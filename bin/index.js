/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./js-compile/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./js-compile/examples/BaseExample.js":
/*!********************************************!*\
  !*** ./js-compile/examples/BaseExample.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Graphics_1 = __webpack_require__(/*! ../raw-pixi-ts/Graphics */ "./js-compile/raw-pixi-ts/Graphics.js");
const Container_1 = __webpack_require__(/*! ../raw-pixi-ts/Container */ "./js-compile/raw-pixi-ts/Container.js");
const EventDispatcher_1 = __webpack_require__(/*! ../raw-pixi-ts/EventDispatcher */ "./js-compile/raw-pixi-ts/EventDispatcher.js");
const Event_1 = __webpack_require__(/*! ../raw-pixi-ts/Event */ "./js-compile/raw-pixi-ts/Event.js");
class BaseExample extends EventDispatcher_1.EventDispatcher {
    constructor(app, width = 100, height = 100) {
        super();
        this.backColor = 0x969696;
        this.sizew = width;
        this.sizeh = height;
        this.app = app;
        this.stage = new Container_1.Container();
    }
    activateMask() {
        this.stageMask = new Graphics_1.Graphics();
        this.stageMask.beginFill(0);
        this.stageMask.drawRect(0, 0, this.sizew, this.sizeh);
        this.stage.mask = this.stageMask;
    }
    destructor() {
        this.stage.removeChildren();
        if (this.stageMask) {
            this.stageMask.destroy(null);
        }
    }
    exampleReady() {
        this.dispatchEvent(Event_1.Event.getEvent(Event_1.Event.COMPLETE));
    }
}
exports.BaseExample = BaseExample;


/***/ }),

/***/ "./js-compile/examples/FilterBlending.js":
/*!***********************************************!*\
  !*** ./js-compile/examples/FilterBlending.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseExample_1 = __webpack_require__(/*! ./BaseExample */ "./js-compile/examples/BaseExample.js");
const ResourceLoader_1 = __webpack_require__(/*! ../raw-pixi-ts/ResourceLoader */ "./js-compile/raw-pixi-ts/ResourceLoader.js");
const URLRequest_1 = __webpack_require__(/*! ../raw-pixi-ts/URLRequest */ "./js-compile/raw-pixi-ts/URLRequest.js");
const Event_1 = __webpack_require__(/*! ../raw-pixi-ts/Event */ "./js-compile/raw-pixi-ts/Event.js");
const Texture_1 = __webpack_require__(/*! ../raw-pixi-ts/Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const BaseTexture_1 = __webpack_require__(/*! ../raw-pixi-ts/BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const Sprite_1 = __webpack_require__(/*! ../raw-pixi-ts/Sprite */ "./js-compile/raw-pixi-ts/Sprite.js");
const Container_1 = __webpack_require__(/*! ../raw-pixi-ts/Container */ "./js-compile/raw-pixi-ts/Container.js");
const Rectangle_1 = __webpack_require__(/*! ../raw-pixi-ts/Rectangle */ "./js-compile/raw-pixi-ts/Rectangle.js");
const Filter_1 = __webpack_require__(/*! ../raw-pixi-ts/Filter */ "./js-compile/raw-pixi-ts/Filter.js");
const Point_1 = __webpack_require__(/*! ../raw-pixi-ts/Point */ "./js-compile/raw-pixi-ts/Point.js");
class FilterBlending extends BaseExample_1.BaseExample {
    constructor(app, width, height) {
        super(app, width, height);
        this.handleGrassLoaded = (event) => {
            this.backgroundtxt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            const background = new Sprite_1.Sprite(this.backgroundtxt);
            background.width = this.app.screen.width;
            background.height = this.app.screen.height;
            this.app.stage.addChild(background);
            const shaderFrag = `
            precision highp float;
            varying vec2 vTextureCoord;
            uniform vec2 mouse;
            uniform vec4 inputSize;
            uniform vec4 outputFrame;
            uniform float time;
            void main() {
            vec2 screenPos = vTextureCoord * inputSize.xy + outputFrame.xy;
            if (length(mouse - screenPos) < 25.0) {
                gl_FragColor = vec4(1.0, 1.0, 0.0, 1.0) * 0.7; //yellow circle, alpha=0.7
            } else {
                gl_FragColor = vec4( sin(time), (mouse.xy - outputFrame.xy) / outputFrame.zw, 1.0) * 0.5; // blend with underlying image, alpha=0.5
            }
            }
            `;
            const container = new Container_1.Container();
            container.filterArea = new Rectangle_1.Rectangle(100, 100, this.app.screen.width - 200, this.app.screen.height - 200);
            this.app.stage.addChild(container);
            this.filter = new Filter_1.Filter(null, shaderFrag, {
                mouse: new Point_1.Point()
            });
            container.filters = [this.filter];
            this.app.ticker.add(this.runExample);
        };
        this.runExample = (delta) => {
            this.filter.uniforms.mouse.copyFrom(this.app.renderer.plugins.interaction.mouse.global);
        };
        this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/bg_grass.jpg"));
        this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleGrassLoaded);
        this.loader.load();
    }
}
exports.FilterBlending = FilterBlending;


/***/ }),

/***/ "./js-compile/examples/FilterBlur.js":
/*!*******************************************!*\
  !*** ./js-compile/examples/FilterBlur.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseExample_1 = __webpack_require__(/*! ./BaseExample */ "./js-compile/examples/BaseExample.js");
const ResourceLoader_1 = __webpack_require__(/*! ../raw-pixi-ts/ResourceLoader */ "./js-compile/raw-pixi-ts/ResourceLoader.js");
const Texture_1 = __webpack_require__(/*! ../raw-pixi-ts/Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const URLRequest_1 = __webpack_require__(/*! ../raw-pixi-ts/URLRequest */ "./js-compile/raw-pixi-ts/URLRequest.js");
const Event_1 = __webpack_require__(/*! ../raw-pixi-ts/Event */ "./js-compile/raw-pixi-ts/Event.js");
const BaseTexture_1 = __webpack_require__(/*! ../raw-pixi-ts/BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const Sprite_1 = __webpack_require__(/*! ../raw-pixi-ts/Sprite */ "./js-compile/raw-pixi-ts/Sprite.js");
const BlurFilter_1 = __webpack_require__(/*! ../raw-pixi-ts/BlurFilter */ "./js-compile/raw-pixi-ts/BlurFilter.js");
class FilterBlur extends BaseExample_1.BaseExample {
    constructor(app, width, height) {
        super(app, width, height);
        this.handleMobyLoaded = (event) => {
            this.mobyTxt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            const bg = new Sprite_1.Sprite(this.depthTxt);
            bg.width = this.sizew;
            bg.height = this.sizeh;
            this.stage.addChild(bg);
            const littleDudes = new Sprite_1.Sprite(this.dudesTxt);
            littleDudes.x = (this.sizew / 2) - 315;
            littleDudes.y = 200;
            this.stage.addChild(littleDudes);
            const littleRobot = new Sprite_1.Sprite(this.mobyTxt);
            littleRobot.x = (this.sizew / 2) - 200;
            littleRobot.y = 100;
            this.stage.addChild(littleRobot);
            this.blurFilter1 = new BlurFilter_1.BlurFilter();
            this.blurFilter2 = new BlurFilter_1.BlurFilter();
            littleDudes.filters = [this.blurFilter1];
            littleRobot.filters = [this.blurFilter2];
            this.count = 0;
            this.app.ticker.add(this.runExample);
            this.exampleReady();
        };
        this.runExample = (delta) => {
            this.count += 0.005;
            const blurAmount = Math.cos(this.count);
            const blurAmount2 = Math.sin(this.count);
            this.blurFilter1.blur = 20 * (blurAmount);
            this.blurFilter2.blur = 20 * (blurAmount2);
        };
        this.handleDudesLoaded = (event) => {
            this.dudesTxt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/pixi-filters/depth_blur_moby.jpg"));
            this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleMobyLoaded);
            this.loader.load();
        };
        this.handleDepthLoaded = (event) => {
            this.depthTxt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/pixi-filters/depth_blur_dudes.jpg"));
            this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleDudesLoaded);
            this.loader.load();
        };
        this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/pixi-filters/bg_depth_blur.jpg"));
        this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleDepthLoaded);
        this.loader.load();
    }
    destructor() {
        super.destructor();
        this.app.ticker.remove(this.runExample, null);
        this.blurFilter1.destroy();
        this.blurFilter1 = null;
        this.blurFilter2.destroy();
        this.blurFilter2 = null;
        this.mobyTxt.destroy(null);
        this.mobyTxt = null;
        this.dudesTxt.destroy(null);
        this.dudesTxt = null;
        this.depthTxt.destroy(null);
        this.depthTxt = null;
    }
}
exports.FilterBlur = FilterBlur;


/***/ }),

/***/ "./js-compile/examples/FilterColor.js":
/*!********************************************!*\
  !*** ./js-compile/examples/FilterColor.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseExample_1 = __webpack_require__(/*! ./BaseExample */ "./js-compile/examples/BaseExample.js");
const ResourceLoader_1 = __webpack_require__(/*! ../raw-pixi-ts/ResourceLoader */ "./js-compile/raw-pixi-ts/ResourceLoader.js");
const Texture_1 = __webpack_require__(/*! ../raw-pixi-ts/Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const URLRequest_1 = __webpack_require__(/*! ../raw-pixi-ts/URLRequest */ "./js-compile/raw-pixi-ts/URLRequest.js");
const Event_1 = __webpack_require__(/*! ../raw-pixi-ts/Event */ "./js-compile/raw-pixi-ts/Event.js");
const BaseTexture_1 = __webpack_require__(/*! ../raw-pixi-ts/BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const Sprite_1 = __webpack_require__(/*! ../raw-pixi-ts/Sprite */ "./js-compile/raw-pixi-ts/Sprite.js");
const ColorMatrixFilter_1 = __webpack_require__(/*! ../raw-pixi-ts/ColorMatrixFilter */ "./js-compile/raw-pixi-ts/ColorMatrixFilter.js");
const Text_1 = __webpack_require__(/*! ../raw-pixi-ts/Text */ "./js-compile/raw-pixi-ts/Text.js");
const Container_1 = __webpack_require__(/*! ../raw-pixi-ts/Container */ "./js-compile/raw-pixi-ts/Container.js");
const MouseEvent_1 = __webpack_require__(/*! ../raw-pixi-ts/MouseEvent */ "./js-compile/raw-pixi-ts/MouseEvent.js");
class FilterColor extends BaseExample_1.BaseExample {
    constructor(app, width, height) {
        super(app, width, height);
        this.handlePandaLoaded = (event) => {
            this.pandaTxt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            this.bg = new Sprite_1.Sprite(this.rotateTxt);
            this.bg.anchor.set(0.5);
            this.bg.x = this.app.screen.width / 2;
            this.bg.y = this.app.screen.height / 2;
            this.filter = new ColorMatrixFilter_1.ColorMatrixFilter();
            const container = new Container_1.Container();
            container.x = this.app.screen.width / 2;
            container.y = this.app.screen.height / 2;
            this.bgFront = new Sprite_1.Sprite(this.scenerotateTxt);
            this.bgFront.anchor.set(0.5);
            container.addChild(this.bgFront);
            this.light2 = new Sprite_1.Sprite(this.lightrotate2Txt);
            this.light2.anchor.set(0.5);
            container.addChild(this.light2);
            this.light1 = new Sprite_1.Sprite(this.lightrotate1Txt);
            this.light1.anchor.set(0.5);
            container.addChild(this.light1);
            this.panda = new Sprite_1.Sprite(this.pandaTxt);
            this.panda.anchor.set(0.5);
            container.addChild(this.panda);
            this.app.stage.addChild(container);
            this.app.stage.filters = [this.filter];
            this.count = 0;
            this.enabled = true;
            this.app.stage.addEventListener(MouseEvent_1.MouseEvent.POINTER_TAP, this.handlePointer);
            const help = new Text_1.Text('Click or tap to turn filters on / off.', {
                fontFamily: 'Arial',
                fontSize: 12,
                fontWeight: 'bold',
                fill: 'white',
            });
            help.y = this.app.screen.height - 25;
            help.x = 10;
            this.app.stage.addChild(help);
            this.app.ticker.add(this.runExample);
        };
        this.runExample = (delta) => {
            this.bg.rotation += 0.01;
            this.bgFront.rotation -= 0.01;
            this.light1.rotation += 0.02;
            this.light2.rotation += 0.01;
            this.panda.scale.x = 1 + Math.sin(this.count) * 0.04;
            this.panda.scale.y = 1 + Math.cos(this.count) * 0.04;
            this.count += 0.1;
            const { matrix } = this.filter;
            matrix[1] = Math.sin(this.count) * 3;
            matrix[2] = Math.cos(this.count);
            matrix[3] = Math.cos(this.count) * 1.5;
            matrix[4] = Math.sin(this.count / 3) * 2;
            matrix[5] = Math.sin(this.count / 2);
            matrix[6] = Math.sin(this.count / 4);
        };
        this.handlePointer = (event) => {
            this.enabled = !this.enabled;
            this.app.stage.filters = this.enabled ? [this.filter] : null;
        };
        this.handleLightRotate1Loaded = (event) => {
            this.lightrotate1Txt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/light_rotate_1.png"));
            this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleLightRotate1Loaded);
            this.loader.load();
        };
        this.handleRotateLoaded = (event) => {
            this.rotateTxt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/bg_scene_rotate.jpg"));
            this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleSceneRotateLoaded);
            this.loader.load();
        };
        this.handleSceneRotateLoaded = (event) => {
            this.scenerotateTxt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/light_rotate_2.png"));
            this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleLightRotate2Loaded);
            this.loader.load();
        };
        this.handleLightRotate2Loaded = (event) => {
            this.lightrotate2Txt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/panda.png"));
            this.loader.addEventListener(Event_1.Event.COMPLETE, this.handlePandaLoaded);
            this.loader.load();
        };
        app.stage.interactive = true;
        this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/bg_rotate.jpg"));
        this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleRotateLoaded);
        this.loader.load();
    }
}
exports.FilterColor = FilterColor;


/***/ }),

/***/ "./js-compile/examples/FilterCrawlies.js":
/*!***********************************************!*\
  !*** ./js-compile/examples/FilterCrawlies.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseExample_1 = __webpack_require__(/*! ./BaseExample */ "./js-compile/examples/BaseExample.js");
const ResourceLoader_1 = __webpack_require__(/*! ../raw-pixi-ts/ResourceLoader */ "./js-compile/raw-pixi-ts/ResourceLoader.js");
const Texture_1 = __webpack_require__(/*! ../raw-pixi-ts/Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const Container_1 = __webpack_require__(/*! ../raw-pixi-ts/Container */ "./js-compile/raw-pixi-ts/Container.js");
const Rectangle_1 = __webpack_require__(/*! ../raw-pixi-ts/Rectangle */ "./js-compile/raw-pixi-ts/Rectangle.js");
const MouseEvent_1 = __webpack_require__(/*! ../raw-pixi-ts/MouseEvent */ "./js-compile/raw-pixi-ts/MouseEvent.js");
const Sprite_1 = __webpack_require__(/*! ../raw-pixi-ts/Sprite */ "./js-compile/raw-pixi-ts/Sprite.js");
const URLRequest_1 = __webpack_require__(/*! ../raw-pixi-ts/URLRequest */ "./js-compile/raw-pixi-ts/URLRequest.js");
const Event_1 = __webpack_require__(/*! ../raw-pixi-ts/Event */ "./js-compile/raw-pixi-ts/Event.js");
const BaseTexture_1 = __webpack_require__(/*! ../raw-pixi-ts/BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const Point_1 = __webpack_require__(/*! ../raw-pixi-ts/Point */ "./js-compile/raw-pixi-ts/Point.js");
const DisplacementFilter_1 = __webpack_require__(/*! ../raw-pixi-ts/DisplacementFilter */ "./js-compile/raw-pixi-ts/DisplacementFilter.js");
class FilterCrawlies extends BaseExample_1.BaseExample {
    constructor(app, width, height) {
        super(app, width, height);
        this.handleGrassLoaded = (event) => {
            this.grassTxt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            this.container = new Container_1.Container();
            this.app.stage.addChild(this.container);
            const padding = 100;
            this.bounds = new Rectangle_1.Rectangle(-padding, -padding, this.app.screen.width + padding * 2, this.app.screen.height + padding * 2);
            for (let i = 0; i < 20; i++) {
                const maggot = new ExtendedSprite(this.maggotTxt);
                maggot.anchor.set(0.5);
                this.container.addChild(maggot);
                maggot.direction = Math.random() * Math.PI * 2;
                maggot.speed = 1;
                maggot.turnSpeed = Math.random() - 0.8;
                maggot.x = Math.random() * this.bounds.width;
                maggot.y = Math.random() * this.bounds.height;
                maggot.scale.set(1 + Math.random() * 0.3);
                maggot.original = new Point_1.Point();
                maggot.original.copyFrom(maggot.scale);
                this.maggots.push(maggot);
            }
            this.displacementSprite = new Sprite_1.Sprite(this.displacementTxt);
            const displacementFilter = new DisplacementFilter_1.DisplacementFilter(this.displacementSprite);
            this.app.stage.addChild(this.displacementSprite);
            this.container.filters = [displacementFilter];
            displacementFilter.scale.x = 110;
            displacementFilter.scale.y = 110;
            this.displacementSprite.anchor.set(0.5);
            this.ring = new Sprite_1.Sprite(this.ringTxt);
            this.ring.anchor.set(0.5);
            this.ring.visible = false;
            this.app.stage.addChild(this.ring);
            const bg = new Sprite_1.Sprite(this.grassTxt);
            bg.width = this.app.screen.width;
            bg.height = this.app.screen.height;
            bg.alpha = 0.4;
            this.container.addChild(bg);
            this.app.stage.addEventListener(MouseEvent_1.MouseEvent.MOUSE_MOVE, this.onPointerMove);
            this.app.stage.addEventListener(MouseEvent_1.MouseEvent.TOUCH_MOVE, this.onPointerMove);
            this.app.ticker.add(this.runExample);
        };
        this.handleMaggotLoaded = (event) => {
            this.maggotTxt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest('examples/assets/bg_grass.jpg'));
            this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleGrassLoaded);
            this.loader.load();
        };
        this.handleRingLoaded = (event) => {
            this.ringTxt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest('examples/assets/maggot.png'));
            this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleMaggotLoaded);
            this.loader.load();
        };
        this.handleDisplacementLoaded = (event) => {
            this.displacementTxt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest('examples/assets/pixi-filters/ring.png'));
            this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleRingLoaded);
            this.loader.load();
        };
        this.handleRotateLoaded = (event) => {
            this.maggotTxt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest('examples/assets/pixi-filters/displace.png'));
            this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleDisplacementLoaded);
            this.loader.load();
        };
        this.onPointerMove = (event) => {
            this.ring.visible = true;
            this.displacementSprite.position.set(event.data.global.x - 25, event.data.global.y);
            this.ring.position.copyFrom(this.displacementSprite.position);
        };
        this.runExample = (delta) => {
            this.count += 0.05;
            for (let i = 0; i < this.maggots.length; i++) {
                const maggot = this.maggots[i];
                maggot.direction += maggot.turnSpeed * 0.01;
                maggot.x += Math.sin(maggot.direction) * maggot.speed;
                maggot.y += Math.cos(maggot.direction) * maggot.speed;
                maggot.rotation = -maggot.direction - Math.PI / 2;
                maggot.scale.x = maggot.original.x + Math.sin(this.count) * 0.2;
                if (maggot.x < this.bounds.x) {
                    maggot.x += this.bounds.width;
                }
                else if (maggot.x > this.bounds.x + this.bounds.width) {
                    maggot.x -= this.bounds.width;
                }
                if (maggot.y < this.bounds.y) {
                    maggot.y += this.bounds.height;
                }
                else if (maggot.y > this.bounds.y + this.bounds.height) {
                    maggot.y -= this.bounds.height;
                }
            }
        };
        this.count = 0;
        this.maggots = [];
        app.stage.interactive = true;
        this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/bg_rotate.jpg"));
        this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleRotateLoaded);
        this.loader.load();
    }
}
exports.FilterCrawlies = FilterCrawlies;
class ExtendedSprite extends Sprite_1.Sprite {
}


/***/ }),

/***/ "./js-compile/examples/FilterCustom.js":
/*!*********************************************!*\
  !*** ./js-compile/examples/FilterCustom.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseExample_1 = __webpack_require__(/*! ./BaseExample */ "./js-compile/examples/BaseExample.js");
const ResourceLoader_1 = __webpack_require__(/*! ../raw-pixi-ts/ResourceLoader */ "./js-compile/raw-pixi-ts/ResourceLoader.js");
const Texture_1 = __webpack_require__(/*! ../raw-pixi-ts/Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const URLRequest_1 = __webpack_require__(/*! ../raw-pixi-ts/URLRequest */ "./js-compile/raw-pixi-ts/URLRequest.js");
const Event_1 = __webpack_require__(/*! ../raw-pixi-ts/Event */ "./js-compile/raw-pixi-ts/Event.js");
const BaseTexture_1 = __webpack_require__(/*! ../raw-pixi-ts/BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const Sprite_1 = __webpack_require__(/*! ../raw-pixi-ts/Sprite */ "./js-compile/raw-pixi-ts/Sprite.js");
const URLLoader_1 = __webpack_require__(/*! ../raw-pixi-ts/URLLoader */ "./js-compile/raw-pixi-ts/URLLoader.js");
const Filter_1 = __webpack_require__(/*! ../raw-pixi-ts/Filter */ "./js-compile/raw-pixi-ts/Filter.js");
const Logger_1 = __webpack_require__(/*! ../raw-pixi-ts/Logger */ "./js-compile/raw-pixi-ts/Logger.js");
class FilterCustom extends BaseExample_1.BaseExample {
    constructor(app, width, height) {
        super(app, width, height);
        this.handleGrassLoaded = (event) => {
            this.grasstxt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            this.background = new Sprite_1.Sprite(this.grasstxt);
            this.background.width = this.app.screen.width;
            this.background.height = this.app.screen.height;
            this.app.stage.addChild(this.background);
            this.urlloader = new URLLoader_1.URLLoader();
            this.urlloader.addEventListener(Event_1.Event.COMPLETE, this.handleFragLoaded);
            this.urlloader.load(new URLRequest_1.URLRequest("examples/assets/pixi-filters/shader.frag"));
        };
        this.handleFragLoaded = (event) => {
            let fragdata = this.urlloader.data;
            Logger_1.trace(fragdata);
            this.filter = new Filter_1.Filter(null, fragdata, {
                customUniform: 0.0
            });
            this.background.filters = [this.filter];
            this.app.ticker.add(this.runExample);
        };
        this.runExample = (delta) => {
            this.filter.uniforms.customUniform += 0.04 * delta;
        };
        this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/bg_grass.jpg"));
        this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleGrassLoaded);
        this.loader.load();
    }
}
exports.FilterCustom = FilterCustom;


/***/ }),

/***/ "./js-compile/examples/FilterFlag.js":
/*!*******************************************!*\
  !*** ./js-compile/examples/FilterFlag.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseExample_1 = __webpack_require__(/*! ./BaseExample */ "./js-compile/examples/BaseExample.js");
const Container_1 = __webpack_require__(/*! ../raw-pixi-ts/Container */ "./js-compile/raw-pixi-ts/Container.js");
const ResourceLoader_1 = __webpack_require__(/*! ../raw-pixi-ts/ResourceLoader */ "./js-compile/raw-pixi-ts/ResourceLoader.js");
const Texture_1 = __webpack_require__(/*! ../raw-pixi-ts/Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const URLRequest_1 = __webpack_require__(/*! ../raw-pixi-ts/URLRequest */ "./js-compile/raw-pixi-ts/URLRequest.js");
const Event_1 = __webpack_require__(/*! ../raw-pixi-ts/Event */ "./js-compile/raw-pixi-ts/Event.js");
const BaseTexture_1 = __webpack_require__(/*! ../raw-pixi-ts/BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const Sprite_1 = __webpack_require__(/*! ../raw-pixi-ts/Sprite */ "./js-compile/raw-pixi-ts/Sprite.js");
const WebGLSettings_1 = __webpack_require__(/*! ../raw-pixi-ts/WebGLSettings */ "./js-compile/raw-pixi-ts/WebGLSettings.js");
const DisplacementFilter_1 = __webpack_require__(/*! ../raw-pixi-ts/DisplacementFilter */ "./js-compile/raw-pixi-ts/DisplacementFilter.js");
class FilterFlag extends BaseExample_1.BaseExample {
    constructor(app, width, height) {
        super(app, width, height);
        this.handleDisplacementLoaded = (event) => {
            this.repeatTxt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            const container = new Container_1.Container();
            this.app.stage.addChild(container);
            const flag = new Sprite_1.Sprite(this.flagTxt);
            container.addChild(flag);
            flag.x = 100;
            flag.y = 100;
            this.displacementSprite = new Sprite_1.Sprite(this.repeatTxt);
            this.displacementSprite.texture.baseTexture.wrapMode = WebGLSettings_1.WebGLSettings.WRAP_MODES.REPEAT;
            const displacementFilter = new DisplacementFilter_1.DisplacementFilter(this.displacementSprite);
            displacementFilter.padding = 10;
            this.displacementSprite.position = flag.position;
            this.app.stage.addChild(this.displacementSprite);
            flag.filters = [displacementFilter];
            displacementFilter.scale.x = 30;
            displacementFilter.scale.y = 60;
            this.app.ticker.add(this.runExample);
        };
        this.runExample = (delta) => {
            this.displacementSprite.x++;
            if (this.displacementSprite.x > this.displacementSprite.width) {
                this.displacementSprite.x = 0;
            }
        };
        this.handleRotateLoaded = (event) => {
            this.flagTxt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest('examples/assets/pixi-filters/displacement_map_repeat.jpg'));
            this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleDisplacementLoaded);
            this.loader.load();
        };
        app.stage.interactive = true;
        this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/pixi-filters/flag.png"));
        this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleRotateLoaded);
        this.loader.load();
    }
}
exports.FilterFlag = FilterFlag;


/***/ }),

/***/ "./js-compile/examples/FilterShadow.js":
/*!*********************************************!*\
  !*** ./js-compile/examples/FilterShadow.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseExample_1 = __webpack_require__(/*! ./BaseExample */ "./js-compile/examples/BaseExample.js");
const URLLoader_1 = __webpack_require__(/*! ../raw-pixi-ts/URLLoader */ "./js-compile/raw-pixi-ts/URLLoader.js");
const Event_1 = __webpack_require__(/*! ../raw-pixi-ts/Event */ "./js-compile/raw-pixi-ts/Event.js");
const URLRequest_1 = __webpack_require__(/*! ../raw-pixi-ts/URLRequest */ "./js-compile/raw-pixi-ts/URLRequest.js");
const ResourceLoader_1 = __webpack_require__(/*! ../raw-pixi-ts/ResourceLoader */ "./js-compile/raw-pixi-ts/ResourceLoader.js");
const Texture_1 = __webpack_require__(/*! ../raw-pixi-ts/Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const BaseTexture_1 = __webpack_require__(/*! ../raw-pixi-ts/BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const Spritesheet_1 = __webpack_require__(/*! ../raw-pixi-ts/Spritesheet */ "./js-compile/raw-pixi-ts/Spritesheet.js");
const AnimatedSprite_1 = __webpack_require__(/*! ../raw-pixi-ts/AnimatedSprite */ "./js-compile/raw-pixi-ts/AnimatedSprite.js");
const Filter_1 = __webpack_require__(/*! ../raw-pixi-ts/Filter */ "./js-compile/raw-pixi-ts/Filter.js");
class FilterShadow extends BaseExample_1.BaseExample {
    constructor(app, width, height) {
        super(app, width, height);
        this.onAnimationParsed = (textures) => {
            this.app.stage.interactive = true;
            const frames = [];
            for (let i = 0; i < 30; i++) {
                const val = i < 10 ? `0${i}` : i;
                frames.push(textures[`rollSequence00${val}.png`]);
            }
            this.anim = new AnimatedSprite_1.AnimatedSprite(frames);
            this.anim.x = this.app.screen.width / 2;
            this.anim.y = this.app.screen.height / 2;
            this.anim.anchor.set(0.5);
            this.anim.animationSpeed = 0.5;
            this.anim.play();
            this.app.stage.addChild(this.anim);
            this.filter = new Filter_1.Filter(FilterShadow.myVertex, FilterShadow.myFragment);
            this.filter.uniforms.shadowDirection = [0.1, 0.5];
            this.filter.uniforms.floorY = this.anim.height * 2;
            this.filter.padding = 200;
            this.anim.filters = [this.filter];
            this.app.ticker.add(this.runExample);
        };
        this.runExample = (delta) => {
            this.filter.uniforms.floorY = this.app.renderer.plugins.interaction.mouse.global.y;
        };
        this.handleJsonLoaded = (event) => {
            this.jsondata = JSON.parse(this.urlloader.data);
            this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/spritesheet/fighter.png"));
            this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleRotateLoaded);
            this.loader.load();
        };
        this.handleRotateLoaded = (event) => {
            this.txt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            let spritesheet = new Spritesheet_1.Spritesheet(this.txt, this.jsondata);
            spritesheet.parse(this.onAnimationParsed);
        };
        this.urlloader = new URLLoader_1.URLLoader();
        this.urlloader.addEventListener(Event_1.Event.COMPLETE, this.handleJsonLoaded);
        this.urlloader.load(new URLRequest_1.URLRequest("examples/assets/spritesheet/fighter.json"));
    }
}
FilterShadow.myVertex = `
        attribute vec2 aVertexPosition;
        attribute vec2 aTextureCoord;
        uniform mat3 projectionMatrix;
        varying vec2 vTextureCoord;
        void main(void) {
            gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);
            vTextureCoord = aTextureCoord;
        }
    `;
FilterShadow.myFragment = `
        varying vec2 vTextureCoord;
        uniform sampler2D uSampler;
        uniform vec4 inputSize;
        uniform vec4 outputFrame;
        uniform vec2 shadowDirection;
        uniform float floorY;
        void main(void) {
            //1. get the screen coordinate
            vec2 screenCoord = vTextureCoord * inputSize.xy + outputFrame.xy;
            //2. calculate Y shift of our dimension vector
            vec2 shadow;
            //shadow coordinate system is a bit skewed, but it has to be the same for screenCoord.y = floorY
            float paramY = (screenCoord.y - floorY) / shadowDirection.y;
            shadow.y = paramY + floorY;
            shadow.x = screenCoord.x + paramY * shadowDirection.x;
            vec2 bodyFilterCoord = (shadow - outputFrame.xy) * inputSize.zw; // same as / inputSize.xy
            vec4 originalColor = texture2D(uSampler, vTextureCoord);
            vec4 shadowColor = texture2D(uSampler, bodyFilterCoord);
            shadowColor.rgb = vec3(0.0);
            shadowColor.a *= 0.5;
            // normal blend mode coefficients (1, 1-src_alpha)
            // shadow is destination (backdrop), original is source
            gl_FragColor = originalColor + shadowColor * (1.0 - originalColor.a);
        }
    `;
exports.FilterShadow = FilterShadow;


/***/ }),

/***/ "./js-compile/examples/MaskFilter.js":
/*!*******************************************!*\
  !*** ./js-compile/examples/MaskFilter.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseExample_1 = __webpack_require__(/*! ./BaseExample */ "./js-compile/examples/BaseExample.js");
const ResourceLoader_1 = __webpack_require__(/*! ../raw-pixi-ts/ResourceLoader */ "./js-compile/raw-pixi-ts/ResourceLoader.js");
const Texture_1 = __webpack_require__(/*! ../raw-pixi-ts/Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const URLRequest_1 = __webpack_require__(/*! ../raw-pixi-ts/URLRequest */ "./js-compile/raw-pixi-ts/URLRequest.js");
const Event_1 = __webpack_require__(/*! ../raw-pixi-ts/Event */ "./js-compile/raw-pixi-ts/Event.js");
const BaseTexture_1 = __webpack_require__(/*! ../raw-pixi-ts/BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const Graphics_1 = __webpack_require__(/*! ../raw-pixi-ts/Graphics */ "./js-compile/raw-pixi-ts/Graphics.js");
const BlurFilter_1 = __webpack_require__(/*! ../raw-pixi-ts/BlurFilter */ "./js-compile/raw-pixi-ts/BlurFilter.js");
const Rectangle_1 = __webpack_require__(/*! ../raw-pixi-ts/Rectangle */ "./js-compile/raw-pixi-ts/Rectangle.js");
const WebGLSettings_1 = __webpack_require__(/*! ../raw-pixi-ts/WebGLSettings */ "./js-compile/raw-pixi-ts/WebGLSettings.js");
const Sprite_1 = __webpack_require__(/*! ../raw-pixi-ts/Sprite */ "./js-compile/raw-pixi-ts/Sprite.js");
const MouseEvent_1 = __webpack_require__(/*! ../raw-pixi-ts/MouseEvent */ "./js-compile/raw-pixi-ts/MouseEvent.js");
class MaskFilter extends BaseExample_1.BaseExample {
    constructor(app, width, height) {
        super(app, width, height);
        this.handleRotateLoaded = (event) => {
            this.flagTxt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            const radius = 100;
            const blurSize = 32;
            const background = new Sprite_1.Sprite(this.flagTxt);
            this.app.stage.addChild(background);
            background.width = this.app.screen.width;
            background.height = this.app.screen.height;
            const circle = new Graphics_1.Graphics()
                .beginFill(0xFF0000)
                .drawCircle(radius + blurSize, radius + blurSize, radius)
                .endFill();
            circle.filters = [new BlurFilter_1.BlurFilter(blurSize)];
            const bounds = new Rectangle_1.Rectangle(0, 0, (radius + blurSize) * 2, (radius + blurSize) * 2);
            const texture = this.app.renderer.generateTexture(circle, WebGLSettings_1.WebGLSettings.SCALE_MODES.NEAREST, 1, bounds);
            this.focus = new Sprite_1.Sprite(texture);
            this.app.stage.addChild(this.focus);
            background.mask = this.focus;
            this.app.stage.interactive = true;
            this.app.stage.addEventListener(MouseEvent_1.MouseEvent.MOUSE_MOVE, this.pointerMove);
        };
        this.pointerMove = (event) => {
            this.focus.position.x = event.data.global.x - this.focus.width / 2;
            this.focus.position.y = event.data.global.y - this.focus.height / 2;
        };
        this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/bg_grass.jpg"));
        this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleRotateLoaded);
        this.loader.load();
    }
}
exports.MaskFilter = MaskFilter;


/***/ }),

/***/ "./js-compile/examples/MeshAdvanced.js":
/*!*********************************************!*\
  !*** ./js-compile/examples/MeshAdvanced.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseExample_1 = __webpack_require__(/*! ./BaseExample */ "./js-compile/examples/BaseExample.js");
const Texture_1 = __webpack_require__(/*! ../raw-pixi-ts/Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const BaseTexture_1 = __webpack_require__(/*! ../raw-pixi-ts/BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const Event_1 = __webpack_require__(/*! ../raw-pixi-ts/Event */ "./js-compile/raw-pixi-ts/Event.js");
const ResourceLoader_1 = __webpack_require__(/*! ../raw-pixi-ts/ResourceLoader */ "./js-compile/raw-pixi-ts/ResourceLoader.js");
const URLRequest_1 = __webpack_require__(/*! ../raw-pixi-ts/URLRequest */ "./js-compile/raw-pixi-ts/URLRequest.js");
const Point_1 = __webpack_require__(/*! ../raw-pixi-ts/Point */ "./js-compile/raw-pixi-ts/Point.js");
const SimpleRope_1 = __webpack_require__(/*! ../raw-pixi-ts/SimpleRope */ "./js-compile/raw-pixi-ts/SimpleRope.js");
const Graphics_1 = __webpack_require__(/*! ../raw-pixi-ts/Graphics */ "./js-compile/raw-pixi-ts/Graphics.js");
class MeshAdvanced extends BaseExample_1.BaseExample {
    constructor(app, width, height) {
        super(app, width, height);
        this.runExample = (delta) => {
            this.count += 0.1;
            for (let i = 0; i < this.points.length; i++) {
                this.points[i].y = Math.sin((i * 0.5) + this.count) * 30;
                this.points[i].x = i * this.ropeLength + Math.cos((i * 0.3) + this.count) * 20;
            }
            this.renderPoints();
        };
        this.handlePlaneLoaded = (event) => {
            this.planeTxt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            this.count = 0;
            this.ropeLength = 45;
            this.points = [];
            for (let i = 0; i < 25; i++) {
                this.points.push(new Point_1.Point(i * this.ropeLength, 0));
            }
            const strip = new SimpleRope_1.SimpleRope(this.planeTxt, this.points);
            strip.x = -40;
            strip.y = 300;
            this.app.stage.addChild(strip);
            this.g = new Graphics_1.Graphics();
            this.g.x = strip.x;
            this.g.y = strip.y;
            this.app.stage.addChild(this.g);
            this.app.ticker.add(this.runExample);
        };
        this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/snake.png"));
        this.loader.addEventListener(Event_1.Event.COMPLETE, this.handlePlaneLoaded);
        this.loader.load();
    }
    renderPoints() {
        this.g.clear();
        this.g.lineStyle(2, 0xffc2c2);
        this.g.moveTo(this.points[0].x, this.points[0].y);
        for (let i = 1; i < this.points.length; i++) {
            this.g.lineTo(this.points[i].x, this.points[i].y);
        }
        for (let i = 1; i < this.points.length; i++) {
            this.g.beginFill(0xff0022);
            this.g.drawCircle(this.points[i].x, this.points[i].y, 10);
            this.g.endFill();
        }
    }
}
exports.MeshAdvanced = MeshAdvanced;


/***/ }),

/***/ "./js-compile/examples/MeshBasic.js":
/*!******************************************!*\
  !*** ./js-compile/examples/MeshBasic.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseExample_1 = __webpack_require__(/*! ./BaseExample */ "./js-compile/examples/BaseExample.js");
const ResourceLoader_1 = __webpack_require__(/*! ../raw-pixi-ts/ResourceLoader */ "./js-compile/raw-pixi-ts/ResourceLoader.js");
const Texture_1 = __webpack_require__(/*! ../raw-pixi-ts/Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const URLRequest_1 = __webpack_require__(/*! ../raw-pixi-ts/URLRequest */ "./js-compile/raw-pixi-ts/URLRequest.js");
const Event_1 = __webpack_require__(/*! ../raw-pixi-ts/Event */ "./js-compile/raw-pixi-ts/Event.js");
const BaseTexture_1 = __webpack_require__(/*! ../raw-pixi-ts/BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const Point_1 = __webpack_require__(/*! ../raw-pixi-ts/Point */ "./js-compile/raw-pixi-ts/Point.js");
const SimpleRope_1 = __webpack_require__(/*! ../raw-pixi-ts/SimpleRope */ "./js-compile/raw-pixi-ts/SimpleRope.js");
const Container_1 = __webpack_require__(/*! ../raw-pixi-ts/Container */ "./js-compile/raw-pixi-ts/Container.js");
class MeshBasic extends BaseExample_1.BaseExample {
    constructor(app, width, height) {
        super(app, width, height);
        this.runExample = (delta) => {
            this.count += 0.1;
            for (let i = 0; i < this.points.length; i++) {
                this.points[i].y = Math.sin((i * 0.5) + this.count) * 30;
                this.points[i].x = i * this.ropeLength + Math.cos((i * 0.3) + this.count) * 20;
            }
        };
        this.handlePlaneLoaded = (event) => {
            this.planeTxt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            this.count = 0;
            this.ropeLength = 918 / 20;
            this.points = [];
            for (let i = 0; i < 20; i++) {
                this.points.push(new Point_1.Point(i * this.ropeLength, 0));
            }
            const strip = new SimpleRope_1.SimpleRope(this.planeTxt, this.points);
            strip.x = -459;
            const snakeContainer = new Container_1.Container();
            snakeContainer.x = 400;
            snakeContainer.y = 300;
            snakeContainer.scale.set(800 / 1100);
            this.app.stage.addChild(snakeContainer);
            snakeContainer.addChild(strip);
            this.app.ticker.add(this.runExample);
        };
        this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/snake.png"));
        this.loader.addEventListener(Event_1.Event.COMPLETE, this.handlePlaneLoaded);
        this.loader.load();
    }
}
exports.MeshBasic = MeshBasic;


/***/ }),

/***/ "./js-compile/examples/MeshColoredTriangle.js":
/*!****************************************************!*\
  !*** ./js-compile/examples/MeshColoredTriangle.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseExample_1 = __webpack_require__(/*! ./BaseExample */ "./js-compile/examples/BaseExample.js");
const Geometry_1 = __webpack_require__(/*! ../raw-pixi-ts/Geometry */ "./js-compile/raw-pixi-ts/Geometry.js");
const Program_1 = __webpack_require__(/*! ../raw-pixi-ts/Program */ "./js-compile/raw-pixi-ts/Program.js");
const Shader_1 = __webpack_require__(/*! ../raw-pixi-ts/Shader */ "./js-compile/raw-pixi-ts/Shader.js");
const Mesh_1 = __webpack_require__(/*! ../raw-pixi-ts/Mesh */ "./js-compile/raw-pixi-ts/Mesh.js");
class MeshColoredTriangle extends BaseExample_1.BaseExample {
    constructor(app, width, height) {
        super(app, width, height);
        this.runExample = (delta) => {
            this.triangle.rotation += 0.01;
        };
        const geometry = new Geometry_1.Geometry();
        geometry.addAttribute('aVertexPosition', // the attribute name
        [-100, -50,
            100, -50,
            0.0, 100.0], // x, y
        2); // the size of the attribute
        geometry.addAttribute('aColor', // the attribute name
        [1, 0, 0,
            0, 1, 0,
            0, 0, 1], // r, g, b
        3); // the size of the attribute
        let vx = `
            precision mediump float;
            attribute vec2 aVertexPosition;
            attribute vec3 aColor;    
            uniform mat3 translationMatrix;
            uniform mat3 projectionMatrix;    
            varying vec3 vColor;    
            void main() {    
                vColor = aColor;
                gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);    
            }`;
        let fx = `precision mediump float;
            varying vec3 vColor;    
            void main() {
                gl_FragColor = vec4(vColor, 1.0);
            }    
            `;
        let program = new Program_1.Program(vx, fx);
        const shader = new Shader_1.Shader(program, null);
        this.triangle = new Mesh_1.Mesh(geometry, shader);
        this.triangle.position.set(400, 300);
        this.triangle.scale.set(2);
        app.stage.addChild(this.triangle);
        this.app.ticker.add(this.runExample);
    }
}
exports.MeshColoredTriangle = MeshColoredTriangle;


/***/ }),

/***/ "./js-compile/examples/MeshGeometry.js":
/*!*********************************************!*\
  !*** ./js-compile/examples/MeshGeometry.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseExample_1 = __webpack_require__(/*! ./BaseExample */ "./js-compile/examples/BaseExample.js");
const ResourceLoader_1 = __webpack_require__(/*! ../raw-pixi-ts/ResourceLoader */ "./js-compile/raw-pixi-ts/ResourceLoader.js");
const Texture_1 = __webpack_require__(/*! ../raw-pixi-ts/Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const URLRequest_1 = __webpack_require__(/*! ../raw-pixi-ts/URLRequest */ "./js-compile/raw-pixi-ts/URLRequest.js");
const Event_1 = __webpack_require__(/*! ../raw-pixi-ts/Event */ "./js-compile/raw-pixi-ts/Event.js");
const BaseTexture_1 = __webpack_require__(/*! ../raw-pixi-ts/BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const Geometry_1 = __webpack_require__(/*! ../raw-pixi-ts/Geometry */ "./js-compile/raw-pixi-ts/Geometry.js");
const Program_1 = __webpack_require__(/*! ../raw-pixi-ts/Program */ "./js-compile/raw-pixi-ts/Program.js");
const Mesh_1 = __webpack_require__(/*! ../raw-pixi-ts/Mesh */ "./js-compile/raw-pixi-ts/Mesh.js");
const Shader_1 = __webpack_require__(/*! ../raw-pixi-ts/Shader */ "./js-compile/raw-pixi-ts/Shader.js");
class MeshGeometry extends BaseExample_1.BaseExample {
    constructor(app, width, height) {
        super(app, width, height);
        this.handleTxt3Loaded = (event) => {
            this.txt3 = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            const geometry = new Geometry_1.Geometry();
            geometry.addAttribute('aVertexPosition', // the attribute name
            [-100, -100,
                100, -100,
                100, 100], // x, y
            2); // the size of the attribute    
            geometry.addAttribute('aUvs', // the attribute name
            [0, 0,
                1, 0,
                1, 1], // u, v
            2); // the size of the attribute    
            const program = Program_1.Program.from(`    
            precision mediump float;    
            attribute vec2 aVertexPosition;
            attribute vec2 aUvs;    
            uniform mat3 translationMatrix;
            uniform mat3 projectionMatrix;    
            varying vec2 vUvs;    
            void main() {    
                vUvs = aUvs;
                gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);    
            }`, `precision mediump float;    
            varying vec2 vUvs;    
            uniform sampler2D uSamplerTexture;    
            void main() {    
                gl_FragColor = texture2D(uSamplerTexture, vUvs);
            }    
        `);
            this.triangle = new Mesh_1.Mesh(geometry, new Shader_1.Shader(program, {
                uSamplerTexture: this.txt1,
            }));
            this.triangle2 = new Mesh_1.Mesh(geometry, new Shader_1.Shader(program, {
                uSamplerTexture: this.txt2,
            }));
            this.triangle3 = new Mesh_1.Mesh(geometry, new Shader_1.Shader(program, {
                uSamplerTexture: this.txt3,
            }));
            this.triangle.position.set(400, 300);
            this.triangle.scale.set(2);
            this.triangle2.position.set(200, 100);
            this.triangle3.position.set(500, 400);
            this.triangle3.scale.set(3);
            this.app.stage.addChild(this.triangle3);
            this.app.stage.addChild(this.triangle2);
            this.app.stage.addChild(this.triangle);
            this.app.ticker.add(this.runExample);
        };
        this.runExample = (delta) => {
            this.triangle.rotation += 0.01;
            this.triangle2.rotation -= 0.01;
            this.triangle3.rotation -= 0.005;
        };
        this.handleTxt2Loaded = (event) => {
            this.txt2 = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/bg_displacement.jpg"));
            this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleTxt3Loaded);
            this.loader.load();
        };
        this.handleTxt1Loaded = (event) => {
            this.txt1 = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/bg_rotate.jpg"));
            this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleTxt2Loaded);
            this.loader.load();
        };
        this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/bg_scene_rotate.jpg"));
        this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleTxt1Loaded);
        this.loader.load();
    }
}
exports.MeshGeometry = MeshGeometry;


/***/ }),

/***/ "./js-compile/examples/MeshShader.js":
/*!*******************************************!*\
  !*** ./js-compile/examples/MeshShader.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseExample_1 = __webpack_require__(/*! ./BaseExample */ "./js-compile/examples/BaseExample.js");
const ResourceLoader_1 = __webpack_require__(/*! ../raw-pixi-ts/ResourceLoader */ "./js-compile/raw-pixi-ts/ResourceLoader.js");
const Texture_1 = __webpack_require__(/*! ../raw-pixi-ts/Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const URLRequest_1 = __webpack_require__(/*! ../raw-pixi-ts/URLRequest */ "./js-compile/raw-pixi-ts/URLRequest.js");
const Event_1 = __webpack_require__(/*! ../raw-pixi-ts/Event */ "./js-compile/raw-pixi-ts/Event.js");
const BaseTexture_1 = __webpack_require__(/*! ../raw-pixi-ts/BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const Geometry_1 = __webpack_require__(/*! ../raw-pixi-ts/Geometry */ "./js-compile/raw-pixi-ts/Geometry.js");
const Program_1 = __webpack_require__(/*! ../raw-pixi-ts/Program */ "./js-compile/raw-pixi-ts/Program.js");
const Shader_1 = __webpack_require__(/*! ../raw-pixi-ts/Shader */ "./js-compile/raw-pixi-ts/Shader.js");
const Mesh_1 = __webpack_require__(/*! ../raw-pixi-ts/Mesh */ "./js-compile/raw-pixi-ts/Mesh.js");
class MeshShader extends BaseExample_1.BaseExample {
    constructor(app, width, height) {
        super(app, width, height);
        this.handleTxt1Loaded = (event) => {
            this.txt1 = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            const geometry = new Geometry_1.Geometry();
            geometry.addAttribute('aVertexPosition', // the attribute name
            [-100, -100,
                100, -100,
                100, 100]); // x, y
            geometry.addAttribute('aUvs', // the attribute name
            [0, 0,
                1, 0,
                1, 1]); // u, v
            let vx = `
            precision mediump float;
            attribute vec2 aVertexPosition;
            attribute vec2 aUvs;
            uniform mat3 translationMatrix;
            uniform mat3 projectionMatrix;
            varying vec2 vUvs;
            void main() {
                vUvs = aUvs;
                gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);
            }`;
            let fx = `precision mediump float;
            varying vec2 vUvs;
            uniform sampler2D uSampler2;
            void main() {
                gl_FragColor = texture2D(uSampler2, vUvs);
            }        
            `;
            let program = new Program_1.Program(vx, fx);
            const shader = new Shader_1.Shader(program, { uSampler2: this.txt1 });
            let vx2 = `
            precision mediump float;    
            attribute vec2 aVertexPosition;
            attribute vec2 aUvs;    
            uniform mat3 translationMatrix;
            uniform mat3 projectionMatrix;    
            varying vec2 vUvs;    
            void main() {    
                vUvs = aUvs;
                gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);    
            }`;
            let fx2 = `precision mediump float;
            varying vec2 vUvs;    
            uniform sampler2D uSampler2;    
            void main() {    
                gl_FragColor = texture2D(uSampler2, vUvs);
                gl_FragColor.r += (abs(sin(gl_FragCoord.x * 0.06)) * 0.5) * 2.;
                gl_FragColor.g += (abs(cos(gl_FragCoord.y * 0.06)) * 0.5) * 2.;
            }    
            `;
            let program2 = new Program_1.Program(vx2, fx2);
            const shader2 = new Shader_1.Shader(program2, { uSampler2: this.txt1 });
            this.triangle = new Mesh_1.Mesh(geometry, shader);
            this.triangle2 = new Mesh_1.Mesh(geometry, shader2);
            this.triangle.position.set(400, 300);
            this.triangle.scale.set(2);
            this.triangle2.position.set(500, 400);
            this.triangle2.scale.set(3);
            this.app.stage.addChild(this.triangle2);
            this.app.stage.addChild(this.triangle);
            this.app.ticker.add(this.runExample);
        };
        this.runExample = (delta) => {
            this.triangle.rotation += 0.01;
            this.triangle2.rotation -= 0.005;
        };
        this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/bg_scene_rotate.jpg"));
        this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleTxt1Loaded);
        this.loader.load();
    }
}
exports.MeshShader = MeshShader;


/***/ }),

/***/ "./js-compile/examples/MeshTextured.js":
/*!*********************************************!*\
  !*** ./js-compile/examples/MeshTextured.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseExample_1 = __webpack_require__(/*! ./BaseExample */ "./js-compile/examples/BaseExample.js");
const ResourceLoader_1 = __webpack_require__(/*! ../raw-pixi-ts/ResourceLoader */ "./js-compile/raw-pixi-ts/ResourceLoader.js");
const Texture_1 = __webpack_require__(/*! ../raw-pixi-ts/Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const URLRequest_1 = __webpack_require__(/*! ../raw-pixi-ts/URLRequest */ "./js-compile/raw-pixi-ts/URLRequest.js");
const Event_1 = __webpack_require__(/*! ../raw-pixi-ts/Event */ "./js-compile/raw-pixi-ts/Event.js");
const BaseTexture_1 = __webpack_require__(/*! ../raw-pixi-ts/BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const Geometry_1 = __webpack_require__(/*! ../raw-pixi-ts/Geometry */ "./js-compile/raw-pixi-ts/Geometry.js");
const Program_1 = __webpack_require__(/*! ../raw-pixi-ts/Program */ "./js-compile/raw-pixi-ts/Program.js");
const Shader_1 = __webpack_require__(/*! ../raw-pixi-ts/Shader */ "./js-compile/raw-pixi-ts/Shader.js");
const Mesh_1 = __webpack_require__(/*! ../raw-pixi-ts/Mesh */ "./js-compile/raw-pixi-ts/Mesh.js");
class MeshTextured extends BaseExample_1.BaseExample {
    constructor(app, width, height) {
        super(app, width, height);
        this.handlePlaneLoaded = (event) => {
            this.planeTxt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            const geometry = new Geometry_1.Geometry();
            geometry.addAttribute('aVertexPosition', // the attribute name
            [-100, -100,
                100, -100,
                100, 100], // x, y
            2); // the size of the attribute
            geometry.addAttribute('aColor', // the attribute name
            [1, 0, 0,
                0, 1, 0,
                0, 0, 1], // r, g, b
            3); // the size of the attribute
            geometry.addAttribute('aUvs', // the attribute name
            [0, 0,
                1, 0,
                1, 1], // u, v
            2); // the size of the attribute
            const vertexSrc = `
            precision mediump float;
            attribute vec2 aVertexPosition;
            attribute vec3 aColor;
            attribute vec2 aUvs;
            uniform mat3 translationMatrix;
            uniform mat3 projectionMatrix;
            varying vec2 vUvs;
            varying vec3 vColor;
            void main() {
                vUvs = aUvs;
                vColor = aColor;
                gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);
            }`;
            const fragmentSrc = `
            precision mediump float;
            varying vec3 vColor;
            varying vec2 vUvs;
            uniform sampler2D uSampler2;
            void main() {
                gl_FragColor = texture2D(uSampler2, vUvs) * vec4(vColor, 1.0);
            }`;
            const uniforms = { uSampler2: this.planeTxt };
            let program = new Program_1.Program(vertexSrc, fragmentSrc);
            const shader = new Shader_1.Shader(program, uniforms);
            this.triangle = new Mesh_1.Mesh(geometry, shader);
            this.triangle.position.set(400, 300);
            this.triangle.scale.set(2);
            this.app.stage.addChild(this.triangle);
            this.app.ticker.add(this.runExample);
        };
        this.runExample = (delta) => {
            this.triangle.rotation += 0.01;
        };
        this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/bg_scene_rotate.jpg"));
        this.loader.addEventListener(Event_1.Event.COMPLETE, this.handlePlaneLoaded);
        this.loader.load();
    }
}
exports.MeshTextured = MeshTextured;


/***/ }),

/***/ "./js-compile/examples/MeshTriangle.js":
/*!*********************************************!*\
  !*** ./js-compile/examples/MeshTriangle.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseExample_1 = __webpack_require__(/*! ./BaseExample */ "./js-compile/examples/BaseExample.js");
const Geometry_1 = __webpack_require__(/*! ../raw-pixi-ts/Geometry */ "./js-compile/raw-pixi-ts/Geometry.js");
const Shader_1 = __webpack_require__(/*! ../raw-pixi-ts/Shader */ "./js-compile/raw-pixi-ts/Shader.js");
const Program_1 = __webpack_require__(/*! ../raw-pixi-ts/Program */ "./js-compile/raw-pixi-ts/Program.js");
const Mesh_1 = __webpack_require__(/*! ../raw-pixi-ts/Mesh */ "./js-compile/raw-pixi-ts/Mesh.js");
class MeshTriangle extends BaseExample_1.BaseExample {
    constructor(app, width, height) {
        super(app, width, height);
        this.runExample = (delta) => {
            this.triangle.rotation += 0.01;
        };
        const geometry = new Geometry_1.Geometry();
        geometry.addAttribute('aVertexPosition', [-100, -50, 100, -50, 0, 100]);
        let vx = `
            precision mediump float;
            attribute vec2 aVertexPosition;
            uniform mat3 translationMatrix;
            uniform mat3 projectionMatrix;
            void main() {
                gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);
            }`;
        let fx = `precision mediump float;
            void main() {
                gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
            }
        `;
        let program = new Program_1.Program(vx, fx);
        const shader = new Shader_1.Shader(program, null);
        this.triangle = new Mesh_1.Mesh(geometry, shader);
        this.triangle.position.set(400, 300);
        app.stage.addChild(this.triangle);
        this.app.ticker.add(this.runExample);
    }
}
exports.MeshTriangle = MeshTriangle;


/***/ }),

/***/ "./js-compile/examples/MeshUniforms.js":
/*!*********************************************!*\
  !*** ./js-compile/examples/MeshUniforms.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseExample_1 = __webpack_require__(/*! ./BaseExample */ "./js-compile/examples/BaseExample.js");
const Mesh_1 = __webpack_require__(/*! ../raw-pixi-ts/Mesh */ "./js-compile/raw-pixi-ts/Mesh.js");
const ResourceLoader_1 = __webpack_require__(/*! ../raw-pixi-ts/ResourceLoader */ "./js-compile/raw-pixi-ts/ResourceLoader.js");
const Texture_1 = __webpack_require__(/*! ../raw-pixi-ts/Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const URLRequest_1 = __webpack_require__(/*! ../raw-pixi-ts/URLRequest */ "./js-compile/raw-pixi-ts/URLRequest.js");
const Event_1 = __webpack_require__(/*! ../raw-pixi-ts/Event */ "./js-compile/raw-pixi-ts/Event.js");
const BaseTexture_1 = __webpack_require__(/*! ../raw-pixi-ts/BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const Geometry_1 = __webpack_require__(/*! ../raw-pixi-ts/Geometry */ "./js-compile/raw-pixi-ts/Geometry.js");
const Program_1 = __webpack_require__(/*! ../raw-pixi-ts/Program */ "./js-compile/raw-pixi-ts/Program.js");
const Shader_1 = __webpack_require__(/*! ../raw-pixi-ts/Shader */ "./js-compile/raw-pixi-ts/Shader.js");
class MeshUniforms extends BaseExample_1.BaseExample {
    constructor(app, width, height) {
        super(app, width, height);
        this.handlePlaneLoaded = (event) => {
            this.planeTxt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            const geometry = new Geometry_1.Geometry();
            geometry.addAttribute('aVertexPosition', // the attribute name
            [-100, -100,
                100, -100,
                100, 100,
                -100, 100], // x, y
            2); // the size of the attribute
            geometry.addAttribute('aUvs', // the attribute name
            [0, 0,
                1, 0,
                1, 1,
                0, 1], // u, v
            2); // the size of the attribute
            geometry.addIndex([0, 1, 2, 0, 2, 3]);
            const vertexSrc = `
            precision mediump float;    
            attribute vec2 aVertexPosition;
            attribute vec2 aUvs;    
            uniform mat3 translationMatrix;
            uniform mat3 projectionMatrix;    
            varying vec2 vUvs;    
            void main() {    
                vUvs = aUvs;
                gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);    
            }`;
            const fragmentSrc = `    
            precision mediump float;    
            varying vec2 vUvs;    
            uniform sampler2D uSampler2;
            uniform float time;    
            void main() {    
                gl_FragColor = texture2D(uSampler2, vUvs + sin( (time + (vUvs.x) * 14.) ) * 0.1 );
            }`;
            const uniforms = {
                uSampler2: this.planeTxt,
                time: 0,
            };
            let program = new Program_1.Program(vertexSrc, fragmentSrc);
            const shader = new Shader_1.Shader(program, uniforms);
            this.triangle = new Mesh_1.Mesh(geometry, shader);
            this.triangle.position.set(400, 300);
            this.triangle.scale.set(2);
            this.app.stage.addChild(this.triangle);
            this.app.ticker.add(this.runExample);
        };
        this.runExample = (delta) => {
            this.triangle.rotation += 0.01;
            this.triangle.shader.uniforms.time += 0.1;
        };
        this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/bg_scene_rotate.jpg"));
        this.loader.addEventListener(Event_1.Event.COMPLETE, this.handlePlaneLoaded);
        this.loader.load();
    }
}
exports.MeshUniforms = MeshUniforms;


/***/ }),

/***/ "./js-compile/examples/SpriteBasic.js":
/*!********************************************!*\
  !*** ./js-compile/examples/SpriteBasic.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseExample_1 = __webpack_require__(/*! ./BaseExample */ "./js-compile/examples/BaseExample.js");
const ResourceLoader_1 = __webpack_require__(/*! ../raw-pixi-ts/ResourceLoader */ "./js-compile/raw-pixi-ts/ResourceLoader.js");
const URLRequest_1 = __webpack_require__(/*! ../raw-pixi-ts/URLRequest */ "./js-compile/raw-pixi-ts/URLRequest.js");
const Event_1 = __webpack_require__(/*! ../raw-pixi-ts/Event */ "./js-compile/raw-pixi-ts/Event.js");
const Texture_1 = __webpack_require__(/*! ../raw-pixi-ts/Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const BaseTexture_1 = __webpack_require__(/*! ../raw-pixi-ts/BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const Sprite_1 = __webpack_require__(/*! ../raw-pixi-ts/Sprite */ "./js-compile/raw-pixi-ts/Sprite.js");
class SpriteBasic extends BaseExample_1.BaseExample {
    constructor(app, width = 100, height = 100) {
        super(app, width, height);
        this.handleRotateLoaded = (event) => {
            let texture = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            this.bunny = new Sprite_1.Sprite(texture);
            this.bunny.anchor.set(0.5);
            this.bunny.x = this.sizew / 2;
            this.bunny.y = this.sizeh / 2;
            this.stage.addChild(this.bunny);
            this.app.ticker.add(this.runExample);
            this.exampleReady();
        };
        this.runExample = (delta) => {
            this.bunny.rotation += 0.1 * delta;
        };
        this.backColor = 0xFFF000;
        this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/bunny.png"));
        this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleRotateLoaded);
        this.loader.load();
    }
    destructor() {
        super.destructor();
        this.app.ticker.remove(this.runExample, null);
        this.bunny.destroy(null);
    }
}
exports.SpriteBasic = SpriteBasic;


/***/ }),

/***/ "./js-compile/examples/TextureGradientResource.js":
/*!********************************************************!*\
  !*** ./js-compile/examples/TextureGradientResource.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseExample_1 = __webpack_require__(/*! ./BaseExample */ "./js-compile/examples/BaseExample.js");
const Resource_1 = __webpack_require__(/*! ../raw-pixi-ts/Resource */ "./js-compile/raw-pixi-ts/Resource.js");
const BaseTexture_1 = __webpack_require__(/*! ../raw-pixi-ts/BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const Texture_1 = __webpack_require__(/*! ../raw-pixi-ts/Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const Sprite_1 = __webpack_require__(/*! ../raw-pixi-ts/Sprite */ "./js-compile/raw-pixi-ts/Sprite.js");
class TextureGradientResource extends BaseExample_1.BaseExample {
    constructor(app, width, height) {
        super(app, width, height);
        const gradBaseTexture = new BaseTexture_1.BaseTexture(new GradientResource());
        gradBaseTexture.setSize(500, 50);
        const gradTexture = new Texture_1.Texture(gradBaseTexture);
        const sprite = new Sprite_1.Sprite(gradTexture);
        sprite.position.set(100, 100);
        sprite.rotation = Math.PI / 8;
        this.stage.addChild(sprite);
        setTimeout(() => {
            this.exampleReady();
        }, 1000);
    }
}
exports.TextureGradientResource = TextureGradientResource;
class GradientResource extends Resource_1.Resource {
    constructor() {
        super(256, 100);
        this.canUpload = true;
    }
    upload(renderer, baseTexture, glTexture) {
        const { width } = this; // default size or from baseTexture?
        const { height } = this; // your choice.
        const canvas = document.createElement('canvas');
        this.source = canvas;
        this.source.width = width;
        this.source.height = height;
        const ctx = this.source.getContext('2d');
        const grd = ctx.createLinearGradient(0, 0, width, 0);
        grd.addColorStop(0, 'rgba(255, 255, 255, 0.0)');
        grd.addColorStop(0.3, 'cyan');
        grd.addColorStop(0.7, 'red');
        grd.addColorStop(1, 'green');
        ctx.fillStyle = grd;
        ctx.fillRect(0, 0, width, height);
        glTexture.width = width;
        glTexture.height = height;
        const { gl } = renderer;
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, baseTexture.premultiplyAlpha);
        gl.texImage2D(baseTexture.target, 0, baseTexture.format, baseTexture.format, baseTexture.type, this.source);
        return true;
    }
}


/***/ }),

/***/ "./js-compile/examples/TextureRender.js":
/*!**********************************************!*\
  !*** ./js-compile/examples/TextureRender.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseExample_1 = __webpack_require__(/*! ./BaseExample */ "./js-compile/examples/BaseExample.js");
const ResourceLoader_1 = __webpack_require__(/*! ../raw-pixi-ts/ResourceLoader */ "./js-compile/raw-pixi-ts/ResourceLoader.js");
const URLRequest_1 = __webpack_require__(/*! ../raw-pixi-ts/URLRequest */ "./js-compile/raw-pixi-ts/URLRequest.js");
const Event_1 = __webpack_require__(/*! ../raw-pixi-ts/Event */ "./js-compile/raw-pixi-ts/Event.js");
const Texture_1 = __webpack_require__(/*! ../raw-pixi-ts/Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const BaseTexture_1 = __webpack_require__(/*! ../raw-pixi-ts/BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const Container_1 = __webpack_require__(/*! ../raw-pixi-ts/Container */ "./js-compile/raw-pixi-ts/Container.js");
const Sprite_1 = __webpack_require__(/*! ../raw-pixi-ts/Sprite */ "./js-compile/raw-pixi-ts/Sprite.js");
const WebGLSettings_1 = __webpack_require__(/*! ../raw-pixi-ts/WebGLSettings */ "./js-compile/raw-pixi-ts/WebGLSettings.js");
const BaseRenderTexture_1 = __webpack_require__(/*! ../raw-pixi-ts/BaseRenderTexture */ "./js-compile/raw-pixi-ts/BaseRenderTexture.js");
const RenderTexture_1 = __webpack_require__(/*! ../raw-pixi-ts/RenderTexture */ "./js-compile/raw-pixi-ts/RenderTexture.js");
class TextureRender extends BaseExample_1.BaseExample {
    constructor(app, width, height) {
        super(app, width, height);
        this.handleResourceLoaded = (event) => {
            let txt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            this.container = new Container_1.Container();
            this.stage.addChild(this.container);
            for (let i = 0; i < 25; i++) {
                const bunny = new Sprite_1.Sprite(txt);
                bunny.x = (i % 5) * 30;
                bunny.y = Math.floor(i / 5) * 30;
                bunny.rotation = Math.random() * (Math.PI * 2);
                this.container.addChild(bunny);
            }
            const brt = new BaseRenderTexture_1.BaseRenderTexture(300, 300, WebGLSettings_1.WebGLSettings.SCALE_MODES.LINEAR, 1);
            this.rt = new RenderTexture_1.RenderTexture(brt);
            const sprite = new Sprite_1.Sprite(this.rt);
            sprite.x = 450;
            sprite.y = 60;
            this.stage.addChild(sprite);
            this.container.x = 100;
            this.container.y = 60;
            this.app.ticker.add(this.runExample);
            this.exampleReady();
        };
        this.runExample = (delta) => {
            this.app.renderer.render(this.container, this.rt);
        };
        this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/bunny.png"));
        this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleResourceLoaded);
        this.loader.load();
    }
    destructor() {
        super.destructor();
        this.app.ticker.remove(this.runExample, null);
        this.container.destroy(null);
        this.container = null;
        this.rt.destroy(null);
        this.rt = null;
    }
}
exports.TextureRender = TextureRender;


/***/ }),

/***/ "./js-compile/examples/TextureRotate.js":
/*!**********************************************!*\
  !*** ./js-compile/examples/TextureRotate.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseExample_1 = __webpack_require__(/*! ./BaseExample */ "./js-compile/examples/BaseExample.js");
const ResourceLoader_1 = __webpack_require__(/*! ../raw-pixi-ts/ResourceLoader */ "./js-compile/raw-pixi-ts/ResourceLoader.js");
const URLRequest_1 = __webpack_require__(/*! ../raw-pixi-ts/URLRequest */ "./js-compile/raw-pixi-ts/URLRequest.js");
const Event_1 = __webpack_require__(/*! ../raw-pixi-ts/Event */ "./js-compile/raw-pixi-ts/Event.js");
const Texture_1 = __webpack_require__(/*! ../raw-pixi-ts/Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const BaseTexture_1 = __webpack_require__(/*! ../raw-pixi-ts/BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const GroupD8_1 = __webpack_require__(/*! ../raw-pixi-ts/GroupD8 */ "./js-compile/raw-pixi-ts/GroupD8.js");
const Rectangle_1 = __webpack_require__(/*! ../raw-pixi-ts/Rectangle */ "./js-compile/raw-pixi-ts/Rectangle.js");
const Sprite_1 = __webpack_require__(/*! ../raw-pixi-ts/Sprite */ "./js-compile/raw-pixi-ts/Sprite.js");
const Text_1 = __webpack_require__(/*! ../raw-pixi-ts/Text */ "./js-compile/raw-pixi-ts/Text.js");
class TextureRotate extends BaseExample_1.BaseExample {
    constructor(app, width, height) {
        super(app, width, height);
        this.handleResourceLoaded = (event) => {
            let txt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            const textures = [txt];
            const D8 = GroupD8_1.GroupD8;
            for (let rotate = 1; rotate < 16; rotate++) {
                const h = D8.isVertical(rotate) ? txt.frame.width : txt.frame.height;
                const w = D8.isVertical(rotate) ? txt.frame.height : txt.frame.width;
                const { frame } = txt;
                const crop = new Rectangle_1.Rectangle(txt.frame.x, txt.frame.y, w, h);
                const trim = crop;
                let rotatedTexture;
                if (rotate % 2 === 0) {
                    rotatedTexture = new Texture_1.Texture(txt.baseTexture, frame, crop, trim, rotate);
                }
                else {
                    rotatedTexture = new Texture_1.Texture(txt.baseTexture, frame, crop, trim, rotate - 1);
                    rotatedTexture.rotate++;
                }
                textures.push(rotatedTexture);
            }
            const offsetX = this.sizew / 16 | 0;
            const offsetY = this.sizeh / 8 | 0;
            const gridW = this.sizew / 4 | 0;
            const gridH = this.sizeh / 5 | 0;
            for (let i = 0; i < 16; i++) {
                const dude = new Sprite_1.Sprite(textures[i < 8 ? i * 2 : (i - 8) * 2 + 1]);
                dude.scale.x = 0.5;
                dude.scale.y = 0.5;
                dude.x = offsetX + gridW * (i % 4);
                dude.y = offsetY + gridH * (i / 4 | 0);
                this.stage.addChild(dude);
                const text = new Text_1.Text(`rotate = ${dude.texture.rotate}`, {
                    fontFamily: 'Courier New', fontSize: '12px', fill: 'white', align: 'left',
                });
                text.x = dude.x;
                text.y = dude.y - 20;
                this.stage.addChild(text);
            }
            this.exampleReady();
        };
        this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/flowerTop.png"));
        this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleResourceLoaded);
        this.loader.load();
    }
}
exports.TextureRotate = TextureRotate;


/***/ }),

/***/ "./js-compile/examples/controls/ExampleDisplay.js":
/*!********************************************************!*\
  !*** ./js-compile/examples/controls/ExampleDisplay.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Container_1 = __webpack_require__(/*! ../../raw-pixi-ts/Container */ "./js-compile/raw-pixi-ts/Container.js");
const Graphics_1 = __webpack_require__(/*! ../../raw-pixi-ts/Graphics */ "./js-compile/raw-pixi-ts/Graphics.js");
const ExampleList_1 = __webpack_require__(/*! ./ExampleList */ "./js-compile/examples/controls/ExampleList.js");
const TextureRotate_1 = __webpack_require__(/*! ../TextureRotate */ "./js-compile/examples/TextureRotate.js");
const TextureRender_1 = __webpack_require__(/*! ../TextureRender */ "./js-compile/examples/TextureRender.js");
const TextureGradientResource_1 = __webpack_require__(/*! ../TextureGradientResource */ "./js-compile/examples/TextureGradientResource.js");
const FilterBlur_1 = __webpack_require__(/*! ../FilterBlur */ "./js-compile/examples/FilterBlur.js");
const FilterColor_1 = __webpack_require__(/*! ../FilterColor */ "./js-compile/examples/FilterColor.js");
const FilterCrawlies_1 = __webpack_require__(/*! ../FilterCrawlies */ "./js-compile/examples/FilterCrawlies.js");
const FilterFlag_1 = __webpack_require__(/*! ../FilterFlag */ "./js-compile/examples/FilterFlag.js");
const MaskFilter_1 = __webpack_require__(/*! ../MaskFilter */ "./js-compile/examples/MaskFilter.js");
const SpriteBasic_1 = __webpack_require__(/*! ../SpriteBasic */ "./js-compile/examples/SpriteBasic.js");
const FilterBlending_1 = __webpack_require__(/*! ../FilterBlending */ "./js-compile/examples/FilterBlending.js");
const FilterCustom_1 = __webpack_require__(/*! ../FilterCustom */ "./js-compile/examples/FilterCustom.js");
const FilterShadow_1 = __webpack_require__(/*! ../FilterShadow */ "./js-compile/examples/FilterShadow.js");
const MeshBasic_1 = __webpack_require__(/*! ../MeshBasic */ "./js-compile/examples/MeshBasic.js");
const MeshAdvanced_1 = __webpack_require__(/*! ../MeshAdvanced */ "./js-compile/examples/MeshAdvanced.js");
const MeshTriangle_1 = __webpack_require__(/*! ../MeshTriangle */ "./js-compile/examples/MeshTriangle.js");
const MeshColoredTriangle_1 = __webpack_require__(/*! ../MeshColoredTriangle */ "./js-compile/examples/MeshColoredTriangle.js");
const MeshTextured_1 = __webpack_require__(/*! ../MeshTextured */ "./js-compile/examples/MeshTextured.js");
const MeshUniforms_1 = __webpack_require__(/*! ../MeshUniforms */ "./js-compile/examples/MeshUniforms.js");
const MeshGeometry_1 = __webpack_require__(/*! ../MeshGeometry */ "./js-compile/examples/MeshGeometry.js");
const MeshShader_1 = __webpack_require__(/*! ../MeshShader */ "./js-compile/examples/MeshShader.js");
const Event_1 = __webpack_require__(/*! ../../raw-pixi-ts/Event */ "./js-compile/raw-pixi-ts/Event.js");
class ExampleDisplay extends Container_1.Container {
    constructor(app, displayWidth, displayheight) {
        super();
        this.handleExampleRequest = (event) => {
            this.setExample(this.list.selectedClass);
        };
        this.handleComplete = (event) => {
            this.list.addEventListener(Event_1.Event.CHANGE, this.handleExampleRequest);
        };
        let controlSize = 200;
        this.app = app;
        this.background = new Graphics_1.Graphics();
        this.refreshBackground(0x969696);
        app.stage.addChild(this.background);
        this.stageLayer = new Container_1.Container();
        app.stage.addChild(this.stageLayer);
        this.list = new ExampleList_1.ExampleList(controlSize, displayheight);
        this.list.x = displayWidth - controlSize;
        displayWidth = displayWidth - controlSize;
        app.stage.addChild(this.list);
        this.controlLayer = new Container_1.Container();
        app.stage.addChild(this.controlLayer);
        this.framesize = 5;
        this.exampleWidth = displayWidth; //(displayWidth - controlSize) - (this.framesize / 2)
        this.exampleheight = displayheight - (this.framesize / 2);
        this.frame = new Graphics_1.Graphics();
        this.frame.beginFill(0x000FFF);
        this.frame.drawRect(0, 0, this.framesize, displayheight);
        this.frame.drawRect(displayWidth - this.framesize, 0, 5, displayheight);
        this.frame.drawRect(this.framesize, 0, displayWidth - (this.framesize * 2), this.framesize);
        this.frame.drawRect(this.framesize, displayheight - this.framesize, displayWidth - (this.framesize * 2), this.framesize);
        this.controlLayer.addChild(this.frame);
        // this.list.addExample("Sprite Basic", SpriteBasic);
        // this.list.addExample("Sprite Reveal", AdvancedCard);
        // this.list.addExample("Sprite Slots", AdvancedSlots);
        // this.list.addExample("Sprite Trail", AdvancedTrail);
        // this.list.addExample("Sprite Warp", AdvancedWarp);  
        // this.list.addExample("Sprite Blend", BasicBlend);
        // this.list.addExample("Sprite Tinting", BasicTinting);
        // this.list.addExample("Sprite Video", SpriteVideo);
        // this.list.addExample("Sprite Tiling", SpriteTiling);
        // this.list.addExample("Sprite Animation", SpriteExplosion);
        // this.list.addExample("Sprite Animation 2", Spritejet);
        // this.list.addExample("Sprite Animation 3", SpriteSpeed);
        // this.list.addExample("Graphics Basic", GraphicsSimple);
        // this.list.addExample("Graphics Advanced", GraphicsAdvanced);
        // this.list.addExample("Graphics Dynamic", GraphicsDynamic);
        // this.list.addExample("Container", BasicContainer);
        // this.list.addExample("Mask Graphics", MaskGraphics);
        // this.list.addExample("Mask Sprite", MaskSprite);
        // this.list.addExample("Particles", BasicParticles);
        // this.list.addExample("Text", TextBase);
        // this.list.addExample("Text Bitmap", TextBitmap);
        // this.list.addExample("Text WebFont", TextWebFont);
        // this.list.addExample("Interaction", InteractionInteractivity);
        // this.list.addExample("Interaction Click", InteractionClick);  
        // this.list.addExample("Interaction Drag", InteractionDragging);
        // this.list.addExample("Interaction Icon", InteractionIcon);    
        // this.list.addExample("texture Swap", SpriteSwap);
        // this.list.addExample("Texture Advanced", TextureAdvanced);
        // this.list.addExample("Texture Gradient", TextureGradientBasic);
        this.list.addExample("Texture Gradient 2", TextureGradientResource_1.TextureGradientResource);
        this.list.addExample("Texture Rotate", TextureRotate_1.TextureRotate);
        this.list.addExample("Texture Render", TextureRender_1.TextureRender);
        this.list.addExample("Filter Blur", FilterBlur_1.FilterBlur);
        this.list.addExample("Filter Colormatrix", FilterColor_1.FilterColor);
        this.list.addExample("Filter Displacement", FilterCrawlies_1.FilterCrawlies);
        this.list.addExample("Filter Displacement 2", FilterFlag_1.FilterFlag);
        this.list.addExample("Filter Blur 2", MaskFilter_1.MaskFilter);
        this.list.addExample("Filter Blending", FilterBlending_1.FilterBlending);
        this.list.addExample("Filter Custom", FilterCustom_1.FilterCustom);
        this.list.addExample("Filter Shadow", FilterShadow_1.FilterShadow);
        this.list.addExample("Mesh Basic", MeshBasic_1.MeshBasic);
        this.list.addExample("Mesh Triangle", MeshTriangle_1.MeshTriangle);
        this.list.addExample("Mesh Triangle 2", MeshColoredTriangle_1.MeshColoredTriangle);
        this.list.addExample("Mesh Texture", MeshTextured_1.MeshTextured);
        this.list.addExample("Mesh Advanced", MeshAdvanced_1.MeshAdvanced);
        this.list.addExample("Mesh Uniforms", MeshUniforms_1.MeshUniforms);
        this.list.addExample("Mesh Geometry", MeshGeometry_1.MeshGeometry);
        this.list.addExample("Mesh Shader", MeshShader_1.MeshShader);
        this.setExample(SpriteBasic_1.SpriteBasic);
    }
    setExample(keyclass) {
        this.list.removeEventListener(Event_1.Event.CHANGE, this.handleExampleRequest);
        if (this.currentExample) {
            this.currentExample.destructor();
        }
        this.currentExample = new keyclass(this.app, this.exampleWidth, this.exampleheight);
        this.currentExample.addEventListener(Event_1.Event.COMPLETE, this.handleComplete);
        // this.currentExample.stage.x = this.currentExample.stage.y = this.framesize;
        this.stageLayer.removeChildren();
        this.stageLayer.addChild(this.currentExample.stage);
        this.refreshBackground(this.currentExample.backColor);
    }
    refreshBackground(color) {
        this.background.clear();
        this.background.beginFill(color);
        this.background.drawRect(0, 0, this.exampleWidth, this.exampleheight);
    }
}
exports.ExampleDisplay = ExampleDisplay;


/***/ }),

/***/ "./js-compile/examples/controls/ExampleList.js":
/*!*****************************************************!*\
  !*** ./js-compile/examples/controls/ExampleList.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Container_1 = __webpack_require__(/*! ../../raw-pixi-ts/Container */ "./js-compile/raw-pixi-ts/Container.js");
const Button_1 = __webpack_require__(/*! ../../fl-package/Button */ "./js-compile/fl-package/Button.js");
const Graphics_1 = __webpack_require__(/*! ../../raw-pixi-ts/Graphics */ "./js-compile/raw-pixi-ts/Graphics.js");
const MouseEvent_1 = __webpack_require__(/*! ../../raw-pixi-ts/MouseEvent */ "./js-compile/raw-pixi-ts/MouseEvent.js");
const Event_1 = __webpack_require__(/*! ../../raw-pixi-ts/Event */ "./js-compile/raw-pixi-ts/Event.js");
class ExampleList extends Container_1.Container {
    constructor(displayWidth, displayheight) {
        super();
        this.handleScrollChange = (event) => {
            this.listContainer.y = this.scroll.targetPosition;
        };
        this.handleButtonTap = (event) => {
            this._selectedClass = this.classReference[event.currentTarget.name];
            this.dispatchEvent(Event_1.Event.getEvent(Event_1.Event.CHANGE));
        };
        this.buttons = [];
        this.classReference = {};
        this.itemGap = 2;
        this.sideGap = 2;
        this.listContainer = new Container_1.Container();
        this.addChild(this.listContainer);
        this.listmask = new Graphics_1.Graphics();
        this.listmask.beginFill(0);
        this.listmask.drawRect(0, 0, displayWidth, displayheight);
        this.listContainer.mask = this.listmask;
        this.addChild(this.listmask);
        let gr = new Graphics_1.Graphics();
        gr.beginFill(0xAAA0AA);
        gr.drawRect(0, 0, 25, displayheight);
        this.addChild(gr);
        gr.x = displayWidth - 25;
        this.buttonWidth = displayWidth - 25 - (this.sideGap * 2);
        this.buttonheight = 40;
        this.scroll = new ScrollBar();
        this.addChild(this.scroll);
        this.scroll.x = displayWidth - 25;
        this.scroll.scrollArea = displayheight;
        this.scroll.addEventListener(Event_1.Event.CHANGE, this.handleScrollChange);
    }
    get selectedClass() {
        return this._selectedClass;
    }
    addExample(keyname, keyclass) {
        let button = new Button_1.Button(keyname, this.buttonWidth, this.buttonheight);
        button.addEventListener(MouseEvent_1.MouseEvent.POINTER_TAP, this.handleButtonTap);
        this.buttons.push(button);
        button.name = keyname;
        button.x = this.sideGap;
        this.listContainer.addChild(button);
        this.classReference[keyname] = keyclass;
        this.refreshList();
    }
    refreshList() {
        let start = this.itemGap;
        for (let button of this.buttons) {
            button.y = start;
            start += button.height + this.itemGap;
        }
        this.scroll.scrollDistance = start;
    }
}
exports.ExampleList = ExampleList;
class ScrollBar extends Container_1.Container {
    constructor() {
        super();
        this.handleHandleUp = (event) => {
            this.dragging = false;
            this.eventData = null;
        };
        this.handleHandleMove = (event) => {
            if (this.eventData) {
                const newPosition = this.eventData.getLocalPosition(this._handle.parent);
                this._handle.y = newPosition.y - (this._handle.height / 2);
                if (this._handle.y > this._scrollArea) {
                    this._handle.y = this._scrollArea;
                }
                else if (this._handle.y < 0) {
                    this._handle.y = 0;
                }
                this.areaPercent = this._handle.y / this._scrollArea;
                this._targetPosition = (this._scrollDistance - this._visibleArea) * this.areaPercent * -1;
                this.dispatchEvent(Event_1.Event.getEvent(Event_1.Event.CHANGE));
            }
        };
        this.handleHandleDown = (event) => {
            this.dragging = true;
            this.eventData = event.data;
        };
        this._handle = new Graphics_1.Graphics();
        this._handle.beginFill(0x636363);
        this._handle.drawRect(0, 0, 25, 25);
        this.addChild(this._handle);
        this._handle.buttonMode = this._handle.interactive = true;
        this._handle.addEventListener(MouseEvent_1.MouseEvent.POINTER_DOWN, this.handleHandleDown);
        this._handle.addEventListener(MouseEvent_1.MouseEvent.POINTER_UP, this.handleHandleUp);
        this._handle.addEventListener(MouseEvent_1.MouseEvent.POINTER_UP_OUTSIDE, this.handleHandleUp);
        this._handle.addEventListener(MouseEvent_1.MouseEvent.POINTER_MOVE, this.handleHandleMove);
    }
    get targetPosition() {
        return this._targetPosition;
    }
    set scrollDistance(value) {
        this._scrollDistance = value;
    }
    set scrollArea(value) {
        this._scrollArea = value - 25;
        this._visibleArea = value;
    }
}


/***/ }),

/***/ "./js-compile/fl-package/Button.js":
/*!*****************************************!*\
  !*** ./js-compile/fl-package/Button.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Container_1 = __webpack_require__(/*! ../raw-pixi-ts/Container */ "./js-compile/raw-pixi-ts/Container.js");
const Graphics_1 = __webpack_require__(/*! ../raw-pixi-ts/Graphics */ "./js-compile/raw-pixi-ts/Graphics.js");
const MouseEvent_1 = __webpack_require__(/*! ../raw-pixi-ts/MouseEvent */ "./js-compile/raw-pixi-ts/MouseEvent.js");
const Text_1 = __webpack_require__(/*! ../raw-pixi-ts/Text */ "./js-compile/raw-pixi-ts/Text.js");
const TextStyle_1 = __webpack_require__(/*! ../raw-pixi-ts/TextStyle */ "./js-compile/raw-pixi-ts/TextStyle.js");
class Button extends Container_1.Container {
    constructor(caption, buttonWidth = 150, buttonheight = 40) {
        super();
        this.handleOut = (event) => {
            this.buttongraphic.visible = true;
            this.buttonovergraphic.visible = false;
            this.buttondowngraphic.visible = false;
        };
        this.handleOver = (event) => {
            this.buttongraphic.visible = false;
            this.buttonovergraphic.visible = true;
            this.buttondowngraphic.visible = false;
        };
        this.handleUp = (event) => {
            this.buttongraphic.visible = true;
            this.buttonovergraphic.visible = false;
            this.buttondowngraphic.visible = false;
        };
        this.handleDown = (event) => {
            this.buttongraphic.visible = false;
            this.buttonovergraphic.visible = false;
            this.buttondowngraphic.visible = true;
        };
        this.interactive = true;
        this.buttongraphic = new Graphics_1.Graphics();
        this.buttongraphic.beginFill(0x969696);
        this.buttongraphic.drawRoundedRect(0, 0, buttonWidth, buttonheight, 10);
        this.addChild(this.buttongraphic);
        this.buttonovergraphic = new Graphics_1.Graphics();
        this.buttonovergraphic.beginFill(0xB9B9B9);
        this.buttonovergraphic.drawRoundedRect(0, 0, buttonWidth, buttonheight, 10);
        this.addChild(this.buttonovergraphic);
        this.buttonovergraphic.visible = false;
        this.buttondowngraphic = new Graphics_1.Graphics();
        this.buttondowngraphic.beginFill(0x636363);
        this.buttondowngraphic.drawRoundedRect(0, 0, buttonWidth, buttonheight, 10);
        this.addChild(this.buttondowngraphic);
        this.buttondowngraphic.visible = false;
        let style = new TextStyle_1.TextStyle({});
        style.fontSize = 16;
        style.align = "center";
        style.fontFamily = "Arial";
        this.label = new Text_1.Text(caption, style);
        this.label.interactive = false;
        this.label.y = (buttonheight - (this.label.height)) / 2;
        this.label.x = (buttonWidth / 2 - this.label.width / 2);
        this.addChild(this.label);
        this.addEventListener(MouseEvent_1.MouseEvent.POINTER_DOWN, this.handleDown);
        this.addEventListener(MouseEvent_1.MouseEvent.POINTER_OVER, this.handleOver);
        this.addEventListener(MouseEvent_1.MouseEvent.POINTER_UP, this.handleUp);
        this.addEventListener(MouseEvent_1.MouseEvent.POINTER_OUT, this.handleOut);
        this.addEventListener(MouseEvent_1.MouseEvent.POINTER_UP_OUTSIDE, this.handleOut);
    }
}
exports.Button = Button;


/***/ }),

/***/ "./js-compile/index.js":
/*!*****************************!*\
  !*** ./js-compile/index.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Application_1 = __webpack_require__(/*! ./raw-pixi-ts/Application */ "./js-compile/raw-pixi-ts/Application.js");
const StageOptions_1 = __webpack_require__(/*! ./raw-pixi-ts/StageOptions */ "./js-compile/raw-pixi-ts/StageOptions.js");
const ExampleDisplay_1 = __webpack_require__(/*! ./examples/controls/ExampleDisplay */ "./js-compile/examples/controls/ExampleDisplay.js");
window.addEventListener("load", () => {
    var options = new StageOptions_1.StageOptions();
    options.width = 1000;
    options.height = 600;
    options.autoResize = false;
    options.backgroundColor = 0x00000000;
    options.clearBeforeRender = true;
    options.resolution = 1;
    options.autoStart = true;
    options.transparent = true;
    options.antialias = true;
    options.view = document.getElementById("fakecanvas");
    var app = new Application_1.Application(options);
    let display = new ExampleDisplay_1.ExampleDisplay(app, 1024, 768);
    app.stage.addChild(display);
    // create a view class with frame
    // create a control class with buttons
    // each button click change content of class frame
    // let button:Button = new Button("Test", 200, 40);
    // app.stage.addChild(button);
    // button.x = 800;
    // let example:BasicCache = new BasicCache(app); NOT WORKING
    // let example:InteractionIcon = new InteractionIcon(app);
    // let example:SpriteVideo = new SpriteVideo(app);
    // let example:AdvancedSlots = new AdvancedSlots(app); 
    // let example:TextureRotate = new TextureRotate(app); 
    // let example:BasicContainer = new BasicContainer(app);
    // let example:BasicBackground = new BasicBackground(app);
    // let example:BasicTinting = new BasicTinting(app);    
    // let example:BasicParticles = new BasicParticles(app);
    // let example:BasicBlend = new BasicBlend(app);    
    // let example:GraphicsSimple = new GraphicsSimple(app);
    // let example:GraphicsAdvanced = new GraphicsAdvanced(app);
    // let example:GraphicsDynamic = new GraphicsDynamic(app);
    // let example:TextureRender = new TextureRender(app);
    // let example:TextureAdvanced = new TextureAdvanced(app);
    // let example:TextureGradientBasic = new TextureGradientBasic(app);
    // let example:TextureGradientResource = new TextureGradientResource(app);
    // let example:TextBase = new TextBase(app);
    // let example:TextBitmap = new TextBitmap(app); 
    // let example:TextWebFont = new TextWebFont(app); 
    // let example:MaskGraphics = new MaskGraphics(app);
    // let example:MaskSprite = new MaskSprite(app);
    // let example:FilterBlur = new FilterBlur(app);
    // let example:FilterColor = new FilterColor(app);
    // let example:FilterCrawlies = new FilterCrawlies(app);
    // let example:FilterFlag = new FilterFlag(app);
    // let example:MaskFilter = new MaskFilter(app);
    // let example:InteractionClick = new InteractionClick(app);
    // let example:InteractionInteractivity = new InteractionInteractivity(app);
    // let example:InteractionDragging = new InteractionDragging(app); 
    // let example:SpriteBasic = new SpriteBasic(app);  
    // let example:SpriteSwap = new SpriteSwap(app);    
    // let example:SpriteTiling = new SpriteTiling(app);    
    // let example:SpriteExplosion = new SpriteExplosion(app);
    // let example:Spritejet = new Spritejet(app); 
    // let example:SpriteSpeed = new SpriteSpeed(app); 
    // let example:AdvancedCard = new AdvancedCard(app); 
    // let example:AdvancedTrail = new AdvancedTrail(app); 
    // let example:AdvancedWarp = new AdvancedWarp(app); 
    // let example:FilterBlending = new FilterBlending(app); 
    // let example:FilterCustom = new FilterCustom(app); 
    // let example:FilterShadow = new FilterShadow(app); 
    // let example:MeshBasic = new MeshBasic(app);
    // let example:MeshAdvanced = new MeshAdvanced(app);
    // let example:MeshTriangle = new MeshTriangle(app);
    // let example:MeshColoredTriangle = new MeshColoredTriangle(app);
    // let example:MeshTextured = new MeshTextured(app);
    // let example:MeshUniforms = new MeshUniforms(app);
    // let example:MeshGeometry = new MeshGeometry(app);
    // let example:MeshShader = new MeshShader(app);
});


/***/ }),

/***/ "./js-compile/raw-pixi-ts/AbstractRenderer.js":
/*!****************************************************!*\
  !*** ./js-compile/raw-pixi-ts/AbstractRenderer.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const EventDispatcher_1 = __webpack_require__(/*! ./EventDispatcher */ "./js-compile/raw-pixi-ts/EventDispatcher.js");
const Matrix_1 = __webpack_require__(/*! ./Matrix */ "./js-compile/raw-pixi-ts/Matrix.js");
const Rectangle_1 = __webpack_require__(/*! ./Rectangle */ "./js-compile/raw-pixi-ts/Rectangle.js");
const RenderTexture_1 = __webpack_require__(/*! ./RenderTexture */ "./js-compile/raw-pixi-ts/RenderTexture.js");
const Container_1 = __webpack_require__(/*! ./Container */ "./js-compile/raw-pixi-ts/Container.js");
const DisplaySettings_1 = __webpack_require__(/*! ./DisplaySettings */ "./js-compile/raw-pixi-ts/DisplaySettings.js");
const MathSettings_1 = __webpack_require__(/*! ./MathSettings */ "./js-compile/raw-pixi-ts/MathSettings.js");
const ColorSettings_1 = __webpack_require__(/*! ./ColorSettings */ "./js-compile/raw-pixi-ts/ColorSettings.js");
class AbstractRenderer extends EventDispatcher_1.EventDispatcher {
    constructor(system, options) {
        super();
        if (options.roundPixels) {
            DisplaySettings_1.DisplaySettings.ROUND_PIXELS = options.roundPixels;
        }
        this.options = options;
        this.type = DisplaySettings_1.DisplaySettings.RENDERER_TYPE.UNKNOWN;
        this.screen = new Rectangle_1.Rectangle(0, 0, options.width, options.height);
        this.view = options.view || document.createElement('canvas');
        this.resolution = options.resolution || DisplaySettings_1.DisplaySettings.RESOLUTION;
        this.transparent = options.transparent;
        this.autoDensity = options.autoDensity || options.autoResize || false;
        this.preserveDrawingBuffer = options.preserveDrawingBuffer;
        this.clearBeforeRender = options.clearBeforeRender;
        this._backgroundColor = 0x000000;
        this._backgroundColorRgba = [0, 0, 0, 0];
        this._backgroundColorString = '#000000';
        this.backgroundColor = options.backgroundColor || this._backgroundColor;
        this._tempDisplayObjectParent = new Container_1.Container();
        this._lastObjectRendered = this._tempDisplayObjectParent;
        this.blendModes = 0;
    }
    resize(screenWidth, screenHeight) {
        this.screen.width = screenWidth;
        this.screen.height = screenHeight;
        this.view.width = screenWidth * this.resolution;
        this.view.height = screenHeight * this.resolution;
        if (this.autoDensity) {
            this.view.style.width = screenWidth + "px";
            this.view.style.height = screenHeight + "px";
        }
    }
    ;
    get width() {
        return this.view.width;
    }
    ;
    get height() {
        return this.view.height;
    }
    ;
    generateTexture(displayObject, scaleMode, resolution, region) {
        region = region || displayObject.getLocalBounds();
        if (region.width === 0) {
            region.width = 1;
        }
        if (region.height === 0) {
            region.height = 1;
        }
        var renderTexture = RenderTexture_1.RenderTexture.create(region.width | 0, region.height | 0, scaleMode, resolution);
        AbstractRenderer.tempMatrix.tx = -region.x;
        AbstractRenderer.tempMatrix.ty = -region.y;
        this.render(displayObject, renderTexture, false, AbstractRenderer.tempMatrix, !!displayObject.parent);
        return renderTexture;
    }
    ;
    render(displayObject, renderTexture, b, m, parent) {
    }
    /**
     * Removes everything from the renderer and optionally removes the Canvas DOM element.
     *
     * @param {boolean} [removeView=false] - Removes the Canvas element from the DOM.
     */
    destroy(removeView) {
        // for (var o in this.plugins)
        // {
        //     this.plugins[o].destroy();
        //     this.plugins[o] = null;
        // }
        if (removeView && this.view.parentNode) {
            this.view.parentNode.removeChild(this.view);
        }
        // this.plugins = null;
        this.type = DisplaySettings_1.DisplaySettings.RENDERER_TYPE.UNKNOWN;
        this.view = null;
        this.screen = null;
        this.resolution = 0;
        this.transparent = false;
        this.autoDensity = false;
        this.blendModes = null;
        this.options = null;
        this.preserveDrawingBuffer = false;
        this.clearBeforeRender = false;
        this._backgroundColor = 0;
        this._backgroundColorRgba = null;
        this._backgroundColorString = null;
        this._tempDisplayObjectParent = null;
        this._lastObjectRendered = null;
    }
    ;
    /**
     * The background color to fill if not transparent
     *
     * @member {number}
     */
    get backgroundColor() {
        return this._backgroundColor;
    }
    ;
    set backgroundColor(value) {
        this._backgroundColor = value;
        this._backgroundColorString = MathSettings_1.MathSettings.hex2string(value);
        ColorSettings_1.ColorSettings.hex2rgb(value, this._backgroundColorRgba);
    }
    ;
}
AbstractRenderer.tempMatrix = new Matrix_1.Matrix();
exports.AbstractRenderer = AbstractRenderer;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/AccessibilityManager.js":
/*!********************************************************!*\
  !*** ./js-compile/raw-pixi-ts/AccessibilityManager.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
// import { settings } from './settings';
const UtilsSettings_1 = __webpack_require__(/*! ./UtilsSettings */ "./js-compile/raw-pixi-ts/UtilsSettings.js");
class AccessibilityManager {
    constructor(renderer) {
        /**
                 * @type {?HTMLElement}
                 * @private
                 */
        this._hookDiv = null;
        // if (settings.isMobile_min.tablet || settings.isMobile_min.phone)
        // {
        this.createTouchHook();
        // }
        // first we create a div that will sit over the PixiJS element. This is where the div overlays will go.
        var div = document.createElement('div');
        div.style.width = AccessibilityManager.DIV_TOUCH_SIZE + "px";
        div.style.height = AccessibilityManager.DIV_TOUCH_SIZE + "px";
        div.style.position = 'absolute';
        div.style.top = AccessibilityManager.DIV_TOUCH_POS_X + "px";
        div.style.left = AccessibilityManager.DIV_TOUCH_POS_Y + "px";
        div.style.zIndex = AccessibilityManager.DIV_TOUCH_ZINDEX.toString();
        /**
         * This is the dom element that will sit over the PixiJS element. This is where the div overlays will go.
         *
         * @type {HTMLElement}
         * @private
         */
        this.div = div;
        /**
         * A simple pool for storing divs.
         *
         * @type {*}
         * @private
         */
        this.pool = [];
        /**
         * This is a tick used to check if an object is no longer being rendered.
         *
         * @type {Number}
         * @private
         */
        this.renderId = 0;
        /**
         * Setting this to true will visually show the divs.
         *
         * @type {boolean}
         */
        this.debug = false;
        /**
         * The renderer this accessibility manager works for.
         *
         * @member {PIXI.AbstractRenderer}
         */
        this.renderer = renderer;
        /**
         * The array of currently active accessible items.
         *
         * @member {Array<*>}
         * @private
         */
        this.children = [];
        /**
         * pre-bind the functions
         *
         * @type {Function}
         * @private
         */
        this._onKeyDown = this._onKeyDown.bind(this);
        /**
         * pre-bind the functions
         *
         * @type {Function}
         * @private
         */
        this._onMouseMove = this._onMouseMove.bind(this);
        /**
         * A flag
         * @type {boolean}
         * @readonly
         */
        this.isActive = false;
        /**
         * A flag
         * @type {boolean}
         * @readonly
         */
        this.isMobileAccessibility = false;
        // let listen for tab.. once pressed we can fire up and show the accessibility layer
        window.addEventListener('keydown', this._onKeyDown, false);
    }
    /**
     * Creates the touch hooks.
     *
     * @private
     */
    createTouchHook() {
        var this$1 = this;
        var hookDiv = document.createElement('button');
        hookDiv.style.width = AccessibilityManager.DIV_HOOK_SIZE + "px";
        hookDiv.style.height = AccessibilityManager.DIV_HOOK_SIZE + "px";
        hookDiv.style.position = 'absolute';
        hookDiv.style.top = AccessibilityManager.DIV_HOOK_POS_X + "px";
        hookDiv.style.left = AccessibilityManager.DIV_HOOK_POS_Y + "px";
        hookDiv.style.zIndex = AccessibilityManager.DIV_HOOK_ZINDEX.toString();
        hookDiv.style.backgroundColor = '#FF0000';
        hookDiv.title = 'HOOK DIV';
        hookDiv.addEventListener('focus', function () {
            this$1.isMobileAccessibility = true;
            this$1.activate();
            this$1.destroyTouchHook();
        });
        document.body.appendChild(hookDiv);
        this._hookDiv = hookDiv;
    }
    ;
    /**
     * Destroys the touch hooks.
     *
     * @private
     */
    destroyTouchHook() {
        if (!this._hookDiv) {
            return;
        }
        document.body.removeChild(this._hookDiv);
        this._hookDiv = null;
    }
    ;
    /**
     * Activating will cause the Accessibility layer to be shown.
     * This is called when a user presses the tab key.
     *
     * @private
     */
    activate() {
        if (this.isActive) {
            return;
        }
        this.isActive = true;
        window.document.addEventListener('mousemove', this._onMouseMove, true);
        window.removeEventListener('keydown', this._onKeyDown, false);
        this.renderer.on('postrender', this.update, this);
        if (this.renderer.view.parentNode) {
            this.renderer.view.parentNode.appendChild(this.div);
        }
    }
    ;
    /**
     * Deactivating will cause the Accessibility layer to be hidden.
     * This is called when a user moves the mouse.
     *
     * @private
     */
    deactivate() {
        if (!this.isActive || this.isMobileAccessibility) {
            return;
        }
        this.isActive = false;
        window.document.removeEventListener('mousemove', this._onMouseMove, true);
        window.addEventListener('keydown', this._onKeyDown, false);
        this.renderer.off('postrender', this.update);
        if (this.div.parentNode) {
            this.div.parentNode.removeChild(this.div);
        }
    }
    ;
    /**
     * This recursive function will run through the scene graph and add any new accessible objects to the DOM layer.
     *
     * @private
     * @param {PIXI.Container} displayObject - The DisplayObject to check.
     */
    updateAccessibleObjects(displayObject) {
        if (!displayObject.visible) {
            return;
        }
        if (displayObject.accessible && displayObject.interactive) {
            if (!displayObject._accessibleActive) {
                this.addChild(displayObject);
            }
            displayObject.renderId = this.renderId;
        }
        var children = displayObject.children;
        for (var i = 0; i < children.length; i++) {
            this.updateAccessibleObjects(children[i]);
        }
    }
    ;
    /**
     * Before each render this function will ensure that all divs are mapped correctly to their DisplayObjects.
     *
     * @private
     */
    update() {
        if (!this.renderer.renderingToScreen) {
            return;
        }
        // update children...
        this.updateAccessibleObjects(this.renderer._lastObjectRendered);
        var rect = this.renderer.view.getBoundingClientRect();
        var sx = rect.width / this.renderer.width;
        var sy = rect.height / this.renderer.height;
        var div = this.div;
        div.style.left = (rect.left) + "px";
        div.style.top = (rect.top) + "px";
        div.style.width = (this.renderer.width) + "px";
        div.style.height = (this.renderer.height) + "px";
        for (var i = 0; i < this.children.length; i++) {
            var child = this.children[i];
            if (child.renderId !== this.renderId) {
                child._accessibleActive = false;
                UtilsSettings_1.UtilsSettings.removeItems(this.children, i, 1);
                this.div.removeChild(child._accessibleDiv);
                this.pool.push(child._accessibleDiv);
                child._accessibleDiv = null;
                i--;
                if (this.children.length === 0) {
                    this.deactivate();
                }
            }
            else {
                // map div to display..
                div = child._accessibleDiv;
                var hitArea = child.hitArea;
                var wt = child.worldTransform;
                if (child.hitArea) {
                    div.style.left = ((wt.tx + (hitArea.x * wt.a)) * sx) + "px";
                    div.style.top = ((wt.ty + (hitArea.y * wt.d)) * sy) + "px";
                    div.style.width = (hitArea.width * wt.a * sx) + "px";
                    div.style.height = (hitArea.height * wt.d * sy) + "px";
                }
                else {
                    hitArea = child.getBounds();
                    this.capHitArea(hitArea);
                    div.style.left = (hitArea.x * sx) + "px";
                    div.style.top = (hitArea.y * sy) + "px";
                    div.style.width = (hitArea.width * sx) + "px";
                    div.style.height = (hitArea.height * sy) + "px";
                    // update button titles and hints if they exist and they've changed
                    if (div.title !== child.accessibleTitle && child.accessibleTitle !== null) {
                        div.title = child.accessibleTitle;
                    }
                    if (div.getAttribute('aria-label') !== child.accessibleHint
                        && child.accessibleHint !== null) {
                        div.setAttribute('aria-label', child.accessibleHint);
                    }
                }
            }
        }
        // increment the render id..
        this.renderId++;
    }
    ;
    /**
     * Adjust the hit area based on the bounds of a display object
     *
     * @param {Rectangle} hitArea - Bounds of the child
     */
    capHitArea(hitArea) {
        if (hitArea.x < 0) {
            hitArea.width += hitArea.x;
            hitArea.x = 0;
        }
        if (hitArea.y < 0) {
            hitArea.height += hitArea.y;
            hitArea.y = 0;
        }
        if (hitArea.x + hitArea.width > this.renderer.width) {
            hitArea.width = this.renderer.width - hitArea.x;
        }
        if (hitArea.y + hitArea.height > this.renderer.height) {
            hitArea.height = this.renderer.height - hitArea.y;
        }
    }
    ;
    /**
     * Adds a DisplayObject to the accessibility manager
     *
     * @private
     * @param {DisplayObject} displayObject - The child to make accessible.
     */
    addChild(displayObject) {
        //this.activate();
        var div = this.pool.pop();
        if (!div) {
            div = document.createElement('button');
            div.style.width = AccessibilityManager.DIV_TOUCH_SIZE + "px";
            div.style.height = AccessibilityManager.DIV_TOUCH_SIZE + "px";
            div.style.backgroundColor = this.debug ? 'rgba(255,0,0,0.5)' : 'transparent';
            div.style.position = 'absolute';
            div.style.zIndex = AccessibilityManager.DIV_TOUCH_ZINDEX;
            div.style.borderStyle = 'none';
            // ARIA attributes ensure that button title and hint updates are announced properly
            if (navigator.userAgent.toLowerCase().indexOf('chrome') > -1) {
                // Chrome doesn't need aria-live to work as intended; in fact it just gets more confused.
                div.setAttribute('aria-live', 'off');
            }
            else {
                div.setAttribute('aria-live', 'polite');
            }
            if (navigator.userAgent.match(/rv:.*Gecko\//)) {
                // FireFox needs this to announce only the new button name
                div.setAttribute('aria-relevant', 'additions');
            }
            else {
                // required by IE, other browsers don't much care
                div.setAttribute('aria-relevant', 'text');
            }
            div.addEventListener('click', this._onClick.bind(this));
            div.addEventListener('focus', this._onFocus.bind(this));
            div.addEventListener('focusout', this._onFocusOut.bind(this));
        }
        if (displayObject.accessibleTitle && displayObject.accessibleTitle !== null) {
            div.title = displayObject.accessibleTitle;
        }
        else if (!displayObject.accessibleHint
            || displayObject.accessibleHint === null) {
            div.title = "displayObject " + (displayObject.tabIndex);
        }
        if (displayObject.accessibleHint
            && displayObject.accessibleHint !== null) {
            div.setAttribute('aria-label', displayObject.accessibleHint);
        }
        //
        displayObject._accessibleActive = true;
        displayObject._accessibleDiv = div;
        div.displayObject = displayObject;
        this.children.push(displayObject);
        this.div.appendChild(displayObject._accessibleDiv);
        displayObject._accessibleDiv.tabIndex = displayObject.tabIndex;
    }
    ;
    /**
     * Maps the div button press to pixi's  (click)
     *
     * @private
     * @param {MouseEvent} e - The click event.
     */
    _onClick(e) {
        var interactionManager = this.renderer.plugins.interaction;
        interactionManager.dispatchEvent(e.target.displayObject, 'click', interactionManager.eventData);
    }
    ;
    /**
     * Maps the div focus events to pixi's  (mouseover)
     *
     * @private
     * @param {FocusEvent} e - The focus event.
     */
    _onFocus(e) {
        if (!e.target.getAttribute('aria-live', 'off')) {
            e.target.setAttribute('aria-live', 'assertive');
        }
        var interactionManager = this.renderer.plugins.interaction;
        interactionManager.dispatchEvent(e.target.displayObject, 'mouseover', interactionManager.eventData);
    }
    ;
    /**
     * Maps the div focus events to pixi's  (mouseout)
     *
     * @private
     * @param {FocusEvent} e - The focusout event.
     */
    _onFocusOut(e) {
        if (!e.target.getAttribute('aria-live', 'off')) {
            e.target.setAttribute('aria-live', 'polite');
        }
        var interactionManager = this.renderer.plugins.interaction;
        interactionManager.dispatchEvent(e.target.displayObject, 'mouseout', interactionManager.eventData);
    }
    ;
    /**
     * Is called when a key is pressed
     *
     * @private
     * @param {KeyboardEvent} e - The keydown event.
     */
    _onKeyDown(e) {
        if (e.keyCode !== AccessibilityManager.KEY_CODE_TAB) {
            return;
        }
        this.activate();
    }
    ;
    /**
     * Is called when the mouse moves across the renderer element
     *
     * @private
     * @param {MouseEvent} e - The mouse event.
     */
    _onMouseMove(e) {
        if (e.movementX === 0 && e.movementY === 0) {
            return;
        }
        this.deactivate();
    }
    ;
    /**
     * Destroys the accessibility manager
     *
     */
    destroy() {
        this.destroyTouchHook();
        this.div = null;
        for (var i = 0; i < this.children.length; i++) {
            this.children[i].div = null;
        }
        window.document.removeEventListener('mousemove', this._onMouseMove, true);
        window.removeEventListener('keydown', this._onKeyDown);
        this.pool = null;
        this.children = null;
        this.renderer = null;
    }
    ;
}
AccessibilityManager.DIV_HOOK_SIZE = 1;
AccessibilityManager.DIV_HOOK_POS_X = -1000;
AccessibilityManager.DIV_HOOK_POS_Y = -1000;
AccessibilityManager.DIV_HOOK_ZINDEX = 2;
AccessibilityManager.KEY_CODE_TAB = 9;
AccessibilityManager.DIV_TOUCH_SIZE = 100;
AccessibilityManager.DIV_TOUCH_POS_X = 0;
AccessibilityManager.DIV_TOUCH_POS_Y = 0;
AccessibilityManager.DIV_TOUCH_ZINDEX = 2;
exports.AccessibilityManager = AccessibilityManager;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/AnimatedSprite.js":
/*!**************************************************!*\
  !*** ./js-compile/raw-pixi-ts/AnimatedSprite.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Sprite_1 = __webpack_require__(/*! ./Sprite */ "./js-compile/raw-pixi-ts/Sprite.js");
const Texture_1 = __webpack_require__(/*! ./Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const Ticker_1 = __webpack_require__(/*! ./Ticker */ "./js-compile/raw-pixi-ts/Ticker.js");
class AnimatedSprite extends Sprite_1.Sprite {
    constructor(textures, autoUpdate = true) {
        super(textures[0] instanceof Texture_1.Texture ? textures[0] : textures[0].texture);
        /**
         * @type {PIXI.Texture[]}
         * @private
         */
        this._textures = null;
        /**
         * @type {number[]}
         * @private
         */
        this._durations = null;
        this.textures = textures;
        /**
         * `true` uses PIXI.Ticker.shared to auto update animation time.
         * @type {boolean}
         * @default true
         * @private
         */
        this._autoUpdate = autoUpdate !== false;
        /**
         * The speed that the AnimatedSprite will play at. Higher is faster, lower is slower.
         *
         * @member {number}
         * @default 1
         */
        this.animationSpeed = 1;
        /**
         * Whether or not the animate sprite repeats after playing.
         *
         * @member {boolean}
         * @default true
         */
        this.loop = true;
        /**
         * Update anchor to [Texture's defaultAnchor]{@link PIXI.Texture#defaultAnchor} when frame changes.
         *
         * Useful with [sprite sheet animations]{@link PIXI.Spritesheet#animations} created with tools.
         * Changing anchor for each frame allows to pin sprite origin to certain moving feature
         * of the frame (e.g. left foot).
         *
         * Note: Enabling this will override any previously set `anchor` on each frame change.
         *
         * @member {boolean}
         * @default false
         */
        this.updateAnchor = false;
        /**
         * Function to call when a AnimatedSprite finishes playing.
         *
         * @member {Function}
         */
        this.onComplete = null;
        /**
         * Function to call when a AnimatedSprite changes which texture is being rendered.
         *
         * @member {Function}
         */
        this.onFrameChange = null;
        /**
         * Function to call when `loop` is true, and an AnimatedSprite is played and loops around to start again.
         *
         * @member {Function}
         */
        this.onLoop = null;
        /**
         * Elapsed time since animation has been started, used internally to display current texture.
         *
         * @member {number}
         * @private
         */
        this._currentTime = 0;
        /**
         * Indicates if the AnimatedSprite is currently playing.
         *
         * @member {boolean}
         * @readonly
         */
        this.playing = false;
    }
    /**
     * Stops the AnimatedSprite.
     *
     */
    stop() {
        if (!this.playing) {
            return;
        }
        this.playing = false;
        if (this._autoUpdate) {
            Ticker_1.Ticker.shared.remove(this.update, this);
        }
    }
    ;
    /**
     * Plays the AnimatedSprite.
     *
     */
    play() {
        if (this.playing) {
            return;
        }
        this.playing = true;
        if (this._autoUpdate) {
            Ticker_1.Ticker.shared.add(this.update, this, Ticker_1.Ticker.UPDATE_PRIORITY.HIGH);
        }
    }
    ;
    /**
     * Stops the AnimatedSprite and goes to a specific frame.
     *
     * @param {number} frameNumber - Frame index to stop at.
     */
    gotoAndStop(frameNumber) {
        this.stop();
        var previousFrame = this.currentFrame;
        this._currentTime = frameNumber;
        if (previousFrame !== this.currentFrame) {
            this.updateTexture();
        }
    }
    ;
    /**
     * Goes to a specific frame and begins playing the AnimatedSprite.
     *
     * @param {number} frameNumber - Frame index to start at.
     */
    gotoAndPlay(frameNumber) {
        var previousFrame = this.currentFrame;
        this._currentTime = frameNumber;
        if (previousFrame !== this.currentFrame) {
            this.updateTexture();
        }
        this.play();
    }
    ;
    /**
     * Updates the object transform for rendering.
     *
     * @private
     * @param {number} deltaTime - Time since last tick.
     */
    update(deltaTime) {
        var elapsed = this.animationSpeed * deltaTime;
        var previousFrame = this.currentFrame;
        if (this._durations !== null) {
            var lag = this._currentTime % 1 * this._durations[this.currentFrame];
            lag += elapsed / 60 * 1000;
            while (lag < 0) {
                this._currentTime--;
                lag += this._durations[this.currentFrame];
            }
            var sign = Math.sign(this.animationSpeed * deltaTime);
            this._currentTime = Math.floor(this._currentTime);
            while (lag >= this._durations[this.currentFrame]) {
                lag -= this._durations[this.currentFrame] * sign;
                this._currentTime += sign;
            }
            this._currentTime += lag / this._durations[this.currentFrame];
        }
        else {
            this._currentTime += elapsed;
        }
        if (this._currentTime < 0 && !this.loop) {
            this.gotoAndStop(0);
            if (this.onComplete) {
                this.onComplete();
            }
        }
        else if (this._currentTime >= this._textures.length && !this.loop) {
            this.gotoAndStop(this._textures.length - 1);
            if (this.onComplete) {
                this.onComplete();
            }
        }
        else if (previousFrame !== this.currentFrame) {
            if (this.loop && this.onLoop) {
                if (this.animationSpeed > 0 && this.currentFrame < previousFrame) {
                    this.onLoop();
                }
                else if (this.animationSpeed < 0 && this.currentFrame > previousFrame) {
                    this.onLoop();
                }
            }
            this.updateTexture();
        }
    }
    ;
    /**
     * Updates the displayed texture to match the current frame index.
     *
     * @private
     */
    updateTexture() {
        this._texture = this._textures[this.currentFrame];
        this._textureID = -1;
        this._textureTrimmedID = -1;
        this.cachedTint = 0xFFFFFF;
        this.uvs = this._texture._uvs.uvsFloat32;
        if (this.updateAnchor) {
            this._anchor.copy(this._texture.defaultAnchor);
        }
        if (this.onFrameChange) {
            this.onFrameChange(this.currentFrame);
        }
    }
    ;
    /**
     * Stops the AnimatedSprite and destroys it.
     *
     * @param {object|boolean} [options] - Options parameter. A boolean will act as if all options
     *  have been set to that value.
     * @param {boolean} [options.children=false] - If set to true, all the children will have their destroy
     *      method called as well. 'options' will be passed on to those calls.
     * @param {boolean} [options.texture=false] - Should it destroy the current texture of the sprite as well.
     * @param {boolean} [options.baseTexture=false] - Should it destroy the base texture of the sprite as well.
     */
    destroy(options) {
        this.stop();
        Sprite_1.Sprite.prototype.destroy.call(this, options);
        this.onComplete = null;
        this.onFrameChange = null;
        this.onLoop = null;
    }
    ;
    /**
     * A short hand way of creating a movieclip from an array of frame ids.
     *
     * @static
     * @param {string[]} frames - The array of frames ids the movieclip will use as its texture frames.
     * @return {AnimatedSprite} The new animated sprite with the specified frames.
     */
    static fromFrames(frames) {
        var textures = [];
        for (var i = 0; i < frames.length; ++i) {
            textures.push(Texture_1.Texture.from(frames[i]));
        }
        return new AnimatedSprite(textures);
    }
    ;
    /**
     * A short hand way of creating a movieclip from an array of image ids.
     *
     * @static
     * @param {string[]} images - The array of image urls the movieclip will use as its texture frames.
     * @return {AnimatedSprite} The new animate sprite with the specified images as frames.
     */
    static fromImages(images) {
        var textures = [];
        for (var i = 0; i < images.length; ++i) {
            textures.push(Texture_1.Texture.from(images[i]));
        }
        return new AnimatedSprite(textures);
    }
    ;
    /**
     * The total number of frames in the AnimatedSprite. This is the same as number of textures
     * assigned to the AnimatedSprite.
     *
     * @readonly
     * @member {number}
     * @default 0
     */
    get totalFrames() {
        return this._textures.length;
    }
    ;
    /**
     * The array of textures used for this AnimatedSprite.
     *
     * @member {PIXI.Texture[]}
     */
    get textures() {
        return this._textures;
    }
    ;
    set textures(value) {
        if (value[0] instanceof Texture_1.Texture) {
            this._textures = value;
            this._durations = null;
        }
        else {
            this._textures = [];
            this._durations = [];
            for (var i = 0; i < value.length; i++) {
                this._textures.push(value[i].texture);
                this._durations.push(value[i].time);
            }
        }
        this.gotoAndStop(0);
        this.updateTexture();
    }
    ;
    /**
    * The AnimatedSprites current frame index.
    *
    * @member {number}
    * @readonly
    */
    get currentFrame() {
        var currentFrame = Math.floor(this._currentTime) % this._textures.length;
        if (currentFrame < 0) {
            currentFrame += this._textures.length;
        }
        return currentFrame;
    }
    ;
}
exports.AnimatedSprite = AnimatedSprite;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/Application.js":
/*!***********************************************!*\
  !*** ./js-compile/raw-pixi-ts/Application.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Container_1 = __webpack_require__(/*! ./Container */ "./js-compile/raw-pixi-ts/Container.js");
const Renderer_1 = __webpack_require__(/*! ./Renderer */ "./js-compile/raw-pixi-ts/Renderer.js");
const StageOptions_1 = __webpack_require__(/*! ./StageOptions */ "./js-compile/raw-pixi-ts/StageOptions.js");
const Ticker_1 = __webpack_require__(/*! ./Ticker */ "./js-compile/raw-pixi-ts/Ticker.js");
const AccessibilityManager_1 = __webpack_require__(/*! ./AccessibilityManager */ "./js-compile/raw-pixi-ts/AccessibilityManager.js");
const Extract_1 = __webpack_require__(/*! ./Extract */ "./js-compile/raw-pixi-ts/Extract.js");
const InteractionManager_1 = __webpack_require__(/*! ./InteractionManager */ "./js-compile/raw-pixi-ts/InteractionManager.js");
const ParticleRenderer_1 = __webpack_require__(/*! ./ParticleRenderer */ "./js-compile/raw-pixi-ts/ParticleRenderer.js");
const Prepare_1 = __webpack_require__(/*! ./Prepare */ "./js-compile/raw-pixi-ts/Prepare.js");
const BatchRenderer_1 = __webpack_require__(/*! ./BatchRenderer */ "./js-compile/raw-pixi-ts/BatchRenderer.js");
const TilingSpriteRenderer_1 = __webpack_require__(/*! ./TilingSpriteRenderer */ "./js-compile/raw-pixi-ts/TilingSpriteRenderer.js");
class Application {
    constructor(options = null) {
        this.resize = () => {
            if (this._resizeTo) {
                if (this._resizeTo === window) {
                    this.renderer.resize(window.innerWidth, window.innerHeight);
                }
                else {
                    this.renderer.resize(this._resizeTo['clientWidth'], this._resizeTo['clientHeight']);
                }
            }
        };
        if (!options) {
            options = new StageOptions_1.StageOptions();
        }
        Renderer_1.Renderer.registerPlugin('accessibility', AccessibilityManager_1.AccessibilityManager);
        Renderer_1.Renderer.registerPlugin('extract', Extract_1.Extract);
        Renderer_1.Renderer.registerPlugin('interaction', InteractionManager_1.InteractionManager);
        Renderer_1.Renderer.registerPlugin('particle', ParticleRenderer_1.ParticleRenderer);
        Renderer_1.Renderer.registerPlugin('prepare', Prepare_1.Prepare);
        Renderer_1.Renderer.registerPlugin('batch', BatchRenderer_1.BatchRenderer);
        Renderer_1.Renderer.registerPlugin('tilingSprite', TilingSpriteRenderer_1.TilingSpriteRenderer);
        // this.loader = /*options.sharedLoader ? Loader.shared : */new Loader();
        this.renderer = new Renderer_1.Renderer(options); //Application.autoDetectRenderer(options);
        this._stage = new Container_1.Container();
        this.ticker = options.sharedTicker ? Ticker_1.Ticker.shared : new Ticker_1.Ticker();
        this.resizeTo = window;
        // DisplayObject.mixin(interactiveTarget);
        if (options.autoStart) {
            this.start();
        }
    }
    get ticker() {
        return this._ticker;
    }
    set ticker(ticker) {
        if (this._ticker) {
            this._ticker.remove(this.render, this);
        }
        this._ticker = ticker;
        if (ticker) {
            ticker.add(this.render, this, Ticker_1.Ticker.UPDATE_PRIORITY.LOW);
        }
    }
    start() {
        this._ticker.start();
    }
    ;
    stop() {
        this._ticker.stop();
    }
    ;
    get resizeTo() {
        return this._resizeTo;
    }
    set resizeTo(value) {
        window.removeEventListener('resize', this.resize);
        this._resizeTo = value;
        if (value) {
            window.addEventListener('resize', this.resize);
            this.resize();
        }
    }
    render() {
        this.renderer.render(this._stage);
    }
    ;
    get stage() {
        return this._stage;
    }
    get view() {
        return this.renderer.view;
    }
    ;
    get screen() {
        return this.renderer.screen;
    }
    ;
    destroy(options = null) {
        this._stage.destroy(options);
        this._stage = null;
        this.renderer.destroy(options);
        this.renderer = null;
        this._options = null;
        // if (this.loader)
        // {
        //     this.loader.destroy();
        //     this.loader = null;
        // }
    }
    ;
}
exports.Application = Application;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/ArcUtils.js":
/*!********************************************!*\
  !*** ./js-compile/raw-pixi-ts/ArcUtils.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const settings_1 = __webpack_require__(/*! ./settings */ "./js-compile/raw-pixi-ts/settings.js");
const MathSettings_1 = __webpack_require__(/*! ./MathSettings */ "./js-compile/raw-pixi-ts/MathSettings.js");
class ArcUtils {
    constructor() {
    }
    static curveTo(x1, y1, x2, y2, radius, points) {
        var fromX = points[points.length - 2];
        var fromY = points[points.length - 1];
        var a1 = fromY - y1;
        var b1 = fromX - x1;
        var a2 = y2 - y1;
        var b2 = x2 - x1;
        var mm = Math.abs((a1 * b2) - (b1 * a2));
        if (mm < 1.0e-8 || radius === 0) {
            if (points[points.length - 2] !== x1 || points[points.length - 1] !== y1) {
                points.push(x1, y1);
            }
            return null;
        }
        var dd = (a1 * a1) + (b1 * b1);
        var cc = (a2 * a2) + (b2 * b2);
        var tt = (a1 * a2) + (b1 * b2);
        var k1 = radius * Math.sqrt(dd) / mm;
        var k2 = radius * Math.sqrt(cc) / mm;
        var j1 = k1 * tt / dd;
        var j2 = k2 * tt / cc;
        var cx = (k1 * b2) + (k2 * b1);
        var cy = (k1 * a2) + (k2 * a1);
        var px = b1 * (k2 + j1);
        var py = a1 * (k2 + j1);
        var qx = b2 * (k1 + j2);
        var qy = a2 * (k1 + j2);
        var startAngle = Math.atan2(py - cy, px - cx);
        var endAngle = Math.atan2(qy - cy, qx - cx);
        return {
            cx: (cx + x1),
            cy: (cy + y1),
            radius: radius,
            startAngle: startAngle,
            endAngle: endAngle,
            anticlockwise: (b1 * a2 > b2 * a1),
        };
    }
    ;
    /**
     * The arc method creates an arc/curve (used to create circles, or parts of circles).
     *
     * @private
     * @param {number} startX - Start x location of arc
     * @param {number} startY - Start y location of arc
     * @param {number} cx - The x-coordinate of the center of the circle
     * @param {number} cy - The y-coordinate of the center of the circle
     * @param {number} radius - The radius of the circle
     * @param {number} startAngle - The starting angle, in radians (0 is at the 3 o'clock position
     *  of the arc's circle)
     * @param {number} endAngle - The ending angle, in radians
     * @param {boolean} anticlockwise - Specifies whether the drawing should be
     *  counter-clockwise or clockwise. False is default, and indicates clockwise, while true
     *  indicates counter-clockwise.
     * @param {number} n - Number of segments
     * @param {number[]} points - Collection of points to add to
     */
    static arc(startX, startY, cx, cy, radius, startAngle, endAngle, anticlockwise, points) {
        var sweep = endAngle - startAngle;
        var n = settings_1.settings.GRAPHICS_CURVES._segmentsCount(Math.abs(sweep) * radius, Math.ceil(Math.abs(sweep) / MathSettings_1.MathSettings.PI_2) * 40);
        var theta = (sweep) / (n * 2);
        var theta2 = theta * 2;
        var cTheta = Math.cos(theta);
        var sTheta = Math.sin(theta);
        var segMinus = n - 1;
        var remainder = (segMinus % 1) / segMinus;
        for (var i = 0; i <= segMinus; ++i) {
            var real = i + (remainder * i);
            var angle = ((theta) + startAngle + (theta2 * real));
            var c = Math.cos(angle);
            var s = -Math.sin(angle);
            points.push((((cTheta * c) + (sTheta * s)) * radius) + cx, (((cTheta * -s) + (sTheta * c)) * radius) + cy);
        }
    }
    ;
}
exports.ArcUtils = ArcUtils;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/ArrayResource.js":
/*!*************************************************!*\
  !*** ./js-compile/raw-pixi-ts/ArrayResource.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Resource_1 = __webpack_require__(/*! ./Resource */ "./js-compile/raw-pixi-ts/Resource.js");
const BaseTexture_1 = __webpack_require__(/*! ./BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const ResourceSettings_1 = __webpack_require__(/*! ./ResourceSettings */ "./js-compile/raw-pixi-ts/ResourceSettings.js");
const WebGLSettings_1 = __webpack_require__(/*! ./WebGLSettings */ "./js-compile/raw-pixi-ts/WebGLSettings.js");
class ArrayResource extends Resource_1.Resource {
    constructor(source, options) {
        options = options || {};
        var urls;
        var length = source;
        if (Array.isArray(source)) {
            urls = source;
            length = source.length;
        }
        super(options.width, options.height);
        /**
         * Collection of resources.
         * @member {Array<PIXI.BaseTexture>}
         * @readonly
         */
        this.items = [];
        /**
         * Dirty IDs for each part
         * @member {Array<number>}
         * @readonly
         */
        this.itemDirtyIds = [];
        for (var i = 0; i < length; i++) {
            var partTexture = new BaseTexture_1.BaseTexture();
            this.items.push(partTexture);
            this.itemDirtyIds.push(-1);
        }
        /**
         * Number of elements in array
         *
         * @member {number}
         * @readonly
         */
        this.length = length;
        /**
         * Promise when loading
         * @member {Promise}
         * @private
         * @default null
         */
        this._load = null;
        if (urls) {
            for (var i$1 = 0; i$1 < length; i$1++) {
                this.addResourceAt(ResourceSettings_1.ResourceSettings.autoDetectResource(urls[i$1], options), i$1);
            }
        }
    }
    /**
     * Destroy this BaseImageResource
     * @override
     */
    dispose() {
        for (var i = 0, len = this.length; i < len; i++) {
            this.items[i].destroy();
        }
        this.items = null;
        this.itemDirtyIds = null;
        this._load = null;
    }
    ;
    /**
     * Set a resource by ID
     *
     * @param {PIXI.resources.Resource} resource
     * @param {number} index - Zero-based index of resource to set
     * @return {PIXI.resources.ArrayResource} Instance for chaining
     */
    addResourceAt(resource, index) {
        var baseTexture = this.items[index];
        if (!baseTexture) {
            throw new Error(("Index " + index + " is out of bounds"));
        }
        // Inherit the first resource dimensions
        if (resource.valid && !this.valid) {
            this.resize(resource.width, resource.height);
        }
        this.items[index].setResource(resource);
        return this;
    }
    ;
    /**
     * Set the parent base texture
     * @member {PIXI.BaseTexture}
     * @override
     */
    bind(baseTexture) {
        super.bind(baseTexture);
        baseTexture.target = WebGLSettings_1.WebGLSettings.TARGETS.TEXTURE_2D_ARRAY;
        for (var i = 0; i < this.length; i++) {
            this.items[i].on('update', baseTexture.update, baseTexture);
        }
    }
    ;
    /**
     * Unset the parent base texture
     * @member {PIXI.BaseTexture}
     * @override
     */
    unbind(baseTexture) {
        super.unbind(baseTexture);
        for (var i = 0; i < this.length; i++) {
            this.items[i].off('update', baseTexture.update, baseTexture);
        }
    }
    ;
    /**
     * Load all the resources simultaneously
     * @override
     * @return {Promise<void>} When load is resolved
     */
    load() {
        var this$1 = this;
        if (this._load) {
            return this._load;
        }
        var resources = this.items.map(function (item) { return item.resource; });
        // TODO: also implement load part-by-part strategy
        var promises = resources.map(function (item) { return item.load(); });
        this._load = Promise.all(promises)
            .then(function () {
            var ref = resources[0];
            var width = ref.width;
            var height = ref.height;
            this$1.resize(width, height);
            return Promise.resolve(this$1);
        });
        return this._load;
    }
    ;
    /**
     * Upload the resources to the GPU.
     * @param {PIXI.Renderer} renderer
     * @param {PIXI.BaseTexture} texture
     * @param {PIXI.GLTexture} glTexture
     * @returns {boolean} whether texture was uploaded
     */
    upload(renderer, texture, glTexture) {
        var ref = this;
        var length = ref.length;
        var itemDirtyIds = ref.itemDirtyIds;
        var items = ref.items;
        var gl = renderer.gl;
        if (glTexture.dirtyId < 0) {
            gl.texImage3D(gl.TEXTURE_2D_ARRAY, 0, texture.format, this._width, this._height, length, 0, texture.format, texture.type, null);
        }
        for (var i = 0; i < length; i++) {
            var item = items[i];
            if (itemDirtyIds[i] < item.dirtyId) {
                itemDirtyIds[i] = item.dirtyId;
                if (item.valid) {
                    gl.texSubImage3D(gl.TEXTURE_2D_ARRAY, 0, 0, // xoffset
                    0, // yoffset
                    i, // zoffset
                    item.resource.width, item.resource.height, 1, texture.format, texture.type, item.resource.source);
                }
            }
        }
        return true;
    }
    ;
}
exports.ArrayResource = ArrayResource;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/Attribute.js":
/*!*********************************************!*\
  !*** ./js-compile/raw-pixi-ts/Attribute.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Logger_1 = __webpack_require__(/*! .//Logger */ "./js-compile/raw-pixi-ts/Logger.js");
class Attribute {
    constructor(buffer, size, normalized = false, type = 5126, stride = undefined, start = undefined, instance = undefined) {
        this.buffer = buffer;
        this.size = size;
        this.normalized = normalized;
        this.type = type;
        this._stride = stride;
        this.start = start;
        this.instance = instance;
    }
    ;
    set stride(value) {
        Logger_1.trace("set to " + value);
        this._stride = value;
    }
    get stride() {
        return this._stride;
    }
    destroy(options = null) {
        this.buffer = null;
    }
    ;
}
exports.Attribute = Attribute;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/BaseImageResource.js":
/*!*****************************************************!*\
  !*** ./js-compile/raw-pixi-ts/BaseImageResource.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Resource_1 = __webpack_require__(/*! ./Resource */ "./js-compile/raw-pixi-ts/Resource.js");
const NetworkSettings_1 = __webpack_require__(/*! ./NetworkSettings */ "./js-compile/raw-pixi-ts/NetworkSettings.js");
const Logger_1 = __webpack_require__(/*! ./Logger */ "./js-compile/raw-pixi-ts/Logger.js");
class BaseImageResource extends Resource_1.Resource {
    constructor(source) {
        super(source.width, source.height);
        this.source = source;
    }
    /**
     * Set cross origin based detecting the url and the crossorigin
     * @protected
     * @param {HTMLElement} element - Element to apply crossOrigin
     * @param {string} url - URL to check
     * @param {boolean|string} [crossorigin=true] - Cross origin value to use
     */
    static crossOrigin(element, url, crossorigin) {
        if (crossorigin === undefined && url.indexOf('data:') !== 0) {
            element.crossOrigin = NetworkSettings_1.NetworkSettings.determineCrossOrigin(url);
        }
        else if (crossorigin !== false) {
            element.crossOrigin = typeof crossorigin === 'string' ? crossorigin : 'anonymous';
        }
    }
    ;
    /**
     * Upload the texture to the GPU.
     * @param {PIXI.Renderer} renderer Upload to the renderer
     * @param {PIXI.BaseTexture} baseTexture Reference to parent texture
     * @param {PIXI.GLTexture} glTexture
     * @param {HTMLImageElement|HTMLCanvasElement|HTMLVideoElement|SVGElement} [source] (optional)
     * @returns {boolean} true is success
     */
    upload(renderer, baseTexture, glTexture, source = null) {
        var gl = renderer.gl;
        var width = baseTexture.realWidth;
        var height = baseTexture.realHeight;
        source = source || this.source;
        Logger_1.trace("update upload " + baseTexture.type);
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, baseTexture.premultiplyAlpha);
        if (baseTexture.target === gl.TEXTURE_2D && glTexture.width === width && glTexture.height === height) {
            // trace("update upload " + glTexture.width + ":" + glTexture.height)
            gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, baseTexture.format, baseTexture.type, source);
        }
        else {
            glTexture.width = width;
            glTexture.height = height;
            Logger_1.trace("first upload " + width + ":" + height);
            gl.texImage2D(baseTexture.target, 0, baseTexture.format, baseTexture.format, baseTexture.type, source);
        }
        return true;
    }
    ;
    /**
     * Destroy this BaseImageResource
     * @override
     * @param {PIXI.BaseTexture} [fromTexture] Optional base texture
     * @return {boolean} Destroy was successful
     */
    dispose() {
        this.source = null;
    }
    ;
}
exports.BaseImageResource = BaseImageResource;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/BasePrepare.js":
/*!***********************************************!*\
  !*** ./js-compile/raw-pixi-ts/BasePrepare.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Ticker_1 = __webpack_require__(/*! ./Ticker */ "./js-compile/raw-pixi-ts/Ticker.js");
const Container_1 = __webpack_require__(/*! ./Container */ "./js-compile/raw-pixi-ts/Container.js");
const TextStyle_1 = __webpack_require__(/*! ./TextStyle */ "./js-compile/raw-pixi-ts/TextStyle.js");
const Text_1 = __webpack_require__(/*! ./Text */ "./js-compile/raw-pixi-ts/Text.js");
const Texture_1 = __webpack_require__(/*! ./Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const BaseTexture_1 = __webpack_require__(/*! ./BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const TextMetrics_1 = __webpack_require__(/*! ./TextMetrics */ "./js-compile/raw-pixi-ts/TextMetrics.js");
const CountLimiter_1 = __webpack_require__(/*! ./CountLimiter */ "./js-compile/raw-pixi-ts/CountLimiter.js");
const WebGLSettings_1 = __webpack_require__(/*! ./WebGLSettings */ "./js-compile/raw-pixi-ts/WebGLSettings.js");
class BasePrepare //extends Renderer
 {
    constructor(renderer) {
        // super(null);
        /**
         * The limiter to be used to control how quickly items are prepared.
         * @type {PIXI.prepare.CountLimiter|PIXI.prepare.TimeLimiter}
         */
        this.limiter = new CountLimiter_1.CountLimiter(WebGLSettings_1.WebGLSettings.UPLOADS_PER_FRAME);
        /**
         * Reference to the renderer.
         * @type {PIXI.AbstractRenderer}
         * @protected
         */
        this.renderer = renderer;
        /**
         * The only real difference between CanvasPrepare and WebGLPrepare is what they pass
         * to upload hooks. That different parameter is stored here.
         * @type {PIXI.prepare.CanvasPrepare|PIXI.Renderer}
         * @protected
         */
        this.uploadHookHelper = renderer;
        /**
         * Collection of items to uploads at once.
         * @type {Array<*>}
         * @private
         */
        this.queue = [];
        /**
         * Collection of additional hooks for finding assets.
         * @type {Array<Function>}
         * @private
         */
        this.addHooks = [];
        /**
         * Collection of additional hooks for processing assets.
         * @type {Array<Function>}
         * @private
         */
        this.uploadHooks = [];
        /**
         * Callback to call after completed.
         * @type {Array<Function>}
         * @private
         */
        this.completes = [];
        /**
         * If prepare is ticking (running).
         * @type {boolean}
         * @private
         */
        this.ticking = false;
        /**
         * 'bound' call for prepareItems().
         * @type {Function}
         * @private
         */
        this.delayedTick = function () {
            // unlikely, but in case we were destroyed between tick() and delayedTick()
            if (!this.queue) {
                return;
            }
            this.prepareItems();
        };
        // hooks to find the correct texture
        this.registerFindHook(BasePrepare.findText);
        this.registerFindHook(BasePrepare.findTextStyle);
        this.registerFindHook(BasePrepare.findMultipleBaseTextures);
        this.registerFindHook(BasePrepare.findBaseTexture);
        this.registerFindHook(BasePrepare.findTexture);
        // upload hooks
        this.registerUploadHook(BasePrepare.drawText);
        this.registerUploadHook(BasePrepare.calculateTextStyle);
    }
    /**
     * Upload all the textures and graphics to the GPU.
     *
     * @param {Function|PIXI.DisplayObject|PIXI.Container|PIXI.BaseTexture|PIXI.Texture|PIXI.Graphics|PIXI.Text} item -
     *    Either the container or display object to search for items to upload, the items to upload themselves,
     *    or the callback function, if items have been added using `prepare.add`.
     * @param {Function} [done] - Optional callback when all queued uploads have completed
     */
    upload(item, done) {
        if (typeof item === 'function') {
            done = item;
            item = null;
        }
        // If a display object, search for items
        // that we could upload
        if (item) {
            this.add(item);
        }
        // Get the items for upload from the display
        if (this.queue.length) {
            if (done) {
                this.completes.push(done);
            }
            if (!this.ticking) {
                this.ticking = true;
                Ticker_1.Ticker.system.addOnce(this.tick, this, Ticker_1.Ticker.UPDATE_PRIORITY.UTILITY);
            }
        }
        else if (done) {
            done();
        }
    }
    ;
    /**
     * Handle tick update
     *
     * @private
     */
    tick() {
        setTimeout(this.delayedTick, 0);
    }
    ;
    /**
     * Actually prepare items. This is handled outside of the tick because it will take a while
     * and we do NOT want to block the current animation frame from rendering.
     *
     * @private
     */
    prepareItems() {
        this.limiter.beginFrame();
        // Upload the graphics
        while (this.queue.length && this.limiter.allowedToUpload()) {
            var item = this.queue[0];
            var uploaded = false;
            if (item && !item._destroyed) {
                for (var i = 0, len = this.uploadHooks.length; i < len; i++) {
                    if (this.uploadHooks[i](this.uploadHookHelper, item)) {
                        this.queue.shift();
                        uploaded = true;
                        break;
                    }
                }
            }
            if (!uploaded) {
                this.queue.shift();
            }
        }
        // We're finished
        if (!this.queue.length) {
            this.ticking = false;
            var completes = this.completes.slice(0);
            this.completes.length = 0;
            for (var i$1 = 0, len$1 = completes.length; i$1 < len$1; i$1++) {
                completes[i$1]();
            }
        }
        else {
            // if we are not finished, on the next rAF do this again
            Ticker_1.Ticker.system.addOnce(this.tick, this, Ticker_1.Ticker.UPDATE_PRIORITY.UTILITY);
        }
    }
    ;
    /**
     * Adds hooks for finding items.
     *
     * @param {Function} addHook - Function call that takes two parameters: `item:*, queue:Array`
     *      function must return `true` if it was able to add item to the queue.
     * @return {PIXI.prepare.BasePrepare} Instance of plugin for chaining.
     */
    registerFindHook(addHook) {
        if (addHook) {
            this.addHooks.push(addHook);
        }
        return this;
    }
    ;
    /**
     * Adds hooks for uploading items.
     *
     * @param {Function} uploadHook - Function call that takes two parameters: `prepare:CanvasPrepare, item:*` and
     *      function must return `true` if it was able to handle upload of item.
     * @return {PIXI.prepare.BasePrepare} Instance of plugin for chaining.
     */
    registerUploadHook(uploadHook) {
        if (uploadHook) {
            this.uploadHooks.push(uploadHook);
        }
        return this;
    }
    ;
    /**
     * Manually add an item to the uploading queue.
     *
     * @param {PIXI.DisplayObject|PIXI.Container|PIXI.BaseTexture|PIXI.Texture|PIXI.Graphics|PIXI.Text|*} item - Object to
     *    add to the queue
     * @return {PIXI.prepare.BasePrepare} Instance of plugin for chaining.
     */
    add(item) {
        // Add additional hooks for finding elements on special
        // types of objects that
        for (var i = 0, len = this.addHooks.length; i < len; i++) {
            if (this.addHooks[i](item, this.queue)) {
                break;
            }
        }
        // Get children recursively
        if (item instanceof Container_1.Container) {
            for (var i$1 = item.children.length - 1; i$1 >= 0; i$1--) {
                this.add(item.children[i$1]);
            }
        }
        return this;
    }
    ;
    /**
     * Destroys the plugin, don't use after this.
     *
     */
    destroy() {
        if (this.ticking) {
            Ticker_1.Ticker.system.remove(this.tick, this);
        }
        this.ticking = false;
        this.addHooks = null;
        this.uploadHooks = null;
        this.renderer = null;
        this.completes = null;
        this.queue = null;
        this.limiter = null;
        this.uploadHookHelper = null;
    }
    ;
    /**
 * Built-in hook to find Text objects.
 *
 * @private
 * @param {PIXI.DisplayObject} item - Display object to check
 * @param {Array<*>} queue - Collection of items to upload
 * @return {boolean} if a PIXI.Text object was found.
 */
    static findText(item, queue) {
        if (item instanceof Text_1.Text) {
            // push the text style to prepare it - this can be really expensive
            if (queue.indexOf(item.style) === -1) {
                queue.push(item.style);
            }
            // also push the text object so that we can render it (to canvas/texture) if needed
            if (queue.indexOf(item) === -1) {
                queue.push(item);
            }
            // also push the Text's texture for upload to GPU
            var texture = item._texture.baseTexture;
            if (queue.indexOf(texture) === -1) {
                queue.push(texture);
            }
            return true;
        }
        return false;
    }
    /**
 * Built-in hook to find TextStyle objects.
 *
 * @private
 * @param {PIXI.TextStyle} item - Display object to check
 * @param {Array<*>} queue - Collection of items to upload
 * @return {boolean} if a PIXI.TextStyle object was found.
 */
    static findTextStyle(item, queue) {
        if (item instanceof TextStyle_1.TextStyle) {
            if (queue.indexOf(item) === -1) {
                queue.push(item);
            }
            return true;
        }
        return false;
    }
    /**
 * Built-in hook to find multiple textures from objects like AnimatedSprites.
 *
 * @private
 * @param {PIXI.DisplayObject} item - Display object to check
 * @param {Array<*>} queue - Collection of items to upload
 * @return {boolean} if a PIXI.Texture object was found.
 */
    static findMultipleBaseTextures(item, queue) {
        var result = false;
        // Objects with multiple textures
        if (item && item._textures && item._textures.length) {
            for (var i = 0; i < item._textures.length; i++) {
                if (item._textures[i] instanceof Texture_1.Texture) {
                    var baseTexture = item._textures[i].baseTexture;
                    if (queue.indexOf(baseTexture) === -1) {
                        queue.push(baseTexture);
                        result = true;
                    }
                }
            }
        }
        return result;
    }
    /**
 * Built-in hook to find BaseTextures from Sprites.
 *
 * @private
 * @param {PIXI.DisplayObject} item - Display object to check
 * @param {Array<*>} queue - Collection of items to upload
 * @return {boolean} if a PIXI.Texture object was found.
 */
    static findBaseTexture(item, queue) {
        // Objects with textures, like Sprites/Text
        if (item instanceof BaseTexture_1.BaseTexture) {
            if (queue.indexOf(item) === -1) {
                queue.push(item);
            }
            return true;
        }
        return false;
    }
    /**
 * Built-in hook to find textures from objects.
 *
 * @private
 * @param {PIXI.DisplayObject} item - Display object to check
 * @param {Array<*>} queue - Collection of items to upload
 * @return {boolean} if a PIXI.Texture object was found.
 */
    static findTexture(item, queue) {
        if (item._texture && item._texture instanceof Texture_1.Texture) {
            var texture = item._texture.baseTexture;
            if (queue.indexOf(texture) === -1) {
                queue.push(texture);
            }
            return true;
        }
        return false;
    }
    /**
     * Built-in hook to draw PIXI.Text to its texture.
     *
     * @private
     * @param {PIXI.Renderer|PIXI.CanvasPrepare} helper - Not used by this upload handler
     * @param {PIXI.DisplayObject} item - Item to check
     * @return {boolean} If item was uploaded.
     */
    static drawText(helper, item) {
        if (item instanceof Text_1.Text) {
            // updating text will return early if it is not dirty
            item.updateText(true);
            return true;
        }
        return false;
    }
    /**
 * Built-in hook to calculate a text style for a PIXI.Text object.
 *
 * @private
 * @param {PIXI.Renderer|PIXI.CanvasPrepare} helper - Not used by this upload handler
 * @param {PIXI.DisplayObject} item - Item to check
 * @return {boolean} If item was uploaded.
 */
    static calculateTextStyle(helper, item) {
        if (item instanceof TextStyle_1.TextStyle) {
            var font = item.toFontString();
            TextMetrics_1.TextMetrics.measureFont(font);
            return true;
        }
        return false;
    }
}
exports.BasePrepare = BasePrepare;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/BaseRenderTexture.js":
/*!*****************************************************!*\
  !*** ./js-compile/raw-pixi-ts/BaseRenderTexture.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseTexture_1 = __webpack_require__(/*! ./BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const Framebuffer_1 = __webpack_require__(/*! ./Framebuffer */ "./js-compile/raw-pixi-ts/Framebuffer.js");
class BaseRenderTexture extends BaseTexture_1.BaseTexture {
    constructor(options, arg1 = null, arg2 = null, arg4 = null) {
        super(null, options);
        if (typeof options === 'number') {
            /* eslint-disable prefer-rest-params */
            // Backward compatibility of signature
            var width$1 = arguments[0];
            var height$1 = arguments[1];
            var scaleMode = arguments[2];
            var resolution = arguments[3];
            options = { width: width$1, height: height$1, scaleMode: scaleMode, resolution: resolution };
            /* eslint-enable prefer-rest-params */
        }
        var ref = options || {};
        var width = ref.width;
        var height = ref.height;
        // Set defaults
        this.mipmap = false;
        this.width = Math.ceil(width) || 100;
        this.height = Math.ceil(height) || 100;
        this.valid = true;
        /**
         * A reference to the canvas render target (we only need one as this can be shared across renderers)
         *
         * @protected
         * @member {object}
         */
        this._canvasRenderTarget = null;
        this.clearColor = [0, 0, 0, 0];
        this.framebuffer = new Framebuffer_1.Framebuffer(this.width * this.resolution, this.height * this.resolution)
            .addColorTexture(0, this)
            .enableStencil();
        // TODO - could this be added the systems?
        /**
         * The data structure for the stencil masks.
         *
         * @member {PIXI.Graphics[]}
         */
        this.stencilMaskStack = [];
        /**
         * The data structure for the filters.
         *
         * @member {PIXI.Graphics[]}
         */
        this.filterStack = [{}];
    }
    /**
     * Resizes the BaseRenderTexture.
     *
     * @param {number} width - The width to resize to.
     * @param {number} height - The height to resize to.
     */
    resize(width, height) {
        width = Math.ceil(width);
        height = Math.ceil(height);
        this.framebuffer.resize(width * this.resolution, height * this.resolution);
    }
    ;
    /**
     * Frees the texture and framebuffer from WebGL memory without destroying this texture object.
     * This means you can still use the texture later which will upload it to GPU
     * memory again.
     *
     * @fires PIXI.BaseTexture#dispose
     */
    dispose() {
        this.framebuffer.dispose();
        super.dispose();
    }
    ;
    /**
     * Destroys this texture.
     *
     */
    destroy() {
        super.destroy();
        this.framebuffer = null;
        this.renderer = null;
    }
    ;
}
exports.BaseRenderTexture = BaseRenderTexture;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/BaseTexture.js":
/*!***********************************************!*\
  !*** ./js-compile/raw-pixi-ts/BaseTexture.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const EventDispatcher_1 = __webpack_require__(/*! ./EventDispatcher */ "./js-compile/raw-pixi-ts/EventDispatcher.js");
const Event_1 = __webpack_require__(/*! ./Event */ "./js-compile/raw-pixi-ts/Event.js");
const Resource_1 = __webpack_require__(/*! ./Resource */ "./js-compile/raw-pixi-ts/Resource.js");
const BufferResource_1 = __webpack_require__(/*! ./BufferResource */ "./js-compile/raw-pixi-ts/BufferResource.js");
const DisplaySettings_1 = __webpack_require__(/*! ./DisplaySettings */ "./js-compile/raw-pixi-ts/DisplaySettings.js");
const MathSettings_1 = __webpack_require__(/*! ./MathSettings */ "./js-compile/raw-pixi-ts/MathSettings.js");
const WebGLSettings_1 = __webpack_require__(/*! ./WebGLSettings */ "./js-compile/raw-pixi-ts/WebGLSettings.js");
const CacheSettings_1 = __webpack_require__(/*! ./CacheSettings */ "./js-compile/raw-pixi-ts/CacheSettings.js");
const ResourceSettings_1 = __webpack_require__(/*! ./ResourceSettings */ "./js-compile/raw-pixi-ts/ResourceSettings.js");
const Logger_1 = __webpack_require__(/*! ./Logger */ "./js-compile/raw-pixi-ts/Logger.js");
class BaseTexture extends EventDispatcher_1.EventDispatcher {
    constructor(resource = null, options = null) {
        super();
        this.handleResize = (event) => {
            this.setRealSize(this.resource.width, this.resource.height);
        };
        this.handleUpdate = (event) => {
            this.update();
        };
        options = options || {};
        var premultiplyAlpha = options.premultiplyAlpha;
        var mipmap = options.mipmap;
        var scaleMode = options.scaleMode;
        var width = options.width;
        var height = options.height;
        var wrapMode = options.wrapMode;
        var format = options.format;
        var type = options.type;
        var target = options.target;
        var resolution = options.resolution;
        var resourceOptions = options.resourceOptions;
        // Convert the resource to a Resource object
        if (resource && resource instanceof ImageBitmap) {
        }
        else if (resource && !(resource instanceof Resource_1.Resource)) {
            resource = ResourceSettings_1.ResourceSettings.autoDetectResource(resource, resourceOptions);
            Logger_1.reveal(resource);
            resource.internal = true;
        }
        /**
         * The width of the base texture set when the image has loaded
         *
         * @readonly
         * @member {number}
         */
        this.width = width || 0;
        /**
         * The height of the base texture set when the image has loaded
         *
         * @readonly
         * @member {number}
         */
        this.height = height || 0;
        /**
         * The resolution / device pixel ratio of the texture
         *
         * @member {number}
         * @default PIXI.settings.RESOLUTION
         */
        this.resolution = resolution || DisplaySettings_1.DisplaySettings.RESOLUTION;
        /**
         * Mipmap mode of the texture, affects downscaled images
         *
         * @member {PIXI.MIPMAP_MODES}
         * @default PIXI.settings.MIPMAP_TEXTURES
         */
        this.mipmap = mipmap !== undefined ? mipmap : WebGLSettings_1.WebGLSettings.MIPMAP_TEXTURES;
        /**
         * How the texture wraps
         * @member {number}
         */
        this.wrapMode = wrapMode || WebGLSettings_1.WebGLSettings.WRAP_MODE;
        /**
         * The scale mode to apply when scaling this texture
         *
         * @member {PIXI.SCALE_MODES}
         * @default PIXI.settings.SCALE_MODE
         */
        this.scaleMode = scaleMode !== undefined ? scaleMode : DisplaySettings_1.DisplaySettings.SCALE_MODE;
        /**
         * The pixel format of the texture
         *
         * @member {PIXI.FORMATS}
         * @default PIXI.FORMATS.RGBA
         */
        this.format = format || WebGLSettings_1.WebGLSettings.FORMATS.RGBA;
        /**
         * The type of resource data
         *
         * @member {PIXI.TYPES}
         * @default PIXI.TYPES.UNSIGNED_BYTE
         */
        this.type = type || WebGLSettings_1.WebGLSettings.TYPES.UNSIGNED_BYTE;
        /**
         * The target type
         *
         * @member {PIXI.TARGETS}
         * @default PIXI.TARGETS.TEXTURE_2D
         */
        this.target = target || WebGLSettings_1.WebGLSettings.TARGETS.TEXTURE_2D;
        /**
         * Set to true to enable pre-multiplied alpha
         *
         * @member {boolean}
         * @default true
         */
        this.premultiplyAlpha = premultiplyAlpha !== false;
        /**
         * Global unique identifier for this BaseTexture
         *
         * @member {string}
         * @protected
         */
        this.uid = MathSettings_1.MathSettings.uid();
        /**
         * Used by automatic texture Garbage Collection, stores last GC tick when it was bound
         *
         * @member {number}
         * @protected
         */
        this.touched = 0;
        /**
         * Whether or not the texture is a power of two, try to use power of two textures as much
         * as you can
         *
         * @readonly
         * @member {boolean}
         * @default false
         */
        this.isPowerOfTwo = false;
        this._refreshPOT();
        /**
         * The map of render context textures where this is bound
         *
         * @member {Object}
         * @private
         */
        this._glTextures = {};
        /**
         * Used by TextureSystem to only update texture to the GPU when needed.
         *
         * @protected
         * @member {number}
         */
        this.dirtyId = 0;
        /**
         * Used by TextureSystem to only update texture style when needed.
         *
         * @protected
         * @member {number}
         */
        this.dirtyStyleId = 0;
        /**
         * Currently default cache ID.
         *
         * @member {string}
         */
        this.cacheId = null;
        /**
         * Generally speaking means when resource is loaded.
         * @readonly
         * @member {boolean}
         */
        this.valid = width > 0 && height > 0;
        /**
         * The collection of alternative cache ids, since some BaseTextures
         * can have more than one ID, short name and longer full URL
         *
         * @member {Array<string>}
         * @readonly
         */
        this.textureCacheIds = [];
        /**
         * Flag if BaseTexture has been destroyed.
         *
         * @member {boolean}
         * @readonly
         */
        this.destroyed = false;
        /**
         * The resource used by this BaseTexture, there can only
         * be one resource per BaseTexture, but textures can share
         * resources.
         *
         * @member {PIXI.resources.Resource}
         * @readonly
         */
        this.resource = null;
        /**
         * Number of the texture batch, used by multi-texture renderers
         *
         * @member {number}
         */
        this._batchEnabled = 0;
        /**
         * Fired when a not-immediately-available source finishes loading.
         *
         * @protected
         * @event PIXI.BaseTexture#loaded
         * @param {PIXI.BaseTexture} baseTexture - Resource loaded.
         */
        /**
         * Fired when a not-immediately-available source fails to load.
         *
         * @protected
         * @event PIXI.BaseTexture#error
         * @param {PIXI.BaseTexture} baseTexture - Resource errored.
         */
        /**
         * Fired when BaseTexture is updated.
         *
         * @protected
         * @event PIXI.BaseTexture#loaded
         * @param {PIXI.BaseTexture} baseTexture - Resource loaded.
         */
        /**
         * Fired when BaseTexture is destroyed.
         *
         * @protected
         * @event PIXI.BaseTexture#error
         * @param {PIXI.BaseTexture} baseTexture - Resource errored.
         */
        /**
         * Fired when BaseTexture is updated.
         *
         * @protected
         * @event PIXI.BaseTexture#update
         * @param {PIXI.BaseTexture} baseTexture - Instance of texture being updated.
         */
        /**
         * Fired when BaseTexture is destroyed.
         *
         * @protected
         * @event PIXI.BaseTexture#dispose
         * @param {PIXI.BaseTexture} baseTexture - Instance of texture being destroyed.
         */
        // Set the resource
        this.setResource(resource);
    }
    /**
     * Pixel width of the source of this texture
     *
     * @readonly
     * @member {number}
     */
    get realWidth() {
        return this.width * this.resolution;
    }
    ;
    /**
     * Pixel height of the source of this texture
     *
     * @readonly
     * @member {number}
     */
    get realHeight() {
        return this.height * this.resolution;
    }
    ;
    /**
     * Changes style options of BaseTexture
     *
     * @param {PIXI.SCALE_MODES} [scaleMode] - Pixi scalemode
     * @param {PIXI.MIPMAP_MODES} [mipmap] - enable mipmaps
     * @returns {BaseTexture} this
     */
    BsetStyle(scaleMode, mipmap) {
        var dirty;
        if (scaleMode !== undefined && scaleMode !== this.scaleMode) {
            this.scaleMode = scaleMode;
            dirty = true;
        }
        if (mipmap !== undefined && mipmap !== this.mipmap) {
            this.mipmap = mipmap;
            dirty = true;
        }
        if (dirty) {
            this.dirtyStyleId++;
        }
        return this;
    }
    ;
    /**
     * Changes w/h/resolution. Texture becomes valid if width and height are greater than zero.
     *
     * @param {number} width Visual width
     * @param {number} height Visual height
     * @param {number} [resolution] Optionally set resolution
     * @returns {BaseTexture} this
     */
    setSize(width, height, resolution = null) {
        this.resolution = resolution || this.resolution;
        this.width = width;
        this.height = height;
        this._refreshPOT();
        this.update();
        return this;
    }
    ;
    /**
     * Sets real size of baseTexture, preserves current resolution.
     *
     * @param {number} realWidth Full rendered width
     * @param {number} realHeight Full rendered height
     * @param {number} [resolution] Optionally set resolution
     * @returns {BaseTexture} this
     */
    setRealSize(realWidth, realHeight, resolution = null) {
        this.resolution = resolution || this.resolution;
        this.width = realWidth / this.resolution;
        this.height = realHeight / this.resolution;
        this._refreshPOT();
        this.update();
        return this;
    }
    ;
    /**
     * Refresh check for isPowerOfTwo texture based on size
     *
     * @private
     */
    _refreshPOT() {
        this.isPowerOfTwo = MathSettings_1.MathSettings.isPow2(this.realWidth) && MathSettings_1.MathSettings.isPow2(this.realHeight);
    }
    ;
    /**
     * Changes resolution
     *
     * @param {number} [resolution] res
     * @returns {BaseTexture} this
     */
    setResolution(resolution) {
        var oldResolution = this.resolution;
        if (oldResolution === resolution) {
            return this;
        }
        this.resolution = resolution;
        if (this.valid) {
            this.width = this.width * oldResolution / resolution;
            this.height = this.height * oldResolution / resolution;
            this.dispatchEvent(Event_1.Event.getEvent("update"));
            // this.emit('update');
        }
        this._refreshPOT();
        return this;
    }
    ;
    /**
     * Sets the resource if it wasn't set. Throws error if resource already present
     *
     * @param {PIXI.resources.Resource} resource - that is managing this BaseTexture
     * @returns {BaseTexture} this
     */
    setResource(resource) {
        if (this.resource === resource) {
            return this;
        }
        if (this.resource) {
            throw new Error('Resource can be set only once');
        }
        this.resource = resource;
        if (resource instanceof ImageBitmap) {
            this.setRealSize(this.resource.width, this.resource.height);
            this.handleUpdate(null);
        }
        else {
            resource.addEventListener("update", this.handleUpdate);
            resource.addEventListener("setRealSize", this.handleResize);
            this.setRealSize(this.resource.width, this.resource.height);
        }
        // resource.bind(this);
        return this;
    }
    ;
    /**
     * Invalidates the object. Texture becomes valid if width and height are greater than zero.
     */
    update() {
        if (!this.valid) {
            if (this.width > 0 && this.height > 0) {
                this.valid = true;
                this.dispatchEvent(Event_1.Event.getEvent("loaded"));
                this.dispatchEvent(Event_1.Event.getEvent("update"));
                // this.emit('loaded', this);
                // this.emit('update', this);
            }
        }
        else {
            this.dirtyId++;
            this.dirtyStyleId++;
            this.dispatchEvent(Event_1.Event.getEvent("update"));
            // this.emit('update', this);
        }
    }
    ;
    /**
     * Destroys this base texture.
     * The method stops if resource doesn't want this texture to be destroyed.
     * Removes texture from all caches.
     */
    destroy() {
        // remove and destroy the resource
        if (this.resource) {
            this.resource.unbind(this);
            // only destroy resourced created internally
            if (this.resource.internal) {
                this.resource.destroy();
            }
            this.resource = null;
        }
        if (this.cacheId) {
            delete CacheSettings_1.CacheSettings.BaseTextureCache[this.cacheId];
            delete CacheSettings_1.CacheSettings.TextureCache[this.cacheId];
            this.cacheId = null;
        }
        // finally let the WebGL renderer know..
        this.dispose();
        BaseTexture.removeFromCache(this);
        this.textureCacheIds = null;
        this.destroyed = true;
    }
    ;
    /**
     * Frees the texture from WebGL memory without destroying this texture object.
     * This means you can still use the texture later which will upload it to GPU
     * memory again.
     *
     * @fires PIXI.BaseTexture#dispose
     */
    dispose() {
        this.dispatchEvent(Event_1.Event.getEvent("dispose"));
        // this.emit('dispose', this);
    }
    ;
    /**
     * Helper function that creates a base texture based on the source you provide.
     * The source can be - image url, image element, canvas element. If the
     * source is an image url or an image element and not in the base texture
     * cache, it will be created and loaded.
     *
     * @static
     * @param {string|HTMLImageElement|HTMLCanvasElement|SVGElement|HTMLVideoElement} source - The
     *        source to create base texture from.
     * @param {object} [options] See {@link PIXI.BaseTexture}'s constructor for options.
     * @returns {PIXI.BaseTexture} The new base texture.
     */
    static from(source, options) {
        var cacheId = null;
        if (typeof source === 'string') {
            cacheId = source;
        }
        else {
            if (!source._pixiId) {
                source._pixiId = "pixiid_" + (MathSettings_1.MathSettings.uid());
            }
            cacheId = source._pixiId;
        }
        var baseTexture = CacheSettings_1.CacheSettings.BaseTextureCache[cacheId];
        if (!baseTexture) {
            baseTexture = new BaseTexture(source, options);
            baseTexture.cacheId = cacheId;
            BaseTexture.addToCache(baseTexture, cacheId);
        }
        return baseTexture;
    }
    ;
    /**
     * Create a new BaseTexture with a BufferResource from a Float32Array.
     * RGBA values are floats from 0 to 1.
     * @static
     * @param {Float32Array|Uint8Array} buffer The optional array to use, if no data
     *        is provided, a new Float32Array is created.
     * @param {number} width - Width of the resource
     * @param {number} height - Height of the resource
     * @param {object} [options] See {@link PIXI.BaseTexture}'s constructor for options.
     * @return {PIXI.BaseTexture} The resulting new BaseTexture
     */
    static fromBuffer(buffer, width, height, options) {
        buffer = buffer || new Float32Array(width * height * 4);
        var resource = new BufferResource_1.BufferResource(buffer, { width: width, height: height });
        var type = buffer instanceof Float32Array ? WebGLSettings_1.WebGLSettings.TYPES.FLOAT : WebGLSettings_1.WebGLSettings.TYPES.UNSIGNED_BYTE;
        return new BaseTexture(resource, Object.assign(WebGLSettings_1.WebGLSettings.defaultBufferOptions, options || { width: width, height: height, type: type }));
    }
    ;
    /**
     * Adds a BaseTexture to the global BaseTextureCache. This cache is shared across the whole PIXI object.
     *
     * @static
     * @param {PIXI.BaseTexture} baseTexture - The BaseTexture to add to the cache.
     * @param {string} id - The id that the BaseTexture will be stored against.
     */
    static addToCache(baseTexture, id) {
        if (id) {
            if (baseTexture.textureCacheIds.indexOf(id) === -1) {
                baseTexture.textureCacheIds.push(id);
            }
            if (CacheSettings_1.CacheSettings.BaseTextureCache[id]) {
                // eslint-disable-next-line no-console
                console.warn(("BaseTexture added to the cache with an id [" + id + "] that already had an entry"));
            }
            CacheSettings_1.CacheSettings.BaseTextureCache[id] = baseTexture;
        }
    }
    ;
    /**
     * Remove a BaseTexture from the global BaseTextureCache.
     *
     * @static
     * @param {string|PIXI.BaseTexture} baseTexture - id of a BaseTexture to be removed, or a BaseTexture instance itself.
     * @return {PIXI.BaseTexture|null} The BaseTexture that was removed.
     */
    static removeFromCache(baseTexture) {
        if (typeof baseTexture === 'string') {
            var baseTextureFromCache = CacheSettings_1.CacheSettings.BaseTextureCache[baseTexture];
            if (baseTextureFromCache) {
                var index = baseTextureFromCache.textureCacheIds.indexOf(baseTexture);
                if (index > -1) {
                    baseTextureFromCache.textureCacheIds.splice(index, 1);
                }
                delete CacheSettings_1.CacheSettings.BaseTextureCache[baseTexture];
                return baseTextureFromCache;
            }
        }
        else if (baseTexture && baseTexture.textureCacheIds) {
            for (var i = 0; i < baseTexture.textureCacheIds.length; ++i) {
                delete CacheSettings_1.CacheSettings.BaseTextureCache[baseTexture.textureCacheIds[i]];
            }
            baseTexture.textureCacheIds.length = 0;
            return baseTexture;
        }
        return null;
    }
    ;
}
/**
 * Global number of the texture batch, used by multi-texture renderers
 *
 * @static
 * @member {number} new texture batch number
 */
BaseTexture._globalBatch = 0;
exports.BaseTexture = BaseTexture;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/BatchBuffer.js":
/*!***********************************************!*\
  !*** ./js-compile/raw-pixi-ts/BatchBuffer.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class BatchBuffer {
    constructor(size) {
        this.vertices = new ArrayBuffer(size);
        /**
         * View on the vertices as a Float32Array for positions
         *
         * @member {Float32Array}
         */
        this.float32View = new Float32Array(this.vertices);
        /**
         * View on the vertices as a Uint32Array for uvs
         *
         * @member {Float32Array}
         */
        this.uint32View = new Uint32Array(this.vertices);
    }
    destroy() {
        this.vertices = null;
        this.float32View = null;
        this.uint32View = null;
    }
    ;
}
exports.BatchBuffer = BatchBuffer;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/BatchDrawCall.js":
/*!*************************************************!*\
  !*** ./js-compile/raw-pixi-ts/BatchDrawCall.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class BatchDrawCall {
    constructor() {
        this.textures = [];
        this.ids = [];
        this.blend = 0;
        this.textureCount = 0;
        this.start = 0;
        this.size = 0;
        this.type = 4;
    }
    ;
}
exports.BatchDrawCall = BatchDrawCall;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/BatchGeometry.js":
/*!*************************************************!*\
  !*** ./js-compile/raw-pixi-ts/BatchGeometry.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Geometry_1 = __webpack_require__(/*! ./Geometry */ "./js-compile/raw-pixi-ts/Geometry.js");
const Buffer_1 = __webpack_require__(/*! ./Buffer */ "./js-compile/raw-pixi-ts/Buffer.js");
const WebGLSettings_1 = __webpack_require__(/*! ./WebGLSettings */ "./js-compile/raw-pixi-ts/WebGLSettings.js");
class BatchGeometry extends Geometry_1.Geometry {
    constructor(_static = false) {
        super();
        /**
         * Buffer used for position, color, texture IDs
         *
         * @member {PIXI.Buffer}
         * @protected
         */
        this._buffer = new Buffer_1.Buffer(null, _static, false);
        /**
         * Index buffer data
         *
         * @member {PIXI.Buffer}
         * @protected
         */
        this._indexBuffer = new Buffer_1.Buffer(null, _static, true);
        this.addAttribute('aVertexPosition', this._buffer, 2, false, WebGLSettings_1.WebGLSettings.TYPES.FLOAT)
            .addAttribute('aTextureCoord', this._buffer, 2, false, WebGLSettings_1.WebGLSettings.TYPES.FLOAT)
            .addAttribute('aColor', this._buffer, 4, true, WebGLSettings_1.WebGLSettings.TYPES.UNSIGNED_BYTE)
            .addAttribute('aTextureId', this._buffer, 1, true, WebGLSettings_1.WebGLSettings.TYPES.FLOAT)
            .addIndex(this._indexBuffer);
    }
}
exports.BatchGeometry = BatchGeometry;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/BatchRenderer.js":
/*!*************************************************!*\
  !*** ./js-compile/raw-pixi-ts/BatchRenderer.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const ObjectRenderer_1 = __webpack_require__(/*! ./ObjectRenderer */ "./js-compile/raw-pixi-ts/ObjectRenderer.js");
const BatchGeometry_1 = __webpack_require__(/*! ./BatchGeometry */ "./js-compile/raw-pixi-ts/BatchGeometry.js");
const BaseTexture_1 = __webpack_require__(/*! ./BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const BatchDrawCall_1 = __webpack_require__(/*! ./BatchDrawCall */ "./js-compile/raw-pixi-ts/BatchDrawCall.js");
const State_1 = __webpack_require__(/*! ./State */ "./js-compile/raw-pixi-ts/State.js");
const BatchBuffer_1 = __webpack_require__(/*! ./BatchBuffer */ "./js-compile/raw-pixi-ts/BatchBuffer.js");
const ColorSettings_1 = __webpack_require__(/*! ./ColorSettings */ "./js-compile/raw-pixi-ts/ColorSettings.js");
const WebGLSettings_1 = __webpack_require__(/*! ./WebGLSettings */ "./js-compile/raw-pixi-ts/WebGLSettings.js");
const BlendModesSettings_1 = __webpack_require__(/*! ./BlendModesSettings */ "./js-compile/raw-pixi-ts/BlendModesSettings.js");
const MathSettings_1 = __webpack_require__(/*! ./MathSettings */ "./js-compile/raw-pixi-ts/MathSettings.js");
const DisplaySettings_1 = __webpack_require__(/*! ./DisplaySettings */ "./js-compile/raw-pixi-ts/DisplaySettings.js");
class BatchRenderer extends ObjectRenderer_1.ObjectRenderer {
    constructor(renderer) {
        super(renderer);
        /**
         * Called before the renderer starts rendering.
         *
         */
        this.onPrerender = (event) => {
            this.vertexCount = 0;
        };
        /**
         * Number of values sent in the vertex buffer.
         * aVertexPosition(2), aTextureCoord(1), aColor(1), aTextureId(1) = 5
         *
         * @member {number}
         */
        this.vertSize = 6;
        /**
         * The size of the vertex information in bytes.
         *
         * @member {number}
         */
        this.vertByteSize = this.vertSize * 4;
        /**
         * The number of images in the SpriteRenderer before it flushes.
         *
         * @member {number}
         */
        this.size = 2000 * 4; // settings.SPRITE_BATCH_SIZE; // 2000 is a nice balance between mobile / desktop
        this.currentSize = 0;
        this.currentIndexSize = 0;
        // the total number of bytes in our batch
        // let numVerts = this.size * 4 * this.vertByteSize;
        this.attributeBuffers = {};
        this.aBuffers = {};
        this.iBuffers = {};
        //     this.defualtSpriteIndexBuffer = new Buffer(createIndicesForQuads(this.size), true, true);
        /**
         * Holds the defualt indices of the geometry (quads) to draw
         *
         * @member {Uint16Array}
         */
        // const indicies = createIndicesForQuads(this.size);
        //  this.defaultQuadIndexBuffer = new Buffer(indicies, true, true);
        this.onlySprites = false;
        /**
         * The default shaders that is used if a sprite doesn't have a more specific one.
         * there is a shader for each number of textures that can be rendered.
         * These shaders will also be generated on the fly as required.
         * @member {PIXI.Shader[]}
         */
        this.shader = null;
        this.currentIndex = 0;
        this.groups = [];
        for (var k = 0; k < this.size / 4; k++) {
            this.groups[k] = new BatchDrawCall_1.BatchDrawCall();
        }
        this.elements = [];
        this.vaos = [];
        this.vaoMax = 2;
        this.vertexCount = 0;
        this.renderer.addEventListener("prerender", this.onPrerender);
        // this.renderer.on('prerender', this.onPrerender, this);
        this.state = State_1.State.for2d();
    }
    /**
     * Sets up the renderer context and necessary buffers.
     */
    contextChange() {
        var gl = this.renderer.gl;
        if (DisplaySettings_1.DisplaySettings.PREFER_ENV === DisplaySettings_1.DisplaySettings.ENV.WEBGL_LEGACY) {
            this.MAX_TEXTURES = 1;
        }
        else {
            // step 1: first check max textures the GPU can handle.
            this.MAX_TEXTURES = Math.min(gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS), WebGLSettings_1.WebGLSettings.SPRITE_MAX_TEXTURES);
            // step 2: check the maximum number of if statements the shader can have too..
            this.MAX_TEXTURES = WebGLSettings_1.WebGLSettings.checkMaxIfStatementsInShader(this.MAX_TEXTURES, gl);
        }
        // generate generateMultiTextureProgram, may be a better move?
        this.shader = WebGLSettings_1.WebGLSettings.generateMultiTextureShader(gl, this.MAX_TEXTURES);
        // we use the second shader as the first one depending on your browser may omit aTextureId
        // as it is not used by the shader so is optimized out.
        for (var i = 0; i < this.vaoMax; i++) {
            /* eslint-disable max-len */
            this.vaos[i] = new BatchGeometry_1.BatchGeometry();
        }
    }
    ;
    /**
     * Renders the sprite object.
     *
     * @param {PIXI.Sprite} sprite - the sprite to render when using this spritebatch
     */
    render(element) {
        // trace("rendering element: " + element._texture.valid)
        if (!element._texture.valid) {
            return;
        }
        if (this.currentSize + (element.vertexData.length / 2) > this.size) {
            this.flush();
        }
        this.elements[this.currentIndex++] = element;
        this.currentSize += element.vertexData.length / 2;
        // trace("currentSize: " + this.currentSize)
        this.currentIndexSize += element.indices.length;
    }
    ;
    getIndexBuffer(size) {
        // 12 indices is enough for 2 quads
        var roundedP2 = MathSettings_1.MathSettings.nextPow2(Math.ceil(size / 12));
        var roundedSizeIndex = MathSettings_1.MathSettings.log2(roundedP2);
        var roundedSize = roundedP2 * 12;
        if (this.iBuffers.length <= roundedSizeIndex) {
            this.iBuffers.length = roundedSizeIndex + 1;
        }
        var buffer = this.iBuffers[roundedSizeIndex];
        if (!buffer) {
            this.iBuffers[roundedSizeIndex] = buffer = new Uint16Array(roundedSize);
        }
        return buffer;
    }
    ;
    getAttributeBuffer(size) {
        // 8 vertices is enough for 2 quads
        var roundedP2 = MathSettings_1.MathSettings.nextPow2(Math.ceil(size / 8));
        var roundedSizeIndex = MathSettings_1.MathSettings.log2(roundedP2);
        var roundedSize = roundedP2 * 8;
        if (this.aBuffers.length <= roundedSizeIndex) {
            this.iBuffers.length = roundedSizeIndex + 1;
        }
        var buffer = this.aBuffers[roundedSize];
        if (!buffer) {
            this.aBuffers[roundedSize] = buffer = new BatchBuffer_1.BatchBuffer(roundedSize * this.vertByteSize);
        }
        return buffer;
    }
    ;
    /**
     * Renders the content and empties the current batch.
     *
     */
    flush() {
        // trace("BatchRender flush " + this.currentSize)
        if (this.currentSize === 0) {
            return;
        }
        var gl = this.renderer.gl;
        var MAX_TEXTURES = this.MAX_TEXTURES;
        var buffer = this.getAttributeBuffer(this.currentSize);
        // reveal(buffer);
        var indexBuffer = this.getIndexBuffer(this.currentIndexSize);
        // reveal(indexBuffer);
        var elements = this.elements;
        var groups = this.groups;
        var float32View = buffer.float32View;
        // reveal(float32View);
        var uint32View = buffer.uint32View;
        // reveal(uint32View);
        var touch = this.renderer.textureGC.count;
        var index = 0;
        var indexCount = 0;
        var nextTexture;
        var currentTexture;
        var groupCount = 0;
        var textureCount = 0;
        var currentGroup = groups[0];
        // reveal(currentGroup);
        var blendMode = -1; // premultiplyBlendMode[elements[0]._texture.baseTexture.premultiplyAlpha ? 0 : ][elements[0].blendMode];
        currentGroup.textureCount = 0;
        currentGroup.start = 0;
        currentGroup.blend = blendMode;
        var TICK = ++BaseTexture_1.BaseTexture._globalBatch;
        var i;
        for (i = 0; i < this.currentIndex; ++i) {
            // upload the sprite elements...
            // they have all ready been calculated so we just need to push them into the buffer.
            var sprite = elements[i];
            elements[i] = null;
            nextTexture = sprite._texture.baseTexture;
            // reveal(nextTexture);
            var spriteBlendMode = BlendModesSettings_1.BlendModesSettings.premultiplyBlendMode[nextTexture.premultiplyAlpha ? 1 : 0][sprite.blendMode];
            if (blendMode !== spriteBlendMode) {
                blendMode = spriteBlendMode;
                // force the batch to break!
                currentTexture = null;
                textureCount = MAX_TEXTURES;
                TICK++;
            }
            if (currentTexture !== nextTexture) {
                currentTexture = nextTexture;
                if (nextTexture._batchEnabled !== TICK) {
                    if (textureCount === MAX_TEXTURES) {
                        TICK++;
                        textureCount = 0;
                        currentGroup.size = indexCount - currentGroup.start;
                        currentGroup = groups[groupCount++];
                        currentGroup.textureCount = 0;
                        currentGroup.blend = blendMode;
                        currentGroup.start = indexCount;
                    }
                    nextTexture.touched = touch;
                    nextTexture._batchEnabled = TICK;
                    nextTexture._id = textureCount;
                    currentGroup.textures[currentGroup.textureCount++] = nextTexture;
                    // reveal(currentGroup);
                    // reveal(nextTexture);
                    textureCount++;
                }
            }
            this.packGeometry(sprite, float32View, uint32View, indexBuffer, index, indexCount); // argb, nextTexture._id, float32View, uint32View, indexBuffer, index, indexCount);
            // HERE 
            // push a graphics..
            index += (sprite.vertexData.length / 2) * this.vertSize;
            indexCount += sprite.indices.length;
        }
        BaseTexture_1.BaseTexture._globalBatch = TICK;
        currentGroup.size = indexCount - currentGroup.start;
        //        this.indexBuffer.update();
        if (!WebGLSettings_1.WebGLSettings.CAN_UPLOAD_SAME_BUFFER) {
            // this is still needed for IOS performance..
            // it really does not like uploading to the same buffer in a single frame!
            if (this.vaoMax <= this.vertexCount) {
                this.vaoMax++;
                /* eslint-disable max-len */
                this.vaos[this.vertexCount] = new BatchGeometry_1.BatchGeometry();
            }
            this.vaos[this.vertexCount]._buffer.update(buffer.vertices, 0);
            this.vaos[this.vertexCount]._indexBuffer.update(indexBuffer, 0);
            //   this.vertexBuffers[this.vertexCount].update(buffer.vertices, 0);
            this.renderer.geometry.bind(this.vaos[this.vertexCount]);
            this.renderer.geometry.updateBuffers();
            this.vertexCount++;
        }
        else {
            // lets use the faster option, always use buffer number 0
            this.vaos[this.vertexCount]._buffer.update(buffer.vertices, 0);
            this.vaos[this.vertexCount]._indexBuffer.update(indexBuffer, 0);
            //   if (true)// this.spriteOnly)
            // {
            // this.vaos[this.vertexCount].indexBuffer = this.defualtSpriteIndexBuffer;
            // this.vaos[this.vertexCount].buffers[1] = this.defualtSpriteIndexBuffer;
            // }
            // this.vaos[0].attributes.aColor.stride = 24
            // this.vaos[0].attributes.aColor.start = 16
            // NOT SET
            // this.vaos[0].attributes.aTextureCoord.stride = 24
            // this.vaos[0].attributes.aTextureCoord.start = 8
            // NOT SET
            // this.vaos[0].attributes.aVertexPosition.stride = 24
            // NOT SET
            this.renderer.geometry.updateBuffers();
            //    
        }
        //   this.renderer.state.set(this.state);
        var textureSystem = this.renderer.texture;
        var stateSystem = this.renderer.state;
        // e.log(groupCount);
        // / render the groups..
        //    trace("groupcount: " + groupCount)
        // trace("BatchRenderer count: " + groupCount)
        for (i = 0; i < groupCount; i++) {
            var group = groups[i];
            var groupTextureCount = group.textureCount;
            for (var j = 0; j < groupTextureCount; j++) {
                // trace("possible textureSystem bind call (BathRenderer)")
                // trace("binding: " + group.textures[j] + " to " + j)
                textureSystem.bind(group.textures[j], j);
                group.textures[j] = null;
            }
            // this.state.blendMode = group.blend;
            // this.state.blend = true;
            // this.renderer.state.setState(this.state);
            // set the blend mode..
            stateSystem.setBlendMode(group.blend);
            gl.drawElements(group.type, group.size, gl.UNSIGNED_SHORT, group.start * 2);
        }
        // reset elements for the next flush
        this.currentIndex = 0;
        this.currentSize = 0;
        this.currentIndexSize = 0;
    }
    ;
    packGeometry(element, float32View, uint32View, indexBuffer, index, indexCount) {
        var p = index / this.vertSize; // float32View.length / 6 / 2;
        var uvs = element.uvs;
        var indicies = element.indices; // geometry.getIndex().data;// indicies;
        var vertexData = element.vertexData;
        var textureId = element._texture.baseTexture._id;
        var alpha = Math.min(element.worldAlpha, 1.0);
        var argb = alpha < 1.0 && element._texture.baseTexture.premultiplyAlpha ? ColorSettings_1.ColorSettings.premultiplyTint(element._tintRGB, alpha)
            : element._tintRGB + (alpha * 255 << 24);
        // lets not worry about tint! for now..
        for (var i = 0; i < vertexData.length; i += 2) {
            float32View[index++] = vertexData[i];
            float32View[index++] = vertexData[i + 1];
            float32View[index++] = uvs[i];
            float32View[index++] = uvs[i + 1];
            uint32View[index++] = argb;
            float32View[index++] = textureId;
        }
        for (var i$1 = 0; i$1 < indicies.length; i$1++) {
            indexBuffer[indexCount++] = p + indicies[i$1];
        }
    }
    ;
    /**
     * Starts a new sprite batch.
     */
    start() {
        this.renderer.state.setState(this.state);
        this.renderer.shader.bind(this.shader);
        if (WebGLSettings_1.WebGLSettings.CAN_UPLOAD_SAME_BUFFER) {
            // bind buffer #0, we don't need others
            this.renderer.geometry.bind(this.vaos[this.vertexCount]);
        }
    }
    ;
    /**
     * Stops and flushes the current batch.
     *
     */
    stop() {
        this.flush();
    }
    ;
    /**
     * Destroys the SpriteRenderer.
     *
     */
    destroy() {
        for (var i = 0; i < this.vaoMax; i++) {
            // if (this.vertexBuffers[i])
            // {
            //     this.vertexBuffers[i].destroy();
            // }
            if (this.vaos[i]) {
                this.vaos[i].destroy(null);
            }
        }
        if (this.indexBuffer) {
            this.indexBuffer.destroy();
        }
        this.renderer.removeEventListener('prerender', this.onPrerender);
        if (this.shader) {
            this.shader.destroy();
            this.shader = null;
        }
        // this.vertexBuffers = null;
        this.vaos = null;
        this.indexBuffer = null;
        this.indices = null;
        this.sprites = null;
        // for (let i = 0; i < this.buffers.length; ++i)
        // {
        //     this.buffers[i].destroy();
        // }
        super.destroy();
    }
    ;
}
exports.BatchRenderer = BatchRenderer;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/BatchSystem.js":
/*!***********************************************!*\
  !*** ./js-compile/raw-pixi-ts/BatchSystem.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const System_1 = __webpack_require__(/*! ./System */ "./js-compile/raw-pixi-ts/System.js");
const ObjectRenderer_1 = __webpack_require__(/*! ./ObjectRenderer */ "./js-compile/raw-pixi-ts/ObjectRenderer.js");
class BatchSystem extends System_1.System {
    constructor(renderer) {
        super(renderer);
        /**
         * An empty renderer.
         *
         * @member {PIXI.ObjectRenderer}
         */
        this.emptyRenderer = new ObjectRenderer_1.ObjectRenderer(renderer);
        /**
         * The currently active ObjectRenderer.
         *
         * @member {PIXI.ObjectRenderer}
         */
        this.currentRenderer = this.emptyRenderer;
    }
    /**
     * Changes the current renderer to the one given in parameter
     *
     * @param {PIXI.ObjectRenderer} objectRenderer - The object renderer to use.
     */
    setObjectRenderer(objectRenderer) {
        if (this.currentRenderer === objectRenderer) {
            return;
        }
        this.currentRenderer.stop();
        this.currentRenderer = objectRenderer;
        this.currentRenderer.start();
    }
    ;
    /**
     * This should be called if you wish to do some custom rendering
     * It will basically render anything that may be batched up such as sprites
     */
    flush() {
        this.setObjectRenderer(this.emptyRenderer);
    }
    ;
    /**
     * Reset the system to an empty renderer
     */
    reset() {
        this.setObjectRenderer(this.emptyRenderer);
    }
    ;
}
exports.BatchSystem = BatchSystem;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/BezierUtils.js":
/*!***********************************************!*\
  !*** ./js-compile/raw-pixi-ts/BezierUtils.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const settings_1 = __webpack_require__(/*! ./settings */ "./js-compile/raw-pixi-ts/settings.js");
class BezierUtils {
    constructor() {
    }
    static curveLength(fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY) {
        var n = 10;
        var result = 0.0;
        var t = 0.0;
        var t2 = 0.0;
        var t3 = 0.0;
        var nt = 0.0;
        var nt2 = 0.0;
        var nt3 = 0.0;
        var x = 0.0;
        var y = 0.0;
        var dx = 0.0;
        var dy = 0.0;
        var prevX = fromX;
        var prevY = fromY;
        for (var i = 1; i <= n; ++i) {
            t = i / n;
            t2 = t * t;
            t3 = t2 * t;
            nt = (1.0 - t);
            nt2 = nt * nt;
            nt3 = nt2 * nt;
            x = (nt3 * fromX) + (3.0 * nt2 * t * cpX) + (3.0 * nt * t2 * cpX2) + (t3 * toX);
            y = (nt3 * fromY) + (3.0 * nt2 * t * cpY) + (3 * nt * t2 * cpY2) + (t3 * toY);
            dx = prevX - x;
            dy = prevY - y;
            prevX = x;
            prevY = y;
            result += Math.sqrt((dx * dx) + (dy * dy));
        }
        return result;
    }
    ;
    /**
     * Calculate the points for a bezier curve and then draws it.
     *
     * Ignored from docs since it is not directly exposed.
     *
     * @ignore
     * @param {number} cpX - Control point x
     * @param {number} cpY - Control point y
     * @param {number} cpX2 - Second Control point x
     * @param {number} cpY2 - Second Control point y
     * @param {number} toX - Destination point x
     * @param {number} toY - Destination point y
     * @param {number[]} points - Path array to push points into
     */
    static curveTo(cpX, cpY, cpX2, cpY2, toX, toY, points) {
        var fromX = points[points.length - 2];
        var fromY = points[points.length - 1];
        points.length -= 2;
        var n = settings_1.settings.GRAPHICS_CURVES._segmentsCount(BezierUtils.curveLength(fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY));
        var dt = 0;
        var dt2 = 0;
        var dt3 = 0;
        var t2 = 0;
        var t3 = 0;
        points.push(fromX, fromY);
        for (var i = 1, j = 0; i <= n; ++i) {
            j = i / n;
            dt = (1 - j);
            dt2 = dt * dt;
            dt3 = dt2 * dt;
            t2 = j * j;
            t3 = t2 * j;
            points.push((dt3 * fromX) + (3 * dt2 * j * cpX) + (3 * dt * t2 * cpX2) + (t3 * toX), (dt3 * fromY) + (3 * dt2 * j * cpY) + (3 * dt * t2 * cpY2) + (t3 * toY));
        }
    }
    ;
}
exports.BezierUtils = BezierUtils;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/BlendModesSettings.js":
/*!******************************************************!*\
  !*** ./js-compile/raw-pixi-ts/BlendModesSettings.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class BlendModesSettings {
    /**
* Corrects PixiJS blend, takes premultiplied alpha into account
*
* @memberof PIXI.utils
* @function mapPremultipliedBlendModes
* @private
* @param {Array<number[]>} [array] - The array to output into.
* @return {Array<number[]>} Mapped modes.
*/
    static mapPremultipliedBlendModes() {
        var pm = [];
        var npm = [];
        for (var i = 0; i < 32; i++) {
            pm[i] = i;
            npm[i] = i;
        }
        pm[BlendModesSettings.BLEND_MODES.NORMAL_NPM] = BlendModesSettings.BLEND_MODES.NORMAL;
        pm[BlendModesSettings.BLEND_MODES.ADD_NPM] = BlendModesSettings.BLEND_MODES.ADD;
        pm[BlendModesSettings.BLEND_MODES.SCREEN_NPM] = BlendModesSettings.BLEND_MODES.SCREEN;
        npm[BlendModesSettings.BLEND_MODES.NORMAL] = BlendModesSettings.BLEND_MODES.NORMAL_NPM;
        npm[BlendModesSettings.BLEND_MODES.ADD] = BlendModesSettings.BLEND_MODES.ADD_NPM;
        npm[BlendModesSettings.BLEND_MODES.SCREEN] = BlendModesSettings.BLEND_MODES.SCREEN_NPM;
        var array = [];
        array.push(npm);
        array.push(pm);
        return array;
    }
    /**
* changes blendMode according to texture format
*
* @memberof PIXI.utils
* @function correctBlendMode
* @param {number} blendMode supposed blend mode
* @param {boolean} premultiplied  whether source is premultiplied
* @returns {number} true blend mode for this texture
*/
    static correctBlendMode(blendMode, premultiplied) {
        return BlendModesSettings.premultiplyBlendMode[premultiplied ? 1 : 0][blendMode];
    }
    /**
* Maps gl blend combinations to WebGL.
*
* @memberof PIXI
* @function mapWebGLBlendModesToPixi
* @private
* @param {WebGLRenderingContext} gl - The rendering context.
* @param {number[][]} [array=[]] - The array to output into.
* @return {number[][]} Mapped modes.
*/
    static mapWebGLBlendModesToPixi(gl, array = []) {
        // TODO - premultiply alpha would be different.
        // add a boolean for that!
        array[BlendModesSettings.BLEND_MODES.NORMAL] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
        array[BlendModesSettings.BLEND_MODES.ADD] = [gl.ONE, gl.DST_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
        array[BlendModesSettings.BLEND_MODES.MULTIPLY] = [gl.DST_COLOR, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
        array[BlendModesSettings.BLEND_MODES.SCREEN] = [gl.ONE, gl.ONE_MINUS_SRC_COLOR, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
        array[BlendModesSettings.BLEND_MODES.OVERLAY] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
        array[BlendModesSettings.BLEND_MODES.DARKEN] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
        array[BlendModesSettings.BLEND_MODES.LIGHTEN] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
        array[BlendModesSettings.BLEND_MODES.COLOR_DODGE] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
        array[BlendModesSettings.BLEND_MODES.COLOR_BURN] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
        array[BlendModesSettings.BLEND_MODES.HARD_LIGHT] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
        array[BlendModesSettings.BLEND_MODES.SOFT_LIGHT] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
        array[BlendModesSettings.BLEND_MODES.DIFFERENCE] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
        array[BlendModesSettings.BLEND_MODES.EXCLUSION] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
        array[BlendModesSettings.BLEND_MODES.HUE] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
        array[BlendModesSettings.BLEND_MODES.SATURATION] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
        array[BlendModesSettings.BLEND_MODES.COLOR] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
        array[BlendModesSettings.BLEND_MODES.LUMINOSITY] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
        array[BlendModesSettings.BLEND_MODES.NONE] = [0, 0];
        // not-premultiplied blend modes
        array[BlendModesSettings.BLEND_MODES.NORMAL_NPM] = [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
        array[BlendModesSettings.BLEND_MODES.ADD_NPM] = [gl.SRC_ALPHA, gl.DST_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
        array[BlendModesSettings.BLEND_MODES.SCREEN_NPM] = [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_COLOR, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
        // composite operations
        array[BlendModesSettings.BLEND_MODES.SRC_IN] = [gl.DST_ALPHA, gl.ZERO];
        array[BlendModesSettings.BLEND_MODES.SRC_OUT] = [gl.ONE_MINUS_DST_ALPHA, gl.ZERO];
        array[BlendModesSettings.BLEND_MODES.SRC_ATOP] = [gl.DST_ALPHA, gl.ONE_MINUS_SRC_ALPHA];
        array[BlendModesSettings.BLEND_MODES.DST_OVER] = [gl.ONE_MINUS_DST_ALPHA, gl.ONE];
        array[BlendModesSettings.BLEND_MODES.DST_IN] = [gl.ZERO, gl.SRC_ALPHA];
        array[BlendModesSettings.BLEND_MODES.DST_OUT] = [gl.ZERO, gl.ONE_MINUS_SRC_ALPHA];
        array[BlendModesSettings.BLEND_MODES.DST_ATOP] = [gl.ONE_MINUS_DST_ALPHA, gl.SRC_ALPHA];
        // SUBTRACT from flash
        array[BlendModesSettings.BLEND_MODES.SUBTRACT] = [gl.ONE, gl.ONE, gl.ONE, gl.ONE, gl.FUNC_REVERSE_SUBTRACT, gl.FUNC_ADD];
        return array;
    }
}
/**
* Various blend modes supported by PIXI.
*
* IMPORTANT - The WebGL renderer only supports the NORMAL, ADD, MULTIPLY and SCREEN blend modes.
* Anything else will silently act like NORMAL.
*
* @memberof PIXI
* @name BLEND_MODES
* @enum {number}
* @property {number} NORMAL
* @property {number} ADD
* @property {number} MULTIPLY
* @property {number} SCREEN
* @property {number} OVERLAY
* @property {number} DARKEN
* @property {number} LIGHTEN
* @property {number} COLOR_DODGE
* @property {number} COLOR_BURN
* @property {number} HARD_LIGHT
* @property {number} SOFT_LIGHT
* @property {number} DIFFERENCE
* @property {number} EXCLUSION
* @property {number} HUE
* @property {number} SATURATION
* @property {number} COLOR
* @property {number} LUMINOSITY
* @property {number} NORMAL_NPM
* @property {number} ADD_NPM
* @property {number} SCREEN_NPM
* @property {number} NONE
* @property {number} SRC_IN
* @property {number} SRC_OUT
* @property {number} SRC_ATOP
* @property {number} DST_OVER
* @property {number} DST_IN
* @property {number} DST_OUT
* @property {number} DST_ATOP
* @property {number} SUBTRACT
* @property {number} SRC_OVER
* @property {number} ERASE
*/
BlendModesSettings.BLEND_MODES = {
    NORMAL: 0,
    ADD: 1,
    MULTIPLY: 2,
    SCREEN: 3,
    OVERLAY: 4,
    DARKEN: 5,
    LIGHTEN: 6,
    COLOR_DODGE: 7,
    COLOR_BURN: 8,
    HARD_LIGHT: 9,
    SOFT_LIGHT: 10,
    DIFFERENCE: 11,
    EXCLUSION: 12,
    HUE: 13,
    SATURATION: 14,
    COLOR: 15,
    LUMINOSITY: 16,
    NORMAL_NPM: 17,
    ADD_NPM: 18,
    SCREEN_NPM: 19,
    NONE: 20,
    SRC_OVER: 0,
    SRC_IN: 21,
    SRC_OUT: 22,
    SRC_ATOP: 23,
    DST_OVER: 24,
    DST_IN: 25,
    DST_OUT: 26,
    DST_ATOP: 27,
    ERASE: 26,
    SUBTRACT: 28,
};
/**
* maps premultiply flag and blendMode to adjusted blendMode
* @memberof PIXI.utils
* @const premultiplyBlendMode
* @type {Array<number[]>}
*/
BlendModesSettings.premultiplyBlendMode = BlendModesSettings.mapPremultipliedBlendModes();
exports.BlendModesSettings = BlendModesSettings;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/BlurFilter.js":
/*!**********************************************!*\
  !*** ./js-compile/raw-pixi-ts/BlurFilter.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Filter_1 = __webpack_require__(/*! ./Filter */ "./js-compile/raw-pixi-ts/Filter.js");
const BlurFilterPass_1 = __webpack_require__(/*! ./BlurFilterPass */ "./js-compile/raw-pixi-ts/BlurFilterPass.js");
const DisplaySettings_1 = __webpack_require__(/*! ./DisplaySettings */ "./js-compile/raw-pixi-ts/DisplaySettings.js");
class BlurFilter extends Filter_1.Filter {
    constructor(strength = 1, quality = 1, resolution = 1, kernelSize = 5) {
        super();
        this.blurXFilter = new BlurFilterPass_1.BlurFilterPass(true, strength, quality, resolution, kernelSize);
        this.blurYFilter = new BlurFilterPass_1.BlurFilterPass(false, strength, quality, resolution, kernelSize);
        this.resolution = resolution || DisplaySettings_1.DisplaySettings.RESOLUTION;
        this.quality = quality || 4;
        this.blur = strength || 8;
        this.repeatEdgePixels = false;
    }
    /**
     * Applies the filter.
     *
     * @param {PIXI.systems.FilterSystem} filterManager - The manager.
     * @param {PIXI.RenderTexture} input - The input target.
     * @param {PIXI.RenderTexture} output - The output target.
     */
    apply(filterManager, input, output, clear) {
        var xStrength = Math.abs(this.blurXFilter.strength);
        var yStrength = Math.abs(this.blurYFilter.strength);
        if (xStrength && yStrength) {
            var renderTarget = filterManager.getFilterTexture();
            this.blurXFilter.apply(filterManager, input, renderTarget, true);
            this.blurYFilter.apply(filterManager, renderTarget, output, clear);
            filterManager.returnFilterTexture(renderTarget);
        }
        else if (yStrength) {
            this.blurYFilter.apply(filterManager, input, output, clear);
        }
        else {
            this.blurXFilter.apply(filterManager, input, output, clear);
        }
    }
    ;
    updatePadding() {
        if (this._repeatEdgePixels) {
            this.padding = 0;
        }
        else {
            this.padding = Math.max(Math.abs(this.blurXFilter.strength), Math.abs(this.blurYFilter.strength)) * 2;
        }
    }
    ;
    /**
     * Sets the strength of both the blurX and blurY properties simultaneously
     *
     * @member {number}
     * @default 2
     */
    get blur() {
        return this.blurXFilter.blur;
    }
    ;
    set blur(value) {
        this.blurXFilter.blur = this.blurYFilter.blur = value;
        this.updatePadding();
    }
    ;
    /**
     * Sets the number of passes for blur. More passes means higher quaility bluring.
     *
     * @member {number}
     * @default 1
     */
    get quality() {
        return this.blurXFilter.quality;
    }
    ;
    set quality(value) {
        this.blurXFilter.quality = this.blurYFilter.quality = value;
    }
    ;
    /**
     * Sets the strength of the blurX property
     *
     * @member {number}
     * @default 2
     */
    get blurX() {
        return this.blurXFilter.blur;
    }
    ;
    set blurX(value) {
        this.blurXFilter.blur = value;
        this.updatePadding();
    }
    ;
    /**
     * Sets the strength of the blurY property
     *
     * @member {number}
     * @default 2
     */
    get blurY() {
        return this.blurYFilter.blur;
    }
    ;
    set blurY(value) {
        this.blurYFilter.blur = value;
        this.updatePadding();
    }
    ;
    /**
     * Sets the blendmode of the filter
     *
     * @member {number}
     * @default PIXI.BLEND_MODES.NORMAL
     */
    get blendMode() {
        return this.blurYFilter.blendMode;
    }
    ;
    set blendMode(value) {
        this.blurYFilter.blendMode = value;
    }
    ;
    /**
     * If set to true the edge of the target will be clamped
     *
     * @member {bool}
     * @default false
     */
    get repeatEdgePixels() {
        return this._repeatEdgePixels;
    }
    ;
    set repeatEdgePixels(value) {
        this._repeatEdgePixels = value;
        this.updatePadding();
    }
    ;
}
exports.BlurFilter = BlurFilter;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/BlurFilterPass.js":
/*!**************************************************!*\
  !*** ./js-compile/raw-pixi-ts/BlurFilterPass.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Filter_1 = __webpack_require__(/*! ./Filter */ "./js-compile/raw-pixi-ts/Filter.js");
const DisplaySettings_1 = __webpack_require__(/*! ./DisplaySettings */ "./js-compile/raw-pixi-ts/DisplaySettings.js");
class BlurFilterPass extends Filter_1.Filter {
    constructor(horizontal, strength, quality, resolution, kernelSize) {
        kernelSize = kernelSize || 5;
        var vertSrc = BlurFilterPass.generateBlurVertSource(kernelSize, horizontal);
        var fragSrc = BlurFilterPass.generateBlurFragSource(kernelSize);
        super(vertSrc, fragSrc);
        this.horizontal = horizontal;
        this.resolution = resolution || DisplaySettings_1.DisplaySettings.RESOLUTION;
        this._quality = 0;
        this.quality = quality || 4;
        this.blur = strength || 8;
    }
    static generateBlurFragSource(kernelSize) {
        var kernel = BlurFilterPass.GAUSSIAN_VALUES[kernelSize];
        var halfLength = kernel.length;
        var fragSource = BlurFilterPass.fragTemplate$2;
        var blurLoop = '';
        var template = 'gl_FragColor += texture2D(uSampler, vBlurTexCoords[%index%]) * %value%;';
        var value;
        for (var i = 0; i < kernelSize; i++) {
            var blur = template.replace('%index%', i.toString());
            value = i;
            if (i >= halfLength) {
                value = kernelSize - i - 1;
            }
            blur = blur.replace('%value%', kernel[value]);
            blurLoop += blur;
            blurLoop += '\n';
        }
        fragSource = fragSource.replace('%blur%', blurLoop);
        fragSource = fragSource.replace('%size%', kernelSize);
        return fragSource;
    }
    static generateBlurVertSource(kernelSize, x) {
        var halfLength = Math.ceil(kernelSize / 2);
        var vertSource = BlurFilterPass.vertTemplate;
        var blurLoop = '';
        var template;
        // let value;
        if (x) {
            template = 'vBlurTexCoords[%index%] =  textureCoord + vec2(%sampleIndex% * strength, 0.0);';
        }
        else {
            template = 'vBlurTexCoords[%index%] =  textureCoord + vec2(0.0, %sampleIndex% * strength);';
        }
        for (var i = 0; i < kernelSize; i++) {
            var blur = template.replace('%index%', i);
            // value = i;
            // if(i >= halfLength)
            // {
            //     value = kernelSize - i - 1;
            // }
            blur = blur.replace('%sampleIndex%', ((i - (halfLength - 1)) + ".0"));
            blurLoop += blur;
            blurLoop += '\n';
        }
        vertSource = vertSource.replace('%blur%', blurLoop);
        vertSource = vertSource.replace('%size%', kernelSize);
        return vertSource;
    }
    apply(filterManager, input, output, clear) {
        if (output) {
            if (this.horizontal) {
                this.uniforms.strength = (1 / output.width) * (output.width / input.width);
            }
            else {
                this.uniforms.strength = (1 / output.height) * (output.height / input.height);
            }
        }
        else {
            if (this.horizontal) // eslint-disable-line
             {
                this.uniforms.strength = (1 / filterManager.renderer.width) * (filterManager.renderer.width / input.width);
            }
            else {
                this.uniforms.strength = (1 / filterManager.renderer.height) * (filterManager.renderer.height / input.height); // eslint-disable-line
            }
        }
        // screen space!
        this.uniforms.strength *= this.strength;
        this.uniforms.strength /= this.passes;
        if (this.passes === 1) {
            filterManager.applyFilter(this, input, output, clear);
        }
        else {
            var renderTarget = filterManager.getFilterTexture();
            var renderer = filterManager.renderer;
            var flip = input;
            var flop = renderTarget;
            this.state.blend = false;
            filterManager.applyFilter(this, flip, flop, false);
            for (var i = 1; i < this.passes - 1; i++) {
                renderer.renderTexture.bind(flip, flip.filterFrame);
                this.uniforms.uSampler = flop;
                var temp = flop;
                flop = flip;
                flip = temp;
                renderer.shader.bind(this);
                renderer.geometry.draw(5);
            }
            this.state.blend = true;
            filterManager.applyFilter(this, flop, output, clear);
            filterManager.returnFilterTexture(renderTarget);
        }
    }
    ;
    /**
     * Sets the strength of both the blur.
     *
     * @member {number}
     * @default 16
     */
    get blur() {
        return this.strength;
    }
    ;
    set blur(value) {
        this.padding = 1 + (Math.abs(value) * 2);
        this.strength = value;
    }
    ;
    /**
     * Sets the quality of the blur by modifying the number of passes. More passes means higher
     * quaility bluring but the lower the performance.
     *
     * @member {number}
     * @default 4
     */
    get quality() {
        return this._quality;
    }
    ;
    set quality(value) {
        this._quality = value;
        this.passes = value;
    }
    ;
}
BlurFilterPass.GAUSSIAN_VALUES = {
    5: [0.153388, 0.221461, 0.250301],
    7: [0.071303, 0.131514, 0.189879, 0.214607],
    9: [0.028532, 0.067234, 0.124009, 0.179044, 0.20236],
    11: [0.0093, 0.028002, 0.065984, 0.121703, 0.175713, 0.198596],
    13: [0.002406, 0.009255, 0.027867, 0.065666, 0.121117, 0.174868, 0.197641],
    15: [0.000489, 0.002403, 0.009246, 0.02784, 0.065602, 0.120999, 0.174697, 0.197448],
};
BlurFilterPass.vertTemplate = "\n    attribute vec2 aVertexPosition;\n\n    uniform mat3 projectionMatrix;\n\n    uniform float strength;\n\n    varying vec2 vBlurTexCoords[%size%];\n\n    uniform vec4 inputSize;\n    uniform vec4 outputFrame;\n    \n    vec4 filterVertexPosition( void )\n    {\n        vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n    \n        return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n    }\n    \n    vec2 filterTextureCoord( void )\n    {\n        return aVertexPosition * (outputFrame.zw * inputSize.zw);\n    }\n\n    void main(void)\n    {\n        gl_Position = filterVertexPosition();\n\n        vec2 textureCoord = filterTextureCoord();\n        %blur%\n    }";
BlurFilterPass.fragTemplate$2 = [
    'varying vec2 vBlurTexCoords[%size%];',
    'uniform sampler2D uSampler;',
    'void main(void)',
    '{',
    '    gl_FragColor = vec4(0.0);',
    '    %blur%',
    '}'
].join('\n');
exports.BlurFilterPass = BlurFilterPass;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/Bounds.js":
/*!******************************************!*\
  !*** ./js-compile/raw-pixi-ts/Bounds.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Rectangle_1 = __webpack_require__(/*! ./Rectangle */ "./js-compile/raw-pixi-ts/Rectangle.js");
class Bounds {
    constructor() {
        /**
         * @member {number}
         * @default 0
         */
        this.minX = Infinity;
        /**
         * @member {number}
         * @default 0
         */
        this.minY = Infinity;
        /**
         * @member {number}
         * @default 0
         */
        this.maxX = -Infinity;
        /**
         * @member {number}
         * @default 0
         */
        this.maxY = -Infinity;
        this.rect = null;
    }
    /**
 * Checks if bounds are empty.
 *
 * @return {boolean} True if empty.
 */
    isEmpty() {
        return this.minX > this.maxX || this.minY > this.maxY;
    }
    ;
    /**
     * Clears the bounds and resets.
     *
     */
    clear() {
        this.updateID++;
        this.minX = Infinity;
        this.minY = Infinity;
        this.maxX = -Infinity;
        this.maxY = -Infinity;
    }
    ;
    /**
 * Can return Rectangle.EMPTY constant, either construct new rectangle, either use your rectangle
 * It is not guaranteed that it will return tempRect
 *
 * @param {PIXI.Rectangle} rect - temporary object will be used if AABB is not empty
 * @returns {PIXI.Rectangle} A rectangle of the bounds
 */
    getRectangle(rect) {
        if (this.minX > this.maxX || this.minY > this.maxY) {
            return Rectangle_1.Rectangle.EMPTY;
        }
        rect = rect || new Rectangle_1.Rectangle(0, 0, 1, 1);
        rect.x = this.minX;
        rect.y = this.minY;
        rect.width = this.maxX - this.minX;
        rect.height = this.maxY - this.minY;
        return rect;
    }
    ;
    /**
     * This function should be inlined when its possible.
     *
     * @param {PIXI.Point} point - The point to add.
     */
    addPoint(point) {
        this.minX = Math.min(this.minX, point.x);
        this.maxX = Math.max(this.maxX, point.x);
        this.minY = Math.min(this.minY, point.y);
        this.maxY = Math.max(this.maxY, point.y);
    }
    ;
    /**
     * Adds a quad, not transformed
     *
     * @param {Float32Array} vertices - The verts to add.
     */
    addQuad(vertices) {
        var minX = this.minX;
        var minY = this.minY;
        var maxX = this.maxX;
        var maxY = this.maxY;
        var x = vertices[0];
        var y = vertices[1];
        minX = x < minX ? x : minX;
        minY = y < minY ? y : minY;
        maxX = x > maxX ? x : maxX;
        maxY = y > maxY ? y : maxY;
        x = vertices[2];
        y = vertices[3];
        minX = x < minX ? x : minX;
        minY = y < minY ? y : minY;
        maxX = x > maxX ? x : maxX;
        maxY = y > maxY ? y : maxY;
        x = vertices[4];
        y = vertices[5];
        minX = x < minX ? x : minX;
        minY = y < minY ? y : minY;
        maxX = x > maxX ? x : maxX;
        maxY = y > maxY ? y : maxY;
        x = vertices[6];
        y = vertices[7];
        minX = x < minX ? x : minX;
        minY = y < minY ? y : minY;
        maxX = x > maxX ? x : maxX;
        maxY = y > maxY ? y : maxY;
        this.minX = minX;
        this.minY = minY;
        this.maxX = maxX;
        this.maxY = maxY;
    }
    ;
    /**
     * Adds sprite frame, transformed.
     *
     * @param {PIXI.Transform} transform - TODO
     * @param {number} x0 - TODO
     * @param {number} y0 - TODO
     * @param {number} x1 - TODO
     * @param {number} y1 - TODO
     */
    addFrame(transform, x0, y0, x1, y1) {
        var matrix = transform.worldTransform;
        var a = matrix.a;
        var b = matrix.b;
        var c = matrix.c;
        var d = matrix.d;
        var tx = matrix.tx;
        var ty = matrix.ty;
        var minX = this.minX;
        var minY = this.minY;
        var maxX = this.maxX;
        var maxY = this.maxY;
        var x = (a * x0) + (c * y0) + tx;
        var y = (b * x0) + (d * y0) + ty;
        minX = x < minX ? x : minX;
        minY = y < minY ? y : minY;
        maxX = x > maxX ? x : maxX;
        maxY = y > maxY ? y : maxY;
        x = (a * x1) + (c * y0) + tx;
        y = (b * x1) + (d * y0) + ty;
        minX = x < minX ? x : minX;
        minY = y < minY ? y : minY;
        maxX = x > maxX ? x : maxX;
        maxY = y > maxY ? y : maxY;
        x = (a * x0) + (c * y1) + tx;
        y = (b * x0) + (d * y1) + ty;
        minX = x < minX ? x : minX;
        minY = y < minY ? y : minY;
        maxX = x > maxX ? x : maxX;
        maxY = y > maxY ? y : maxY;
        x = (a * x1) + (c * y1) + tx;
        y = (b * x1) + (d * y1) + ty;
        minX = x < minX ? x : minX;
        minY = y < minY ? y : minY;
        maxX = x > maxX ? x : maxX;
        maxY = y > maxY ? y : maxY;
        this.minX = minX;
        this.minY = minY;
        this.maxX = maxX;
        this.maxY = maxY;
    }
    ;
    /**
     * Adds screen vertices from array
     *
     * @param {Float32Array} vertexData - calculated vertices
     * @param {number} beginOffset - begin offset
     * @param {number} endOffset - end offset, excluded
     */
    addVertexData(vertexData, beginOffset, endOffset) {
        var minX = this.minX;
        var minY = this.minY;
        var maxX = this.maxX;
        var maxY = this.maxY;
        for (var i = beginOffset; i < endOffset; i += 2) {
            var x = vertexData[i];
            var y = vertexData[i + 1];
            minX = x < minX ? x : minX;
            minY = y < minY ? y : minY;
            maxX = x > maxX ? x : maxX;
            maxY = y > maxY ? y : maxY;
        }
        this.minX = minX;
        this.minY = minY;
        this.maxX = maxX;
        this.maxY = maxY;
    }
    ;
    /**
     * Add an array of mesh vertices
     *
     * @param {PIXI.Transform} transform - mesh transform
     * @param {Float32Array} vertices - mesh coordinates in array
     * @param {number} beginOffset - begin offset
     * @param {number} endOffset - end offset, excluded
     */
    addVertices(transform, vertices, beginOffset, endOffset) {
        var matrix = transform.worldTransform;
        var a = matrix.a;
        var b = matrix.b;
        var c = matrix.c;
        var d = matrix.d;
        var tx = matrix.tx;
        var ty = matrix.ty;
        var minX = this.minX;
        var minY = this.minY;
        var maxX = this.maxX;
        var maxY = this.maxY;
        for (var i = beginOffset; i < endOffset; i += 2) {
            var rawX = vertices[i];
            var rawY = vertices[i + 1];
            var x = (a * rawX) + (c * rawY) + tx;
            var y = (d * rawY) + (b * rawX) + ty;
            minX = x < minX ? x : minX;
            minY = y < minY ? y : minY;
            maxX = x > maxX ? x : maxX;
            maxY = y > maxY ? y : maxY;
        }
        this.minX = minX;
        this.minY = minY;
        this.maxX = maxX;
        this.maxY = maxY;
    }
    ;
    /**
     * Adds other Bounds
     *
     * @param {PIXI.Bounds} bounds - TODO
     */
    addBounds(bounds) {
        var minX = this.minX;
        var minY = this.minY;
        var maxX = this.maxX;
        var maxY = this.maxY;
        this.minX = bounds.minX < minX ? bounds.minX : minX;
        this.minY = bounds.minY < minY ? bounds.minY : minY;
        this.maxX = bounds.maxX > maxX ? bounds.maxX : maxX;
        this.maxY = bounds.maxY > maxY ? bounds.maxY : maxY;
    }
    ;
    /**
     * Adds other Bounds, masked with Bounds
     *
     * @param {PIXI.Bounds} bounds - TODO
     * @param {PIXI.Bounds} mask - TODO
     */
    addBoundsMask(bounds, mask) {
        var _minX = bounds.minX > mask.minX ? bounds.minX : mask.minX;
        var _minY = bounds.minY > mask.minY ? bounds.minY : mask.minY;
        var _maxX = bounds.maxX < mask.maxX ? bounds.maxX : mask.maxX;
        var _maxY = bounds.maxY < mask.maxY ? bounds.maxY : mask.maxY;
        if (_minX <= _maxX && _minY <= _maxY) {
            var minX = this.minX;
            var minY = this.minY;
            var maxX = this.maxX;
            var maxY = this.maxY;
            this.minX = _minX < minX ? _minX : minX;
            this.minY = _minY < minY ? _minY : minY;
            this.maxX = _maxX > maxX ? _maxX : maxX;
            this.maxY = _maxY > maxY ? _maxY : maxY;
        }
    }
    ;
    /**
     * Adds other Bounds, masked with Rectangle
     *
     * @param {PIXI.Bounds} bounds - TODO
     * @param {PIXI.Rectangle} area - TODO
     */
    addBoundsArea(bounds, area) {
        var _minX = bounds.minX > area.x ? bounds.minX : area.x;
        var _minY = bounds.minY > area.y ? bounds.minY : area.y;
        var _maxX = bounds.maxX < area.x + area.width ? bounds.maxX : (area.x + area.width);
        var _maxY = bounds.maxY < area.y + area.height ? bounds.maxY : (area.y + area.height);
        if (_minX <= _maxX && _minY <= _maxY) {
            var minX = this.minX;
            var minY = this.minY;
            var maxX = this.maxX;
            var maxY = this.maxY;
            this.minX = _minX < minX ? _minX : minX;
            this.minY = _minY < minY ? _minY : minY;
            this.maxX = _maxX > maxX ? _maxX : maxX;
            this.maxY = _maxY > maxY ? _maxY : maxY;
        }
    }
    ;
}
exports.Bounds = Bounds;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/Buffer.js":
/*!******************************************!*\
  !*** ./js-compile/raw-pixi-ts/Buffer.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Runner_1 = __webpack_require__(/*! ./Runner */ "./js-compile/raw-pixi-ts/Runner.js");
class Buffer {
    constructor(data = null, _static = false, index = null) {
        if (_static === void 0) {
            _static = true;
        }
        if (index === void 0) {
            index = false;
        }
        /**
         * The data in the buffer, as a typed array
         *
         * @member {ArrayBuffer| SharedArrayBuffer|ArrayBufferView}
         */
        this.data = data || new Float32Array(1);
        /**
         * A map of renderer IDs to webgl buffer
         *
         * @private
         * @member {object<number, GLBuffer>}
         */
        this._glBuffers = {};
        this._updateID = 0;
        this.index = index;
        this.static = _static;
        this.id = Buffer.UID++;
        this.disposeRunner = new Runner_1.Runner('disposeBuffer', 2);
        // this.disposeRunner = new Runner('disposeBuffer', 2);
    }
    // TODO could explore flagging only a partial upload?
    /**
     * flags this buffer as requiring an upload to the GPU
     */
    update(data) {
        this.data = data || this.data;
        this._updateID++;
    }
    ;
    /**
     * disposes WebGL resources that are connected to this geometry
     */
    dispose() {
        this.disposeRunner.run(this, false);
        // this.disposeRunner.run(this, false);
    }
    ;
    /**
     * Destroys the buffer
     */
    destroy() {
        this.dispose();
        this.data = null;
    }
    ;
    /**
     * Helper function that creates a buffer based on an array or TypedArray
     *
     * @static
     * @param {ArrayBufferView | number[]} data the TypedArray that the buffer will store. If this is a regular Array it will be converted to a Float32Array.
     * @return {PIXI.Buffer} A new Buffer based on the data provided.
     */
    static from(data) {
        if (data instanceof Array) {
            data = new Float32Array(data);
        }
        return new Buffer(data);
    }
    ;
}
Buffer.UID = 0;
exports.Buffer = Buffer;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/BufferResource.js":
/*!**************************************************!*\
  !*** ./js-compile/raw-pixi-ts/BufferResource.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Resource_1 = __webpack_require__(/*! ./Resource */ "./js-compile/raw-pixi-ts/Resource.js");
class BufferResource extends Resource_1.Resource {
    constructor(source, options) {
        var ref = options || {};
        var width = ref.width;
        var height = ref.height;
        if (!width || !height) {
            throw new Error('BufferResource width or height invalid');
        }
        super(width, height);
        /**
         * Source array
         * Cannot be ClampedUint8Array because it cant be uploaded to WebGL
         *
         * @member {Float32Array|Uint8Array|Uint32Array}
         */
        this.data = source;
    }
    /**
     * Upload the texture to the GPU.
     * @param {PIXI.Renderer} renderer Upload to the renderer
     * @param {PIXI.BaseTexture} baseTexture Reference to parent texture
     * @param {PIXI.GLTexture} glTexture glTexture
     * @returns {boolean} true is success
     */
    upload(renderer, baseTexture, glTexture) {
        var gl = renderer.gl;
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, baseTexture.premultiplyAlpha);
        if (glTexture.width === baseTexture.width && glTexture.height === baseTexture.height) {
            gl.texSubImage2D(baseTexture.target, 0, 0, 0, baseTexture.width, baseTexture.height, baseTexture.format, baseTexture.type, this.data);
        }
        else {
            glTexture.width = baseTexture.width;
            glTexture.height = baseTexture.height;
            var internalFormat = baseTexture.format;
            // guess sized format by type and format
            // https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/texImage2D
            if (renderer.context.webGLVersion === 2
                && baseTexture.type === renderer.gl.FLOAT
                && baseTexture.format === renderer.gl.RGBA) {
                internalFormat = renderer.gl.RGBA32F;
            }
            gl.texImage2D(baseTexture.target, 0, internalFormat, baseTexture.width, baseTexture.height, 0, baseTexture.format, baseTexture.type, this.data);
        }
        return true;
    }
    ;
    /**
     * Destroy and don't use after this
     * @override
     */
    dispose() {
        this.data = null;
    }
    ;
    /**
     * Used to auto-detect the type of resource.
     *
     * @static
     * @param {*} source - The source object
     * @return {boolean} `true` if <canvas>
     */
    static test(source) {
        return source instanceof Float32Array
            || source instanceof Uint8Array
            || source instanceof Uint32Array;
    }
    ;
}
exports.BufferResource = BufferResource;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/CacheSettings.js":
/*!*************************************************!*\
  !*** ./js-compile/raw-pixi-ts/CacheSettings.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class CacheSettings {
    static clearTextureCache() {
        var key;
        for (key in CacheSettings.TextureCache) {
            delete CacheSettings.TextureCache[key];
        }
        for (key in CacheSettings.BaseTextureCache) {
            delete CacheSettings.BaseTextureCache[key];
        }
    }
    static destroyTextureCache() {
        var key;
        for (key in CacheSettings.TextureCache) {
            CacheSettings.TextureCache[key].destroy();
        }
        for (key in CacheSettings.BaseTextureCache) {
            CacheSettings.BaseTextureCache[key].destroy();
        }
    }
}
CacheSettings.ProgramCache = {};
CacheSettings.nameCache = {};
CacheSettings.programCache = {};
CacheSettings.TextureCache = {};
CacheSettings.BaseTextureCache = {};
CacheSettings.defaultGroupCache = {};
exports.CacheSettings = CacheSettings;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/CanvasRenderTarget.js":
/*!******************************************************!*\
  !*** ./js-compile/raw-pixi-ts/CanvasRenderTarget.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const DisplaySettings_1 = __webpack_require__(/*! ./DisplaySettings */ "./js-compile/raw-pixi-ts/DisplaySettings.js");
class CanvasRenderTarget {
    constructor(width, height, resolution) {
        /**
                 * The Canvas object that belongs to this CanvasRenderTarget.
                 *
                 * @member {HTMLCanvasElement}
                 */
        this.canvas = document.createElement('canvas');
        /**
         * A CanvasRenderingContext2D object representing a two-dimensional rendering context.
         *
         * @member {CanvasRenderingContext2D}
         */
        this.context = this.canvas.getContext('2d');
        this.resolution = resolution || DisplaySettings_1.DisplaySettings.RESOLUTION;
        this.resize(width, height);
    }
    /**
     * Clears the canvas that was created by the CanvasRenderTarget class.
     *
     * @private
     */
    clear() {
        this.context.setTransform(1, 0, 0, 1, 0, 0);
        this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
    }
    ;
    /**
     * Resizes the canvas to the specified width and height.
     *
     * @param {number} width - the new width of the canvas
     * @param {number} height - the new height of the canvas
     */
    resize(width, height) {
        this.canvas.width = width * this.resolution;
        this.canvas.height = height * this.resolution;
    }
    ;
    /**
     * Destroys this canvas.
     *
     */
    destroy() {
        this.context = null;
        this.canvas = null;
    }
    ;
    /**
     * The width of the canvas buffer in pixels.
     *
     * @member {number}
     */
    get width() {
        return this.canvas.width;
    }
    ;
    set width(val) {
        this.canvas.width = val;
    }
    ;
    /**
     * The height of the canvas buffer in pixels.
     *
     * @member {number}
     */
    get height() {
        return this.canvas.height;
    }
    ;
    set height(val) {
        this.canvas.height = val;
    }
    ;
}
exports.CanvasRenderTarget = CanvasRenderTarget;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/CanvasResource.js":
/*!**************************************************!*\
  !*** ./js-compile/raw-pixi-ts/CanvasResource.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseImageResource_1 = __webpack_require__(/*! ./BaseImageResource */ "./js-compile/raw-pixi-ts/BaseImageResource.js");
class CanvasResource extends BaseImageResource_1.BaseImageResource {
    constructor(source) {
        super(source);
    }
    static test(source) {
        return (source instanceof HTMLCanvasElement);
    }
    ;
}
exports.CanvasResource = CanvasResource;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/CanvasSettings.js":
/*!**************************************************!*\
  !*** ./js-compile/raw-pixi-ts/CanvasSettings.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class CanvasSettings {
    /**
* Trim transparent borders from a canvas
*
* @memberof PIXI.utils
* @function trimCanvas
* @param {HTMLCanvasElement} canvas - the canvas to trim
* @returns {object} Trim data
*/
    static trimCanvas(canvas) {
        // https://gist.github.com/remy/784508
        var width = canvas.width;
        var height = canvas.height;
        var context = canvas.getContext('2d');
        var imageData = context.getImageData(0, 0, width, height);
        var pixels = imageData.data;
        var len = pixels.length;
        var bound = {
            top: null,
            left: null,
            right: null,
            bottom: null,
        };
        var data = null;
        var i;
        var x;
        var y;
        for (i = 0; i < len; i += 4) {
            if (pixels[i + 3] !== 0) {
                x = (i / 4) % width;
                y = ~~((i / 4) / width);
                if (bound.top === null) {
                    bound.top = y;
                }
                if (bound.left === null) {
                    bound.left = x;
                }
                else if (x < bound.left) {
                    bound.left = x;
                }
                if (bound.right === null) {
                    bound.right = x + 1;
                }
                else if (bound.right < x) {
                    bound.right = x + 1;
                }
                if (bound.bottom === null) {
                    bound.bottom = y;
                }
                else if (bound.bottom < y) {
                    bound.bottom = y;
                }
            }
        }
        if (bound.top !== null) {
            width = bound.right - bound.left;
            height = bound.bottom - bound.top + 1;
            data = context.getImageData(bound.left, bound.top, width, height);
        }
        return {
            height: height,
            width: width,
            data: data,
        };
    }
}
exports.CanvasSettings = CanvasSettings;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/Circle.js":
/*!******************************************!*\
  !*** ./js-compile/raw-pixi-ts/Circle.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Rectangle_1 = __webpack_require__(/*! ./Rectangle */ "./js-compile/raw-pixi-ts/Rectangle.js");
const ShapeSettings_1 = __webpack_require__(/*! ./ShapeSettings */ "./js-compile/raw-pixi-ts/ShapeSettings.js");
class Circle {
    constructor(x = 0, y = 0, radius = 0) {
        if (x === void 0) {
            x = 0;
        }
        if (y === void 0) {
            y = 0;
        }
        if (radius === void 0) {
            radius = 0;
        }
        /**
         * @member {number}
         * @default 0
         */
        this.x = x;
        /**
         * @member {number}
         * @default 0
         */
        this.y = y;
        /**
         * @member {number}
         * @default 0
         */
        this.radius = radius;
        /**
         * The type of the object, mainly used to avoid `instanceof` checks
         *
         * @member {number}
         * @readOnly
         * @default PIXI.SHAPES.CIRC
         * @see PIXI.SHAPES
         */
        this.type = ShapeSettings_1.ShapeSettings.SHAPES.CIRC;
    }
    /**
     * Creates a clone of this Circle instance
     *
     * @return {PIXI.Circle} a copy of the Circle
     */
    clone() {
        return new Circle(this.x, this.y, this.radius);
    }
    ;
    /**
     * Checks whether the x and y coordinates given are contained within this circle
     *
     * @param {number} x - The X coordinate of the point to test
     * @param {number} y - The Y coordinate of the point to test
     * @return {boolean} Whether the x/y coordinates are within this Circle
     */
    contains(x, y) {
        if (this.radius <= 0) {
            return false;
        }
        var r2 = this.radius * this.radius;
        var dx = (this.x - x);
        var dy = (this.y - y);
        dx *= dx;
        dy *= dy;
        return (dx + dy <= r2);
    }
    ;
    /**
    * Returns the framing rectangle of the circle as a Rectangle object
    *
    * @return {PIXI.Rectangle} the framing rectangle
    */
    getBounds() {
        return new Rectangle_1.Rectangle(this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2);
    }
    ;
}
exports.Circle = Circle;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/CleanUpSettings.js":
/*!***************************************************!*\
  !*** ./js-compile/raw-pixi-ts/CleanUpSettings.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class CleanUpSettings {
}
CleanUpSettings.defaultDestroyOptions = {
    texture: true,
    children: false,
    baseTexture: true,
};
exports.CleanUpSettings = CleanUpSettings;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/ColorMatrixFilter.js":
/*!*****************************************************!*\
  !*** ./js-compile/raw-pixi-ts/ColorMatrixFilter.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Filter_1 = __webpack_require__(/*! ./Filter */ "./js-compile/raw-pixi-ts/Filter.js");
const settings_1 = __webpack_require__(/*! ./settings */ "./js-compile/raw-pixi-ts/settings.js");
class ColorMatrixFilter extends Filter_1.Filter {
    constructor() {
        var uniforms = {
            m: new Float32Array([1, 0, 0, 0, 0,
                0, 1, 0, 0, 0,
                0, 0, 1, 0, 0,
                0, 0, 0, 1, 0]),
            uAlpha: 1,
        };
        super(settings_1.settings.defaultFilterVertex, ColorMatrixFilter.fragment$4, uniforms);
        this.alpha = 1;
    }
    /**
     * Transforms current matrix and set the new one
     *
     * @param {number[]} matrix - 5x4 matrix
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */
    _loadMatrix(matrix, multiply) {
        if (multiply === void 0) {
            multiply = false;
        }
        var newMatrix = matrix;
        if (multiply) {
            this._multiply(newMatrix, this.uniforms.m, matrix);
            newMatrix = this._colorMatrix(newMatrix);
        }
        // set the new matrix
        this.uniforms.m = newMatrix;
    }
    ;
    /**
     * Multiplies two mat5's
     *
     * @private
     * @param {number[]} out - 5x4 matrix the receiving matrix
     * @param {number[]} a - 5x4 matrix the first operand
     * @param {number[]} b - 5x4 matrix the second operand
     * @returns {number[]} 5x4 matrix
     */
    _multiply(out, a, b) {
        // Red Channel
        out[0] = (a[0] * b[0]) + (a[1] * b[5]) + (a[2] * b[10]) + (a[3] * b[15]);
        out[1] = (a[0] * b[1]) + (a[1] * b[6]) + (a[2] * b[11]) + (a[3] * b[16]);
        out[2] = (a[0] * b[2]) + (a[1] * b[7]) + (a[2] * b[12]) + (a[3] * b[17]);
        out[3] = (a[0] * b[3]) + (a[1] * b[8]) + (a[2] * b[13]) + (a[3] * b[18]);
        out[4] = (a[0] * b[4]) + (a[1] * b[9]) + (a[2] * b[14]) + (a[3] * b[19]) + a[4];
        // Green Channel
        out[5] = (a[5] * b[0]) + (a[6] * b[5]) + (a[7] * b[10]) + (a[8] * b[15]);
        out[6] = (a[5] * b[1]) + (a[6] * b[6]) + (a[7] * b[11]) + (a[8] * b[16]);
        out[7] = (a[5] * b[2]) + (a[6] * b[7]) + (a[7] * b[12]) + (a[8] * b[17]);
        out[8] = (a[5] * b[3]) + (a[6] * b[8]) + (a[7] * b[13]) + (a[8] * b[18]);
        out[9] = (a[5] * b[4]) + (a[6] * b[9]) + (a[7] * b[14]) + (a[8] * b[19]) + a[9];
        // Blue Channel
        out[10] = (a[10] * b[0]) + (a[11] * b[5]) + (a[12] * b[10]) + (a[13] * b[15]);
        out[11] = (a[10] * b[1]) + (a[11] * b[6]) + (a[12] * b[11]) + (a[13] * b[16]);
        out[12] = (a[10] * b[2]) + (a[11] * b[7]) + (a[12] * b[12]) + (a[13] * b[17]);
        out[13] = (a[10] * b[3]) + (a[11] * b[8]) + (a[12] * b[13]) + (a[13] * b[18]);
        out[14] = (a[10] * b[4]) + (a[11] * b[9]) + (a[12] * b[14]) + (a[13] * b[19]) + a[14];
        // Alpha Channel
        out[15] = (a[15] * b[0]) + (a[16] * b[5]) + (a[17] * b[10]) + (a[18] * b[15]);
        out[16] = (a[15] * b[1]) + (a[16] * b[6]) + (a[17] * b[11]) + (a[18] * b[16]);
        out[17] = (a[15] * b[2]) + (a[16] * b[7]) + (a[17] * b[12]) + (a[18] * b[17]);
        out[18] = (a[15] * b[3]) + (a[16] * b[8]) + (a[17] * b[13]) + (a[18] * b[18]);
        out[19] = (a[15] * b[4]) + (a[16] * b[9]) + (a[17] * b[14]) + (a[18] * b[19]) + a[19];
        return out;
    }
    ;
    /**
     * Create a Float32 Array and normalize the offset component to 0-1
     *
     * @private
     * @param {number[]} matrix - 5x4 matrix
     * @return {number[]} 5x4 matrix with all values between 0-1
     */
    _colorMatrix(matrix) {
        // Create a Float32 Array and normalize the offset component to 0-1
        var m = new Float32Array(matrix);
        m[4] /= 255;
        m[9] /= 255;
        m[14] /= 255;
        m[19] /= 255;
        return m;
    }
    ;
    /**
     * Adjusts brightness
     *
     * @param {number} b - value of the brigthness (0-1, where 0 is black)
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */
    brightness(b, multiply) {
        var matrix = [
            b, 0, 0, 0, 0,
            0, b, 0, 0, 0,
            0, 0, b, 0, 0,
            0, 0, 0, 1, 0
        ];
        this._loadMatrix(matrix, multiply);
    }
    ;
    /**
     * Set the matrices in grey scales
     *
     * @param {number} scale - value of the grey (0-1, where 0 is black)
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */
    greyscale(scale, multiply) {
        var matrix = [
            scale, scale, scale, 0, 0,
            scale, scale, scale, 0, 0,
            scale, scale, scale, 0, 0,
            0, 0, 0, 1, 0
        ];
        this._loadMatrix(matrix, multiply);
    }
    ;
    /**
     * Set the black and white matrice.
     *
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */
    blackAndWhite(multiply) {
        var matrix = [
            0.3, 0.6, 0.1, 0, 0,
            0.3, 0.6, 0.1, 0, 0,
            0.3, 0.6, 0.1, 0, 0,
            0, 0, 0, 1, 0
        ];
        this._loadMatrix(matrix, multiply);
    }
    ;
    /**
     * Set the hue property of the color
     *
     * @param {number} rotation - in degrees
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */
    hue(rotation, multiply) {
        rotation = (rotation || 0) / 180 * Math.PI;
        var cosR = Math.cos(rotation);
        var sinR = Math.sin(rotation);
        var sqrt = Math.sqrt;
        /* a good approximation for hue rotation
            This matrix is far better than the versions with magic luminance constants
            formerly used here, but also used in the starling framework (flash) and known from this
            old part of the internet: quasimondo.com/archives/000565.php

            This new matrix is based on rgb cube rotation in space. Look here for a more descriptive
            implementation as a shader not a general matrix:
            https://github.com/evanw/glfx.js/blob/58841c23919bd59787effc0333a4897b43835412/src/filters/adjust/huesaturation.js

            This is the source for the code:
            see http://stackoverflow.com/questions/8507885/shift-hue-of-an-rgb-color/8510751#8510751
            */
        var w = 1 / 3;
        var sqrW = sqrt(w); // weight is
        var a00 = cosR + ((1.0 - cosR) * w);
        var a01 = (w * (1.0 - cosR)) - (sqrW * sinR);
        var a02 = (w * (1.0 - cosR)) + (sqrW * sinR);
        var a10 = (w * (1.0 - cosR)) + (sqrW * sinR);
        var a11 = cosR + (w * (1.0 - cosR));
        var a12 = (w * (1.0 - cosR)) - (sqrW * sinR);
        var a20 = (w * (1.0 - cosR)) - (sqrW * sinR);
        var a21 = (w * (1.0 - cosR)) + (sqrW * sinR);
        var a22 = cosR + (w * (1.0 - cosR));
        var matrix = [
            a00, a01, a02, 0, 0,
            a10, a11, a12, 0, 0,
            a20, a21, a22, 0, 0,
            0, 0, 0, 1, 0
        ];
        this._loadMatrix(matrix, multiply);
    }
    ;
    /**
     * Set the contrast matrix, increase the separation between dark and bright
     * Increase contrast : shadows darker and highlights brighter
     * Decrease contrast : bring the shadows up and the highlights down
     *
     * @param {number} amount - value of the contrast (0-1)
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */
    contrast(amount, multiply) {
        var v = (amount || 0) + 1;
        var o = -0.5 * (v - 1);
        var matrix = [
            v, 0, 0, 0, o,
            0, v, 0, 0, o,
            0, 0, v, 0, o,
            0, 0, 0, 1, 0
        ];
        this._loadMatrix(matrix, multiply);
    }
    ;
    /**
     * Set the saturation matrix, increase the separation between colors
     * Increase saturation : increase contrast, brightness, and sharpness
     *
     * @param {number} amount - The saturation amount (0-1)
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */
    saturate(amount, multiply = null) {
        if (amount === void 0) {
            amount = 0;
        }
        var x = (amount * 2 / 3) + 1;
        var y = ((x - 1) * -0.5);
        var matrix = [
            x, y, y, 0, 0,
            y, x, y, 0, 0,
            y, y, x, 0, 0,
            0, 0, 0, 1, 0
        ];
        this._loadMatrix(matrix, multiply);
    }
    ;
    /**
     * Desaturate image (remove color)
     *
     * Call the saturate function
     *
     */
    desaturate() {
        this.saturate(-1);
    }
    ;
    /**
     * Negative image (inverse of classic rgb matrix)
     *
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */
    negative(multiply) {
        var matrix = [
            -1, 0, 0, 1, 0,
            0, -1, 0, 1, 0,
            0, 0, -1, 1, 0,
            0, 0, 0, 1, 0
        ];
        this._loadMatrix(matrix, multiply);
    }
    ;
    /**
     * Sepia image
     *
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */
    sepia(multiply) {
        var matrix = [
            0.393, 0.7689999, 0.18899999, 0, 0,
            0.349, 0.6859999, 0.16799999, 0, 0,
            0.272, 0.5339999, 0.13099999, 0, 0,
            0, 0, 0, 1, 0
        ];
        this._loadMatrix(matrix, multiply);
    }
    ;
    /**
     * Color motion picture process invented in 1916 (thanks Dominic Szablewski)
     *
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */
    technicolor(multiply) {
        var matrix = [
            1.9125277891456083, -0.8545344976951645, -0.09155508482755585, 0, 11.793603434377337,
            -0.3087833385928097, 1.7658908555458428, -0.10601743074722245, 0, -70.35205161461398,
            -0.231103377548616, -0.7501899197440212, 1.847597816108189, 0, 30.950940869491138,
            0, 0, 0, 1, 0
        ];
        this._loadMatrix(matrix, multiply);
    }
    ;
    /**
     * Polaroid filter
     *
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */
    polaroid(multiply) {
        var matrix = [
            1.438, -0.062, -0.062, 0, 0,
            -0.122, 1.378, -0.122, 0, 0,
            -0.016, -0.016, 1.483, 0, 0,
            0, 0, 0, 1, 0
        ];
        this._loadMatrix(matrix, multiply);
    }
    ;
    /**
     * Filter who transforms : Red -> Blue and Blue -> Red
     *
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */
    toBGR(multiply) {
        var matrix = [
            0, 0, 1, 0, 0,
            0, 1, 0, 0, 0,
            1, 0, 0, 0, 0,
            0, 0, 0, 1, 0
        ];
        this._loadMatrix(matrix, multiply);
    }
    ;
    /**
     * Color reversal film introduced by Eastman Kodak in 1935. (thanks Dominic Szablewski)
     *
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */
    kodachrome(multiply) {
        var matrix = [
            1.1285582396593525, -0.3967382283601348, -0.03992559172921793, 0, 63.72958762196502,
            -0.16404339962244616, 1.0835251566291304, -0.05498805115633132, 0, 24.732407896706203,
            -0.16786010706155763, -0.5603416277695248, 1.6014850761964943, 0, 35.62982807460946,
            0, 0, 0, 1, 0
        ];
        this._loadMatrix(matrix, multiply);
    }
    ;
    /**
     * Brown delicious browni filter (thanks Dominic Szablewski)
     *
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */
    browni(multiply) {
        var matrix = [
            0.5997023498159715, 0.34553243048391263, -0.2708298674538042, 0, 47.43192855600873,
            -0.037703249837783157, 0.8609577587992641, 0.15059552388459913, 0, -36.96841498319127,
            0.24113635128153335, -0.07441037908422492, 0.44972182064877153, 0, -7.562075277591283,
            0, 0, 0, 1, 0
        ];
        this._loadMatrix(matrix, multiply);
    }
    ;
    /**
     * Vintage filter (thanks Dominic Szablewski)
     *
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */
    vintage(multiply) {
        var matrix = [
            0.6279345635605994, 0.3202183420819367, -0.03965408211312453, 0, 9.651285835294123,
            0.02578397704808868, 0.6441188644374771, 0.03259127616149294, 0, 7.462829176470591,
            0.0466055556782719, -0.0851232987247891, 0.5241648018700465, 0, 5.159190588235296,
            0, 0, 0, 1, 0
        ];
        this._loadMatrix(matrix, multiply);
    }
    ;
    /**
     * We don't know exactly what it does, kind of gradient map, but funny to play with!
     *
     * @param {number} desaturation - Tone values.
     * @param {number} toned - Tone values.
     * @param {string} lightColor - Tone values, example: `0xFFE580`
     * @param {string} darkColor - Tone values, example: `0xFFE580`
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */
    colorTone(desaturation, toned, lightColor, darkColor, multiply) {
        desaturation = desaturation || 0.2;
        toned = toned || 0.15;
        lightColor = lightColor || 0xFFE580;
        darkColor = darkColor || 0x338000;
        var lR = ((lightColor >> 16) & 0xFF) / 255;
        var lG = ((lightColor >> 8) & 0xFF) / 255;
        var lB = (lightColor & 0xFF) / 255;
        var dR = ((darkColor >> 16) & 0xFF) / 255;
        var dG = ((darkColor >> 8) & 0xFF) / 255;
        var dB = (darkColor & 0xFF) / 255;
        var matrix = [
            0.3, 0.59, 0.11, 0, 0,
            lR, lG, lB, desaturation, 0,
            dR, dG, dB, toned, 0,
            lR - dR, lG - dG, lB - dB, 0, 0
        ];
        this._loadMatrix(matrix, multiply);
    }
    ;
    /**
     * Night effect
     *
     * @param {number} intensity - The intensity of the night effect.
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */
    night(intensity, multiply) {
        intensity = intensity || 0.1;
        var matrix = [
            intensity * (-2.0), -intensity, 0, 0, 0,
            -intensity, 0, intensity, 0, 0,
            0, intensity, intensity * 2.0, 0, 0,
            0, 0, 0, 1, 0
        ];
        this._loadMatrix(matrix, multiply);
    }
    ;
    /**
     * Predator effect
     *
     * Erase the current matrix by setting a new indepent one
     *
     * @param {number} amount - how much the predator feels his future victim
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */
    predator(amount, multiply) {
        var matrix = [
            // row 1
            11.224130630493164 * amount,
            -4.794486999511719 * amount,
            -2.8746118545532227 * amount,
            0 * amount,
            0.40342438220977783 * amount,
            // row 2
            -3.6330697536468506 * amount,
            9.193157196044922 * amount,
            -2.951810836791992 * amount,
            0 * amount,
            -1.316135048866272 * amount,
            // row 3
            -3.2184197902679443 * amount,
            -4.2375030517578125 * amount,
            7.476448059082031 * amount,
            0 * amount,
            0.8044459223747253 * amount,
            // row 4
            0, 0, 0, 1, 0
        ];
        this._loadMatrix(matrix, multiply);
    }
    ;
    /**
     * LSD effect
     *
     * Multiply the current matrix
     *
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */
    lsd(multiply) {
        var matrix = [
            2, -0.4, 0.5, 0, 0,
            -0.5, 2, -0.4, 0, 0,
            -0.4, -0.5, 3, 0, 0,
            0, 0, 0, 1, 0
        ];
        this._loadMatrix(matrix, multiply);
    }
    ;
    /**
     * Erase the current matrix by setting the default one
     *
     */
    reset() {
        var matrix = [
            1, 0, 0, 0, 0,
            0, 1, 0, 0, 0,
            0, 0, 1, 0, 0,
            0, 0, 0, 1, 0
        ];
        this._loadMatrix(matrix, false);
    }
    ;
    /**
     * The matrix of the color matrix filter
     *
     * @member {number[]}
     * @default [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0]
     */
    get matrix() {
        return this.uniforms.m;
    }
    ;
    set matrix(value) {
        this.uniforms.m = value;
    }
    ;
    /**
     * The opacity value to use when mixing the original and resultant colors.
     *
     * When the value is 0, the original color is used without modification.
     * When the value is 1, the result color is used.
     * When in the range (0, 1) the color is interpolated between the original and result by this amount.
     *
     * @member {number}
     * @default 1
     */
    get alpha() {
        return this.uniforms.uAlpha;
    }
    ;
    set alpha(value) {
        this.uniforms.uAlpha = value;
    }
    ;
}
/*!
* @pixi/filter-color-matrix - v5.0.0-rc.3
* Compiled Wed, 10 Apr 2019 01:21:15 UTC
*
* @pixi/filter-color-matrix is licensed under the MIT License.
* http://www.opensource.org/licenses/mit-license
*/
ColorMatrixFilter.fragment$4 = "varying vec2 vTextureCoord;\r\nuniform sampler2D uSampler;\r\nuniform float m[20];\r\nuniform float uAlpha;\r\n\r\nvoid main(void)\r\n{\r\n    vec4 c = texture2D(uSampler, vTextureCoord);\r\n\r\n    if (uAlpha == 0.0) {\r\n        gl_FragColor = c;\r\n        return;\r\n    }\r\n\r\n    // Un-premultiply alpha before applying the color matrix. See issue #3539.\r\n    if (c.a > 0.0) {\r\n      c.rgb /= c.a;\r\n    }\r\n\r\n    vec4 result;\r\n\r\n    result.r = (m[0] * c.r);\r\n        result.r += (m[1] * c.g);\r\n        result.r += (m[2] * c.b);\r\n        result.r += (m[3] * c.a);\r\n        result.r += m[4];\r\n\r\n    result.g = (m[5] * c.r);\r\n        result.g += (m[6] * c.g);\r\n        result.g += (m[7] * c.b);\r\n        result.g += (m[8] * c.a);\r\n        result.g += m[9];\r\n\r\n    result.b = (m[10] * c.r);\r\n       result.b += (m[11] * c.g);\r\n       result.b += (m[12] * c.b);\r\n       result.b += (m[13] * c.a);\r\n       result.b += m[14];\r\n\r\n    result.a = (m[15] * c.r);\r\n       result.a += (m[16] * c.g);\r\n       result.a += (m[17] * c.b);\r\n       result.a += (m[18] * c.a);\r\n       result.a += m[19];\r\n\r\n    vec3 rgb = mix(c.rgb, result.rgb, uAlpha);\r\n\r\n    // Premultiply alpha again.\r\n    rgb *= result.a;\r\n\r\n    gl_FragColor = vec4(rgb, result.a);\r\n}\r\n";
exports.ColorMatrixFilter = ColorMatrixFilter;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/ColorSettings.js":
/*!*************************************************!*\
  !*** ./js-compile/raw-pixi-ts/ColorSettings.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const MathSettings_1 = __webpack_require__(/*! ./MathSettings */ "./js-compile/raw-pixi-ts/MathSettings.js");
class ColorSettings {
    static premultiplyTint(tint, alpha) {
        if (alpha === 1.0) {
            return (alpha * 255 << 24) + tint;
        }
        if (alpha === 0.0) {
            return 0;
        }
        var R = ((tint >> 16) & 0xFF);
        var G = ((tint >> 8) & 0xFF);
        var B = (tint & 0xFF);
        R = ((R * alpha) + 0.5) | 0;
        G = ((G * alpha) + 0.5) | 0;
        B = ((B * alpha) + 0.5) | 0;
        return (alpha * 255 << 24) + (R << 16) + (G << 8) + B;
    }
    static premultiplyTintToRgba(tint, alpha, out, premultiply) {
        out = out || new Float32Array(4);
        out[0] = ((tint >> 16) & 0xFF) / 255.0;
        out[1] = ((tint >> 8) & 0xFF) / 255.0;
        out[2] = (tint & 0xFF) / 255.0;
        if (premultiply || premultiply === undefined) {
            out[0] *= alpha;
            out[1] *= alpha;
            out[2] *= alpha;
        }
        out[3] = alpha;
        return out;
    }
    static getSingleColor(color) {
        if (typeof color === 'number') {
            return MathSettings_1.MathSettings.hex2string(color);
        }
        else if (typeof color === 'string') {
            if (color.indexOf('0x') === 0) {
                color = color.replace('0x', '#');
            }
        }
        return color;
    }
    static getColor(color) {
        if (!Array.isArray(color)) {
            return ColorSettings.getSingleColor(color);
        }
        else {
            for (var i = 0; i < color.length; ++i) {
                color[i] = ColorSettings.getSingleColor(color[i]);
            }
            return color;
        }
    }
    static premultiplyRgba(rgb, alpha, out, premultiply) {
        out = out || new Float32Array(4);
        if (premultiply || premultiply === undefined) {
            out[0] = rgb[0] * alpha;
            out[1] = rgb[1] * alpha;
            out[2] = rgb[2] * alpha;
        }
        else {
            out[0] = rgb[0];
            out[1] = rgb[1];
            out[2] = rgb[2];
        }
        out[3] = alpha;
        return out;
    }
    /**
* Converts a hexadecimal color number to an [R, G, B] array of normalized floats (numbers from 0.0 to 1.0).
*
* @example
* PIXI.utils.hex2rgb(0xffffff); // returns [1, 1, 1]
* @memberof PIXI.utils
* @function hex2rgb
* @param {number} hex - The hexadecimal number to convert
* @param  {number[]} [out=[]] If supplied, this array will be used rather than returning a new one
* @return {number[]} An array representing the [R, G, B] of the color where all values are floats.
*/
    static hex2rgb(hex, out = null) {
        out = out || [];
        out[0] = ((hex >> 16) & 0xFF) / 255;
        out[1] = ((hex >> 8) & 0xFF) / 255;
        out[2] = (hex & 0xFF) / 255;
        return out;
    }
    /**
* Converts a color as an [R, G, B] array of normalized floats to a hexadecimal number.
*
* @example
* PIXI.utils.rgb2hex([1, 1, 1]); // returns 0xffffff
* @memberof PIXI.utils
* @function rgb2hex
* @param {number[]} rgb - Array of numbers where all values are normalized floats from 0.0 to 1.0.
* @return {number} Number in hexadecimal.
*/
    static rgb2hex(rgb) {
        return (((rgb[0] * 255) << 16) + ((rgb[1] * 255) << 8) + (rgb[2] * 255 | 0));
    }
}
exports.ColorSettings = ColorSettings;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/Container.js":
/*!*********************************************!*\
  !*** ./js-compile/raw-pixi-ts/Container.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const DisplayObject_1 = __webpack_require__(/*! ./DisplayObject */ "./js-compile/raw-pixi-ts/DisplayObject.js");
const Event_1 = __webpack_require__(/*! ./Event */ "./js-compile/raw-pixi-ts/Event.js");
const UtilsSettings_1 = __webpack_require__(/*! ./UtilsSettings */ "./js-compile/raw-pixi-ts/UtilsSettings.js");
const DisplaySettings_1 = __webpack_require__(/*! ./DisplaySettings */ "./js-compile/raw-pixi-ts/DisplaySettings.js");
class Container extends DisplayObject_1.DisplayObject {
    constructor() {
        super();
        this.containerUpdateTransform = this.updateTransform;
        /**
         * The array of children of this container.
         *
         * @member {PIXI.DisplayObject[]}
         * @readonly
         */
        this.children = [];
        /**
         * If set to true, the container will sort its children by zIndex value
         * when updateTransform() is called, or manually if sortChildren() is called.
         *
         * This actually changes the order of elements in the array, so should be treated
         * as a basic solution that is not performant compared to other solutions,
         * such as @link https://github.com/pixijs/pixi-display
         *
         * Also be aware of that this may not work nicely with the addChildAt() function,
         * as the zIndex sorting may cause the child to automatically sorted to another position.
         *
         * @see PIXI.settings.SORTABLE_CHILDREN
         *
         * @member {boolean}
         */
        this.sortableChildren = DisplaySettings_1.DisplaySettings.SORTABLE_CHILDREN;
        /**
         * Should children be sorted by zIndex at the next updateTransform call.
         * Will get automatically set to true if a new child is added, or if a child's zIndex changes.
         *
         * @member {boolean}
         */
        this.sortDirty = false;
        /**
         * Fired when a DisplayObject is added to this Container.
         *
         * @event PIXI.Container#childAdded
         * @param {PIXI.DisplayObject} child - The child added to the Container.
         * @param {PIXI.Container} container - The container that added the child.
         * @param {number} index - The children's index of the added child.
         */
        /**
         * Fired when a DisplayObject is removed from this Container.
         *
         * @event PIXI.DisplayObject#removedFrom
         * @param {PIXI.DisplayObject} child - The child removed from the Container.
         * @param {PIXI.Container} container - The container that removed removed the child.
         * @param {number} index - The former children's index of the removed child
         */
    }
    /**
 * Returns the display object in the container.
 *
 * @method getChildByName
 * @memberof PIXI.Container#
 * @param {string} name - Instance name.
 * @return {PIXI.DisplayObject} The child with the specified name.
 */
    getChildByName(name) {
        for (var i = 0; i < this.children.length; i++) {
            if (this.children[i].name === name) {
                return this.children[i];
            }
        }
        return null;
    }
    ;
    /**
     * Overridable method that can be used by Container subclasses whenever the children array is modified
     *
     * @protected
     */
    onChildrenChange(options) {
        /* empty */
    }
    ;
    /**
     * Adds one or more children to the container.
     *
     * Multiple items can be added like so: `myContainer.addChild(thingOne, thingTwo, thingThree)`
     *
     * @param {...PIXI.DisplayObject} child - The DisplayObject(s) to add to the container
     * @return {PIXI.DisplayObject} The first child that was added.
     */
    addChild(child) {
        var arguments$1 = arguments;
        var argumentsLength = arguments.length;
        // if there is only one argument we can bypass looping through the them
        if (argumentsLength > 1) {
            // loop through the arguments property and add all children
            // use it the right way (.length and [i]) so that this function can still be optimized by JS runtimes
            for (var i = 0; i < argumentsLength; i++) {
                this.addChild(arguments$1[i]);
            }
        }
        else {
            // if the child has a parent then lets remove it as PixiJS objects can only exist in one place
            if (child.parent) {
                child.parent.removeChild(child);
            }
            child.parent = this;
            this.sortDirty = true;
            // ensure child transform will be recalculated
            child.transform._parentID = -1;
            this.children.push(child);
            // ensure bounds will be recalculated
            this._boundsID++;
            // TODO - lets either do all callbacks or all events.. not both!
            this.onChildrenChange(this.children.length - 1);
            this.dispatchEvent(Event_1.Event.getEvent("childAdded"));
            // this.emit('childAdded', child, this, this.children.length - 1);
            child.dispatchEvent(Event_1.Event.getEvent("added"));
            // child.emit('added', this);
        }
        return child;
    }
    ;
    /**
     * Adds a child to the container at a specified index. If the index is out of bounds an error will be thrown
     *
     * @param {PIXI.DisplayObject} child - The child to add
     * @param {number} index - The index to place the child in
     * @return {PIXI.DisplayObject} The child that was added.
     */
    addChildAt(child, index) {
        if (index < 0 || index > this.children.length) {
            throw new Error((child + "addChildAt: The index " + index + " supplied is out of bounds " + (this.children.length)));
        }
        if (child.parent) {
            child.parent.removeChild(child);
        }
        child.parent = this;
        this.sortDirty = true;
        // ensure child transform will be recalculated
        child.transform._parentID = -1;
        this.children.splice(index, 0, child);
        // ensure bounds will be recalculated
        this._boundsID++;
        // TODO - lets either do all callbacks or all events.. not both!
        this.onChildrenChange(index);
        // child.emit('added', this);
        this.dispatchEvent(Event_1.Event.getEvent("childAdded"));
        // this.emit('childAdded', child, this, index);
        return child;
    }
    ;
    /**
     * Swaps the position of 2 Display Objects within this container.
     *
     * @param {PIXI.DisplayObject} child - First display object to swap
     * @param {PIXI.DisplayObject} child2 - Second display object to swap
     */
    swapChildren(child, child2) {
        if (child === child2) {
            return;
        }
        var index1 = this.getChildIndex(child);
        var index2 = this.getChildIndex(child2);
        this.children[index1] = child2;
        this.children[index2] = child;
        this.onChildrenChange(index1 < index2 ? index1 : index2);
    }
    ;
    /**
     * Returns the index position of a child DisplayObject instance
     *
     * @param {PIXI.DisplayObject} child - The DisplayObject instance to identify
     * @return {number} The index position of the child display object to identify
     */
    getChildIndex(child) {
        var index = this.children.indexOf(child);
        if (index === -1) {
            throw new Error('The supplied DisplayObject must be a child of the caller');
        }
        return index;
    }
    ;
    /**
     * Changes the position of an existing child in the display object container
     *
     * @param {PIXI.DisplayObject} child - The child DisplayObject instance for which you want to change the index number
     * @param {number} index - The resulting index number for the child display object
     */
    setChildIndex(child, index) {
        if (index < 0 || index >= this.children.length) {
            throw new Error(("The index " + index + " supplied is out of bounds " + (this.children.length)));
        }
        var currentIndex = this.getChildIndex(child);
        UtilsSettings_1.UtilsSettings.removeItems(this.children, currentIndex, 1); // remove from old position
        this.children.splice(index, 0, child); // add at new position
        this.onChildrenChange(index);
    }
    ;
    /**
     * Returns the child at the specified index
     *
     * @param {number} index - The index to get the child at
     * @return {PIXI.DisplayObject} The child at the given index, if any.
     */
    getChildAt(index) {
        if (index < 0 || index >= this.children.length) {
            throw new Error(("getChildAt: Index (" + index + ") does not exist."));
        }
        return this.children[index];
    }
    ;
    /**
     * Removes one or more children from the container.
     *
     * @param {...PIXI.DisplayObject} child - The DisplayObject(s) to remove
     * @return {PIXI.DisplayObject} The first child that was removed.
     */
    removeChild(child) {
        var arguments$1 = arguments;
        var argumentsLength = arguments.length;
        // if there is only one argument we can bypass looping through the them
        if (argumentsLength > 1) {
            // loop through the arguments property and add all children
            // use it the right way (.length and [i]) so that this function can still be optimized by JS runtimes
            for (var i = 0; i < argumentsLength; i++) {
                this.removeChild(arguments$1[i]);
            }
        }
        else {
            var index = this.children.indexOf(child);
            if (index === -1) {
                return null;
            }
            child.parent = null;
            // ensure child transform will be recalculated
            child.transform._parentID = -1;
            UtilsSettings_1.UtilsSettings.removeItems(this.children, index, 1);
            // ensure bounds will be recalculated
            this._boundsID++;
            // TODO - lets either do all callbacks or all events.. not both!
            this.onChildrenChange(index);
            // child.emit('removed', this);
            this.dispatchEvent(Event_1.Event.getEvent("childRemoved"));
            // this.emit('childRemoved', child, this, index);
        }
        return child;
    }
    ;
    /**
     * Removes a child from the specified index position.
     *
     * @param {number} index - The index to get the child from
     * @return {PIXI.DisplayObject} The child that was removed.
     */
    removeChildAt(index) {
        var child = this.getChildAt(index);
        // ensure child transform will be recalculated..
        child.parent = null;
        child.transform._parentID = -1;
        UtilsSettings_1.UtilsSettings.removeItems(this.children, index, 1);
        // ensure bounds will be recalculated
        this._boundsID++;
        // TODO - lets either do all callbacks or all events.. not both!
        this.onChildrenChange(index);
        // child.emit('removed', this);
        this.dispatchEvent(Event_1.Event.getEvent("childRemoved"));
        // this.emit('childRemoved', child, this, index);
        return child;
    }
    ;
    /**
     * Removes all children from this container that are within the begin and end indexes.
     *
     * @param {number} [beginIndex=0] - The beginning position.
     * @param {number} [endIndex=this.children.length] - The ending position. Default value is size of the container.
     * @returns {DisplayObject[]} List of removed children
     */
    removeChildren(beginIndex = 0, endIndex = Infinity) {
        if (beginIndex === void 0) {
            beginIndex = 0;
        }
        var begin = beginIndex;
        var end = typeof endIndex === 'number' ? endIndex : this.children.length;
        var range = end - begin;
        var removed;
        if (range > 0 && range <= end) {
            removed = this.children.splice(begin, range);
            for (var i = 0; i < removed.length; ++i) {
                removed[i].parent = null;
                if (removed[i].transform) {
                    removed[i].transform._parentID = -1;
                }
            }
            this._boundsID++;
            this.onChildrenChange(beginIndex);
            for (var i$1 = 0; i$1 < removed.length; ++i$1) {
                // removed[i$1].emit('removed', this);
                this.dispatchEvent(Event_1.Event.getEvent("childRemoved"));
                // this.emit('childRemoved', removed[i$1], this, i$1);
            }
            return removed;
        }
        else if (range === 0 && this.children.length === 0) {
            return [];
        }
        throw new RangeError('removeChildren: numeric values are outside the acceptable range.');
    }
    ;
    /**
     * Sorts children by zIndex. Previous order is mantained for 2 children with the same zIndex.
     */
    sortChildren() {
        var sortRequired = false;
        for (var i = 0, j = this.children.length; i < j; ++i) {
            var child = this.children[i];
            child._lastSortedIndex = i;
            if (!sortRequired && child.zIndex !== 0) {
                sortRequired = true;
            }
        }
        if (sortRequired && this.children.length > 1) {
            this.children.sort(Container.sortChildren);
        }
        this.sortDirty = false;
    }
    ;
    /**
     * Updates the transform on all children of this container for rendering
     */
    updateTransform() {
        if (this.sortableChildren && this.sortDirty) {
            this.sortChildren();
        }
        this._boundsID++;
        this.transform.updateTransform(this.parent.transform);
        // TODO: check render flags, how to process stuff here
        this.worldAlpha = this.alpha * this.parent.worldAlpha;
        for (var i = 0, j = this.children.length; i < j; ++i) {
            var child = this.children[i];
            if (child.visible) {
                child.updateTransform();
            }
        }
    }
    ;
    /**
     * Recalculates the bounds of the container.
     *
     */
    calculateBounds() {
        this._bounds.clear();
        this._calculateBounds();
        for (var i = 0; i < this.children.length; i++) {
            var child = this.children[i];
            if (!child.visible || !child.renderable) {
                continue;
            }
            child.calculateBounds();
            // TODO: filter+mask, need to mask both somehow
            if (child._mask) {
                child._mask.calculateBounds();
                this._bounds.addBoundsMask(child._bounds, child._mask._bounds);
            }
            else if (child.filterArea) {
                this._bounds.addBoundsArea(child._bounds, child.filterArea);
            }
            else {
                this._bounds.addBounds(child._bounds);
            }
        }
        this._lastBoundsID = this._boundsID;
    }
    ;
    /**
     * Recalculates the bounds of the object. Override this to
     * calculate the bounds of the specific object (not including children).
     *
     * @protected
     */
    _calculateBounds() {
        // FILL IN//
    }
    ;
    /**
     * Renders the object using the WebGL renderer
     *
     * @param {PIXI.Renderer} renderer - The renderer
     */
    render(renderer) {
        // if the object is not visible or the alpha is 0 then no need to render this element
        if (!this.visible || this.worldAlpha <= 0 || !this.renderable) {
            return;
        }
        // do a quick check to see if this element has a mask or a filter.
        if (this._mask || this.filters) {
            this.renderAdvanced(renderer);
        }
        else {
            this._render(renderer);
            // simple render children!
            for (var i = 0, j = this.children.length; i < j; ++i) {
                this.children[i].render(renderer);
            }
        }
    }
    ;
    /**
     * Render the object using the WebGL renderer and advanced features.
     *
     * @protected
     * @param {PIXI.Renderer} renderer - The renderer
     */
    renderAdvanced(renderer) {
        renderer.batch.flush();
        var filters = this.filters;
        var mask = this._mask;
        // push filter first as we need to ensure the stencil buffer is correct for any masking
        if (filters) {
            if (!this._enabledFilters) {
                this._enabledFilters = [];
            }
            this._enabledFilters.length = 0;
            for (var i = 0; i < filters.length; i++) {
                if (filters[i].enabled) {
                    this._enabledFilters.push(filters[i]);
                }
            }
            if (this._enabledFilters.length) {
                renderer.filter.push(this, this._enabledFilters);
            }
        }
        if (mask) {
            renderer.mask.push(this, this._mask);
        }
        // add this object to the batch, only rendered if it has a texture.
        this._render(renderer);
        // now loop through the children and make sure they get rendered
        for (var i$1 = 0, j = this.children.length; i$1 < j; i$1++) {
            this.children[i$1].render(renderer);
        }
        renderer.batch.flush();
        if (mask) {
            renderer.mask.pop(this, this._mask);
        }
        if (filters && this._enabledFilters && this._enabledFilters.length) {
            renderer.filter.pop();
        }
    }
    ;
    /**
     * To be overridden by the subclasses.
     *
     * @protected
     * @param {PIXI.Renderer} renderer - The renderer
     */
    _render(renderer) {
        // this is where content itself gets rendered...
    }
    ;
    /**
     * Removes all internal references and listeners as well as removes children from the display list.
     * Do not use a Container after calling `destroy`.
     *
     * @param {object|boolean} [options] - Options parameter. A boolean will act as if all options
     *  have been set to that value
     * @param {boolean} [options.children=false] - if set to true, all the children will have their destroy
     *  method called as well. 'options' will be passed on to those calls.
     * @param {boolean} [options.texture=false] - Only used for child Sprites if options.children is set to true
     *  Should it destroy the texture of the child sprite
     * @param {boolean} [options.baseTexture=false] - Only used for child Sprites if options.children is set to true
     *  Should it destroy the base texture of the child sprite
     */
    destroy(options) {
        super.destroy(options);
        this.sortDirty = false;
        var destroyChildren = typeof options === 'boolean' ? options : options && options.children;
        var oldChildren = this.removeChildren(0, this.children.length);
        if (destroyChildren) {
            for (var i = 0; i < oldChildren.length; ++i) {
                oldChildren[i].destroy(options);
            }
        }
    }
    ;
    /**
     * The width of the Container, setting this will actually modify the scale to achieve the value set
     *
     * @member {number}
     */
    get width() {
        return this.scale.x * this.getLocalBounds().width;
    }
    ;
    set width(value) {
        var width = this.getLocalBounds().width;
        if (width !== 0) {
            this.scale.x = value / width;
        }
        else {
            this.scale.x = 1;
        }
        this._width = value;
    }
    ;
    /**
     * The height of the Container, setting this will actually modify the scale to achieve the value set
     *
     * @member {number}
     */
    get height() {
        return this.scale.y * this.getLocalBounds().height;
    }
    ;
    set height(value) {
        var height = this.getLocalBounds().height;
        if (height !== 0) {
            this.scale.y = value / height;
        }
        else {
            this.scale.y = 1;
        }
        this._height = value;
    }
    ;
    static sortChildren(a, b) {
        if (a.zIndex === b.zIndex) {
            return a._lastSortedIndex - b._lastSortedIndex;
        }
        return a.zIndex - b.zIndex;
    }
}
exports.Container = Container;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/ContextSystem.js":
/*!*************************************************!*\
  !*** ./js-compile/raw-pixi-ts/ContextSystem.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const System_1 = __webpack_require__(/*! ./System */ "./js-compile/raw-pixi-ts/System.js");
const DisplaySettings_1 = __webpack_require__(/*! ./DisplaySettings */ "./js-compile/raw-pixi-ts/DisplaySettings.js");
class ContextSystem extends System_1.System {
    constructor(renderer) {
        super(renderer);
        /**
         * Either 1 or 2 to reflect the WebGL version being used
         * @member {number}
         * @readonly
         */
        this.webGLVersion = 1;
        /**
         * Extensions being used
         * @member {object}
         * @readonly
         * @property {WEBGL_draw_buffers} drawBuffers - WebGL v1 extension
         * @property {WEBGL_depth_texture} depthTexture - WebGL v1 extension
         * @property {OES_texture_float} floatTexture - WebGL v1 extension
         * @property {WEBGL_lose_context} loseContext - WebGL v1 extension
         * @property {OES_vertex_array_object} vertexArrayObject - WebGL v1 extension
         */
        this.extensions = {};
        // Bind functions
        this.handleContextLost = this.handleContextLost.bind(this);
        this.handleContextRestored = this.handleContextRestored.bind(this);
        renderer.view.addEventListener('webglcontextlost', this.handleContextLost, false);
        renderer.view.addEventListener('webglcontextrestored', this.handleContextRestored, false);
    }
    /**
     * `true` if the context is lost
     * @member {boolean}
     * @readonly
     */
    get isLost() {
        return (!this.gl || this.gl.isContextLost());
    }
    ;
    /**
     * Handle the context change event
     * @param {WebGLRenderingContext} gl new webgl context
     */
    contextChange(gl) {
        this.gl = gl;
        // restore a context if it was previously lost
        if (gl.isContextLost() && gl.getExtension('WEBGL_lose_context')) {
            gl.getExtension('WEBGL_lose_context').restoreContext();
        }
    }
    ;
    /**
     * Initialize the context
     *
     * @protected
     * @param {WebGLRenderingContext} gl - WebGL context
     */
    initFromContext(gl) {
        this.gl = gl;
        this.validateContext(gl);
        this.renderer.gl = gl;
        this.renderer.CONTEXT_UID = ContextSystem.CONTEXT_UID++;
        // this.dispatchEvent(Event.getEvent("contextchange"))
        this.renderer.runners.contextChange.run(gl);
    }
    ;
    /**
     * Initialize from context options
     *
     * @protected
     * @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/getContext
     * @param {object} options - context attributes
     */
    initFromOptions(options) {
        var gl = this.createContext(this.renderer.view, options);
        this.initFromContext(gl);
    }
    ;
    /**
     * Helper class to create a WebGL Context
     *
     * @param canvas {HTMLCanvasElement} the canvas element that we will get the context from
     * @param options {object} An options object that gets passed in to the canvas element containing the context attributes
     * @see https://developer.mozilla.org/en/docs/Web/API/HTMLCanvasElement/getContext
     * @return {WebGLRenderingContext} the WebGL context
     */
    createContext(canvas, options) {
        var gl;
        if (DisplaySettings_1.DisplaySettings.PREFER_ENV >= DisplaySettings_1.DisplaySettings.ENV.WEBGL2) {
            gl = canvas.getContext('webgl2', options);
        }
        if (gl) {
            this.webGLVersion = 2;
        }
        else {
            this.webGLVersion = 1;
            gl = canvas.getContext('webgl', options)
                || canvas.getContext('experimental-webgl', options);
            if (!gl) {
                // fail, not able to get a context
                throw new Error('This browser does not support WebGL. Try using the canvas renderer');
            }
        }
        this.gl = gl;
        this.getExtensions();
        return gl;
    }
    ;
    /**
     * Auto-populate the extensions
     *
     * @protected
     */
    getExtensions() {
        // time to set up default extensions that Pixi uses.
        var ref = this;
        var gl = ref.gl;
        if (this.webGLVersion === 1) {
            Object.assign(this.extensions, {
                drawBuffers: gl.getExtension('WEBGL_draw_buffers'),
                depthTexture: gl.getExtension('WEBKIT_WEBGL_depth_texture'),
                floatTexture: gl.getExtension('OES_texture_float'),
                loseContext: gl.getExtension('WEBGL_lose_context'),
                vertexArrayObject: gl.getExtension('OES_vertex_array_object')
                    || gl.getExtension('MOZ_OES_vertex_array_object')
                    || gl.getExtension('WEBKIT_OES_vertex_array_object'),
            });
        }
        // we don't use any specific WebGL 2 ones yet!
    }
    ;
    /**
     * Handles a lost webgl context
     *
     * @protected
     * @param {WebGLContextEvent} event - The context lost event.
     */
    handleContextLost(event) {
        event.preventDefault();
    }
    ;
    /**
     * Handles a restored webgl context
     *
     * @protected
     */
    handleContextRestored() {
        this.renderer.runners.contextChange.run(this.gl);
    }
    ;
    destroy() {
        var view = this.renderer.view;
        // remove listeners
        view.removeEventListener('webglcontextlost', this.handleContextLost);
        view.removeEventListener('webglcontextrestored', this.handleContextRestored);
        this.gl.useProgram(null);
        if (this.extensions.loseContext) {
            this.extensions.loseContext.loseContext();
        }
    }
    ;
    /**
     * Handle the post-render runner event
     *
     * @protected
     */
    postrender() {
        this.gl.flush();
    }
    ;
    /**
     * Validate context
     *
     * @protected
     * @param {WebGLRenderingContext} gl - Render context
     */
    validateContext(gl) {
        var attributes = gl.getContextAttributes();
        // this is going to be fairly simple for now.. but at least we have room to grow!
        if (!attributes.stencil) {
            /* eslint-disable max-len */
            /* eslint-disable no-console */
            console.warn('Provided WebGL context does not have a stencil buffer, masks may not render correctly');
            /* eslint-enable no-console */
            /* eslint-enable max-len */
        }
    }
    ;
}
ContextSystem.CONTEXT_UID = 0;
exports.ContextSystem = ContextSystem;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/CountLimiter.js":
/*!************************************************!*\
  !*** ./js-compile/raw-pixi-ts/CountLimiter.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class CountLimiter {
    constructor(maxItemsPerFrame) {
        /**
             * The maximum number of items that can be prepared each frame.
             * @type {number}
             * @private
             */
        this.maxItemsPerFrame = maxItemsPerFrame;
        /**
         * The number of items that can be prepared in the current frame.
         * @type {number}
         * @private
         */
        this.itemsLeft = 0;
    }
    /**
     * Resets any counting properties to start fresh on a new frame.
     */
    beginFrame() {
        this.itemsLeft = this.maxItemsPerFrame;
    }
    ;
    /**
     * Checks to see if another item can be uploaded. This should only be called once per item.
     * @return {boolean} If the item is allowed to be uploaded.
     */
    allowedToUpload() {
        return this.itemsLeft-- > 0;
    }
    ;
}
exports.CountLimiter = CountLimiter;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/CubeResource.js":
/*!************************************************!*\
  !*** ./js-compile/raw-pixi-ts/CubeResource.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const ArrayResource_1 = __webpack_require__(/*! ./ArrayResource */ "./js-compile/raw-pixi-ts/ArrayResource.js");
const WebGLSettings_1 = __webpack_require__(/*! ./WebGLSettings */ "./js-compile/raw-pixi-ts/WebGLSettings.js");
class CubeResource extends ArrayResource_1.ArrayResource {
    constructor(source, options) {
        super(source, options);
        options = options || {};
        if (this.length !== CubeResource.SIDES) {
            throw new Error(("Invalid length. Got " + (this.length) + ", expected 6"));
        }
        for (var i = 0; i < CubeResource.SIDES; i++) {
            this.items[i].target = WebGLSettings_1.WebGLSettings.TARGETS.TEXTURE_CUBE_MAP_POSITIVE_X + i;
        }
        if (options.autoLoad !== false) {
            this.load();
        }
    }
    /**
     * Add binding
     *
     * @override
     * @param {PIXI.BaseTexture} baseTexture - parent base texture
     */
    bind(baseTexture) {
        super.bind(baseTexture);
        baseTexture.target = WebGLSettings_1.WebGLSettings.TARGETS.TEXTURE_CUBE_MAP;
    }
    ;
    /**
     * Upload the resource
     *
     * @returns {boolean} true is success
     */
    upload(renderer, baseTexture, glTexture) {
        var dirty = this.itemDirtyIds;
        for (var i = 0; i < CubeResource.SIDES; i++) {
            var side = this.items[i];
            if (dirty[i] < side.dirtyId) {
                dirty[i] = side.dirtyId;
                if (side.valid) {
                    side.resource.upload(renderer, side, glTexture);
                }
            }
        }
        return true;
    }
    ;
}
/**
* Number of texture sides to store for CubeResources
*
* @name PIXI.resources.CubeResource.SIDES
* @static
* @member {number}
* @default 6
*/
CubeResource.SIDES = 6;
exports.CubeResource = CubeResource;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/DepthResource.js":
/*!*************************************************!*\
  !*** ./js-compile/raw-pixi-ts/DepthResource.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BufferResource_1 = __webpack_require__(/*! ./BufferResource */ "./js-compile/raw-pixi-ts/BufferResource.js");
class DepthResource extends BufferResource_1.BufferResource {
    constructor(source, options) {
        super(source, options);
    }
    upload(renderer, baseTexture, glTexture) {
        var gl = renderer.gl;
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, baseTexture.premultiplyAlpha);
        if (glTexture.width === baseTexture.width && glTexture.height === baseTexture.height) {
            gl.texSubImage2D(baseTexture.target, 0, 0, 0, baseTexture.width, baseTexture.height, baseTexture.format, baseTexture.type, this.data);
        }
        else {
            glTexture.width = baseTexture.width;
            glTexture.height = baseTexture.height;
            gl.texImage2D(baseTexture.target, 0, gl.DEPTH_COMPONENT16, // Needed for depth to render properly in webgl2.0
            baseTexture.width, baseTexture.height, 0, baseTexture.format, baseTexture.type, this.data);
        }
        return true;
    }
    ;
}
exports.DepthResource = DepthResource;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/DisplacementFilter.js":
/*!******************************************************!*\
  !*** ./js-compile/raw-pixi-ts/DisplacementFilter.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Filter_1 = __webpack_require__(/*! ./Filter */ "./js-compile/raw-pixi-ts/Filter.js");
const Matrix_1 = __webpack_require__(/*! ./Matrix */ "./js-compile/raw-pixi-ts/Matrix.js");
const Point_1 = __webpack_require__(/*! ./Point */ "./js-compile/raw-pixi-ts/Point.js");
class DisplacementFilter extends Filter_1.Filter {
    constructor(sprite, scale = 1) {
        var maskMatrix = new Matrix_1.Matrix();
        sprite.renderable = false;
        super(DisplacementFilter.vertex$4, DisplacementFilter.fragment$5, { mapSampler: sprite._texture, filterMatrix: maskMatrix, scale: { x: 1, y: 1 }, rotation: new Float32Array([1, 0, 0, 1]), });
        this.maskSprite = sprite;
        this.maskMatrix = maskMatrix;
        if (scale === null || scale === undefined) {
            scale = 20;
        }
        /**
         * scaleX, scaleY for displacements
         * @member {PIXI.Point}
         */
        this.scale = new Point_1.Point(scale, scale);
    }
    /**
     * Applies the filter.
     *
     * @param {PIXI.systems.FilterSystem} filterManager - The manager.
     * @param {PIXI.RenderTexture} input - The input target.
     * @param {PIXI.RenderTexture} output - The output target.
     */
    apply(filterManager, input, output) {
        this.uniforms.filterMatrix = filterManager.calculateSpriteMatrix(this.maskMatrix, this.maskSprite);
        this.uniforms.scale.x = this.scale.x;
        this.uniforms.scale.y = this.scale.y;
        // Extract rotation from world transform
        var wt = this.maskSprite.transform.worldTransform;
        var lenX = Math.sqrt((wt.a * wt.a) + (wt.b * wt.b));
        var lenY = Math.sqrt((wt.c * wt.c) + (wt.d * wt.d));
        if (lenX !== 0 && lenY !== 0) {
            this.uniforms.rotation[0] = wt.a / lenX;
            this.uniforms.rotation[1] = wt.b / lenX;
            this.uniforms.rotation[2] = wt.c / lenY;
            this.uniforms.rotation[3] = wt.d / lenY;
        }
        // draw the filter...
        filterManager.applyFilter(this, input, output);
    }
    ;
    /**
     * The texture used for the displacement map. Must be power of 2 sized texture.
     *
     * @member {PIXI.Texture}
     */
    get map() {
        return this.uniforms.mapSampler;
    }
    ;
    set map(value) {
        this.uniforms.mapSampler = value;
    }
    ;
}
DisplacementFilter.fragment$5 = "varying vec2 vFilterCoord;\r\nvarying vec2 vTextureCoord;\r\n\r\nuniform vec2 scale;\r\nuniform mat2 rotation;\r\nuniform sampler2D uSampler;\r\nuniform sampler2D mapSampler;\r\n\r\nuniform highp vec4 inputSize;\r\nuniform vec4 inputClamp;\r\n\r\nvoid main(void)\r\n{\r\n  vec4 map =  texture2D(mapSampler, vFilterCoord);\r\n\r\n  map -= 0.5;\r\n  map.xy = scale * inputSize.zw * (rotation * map.xy);\r\n\r\n  gl_FragColor = texture2D(uSampler, clamp(vec2(vTextureCoord.x + map.x, vTextureCoord.y + map.y), inputClamp.xy, inputClamp.zw));\r\n}\r\n";
DisplacementFilter.vertex$4 = "attribute vec2 aVertexPosition;\r\n\r\nuniform mat3 projectionMatrix;\r\nuniform mat3 filterMatrix;\r\n\r\nvarying vec2 vTextureCoord;\r\nvarying vec2 vFilterCoord;\r\n\r\nuniform vec4 inputSize;\r\nuniform vec4 outputFrame;\r\n\r\nvec4 filterVertexPosition( void )\r\n{\r\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\r\n\r\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\r\n}\r\n\r\nvec2 filterTextureCoord( void )\r\n{\r\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\r\n}\r\n\r\nvoid main(void)\r\n{\r\n\tgl_Position = filterVertexPosition();\r\n\tvTextureCoord = filterTextureCoord();\r\n\tvFilterCoord = ( filterMatrix * vec3( vTextureCoord, 1.0)  ).xy;\r\n}\r\n";
exports.DisplacementFilter = DisplacementFilter;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/DisplayObject.js":
/*!*************************************************!*\
  !*** ./js-compile/raw-pixi-ts/DisplayObject.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const EventDispatcher_1 = __webpack_require__(/*! ./EventDispatcher */ "./js-compile/raw-pixi-ts/EventDispatcher.js");
const Rectangle_1 = __webpack_require__(/*! ./Rectangle */ "./js-compile/raw-pixi-ts/Rectangle.js");
const Matrix_1 = __webpack_require__(/*! ./Matrix */ "./js-compile/raw-pixi-ts/Matrix.js");
const RenderTexture_1 = __webpack_require__(/*! ./RenderTexture */ "./js-compile/raw-pixi-ts/RenderTexture.js");
const BaseTexture_1 = __webpack_require__(/*! ./BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const Texture_1 = __webpack_require__(/*! ./Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const Bounds_1 = __webpack_require__(/*! ./Bounds */ "./js-compile/raw-pixi-ts/Bounds.js");
const Transform_1 = __webpack_require__(/*! ./Transform */ "./js-compile/raw-pixi-ts/Transform.js");
const Point_1 = __webpack_require__(/*! ./Point */ "./js-compile/raw-pixi-ts/Point.js");
const MathSettings_1 = __webpack_require__(/*! ./MathSettings */ "./js-compile/raw-pixi-ts/MathSettings.js");
const DisplaySettings_1 = __webpack_require__(/*! ./DisplaySettings */ "./js-compile/raw-pixi-ts/DisplaySettings.js");
class DisplayObject extends EventDispatcher_1.EventDispatcher {
    constructor() {
        super();
        /*!
 * @pixi/mixin-get-child-by-name - v5.0.0-rc.3
 * Compiled Wed, 10 Apr 2019 01:21:15 UTC
 *
 * @pixi/mixin-get-child-by-name is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
        /**
         * The instance name of the object.
         *
         * @memberof PIXI.DisplayObject#
         * @member {string} name
         */
        this.name = null;
        /**
         *  Flag for if the object is accessible. If true AccessibilityManager will overlay a
         *   shadow div with attributes set
         *
         * @member {boolean}
         * @memberof PIXI.DisplayObject#
         */
        this.accessible = false;
        /**
         * Sets the title attribute of the shadow div
         * If accessibleTitle AND accessibleHint has not been this will default to 'displayObject [tabIndex]'
         *
         * @member {?string}
         * @memberof PIXI.DisplayObject#
         */
        this.accessibleTitle = null;
        /**
         * Sets the aria-label attribute of the shadow div
         *
         * @member {string}
         * @memberof PIXI.DisplayObject#
         */
        this.accessibleHint = null;
        /**
         * @member {number}
         * @memberof PIXI.DisplayObject#
         * @private
         * @todo Needs docs.
         */
        this.tabIndex = 0;
        /**
         * @member {boolean}
         * @memberof PIXI.DisplayObject#
         * @todo Needs docs.
         */
        this._accessibleActive = false;
        /**
         * @member {boolean}
         * @memberof PIXI.DisplayObject#
         * @todo Needs docs.
         */
        this._accessibleDiv = false;
        /**
        * Enable interaction events for the DisplayObject. Touch, pointer and mouse
        * events will not be emitted unless `interactive` is set to `true`.
        *
        * @example
        * const sprite = new PIXI.Sprite(texture);
        * sprite.interactive = true;
        * sprite.on('tap', (event) => {
        *    //handle event
        * });
        * @member {boolean}
        * @memberof PIXI.DisplayObject#
        */
        this.interactive = false;
        /**
         * Determines if the children to the displayObject can be clicked/touched
         * Setting this to false allows PixiJS to bypass a recursive `hitTest` function
         *
         * @member {boolean}
         * @memberof PIXI.Container#
         */
        this.interactiveChildren = true;
        /**
         * Interaction shape. Children will be hit first, then this shape will be checked.
         * Setting this will cause this shape to be checked in hit tests rather than the displayObject's bounds.
         *
         * @example
         * const sprite = new PIXI.Sprite(texture);
         * sprite.interactive = true;
         * sprite.hitArea = new PIXI.Rectangle(0, 0, 100, 100);
         * @member {PIXI.Rectangle|PIXI.Circle|PIXI.Ellipse|PIXI.Polygon|PIXI.RoundedRectangle}
         * @memberof PIXI.DisplayObject#
         */
        this.hitArea = null;
        /**
         * This defines what cursor mode is used when the mouse cursor
         * is hovered over the displayObject.
         *
         * @example
         * const sprite = new PIXI.Sprite(texture);
         * sprite.interactive = true;
         * sprite.cursor = 'wait';
         * @see https://developer.mozilla.org/en/docs/Web/CSS/cursor
         *
         * @member {string}
         * @memberof PIXI.DisplayObject#
         */
        this.cursor = null;
        /**
         * Map of all tracked pointers, by identifier. Use trackedPointers to access.
         *
         * @private
         * @type {Map<number, InteractionTrackingData>}
         */
        this._trackedPointers = undefined;
        this._cacheAsBitmap = false;
        this._cacheData = false;
        // performance increase to avoid using call.. (10x faster)
        this.displayObjectUpdateTransform = this.updateTransform;
        this.tempDisplayObjectParent = null;
        // TODO: need to create Transform from factory
        /**
         * World transform and local transform of this object.
         * This will become read-only later, please do not assign anything there unless you know what are you doing.
         *
         * @member {PIXI.Transform}
         */
        this.transform = new Transform_1.Transform();
        /**
         * The opacity of the object.
         *
         * @member {number}
         */
        this.alpha = 1;
        /**
         * The visibility of the object. If false the object will not be drawn, and
         * the updateTransform function will not be called.
         *
         * Only affects recursive calls from parent. You can ask for bounds or call updateTransform manually.
         *
         * @member {boolean}
         */
        this.visible = true;
        /**
         * Can this object be rendered, if false the object will not be drawn but the updateTransform
         * methods will still be called.
         *
         * Only affects recursive calls from parent. You can ask for bounds manually.
         *
         * @member {boolean}
         */
        this.renderable = true;
        /**
         * The display object container that contains this display object.
         *
         * @member {PIXI.Container}
         * @readonly
         */
        this.parent = null;
        /**
         * The multiplied alpha of the displayObject.
         *
         * @member {number}
         * @readonly
         */
        this.worldAlpha = 1;
        /**
         * Which index in the children array the display component was before the previous zIndex sort.
         * Used by containers to help sort objects with the same zIndex, by using previous array index as the decider.
         *
         * @member {number}
         * @protected
         */
        this._lastSortedIndex = 0;
        /**
         * The zIndex of the displayObject.
         * A higher value will mean it will be rendered on top of other displayObjects within the same container.
         *
         * @member {number}
         * @protected
         */
        this._zIndex = 0;
        /**
         * The area the filter is applied to. This is used as more of an optimization
         * rather than figuring out the dimensions of the displayObject each frame you can set this rectangle.
         *
         * Also works as an interaction mask.
         *
         * @member {?PIXI.Rectangle}
         */
        this.filterArea = null;
        /**
         * Sets the filters for the displayObject.
         * * IMPORTANT: This is a WebGL only feature and will be ignored by the canvas renderer.
         * To remove filters simply set this property to `'null'`.
         *
         * @member {?PIXI.Filter[]}
         */
        this.filters = null;
        this._enabledFilters = null;
        /**
         * The bounds object, this is used to calculate and store the bounds of the displayObject.
         *
         * @member {PIXI.Bounds}
         * @protected
         */
        this._bounds = new Bounds_1.Bounds();
        this._boundsID = 0;
        this._lastBoundsID = -1;
        this._boundsRect = null;
        this._localBoundsRect = null;
        /**
         * The original, cached mask of the object.
         *
         * @member {PIXI.Graphics|PIXI.Sprite}
         * @protected
         */
        this._mask = null;
        /**
         * Fired when this DisplayObject is added to a Container.
         *
         * @event PIXI.DisplayObject#added
         * @param {PIXI.Container} container - The container added to.
         */
        /**
         * Fired when this DisplayObject is removed from a Container.
         *
         * @event PIXI.DisplayObject#removed
         * @param {PIXI.Container} container - The container removed from.
         */
        /**
         * If the object has been destroyed via destroy(). If true, it should not be used.
         *
         * @member {boolean}
         * @protected
         */
        this._destroyed = false;
        /**
         * used to fast check if a sprite is.. a sprite!
         * @member {boolean}
         */
        this.isSprite = false;
    }
    /**
 * Internal set of all active pointers, by identifier
 *
 * @member {Map<number, InteractionTrackingData>}
 * @memberof PIXI.DisplayObject#
 * @private
 */
    get trackedPointers() {
        if (this._trackedPointers === undefined) {
            this._trackedPointers = {};
        }
        return this._trackedPointers;
    }
    /*!
 * @pixi/mixin-get-global-position - v5.0.0-rc.3
 * Compiled Wed, 10 Apr 2019 01:21:15 UTC
 *
 * @pixi/mixin-get-global-position is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
    /**
     * Returns the global position of the displayObject. Does not depend on object scale, rotation and pivot.
     *
     * @method getGlobalPosition
     * @memberof PIXI.DisplayObject#
     * @param {Point} point - The point to write the global value to. If null a new point will be returned
     * @param {boolean} skipUpdate - Setting to true will stop the transforms of the scene graph from
     *  being updated. This means the calculation returned MAY be out of date BUT will give you a
     *  nice performance boost.
     * @return {Point} The updated point.
     */
    getGlobalPosition(point, skipUpdate) {
        if (point === void 0) {
            point = new Point_1.Point();
        }
        if (skipUpdate === void 0) {
            skipUpdate = false;
        }
        if (this.parent) {
            this.parent.toGlobal(this.position, point, skipUpdate);
        }
        else {
            point.x = this.position.x;
            point.y = this.position.y;
        }
        return point;
    }
    ;
    /**
 * If enabled, the mouse cursor use the pointer behavior when hovered over the displayObject if it is interactive
 * Setting this changes the 'cursor' property to `'pointer'`.
 *
 * @example
 * const sprite = new PIXI.Sprite(texture);
 * sprite.interactive = true;
 * sprite.buttonMode = true;
 * @member {boolean}
 * @memberof PIXI.DisplayObject#
 */
    get buttonMode() {
        return this.cursor === 'pointer';
    }
    set buttonMode(value) {
        if (value) {
            this.cursor = 'pointer';
        }
        else if (this.cursor === 'pointer') {
            this.cursor = null;
        }
    }
    /**
     * @protected
     * @member {PIXI.DisplayObject}
     */
    static mixin(source) {
        // in ES8/ES2017, this would be really easy:
        // Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        // get all the enumerable property keys
        var keys = Object.keys(source);
        // loop through properties
        for (var i = 0; i < keys.length; ++i) {
            var propertyName = keys[i];
            // Set the property using the property descriptor - this works for accessors and normal value properties
            Object.defineProperty(DisplayObject.prototype, propertyName, Object.getOwnPropertyDescriptor(source, propertyName));
        }
    }
    ;
    get _tempDisplayObjectParent() {
        if (this.tempDisplayObjectParent === null) {
            this.tempDisplayObjectParent = new DisplayObject();
        }
        return this.tempDisplayObjectParent;
    }
    ;
    /**
     * Updates the object transform for rendering.
     *
     * TODO - Optimization pass!
     */
    updateTransform() {
        this.transform.updateTransform(this.parent.transform);
        // multiply the alphas..
        this.worldAlpha = this.alpha * this.parent.worldAlpha;
        this._bounds.updateID++;
    }
    ;
    /**
     * Recursively updates transform of all objects from the root to this one
     * internal function for toLocal()
     */
    _recursivePostUpdateTransform() {
        if (this.parent) {
            this.parent._recursivePostUpdateTransform();
            this.transform.updateTransform(this.parent.transform);
        }
        else {
            this.transform.updateTransform(this._tempDisplayObjectParent.transform);
        }
    }
    ;
    /**
     * Retrieves the bounds of the displayObject as a rectangle object.
     *
     * @param {boolean} [skipUpdate] - Setting to `true` will stop the transforms of the scene graph from
     *  being updated. This means the calculation returned MAY be out of date BUT will give you a
     *  nice performance boost.
     * @param {PIXI.Rectangle} [rect] - Optional rectangle to store the result of the bounds calculation.
     * @return {PIXI.Rectangle} The rectangular bounding area.
     */
    getBounds(skipUpdate = true, rect = null) {
        if (!skipUpdate) {
            if (!this.parent) {
                this.parent = this._tempDisplayObjectParent;
                this.updateTransform();
                this.parent = null;
            }
            else {
                this._recursivePostUpdateTransform();
                this.updateTransform();
            }
        }
        if (this._boundsID !== this._lastBoundsID) {
            this.calculateBounds();
        }
        if (!rect) {
            if (!this._boundsRect) {
                this._boundsRect = new Rectangle_1.Rectangle();
            }
            rect = this._boundsRect;
        }
        return this._bounds.getRectangle(rect);
    }
    ;
    calculateBounds() {
    }
    /**
     * Retrieves the local bounds of the displayObject as a rectangle object.
     *
     * @param {PIXI.Rectangle} [rect] - Optional rectangle to store the result of the bounds calculation.
     * @return {PIXI.Rectangle} The rectangular bounding area.
     */
    getLocalBounds(rect = null) {
        var transformRef = this.transform;
        var parentRef = this.parent;
        this.parent = null;
        this.transform = this._tempDisplayObjectParent.transform;
        if (!rect) {
            if (!this._localBoundsRect) {
                this._localBoundsRect = new Rectangle_1.Rectangle();
            }
            rect = this._localBoundsRect;
        }
        var bounds = this.getBounds(false, rect);
        this.parent = parentRef;
        this.transform = transformRef;
        return bounds;
    }
    ;
    /**
     * Calculates the global position of the display object.
     *
     * @param {PIXI.IPoint} position - The world origin to calculate from.
     * @param {PIXI.IPoint} [point] - A Point object in which to store the value, optional
     *  (otherwise will create a new Point).
     * @param {boolean} [skipUpdate=false] - Should we skip the update transform.
     * @return {PIXI.IPoint} A point object representing the position of this object.
     */
    toGlobal(position, point, skipUpdate) {
        if (skipUpdate === void 0) {
            skipUpdate = false;
        }
        if (!skipUpdate) {
            this._recursivePostUpdateTransform();
            // this parent check is for just in case the item is a root object.
            // If it is we need to give it a temporary parent so that displayObjectUpdateTransform works correctly
            // this is mainly to avoid a parent check in the main loop. Every little helps for performance :)
            if (!this.parent) {
                this.parent = this._tempDisplayObjectParent;
                this.displayObjectUpdateTransform();
                this.parent = null;
            }
            else {
                this.displayObjectUpdateTransform();
            }
        }
        // don't need to update the lot
        return this.worldTransform.apply(position, point);
    }
    ;
    /**
     * Calculates the local position of the display object relative to another point.
     *
     * @param {PIXI.IPoint} position - The world origin to calculate from.
     * @param {PIXI.DisplayObject} [from] - The DisplayObject to calculate the global position from.
     * @param {PIXI.IPoint} [point] - A Point object in which to store the value, optional
     *  (otherwise will create a new Point).
     * @param {boolean} [skipUpdate=false] - Should we skip the update transform
     * @return {PIXI.IPoint} A point object representing the position of this object
     */
    toLocal(position, from, point, skipUpdate) {
        if (from) {
            position = from.toGlobal(position, point, skipUpdate);
        }
        if (!skipUpdate) {
            this._recursivePostUpdateTransform();
            // this parent check is for just in case the item is a root object.
            // If it is we need to give it a temporary parent so that displayObjectUpdateTransform works correctly
            // this is mainly to avoid a parent check in the main loop. Every little helps for performance :)
            if (!this.parent) {
                this.parent = this._tempDisplayObjectParent;
                this.displayObjectUpdateTransform();
                this.parent = null;
            }
            else {
                this.displayObjectUpdateTransform();
            }
        }
        // simply apply the matrix..
        return this.worldTransform.applyInverse(position, point);
    }
    ;
    /**
     * Renders the object using the WebGL renderer.
     *
     * @param {PIXI.Renderer} renderer - The renderer.
     */
    render(renderer) {
        // OVERWRITE;
    }
    ;
    /**
     * Set the parent Container of this DisplayObject.
     *
     * @param {PIXI.Container} container - The Container to add this DisplayObject to.
     * @return {PIXI.Container} The Container that this DisplayObject was added to.
     */
    setParent(container) {
        if (!container || !container.addChild) {
            throw new Error('setParent: Argument must be a Container');
        }
        container.addChild(this);
        return container;
    }
    ;
    /**
     * Convenience function to set the position, scale, skew and pivot at once.
     *
     * @param {number} [x=0] - The X position
     * @param {number} [y=0] - The Y position
     * @param {number} [scaleX=1] - The X scale value
     * @param {number} [scaleY=1] - The Y scale value
     * @param {number} [rotation=0] - The rotation
     * @param {number} [skewX=0] - The X skew value
     * @param {number} [skewY=0] - The Y skew value
     * @param {number} [pivotX=0] - The X pivot value
     * @param {number} [pivotY=0] - The Y pivot value
     * @return {PIXI.DisplayObject} The DisplayObject instance
     */
    setTransform(x, y, scaleX, scaleY, rotation, skewX, skewY, pivotX, pivotY) {
        if (x === void 0) {
            x = 0;
        }
        if (y === void 0) {
            y = 0;
        }
        if (scaleX === void 0) {
            scaleX = 1;
        }
        if (scaleY === void 0) {
            scaleY = 1;
        }
        if (rotation === void 0) {
            rotation = 0;
        }
        if (skewX === void 0) {
            skewX = 0;
        }
        if (skewY === void 0) {
            skewY = 0;
        }
        if (pivotX === void 0) {
            pivotX = 0;
        }
        if (pivotY === void 0) {
            pivotY = 0;
        }
        this.position.x = x;
        this.position.y = y;
        this.scale.x = !scaleX ? 1 : scaleX;
        this.scale.y = !scaleY ? 1 : scaleY;
        this.rotation = rotation;
        this.skew.x = skewX;
        this.skew.y = skewY;
        this.pivot.x = pivotX;
        this.pivot.y = pivotY;
        return this;
    }
    ;
    /**
     * Base destroy method for generic display objects. This will automatically
     * remove the display object from its parent Container as well as remove
     * all current event listeners and internal references. Do not use a DisplayObject
     * after calling `destroy()`.
     *
     */
    destroy(options = null) {
        // this.removeAllListeners();
        if (this.parent) {
            this.parent.removeChild(this);
        }
        this.transform = null;
        this.parent = null;
        this._bounds = null;
        this._currentBounds = null;
        this._mask = null;
        this.filterArea = null;
        this.interactive = false;
        this.interactiveChildren = false;
        this._destroyed = true;
    }
    ;
    /**
     * The position of the displayObject on the x axis relative to the local coordinates of the parent.
     * An alias to position.x
     *
     * @member {number}
     */
    get x() {
        return this.position.x;
    }
    ;
    set x(value) {
        this.transform.position.x = value;
    }
    ;
    /**
     * The position of the displayObject on the y axis relative to the local coordinates of the parent.
     * An alias to position.y
     *
     * @member {number}
     */
    get y() {
        return this.position.y;
    }
    ;
    set y(value) {
        this.transform.position.y = value;
    }
    ;
    /**
     * Current transform of the object based on world (parent) factors.
     *
     * @member {PIXI.Matrix}
     * @readonly
     */
    get worldTransform() {
        return this.transform.worldTransform;
    }
    ;
    /**
     * Current transform of the object based on local factors: position, scale, other stuff.
     *
     * @member {PIXI.Matrix}
     * @readonly
     */
    get localTransform() {
        return this.transform.localTransform;
    }
    ;
    /**
     * The coordinate of the object relative to the local coordinates of the parent.
     * Assignment by value since pixi-v4.
     *
     * @member {PIXI.IPoint}
     */
    get position() {
        return this.transform.position;
    }
    ;
    set position(value) {
        this.transform.position.copyFrom(value);
    }
    ;
    /**
     * The scale factor of the object.
     * Assignment by value since pixi-v4.
     *
     * @member {PIXI.IPoint}
     */
    get scale() {
        return this.transform.scale;
    }
    ;
    set scale(value) {
        this.transform.scale.copyFrom(value);
    }
    ;
    /**
     * The pivot point of the displayObject that it rotates around.
     * Assignment by value since pixi-v4.
     *
     * @member {PIXI.IPoint}
     */
    get pivot() {
        return this.transform.pivot;
    }
    ;
    set pivot(value) {
        this.transform.pivot.copyFrom(value);
    }
    ;
    /**
     * The skew factor for the object in radians.
     * Assignment by value since pixi-v4.
     *
     * @member {PIXI.ObservablePoint}
     */
    get skew() {
        return this.transform.skew;
    }
    ;
    set skew(value) {
        this.transform.skew.copyFrom(value);
    }
    ;
    /**
     * The rotation of the object in radians.
     * 'rotation' and 'angle' have the same effect on a display object; rotation is in radians, angle is in degrees.
     *
     * @member {number}
     */
    get rotation() {
        return this.transform.rotation;
    }
    ;
    set rotation(value) {
        this.transform.rotation = value;
    }
    ;
    /**
     * The angle of the object in degrees.
     * 'rotation' and 'angle' have the same effect on a display object; rotation is in radians, angle is in degrees.
     *
     * @member {number}
     */
    get angle() {
        return this.transform.rotation * MathSettings_1.MathSettings.RAD_TO_DEG;
    }
    ;
    set angle(value) {
        this.transform.rotation = value * MathSettings_1.MathSettings.DEG_TO_RAD;
    }
    ;
    /**
     * The zIndex of the displayObject.
     * If a container has the sortableChildren property set to true, children will be automatically
     * sorted by zIndex value; a higher value will mean it will be moved towards the end of the array,
     * and thus rendered on top of other displayObjects within the same container.
     *
     * @member {number}
     */
    get zIndex() {
        return this._zIndex;
    }
    ;
    set zIndex(value) {
        this._zIndex = value;
        if (this.parent) {
            this.parent.sortDirty = true;
        }
    }
    ;
    /**
     * Indicates if the object is globally visible.
     *
     * @member {boolean}
     * @readonly
     */
    get worldVisible() {
        var item = this;
        do {
            if (!item.visible) {
                return false;
            }
            item = item.parent;
        } while (item);
        return true;
    }
    ;
    /**
     * Sets a mask for the displayObject. A mask is an object that limits the visibility of an
     * object to the shape of the mask applied to it. In PixiJS a regular mask must be a
     * {@link PIXI.Graphics} or a {@link PIXI.Sprite} object. This allows for much faster masking in canvas as it
     * utilities shape clipping. To remove a mask, set this property to `null`.
     *
     * For sprite mask both alpha and red channel are used. Black mask is the same as transparent mask.
     * @example
     * const graphics = new PIXI.Graphics();
     * graphics.beginFill(0xFF3300);
     * graphics.drawRect(50, 250, 100, 100);
     * graphics.endFill();
     *
     * const sprite = new PIXI.Sprite(texture);
     * sprite.mask = graphics;
     * @todo At the moment, PIXI.CanvasRenderer doesn't support PIXI.Sprite as mask.
     *
     * @member {PIXI.Graphics|PIXI.Sprite}
     */
    get mask() {
        return this._mask;
    }
    ;
    set mask(value) {
        if (this._mask) {
            this._mask.renderable = true;
            this._mask.isMask = false;
        }
        this._mask = value;
        if (this._mask) {
            this._mask.renderable = false;
            this._mask.isMask = true;
        }
    }
    ;
    /**
             * Set this to true if you want this display object to be cached as a bitmap.
             * This basically takes a snap shot of the display object as it is at that moment. It can
             * provide a performance benefit for complex static displayObjects.
             * To remove simply set this property to `false`
             *
             * IMPORTANT GOTCHA - Make sure that all your textures are preloaded BEFORE setting this property to true
             * as it will take a snapshot of what is currently there. If the textures have not loaded then they will not appear.
             *
             * @member {boolean}
             * @memberof PIXI.DisplayObject#
             */
    get cacheAsBitmap() {
        return this._cacheAsBitmap;
    }
    set cacheAsBitmap(value) {
        if (this._cacheAsBitmap === value) {
            return;
        }
        this._cacheAsBitmap = value;
        var data;
        if (value) {
            if (!this._cacheData) {
                this._cacheData = new CacheData();
            }
            data = this._cacheData;
            data.originalRender = this.render;
            data.originalRenderCanvas = this.renderCanvas;
            data.originalUpdateTransform = this.updateTransform;
            data.originalCalculateBounds = this.calculateBounds;
            data.originalGetLocalBounds = this.getLocalBounds;
            data.originalDestroy = this.destroy;
            data.originalContainsPoint = this.containsPoint;
            data.originalMask = this._mask;
            data.originalFilterArea = this.filterArea;
            this.render = this._renderCached;
            this.renderCanvas = this._renderCachedCanvas;
            this.destroy = this._cacheAsBitmapDestroy;
        }
        else {
            data = this._cacheData;
            if (data.sprite) {
                this._destroyCachedDisplayObject();
            }
            this.render = data.originalRender;
            this.renderCanvas = data.originalRenderCanvas;
            this.calculateBounds = data.originalCalculateBounds;
            this.getLocalBounds = data.originalGetLocalBounds;
            this.destroy = data.originalDestroy;
            this.updateTransform = data.originalUpdateTransform;
            this.containsPoint = data.originalContainsPoint;
            this._mask = data.originalMask;
            this.filterArea = data.originalFilterArea;
        }
    }
    containsPoint(point) {
        return false;
    }
    /**
     * Renders a cached version of the sprite with WebGL
     *
     * @private
     * @function _renderCached
     * @memberof PIXI.DisplayObject#
     * @param {PIXI.Renderer} renderer - the WebGL renderer
     */
    _renderCached(renderer) {
        if (!this.visible || this.worldAlpha <= 0 || !this.renderable) {
            return;
        }
        this._initCachedDisplayObject(renderer);
        this._cacheData.sprite.transform._worldID = this.transform._worldID;
        this._cacheData.sprite.worldAlpha = this.worldAlpha;
        this._cacheData.sprite._render(renderer);
    }
    /**
     * Prepares the WebGL renderer to cache the sprite
     *
     * @private
     * @function _initCachedDisplayObject
     * @memberof PIXI.DisplayObject#
     * @param {PIXI.Renderer} renderer - the WebGL renderer
     */
    _initCachedDisplayObject(renderer) {
        if (this._cacheData && this._cacheData.sprite) {
            return;
        }
        // make sure alpha is set to 1 otherwise it will get rendered as invisible!
        var cacheAlpha = this.alpha;
        this.alpha = 1;
        // first we flush anything left in the renderer (otherwise it would get rendered to the cached texture)
        renderer.batch.flush();
        // this.filters= [];
        // next we find the dimensions of the untransformed object
        // this function also calls updatetransform on all its children as part of the measuring.
        // This means we don't need to update the transform again in this function
        // TODO pass an object to clone too? saves having to create a new one each time!
        var bounds = this.getLocalBounds().clone();
        // add some padding!
        if (this.filters) {
            var padding = this.filters[0].padding;
            bounds.pad(padding);
        }
        bounds.ceil(DisplaySettings_1.DisplaySettings.RESOLUTION);
        // for now we cache the current renderTarget that the WebGL renderer is currently using.
        // this could be more elegant..
        var cachedRenderTarget = renderer._activeRenderTarget;
        // We also store the filter stack - I will definitely look to change how this works a little later down the line.
        // const stack = renderer.filterManager.filterStack;
        // this renderTexture will be used to store the cached DisplayObject
        var renderTexture = RenderTexture_1.RenderTexture.create(bounds.width, bounds.height);
        var textureCacheId = "cacheAsBitmap_" + (MathSettings_1.MathSettings.uid());
        this._cacheData.textureCacheId = textureCacheId;
        BaseTexture_1.BaseTexture.addToCache(renderTexture.baseTexture, textureCacheId);
        Texture_1.Texture.addToCache(renderTexture, textureCacheId);
        // need to set //
        var m = DisplayObject._tempMatrix;
        m.tx = -bounds.x;
        m.ty = -bounds.y;
        // reset
        this.transform.worldTransform.identity();
        // set all properties to there original so we can render to a texture
        this.render = this._cacheData.originalRender;
        renderer.render(this, renderTexture, true, m, true);
        // now restore the state be setting the new properties
        renderer.renderTexture.bind(cachedRenderTarget);
        // renderer.filterManager.filterStack = stack;
        this.render = this._renderCached;
        // the rest is the same as for Canvas
        this.updateTransform = this.displayObjectUpdateTransform;
        this.calculateBounds = this._calculateCachedBounds;
        this.getLocalBounds = this._getCachedLocalBounds;
        this._mask = null;
        this.filterArea = null;
        // create our cached sprite
        var cachedSprite; // = new Sprite(renderTexture);
        cachedSprite.transform.worldTransform = this.transform.worldTransform;
        cachedSprite.anchor.x = -(bounds.x / bounds.width);
        cachedSprite.anchor.y = -(bounds.y / bounds.height);
        cachedSprite.alpha = cacheAlpha;
        cachedSprite._bounds = this._bounds;
        this._cacheData.sprite = cachedSprite;
        this.transform._parentID = -1;
        // restore the transform of the cached sprite to avoid the nasty flicker..
        if (!this.parent) {
            this.parent = renderer._tempDisplayObjectParent;
            this.updateTransform();
            this.parent = null;
        }
        else {
            this.updateTransform();
        }
        // map the hit test..
        this.containsPoint = cachedSprite.containsPoint.bind(cachedSprite);
    }
    ;
    /**
 * Renders a cached version of the sprite with canvas
 *
 * @private
 * @function _renderCachedCanvas
 * @memberof PIXI.DisplayObject#
 * @param {PIXI.Renderer} renderer - the WebGL renderer
 */
    _renderCachedCanvas(renderer) {
        if (!this.visible || this.worldAlpha <= 0 || !this.renderable) {
            return;
        }
        this._initCachedDisplayObjectCanvas(renderer);
        this._cacheData.sprite.worldAlpha = this.worldAlpha;
        this._cacheData.sprite._renderCanvas(renderer);
    }
    ;
    // TODO this can be the same as the WebGL version.. will need to do a little tweaking first though..
    /**
     * Prepares the Canvas renderer to cache the sprite
     *
     * @private
     * @function _initCachedDisplayObjectCanvas
     * @memberof PIXI.DisplayObject#
     * @param {PIXI.Renderer} renderer - the WebGL renderer
     */
    _initCachedDisplayObjectCanvas(renderer) {
        if (this._cacheData && this._cacheData.sprite) {
            return;
        }
        // get bounds actually transforms the object for us already!
        var bounds = this.getLocalBounds();
        var cacheAlpha = this.alpha;
        this.alpha = 1;
        var cachedRenderTarget = renderer.context;
        bounds.ceil(DisplaySettings_1.DisplaySettings.RESOLUTION);
        var renderTexture = RenderTexture_1.RenderTexture.create(bounds.width, bounds.height);
        var textureCacheId = "cacheAsBitmap_" + (MathSettings_1.MathSettings.uid());
        this._cacheData.textureCacheId = textureCacheId;
        BaseTexture_1.BaseTexture.addToCache(renderTexture.baseTexture, textureCacheId);
        Texture_1.Texture.addToCache(renderTexture, textureCacheId);
        // need to set //
        var m = DisplayObject._tempMatrix;
        this.transform.localTransform.copyTo(m);
        m.invert();
        m.tx -= bounds.x;
        m.ty -= bounds.y;
        // m.append(this.transform.worldTransform.)
        // set all properties to there original so we can render to a texture
        this.renderCanvas = this._cacheData.originalRenderCanvas;
        // renderTexture.render(this, m, true);
        renderer.render(this, renderTexture, true, m, false);
        // now restore the state be setting the new properties
        renderer.context = cachedRenderTarget;
        this.renderCanvas = this._renderCachedCanvas;
        // the rest is the same as for WebGL
        this.updateTransform = this.displayObjectUpdateTransform;
        this.calculateBounds = this._calculateCachedBounds;
        this.getLocalBounds = this._getCachedLocalBounds;
        this._mask = null;
        this.filterArea = null;
        // create our cached sprite
        var cachedSprite; //= new Sprite(renderTexture);
        cachedSprite.transform.worldTransform = this.transform.worldTransform;
        cachedSprite.anchor.x = -(bounds.x / bounds.width);
        cachedSprite.anchor.y = -(bounds.y / bounds.height);
        cachedSprite.alpha = cacheAlpha;
        cachedSprite._bounds = this._bounds;
        this._cacheData.sprite = cachedSprite;
        this.transform._parentID = -1;
        // restore the transform of the cached sprite to avoid the nasty flicker..
        if (!this.parent) {
            this.parent = renderer._tempDisplayObjectParent;
            this.updateTransform();
            this.parent = null;
        }
        else {
            this.updateTransform();
        }
        // map the hit test..
        this.containsPoint = cachedSprite.containsPoint.bind(cachedSprite);
    }
    ;
    renderCanvas(renderer) {
    }
    /**
     * Calculates the bounds of the cached sprite
     *
     * @private
     */
    _calculateCachedBounds() {
        this._bounds.clear();
        this._cacheData.sprite.transform._worldID = this.transform._worldID;
        this._cacheData.sprite._calculateBounds();
        this._lastBoundsID = this._boundsID;
    }
    ;
    /**
     * Gets the bounds of the cached sprite.
     *
     * @private
     * @return {Rectangle} The local bounds.
     */
    _getCachedLocalBounds() {
        return this._cacheData.sprite.getLocalBounds();
    }
    ;
    /**
     * Destroys the cached sprite.
     *
     * @private
     */
    _destroyCachedDisplayObject() {
        this._cacheData.sprite._texture.destroy(true);
        this._cacheData.sprite = null;
        BaseTexture_1.BaseTexture.removeFromCache(this._cacheData.textureCacheId);
        Texture_1.Texture.removeFromCache(this._cacheData.textureCacheId);
        this._cacheData.textureCacheId = null;
    }
    ;
    /**
 * Destroys the cached object.
 *
 * @private
 * @param {object|boolean} [options] - Options parameter. A boolean will act as if all options
 *  have been set to that value.
 *  Used when destroying containers, see the Container.destroy method.
 */
    _cacheAsBitmapDestroy(options) {
        this.cacheAsBitmap = false;
        this.destroy(options);
    }
    ;
}
DisplayObject._tempMatrix = new Matrix_1.Matrix();
exports.DisplayObject = DisplayObject;
// figured theres no point adding ALL the extra variables to prototype.
// this model can hold the information needed. This can also be generated on demand as
// most objects are not cached as bitmaps.
/**
 * @class
 * @ignore
 */
class CacheData {
    constructor() {
        this.textureCacheId = null;
        this.originalRender = null;
        this.originalRenderCanvas = null;
        this.originalCalculateBounds = null;
        this.originalGetLocalBounds = null;
        this.originalUpdateTransform = null;
        this.originalHitTest = null;
        this.originalDestroy = null;
        this.originalMask = null;
        this.originalFilterArea = null;
        this.sprite = null;
    }
}
;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/DisplaySettings.js":
/*!***************************************************!*\
  !*** ./js-compile/raw-pixi-ts/DisplaySettings.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class DisplaySettings {
}
DisplaySettings.SORTABLE_CHILDREN = false;
DisplaySettings.CREATE_IMAGE_BITMAP = true;
DisplaySettings.RENDERER_TYPE = {
    UNKNOWN: 0,
    WEBGL: 1,
    CANVAS: 2,
};
DisplaySettings.ENV = {
    WEBGL_LEGACY: 0,
    WEBGL: 1,
    WEBGL2: 2,
};
DisplaySettings.RESOLUTION = 1;
DisplaySettings.SCALE_MODE = 1;
DisplaySettings.ROUND_PIXELS = false;
DisplaySettings.PREFER_ENV = DisplaySettings.ENV.WEBGL;
exports.DisplaySettings = DisplaySettings;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/DrawModeSettings.js":
/*!****************************************************!*\
  !*** ./js-compile/raw-pixi-ts/DrawModeSettings.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class DrawModeSettings {
}
/**
* Various webgl draw modes. These can be used to specify which GL drawMode to use
* under certain situations and renderers.
*
* @memberof PIXI
* @static
* @name DRAW_MODES
* @enum {number}
* @property {number} POINTS
* @property {number} LINES
* @property {number} LINE_LOOP
* @property {number} LINE_STRIP
* @property {number} TRIANGLES
* @property {number} TRIANGLE_STRIP
* @property {number} TRIANGLE_FAN
*/
DrawModeSettings.DRAW_MODES = {
    POINTS: 0,
    LINES: 1,
    LINE_LOOP: 2,
    LINE_STRIP: 3,
    TRIANGLES: 4,
    TRIANGLE_STRIP: 5,
    TRIANGLE_FAN: 6,
};
exports.DrawModeSettings = DrawModeSettings;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/Ellipse.js":
/*!*******************************************!*\
  !*** ./js-compile/raw-pixi-ts/Ellipse.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Rectangle_1 = __webpack_require__(/*! ./Rectangle */ "./js-compile/raw-pixi-ts/Rectangle.js");
const ShapeSettings_1 = __webpack_require__(/*! ./ShapeSettings */ "./js-compile/raw-pixi-ts/ShapeSettings.js");
class Ellipse {
    constructor(x = 0, y = 0, halfWidth = 0, halfHeight = 0) {
        if (x === void 0) {
            x = 0;
        }
        if (y === void 0) {
            y = 0;
        }
        if (halfWidth === void 0) {
            halfWidth = 0;
        }
        if (halfHeight === void 0) {
            halfHeight = 0;
        }
        /**
         * @member {number}
         * @default 0
         */
        this.x = x;
        /**
         * @member {number}
         * @default 0
         */
        this.y = y;
        /**
         * @member {number}
         * @default 0
         */
        this.width = halfWidth;
        /**
         * @member {number}
         * @default 0
         */
        this.height = halfHeight;
        /**
         * The type of the object, mainly used to avoid `instanceof` checks
         *
         * @member {number}
         * @readOnly
         * @default PIXI.SHAPES.ELIP
         * @see PIXI.SHAPES
         */
        this.type = ShapeSettings_1.ShapeSettings.SHAPES.ELIP;
    }
    /**
     * Creates a clone of this Ellipse instance
     *
     * @return {PIXI.Ellipse} a copy of the ellipse
     */
    clone() {
        return new Ellipse(this.x, this.y, this.width, this.height);
    }
    ;
    /**
     * Checks whether the x and y coordinates given are contained within this ellipse
     *
     * @param {number} x - The X coordinate of the point to test
     * @param {number} y - The Y coordinate of the point to test
     * @return {boolean} Whether the x/y coords are within this ellipse
     */
    contains(x, y) {
        if (this.width <= 0 || this.height <= 0) {
            return false;
        }
        // normalize the coords to an ellipse with center 0,0
        var normx = ((x - this.x) / this.width);
        var normy = ((y - this.y) / this.height);
        normx *= normx;
        normy *= normy;
        return (normx + normy <= 1);
    }
    ;
    /**
     * Returns the framing rectangle of the ellipse as a Rectangle object
     *
     * @return {PIXI.Rectangle} the framing rectangle
     */
    getBounds() {
        return new Rectangle_1.Rectangle(this.x - this.width, this.y - this.height, this.width, this.height);
    }
    ;
}
exports.Ellipse = Ellipse;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/Event.js":
/*!*****************************************!*\
  !*** ./js-compile/raw-pixi-ts/Event.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const FlashBaseObject_1 = __webpack_require__(/*! ./FlashBaseObject */ "./js-compile/raw-pixi-ts/FlashBaseObject.js");
class Event extends FlashBaseObject_1.FlashBaseObject {
    constructor(type, bubble = true, cancelable = true) {
        super();
        this.reset(type, bubble, cancelable);
    }
    get currentTarget() {
        return this._currentTarget;
    }
    setCurrentTarget(value) {
        this._currentTarget = value;
    }
    get type() {
        return this._type;
    }
    get cancelable() {
        return this._cancelable;
    }
    get bubbles() {
        return this._bubbles;
    }
    get eventPhase() {
        return this._eventPhase;
    }
    clone() {
        return Event.getEvent(this._type, this._bubbles, this._cancelable);
    }
    reset(type, bubble = true, cancelable = true) {
        this._type = type;
        this._bubbles = bubble;
        this._cancelable = cancelable;
    }
    static getEvent(type, bubble = true, cancelable = true) {
        if (Event.EventCache.length) {
            let te = Event.EventCache[Event.EventCache.length - 1];
            Event.EventCache.length -= 1;
            te.reset(type, bubble, cancelable);
            return te;
        }
        return new Event(type, bubble, cancelable);
    }
    destructor() {
        this._currentTarget = null;
        let index = Event.EventCache.indexOf(this);
        if (index < 0) {
            Event.EventCache.push(this);
        }
    }
    get isDisposable() {
        return true;
    }
    stopPropagation() {
    }
    stopImmediatePropagation() {
    }
    preventDefault() {
    }
}
Event.ADDED_TO_STAGE = "addedToStage";
Event.ADDED = "added";
Event.ENTER_FRAME = "enterFrame";
Event.EXIT_FRAME = "exitFrame";
Event.FRAME_CONSTRUCTED = "frameConstructed";
Event.REMOVED = "removed";
Event.REMOVED_FROM_STAGE = "removedFromStage";
Event.RENDER = "render";
Event.COMPLETE = "complete";
Event.INIT = "init";
Event.OPEN = "open";
Event.UNLOAD = "unload";
Event.CLEAR = "clear";
Event.SOUND_COMPLETE = "soundComplete";
Event.SOUND_STARTED = "soundStarted";
Event.ACTIVATE = "activate";
Event.DEACTIVATE = "desactivate";
Event.RESIZE = "resize";
Event.CHANGE = "change";
Event.EventCache = [];
exports.Event = Event;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/EventDispatcher.js":
/*!***************************************************!*\
  !*** ./js-compile/raw-pixi-ts/EventDispatcher.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const FlashBaseObject_1 = __webpack_require__(/*! ./FlashBaseObject */ "./js-compile/raw-pixi-ts/FlashBaseObject.js");
class EventDispatcher extends FlashBaseObject_1.FlashBaseObject {
    constructor(target = null) {
        super();
        this.registeredListeners = {};
    }
    removeListeners() {
        for (var i in this.registeredListeners) {
            var methods = this.registeredListeners[i];
            while (methods.length) {
                let ms = methods.shift();
                ms.destructor();
            }
            delete this.registeredListeners[i];
        }
        this.registeredListeners = {};
    }
    destructor() {
        super.destructor();
        this.removeListeners();
    }
    willTrigger(type) {
        if (this.registeredListeners[type] != null) {
            var methods = this.registeredListeners[type];
            if (methods && methods.length) {
                return true;
            }
            return false;
        }
        return false;
    }
    removeEventListener(type, listener, useCapture = false) {
        if (this.registeredListeners[type] != null) {
            var methods = this.registeredListeners[type];
            if (methods && methods.length) {
                for (var i = 0; i < methods.length; i++) {
                    if (methods[i].objectFunction == listener) {
                        methods[i].destructor();
                        methods.splice(i, 1);
                    }
                }
            }
            if (!methods.length) {
                delete this.registeredListeners[type];
            }
        }
    }
    hasEventListener(type) {
        if (this.registeredListeners[type] != null) {
            var methods = this.registeredListeners[type];
            if (methods && methods.length) {
                return true;
            }
            return false;
        }
        return false;
    }
    dispatchEvent(event) {
        if (this.registeredListeners[event.type] != null) {
            event.setCurrentTarget(this);
            var methods = this.registeredListeners[event.type];
            if (methods && methods.length) {
                let methodcopy = methods.concat();
                methodcopy = methodcopy.sort(this.getMethodPriority);
                while (methodcopy.length) {
                    var method = methodcopy.shift();
                    if (method.eventType != event.type) {
                        continue;
                    }
                    if (method) {
                        this.trigger(method, event);
                    }
                }
            }
        }
        if (event.isDisposable) {
            event.destructor();
        }
        return false;
    }
    addEventListener(type, listener, useCapture = false, priority = 0, useWeakReference = false, scope = null) {
        if (this.isRegistered(type, listener)) {
            return;
        }
        if (!this.registeredListeners[type]) {
            this.registeredListeners[type] = [];
        }
        var methods = this.registeredListeners[type];
        var methodScope = MethodScope.getMethodScope();
        methodScope.eventType = type;
        methodScope.parentDispatcher = this;
        methodScope.objectFunction = listener;
        methodScope.scope = scope;
        methodScope.priority = priority;
        methods.push(methodScope);
    }
    trigger(method, event) {
        if (method.objectFunction) {
            method.objectFunction.call(method.scope, event);
        }
    }
    getMethodPriority(method1, method2) {
        if (method1.priority > method2.priority) {
            return 1;
        }
        return -1;
    }
    isRegistered(type, listener) {
        if (!this.registeredListeners[type]) {
            return false;
        }
        var methods = this.registeredListeners[type];
        for (var i = 0; i < methods.length; i++) {
            if (methods[i].objectFunction == listener) {
                return true;
            }
        }
        return false;
    }
}
exports.EventDispatcher = EventDispatcher;
class MethodScope extends FlashBaseObject_1.FlashBaseObject {
    constructor() {
        super();
        this.reset();
    }
    reset() {
        this.objectFunction = null;
        this.scope = null;
        this.parentDispatcher = null;
        this.priority = 0;
        this.eventType = null;
    }
    static getMethodScope() {
        if (MethodScope.MethodScopeCache.length) {
            let te = MethodScope.MethodScopeCache[MethodScope.MethodScopeCache.length - 1];
            MethodScope.MethodScopeCache.length -= 1;
            te.reset();
            return te;
        }
        return new MethodScope();
    }
    destructor() {
        this.objectFunction = null;
        this.scope = null;
        this.parentDispatcher = null;
        let index = MethodScope.MethodScopeCache.indexOf(this);
        if (index < 0) {
            MethodScope.MethodScopeCache.unshift(this);
        }
    }
}
MethodScope.MethodScopeCache = [];


/***/ }),

/***/ "./js-compile/raw-pixi-ts/Extract.js":
/*!*******************************************!*\
  !*** ./js-compile/raw-pixi-ts/Extract.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const RenderTexture_1 = __webpack_require__(/*! ./RenderTexture */ "./js-compile/raw-pixi-ts/RenderTexture.js");
const Rectangle_1 = __webpack_require__(/*! ./Rectangle */ "./js-compile/raw-pixi-ts/Rectangle.js");
const CanvasRenderTarget_1 = __webpack_require__(/*! ./CanvasRenderTarget */ "./js-compile/raw-pixi-ts/CanvasRenderTarget.js");
class Extract {
    constructor(renderer) {
        this.renderer = renderer;
        /**
         * Collection of methods for extracting data (image, pixels, etc.) from a display object or render texture
         *
         * @member {PIXI.extract.Extract} extract
         * @memberof PIXI.Renderer#
         * @see PIXI.extract.Extract
         */
        renderer.extract = this;
    }
    /**
     * Will return a HTML Image of the target
     *
     * @param {PIXI.DisplayObject|PIXI.RenderTexture} target - A displayObject or renderTexture
     *  to convert. If left empty will use the main renderer
     * @return {HTMLImageElement} HTML Image of the target
     */
    image(target) {
        var image = new Image();
        image.src = this.base64(target);
        return image;
    }
    ;
    /**
     * Will return a a base64 encoded string of this target. It works by calling
     *  `Extract.getCanvas` and then running toDataURL on that.
     *
     * @param {PIXI.DisplayObject|PIXI.RenderTexture} target - A displayObject or renderTexture
     *  to convert. If left empty will use the main renderer
     * @return {string} A base64 encoded string of the texture.
     */
    base64(target) {
        return this.canvas(target).toDataURL();
    }
    ;
    /**
     * Creates a Canvas element, renders this target to it and then returns it.
     *
     * @param {PIXI.DisplayObject|PIXI.RenderTexture} target - A displayObject or renderTexture
     *  to convert. If left empty will use the main renderer
     * @return {HTMLCanvasElement} A Canvas element with the texture rendered on.
     */
    canvas(target) {
        var renderer = this.renderer;
        var resolution;
        var frame;
        var flipY = false;
        var renderTexture;
        var generated = false;
        if (target) {
            if (target instanceof RenderTexture_1.RenderTexture) {
                renderTexture = target;
            }
            else {
                renderTexture = this.renderer.generateTexture(target);
                generated = true;
            }
        }
        if (renderTexture) {
            resolution = renderTexture.baseTexture.resolution;
            frame = renderTexture.frame;
            flipY = false;
            renderer.renderTexture.bind(renderTexture);
        }
        else {
            resolution = this.renderer.resolution;
            flipY = true;
            frame = Extract.TEMP_RECT;
            frame.width = this.renderer.width;
            frame.height = this.renderer.height;
            renderer.renderTexture.bind(null);
        }
        var width = frame.width * resolution;
        var height = frame.height * resolution;
        var canvasBuffer = new CanvasRenderTarget_1.CanvasRenderTarget(width, height, 1);
        var webglPixels = new Uint8Array(Extract.BYTES_PER_PIXEL * width * height);
        // read pixels to the array
        var gl = renderer.gl;
        gl.readPixels(frame.x * resolution, frame.y * resolution, width, height, gl.RGBA, gl.UNSIGNED_BYTE, webglPixels);
        // add the pixels to the canvas
        var canvasData = canvasBuffer.context.getImageData(0, 0, width, height);
        canvasData.data.set(webglPixels);
        canvasBuffer.context.putImageData(canvasData, 0, 0);
        // pulling pixels
        if (flipY) {
            canvasBuffer.context.scale(1, -1);
            canvasBuffer.context.drawImage(canvasBuffer.canvas, 0, -height);
        }
        if (generated) {
            renderTexture.destroy(true);
        }
        // send the canvas back..
        return canvasBuffer.canvas;
    }
    ;
    /**
     * Will return a one-dimensional array containing the pixel data of the entire texture in RGBA
     * order, with integer values between 0 and 255 (included).
     *
     * @param {PIXI.DisplayObject|PIXI.RenderTexture} target - A displayObject or renderTexture
     *  to convert. If left empty will use the main renderer
     * @return {Uint8ClampedArray} One-dimensional array containing the pixel data of the entire texture
     */
    pixels(target) {
        var renderer = this.renderer;
        var resolution;
        var frame;
        var renderTexture;
        var generated = false;
        if (target) {
            if (target instanceof RenderTexture_1.RenderTexture) {
                renderTexture = target;
            }
            else {
                renderTexture = this.renderer.generateTexture(target);
                generated = true;
            }
        }
        if (renderTexture) {
            resolution = renderTexture.baseTexture.resolution;
            frame = renderTexture.frame;
            // bind the buffer
            renderer.renderTexture.bind(renderTexture);
        }
        else {
            resolution = renderer.resolution;
            frame = Extract.TEMP_RECT;
            frame.width = renderer.width;
            frame.height = renderer.height;
            renderer.renderTexture.bind(null);
        }
        var width = frame.width * resolution;
        var height = frame.height * resolution;
        var webglPixels = new Uint8Array(Extract.BYTES_PER_PIXEL * width * height);
        // read pixels to the array
        var gl = renderer.gl;
        gl.readPixels(frame.x * resolution, frame.y * resolution, width, height, gl.RGBA, gl.UNSIGNED_BYTE, webglPixels);
        if (generated) {
            renderTexture.destroy(true);
        }
        return webglPixels;
    }
    ;
    /**
     * Destroys the extract
     *
     */
    destroy() {
        this.renderer.extract = null;
        this.renderer = null;
    }
    ;
}
Extract.TEMP_RECT = new Rectangle_1.Rectangle();
Extract.BYTES_PER_PIXEL = 4;
exports.Extract = Extract;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/FillStyle.js":
/*!*********************************************!*\
  !*** ./js-compile/raw-pixi-ts/FillStyle.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Texture_1 = __webpack_require__(/*! ./Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const FlashBaseObject_1 = __webpack_require__(/*! ./FlashBaseObject */ "./js-compile/raw-pixi-ts/FlashBaseObject.js");
class FillStyle extends FlashBaseObject_1.FlashBaseObject {
    constructor() {
        super();
        this.reset();
    }
    /**
     * Clones the object
     *
     * @return {PIXI.FillStyle}
     */
    clone() {
        var obj = new FillStyle();
        obj.color = this.color;
        obj.alpha = this.alpha;
        obj.texture = this.texture;
        obj.matrix = this.matrix;
        obj.visible = this.visible;
        return obj;
    }
    ;
    /**
     * Reset
     */
    reset() {
        /**
         * The hex color value used when coloring the Graphics object.
         *
         * @member {number}
         * @default 1
         */
        this.color = 0xFFFFFF;
        /**
         * The alpha value used when filling the Graphics object.
         *
         * @member {number}
         * @default 1
         */
        this.alpha = 1;
        /**
         * The texture to be used for the fill.
         *
         * @member {string}
         * @default 0
         */
        this.texture = Texture_1.Texture.WHITE;
        /**
         * The transform aplpied to the texture.
         *
         * @member {string}
         * @default 0
         */
        this.matrix = null;
        /**
         * If the current fill is visible.
         *
         * @member {boolean}
         * @default false
         */
        this.visible = false;
    }
    ;
    /**
     * Destroy and don't use after this
     */
    destroy() {
        this.texture = null;
        this.matrix = null;
    }
    ;
}
exports.FillStyle = FillStyle;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/Filter.js":
/*!******************************************!*\
  !*** ./js-compile/raw-pixi-ts/Filter.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Shader_1 = __webpack_require__(/*! ./Shader */ "./js-compile/raw-pixi-ts/Shader.js");
const Program_1 = __webpack_require__(/*! ./Program */ "./js-compile/raw-pixi-ts/Program.js");
const settings_1 = __webpack_require__(/*! ./settings */ "./js-compile/raw-pixi-ts/settings.js");
const State_1 = __webpack_require__(/*! ./State */ "./js-compile/raw-pixi-ts/State.js");
class Filter extends Shader_1.Shader {
    constructor(vertexSrc = null, fragmentSrc = null, uniforms = null) {
        var program = Program_1.Program.from(vertexSrc || Filter.defaultVertexSrc, fragmentSrc || Filter.defaultFragmentSrc);
        super(program, uniforms);
        /**
         * The padding of the filter. Some filters require extra space to breath such as a blur.
         * Increasing this will add extra width and height to the bounds of the object that the
         * filter is applied to.
         *
         * @member {number}
         */
        this.padding = 0;
        /**
         * The resolution of the filter. Setting this to be lower will lower the quality but
         * increase the performance of the filter.
         *
         * @member {number}
         */
        this.resolution = settings_1.settings.FILTER_RESOLUTION;
        /**
         * If enabled is true the filter is applied, if false it will not.
         *
         * @member {boolean}
         */
        this.enabled = true;
        /**
         * If enabled, PixiJS will fit the filter area into boundaries for better performance.
         * Switch it off if it does not work for specific shader.
         *
         * @member {boolean}
         */
        this.autoFit = true;
        /**
         * Legacy filters use position and uvs from attributes
         * @member {boolean}
         * @readonly
         */
        this.legacy = !!this.program.attributeData.aTextureCoord;
        /**
         * The WebGL state the filter requires to render
         * @member {PIXI.State}
         */
        this.state = new State_1.State();
    }
    /**
     * Applies the filter
     *
     * @param {PIXI.systems.FilterSystem} filterManager - The renderer to retrieve the filter from
     * @param {PIXI.RenderTexture} input - The input render target.
     * @param {PIXI.RenderTexture} output - The target to output to.
     * @param {boolean} clear - Should the output be cleared before rendering to it
     * @param {object} [currentState] - It's current state of filter.
     *        There are some useful properties in the currentState :
     *        target, filters, sourceFrame, destinationFrame, renderTarget, resolution
     */
    apply(filterManager, input, output, clear, currentState, derp) {
        // do as you please!
        filterManager.applyFilter(this, input, output, clear, currentState, derp);
        // or just do a regular render..
    }
    ;
    /**
     * Sets the blendmode of the filter
     *
     * @member {number}
     * @default PIXI.BLEND_MODES.NORMAL
     */
    get blendMode() {
        return this.state.blendMode;
    }
    ;
    set blendMode(value) {
        this.state.blendMode = value;
    }
    ;
    /**
     * The default vertex shader source
     *
     * @static
     * @type {string}
     * @constant
     */
    static get defaultVertexSrc() {
        return Filter.defaultVertex$1;
    }
    ;
    /**
     * The default fragment shader source
     *
     * @static
     * @type {string}
     * @constant
     */
    static get defaultFragmentSrc() {
        return Filter.defaultFragment$1;
    }
    ;
}
/**
 * Used for caching shader IDs
 *
 * @static
 * @type {object}
 * @protected
 */
Filter.SOURCE_KEY_MAP = {};
Filter.defaultVertex$1 = "attribute vec2 aVertexPosition;\r\n\r\nuniform mat3 projectionMatrix;\r\n\r\nvarying vec2 vTextureCoord;\r\n\r\nuniform vec4 inputSize;\r\nuniform vec4 outputFrame;\r\n\r\nvec4 filterVertexPosition( void )\r\n{\r\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\r\n\r\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\r\n}\r\n\r\nvec2 filterTextureCoord( void )\r\n{\r\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\r\n}\r\n\r\nvoid main(void)\r\n{\r\n    gl_Position = filterVertexPosition();\r\n    vTextureCoord = filterTextureCoord();\r\n}\r\n";
Filter.defaultFragment$1 = "varying vec2 vTextureCoord;\r\n\r\nuniform sampler2D uSampler;\r\n\r\nvoid main(void){\r\n   gl_FragColor = texture2D(uSampler, vTextureCoord);\r\n}\r\n";
exports.Filter = Filter;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/FilterState.js":
/*!***********************************************!*\
  !*** ./js-compile/raw-pixi-ts/FilterState.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Rectangle_1 = __webpack_require__(/*! ./Rectangle */ "./js-compile/raw-pixi-ts/Rectangle.js");
class FilterState {
    constructor() {
        this.renderTexture = null;
        /**
         * Target of the filters
         * We store for case when custom filter wants to know the element it was applied on
         * @member {PIXI.DisplayObject}
         * @private
         */
        this.target = null;
        /**
         * Compatibility with PixiJS v4 filters
         * @member {boolean}
         * @default false
         * @private
         */
        this.legacy = false;
        /**
         * Resolution of filters
         * @member {number}
         * @default 1
         * @private
         */
        this.resolution = 1;
        // next three fields are created only for root
        // re-assigned for everything else
        /**
         * Source frame
         * @member {PIXI.Rectangle}
         * @private
         */
        this.sourceFrame = new Rectangle_1.Rectangle();
        /**
         * Destination frame
         * @member {PIXI.Rectangle}
         * @private
         */
        this.destinationFrame = new Rectangle_1.Rectangle();
        /**
         * Collection of filters
         * @member {PIXI.Filter[]}
         * @private
         */
        this.filters = [];
    }
    /**
     * clears the state
     * @private
     */
    clear() {
        this.target = null;
        this.filters = null;
        this.renderTexture = null;
    }
    ;
}
exports.FilterState = FilterState;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/FilterSystem.js":
/*!************************************************!*\
  !*** ./js-compile/raw-pixi-ts/FilterSystem.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const System_1 = __webpack_require__(/*! ./System */ "./js-compile/raw-pixi-ts/System.js");
const Quad_1 = __webpack_require__(/*! ./Quad */ "./js-compile/raw-pixi-ts/Quad.js");
const QuadUv_1 = __webpack_require__(/*! ./QuadUv */ "./js-compile/raw-pixi-ts/QuadUv.js");
const Rectangle_1 = __webpack_require__(/*! ./Rectangle */ "./js-compile/raw-pixi-ts/Rectangle.js");
const UniformGroup_1 = __webpack_require__(/*! ./UniformGroup */ "./js-compile/raw-pixi-ts/UniformGroup.js");
const RenderTexture_1 = __webpack_require__(/*! ./RenderTexture */ "./js-compile/raw-pixi-ts/RenderTexture.js");
const Matrix_1 = __webpack_require__(/*! ./Matrix */ "./js-compile/raw-pixi-ts/Matrix.js");
const FilterState_1 = __webpack_require__(/*! ./FilterState */ "./js-compile/raw-pixi-ts/FilterState.js");
const DrawModeSettings_1 = __webpack_require__(/*! ./DrawModeSettings */ "./js-compile/raw-pixi-ts/DrawModeSettings.js");
const MathSettings_1 = __webpack_require__(/*! ./MathSettings */ "./js-compile/raw-pixi-ts/MathSettings.js");
class FilterSystem extends System_1.System {
    constructor(renderer) {
        super(renderer);
        /**
         * List of filters for the FilterSystem
         * @member {Object[]}
         * @readonly
         */
        this.defaultFilterStack = [{}];
        /**
         * stores a bunch of PO2 textures used for filtering
         * @member {Object}
         */
        this.texturePool = {};
        /**
         * a pool for storing filter states, save us creating new ones each tick
         * @member {Object[]}
         */
        this.statePool = [];
        /**
         * A very simple geometry used when drawing a filter effect to the screen
         * @member {PIXI.Quad}
         */
        this.quad = new Quad_1.Quad();
        /**
         * Quad UVs
         * @member {PIXI.QuadUv}
         */
        this.quadUv = new QuadUv_1.QuadUv();
        /**
         * Temporary rect for maths
         * @type {PIXI.Rectangle}
         */
        this.tempRect = new Rectangle_1.Rectangle();
        /**
         * Active state
         * @member {object}
         */
        this.activeState = {};
        /**
         * This uniform group is attached to filter uniforms when used
         * @member {PIXI.UniformGroup}
         * @property {PIXI.Rectangle} outputFrame
         * @property {Float32Array} inputSize
         * @property {Float32Array} inputPixel
         * @property {Float32Array} inputClamp
         * @property {Number} resolution
         * @property {Float32Array} filterArea
         * @property {Fload32Array} filterClamp
         */
        this.globalUniforms = new UniformGroup_1.UniformGroup({
            outputFrame: this.tempRect,
            inputSize: new Float32Array(4),
            inputPixel: new Float32Array(4),
            inputClamp: new Float32Array(4),
            resolution: 1,
            // legacy variables
            filterArea: new Float32Array(4),
            filterClamp: new Float32Array(4),
        }, true);
        this._pixelsWidth = renderer.view.width;
        this._pixelsHeight = renderer.view.height;
    }
    /**
     * Adds a new filter to the System.
     *
     * @param {PIXI.DisplayObject} target - The target of the filter to render.
     * @param {PIXI.Filter[]} filters - The filters to apply.
     */
    push(target, filters) {
        var renderer = this.renderer;
        var filterStack = this.defaultFilterStack;
        var state = this.statePool.pop() || new FilterState_1.FilterState();
        var resolution = filters[0].resolution;
        var padding = filters[0].padding;
        var autoFit = filters[0].autoFit;
        var legacy = filters[0].legacy;
        for (var i = 1; i < filters.length; i++) {
            var filter = filters[i];
            // lets use the lowest resolution..
            resolution = Math.min(resolution, filter.resolution);
            // and the largest amount of padding!
            padding = Math.max(padding, filter.padding);
            // only auto fit if all filters are autofit
            autoFit = autoFit || filter.autoFit;
            legacy = legacy || filter.legacy;
        }
        if (filterStack.length === 1) {
            this.defaultFilterStack[0].renderTexture = renderer.renderTexture.current;
        }
        filterStack.push(state);
        state.resolution = resolution;
        state.legacy = legacy;
        state.target = target;
        state.sourceFrame.copyFrom(target.filterArea || target.getBounds(true));
        state.sourceFrame.pad(padding);
        if (autoFit) {
            state.sourceFrame.fit(this.renderer.renderTexture.sourceFrame);
        }
        // round to whole number based on resolution
        state.sourceFrame.ceil(resolution);
        state.renderTexture = this.getOptimalFilterTexture(state.sourceFrame.width, state.sourceFrame.height, resolution);
        state.filters = filters;
        state.destinationFrame.width = state.renderTexture.width;
        state.destinationFrame.height = state.renderTexture.height;
        state.renderTexture.filterFrame = state.sourceFrame;
        renderer.renderTexture.bind(state.renderTexture, state.sourceFrame); // /, state.destinationFrame);
        renderer.renderTexture.clear();
    }
    ;
    /**
     * Pops off the filter and applies it.
     *
     */
    pop() {
        var filterStack = this.defaultFilterStack;
        var state = filterStack.pop();
        var filters = state.filters;
        this.activeState = state;
        var globalUniforms = this.globalUniforms.uniforms;
        globalUniforms.outputFrame = state.sourceFrame;
        globalUniforms.resolution = state.resolution;
        var inputSize = globalUniforms.inputSize;
        var inputPixel = globalUniforms.inputPixel;
        var inputClamp = globalUniforms.inputClamp;
        inputSize[0] = state.destinationFrame.width;
        inputSize[1] = state.destinationFrame.height;
        inputSize[2] = 1.0 / inputSize[0];
        inputSize[3] = 1.0 / inputSize[1];
        inputPixel[0] = inputSize[0] * state.resolution;
        inputPixel[1] = inputSize[1] * state.resolution;
        inputPixel[2] = 1.0 / inputPixel[0];
        inputPixel[3] = 1.0 / inputPixel[1];
        inputClamp[0] = 0.5 * inputPixel[2];
        inputClamp[1] = 0.5 * inputPixel[3];
        inputClamp[2] = (state.sourceFrame.width * inputSize[2]) - (0.5 * inputPixel[2]);
        inputClamp[3] = (state.sourceFrame.height * inputSize[3]) - (0.5 * inputPixel[3]);
        // only update the rect if its legacy..
        if (state.legacy) {
            var filterArea = globalUniforms.filterArea;
            filterArea[0] = state.destinationFrame.width;
            filterArea[1] = state.destinationFrame.height;
            filterArea[2] = state.sourceFrame.x;
            filterArea[3] = state.sourceFrame.y;
            globalUniforms.filterClamp = globalUniforms.inputClamp;
        }
        this.globalUniforms.update();
        var lastState = filterStack[filterStack.length - 1];
        if (filters.length === 1) {
            filters[0].apply(this, state.renderTexture, lastState.renderTexture, false, state);
            this.returnFilterTexture(state.renderTexture);
        }
        else {
            var flip = state.renderTexture;
            var flop = this.getOptimalFilterTexture(flip.width, flip.height, state.resolution);
            flop.filterFrame = flip.filterFrame;
            var i = 0;
            for (i = 0; i < filters.length - 1; ++i) {
                filters[i].apply(this, flip, flop, true, state);
                var t = flip;
                flip = flop;
                flop = t;
            }
            filters[i].apply(this, flip, lastState.renderTexture, false, state);
            this.returnFilterTexture(flip);
            this.returnFilterTexture(flop);
        }
        state.clear();
        this.statePool.push(state);
    }
    ;
    /**
     * Draws a filter.
     *
     * @param {PIXI.Filter} filter - The filter to draw.
     * @param {PIXI.RenderTexture} input - The input render target.
     * @param {PIXI.RenderTexture} output - The target to output to.
     * @param {boolean} clear - Should the output be cleared before rendering to it
     */
    applyFilter(filter, input, output, clear) {
        var renderer = this.renderer;
        renderer.renderTexture.bind(output, output ? output.filterFrame : null);
        if (clear) {
            // gl.disable(gl.SCISSOR_TEST);
            renderer.renderTexture.clear();
            // gl.enable(gl.SCISSOR_TEST);
        }
        // set the uniforms..
        filter.uniforms.uSampler = input;
        filter.uniforms.filterGlobals = this.globalUniforms;
        // TODO make it so that the order of this does not matter..
        // because it does at the moment cos of global uniforms.
        // they need to get resynced
        renderer.state.setState(filter.state);
        renderer.shader.bind(filter);
        if (filter.legacy) {
            this.quadUv.map(input._frame, input.filterFrame);
            renderer.geometry.bind(this.quadUv);
            renderer.geometry.draw(DrawModeSettings_1.DrawModeSettings.DRAW_MODES.TRIANGLES);
        }
        else {
            renderer.geometry.bind(this.quad);
            renderer.geometry.draw(DrawModeSettings_1.DrawModeSettings.DRAW_MODES.TRIANGLE_STRIP);
        }
    }
    ;
    /**
     * Calculates the mapped matrix.
     *
     * TODO playing around here.. this is temporary - (will end up in the shader)
     * this returns a matrix that will normalize map filter cords in the filter to screen space
     *
     * @param {PIXI.Matrix} outputMatrix - the matrix to output to.
     * @return {PIXI.Matrix} The mapped matrix.
     */
    calculateScreenSpaceMatrix(outputMatrix) {
        var currentState = this.activeState;
        return FilterSystem.calculateScreenSpaceMatrix(outputMatrix, currentState.sourceFrame, currentState.destinationFrame);
    }
    ;
    /**
     * This will map the filter coord so that a texture can be used based on the transform of a sprite
     *
     * @param {PIXI.Matrix} outputMatrix - The matrix to output to.
     * @param {PIXI.Sprite} sprite - The sprite to map to.
     * @return {PIXI.Matrix} The mapped matrix.
     */
    calculateSpriteMatrix(outputMatrix, sprite) {
        var currentState = this.activeState;
        return FilterSystem.calculateSpriteMatrix(outputMatrix, currentState.sourceFrame, currentState.destinationFrame, sprite);
    }
    ;
    /**
     * Destroys this Filter System.
     *
     * @param {boolean} [contextLost=false] context was lost, do not free shaders
     *
     */
    destroy(contextLost) {
        if (contextLost === void 0) {
            contextLost = false;
        }
        if (!contextLost) {
            this.emptyPool();
        }
        else {
            this.texturePool = {};
        }
    }
    ;
    /**
     * Gets a Power-of-Two render texture or fullScreen texture
     *
     * TODO move to a separate class could be on renderer?
     *
     * @protected
     * @param {number} minWidth - The minimum width of the render texture in real pixels.
     * @param {number} minHeight - The minimum height of the render texture in real pixels.
     * @param {number} [resolution=1] - The resolution of the render texture.
     * @return {PIXI.RenderTexture} The new render texture.
     */
    getOptimalFilterTexture(minWidth, minHeight, resolution) {
        if (resolution === void 0) {
            resolution = 1;
        }
        var key = FilterSystem.screenKey;
        minWidth *= resolution;
        minHeight *= resolution;
        if (minWidth !== this._pixelsWidth || minHeight !== this._pixelsHeight) {
            minWidth = MathSettings_1.MathSettings.nextPow2(minWidth);
            minHeight = MathSettings_1.MathSettings.nextPow2(minHeight);
            key = ((minWidth & 0xFFFF) << 16) | (minHeight & 0xFFFF);
        }
        if (!this.texturePool[key]) {
            this.texturePool[key] = [];
        }
        var renderTexture = this.texturePool[key].pop();
        if (!renderTexture) {
            // temporary bypass cache..
            // internally - this will cause a texture to be bound..
            renderTexture = RenderTexture_1.RenderTexture.create({
                width: minWidth / resolution,
                height: minHeight / resolution,
                resolution: resolution,
            });
        }
        renderTexture.filterPoolKey = key;
        return renderTexture;
    }
    ;
    /**
     * Gets extra render texture to use inside current filter
     *
     * @param {number} resolution resolution of the renderTexture
     * @returns {PIXI.RenderTexture}
     */
    getFilterTexture(resolution) {
        var rt = this.activeState.renderTexture;
        var filterTexture = this.getOptimalFilterTexture(rt.width, rt.height, resolution || rt.baseTexture.resolution);
        filterTexture.filterFrame = rt.filterFrame;
        return filterTexture;
    }
    ;
    /**
     * Frees a render texture back into the pool.
     *
     * @param {PIXI.RenderTexture} renderTexture - The renderTarget to free
     */
    returnFilterTexture(renderTexture) {
        var key = renderTexture.filterPoolKey;
        renderTexture.filterFrame = null;
        this.texturePool[key].push(renderTexture);
    }
    ;
    /**
     * Empties the texture pool.
     *
     */
    emptyPool() {
        for (var i in this.texturePool) {
            var textures = this.texturePool[i];
            if (textures) {
                for (var j = 0; j < textures.length; j++) {
                    textures[j].destroy(true);
                }
            }
        }
        this.texturePool = {};
    }
    ;
    resize() {
        var textures = this.texturePool[FilterSystem.screenKey];
        if (textures) {
            for (var j = 0; j < textures.length; j++) {
                textures[j].destroy(true);
            }
        }
        this.texturePool[FilterSystem.screenKey] = [];
        this._pixelsWidth = this.renderer.view.width;
        this._pixelsHeight = this.renderer.view.height;
    }
    ;
    // this will map the filter coord so that a texture can be used based on the transform of a sprite
    static calculateSpriteMatrix(outputMatrix, filterArea, textureSize, sprite) {
        var orig = sprite._texture.orig;
        var mappedMatrix = outputMatrix.set(textureSize.width, 0, 0, textureSize.height, filterArea.x, filterArea.y);
        var worldTransform = sprite.worldTransform.copyTo(Matrix_1.Matrix.TEMP_MATRIX);
        worldTransform.invert();
        mappedMatrix.prepend(worldTransform);
        mappedMatrix.scale(1.0 / orig.width, 1.0 / orig.height);
        mappedMatrix.translate(sprite.anchor.x, sprite.anchor.y);
        return mappedMatrix;
    }
    /**
 * Calculates the mapped matrix
 * @param {PIXI.Matrix} outputMatrix matrix that will normalize map filter cords in the filter to screen space
 * @param {PIXI.Rectangle} filterArea filter area
 * @param {PIXI.Rectangle} textureSize texture size
 * @returns {PIXI.Matrix} same as outputMatrix
 * @private
 */
    static calculateScreenSpaceMatrix(outputMatrix, filterArea, textureSize) {
        // TODO unwrap?
        var mappedMatrix = outputMatrix.identity();
        mappedMatrix.translate(filterArea.x / textureSize.width, filterArea.y / textureSize.height);
        mappedMatrix.scale(textureSize.width, textureSize.height);
        return mappedMatrix;
    }
}
FilterSystem.screenKey = 'screen';
exports.FilterSystem = FilterSystem;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/FlashBaseObject.js":
/*!***************************************************!*\
  !*** ./js-compile/raw-pixi-ts/FlashBaseObject.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class FlashBaseObject {
    constructor() {
        FlashBaseObject.nameCount++;
        this._name = "instance-" + this.className + "-" + FlashBaseObject.nameCount;
        this._instanceName = "instance-" + this.className + "-" + FlashBaseObject.nameCount;
        this._hasChanged = true;
        this._className = this.constructor['name'];
    }
    get className() {
        return this.constructor['name'];
    }
    destructor() {
    }
    get hasChanged() {
        return this._hasChanged;
    }
    set hasChanged(value) {
        this._hasChanged = value;
    }
    get name() {
        return this._name;
    }
    set name(value) {
        this._name = value;
    }
    get instanceName() {
        return this._instanceName;
    }
}
FlashBaseObject.nameCount = 0;
exports.FlashBaseObject = FlashBaseObject;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/Framebuffer.js":
/*!***********************************************!*\
  !*** ./js-compile/raw-pixi-ts/Framebuffer.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseTexture_1 = __webpack_require__(/*! ./BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const DepthResource_1 = __webpack_require__(/*! ./DepthResource */ "./js-compile/raw-pixi-ts/DepthResource.js");
const WebGLSettings_1 = __webpack_require__(/*! ./WebGLSettings */ "./js-compile/raw-pixi-ts/WebGLSettings.js");
const Runner_1 = __webpack_require__(/*! ./Runner */ "./js-compile/raw-pixi-ts/Runner.js");
class Framebuffer {
    constructor(width, height) {
        this.width = Math.ceil(width || 100);
        this.height = Math.ceil(height || 100);
        this.stencil = false;
        this.depth = false;
        this.dirtyId = 0;
        this.dirtyFormat = 0;
        this.dirtySize = 0;
        this.depthTexture = null;
        this.colorTextures = [];
        this.glFramebuffers = {};
        this.disposeRunner = new Runner_1.Runner('disposeFramebuffer', 2);
        // this.disposeRunner = new Runner('disposeFramebuffer', 2);
    }
    /**
     * Reference to the colorTexture.
     *
     * @member {PIXI.Texture[]}
     * @readonly
     */
    get colorTexture() {
        return this.colorTextures[0];
    }
    ;
    /**
     * Add texture to the colorTexture array
     *
     * @param {number} [index=0] - Index of the array to add the texture to
     * @param {PIXI.Texture} [texture] - Texture to add to the array
     */
    addColorTexture(index, texture) {
        if (index === void 0) {
            index = 0;
        }
        // TODO add some validation to the texture - same width / height etc?
        this.colorTextures[index] = texture || new BaseTexture_1.BaseTexture(null, { scaleMode: 0,
            resolution: 1,
            mipmap: false,
            width: this.width,
            height: this.height }); // || new Texture();
        this.dirtyId++;
        this.dirtyFormat++;
        return this;
    }
    ;
    /**
     * Add a depth texture to the frame buffer
     *
     * @param {PIXI.Texture} [texture] - Texture to add
     */
    addDepthTexture(texture) {
        /* eslint-disable max-len */
        this.depthTexture = texture || new BaseTexture_1.BaseTexture(new DepthResource_1.DepthResource(null, { width: this.width, height: this.height }), { scaleMode: 0,
            resolution: 1,
            width: this.width,
            height: this.height,
            mipmap: false,
            format: WebGLSettings_1.WebGLSettings.FORMATS.DEPTH_COMPONENT,
            type: WebGLSettings_1.WebGLSettings.TYPES.UNSIGNED_SHORT }); // UNSIGNED_SHORT;
        /* eslint-disable max-len */
        this.dirtyId++;
        this.dirtyFormat++;
        return this;
    }
    ;
    /**
     * Enable depth on the frame buffer
     */
    enableDepth() {
        this.depth = true;
        this.dirtyId++;
        this.dirtyFormat++;
        return this;
    }
    ;
    /**
     * Enable stencil on the frame buffer
     */
    enableStencil() {
        this.stencil = true;
        this.dirtyId++;
        this.dirtyFormat++;
        return this;
    }
    ;
    /**
     * Resize the frame buffer
     *
     * @param {number} width - Width of the frame buffer to resize to
     * @param {number} height - Height of the frame buffer to resize to
     */
    resize(width, height) {
        width = Math.ceil(width);
        height = Math.ceil(height);
        if (width === this.width && height === this.height) {
            return;
        }
        this.width = width;
        this.height = height;
        this.dirtyId++;
        this.dirtySize++;
        for (var i = 0; i < this.colorTextures.length; i++) {
            var texture = this.colorTextures[i];
            var resolution = texture.resolution;
            // take into acount the fact the texture may have a different resolution..
            texture.setSize(width / resolution, height / resolution);
        }
        if (this.depthTexture) {
            var resolution$1 = this.depthTexture.resolution;
            this.depthTexture.setSize(width / resolution$1, height / resolution$1);
        }
    }
    ;
    /**
     * disposes WebGL resources that are connected to this geometry
     */
    dispose() {
        // this.disposeRunner.run(this, false);
        this.disposeRunner.run(this, false);
    }
    ;
}
exports.Framebuffer = Framebuffer;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/FramebufferSystem.js":
/*!*****************************************************!*\
  !*** ./js-compile/raw-pixi-ts/FramebufferSystem.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const System_1 = __webpack_require__(/*! ./System */ "./js-compile/raw-pixi-ts/System.js");
const Framebuffer_1 = __webpack_require__(/*! ./Framebuffer */ "./js-compile/raw-pixi-ts/Framebuffer.js");
const Rectangle_1 = __webpack_require__(/*! ./Rectangle */ "./js-compile/raw-pixi-ts/Rectangle.js");
const DisplaySettings_1 = __webpack_require__(/*! ./DisplaySettings */ "./js-compile/raw-pixi-ts/DisplaySettings.js");
class FramebufferSystem extends System_1.System {
    constructor(renderer) {
        super(renderer);
        /**
         * A list of managed framebuffers
         * @member {PIXI.Framebuffer[]}
         * @readonly
         */
        this.managedFramebuffers = [];
        /**
         * Framebuffer value that shows that we don't know what is bound
         * @member {Framebuffer}
         * @readonly
         */
        this.unknownFramebuffer = new Framebuffer_1.Framebuffer(10, 10);
        this.viewport = new Rectangle_1.Rectangle();
    }
    /**
     * Sets up the renderer context and necessary buffers.
     */
    contextChange(gl) {
        var gl = this.gl = this.renderer.gl;
        this.CONTEXT_UID = this.renderer.CONTEXT_UID;
        this.current = this.unknownFramebuffer;
        this.viewport = new Rectangle_1.Rectangle();
        this.hasMRT = true;
        this.writeDepthTexture = true;
        this.disposeAll(true);
        // webgl2
        if (this.renderer.context.webGLVersion === 1) {
            // webgl 1!
            var nativeDrawBuffersExtension = this.renderer.context.extensions.drawBuffers;
            var nativeDepthTextureExtension = this.renderer.context.extensions.depthTexture;
            if (DisplaySettings_1.DisplaySettings.PREFER_ENV === DisplaySettings_1.DisplaySettings.ENV.WEBGL_LEGACY) {
                nativeDrawBuffersExtension = null;
                nativeDepthTextureExtension = null;
            }
            if (nativeDrawBuffersExtension) {
                gl.drawBuffers = function (activeTextures) { return nativeDrawBuffersExtension.drawBuffersWEBGL(activeTextures); };
            }
            else {
                this.hasMRT = false;
                gl.drawBuffers = function () {
                    // empty
                };
            }
            if (!nativeDepthTextureExtension) {
                this.writeDepthTexture = false;
            }
        }
    }
    ;
    /**
         * Bind a framebuffer
         *
         * @param {PIXI.Framebuffer} framebuffer
         * @param {PIXI.Rectangle} [frame] frame, default is framebuffer size
         */
    bind(framebuffer = null, frame = null) {
        var ref = this;
        var gl = ref.gl;
        if (framebuffer) {
            // TODO caching layer!
            var fbo = framebuffer.glFramebuffers[this.CONTEXT_UID] || this.initFramebuffer(framebuffer);
            if (this.current !== framebuffer) {
                this.current = framebuffer;
                gl.bindFramebuffer(gl.FRAMEBUFFER, fbo.framebuffer);
            }
            // make sure all textures are unbound..
            // now check for updates...
            if (fbo.dirtyId !== framebuffer.dirtyId) {
                fbo.dirtyId = framebuffer.dirtyId;
                if (fbo.dirtyFormat !== framebuffer.dirtyFormat) {
                    fbo.dirtyFormat = framebuffer.dirtyFormat;
                    this.updateFramebuffer(framebuffer);
                }
                else if (fbo.dirtySize !== framebuffer.dirtySize) {
                    fbo.dirtySize = framebuffer.dirtySize;
                    this.resizeFramebuffer(framebuffer);
                }
            }
            for (var i = 0; i < framebuffer.colorTextures.length; i++) {
                if (framebuffer.colorTextures[i].texturePart) {
                    this.renderer.texture.unbind(framebuffer.colorTextures[i].texture);
                }
                else {
                    this.renderer.texture.unbind(framebuffer.colorTextures[i]);
                }
            }
            if (framebuffer.depthTexture) {
                this.renderer.texture.unbind(framebuffer.depthTexture);
            }
            if (frame) {
                this.setViewport(frame.x, frame.y, frame.width, frame.height);
            }
            else {
                this.setViewport(0, 0, framebuffer.width, framebuffer.height);
            }
        }
        else {
            if (this.current) {
                this.current = null;
                gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            }
            if (frame) {
                this.setViewport(frame.x, frame.y, frame.width, frame.height);
            }
            else {
                this.setViewport(0, 0, this.renderer.width, this.renderer.height);
            }
        }
    }
    ;
    /**
     * Set the WebGLRenderingContext's viewport.
     *
     * @param {Number} x - X position of viewport
     * @param {Number} y - Y position of viewport
     * @param {Number} width - Width of viewport
     * @param {Number} height - Height of viewport
     */
    setViewport(x, y, width, height) {
        var v = this.viewport;
        if (v.width !== width || v.height !== height || v.x !== x || v.y !== y) {
            v.x = x;
            v.y = y;
            v.width = width;
            v.height = height;
            this.gl.viewport(x, y, width, height);
        }
    }
    ;
    /**
     * Get the size of the current width and height. Returns object with `width` and `height` values.
     *
     * @member {object}
     * @readonly
     */
    get size() {
        if (this.current) {
            // TODO store temp
            return { x: 0, y: 0, width: this.current.width, height: this.current.height };
        }
        return { x: 0, y: 0, width: this.renderer.width, height: this.renderer.height };
    }
    ;
    /**
     * Clear the color of the context
     *
     * @param {Number} r - Red value from 0 to 1
     * @param {Number} g - Green value from 0 to 1
     * @param {Number} b - Blue value from 0 to 1
     * @param {Number} a - Alpha value from 0 to 1
     */
    clear(r = 0, g = 0, b = 0, a = 1) {
        var ref = this;
        var gl = ref.gl;
        // TODO clear color can be set only one right?
        gl.clearColor(r, g, b, a);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    }
    ;
    /**
 * Initialize framebuffer
 *
 * @protected
 * @param {PIXI.Framebuffer} framebuffer
 */
    initFramebuffer(framebuffer) {
        var ref = this;
        var gl = ref.gl;
        // TODO - make this a class?
        var fbo = {
            framebuffer: gl.createFramebuffer(),
            stencil: null,
            dirtyId: 0,
            dirtyFormat: 0,
            dirtySize: 0,
        };
        framebuffer.glFramebuffers[this.CONTEXT_UID] = fbo;
        this.managedFramebuffers.push(framebuffer);
        framebuffer.disposeRunner.add(this);
        return fbo;
    }
    ;
    /**
     * Resize the framebuffer
     *
     * @protected
     * @param {PIXI.Framebuffer} framebuffer
     */
    resizeFramebuffer(framebuffer) {
        var ref = this;
        var gl = ref.gl;
        var fbo = framebuffer.glFramebuffers[this.CONTEXT_UID];
        if (fbo.stencil) {
            gl.bindRenderbuffer(gl.RENDERBUFFER, fbo.stencil);
            gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, framebuffer.width, framebuffer.height);
        }
        var colorTextures = framebuffer.colorTextures;
        for (var i = 0; i < colorTextures.length; i++) {
            this.renderer.texture.bind(colorTextures[i], 0);
        }
        if (framebuffer.depthTexture) {
            this.renderer.texture.bind(framebuffer.depthTexture, 0);
        }
    }
    ;
    /**
     * Update the framebuffer
     *
     * @protected
     * @param {PIXI.Framebuffer} framebuffer
     */
    updateFramebuffer(framebuffer) {
        var ref = this;
        var gl = ref.gl;
        var fbo = framebuffer.glFramebuffers[this.CONTEXT_UID];
        // bind the color texture
        var colorTextures = framebuffer.colorTextures;
        var count = colorTextures.length;
        if (!gl.drawBuffers) {
            count = Math.min(count, 1);
        }
        var activeTextures = [];
        for (var i = 0; i < count; i++) {
            var texture = framebuffer.colorTextures[i];
            if (texture.texturePart) {
                this.renderer.texture.bind(texture.texture, 0);
                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, gl.TEXTURE_CUBE_MAP_NEGATIVE_X + texture.side, texture.texture._glTextures[this.CONTEXT_UID].texture, 0);
            }
            else {
                this.renderer.texture.bind(texture, 0);
                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, gl.TEXTURE_2D, texture._glTextures[this.CONTEXT_UID].texture, 0);
            }
            activeTextures.push(gl.COLOR_ATTACHMENT0 + i);
        }
        if (activeTextures.length > 1) {
            gl.drawBuffers(activeTextures);
        }
        if (framebuffer.depthTexture) {
            var writeDepthTexture = this.writeDepthTexture;
            if (writeDepthTexture) {
                var depthTexture = framebuffer.depthTexture;
                this.renderer.texture.bind(depthTexture, 0);
                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, depthTexture._glTextures[this.CONTEXT_UID].texture, 0);
            }
        }
        if (!fbo.stencil && (framebuffer.stencil || framebuffer.depth)) {
            fbo.stencil = gl.createRenderbuffer();
            gl.bindRenderbuffer(gl.RENDERBUFFER, fbo.stencil);
            // TODO.. this is depth AND stencil?
            if (!framebuffer.depthTexture) { // you can't have both, so one should take priority if enabled
                gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, fbo.stencil);
            }
            gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, framebuffer.width, framebuffer.height);
            // fbo.enableStencil();
        }
    }
    ;
    /**
     * Disposes framebuffer
     * @param {PIXI.Framebuffer} framebuffer framebuffer that has to be disposed of
     * @param {boolean} [contextLost=false] If context was lost, we suppress all delete function calls
     */
    disposeFramebuffer(framebuffer, contextLost) {
        var fbo = framebuffer.glFramebuffers[this.CONTEXT_UID];
        var gl = this.gl;
        if (!fbo) {
            return;
        }
        delete framebuffer.glFramebuffers[this.CONTEXT_UID];
        var index = this.managedFramebuffers.indexOf(framebuffer);
        if (index >= 0) {
            this.managedFramebuffers.splice(index, 1);
        }
        framebuffer.disposeRunner.remove(this);
        if (!contextLost) {
            gl.deleteFramebuffer(fbo.framebuffer);
            if (fbo.stencil) {
                gl.deleteRenderbuffer(fbo.stencil);
            }
        }
    }
    ;
    /**
     * Disposes all framebuffers, but not textures bound to them
     * @param {boolean} [contextLost=false] If context was lost, we suppress all delete function calls
     */
    disposeAll(contextLost) {
        var list = this.managedFramebuffers;
        this.managedFramebuffers = [];
        for (var i = 0; i < list.count; i++) {
            this.disposeFramebuffer(list[i], contextLost);
        }
    }
    ;
    /**
     * resets framebuffer stored state, binds screen framebuffer
     *
     * should be called before renderTexture reset()
     */
    reset() {
        this.current = this.unknownFramebuffer;
        this.viewport = new Rectangle_1.Rectangle();
    }
    ;
}
exports.FramebufferSystem = FramebufferSystem;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/GLBuffer.js":
/*!********************************************!*\
  !*** ./js-compile/raw-pixi-ts/GLBuffer.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class GLBuffer {
    constructor(buffer) {
        this.buffer = buffer;
        this.updateID = -1;
        this.byteLength = -1;
        this.refCount = 0;
    }
}
exports.GLBuffer = GLBuffer;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/GLProgram.js":
/*!*********************************************!*\
  !*** ./js-compile/raw-pixi-ts/GLProgram.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class GLProgram {
    constructor(program, uniformData) {
        /**
                 * The shader program
                 *
                 * @member {WebGLProgram}
                 */
        this.program = program;
        /**
         * holds the uniform data which contains uniform locations
         * and current uniform values used for caching and preventing unneeded GPU commands
         * @member {Object}
         */
        this.uniformData = uniformData;
        /**
         * uniformGroups holds the various upload functions for the shader. Each uniform group
         * and program have a unique upload function generated.
         * @member {Object}
         */
        this.uniformGroups = {};
    }
    /**
     * Destroys this program
     */
    destroy() {
        this.uniformData = null;
        this.uniformGroups = null;
        this.program = null;
    }
    ;
}
exports.GLProgram = GLProgram;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/GLTexture.js":
/*!*********************************************!*\
  !*** ./js-compile/raw-pixi-ts/GLTexture.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class GLTexture {
    constructor(texture) {
        /**
                 * The WebGL texture
                 * @member {WebGLTexture}
                 */
        this.texture = texture;
        this.width = -1;
        this.height = -1;
        /**
         * Texture contents dirty flag
         * @member {number}
         */
        this.dirtyId = -1;
        /**
         * Texture style dirty flag
         * @member {number}
         */
        this.dirtyStyleId = -1;
        /**
         * Whether mip levels has to be generated
         * @member {boolean}
         */
        this.mipmap = false;
        /**
         * WrapMode copied from baseTexture
         * @member {number}
         */
        this.wrapMode = 33071;
    }
}
exports.GLTexture = GLTexture;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/Geometry.js":
/*!********************************************!*\
  !*** ./js-compile/raw-pixi-ts/Geometry.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Attribute_1 = __webpack_require__(/*! ./Attribute */ "./js-compile/raw-pixi-ts/Attribute.js");
const Buffer_1 = __webpack_require__(/*! ./Buffer */ "./js-compile/raw-pixi-ts/Buffer.js");
const Runner_1 = __webpack_require__(/*! ./Runner */ "./js-compile/raw-pixi-ts/Runner.js");
class Geometry {
    constructor(buffers = [], attributes = {}) {
        this.buffers = buffers;
        this.indexBuffer = null;
        this.attributes = attributes;
        /**
         * A map of renderer IDs to webgl VAOs
         *
         * @protected
         * @type {object}
         */
        this.glVertexArrayObjects = {};
        this.id = Geometry.UID$1++;
        this.instanced = false;
        this.instanceCount = 1;
        this._size = null;
        this.disposeRunner = new Runner_1.Runner('disposeGeometry', 2);
        // this.disposeRunner = new Runner('disposeGeometry', 2);
        /**
         * Count of existing (not destroyed) meshes that reference this geometry
         * @member {boolean}
         */
        this.refCount = 0;
    }
    /**
    *
    * Adds an attribute to the geometry
    *
    * @param {String} id - the name of the attribute (matching up to a shader)
    * @param {PIXI.Buffer} [buffer] the buffer that holds the data of the attribute . You can also provide an Array and a buffer will be created from it.
    * @param {Number} [size=0] the size of the attribute. If you have 2 floats per vertex (eg position x and y) this would be 2
    * @param {Boolean} [normalized=false] should the data be normalized.
    * @param {Number} [type=PIXI.TYPES.FLOAT] what type of number is the attribute. Check {PIXI.TYPES} to see the ones available
    * @param {Number} [stride=0] How far apart (in floats) the start of each value is. (used for interleaving data)
    * @param {Number} [start=0] How far into the array to start reading values (used for interleaving data)
    *
    * @return {PIXI.Geometry} returns self, useful for chaining.
    */
    addAttribute(id, buffer, size = null, normalized = false, type = null, stride = undefined, start = undefined, instance = undefined) {
        if (!buffer) {
            throw new Error('You must pass a buffer when creating an attribute');
        }
        // check if this is a buffer!
        if (!buffer.data) {
            // its an array!
            if (buffer instanceof Array) {
                buffer = new Float32Array(buffer);
            }
            buffer = new Buffer_1.Buffer(buffer);
        }
        var ids = id.split('|');
        if (ids.length > 1) {
            for (var i = 0; i < ids.length; i++) {
                this.addAttribute(ids[i], buffer, size, normalized, type);
            }
            return this;
        }
        var bufferIndex = this.buffers.indexOf(buffer);
        if (bufferIndex === -1) {
            this.buffers.push(buffer);
            bufferIndex = this.buffers.length - 1;
        }
        this.attributes[id] = new Attribute_1.Attribute(bufferIndex, size, normalized, type, stride, start, instance);
        // assuming that if there is instanced data then this will be drawn with instancing!
        this.instanced = this.instanced || instance;
        return this;
    }
    ;
    /**
     * returns the requested attribute
     *
     * @param {String} id  the name of the attribute required
     * @return {PIXI.Attribute} the attribute requested.
     */
    getAttribute(id) {
        return this.buffers[this.attributes[id].buffer];
    }
    ;
    /**
    *
    * Adds an index buffer to the geometry
    * The index buffer contains integers, three for each triangle in the geometry, which reference the various attribute buffers (position, colour, UV coordinates, other UV coordinates, normal, ). There is only ONE index buffer.
    *
    * @param {PIXI.Buffer} [buffer] the buffer that holds the data of the index buffer. You can also provide an Array and a buffer will be created from it.
    * @return {PIXI.Geometry} returns self, useful for chaining.
    */
    addIndex(buffer) {
        if (!buffer.data) {
            // its an array!
            if (buffer instanceof Array) {
                buffer = new Uint16Array(buffer);
            }
            buffer = new Buffer_1.Buffer(buffer);
        }
        buffer.index = true;
        this.indexBuffer = buffer;
        if (this.buffers.indexOf(buffer) === -1) {
            this.buffers.push(buffer);
        }
        return this;
    }
    ;
    /**
     * returns the index buffer
     *
     * @return {PIXI.Buffer} the index buffer.
     */
    getIndex() {
        return this.indexBuffer;
    }
    ;
    /**
     * this function modifies the structure so that all current attributes become interleaved into a single buffer
     * This can be useful if your model remains static as it offers a little performance boost
     *
     * @return {PIXI.Geometry} returns self, useful for chaining.
     */
    interleave() {
        // a simple check to see if buffers are already interleaved..
        if (this.buffers.length === 1 || (this.buffers.length === 2 && this.indexBuffer)) {
            return this;
        }
        // assume already that no buffers are interleaved
        var arrays = [];
        var sizes = [];
        var interleavedBuffer = new Buffer_1.Buffer();
        var i;
        for (i in this.attributes) {
            var attribute = this.attributes[i];
            var buffer = this.buffers[attribute.buffer];
            arrays.push(buffer.data);
            sizes.push((attribute.size * Geometry.byteSizeMap[attribute.type]) / 4);
            attribute.buffer = 0;
        }
        interleavedBuffer.data = Geometry.interleaveTypedArrays(arrays, sizes);
        for (i = 0; i < this.buffers.length; i++) {
            if (this.buffers[i] !== this.indexBuffer) {
                this.buffers[i].destroy();
            }
        }
        this.buffers = [interleavedBuffer];
        if (this.indexBuffer) {
            this.buffers.push(this.indexBuffer);
        }
        return this;
    }
    ;
    getSize() {
        for (var i in this.attributes) {
            var attribute = this.attributes[i];
            var buffer = this.buffers[attribute.buffer];
            return buffer.data.length / ((attribute.stride / 4) || attribute.size);
        }
        return 0;
    }
    ;
    /**
     * disposes WebGL resources that are connected to this geometry
     */
    dispose() {
        // this.disposeRunner.run(this, false);
        this.disposeRunner.run(this, false);
    }
    ;
    /**
     * Destroys the geometry.
     */
    destroy(options = null) {
        this.dispose();
        this.buffers = null;
        this.indexBuffer.destroy();
        this.attributes = null;
    }
    ;
    /**
     * returns a clone of the geometry
     *
     * @returns {PIXI.Geometry} a new clone of this geometry
     */
    clone() {
        var geometry = new Geometry();
        for (var i = 0; i < this.buffers.length; i++) {
            geometry.buffers[i] = new Buffer_1.Buffer(this.buffers[i].data.slice());
        }
        for (var i$1 in this.attributes) {
            var attrib = this.attributes[i$1];
            geometry.attributes[i$1] = new Attribute_1.Attribute(attrib.buffer, attrib.size, attrib.normalized, attrib.type, attrib.stride, attrib.start, attrib.instance);
        }
        if (this.indexBuffer) {
            geometry.indexBuffer = geometry.buffers[this.buffers.indexOf(this.indexBuffer)];
            geometry.indexBuffer.index = true;
        }
        return geometry;
    }
    ;
    /**
     * merges an array of geometries into a new single one
     * geometry attribute styles must match for this operation to work
     *
     * @param {PIXI.Geometry[]} geometries array of geometries to merge
     * @returns {PIXI.Geometry} shiny new geometry!
     */
    static merge(geometries) {
        // todo add a geometry check!
        // also a size check.. cant be too big!]
        var geometryOut = new Geometry();
        var arrays = [];
        var sizes = [];
        var offsets = [];
        var geometry;
        // pass one.. get sizes..
        for (var i = 0; i < geometries.length; i++) {
            geometry = geometries[i];
            for (var j = 0; j < geometry.buffers.length; j++) {
                sizes[j] = sizes[j] || 0;
                sizes[j] += geometry.buffers[j].data.length;
                offsets[j] = 0;
            }
        }
        // build the correct size arrays..
        for (var i$1 = 0; i$1 < geometry.buffers.length; i$1++) {
            // TODO types!
            arrays[i$1] = new Geometry.map$1[Geometry.getBufferType(geometry.buffers[i$1].data)](sizes[i$1]);
            geometryOut.buffers[i$1] = new Buffer_1.Buffer(arrays[i$1]);
        }
        // pass to set data..
        for (var i$2 = 0; i$2 < geometries.length; i$2++) {
            geometry = geometries[i$2];
            for (var j$1 = 0; j$1 < geometry.buffers.length; j$1++) {
                arrays[j$1].set(geometry.buffers[j$1].data, offsets[j$1]);
                offsets[j$1] += geometry.buffers[j$1].data.length;
            }
        }
        geometryOut.attributes = geometry.attributes;
        if (geometry.indexBuffer) {
            geometryOut.indexBuffer = geometryOut.buffers[geometry.buffers.indexOf(geometry.indexBuffer)];
            geometryOut.indexBuffer.index = true;
            var offset = 0;
            var stride = 0;
            var offset2 = 0;
            var bufferIndexToCount = 0;
            // get a buffer
            for (var i$3 = 0; i$3 < geometry.buffers.length; i$3++) {
                if (geometry.buffers[i$3] !== geometry.indexBuffer) {
                    bufferIndexToCount = i$3;
                    break;
                }
            }
            // figure out the stride of one buffer..
            for (var i$4 in geometry.attributes) {
                var attribute = geometry.attributes[i$4];
                if ((attribute.buffer | 0) === bufferIndexToCount) {
                    stride += ((attribute.size * Geometry.byteSizeMap[attribute.type]) / 4);
                }
            }
            // time to off set all indexes..
            for (var i$5 = 0; i$5 < geometries.length; i$5++) {
                var indexBufferData = geometries[i$5].indexBuffer.data;
                for (var j$2 = 0; j$2 < indexBufferData.length; j$2++) {
                    geometryOut.indexBuffer.data[j$2 + offset2] += offset;
                }
                offset += geometry.buffers[bufferIndexToCount].data.length / (stride);
                offset2 += indexBufferData.length;
            }
        }
        return geometryOut;
    }
    ;
    static getBufferType(array) {
        if (array.BYTES_PER_ELEMENT === 4) {
            if (array instanceof Float32Array) {
                return 'Float32Array';
            }
            else if (array instanceof Uint32Array) {
                return 'Uint32Array';
            }
            return 'Int32Array';
        }
        else if (array.BYTES_PER_ELEMENT === 2) {
            if (array instanceof Uint16Array) {
                return 'Uint16Array';
            }
        }
        else if (array.BYTES_PER_ELEMENT === 1) {
            if (array instanceof Uint8Array) {
                return 'Uint8Array';
            }
        }
        // TODO map out the rest of the array elements!
        return null;
    }
    static interleaveTypedArrays(arrays, sizes) {
        var outSize = 0;
        var stride = 0;
        var views = {};
        for (var i = 0; i < arrays.length; i++) {
            stride += sizes[i];
            outSize += arrays[i].length;
        }
        var buffer = new ArrayBuffer(outSize * 4);
        var out = null;
        var littleOffset = 0;
        for (var i$1 = 0; i$1 < arrays.length; i$1++) {
            var size = sizes[i$1];
            var array = arrays[i$1];
            var type = Geometry.getBufferType(array);
            if (!views[type]) {
                views[type] = new Geometry.map[type](buffer);
            }
            out = views[type];
            for (var j = 0; j < array.length; j++) {
                var indexStart = ((j / size | 0) * stride) + littleOffset;
                var index = j % size;
                out[indexStart + index] = array[j];
            }
            littleOffset += size;
        }
        return new Float32Array(buffer);
    }
}
/* eslint-disable object-shorthand */
Geometry.map = {
    Float32Array: Float32Array,
    Uint32Array: Uint32Array,
    Int32Array: Int32Array,
    Uint8Array: Uint8Array,
};
Geometry.UID$1 = 0;
/* eslint-disable object-shorthand */
Geometry.map$1 = {
    Float32Array: Float32Array,
    Uint32Array: Uint32Array,
    Int32Array: Int32Array,
    Uint8Array: Uint8Array,
    Uint16Array: Uint16Array,
};
Geometry.byteSizeMap = { 5126: 4, 5123: 2, 5121: 1 };
exports.Geometry = Geometry;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/GeometrySystem.js":
/*!**************************************************!*\
  !*** ./js-compile/raw-pixi-ts/GeometrySystem.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const System_1 = __webpack_require__(/*! ./System */ "./js-compile/raw-pixi-ts/System.js");
const GLBuffer_1 = __webpack_require__(/*! ./GLBuffer */ "./js-compile/raw-pixi-ts/GLBuffer.js");
const DisplaySettings_1 = __webpack_require__(/*! ./DisplaySettings */ "./js-compile/raw-pixi-ts/DisplaySettings.js");
class GeometrySystem extends System_1.System {
    constructor(renderer) {
        super(renderer);
        this._activeGeometry = null;
        this._activeVao = null;
        /**
         * `true` if we has `*_vertex_array_object` extension
         * @member {boolean}
         * @readonly
         */
        this.hasVao = true;
        /**
         * `true` if has `ANGLE_instanced_arrays` extension
         * @member {boolean}
         * @readonly
         */
        this.hasInstance = true;
        /**
         * A cache of currently bound buffer,
         * contains only two members with keys ARRAY_BUFFER and ELEMENT_ARRAY_BUFFER
         * @member {Object.<number, PIXI.Buffer>}
         * @readonly
         */
        this.boundBuffers = {};
        /**
         * Cache for all geometries by id, used in case renderer gets destroyed or for profiling
         * @member {object}
         * @readonly
         */
        this.managedGeometries = {};
        /**
         * Cache for all buffers by id, used in case renderer gets destroyed or for profiling
         * @member {object}
         * @readonly
         */
        this.managedBuffers = {};
    }
    /**
     * Sets up the renderer context and necessary buffers.
     */
    contextChange() {
        this.disposeAll(true);
        var gl = this.gl = this.renderer.gl;
        this.CONTEXT_UID = this.renderer.CONTEXT_UID;
        // webgl2
        if (!gl.createVertexArray) {
            // webgl 1!
            var nativeVaoExtension = this.renderer.context.extensions.vertexArrayObject;
            if (DisplaySettings_1.DisplaySettings.PREFER_ENV === DisplaySettings_1.DisplaySettings.ENV.WEBGL_LEGACY) {
                nativeVaoExtension = null;
            }
            if (nativeVaoExtension) {
                gl.createVertexArray = function () { return nativeVaoExtension.createVertexArrayOES(); };
                gl.bindVertexArray = function (vao) { return nativeVaoExtension.bindVertexArrayOES(vao); };
                gl.deleteVertexArray = function (vao) { return nativeVaoExtension.deleteVertexArrayOES(vao); };
            }
            else {
                this.hasVao = false;
                gl.createVertexArray = function () {
                    // empty
                };
                gl.bindVertexArray = function () {
                    // empty
                };
                gl.deleteVertexArray = function () {
                    // empty
                };
            }
        }
        if (!gl.vertexAttribDivisor) {
            var instanceExt = gl.getExtension('ANGLE_instanced_arrays');
            if (instanceExt) {
                gl.vertexAttribDivisor = function (a, b) { return instanceExt.vertexAttribDivisorANGLE(a, b); };
                gl.drawElementsInstanced = function (a, b, c, d, e) { return instanceExt.drawElementsInstancedANGLE(a, b, c, d, e); };
                gl.drawArraysInstanced = function (a, b, c, d) { return instanceExt.drawArraysInstancedANGLE(a, b, c, d); };
            }
            else {
                this.hasInstance = false;
            }
        }
    }
    ;
    /**
     * Binds geometry so that is can be drawn. Creating a Vao if required
     * @protected
     * @param {PIXI.Geometry} geometry instance of geometry to bind
     * @param {PIXI.Shader} shader instance of shader to bind
     */
    bind(geometry, shader = null) {
        shader = shader || this.renderer.shader.shader;
        var ref = this;
        var gl = ref.gl;
        // not sure the best way to address this..
        // currently different shaders require different VAOs for the same geometry
        // Still mulling over the best way to solve this one..
        // will likely need to modify the shader attribute locations at run time!
        var vaos = geometry.glVertexArrayObjects[this.CONTEXT_UID];
        if (!vaos) {
            this.managedGeometries[geometry.id] = geometry;
            // geometry.disposeRunner.add(this);
            geometry.glVertexArrayObjects[this.CONTEXT_UID] = vaos = {};
        }
        var vao = vaos[shader.program.id] || this.initGeometryVao(geometry, shader.program);
        this._activeGeometry = geometry;
        if (this._activeVao !== vao) {
            this._activeVao = vao;
            if (this.hasVao) {
                gl.bindVertexArray(vao);
            }
            else {
                this.activateVao(geometry, shader.program);
            }
        }
        // TODO - optimise later!
        // don't need to loop through if nothing changed!
        // maybe look to add an 'autoupdate' to geometry?
        this.updateBuffers();
    }
    ;
    /**
     * Reset and unbind any active VAO and geometry
     */
    reset() {
        this.unbind();
    }
    ;
    /**
     * Update buffers
     * @protected
     */
    updateBuffers() {
        var geometry = this._activeGeometry;
        var ref = this;
        var gl = ref.gl;
        // reveal(gl);
        for (var i = 0; i < geometry.buffers.length; i++) {
            var buffer = geometry.buffers[i];
            var glBuffer = buffer._glBuffers[this.CONTEXT_UID];
            if (buffer._updateID !== glBuffer.updateID) {
                glBuffer.updateID = buffer._updateID;
                // TODO can cache this on buffer! maybe added a getter / setter?
                var type = buffer.index ? gl.ELEMENT_ARRAY_BUFFER : gl.ARRAY_BUFFER;
                // TODO this could change if the VAO changes...
                // need to come up with a better way to cache..
                // if (this.boundBuffers[type] !== glBuffer)
                // {
                // this.boundBuffers[type] = glBuffer;
                gl.bindBuffer(type, glBuffer.buffer);
                // }
                this._boundBuffer = glBuffer;
                if (glBuffer.byteLength >= buffer.data.byteLength) {
                    // offset is always zero for now!
                    gl.bufferSubData(type, 0, buffer.data);
                }
                else {
                    var drawType = buffer.static ? gl.STATIC_DRAW : gl.DYNAMIC_DRAW;
                    glBuffer.byteLength = buffer.data.byteLength;
                    gl.bufferData(type, buffer.data, drawType);
                }
            }
        }
    }
    ;
    /**
     * Check compability between a geometry and a program
     * @protected
     * @param {PIXI.Geometry} geometry - Geometry instance
     * @param {PIXI.Program} program - Program instance
     */
    checkCompatibility(geometry, program) {
        // geometry must have at least all the attributes that the shader requires.
        var geometryAttributes = geometry.attributes;
        var shaderAttributes = program.attributeData;
        for (var j in shaderAttributes) {
            if (!geometryAttributes[j]) {
                throw new Error(("shader and geometry incompatible, geometry missing the \"" + j + "\" attribute"));
            }
        }
    }
    ;
    /**
     * Takes a geometry and program and generates a unique signature for them.
     *
     * @param {PIXI.Geometry} geometry to get signature from
     * @param {PIXI.Program} program to test geometry against
     * @returns {String} Unique signature of the geometry and program
     * @protected
     */
    getSignature(geometry, program) {
        var attribs = geometry.attributes;
        var shaderAttributes = program.attributeData;
        var strings = ['g', geometry.id];
        for (var i in attribs) {
            if (shaderAttributes[i]) {
                strings.push(i);
            }
        }
        return strings.join('-');
    }
    ;
    /**
     * Creates or gets Vao with the same structure as the geometry and stores it on the geometry.
     * If vao is created, it is bound automatically.
     *
     * @protected
     * @param {PIXI.Geometry} geometry - Instance of geometry to to generate Vao for
     * @param {PIXI.Program} program - Instance of program
     */
    initGeometryVao(geometry, program) {
        this.checkCompatibility(geometry, program);
        var gl = this.gl;
        var CONTEXT_UID = this.CONTEXT_UID;
        var signature = this.getSignature(geometry, program);
        var vaoObjectHash = geometry.glVertexArrayObjects[this.CONTEXT_UID];
        var vao = vaoObjectHash[signature];
        if (vao) {
            // this will give us easy access to the vao
            vaoObjectHash[program.id] = vao;
            return vao;
        }
        var buffers = geometry.buffers;
        var attributes = geometry.attributes;
        var tempStride = {};
        var tempStart = {};
        for (var j in buffers) {
            tempStride[j] = 0;
            tempStart[j] = 0;
        }
        for (var j$1 in attributes) {
            if (!attributes[j$1].size && program.attributeData[j$1]) {
                attributes[j$1].size = program.attributeData[j$1].size;
            }
            else if (!attributes[j$1].size) {
                console.warn(("PIXI Geometry attribute '" + j$1 + "' size cannot be determined (likely the bound shader does not have the attribute)")); // eslint-disable-line
            }
            tempStride[attributes[j$1].buffer] += attributes[j$1].size * GeometrySystem.byteSizeMap$1[attributes[j$1].type];
        }
        for (var j$2 in attributes) {
            var attribute = attributes[j$2];
            var attribSize = attribute.size;
            if (attribute.stride === undefined) {
                if (tempStride[attribute.buffer] === attribSize * GeometrySystem.byteSizeMap$1[attribute.type]) {
                    attribute.stride = 0;
                }
                else {
                    attribute.stride = tempStride[attribute.buffer];
                }
            }
            if (attribute.start === undefined) {
                attribute.start = tempStart[attribute.buffer];
                tempStart[attribute.buffer] += attribSize * GeometrySystem.byteSizeMap$1[attribute.type];
            }
        }
        vao = gl.createVertexArray();
        gl.bindVertexArray(vao);
        // first update - and create the buffers!
        // only create a gl buffer if it actually gets
        for (var i = 0; i < buffers.length; i++) {
            var buffer = buffers[i];
            if (!buffer._glBuffers[CONTEXT_UID]) {
                buffer._glBuffers[CONTEXT_UID] = new GLBuffer_1.GLBuffer(gl.createBuffer());
                this.managedBuffers[buffer.id] = buffer;
                // buffer.disposeRunner.add(this);
            }
            buffer._glBuffers[CONTEXT_UID].refCount++;
        }
        // TODO - maybe make this a data object?
        // lets wait to see if we need to first!
        this.activateVao(geometry, program);
        this._activeVao = vao;
        // add it to the cache!
        vaoObjectHash[program.id] = vao;
        vaoObjectHash[signature] = vao;
        return vao;
    }
    ;
    /**
     * Disposes buffer
     * @param {PIXI.Buffer} buffer buffer with data
     * @param {boolean} [contextLost=false] If context was lost, we suppress deleteVertexArray
     */
    disposeBuffer(buffer, contextLost) {
        if (!this.managedBuffers[buffer.id]) {
            return;
        }
        delete this.managedBuffers[buffer.id];
        var glBuffer = buffer._glBuffers[this.CONTEXT_UID];
        var gl = this.gl;
        // buffer.disposeRunner.remove(this);
        if (!glBuffer) {
            return;
        }
        if (!contextLost) {
            gl.deleteBuffer(glBuffer.buffer);
        }
        delete buffer._glBuffers[this.CONTEXT_UID];
    }
    ;
    /**
     * Disposes geometry
     * @param {PIXI.Geometry} geometry Geometry with buffers. Only VAO will be disposed
     * @param {boolean} [contextLost=false] If context was lost, we suppress deleteVertexArray
     */
    disposeGeometry(geometry, contextLost) {
        if (!this.managedGeometries[geometry.id]) {
            return;
        }
        delete this.managedGeometries[geometry.id];
        var vaos = geometry.glVertexArrayObjects[this.CONTEXT_UID];
        var gl = this.gl;
        var buffers = geometry.buffers;
        geometry.disposeRunner.remove(this);
        if (!vaos) {
            return;
        }
        for (var i = 0; i < buffers.length; i++) {
            var buf = buffers[i]._glBuffers[this.CONTEXT_UID];
            buf.refCount--;
            if (buf.refCount === 0 && !contextLost) {
                this.disposeBuffer(buffers[i], contextLost);
            }
        }
        if (!contextLost) {
            for (var vaoId in vaos) {
                // delete only signatures, everything else are copies
                if (vaoId[0] === 'g') {
                    var vao = vaos[vaoId];
                    if (this._activeVao === vao) {
                        this.unbind();
                    }
                    gl.deleteVertexArray(vao);
                }
            }
        }
        delete geometry.glVertexArrayObjects[this.CONTEXT_UID];
    }
    ;
    /**
     * dispose all WebGL resources of all managed geometries and buffers
     * @param {boolean} [contextLost=false] If context was lost, we suppress `gl.delete` calls
     */
    disposeAll(contextLost) {
        var all = Object.keys(this.managedGeometries);
        for (var i = 0; i < all.length; i++) {
            this.disposeGeometry(this.managedGeometries[all[i]], contextLost);
        }
        all = Object.keys(this.managedBuffers);
        for (var i$1 = 0; i$1 < all.length; i$1++) {
            this.disposeBuffer(this.managedBuffers[all[i$1]], contextLost);
        }
    }
    ;
    /**
     * Activate vertex array object
     *
     * @protected
     * @param {PIXI.Geometry} geometry - Geometry instance
     * @param {PIXI.Program} program - Shader program instance
     */
    activateVao(geometry, program) {
        var gl = this.gl;
        var CONTEXT_UID = this.CONTEXT_UID;
        var buffers = geometry.buffers;
        var attributes = geometry.attributes;
        if (geometry.indexBuffer) {
            // first update the index buffer if we have one..
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, geometry.indexBuffer._glBuffers[CONTEXT_UID].buffer);
        }
        var lastBuffer = null;
        // add a new one!
        for (var j in attributes) {
            var attribute = attributes[j];
            var buffer = buffers[attribute.buffer];
            var glBuffer = buffer._glBuffers[CONTEXT_UID];
            if (program.attributeData[j]) {
                if (lastBuffer !== glBuffer) {
                    gl.bindBuffer(gl.ARRAY_BUFFER, glBuffer.buffer);
                    lastBuffer = glBuffer;
                }
                var location = program.attributeData[j].location;
                // TODO introduce state again
                // we can optimise this for older devices that have no VAOs
                gl.enableVertexAttribArray(location);
                gl.vertexAttribPointer(location, attribute.size, attribute.type || gl.FLOAT, attribute.normalized, attribute.stride, attribute.start);
                if (attribute.instance) {
                    // TODO calculate instance count based of this...
                    if (this.hasInstance) {
                        gl.vertexAttribDivisor(location, 1);
                    }
                    else {
                        throw new Error('geometry error, GPU Instancing is not supported on this device');
                    }
                }
            }
        }
    }
    ;
    /**
     * Draw the geometry
     *
     * @param {Number} type - the type primitive to render
     * @param {Number} [size] - the number of elements to be rendered
     * @param {Number} [start] - Starting index
     * @param {Number} [instanceCount] - the number of instances of the set of elements to execute
     */
    draw(type, size = -1, start = 0, instanceCount = 1) {
        var ref = this;
        var gl = ref.gl;
        var geometry = this._activeGeometry;
        // TODO.. this should not change so maybe cache the function?
        if (size < 0) {
            size = geometry.indexBuffer.data.length;
        }
        if (geometry.indexBuffer) {
            if (geometry.instanced) {
                /* eslint-disable max-len */
                gl.drawElementsInstanced(type, size || geometry.indexBuffer.data.length, gl.UNSIGNED_SHORT, (start || 0) * 2, instanceCount || 1);
                /* eslint-enable max-len */
            }
            else {
                gl.drawElements(type, size || geometry.indexBuffer.data.length, gl.UNSIGNED_SHORT, (start || 0) * 2);
            }
        }
        else if (geometry.instanced) {
            // TODO need a better way to calculate size..
            gl.drawArraysInstanced(type, start, size || geometry.getSize(), instanceCount || 1);
        }
        else {
            gl.drawArrays(type, start, size || geometry.getSize());
        }
        return this;
    }
    ;
    /**
     * Unbind/reset everything
     * @protected
     */
    unbind() {
        this.gl.bindVertexArray(null);
        this._activeVao = null;
        this._activeGeometry = null;
    }
    ;
}
GeometrySystem.byteSizeMap$1 = { 5126: 4, 5123: 2, 5121: 1 };
exports.GeometrySystem = GeometrySystem;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/Graphics.js":
/*!********************************************!*\
  !*** ./js-compile/raw-pixi-ts/Graphics.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Container_1 = __webpack_require__(/*! ./Container */ "./js-compile/raw-pixi-ts/Container.js");
const State_1 = __webpack_require__(/*! ./State */ "./js-compile/raw-pixi-ts/State.js");
const FillStyle_1 = __webpack_require__(/*! ./FillStyle */ "./js-compile/raw-pixi-ts/FillStyle.js");
// import { settings } from "./settings";
const Texture_1 = __webpack_require__(/*! ./Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const Rectangle_1 = __webpack_require__(/*! ./Rectangle */ "./js-compile/raw-pixi-ts/Rectangle.js");
const Matrix_1 = __webpack_require__(/*! ./Matrix */ "./js-compile/raw-pixi-ts/Matrix.js");
const UniformGroup_1 = __webpack_require__(/*! ./UniformGroup */ "./js-compile/raw-pixi-ts/UniformGroup.js");
const Shader_1 = __webpack_require__(/*! ./Shader */ "./js-compile/raw-pixi-ts/Shader.js");
const Point_1 = __webpack_require__(/*! ./Point */ "./js-compile/raw-pixi-ts/Point.js");
const Polygon_1 = __webpack_require__(/*! ./Polygon */ "./js-compile/raw-pixi-ts/Polygon.js");
const Ellipse_1 = __webpack_require__(/*! ./Ellipse */ "./js-compile/raw-pixi-ts/Ellipse.js");
const Circle_1 = __webpack_require__(/*! ./Circle */ "./js-compile/raw-pixi-ts/Circle.js");
const RoundedRectangle_1 = __webpack_require__(/*! ./RoundedRectangle */ "./js-compile/raw-pixi-ts/RoundedRectangle.js");
const ArcUtils_1 = __webpack_require__(/*! ./ArcUtils */ "./js-compile/raw-pixi-ts/ArcUtils.js");
const BezierUtils_1 = __webpack_require__(/*! ./BezierUtils */ "./js-compile/raw-pixi-ts/BezierUtils.js");
const QuadraticUtils_1 = __webpack_require__(/*! ./QuadraticUtils */ "./js-compile/raw-pixi-ts/QuadraticUtils.js");
const LineStyle_1 = __webpack_require__(/*! ./LineStyle */ "./js-compile/raw-pixi-ts/LineStyle.js");
const GraphicsGeometry_1 = __webpack_require__(/*! ./GraphicsGeometry */ "./js-compile/raw-pixi-ts/GraphicsGeometry.js");
const Star_1 = __webpack_require__(/*! ./Star */ "./js-compile/raw-pixi-ts/Star.js");
const MathSettings_1 = __webpack_require__(/*! ./MathSettings */ "./js-compile/raw-pixi-ts/MathSettings.js");
const BlendModesSettings_1 = __webpack_require__(/*! ./BlendModesSettings */ "./js-compile/raw-pixi-ts/BlendModesSettings.js");
const ColorSettings_1 = __webpack_require__(/*! ./ColorSettings */ "./js-compile/raw-pixi-ts/ColorSettings.js");
class Graphics extends Container_1.Container {
    constructor(geometry = null) {
        super();
        if (geometry === void 0) {
            geometry = null;
        }
        /**
         * Includes vertex positions, face indices, normals, colors, UVs, and
         * custom attributes within buffers, reducing the cost of passing all
         * this data to the GPU. Can be shared between multiple Mesh or Graphics objects.
         * @member {PIXI.GraphicsGeometry}
         * @readonly
         */
        this.geometry = geometry || new GraphicsGeometry_1.GraphicsGeometry();
        this.geometry.refCount++;
        /**
         * Represents the vertex and fragment shaders that processes the geometry and runs on the GPU.
         * Can be shared between multiple Graphics objects.
         * @member {PIXI.Shader}
         */
        this.shader = null;
        /**
         * Represents the WebGL state the Graphics required to render, excludes shader and geometry. E.g.,
         * blend mode, culling, depth testing, direction of rendering triangles, backface, etc.
         * @member {PIXI.State}
         */
        this.state = State_1.State.for2d();
        /**
         * Current fill style
         *
         * @member {PIXI.FillStyle}
         * @protected
         */
        this._fillStyle = new FillStyle_1.FillStyle();
        /**
         * Current line style
         *
         * @member {PIXI.LineStyle}
         * @protected
         */
        this._lineStyle = new LineStyle_1.LineStyle();
        /**
         * Current shape transform matrix.
         *
         * @member {PIXI.Matrix}
         * @protected
         */
        this._matrix = null;
        /**
         * Current hole mode is enabled.
         *
         * @member {boolean}
         * @default false
         * @protected
         */
        this._holeMode = false;
        /**
         * Current path
         *
         * @member {PIXI.Polygon}
         * @protected
         */
        this.currentPath = null;
        /**
         * When cacheAsBitmap is set to true the graphics object will be rendered as if it was a sprite.
         * This is useful if your graphics element does not change often, as it will speed up the rendering
         * of the object in exchange for taking up texture memory. It is also useful if you need the graphics
         * object to be anti-aliased, because it will be rendered using canvas. This is not recommended if
         * you are constantly redrawing the graphics element.
         *
         * @name cacheAsBitmap
         * @member {boolean}
         * @memberof PIXI.Graphics#
         * @default false
         */
        /**
         * A collections of batches! These can be drawn by the renderer batch system.
         *
         * @protected
         * @member {object[]}
         */
        this.batches = [];
        /**
         * Update dirty for limiting calculating tints for batches.
         *
         * @protected
         * @member {number}
         * @default -1
         */
        this.batchTint = -1;
        /**
         * Copy of the object vertex data.
         *
         * @protected
         * @member {Float32Array}
         */
        this.vertexData = null;
        this._transformID = -1;
        this.batchDirty = -1;
        // Set default
        this.tint = 0xFFFFFF;
        this.blendMode = BlendModesSettings_1.BlendModesSettings.BLEND_MODES.NORMAL;
    }
    /**
     * Creates a new Graphics object with the same values as this one.
     * Note that the only the properties of the object are cloned, not its transform (position,scale,etc)
     *
     * @return {PIXI.Graphics} A clone of the graphics object
     */
    clone() {
        this.finishPoly();
        return new Graphics(this.geometry);
    }
    ;
    /**
     * The blend mode to be applied to the graphic shape. Apply a value of
     * `PIXI.BLEND_MODES.NORMAL` to reset the blend mode.
     *
     * @member {number}
     * @default PIXI.BLEND_MODES.NORMAL;
     * @see PIXI.BLEND_MODES
     */
    set blendMode(value) {
        this.state.blendMode = value;
    }
    ;
    get blendMode() {
        return this.state.blendMode;
    }
    ;
    /**
     * The tint applied to the graphic shape. This is a hex value. A value of
     * 0xFFFFFF will remove any tint effect.
     *
     * @member {number}
     * @default 0xFFFFFF
     */
    get tint() {
        return this._tint;
    }
    ;
    set tint(value) {
        this._tint = value;
    }
    ;
    /**
     * The current fill style.
     *
     * @member {PIXI.FillStyle}
     * @readonly
     */
    get fill() {
        return this._fillStyle;
    }
    ;
    /**
     * The current line style.
     *
     * @member {PIXI.LineStyle}
     * @readonly
     */
    get line() {
        return this._lineStyle;
    }
    ;
    /**
     * Specifies the line style used for subsequent calls to Graphics methods such as the lineTo()
     * method or the drawCircle() method.
     *
     * @param {number} [width=0] - width of the line to draw, will update the objects stored style
     * @param {number} [color=0] - color of the line to draw, will update the objects stored style
     * @param {number} [alpha=1] - alpha of the line to draw, will update the objects stored style
     * @param {number} [alignment=1] - alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outter)
     * @param {boolean} [native=false] - If true the lines will be draw using LINES instead of TRIANGLE_STRIP
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */
    lineStyle(width, color = 0, alpha = 1, alignment = 0.5, native = false) {
        if (width === void 0) {
            width = 0;
        }
        if (color === void 0) {
            color = 0;
        }
        if (alpha === void 0) {
            alpha = 1;
        }
        if (alignment === void 0) {
            alignment = 0.5;
        }
        if (native === void 0) {
            native = false;
        }
        this.lineTextureStyle(width, Texture_1.Texture.WHITE, color, alpha, null, alignment, native);
        return this;
    }
    ;
    /**
     * Like line style but support texture for line fill.
     *
     * @param {number} [width=0] - width of the line to draw, will update the objects stored style
     * @param {PIXI.Texture} [texture=PIXI.Texture.WHITE] - Texture to use
     * @param {number} [color=0] - color of the line to draw, will update the objects stored style
     * @param {number} [alpha=1] - alpha of the line to draw, will update the objects stored style
     * @param {PIXI.Matrix} [matrix=null] Texture matrix to transform texture
     * @param {number} [alignment=0.5] - alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outter)
     * @param {boolean} [native=false] - If true the lines will be draw using LINES instead of TRIANGLE_STRIP
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */
    lineTextureStyle(width = 0, texture = Texture_1.Texture.WHITE, color = 0xFFFFFF, alpha = 1, matrix = null, alignment = 0.5, native = false) {
        if (width === void 0) {
            width = 0;
        }
        if (texture === void 0) {
            texture = Texture_1.Texture.WHITE;
        }
        if (color === void 0) {
            color = 0xFFFFFF;
        }
        if (alpha === void 0) {
            alpha = 1;
        }
        if (matrix === void 0) {
            matrix = null;
        }
        if (alignment === void 0) {
            alignment = 0.5;
        }
        if (native === void 0) {
            native = false;
        }
        if (this.currentPath) {
            this.startPoly();
        }
        var visible = width > 0 && alpha > 0;
        if (!visible) {
            this._lineStyle.reset();
        }
        else {
            if (matrix) {
                matrix = matrix.clone();
                matrix.invert();
            }
            Object.assign(this._lineStyle, {
                color: color,
                width: width,
                alpha: alpha,
                matrix: matrix,
                texture: texture,
                alignment: alignment,
                native: native,
                visible: visible,
            });
        }
        return this;
    }
    ;
    /**
     * Start a polygon object internally
     * @protected
     */
    startPoly() {
        if (this.currentPath) {
            var points = this.currentPath.points;
            var len = this.currentPath.points.length;
            if (len > 2) {
                this.drawShape(this.currentPath);
                this.currentPath = new Polygon_1.Polygon();
                this.currentPath.closeStroke = false;
                this.currentPath.points.push(points[len - 2], points[len - 1]);
            }
        }
        else {
            this.currentPath = new Polygon_1.Polygon();
            this.currentPath.closeStroke = false;
        }
    }
    ;
    /**
     * Finish the polygon object.
     * @protected
     */
    finishPoly() {
        if (this.currentPath) {
            if (this.currentPath.points.length > 2) {
                this.drawShape(this.currentPath);
                this.currentPath = null;
            }
            else {
                this.currentPath.points.length = 0;
            }
        }
    }
    ;
    /**
     * Moves the current drawing position to x, y.
     *
     * @param {number} x - the X coordinate to move to
     * @param {number} y - the Y coordinate to move to
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */
    moveTo(x, y) {
        this.startPoly();
        this.currentPath.points[0] = x;
        this.currentPath.points[1] = y;
        return this;
    }
    ;
    /**
     * Draws a line using the current line style from the current drawing position to (x, y);
     * The current drawing position is then set to (x, y).
     *
     * @param {number} x - the X coordinate to draw to
     * @param {number} y - the Y coordinate to draw to
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */
    lineTo(x, y) {
        if (!this.currentPath) {
            this.moveTo(0, 0);
        }
        // remove duplicates..
        var points = this.currentPath.points;
        var fromX = points[points.length - 2];
        var fromY = points[points.length - 1];
        if (fromX !== x || fromY !== y) {
            points.push(x, y);
        }
        return this;
    }
    ;
    /**
     * Initialize the curve
     *
     * @protected
     * @param {number} [x=0]
     * @param {number} [y=0]
     */
    _initCurve(x = 0, y = 0) {
        if (x === void 0) {
            x = 0;
        }
        if (y === void 0) {
            y = 0;
        }
        if (this.currentPath) {
            if (this.currentPath.points.length === 0) {
                this.currentPath.points = [x, y];
            }
        }
        else {
            this.moveTo(x, y);
        }
    }
    ;
    /**
     * Calculate the points for a quadratic bezier curve and then draws it.
     * Based on: https://stackoverflow.com/questions/785097/how-do-i-implement-a-bezier-curve-in-c
     *
     * @param {number} cpX - Control point x
     * @param {number} cpY - Control point y
     * @param {number} toX - Destination point x
     * @param {number} toY - Destination point y
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */
    quadraticCurveTo(cpX, cpY, toX, toY) {
        this._initCurve();
        var points = this.currentPath.points;
        if (points.length === 0) {
            this.moveTo(0, 0);
        }
        QuadraticUtils_1.QuadraticUtils.curveTo(cpX, cpY, toX, toY, points);
        return this;
    }
    ;
    /**
     * Calculate the points for a bezier curve and then draws it.
     *
     * @param {number} cpX - Control point x
     * @param {number} cpY - Control point y
     * @param {number} cpX2 - Second Control point x
     * @param {number} cpY2 - Second Control point y
     * @param {number} toX - Destination point x
     * @param {number} toY - Destination point y
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */
    bezierCurveTo(cpX, cpY, cpX2, cpY2, toX, toY) {
        this._initCurve();
        BezierUtils_1.BezierUtils.curveTo(cpX, cpY, cpX2, cpY2, toX, toY, this.currentPath.points);
        return this;
    }
    ;
    /**
     * The arcTo() method creates an arc/curve between two tangents on the canvas.
     *
     * "borrowed" from https://code.google.com/p/fxcanvas/ - thanks google!
     *
     * @param {number} x1 - The x-coordinate of the beginning of the arc
     * @param {number} y1 - The y-coordinate of the beginning of the arc
     * @param {number} x2 - The x-coordinate of the end of the arc
     * @param {number} y2 - The y-coordinate of the end of the arc
     * @param {number} radius - The radius of the arc
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */
    arcTo(x1, y1, x2, y2, radius) {
        this._initCurve(x1, y1);
        var points = this.currentPath.points;
        var result = ArcUtils_1.ArcUtils.curveTo(x1, y1, x2, y2, radius, points);
        if (result) {
            var cx = result.cx;
            var cy = result.cy;
            var radius$1 = result.radius;
            var startAngle = result.startAngle;
            var endAngle = result.endAngle;
            var anticlockwise = result.anticlockwise;
            this.arc(cx, cy, radius$1, startAngle, endAngle, anticlockwise);
        }
        return this;
    }
    ;
    /**
     * The arc method creates an arc/curve (used to create circles, or parts of circles).
     *
     * @param {number} cx - The x-coordinate of the center of the circle
     * @param {number} cy - The y-coordinate of the center of the circle
     * @param {number} radius - The radius of the circle
     * @param {number} startAngle - The starting angle, in radians (0 is at the 3 o'clock position
     *  of the arc's circle)
     * @param {number} endAngle - The ending angle, in radians
     * @param {boolean} [anticlockwise=false] - Specifies whether the drawing should be
     *  counter-clockwise or clockwise. False is default, and indicates clockwise, while true
     *  indicates counter-clockwise.
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */
    arc(cx, cy, radius, startAngle, endAngle, anticlockwise = false) {
        if (anticlockwise === void 0) {
            anticlockwise = false;
        }
        if (startAngle === endAngle) {
            return this;
        }
        if (!anticlockwise && endAngle <= startAngle) {
            endAngle += MathSettings_1.MathSettings.PI_2;
        }
        else if (anticlockwise && startAngle <= endAngle) {
            startAngle += MathSettings_1.MathSettings.PI_2;
        }
        var sweep = endAngle - startAngle;
        if (sweep === 0) {
            return this;
        }
        var startX = cx + (Math.cos(startAngle) * radius);
        var startY = cy + (Math.sin(startAngle) * radius);
        // If the currentPath exists, take its points. Otherwise call `moveTo` to start a path.
        var points = this.currentPath ? this.currentPath.points : null;
        if (points) {
            // TODO: make a better fix.
            // We check how far our start is from the last existing point
            var xDiff = Math.abs(points[points.length - 2] - startX);
            var yDiff = Math.abs(points[points.length - 1] - startY);
            if (xDiff < 0.001 && yDiff < 0.001) {
                ;
            }
            else {
                points.push(startX, startY);
            }
        }
        else {
            this.moveTo(startX, startY);
            points = this.currentPath.points;
        }
        ArcUtils_1.ArcUtils.arc(startX, startY, cx, cy, radius, startAngle, endAngle, anticlockwise, points);
        return this;
    }
    ;
    /**
     * Specifies a simple one-color fill that subsequent calls to other Graphics methods
     * (such as lineTo() or drawCircle()) use when drawing.
     *
     * @param {number} [color=0] - the color of the fill
     * @param {number} [alpha=1] - the alpha of the fill
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */
    beginFill(color = 0, alpha = 1) {
        return this.beginTextureFill(Texture_1.Texture.WHITE, color, alpha);
    }
    ;
    /**
     * Begin the texture fill
     *
     * @param {PIXI.Texture} [texture=PIXI.Texture.WHITE] - Texture to fill
     * @param {number} [color=0xffffff] - Background to fill behind texture
     * @param {number} [alpha=1] - Alpha of fill
     * @param {PIXI.Matrix} [matrix=null] - Transform matrix
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */
    beginTextureFill(texture, color, alpha, matrix = null) {
        if (texture === void 0) {
            texture = Texture_1.Texture.WHITE;
        }
        if (color === void 0) {
            color = 0xFFFFFF;
        }
        if (alpha === void 0) {
            alpha = 1;
        }
        if (matrix === void 0) {
            matrix = null;
        }
        if (this.currentPath) {
            this.startPoly();
        }
        var visible = alpha > 0;
        if (!visible) {
            this._fillStyle.reset();
        }
        else {
            if (matrix) {
                matrix = matrix.clone();
                matrix.invert();
            }
            Object.assign(this._fillStyle, {
                color: color,
                alpha: alpha,
                texture: texture,
                matrix: matrix,
                visible: visible,
            });
        }
        return this;
    }
    ;
    /**
     * Applies a fill to the lines and shapes that were added since the last call to the beginFill() method.
     *
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */
    endFill() {
        this.finishPoly();
        this._fillStyle.reset();
        return this;
    }
    ;
    /**
     * Draws a rectangle shape.
     *
     * @param {number} x - The X coord of the top-left of the rectangle
     * @param {number} y - The Y coord of the top-left of the rectangle
     * @param {number} width - The width of the rectangle
     * @param {number} height - The height of the rectangle
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */
    drawRect(x, y, width, height) {
        return this.drawShape(new Rectangle_1.Rectangle(x, y, width, height));
    }
    ;
    /**
     * Draw a rectangle shape with rounded/beveled corners.
     *
     * @param {number} x - The X coord of the top-left of the rectangle
     * @param {number} y - The Y coord of the top-left of the rectangle
     * @param {number} width - The width of the rectangle
     * @param {number} height - The height of the rectangle
     * @param {number} radius - Radius of the rectangle corners
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */
    drawRoundedRect(x, y, width, height, radius) {
        return this.drawShape(new RoundedRectangle_1.RoundedRectangle(x, y, width, height, radius));
    }
    ;
    /**
     * Draws a circle.
     *
     * @param {number} x - The X coordinate of the center of the circle
     * @param {number} y - The Y coordinate of the center of the circle
     * @param {number} radius - The radius of the circle
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */
    drawCircle(x, y, radius) {
        return this.drawShape(new Circle_1.Circle(x, y, radius));
    }
    ;
    /**
     * Draws an ellipse.
     *
     * @param {number} x - The X coordinate of the center of the ellipse
     * @param {number} y - The Y coordinate of the center of the ellipse
     * @param {number} width - The half width of the ellipse
     * @param {number} height - The half height of the ellipse
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */
    drawEllipse(x, y, width, height) {
        return this.drawShape(new Ellipse_1.Ellipse(x, y, width, height));
    }
    ;
    /**
     * Draws a polygon using the given path.
     *
     * @param {number[]|PIXI.Point[]|PIXI.Polygon} path - The path data used to construct the polygon.
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */
    drawPolygon(path) {
        var arguments$1 = arguments;
        // prevents an argument assignment deopt
        // see section 3.1: https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#3-managing-arguments
        var points = path;
        var closeStroke = true; // !!this._fillStyle;
        // check if data has points..
        if (points.points) {
            closeStroke = points.closeStroke;
            points = points.points;
        }
        if (!Array.isArray(points)) {
            // prevents an argument leak deopt
            // see section 3.2: https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#3-managing-arguments
            points = new Array(arguments.length);
            for (var i = 0; i < points.length; ++i) {
                points[i] = arguments$1[i]; // eslint-disable-line prefer-rest-params
            }
        }
        var shape = new Polygon_1.Polygon(points);
        shape.closeStroke = closeStroke;
        this.drawShape(shape);
        return this;
    }
    ;
    /**
     * Draw any shape.
     *
     * @param {PIXI.Circle|PIXI.Ellipse|PIXI.Polygon|PIXI.Rectangle|PIXI.RoundedRectangle} shape - Shape to draw
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */
    drawShape(shape) {
        if (!this._holeMode) {
            this.geometry.drawShape(shape, this._fillStyle.clone(), this._lineStyle.clone(), this._matrix);
        }
        else {
            this.geometry.drawHole(shape, this._matrix);
        }
        return this;
    }
    ;
    /**
     * Draw a star shape with an arbitrary number of points.
     *
     * @param {number} x - Center X position of the star
     * @param {number} y - Center Y position of the star
     * @param {number} points - The number of points of the star, must be > 1
     * @param {number} radius - The outer radius of the star
     * @param {number} [innerRadius] - The inner radius between points, default half `radius`
     * @param {number} [rotation=0] - The rotation of the star in radians, where 0 is vertical
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */
    drawStar(x, y, points, radius, innerRadius = 0, rotation = 0) {
        if (rotation === void 0) {
            rotation = 0;
        }
        return this.drawPolygon(new Star_1.Star(x, y, points, radius, innerRadius, rotation));
    }
    ;
    /**
     * Clears the graphics that were drawn to this Graphics object, and resets fill and line style settings.
     *
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */
    clear() {
        this.geometry.clear();
        this._matrix = null;
        this._holeMode = false;
        this.currentPath = null;
        this._spriteRect = null;
        return this;
    }
    ;
    /**
     * True if graphics consists of one rectangle, and thus, can be drawn like a Sprite and
     * masked with gl.scissor.
     *
     * @returns {boolean} True if only 1 rect.
     */
    isFastRect() {
        // will fix this!
        return false;
        // this.graphicsData.length === 1
        //  && this.graphicsData[0].shape.type === SHAPES.RECT
        // && !this.graphicsData[0].lineWidth;
    }
    ;
    /**
     * Renders the object using the WebGL renderer
     *
     * @protected
     * @param {PIXI.Renderer} renderer - The renderer
     */
    _render(renderer) {
        this.finishPoly();
        var geometry = this.geometry;
        // batch part..
        // batch it!
        geometry.updateBatches();
        if (geometry.batchable) {
            if (this.batchDirty !== geometry.batchDirty) {
                this.batches = [];
                this.batchTint = -1;
                this._transformID = -1;
                this.batchDirty = geometry.batchDirty;
                this.vertexData = new Float32Array(geometry.points);
                var blendMode = this.blendMode;
                for (var i = 0; i < geometry.batches.length; i++) {
                    var gI = geometry.batches[i];
                    var color = gI.style.color;
                    //        + (alpha * 255 << 24);
                    var vertexData = new Float32Array(this.vertexData.buffer, gI.attribStart * 4 * 2, gI.attribSize * 2);
                    var uvs = new Float32Array(geometry.uvsFloat32.buffer, gI.attribStart * 4 * 2, gI.attribSize * 2);
                    var indices = new Uint16Array(geometry.indicesUint16.buffer, gI.start * 2, gI.size);
                    var batch = {
                        vertexData: vertexData,
                        blendMode: blendMode,
                        indices: indices,
                        uvs: uvs,
                        _batchRGB: ColorSettings_1.ColorSettings.hex2rgb(color),
                        _tintRGB: color,
                        _texture: gI.style.texture,
                        alpha: gI.style.alpha,
                        worldAlpha: 1
                    };
                    this.batches[i] = batch;
                }
            }
            renderer.batch.setObjectRenderer(renderer.plugins.batch);
            if (this.batches.length) {
                this.calculateVertices();
                this.calculateTints();
                for (var i$1 = 0; i$1 < this.batches.length; i$1++) {
                    var batch$1 = this.batches[i$1];
                    batch$1.worldAlpha = this.worldAlpha * batch$1.alpha;
                    renderer.plugins.batch.render(batch$1);
                }
            }
        }
        else {
            // no batching...
            renderer.batch.flush();
            if (!this.shader) {
                // if there is no shader here, we can use the default shader.
                // and that only gets created if we actually need it..
                if (!Graphics.defaultShader) {
                    var sampleValues = new Int32Array(16);
                    for (var i$2 = 0; i$2 < 16; i$2++) {
                        sampleValues[i$2] = i$2;
                    }
                    var uniforms = {
                        tint: new Float32Array([1, 1, 1, 1]),
                        translationMatrix: new Matrix_1.Matrix(),
                        default: UniformGroup_1.UniformGroup.from({ uSamplers: sampleValues }, true),
                    };
                    // we can bbase default shader of the batch renderers program
                    var program = renderer.plugins.batch.shader.program;
                    Graphics.defaultShader = new Shader_1.Shader(program, uniforms);
                }
                this.shader = Graphics.defaultShader;
            }
            var uniforms$1 = this.shader.uniforms;
            // lets set the transfomr
            uniforms$1.translationMatrix = this.transform.worldTransform;
            var tint = this.tint;
            var wa = this.worldAlpha;
            // and then lets set the tint..
            uniforms$1.tint[0] = (((tint >> 16) & 0xFF) / 255) * wa;
            uniforms$1.tint[1] = (((tint >> 8) & 0xFF) / 255) * wa;
            uniforms$1.tint[2] = ((tint & 0xFF) / 255) * wa;
            uniforms$1.tint[3] = wa;
            // the first draw call, we can set the uniforms of the shader directly here.
            // this means that we can tack advantage of the sync function of pixi!
            // bind and sync uniforms..
            // there is a way to optimise this..
            renderer.shader.bind(this.shader);
            // then render it
            renderer.geometry.bind(geometry, this.shader);
            // set state..
            renderer.state.setState(this.state);
            // then render the rest of them...
            for (var i$3 = 0; i$3 < geometry.drawCalls.length; i$3++) {
                var drawCall = geometry.drawCalls[i$3];
                var groupTextureCount = drawCall.textureCount;
                for (var j = 0; j < groupTextureCount; j++) {
                    renderer.texture.bind(drawCall.textures[j], j);
                }
                // bind the geometry...
                renderer.geometry.draw(drawCall.type, drawCall.size, drawCall.start);
            }
        }
    }
    ;
    /**
     * Retrieves the bounds of the graphic shape as a rectangle object
     *
     * @protected
     */
    _calculateBounds() {
        this.finishPoly();
        var lb = this.geometry.bounds;
        this._bounds.addFrame(this.transform, lb.minX, lb.minY, lb.maxX, lb.maxY);
    }
    ;
    /**
     * Tests if a point is inside this graphics object
     *
     * @param {PIXI.Point} point - the point to test
     * @return {boolean} the result of the test
     */
    containsPoint(point) {
        this.worldTransform.applyInverse(point, Graphics._TEMP_POINT);
        return this.geometry.containsPoint(Graphics._TEMP_POINT);
    }
    ;
    /**
     * Recalcuate the tint by applying tin to batches using Graphics tint.
     * @protected
     */
    calculateTints() {
        if (this.batchTint !== this.tint) {
            this.batchTint = this.tint;
            var tintRGB = ColorSettings_1.ColorSettings.hex2rgb(this.tint, Graphics.temp);
            for (var i = 0; i < this.batches.length; i++) {
                var batch = this.batches[i];
                var batchTint = batch._batchRGB;
                var r = (tintRGB[0] * batchTint[0]) * 255;
                var g = (tintRGB[1] * batchTint[1]) * 255;
                var b = (tintRGB[2] * batchTint[2]) * 255;
                // TODO Ivan, can this be done in one go?
                var color = (r << 16) + (g << 8) + (b | 0);
                batch._tintRGB = (color >> 16)
                    + (color & 0xff00)
                    + ((color & 0xff) << 16);
            }
        }
    }
    ;
    /**
     * If there's a transform update or a change to the shape of the
     * geometry, recaculate the vertices.
     * @protected
     */
    calculateVertices() {
        if (this._transformID === this.transform._worldID) {
            return;
        }
        this._transformID = this.transform._worldID;
        var wt = this.transform.worldTransform;
        // reveal(wt)
        var a = wt.a;
        var b = wt.b;
        var c = wt.c;
        var d = wt.d;
        var tx = wt.tx;
        var ty = wt.ty;
        var data = this.geometry.points; // batch.vertexDataOriginal;
        var vertexData = this.vertexData;
        var count = 0;
        for (var i = 0; i < data.length; i += 2) {
            var x = data[i];
            var y = data[i + 1];
            vertexData[count++] = (a * x) + (c * y) + tx;
            vertexData[count++] = (d * y) + (b * x) + ty;
        }
    }
    ;
    /**
     * Closes the current path.
     *
     * @return {PIXI.Graphics} Returns itself.
     */
    closePath() {
        var currentPath = this.currentPath;
        if (currentPath) {
            // we don't need to add extra point in the end because buildLine will take care of that
            currentPath.closeStroke = true;
        }
        return this;
    }
    ;
    /**
     * Apply a matrix to the positional data.
     *
     * @param {PIXI.Matrix} matrix - Matrix to use for transform current shape.
     * @return {PIXI.Graphics} Returns itself.
     */
    setMatrix(matrix) {
        this._matrix = matrix;
        return this;
    }
    ;
    /**
     * Begin adding holes to the last draw shape
     * IMPORTANT: holes must be fully inside a shape to work
     * Also weirdness ensues if holes overlap!
     * Ellipses, Circles, Rectangles and Rounded Rectangles cannot be holes or host for holes in CanvasRenderer,
     * please use `moveTo` `lineTo`, `quadraticCurveTo` if you rely on pixi-legacy bundle.
     * @return {PIXI.Graphics} Returns itself.
     */
    beginHole() {
        this.finishPoly();
        this._holeMode = true;
        return this;
    }
    ;
    /**
     * End adding holes to the last draw shape
     * @return {PIXI.Graphics} Returns itself.
     */
    endHole() {
        this.finishPoly();
        this._holeMode = false;
        return this;
    }
    ;
    /**
     * Destroys the Graphics object.
     *
     * @param {object|boolean} [options] - Options parameter. A boolean will act as if all
     *  options have been set to that value
     * @param {boolean} [options.children=false] - if set to true, all the children will have
     *  their destroy method called as well. 'options' will be passed on to those calls.
     * @param {boolean} [options.texture=false] - Only used for child Sprites if options.children is set to true
     *  Should it destroy the texture of the child sprite
     * @param {boolean} [options.baseTexture=false] - Only used for child Sprites if options.children is set to true
     *  Should it destroy the base texture of the child sprite
     */
    destroy(options) {
        super.destroy(options);
        this.geometry.refCount--;
        if (this.geometry.refCount === 0) {
            this.geometry.dispose();
        }
        this._matrix = null;
        this.currentPath = null;
        this._lineStyle.destroy();
        this._lineStyle = null;
        this._fillStyle.destroy();
        this._fillStyle = null;
        this.geometry = null;
        this.shader = null;
        this.vertexData = null;
        this.batches.length = 0;
        this.batches = null;
        super.destroy(options);
    }
    ;
}
Graphics.temp = new Float32Array([1, 1, 1]);
Graphics.defaultShader = null;
/**
* Temporary point to use for containsPoint
*
* @static
* @private
* @member {PIXI.Point}
*/
Graphics._TEMP_POINT = new Point_1.Point();
exports.Graphics = Graphics;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/GraphicsData.js":
/*!************************************************!*\
  !*** ./js-compile/raw-pixi-ts/GraphicsData.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class GraphicsData {
    constructor(shape, fillStyle = null, lineStyle = null, matrix = null) {
        /**
         * The shape object to draw.
         * @member {PIXI.Circle|PIXI.Ellipse|PIXI.Polygon|PIXI.Rectangle|PIXI.RoundedRectangle}
         */
        this.shape = shape;
        /**
         * The style of the line.
         * @member {PIXI.LineStyle}
         */
        this.lineStyle = lineStyle;
        /**
         * The style of the fill.
         * @member {PIXI.FillStyle}
         */
        this.fillStyle = fillStyle;
        /**
         * The transform matrix.
         * @member {PIXI.Matrix}
         */
        this.matrix = matrix;
        /**
         * The type of the shape, see the Const.Shapes file for all the existing types,
         * @member {number}
         */
        this.type = shape.type;
        /**
         * The collection of points.
         * @member {number[]}
         */
        this.points = [];
        /**
         * The collection of holes.
         * @member {PIXI.GraphicsData[]}
         */
        this.holes = [];
    }
    /**
     * Creates a new GraphicsData object with the same values as this one.
     *
     * @return {PIXI.GraphicsData} Cloned GraphicsData object
     */
    clone() {
        return new GraphicsData(this.shape, this.fillStyle, this.lineStyle, this.matrix);
    }
    ;
    /**
     * Destroys the Graphics data.
     */
    destroy() {
        this.shape = null;
        this.holes.length = 0;
        this.holes = null;
        this.points.length = 0;
        this.points = null;
        this.lineStyle = null;
        this.fillStyle = null;
    }
    ;
}
exports.GraphicsData = GraphicsData;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/GraphicsGeometry.js":
/*!****************************************************!*\
  !*** ./js-compile/raw-pixi-ts/GraphicsGeometry.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BatchGeometry_1 = __webpack_require__(/*! ./BatchGeometry */ "./js-compile/raw-pixi-ts/BatchGeometry.js");
const Bounds_1 = __webpack_require__(/*! ./Bounds */ "./js-compile/raw-pixi-ts/Bounds.js");
const GraphicsData_1 = __webpack_require__(/*! ./GraphicsData */ "./js-compile/raw-pixi-ts/GraphicsData.js");
const BaseTexture_1 = __webpack_require__(/*! ./BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const BatchDrawCall_1 = __webpack_require__(/*! ./BatchDrawCall */ "./js-compile/raw-pixi-ts/BatchDrawCall.js");
const Point_1 = __webpack_require__(/*! ./Point */ "./js-compile/raw-pixi-ts/Point.js");
const ShapeSettings_1 = __webpack_require__(/*! ./ShapeSettings */ "./js-compile/raw-pixi-ts/ShapeSettings.js");
const DrawModeSettings_1 = __webpack_require__(/*! ./DrawModeSettings */ "./js-compile/raw-pixi-ts/DrawModeSettings.js");
const ColorSettings_1 = __webpack_require__(/*! ./ColorSettings */ "./js-compile/raw-pixi-ts/ColorSettings.js");
class BatchPart {
    constructor() {
        this.style = null;
        this.size = 0;
        this.start = 0;
        this.attribStart = 0;
        this.attribSize = 0;
    }
}
class GraphicsGeometry extends BatchGeometry_1.BatchGeometry {
    constructor() {
        super();
        /**
         * An array of points to draw
         *
         * @member {PIXI.Point[]}
         * @protected
         */
        this.points = [];
        /**
         * The collection of colors
         *
         * @member {number[]}
         * @protected
         */
        this.colors = [];
        /**
         * The UVs collection
         *
         * @member {number[]}
         * @protected
         */
        this.uvs = [];
        /**
         * The indices of the vertices
         *
         * @member {number[]}
         * @protected
         */
        this.indices = [];
        /**
         * Reference to the texture IDs.
         *
         * @member {number[]}
         * @protected
         */
        this.textureIds = [];
        /**
         * The collection of drawn shapes.
         *
         * @member {PIXI.GraphicsData[]}
         * @protected
         */
        this.graphicsData = [];
        /**
         * Used to detect if the graphics object has changed. If this is set to true then the graphics
         * object will be recalculated.
         *
         * @member {number}
         * @protected
         */
        this.dirty = 0;
        /**
         * Batches need to regenerated if the geometry is updated.
         *
         * @member {number}
         * @protected
         */
        this.batchDirty = -1;
        /**
         * Used to check if the cache is dirty.
         *
         * @member {number}
         * @protected
         */
        this.cacheDirty = -1;
        /**
         * Used to detect if we clear the graphics WebGL data.
         *
         * @member {number}
         * @default 0
         * @protected
         */
        this.clearDirty = 0;
        /**
         * List of current draw calls drived from the batches.
         *
         * @member {object[]}
         * @protected
         */
        this.drawCalls = [];
        /**
         * Intermediate abstract format sent to batch system.
         * Can be converted to drawCalls or to batchable objects.
         *
         * @member {object[]}
         * @protected
         */
        this.batches = [];
        /**
         * Index of the current last shape in the stack of calls.
         *
         * @member {number}
         * @protected
         */
        this.shapeIndex = 0;
        /**
         * Cached bounds.
         *
         * @member {PIXI.Bounds}
         * @protected
         */
        this._bounds = new Bounds_1.Bounds();
        /**
         * The bounds dirty flag.
         *
         * @member {number}
         * @protected
         */
        this.boundsDirty = -1;
        /**
         * Padding to add to the bounds.
         *
         * @member {number}
         * @default 0
         */
        this.boundsPadding = 0;
        this.batchable = false;
        this.indicesUint16 = null;
        this.uvsFloat32 = null;
    }
    static getFillCommand(type) {
        if (!GraphicsGeometry.fillCommands) {
            GraphicsGeometry.fillCommands = {};
            GraphicsGeometry.fillCommands[ShapeSettings_1.ShapeSettings.SHAPES.POLY] = GraphicsGeometry.buildPoly;
            GraphicsGeometry.fillCommands[ShapeSettings_1.ShapeSettings.SHAPES.CIRC] = GraphicsGeometry.buildCircle;
            GraphicsGeometry.fillCommands[ShapeSettings_1.ShapeSettings.SHAPES.ELIP] = GraphicsGeometry.buildCircle;
            GraphicsGeometry.fillCommands[ShapeSettings_1.ShapeSettings.SHAPES.RECT] = GraphicsGeometry.buildRectangle;
            GraphicsGeometry.fillCommands[ShapeSettings_1.ShapeSettings.SHAPES.RREC] = GraphicsGeometry.buildRoundedRectangle;
        }
        return GraphicsGeometry.fillCommands[type];
    }
    /**
     * Get the current bounds of the graphic geometry.
     *
     * @member {PIXI.Bounds}
     * @readonly
     */
    get bounds() {
        if (this.boundsDirty !== this.dirty) {
            this.boundsDirty = this.dirty;
            this.calculateBounds();
        }
        return this._bounds;
    }
    ;
    /**
     * Clears the graphics that were drawn to this Graphics object, and resets fill and line style settings.
     *
     * @return {PIXI.GraphicsGeometry} This GraphicsGeometry object. Good for chaining method calls
     */
    clear() {
        if (this.graphicsData.length > 0) {
            this.boundsDirty = -1;
            this.dirty++;
            this.clearDirty++;
            this.batchDirty++;
            this.graphicsData.length = 0;
            this.shapeIndex = 0;
            this.points.length = 0;
            this.colors.length = 0;
            this.uvs.length = 0;
            this.indices.length = 0;
            this.textureIds.length = 0;
            for (var i = 0; i < this.drawCalls.length; i++) {
                this.drawCalls[i].textures.length = 0;
                GraphicsGeometry.DRAW_CALL_POOL.push(this.drawCalls[i]);
            }
            this.drawCalls.length = 0;
            for (var i$1 = 0; i$1 < this.batches.length; i$1++) {
                var batch = this.batches[i$1];
                batch.start = 0;
                batch.attribStart = 0;
                batch.style = null;
                GraphicsGeometry.BATCH_POOL.push(batch);
            }
            this.batches.length = 0;
        }
        return this;
    }
    ;
    /**
     * Draws the given shape to this Graphics object. Can be any of Circle, Rectangle, Ellipse, Line or Polygon.
     *
     * @param {PIXI.Circle|PIXI.Ellipse|PIXI.Polygon|PIXI.Rectangle|PIXI.RoundedRectangle} shape - The shape object to draw.
     * @param {PIXI.FillStyle} fillStyle - Defines style of the fill.
     * @param {PIXI.LineStyle} lineStyle - Defines style of the lines.
     * @param {PIXI.Matrix} matrix - Transform applied to the points of the shape.
     * @return {PIXI.GraphicsGeometry} Returns geometry for chaining.
     */
    drawShape(shape, fillStyle, lineStyle, matrix) {
        var data = new GraphicsData_1.GraphicsData(shape, fillStyle, lineStyle, matrix);
        this.graphicsData.push(data);
        this.dirty++;
        return this;
    }
    ;
    /**
     * Draws the given shape to this Graphics object. Can be any of Circle, Rectangle, Ellipse, Line or Polygon.
     *
     * @param {PIXI.Circle|PIXI.Ellipse|PIXI.Polygon|PIXI.Rectangle|PIXI.RoundedRectangle} shape - The shape object to draw.
     * @param {PIXI.Matrix} matrix - Transform applied to the points of the shape.
     * @return {PIXI.GraphicsGeometry} Returns geometry for chaining.
     */
    drawHole(shape, matrix) {
        if (!this.graphicsData.length) {
            return null;
        }
        var data = new GraphicsData_1.GraphicsData(shape, null, null, matrix);
        var lastShape = this.graphicsData[this.graphicsData.length - 1];
        data.lineStyle = lastShape.lineStyle;
        lastShape.holes.push(data);
        this.dirty++;
        return data;
    }
    ;
    /**
     * Destroys the Graphics object.
     *
     * @param {object|boolean} [options] - Options parameter. A boolean will act as if all
     *  options have been set to that value
     * @param {boolean} [options.children=false] - if set to true, all the children will have
     *  their destroy method called as well. 'options' will be passed on to those calls.
     * @param {boolean} [options.texture=false] - Only used for child Sprites if options.children is set to true
     *  Should it destroy the texture of the child sprite
     * @param {boolean} [options.baseTexture=false] - Only used for child Sprites if options.children is set to true
     *  Should it destroy the base texture of the child sprite
     */
    destroy(options) {
        super.destroy(options);
        // destroy each of the GraphicsData objects
        for (var i = 0; i < this.graphicsData.length; ++i) {
            this.graphicsData[i].destroy();
        }
        this.points.length = 0;
        this.points = null;
        this.colors.length = 0;
        this.colors = null;
        this.uvs.length = 0;
        this.uvs = null;
        this.indices.length = 0;
        this.indices = null;
        this.indexBuffer.destroy();
        this.indexBuffer = null;
        this.graphicsData.length = 0;
        this.graphicsData = null;
        this.drawCalls.length = 0;
        this.drawCalls = null;
        this.batches.length = 0;
        this.batches = null;
        this._bounds = null;
    }
    ;
    /**
     * Check to see if a point is contained within this geometry.
     *
     * @param {PIXI.Point} point - Point to check if it's contained.
     * @return {Boolean} `true` if the point is contained within geometry.
     */
    containsPoint(point) {
        var graphicsData = this.graphicsData;
        for (var i = 0; i < graphicsData.length; ++i) {
            var data = graphicsData[i];
            if (!data.fillStyle.visible) {
                continue;
            }
            // only deal with fills..
            if (data.shape) {
                if (data.shape.contains(point.x, point.y)) {
                    if (data.holes) {
                        for (var i$1 = 0; i$1 < data.holes.length; i$1++) {
                            var hole = data.holes[i$1];
                            if (hole.shape.contains(point.x, point.y)) {
                                return false;
                            }
                        }
                    }
                    return true;
                }
            }
        }
        return false;
    }
    ;
    /**
     * Generates intermediate batch data. Either gets converted to drawCalls
     * or used to convert to batch objects directly by the Graphics object.
     * @protected
     */
    updateBatches() {
        if (this.dirty === this.cacheDirty) {
            return;
        }
        if (this.graphicsData.length === 0) {
            return;
        }
        if (this.dirty !== this.cacheDirty) {
            for (var i = 0; i < this.graphicsData.length; i++) {
                var data = this.graphicsData[i];
                // reveal(data.fillStyle.texture.baseTexture.resource);
                // reveal(data.lineStyle.texture.baseTexture.resource);
                if (data.fillStyle && !data.fillStyle.texture.baseTexture.valid) {
                    return;
                }
                if (data.lineStyle && !data.lineStyle.texture.baseTexture.valid) {
                    return;
                }
            }
        }
        this.cacheDirty = this.dirty;
        var uvs = this.uvs;
        var batchPart = this.batches.pop()
            || GraphicsGeometry.BATCH_POOL.pop()
            || new BatchPart();
        batchPart.style = batchPart.style
            || this.graphicsData[0].fillStyle
            || this.graphicsData[0].lineStyle;
        var currentTexture = batchPart.style.texture.baseTexture;
        // reveal(currentTexture);
        var currentColor = batchPart.style.color + batchPart.style.alpha;
        this.batches.push(batchPart);
        // reveal(this.batches);
        // TODO - this can be simplified
        for (var i$1 = this.shapeIndex; i$1 < this.graphicsData.length; i$1++) {
            this.shapeIndex++;
            var data$1 = this.graphicsData[i$1];
            // reveal(data$1);
            var command = GraphicsGeometry.getFillCommand(data$1.type);
            // reveal(command)
            var fillStyle = data$1.fillStyle;
            var lineStyle = data$1.lineStyle;
            // build out the shapes points..
            command.build(data$1);
            if (data$1.matrix) {
                this.transformPoints(data$1.points, data$1.matrix);
                // reveal(data$1.points)
                // 	reveal(data$1.matrix)
            }
            for (var j = 0; j < 2; j++) {
                var style = (j === 0) ? fillStyle : lineStyle;
                if (!style.visible) {
                    continue;
                }
                var nextTexture = style.texture.baseTexture;
                if (currentTexture !== nextTexture || (style.color + style.alpha) !== currentColor) {
                    // TODO use a const
                    nextTexture.wrapMode = 10497;
                    currentTexture = nextTexture;
                    currentColor = style.color + style.alpha;
                    var index$1 = this.indices.length;
                    var attribIndex = this.points.length / 2;
                    batchPart.size = index$1 - batchPart.start;
                    batchPart.attribSize = attribIndex - batchPart.attribStart;
                    if (batchPart.size > 0) {
                        batchPart = GraphicsGeometry.BATCH_POOL.pop() || new BatchPart();
                        this.batches.push(batchPart);
                    }
                    batchPart.style = style;
                    batchPart.start = index$1;
                    batchPart.attribStart = attribIndex;
                    // TODO add this to the render part..
                }
                var start = this.points.length / 2;
                if (j === 0) {
                    if (data$1.holes.length) {
                        this.processHoles(data$1.holes);
                        GraphicsGeometry.buildPoly.triangulate(data$1, this);
                    }
                    else {
                        command.triangulate(data$1, this);
                    }
                }
                else {
                    GraphicsGeometry.buildLine(data$1, this);
                    for (var i$2 = 0; i$2 < data$1.holes.length; i$2++) {
                        GraphicsGeometry.buildLine(data$1.holes[i$2], this);
                    }
                }
                var size = (this.points.length / 2) - start;
                this.addUvs(this.points, uvs, style.texture, start, size, style.matrix);
            }
        }
        var index = this.indices.length;
        var attrib = this.points.length / 2;
        batchPart.size = index - batchPart.start;
        batchPart.attribSize = attrib - batchPart.attribStart;
        this.indicesUint16 = new Uint16Array(this.indices);
        // TODO make this a const..
        this.batchable = this.isBatchable();
        if (this.batchable) {
            this.batchDirty++;
            this.uvsFloat32 = new Float32Array(this.uvs);
            // offset the indices so that it works with the batcher...
            for (var i$3 = 0; i$3 < this.batches.length; i$3++) {
                var batch = this.batches[i$3];
                for (var j$1 = 0; j$1 < batch.size; j$1++) {
                    var index$2 = batch.start + j$1;
                    this.indicesUint16[index$2] = this.indicesUint16[index$2] - batch.attribStart;
                }
            }
        }
        else {
            this.buildDrawCalls();
        }
    }
    ;
    /**
     * Checks to see if this graphics geometry can be batched.
     * Currently it needs to be small enough and not contain any native lines.
     * @protected
     */
    isBatchable() {
        var batches = this.batches;
        for (var i = 0; i < batches.length; i++) {
            if (batches[i].style.native) {
                return false;
            }
        }
        return (this.points.length < GraphicsGeometry.BATCHABLE_SIZE * 2);
    }
    ;
    /**
     * Converts intermediate batches data to drawCalls.
     * @protected
     */
    buildDrawCalls() {
        var TICK = ++BaseTexture_1.BaseTexture._globalBatch;
        for (var i = 0; i < this.drawCalls.length; i++) {
            this.drawCalls[i].textures.length = 0;
            GraphicsGeometry.DRAW_CALL_POOL.push(this.drawCalls[i]);
        }
        this.drawCalls.length = 0;
        var uvs = this.uvs;
        var colors = this.colors;
        var textureIds = this.textureIds;
        var currentGroup = GraphicsGeometry.DRAW_CALL_POOL.pop() || new BatchDrawCall_1.BatchDrawCall();
        currentGroup.textureCount = 0;
        currentGroup.start = 0;
        currentGroup.size = 0;
        currentGroup.type = DrawModeSettings_1.DrawModeSettings.DRAW_MODES.TRIANGLES;
        var textureCount = 0;
        var currentTexture = null;
        var textureId = 0;
        var native = false;
        var drawMode = DrawModeSettings_1.DrawModeSettings.DRAW_MODES.TRIANGLES;
        var index = 0;
        this.drawCalls.push(currentGroup);
        // TODO - this can be simplified
        for (var i$1 = 0; i$1 < this.batches.length; i$1++) {
            var data = this.batches[i$1];
            // TODO add some full on MAX_TEXTURE CODE..
            var MAX_TEXTURES = 8;
            var style = data.style;
            var nextTexture = style.texture.baseTexture;
            if (native !== style.native) {
                native = style.native;
                drawMode = native ? DrawModeSettings_1.DrawModeSettings.DRAW_MODES.LINES : DrawModeSettings_1.DrawModeSettings.DRAW_MODES.TRIANGLES;
                // force the batch to break!
                currentTexture = null;
                textureCount = MAX_TEXTURES;
                TICK++;
            }
            if (currentTexture !== nextTexture) {
                currentTexture = nextTexture;
                if (nextTexture._batchEnabled !== TICK) {
                    if (textureCount === MAX_TEXTURES) {
                        TICK++;
                        textureCount = 0;
                        if (currentGroup.size > 0) {
                            currentGroup = GraphicsGeometry.DRAW_CALL_POOL.pop() || new BatchDrawCall_1.BatchDrawCall();
                            this.drawCalls.push(currentGroup);
                        }
                        currentGroup.start = index;
                        currentGroup.size = 0;
                        currentGroup.textureCount = 0;
                        currentGroup.type = drawMode;
                    }
                    // TODO add this to the render part..
                    nextTexture.touched = 1; // touch;
                    nextTexture._batchEnabled = TICK;
                    nextTexture._id = textureCount;
                    nextTexture.wrapMode = 10497;
                    currentGroup.textures[currentGroup.textureCount++] = nextTexture;
                    textureCount++;
                }
            }
            currentGroup.size += data.size;
            index += data.size;
            textureId = nextTexture._id;
            this.addColors(colors, style.color, style.alpha, data.attribSize);
            this.addTextureIds(textureIds, textureId, data.attribSize);
        }
        BaseTexture_1.BaseTexture._globalBatch = TICK;
        // upload..
        // merge for now!
        var verts = this.points;
        // verts are 2 positions.. so we * by 3 as there are 6 properties.. then 4 cos its bytes
        var glPoints = new ArrayBuffer(verts.length * 3 * 4);
        var f32 = new Float32Array(glPoints);
        var u32 = new Uint32Array(glPoints);
        var p = 0;
        for (var i$2 = 0; i$2 < verts.length / 2; i$2++) {
            f32[p++] = verts[i$2 * 2];
            f32[p++] = verts[(i$2 * 2) + 1];
            f32[p++] = uvs[i$2 * 2];
            f32[p++] = uvs[(i$2 * 2) + 1];
            u32[p++] = colors[i$2];
            f32[p++] = textureIds[i$2];
        }
        this._buffer.update(glPoints);
        this._indexBuffer.update(this.indicesUint16);
    }
    ;
    /**
     * Process the holes data.
     *
     * @param {PIXI.GraphicsData[]} holes - Holes to render
     * @protected
     */
    processHoles(holes) {
        for (var i = 0; i < holes.length; i++) {
            var hole = holes[i];
            var command = GraphicsGeometry.fillCommands[hole.type];
            command.build(hole);
            if (hole.matrix) {
                this.transformPoints(hole.points, hole.matrix);
            }
        }
    }
    ;
    /**
     * Update the local bounds of the object. Expensive to use performance-wise.
     * @protected
     */
    calculateBounds() {
        var minX = Infinity;
        var maxX = -Infinity;
        var minY = Infinity;
        var maxY = -Infinity;
        if (this.graphicsData.length) {
            var shape = null;
            var x = 0;
            var y = 0;
            var w = 0;
            var h = 0;
            for (var i = 0; i < this.graphicsData.length; i++) {
                var data = this.graphicsData[i];
                var type = data.type;
                var lineWidth = data.lineStyle ? data.lineStyle.width : 0;
                shape = data.shape;
                if (type === ShapeSettings_1.ShapeSettings.SHAPES.RECT || type === ShapeSettings_1.ShapeSettings.SHAPES.RREC) {
                    x = shape.x - (lineWidth / 2);
                    y = shape.y - (lineWidth / 2);
                    w = shape.width + lineWidth;
                    h = shape.height + lineWidth;
                    minX = x < minX ? x : minX;
                    maxX = x + w > maxX ? x + w : maxX;
                    minY = y < minY ? y : minY;
                    maxY = y + h > maxY ? y + h : maxY;
                }
                else if (type === ShapeSettings_1.ShapeSettings.SHAPES.CIRC) {
                    x = shape.x;
                    y = shape.y;
                    w = shape.radius + (lineWidth / 2);
                    h = shape.radius + (lineWidth / 2);
                    minX = x - w < minX ? x - w : minX;
                    maxX = x + w > maxX ? x + w : maxX;
                    minY = y - h < minY ? y - h : minY;
                    maxY = y + h > maxY ? y + h : maxY;
                }
                else if (type === ShapeSettings_1.ShapeSettings.SHAPES.ELIP) {
                    x = shape.x;
                    y = shape.y;
                    w = shape.width + (lineWidth / 2);
                    h = shape.height + (lineWidth / 2);
                    minX = x - w < minX ? x - w : minX;
                    maxX = x + w > maxX ? x + w : maxX;
                    minY = y - h < minY ? y - h : minY;
                    maxY = y + h > maxY ? y + h : maxY;
                }
                else {
                    // POLY
                    var points = shape.points;
                    var x2 = 0;
                    var y2 = 0;
                    var dx = 0;
                    var dy = 0;
                    var rw = 0;
                    var rh = 0;
                    var cx = 0;
                    var cy = 0;
                    for (var j = 0; j + 2 < points.length; j += 2) {
                        x = points[j];
                        y = points[j + 1];
                        x2 = points[j + 2];
                        y2 = points[j + 3];
                        dx = Math.abs(x2 - x);
                        dy = Math.abs(y2 - y);
                        h = lineWidth;
                        w = Math.sqrt((dx * dx) + (dy * dy));
                        if (w < 1e-9) {
                            continue;
                        }
                        rw = ((h / w * dy) + dx) / 2;
                        rh = ((h / w * dx) + dy) / 2;
                        cx = (x2 + x) / 2;
                        cy = (y2 + y) / 2;
                        minX = cx - rw < minX ? cx - rw : minX;
                        maxX = cx + rw > maxX ? cx + rw : maxX;
                        minY = cy - rh < minY ? cy - rh : minY;
                        maxY = cy + rh > maxY ? cy + rh : maxY;
                    }
                }
            }
        }
        else {
            minX = 0;
            maxX = 0;
            minY = 0;
            maxY = 0;
        }
        var padding = this.boundsPadding;
        this._bounds.minX = minX - padding;
        this._bounds.maxX = maxX + padding;
        this._bounds.minY = minY - padding;
        this._bounds.maxY = maxY + padding;
    }
    ;
    /**
     * Transform points using matrix.
     *
     * @protected
     * @param {number[]} points - Points to transform
     * @param {PIXI.Matrix} matrix - Transform matrix
     */
    transformPoints(points, matrix) {
        for (var i = 0; i < points.length / 2; i++) {
            var x = points[(i * 2)];
            var y = points[(i * 2) + 1];
            points[(i * 2)] = (matrix.a * x) + (matrix.c * y) + matrix.tx;
            points[(i * 2) + 1] = (matrix.b * x) + (matrix.d * y) + matrix.ty;
        }
    }
    ;
    /**
     * Add colors.
     *
     * @protected
     * @param {number[]} colors - List of colors to add to
     * @param {number} color - Color to add
     * @param {number} alpha - Alpha to use
     * @param {number} size - Number of colors to add
     */
    addColors(colors, color, alpha, size) {
        // TODO use the premultiply bits Ivan added
        var rgb = (color >> 16) + (color & 0xff00) + ((color & 0xff) << 16);
        var rgba = ColorSettings_1.ColorSettings.premultiplyTint(rgb, alpha);
        while (size-- > 0) {
            colors.push(rgba);
        }
    }
    ;
    /**
     * Add texture id that the shader/fragment wants to use.
     *
     * @protected
     * @param {number[]} textureIds
     * @param {number} id
     * @param {number} size
     */
    addTextureIds(textureIds, id, size) {
        while (size-- > 0) {
            textureIds.push(id);
        }
    }
    ;
    /**
     * Generates the UVs for a shape.
     *
     * @protected
     * @param {number[]} verts - Vertices
     * @param {number[]} uvs - UVs
     * @param {PIXI.Texture} texture - Reference to Texture
     * @param {number} start - Index buffer start index.
     * @param {number} size - The size/length for index buffer.
     * @param {PIXI.Matrix} [matrix] - Optional transform for all points.
     */
    addUvs(verts, uvs, texture, start, size, matrix) {
        var index = 0;
        var uvsStart = uvs.length;
        var frame = texture.frame;
        while (index < size) {
            var x = verts[(start + index) * 2];
            var y = verts[((start + index) * 2) + 1];
            if (matrix) {
                var nx = (matrix.a * x) + (matrix.c * y) + matrix.tx;
                y = (matrix.b * x) + (matrix.d * y) + matrix.ty;
                x = nx;
            }
            index++;
            uvs.push(x / frame.width, y / frame.height);
        }
        var baseTexture = texture.baseTexture;
        if (frame.width < baseTexture.width
            || frame.height < baseTexture.height) {
            this.adjustUvs(uvs, texture, uvsStart, size);
        }
    }
    ;
    /**
     * Modify uvs array according to position of texture region
     * Does not work with rotated or trimmed textures
     * @param {number} uvs array
     * @param {PIXI.Texture} texture region
     * @param {number} start starting index for uvs
     * @param {number} size how many points to adjust
     */
    adjustUvs(uvs, texture, start, size) {
        var baseTexture = texture.baseTexture;
        var eps = 1e-6;
        var finish = start + (size * 2);
        var frame = texture.frame;
        var scaleX = frame.width / baseTexture.width;
        var scaleY = frame.height / baseTexture.height;
        var offsetX = frame.x / frame.width;
        var offsetY = frame.y / frame.width;
        var minX = Math.floor(uvs[start] + eps);
        var minY = Math.floor(uvs[start + 1] + eps);
        for (var i = start + 2; i < finish; i += 2) {
            minX = Math.min(minX, Math.floor(uvs[i] + eps));
            minY = Math.min(minY, Math.floor(uvs[i + 1] + eps));
        }
        offsetX -= minX;
        offsetY -= minY;
        for (var i$1 = start; i$1 < finish; i$1 += 2) {
            uvs[i$1] = (uvs[i$1] + offsetX) * scaleX;
            uvs[i$1 + 1] = (uvs[i$1 + 1] + offsetY) * scaleY;
        }
    }
    ;
    /**
 * Builds a line to draw
 *
 * Ignored from docs since it is not directly exposed.
 *
 * @ignore
 * @private
 * @param {PIXI.GraphicsData} graphicsData - The graphics object containing all the necessary properties
 * @param {PIXI.GraphicsGeometry} graphicsGeometry - Geometry where to append output
 */
    static buildLine(graphicsData, graphicsGeometry) {
        if (graphicsData.lineStyle.native) {
            GraphicsGeometry.buildNativeLine(graphicsData, graphicsGeometry);
        }
        else {
            GraphicsGeometry.buildLine$1(graphicsData, graphicsGeometry);
        }
    }
    /**
 * Builds a line to draw using the gl.drawArrays(gl.LINES) method
 *
 * Ignored from docs since it is not directly exposed.
 *
 * @ignore
 * @private
 * @param {PIXI.GraphicsData} graphicsData - The graphics object containing all the necessary properties
 * @param {PIXI.GraphicsGeometry} graphicsGeometry - Geometry where to append output
 */
    static buildNativeLine(graphicsData, graphicsGeometry) {
        var i = 0;
        var points = graphicsData.points || graphicsData.shape.points;
        if (points.length === 0) {
            return;
        }
        var verts = graphicsGeometry.points;
        var indices = graphicsGeometry.indices;
        var length = points.length / 2;
        var indexStart = verts.length / 2;
        // sort color
        for (i = 1; i < length; i++) {
            var p1x = points[(i - 1) * 2];
            var p1y = points[((i - 1) * 2) + 1];
            var p2x = points[i * 2];
            var p2y = points[(i * 2) + 1];
            verts.push(p1x, p1y);
            verts.push(p2x, p2y);
            indices.push(indexStart++, indexStart++);
        }
    }
    /**
 * Builds a line to draw using the polygon method.
 *
 * Ignored from docs since it is not directly exposed.
 *
 * @ignore
 * @private
 * @param {PIXI.GraphicsData} graphicsData - The graphics object containing all the necessary properties
 * @param {PIXI.GraphicsGeometry} graphicsGeometry - Geometry where to append output
 */
    static buildLine$1(graphicsData, graphicsGeometry) {
        var shape = graphicsData.shape;
        var points = graphicsData.points || shape.points.slice();
        if (points.length === 0) {
            return;
        }
        // if the line width is an odd number add 0.5 to align to a whole pixel
        // commenting this out fixes #711 and #1620
        // if (graphicsData.lineWidth%2)
        // {
        //     for (i = 0; i < points.length; i++)
        //     {
        //         points[i] += 0.5;
        //     }
        // }
        var style = graphicsData.lineStyle;
        // get first and last point.. figure out the middle!
        var firstPoint = new Point_1.Point(points[0], points[1]);
        var lastPoint = new Point_1.Point(points[points.length - 2], points[points.length - 1]);
        var closedShape = shape.type !== ShapeSettings_1.ShapeSettings.SHAPES.POLY || shape.closeStroke;
        var closedPath = firstPoint.x === lastPoint.x && firstPoint.y === lastPoint.y;
        // if the first point is the last point - gonna have issues :)
        if (closedShape) {
            // need to clone as we are going to slightly modify the shape..
            points = points.slice();
            if (closedPath) {
                points.pop();
                points.pop();
                lastPoint.set(points[points.length - 2], points[points.length - 1]);
            }
            var midPointX = lastPoint.x + ((firstPoint.x - lastPoint.x) * 0.5);
            var midPointY = lastPoint.y + ((firstPoint.y - lastPoint.y) * 0.5);
            points.unshift(midPointX, midPointY);
            points.push(midPointX, midPointY);
        }
        var verts = graphicsGeometry.points;
        var length = points.length / 2;
        var indexCount = points.length;
        var indexStart = verts.length / 2;
        // DRAW the Line
        var width = style.width / 2;
        // sort color
        var p1x = points[0];
        var p1y = points[1];
        var p2x = points[2];
        var p2y = points[3];
        var p3x = 0;
        var p3y = 0;
        var perpx = -(p1y - p2y);
        var perpy = p1x - p2x;
        var perp2x = 0;
        var perp2y = 0;
        var perp3x = 0;
        var perp3y = 0;
        var dist = Math.sqrt((perpx * perpx) + (perpy * perpy));
        perpx /= dist;
        perpy /= dist;
        perpx *= width;
        perpy *= width;
        var ratio = style.alignment; // 0.5;
        var r1 = (1 - ratio) * 2;
        var r2 = ratio * 2;
        // start
        verts.push(p1x - (perpx * r1), p1y - (perpy * r1));
        verts.push(p1x + (perpx * r2), p1y + (perpy * r2));
        for (var i = 1; i < length - 1; ++i) {
            p1x = points[(i - 1) * 2];
            p1y = points[((i - 1) * 2) + 1];
            p2x = points[i * 2];
            p2y = points[(i * 2) + 1];
            p3x = points[(i + 1) * 2];
            p3y = points[((i + 1) * 2) + 1];
            perpx = -(p1y - p2y);
            perpy = p1x - p2x;
            dist = Math.sqrt((perpx * perpx) + (perpy * perpy));
            perpx /= dist;
            perpy /= dist;
            perpx *= width;
            perpy *= width;
            perp2x = -(p2y - p3y);
            perp2y = p2x - p3x;
            dist = Math.sqrt((perp2x * perp2x) + (perp2y * perp2y));
            perp2x /= dist;
            perp2y /= dist;
            perp2x *= width;
            perp2y *= width;
            var a1 = (-perpy + p1y) - (-perpy + p2y);
            var b1 = (-perpx + p2x) - (-perpx + p1x);
            var c1 = ((-perpx + p1x) * (-perpy + p2y)) - ((-perpx + p2x) * (-perpy + p1y));
            var a2 = (-perp2y + p3y) - (-perp2y + p2y);
            var b2 = (-perp2x + p2x) - (-perp2x + p3x);
            var c2 = ((-perp2x + p3x) * (-perp2y + p2y)) - ((-perp2x + p2x) * (-perp2y + p3y));
            var denom = (a1 * b2) - (a2 * b1);
            if (Math.abs(denom) < 0.1) {
                denom += 10.1;
                verts.push(p2x - (perpx * r1), p2y - (perpy * r1));
                verts.push(p2x + (perpx * r2), p2y + (perpy * r2));
                continue;
            }
            var px = ((b1 * c2) - (b2 * c1)) / denom;
            var py = ((a2 * c1) - (a1 * c2)) / denom;
            var pdist = ((px - p2x) * (px - p2x)) + ((py - p2y) * (py - p2y));
            if (pdist > (196 * width * width)) {
                perp3x = perpx - perp2x;
                perp3y = perpy - perp2y;
                dist = Math.sqrt((perp3x * perp3x) + (perp3y * perp3y));
                perp3x /= dist;
                perp3y /= dist;
                perp3x *= width;
                perp3y *= width;
                verts.push(p2x - (perp3x * r1), p2y - (perp3y * r1));
                verts.push(p2x + (perp3x * r2), p2y + (perp3y * r2));
                verts.push(p2x - (perp3x * r2 * r1), p2y - (perp3y * r1));
                indexCount++;
            }
            else {
                verts.push(p2x + ((px - p2x) * r1), p2y + ((py - p2y) * r1));
                verts.push(p2x - ((px - p2x) * r2), p2y - ((py - p2y) * r2));
            }
        }
        p1x = points[(length - 2) * 2];
        p1y = points[((length - 2) * 2) + 1];
        p2x = points[(length - 1) * 2];
        p2y = points[((length - 1) * 2) + 1];
        perpx = -(p1y - p2y);
        perpy = p1x - p2x;
        dist = Math.sqrt((perpx * perpx) + (perpy * perpy));
        perpx /= dist;
        perpy /= dist;
        perpx *= width;
        perpy *= width;
        verts.push(p2x - (perpx * r1), p2y - (perpy * r1));
        verts.push(p2x + (perpx * r2), p2y + (perpy * r2));
        var indices = graphicsGeometry.indices;
        // indices.push(indexStart);
        for (var i$1 = 0; i$1 < indexCount - 2; ++i$1) {
            indices.push(indexStart, indexStart + 1, indexStart + 2);
            indexStart++;
        }
    }
    static earcut(data, holeIndices, dim) {
        dim = dim || 2;
        var hasHoles = holeIndices && holeIndices.length, outerLen = hasHoles ? holeIndices[0] * dim : data.length, outerNode = GraphicsGeometry.linkedList(data, 0, outerLen, dim, true), triangles = [];
        if (!outerNode || outerNode.next === outerNode.prev) {
            return triangles;
        }
        var minX, minY, maxX, maxY, x, y, invSize;
        if (hasHoles) {
            outerNode = GraphicsGeometry.eliminateHoles(data, holeIndices, outerNode, dim);
        }
        // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
        if (data.length > 80 * dim) {
            minX = maxX = data[0];
            minY = maxY = data[1];
            for (var i = dim; i < outerLen; i += dim) {
                x = data[i];
                y = data[i + 1];
                if (x < minX) {
                    minX = x;
                }
                if (y < minY) {
                    minY = y;
                }
                if (x > maxX) {
                    maxX = x;
                }
                if (y > maxY) {
                    maxY = y;
                }
            }
            // minX, minY and invSize are later used to transform coords into integers for z-order calculation
            invSize = Math.max(maxX - minX, maxY - minY);
            invSize = invSize !== 0 ? 1 / invSize : 0;
        }
        GraphicsGeometry.earcutLinked(outerNode, triangles, dim, minX, minY, invSize);
        return triangles;
    }
    // create a circular doubly linked list from polygon points in the specified winding order
    static linkedList(data, start, end, dim, clockwise) {
        var i, last;
        if (clockwise === (GraphicsGeometry.signedArea(data, start, end, dim) > 0)) {
            for (i = start; i < end; i += dim) {
                last = GraphicsGeometry.insertNode(i, data[i], data[i + 1], last);
            }
        }
        else {
            for (i = end - dim; i >= start; i -= dim) {
                last = GraphicsGeometry.insertNode(i, data[i], data[i + 1], last);
            }
        }
        if (last && GraphicsGeometry.equals(last, last.next)) {
            GraphicsGeometry.removeNode(last);
            last = last.next;
        }
        return last;
    }
    // link every hole into the outer loop, producing a single-ring polygon without holes
    static eliminateHoles(data, holeIndices, outerNode, dim) {
        var queue = [], i, len, start, end, list;
        for (i = 0, len = holeIndices.length; i < len; i++) {
            start = holeIndices[i] * dim;
            end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
            list = GraphicsGeometry.linkedList(data, start, end, dim, false);
            if (list === list.next) {
                list.steiner = true;
            }
            queue.push(GraphicsGeometry.getLeftmost(list));
        }
        queue.sort(GraphicsGeometry.compareX);
        // process holes from left to right
        for (i = 0; i < queue.length; i++) {
            GraphicsGeometry.eliminateHole(queue[i], outerNode);
            outerNode = GraphicsGeometry.filterPoints(outerNode, outerNode.next);
        }
        return outerNode;
    }
    // main ear slicing loop which triangulates a polygon (given as a linked list)
    static earcutLinked(ear, triangles, dim, minX, minY, invSize, pass = null) {
        if (!ear) {
            return;
        }
        // interlink polygon nodes in z-order
        if (!pass && invSize) {
            GraphicsGeometry.indexCurve(ear, minX, minY, invSize);
        }
        var stop = ear, prev, next;
        // iterate through ears, slicing them one by one
        while (ear.prev !== ear.next) {
            prev = ear.prev;
            next = ear.next;
            if (invSize ? GraphicsGeometry.isEarHashed(ear, minX, minY, invSize) : GraphicsGeometry.isEar(ear)) {
                // cut off the triangle
                triangles.push(prev.i / dim);
                triangles.push(ear.i / dim);
                triangles.push(next.i / dim);
                GraphicsGeometry.removeNode(ear);
                // skipping the next vertex leads to less sliver triangles
                ear = next.next;
                stop = next.next;
                continue;
            }
            ear = next;
            // if we looped through the whole remaining polygon and can't find any more ears
            if (ear === stop) {
                // try filtering points and slicing again
                if (!pass) {
                    GraphicsGeometry.earcutLinked(GraphicsGeometry.filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
                    // if this didn't work, try curing all small self-intersections locally
                }
                else if (pass === 1) {
                    ear = GraphicsGeometry.cureLocalIntersections(ear, triangles, dim);
                    GraphicsGeometry.earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
                    // as a last resort, try splitting the remaining polygon into two
                }
                else if (pass === 2) {
                    GraphicsGeometry.splitEarcut(ear, triangles, dim, minX, minY, invSize);
                }
                break;
            }
        }
    }
    static signedArea(data, start, end, dim) {
        var sum = 0;
        for (var i = start, j = end - dim; i < end; i += dim) {
            sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
            j = i;
        }
        return sum;
    }
    // create a node and optionally link it with previous one (in a circular doubly linked list)
    static insertNode(i, x, y, last) {
        var p = new Node(i, x, y);
        if (!last) {
            p.prev = p;
            p.next = p;
        }
        else {
            p.next = last.next;
            p.prev = last;
            last.next.prev = p;
            last.next = p;
        }
        return p;
    }
    // check if two points are equal
    static equals(p1, p2) {
        return p1.x === p2.x && p1.y === p2.y;
    }
    static removeNode(p) {
        p.next.prev = p.prev;
        p.prev.next = p.next;
        if (p.prevZ) {
            p.prevZ.nextZ = p.nextZ;
        }
        if (p.nextZ) {
            p.nextZ.prevZ = p.prevZ;
        }
    }
    // find the leftmost node of a polygon ring
    static getLeftmost(start) {
        var p = start, leftmost = start;
        do {
            if (p.x < leftmost.x || (p.x === leftmost.x && p.y < leftmost.y)) {
                leftmost = p;
            }
            p = p.next;
        } while (p !== start);
        return leftmost;
    }
    static compareX(a, b) {
        return a.x - b.x;
    }
    // find a bridge between vertices that connects hole with an outer ring and and link it
    static eliminateHole(hole, outerNode) {
        outerNode = GraphicsGeometry.findHoleBridge(hole, outerNode);
        if (outerNode) {
            var b = GraphicsGeometry.splitPolygon(outerNode, hole);
            GraphicsGeometry.filterPoints(b, b.next);
        }
    }
    // eliminate colinear or duplicate points
    static filterPoints(start, end = null) {
        if (!start) {
            return start;
        }
        if (!end) {
            end = start;
        }
        var p = start, again;
        do {
            again = false;
            if (!p.steiner && (GraphicsGeometry.equals(p, p.next) || GraphicsGeometry.area(p.prev, p, p.next) === 0)) {
                GraphicsGeometry.removeNode(p);
                p = end = p.prev;
                if (p === p.next) {
                    break;
                }
                again = true;
            }
            else {
                p = p.next;
            }
        } while (again || p !== end);
        return end;
    }
    // signed area of a triangle
    static area(p, q, r) {
        return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
    }
    // link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
    // if one belongs to the outer ring and another to a hole, it merges it into a single ring
    static splitPolygon(a, b) {
        var a2 = new Node(a.i, a.x, a.y), b2 = new Node(b.i, b.x, b.y), an = a.next, bp = b.prev;
        a.next = b;
        b.prev = a;
        a2.next = an;
        an.prev = a2;
        b2.next = a2;
        a2.prev = b2;
        bp.next = b2;
        b2.prev = bp;
        return b2;
    }
    // David Eberly's algorithm for finding a bridge between hole and outer polygon
    static findHoleBridge(hole, outerNode) {
        var p = outerNode, hx = hole.x, hy = hole.y, qx = -Infinity, m;
        // find a segment intersected by a ray from the hole's leftmost point to the left;
        // segment's endpoint with lesser x will be potential connection point
        do {
            if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
                var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
                if (x <= hx && x > qx) {
                    qx = x;
                    if (x === hx) {
                        if (hy === p.y) {
                            return p;
                        }
                        if (hy === p.next.y) {
                            return p.next;
                        }
                    }
                    m = p.x < p.next.x ? p : p.next;
                }
            }
            p = p.next;
        } while (p !== outerNode);
        if (!m) {
            return null;
        }
        if (hx === qx) {
            return m.prev;
        } // hole touches outer segment; pick lower endpoint
        // look for points inside the triangle of hole point, segment intersection and endpoint;
        // if there are no points found, we have a valid connection;
        // otherwise choose the point of the minimum angle with the ray as connection point
        var stop = m, mx = m.x, my = m.y, tanMin = Infinity, tan;
        p = m.next;
        while (p !== stop) {
            if (hx >= p.x && p.x >= mx && hx !== p.x &&
                GraphicsGeometry.pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
                tan = Math.abs(hy - p.y) / (hx - p.x); // tangential
                if ((tan < tanMin || (tan === tanMin && p.x > m.x)) && GraphicsGeometry.locallyInside(p, hole)) {
                    m = p;
                    tanMin = tan;
                }
            }
            p = p.next;
        }
        return m;
    }
    // check if a polygon diagonal is locally inside the polygon
    static locallyInside(a, b) {
        return GraphicsGeometry.area(a.prev, a, a.next) < 0 ?
            GraphicsGeometry.area(a, b, a.next) >= 0 && GraphicsGeometry.area(a, a.prev, b) >= 0 :
            GraphicsGeometry.area(a, b, a.prev) < 0 || GraphicsGeometry.area(a, a.next, b) < 0;
    }
    // check if a point lies within a convex triangle
    static pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
        return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 &&
            (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 &&
            (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
    }
    // try splitting polygon into two and triangulate them independently
    static splitEarcut(start, triangles, dim, minX, minY, invSize) {
        // look for a valid diagonal that divides the polygon into two
        var a = start;
        do {
            var b = a.next.next;
            while (b !== a.prev) {
                if (a.i !== b.i && GraphicsGeometry.isValidDiagonal(a, b)) {
                    // split the polygon in two by the diagonal
                    var c = GraphicsGeometry.splitPolygon(a, b);
                    // filter colinear points around the cuts
                    a = GraphicsGeometry.filterPoints(a, a.next);
                    c = GraphicsGeometry.filterPoints(c, c.next);
                    // run earcut on each half
                    GraphicsGeometry.earcutLinked(a, triangles, dim, minX, minY, invSize);
                    GraphicsGeometry.earcutLinked(c, triangles, dim, minX, minY, invSize);
                    return;
                }
                b = b.next;
            }
            a = a.next;
        } while (a !== start);
    }
    // check if a diagonal between two polygon nodes is valid (lies in polygon interior)
    static isValidDiagonal(a, b) {
        return a.next.i !== b.i && a.prev.i !== b.i && !GraphicsGeometry.intersectsPolygon(a, b) &&
            GraphicsGeometry.locallyInside(a, b) && GraphicsGeometry.locallyInside(b, a) && GraphicsGeometry.middleInside(a, b);
    }
    // check if the middle point of a polygon diagonal is inside the polygon
    static middleInside(a, b) {
        var p = a, inside = false, px = (a.x + b.x) / 2, py = (a.y + b.y) / 2;
        do {
            if (((p.y > py) !== (p.next.y > py)) && p.next.y !== p.y &&
                (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x)) {
                inside = !inside;
            }
            p = p.next;
        } while (p !== a);
        return inside;
    }
    // check if a polygon diagonal intersects any polygon segments
    static intersectsPolygon(a, b) {
        var p = a;
        do {
            if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&
                GraphicsGeometry.intersects(p, p.next, a, b)) {
                return true;
            }
            p = p.next;
        } while (p !== a);
        return false;
    }
    // check if two segments intersect
    static intersects(p1, q1, p2, q2) {
        if ((GraphicsGeometry.equals(p1, q1) && GraphicsGeometry.equals(p2, q2)) ||
            (GraphicsGeometry.equals(p1, q2) && GraphicsGeometry.equals(p2, q1))) {
            return true;
        }
        return GraphicsGeometry.area(p1, q1, p2) > 0 !== GraphicsGeometry.area(p1, q1, q2) > 0 &&
            GraphicsGeometry.area(p2, q2, p1) > 0 !== GraphicsGeometry.area(p2, q2, q1) > 0;
    }
    // go through all polygon nodes and cure small local self-intersections
    static cureLocalIntersections(start, triangles, dim) {
        var p = start;
        do {
            var a = p.prev, b = p.next.next;
            if (!GraphicsGeometry.equals(a, b) && GraphicsGeometry.intersects(a, p, p.next, b) && GraphicsGeometry.locallyInside(a, b) && GraphicsGeometry.locallyInside(b, a)) {
                triangles.push(a.i / dim);
                triangles.push(p.i / dim);
                triangles.push(b.i / dim);
                // remove two nodes involved
                GraphicsGeometry.removeNode(p);
                GraphicsGeometry.removeNode(p.next);
                p = start = b;
            }
            p = p.next;
        } while (p !== start);
        return p;
    }
    static isEarHashed(ear, minX, minY, invSize) {
        var a = ear.prev, b = ear, c = ear.next;
        if (GraphicsGeometry.area(a, b, c) >= 0) {
            return false;
        } // reflex, can't be an ear
        // triangle bbox; min & max are calculated like this for speed
        var minTX = a.x < b.x ? (a.x < c.x ? a.x : c.x) : (b.x < c.x ? b.x : c.x), minTY = a.y < b.y ? (a.y < c.y ? a.y : c.y) : (b.y < c.y ? b.y : c.y), maxTX = a.x > b.x ? (a.x > c.x ? a.x : c.x) : (b.x > c.x ? b.x : c.x), maxTY = a.y > b.y ? (a.y > c.y ? a.y : c.y) : (b.y > c.y ? b.y : c.y);
        // z-order range for the current triangle bbox;
        var minZ = GraphicsGeometry.zOrder(minTX, minTY, minX, minY, invSize), maxZ = GraphicsGeometry.zOrder(maxTX, maxTY, minX, minY, invSize);
        var p = ear.prevZ, n = ear.nextZ;
        // look for points inside the triangle in both directions
        while (p && p.z >= minZ && n && n.z <= maxZ) {
            if (p !== ear.prev && p !== ear.next &&
                GraphicsGeometry.pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
                GraphicsGeometry.area(p.prev, p, p.next) >= 0) {
                return false;
            }
            p = p.prevZ;
            if (n !== ear.prev && n !== ear.next &&
                GraphicsGeometry.pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) &&
                GraphicsGeometry.area(n.prev, n, n.next) >= 0) {
                return false;
            }
            n = n.nextZ;
        }
        // look for remaining points in decreasing z-order
        while (p && p.z >= minZ) {
            if (p !== ear.prev && p !== ear.next &&
                GraphicsGeometry.pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
                GraphicsGeometry.area(p.prev, p, p.next) >= 0) {
                return false;
            }
            p = p.prevZ;
        }
        // look for remaining points in increasing z-order
        while (n && n.z <= maxZ) {
            if (n !== ear.prev && n !== ear.next &&
                GraphicsGeometry.pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) &&
                GraphicsGeometry.area(n.prev, n, n.next) >= 0) {
                return false;
            }
            n = n.nextZ;
        }
        return true;
    }
    // z-order of a point given coords and inverse of the longer side of data bbox
    static zOrder(x, y, minX, minY, invSize) {
        // coords are transformed into non-negative 15-bit integer range
        x = 32767 * (x - minX) * invSize;
        y = 32767 * (y - minY) * invSize;
        x = (x | (x << 8)) & 0x00FF00FF;
        x = (x | (x << 4)) & 0x0F0F0F0F;
        x = (x | (x << 2)) & 0x33333333;
        x = (x | (x << 1)) & 0x55555555;
        y = (y | (y << 8)) & 0x00FF00FF;
        y = (y | (y << 4)) & 0x0F0F0F0F;
        y = (y | (y << 2)) & 0x33333333;
        y = (y | (y << 1)) & 0x55555555;
        return x | (y << 1);
    }
    // check whether a polygon node forms a valid ear with adjacent nodes
    static isEar(ear) {
        var a = ear.prev, b = ear, c = ear.next;
        if (GraphicsGeometry.area(a, b, c) >= 0) {
            return false;
        } // reflex, can't be an ear
        // now make sure we don't have other points inside the potential ear
        var p = ear.next.next;
        while (p !== ear.prev) {
            if (GraphicsGeometry.pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
                GraphicsGeometry.area(p.prev, p, p.next) >= 0) {
                return false;
            }
            p = p.next;
        }
        return true;
    }
    // interlink polygon nodes in z-order
    static indexCurve(start, minX, minY, invSize) {
        var p = start;
        do {
            if (p.z === null) {
                p.z = GraphicsGeometry.zOrder(p.x, p.y, minX, minY, invSize);
            }
            p.prevZ = p.prev;
            p.nextZ = p.next;
            p = p.next;
        } while (p !== start);
        p.prevZ.nextZ = null;
        p.prevZ = null;
        GraphicsGeometry.sortLinked(p);
    }
    // Simon Tatham's linked list merge sort algorithm
    // http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
    static sortLinked(list) {
        var i, p, q, e, tail, numMerges, pSize, qSize, inSize = 1;
        do {
            p = list;
            list = null;
            tail = null;
            numMerges = 0;
            while (p) {
                numMerges++;
                q = p;
                pSize = 0;
                for (i = 0; i < inSize; i++) {
                    pSize++;
                    q = q.nextZ;
                    if (!q) {
                        break;
                    }
                }
                qSize = inSize;
                while (pSize > 0 || (qSize > 0 && q)) {
                    if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
                        e = p;
                        p = p.nextZ;
                        pSize--;
                    }
                    else {
                        e = q;
                        q = q.nextZ;
                        qSize--;
                    }
                    if (tail) {
                        tail.nextZ = e;
                    }
                    else {
                        list = e;
                    }
                    e.prevZ = tail;
                    tail = e;
                }
                p = q;
            }
            tail.nextZ = null;
            inSize *= 2;
        } while (numMerges > 1);
        return list;
    }
    /**
 * Calculate the points for a quadratic bezier curve. (helper function..)
 * Based on: https://stackoverflow.com/questions/785097/how-do-i-implement-a-bezier-curve-in-c
 *
 * Ignored from docs since it is not directly exposed.
 *
 * @ignore
 * @private
 * @param {number} fromX - Origin point x
 * @param {number} fromY - Origin point x
 * @param {number} cpX - Control point x
 * @param {number} cpY - Control point y
 * @param {number} toX - Destination point x
 * @param {number} toY - Destination point y
 * @param {number[]} [out=[]] - The output array to add points into. If not passed, a new array is created.
 * @return {number[]} an array of points
 */
    static quadraticBezierCurve(fromX, fromY, cpX, cpY, toX, toY, out) {
        if (out === void 0) {
            out = [];
        }
        var n = 20;
        var points = out;
        var xa = 0;
        var ya = 0;
        var xb = 0;
        var yb = 0;
        var x = 0;
        var y = 0;
        for (var i = 0, j = 0; i <= n; ++i) {
            j = i / n;
            // The Green Line
            xa = GraphicsGeometry.getPt(fromX, cpX, j);
            ya = GraphicsGeometry.getPt(fromY, cpY, j);
            xb = GraphicsGeometry.getPt(cpX, toX, j);
            yb = GraphicsGeometry.getPt(cpY, toY, j);
            // The Black Dot
            x = GraphicsGeometry.getPt(xa, xb, j);
            y = GraphicsGeometry.getPt(ya, yb, j);
            points.push(x, y);
        }
        return points;
    }
    /**
 * Calculate a single point for a quadratic bezier curve.
 * Utility function used by quadraticBezierCurve.
 * Ignored from docs since it is not directly exposed.
 *
 * @ignore
 * @private
 * @param {number} n1 - first number
 * @param {number} n2 - second number
 * @param {number} perc - percentage
 * @return {number} the result
 *
 */
    static getPt(n1, n2, perc) {
        var diff = n2 - n1;
        return n1 + (diff * perc);
    }
}
GraphicsGeometry.BATCH_POOL = [];
GraphicsGeometry.DRAW_CALL_POOL = [];
/**
* The maximum number of points to consider an object "batchable",
* able to be batched by the renderer's batch system.
*
* @memberof PIXI.GraphicsGeometry
* @static
* @member {number} BATCHABLE_SIZE
* @default 100
*/
GraphicsGeometry.BATCHABLE_SIZE = 100;
/**
* Builds a polygon to draw
*
* Ignored from docs since it is not directly exposed.
*
* @ignore
* @private
* @param {PIXI.WebGLGraphicsData} graphicsData - The graphics object containing all the necessary properties
* @param {object} webGLData - an object containing all the WebGL-specific information to create this shape
* @param {object} webGLDataNativeLines - an object containing all the WebGL-specific information to create nativeLines
*/
GraphicsGeometry.buildPoly = {
    name: "buildPoly",
    build: function build(graphicsData) {
        graphicsData.points = graphicsData.shape.points.slice();
    },
    triangulate: function triangulate(graphicsData, graphicsGeometry) {
        var points = graphicsData.points;
        var holes = graphicsData.holes;
        var verts = graphicsGeometry.points;
        var indices = graphicsGeometry.indices;
        if (points.length >= 6) {
            var holeArray = [];
            // Process holes..
            for (var i = 0; i < holes.length; i++) {
                var hole = holes[i];
                holeArray.push(points.length / 2);
                points = points.concat(hole.points);
            }
            // sort color
            var triangles = GraphicsGeometry.earcut(points, holeArray, 2);
            if (!triangles) {
                return;
            }
            var vertPos = verts.length / 2;
            for (var i$1 = 0; i$1 < triangles.length; i$1 += 3) {
                indices.push(triangles[i$1] + vertPos);
                indices.push(triangles[i$1 + 1] + vertPos);
                indices.push(triangles[i$1 + 2] + vertPos);
            }
            for (var i$2 = 0; i$2 < points.length; i$2++) {
                verts.push(points[i$2]);
            }
        }
    },
};
/**
* Builds a rectangle to draw
*
* Ignored from docs since it is not directly exposed.
*
* @ignore
* @private
* @param {PIXI.WebGLGraphicsData} graphicsData - The graphics object containing all the necessary properties
* @param {object} webGLData - an object containing all the WebGL-specific information to create this shape
* @param {object} webGLDataNativeLines - an object containing all the WebGL-specific information to create nativeLines
*/
GraphicsGeometry.buildRectangle = {
    name: "buildRectangle",
    build: function build(graphicsData) {
        // --- //
        // need to convert points to a nice regular data
        //
        var rectData = graphicsData.shape;
        var x = rectData.x;
        var y = rectData.y;
        var width = rectData.width;
        var height = rectData.height;
        var points = graphicsData.points;
        points.length = 0;
        points.push(x, y, x + width, y, x + width, y + height, x, y + height);
    },
    triangulate: function triangulate(graphicsData, graphicsGeometry) {
        var points = graphicsData.points;
        var verts = graphicsGeometry.points;
        var vertPos = verts.length / 2;
        verts.push(points[0], points[1], points[2], points[3], points[6], points[7], points[4], points[5]);
        graphicsGeometry.indices.push(vertPos, vertPos + 1, vertPos + 2, vertPos + 1, vertPos + 2, vertPos + 3);
    },
};
/**
* Builds a rounded rectangle to draw
*
* Ignored from docs since it is not directly exposed.
*
* @ignore
* @private
* @param {PIXI.WebGLGraphicsData} graphicsData - The graphics object containing all the necessary properties
* @param {object} webGLData - an object containing all the WebGL-specific information to create this shape
* @param {object} webGLDataNativeLines - an object containing all the WebGL-specific information to create nativeLines
*/
GraphicsGeometry.buildRoundedRectangle = {
    name: "buildRoundedRectangle",
    build: function build(graphicsData) {
        var rrectData = graphicsData.shape;
        var points = graphicsData.points;
        var x = rrectData.x;
        var y = rrectData.y;
        var width = rrectData.width;
        var height = rrectData.height;
        var radius = rrectData.radius;
        points.length = 0;
        GraphicsGeometry.quadraticBezierCurve(x, y + radius, x, y, x + radius, y, points);
        GraphicsGeometry.quadraticBezierCurve(x + width - radius, y, x + width, y, x + width, y + radius, points);
        GraphicsGeometry.quadraticBezierCurve(x + width, y + height - radius, x + width, y + height, x + width - radius, y + height, points);
        GraphicsGeometry.quadraticBezierCurve(x + radius, y + height, x, y + height, x, y + height - radius, points);
        // this tiny number deals with the issue that occurs when points overlap and earcut fails to triangulate the item.
        // TODO - fix this properly, this is not very elegant.. but it works for now.
    },
    triangulate: function triangulate(graphicsData, graphicsGeometry) {
        var points = graphicsData.points;
        var verts = graphicsGeometry.points;
        var indices = graphicsGeometry.indices;
        var vecPos = verts.length / 2;
        var triangles = GraphicsGeometry.earcut(points, null, 2);
        for (var i = 0, j = triangles.length; i < j; i += 3) {
            indices.push(triangles[i] + vecPos);
            //     indices.push(triangles[i] + vecPos);
            indices.push(triangles[i + 1] + vecPos);
            //   indices.push(triangles[i + 2] + vecPos);
            indices.push(triangles[i + 2] + vecPos);
        }
        for (var i$1 = 0, j$1 = points.length; i$1 < j$1; i$1++) {
            verts.push(points[i$1], points[++i$1]);
        }
    },
};
/**
* Builds a circle to draw
*
* Ignored from docs since it is not directly exposed.
*
* @ignore
* @private
* @param {PIXI.WebGLGraphicsData} graphicsData - The graphics object to draw
* @param {object} webGLData - an object containing all the WebGL-specific information to create this shape
* @param {object} webGLDataNativeLines - an object containing all the WebGL-specific information to create nativeLines
*/
GraphicsGeometry.buildCircle = {
    name: "buildCircle",
    build: function build(graphicsData) {
        // need to convert points to a nice regular data
        var circleData = graphicsData.shape;
        var points = graphicsData.points;
        var x = circleData.x;
        var y = circleData.y;
        var width;
        var height;
        points.length = 0;
        // TODO - bit hacky??
        if (graphicsData.type === ShapeSettings_1.ShapeSettings.SHAPES.CIRC) {
            width = circleData.radius;
            height = circleData.radius;
        }
        else {
            width = circleData.width;
            height = circleData.height;
        }
        if (width === 0 || height === 0) {
            return;
        }
        var totalSegs = Math.floor(30 * Math.sqrt(circleData.radius))
            || Math.floor(15 * Math.sqrt(circleData.width + circleData.height));
        totalSegs /= 2.3;
        var seg = (Math.PI * 2) / totalSegs;
        for (var i = 0; i < totalSegs; i++) {
            points.push(x + (Math.sin(-seg * i) * width), y + (Math.cos(-seg * i) * height));
        }
        points.push(points[0], points[1]);
    },
    triangulate: function triangulate(graphicsData, graphicsGeometry) {
        var points = graphicsData.points;
        var verts = graphicsGeometry.points;
        var indices = graphicsGeometry.indices;
        var vertPos = verts.length / 2;
        var center = vertPos;
        verts.push(graphicsData.shape.x, graphicsData.shape.y);
        for (var i = 0; i < points.length; i += 2) {
            verts.push(points[i], points[i + 1]);
            // add some uvs
            indices.push(vertPos++, center, vertPos);
        }
    },
};
exports.GraphicsGeometry = GraphicsGeometry;
class Node {
    constructor(i, x, y) {
        // vertex index in coordinates array
        this.i = i;
        // vertex coordinates
        this.x = x;
        this.y = y;
        // previous and next vertex nodes in a polygon ring
        this.prev = null;
        this.next = null;
        // z-order curve value
        this.z = null;
        // previous and next nodes in z-order
        this.prevZ = null;
        this.nextZ = null;
        // indicates whether this is a steiner point
        this.steiner = false;
    }
}


/***/ }),

/***/ "./js-compile/raw-pixi-ts/GroupD8.js":
/*!*******************************************!*\
  !*** ./js-compile/raw-pixi-ts/GroupD8.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Matrix_1 = __webpack_require__(/*! ./Matrix */ "./js-compile/raw-pixi-ts/Matrix.js");
class GroupD8 {
    static uX(ind) {
        GroupD8.init();
        return GroupD8.ux[ind];
    }
    static uY(ind) {
        GroupD8.init();
        return GroupD8.uy[ind];
    }
    static vX(ind) {
        GroupD8.init();
        return GroupD8.vx[ind];
    }
    static vY(ind) {
        GroupD8.init();
        return GroupD8.vy[ind];
    }
    static inv(rotation) {
        if (rotation & 8) {
            return rotation & 15;
        }
        return (-rotation) & 7;
    }
    static add(rotationSecond, rotationFirst) {
        GroupD8.init();
        return GroupD8.mul[rotationSecond][rotationFirst];
    }
    static sub(rotationSecond, rotationFirst) {
        GroupD8.init();
        return GroupD8.mul[rotationSecond][GroupD8.inv(rotationFirst)];
    }
    static rotate180(rotation) {
        return rotation ^ 4;
    }
    static isVertical(rotation) {
        return (rotation & 3) === 2;
    }
    static byDirection(dx, dy) {
        GroupD8.init();
        if (Math.abs(dx) * 2 <= Math.abs(dy)) {
            if (dy >= 0) {
                return GroupD8.S;
            }
            return GroupD8.N;
        }
        else if (Math.abs(dy) * 2 <= Math.abs(dx)) {
            if (dx > 0) {
                return GroupD8.E;
            }
            return GroupD8.W;
        }
        else if (dy > 0) {
            if (dx > 0) {
                return GroupD8.SE;
            }
            return GroupD8.SW;
        }
        else if (dx > 0) {
            return GroupD8.NE;
        }
        return GroupD8.NW;
    }
    static matrixAppendRotationInv(matrix, rotation, tx = 0, ty = 0) {
        GroupD8.init();
        let mat = GroupD8.tempMatrices[GroupD8.inv(rotation)];
        mat.tx = tx;
        mat.ty = ty;
        matrix.append(mat);
    }
    static signum(x) {
        if (x < 0) {
            return -1;
        }
        if (x > 0) {
            return 1;
        }
        return 0;
    }
    static init() {
        if (GroupD8.isInit) {
            return;
        }
        GroupD8.isInit = true;
        for (var i = 0; i < 16; i++) {
            var row = [];
            GroupD8.mul.push(row);
            for (var j = 0; j < 16; j++) {
                var _ux = GroupD8.signum((GroupD8.ux[i] * GroupD8.ux[j]) + (GroupD8.vx[i] * GroupD8.uy[j]));
                var _uy = GroupD8.signum((GroupD8.uy[i] * GroupD8.ux[j]) + (GroupD8.vy[i] * GroupD8.uy[j]));
                var _vx = GroupD8.signum((GroupD8.ux[i] * GroupD8.vx[j]) + (GroupD8.vx[i] * GroupD8.vy[j]));
                var _vy = GroupD8.signum((GroupD8.uy[i] * GroupD8.vx[j]) + (GroupD8.vy[i] * GroupD8.vy[j]));
                for (var k = 0; k < 16; k++) {
                    if (GroupD8.ux[k] === _ux && GroupD8.uy[k] === _uy && GroupD8.vx[k] === _vx && GroupD8.vy[k] === _vy) {
                        row.push(k);
                        break;
                    }
                }
            }
        }
        for (var i$1 = 0; i$1 < 16; i$1++) {
            var mat = new Matrix_1.Matrix();
            mat.set(GroupD8.ux[i$1], GroupD8.uy[i$1], GroupD8.vx[i$1], GroupD8.vy[i$1], 0, 0);
            GroupD8.tempMatrices.push(mat);
        }
    }
}
GroupD8.isInit = false;
GroupD8.E = 0;
GroupD8.SE = 1;
GroupD8.S = 2;
GroupD8.SW = 3;
GroupD8.W = 4;
GroupD8.NW = 5;
GroupD8.N = 6;
GroupD8.NE = 7;
GroupD8.MIRROR_VERTICAL = 8;
GroupD8.MIRROR_HORIZONTAL = 12;
GroupD8.ux = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1];
GroupD8.uy = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1];
GroupD8.vx = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1];
GroupD8.vy = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1];
GroupD8.tempMatrices = [];
GroupD8.mul = [];
exports.GroupD8 = GroupD8;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/IOErrorEvent.js":
/*!************************************************!*\
  !*** ./js-compile/raw-pixi-ts/IOErrorEvent.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Event_1 = __webpack_require__(/*! ./Event */ "./js-compile/raw-pixi-ts/Event.js");
class IOErrorEvent extends Event_1.Event {
    constructor(type, bubble = true, cancelable = true) {
        super(type, bubble, cancelable);
        this.errorId = 0;
    }
    clone() {
        var event = new IOErrorEvent(this.type, this.bubbles, this.cancelable);
        event.text = this.text;
        event.errorId = this.errorId;
        return event;
    }
    get isDisposable() {
        return false;
    }
}
IOErrorEvent.IO_ERROR = "ioError";
exports.IOErrorEvent = IOErrorEvent;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/ImageResource.js":
/*!*************************************************!*\
  !*** ./js-compile/raw-pixi-ts/ImageResource.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseImageResource_1 = __webpack_require__(/*! ./BaseImageResource */ "./js-compile/raw-pixi-ts/BaseImageResource.js");
const DisplaySettings_1 = __webpack_require__(/*! ./DisplaySettings */ "./js-compile/raw-pixi-ts/DisplaySettings.js");
const Logger_1 = __webpack_require__(/*! ./Logger */ "./js-compile/raw-pixi-ts/Logger.js");
class ImageResource extends BaseImageResource_1.BaseImageResource {
    constructor(source, options = {}) {
        super(source);
        if (!(source instanceof HTMLImageElement)) {
            var imageElement = new Image();
            // BaseImageResource.crossOrigin(imageElement, source, options.crossorigin);
            imageElement.src = source;
            source = imageElement;
            this.source = source;
        }
        /**
         * URL of the image source
         * @member {string}
         */
        this.url = source.src;
        /**
         * When process is completed
         * @member {Promise<void>}
         * @private
         */
        this._process = null;
        /**
         * If the image should be disposed after upload
         * @member {boolean}
         * @default false
         */
        this.preserveBitmap = false;
        /**
         * If capable, convert the image using createImageBitmap API
         * @member {boolean}
         * @default PIXI.settings.CREATE_IMAGE_BITMAP
         */
        this.createBitmap = options.createBitmap !== false && DisplaySettings_1.DisplaySettings.CREATE_IMAGE_BITMAP && !!window.createImageBitmap;
        /**
         * Controls texture premultiplyAlpha field
         * Copies from options
         * @member {boolean|null}
         * @readonly
         */
        this.premultiplyAlpha = options.premultiplyAlpha !== false;
        /**
         * The ImageBitmap element created for HTMLImageElement
         * @member {ImageBitmap}
         * @default null
         */
        this.bitmap = null;
        /**
         * Promise when loading
         * @member {Promise<void>}
         * @private
         * @default null
         */
        this._load = null;
        if (options.autoLoad !== false) {
            this.load();
        }
    }
    /**
     * returns a promise when image will be loaded and processed
     *
     * @param {boolean} [createBitmap=true] whether process image into bitmap
     * @returns {Promise<void>}
     */
    load(createBitmap = undefined) {
        if (createBitmap !== undefined) {
            this.createBitmap = createBitmap;
        }
        if (this._load) {
            return this._load;
        }
        this._load = new Promise((resolve) => {
            Logger_1.trace("source " + this.source);
            this.url = this.source.src;
            var ref = this;
            var source = ref.source;
            var completed = () => {
                if (this.destroyed) {
                    return;
                }
                source.onload = null;
                source.onerror = null;
                this.resize(source.width, source.height);
                this._load = null;
                if (this.createBitmap) {
                    resolve(this.process());
                }
                else {
                    resolve(this);
                }
            };
            if (source.complete && source.src) {
                completed();
            }
            else {
                source.onload = completed;
            }
        });
        return this._load;
    }
    ;
    /**
    * Called when we need to convert image into BitmapImage.
    * Can be called multiple times, real promise is cached inside.
    *
    * @returns {Promise<void>} cached promise to fill that bitmap
    */
    process() {
        if (this._process !== null) {
            return this._process;
        }
        if (this.bitmap !== null || !window.createImageBitmap) {
            return Promise.resolve(this);
        }
        this._process = window.createImageBitmap(this.source, 0, 0, this.source.width, this.source.height)
            .then((bitmap) => {
            if (this.destroyed) {
                return Promise.reject("");
            }
            this.bitmap = bitmap;
            this.update(0);
            this._process = null;
            return Promise.resolve(this);
        });
        return this._process;
    }
    ;
    /**
    * Upload the image resource to GPU.
    *
    * @param {PIXI.Renderer} renderer - Renderer to upload to
    * @param {PIXI.BaseTexture} baseTexture - BaseTexture for this resource
    * @param {PIXI.GLTexture} glTexture - GLTexture to use
    * @returns {boolean} true is success
    */
    upload(renderer, baseTexture, glTexture) {
        baseTexture.premultiplyAlpha = this.premultiplyAlpha;
        // reveal(this.bitmap)
        if (!this.createBitmap) {
            return super.upload(renderer, baseTexture, glTexture);
        }
        if (!this.bitmap) {
            // yeah, ignore the output
            this.process();
            if (!this.bitmap) {
                return false;
            }
        }
        Logger_1.trace("uploading");
        super.upload(renderer, baseTexture, glTexture, this.bitmap);
        if (!this.preserveBitmap) {
            // checks if there are other renderers that possibly need this bitmap
            var flag = true;
            for (var key in baseTexture._glTextures) {
                var otherTex = baseTexture._glTextures[key];
                if (otherTex !== glTexture && otherTex.dirtyId !== baseTexture.dirtyId) {
                    flag = false;
                    break;
                }
            }
            if (flag) {
                if (this.bitmap.close) {
                    this.bitmap.close();
                }
                Logger_1.trace("bitmap flagged");
                this.bitmap = null;
            }
        }
        return true;
    }
    ;
    /**
    * Destroys this texture
    * @override
    */
    dispose() {
        super.dispose();
        if (this.bitmap) {
            this.bitmap.close();
            this.bitmap = null;
        }
        this._process = null;
        this._load = null;
    }
    ;
}
exports.ImageResource = ImageResource;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/InteractionData.js":
/*!***************************************************!*\
  !*** ./js-compile/raw-pixi-ts/InteractionData.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Point_1 = __webpack_require__(/*! ./Point */ "./js-compile/raw-pixi-ts/Point.js");
class InteractionData {
    constructor() {
        this.global = new Point_1.Point();
        this.target = null;
        this.originalEvent = null;
        this.identifier = null;
        this.isPrimary = false;
        this.button = 0;
        this.buttons = 0;
        this.width = 0;
        this.height = 0;
        this.tiltX = 0;
        this.tiltY = 0;
        this.pointerType = null;
        this.pressure = 0;
        this.rotationAngle = 0;
        this.twist = 0;
        this.tangentialPressure = 0;
        this.which = 0;
    }
    getLocalPosition(displayObject, point = null, globalPos = null) {
        return displayObject.worldTransform.applyInverse(globalPos || this.global, point);
    }
    ;
    copyEvent(event) {
        if (event.isPrimary) {
            this.isPrimary = true;
        }
        this.button = event.button;
        this.buttons = Number.isInteger(event.buttons) ? event.buttons : event.which;
        this.width = event.width;
        this.height = event.height;
        this.tiltX = event.tiltX;
        this.tiltY = event.tiltY;
        this.pointerType = event.pointerType;
        this.pressure = event.pressure;
        this.rotationAngle = event.rotationAngle;
        this.twist = event.twist || 0;
        this.tangentialPressure = event.tangentialPressure || 0;
    }
    ;
    get pointerId() {
        return this.identifier;
    }
    ;
    reset() {
        this.isPrimary = false;
    }
    ;
}
exports.InteractionData = InteractionData;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/InteractionEvent.js":
/*!****************************************************!*\
  !*** ./js-compile/raw-pixi-ts/InteractionEvent.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Event_1 = __webpack_require__(/*! ./Event */ "./js-compile/raw-pixi-ts/Event.js");
class InteractionEvent extends Event_1.Event {
    constructor(type, bubble = true, cancelable = true) {
        super(type, bubble, cancelable);
        this.target = null;
        this.stopped = false;
        this._currentTarget = null;
        this._type = null;
        this.data = null;
    }
    reset() {
        this.stopped = false;
        this._currentTarget = null;
        this.target = null;
    }
    ;
    stopPropagation() {
        this.stopped = true;
    }
    ;
}
exports.InteractionEvent = InteractionEvent;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/InteractionManager.js":
/*!******************************************************!*\
  !*** ./js-compile/raw-pixi-ts/InteractionManager.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const InteractionData_1 = __webpack_require__(/*! ./InteractionData */ "./js-compile/raw-pixi-ts/InteractionData.js");
const InteractionEvent_1 = __webpack_require__(/*! ./InteractionEvent */ "./js-compile/raw-pixi-ts/InteractionEvent.js");
const MouseEvent_1 = __webpack_require__(/*! ./MouseEvent */ "./js-compile/raw-pixi-ts/MouseEvent.js");
const InteractionTrackingData_1 = __webpack_require__(/*! ./InteractionTrackingData */ "./js-compile/raw-pixi-ts/InteractionTrackingData.js");
const Ticker_1 = __webpack_require__(/*! ./Ticker */ "./js-compile/raw-pixi-ts/Ticker.js");
const Point_1 = __webpack_require__(/*! ./Point */ "./js-compile/raw-pixi-ts/Point.js");
const Container_1 = __webpack_require__(/*! ./Container */ "./js-compile/raw-pixi-ts/Container.js");
const Rectangle_1 = __webpack_require__(/*! ./Rectangle */ "./js-compile/raw-pixi-ts/Rectangle.js");
const EventDispatcher_1 = __webpack_require__(/*! ./EventDispatcher */ "./js-compile/raw-pixi-ts/EventDispatcher.js");
class InteractionManager extends EventDispatcher_1.EventDispatcher {
    constructor(renderer) {
        super();
        this.update = (deltaTime) => {
            this._deltaTime += deltaTime;
            if (this._deltaTime < this.interactionFrequency) {
                return;
            }
            this._deltaTime = 0;
            if (!this.interactionDOMElement) {
                return;
            }
            if (this.didMove) {
                this.didMove = false;
                return;
            }
            this.cursor = null;
            for (let k in this.activeInteractionData) {
                if (this.activeInteractionData.hasOwnProperty(k)) {
                    let interactionData = this.activeInteractionData[k];
                    if (interactionData.originalEvent && interactionData.pointerType !== 'touch') {
                        let interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, interactionData.originalEvent, interactionData);
                        this.processInteractive(interactionEvent, this.renderer._lastObjectRendered, this.processPointerOverOut, true);
                    }
                }
            }
            this.setCursorMode(this.cursor);
        };
        this.onPointerUp = (event) => {
            if (this.supportsTouchEvents && event.pointerType === 'touch') {
                return;
            }
            this.onPointerComplete(event, false, this.processPointerUp);
        };
        this.onPointerCancel = (event) => {
            if (this.supportsTouchEvents && event.pointerType === 'touch') {
                return;
            }
            this.onPointerComplete(event, true, this.processPointerCancel);
        };
        this.onPointerOver = (originalEvent) => {
            let events = this.normalizeToPointerData(originalEvent);
            let event = events[0];
            let interactionData = this.getInteractionDataForPointerId(event);
            let interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);
            interactionEvent.data.originalEvent = event;
            if (event.pointerType === 'mouse') {
                this.mouseOverRenderer = true;
            }
            let pointer = new MouseEvent_1.MouseEvent(MouseEvent_1.MouseEvent.POINTER_OVER);
            pointer.data = interactionData;
            this.dispatchEvent(pointer);
            if (event.pointerType === 'mouse' || event.pointerType === 'pen') {
                let pointer = new MouseEvent_1.MouseEvent(MouseEvent_1.MouseEvent.MOUSE_OVER);
                pointer.data = interactionData;
                this.dispatchEvent(pointer);
                this.dispatchEvent(pointer);
            }
        };
        this.onPointerOut = (originalEvent) => {
            if (this.supportsTouchEvents && originalEvent.pointerType === 'touch') {
                return;
            }
            let events = this.normalizeToPointerData(originalEvent);
            let event = events[0];
            if (event.pointerType === 'mouse') {
                this.mouseOverRenderer = false;
                this.setCursorMode(null);
            }
            let interactionData = this.getInteractionDataForPointerId(event);
            let interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);
            interactionEvent.data.originalEvent = event;
            this.processInteractive(interactionEvent, this.renderer._lastObjectRendered, this.processPointerOverOut, false);
            let pointer = new MouseEvent_1.MouseEvent(MouseEvent_1.MouseEvent.POINTER_OUT);
            pointer.data = interactionData;
            this.dispatchEvent(pointer);
            if (event.pointerType === 'mouse' || event.pointerType === 'pen') {
                let pointer = new MouseEvent_1.MouseEvent(MouseEvent_1.MouseEvent.MOUSE_OUT);
                pointer.data = interactionData;
                this.dispatchEvent(pointer);
            }
            else {
                this.releaseInteractionDataForPointerId(interactionData.identifier);
            }
        };
        this.onPointerDown = (originalEvent) => {
            if (this.supportsTouchEvents && originalEvent.pointerType === 'touch') {
                return;
            }
            let events = this.normalizeToPointerData(originalEvent);
            let event = events[0];
            if (this.autoPreventDefault && event.isNormalized) {
                let cancelable = originalEvent.cancelable || !('cancelable' in originalEvent);
                if (cancelable) {
                    originalEvent.preventDefault();
                }
            }
            let eventLen = events.length;
            for (let i = 0; i < eventLen; i++) {
                let event = events[i];
                let interactionData = this.getInteractionDataForPointerId(event);
                let interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);
                interactionEvent.data.originalEvent = originalEvent;
                let result = this.processInteractive(interactionEvent, this.renderer._lastObjectRendered, this.processPointerDown, true);
                let pointer = new MouseEvent_1.MouseEvent(MouseEvent_1.MouseEvent.POINTER_DOWN);
                pointer.data = interactionData;
                this.dispatchEvent(pointer);
                if (event.pointerType === 'touch') {
                    let pointer = new MouseEvent_1.MouseEvent(MouseEvent_1.MouseEvent.TOUCH_START);
                    pointer.data = interactionData;
                    this.dispatchEvent(pointer);
                }
                else if (event.pointerType === 'mouse' || event.pointerType === 'pen') {
                    let isRightButton = event.button === 2;
                    let pointer = new MouseEvent_1.MouseEvent(isRightButton ? MouseEvent_1.MouseEvent.RIGHT_MOUSE_DOWN : MouseEvent_1.MouseEvent.MOUSE_DOWN);
                    pointer.data = interactionData;
                    this.dispatchEvent(pointer);
                }
            }
        };
        this.onPointerMove = (originalEvent) => {
            if (this.supportsTouchEvents && originalEvent.pointerType === 'touch') {
                return;
            }
            let events = this.normalizeToPointerData(originalEvent);
            if (events[0].pointerType === 'mouse' || events[0].pointerType === 'pen') {
                this.didMove = true;
                this.cursor = null;
            }
            let eventLen = events.length;
            for (var i = 0; i < eventLen; i++) {
                let event = events[i];
                let interactionData = this.getInteractionDataForPointerId(event);
                let interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);
                interactionEvent.data.originalEvent = originalEvent;
                let interactive = event.pointerType === 'touch' ? this.moveWhenInside : true;
                this.processInteractive(interactionEvent, this.renderer._lastObjectRendered, this.processPointerMove, interactive);
                let pointer = new MouseEvent_1.MouseEvent(MouseEvent_1.MouseEvent.POINTER_MOVE);
                pointer.data = interactionData;
                this.dispatchEvent(pointer);
                if (event.pointerType === 'touch') {
                    let pointer = new MouseEvent_1.MouseEvent(MouseEvent_1.MouseEvent.TOUCH_MOVE);
                    pointer.data = interactionData;
                    this.dispatchEvent(pointer);
                }
                if (event.pointerType === 'mouse' || event.pointerType === 'pen') {
                    let pointer = new MouseEvent_1.MouseEvent(MouseEvent_1.MouseEvent.MOUSE_MOVE);
                    pointer.data = interactionData;
                    this.dispatchEvent(pointer);
                }
            }
            if (events[0].pointerType === 'mouse') {
                this.setCursorMode(this.cursor);
            }
        };
        this.processPointerDown = (interactionEvent, displayObject, hit) => {
            let data = interactionEvent.data;
            let id = interactionEvent.data.identifier;
            if (hit) {
                if (!displayObject.trackedPointers[id]) {
                    displayObject.trackedPointers[id] = new InteractionTrackingData_1.InteractionTrackingData(id);
                }
                let pointer = new MouseEvent_1.MouseEvent(MouseEvent_1.MouseEvent.POINTER_DOWN);
                pointer.data = data;
                displayObject.dispatchEvent(pointer);
                if (data.pointerType === 'touch') {
                    let pointer = new MouseEvent_1.MouseEvent(MouseEvent_1.MouseEvent.TOUCH_START);
                    pointer.data = data;
                    displayObject.dispatchEvent(pointer);
                }
                else if (data.pointerType === 'mouse' || data.pointerType === 'pen') {
                    let isRightButton = data.button === 2;
                    if (isRightButton) {
                        displayObject.trackedPointers[id].rightDown = true;
                    }
                    else {
                        displayObject.trackedPointers[id].leftDown = true;
                    }
                    let pointer = new MouseEvent_1.MouseEvent(isRightButton ? MouseEvent_1.MouseEvent.RIGHT_MOUSE_DOWN : MouseEvent_1.MouseEvent.MOUSE_DOWN);
                    pointer.data = data;
                    displayObject.dispatchEvent(pointer);
                }
            }
        };
        this.processPointerUp = (interactionEvent, displayObject, hit) => {
            let data = interactionEvent.data;
            let id = interactionEvent.data.identifier;
            let trackingData = displayObject.trackedPointers[id];
            let isTouch = data.pointerType === 'touch';
            let isMouse = (data.pointerType === 'mouse' || data.pointerType === 'pen');
            let isMouseTap = false;
            if (isMouse) {
                let isRightButton = data.button === 2;
                let flags = InteractionTrackingData_1.InteractionTrackingData.FLAGS;
                let test = isRightButton ? flags.RIGHT_DOWN : flags.LEFT_DOWN;
                let isDown = trackingData !== undefined && (trackingData.flags & test);
                if (hit) {
                    let pointer = new MouseEvent_1.MouseEvent(isRightButton ? MouseEvent_1.MouseEvent.RIGHT_MOUSE_UP : MouseEvent_1.MouseEvent.MOUSE_UP);
                    pointer.data = data;
                    displayObject.dispatchEvent(pointer);
                    if (isDown) {
                        let pointer = new MouseEvent_1.MouseEvent(isRightButton ? MouseEvent_1.MouseEvent.RIGHT_CLICK : MouseEvent_1.MouseEvent.CLICK);
                        pointer.data = data;
                        displayObject.dispatchEvent(pointer);
                        isMouseTap = true;
                    }
                }
                else if (isDown) {
                    let pointer = new MouseEvent_1.MouseEvent(isRightButton ? MouseEvent_1.MouseEvent.RIGHT_MOUSE_UP_OUTSIDE : MouseEvent_1.MouseEvent.MOUSE_UP_OUTSIDE);
                    pointer.data = data;
                    displayObject.dispatchEvent(pointer);
                }
                if (trackingData) {
                    if (isRightButton) {
                        trackingData.rightDown = false;
                    }
                    else {
                        trackingData.leftDown = false;
                    }
                }
            }
            if (hit) {
                let pointer = new MouseEvent_1.MouseEvent(MouseEvent_1.MouseEvent.POINTER_UP);
                pointer.data = data;
                displayObject.dispatchEvent(pointer);
                if (isTouch) {
                    let pointer = new MouseEvent_1.MouseEvent(MouseEvent_1.MouseEvent.TOUCH_END);
                    pointer.data = data;
                    displayObject.dispatchEvent(pointer);
                }
                if (trackingData) {
                    if (!isMouse || isMouseTap) {
                        let pointer = new MouseEvent_1.MouseEvent(MouseEvent_1.MouseEvent.POINTER_TAP);
                        pointer.data = data;
                        displayObject.dispatchEvent(pointer);
                    }
                    if (isTouch) {
                        let pointer = new MouseEvent_1.MouseEvent(MouseEvent_1.MouseEvent.TOUCH_TAP);
                        pointer.data = data;
                        displayObject.dispatchEvent(pointer);
                        trackingData.over = false;
                    }
                }
            }
            else if (trackingData) {
                let pointer = new MouseEvent_1.MouseEvent(MouseEvent_1.MouseEvent.POINTER_UP_OUTSIDE);
                pointer.data = data;
                displayObject.dispatchEvent(pointer);
                if (isTouch) {
                    let pointer = new MouseEvent_1.MouseEvent(MouseEvent_1.MouseEvent.TOUCH_END_OUTSIDE);
                    pointer.data = data;
                    displayObject.dispatchEvent(pointer);
                }
            }
            if (trackingData && trackingData.none) {
                delete displayObject.trackedPointers[id];
            }
        };
        this.processPointerMove = (interactionEvent, displayObject, hit) => {
            let data = interactionEvent.data;
            let isTouch = data.pointerType === 'touch';
            let isMouse = (data.pointerType === 'mouse' || data.pointerType === 'pen');
            if (isMouse) {
                this.processPointerOverOut(interactionEvent, displayObject, hit);
            }
            if (!this.moveWhenInside || hit) {
                let pointer = new MouseEvent_1.MouseEvent(MouseEvent_1.MouseEvent.POINTER_MOVE);
                pointer.data = data;
                displayObject.dispatchEvent(pointer);
                if (isTouch) {
                    let pointer = new MouseEvent_1.MouseEvent(MouseEvent_1.MouseEvent.TOUCH_MOVE);
                    pointer.data = data;
                    displayObject.dispatchEvent(pointer);
                }
                if (isMouse) {
                    let pointer = new MouseEvent_1.MouseEvent(MouseEvent_1.MouseEvent.MOUSE_MOVE);
                    pointer.data = data;
                    displayObject.dispatchEvent(pointer);
                }
            }
        };
        this.processPointerOverOut = (interactionEvent, displayObject, hit) => {
            let data = interactionEvent.data;
            let id = interactionEvent.data.identifier;
            let isMouse = (data.pointerType === 'mouse' || data.pointerType === 'pen');
            let trackingData = displayObject.trackedPointers[id];
            if (hit && !trackingData) {
                trackingData = displayObject.trackedPointers[id] = new InteractionTrackingData_1.InteractionTrackingData(id);
            }
            if (trackingData === undefined) {
                return;
            }
            if (hit && this.mouseOverRenderer) {
                if (!trackingData.over) {
                    trackingData.over = true;
                    let pointer = new MouseEvent_1.MouseEvent(MouseEvent_1.MouseEvent.POINTER_OVER);
                    pointer.data = data;
                    displayObject.dispatchEvent(pointer);
                    if (isMouse) {
                        let pointer = new MouseEvent_1.MouseEvent(MouseEvent_1.MouseEvent.MOUSE_OVER);
                        pointer.data = data;
                        displayObject.dispatchEvent(pointer);
                    }
                }
                if (isMouse && this.cursor === null) {
                    this.cursor = displayObject.cursor;
                }
            }
            else if (trackingData.over) {
                trackingData.over = false;
                let pointer = new MouseEvent_1.MouseEvent(MouseEvent_1.MouseEvent.POINTER_OUT);
                pointer.data = data;
                displayObject.dispatchEvent(pointer);
                if (isMouse) {
                    let pointer = new MouseEvent_1.MouseEvent(MouseEvent_1.MouseEvent.MOUSE_OUT);
                    pointer.data = data;
                    displayObject.dispatchEvent(pointer);
                }
                if (trackingData.none) {
                    delete displayObject.trackedPointers[id];
                }
            }
        };
        this.hitTestEvent = new InteractionEvent_1.InteractionEvent(null, null, null);
        this.hitTestEvent.target = null;
        this.renderer = renderer;
        this.autoPreventDefault = true;
        this.interactionFrequency = 10;
        this.mouse = new InteractionData_1.InteractionData();
        this.mouse.identifier = InteractionManager.MOUSE_POINTER_ID;
        this.mouse.global.set(-999999);
        this.activeInteractionData = {};
        this.activeInteractionData[InteractionManager.MOUSE_POINTER_ID] = this.mouse;
        this.interactionDataPool = [];
        this.eventData = new InteractionEvent_1.InteractionEvent("interaction");
        this.interactionDOMElement = null;
        this.moveWhenInside = false;
        this.eventsAdded = false;
        this.mouseOverRenderer = false;
        this.supportsTouchEvents = 'ontouchstart' in window;
        this.supportsPointerEvents = !!window['PointerEvent'];
        this.cursorStyles = {
            default: 'inherit',
            pointer: 'pointer'
        };
        this.currentCursorMode = null;
        this.cursor = null;
        this._tempPoint = new Point_1.Point();
        this.resolution = 1;
        this.setTargetElement(this.renderer.view, this.renderer.resolution);
    }
    setTargetElement(element, resolution = 1) {
        this.removeEvents();
        this.interactionDOMElement = element;
        this.resolution = resolution;
        this.addEvents();
    }
    ;
    removeEvents() {
        if (!this.interactionDOMElement) {
            return;
        }
        Ticker_1.Ticker.system.remove(this.update);
        if (window.navigator.msPointerEnabled) {
            this.interactionDOMElement.style['-ms-content-zooming'] = '';
            this.interactionDOMElement.style['-ms-touch-action'] = '';
        }
        else if (this.supportsPointerEvents) {
            this.interactionDOMElement.style['touch-action'] = '';
        }
        if (this.supportsPointerEvents) {
            window.document.removeEventListener('pointermove', this.onPointerMove);
            this.interactionDOMElement.removeEventListener('pointerdown', this.onPointerDown);
            this.interactionDOMElement.removeEventListener('pointerleave', this.onPointerOut);
            this.interactionDOMElement.removeEventListener('pointerover', this.onPointerOver);
            window.removeEventListener('pointercancel', this.onPointerCancel);
            window.removeEventListener('pointerup', this.onPointerUp);
        }
        else {
            window.document.removeEventListener('mousemove', this.onPointerMove);
            this.interactionDOMElement.removeEventListener('mousedown', this.onPointerDown);
            this.interactionDOMElement.removeEventListener('mouseout', this.onPointerOut);
            this.interactionDOMElement.removeEventListener('mouseover', this.onPointerOver);
            window.removeEventListener('mouseup', this.onPointerUp);
        }
        if (this.supportsTouchEvents) {
            this.interactionDOMElement.removeEventListener('touchstart', this.onPointerDown);
            this.interactionDOMElement.removeEventListener('touchcancel', this.onPointerCancel);
            this.interactionDOMElement.removeEventListener('touchend', this.onPointerUp);
            this.interactionDOMElement.removeEventListener('touchmove', this.onPointerMove);
        }
        this.interactionDOMElement = null;
        this.eventsAdded = false;
    }
    ;
    mapPositionToPoint(point, x, y) {
        let rect;
        if (!this.interactionDOMElement.parentElement) {
            rect = new Rectangle_1.Rectangle();
        }
        else {
            rect = this.interactionDOMElement.getBoundingClientRect();
        }
        let resolutionMultiplier = 1.0 / this.resolution;
        point.x = ((x - rect.left) * (this.interactionDOMElement.width / rect.width)) * resolutionMultiplier;
        point.y = ((y - rect.top) * (this.interactionDOMElement.height / rect.height)) * resolutionMultiplier;
    }
    ;
    configureInteractionEventForDOMEvent(interactionEvent, pointerEvent, interactionData) {
        interactionEvent.data = interactionData;
        this.mapPositionToPoint(interactionData.global, pointerEvent.clientX, pointerEvent.clientY);
        if (pointerEvent.pointerType === 'touch') {
            pointerEvent.globalX = interactionData.global.x;
            pointerEvent.globalY = interactionData.global.y;
        }
        interactionData.originalEvent = pointerEvent;
        interactionEvent.reset();
        return interactionEvent;
    }
    ;
    addEvents() {
        if (!this.interactionDOMElement) {
            return;
        }
        Ticker_1.Ticker.system.add(this.update, this, Ticker_1.Ticker.UPDATE_PRIORITY.INTERACTION);
        if (window.navigator.msPointerEnabled) {
            this.interactionDOMElement.style['-ms-content-zooming'] = 'none';
            this.interactionDOMElement.style['-ms-touch-action'] = 'none';
        }
        else if (this.supportsPointerEvents) {
            this.interactionDOMElement.style['touch-action'] = 'none';
        }
        if (this.supportsPointerEvents) {
            window.document.addEventListener('pointermove', this.onPointerMove);
            this.interactionDOMElement.addEventListener('pointerdown', this.onPointerDown);
            this.interactionDOMElement.addEventListener('pointerleave', this.onPointerOut);
            this.interactionDOMElement.addEventListener('pointerover', this.onPointerOver);
            window.addEventListener('pointercancel', this.onPointerCancel);
            window.addEventListener('pointerup', this.onPointerUp);
        }
        else {
            window.document.addEventListener('mousemove', this.onPointerMove);
            this.interactionDOMElement.addEventListener('mousedown', this.onPointerDown);
            this.interactionDOMElement.addEventListener('mouseout', this.onPointerOut);
            this.interactionDOMElement.addEventListener('mouseover', this.onPointerOver);
            window.addEventListener('mouseup', this.onPointerUp);
        }
        if (this.supportsTouchEvents) {
            this.interactionDOMElement.addEventListener('touchstart', this.onPointerDown);
            this.interactionDOMElement.addEventListener('touchcancel', this.onPointerCancel);
            this.interactionDOMElement.addEventListener('touchend', this.onPointerUp);
            this.interactionDOMElement.addEventListener('touchmove', this.onPointerMove);
        }
        this.eventsAdded = true;
    }
    ;
    processInteractive(interactionEvent, displayObject, func, hitTest, interactive = true) {
        if (!displayObject || !displayObject.visible) {
            return false;
        }
        let point = interactionEvent.data.global;
        interactive = displayObject.interactive || interactive;
        let hit = false;
        let interactiveParent = interactive;
        let hitTestChildren = true;
        if (displayObject.hitArea) {
            if (hitTest) {
                displayObject.worldTransform.applyInverse(point, this._tempPoint);
                if (!displayObject.hitArea.contains(this._tempPoint.x, this._tempPoint.y)) {
                    hitTest = false;
                    hitTestChildren = false;
                }
                else {
                    hit = true;
                }
            }
            interactiveParent = false;
        }
        else if (displayObject._mask) {
            if (hitTest) {
                if (!(displayObject._mask.containsPoint && displayObject._mask.containsPoint(point))) {
                    hitTest = false;
                    hitTestChildren = false;
                }
            }
        }
        if (displayObject instanceof Container_1.Container) {
            if (hitTestChildren && displayObject.interactiveChildren && displayObject.children) {
                let children = displayObject.children;
                for (let i = children.length - 1; i >= 0; i--) {
                    let child = children[i];
                    let childHit = this.processInteractive(interactionEvent, child, func, hitTest, interactiveParent);
                    if (childHit) {
                        if (!child.parent) {
                            continue;
                        }
                        interactiveParent = false;
                        if (childHit) {
                            if (interactionEvent.target) {
                                hitTest = false;
                            }
                            hit = true;
                        }
                    }
                }
            }
        }
        if (interactive) {
            if (hitTest && !interactionEvent.target) {
                if (!displayObject.hitArea && displayObject.containsPoint) {
                    if (displayObject.containsPoint(point)) {
                        hit = true;
                    }
                }
            }
            if (displayObject.interactive) {
                if (hit && !interactionEvent.target) {
                    interactionEvent.target = displayObject;
                }
                if (func) {
                    func(interactionEvent, displayObject, !!hit);
                }
            }
        }
        return hit;
    }
    ;
    setCursorMode(mode = "default") {
        if (this.currentCursorMode === mode) {
            return;
        }
        this.currentCursorMode = mode;
        let style = this.cursorStyles[mode];
        if (style) {
            switch (typeof style) {
                case 'string':
                    this.interactionDOMElement.style.cursor = style;
                    break;
                case 'function':
                    style(mode);
                    break;
                case 'object':
                    Object.assign(this.interactionDOMElement.style, style);
                    break;
            }
        }
        else if (typeof mode === 'string' && !Object.prototype.hasOwnProperty.call(this.cursorStyles, mode)) {
            this.interactionDOMElement.style.cursor = mode;
        }
    }
    ;
    hitTest(globalPoint, root) {
        this.hitTestEvent.target = null;
        this.hitTestEvent.data.global = globalPoint;
        let currentdisplay;
        if (root) {
            currentdisplay = root;
        }
        else {
            currentdisplay = this.renderer._lastObjectRendered;
        }
        this.processInteractive(this.hitTestEvent, currentdisplay, null, true);
        return this.hitTestEvent.target;
    }
    ;
    normalizeToPointerData(event) {
        let normalizedEvents = [];
        if (this.supportsTouchEvents && event instanceof TouchEvent) {
            for (let i = 0, li = event.changedTouches.length; i < li; i++) {
                let touch = event.changedTouches[i];
                if (typeof touch.button === 'undefined') {
                    touch.button = event.touches.length ? 1 : 0;
                }
                if (typeof touch.buttons === 'undefined') {
                    touch.buttons = event.touches.length ? 1 : 0;
                }
                if (typeof touch.isPrimary === 'undefined') {
                    touch.isPrimary = event.touches.length === 1 && event.type === 'touchstart';
                }
                if (typeof touch.width === 'undefined') {
                    touch.width = touch.radiusX || 1;
                }
                if (typeof touch.height === 'undefined') {
                    touch.height = touch.radiusY || 1;
                }
                if (typeof touch.tiltX === 'undefined') {
                    touch.tiltX = 0;
                }
                if (typeof touch.tiltY === 'undefined') {
                    touch.tiltY = 0;
                }
                if (typeof touch.pointerType === 'undefined') {
                    touch.pointerType = 'touch';
                }
                if (typeof touch.pointerId === 'undefined') {
                    touch.pointerId = touch.identifier || 0;
                }
                if (typeof touch.pressure === 'undefined') {
                    touch.pressure = touch.force || 0.5;
                }
                if (typeof touch.twist === 'undefined') {
                    touch.twist = 0;
                }
                if (typeof touch.tangentialPressure === 'undefined') {
                    touch.tangentialPressure = 0;
                }
                if (typeof touch.layerX === 'undefined') {
                    touch.layerX = touch.offsetX = touch.clientX;
                }
                if (typeof touch.layerY === 'undefined') {
                    touch.layerY = touch.offsetY = touch.clientY;
                }
                touch.isNormalized = true;
                normalizedEvents.push(touch);
            }
        }
        else if (event instanceof MouseEvent_1.MouseEvent && (!this.supportsPointerEvents || !(event instanceof window['PointerEvent']))) {
            let originevent = event;
            if (typeof originevent.isPrimary === 'undefined') {
                originevent.isPrimary = true;
            }
            if (typeof originevent.width === 'undefined') {
                originevent.width = 1;
            }
            if (typeof originevent.height === 'undefined') {
                originevent.height = 1;
            }
            if (typeof originevent.tiltX === 'undefined') {
                originevent.tiltX = 0;
            }
            if (typeof originevent.tiltY === 'undefined') {
                originevent.tiltY = 0;
            }
            if (typeof originevent.pointerType === 'undefined') {
                originevent.pointerType = 'mouse';
            }
            if (typeof originevent.pointerId === 'undefined') {
                originevent.pointerId = InteractionManager.MOUSE_POINTER_ID;
            }
            if (typeof originevent.pressure === 'undefined') {
                originevent.pressure = 0.5;
            }
            if (typeof originevent.twist === 'undefined') {
                originevent.twist = 0;
            }
            if (typeof originevent.tangentialPressure === 'undefined') {
                originevent.tangentialPressure = 0;
            }
            originevent.isNormalized = true;
            normalizedEvents.push(event);
        }
        else {
            normalizedEvents.push(event);
        }
        return normalizedEvents;
    }
    ;
    getInteractionDataForPointerId(event) {
        let pointerId = event.pointerId;
        let interactionData;
        if (pointerId === InteractionManager.MOUSE_POINTER_ID || event.pointerType === 'mouse') {
            interactionData = this.mouse;
        }
        else if (this.activeInteractionData[pointerId]) {
            interactionData = this.activeInteractionData[pointerId];
        }
        else {
            interactionData = this.interactionDataPool.pop() || new InteractionData_1.InteractionData();
            interactionData.identifier = pointerId;
            this.activeInteractionData[pointerId] = interactionData;
        }
        interactionData.copyEvent(event);
        return interactionData;
    }
    ;
    onPointerComplete(originalEvent, cancelled, func) {
        let events = this.normalizeToPointerData(originalEvent);
        let eventLen = events.length;
        let eventAppend = originalEvent.target !== this.interactionDOMElement ? 'outside' : '';
        for (let i = 0; i < eventLen; i++) {
            let event = events[i];
            let interactionData = this.getInteractionDataForPointerId(event);
            let interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);
            interactionEvent.data.originalEvent = originalEvent;
            this.processInteractive(interactionEvent, this.renderer._lastObjectRendered, func, cancelled || !eventAppend);
            let pointer = new MouseEvent_1.MouseEvent(cancelled ? MouseEvent_1.MouseEvent.POINTER_CANCEL : (MouseEvent_1.MouseEvent.POINTER_UP));
            pointer.data = interactionData;
            this.dispatchEvent(pointer);
            if (event.pointerType === 'mouse' || event.pointerType === 'pen') {
                let isRightButton = event.button === 2;
                let pointer = new MouseEvent_1.MouseEvent(isRightButton ? (MouseEvent_1.MouseEvent.RIGHT_MOUSE_UP) : (MouseEvent_1.MouseEvent.MOUSE_UP));
                pointer.data = interactionData;
                this.dispatchEvent(pointer);
            }
            else if (event.pointerType === 'touch') {
                let pointer = new MouseEvent_1.MouseEvent(cancelled ? MouseEvent_1.MouseEvent.TOUCH_CANCEL : (MouseEvent_1.MouseEvent.TOUCH_END));
                pointer.data = interactionData;
                this.dispatchEvent(pointer);
                this.releaseInteractionDataForPointerId(event.pointerId);
            }
        }
    }
    ;
    releaseInteractionDataForPointerId(pointerId) {
        let interactionData = this.activeInteractionData[pointerId];
        if (interactionData) {
            delete this.activeInteractionData[pointerId];
            interactionData.reset();
            this.interactionDataPool.push(interactionData);
        }
    }
    ;
    processPointerCancel(interactionEvent, displayObject) {
        let data = interactionEvent.data;
        let id = interactionEvent.data.identifier;
        if (displayObject.trackedPointers[id] !== undefined) {
            delete displayObject.trackedPointers[id];
            let pointer = new MouseEvent_1.MouseEvent(MouseEvent_1.MouseEvent.POINTER_CANCEL);
            pointer.data = data;
            displayObject.dispatchEvent(pointer);
            if (data.pointerType === 'touch') {
                let pointer = new MouseEvent_1.MouseEvent(MouseEvent_1.MouseEvent.TOUCH_CANCEL);
                pointer.data = data;
                displayObject.dispatchEvent(pointer);
            }
        }
    }
    ;
    destroy(options = null) {
        this.removeEvents();
        this.renderer = null;
        this.mouse = null;
        this.eventData = null;
        this.interactionDOMElement = null;
        this.onPointerDown = null;
        this.processPointerDown = null;
        this.onPointerUp = null;
        this.processPointerUp = null;
        this.onPointerCancel = null;
        this.processPointerCancel = null;
        this.onPointerMove = null;
        this.processPointerMove = null;
        this.onPointerOut = null;
        this.processPointerOverOut = null;
        this.onPointerOver = null;
        this._tempPoint = null;
    }
    ;
}
InteractionManager.MOUSE_POINTER_ID = 1;
exports.InteractionManager = InteractionManager;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/InteractionTrackingData.js":
/*!***********************************************************!*\
  !*** ./js-compile/raw-pixi-ts/InteractionTrackingData.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class InteractionTrackingData {
    constructor(pointerId) {
        this._pointerId = pointerId;
        this._flags = InteractionTrackingData.FLAGS.NONE;
    }
    _doSet(flag, yn) {
        if (yn) {
            this._flags = this._flags | flag;
        }
        else {
            this._flags = this._flags & (~flag);
        }
    }
    ;
    get pointerId() {
        return this._pointerId;
    }
    ;
    get flags() {
        return this._flags;
    }
    ;
    set flags(flags) {
        this._flags = flags;
    }
    ;
    get none() {
        return this._flags === InteractionTrackingData.FLAGS.NONE;
    }
    ;
    get over() {
        return (this._flags & InteractionTrackingData.FLAGS.OVER) !== 0;
    }
    ;
    set over(yn) {
        this._doSet(InteractionTrackingData.FLAGS.OVER, yn);
    }
    ;
    get rightDown() {
        return (this._flags & InteractionTrackingData.FLAGS.RIGHT_DOWN) !== 0;
    }
    ;
    set rightDown(yn) {
        this._doSet(InteractionTrackingData.FLAGS.RIGHT_DOWN, yn);
    }
    ;
    get leftDown() {
        return (this._flags & InteractionTrackingData.FLAGS.LEFT_DOWN) !== 0;
    }
    ;
    set leftDown(yn) {
        this._doSet(InteractionTrackingData.FLAGS.LEFT_DOWN, yn);
    }
    ;
}
InteractionTrackingData.FLAGS = {
    NONE: 0,
    OVER: 1 << 0,
    LEFT_DOWN: 1 << 1,
    RIGHT_DOWN: 1 << 2,
};
exports.InteractionTrackingData = InteractionTrackingData;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/LineStyle.js":
/*!*********************************************!*\
  !*** ./js-compile/raw-pixi-ts/LineStyle.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const FillStyle_1 = __webpack_require__(/*! ./FillStyle */ "./js-compile/raw-pixi-ts/FillStyle.js");
class LineStyle extends FillStyle_1.FillStyle {
    constructor() {
        super();
    }
    clone() {
        var obj = new LineStyle();
        obj.color = this.color;
        obj.alpha = this.alpha;
        obj.texture = this.texture;
        obj.matrix = this.matrix;
        obj.visible = this.visible;
        obj.width = this.width;
        obj.alignment = this.alignment;
        obj.native = this.native;
        return obj;
    }
    ;
    /**
     * Reset the line style to default.
     */
    reset() {
        super.reset();
        // Override default line style color
        this.color = 0x0;
        /**
         * The width (thickness) of any lines drawn.
         *
         * @member {number}
         * @default 0
         */
        this.width = 0;
        /**
         * The alignment of any lines drawn (0.5 = middle, 1 = outter, 0 = inner).
         *
         * @member {number}
         * @default 0
         */
        this.alignment = 0.5;
        /**
         * If true the lines will be draw using LINES instead of TRIANGLE_STRIP
         *
         * @member {boolean}
         * @default false
         */
        this.native = false;
    }
    ;
}
exports.LineStyle = LineStyle;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/Logger.js":
/*!******************************************!*\
  !*** ./js-compile/raw-pixi-ts/Logger.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.OUTPUT_TO_CONSOLE = true;
exports.trace = function (value) {
    try {
        if (!value) {
            if (isNaN(value)) {
                var result = "show: null";
            }
            else {
                var result = "show: 0";
            }
        }
        else {
            var result = "show: " + value.toString();
        }
        if (exports.OUTPUT_TO_CONSOLE) {
            console.log(result);
        }
        return result;
    }
    catch (e) {
    }
    return null;
};
exports.revealMethods = function (value) {
    try {
        if (!value) {
            var result = "reveal methods: null";
        }
        else {
            var result = "reveal methods: ";
        }
        for (var key in value) {
            var instanceItem = value[key];
            if (instanceItem instanceof Function) {
                result += 'method: ' + key + ' : ' + value[key] + "\n";
            }
        }
        if (exports.OUTPUT_TO_CONSOLE) {
            console.log(result);
        }
        return result;
    }
    catch (e) {
    }
    return null;
};
exports.reveal = function (value) {
    if (!value) {
        var result = "reveal: null";
        if (exports.OUTPUT_TO_CONSOLE) {
            console.log(result);
        }
        return;
    }
    if (value === undefined) {
        var result = "reveal: undefined";
        if (exports.OUTPUT_TO_CONSOLE) {
            console.log(result);
        }
        return;
    }
    var result = "reveal: ";
    for (var key in value) {
        var instanceItem = getValue(key, value);
        if (instanceItem) {
            if (instanceItem instanceof Function) {
                result += 'method: ' + key + "\n";
            }
            else {
                try {
                    result += key + ' : ' + instanceItem + "\n";
                }
                catch (e) {
                }
            }
        }
    }
    if (exports.OUTPUT_TO_CONSOLE) {
        console.log(result);
    }
    return result;
};
const getValue = function (key, value) {
    var valueResult = null;
    try {
        valueResult = value[key];
    }
    catch (e) {
    }
    return valueResult;
};


/***/ }),

/***/ "./js-compile/raw-pixi-ts/MaskSystem.js":
/*!**********************************************!*\
  !*** ./js-compile/raw-pixi-ts/MaskSystem.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const System_1 = __webpack_require__(/*! ./System */ "./js-compile/raw-pixi-ts/System.js");
const SpriteMaskFilter_1 = __webpack_require__(/*! ./SpriteMaskFilter */ "./js-compile/raw-pixi-ts/SpriteMaskFilter.js");
class MaskSystem extends System_1.System {
    constructor(renderer) {
        super(renderer);
        // TODO - we don't need both!
        /**
         * `true` if current pushed masked is scissor
         * @member {boolean}
         * @readonly
         */
        this.scissor = false;
        /**
         * Mask data
         * @member {PIXI.Graphics}
         * @readonly
         */
        this.scissorData = null;
        /**
         * Target to mask
         * @member {PIXI.DisplayObject}
         * @readonly
         */
        this.scissorRenderTarget = null;
        /**
         * Enable scissor
         * @member {boolean}
         * @readonly
         */
        this.enableScissor = false;
        /**
         * Pool of used sprite mask filters
         * @member {PIXI.SpriteMaskFilter[]}
         * @readonly
         */
        this.alphaMaskPool = [];
        /**
         * Current index of alpha mask pool
         * @member {number}
         * @default 0
         * @readonly
         */
        this.alphaMaskIndex = 0;
    }
    /**
     * Applies the Mask and adds it to the current filter stack.
     *
     * @param {PIXI.DisplayObject} target - Display Object to push the mask to
     * @param {PIXI.Sprite|PIXI.Graphics} maskData - The masking data.
     */
    push(target, maskData) {
        // TODO the root check means scissor rect will not
        // be used on render textures more info here:
        // https://github.com/pixijs/pixi.js/pull/3545
        if (maskData.isSprite) {
            this.pushSpriteMask(target, maskData);
        }
        else if (this.enableScissor
            && !this.scissor
            && this.renderer._activeRenderTarget.root
            && !this.renderer.stencil.stencilMaskStack.length
            && maskData.isFastRect()) {
            var matrix = maskData.worldTransform;
            var rot = Math.atan2(matrix.b, matrix.a);
            // use the nearest degree!
            rot = Math.round(rot * (180 / Math.PI));
            if (rot % 90) {
                this.pushStencilMask(maskData);
            }
            else {
                this.pushScissorMask(target, maskData);
            }
        }
        else {
            this.pushStencilMask(maskData);
        }
    }
    ;
    /**
     * Removes the last mask from the mask stack and doesn't return it.
     *
     * @param {PIXI.DisplayObject} target - Display Object to pop the mask from
     * @param {PIXI.Sprite|PIXI.Graphics} maskData - The masking data.
     */
    pop(target, maskData) {
        if (maskData.isSprite) {
            this.popSpriteMask(target, maskData);
        }
        else if (this.enableScissor && !this.renderer.stencil.stencilMaskStack.length) {
            this.popScissorMask(target, maskData);
        }
        else {
            this.popStencilMask(target, maskData);
        }
    }
    ;
    /**
     * Applies the Mask and adds it to the current filter stack.
     *
     * @param {PIXI.RenderTexture} target - Display Object to push the sprite mask to
     * @param {PIXI.Sprite} maskData - Sprite to be used as the mask
     */
    pushSpriteMask(target, maskData) {
        var alphaMaskFilter = this.alphaMaskPool[this.alphaMaskIndex];
        if (!alphaMaskFilter) {
            alphaMaskFilter = this.alphaMaskPool[this.alphaMaskIndex] = [new SpriteMaskFilter_1.SpriteMaskFilter(maskData)];
        }
        alphaMaskFilter[0].resolution = this.renderer.resolution;
        alphaMaskFilter[0].maskSprite = maskData;
        var stashFilterArea = target.filterArea;
        target.filterArea = maskData.getBounds(true);
        this.renderer.filter.push(target, alphaMaskFilter);
        target.filterArea = stashFilterArea;
        this.alphaMaskIndex++;
    }
    ;
    /**
     * Removes the last filter from the filter stack and doesn't return it.
     *
     */
    popSpriteMask(a, b) {
        this.renderer.filter.pop();
        this.alphaMaskIndex--;
    }
    ;
    /**
     * Applies the Mask and adds it to the current filter stack.
     *
     * @param {PIXI.Sprite|PIXI.Graphics} maskData - The masking data.
     */
    pushStencilMask(maskData) {
        this.renderer.batch.flush();
        this.renderer.stencil.pushStencil(maskData);
    }
    ;
    /**
     * Removes the last filter from the filter stack and doesn't return it.
     *
     */
    popStencilMask(a, b) {
        // this.renderer.currentRenderer.stop();
        this.renderer.stencil.popStencil();
    }
    ;
    /**
     *
     * @param {PIXI.DisplayObject} target - Display Object to push the mask to
     * @param {PIXI.Graphics} maskData - The masking data.
     */
    pushScissorMask(target, maskData) {
        maskData.renderable = true;
        var renderTarget = this.renderer._activeRenderTarget;
        var bounds = maskData.getBounds();
        bounds.fit(renderTarget.size);
        maskData.renderable = false;
        this.renderer.gl.enable(this.renderer.gl.SCISSOR_TEST);
        var resolution = this.renderer.resolution;
        this.renderer.gl.scissor(bounds.x * resolution, (renderTarget.root ? renderTarget.size.height - bounds.y - bounds.height : bounds.y) * resolution, bounds.width * resolution, bounds.height * resolution);
        this.scissorRenderTarget = renderTarget;
        this.scissorData = maskData;
        this.scissor = true;
    }
    ;
    /**
     * Pop scissor mask
     *
     */
    popScissorMask(a, b) {
        this.scissorRenderTarget = null;
        this.scissorData = null;
        this.scissor = false;
        // must be scissor!
        var ref = this.renderer;
        var gl = ref.gl;
        gl.disable(gl.SCISSOR_TEST);
    }
    ;
}
exports.MaskSystem = MaskSystem;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/MathSettings.js":
/*!************************************************!*\
  !*** ./js-compile/raw-pixi-ts/MathSettings.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class MathSettings {
    static uid() {
        return ++MathSettings.nextUid;
    }
    static sign(n) {
        if (n === 0) {
            return 0;
        }
        return n < 0 ? -1 : 1;
    }
    static string2hex(string) {
        if (typeof string === 'string' && string[0] === '#') {
            string = string.substr(1);
        }
        return parseInt(string, 16);
    }
    static hex2string(hex) {
        hex = hex.toString(16);
        hex = '000000'.substr(0, 6 - hex.length) + hex;
        return ("#" + hex);
    }
    static log2(v) {
        var r = (v > 0xFFFF) << 4;
        v >>>= r;
        var shift = (v > 0xFF) << 3;
        v >>>= shift;
        r |= shift;
        shift = (v > 0xF) << 2;
        v >>>= shift;
        r |= shift;
        shift = (v > 0x3) << 1;
        v >>>= shift;
        r |= shift;
        return r | (v >> 1);
    }
    static nextPow2(v) {
        v += v === 0;
        --v;
        v |= v >>> 1;
        v |= v >>> 2;
        v |= v >>> 4;
        v |= v >>> 8;
        v |= v >>> 16;
        return v + 1;
    }
    static isPow2(v) {
        return !(v & (v - 1)) && (!!v);
    }
}
MathSettings.nextUid = 0;
MathSettings.PI_2 = Math.PI * 2;
MathSettings.RAD_TO_DEG = 180 / Math.PI;
MathSettings.DEG_TO_RAD = Math.PI / 180;
exports.MathSettings = MathSettings;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/Matrix.js":
/*!******************************************!*\
  !*** ./js-compile/raw-pixi-ts/Matrix.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Point_1 = __webpack_require__(/*! ./Point */ "./js-compile/raw-pixi-ts/Point.js");
const MathSettings_1 = __webpack_require__(/*! ./MathSettings */ "./js-compile/raw-pixi-ts/MathSettings.js");
class Matrix {
    constructor(a = 1, b = 0, c = 0, d = 1, tx = 0, ty = 0) {
        if (a === void 0) {
            a = 1;
        }
        if (b === void 0) {
            b = 0;
        }
        if (c === void 0) {
            c = 0;
        }
        if (d === void 0) {
            d = 1;
        }
        if (tx === void 0) {
            tx = 0;
        }
        if (ty === void 0) {
            ty = 0;
        }
        /**
         * @member {number}
         * @default 1
         */
        this.a = a;
        /**
         * @member {number}
         * @default 0
         */
        this.b = b;
        /**
         * @member {number}
         * @default 0
         */
        this.c = c;
        /**
         * @member {number}
         * @default 1
         */
        this.d = d;
        /**
         * @member {number}
         * @default 0
         */
        this.tx = tx;
        /**
         * @member {number}
         * @default 0
         */
        this.ty = ty;
        this.array = null;
    }
    /**
     * Creates a Matrix object based on the given array. The Element to Matrix mapping order is as follows:
     *
     * a = array[0]
     * b = array[1]
     * c = array[3]
     * d = array[4]
     * tx = array[2]
     * ty = array[5]
     *
     * @param {number[]} array - The array that the matrix will be populated from.
     */
    fromArray(array) {
        this.a = array[0];
        this.b = array[1];
        this.c = array[3];
        this.d = array[4];
        this.tx = array[2];
        this.ty = array[5];
    }
    ;
    /**
     * sets the matrix properties
     *
     * @param {number} a - Matrix component
     * @param {number} b - Matrix component
     * @param {number} c - Matrix component
     * @param {number} d - Matrix component
     * @param {number} tx - Matrix component
     * @param {number} ty - Matrix component
     *
     * @return {PIXI.Matrix} This matrix. Good for chaining method calls.
     */
    set(a, b, c, d, tx, ty) {
        this.a = a;
        this.b = b;
        this.c = c;
        this.d = d;
        this.tx = tx;
        this.ty = ty;
        return this;
    }
    ;
    /**
     * Creates an array from the current Matrix object.
     *
     * @param {boolean} transpose - Whether we need to transpose the matrix or not
     * @param {Float32Array} [out=new Float32Array(9)] - If provided the array will be assigned to out
     * @return {number[]} the newly created array which contains the matrix
     */
    toArray(transpose, out = null) {
        if (!this.array) {
            this.array = new Float32Array(9);
        }
        var array = out || this.array;
        if (transpose) {
            array[0] = this.a;
            array[1] = this.b;
            array[2] = 0;
            array[3] = this.c;
            array[4] = this.d;
            array[5] = 0;
            array[6] = this.tx;
            array[7] = this.ty;
            array[8] = 1;
        }
        else {
            array[0] = this.a;
            array[1] = this.c;
            array[2] = this.tx;
            array[3] = this.b;
            array[4] = this.d;
            array[5] = this.ty;
            array[6] = 0;
            array[7] = 0;
            array[8] = 1;
        }
        return array;
    }
    ;
    /**
     * Get a new position with the current transformation applied.
     * Can be used to go from a child's coordinate space to the world coordinate space. (e.g. rendering)
     *
     * @param {PIXI.Point} pos - The origin
     * @param {PIXI.Point} [newPos] - The point that the new position is assigned to (allowed to be same as input)
     * @return {PIXI.Point} The new point, transformed through this matrix
     */
    apply(pos, newPos) {
        newPos = newPos || new Point_1.Point();
        var x = pos.x;
        var y = pos.y;
        newPos.x = (this.a * x) + (this.c * y) + this.tx;
        newPos.y = (this.b * x) + (this.d * y) + this.ty;
        return newPos;
    }
    ;
    /**
     * Get a new position with the inverse of the current transformation applied.
     * Can be used to go from the world coordinate space to a child's coordinate space. (e.g. input)
     *
     * @param {PIXI.Point} pos - The origin
     * @param {PIXI.Point} [newPos] - The point that the new position is assigned to (allowed to be same as input)
     * @return {PIXI.Point} The new point, inverse-transformed through this matrix
     */
    applyInverse(pos, newPos) {
        newPos = newPos || new Point_1.Point();
        var id = 1 / ((this.a * this.d) + (this.c * -this.b));
        var x = pos.x;
        var y = pos.y;
        newPos.x = (this.d * id * x) + (-this.c * id * y) + (((this.ty * this.c) - (this.tx * this.d)) * id);
        newPos.y = (this.a * id * y) + (-this.b * id * x) + (((-this.ty * this.a) + (this.tx * this.b)) * id);
        return newPos;
    }
    ;
    /**
     * Translates the matrix on the x and y.
     *
     * @param {number} x How much to translate x by
     * @param {number} y How much to translate y by
     * @return {PIXI.Matrix} This matrix. Good for chaining method calls.
     */
    translate(x, y) {
        this.tx += x;
        this.ty += y;
        return this;
    }
    ;
    /**
     * Applies a scale transformation to the matrix.
     *
     * @param {number} x The amount to scale horizontally
     * @param {number} y The amount to scale vertically
     * @return {PIXI.Matrix} This matrix. Good for chaining method calls.
     */
    scale(x, y) {
        this.a *= x;
        this.d *= y;
        this.c *= x;
        this.b *= y;
        this.tx *= x;
        this.ty *= y;
        return this;
    }
    ;
    /**
     * Applies a rotation transformation to the matrix.
     *
     * @param {number} angle - The angle in radians.
     * @return {PIXI.Matrix} This matrix. Good for chaining method calls.
     */
    rotate(angle) {
        var cos = Math.cos(angle);
        var sin = Math.sin(angle);
        var a1 = this.a;
        var c1 = this.c;
        var tx1 = this.tx;
        this.a = (a1 * cos) - (this.b * sin);
        this.b = (a1 * sin) + (this.b * cos);
        this.c = (c1 * cos) - (this.d * sin);
        this.d = (c1 * sin) + (this.d * cos);
        this.tx = (tx1 * cos) - (this.ty * sin);
        this.ty = (tx1 * sin) + (this.ty * cos);
        return this;
    }
    ;
    /**
     * Appends the given Matrix to this Matrix.
     *
     * @param {PIXI.Matrix} matrix - The matrix to append.
     * @return {PIXI.Matrix} This matrix. Good for chaining method calls.
     */
    append(matrix) {
        var a1 = this.a;
        var b1 = this.b;
        var c1 = this.c;
        var d1 = this.d;
        this.a = (matrix.a * a1) + (matrix.b * c1);
        this.b = (matrix.a * b1) + (matrix.b * d1);
        this.c = (matrix.c * a1) + (matrix.d * c1);
        this.d = (matrix.c * b1) + (matrix.d * d1);
        this.tx = (matrix.tx * a1) + (matrix.ty * c1) + this.tx;
        this.ty = (matrix.tx * b1) + (matrix.ty * d1) + this.ty;
        return this;
    }
    ;
    /**
     * Sets the matrix based on all the available properties
     *
     * @param {number} x - Position on the x axis
     * @param {number} y - Position on the y axis
     * @param {number} pivotX - Pivot on the x axis
     * @param {number} pivotY - Pivot on the y axis
     * @param {number} scaleX - Scale on the x axis
     * @param {number} scaleY - Scale on the y axis
     * @param {number} rotation - Rotation in radians
     * @param {number} skewX - Skew on the x axis
     * @param {number} skewY - Skew on the y axis
     * @return {PIXI.Matrix} This matrix. Good for chaining method calls.
     */
    setTransform(x, y, pivotX, pivotY, scaleX, scaleY, rotation, skewX, skewY) {
        this.a = Math.cos(rotation + skewY) * scaleX;
        this.b = Math.sin(rotation + skewY) * scaleX;
        this.c = -Math.sin(rotation - skewX) * scaleY;
        this.d = Math.cos(rotation - skewX) * scaleY;
        this.tx = x - ((pivotX * this.a) + (pivotY * this.c));
        this.ty = y - ((pivotX * this.b) + (pivotY * this.d));
        return this;
    }
    ;
    /**
     * Prepends the given Matrix to this Matrix.
     *
     * @param {PIXI.Matrix} matrix - The matrix to prepend
     * @return {PIXI.Matrix} This matrix. Good for chaining method calls.
     */
    prepend(matrix) {
        var tx1 = this.tx;
        if (matrix.a !== 1 || matrix.b !== 0 || matrix.c !== 0 || matrix.d !== 1) {
            var a1 = this.a;
            var c1 = this.c;
            this.a = (a1 * matrix.a) + (this.b * matrix.c);
            this.b = (a1 * matrix.b) + (this.b * matrix.d);
            this.c = (c1 * matrix.a) + (this.d * matrix.c);
            this.d = (c1 * matrix.b) + (this.d * matrix.d);
        }
        this.tx = (tx1 * matrix.a) + (this.ty * matrix.c) + matrix.tx;
        this.ty = (tx1 * matrix.b) + (this.ty * matrix.d) + matrix.ty;
        return this;
    }
    ;
    /**
     * Decomposes the matrix (x, y, scaleX, scaleY, and rotation) and sets the properties on to a transform.
     *
     * @param {PIXI.Transform} transform - The transform to apply the properties to.
     * @return {PIXI.Transform} The transform with the newly applied properties
     */
    decompose(transform) {
        // sort out rotation / skew..
        var a = this.a;
        var b = this.b;
        var c = this.c;
        var d = this.d;
        var skewX = -Math.atan2(-c, d);
        var skewY = Math.atan2(b, a);
        var delta = Math.abs(skewX + skewY);
        if (delta < 0.00001 || Math.abs(MathSettings_1.MathSettings.PI_2 - delta) < 0.00001) {
            transform.rotation = skewY;
            transform.skew.x = transform.skew.y = 0;
        }
        else {
            transform.rotation = 0;
            transform.skew.x = skewX;
            transform.skew.y = skewY;
        }
        // next set scale
        transform.scale.x = Math.sqrt((a * a) + (b * b));
        transform.scale.y = Math.sqrt((c * c) + (d * d));
        // next set position
        transform.position.x = this.tx;
        transform.position.y = this.ty;
        return transform;
    }
    ;
    /**
     * Inverts this matrix
     *
     * @return {PIXI.Matrix} This matrix. Good for chaining method calls.
     */
    invert() {
        var a1 = this.a;
        var b1 = this.b;
        var c1 = this.c;
        var d1 = this.d;
        var tx1 = this.tx;
        var n = (a1 * d1) - (b1 * c1);
        this.a = d1 / n;
        this.b = -b1 / n;
        this.c = -c1 / n;
        this.d = a1 / n;
        this.tx = ((c1 * this.ty) - (d1 * tx1)) / n;
        this.ty = -((a1 * this.ty) - (b1 * tx1)) / n;
        return this;
    }
    ;
    /**
     * Resets this Matrix to an identity (default) matrix.
     *
     * @return {PIXI.Matrix} This matrix. Good for chaining method calls.
     */
    identity() {
        this.a = 1;
        this.b = 0;
        this.c = 0;
        this.d = 1;
        this.tx = 0;
        this.ty = 0;
        return this;
    }
    ;
    /**
     * Creates a new Matrix object with the same values as this one.
     *
     * @return {PIXI.Matrix} A copy of this matrix. Good for chaining method calls.
     */
    clone() {
        var matrix = new Matrix();
        matrix.a = this.a;
        matrix.b = this.b;
        matrix.c = this.c;
        matrix.d = this.d;
        matrix.tx = this.tx;
        matrix.ty = this.ty;
        return matrix;
    }
    ;
    /**
     * Changes the values of the given matrix to be the same as the ones in this matrix
     *
     * @param {PIXI.Matrix} matrix - The matrix to copy to.
     * @return {PIXI.Matrix} The matrix given in parameter with its values updated.
     */
    copyTo(matrix) {
        matrix.a = this.a;
        matrix.b = this.b;
        matrix.c = this.c;
        matrix.d = this.d;
        matrix.tx = this.tx;
        matrix.ty = this.ty;
        return matrix;
    }
    ;
    /**
     * Changes the values of the matrix to be the same as the ones in given matrix
     *
     * @param {PIXI.Matrix} matrix - The matrix to copy from.
     * @return {PIXI.Matrix} this
     */
    copyFrom(matrix) {
        this.a = matrix.a;
        this.b = matrix.b;
        this.c = matrix.c;
        this.d = matrix.d;
        this.tx = matrix.tx;
        this.ty = matrix.ty;
        return this;
    }
    ;
    /**
     * A default (identity) matrix
     *
     * @static
     * @const
     * @member {PIXI.Matrix}
     */
    static get IDENTITY() {
        return new Matrix();
    }
    ;
    /**
     * A temp matrix
     *
     * @static
     * @const
     * @member {PIXI.Matrix}
     */
    static get TEMP_MATRIX() {
        return new Matrix();
    }
    ;
}
exports.Matrix = Matrix;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/Mesh.js":
/*!****************************************!*\
  !*** ./js-compile/raw-pixi-ts/Mesh.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Container_1 = __webpack_require__(/*! ./Container */ "./js-compile/raw-pixi-ts/Container.js");
const State_1 = __webpack_require__(/*! ./State */ "./js-compile/raw-pixi-ts/State.js");
const Polygon_1 = __webpack_require__(/*! ./Polygon */ "./js-compile/raw-pixi-ts/Polygon.js");
const MeshBatchUvs_1 = __webpack_require__(/*! ./MeshBatchUvs */ "./js-compile/raw-pixi-ts/MeshBatchUvs.js");
const Point_1 = __webpack_require__(/*! ./Point */ "./js-compile/raw-pixi-ts/Point.js");
const DrawModeSettings_1 = __webpack_require__(/*! ./DrawModeSettings */ "./js-compile/raw-pixi-ts/DrawModeSettings.js");
const BlendModesSettings_1 = __webpack_require__(/*! ./BlendModesSettings */ "./js-compile/raw-pixi-ts/BlendModesSettings.js");
const DisplaySettings_1 = __webpack_require__(/*! ./DisplaySettings */ "./js-compile/raw-pixi-ts/DisplaySettings.js");
class Mesh extends Container_1.Container {
    constructor(geometry, shader, state = null, drawMode = DrawModeSettings_1.DrawModeSettings.DRAW_MODES.TRIANGLES) {
        super();
        this.interactive = false;
        /**
         * Includes vertex positions, face indices, normals, colors, UVs, and
         * custom attributes within buffers, reducing the cost of passing all
         * this data to the GPU. Can be shared between multiple Mesh objects.
         * @member {PIXI.Geometry}
         * @readonly
         */
        this.geometry = geometry;
        geometry.refCount++;
        /**
         * Represents the vertex and fragment shaders that processes the geometry and runs on the GPU.
         * Can be shared between multiple Mesh objects.
         * @member {PIXI.Shader|PIXI.MeshMaterial}
         */
        this.shader = shader;
        /**
         * Represents the WebGL state the Mesh required to render, excludes shader and geometry. E.g.,
         * blend mode, culling, depth testing, direction of rendering triangles, backface, etc.
         * @member {PIXI.State}
         */
        this.state = state || State_1.State.for2d();
        /**
         * The way the Mesh should be drawn, can be any of the {@link PIXI.DRAW_MODES} constants.
         *
         * @member {number}
         * @see PIXI.DRAW_MODES
         */
        this.drawMode = drawMode;
        /**
         * Typically the index of the IndexBuffer where to start drawing.
         * @member {number}
         * @default 0
         */
        this.start = 0;
        /**
         * How much of the geometry to draw, by default `0` renders everything.
         * @member {number}
         * @default 0
         */
        this.size = 0;
        /**
         * thease are used as easy access for batching
         * @member {Float32Array}
         * @private
         */
        this.uvs = null;
        /**
         * thease are used as easy access for batching
         * @member {Uint16Array}
         * @private
         */
        this.indices = null;
        /**
         * this is the caching layer used by the batcher
         * @member {Float32Array}
         * @private
         */
        this.vertexData = new Float32Array(1);
        /**
         * If geometry is changed used to decide to re-transform
         * the vertexData.
         * @member {number}
         * @private
         */
        this.vertexDirty = 0;
        this._transformID = -1;
        // Inherited from DisplayMode, set defaults
        this.tint = 0xFFFFFF;
        this.blendMode = BlendModesSettings_1.BlendModesSettings.BLEND_MODES.NORMAL;
        /**
         * Internal roundPixels field
         *
         * @member {boolean}
         * @private
         */
        this._roundPixels = DisplaySettings_1.DisplaySettings.ROUND_PIXELS;
        /**
         * Batched UV's are cached for atlas textures
         * @member {PIXI.MeshBatchUvs}
         * @private
         */
        this.batchUvs = null;
    }
    /**
     * To change mesh uv's, change its uvBuffer data and increment its _updateID.
     * @member {PIXI.Buffer}
     * @readonly
     */
    get uvBuffer() {
        return this.geometry.buffers[1].data;
    }
    ;
    /**
     * To change mesh vertices, change its uvBuffer data and increment its _updateID.
     * Incrementing _updateID is optional because most of Mesh objects do it anyway.
     * @member {PIXI.Buffer}
     * @readonly
     */
    get verticesBuffer() {
        return this.geometry.buffers[0].data;
    }
    ;
    /**
     * Alias for {@link PIXI.Mesh#shader}.
     * @member {PIXI.Shader|PIXI.MeshMaterial}
     */
    set material(value) {
        this.shader = value;
    }
    ;
    get material() {
        return this.shader;
    }
    ;
    /**
     * The blend mode to be applied to the Mesh. Apply a value of
     * `PIXI.BLEND_MODES.NORMAL` to reset the blend mode.
     *
     * @member {number}
     * @default PIXI.BLEND_MODES.NORMAL;
     * @see PIXI.BLEND_MODES
     */
    set blendMode(value) {
        this.state.blendMode = value;
    }
    ;
    get blendMode() {
        return this.state.blendMode;
    }
    ;
    /**
     * If true PixiJS will Math.floor() x/y values when rendering, stopping pixel interpolation.
     * Advantages can include sharper image quality (like text) and faster rendering on canvas.
     * The main disadvantage is movement of objects may appear less smooth.
     * To set the global default, change {@link PIXI.settings.ROUND_PIXELS}
     *
     * @member {boolean}
     * @default false
     */
    set roundPixels(value) {
        if (this._roundPixels !== value) {
            this._transformID = -1;
        }
        this._roundPixels = value;
    }
    ;
    get roundPixels() {
        return this._roundPixels;
    }
    ;
    /**
     * The multiply tint applied to the Mesh. This is a hex value. A value of
     * `0xFFFFFF` will remove any tint effect.
     *
     * @member {number}
     * @default 0xFFFFFF
     */
    get tint() {
        return this.shader.tint;
    }
    ;
    set tint(value) {
        this.shader.tint = value;
    }
    ;
    /**
     * The texture that the Mesh uses.
     *
     * @member {PIXI.Texture}
     */
    get texture() {
        return this.shader.texture;
    }
    ;
    set texture(value) {
        this.shader.texture = value;
    }
    ;
    /**
     * Standard renderer draw.
     * @protected
     */
    _render(renderer) {
        // set properties for batching..
        // TODO could use a different way to grab verts?
        var vertices = this.geometry.buffers[0].data;
        // TODO benchmark check for attribute size..
        if (this.shader.batchable && this.drawMode === DrawModeSettings_1.DrawModeSettings.DRAW_MODES.TRIANGLES && vertices.length < Mesh.BATCHABLE_SIZE * 2) {
            this._renderToBatch(renderer);
        }
        else {
            this._renderDefault(renderer);
        }
    }
    ;
    /**
     * Standard non-batching way of rendering.
     * @protected
     * @param {PIXI.Renderer} renderer - Instance to renderer.
     */
    _renderDefault(renderer) {
        var shader = this.shader;
        shader.alpha = this.worldAlpha;
        if (shader.update) {
            shader.update();
        }
        renderer.batch.flush();
        if (shader.program.uniformData.translationMatrix) {
            shader.uniforms.translationMatrix = this.transform.worldTransform.toArray(true);
        }
        // bind and sync uniforms..
        renderer.shader.bind(shader);
        // set state..
        renderer.state.setState(this.state);
        // bind the geometry...
        renderer.geometry.bind(this.geometry, shader);
        // then render it
        renderer.geometry.draw(this.drawMode, this.size, this.start, this.geometry.instanceCount);
    }
    ;
    /**
     * Rendering by using the Batch system.
     * @protected
     * @param {PIXI.Renderer} renderer - Instance to renderer.
     */
    _renderToBatch(renderer) {
        var geometry = this.geometry;
        if (this.shader.uvMatrix) {
            this.shader.uvMatrix.update();
            this.calculateUvs();
        }
        // set properties for batching..
        this.calculateVertices();
        this.indices = geometry.indexBuffer.data;
        this._tintRGB = this.shader._tintRGB;
        this._texture = this.shader.texture;
        var pluginName = this.material.pluginName;
        renderer.batch.setObjectRenderer(renderer.plugins[pluginName]);
        renderer.plugins[pluginName].render(this);
    }
    ;
    /**
     * Updates vertexData field based on transform and vertices
     */
    calculateVertices() {
        var geometry = this.geometry;
        var vertices = geometry.buffers[0].data;
        if (geometry.vertexDirtyId === this.vertexDirty && this._transformID === this.transform._worldID) {
            return;
        }
        this._transformID = this.transform._worldID;
        if (this.vertexData.length !== vertices.length) {
            this.vertexData = new Float32Array(vertices.length);
        }
        var wt = this.transform.worldTransform;
        var a = wt.a;
        var b = wt.b;
        var c = wt.c;
        var d = wt.d;
        var tx = wt.tx;
        var ty = wt.ty;
        var vertexData = this.vertexData;
        for (var i = 0; i < vertexData.length / 2; i++) {
            var x = vertices[(i * 2)];
            var y = vertices[(i * 2) + 1];
            vertexData[(i * 2)] = (a * x) + (c * y) + tx;
            vertexData[(i * 2) + 1] = (b * x) + (d * y) + ty;
        }
        if (this._roundPixels) {
            for (var i$1 = 0; i$1 < vertexData.length; i$1++) {
                vertexData[i$1] = Math.round(vertexData[i$1]);
            }
        }
        this.vertexDirty = geometry.vertexDirtyId;
    }
    ;
    /**
     * Updates uv field based on from geometry uv's or batchUvs
     */
    calculateUvs() {
        var geomUvs = this.geometry.buffers[1];
        if (!this.shader.uvMatrix.isSimple) {
            if (!this.batchUvs) {
                this.batchUvs = new MeshBatchUvs_1.MeshBatchUvs(geomUvs, this.shader.uvMatrix);
            }
            this.batchUvs.update();
            this.uvs = this.batchUvs.data;
        }
        else {
            this.uvs = geomUvs.data;
        }
    }
    ;
    /**
     * Updates the bounds of the mesh as a rectangle. The bounds calculation takes the worldTransform into account.
     * there must be a aVertexPosition attribute present in the geometry for bounds to be calculated correctly.
     *
     * @protected
     */
    _calculateBounds() {
        this.calculateVertices();
        this._bounds.addVertexData(this.vertexData, 0, this.vertexData.length);
    }
    ;
    /**
     * Tests if a point is inside this mesh. Works only for PIXI.DRAW_MODES.TRIANGLES.
     *
     * @param {PIXI.Point} point the point to test
     * @return {boolean} the result of the test
     */
    containsPoint(point) {
        if (!this.interactive) {
            return false;
        }
        if (!this.getBounds().contains(point.x, point.y)) {
            return false;
        }
        this.worldTransform.applyInverse(point, Mesh.tempPoint$2);
        var vertices = this.geometry.getAttribute('aVertexPosition').data;
        var points = Mesh.tempPolygon.points;
        var indices = this.geometry.getIndex().data;
        var len = indices.length;
        var step = this.drawMode === 4 ? 3 : 1;
        for (var i = 0; i + 2 < len; i += step) {
            var ind0 = indices[i] * 2;
            var ind1 = indices[i + 1] * 2;
            var ind2 = indices[i + 2] * 2;
            points[0] = vertices[ind0];
            points[1] = vertices[ind0 + 1];
            points[2] = vertices[ind1];
            points[3] = vertices[ind1 + 1];
            points[4] = vertices[ind2];
            points[5] = vertices[ind2 + 1];
            if (Mesh.tempPolygon.contains(Mesh.tempPoint$2.x, Mesh.tempPoint$2.y)) {
                return true;
            }
        }
        return false;
    }
    ;
    /**
     * Destroys the Mesh object.
     *
     * @param {object|boolean} [options] - Options parameter. A boolean will act as if all
     *  options have been set to that value
     * @param {boolean} [options.children=false] - if set to true, all the children will have
     *  their destroy method called as well. 'options' will be passed on to those calls.
     */
    destroy(options) {
        super.destroy(options);
        this.geometry.refCount--;
        if (this.geometry.refCount === 0) {
            this.geometry.dispose();
        }
        this.geometry = null;
        this.shader = null;
        this.state = null;
        this.uvs = null;
        this.indices = null;
        this.vertexData = null;
    }
    ;
}
Mesh.tempPolygon = new Polygon_1.Polygon();
Mesh.tempPoint$2 = new Point_1.Point();
/**
 * The maximum number of vertices to consider batchable. Generally, the complexity
 * of the geometry.
 * @memberof PIXI.Mesh
 * @static
 * @member {number} BATCHABLE_SIZE
 */
Mesh.BATCHABLE_SIZE = 100;
exports.Mesh = Mesh;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/MeshBatchUvs.js":
/*!************************************************!*\
  !*** ./js-compile/raw-pixi-ts/MeshBatchUvs.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class MeshBatchUvs {
    constructor(uvBuffer, uvMatrix) {
        /**
                 * Buffer with normalized UV's
                 * @member {PIXI.Buffer}
                 */
        this.uvBuffer = uvBuffer;
        /**
         * Material UV matrix
         * @member {PIXI.TextureMatrix}
         */
        this.uvMatrix = uvMatrix;
        /**
         * UV Buffer data
         * @member {Float32Array}
         * @readonly
         */
        this.data = null;
        this._bufferUpdateId = -1;
        this._textureUpdateId = -1;
        this._updateID = 0;
    }
    /**
     * updates
     *
     * @param {boolean} forceUpdate - force the update
     */
    update(forceUpdate) {
        if (!forceUpdate
            && this._bufferUpdateId === this.uvBuffer._updateID
            && this._textureUpdateId === this.uvMatrix._updateID) {
            return;
        }
        this._bufferUpdateId = this.uvBuffer._updateID;
        this._textureUpdateId = this.uvMatrix._updateID;
        var data = this.uvBuffer.data;
        if (!this.data || this.data.length !== data.length) {
            this.data = new Float32Array(data.length);
        }
        this.uvMatrix.multiplyUvs(data, this.data);
        this._updateID++;
    }
    ;
}
exports.MeshBatchUvs = MeshBatchUvs;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/MeshGeometry.js":
/*!************************************************!*\
  !*** ./js-compile/raw-pixi-ts/MeshGeometry.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Geometry_1 = __webpack_require__(/*! ./Geometry */ "./js-compile/raw-pixi-ts/Geometry.js");
const Buffer_1 = __webpack_require__(/*! ./Buffer */ "./js-compile/raw-pixi-ts/Buffer.js");
const WebGLSettings_1 = __webpack_require__(/*! ./WebGLSettings */ "./js-compile/raw-pixi-ts/WebGLSettings.js");
class MeshGeometry extends Geometry_1.Geometry {
    constructor(vertices = null, uvs = null, index = null) {
        super();
        var verticesBuffer = new Buffer_1.Buffer(vertices);
        var uvsBuffer = new Buffer_1.Buffer(uvs, true);
        var indexBuffer = new Buffer_1.Buffer(index, true, true);
        this.addAttribute('aVertexPosition', verticesBuffer, 2, false, WebGLSettings_1.WebGLSettings.TYPES.FLOAT)
            .addAttribute('aTextureCoord', uvsBuffer, 2, false, WebGLSettings_1.WebGLSettings.TYPES.FLOAT)
            .addIndex(indexBuffer);
        /**
         * Dirty flag to limit update calls on Mesh. For example,
         * limiting updates on a single Mesh instance with a shared Geometry
         * within the render loop.
         * @private
         * @member {number}
         * @default -1
         */
        this._updateId = -1;
    }
    /**
     * If the vertex position is updated.
     * @member {number}
     * @readonly
     * @private
     */
    get vertexDirtyId() {
        return this.buffers[0]._updateID;
    }
    ;
}
exports.MeshGeometry = MeshGeometry;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/MeshMaterial.js":
/*!************************************************!*\
  !*** ./js-compile/raw-pixi-ts/MeshMaterial.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Shader_1 = __webpack_require__(/*! ./Shader */ "./js-compile/raw-pixi-ts/Shader.js");
const Matrix_1 = __webpack_require__(/*! ./Matrix */ "./js-compile/raw-pixi-ts/Matrix.js");
const Program_1 = __webpack_require__(/*! ./Program */ "./js-compile/raw-pixi-ts/Program.js");
const TextureMatrix_1 = __webpack_require__(/*! ./TextureMatrix */ "./js-compile/raw-pixi-ts/TextureMatrix.js");
const ColorSettings_1 = __webpack_require__(/*! ./ColorSettings */ "./js-compile/raw-pixi-ts/ColorSettings.js");
class MeshMaterial extends Shader_1.Shader {
    constructor(uSampler, options = null) {
        var uniforms = {
            uSampler: uSampler,
            alpha: 1,
            uTextureMatrix: Matrix_1.Matrix.IDENTITY,
            uColor: new Float32Array([1, 1, 1, 1]),
        };
        // Set defaults
        options = Object.assign({
            tint: 0xFFFFFF,
            alpha: 1,
            pluginName: 'batch',
        }, options);
        if (options.uniforms) {
            Object.assign(uniforms, options.uniforms);
        }
        super(options.program || Program_1.Program.from(MeshMaterial.vertex$6, MeshMaterial.fragment$8), uniforms);
        /**
         * Only do update if tint or alpha changes.
         * @member {boolean}
         * @private
         * @default false
         */
        this._colorDirty = false;
        /**
         * TextureMatrix instance for this Mesh, used to track Texture changes
         *
         * @member {PIXI.TextureMatrix}
         * @readonly
         */
        this.uvMatrix = new TextureMatrix_1.TextureMatrix(uSampler);
        /**
         * `true` if shader can be batch with the renderer's batch system.
         * @member {boolean}
         * @default true
         */
        this.batchable = options.program === undefined;
        /**
         * Renderer plugin for batching
         *
         * @member {string}
         * @default 'batch'
         */
        this.pluginName = options.pluginName;
        this.tint = options.tint;
        this.alpha = options.alpha;
    }
    /**
     * Reference to the texture being rendered.
     * @member {PIXI.Texture}
     */
    get texture() {
        return this.uniforms.uSampler;
    }
    ;
    set texture(value) {
        if (this.uniforms.uSampler !== value) {
            this.uniforms.uSampler = value;
            this.uvMatrix.texture = value;
        }
    }
    ;
    /**
     * This gets automatically set by the object using this.
     *
     * @default 1
     * @member {number}
     */
    set alpha(value) {
        if (value === this._alpha) {
            return;
        }
        this._alpha = value;
        this._colorDirty = true;
    }
    ;
    get alpha() {
        return this._alpha;
    }
    ;
    /**
     * Multiply tint for the material.
     * @member {number}
     * @default 0xFFFFFF
     */
    set tint(value) {
        if (value === this._tint) {
            return;
        }
        this._tint = value;
        this._tintRGB = (value >> 16) + (value & 0xff00) + ((value & 0xff) << 16);
        this._colorDirty = true;
    }
    ;
    get tint() {
        return this._tint;
    }
    ;
    /**
     * Gets called automatically by the Mesh. Intended to be overridden for custom
     * MeshMaterial objects.
     */
    update() {
        if (this._colorDirty) {
            this._colorDirty = false;
            var baseTexture = this.texture.baseTexture;
            ColorSettings_1.ColorSettings.premultiplyTintToRgba(this._tint, this._alpha, this.uniforms.uColor, baseTexture.premultiplyAlpha);
        }
        if (this.uvMatrix.update()) {
            this.uniforms.uTextureMatrix = this.uvMatrix.mapCoord;
        }
    }
    ;
}
MeshMaterial.vertex$6 = "attribute vec2 aVertexPosition;\r\nattribute vec2 aTextureCoord;\r\n\r\nuniform mat3 projectionMatrix;\r\nuniform mat3 translationMatrix;\r\nuniform mat3 uTextureMatrix;\r\n\r\nvarying vec2 vTextureCoord;\r\n\r\nvoid main(void)\r\n{\r\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\r\n\r\n    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;\r\n}\r\n";
MeshMaterial.fragment$8 = "varying vec2 vTextureCoord;\r\nuniform vec4 uColor;\r\n\r\nuniform sampler2D uSampler;\r\n\r\nvoid main(void)\r\n{\r\n    gl_FragColor = texture2D(uSampler, vTextureCoord) * uColor;\r\n}\r\n";
exports.MeshMaterial = MeshMaterial;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/MouseEvent.js":
/*!**********************************************!*\
  !*** ./js-compile/raw-pixi-ts/MouseEvent.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Event_1 = __webpack_require__(/*! ./Event */ "./js-compile/raw-pixi-ts/Event.js");
class MouseEvent extends Event_1.Event {
    constructor(type, bubbles = false) {
        super(type, bubbles);
        this.movementX = 0;
        this.movementY = 0;
    }
}
MouseEvent.CLICK = "click";
MouseEvent.MOUSE_DOWN = "mouseDown";
MouseEvent.MOUSE_UP = "mouseUp";
MouseEvent.MIDDLE_CLICK = "middleClick";
MouseEvent.MIDDLE_MOUSE_DOWN = "middleMouseDown";
MouseEvent.MIDDLE_MOUSE_UP = "middleMouseUp";
MouseEvent.RIGHT_CLICK = "rightClick";
MouseEvent.RIGHT_MOUSE_DOWN = "rightMouseDown";
MouseEvent.RIGHT_MOUSE_UP = "rightMouseUp";
MouseEvent.MOUSE_MOVE = "mouseMove";
MouseEvent.MOUSE_OVER = "mouseOver";
MouseEvent.MOUSE_OUT = "mouseOut";
MouseEvent.RIGHT_MOUSE_UP_OUTSIDE = "rightupoutside";
MouseEvent.MOUSE_UP_OUTSIDE = "mouseupoutside";
MouseEvent.POINTER_OVER = "pointerover";
MouseEvent.POINTER_ENTER = "pointerenter";
MouseEvent.POINTER_DOWN = "pointerdown";
MouseEvent.POINTER_MOVE = "pointermove";
MouseEvent.POINTER_UP = "pointerup";
MouseEvent.POINTER_CANCEL = "pointercancel";
MouseEvent.POINTER_OUT = "pointerout";
MouseEvent.POINTER_LEAVE = "pointerleave";
MouseEvent.POINTER_CAPTURE = "gotpointercapture";
MouseEvent.POINTER_LOST = "lostpointercapture";
MouseEvent.POINTER_UP_OUTSIDE = "pointerupoutside";
MouseEvent.POINTER_TAP = "pointertap";
MouseEvent.TOUCH_START = "touchstart";
MouseEvent.TOUCH_END = "touchend";
MouseEvent.TOUCH_END_OUTSIDE = "touchendoutside";
MouseEvent.TOUCH_MOVE = "touchmove";
MouseEvent.TOUCH_CANCEL = "touchcancel";
MouseEvent.TOUCH_TAP = "tap";
exports.MouseEvent = MouseEvent;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/NetworkSettings.js":
/*!***************************************************!*\
  !*** ./js-compile/raw-pixi-ts/NetworkSettings.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Url_1 = __webpack_require__(/*! ./Url */ "./js-compile/raw-pixi-ts/Url.js");
class NetworkSettings {
    static getResolutionOfUrl(url, defaultValue = null) {
        var resolution = NetworkSettings.RETINA_PREFIX.exec(url);
        if (resolution) {
            return parseFloat(resolution[1]);
        }
        return defaultValue !== undefined ? defaultValue : 1;
    }
    static determineCrossOrigin(url$1, loc = null) {
        if (loc === void 0) {
            loc = window.location;
        }
        if (url$1.indexOf('data:') === 0) {
            return '';
        }
        loc = loc || window.location;
        if (!NetworkSettings.tempAnchor) {
            NetworkSettings.tempAnchor = document.createElement('a');
        }
        NetworkSettings.tempAnchor.href = url$1;
        url$1 = NetworkSettings.url.parse(NetworkSettings.tempAnchor.href);
        var samePort = (!url$1.port && loc.port === '') || (url$1.port === loc.port);
        if (url$1.hostname !== loc.hostname || !samePort || url$1.protocol !== loc.protocol) {
            return 'anonymous';
        }
        return '';
    }
}
NetworkSettings.RETINA_PREFIX = /@([0-9\.]+)x/;
NetworkSettings.url = {
    parse: Url_1.Url.urlParse,
    resolve: Url_1.Url.urlResolve,
    resolveObject: Url_1.Url.urlResolveObject,
    format: Url_1.Url.urlFormat,
    Url: Url_1.Url
};
exports.NetworkSettings = NetworkSettings;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/ObjectRenderer.js":
/*!**************************************************!*\
  !*** ./js-compile/raw-pixi-ts/ObjectRenderer.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const System_1 = __webpack_require__(/*! ./System */ "./js-compile/raw-pixi-ts/System.js");
class ObjectRenderer extends System_1.System {
    constructor(renderer) {
        super(renderer);
    }
    start() {
        // set the shader..
    }
    ;
    /**
     * Stops the renderer
     *
     */
    stop() {
        this.flush();
    }
    ;
    /**
     * Stub method for rendering content and emptying the current batch.
     *
     */
    flush() {
        // flush!
    }
    ;
    /**
     * Renders an object
     *
     * @param {PIXI.DisplayObject} object - The object to render.
     */
    render(object) {
        // render the object
    }
    ;
}
exports.ObjectRenderer = ObjectRenderer;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/ObservablePoint.js":
/*!***************************************************!*\
  !*** ./js-compile/raw-pixi-ts/ObservablePoint.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class ObservablePoint {
    constructor(cb, scope, x = 0, y = 0) {
        if (x === void 0) {
            x = 0;
        }
        if (y === void 0) {
            y = 0;
        }
        this._x = x;
        this._y = y;
        this.cb = cb;
        this.scope = scope;
    }
    /**
     * Creates a clone of this point.
     * The callback and scope params can be overidden otherwise they will default
     * to the clone object's values.
     *
     * @override
     * @param {Function} [cb=null] - callback when changed
     * @param {object} [scope=null] - owner of callback
     * @return {PIXI.ObservablePoint} a copy of the point
     */
    clone(cb, scope) {
        if (cb === void 0) {
            cb = null;
        }
        if (scope === void 0) {
            scope = null;
        }
        var _cb = cb || this.cb;
        var _scope = scope || this.scope;
        return new ObservablePoint(_cb, _scope, this._x, this._y);
    }
    ;
    /**
     * Sets the point to a new x and y position.
     * If y is omitted, both x and y will be set to x.
     *
     * @param {number} [x=0] - position of the point on the x axis
     * @param {number} [y=0] - position of the point on the y axis
     */
    set(x, y) {
        var _x = x || 0;
        var _y = y || ((y !== 0) ? _x : 0);
        if (this._x !== _x || this._y !== _y) {
            this._x = _x;
            this._y = _y;
            this.cb.call(this.scope);
        }
    }
    ;
    /**
     * Copies x and y from the given point
     *
     * @param {PIXI.IPoint} p - The point to copy from.
     * @returns {PIXI.IPoint} Returns itself.
     */
    copyFrom(p) {
        if (this._x !== p.x || this._y !== p.y) {
            this._x = p.x;
            this._y = p.y;
            this.cb.call(this.scope);
        }
        return this;
    }
    ;
    /**
     * Copies x and y into the given point
     *
     * @param {PIXI.IPoint} p - The point to copy.
     * @returns {PIXI.IPoint} Given point with values updated
     */
    copyTo(p) {
        p.set(this._x, this._y);
        return p;
    }
    ;
    /**
     * Returns true if the given point is equal to this point
     *
     * @param {PIXI.IPoint} p - The point to check
     * @returns {boolean} Whether the given point equal to this point
     */
    equals(p) {
        return (p.x === this._x) && (p.y === this._y);
    }
    ;
    /**
     * The position of the displayObject on the x axis relative to the local coordinates of the parent.
     *
     * @member {number}
     */
    get x() {
        return this._x;
    }
    ;
    set x(value) {
        if (this._x !== value) {
            this._x = value;
            this.cb.call(this.scope);
        }
    }
    ;
    /**
     * The position of the displayObject on the x axis relative to the local coordinates of the parent.
     *
     * @member {number}
     */
    get y() {
        return this._y;
    }
    ;
    set y(value) {
        if (this._y !== value) {
            this._y = value;
            this.cb.call(this.scope);
        }
    }
    ;
}
exports.ObservablePoint = ObservablePoint;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/ParticleBuffer.js":
/*!**************************************************!*\
  !*** ./js-compile/raw-pixi-ts/ParticleBuffer.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Geometry_1 = __webpack_require__(/*! ./Geometry */ "./js-compile/raw-pixi-ts/Geometry.js");
const Buffer_1 = __webpack_require__(/*! ./Buffer */ "./js-compile/raw-pixi-ts/Buffer.js");
const WebGLSettings_1 = __webpack_require__(/*! ./WebGLSettings */ "./js-compile/raw-pixi-ts/WebGLSettings.js");
class ParticleBuffer {
    constructor(properties, dynamicPropertyFlags, size) {
        this.geometry = new Geometry_1.Geometry();
        this.indexBuffer = null;
        /**
         * The number of particles the buffer can hold
         *
         * @private
         * @member {number}
         */
        this.size = size;
        /**
         * A list of the properties that are dynamic.
         *
         * @private
         * @member {object[]}
         */
        this.dynamicProperties = [];
        /**
         * A list of the properties that are static.
         *
         * @private
         * @member {object[]}
         */
        this.staticProperties = [];
        for (var i = 0; i < properties.length; ++i) {
            var property = properties[i];
            // Make copy of properties object so that when we edit the offset it doesn't
            // change all other instances of the object literal
            property = {
                attributeName: property.attributeName,
                size: property.size,
                uploadFunction: property.uploadFunction,
                type: property.type || WebGLSettings_1.WebGLSettings.TYPES.FLOAT,
                offset: property.offset,
            };
            if (dynamicPropertyFlags[i]) {
                this.dynamicProperties.push(property);
            }
            else {
                this.staticProperties.push(property);
            }
        }
        this.staticStride = 0;
        this.staticBuffer = null;
        this.staticData = null;
        this.staticDataUint32 = null;
        this.dynamicStride = 0;
        this.dynamicBuffer = null;
        this.dynamicData = null;
        this.dynamicDataUint32 = null;
        this._updateID = 0;
        this.initBuffers();
    }
    /**
     * Sets up the renderer context and necessary buffers.
     *
     * @private
     */
    initBuffers() {
        var geometry = this.geometry;
        var dynamicOffset = 0;
        /**
         * Holds the indices of the geometry (quads) to draw
         *
         * @member {Uint16Array}
         * @private
         */
        this.indexBuffer = new Buffer_1.Buffer(WebGLSettings_1.WebGLSettings.createIndicesForQuads(this.size), true, true);
        geometry.addIndex(this.indexBuffer);
        this.dynamicStride = 0;
        for (var i = 0; i < this.dynamicProperties.length; ++i) {
            var property = this.dynamicProperties[i];
            property.offset = dynamicOffset;
            dynamicOffset += property.size;
            this.dynamicStride += property.size;
        }
        var dynBuffer = new ArrayBuffer(this.size * this.dynamicStride * 4 * 4);
        this.dynamicData = new Float32Array(dynBuffer);
        this.dynamicDataUint32 = new Uint32Array(dynBuffer);
        this.dynamicBuffer = new Buffer_1.Buffer(this.dynamicData, false, false);
        // static //
        var staticOffset = 0;
        this.staticStride = 0;
        for (var i$1 = 0; i$1 < this.staticProperties.length; ++i$1) {
            var property$1 = this.staticProperties[i$1];
            property$1.offset = staticOffset;
            staticOffset += property$1.size;
            this.staticStride += property$1.size;
        }
        var statBuffer = new ArrayBuffer(this.size * this.staticStride * 4 * 4);
        this.staticData = new Float32Array(statBuffer);
        this.staticDataUint32 = new Uint32Array(statBuffer);
        this.staticBuffer = new Buffer_1.Buffer(this.staticData, true, false);
        for (var i$2 = 0; i$2 < this.dynamicProperties.length; ++i$2) {
            var property$2 = this.dynamicProperties[i$2];
            geometry.addAttribute(property$2.attributeName, this.dynamicBuffer, 0, property$2.type === WebGLSettings_1.WebGLSettings.TYPES.UNSIGNED_BYTE, property$2.type, this.dynamicStride * 4, property$2.offset * 4);
        }
        for (var i$3 = 0; i$3 < this.staticProperties.length; ++i$3) {
            var property$3 = this.staticProperties[i$3];
            geometry.addAttribute(property$3.attributeName, this.staticBuffer, 0, property$3.type === WebGLSettings_1.WebGLSettings.TYPES.UNSIGNED_BYTE, property$3.type, this.staticStride * 4, property$3.offset * 4);
        }
    }
    ;
    /**
     * Uploads the dynamic properties.
     *
     * @private
     * @param {PIXI.DisplayObject[]} children - The children to upload.
     * @param {number} startIndex - The index to start at.
     * @param {number} amount - The number to upload.
     */
    uploadDynamic(children, startIndex, amount) {
        for (var i = 0; i < this.dynamicProperties.length; i++) {
            var property = this.dynamicProperties[i];
            property.uploadFunction(children, startIndex, amount, property.type === WebGLSettings_1.WebGLSettings.TYPES.UNSIGNED_BYTE ? this.dynamicDataUint32 : this.dynamicData, this.dynamicStride, property.offset);
        }
        this.dynamicBuffer._updateID++;
    }
    ;
    /**
     * Uploads the static properties.
     *
     * @private
     * @param {PIXI.DisplayObject[]} children - The children to upload.
     * @param {number} startIndex - The index to start at.
     * @param {number} amount - The number to upload.
     */
    uploadStatic(children, startIndex, amount) {
        for (var i = 0; i < this.staticProperties.length; i++) {
            var property = this.staticProperties[i];
            property.uploadFunction(children, startIndex, amount, property.type === WebGLSettings_1.WebGLSettings.TYPES.UNSIGNED_BYTE ? this.staticDataUint32 : this.staticData, this.staticStride, property.offset);
        }
        this.staticBuffer._updateID++;
    }
    ;
    /**
     * Destroys the ParticleBuffer.
     *
     * @private
     */
    destroy() {
        this.indexBuffer = null;
        this.dynamicProperties = null;
        // this.dynamicBuffer.destroy();
        this.dynamicBuffer = null;
        this.dynamicData = null;
        this.dynamicDataUint32 = null;
        this.staticProperties = null;
        // this.staticBuffer.destroy();
        this.staticBuffer = null;
        this.staticData = null;
        this.staticDataUint32 = null;
        // all buffers are destroyed inside geometry
        this.geometry.destroy();
    }
    ;
}
exports.ParticleBuffer = ParticleBuffer;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/ParticleRenderer.js":
/*!****************************************************!*\
  !*** ./js-compile/raw-pixi-ts/ParticleRenderer.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const ObjectRenderer_1 = __webpack_require__(/*! ./ObjectRenderer */ "./js-compile/raw-pixi-ts/ObjectRenderer.js");
const Matrix_1 = __webpack_require__(/*! ./Matrix */ "./js-compile/raw-pixi-ts/Matrix.js");
const Shader_1 = __webpack_require__(/*! ./Shader */ "./js-compile/raw-pixi-ts/Shader.js");
const ParticleBuffer_1 = __webpack_require__(/*! ./ParticleBuffer */ "./js-compile/raw-pixi-ts/ParticleBuffer.js");
const ColorSettings_1 = __webpack_require__(/*! ./ColorSettings */ "./js-compile/raw-pixi-ts/ColorSettings.js");
const BlendModesSettings_1 = __webpack_require__(/*! ./BlendModesSettings */ "./js-compile/raw-pixi-ts/BlendModesSettings.js");
const WebGLSettings_1 = __webpack_require__(/*! ./WebGLSettings */ "./js-compile/raw-pixi-ts/WebGLSettings.js");
class ParticleRenderer extends ObjectRenderer_1.ObjectRenderer {
    constructor(renderer) {
        super(renderer);
        // 65535 is max vertex index in the index buffer (see ParticleRenderer)
        // so max number of particles is 65536 / 4 = 16384
        // and max number of element in the index buffer is 16384 * 6 = 98304
        // Creating a full index buffer, overhead is 98304 * 2 = 196Ko
        // let numIndices = 98304;
        /**
         * The default shader that is used if a sprite doesn't have a more specific one.
         *
         * @member {PIXI.Shader}
         */
        this.shader = null;
        this.properties = null;
        this.tempMatrix = new Matrix_1.Matrix();
        this.properties = [
            // verticesData
            {
                attributeName: 'aVertexPosition',
                size: 2,
                uploadFunction: this.uploadVertices,
                offset: 0,
            },
            // positionData
            {
                attributeName: 'aPositionCoord',
                size: 2,
                uploadFunction: this.uploadPosition,
                offset: 0,
            },
            // rotationData
            {
                attributeName: 'aRotation',
                size: 1,
                uploadFunction: this.uploadRotation,
                offset: 0,
            },
            // uvsData
            {
                attributeName: 'aTextureCoord',
                size: 2,
                uploadFunction: this.uploadUvs,
                offset: 0,
            },
            // tintData
            {
                attributeName: 'aColor',
                size: 1,
                type: WebGLSettings_1.WebGLSettings.TYPES.UNSIGNED_BYTE,
                uploadFunction: this.uploadTint,
                offset: 0,
            }
        ];
        this.shader = Shader_1.Shader.from(ParticleRenderer.vertex$2, ParticleRenderer.fragment$1, {});
    }
    /**
     * Renders the particle container object.
     *
     * @param {PIXI.ParticleContainer} container - The container to render using this ParticleRenderer
     */
    render(container) {
        var children = container.children;
        var maxSize = container._maxSize;
        var batchSize = container._batchSize;
        var renderer = this.renderer;
        var totalChildren = children.length;
        if (totalChildren === 0) {
            return;
        }
        else if (totalChildren > maxSize) {
            totalChildren = maxSize;
        }
        var buffers = container._buffers;
        if (!buffers) {
            buffers = container._buffers = this.generateBuffers(container);
        }
        var baseTexture = children[0]._texture.baseTexture;
        // if the uvs have not updated then no point rendering just yet!
        this.renderer.state.setBlendMode(BlendModesSettings_1.BlendModesSettings.correctBlendMode(container.blendMode, baseTexture.premultiplyAlpha));
        var gl = renderer.gl;
        var m = container.worldTransform.copyTo(this.tempMatrix);
        m.prepend(renderer.globalUniforms.uniforms.projectionMatrix);
        this.shader.uniforms.translationMatrix = m.toArray(true);
        this.shader.uniforms.uColor = ColorSettings_1.ColorSettings.premultiplyRgba(container.tintRgb, container.worldAlpha, this.shader.uniforms.uColor, baseTexture.premultiplyAlpha);
        this.shader.uniforms.uSampler = baseTexture;
        this.renderer.shader.bind(this.shader);
        var updateStatic = false;
        // now lets upload and render the buffers..
        for (var i = 0, j = 0; i < totalChildren; i += batchSize, j += 1) {
            var amount = (totalChildren - i);
            if (amount > batchSize) {
                amount = batchSize;
            }
            if (j >= buffers.length) {
                if (!container.autoResize) {
                    break;
                }
                buffers.push(this._generateOneMoreBuffer(container));
            }
            var buffer = buffers[j];
            // we always upload the dynamic
            buffer.uploadDynamic(children, i, amount);
            var bid = container._bufferUpdateIDs[j] || 0;
            updateStatic = updateStatic || (buffer._updateID < bid);
            // we only upload the static content when we have to!
            if (updateStatic) {
                buffer._updateID = container._updateID;
                buffer.uploadStatic(children, i, amount);
            }
            // bind the buffer
            renderer.geometry.bind(buffer.geometry);
            gl.drawElements(gl.TRIANGLES, amount * 6, gl.UNSIGNED_SHORT, 0);
        }
    }
    ;
    /**
     * Creates one particle buffer for each child in the container we want to render and updates internal properties
     *
     * @param {PIXI.ParticleContainer} container - The container to render using this ParticleRenderer
     * @return {PIXI.ParticleBuffer[]} The buffers
     * @private
     */
    generateBuffers(container) {
        var buffers = [];
        var size = container._maxSize;
        var batchSize = container._batchSize;
        var dynamicPropertyFlags = container._properties;
        for (var i = 0; i < size; i += batchSize) {
            buffers.push(new ParticleBuffer_1.ParticleBuffer(this.properties, dynamicPropertyFlags, batchSize));
        }
        return buffers;
    }
    ;
    /**
     * Creates one more particle buffer, because container has autoResize feature
     *
     * @param {PIXI.ParticleContainer} container - The container to render using this ParticleRenderer
     * @return {PIXI.ParticleBuffer} generated buffer
     * @private
     */
    _generateOneMoreBuffer(container) {
        var batchSize = container._batchSize;
        var dynamicPropertyFlags = container._properties;
        return new ParticleBuffer_1.ParticleBuffer(this.properties, dynamicPropertyFlags, batchSize);
    }
    ;
    /**
     * Uploads the vertices.
     *
     * @param {PIXI.DisplayObject[]} children - the array of display objects to render
     * @param {number} startIndex - the index to start from in the children array
     * @param {number} amount - the amount of children that will have their vertices uploaded
     * @param {number[]} array - The vertices to upload.
     * @param {number} stride - Stride to use for iteration.
     * @param {number} offset - Offset to start at.
     */
    uploadVertices(children, startIndex, amount, array, stride, offset) {
        var w0 = 0;
        var w1 = 0;
        var h0 = 0;
        var h1 = 0;
        for (var i = 0; i < amount; ++i) {
            var sprite = children[startIndex + i];
            var texture = sprite._texture;
            var sx = sprite.scale.x;
            var sy = sprite.scale.y;
            var trim = texture.trim;
            var orig = texture.orig;
            if (trim) {
                // if the sprite is trimmed and is not a tilingsprite then we need to add the
                // extra space before transforming the sprite coords..
                w1 = trim.x - (sprite.anchor.x * orig.width);
                w0 = w1 + trim.width;
                h1 = trim.y - (sprite.anchor.y * orig.height);
                h0 = h1 + trim.height;
            }
            else {
                w0 = (orig.width) * (1 - sprite.anchor.x);
                w1 = (orig.width) * -sprite.anchor.x;
                h0 = orig.height * (1 - sprite.anchor.y);
                h1 = orig.height * -sprite.anchor.y;
            }
            array[offset] = w1 * sx;
            array[offset + 1] = h1 * sy;
            array[offset + stride] = w0 * sx;
            array[offset + stride + 1] = h1 * sy;
            array[offset + (stride * 2)] = w0 * sx;
            array[offset + (stride * 2) + 1] = h0 * sy;
            array[offset + (stride * 3)] = w1 * sx;
            array[offset + (stride * 3) + 1] = h0 * sy;
            offset += stride * 4;
        }
    }
    ;
    /**
     * Uploads the position.
     *
     * @param {PIXI.DisplayObject[]} children - the array of display objects to render
     * @param {number} startIndex - the index to start from in the children array
     * @param {number} amount - the amount of children that will have their positions uploaded
     * @param {number[]} array - The vertices to upload.
     * @param {number} stride - Stride to use for iteration.
     * @param {number} offset - Offset to start at.
     */
    uploadPosition(children, startIndex, amount, array, stride, offset) {
        for (var i = 0; i < amount; i++) {
            var spritePosition = children[startIndex + i].position;
            array[offset] = spritePosition.x;
            array[offset + 1] = spritePosition.y;
            array[offset + stride] = spritePosition.x;
            array[offset + stride + 1] = spritePosition.y;
            array[offset + (stride * 2)] = spritePosition.x;
            array[offset + (stride * 2) + 1] = spritePosition.y;
            array[offset + (stride * 3)] = spritePosition.x;
            array[offset + (stride * 3) + 1] = spritePosition.y;
            offset += stride * 4;
        }
    }
    ;
    /**
     * Uploads the rotiation.
     *
     * @param {PIXI.DisplayObject[]} children - the array of display objects to render
     * @param {number} startIndex - the index to start from in the children array
     * @param {number} amount - the amount of children that will have their rotation uploaded
     * @param {number[]} array - The vertices to upload.
     * @param {number} stride - Stride to use for iteration.
     * @param {number} offset - Offset to start at.
     */
    uploadRotation(children, startIndex, amount, array, stride, offset) {
        for (var i = 0; i < amount; i++) {
            var spriteRotation = children[startIndex + i].rotation;
            array[offset] = spriteRotation;
            array[offset + stride] = spriteRotation;
            array[offset + (stride * 2)] = spriteRotation;
            array[offset + (stride * 3)] = spriteRotation;
            offset += stride * 4;
        }
    }
    ;
    /**
     * Uploads the Uvs
     *
     * @param {PIXI.DisplayObject[]} children - the array of display objects to render
     * @param {number} startIndex - the index to start from in the children array
     * @param {number} amount - the amount of children that will have their rotation uploaded
     * @param {number[]} array - The vertices to upload.
     * @param {number} stride - Stride to use for iteration.
     * @param {number} offset - Offset to start at.
     */
    uploadUvs(children, startIndex, amount, array, stride, offset) {
        for (var i = 0; i < amount; ++i) {
            var textureUvs = children[startIndex + i]._texture._uvs;
            if (textureUvs) {
                array[offset] = textureUvs.x0;
                array[offset + 1] = textureUvs.y0;
                array[offset + stride] = textureUvs.x1;
                array[offset + stride + 1] = textureUvs.y1;
                array[offset + (stride * 2)] = textureUvs.x2;
                array[offset + (stride * 2) + 1] = textureUvs.y2;
                array[offset + (stride * 3)] = textureUvs.x3;
                array[offset + (stride * 3) + 1] = textureUvs.y3;
                offset += stride * 4;
            }
            else {
                // TODO you know this can be easier!
                array[offset] = 0;
                array[offset + 1] = 0;
                array[offset + stride] = 0;
                array[offset + stride + 1] = 0;
                array[offset + (stride * 2)] = 0;
                array[offset + (stride * 2) + 1] = 0;
                array[offset + (stride * 3)] = 0;
                array[offset + (stride * 3) + 1] = 0;
                offset += stride * 4;
            }
        }
    }
    ;
    /**
     * Uploads the tint.
     *
     * @param {PIXI.DisplayObject[]} children - the array of display objects to render
     * @param {number} startIndex - the index to start from in the children array
     * @param {number} amount - the amount of children that will have their rotation uploaded
     * @param {number[]} array - The vertices to upload.
     * @param {number} stride - Stride to use for iteration.
     * @param {number} offset - Offset to start at.
     */
    uploadTint(children, startIndex, amount, array, stride, offset) {
        for (var i = 0; i < amount; ++i) {
            var sprite = children[startIndex + i];
            var premultiplied = sprite._texture.baseTexture.premultiplyAlpha;
            var alpha = sprite.alpha;
            // we dont call extra function if alpha is 1.0, that's faster
            var argb = alpha < 1.0 && premultiplied ? ColorSettings_1.ColorSettings.premultiplyTint(sprite._tintRGB, alpha)
                : sprite._tintRGB + (alpha * 255 << 24);
            array[offset] = argb;
            array[offset + stride] = argb;
            array[offset + (stride * 2)] = argb;
            array[offset + (stride * 3)] = argb;
            offset += stride * 4;
        }
    }
    ;
    /**
     * Destroys the ParticleRenderer.
     */
    destroy() {
        super.destroy();
        if (this.shader) {
            this.shader.destroy();
            this.shader = null;
        }
        this.tempMatrix = null;
    }
    ;
}
ParticleRenderer.vertex$2 = "attribute vec2 aVertexPosition;\r\nattribute vec2 aTextureCoord;\r\nattribute vec4 aColor;\r\n\r\nattribute vec2 aPositionCoord;\r\nattribute float aRotation;\r\n\r\nuniform mat3 translationMatrix;\r\nuniform vec4 uColor;\r\n\r\nvarying vec2 vTextureCoord;\r\nvarying vec4 vColor;\r\n\r\nvoid main(void){\r\n    float x = (aVertexPosition.x) * cos(aRotation) - (aVertexPosition.y) * sin(aRotation);\r\n    float y = (aVertexPosition.x) * sin(aRotation) + (aVertexPosition.y) * cos(aRotation);\r\n\r\n    vec2 v = vec2(x, y);\r\n    v = v + aPositionCoord;\r\n\r\n    gl_Position = vec4((translationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);\r\n\r\n    vTextureCoord = aTextureCoord;\r\n    vColor = aColor * uColor;\r\n}\r\n";
ParticleRenderer.fragment$1 = "varying vec2 vTextureCoord;\r\nvarying vec4 vColor;\r\n\r\nuniform sampler2D uSampler;\r\n\r\nvoid main(void){\r\n    vec4 color = texture2D(uSampler, vTextureCoord) * vColor;\r\n    gl_FragColor = color;\r\n}";
exports.ParticleRenderer = ParticleRenderer;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/Point.js":
/*!*****************************************!*\
  !*** ./js-compile/raw-pixi-ts/Point.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class Point {
    constructor(x = 0, y = 0) {
        if (x === void 0) {
            x = 0;
        }
        if (y === void 0) {
            y = 0;
        }
        /**
         * @member {number}
         * @default 0
         */
        this.x = x;
        /**
         * @member {number}
         * @default 0
         */
        this.y = y;
    }
    /**
     * Sets the point to a new x and y position.
     * If y is omitted, both x and y will be set to x.
     *
     * @param {number} [x=0] - position of the point on the x axis
     * @param {number} [y=0] - position of the point on the y axis
     */
    set(x = 0, y = 0) {
        this.x = x || 0;
        this.y = y || ((y !== 0) ? this.x : 0);
    }
    ;
    /**
     * Returns true if the given point is equal to this point
     *
     * @param {PIXI.IPoint} p - The point to check
     * @returns {boolean} Whether the given point equal to this point
     */
    equals(p) {
        return (p.x === this.x) && (p.y === this.y);
    }
    ;
    /**
     * Copies x and y into the given point
     *
     * @param {PIXI.IPoint} p - The point to copy.
     * @returns {PIXI.IPoint} Given point with values updated
     */
    copyTo(p) {
        p.set(this.x, this.y);
        return p;
    }
    ;
    /**
     * Copies x and y from the given point
     *
     * @param {PIXI.IPoint} p - The point to copy from
     * @returns {PIXI.IPoint} Returns itself.
     */
    copyFrom(p) {
        this.set(p.x, p.y);
        return this;
    }
    ;
    /**
     * Creates a clone of this point
     *
     * @return {PIXI.Point} a copy of the point
     */
    clone() {
        return new Point(this.x, this.y);
    }
    ;
}
exports.Point = Point;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/Polygon.js":
/*!*******************************************!*\
  !*** ./js-compile/raw-pixi-ts/Polygon.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Point_1 = __webpack_require__(/*! ./Point */ "./js-compile/raw-pixi-ts/Point.js");
const ShapeSettings_1 = __webpack_require__(/*! ./ShapeSettings */ "./js-compile/raw-pixi-ts/ShapeSettings.js");
class Polygon {
    constructor(arg = null) {
        var arguments$1 = arguments;
        var points = [], len = arguments.length;
        while (len--) {
            points[len] = arguments$1[len];
        }
        if (Array.isArray(points[0])) {
            points = points[0];
        }
        // if this is an array of points, convert it to a flat array of numbers
        if (points[0] instanceof Point_1.Point) {
            var p = [];
            for (var i = 0, il = points.length; i < il; i++) {
                p.push(points[i].x, points[i].y);
            }
            points = p;
        }
        /**
         * An array of the points of this polygon
         *
         * @member {number[]}
         */
        this.points = points;
        /**
         * The type of the object, mainly used to avoid `instanceof` checks
         *
         * @member {number}
         * @readOnly
         * @default PIXI.SHAPES.POLY
         * @see PIXI.SHAPES
         */
        this.type = ShapeSettings_1.ShapeSettings.SHAPES.POLY;
        /**
         * `false` after moveTo, `true` after `closePath`. In all other cases it is `true`.
         * @member {boolean}
         * @default true
         */
        this.closeStroke = true;
    }
    /**
     * Creates a clone of this polygon
     *
     * @return {PIXI.Polygon} a copy of the polygon
     */
    clone() {
        var polygon = new Polygon(this.points.slice());
        polygon.closeStroke = this.closeStroke;
        return polygon;
    }
    ;
    /**
     * Checks whether the x and y coordinates passed to this function are contained within this polygon
     *
     * @param {number} x - The X coordinate of the point to test
     * @param {number} y - The Y coordinate of the point to test
     * @return {boolean} Whether the x/y coordinates are within this polygon
     */
    contains(x, y) {
        var inside = false;
        // use some raycasting to test hits
        // https://github.com/substack/point-in-polygon/blob/master/index.js
        var length = this.points.length / 2;
        for (var i = 0, j = length - 1; i < length; j = i++) {
            var xi = this.points[i * 2];
            var yi = this.points[(i * 2) + 1];
            var xj = this.points[j * 2];
            var yj = this.points[(j * 2) + 1];
            var intersect = ((yi > y) !== (yj > y)) && (x < ((xj - xi) * ((y - yi) / (yj - yi))) + xi);
            if (intersect) {
                inside = !inside;
            }
        }
        return inside;
    }
    ;
}
exports.Polygon = Polygon;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/Prepare.js":
/*!*******************************************!*\
  !*** ./js-compile/raw-pixi-ts/Prepare.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BasePrepare_1 = __webpack_require__(/*! ./BasePrepare */ "./js-compile/raw-pixi-ts/BasePrepare.js");
// import { settings } from "./settings";
const Graphics_1 = __webpack_require__(/*! ./Graphics */ "./js-compile/raw-pixi-ts/Graphics.js");
const BaseTexture_1 = __webpack_require__(/*! ./BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
class Prepare extends BasePrepare_1.BasePrepare {
    constructor(renderer) {
        super(renderer);
        this.uploadHookHelper = this.renderer;
        // Add textures and graphics to upload
        this.registerFindHook(Prepare.findGraphics);
        this.registerUploadHook(Prepare.uploadBaseTextures);
        this.registerUploadHook(Prepare.uploadGraphics);
    }
    static findGraphics(item, queue) {
        if (item instanceof Graphics_1.Graphics) {
            queue.push(item);
            return true;
        }
        return false;
    }
    static uploadBaseTextures(renderer, item) {
        if (item instanceof BaseTexture_1.BaseTexture) {
            if (!item._glTextures[renderer.CONTEXT_UID]) {
                renderer.textureManager.updateTexture(item);
            }
            return true;
        }
        return false;
    }
    static uploadGraphics(renderer, item) {
        if (item instanceof Graphics_1.Graphics) {
            if (item.dirty || item.clearDirty || !item._webGL[renderer.plugins.graphics.CONTEXT_UID]) {
                renderer.plugins.graphics.updateGraphics(item);
            }
            return true;
        }
        return false;
    }
}
exports.Prepare = Prepare;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/Program.js":
/*!*******************************************!*\
  !*** ./js-compile/raw-pixi-ts/Program.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Shader_1 = __webpack_require__(/*! ./Shader */ "./js-compile/raw-pixi-ts/Shader.js");
const CacheSettings_1 = __webpack_require__(/*! ./CacheSettings */ "./js-compile/raw-pixi-ts/CacheSettings.js");
const WebGLSettings_1 = __webpack_require__(/*! ./WebGLSettings */ "./js-compile/raw-pixi-ts/WebGLSettings.js");
class Program {
    constructor(vertexSrc, fragmentSrc, name = 'pixi-shader') {
        this.id = Program.UID$3++;
        /**
         * The vertex shader.
         *
         * @member {string}
         */
        this.vertexSrc = vertexSrc || Program.defaultVertexSrc;
        /**
         * The fragment shader.
         *
         * @member {string}
         */
        this.fragmentSrc = fragmentSrc || Program.defaultFragmentSrc;
        this.vertexSrc = this.vertexSrc.trim();
        this.fragmentSrc = this.fragmentSrc.trim();
        if (this.vertexSrc.substring(0, 8) !== '#version') {
            name = name.replace(/\s+/g, '-');
            if (CacheSettings_1.CacheSettings.nameCache[name]) {
                CacheSettings_1.CacheSettings.nameCache[name]++;
                name += "-" + (CacheSettings_1.CacheSettings.nameCache[name]);
            }
            else {
                CacheSettings_1.CacheSettings.nameCache[name] = 1;
            }
            this.vertexSrc = "#define SHADER_NAME " + name + "\n" + (this.vertexSrc);
            this.fragmentSrc = "#define SHADER_NAME " + name + "\n" + (this.fragmentSrc);
            this.vertexSrc = WebGLSettings_1.WebGLSettings.setPrecision(this.vertexSrc, WebGLSettings_1.WebGLSettings.PRECISION_VERTEX);
            this.fragmentSrc = WebGLSettings_1.WebGLSettings.setPrecision(this.fragmentSrc, WebGLSettings_1.WebGLSettings.PRECISION_FRAGMENT);
        }
        if (name == "pixi-shader-4") {
        }
        // currently this does not extract structs only default types
        this.extractData(this.vertexSrc, this.fragmentSrc);
        // this is where we store shader references..
        this.glPrograms = {};
        this.syncUniforms = null;
    }
    /**
     * Extracts the data for a buy creating a small test program
     * or reading the src directly.
     * @protected
     *
     * @param {string} [vertexSrc] - The source of the vertex shader.
     * @param {string} [fragmentSrc] - The source of the fragment shader.
     */
    extractData(vertexSrc, fragmentSrc) {
        var gl = WebGLSettings_1.WebGLSettings.getTestContext();
        if (gl) {
            var program = Program.compileProgram(gl, vertexSrc, fragmentSrc);
            this.attributeData = this.getAttributeData(program, gl);
            this.uniformData = this.getUniformData(program, gl);
            gl.deleteProgram(program);
        }
        else {
            this.uniformData = {};
            this.attributeData = {};
        }
    }
    ;
    /**
     * returns the attribute data from the program
     * @private
     *
     * @param {WebGLProgram} [program] - the WebGL program
     * @param {WebGLRenderingContext} [gl] - the WebGL context
     *
     * @returns {object} the attribute data for this program
     */
    getAttributeData(program, gl) {
        var attributes = {};
        var attributesArray = [];
        var totalAttributes = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
        for (var i = 0; i < totalAttributes; i++) {
            var attribData = gl.getActiveAttrib(program, i);
            var type = WebGLSettings_1.WebGLSettings.mapType(gl, attribData.type);
            /*eslint-disable */
            var data = {
                type: type,
                name: attribData.name,
                size: WebGLSettings_1.WebGLSettings.mapSize(type),
                location: 0,
            };
            /* eslint-enable */
            attributes[attribData.name] = data;
            attributesArray.push(data);
        }
        attributesArray.sort(function (a, b) { return (a.name > b.name) ? 1 : -1; }); // eslint-disable-line no-confusing-arrow
        for (var i$1 = 0; i$1 < attributesArray.length; i$1++) {
            attributesArray[i$1].location = i$1;
        }
        return attributes;
    }
    ;
    /**
     * returns the uniform data from the program
     * @private
     *
     * @param {webGL-program} [program] - the webgl program
     * @param {context} [gl] - the WebGL context
     *
     * @returns {object} the uniform data for this program
     */
    getUniformData(program, gl) {
        var uniforms = {};
        var totalUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
        // TODO expose this as a prop?
        // const maskRegex = new RegExp('^(projectionMatrix|uSampler|translationMatrix)$');
        // const maskRegex = new RegExp('^(projectionMatrix|uSampler|translationMatrix)$');
        for (var i = 0; i < totalUniforms; i++) {
            var uniformData = gl.getActiveUniform(program, i);
            var name = uniformData.name.replace(/\[.*?\]/, '');
            var isArray = uniformData.name.match(/\[.*?\]/, '');
            var type = WebGLSettings_1.WebGLSettings.mapType(gl, uniformData.type);
            /*eslint-disable */
            uniforms[name] = {
                type: type,
                size: uniformData.size,
                isArray: isArray,
                value: WebGLSettings_1.WebGLSettings.defaultValue(type, uniformData.size),
            };
            /* eslint-enable */
        }
        return uniforms;
    }
    ;
    /**
     * The default vertex shader source
     *
     * @static
     * @constant
     * @member {string}
     */
    static get defaultVertexSrc() {
        return Program.defaultVertex;
    }
    ;
    /**
     * The default fragment shader source
     *
     * @static
     * @constant
     * @member {string}
     */
    static get defaultFragmentSrc() {
        return Program.defaultFragment;
    }
    ;
    /**
     * A short hand function to create a program based of a vertex and fragment shader
     * this method will also check to see if there is a cached program.
     *
     * @param {string} [vertexSrc] - The source of the vertex shader.
     * @param {string} [fragmentSrc] - The source of the fragment shader.
     * @param {object} [uniforms] - Custom uniforms to use to augment the built-in ones.
     *
     * @returns {PIXI.Program} an shiny new Pixi shader!
     */
    static from(vertexSrc, fragmentSrc, name = "pixi-shader") {
        var key = vertexSrc + fragmentSrc;
        var program = CacheSettings_1.CacheSettings.ProgramCache[key];
        if (!program) {
            CacheSettings_1.CacheSettings.ProgramCache[key] = program = new Program(vertexSrc, fragmentSrc, name);
        }
        return program;
    }
    ;
    /**
 * @method compileProgram
 * @private
 * @memberof PIXI.glCore.shader
 * @param gl {WebGLRenderingContext} The current WebGL context {WebGLProgram}
 * @param vertexSrc {string|string[]} The vertex shader source as an array of strings.
 * @param fragmentSrc {string|string[]} The fragment shader source as an array of strings.
 * @param attributeLocations {Object} An attribute location map that lets you manually set the attribute locations
 * @return {WebGLProgram} the shader program
 */
    static compileProgram(gl, vertexSrc, fragmentSrc, attributeLocations = null) {
        var glVertShader = Shader_1.Shader.compileShader(gl, gl.VERTEX_SHADER, vertexSrc);
        var glFragShader = Shader_1.Shader.compileShader(gl, gl.FRAGMENT_SHADER, fragmentSrc);
        var program = gl.createProgram();
        gl.attachShader(program, glVertShader);
        gl.attachShader(program, glFragShader);
        // optionally, set the attributes manually for the program rather than letting WebGL decide..
        if (attributeLocations) {
            for (var i in attributeLocations) {
                gl.bindAttribLocation(program, attributeLocations[i], i);
            }
        }
        gl.linkProgram(program);
        // if linking fails, then log and cleanup
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            console.error('Pixi.js Error: Could not initialize shader.');
            console.error('gl.VALIDATE_STATUS', gl.getProgramParameter(program, gl.VALIDATE_STATUS));
            console.error('gl.getError()', gl.getError());
            // if there is a program info log, log it
            if (gl.getProgramInfoLog(program) !== '') {
                console.warn('Pixi.js Warning: gl.getProgramInfoLog()', gl.getProgramInfoLog(program));
            }
            gl.deleteProgram(program);
            program = null;
        }
        // clean up some shaders
        gl.deleteShader(glVertShader);
        gl.deleteShader(glFragShader);
        return program;
    }
}
Program.UID$3 = 0;
Program.defaultFragment = "varying vec2 vTextureCoord;\r\n\r\nuniform sampler2D uSampler;\r\n\r\nvoid main(void){\r\n   gl_FragColor *= texture2D(uSampler, vTextureCoord);\r\n}";
Program.defaultVertex = "attribute vec2 aVertexPosition;\r\nattribute vec2 aTextureCoord;\r\n\r\nuniform mat3 projectionMatrix;\r\n\r\nvarying vec2 vTextureCoord;\r\n\r\nvoid main(void){\r\n   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\r\n   vTextureCoord = aTextureCoord;\r\n}\r\n";
exports.Program = Program;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/ProgressEvent.js":
/*!*************************************************!*\
  !*** ./js-compile/raw-pixi-ts/ProgressEvent.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Event_1 = __webpack_require__(/*! ./Event */ "./js-compile/raw-pixi-ts/Event.js");
class ProgressEvent extends Event_1.Event {
    constructor(type, bubbles = false, cancelable = false) {
        super(type, bubbles, cancelable);
    }
    clone() {
        var event = ProgressEvent.getProgressEvent(this.type, this.bubbles, this.cancelable);
        event.bytesLoaded = this.bytesLoaded;
        event.bytesTotal = this.bytesTotal;
        event.percent = this.percent;
        return event;
    }
    get isDisposable() {
        return true;
    }
    static getProgressEvent(type, bubble = true, cancelable = true) {
        if (ProgressEvent.ProgressEventCache.length) {
            let te = ProgressEvent.ProgressEventCache[ProgressEvent.ProgressEventCache.length - 1];
            ProgressEvent.ProgressEventCache.length -= 1;
            te.reset(type, bubble, cancelable);
            return te;
        }
        return new ProgressEvent(type, bubble, cancelable);
    }
    destructor() {
        this._currentTarget = null;
        // this._legacyTarget = null;
        let index = ProgressEvent.ProgressEventCache.indexOf(this);
        if (index < 0) {
            ProgressEvent.ProgressEventCache.push(this);
        }
    }
}
ProgressEvent.ProgressEventCache = [];
ProgressEvent.PROGRESS = "progress";
exports.ProgressEvent = ProgressEvent;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/ProjectionSystem.js":
/*!****************************************************!*\
  !*** ./js-compile/raw-pixi-ts/ProjectionSystem.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const System_1 = __webpack_require__(/*! ./System */ "./js-compile/raw-pixi-ts/System.js");
const Matrix_1 = __webpack_require__(/*! ./Matrix */ "./js-compile/raw-pixi-ts/Matrix.js");
class ProjectionSystem extends System_1.System {
    constructor(renderer) {
        super(renderer);
        /**
         * Destination frame
         * @member {PIXI.Rectangle}
         * @readonly
         */
        this.destinationFrame = null;
        /**
         * Source frame
         * @member {PIXI.Rectangle}
         * @readonly
         */
        this.sourceFrame = null;
        /**
         * Default destination frame
         * @member {PIXI.Rectangle}
         * @readonly
         */
        this.defaultFrame = null;
        /**
         * Project matrix
         * @member {PIXI.Matrix}
         * @readonly
         */
        this.projectionMatrix = new Matrix_1.Matrix();
        /**
         * A transform that will be appended to the projection matrix
         * if null, nothing will be applied
         * @member {PIXI.Matrix}
         */
        this.transform = null;
    }
    /**
     * Updates the projection matrix based on a projection frame (which is a rectangle)
     *
     * @param {PIXI.Rectangle} destinationFrame - The destination frame.
     * @param {PIXI.Rectangle} sourceFrame - The source frame.
     * @param {Number} resolution - Resolution
     * @param {boolean} root - If is root
     */
    update(destinationFrame, sourceFrame, resolution, root) {
        this.destinationFrame = destinationFrame || this.destinationFrame || this.defaultFrame;
        this.sourceFrame = sourceFrame || this.sourceFrame || destinationFrame;
        this.calculateProjection(this.destinationFrame, this.sourceFrame, resolution, root);
        if (this.transform) {
            this.projectionMatrix.append(this.transform);
        }
        var renderer = this.renderer;
        renderer.globalUniforms.uniforms.projectionMatrix = this.projectionMatrix;
        renderer.globalUniforms.update();
        // this will work for now
        // but would be sweet to stick and even on the global uniforms..
        if (renderer.shader.shader) {
            renderer.shader.syncUniformGroup(renderer.shader.shader.uniforms.globals);
        }
    }
    ;
    /**
     * Updates the projection matrix based on a projection frame (which is a rectangle)
     *
     * @param {PIXI.Rectangle} destinationFrame - The destination frame.
     * @param {PIXI.Rectangle} sourceFrame - The source frame.
     * @param {Number} resolution - Resolution
     * @param {boolean} root - If is root
     */
    calculateProjection(destinationFrame, sourceFrame, resolution, root) {
        var pm = this.projectionMatrix;
        // I don't think we will need this line..
        // pm.identity();
        if (!root) {
            pm.a = (1 / destinationFrame.width * 2) * resolution;
            pm.d = (1 / destinationFrame.height * 2) * resolution;
            pm.tx = -1 - (sourceFrame.x * pm.a);
            pm.ty = -1 - (sourceFrame.y * pm.d);
        }
        else {
            pm.a = (1 / destinationFrame.width * 2) * resolution;
            pm.d = (-1 / destinationFrame.height * 2) * resolution;
            pm.tx = -1 - (sourceFrame.x * pm.a);
            pm.ty = 1 - (sourceFrame.y * pm.d);
        }
    }
    ;
    /**
     * Sets the transform of the active render target to the given matrix
     *
     * @param {PIXI.Matrix} matrix - The transformation matrix
     */
    setTransform() {
        // this._activeRenderTarget.transform = matrix;
    }
    ;
}
exports.ProjectionSystem = ProjectionSystem;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/Quad.js":
/*!****************************************!*\
  !*** ./js-compile/raw-pixi-ts/Quad.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Geometry_1 = __webpack_require__(/*! ./Geometry */ "./js-compile/raw-pixi-ts/Geometry.js");
class Quad extends Geometry_1.Geometry {
    constructor() {
        super();
        this.addAttribute('aVertexPosition', [0, 0, 1, 0, 1, 1, 0, 1]).addIndex([0, 1, 3, 2]);
    }
}
exports.Quad = Quad;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/QuadUv.js":
/*!******************************************!*\
  !*** ./js-compile/raw-pixi-ts/QuadUv.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Geometry_1 = __webpack_require__(/*! ./Geometry */ "./js-compile/raw-pixi-ts/Geometry.js");
const Buffer_1 = __webpack_require__(/*! ./Buffer */ "./js-compile/raw-pixi-ts/Buffer.js");
class QuadUv extends Geometry_1.Geometry {
    constructor() {
        super();
        /**
         * An array of vertices
         *
         * @member {Float32Array}
         */
        this.vertices = new Float32Array([
            -1, -1,
            1, -1,
            1, 1,
            -1, 1
        ]);
        /**
         * The Uvs of the quad
         *
         * @member {Float32Array}
         */
        this.uvs = new Float32Array([
            0, 0,
            1, 0,
            1, 1,
            0, 1
        ]);
        this.vertexBuffer = new Buffer_1.Buffer(this.vertices);
        this.uvBuffer = new Buffer_1.Buffer(this.uvs);
        this.addAttribute('aVertexPosition', this.vertexBuffer)
            .addAttribute('aTextureCoord', this.uvBuffer)
            .addIndex([0, 1, 2, 0, 2, 3]);
    }
    /**
     * Maps two Rectangle to the quad.
     *
     * @param {PIXI.Rectangle} targetTextureFrame - the first rectangle
     * @param {PIXI.Rectangle} destinationFrame - the second rectangle
     * @return {PIXI.Quad} Returns itself.
     */
    map(targetTextureFrame, destinationFrame) {
        var x = 0; // destinationFrame.x / targetTextureFrame.width;
        var y = 0; // destinationFrame.y / targetTextureFrame.height;
        this.uvs[0] = x;
        this.uvs[1] = y;
        this.uvs[2] = x + (destinationFrame.width / targetTextureFrame.width);
        this.uvs[3] = y;
        this.uvs[4] = x + (destinationFrame.width / targetTextureFrame.width);
        this.uvs[5] = y + (destinationFrame.height / targetTextureFrame.height);
        this.uvs[6] = x;
        this.uvs[7] = y + (destinationFrame.height / targetTextureFrame.height);
        x = destinationFrame.x;
        y = destinationFrame.y;
        this.vertices[0] = x;
        this.vertices[1] = y;
        this.vertices[2] = x + destinationFrame.width;
        this.vertices[3] = y;
        this.vertices[4] = x + destinationFrame.width;
        this.vertices[5] = y + destinationFrame.height;
        this.vertices[6] = x;
        this.vertices[7] = y + destinationFrame.height;
        this.invalidate();
        return this;
    }
    ;
    /**
     * legacy upload method, just marks buffers dirty
     * @returns {PIXI.QuadUv} Returns itself.
     */
    invalidate() {
        this.vertexBuffer._updateID++;
        this.uvBuffer._updateID++;
        return this;
    }
    ;
}
exports.QuadUv = QuadUv;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/QuadraticUtils.js":
/*!**************************************************!*\
  !*** ./js-compile/raw-pixi-ts/QuadraticUtils.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const settings_1 = __webpack_require__(/*! ./settings */ "./js-compile/raw-pixi-ts/settings.js");
class QuadraticUtils {
    static curveLength(fromX, fromY, cpX, cpY, toX, toY) {
        var ax = fromX - (2.0 * cpX) + toX;
        var ay = fromY - (2.0 * cpY) + toY;
        var bx = (2.0 * cpX) - (2.0 * fromX);
        var by = (2.0 * cpY) - (2.0 * fromY);
        var a = 4.0 * ((ax * ax) + (ay * ay));
        var b = 4.0 * ((ax * bx) + (ay * by));
        var c = (bx * bx) + (by * by);
        var s = 2.0 * Math.sqrt(a + b + c);
        var a2 = Math.sqrt(a);
        var a32 = 2.0 * a * a2;
        var c2 = 2.0 * Math.sqrt(c);
        var ba = b / a2;
        return ((a32 * s)
            + (a2 * b * (s - c2))
            + (((4.0 * c * a) - (b * b))
                * Math.log(((2.0 * a2) + ba + s) / (ba + c2)))) / (4.0 * a32);
    }
    ;
    /**
     * Calculate the points for a quadratic bezier curve and then draws it.
     * Based on: https://stackoverflow.com/questions/785097/how-do-i-implement-a-bezier-curve-in-c
     *
     * @private
     * @param {number} cpX - Control point x
     * @param {number} cpY - Control point y
     * @param {number} toX - Destination point x
     * @param {number} toY - Destination point y
     * @param {number[]} points - Points to add segments to.
     */
    static curveTo(cpX, cpY, toX, toY, points) {
        var fromX = points[points.length - 2];
        var fromY = points[points.length - 1];
        var n = settings_1.settings.GRAPHICS_CURVES._segmentsCount(QuadraticUtils.curveLength(fromX, fromY, cpX, cpY, toX, toY));
        var xa = 0;
        var ya = 0;
        for (var i = 1; i <= n; ++i) {
            var j = i / n;
            xa = fromX + ((cpX - fromX) * j);
            ya = fromY + ((cpY - fromY) * j);
            points.push(xa + (((cpX + ((toX - cpX) * j)) - xa) * j), ya + (((cpY + ((toY - cpY) * j)) - ya) * j));
        }
    }
    ;
}
exports.QuadraticUtils = QuadraticUtils;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/Rectangle.js":
/*!*********************************************!*\
  !*** ./js-compile/raw-pixi-ts/Rectangle.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const ShapeSettings_1 = __webpack_require__(/*! ./ShapeSettings */ "./js-compile/raw-pixi-ts/ShapeSettings.js");
class Rectangle {
    constructor(x = 0, y = 0, width = 0, height = 0) {
        if (x === void 0) {
            x = 0;
        }
        if (y === void 0) {
            y = 0;
        }
        if (width === void 0) {
            width = 0;
        }
        if (height === void 0) {
            height = 0;
        }
        /**
         * @member {number}
         * @default 0
         */
        this.x = Number(x);
        /**
         * @member {number}
         * @default 0
         */
        this.y = Number(y);
        /**
         * @member {number}
         * @default 0
         */
        this.width = Number(width);
        /**
         * @member {number}
         * @default 0
         */
        this.height = Number(height);
        /**
         * The type of the object, mainly used to avoid `instanceof` checks
         *
         * @member {number}
         * @readOnly
         * @default PIXI.SHAPES.RECT
         * @see PIXI.SHAPES
         */
        this.type = ShapeSettings_1.ShapeSettings.SHAPES.RECT;
    }
    /**
     * returns the left edge of the rectangle
     *
     * @member {number}
     */
    get left() {
        return this.x;
    }
    ;
    /**
     * returns the right edge of the rectangle
     *
     * @member {number}
     */
    get right() {
        return this.x + this.width;
    }
    ;
    /**
     * returns the top edge of the rectangle
     *
     * @member {number}
     */
    get top() {
        return this.y;
    }
    ;
    /**
     * returns the bottom edge of the rectangle
     *
     * @member {number}
     */
    get bottom() {
        return this.y + this.height;
    }
    ;
    /**
     * A constant empty rectangle.
     *
     * @static
     * @constant
     * @member {PIXI.Rectangle}
     */
    static get EMPTY() {
        return new Rectangle(0, 0, 0, 0);
    }
    ;
    /**
     * Creates a clone of this Rectangle
     *
     * @return {PIXI.Rectangle} a copy of the rectangle
     */
    clone() {
        return new Rectangle(this.x, this.y, this.width, this.height);
    }
    ;
    /**
     * Copies another rectangle to this one.
     *
     * @param {PIXI.Rectangle} rectangle - The rectangle to copy from.
     * @return {PIXI.Rectangle} Returns itself.
     */
    copyFrom(rectangle) {
        this.x = rectangle.x;
        this.y = rectangle.y;
        this.width = rectangle.width;
        this.height = rectangle.height;
        return this;
    }
    ;
    /**
     * Copies this rectangle to another one.
     *
     * @param {PIXI.Rectangle} rectangle - The rectangle to copy to.
     * @return {PIXI.Rectangle} Returns given parameter.
     */
    copyTo(rectangle) {
        rectangle.x = this.x;
        rectangle.y = this.y;
        rectangle.width = this.width;
        rectangle.height = this.height;
        return rectangle;
    }
    ;
    /**
     * Checks whether the x and y coordinates given are contained within this Rectangle
     *
     * @param {number} x - The X coordinate of the point to test
     * @param {number} y - The Y coordinate of the point to test
     * @return {boolean} Whether the x/y coordinates are within this Rectangle
     */
    contains(x, y) {
        if (this.width <= 0 || this.height <= 0) {
            return false;
        }
        if (x >= this.x && x < this.x + this.width) {
            if (y >= this.y && y < this.y + this.height) {
                return true;
            }
        }
        return false;
    }
    ;
    /**
     * Pads the rectangle making it grow in all directions.
     *
     * @param {number} paddingX - The horizontal padding amount.
     * @param {number} paddingY - The vertical padding amount.
     */
    pad(paddingX, paddingY) {
        paddingX = paddingX || 0;
        paddingY = paddingY || ((paddingY !== 0) ? paddingX : 0);
        this.x -= paddingX;
        this.y -= paddingY;
        this.width += paddingX * 2;
        this.height += paddingY * 2;
    }
    ;
    /**
     * Fits this rectangle around the passed one.
     *
     * @param {PIXI.Rectangle} rectangle - The rectangle to fit.
     */
    fit(rectangle) {
        var x1 = Math.max(this.x, rectangle.x);
        var x2 = Math.min(this.x + this.width, rectangle.x + rectangle.width);
        var y1 = Math.max(this.y, rectangle.y);
        var y2 = Math.min(this.y + this.height, rectangle.y + rectangle.height);
        this.x = x1;
        this.width = Math.max(x2 - x1, 0);
        this.y = y1;
        this.height = Math.max(y2 - y1, 0);
    }
    ;
    /**
     * Enlarges rectangle that way its corners lie on grid
     *
     * @param {number} [resolution=1] resolution
     * @param {number} [eps=0.001] precision
     */
    ceil(resolution, eps) {
        if (resolution === void 0) {
            resolution = 1;
        }
        if (eps === void 0) {
            eps = 0.001;
        }
        var x2 = Math.ceil((this.x + this.width - eps) * resolution) / resolution;
        var y2 = Math.ceil((this.y + this.height - eps) * resolution) / resolution;
        this.x = Math.floor((this.x + eps) * resolution) / resolution;
        this.y = Math.floor((this.y + eps) * resolution) / resolution;
        this.width = x2 - this.x;
        this.height = y2 - this.y;
    }
    ;
    /**
     * Enlarges this rectangle to include the passed rectangle.
     *
     * @param {PIXI.Rectangle} rectangle - The rectangle to include.
     */
    enlarge(rectangle) {
        var x1 = Math.min(this.x, rectangle.x);
        var x2 = Math.max(this.x + this.width, rectangle.x + rectangle.width);
        var y1 = Math.min(this.y, rectangle.y);
        var y2 = Math.max(this.y + this.height, rectangle.y + rectangle.height);
        this.x = x1;
        this.width = x2 - x1;
        this.y = y1;
        this.height = y2 - y1;
    }
    ;
}
exports.Rectangle = Rectangle;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/RenderTexture.js":
/*!*************************************************!*\
  !*** ./js-compile/raw-pixi-ts/RenderTexture.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Texture_1 = __webpack_require__(/*! ./Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const BaseRenderTexture_1 = __webpack_require__(/*! ./BaseRenderTexture */ "./js-compile/raw-pixi-ts/BaseRenderTexture.js");
class RenderTexture extends Texture_1.Texture {
    constructor(baseRenderTexture = null, frame = null) {
        super(baseRenderTexture, frame);
        var _legacyRenderer = null;
        if (!(baseRenderTexture instanceof BaseRenderTexture_1.BaseRenderTexture)) {
            /* eslint-disable prefer-rest-params, no-console */
            var width = arguments[1];
            var height = arguments[2];
            var scaleMode = arguments[3];
            var resolution = arguments[4];
            // we have an old render texture..
            console.warn(("Please use RenderTexture.create(" + width + ", " + height + ") instead of the ctor directly."));
            _legacyRenderer = arguments[0];
            /* eslint-enable prefer-rest-params, no-console */
            frame = null;
            baseRenderTexture = new BaseRenderTexture_1.BaseRenderTexture({
                width: width,
                height: height,
                scaleMode: scaleMode,
                resolution: resolution,
            });
        }
        this.legacyRenderer = _legacyRenderer;
        /**
         * This will let the renderer know if the texture is valid. If it's not then it cannot be rendered.
         *
         * @member {boolean}
         */
        this.valid = true;
        /**
         * FilterSystem temporary storage
         * @protected
         * @member {PIXI.Rectangle}
         */
        this.filterFrame = null;
        /**
        * The key for pooled texture of FilterSystem
        * @protected
        * @member {string}
        */
        this.filterPoolKey = null;
        this.updateUvs();
    }
    /**
    * Resizes the RenderTexture.
    *
    * @param {number} width - The width to resize to.
    * @param {number} height - The height to resize to.
    * @param {boolean} [resizeBaseTexture=true] - Should the baseTexture.width and height values be resized as well?
    */
    resize(width, height, resizeBaseTexture) {
        if (resizeBaseTexture === void 0) {
            resizeBaseTexture = true;
        }
        width = Math.ceil(width);
        height = Math.ceil(height);
        // TODO - could be not required..
        this.valid = (width > 0 && height > 0);
        this._frame.width = this.orig.width = width;
        this._frame.height = this.orig.height = height;
        if (resizeBaseTexture) {
            this.baseTexture.resize(width, height);
        }
        this.updateUvs();
    }
    ;
    /**
     * A short hand way of creating a render texture.
     *
     * @param {object} [options] - Options
     * @param {number} [options.width=100] - The width of the render texture
     * @param {number} [options.height=100] - The height of the render texture
     * @param {number} [options.scaleMode=PIXI.settings.SCALE_MODE] - See {@link PIXI.SCALE_MODES} for possible values
     * @param {number} [options.resolution=1] - The resolution / device pixel ratio of the texture being generated
     * @return {PIXI.RenderTexture} The new render texture
     */
    static create(options, height = null, scaleMode = null, resolution = null) {
        // fallback, old-style: create(width, height, scaleMode, resolution)
        if (typeof options === 'number') {
            /* eslint-disable prefer-rest-params */
            options = {
                width: options,
                height: arguments[1],
                scaleMode: arguments[2],
                resolution: arguments[3],
            };
            /* eslint-enable prefer-rest-params */
        }
        return new RenderTexture(new BaseRenderTexture_1.BaseRenderTexture(options));
    }
    ;
}
exports.RenderTexture = RenderTexture;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/RenderTextureSystem.js":
/*!*******************************************************!*\
  !*** ./js-compile/raw-pixi-ts/RenderTextureSystem.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const System_1 = __webpack_require__(/*! ./System */ "./js-compile/raw-pixi-ts/System.js");
const Rectangle_1 = __webpack_require__(/*! ./Rectangle */ "./js-compile/raw-pixi-ts/Rectangle.js");
class RenderTextureSystem extends System_1.System {
    constructor(renderer) {
        super(renderer);
        /**
         * The clear background color as rgba
         * @member {number[]}
         */
        this.clearColor = renderer._backgroundColorRgba;
        // TODO move this property somewhere else!
        /**
         * List of masks for the StencilSystem
         * @member {PIXI.Graphics[]}
         * @readonly
         */
        this.defaultMaskStack = [];
        // empty render texture?
        /**
         * Render texture
         * @member {PIXI.RenderTexture}
         * @readonly
         */
        this.current = null;
        /**
         * Source frame
         * @member {PIXI.Rectangle}
         * @readonly
         */
        this.sourceFrame = new Rectangle_1.Rectangle();
        /**
         * Destination frame
         * @member {PIXI.Rectangle}
         * @readonly
         */
        this.destinationFrame = new Rectangle_1.Rectangle();
    }
    /**
     * Bind the current render texture
     * @param {PIXI.RenderTexture} renderTexture
     * @param {PIXI.Rectangle} sourceFrame
     * @param {PIXI.Rectangle} destinationFrame
     */
    bind(renderTexture, sourceFrame = null, destinationFrame = null) {
        if (renderTexture === void 0) {
            renderTexture = null;
        }
        this.current = renderTexture;
        var renderer = this.renderer;
        var resolution;
        if (renderTexture) {
            var baseTexture = renderTexture.baseTexture;
            resolution = baseTexture.resolution;
            if (!destinationFrame) {
                RenderTextureSystem.tempRect.width = baseTexture.realWidth;
                RenderTextureSystem.tempRect.height = baseTexture.realHeight;
                destinationFrame = RenderTextureSystem.tempRect;
            }
            if (!sourceFrame) {
                sourceFrame = destinationFrame;
            }
            this.renderer.framebuffer.bind(baseTexture.framebuffer, destinationFrame);
            this.renderer.projection.update(destinationFrame, sourceFrame, resolution, false);
            this.renderer.stencil.setMaskStack(baseTexture.stencilMaskStack);
        }
        else {
            resolution = this.renderer.resolution;
            // TODO these validation checks happen deeper down..
            // thing they can be avoided..
            if (!destinationFrame) {
                RenderTextureSystem.tempRect.width = renderer.width;
                RenderTextureSystem.tempRect.height = renderer.height;
                destinationFrame = RenderTextureSystem.tempRect;
            }
            if (!sourceFrame) {
                sourceFrame = destinationFrame;
            }
            renderer.framebuffer.bind(null, destinationFrame);
            // TODO store this..
            this.renderer.projection.update(destinationFrame, sourceFrame, resolution, true);
            this.renderer.stencil.setMaskStack(this.defaultMaskStack);
        }
        this.sourceFrame.copyFrom(sourceFrame);
        this.destinationFrame.x = destinationFrame.x / resolution;
        this.destinationFrame.y = destinationFrame.y / resolution;
        this.destinationFrame.width = destinationFrame.width / resolution;
        this.destinationFrame.height = destinationFrame.height / resolution;
    }
    ;
    /**
     * Erases the render texture and fills the drawing area with a colour
     *
     * @param {number[]} [clearColor] - The color as rgba, default to use the renderer backgroundColor
     * @return {PIXI.Renderer} Returns itself.
     */
    clear(clearColor = null) {
        if (this.current) {
            clearColor = clearColor || this.current.baseTexture.clearColor;
        }
        else {
            clearColor = clearColor || this.clearColor;
        }
        this.renderer.framebuffer.clear(clearColor[0], clearColor[1], clearColor[2], clearColor[3]);
    }
    ;
    resize() {
        // resize the root only!
        this.bind(null);
    }
    ;
    /**
     * Resets renderTexture state
     */
    reset() {
        this.bind(null);
    }
    ;
}
RenderTextureSystem.tempRect = new Rectangle_1.Rectangle();
exports.RenderTextureSystem = RenderTextureSystem;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/Renderer.js":
/*!********************************************!*\
  !*** ./js-compile/raw-pixi-ts/Renderer.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const AbstractRenderer_1 = __webpack_require__(/*! ./AbstractRenderer */ "./js-compile/raw-pixi-ts/AbstractRenderer.js");
const UniformGroup_1 = __webpack_require__(/*! ./UniformGroup */ "./js-compile/raw-pixi-ts/UniformGroup.js");
const Matrix_1 = __webpack_require__(/*! ./Matrix */ "./js-compile/raw-pixi-ts/Matrix.js");
const Event_1 = __webpack_require__(/*! ./Event */ "./js-compile/raw-pixi-ts/Event.js");
const BatchRenderer_1 = __webpack_require__(/*! ./BatchRenderer */ "./js-compile/raw-pixi-ts/BatchRenderer.js");
const BatchSystem_1 = __webpack_require__(/*! ./BatchSystem */ "./js-compile/raw-pixi-ts/BatchSystem.js");
const RenderTextureSystem_1 = __webpack_require__(/*! ./RenderTextureSystem */ "./js-compile/raw-pixi-ts/RenderTextureSystem.js");
const FilterSystem_1 = __webpack_require__(/*! ./FilterSystem */ "./js-compile/raw-pixi-ts/FilterSystem.js");
const TextureGCSystem_1 = __webpack_require__(/*! ./TextureGCSystem */ "./js-compile/raw-pixi-ts/TextureGCSystem.js");
const ProjectionSystem_1 = __webpack_require__(/*! ./ProjectionSystem */ "./js-compile/raw-pixi-ts/ProjectionSystem.js");
const StencilSystem_1 = __webpack_require__(/*! ./StencilSystem */ "./js-compile/raw-pixi-ts/StencilSystem.js");
const FramebufferSystem_1 = __webpack_require__(/*! ./FramebufferSystem */ "./js-compile/raw-pixi-ts/FramebufferSystem.js");
const GeometrySystem_1 = __webpack_require__(/*! ./GeometrySystem */ "./js-compile/raw-pixi-ts/GeometrySystem.js");
const TextureSystem_1 = __webpack_require__(/*! ./TextureSystem */ "./js-compile/raw-pixi-ts/TextureSystem.js");
const ShaderSystem_1 = __webpack_require__(/*! ./ShaderSystem */ "./js-compile/raw-pixi-ts/ShaderSystem.js");
const StateSystem_1 = __webpack_require__(/*! ./StateSystem */ "./js-compile/raw-pixi-ts/StateSystem.js");
const ContextSystem_1 = __webpack_require__(/*! ./ContextSystem */ "./js-compile/raw-pixi-ts/ContextSystem.js");
const MaskSystem_1 = __webpack_require__(/*! ./MaskSystem */ "./js-compile/raw-pixi-ts/MaskSystem.js");
const DisplaySettings_1 = __webpack_require__(/*! ./DisplaySettings */ "./js-compile/raw-pixi-ts/DisplaySettings.js");
const TilingSpriteRenderer_1 = __webpack_require__(/*! ./TilingSpriteRenderer */ "./js-compile/raw-pixi-ts/TilingSpriteRenderer.js");
const AccessibilityManager_1 = __webpack_require__(/*! ./AccessibilityManager */ "./js-compile/raw-pixi-ts/AccessibilityManager.js");
const Extract_1 = __webpack_require__(/*! ./Extract */ "./js-compile/raw-pixi-ts/Extract.js");
const InteractionManager_1 = __webpack_require__(/*! ./InteractionManager */ "./js-compile/raw-pixi-ts/InteractionManager.js");
const ParticleRenderer_1 = __webpack_require__(/*! ./ParticleRenderer */ "./js-compile/raw-pixi-ts/ParticleRenderer.js");
const Prepare_1 = __webpack_require__(/*! ./Prepare */ "./js-compile/raw-pixi-ts/Prepare.js");
const Runner_1 = __webpack_require__(/*! ./Runner */ "./js-compile/raw-pixi-ts/Runner.js");
class Renderer extends AbstractRenderer_1.AbstractRenderer {
    constructor(options) {
        super('WebGL', options);
        this.plugins = {};
        this.type = DisplaySettings_1.DisplaySettings.RENDERER_TYPE.WEBGL;
        this.gl = null;
        this.CONTEXT_UID = 0;
        this.runners = {
            destroy: new Runner_1.Runner('destroy'),
            contextChange: new Runner_1.Runner('contextChange', 1),
            reset: new Runner_1.Runner('reset'),
            update: new Runner_1.Runner('update'),
            postrender: new Runner_1.Runner('postrender'),
            prerender: new Runner_1.Runner('prerender'),
            resize: new Runner_1.Runner('resize', 2),
        };
        this.globalUniforms = new UniformGroup_1.UniformGroup({
            projectionMatrix: new Matrix_1.Matrix(),
        }, true);
        this.addSystem(MaskSystem_1.MaskSystem, 'mask')
            .addSystem(ContextSystem_1.ContextSystem, 'context')
            .addSystem(StateSystem_1.StateSystem, 'state')
            .addSystem(ShaderSystem_1.ShaderSystem, 'shader')
            .addSystem(TextureSystem_1.TextureSystem, 'texture')
            .addSystem(GeometrySystem_1.GeometrySystem, 'geometry')
            .addSystem(FramebufferSystem_1.FramebufferSystem, 'framebuffer')
            .addSystem(StencilSystem_1.StencilSystem, 'stencil')
            .addSystem(ProjectionSystem_1.ProjectionSystem, 'projection')
            .addSystem(TextureGCSystem_1.TextureGCSystem, 'textureGC')
            .addSystem(FilterSystem_1.FilterSystem, 'filter')
            .addSystem(RenderTextureSystem_1.RenderTextureSystem, 'renderTexture')
            .addSystem(BatchSystem_1.BatchSystem, 'batch');
        this.initPlugins(Renderer.__plugins);
        if (options.context) {
            this.context.initFromContext(options.context);
        }
        else {
            this.context.initFromOptions({
                alpha: this.transparent,
                antialias: options.antialias,
                premultipliedAlpha: this.transparent,
                stencil: true,
                preserveDrawingBuffer: options.preserveDrawingBuffer,
                powerPreference: this.options.powerPreference,
            });
        }
        this.renderingToScreen = true;
        //     sayHello(this.context.webGLVersion === 2 ? 'WebGL 2' : 'WebGL 1');
        this.resize(this.options.width, this.options.height);
    }
    static registerPlugin(pluginName, ctor) {
        Renderer.__plugins = Renderer.__plugins || {};
        Renderer.__plugins[pluginName] = ctor;
    }
    ;
    initPlugins(staticMap) {
        for (var o in staticMap) {
            this.plugins[o] = new (staticMap[o])(this);
        }
    }
    ;
    addSystem(ClassRef, name) {
        if (!name) {
            name = ClassRef.name;
        }
        var system = new ClassRef(this);
        if (this[name]) {
            throw new Error(("Whoops! The name \"" + name + "\" is already in use"));
        }
        this[name] = system;
        for (var i in this.runners) {
            this.runners[i].add(system);
        }
        /**
         * Fired after rendering finishes.
         *
         * @event PIXI.Renderer#postrender
         */
        /**
         * Fired before rendering starts.
         *
         * @event PIXI.Renderer#prerender
         */
        /**
         * Fired when the WebGL context is set.
         *
         * @event PIXI.Renderer#context
         * @param {WebGLRenderingContext} gl - WebGL context.
         */
        return this;
    }
    ;
    // protected handleContextChange = (event:Event)=>
    // {
    // 	this.plugins.particle.contextChange(this.context.gl)
    // 	this.framebuffer.contextChange(this.context.gl)		
    // 	this.shader.contextChange(this.context.gl)
    // 	this.geometry.contextChange();
    // 	this.state.contextChange(this.context.gl)
    // 	this.texture.contextChange();
    // 	this.framebuffer.contextChange(this.context.gl)
    // 	this.stencil.contextChange(this.context.gl)
    // 	this.projection.contextChange(this.context.gl)
    // 	this.textureGC.contextChange(this.context.gl)
    // 	this.filter.contextChange(this.context.gl)
    // 	this.renderTexture.contextChange(this.context.gl)
    // 	this.batch.contextChange(this.context.gl)
    // 	this.mask.contextChange(this.context.gl);
    // 	this.plugins.batch.contextChange();		
    // 	this.plugins.tilingSprite.contextChange(this.context.gl)		
    // }
    render(displayObject, renderTexture = null, clear = true, transform = null, skipUpdateTransform = false) {
        this.renderingToScreen = !renderTexture;
        this.runners.prerender.run();
        // this.emit('prerender');
        this.dispatchEvent(Event_1.Event.getEvent("prerender"));
        if (this.context.isLost) {
            return;
        }
        if (!renderTexture) {
            this._lastObjectRendered = displayObject;
        }
        if (!skipUpdateTransform) {
            let cacheParent = displayObject.parent;
            displayObject.parent = this._tempDisplayObjectParent;
            displayObject.updateTransform();
            displayObject.parent = cacheParent;
        }
        this.renderTexture.bind(renderTexture);
        this.batch.currentRenderer.start();
        if (clear !== undefined ? clear : this.clearBeforeRender) {
            this.renderTexture.clear();
        }
        displayObject.render(this);
        this.batch.currentRenderer.flush();
        if (renderTexture) {
            renderTexture.baseTexture.update();
        }
        this.runners.postrender.run();
        this.dispatchEvent(Event_1.Event.getEvent("postrender"));
    }
    ;
    resize(screenWidth, screenHeight) {
        super.resize(screenWidth, screenHeight);
        this.runners.resize.run(screenWidth, screenHeight);
        // this.dispatchEvent(Event.getEvent("resize"));
    }
    ;
    reset() {
        this.runners.reset.run();
        // this.dispatchEvent(Event.getEvent("reset"));
        return this;
    }
    ;
    clear() {
        this.framebuffer.bind();
        this.framebuffer.clear();
    }
    ;
    destroy(options = null) {
        this.runners.destroy.run();
        // this.dispatchEvent(Event.getEvent("destroy"));
        super.destroy(options);
        this.gl = null;
    }
    ;
}
Renderer.__plugins = {};
exports.Renderer = Renderer;
class RendererPlugins {
    constructor(renderer) {
        this.particle = new ParticleRenderer_1.ParticleRenderer(renderer);
        this.tilingSprite = new TilingSpriteRenderer_1.TilingSpriteRenderer(renderer);
        this.accessibility = new AccessibilityManager_1.AccessibilityManager(renderer);
        this.extract = new Extract_1.Extract(renderer);
        this.interaction = new InteractionManager_1.InteractionManager(renderer);
        this.prepare = new Prepare_1.Prepare(renderer);
        this.batch = new BatchRenderer_1.BatchRenderer(renderer);
        // Loader$2.registerPlugin(BitmapFontLoader);
        // Loader$2.registerPlugin(SpritesheetLoader);	
    }
}


/***/ }),

/***/ "./js-compile/raw-pixi-ts/Resource.js":
/*!********************************************!*\
  !*** ./js-compile/raw-pixi-ts/Resource.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Event_1 = __webpack_require__(/*! ./Event */ "./js-compile/raw-pixi-ts/Event.js");
const EventDispatcher_1 = __webpack_require__(/*! ./EventDispatcher */ "./js-compile/raw-pixi-ts/EventDispatcher.js");
const Runner_1 = __webpack_require__(/*! ./Runner */ "./js-compile/raw-pixi-ts/Runner.js");
class Resource extends EventDispatcher_1.EventDispatcher {
    constructor(width = 0, height = 0) {
        super();
        /**
         * Internal width of the resource
         * @member {number}
         * @protected
         */
        this._width = width;
        /**
         * Internal height of the resource
         * @member {number}
         * @protected
         */
        this._height = height;
        /**
         * If resource has been destroyed
         * @member {boolean}
         * @readonly
         * @default false
         */
        this.destroyed = false;
        /**
         * `true` if resource is created by BaseTexture
         * useful for doing cleanup with BaseTexture destroy
         * and not cleaning up resources that were created
         * externally.
         * @member {boolean}
         * @protected
         */
        this.internal = false;
        /**
         * Mini-runner for handling resize events
         *
         * @member {Runner}
         * @private
         */
        // this.onResize = Event.getEvent("setRealSize")
        // Runner('setRealSize', 2);
        /**
         * Mini-runner for handling update events
         *
         * @member {Runner}
         * @private
         */
        // this.onUpdate = Event.getEvent("update")
        // new Runner('update');
        this.onResize = new Runner_1.Runner('setRealSize', 2);
        /**
         * Mini-runner for handling update events
         *
         * @member {Runner}
         * @private
         */
        this.onUpdate = new Runner_1.Runner('update');
    }
    /**
     * Bind to a parent BaseTexture
     *
     * @param {PIXI.BaseTexture} baseTexture - Parent texture
     */
    bind(baseTexture) {
        this.onResize.add(baseTexture);
        this.onUpdate.add(baseTexture);
        // Call a resize immediate if we already
        // have the width and height of the resource
        if (this._width || this._height) {
            this.onResize.run(this._width, this._height);
        }
        // this.onResize.add(baseTexture);
        // this.onUpdate.add(baseTexture);
        // Call a resize immediate if we already
        // have the width and height of the resource
        // if (this._width || this._height)
        // {
        // 	this.dispatchEvent(Event.getEvent("setRealSize"))
        //     // this.onResize.run(this._width, this._height);
        // }
    }
    ;
    /**
     * Unbind to a parent BaseTexture
     *
     * @param {PIXI.BaseTexture} baseTexture - Parent texture
     */
    unbind(baseTexture) {
        this.onResize.remove(baseTexture);
        this.onUpdate.remove(baseTexture);
        // this.onResize.remove(baseTexture);
        // this.onUpdate.remove(baseTexture);
    }
    ;
    /**
     * Trigger a resize event
     */
    resize(width, height) {
        if (width !== this._width || height !== this._height) {
            this._width = width;
            this._height = height;
            this.onResize.run(width, height);
            this.dispatchEvent(Event_1.Event.getEvent("setRealSize"));
            // Event.getEvent("setRealSize")
            // this.onResize.run(width, height);
        }
    }
    ;
    /**
     * Has been validated
     * @readonly
     * @member {boolean}
     */
    get valid() {
        return !!this._width && !!this._height;
    }
    ;
    /**
     * Has been updated trigger event
     */
    update(deltaTime) {
        if (!this.destroyed) {
            this.dispatchEvent(Event_1.Event.getEvent("update"));
        }
    }
    ;
    /**
     * This can be overridden to start preloading a resource
     * or do any other prepare step.
     * @protected
     * @return {Promise<void>} Handle the validate event
     */
    load() {
        return Promise.resolve();
    }
    ;
    /**
     * The width of the resource.
     *
     * @member {number}
     * @readonly
     */
    get width() {
        return this._width;
    }
    ;
    /**
     * The height of the resource.
     *
     * @member {number}
     * @readonly
     */
    get height() {
        return this._height;
    }
    ;
    /**
     * Uploads the texture or returns false if it cant for some reason. Override this.
     *
     * @param {PIXI.Renderer} renderer - yeah, renderer!
     * @param {PIXI.BaseTexture} baseTexture - the texture
     * @param {PIXI.GLTexture} glTexture - texture instance for this webgl context
     * @returns {boolean} true is success
     */
    upload(renderer, baseTexture, glTexture, source) {
        return false;
    }
    ;
    /**
     * Set the style, optional to override
     *
     * @param {PIXI.Renderer} renderer - yeah, renderer!
     * @param {PIXI.BaseTexture} baseTexture - the texture
     * @param {PIXI.GLTexture} glTexture - texture instance for this webgl context
     * @returns {boolean} `true` is success
     */
    style(renderer, baseTexture, glTexture) {
        return false;
    }
    ;
    /**
     * Clean up anything, this happens when destroying is ready.
     *
     * @protected
     */
    dispose() {
        // override
    }
    ;
    /**
     * Call when destroying resource, unbind any BaseTexture object
     * before calling this method, as reference counts are maintained
     * internally.
     */
    destroy() {
        if (!this.destroyed) {
            this.onResize.removeAll();
            this.onResize = null;
            this.onUpdate.removeAll();
            this.onUpdate = null;
            this.destroyed = true;
            this.dispose();
        }
    }
    ;
}
exports.Resource = Resource;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/ResourceLoader.js":
/*!**************************************************!*\
  !*** ./js-compile/raw-pixi-ts/ResourceLoader.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const EventDispatcher_1 = __webpack_require__(/*! ./EventDispatcher */ "./js-compile/raw-pixi-ts/EventDispatcher.js");
const Event_1 = __webpack_require__(/*! ./Event */ "./js-compile/raw-pixi-ts/Event.js");
const ProgressEvent_1 = __webpack_require__(/*! ./ProgressEvent */ "./js-compile/raw-pixi-ts/ProgressEvent.js");
const Logger_1 = __webpack_require__(/*! ./Logger */ "./js-compile/raw-pixi-ts/Logger.js");
class ResourceLoader extends EventDispatcher_1.EventDispatcher {
    constructor(request) {
        super();
        this.complete = (event) => {
            Logger_1.trace("complete");
            let promise = window.createImageBitmap(this._imageElement, 0, 0, this._imageElement.width, this._imageElement.height);
            promise.then(this.onImageBitmapCreated).catch();
        };
        this.onImageBitmapCreated = (image) => {
            Logger_1.trace("onImageBitmapCreated");
            this._imageData = image;
            this._clearEvents();
            this._finish();
        };
        this._onTimeout = () => {
            this.abort('Load timed out.');
        };
        this._onProgress = (event) => {
            if (event && event.lengthComputable) {
                let pe = ProgressEvent_1.ProgressEvent.getProgressEvent(ProgressEvent_1.ProgressEvent.PROGRESS);
                pe.bytesLoaded = event.loaded;
                pe.bytesTotal = event.total;
                pe.percent = event.loaded / event.total;
                this.dispatchEvent(pe);
            }
        };
        this._onError = (event) => {
            this.abort('Failed to load element using: ' + event.target.nodeName);
        };
        this._request = request;
        this._flags = 0;
        this._setFlag(ResourceLoader.STATUS_FLAGS.DATA_URL, this._request.url.indexOf('data:') === 0);
        this.extension = this._getExtension();
        this.data = null;
        this.crossOrigin = request.crossOrigin === true ? 'anonymous' : "";
        this.timeout = request.timeout || 0;
        this.loadType = this._determineLoadType();
        this.error = null;
        this.xhr = null;
        this.type = ResourceLoader.TYPE.UNKNOWN;
        this.progressChunk = 0;
        this._elementTimer = 0;
        this.metadata = request.requestMetaData;
        this.xhrType = null;
        // this.children = [];
        // this._dequeue = ResourceLoader._noop;
        // this._onLoadBinding = null;
    }
    load() {
        if (this.isLoading) {
            return;
        }
        if (this.isComplete) {
            this.dispatchEvent(Event_1.Event.getEvent(Event_1.Event.COMPLETE));
            return;
        }
        this._setFlag(ResourceLoader.STATUS_FLAGS.LOADING, true);
        if (!this.crossOrigin) {
            this.crossOrigin = this._determineCrossOrigin(this._request.url);
        }
        switch (this.loadType) {
            case ResourceLoader.LOAD_TYPE.IMAGE:
                this.type = ResourceLoader.TYPE.IMAGE;
                this._loadElement('image');
                break;
            case ResourceLoader.LOAD_TYPE.AUDIO:
                this.type = ResourceLoader.TYPE.AUDIO;
                // this._loadSourceElement('audio');
                break;
            case ResourceLoader.LOAD_TYPE.VIDEO:
                this.type = ResourceLoader.TYPE.VIDEO;
                // this._loadSourceElement('video');
                break;
            case ResourceLoader.LOAD_TYPE.XHR:
            default:
                if (ResourceLoader.useXdr && this.crossOrigin) {
                    this._loadXdr();
                }
                else {
                    this._loadXhr();
                }
                break;
        }
        // _loadSourceElement
        // _loadXdr
        // _loadXhr
    }
    ;
    /**
     * Loads this resources using an element that has multiple sources,
     * like an HTMLAudioElement or HTMLVideoElement.
     *
     * @private
     * @param {string} type - The type of element to use.
     */
    // protected _loadSourceElement(type):void
    // {
    //     if (this.metadata.loadElement) 
    //     {
    //         this.data = this.metadata.loadElement;
    //     } else if (type === 'audio' && typeof window['Audio'] !== 'undefined') {
    //         this.data = new Audio();
    //     } else {
    //         this.data = document.createElement(type);
    //     }
    //     if (this.data === null) {
    //         this.abort('Unsupported element: ' + type);
    //         return;
    //     }
    //     if (this.crossOrigin) {
    //         this.data.crossOrigin = this.crossOrigin;
    //     }
    //     if (!this.metadata.skipSource) {
    //         // support for CocoonJS Canvas+ runtime, lacks document.createElement('source')
    //         if (navigator['isCocoonJS']) {
    //             this.data.src = Array.isArray(this._request.url) ? this._request.url[0] : this._request.url;
    //         } else if (Array.isArray(this._request.url)) {
    //             var mimeTypes = this.metadata.mimeType;
    //             for (var i = 0; i < this._request.url.length; ++i) {
    //                 this.data.appendChild(this._createSource(type, this._request.url[i], Array.isArray(mimeTypes) ? mimeTypes[i] : mimeTypes));
    //             }
    //         } else {
    //             var _mimeTypes = this.metadata.mimeType;
    //             this.data.appendChild(this._createSource(type, this._request.url, Array.isArray(_mimeTypes) ? _mimeTypes[0] : _mimeTypes));
    //         }
    //     }
    //     this.data.addEventListener('error', this._boundOnError, false);
    //     this.data.addEventListener('load', this._boundComplete, false);
    //     this.data.addEventListener('progress', this._boundOnProgress, false);
    //     this.data.addEventListener('canplaythrough', this._boundComplete, false);
    //     this.data.load();
    //     if (this.timeout) {
    //         this._elementTimer = setTimeout(this._boundOnTimeout, this.timeout);
    //     }
    // };
    _clearEvents() {
        clearTimeout(this._elementTimer);
        if (this._imageElement && this._imageElement.removeEventListener) {
            this._imageElement.removeEventListener('error', this._onError);
            this._imageElement.removeEventListener('load', this.complete);
            this._imageElement.removeEventListener('progress', this._onProgress);
            this._imageElement.removeEventListener('canplaythrough', this.complete);
        }
        if (this.xhr) {
            // if (this.xhr.removeEventListener) {
            //     this.xhr.removeEventListener('error', this._boundXhrOnError, false);
            //     this.xhr.removeEventListener('timeout', this._boundXhrOnTimeout, false);
            //     this.xhr.removeEventListener('abort', this._boundXhrOnAbort, false);
            //     this.xhr.removeEventListener('progress', this._boundOnProgress, false);
            //     this.xhr.removeEventListener('load', this._boundXhrOnLoad, false);
            // } else {
            //     this.xhr.onerror = null;
            //     this.xhr.ontimeout = null;
            //     this.xhr.onprogress = null;
            //     this.xhr.onload = null;
            // }
        }
    }
    ;
    _loadElement(type) {
        Logger_1.trace("_loadElement " + type);
        this._imageElement = document.createElement("img");
        if (this.crossOrigin) {
            this._imageElement.crossOrigin = this.crossOrigin;
        }
        this._imageElement.src = this._request.url;
        this._imageElement.addEventListener('error', this._onError);
        this._imageElement.addEventListener('load', this.complete);
        this._imageElement.addEventListener('progress', this._onProgress);
        // if (this.timeout > 0) 
        // {
        //     this._elementTimer = setTimeout(this._onTimeout, this.timeout);
        // }
    }
    ;
    get imageData() {
        return this._imageData;
    }
    abort(message) {
        if (this.error) {
            return;
        }
        this.error = new Error(message);
        this._clearEvents();
        if (this.xhr) {
            this.xhr.abort();
        }
        else if (this.xdr) {
            this.xdr.abort();
        }
        else if (this.data) {
            if (this.data.src) {
                this.data.src = ResourceLoader.EMPTY_GIF;
            }
            else {
                while (this.data.firstChild) {
                    this.data.removeChild(this.data.firstChild);
                }
            }
        }
        this._finish();
    }
    ;
    _finish() {
        if (this.isComplete) {
            return;
        }
        this._setFlag(ResourceLoader.STATUS_FLAGS.COMPLETE, true);
        this._setFlag(ResourceLoader.STATUS_FLAGS.LOADING, false);
        this.dispatchEvent(Event_1.Event.getEvent(Event_1.Event.COMPLETE));
    }
    ;
    _determineCrossOrigin(url, loc = null) {
        if (url.indexOf('data:') === 0) {
            return '';
        }
        if (window['origin'] !== window.location.origin) {
            return 'anonymous';
        }
        loc = loc || window.location;
        if (!ResourceLoader.tempAnchor) {
            ResourceLoader.tempAnchor = document.createElement('a');
        }
        ResourceLoader.tempAnchor.href = url;
        let uri = ResourceLoader.parseUri(ResourceLoader.tempAnchor.href, true);
        let samePort = !uri.port && loc.port === '' || uri.port === loc.port;
        let protocol = uri.protocol ? uri.protocol + ':' : '';
        if (uri.host !== loc.hostname || !samePort || protocol !== loc.protocol) {
            return 'anonymous';
        }
        return '';
    }
    ;
    static parseUri(str, strict = true) {
        let o = {
            key: ['source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'],
            q: {
                name: 'queryKey',
                parser: /(?:^|&)([^&=]*)=?([^&]*)/g
            },
            parser: {
                strict: /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/,
                loose: /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/
            }
        };
        let m = o.parser[strict ? 'strict' : 'loose'].exec(str);
        let uri = new URIData();
        uri.source = m["source"] || '';
        uri.protocol = m["protocol"] || '';
        uri.authority = m["authority"] || '';
        uri.userInfo = m["userInfo"] || '';
        uri.user = m["user"] || '';
        uri.password = m["password"] || '';
        uri.host = m["host"] || '';
        uri.port = m["port"] || '';
        uri.relative = m["relative"] || '';
        uri.path = m["path"] || '';
        uri.directory = m["directory"] || '';
        uri.file = m["file"] || '';
        uri.query = m["query"] || '';
        uri.anchor = m["anchor"] || '';
        uri[o.q.name] = {};
        uri[o.key[12]].replace(o.q.parser, function ($0, $1, $2) {
            if ($1) {
                uri[o.q.name][$1] = $2;
            }
        });
        return uri;
    }
    ;
    _determineLoadType() {
        return ResourceLoader._loadTypeMap[this.extension] || ResourceLoader.LOAD_TYPE.XHR;
    }
    ;
    _getExtension() {
        let url = this._request.url;
        let ext = '';
        if (this.isDataUrl) {
            let slashIndex = url.indexOf('/');
            ext = url.substring(slashIndex + 1, url.indexOf(';', slashIndex));
        }
        else {
            let queryStart = url.indexOf('?');
            let hashStart = url.indexOf('#');
            let index = Math.min(queryStart > -1 ? queryStart : url.length, hashStart > -1 ? hashStart : url.length);
            url = url.substring(0, index);
            ext = url.substring(url.lastIndexOf('.') + 1);
        }
        return ext.toLowerCase();
    }
    ;
    _hasFlag(flag) {
        return (this._flags & flag) !== 0;
    }
    ;
    _setFlag(flag, value) {
        this._flags = value ? this._flags | flag : this._flags & ~flag;
    }
    ;
    static setExtMap(map, extname, val) {
        if (extname && extname.indexOf('.') === 0) {
            extname = extname.substring(1);
        }
        if (!extname) {
            return;
        }
        map[extname] = val;
    }
    static setExtensionLoadType(extname, loadType) {
        ResourceLoader.setExtMap(ResourceLoader._loadTypeMap, extname, loadType);
    }
    ;
    static setExtensionXhrType(extname, xhrType) {
        ResourceLoader.setExtMap(ResourceLoader._xhrTypeMap, extname, xhrType);
    }
    ;
    /**
     * Quick helper to get string xhr type.
     *
     * @ignore
     * @param {XMLHttpRequest|XDomainRequest} xhr - The request to check.
     * @return {string} The type.
     */
    static reqType(xhr) {
        return xhr.toString().replace('object ', '');
    }
    /**
     * Loads this resources using an XMLHttpRequest.
     *
     * @private
     */
    _loadXhr() {
        // // if unset, determine the value
        // if (typeof this.xhrType !== 'string') {
        //     this.xhrType = this._determineXhrType();
        // }
        // var xhr = this.xhr = new XMLHttpRequest();
        // // set the request type and url
        // xhr.open('GET', this._request.url, true);
        // xhr.timeout = this.timeout;
        // // load json as text and parse it ourselves. We do this because some browsers
        // // *cough* safari *cough* can't deal with it.
        // if (this.xhrType === ResourceLoader.XHR_RESPONSE_TYPE.JSON || this.xhrType === ResourceLoader.XHR_RESPONSE_TYPE.DOCUMENT) {
        //     xhr.responseType = <any>ResourceLoader.XHR_RESPONSE_TYPE.TEXT;
        // } else {
        //     xhr.responseType = this.xhrType;
        // }
        // xhr.addEventListener('error', this._boundXhrOnError, false);
        // xhr.addEventListener('timeout', this._boundXhrOnTimeout, false);
        // xhr.addEventListener('abort', this._boundXhrOnAbort, false);
        // xhr.addEventListener('progress', this._boundOnProgress, false);
        // xhr.addEventListener('load', this._boundXhrOnLoad, false);
        // xhr.send();
    }
    ;
    /**
     * Loads this resources using an XDomainRequest. This is here because we need to support IE9 (gross).
     *
     * @private
     */
    _loadXdr() {
        // // if unset, determine the value
        // if (typeof this.xhrType !== 'string') {
        //     this.xhrType = this._determineXhrType();
        // }
        // var xdr = this.xhr = new window['XDomainRequest'](); // eslint-disable-line no-undef
        // // XDomainRequest has a few quirks. Occasionally it will abort requests
        // // A way to avoid this is to make sure ALL callbacks are set even if not used
        // // More info here: http://stackoverflow.com/questions/15786966/xdomainrequest-aborts-post-on-ie-9
        // xdr.timeout = this.timeout || 5000; // XDR needs a timeout value or it breaks in IE9
        // xdr.onerror = this._boundXhrOnError;
        // xdr.ontimeout = this._boundXhrOnTimeout;
        // xdr.onprogress = this._boundOnProgress;
        // xdr.onload = this._boundXhrOnLoad;
        // xdr.open('GET', this._request.url, true);
        // // Note: The xdr.send() call is wrapped in a timeout to prevent an
        // // issue with the interface where some requests are lost if multiple
        // // XDomainRequests are being sent at the same time.
        // // Some info here: https://github.com/photonstorm/phaser/issues/1248
        // setTimeout(function () {
        //     return xdr.send();
        // }, 1);
    }
    ;
    /**
     * Creates a source used in loading via an element.
     *
     * @private
     * @param {string} type - The element type (video or audio).
     * @param {string} url - The source URL to load from.
     * @param {string} [mime] - The mime type of the video
     * @return {HTMLSourceElement} The source element.
     */
    _createSource(type, url, mime) {
        // if (!mime) {
        //     mime = type + '/' + this._getExtension(url);
        // }
        // var source = document.createElement('source');
        // source.src = url;
        // source.type = mime;
        // return source;
    }
    ;
    /**
     * Called if an error event fires for xhr/xdr.
     *
     * @private
     */
    _xhrOnError() {
        var xhr = this.xhr;
        this.abort(ResourceLoader.reqType(xhr) + ' Request failed. Status: ' + xhr.status + ', text: "' + xhr.statusText + '"');
    }
    ;
    /**
     * Called if an error event fires for xhr/xdr.
     *
     * @private
     */
    _xhrOnTimeout() {
        var xhr = this.xhr;
        this.abort(ResourceLoader.reqType(xhr) + ' Request timed out.');
    }
    ;
    /**
     * Called if an abort event fires for xhr/xdr.
     *
     * @private
     */
    _xhrOnAbort() {
        var xhr = this.xhr;
        this.abort(ResourceLoader.reqType(xhr) + ' Request was aborted by the user.');
    }
    ;
    /**
     * Called when data successfully loads from an xhr/xdr request.
     *
     * @private
     * @param {XMLHttpRequestLoadEvent|Event} event - Load event
     */
    _xhrOnLoad() {
        // var xhr = this.xhr;
        // var text = '';
        // var status = typeof xhr.status === 'undefined' ? ResourceLoader.STATUS_OK : xhr.status; // XDR has no `.status`, assume 200.
        // // responseText is accessible only if responseType is '' or 'text' and on older browsers
        // if (xhr.responseType === '' || xhr.responseType === 'text' || typeof xhr.responseType === 'undefined') {
        //     text = xhr.responseText;
        // }
        // // status can be 0 when using the `file://` protocol so we also check if a response is set.
        // // If it has a response, we assume 200; otherwise a 0 status code with no contents is an aborted request.
        // if (status === ResourceLoader.STATUS_NONE && (text.length > 0 || xhr.responseType === ResourceLoader.XHR_RESPONSE_TYPE.BUFFER)) {
        //     status = ResourceLoader.STATUS_OK;
        // }
        // // handle IE9 bug: http://stackoverflow.com/questions/10046972/msie-returns-status-code-of-1223-for-ajax-request
        // else if (status === ResourceLoader.STATUS_IE_BUG_EMPTY) {
        //         status = ResourceLoader.STATUS_EMPTY;
        //     }
        // var statusType = status / 100 | 0;
        // if (statusType === ResourceLoader.STATUS_TYPE_OK) {
        //     // if text, just return it
        //     if (this.xhrType === ResourceLoader.XHR_RESPONSE_TYPE.TEXT) {
        //         this.data = text;
        //         this.type = ResourceLoader.TYPE.TEXT;
        //     }
        //     // if json, parse into json object
        //     else if (this.xhrType === ResourceLoader.XHR_RESPONSE_TYPE.JSON) {
        //             try {
        //                 this.data = JSON.parse(text);
        //                 this.type = ResourceLoader.TYPE.JSON;
        //             } catch (e) {
        //                 this.abort('Error trying to parse loaded json: ' + e);
        //                 return;
        //             }
        //         }
        //         // if xml, parse into an xml document or div element
        //         else if (this.xhrType === ResourceLoader.XHR_RESPONSE_TYPE.DOCUMENT) {
        //                 try {
        //                     if (window['DOMParser']) {
        //                         var domparser = new DOMParser();
        //                         this.data = domparser.parseFromString(text, 'text/xml');
        //                     } else {
        //                         var div = document.createElement('div');
        //                         div.innerHTML = text;
        //                         this.data = div;
        //                     }
        //                     this.type = ResourceLoader.TYPE.XML;
        //                 } catch (e) {
        //                     this.abort('Error trying to parse loaded xml: ' + e);
        //                     return;
        //                 }
        //             }
        //             // other types just return the response
        //             else {
        //                     this.data = xhr.response || text;
        //                 }
        // } else {
        //     this.abort('[' + xhr.status + '] ' + xhr.statusText + ': ' + xhr.responseURL);
        //     return;
        // }
        // this.complete();
    }
    ;
    /**
     * Determines the responseType of an XHR request based on the extension of the
     * resource being loaded.
     *
     * @private
     * @return {Resource.XHR_RESPONSE_TYPE} The responseType to use.
     */
    _determineXhrType() {
        return ResourceLoader._xhrTypeMap[this.extension] || ResourceLoader.XHR_RESPONSE_TYPE.TEXT;
    }
    ;
    /**
     * Determines the loadType of a resource based on the extension of the
     * resource being loaded.
     *
     * @private
     * @return {Resource.LOAD_TYPE} The loadType to use.
     */
    /**
     * Determines the mime type of an XHR request based on the responseType of
     * resource being loaded.
     *
     * @private
     * @param {Resource.XHR_RESPONSE_TYPE} type - The type to get a mime type for.
     * @return {string} The mime type to use.
     */
    _getMimeFromXhrType(type) {
        switch (type) {
            case ResourceLoader.XHR_RESPONSE_TYPE.BUFFER:
                return 'application/octet-binary';
            case ResourceLoader.XHR_RESPONSE_TYPE.BLOB:
                return 'application/blob';
            case ResourceLoader.XHR_RESPONSE_TYPE.DOCUMENT:
                return 'application/xml';
            case ResourceLoader.XHR_RESPONSE_TYPE.JSON:
                return 'application/json';
            case ResourceLoader.XHR_RESPONSE_TYPE.DEFAULT:
            case ResourceLoader.XHR_RESPONSE_TYPE.TEXT:
            /* falls through */
            default:
                return 'text/plain';
        }
    }
    ;
    get isDataUrl() {
        return this._hasFlag(ResourceLoader.STATUS_FLAGS.DATA_URL);
    }
    get isComplete() {
        return this._hasFlag(ResourceLoader.STATUS_FLAGS.COMPLETE);
    }
    get isLoading() {
        return this._hasFlag(ResourceLoader.STATUS_FLAGS.LOADING);
    }
}
ResourceLoader.STATUS_NONE = 0;
ResourceLoader.STATUS_OK = 200;
ResourceLoader.STATUS_EMPTY = 204;
ResourceLoader.STATUS_IE_BUG_EMPTY = 1223;
ResourceLoader.STATUS_TYPE_OK = 2;
ResourceLoader.useXdr = !!(window['XDomainRequest'] && !('withCredentials' in new XMLHttpRequest()));
ResourceLoader.EMPTY_GIF = 'data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==';
ResourceLoader.LOAD_TYPE = {
    XHR: 1,
    IMAGE: 2,
    AUDIO: 3,
    VIDEO: 4
};
ResourceLoader.XHR_RESPONSE_TYPE = {
    DEFAULT: 'text',
    BUFFER: 'arraybuffer',
    BLOB: 'blob',
    DOCUMENT: 'document',
    JSON: 'json',
    TEXT: 'text'
};
ResourceLoader._xhrTypeMap = {
    xhtml: ResourceLoader.XHR_RESPONSE_TYPE.DOCUMENT,
    html: ResourceLoader.XHR_RESPONSE_TYPE.DOCUMENT,
    htm: ResourceLoader.XHR_RESPONSE_TYPE.DOCUMENT,
    xml: ResourceLoader.XHR_RESPONSE_TYPE.DOCUMENT,
    tmx: ResourceLoader.XHR_RESPONSE_TYPE.DOCUMENT,
    svg: ResourceLoader.XHR_RESPONSE_TYPE.DOCUMENT,
    tsx: ResourceLoader.XHR_RESPONSE_TYPE.DOCUMENT,
    gif: ResourceLoader.XHR_RESPONSE_TYPE.BLOB,
    png: ResourceLoader.XHR_RESPONSE_TYPE.BLOB,
    bmp: ResourceLoader.XHR_RESPONSE_TYPE.BLOB,
    jpg: ResourceLoader.XHR_RESPONSE_TYPE.BLOB,
    jpeg: ResourceLoader.XHR_RESPONSE_TYPE.BLOB,
    tif: ResourceLoader.XHR_RESPONSE_TYPE.BLOB,
    tiff: ResourceLoader.XHR_RESPONSE_TYPE.BLOB,
    webp: ResourceLoader.XHR_RESPONSE_TYPE.BLOB,
    tga: ResourceLoader.XHR_RESPONSE_TYPE.BLOB,
    json: ResourceLoader.XHR_RESPONSE_TYPE.JSON,
    text: ResourceLoader.XHR_RESPONSE_TYPE.TEXT,
    txt: ResourceLoader.XHR_RESPONSE_TYPE.TEXT,
    ttf: ResourceLoader.XHR_RESPONSE_TYPE.BUFFER,
    otf: ResourceLoader.XHR_RESPONSE_TYPE.BUFFER
};
ResourceLoader._loadTypeMap = {
    gif: ResourceLoader.LOAD_TYPE.IMAGE,
    png: ResourceLoader.LOAD_TYPE.IMAGE,
    bmp: ResourceLoader.LOAD_TYPE.IMAGE,
    jpg: ResourceLoader.LOAD_TYPE.IMAGE,
    jpeg: ResourceLoader.LOAD_TYPE.IMAGE,
    tif: ResourceLoader.LOAD_TYPE.IMAGE,
    tiff: ResourceLoader.LOAD_TYPE.IMAGE,
    webp: ResourceLoader.LOAD_TYPE.IMAGE,
    tga: ResourceLoader.LOAD_TYPE.IMAGE,
    svg: ResourceLoader.LOAD_TYPE.IMAGE,
    'svg+xml': ResourceLoader.LOAD_TYPE.IMAGE,
    mp3: ResourceLoader.LOAD_TYPE.AUDIO,
    ogg: ResourceLoader.LOAD_TYPE.AUDIO,
    wav: ResourceLoader.LOAD_TYPE.AUDIO,
    mp4: ResourceLoader.LOAD_TYPE.VIDEO,
    webm: ResourceLoader.LOAD_TYPE.VIDEO
};
ResourceLoader.TYPE = {
    UNKNOWN: 0,
    JSON: 1,
    XML: 2,
    IMAGE: 3,
    AUDIO: 4,
    VIDEO: 5,
    TEXT: 6
};
ResourceLoader.STATUS_FLAGS = {
    NONE: 0,
    DATA_URL: 1 << 0,
    COMPLETE: 1 << 1,
    LOADING: 1 << 2
};
exports.ResourceLoader = ResourceLoader;
class URIData {
}


/***/ }),

/***/ "./js-compile/raw-pixi-ts/ResourceSettings.js":
/*!****************************************************!*\
  !*** ./js-compile/raw-pixi-ts/ResourceSettings.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const ImageResource_1 = __webpack_require__(/*! ./ImageResource */ "./js-compile/raw-pixi-ts/ImageResource.js");
const CanvasResource_1 = __webpack_require__(/*! ./CanvasResource */ "./js-compile/raw-pixi-ts/CanvasResource.js");
const VideoResource_1 = __webpack_require__(/*! ./VideoResource */ "./js-compile/raw-pixi-ts/VideoResource.js");
const SVGResource_1 = __webpack_require__(/*! ./SVGResource */ "./js-compile/raw-pixi-ts/SVGResource.js");
const BufferResource_1 = __webpack_require__(/*! ./BufferResource */ "./js-compile/raw-pixi-ts/BufferResource.js");
const CubeResource_1 = __webpack_require__(/*! ./CubeResource */ "./js-compile/raw-pixi-ts/CubeResource.js");
const ArrayResource_1 = __webpack_require__(/*! ./ArrayResource */ "./js-compile/raw-pixi-ts/ArrayResource.js");
class ResourceSettings {
    static autoDetectResource(source, options) {
        if (!source) {
            return null;
        }
        var extension = '';
        if (typeof source === 'string') {
            var result = (/\.(\w{3,4})(?:$|\?|#)/i).exec(source);
            if (result) {
                extension = result[1].toLowerCase();
            }
        }
        for (var i = ResourceSettings.INSTALLED.length - 1; i >= 0; --i) {
            var ResourcePlugin = ResourceSettings.INSTALLED[i];
            if (ResourcePlugin.test && ResourcePlugin.test(source, extension)) {
                return new ResourcePlugin(source, options);
            }
        }
        return new ImageResource_1.ImageResource(source, options);
    }
}
ResourceSettings.INSTALLED = [
    ImageResource_1.ImageResource,
    CanvasResource_1.CanvasResource,
    VideoResource_1.VideoResource,
    SVGResource_1.SVGResource,
    BufferResource_1.BufferResource,
    CubeResource_1.CubeResource,
    ArrayResource_1.ArrayResource
];
exports.ResourceSettings = ResourceSettings;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/RopeGeometry.js":
/*!************************************************!*\
  !*** ./js-compile/raw-pixi-ts/RopeGeometry.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const MeshGeometry_1 = __webpack_require__(/*! ./MeshGeometry */ "./js-compile/raw-pixi-ts/MeshGeometry.js");
class RopeGeometry extends MeshGeometry_1.MeshGeometry {
    constructor(width = 200, points = null) {
        if (width === void 0) {
            width = 200;
        }
        super(new Float32Array(points.length * 4), new Float32Array(points.length * 4), new Uint16Array((points.length - 1) * 6));
        /**
        * An array of points that determine the rope
        * @member {PIXI.Point[]}
        */
        this.points = points;
        /**
        * The width (i.e., thickness) of the rope.
        * @member {number}
        * @readOnly
        */
        this.width = width;
        this.build();
    }
    /**
    * Refreshes Rope indices and uvs
    * @private
    */
    build() {
        var points = this.points;
        if (!points) {
            return;
        }
        var vertexBuffer = this.getAttribute('aVertexPosition');
        var uvBuffer = this.getAttribute('aTextureCoord');
        var indexBuffer = this.getIndex();
        // if too little points, or texture hasn't got UVs set yet just move on.
        if (points.length < 1) {
            return;
        }
        // if the number of points has changed we will need to recreate the arraybuffers
        if (vertexBuffer.data.length / 4 !== points.length) {
            vertexBuffer.data = new Float32Array(points.length * 4);
            uvBuffer.data = new Float32Array(points.length * 4);
            indexBuffer.data = new Uint16Array((points.length - 1) * 6);
        }
        var uvs = uvBuffer.data;
        var indices = indexBuffer.data;
        uvs[0] = 0;
        uvs[1] = 0;
        uvs[2] = 0;
        uvs[3] = 1;
        // indices[0] = 0;
        // indices[1] = 1;
        var total = points.length; // - 1;
        for (var i = 0; i < total; i++) {
            // time to do some smart drawing!
            var index = i * 4;
            var amount = i / (total - 1);
            uvs[index] = amount;
            uvs[index + 1] = 0;
            uvs[index + 2] = amount;
            uvs[index + 3] = 1;
        }
        var indexCount = 0;
        for (var i$1 = 0; i$1 < total - 1; i$1++) {
            var index$1 = i$1 * 2;
            indices[indexCount++] = index$1;
            indices[indexCount++] = index$1 + 1;
            indices[indexCount++] = index$1 + 2;
            indices[indexCount++] = index$1 + 2;
            indices[indexCount++] = index$1 + 1;
            indices[indexCount++] = index$1 + 3;
        }
        // ensure that the changes are uploaded
        uvBuffer.update();
        indexBuffer.update();
        this.updateVertices();
    }
    ;
    /**
    * refreshes vertices of Rope mesh
    */
    updateVertices() {
        var points = this.points;
        if (points.length < 1) {
            return;
        }
        var lastPoint = points[0];
        var nextPoint;
        var perpX = 0;
        var perpY = 0;
        // this.count -= 0.2;
        var vertices = this.buffers[0].data;
        var total = points.length;
        for (var i = 0; i < total; i++) {
            var point = points[i];
            var index = i * 4;
            if (i < points.length - 1) {
                nextPoint = points[i + 1];
            }
            else {
                nextPoint = point;
            }
            perpY = -(nextPoint.x - lastPoint.x);
            perpX = nextPoint.y - lastPoint.y;
            var perpLength = Math.sqrt((perpX * perpX) + (perpY * perpY));
            var num = this.width / 2; // (20 + Math.abs(Math.sin((i + this.count) * 0.3) * 50) )* ratio;
            perpX /= perpLength;
            perpY /= perpLength;
            perpX *= num;
            perpY *= num;
            vertices[index] = point.x + perpX;
            vertices[index + 1] = point.y + perpY;
            vertices[index + 2] = point.x - perpX;
            vertices[index + 3] = point.y - perpY;
            lastPoint = point;
        }
        this.buffers[0].update();
    }
    ;
    update() {
        this.updateVertices();
    }
    ;
}
exports.RopeGeometry = RopeGeometry;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/RoundedRectangle.js":
/*!****************************************************!*\
  !*** ./js-compile/raw-pixi-ts/RoundedRectangle.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const ShapeSettings_1 = __webpack_require__(/*! ./ShapeSettings */ "./js-compile/raw-pixi-ts/ShapeSettings.js");
class RoundedRectangle {
    constructor(x = 0, y = 0, width = 0, height = 0, radius = 20) {
        if (x === void 0) {
            x = 0;
        }
        if (y === void 0) {
            y = 0;
        }
        if (width === void 0) {
            width = 0;
        }
        if (height === void 0) {
            height = 0;
        }
        if (radius === void 0) {
            radius = 20;
        }
        /**
         * @member {number}
         * @default 0
         */
        this.x = x;
        /**
         * @member {number}
         * @default 0
         */
        this.y = y;
        /**
         * @member {number}
         * @default 0
         */
        this.width = width;
        /**
         * @member {number}
         * @default 0
         */
        this.height = height;
        /**
         * @member {number}
         * @default 20
         */
        this.radius = radius;
        /**
         * The type of the object, mainly used to avoid `instanceof` checks
         *
         * @member {number}
         * @readonly
         * @default PIXI.SHAPES.RREC
         * @see PIXI.SHAPES
         */
        this.type = ShapeSettings_1.ShapeSettings.SHAPES.RREC;
    }
    /**
     * Creates a clone of this Rounded Rectangle
     *
     * @return {PIXI.RoundedRectangle} a copy of the rounded rectangle
     */
    clone() {
        return new RoundedRectangle(this.x, this.y, this.width, this.height, this.radius);
    }
    ;
    /**
     * Checks whether the x and y coordinates given are contained within this Rounded Rectangle
     *
     * @param {number} x - The X coordinate of the point to test
     * @param {number} y - The Y coordinate of the point to test
     * @return {boolean} Whether the x/y coordinates are within this Rounded Rectangle
     */
    contains(x, y) {
        if (this.width <= 0 || this.height <= 0) {
            return false;
        }
        if (x >= this.x && x <= this.x + this.width) {
            if (y >= this.y && y <= this.y + this.height) {
                if ((y >= this.y + this.radius && y <= this.y + this.height - this.radius)
                    || (x >= this.x + this.radius && x <= this.x + this.width - this.radius)) {
                    return true;
                }
                var dx = x - (this.x + this.radius);
                var dy = y - (this.y + this.radius);
                var radius2 = this.radius * this.radius;
                if ((dx * dx) + (dy * dy) <= radius2) {
                    return true;
                }
                dx = x - (this.x + this.width - this.radius);
                if ((dx * dx) + (dy * dy) <= radius2) {
                    return true;
                }
                dy = y - (this.y + this.height - this.radius);
                if ((dx * dx) + (dy * dy) <= radius2) {
                    return true;
                }
                dx = x - (this.x + this.radius);
                if ((dx * dx) + (dy * dy) <= radius2) {
                    return true;
                }
            }
        }
        return false;
    }
    ;
}
exports.RoundedRectangle = RoundedRectangle;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/Runner.js":
/*!******************************************!*\
  !*** ./js-compile/raw-pixi-ts/Runner.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class Runner {
    constructor(name, priority = 0) {
        this.items = [];
        this._name = name;
        this.dispatch = this.emit;
        this.run = this.emit;
    }
    emit(a0, a1, a2, a3, a4, a5, a6, a7) {
        if (arguments.length > 8) {
            throw new Error('max arguments reached');
        }
        var ref = this;
        var name = ref.name;
        var items = ref.items;
        for (var i = 0, len = items.length; i < len; i++) {
            items[i][name](a0, a1, a2, a3, a4, a5, a6, a7);
        }
        return this;
    }
    ;
    /**
     * Add a listener to the Runner
     *
     * Runners do not need to have scope or functions passed to them.
     * All that is required is to pass the listening object and ensure that it has contains a function that has the same name
     * as the name provided to the Runner when it was created.
     *
     * Eg A listener passed to this Runner will require a 'complete' function.
     *
     * ```
     * const complete = new PIXI.Runner('complete');
     * ```
     *
     * The scope used will be the object itself.
     *
     * @param {any} item - The object that will be listening.
     */
    add(item) {
        if (item[this._name]) {
            this.remove(item);
            this.items.push(item);
        }
        return this;
    }
    ;
    /**
     * Remove a single listener from the dispatch queue.
     * @param {any} item - The listenr that you would like to remove.
     */
    remove(item) {
        var index = this.items.indexOf(item);
        if (index !== -1) {
            this.items.splice(index, 1);
        }
        return this;
    }
    ;
    /**
     * Check to see if the listener is already in the Runner
     * @param {any} item - The listener that you would like to check.
     */
    contains(item) {
        return this.items.indexOf(item) !== -1;
    }
    ;
    /**
     * Remove all listeners from the Runner
     */
    removeAll() {
        this.items.length = 0;
        return this;
    }
    ;
    /**
     * Remove all references, don't use after this.
     */
    destroy() {
        this.removeAll();
        this.items = null;
        this._name = null;
    }
    ;
    /**
     * `true` if there are no this Runner contains no listeners
     *
     * @member {boolean}
     * @readonly
     */
    get empty() {
        return this.items.length === 0;
    }
    ;
    /**
     * The name of the runner.
     *
     * @member {string}
     * @readonly
     */
    get name() {
        return this._name;
    }
    ;
}
exports.Runner = Runner;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/SVGResource.js":
/*!***********************************************!*\
  !*** ./js-compile/raw-pixi-ts/SVGResource.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseImageResource_1 = __webpack_require__(/*! ./BaseImageResource */ "./js-compile/raw-pixi-ts/BaseImageResource.js");
const settings_1 = __webpack_require__(/*! ./settings */ "./js-compile/raw-pixi-ts/settings.js");
const MathSettings_1 = __webpack_require__(/*! ./MathSettings */ "./js-compile/raw-pixi-ts/MathSettings.js");
class SVGResource extends BaseImageResource_1.BaseImageResource {
    constructor(source, options) {
        options = options || {};
        super(document.createElement('canvas'));
        /**
         * Base64 encoded SVG element or URL for SVG file
         * @readonly
         * @member {string}
         */
        this.svg = source;
        /**
         * The source scale to apply to render
         * @readonly
         * @member {number}
         */
        this.scale = options.scale || 1;
        /**
         * Call when completely loaded
         * @private
         * @member {function}
         */
        this._resolve = null;
        /**
         * Promise when loading
         * @member {Promise<void>}
         * @private
         * @default null
         */
        this._load = null;
        if (options.autoLoad !== false) {
            this.load();
        }
    }
    load() {
        var this$1 = this;
        if (this._load) {
            return this._load;
        }
        this._load = new Promise(function (resolve) {
            // Save this until after load is finished
            this$1._resolve = function () {
                this$1.resize(this$1.source.width, this$1.source.height);
                resolve(this$1);
            };
            // Convert SVG inline string to data-uri
            if ((/^\<svg/).test(this$1.svg.trim())) {
                this$1.svg = "data:image/svg+xml;utf8," + (this$1.svg);
            }
            // Checks if `source` is an SVG image and whether it's
            // loaded via a URL or a data URI. Then calls
            // `_loadDataUri` or `_loadXhr`.
            var dataUri = settings_1.settings.decomposeDataUri(this$1.svg);
            if (dataUri) {
                this$1._loadDataUri(dataUri);
            }
            else {
                // We got an URL, so we need to do an XHR to check the svg size
                this$1._loadXhr();
            }
        });
        return this._load;
    }
    ;
    /**
     * Reads an SVG string from data URI and then calls `_loadString`.
     *
     * @param {string} dataUri - The data uri to load from.
     */
    _loadDataUri(dataUri) {
        var svgString;
        if (dataUri.encoding === 'base64') {
            if (!atob) {
                throw new Error('Your browser doesn\'t support base64 conversions.');
            }
            svgString = atob(dataUri.data);
        }
        else {
            svgString = dataUri.data;
        }
        this._loadString(svgString);
    }
    ;
    /**
     * Loads an SVG string from `imageUrl` using XHR and then calls `_loadString`.
     *
     * @private
     */
    _loadXhr() {
        var this$1 = this;
        var svgXhr = new XMLHttpRequest();
        // This throws error on IE, so SVG Document can't be used
        // svgXhr.responseType = 'document';
        // This is not needed since we load the svg as string (breaks IE too)
        // but overrideMimeType() can be used to force the response to be parsed as XML
        // svgXhr.overrideMimeType('image/svg+xml');
        svgXhr.onload = function () {
            if (svgXhr.readyState !== svgXhr.DONE || svgXhr.status !== 200) {
                throw new Error('Failed to load SVG using XHR.');
            }
            this$1._loadString(svgXhr.response);
        };
        // svgXhr.onerror = () => this.emit('error', this);
        svgXhr.open('GET', this.svg, true);
        svgXhr.send();
    }
    ;
    /**
     * Loads texture using an SVG string. The original SVG Image is stored as `origSource` and the
     * created canvas is the new `source`. The SVG is scaled using `sourceScale`. Called by
     * `_loadXhr` or `_loadDataUri`.
     *
     * @private
     * @param  {string} svgString SVG source as string
     *
     * @fires loaded
     */
    _loadString(svgString) {
        var svgSize = SVGResource.getSize(svgString);
        // TODO do we need to wait for this to load?
        // seems instant!
        //
        var tempImage = new Image();
        tempImage.src = "data:image/svg+xml," + svgString;
        var svgWidth = svgSize.width;
        var svgHeight = svgSize.height;
        if (!svgWidth || !svgHeight) {
            throw new Error('The SVG image must have width and height defined (in pixels), canvas API needs them.');
        }
        // Scale realWidth and realHeight
        this._width = Math.round(svgWidth * this.scale);
        this._height = Math.round(svgHeight * this.scale);
        // Create a canvas element
        var canvas = this.source;
        canvas.width = this._width;
        canvas.height = this._height;
        canvas._pixiId = "canvas_" + (MathSettings_1.MathSettings.uid());
        // Draw the Svg to the canvas
        canvas
            .getContext('2d')
            .drawImage(tempImage, 0, 0, svgWidth, svgHeight, 0, 0, this.width, this.height);
        this._resolve();
        this._resolve = null;
    }
    ;
    /**
     * Typedef for Size object.
     *
     * @memberof PIXI.resources.SVGResource
     * @typedef {object} Size
     * @property {number} width - Width component
     * @property {number} height - Height component
     */
    /**
     * Get size from an svg string using regexp.
     *
     * @method
     * @param {string} svgString - a serialized svg element
     * @return {PIXI.resources.SVGResource.Size} image extension
     */
    static getSize(svgString) {
        var sizeMatch = SVGResource.SVG_SIZE.exec(svgString);
        var size = {};
        if (sizeMatch) {
            size[sizeMatch[1]] = Math.round(parseFloat(sizeMatch[3]));
            size[sizeMatch[5]] = Math.round(parseFloat(sizeMatch[7]));
        }
        return size;
    }
    ;
    /**
     * Destroys this texture
     * @override
     */
    dispose() {
        BaseImageResource_1.BaseImageResource.prototype.dispose.call(this);
        this._resolve = null;
    }
    ;
    /**
     * Used to auto-detect the type of resource.
     *
     * @static
     * @param {*} source - The source object
     * @param {string} extension - The extension of source, if set
     */
    static test(source, extension) {
        // url file extension is SVG
        return extension === 'svg'
            // source is SVG data-uri
            || (typeof source === 'string' && source.indexOf('data:image/svg+xml') === 0);
    }
    ;
}
/**
* RegExp for SVG size.
*
* @static
* @constant {RegExp|string} SVG_SIZE
* @memberof PIXI.resources.SVGResource
* @example &lt;svg width="100" height="100"&gt;&lt;/svg&gt;
*/
SVGResource.SVG_SIZE = /<svg[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*>/i; // eslint-disable-line max-len
exports.SVGResource = SVGResource;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/Shader.js":
/*!******************************************!*\
  !*** ./js-compile/raw-pixi-ts/Shader.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const UniformGroup_1 = __webpack_require__(/*! ./UniformGroup */ "./js-compile/raw-pixi-ts/UniformGroup.js");
const Program_1 = __webpack_require__(/*! ./Program */ "./js-compile/raw-pixi-ts/Program.js");
class Shader {
    constructor(program, uniforms) {
        this.program = program;
        // lets see whats been passed in
        // uniforms should be converted to a uniform group
        if (uniforms) {
            if (uniforms instanceof UniformGroup_1.UniformGroup) {
                this.uniformGroup = uniforms;
            }
            else {
                this.uniformGroup = new UniformGroup_1.UniformGroup(uniforms);
            }
        }
        else {
            this.uniformGroup = new UniformGroup_1.UniformGroup({});
        }
        // time to build some getters and setters!
        // I guess down the line this could sort of generate an instruction list rather than use dirty ids?
        // does the trick for now though!
        for (var i in program.uniformData) {
            if (this.uniformGroup.uniforms[i] instanceof Array) {
                this.uniformGroup.uniforms[i] = new Float32Array(this.uniformGroup.uniforms[i]);
            }
        }
    }
    // TODO move to shader system..
    checkUniformExists(name, group) {
        if (group.uniforms[name]) {
            return true;
        }
        for (var i in group.uniforms) {
            var uniform = group.uniforms[i];
            if (uniform.group) {
                if (this.checkUniformExists(name, uniform)) {
                    return true;
                }
            }
        }
        return false;
    }
    ;
    destroy() {
        // usage count on programs?
        // remove if not used!
        this.uniformGroup = null;
    }
    ;
    /**
     * Shader uniform values, shortcut for `uniformGroup.uniforms`
     * @readonly
     * @member {object}
     */
    get uniforms() {
        return this.uniformGroup.uniforms;
    }
    ;
    /**
     * A short hand function to create a shader based of a vertex and fragment shader
     *
     * @param {string} [vertexSrc] - The source of the vertex shader.
     * @param {string} [fragmentSrc] - The source of the fragment shader.
     * @param {object} [uniforms] - Custom uniforms to use to augment the built-in ones.
     *
     * @returns {PIXI.Shader} an shiny new Pixi shader!
     */
    static from(vertexSrc, fragmentSrc, uniforms) {
        var program = Program_1.Program.from(vertexSrc, fragmentSrc);
        return new Shader(program, uniforms);
    }
    ;
    /**
 * @private
 * @param gl {WebGLRenderingContext} The current WebGL context {WebGLProgram}
 * @param type {Number} the type, can be either VERTEX_SHADER or FRAGMENT_SHADER
 * @param vertexSrc {string|string[]} The vertex shader source as an array of strings.
 * @return {WebGLShader} the shader
 */
    static compileShader(gl, type, src) {
        var shader = gl.createShader(type);
        gl.shaderSource(shader, src);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            console.warn(src);
            console.error(gl.getShaderInfoLog(shader));
            return null;
        }
        return shader;
    }
}
exports.Shader = Shader;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/ShaderSystem.js":
/*!************************************************!*\
  !*** ./js-compile/raw-pixi-ts/ShaderSystem.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const System_1 = __webpack_require__(/*! ./System */ "./js-compile/raw-pixi-ts/System.js");
const Program_1 = __webpack_require__(/*! ./Program */ "./js-compile/raw-pixi-ts/Program.js");
const GLProgram_1 = __webpack_require__(/*! ./GLProgram */ "./js-compile/raw-pixi-ts/GLProgram.js");
const StateSystem_1 = __webpack_require__(/*! ./StateSystem */ "./js-compile/raw-pixi-ts/StateSystem.js");
const UtilsSettings_1 = __webpack_require__(/*! ./UtilsSettings */ "./js-compile/raw-pixi-ts/UtilsSettings.js");
const WebGLSettings_1 = __webpack_require__(/*! ./WebGLSettings */ "./js-compile/raw-pixi-ts/WebGLSettings.js");
class ShaderSystem extends System_1.System {
    constructor(renderer) {
        super(renderer);
        // Validation check that this environment support `new Function`
        this.systemCheck();
        /**
         * The current WebGL rendering context
         *
         * @member {WebGLRenderingContext}
         */
        this.gl = null;
        this.shader = null;
        this.program = null;
        /**
         * Cache to holds the generated functions. Stored against UniformObjects unique signature
         * @type {Object}
         * @private
         */
        this.cache = {};
        this.id = StateSystem_1.StateSystem.UID$4++;
    }
    /**
     * Overrideable function by `@pixi/unsafe-eval` to silence
     * throwing an error if platform doesn't support unsafe-evals.
     *
     * @private
     */
    systemCheck() {
        if (!UtilsSettings_1.UtilsSettings.unsafeEvalSupported()) {
            throw new Error('Current environment does not allow unsafe-eval, '
                + 'please use @pixi/unsafe-eval module to enable support.');
        }
    }
    ;
    contextChange(gl) {
        this.gl = gl;
    }
    ;
    /**
     * Changes the current shader to the one given in parameter
     *
     * @param {PIXI.Shader} shader - the new shader
     * @param {boolean} dontSync - false if the shader should automatically sync its uniforms.
     * @returns {PIXI.GLProgram} the glProgram that belongs to the shader.
     */
    bind(shader, dontSync = false) {
        shader.uniforms.globals = this.renderer.globalUniforms;
        var program = shader.program;
        var glProgram = program.glPrograms[this.renderer.CONTEXT_UID] || this.generateShader(shader);
        this.shader = shader;
        // TODO - some current Pixi plugins bypass this.. so it not safe to use yet..
        if (this.program !== program) {
            this.program = program;
            this.gl.useProgram(glProgram.program);
        }
        if (!dontSync) {
            this.syncUniformGroup(shader.uniformGroup);
        }
        return glProgram;
    }
    ;
    /**
     * Uploads the uniforms values to the currently bound shader.
     *
     * @param {object} uniforms - the uniforms values that be applied to the current shader
     */
    setUniforms(uniforms) {
        var shader = this.shader.program;
        var glProgram = shader.glPrograms[this.renderer.CONTEXT_UID];
        shader.syncUniforms(glProgram.uniformData, uniforms, this.renderer);
    }
    ;
    syncUniformGroup(group) {
        var glProgram = this.getglProgram();
        if (!group.static || group.dirtyId !== glProgram.uniformGroups[group.id]) {
            glProgram.uniformGroups[group.id] = group.dirtyId;
            this.syncUniforms(group, glProgram);
        }
    }
    ;
    /**
     * Overrideable by the @pixi/unsafe-eval package to use static
     * syncUnforms instead.
     *
     * @private
     */
    syncUniforms(group, glProgram) {
        var syncFunc = group.syncUniforms[this.shader.program.id] || this.createSyncGroups(group);
        syncFunc(glProgram.uniformData, group.uniforms, this.renderer);
    }
    ;
    createSyncGroups(group) {
        var id = this.getSignature(group, this.shader.program.uniformData);
        if (!this.cache[id]) {
            this.cache[id] = WebGLSettings_1.WebGLSettings.generateUniformsSync(group, this.shader.program.uniformData);
        }
        group.syncUniforms[this.shader.program.id] = this.cache[id];
        return group.syncUniforms[this.shader.program.id];
    }
    ;
    /**
     * Takes a uniform group and data and generates a unique signature for them.
     *
     * @param {PIXI.UniformGroup} group the uniform group to get signature of
     * @param {Object} uniformData uniform information generated by the shader
     * @returns {String} Unique signature of the uniform group
     * @private
     */
    getSignature(group, uniformData) {
        var uniforms = group.uniforms;
        var strings = [];
        for (var i in uniforms) {
            strings.push(i);
            if (uniformData[i]) {
                strings.push(uniformData[i].type);
            }
        }
        return strings.join('-');
    }
    ;
    /**
     * Returns the underlying GLShade rof the currently bound shader.
     * This can be handy for when you to have a little more control over the setting of your uniforms.
     *
     * @return {PIXI.GLProgram} the glProgram for the currently bound Shader for this context
     */
    getglProgram() {
        if (this.shader) {
            return this.shader.program.glPrograms[this.renderer.CONTEXT_UID];
        }
        return null;
    }
    ;
    /**
     * Generates a glProgram version of the Shader provided.
     *
     * @private
     * @param {PIXI.Shader} shader the shader that the glProgram will be based on.
     * @return {PIXI.GLProgram} A shiny new glProgram!
     */
    generateShader(shader) {
        var gl = this.gl;
        var program = shader.program;
        var attribMap = {};
        for (var i in program.attributeData) {
            attribMap[i] = program.attributeData[i].location;
        }
        var shaderProgram = Program_1.Program.compileProgram(gl, program.vertexSrc, program.fragmentSrc, attribMap);
        var uniformData = {};
        for (var i$1 in program.uniformData) {
            var data = program.uniformData[i$1];
            uniformData[i$1] = {
                location: gl.getUniformLocation(shaderProgram, i$1),
                value: WebGLSettings_1.WebGLSettings.defaultValue(data.type, data.size),
            };
        }
        var glProgram = new GLProgram_1.GLProgram(shaderProgram, uniformData);
        program.glPrograms[this.renderer.CONTEXT_UID] = glProgram;
        return glProgram;
    }
    ;
    /**
     * Resets ShaderSystem state, does not affect WebGL state
     */
    reset() {
        this.program = null;
        this.shader = null;
    }
    ;
    /**
     * Destroys this System and removes all its textures
     */
    destroy() {
        // TODO implement destroy method for ShaderSystem
        this.destroyed = true;
    }
    ;
}
exports.ShaderSystem = ShaderSystem;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/ShapeSettings.js":
/*!*************************************************!*\
  !*** ./js-compile/raw-pixi-ts/ShapeSettings.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class ShapeSettings {
}
/**
* Constants that identify shapes, mainly to prevent `instanceof` calls.
*
* @static
* @constant
* @name SHAPES
* @memberof PIXI
* @type {object}
* @property {number} POLY Polygon
* @property {number} RECT Rectangle
* @property {number} CIRC Circle
* @property {number} ELIP Ellipse
* @property {number} RREC Rounded Rectangle
*/
ShapeSettings.SHAPES = {
    POLY: 0,
    RECT: 1,
    CIRC: 2,
    ELIP: 3,
    RREC: 4,
};
exports.ShapeSettings = ShapeSettings;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/SimpleRope.js":
/*!**********************************************!*\
  !*** ./js-compile/raw-pixi-ts/SimpleRope.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Mesh_1 = __webpack_require__(/*! ./Mesh */ "./js-compile/raw-pixi-ts/Mesh.js");
const RopeGeometry_1 = __webpack_require__(/*! ./RopeGeometry */ "./js-compile/raw-pixi-ts/RopeGeometry.js");
const MeshMaterial_1 = __webpack_require__(/*! ./MeshMaterial */ "./js-compile/raw-pixi-ts/MeshMaterial.js");
class SimpleRope extends Mesh_1.Mesh {
    constructor(texture, points) {
        var ropeGeometry = new RopeGeometry_1.RopeGeometry(texture.height, points);
        var meshMaterial = new MeshMaterial_1.MeshMaterial(texture);
        super(ropeGeometry, meshMaterial);
        this.autoUpdate = true;
    }
    _render(renderer) {
        if (this.autoUpdate
            || this.geometry.width !== this.shader.texture.height) {
            this.geometry.width = this.shader.texture.height;
            this.geometry.update();
        }
        super._render(renderer);
    }
    ;
}
exports.SimpleRope = SimpleRope;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/Sprite.js":
/*!******************************************!*\
  !*** ./js-compile/raw-pixi-ts/Sprite.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Container_1 = __webpack_require__(/*! ./Container */ "./js-compile/raw-pixi-ts/Container.js");
const ObservablePoint_1 = __webpack_require__(/*! ./ObservablePoint */ "./js-compile/raw-pixi-ts/ObservablePoint.js");
const Texture_1 = __webpack_require__(/*! ./Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const Rectangle_1 = __webpack_require__(/*! ./Rectangle */ "./js-compile/raw-pixi-ts/Rectangle.js");
const Point_1 = __webpack_require__(/*! ./Point */ "./js-compile/raw-pixi-ts/Point.js");
const BlendModesSettings_1 = __webpack_require__(/*! ./BlendModesSettings */ "./js-compile/raw-pixi-ts/BlendModesSettings.js");
const DisplaySettings_1 = __webpack_require__(/*! ./DisplaySettings */ "./js-compile/raw-pixi-ts/DisplaySettings.js");
const MathSettings_1 = __webpack_require__(/*! ./MathSettings */ "./js-compile/raw-pixi-ts/MathSettings.js");
const Logger_1 = __webpack_require__(/*! ./Logger */ "./js-compile/raw-pixi-ts/Logger.js");
class Sprite extends Container_1.Container {
    constructor(texture) {
        super();
        /**
         * When the texture is updated, this event will fire to update the scale and frame
         *
         * @private
         */
        this._onTextureUpdate = () => {
            Logger_1.trace("Sprite update");
            this._textureID = -1;
            this._textureTrimmedID = -1;
            this.cachedTint = 0xFFFFFF;
            // reveal(this._texture)
            this.uvs = this._texture._uvs.uvsFloat32;
            // so if _width is 0 then width was not set..
            if (this._width) {
                this.scale.x = MathSettings_1.MathSettings.sign(this.scale.x) * this._width / this._texture.orig.width;
            }
            if (this._height) {
                this.scale.y = MathSettings_1.MathSettings.sign(this.scale.y) * this._height / this._texture.orig.height;
            }
        };
        /**
         * The anchor sets the origin point of the texture.
         * The default is 0,0 or taken from the {@link PIXI.Texture#defaultAnchor|Texture}
         * passed to the constructor. A value of 0,0 means the texture's origin is the top left.
         * Setting the anchor to 0.5,0.5 means the texture's origin is centered.
         * Setting the anchor to 1,1 would mean the texture's origin point will be the bottom right corner.
         * Note: Updating the {@link PIXI.Texture#defaultAnchor} after a Texture is
         * created does _not_ update the Sprite's anchor values.
         *
         * @member {PIXI.ObservablePoint}
         * @private
         */
        this._anchor = new ObservablePoint_1.ObservablePoint(this._onAnchorUpdate, this, (texture ? texture.defaultAnchor.x : 0), (texture ? texture.defaultAnchor.y : 0));
        /**
         * The texture that the sprite is using
         *
         * @private
         * @member {PIXI.Texture}
         */
        this._texture = null;
        /**
         * The width of the sprite (this is initially set by the texture)
         *
         * @private
         * @member {number}
         */
        this._width = 0;
        /**
         * The height of the sprite (this is initially set by the texture)
         *
         * @private
         * @member {number}
         */
        this._height = 0;
        /**
         * The tint applied to the sprite. This is a hex value. A value of 0xFFFFFF will remove any tint effect.
         *
         * @private
         * @member {number}
         * @default 0xFFFFFF
         */
        this._tint = null;
        this._tintRGB = null;
        this.tint = 0xFFFFFF;
        /**
         * The blend mode to be applied to the sprite. Apply a value of `PIXI.BLEND_MODES.NORMAL` to reset the blend mode.
         *
         * @member {number}
         * @default PIXI.BLEND_MODES.NORMAL
         * @see PIXI.BLEND_MODES
         */
        this.blendMode = BlendModesSettings_1.BlendModesSettings.BLEND_MODES.NORMAL;
        /**
         * The shader that will be used to render the sprite. Set to null to remove a current shader.
         *
         * @member {PIXI.Filter|PIXI.Shader}
         */
        this.shader = null;
        /**
         * An internal cached value of the tint.
         *
         * @private
         * @member {number}
         * @default 0xFFFFFF
         */
        this.cachedTint = 0xFFFFFF;
        this.uvs = null;
        // call texture setter
        this.texture = texture || Texture_1.Texture.EMPTY;
        /**
         * this is used to store the vertex data of the sprite (basically a quad)
         *
         * @private
         * @member {Float32Array}
         */
        this.vertexData = new Float32Array(8);
        /**
         * This is used to calculate the bounds of the object IF it is a trimmed sprite
         *
         * @private
         * @member {Float32Array}
         */
        this.vertexTrimmedData = null;
        this._transformID = -1;
        this._textureID = -1;
        this._transformTrimmedID = -1;
        this._textureTrimmedID = -1;
        // Batchable stuff..
        // TODO could make this a mixin?
        this.indices = Sprite.indices;
        this.size = 4;
        this.start = 0;
        /**
         * Plugin that is responsible for rendering this element.
         * Allows to customize the rendering process without overriding '_render' & '_renderCanvas' methods.
         *
         * @member {string}
         * @default 'sprite'
         */
        this.pluginName = 'batch';
        /**
         * used to fast check if a sprite is.. a sprite!
         * @member {boolean}
         */
        this.isSprite = true;
        /**
         * Internal roundPixels field
         *
         * @member {boolean}
         * @private
         */
        this._roundPixels = DisplaySettings_1.DisplaySettings.ROUND_PIXELS;
    }
    /**
     * Called when the anchor position updates.
     *
     * @private
     */
    _onAnchorUpdate() {
        this._transformID = -1;
        this._transformTrimmedID = -1;
    }
    ;
    /**
     * calculates worldTransform * vertices, store it in vertexData
     */
    calculateVertices() {
        var texture = this._texture;
        if (this._transformID === this.transform._worldID && this._textureID === texture._updateID) {
            return;
        }
        this._transformID = this.transform._worldID;
        this._textureID = texture._updateID;
        // set the vertex data
        var wt = this.transform.worldTransform;
        var a = wt.a;
        var b = wt.b;
        var c = wt.c;
        var d = wt.d;
        var tx = wt.tx;
        var ty = wt.ty;
        var vertexData = this.vertexData;
        var trim = texture.trim;
        var orig = texture.orig;
        var anchor = this._anchor;
        var w0 = 0;
        var w1 = 0;
        var h0 = 0;
        var h1 = 0;
        if (trim) {
            // if the sprite is trimmed and is not a tilingsprite then we need to add the extra
            // space before transforming the sprite coords.
            w1 = trim.x - (anchor._x * orig.width);
            w0 = w1 + trim.width;
            h1 = trim.y - (anchor._y * orig.height);
            h0 = h1 + trim.height;
        }
        else {
            w1 = -anchor._x * orig.width;
            w0 = w1 + orig.width;
            h1 = -anchor._y * orig.height;
            h0 = h1 + orig.height;
        }
        // xy
        vertexData[0] = (a * w1) + (c * h1) + tx;
        vertexData[1] = (d * h1) + (b * w1) + ty;
        // xy
        vertexData[2] = (a * w0) + (c * h1) + tx;
        vertexData[3] = (d * h1) + (b * w0) + ty;
        // xy
        vertexData[4] = (a * w0) + (c * h0) + tx;
        vertexData[5] = (d * h0) + (b * w0) + ty;
        // xy
        vertexData[6] = (a * w1) + (c * h0) + tx;
        vertexData[7] = (d * h0) + (b * w1) + ty;
        if (this._roundPixels) {
            for (var i = 0; i < 8; i++) {
                vertexData[i] = Math.round(vertexData[i]);
            }
        }
    }
    ;
    /**
     * calculates worldTransform * vertices for a non texture with a trim. store it in vertexTrimmedData
     * This is used to ensure that the true width and height of a trimmed texture is respected
     */
    calculateTrimmedVertices() {
        if (!this.vertexTrimmedData) {
            this.vertexTrimmedData = new Float32Array(8);
        }
        else if (this._transformTrimmedID === this.transform._worldID && this._textureTrimmedID === this._texture._updateID) {
            return;
        }
        this._transformTrimmedID = this.transform._worldID;
        this._textureTrimmedID = this._texture._updateID;
        // lets do some special trim code!
        var texture = this._texture;
        var vertexData = this.vertexTrimmedData;
        var orig = texture.orig;
        var anchor = this._anchor;
        // lets calculate the new untrimmed bounds..
        var wt = this.transform.worldTransform;
        var a = wt.a;
        var b = wt.b;
        var c = wt.c;
        var d = wt.d;
        var tx = wt.tx;
        var ty = wt.ty;
        var w1 = -anchor._x * orig.width;
        var w0 = w1 + orig.width;
        var h1 = -anchor._y * orig.height;
        var h0 = h1 + orig.height;
        // xy
        vertexData[0] = (a * w1) + (c * h1) + tx;
        vertexData[1] = (d * h1) + (b * w1) + ty;
        // xy
        vertexData[2] = (a * w0) + (c * h1) + tx;
        vertexData[3] = (d * h1) + (b * w0) + ty;
        // xy
        vertexData[4] = (a * w0) + (c * h0) + tx;
        vertexData[5] = (d * h0) + (b * w0) + ty;
        // xy
        vertexData[6] = (a * w1) + (c * h0) + tx;
        vertexData[7] = (d * h0) + (b * w1) + ty;
    }
    ;
    /**
    *
    * Renders the object using the WebGL renderer
    *
    * @protected
    * @param {PIXI.Renderer} renderer - The webgl renderer to use.
    */
    _render(renderer) {
        this.calculateVertices();
        renderer.batch.setObjectRenderer(renderer.plugins[this.pluginName]);
        renderer.plugins[this.pluginName].render(this);
    }
    ;
    /**
     * Updates the bounds of the sprite.
     *
     * @protected
     */
    _calculateBounds() {
        var trim = this._texture.trim;
        var orig = this._texture.orig;
        // First lets check to see if the current texture has a trim..
        if (!trim || (trim.width === orig.width && trim.height === orig.height)) {
            // no trim! lets use the usual calculations..
            this.calculateVertices();
            this._bounds.addQuad(this.vertexData);
        }
        else {
            // lets calculate a special trimmed bounds...
            this.calculateTrimmedVertices();
            this._bounds.addQuad(this.vertexTrimmedData);
        }
    }
    ;
    /**
     * Gets the local bounds of the sprite object.
     *
     * @param {PIXI.Rectangle} rect - The output rectangle.
     * @return {PIXI.Rectangle} The bounds.
     */
    getLocalBounds(rect) {
        // we can do a fast local bounds if the sprite has no children!
        if (this.children.length === 0) {
            this._bounds.minX = this._texture.orig.width * -this._anchor._x;
            this._bounds.minY = this._texture.orig.height * -this._anchor._y;
            this._bounds.maxX = this._texture.orig.width * (1 - this._anchor._x);
            this._bounds.maxY = this._texture.orig.height * (1 - this._anchor._y);
            if (!rect) {
                if (!this._localBoundsRect) {
                    this._localBoundsRect = new Rectangle_1.Rectangle();
                }
                rect = this._localBoundsRect;
            }
            return this._bounds.getRectangle(rect);
        }
        return Container_1.Container.prototype.getLocalBounds.call(this, rect);
    }
    ;
    /**
     * Tests if a point is inside this sprite
     *
     * @param {PIXI.Point} point - the point to test
     * @return {boolean} the result of the test
     */
    containsPoint(point) {
        this.worldTransform.applyInverse(point, Sprite.tempPoint);
        var width = this._texture.orig.width;
        var height = this._texture.orig.height;
        var x1 = -width * this.anchor.x;
        var y1 = 0;
        if (Sprite.tempPoint.x >= x1 && Sprite.tempPoint.x < x1 + width) {
            y1 = -height * this.anchor.y;
            if (Sprite.tempPoint.y >= y1 && Sprite.tempPoint.y < y1 + height) {
                return true;
            }
        }
        return false;
    }
    ;
    /**
     * Destroys this sprite and optionally its texture and children
     *
     * @param {object|boolean} [options] - Options parameter. A boolean will act as if all options
     *  have been set to that value
     * @param {boolean} [options.children=false] - if set to true, all the children will have their destroy
     *      method called as well. 'options' will be passed on to those calls.
     * @param {boolean} [options.texture=false] - Should it destroy the current texture of the sprite as well
     * @param {boolean} [options.baseTexture=false] - Should it destroy the base texture of the sprite as well
     */
    destroy(options) {
        super.destroy(options);
        // this._texture.off('update', this._onTextureUpdate, this);
        this._anchor = null;
        var destroyTexture = typeof options === 'boolean' ? options : options && options.texture;
        if (destroyTexture) {
            var destroyBaseTexture = typeof options === 'boolean' ? options : options && options.baseTexture;
            this._texture.destroy(!!destroyBaseTexture);
        }
        this._texture = null;
        this.shader = null;
    }
    ;
    /**
     * If true PixiJS will Math.floor() x/y values when rendering, stopping pixel interpolation.
     * Advantages can include sharper image quality (like text) and faster rendering on canvas.
     * The main disadvantage is movement of objects may appear less smooth.
     * To set the global default, change {@link PIXI.settings.ROUND_PIXELS}
     *
     * @member {boolean}
     * @default false
     */
    set roundPixels(value) {
        if (this._roundPixels !== value) {
            this._transformID = -1;
        }
        this._roundPixels = value;
    }
    ;
    get roundPixels() {
        return this._roundPixels;
    }
    ;
    /**
     * The width of the sprite, setting this will actually modify the scale to achieve the value set
     *
     * @member {number}
     */
    get width() {
        return Math.abs(this.scale.x) * this._texture.orig.width;
    }
    ;
    set width(value) {
        var s = MathSettings_1.MathSettings.sign(this.scale.x) || 1;
        this.scale.x = s * value / this._texture.orig.width;
        this._width = value;
    }
    ;
    /**
     * The height of the sprite, setting this will actually modify the scale to achieve the value set
     *
     * @member {number}
     */
    get height() {
        return Math.abs(this.scale.y) * this._texture.orig.height;
    }
    ;
    set height(value) {
        var s = MathSettings_1.MathSettings.sign(this.scale.y) || 1;
        this.scale.y = s * value / this._texture.orig.height;
        this._height = value;
    }
    ;
    /**
     * The anchor sets the origin point of the text. The default value is taken from the {@link PIXI.Texture|Texture}
     * and passed to the constructor.
     *
     * The default is `(0,0)`, this means the text's origin is the top left.
     *
     * Setting the anchor to `(0.5,0.5)` means the text's origin is centered.
     *
     * Setting the anchor to `(1,1)` would mean the text's origin point will be the bottom right corner.
     *
     * If you pass only single parameter, it will set both x and y to the same value as shown in the example below.
     *
     * @example
     * const sprite = new PIXI.Sprite(texture);
     * sprite.anchor.set(0.5); // This will set the origin to center. (0.5) is same as (0.5, 0.5).
     *
     * @member {PIXI.ObservablePoint}
     */
    get anchor() {
        return this._anchor;
    }
    ;
    set anchor(value) {
        this._anchor.copyFrom(value);
    }
    ;
    /**
     * The tint applied to the sprite. This is a hex value.
     * A value of 0xFFFFFF will remove any tint effect.
     *
     * @member {number}
     * @default 0xFFFFFF
     */
    get tint() {
        return this._tint;
    }
    ;
    set tint(value) {
        this._tint = value;
        this._tintRGB = (value >> 16) + (value & 0xff00) + ((value & 0xff) << 16);
    }
    ;
    /**
     * The texture that the sprite is using
     *
     * @member {PIXI.Texture}
     */
    get texture() {
        return this._texture;
    }
    ;
    set texture(value) {
        if (this._texture === value) {
            return;
        }
        this._texture = value || Texture_1.Texture.EMPTY;
        this.cachedTint = 0xFFFFFF;
        this._textureID = -1;
        this._textureTrimmedID = -1;
        if (value) {
            // wait for the texture to load
            if (value.baseTexture.valid) {
                this._onTextureUpdate();
            }
            else {
                value.addEventListener('update', this._onTextureUpdate);
                // value.once('update', this._onTextureUpdate, this);
            }
        }
    }
    ;
}
Sprite.tempPoint = new Point_1.Point();
Sprite.indices = new Uint16Array([0, 1, 2, 0, 2, 3]);
// some helper functions..
/**
 * Helper function that creates a new sprite based on the source you provide.
 * The source can be - frame id, image url, video url, canvas element, video element, base texture
 *
 * @static
 * @param {number|string|PIXI.Texture|HTMLCanvasElement|HTMLVideoElement} source Source to create texture from
 * @param {object} [options] See {@link PIXI.BaseTexture}'s constructor for options.
 * @return {PIXI.Sprite} The newly created sprite
 */
Sprite.from = function from(source, options = {}) {
    if (options == null) {
        options = {};
    }
    var texture = (source instanceof Texture_1.Texture)
        ? source
        : Texture_1.Texture.from(source, options);
    return new Sprite(texture);
};
exports.Sprite = Sprite;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/SpriteMaskFilter.js":
/*!****************************************************!*\
  !*** ./js-compile/raw-pixi-ts/SpriteMaskFilter.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Filter_1 = __webpack_require__(/*! ./Filter */ "./js-compile/raw-pixi-ts/Filter.js");
const Matrix_1 = __webpack_require__(/*! ./Matrix */ "./js-compile/raw-pixi-ts/Matrix.js");
const TextureMatrix_1 = __webpack_require__(/*! ./TextureMatrix */ "./js-compile/raw-pixi-ts/TextureMatrix.js");
class SpriteMaskFilter extends Filter_1.Filter {
    constructor(sprite) {
        var maskMatrix = new Matrix_1.Matrix();
        super(SpriteMaskFilter.vertex, SpriteMaskFilter.fragment);
        sprite.renderable = false;
        /**
         * Sprite mask
         * @member {PIXI.Sprite}
         */
        this.maskSprite = sprite;
        /**
         * Mask matrix
         * @member {PIXI.Matrix}
         */
        this.maskMatrix = maskMatrix;
    }
    /**
     * Applies the filter
     *
     * @param {PIXI.systems.FilterSystem} filterManager - The renderer to retrieve the filter from
     * @param {PIXI.RenderTexture} input - The input render target.
     * @param {PIXI.RenderTexture} output - The target to output to.
     * @param {boolean} clear - Should the output be cleared before rendering to it.
     */
    apply(filterManager, input, output, clear) {
        var maskSprite = this.maskSprite;
        var tex = this.maskSprite.texture;
        if (!tex.valid) {
            return;
        }
        if (!tex.transform) {
            // margin = 0.0, let it bleed a bit, shader code becomes easier
            // assuming that atlas textures were made with 1-pixel padding
            tex.transform = new TextureMatrix_1.TextureMatrix(tex, 0.0);
        }
        tex.transform.update();
        this.uniforms.npmAlpha = tex.baseTexture.premultiplyAlpha ? 0.0 : 1.0;
        this.uniforms.mask = tex;
        this.uniforms.otherMatrix = filterManager.calculateSpriteMatrix(this.maskMatrix, maskSprite)
            .prepend(tex.transform.mapCoord);
        this.uniforms.alpha = maskSprite.worldAlpha;
        this.uniforms.maskClamp = tex.transform.uClampFrame;
        filterManager.applyFilter(this, input, output, clear);
    }
    ;
}
SpriteMaskFilter.vertex = "attribute vec2 aVertexPosition;\r\nattribute vec2 aTextureCoord;\r\n\r\nuniform mat3 projectionMatrix;\r\nuniform mat3 otherMatrix;\r\n\r\nvarying vec2 vMaskCoord;\r\nvarying vec2 vTextureCoord;\r\n\r\nvoid main(void)\r\n{\r\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\r\n\r\n    vTextureCoord = aTextureCoord;\r\n    vMaskCoord = ( otherMatrix * vec3( aTextureCoord, 1.0)  ).xy;\r\n}\r\n";
SpriteMaskFilter.fragment = "varying vec2 vMaskCoord;\r\nvarying vec2 vTextureCoord;\r\n\r\nuniform sampler2D uSampler;\r\nuniform sampler2D mask;\r\nuniform float alpha;\r\nuniform float npmAlpha;\r\nuniform vec4 maskClamp;\r\n\r\nvoid main(void)\r\n{\r\n    float clip = step(3.5,\r\n        step(maskClamp.x, vMaskCoord.x) +\r\n        step(maskClamp.y, vMaskCoord.y) +\r\n        step(vMaskCoord.x, maskClamp.z) +\r\n        step(vMaskCoord.y, maskClamp.w));\r\n\r\n    vec4 original = texture2D(uSampler, vTextureCoord);\r\n    vec4 masky = texture2D(mask, vMaskCoord);\r\n    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);\r\n\r\n    original *= (alphaMul * masky.r * alpha * clip);\r\n\r\n    gl_FragColor = original;\r\n}\r\n";
exports.SpriteMaskFilter = SpriteMaskFilter;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/Spritesheet.js":
/*!***********************************************!*\
  !*** ./js-compile/raw-pixi-ts/Spritesheet.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Rectangle_1 = __webpack_require__(/*! ./Rectangle */ "./js-compile/raw-pixi-ts/Rectangle.js");
const Texture_1 = __webpack_require__(/*! ./Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const NetworkSettings_1 = __webpack_require__(/*! ./NetworkSettings */ "./js-compile/raw-pixi-ts/NetworkSettings.js");
class Spritesheet {
    constructor(baseTexture, data, resolutionFilename = null) {
        /**
         * Reference to ths source texture
         * @type {PIXI.BaseTexture}
         */
        this.baseTexture = baseTexture;
        /**
         * A map containing all textures of the sprite sheet.
         * Can be used to create a {@link PIXI.Sprite|Sprite}:
         * ```js
         * new PIXI.Sprite(sheet.textures["image.png"]);
         * ```
         * @member {Object}
         */
        this.textures = {};
        /**
         * A map containing the textures for each animation.
         * Can be used to create an {@link PIXI.AnimatedSprite|AnimatedSprite}:
         * ```js
         * new PIXI.AnimatedSprite(sheet.animations["anim_name"])
         * ```
         * @member {Object}
         */
        this.animations = {};
        /**
         * Reference to the original JSON data.
         * @type {Object}
         */
        this.data = data;
        /**
         * The resolution of the spritesheet.
         * @type {number}
         */
        this.resolution = this._updateResolution(resolutionFilename
            || (this.baseTexture.resource ? this.baseTexture.resource.url : null));
        /**
         * Map of spritesheet frames.
         * @type {Object}
         * @private
         */
        this._frames = this.data.frames;
        /**
         * Collection of frame names.
         * @type {string[]}
         * @private
         */
        this._frameKeys = Object.keys(this._frames);
        /**
         * Current batch index being processed.
         * @type {number}
         * @private
         */
        this._batchIndex = 0;
        /**
         * Callback when parse is completed.
         * @type {Function}
         * @private
         */
        this._callback = null;
    }
    _updateResolution(resolutionFilename) {
        var scale = this.data.meta.scale;
        // Use a defaultValue of `null` to check if a url-based resolution is set
        var resolution = NetworkSettings_1.NetworkSettings.getResolutionOfUrl(resolutionFilename, null);
        // No resolution found via URL
        if (resolution === null) {
            // Use the scale value or default to 1
            resolution = scale !== undefined ? parseFloat(scale) : 1;
        }
        // For non-1 resolutions, update baseTexture
        if (resolution !== 1) {
            this.baseTexture.setResolution(resolution);
        }
        return resolution;
    }
    ;
    /**
     * Generate the resolution from the filename or fallback
     * to the meta.scale field of the JSON data.
     *
     * @private
     * @param {string} resolutionFilename - The filename to use for resolving
     *    the default resolution.
     * @return {number} Resolution to use for spritesheet.
     */
    static get BATCH_SIZE() {
        return 1000;
    }
    ;
    /**
     * Parser spritesheet from loaded data. This is done asynchronously
     * to prevent creating too many Texture within a single process.
     *
     * @param {Function} callback - Callback when complete returns
     *    a map of the Textures for this spritesheet.
     */
    parse(callback) {
        this._batchIndex = 0;
        this._callback = callback;
        if (this._frameKeys.length <= Spritesheet.BATCH_SIZE) {
            this._processFrames(0);
            this._processAnimations();
            this._parseComplete();
        }
        else {
            this._nextBatch();
        }
    }
    ;
    /**
     * Process a batch of frames
     *
     * @private
     * @param {number} initialFrameIndex - The index of frame to start.
     */
    _processFrames(initialFrameIndex) {
        var frameIndex = initialFrameIndex;
        var maxFrames = Spritesheet.BATCH_SIZE;
        while (frameIndex - initialFrameIndex < maxFrames && frameIndex < this._frameKeys.length) {
            var i = this._frameKeys[frameIndex];
            var data = this._frames[i];
            var rect = data.frame;
            if (rect) {
                var frame = null;
                var trim = null;
                var sourceSize = data.trimmed !== false && data.sourceSize
                    ? data.sourceSize : data.frame;
                var orig = new Rectangle_1.Rectangle(0, 0, Math.floor(sourceSize.w) / this.resolution, Math.floor(sourceSize.h) / this.resolution);
                if (data.rotated) {
                    frame = new Rectangle_1.Rectangle(Math.floor(rect.x) / this.resolution, Math.floor(rect.y) / this.resolution, Math.floor(rect.h) / this.resolution, Math.floor(rect.w) / this.resolution);
                }
                else {
                    frame = new Rectangle_1.Rectangle(Math.floor(rect.x) / this.resolution, Math.floor(rect.y) / this.resolution, Math.floor(rect.w) / this.resolution, Math.floor(rect.h) / this.resolution);
                }
                //  Check to see if the sprite is trimmed
                if (data.trimmed !== false && data.spriteSourceSize) {
                    trim = new Rectangle_1.Rectangle(Math.floor(data.spriteSourceSize.x) / this.resolution, Math.floor(data.spriteSourceSize.y) / this.resolution, Math.floor(rect.w) / this.resolution, Math.floor(rect.h) / this.resolution);
                }
                this.textures[i] = new Texture_1.Texture(this.baseTexture, frame, orig, trim, data.rotated ? 2 : 0, data.anchor);
                // lets also add the frame to pixi's global cache for fromFrame and fromImage functions
                Texture_1.Texture.addToCache(this.textures[i], i);
            }
            frameIndex++;
        }
    }
    ;
    /**
     * Parse animations config
     *
     * @private
     */
    _processAnimations() {
        var animations = this.data.animations || {};
        for (var animName in animations) {
            this.animations[animName] = [];
            for (var i = 0; i < animations[animName].length; i++) {
                var frameName = animations[animName][i];
                this.animations[animName].push(this.textures[frameName]);
            }
        }
    }
    ;
    /**
     * The parse has completed.
     *
     * @private
     */
    _parseComplete() {
        var callback = this._callback;
        this._callback = null;
        this._batchIndex = 0;
        callback.call(this, this.textures);
    }
    ;
    /**
     * Begin the next batch of textures.
     *
     * @private
     */
    _nextBatch() {
        var this$1 = this;
        this._processFrames(this._batchIndex * Spritesheet.BATCH_SIZE);
        this._batchIndex++;
        setTimeout(function () {
            if (this$1._batchIndex * Spritesheet.BATCH_SIZE < this$1._frameKeys.length) {
                this$1._nextBatch();
            }
            else {
                this$1._processAnimations();
                this$1._parseComplete();
            }
        }, 0);
    }
    ;
    /**
     * Destroy Spritesheet and don't use after this.
     *
     * @param {boolean} [destroyBase=false] Whether to destroy the base texture as well
     */
    destroy(destroyBase) {
        if (destroyBase === void 0) {
            destroyBase = false;
        }
        for (var i in this.textures) {
            this.textures[i].destroy();
        }
        this._frames = null;
        this._frameKeys = null;
        this.data = null;
        this.textures = null;
        if (destroyBase) {
            this.baseTexture.destroy();
        }
        this.baseTexture = null;
    }
    ;
}
exports.Spritesheet = Spritesheet;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/StageOptions.js":
/*!************************************************!*\
  !*** ./js-compile/raw-pixi-ts/StageOptions.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class StageOptions {
    constructor() {
        this.sharedLoader = false;
        this.forceCanvas = false;
        this.view = null;
        this.antialias = false;
        this.forceFXAA = false;
        this.autoDensity = true;
        this.autoResize = true;
        this.transparent = false;
        this.backgroundColor = 0x000000;
        this.clearBeforeRender = true;
        this.autoStart = true;
        this.preserveDrawingBuffer = false;
        this.width = 1024;
        this.height = 768;
        this.resolution = 1;
        this.legacy = false;
        this.roundPixels = false;
        this.sharedTicker = false;
        this.context = null;
        this.resizeTo = null;
        this.powerPreference = "high-performance";
    }
}
exports.StageOptions = StageOptions;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/Star.js":
/*!****************************************!*\
  !*** ./js-compile/raw-pixi-ts/Star.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Polygon_1 = __webpack_require__(/*! ./Polygon */ "./js-compile/raw-pixi-ts/Polygon.js");
const MathSettings_1 = __webpack_require__(/*! ./MathSettings */ "./js-compile/raw-pixi-ts/MathSettings.js");
class Star extends Polygon_1.Polygon {
    constructor(x, y, points, radius, innerRadius, rotation) {
        innerRadius = innerRadius || radius / 2;
        var startAngle = (-1 * Math.PI / 2) + rotation;
        var len = points * 2;
        var delta = MathSettings_1.MathSettings.PI_2 / len;
        var polygon = [];
        for (var i = 0; i < len; i++) {
            var r = i % 2 ? innerRadius : radius;
            var angle = (i * delta) + startAngle;
            polygon.push(x + (r * Math.cos(angle)), y + (r * Math.sin(angle)));
        }
        super(polygon);
    }
}
exports.Star = Star;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/State.js":
/*!*****************************************!*\
  !*** ./js-compile/raw-pixi-ts/State.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BlendModesSettings_1 = __webpack_require__(/*! ./BlendModesSettings */ "./js-compile/raw-pixi-ts/BlendModesSettings.js");
class State {
    constructor() {
        this.data = 0;
        this.blendMode = BlendModesSettings_1.BlendModesSettings.BLEND_MODES.NORMAL;
        this.polygonOffset = 0;
        this.blend = true;
        //  this.depthTest = true;
    }
    /**
     * Activates blending of the computed fragment color values
     *
     * @member {boolean}
     */
    get blend() {
        return !!(this.data & (1 << State.BLEND));
    }
    ;
    set blend(value) {
        if (!!(this.data & (1 << State.BLEND)) !== value) {
            this.data ^= (1 << State.BLEND);
        }
    }
    ;
    /**
     * Activates adding an offset to depth values of polygon's fragments
     *
     * @member {boolean}
     * @default false
     */
    get offsets() {
        return !!(this.data & (1 << State.OFFSET));
    }
    ;
    set offsets(value) {
        if (!!(this.data & (1 << State.OFFSET)) !== value) {
            this.data ^= (1 << State.OFFSET);
        }
    }
    ;
    /**
     * Activates culling of polygons.
     *
     * @member {boolean}
     * @default false
     */
    get culling() {
        return !!(this.data & (1 << State.CULLING));
    }
    ;
    set culling(value) {
        if (!!(this.data & (1 << State.CULLING)) !== value) {
            this.data ^= (1 << State.CULLING);
        }
    }
    ;
    /**
     * Activates depth comparisons and updates to the depth buffer.
     *
     * @member {boolean}
     * @default false
     */
    get depthTest() {
        return !!(this.data & (1 << State.DEPTH_TEST));
    }
    ;
    set depthTest(value) {
        if (!!(this.data & (1 << State.DEPTH_TEST)) !== value) {
            this.data ^= (1 << State.DEPTH_TEST);
        }
    }
    ;
    /**
     * Specifies whether or not front or back-facing polygons can be culled.
     * @member {boolean}
     * @default false
     */
    get clockwiseFrontFace() {
        return !!(this.data & (1 << State.WINDING));
    }
    ;
    set clockwiseFrontFace(value) {
        if (!!(this.data & (1 << State.WINDING)) !== value) {
            this.data ^= (1 << State.WINDING);
        }
    }
    ;
    /**
     * The blend mode to be applied when this state is set. Apply a value of `PIXI.BLEND_MODES.NORMAL` to reset the blend mode.
     * Setting this mode to anything other than NO_BLEND will automatically switch blending on.
     *
     * @member {boolean}
     * @default PIXI.BLEND_MODES.NORMAL
     * @see PIXI.BLEND_MODES
     */
    get blendMode() {
        return this._blendMode;
    }
    ;
    set blendMode(value) {
        this.blend = (value !== BlendModesSettings_1.BlendModesSettings.BLEND_MODES.NONE);
        this._blendMode = value;
    }
    ;
    /**
     * The polygon offset. Setting this property to anything other than 0 will automatically enable polygon offset fill.
     *
     * @member {number}
     * @default 0
     */
    get polygonOffset() {
        return this._polygonOffset;
    }
    ;
    set polygonOffset(value) {
        this.offsets = !!value;
        this._polygonOffset = value;
    }
    ;
    static for2d() {
        var state = new State();
        state.depthTest = false;
        state.blend = true;
        return state;
    }
    ;
}
State.BLEND = 0;
State.OFFSET = 1;
State.CULLING = 2;
State.DEPTH_TEST = 3;
State.WINDING = 4;
exports.State = State;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/StateSystem.js":
/*!***********************************************!*\
  !*** ./js-compile/raw-pixi-ts/StateSystem.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const System_1 = __webpack_require__(/*! ./System */ "./js-compile/raw-pixi-ts/System.js");
const State_1 = __webpack_require__(/*! ./State */ "./js-compile/raw-pixi-ts/State.js");
const BlendModesSettings_1 = __webpack_require__(/*! ./BlendModesSettings */ "./js-compile/raw-pixi-ts/BlendModesSettings.js");
class StateSystem extends System_1.System {
    constructor(renderer) {
        super(renderer);
        /**
         * GL context
         * @member {WebGLRenderingContext}
         * @readonly
         */
        this.gl = null;
        /**
         * State ID
         * @member {number}
         * @readonly
         */
        this.stateId = 0;
        /**
         * Polygon offset
         * @member {number}
         * @readonly
         */
        this.polygonOffset = 0;
        /**
         * Blend mode
         * @member {number}
         * @default PIXI.BLEND_MODES.NONE
         * @readonly
         */
        this.blendMode = BlendModesSettings_1.BlendModesSettings.BLEND_MODES.NONE;
        /**
         * Whether current blend equation is different
         * @member {boolean}
         * @protected
         */
        this._blendEq = false;
        /**
         * Collection of calls
         * @member {function[]}
         * @readonly
         */
        this.map = [];
        // map functions for when we set state..
        this.map[StateSystem.BLEND$1] = this.setBlend;
        this.map[StateSystem.OFFSET$1] = this.setOffset;
        this.map[StateSystem.CULLING$1] = this.setCullFace;
        this.map[StateSystem.DEPTH_TEST$1] = this.setDepthTest;
        this.map[StateSystem.WINDING$1] = this.setFrontFace;
        /**
         * Collection of check calls
         * @member {function[]}
         * @readonly
         */
        this.checks = [];
        /**
         * Default WebGL State
         * @member {PIXI.State}
         * @readonly
         */
        this.defaultState = new State_1.State();
        this.defaultState.blend = true;
        this.defaultState.depth = true;
    }
    contextChange(gl) {
        this.gl = gl;
        this.blendModes = BlendModesSettings_1.BlendModesSettings.mapWebGLBlendModesToPixi(gl);
        this.setState(this.defaultState);
        this.reset();
    }
    ;
    /**
     * Sets the current state
     *
     * @param {*} state - The state to set.
     */
    setState(state) {
        state = state || this.defaultState;
        // TODO maybe to an object check? ( this.state === state )?
        if (this.stateId !== state.data) {
            var diff = this.stateId ^ state.data;
            var i = 0;
            // order from least to most common
            while (diff) {
                if (diff & 1) {
                    // state change!
                    this.map[i].call(this, !!(state.data & (1 << i)));
                }
                diff = diff >> 1;
                i++;
            }
            this.stateId = state.data;
        }
        // based on the above settings we check for specific modes..
        // for example if blend is active we check and set the blend modes
        // or of polygon offset is active we check the poly depth.
        for (var i$1 = 0; i$1 < this.checks.length; i$1++) {
            this.checks[i$1](this, state);
        }
    }
    ;
    /**
     * Sets the state, when previous state is unknown
     *
     * @param {*} state - The state to set
     */
    forceState(state) {
        state = state || this.defaultState;
        for (var i = 0; i < this.map.length; i++) {
            this.map[i].call(this, !!(state.data & (1 << i)));
        }
        for (var i$1 = 0; i$1 < this.checks.length; i$1++) {
            this.checks[i$1](this, state);
        }
        this.stateId = state.data;
    }
    ;
    /**
     * Enables or disabled blending.
     *
     * @param {boolean} value - Turn on or off webgl blending.
     */
    setBlend(value) {
        this.updateCheck(StateSystem.checkBlendMode, value);
        this.gl[value ? 'enable' : 'disable'](this.gl.BLEND);
    }
    ;
    /**
     * Enables or disable polygon offset fill
     *
     * @param {boolean} value - Turn on or off webgl polygon offset testing.
     */
    setOffset(value) {
        this.gl[value ? 'enable' : 'disable'](this.gl.POLYGON_OFFSET_FILL);
    }
    ;
    /**
     * Sets whether to enable or disable depth test.
     *
     * @param {boolean} value - Turn on or off webgl depth testing.
     */
    setDepthTest(value) {
        this.gl[value ? 'enable' : 'disable'](this.gl.DEPTH_TEST);
    }
    ;
    /**
     * Sets whether to enable or disable cull face.
     *
     * @param {boolean} value - Turn on or off webgl cull face.
     */
    setCullFace(value) {
        this.gl[value ? 'enable' : 'disable'](this.gl.CULL_FACE);
    }
    ;
    /**
     * Sets the gl front face.
     *
     * @param {boolean} value - true is clockwise and false is counter-clockwise
     */
    setFrontFace(value) {
        this.gl.frontFace(this.gl[value ? 'CW' : 'CCW']);
    }
    ;
    /**
     * Sets the blend mode.
     *
     * @param {number} value - The blend mode to set to.
     */
    setBlendMode(value) {
        if (value === this.blendMode) {
            return;
        }
        this.blendMode = value;
        var mode = this.blendModes[value];
        var gl = this.gl;
        if (mode.length === 2) {
            gl.blendFunc(mode[0], mode[1]);
        }
        else {
            gl.blendFuncSeparate(mode[0], mode[1], mode[2], mode[3]);
        }
        if (mode.length === 6) {
            this._blendEq = true;
            gl.blendEquationSeparate(mode[4], mode[5]);
        }
        else if (this._blendEq) {
            this._blendEq = false;
            gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
        }
    }
    ;
    /**
     * Sets the polygon offset.
     *
     * @param {number} value - the polygon offset
     * @param {number} scale - the polygon offset scale
     */
    setPolygonOffset(value, scale) {
        this.gl.polygonOffset(value, scale);
    }
    ;
    // used
    /**
     * Resets all the logic and disables the vaos
     */
    reset() {
        this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, false);
        this.forceState(0);
        this._blendEq = true;
        this.blendMode = -1;
        this.setBlendMode(0);
    }
    ;
    /**
     * checks to see which updates should be checked based on which settings have been activated.
     * For example, if blend is enabled then we should check the blend modes each time the state is changed
     * or if polygon fill is activated then we need to check if the polygon offset changes.
     * The idea is that we only check what we have too.
     *
     * @param {Function} func  the checking function to add or remove
     * @param {boolean} value  should the check function be added or removed.
     */
    updateCheck(func, value) {
        var index = this.checks.indexOf(func);
        if (value && index === -1) {
            this.checks.push(func);
        }
        else if (!value && index !== -1) {
            this.checks.splice(index, 1);
        }
    }
    ;
    /**
     * A private little wrapper function that we call to check the blend mode.
     *
     * @static
     * @private
     * @param {PIXI.StateSystem} System  the System to perform the state check on
     * @param {PIXI.State} state  the state that the blendMode will pulled from
     */
    static checkBlendMode(system, state) {
        system.setBlendMode(state.blendMode);
    }
    ;
}
StateSystem.UID$4 = 0;
StateSystem.BLEND$1 = 0;
StateSystem.OFFSET$1 = 1;
StateSystem.CULLING$1 = 2;
StateSystem.DEPTH_TEST$1 = 3;
StateSystem.WINDING$1 = 4;
exports.StateSystem = StateSystem;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/StencilSystem.js":
/*!*************************************************!*\
  !*** ./js-compile/raw-pixi-ts/StencilSystem.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const System_1 = __webpack_require__(/*! ./System */ "./js-compile/raw-pixi-ts/System.js");
class StencilSystem extends System_1.System {
    constructor(renderer) {
        super(renderer);
        this.stencilMaskStack = [];
    }
    /**
     * Changes the mask stack that is used by this System.
     *
     * @param {PIXI.Graphics[]} stencilMaskStack - The mask stack
     */
    setMaskStack(stencilMaskStack) {
        var gl = this.renderer.gl;
        if (stencilMaskStack.length !== this.stencilMaskStack.length) {
            if (stencilMaskStack.length === 0) {
                gl.disable(gl.STENCIL_TEST);
            }
            else {
                gl.enable(gl.STENCIL_TEST);
            }
        }
        this.stencilMaskStack = stencilMaskStack;
    }
    ;
    /**
     * Applies the Mask and adds it to the current stencil stack. @alvin
     *
     * @param {PIXI.Graphics} graphics - The mask
     */
    pushStencil(graphics) {
        var gl = this.renderer.gl;
        var prevMaskCount = this.stencilMaskStack.length;
        if (prevMaskCount === 0) {
            gl.enable(gl.STENCIL_TEST);
        }
        this.stencilMaskStack.push(graphics);
        // Increment the reference stencil value where the new mask overlaps with the old ones.
        gl.colorMask(false, false, false, false);
        gl.stencilFunc(gl.EQUAL, prevMaskCount, this._getBitwiseMask());
        gl.stencilOp(gl.KEEP, gl.KEEP, gl.INCR);
        graphics.renderable = true;
        graphics.render(this.renderer);
        this.renderer.batch.flush();
        graphics.renderable = false;
        this._useCurrent();
    }
    ;
    /**
     * Removes the last mask from the stencil stack. @alvin
     */
    popStencil() {
        var gl = this.renderer.gl;
        var graphics = this.stencilMaskStack.pop();
        if (this.stencilMaskStack.length === 0) {
            // the stack is empty!
            gl.disable(gl.STENCIL_TEST);
            gl.clear(gl.STENCIL_BUFFER_BIT);
            gl.clearStencil(0);
        }
        else {
            // Decrement the reference stencil value where the popped mask overlaps with the other ones
            gl.colorMask(false, false, false, false);
            gl.stencilOp(gl.KEEP, gl.KEEP, gl.DECR);
            graphics.renderable = true;
            graphics.render(this.renderer);
            this.renderer.batch.flush();
            graphics.renderable = false;
            this._useCurrent();
        }
    }
    ;
    /**
     * Setup renderer to use the current stencil data.
     * @private
     */
    _useCurrent() {
        var gl = this.renderer.gl;
        gl.colorMask(true, true, true, true);
        gl.stencilFunc(gl.EQUAL, this.stencilMaskStack.length, this._getBitwiseMask());
        gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
    }
    ;
    /**
     * Fill 1s equal to the number of acitve stencil masks.
     * @private
     * @return {number} The bitwise mask.
     */
    _getBitwiseMask() {
        return (1 << this.stencilMaskStack.length) - 1;
    }
    ;
    /**
     * Destroys the mask stack.
     *
     */
    destroy() {
        super.destroy();
        this.stencilMaskStack = null;
    }
    ;
}
exports.StencilSystem = StencilSystem;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/System.js":
/*!******************************************!*\
  !*** ./js-compile/raw-pixi-ts/System.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const EventDispatcher_1 = __webpack_require__(/*! ./EventDispatcher */ "./js-compile/raw-pixi-ts/EventDispatcher.js");
class System extends EventDispatcher_1.EventDispatcher {
    constructor(renderer = null) {
        super();
        this.renderer = renderer;
        this.renderer.runners.contextChange.add(this);
    }
    contextChange(gl) {
    }
    ;
    destroy(options = null) {
        this.renderer.runners.contextChange.remove(this);
        this.renderer = null;
    }
    ;
}
exports.System = System;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/Text.js":
/*!****************************************!*\
  !*** ./js-compile/raw-pixi-ts/Text.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Sprite_1 = __webpack_require__(/*! ./Sprite */ "./js-compile/raw-pixi-ts/Sprite.js");
const Texture_1 = __webpack_require__(/*! ./Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const Rectangle_1 = __webpack_require__(/*! ./Rectangle */ "./js-compile/raw-pixi-ts/Rectangle.js");
const TextMetrics_1 = __webpack_require__(/*! ./TextMetrics */ "./js-compile/raw-pixi-ts/TextMetrics.js");
const TextStyle_1 = __webpack_require__(/*! ./TextStyle */ "./js-compile/raw-pixi-ts/TextStyle.js");
const DisplaySettings_1 = __webpack_require__(/*! ./DisplaySettings */ "./js-compile/raw-pixi-ts/DisplaySettings.js");
const MathSettings_1 = __webpack_require__(/*! ./MathSettings */ "./js-compile/raw-pixi-ts/MathSettings.js");
const CanvasSettings_1 = __webpack_require__(/*! ./CanvasSettings */ "./js-compile/raw-pixi-ts/CanvasSettings.js");
const TextSettings_1 = __webpack_require__(/*! ./TextSettings */ "./js-compile/raw-pixi-ts/TextSettings.js");
const CleanUpSettings_1 = __webpack_require__(/*! ./CleanUpSettings */ "./js-compile/raw-pixi-ts/CleanUpSettings.js");
const ColorSettings_1 = __webpack_require__(/*! ./ColorSettings */ "./js-compile/raw-pixi-ts/ColorSettings.js");
class Text extends Sprite_1.Sprite {
    constructor(text, style = null, canvas = null) {
        canvas = canvas || document.createElement('canvas');
        canvas.width = 3;
        canvas.height = 3;
        var texture = Texture_1.Texture.from(canvas);
        texture.orig = new Rectangle_1.Rectangle();
        texture.trim = new Rectangle_1.Rectangle();
        super(texture);
        /**
         * The canvas element that everything is drawn to
         *
         * @member {HTMLCanvasElement}
         */
        this.canvas = canvas;
        /**
         * The canvas 2d context that everything is drawn with
         * @member {CanvasRenderingContext2D}
         */
        this.context = this.canvas.getContext('2d');
        /**
         * The resolution / device pixel ratio of the canvas.
         * This is set to automatically match the renderer resolution by default, but can be overridden by setting manually.
         * @member {number}
         * @default 1
         */
        this._resolution = DisplaySettings_1.DisplaySettings.RESOLUTION;
        this._autoResolution = true;
        /**
         * Private tracker for the current text.
         *
         * @member {string}
         * @private
         */
        this._text = null;
        /**
         * Private tracker for the current style.
         *
         * @member {object}
         * @private
         */
        this._style = null;
        /**
         * Private listener to track style changes.
         *
         * @member {Function}
         * @private
         */
        this._styleListener = null;
        /**
         * Private tracker for the current font.
         *
         * @member {string}
         * @private
         */
        this._font = '';
        this.text = text;
        this.style = style;
        this.localStyleID = -1;
    }
    /**
     * Renders text and updates it when needed.
     *
     * @private
     * @param {boolean} respectDirty - Whether to abort updating the text if the Text isn't dirty and the function is called.
     */
    updateText(respectDirty) {
        var style = this._style;
        // check if style has changed..
        if (this.localStyleID !== style.styleID) {
            this.dirty = true;
            this.localStyleID = style.styleID;
        }
        if (!this.dirty && respectDirty) {
            return;
        }
        this._font = this._style.toFontString();
        var context = this.context;
        TextMetrics_1.TextMetrics.init();
        var measured = TextMetrics_1.TextMetrics.measureText(this._text || ' ', this._style, this._style.wordWrap, this.canvas);
        var width = measured.width;
        var height = measured.height;
        var lines = measured.lines;
        var lineHeight = measured.lineHeight;
        var lineWidths = measured.lineWidths;
        var maxLineWidth = measured.maxLineWidth;
        var fontProperties = measured.fontProperties;
        this.canvas.width = Math.ceil((Math.max(1, width) + (style.padding * 2)) * this._resolution);
        this.canvas.height = Math.ceil((Math.max(1, height) + (style.padding * 2)) * this._resolution);
        context.scale(this._resolution, this._resolution);
        context.clearRect(0, 0, this.canvas.width, this.canvas.height);
        context.font = this._font;
        context.strokeStyle = style.stroke;
        context.lineWidth = style.strokeThickness;
        context.textBaseline = style.textBaseline;
        context.lineJoin = style.lineJoin;
        context.miterLimit = style.miterLimit;
        var linePositionX;
        var linePositionY;
        if (style.dropShadow) {
            var dropShadowColor = style.dropShadowColor;
            var rgb = ColorSettings_1.ColorSettings.hex2rgb(typeof dropShadowColor === 'number' ? dropShadowColor : MathSettings_1.MathSettings.string2hex(dropShadowColor));
            context.shadowColor = "rgba(" + (rgb[0] * 255) + "," + (rgb[1] * 255) + "," + (rgb[2] * 255) + "," + (style.dropShadowAlpha) + ")";
            context.shadowBlur = style.dropShadowBlur;
            context.shadowOffsetX = Math.cos(style.dropShadowAngle) * style.dropShadowDistance;
            context.shadowOffsetY = Math.sin(style.dropShadowAngle) * style.dropShadowDistance;
        }
        else {
            context.shadowColor = 0;
            context.shadowBlur = 0;
            context.shadowOffsetX = 0;
            context.shadowOffsetY = 0;
        }
        // set canvas text styles
        context.fillStyle = this._generateFillStyle(style, lines);
        // draw lines line by line
        for (var i = 0; i < lines.length; i++) {
            linePositionX = style.strokeThickness / 2;
            linePositionY = ((style.strokeThickness / 2) + (i * lineHeight)) + fontProperties.ascent;
            if (style.align === 'right') {
                linePositionX += maxLineWidth - lineWidths[i];
            }
            else if (style.align === 'center') {
                linePositionX += (maxLineWidth - lineWidths[i]) / 2;
            }
            if (style.stroke && style.strokeThickness) {
                this.drawLetterSpacing(lines[i], linePositionX + style.padding, linePositionY + style.padding, true);
            }
            if (style.fill) {
                this.drawLetterSpacing(lines[i], linePositionX + style.padding, linePositionY + style.padding);
            }
        }
        this.updateTexture();
    }
    ;
    /**
     * Render the text with letter-spacing.
     * @param {string} text - The text to draw
     * @param {number} x - Horizontal position to draw the text
     * @param {number} y - Vertical position to draw the text
     * @param {boolean} [isStroke=false] - Is this drawing for the outside stroke of the
     *  text? If not, it's for the inside fill
     * @private
     */
    drawLetterSpacing(text, x, y, isStroke = false) {
        if (isStroke === void 0) {
            isStroke = false;
        }
        var style = this._style;
        // letterSpacing of 0 means normal
        var letterSpacing = style.letterSpacing;
        if (letterSpacing === 0) {
            if (isStroke) {
                this.context.strokeText(text, x, y);
            }
            else {
                this.context.fillText(text, x, y);
            }
            return;
        }
        var characters = String.prototype.split.call(text, '');
        var currentPosition = x;
        var index = 0;
        var current = '';
        while (index < text.length) {
            current = characters[index++];
            if (isStroke) {
                this.context.strokeText(current, currentPosition, y);
            }
            else {
                this.context.fillText(current, currentPosition, y);
            }
            currentPosition += this.context.measureText(current).width + letterSpacing;
        }
    }
    ;
    /**
     * Updates texture size based on canvas size
     *
     * @private
     */
    updateTexture() {
        var canvas = this.canvas;
        if (this._style.trim) {
            var trimmed = CanvasSettings_1.CanvasSettings.trimCanvas(canvas);
            if (trimmed.data) {
                canvas.width = trimmed.width;
                canvas.height = trimmed.height;
                this.context.putImageData(trimmed.data, 0, 0);
            }
        }
        var texture = this._texture;
        var style = this._style;
        var padding = style.trim ? 0 : style.padding;
        var baseTexture = texture.baseTexture;
        texture.trim.width = texture._frame.width = canvas.width / this._resolution;
        texture.trim.height = texture._frame.height = canvas.height / this._resolution;
        texture.trim.x = -padding;
        texture.trim.y = -padding;
        texture.orig.width = texture._frame.width - (padding * 2);
        texture.orig.height = texture._frame.height - (padding * 2);
        // call sprite onTextureUpdate to update scale if _width or _height were set
        this._onTextureUpdate();
        baseTexture.setRealSize(canvas.width, canvas.height, this._resolution);
        this.dirty = false;
    }
    ;
    /**
     * Renders the object using the WebGL renderer
     *
     * @param {PIXI.Renderer} renderer - The renderer
     */
    render(renderer) {
        if (this._autoResolution && this._resolution !== renderer.resolution) {
            this._resolution = renderer.resolution;
            this.dirty = true;
        }
        this.updateText(true);
        super.render(renderer);
    }
    ;
    /**
     * Renders the object using the Canvas renderer
     *
     * @private
     * @param {PIXI.CanvasRenderer} renderer - The renderer
     */
    _renderCanvas(renderer) {
        if (this._autoResolution && this._resolution !== renderer.resolution) {
            this._resolution = renderer.resolution;
            this.dirty = true;
        }
        this.updateText(true);
        // super._renderCanvas(renderer);
    }
    ;
    /**
     * Gets the local bounds of the text object.
     *
     * @param {Rectangle} rect - The output rectangle.
     * @return {Rectangle} The bounds.
     */
    getLocalBounds(rect) {
        this.updateText(true);
        return super.getLocalBounds(rect);
    }
    ;
    /**
     * calculates the bounds of the Text as a rectangle. The bounds calculation takes the worldTransform into account.
     * @protected
     */
    _calculateBounds() {
        this.updateText(true);
        this.calculateVertices();
        // if we have already done this on THIS frame.
        this._bounds.addQuad(this.vertexData);
    }
    ;
    /**
     * Method to be called upon a TextStyle change.
     * @private
     */
    _onStyleChange() {
        this.dirty = true;
    }
    ;
    /**
     * Generates the fill style. Can automatically generate a gradient based on the fill style being an array
     *
     * @private
     * @param {object} style - The style.
     * @param {string[]} lines - The lines of text.
     * @return {string|number|CanvasGradient} The fill style
     */
    _generateFillStyle(style, lines) {
        if (!Array.isArray(style.fill)) {
            return style.fill;
        }
        // the gradient will be evenly spaced out according to how large the array is.
        // ['#FF0000', '#00FF00', '#0000FF'] would created stops at 0.25, 0.5 and 0.75
        var gradient;
        var totalIterations;
        var currentIteration;
        var stop;
        var width = this.canvas.width / this._resolution;
        var height = this.canvas.height / this._resolution;
        // make a copy of the style settings, so we can manipulate them later
        var fill = style.fill.slice();
        var fillGradientStops = style.fillGradientStops.slice();
        // wanting to evenly distribute the fills. So an array of 4 colours should give fills of 0.25, 0.5 and 0.75
        if (!fillGradientStops.length) {
            var lengthPlus1 = fill.length + 1;
            for (var i = 1; i < lengthPlus1; ++i) {
                fillGradientStops.push(i / lengthPlus1);
            }
        }
        // stop the bleeding of the last gradient on the line above to the top gradient of the this line
        // by hard defining the first gradient colour at point 0, and last gradient colour at point 1
        fill.unshift(style.fill[0]);
        fillGradientStops.unshift(0);
        fill.push(style.fill[style.fill.length - 1]);
        fillGradientStops.push(1);
        if (style.fillGradientType === TextSettings_1.TextSettings.TEXT_GRADIENT.LINEAR_VERTICAL) {
            // start the gradient at the top center of the canvas, and end at the bottom middle of the canvas
            gradient = this.context.createLinearGradient(width / 2, 0, width / 2, height);
            // we need to repeat the gradient so that each individual line of text has the same vertical gradient effect
            // ['#FF0000', '#00FF00', '#0000FF'] over 2 lines would create stops at 0.125, 0.25, 0.375, 0.625, 0.75, 0.875
            totalIterations = (fill.length + 1) * lines.length;
            currentIteration = 0;
            for (var i$1 = 0; i$1 < lines.length; i$1++) {
                currentIteration += 1;
                for (var j = 0; j < fill.length; j++) {
                    if (typeof fillGradientStops[j] === 'number') {
                        stop = (fillGradientStops[j] / lines.length) + (i$1 / lines.length);
                    }
                    else {
                        stop = currentIteration / totalIterations;
                    }
                    gradient.addColorStop(stop, fill[j]);
                    currentIteration++;
                }
            }
        }
        else {
            // start the gradient at the center left of the canvas, and end at the center right of the canvas
            gradient = this.context.createLinearGradient(0, height / 2, width, height / 2);
            // can just evenly space out the gradients in this case, as multiple lines makes no difference
            // to an even left to right gradient
            totalIterations = fill.length + 1;
            currentIteration = 1;
            for (var i$2 = 0; i$2 < fill.length; i$2++) {
                if (typeof fillGradientStops[i$2] === 'number') {
                    stop = fillGradientStops[i$2];
                }
                else {
                    stop = currentIteration / totalIterations;
                }
                gradient.addColorStop(stop, fill[i$2]);
                currentIteration++;
            }
        }
        return gradient;
    }
    ;
    /**
     * Destroys this text object.
     * Note* Unlike a Sprite, a Text object will automatically destroy its baseTexture and texture as
     * the majority of the time the texture will not be shared with any other Sprites.
     *
     * @param {object|boolean} [options] - Options parameter. A boolean will act as if all options
     *  have been set to that value
     * @param {boolean} [options.children=false] - if set to true, all the children will have their
     *  destroy method called as well. 'options' will be passed on to those calls.
     * @param {boolean} [options.texture=true] - Should it destroy the current texture of the sprite as well
     * @param {boolean} [options.baseTexture=true] - Should it destroy the base texture of the sprite as well
     */
    destroy(options) {
        if (typeof options === 'boolean') {
            options = { children: options };
        }
        options = Object.assign({}, CleanUpSettings_1.CleanUpSettings.defaultDestroyOptions, options);
        super.destroy(options);
        // make sure to reset the the context and canvas.. dont want this hanging around in memory!
        this.context = null;
        this.canvas = null;
        this._style = null;
    }
    ;
    /**
     * The width of the Text, setting this will actually modify the scale to achieve the value set
     *
     * @member {number}
     */
    get width() {
        this.updateText(true);
        return Math.abs(this.scale.x) * this._texture.orig.width;
    }
    ;
    set width(value) {
        this.updateText(true);
        var s = MathSettings_1.MathSettings.sign(this.scale.x) || 1;
        this.scale.x = s * value / this._texture.orig.width;
        this._width = value;
    }
    ;
    /**
     * The height of the Text, setting this will actually modify the scale to achieve the value set
     *
     * @member {number}
     */
    get height() {
        this.updateText(true);
        return Math.abs(this.scale.y) * this._texture.orig.height;
    }
    ;
    set height(value) {
        this.updateText(true);
        var s = MathSettings_1.MathSettings.sign(this.scale.y) || 1;
        this.scale.y = s * value / this._texture.orig.height;
        this._height = value;
    }
    ;
    /**
     * Set the style of the text. Set up an event listener to listen for changes on the style
     * object and mark the text as dirty.
     *
     * @member {object|PIXI.TextStyle}
     */
    get style() {
        return this._style;
    }
    ;
    set style(style) {
        style = style || {};
        if (style instanceof TextStyle_1.TextStyle) {
            this._style = style;
        }
        else {
            this._style = new TextStyle_1.TextStyle(style);
        }
        this.localStyleID = -1;
        this.dirty = true;
    }
    ;
    /**
     * Set the copy for the text object. To split a line you can use '\n'.
     *
     * @member {string}
     */
    get text() {
        return this._text;
    }
    ;
    set text(text) {
        text = String(text === null || text === undefined ? '' : text);
        if (this._text === text) {
            return;
        }
        this._text = text;
        this.dirty = true;
    }
    ;
    /**
     * The resolution / device pixel ratio of the canvas.
     * This is set to automatically match the renderer resolution by default, but can be overridden by setting manually.
     * @member {number}
     * @default 1
     */
    get resolution() {
        return this._resolution;
    }
    ;
    set resolution(value) {
        this._autoResolution = false;
        if (this._resolution === value) {
            return;
        }
        this._resolution = value;
        this.dirty = true;
    }
    ;
}
exports.Text = Text;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/TextMetrics.js":
/*!***********************************************!*\
  !*** ./js-compile/raw-pixi-ts/TextMetrics.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class TextMetrics {
    constructor(text, style, width, height, lines, lineWidths, lineHeight, maxLineWidth, fontProperties) {
        if (!TextMetrics.canvas) {
            TextMetrics.canvas = document.createElement('canvas');
            TextMetrics.canvas.width = TextMetrics.canvas.height = 10;
            TextMetrics._canvas = TextMetrics.canvas;
            TextMetrics._context = TextMetrics.canvas.getContext('2d');
        }
        this.text = text;
        this.style = style;
        this.width = width;
        this.height = height;
        this.lines = lines;
        this.lineWidths = lineWidths;
        this.lineHeight = lineHeight;
        this.maxLineWidth = maxLineWidth;
        this.fontProperties = fontProperties;
    }
    static init() {
        if (!TextMetrics.canvas) {
            TextMetrics.canvas = document.createElement('canvas');
            TextMetrics.canvas.width = TextMetrics.canvas.height = 10;
            TextMetrics._canvas = TextMetrics.canvas;
            TextMetrics._context = TextMetrics.canvas.getContext('2d');
        }
    }
    /**
     * Measures the supplied string of text and returns a Rectangle.
     *
     * @param {string} text - the text to measure.
     * @param {PIXI.TextStyle} style - the text style to use for measuring
     * @param {boolean} [wordWrap] - optional override for if word-wrap should be applied to the text.
     * @param {HTMLCanvasElement} [canvas] - optional specification of the canvas to use for measuring.
     * @return {PIXI.TextMetrics} measured width and height of the text.
     */
    static measureText(text, style, wordWrap, canvas = TextMetrics._canvas) {
        wordWrap = (wordWrap === undefined || wordWrap === null) ? style.wordWrap : wordWrap;
        var font = style.toFontString();
        var fontProperties = TextMetrics.measureFont(font);
        // fallback in case UA disallow canvas data extraction
        // (toDataURI, getImageData functions)
        if (fontProperties.fontSize === 0) {
            fontProperties.fontSize = style.fontSize;
            fontProperties.ascent = style.fontSize;
        }
        var context = canvas.getContext('2d');
        context.font = font;
        var outputText = wordWrap ? TextMetrics.wordWrap(text, style, canvas) : text;
        var lines = outputText.split(/(?:\r\n|\r|\n)/);
        var lineWidths = new Array(lines.length);
        var maxLineWidth = 0;
        for (var i = 0; i < lines.length; i++) {
            var lineWidth = context.measureText(lines[i]).width + ((lines[i].length - 1) * style.letterSpacing);
            lineWidths[i] = lineWidth;
            maxLineWidth = Math.max(maxLineWidth, lineWidth);
        }
        var width = maxLineWidth + style.strokeThickness;
        if (style.dropShadow) {
            width += style.dropShadowDistance;
        }
        var lineHeight = style.lineHeight || fontProperties.fontSize + style.strokeThickness;
        var height = Math.max(lineHeight, fontProperties.fontSize + style.strokeThickness)
            + ((lines.length - 1) * (lineHeight + style.leading));
        if (style.dropShadow) {
            height += style.dropShadowDistance;
        }
        return new TextMetrics(text, style, width, height, lines, lineWidths, lineHeight + style.leading, maxLineWidth, fontProperties);
    }
    ;
    /**
     * Applies newlines to a string to have it optimally fit into the horizontal
     * bounds set by the Text object's wordWrapWidth property.
     *
     * @private
     * @param {string} text - String to apply word wrapping to
     * @param {PIXI.TextStyle} style - the style to use when wrapping
     * @param {HTMLCanvasElement} [canvas] - optional specification of the canvas to use for measuring.
     * @return {string} New string with new lines applied where required
     */
    static wordWrap(text, style, canvas) {
        if (canvas === void 0) {
            canvas = TextMetrics._canvas;
        }
        var context = canvas.getContext('2d');
        var width = 0;
        var line = '';
        var lines = '';
        var cache = {};
        var letterSpacing = style.letterSpacing;
        var whiteSpace = style.whiteSpace;
        // How to handle whitespaces
        var collapseSpaces = TextMetrics.collapseSpaces(whiteSpace);
        var collapseNewlines = TextMetrics.collapseNewlines(whiteSpace);
        // whether or not spaces may be added to the beginning of lines
        var canPrependSpaces = !collapseSpaces;
        // There is letterSpacing after every char except the last one
        // t_h_i_s_' '_i_s_' '_a_n_' '_e_x_a_m_p_l_e_' '_!
        // so for convenience the above needs to be compared to width + 1 extra letterSpace
        // t_h_i_s_' '_i_s_' '_a_n_' '_e_x_a_m_p_l_e_' '_!_
        // ________________________________________________
        // And then the final space is simply no appended to each line
        var wordWrapWidth = style.wordWrapWidth + letterSpacing;
        // break text into words, spaces and newline chars
        var tokens = TextMetrics.tokenize(text);
        for (var i = 0; i < tokens.length; i++) {
            // get the word, space or newlineChar
            var token = tokens[i];
            // if word is a new line
            if (TextMetrics.isNewline(token)) {
                // keep the new line
                if (!collapseNewlines) {
                    lines += TextMetrics.addLine(line);
                    canPrependSpaces = !collapseSpaces;
                    line = '';
                    width = 0;
                    continue;
                }
                // if we should collapse new lines
                // we simply convert it into a space
                token = ' ';
            }
            // if we should collapse repeated whitespaces
            if (collapseSpaces) {
                // check both this and the last tokens for spaces
                var currIsBreakingSpace = TextMetrics.isBreakingSpace(token);
                var lastIsBreakingSpace = TextMetrics.isBreakingSpace(line[line.length - 1]);
                if (currIsBreakingSpace && lastIsBreakingSpace) {
                    continue;
                }
            }
            // get word width from cache if possible
            var tokenWidth = TextMetrics.getFromCache(token, letterSpacing, cache, context);
            // word is longer than desired bounds
            if (tokenWidth > wordWrapWidth) {
                // if we are not already at the beginning of a line
                if (line !== '') {
                    // start newlines for overflow words
                    lines += TextMetrics.addLine(line);
                    line = '';
                    width = 0;
                }
                // break large word over multiple lines
                if (TextMetrics.canBreakWords(token, style.breakWords)) {
                    // break word into characters
                    var characters = token.split('');
                    // loop the characters
                    for (var j = 0; j < characters.length; j++) {
                        var char = characters[j];
                        var k = 1;
                        // we are not at the end of the token
                        while (characters[j + k]) {
                            var nextChar = characters[j + k];
                            var lastChar = char[char.length - 1];
                            // should not split chars
                            if (!TextMetrics.canBreakChars(lastChar, nextChar, token, j, style.breakWords)) {
                                // combine chars & move forward one
                                char += nextChar;
                            }
                            else {
                                break;
                            }
                            k++;
                        }
                        j += char.length - 1;
                        var characterWidth = TextMetrics.getFromCache(char, letterSpacing, cache, context);
                        if (characterWidth + width > wordWrapWidth) {
                            lines += TextMetrics.addLine(line);
                            canPrependSpaces = false;
                            line = '';
                            width = 0;
                        }
                        line += char;
                        width += characterWidth;
                    }
                }
                // run word out of the bounds
                else {
                    // if there are words in this line already
                    // finish that line and start a new one
                    if (line.length > 0) {
                        lines += TextMetrics.addLine(line);
                        line = '';
                        width = 0;
                    }
                    var isLastToken = i === tokens.length - 1;
                    // give it its own line if it's not the end
                    lines += TextMetrics.addLine(token, !isLastToken);
                    canPrependSpaces = false;
                    line = '';
                    width = 0;
                }
            }
            // word could fit
            else {
                // word won't fit because of existing words
                // start a new line
                if (tokenWidth + width > wordWrapWidth) {
                    // if its a space we don't want it
                    canPrependSpaces = false;
                    // add a new line
                    lines += TextMetrics.addLine(line);
                    // start a new line
                    line = '';
                    width = 0;
                }
                // don't add spaces to the beginning of lines
                if (line.length > 0 || !TextMetrics.isBreakingSpace(token) || canPrependSpaces) {
                    // add the word to the current line
                    line += token;
                    // update width counter
                    width += tokenWidth;
                }
            }
        }
        lines += TextMetrics.addLine(line, false);
        return lines;
    }
    ;
    /**
     * Convienience function for logging each line added during the wordWrap
     * method
     *
     * @private
     * @param  {string}   line    - The line of text to add
     * @param  {boolean}  newLine - Add new line character to end
     * @return {string}   A formatted line
     */
    static addLine(line, newLine = true) {
        if (newLine === void 0) {
            newLine = true;
        }
        line = TextMetrics.trimRight(line);
        line = (newLine) ? (line + "\n") : line;
        return line;
    }
    ;
    /**
     * Gets & sets the widths of calculated characters in a cache object
     *
     * @private
     * @param  {string}                key        The key
     * @param  {number}                letterSpacing  The letter spacing
     * @param  {object}                cache      The cache
     * @param  {CanvasRenderingContext2D}  context    The canvas context
     * @return {number}                The from cache.
     */
    static getFromCache(key, letterSpacing, cache, context) {
        var width = cache[key];
        if (width === undefined) {
            var spacing = ((key.length) * letterSpacing);
            width = context.measureText(key).width + spacing;
            cache[key] = width;
        }
        return width;
    }
    ;
    /**
     * Determines whether we should collapse breaking spaces
     *
     * @private
     * @param  {string}   whiteSpace  The TextStyle property whiteSpace
     * @return {boolean}  should collapse
     */
    static collapseSpaces(whiteSpace) {
        return (whiteSpace === 'normal' || whiteSpace === 'pre-line');
    }
    ;
    /**
     * Determines whether we should collapse newLine chars
     *
     * @private
     * @param  {string}   whiteSpace  The white space
     * @return {boolean}  should collapse
     */
    static collapseNewlines(whiteSpace) {
        return (whiteSpace === 'normal');
    }
    ;
    /**
     * trims breaking whitespaces from string
     *
     * @private
     * @param  {string}  text  The text
     * @return {string}  trimmed string
     */
    static trimRight(text) {
        if (typeof text !== 'string') {
            return '';
        }
        for (var i = text.length - 1; i >= 0; i--) {
            var char = text[i];
            if (!TextMetrics.isBreakingSpace(char)) {
                break;
            }
            text = text.slice(0, -1);
        }
        return text;
    }
    ;
    /**
     * Determines if char is a newline.
     *
     * @private
     * @param  {string}  char  The character
     * @return {boolean}  True if newline, False otherwise.
     */
    static isNewline(char) {
        if (typeof char !== 'string') {
            return false;
        }
        return (TextMetrics._newlines.indexOf(char.charCodeAt(0)) >= 0);
    }
    ;
    /**
     * Determines if char is a breaking whitespace.
     *
     * @private
     * @param  {string}  char  The character
     * @return {boolean}  True if whitespace, False otherwise.
     */
    static isBreakingSpace(char) {
        if (typeof char !== 'string') {
            return false;
        }
        return (TextMetrics._breakingSpaces.indexOf(char.charCodeAt(0)) >= 0);
    }
    ;
    /**
     * Splits a string into words, breaking-spaces and newLine characters
     *
     * @private
     * @param  {string}  text   The text
     * @return {string[]}  A tokenized array
     */
    static tokenize(text) {
        var tokens = [];
        var token = '';
        if (typeof text !== 'string') {
            return tokens;
        }
        for (var i = 0; i < text.length; i++) {
            var char = text[i];
            if (TextMetrics.isBreakingSpace(char) || TextMetrics.isNewline(char)) {
                if (token !== '') {
                    tokens.push(token);
                    token = '';
                }
                tokens.push(char);
                continue;
            }
            token += char;
        }
        if (token !== '') {
            tokens.push(token);
        }
        return tokens;
    }
    ;
    /**
     * This method exists to be easily overridden
     * It allows one to customise which words should break
     * Examples are if the token is CJK or numbers.
     * It must return a boolean.
     *
     * @private
     * @param  {string}  token   The token
     * @param  {boolean}  breakWords  The style attr break words
     * @return {boolean} whether to break word or not
     */
    static canBreakWords(token, breakWords) {
        return breakWords;
    }
    ;
    /**
     * This method exists to be easily overridden
     * It allows one to determine whether a pair of characters
     * should be broken by newlines
     * For example certain characters in CJK langs or numbers.
     * It must return a boolean.
     *
     * @private
     * @param  {string}  char  The character
     * @param  {string}  nextChar  The next character
     * @param  {string}  token The token/word the characters are from
     * @param  {number}  index The index in the token of the char
     * @param  {boolean}  breakWords  The style attr break words
     * @return {boolean} whether to break word or not
     */
    static canBreakChars(char, nextChar, token, index, breakWords) {
        return true;
    }
    ;
    /**
     * Calculates the ascent, descent and fontSize of a given font-style
     *
     * @static
     * @param {string} font - String representing the style of the font
     * @return {PIXI.IFontMetrics} Font properties object
     */
    static measureFont(font) {
        // as this method is used for preparing assets, don't recalculate things if we don't need to
        if (TextMetrics._fonts[font]) {
            return TextMetrics._fonts[font];
        }
        var properties = {};
        var canvas = TextMetrics._canvas;
        var context = TextMetrics._context;
        context.font = font;
        var metricsString = TextMetrics.METRICS_STRING + TextMetrics.BASELINE_SYMBOL;
        var width = Math.ceil(context.measureText(metricsString).width);
        var baseline = Math.ceil(context.measureText(TextMetrics.BASELINE_SYMBOL).width);
        var height = 2 * baseline;
        baseline = baseline * TextMetrics.BASELINE_MULTIPLIER | 0;
        canvas.width = width;
        canvas.height = height;
        context.fillStyle = '#f00';
        context.fillRect(0, 0, width, height);
        context.font = font;
        context.textBaseline = 'alphabetic';
        context.fillStyle = '#000';
        context.fillText(metricsString, 0, baseline);
        var imagedata = context.getImageData(0, 0, width, height).data;
        var pixels = imagedata.length;
        var line = width * 4;
        var i = 0;
        var idx = 0;
        var stop = false;
        // ascent. scan from top to bottom until we find a non red pixel
        for (i = 0; i < baseline; ++i) {
            for (var j = 0; j < line; j += 4) {
                if (imagedata[idx + j] !== 255) {
                    stop = true;
                    break;
                }
            }
            if (!stop) {
                idx += line;
            }
            else {
                break;
            }
        }
        properties.ascent = baseline - i;
        idx = pixels - line;
        stop = false;
        // descent. scan from bottom to top until we find a non red pixel
        for (i = height; i > baseline; --i) {
            for (var j$1 = 0; j$1 < line; j$1 += 4) {
                if (imagedata[idx + j$1] !== 255) {
                    stop = true;
                    break;
                }
            }
            if (!stop) {
                idx -= line;
            }
            else {
                break;
            }
        }
        properties.descent = i - baseline;
        properties.fontSize = properties.ascent + properties.descent;
        TextMetrics._fonts[font] = properties;
        return properties;
    }
    ;
    /**
     * Clear font metrics in metrics cache.
     *
     * @static
     * @param {string} [font] - font name. If font name not set then clear cache for all fonts.
     */
    static clearMetrics(font) {
        if (font === void 0) {
            font = '';
        }
        if (font) {
            delete TextMetrics._fonts[font];
        }
        else {
            TextMetrics._fonts = {};
        }
    }
    ;
}
/**
 * Internal return object for {@link PIXI.TextMetrics.measureFont `TextMetrics.measureFont`}.
 *
 * @typedef {object} FontMetrics
 * @property {number} ascent - The ascent distance
 * @property {number} descent - The descent distance
 * @property {number} fontSize - Font size from ascent to descent
 * @memberof PIXI.TextMetrics
 * @private
 */
/**
 * Cache of {@see PIXI.TextMetrics.FontMetrics} objects.
 * @memberof PIXI.TextMetrics
 * @type {Object}
 * @private
 */
TextMetrics._fonts = {};
/**
 * String used for calculate font metrics.
 * @static
 * @memberof PIXI.TextMetrics
 * @name METRICS_STRING
 * @type {string}
 * @default |q
 */
TextMetrics.METRICS_STRING = '|q';
/**
 * Baseline symbol for calculate font metrics.
 * @static
 * @memberof PIXI.TextMetrics
 * @name BASELINE_SYMBOL
 * @type {string}
 * @default M
 */
TextMetrics.BASELINE_SYMBOL = 'M';
/**
 * Baseline multiplier for calculate font metrics.
 * @static
 * @memberof PIXI.TextMetrics
 * @name BASELINE_MULTIPLIER
 * @type {number}
 * @default 1.4
 */
TextMetrics.BASELINE_MULTIPLIER = 1.4;
/**
 * Cache of new line chars.
 * @memberof PIXI.TextMetrics
 * @type {number[]}
 * @private
 */
TextMetrics._newlines = [
    0x000A,
    0x000D
];
/**
 * Cache of breaking spaces.
 * @memberof PIXI.TextMetrics
 * @type {number[]}
 * @private
 */
TextMetrics._breakingSpaces = [
    0x0009,
    0x0020,
    0x2000,
    0x2001,
    0x2002,
    0x2003,
    0x2004,
    0x2005,
    0x2006,
    0x2008,
    0x2009,
    0x200A,
    0x205F,
    0x3000
];
exports.TextMetrics = TextMetrics;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/TextSettings.js":
/*!************************************************!*\
  !*** ./js-compile/raw-pixi-ts/TextSettings.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class TextSettings {
}
TextSettings.TEXT_GRADIENT = {
    LINEAR_VERTICAL: 0,
    LINEAR_HORIZONTAL: 1,
};
TextSettings.defaultStyle = {
    align: 'left',
    breakWords: false,
    dropShadow: false,
    dropShadowAlpha: 1,
    dropShadowAngle: Math.PI / 6,
    dropShadowBlur: 0,
    dropShadowColor: 'black',
    dropShadowDistance: 5,
    fill: 'black',
    fillGradientType: TextSettings.TEXT_GRADIENT.LINEAR_VERTICAL,
    fillGradientStops: [],
    fontFamily: 'Arial',
    fontSize: 26,
    fontStyle: 'normal',
    fontVariant: 'normal',
    fontWeight: 'normal',
    letterSpacing: 0,
    lineHeight: 0,
    lineJoin: 'miter',
    miterLimit: 10,
    padding: 0,
    stroke: 'black',
    strokeThickness: 0,
    textBaseline: 'alphabetic',
    trim: false,
    whiteSpace: 'pre',
    wordWrap: false,
    wordWrapWidth: 100,
    leading: 0,
};
exports.TextSettings = TextSettings;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/TextStyle.js":
/*!*********************************************!*\
  !*** ./js-compile/raw-pixi-ts/TextStyle.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const TextSettings_1 = __webpack_require__(/*! ./TextSettings */ "./js-compile/raw-pixi-ts/TextSettings.js");
const ColorSettings_1 = __webpack_require__(/*! ./ColorSettings */ "./js-compile/raw-pixi-ts/ColorSettings.js");
const UtilsSettings_1 = __webpack_require__(/*! ./UtilsSettings */ "./js-compile/raw-pixi-ts/UtilsSettings.js");
class TextStyle {
    constructor(style) {
        this.styleID = 0;
        this.reset();
        UtilsSettings_1.UtilsSettings.deepCopyProperties(this, style, style);
    }
    /**
     * Creates a new TextStyle object with the same values as this one.
     * Note that the only the properties of the object are cloned.
     *
     * @return {PIXI.TextStyle} New cloned TextStyle object
     */
    clone() {
        var clonedProperties = {};
        UtilsSettings_1.UtilsSettings.deepCopyProperties(clonedProperties, this, TextSettings_1.TextSettings.defaultStyle);
        return new TextStyle(clonedProperties);
    }
    ;
    /**
     * Resets all properties to the defaults specified in TextStyle.prototype._default
     */
    reset() {
        UtilsSettings_1.UtilsSettings.deepCopyProperties(this, TextSettings_1.TextSettings.defaultStyle, TextSettings_1.TextSettings.defaultStyle);
    }
    ;
    /**
     * Alignment for multiline text ('left', 'center' or 'right'), does not affect single line text
     *
     * @member {string}
     */
    get align() {
        return this._align;
    }
    ;
    set align(align) {
        if (this._align !== align) {
            this._align = align;
            this.styleID++;
        }
    }
    ;
    /**
     * Indicates if lines can be wrapped within words, it needs wordWrap to be set to true
     *
     * @member {boolean}
     */
    get breakWords() {
        return this._breakWords;
    }
    ;
    set breakWords(breakWords) {
        if (this._breakWords !== breakWords) {
            this._breakWords = breakWords;
            this.styleID++;
        }
    }
    ;
    /**
     * Set a drop shadow for the text
     *
     * @member {boolean}
     */
    get dropShadow() {
        return this._dropShadow;
    }
    ;
    set dropShadow(dropShadow) {
        if (this._dropShadow !== dropShadow) {
            this._dropShadow = dropShadow;
            this.styleID++;
        }
    }
    ;
    /**
     * Set alpha for the drop shadow
     *
     * @member {number}
     */
    get dropShadowAlpha() {
        return this._dropShadowAlpha;
    }
    ;
    set dropShadowAlpha(dropShadowAlpha) {
        if (this._dropShadowAlpha !== dropShadowAlpha) {
            this._dropShadowAlpha = dropShadowAlpha;
            this.styleID++;
        }
    }
    ;
    /**
     * Set a angle of the drop shadow
     *
     * @member {number}
     */
    get dropShadowAngle() {
        return this._dropShadowAngle;
    }
    ;
    set dropShadowAngle(dropShadowAngle) {
        if (this._dropShadowAngle !== dropShadowAngle) {
            this._dropShadowAngle = dropShadowAngle;
            this.styleID++;
        }
    }
    ;
    /**
     * Set a shadow blur radius
     *
     * @member {number}
     */
    get dropShadowBlur() {
        return this._dropShadowBlur;
    }
    ;
    set dropShadowBlur(dropShadowBlur) {
        if (this._dropShadowBlur !== dropShadowBlur) {
            this._dropShadowBlur = dropShadowBlur;
            this.styleID++;
        }
    }
    ;
    /**
     * A fill style to be used on the dropshadow e.g 'red', '#00FF00'
     *
     * @member {string|number}
     */
    get dropShadowColor() {
        return this._dropShadowColor;
    }
    ;
    set dropShadowColor(dropShadowColor) {
        var outputColor = ColorSettings_1.ColorSettings.getColor(dropShadowColor);
        if (this._dropShadowColor !== outputColor) {
            this._dropShadowColor = outputColor;
            this.styleID++;
        }
    }
    ;
    /**
     * Set a distance of the drop shadow
     *
     * @member {number}
     */
    get dropShadowDistance() {
        return this._dropShadowDistance;
    }
    ;
    set dropShadowDistance(dropShadowDistance) {
        if (this._dropShadowDistance !== dropShadowDistance) {
            this._dropShadowDistance = dropShadowDistance;
            this.styleID++;
        }
    }
    ;
    /**
     * A canvas fillstyle that will be used on the text e.g 'red', '#00FF00'.
     * Can be an array to create a gradient eg ['#000000','#FFFFFF']
     * {@link https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/fillStyle|MDN}
     *
     * @member {string|string[]|number|number[]|CanvasGradient|CanvasPattern}
     */
    get fill() {
        return this._fill;
    }
    ;
    set fill(fill) {
        var outputColor = ColorSettings_1.ColorSettings.getColor(fill);
        if (this._fill !== outputColor) {
            this._fill = outputColor;
            this.styleID++;
        }
    }
    ;
    /**
     * If fill is an array of colours to create a gradient, this can change the type/direction of the gradient.
     * See {@link PIXI.TEXT_GRADIENT}
     *
     * @member {number}
     */
    get fillGradientType() {
        return this._fillGradientType;
    }
    ;
    set fillGradientType(fillGradientType) {
        if (this._fillGradientType !== fillGradientType) {
            this._fillGradientType = fillGradientType;
            this.styleID++;
        }
    }
    ;
    /**
     * If fill is an array of colours to create a gradient, this array can set the stop points
     * (numbers between 0 and 1) for the color, overriding the default behaviour of evenly spacing them.
     *
     * @member {number[]}
     */
    get fillGradientStops() {
        return this._fillGradientStops;
    }
    ;
    set fillGradientStops(fillGradientStops) {
        if (!UtilsSettings_1.UtilsSettings.areArraysEqual(this._fillGradientStops, fillGradientStops)) {
            this._fillGradientStops = fillGradientStops;
            this.styleID++;
        }
    }
    ;
    /**
     * The font family
     *
     * @member {string|string[]}
     */
    get fontFamily() {
        return this._fontFamily;
    }
    ;
    set fontFamily(fontFamily) {
        if (this.fontFamily !== fontFamily) {
            this._fontFamily = fontFamily;
            this.styleID++;
        }
    }
    ;
    /**
     * The font size
     * (as a number it converts to px, but as a string, equivalents are '26px','20pt','160%' or '1.6em')
     *
     * @member {number|string}
     */
    get fontSize() {
        return this._fontSize;
    }
    ;
    set fontSize(fontSize) {
        if (this._fontSize !== fontSize) {
            this._fontSize = fontSize;
            this.styleID++;
        }
    }
    ;
    /**
     * The font style
     * ('normal', 'italic' or 'oblique')
     *
     * @member {string}
     */
    get fontStyle() {
        return this._fontStyle;
    }
    ;
    set fontStyle(fontStyle) {
        if (this._fontStyle !== fontStyle) {
            this._fontStyle = fontStyle;
            this.styleID++;
        }
    }
    ;
    /**
     * The font variant
     * ('normal' or 'small-caps')
     *
     * @member {string}
     */
    get fontVariant() {
        return this._fontVariant;
    }
    ;
    set fontVariant(fontVariant) {
        if (this._fontVariant !== fontVariant) {
            this._fontVariant = fontVariant;
            this.styleID++;
        }
    }
    ;
    /**
     * The font weight
     * ('normal', 'bold', 'bolder', 'lighter' and '100', '200', '300', '400', '500', '600', '700', 800' or '900')
     *
     * @member {string}
     */
    get fontWeight() {
        return this._fontWeight;
    }
    ;
    set fontWeight(fontWeight) {
        if (this._fontWeight !== fontWeight) {
            this._fontWeight = fontWeight;
            this.styleID++;
        }
    }
    ;
    /**
     * The amount of spacing between letters, default is 0
     *
     * @member {number}
     */
    get letterSpacing() {
        return this._letterSpacing;
    }
    ;
    set letterSpacing(letterSpacing) {
        if (this._letterSpacing !== letterSpacing) {
            this._letterSpacing = letterSpacing;
            this.styleID++;
        }
    }
    ;
    /**
     * The line height, a number that represents the vertical space that a letter uses
     *
     * @member {number}
     */
    get lineHeight() {
        return this._lineHeight;
    }
    ;
    set lineHeight(lineHeight) {
        if (this._lineHeight !== lineHeight) {
            this._lineHeight = lineHeight;
            this.styleID++;
        }
    }
    ;
    /**
     * The space between lines
     *
     * @member {number}
     */
    get leading() {
        return this._leading;
    }
    ;
    set leading(leading) {
        if (this._leading !== leading) {
            this._leading = leading;
            this.styleID++;
        }
    }
    ;
    /**
     * The lineJoin property sets the type of corner created, it can resolve spiked text issues.
     * Default is 'miter' (creates a sharp corner).
     *
     * @member {string}
     */
    get lineJoin() {
        return this._lineJoin;
    }
    ;
    set lineJoin(lineJoin) {
        if (this._lineJoin !== lineJoin) {
            this._lineJoin = lineJoin;
            this.styleID++;
        }
    }
    ;
    /**
     * The miter limit to use when using the 'miter' lineJoin mode
     * This can reduce or increase the spikiness of rendered text.
     *
     * @member {number}
     */
    get miterLimit() {
        return this._miterLimit;
    }
    ;
    set miterLimit(miterLimit) {
        if (this._miterLimit !== miterLimit) {
            this._miterLimit = miterLimit;
            this.styleID++;
        }
    }
    ;
    /**
     * Occasionally some fonts are cropped. Adding some padding will prevent this from happening
     * by adding padding to all sides of the text.
     *
     * @member {number}
     */
    get padding() {
        return this._padding;
    }
    ;
    set padding(padding) {
        if (this._padding !== padding) {
            this._padding = padding;
            this.styleID++;
        }
    }
    ;
    /**
     * A canvas fillstyle that will be used on the text stroke
     * e.g 'blue', '#FCFF00'
     *
     * @member {string|number}
     */
    get stroke() {
        return this._stroke;
    }
    ;
    set stroke(stroke) {
        var outputColor = ColorSettings_1.ColorSettings.getColor(stroke);
        if (this._stroke !== outputColor) {
            this._stroke = outputColor;
            this.styleID++;
        }
    }
    ;
    /**
     * A number that represents the thickness of the stroke.
     * Default is 0 (no stroke)
     *
     * @member {number}
     */
    get strokeThickness() {
        return this._strokeThickness;
    }
    ;
    set strokeThickness(strokeThickness) {
        if (this._strokeThickness !== strokeThickness) {
            this._strokeThickness = strokeThickness;
            this.styleID++;
        }
    }
    ;
    /**
     * The baseline of the text that is rendered.
     *
     * @member {string}
     */
    get textBaseline() {
        return this._textBaseline;
    }
    ;
    set textBaseline(textBaseline) {
        if (this._textBaseline !== textBaseline) {
            this._textBaseline = textBaseline;
            this.styleID++;
        }
    }
    ;
    /**
     * Trim transparent borders
     *
     * @member {boolean}
     */
    get trim() {
        return this._trim;
    }
    ;
    set trim(trim) {
        if (this._trim !== trim) {
            this._trim = trim;
            this.styleID++;
        }
    }
    ;
    /**
     * How newlines and spaces should be handled.
     * Default is 'pre' (preserve, preserve).
     *
     *  value   | New lines |   Spaces
     *  ---     | ---       |   ---
     * 'normal' | Collapse  |   Collapse
     * 'pre'    | Preserve  |   Preserve
     * 'pre-line'   | Preserve  |   Collapse
     *
     * @member {string}
     */
    get whiteSpace() {
        return this._whiteSpace;
    }
    ;
    set whiteSpace(whiteSpace) {
        if (this._whiteSpace !== whiteSpace) {
            this._whiteSpace = whiteSpace;
            this.styleID++;
        }
    }
    ;
    /**
     * Indicates if word wrap should be used
     *
     * @member {boolean}
     */
    get wordWrap() {
        return this._wordWrap;
    }
    ;
    set wordWrap(wordWrap) {
        if (this._wordWrap !== wordWrap) {
            this._wordWrap = wordWrap;
            this.styleID++;
        }
    }
    ;
    /**
     * The width at which text will wrap, it needs wordWrap to be set to true
     *
     * @member {number}
     */
    get wordWrapWidth() {
        return this._wordWrapWidth;
    }
    ;
    set wordWrapWidth(wordWrapWidth) {
        if (this._wordWrapWidth !== wordWrapWidth) {
            this._wordWrapWidth = wordWrapWidth;
            this.styleID++;
        }
    }
    ;
    /**
     * Generates a font style string to use for `TextMetrics.measureFont()`.
     *
     * @return {string} Font style string, for passing to `TextMetrics.measureFont()`
     */
    toFontString() {
        // build canvas api font setting from individual components. Convert a numeric this.fontSize to px
        var fontSizeString = (typeof this.fontSize === 'number') ? ((this.fontSize) + "px") : this.fontSize;
        // Clean-up fontFamily property by quoting each font name
        // this will support font names with spaces
        var fontFamilies = this.fontFamily;
        if (!Array.isArray(this.fontFamily)) {
            fontFamilies = this.fontFamily.split(',');
        }
        for (var i = fontFamilies.length - 1; i >= 0; i--) {
            // Trim any extra white-space
            var fontFamily = fontFamilies[i].trim();
            // Check if font already contains strings
            if (!(/([\"\'])[^\'\"]+\1/).test(fontFamily)) {
                fontFamily = "\"" + fontFamily + "\"";
            }
            fontFamilies[i] = fontFamily;
        }
        return ((this.fontStyle) + " " + (this.fontVariant) + " " + (this.fontWeight) + " " + fontSizeString + " " + (fontFamilies.join(',')));
    }
    ;
}
exports.TextStyle = TextStyle;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/Texture.js":
/*!*******************************************!*\
  !*** ./js-compile/raw-pixi-ts/Texture.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const EventDispatcher_1 = __webpack_require__(/*! ./EventDispatcher */ "./js-compile/raw-pixi-ts/EventDispatcher.js");
const Rectangle_1 = __webpack_require__(/*! ./Rectangle */ "./js-compile/raw-pixi-ts/Rectangle.js");
const Point_1 = __webpack_require__(/*! ./Point */ "./js-compile/raw-pixi-ts/Point.js");
const Event_1 = __webpack_require__(/*! ./Event */ "./js-compile/raw-pixi-ts/Event.js");
const TextureUvs_1 = __webpack_require__(/*! ./TextureUvs */ "./js-compile/raw-pixi-ts/TextureUvs.js");
const BaseTexture_1 = __webpack_require__(/*! ./BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const ImageResource_1 = __webpack_require__(/*! ./ImageResource */ "./js-compile/raw-pixi-ts/ImageResource.js");
const CanvasResource_1 = __webpack_require__(/*! ./CanvasResource */ "./js-compile/raw-pixi-ts/CanvasResource.js");
const MathSettings_1 = __webpack_require__(/*! ./MathSettings */ "./js-compile/raw-pixi-ts/MathSettings.js");
const CacheSettings_1 = __webpack_require__(/*! ./CacheSettings */ "./js-compile/raw-pixi-ts/CacheSettings.js");
const DisplaySettings_1 = __webpack_require__(/*! ./DisplaySettings */ "./js-compile/raw-pixi-ts/DisplaySettings.js");
const NetworkSettings_1 = __webpack_require__(/*! ./NetworkSettings */ "./js-compile/raw-pixi-ts/NetworkSettings.js");
const Logger_1 = __webpack_require__(/*! ./Logger */ "./js-compile/raw-pixi-ts/Logger.js");
class Texture extends EventDispatcher_1.EventDispatcher {
    constructor(baseTexture, frame = null, orig = null, trim = null, rotate = null, anchor = null) {
        super();
        /**
         * Called when the base texture is updated
         *
         * @protected
         * @param {PIXI.BaseTexture} baseTexture - The base texture.
         */
        this.onBaseTextureUpdated = (baseTexture) => {
            Logger_1.trace("onBaseTextureUpdated");
            this._updateID++;
            // TODO this code looks confusing.. boo to abusing getters and setters!
            if (this.noFrame) {
                this.frame = new Rectangle_1.Rectangle(0, 0, baseTexture.width, baseTexture.height);
            }
            else {
                this.frame = this._frame;
                // TODO maybe watch out for the no frame option
                // updating the texture will should update the frame if it was set to no frame..
            }
            this.valid = this.baseTexture.valid;
            this.dispatchEvent(Event_1.Event.getEvent("update"));
            // this.emit('update', this);
            // this.baseTexture.addEventListener("update", this.onBaseTextureUpdated)
        };
        this.noFrame = false;
        if (!frame) {
            this.noFrame = true;
            frame = new Rectangle_1.Rectangle(0, 0, 1, 1);
        }
        if (baseTexture instanceof Texture) {
            baseTexture = baseTexture.baseTexture;
        }
        /**
         * The base texture that this texture uses.
         *
         * @member {PIXI.BaseTexture}
         */
        this.baseTexture = baseTexture;
        /**
         * This is the area of the BaseTexture image to actually copy to the Canvas / WebGL when rendering,
         * irrespective of the actual frame size or placement (which can be influenced by trimmed texture atlases)
         *
         * @member {PIXI.Rectangle}
         */
        this._frame = frame;
        /**
         * This is the trimmed area of original texture, before it was put in atlas
         * Please call `updateUvs()` after you change coordinates of `trim` manually.
         *
         * @member {PIXI.Rectangle}
         */
        this.trim = trim;
        /**
         * This will let the renderer know if the texture is valid. If it's not then it cannot be rendered.
         *
         * @member {boolean}
         */
        this.valid = false;
        /**
         * This will let a renderer know that a texture has been updated (used mainly for WebGL uv updates)
         *
         * @member {boolean}
         */
        this.requiresUpdate = false;
        /**
         * The WebGL UV data cache. Can be used as quad UV
         *
         * @member {PIXI.TextureUvs}
         * @protected
         */
        this._uvs = Texture.DEFAULT_UVS;
        /**
         * Default TextureMatrix instance for this texture
         * By default that object is not created because its heavy
         *
         * @member {PIXI.TextureMatrix}
         */
        this.uvMatrix = null;
        /**
         * This is the area of original texture, before it was put in atlas
         *
         * @member {PIXI.Rectangle}
         */
        this.orig = orig || frame; // new Rectangle(0, 0, 1, 1);
        this._rotate = Number(rotate || 0);
        if (rotate === true) {
            // this is old texturepacker legacy, some games/libraries are passing "true" for rotated textures
            this._rotate = 2;
        }
        else if (this._rotate % 2 !== 0) {
            throw new Error('attempt to use diamond-shaped UVs. If you are sure, set rotation manually');
        }
        if (baseTexture.valid) {
            if (this.noFrame) {
                frame = new Rectangle_1.Rectangle(0, 0, baseTexture.width, baseTexture.height);
                // if there is no frame we should monitor for any base texture changes..
                baseTexture.addEventListener("update", this.onBaseTextureUpdated);
                // baseTexture.on('update', this.onBaseTextureUpdated, this);
            }
            this.frame = frame;
        }
        else {
            baseTexture.addEventListener("loaded", this.onBaseTextureUpdated);
            // baseTexture.once('loaded', this.onBaseTextureUpdated, this);
        }
        /**
         * Anchor point that is used as default if sprite is created with this texture.
         * Changing the `defaultAnchor` at a later point of time will not update Sprite's anchor point.
         * @member {PIXI.Point}
         * @default {0,0}
         */
        if (anchor) {
            this.defaultAnchor = new Point_1.Point(anchor.x, anchor.y);
        }
        else {
            this.defaultAnchor = new Point_1.Point(0, 0);
        }
        /**
         * Update ID is observed by sprites and TextureMatrix instances.
         * Call updateUvs() to increment it.
         *
         * @member {number}
         * @protected
         */
        this._updateID = 0;
        /**
         * The ids under which this Texture has been added to the texture cache. This is
         * automatically set as long as Texture.addToCache is used, but may not be set if a
         * Texture is added directly to the TextureCache array.
         *
         * @member {string[]}
         */
        this.textureCacheIds = [];
    }
    /**
     * Updates this texture on the gpu.
     *
     */
    update() {
        this.baseTexture.update();
    }
    ;
    /**
     * Destroys this texture
     *
     * @param {boolean} [destroyBase=false] Whether to destroy the base texture as well
     */
    destroy(destroyBase) {
        if (this.baseTexture) {
            if (destroyBase) {
                // delete the texture if it exists in the texture cache..
                // this only needs to be removed if the base texture is actually destroyed too..
                if (CacheSettings_1.CacheSettings.TextureCache[this.baseTexture.imageUrl]) {
                    Texture.removeFromCache(this.baseTexture.imageUrl);
                }
                this.baseTexture.destroy();
            }
            // this.baseTexture.remo('update', this.onBaseTextureUpdated, this);
            this.baseTexture = null;
        }
        this._frame = null;
        this._uvs = null;
        this.trim = null;
        this.orig = null;
        this.valid = false;
        Texture.removeFromCache(this);
        this.textureCacheIds = null;
    }
    ;
    /**
     * Creates a new texture object that acts the same as this one.
     *
     * @return {PIXI.Texture} The new texture
     */
    clone() {
        return new Texture(this.baseTexture, this.frame, this.orig, this.trim, this.rotate, this.defaultAnchor);
    }
    ;
    /**
     * Updates the internal WebGL UV cache. Use it after you change `frame` or `trim` of the texture.
     * Call it after changing the frame
     */
    updateUvs() {
        if (this._uvs === Texture.DEFAULT_UVS) {
            this._uvs = new TextureUvs_1.TextureUvs();
        }
        this._uvs.set(this._frame, this.baseTexture, this.rotate);
        this._updateID++;
    }
    ;
    /**
     * Helper function that creates a new Texture based on the source you provide.
     * The source can be - frame id, image url, video url, canvas element, video element, base texture
     *
     * @static
     * @param {number|string|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement|PIXI.BaseTexture} source
     *        Source to create texture from
     * @param {object} [options] See {@link PIXI.BaseTexture}'s constructor for options.
     * @return {PIXI.Texture} The newly created texture
     */
    static from(source, options = {}) {
        var cacheId = null;
        if (typeof source === 'string') {
            cacheId = source;
        }
        else {
            if (!source._pixiId) {
                source._pixiId = "pixiid_" + (MathSettings_1.MathSettings.uid());
            }
            cacheId = source._pixiId;
        }
        var texture = CacheSettings_1.CacheSettings.TextureCache[cacheId];
        if (!texture) {
            if (options['resolution'] == undefined) {
                options.resolution = NetworkSettings_1.NetworkSettings.getResolutionOfUrl(source);
            }
            texture = new Texture(new BaseTexture_1.BaseTexture(source, options));
            texture.baseTexture.cacheId = cacheId;
            BaseTexture_1.BaseTexture.addToCache(texture.baseTexture, cacheId);
            Texture.addToCache(texture, cacheId);
        }
        // lets assume its a base texture!
        return texture;
    }
    ;
    /**
     * Adds a Texture to the global TextureCache. This cache is shared across the whole PIXI object.
     *
     * @static
     * @param {PIXI.Texture} texture - The Texture to add to the cache.
     * @param {string} id - The id that the Texture will be stored against.
     */
    static addToCache(texture, id) {
        if (id) {
            if (texture.textureCacheIds.indexOf(id) === -1) {
                texture.textureCacheIds.push(id);
            }
            if (CacheSettings_1.CacheSettings.TextureCache[id]) {
                // eslint-disable-next-line no-console
                console.warn(("Texture added to the cache with an id [" + id + "] that already had an entry"));
            }
            CacheSettings_1.CacheSettings.TextureCache[id] = texture;
        }
    }
    ;
    /**
     * Remove a Texture from the global TextureCache.
     *
     * @static
     * @param {string|PIXI.Texture} texture - id of a Texture to be removed, or a Texture instance itself
     * @return {PIXI.Texture|null} The Texture that was removed
     */
    static removeFromCache(texture) {
        if (typeof texture === 'string') {
            var textureFromCache = CacheSettings_1.CacheSettings.TextureCache[texture];
            if (textureFromCache) {
                var index = textureFromCache.textureCacheIds.indexOf(texture);
                if (index > -1) {
                    textureFromCache.textureCacheIds.splice(index, 1);
                }
                delete CacheSettings_1.CacheSettings.TextureCache[texture];
                return textureFromCache;
            }
        }
        else if (texture && texture.textureCacheIds) {
            for (var i = 0; i < texture.textureCacheIds.length; ++i) {
                // Check that texture matches the one being passed in before deleting it from the cache.
                if (CacheSettings_1.CacheSettings.TextureCache[texture.textureCacheIds[i]] === texture) {
                    delete CacheSettings_1.CacheSettings.TextureCache[texture.textureCacheIds[i]];
                }
            }
            texture.textureCacheIds.length = 0;
            return texture;
        }
        return null;
    }
    ;
    /**
     * The frame specifies the region of the base texture that this texture uses.
     * Please call `updateUvs()` after you change coordinates of `frame` manually.
     *
     * @member {PIXI.Rectangle}
     */
    get frame() {
        return this._frame;
    }
    ;
    set frame(frame) {
        this._frame = frame;
        this.noFrame = false;
        var x = frame.x;
        var y = frame.y;
        var width = frame.width;
        var height = frame.height;
        var xNotFit = x + width > this.baseTexture.width;
        var yNotFit = y + height > this.baseTexture.height;
        if (xNotFit || yNotFit) {
            var relationship = xNotFit && yNotFit ? 'and' : 'or';
            var errorX = "X: " + x + " + " + width + " = " + (x + width) + " > " + (this.baseTexture.width);
            var errorY = "Y: " + y + " + " + height + " = " + (y + height) + " > " + (this.baseTexture.height);
            throw new Error('Texture Error: frame does not fit inside the base Texture dimensions: '
                + errorX + " " + relationship + " " + errorY);
        }
        this.valid = width && height && this.baseTexture.valid;
        if (!this.trim && !this.rotate) {
            this.orig = frame;
        }
        if (this.valid) {
            this.updateUvs();
        }
    }
    ;
    /**
     * Indicates whether the texture is rotated inside the atlas
     * set to 2 to compensate for texture packer rotation
     * set to 6 to compensate for spine packer rotation
     * can be used to rotate or mirror sprites
     * See {@link PIXI.GroupD8} for explanation
     *
     * @member {number}
     */
    get rotate() {
        return this._rotate;
    }
    ;
    set rotate(rotate) {
        this._rotate = rotate;
        if (this.valid) {
            this.updateUvs();
        }
    }
    ;
    /**
     * The width of the Texture in pixels.
     *
     * @member {number}
     */
    get width() {
        return this.orig.width;
    }
    ;
    /**
     * The height of the Texture in pixels.
     *
     * @member {number}
     */
    get height() {
        return this.orig.height;
    }
    ;
    /**
     * An empty texture, used often to not have to create multiple empty textures.
     * Can not be destroyed.
     *
     * @static
     * @constant
     * @member {PIXI.Texture}
     */
    static get EMPTY() {
        return new Texture(new BaseTexture_1.BaseTexture());
    }
    /**
 * A white texture of 10x10 size, used for graphics and other things
 * Can not be destroyed.
 *
 * @static
 * @constant
 * @member {PIXI.Texture}
 */
    static get WHITE() {
        return Texture.createWhiteTexture();
    }
    static createWhiteTexture() {
        var canvas = document.createElement('canvas');
        canvas.width = 16;
        canvas.height = 16;
        var context = canvas.getContext('2d');
        context.fillStyle = 'white';
        context.fillRect(0, 0, 16, 16);
        return new Texture(new BaseTexture_1.BaseTexture(new CanvasResource_1.CanvasResource(canvas)));
    }
}
Texture.DEFAULT_UVS = new TextureUvs_1.TextureUvs();
/**
 * Create a new Texture with a BufferResource from a Float32Array.
 * RGBA values are floats from 0 to 1.
 * @static
 * @param {Float32Array|Uint8Array} buffer The optional array to use, if no data
 *        is provided, a new Float32Array is created.
 * @param {number} width - Width of the resource
 * @param {number} height - Height of the resource
 * @param {object} [options] See {@link PIXI.BaseTexture}'s constructor for options.
 * @return {PIXI.Texture} The resulting new BaseTexture
 */
Texture.fromBuffer = function fromBuffer(buffer, width, height, options) {
    return new Texture(BaseTexture_1.BaseTexture.fromBuffer(buffer, width, height, options));
};
/**
 * Create a texture from a source and add to the cache.
 *
 * @static
 * @param {HTMLImageElement|HTMLCanvasElement} source - The input source.
 * @param {String} imageUrl - File name of texture, for cache and resolving resolution.
 * @param {String} [name] - Human readable name for the texture cache. If no name is
 *        specified, only `imageUrl` will be used as the cache ID.
 * @return {PIXI.Texture} Output texture
 */
Texture.fromLoader = function fromLoader(source, imageUrl, name) {
    var resource = new ImageResource_1.ImageResource(source);
    resource.url = imageUrl;
    var baseTexture = new BaseTexture_1.BaseTexture(resource, {
        scaleMode: DisplaySettings_1.DisplaySettings.SCALE_MODE,
        resolution: NetworkSettings_1.NetworkSettings.getResolutionOfUrl(imageUrl),
    });
    var texture = new Texture(baseTexture);
    // No name, use imageUrl instead
    if (!name) {
        name = imageUrl;
    }
    // lets also add the frame to pixi's global cache for fromFrame and fromImage functions
    BaseTexture_1.BaseTexture.addToCache(texture.baseTexture, name);
    Texture.addToCache(texture, name);
    // also add references by url if they are different.
    if (name !== imageUrl) {
        BaseTexture_1.BaseTexture.addToCache(texture.baseTexture, imageUrl);
        Texture.addToCache(texture, imageUrl);
    }
    return texture;
};
exports.Texture = Texture;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/TextureGCSystem.js":
/*!***************************************************!*\
  !*** ./js-compile/raw-pixi-ts/TextureGCSystem.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const System_1 = __webpack_require__(/*! ./System */ "./js-compile/raw-pixi-ts/System.js");
const settings_1 = __webpack_require__(/*! ./settings */ "./js-compile/raw-pixi-ts/settings.js");
class TextureGCSystem extends System_1.System {
    constructor(renderer) {
        super(renderer);
        /**
         * Count
         * @member {number}
         * @readonly
         */
        this.count = 0;
        /**
         * Check count
         * @member {number}
         * @readonly
         */
        this.checkCount = 0;
        /**
         * Maximum idle time, in seconds
         * @member {number}
         * @see PIXI.settings.GC_MAX_IDLE
         */
        this.maxIdle = settings_1.settings.GC_MAX_IDLE;
        /**
         * Maximum number of itesm to check
         * @member {number}
         * @see PIXI.settings.GC_MAX_CHECK_COUNT
         */
        this.checkCountMax = settings_1.settings.GC_MAX_CHECK_COUNT;
        /**
         * Current garabage collection mode
         * @member {PIXI.GC_MODES}
         * @see PIXI.settings.GC_MODE
         */
        this.mode = settings_1.settings.GC_MODE;
    }
    /**
     * Checks to see when the last time a texture was used
     * if the texture has not been used for a specified amount of time it will be removed from the GPU
     */
    postrender() {
        this.count++;
        if (this.mode === settings_1.settings.GC_MODES.MANUAL) {
            return;
        }
        this.checkCount++;
        if (this.checkCount > this.checkCountMax) {
            this.checkCount = 0;
            this.run();
        }
    }
    ;
    /**
     * Checks to see when the last time a texture was used
     * if the texture has not been used for a specified amount of time it will be removed from the GPU
     */
    run() {
        var tm = this.renderer.texture;
        var managedTextures = tm.managedTextures;
        var wasRemoved = false;
        for (var i = 0; i < managedTextures.length; i++) {
            var texture = managedTextures[i];
            // only supports non generated textures at the moment!
            if (!texture.framebuffer && this.count - texture.touched > this.maxIdle) {
                tm.destroyTexture(texture, true);
                managedTextures[i] = null;
                wasRemoved = true;
            }
        }
        if (wasRemoved) {
            var j = 0;
            for (var i$1 = 0; i$1 < managedTextures.length; i$1++) {
                if (managedTextures[i$1] !== null) {
                    managedTextures[j++] = managedTextures[i$1];
                }
            }
            managedTextures.length = j;
        }
    }
    ;
    /**
     * Removes all the textures within the specified displayObject and its children from the GPU
     *
     * @param {PIXI.DisplayObject} displayObject - the displayObject to remove the textures from.
     */
    unload(displayObject) {
        // var tm = this.renderer.textureSystem;
        var tm = this.renderer.texture;
        // only destroy non generated textures
        if (displayObject._texture && displayObject._texture._glRenderTargets) {
            tm.destroyTexture(displayObject._texture);
        }
        for (var i = displayObject.children.length - 1; i >= 0; i--) {
            this.unload(displayObject.children[i]);
        }
    }
    ;
}
exports.TextureGCSystem = TextureGCSystem;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/TextureMatrix.js":
/*!*************************************************!*\
  !*** ./js-compile/raw-pixi-ts/TextureMatrix.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Matrix_1 = __webpack_require__(/*! ./Matrix */ "./js-compile/raw-pixi-ts/Matrix.js");
class TextureMatrix {
    constructor(texture, clampMargin = null) {
        this._texture = texture;
        this.mapCoord = new Matrix_1.Matrix();
        this.uClampFrame = new Float32Array(4);
        this.uClampOffset = new Float32Array(2);
        /**
         * Tracks Texture frame changes
         * @member {number}
         * @protected
         */
        this._updateID = -1;
        /**
         * Changes frame clamping
         * Works with TilingSprite and Mesh
         * Change to 1.5 if you texture has repeated right and bottom lines, that leads to smoother borders
         *
         * @default 0
         * @member {number}
         */
        this.clampOffset = 0;
        /**
         * Changes frame clamping
         * Works with TilingSprite and Mesh
         * Change to -0.5 to add a pixel to the edge, recommended for transparent trimmed textures in atlas
         *
         * @default 0.5
         * @member {number}
         */
        this.clampMargin = (typeof clampMargin === 'undefined') ? 0.5 : clampMargin;
        /**
         * If texture size is the same as baseTexture
         * @member {boolean}
         * @default false
         * @readonly
         */
        this.isSimple = false;
    }
    /**
     * texture property
     * @member {PIXI.Texture}
     */
    get texture() {
        return this._texture;
    }
    ;
    set texture(value) {
        this._texture = value;
        this._updateID = -1;
    }
    ;
    /**
     * Multiplies uvs array to transform
     * @param {Float32Array} uvs mesh uvs
     * @param {Float32Array} [out=uvs] output
     * @returns {Float32Array} output
     */
    multiplyUvs(uvs, out) {
        if (out === undefined) {
            out = uvs;
        }
        var mat = this.mapCoord;
        for (var i = 0; i < uvs.length; i += 2) {
            var x = uvs[i];
            var y = uvs[i + 1];
            out[i] = (x * mat.a) + (y * mat.c) + mat.tx;
            out[i + 1] = (x * mat.b) + (y * mat.d) + mat.ty;
        }
        return out;
    }
    ;
    /**
     * updates matrices if texture was changed
     * @param {boolean} forceUpdate if true, matrices will be updated any case
     * @returns {boolean} whether or not it was updated
     */
    update(forceUpdate) {
        var tex = this._texture;
        if (!tex || !tex.valid) {
            return false;
        }
        if (!forceUpdate
            && this._updateID === tex._updateID) {
            return false;
        }
        this._updateID = tex._updateID;
        var uvs = tex._uvs;
        this.mapCoord.set(uvs.x1 - uvs.x0, uvs.y1 - uvs.y0, uvs.x3 - uvs.x0, uvs.y3 - uvs.y0, uvs.x0, uvs.y0);
        var orig = tex.orig;
        var trim = tex.trim;
        if (trim) {
            TextureMatrix.tempMat.set(orig.width / trim.width, 0, 0, orig.height / trim.height, -trim.x / trim.width, -trim.y / trim.height);
            this.mapCoord.append(TextureMatrix.tempMat);
        }
        var texBase = tex.baseTexture;
        var frame = this.uClampFrame;
        var margin = this.clampMargin / texBase.resolution;
        var offset = this.clampOffset;
        frame[0] = (tex._frame.x + margin + offset) / texBase.width;
        frame[1] = (tex._frame.y + margin + offset) / texBase.height;
        frame[2] = (tex._frame.x + tex._frame.width - margin + offset) / texBase.width;
        frame[3] = (tex._frame.y + tex._frame.height - margin + offset) / texBase.height;
        this.uClampOffset[0] = offset / texBase.realWidth;
        this.uClampOffset[1] = offset / texBase.realHeight;
        this.isSimple = tex._frame.width === texBase.width
            && tex._frame.height === texBase.height
            && tex.rotate === 0;
        return true;
    }
    ;
}
TextureMatrix.tempMat = new Matrix_1.Matrix();
exports.TextureMatrix = TextureMatrix;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/TextureSystem.js":
/*!*************************************************!*\
  !*** ./js-compile/raw-pixi-ts/TextureSystem.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const System_1 = __webpack_require__(/*! ./System */ "./js-compile/raw-pixi-ts/System.js");
const BaseTexture_1 = __webpack_require__(/*! ./BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const GLTexture_1 = __webpack_require__(/*! ./GLTexture */ "./js-compile/raw-pixi-ts/GLTexture.js");
const UtilsSettings_1 = __webpack_require__(/*! ./UtilsSettings */ "./js-compile/raw-pixi-ts/UtilsSettings.js");
const WebGLSettings_1 = __webpack_require__(/*! ./WebGLSettings */ "./js-compile/raw-pixi-ts/WebGLSettings.js");
const Logger_1 = __webpack_require__(/*! ./Logger */ "./js-compile/raw-pixi-ts/Logger.js");
class TextureSystem extends System_1.System {
    constructor(renderer) {
        super(renderer);
        // TODO set to max textures...
        /**
         * Bound textures
         * @member {PIXI.BaseTexture[]}
         * @readonly
         */
        this.boundTextures = [];
        /**
         * Current location
         * @member {number}
         * @readonly
         */
        this.currentLocation = -1;
        /**
         * List of managed textures
         * @member {PIXI.BaseTexture[]}
         * @readonly
         */
        this.managedTextures = [];
        /**
         * Did someone temper with textures state? We'll overwrite them when we need to unbind something.
         * @member {boolean}
         * @private
         */
        this._unknownBoundTextures = false;
        /**
         * BaseTexture value that shows that we don't know what is bound
         * @member {PIXI.BaseTexture}
         * @readonly
         */
        this.unknownTexture = new BaseTexture_1.BaseTexture();
    }
    /**
     * Sets up the renderer context and necessary buffers.
     */
    contextChange() {
        var gl = this.gl = this.renderer.gl;
        this.CONTEXT_UID = this.renderer.CONTEXT_UID;
        this.webGLVersion = this.renderer.context.webGLVersion;
        var maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
        this.boundTextures.length = maxTextures;
        for (var i = 0; i < maxTextures; i++) {
            this.boundTextures[i] = null;
        }
        // TODO move this.. to a nice make empty textures class..
        this.emptyTextures = {};
        var emptyTexture2D = new GLTexture_1.GLTexture(gl.createTexture());
        gl.bindTexture(gl.TEXTURE_2D, emptyTexture2D.texture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array(4));
        this.emptyTextures[gl.TEXTURE_2D] = emptyTexture2D;
        this.emptyTextures[gl.TEXTURE_CUBE_MAP] = new GLTexture_1.GLTexture(gl.createTexture());
        gl.bindTexture(gl.TEXTURE_CUBE_MAP, this.emptyTextures[gl.TEXTURE_CUBE_MAP].texture);
        for (var i$1 = 0; i$1 < 6; i$1++) {
            gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + i$1, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
        }
        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        for (var i$2 = 0; i$2 < this.boundTextures.length; i$2++) {
            this.bind(null, i$2);
        }
    }
    ;
    /**
     * Bind a texture to a specific location
     *
     * If you want to unbind something, please use `unbind(texture)` instead of `bind(null, textureLocation)`
     *
     * @param {PIXI.Texture|PIXI.BaseTexture} texture - Texture to bind
     * @param {number} [location=0] - Location to bind at
     */
    bind(texture, location = 0) {
        var ref = this;
        var gl = ref.gl;
        if (texture) {
            texture = texture.baseTexture || texture;
            if (texture.valid) {
                texture.touched = this.renderer.textureGC.count;
                var glTexture = texture._glTextures[this.CONTEXT_UID] || this.initTexture(texture);
                if (this.currentLocation !== location) {
                    this.currentLocation = location;
                    gl.activeTexture(gl.TEXTURE0 + location);
                }
                if (this.boundTextures[location] !== texture) {
                    gl.bindTexture(texture.target, glTexture.texture);
                }
                if (glTexture.dirtyId !== texture.dirtyId) {
                    this.updateTexture(texture);
                }
                this.boundTextures[location] = texture;
            }
        }
        else {
            if (this.currentLocation !== location) {
                this.currentLocation = location;
                gl.activeTexture(gl.TEXTURE0 + location);
            }
            gl.bindTexture(gl.TEXTURE_2D, this.emptyTextures[gl.TEXTURE_2D].texture);
            this.boundTextures[location] = null;
        }
    }
    ;
    /**
     * Resets texture location and bound textures
     *
     * Actual `bind(null, i)` calls will be performed at next `unbind()` call
     */
    reset() {
        this._unknownBoundTextures = true;
        this.currentLocation = -1;
        for (var i = 0; i < this.boundTextures.length; i++) {
            this.boundTextures[i] = this.unknownTexture;
        }
    }
    ;
    /**
     * Unbind a texture
     * @param {PIXI.Texture|PIXI.BaseTexture} texture - Texture to bind
     */
    unbind(texture) {
        var ref = this;
        var gl = ref.gl;
        var boundTextures = ref.boundTextures;
        if (this._unknownBoundTextures) {
            this._unknownBoundTextures = false;
            // someone changed webGL state,
            // we have to be sure that our texture does not appear in multi-texture renderer samplers
            for (var i = 0; i < boundTextures.length; i++) {
                if (boundTextures[i] === this.unknownTexture) {
                    this.bind(null, i);
                }
            }
        }
        for (var i$1 = 0; i$1 < boundTextures.length; i$1++) {
            if (boundTextures[i$1] === texture) {
                if (this.currentLocation !== i$1) {
                    gl.activeTexture(gl.TEXTURE0 + i$1);
                    this.currentLocation = i$1;
                }
                gl.bindTexture(gl.TEXTURE_2D, this.emptyTextures[texture.target].texture);
                boundTextures[i$1] = null;
            }
        }
    }
    ;
    /**
     * Initialize a texture
     *
     * @private
     * @param {PIXI.BaseTexture} texture - Texture to initialize
     */
    initTexture(texture) {
        var glTexture = new GLTexture_1.GLTexture(this.gl.createTexture());
        // guarantee an update..
        glTexture.dirtyId = -1;
        texture._glTextures[this.CONTEXT_UID] = glTexture;
        this.managedTextures.push(texture);
        // texture.on('dispose', this.destroyTexture, this);
        return glTexture;
    }
    ;
    /**
     * Update a texture
     *
     * @private
     * @param {PIXI.BaseTexture} texture - Texture to initialize
     */
    updateTexture(texture) {
        var glTexture = texture._glTextures[this.CONTEXT_UID];
        var renderer = this.renderer;
        if (texture.resource && texture.resource.canUpload) {
            texture.resource.upload(renderer, texture, glTexture);
        }
        // if (texture.resource && texture.resource.upload(renderer, texture, glTexture))
        else if (texture.resource && this.uploadTexture(renderer, texture, glTexture, texture.resource)) {
        }
        else {
            // default, renderTexture-like logic
            var width = texture.realWidth;
            var height = texture.realHeight;
            var gl = renderer.gl;
            if (glTexture.width !== width
                || glTexture.height !== height
                || glTexture.dirtyId < 0) {
                glTexture.width = width;
                glTexture.height = height;
                gl.texImage2D(texture.target, 0, texture.format, width, height, 0, texture.format, texture.type, null);
            }
        }
        // lets only update what changes..
        if (texture.dirtyStyleId !== glTexture.dirtyStyleId) {
            this.updateTextureStyle(texture);
        }
        glTexture.dirtyId = texture.dirtyId;
    }
    ;
    uploadTexture(renderer, baseTexture, glTexture, source) {
        var gl = renderer.gl;
        var width = baseTexture.realWidth;
        var height = baseTexture.realHeight;
        // source = source || this.source;
        if (source.constructor['name'] == "CanvasResource") {
            source = source.source;
        }
        else if (source.constructor['name'] == "ImageResource") {
            source = source.source;
        }
        else if (source.constructor['name'] == "VideoResource") {
            source = source.source;
        }
        // else if(source.constructor['name'] == "GradientResource")
        // {
        //     if(!source.source)
        //     {
        //         return
        //     }
        //     source = source.source
        //     reveal(source)
        // }
        else {
            Logger_1.reveal(source);
        }
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, baseTexture.premultiplyAlpha);
        if (baseTexture.target === gl.TEXTURE_2D && glTexture.width === width && glTexture.height === height) {
            gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, baseTexture.format, baseTexture.type, source);
        }
        else {
            glTexture.width = width;
            glTexture.height = height;
            gl.texImage2D(baseTexture.target, 0, baseTexture.format, baseTexture.format, baseTexture.type, source);
        }
        return true;
    }
    ;
    /**
     * Deletes the texture from WebGL
     *
     * @private
     * @param {PIXI.BaseTexture|PIXI.Texture} texture - the texture to destroy
     * @param {boolean} [skipRemove=false] - Whether to skip removing the texture from the TextureManager.
     */
    destroyTexture(texture, skipRemove = false) {
        var ref = this;
        var gl = ref.gl;
        texture = texture.baseTexture || texture;
        if (texture._glTextures[this.renderer.CONTEXT_UID]) {
            this.unbind(texture);
            gl.deleteTexture(texture._glTextures[this.renderer.CONTEXT_UID].texture);
            // texture.off('dispose', this.destroyTexture, this);
            delete texture._glTextures[this.renderer.CONTEXT_UID];
            if (!skipRemove) {
                var i = this.managedTextures.indexOf(texture);
                if (i !== -1) {
                    UtilsSettings_1.UtilsSettings.removeItems(this.managedTextures, i, 1);
                }
            }
        }
    }
    ;
    /**
     * Update texture style such as mipmap flag
     *
     * @private
     * @param {PIXI.BaseTexture} texture - Texture to update
     */
    updateTextureStyle(texture) {
        var glTexture = texture._glTextures[this.CONTEXT_UID];
        if (!glTexture) {
            return;
        }
        if ((texture.mipmap === WebGLSettings_1.WebGLSettings.MIPMAP_MODES.POW2 || this.webGLVersion !== 2) && !texture.isPowerOfTwo) {
            glTexture.mipmap = 0;
            glTexture.wrapMode = WebGLSettings_1.WebGLSettings.WRAP_MODES.CLAMP;
        }
        else {
            glTexture.mipmap = texture.mipmap >= 1;
            glTexture.wrapMode = texture.wrapMode;
        }
        // if (texture.resource && texture.resource.style(this.renderer, texture, glTexture))
        // { ; }
        // else
        // {
        this.setStyle(texture, glTexture);
        // }
        glTexture.dirtyStyleId = texture.dirtyStyleId;
    }
    ;
    /**
     * Set style for texture
     *
     * @private
     * @param {PIXI.BaseTexture} texture - Texture to update
     * @param {glTexture} glTexture
     */
    setStyle(texture, glTexture) {
        var gl = this.gl;
        if (glTexture.mipmap) {
            gl.generateMipmap(texture.target);
        }
        gl.texParameteri(texture.target, gl.TEXTURE_WRAP_S, glTexture.wrapMode);
        gl.texParameteri(texture.target, gl.TEXTURE_WRAP_T, glTexture.wrapMode);
        if (glTexture.mipmap) {
            /* eslint-disable max-len */
            gl.texParameteri(texture.target, gl.TEXTURE_MIN_FILTER, texture.scaleMode ? gl.LINEAR_MIPMAP_LINEAR : gl.NEAREST_MIPMAP_NEAREST);
            /* eslint-disable max-len */
        }
        else {
            gl.texParameteri(texture.target, gl.TEXTURE_MIN_FILTER, texture.scaleMode ? gl.LINEAR : gl.NEAREST);
        }
        gl.texParameteri(texture.target, gl.TEXTURE_MAG_FILTER, texture.scaleMode ? gl.LINEAR : gl.NEAREST);
    }
    ;
}
exports.TextureSystem = TextureSystem;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/TextureUvs.js":
/*!**********************************************!*\
  !*** ./js-compile/raw-pixi-ts/TextureUvs.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const GroupD8_1 = __webpack_require__(/*! ./GroupD8 */ "./js-compile/raw-pixi-ts/GroupD8.js");
class TextureUvs {
    constructor() {
        this.x0 = 0;
        this.y0 = 0;
        this.x1 = 1;
        this.y1 = 0;
        this.x2 = 1;
        this.y2 = 1;
        this.x3 = 0;
        this.y3 = 1;
        this.uvsFloat32 = new Float32Array(8);
    }
    /**
 * Sets the texture Uvs based on the given frame information.
 *
 * @protected
 * @param {PIXI.Rectangle} frame - The frame of the texture
 * @param {PIXI.Rectangle} baseFrame - The base frame of the texture
 * @param {number} rotate - Rotation of frame, see {@link PIXI.GroupD8}
 */
    set(frame, baseFrame, rotate) {
        var tw = baseFrame.width;
        var th = baseFrame.height;
        if (rotate) {
            // width and height div 2 div baseFrame size
            var w2 = frame.width / 2 / tw;
            var h2 = frame.height / 2 / th;
            // coordinates of center
            var cX = (frame.x / tw) + w2;
            var cY = (frame.y / th) + h2;
            rotate = GroupD8_1.GroupD8.add(rotate, GroupD8_1.GroupD8.NW); // NW is top-left corner
            this.x0 = cX + (w2 * GroupD8_1.GroupD8.uX(rotate));
            this.y0 = cY + (h2 * GroupD8_1.GroupD8.uY(rotate));
            rotate = GroupD8_1.GroupD8.add(rotate, 2); // rotate 90 degrees clockwise
            this.x1 = cX + (w2 * GroupD8_1.GroupD8.uX(rotate));
            this.y1 = cY + (h2 * GroupD8_1.GroupD8.uY(rotate));
            rotate = GroupD8_1.GroupD8.add(rotate, 2);
            this.x2 = cX + (w2 * GroupD8_1.GroupD8.uX(rotate));
            this.y2 = cY + (h2 * GroupD8_1.GroupD8.uY(rotate));
            rotate = GroupD8_1.GroupD8.add(rotate, 2);
            this.x3 = cX + (w2 * GroupD8_1.GroupD8.uX(rotate));
            this.y3 = cY + (h2 * GroupD8_1.GroupD8.uY(rotate));
        }
        else {
            this.x0 = frame.x / tw;
            this.y0 = frame.y / th;
            this.x1 = (frame.x + frame.width) / tw;
            this.y1 = frame.y / th;
            this.x2 = (frame.x + frame.width) / tw;
            this.y2 = (frame.y + frame.height) / th;
            this.x3 = frame.x / tw;
            this.y3 = (frame.y + frame.height) / th;
        }
        this.uvsFloat32[0] = this.x0;
        this.uvsFloat32[1] = this.y0;
        this.uvsFloat32[2] = this.x1;
        this.uvsFloat32[3] = this.y1;
        this.uvsFloat32[4] = this.x2;
        this.uvsFloat32[5] = this.y2;
        this.uvsFloat32[6] = this.x3;
        this.uvsFloat32[7] = this.y3;
    }
    ;
}
exports.TextureUvs = TextureUvs;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/Ticker.js":
/*!******************************************!*\
  !*** ./js-compile/raw-pixi-ts/Ticker.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const EventDispatcher_1 = __webpack_require__(/*! ./EventDispatcher */ "./js-compile/raw-pixi-ts/EventDispatcher.js");
const TickerListener_1 = __webpack_require__(/*! ./TickerListener */ "./js-compile/raw-pixi-ts/TickerListener.js");
const settings_1 = __webpack_require__(/*! ./settings */ "./js-compile/raw-pixi-ts/settings.js");
class Ticker extends EventDispatcher_1.EventDispatcher {
    constructor() {
        super();
        var this$1 = this;
        /**
         * The first listener. All new listeners added are chained on this.
         * @private
         * @type {TickerListener}
         */
        this._head = new TickerListener_1.TickerListener(null, null, Infinity);
        /**
         * Internal current frame request ID
         * @type {?number}
         * @private
         */
        this._requestId = null;
        /**
         * Internal value managed by minFPS property setter and getter.
         * This is the maximum allowed milliseconds between updates.
         * @type {number}
         * @private
         */
        this._maxElapsedMS = 100;
        /**
         * Internal value managed by maxFPS property setter and getter.
         * This is the minimum allowed milliseconds between updates.
         * @private
         */
        this._minElapsedMS = 0;
        /**
         * Whether or not this ticker should invoke the method
         * {@link PIXI.Ticker#start} automatically
         * when a listener is added.
         *
         * @member {boolean}
         * @default false
         */
        this.autoStart = false;
        /**
         * Scalar time value from last frame to this frame.
         * This value is capped by setting {@link PIXI.Ticker#minFPS}
         * and is scaled with {@link PIXI.Ticker#speed}.
         * **Note:** The cap may be exceeded by scaling.
         *
         * @member {number}
         * @default 1
         */
        this.deltaTime = 1;
        /**
         * Scaler time elapsed in milliseconds from last frame to this frame.
         * This value is capped by setting {@link PIXI.Ticker#minFPS}
         * and is scaled with {@link PIXI.Ticker#speed}.
         * **Note:** The cap may be exceeded by scaling.
         * If the platform supports DOMHighResTimeStamp,
         * this value will have a precision of 1 s.
         * Defaults to target frame time
         *
         * @member {number}
         * @default 16.66
         */
        this.deltaMS = 1 / settings_1.settings.TARGET_FPMS;
        /**
         * Time elapsed in milliseconds from last frame to this frame.
         * Opposed to what the scalar {@link PIXI.Ticker#deltaTime}
         * is based, this value is neither capped nor scaled.
         * If the platform supports DOMHighResTimeStamp,
         * this value will have a precision of 1 s.
         * Defaults to target frame time
         *
         * @member {number}
         * @default 16.66
         */
        this.elapsedMS = 1 / settings_1.settings.TARGET_FPMS;
        /**
         * The last time {@link PIXI.Ticker#update} was invoked.
         * This value is also reset internally outside of invoking
         * update, but only when a new animation frame is requested.
         * If the platform supports DOMHighResTimeStamp,
         * this value will have a precision of 1 s.
         *
         * @member {number}
         * @default -1
         */
        this.lastTime = -1;
        /**
         * Factor of current {@link PIXI.Ticker#deltaTime}.
         * @example
         * // Scales ticker.deltaTime to what would be
         * // the equivalent of approximately 120 FPS
         * ticker.speed = 2;
         *
         * @member {number}
         * @default 1
         */
        this.speed = 1;
        /**
         * Whether or not this ticker has been started.
         * `true` if {@link PIXI.Ticker#start} has been called.
         * `false` if {@link PIXI.Ticker#stop} has been called.
         * While `false`, this value may change to `true` in the
         * event of {@link PIXI.Ticker#autoStart} being `true`
         * and a listener is added.
         *
         * @member {boolean}
         * @default false
         */
        this.started = false;
        /**
         * If enabled, deleting is disabled.
         * @member {boolean}
         * @default false
         * @private
         */
        this._protected = false;
        /**
         * Internal tick method bound to ticker instance.
         * This is because in early 2015, Function.bind
         * is still 60% slower in high performance scenarios.
         * Also separating frame requests from update method
         * so listeners may be called at any time and with
         * any animation API, just invoke ticker.update(time).
         *
         * @private
         * @param {number} time - Time since last tick.
         */
        this._tick = function (time) {
            this$1._requestId = null;
            if (this$1.started) {
                // Invoke listeners now
                this$1.update(time);
                // Listener side effects may have modified ticker state.
                if (this$1.started && this$1._requestId === null && this$1._head.next) {
                    this$1._requestId = requestAnimationFrame(this$1._tick);
                }
            }
        };
    }
    /**
     * Internally adds the event handler so that it can be sorted by priority.
     * Priority allows certain handler (user, AnimatedSprite, Interaction) to be run
     * before the rendering.
     *
     * @private
     * @param {TickerListener} listener - Current listener being added.
     * @returns {PIXI.Ticker} This instance of a ticker
     */
    _addListener(listener) {
        // For attaching to head
        var current = this._head.next;
        var previous = this._head;
        // Add the first item
        if (!current) {
            listener.connect(previous);
        }
        else {
            // Go from highest to lowest priority
            while (current) {
                if (listener.priority > current.priority) {
                    listener.connect(previous);
                    break;
                }
                previous = current;
                current = current.next;
            }
            // Not yet connected
            if (!listener.previous) {
                listener.connect(previous);
            }
        }
        this._startIfPossible();
        return this;
    }
    ;
    /**
     * Triggers an update. An update entails setting the
     * current {@link PIXI.Ticker#elapsedMS},
     * the current {@link PIXI.Ticker#deltaTime},
     * invoking all listeners with current deltaTime,
     * and then finally setting {@link PIXI.Ticker#lastTime}
     * with the value of currentTime that was provided.
     * This method will be called automatically by animation
     * frame callbacks if the ticker instance has been started
     * and listeners are added.
     *
     * @param {number} [currentTime=performance.now()] - the current time of execution
     */
    update(currentTime) {
        if (currentTime === void 0) {
            currentTime = performance.now();
        }
        var elapsedMS;
        // If the difference in time is zero or negative, we ignore most of the work done here.
        // If there is no valid difference, then should be no reason to let anyone know about it.
        // A zero delta, is exactly that, nothing should update.
        //
        // The difference in time can be negative, and no this does not mean time traveling.
        // This can be the result of a race condition between when an animation frame is requested
        // on the current JavaScript engine event loop, and when the ticker's start method is invoked
        // (which invokes the internal _requestIfNeeded method). If a frame is requested before
        // _requestIfNeeded is invoked, then the callback for the animation frame the ticker requests,
        // can receive a time argument that can be less than the lastTime value that was set within
        // _requestIfNeeded. This difference is in microseconds, but this is enough to cause problems.
        //
        // This check covers this browser engine timing issue, as well as if consumers pass an invalid
        // currentTime value. This may happen if consumers opt-out of the autoStart, and update themselves.
        if (currentTime > this.lastTime) {
            // Save uncapped elapsedMS for measurement
            elapsedMS = this.elapsedMS = currentTime - this.lastTime;
            // cap the milliseconds elapsed used for deltaTime
            if (elapsedMS > this._maxElapsedMS) {
                elapsedMS = this._maxElapsedMS;
            }
            elapsedMS *= this.speed;
            // if not enough time has passed, exit the function.
            // We give an extra ms to elapsedMS for this check, because the nature of
            // request animation frame means that not all browsers will return precise values.
            // However, because rAF works based on v-sync, it's won't change the effective FPS.
            if (this._minElapsedMS && elapsedMS + 1 < this._minElapsedMS) {
                return;
            }
            this.deltaMS = elapsedMS;
            this.deltaTime = this.deltaMS * settings_1.settings.TARGET_FPMS;
            // Cache a local reference, in-case ticker is destroyed
            // during the emit, we can still check for head.next
            var head = this._head;
            // Invoke listeners added to internal emitter
            var listener = head.next;
            while (listener) {
                listener = listener.emit(this.deltaTime);
            }
            if (!head.next) {
                this._cancelIfNeeded();
            }
        }
        else {
            this.deltaTime = this.deltaMS = this.elapsedMS = 0;
        }
        this.lastTime = currentTime;
    }
    ;
    /**
     * Destroy the ticker and don't use after this. Calling
     * this method removes all references to internal events.
     */
    destroy() {
        if (!this._protected) {
            this.stop();
            var listener = this._head.next;
            while (listener) {
                listener = listener.destroy(true);
            }
            this._head.destroy();
            this._head = null;
        }
    }
    ;
    /**
     * Stops the ticker. If the ticker has requested
     * an animation frame it is canceled at this point.
     */
    stop() {
        if (this.started) {
            this.started = false;
            this._cancelIfNeeded();
        }
    }
    ;
    /**
     * Starts the ticker. If the ticker has listeners
     * a new animation frame is requested at this point.
     */
    start() {
        if (!this.started) {
            this.started = true;
            this._requestIfNeeded();
        }
    }
    ;
    /**
     * Removes any handlers matching the function and context parameters.
     * If no handlers are left after removing, then it cancels the animation frame.
     *
     * @param {Function} fn - The listener function to be removed
     * @param {*} [context] - The listener context to be removed
     * @returns {PIXI.Ticker} This instance of a ticker
     */
    remove(fn, context) {
        var listener = this._head.next;
        while (listener) {
            // We found a match, lets remove it
            // no break to delete all possible matches
            // incase a listener was added 2+ times
            if (listener.match(fn, context)) {
                listener = listener.destroy();
            }
            else {
                listener = listener.next;
            }
        }
        if (!this._head.next) {
            this._cancelIfNeeded();
        }
        return this;
    }
    ;
    /**
     * Add a handler for the tick event which is only execute once.
     *
     * @param {Function} fn - The listener function to be added for one update
     * @param {*} [context] - The listener context
     * @param {number} [priority=PIXI.UPDATE_PRIORITY.NORMAL] - The priority for emitting
     * @returns {PIXI.Ticker} This instance of a ticker
     */
    addOnce(fn, context, priority) {
        if (priority === void 0) {
            priority = Ticker.UPDATE_PRIORITY.NORMAL;
        }
        return this._addListener(new TickerListener_1.TickerListener(fn, context, priority, true));
    }
    ;
    /**
     * Register a handler for tick events. Calls continuously unless
     * it is removed or the ticker is stopped.
     *
     * @param {Function} fn - The listener function to be added for updates
     * @param {*} [context] - The listener context
     * @param {number} [priority=PIXI.UPDATE_PRIORITY.NORMAL] - The priority for emitting
     * @returns {PIXI.Ticker} This instance of a ticker
     */
    add(fn, context = null, priority = null) {
        if (priority === void 0) {
            priority = Ticker.UPDATE_PRIORITY.NORMAL;
        }
        return this._addListener(new TickerListener_1.TickerListener(fn, context, priority));
    }
    ;
    /**
     * Conditionally requests a new animation frame.
     * If the ticker has been started it checks if a frame has not already
     * been requested, and if the internal emitter has listeners. If these
     * conditions are met, a new frame is requested. If the ticker has not
     * been started, but autoStart is `true`, then the ticker starts now,
     * and continues with the previous conditions to request a new frame.
     *
     * @private
     */
    _startIfPossible() {
        if (this.started) {
            this._requestIfNeeded();
        }
        else if (this.autoStart) {
            this.start();
        }
    }
    ;
    /**
     * Conditionally cancels a pending animation frame.
     *
     * @private
     */
    _cancelIfNeeded() {
        if (this._requestId !== null) {
            cancelAnimationFrame(this._requestId);
            this._requestId = null;
        }
    }
    ;
    /**
 * Conditionally requests a new animation frame.
 * If a frame has not already been requested, and if the internal
 * emitter has listeners, a new frame is requested.
 *
 * @private
 */
    _requestIfNeeded() {
        if (this._requestId === null && this._head.next) {
            // ensure callbacks get correct delta
            this.lastTime = performance.now();
            this._requestId = requestAnimationFrame(this._tick);
        }
    }
    ;
    /**
     * The frames per second at which this ticker is running.
     * The default is approximately 60 in most modern browsers.
     * **Note:** This does not factor in the value of
     * {@link PIXI.Ticker#speed}, which is specific
     * to scaling {@link PIXI.Ticker#deltaTime}.
     *
     * @member {number}
     * @readonly
     */
    get FPS() {
        return 1000 / this.elapsedMS;
    }
    ;
    /**
     * Manages the maximum amount of milliseconds allowed to
     * elapse between invoking {@link PIXI.Ticker#update}.
     * This value is used to cap {@link PIXI.Ticker#deltaTime},
     * but does not effect the measured value of {@link PIXI.Ticker#FPS}.
     * When setting this property it is clamped to a value between
     * `0` and `PIXI.settings.TARGET_FPMS * 1000`.
     *
     * @member {number}
     * @default 10
     */
    get minFPS() {
        return 1000 / this._maxElapsedMS;
    }
    ;
    set minFPS(fps) {
        // Minimum must be below the maxFPS
        var minFPS = Math.min(this.maxFPS, fps);
        // Must be at least 0, but below 1 / settings.TARGET_FPMS
        var minFPMS = Math.min(Math.max(0, minFPS) / 1000, settings_1.settings.TARGET_FPMS);
        this._maxElapsedMS = 1 / minFPMS;
    }
    ;
    set maxFPS(fps) {
        if (fps / 1000 >= settings_1.settings.TARGET_FPMS) {
            this._minElapsedMS = 0;
        }
        else {
            // Max must be at least the minFPS
            var maxFPS = Math.max(this.minFPS, fps);
            // Must be at least 1, but below 1 / settings.TARGET_FPMS
            var maxFPMS = Math.min(Math.max(1, maxFPS) / 1000, settings_1.settings.TARGET_FPMS);
            this._minElapsedMS = 1 / maxFPMS;
        }
    }
    ;
    /**
 * The shared ticker instance used by {@link PIXI.AnimatedSprite} and by
 * {@link PIXI.VideoResource} to update animation frames / video textures.
 *
 * It may also be used by {@link PIXI.Application} if created with the `sharedTicker` option property set to true.
 *
 * The property {@link PIXI.Ticker#autoStart} is set to `true` for this instance.
 * Please follow the examples for usage, including how to opt-out of auto-starting the shared ticker.
 *
 * @example
 * let ticker = PIXI.Ticker.shared;
 * // Set this to prevent starting this ticker when listeners are added.
 * // By default this is true only for the PIXI.Ticker.shared instance.
 * ticker.autoStart = false;
 * // FYI, call this to ensure the ticker is stopped. It should be stopped
 * // if you have not attempted to render anything yet.
 * ticker.stop();
 * // Call this when you are ready for a running shared ticker.
 * ticker.start();
 *
 * @example
 * // You may use the shared ticker to render...
 * let renderer = PIXI.autoDetectRenderer();
 * let stage = new PIXI.Container();
 * document.body.appendChild(renderer.view);
 * ticker.add(function (time) {
 * renderer.render(stage);
 * });
 *
 * @example
 * // Or you can just update it manually.
 * ticker.autoStart = false;
 * ticker.stop();
 * function animate(time) {
 * ticker.update(time);
 * renderer.render(stage);
 * requestAnimationFrame(animate);
 * }
 * animate(performance.now());
 *
 * @member {PIXI.Ticker}
 * @static
 */
    static get shared() {
        if (!Ticker._shared) {
            var shared = Ticker._shared = new Ticker();
            shared.autoStart = true;
            shared._protected = true;
        }
        return Ticker._shared;
    }
    ;
    /**
     * The system ticker instance used by {@link PIXI.interaction.InteractionManager} and by
     * {@link PIXI.BasePrepare} for core timing functionality that shouldn't usually need to be paused,
     * unlike the `shared` ticker which drives visual animations and rendering which may want to be paused.
     *
     * The property {@link PIXI.Ticker#autoStart} is set to `true` for this instance.
     *
     * @member {PIXI.Ticker}
     * @static
     */
    static get system() {
        if (!Ticker._system) {
            var system = Ticker._system = new Ticker();
            system.autoStart = true;
            system._protected = true;
        }
        return Ticker._system;
    }
    ;
    /**
     * Manages the minimum amount of milliseconds allowed to
     * elapse between invoking {@link PIXI.Ticker#update}.
     * This will effect the measured value of {@link PIXI.ticker.Ticker#FPS}.
     * When setting this property it is clamped to a value between
     * `1` and `TARGET_FPMS * 1000`.
     *
     * @member {number}
     * @default 60
     */
    get maxFPS() {
        if (this._minElapsedMS) {
            return 1000 / this._minElapsedMS;
        }
        return settings_1.settings.TARGET_FPMS * 1000;
    }
    ;
}
/**
 * Represents the update priorities used by internal PIXI classes when registered with
 * the {@link PIXI.Ticker} object. Higher priority items are updated first and lower
 * priority items, such as render, should go later.
 *
 * @static
 * @constant
 * @name UPDATE_PRIORITY
 * @memberof PIXI
 * @type {object}
 * @property {number} INTERACTION=50 Highest priority, used for {@link PIXI.interaction.InteractionManager}
 * @property {number} HIGH=25 High priority updating, {@link PIXI.VideoBaseTexture} and {@link PIXI.AnimatedSprite}
 * @property {number} NORMAL=0 Default priority for ticker events, see {@link PIXI.Ticker#add}.
 * @property {number} LOW=-25 Low priority used for {@link PIXI.Application} rendering.
 * @property {number} UTILITY=-50 Lowest priority used for {@link PIXI.prepare.BasePrepare} utility.
 */
Ticker.UPDATE_PRIORITY = {
    INTERACTION: 50,
    HIGH: 25,
    NORMAL: 0,
    LOW: -25,
    UTILITY: -50,
};
exports.Ticker = Ticker;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/TickerListener.js":
/*!**************************************************!*\
  !*** ./js-compile/raw-pixi-ts/TickerListener.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class TickerListener {
    constructor(fn, context, priority, once = false) {
        if (context === void 0) {
            context = null;
        }
        if (priority === void 0) {
            priority = 0;
        }
        if (once === void 0) {
            once = false;
        }
        /**
         * The handler function to execute.
         * @private
         * @member {Function}
         */
        this.fn = fn;
        /**
         * The calling to execute.
         * @private
         * @member {*}
         */
        this.context = context;
        /**
         * The current priority.
         * @private
         * @member {number}
         */
        this.priority = priority;
        /**
         * If this should only execute once.
         * @private
         * @member {boolean}
         */
        this.once = once;
        /**
         * The next item in chain.
         * @private
         * @member {TickerListener}
         */
        this.next = null;
        /**
         * The previous item in chain.
         * @private
         * @member {TickerListener}
         */
        this.previous = null;
        /**
         * `true` if this listener has been destroyed already.
         * @member {boolean}
         * @private
         */
        this._destroyed = false;
    }
    /**
     * Emit by calling the current function.
     * @private
     * @param {number} deltaTime - time since the last emit.
     * @return {TickerListener} Next ticker
     */
    emit(deltaTime) {
        if (this.fn) {
            if (this.context) {
                this.fn.call(this.context, deltaTime);
            }
            else {
                this.fn(deltaTime);
            }
        }
        var redirect = this.next;
        if (this.once) {
            this.destroy(true);
        }
        // Soft-destroying should remove
        // the next reference
        if (this._destroyed) {
            this.next = null;
        }
        return redirect;
    }
    ;
    /**
     * Destroy and don't use after this.
     * @private
     * @param {boolean} [hard = false] `true` to remove the `next` reference, this
     *    is considered a hard destroy. Soft destroy maintains the next reference.
     * @return {TickerListener} The listener to redirect while emitting or removing.
     */
    destroy(hard) {
        if (hard === void 0) {
            hard = false;
        }
        this._destroyed = true;
        this.fn = null;
        this.context = null;
        // Disconnect, hook up next and previous
        if (this.previous) {
            this.previous.next = this.next;
        }
        if (this.next) {
            this.next.previous = this.previous;
        }
        // Redirect to the next item
        var redirect = this.next;
        // Remove references
        this.next = hard ? null : redirect;
        this.previous = null;
        return redirect;
    }
    ;
    /**
     * Connect to the list.
     * @private
     * @param {TickerListener} previous - Input node, previous listener
     */
    connect(previous) {
        this.previous = previous;
        if (previous.next) {
            previous.next.previous = this;
        }
        this.next = previous.next;
        previous.next = this;
    }
    ;
    /**
     * Simple compare function to figure out if a function and context match.
     * @private
     * @param {Function} fn - The listener function to be added for one update
     * @param {Function} context - The listener context
     * @return {boolean} `true` if the listener match the arguments
     */
    match(fn, context) {
        context = context || null;
        return this.fn === fn && this.context === context;
    }
    ;
}
exports.TickerListener = TickerListener;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/TilingSpriteRenderer.js":
/*!********************************************************!*\
  !*** ./js-compile/raw-pixi-ts/TilingSpriteRenderer.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const ObjectRenderer_1 = __webpack_require__(/*! ./ObjectRenderer */ "./js-compile/raw-pixi-ts/ObjectRenderer.js");
const Shader_1 = __webpack_require__(/*! ./Shader */ "./js-compile/raw-pixi-ts/Shader.js");
const QuadUv_1 = __webpack_require__(/*! ./QuadUv */ "./js-compile/raw-pixi-ts/QuadUv.js");
const Matrix_1 = __webpack_require__(/*! ./Matrix */ "./js-compile/raw-pixi-ts/Matrix.js");
const WebGLSettings_1 = __webpack_require__(/*! ./WebGLSettings */ "./js-compile/raw-pixi-ts/WebGLSettings.js");
const ColorSettings_1 = __webpack_require__(/*! ./ColorSettings */ "./js-compile/raw-pixi-ts/ColorSettings.js");
const BlendModesSettings_1 = __webpack_require__(/*! ./BlendModesSettings */ "./js-compile/raw-pixi-ts/BlendModesSettings.js");
class TilingSpriteRenderer extends ObjectRenderer_1.ObjectRenderer {
    constructor(renderer) {
        super(renderer);
        var uniforms = { globals: this.renderer.globalUniforms };
        this.shader = Shader_1.Shader.from(TilingSpriteRenderer.vertex$3, TilingSpriteRenderer.fragment$2, uniforms);
        this.simpleShader = Shader_1.Shader.from(TilingSpriteRenderer.vertex$3, TilingSpriteRenderer.fragmentSimple, uniforms);
        this.quad = new QuadUv_1.QuadUv();
    }
    /**
     *
     * @param {PIXI.TilingSprite} ts tilingSprite to be rendered
     */
    render(ts) {
        var renderer = this.renderer;
        var quad = this.quad;
        var vertices = quad.vertices;
        vertices[0] = vertices[6] = (ts._width) * -ts.anchor.x;
        vertices[1] = vertices[3] = ts._height * -ts.anchor.y;
        vertices[2] = vertices[4] = (ts._width) * (1.0 - ts.anchor.x);
        vertices[5] = vertices[7] = ts._height * (1.0 - ts.anchor.y);
        if (ts.uvRespectAnchor) {
            vertices = quad.uvs;
            vertices[0] = vertices[6] = -ts.anchor.x;
            vertices[1] = vertices[3] = -ts.anchor.y;
            vertices[2] = vertices[4] = 1.0 - ts.anchor.x;
            vertices[5] = vertices[7] = 1.0 - ts.anchor.y;
        }
        quad.invalidate();
        var tex = ts._texture;
        var baseTex = tex.baseTexture;
        var lt = ts.tileTransform.localTransform;
        var uv = ts.uvMatrix;
        var isSimple = baseTex.isPowerOfTwo
            && tex.frame.width === baseTex.width && tex.frame.height === baseTex.height;
        // auto, force repeat wrapMode for big tiling textures
        if (isSimple) {
            if (!baseTex._glTextures[renderer.CONTEXT_UID]) {
                if (baseTex.wrapMode === WebGLSettings_1.WebGLSettings.WRAP_MODES.CLAMP) {
                    baseTex.wrapMode = WebGLSettings_1.WebGLSettings.WRAP_MODES.REPEAT;
                }
            }
            else {
                isSimple = baseTex.wrapMode !== WebGLSettings_1.WebGLSettings.WRAP_MODES.CLAMP;
            }
        }
        var shader = isSimple ? this.simpleShader : this.shader;
        var w = tex.width;
        var h = tex.height;
        var W = ts._width;
        var H = ts._height;
        TilingSpriteRenderer.tempMat$1.set(lt.a * w / W, lt.b * w / H, lt.c * h / W, lt.d * h / H, lt.tx / W, lt.ty / H);
        // that part is the same as above:
        // tempMat.identity();
        // tempMat.scale(tex.width, tex.height);
        // tempMat.prepend(lt);
        // tempMat.scale(1.0 / ts._width, 1.0 / ts._height);
        TilingSpriteRenderer.tempMat$1.invert();
        if (isSimple) {
            TilingSpriteRenderer.tempMat$1.prepend(uv.mapCoord);
        }
        else {
            shader.uniforms.uMapCoord = uv.mapCoord.toArray(true);
            shader.uniforms.uClampFrame = uv.uClampFrame;
            shader.uniforms.uClampOffset = uv.uClampOffset;
        }
        shader.uniforms.uTransform = TilingSpriteRenderer.tempMat$1.toArray(true);
        shader.uniforms.uColor = ColorSettings_1.ColorSettings.premultiplyTintToRgba(ts.tint, ts.worldAlpha, shader.uniforms.uColor, baseTex.premultiplyAlpha);
        shader.uniforms.translationMatrix = ts.transform.worldTransform.toArray(true);
        shader.uniforms.uSampler = tex;
        renderer.shader.bind(shader);
        renderer.geometry.bind(quad); // , renderer.shader.getGLShader());
        renderer.state.setBlendMode(BlendModesSettings_1.BlendModesSettings.correctBlendMode(ts.blendMode, baseTex.premultiplyAlpha));
        renderer.geometry.draw(this.renderer.gl.TRIANGLES, 6, 0);
    }
    ;
}
TilingSpriteRenderer.fragmentSimple = "varying vec2 vTextureCoord;\r\n\r\nuniform sampler2D uSampler;\r\nuniform vec4 uColor;\r\n\r\nvoid main(void)\r\n{\r\n    vec4 sample = texture2D(uSampler, vTextureCoord);\r\n    gl_FragColor = sample * uColor;\r\n}\r\n";
TilingSpriteRenderer.fragment$2 = "varying vec2 vTextureCoord;\r\n\r\nuniform sampler2D uSampler;\r\nuniform vec4 uColor;\r\nuniform mat3 uMapCoord;\r\nuniform vec4 uClampFrame;\r\nuniform vec2 uClampOffset;\r\n\r\nvoid main(void)\r\n{\r\n    vec2 coord = mod(vTextureCoord - uClampOffset, vec2(1.0, 1.0)) + uClampOffset;\r\n    coord = (uMapCoord * vec3(coord, 1.0)).xy;\r\n    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\r\n\r\n    vec4 sample = texture2D(uSampler, coord);\r\n    gl_FragColor = sample * uColor;\r\n}\r\n";
TilingSpriteRenderer.vertex$3 = "attribute vec2 aVertexPosition;\r\nattribute vec2 aTextureCoord;\r\n\r\nuniform mat3 projectionMatrix;\r\nuniform mat3 translationMatrix;\r\nuniform mat3 uTransform;\r\n\r\nvarying vec2 vTextureCoord;\r\n\r\nvoid main(void)\r\n{\r\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\r\n\r\n    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;\r\n}\r\n";
TilingSpriteRenderer.tempMat$1 = new Matrix_1.Matrix();
exports.TilingSpriteRenderer = TilingSpriteRenderer;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/Transform.js":
/*!*********************************************!*\
  !*** ./js-compile/raw-pixi-ts/Transform.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Matrix_1 = __webpack_require__(/*! ./Matrix */ "./js-compile/raw-pixi-ts/Matrix.js");
const ObservablePoint_1 = __webpack_require__(/*! ./ObservablePoint */ "./js-compile/raw-pixi-ts/ObservablePoint.js");
class Transform {
    constructor() {
        /**
                 * The global matrix transform. It can be swapped temporarily by some functions like getLocalBounds()
                 *
                 * @member {PIXI.Matrix}
                 */
        this.worldTransform = new Matrix_1.Matrix();
        /**
         * The local matrix transform
         *
         * @member {PIXI.Matrix}
         */
        this.localTransform = new Matrix_1.Matrix();
        /**
         * The coordinate of the object relative to the local coordinates of the parent.
         *
         * @member {PIXI.ObservablePoint}
         */
        this.position = new ObservablePoint_1.ObservablePoint(this.onChange, this, 0, 0);
        /**
         * The scale factor of the object.
         *
         * @member {PIXI.ObservablePoint}
         */
        this.scale = new ObservablePoint_1.ObservablePoint(this.onChange, this, 1, 1);
        /**
         * The pivot point of the displayObject that it rotates around.
         *
         * @member {PIXI.ObservablePoint}
         */
        this.pivot = new ObservablePoint_1.ObservablePoint(this.onChange, this, 0, 0);
        /**
         * The skew amount, on the x and y axis.
         *
         * @member {PIXI.ObservablePoint}
         */
        this.skew = new ObservablePoint_1.ObservablePoint(this.updateSkew, this, 0, 0);
        this._rotation = 0;
        this._cx = 1; // cos rotation + skewY;
        this._sx = 0; // sin rotation + skewY;
        this._cy = 0; // cos rotation + Math.PI/2 - skewX;
        this._sy = 1; // sin rotation + Math.PI/2 - skewX;
        this._localID = 0;
        this._currentLocalID = 0;
        this._worldID = 0;
        this._parentID = 0;
    }
    /**
     * Called when a value changes.
     *
     * @private
     */
    onChange() {
        this._localID++;
    }
    ;
    /**
     * Called when skew or rotation changes
     *
     * @private
     */
    updateSkew() {
        this._cx = Math.cos(this._rotation + this.skew._y);
        this._sx = Math.sin(this._rotation + this.skew._y);
        this._cy = -Math.sin(this._rotation - this.skew._x); // cos, added PI/2
        this._sy = Math.cos(this._rotation - this.skew._x); // sin, added PI/2
        this._localID++;
    }
    ;
    /**
     * Updates only local matrix
     */
    updateLocalTransform() {
        var lt = this.localTransform;
        if (this._localID !== this._currentLocalID) {
            // get the matrix values of the displayobject based on its transform properties..
            lt.a = this._cx * this.scale._x;
            lt.b = this._sx * this.scale._x;
            lt.c = this._cy * this.scale._y;
            lt.d = this._sy * this.scale._y;
            lt.tx = this.position._x - ((this.pivot._x * lt.a) + (this.pivot._y * lt.c));
            lt.ty = this.position._y - ((this.pivot._x * lt.b) + (this.pivot._y * lt.d));
            this._currentLocalID = this._localID;
            // force an update..
            this._parentID = -1;
        }
    }
    ;
    /**
     * Updates the values of the object and applies the parent's transform.
     *
     * @param {PIXI.Transform} parentTransform - The transform of the parent of this object
     */
    updateTransform(parentTransform) {
        var lt = this.localTransform;
        if (this._localID !== this._currentLocalID) {
            // get the matrix values of the displayobject based on its transform properties..
            lt.a = this._cx * this.scale._x;
            lt.b = this._sx * this.scale._x;
            lt.c = this._cy * this.scale._y;
            lt.d = this._sy * this.scale._y;
            lt.tx = this.position._x - ((this.pivot._x * lt.a) + (this.pivot._y * lt.c));
            lt.ty = this.position._y - ((this.pivot._x * lt.b) + (this.pivot._y * lt.d));
            this._currentLocalID = this._localID;
            // force an update..
            this._parentID = -1;
        }
        if (this._parentID !== parentTransform._worldID) {
            // concat the parent matrix with the objects transform.
            var pt = parentTransform.worldTransform;
            var wt = this.worldTransform;
            wt.a = (lt.a * pt.a) + (lt.b * pt.c);
            wt.b = (lt.a * pt.b) + (lt.b * pt.d);
            wt.c = (lt.c * pt.a) + (lt.d * pt.c);
            wt.d = (lt.c * pt.b) + (lt.d * pt.d);
            wt.tx = (lt.tx * pt.a) + (lt.ty * pt.c) + pt.tx;
            wt.ty = (lt.tx * pt.b) + (lt.ty * pt.d) + pt.ty;
            this._parentID = parentTransform._worldID;
            // update the id of the transform..
            this._worldID++;
        }
    }
    ;
    /**
     * Decomposes a matrix and sets the transforms properties based on it.
     *
     * @param {PIXI.Matrix} matrix - The matrix to decompose
     */
    setFromMatrix(matrix) {
        matrix.decompose(this);
        this._localID++;
    }
    ;
    /**
     * The rotation of the object in radians.
     *
     * @member {number}
     */
    get rotation() {
        return this._rotation;
    }
    ;
    set rotation(value) {
        if (this._rotation !== value) {
            this._rotation = value;
            this.updateSkew();
        }
    }
    ;
}
Transform.IDENTITY = new Transform();
exports.Transform = Transform;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/URLLoader.js":
/*!*********************************************!*\
  !*** ./js-compile/raw-pixi-ts/URLLoader.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const IOErrorEvent_1 = __webpack_require__(/*! ./IOErrorEvent */ "./js-compile/raw-pixi-ts/IOErrorEvent.js");
const EventDispatcher_1 = __webpack_require__(/*! ./EventDispatcher */ "./js-compile/raw-pixi-ts/EventDispatcher.js");
const Event_1 = __webpack_require__(/*! ./Event */ "./js-compile/raw-pixi-ts/Event.js");
class URLLoader extends EventDispatcher_1.EventDispatcher {
    constructor() {
        super();
        this.onHttpResponse = () => {
            if (this.xmlhttp.readyState == 4 && this.xmlhttp.status == 200) {
                this._data = this.xmlhttp.responseText;
                this.dispatchEvent(Event_1.Event.getEvent(Event_1.Event.COMPLETE));
            }
            else if (this.xmlhttp.readyState == 4 && this.xmlhttp.status == 0 && this.xmlhttp.responseText) {
                this._data = this.xmlhttp.responseText;
                this.dispatchEvent(Event_1.Event.getEvent(Event_1.Event.COMPLETE));
            }
            else if (this.xmlhttp.readyState == 4 && this.xmlhttp.status == 404) {
                var errorevent = new IOErrorEvent_1.IOErrorEvent(IOErrorEvent_1.IOErrorEvent.IO_ERROR);
                errorevent.text = "Could not find file " + this.request.url;
                errorevent.errorId = 404;
                this.dispatchEvent(errorevent);
            }
            else if (this.xmlhttp.readyState == 4 && this.xmlhttp.status == 403) {
                var errorevent = new IOErrorEvent_1.IOErrorEvent(IOErrorEvent_1.IOErrorEvent.IO_ERROR);
                errorevent.text = "Cross Origin Error " + this.request.url;
                errorevent.errorId = 403;
                this.dispatchEvent(errorevent);
            }
            else if (this.xmlhttp.readyState == 4 && this.xmlhttp.status != 200) {
                var errorevent = new IOErrorEvent_1.IOErrorEvent(IOErrorEvent_1.IOErrorEvent.IO_ERROR);
                errorevent.text = "Unkown Error " + this.request.url;
                errorevent.errorId = this.xmlhttp.status;
                this.dispatchEvent(errorevent);
            }
        };
        this.xmlhttp = new XMLHttpRequest();
    }
    destructor() {
        super.destructor();
        if (this.xmlhttp) {
            this.xmlhttp.onreadystatechange = null;
        }
        this.xmlhttp = null;
        if (this.request) {
            this.request.destructor();
        }
        this.request = null;
        this._data = null;
    }
    get url() {
        if (this.request) {
            return this.request.url;
        }
        return null;
    }
    get data() {
        return this._data;
    }
    set data(value) {
    }
    close() {
    }
    load(value) {
        this.request = value;
        var path = this.request.url;
        if (!path) {
            return;
        }
        if (this.request.data) {
            var params = '';
            for (var key in this.request.data) {
                params += key + "=" + this.request.data[key] + "&";
            }
            params = params.substr(0, params.length - 1);
            path += "?" + params;
        }
        this.xmlhttp.open(this.request.method, path, true);
        this.xmlhttp.onreadystatechange = this.onHttpResponse;
        if (path.indexOf(".json") < 0) {
            if (this.request.contentType != 'json') {
                this.xmlhttp.setRequestHeader('Content-Type', 'text/xml');
            }
        }
        if (this.request.envelop) {
            this.xmlhttp.send(this.request.envelop);
        }
        else {
            this.xmlhttp.send();
        }
    }
    get dataFormat() {
        return null;
    }
    set dataFormat(value) {
    }
}
exports.URLLoader = URLLoader;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/URLRequest.js":
/*!**********************************************!*\
  !*** ./js-compile/raw-pixi-ts/URLRequest.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const URLRequestMethod_1 = __webpack_require__(/*! ./URLRequestMethod */ "./js-compile/raw-pixi-ts/URLRequestMethod.js");
const FlashBaseObject_1 = __webpack_require__(/*! ./FlashBaseObject */ "./js-compile/raw-pixi-ts/FlashBaseObject.js");
class URLRequest extends FlashBaseObject_1.FlashBaseObject {
    constructor(path = null) {
        super();
        this._requestMetaData = new RequestMetaData();
        this._timeout = 0;
        this._crossOrigin = true;
        this.reset(path);
    }
    destructor() {
        this._url = null;
        this._method = URLRequestMethod_1.URLRequestMethod.POST;
        let index = URLRequest.URLRequestCache.indexOf(this);
        if (index < 0) {
            URLRequest.URLRequestCache.push(this);
        }
    }
    reset(path = null) {
        this._url = path;
        this._method = URLRequestMethod_1.URLRequestMethod.POST;
        this._contentType = null;
        this._envelop = null;
        this._data = null;
    }
    static getURLRequest(path = null) {
        if (URLRequest.URLRequestCache.length) {
            let ur = URLRequest.URLRequestCache[URLRequest.URLRequestCache.length - 1];
            URLRequest.URLRequestCache.length -= 1;
            ur.reset(path);
            return ur;
        }
        return new URLRequest(path);
    }
    set requestMetaData(value) {
        this._requestMetaData = value;
    }
    get requestMetaData() {
        return this._requestMetaData;
    }
    set timeout(value) {
        this._timeout = value;
    }
    get timeout() {
        return this._timeout;
    }
    set crossOrigin(value) {
        this._crossOrigin = value;
    }
    get crossOrigin() {
        return this._crossOrigin;
    }
    set envelop(value) {
        this._envelop = value;
    }
    get envelop() {
        return this._envelop;
    }
    get requestHeaders() {
        return null;
    }
    set requestHeaders(value) {
    }
    get contentType() {
        return this._contentType;
    }
    set contentType(value) {
        this._contentType = value;
    }
    get url() {
        return this._url;
    }
    set url(value) {
        this._url = value;
    }
    set data(value) {
        this._data = value;
    }
    get data() {
        return this._data;
    }
    get method() {
        return this._method;
    }
    set method(value) {
        this._method = value;
    }
}
URLRequest.URLRequestCache = [];
exports.URLRequest = URLRequest;
class RequestMetaData {
    constructor() {
        this.mimeType = '';
        this.skipSource = false;
    }
}
exports.RequestMetaData = RequestMetaData;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/URLRequestMethod.js":
/*!****************************************************!*\
  !*** ./js-compile/raw-pixi-ts/URLRequestMethod.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class URLRequestMethod {
}
URLRequestMethod.GET = "GET";
URLRequestMethod.POST = "POST";
exports.URLRequestMethod = URLRequestMethod;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/UniformGroup.js":
/*!************************************************!*\
  !*** ./js-compile/raw-pixi-ts/UniformGroup.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class UniformGroup {
    constructor(uniforms = null, _static = null) {
        /**
                 * uniform values
                 * @member {object}
                 * @readonly
                 */
        this.uniforms = uniforms;
        /**
         * Its a group and not a single uniforms
         * @member {boolean}
         * @readonly
         * @default true
         */
        this.group = true;
        // lets generate this when the shader ?
        this.syncUniforms = {};
        /**
         * dirty version
         * @protected
         * @member {number}
         */
        this.dirtyId = 0;
        /**
         * unique id
         * @protected
         * @member {number}
         */
        this.id = UniformGroup.UID$2++;
        /**
         * Uniforms wont be changed after creation
         * @member {boolean}
         */
        this.static = !!_static;
    }
    update() {
        this.dirtyId++;
    }
    ;
    add(name, uniforms, _static) {
        this.uniforms[name] = new UniformGroup(uniforms, _static);
    }
    ;
    static from(uniforms, _static) {
        return new UniformGroup(uniforms, _static);
    }
    ;
}
UniformGroup.UID$2 = 0;
exports.UniformGroup = UniformGroup;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/Url.js":
/*!***************************************!*\
  !*** ./js-compile/raw-pixi-ts/Url.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const UtilsSettings_1 = __webpack_require__(/*! ./UtilsSettings */ "./js-compile/raw-pixi-ts/UtilsSettings.js");
class Url {
    constructor() {
        this.protocol = null;
        this.slashes = null;
        this.auth = null;
        this.host = null;
        this.port = null;
        this.hostname = null;
        this.hash = null;
        this.search = null;
        this.query = null;
        this.pathname = null;
        this.path = null;
        this.href = null;
    }
    // format a parsed object into a url string
    static urlFormat(obj) {
        // ensure it's an object, and not a string url.
        // If it's an obj, this is a no-op.
        // this way, you can call url_format() on strings
        // to clean up potentially wonky urls.
        if (UtilsSettings_1.UtilsSettings.util.isString(obj)) {
            obj = Url.urlParse(obj);
        }
        if (!(obj instanceof Url)) {
            return Url.prototype.format.call(obj);
        }
        return obj.format();
    }
    static urlResolveObject(source, relative) {
        if (!source) {
            return relative;
        }
        return Url.urlParse(source, false, true).resolveObject(relative);
    }
    static urlResolve(source, relative) {
        return Url.urlParse(source, false, true).resolve(relative);
    }
    resolveObject(relative) {
        if (UtilsSettings_1.UtilsSettings.util.isString(relative)) {
            var rel = new Url();
            rel.parse(relative, false, true);
            relative = rel;
        }
        var result = new Url();
        var tkeys = Object.keys(this);
        for (var tk = 0; tk < tkeys.length; tk++) {
            var tkey = tkeys[tk];
            result[tkey] = this[tkey];
        }
        // hash is always overridden, no matter what.
        // even href="" will remove it.
        result.hash = relative.hash;
        // if the relative url is empty, then there's nothing left to do here.
        if (relative.href === '') {
            result.href = result.format();
            return result;
        }
        // hrefs like //foo/bar always cut to the protocol.
        if (relative.slashes && !relative.protocol) {
            // take everything except the protocol from relative
            var rkeys = Object.keys(relative);
            for (var rk = 0; rk < rkeys.length; rk++) {
                var rkey = rkeys[rk];
                if (rkey !== 'protocol') {
                    result[rkey] = relative[rkey];
                }
            }
            //urlParse appends trailing / to urls like http://www.example.com
            if (Url.slashedProtocol[result.protocol] &&
                result.hostname && !result.pathname) {
                result.path = result.pathname = '/';
            }
            result.href = result.format();
            return result;
        }
        if (relative.protocol && relative.protocol !== result.protocol) {
            // if it's a known url protocol, then changing
            // the protocol does weird things
            // first, if it's not file:, then we MUST have a host,
            // and if there was a path
            // to begin with, then we MUST have a path.
            // if it is file:, then the host is dropped,
            // because that's known to be hostless.
            // anything else is assumed to be absolute.
            if (!Url.slashedProtocol[relative.protocol]) {
                var keys = Object.keys(relative);
                for (var v = 0; v < keys.length; v++) {
                    var k = keys[v];
                    result[k] = relative[k];
                }
                result.href = result.format();
                return result;
            }
            result.protocol = relative.protocol;
            if (!relative.host && !Url.hostlessProtocol[relative.protocol]) {
                var relPath = (relative.pathname || '').split('/');
                while (relPath.length && !(relative.host = relPath.shift())) {
                    ;
                }
                if (!relative.host) {
                    relative.host = '';
                }
                if (!relative.hostname) {
                    relative.hostname = '';
                }
                if (relPath[0] !== '') {
                    relPath.unshift('');
                }
                if (relPath.length < 2) {
                    relPath.unshift('');
                }
                result.pathname = relPath.join('/');
            }
            else {
                result.pathname = relative.pathname;
            }
            result.search = relative.search;
            result.query = relative.query;
            result.host = relative.host || '';
            result.auth = relative.auth;
            result.hostname = relative.hostname || relative.host;
            result.port = relative.port;
            // to support http.request
            if (result.pathname || result.search) {
                var p = result.pathname || '';
                var s = result.search || '';
                result.path = p + s;
            }
            result.slashes = result.slashes || relative.slashes;
            result.href = result.format();
            return result;
        }
        var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'), isRelAbs = (relative.host ||
            relative.pathname && relative.pathname.charAt(0) === '/'), mustEndAbs = (isRelAbs || isSourceAbs ||
            (result.host && relative.pathname)), removeAllDots = mustEndAbs, srcPath = result.pathname && result.pathname.split('/') || [], relPath = relative.pathname && relative.pathname.split('/') || [], psychotic = result.protocol && !Url.slashedProtocol[result.protocol];
        // if the url is a non-slashed url, then relative
        // links like ../.. should be able
        // to crawl up to the hostname, as well.  This is strange.
        // result.protocol has already been set by now.
        // Later on, put the first path part into the host field.
        if (psychotic) {
            result.hostname = '';
            result.port = null;
            if (result.host) {
                if (srcPath[0] === '') {
                    srcPath[0] = result.host;
                }
                else {
                    srcPath.unshift(result.host);
                }
            }
            result.host = '';
            if (relative.protocol) {
                relative.hostname = null;
                relative.port = null;
                if (relative.host) {
                    if (relPath[0] === '') {
                        relPath[0] = relative.host;
                    }
                    else {
                        relPath.unshift(relative.host);
                    }
                }
                relative.host = null;
            }
            mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
        }
        if (isRelAbs) {
            // it's absolute.
            result.host = (relative.host || relative.host === '') ?
                relative.host : result.host;
            result.hostname = (relative.hostname || relative.hostname === '') ?
                relative.hostname : result.hostname;
            result.search = relative.search;
            result.query = relative.query;
            srcPath = relPath;
            // fall through to the dot-handling below.
        }
        else if (relPath.length) {
            // it's relative
            // throw away the existing file, and take the new path instead.
            if (!srcPath) {
                srcPath = [];
            }
            srcPath.pop();
            srcPath = srcPath.concat(relPath);
            result.search = relative.search;
            result.query = relative.query;
        }
        else if (!UtilsSettings_1.UtilsSettings.util.isNullOrUndefined(relative.search)) {
            // just pull out the search.
            // like href='?foo'.
            // Put this after the other two cases because it simplifies the booleans
            if (psychotic) {
                result.hostname = result.host = srcPath.shift();
                //occationaly the auth can get stuck only in host
                //this especially happens in cases like
                //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
                var authInHost = result.host && result.host.indexOf('@') > 0 ?
                    result.host.split('@') : false;
                if (authInHost) {
                    result.auth = authInHost.shift();
                    result.host = result.hostname = authInHost.shift();
                }
            }
            result.search = relative.search;
            result.query = relative.query;
            //to support http.request
            if (!UtilsSettings_1.UtilsSettings.util.isNull(result.pathname) || !UtilsSettings_1.UtilsSettings.util.isNull(result.search)) {
                result.path = (result.pathname ? result.pathname : '') +
                    (result.search ? result.search : '');
            }
            result.href = result.format();
            return result;
        }
        if (!srcPath.length) {
            // no path at all.  easy.
            // we've already handled the other stuff above.
            result.pathname = null;
            //to support http.request
            if (result.search) {
                result.path = '/' + result.search;
            }
            else {
                result.path = null;
            }
            result.href = result.format();
            return result;
        }
        // if a url ENDs in . or .., then it must get a trailing slash.
        // however, if it ends in anything else non-slashy,
        // then it must NOT get a trailing slash.
        var last = srcPath.slice(-1)[0];
        var hasTrailingSlash = ((result.host || relative.host || srcPath.length > 1) &&
            (last === '.' || last === '..') || last === '');
        // strip single dots, resolve double dots to parent dir
        // if the path tries to go above the root, `up` ends up > 0
        var up = 0;
        for (var i = srcPath.length; i >= 0; i--) {
            last = srcPath[i];
            if (last === '.') {
                srcPath.splice(i, 1);
            }
            else if (last === '..') {
                srcPath.splice(i, 1);
                up++;
            }
            else if (up) {
                srcPath.splice(i, 1);
                up--;
            }
        }
        // if the path is allowed to go above the root, restore leading ..s
        if (!mustEndAbs && !removeAllDots) {
            for (; up--; up) {
                srcPath.unshift('..');
            }
        }
        if (mustEndAbs && srcPath[0] !== '' &&
            (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
            srcPath.unshift('');
        }
        if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
            srcPath.push('');
        }
        var isAbsolute = srcPath[0] === '' ||
            (srcPath[0] && srcPath[0].charAt(0) === '/');
        // put the host back
        if (psychotic) {
            result.hostname = result.host = isAbsolute ? '' :
                srcPath.length ? srcPath.shift() : '';
            //occationaly the auth can get stuck only in host
            //this especially happens in cases like
            //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
            var authInHost = result.host && result.host.indexOf('@') > 0 ?
                result.host.split('@') : false;
            if (authInHost) {
                result.auth = authInHost.shift();
                result.host = result.hostname = authInHost.shift();
            }
        }
        mustEndAbs = mustEndAbs || (result.host && srcPath.length);
        if (mustEndAbs && !isAbsolute) {
            srcPath.unshift('');
        }
        if (!srcPath.length) {
            result.pathname = null;
            result.path = null;
        }
        else {
            result.pathname = srcPath.join('/');
        }
        //to support request.http
        if (!UtilsSettings_1.UtilsSettings.util.isNull(result.pathname) || !UtilsSettings_1.UtilsSettings.util.isNull(result.search)) {
            result.path = (result.pathname ? result.pathname : '') +
                (result.search ? result.search : '');
        }
        result.auth = relative.auth || result.auth;
        result.slashes = result.slashes || relative.slashes;
        result.href = result.format();
        return result;
    }
    ;
    static urlParse(url, parseQueryString = null, slashesDenoteHost = null) {
        if (url && UtilsSettings_1.UtilsSettings.util.isObject(url) && url instanceof Url) {
            return url;
        }
        var u = new Url;
        u.parse(url, parseQueryString, slashesDenoteHost);
        return u;
    }
    resolve(relative) {
        return this.resolveObject(Url.urlParse(relative, false, true)).format();
    }
    ;
    parseHost() {
        var host = this.host;
        var port = Url.portPattern.exec(host);
        if (port) {
            port = port[0];
            if (port !== ':') {
                this.port = port.substr(1);
            }
            host = host.substr(0, host.length - port.length);
        }
        if (host) {
            this.hostname = host;
        }
    }
    ;
    parse(url, parseQueryString = null, slashesDenoteHost = null) {
        if (!UtilsSettings_1.UtilsSettings.util.isString(url)) {
            throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
        }
        // Copy chrome, IE, opera backslash-handling behavior.
        // Back slashes before the query string get converted to forward slashes
        // See: https://code.google.com/p/chromium/issues/detail?id=25916
        var queryIndex = url.indexOf('?'), splitter = (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#', uSplit = url.split(splitter), slashRegex = /\\/g;
        uSplit[0] = uSplit[0].replace(slashRegex, '/');
        url = uSplit.join(splitter);
        var rest = url;
        // trim before proceeding.
        // This is to support parse stuff like "  http://foo.com  \n"
        rest = rest.trim();
        if (!slashesDenoteHost && url.split('#').length === 1) {
            // Try fast path regexp
            var simplePath = Url.simplePathPattern.exec(rest);
            if (simplePath) {
                this.path = rest;
                this.href = rest;
                this.pathname = simplePath[1];
                if (simplePath[2]) {
                    this.search = simplePath[2];
                    if (parseQueryString) {
                        this.query = this.parse(this.search.substr(1));
                    }
                    else {
                        this.query = this.search.substr(1);
                    }
                }
                else if (parseQueryString) {
                    this.search = '';
                    this.query = {};
                }
                return this;
            }
        }
        var proto = Url.protocolPattern.exec(rest);
        if (proto) {
            proto = proto[0];
            var lowerProto = proto.toLowerCase();
            this.protocol = lowerProto;
            rest = rest.substr(proto.length);
        }
        // figure out if it's got a host
        // user@server is *always* interpreted as a hostname, and url
        // resolution will treat //foo/bar as host=foo,path=bar because that's
        // how the browser resolves relative URLs.
        if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
            var slashes = rest.substr(0, 2) === '//';
            if (slashes && !(proto && Url.hostlessProtocol[proto])) {
                rest = rest.substr(2);
                this.slashes = true;
            }
        }
        if (!Url.hostlessProtocol[proto] &&
            (slashes || (proto && !Url.slashedProtocol[proto]))) {
            // there's a hostname.
            // the first instance of /, ?, ;, or # ends the host.
            //
            // If there is an @ in the hostname, then non-host chars *are* allowed
            // to the left of the last @ sign, unless some host-ending character
            // comes *before* the @-sign.
            // URLs are obnoxious.
            //
            // ex:
            // http://a@b@c/ => user:a@b host:c
            // http://a@b?@c => user:a host:c path:/?@c
            // v0.12 TODO(isaacs): This is not quite how Chrome does things.
            // Review our test case against browsers more comprehensively.
            // find the first instance of any hostEndingChars
            var hostEnd = -1;
            for (var i = 0; i < Url.hostEndingChars.length; i++) {
                var hec = rest.indexOf(Url.hostEndingChars[i]);
                if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
                    hostEnd = hec;
                }
            }
            // at this point, either we have an explicit point where the
            // auth portion cannot go past, or the last @ char is the decider.
            var auth, atSign;
            if (hostEnd === -1) {
                // atSign can be anywhere.
                atSign = rest.lastIndexOf('@');
            }
            else {
                // atSign must be in auth portion.
                // http://a@b/c@d => host:b auth:a path:/c@d
                atSign = rest.lastIndexOf('@', hostEnd);
            }
            // Now we have a portion which is definitely the auth.
            // Pull that off.
            if (atSign !== -1) {
                auth = rest.slice(0, atSign);
                rest = rest.slice(atSign + 1);
                this.auth = decodeURIComponent(auth);
            }
            // the host is the remaining to the left of the first non-host char
            hostEnd = -1;
            for (var i = 0; i < Url.nonHostChars.length; i++) {
                var hec = rest.indexOf(Url.nonHostChars[i]);
                if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
                    hostEnd = hec;
                }
            }
            // if we still have not hit it, then the entire thing is a host.
            if (hostEnd === -1) {
                hostEnd = rest.length;
            }
            this.host = rest.slice(0, hostEnd);
            rest = rest.slice(hostEnd);
            // pull out port.
            this.parseHost();
            // we've indicated that there is a hostname,
            // so even if it's empty, it has to be present.
            this.hostname = this.hostname || '';
            // if hostname begins with [ and ends with ]
            // assume that it's an IPv6 address.
            var ipv6Hostname = this.hostname[0] === '[' &&
                this.hostname[this.hostname.length - 1] === ']';
            // validate a little.
            if (!ipv6Hostname) {
                var hostparts = this.hostname.split(/\./);
                for (var i = 0, l = hostparts.length; i < l; i++) {
                    var part = hostparts[i];
                    if (!part) {
                        continue;
                    }
                    if (!part.match(Url.hostnamePartPattern)) {
                        var newpart = '';
                        for (var j = 0, k = part.length; j < k; j++) {
                            if (part.charCodeAt(j) > 127) {
                                // we replace non-ASCII char with a temporary placeholder
                                // we need this to make sure size of hostname is not
                                // broken by replacing non-ASCII by nothing
                                newpart += 'x';
                            }
                            else {
                                newpart += part[j];
                            }
                        }
                        // we test again with ASCII char only
                        if (!newpart.match(Url.hostnamePartPattern)) {
                            var validParts = hostparts.slice(0, i);
                            var notHost = hostparts.slice(i + 1);
                            var bit = part.match(Url.hostnamePartStart);
                            if (bit) {
                                validParts.push(bit[1]);
                                notHost.unshift(bit[2]);
                            }
                            if (notHost.length) {
                                rest = '/' + notHost.join('.') + rest;
                            }
                            this.hostname = validParts.join('.');
                            break;
                        }
                    }
                }
            }
            if (this.hostname.length > Url.hostnameMaxLen) {
                this.hostname = '';
            }
            else {
                // hostnames are always lower case.
                this.hostname = this.hostname.toLowerCase();
            }
            if (!ipv6Hostname) {
                // IDNA Support: Returns a punycoded representation of "domain".
                // It only converts parts of the domain name that
                // have non-ASCII characters, i.e. it doesn't matter if
                // you call it with a domain that already is ASCII-only.
                this.hostname = this.toASCII(this.hostname);
            }
            var p = this.port ? ':' + this.port : '';
            var h = this.hostname || '';
            this.host = h + p;
            this.href += this.host;
            // strip [ and ] from the hostname
            // the host field still retains them, though
            if (ipv6Hostname) {
                this.hostname = this.hostname.substr(1, this.hostname.length - 2);
                if (rest[0] !== '/') {
                    rest = '/' + rest;
                }
            }
        }
        // now rest is set to the post-host stuff.
        // chop off any delim chars.
        if (!Url.unsafeProtocol[lowerProto]) {
            // First, make 100% sure that any "autoEscape" chars get
            // escaped, even if encodeURIComponent doesn't think they
            // need to be.
            for (var i = 0, l = Url.autoEscape.length; i < l; i++) {
                var ae = Url.autoEscape[i];
                if (rest.indexOf(ae) === -1) {
                    continue;
                }
                var esc = encodeURIComponent(ae);
                if (esc === ae) {
                    esc = escape(ae);
                }
                rest = rest.split(ae).join(esc);
            }
        }
        // chop off from the tail first.
        var hash = rest.indexOf('#');
        if (hash !== -1) {
            // got a fragment string.
            this.hash = rest.substr(hash);
            rest = rest.slice(0, hash);
        }
        var qm = rest.indexOf('?');
        if (qm !== -1) {
            this.search = rest.substr(qm);
            this.query = rest.substr(qm + 1);
            if (parseQueryString) {
                this.query = this.parse(this.query);
            }
            rest = rest.slice(0, qm);
        }
        else if (parseQueryString) {
            // no query string, but parseQueryString still requested
            this.search = '';
            this.query = {};
        }
        if (rest) {
            this.pathname = rest;
        }
        if (Url.slashedProtocol[lowerProto] &&
            this.hostname && !this.pathname) {
            this.pathname = '/';
        }
        //to support http.request
        if (this.pathname || this.search) {
            var p = this.pathname || '';
            var s = this.search || '';
            this.path = p + s;
        }
        // finally, reconstruct the href based on what has been validated.
        this.href = this.format();
        return this;
    }
    ;
    /**
 * Converts a Unicode string representing a domain name or an email address to
 * Punycode. Only the non-ASCII parts of the domain name will be converted,
 * i.e. it doesn't matter if you call it with a domain that's already in
 * ASCII.
 * @memberOf punycode
 * @param {String} input The domain name or email address to convert, as a
 * Unicode string.
 * @returns {String} The Punycode representation of the given domain name or
 * email address.
 */
    toASCII(input) {
        return this.mapDomain(input, function (string) {
            return Url.regexNonASCII.test(string)
                ? 'xn--' + this.encode(string)
                : string;
        });
    }
    stringifyPrimitive(v) {
        switch (typeof v) {
            case 'string':
                return v;
            case 'boolean':
                return v ? 'true' : 'false';
            case 'number':
                return isFinite(v) ? v : '';
            default:
                return '';
        }
    }
    ;
    encode(obj, sep = null, eq = null, name = null) {
        sep = sep || '&';
        eq = eq || '=';
        if (obj === null) {
            obj = undefined;
        }
        if (typeof obj === 'object') {
            return Object.keys(obj).map(function (k) {
                var ks = encodeURIComponent(this.stringifyPrimitive(k)) + eq;
                if (Array.isArray(obj[k])) {
                    return obj[k].map(function (v) {
                        return ks + encodeURIComponent(this.stringifyPrimitive(v));
                    }).join(sep);
                }
                else {
                    return ks + encodeURIComponent(this.stringifyPrimitive(obj[k]));
                }
            }).join(sep);
        }
        if (!name) {
            return '';
        }
        return encodeURIComponent(this.stringifyPrimitive(name)) + eq +
            encodeURIComponent(this.stringifyPrimitive(obj));
    }
    ;
    /**
     * A simple `Array#map`-like wrapper to work with domain name strings or email
     * addresses.
     * @private
     * @param {String} domain The domain name or email address.
     * @param {Function} callback The function that gets called for every
     * character.
     * @returns {Array} A new string of characters returned by the callback
     * function.
     */
    mapDomain(string, fn) {
        var parts = string.split('@');
        var result = '';
        if (parts.length > 1) {
            // In email addresses, only the domain name should be punycoded. Leave
            // the local part (i.e. everything up to `@`) intact.
            result = parts[0] + '@';
            string = parts[1];
        }
        // Avoid `split(regex)` for IE8 compatibility. See #17.
        string = string.replace(Url.regexSeparators, '\x2E');
        var labels = string.split('.');
        var encoded = this.map(labels, fn).join('.');
        return result + encoded;
    }
    /**
     * A generic `Array#map` utility function.
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} callback The function that gets called for every array
     * item.
     * @returns {Array} A new array of values returned by the callback function.
     */
    map(array, fn) {
        var length = array.length;
        var result = [];
        while (length--) {
            result[length] = fn(array[length]);
        }
        return result;
    }
    format() {
        var auth = this.auth || '';
        if (auth) {
            auth = encodeURIComponent(auth);
            auth = auth.replace(/%3A/i, ':');
            auth += '@';
        }
        var protocol = this.protocol || '', pathname = this.pathname || '', hash = this.hash || '', host = false, query = '';
        if (this.host) {
            host = auth + this.host;
        }
        else if (this.hostname) {
            host = auth + (this.hostname.indexOf(':') === -1 ?
                this.hostname :
                '[' + this.hostname + ']');
            if (this.port) {
                host += ':' + this.port;
            }
        }
        if (this.query &&
            UtilsSettings_1.UtilsSettings.util.isObject(this.query) &&
            Object.keys(this.query).length) {
            query = this.encode(this.query);
        }
        var search = this.search || (query && ('?' + query)) || '';
        if (protocol && protocol.substr(-1) !== ':') {
            protocol += ':';
        }
        // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
        // unless they had them to begin with.
        if (this.slashes ||
            (!protocol || Url.slashedProtocol[protocol]) && host !== false) {
            host = '//' + (host || '');
            if (pathname && pathname.charAt(0) !== '/') {
                pathname = '/' + pathname;
            }
        }
        else if (!host) {
            host = '';
        }
        if (hash && hash.charAt(0) !== '#') {
            hash = '#' + hash;
        }
        if (search && search.charAt(0) !== '?') {
            search = '?' + search;
        }
        pathname = pathname.replace(/[?#]/g, function (match) {
            return encodeURIComponent(match);
        });
        search = search.replace('#', '%23');
        return protocol + host + pathname + search + hash;
    }
    ;
}
Url.regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g;
Url.portPattern = /:[0-9]*$/;
Url.simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/;
Url.protocolPattern = /^([a-z0-9.+-]+:)/i;
Url.regexNonASCII = /[^\x20-\x7E]/;
Url.hostlessProtocol = {
    'javascript': true,
    'javascript:': true
};
Url.slashedProtocol = {
    'http': true,
    'https': true,
    'ftp': true,
    'gopher': true,
    'file': true,
    'http:': true,
    'https:': true,
    'ftp:': true,
    'gopher:': true,
    'file:': true
};
Url.hostEndingChars = ['/', '?', '#'];
Url.delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'];
Url.unwise = ['{', '}', '|', '\\', '^', '`'].concat(Url.delims);
Url.autoEscape = ['\''].concat(Url.unwise);
Url.nonHostChars = ['%', '/', '?', ';', '#'].concat(Url.autoEscape);
Url.hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/;
Url.hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/;
Url.hostnameMaxLen = 255;
Url.unsafeProtocol = {
    'javascript': true,
    'javascript:': true
};
exports.Url = Url;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/UtilsSettings.js":
/*!*************************************************!*\
  !*** ./js-compile/raw-pixi-ts/UtilsSettings.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class UtilsSettings {
    static removeItems(arr, startIdx, removeCount) {
        var length = arr.length;
        var i;
        if (startIdx >= length || removeCount === 0) {
            return;
        }
        removeCount = (startIdx + removeCount > length ? length - startIdx : removeCount);
        var len = length - removeCount;
        for (i = startIdx; i < len; ++i) {
            arr[i] = arr[i + removeCount];
        }
        arr.length = len;
    }
    static deepCopyProperties(target, source, propertyObj) {
        for (var prop in propertyObj) {
            if (Array.isArray(source[prop])) {
                target[prop] = source[prop].slice();
            }
            else {
                target[prop] = source[prop];
            }
        }
    }
    static areArraysEqual(array1, array2) {
        if (!Array.isArray(array1) || !Array.isArray(array2)) {
            return false;
        }
        if (array1.length !== array2.length) {
            return false;
        }
        for (var i = 0; i < array1.length; ++i) {
            if (array1[i] !== array2[i]) {
                return false;
            }
        }
        return true;
    }
    static unsafeEvalSupported() {
        if (typeof UtilsSettings.unsafeEval === 'boolean') {
            return UtilsSettings.unsafeEval;
        }
        try {
            var func = new Function('param1', 'param2', 'param3', 'return param1[param2] === param3;');
            UtilsSettings.unsafeEval = func({ a: 'b' }, 'a', 'b') === true;
        }
        catch (e) {
            UtilsSettings.unsafeEval = false;
        }
        return UtilsSettings.unsafeEval;
    }
    static isWebGLSupported() {
        var contextOptions = { stencil: true, failIfMajorPerformanceCaveat: true };
        try {
            if (!window['WebGLRenderingContext']) {
                return false;
            }
            var canvas = document.createElement('canvas');
            var gl = canvas.getContext('webgl', contextOptions) || canvas.getContext('experimental-webgl', contextOptions);
            var success = !!(gl && gl.getContextAttributes().stencil);
            if (gl) {
                var loseContext = gl.getExtension('WEBGL_lose_context');
                if (loseContext) {
                    loseContext.loseContext();
                }
            }
            gl = null;
            return success;
        }
        catch (e) {
            return false;
        }
    }
}
UtilsSettings.util = {
    isString: function (arg) {
        return typeof (arg) === 'string';
    },
    isObject: function (arg) {
        return typeof (arg) === 'object' && arg !== null;
    },
    isNull: function (arg) {
        return arg === null;
    },
    isNullOrUndefined: function (arg) {
        return arg == null;
    }
};
exports.UtilsSettings = UtilsSettings;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/VideoResource.js":
/*!*************************************************!*\
  !*** ./js-compile/raw-pixi-ts/VideoResource.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseImageResource_1 = __webpack_require__(/*! ./BaseImageResource */ "./js-compile/raw-pixi-ts/BaseImageResource.js");
const Ticker_1 = __webpack_require__(/*! ./Ticker */ "./js-compile/raw-pixi-ts/Ticker.js");
const Logger_1 = __webpack_require__(/*! ./Logger */ "./js-compile/raw-pixi-ts/Logger.js");
class VideoResource extends BaseImageResource_1.BaseImageResource {
    constructor(source, options) {
        options = options || {};
        // throw "stop"
        if (!(source instanceof HTMLVideoElement)) {
            var videoElement = document.createElement('video');
            videoElement.setAttribute('webkit-playsinline', '');
            videoElement.setAttribute('playsinline', '');
            if (typeof source === 'string') {
                source = [source];
            }
            BaseImageResource_1.BaseImageResource.crossOrigin(videoElement, (source[0].src || source[0]), options.crossorigin);
            // array of objects or strings
            for (var i = 0; i < source.length; ++i) {
                var sourceElement = document.createElement('source');
                var ref = source[i];
                var src = ref.src;
                var mime = ref.mime;
                src = src || source[i];
                var baseSrc = src.split('?').shift().toLowerCase();
                var ext = baseSrc.substr(baseSrc.lastIndexOf('.') + 1);
                mime = mime || ("video/" + ext);
                sourceElement.src = src;
                sourceElement.type = mime;
                videoElement.appendChild(sourceElement);
            }
            // Override the source
            source = videoElement;
        }
        super(source);
        this.canUpload = false;
        this._autoUpdate = true;
        this._isAutoUpdating = false;
        this._updateFPS = options.updateFPS || 0;
        this._msToNextUpdate = 0;
        /**
         * When set to true will automatically play videos used by this texture once
         * they are loaded. If false, it will not modify the playing state.
         *
         * @member {boolean}
         * @default true
         */
        this.autoPlay = options.autoPlay !== false;
        /**
         * Promise when loading
         * @member {Promise<void>}
         * @private
         * @default null
         */
        this._load = null;
        /**
         * Callback when completed with load.
         * @member {function}
         * @private
         */
        this._resolve = null;
        // Bind for listeners
        this._onCanPlay = this._onCanPlay.bind(this);
        if (options.autoLoad !== false) {
            this.load();
        }
    }
    /**
     * Trigger updating of the texture
     *
     * @param {number} [deltaTime=0] - time delta since last tick
     */
    update(deltaTime = 0) {
        if (!this.destroyed) {
            // account for if video has had its playbackRate changed
            var elapsedMS = Ticker_1.Ticker.shared.elapsedMS * this.source.playbackRate;
            // trace("elapsed: " + elapsedMS)
            this._msToNextUpdate = Math.floor(this._msToNextUpdate - elapsedMS);
            if (!this._updateFPS || this._msToNextUpdate <= 0) {
                // trace("super update: " + deltaTime)
                super.update(deltaTime);
                this._msToNextUpdate = this._updateFPS ? Math.floor(1000 / this._updateFPS) : 0;
            }
        }
    }
    ;
    /**
     * Start preloading the video resource.
     *
     * @protected
     * @return {Promise<void>} Handle the validate event
     */
    load() {
        Logger_1.trace("loading video");
        var this$1 = this;
        if (this._load) {
            return this._load;
        }
        var source = this.source;
        if ((source.readyState === source.HAVE_ENOUGH_DATA || source.readyState === source.HAVE_FUTURE_DATA)
            && source.width && source.height) {
            source.complete = true;
        }
        source.addEventListener('play', this._onPlayStart.bind(this));
        source.addEventListener('pause', this._onPlayStop.bind(this));
        if (!this._isSourceReady()) {
            source.addEventListener('canplay', this._onCanPlay);
            source.addEventListener('canplaythrough', this._onCanPlay);
        }
        else {
            this._onCanPlay();
        }
        this._load = new Promise(function (resolve) {
            if (this$1.valid) {
                resolve(this$1);
            }
            else {
                this$1._resolve = resolve;
                source.load();
            }
        });
        return this._load;
    }
    ;
    /**
     * Returns true if the underlying source is playing.
     *
     * @private
     * @return {boolean} True if playing.
     */
    _isSourcePlaying() {
        var source = this.source;
        return (source.currentTime > 0 && source.paused === false && source.ended === false && source.readyState > 2);
    }
    ;
    /**
     * Returns true if the underlying source is ready for playing.
     *
     * @private
     * @return {boolean} True if ready.
     */
    _isSourceReady() {
        return this.source.readyState === 3 || this.source.readyState === 4;
    }
    ;
    /**
     * Runs the update loop when the video is ready to play
     *
     * @private
     */
    _onPlayStart() {
        // Just in case the video has not received its can play even yet..
        if (!this.valid) {
            this._onCanPlay();
        }
        if (!this._isAutoUpdating && this.autoUpdate) {
            Ticker_1.Ticker.shared.add(this.update, this);
            this._isAutoUpdating = true;
        }
    }
    ;
    /**
     * Fired when a pause event is triggered, stops the update loop
     *
     * @private
     */
    _onPlayStop() {
        if (this._isAutoUpdating) {
            Ticker_1.Ticker.shared.remove(this.update, this);
            this._isAutoUpdating = false;
        }
    }
    ;
    /**
     * Fired when the video is loaded and ready to play
     *
     * @private
     */
    _onCanPlay() {
        var ref = this;
        var source = ref.source;
        source.removeEventListener('canplay', this._onCanPlay);
        source.removeEventListener('canplaythrough', this._onCanPlay);
        var valid = this.valid;
        this.resize(source.videoWidth, source.videoHeight);
        // prevent multiple loaded dispatches..
        if (!valid && this._resolve) {
            this._resolve(this);
            this._resolve = null;
        }
        if (this._isSourcePlaying()) {
            this._onPlayStart();
        }
        else if (this.autoPlay) {
            source.play();
        }
    }
    ;
    /**
     * Destroys this texture
     * @override
     */
    dispose() {
        if (this._isAutoUpdating) {
            Ticker_1.Ticker.shared.remove(this.update, this);
        }
        if (this.source) {
            this.source.pause();
            this.source.src = '';
            this.source.load();
        }
        BaseImageResource_1.BaseImageResource.prototype.dispose.call(this);
    }
    ;
    /**
     * Should the base texture automatically update itself, set to true by default
     *
     * @member {boolean}
     */
    get autoUpdate() {
        return this._autoUpdate;
    }
    ;
    set autoUpdate(value) {
        if (value !== this._autoUpdate) {
            this._autoUpdate = value;
            if (!this._autoUpdate && this._isAutoUpdating) {
                Ticker_1.Ticker.shared.remove(this.update, this);
                this._isAutoUpdating = false;
            }
            else if (this._autoUpdate && !this._isAutoUpdating) {
                Ticker_1.Ticker.shared.add(this.update, this);
                this._isAutoUpdating = true;
            }
        }
    }
    ;
    /**
     * How many times a second to update the texture from the video. Leave at 0 to update at every render.
     * A lower fps can help performance, as updating the texture at 60fps on a 30ps video may not be efficient.
     *
     * @member {number}
     */
    get updateFPS() {
        return this._updateFPS;
    }
    ;
    set updateFPS(value) {
        if (value !== this._updateFPS) {
            this._updateFPS = value;
        }
    }
    ;
    /**
     * Used to auto-detect the type of resource.
     *
     * @static
     * @param {*} source - The source object
     * @param {string} extension - The extension of source, if set
     * @return {boolean} `true` if video source
     */
    static test(source, extension) {
        return (source instanceof HTMLVideoElement)
            || VideoResource.TYPES.indexOf(extension) > -1;
    }
    ;
}
VideoResource.TYPES = ['mp4', 'm4v', 'webm', 'ogg', 'ogv', 'h264', 'avi', 'mov'];
exports.VideoResource = VideoResource;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/WebGLSettings.js":
/*!*************************************************!*\
  !*** ./js-compile/raw-pixi-ts/WebGLSettings.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Program_1 = __webpack_require__(/*! ./Program */ "./js-compile/raw-pixi-ts/Program.js");
const Matrix_1 = __webpack_require__(/*! ./Matrix */ "./js-compile/raw-pixi-ts/Matrix.js");
const Shader_1 = __webpack_require__(/*! ./Shader */ "./js-compile/raw-pixi-ts/Shader.js");
const CacheSettings_1 = __webpack_require__(/*! ./CacheSettings */ "./js-compile/raw-pixi-ts/CacheSettings.js");
const UniformGroup_1 = __webpack_require__(/*! ./UniformGroup */ "./js-compile/raw-pixi-ts/UniformGroup.js");
const DisplaySettings_1 = __webpack_require__(/*! ./DisplaySettings */ "./js-compile/raw-pixi-ts/DisplaySettings.js");
class WebGLSettings {
    static createIndicesForQuads(size) {
        var totalIndices = size * 6;
        var indices = new Uint16Array(totalIndices);
        for (var i = 0, j = 0; i < totalIndices; i += 6, j += 4) {
            indices[i + 0] = j + 0;
            indices[i + 1] = j + 1;
            indices[i + 2] = j + 2;
            indices[i + 3] = j + 0;
            indices[i + 4] = j + 2;
            indices[i + 5] = j + 3;
        }
        return indices;
    }
    static canUploadSameBuffer() {
        return true;
    }
    static generateMultiTextureShader(gl, maxTextures) {
        if (!CacheSettings_1.CacheSettings.programCache[maxTextures]) {
            var sampleValues = new Int32Array(maxTextures);
            for (var i = 0; i < maxTextures; i++) {
                sampleValues[i] = i;
            }
            CacheSettings_1.CacheSettings.defaultGroupCache[maxTextures] = UniformGroup_1.UniformGroup.from({ uSamplers: sampleValues }, true);
            var fragmentSrc = WebGLSettings.fragTemplate$1;
            fragmentSrc = fragmentSrc.replace(/%count%/gi, maxTextures);
            fragmentSrc = fragmentSrc.replace(/%forloop%/gi, WebGLSettings.generateSampleSrc(maxTextures));
            CacheSettings_1.CacheSettings.programCache[maxTextures] = new Program_1.Program(WebGLSettings.vertex$1, fragmentSrc);
        }
        var uniforms = {
            tint: new Float32Array([1, 1, 1, 1]),
            translationMatrix: new Matrix_1.Matrix(),
            default: CacheSettings_1.CacheSettings.defaultGroupCache[maxTextures],
        };
        var shader = new Shader_1.Shader(CacheSettings_1.CacheSettings.programCache[maxTextures], uniforms);
        return shader;
    }
    static generateSampleSrc(maxTextures) {
        var src = '';
        src += '\n';
        src += '\n';
        for (var i = 0; i < maxTextures; i++) {
            if (i > 0) {
                src += '\nelse ';
            }
            if (i < maxTextures - 1) {
                src += "if(vTextureId < " + i + ".5)";
            }
            src += '\n{';
            src += "\n\tcolor = texture2D(uSamplers[" + i + "], vTextureCoord);";
            src += '\n}';
        }
        src += '\n';
        src += '\n';
        return src;
    }
    static checkMaxIfStatementsInShader(maxIfs, gl) {
        if (maxIfs === 0) {
            throw new Error('Invalid value of `0` passed to `checkMaxIfStatementsInShader`');
        }
        var shader = gl.createShader(gl.FRAGMENT_SHADER);
        while (true) // eslint-disable-line no-constant-condition
         {
            var fragmentSrc = WebGLSettings.fragTemplate.replace(/%forloop%/gi, WebGLSettings.generateIfTestSrc(maxIfs));
            gl.shaderSource(shader, fragmentSrc);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                maxIfs = (maxIfs / 2) | 0;
            }
            else {
                // valid!
                break;
            }
        }
        return maxIfs;
    }
    static generateIfTestSrc(maxIfs) {
        var src = '';
        for (var i = 0; i < maxIfs; ++i) {
            if (i > 0) {
                src += '\nelse ';
            }
            if (i < maxIfs - 1) {
                src += "if(test == " + i + ".0){}";
            }
        }
        return src;
    }
    static maxRecommendedTextures(max) {
        var allowMax = true;
        var match = (navigator.userAgent).match(/OS (\d+)_(\d+)?/);
        if (match) {
            var majorVersion = parseInt(match[1], 10);
            if (majorVersion >= 11) {
                allowMax = true;
            }
        }
        var match$1 = (navigator.userAgent).match(/Android\s([0-9.]*)/);
        if (match$1) {
            var majorVersion$1 = parseInt(match$1[1], 10);
            if (majorVersion$1 >= 7) {
                allowMax = true;
            }
        }
        return allowMax ? max : 4;
    }
    static setPrecision(src, precision) {
        if (src.substring(0, 9) !== 'precision') // && src.substring(0, 1) !== '#')
         {
            return ("precision " + precision + " float;\n" + src);
        }
        return src;
    }
    static getTestContext() {
        if (!WebGLSettings.context) {
            var canvas = document.createElement('canvas');
            var gl;
            if (DisplaySettings_1.DisplaySettings.PREFER_ENV >= DisplaySettings_1.DisplaySettings.ENV.WEBGL2) {
                gl = canvas.getContext('webgl2', {});
            }
            if (!gl) {
                gl = canvas.getContext('webgl', {})
                    || canvas.getContext('experimental-webgl', {});
                if (!gl) {
                    // fail, not able to get a context
                    throw new Error('This browser does not support WebGL. Try using the canvas renderer');
                }
                else {
                    // for shader testing..
                    gl.getExtension('WEBGL_draw_buffers');
                }
            }
            WebGLSettings.context = gl;
            return gl;
        }
        return WebGLSettings.context;
    }
    static defaultValue(type, size) {
        switch (type) {
            case 'float':
                return 0;
            case 'vec2':
                return new Float32Array(2 * size);
            case 'vec3':
                return new Float32Array(3 * size);
            case 'vec4':
                return new Float32Array(4 * size);
            case 'int':
            case 'sampler2D':
            case 'sampler2DArray':
                return 0;
            case 'ivec2':
                return new Int32Array(2 * size);
            case 'ivec3':
                return new Int32Array(3 * size);
            case 'ivec4':
                return new Int32Array(4 * size);
            case 'bool':
                return false;
            case 'bvec2':
                return WebGLSettings.booleanArray(2 * size);
            case 'bvec3':
                return WebGLSettings.booleanArray(3 * size);
            case 'bvec4':
                return WebGLSettings.booleanArray(4 * size);
            case 'mat2':
                return new Float32Array([1, 0,
                    0, 1]);
            case 'mat3':
                return new Float32Array([1, 0, 0,
                    0, 1, 0,
                    0, 0, 1]);
            case 'mat4':
                return new Float32Array([1, 0, 0, 0,
                    0, 1, 0, 0,
                    0, 0, 1, 0,
                    0, 0, 0, 1]);
        }
        return null;
    }
    static booleanArray(size) {
        var array = new Array(size);
        for (var i = 0; i < array.length; i++) {
            array[i] = false;
        }
        return array;
    }
    static mapType(gl, type) {
        if (!WebGLSettings.GL_TABLE) {
            var typeNames = Object.keys(WebGLSettings.GL_TO_GLSL_TYPES);
            WebGLSettings.GL_TABLE = {};
            for (var i = 0; i < typeNames.length; ++i) {
                var tn = typeNames[i];
                WebGLSettings.GL_TABLE[gl[tn]] = WebGLSettings.GL_TO_GLSL_TYPES[tn];
            }
        }
        return WebGLSettings.GL_TABLE[type];
    }
    static mapSize(type) {
        return WebGLSettings.GLSL_TO_SIZE[type];
    }
    static generateUniformsSync(group, uniformData) {
        var textureCount = 0;
        var func = "var v = null;\n    var cv = null\n    var gl = renderer.gl";
        for (var i in group.uniforms) {
            var data = uniformData[i];
            if (!data) {
                if (group.uniforms[i].group) {
                    func += "\n                    renderer.shader.syncUniformGroup(uv." + i + ");\n                ";
                }
                continue;
            }
            // TODO && uniformData[i].value !== 0 <-- do we still need this?
            if (data.type === 'float' && data.size === 1) {
                func += "\n            if(uv." + i + " !== ud." + i + ".value)\n            {\n                ud." + i + ".value = uv." + i + "\n                gl.uniform1f(ud." + i + ".location, uv." + i + ")\n            }\n";
            }
            /* eslint-disable max-len */
            else if ((data.type === 'sampler2D' || data.type === 'samplerCube' || data.type === 'sampler2DArray') && data.size === 1 && !data.isArray) 
            /* eslint-disable max-len */
            {
                func += "\n            renderer.texture.bind(uv." + i + ", " + textureCount + ");\n\n            if(ud." + i + ".value !== " + textureCount + ")\n            {\n                ud." + i + ".value = " + textureCount + ";\n                gl.uniform1i(ud." + i + ".location, " + textureCount + ");\n; // eslint-disable-line max-len\n            }\n";
                textureCount++;
            }
            else if (data.type === 'mat3' && data.size === 1) {
                if (group.uniforms[i].a !== undefined) {
                    // TODO and some smart caching dirty ids here!
                    func += "\n                gl.uniformMatrix3fv(ud." + i + ".location, false, uv." + i + ".toArray(true));\n                \n";
                }
                else {
                    func += "\n                gl.uniformMatrix3fv(ud." + i + ".location, false, uv." + i + ");\n                \n";
                }
            }
            else if (data.type === 'vec2' && data.size === 1) {
                // TODO - do we need both here?
                // maybe we can get away with only using points?
                if (group.uniforms[i].x !== undefined) {
                    func += "\n                cv = ud." + i + ".value;\n                v = uv." + i + ";\n\n                if(cv[0] !== v.x || cv[1] !== v.y)\n                {\n                    cv[0] = v.x;\n                    cv[1] = v.y;\n                    gl.uniform2f(ud." + i + ".location, v.x, v.y);\n                }\n";
                }
                else {
                    func += "\n                cv = ud." + i + ".value;\n                v = uv." + i + ";\n\n                if(cv[0] !== v[0] || cv[1] !== v[1])\n                {\n                    cv[0] = v[0];\n                    cv[1] = v[1];\n                    gl.uniform2f(ud." + i + ".location, v[0], v[1]);\n                }\n                \n";
                }
            }
            else if (data.type === 'vec4' && data.size === 1) {
                // TODO - do we need both here?
                // maybe we can get away with only using points?
                if (group.uniforms[i].width !== undefined) {
                    func += "\n                cv = ud." + i + ".value;\n                v = uv." + i + ";\n\n                if(cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height)\n                {\n                    cv[0] = v.x;\n                    cv[1] = v.y;\n                    cv[2] = v.width;\n                    cv[3] = v.height;\n                    gl.uniform4f(ud." + i + ".location, v.x, v.y, v.width, v.height)\n                }\n";
                }
                else {
                    func += "\n                cv = ud." + i + ".value;\n                v = uv." + i + ";\n\n                if(cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n                {\n                    cv[0] = v[0];\n                    cv[1] = v[1];\n                    cv[2] = v[2];\n                    cv[3] = v[3];\n\n                    gl.uniform4f(ud." + i + ".location, v[0], v[1], v[2], v[3])\n                }\n                \n";
                }
            }
            else {
                var templateType = (data.size === 1) ? WebGLSettings.GLSL_TO_SINGLE_SETTERS_CACHED : WebGLSettings.GLSL_TO_ARRAY_SETTERS;
                var template = templateType[data.type].replace('location', ("ud." + i + ".location"));
                func += "\n            cv = ud." + i + ".value;\n            v = uv." + i + ";\n            " + template + ";\n";
            }
        }
        return new Function('ud', 'uv', 'renderer', func); // eslint-disable-line no-new-func
    }
}
WebGLSettings.UPLOADS_PER_FRAME = 4;
WebGLSettings.GLSL_TO_ARRAY_SETTERS = {
    float: "gl.uniform1fv(location, v)",
    vec2: "gl.uniform2fv(location, v)",
    vec3: "gl.uniform3fv(location, v)",
    vec4: 'gl.uniform4fv(location, v)',
    mat4: 'gl.uniformMatrix4fv(location, false, v)',
    mat3: 'gl.uniformMatrix3fv(location, false, v)',
    mat2: 'gl.uniformMatrix2fv(location, false, v)',
    int: 'gl.uniform1iv(location, v)',
    ivec2: 'gl.uniform2iv(location, v)',
    ivec3: 'gl.uniform3iv(location, v)',
    ivec4: 'gl.uniform4iv(location, v)',
    bool: 'gl.uniform1iv(location, v)',
    bvec2: 'gl.uniform2iv(location, v)',
    bvec3: 'gl.uniform3iv(location, v)',
    bvec4: 'gl.uniform4iv(location, v)',
    sampler2D: 'gl.uniform1iv(location, v)',
    samplerCube: 'gl.uniform1iv(location, v)',
    sampler2DArray: 'gl.uniform1iv(location, v)',
};
WebGLSettings.GLSL_TO_SINGLE_SETTERS_CACHED = {
    float: "\n    if(cv !== v)\n    {\n        cv.v = v;\n        gl.uniform1f(location, v)\n    }",
    vec2: "\n    if(cv[0] !== v[0] || cv[1] !== v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        gl.uniform2f(location, v[0], v[1])\n    }",
    vec3: "\n    if(cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3f(location, v[0], v[1], v[2])\n    }",
    vec4: 'gl.uniform4f(location, v[0], v[1], v[2], v[3])',
    int: 'gl.uniform1i(location, v)',
    ivec2: 'gl.uniform2i(location, v[0], v[1])',
    ivec3: 'gl.uniform3i(location, v[0], v[1], v[2])',
    ivec4: 'gl.uniform4i(location, v[0], v[1], v[2], v[3])',
    bool: 'gl.uniform1i(location, v)',
    bvec2: 'gl.uniform2i(location, v[0], v[1])',
    bvec3: 'gl.uniform3i(location, v[0], v[1], v[2])',
    bvec4: 'gl.uniform4i(location, v[0], v[1], v[2], v[3])',
    mat2: 'gl.uniformMatrix2fv(location, false, v)',
    mat3: 'gl.uniformMatrix3fv(location, false, v)',
    mat4: 'gl.uniformMatrix4fv(location, false, v)',
    sampler2D: 'gl.uniform1i(location, v)',
    samplerCube: 'gl.uniform1i(location, v)',
    sampler2DArray: 'gl.uniform1i(location, v)',
};
WebGLSettings.GLSL_TO_SIZE = {
    float: 1,
    vec2: 2,
    vec3: 3,
    vec4: 4,
    int: 1,
    ivec2: 2,
    ivec3: 3,
    ivec4: 4,
    bool: 1,
    bvec2: 2,
    bvec3: 3,
    bvec4: 4,
    mat2: 4,
    mat3: 9,
    mat4: 16,
    sampler2D: 1,
};
WebGLSettings.GL_TO_GLSL_TYPES = {
    FLOAT: 'float',
    FLOAT_VEC2: 'vec2',
    FLOAT_VEC3: 'vec3',
    FLOAT_VEC4: 'vec4',
    INT: 'int',
    INT_VEC2: 'ivec2',
    INT_VEC3: 'ivec3',
    INT_VEC4: 'ivec4',
    BOOL: 'bool',
    BOOL_VEC2: 'bvec2',
    BOOL_VEC3: 'bvec3',
    BOOL_VEC4: 'bvec4',
    FLOAT_MAT2: 'mat2',
    FLOAT_MAT3: 'mat3',
    FLOAT_MAT4: 'mat4',
    SAMPLER_2D: 'sampler2D',
    SAMPLER_CUBE: 'samplerCube',
    SAMPLER_2D_ARRAY: 'sampler2DArray',
};
WebGLSettings.GL_TABLE = null;
WebGLSettings.context = null;
WebGLSettings.PRECISION_FRAGMENT = 'highp';
WebGLSettings.PRECISION_VERTEX = 'highp';
WebGLSettings.fragTemplate = [
    'precision mediump float;',
    'void main(void){',
    'float test = 0.1;',
    '%forloop%',
    'gl_FragColor = vec4(0.0);',
    '}'
].join('\n');
WebGLSettings.vertex$1 = "precision highp float;\r\nattribute vec2 aVertexPosition;\r\nattribute vec2 aTextureCoord;\r\nattribute vec4 aColor;\r\nattribute float aTextureId;\r\n\r\nuniform mat3 projectionMatrix;\r\nuniform mat3 translationMatrix;\r\nuniform vec4 tint;\r\n\r\nvarying vec2 vTextureCoord;\r\nvarying vec4 vColor;\r\nvarying float vTextureId;\r\n\r\nvoid main(void){\r\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\r\n\r\n    vTextureCoord = aTextureCoord;\r\n    vTextureId = aTextureId;\r\n    vColor = aColor * tint;\r\n}\r\n";
WebGLSettings.fragTemplate$1 = [
    'varying vec2 vTextureCoord;',
    'varying vec4 vColor;',
    'varying float vTextureId;',
    'uniform sampler2D uSamplers[%count%];',
    'void main(void){',
    'vec4 color;',
    '%forloop%',
    'gl_FragColor = color * vColor;',
    '}'
].join('\n');
WebGLSettings.MIPMAP_TEXTURES = 1;
WebGLSettings.WRAP_MODE = 33071;
WebGLSettings.TARGETS = {
    TEXTURE_2D: 3553,
    TEXTURE_CUBE_MAP: 34067,
    TEXTURE_2D_ARRAY: 35866,
    TEXTURE_CUBE_MAP_POSITIVE_X: 34069,
    TEXTURE_CUBE_MAP_NEGATIVE_X: 34070,
    TEXTURE_CUBE_MAP_POSITIVE_Y: 34071,
    TEXTURE_CUBE_MAP_NEGATIVE_Y: 34072,
    TEXTURE_CUBE_MAP_POSITIVE_Z: 34073,
    TEXTURE_CUBE_MAP_NEGATIVE_Z: 34074,
};
WebGLSettings.FORMATS = {
    RGBA: 6408,
    RGB: 6407,
    ALPHA: 6406,
    LUMINANCE: 6409,
    LUMINANCE_ALPHA: 6410,
    DEPTH_COMPONENT: 6402,
    DEPTH_STENCIL: 34041,
};
WebGLSettings.TYPES = {
    UNSIGNED_BYTE: 5121,
    UNSIGNED_SHORT: 5123,
    UNSIGNED_SHORT_5_6_5: 33635,
    UNSIGNED_SHORT_4_4_4_4: 32819,
    UNSIGNED_SHORT_5_5_5_1: 32820,
    FLOAT: 5126,
    HALF_FLOAT: 36193,
};
WebGLSettings.MIPMAP_MODES = {
    OFF: 0,
    POW2: 1,
    ON: 2,
};
WebGLSettings.SCALE_MODES = {
    LINEAR: 1,
    NEAREST: 0,
};
WebGLSettings.WRAP_MODES = {
    CLAMP: 33071,
    REPEAT: 10497,
    MIRRORED_REPEAT: 33648,
};
WebGLSettings.defaultBufferOptions = {
    scaleMode: WebGLSettings.SCALE_MODES.NEAREST,
    format: WebGLSettings.FORMATS.RGBA,
    premultiplyAlpha: false,
};
WebGLSettings.CAN_UPLOAD_SAME_BUFFER = WebGLSettings.canUploadSameBuffer();
WebGLSettings.SPRITE_MAX_TEXTURES = WebGLSettings.maxRecommendedTextures(32);
exports.WebGLSettings = WebGLSettings;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/settings.js":
/*!********************************************!*\
  !*** ./js-compile/raw-pixi-ts/settings.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class settings {
    /**
     * Converts a digit/integer into a basic code point.
     * @see `basicToDigit()`
     * @private
     * @param {Number} digit The numeric value of a basic code point.
     * @returns {Number} The basic code point whose value (when used for
     * representing integers) is `digit`, which needs to be in the range
     * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
     * used; else, the lowercase form is used. The behavior is undefined
     * if `flag` is non-zero and `digit` has no uppercase form.
     */
    static digitToBasic(digit, flag) {
        //  0..25 map to ASCII a..z or A..Z
        // 26..35 map to ASCII 0..9
        return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
    }
    /**
     * A generic error utility function.
     * @private
     * @param {String} type The error type.
     * @returns {Error} Throws a `RangeError` with the applicable error message.
     */
    static error(type) {
        throw RangeError(settings.errors[type]);
    }
    /**
 * Converts a string of Unicode symbols (e.g. a domain name label) to a
 * Punycode string of ASCII-only symbols.
 * @memberOf punycode
 * @param {String} input The string of Unicode symbols.
 * @returns {String} The resulting Punycode string of ASCII-only symbols.
 */
    static encode(input) {
        var n, delta, handledCPCount, basicLength, bias, j, m, q, k, t, currentValue, output = [], 
        /** `inputLength` will hold the number of code points in `input`. */
        inputLength, 
        /** Cached calculation results */
        handledCPCountPlusOne, baseMinusT, qMinusT;
        // Convert the input in UCS-2 to Unicode
        input = settings.ucs2decode(input);
        // Cache the length
        inputLength = input.length;
        // Initialize the state
        n = settings.initialN;
        delta = 0;
        bias = settings.initialBias;
        // Handle the basic code points
        for (j = 0; j < inputLength; ++j) {
            currentValue = input[j];
            if (currentValue < 0x80) {
                output.push(settings.stringFromCharCode(currentValue));
            }
        }
        handledCPCount = basicLength = output.length;
        // `handledCPCount` is the number of code points that have been handled;
        // `basicLength` is the number of basic code points.
        // Finish the basic string - if it is not empty - with a delimiter
        if (basicLength) {
            output.push(settings.delimiter);
        }
        // Main encoding loop:
        while (handledCPCount < inputLength) {
            // All non-basic code points < n have been handled already. Find the next
            // larger one:
            for (m = settings.maxInt, j = 0; j < inputLength; ++j) {
                currentValue = input[j];
                if (currentValue >= n && currentValue < m) {
                    m = currentValue;
                }
            }
            // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
            // but guard against overflow
            handledCPCountPlusOne = handledCPCount + 1;
            if (m - n > settings.floor((settings.maxInt - delta) / handledCPCountPlusOne)) {
                settings.error('overflow');
            }
            delta += (m - n) * handledCPCountPlusOne;
            n = m;
            for (j = 0; j < inputLength; ++j) {
                currentValue = input[j];
                if (currentValue < n && ++delta > settings.maxInt) {
                    settings.error('overflow');
                }
                if (currentValue == n) {
                    // Represent delta as a generalized variable-length integer
                    for (q = delta, k = settings.base; /* no condition */; k += settings.base) {
                        t = k <= bias ? settings.tMin : (k >= bias + settings.tMax ? settings.tMax : k - bias);
                        if (q < t) {
                            break;
                        }
                        qMinusT = q - t;
                        baseMinusT = settings.base - t;
                        output.push(settings.stringFromCharCode(settings.digitToBasic(t + qMinusT % baseMinusT, 0)));
                        q = settings.floor(qMinusT / baseMinusT);
                    }
                    output.push(settings.stringFromCharCode(settings.digitToBasic(q, 0)));
                    bias = settings.adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
                    delta = 0;
                    ++handledCPCount;
                }
            }
            ++delta;
            ++n;
        }
        return output.join('');
    }
    /**
* Bias adaptation function as per section 3.4 of RFC 3492.
* http://tools.ietf.org/html/rfc3492#section-3.4
* @private
*/
    static adapt(delta, numPoints, firstTime) {
        var k = 0;
        delta = firstTime ? settings.floor(delta / settings.damp) : delta >> 1;
        delta += settings.floor(delta / numPoints);
        for ( /* no initialization */; delta > settings.baseMinusTMin * settings.tMax >> 1; k += settings.base) {
            delta = settings.floor(delta / settings.baseMinusTMin);
        }
        return settings.floor(k + (settings.baseMinusTMin + 1) * delta / (delta + settings.skew));
    }
    /**
* Creates an array containing the numeric code points of each Unicode
* character in the string. While JavaScript uses UCS-2 internally,
* this function will convert a pair of surrogate halves (each of which
* UCS-2 exposes as separate characters) into a single code point,
* matching UTF-16.
* @see `punycode.ucs2.encode`
* @see <https://mathiasbynens.be/notes/javascript-encoding>
* @memberOf punycode.ucs2
* @name decode
* @param {String} string The Unicode input string (UCS-2).
* @returns {Array} The new array of code points.
*/
    static ucs2decode(string) {
        var output = [], counter = 0, length = string.length, value, extra;
        while (counter < length) {
            value = string.charCodeAt(counter++);
            if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
                // high surrogate, and there is a next character
                extra = string.charCodeAt(counter++);
                if ((extra & 0xFC00) == 0xDC00) { // low surrogate
                    output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
                }
                else {
                    // unmatched surrogate; only append this code unit, in case the next
                    // code unit is the high surrogate of a surrogate pair
                    output.push(value);
                    counter--;
                }
            }
            else {
                output.push(value);
            }
        }
        return output;
    }
    /**
 * Typedef for decomposeDataUri return object.
 *
 * @memberof PIXI.utils
 * @typedef {object} DecomposedDataUri
 * @property {string} mediaType Media type, eg. `image`
 * @property {string} subType Sub type, eg. `png`
 * @property {string} encoding Data encoding, eg. `base64`
 * @property {string} data The actual data
 */
    /**
     * Split a data URI into components. Returns undefined if
     * parameter `dataUri` is not a valid data URI.
     *
     * @memberof PIXI.utils
     * @function decomposeDataUri
     * @param {string} dataUri - the data URI to check
     * @return {PIXI.utils.DecomposedDataUri|undefined} The decomposed data uri or undefined
     */
    static decomposeDataUri(dataUri) {
        var dataUriMatch = settings.DATA_URI.exec(dataUri);
        if (dataUriMatch) {
            return {
                mediaType: dataUriMatch[1] ? dataUriMatch[1].toLowerCase() : undefined,
                subType: dataUriMatch[2] ? dataUriMatch[2].toLowerCase() : undefined,
                charset: dataUriMatch[3] ? dataUriMatch[3].toLowerCase() : undefined,
                encoding: dataUriMatch[4] ? dataUriMatch[4].toLowerCase() : undefined,
                data: dataUriMatch[5],
            };
        }
        return undefined;
    }
}
/**
 * Target frames per millisecond.
 *
 * @static
 * @name TARGET_FPMS
 * @memberof PIXI.settings
 * @type {number}
 * @default 0.06
 */
settings.TARGET_FPMS = 0.06;
/**
 * Default filter resolution.
 *
 * @static
 * @name FILTER_RESOLUTION
 * @memberof PIXI.settings
 * @type {number}
 * @default 1
 */
settings.FILTER_RESOLUTION = 1;
// TODO: maybe change to SPRITE.BATCH_SIZE: 2000
// TODO: maybe add PARTICLE.BATCH_SIZE: 15000
/**
 * The default sprite batch size.
 *
 * The default aims to balance desktop and mobile devices.
 *
 * @static
 * @name SPRITE_BATCH_SIZE
 * @memberof PIXI.settings
 * @type {number}
 * @default 4096
 */
settings.SPRITE_BATCH_SIZE = 4096;
/**
 * Default Garbage Collection mode.
 *
 * @static
 * @name GC_MODE
 * @memberof PIXI.settings
 * @type {PIXI.GC_MODES}
 * @default PIXI.GC_MODES.AUTO
 */
settings.GC_MODE = 0;
/**
 * Default Garbage Collection max idle.
 *
 * @static
 * @name GC_MAX_IDLE
 * @memberof PIXI.settings
 * @type {number}
 * @default 3600
 */
settings.GC_MAX_IDLE = 60 * 60;
/**
 * Default Garbage Collection maximum check count.
 *
 * @static
 * @name GC_MAX_CHECK_COUNT
 * @memberof PIXI.settings
 * @type {number}
 * @default 600
 */
settings.GC_MAX_CHECK_COUNT = 60 * 10;
/**
* The gc modes that are supported by pixi.
*
* The {@link PIXI.settings.GC_MODE} Garbage Collection mode for PixiJS textures is AUTO
* If set to GC_MODE, the renderer will occasionally check textures usage. If they are not
* used for a specified period of time they will be removed from the GPU. They will of course
* be uploaded again when they are required. This is a silent behind the scenes process that
* should ensure that the GPU does not  get filled up.
*
* Handy for mobile devices!
* This property only affects WebGL.
*
* @name GC_MODES
* @enum {number}
* @static
* @memberof PIXI
* @property {number} AUTO - Garbage collection will happen periodically automatically
* @property {number} MANUAL - Garbage collection will need to be called manually
*/
settings.GC_MODES = {
    AUTO: 0,
    MANUAL: 1,
};
/**
 * Constants that specify float precision in shaders.
 *
 * @name PRECISION
 * @memberof PIXI
 * @static
 * @enum {string}
 * @constant
 * @property {string} LOW='lowp'
 * @property {string} MEDIUM='mediump'
 * @property {string} HIGH='highp'
 */
settings.PRECISION = {
    LOW: 'lowp',
    MEDIUM: 'mediump',
    HIGH: 'highp',
};
/**
* Graphics curves resolution settings. If `adaptive` flag is set to `true`,
* the resolution is calculated based on the curve's length to ensure better visual quality.
* Adaptive draw works with `bezierCurveTo` and `quadraticCurveTo`.
*
* @static
* @constant
* @memberof PIXI
* @name GRAPHICS_CURVES
* @type {object}
* @property {boolean} adaptive=false - flag indicating if the resolution should be adaptive
* @property {number} maxLength=10 - maximal length of a single segment of the curve (if adaptive = false, ignored)
* @property {number} minSegments=8 - minimal number of segments in the curve (if adaptive = false, ignored)
* @property {number} maxSegments=2048 - maximal number of segments in the curve (if adaptive = false, ignored)
*/
settings.GRAPHICS_CURVES = {
    adaptive: true,
    maxLength: 10,
    minSegments: 8,
    maxSegments: 2048,
    _segmentsCount: function _segmentsCount(length, defaultSegments = null) {
        if (defaultSegments === void 0) {
            defaultSegments = 20;
        }
        if (!this.adaptive) {
            return defaultSegments;
        }
        var result = Math.ceil(length / this.maxLength);
        if (result < this.minSegments) {
            result = this.minSegments;
        }
        else if (result > this.maxSegments) {
            result = this.maxSegments;
        }
        return result;
    },
};
settings.initialN = 128;
settings.initialBias = 72;
settings.stringFromCharCode = String.fromCharCode;
settings.delimiter = '-';
settings.maxInt = 2147483647;
settings.floor = Math.floor;
settings.base = 36;
settings.tMin = 1;
settings.tMax = 26;
/** Error messages */
settings.errors = {
    'overflow': 'Overflow: input needs wider integers to process',
    'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
    'invalid-input': 'Invalid input'
};
settings.damp = 700;
settings.baseMinusTMin = settings.base - settings.tMin;
settings.skew = 38;
/**
* Regexp for data URI.
* Based on: {@link https://github.com/ragingwind/data-uri-regex}
*
* @static
* @constant {RegExp|string} DATA_URI
* @memberof PIXI
* @example data:image/png;base64
*/
settings.DATA_URI = /^\s*data:(?:([\w-]+)\/([\w+.-]+))?(?:;charset=([\w-]+))?(?:;(base64))?,(.*)/i;
// Taken from the bit-twiddle package
settings.defaultVertex = "attribute vec2 aVertexPosition;\r\nattribute vec2 aTextureCoord;\r\n\r\nuniform mat3 projectionMatrix;\r\n\r\nvarying vec2 vTextureCoord;\r\n\r\nvoid main(void)\r\n{\r\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\r\n    vTextureCoord = aTextureCoord;\r\n}";
settings.defaultFilterVertex = "attribute vec2 aVertexPosition;\r\n\r\nuniform mat3 projectionMatrix;\r\n\r\nvarying vec2 vTextureCoord;\r\n\r\nuniform vec4 inputSize;\r\nuniform vec4 outputFrame;\r\n\r\nvec4 filterVertexPosition( void )\r\n{\r\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\r\n\r\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\r\n}\r\n\r\nvec2 filterTextureCoord( void )\r\n{\r\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\r\n}\r\n\r\nvoid main(void)\r\n{\r\n    gl_Position = filterVertexPosition();\r\n    vTextureCoord = filterTextureCoord();\r\n}\r\n";
exports.settings = settings;


/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9leGFtcGxlcy9CYXNlRXhhbXBsZS5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL2V4YW1wbGVzL0ZpbHRlckJsZW5kaW5nLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvZXhhbXBsZXMvRmlsdGVyQmx1ci5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL2V4YW1wbGVzL0ZpbHRlckNvbG9yLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvZXhhbXBsZXMvRmlsdGVyQ3Jhd2xpZXMuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9leGFtcGxlcy9GaWx0ZXJDdXN0b20uanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9leGFtcGxlcy9GaWx0ZXJGbGFnLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvZXhhbXBsZXMvRmlsdGVyU2hhZG93LmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvZXhhbXBsZXMvTWFza0ZpbHRlci5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL2V4YW1wbGVzL01lc2hBZHZhbmNlZC5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL2V4YW1wbGVzL01lc2hCYXNpYy5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL2V4YW1wbGVzL01lc2hDb2xvcmVkVHJpYW5nbGUuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9leGFtcGxlcy9NZXNoR2VvbWV0cnkuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9leGFtcGxlcy9NZXNoU2hhZGVyLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvZXhhbXBsZXMvTWVzaFRleHR1cmVkLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvZXhhbXBsZXMvTWVzaFRyaWFuZ2xlLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvZXhhbXBsZXMvTWVzaFVuaWZvcm1zLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvZXhhbXBsZXMvU3ByaXRlQmFzaWMuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9leGFtcGxlcy9UZXh0dXJlR3JhZGllbnRSZXNvdXJjZS5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL2V4YW1wbGVzL1RleHR1cmVSZW5kZXIuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9leGFtcGxlcy9UZXh0dXJlUm90YXRlLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvZXhhbXBsZXMvY29udHJvbHMvRXhhbXBsZURpc3BsYXkuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9leGFtcGxlcy9jb250cm9scy9FeGFtcGxlTGlzdC5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL2ZsLXBhY2thZ2UvQnV0dG9uLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9BYnN0cmFjdFJlbmRlcmVyLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvQWNjZXNzaWJpbGl0eU1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9BbmltYXRlZFNwcml0ZS5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL0FwcGxpY2F0aW9uLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvQXJjVXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9BcnJheVJlc291cmNlLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvQXR0cmlidXRlLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvQmFzZUltYWdlUmVzb3VyY2UuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9CYXNlUHJlcGFyZS5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL0Jhc2VSZW5kZXJUZXh0dXJlLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvQmFzZVRleHR1cmUuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9CYXRjaEJ1ZmZlci5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL0JhdGNoRHJhd0NhbGwuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9CYXRjaEdlb21ldHJ5LmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvQmF0Y2hSZW5kZXJlci5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL0JhdGNoU3lzdGVtLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvQmV6aWVyVXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9CbGVuZE1vZGVzU2V0dGluZ3MuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9CbHVyRmlsdGVyLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvQmx1ckZpbHRlclBhc3MuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9Cb3VuZHMuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9CdWZmZXIuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9CdWZmZXJSZXNvdXJjZS5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL0NhY2hlU2V0dGluZ3MuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9DYW52YXNSZW5kZXJUYXJnZXQuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9DYW52YXNSZXNvdXJjZS5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL0NhbnZhc1NldHRpbmdzLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvQ2lyY2xlLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvQ2xlYW5VcFNldHRpbmdzLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvQ29sb3JNYXRyaXhGaWx0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9Db2xvclNldHRpbmdzLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvQ29udGFpbmVyLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvQ29udGV4dFN5c3RlbS5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL0NvdW50TGltaXRlci5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL0N1YmVSZXNvdXJjZS5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL0RlcHRoUmVzb3VyY2UuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9EaXNwbGFjZW1lbnRGaWx0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9EaXNwbGF5T2JqZWN0LmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvRGlzcGxheVNldHRpbmdzLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvRHJhd01vZGVTZXR0aW5ncy5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL0VsbGlwc2UuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9FdmVudC5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL0V2ZW50RGlzcGF0Y2hlci5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL0V4dHJhY3QuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9GaWxsU3R5bGUuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9GaWx0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9GaWx0ZXJTdGF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL0ZpbHRlclN5c3RlbS5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL0ZsYXNoQmFzZU9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL0ZyYW1lYnVmZmVyLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvRnJhbWVidWZmZXJTeXN0ZW0uanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9HTEJ1ZmZlci5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL0dMUHJvZ3JhbS5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL0dMVGV4dHVyZS5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL0dlb21ldHJ5LmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvR2VvbWV0cnlTeXN0ZW0uanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9HcmFwaGljcy5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL0dyYXBoaWNzRGF0YS5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL0dyYXBoaWNzR2VvbWV0cnkuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9Hcm91cEQ4LmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvSU9FcnJvckV2ZW50LmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvSW1hZ2VSZXNvdXJjZS5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL0ludGVyYWN0aW9uRGF0YS5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL0ludGVyYWN0aW9uRXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9JbnRlcmFjdGlvbk1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9JbnRlcmFjdGlvblRyYWNraW5nRGF0YS5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL0xpbmVTdHlsZS5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL0xvZ2dlci5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL01hc2tTeXN0ZW0uanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9NYXRoU2V0dGluZ3MuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9NYXRyaXguanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9NZXNoLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvTWVzaEJhdGNoVXZzLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvTWVzaEdlb21ldHJ5LmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvTWVzaE1hdGVyaWFsLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvTW91c2VFdmVudC5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL05ldHdvcmtTZXR0aW5ncy5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL09iamVjdFJlbmRlcmVyLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvT2JzZXJ2YWJsZVBvaW50LmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvUGFydGljbGVCdWZmZXIuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9QYXJ0aWNsZVJlbmRlcmVyLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvUG9pbnQuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9Qb2x5Z29uLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvUHJlcGFyZS5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL1Byb2dyYW0uanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9Qcm9ncmVzc0V2ZW50LmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvUHJvamVjdGlvblN5c3RlbS5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL1F1YWQuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9RdWFkVXYuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9RdWFkcmF0aWNVdGlscy5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL1JlY3RhbmdsZS5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL1JlbmRlclRleHR1cmUuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9SZW5kZXJUZXh0dXJlU3lzdGVtLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvUmVuZGVyZXIuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9SZXNvdXJjZS5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL1Jlc291cmNlTG9hZGVyLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvUmVzb3VyY2VTZXR0aW5ncy5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL1JvcGVHZW9tZXRyeS5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL1JvdW5kZWRSZWN0YW5nbGUuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9SdW5uZXIuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9TVkdSZXNvdXJjZS5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL1NoYWRlci5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL1NoYWRlclN5c3RlbS5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL1NoYXBlU2V0dGluZ3MuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9TaW1wbGVSb3BlLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvU3ByaXRlLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvU3ByaXRlTWFza0ZpbHRlci5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL1Nwcml0ZXNoZWV0LmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvU3RhZ2VPcHRpb25zLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvU3Rhci5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL1N0YXRlLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvU3RhdGVTeXN0ZW0uanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9TdGVuY2lsU3lzdGVtLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvU3lzdGVtLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvVGV4dC5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL1RleHRNZXRyaWNzLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvVGV4dFNldHRpbmdzLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvVGV4dFN0eWxlLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvVGV4dHVyZS5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL1RleHR1cmVHQ1N5c3RlbS5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL1RleHR1cmVNYXRyaXguanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9UZXh0dXJlU3lzdGVtLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvVGV4dHVyZVV2cy5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL1RpY2tlci5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL1RpY2tlckxpc3RlbmVyLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvVGlsaW5nU3ByaXRlUmVuZGVyZXIuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9UcmFuc2Zvcm0uanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9VUkxMb2FkZXIuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9VUkxSZXF1ZXN0LmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvVVJMUmVxdWVzdE1ldGhvZC5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL1VuaWZvcm1Hcm91cC5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL1VybC5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL1V0aWxzU2V0dGluZ3MuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9WaWRlb1Jlc291cmNlLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvV2ViR0xTZXR0aW5ncy5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL3NldHRpbmdzLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtEQUEwQyxnQ0FBZ0M7QUFDMUU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnRUFBd0Qsa0JBQWtCO0FBQzFFO0FBQ0EseURBQWlELGNBQWM7QUFDL0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUF5QyxpQ0FBaUM7QUFDMUUsd0hBQWdILG1CQUFtQixFQUFFO0FBQ3JJO0FBQ0E7O0FBRUE7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O0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxlQUFlO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixxQkFBcUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QiwwQkFBMEI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxjQUFjO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUU7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsV0FBVztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsV0FBVztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsV0FBVztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsY0FBYztBQUM3QjtBQUNBO0FBQ0E7QUFD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aUIsWUFBWTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsaUJBQWlCLFlBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixpQkFBaUIsWUFBWTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixpQkFBaUIsWUFBWTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx3QkFBd0I7QUFDdkMsaUJBQWlCLFlBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGVBQWU7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGVBQWU7QUFDOUIsZUFBZSxhQUFhO0FBQzVCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsZUFBZTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCLGVBQWUsWUFBWTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0IsZUFBZSxlQUFlO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixlQUFlO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsZUFBZTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQSxnQkFBZ0IsTUFBTTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUU7QUFDdkU7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RTtBQUN2RTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsb0JBQW9CLE9BQU8sa0JBQWtCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxjQUFjO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxjQUFjO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxjQUFjO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsVUFBVTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RTtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHdCQUF3QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQixlQUFlLG1CQUFtQjtBQUNsQyxlQUFlLG1CQUFtQjtBQUNsQyxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0IsZ0JBQWdCLFlBQVk7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCLGVBQWUsWUFBWTtBQUMzQixnQkFBZ0IsWUFBWTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixnQkFBZ0IsY0FBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQixjQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixnQkFBZ0IsY0FBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZ0JBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixnQkFBZ0IsY0FBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0EsZ0JBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQixjQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLFlBQVk7QUFDM0IsZ0JBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxTQUFTO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLCtCQUErQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsY0FBYztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixjQUFjO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELFFBQVE7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELFFBQVE7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixjQUFjO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFlLFdBQVc7QUFDMUIsZ0JBQWdCLFdBQVc7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsV0FBVztBQUMxQixlQUFlLFdBQVc7QUFDMUIsZ0JBQWdCLFdBQVc7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZ0JBQWdCLFlBQVk7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQixZQUFZO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZ0JBQWdCLFlBQVk7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0IsZ0JBQWdCLFlBQVk7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZ0JBQWdCLFlBQVk7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQixnQkFBZ0IsWUFBWTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZUFBZTtBQUM5QixnQkFBZ0IsZUFBZTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixZQUFZO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsWUFBWTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFlBQVk7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCLGdCQUFnQixZQUFZO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0IsZ0JBQWdCLFlBQVk7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUMzYWE7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RCxvQkFBb0IsbUJBQU8sQ0FBQywwREFBYTtBQUN6QyxnQkFBZ0IsbUJBQU8sQ0FBQyxrREFBUztBQUNqQyxrQkFBa0IsbUJBQU8sQ0FBQyxzREFBVztBQUNyQyx1QkFBdUIsbUJBQU8sQ0FBQyxnRUFBZ0I7QUFDL0MsZ0JBQWdCLG1CQUFPLENBQUMsa0RBQVM7QUFDakMsMkJBQTJCLG1CQUFPLENBQUMsd0VBQW9CO0FBQ3ZELDZCQUE2QixtQkFBTyxDQUFDLDRFQUFzQjtBQUMzRCwwQkFBMEIsbUJBQU8sQ0FBQyxzRUFBbUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSxzQkFBc0I7QUFDdEY7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsdUJBQXVCO0FBQ3pDLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxjQUFjO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsY0FBYztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQSxrQ0FBa0MsOEJBQThCO0FBQ2hFO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDhCQUE4QjtBQUM3QyxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStE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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsaUNBQWlDO0FBQ2hFO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsT0FBTztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGNBQWM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGVBQWU7QUFDOUIsZ0JBQWdCLGVBQWU7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFdBQVc7QUFDMUIsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGVBQWU7QUFDOUI7QUFDQSxlQUFlLFFBQVE7QUFD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cEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsa0JBQWtCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxjQUFjO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixRQUFRO0FBQ3hCLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0IseUJBQXlCO0FBQ3pDLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsUUFBUTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixTQUFTO0FBQ3pCO0FB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QUFPLENBQUMsa0VBQWlCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGVBQWU7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxRQUFRO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDaGlCYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVELDBCQUEwQixtQkFBTyxDQUFDLHNFQUFtQjtBQUNyRCxvQkFBb0IsbUJBQU8sQ0FBQywwREFBYTtBQUN6QyxnQkFBZ0IsbUJBQU8sQ0FBQyxrREFBUztBQUNqQyxnQkFBZ0IsbUJBQU8sQ0FBQyxrREFBUztBQUNqQyxxQkFBcUIsbUJBQU8sQ0FBQyw0REFBYztBQUMzQyxzQkFBc0IsbUJBQU8sQ0FBQyw4REFBZTtBQUM3Qyx3QkFBd0IsbUJBQU8sQ0FBQyxrRUFBaUI7QUFDakQseUJBQXlCLG1CQUFPLENBQUMsb0VBQWtCO0FBQ25ELHVCQUF1QixtQkFBTyxDQUFDLGdFQUFnQjtBQUMvQyx3QkFBd0IsbUJBQU8sQ0FBQyxrRUFBaUI7QUFDakQsMEJBQTBCLG1CQUFPLENBQUMsc0VBQW1CO0FBQ3JELDBCQUEwQixtQkFBTyxDQUFDLHNFQUFtQjtBQUNyRCxpQkFBaUIsbUJBQU8sQ0FBQyxvREFBVTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixpQkFBaUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGFBQWE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Q3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNsR2E7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDTmE7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ25EYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVELHdCQUF3QixtQkFBTyxDQUFDLGtFQUFpQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixtQkFBbUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLG1CQUFtQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsaUJBQWlCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFFBQVE7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLE1BQU07QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsZ0NBQWdDO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsNkJBQTZCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsT0FBTztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsT0FBTztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsRUFBRTtBQUNqQixlQUFlLE9BQU87QUFDdEIsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDNVFh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LHlEQUF5RCxpQ0FBaUMsc0NBQXNDLG1DQUFtQyw0QkFBNEIseUZBQXlGLHNDQUFzQyxLQUFLO0FBQ25VLCtEQUErRCxzQ0FBc0MsbUNBQW1DLCtCQUErQiw2QkFBNkIsOENBQThDLHlGQUF5RiwrRUFBK0UsS0FBSyw0Q0FBNEMsaUVBQWlFLEtBQUssNEJBQTRCLDZDQUE2Qyw2Q0FBNkMsS0FBSztBQUM1b0IiLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBnZXR0ZXIgfSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbiBcdFx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG4gXHRcdH1cbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiBcdH07XG5cbiBcdC8vIGNyZWF0ZSBhIGZha2UgbmFtZXNwYWNlIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XG4gXHQvLyBtb2RlICYgMjogbWVyZ2UgYWxsIHByb3BlcnRpZXMgb2YgdmFsdWUgaW50byB0aGUgbnNcbiBcdC8vIG1vZGUgJiA0OiByZXR1cm4gdmFsdWUgd2hlbiBhbHJlYWR5IG5zIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy50ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUpIHtcbiBcdFx0aWYobW9kZSAmIDEpIHZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyh2YWx1ZSk7XG4gXHRcdGlmKG1vZGUgJiA4KSByZXR1cm4gdmFsdWU7XG4gXHRcdGlmKChtb2RlICYgNCkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAmJiB2YWx1ZS5fX2VzTW9kdWxlKSByZXR1cm4gdmFsdWU7XG4gXHRcdHZhciBucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18ucihucyk7XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShucywgJ2RlZmF1bHQnLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2YWx1ZSB9KTtcbiBcdFx0aWYobW9kZSAmIDIgJiYgdHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSBmb3IodmFyIGtleSBpbiB2YWx1ZSkgX193ZWJwYWNrX3JlcXVpcmVfXy5kKG5zLCBrZXksIGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gdmFsdWVba2V5XTsgfS5iaW5kKG51bGwsIGtleSkpO1xuIFx0XHRyZXR1cm4gbnM7XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gXCIuL2pzLWNvbXBpbGUvaW5kZXguanNcIik7XG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBHcmFwaGljc18xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0dyYXBoaWNzXCIpO1xyXG5jb25zdCBDb250YWluZXJfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9Db250YWluZXJcIik7XHJcbmNvbnN0IEV2ZW50RGlzcGF0Y2hlcl8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0V2ZW50RGlzcGF0Y2hlclwiKTtcclxuY29uc3QgRXZlbnRfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9FdmVudFwiKTtcclxuY2xhc3MgQmFzZUV4YW1wbGUgZXh0ZW5kcyBFdmVudERpc3BhdGNoZXJfMS5FdmVudERpc3BhdGNoZXIge1xyXG4gICAgY29uc3RydWN0b3IoYXBwLCB3aWR0aCA9IDEwMCwgaGVpZ2h0ID0gMTAwKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLmJhY2tDb2xvciA9IDB4OTY5Njk2O1xyXG4gICAgICAgIHRoaXMuc2l6ZXcgPSB3aWR0aDtcclxuICAgICAgICB0aGlzLnNpemVoID0gaGVpZ2h0O1xyXG4gICAgICAgIHRoaXMuYXBwID0gYXBwO1xyXG4gICAgICAgIHRoaXMuc3RhZ2UgPSBuZXcgQ29udGFpbmVyXzEuQ29udGFpbmVyKCk7XHJcbiAgICB9XHJcbiAgICBhY3RpdmF0ZU1hc2soKSB7XHJcbiAgICAgICAgdGhpcy5zdGFnZU1hc2sgPSBuZXcgR3JhcGhpY3NfMS5HcmFwaGljcygpO1xyXG4gICAgICAgIHRoaXMuc3RhZ2VNYXNrLmJlZ2luRmlsbCgwKTtcclxuICAgICAgICB0aGlzLnN0YWdlTWFzay5kcmF3UmVjdCgwLCAwLCB0aGlzLnNpemV3LCB0aGlzLnNpemVoKTtcclxuICAgICAgICB0aGlzLnN0YWdlLm1hc2sgPSB0aGlzLnN0YWdlTWFzaztcclxuICAgIH1cclxuICAgIGRlc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5zdGFnZS5yZW1vdmVDaGlsZHJlbigpO1xyXG4gICAgICAgIGlmICh0aGlzLnN0YWdlTWFzaykge1xyXG4gICAgICAgICAgICB0aGlzLnN0YWdlTWFzay5kZXN0cm95KG51bGwpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGV4YW1wbGVSZWFkeSgpIHtcclxuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoRXZlbnRfMS5FdmVudC5nZXRFdmVudChFdmVudF8xLkV2ZW50LkNPTVBMRVRFKSk7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5CYXNlRXhhbXBsZSA9IEJhc2VFeGFtcGxlO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBCYXNlRXhhbXBsZV8xID0gcmVxdWlyZShcIi4vQmFzZUV4YW1wbGVcIik7XHJcbmNvbnN0IFJlc291cmNlTG9hZGVyXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvUmVzb3VyY2VMb2FkZXJcIik7XHJcbmNvbnN0IFVSTFJlcXVlc3RfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9VUkxSZXF1ZXN0XCIpO1xyXG5jb25zdCBFdmVudF8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0V2ZW50XCIpO1xyXG5jb25zdCBUZXh0dXJlXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvVGV4dHVyZVwiKTtcclxuY29uc3QgQmFzZVRleHR1cmVfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9CYXNlVGV4dHVyZVwiKTtcclxuY29uc3QgU3ByaXRlXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvU3ByaXRlXCIpO1xyXG5jb25zdCBDb250YWluZXJfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9Db250YWluZXJcIik7XHJcbmNvbnN0IFJlY3RhbmdsZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1JlY3RhbmdsZVwiKTtcclxuY29uc3QgRmlsdGVyXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvRmlsdGVyXCIpO1xyXG5jb25zdCBQb2ludF8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1BvaW50XCIpO1xyXG5jbGFzcyBGaWx0ZXJCbGVuZGluZyBleHRlbmRzIEJhc2VFeGFtcGxlXzEuQmFzZUV4YW1wbGUge1xyXG4gICAgY29uc3RydWN0b3IoYXBwLCB3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICAgICAgc3VwZXIoYXBwLCB3aWR0aCwgaGVpZ2h0KTtcclxuICAgICAgICB0aGlzLmhhbmRsZUdyYXNzTG9hZGVkID0gKGV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuYmFja2dyb3VuZHR4dCA9IG5ldyBUZXh0dXJlXzEuVGV4dHVyZShuZXcgQmFzZVRleHR1cmVfMS5CYXNlVGV4dHVyZSh0aGlzLmxvYWRlci5pbWFnZURhdGEpKTtcclxuICAgICAgICAgICAgY29uc3QgYmFja2dyb3VuZCA9IG5ldyBTcHJpdGVfMS5TcHJpdGUodGhpcy5iYWNrZ3JvdW5kdHh0KTtcclxuICAgICAgICAgICAgYmFja2dyb3VuZC53aWR0aCA9IHRoaXMuYXBwLnNjcmVlbi53aWR0aDtcclxuICAgICAgICAgICAgYmFja2dyb3VuZC5oZWlnaHQgPSB0aGlzLmFwcC5zY3JlZW4uaGVpZ2h0O1xyXG4gICAgICAgICAgICB0aGlzLmFwcC5zdGFnZS5hZGRDaGlsZChiYWNrZ3JvdW5kKTtcclxuICAgICAgICAgICAgY29uc3Qgc2hhZGVyRnJhZyA9IGBcclxuICAgICAgICAgICAgcHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xyXG4gICAgICAgICAgICB2YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcclxuICAgICAgICAgICAgdW5pZm9ybSB2ZWMyIG1vdXNlO1xyXG4gICAgICAgICAgICB1bmlmb3JtIHZlYzQgaW5wdXRTaXplO1xyXG4gICAgICAgICAgICB1bmlmb3JtIHZlYzQgb3V0cHV0RnJhbWU7XHJcbiAgICAgICAgICAgIHVuaWZvcm0gZmxvYXQgdGltZTtcclxuICAgICAgICAgICAgdm9pZCBtYWluKCkge1xyXG4gICAgICAgICAgICB2ZWMyIHNjcmVlblBvcyA9IHZUZXh0dXJlQ29vcmQgKiBpbnB1dFNpemUueHkgKyBvdXRwdXRGcmFtZS54eTtcclxuICAgICAgICAgICAgaWYgKGxlbmd0aChtb3VzZSAtIHNjcmVlblBvcykgPCAyNS4wKSB7XHJcbiAgICAgICAgICAgICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KDEuMCwgMS4wLCAwLjAsIDEuMCkgKiAwLjc7IC8veWVsbG93IGNpcmNsZSwgYWxwaGE9MC43XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KCBzaW4odGltZSksIChtb3VzZS54eSAtIG91dHB1dEZyYW1lLnh5KSAvIG91dHB1dEZyYW1lLnp3LCAxLjApICogMC41OyAvLyBibGVuZCB3aXRoIHVuZGVybHlpbmcgaW1hZ2UsIGFscGhhPTAuNVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYDtcclxuICAgICAgICAgICAgY29uc3QgY29udGFpbmVyID0gbmV3IENvbnRhaW5lcl8xLkNvbnRhaW5lcigpO1xyXG4gICAgICAgICAgICBjb250YWluZXIuZmlsdGVyQXJlYSA9IG5ldyBSZWN0YW5nbGVfMS5SZWN0YW5nbGUoMTAwLCAxMDAsIHRoaXMuYXBwLnNjcmVlbi53aWR0aCAtIDIwMCwgdGhpcy5hcHAuc2NyZWVuLmhlaWdodCAtIDIwMCk7XHJcbiAgICAgICAgICAgIHRoaXMuYXBwLnN0YWdlLmFkZENoaWxkKGNvbnRhaW5lcik7XHJcbiAgICAgICAgICAgIHRoaXMuZmlsdGVyID0gbmV3IEZpbHRlcl8xLkZpbHRlcihudWxsLCBzaGFkZXJGcmFnLCB7XHJcbiAgICAgICAgICAgICAgICBtb3VzZTogbmV3IFBvaW50XzEuUG9pbnQoKVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgY29udGFpbmVyLmZpbHRlcnMgPSBbdGhpcy5maWx0ZXJdO1xyXG4gICAgICAgICAgICB0aGlzLmFwcC50aWNrZXIuYWRkKHRoaXMucnVuRXhhbXBsZSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLnJ1bkV4YW1wbGUgPSAoZGVsdGEpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5maWx0ZXIudW5pZm9ybXMubW91c2UuY29weUZyb20odGhpcy5hcHAucmVuZGVyZXIucGx1Z2lucy5pbnRlcmFjdGlvbi5tb3VzZS5nbG9iYWwpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5sb2FkZXIgPSBuZXcgUmVzb3VyY2VMb2FkZXJfMS5SZXNvdXJjZUxvYWRlcihuZXcgVVJMUmVxdWVzdF8xLlVSTFJlcXVlc3QoXCJleGFtcGxlcy9hc3NldHMvYmdfZ3Jhc3MuanBnXCIpKTtcclxuICAgICAgICB0aGlzLmxvYWRlci5hZGRFdmVudExpc3RlbmVyKEV2ZW50XzEuRXZlbnQuQ09NUExFVEUsIHRoaXMuaGFuZGxlR3Jhc3NMb2FkZWQpO1xyXG4gICAgICAgIHRoaXMubG9hZGVyLmxvYWQoKTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLkZpbHRlckJsZW5kaW5nID0gRmlsdGVyQmxlbmRpbmc7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IEJhc2VFeGFtcGxlXzEgPSByZXF1aXJlKFwiLi9CYXNlRXhhbXBsZVwiKTtcclxuY29uc3QgUmVzb3VyY2VMb2FkZXJfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9SZXNvdXJjZUxvYWRlclwiKTtcclxuY29uc3QgVGV4dHVyZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1RleHR1cmVcIik7XHJcbmNvbnN0IFVSTFJlcXVlc3RfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9VUkxSZXF1ZXN0XCIpO1xyXG5jb25zdCBFdmVudF8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0V2ZW50XCIpO1xyXG5jb25zdCBCYXNlVGV4dHVyZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0Jhc2VUZXh0dXJlXCIpO1xyXG5jb25zdCBTcHJpdGVfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9TcHJpdGVcIik7XHJcbmNvbnN0IEJsdXJGaWx0ZXJfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9CbHVyRmlsdGVyXCIpO1xyXG5jbGFzcyBGaWx0ZXJCbHVyIGV4dGVuZHMgQmFzZUV4YW1wbGVfMS5CYXNlRXhhbXBsZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihhcHAsIHdpZHRoLCBoZWlnaHQpIHtcclxuICAgICAgICBzdXBlcihhcHAsIHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgICAgIHRoaXMuaGFuZGxlTW9ieUxvYWRlZCA9IChldmVudCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLm1vYnlUeHQgPSBuZXcgVGV4dHVyZV8xLlRleHR1cmUobmV3IEJhc2VUZXh0dXJlXzEuQmFzZVRleHR1cmUodGhpcy5sb2FkZXIuaW1hZ2VEYXRhKSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGJnID0gbmV3IFNwcml0ZV8xLlNwcml0ZSh0aGlzLmRlcHRoVHh0KTtcclxuICAgICAgICAgICAgYmcud2lkdGggPSB0aGlzLnNpemV3O1xyXG4gICAgICAgICAgICBiZy5oZWlnaHQgPSB0aGlzLnNpemVoO1xyXG4gICAgICAgICAgICB0aGlzLnN0YWdlLmFkZENoaWxkKGJnKTtcclxuICAgICAgICAgICAgY29uc3QgbGl0dGxlRHVkZXMgPSBuZXcgU3ByaXRlXzEuU3ByaXRlKHRoaXMuZHVkZXNUeHQpO1xyXG4gICAgICAgICAgICBsaXR0bGVEdWRlcy54ID0gKHRoaXMuc2l6ZXcgLyAyKSAtIDMxNTtcclxuICAgICAgICAgICAgbGl0dGxlRHVkZXMueSA9IDIwMDtcclxuICAgICAgICAgICAgdGhpcy5zdGFnZS5hZGRDaGlsZChsaXR0bGVEdWRlcyk7XHJcbiAgICAgICAgICAgIGNvbnN0IGxpdHRsZVJvYm90ID0gbmV3IFNwcml0ZV8xLlNwcml0ZSh0aGlzLm1vYnlUeHQpO1xyXG4gICAgICAgICAgICBsaXR0bGVSb2JvdC54ID0gKHRoaXMuc2l6ZXcgLyAyKSAtIDIwMDtcclxuICAgICAgICAgICAgbGl0dGxlUm9ib3QueSA9IDEwMDtcclxuICAgICAgICAgICAgdGhpcy5zdGFnZS5hZGRDaGlsZChsaXR0bGVSb2JvdCk7XHJcbiAgICAgICAgICAgIHRoaXMuYmx1ckZpbHRlcjEgPSBuZXcgQmx1ckZpbHRlcl8xLkJsdXJGaWx0ZXIoKTtcclxuICAgICAgICAgICAgdGhpcy5ibHVyRmlsdGVyMiA9IG5ldyBCbHVyRmlsdGVyXzEuQmx1ckZpbHRlcigpO1xyXG4gICAgICAgICAgICBsaXR0bGVEdWRlcy5maWx0ZXJzID0gW3RoaXMuYmx1ckZpbHRlcjFdO1xyXG4gICAgICAgICAgICBsaXR0bGVSb2JvdC5maWx0ZXJzID0gW3RoaXMuYmx1ckZpbHRlcjJdO1xyXG4gICAgICAgICAgICB0aGlzLmNvdW50ID0gMDtcclxuICAgICAgICAgICAgdGhpcy5hcHAudGlja2VyLmFkZCh0aGlzLnJ1bkV4YW1wbGUpO1xyXG4gICAgICAgICAgICB0aGlzLmV4YW1wbGVSZWFkeSgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5ydW5FeGFtcGxlID0gKGRlbHRhKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuY291bnQgKz0gMC4wMDU7XHJcbiAgICAgICAgICAgIGNvbnN0IGJsdXJBbW91bnQgPSBNYXRoLmNvcyh0aGlzLmNvdW50KTtcclxuICAgICAgICAgICAgY29uc3QgYmx1ckFtb3VudDIgPSBNYXRoLnNpbih0aGlzLmNvdW50KTtcclxuICAgICAgICAgICAgdGhpcy5ibHVyRmlsdGVyMS5ibHVyID0gMjAgKiAoYmx1ckFtb3VudCk7XHJcbiAgICAgICAgICAgIHRoaXMuYmx1ckZpbHRlcjIuYmx1ciA9IDIwICogKGJsdXJBbW91bnQyKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuaGFuZGxlRHVkZXNMb2FkZWQgPSAoZXZlbnQpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5kdWRlc1R4dCA9IG5ldyBUZXh0dXJlXzEuVGV4dHVyZShuZXcgQmFzZVRleHR1cmVfMS5CYXNlVGV4dHVyZSh0aGlzLmxvYWRlci5pbWFnZURhdGEpKTtcclxuICAgICAgICAgICAgdGhpcy5sb2FkZXIgPSBuZXcgUmVzb3VyY2VMb2FkZXJfMS5SZXNvdXJjZUxvYWRlcihuZXcgVVJMUmVxdWVzdF8xLlVSTFJlcXVlc3QoXCJleGFtcGxlcy9hc3NldHMvcGl4aS1maWx0ZXJzL2RlcHRoX2JsdXJfbW9ieS5qcGdcIikpO1xyXG4gICAgICAgICAgICB0aGlzLmxvYWRlci5hZGRFdmVudExpc3RlbmVyKEV2ZW50XzEuRXZlbnQuQ09NUExFVEUsIHRoaXMuaGFuZGxlTW9ieUxvYWRlZCk7XHJcbiAgICAgICAgICAgIHRoaXMubG9hZGVyLmxvYWQoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuaGFuZGxlRGVwdGhMb2FkZWQgPSAoZXZlbnQpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5kZXB0aFR4dCA9IG5ldyBUZXh0dXJlXzEuVGV4dHVyZShuZXcgQmFzZVRleHR1cmVfMS5CYXNlVGV4dHVyZSh0aGlzLmxvYWRlci5pbWFnZURhdGEpKTtcclxuICAgICAgICAgICAgdGhpcy5sb2FkZXIgPSBuZXcgUmVzb3VyY2VMb2FkZXJfMS5SZXNvdXJjZUxvYWRlcihuZXcgVVJMUmVxdWVzdF8xLlVSTFJlcXVlc3QoXCJleGFtcGxlcy9hc3NldHMvcGl4aS1maWx0ZXJzL2RlcHRoX2JsdXJfZHVkZXMuanBnXCIpKTtcclxuICAgICAgICAgICAgdGhpcy5sb2FkZXIuYWRkRXZlbnRMaXN0ZW5lcihFdmVudF8xLkV2ZW50LkNPTVBMRVRFLCB0aGlzLmhhbmRsZUR1ZGVzTG9hZGVkKTtcclxuICAgICAgICAgICAgdGhpcy5sb2FkZXIubG9hZCgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5sb2FkZXIgPSBuZXcgUmVzb3VyY2VMb2FkZXJfMS5SZXNvdXJjZUxvYWRlcihuZXcgVVJMUmVxdWVzdF8xLlVSTFJlcXVlc3QoXCJleGFtcGxlcy9hc3NldHMvcGl4aS1maWx0ZXJzL2JnX2RlcHRoX2JsdXIuanBnXCIpKTtcclxuICAgICAgICB0aGlzLmxvYWRlci5hZGRFdmVudExpc3RlbmVyKEV2ZW50XzEuRXZlbnQuQ09NUExFVEUsIHRoaXMuaGFuZGxlRGVwdGhMb2FkZWQpO1xyXG4gICAgICAgIHRoaXMubG9hZGVyLmxvYWQoKTtcclxuICAgIH1cclxuICAgIGRlc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIuZGVzdHJ1Y3RvcigpO1xyXG4gICAgICAgIHRoaXMuYXBwLnRpY2tlci5yZW1vdmUodGhpcy5ydW5FeGFtcGxlLCBudWxsKTtcclxuICAgICAgICB0aGlzLmJsdXJGaWx0ZXIxLmRlc3Ryb3koKTtcclxuICAgICAgICB0aGlzLmJsdXJGaWx0ZXIxID0gbnVsbDtcclxuICAgICAgICB0aGlzLmJsdXJGaWx0ZXIyLmRlc3Ryb3koKTtcclxuICAgICAgICB0aGlzLmJsdXJGaWx0ZXIyID0gbnVsbDtcclxuICAgICAgICB0aGlzLm1vYnlUeHQuZGVzdHJveShudWxsKTtcclxuICAgICAgICB0aGlzLm1vYnlUeHQgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuZHVkZXNUeHQuZGVzdHJveShudWxsKTtcclxuICAgICAgICB0aGlzLmR1ZGVzVHh0ID0gbnVsbDtcclxuICAgICAgICB0aGlzLmRlcHRoVHh0LmRlc3Ryb3kobnVsbCk7XHJcbiAgICAgICAgdGhpcy5kZXB0aFR4dCA9IG51bGw7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5GaWx0ZXJCbHVyID0gRmlsdGVyQmx1cjtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgQmFzZUV4YW1wbGVfMSA9IHJlcXVpcmUoXCIuL0Jhc2VFeGFtcGxlXCIpO1xyXG5jb25zdCBSZXNvdXJjZUxvYWRlcl8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1Jlc291cmNlTG9hZGVyXCIpO1xyXG5jb25zdCBUZXh0dXJlXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvVGV4dHVyZVwiKTtcclxuY29uc3QgVVJMUmVxdWVzdF8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1VSTFJlcXVlc3RcIik7XHJcbmNvbnN0IEV2ZW50XzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvRXZlbnRcIik7XHJcbmNvbnN0IEJhc2VUZXh0dXJlXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvQmFzZVRleHR1cmVcIik7XHJcbmNvbnN0IFNwcml0ZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1Nwcml0ZVwiKTtcclxuY29uc3QgQ29sb3JNYXRyaXhGaWx0ZXJfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9Db2xvck1hdHJpeEZpbHRlclwiKTtcclxuY29uc3QgVGV4dF8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1RleHRcIik7XHJcbmNvbnN0IENvbnRhaW5lcl8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0NvbnRhaW5lclwiKTtcclxuY29uc3QgTW91c2VFdmVudF8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL01vdXNlRXZlbnRcIik7XHJcbmNsYXNzIEZpbHRlckNvbG9yIGV4dGVuZHMgQmFzZUV4YW1wbGVfMS5CYXNlRXhhbXBsZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihhcHAsIHdpZHRoLCBoZWlnaHQpIHtcclxuICAgICAgICBzdXBlcihhcHAsIHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgICAgIHRoaXMuaGFuZGxlUGFuZGFMb2FkZWQgPSAoZXZlbnQpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5wYW5kYVR4dCA9IG5ldyBUZXh0dXJlXzEuVGV4dHVyZShuZXcgQmFzZVRleHR1cmVfMS5CYXNlVGV4dHVyZSh0aGlzLmxvYWRlci5pbWFnZURhdGEpKTtcclxuICAgICAgICAgICAgdGhpcy5iZyA9IG5ldyBTcHJpdGVfMS5TcHJpdGUodGhpcy5yb3RhdGVUeHQpO1xyXG4gICAgICAgICAgICB0aGlzLmJnLmFuY2hvci5zZXQoMC41KTtcclxuICAgICAgICAgICAgdGhpcy5iZy54ID0gdGhpcy5hcHAuc2NyZWVuLndpZHRoIC8gMjtcclxuICAgICAgICAgICAgdGhpcy5iZy55ID0gdGhpcy5hcHAuc2NyZWVuLmhlaWdodCAvIDI7XHJcbiAgICAgICAgICAgIHRoaXMuZmlsdGVyID0gbmV3IENvbG9yTWF0cml4RmlsdGVyXzEuQ29sb3JNYXRyaXhGaWx0ZXIoKTtcclxuICAgICAgICAgICAgY29uc3QgY29udGFpbmVyID0gbmV3IENvbnRhaW5lcl8xLkNvbnRhaW5lcigpO1xyXG4gICAgICAgICAgICBjb250YWluZXIueCA9IHRoaXMuYXBwLnNjcmVlbi53aWR0aCAvIDI7XHJcbiAgICAgICAgICAgIGNvbnRhaW5lci55ID0gdGhpcy5hcHAuc2NyZWVuLmhlaWdodCAvIDI7XHJcbiAgICAgICAgICAgIHRoaXMuYmdGcm9udCA9IG5ldyBTcHJpdGVfMS5TcHJpdGUodGhpcy5zY2VuZXJvdGF0ZVR4dCk7XHJcbiAgICAgICAgICAgIHRoaXMuYmdGcm9udC5hbmNob3Iuc2V0KDAuNSk7XHJcbiAgICAgICAgICAgIGNvbnRhaW5lci5hZGRDaGlsZCh0aGlzLmJnRnJvbnQpO1xyXG4gICAgICAgICAgICB0aGlzLmxpZ2h0MiA9IG5ldyBTcHJpdGVfMS5TcHJpdGUodGhpcy5saWdodHJvdGF0ZTJUeHQpO1xyXG4gICAgICAgICAgICB0aGlzLmxpZ2h0Mi5hbmNob3Iuc2V0KDAuNSk7XHJcbiAgICAgICAgICAgIGNvbnRhaW5lci5hZGRDaGlsZCh0aGlzLmxpZ2h0Mik7XHJcbiAgICAgICAgICAgIHRoaXMubGlnaHQxID0gbmV3IFNwcml0ZV8xLlNwcml0ZSh0aGlzLmxpZ2h0cm90YXRlMVR4dCk7XHJcbiAgICAgICAgICAgIHRoaXMubGlnaHQxLmFuY2hvci5zZXQoMC41KTtcclxuICAgICAgICAgICAgY29udGFpbmVyLmFkZENoaWxkKHRoaXMubGlnaHQxKTtcclxuICAgICAgICAgICAgdGhpcy5wYW5kYSA9IG5ldyBTcHJpdGVfMS5TcHJpdGUodGhpcy5wYW5kYVR4dCk7XHJcbiAgICAgICAgICAgIHRoaXMucGFuZGEuYW5jaG9yLnNldCgwLjUpO1xyXG4gICAgICAgICAgICBjb250YWluZXIuYWRkQ2hpbGQodGhpcy5wYW5kYSk7XHJcbiAgICAgICAgICAgIHRoaXMuYXBwLnN0YWdlLmFkZENoaWxkKGNvbnRhaW5lcik7XHJcbiAgICAgICAgICAgIHRoaXMuYXBwLnN0YWdlLmZpbHRlcnMgPSBbdGhpcy5maWx0ZXJdO1xyXG4gICAgICAgICAgICB0aGlzLmNvdW50ID0gMDtcclxuICAgICAgICAgICAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5hcHAuc3RhZ2UuYWRkRXZlbnRMaXN0ZW5lcihNb3VzZUV2ZW50XzEuTW91c2VFdmVudC5QT0lOVEVSX1RBUCwgdGhpcy5oYW5kbGVQb2ludGVyKTtcclxuICAgICAgICAgICAgY29uc3QgaGVscCA9IG5ldyBUZXh0XzEuVGV4dCgnQ2xpY2sgb3IgdGFwIHRvIHR1cm4gZmlsdGVycyBvbiAvIG9mZi4nLCB7XHJcbiAgICAgICAgICAgICAgICBmb250RmFtaWx5OiAnQXJpYWwnLFxyXG4gICAgICAgICAgICAgICAgZm9udFNpemU6IDEyLFxyXG4gICAgICAgICAgICAgICAgZm9udFdlaWdodDogJ2JvbGQnLFxyXG4gICAgICAgICAgICAgICAgZmlsbDogJ3doaXRlJyxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGhlbHAueSA9IHRoaXMuYXBwLnNjcmVlbi5oZWlnaHQgLSAyNTtcclxuICAgICAgICAgICAgaGVscC54ID0gMTA7XHJcbiAgICAgICAgICAgIHRoaXMuYXBwLnN0YWdlLmFkZENoaWxkKGhlbHApO1xyXG4gICAgICAgICAgICB0aGlzLmFwcC50aWNrZXIuYWRkKHRoaXMucnVuRXhhbXBsZSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLnJ1bkV4YW1wbGUgPSAoZGVsdGEpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5iZy5yb3RhdGlvbiArPSAwLjAxO1xyXG4gICAgICAgICAgICB0aGlzLmJnRnJvbnQucm90YXRpb24gLT0gMC4wMTtcclxuICAgICAgICAgICAgdGhpcy5saWdodDEucm90YXRpb24gKz0gMC4wMjtcclxuICAgICAgICAgICAgdGhpcy5saWdodDIucm90YXRpb24gKz0gMC4wMTtcclxuICAgICAgICAgICAgdGhpcy5wYW5kYS5zY2FsZS54ID0gMSArIE1hdGguc2luKHRoaXMuY291bnQpICogMC4wNDtcclxuICAgICAgICAgICAgdGhpcy5wYW5kYS5zY2FsZS55ID0gMSArIE1hdGguY29zKHRoaXMuY291bnQpICogMC4wNDtcclxuICAgICAgICAgICAgdGhpcy5jb3VudCArPSAwLjE7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgbWF0cml4IH0gPSB0aGlzLmZpbHRlcjtcclxuICAgICAgICAgICAgbWF0cml4WzFdID0gTWF0aC5zaW4odGhpcy5jb3VudCkgKiAzO1xyXG4gICAgICAgICAgICBtYXRyaXhbMl0gPSBNYXRoLmNvcyh0aGlzLmNvdW50KTtcclxuICAgICAgICAgICAgbWF0cml4WzNdID0gTWF0aC5jb3ModGhpcy5jb3VudCkgKiAxLjU7XHJcbiAgICAgICAgICAgIG1hdHJpeFs0XSA9IE1hdGguc2luKHRoaXMuY291bnQgLyAzKSAqIDI7XHJcbiAgICAgICAgICAgIG1hdHJpeFs1XSA9IE1hdGguc2luKHRoaXMuY291bnQgLyAyKTtcclxuICAgICAgICAgICAgbWF0cml4WzZdID0gTWF0aC5zaW4odGhpcy5jb3VudCAvIDQpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5oYW5kbGVQb2ludGVyID0gKGV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuZW5hYmxlZCA9ICF0aGlzLmVuYWJsZWQ7XHJcbiAgICAgICAgICAgIHRoaXMuYXBwLnN0YWdlLmZpbHRlcnMgPSB0aGlzLmVuYWJsZWQgPyBbdGhpcy5maWx0ZXJdIDogbnVsbDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuaGFuZGxlTGlnaHRSb3RhdGUxTG9hZGVkID0gKGV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMubGlnaHRyb3RhdGUxVHh0ID0gbmV3IFRleHR1cmVfMS5UZXh0dXJlKG5ldyBCYXNlVGV4dHVyZV8xLkJhc2VUZXh0dXJlKHRoaXMubG9hZGVyLmltYWdlRGF0YSkpO1xyXG4gICAgICAgICAgICB0aGlzLmxvYWRlciA9IG5ldyBSZXNvdXJjZUxvYWRlcl8xLlJlc291cmNlTG9hZGVyKG5ldyBVUkxSZXF1ZXN0XzEuVVJMUmVxdWVzdChcImV4YW1wbGVzL2Fzc2V0cy9saWdodF9yb3RhdGVfMS5wbmdcIikpO1xyXG4gICAgICAgICAgICB0aGlzLmxvYWRlci5hZGRFdmVudExpc3RlbmVyKEV2ZW50XzEuRXZlbnQuQ09NUExFVEUsIHRoaXMuaGFuZGxlTGlnaHRSb3RhdGUxTG9hZGVkKTtcclxuICAgICAgICAgICAgdGhpcy5sb2FkZXIubG9hZCgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5oYW5kbGVSb3RhdGVMb2FkZWQgPSAoZXZlbnQpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5yb3RhdGVUeHQgPSBuZXcgVGV4dHVyZV8xLlRleHR1cmUobmV3IEJhc2VUZXh0dXJlXzEuQmFzZVRleHR1cmUodGhpcy5sb2FkZXIuaW1hZ2VEYXRhKSk7XHJcbiAgICAgICAgICAgIHRoaXMubG9hZGVyID0gbmV3IFJlc291cmNlTG9hZGVyXzEuUmVzb3VyY2VMb2FkZXIobmV3IFVSTFJlcXVlc3RfMS5VUkxSZXF1ZXN0KFwiZXhhbXBsZXMvYXNzZXRzL2JnX3NjZW5lX3JvdGF0ZS5qcGdcIikpO1xyXG4gICAgICAgICAgICB0aGlzLmxvYWRlci5hZGRFdmVudExpc3RlbmVyKEV2ZW50XzEuRXZlbnQuQ09NUExFVEUsIHRoaXMuaGFuZGxlU2NlbmVSb3RhdGVMb2FkZWQpO1xyXG4gICAgICAgICAgICB0aGlzLmxvYWRlci5sb2FkKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLmhhbmRsZVNjZW5lUm90YXRlTG9hZGVkID0gKGV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuc2NlbmVyb3RhdGVUeHQgPSBuZXcgVGV4dHVyZV8xLlRleHR1cmUobmV3IEJhc2VUZXh0dXJlXzEuQmFzZVRleHR1cmUodGhpcy5sb2FkZXIuaW1hZ2VEYXRhKSk7XHJcbiAgICAgICAgICAgIHRoaXMubG9hZGVyID0gbmV3IFJlc291cmNlTG9hZGVyXzEuUmVzb3VyY2VMb2FkZXIobmV3IFVSTFJlcXVlc3RfMS5VUkxSZXF1ZXN0KFwiZXhhbXBsZXMvYXNzZXRzL2xpZ2h0X3JvdGF0ZV8yLnBuZ1wiKSk7XHJcbiAgICAgICAgICAgIHRoaXMubG9hZGVyLmFkZEV2ZW50TGlzdGVuZXIoRXZlbnRfMS5FdmVudC5DT01QTEVURSwgdGhpcy5oYW5kbGVMaWdodFJvdGF0ZTJMb2FkZWQpO1xyXG4gICAgICAgICAgICB0aGlzLmxvYWRlci5sb2FkKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLmhhbmRsZUxpZ2h0Um90YXRlMkxvYWRlZCA9IChldmVudCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLmxpZ2h0cm90YXRlMlR4dCA9IG5ldyBUZXh0dXJlXzEuVGV4dHVyZShuZXcgQmFzZVRleHR1cmVfMS5CYXNlVGV4dHVyZSh0aGlzLmxvYWRlci5pbWFnZURhdGEpKTtcclxuICAgICAgICAgICAgdGhpcy5sb2FkZXIgPSBuZXcgUmVzb3VyY2VMb2FkZXJfMS5SZXNvdXJjZUxvYWRlcihuZXcgVVJMUmVxdWVzdF8xLlVSTFJlcXVlc3QoXCJleGFtcGxlcy9hc3NldHMvcGFuZGEucG5nXCIpKTtcclxuICAgICAgICAgICAgdGhpcy5sb2FkZXIuYWRkRXZlbnRMaXN0ZW5lcihFdmVudF8xLkV2ZW50LkNPTVBMRVRFLCB0aGlzLmhhbmRsZVBhbmRhTG9hZGVkKTtcclxuICAgICAgICAgICAgdGhpcy5sb2FkZXIubG9hZCgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgYXBwLnN0YWdlLmludGVyYWN0aXZlID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmxvYWRlciA9IG5ldyBSZXNvdXJjZUxvYWRlcl8xLlJlc291cmNlTG9hZGVyKG5ldyBVUkxSZXF1ZXN0XzEuVVJMUmVxdWVzdChcImV4YW1wbGVzL2Fzc2V0cy9iZ19yb3RhdGUuanBnXCIpKTtcclxuICAgICAgICB0aGlzLmxvYWRlci5hZGRFdmVudExpc3RlbmVyKEV2ZW50XzEuRXZlbnQuQ09NUExFVEUsIHRoaXMuaGFuZGxlUm90YXRlTG9hZGVkKTtcclxuICAgICAgICB0aGlzLmxvYWRlci5sb2FkKCk7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5GaWx0ZXJDb2xvciA9IEZpbHRlckNvbG9yO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBCYXNlRXhhbXBsZV8xID0gcmVxdWlyZShcIi4vQmFzZUV4YW1wbGVcIik7XHJcbmNvbnN0IFJlc291cmNlTG9hZGVyXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvUmVzb3VyY2VMb2FkZXJcIik7XHJcbmNvbnN0IFRleHR1cmVfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9UZXh0dXJlXCIpO1xyXG5jb25zdCBDb250YWluZXJfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9Db250YWluZXJcIik7XHJcbmNvbnN0IFJlY3RhbmdsZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1JlY3RhbmdsZVwiKTtcclxuY29uc3QgTW91c2VFdmVudF8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL01vdXNlRXZlbnRcIik7XHJcbmNvbnN0IFNwcml0ZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1Nwcml0ZVwiKTtcclxuY29uc3QgVVJMUmVxdWVzdF8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1VSTFJlcXVlc3RcIik7XHJcbmNvbnN0IEV2ZW50XzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvRXZlbnRcIik7XHJcbmNvbnN0IEJhc2VUZXh0dXJlXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvQmFzZVRleHR1cmVcIik7XHJcbmNvbnN0IFBvaW50XzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvUG9pbnRcIik7XHJcbmNvbnN0IERpc3BsYWNlbWVudEZpbHRlcl8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0Rpc3BsYWNlbWVudEZpbHRlclwiKTtcclxuY2xhc3MgRmlsdGVyQ3Jhd2xpZXMgZXh0ZW5kcyBCYXNlRXhhbXBsZV8xLkJhc2VFeGFtcGxlIHtcclxuICAgIGNvbnN0cnVjdG9yKGFwcCwgd2lkdGgsIGhlaWdodCkge1xyXG4gICAgICAgIHN1cGVyKGFwcCwgd2lkdGgsIGhlaWdodCk7XHJcbiAgICAgICAgdGhpcy5oYW5kbGVHcmFzc0xvYWRlZCA9IChldmVudCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLmdyYXNzVHh0ID0gbmV3IFRleHR1cmVfMS5UZXh0dXJlKG5ldyBCYXNlVGV4dHVyZV8xLkJhc2VUZXh0dXJlKHRoaXMubG9hZGVyLmltYWdlRGF0YSkpO1xyXG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lciA9IG5ldyBDb250YWluZXJfMS5Db250YWluZXIoKTtcclxuICAgICAgICAgICAgdGhpcy5hcHAuc3RhZ2UuYWRkQ2hpbGQodGhpcy5jb250YWluZXIpO1xyXG4gICAgICAgICAgICBjb25zdCBwYWRkaW5nID0gMTAwO1xyXG4gICAgICAgICAgICB0aGlzLmJvdW5kcyA9IG5ldyBSZWN0YW5nbGVfMS5SZWN0YW5nbGUoLXBhZGRpbmcsIC1wYWRkaW5nLCB0aGlzLmFwcC5zY3JlZW4ud2lkdGggKyBwYWRkaW5nICogMiwgdGhpcy5hcHAuc2NyZWVuLmhlaWdodCArIHBhZGRpbmcgKiAyKTtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAyMDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBtYWdnb3QgPSBuZXcgRXh0ZW5kZWRTcHJpdGUodGhpcy5tYWdnb3RUeHQpO1xyXG4gICAgICAgICAgICAgICAgbWFnZ290LmFuY2hvci5zZXQoMC41KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLmFkZENoaWxkKG1hZ2dvdCk7XHJcbiAgICAgICAgICAgICAgICBtYWdnb3QuZGlyZWN0aW9uID0gTWF0aC5yYW5kb20oKSAqIE1hdGguUEkgKiAyO1xyXG4gICAgICAgICAgICAgICAgbWFnZ290LnNwZWVkID0gMTtcclxuICAgICAgICAgICAgICAgIG1hZ2dvdC50dXJuU3BlZWQgPSBNYXRoLnJhbmRvbSgpIC0gMC44O1xyXG4gICAgICAgICAgICAgICAgbWFnZ290LnggPSBNYXRoLnJhbmRvbSgpICogdGhpcy5ib3VuZHMud2lkdGg7XHJcbiAgICAgICAgICAgICAgICBtYWdnb3QueSA9IE1hdGgucmFuZG9tKCkgKiB0aGlzLmJvdW5kcy5oZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICBtYWdnb3Quc2NhbGUuc2V0KDEgKyBNYXRoLnJhbmRvbSgpICogMC4zKTtcclxuICAgICAgICAgICAgICAgIG1hZ2dvdC5vcmlnaW5hbCA9IG5ldyBQb2ludF8xLlBvaW50KCk7XHJcbiAgICAgICAgICAgICAgICBtYWdnb3Qub3JpZ2luYWwuY29weUZyb20obWFnZ290LnNjYWxlKTtcclxuICAgICAgICAgICAgICAgIHRoaXMubWFnZ290cy5wdXNoKG1hZ2dvdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5kaXNwbGFjZW1lbnRTcHJpdGUgPSBuZXcgU3ByaXRlXzEuU3ByaXRlKHRoaXMuZGlzcGxhY2VtZW50VHh0KTtcclxuICAgICAgICAgICAgY29uc3QgZGlzcGxhY2VtZW50RmlsdGVyID0gbmV3IERpc3BsYWNlbWVudEZpbHRlcl8xLkRpc3BsYWNlbWVudEZpbHRlcih0aGlzLmRpc3BsYWNlbWVudFNwcml0ZSk7XHJcbiAgICAgICAgICAgIHRoaXMuYXBwLnN0YWdlLmFkZENoaWxkKHRoaXMuZGlzcGxhY2VtZW50U3ByaXRlKTtcclxuICAgICAgICAgICAgdGhpcy5jb250YWluZXIuZmlsdGVycyA9IFtkaXNwbGFjZW1lbnRGaWx0ZXJdO1xyXG4gICAgICAgICAgICBkaXNwbGFjZW1lbnRGaWx0ZXIuc2NhbGUueCA9IDExMDtcclxuICAgICAgICAgICAgZGlzcGxhY2VtZW50RmlsdGVyLnNjYWxlLnkgPSAxMTA7XHJcbiAgICAgICAgICAgIHRoaXMuZGlzcGxhY2VtZW50U3ByaXRlLmFuY2hvci5zZXQoMC41KTtcclxuICAgICAgICAgICAgdGhpcy5yaW5nID0gbmV3IFNwcml0ZV8xLlNwcml0ZSh0aGlzLnJpbmdUeHQpO1xyXG4gICAgICAgICAgICB0aGlzLnJpbmcuYW5jaG9yLnNldCgwLjUpO1xyXG4gICAgICAgICAgICB0aGlzLnJpbmcudmlzaWJsZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLmFwcC5zdGFnZS5hZGRDaGlsZCh0aGlzLnJpbmcpO1xyXG4gICAgICAgICAgICBjb25zdCBiZyA9IG5ldyBTcHJpdGVfMS5TcHJpdGUodGhpcy5ncmFzc1R4dCk7XHJcbiAgICAgICAgICAgIGJnLndpZHRoID0gdGhpcy5hcHAuc2NyZWVuLndpZHRoO1xyXG4gICAgICAgICAgICBiZy5oZWlnaHQgPSB0aGlzLmFwcC5zY3JlZW4uaGVpZ2h0O1xyXG4gICAgICAgICAgICBiZy5hbHBoYSA9IDAuNDtcclxuICAgICAgICAgICAgdGhpcy5jb250YWluZXIuYWRkQ2hpbGQoYmcpO1xyXG4gICAgICAgICAgICB0aGlzLmFwcC5zdGFnZS5hZGRFdmVudExpc3RlbmVyKE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50Lk1PVVNFX01PVkUsIHRoaXMub25Qb2ludGVyTW92ZSk7XHJcbiAgICAgICAgICAgIHRoaXMuYXBwLnN0YWdlLmFkZEV2ZW50TGlzdGVuZXIoTW91c2VFdmVudF8xLk1vdXNlRXZlbnQuVE9VQ0hfTU9WRSwgdGhpcy5vblBvaW50ZXJNb3ZlKTtcclxuICAgICAgICAgICAgdGhpcy5hcHAudGlja2VyLmFkZCh0aGlzLnJ1bkV4YW1wbGUpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5oYW5kbGVNYWdnb3RMb2FkZWQgPSAoZXZlbnQpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5tYWdnb3RUeHQgPSBuZXcgVGV4dHVyZV8xLlRleHR1cmUobmV3IEJhc2VUZXh0dXJlXzEuQmFzZVRleHR1cmUodGhpcy5sb2FkZXIuaW1hZ2VEYXRhKSk7XHJcbiAgICAgICAgICAgIHRoaXMubG9hZGVyID0gbmV3IFJlc291cmNlTG9hZGVyXzEuUmVzb3VyY2VMb2FkZXIobmV3IFVSTFJlcXVlc3RfMS5VUkxSZXF1ZXN0KCdleGFtcGxlcy9hc3NldHMvYmdfZ3Jhc3MuanBnJykpO1xyXG4gICAgICAgICAgICB0aGlzLmxvYWRlci5hZGRFdmVudExpc3RlbmVyKEV2ZW50XzEuRXZlbnQuQ09NUExFVEUsIHRoaXMuaGFuZGxlR3Jhc3NMb2FkZWQpO1xyXG4gICAgICAgICAgICB0aGlzLmxvYWRlci5sb2FkKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLmhhbmRsZVJpbmdMb2FkZWQgPSAoZXZlbnQpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5yaW5nVHh0ID0gbmV3IFRleHR1cmVfMS5UZXh0dXJlKG5ldyBCYXNlVGV4dHVyZV8xLkJhc2VUZXh0dXJlKHRoaXMubG9hZGVyLmltYWdlRGF0YSkpO1xyXG4gICAgICAgICAgICB0aGlzLmxvYWRlciA9IG5ldyBSZXNvdXJjZUxvYWRlcl8xLlJlc291cmNlTG9hZGVyKG5ldyBVUkxSZXF1ZXN0XzEuVVJMUmVxdWVzdCgnZXhhbXBsZXMvYXNzZXRzL21hZ2dvdC5wbmcnKSk7XHJcbiAgICAgICAgICAgIHRoaXMubG9hZGVyLmFkZEV2ZW50TGlzdGVuZXIoRXZlbnRfMS5FdmVudC5DT01QTEVURSwgdGhpcy5oYW5kbGVNYWdnb3RMb2FkZWQpO1xyXG4gICAgICAgICAgICB0aGlzLmxvYWRlci5sb2FkKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLmhhbmRsZURpc3BsYWNlbWVudExvYWRlZCA9IChldmVudCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLmRpc3BsYWNlbWVudFR4dCA9IG5ldyBUZXh0dXJlXzEuVGV4dHVyZShuZXcgQmFzZVRleHR1cmVfMS5CYXNlVGV4dHVyZSh0aGlzLmxvYWRlci5pbWFnZURhdGEpKTtcclxuICAgICAgICAgICAgdGhpcy5sb2FkZXIgPSBuZXcgUmVzb3VyY2VMb2FkZXJfMS5SZXNvdXJjZUxvYWRlcihuZXcgVVJMUmVxdWVzdF8xLlVSTFJlcXVlc3QoJ2V4YW1wbGVzL2Fzc2V0cy9waXhpLWZpbHRlcnMvcmluZy5wbmcnKSk7XHJcbiAgICAgICAgICAgIHRoaXMubG9hZGVyLmFkZEV2ZW50TGlzdGVuZXIoRXZlbnRfMS5FdmVudC5DT01QTEVURSwgdGhpcy5oYW5kbGVSaW5nTG9hZGVkKTtcclxuICAgICAgICAgICAgdGhpcy5sb2FkZXIubG9hZCgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5oYW5kbGVSb3RhdGVMb2FkZWQgPSAoZXZlbnQpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5tYWdnb3RUeHQgPSBuZXcgVGV4dHVyZV8xLlRleHR1cmUobmV3IEJhc2VUZXh0dXJlXzEuQmFzZVRleHR1cmUodGhpcy5sb2FkZXIuaW1hZ2VEYXRhKSk7XHJcbiAgICAgICAgICAgIHRoaXMubG9hZGVyID0gbmV3IFJlc291cmNlTG9hZGVyXzEuUmVzb3VyY2VMb2FkZXIobmV3IFVSTFJlcXVlc3RfMS5VUkxSZXF1ZXN0KCdleGFtcGxlcy9hc3NldHMvcGl4aS1maWx0ZXJzL2Rpc3BsYWNlLnBuZycpKTtcclxuICAgICAgICAgICAgdGhpcy5sb2FkZXIuYWRkRXZlbnRMaXN0ZW5lcihFdmVudF8xLkV2ZW50LkNPTVBMRVRFLCB0aGlzLmhhbmRsZURpc3BsYWNlbWVudExvYWRlZCk7XHJcbiAgICAgICAgICAgIHRoaXMubG9hZGVyLmxvYWQoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMub25Qb2ludGVyTW92ZSA9IChldmVudCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnJpbmcudmlzaWJsZSA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuZGlzcGxhY2VtZW50U3ByaXRlLnBvc2l0aW9uLnNldChldmVudC5kYXRhLmdsb2JhbC54IC0gMjUsIGV2ZW50LmRhdGEuZ2xvYmFsLnkpO1xyXG4gICAgICAgICAgICB0aGlzLnJpbmcucG9zaXRpb24uY29weUZyb20odGhpcy5kaXNwbGFjZW1lbnRTcHJpdGUucG9zaXRpb24pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5ydW5FeGFtcGxlID0gKGRlbHRhKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuY291bnQgKz0gMC4wNTtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm1hZ2dvdHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG1hZ2dvdCA9IHRoaXMubWFnZ290c1tpXTtcclxuICAgICAgICAgICAgICAgIG1hZ2dvdC5kaXJlY3Rpb24gKz0gbWFnZ290LnR1cm5TcGVlZCAqIDAuMDE7XHJcbiAgICAgICAgICAgICAgICBtYWdnb3QueCArPSBNYXRoLnNpbihtYWdnb3QuZGlyZWN0aW9uKSAqIG1hZ2dvdC5zcGVlZDtcclxuICAgICAgICAgICAgICAgIG1hZ2dvdC55ICs9IE1hdGguY29zKG1hZ2dvdC5kaXJlY3Rpb24pICogbWFnZ290LnNwZWVkO1xyXG4gICAgICAgICAgICAgICAgbWFnZ290LnJvdGF0aW9uID0gLW1hZ2dvdC5kaXJlY3Rpb24gLSBNYXRoLlBJIC8gMjtcclxuICAgICAgICAgICAgICAgIG1hZ2dvdC5zY2FsZS54ID0gbWFnZ290Lm9yaWdpbmFsLnggKyBNYXRoLnNpbih0aGlzLmNvdW50KSAqIDAuMjtcclxuICAgICAgICAgICAgICAgIGlmIChtYWdnb3QueCA8IHRoaXMuYm91bmRzLngpIHtcclxuICAgICAgICAgICAgICAgICAgICBtYWdnb3QueCArPSB0aGlzLmJvdW5kcy53aWR0aDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1hZ2dvdC54ID4gdGhpcy5ib3VuZHMueCArIHRoaXMuYm91bmRzLndpZHRoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWFnZ290LnggLT0gdGhpcy5ib3VuZHMud2lkdGg7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAobWFnZ290LnkgPCB0aGlzLmJvdW5kcy55KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWFnZ290LnkgKz0gdGhpcy5ib3VuZHMuaGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobWFnZ290LnkgPiB0aGlzLmJvdW5kcy55ICsgdGhpcy5ib3VuZHMuaGVpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWFnZ290LnkgLT0gdGhpcy5ib3VuZHMuaGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLmNvdW50ID0gMDtcclxuICAgICAgICB0aGlzLm1hZ2dvdHMgPSBbXTtcclxuICAgICAgICBhcHAuc3RhZ2UuaW50ZXJhY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMubG9hZGVyID0gbmV3IFJlc291cmNlTG9hZGVyXzEuUmVzb3VyY2VMb2FkZXIobmV3IFVSTFJlcXVlc3RfMS5VUkxSZXF1ZXN0KFwiZXhhbXBsZXMvYXNzZXRzL2JnX3JvdGF0ZS5qcGdcIikpO1xyXG4gICAgICAgIHRoaXMubG9hZGVyLmFkZEV2ZW50TGlzdGVuZXIoRXZlbnRfMS5FdmVudC5DT01QTEVURSwgdGhpcy5oYW5kbGVSb3RhdGVMb2FkZWQpO1xyXG4gICAgICAgIHRoaXMubG9hZGVyLmxvYWQoKTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLkZpbHRlckNyYXdsaWVzID0gRmlsdGVyQ3Jhd2xpZXM7XHJcbmNsYXNzIEV4dGVuZGVkU3ByaXRlIGV4dGVuZHMgU3ByaXRlXzEuU3ByaXRlIHtcclxufVxyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBCYXNlRXhhbXBsZV8xID0gcmVxdWlyZShcIi4vQmFzZUV4YW1wbGVcIik7XHJcbmNvbnN0IFJlc291cmNlTG9hZGVyXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvUmVzb3VyY2VMb2FkZXJcIik7XHJcbmNvbnN0IFRleHR1cmVfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9UZXh0dXJlXCIpO1xyXG5jb25zdCBVUkxSZXF1ZXN0XzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvVVJMUmVxdWVzdFwiKTtcclxuY29uc3QgRXZlbnRfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9FdmVudFwiKTtcclxuY29uc3QgQmFzZVRleHR1cmVfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9CYXNlVGV4dHVyZVwiKTtcclxuY29uc3QgU3ByaXRlXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvU3ByaXRlXCIpO1xyXG5jb25zdCBVUkxMb2FkZXJfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9VUkxMb2FkZXJcIik7XHJcbmNvbnN0IEZpbHRlcl8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0ZpbHRlclwiKTtcclxuY29uc3QgTG9nZ2VyXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvTG9nZ2VyXCIpO1xyXG5jbGFzcyBGaWx0ZXJDdXN0b20gZXh0ZW5kcyBCYXNlRXhhbXBsZV8xLkJhc2VFeGFtcGxlIHtcclxuICAgIGNvbnN0cnVjdG9yKGFwcCwgd2lkdGgsIGhlaWdodCkge1xyXG4gICAgICAgIHN1cGVyKGFwcCwgd2lkdGgsIGhlaWdodCk7XHJcbiAgICAgICAgdGhpcy5oYW5kbGVHcmFzc0xvYWRlZCA9IChldmVudCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLmdyYXNzdHh0ID0gbmV3IFRleHR1cmVfMS5UZXh0dXJlKG5ldyBCYXNlVGV4dHVyZV8xLkJhc2VUZXh0dXJlKHRoaXMubG9hZGVyLmltYWdlRGF0YSkpO1xyXG4gICAgICAgICAgICB0aGlzLmJhY2tncm91bmQgPSBuZXcgU3ByaXRlXzEuU3ByaXRlKHRoaXMuZ3Jhc3N0eHQpO1xyXG4gICAgICAgICAgICB0aGlzLmJhY2tncm91bmQud2lkdGggPSB0aGlzLmFwcC5zY3JlZW4ud2lkdGg7XHJcbiAgICAgICAgICAgIHRoaXMuYmFja2dyb3VuZC5oZWlnaHQgPSB0aGlzLmFwcC5zY3JlZW4uaGVpZ2h0O1xyXG4gICAgICAgICAgICB0aGlzLmFwcC5zdGFnZS5hZGRDaGlsZCh0aGlzLmJhY2tncm91bmQpO1xyXG4gICAgICAgICAgICB0aGlzLnVybGxvYWRlciA9IG5ldyBVUkxMb2FkZXJfMS5VUkxMb2FkZXIoKTtcclxuICAgICAgICAgICAgdGhpcy51cmxsb2FkZXIuYWRkRXZlbnRMaXN0ZW5lcihFdmVudF8xLkV2ZW50LkNPTVBMRVRFLCB0aGlzLmhhbmRsZUZyYWdMb2FkZWQpO1xyXG4gICAgICAgICAgICB0aGlzLnVybGxvYWRlci5sb2FkKG5ldyBVUkxSZXF1ZXN0XzEuVVJMUmVxdWVzdChcImV4YW1wbGVzL2Fzc2V0cy9waXhpLWZpbHRlcnMvc2hhZGVyLmZyYWdcIikpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5oYW5kbGVGcmFnTG9hZGVkID0gKGV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgIGxldCBmcmFnZGF0YSA9IHRoaXMudXJsbG9hZGVyLmRhdGE7XHJcbiAgICAgICAgICAgIExvZ2dlcl8xLnRyYWNlKGZyYWdkYXRhKTtcclxuICAgICAgICAgICAgdGhpcy5maWx0ZXIgPSBuZXcgRmlsdGVyXzEuRmlsdGVyKG51bGwsIGZyYWdkYXRhLCB7XHJcbiAgICAgICAgICAgICAgICBjdXN0b21Vbmlmb3JtOiAwLjBcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHRoaXMuYmFja2dyb3VuZC5maWx0ZXJzID0gW3RoaXMuZmlsdGVyXTtcclxuICAgICAgICAgICAgdGhpcy5hcHAudGlja2VyLmFkZCh0aGlzLnJ1bkV4YW1wbGUpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5ydW5FeGFtcGxlID0gKGRlbHRhKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuZmlsdGVyLnVuaWZvcm1zLmN1c3RvbVVuaWZvcm0gKz0gMC4wNCAqIGRlbHRhO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5sb2FkZXIgPSBuZXcgUmVzb3VyY2VMb2FkZXJfMS5SZXNvdXJjZUxvYWRlcihuZXcgVVJMUmVxdWVzdF8xLlVSTFJlcXVlc3QoXCJleGFtcGxlcy9hc3NldHMvYmdfZ3Jhc3MuanBnXCIpKTtcclxuICAgICAgICB0aGlzLmxvYWRlci5hZGRFdmVudExpc3RlbmVyKEV2ZW50XzEuRXZlbnQuQ09NUExFVEUsIHRoaXMuaGFuZGxlR3Jhc3NMb2FkZWQpO1xyXG4gICAgICAgIHRoaXMubG9hZGVyLmxvYWQoKTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLkZpbHRlckN1c3RvbSA9IEZpbHRlckN1c3RvbTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgQmFzZUV4YW1wbGVfMSA9IHJlcXVpcmUoXCIuL0Jhc2VFeGFtcGxlXCIpO1xyXG5jb25zdCBDb250YWluZXJfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9Db250YWluZXJcIik7XHJcbmNvbnN0IFJlc291cmNlTG9hZGVyXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvUmVzb3VyY2VMb2FkZXJcIik7XHJcbmNvbnN0IFRleHR1cmVfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9UZXh0dXJlXCIpO1xyXG5jb25zdCBVUkxSZXF1ZXN0XzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvVVJMUmVxdWVzdFwiKTtcclxuY29uc3QgRXZlbnRfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9FdmVudFwiKTtcclxuY29uc3QgQmFzZVRleHR1cmVfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9CYXNlVGV4dHVyZVwiKTtcclxuY29uc3QgU3ByaXRlXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvU3ByaXRlXCIpO1xyXG5jb25zdCBXZWJHTFNldHRpbmdzXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvV2ViR0xTZXR0aW5nc1wiKTtcclxuY29uc3QgRGlzcGxhY2VtZW50RmlsdGVyXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvRGlzcGxhY2VtZW50RmlsdGVyXCIpO1xyXG5jbGFzcyBGaWx0ZXJGbGFnIGV4dGVuZHMgQmFzZUV4YW1wbGVfMS5CYXNlRXhhbXBsZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihhcHAsIHdpZHRoLCBoZWlnaHQpIHtcclxuICAgICAgICBzdXBlcihhcHAsIHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgICAgIHRoaXMuaGFuZGxlRGlzcGxhY2VtZW50TG9hZGVkID0gKGV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMucmVwZWF0VHh0ID0gbmV3IFRleHR1cmVfMS5UZXh0dXJlKG5ldyBCYXNlVGV4dHVyZV8xLkJhc2VUZXh0dXJlKHRoaXMubG9hZGVyLmltYWdlRGF0YSkpO1xyXG4gICAgICAgICAgICBjb25zdCBjb250YWluZXIgPSBuZXcgQ29udGFpbmVyXzEuQ29udGFpbmVyKCk7XHJcbiAgICAgICAgICAgIHRoaXMuYXBwLnN0YWdlLmFkZENoaWxkKGNvbnRhaW5lcik7XHJcbiAgICAgICAgICAgIGNvbnN0IGZsYWcgPSBuZXcgU3ByaXRlXzEuU3ByaXRlKHRoaXMuZmxhZ1R4dCk7XHJcbiAgICAgICAgICAgIGNvbnRhaW5lci5hZGRDaGlsZChmbGFnKTtcclxuICAgICAgICAgICAgZmxhZy54ID0gMTAwO1xyXG4gICAgICAgICAgICBmbGFnLnkgPSAxMDA7XHJcbiAgICAgICAgICAgIHRoaXMuZGlzcGxhY2VtZW50U3ByaXRlID0gbmV3IFNwcml0ZV8xLlNwcml0ZSh0aGlzLnJlcGVhdFR4dCk7XHJcbiAgICAgICAgICAgIHRoaXMuZGlzcGxhY2VtZW50U3ByaXRlLnRleHR1cmUuYmFzZVRleHR1cmUud3JhcE1vZGUgPSBXZWJHTFNldHRpbmdzXzEuV2ViR0xTZXR0aW5ncy5XUkFQX01PREVTLlJFUEVBVDtcclxuICAgICAgICAgICAgY29uc3QgZGlzcGxhY2VtZW50RmlsdGVyID0gbmV3IERpc3BsYWNlbWVudEZpbHRlcl8xLkRpc3BsYWNlbWVudEZpbHRlcih0aGlzLmRpc3BsYWNlbWVudFNwcml0ZSk7XHJcbiAgICAgICAgICAgIGRpc3BsYWNlbWVudEZpbHRlci5wYWRkaW5nID0gMTA7XHJcbiAgICAgICAgICAgIHRoaXMuZGlzcGxhY2VtZW50U3ByaXRlLnBvc2l0aW9uID0gZmxhZy5wb3NpdGlvbjtcclxuICAgICAgICAgICAgdGhpcy5hcHAuc3RhZ2UuYWRkQ2hpbGQodGhpcy5kaXNwbGFjZW1lbnRTcHJpdGUpO1xyXG4gICAgICAgICAgICBmbGFnLmZpbHRlcnMgPSBbZGlzcGxhY2VtZW50RmlsdGVyXTtcclxuICAgICAgICAgICAgZGlzcGxhY2VtZW50RmlsdGVyLnNjYWxlLnggPSAzMDtcclxuICAgICAgICAgICAgZGlzcGxhY2VtZW50RmlsdGVyLnNjYWxlLnkgPSA2MDtcclxuICAgICAgICAgICAgdGhpcy5hcHAudGlja2VyLmFkZCh0aGlzLnJ1bkV4YW1wbGUpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5ydW5FeGFtcGxlID0gKGRlbHRhKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuZGlzcGxhY2VtZW50U3ByaXRlLngrKztcclxuICAgICAgICAgICAgaWYgKHRoaXMuZGlzcGxhY2VtZW50U3ByaXRlLnggPiB0aGlzLmRpc3BsYWNlbWVudFNwcml0ZS53aWR0aCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwbGFjZW1lbnRTcHJpdGUueCA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuaGFuZGxlUm90YXRlTG9hZGVkID0gKGV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuZmxhZ1R4dCA9IG5ldyBUZXh0dXJlXzEuVGV4dHVyZShuZXcgQmFzZVRleHR1cmVfMS5CYXNlVGV4dHVyZSh0aGlzLmxvYWRlci5pbWFnZURhdGEpKTtcclxuICAgICAgICAgICAgdGhpcy5sb2FkZXIgPSBuZXcgUmVzb3VyY2VMb2FkZXJfMS5SZXNvdXJjZUxvYWRlcihuZXcgVVJMUmVxdWVzdF8xLlVSTFJlcXVlc3QoJ2V4YW1wbGVzL2Fzc2V0cy9waXhpLWZpbHRlcnMvZGlzcGxhY2VtZW50X21hcF9yZXBlYXQuanBnJykpO1xyXG4gICAgICAgICAgICB0aGlzLmxvYWRlci5hZGRFdmVudExpc3RlbmVyKEV2ZW50XzEuRXZlbnQuQ09NUExFVEUsIHRoaXMuaGFuZGxlRGlzcGxhY2VtZW50TG9hZGVkKTtcclxuICAgICAgICAgICAgdGhpcy5sb2FkZXIubG9hZCgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgYXBwLnN0YWdlLmludGVyYWN0aXZlID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmxvYWRlciA9IG5ldyBSZXNvdXJjZUxvYWRlcl8xLlJlc291cmNlTG9hZGVyKG5ldyBVUkxSZXF1ZXN0XzEuVVJMUmVxdWVzdChcImV4YW1wbGVzL2Fzc2V0cy9waXhpLWZpbHRlcnMvZmxhZy5wbmdcIikpO1xyXG4gICAgICAgIHRoaXMubG9hZGVyLmFkZEV2ZW50TGlzdGVuZXIoRXZlbnRfMS5FdmVudC5DT01QTEVURSwgdGhpcy5oYW5kbGVSb3RhdGVMb2FkZWQpO1xyXG4gICAgICAgIHRoaXMubG9hZGVyLmxvYWQoKTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLkZpbHRlckZsYWcgPSBGaWx0ZXJGbGFnO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBCYXNlRXhhbXBsZV8xID0gcmVxdWlyZShcIi4vQmFzZUV4YW1wbGVcIik7XHJcbmNvbnN0IFVSTExvYWRlcl8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1VSTExvYWRlclwiKTtcclxuY29uc3QgRXZlbnRfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9FdmVudFwiKTtcclxuY29uc3QgVVJMUmVxdWVzdF8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1VSTFJlcXVlc3RcIik7XHJcbmNvbnN0IFJlc291cmNlTG9hZGVyXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvUmVzb3VyY2VMb2FkZXJcIik7XHJcbmNvbnN0IFRleHR1cmVfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9UZXh0dXJlXCIpO1xyXG5jb25zdCBCYXNlVGV4dHVyZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0Jhc2VUZXh0dXJlXCIpO1xyXG5jb25zdCBTcHJpdGVzaGVldF8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1Nwcml0ZXNoZWV0XCIpO1xyXG5jb25zdCBBbmltYXRlZFNwcml0ZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0FuaW1hdGVkU3ByaXRlXCIpO1xyXG5jb25zdCBGaWx0ZXJfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9GaWx0ZXJcIik7XHJcbmNsYXNzIEZpbHRlclNoYWRvdyBleHRlbmRzIEJhc2VFeGFtcGxlXzEuQmFzZUV4YW1wbGUge1xyXG4gICAgY29uc3RydWN0b3IoYXBwLCB3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICAgICAgc3VwZXIoYXBwLCB3aWR0aCwgaGVpZ2h0KTtcclxuICAgICAgICB0aGlzLm9uQW5pbWF0aW9uUGFyc2VkID0gKHRleHR1cmVzKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuYXBwLnN0YWdlLmludGVyYWN0aXZlID0gdHJ1ZTtcclxuICAgICAgICAgICAgY29uc3QgZnJhbWVzID0gW107XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMzA7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdmFsID0gaSA8IDEwID8gYDAke2l9YCA6IGk7XHJcbiAgICAgICAgICAgICAgICBmcmFtZXMucHVzaCh0ZXh0dXJlc1tgcm9sbFNlcXVlbmNlMDAke3ZhbH0ucG5nYF0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuYW5pbSA9IG5ldyBBbmltYXRlZFNwcml0ZV8xLkFuaW1hdGVkU3ByaXRlKGZyYW1lcyk7XHJcbiAgICAgICAgICAgIHRoaXMuYW5pbS54ID0gdGhpcy5hcHAuc2NyZWVuLndpZHRoIC8gMjtcclxuICAgICAgICAgICAgdGhpcy5hbmltLnkgPSB0aGlzLmFwcC5zY3JlZW4uaGVpZ2h0IC8gMjtcclxuICAgICAgICAgICAgdGhpcy5hbmltLmFuY2hvci5zZXQoMC41KTtcclxuICAgICAgICAgICAgdGhpcy5hbmltLmFuaW1hdGlvblNwZWVkID0gMC41O1xyXG4gICAgICAgICAgICB0aGlzLmFuaW0ucGxheSgpO1xyXG4gICAgICAgICAgICB0aGlzLmFwcC5zdGFnZS5hZGRDaGlsZCh0aGlzLmFuaW0pO1xyXG4gICAgICAgICAgICB0aGlzLmZpbHRlciA9IG5ldyBGaWx0ZXJfMS5GaWx0ZXIoRmlsdGVyU2hhZG93Lm15VmVydGV4LCBGaWx0ZXJTaGFkb3cubXlGcmFnbWVudCk7XHJcbiAgICAgICAgICAgIHRoaXMuZmlsdGVyLnVuaWZvcm1zLnNoYWRvd0RpcmVjdGlvbiA9IFswLjEsIDAuNV07XHJcbiAgICAgICAgICAgIHRoaXMuZmlsdGVyLnVuaWZvcm1zLmZsb29yWSA9IHRoaXMuYW5pbS5oZWlnaHQgKiAyO1xyXG4gICAgICAgICAgICB0aGlzLmZpbHRlci5wYWRkaW5nID0gMjAwO1xyXG4gICAgICAgICAgICB0aGlzLmFuaW0uZmlsdGVycyA9IFt0aGlzLmZpbHRlcl07XHJcbiAgICAgICAgICAgIHRoaXMuYXBwLnRpY2tlci5hZGQodGhpcy5ydW5FeGFtcGxlKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMucnVuRXhhbXBsZSA9IChkZWx0YSkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLmZpbHRlci51bmlmb3Jtcy5mbG9vclkgPSB0aGlzLmFwcC5yZW5kZXJlci5wbHVnaW5zLmludGVyYWN0aW9uLm1vdXNlLmdsb2JhbC55O1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5oYW5kbGVKc29uTG9hZGVkID0gKGV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuanNvbmRhdGEgPSBKU09OLnBhcnNlKHRoaXMudXJsbG9hZGVyLmRhdGEpO1xyXG4gICAgICAgICAgICB0aGlzLmxvYWRlciA9IG5ldyBSZXNvdXJjZUxvYWRlcl8xLlJlc291cmNlTG9hZGVyKG5ldyBVUkxSZXF1ZXN0XzEuVVJMUmVxdWVzdChcImV4YW1wbGVzL2Fzc2V0cy9zcHJpdGVzaGVldC9maWdodGVyLnBuZ1wiKSk7XHJcbiAgICAgICAgICAgIHRoaXMubG9hZGVyLmFkZEV2ZW50TGlzdGVuZXIoRXZlbnRfMS5FdmVudC5DT01QTEVURSwgdGhpcy5oYW5kbGVSb3RhdGVMb2FkZWQpO1xyXG4gICAgICAgICAgICB0aGlzLmxvYWRlci5sb2FkKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLmhhbmRsZVJvdGF0ZUxvYWRlZCA9IChldmVudCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnR4dCA9IG5ldyBUZXh0dXJlXzEuVGV4dHVyZShuZXcgQmFzZVRleHR1cmVfMS5CYXNlVGV4dHVyZSh0aGlzLmxvYWRlci5pbWFnZURhdGEpKTtcclxuICAgICAgICAgICAgbGV0IHNwcml0ZXNoZWV0ID0gbmV3IFNwcml0ZXNoZWV0XzEuU3ByaXRlc2hlZXQodGhpcy50eHQsIHRoaXMuanNvbmRhdGEpO1xyXG4gICAgICAgICAgICBzcHJpdGVzaGVldC5wYXJzZSh0aGlzLm9uQW5pbWF0aW9uUGFyc2VkKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMudXJsbG9hZGVyID0gbmV3IFVSTExvYWRlcl8xLlVSTExvYWRlcigpO1xyXG4gICAgICAgIHRoaXMudXJsbG9hZGVyLmFkZEV2ZW50TGlzdGVuZXIoRXZlbnRfMS5FdmVudC5DT01QTEVURSwgdGhpcy5oYW5kbGVKc29uTG9hZGVkKTtcclxuICAgICAgICB0aGlzLnVybGxvYWRlci5sb2FkKG5ldyBVUkxSZXF1ZXN0XzEuVVJMUmVxdWVzdChcImV4YW1wbGVzL2Fzc2V0cy9zcHJpdGVzaGVldC9maWdodGVyLmpzb25cIikpO1xyXG4gICAgfVxyXG59XHJcbkZpbHRlclNoYWRvdy5teVZlcnRleCA9IGBcclxuICAgICAgICBhdHRyaWJ1dGUgdmVjMiBhVmVydGV4UG9zaXRpb247XHJcbiAgICAgICAgYXR0cmlidXRlIHZlYzIgYVRleHR1cmVDb29yZDtcclxuICAgICAgICB1bmlmb3JtIG1hdDMgcHJvamVjdGlvbk1hdHJpeDtcclxuICAgICAgICB2YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcclxuICAgICAgICB2b2lkIG1haW4odm9pZCkge1xyXG4gICAgICAgICAgICBnbF9Qb3NpdGlvbiA9IHZlYzQoKHByb2plY3Rpb25NYXRyaXggKiB2ZWMzKGFWZXJ0ZXhQb3NpdGlvbiwgMS4wKSkueHksIDAuMCwgMS4wKTtcclxuICAgICAgICAgICAgdlRleHR1cmVDb29yZCA9IGFUZXh0dXJlQ29vcmQ7XHJcbiAgICAgICAgfVxyXG4gICAgYDtcclxuRmlsdGVyU2hhZG93Lm15RnJhZ21lbnQgPSBgXHJcbiAgICAgICAgdmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XHJcbiAgICAgICAgdW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXI7XHJcbiAgICAgICAgdW5pZm9ybSB2ZWM0IGlucHV0U2l6ZTtcclxuICAgICAgICB1bmlmb3JtIHZlYzQgb3V0cHV0RnJhbWU7XHJcbiAgICAgICAgdW5pZm9ybSB2ZWMyIHNoYWRvd0RpcmVjdGlvbjtcclxuICAgICAgICB1bmlmb3JtIGZsb2F0IGZsb29yWTtcclxuICAgICAgICB2b2lkIG1haW4odm9pZCkge1xyXG4gICAgICAgICAgICAvLzEuIGdldCB0aGUgc2NyZWVuIGNvb3JkaW5hdGVcclxuICAgICAgICAgICAgdmVjMiBzY3JlZW5Db29yZCA9IHZUZXh0dXJlQ29vcmQgKiBpbnB1dFNpemUueHkgKyBvdXRwdXRGcmFtZS54eTtcclxuICAgICAgICAgICAgLy8yLiBjYWxjdWxhdGUgWSBzaGlmdCBvZiBvdXIgZGltZW5zaW9uIHZlY3RvclxyXG4gICAgICAgICAgICB2ZWMyIHNoYWRvdztcclxuICAgICAgICAgICAgLy9zaGFkb3cgY29vcmRpbmF0ZSBzeXN0ZW0gaXMgYSBiaXQgc2tld2VkLCBidXQgaXQgaGFzIHRvIGJlIHRoZSBzYW1lIGZvciBzY3JlZW5Db29yZC55ID0gZmxvb3JZXHJcbiAgICAgICAgICAgIGZsb2F0IHBhcmFtWSA9IChzY3JlZW5Db29yZC55IC0gZmxvb3JZKSAvIHNoYWRvd0RpcmVjdGlvbi55O1xyXG4gICAgICAgICAgICBzaGFkb3cueSA9IHBhcmFtWSArIGZsb29yWTtcclxuICAgICAgICAgICAgc2hhZG93LnggPSBzY3JlZW5Db29yZC54ICsgcGFyYW1ZICogc2hhZG93RGlyZWN0aW9uLng7XHJcbiAgICAgICAgICAgIHZlYzIgYm9keUZpbHRlckNvb3JkID0gKHNoYWRvdyAtIG91dHB1dEZyYW1lLnh5KSAqIGlucHV0U2l6ZS56dzsgLy8gc2FtZSBhcyAvIGlucHV0U2l6ZS54eVxyXG4gICAgICAgICAgICB2ZWM0IG9yaWdpbmFsQ29sb3IgPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZUZXh0dXJlQ29vcmQpO1xyXG4gICAgICAgICAgICB2ZWM0IHNoYWRvd0NvbG9yID0gdGV4dHVyZTJEKHVTYW1wbGVyLCBib2R5RmlsdGVyQ29vcmQpO1xyXG4gICAgICAgICAgICBzaGFkb3dDb2xvci5yZ2IgPSB2ZWMzKDAuMCk7XHJcbiAgICAgICAgICAgIHNoYWRvd0NvbG9yLmEgKj0gMC41O1xyXG4gICAgICAgICAgICAvLyBub3JtYWwgYmxlbmQgbW9kZSBjb2VmZmljaWVudHMgKDEsIDEtc3JjX2FscGhhKVxyXG4gICAgICAgICAgICAvLyBzaGFkb3cgaXMgZGVzdGluYXRpb24gKGJhY2tkcm9wKSwgb3JpZ2luYWwgaXMgc291cmNlXHJcbiAgICAgICAgICAgIGdsX0ZyYWdDb2xvciA9IG9yaWdpbmFsQ29sb3IgKyBzaGFkb3dDb2xvciAqICgxLjAgLSBvcmlnaW5hbENvbG9yLmEpO1xyXG4gICAgICAgIH1cclxuICAgIGA7XHJcbmV4cG9ydHMuRmlsdGVyU2hhZG93ID0gRmlsdGVyU2hhZG93O1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBCYXNlRXhhbXBsZV8xID0gcmVxdWlyZShcIi4vQmFzZUV4YW1wbGVcIik7XHJcbmNvbnN0IFJlc291cmNlTG9hZGVyXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvUmVzb3VyY2VMb2FkZXJcIik7XHJcbmNvbnN0IFRleHR1cmVfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9UZXh0dXJlXCIpO1xyXG5jb25zdCBVUkxSZXF1ZXN0XzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvVVJMUmVxdWVzdFwiKTtcclxuY29uc3QgRXZlbnRfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9FdmVudFwiKTtcclxuY29uc3QgQmFzZVRleHR1cmVfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9CYXNlVGV4dHVyZVwiKTtcclxuY29uc3QgR3JhcGhpY3NfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9HcmFwaGljc1wiKTtcclxuY29uc3QgQmx1ckZpbHRlcl8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0JsdXJGaWx0ZXJcIik7XHJcbmNvbnN0IFJlY3RhbmdsZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1JlY3RhbmdsZVwiKTtcclxuY29uc3QgV2ViR0xTZXR0aW5nc18xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1dlYkdMU2V0dGluZ3NcIik7XHJcbmNvbnN0IFNwcml0ZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1Nwcml0ZVwiKTtcclxuY29uc3QgTW91c2VFdmVudF8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL01vdXNlRXZlbnRcIik7XHJcbmNsYXNzIE1hc2tGaWx0ZXIgZXh0ZW5kcyBCYXNlRXhhbXBsZV8xLkJhc2VFeGFtcGxlIHtcclxuICAgIGNvbnN0cnVjdG9yKGFwcCwgd2lkdGgsIGhlaWdodCkge1xyXG4gICAgICAgIHN1cGVyKGFwcCwgd2lkdGgsIGhlaWdodCk7XHJcbiAgICAgICAgdGhpcy5oYW5kbGVSb3RhdGVMb2FkZWQgPSAoZXZlbnQpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5mbGFnVHh0ID0gbmV3IFRleHR1cmVfMS5UZXh0dXJlKG5ldyBCYXNlVGV4dHVyZV8xLkJhc2VUZXh0dXJlKHRoaXMubG9hZGVyLmltYWdlRGF0YSkpO1xyXG4gICAgICAgICAgICBjb25zdCByYWRpdXMgPSAxMDA7XHJcbiAgICAgICAgICAgIGNvbnN0IGJsdXJTaXplID0gMzI7XHJcbiAgICAgICAgICAgIGNvbnN0IGJhY2tncm91bmQgPSBuZXcgU3ByaXRlXzEuU3ByaXRlKHRoaXMuZmxhZ1R4dCk7XHJcbiAgICAgICAgICAgIHRoaXMuYXBwLnN0YWdlLmFkZENoaWxkKGJhY2tncm91bmQpO1xyXG4gICAgICAgICAgICBiYWNrZ3JvdW5kLndpZHRoID0gdGhpcy5hcHAuc2NyZWVuLndpZHRoO1xyXG4gICAgICAgICAgICBiYWNrZ3JvdW5kLmhlaWdodCA9IHRoaXMuYXBwLnNjcmVlbi5oZWlnaHQ7XHJcbiAgICAgICAgICAgIGNvbnN0IGNpcmNsZSA9IG5ldyBHcmFwaGljc18xLkdyYXBoaWNzKClcclxuICAgICAgICAgICAgICAgIC5iZWdpbkZpbGwoMHhGRjAwMDApXHJcbiAgICAgICAgICAgICAgICAuZHJhd0NpcmNsZShyYWRpdXMgKyBibHVyU2l6ZSwgcmFkaXVzICsgYmx1clNpemUsIHJhZGl1cylcclxuICAgICAgICAgICAgICAgIC5lbmRGaWxsKCk7XHJcbiAgICAgICAgICAgIGNpcmNsZS5maWx0ZXJzID0gW25ldyBCbHVyRmlsdGVyXzEuQmx1ckZpbHRlcihibHVyU2l6ZSldO1xyXG4gICAgICAgICAgICBjb25zdCBib3VuZHMgPSBuZXcgUmVjdGFuZ2xlXzEuUmVjdGFuZ2xlKDAsIDAsIChyYWRpdXMgKyBibHVyU2l6ZSkgKiAyLCAocmFkaXVzICsgYmx1clNpemUpICogMik7XHJcbiAgICAgICAgICAgIGNvbnN0IHRleHR1cmUgPSB0aGlzLmFwcC5yZW5kZXJlci5nZW5lcmF0ZVRleHR1cmUoY2lyY2xlLCBXZWJHTFNldHRpbmdzXzEuV2ViR0xTZXR0aW5ncy5TQ0FMRV9NT0RFUy5ORUFSRVNULCAxLCBib3VuZHMpO1xyXG4gICAgICAgICAgICB0aGlzLmZvY3VzID0gbmV3IFNwcml0ZV8xLlNwcml0ZSh0ZXh0dXJlKTtcclxuICAgICAgICAgICAgdGhpcy5hcHAuc3RhZ2UuYWRkQ2hpbGQodGhpcy5mb2N1cyk7XHJcbiAgICAgICAgICAgIGJhY2tncm91bmQubWFzayA9IHRoaXMuZm9jdXM7XHJcbiAgICAgICAgICAgIHRoaXMuYXBwLnN0YWdlLmludGVyYWN0aXZlID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5hcHAuc3RhZ2UuYWRkRXZlbnRMaXN0ZW5lcihNb3VzZUV2ZW50XzEuTW91c2VFdmVudC5NT1VTRV9NT1ZFLCB0aGlzLnBvaW50ZXJNb3ZlKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMucG9pbnRlck1vdmUgPSAoZXZlbnQpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5mb2N1cy5wb3NpdGlvbi54ID0gZXZlbnQuZGF0YS5nbG9iYWwueCAtIHRoaXMuZm9jdXMud2lkdGggLyAyO1xyXG4gICAgICAgICAgICB0aGlzLmZvY3VzLnBvc2l0aW9uLnkgPSBldmVudC5kYXRhLmdsb2JhbC55IC0gdGhpcy5mb2N1cy5oZWlnaHQgLyAyO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5sb2FkZXIgPSBuZXcgUmVzb3VyY2VMb2FkZXJfMS5SZXNvdXJjZUxvYWRlcihuZXcgVVJMUmVxdWVzdF8xLlVSTFJlcXVlc3QoXCJleGFtcGxlcy9hc3NldHMvYmdfZ3Jhc3MuanBnXCIpKTtcclxuICAgICAgICB0aGlzLmxvYWRlci5hZGRFdmVudExpc3RlbmVyKEV2ZW50XzEuRXZlbnQuQ09NUExFVEUsIHRoaXMuaGFuZGxlUm90YXRlTG9hZGVkKTtcclxuICAgICAgICB0aGlzLmxvYWRlci5sb2FkKCk7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5NYXNrRmlsdGVyID0gTWFza0ZpbHRlcjtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgQmFzZUV4YW1wbGVfMSA9IHJlcXVpcmUoXCIuL0Jhc2VFeGFtcGxlXCIpO1xyXG5jb25zdCBUZXh0dXJlXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvVGV4dHVyZVwiKTtcclxuY29uc3QgQmFzZVRleHR1cmVfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9CYXNlVGV4dHVyZVwiKTtcclxuY29uc3QgRXZlbnRfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9FdmVudFwiKTtcclxuY29uc3QgUmVzb3VyY2VMb2FkZXJfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9SZXNvdXJjZUxvYWRlclwiKTtcclxuY29uc3QgVVJMUmVxdWVzdF8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1VSTFJlcXVlc3RcIik7XHJcbmNvbnN0IFBvaW50XzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvUG9pbnRcIik7XHJcbmNvbnN0IFNpbXBsZVJvcGVfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9TaW1wbGVSb3BlXCIpO1xyXG5jb25zdCBHcmFwaGljc18xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0dyYXBoaWNzXCIpO1xyXG5jbGFzcyBNZXNoQWR2YW5jZWQgZXh0ZW5kcyBCYXNlRXhhbXBsZV8xLkJhc2VFeGFtcGxlIHtcclxuICAgIGNvbnN0cnVjdG9yKGFwcCwgd2lkdGgsIGhlaWdodCkge1xyXG4gICAgICAgIHN1cGVyKGFwcCwgd2lkdGgsIGhlaWdodCk7XHJcbiAgICAgICAgdGhpcy5ydW5FeGFtcGxlID0gKGRlbHRhKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuY291bnQgKz0gMC4xO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucG9pbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBvaW50c1tpXS55ID0gTWF0aC5zaW4oKGkgKiAwLjUpICsgdGhpcy5jb3VudCkgKiAzMDtcclxuICAgICAgICAgICAgICAgIHRoaXMucG9pbnRzW2ldLnggPSBpICogdGhpcy5yb3BlTGVuZ3RoICsgTWF0aC5jb3MoKGkgKiAwLjMpICsgdGhpcy5jb3VudCkgKiAyMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnJlbmRlclBvaW50cygpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5oYW5kbGVQbGFuZUxvYWRlZCA9IChldmVudCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnBsYW5lVHh0ID0gbmV3IFRleHR1cmVfMS5UZXh0dXJlKG5ldyBCYXNlVGV4dHVyZV8xLkJhc2VUZXh0dXJlKHRoaXMubG9hZGVyLmltYWdlRGF0YSkpO1xyXG4gICAgICAgICAgICB0aGlzLmNvdW50ID0gMDtcclxuICAgICAgICAgICAgdGhpcy5yb3BlTGVuZ3RoID0gNDU7XHJcbiAgICAgICAgICAgIHRoaXMucG9pbnRzID0gW107XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMjU7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wb2ludHMucHVzaChuZXcgUG9pbnRfMS5Qb2ludChpICogdGhpcy5yb3BlTGVuZ3RoLCAwKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3Qgc3RyaXAgPSBuZXcgU2ltcGxlUm9wZV8xLlNpbXBsZVJvcGUodGhpcy5wbGFuZVR4dCwgdGhpcy5wb2ludHMpO1xyXG4gICAgICAgICAgICBzdHJpcC54ID0gLTQwO1xyXG4gICAgICAgICAgICBzdHJpcC55ID0gMzAwO1xyXG4gICAgICAgICAgICB0aGlzLmFwcC5zdGFnZS5hZGRDaGlsZChzdHJpcCk7XHJcbiAgICAgICAgICAgIHRoaXMuZyA9IG5ldyBHcmFwaGljc18xLkdyYXBoaWNzKCk7XHJcbiAgICAgICAgICAgIHRoaXMuZy54ID0gc3RyaXAueDtcclxuICAgICAgICAgICAgdGhpcy5nLnkgPSBzdHJpcC55O1xyXG4gICAgICAgICAgICB0aGlzLmFwcC5zdGFnZS5hZGRDaGlsZCh0aGlzLmcpO1xyXG4gICAgICAgICAgICB0aGlzLmFwcC50aWNrZXIuYWRkKHRoaXMucnVuRXhhbXBsZSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLmxvYWRlciA9IG5ldyBSZXNvdXJjZUxvYWRlcl8xLlJlc291cmNlTG9hZGVyKG5ldyBVUkxSZXF1ZXN0XzEuVVJMUmVxdWVzdChcImV4YW1wbGVzL2Fzc2V0cy9zbmFrZS5wbmdcIikpO1xyXG4gICAgICAgIHRoaXMubG9hZGVyLmFkZEV2ZW50TGlzdGVuZXIoRXZlbnRfMS5FdmVudC5DT01QTEVURSwgdGhpcy5oYW5kbGVQbGFuZUxvYWRlZCk7XHJcbiAgICAgICAgdGhpcy5sb2FkZXIubG9hZCgpO1xyXG4gICAgfVxyXG4gICAgcmVuZGVyUG9pbnRzKCkge1xyXG4gICAgICAgIHRoaXMuZy5jbGVhcigpO1xyXG4gICAgICAgIHRoaXMuZy5saW5lU3R5bGUoMiwgMHhmZmMyYzIpO1xyXG4gICAgICAgIHRoaXMuZy5tb3ZlVG8odGhpcy5wb2ludHNbMF0ueCwgdGhpcy5wb2ludHNbMF0ueSk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCB0aGlzLnBvaW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB0aGlzLmcubGluZVRvKHRoaXMucG9pbnRzW2ldLngsIHRoaXMucG9pbnRzW2ldLnkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHRoaXMucG9pbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZy5iZWdpbkZpbGwoMHhmZjAwMjIpO1xyXG4gICAgICAgICAgICB0aGlzLmcuZHJhd0NpcmNsZSh0aGlzLnBvaW50c1tpXS54LCB0aGlzLnBvaW50c1tpXS55LCAxMCk7XHJcbiAgICAgICAgICAgIHRoaXMuZy5lbmRGaWxsKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuTWVzaEFkdmFuY2VkID0gTWVzaEFkdmFuY2VkO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBCYXNlRXhhbXBsZV8xID0gcmVxdWlyZShcIi4vQmFzZUV4YW1wbGVcIik7XHJcbmNvbnN0IFJlc291cmNlTG9hZGVyXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvUmVzb3VyY2VMb2FkZXJcIik7XHJcbmNvbnN0IFRleHR1cmVfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9UZXh0dXJlXCIpO1xyXG5jb25zdCBVUkxSZXF1ZXN0XzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvVVJMUmVxdWVzdFwiKTtcclxuY29uc3QgRXZlbnRfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9FdmVudFwiKTtcclxuY29uc3QgQmFzZVRleHR1cmVfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9CYXNlVGV4dHVyZVwiKTtcclxuY29uc3QgUG9pbnRfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9Qb2ludFwiKTtcclxuY29uc3QgU2ltcGxlUm9wZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1NpbXBsZVJvcGVcIik7XHJcbmNvbnN0IENvbnRhaW5lcl8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0NvbnRhaW5lclwiKTtcclxuY2xhc3MgTWVzaEJhc2ljIGV4dGVuZHMgQmFzZUV4YW1wbGVfMS5CYXNlRXhhbXBsZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihhcHAsIHdpZHRoLCBoZWlnaHQpIHtcclxuICAgICAgICBzdXBlcihhcHAsIHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgICAgIHRoaXMucnVuRXhhbXBsZSA9IChkZWx0YSkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLmNvdW50ICs9IDAuMTtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnBvaW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wb2ludHNbaV0ueSA9IE1hdGguc2luKChpICogMC41KSArIHRoaXMuY291bnQpICogMzA7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBvaW50c1tpXS54ID0gaSAqIHRoaXMucm9wZUxlbmd0aCArIE1hdGguY29zKChpICogMC4zKSArIHRoaXMuY291bnQpICogMjA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuaGFuZGxlUGxhbmVMb2FkZWQgPSAoZXZlbnQpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5wbGFuZVR4dCA9IG5ldyBUZXh0dXJlXzEuVGV4dHVyZShuZXcgQmFzZVRleHR1cmVfMS5CYXNlVGV4dHVyZSh0aGlzLmxvYWRlci5pbWFnZURhdGEpKTtcclxuICAgICAgICAgICAgdGhpcy5jb3VudCA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMucm9wZUxlbmd0aCA9IDkxOCAvIDIwO1xyXG4gICAgICAgICAgICB0aGlzLnBvaW50cyA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDIwOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucG9pbnRzLnB1c2gobmV3IFBvaW50XzEuUG9pbnQoaSAqIHRoaXMucm9wZUxlbmd0aCwgMCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHN0cmlwID0gbmV3IFNpbXBsZVJvcGVfMS5TaW1wbGVSb3BlKHRoaXMucGxhbmVUeHQsIHRoaXMucG9pbnRzKTtcclxuICAgICAgICAgICAgc3RyaXAueCA9IC00NTk7XHJcbiAgICAgICAgICAgIGNvbnN0IHNuYWtlQ29udGFpbmVyID0gbmV3IENvbnRhaW5lcl8xLkNvbnRhaW5lcigpO1xyXG4gICAgICAgICAgICBzbmFrZUNvbnRhaW5lci54ID0gNDAwO1xyXG4gICAgICAgICAgICBzbmFrZUNvbnRhaW5lci55ID0gMzAwO1xyXG4gICAgICAgICAgICBzbmFrZUNvbnRhaW5lci5zY2FsZS5zZXQoODAwIC8gMTEwMCk7XHJcbiAgICAgICAgICAgIHRoaXMuYXBwLnN0YWdlLmFkZENoaWxkKHNuYWtlQ29udGFpbmVyKTtcclxuICAgICAgICAgICAgc25ha2VDb250YWluZXIuYWRkQ2hpbGQoc3RyaXApO1xyXG4gICAgICAgICAgICB0aGlzLmFwcC50aWNrZXIuYWRkKHRoaXMucnVuRXhhbXBsZSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLmxvYWRlciA9IG5ldyBSZXNvdXJjZUxvYWRlcl8xLlJlc291cmNlTG9hZGVyKG5ldyBVUkxSZXF1ZXN0XzEuVVJMUmVxdWVzdChcImV4YW1wbGVzL2Fzc2V0cy9zbmFrZS5wbmdcIikpO1xyXG4gICAgICAgIHRoaXMubG9hZGVyLmFkZEV2ZW50TGlzdGVuZXIoRXZlbnRfMS5FdmVudC5DT01QTEVURSwgdGhpcy5oYW5kbGVQbGFuZUxvYWRlZCk7XHJcbiAgICAgICAgdGhpcy5sb2FkZXIubG9hZCgpO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuTWVzaEJhc2ljID0gTWVzaEJhc2ljO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBCYXNlRXhhbXBsZV8xID0gcmVxdWlyZShcIi4vQmFzZUV4YW1wbGVcIik7XHJcbmNvbnN0IEdlb21ldHJ5XzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvR2VvbWV0cnlcIik7XHJcbmNvbnN0IFByb2dyYW1fMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9Qcm9ncmFtXCIpO1xyXG5jb25zdCBTaGFkZXJfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9TaGFkZXJcIik7XHJcbmNvbnN0IE1lc2hfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9NZXNoXCIpO1xyXG5jbGFzcyBNZXNoQ29sb3JlZFRyaWFuZ2xlIGV4dGVuZHMgQmFzZUV4YW1wbGVfMS5CYXNlRXhhbXBsZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihhcHAsIHdpZHRoLCBoZWlnaHQpIHtcclxuICAgICAgICBzdXBlcihhcHAsIHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgICAgIHRoaXMucnVuRXhhbXBsZSA9IChkZWx0YSkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnRyaWFuZ2xlLnJvdGF0aW9uICs9IDAuMDE7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCBnZW9tZXRyeSA9IG5ldyBHZW9tZXRyeV8xLkdlb21ldHJ5KCk7XHJcbiAgICAgICAgZ2VvbWV0cnkuYWRkQXR0cmlidXRlKCdhVmVydGV4UG9zaXRpb24nLCAvLyB0aGUgYXR0cmlidXRlIG5hbWVcclxuICAgICAgICBbLTEwMCwgLTUwLFxyXG4gICAgICAgICAgICAxMDAsIC01MCxcclxuICAgICAgICAgICAgMC4wLCAxMDAuMF0sIC8vIHgsIHlcclxuICAgICAgICAyKTsgLy8gdGhlIHNpemUgb2YgdGhlIGF0dHJpYnV0ZVxyXG4gICAgICAgIGdlb21ldHJ5LmFkZEF0dHJpYnV0ZSgnYUNvbG9yJywgLy8gdGhlIGF0dHJpYnV0ZSBuYW1lXHJcbiAgICAgICAgWzEsIDAsIDAsXHJcbiAgICAgICAgICAgIDAsIDEsIDAsXHJcbiAgICAgICAgICAgIDAsIDAsIDFdLCAvLyByLCBnLCBiXHJcbiAgICAgICAgMyk7IC8vIHRoZSBzaXplIG9mIHRoZSBhdHRyaWJ1dGVcclxuICAgICAgICBsZXQgdnggPSBgXHJcbiAgICAgICAgICAgIHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xyXG4gICAgICAgICAgICBhdHRyaWJ1dGUgdmVjMiBhVmVydGV4UG9zaXRpb247XHJcbiAgICAgICAgICAgIGF0dHJpYnV0ZSB2ZWMzIGFDb2xvcjsgICAgXHJcbiAgICAgICAgICAgIHVuaWZvcm0gbWF0MyB0cmFuc2xhdGlvbk1hdHJpeDtcclxuICAgICAgICAgICAgdW5pZm9ybSBtYXQzIHByb2plY3Rpb25NYXRyaXg7ICAgIFxyXG4gICAgICAgICAgICB2YXJ5aW5nIHZlYzMgdkNvbG9yOyAgICBcclxuICAgICAgICAgICAgdm9pZCBtYWluKCkgeyAgICBcclxuICAgICAgICAgICAgICAgIHZDb2xvciA9IGFDb2xvcjtcclxuICAgICAgICAgICAgICAgIGdsX1Bvc2l0aW9uID0gdmVjNCgocHJvamVjdGlvbk1hdHJpeCAqIHRyYW5zbGF0aW9uTWF0cml4ICogdmVjMyhhVmVydGV4UG9zaXRpb24sIDEuMCkpLnh5LCAwLjAsIDEuMCk7ICAgIFxyXG4gICAgICAgICAgICB9YDtcclxuICAgICAgICBsZXQgZnggPSBgcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XHJcbiAgICAgICAgICAgIHZhcnlpbmcgdmVjMyB2Q29sb3I7ICAgIFxyXG4gICAgICAgICAgICB2b2lkIG1haW4oKSB7XHJcbiAgICAgICAgICAgICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KHZDb2xvciwgMS4wKTtcclxuICAgICAgICAgICAgfSAgICBcclxuICAgICAgICAgICAgYDtcclxuICAgICAgICBsZXQgcHJvZ3JhbSA9IG5ldyBQcm9ncmFtXzEuUHJvZ3JhbSh2eCwgZngpO1xyXG4gICAgICAgIGNvbnN0IHNoYWRlciA9IG5ldyBTaGFkZXJfMS5TaGFkZXIocHJvZ3JhbSwgbnVsbCk7XHJcbiAgICAgICAgdGhpcy50cmlhbmdsZSA9IG5ldyBNZXNoXzEuTWVzaChnZW9tZXRyeSwgc2hhZGVyKTtcclxuICAgICAgICB0aGlzLnRyaWFuZ2xlLnBvc2l0aW9uLnNldCg0MDAsIDMwMCk7XHJcbiAgICAgICAgdGhpcy50cmlhbmdsZS5zY2FsZS5zZXQoMik7XHJcbiAgICAgICAgYXBwLnN0YWdlLmFkZENoaWxkKHRoaXMudHJpYW5nbGUpO1xyXG4gICAgICAgIHRoaXMuYXBwLnRpY2tlci5hZGQodGhpcy5ydW5FeGFtcGxlKTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLk1lc2hDb2xvcmVkVHJpYW5nbGUgPSBNZXNoQ29sb3JlZFRyaWFuZ2xlO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBCYXNlRXhhbXBsZV8xID0gcmVxdWlyZShcIi4vQmFzZUV4YW1wbGVcIik7XHJcbmNvbnN0IFJlc291cmNlTG9hZGVyXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvUmVzb3VyY2VMb2FkZXJcIik7XHJcbmNvbnN0IFRleHR1cmVfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9UZXh0dXJlXCIpO1xyXG5jb25zdCBVUkxSZXF1ZXN0XzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvVVJMUmVxdWVzdFwiKTtcclxuY29uc3QgRXZlbnRfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9FdmVudFwiKTtcclxuY29uc3QgQmFzZVRleHR1cmVfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9CYXNlVGV4dHVyZVwiKTtcclxuY29uc3QgR2VvbWV0cnlfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9HZW9tZXRyeVwiKTtcclxuY29uc3QgUHJvZ3JhbV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1Byb2dyYW1cIik7XHJcbmNvbnN0IE1lc2hfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9NZXNoXCIpO1xyXG5jb25zdCBTaGFkZXJfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9TaGFkZXJcIik7XHJcbmNsYXNzIE1lc2hHZW9tZXRyeSBleHRlbmRzIEJhc2VFeGFtcGxlXzEuQmFzZUV4YW1wbGUge1xyXG4gICAgY29uc3RydWN0b3IoYXBwLCB3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICAgICAgc3VwZXIoYXBwLCB3aWR0aCwgaGVpZ2h0KTtcclxuICAgICAgICB0aGlzLmhhbmRsZVR4dDNMb2FkZWQgPSAoZXZlbnQpID0+IHtcclxuICAgICAgICAgICAgdGhpcy50eHQzID0gbmV3IFRleHR1cmVfMS5UZXh0dXJlKG5ldyBCYXNlVGV4dHVyZV8xLkJhc2VUZXh0dXJlKHRoaXMubG9hZGVyLmltYWdlRGF0YSkpO1xyXG4gICAgICAgICAgICBjb25zdCBnZW9tZXRyeSA9IG5ldyBHZW9tZXRyeV8xLkdlb21ldHJ5KCk7XHJcbiAgICAgICAgICAgIGdlb21ldHJ5LmFkZEF0dHJpYnV0ZSgnYVZlcnRleFBvc2l0aW9uJywgLy8gdGhlIGF0dHJpYnV0ZSBuYW1lXHJcbiAgICAgICAgICAgIFstMTAwLCAtMTAwLFxyXG4gICAgICAgICAgICAgICAgMTAwLCAtMTAwLFxyXG4gICAgICAgICAgICAgICAgMTAwLCAxMDBdLCAvLyB4LCB5XHJcbiAgICAgICAgICAgIDIpOyAvLyB0aGUgc2l6ZSBvZiB0aGUgYXR0cmlidXRlICAgIFxyXG4gICAgICAgICAgICBnZW9tZXRyeS5hZGRBdHRyaWJ1dGUoJ2FVdnMnLCAvLyB0aGUgYXR0cmlidXRlIG5hbWVcclxuICAgICAgICAgICAgWzAsIDAsXHJcbiAgICAgICAgICAgICAgICAxLCAwLFxyXG4gICAgICAgICAgICAgICAgMSwgMV0sIC8vIHUsIHZcclxuICAgICAgICAgICAgMik7IC8vIHRoZSBzaXplIG9mIHRoZSBhdHRyaWJ1dGUgICAgXHJcbiAgICAgICAgICAgIGNvbnN0IHByb2dyYW0gPSBQcm9ncmFtXzEuUHJvZ3JhbS5mcm9tKGAgICAgXHJcbiAgICAgICAgICAgIHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0OyAgICBcclxuICAgICAgICAgICAgYXR0cmlidXRlIHZlYzIgYVZlcnRleFBvc2l0aW9uO1xyXG4gICAgICAgICAgICBhdHRyaWJ1dGUgdmVjMiBhVXZzOyAgICBcclxuICAgICAgICAgICAgdW5pZm9ybSBtYXQzIHRyYW5zbGF0aW9uTWF0cml4O1xyXG4gICAgICAgICAgICB1bmlmb3JtIG1hdDMgcHJvamVjdGlvbk1hdHJpeDsgICAgXHJcbiAgICAgICAgICAgIHZhcnlpbmcgdmVjMiB2VXZzOyAgICBcclxuICAgICAgICAgICAgdm9pZCBtYWluKCkgeyAgICBcclxuICAgICAgICAgICAgICAgIHZVdnMgPSBhVXZzO1xyXG4gICAgICAgICAgICAgICAgZ2xfUG9zaXRpb24gPSB2ZWM0KChwcm9qZWN0aW9uTWF0cml4ICogdHJhbnNsYXRpb25NYXRyaXggKiB2ZWMzKGFWZXJ0ZXhQb3NpdGlvbiwgMS4wKSkueHksIDAuMCwgMS4wKTsgICAgXHJcbiAgICAgICAgICAgIH1gLCBgcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7ICAgIFxyXG4gICAgICAgICAgICB2YXJ5aW5nIHZlYzIgdlV2czsgICAgXHJcbiAgICAgICAgICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyVGV4dHVyZTsgICAgXHJcbiAgICAgICAgICAgIHZvaWQgbWFpbigpIHsgICAgXHJcbiAgICAgICAgICAgICAgICBnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQodVNhbXBsZXJUZXh0dXJlLCB2VXZzKTtcclxuICAgICAgICAgICAgfSAgICBcclxuICAgICAgICBgKTtcclxuICAgICAgICAgICAgdGhpcy50cmlhbmdsZSA9IG5ldyBNZXNoXzEuTWVzaChnZW9tZXRyeSwgbmV3IFNoYWRlcl8xLlNoYWRlcihwcm9ncmFtLCB7XHJcbiAgICAgICAgICAgICAgICB1U2FtcGxlclRleHR1cmU6IHRoaXMudHh0MSxcclxuICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICB0aGlzLnRyaWFuZ2xlMiA9IG5ldyBNZXNoXzEuTWVzaChnZW9tZXRyeSwgbmV3IFNoYWRlcl8xLlNoYWRlcihwcm9ncmFtLCB7XHJcbiAgICAgICAgICAgICAgICB1U2FtcGxlclRleHR1cmU6IHRoaXMudHh0MixcclxuICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICB0aGlzLnRyaWFuZ2xlMyA9IG5ldyBNZXNoXzEuTWVzaChnZW9tZXRyeSwgbmV3IFNoYWRlcl8xLlNoYWRlcihwcm9ncmFtLCB7XHJcbiAgICAgICAgICAgICAgICB1U2FtcGxlclRleHR1cmU6IHRoaXMudHh0MyxcclxuICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICB0aGlzLnRyaWFuZ2xlLnBvc2l0aW9uLnNldCg0MDAsIDMwMCk7XHJcbiAgICAgICAgICAgIHRoaXMudHJpYW5nbGUuc2NhbGUuc2V0KDIpO1xyXG4gICAgICAgICAgICB0aGlzLnRyaWFuZ2xlMi5wb3NpdGlvbi5zZXQoMjAwLCAxMDApO1xyXG4gICAgICAgICAgICB0aGlzLnRyaWFuZ2xlMy5wb3NpdGlvbi5zZXQoNTAwLCA0MDApO1xyXG4gICAgICAgICAgICB0aGlzLnRyaWFuZ2xlMy5zY2FsZS5zZXQoMyk7XHJcbiAgICAgICAgICAgIHRoaXMuYXBwLnN0YWdlLmFkZENoaWxkKHRoaXMudHJpYW5nbGUzKTtcclxuICAgICAgICAgICAgdGhpcy5hcHAuc3RhZ2UuYWRkQ2hpbGQodGhpcy50cmlhbmdsZTIpO1xyXG4gICAgICAgICAgICB0aGlzLmFwcC5zdGFnZS5hZGRDaGlsZCh0aGlzLnRyaWFuZ2xlKTtcclxuICAgICAgICAgICAgdGhpcy5hcHAudGlja2VyLmFkZCh0aGlzLnJ1bkV4YW1wbGUpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5ydW5FeGFtcGxlID0gKGRlbHRhKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMudHJpYW5nbGUucm90YXRpb24gKz0gMC4wMTtcclxuICAgICAgICAgICAgdGhpcy50cmlhbmdsZTIucm90YXRpb24gLT0gMC4wMTtcclxuICAgICAgICAgICAgdGhpcy50cmlhbmdsZTMucm90YXRpb24gLT0gMC4wMDU7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLmhhbmRsZVR4dDJMb2FkZWQgPSAoZXZlbnQpID0+IHtcclxuICAgICAgICAgICAgdGhpcy50eHQyID0gbmV3IFRleHR1cmVfMS5UZXh0dXJlKG5ldyBCYXNlVGV4dHVyZV8xLkJhc2VUZXh0dXJlKHRoaXMubG9hZGVyLmltYWdlRGF0YSkpO1xyXG4gICAgICAgICAgICB0aGlzLmxvYWRlciA9IG5ldyBSZXNvdXJjZUxvYWRlcl8xLlJlc291cmNlTG9hZGVyKG5ldyBVUkxSZXF1ZXN0XzEuVVJMUmVxdWVzdChcImV4YW1wbGVzL2Fzc2V0cy9iZ19kaXNwbGFjZW1lbnQuanBnXCIpKTtcclxuICAgICAgICAgICAgdGhpcy5sb2FkZXIuYWRkRXZlbnRMaXN0ZW5lcihFdmVudF8xLkV2ZW50LkNPTVBMRVRFLCB0aGlzLmhhbmRsZVR4dDNMb2FkZWQpO1xyXG4gICAgICAgICAgICB0aGlzLmxvYWRlci5sb2FkKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLmhhbmRsZVR4dDFMb2FkZWQgPSAoZXZlbnQpID0+IHtcclxuICAgICAgICAgICAgdGhpcy50eHQxID0gbmV3IFRleHR1cmVfMS5UZXh0dXJlKG5ldyBCYXNlVGV4dHVyZV8xLkJhc2VUZXh0dXJlKHRoaXMubG9hZGVyLmltYWdlRGF0YSkpO1xyXG4gICAgICAgICAgICB0aGlzLmxvYWRlciA9IG5ldyBSZXNvdXJjZUxvYWRlcl8xLlJlc291cmNlTG9hZGVyKG5ldyBVUkxSZXF1ZXN0XzEuVVJMUmVxdWVzdChcImV4YW1wbGVzL2Fzc2V0cy9iZ19yb3RhdGUuanBnXCIpKTtcclxuICAgICAgICAgICAgdGhpcy5sb2FkZXIuYWRkRXZlbnRMaXN0ZW5lcihFdmVudF8xLkV2ZW50LkNPTVBMRVRFLCB0aGlzLmhhbmRsZVR4dDJMb2FkZWQpO1xyXG4gICAgICAgICAgICB0aGlzLmxvYWRlci5sb2FkKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLmxvYWRlciA9IG5ldyBSZXNvdXJjZUxvYWRlcl8xLlJlc291cmNlTG9hZGVyKG5ldyBVUkxSZXF1ZXN0XzEuVVJMUmVxdWVzdChcImV4YW1wbGVzL2Fzc2V0cy9iZ19zY2VuZV9yb3RhdGUuanBnXCIpKTtcclxuICAgICAgICB0aGlzLmxvYWRlci5hZGRFdmVudExpc3RlbmVyKEV2ZW50XzEuRXZlbnQuQ09NUExFVEUsIHRoaXMuaGFuZGxlVHh0MUxvYWRlZCk7XHJcbiAgICAgICAgdGhpcy5sb2FkZXIubG9hZCgpO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuTWVzaEdlb21ldHJ5ID0gTWVzaEdlb21ldHJ5O1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBCYXNlRXhhbXBsZV8xID0gcmVxdWlyZShcIi4vQmFzZUV4YW1wbGVcIik7XHJcbmNvbnN0IFJlc291cmNlTG9hZGVyXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvUmVzb3VyY2VMb2FkZXJcIik7XHJcbmNvbnN0IFRleHR1cmVfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9UZXh0dXJlXCIpO1xyXG5jb25zdCBVUkxSZXF1ZXN0XzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvVVJMUmVxdWVzdFwiKTtcclxuY29uc3QgRXZlbnRfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9FdmVudFwiKTtcclxuY29uc3QgQmFzZVRleHR1cmVfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9CYXNlVGV4dHVyZVwiKTtcclxuY29uc3QgR2VvbWV0cnlfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9HZW9tZXRyeVwiKTtcclxuY29uc3QgUHJvZ3JhbV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1Byb2dyYW1cIik7XHJcbmNvbnN0IFNoYWRlcl8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1NoYWRlclwiKTtcclxuY29uc3QgTWVzaF8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL01lc2hcIik7XHJcbmNsYXNzIE1lc2hTaGFkZXIgZXh0ZW5kcyBCYXNlRXhhbXBsZV8xLkJhc2VFeGFtcGxlIHtcclxuICAgIGNvbnN0cnVjdG9yKGFwcCwgd2lkdGgsIGhlaWdodCkge1xyXG4gICAgICAgIHN1cGVyKGFwcCwgd2lkdGgsIGhlaWdodCk7XHJcbiAgICAgICAgdGhpcy5oYW5kbGVUeHQxTG9hZGVkID0gKGV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMudHh0MSA9IG5ldyBUZXh0dXJlXzEuVGV4dHVyZShuZXcgQmFzZVRleHR1cmVfMS5CYXNlVGV4dHVyZSh0aGlzLmxvYWRlci5pbWFnZURhdGEpKTtcclxuICAgICAgICAgICAgY29uc3QgZ2VvbWV0cnkgPSBuZXcgR2VvbWV0cnlfMS5HZW9tZXRyeSgpO1xyXG4gICAgICAgICAgICBnZW9tZXRyeS5hZGRBdHRyaWJ1dGUoJ2FWZXJ0ZXhQb3NpdGlvbicsIC8vIHRoZSBhdHRyaWJ1dGUgbmFtZVxyXG4gICAgICAgICAgICBbLTEwMCwgLTEwMCxcclxuICAgICAgICAgICAgICAgIDEwMCwgLTEwMCxcclxuICAgICAgICAgICAgICAgIDEwMCwgMTAwXSk7IC8vIHgsIHlcclxuICAgICAgICAgICAgZ2VvbWV0cnkuYWRkQXR0cmlidXRlKCdhVXZzJywgLy8gdGhlIGF0dHJpYnV0ZSBuYW1lXHJcbiAgICAgICAgICAgIFswLCAwLFxyXG4gICAgICAgICAgICAgICAgMSwgMCxcclxuICAgICAgICAgICAgICAgIDEsIDFdKTsgLy8gdSwgdlxyXG4gICAgICAgICAgICBsZXQgdnggPSBgXHJcbiAgICAgICAgICAgIHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xyXG4gICAgICAgICAgICBhdHRyaWJ1dGUgdmVjMiBhVmVydGV4UG9zaXRpb247XHJcbiAgICAgICAgICAgIGF0dHJpYnV0ZSB2ZWMyIGFVdnM7XHJcbiAgICAgICAgICAgIHVuaWZvcm0gbWF0MyB0cmFuc2xhdGlvbk1hdHJpeDtcclxuICAgICAgICAgICAgdW5pZm9ybSBtYXQzIHByb2plY3Rpb25NYXRyaXg7XHJcbiAgICAgICAgICAgIHZhcnlpbmcgdmVjMiB2VXZzO1xyXG4gICAgICAgICAgICB2b2lkIG1haW4oKSB7XHJcbiAgICAgICAgICAgICAgICB2VXZzID0gYVV2cztcclxuICAgICAgICAgICAgICAgIGdsX1Bvc2l0aW9uID0gdmVjNCgocHJvamVjdGlvbk1hdHJpeCAqIHRyYW5zbGF0aW9uTWF0cml4ICogdmVjMyhhVmVydGV4UG9zaXRpb24sIDEuMCkpLnh5LCAwLjAsIDEuMCk7XHJcbiAgICAgICAgICAgIH1gO1xyXG4gICAgICAgICAgICBsZXQgZnggPSBgcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XHJcbiAgICAgICAgICAgIHZhcnlpbmcgdmVjMiB2VXZzO1xyXG4gICAgICAgICAgICB1bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjI7XHJcbiAgICAgICAgICAgIHZvaWQgbWFpbigpIHtcclxuICAgICAgICAgICAgICAgIGdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCh1U2FtcGxlcjIsIHZVdnMpO1xyXG4gICAgICAgICAgICB9ICAgICAgICBcclxuICAgICAgICAgICAgYDtcclxuICAgICAgICAgICAgbGV0IHByb2dyYW0gPSBuZXcgUHJvZ3JhbV8xLlByb2dyYW0odngsIGZ4KTtcclxuICAgICAgICAgICAgY29uc3Qgc2hhZGVyID0gbmV3IFNoYWRlcl8xLlNoYWRlcihwcm9ncmFtLCB7IHVTYW1wbGVyMjogdGhpcy50eHQxIH0pO1xyXG4gICAgICAgICAgICBsZXQgdngyID0gYFxyXG4gICAgICAgICAgICBwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDsgICAgXHJcbiAgICAgICAgICAgIGF0dHJpYnV0ZSB2ZWMyIGFWZXJ0ZXhQb3NpdGlvbjtcclxuICAgICAgICAgICAgYXR0cmlidXRlIHZlYzIgYVV2czsgICAgXHJcbiAgICAgICAgICAgIHVuaWZvcm0gbWF0MyB0cmFuc2xhdGlvbk1hdHJpeDtcclxuICAgICAgICAgICAgdW5pZm9ybSBtYXQzIHByb2plY3Rpb25NYXRyaXg7ICAgIFxyXG4gICAgICAgICAgICB2YXJ5aW5nIHZlYzIgdlV2czsgICAgXHJcbiAgICAgICAgICAgIHZvaWQgbWFpbigpIHsgICAgXHJcbiAgICAgICAgICAgICAgICB2VXZzID0gYVV2cztcclxuICAgICAgICAgICAgICAgIGdsX1Bvc2l0aW9uID0gdmVjNCgocHJvamVjdGlvbk1hdHJpeCAqIHRyYW5zbGF0aW9uTWF0cml4ICogdmVjMyhhVmVydGV4UG9zaXRpb24sIDEuMCkpLnh5LCAwLjAsIDEuMCk7ICAgIFxyXG4gICAgICAgICAgICB9YDtcclxuICAgICAgICAgICAgbGV0IGZ4MiA9IGBwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcclxuICAgICAgICAgICAgdmFyeWluZyB2ZWMyIHZVdnM7ICAgIFxyXG4gICAgICAgICAgICB1bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjI7ICAgIFxyXG4gICAgICAgICAgICB2b2lkIG1haW4oKSB7ICAgIFxyXG4gICAgICAgICAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKHVTYW1wbGVyMiwgdlV2cyk7XHJcbiAgICAgICAgICAgICAgICBnbF9GcmFnQ29sb3IuciArPSAoYWJzKHNpbihnbF9GcmFnQ29vcmQueCAqIDAuMDYpKSAqIDAuNSkgKiAyLjtcclxuICAgICAgICAgICAgICAgIGdsX0ZyYWdDb2xvci5nICs9IChhYnMoY29zKGdsX0ZyYWdDb29yZC55ICogMC4wNikpICogMC41KSAqIDIuO1xyXG4gICAgICAgICAgICB9ICAgIFxyXG4gICAgICAgICAgICBgO1xyXG4gICAgICAgICAgICBsZXQgcHJvZ3JhbTIgPSBuZXcgUHJvZ3JhbV8xLlByb2dyYW0odngyLCBmeDIpO1xyXG4gICAgICAgICAgICBjb25zdCBzaGFkZXIyID0gbmV3IFNoYWRlcl8xLlNoYWRlcihwcm9ncmFtMiwgeyB1U2FtcGxlcjI6IHRoaXMudHh0MSB9KTtcclxuICAgICAgICAgICAgdGhpcy50cmlhbmdsZSA9IG5ldyBNZXNoXzEuTWVzaChnZW9tZXRyeSwgc2hhZGVyKTtcclxuICAgICAgICAgICAgdGhpcy50cmlhbmdsZTIgPSBuZXcgTWVzaF8xLk1lc2goZ2VvbWV0cnksIHNoYWRlcjIpO1xyXG4gICAgICAgICAgICB0aGlzLnRyaWFuZ2xlLnBvc2l0aW9uLnNldCg0MDAsIDMwMCk7XHJcbiAgICAgICAgICAgIHRoaXMudHJpYW5nbGUuc2NhbGUuc2V0KDIpO1xyXG4gICAgICAgICAgICB0aGlzLnRyaWFuZ2xlMi5wb3NpdGlvbi5zZXQoNTAwLCA0MDApO1xyXG4gICAgICAgICAgICB0aGlzLnRyaWFuZ2xlMi5zY2FsZS5zZXQoMyk7XHJcbiAgICAgICAgICAgIHRoaXMuYXBwLnN0YWdlLmFkZENoaWxkKHRoaXMudHJpYW5nbGUyKTtcclxuICAgICAgICAgICAgdGhpcy5hcHAuc3RhZ2UuYWRkQ2hpbGQodGhpcy50cmlhbmdsZSk7XHJcbiAgICAgICAgICAgIHRoaXMuYXBwLnRpY2tlci5hZGQodGhpcy5ydW5FeGFtcGxlKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMucnVuRXhhbXBsZSA9IChkZWx0YSkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnRyaWFuZ2xlLnJvdGF0aW9uICs9IDAuMDE7XHJcbiAgICAgICAgICAgIHRoaXMudHJpYW5nbGUyLnJvdGF0aW9uIC09IDAuMDA1O1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5sb2FkZXIgPSBuZXcgUmVzb3VyY2VMb2FkZXJfMS5SZXNvdXJjZUxvYWRlcihuZXcgVVJMUmVxdWVzdF8xLlVSTFJlcXVlc3QoXCJleGFtcGxlcy9hc3NldHMvYmdfc2NlbmVfcm90YXRlLmpwZ1wiKSk7XHJcbiAgICAgICAgdGhpcy5sb2FkZXIuYWRkRXZlbnRMaXN0ZW5lcihFdmVudF8xLkV2ZW50LkNPTVBMRVRFLCB0aGlzLmhhbmRsZVR4dDFMb2FkZWQpO1xyXG4gICAgICAgIHRoaXMubG9hZGVyLmxvYWQoKTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLk1lc2hTaGFkZXIgPSBNZXNoU2hhZGVyO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBCYXNlRXhhbXBsZV8xID0gcmVxdWlyZShcIi4vQmFzZUV4YW1wbGVcIik7XHJcbmNvbnN0IFJlc291cmNlTG9hZGVyXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvUmVzb3VyY2VMb2FkZXJcIik7XHJcbmNvbnN0IFRleHR1cmVfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9UZXh0dXJlXCIpO1xyXG5jb25zdCBVUkxSZXF1ZXN0XzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvVVJMUmVxdWVzdFwiKTtcclxuY29uc3QgRXZlbnRfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9FdmVudFwiKTtcclxuY29uc3QgQmFzZVRleHR1cmVfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9CYXNlVGV4dHVyZVwiKTtcclxuY29uc3QgR2VvbWV0cnlfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9HZW9tZXRyeVwiKTtcclxuY29uc3QgUHJvZ3JhbV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1Byb2dyYW1cIik7XHJcbmNvbnN0IFNoYWRlcl8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1NoYWRlclwiKTtcclxuY29uc3QgTWVzaF8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL01lc2hcIik7XHJcbmNsYXNzIE1lc2hUZXh0dXJlZCBleHRlbmRzIEJhc2VFeGFtcGxlXzEuQmFzZUV4YW1wbGUge1xyXG4gICAgY29uc3RydWN0b3IoYXBwLCB3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICAgICAgc3VwZXIoYXBwLCB3aWR0aCwgaGVpZ2h0KTtcclxuICAgICAgICB0aGlzLmhhbmRsZVBsYW5lTG9hZGVkID0gKGV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMucGxhbmVUeHQgPSBuZXcgVGV4dHVyZV8xLlRleHR1cmUobmV3IEJhc2VUZXh0dXJlXzEuQmFzZVRleHR1cmUodGhpcy5sb2FkZXIuaW1hZ2VEYXRhKSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGdlb21ldHJ5ID0gbmV3IEdlb21ldHJ5XzEuR2VvbWV0cnkoKTtcclxuICAgICAgICAgICAgZ2VvbWV0cnkuYWRkQXR0cmlidXRlKCdhVmVydGV4UG9zaXRpb24nLCAvLyB0aGUgYXR0cmlidXRlIG5hbWVcclxuICAgICAgICAgICAgWy0xMDAsIC0xMDAsXHJcbiAgICAgICAgICAgICAgICAxMDAsIC0xMDAsXHJcbiAgICAgICAgICAgICAgICAxMDAsIDEwMF0sIC8vIHgsIHlcclxuICAgICAgICAgICAgMik7IC8vIHRoZSBzaXplIG9mIHRoZSBhdHRyaWJ1dGVcclxuICAgICAgICAgICAgZ2VvbWV0cnkuYWRkQXR0cmlidXRlKCdhQ29sb3InLCAvLyB0aGUgYXR0cmlidXRlIG5hbWVcclxuICAgICAgICAgICAgWzEsIDAsIDAsXHJcbiAgICAgICAgICAgICAgICAwLCAxLCAwLFxyXG4gICAgICAgICAgICAgICAgMCwgMCwgMV0sIC8vIHIsIGcsIGJcclxuICAgICAgICAgICAgMyk7IC8vIHRoZSBzaXplIG9mIHRoZSBhdHRyaWJ1dGVcclxuICAgICAgICAgICAgZ2VvbWV0cnkuYWRkQXR0cmlidXRlKCdhVXZzJywgLy8gdGhlIGF0dHJpYnV0ZSBuYW1lXHJcbiAgICAgICAgICAgIFswLCAwLFxyXG4gICAgICAgICAgICAgICAgMSwgMCxcclxuICAgICAgICAgICAgICAgIDEsIDFdLCAvLyB1LCB2XHJcbiAgICAgICAgICAgIDIpOyAvLyB0aGUgc2l6ZSBvZiB0aGUgYXR0cmlidXRlXHJcbiAgICAgICAgICAgIGNvbnN0IHZlcnRleFNyYyA9IGBcclxuICAgICAgICAgICAgcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XHJcbiAgICAgICAgICAgIGF0dHJpYnV0ZSB2ZWMyIGFWZXJ0ZXhQb3NpdGlvbjtcclxuICAgICAgICAgICAgYXR0cmlidXRlIHZlYzMgYUNvbG9yO1xyXG4gICAgICAgICAgICBhdHRyaWJ1dGUgdmVjMiBhVXZzO1xyXG4gICAgICAgICAgICB1bmlmb3JtIG1hdDMgdHJhbnNsYXRpb25NYXRyaXg7XHJcbiAgICAgICAgICAgIHVuaWZvcm0gbWF0MyBwcm9qZWN0aW9uTWF0cml4O1xyXG4gICAgICAgICAgICB2YXJ5aW5nIHZlYzIgdlV2cztcclxuICAgICAgICAgICAgdmFyeWluZyB2ZWMzIHZDb2xvcjtcclxuICAgICAgICAgICAgdm9pZCBtYWluKCkge1xyXG4gICAgICAgICAgICAgICAgdlV2cyA9IGFVdnM7XHJcbiAgICAgICAgICAgICAgICB2Q29sb3IgPSBhQ29sb3I7XHJcbiAgICAgICAgICAgICAgICBnbF9Qb3NpdGlvbiA9IHZlYzQoKHByb2plY3Rpb25NYXRyaXggKiB0cmFuc2xhdGlvbk1hdHJpeCAqIHZlYzMoYVZlcnRleFBvc2l0aW9uLCAxLjApKS54eSwgMC4wLCAxLjApO1xyXG4gICAgICAgICAgICB9YDtcclxuICAgICAgICAgICAgY29uc3QgZnJhZ21lbnRTcmMgPSBgXHJcbiAgICAgICAgICAgIHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xyXG4gICAgICAgICAgICB2YXJ5aW5nIHZlYzMgdkNvbG9yO1xyXG4gICAgICAgICAgICB2YXJ5aW5nIHZlYzIgdlV2cztcclxuICAgICAgICAgICAgdW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXIyO1xyXG4gICAgICAgICAgICB2b2lkIG1haW4oKSB7XHJcbiAgICAgICAgICAgICAgICBnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQodVNhbXBsZXIyLCB2VXZzKSAqIHZlYzQodkNvbG9yLCAxLjApO1xyXG4gICAgICAgICAgICB9YDtcclxuICAgICAgICAgICAgY29uc3QgdW5pZm9ybXMgPSB7IHVTYW1wbGVyMjogdGhpcy5wbGFuZVR4dCB9O1xyXG4gICAgICAgICAgICBsZXQgcHJvZ3JhbSA9IG5ldyBQcm9ncmFtXzEuUHJvZ3JhbSh2ZXJ0ZXhTcmMsIGZyYWdtZW50U3JjKTtcclxuICAgICAgICAgICAgY29uc3Qgc2hhZGVyID0gbmV3IFNoYWRlcl8xLlNoYWRlcihwcm9ncmFtLCB1bmlmb3Jtcyk7XHJcbiAgICAgICAgICAgIHRoaXMudHJpYW5nbGUgPSBuZXcgTWVzaF8xLk1lc2goZ2VvbWV0cnksIHNoYWRlcik7XHJcbiAgICAgICAgICAgIHRoaXMudHJpYW5nbGUucG9zaXRpb24uc2V0KDQwMCwgMzAwKTtcclxuICAgICAgICAgICAgdGhpcy50cmlhbmdsZS5zY2FsZS5zZXQoMik7XHJcbiAgICAgICAgICAgIHRoaXMuYXBwLnN0YWdlLmFkZENoaWxkKHRoaXMudHJpYW5nbGUpO1xyXG4gICAgICAgICAgICB0aGlzLmFwcC50aWNrZXIuYWRkKHRoaXMucnVuRXhhbXBsZSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLnJ1bkV4YW1wbGUgPSAoZGVsdGEpID0+IHtcclxuICAgICAgICAgICAgdGhpcy50cmlhbmdsZS5yb3RhdGlvbiArPSAwLjAxO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5sb2FkZXIgPSBuZXcgUmVzb3VyY2VMb2FkZXJfMS5SZXNvdXJjZUxvYWRlcihuZXcgVVJMUmVxdWVzdF8xLlVSTFJlcXVlc3QoXCJleGFtcGxlcy9hc3NldHMvYmdfc2NlbmVfcm90YXRlLmpwZ1wiKSk7XHJcbiAgICAgICAgdGhpcy5sb2FkZXIuYWRkRXZlbnRMaXN0ZW5lcihFdmVudF8xLkV2ZW50LkNPTVBMRVRFLCB0aGlzLmhhbmRsZVBsYW5lTG9hZGVkKTtcclxuICAgICAgICB0aGlzLmxvYWRlci5sb2FkKCk7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5NZXNoVGV4dHVyZWQgPSBNZXNoVGV4dHVyZWQ7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IEJhc2VFeGFtcGxlXzEgPSByZXF1aXJlKFwiLi9CYXNlRXhhbXBsZVwiKTtcclxuY29uc3QgR2VvbWV0cnlfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9HZW9tZXRyeVwiKTtcclxuY29uc3QgU2hhZGVyXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvU2hhZGVyXCIpO1xyXG5jb25zdCBQcm9ncmFtXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvUHJvZ3JhbVwiKTtcclxuY29uc3QgTWVzaF8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL01lc2hcIik7XHJcbmNsYXNzIE1lc2hUcmlhbmdsZSBleHRlbmRzIEJhc2VFeGFtcGxlXzEuQmFzZUV4YW1wbGUge1xyXG4gICAgY29uc3RydWN0b3IoYXBwLCB3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICAgICAgc3VwZXIoYXBwLCB3aWR0aCwgaGVpZ2h0KTtcclxuICAgICAgICB0aGlzLnJ1bkV4YW1wbGUgPSAoZGVsdGEpID0+IHtcclxuICAgICAgICAgICAgdGhpcy50cmlhbmdsZS5yb3RhdGlvbiArPSAwLjAxO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgY29uc3QgZ2VvbWV0cnkgPSBuZXcgR2VvbWV0cnlfMS5HZW9tZXRyeSgpO1xyXG4gICAgICAgIGdlb21ldHJ5LmFkZEF0dHJpYnV0ZSgnYVZlcnRleFBvc2l0aW9uJywgWy0xMDAsIC01MCwgMTAwLCAtNTAsIDAsIDEwMF0pO1xyXG4gICAgICAgIGxldCB2eCA9IGBcclxuICAgICAgICAgICAgcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XHJcbiAgICAgICAgICAgIGF0dHJpYnV0ZSB2ZWMyIGFWZXJ0ZXhQb3NpdGlvbjtcclxuICAgICAgICAgICAgdW5pZm9ybSBtYXQzIHRyYW5zbGF0aW9uTWF0cml4O1xyXG4gICAgICAgICAgICB1bmlmb3JtIG1hdDMgcHJvamVjdGlvbk1hdHJpeDtcclxuICAgICAgICAgICAgdm9pZCBtYWluKCkge1xyXG4gICAgICAgICAgICAgICAgZ2xfUG9zaXRpb24gPSB2ZWM0KChwcm9qZWN0aW9uTWF0cml4ICogdHJhbnNsYXRpb25NYXRyaXggKiB2ZWMzKGFWZXJ0ZXhQb3NpdGlvbiwgMS4wKSkueHksIDAuMCwgMS4wKTtcclxuICAgICAgICAgICAgfWA7XHJcbiAgICAgICAgbGV0IGZ4ID0gYHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xyXG4gICAgICAgICAgICB2b2lkIG1haW4oKSB7XHJcbiAgICAgICAgICAgICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KDEuMCwgMC4wLCAwLjAsIDEuMCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICBgO1xyXG4gICAgICAgIGxldCBwcm9ncmFtID0gbmV3IFByb2dyYW1fMS5Qcm9ncmFtKHZ4LCBmeCk7XHJcbiAgICAgICAgY29uc3Qgc2hhZGVyID0gbmV3IFNoYWRlcl8xLlNoYWRlcihwcm9ncmFtLCBudWxsKTtcclxuICAgICAgICB0aGlzLnRyaWFuZ2xlID0gbmV3IE1lc2hfMS5NZXNoKGdlb21ldHJ5LCBzaGFkZXIpO1xyXG4gICAgICAgIHRoaXMudHJpYW5nbGUucG9zaXRpb24uc2V0KDQwMCwgMzAwKTtcclxuICAgICAgICBhcHAuc3RhZ2UuYWRkQ2hpbGQodGhpcy50cmlhbmdsZSk7XHJcbiAgICAgICAgdGhpcy5hcHAudGlja2VyLmFkZCh0aGlzLnJ1bkV4YW1wbGUpO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuTWVzaFRyaWFuZ2xlID0gTWVzaFRyaWFuZ2xlO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBCYXNlRXhhbXBsZV8xID0gcmVxdWlyZShcIi4vQmFzZUV4YW1wbGVcIik7XHJcbmNvbnN0IE1lc2hfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9NZXNoXCIpO1xyXG5jb25zdCBSZXNvdXJjZUxvYWRlcl8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1Jlc291cmNlTG9hZGVyXCIpO1xyXG5jb25zdCBUZXh0dXJlXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvVGV4dHVyZVwiKTtcclxuY29uc3QgVVJMUmVxdWVzdF8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1VSTFJlcXVlc3RcIik7XHJcbmNvbnN0IEV2ZW50XzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvRXZlbnRcIik7XHJcbmNvbnN0IEJhc2VUZXh0dXJlXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvQmFzZVRleHR1cmVcIik7XHJcbmNvbnN0IEdlb21ldHJ5XzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvR2VvbWV0cnlcIik7XHJcbmNvbnN0IFByb2dyYW1fMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9Qcm9ncmFtXCIpO1xyXG5jb25zdCBTaGFkZXJfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9TaGFkZXJcIik7XHJcbmNsYXNzIE1lc2hVbmlmb3JtcyBleHRlbmRzIEJhc2VFeGFtcGxlXzEuQmFzZUV4YW1wbGUge1xyXG4gICAgY29uc3RydWN0b3IoYXBwLCB3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICAgICAgc3VwZXIoYXBwLCB3aWR0aCwgaGVpZ2h0KTtcclxuICAgICAgICB0aGlzLmhhbmRsZVBsYW5lTG9hZGVkID0gKGV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMucGxhbmVUeHQgPSBuZXcgVGV4dHVyZV8xLlRleHR1cmUobmV3IEJhc2VUZXh0dXJlXzEuQmFzZVRleHR1cmUodGhpcy5sb2FkZXIuaW1hZ2VEYXRhKSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGdlb21ldHJ5ID0gbmV3IEdlb21ldHJ5XzEuR2VvbWV0cnkoKTtcclxuICAgICAgICAgICAgZ2VvbWV0cnkuYWRkQXR0cmlidXRlKCdhVmVydGV4UG9zaXRpb24nLCAvLyB0aGUgYXR0cmlidXRlIG5hbWVcclxuICAgICAgICAgICAgWy0xMDAsIC0xMDAsXHJcbiAgICAgICAgICAgICAgICAxMDAsIC0xMDAsXHJcbiAgICAgICAgICAgICAgICAxMDAsIDEwMCxcclxuICAgICAgICAgICAgICAgIC0xMDAsIDEwMF0sIC8vIHgsIHlcclxuICAgICAgICAgICAgMik7IC8vIHRoZSBzaXplIG9mIHRoZSBhdHRyaWJ1dGVcclxuICAgICAgICAgICAgZ2VvbWV0cnkuYWRkQXR0cmlidXRlKCdhVXZzJywgLy8gdGhlIGF0dHJpYnV0ZSBuYW1lXHJcbiAgICAgICAgICAgIFswLCAwLFxyXG4gICAgICAgICAgICAgICAgMSwgMCxcclxuICAgICAgICAgICAgICAgIDEsIDEsXHJcbiAgICAgICAgICAgICAgICAwLCAxXSwgLy8gdSwgdlxyXG4gICAgICAgICAgICAyKTsgLy8gdGhlIHNpemUgb2YgdGhlIGF0dHJpYnV0ZVxyXG4gICAgICAgICAgICBnZW9tZXRyeS5hZGRJbmRleChbMCwgMSwgMiwgMCwgMiwgM10pO1xyXG4gICAgICAgICAgICBjb25zdCB2ZXJ0ZXhTcmMgPSBgXHJcbiAgICAgICAgICAgIHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0OyAgICBcclxuICAgICAgICAgICAgYXR0cmlidXRlIHZlYzIgYVZlcnRleFBvc2l0aW9uO1xyXG4gICAgICAgICAgICBhdHRyaWJ1dGUgdmVjMiBhVXZzOyAgICBcclxuICAgICAgICAgICAgdW5pZm9ybSBtYXQzIHRyYW5zbGF0aW9uTWF0cml4O1xyXG4gICAgICAgICAgICB1bmlmb3JtIG1hdDMgcHJvamVjdGlvbk1hdHJpeDsgICAgXHJcbiAgICAgICAgICAgIHZhcnlpbmcgdmVjMiB2VXZzOyAgICBcclxuICAgICAgICAgICAgdm9pZCBtYWluKCkgeyAgICBcclxuICAgICAgICAgICAgICAgIHZVdnMgPSBhVXZzO1xyXG4gICAgICAgICAgICAgICAgZ2xfUG9zaXRpb24gPSB2ZWM0KChwcm9qZWN0aW9uTWF0cml4ICogdHJhbnNsYXRpb25NYXRyaXggKiB2ZWMzKGFWZXJ0ZXhQb3NpdGlvbiwgMS4wKSkueHksIDAuMCwgMS4wKTsgICAgXHJcbiAgICAgICAgICAgIH1gO1xyXG4gICAgICAgICAgICBjb25zdCBmcmFnbWVudFNyYyA9IGAgICAgXHJcbiAgICAgICAgICAgIHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0OyAgICBcclxuICAgICAgICAgICAgdmFyeWluZyB2ZWMyIHZVdnM7ICAgIFxyXG4gICAgICAgICAgICB1bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjI7XHJcbiAgICAgICAgICAgIHVuaWZvcm0gZmxvYXQgdGltZTsgICAgXHJcbiAgICAgICAgICAgIHZvaWQgbWFpbigpIHsgICAgXHJcbiAgICAgICAgICAgICAgICBnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQodVNhbXBsZXIyLCB2VXZzICsgc2luKCAodGltZSArICh2VXZzLngpICogMTQuKSApICogMC4xICk7XHJcbiAgICAgICAgICAgIH1gO1xyXG4gICAgICAgICAgICBjb25zdCB1bmlmb3JtcyA9IHtcclxuICAgICAgICAgICAgICAgIHVTYW1wbGVyMjogdGhpcy5wbGFuZVR4dCxcclxuICAgICAgICAgICAgICAgIHRpbWU6IDAsXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGxldCBwcm9ncmFtID0gbmV3IFByb2dyYW1fMS5Qcm9ncmFtKHZlcnRleFNyYywgZnJhZ21lbnRTcmMpO1xyXG4gICAgICAgICAgICBjb25zdCBzaGFkZXIgPSBuZXcgU2hhZGVyXzEuU2hhZGVyKHByb2dyYW0sIHVuaWZvcm1zKTtcclxuICAgICAgICAgICAgdGhpcy50cmlhbmdsZSA9IG5ldyBNZXNoXzEuTWVzaChnZW9tZXRyeSwgc2hhZGVyKTtcclxuICAgICAgICAgICAgdGhpcy50cmlhbmdsZS5wb3NpdGlvbi5zZXQoNDAwLCAzMDApO1xyXG4gICAgICAgICAgICB0aGlzLnRyaWFuZ2xlLnNjYWxlLnNldCgyKTtcclxuICAgICAgICAgICAgdGhpcy5hcHAuc3RhZ2UuYWRkQ2hpbGQodGhpcy50cmlhbmdsZSk7XHJcbiAgICAgICAgICAgIHRoaXMuYXBwLnRpY2tlci5hZGQodGhpcy5ydW5FeGFtcGxlKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMucnVuRXhhbXBsZSA9IChkZWx0YSkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnRyaWFuZ2xlLnJvdGF0aW9uICs9IDAuMDE7XHJcbiAgICAgICAgICAgIHRoaXMudHJpYW5nbGUuc2hhZGVyLnVuaWZvcm1zLnRpbWUgKz0gMC4xO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5sb2FkZXIgPSBuZXcgUmVzb3VyY2VMb2FkZXJfMS5SZXNvdXJjZUxvYWRlcihuZXcgVVJMUmVxdWVzdF8xLlVSTFJlcXVlc3QoXCJleGFtcGxlcy9hc3NldHMvYmdfc2NlbmVfcm90YXRlLmpwZ1wiKSk7XHJcbiAgICAgICAgdGhpcy5sb2FkZXIuYWRkRXZlbnRMaXN0ZW5lcihFdmVudF8xLkV2ZW50LkNPTVBMRVRFLCB0aGlzLmhhbmRsZVBsYW5lTG9hZGVkKTtcclxuICAgICAgICB0aGlzLmxvYWRlci5sb2FkKCk7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5NZXNoVW5pZm9ybXMgPSBNZXNoVW5pZm9ybXM7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IEJhc2VFeGFtcGxlXzEgPSByZXF1aXJlKFwiLi9CYXNlRXhhbXBsZVwiKTtcclxuY29uc3QgUmVzb3VyY2VMb2FkZXJfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9SZXNvdXJjZUxvYWRlclwiKTtcclxuY29uc3QgVVJMUmVxdWVzdF8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1VSTFJlcXVlc3RcIik7XHJcbmNvbnN0IEV2ZW50XzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvRXZlbnRcIik7XHJcbmNvbnN0IFRleHR1cmVfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9UZXh0dXJlXCIpO1xyXG5jb25zdCBCYXNlVGV4dHVyZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0Jhc2VUZXh0dXJlXCIpO1xyXG5jb25zdCBTcHJpdGVfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9TcHJpdGVcIik7XHJcbmNsYXNzIFNwcml0ZUJhc2ljIGV4dGVuZHMgQmFzZUV4YW1wbGVfMS5CYXNlRXhhbXBsZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihhcHAsIHdpZHRoID0gMTAwLCBoZWlnaHQgPSAxMDApIHtcclxuICAgICAgICBzdXBlcihhcHAsIHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgICAgIHRoaXMuaGFuZGxlUm90YXRlTG9hZGVkID0gKGV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgIGxldCB0ZXh0dXJlID0gbmV3IFRleHR1cmVfMS5UZXh0dXJlKG5ldyBCYXNlVGV4dHVyZV8xLkJhc2VUZXh0dXJlKHRoaXMubG9hZGVyLmltYWdlRGF0YSkpO1xyXG4gICAgICAgICAgICB0aGlzLmJ1bm55ID0gbmV3IFNwcml0ZV8xLlNwcml0ZSh0ZXh0dXJlKTtcclxuICAgICAgICAgICAgdGhpcy5idW5ueS5hbmNob3Iuc2V0KDAuNSk7XHJcbiAgICAgICAgICAgIHRoaXMuYnVubnkueCA9IHRoaXMuc2l6ZXcgLyAyO1xyXG4gICAgICAgICAgICB0aGlzLmJ1bm55LnkgPSB0aGlzLnNpemVoIC8gMjtcclxuICAgICAgICAgICAgdGhpcy5zdGFnZS5hZGRDaGlsZCh0aGlzLmJ1bm55KTtcclxuICAgICAgICAgICAgdGhpcy5hcHAudGlja2VyLmFkZCh0aGlzLnJ1bkV4YW1wbGUpO1xyXG4gICAgICAgICAgICB0aGlzLmV4YW1wbGVSZWFkeSgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5ydW5FeGFtcGxlID0gKGRlbHRhKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuYnVubnkucm90YXRpb24gKz0gMC4xICogZGVsdGE7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLmJhY2tDb2xvciA9IDB4RkZGMDAwO1xyXG4gICAgICAgIHRoaXMubG9hZGVyID0gbmV3IFJlc291cmNlTG9hZGVyXzEuUmVzb3VyY2VMb2FkZXIobmV3IFVSTFJlcXVlc3RfMS5VUkxSZXF1ZXN0KFwiZXhhbXBsZXMvYXNzZXRzL2J1bm55LnBuZ1wiKSk7XHJcbiAgICAgICAgdGhpcy5sb2FkZXIuYWRkRXZlbnRMaXN0ZW5lcihFdmVudF8xLkV2ZW50LkNPTVBMRVRFLCB0aGlzLmhhbmRsZVJvdGF0ZUxvYWRlZCk7XHJcbiAgICAgICAgdGhpcy5sb2FkZXIubG9hZCgpO1xyXG4gICAgfVxyXG4gICAgZGVzdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlci5kZXN0cnVjdG9yKCk7XHJcbiAgICAgICAgdGhpcy5hcHAudGlja2VyLnJlbW92ZSh0aGlzLnJ1bkV4YW1wbGUsIG51bGwpO1xyXG4gICAgICAgIHRoaXMuYnVubnkuZGVzdHJveShudWxsKTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLlNwcml0ZUJhc2ljID0gU3ByaXRlQmFzaWM7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IEJhc2VFeGFtcGxlXzEgPSByZXF1aXJlKFwiLi9CYXNlRXhhbXBsZVwiKTtcclxuY29uc3QgUmVzb3VyY2VfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9SZXNvdXJjZVwiKTtcclxuY29uc3QgQmFzZVRleHR1cmVfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9CYXNlVGV4dHVyZVwiKTtcclxuY29uc3QgVGV4dHVyZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1RleHR1cmVcIik7XHJcbmNvbnN0IFNwcml0ZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1Nwcml0ZVwiKTtcclxuY2xhc3MgVGV4dHVyZUdyYWRpZW50UmVzb3VyY2UgZXh0ZW5kcyBCYXNlRXhhbXBsZV8xLkJhc2VFeGFtcGxlIHtcclxuICAgIGNvbnN0cnVjdG9yKGFwcCwgd2lkdGgsIGhlaWdodCkge1xyXG4gICAgICAgIHN1cGVyKGFwcCwgd2lkdGgsIGhlaWdodCk7XHJcbiAgICAgICAgY29uc3QgZ3JhZEJhc2VUZXh0dXJlID0gbmV3IEJhc2VUZXh0dXJlXzEuQmFzZVRleHR1cmUobmV3IEdyYWRpZW50UmVzb3VyY2UoKSk7XHJcbiAgICAgICAgZ3JhZEJhc2VUZXh0dXJlLnNldFNpemUoNTAwLCA1MCk7XHJcbiAgICAgICAgY29uc3QgZ3JhZFRleHR1cmUgPSBuZXcgVGV4dHVyZV8xLlRleHR1cmUoZ3JhZEJhc2VUZXh0dXJlKTtcclxuICAgICAgICBjb25zdCBzcHJpdGUgPSBuZXcgU3ByaXRlXzEuU3ByaXRlKGdyYWRUZXh0dXJlKTtcclxuICAgICAgICBzcHJpdGUucG9zaXRpb24uc2V0KDEwMCwgMTAwKTtcclxuICAgICAgICBzcHJpdGUucm90YXRpb24gPSBNYXRoLlBJIC8gODtcclxuICAgICAgICB0aGlzLnN0YWdlLmFkZENoaWxkKHNwcml0ZSk7XHJcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuZXhhbXBsZVJlYWR5KCk7XHJcbiAgICAgICAgfSwgMTAwMCk7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5UZXh0dXJlR3JhZGllbnRSZXNvdXJjZSA9IFRleHR1cmVHcmFkaWVudFJlc291cmNlO1xyXG5jbGFzcyBHcmFkaWVudFJlc291cmNlIGV4dGVuZHMgUmVzb3VyY2VfMS5SZXNvdXJjZSB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlcigyNTYsIDEwMCk7XHJcbiAgICAgICAgdGhpcy5jYW5VcGxvYWQgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgdXBsb2FkKHJlbmRlcmVyLCBiYXNlVGV4dHVyZSwgZ2xUZXh0dXJlKSB7XHJcbiAgICAgICAgY29uc3QgeyB3aWR0aCB9ID0gdGhpczsgLy8gZGVmYXVsdCBzaXplIG9yIGZyb20gYmFzZVRleHR1cmU/XHJcbiAgICAgICAgY29uc3QgeyBoZWlnaHQgfSA9IHRoaXM7IC8vIHlvdXIgY2hvaWNlLlxyXG4gICAgICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xyXG4gICAgICAgIHRoaXMuc291cmNlID0gY2FudmFzO1xyXG4gICAgICAgIHRoaXMuc291cmNlLndpZHRoID0gd2lkdGg7XHJcbiAgICAgICAgdGhpcy5zb3VyY2UuaGVpZ2h0ID0gaGVpZ2h0O1xyXG4gICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuc291cmNlLmdldENvbnRleHQoJzJkJyk7XHJcbiAgICAgICAgY29uc3QgZ3JkID0gY3R4LmNyZWF0ZUxpbmVhckdyYWRpZW50KDAsIDAsIHdpZHRoLCAwKTtcclxuICAgICAgICBncmQuYWRkQ29sb3JTdG9wKDAsICdyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMCknKTtcclxuICAgICAgICBncmQuYWRkQ29sb3JTdG9wKDAuMywgJ2N5YW4nKTtcclxuICAgICAgICBncmQuYWRkQ29sb3JTdG9wKDAuNywgJ3JlZCcpO1xyXG4gICAgICAgIGdyZC5hZGRDb2xvclN0b3AoMSwgJ2dyZWVuJyk7XHJcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGdyZDtcclxuICAgICAgICBjdHguZmlsbFJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XHJcbiAgICAgICAgZ2xUZXh0dXJlLndpZHRoID0gd2lkdGg7XHJcbiAgICAgICAgZ2xUZXh0dXJlLmhlaWdodCA9IGhlaWdodDtcclxuICAgICAgICBjb25zdCB7IGdsIH0gPSByZW5kZXJlcjtcclxuICAgICAgICBnbC5waXhlbFN0b3JlaShnbC5VTlBBQ0tfUFJFTVVMVElQTFlfQUxQSEFfV0VCR0wsIGJhc2VUZXh0dXJlLnByZW11bHRpcGx5QWxwaGEpO1xyXG4gICAgICAgIGdsLnRleEltYWdlMkQoYmFzZVRleHR1cmUudGFyZ2V0LCAwLCBiYXNlVGV4dHVyZS5mb3JtYXQsIGJhc2VUZXh0dXJlLmZvcm1hdCwgYmFzZVRleHR1cmUudHlwZSwgdGhpcy5zb3VyY2UpO1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG59XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IEJhc2VFeGFtcGxlXzEgPSByZXF1aXJlKFwiLi9CYXNlRXhhbXBsZVwiKTtcclxuY29uc3QgUmVzb3VyY2VMb2FkZXJfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9SZXNvdXJjZUxvYWRlclwiKTtcclxuY29uc3QgVVJMUmVxdWVzdF8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1VSTFJlcXVlc3RcIik7XHJcbmNvbnN0IEV2ZW50XzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvRXZlbnRcIik7XHJcbmNvbnN0IFRleHR1cmVfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9UZXh0dXJlXCIpO1xyXG5jb25zdCBCYXNlVGV4dHVyZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0Jhc2VUZXh0dXJlXCIpO1xyXG5jb25zdCBDb250YWluZXJfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9Db250YWluZXJcIik7XHJcbmNvbnN0IFNwcml0ZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1Nwcml0ZVwiKTtcclxuY29uc3QgV2ViR0xTZXR0aW5nc18xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1dlYkdMU2V0dGluZ3NcIik7XHJcbmNvbnN0IEJhc2VSZW5kZXJUZXh0dXJlXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvQmFzZVJlbmRlclRleHR1cmVcIik7XHJcbmNvbnN0IFJlbmRlclRleHR1cmVfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9SZW5kZXJUZXh0dXJlXCIpO1xyXG5jbGFzcyBUZXh0dXJlUmVuZGVyIGV4dGVuZHMgQmFzZUV4YW1wbGVfMS5CYXNlRXhhbXBsZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihhcHAsIHdpZHRoLCBoZWlnaHQpIHtcclxuICAgICAgICBzdXBlcihhcHAsIHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgICAgIHRoaXMuaGFuZGxlUmVzb3VyY2VMb2FkZWQgPSAoZXZlbnQpID0+IHtcclxuICAgICAgICAgICAgbGV0IHR4dCA9IG5ldyBUZXh0dXJlXzEuVGV4dHVyZShuZXcgQmFzZVRleHR1cmVfMS5CYXNlVGV4dHVyZSh0aGlzLmxvYWRlci5pbWFnZURhdGEpKTtcclxuICAgICAgICAgICAgdGhpcy5jb250YWluZXIgPSBuZXcgQ29udGFpbmVyXzEuQ29udGFpbmVyKCk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhZ2UuYWRkQ2hpbGQodGhpcy5jb250YWluZXIpO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDI1OyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGJ1bm55ID0gbmV3IFNwcml0ZV8xLlNwcml0ZSh0eHQpO1xyXG4gICAgICAgICAgICAgICAgYnVubnkueCA9IChpICUgNSkgKiAzMDtcclxuICAgICAgICAgICAgICAgIGJ1bm55LnkgPSBNYXRoLmZsb29yKGkgLyA1KSAqIDMwO1xyXG4gICAgICAgICAgICAgICAgYnVubnkucm90YXRpb24gPSBNYXRoLnJhbmRvbSgpICogKE1hdGguUEkgKiAyKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLmFkZENoaWxkKGJ1bm55KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBicnQgPSBuZXcgQmFzZVJlbmRlclRleHR1cmVfMS5CYXNlUmVuZGVyVGV4dHVyZSgzMDAsIDMwMCwgV2ViR0xTZXR0aW5nc18xLldlYkdMU2V0dGluZ3MuU0NBTEVfTU9ERVMuTElORUFSLCAxKTtcclxuICAgICAgICAgICAgdGhpcy5ydCA9IG5ldyBSZW5kZXJUZXh0dXJlXzEuUmVuZGVyVGV4dHVyZShicnQpO1xyXG4gICAgICAgICAgICBjb25zdCBzcHJpdGUgPSBuZXcgU3ByaXRlXzEuU3ByaXRlKHRoaXMucnQpO1xyXG4gICAgICAgICAgICBzcHJpdGUueCA9IDQ1MDtcclxuICAgICAgICAgICAgc3ByaXRlLnkgPSA2MDtcclxuICAgICAgICAgICAgdGhpcy5zdGFnZS5hZGRDaGlsZChzcHJpdGUpO1xyXG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lci54ID0gMTAwO1xyXG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lci55ID0gNjA7XHJcbiAgICAgICAgICAgIHRoaXMuYXBwLnRpY2tlci5hZGQodGhpcy5ydW5FeGFtcGxlKTtcclxuICAgICAgICAgICAgdGhpcy5leGFtcGxlUmVhZHkoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMucnVuRXhhbXBsZSA9IChkZWx0YSkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLmFwcC5yZW5kZXJlci5yZW5kZXIodGhpcy5jb250YWluZXIsIHRoaXMucnQpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5sb2FkZXIgPSBuZXcgUmVzb3VyY2VMb2FkZXJfMS5SZXNvdXJjZUxvYWRlcihuZXcgVVJMUmVxdWVzdF8xLlVSTFJlcXVlc3QoXCJleGFtcGxlcy9hc3NldHMvYnVubnkucG5nXCIpKTtcclxuICAgICAgICB0aGlzLmxvYWRlci5hZGRFdmVudExpc3RlbmVyKEV2ZW50XzEuRXZlbnQuQ09NUExFVEUsIHRoaXMuaGFuZGxlUmVzb3VyY2VMb2FkZWQpO1xyXG4gICAgICAgIHRoaXMubG9hZGVyLmxvYWQoKTtcclxuICAgIH1cclxuICAgIGRlc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIuZGVzdHJ1Y3RvcigpO1xyXG4gICAgICAgIHRoaXMuYXBwLnRpY2tlci5yZW1vdmUodGhpcy5ydW5FeGFtcGxlLCBudWxsKTtcclxuICAgICAgICB0aGlzLmNvbnRhaW5lci5kZXN0cm95KG51bGwpO1xyXG4gICAgICAgIHRoaXMuY29udGFpbmVyID0gbnVsbDtcclxuICAgICAgICB0aGlzLnJ0LmRlc3Ryb3kobnVsbCk7XHJcbiAgICAgICAgdGhpcy5ydCA9IG51bGw7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5UZXh0dXJlUmVuZGVyID0gVGV4dHVyZVJlbmRlcjtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgQmFzZUV4YW1wbGVfMSA9IHJlcXVpcmUoXCIuL0Jhc2VFeGFtcGxlXCIpO1xyXG5jb25zdCBSZXNvdXJjZUxvYWRlcl8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1Jlc291cmNlTG9hZGVyXCIpO1xyXG5jb25zdCBVUkxSZXF1ZXN0XzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvVVJMUmVxdWVzdFwiKTtcclxuY29uc3QgRXZlbnRfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9FdmVudFwiKTtcclxuY29uc3QgVGV4dHVyZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1RleHR1cmVcIik7XHJcbmNvbnN0IEJhc2VUZXh0dXJlXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvQmFzZVRleHR1cmVcIik7XHJcbmNvbnN0IEdyb3VwRDhfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9Hcm91cEQ4XCIpO1xyXG5jb25zdCBSZWN0YW5nbGVfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9SZWN0YW5nbGVcIik7XHJcbmNvbnN0IFNwcml0ZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1Nwcml0ZVwiKTtcclxuY29uc3QgVGV4dF8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1RleHRcIik7XHJcbmNsYXNzIFRleHR1cmVSb3RhdGUgZXh0ZW5kcyBCYXNlRXhhbXBsZV8xLkJhc2VFeGFtcGxlIHtcclxuICAgIGNvbnN0cnVjdG9yKGFwcCwgd2lkdGgsIGhlaWdodCkge1xyXG4gICAgICAgIHN1cGVyKGFwcCwgd2lkdGgsIGhlaWdodCk7XHJcbiAgICAgICAgdGhpcy5oYW5kbGVSZXNvdXJjZUxvYWRlZCA9IChldmVudCkgPT4ge1xyXG4gICAgICAgICAgICBsZXQgdHh0ID0gbmV3IFRleHR1cmVfMS5UZXh0dXJlKG5ldyBCYXNlVGV4dHVyZV8xLkJhc2VUZXh0dXJlKHRoaXMubG9hZGVyLmltYWdlRGF0YSkpO1xyXG4gICAgICAgICAgICBjb25zdCB0ZXh0dXJlcyA9IFt0eHRdO1xyXG4gICAgICAgICAgICBjb25zdCBEOCA9IEdyb3VwRDhfMS5Hcm91cEQ4O1xyXG4gICAgICAgICAgICBmb3IgKGxldCByb3RhdGUgPSAxOyByb3RhdGUgPCAxNjsgcm90YXRlKyspIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGggPSBEOC5pc1ZlcnRpY2FsKHJvdGF0ZSkgPyB0eHQuZnJhbWUud2lkdGggOiB0eHQuZnJhbWUuaGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdyA9IEQ4LmlzVmVydGljYWwocm90YXRlKSA/IHR4dC5mcmFtZS5oZWlnaHQgOiB0eHQuZnJhbWUud2lkdGg7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB7IGZyYW1lIH0gPSB0eHQ7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjcm9wID0gbmV3IFJlY3RhbmdsZV8xLlJlY3RhbmdsZSh0eHQuZnJhbWUueCwgdHh0LmZyYW1lLnksIHcsIGgpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdHJpbSA9IGNyb3A7XHJcbiAgICAgICAgICAgICAgICBsZXQgcm90YXRlZFRleHR1cmU7XHJcbiAgICAgICAgICAgICAgICBpZiAocm90YXRlICUgMiA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJvdGF0ZWRUZXh0dXJlID0gbmV3IFRleHR1cmVfMS5UZXh0dXJlKHR4dC5iYXNlVGV4dHVyZSwgZnJhbWUsIGNyb3AsIHRyaW0sIHJvdGF0ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByb3RhdGVkVGV4dHVyZSA9IG5ldyBUZXh0dXJlXzEuVGV4dHVyZSh0eHQuYmFzZVRleHR1cmUsIGZyYW1lLCBjcm9wLCB0cmltLCByb3RhdGUgLSAxKTtcclxuICAgICAgICAgICAgICAgICAgICByb3RhdGVkVGV4dHVyZS5yb3RhdGUrKztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRleHR1cmVzLnB1c2gocm90YXRlZFRleHR1cmUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IG9mZnNldFggPSB0aGlzLnNpemV3IC8gMTYgfCAwO1xyXG4gICAgICAgICAgICBjb25zdCBvZmZzZXRZID0gdGhpcy5zaXplaCAvIDggfCAwO1xyXG4gICAgICAgICAgICBjb25zdCBncmlkVyA9IHRoaXMuc2l6ZXcgLyA0IHwgMDtcclxuICAgICAgICAgICAgY29uc3QgZ3JpZEggPSB0aGlzLnNpemVoIC8gNSB8IDA7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZHVkZSA9IG5ldyBTcHJpdGVfMS5TcHJpdGUodGV4dHVyZXNbaSA8IDggPyBpICogMiA6IChpIC0gOCkgKiAyICsgMV0pO1xyXG4gICAgICAgICAgICAgICAgZHVkZS5zY2FsZS54ID0gMC41O1xyXG4gICAgICAgICAgICAgICAgZHVkZS5zY2FsZS55ID0gMC41O1xyXG4gICAgICAgICAgICAgICAgZHVkZS54ID0gb2Zmc2V0WCArIGdyaWRXICogKGkgJSA0KTtcclxuICAgICAgICAgICAgICAgIGR1ZGUueSA9IG9mZnNldFkgKyBncmlkSCAqIChpIC8gNCB8IDApO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGFnZS5hZGRDaGlsZChkdWRlKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHRleHQgPSBuZXcgVGV4dF8xLlRleHQoYHJvdGF0ZSA9ICR7ZHVkZS50ZXh0dXJlLnJvdGF0ZX1gLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9udEZhbWlseTogJ0NvdXJpZXIgTmV3JywgZm9udFNpemU6ICcxMnB4JywgZmlsbDogJ3doaXRlJywgYWxpZ246ICdsZWZ0JyxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgdGV4dC54ID0gZHVkZS54O1xyXG4gICAgICAgICAgICAgICAgdGV4dC55ID0gZHVkZS55IC0gMjA7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0YWdlLmFkZENoaWxkKHRleHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuZXhhbXBsZVJlYWR5KCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLmxvYWRlciA9IG5ldyBSZXNvdXJjZUxvYWRlcl8xLlJlc291cmNlTG9hZGVyKG5ldyBVUkxSZXF1ZXN0XzEuVVJMUmVxdWVzdChcImV4YW1wbGVzL2Fzc2V0cy9mbG93ZXJUb3AucG5nXCIpKTtcclxuICAgICAgICB0aGlzLmxvYWRlci5hZGRFdmVudExpc3RlbmVyKEV2ZW50XzEuRXZlbnQuQ09NUExFVEUsIHRoaXMuaGFuZGxlUmVzb3VyY2VMb2FkZWQpO1xyXG4gICAgICAgIHRoaXMubG9hZGVyLmxvYWQoKTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLlRleHR1cmVSb3RhdGUgPSBUZXh0dXJlUm90YXRlO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBDb250YWluZXJfMSA9IHJlcXVpcmUoXCIuLi8uLi9yYXctcGl4aS10cy9Db250YWluZXJcIik7XHJcbmNvbnN0IEdyYXBoaWNzXzEgPSByZXF1aXJlKFwiLi4vLi4vcmF3LXBpeGktdHMvR3JhcGhpY3NcIik7XHJcbmNvbnN0IEV4YW1wbGVMaXN0XzEgPSByZXF1aXJlKFwiLi9FeGFtcGxlTGlzdFwiKTtcclxuY29uc3QgVGV4dHVyZVJvdGF0ZV8xID0gcmVxdWlyZShcIi4uL1RleHR1cmVSb3RhdGVcIik7XHJcbmNvbnN0IFRleHR1cmVSZW5kZXJfMSA9IHJlcXVpcmUoXCIuLi9UZXh0dXJlUmVuZGVyXCIpO1xyXG5jb25zdCBUZXh0dXJlR3JhZGllbnRSZXNvdXJjZV8xID0gcmVxdWlyZShcIi4uL1RleHR1cmVHcmFkaWVudFJlc291cmNlXCIpO1xyXG5jb25zdCBGaWx0ZXJCbHVyXzEgPSByZXF1aXJlKFwiLi4vRmlsdGVyQmx1clwiKTtcclxuY29uc3QgRmlsdGVyQ29sb3JfMSA9IHJlcXVpcmUoXCIuLi9GaWx0ZXJDb2xvclwiKTtcclxuY29uc3QgRmlsdGVyQ3Jhd2xpZXNfMSA9IHJlcXVpcmUoXCIuLi9GaWx0ZXJDcmF3bGllc1wiKTtcclxuY29uc3QgRmlsdGVyRmxhZ18xID0gcmVxdWlyZShcIi4uL0ZpbHRlckZsYWdcIik7XHJcbmNvbnN0IE1hc2tGaWx0ZXJfMSA9IHJlcXVpcmUoXCIuLi9NYXNrRmlsdGVyXCIpO1xyXG5jb25zdCBTcHJpdGVCYXNpY18xID0gcmVxdWlyZShcIi4uL1Nwcml0ZUJhc2ljXCIpO1xyXG5jb25zdCBGaWx0ZXJCbGVuZGluZ18xID0gcmVxdWlyZShcIi4uL0ZpbHRlckJsZW5kaW5nXCIpO1xyXG5jb25zdCBGaWx0ZXJDdXN0b21fMSA9IHJlcXVpcmUoXCIuLi9GaWx0ZXJDdXN0b21cIik7XHJcbmNvbnN0IEZpbHRlclNoYWRvd18xID0gcmVxdWlyZShcIi4uL0ZpbHRlclNoYWRvd1wiKTtcclxuY29uc3QgTWVzaEJhc2ljXzEgPSByZXF1aXJlKFwiLi4vTWVzaEJhc2ljXCIpO1xyXG5jb25zdCBNZXNoQWR2YW5jZWRfMSA9IHJlcXVpcmUoXCIuLi9NZXNoQWR2YW5jZWRcIik7XHJcbmNvbnN0IE1lc2hUcmlhbmdsZV8xID0gcmVxdWlyZShcIi4uL01lc2hUcmlhbmdsZVwiKTtcclxuY29uc3QgTWVzaENvbG9yZWRUcmlhbmdsZV8xID0gcmVxdWlyZShcIi4uL01lc2hDb2xvcmVkVHJpYW5nbGVcIik7XHJcbmNvbnN0IE1lc2hUZXh0dXJlZF8xID0gcmVxdWlyZShcIi4uL01lc2hUZXh0dXJlZFwiKTtcclxuY29uc3QgTWVzaFVuaWZvcm1zXzEgPSByZXF1aXJlKFwiLi4vTWVzaFVuaWZvcm1zXCIpO1xyXG5jb25zdCBNZXNoR2VvbWV0cnlfMSA9IHJlcXVpcmUoXCIuLi9NZXNoR2VvbWV0cnlcIik7XHJcbmNvbnN0IE1lc2hTaGFkZXJfMSA9IHJlcXVpcmUoXCIuLi9NZXNoU2hhZGVyXCIpO1xyXG5jb25zdCBFdmVudF8xID0gcmVxdWlyZShcIi4uLy4uL3Jhdy1waXhpLXRzL0V2ZW50XCIpO1xyXG5jbGFzcyBFeGFtcGxlRGlzcGxheSBleHRlbmRzIENvbnRhaW5lcl8xLkNvbnRhaW5lciB7XHJcbiAgICBjb25zdHJ1Y3RvcihhcHAsIGRpc3BsYXlXaWR0aCwgZGlzcGxheWhlaWdodCkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5oYW5kbGVFeGFtcGxlUmVxdWVzdCA9IChldmVudCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnNldEV4YW1wbGUodGhpcy5saXN0LnNlbGVjdGVkQ2xhc3MpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5oYW5kbGVDb21wbGV0ZSA9IChldmVudCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLmxpc3QuYWRkRXZlbnRMaXN0ZW5lcihFdmVudF8xLkV2ZW50LkNIQU5HRSwgdGhpcy5oYW5kbGVFeGFtcGxlUmVxdWVzdCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBsZXQgY29udHJvbFNpemUgPSAyMDA7XHJcbiAgICAgICAgdGhpcy5hcHAgPSBhcHA7XHJcbiAgICAgICAgdGhpcy5iYWNrZ3JvdW5kID0gbmV3IEdyYXBoaWNzXzEuR3JhcGhpY3MoKTtcclxuICAgICAgICB0aGlzLnJlZnJlc2hCYWNrZ3JvdW5kKDB4OTY5Njk2KTtcclxuICAgICAgICBhcHAuc3RhZ2UuYWRkQ2hpbGQodGhpcy5iYWNrZ3JvdW5kKTtcclxuICAgICAgICB0aGlzLnN0YWdlTGF5ZXIgPSBuZXcgQ29udGFpbmVyXzEuQ29udGFpbmVyKCk7XHJcbiAgICAgICAgYXBwLnN0YWdlLmFkZENoaWxkKHRoaXMuc3RhZ2VMYXllcik7XHJcbiAgICAgICAgdGhpcy5saXN0ID0gbmV3IEV4YW1wbGVMaXN0XzEuRXhhbXBsZUxpc3QoY29udHJvbFNpemUsIGRpc3BsYXloZWlnaHQpO1xyXG4gICAgICAgIHRoaXMubGlzdC54ID0gZGlzcGxheVdpZHRoIC0gY29udHJvbFNpemU7XHJcbiAgICAgICAgZGlzcGxheVdpZHRoID0gZGlzcGxheVdpZHRoIC0gY29udHJvbFNpemU7XHJcbiAgICAgICAgYXBwLnN0YWdlLmFkZENoaWxkKHRoaXMubGlzdCk7XHJcbiAgICAgICAgdGhpcy5jb250cm9sTGF5ZXIgPSBuZXcgQ29udGFpbmVyXzEuQ29udGFpbmVyKCk7XHJcbiAgICAgICAgYXBwLnN0YWdlLmFkZENoaWxkKHRoaXMuY29udHJvbExheWVyKTtcclxuICAgICAgICB0aGlzLmZyYW1lc2l6ZSA9IDU7XHJcbiAgICAgICAgdGhpcy5leGFtcGxlV2lkdGggPSBkaXNwbGF5V2lkdGg7IC8vKGRpc3BsYXlXaWR0aCAtIGNvbnRyb2xTaXplKSAtICh0aGlzLmZyYW1lc2l6ZSAvIDIpXHJcbiAgICAgICAgdGhpcy5leGFtcGxlaGVpZ2h0ID0gZGlzcGxheWhlaWdodCAtICh0aGlzLmZyYW1lc2l6ZSAvIDIpO1xyXG4gICAgICAgIHRoaXMuZnJhbWUgPSBuZXcgR3JhcGhpY3NfMS5HcmFwaGljcygpO1xyXG4gICAgICAgIHRoaXMuZnJhbWUuYmVnaW5GaWxsKDB4MDAwRkZGKTtcclxuICAgICAgICB0aGlzLmZyYW1lLmRyYXdSZWN0KDAsIDAsIHRoaXMuZnJhbWVzaXplLCBkaXNwbGF5aGVpZ2h0KTtcclxuICAgICAgICB0aGlzLmZyYW1lLmRyYXdSZWN0KGRpc3BsYXlXaWR0aCAtIHRoaXMuZnJhbWVzaXplLCAwLCA1LCBkaXNwbGF5aGVpZ2h0KTtcclxuICAgICAgICB0aGlzLmZyYW1lLmRyYXdSZWN0KHRoaXMuZnJhbWVzaXplLCAwLCBkaXNwbGF5V2lkdGggLSAodGhpcy5mcmFtZXNpemUgKiAyKSwgdGhpcy5mcmFtZXNpemUpO1xyXG4gICAgICAgIHRoaXMuZnJhbWUuZHJhd1JlY3QodGhpcy5mcmFtZXNpemUsIGRpc3BsYXloZWlnaHQgLSB0aGlzLmZyYW1lc2l6ZSwgZGlzcGxheVdpZHRoIC0gKHRoaXMuZnJhbWVzaXplICogMiksIHRoaXMuZnJhbWVzaXplKTtcclxuICAgICAgICB0aGlzLmNvbnRyb2xMYXllci5hZGRDaGlsZCh0aGlzLmZyYW1lKTtcclxuICAgICAgICAvLyB0aGlzLmxpc3QuYWRkRXhhbXBsZShcIlNwcml0ZSBCYXNpY1wiLCBTcHJpdGVCYXNpYyk7XHJcbiAgICAgICAgLy8gdGhpcy5saXN0LmFkZEV4YW1wbGUoXCJTcHJpdGUgUmV2ZWFsXCIsIEFkdmFuY2VkQ2FyZCk7XHJcbiAgICAgICAgLy8gdGhpcy5saXN0LmFkZEV4YW1wbGUoXCJTcHJpdGUgU2xvdHNcIiwgQWR2YW5jZWRTbG90cyk7XHJcbiAgICAgICAgLy8gdGhpcy5saXN0LmFkZEV4YW1wbGUoXCJTcHJpdGUgVHJhaWxcIiwgQWR2YW5jZWRUcmFpbCk7XHJcbiAgICAgICAgLy8gdGhpcy5saXN0LmFkZEV4YW1wbGUoXCJTcHJpdGUgV2FycFwiLCBBZHZhbmNlZFdhcnApOyAgXHJcbiAgICAgICAgLy8gdGhpcy5saXN0LmFkZEV4YW1wbGUoXCJTcHJpdGUgQmxlbmRcIiwgQmFzaWNCbGVuZCk7XHJcbiAgICAgICAgLy8gdGhpcy5saXN0LmFkZEV4YW1wbGUoXCJTcHJpdGUgVGludGluZ1wiLCBCYXNpY1RpbnRpbmcpO1xyXG4gICAgICAgIC8vIHRoaXMubGlzdC5hZGRFeGFtcGxlKFwiU3ByaXRlIFZpZGVvXCIsIFNwcml0ZVZpZGVvKTtcclxuICAgICAgICAvLyB0aGlzLmxpc3QuYWRkRXhhbXBsZShcIlNwcml0ZSBUaWxpbmdcIiwgU3ByaXRlVGlsaW5nKTtcclxuICAgICAgICAvLyB0aGlzLmxpc3QuYWRkRXhhbXBsZShcIlNwcml0ZSBBbmltYXRpb25cIiwgU3ByaXRlRXhwbG9zaW9uKTtcclxuICAgICAgICAvLyB0aGlzLmxpc3QuYWRkRXhhbXBsZShcIlNwcml0ZSBBbmltYXRpb24gMlwiLCBTcHJpdGVqZXQpO1xyXG4gICAgICAgIC8vIHRoaXMubGlzdC5hZGRFeGFtcGxlKFwiU3ByaXRlIEFuaW1hdGlvbiAzXCIsIFNwcml0ZVNwZWVkKTtcclxuICAgICAgICAvLyB0aGlzLmxpc3QuYWRkRXhhbXBsZShcIkdyYXBoaWNzIEJhc2ljXCIsIEdyYXBoaWNzU2ltcGxlKTtcclxuICAgICAgICAvLyB0aGlzLmxpc3QuYWRkRXhhbXBsZShcIkdyYXBoaWNzIEFkdmFuY2VkXCIsIEdyYXBoaWNzQWR2YW5jZWQpO1xyXG4gICAgICAgIC8vIHRoaXMubGlzdC5hZGRFeGFtcGxlKFwiR3JhcGhpY3MgRHluYW1pY1wiLCBHcmFwaGljc0R5bmFtaWMpO1xyXG4gICAgICAgIC8vIHRoaXMubGlzdC5hZGRFeGFtcGxlKFwiQ29udGFpbmVyXCIsIEJhc2ljQ29udGFpbmVyKTtcclxuICAgICAgICAvLyB0aGlzLmxpc3QuYWRkRXhhbXBsZShcIk1hc2sgR3JhcGhpY3NcIiwgTWFza0dyYXBoaWNzKTtcclxuICAgICAgICAvLyB0aGlzLmxpc3QuYWRkRXhhbXBsZShcIk1hc2sgU3ByaXRlXCIsIE1hc2tTcHJpdGUpO1xyXG4gICAgICAgIC8vIHRoaXMubGlzdC5hZGRFeGFtcGxlKFwiUGFydGljbGVzXCIsIEJhc2ljUGFydGljbGVzKTtcclxuICAgICAgICAvLyB0aGlzLmxpc3QuYWRkRXhhbXBsZShcIlRleHRcIiwgVGV4dEJhc2UpO1xyXG4gICAgICAgIC8vIHRoaXMubGlzdC5hZGRFeGFtcGxlKFwiVGV4dCBCaXRtYXBcIiwgVGV4dEJpdG1hcCk7XHJcbiAgICAgICAgLy8gdGhpcy5saXN0LmFkZEV4YW1wbGUoXCJUZXh0IFdlYkZvbnRcIiwgVGV4dFdlYkZvbnQpO1xyXG4gICAgICAgIC8vIHRoaXMubGlzdC5hZGRFeGFtcGxlKFwiSW50ZXJhY3Rpb25cIiwgSW50ZXJhY3Rpb25JbnRlcmFjdGl2aXR5KTtcclxuICAgICAgICAvLyB0aGlzLmxpc3QuYWRkRXhhbXBsZShcIkludGVyYWN0aW9uIENsaWNrXCIsIEludGVyYWN0aW9uQ2xpY2spOyAgXHJcbiAgICAgICAgLy8gdGhpcy5saXN0LmFkZEV4YW1wbGUoXCJJbnRlcmFjdGlvbiBEcmFnXCIsIEludGVyYWN0aW9uRHJhZ2dpbmcpO1xyXG4gICAgICAgIC8vIHRoaXMubGlzdC5hZGRFeGFtcGxlKFwiSW50ZXJhY3Rpb24gSWNvblwiLCBJbnRlcmFjdGlvbkljb24pOyAgICBcclxuICAgICAgICAvLyB0aGlzLmxpc3QuYWRkRXhhbXBsZShcInRleHR1cmUgU3dhcFwiLCBTcHJpdGVTd2FwKTtcclxuICAgICAgICAvLyB0aGlzLmxpc3QuYWRkRXhhbXBsZShcIlRleHR1cmUgQWR2YW5jZWRcIiwgVGV4dHVyZUFkdmFuY2VkKTtcclxuICAgICAgICAvLyB0aGlzLmxpc3QuYWRkRXhhbXBsZShcIlRleHR1cmUgR3JhZGllbnRcIiwgVGV4dHVyZUdyYWRpZW50QmFzaWMpO1xyXG4gICAgICAgIHRoaXMubGlzdC5hZGRFeGFtcGxlKFwiVGV4dHVyZSBHcmFkaWVudCAyXCIsIFRleHR1cmVHcmFkaWVudFJlc291cmNlXzEuVGV4dHVyZUdyYWRpZW50UmVzb3VyY2UpO1xyXG4gICAgICAgIHRoaXMubGlzdC5hZGRFeGFtcGxlKFwiVGV4dHVyZSBSb3RhdGVcIiwgVGV4dHVyZVJvdGF0ZV8xLlRleHR1cmVSb3RhdGUpO1xyXG4gICAgICAgIHRoaXMubGlzdC5hZGRFeGFtcGxlKFwiVGV4dHVyZSBSZW5kZXJcIiwgVGV4dHVyZVJlbmRlcl8xLlRleHR1cmVSZW5kZXIpO1xyXG4gICAgICAgIHRoaXMubGlzdC5hZGRFeGFtcGxlKFwiRmlsdGVyIEJsdXJcIiwgRmlsdGVyQmx1cl8xLkZpbHRlckJsdXIpO1xyXG4gICAgICAgIHRoaXMubGlzdC5hZGRFeGFtcGxlKFwiRmlsdGVyIENvbG9ybWF0cml4XCIsIEZpbHRlckNvbG9yXzEuRmlsdGVyQ29sb3IpO1xyXG4gICAgICAgIHRoaXMubGlzdC5hZGRFeGFtcGxlKFwiRmlsdGVyIERpc3BsYWNlbWVudFwiLCBGaWx0ZXJDcmF3bGllc18xLkZpbHRlckNyYXdsaWVzKTtcclxuICAgICAgICB0aGlzLmxpc3QuYWRkRXhhbXBsZShcIkZpbHRlciBEaXNwbGFjZW1lbnQgMlwiLCBGaWx0ZXJGbGFnXzEuRmlsdGVyRmxhZyk7XHJcbiAgICAgICAgdGhpcy5saXN0LmFkZEV4YW1wbGUoXCJGaWx0ZXIgQmx1ciAyXCIsIE1hc2tGaWx0ZXJfMS5NYXNrRmlsdGVyKTtcclxuICAgICAgICB0aGlzLmxpc3QuYWRkRXhhbXBsZShcIkZpbHRlciBCbGVuZGluZ1wiLCBGaWx0ZXJCbGVuZGluZ18xLkZpbHRlckJsZW5kaW5nKTtcclxuICAgICAgICB0aGlzLmxpc3QuYWRkRXhhbXBsZShcIkZpbHRlciBDdXN0b21cIiwgRmlsdGVyQ3VzdG9tXzEuRmlsdGVyQ3VzdG9tKTtcclxuICAgICAgICB0aGlzLmxpc3QuYWRkRXhhbXBsZShcIkZpbHRlciBTaGFkb3dcIiwgRmlsdGVyU2hhZG93XzEuRmlsdGVyU2hhZG93KTtcclxuICAgICAgICB0aGlzLmxpc3QuYWRkRXhhbXBsZShcIk1lc2ggQmFzaWNcIiwgTWVzaEJhc2ljXzEuTWVzaEJhc2ljKTtcclxuICAgICAgICB0aGlzLmxpc3QuYWRkRXhhbXBsZShcIk1lc2ggVHJpYW5nbGVcIiwgTWVzaFRyaWFuZ2xlXzEuTWVzaFRyaWFuZ2xlKTtcclxuICAgICAgICB0aGlzLmxpc3QuYWRkRXhhbXBsZShcIk1lc2ggVHJpYW5nbGUgMlwiLCBNZXNoQ29sb3JlZFRyaWFuZ2xlXzEuTWVzaENvbG9yZWRUcmlhbmdsZSk7XHJcbiAgICAgICAgdGhpcy5saXN0LmFkZEV4YW1wbGUoXCJNZXNoIFRleHR1cmVcIiwgTWVzaFRleHR1cmVkXzEuTWVzaFRleHR1cmVkKTtcclxuICAgICAgICB0aGlzLmxpc3QuYWRkRXhhbXBsZShcIk1lc2ggQWR2YW5jZWRcIiwgTWVzaEFkdmFuY2VkXzEuTWVzaEFkdmFuY2VkKTtcclxuICAgICAgICB0aGlzLmxpc3QuYWRkRXhhbXBsZShcIk1lc2ggVW5pZm9ybXNcIiwgTWVzaFVuaWZvcm1zXzEuTWVzaFVuaWZvcm1zKTtcclxuICAgICAgICB0aGlzLmxpc3QuYWRkRXhhbXBsZShcIk1lc2ggR2VvbWV0cnlcIiwgTWVzaEdlb21ldHJ5XzEuTWVzaEdlb21ldHJ5KTtcclxuICAgICAgICB0aGlzLmxpc3QuYWRkRXhhbXBsZShcIk1lc2ggU2hhZGVyXCIsIE1lc2hTaGFkZXJfMS5NZXNoU2hhZGVyKTtcclxuICAgICAgICB0aGlzLnNldEV4YW1wbGUoU3ByaXRlQmFzaWNfMS5TcHJpdGVCYXNpYyk7XHJcbiAgICB9XHJcbiAgICBzZXRFeGFtcGxlKGtleWNsYXNzKSB7XHJcbiAgICAgICAgdGhpcy5saXN0LnJlbW92ZUV2ZW50TGlzdGVuZXIoRXZlbnRfMS5FdmVudC5DSEFOR0UsIHRoaXMuaGFuZGxlRXhhbXBsZVJlcXVlc3QpO1xyXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRFeGFtcGxlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudEV4YW1wbGUuZGVzdHJ1Y3RvcigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmN1cnJlbnRFeGFtcGxlID0gbmV3IGtleWNsYXNzKHRoaXMuYXBwLCB0aGlzLmV4YW1wbGVXaWR0aCwgdGhpcy5leGFtcGxlaGVpZ2h0KTtcclxuICAgICAgICB0aGlzLmN1cnJlbnRFeGFtcGxlLmFkZEV2ZW50TGlzdGVuZXIoRXZlbnRfMS5FdmVudC5DT01QTEVURSwgdGhpcy5oYW5kbGVDb21wbGV0ZSk7XHJcbiAgICAgICAgLy8gdGhpcy5jdXJyZW50RXhhbXBsZS5zdGFnZS54ID0gdGhpcy5jdXJyZW50RXhhbXBsZS5zdGFnZS55ID0gdGhpcy5mcmFtZXNpemU7XHJcbiAgICAgICAgdGhpcy5zdGFnZUxheWVyLnJlbW92ZUNoaWxkcmVuKCk7XHJcbiAgICAgICAgdGhpcy5zdGFnZUxheWVyLmFkZENoaWxkKHRoaXMuY3VycmVudEV4YW1wbGUuc3RhZ2UpO1xyXG4gICAgICAgIHRoaXMucmVmcmVzaEJhY2tncm91bmQodGhpcy5jdXJyZW50RXhhbXBsZS5iYWNrQ29sb3IpO1xyXG4gICAgfVxyXG4gICAgcmVmcmVzaEJhY2tncm91bmQoY29sb3IpIHtcclxuICAgICAgICB0aGlzLmJhY2tncm91bmQuY2xlYXIoKTtcclxuICAgICAgICB0aGlzLmJhY2tncm91bmQuYmVnaW5GaWxsKGNvbG9yKTtcclxuICAgICAgICB0aGlzLmJhY2tncm91bmQuZHJhd1JlY3QoMCwgMCwgdGhpcy5leGFtcGxlV2lkdGgsIHRoaXMuZXhhbXBsZWhlaWdodCk7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5FeGFtcGxlRGlzcGxheSA9IEV4YW1wbGVEaXNwbGF5O1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBDb250YWluZXJfMSA9IHJlcXVpcmUoXCIuLi8uLi9yYXctcGl4aS10cy9Db250YWluZXJcIik7XHJcbmNvbnN0IEJ1dHRvbl8xID0gcmVxdWlyZShcIi4uLy4uL2ZsLXBhY2thZ2UvQnV0dG9uXCIpO1xyXG5jb25zdCBHcmFwaGljc18xID0gcmVxdWlyZShcIi4uLy4uL3Jhdy1waXhpLXRzL0dyYXBoaWNzXCIpO1xyXG5jb25zdCBNb3VzZUV2ZW50XzEgPSByZXF1aXJlKFwiLi4vLi4vcmF3LXBpeGktdHMvTW91c2VFdmVudFwiKTtcclxuY29uc3QgRXZlbnRfMSA9IHJlcXVpcmUoXCIuLi8uLi9yYXctcGl4aS10cy9FdmVudFwiKTtcclxuY2xhc3MgRXhhbXBsZUxpc3QgZXh0ZW5kcyBDb250YWluZXJfMS5Db250YWluZXIge1xyXG4gICAgY29uc3RydWN0b3IoZGlzcGxheVdpZHRoLCBkaXNwbGF5aGVpZ2h0KSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLmhhbmRsZVNjcm9sbENoYW5nZSA9IChldmVudCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLmxpc3RDb250YWluZXIueSA9IHRoaXMuc2Nyb2xsLnRhcmdldFBvc2l0aW9uO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5oYW5kbGVCdXR0b25UYXAgPSAoZXZlbnQpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5fc2VsZWN0ZWRDbGFzcyA9IHRoaXMuY2xhc3NSZWZlcmVuY2VbZXZlbnQuY3VycmVudFRhcmdldC5uYW1lXTtcclxuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KEV2ZW50XzEuRXZlbnQuZ2V0RXZlbnQoRXZlbnRfMS5FdmVudC5DSEFOR0UpKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuYnV0dG9ucyA9IFtdO1xyXG4gICAgICAgIHRoaXMuY2xhc3NSZWZlcmVuY2UgPSB7fTtcclxuICAgICAgICB0aGlzLml0ZW1HYXAgPSAyO1xyXG4gICAgICAgIHRoaXMuc2lkZUdhcCA9IDI7XHJcbiAgICAgICAgdGhpcy5saXN0Q29udGFpbmVyID0gbmV3IENvbnRhaW5lcl8xLkNvbnRhaW5lcigpO1xyXG4gICAgICAgIHRoaXMuYWRkQ2hpbGQodGhpcy5saXN0Q29udGFpbmVyKTtcclxuICAgICAgICB0aGlzLmxpc3RtYXNrID0gbmV3IEdyYXBoaWNzXzEuR3JhcGhpY3MoKTtcclxuICAgICAgICB0aGlzLmxpc3RtYXNrLmJlZ2luRmlsbCgwKTtcclxuICAgICAgICB0aGlzLmxpc3RtYXNrLmRyYXdSZWN0KDAsIDAsIGRpc3BsYXlXaWR0aCwgZGlzcGxheWhlaWdodCk7XHJcbiAgICAgICAgdGhpcy5saXN0Q29udGFpbmVyLm1hc2sgPSB0aGlzLmxpc3RtYXNrO1xyXG4gICAgICAgIHRoaXMuYWRkQ2hpbGQodGhpcy5saXN0bWFzayk7XHJcbiAgICAgICAgbGV0IGdyID0gbmV3IEdyYXBoaWNzXzEuR3JhcGhpY3MoKTtcclxuICAgICAgICBnci5iZWdpbkZpbGwoMHhBQUEwQUEpO1xyXG4gICAgICAgIGdyLmRyYXdSZWN0KDAsIDAsIDI1LCBkaXNwbGF5aGVpZ2h0KTtcclxuICAgICAgICB0aGlzLmFkZENoaWxkKGdyKTtcclxuICAgICAgICBnci54ID0gZGlzcGxheVdpZHRoIC0gMjU7XHJcbiAgICAgICAgdGhpcy5idXR0b25XaWR0aCA9IGRpc3BsYXlXaWR0aCAtIDI1IC0gKHRoaXMuc2lkZUdhcCAqIDIpO1xyXG4gICAgICAgIHRoaXMuYnV0dG9uaGVpZ2h0ID0gNDA7XHJcbiAgICAgICAgdGhpcy5zY3JvbGwgPSBuZXcgU2Nyb2xsQmFyKCk7XHJcbiAgICAgICAgdGhpcy5hZGRDaGlsZCh0aGlzLnNjcm9sbCk7XHJcbiAgICAgICAgdGhpcy5zY3JvbGwueCA9IGRpc3BsYXlXaWR0aCAtIDI1O1xyXG4gICAgICAgIHRoaXMuc2Nyb2xsLnNjcm9sbEFyZWEgPSBkaXNwbGF5aGVpZ2h0O1xyXG4gICAgICAgIHRoaXMuc2Nyb2xsLmFkZEV2ZW50TGlzdGVuZXIoRXZlbnRfMS5FdmVudC5DSEFOR0UsIHRoaXMuaGFuZGxlU2Nyb2xsQ2hhbmdlKTtcclxuICAgIH1cclxuICAgIGdldCBzZWxlY3RlZENsYXNzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9zZWxlY3RlZENsYXNzO1xyXG4gICAgfVxyXG4gICAgYWRkRXhhbXBsZShrZXluYW1lLCBrZXljbGFzcykge1xyXG4gICAgICAgIGxldCBidXR0b24gPSBuZXcgQnV0dG9uXzEuQnV0dG9uKGtleW5hbWUsIHRoaXMuYnV0dG9uV2lkdGgsIHRoaXMuYnV0dG9uaGVpZ2h0KTtcclxuICAgICAgICBidXR0b24uYWRkRXZlbnRMaXN0ZW5lcihNb3VzZUV2ZW50XzEuTW91c2VFdmVudC5QT0lOVEVSX1RBUCwgdGhpcy5oYW5kbGVCdXR0b25UYXApO1xyXG4gICAgICAgIHRoaXMuYnV0dG9ucy5wdXNoKGJ1dHRvbik7XHJcbiAgICAgICAgYnV0dG9uLm5hbWUgPSBrZXluYW1lO1xyXG4gICAgICAgIGJ1dHRvbi54ID0gdGhpcy5zaWRlR2FwO1xyXG4gICAgICAgIHRoaXMubGlzdENvbnRhaW5lci5hZGRDaGlsZChidXR0b24pO1xyXG4gICAgICAgIHRoaXMuY2xhc3NSZWZlcmVuY2Vba2V5bmFtZV0gPSBrZXljbGFzcztcclxuICAgICAgICB0aGlzLnJlZnJlc2hMaXN0KCk7XHJcbiAgICB9XHJcbiAgICByZWZyZXNoTGlzdCgpIHtcclxuICAgICAgICBsZXQgc3RhcnQgPSB0aGlzLml0ZW1HYXA7XHJcbiAgICAgICAgZm9yIChsZXQgYnV0dG9uIG9mIHRoaXMuYnV0dG9ucykge1xyXG4gICAgICAgICAgICBidXR0b24ueSA9IHN0YXJ0O1xyXG4gICAgICAgICAgICBzdGFydCArPSBidXR0b24uaGVpZ2h0ICsgdGhpcy5pdGVtR2FwO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnNjcm9sbC5zY3JvbGxEaXN0YW5jZSA9IHN0YXJ0O1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuRXhhbXBsZUxpc3QgPSBFeGFtcGxlTGlzdDtcclxuY2xhc3MgU2Nyb2xsQmFyIGV4dGVuZHMgQ29udGFpbmVyXzEuQ29udGFpbmVyIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5oYW5kbGVIYW5kbGVVcCA9IChldmVudCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLmRyYWdnaW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuZXZlbnREYXRhID0gbnVsbDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuaGFuZGxlSGFuZGxlTW92ZSA9IChldmVudCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5ldmVudERhdGEpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5ld1Bvc2l0aW9uID0gdGhpcy5ldmVudERhdGEuZ2V0TG9jYWxQb3NpdGlvbih0aGlzLl9oYW5kbGUucGFyZW50KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2hhbmRsZS55ID0gbmV3UG9zaXRpb24ueSAtICh0aGlzLl9oYW5kbGUuaGVpZ2h0IC8gMik7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5faGFuZGxlLnkgPiB0aGlzLl9zY3JvbGxBcmVhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faGFuZGxlLnkgPSB0aGlzLl9zY3JvbGxBcmVhO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5faGFuZGxlLnkgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faGFuZGxlLnkgPSAwO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5hcmVhUGVyY2VudCA9IHRoaXMuX2hhbmRsZS55IC8gdGhpcy5fc2Nyb2xsQXJlYTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3RhcmdldFBvc2l0aW9uID0gKHRoaXMuX3Njcm9sbERpc3RhbmNlIC0gdGhpcy5fdmlzaWJsZUFyZWEpICogdGhpcy5hcmVhUGVyY2VudCAqIC0xO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KEV2ZW50XzEuRXZlbnQuZ2V0RXZlbnQoRXZlbnRfMS5FdmVudC5DSEFOR0UpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5oYW5kbGVIYW5kbGVEb3duID0gKGV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuZHJhZ2dpbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLmV2ZW50RGF0YSA9IGV2ZW50LmRhdGE7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLl9oYW5kbGUgPSBuZXcgR3JhcGhpY3NfMS5HcmFwaGljcygpO1xyXG4gICAgICAgIHRoaXMuX2hhbmRsZS5iZWdpbkZpbGwoMHg2MzYzNjMpO1xyXG4gICAgICAgIHRoaXMuX2hhbmRsZS5kcmF3UmVjdCgwLCAwLCAyNSwgMjUpO1xyXG4gICAgICAgIHRoaXMuYWRkQ2hpbGQodGhpcy5faGFuZGxlKTtcclxuICAgICAgICB0aGlzLl9oYW5kbGUuYnV0dG9uTW9kZSA9IHRoaXMuX2hhbmRsZS5pbnRlcmFjdGl2ZSA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5faGFuZGxlLmFkZEV2ZW50TGlzdGVuZXIoTW91c2VFdmVudF8xLk1vdXNlRXZlbnQuUE9JTlRFUl9ET1dOLCB0aGlzLmhhbmRsZUhhbmRsZURvd24pO1xyXG4gICAgICAgIHRoaXMuX2hhbmRsZS5hZGRFdmVudExpc3RlbmVyKE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50LlBPSU5URVJfVVAsIHRoaXMuaGFuZGxlSGFuZGxlVXApO1xyXG4gICAgICAgIHRoaXMuX2hhbmRsZS5hZGRFdmVudExpc3RlbmVyKE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50LlBPSU5URVJfVVBfT1VUU0lERSwgdGhpcy5oYW5kbGVIYW5kbGVVcCk7XHJcbiAgICAgICAgdGhpcy5faGFuZGxlLmFkZEV2ZW50TGlzdGVuZXIoTW91c2VFdmVudF8xLk1vdXNlRXZlbnQuUE9JTlRFUl9NT1ZFLCB0aGlzLmhhbmRsZUhhbmRsZU1vdmUpO1xyXG4gICAgfVxyXG4gICAgZ2V0IHRhcmdldFBvc2l0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl90YXJnZXRQb3NpdGlvbjtcclxuICAgIH1cclxuICAgIHNldCBzY3JvbGxEaXN0YW5jZSh2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuX3Njcm9sbERpc3RhbmNlID0gdmFsdWU7XHJcbiAgICB9XHJcbiAgICBzZXQgc2Nyb2xsQXJlYSh2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuX3Njcm9sbEFyZWEgPSB2YWx1ZSAtIDI1O1xyXG4gICAgICAgIHRoaXMuX3Zpc2libGVBcmVhID0gdmFsdWU7XHJcbiAgICB9XHJcbn1cclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgQ29udGFpbmVyXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvQ29udGFpbmVyXCIpO1xyXG5jb25zdCBHcmFwaGljc18xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0dyYXBoaWNzXCIpO1xyXG5jb25zdCBNb3VzZUV2ZW50XzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvTW91c2VFdmVudFwiKTtcclxuY29uc3QgVGV4dF8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1RleHRcIik7XHJcbmNvbnN0IFRleHRTdHlsZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1RleHRTdHlsZVwiKTtcclxuY2xhc3MgQnV0dG9uIGV4dGVuZHMgQ29udGFpbmVyXzEuQ29udGFpbmVyIHtcclxuICAgIGNvbnN0cnVjdG9yKGNhcHRpb24sIGJ1dHRvbldpZHRoID0gMTUwLCBidXR0b25oZWlnaHQgPSA0MCkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5oYW5kbGVPdXQgPSAoZXZlbnQpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5idXR0b25ncmFwaGljLnZpc2libGUgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLmJ1dHRvbm92ZXJncmFwaGljLnZpc2libGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5idXR0b25kb3duZ3JhcGhpYy52aXNpYmxlID0gZmFsc2U7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLmhhbmRsZU92ZXIgPSAoZXZlbnQpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5idXR0b25ncmFwaGljLnZpc2libGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5idXR0b25vdmVyZ3JhcGhpYy52aXNpYmxlID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5idXR0b25kb3duZ3JhcGhpYy52aXNpYmxlID0gZmFsc2U7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLmhhbmRsZVVwID0gKGV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuYnV0dG9uZ3JhcGhpYy52aXNpYmxlID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5idXR0b25vdmVyZ3JhcGhpYy52aXNpYmxlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuYnV0dG9uZG93bmdyYXBoaWMudmlzaWJsZSA9IGZhbHNlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5oYW5kbGVEb3duID0gKGV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuYnV0dG9uZ3JhcGhpYy52aXNpYmxlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuYnV0dG9ub3ZlcmdyYXBoaWMudmlzaWJsZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLmJ1dHRvbmRvd25ncmFwaGljLnZpc2libGUgPSB0cnVlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5pbnRlcmFjdGl2ZSA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5idXR0b25ncmFwaGljID0gbmV3IEdyYXBoaWNzXzEuR3JhcGhpY3MoKTtcclxuICAgICAgICB0aGlzLmJ1dHRvbmdyYXBoaWMuYmVnaW5GaWxsKDB4OTY5Njk2KTtcclxuICAgICAgICB0aGlzLmJ1dHRvbmdyYXBoaWMuZHJhd1JvdW5kZWRSZWN0KDAsIDAsIGJ1dHRvbldpZHRoLCBidXR0b25oZWlnaHQsIDEwKTtcclxuICAgICAgICB0aGlzLmFkZENoaWxkKHRoaXMuYnV0dG9uZ3JhcGhpYyk7XHJcbiAgICAgICAgdGhpcy5idXR0b25vdmVyZ3JhcGhpYyA9IG5ldyBHcmFwaGljc18xLkdyYXBoaWNzKCk7XHJcbiAgICAgICAgdGhpcy5idXR0b25vdmVyZ3JhcGhpYy5iZWdpbkZpbGwoMHhCOUI5QjkpO1xyXG4gICAgICAgIHRoaXMuYnV0dG9ub3ZlcmdyYXBoaWMuZHJhd1JvdW5kZWRSZWN0KDAsIDAsIGJ1dHRvbldpZHRoLCBidXR0b25oZWlnaHQsIDEwKTtcclxuICAgICAgICB0aGlzLmFkZENoaWxkKHRoaXMuYnV0dG9ub3ZlcmdyYXBoaWMpO1xyXG4gICAgICAgIHRoaXMuYnV0dG9ub3ZlcmdyYXBoaWMudmlzaWJsZSA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuYnV0dG9uZG93bmdyYXBoaWMgPSBuZXcgR3JhcGhpY3NfMS5HcmFwaGljcygpO1xyXG4gICAgICAgIHRoaXMuYnV0dG9uZG93bmdyYXBoaWMuYmVnaW5GaWxsKDB4NjM2MzYzKTtcclxuICAgICAgICB0aGlzLmJ1dHRvbmRvd25ncmFwaGljLmRyYXdSb3VuZGVkUmVjdCgwLCAwLCBidXR0b25XaWR0aCwgYnV0dG9uaGVpZ2h0LCAxMCk7XHJcbiAgICAgICAgdGhpcy5hZGRDaGlsZCh0aGlzLmJ1dHRvbmRvd25ncmFwaGljKTtcclxuICAgICAgICB0aGlzLmJ1dHRvbmRvd25ncmFwaGljLnZpc2libGUgPSBmYWxzZTtcclxuICAgICAgICBsZXQgc3R5bGUgPSBuZXcgVGV4dFN0eWxlXzEuVGV4dFN0eWxlKHt9KTtcclxuICAgICAgICBzdHlsZS5mb250U2l6ZSA9IDE2O1xyXG4gICAgICAgIHN0eWxlLmFsaWduID0gXCJjZW50ZXJcIjtcclxuICAgICAgICBzdHlsZS5mb250RmFtaWx5ID0gXCJBcmlhbFwiO1xyXG4gICAgICAgIHRoaXMubGFiZWwgPSBuZXcgVGV4dF8xLlRleHQoY2FwdGlvbiwgc3R5bGUpO1xyXG4gICAgICAgIHRoaXMubGFiZWwuaW50ZXJhY3RpdmUgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmxhYmVsLnkgPSAoYnV0dG9uaGVpZ2h0IC0gKHRoaXMubGFiZWwuaGVpZ2h0KSkgLyAyO1xyXG4gICAgICAgIHRoaXMubGFiZWwueCA9IChidXR0b25XaWR0aCAvIDIgLSB0aGlzLmxhYmVsLndpZHRoIC8gMik7XHJcbiAgICAgICAgdGhpcy5hZGRDaGlsZCh0aGlzLmxhYmVsKTtcclxuICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoTW91c2VFdmVudF8xLk1vdXNlRXZlbnQuUE9JTlRFUl9ET1dOLCB0aGlzLmhhbmRsZURvd24pO1xyXG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihNb3VzZUV2ZW50XzEuTW91c2VFdmVudC5QT0lOVEVSX09WRVIsIHRoaXMuaGFuZGxlT3Zlcik7XHJcbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50LlBPSU5URVJfVVAsIHRoaXMuaGFuZGxlVXApO1xyXG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihNb3VzZUV2ZW50XzEuTW91c2VFdmVudC5QT0lOVEVSX09VVCwgdGhpcy5oYW5kbGVPdXQpO1xyXG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihNb3VzZUV2ZW50XzEuTW91c2VFdmVudC5QT0lOVEVSX1VQX09VVFNJREUsIHRoaXMuaGFuZGxlT3V0KTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLkJ1dHRvbiA9IEJ1dHRvbjtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgQXBwbGljYXRpb25fMSA9IHJlcXVpcmUoXCIuL3Jhdy1waXhpLXRzL0FwcGxpY2F0aW9uXCIpO1xyXG5jb25zdCBTdGFnZU9wdGlvbnNfMSA9IHJlcXVpcmUoXCIuL3Jhdy1waXhpLXRzL1N0YWdlT3B0aW9uc1wiKTtcclxuY29uc3QgRXhhbXBsZURpc3BsYXlfMSA9IHJlcXVpcmUoXCIuL2V4YW1wbGVzL2NvbnRyb2xzL0V4YW1wbGVEaXNwbGF5XCIpO1xyXG53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgKCkgPT4ge1xyXG4gICAgdmFyIG9wdGlvbnMgPSBuZXcgU3RhZ2VPcHRpb25zXzEuU3RhZ2VPcHRpb25zKCk7XHJcbiAgICBvcHRpb25zLndpZHRoID0gMTAwMDtcclxuICAgIG9wdGlvbnMuaGVpZ2h0ID0gNjAwO1xyXG4gICAgb3B0aW9ucy5hdXRvUmVzaXplID0gZmFsc2U7XHJcbiAgICBvcHRpb25zLmJhY2tncm91bmRDb2xvciA9IDB4MDAwMDAwMDA7XHJcbiAgICBvcHRpb25zLmNsZWFyQmVmb3JlUmVuZGVyID0gdHJ1ZTtcclxuICAgIG9wdGlvbnMucmVzb2x1dGlvbiA9IDE7XHJcbiAgICBvcHRpb25zLmF1dG9TdGFydCA9IHRydWU7XHJcbiAgICBvcHRpb25zLnRyYW5zcGFyZW50ID0gdHJ1ZTtcclxuICAgIG9wdGlvbnMuYW50aWFsaWFzID0gdHJ1ZTtcclxuICAgIG9wdGlvbnMudmlldyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZmFrZWNhbnZhc1wiKTtcclxuICAgIHZhciBhcHAgPSBuZXcgQXBwbGljYXRpb25fMS5BcHBsaWNhdGlvbihvcHRpb25zKTtcclxuICAgIGxldCBkaXNwbGF5ID0gbmV3IEV4YW1wbGVEaXNwbGF5XzEuRXhhbXBsZURpc3BsYXkoYXBwLCAxMDI0LCA3NjgpO1xyXG4gICAgYXBwLnN0YWdlLmFkZENoaWxkKGRpc3BsYXkpO1xyXG4gICAgLy8gY3JlYXRlIGEgdmlldyBjbGFzcyB3aXRoIGZyYW1lXHJcbiAgICAvLyBjcmVhdGUgYSBjb250cm9sIGNsYXNzIHdpdGggYnV0dG9uc1xyXG4gICAgLy8gZWFjaCBidXR0b24gY2xpY2sgY2hhbmdlIGNvbnRlbnQgb2YgY2xhc3MgZnJhbWVcclxuICAgIC8vIGxldCBidXR0b246QnV0dG9uID0gbmV3IEJ1dHRvbihcIlRlc3RcIiwgMjAwLCA0MCk7XHJcbiAgICAvLyBhcHAuc3RhZ2UuYWRkQ2hpbGQoYnV0dG9uKTtcclxuICAgIC8vIGJ1dHRvbi54ID0gODAwO1xyXG4gICAgLy8gbGV0IGV4YW1wbGU6QmFzaWNDYWNoZSA9IG5ldyBCYXNpY0NhY2hlKGFwcCk7IE5PVCBXT1JLSU5HXHJcbiAgICAvLyBsZXQgZXhhbXBsZTpJbnRlcmFjdGlvbkljb24gPSBuZXcgSW50ZXJhY3Rpb25JY29uKGFwcCk7XHJcbiAgICAvLyBsZXQgZXhhbXBsZTpTcHJpdGVWaWRlbyA9IG5ldyBTcHJpdGVWaWRlbyhhcHApO1xyXG4gICAgLy8gbGV0IGV4YW1wbGU6QWR2YW5jZWRTbG90cyA9IG5ldyBBZHZhbmNlZFNsb3RzKGFwcCk7IFxyXG4gICAgLy8gbGV0IGV4YW1wbGU6VGV4dHVyZVJvdGF0ZSA9IG5ldyBUZXh0dXJlUm90YXRlKGFwcCk7IFxyXG4gICAgLy8gbGV0IGV4YW1wbGU6QmFzaWNDb250YWluZXIgPSBuZXcgQmFzaWNDb250YWluZXIoYXBwKTtcclxuICAgIC8vIGxldCBleGFtcGxlOkJhc2ljQmFja2dyb3VuZCA9IG5ldyBCYXNpY0JhY2tncm91bmQoYXBwKTtcclxuICAgIC8vIGxldCBleGFtcGxlOkJhc2ljVGludGluZyA9IG5ldyBCYXNpY1RpbnRpbmcoYXBwKTsgICAgXHJcbiAgICAvLyBsZXQgZXhhbXBsZTpCYXNpY1BhcnRpY2xlcyA9IG5ldyBCYXNpY1BhcnRpY2xlcyhhcHApO1xyXG4gICAgLy8gbGV0IGV4YW1wbGU6QmFzaWNCbGVuZCA9IG5ldyBCYXNpY0JsZW5kKGFwcCk7ICAgIFxyXG4gICAgLy8gbGV0IGV4YW1wbGU6R3JhcGhpY3NTaW1wbGUgPSBuZXcgR3JhcGhpY3NTaW1wbGUoYXBwKTtcclxuICAgIC8vIGxldCBleGFtcGxlOkdyYXBoaWNzQWR2YW5jZWQgPSBuZXcgR3JhcGhpY3NBZHZhbmNlZChhcHApO1xyXG4gICAgLy8gbGV0IGV4YW1wbGU6R3JhcGhpY3NEeW5hbWljID0gbmV3IEdyYXBoaWNzRHluYW1pYyhhcHApO1xyXG4gICAgLy8gbGV0IGV4YW1wbGU6VGV4dHVyZVJlbmRlciA9IG5ldyBUZXh0dXJlUmVuZGVyKGFwcCk7XHJcbiAgICAvLyBsZXQgZXhhbXBsZTpUZXh0dXJlQWR2YW5jZWQgPSBuZXcgVGV4dHVyZUFkdmFuY2VkKGFwcCk7XHJcbiAgICAvLyBsZXQgZXhhbXBsZTpUZXh0dXJlR3JhZGllbnRCYXNpYyA9IG5ldyBUZXh0dXJlR3JhZGllbnRCYXNpYyhhcHApO1xyXG4gICAgLy8gbGV0IGV4YW1wbGU6VGV4dHVyZUdyYWRpZW50UmVzb3VyY2UgPSBuZXcgVGV4dHVyZUdyYWRpZW50UmVzb3VyY2UoYXBwKTtcclxuICAgIC8vIGxldCBleGFtcGxlOlRleHRCYXNlID0gbmV3IFRleHRCYXNlKGFwcCk7XHJcbiAgICAvLyBsZXQgZXhhbXBsZTpUZXh0Qml0bWFwID0gbmV3IFRleHRCaXRtYXAoYXBwKTsgXHJcbiAgICAvLyBsZXQgZXhhbXBsZTpUZXh0V2ViRm9udCA9IG5ldyBUZXh0V2ViRm9udChhcHApOyBcclxuICAgIC8vIGxldCBleGFtcGxlOk1hc2tHcmFwaGljcyA9IG5ldyBNYXNrR3JhcGhpY3MoYXBwKTtcclxuICAgIC8vIGxldCBleGFtcGxlOk1hc2tTcHJpdGUgPSBuZXcgTWFza1Nwcml0ZShhcHApO1xyXG4gICAgLy8gbGV0IGV4YW1wbGU6RmlsdGVyQmx1ciA9IG5ldyBGaWx0ZXJCbHVyKGFwcCk7XHJcbiAgICAvLyBsZXQgZXhhbXBsZTpGaWx0ZXJDb2xvciA9IG5ldyBGaWx0ZXJDb2xvcihhcHApO1xyXG4gICAgLy8gbGV0IGV4YW1wbGU6RmlsdGVyQ3Jhd2xpZXMgPSBuZXcgRmlsdGVyQ3Jhd2xpZXMoYXBwKTtcclxuICAgIC8vIGxldCBleGFtcGxlOkZpbHRlckZsYWcgPSBuZXcgRmlsdGVyRmxhZyhhcHApO1xyXG4gICAgLy8gbGV0IGV4YW1wbGU6TWFza0ZpbHRlciA9IG5ldyBNYXNrRmlsdGVyKGFwcCk7XHJcbiAgICAvLyBsZXQgZXhhbXBsZTpJbnRlcmFjdGlvbkNsaWNrID0gbmV3IEludGVyYWN0aW9uQ2xpY2soYXBwKTtcclxuICAgIC8vIGxldCBleGFtcGxlOkludGVyYWN0aW9uSW50ZXJhY3Rpdml0eSA9IG5ldyBJbnRlcmFjdGlvbkludGVyYWN0aXZpdHkoYXBwKTtcclxuICAgIC8vIGxldCBleGFtcGxlOkludGVyYWN0aW9uRHJhZ2dpbmcgPSBuZXcgSW50ZXJhY3Rpb25EcmFnZ2luZyhhcHApOyBcclxuICAgIC8vIGxldCBleGFtcGxlOlNwcml0ZUJhc2ljID0gbmV3IFNwcml0ZUJhc2ljKGFwcCk7ICBcclxuICAgIC8vIGxldCBleGFtcGxlOlNwcml0ZVN3YXAgPSBuZXcgU3ByaXRlU3dhcChhcHApOyAgICBcclxuICAgIC8vIGxldCBleGFtcGxlOlNwcml0ZVRpbGluZyA9IG5ldyBTcHJpdGVUaWxpbmcoYXBwKTsgICAgXHJcbiAgICAvLyBsZXQgZXhhbXBsZTpTcHJpdGVFeHBsb3Npb24gPSBuZXcgU3ByaXRlRXhwbG9zaW9uKGFwcCk7XHJcbiAgICAvLyBsZXQgZXhhbXBsZTpTcHJpdGVqZXQgPSBuZXcgU3ByaXRlamV0KGFwcCk7IFxyXG4gICAgLy8gbGV0IGV4YW1wbGU6U3ByaXRlU3BlZWQgPSBuZXcgU3ByaXRlU3BlZWQoYXBwKTsgXHJcbiAgICAvLyBsZXQgZXhhbXBsZTpBZHZhbmNlZENhcmQgPSBuZXcgQWR2YW5jZWRDYXJkKGFwcCk7IFxyXG4gICAgLy8gbGV0IGV4YW1wbGU6QWR2YW5jZWRUcmFpbCA9IG5ldyBBZHZhbmNlZFRyYWlsKGFwcCk7IFxyXG4gICAgLy8gbGV0IGV4YW1wbGU6QWR2YW5jZWRXYXJwID0gbmV3IEFkdmFuY2VkV2FycChhcHApOyBcclxuICAgIC8vIGxldCBleGFtcGxlOkZpbHRlckJsZW5kaW5nID0gbmV3IEZpbHRlckJsZW5kaW5nKGFwcCk7IFxyXG4gICAgLy8gbGV0IGV4YW1wbGU6RmlsdGVyQ3VzdG9tID0gbmV3IEZpbHRlckN1c3RvbShhcHApOyBcclxuICAgIC8vIGxldCBleGFtcGxlOkZpbHRlclNoYWRvdyA9IG5ldyBGaWx0ZXJTaGFkb3coYXBwKTsgXHJcbiAgICAvLyBsZXQgZXhhbXBsZTpNZXNoQmFzaWMgPSBuZXcgTWVzaEJhc2ljKGFwcCk7XHJcbiAgICAvLyBsZXQgZXhhbXBsZTpNZXNoQWR2YW5jZWQgPSBuZXcgTWVzaEFkdmFuY2VkKGFwcCk7XHJcbiAgICAvLyBsZXQgZXhhbXBsZTpNZXNoVHJpYW5nbGUgPSBuZXcgTWVzaFRyaWFuZ2xlKGFwcCk7XHJcbiAgICAvLyBsZXQgZXhhbXBsZTpNZXNoQ29sb3JlZFRyaWFuZ2xlID0gbmV3IE1lc2hDb2xvcmVkVHJpYW5nbGUoYXBwKTtcclxuICAgIC8vIGxldCBleGFtcGxlOk1lc2hUZXh0dXJlZCA9IG5ldyBNZXNoVGV4dHVyZWQoYXBwKTtcclxuICAgIC8vIGxldCBleGFtcGxlOk1lc2hVbmlmb3JtcyA9IG5ldyBNZXNoVW5pZm9ybXMoYXBwKTtcclxuICAgIC8vIGxldCBleGFtcGxlOk1lc2hHZW9tZXRyeSA9IG5ldyBNZXNoR2VvbWV0cnkoYXBwKTtcclxuICAgIC8vIGxldCBleGFtcGxlOk1lc2hTaGFkZXIgPSBuZXcgTWVzaFNoYWRlcihhcHApO1xyXG59KTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgRXZlbnREaXNwYXRjaGVyXzEgPSByZXF1aXJlKFwiLi9FdmVudERpc3BhdGNoZXJcIik7XHJcbmNvbnN0IE1hdHJpeF8xID0gcmVxdWlyZShcIi4vTWF0cml4XCIpO1xyXG5jb25zdCBSZWN0YW5nbGVfMSA9IHJlcXVpcmUoXCIuL1JlY3RhbmdsZVwiKTtcclxuY29uc3QgUmVuZGVyVGV4dHVyZV8xID0gcmVxdWlyZShcIi4vUmVuZGVyVGV4dHVyZVwiKTtcclxuY29uc3QgQ29udGFpbmVyXzEgPSByZXF1aXJlKFwiLi9Db250YWluZXJcIik7XHJcbmNvbnN0IERpc3BsYXlTZXR0aW5nc18xID0gcmVxdWlyZShcIi4vRGlzcGxheVNldHRpbmdzXCIpO1xyXG5jb25zdCBNYXRoU2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL01hdGhTZXR0aW5nc1wiKTtcclxuY29uc3QgQ29sb3JTZXR0aW5nc18xID0gcmVxdWlyZShcIi4vQ29sb3JTZXR0aW5nc1wiKTtcclxuY2xhc3MgQWJzdHJhY3RSZW5kZXJlciBleHRlbmRzIEV2ZW50RGlzcGF0Y2hlcl8xLkV2ZW50RGlzcGF0Y2hlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihzeXN0ZW0sIG9wdGlvbnMpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIGlmIChvcHRpb25zLnJvdW5kUGl4ZWxzKSB7XHJcbiAgICAgICAgICAgIERpc3BsYXlTZXR0aW5nc18xLkRpc3BsYXlTZXR0aW5ncy5ST1VORF9QSVhFTFMgPSBvcHRpb25zLnJvdW5kUGl4ZWxzO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xyXG4gICAgICAgIHRoaXMudHlwZSA9IERpc3BsYXlTZXR0aW5nc18xLkRpc3BsYXlTZXR0aW5ncy5SRU5ERVJFUl9UWVBFLlVOS05PV047XHJcbiAgICAgICAgdGhpcy5zY3JlZW4gPSBuZXcgUmVjdGFuZ2xlXzEuUmVjdGFuZ2xlKDAsIDAsIG9wdGlvbnMud2lkdGgsIG9wdGlvbnMuaGVpZ2h0KTtcclxuICAgICAgICB0aGlzLnZpZXcgPSBvcHRpb25zLnZpZXcgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XHJcbiAgICAgICAgdGhpcy5yZXNvbHV0aW9uID0gb3B0aW9ucy5yZXNvbHV0aW9uIHx8IERpc3BsYXlTZXR0aW5nc18xLkRpc3BsYXlTZXR0aW5ncy5SRVNPTFVUSU9OO1xyXG4gICAgICAgIHRoaXMudHJhbnNwYXJlbnQgPSBvcHRpb25zLnRyYW5zcGFyZW50O1xyXG4gICAgICAgIHRoaXMuYXV0b0RlbnNpdHkgPSBvcHRpb25zLmF1dG9EZW5zaXR5IHx8IG9wdGlvbnMuYXV0b1Jlc2l6ZSB8fCBmYWxzZTtcclxuICAgICAgICB0aGlzLnByZXNlcnZlRHJhd2luZ0J1ZmZlciA9IG9wdGlvbnMucHJlc2VydmVEcmF3aW5nQnVmZmVyO1xyXG4gICAgICAgIHRoaXMuY2xlYXJCZWZvcmVSZW5kZXIgPSBvcHRpb25zLmNsZWFyQmVmb3JlUmVuZGVyO1xyXG4gICAgICAgIHRoaXMuX2JhY2tncm91bmRDb2xvciA9IDB4MDAwMDAwO1xyXG4gICAgICAgIHRoaXMuX2JhY2tncm91bmRDb2xvclJnYmEgPSBbMCwgMCwgMCwgMF07XHJcbiAgICAgICAgdGhpcy5fYmFja2dyb3VuZENvbG9yU3RyaW5nID0gJyMwMDAwMDAnO1xyXG4gICAgICAgIHRoaXMuYmFja2dyb3VuZENvbG9yID0gb3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3IgfHwgdGhpcy5fYmFja2dyb3VuZENvbG9yO1xyXG4gICAgICAgIHRoaXMuX3RlbXBEaXNwbGF5T2JqZWN0UGFyZW50ID0gbmV3IENvbnRhaW5lcl8xLkNvbnRhaW5lcigpO1xyXG4gICAgICAgIHRoaXMuX2xhc3RPYmplY3RSZW5kZXJlZCA9IHRoaXMuX3RlbXBEaXNwbGF5T2JqZWN0UGFyZW50O1xyXG4gICAgICAgIHRoaXMuYmxlbmRNb2RlcyA9IDA7XHJcbiAgICB9XHJcbiAgICByZXNpemUoc2NyZWVuV2lkdGgsIHNjcmVlbkhlaWdodCkge1xyXG4gICAgICAgIHRoaXMuc2NyZWVuLndpZHRoID0gc2NyZWVuV2lkdGg7XHJcbiAgICAgICAgdGhpcy5zY3JlZW4uaGVpZ2h0ID0gc2NyZWVuSGVpZ2h0O1xyXG4gICAgICAgIHRoaXMudmlldy53aWR0aCA9IHNjcmVlbldpZHRoICogdGhpcy5yZXNvbHV0aW9uO1xyXG4gICAgICAgIHRoaXMudmlldy5oZWlnaHQgPSBzY3JlZW5IZWlnaHQgKiB0aGlzLnJlc29sdXRpb247XHJcbiAgICAgICAgaWYgKHRoaXMuYXV0b0RlbnNpdHkpIHtcclxuICAgICAgICAgICAgdGhpcy52aWV3LnN0eWxlLndpZHRoID0gc2NyZWVuV2lkdGggKyBcInB4XCI7XHJcbiAgICAgICAgICAgIHRoaXMudmlldy5zdHlsZS5oZWlnaHQgPSBzY3JlZW5IZWlnaHQgKyBcInB4XCI7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgZ2V0IHdpZHRoKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnZpZXcud2lkdGg7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICBnZXQgaGVpZ2h0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnZpZXcuaGVpZ2h0O1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgZ2VuZXJhdGVUZXh0dXJlKGRpc3BsYXlPYmplY3QsIHNjYWxlTW9kZSwgcmVzb2x1dGlvbiwgcmVnaW9uKSB7XHJcbiAgICAgICAgcmVnaW9uID0gcmVnaW9uIHx8IGRpc3BsYXlPYmplY3QuZ2V0TG9jYWxCb3VuZHMoKTtcclxuICAgICAgICBpZiAocmVnaW9uLndpZHRoID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJlZ2lvbi53aWR0aCA9IDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChyZWdpb24uaGVpZ2h0ID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJlZ2lvbi5oZWlnaHQgPSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcmVuZGVyVGV4dHVyZSA9IFJlbmRlclRleHR1cmVfMS5SZW5kZXJUZXh0dXJlLmNyZWF0ZShyZWdpb24ud2lkdGggfCAwLCByZWdpb24uaGVpZ2h0IHwgMCwgc2NhbGVNb2RlLCByZXNvbHV0aW9uKTtcclxuICAgICAgICBBYnN0cmFjdFJlbmRlcmVyLnRlbXBNYXRyaXgudHggPSAtcmVnaW9uLng7XHJcbiAgICAgICAgQWJzdHJhY3RSZW5kZXJlci50ZW1wTWF0cml4LnR5ID0gLXJlZ2lvbi55O1xyXG4gICAgICAgIHRoaXMucmVuZGVyKGRpc3BsYXlPYmplY3QsIHJlbmRlclRleHR1cmUsIGZhbHNlLCBBYnN0cmFjdFJlbmRlcmVyLnRlbXBNYXRyaXgsICEhZGlzcGxheU9iamVjdC5wYXJlbnQpO1xyXG4gICAgICAgIHJldHVybiByZW5kZXJUZXh0dXJlO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgcmVuZGVyKGRpc3BsYXlPYmplY3QsIHJlbmRlclRleHR1cmUsIGIsIG0sIHBhcmVudCkge1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIGV2ZXJ5dGhpbmcgZnJvbSB0aGUgcmVuZGVyZXIgYW5kIG9wdGlvbmFsbHkgcmVtb3ZlcyB0aGUgQ2FudmFzIERPTSBlbGVtZW50LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JlbW92ZVZpZXc9ZmFsc2VdIC0gUmVtb3ZlcyB0aGUgQ2FudmFzIGVsZW1lbnQgZnJvbSB0aGUgRE9NLlxyXG4gICAgICovXHJcbiAgICBkZXN0cm95KHJlbW92ZVZpZXcpIHtcclxuICAgICAgICAvLyBmb3IgKHZhciBvIGluIHRoaXMucGx1Z2lucylcclxuICAgICAgICAvLyB7XHJcbiAgICAgICAgLy8gICAgIHRoaXMucGx1Z2luc1tvXS5kZXN0cm95KCk7XHJcbiAgICAgICAgLy8gICAgIHRoaXMucGx1Z2luc1tvXSA9IG51bGw7XHJcbiAgICAgICAgLy8gfVxyXG4gICAgICAgIGlmIChyZW1vdmVWaWV3ICYmIHRoaXMudmlldy5wYXJlbnROb2RlKSB7XHJcbiAgICAgICAgICAgIHRoaXMudmlldy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMudmlldyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHRoaXMucGx1Z2lucyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy50eXBlID0gRGlzcGxheVNldHRpbmdzXzEuRGlzcGxheVNldHRpbmdzLlJFTkRFUkVSX1RZUEUuVU5LTk9XTjtcclxuICAgICAgICB0aGlzLnZpZXcgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuc2NyZWVuID0gbnVsbDtcclxuICAgICAgICB0aGlzLnJlc29sdXRpb24gPSAwO1xyXG4gICAgICAgIHRoaXMudHJhbnNwYXJlbnQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmF1dG9EZW5zaXR5ID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5ibGVuZE1vZGVzID0gbnVsbDtcclxuICAgICAgICB0aGlzLm9wdGlvbnMgPSBudWxsO1xyXG4gICAgICAgIHRoaXMucHJlc2VydmVEcmF3aW5nQnVmZmVyID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5jbGVhckJlZm9yZVJlbmRlciA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX2JhY2tncm91bmRDb2xvciA9IDA7XHJcbiAgICAgICAgdGhpcy5fYmFja2dyb3VuZENvbG9yUmdiYSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5fYmFja2dyb3VuZENvbG9yU3RyaW5nID0gbnVsbDtcclxuICAgICAgICB0aGlzLl90ZW1wRGlzcGxheU9iamVjdFBhcmVudCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5fbGFzdE9iamVjdFJlbmRlcmVkID0gbnVsbDtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGJhY2tncm91bmQgY29sb3IgdG8gZmlsbCBpZiBub3QgdHJhbnNwYXJlbnRcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIGdldCBiYWNrZ3JvdW5kQ29sb3IoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2JhY2tncm91bmRDb2xvcjtcclxuICAgIH1cclxuICAgIDtcclxuICAgIHNldCBiYWNrZ3JvdW5kQ29sb3IodmFsdWUpIHtcclxuICAgICAgICB0aGlzLl9iYWNrZ3JvdW5kQ29sb3IgPSB2YWx1ZTtcclxuICAgICAgICB0aGlzLl9iYWNrZ3JvdW5kQ29sb3JTdHJpbmcgPSBNYXRoU2V0dGluZ3NfMS5NYXRoU2V0dGluZ3MuaGV4MnN0cmluZyh2YWx1ZSk7XHJcbiAgICAgICAgQ29sb3JTZXR0aW5nc18xLkNvbG9yU2V0dGluZ3MuaGV4MnJnYih2YWx1ZSwgdGhpcy5fYmFja2dyb3VuZENvbG9yUmdiYSk7XHJcbiAgICB9XHJcbiAgICA7XHJcbn1cclxuQWJzdHJhY3RSZW5kZXJlci50ZW1wTWF0cml4ID0gbmV3IE1hdHJpeF8xLk1hdHJpeCgpO1xyXG5leHBvcnRzLkFic3RyYWN0UmVuZGVyZXIgPSBBYnN0cmFjdFJlbmRlcmVyO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4vLyBpbXBvcnQgeyBzZXR0aW5ncyB9IGZyb20gJy4vc2V0dGluZ3MnO1xyXG5jb25zdCBVdGlsc1NldHRpbmdzXzEgPSByZXF1aXJlKFwiLi9VdGlsc1NldHRpbmdzXCIpO1xyXG5jbGFzcyBBY2Nlc3NpYmlsaXR5TWFuYWdlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihyZW5kZXJlcikge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQHR5cGUgez9IVE1MRWxlbWVudH1cclxuICAgICAgICAgICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLl9ob29rRGl2ID0gbnVsbDtcclxuICAgICAgICAvLyBpZiAoc2V0dGluZ3MuaXNNb2JpbGVfbWluLnRhYmxldCB8fCBzZXR0aW5ncy5pc01vYmlsZV9taW4ucGhvbmUpXHJcbiAgICAgICAgLy8ge1xyXG4gICAgICAgIHRoaXMuY3JlYXRlVG91Y2hIb29rKCk7XHJcbiAgICAgICAgLy8gfVxyXG4gICAgICAgIC8vIGZpcnN0IHdlIGNyZWF0ZSBhIGRpdiB0aGF0IHdpbGwgc2l0IG92ZXIgdGhlIFBpeGlKUyBlbGVtZW50LiBUaGlzIGlzIHdoZXJlIHRoZSBkaXYgb3ZlcmxheXMgd2lsbCBnby5cclxuICAgICAgICB2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgICAgZGl2LnN0eWxlLndpZHRoID0gQWNjZXNzaWJpbGl0eU1hbmFnZXIuRElWX1RPVUNIX1NJWkUgKyBcInB4XCI7XHJcbiAgICAgICAgZGl2LnN0eWxlLmhlaWdodCA9IEFjY2Vzc2liaWxpdHlNYW5hZ2VyLkRJVl9UT1VDSF9TSVpFICsgXCJweFwiO1xyXG4gICAgICAgIGRpdi5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XHJcbiAgICAgICAgZGl2LnN0eWxlLnRvcCA9IEFjY2Vzc2liaWxpdHlNYW5hZ2VyLkRJVl9UT1VDSF9QT1NfWCArIFwicHhcIjtcclxuICAgICAgICBkaXYuc3R5bGUubGVmdCA9IEFjY2Vzc2liaWxpdHlNYW5hZ2VyLkRJVl9UT1VDSF9QT1NfWSArIFwicHhcIjtcclxuICAgICAgICBkaXYuc3R5bGUuekluZGV4ID0gQWNjZXNzaWJpbGl0eU1hbmFnZXIuRElWX1RPVUNIX1pJTkRFWC50b1N0cmluZygpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoaXMgaXMgdGhlIGRvbSBlbGVtZW50IHRoYXQgd2lsbCBzaXQgb3ZlciB0aGUgUGl4aUpTIGVsZW1lbnQuIFRoaXMgaXMgd2hlcmUgdGhlIGRpdiBvdmVybGF5cyB3aWxsIGdvLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHR5cGUge0hUTUxFbGVtZW50fVxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5kaXYgPSBkaXY7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQSBzaW1wbGUgcG9vbCBmb3Igc3RvcmluZyBkaXZzLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHR5cGUgeyp9XHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnBvb2wgPSBbXTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGlzIGlzIGEgdGljayB1c2VkIHRvIGNoZWNrIGlmIGFuIG9iamVjdCBpcyBubyBsb25nZXIgYmVpbmcgcmVuZGVyZWQuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5yZW5kZXJJZCA9IDA7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2V0dGluZyB0aGlzIHRvIHRydWUgd2lsbCB2aXN1YWxseSBzaG93IHRoZSBkaXZzLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5kZWJ1ZyA9IGZhbHNlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSByZW5kZXJlciB0aGlzIGFjY2Vzc2liaWxpdHkgbWFuYWdlciB3b3JrcyBmb3IuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLkFic3RyYWN0UmVuZGVyZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBhcnJheSBvZiBjdXJyZW50bHkgYWN0aXZlIGFjY2Vzc2libGUgaXRlbXMuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAbWVtYmVyIHtBcnJheTwqPn1cclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBbXTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBwcmUtYmluZCB0aGUgZnVuY3Rpb25zXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLl9vbktleURvd24gPSB0aGlzLl9vbktleURvd24uYmluZCh0aGlzKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBwcmUtYmluZCB0aGUgZnVuY3Rpb25zXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLl9vbk1vdXNlTW92ZSA9IHRoaXMuX29uTW91c2VNb3ZlLmJpbmQodGhpcyk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQSBmbGFnXHJcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgICAgICogQHJlYWRvbmx5XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5pc0FjdGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEEgZmxhZ1xyXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAgICAgICAqIEByZWFkb25seVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuaXNNb2JpbGVBY2Nlc3NpYmlsaXR5ID0gZmFsc2U7XHJcbiAgICAgICAgLy8gbGV0IGxpc3RlbiBmb3IgdGFiLi4gb25jZSBwcmVzc2VkIHdlIGNhbiBmaXJlIHVwIGFuZCBzaG93IHRoZSBhY2Nlc3NpYmlsaXR5IGxheWVyXHJcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLl9vbktleURvd24sIGZhbHNlKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyB0aGUgdG91Y2ggaG9va3MuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgY3JlYXRlVG91Y2hIb29rKCkge1xyXG4gICAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xyXG4gICAgICAgIHZhciBob29rRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnV0dG9uJyk7XHJcbiAgICAgICAgaG9va0Rpdi5zdHlsZS53aWR0aCA9IEFjY2Vzc2liaWxpdHlNYW5hZ2VyLkRJVl9IT09LX1NJWkUgKyBcInB4XCI7XHJcbiAgICAgICAgaG9va0Rpdi5zdHlsZS5oZWlnaHQgPSBBY2Nlc3NpYmlsaXR5TWFuYWdlci5ESVZfSE9PS19TSVpFICsgXCJweFwiO1xyXG4gICAgICAgIGhvb2tEaXYuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xyXG4gICAgICAgIGhvb2tEaXYuc3R5bGUudG9wID0gQWNjZXNzaWJpbGl0eU1hbmFnZXIuRElWX0hPT0tfUE9TX1ggKyBcInB4XCI7XHJcbiAgICAgICAgaG9va0Rpdi5zdHlsZS5sZWZ0ID0gQWNjZXNzaWJpbGl0eU1hbmFnZXIuRElWX0hPT0tfUE9TX1kgKyBcInB4XCI7XHJcbiAgICAgICAgaG9va0Rpdi5zdHlsZS56SW5kZXggPSBBY2Nlc3NpYmlsaXR5TWFuYWdlci5ESVZfSE9PS19aSU5ERVgudG9TdHJpbmcoKTtcclxuICAgICAgICBob29rRGl2LnN0eWxlLmJhY2tncm91bmRDb2xvciA9ICcjRkYwMDAwJztcclxuICAgICAgICBob29rRGl2LnRpdGxlID0gJ0hPT0sgRElWJztcclxuICAgICAgICBob29rRGl2LmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzJDEuaXNNb2JpbGVBY2Nlc3NpYmlsaXR5ID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcyQxLmFjdGl2YXRlKCk7XHJcbiAgICAgICAgICAgIHRoaXMkMS5kZXN0cm95VG91Y2hIb29rKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChob29rRGl2KTtcclxuICAgICAgICB0aGlzLl9ob29rRGl2ID0gaG9va0RpdjtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogRGVzdHJveXMgdGhlIHRvdWNoIGhvb2tzLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIGRlc3Ryb3lUb3VjaEhvb2soKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9ob29rRGl2KSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZCh0aGlzLl9ob29rRGl2KTtcclxuICAgICAgICB0aGlzLl9ob29rRGl2ID0gbnVsbDtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQWN0aXZhdGluZyB3aWxsIGNhdXNlIHRoZSBBY2Nlc3NpYmlsaXR5IGxheWVyIHRvIGJlIHNob3duLlxyXG4gICAgICogVGhpcyBpcyBjYWxsZWQgd2hlbiBhIHVzZXIgcHJlc3NlcyB0aGUgdGFiIGtleS5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBhY3RpdmF0ZSgpIHtcclxuICAgICAgICBpZiAodGhpcy5pc0FjdGl2ZSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuaXNBY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgIHdpbmRvdy5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLl9vbk1vdXNlTW92ZSwgdHJ1ZSk7XHJcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLl9vbktleURvd24sIGZhbHNlKTtcclxuICAgICAgICB0aGlzLnJlbmRlcmVyLm9uKCdwb3N0cmVuZGVyJywgdGhpcy51cGRhdGUsIHRoaXMpO1xyXG4gICAgICAgIGlmICh0aGlzLnJlbmRlcmVyLnZpZXcucGFyZW50Tm9kZSkge1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnZpZXcucGFyZW50Tm9kZS5hcHBlbmRDaGlsZCh0aGlzLmRpdik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBEZWFjdGl2YXRpbmcgd2lsbCBjYXVzZSB0aGUgQWNjZXNzaWJpbGl0eSBsYXllciB0byBiZSBoaWRkZW4uXHJcbiAgICAgKiBUaGlzIGlzIGNhbGxlZCB3aGVuIGEgdXNlciBtb3ZlcyB0aGUgbW91c2UuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgZGVhY3RpdmF0ZSgpIHtcclxuICAgICAgICBpZiAoIXRoaXMuaXNBY3RpdmUgfHwgdGhpcy5pc01vYmlsZUFjY2Vzc2liaWxpdHkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmlzQWN0aXZlID0gZmFsc2U7XHJcbiAgICAgICAgd2luZG93LmRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMuX29uTW91c2VNb3ZlLCB0cnVlKTtcclxuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuX29uS2V5RG93biwgZmFsc2UpO1xyXG4gICAgICAgIHRoaXMucmVuZGVyZXIub2ZmKCdwb3N0cmVuZGVyJywgdGhpcy51cGRhdGUpO1xyXG4gICAgICAgIGlmICh0aGlzLmRpdi5wYXJlbnROb2RlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGl2LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5kaXYpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogVGhpcyByZWN1cnNpdmUgZnVuY3Rpb24gd2lsbCBydW4gdGhyb3VnaCB0aGUgc2NlbmUgZ3JhcGggYW5kIGFkZCBhbnkgbmV3IGFjY2Vzc2libGUgb2JqZWN0cyB0byB0aGUgRE9NIGxheWVyLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge1BJWEkuQ29udGFpbmVyfSBkaXNwbGF5T2JqZWN0IC0gVGhlIERpc3BsYXlPYmplY3QgdG8gY2hlY2suXHJcbiAgICAgKi9cclxuICAgIHVwZGF0ZUFjY2Vzc2libGVPYmplY3RzKGRpc3BsYXlPYmplY3QpIHtcclxuICAgICAgICBpZiAoIWRpc3BsYXlPYmplY3QudmlzaWJsZSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChkaXNwbGF5T2JqZWN0LmFjY2Vzc2libGUgJiYgZGlzcGxheU9iamVjdC5pbnRlcmFjdGl2ZSkge1xyXG4gICAgICAgICAgICBpZiAoIWRpc3BsYXlPYmplY3QuX2FjY2Vzc2libGVBY3RpdmUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYWRkQ2hpbGQoZGlzcGxheU9iamVjdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZGlzcGxheU9iamVjdC5yZW5kZXJJZCA9IHRoaXMucmVuZGVySWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBjaGlsZHJlbiA9IGRpc3BsYXlPYmplY3QuY2hpbGRyZW47XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUFjY2Vzc2libGVPYmplY3RzKGNoaWxkcmVuW2ldKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIEJlZm9yZSBlYWNoIHJlbmRlciB0aGlzIGZ1bmN0aW9uIHdpbGwgZW5zdXJlIHRoYXQgYWxsIGRpdnMgYXJlIG1hcHBlZCBjb3JyZWN0bHkgdG8gdGhlaXIgRGlzcGxheU9iamVjdHMuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgdXBkYXRlKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5yZW5kZXJlci5yZW5kZXJpbmdUb1NjcmVlbikge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHVwZGF0ZSBjaGlsZHJlbi4uLlxyXG4gICAgICAgIHRoaXMudXBkYXRlQWNjZXNzaWJsZU9iamVjdHModGhpcy5yZW5kZXJlci5fbGFzdE9iamVjdFJlbmRlcmVkKTtcclxuICAgICAgICB2YXIgcmVjdCA9IHRoaXMucmVuZGVyZXIudmlldy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgICAgICB2YXIgc3ggPSByZWN0LndpZHRoIC8gdGhpcy5yZW5kZXJlci53aWR0aDtcclxuICAgICAgICB2YXIgc3kgPSByZWN0LmhlaWdodCAvIHRoaXMucmVuZGVyZXIuaGVpZ2h0O1xyXG4gICAgICAgIHZhciBkaXYgPSB0aGlzLmRpdjtcclxuICAgICAgICBkaXYuc3R5bGUubGVmdCA9IChyZWN0LmxlZnQpICsgXCJweFwiO1xyXG4gICAgICAgIGRpdi5zdHlsZS50b3AgPSAocmVjdC50b3ApICsgXCJweFwiO1xyXG4gICAgICAgIGRpdi5zdHlsZS53aWR0aCA9ICh0aGlzLnJlbmRlcmVyLndpZHRoKSArIFwicHhcIjtcclxuICAgICAgICBkaXYuc3R5bGUuaGVpZ2h0ID0gKHRoaXMucmVuZGVyZXIuaGVpZ2h0KSArIFwicHhcIjtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXTtcclxuICAgICAgICAgICAgaWYgKGNoaWxkLnJlbmRlcklkICE9PSB0aGlzLnJlbmRlcklkKSB7XHJcbiAgICAgICAgICAgICAgICBjaGlsZC5fYWNjZXNzaWJsZUFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgVXRpbHNTZXR0aW5nc18xLlV0aWxzU2V0dGluZ3MucmVtb3ZlSXRlbXModGhpcy5jaGlsZHJlbiwgaSwgMSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRpdi5yZW1vdmVDaGlsZChjaGlsZC5fYWNjZXNzaWJsZURpdik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBvb2wucHVzaChjaGlsZC5fYWNjZXNzaWJsZURpdik7XHJcbiAgICAgICAgICAgICAgICBjaGlsZC5fYWNjZXNzaWJsZURpdiA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICBpLS07XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jaGlsZHJlbi5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlYWN0aXZhdGUoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIG1hcCBkaXYgdG8gZGlzcGxheS4uXHJcbiAgICAgICAgICAgICAgICBkaXYgPSBjaGlsZC5fYWNjZXNzaWJsZURpdjtcclxuICAgICAgICAgICAgICAgIHZhciBoaXRBcmVhID0gY2hpbGQuaGl0QXJlYTtcclxuICAgICAgICAgICAgICAgIHZhciB3dCA9IGNoaWxkLndvcmxkVHJhbnNmb3JtO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLmhpdEFyZWEpIHtcclxuICAgICAgICAgICAgICAgICAgICBkaXYuc3R5bGUubGVmdCA9ICgod3QudHggKyAoaGl0QXJlYS54ICogd3QuYSkpICogc3gpICsgXCJweFwiO1xyXG4gICAgICAgICAgICAgICAgICAgIGRpdi5zdHlsZS50b3AgPSAoKHd0LnR5ICsgKGhpdEFyZWEueSAqIHd0LmQpKSAqIHN5KSArIFwicHhcIjtcclxuICAgICAgICAgICAgICAgICAgICBkaXYuc3R5bGUud2lkdGggPSAoaGl0QXJlYS53aWR0aCAqIHd0LmEgKiBzeCkgKyBcInB4XCI7XHJcbiAgICAgICAgICAgICAgICAgICAgZGl2LnN0eWxlLmhlaWdodCA9IChoaXRBcmVhLmhlaWdodCAqIHd0LmQgKiBzeSkgKyBcInB4XCI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBoaXRBcmVhID0gY2hpbGQuZ2V0Qm91bmRzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYXBIaXRBcmVhKGhpdEFyZWEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGRpdi5zdHlsZS5sZWZ0ID0gKGhpdEFyZWEueCAqIHN4KSArIFwicHhcIjtcclxuICAgICAgICAgICAgICAgICAgICBkaXYuc3R5bGUudG9wID0gKGhpdEFyZWEueSAqIHN5KSArIFwicHhcIjtcclxuICAgICAgICAgICAgICAgICAgICBkaXYuc3R5bGUud2lkdGggPSAoaGl0QXJlYS53aWR0aCAqIHN4KSArIFwicHhcIjtcclxuICAgICAgICAgICAgICAgICAgICBkaXYuc3R5bGUuaGVpZ2h0ID0gKGhpdEFyZWEuaGVpZ2h0ICogc3kpICsgXCJweFwiO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSBidXR0b24gdGl0bGVzIGFuZCBoaW50cyBpZiB0aGV5IGV4aXN0IGFuZCB0aGV5J3ZlIGNoYW5nZWRcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZGl2LnRpdGxlICE9PSBjaGlsZC5hY2Nlc3NpYmxlVGl0bGUgJiYgY2hpbGQuYWNjZXNzaWJsZVRpdGxlICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpdi50aXRsZSA9IGNoaWxkLmFjY2Vzc2libGVUaXRsZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRpdi5nZXRBdHRyaWJ1dGUoJ2FyaWEtbGFiZWwnKSAhPT0gY2hpbGQuYWNjZXNzaWJsZUhpbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgJiYgY2hpbGQuYWNjZXNzaWJsZUhpbnQgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGl2LnNldEF0dHJpYnV0ZSgnYXJpYS1sYWJlbCcsIGNoaWxkLmFjY2Vzc2libGVIaW50KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gaW5jcmVtZW50IHRoZSByZW5kZXIgaWQuLlxyXG4gICAgICAgIHRoaXMucmVuZGVySWQrKztcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQWRqdXN0IHRoZSBoaXQgYXJlYSBiYXNlZCBvbiB0aGUgYm91bmRzIG9mIGEgZGlzcGxheSBvYmplY3RcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1JlY3RhbmdsZX0gaGl0QXJlYSAtIEJvdW5kcyBvZiB0aGUgY2hpbGRcclxuICAgICAqL1xyXG4gICAgY2FwSGl0QXJlYShoaXRBcmVhKSB7XHJcbiAgICAgICAgaWYgKGhpdEFyZWEueCA8IDApIHtcclxuICAgICAgICAgICAgaGl0QXJlYS53aWR0aCArPSBoaXRBcmVhLng7XHJcbiAgICAgICAgICAgIGhpdEFyZWEueCA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChoaXRBcmVhLnkgPCAwKSB7XHJcbiAgICAgICAgICAgIGhpdEFyZWEuaGVpZ2h0ICs9IGhpdEFyZWEueTtcclxuICAgICAgICAgICAgaGl0QXJlYS55ID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGhpdEFyZWEueCArIGhpdEFyZWEud2lkdGggPiB0aGlzLnJlbmRlcmVyLndpZHRoKSB7XHJcbiAgICAgICAgICAgIGhpdEFyZWEud2lkdGggPSB0aGlzLnJlbmRlcmVyLndpZHRoIC0gaGl0QXJlYS54O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaGl0QXJlYS55ICsgaGl0QXJlYS5oZWlnaHQgPiB0aGlzLnJlbmRlcmVyLmhlaWdodCkge1xyXG4gICAgICAgICAgICBoaXRBcmVhLmhlaWdodCA9IHRoaXMucmVuZGVyZXIuaGVpZ2h0IC0gaGl0QXJlYS55O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhIERpc3BsYXlPYmplY3QgdG8gdGhlIGFjY2Vzc2liaWxpdHkgbWFuYWdlclxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge0Rpc3BsYXlPYmplY3R9IGRpc3BsYXlPYmplY3QgLSBUaGUgY2hpbGQgdG8gbWFrZSBhY2Nlc3NpYmxlLlxyXG4gICAgICovXHJcbiAgICBhZGRDaGlsZChkaXNwbGF5T2JqZWN0KSB7XHJcbiAgICAgICAgLy90aGlzLmFjdGl2YXRlKCk7XHJcbiAgICAgICAgdmFyIGRpdiA9IHRoaXMucG9vbC5wb3AoKTtcclxuICAgICAgICBpZiAoIWRpdikge1xyXG4gICAgICAgICAgICBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKTtcclxuICAgICAgICAgICAgZGl2LnN0eWxlLndpZHRoID0gQWNjZXNzaWJpbGl0eU1hbmFnZXIuRElWX1RPVUNIX1NJWkUgKyBcInB4XCI7XHJcbiAgICAgICAgICAgIGRpdi5zdHlsZS5oZWlnaHQgPSBBY2Nlc3NpYmlsaXR5TWFuYWdlci5ESVZfVE9VQ0hfU0laRSArIFwicHhcIjtcclxuICAgICAgICAgICAgZGl2LnN0eWxlLmJhY2tncm91bmRDb2xvciA9IHRoaXMuZGVidWcgPyAncmdiYSgyNTUsMCwwLDAuNSknIDogJ3RyYW5zcGFyZW50JztcclxuICAgICAgICAgICAgZGl2LnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcclxuICAgICAgICAgICAgZGl2LnN0eWxlLnpJbmRleCA9IEFjY2Vzc2liaWxpdHlNYW5hZ2VyLkRJVl9UT1VDSF9aSU5ERVg7XHJcbiAgICAgICAgICAgIGRpdi5zdHlsZS5ib3JkZXJTdHlsZSA9ICdub25lJztcclxuICAgICAgICAgICAgLy8gQVJJQSBhdHRyaWJ1dGVzIGVuc3VyZSB0aGF0IGJ1dHRvbiB0aXRsZSBhbmQgaGludCB1cGRhdGVzIGFyZSBhbm5vdW5jZWQgcHJvcGVybHlcclxuICAgICAgICAgICAgaWYgKG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5pbmRleE9mKCdjaHJvbWUnKSA+IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBDaHJvbWUgZG9lc24ndCBuZWVkIGFyaWEtbGl2ZSB0byB3b3JrIGFzIGludGVuZGVkOyBpbiBmYWN0IGl0IGp1c3QgZ2V0cyBtb3JlIGNvbmZ1c2VkLlxyXG4gICAgICAgICAgICAgICAgZGl2LnNldEF0dHJpYnV0ZSgnYXJpYS1saXZlJywgJ29mZicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZGl2LnNldEF0dHJpYnV0ZSgnYXJpYS1saXZlJywgJ3BvbGl0ZScpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9ydjouKkdlY2tvXFwvLykpIHtcclxuICAgICAgICAgICAgICAgIC8vIEZpcmVGb3ggbmVlZHMgdGhpcyB0byBhbm5vdW5jZSBvbmx5IHRoZSBuZXcgYnV0dG9uIG5hbWVcclxuICAgICAgICAgICAgICAgIGRpdi5zZXRBdHRyaWJ1dGUoJ2FyaWEtcmVsZXZhbnQnLCAnYWRkaXRpb25zJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyByZXF1aXJlZCBieSBJRSwgb3RoZXIgYnJvd3NlcnMgZG9uJ3QgbXVjaCBjYXJlXHJcbiAgICAgICAgICAgICAgICBkaXYuc2V0QXR0cmlidXRlKCdhcmlhLXJlbGV2YW50JywgJ3RleHQnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBkaXYuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9vbkNsaWNrLmJpbmQodGhpcykpO1xyXG4gICAgICAgICAgICBkaXYuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXMnLCB0aGlzLl9vbkZvY3VzLmJpbmQodGhpcykpO1xyXG4gICAgICAgICAgICBkaXYuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXNvdXQnLCB0aGlzLl9vbkZvY3VzT3V0LmJpbmQodGhpcykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZGlzcGxheU9iamVjdC5hY2Nlc3NpYmxlVGl0bGUgJiYgZGlzcGxheU9iamVjdC5hY2Nlc3NpYmxlVGl0bGUgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgZGl2LnRpdGxlID0gZGlzcGxheU9iamVjdC5hY2Nlc3NpYmxlVGl0bGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKCFkaXNwbGF5T2JqZWN0LmFjY2Vzc2libGVIaW50XHJcbiAgICAgICAgICAgIHx8IGRpc3BsYXlPYmplY3QuYWNjZXNzaWJsZUhpbnQgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgZGl2LnRpdGxlID0gXCJkaXNwbGF5T2JqZWN0IFwiICsgKGRpc3BsYXlPYmplY3QudGFiSW5kZXgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZGlzcGxheU9iamVjdC5hY2Nlc3NpYmxlSGludFxyXG4gICAgICAgICAgICAmJiBkaXNwbGF5T2JqZWN0LmFjY2Vzc2libGVIaW50ICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGRpdi5zZXRBdHRyaWJ1dGUoJ2FyaWEtbGFiZWwnLCBkaXNwbGF5T2JqZWN0LmFjY2Vzc2libGVIaW50KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy9cclxuICAgICAgICBkaXNwbGF5T2JqZWN0Ll9hY2Nlc3NpYmxlQWN0aXZlID0gdHJ1ZTtcclxuICAgICAgICBkaXNwbGF5T2JqZWN0Ll9hY2Nlc3NpYmxlRGl2ID0gZGl2O1xyXG4gICAgICAgIGRpdi5kaXNwbGF5T2JqZWN0ID0gZGlzcGxheU9iamVjdDtcclxuICAgICAgICB0aGlzLmNoaWxkcmVuLnB1c2goZGlzcGxheU9iamVjdCk7XHJcbiAgICAgICAgdGhpcy5kaXYuYXBwZW5kQ2hpbGQoZGlzcGxheU9iamVjdC5fYWNjZXNzaWJsZURpdik7XHJcbiAgICAgICAgZGlzcGxheU9iamVjdC5fYWNjZXNzaWJsZURpdi50YWJJbmRleCA9IGRpc3BsYXlPYmplY3QudGFiSW5kZXg7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIE1hcHMgdGhlIGRpdiBidXR0b24gcHJlc3MgdG8gcGl4aSdzICAoY2xpY2spXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7TW91c2VFdmVudH0gZSAtIFRoZSBjbGljayBldmVudC5cclxuICAgICAqL1xyXG4gICAgX29uQ2xpY2soZSkge1xyXG4gICAgICAgIHZhciBpbnRlcmFjdGlvbk1hbmFnZXIgPSB0aGlzLnJlbmRlcmVyLnBsdWdpbnMuaW50ZXJhY3Rpb247XHJcbiAgICAgICAgaW50ZXJhY3Rpb25NYW5hZ2VyLmRpc3BhdGNoRXZlbnQoZS50YXJnZXQuZGlzcGxheU9iamVjdCwgJ2NsaWNrJywgaW50ZXJhY3Rpb25NYW5hZ2VyLmV2ZW50RGF0YSk7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIE1hcHMgdGhlIGRpdiBmb2N1cyBldmVudHMgdG8gcGl4aSdzICAobW91c2VvdmVyKVxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge0ZvY3VzRXZlbnR9IGUgLSBUaGUgZm9jdXMgZXZlbnQuXHJcbiAgICAgKi9cclxuICAgIF9vbkZvY3VzKGUpIHtcclxuICAgICAgICBpZiAoIWUudGFyZ2V0LmdldEF0dHJpYnV0ZSgnYXJpYS1saXZlJywgJ29mZicpKSB7XHJcbiAgICAgICAgICAgIGUudGFyZ2V0LnNldEF0dHJpYnV0ZSgnYXJpYS1saXZlJywgJ2Fzc2VydGl2ZScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgaW50ZXJhY3Rpb25NYW5hZ2VyID0gdGhpcy5yZW5kZXJlci5wbHVnaW5zLmludGVyYWN0aW9uO1xyXG4gICAgICAgIGludGVyYWN0aW9uTWFuYWdlci5kaXNwYXRjaEV2ZW50KGUudGFyZ2V0LmRpc3BsYXlPYmplY3QsICdtb3VzZW92ZXInLCBpbnRlcmFjdGlvbk1hbmFnZXIuZXZlbnREYXRhKTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogTWFwcyB0aGUgZGl2IGZvY3VzIGV2ZW50cyB0byBwaXhpJ3MgIChtb3VzZW91dClcclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtGb2N1c0V2ZW50fSBlIC0gVGhlIGZvY3Vzb3V0IGV2ZW50LlxyXG4gICAgICovXHJcbiAgICBfb25Gb2N1c091dChlKSB7XHJcbiAgICAgICAgaWYgKCFlLnRhcmdldC5nZXRBdHRyaWJ1dGUoJ2FyaWEtbGl2ZScsICdvZmYnKSkge1xyXG4gICAgICAgICAgICBlLnRhcmdldC5zZXRBdHRyaWJ1dGUoJ2FyaWEtbGl2ZScsICdwb2xpdGUnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGludGVyYWN0aW9uTWFuYWdlciA9IHRoaXMucmVuZGVyZXIucGx1Z2lucy5pbnRlcmFjdGlvbjtcclxuICAgICAgICBpbnRlcmFjdGlvbk1hbmFnZXIuZGlzcGF0Y2hFdmVudChlLnRhcmdldC5kaXNwbGF5T2JqZWN0LCAnbW91c2VvdXQnLCBpbnRlcmFjdGlvbk1hbmFnZXIuZXZlbnREYXRhKTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogSXMgY2FsbGVkIHdoZW4gYSBrZXkgaXMgcHJlc3NlZFxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge0tleWJvYXJkRXZlbnR9IGUgLSBUaGUga2V5ZG93biBldmVudC5cclxuICAgICAqL1xyXG4gICAgX29uS2V5RG93bihlKSB7XHJcbiAgICAgICAgaWYgKGUua2V5Q29kZSAhPT0gQWNjZXNzaWJpbGl0eU1hbmFnZXIuS0VZX0NPREVfVEFCKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5hY3RpdmF0ZSgpO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBJcyBjYWxsZWQgd2hlbiB0aGUgbW91c2UgbW92ZXMgYWNyb3NzIHRoZSByZW5kZXJlciBlbGVtZW50XHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7TW91c2VFdmVudH0gZSAtIFRoZSBtb3VzZSBldmVudC5cclxuICAgICAqL1xyXG4gICAgX29uTW91c2VNb3ZlKGUpIHtcclxuICAgICAgICBpZiAoZS5tb3ZlbWVudFggPT09IDAgJiYgZS5tb3ZlbWVudFkgPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmRlYWN0aXZhdGUoKTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogRGVzdHJveXMgdGhlIGFjY2Vzc2liaWxpdHkgbWFuYWdlclxyXG4gICAgICpcclxuICAgICAqL1xyXG4gICAgZGVzdHJveSgpIHtcclxuICAgICAgICB0aGlzLmRlc3Ryb3lUb3VjaEhvb2soKTtcclxuICAgICAgICB0aGlzLmRpdiA9IG51bGw7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW5baV0uZGl2ID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgd2luZG93LmRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMuX29uTW91c2VNb3ZlLCB0cnVlKTtcclxuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuX29uS2V5RG93bik7XHJcbiAgICAgICAgdGhpcy5wb29sID0gbnVsbDtcclxuICAgICAgICB0aGlzLmNoaWxkcmVuID0gbnVsbDtcclxuICAgICAgICB0aGlzLnJlbmRlcmVyID0gbnVsbDtcclxuICAgIH1cclxuICAgIDtcclxufVxyXG5BY2Nlc3NpYmlsaXR5TWFuYWdlci5ESVZfSE9PS19TSVpFID0gMTtcclxuQWNjZXNzaWJpbGl0eU1hbmFnZXIuRElWX0hPT0tfUE9TX1ggPSAtMTAwMDtcclxuQWNjZXNzaWJpbGl0eU1hbmFnZXIuRElWX0hPT0tfUE9TX1kgPSAtMTAwMDtcclxuQWNjZXNzaWJpbGl0eU1hbmFnZXIuRElWX0hPT0tfWklOREVYID0gMjtcclxuQWNjZXNzaWJpbGl0eU1hbmFnZXIuS0VZX0NPREVfVEFCID0gOTtcclxuQWNjZXNzaWJpbGl0eU1hbmFnZXIuRElWX1RPVUNIX1NJWkUgPSAxMDA7XHJcbkFjY2Vzc2liaWxpdHlNYW5hZ2VyLkRJVl9UT1VDSF9QT1NfWCA9IDA7XHJcbkFjY2Vzc2liaWxpdHlNYW5hZ2VyLkRJVl9UT1VDSF9QT1NfWSA9IDA7XHJcbkFjY2Vzc2liaWxpdHlNYW5hZ2VyLkRJVl9UT1VDSF9aSU5ERVggPSAyO1xyXG5leHBvcnRzLkFjY2Vzc2liaWxpdHlNYW5hZ2VyID0gQWNjZXNzaWJpbGl0eU1hbmFnZXI7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IFNwcml0ZV8xID0gcmVxdWlyZShcIi4vU3ByaXRlXCIpO1xyXG5jb25zdCBUZXh0dXJlXzEgPSByZXF1aXJlKFwiLi9UZXh0dXJlXCIpO1xyXG5jb25zdCBUaWNrZXJfMSA9IHJlcXVpcmUoXCIuL1RpY2tlclwiKTtcclxuY2xhc3MgQW5pbWF0ZWRTcHJpdGUgZXh0ZW5kcyBTcHJpdGVfMS5TcHJpdGUge1xyXG4gICAgY29uc3RydWN0b3IodGV4dHVyZXMsIGF1dG9VcGRhdGUgPSB0cnVlKSB7XHJcbiAgICAgICAgc3VwZXIodGV4dHVyZXNbMF0gaW5zdGFuY2VvZiBUZXh0dXJlXzEuVGV4dHVyZSA/IHRleHR1cmVzWzBdIDogdGV4dHVyZXNbMF0udGV4dHVyZSk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHR5cGUge1BJWEkuVGV4dHVyZVtdfVxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5fdGV4dHVyZXMgPSBudWxsO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJbXX1cclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuX2R1cmF0aW9ucyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy50ZXh0dXJlcyA9IHRleHR1cmVzO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIGB0cnVlYCB1c2VzIFBJWEkuVGlja2VyLnNoYXJlZCB0byBhdXRvIHVwZGF0ZSBhbmltYXRpb24gdGltZS5cclxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgICAgICAgKiBAZGVmYXVsdCB0cnVlXHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLl9hdXRvVXBkYXRlID0gYXV0b1VwZGF0ZSAhPT0gZmFsc2U7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIHNwZWVkIHRoYXQgdGhlIEFuaW1hdGVkU3ByaXRlIHdpbGwgcGxheSBhdC4gSGlnaGVyIGlzIGZhc3RlciwgbG93ZXIgaXMgc2xvd2VyLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICAgICAqIEBkZWZhdWx0IDFcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmFuaW1hdGlvblNwZWVkID0gMTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBXaGV0aGVyIG9yIG5vdCB0aGUgYW5pbWF0ZSBzcHJpdGUgcmVwZWF0cyBhZnRlciBwbGF5aW5nLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQG1lbWJlciB7Ym9vbGVhbn1cclxuICAgICAgICAgKiBAZGVmYXVsdCB0cnVlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5sb29wID0gdHJ1ZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBVcGRhdGUgYW5jaG9yIHRvIFtUZXh0dXJlJ3MgZGVmYXVsdEFuY2hvcl17QGxpbmsgUElYSS5UZXh0dXJlI2RlZmF1bHRBbmNob3J9IHdoZW4gZnJhbWUgY2hhbmdlcy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIFVzZWZ1bCB3aXRoIFtzcHJpdGUgc2hlZXQgYW5pbWF0aW9uc117QGxpbmsgUElYSS5TcHJpdGVzaGVldCNhbmltYXRpb25zfSBjcmVhdGVkIHdpdGggdG9vbHMuXHJcbiAgICAgICAgICogQ2hhbmdpbmcgYW5jaG9yIGZvciBlYWNoIGZyYW1lIGFsbG93cyB0byBwaW4gc3ByaXRlIG9yaWdpbiB0byBjZXJ0YWluIG1vdmluZyBmZWF0dXJlXHJcbiAgICAgICAgICogb2YgdGhlIGZyYW1lIChlLmcuIGxlZnQgZm9vdCkuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBOb3RlOiBFbmFibGluZyB0aGlzIHdpbGwgb3ZlcnJpZGUgYW55IHByZXZpb3VzbHkgc2V0IGBhbmNob3JgIG9uIGVhY2ggZnJhbWUgY2hhbmdlLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQG1lbWJlciB7Ym9vbGVhbn1cclxuICAgICAgICAgKiBAZGVmYXVsdCBmYWxzZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMudXBkYXRlQW5jaG9yID0gZmFsc2U7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRnVuY3Rpb24gdG8gY2FsbCB3aGVuIGEgQW5pbWF0ZWRTcHJpdGUgZmluaXNoZXMgcGxheWluZy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBtZW1iZXIge0Z1bmN0aW9ufVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMub25Db21wbGV0ZSA9IG51bGw7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRnVuY3Rpb24gdG8gY2FsbCB3aGVuIGEgQW5pbWF0ZWRTcHJpdGUgY2hhbmdlcyB3aGljaCB0ZXh0dXJlIGlzIGJlaW5nIHJlbmRlcmVkLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQG1lbWJlciB7RnVuY3Rpb259XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5vbkZyYW1lQ2hhbmdlID0gbnVsbDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBGdW5jdGlvbiB0byBjYWxsIHdoZW4gYGxvb3BgIGlzIHRydWUsIGFuZCBhbiBBbmltYXRlZFNwcml0ZSBpcyBwbGF5ZWQgYW5kIGxvb3BzIGFyb3VuZCB0byBzdGFydCBhZ2Fpbi5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBtZW1iZXIge0Z1bmN0aW9ufVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMub25Mb29wID0gbnVsbDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBFbGFwc2VkIHRpbWUgc2luY2UgYW5pbWF0aW9uIGhhcyBiZWVuIHN0YXJ0ZWQsIHVzZWQgaW50ZXJuYWxseSB0byBkaXNwbGF5IGN1cnJlbnQgdGV4dHVyZS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuX2N1cnJlbnRUaW1lID0gMDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJbmRpY2F0ZXMgaWYgdGhlIEFuaW1hdGVkU3ByaXRlIGlzIGN1cnJlbnRseSBwbGF5aW5nLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQG1lbWJlciB7Ym9vbGVhbn1cclxuICAgICAgICAgKiBAcmVhZG9ubHlcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnBsYXlpbmcgPSBmYWxzZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU3RvcHMgdGhlIEFuaW1hdGVkU3ByaXRlLlxyXG4gICAgICpcclxuICAgICAqL1xyXG4gICAgc3RvcCgpIHtcclxuICAgICAgICBpZiAoIXRoaXMucGxheWluZykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMucGxheWluZyA9IGZhbHNlO1xyXG4gICAgICAgIGlmICh0aGlzLl9hdXRvVXBkYXRlKSB7XHJcbiAgICAgICAgICAgIFRpY2tlcl8xLlRpY2tlci5zaGFyZWQucmVtb3ZlKHRoaXMudXBkYXRlLCB0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFBsYXlzIHRoZSBBbmltYXRlZFNwcml0ZS5cclxuICAgICAqXHJcbiAgICAgKi9cclxuICAgIHBsYXkoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMucGxheWluZykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMucGxheWluZyA9IHRydWU7XHJcbiAgICAgICAgaWYgKHRoaXMuX2F1dG9VcGRhdGUpIHtcclxuICAgICAgICAgICAgVGlja2VyXzEuVGlja2VyLnNoYXJlZC5hZGQodGhpcy51cGRhdGUsIHRoaXMsIFRpY2tlcl8xLlRpY2tlci5VUERBVEVfUFJJT1JJVFkuSElHSCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBTdG9wcyB0aGUgQW5pbWF0ZWRTcHJpdGUgYW5kIGdvZXMgdG8gYSBzcGVjaWZpYyBmcmFtZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZnJhbWVOdW1iZXIgLSBGcmFtZSBpbmRleCB0byBzdG9wIGF0LlxyXG4gICAgICovXHJcbiAgICBnb3RvQW5kU3RvcChmcmFtZU51bWJlcikge1xyXG4gICAgICAgIHRoaXMuc3RvcCgpO1xyXG4gICAgICAgIHZhciBwcmV2aW91c0ZyYW1lID0gdGhpcy5jdXJyZW50RnJhbWU7XHJcbiAgICAgICAgdGhpcy5fY3VycmVudFRpbWUgPSBmcmFtZU51bWJlcjtcclxuICAgICAgICBpZiAocHJldmlvdXNGcmFtZSAhPT0gdGhpcy5jdXJyZW50RnJhbWUpIHtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVUZXh0dXJlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBHb2VzIHRvIGEgc3BlY2lmaWMgZnJhbWUgYW5kIGJlZ2lucyBwbGF5aW5nIHRoZSBBbmltYXRlZFNwcml0ZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZnJhbWVOdW1iZXIgLSBGcmFtZSBpbmRleCB0byBzdGFydCBhdC5cclxuICAgICAqL1xyXG4gICAgZ290b0FuZFBsYXkoZnJhbWVOdW1iZXIpIHtcclxuICAgICAgICB2YXIgcHJldmlvdXNGcmFtZSA9IHRoaXMuY3VycmVudEZyYW1lO1xyXG4gICAgICAgIHRoaXMuX2N1cnJlbnRUaW1lID0gZnJhbWVOdW1iZXI7XHJcbiAgICAgICAgaWYgKHByZXZpb3VzRnJhbWUgIT09IHRoaXMuY3VycmVudEZyYW1lKSB7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVGV4dHVyZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnBsYXkoKTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyB0aGUgb2JqZWN0IHRyYW5zZm9ybSBmb3IgcmVuZGVyaW5nLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZGVsdGFUaW1lIC0gVGltZSBzaW5jZSBsYXN0IHRpY2suXHJcbiAgICAgKi9cclxuICAgIHVwZGF0ZShkZWx0YVRpbWUpIHtcclxuICAgICAgICB2YXIgZWxhcHNlZCA9IHRoaXMuYW5pbWF0aW9uU3BlZWQgKiBkZWx0YVRpbWU7XHJcbiAgICAgICAgdmFyIHByZXZpb3VzRnJhbWUgPSB0aGlzLmN1cnJlbnRGcmFtZTtcclxuICAgICAgICBpZiAodGhpcy5fZHVyYXRpb25zICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHZhciBsYWcgPSB0aGlzLl9jdXJyZW50VGltZSAlIDEgKiB0aGlzLl9kdXJhdGlvbnNbdGhpcy5jdXJyZW50RnJhbWVdO1xyXG4gICAgICAgICAgICBsYWcgKz0gZWxhcHNlZCAvIDYwICogMTAwMDtcclxuICAgICAgICAgICAgd2hpbGUgKGxhZyA8IDApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRUaW1lLS07XHJcbiAgICAgICAgICAgICAgICBsYWcgKz0gdGhpcy5fZHVyYXRpb25zW3RoaXMuY3VycmVudEZyYW1lXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgc2lnbiA9IE1hdGguc2lnbih0aGlzLmFuaW1hdGlvblNwZWVkICogZGVsdGFUaW1lKTtcclxuICAgICAgICAgICAgdGhpcy5fY3VycmVudFRpbWUgPSBNYXRoLmZsb29yKHRoaXMuX2N1cnJlbnRUaW1lKTtcclxuICAgICAgICAgICAgd2hpbGUgKGxhZyA+PSB0aGlzLl9kdXJhdGlvbnNbdGhpcy5jdXJyZW50RnJhbWVdKSB7XHJcbiAgICAgICAgICAgICAgICBsYWcgLT0gdGhpcy5fZHVyYXRpb25zW3RoaXMuY3VycmVudEZyYW1lXSAqIHNpZ247XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50VGltZSArPSBzaWduO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRUaW1lICs9IGxhZyAvIHRoaXMuX2R1cmF0aW9uc1t0aGlzLmN1cnJlbnRGcmFtZV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50VGltZSArPSBlbGFwc2VkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5fY3VycmVudFRpbWUgPCAwICYmICF0aGlzLmxvb3ApIHtcclxuICAgICAgICAgICAgdGhpcy5nb3RvQW5kU3RvcCgwKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMub25Db21wbGV0ZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vbkNvbXBsZXRlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5fY3VycmVudFRpbWUgPj0gdGhpcy5fdGV4dHVyZXMubGVuZ3RoICYmICF0aGlzLmxvb3ApIHtcclxuICAgICAgICAgICAgdGhpcy5nb3RvQW5kU3RvcCh0aGlzLl90ZXh0dXJlcy5sZW5ndGggLSAxKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMub25Db21wbGV0ZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vbkNvbXBsZXRlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAocHJldmlvdXNGcmFtZSAhPT0gdGhpcy5jdXJyZW50RnJhbWUpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMubG9vcCAmJiB0aGlzLm9uTG9vcCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYW5pbWF0aW9uU3BlZWQgPiAwICYmIHRoaXMuY3VycmVudEZyYW1lIDwgcHJldmlvdXNGcmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25Mb29wKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLmFuaW1hdGlvblNwZWVkIDwgMCAmJiB0aGlzLmN1cnJlbnRGcmFtZSA+IHByZXZpb3VzRnJhbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uTG9vcCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVGV4dHVyZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyB0aGUgZGlzcGxheWVkIHRleHR1cmUgdG8gbWF0Y2ggdGhlIGN1cnJlbnQgZnJhbWUgaW5kZXguXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgdXBkYXRlVGV4dHVyZSgpIHtcclxuICAgICAgICB0aGlzLl90ZXh0dXJlID0gdGhpcy5fdGV4dHVyZXNbdGhpcy5jdXJyZW50RnJhbWVdO1xyXG4gICAgICAgIHRoaXMuX3RleHR1cmVJRCA9IC0xO1xyXG4gICAgICAgIHRoaXMuX3RleHR1cmVUcmltbWVkSUQgPSAtMTtcclxuICAgICAgICB0aGlzLmNhY2hlZFRpbnQgPSAweEZGRkZGRjtcclxuICAgICAgICB0aGlzLnV2cyA9IHRoaXMuX3RleHR1cmUuX3V2cy51dnNGbG9hdDMyO1xyXG4gICAgICAgIGlmICh0aGlzLnVwZGF0ZUFuY2hvcikge1xyXG4gICAgICAgICAgICB0aGlzLl9hbmNob3IuY29weSh0aGlzLl90ZXh0dXJlLmRlZmF1bHRBbmNob3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5vbkZyYW1lQ2hhbmdlKSB7XHJcbiAgICAgICAgICAgIHRoaXMub25GcmFtZUNoYW5nZSh0aGlzLmN1cnJlbnRGcmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBTdG9wcyB0aGUgQW5pbWF0ZWRTcHJpdGUgYW5kIGRlc3Ryb3lzIGl0LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fGJvb2xlYW59IFtvcHRpb25zXSAtIE9wdGlvbnMgcGFyYW1ldGVyLiBBIGJvb2xlYW4gd2lsbCBhY3QgYXMgaWYgYWxsIG9wdGlvbnNcclxuICAgICAqICBoYXZlIGJlZW4gc2V0IHRvIHRoYXQgdmFsdWUuXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmNoaWxkcmVuPWZhbHNlXSAtIElmIHNldCB0byB0cnVlLCBhbGwgdGhlIGNoaWxkcmVuIHdpbGwgaGF2ZSB0aGVpciBkZXN0cm95XHJcbiAgICAgKiAgICAgIG1ldGhvZCBjYWxsZWQgYXMgd2VsbC4gJ29wdGlvbnMnIHdpbGwgYmUgcGFzc2VkIG9uIHRvIHRob3NlIGNhbGxzLlxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50ZXh0dXJlPWZhbHNlXSAtIFNob3VsZCBpdCBkZXN0cm95IHRoZSBjdXJyZW50IHRleHR1cmUgb2YgdGhlIHNwcml0ZSBhcyB3ZWxsLlxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5iYXNlVGV4dHVyZT1mYWxzZV0gLSBTaG91bGQgaXQgZGVzdHJveSB0aGUgYmFzZSB0ZXh0dXJlIG9mIHRoZSBzcHJpdGUgYXMgd2VsbC5cclxuICAgICAqL1xyXG4gICAgZGVzdHJveShvcHRpb25zKSB7XHJcbiAgICAgICAgdGhpcy5zdG9wKCk7XHJcbiAgICAgICAgU3ByaXRlXzEuU3ByaXRlLnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcywgb3B0aW9ucyk7XHJcbiAgICAgICAgdGhpcy5vbkNvbXBsZXRlID0gbnVsbDtcclxuICAgICAgICB0aGlzLm9uRnJhbWVDaGFuZ2UgPSBudWxsO1xyXG4gICAgICAgIHRoaXMub25Mb29wID0gbnVsbDtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQSBzaG9ydCBoYW5kIHdheSBvZiBjcmVhdGluZyBhIG1vdmllY2xpcCBmcm9tIGFuIGFycmF5IG9mIGZyYW1lIGlkcy5cclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBmcmFtZXMgLSBUaGUgYXJyYXkgb2YgZnJhbWVzIGlkcyB0aGUgbW92aWVjbGlwIHdpbGwgdXNlIGFzIGl0cyB0ZXh0dXJlIGZyYW1lcy5cclxuICAgICAqIEByZXR1cm4ge0FuaW1hdGVkU3ByaXRlfSBUaGUgbmV3IGFuaW1hdGVkIHNwcml0ZSB3aXRoIHRoZSBzcGVjaWZpZWQgZnJhbWVzLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZnJvbUZyYW1lcyhmcmFtZXMpIHtcclxuICAgICAgICB2YXIgdGV4dHVyZXMgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZyYW1lcy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICB0ZXh0dXJlcy5wdXNoKFRleHR1cmVfMS5UZXh0dXJlLmZyb20oZnJhbWVzW2ldKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgQW5pbWF0ZWRTcHJpdGUodGV4dHVyZXMpO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBIHNob3J0IGhhbmQgd2F5IG9mIGNyZWF0aW5nIGEgbW92aWVjbGlwIGZyb20gYW4gYXJyYXkgb2YgaW1hZ2UgaWRzLlxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IGltYWdlcyAtIFRoZSBhcnJheSBvZiBpbWFnZSB1cmxzIHRoZSBtb3ZpZWNsaXAgd2lsbCB1c2UgYXMgaXRzIHRleHR1cmUgZnJhbWVzLlxyXG4gICAgICogQHJldHVybiB7QW5pbWF0ZWRTcHJpdGV9IFRoZSBuZXcgYW5pbWF0ZSBzcHJpdGUgd2l0aCB0aGUgc3BlY2lmaWVkIGltYWdlcyBhcyBmcmFtZXMuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBmcm9tSW1hZ2VzKGltYWdlcykge1xyXG4gICAgICAgIHZhciB0ZXh0dXJlcyA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW1hZ2VzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgIHRleHR1cmVzLnB1c2goVGV4dHVyZV8xLlRleHR1cmUuZnJvbShpbWFnZXNbaV0pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBBbmltYXRlZFNwcml0ZSh0ZXh0dXJlcyk7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSB0b3RhbCBudW1iZXIgb2YgZnJhbWVzIGluIHRoZSBBbmltYXRlZFNwcml0ZS4gVGhpcyBpcyB0aGUgc2FtZSBhcyBudW1iZXIgb2YgdGV4dHVyZXNcclxuICAgICAqIGFzc2lnbmVkIHRvIHRoZSBBbmltYXRlZFNwcml0ZS5cclxuICAgICAqXHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAqIEBkZWZhdWx0IDBcclxuICAgICAqL1xyXG4gICAgZ2V0IHRvdGFsRnJhbWVzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl90ZXh0dXJlcy5sZW5ndGg7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBhcnJheSBvZiB0ZXh0dXJlcyB1c2VkIGZvciB0aGlzIEFuaW1hdGVkU3ByaXRlLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge1BJWEkuVGV4dHVyZVtdfVxyXG4gICAgICovXHJcbiAgICBnZXQgdGV4dHVyZXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RleHR1cmVzO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgc2V0IHRleHR1cmVzKHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKHZhbHVlWzBdIGluc3RhbmNlb2YgVGV4dHVyZV8xLlRleHR1cmUpIHtcclxuICAgICAgICAgICAgdGhpcy5fdGV4dHVyZXMgPSB2YWx1ZTtcclxuICAgICAgICAgICAgdGhpcy5fZHVyYXRpb25zID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3RleHR1cmVzID0gW107XHJcbiAgICAgICAgICAgIHRoaXMuX2R1cmF0aW9ucyA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl90ZXh0dXJlcy5wdXNoKHZhbHVlW2ldLnRleHR1cmUpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZHVyYXRpb25zLnB1c2godmFsdWVbaV0udGltZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5nb3RvQW5kU3RvcCgwKTtcclxuICAgICAgICB0aGlzLnVwZGF0ZVRleHR1cmUoKTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgKiBUaGUgQW5pbWF0ZWRTcHJpdGVzIGN1cnJlbnQgZnJhbWUgaW5kZXguXHJcbiAgICAqXHJcbiAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICogQHJlYWRvbmx5XHJcbiAgICAqL1xyXG4gICAgZ2V0IGN1cnJlbnRGcmFtZSgpIHtcclxuICAgICAgICB2YXIgY3VycmVudEZyYW1lID0gTWF0aC5mbG9vcih0aGlzLl9jdXJyZW50VGltZSkgJSB0aGlzLl90ZXh0dXJlcy5sZW5ndGg7XHJcbiAgICAgICAgaWYgKGN1cnJlbnRGcmFtZSA8IDApIHtcclxuICAgICAgICAgICAgY3VycmVudEZyYW1lICs9IHRoaXMuX3RleHR1cmVzLmxlbmd0aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRGcmFtZTtcclxuICAgIH1cclxuICAgIDtcclxufVxyXG5leHBvcnRzLkFuaW1hdGVkU3ByaXRlID0gQW5pbWF0ZWRTcHJpdGU7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IENvbnRhaW5lcl8xID0gcmVxdWlyZShcIi4vQ29udGFpbmVyXCIpO1xyXG5jb25zdCBSZW5kZXJlcl8xID0gcmVxdWlyZShcIi4vUmVuZGVyZXJcIik7XHJcbmNvbnN0IFN0YWdlT3B0aW9uc18xID0gcmVxdWlyZShcIi4vU3RhZ2VPcHRpb25zXCIpO1xyXG5jb25zdCBUaWNrZXJfMSA9IHJlcXVpcmUoXCIuL1RpY2tlclwiKTtcclxuY29uc3QgQWNjZXNzaWJpbGl0eU1hbmFnZXJfMSA9IHJlcXVpcmUoXCIuL0FjY2Vzc2liaWxpdHlNYW5hZ2VyXCIpO1xyXG5jb25zdCBFeHRyYWN0XzEgPSByZXF1aXJlKFwiLi9FeHRyYWN0XCIpO1xyXG5jb25zdCBJbnRlcmFjdGlvbk1hbmFnZXJfMSA9IHJlcXVpcmUoXCIuL0ludGVyYWN0aW9uTWFuYWdlclwiKTtcclxuY29uc3QgUGFydGljbGVSZW5kZXJlcl8xID0gcmVxdWlyZShcIi4vUGFydGljbGVSZW5kZXJlclwiKTtcclxuY29uc3QgUHJlcGFyZV8xID0gcmVxdWlyZShcIi4vUHJlcGFyZVwiKTtcclxuY29uc3QgQmF0Y2hSZW5kZXJlcl8xID0gcmVxdWlyZShcIi4vQmF0Y2hSZW5kZXJlclwiKTtcclxuY29uc3QgVGlsaW5nU3ByaXRlUmVuZGVyZXJfMSA9IHJlcXVpcmUoXCIuL1RpbGluZ1Nwcml0ZVJlbmRlcmVyXCIpO1xyXG5jbGFzcyBBcHBsaWNhdGlvbiB7XHJcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zID0gbnVsbCkge1xyXG4gICAgICAgIHRoaXMucmVzaXplID0gKCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fcmVzaXplVG8pIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9yZXNpemVUbyA9PT0gd2luZG93KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5yZXNpemUod2luZG93LmlubmVyV2lkdGgsIHdpbmRvdy5pbm5lckhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnJlc2l6ZSh0aGlzLl9yZXNpemVUb1snY2xpZW50V2lkdGgnXSwgdGhpcy5fcmVzaXplVG9bJ2NsaWVudEhlaWdodCddKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKCFvcHRpb25zKSB7XHJcbiAgICAgICAgICAgIG9wdGlvbnMgPSBuZXcgU3RhZ2VPcHRpb25zXzEuU3RhZ2VPcHRpb25zKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFJlbmRlcmVyXzEuUmVuZGVyZXIucmVnaXN0ZXJQbHVnaW4oJ2FjY2Vzc2liaWxpdHknLCBBY2Nlc3NpYmlsaXR5TWFuYWdlcl8xLkFjY2Vzc2liaWxpdHlNYW5hZ2VyKTtcclxuICAgICAgICBSZW5kZXJlcl8xLlJlbmRlcmVyLnJlZ2lzdGVyUGx1Z2luKCdleHRyYWN0JywgRXh0cmFjdF8xLkV4dHJhY3QpO1xyXG4gICAgICAgIFJlbmRlcmVyXzEuUmVuZGVyZXIucmVnaXN0ZXJQbHVnaW4oJ2ludGVyYWN0aW9uJywgSW50ZXJhY3Rpb25NYW5hZ2VyXzEuSW50ZXJhY3Rpb25NYW5hZ2VyKTtcclxuICAgICAgICBSZW5kZXJlcl8xLlJlbmRlcmVyLnJlZ2lzdGVyUGx1Z2luKCdwYXJ0aWNsZScsIFBhcnRpY2xlUmVuZGVyZXJfMS5QYXJ0aWNsZVJlbmRlcmVyKTtcclxuICAgICAgICBSZW5kZXJlcl8xLlJlbmRlcmVyLnJlZ2lzdGVyUGx1Z2luKCdwcmVwYXJlJywgUHJlcGFyZV8xLlByZXBhcmUpO1xyXG4gICAgICAgIFJlbmRlcmVyXzEuUmVuZGVyZXIucmVnaXN0ZXJQbHVnaW4oJ2JhdGNoJywgQmF0Y2hSZW5kZXJlcl8xLkJhdGNoUmVuZGVyZXIpO1xyXG4gICAgICAgIFJlbmRlcmVyXzEuUmVuZGVyZXIucmVnaXN0ZXJQbHVnaW4oJ3RpbGluZ1Nwcml0ZScsIFRpbGluZ1Nwcml0ZVJlbmRlcmVyXzEuVGlsaW5nU3ByaXRlUmVuZGVyZXIpO1xyXG4gICAgICAgIC8vIHRoaXMubG9hZGVyID0gLypvcHRpb25zLnNoYXJlZExvYWRlciA/IExvYWRlci5zaGFyZWQgOiAqL25ldyBMb2FkZXIoKTtcclxuICAgICAgICB0aGlzLnJlbmRlcmVyID0gbmV3IFJlbmRlcmVyXzEuUmVuZGVyZXIob3B0aW9ucyk7IC8vQXBwbGljYXRpb24uYXV0b0RldGVjdFJlbmRlcmVyKG9wdGlvbnMpO1xyXG4gICAgICAgIHRoaXMuX3N0YWdlID0gbmV3IENvbnRhaW5lcl8xLkNvbnRhaW5lcigpO1xyXG4gICAgICAgIHRoaXMudGlja2VyID0gb3B0aW9ucy5zaGFyZWRUaWNrZXIgPyBUaWNrZXJfMS5UaWNrZXIuc2hhcmVkIDogbmV3IFRpY2tlcl8xLlRpY2tlcigpO1xyXG4gICAgICAgIHRoaXMucmVzaXplVG8gPSB3aW5kb3c7XHJcbiAgICAgICAgLy8gRGlzcGxheU9iamVjdC5taXhpbihpbnRlcmFjdGl2ZVRhcmdldCk7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMuYXV0b1N0YXJ0KSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhcnQoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXQgdGlja2VyKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl90aWNrZXI7XHJcbiAgICB9XHJcbiAgICBzZXQgdGlja2VyKHRpY2tlcikge1xyXG4gICAgICAgIGlmICh0aGlzLl90aWNrZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5fdGlja2VyLnJlbW92ZSh0aGlzLnJlbmRlciwgdGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3RpY2tlciA9IHRpY2tlcjtcclxuICAgICAgICBpZiAodGlja2VyKSB7XHJcbiAgICAgICAgICAgIHRpY2tlci5hZGQodGhpcy5yZW5kZXIsIHRoaXMsIFRpY2tlcl8xLlRpY2tlci5VUERBVEVfUFJJT1JJVFkuTE9XKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzdGFydCgpIHtcclxuICAgICAgICB0aGlzLl90aWNrZXIuc3RhcnQoKTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIHN0b3AoKSB7XHJcbiAgICAgICAgdGhpcy5fdGlja2VyLnN0b3AoKTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIGdldCByZXNpemVUbygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcmVzaXplVG87XHJcbiAgICB9XHJcbiAgICBzZXQgcmVzaXplVG8odmFsdWUpIHtcclxuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5yZXNpemUpO1xyXG4gICAgICAgIHRoaXMuX3Jlc2l6ZVRvID0gdmFsdWU7XHJcbiAgICAgICAgaWYgKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLnJlc2l6ZSk7XHJcbiAgICAgICAgICAgIHRoaXMucmVzaXplKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmVuZGVyKCkge1xyXG4gICAgICAgIHRoaXMucmVuZGVyZXIucmVuZGVyKHRoaXMuX3N0YWdlKTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIGdldCBzdGFnZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fc3RhZ2U7XHJcbiAgICB9XHJcbiAgICBnZXQgdmlldygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJlci52aWV3O1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgZ2V0IHNjcmVlbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJlci5zY3JlZW47XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICBkZXN0cm95KG9wdGlvbnMgPSBudWxsKSB7XHJcbiAgICAgICAgdGhpcy5fc3RhZ2UuZGVzdHJveShvcHRpb25zKTtcclxuICAgICAgICB0aGlzLl9zdGFnZSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJlci5kZXN0cm95KG9wdGlvbnMpO1xyXG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuX29wdGlvbnMgPSBudWxsO1xyXG4gICAgICAgIC8vIGlmICh0aGlzLmxvYWRlcilcclxuICAgICAgICAvLyB7XHJcbiAgICAgICAgLy8gICAgIHRoaXMubG9hZGVyLmRlc3Ryb3koKTtcclxuICAgICAgICAvLyAgICAgdGhpcy5sb2FkZXIgPSBudWxsO1xyXG4gICAgICAgIC8vIH1cclxuICAgIH1cclxuICAgIDtcclxufVxyXG5leHBvcnRzLkFwcGxpY2F0aW9uID0gQXBwbGljYXRpb247XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IHNldHRpbmdzXzEgPSByZXF1aXJlKFwiLi9zZXR0aW5nc1wiKTtcclxuY29uc3QgTWF0aFNldHRpbmdzXzEgPSByZXF1aXJlKFwiLi9NYXRoU2V0dGluZ3NcIik7XHJcbmNsYXNzIEFyY1V0aWxzIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGN1cnZlVG8oeDEsIHkxLCB4MiwgeTIsIHJhZGl1cywgcG9pbnRzKSB7XHJcbiAgICAgICAgdmFyIGZyb21YID0gcG9pbnRzW3BvaW50cy5sZW5ndGggLSAyXTtcclxuICAgICAgICB2YXIgZnJvbVkgPSBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDFdO1xyXG4gICAgICAgIHZhciBhMSA9IGZyb21ZIC0geTE7XHJcbiAgICAgICAgdmFyIGIxID0gZnJvbVggLSB4MTtcclxuICAgICAgICB2YXIgYTIgPSB5MiAtIHkxO1xyXG4gICAgICAgIHZhciBiMiA9IHgyIC0geDE7XHJcbiAgICAgICAgdmFyIG1tID0gTWF0aC5hYnMoKGExICogYjIpIC0gKGIxICogYTIpKTtcclxuICAgICAgICBpZiAobW0gPCAxLjBlLTggfHwgcmFkaXVzID09PSAwKSB7XHJcbiAgICAgICAgICAgIGlmIChwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDJdICE9PSB4MSB8fCBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDFdICE9PSB5MSkge1xyXG4gICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goeDEsIHkxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGRkID0gKGExICogYTEpICsgKGIxICogYjEpO1xyXG4gICAgICAgIHZhciBjYyA9IChhMiAqIGEyKSArIChiMiAqIGIyKTtcclxuICAgICAgICB2YXIgdHQgPSAoYTEgKiBhMikgKyAoYjEgKiBiMik7XHJcbiAgICAgICAgdmFyIGsxID0gcmFkaXVzICogTWF0aC5zcXJ0KGRkKSAvIG1tO1xyXG4gICAgICAgIHZhciBrMiA9IHJhZGl1cyAqIE1hdGguc3FydChjYykgLyBtbTtcclxuICAgICAgICB2YXIgajEgPSBrMSAqIHR0IC8gZGQ7XHJcbiAgICAgICAgdmFyIGoyID0gazIgKiB0dCAvIGNjO1xyXG4gICAgICAgIHZhciBjeCA9IChrMSAqIGIyKSArIChrMiAqIGIxKTtcclxuICAgICAgICB2YXIgY3kgPSAoazEgKiBhMikgKyAoazIgKiBhMSk7XHJcbiAgICAgICAgdmFyIHB4ID0gYjEgKiAoazIgKyBqMSk7XHJcbiAgICAgICAgdmFyIHB5ID0gYTEgKiAoazIgKyBqMSk7XHJcbiAgICAgICAgdmFyIHF4ID0gYjIgKiAoazEgKyBqMik7XHJcbiAgICAgICAgdmFyIHF5ID0gYTIgKiAoazEgKyBqMik7XHJcbiAgICAgICAgdmFyIHN0YXJ0QW5nbGUgPSBNYXRoLmF0YW4yKHB5IC0gY3ksIHB4IC0gY3gpO1xyXG4gICAgICAgIHZhciBlbmRBbmdsZSA9IE1hdGguYXRhbjIocXkgLSBjeSwgcXggLSBjeCk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgY3g6IChjeCArIHgxKSxcclxuICAgICAgICAgICAgY3k6IChjeSArIHkxKSxcclxuICAgICAgICAgICAgcmFkaXVzOiByYWRpdXMsXHJcbiAgICAgICAgICAgIHN0YXJ0QW5nbGU6IHN0YXJ0QW5nbGUsXHJcbiAgICAgICAgICAgIGVuZEFuZ2xlOiBlbmRBbmdsZSxcclxuICAgICAgICAgICAgYW50aWNsb2Nrd2lzZTogKGIxICogYTIgPiBiMiAqIGExKSxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgYXJjIG1ldGhvZCBjcmVhdGVzIGFuIGFyYy9jdXJ2ZSAodXNlZCB0byBjcmVhdGUgY2lyY2xlcywgb3IgcGFydHMgb2YgY2lyY2xlcykuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydFggLSBTdGFydCB4IGxvY2F0aW9uIG9mIGFyY1xyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0WSAtIFN0YXJ0IHkgbG9jYXRpb24gb2YgYXJjXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY3ggLSBUaGUgeC1jb29yZGluYXRlIG9mIHRoZSBjZW50ZXIgb2YgdGhlIGNpcmNsZVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGN5IC0gVGhlIHktY29vcmRpbmF0ZSBvZiB0aGUgY2VudGVyIG9mIHRoZSBjaXJjbGVcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByYWRpdXMgLSBUaGUgcmFkaXVzIG9mIHRoZSBjaXJjbGVcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydEFuZ2xlIC0gVGhlIHN0YXJ0aW5nIGFuZ2xlLCBpbiByYWRpYW5zICgwIGlzIGF0IHRoZSAzIG8nY2xvY2sgcG9zaXRpb25cclxuICAgICAqICBvZiB0aGUgYXJjJ3MgY2lyY2xlKVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZEFuZ2xlIC0gVGhlIGVuZGluZyBhbmdsZSwgaW4gcmFkaWFuc1xyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBhbnRpY2xvY2t3aXNlIC0gU3BlY2lmaWVzIHdoZXRoZXIgdGhlIGRyYXdpbmcgc2hvdWxkIGJlXHJcbiAgICAgKiAgY291bnRlci1jbG9ja3dpc2Ugb3IgY2xvY2t3aXNlLiBGYWxzZSBpcyBkZWZhdWx0LCBhbmQgaW5kaWNhdGVzIGNsb2Nrd2lzZSwgd2hpbGUgdHJ1ZVxyXG4gICAgICogIGluZGljYXRlcyBjb3VudGVyLWNsb2Nrd2lzZS5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuIC0gTnVtYmVyIG9mIHNlZ21lbnRzXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcltdfSBwb2ludHMgLSBDb2xsZWN0aW9uIG9mIHBvaW50cyB0byBhZGQgdG9cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGFyYyhzdGFydFgsIHN0YXJ0WSwgY3gsIGN5LCByYWRpdXMsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBhbnRpY2xvY2t3aXNlLCBwb2ludHMpIHtcclxuICAgICAgICB2YXIgc3dlZXAgPSBlbmRBbmdsZSAtIHN0YXJ0QW5nbGU7XHJcbiAgICAgICAgdmFyIG4gPSBzZXR0aW5nc18xLnNldHRpbmdzLkdSQVBISUNTX0NVUlZFUy5fc2VnbWVudHNDb3VudChNYXRoLmFicyhzd2VlcCkgKiByYWRpdXMsIE1hdGguY2VpbChNYXRoLmFicyhzd2VlcCkgLyBNYXRoU2V0dGluZ3NfMS5NYXRoU2V0dGluZ3MuUElfMikgKiA0MCk7XHJcbiAgICAgICAgdmFyIHRoZXRhID0gKHN3ZWVwKSAvIChuICogMik7XHJcbiAgICAgICAgdmFyIHRoZXRhMiA9IHRoZXRhICogMjtcclxuICAgICAgICB2YXIgY1RoZXRhID0gTWF0aC5jb3ModGhldGEpO1xyXG4gICAgICAgIHZhciBzVGhldGEgPSBNYXRoLnNpbih0aGV0YSk7XHJcbiAgICAgICAgdmFyIHNlZ01pbnVzID0gbiAtIDE7XHJcbiAgICAgICAgdmFyIHJlbWFpbmRlciA9IChzZWdNaW51cyAlIDEpIC8gc2VnTWludXM7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gc2VnTWludXM7ICsraSkge1xyXG4gICAgICAgICAgICB2YXIgcmVhbCA9IGkgKyAocmVtYWluZGVyICogaSk7XHJcbiAgICAgICAgICAgIHZhciBhbmdsZSA9ICgodGhldGEpICsgc3RhcnRBbmdsZSArICh0aGV0YTIgKiByZWFsKSk7XHJcbiAgICAgICAgICAgIHZhciBjID0gTWF0aC5jb3MoYW5nbGUpO1xyXG4gICAgICAgICAgICB2YXIgcyA9IC1NYXRoLnNpbihhbmdsZSk7XHJcbiAgICAgICAgICAgIHBvaW50cy5wdXNoKCgoKGNUaGV0YSAqIGMpICsgKHNUaGV0YSAqIHMpKSAqIHJhZGl1cykgKyBjeCwgKCgoY1RoZXRhICogLXMpICsgKHNUaGV0YSAqIGMpKSAqIHJhZGl1cykgKyBjeSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgO1xyXG59XHJcbmV4cG9ydHMuQXJjVXRpbHMgPSBBcmNVdGlscztcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgUmVzb3VyY2VfMSA9IHJlcXVpcmUoXCIuL1Jlc291cmNlXCIpO1xyXG5jb25zdCBCYXNlVGV4dHVyZV8xID0gcmVxdWlyZShcIi4vQmFzZVRleHR1cmVcIik7XHJcbmNvbnN0IFJlc291cmNlU2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL1Jlc291cmNlU2V0dGluZ3NcIik7XHJcbmNvbnN0IFdlYkdMU2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL1dlYkdMU2V0dGluZ3NcIik7XHJcbmNsYXNzIEFycmF5UmVzb3VyY2UgZXh0ZW5kcyBSZXNvdXJjZV8xLlJlc291cmNlIHtcclxuICAgIGNvbnN0cnVjdG9yKHNvdXJjZSwgb3B0aW9ucykge1xyXG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG4gICAgICAgIHZhciB1cmxzO1xyXG4gICAgICAgIHZhciBsZW5ndGggPSBzb3VyY2U7XHJcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc291cmNlKSkge1xyXG4gICAgICAgICAgICB1cmxzID0gc291cmNlO1xyXG4gICAgICAgICAgICBsZW5ndGggPSBzb3VyY2UubGVuZ3RoO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzdXBlcihvcHRpb25zLndpZHRoLCBvcHRpb25zLmhlaWdodCk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ29sbGVjdGlvbiBvZiByZXNvdXJjZXMuXHJcbiAgICAgICAgICogQG1lbWJlciB7QXJyYXk8UElYSS5CYXNlVGV4dHVyZT59XHJcbiAgICAgICAgICogQHJlYWRvbmx5XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5pdGVtcyA9IFtdO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIERpcnR5IElEcyBmb3IgZWFjaCBwYXJ0XHJcbiAgICAgICAgICogQG1lbWJlciB7QXJyYXk8bnVtYmVyPn1cclxuICAgICAgICAgKiBAcmVhZG9ubHlcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLml0ZW1EaXJ0eUlkcyA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIHBhcnRUZXh0dXJlID0gbmV3IEJhc2VUZXh0dXJlXzEuQmFzZVRleHR1cmUoKTtcclxuICAgICAgICAgICAgdGhpcy5pdGVtcy5wdXNoKHBhcnRUZXh0dXJlKTtcclxuICAgICAgICAgICAgdGhpcy5pdGVtRGlydHlJZHMucHVzaCgtMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIE51bWJlciBvZiBlbGVtZW50cyBpbiBhcnJheVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICAgICAqIEByZWFkb25seVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFByb21pc2Ugd2hlbiBsb2FkaW5nXHJcbiAgICAgICAgICogQG1lbWJlciB7UHJvbWlzZX1cclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqIEBkZWZhdWx0IG51bGxcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLl9sb2FkID0gbnVsbDtcclxuICAgICAgICBpZiAodXJscykge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBsZW5ndGg7IGkkMSsrKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFkZFJlc291cmNlQXQoUmVzb3VyY2VTZXR0aW5nc18xLlJlc291cmNlU2V0dGluZ3MuYXV0b0RldGVjdFJlc291cmNlKHVybHNbaSQxXSwgb3B0aW9ucyksIGkkMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIERlc3Ryb3kgdGhpcyBCYXNlSW1hZ2VSZXNvdXJjZVxyXG4gICAgICogQG92ZXJyaWRlXHJcbiAgICAgKi9cclxuICAgIGRpc3Bvc2UoKSB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgdGhpcy5pdGVtc1tpXS5kZXN0cm95KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuaXRlbXMgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuaXRlbURpcnR5SWRzID0gbnVsbDtcclxuICAgICAgICB0aGlzLl9sb2FkID0gbnVsbDtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogU2V0IGEgcmVzb3VyY2UgYnkgSURcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1BJWEkucmVzb3VyY2VzLlJlc291cmNlfSByZXNvdXJjZVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gWmVyby1iYXNlZCBpbmRleCBvZiByZXNvdXJjZSB0byBzZXRcclxuICAgICAqIEByZXR1cm4ge1BJWEkucmVzb3VyY2VzLkFycmF5UmVzb3VyY2V9IEluc3RhbmNlIGZvciBjaGFpbmluZ1xyXG4gICAgICovXHJcbiAgICBhZGRSZXNvdXJjZUF0KHJlc291cmNlLCBpbmRleCkge1xyXG4gICAgICAgIHZhciBiYXNlVGV4dHVyZSA9IHRoaXMuaXRlbXNbaW5kZXhdO1xyXG4gICAgICAgIGlmICghYmFzZVRleHR1cmUpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKChcIkluZGV4IFwiICsgaW5kZXggKyBcIiBpcyBvdXQgb2YgYm91bmRzXCIpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gSW5oZXJpdCB0aGUgZmlyc3QgcmVzb3VyY2UgZGltZW5zaW9uc1xyXG4gICAgICAgIGlmIChyZXNvdXJjZS52YWxpZCAmJiAhdGhpcy52YWxpZCkge1xyXG4gICAgICAgICAgICB0aGlzLnJlc2l6ZShyZXNvdXJjZS53aWR0aCwgcmVzb3VyY2UuaGVpZ2h0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5pdGVtc1tpbmRleF0uc2V0UmVzb3VyY2UocmVzb3VyY2UpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhlIHBhcmVudCBiYXNlIHRleHR1cmVcclxuICAgICAqIEBtZW1iZXIge1BJWEkuQmFzZVRleHR1cmV9XHJcbiAgICAgKiBAb3ZlcnJpZGVcclxuICAgICAqL1xyXG4gICAgYmluZChiYXNlVGV4dHVyZSkge1xyXG4gICAgICAgIHN1cGVyLmJpbmQoYmFzZVRleHR1cmUpO1xyXG4gICAgICAgIGJhc2VUZXh0dXJlLnRhcmdldCA9IFdlYkdMU2V0dGluZ3NfMS5XZWJHTFNldHRpbmdzLlRBUkdFVFMuVEVYVFVSRV8yRF9BUlJBWTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdGhpcy5pdGVtc1tpXS5vbigndXBkYXRlJywgYmFzZVRleHR1cmUudXBkYXRlLCBiYXNlVGV4dHVyZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBVbnNldCB0aGUgcGFyZW50IGJhc2UgdGV4dHVyZVxyXG4gICAgICogQG1lbWJlciB7UElYSS5CYXNlVGV4dHVyZX1cclxuICAgICAqIEBvdmVycmlkZVxyXG4gICAgICovXHJcbiAgICB1bmJpbmQoYmFzZVRleHR1cmUpIHtcclxuICAgICAgICBzdXBlci51bmJpbmQoYmFzZVRleHR1cmUpO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB0aGlzLml0ZW1zW2ldLm9mZigndXBkYXRlJywgYmFzZVRleHR1cmUudXBkYXRlLCBiYXNlVGV4dHVyZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBMb2FkIGFsbCB0aGUgcmVzb3VyY2VzIHNpbXVsdGFuZW91c2x5XHJcbiAgICAgKiBAb3ZlcnJpZGVcclxuICAgICAqIEByZXR1cm4ge1Byb21pc2U8dm9pZD59IFdoZW4gbG9hZCBpcyByZXNvbHZlZFxyXG4gICAgICovXHJcbiAgICBsb2FkKCkge1xyXG4gICAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xyXG4gICAgICAgIGlmICh0aGlzLl9sb2FkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9sb2FkO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcmVzb3VyY2VzID0gdGhpcy5pdGVtcy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHsgcmV0dXJuIGl0ZW0ucmVzb3VyY2U7IH0pO1xyXG4gICAgICAgIC8vIFRPRE86IGFsc28gaW1wbGVtZW50IGxvYWQgcGFydC1ieS1wYXJ0IHN0cmF0ZWd5XHJcbiAgICAgICAgdmFyIHByb21pc2VzID0gcmVzb3VyY2VzLm1hcChmdW5jdGlvbiAoaXRlbSkgeyByZXR1cm4gaXRlbS5sb2FkKCk7IH0pO1xyXG4gICAgICAgIHRoaXMuX2xvYWQgPSBQcm9taXNlLmFsbChwcm9taXNlcylcclxuICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgcmVmID0gcmVzb3VyY2VzWzBdO1xyXG4gICAgICAgICAgICB2YXIgd2lkdGggPSByZWYud2lkdGg7XHJcbiAgICAgICAgICAgIHZhciBoZWlnaHQgPSByZWYuaGVpZ2h0O1xyXG4gICAgICAgICAgICB0aGlzJDEucmVzaXplKHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMkMSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvYWQ7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFVwbG9hZCB0aGUgcmVzb3VyY2VzIHRvIHRoZSBHUFUuXHJcbiAgICAgKiBAcGFyYW0ge1BJWEkuUmVuZGVyZXJ9IHJlbmRlcmVyXHJcbiAgICAgKiBAcGFyYW0ge1BJWEkuQmFzZVRleHR1cmV9IHRleHR1cmVcclxuICAgICAqIEBwYXJhbSB7UElYSS5HTFRleHR1cmV9IGdsVGV4dHVyZVxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IHdoZXRoZXIgdGV4dHVyZSB3YXMgdXBsb2FkZWRcclxuICAgICAqL1xyXG4gICAgdXBsb2FkKHJlbmRlcmVyLCB0ZXh0dXJlLCBnbFRleHR1cmUpIHtcclxuICAgICAgICB2YXIgcmVmID0gdGhpcztcclxuICAgICAgICB2YXIgbGVuZ3RoID0gcmVmLmxlbmd0aDtcclxuICAgICAgICB2YXIgaXRlbURpcnR5SWRzID0gcmVmLml0ZW1EaXJ0eUlkcztcclxuICAgICAgICB2YXIgaXRlbXMgPSByZWYuaXRlbXM7XHJcbiAgICAgICAgdmFyIGdsID0gcmVuZGVyZXIuZ2w7XHJcbiAgICAgICAgaWYgKGdsVGV4dHVyZS5kaXJ0eUlkIDwgMCkge1xyXG4gICAgICAgICAgICBnbC50ZXhJbWFnZTNEKGdsLlRFWFRVUkVfMkRfQVJSQVksIDAsIHRleHR1cmUuZm9ybWF0LCB0aGlzLl93aWR0aCwgdGhpcy5faGVpZ2h0LCBsZW5ndGgsIDAsIHRleHR1cmUuZm9ybWF0LCB0ZXh0dXJlLnR5cGUsIG51bGwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBpdGVtID0gaXRlbXNbaV07XHJcbiAgICAgICAgICAgIGlmIChpdGVtRGlydHlJZHNbaV0gPCBpdGVtLmRpcnR5SWQpIHtcclxuICAgICAgICAgICAgICAgIGl0ZW1EaXJ0eUlkc1tpXSA9IGl0ZW0uZGlydHlJZDtcclxuICAgICAgICAgICAgICAgIGlmIChpdGVtLnZhbGlkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZ2wudGV4U3ViSW1hZ2UzRChnbC5URVhUVVJFXzJEX0FSUkFZLCAwLCAwLCAvLyB4b2Zmc2V0XHJcbiAgICAgICAgICAgICAgICAgICAgMCwgLy8geW9mZnNldFxyXG4gICAgICAgICAgICAgICAgICAgIGksIC8vIHpvZmZzZXRcclxuICAgICAgICAgICAgICAgICAgICBpdGVtLnJlc291cmNlLndpZHRoLCBpdGVtLnJlc291cmNlLmhlaWdodCwgMSwgdGV4dHVyZS5mb3JtYXQsIHRleHR1cmUudHlwZSwgaXRlbS5yZXNvdXJjZS5zb3VyY2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgO1xyXG59XHJcbmV4cG9ydHMuQXJyYXlSZXNvdXJjZSA9IEFycmF5UmVzb3VyY2U7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IExvZ2dlcl8xID0gcmVxdWlyZShcIi4vL0xvZ2dlclwiKTtcclxuY2xhc3MgQXR0cmlidXRlIHtcclxuICAgIGNvbnN0cnVjdG9yKGJ1ZmZlciwgc2l6ZSwgbm9ybWFsaXplZCA9IGZhbHNlLCB0eXBlID0gNTEyNiwgc3RyaWRlID0gdW5kZWZpbmVkLCBzdGFydCA9IHVuZGVmaW5lZCwgaW5zdGFuY2UgPSB1bmRlZmluZWQpIHtcclxuICAgICAgICB0aGlzLmJ1ZmZlciA9IGJ1ZmZlcjtcclxuICAgICAgICB0aGlzLnNpemUgPSBzaXplO1xyXG4gICAgICAgIHRoaXMubm9ybWFsaXplZCA9IG5vcm1hbGl6ZWQ7XHJcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcclxuICAgICAgICB0aGlzLl9zdHJpZGUgPSBzdHJpZGU7XHJcbiAgICAgICAgdGhpcy5zdGFydCA9IHN0YXJ0O1xyXG4gICAgICAgIHRoaXMuaW5zdGFuY2UgPSBpbnN0YW5jZTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIHNldCBzdHJpZGUodmFsdWUpIHtcclxuICAgICAgICBMb2dnZXJfMS50cmFjZShcInNldCB0byBcIiArIHZhbHVlKTtcclxuICAgICAgICB0aGlzLl9zdHJpZGUgPSB2YWx1ZTtcclxuICAgIH1cclxuICAgIGdldCBzdHJpZGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0cmlkZTtcclxuICAgIH1cclxuICAgIGRlc3Ryb3kob3B0aW9ucyA9IG51bGwpIHtcclxuICAgICAgICB0aGlzLmJ1ZmZlciA9IG51bGw7XHJcbiAgICB9XHJcbiAgICA7XHJcbn1cclxuZXhwb3J0cy5BdHRyaWJ1dGUgPSBBdHRyaWJ1dGU7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IFJlc291cmNlXzEgPSByZXF1aXJlKFwiLi9SZXNvdXJjZVwiKTtcclxuY29uc3QgTmV0d29ya1NldHRpbmdzXzEgPSByZXF1aXJlKFwiLi9OZXR3b3JrU2V0dGluZ3NcIik7XHJcbmNvbnN0IExvZ2dlcl8xID0gcmVxdWlyZShcIi4vTG9nZ2VyXCIpO1xyXG5jbGFzcyBCYXNlSW1hZ2VSZXNvdXJjZSBleHRlbmRzIFJlc291cmNlXzEuUmVzb3VyY2Uge1xyXG4gICAgY29uc3RydWN0b3Ioc291cmNlKSB7XHJcbiAgICAgICAgc3VwZXIoc291cmNlLndpZHRoLCBzb3VyY2UuaGVpZ2h0KTtcclxuICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0IGNyb3NzIG9yaWdpbiBiYXNlZCBkZXRlY3RpbmcgdGhlIHVybCBhbmQgdGhlIGNyb3Nzb3JpZ2luXHJcbiAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IC0gRWxlbWVudCB0byBhcHBseSBjcm9zc09yaWdpblxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVybCAtIFVSTCB0byBjaGVja1xyXG4gICAgICogQHBhcmFtIHtib29sZWFufHN0cmluZ30gW2Nyb3Nzb3JpZ2luPXRydWVdIC0gQ3Jvc3Mgb3JpZ2luIHZhbHVlIHRvIHVzZVxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgY3Jvc3NPcmlnaW4oZWxlbWVudCwgdXJsLCBjcm9zc29yaWdpbikge1xyXG4gICAgICAgIGlmIChjcm9zc29yaWdpbiA9PT0gdW5kZWZpbmVkICYmIHVybC5pbmRleE9mKCdkYXRhOicpICE9PSAwKSB7XHJcbiAgICAgICAgICAgIGVsZW1lbnQuY3Jvc3NPcmlnaW4gPSBOZXR3b3JrU2V0dGluZ3NfMS5OZXR3b3JrU2V0dGluZ3MuZGV0ZXJtaW5lQ3Jvc3NPcmlnaW4odXJsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoY3Jvc3NvcmlnaW4gIT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIGVsZW1lbnQuY3Jvc3NPcmlnaW4gPSB0eXBlb2YgY3Jvc3NvcmlnaW4gPT09ICdzdHJpbmcnID8gY3Jvc3NvcmlnaW4gOiAnYW5vbnltb3VzJztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFVwbG9hZCB0aGUgdGV4dHVyZSB0byB0aGUgR1BVLlxyXG4gICAgICogQHBhcmFtIHtQSVhJLlJlbmRlcmVyfSByZW5kZXJlciBVcGxvYWQgdG8gdGhlIHJlbmRlcmVyXHJcbiAgICAgKiBAcGFyYW0ge1BJWEkuQmFzZVRleHR1cmV9IGJhc2VUZXh0dXJlIFJlZmVyZW5jZSB0byBwYXJlbnQgdGV4dHVyZVxyXG4gICAgICogQHBhcmFtIHtQSVhJLkdMVGV4dHVyZX0gZ2xUZXh0dXJlXHJcbiAgICAgKiBAcGFyYW0ge0hUTUxJbWFnZUVsZW1lbnR8SFRNTENhbnZhc0VsZW1lbnR8SFRNTFZpZGVvRWxlbWVudHxTVkdFbGVtZW50fSBbc291cmNlXSAob3B0aW9uYWwpXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpcyBzdWNjZXNzXHJcbiAgICAgKi9cclxuICAgIHVwbG9hZChyZW5kZXJlciwgYmFzZVRleHR1cmUsIGdsVGV4dHVyZSwgc291cmNlID0gbnVsbCkge1xyXG4gICAgICAgIHZhciBnbCA9IHJlbmRlcmVyLmdsO1xyXG4gICAgICAgIHZhciB3aWR0aCA9IGJhc2VUZXh0dXJlLnJlYWxXaWR0aDtcclxuICAgICAgICB2YXIgaGVpZ2h0ID0gYmFzZVRleHR1cmUucmVhbEhlaWdodDtcclxuICAgICAgICBzb3VyY2UgPSBzb3VyY2UgfHwgdGhpcy5zb3VyY2U7XHJcbiAgICAgICAgTG9nZ2VyXzEudHJhY2UoXCJ1cGRhdGUgdXBsb2FkIFwiICsgYmFzZVRleHR1cmUudHlwZSk7XHJcbiAgICAgICAgZ2wucGl4ZWxTdG9yZWkoZ2wuVU5QQUNLX1BSRU1VTFRJUExZX0FMUEhBX1dFQkdMLCBiYXNlVGV4dHVyZS5wcmVtdWx0aXBseUFscGhhKTtcclxuICAgICAgICBpZiAoYmFzZVRleHR1cmUudGFyZ2V0ID09PSBnbC5URVhUVVJFXzJEICYmIGdsVGV4dHVyZS53aWR0aCA9PT0gd2lkdGggJiYgZ2xUZXh0dXJlLmhlaWdodCA9PT0gaGVpZ2h0KSB7XHJcbiAgICAgICAgICAgIC8vIHRyYWNlKFwidXBkYXRlIHVwbG9hZCBcIiArIGdsVGV4dHVyZS53aWR0aCArIFwiOlwiICsgZ2xUZXh0dXJlLmhlaWdodClcclxuICAgICAgICAgICAgZ2wudGV4U3ViSW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCAwLCAwLCBiYXNlVGV4dHVyZS5mb3JtYXQsIGJhc2VUZXh0dXJlLnR5cGUsIHNvdXJjZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBnbFRleHR1cmUud2lkdGggPSB3aWR0aDtcclxuICAgICAgICAgICAgZ2xUZXh0dXJlLmhlaWdodCA9IGhlaWdodDtcclxuICAgICAgICAgICAgTG9nZ2VyXzEudHJhY2UoXCJmaXJzdCB1cGxvYWQgXCIgKyB3aWR0aCArIFwiOlwiICsgaGVpZ2h0KTtcclxuICAgICAgICAgICAgZ2wudGV4SW1hZ2UyRChiYXNlVGV4dHVyZS50YXJnZXQsIDAsIGJhc2VUZXh0dXJlLmZvcm1hdCwgYmFzZVRleHR1cmUuZm9ybWF0LCBiYXNlVGV4dHVyZS50eXBlLCBzb3VyY2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogRGVzdHJveSB0aGlzIEJhc2VJbWFnZVJlc291cmNlXHJcbiAgICAgKiBAb3ZlcnJpZGVcclxuICAgICAqIEBwYXJhbSB7UElYSS5CYXNlVGV4dHVyZX0gW2Zyb21UZXh0dXJlXSBPcHRpb25hbCBiYXNlIHRleHR1cmVcclxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IERlc3Ryb3kgd2FzIHN1Y2Nlc3NmdWxcclxuICAgICAqL1xyXG4gICAgZGlzcG9zZSgpIHtcclxuICAgICAgICB0aGlzLnNvdXJjZSA9IG51bGw7XHJcbiAgICB9XHJcbiAgICA7XHJcbn1cclxuZXhwb3J0cy5CYXNlSW1hZ2VSZXNvdXJjZSA9IEJhc2VJbWFnZVJlc291cmNlO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBUaWNrZXJfMSA9IHJlcXVpcmUoXCIuL1RpY2tlclwiKTtcclxuY29uc3QgQ29udGFpbmVyXzEgPSByZXF1aXJlKFwiLi9Db250YWluZXJcIik7XHJcbmNvbnN0IFRleHRTdHlsZV8xID0gcmVxdWlyZShcIi4vVGV4dFN0eWxlXCIpO1xyXG5jb25zdCBUZXh0XzEgPSByZXF1aXJlKFwiLi9UZXh0XCIpO1xyXG5jb25zdCBUZXh0dXJlXzEgPSByZXF1aXJlKFwiLi9UZXh0dXJlXCIpO1xyXG5jb25zdCBCYXNlVGV4dHVyZV8xID0gcmVxdWlyZShcIi4vQmFzZVRleHR1cmVcIik7XHJcbmNvbnN0IFRleHRNZXRyaWNzXzEgPSByZXF1aXJlKFwiLi9UZXh0TWV0cmljc1wiKTtcclxuY29uc3QgQ291bnRMaW1pdGVyXzEgPSByZXF1aXJlKFwiLi9Db3VudExpbWl0ZXJcIik7XHJcbmNvbnN0IFdlYkdMU2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL1dlYkdMU2V0dGluZ3NcIik7XHJcbmNsYXNzIEJhc2VQcmVwYXJlIC8vZXh0ZW5kcyBSZW5kZXJlclxyXG4ge1xyXG4gICAgY29uc3RydWN0b3IocmVuZGVyZXIpIHtcclxuICAgICAgICAvLyBzdXBlcihudWxsKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgbGltaXRlciB0byBiZSB1c2VkIHRvIGNvbnRyb2wgaG93IHF1aWNrbHkgaXRlbXMgYXJlIHByZXBhcmVkLlxyXG4gICAgICAgICAqIEB0eXBlIHtQSVhJLnByZXBhcmUuQ291bnRMaW1pdGVyfFBJWEkucHJlcGFyZS5UaW1lTGltaXRlcn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmxpbWl0ZXIgPSBuZXcgQ291bnRMaW1pdGVyXzEuQ291bnRMaW1pdGVyKFdlYkdMU2V0dGluZ3NfMS5XZWJHTFNldHRpbmdzLlVQTE9BRFNfUEVSX0ZSQU1FKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZWZlcmVuY2UgdG8gdGhlIHJlbmRlcmVyLlxyXG4gICAgICAgICAqIEB0eXBlIHtQSVhJLkFic3RyYWN0UmVuZGVyZXJ9XHJcbiAgICAgICAgICogQHByb3RlY3RlZFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgb25seSByZWFsIGRpZmZlcmVuY2UgYmV0d2VlbiBDYW52YXNQcmVwYXJlIGFuZCBXZWJHTFByZXBhcmUgaXMgd2hhdCB0aGV5IHBhc3NcclxuICAgICAgICAgKiB0byB1cGxvYWQgaG9va3MuIFRoYXQgZGlmZmVyZW50IHBhcmFtZXRlciBpcyBzdG9yZWQgaGVyZS5cclxuICAgICAgICAgKiBAdHlwZSB7UElYSS5wcmVwYXJlLkNhbnZhc1ByZXBhcmV8UElYSS5SZW5kZXJlcn1cclxuICAgICAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy51cGxvYWRIb29rSGVscGVyID0gcmVuZGVyZXI7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ29sbGVjdGlvbiBvZiBpdGVtcyB0byB1cGxvYWRzIGF0IG9uY2UuXHJcbiAgICAgICAgICogQHR5cGUge0FycmF5PCo+fVxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5xdWV1ZSA9IFtdO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbGxlY3Rpb24gb2YgYWRkaXRpb25hbCBob29rcyBmb3IgZmluZGluZyBhc3NldHMuXHJcbiAgICAgICAgICogQHR5cGUge0FycmF5PEZ1bmN0aW9uPn1cclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuYWRkSG9va3MgPSBbXTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb2xsZWN0aW9uIG9mIGFkZGl0aW9uYWwgaG9va3MgZm9yIHByb2Nlc3NpbmcgYXNzZXRzLlxyXG4gICAgICAgICAqIEB0eXBlIHtBcnJheTxGdW5jdGlvbj59XHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnVwbG9hZEhvb2tzID0gW107XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2FsbGJhY2sgdG8gY2FsbCBhZnRlciBjb21wbGV0ZWQuXHJcbiAgICAgICAgICogQHR5cGUge0FycmF5PEZ1bmN0aW9uPn1cclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuY29tcGxldGVzID0gW107XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSWYgcHJlcGFyZSBpcyB0aWNraW5nIChydW5uaW5nKS5cclxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMudGlja2luZyA9IGZhbHNlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqICdib3VuZCcgY2FsbCBmb3IgcHJlcGFyZUl0ZW1zKCkuXHJcbiAgICAgICAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5kZWxheWVkVGljayA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgLy8gdW5saWtlbHksIGJ1dCBpbiBjYXNlIHdlIHdlcmUgZGVzdHJveWVkIGJldHdlZW4gdGljaygpIGFuZCBkZWxheWVkVGljaygpXHJcbiAgICAgICAgICAgIGlmICghdGhpcy5xdWV1ZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMucHJlcGFyZUl0ZW1zKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyBob29rcyB0byBmaW5kIHRoZSBjb3JyZWN0IHRleHR1cmVcclxuICAgICAgICB0aGlzLnJlZ2lzdGVyRmluZEhvb2soQmFzZVByZXBhcmUuZmluZFRleHQpO1xyXG4gICAgICAgIHRoaXMucmVnaXN0ZXJGaW5kSG9vayhCYXNlUHJlcGFyZS5maW5kVGV4dFN0eWxlKTtcclxuICAgICAgICB0aGlzLnJlZ2lzdGVyRmluZEhvb2soQmFzZVByZXBhcmUuZmluZE11bHRpcGxlQmFzZVRleHR1cmVzKTtcclxuICAgICAgICB0aGlzLnJlZ2lzdGVyRmluZEhvb2soQmFzZVByZXBhcmUuZmluZEJhc2VUZXh0dXJlKTtcclxuICAgICAgICB0aGlzLnJlZ2lzdGVyRmluZEhvb2soQmFzZVByZXBhcmUuZmluZFRleHR1cmUpO1xyXG4gICAgICAgIC8vIHVwbG9hZCBob29rc1xyXG4gICAgICAgIHRoaXMucmVnaXN0ZXJVcGxvYWRIb29rKEJhc2VQcmVwYXJlLmRyYXdUZXh0KTtcclxuICAgICAgICB0aGlzLnJlZ2lzdGVyVXBsb2FkSG9vayhCYXNlUHJlcGFyZS5jYWxjdWxhdGVUZXh0U3R5bGUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBVcGxvYWQgYWxsIHRoZSB0ZXh0dXJlcyBhbmQgZ3JhcGhpY3MgdG8gdGhlIEdQVS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufFBJWEkuRGlzcGxheU9iamVjdHxQSVhJLkNvbnRhaW5lcnxQSVhJLkJhc2VUZXh0dXJlfFBJWEkuVGV4dHVyZXxQSVhJLkdyYXBoaWNzfFBJWEkuVGV4dH0gaXRlbSAtXHJcbiAgICAgKiAgICBFaXRoZXIgdGhlIGNvbnRhaW5lciBvciBkaXNwbGF5IG9iamVjdCB0byBzZWFyY2ggZm9yIGl0ZW1zIHRvIHVwbG9hZCwgdGhlIGl0ZW1zIHRvIHVwbG9hZCB0aGVtc2VsdmVzLFxyXG4gICAgICogICAgb3IgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uLCBpZiBpdGVtcyBoYXZlIGJlZW4gYWRkZWQgdXNpbmcgYHByZXBhcmUuYWRkYC5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtkb25lXSAtIE9wdGlvbmFsIGNhbGxiYWNrIHdoZW4gYWxsIHF1ZXVlZCB1cGxvYWRzIGhhdmUgY29tcGxldGVkXHJcbiAgICAgKi9cclxuICAgIHVwbG9hZChpdGVtLCBkb25lKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBpdGVtID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIGRvbmUgPSBpdGVtO1xyXG4gICAgICAgICAgICBpdGVtID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gSWYgYSBkaXNwbGF5IG9iamVjdCwgc2VhcmNoIGZvciBpdGVtc1xyXG4gICAgICAgIC8vIHRoYXQgd2UgY291bGQgdXBsb2FkXHJcbiAgICAgICAgaWYgKGl0ZW0pIHtcclxuICAgICAgICAgICAgdGhpcy5hZGQoaXRlbSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEdldCB0aGUgaXRlbXMgZm9yIHVwbG9hZCBmcm9tIHRoZSBkaXNwbGF5XHJcbiAgICAgICAgaWYgKHRoaXMucXVldWUubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGlmIChkb25lKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbXBsZXRlcy5wdXNoKGRvbmUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghdGhpcy50aWNraW5nKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRpY2tpbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgVGlja2VyXzEuVGlja2VyLnN5c3RlbS5hZGRPbmNlKHRoaXMudGljaywgdGhpcywgVGlja2VyXzEuVGlja2VyLlVQREFURV9QUklPUklUWS5VVElMSVRZKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChkb25lKSB7XHJcbiAgICAgICAgICAgIGRvbmUoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIEhhbmRsZSB0aWNrIHVwZGF0ZVxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHRpY2soKSB7XHJcbiAgICAgICAgc2V0VGltZW91dCh0aGlzLmRlbGF5ZWRUaWNrLCAwKTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQWN0dWFsbHkgcHJlcGFyZSBpdGVtcy4gVGhpcyBpcyBoYW5kbGVkIG91dHNpZGUgb2YgdGhlIHRpY2sgYmVjYXVzZSBpdCB3aWxsIHRha2UgYSB3aGlsZVxyXG4gICAgICogYW5kIHdlIGRvIE5PVCB3YW50IHRvIGJsb2NrIHRoZSBjdXJyZW50IGFuaW1hdGlvbiBmcmFtZSBmcm9tIHJlbmRlcmluZy5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBwcmVwYXJlSXRlbXMoKSB7XHJcbiAgICAgICAgdGhpcy5saW1pdGVyLmJlZ2luRnJhbWUoKTtcclxuICAgICAgICAvLyBVcGxvYWQgdGhlIGdyYXBoaWNzXHJcbiAgICAgICAgd2hpbGUgKHRoaXMucXVldWUubGVuZ3RoICYmIHRoaXMubGltaXRlci5hbGxvd2VkVG9VcGxvYWQoKSkge1xyXG4gICAgICAgICAgICB2YXIgaXRlbSA9IHRoaXMucXVldWVbMF07XHJcbiAgICAgICAgICAgIHZhciB1cGxvYWRlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBpZiAoaXRlbSAmJiAhaXRlbS5fZGVzdHJveWVkKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy51cGxvYWRIb29rcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnVwbG9hZEhvb2tzW2ldKHRoaXMudXBsb2FkSG9va0hlbHBlciwgaXRlbSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5xdWV1ZS5zaGlmdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB1cGxvYWRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIXVwbG9hZGVkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnF1ZXVlLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gV2UncmUgZmluaXNoZWRcclxuICAgICAgICBpZiAoIXRoaXMucXVldWUubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHRoaXMudGlja2luZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICB2YXIgY29tcGxldGVzID0gdGhpcy5jb21wbGV0ZXMuc2xpY2UoMCk7XHJcbiAgICAgICAgICAgIHRoaXMuY29tcGxldGVzLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkkMSA9IDAsIGxlbiQxID0gY29tcGxldGVzLmxlbmd0aDsgaSQxIDwgbGVuJDE7IGkkMSsrKSB7XHJcbiAgICAgICAgICAgICAgICBjb21wbGV0ZXNbaSQxXSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBpZiB3ZSBhcmUgbm90IGZpbmlzaGVkLCBvbiB0aGUgbmV4dCByQUYgZG8gdGhpcyBhZ2FpblxyXG4gICAgICAgICAgICBUaWNrZXJfMS5UaWNrZXIuc3lzdGVtLmFkZE9uY2UodGhpcy50aWNrLCB0aGlzLCBUaWNrZXJfMS5UaWNrZXIuVVBEQVRFX1BSSU9SSVRZLlVUSUxJVFkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBob29rcyBmb3IgZmluZGluZyBpdGVtcy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBhZGRIb29rIC0gRnVuY3Rpb24gY2FsbCB0aGF0IHRha2VzIHR3byBwYXJhbWV0ZXJzOiBgaXRlbToqLCBxdWV1ZTpBcnJheWBcclxuICAgICAqICAgICAgZnVuY3Rpb24gbXVzdCByZXR1cm4gYHRydWVgIGlmIGl0IHdhcyBhYmxlIHRvIGFkZCBpdGVtIHRvIHRoZSBxdWV1ZS5cclxuICAgICAqIEByZXR1cm4ge1BJWEkucHJlcGFyZS5CYXNlUHJlcGFyZX0gSW5zdGFuY2Ugb2YgcGx1Z2luIGZvciBjaGFpbmluZy5cclxuICAgICAqL1xyXG4gICAgcmVnaXN0ZXJGaW5kSG9vayhhZGRIb29rKSB7XHJcbiAgICAgICAgaWYgKGFkZEhvb2spIHtcclxuICAgICAgICAgICAgdGhpcy5hZGRIb29rcy5wdXNoKGFkZEhvb2spO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBob29rcyBmb3IgdXBsb2FkaW5nIGl0ZW1zLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHVwbG9hZEhvb2sgLSBGdW5jdGlvbiBjYWxsIHRoYXQgdGFrZXMgdHdvIHBhcmFtZXRlcnM6IGBwcmVwYXJlOkNhbnZhc1ByZXBhcmUsIGl0ZW06KmAgYW5kXHJcbiAgICAgKiAgICAgIGZ1bmN0aW9uIG11c3QgcmV0dXJuIGB0cnVlYCBpZiBpdCB3YXMgYWJsZSB0byBoYW5kbGUgdXBsb2FkIG9mIGl0ZW0uXHJcbiAgICAgKiBAcmV0dXJuIHtQSVhJLnByZXBhcmUuQmFzZVByZXBhcmV9IEluc3RhbmNlIG9mIHBsdWdpbiBmb3IgY2hhaW5pbmcuXHJcbiAgICAgKi9cclxuICAgIHJlZ2lzdGVyVXBsb2FkSG9vayh1cGxvYWRIb29rKSB7XHJcbiAgICAgICAgaWYgKHVwbG9hZEhvb2spIHtcclxuICAgICAgICAgICAgdGhpcy51cGxvYWRIb29rcy5wdXNoKHVwbG9hZEhvb2spO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogTWFudWFsbHkgYWRkIGFuIGl0ZW0gdG8gdGhlIHVwbG9hZGluZyBxdWV1ZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1BJWEkuRGlzcGxheU9iamVjdHxQSVhJLkNvbnRhaW5lcnxQSVhJLkJhc2VUZXh0dXJlfFBJWEkuVGV4dHVyZXxQSVhJLkdyYXBoaWNzfFBJWEkuVGV4dHwqfSBpdGVtIC0gT2JqZWN0IHRvXHJcbiAgICAgKiAgICBhZGQgdG8gdGhlIHF1ZXVlXHJcbiAgICAgKiBAcmV0dXJuIHtQSVhJLnByZXBhcmUuQmFzZVByZXBhcmV9IEluc3RhbmNlIG9mIHBsdWdpbiBmb3IgY2hhaW5pbmcuXHJcbiAgICAgKi9cclxuICAgIGFkZChpdGVtKSB7XHJcbiAgICAgICAgLy8gQWRkIGFkZGl0aW9uYWwgaG9va3MgZm9yIGZpbmRpbmcgZWxlbWVudHMgb24gc3BlY2lhbFxyXG4gICAgICAgIC8vIHR5cGVzIG9mIG9iamVjdHMgdGhhdFxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLmFkZEhvb2tzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmFkZEhvb2tzW2ldKGl0ZW0sIHRoaXMucXVldWUpKSB7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBHZXQgY2hpbGRyZW4gcmVjdXJzaXZlbHlcclxuICAgICAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIENvbnRhaW5lcl8xLkNvbnRhaW5lcikge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpJDEgPSBpdGVtLmNoaWxkcmVuLmxlbmd0aCAtIDE7IGkkMSA+PSAwOyBpJDEtLSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hZGQoaXRlbS5jaGlsZHJlbltpJDFdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogRGVzdHJveXMgdGhlIHBsdWdpbiwgZG9uJ3QgdXNlIGFmdGVyIHRoaXMuXHJcbiAgICAgKlxyXG4gICAgICovXHJcbiAgICBkZXN0cm95KCkge1xyXG4gICAgICAgIGlmICh0aGlzLnRpY2tpbmcpIHtcclxuICAgICAgICAgICAgVGlja2VyXzEuVGlja2VyLnN5c3RlbS5yZW1vdmUodGhpcy50aWNrLCB0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy50aWNraW5nID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5hZGRIb29rcyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy51cGxvYWRIb29rcyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5jb21wbGV0ZXMgPSBudWxsO1xyXG4gICAgICAgIHRoaXMucXVldWUgPSBudWxsO1xyXG4gICAgICAgIHRoaXMubGltaXRlciA9IG51bGw7XHJcbiAgICAgICAgdGhpcy51cGxvYWRIb29rSGVscGVyID0gbnVsbDtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gKiBCdWlsdC1pbiBob29rIHRvIGZpbmQgVGV4dCBvYmplY3RzLlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAcGFyYW0ge1BJWEkuRGlzcGxheU9iamVjdH0gaXRlbSAtIERpc3BsYXkgb2JqZWN0IHRvIGNoZWNrXHJcbiAqIEBwYXJhbSB7QXJyYXk8Kj59IHF1ZXVlIC0gQ29sbGVjdGlvbiBvZiBpdGVtcyB0byB1cGxvYWRcclxuICogQHJldHVybiB7Ym9vbGVhbn0gaWYgYSBQSVhJLlRleHQgb2JqZWN0IHdhcyBmb3VuZC5cclxuICovXHJcbiAgICBzdGF0aWMgZmluZFRleHQoaXRlbSwgcXVldWUpIHtcclxuICAgICAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIFRleHRfMS5UZXh0KSB7XHJcbiAgICAgICAgICAgIC8vIHB1c2ggdGhlIHRleHQgc3R5bGUgdG8gcHJlcGFyZSBpdCAtIHRoaXMgY2FuIGJlIHJlYWxseSBleHBlbnNpdmVcclxuICAgICAgICAgICAgaWYgKHF1ZXVlLmluZGV4T2YoaXRlbS5zdHlsZSkgPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICBxdWV1ZS5wdXNoKGl0ZW0uc3R5bGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGFsc28gcHVzaCB0aGUgdGV4dCBvYmplY3Qgc28gdGhhdCB3ZSBjYW4gcmVuZGVyIGl0ICh0byBjYW52YXMvdGV4dHVyZSkgaWYgbmVlZGVkXHJcbiAgICAgICAgICAgIGlmIChxdWV1ZS5pbmRleE9mKGl0ZW0pID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgcXVldWUucHVzaChpdGVtKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBhbHNvIHB1c2ggdGhlIFRleHQncyB0ZXh0dXJlIGZvciB1cGxvYWQgdG8gR1BVXHJcbiAgICAgICAgICAgIHZhciB0ZXh0dXJlID0gaXRlbS5fdGV4dHVyZS5iYXNlVGV4dHVyZTtcclxuICAgICAgICAgICAgaWYgKHF1ZXVlLmluZGV4T2YodGV4dHVyZSkgPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICBxdWV1ZS5wdXNoKHRleHR1cmUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICogQnVpbHQtaW4gaG9vayB0byBmaW5kIFRleHRTdHlsZSBvYmplY3RzLlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAcGFyYW0ge1BJWEkuVGV4dFN0eWxlfSBpdGVtIC0gRGlzcGxheSBvYmplY3QgdG8gY2hlY2tcclxuICogQHBhcmFtIHtBcnJheTwqPn0gcXVldWUgLSBDb2xsZWN0aW9uIG9mIGl0ZW1zIHRvIHVwbG9hZFxyXG4gKiBAcmV0dXJuIHtib29sZWFufSBpZiBhIFBJWEkuVGV4dFN0eWxlIG9iamVjdCB3YXMgZm91bmQuXHJcbiAqL1xyXG4gICAgc3RhdGljIGZpbmRUZXh0U3R5bGUoaXRlbSwgcXVldWUpIHtcclxuICAgICAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIFRleHRTdHlsZV8xLlRleHRTdHlsZSkge1xyXG4gICAgICAgICAgICBpZiAocXVldWUuaW5kZXhPZihpdGVtKSA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIHF1ZXVlLnB1c2goaXRlbSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gKiBCdWlsdC1pbiBob29rIHRvIGZpbmQgbXVsdGlwbGUgdGV4dHVyZXMgZnJvbSBvYmplY3RzIGxpa2UgQW5pbWF0ZWRTcHJpdGVzLlxyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAcGFyYW0ge1BJWEkuRGlzcGxheU9iamVjdH0gaXRlbSAtIERpc3BsYXkgb2JqZWN0IHRvIGNoZWNrXHJcbiAqIEBwYXJhbSB7QXJyYXk8Kj59IHF1ZXVlIC0gQ29sbGVjdGlvbiBvZiBpdGVtcyB0byB1cGxvYWRcclxuICogQHJldHVybiB7Ym9vbGVhbn0gaWYgYSBQSVhJLlRleHR1cmUgb2JqZWN0IHdhcyBmb3VuZC5cclxuICovXHJcbiAgICBzdGF0aWMgZmluZE11bHRpcGxlQmFzZVRleHR1cmVzKGl0ZW0sIHF1ZXVlKSB7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IGZhbHNlO1xyXG4gICAgICAgIC8vIE9iamVjdHMgd2l0aCBtdWx0aXBsZSB0ZXh0dXJlc1xyXG4gICAgICAgIGlmIChpdGVtICYmIGl0ZW0uX3RleHR1cmVzICYmIGl0ZW0uX3RleHR1cmVzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGl0ZW0uX3RleHR1cmVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXRlbS5fdGV4dHVyZXNbaV0gaW5zdGFuY2VvZiBUZXh0dXJlXzEuVGV4dHVyZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBiYXNlVGV4dHVyZSA9IGl0ZW0uX3RleHR1cmVzW2ldLmJhc2VUZXh0dXJlO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChxdWV1ZS5pbmRleE9mKGJhc2VUZXh0dXJlKSA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcXVldWUucHVzaChiYXNlVGV4dHVyZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICogQnVpbHQtaW4gaG9vayB0byBmaW5kIEJhc2VUZXh0dXJlcyBmcm9tIFNwcml0ZXMuXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBwYXJhbSB7UElYSS5EaXNwbGF5T2JqZWN0fSBpdGVtIC0gRGlzcGxheSBvYmplY3QgdG8gY2hlY2tcclxuICogQHBhcmFtIHtBcnJheTwqPn0gcXVldWUgLSBDb2xsZWN0aW9uIG9mIGl0ZW1zIHRvIHVwbG9hZFxyXG4gKiBAcmV0dXJuIHtib29sZWFufSBpZiBhIFBJWEkuVGV4dHVyZSBvYmplY3Qgd2FzIGZvdW5kLlxyXG4gKi9cclxuICAgIHN0YXRpYyBmaW5kQmFzZVRleHR1cmUoaXRlbSwgcXVldWUpIHtcclxuICAgICAgICAvLyBPYmplY3RzIHdpdGggdGV4dHVyZXMsIGxpa2UgU3ByaXRlcy9UZXh0XHJcbiAgICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBCYXNlVGV4dHVyZV8xLkJhc2VUZXh0dXJlKSB7XHJcbiAgICAgICAgICAgIGlmIChxdWV1ZS5pbmRleE9mKGl0ZW0pID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgcXVldWUucHVzaChpdGVtKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAqIEJ1aWx0LWluIGhvb2sgdG8gZmluZCB0ZXh0dXJlcyBmcm9tIG9iamVjdHMuXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBwYXJhbSB7UElYSS5EaXNwbGF5T2JqZWN0fSBpdGVtIC0gRGlzcGxheSBvYmplY3QgdG8gY2hlY2tcclxuICogQHBhcmFtIHtBcnJheTwqPn0gcXVldWUgLSBDb2xsZWN0aW9uIG9mIGl0ZW1zIHRvIHVwbG9hZFxyXG4gKiBAcmV0dXJuIHtib29sZWFufSBpZiBhIFBJWEkuVGV4dHVyZSBvYmplY3Qgd2FzIGZvdW5kLlxyXG4gKi9cclxuICAgIHN0YXRpYyBmaW5kVGV4dHVyZShpdGVtLCBxdWV1ZSkge1xyXG4gICAgICAgIGlmIChpdGVtLl90ZXh0dXJlICYmIGl0ZW0uX3RleHR1cmUgaW5zdGFuY2VvZiBUZXh0dXJlXzEuVGV4dHVyZSkge1xyXG4gICAgICAgICAgICB2YXIgdGV4dHVyZSA9IGl0ZW0uX3RleHR1cmUuYmFzZVRleHR1cmU7XHJcbiAgICAgICAgICAgIGlmIChxdWV1ZS5pbmRleE9mKHRleHR1cmUpID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgcXVldWUucHVzaCh0ZXh0dXJlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBCdWlsdC1pbiBob29rIHRvIGRyYXcgUElYSS5UZXh0IHRvIGl0cyB0ZXh0dXJlLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge1BJWEkuUmVuZGVyZXJ8UElYSS5DYW52YXNQcmVwYXJlfSBoZWxwZXIgLSBOb3QgdXNlZCBieSB0aGlzIHVwbG9hZCBoYW5kbGVyXHJcbiAgICAgKiBAcGFyYW0ge1BJWEkuRGlzcGxheU9iamVjdH0gaXRlbSAtIEl0ZW0gdG8gY2hlY2tcclxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IElmIGl0ZW0gd2FzIHVwbG9hZGVkLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZHJhd1RleHQoaGVscGVyLCBpdGVtKSB7XHJcbiAgICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBUZXh0XzEuVGV4dCkge1xyXG4gICAgICAgICAgICAvLyB1cGRhdGluZyB0ZXh0IHdpbGwgcmV0dXJuIGVhcmx5IGlmIGl0IGlzIG5vdCBkaXJ0eVxyXG4gICAgICAgICAgICBpdGVtLnVwZGF0ZVRleHQodHJ1ZSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICogQnVpbHQtaW4gaG9vayB0byBjYWxjdWxhdGUgYSB0ZXh0IHN0eWxlIGZvciBhIFBJWEkuVGV4dCBvYmplY3QuXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBwYXJhbSB7UElYSS5SZW5kZXJlcnxQSVhJLkNhbnZhc1ByZXBhcmV9IGhlbHBlciAtIE5vdCB1c2VkIGJ5IHRoaXMgdXBsb2FkIGhhbmRsZXJcclxuICogQHBhcmFtIHtQSVhJLkRpc3BsYXlPYmplY3R9IGl0ZW0gLSBJdGVtIHRvIGNoZWNrXHJcbiAqIEByZXR1cm4ge2Jvb2xlYW59IElmIGl0ZW0gd2FzIHVwbG9hZGVkLlxyXG4gKi9cclxuICAgIHN0YXRpYyBjYWxjdWxhdGVUZXh0U3R5bGUoaGVscGVyLCBpdGVtKSB7XHJcbiAgICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBUZXh0U3R5bGVfMS5UZXh0U3R5bGUpIHtcclxuICAgICAgICAgICAgdmFyIGZvbnQgPSBpdGVtLnRvRm9udFN0cmluZygpO1xyXG4gICAgICAgICAgICBUZXh0TWV0cmljc18xLlRleHRNZXRyaWNzLm1lYXN1cmVGb250KGZvbnQpO1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuQmFzZVByZXBhcmUgPSBCYXNlUHJlcGFyZTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgQmFzZVRleHR1cmVfMSA9IHJlcXVpcmUoXCIuL0Jhc2VUZXh0dXJlXCIpO1xyXG5jb25zdCBGcmFtZWJ1ZmZlcl8xID0gcmVxdWlyZShcIi4vRnJhbWVidWZmZXJcIik7XHJcbmNsYXNzIEJhc2VSZW5kZXJUZXh0dXJlIGV4dGVuZHMgQmFzZVRleHR1cmVfMS5CYXNlVGV4dHVyZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zLCBhcmcxID0gbnVsbCwgYXJnMiA9IG51bGwsIGFyZzQgPSBudWxsKSB7XHJcbiAgICAgICAgc3VwZXIobnVsbCwgb3B0aW9ucyk7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBwcmVmZXItcmVzdC1wYXJhbXMgKi9cclxuICAgICAgICAgICAgLy8gQmFja3dhcmQgY29tcGF0aWJpbGl0eSBvZiBzaWduYXR1cmVcclxuICAgICAgICAgICAgdmFyIHdpZHRoJDEgPSBhcmd1bWVudHNbMF07XHJcbiAgICAgICAgICAgIHZhciBoZWlnaHQkMSA9IGFyZ3VtZW50c1sxXTtcclxuICAgICAgICAgICAgdmFyIHNjYWxlTW9kZSA9IGFyZ3VtZW50c1syXTtcclxuICAgICAgICAgICAgdmFyIHJlc29sdXRpb24gPSBhcmd1bWVudHNbM107XHJcbiAgICAgICAgICAgIG9wdGlvbnMgPSB7IHdpZHRoOiB3aWR0aCQxLCBoZWlnaHQ6IGhlaWdodCQxLCBzY2FsZU1vZGU6IHNjYWxlTW9kZSwgcmVzb2x1dGlvbjogcmVzb2x1dGlvbiB9O1xyXG4gICAgICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIHByZWZlci1yZXN0LXBhcmFtcyAqL1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcmVmID0gb3B0aW9ucyB8fCB7fTtcclxuICAgICAgICB2YXIgd2lkdGggPSByZWYud2lkdGg7XHJcbiAgICAgICAgdmFyIGhlaWdodCA9IHJlZi5oZWlnaHQ7XHJcbiAgICAgICAgLy8gU2V0IGRlZmF1bHRzXHJcbiAgICAgICAgdGhpcy5taXBtYXAgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLndpZHRoID0gTWF0aC5jZWlsKHdpZHRoKSB8fCAxMDA7XHJcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBNYXRoLmNlaWwoaGVpZ2h0KSB8fCAxMDA7XHJcbiAgICAgICAgdGhpcy52YWxpZCA9IHRydWU7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQSByZWZlcmVuY2UgdG8gdGhlIGNhbnZhcyByZW5kZXIgdGFyZ2V0ICh3ZSBvbmx5IG5lZWQgb25lIGFzIHRoaXMgY2FuIGJlIHNoYXJlZCBhY3Jvc3MgcmVuZGVyZXJzKVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHByb3RlY3RlZFxyXG4gICAgICAgICAqIEBtZW1iZXIge29iamVjdH1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLl9jYW52YXNSZW5kZXJUYXJnZXQgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuY2xlYXJDb2xvciA9IFswLCAwLCAwLCAwXTtcclxuICAgICAgICB0aGlzLmZyYW1lYnVmZmVyID0gbmV3IEZyYW1lYnVmZmVyXzEuRnJhbWVidWZmZXIodGhpcy53aWR0aCAqIHRoaXMucmVzb2x1dGlvbiwgdGhpcy5oZWlnaHQgKiB0aGlzLnJlc29sdXRpb24pXHJcbiAgICAgICAgICAgIC5hZGRDb2xvclRleHR1cmUoMCwgdGhpcylcclxuICAgICAgICAgICAgLmVuYWJsZVN0ZW5jaWwoKTtcclxuICAgICAgICAvLyBUT0RPIC0gY291bGQgdGhpcyBiZSBhZGRlZCB0aGUgc3lzdGVtcz9cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgZGF0YSBzdHJ1Y3R1cmUgZm9yIHRoZSBzdGVuY2lsIG1hc2tzLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQG1lbWJlciB7UElYSS5HcmFwaGljc1tdfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuc3RlbmNpbE1hc2tTdGFjayA9IFtdO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBkYXRhIHN0cnVjdHVyZSBmb3IgdGhlIGZpbHRlcnMuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLkdyYXBoaWNzW119XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5maWx0ZXJTdGFjayA9IFt7fV07XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlc2l6ZXMgdGhlIEJhc2VSZW5kZXJUZXh0dXJlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCAtIFRoZSB3aWR0aCB0byByZXNpemUgdG8uXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IC0gVGhlIGhlaWdodCB0byByZXNpemUgdG8uXHJcbiAgICAgKi9cclxuICAgIHJlc2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICAgICAgd2lkdGggPSBNYXRoLmNlaWwod2lkdGgpO1xyXG4gICAgICAgIGhlaWdodCA9IE1hdGguY2VpbChoZWlnaHQpO1xyXG4gICAgICAgIHRoaXMuZnJhbWVidWZmZXIucmVzaXplKHdpZHRoICogdGhpcy5yZXNvbHV0aW9uLCBoZWlnaHQgKiB0aGlzLnJlc29sdXRpb24pO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBGcmVlcyB0aGUgdGV4dHVyZSBhbmQgZnJhbWVidWZmZXIgZnJvbSBXZWJHTCBtZW1vcnkgd2l0aG91dCBkZXN0cm95aW5nIHRoaXMgdGV4dHVyZSBvYmplY3QuXHJcbiAgICAgKiBUaGlzIG1lYW5zIHlvdSBjYW4gc3RpbGwgdXNlIHRoZSB0ZXh0dXJlIGxhdGVyIHdoaWNoIHdpbGwgdXBsb2FkIGl0IHRvIEdQVVxyXG4gICAgICogbWVtb3J5IGFnYWluLlxyXG4gICAgICpcclxuICAgICAqIEBmaXJlcyBQSVhJLkJhc2VUZXh0dXJlI2Rpc3Bvc2VcclxuICAgICAqL1xyXG4gICAgZGlzcG9zZSgpIHtcclxuICAgICAgICB0aGlzLmZyYW1lYnVmZmVyLmRpc3Bvc2UoKTtcclxuICAgICAgICBzdXBlci5kaXNwb3NlKCk7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIERlc3Ryb3lzIHRoaXMgdGV4dHVyZS5cclxuICAgICAqXHJcbiAgICAgKi9cclxuICAgIGRlc3Ryb3koKSB7XHJcbiAgICAgICAgc3VwZXIuZGVzdHJveSgpO1xyXG4gICAgICAgIHRoaXMuZnJhbWVidWZmZXIgPSBudWxsO1xyXG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgO1xyXG59XHJcbmV4cG9ydHMuQmFzZVJlbmRlclRleHR1cmUgPSBCYXNlUmVuZGVyVGV4dHVyZTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgRXZlbnREaXNwYXRjaGVyXzEgPSByZXF1aXJlKFwiLi9FdmVudERpc3BhdGNoZXJcIik7XHJcbmNvbnN0IEV2ZW50XzEgPSByZXF1aXJlKFwiLi9FdmVudFwiKTtcclxuY29uc3QgUmVzb3VyY2VfMSA9IHJlcXVpcmUoXCIuL1Jlc291cmNlXCIpO1xyXG5jb25zdCBCdWZmZXJSZXNvdXJjZV8xID0gcmVxdWlyZShcIi4vQnVmZmVyUmVzb3VyY2VcIik7XHJcbmNvbnN0IERpc3BsYXlTZXR0aW5nc18xID0gcmVxdWlyZShcIi4vRGlzcGxheVNldHRpbmdzXCIpO1xyXG5jb25zdCBNYXRoU2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL01hdGhTZXR0aW5nc1wiKTtcclxuY29uc3QgV2ViR0xTZXR0aW5nc18xID0gcmVxdWlyZShcIi4vV2ViR0xTZXR0aW5nc1wiKTtcclxuY29uc3QgQ2FjaGVTZXR0aW5nc18xID0gcmVxdWlyZShcIi4vQ2FjaGVTZXR0aW5nc1wiKTtcclxuY29uc3QgUmVzb3VyY2VTZXR0aW5nc18xID0gcmVxdWlyZShcIi4vUmVzb3VyY2VTZXR0aW5nc1wiKTtcclxuY29uc3QgTG9nZ2VyXzEgPSByZXF1aXJlKFwiLi9Mb2dnZXJcIik7XHJcbmNsYXNzIEJhc2VUZXh0dXJlIGV4dGVuZHMgRXZlbnREaXNwYXRjaGVyXzEuRXZlbnREaXNwYXRjaGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKHJlc291cmNlID0gbnVsbCwgb3B0aW9ucyA9IG51bGwpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuaGFuZGxlUmVzaXplID0gKGV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0UmVhbFNpemUodGhpcy5yZXNvdXJjZS53aWR0aCwgdGhpcy5yZXNvdXJjZS5oZWlnaHQpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5oYW5kbGVVcGRhdGUgPSAoZXZlbnQpID0+IHtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGUoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG4gICAgICAgIHZhciBwcmVtdWx0aXBseUFscGhhID0gb3B0aW9ucy5wcmVtdWx0aXBseUFscGhhO1xyXG4gICAgICAgIHZhciBtaXBtYXAgPSBvcHRpb25zLm1pcG1hcDtcclxuICAgICAgICB2YXIgc2NhbGVNb2RlID0gb3B0aW9ucy5zY2FsZU1vZGU7XHJcbiAgICAgICAgdmFyIHdpZHRoID0gb3B0aW9ucy53aWR0aDtcclxuICAgICAgICB2YXIgaGVpZ2h0ID0gb3B0aW9ucy5oZWlnaHQ7XHJcbiAgICAgICAgdmFyIHdyYXBNb2RlID0gb3B0aW9ucy53cmFwTW9kZTtcclxuICAgICAgICB2YXIgZm9ybWF0ID0gb3B0aW9ucy5mb3JtYXQ7XHJcbiAgICAgICAgdmFyIHR5cGUgPSBvcHRpb25zLnR5cGU7XHJcbiAgICAgICAgdmFyIHRhcmdldCA9IG9wdGlvbnMudGFyZ2V0O1xyXG4gICAgICAgIHZhciByZXNvbHV0aW9uID0gb3B0aW9ucy5yZXNvbHV0aW9uO1xyXG4gICAgICAgIHZhciByZXNvdXJjZU9wdGlvbnMgPSBvcHRpb25zLnJlc291cmNlT3B0aW9ucztcclxuICAgICAgICAvLyBDb252ZXJ0IHRoZSByZXNvdXJjZSB0byBhIFJlc291cmNlIG9iamVjdFxyXG4gICAgICAgIGlmIChyZXNvdXJjZSAmJiByZXNvdXJjZSBpbnN0YW5jZW9mIEltYWdlQml0bWFwKSB7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHJlc291cmNlICYmICEocmVzb3VyY2UgaW5zdGFuY2VvZiBSZXNvdXJjZV8xLlJlc291cmNlKSkge1xyXG4gICAgICAgICAgICByZXNvdXJjZSA9IFJlc291cmNlU2V0dGluZ3NfMS5SZXNvdXJjZVNldHRpbmdzLmF1dG9EZXRlY3RSZXNvdXJjZShyZXNvdXJjZSwgcmVzb3VyY2VPcHRpb25zKTtcclxuICAgICAgICAgICAgTG9nZ2VyXzEucmV2ZWFsKHJlc291cmNlKTtcclxuICAgICAgICAgICAgcmVzb3VyY2UuaW50ZXJuYWwgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgd2lkdGggb2YgdGhlIGJhc2UgdGV4dHVyZSBzZXQgd2hlbiB0aGUgaW1hZ2UgaGFzIGxvYWRlZFxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHJlYWRvbmx5XHJcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMud2lkdGggPSB3aWR0aCB8fCAwO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBoZWlnaHQgb2YgdGhlIGJhc2UgdGV4dHVyZSBzZXQgd2hlbiB0aGUgaW1hZ2UgaGFzIGxvYWRlZFxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHJlYWRvbmx5XHJcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0IHx8IDA7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIHJlc29sdXRpb24gLyBkZXZpY2UgcGl4ZWwgcmF0aW8gb2YgdGhlIHRleHR1cmVcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAgICAgKiBAZGVmYXVsdCBQSVhJLnNldHRpbmdzLlJFU09MVVRJT05cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnJlc29sdXRpb24gPSByZXNvbHV0aW9uIHx8IERpc3BsYXlTZXR0aW5nc18xLkRpc3BsYXlTZXR0aW5ncy5SRVNPTFVUSU9OO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIE1pcG1hcCBtb2RlIG9mIHRoZSB0ZXh0dXJlLCBhZmZlY3RzIGRvd25zY2FsZWQgaW1hZ2VzXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLk1JUE1BUF9NT0RFU31cclxuICAgICAgICAgKiBAZGVmYXVsdCBQSVhJLnNldHRpbmdzLk1JUE1BUF9URVhUVVJFU1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMubWlwbWFwID0gbWlwbWFwICE9PSB1bmRlZmluZWQgPyBtaXBtYXAgOiBXZWJHTFNldHRpbmdzXzEuV2ViR0xTZXR0aW5ncy5NSVBNQVBfVEVYVFVSRVM7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSG93IHRoZSB0ZXh0dXJlIHdyYXBzXHJcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMud3JhcE1vZGUgPSB3cmFwTW9kZSB8fCBXZWJHTFNldHRpbmdzXzEuV2ViR0xTZXR0aW5ncy5XUkFQX01PREU7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIHNjYWxlIG1vZGUgdG8gYXBwbHkgd2hlbiBzY2FsaW5nIHRoaXMgdGV4dHVyZVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQG1lbWJlciB7UElYSS5TQ0FMRV9NT0RFU31cclxuICAgICAgICAgKiBAZGVmYXVsdCBQSVhJLnNldHRpbmdzLlNDQUxFX01PREVcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnNjYWxlTW9kZSA9IHNjYWxlTW9kZSAhPT0gdW5kZWZpbmVkID8gc2NhbGVNb2RlIDogRGlzcGxheVNldHRpbmdzXzEuRGlzcGxheVNldHRpbmdzLlNDQUxFX01PREU7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIHBpeGVsIGZvcm1hdCBvZiB0aGUgdGV4dHVyZVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQG1lbWJlciB7UElYSS5GT1JNQVRTfVxyXG4gICAgICAgICAqIEBkZWZhdWx0IFBJWEkuRk9STUFUUy5SR0JBXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5mb3JtYXQgPSBmb3JtYXQgfHwgV2ViR0xTZXR0aW5nc18xLldlYkdMU2V0dGluZ3MuRk9STUFUUy5SR0JBO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSB0eXBlIG9mIHJlc291cmNlIGRhdGFcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuVFlQRVN9XHJcbiAgICAgICAgICogQGRlZmF1bHQgUElYSS5UWVBFUy5VTlNJR05FRF9CWVRFXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZSB8fCBXZWJHTFNldHRpbmdzXzEuV2ViR0xTZXR0aW5ncy5UWVBFUy5VTlNJR05FRF9CWVRFO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSB0YXJnZXQgdHlwZVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQG1lbWJlciB7UElYSS5UQVJHRVRTfVxyXG4gICAgICAgICAqIEBkZWZhdWx0IFBJWEkuVEFSR0VUUy5URVhUVVJFXzJEXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXQgfHwgV2ViR0xTZXR0aW5nc18xLldlYkdMU2V0dGluZ3MuVEFSR0VUUy5URVhUVVJFXzJEO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNldCB0byB0cnVlIHRvIGVuYWJsZSBwcmUtbXVsdGlwbGllZCBhbHBoYVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQG1lbWJlciB7Ym9vbGVhbn1cclxuICAgICAgICAgKiBAZGVmYXVsdCB0cnVlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5wcmVtdWx0aXBseUFscGhhID0gcHJlbXVsdGlwbHlBbHBoYSAhPT0gZmFsc2U7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2xvYmFsIHVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGlzIEJhc2VUZXh0dXJlXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAbWVtYmVyIHtzdHJpbmd9XHJcbiAgICAgICAgICogQHByb3RlY3RlZFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMudWlkID0gTWF0aFNldHRpbmdzXzEuTWF0aFNldHRpbmdzLnVpZCgpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFVzZWQgYnkgYXV0b21hdGljIHRleHR1cmUgR2FyYmFnZSBDb2xsZWN0aW9uLCBzdG9yZXMgbGFzdCBHQyB0aWNrIHdoZW4gaXQgd2FzIGJvdW5kXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgICAgICogQHByb3RlY3RlZFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMudG91Y2hlZCA9IDA7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogV2hldGhlciBvciBub3QgdGhlIHRleHR1cmUgaXMgYSBwb3dlciBvZiB0d28sIHRyeSB0byB1c2UgcG93ZXIgb2YgdHdvIHRleHR1cmVzIGFzIG11Y2hcclxuICAgICAgICAgKiBhcyB5b3UgY2FuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcmVhZG9ubHlcclxuICAgICAgICAgKiBAbWVtYmVyIHtib29sZWFufVxyXG4gICAgICAgICAqIEBkZWZhdWx0IGZhbHNlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5pc1Bvd2VyT2ZUd28gPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9yZWZyZXNoUE9UKCk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIG1hcCBvZiByZW5kZXIgY29udGV4dCB0ZXh0dXJlcyB3aGVyZSB0aGlzIGlzIGJvdW5kXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9XHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLl9nbFRleHR1cmVzID0ge307XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVXNlZCBieSBUZXh0dXJlU3lzdGVtIHRvIG9ubHkgdXBkYXRlIHRleHR1cmUgdG8gdGhlIEdQVSB3aGVuIG5lZWRlZC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5kaXJ0eUlkID0gMDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBVc2VkIGJ5IFRleHR1cmVTeXN0ZW0gdG8gb25seSB1cGRhdGUgdGV4dHVyZSBzdHlsZSB3aGVuIG5lZWRlZC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5kaXJ0eVN0eWxlSWQgPSAwO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEN1cnJlbnRseSBkZWZhdWx0IGNhY2hlIElELlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQG1lbWJlciB7c3RyaW5nfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuY2FjaGVJZCA9IG51bGw7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2VuZXJhbGx5IHNwZWFraW5nIG1lYW5zIHdoZW4gcmVzb3VyY2UgaXMgbG9hZGVkLlxyXG4gICAgICAgICAqIEByZWFkb25seVxyXG4gICAgICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy52YWxpZCA9IHdpZHRoID4gMCAmJiBoZWlnaHQgPiAwO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBjb2xsZWN0aW9uIG9mIGFsdGVybmF0aXZlIGNhY2hlIGlkcywgc2luY2Ugc29tZSBCYXNlVGV4dHVyZXNcclxuICAgICAgICAgKiBjYW4gaGF2ZSBtb3JlIHRoYW4gb25lIElELCBzaG9ydCBuYW1lIGFuZCBsb25nZXIgZnVsbCBVUkxcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBtZW1iZXIge0FycmF5PHN0cmluZz59XHJcbiAgICAgICAgICogQHJlYWRvbmx5XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy50ZXh0dXJlQ2FjaGVJZHMgPSBbXTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBGbGFnIGlmIEJhc2VUZXh0dXJlIGhhcyBiZWVuIGRlc3Ryb3llZC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XHJcbiAgICAgICAgICogQHJlYWRvbmx5XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgcmVzb3VyY2UgdXNlZCBieSB0aGlzIEJhc2VUZXh0dXJlLCB0aGVyZSBjYW4gb25seVxyXG4gICAgICAgICAqIGJlIG9uZSByZXNvdXJjZSBwZXIgQmFzZVRleHR1cmUsIGJ1dCB0ZXh0dXJlcyBjYW4gc2hhcmVcclxuICAgICAgICAgKiByZXNvdXJjZXMuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLnJlc291cmNlcy5SZXNvdXJjZX1cclxuICAgICAgICAgKiBAcmVhZG9ubHlcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnJlc291cmNlID0gbnVsbDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBOdW1iZXIgb2YgdGhlIHRleHR1cmUgYmF0Y2gsIHVzZWQgYnkgbXVsdGktdGV4dHVyZSByZW5kZXJlcnNcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLl9iYXRjaEVuYWJsZWQgPSAwO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEZpcmVkIHdoZW4gYSBub3QtaW1tZWRpYXRlbHktYXZhaWxhYmxlIHNvdXJjZSBmaW5pc2hlcyBsb2FkaW5nLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHByb3RlY3RlZFxyXG4gICAgICAgICAqIEBldmVudCBQSVhJLkJhc2VUZXh0dXJlI2xvYWRlZFxyXG4gICAgICAgICAqIEBwYXJhbSB7UElYSS5CYXNlVGV4dHVyZX0gYmFzZVRleHR1cmUgLSBSZXNvdXJjZSBsb2FkZWQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRmlyZWQgd2hlbiBhIG5vdC1pbW1lZGlhdGVseS1hdmFpbGFibGUgc291cmNlIGZhaWxzIHRvIGxvYWQuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgICAgICogQGV2ZW50IFBJWEkuQmFzZVRleHR1cmUjZXJyb3JcclxuICAgICAgICAgKiBAcGFyYW0ge1BJWEkuQmFzZVRleHR1cmV9IGJhc2VUZXh0dXJlIC0gUmVzb3VyY2UgZXJyb3JlZC5cclxuICAgICAgICAgKi9cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBGaXJlZCB3aGVuIEJhc2VUZXh0dXJlIGlzIHVwZGF0ZWQuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgICAgICogQGV2ZW50IFBJWEkuQmFzZVRleHR1cmUjbG9hZGVkXHJcbiAgICAgICAgICogQHBhcmFtIHtQSVhJLkJhc2VUZXh0dXJlfSBiYXNlVGV4dHVyZSAtIFJlc291cmNlIGxvYWRlZC5cclxuICAgICAgICAgKi9cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBGaXJlZCB3aGVuIEJhc2VUZXh0dXJlIGlzIGRlc3Ryb3llZC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAgICAgKiBAZXZlbnQgUElYSS5CYXNlVGV4dHVyZSNlcnJvclxyXG4gICAgICAgICAqIEBwYXJhbSB7UElYSS5CYXNlVGV4dHVyZX0gYmFzZVRleHR1cmUgLSBSZXNvdXJjZSBlcnJvcmVkLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEZpcmVkIHdoZW4gQmFzZVRleHR1cmUgaXMgdXBkYXRlZC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAgICAgKiBAZXZlbnQgUElYSS5CYXNlVGV4dHVyZSN1cGRhdGVcclxuICAgICAgICAgKiBAcGFyYW0ge1BJWEkuQmFzZVRleHR1cmV9IGJhc2VUZXh0dXJlIC0gSW5zdGFuY2Ugb2YgdGV4dHVyZSBiZWluZyB1cGRhdGVkLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEZpcmVkIHdoZW4gQmFzZVRleHR1cmUgaXMgZGVzdHJveWVkLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHByb3RlY3RlZFxyXG4gICAgICAgICAqIEBldmVudCBQSVhJLkJhc2VUZXh0dXJlI2Rpc3Bvc2VcclxuICAgICAgICAgKiBAcGFyYW0ge1BJWEkuQmFzZVRleHR1cmV9IGJhc2VUZXh0dXJlIC0gSW5zdGFuY2Ugb2YgdGV4dHVyZSBiZWluZyBkZXN0cm95ZWQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgLy8gU2V0IHRoZSByZXNvdXJjZVxyXG4gICAgICAgIHRoaXMuc2V0UmVzb3VyY2UocmVzb3VyY2UpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBQaXhlbCB3aWR0aCBvZiB0aGUgc291cmNlIG9mIHRoaXMgdGV4dHVyZVxyXG4gICAgICpcclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICBnZXQgcmVhbFdpZHRoKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLndpZHRoICogdGhpcy5yZXNvbHV0aW9uO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBQaXhlbCBoZWlnaHQgb2YgdGhlIHNvdXJjZSBvZiB0aGlzIHRleHR1cmVcclxuICAgICAqXHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgZ2V0IHJlYWxIZWlnaHQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaGVpZ2h0ICogdGhpcy5yZXNvbHV0aW9uO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDaGFuZ2VzIHN0eWxlIG9wdGlvbnMgb2YgQmFzZVRleHR1cmVcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1BJWEkuU0NBTEVfTU9ERVN9IFtzY2FsZU1vZGVdIC0gUGl4aSBzY2FsZW1vZGVcclxuICAgICAqIEBwYXJhbSB7UElYSS5NSVBNQVBfTU9ERVN9IFttaXBtYXBdIC0gZW5hYmxlIG1pcG1hcHNcclxuICAgICAqIEByZXR1cm5zIHtCYXNlVGV4dHVyZX0gdGhpc1xyXG4gICAgICovXHJcbiAgICBCc2V0U3R5bGUoc2NhbGVNb2RlLCBtaXBtYXApIHtcclxuICAgICAgICB2YXIgZGlydHk7XHJcbiAgICAgICAgaWYgKHNjYWxlTW9kZSAhPT0gdW5kZWZpbmVkICYmIHNjYWxlTW9kZSAhPT0gdGhpcy5zY2FsZU1vZGUpIHtcclxuICAgICAgICAgICAgdGhpcy5zY2FsZU1vZGUgPSBzY2FsZU1vZGU7XHJcbiAgICAgICAgICAgIGRpcnR5ID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG1pcG1hcCAhPT0gdW5kZWZpbmVkICYmIG1pcG1hcCAhPT0gdGhpcy5taXBtYXApIHtcclxuICAgICAgICAgICAgdGhpcy5taXBtYXAgPSBtaXBtYXA7XHJcbiAgICAgICAgICAgIGRpcnR5ID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGRpcnR5KSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGlydHlTdHlsZUlkKys7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDaGFuZ2VzIHcvaC9yZXNvbHV0aW9uLiBUZXh0dXJlIGJlY29tZXMgdmFsaWQgaWYgd2lkdGggYW5kIGhlaWdodCBhcmUgZ3JlYXRlciB0aGFuIHplcm8uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIFZpc3VhbCB3aWR0aFxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCBWaXN1YWwgaGVpZ2h0XHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3Jlc29sdXRpb25dIE9wdGlvbmFsbHkgc2V0IHJlc29sdXRpb25cclxuICAgICAqIEByZXR1cm5zIHtCYXNlVGV4dHVyZX0gdGhpc1xyXG4gICAgICovXHJcbiAgICBzZXRTaXplKHdpZHRoLCBoZWlnaHQsIHJlc29sdXRpb24gPSBudWxsKSB7XHJcbiAgICAgICAgdGhpcy5yZXNvbHV0aW9uID0gcmVzb2x1dGlvbiB8fCB0aGlzLnJlc29sdXRpb247XHJcbiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xyXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xyXG4gICAgICAgIHRoaXMuX3JlZnJlc2hQT1QoKTtcclxuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHJlYWwgc2l6ZSBvZiBiYXNlVGV4dHVyZSwgcHJlc2VydmVzIGN1cnJlbnQgcmVzb2x1dGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcmVhbFdpZHRoIEZ1bGwgcmVuZGVyZWQgd2lkdGhcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByZWFsSGVpZ2h0IEZ1bGwgcmVuZGVyZWQgaGVpZ2h0XHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3Jlc29sdXRpb25dIE9wdGlvbmFsbHkgc2V0IHJlc29sdXRpb25cclxuICAgICAqIEByZXR1cm5zIHtCYXNlVGV4dHVyZX0gdGhpc1xyXG4gICAgICovXHJcbiAgICBzZXRSZWFsU2l6ZShyZWFsV2lkdGgsIHJlYWxIZWlnaHQsIHJlc29sdXRpb24gPSBudWxsKSB7XHJcbiAgICAgICAgdGhpcy5yZXNvbHV0aW9uID0gcmVzb2x1dGlvbiB8fCB0aGlzLnJlc29sdXRpb247XHJcbiAgICAgICAgdGhpcy53aWR0aCA9IHJlYWxXaWR0aCAvIHRoaXMucmVzb2x1dGlvbjtcclxuICAgICAgICB0aGlzLmhlaWdodCA9IHJlYWxIZWlnaHQgLyB0aGlzLnJlc29sdXRpb247XHJcbiAgICAgICAgdGhpcy5fcmVmcmVzaFBPVCgpO1xyXG4gICAgICAgIHRoaXMudXBkYXRlKCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFJlZnJlc2ggY2hlY2sgZm9yIGlzUG93ZXJPZlR3byB0ZXh0dXJlIGJhc2VkIG9uIHNpemVcclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBfcmVmcmVzaFBPVCgpIHtcclxuICAgICAgICB0aGlzLmlzUG93ZXJPZlR3byA9IE1hdGhTZXR0aW5nc18xLk1hdGhTZXR0aW5ncy5pc1BvdzIodGhpcy5yZWFsV2lkdGgpICYmIE1hdGhTZXR0aW5nc18xLk1hdGhTZXR0aW5ncy5pc1BvdzIodGhpcy5yZWFsSGVpZ2h0KTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQ2hhbmdlcyByZXNvbHV0aW9uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtyZXNvbHV0aW9uXSByZXNcclxuICAgICAqIEByZXR1cm5zIHtCYXNlVGV4dHVyZX0gdGhpc1xyXG4gICAgICovXHJcbiAgICBzZXRSZXNvbHV0aW9uKHJlc29sdXRpb24pIHtcclxuICAgICAgICB2YXIgb2xkUmVzb2x1dGlvbiA9IHRoaXMucmVzb2x1dGlvbjtcclxuICAgICAgICBpZiAob2xkUmVzb2x1dGlvbiA9PT0gcmVzb2x1dGlvbikge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5yZXNvbHV0aW9uID0gcmVzb2x1dGlvbjtcclxuICAgICAgICBpZiAodGhpcy52YWxpZCkge1xyXG4gICAgICAgICAgICB0aGlzLndpZHRoID0gdGhpcy53aWR0aCAqIG9sZFJlc29sdXRpb24gLyByZXNvbHV0aW9uO1xyXG4gICAgICAgICAgICB0aGlzLmhlaWdodCA9IHRoaXMuaGVpZ2h0ICogb2xkUmVzb2x1dGlvbiAvIHJlc29sdXRpb247XHJcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChFdmVudF8xLkV2ZW50LmdldEV2ZW50KFwidXBkYXRlXCIpKTtcclxuICAgICAgICAgICAgLy8gdGhpcy5lbWl0KCd1cGRhdGUnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fcmVmcmVzaFBPVCgpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSByZXNvdXJjZSBpZiBpdCB3YXNuJ3Qgc2V0LiBUaHJvd3MgZXJyb3IgaWYgcmVzb3VyY2UgYWxyZWFkeSBwcmVzZW50XHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtQSVhJLnJlc291cmNlcy5SZXNvdXJjZX0gcmVzb3VyY2UgLSB0aGF0IGlzIG1hbmFnaW5nIHRoaXMgQmFzZVRleHR1cmVcclxuICAgICAqIEByZXR1cm5zIHtCYXNlVGV4dHVyZX0gdGhpc1xyXG4gICAgICovXHJcbiAgICBzZXRSZXNvdXJjZShyZXNvdXJjZSkge1xyXG4gICAgICAgIGlmICh0aGlzLnJlc291cmNlID09PSByZXNvdXJjZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMucmVzb3VyY2UpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZXNvdXJjZSBjYW4gYmUgc2V0IG9ubHkgb25jZScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnJlc291cmNlID0gcmVzb3VyY2U7XHJcbiAgICAgICAgaWYgKHJlc291cmNlIGluc3RhbmNlb2YgSW1hZ2VCaXRtYXApIHtcclxuICAgICAgICAgICAgdGhpcy5zZXRSZWFsU2l6ZSh0aGlzLnJlc291cmNlLndpZHRoLCB0aGlzLnJlc291cmNlLmhlaWdodCk7XHJcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlVXBkYXRlKG51bGwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmVzb3VyY2UuYWRkRXZlbnRMaXN0ZW5lcihcInVwZGF0ZVwiLCB0aGlzLmhhbmRsZVVwZGF0ZSk7XHJcbiAgICAgICAgICAgIHJlc291cmNlLmFkZEV2ZW50TGlzdGVuZXIoXCJzZXRSZWFsU2l6ZVwiLCB0aGlzLmhhbmRsZVJlc2l6ZSk7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0UmVhbFNpemUodGhpcy5yZXNvdXJjZS53aWR0aCwgdGhpcy5yZXNvdXJjZS5oZWlnaHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyByZXNvdXJjZS5iaW5kKHRoaXMpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBJbnZhbGlkYXRlcyB0aGUgb2JqZWN0LiBUZXh0dXJlIGJlY29tZXMgdmFsaWQgaWYgd2lkdGggYW5kIGhlaWdodCBhcmUgZ3JlYXRlciB0aGFuIHplcm8uXHJcbiAgICAgKi9cclxuICAgIHVwZGF0ZSgpIHtcclxuICAgICAgICBpZiAoIXRoaXMudmFsaWQpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMud2lkdGggPiAwICYmIHRoaXMuaGVpZ2h0ID4gMCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy52YWxpZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoRXZlbnRfMS5FdmVudC5nZXRFdmVudChcImxvYWRlZFwiKSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoRXZlbnRfMS5FdmVudC5nZXRFdmVudChcInVwZGF0ZVwiKSk7XHJcbiAgICAgICAgICAgICAgICAvLyB0aGlzLmVtaXQoJ2xvYWRlZCcsIHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgLy8gdGhpcy5lbWl0KCd1cGRhdGUnLCB0aGlzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5kaXJ0eUlkKys7XHJcbiAgICAgICAgICAgIHRoaXMuZGlydHlTdHlsZUlkKys7XHJcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChFdmVudF8xLkV2ZW50LmdldEV2ZW50KFwidXBkYXRlXCIpKTtcclxuICAgICAgICAgICAgLy8gdGhpcy5lbWl0KCd1cGRhdGUnLCB0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIERlc3Ryb3lzIHRoaXMgYmFzZSB0ZXh0dXJlLlxyXG4gICAgICogVGhlIG1ldGhvZCBzdG9wcyBpZiByZXNvdXJjZSBkb2Vzbid0IHdhbnQgdGhpcyB0ZXh0dXJlIHRvIGJlIGRlc3Ryb3llZC5cclxuICAgICAqIFJlbW92ZXMgdGV4dHVyZSBmcm9tIGFsbCBjYWNoZXMuXHJcbiAgICAgKi9cclxuICAgIGRlc3Ryb3koKSB7XHJcbiAgICAgICAgLy8gcmVtb3ZlIGFuZCBkZXN0cm95IHRoZSByZXNvdXJjZVxyXG4gICAgICAgIGlmICh0aGlzLnJlc291cmNlKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVzb3VyY2UudW5iaW5kKHRoaXMpO1xyXG4gICAgICAgICAgICAvLyBvbmx5IGRlc3Ryb3kgcmVzb3VyY2VkIGNyZWF0ZWQgaW50ZXJuYWxseVxyXG4gICAgICAgICAgICBpZiAodGhpcy5yZXNvdXJjZS5pbnRlcm5hbCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZXNvdXJjZS5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5yZXNvdXJjZSA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmNhY2hlSWQpIHtcclxuICAgICAgICAgICAgZGVsZXRlIENhY2hlU2V0dGluZ3NfMS5DYWNoZVNldHRpbmdzLkJhc2VUZXh0dXJlQ2FjaGVbdGhpcy5jYWNoZUlkXTtcclxuICAgICAgICAgICAgZGVsZXRlIENhY2hlU2V0dGluZ3NfMS5DYWNoZVNldHRpbmdzLlRleHR1cmVDYWNoZVt0aGlzLmNhY2hlSWRdO1xyXG4gICAgICAgICAgICB0aGlzLmNhY2hlSWQgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBmaW5hbGx5IGxldCB0aGUgV2ViR0wgcmVuZGVyZXIga25vdy4uXHJcbiAgICAgICAgdGhpcy5kaXNwb3NlKCk7XHJcbiAgICAgICAgQmFzZVRleHR1cmUucmVtb3ZlRnJvbUNhY2hlKHRoaXMpO1xyXG4gICAgICAgIHRoaXMudGV4dHVyZUNhY2hlSWRzID0gbnVsbDtcclxuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IHRydWU7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIEZyZWVzIHRoZSB0ZXh0dXJlIGZyb20gV2ViR0wgbWVtb3J5IHdpdGhvdXQgZGVzdHJveWluZyB0aGlzIHRleHR1cmUgb2JqZWN0LlxyXG4gICAgICogVGhpcyBtZWFucyB5b3UgY2FuIHN0aWxsIHVzZSB0aGUgdGV4dHVyZSBsYXRlciB3aGljaCB3aWxsIHVwbG9hZCBpdCB0byBHUFVcclxuICAgICAqIG1lbW9yeSBhZ2Fpbi5cclxuICAgICAqXHJcbiAgICAgKiBAZmlyZXMgUElYSS5CYXNlVGV4dHVyZSNkaXNwb3NlXHJcbiAgICAgKi9cclxuICAgIGRpc3Bvc2UoKSB7XHJcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KEV2ZW50XzEuRXZlbnQuZ2V0RXZlbnQoXCJkaXNwb3NlXCIpKTtcclxuICAgICAgICAvLyB0aGlzLmVtaXQoJ2Rpc3Bvc2UnLCB0aGlzKTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogSGVscGVyIGZ1bmN0aW9uIHRoYXQgY3JlYXRlcyBhIGJhc2UgdGV4dHVyZSBiYXNlZCBvbiB0aGUgc291cmNlIHlvdSBwcm92aWRlLlxyXG4gICAgICogVGhlIHNvdXJjZSBjYW4gYmUgLSBpbWFnZSB1cmwsIGltYWdlIGVsZW1lbnQsIGNhbnZhcyBlbGVtZW50LiBJZiB0aGVcclxuICAgICAqIHNvdXJjZSBpcyBhbiBpbWFnZSB1cmwgb3IgYW4gaW1hZ2UgZWxlbWVudCBhbmQgbm90IGluIHRoZSBiYXNlIHRleHR1cmVcclxuICAgICAqIGNhY2hlLCBpdCB3aWxsIGJlIGNyZWF0ZWQgYW5kIGxvYWRlZC5cclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xIVE1MSW1hZ2VFbGVtZW50fEhUTUxDYW52YXNFbGVtZW50fFNWR0VsZW1lbnR8SFRNTFZpZGVvRWxlbWVudH0gc291cmNlIC0gVGhlXHJcbiAgICAgKiAgICAgICAgc291cmNlIHRvIGNyZWF0ZSBiYXNlIHRleHR1cmUgZnJvbS5cclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gU2VlIHtAbGluayBQSVhJLkJhc2VUZXh0dXJlfSdzIGNvbnN0cnVjdG9yIGZvciBvcHRpb25zLlxyXG4gICAgICogQHJldHVybnMge1BJWEkuQmFzZVRleHR1cmV9IFRoZSBuZXcgYmFzZSB0ZXh0dXJlLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZnJvbShzb3VyY2UsIG9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgY2FjaGVJZCA9IG51bGw7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBzb3VyY2UgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIGNhY2hlSWQgPSBzb3VyY2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoIXNvdXJjZS5fcGl4aUlkKSB7XHJcbiAgICAgICAgICAgICAgICBzb3VyY2UuX3BpeGlJZCA9IFwicGl4aWlkX1wiICsgKE1hdGhTZXR0aW5nc18xLk1hdGhTZXR0aW5ncy51aWQoKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2FjaGVJZCA9IHNvdXJjZS5fcGl4aUlkO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgYmFzZVRleHR1cmUgPSBDYWNoZVNldHRpbmdzXzEuQ2FjaGVTZXR0aW5ncy5CYXNlVGV4dHVyZUNhY2hlW2NhY2hlSWRdO1xyXG4gICAgICAgIGlmICghYmFzZVRleHR1cmUpIHtcclxuICAgICAgICAgICAgYmFzZVRleHR1cmUgPSBuZXcgQmFzZVRleHR1cmUoc291cmNlLCBvcHRpb25zKTtcclxuICAgICAgICAgICAgYmFzZVRleHR1cmUuY2FjaGVJZCA9IGNhY2hlSWQ7XHJcbiAgICAgICAgICAgIEJhc2VUZXh0dXJlLmFkZFRvQ2FjaGUoYmFzZVRleHR1cmUsIGNhY2hlSWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYmFzZVRleHR1cmU7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZSBhIG5ldyBCYXNlVGV4dHVyZSB3aXRoIGEgQnVmZmVyUmVzb3VyY2UgZnJvbSBhIEZsb2F0MzJBcnJheS5cclxuICAgICAqIFJHQkEgdmFsdWVzIGFyZSBmbG9hdHMgZnJvbSAwIHRvIDEuXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAcGFyYW0ge0Zsb2F0MzJBcnJheXxVaW50OEFycmF5fSBidWZmZXIgVGhlIG9wdGlvbmFsIGFycmF5IHRvIHVzZSwgaWYgbm8gZGF0YVxyXG4gICAgICogICAgICAgIGlzIHByb3ZpZGVkLCBhIG5ldyBGbG9hdDMyQXJyYXkgaXMgY3JlYXRlZC5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCAtIFdpZHRoIG9mIHRoZSByZXNvdXJjZVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCAtIEhlaWdodCBvZiB0aGUgcmVzb3VyY2VcclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gU2VlIHtAbGluayBQSVhJLkJhc2VUZXh0dXJlfSdzIGNvbnN0cnVjdG9yIGZvciBvcHRpb25zLlxyXG4gICAgICogQHJldHVybiB7UElYSS5CYXNlVGV4dHVyZX0gVGhlIHJlc3VsdGluZyBuZXcgQmFzZVRleHR1cmVcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGZyb21CdWZmZXIoYnVmZmVyLCB3aWR0aCwgaGVpZ2h0LCBvcHRpb25zKSB7XHJcbiAgICAgICAgYnVmZmVyID0gYnVmZmVyIHx8IG5ldyBGbG9hdDMyQXJyYXkod2lkdGggKiBoZWlnaHQgKiA0KTtcclxuICAgICAgICB2YXIgcmVzb3VyY2UgPSBuZXcgQnVmZmVyUmVzb3VyY2VfMS5CdWZmZXJSZXNvdXJjZShidWZmZXIsIHsgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodCB9KTtcclxuICAgICAgICB2YXIgdHlwZSA9IGJ1ZmZlciBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSA/IFdlYkdMU2V0dGluZ3NfMS5XZWJHTFNldHRpbmdzLlRZUEVTLkZMT0FUIDogV2ViR0xTZXR0aW5nc18xLldlYkdMU2V0dGluZ3MuVFlQRVMuVU5TSUdORURfQllURTtcclxuICAgICAgICByZXR1cm4gbmV3IEJhc2VUZXh0dXJlKHJlc291cmNlLCBPYmplY3QuYXNzaWduKFdlYkdMU2V0dGluZ3NfMS5XZWJHTFNldHRpbmdzLmRlZmF1bHRCdWZmZXJPcHRpb25zLCBvcHRpb25zIHx8IHsgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodCwgdHlwZTogdHlwZSB9KSk7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYSBCYXNlVGV4dHVyZSB0byB0aGUgZ2xvYmFsIEJhc2VUZXh0dXJlQ2FjaGUuIFRoaXMgY2FjaGUgaXMgc2hhcmVkIGFjcm9zcyB0aGUgd2hvbGUgUElYSSBvYmplY3QuXHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQHBhcmFtIHtQSVhJLkJhc2VUZXh0dXJlfSBiYXNlVGV4dHVyZSAtIFRoZSBCYXNlVGV4dHVyZSB0byBhZGQgdG8gdGhlIGNhY2hlLlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlkIC0gVGhlIGlkIHRoYXQgdGhlIEJhc2VUZXh0dXJlIHdpbGwgYmUgc3RvcmVkIGFnYWluc3QuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBhZGRUb0NhY2hlKGJhc2VUZXh0dXJlLCBpZCkge1xyXG4gICAgICAgIGlmIChpZCkge1xyXG4gICAgICAgICAgICBpZiAoYmFzZVRleHR1cmUudGV4dHVyZUNhY2hlSWRzLmluZGV4T2YoaWQpID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgYmFzZVRleHR1cmUudGV4dHVyZUNhY2hlSWRzLnB1c2goaWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChDYWNoZVNldHRpbmdzXzEuQ2FjaGVTZXR0aW5ncy5CYXNlVGV4dHVyZUNhY2hlW2lkXSkge1xyXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybigoXCJCYXNlVGV4dHVyZSBhZGRlZCB0byB0aGUgY2FjaGUgd2l0aCBhbiBpZCBbXCIgKyBpZCArIFwiXSB0aGF0IGFscmVhZHkgaGFkIGFuIGVudHJ5XCIpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBDYWNoZVNldHRpbmdzXzEuQ2FjaGVTZXR0aW5ncy5CYXNlVGV4dHVyZUNhY2hlW2lkXSA9IGJhc2VUZXh0dXJlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlIGEgQmFzZVRleHR1cmUgZnJvbSB0aGUgZ2xvYmFsIEJhc2VUZXh0dXJlQ2FjaGUuXHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQHBhcmFtIHtzdHJpbmd8UElYSS5CYXNlVGV4dHVyZX0gYmFzZVRleHR1cmUgLSBpZCBvZiBhIEJhc2VUZXh0dXJlIHRvIGJlIHJlbW92ZWQsIG9yIGEgQmFzZVRleHR1cmUgaW5zdGFuY2UgaXRzZWxmLlxyXG4gICAgICogQHJldHVybiB7UElYSS5CYXNlVGV4dHVyZXxudWxsfSBUaGUgQmFzZVRleHR1cmUgdGhhdCB3YXMgcmVtb3ZlZC5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIHJlbW92ZUZyb21DYWNoZShiYXNlVGV4dHVyZSkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgYmFzZVRleHR1cmUgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIHZhciBiYXNlVGV4dHVyZUZyb21DYWNoZSA9IENhY2hlU2V0dGluZ3NfMS5DYWNoZVNldHRpbmdzLkJhc2VUZXh0dXJlQ2FjaGVbYmFzZVRleHR1cmVdO1xyXG4gICAgICAgICAgICBpZiAoYmFzZVRleHR1cmVGcm9tQ2FjaGUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IGJhc2VUZXh0dXJlRnJvbUNhY2hlLnRleHR1cmVDYWNoZUlkcy5pbmRleE9mKGJhc2VUZXh0dXJlKTtcclxuICAgICAgICAgICAgICAgIGlmIChpbmRleCA+IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYmFzZVRleHR1cmVGcm9tQ2FjaGUudGV4dHVyZUNhY2hlSWRzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBkZWxldGUgQ2FjaGVTZXR0aW5nc18xLkNhY2hlU2V0dGluZ3MuQmFzZVRleHR1cmVDYWNoZVtiYXNlVGV4dHVyZV07XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYmFzZVRleHR1cmVGcm9tQ2FjaGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoYmFzZVRleHR1cmUgJiYgYmFzZVRleHR1cmUudGV4dHVyZUNhY2hlSWRzKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYmFzZVRleHR1cmUudGV4dHVyZUNhY2hlSWRzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICBkZWxldGUgQ2FjaGVTZXR0aW5nc18xLkNhY2hlU2V0dGluZ3MuQmFzZVRleHR1cmVDYWNoZVtiYXNlVGV4dHVyZS50ZXh0dXJlQ2FjaGVJZHNbaV1dO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJhc2VUZXh0dXJlLnRleHR1cmVDYWNoZUlkcy5sZW5ndGggPSAwO1xyXG4gICAgICAgICAgICByZXR1cm4gYmFzZVRleHR1cmU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgO1xyXG59XHJcbi8qKlxyXG4gKiBHbG9iYWwgbnVtYmVyIG9mIHRoZSB0ZXh0dXJlIGJhdGNoLCB1c2VkIGJ5IG11bHRpLXRleHR1cmUgcmVuZGVyZXJzXHJcbiAqXHJcbiAqIEBzdGF0aWNcclxuICogQG1lbWJlciB7bnVtYmVyfSBuZXcgdGV4dHVyZSBiYXRjaCBudW1iZXJcclxuICovXHJcbkJhc2VUZXh0dXJlLl9nbG9iYWxCYXRjaCA9IDA7XHJcbmV4cG9ydHMuQmFzZVRleHR1cmUgPSBCYXNlVGV4dHVyZTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY2xhc3MgQmF0Y2hCdWZmZXIge1xyXG4gICAgY29uc3RydWN0b3Ioc2l6ZSkge1xyXG4gICAgICAgIHRoaXMudmVydGljZXMgPSBuZXcgQXJyYXlCdWZmZXIoc2l6ZSk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVmlldyBvbiB0aGUgdmVydGljZXMgYXMgYSBGbG9hdDMyQXJyYXkgZm9yIHBvc2l0aW9uc1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQG1lbWJlciB7RmxvYXQzMkFycmF5fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuZmxvYXQzMlZpZXcgPSBuZXcgRmxvYXQzMkFycmF5KHRoaXMudmVydGljZXMpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFZpZXcgb24gdGhlIHZlcnRpY2VzIGFzIGEgVWludDMyQXJyYXkgZm9yIHV2c1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQG1lbWJlciB7RmxvYXQzMkFycmF5fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMudWludDMyVmlldyA9IG5ldyBVaW50MzJBcnJheSh0aGlzLnZlcnRpY2VzKTtcclxuICAgIH1cclxuICAgIGRlc3Ryb3koKSB7XHJcbiAgICAgICAgdGhpcy52ZXJ0aWNlcyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5mbG9hdDMyVmlldyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy51aW50MzJWaWV3ID0gbnVsbDtcclxuICAgIH1cclxuICAgIDtcclxufVxyXG5leHBvcnRzLkJhdGNoQnVmZmVyID0gQmF0Y2hCdWZmZXI7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNsYXNzIEJhdGNoRHJhd0NhbGwge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy50ZXh0dXJlcyA9IFtdO1xyXG4gICAgICAgIHRoaXMuaWRzID0gW107XHJcbiAgICAgICAgdGhpcy5ibGVuZCA9IDA7XHJcbiAgICAgICAgdGhpcy50ZXh0dXJlQ291bnQgPSAwO1xyXG4gICAgICAgIHRoaXMuc3RhcnQgPSAwO1xyXG4gICAgICAgIHRoaXMuc2l6ZSA9IDA7XHJcbiAgICAgICAgdGhpcy50eXBlID0gNDtcclxuICAgIH1cclxuICAgIDtcclxufVxyXG5leHBvcnRzLkJhdGNoRHJhd0NhbGwgPSBCYXRjaERyYXdDYWxsO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBHZW9tZXRyeV8xID0gcmVxdWlyZShcIi4vR2VvbWV0cnlcIik7XHJcbmNvbnN0IEJ1ZmZlcl8xID0gcmVxdWlyZShcIi4vQnVmZmVyXCIpO1xyXG5jb25zdCBXZWJHTFNldHRpbmdzXzEgPSByZXF1aXJlKFwiLi9XZWJHTFNldHRpbmdzXCIpO1xyXG5jbGFzcyBCYXRjaEdlb21ldHJ5IGV4dGVuZHMgR2VvbWV0cnlfMS5HZW9tZXRyeSB7XHJcbiAgICBjb25zdHJ1Y3Rvcihfc3RhdGljID0gZmFsc2UpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEJ1ZmZlciB1c2VkIGZvciBwb3NpdGlvbiwgY29sb3IsIHRleHR1cmUgSURzXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLkJ1ZmZlcn1cclxuICAgICAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5fYnVmZmVyID0gbmV3IEJ1ZmZlcl8xLkJ1ZmZlcihudWxsLCBfc3RhdGljLCBmYWxzZSk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSW5kZXggYnVmZmVyIGRhdGFcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuQnVmZmVyfVxyXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLl9pbmRleEJ1ZmZlciA9IG5ldyBCdWZmZXJfMS5CdWZmZXIobnVsbCwgX3N0YXRpYywgdHJ1ZSk7XHJcbiAgICAgICAgdGhpcy5hZGRBdHRyaWJ1dGUoJ2FWZXJ0ZXhQb3NpdGlvbicsIHRoaXMuX2J1ZmZlciwgMiwgZmFsc2UsIFdlYkdMU2V0dGluZ3NfMS5XZWJHTFNldHRpbmdzLlRZUEVTLkZMT0FUKVxyXG4gICAgICAgICAgICAuYWRkQXR0cmlidXRlKCdhVGV4dHVyZUNvb3JkJywgdGhpcy5fYnVmZmVyLCAyLCBmYWxzZSwgV2ViR0xTZXR0aW5nc18xLldlYkdMU2V0dGluZ3MuVFlQRVMuRkxPQVQpXHJcbiAgICAgICAgICAgIC5hZGRBdHRyaWJ1dGUoJ2FDb2xvcicsIHRoaXMuX2J1ZmZlciwgNCwgdHJ1ZSwgV2ViR0xTZXR0aW5nc18xLldlYkdMU2V0dGluZ3MuVFlQRVMuVU5TSUdORURfQllURSlcclxuICAgICAgICAgICAgLmFkZEF0dHJpYnV0ZSgnYVRleHR1cmVJZCcsIHRoaXMuX2J1ZmZlciwgMSwgdHJ1ZSwgV2ViR0xTZXR0aW5nc18xLldlYkdMU2V0dGluZ3MuVFlQRVMuRkxPQVQpXHJcbiAgICAgICAgICAgIC5hZGRJbmRleCh0aGlzLl9pbmRleEJ1ZmZlcik7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5CYXRjaEdlb21ldHJ5ID0gQmF0Y2hHZW9tZXRyeTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgT2JqZWN0UmVuZGVyZXJfMSA9IHJlcXVpcmUoXCIuL09iamVjdFJlbmRlcmVyXCIpO1xyXG5jb25zdCBCYXRjaEdlb21ldHJ5XzEgPSByZXF1aXJlKFwiLi9CYXRjaEdlb21ldHJ5XCIpO1xyXG5jb25zdCBCYXNlVGV4dHVyZV8xID0gcmVxdWlyZShcIi4vQmFzZVRleHR1cmVcIik7XHJcbmNvbnN0IEJhdGNoRHJhd0NhbGxfMSA9IHJlcXVpcmUoXCIuL0JhdGNoRHJhd0NhbGxcIik7XHJcbmNvbnN0IFN0YXRlXzEgPSByZXF1aXJlKFwiLi9TdGF0ZVwiKTtcclxuY29uc3QgQmF0Y2hCdWZmZXJfMSA9IHJlcXVpcmUoXCIuL0JhdGNoQnVmZmVyXCIpO1xyXG5jb25zdCBDb2xvclNldHRpbmdzXzEgPSByZXF1aXJlKFwiLi9Db2xvclNldHRpbmdzXCIpO1xyXG5jb25zdCBXZWJHTFNldHRpbmdzXzEgPSByZXF1aXJlKFwiLi9XZWJHTFNldHRpbmdzXCIpO1xyXG5jb25zdCBCbGVuZE1vZGVzU2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL0JsZW5kTW9kZXNTZXR0aW5nc1wiKTtcclxuY29uc3QgTWF0aFNldHRpbmdzXzEgPSByZXF1aXJlKFwiLi9NYXRoU2V0dGluZ3NcIik7XHJcbmNvbnN0IERpc3BsYXlTZXR0aW5nc18xID0gcmVxdWlyZShcIi4vRGlzcGxheVNldHRpbmdzXCIpO1xyXG5jbGFzcyBCYXRjaFJlbmRlcmVyIGV4dGVuZHMgT2JqZWN0UmVuZGVyZXJfMS5PYmplY3RSZW5kZXJlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihyZW5kZXJlcikge1xyXG4gICAgICAgIHN1cGVyKHJlbmRlcmVyKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDYWxsZWQgYmVmb3JlIHRoZSByZW5kZXJlciBzdGFydHMgcmVuZGVyaW5nLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5vblByZXJlbmRlciA9IChldmVudCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnZlcnRleENvdW50ID0gMDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIE51bWJlciBvZiB2YWx1ZXMgc2VudCBpbiB0aGUgdmVydGV4IGJ1ZmZlci5cclxuICAgICAgICAgKiBhVmVydGV4UG9zaXRpb24oMiksIGFUZXh0dXJlQ29vcmQoMSksIGFDb2xvcigxKSwgYVRleHR1cmVJZCgxKSA9IDVcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnZlcnRTaXplID0gNjtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgc2l6ZSBvZiB0aGUgdmVydGV4IGluZm9ybWF0aW9uIGluIGJ5dGVzLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMudmVydEJ5dGVTaXplID0gdGhpcy52ZXJ0U2l6ZSAqIDQ7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIG51bWJlciBvZiBpbWFnZXMgaW4gdGhlIFNwcml0ZVJlbmRlcmVyIGJlZm9yZSBpdCBmbHVzaGVzLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuc2l6ZSA9IDIwMDAgKiA0OyAvLyBzZXR0aW5ncy5TUFJJVEVfQkFUQ0hfU0laRTsgLy8gMjAwMCBpcyBhIG5pY2UgYmFsYW5jZSBiZXR3ZWVuIG1vYmlsZSAvIGRlc2t0b3BcclxuICAgICAgICB0aGlzLmN1cnJlbnRTaXplID0gMDtcclxuICAgICAgICB0aGlzLmN1cnJlbnRJbmRleFNpemUgPSAwO1xyXG4gICAgICAgIC8vIHRoZSB0b3RhbCBudW1iZXIgb2YgYnl0ZXMgaW4gb3VyIGJhdGNoXHJcbiAgICAgICAgLy8gbGV0IG51bVZlcnRzID0gdGhpcy5zaXplICogNCAqIHRoaXMudmVydEJ5dGVTaXplO1xyXG4gICAgICAgIHRoaXMuYXR0cmlidXRlQnVmZmVycyA9IHt9O1xyXG4gICAgICAgIHRoaXMuYUJ1ZmZlcnMgPSB7fTtcclxuICAgICAgICB0aGlzLmlCdWZmZXJzID0ge307XHJcbiAgICAgICAgLy8gICAgIHRoaXMuZGVmdWFsdFNwcml0ZUluZGV4QnVmZmVyID0gbmV3IEJ1ZmZlcihjcmVhdGVJbmRpY2VzRm9yUXVhZHModGhpcy5zaXplKSwgdHJ1ZSwgdHJ1ZSk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSG9sZHMgdGhlIGRlZnVhbHQgaW5kaWNlcyBvZiB0aGUgZ2VvbWV0cnkgKHF1YWRzKSB0byBkcmF3XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAbWVtYmVyIHtVaW50MTZBcnJheX1cclxuICAgICAgICAgKi9cclxuICAgICAgICAvLyBjb25zdCBpbmRpY2llcyA9IGNyZWF0ZUluZGljZXNGb3JRdWFkcyh0aGlzLnNpemUpO1xyXG4gICAgICAgIC8vICB0aGlzLmRlZmF1bHRRdWFkSW5kZXhCdWZmZXIgPSBuZXcgQnVmZmVyKGluZGljaWVzLCB0cnVlLCB0cnVlKTtcclxuICAgICAgICB0aGlzLm9ubHlTcHJpdGVzID0gZmFsc2U7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGRlZmF1bHQgc2hhZGVycyB0aGF0IGlzIHVzZWQgaWYgYSBzcHJpdGUgZG9lc24ndCBoYXZlIGEgbW9yZSBzcGVjaWZpYyBvbmUuXHJcbiAgICAgICAgICogdGhlcmUgaXMgYSBzaGFkZXIgZm9yIGVhY2ggbnVtYmVyIG9mIHRleHR1cmVzIHRoYXQgY2FuIGJlIHJlbmRlcmVkLlxyXG4gICAgICAgICAqIFRoZXNlIHNoYWRlcnMgd2lsbCBhbHNvIGJlIGdlbmVyYXRlZCBvbiB0aGUgZmx5IGFzIHJlcXVpcmVkLlxyXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuU2hhZGVyW119XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5zaGFkZXIgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuY3VycmVudEluZGV4ID0gMDtcclxuICAgICAgICB0aGlzLmdyb3VwcyA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgdGhpcy5zaXplIC8gNDsgaysrKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBzW2tdID0gbmV3IEJhdGNoRHJhd0NhbGxfMS5CYXRjaERyYXdDYWxsKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZWxlbWVudHMgPSBbXTtcclxuICAgICAgICB0aGlzLnZhb3MgPSBbXTtcclxuICAgICAgICB0aGlzLnZhb01heCA9IDI7XHJcbiAgICAgICAgdGhpcy52ZXJ0ZXhDb3VudCA9IDA7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJlci5hZGRFdmVudExpc3RlbmVyKFwicHJlcmVuZGVyXCIsIHRoaXMub25QcmVyZW5kZXIpO1xyXG4gICAgICAgIC8vIHRoaXMucmVuZGVyZXIub24oJ3ByZXJlbmRlcicsIHRoaXMub25QcmVyZW5kZXIsIHRoaXMpO1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZV8xLlN0YXRlLmZvcjJkKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdXAgdGhlIHJlbmRlcmVyIGNvbnRleHQgYW5kIG5lY2Vzc2FyeSBidWZmZXJzLlxyXG4gICAgICovXHJcbiAgICBjb250ZXh0Q2hhbmdlKCkge1xyXG4gICAgICAgIHZhciBnbCA9IHRoaXMucmVuZGVyZXIuZ2w7XHJcbiAgICAgICAgaWYgKERpc3BsYXlTZXR0aW5nc18xLkRpc3BsYXlTZXR0aW5ncy5QUkVGRVJfRU5WID09PSBEaXNwbGF5U2V0dGluZ3NfMS5EaXNwbGF5U2V0dGluZ3MuRU5WLldFQkdMX0xFR0FDWSkge1xyXG4gICAgICAgICAgICB0aGlzLk1BWF9URVhUVVJFUyA9IDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBzdGVwIDE6IGZpcnN0IGNoZWNrIG1heCB0ZXh0dXJlcyB0aGUgR1BVIGNhbiBoYW5kbGUuXHJcbiAgICAgICAgICAgIHRoaXMuTUFYX1RFWFRVUkVTID0gTWF0aC5taW4oZ2wuZ2V0UGFyYW1ldGVyKGdsLk1BWF9URVhUVVJFX0lNQUdFX1VOSVRTKSwgV2ViR0xTZXR0aW5nc18xLldlYkdMU2V0dGluZ3MuU1BSSVRFX01BWF9URVhUVVJFUyk7XHJcbiAgICAgICAgICAgIC8vIHN0ZXAgMjogY2hlY2sgdGhlIG1heGltdW0gbnVtYmVyIG9mIGlmIHN0YXRlbWVudHMgdGhlIHNoYWRlciBjYW4gaGF2ZSB0b28uLlxyXG4gICAgICAgICAgICB0aGlzLk1BWF9URVhUVVJFUyA9IFdlYkdMU2V0dGluZ3NfMS5XZWJHTFNldHRpbmdzLmNoZWNrTWF4SWZTdGF0ZW1lbnRzSW5TaGFkZXIodGhpcy5NQVhfVEVYVFVSRVMsIGdsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gZ2VuZXJhdGUgZ2VuZXJhdGVNdWx0aVRleHR1cmVQcm9ncmFtLCBtYXkgYmUgYSBiZXR0ZXIgbW92ZT9cclxuICAgICAgICB0aGlzLnNoYWRlciA9IFdlYkdMU2V0dGluZ3NfMS5XZWJHTFNldHRpbmdzLmdlbmVyYXRlTXVsdGlUZXh0dXJlU2hhZGVyKGdsLCB0aGlzLk1BWF9URVhUVVJFUyk7XHJcbiAgICAgICAgLy8gd2UgdXNlIHRoZSBzZWNvbmQgc2hhZGVyIGFzIHRoZSBmaXJzdCBvbmUgZGVwZW5kaW5nIG9uIHlvdXIgYnJvd3NlciBtYXkgb21pdCBhVGV4dHVyZUlkXHJcbiAgICAgICAgLy8gYXMgaXQgaXMgbm90IHVzZWQgYnkgdGhlIHNoYWRlciBzbyBpcyBvcHRpbWl6ZWQgb3V0LlxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy52YW9NYXg7IGkrKykge1xyXG4gICAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXHJcbiAgICAgICAgICAgIHRoaXMudmFvc1tpXSA9IG5ldyBCYXRjaEdlb21ldHJ5XzEuQmF0Y2hHZW9tZXRyeSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogUmVuZGVycyB0aGUgc3ByaXRlIG9iamVjdC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1BJWEkuU3ByaXRlfSBzcHJpdGUgLSB0aGUgc3ByaXRlIHRvIHJlbmRlciB3aGVuIHVzaW5nIHRoaXMgc3ByaXRlYmF0Y2hcclxuICAgICAqL1xyXG4gICAgcmVuZGVyKGVsZW1lbnQpIHtcclxuICAgICAgICAvLyB0cmFjZShcInJlbmRlcmluZyBlbGVtZW50OiBcIiArIGVsZW1lbnQuX3RleHR1cmUudmFsaWQpXHJcbiAgICAgICAgaWYgKCFlbGVtZW50Ll90ZXh0dXJlLnZhbGlkKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFNpemUgKyAoZWxlbWVudC52ZXJ0ZXhEYXRhLmxlbmd0aCAvIDIpID4gdGhpcy5zaXplKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZmx1c2goKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5lbGVtZW50c1t0aGlzLmN1cnJlbnRJbmRleCsrXSA9IGVsZW1lbnQ7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50U2l6ZSArPSBlbGVtZW50LnZlcnRleERhdGEubGVuZ3RoIC8gMjtcclxuICAgICAgICAvLyB0cmFjZShcImN1cnJlbnRTaXplOiBcIiArIHRoaXMuY3VycmVudFNpemUpXHJcbiAgICAgICAgdGhpcy5jdXJyZW50SW5kZXhTaXplICs9IGVsZW1lbnQuaW5kaWNlcy5sZW5ndGg7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICBnZXRJbmRleEJ1ZmZlcihzaXplKSB7XHJcbiAgICAgICAgLy8gMTIgaW5kaWNlcyBpcyBlbm91Z2ggZm9yIDIgcXVhZHNcclxuICAgICAgICB2YXIgcm91bmRlZFAyID0gTWF0aFNldHRpbmdzXzEuTWF0aFNldHRpbmdzLm5leHRQb3cyKE1hdGguY2VpbChzaXplIC8gMTIpKTtcclxuICAgICAgICB2YXIgcm91bmRlZFNpemVJbmRleCA9IE1hdGhTZXR0aW5nc18xLk1hdGhTZXR0aW5ncy5sb2cyKHJvdW5kZWRQMik7XHJcbiAgICAgICAgdmFyIHJvdW5kZWRTaXplID0gcm91bmRlZFAyICogMTI7XHJcbiAgICAgICAgaWYgKHRoaXMuaUJ1ZmZlcnMubGVuZ3RoIDw9IHJvdW5kZWRTaXplSW5kZXgpIHtcclxuICAgICAgICAgICAgdGhpcy5pQnVmZmVycy5sZW5ndGggPSByb3VuZGVkU2l6ZUluZGV4ICsgMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGJ1ZmZlciA9IHRoaXMuaUJ1ZmZlcnNbcm91bmRlZFNpemVJbmRleF07XHJcbiAgICAgICAgaWYgKCFidWZmZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5pQnVmZmVyc1tyb3VuZGVkU2l6ZUluZGV4XSA9IGJ1ZmZlciA9IG5ldyBVaW50MTZBcnJheShyb3VuZGVkU2l6ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBidWZmZXI7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICBnZXRBdHRyaWJ1dGVCdWZmZXIoc2l6ZSkge1xyXG4gICAgICAgIC8vIDggdmVydGljZXMgaXMgZW5vdWdoIGZvciAyIHF1YWRzXHJcbiAgICAgICAgdmFyIHJvdW5kZWRQMiA9IE1hdGhTZXR0aW5nc18xLk1hdGhTZXR0aW5ncy5uZXh0UG93MihNYXRoLmNlaWwoc2l6ZSAvIDgpKTtcclxuICAgICAgICB2YXIgcm91bmRlZFNpemVJbmRleCA9IE1hdGhTZXR0aW5nc18xLk1hdGhTZXR0aW5ncy5sb2cyKHJvdW5kZWRQMik7XHJcbiAgICAgICAgdmFyIHJvdW5kZWRTaXplID0gcm91bmRlZFAyICogODtcclxuICAgICAgICBpZiAodGhpcy5hQnVmZmVycy5sZW5ndGggPD0gcm91bmRlZFNpemVJbmRleCkge1xyXG4gICAgICAgICAgICB0aGlzLmlCdWZmZXJzLmxlbmd0aCA9IHJvdW5kZWRTaXplSW5kZXggKyAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgYnVmZmVyID0gdGhpcy5hQnVmZmVyc1tyb3VuZGVkU2l6ZV07XHJcbiAgICAgICAgaWYgKCFidWZmZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5hQnVmZmVyc1tyb3VuZGVkU2l6ZV0gPSBidWZmZXIgPSBuZXcgQmF0Y2hCdWZmZXJfMS5CYXRjaEJ1ZmZlcihyb3VuZGVkU2l6ZSAqIHRoaXMudmVydEJ5dGVTaXplKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGJ1ZmZlcjtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogUmVuZGVycyB0aGUgY29udGVudCBhbmQgZW1wdGllcyB0aGUgY3VycmVudCBiYXRjaC5cclxuICAgICAqXHJcbiAgICAgKi9cclxuICAgIGZsdXNoKCkge1xyXG4gICAgICAgIC8vIHRyYWNlKFwiQmF0Y2hSZW5kZXIgZmx1c2ggXCIgKyB0aGlzLmN1cnJlbnRTaXplKVxyXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRTaXplID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGdsID0gdGhpcy5yZW5kZXJlci5nbDtcclxuICAgICAgICB2YXIgTUFYX1RFWFRVUkVTID0gdGhpcy5NQVhfVEVYVFVSRVM7XHJcbiAgICAgICAgdmFyIGJ1ZmZlciA9IHRoaXMuZ2V0QXR0cmlidXRlQnVmZmVyKHRoaXMuY3VycmVudFNpemUpO1xyXG4gICAgICAgIC8vIHJldmVhbChidWZmZXIpO1xyXG4gICAgICAgIHZhciBpbmRleEJ1ZmZlciA9IHRoaXMuZ2V0SW5kZXhCdWZmZXIodGhpcy5jdXJyZW50SW5kZXhTaXplKTtcclxuICAgICAgICAvLyByZXZlYWwoaW5kZXhCdWZmZXIpO1xyXG4gICAgICAgIHZhciBlbGVtZW50cyA9IHRoaXMuZWxlbWVudHM7XHJcbiAgICAgICAgdmFyIGdyb3VwcyA9IHRoaXMuZ3JvdXBzO1xyXG4gICAgICAgIHZhciBmbG9hdDMyVmlldyA9IGJ1ZmZlci5mbG9hdDMyVmlldztcclxuICAgICAgICAvLyByZXZlYWwoZmxvYXQzMlZpZXcpO1xyXG4gICAgICAgIHZhciB1aW50MzJWaWV3ID0gYnVmZmVyLnVpbnQzMlZpZXc7XHJcbiAgICAgICAgLy8gcmV2ZWFsKHVpbnQzMlZpZXcpO1xyXG4gICAgICAgIHZhciB0b3VjaCA9IHRoaXMucmVuZGVyZXIudGV4dHVyZUdDLmNvdW50O1xyXG4gICAgICAgIHZhciBpbmRleCA9IDA7XHJcbiAgICAgICAgdmFyIGluZGV4Q291bnQgPSAwO1xyXG4gICAgICAgIHZhciBuZXh0VGV4dHVyZTtcclxuICAgICAgICB2YXIgY3VycmVudFRleHR1cmU7XHJcbiAgICAgICAgdmFyIGdyb3VwQ291bnQgPSAwO1xyXG4gICAgICAgIHZhciB0ZXh0dXJlQ291bnQgPSAwO1xyXG4gICAgICAgIHZhciBjdXJyZW50R3JvdXAgPSBncm91cHNbMF07XHJcbiAgICAgICAgLy8gcmV2ZWFsKGN1cnJlbnRHcm91cCk7XHJcbiAgICAgICAgdmFyIGJsZW5kTW9kZSA9IC0xOyAvLyBwcmVtdWx0aXBseUJsZW5kTW9kZVtlbGVtZW50c1swXS5fdGV4dHVyZS5iYXNlVGV4dHVyZS5wcmVtdWx0aXBseUFscGhhID8gMCA6IF1bZWxlbWVudHNbMF0uYmxlbmRNb2RlXTtcclxuICAgICAgICBjdXJyZW50R3JvdXAudGV4dHVyZUNvdW50ID0gMDtcclxuICAgICAgICBjdXJyZW50R3JvdXAuc3RhcnQgPSAwO1xyXG4gICAgICAgIGN1cnJlbnRHcm91cC5ibGVuZCA9IGJsZW5kTW9kZTtcclxuICAgICAgICB2YXIgVElDSyA9ICsrQmFzZVRleHR1cmVfMS5CYXNlVGV4dHVyZS5fZ2xvYmFsQmF0Y2g7XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMuY3VycmVudEluZGV4OyArK2kpIHtcclxuICAgICAgICAgICAgLy8gdXBsb2FkIHRoZSBzcHJpdGUgZWxlbWVudHMuLi5cclxuICAgICAgICAgICAgLy8gdGhleSBoYXZlIGFsbCByZWFkeSBiZWVuIGNhbGN1bGF0ZWQgc28gd2UganVzdCBuZWVkIHRvIHB1c2ggdGhlbSBpbnRvIHRoZSBidWZmZXIuXHJcbiAgICAgICAgICAgIHZhciBzcHJpdGUgPSBlbGVtZW50c1tpXTtcclxuICAgICAgICAgICAgZWxlbWVudHNbaV0gPSBudWxsO1xyXG4gICAgICAgICAgICBuZXh0VGV4dHVyZSA9IHNwcml0ZS5fdGV4dHVyZS5iYXNlVGV4dHVyZTtcclxuICAgICAgICAgICAgLy8gcmV2ZWFsKG5leHRUZXh0dXJlKTtcclxuICAgICAgICAgICAgdmFyIHNwcml0ZUJsZW5kTW9kZSA9IEJsZW5kTW9kZXNTZXR0aW5nc18xLkJsZW5kTW9kZXNTZXR0aW5ncy5wcmVtdWx0aXBseUJsZW5kTW9kZVtuZXh0VGV4dHVyZS5wcmVtdWx0aXBseUFscGhhID8gMSA6IDBdW3Nwcml0ZS5ibGVuZE1vZGVdO1xyXG4gICAgICAgICAgICBpZiAoYmxlbmRNb2RlICE9PSBzcHJpdGVCbGVuZE1vZGUpIHtcclxuICAgICAgICAgICAgICAgIGJsZW5kTW9kZSA9IHNwcml0ZUJsZW5kTW9kZTtcclxuICAgICAgICAgICAgICAgIC8vIGZvcmNlIHRoZSBiYXRjaCB0byBicmVhayFcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRUZXh0dXJlID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIHRleHR1cmVDb3VudCA9IE1BWF9URVhUVVJFUztcclxuICAgICAgICAgICAgICAgIFRJQ0srKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoY3VycmVudFRleHR1cmUgIT09IG5leHRUZXh0dXJlKSB7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50VGV4dHVyZSA9IG5leHRUZXh0dXJlO1xyXG4gICAgICAgICAgICAgICAgaWYgKG5leHRUZXh0dXJlLl9iYXRjaEVuYWJsZWQgIT09IFRJQ0spIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGV4dHVyZUNvdW50ID09PSBNQVhfVEVYVFVSRVMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgVElDSysrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlQ291bnQgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50R3JvdXAuc2l6ZSA9IGluZGV4Q291bnQgLSBjdXJyZW50R3JvdXAuc3RhcnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRHcm91cCA9IGdyb3Vwc1tncm91cENvdW50KytdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50R3JvdXAudGV4dHVyZUNvdW50ID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEdyb3VwLmJsZW5kID0gYmxlbmRNb2RlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50R3JvdXAuc3RhcnQgPSBpbmRleENvdW50O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBuZXh0VGV4dHVyZS50b3VjaGVkID0gdG91Y2g7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV4dFRleHR1cmUuX2JhdGNoRW5hYmxlZCA9IFRJQ0s7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV4dFRleHR1cmUuX2lkID0gdGV4dHVyZUNvdW50O1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRHcm91cC50ZXh0dXJlc1tjdXJyZW50R3JvdXAudGV4dHVyZUNvdW50KytdID0gbmV4dFRleHR1cmU7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gcmV2ZWFsKGN1cnJlbnRHcm91cCk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gcmV2ZWFsKG5leHRUZXh0dXJlKTtcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlQ291bnQrKztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnBhY2tHZW9tZXRyeShzcHJpdGUsIGZsb2F0MzJWaWV3LCB1aW50MzJWaWV3LCBpbmRleEJ1ZmZlciwgaW5kZXgsIGluZGV4Q291bnQpOyAvLyBhcmdiLCBuZXh0VGV4dHVyZS5faWQsIGZsb2F0MzJWaWV3LCB1aW50MzJWaWV3LCBpbmRleEJ1ZmZlciwgaW5kZXgsIGluZGV4Q291bnQpO1xyXG4gICAgICAgICAgICAvLyBIRVJFIFxyXG4gICAgICAgICAgICAvLyBwdXNoIGEgZ3JhcGhpY3MuLlxyXG4gICAgICAgICAgICBpbmRleCArPSAoc3ByaXRlLnZlcnRleERhdGEubGVuZ3RoIC8gMikgKiB0aGlzLnZlcnRTaXplO1xyXG4gICAgICAgICAgICBpbmRleENvdW50ICs9IHNwcml0ZS5pbmRpY2VzLmxlbmd0aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgQmFzZVRleHR1cmVfMS5CYXNlVGV4dHVyZS5fZ2xvYmFsQmF0Y2ggPSBUSUNLO1xyXG4gICAgICAgIGN1cnJlbnRHcm91cC5zaXplID0gaW5kZXhDb3VudCAtIGN1cnJlbnRHcm91cC5zdGFydDtcclxuICAgICAgICAvLyAgICAgICAgdGhpcy5pbmRleEJ1ZmZlci51cGRhdGUoKTtcclxuICAgICAgICBpZiAoIVdlYkdMU2V0dGluZ3NfMS5XZWJHTFNldHRpbmdzLkNBTl9VUExPQURfU0FNRV9CVUZGRVIpIHtcclxuICAgICAgICAgICAgLy8gdGhpcyBpcyBzdGlsbCBuZWVkZWQgZm9yIElPUyBwZXJmb3JtYW5jZS4uXHJcbiAgICAgICAgICAgIC8vIGl0IHJlYWxseSBkb2VzIG5vdCBsaWtlIHVwbG9hZGluZyB0byB0aGUgc2FtZSBidWZmZXIgaW4gYSBzaW5nbGUgZnJhbWUhXHJcbiAgICAgICAgICAgIGlmICh0aGlzLnZhb01heCA8PSB0aGlzLnZlcnRleENvdW50KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnZhb01heCsrO1xyXG4gICAgICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy52YW9zW3RoaXMudmVydGV4Q291bnRdID0gbmV3IEJhdGNoR2VvbWV0cnlfMS5CYXRjaEdlb21ldHJ5KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy52YW9zW3RoaXMudmVydGV4Q291bnRdLl9idWZmZXIudXBkYXRlKGJ1ZmZlci52ZXJ0aWNlcywgMCk7XHJcbiAgICAgICAgICAgIHRoaXMudmFvc1t0aGlzLnZlcnRleENvdW50XS5faW5kZXhCdWZmZXIudXBkYXRlKGluZGV4QnVmZmVyLCAwKTtcclxuICAgICAgICAgICAgLy8gICB0aGlzLnZlcnRleEJ1ZmZlcnNbdGhpcy52ZXJ0ZXhDb3VudF0udXBkYXRlKGJ1ZmZlci52ZXJ0aWNlcywgMCk7XHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuZ2VvbWV0cnkuYmluZCh0aGlzLnZhb3NbdGhpcy52ZXJ0ZXhDb3VudF0pO1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLmdlb21ldHJ5LnVwZGF0ZUJ1ZmZlcnMoKTtcclxuICAgICAgICAgICAgdGhpcy52ZXJ0ZXhDb3VudCsrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gbGV0cyB1c2UgdGhlIGZhc3RlciBvcHRpb24sIGFsd2F5cyB1c2UgYnVmZmVyIG51bWJlciAwXHJcbiAgICAgICAgICAgIHRoaXMudmFvc1t0aGlzLnZlcnRleENvdW50XS5fYnVmZmVyLnVwZGF0ZShidWZmZXIudmVydGljZXMsIDApO1xyXG4gICAgICAgICAgICB0aGlzLnZhb3NbdGhpcy52ZXJ0ZXhDb3VudF0uX2luZGV4QnVmZmVyLnVwZGF0ZShpbmRleEJ1ZmZlciwgMCk7XHJcbiAgICAgICAgICAgIC8vICAgaWYgKHRydWUpLy8gdGhpcy5zcHJpdGVPbmx5KVxyXG4gICAgICAgICAgICAvLyB7XHJcbiAgICAgICAgICAgIC8vIHRoaXMudmFvc1t0aGlzLnZlcnRleENvdW50XS5pbmRleEJ1ZmZlciA9IHRoaXMuZGVmdWFsdFNwcml0ZUluZGV4QnVmZmVyO1xyXG4gICAgICAgICAgICAvLyB0aGlzLnZhb3NbdGhpcy52ZXJ0ZXhDb3VudF0uYnVmZmVyc1sxXSA9IHRoaXMuZGVmdWFsdFNwcml0ZUluZGV4QnVmZmVyO1xyXG4gICAgICAgICAgICAvLyB9XHJcbiAgICAgICAgICAgIC8vIHRoaXMudmFvc1swXS5hdHRyaWJ1dGVzLmFDb2xvci5zdHJpZGUgPSAyNFxyXG4gICAgICAgICAgICAvLyB0aGlzLnZhb3NbMF0uYXR0cmlidXRlcy5hQ29sb3Iuc3RhcnQgPSAxNlxyXG4gICAgICAgICAgICAvLyBOT1QgU0VUXHJcbiAgICAgICAgICAgIC8vIHRoaXMudmFvc1swXS5hdHRyaWJ1dGVzLmFUZXh0dXJlQ29vcmQuc3RyaWRlID0gMjRcclxuICAgICAgICAgICAgLy8gdGhpcy52YW9zWzBdLmF0dHJpYnV0ZXMuYVRleHR1cmVDb29yZC5zdGFydCA9IDhcclxuICAgICAgICAgICAgLy8gTk9UIFNFVFxyXG4gICAgICAgICAgICAvLyB0aGlzLnZhb3NbMF0uYXR0cmlidXRlcy5hVmVydGV4UG9zaXRpb24uc3RyaWRlID0gMjRcclxuICAgICAgICAgICAgLy8gTk9UIFNFVFxyXG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLmdlb21ldHJ5LnVwZGF0ZUJ1ZmZlcnMoKTtcclxuICAgICAgICAgICAgLy8gICAgXHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vICAgdGhpcy5yZW5kZXJlci5zdGF0ZS5zZXQodGhpcy5zdGF0ZSk7XHJcbiAgICAgICAgdmFyIHRleHR1cmVTeXN0ZW0gPSB0aGlzLnJlbmRlcmVyLnRleHR1cmU7XHJcbiAgICAgICAgdmFyIHN0YXRlU3lzdGVtID0gdGhpcy5yZW5kZXJlci5zdGF0ZTtcclxuICAgICAgICAvLyBlLmxvZyhncm91cENvdW50KTtcclxuICAgICAgICAvLyAvIHJlbmRlciB0aGUgZ3JvdXBzLi5cclxuICAgICAgICAvLyAgICB0cmFjZShcImdyb3VwY291bnQ6IFwiICsgZ3JvdXBDb3VudClcclxuICAgICAgICAvLyB0cmFjZShcIkJhdGNoUmVuZGVyZXIgY291bnQ6IFwiICsgZ3JvdXBDb3VudClcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZ3JvdXBDb3VudDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBncm91cCA9IGdyb3Vwc1tpXTtcclxuICAgICAgICAgICAgdmFyIGdyb3VwVGV4dHVyZUNvdW50ID0gZ3JvdXAudGV4dHVyZUNvdW50O1xyXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGdyb3VwVGV4dHVyZUNvdW50OyBqKyspIHtcclxuICAgICAgICAgICAgICAgIC8vIHRyYWNlKFwicG9zc2libGUgdGV4dHVyZVN5c3RlbSBiaW5kIGNhbGwgKEJhdGhSZW5kZXJlcilcIilcclxuICAgICAgICAgICAgICAgIC8vIHRyYWNlKFwiYmluZGluZzogXCIgKyBncm91cC50ZXh0dXJlc1tqXSArIFwiIHRvIFwiICsgailcclxuICAgICAgICAgICAgICAgIHRleHR1cmVTeXN0ZW0uYmluZChncm91cC50ZXh0dXJlc1tqXSwgaik7XHJcbiAgICAgICAgICAgICAgICBncm91cC50ZXh0dXJlc1tqXSA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gdGhpcy5zdGF0ZS5ibGVuZE1vZGUgPSBncm91cC5ibGVuZDtcclxuICAgICAgICAgICAgLy8gdGhpcy5zdGF0ZS5ibGVuZCA9IHRydWU7XHJcbiAgICAgICAgICAgIC8vIHRoaXMucmVuZGVyZXIuc3RhdGUuc2V0U3RhdGUodGhpcy5zdGF0ZSk7XHJcbiAgICAgICAgICAgIC8vIHNldCB0aGUgYmxlbmQgbW9kZS4uXHJcbiAgICAgICAgICAgIHN0YXRlU3lzdGVtLnNldEJsZW5kTW9kZShncm91cC5ibGVuZCk7XHJcbiAgICAgICAgICAgIGdsLmRyYXdFbGVtZW50cyhncm91cC50eXBlLCBncm91cC5zaXplLCBnbC5VTlNJR05FRF9TSE9SVCwgZ3JvdXAuc3RhcnQgKiAyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gcmVzZXQgZWxlbWVudHMgZm9yIHRoZSBuZXh0IGZsdXNoXHJcbiAgICAgICAgdGhpcy5jdXJyZW50SW5kZXggPSAwO1xyXG4gICAgICAgIHRoaXMuY3VycmVudFNpemUgPSAwO1xyXG4gICAgICAgIHRoaXMuY3VycmVudEluZGV4U2l6ZSA9IDA7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICBwYWNrR2VvbWV0cnkoZWxlbWVudCwgZmxvYXQzMlZpZXcsIHVpbnQzMlZpZXcsIGluZGV4QnVmZmVyLCBpbmRleCwgaW5kZXhDb3VudCkge1xyXG4gICAgICAgIHZhciBwID0gaW5kZXggLyB0aGlzLnZlcnRTaXplOyAvLyBmbG9hdDMyVmlldy5sZW5ndGggLyA2IC8gMjtcclxuICAgICAgICB2YXIgdXZzID0gZWxlbWVudC51dnM7XHJcbiAgICAgICAgdmFyIGluZGljaWVzID0gZWxlbWVudC5pbmRpY2VzOyAvLyBnZW9tZXRyeS5nZXRJbmRleCgpLmRhdGE7Ly8gaW5kaWNpZXM7XHJcbiAgICAgICAgdmFyIHZlcnRleERhdGEgPSBlbGVtZW50LnZlcnRleERhdGE7XHJcbiAgICAgICAgdmFyIHRleHR1cmVJZCA9IGVsZW1lbnQuX3RleHR1cmUuYmFzZVRleHR1cmUuX2lkO1xyXG4gICAgICAgIHZhciBhbHBoYSA9IE1hdGgubWluKGVsZW1lbnQud29ybGRBbHBoYSwgMS4wKTtcclxuICAgICAgICB2YXIgYXJnYiA9IGFscGhhIDwgMS4wICYmIGVsZW1lbnQuX3RleHR1cmUuYmFzZVRleHR1cmUucHJlbXVsdGlwbHlBbHBoYSA/IENvbG9yU2V0dGluZ3NfMS5Db2xvclNldHRpbmdzLnByZW11bHRpcGx5VGludChlbGVtZW50Ll90aW50UkdCLCBhbHBoYSlcclxuICAgICAgICAgICAgOiBlbGVtZW50Ll90aW50UkdCICsgKGFscGhhICogMjU1IDw8IDI0KTtcclxuICAgICAgICAvLyBsZXRzIG5vdCB3b3JyeSBhYm91dCB0aW50ISBmb3Igbm93Li5cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZlcnRleERhdGEubGVuZ3RoOyBpICs9IDIpIHtcclxuICAgICAgICAgICAgZmxvYXQzMlZpZXdbaW5kZXgrK10gPSB2ZXJ0ZXhEYXRhW2ldO1xyXG4gICAgICAgICAgICBmbG9hdDMyVmlld1tpbmRleCsrXSA9IHZlcnRleERhdGFbaSArIDFdO1xyXG4gICAgICAgICAgICBmbG9hdDMyVmlld1tpbmRleCsrXSA9IHV2c1tpXTtcclxuICAgICAgICAgICAgZmxvYXQzMlZpZXdbaW5kZXgrK10gPSB1dnNbaSArIDFdO1xyXG4gICAgICAgICAgICB1aW50MzJWaWV3W2luZGV4KytdID0gYXJnYjtcclxuICAgICAgICAgICAgZmxvYXQzMlZpZXdbaW5kZXgrK10gPSB0ZXh0dXJlSWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGluZGljaWVzLmxlbmd0aDsgaSQxKyspIHtcclxuICAgICAgICAgICAgaW5kZXhCdWZmZXJbaW5kZXhDb3VudCsrXSA9IHAgKyBpbmRpY2llc1tpJDFdO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogU3RhcnRzIGEgbmV3IHNwcml0ZSBiYXRjaC5cclxuICAgICAqL1xyXG4gICAgc3RhcnQoKSB7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJlci5zdGF0ZS5zZXRTdGF0ZSh0aGlzLnN0YXRlKTtcclxuICAgICAgICB0aGlzLnJlbmRlcmVyLnNoYWRlci5iaW5kKHRoaXMuc2hhZGVyKTtcclxuICAgICAgICBpZiAoV2ViR0xTZXR0aW5nc18xLldlYkdMU2V0dGluZ3MuQ0FOX1VQTE9BRF9TQU1FX0JVRkZFUikge1xyXG4gICAgICAgICAgICAvLyBiaW5kIGJ1ZmZlciAjMCwgd2UgZG9uJ3QgbmVlZCBvdGhlcnNcclxuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5nZW9tZXRyeS5iaW5kKHRoaXMudmFvc1t0aGlzLnZlcnRleENvdW50XSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBTdG9wcyBhbmQgZmx1c2hlcyB0aGUgY3VycmVudCBiYXRjaC5cclxuICAgICAqXHJcbiAgICAgKi9cclxuICAgIHN0b3AoKSB7XHJcbiAgICAgICAgdGhpcy5mbHVzaCgpO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBEZXN0cm95cyB0aGUgU3ByaXRlUmVuZGVyZXIuXHJcbiAgICAgKlxyXG4gICAgICovXHJcbiAgICBkZXN0cm95KCkge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy52YW9NYXg7IGkrKykge1xyXG4gICAgICAgICAgICAvLyBpZiAodGhpcy52ZXJ0ZXhCdWZmZXJzW2ldKVxyXG4gICAgICAgICAgICAvLyB7XHJcbiAgICAgICAgICAgIC8vICAgICB0aGlzLnZlcnRleEJ1ZmZlcnNbaV0uZGVzdHJveSgpO1xyXG4gICAgICAgICAgICAvLyB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnZhb3NbaV0pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudmFvc1tpXS5kZXN0cm95KG51bGwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmluZGV4QnVmZmVyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaW5kZXhCdWZmZXIuZGVzdHJveSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnJlbmRlcmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3ByZXJlbmRlcicsIHRoaXMub25QcmVyZW5kZXIpO1xyXG4gICAgICAgIGlmICh0aGlzLnNoYWRlcikge1xyXG4gICAgICAgICAgICB0aGlzLnNoYWRlci5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgIHRoaXMuc2hhZGVyID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gdGhpcy52ZXJ0ZXhCdWZmZXJzID0gbnVsbDtcclxuICAgICAgICB0aGlzLnZhb3MgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuaW5kZXhCdWZmZXIgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuaW5kaWNlcyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5zcHJpdGVzID0gbnVsbDtcclxuICAgICAgICAvLyBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuYnVmZmVycy5sZW5ndGg7ICsraSlcclxuICAgICAgICAvLyB7XHJcbiAgICAgICAgLy8gICAgIHRoaXMuYnVmZmVyc1tpXS5kZXN0cm95KCk7XHJcbiAgICAgICAgLy8gfVxyXG4gICAgICAgIHN1cGVyLmRlc3Ryb3koKTtcclxuICAgIH1cclxuICAgIDtcclxufVxyXG5leHBvcnRzLkJhdGNoUmVuZGVyZXIgPSBCYXRjaFJlbmRlcmVyO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBTeXN0ZW1fMSA9IHJlcXVpcmUoXCIuL1N5c3RlbVwiKTtcclxuY29uc3QgT2JqZWN0UmVuZGVyZXJfMSA9IHJlcXVpcmUoXCIuL09iamVjdFJlbmRlcmVyXCIpO1xyXG5jbGFzcyBCYXRjaFN5c3RlbSBleHRlbmRzIFN5c3RlbV8xLlN5c3RlbSB7XHJcbiAgICBjb25zdHJ1Y3RvcihyZW5kZXJlcikge1xyXG4gICAgICAgIHN1cGVyKHJlbmRlcmVyKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBbiBlbXB0eSByZW5kZXJlci5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuT2JqZWN0UmVuZGVyZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5lbXB0eVJlbmRlcmVyID0gbmV3IE9iamVjdFJlbmRlcmVyXzEuT2JqZWN0UmVuZGVyZXIocmVuZGVyZXIpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBjdXJyZW50bHkgYWN0aXZlIE9iamVjdFJlbmRlcmVyLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQG1lbWJlciB7UElYSS5PYmplY3RSZW5kZXJlcn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmN1cnJlbnRSZW5kZXJlciA9IHRoaXMuZW1wdHlSZW5kZXJlcjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2hhbmdlcyB0aGUgY3VycmVudCByZW5kZXJlciB0byB0aGUgb25lIGdpdmVuIGluIHBhcmFtZXRlclxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7UElYSS5PYmplY3RSZW5kZXJlcn0gb2JqZWN0UmVuZGVyZXIgLSBUaGUgb2JqZWN0IHJlbmRlcmVyIHRvIHVzZS5cclxuICAgICAqL1xyXG4gICAgc2V0T2JqZWN0UmVuZGVyZXIob2JqZWN0UmVuZGVyZXIpIHtcclxuICAgICAgICBpZiAodGhpcy5jdXJyZW50UmVuZGVyZXIgPT09IG9iamVjdFJlbmRlcmVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jdXJyZW50UmVuZGVyZXIuc3RvcCgpO1xyXG4gICAgICAgIHRoaXMuY3VycmVudFJlbmRlcmVyID0gb2JqZWN0UmVuZGVyZXI7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50UmVuZGVyZXIuc3RhcnQoKTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBzaG91bGQgYmUgY2FsbGVkIGlmIHlvdSB3aXNoIHRvIGRvIHNvbWUgY3VzdG9tIHJlbmRlcmluZ1xyXG4gICAgICogSXQgd2lsbCBiYXNpY2FsbHkgcmVuZGVyIGFueXRoaW5nIHRoYXQgbWF5IGJlIGJhdGNoZWQgdXAgc3VjaCBhcyBzcHJpdGVzXHJcbiAgICAgKi9cclxuICAgIGZsdXNoKCkge1xyXG4gICAgICAgIHRoaXMuc2V0T2JqZWN0UmVuZGVyZXIodGhpcy5lbXB0eVJlbmRlcmVyKTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogUmVzZXQgdGhlIHN5c3RlbSB0byBhbiBlbXB0eSByZW5kZXJlclxyXG4gICAgICovXHJcbiAgICByZXNldCgpIHtcclxuICAgICAgICB0aGlzLnNldE9iamVjdFJlbmRlcmVyKHRoaXMuZW1wdHlSZW5kZXJlcik7XHJcbiAgICB9XHJcbiAgICA7XHJcbn1cclxuZXhwb3J0cy5CYXRjaFN5c3RlbSA9IEJhdGNoU3lzdGVtO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBzZXR0aW5nc18xID0gcmVxdWlyZShcIi4vc2V0dGluZ3NcIik7XHJcbmNsYXNzIEJlemllclV0aWxzIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGN1cnZlTGVuZ3RoKGZyb21YLCBmcm9tWSwgY3BYLCBjcFksIGNwWDIsIGNwWTIsIHRvWCwgdG9ZKSB7XHJcbiAgICAgICAgdmFyIG4gPSAxMDtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gMC4wO1xyXG4gICAgICAgIHZhciB0ID0gMC4wO1xyXG4gICAgICAgIHZhciB0MiA9IDAuMDtcclxuICAgICAgICB2YXIgdDMgPSAwLjA7XHJcbiAgICAgICAgdmFyIG50ID0gMC4wO1xyXG4gICAgICAgIHZhciBudDIgPSAwLjA7XHJcbiAgICAgICAgdmFyIG50MyA9IDAuMDtcclxuICAgICAgICB2YXIgeCA9IDAuMDtcclxuICAgICAgICB2YXIgeSA9IDAuMDtcclxuICAgICAgICB2YXIgZHggPSAwLjA7XHJcbiAgICAgICAgdmFyIGR5ID0gMC4wO1xyXG4gICAgICAgIHZhciBwcmV2WCA9IGZyb21YO1xyXG4gICAgICAgIHZhciBwcmV2WSA9IGZyb21ZO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDw9IG47ICsraSkge1xyXG4gICAgICAgICAgICB0ID0gaSAvIG47XHJcbiAgICAgICAgICAgIHQyID0gdCAqIHQ7XHJcbiAgICAgICAgICAgIHQzID0gdDIgKiB0O1xyXG4gICAgICAgICAgICBudCA9ICgxLjAgLSB0KTtcclxuICAgICAgICAgICAgbnQyID0gbnQgKiBudDtcclxuICAgICAgICAgICAgbnQzID0gbnQyICogbnQ7XHJcbiAgICAgICAgICAgIHggPSAobnQzICogZnJvbVgpICsgKDMuMCAqIG50MiAqIHQgKiBjcFgpICsgKDMuMCAqIG50ICogdDIgKiBjcFgyKSArICh0MyAqIHRvWCk7XHJcbiAgICAgICAgICAgIHkgPSAobnQzICogZnJvbVkpICsgKDMuMCAqIG50MiAqIHQgKiBjcFkpICsgKDMgKiBudCAqIHQyICogY3BZMikgKyAodDMgKiB0b1kpO1xyXG4gICAgICAgICAgICBkeCA9IHByZXZYIC0geDtcclxuICAgICAgICAgICAgZHkgPSBwcmV2WSAtIHk7XHJcbiAgICAgICAgICAgIHByZXZYID0geDtcclxuICAgICAgICAgICAgcHJldlkgPSB5O1xyXG4gICAgICAgICAgICByZXN1bHQgKz0gTWF0aC5zcXJ0KChkeCAqIGR4KSArIChkeSAqIGR5KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIENhbGN1bGF0ZSB0aGUgcG9pbnRzIGZvciBhIGJlemllciBjdXJ2ZSBhbmQgdGhlbiBkcmF3cyBpdC5cclxuICAgICAqXHJcbiAgICAgKiBJZ25vcmVkIGZyb20gZG9jcyBzaW5jZSBpdCBpcyBub3QgZGlyZWN0bHkgZXhwb3NlZC5cclxuICAgICAqXHJcbiAgICAgKiBAaWdub3JlXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY3BYIC0gQ29udHJvbCBwb2ludCB4XHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY3BZIC0gQ29udHJvbCBwb2ludCB5XHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY3BYMiAtIFNlY29uZCBDb250cm9sIHBvaW50IHhcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjcFkyIC0gU2Vjb25kIENvbnRyb2wgcG9pbnQgeVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRvWCAtIERlc3RpbmF0aW9uIHBvaW50IHhcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0b1kgLSBEZXN0aW5hdGlvbiBwb2ludCB5XHJcbiAgICAgKiBAcGFyYW0ge251bWJlcltdfSBwb2ludHMgLSBQYXRoIGFycmF5IHRvIHB1c2ggcG9pbnRzIGludG9cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGN1cnZlVG8oY3BYLCBjcFksIGNwWDIsIGNwWTIsIHRvWCwgdG9ZLCBwb2ludHMpIHtcclxuICAgICAgICB2YXIgZnJvbVggPSBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDJdO1xyXG4gICAgICAgIHZhciBmcm9tWSA9IHBvaW50c1twb2ludHMubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgcG9pbnRzLmxlbmd0aCAtPSAyO1xyXG4gICAgICAgIHZhciBuID0gc2V0dGluZ3NfMS5zZXR0aW5ncy5HUkFQSElDU19DVVJWRVMuX3NlZ21lbnRzQ291bnQoQmV6aWVyVXRpbHMuY3VydmVMZW5ndGgoZnJvbVgsIGZyb21ZLCBjcFgsIGNwWSwgY3BYMiwgY3BZMiwgdG9YLCB0b1kpKTtcclxuICAgICAgICB2YXIgZHQgPSAwO1xyXG4gICAgICAgIHZhciBkdDIgPSAwO1xyXG4gICAgICAgIHZhciBkdDMgPSAwO1xyXG4gICAgICAgIHZhciB0MiA9IDA7XHJcbiAgICAgICAgdmFyIHQzID0gMDtcclxuICAgICAgICBwb2ludHMucHVzaChmcm9tWCwgZnJvbVkpO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAxLCBqID0gMDsgaSA8PSBuOyArK2kpIHtcclxuICAgICAgICAgICAgaiA9IGkgLyBuO1xyXG4gICAgICAgICAgICBkdCA9ICgxIC0gaik7XHJcbiAgICAgICAgICAgIGR0MiA9IGR0ICogZHQ7XHJcbiAgICAgICAgICAgIGR0MyA9IGR0MiAqIGR0O1xyXG4gICAgICAgICAgICB0MiA9IGogKiBqO1xyXG4gICAgICAgICAgICB0MyA9IHQyICogajtcclxuICAgICAgICAgICAgcG9pbnRzLnB1c2goKGR0MyAqIGZyb21YKSArICgzICogZHQyICogaiAqIGNwWCkgKyAoMyAqIGR0ICogdDIgKiBjcFgyKSArICh0MyAqIHRvWCksIChkdDMgKiBmcm9tWSkgKyAoMyAqIGR0MiAqIGogKiBjcFkpICsgKDMgKiBkdCAqIHQyICogY3BZMikgKyAodDMgKiB0b1kpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICA7XHJcbn1cclxuZXhwb3J0cy5CZXppZXJVdGlscyA9IEJlemllclV0aWxzO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jbGFzcyBCbGVuZE1vZGVzU2V0dGluZ3Mge1xyXG4gICAgLyoqXHJcbiogQ29ycmVjdHMgUGl4aUpTIGJsZW5kLCB0YWtlcyBwcmVtdWx0aXBsaWVkIGFscGhhIGludG8gYWNjb3VudFxyXG4qXHJcbiogQG1lbWJlcm9mIFBJWEkudXRpbHNcclxuKiBAZnVuY3Rpb24gbWFwUHJlbXVsdGlwbGllZEJsZW5kTW9kZXNcclxuKiBAcHJpdmF0ZVxyXG4qIEBwYXJhbSB7QXJyYXk8bnVtYmVyW10+fSBbYXJyYXldIC0gVGhlIGFycmF5IHRvIG91dHB1dCBpbnRvLlxyXG4qIEByZXR1cm4ge0FycmF5PG51bWJlcltdPn0gTWFwcGVkIG1vZGVzLlxyXG4qL1xyXG4gICAgc3RhdGljIG1hcFByZW11bHRpcGxpZWRCbGVuZE1vZGVzKCkge1xyXG4gICAgICAgIHZhciBwbSA9IFtdO1xyXG4gICAgICAgIHZhciBucG0gPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDMyOyBpKyspIHtcclxuICAgICAgICAgICAgcG1baV0gPSBpO1xyXG4gICAgICAgICAgICBucG1baV0gPSBpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwbVtCbGVuZE1vZGVzU2V0dGluZ3MuQkxFTkRfTU9ERVMuTk9STUFMX05QTV0gPSBCbGVuZE1vZGVzU2V0dGluZ3MuQkxFTkRfTU9ERVMuTk9STUFMO1xyXG4gICAgICAgIHBtW0JsZW5kTW9kZXNTZXR0aW5ncy5CTEVORF9NT0RFUy5BRERfTlBNXSA9IEJsZW5kTW9kZXNTZXR0aW5ncy5CTEVORF9NT0RFUy5BREQ7XHJcbiAgICAgICAgcG1bQmxlbmRNb2Rlc1NldHRpbmdzLkJMRU5EX01PREVTLlNDUkVFTl9OUE1dID0gQmxlbmRNb2Rlc1NldHRpbmdzLkJMRU5EX01PREVTLlNDUkVFTjtcclxuICAgICAgICBucG1bQmxlbmRNb2Rlc1NldHRpbmdzLkJMRU5EX01PREVTLk5PUk1BTF0gPSBCbGVuZE1vZGVzU2V0dGluZ3MuQkxFTkRfTU9ERVMuTk9STUFMX05QTTtcclxuICAgICAgICBucG1bQmxlbmRNb2Rlc1NldHRpbmdzLkJMRU5EX01PREVTLkFERF0gPSBCbGVuZE1vZGVzU2V0dGluZ3MuQkxFTkRfTU9ERVMuQUREX05QTTtcclxuICAgICAgICBucG1bQmxlbmRNb2Rlc1NldHRpbmdzLkJMRU5EX01PREVTLlNDUkVFTl0gPSBCbGVuZE1vZGVzU2V0dGluZ3MuQkxFTkRfTU9ERVMuU0NSRUVOX05QTTtcclxuICAgICAgICB2YXIgYXJyYXkgPSBbXTtcclxuICAgICAgICBhcnJheS5wdXNoKG5wbSk7XHJcbiAgICAgICAgYXJyYXkucHVzaChwbSk7XHJcbiAgICAgICAgcmV0dXJuIGFycmF5O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiogY2hhbmdlcyBibGVuZE1vZGUgYWNjb3JkaW5nIHRvIHRleHR1cmUgZm9ybWF0XHJcbipcclxuKiBAbWVtYmVyb2YgUElYSS51dGlsc1xyXG4qIEBmdW5jdGlvbiBjb3JyZWN0QmxlbmRNb2RlXHJcbiogQHBhcmFtIHtudW1iZXJ9IGJsZW5kTW9kZSBzdXBwb3NlZCBibGVuZCBtb2RlXHJcbiogQHBhcmFtIHtib29sZWFufSBwcmVtdWx0aXBsaWVkICB3aGV0aGVyIHNvdXJjZSBpcyBwcmVtdWx0aXBsaWVkXHJcbiogQHJldHVybnMge251bWJlcn0gdHJ1ZSBibGVuZCBtb2RlIGZvciB0aGlzIHRleHR1cmVcclxuKi9cclxuICAgIHN0YXRpYyBjb3JyZWN0QmxlbmRNb2RlKGJsZW5kTW9kZSwgcHJlbXVsdGlwbGllZCkge1xyXG4gICAgICAgIHJldHVybiBCbGVuZE1vZGVzU2V0dGluZ3MucHJlbXVsdGlwbHlCbGVuZE1vZGVbcHJlbXVsdGlwbGllZCA/IDEgOiAwXVtibGVuZE1vZGVdO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiogTWFwcyBnbCBibGVuZCBjb21iaW5hdGlvbnMgdG8gV2ViR0wuXHJcbipcclxuKiBAbWVtYmVyb2YgUElYSVxyXG4qIEBmdW5jdGlvbiBtYXBXZWJHTEJsZW5kTW9kZXNUb1BpeGlcclxuKiBAcHJpdmF0ZVxyXG4qIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCAtIFRoZSByZW5kZXJpbmcgY29udGV4dC5cclxuKiBAcGFyYW0ge251bWJlcltdW119IFthcnJheT1bXV0gLSBUaGUgYXJyYXkgdG8gb3V0cHV0IGludG8uXHJcbiogQHJldHVybiB7bnVtYmVyW11bXX0gTWFwcGVkIG1vZGVzLlxyXG4qL1xyXG4gICAgc3RhdGljIG1hcFdlYkdMQmxlbmRNb2Rlc1RvUGl4aShnbCwgYXJyYXkgPSBbXSkge1xyXG4gICAgICAgIC8vIFRPRE8gLSBwcmVtdWx0aXBseSBhbHBoYSB3b3VsZCBiZSBkaWZmZXJlbnQuXHJcbiAgICAgICAgLy8gYWRkIGEgYm9vbGVhbiBmb3IgdGhhdCFcclxuICAgICAgICBhcnJheVtCbGVuZE1vZGVzU2V0dGluZ3MuQkxFTkRfTU9ERVMuTk9STUFMXSA9IFtnbC5PTkUsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEFdO1xyXG4gICAgICAgIGFycmF5W0JsZW5kTW9kZXNTZXR0aW5ncy5CTEVORF9NT0RFUy5BRERdID0gW2dsLk9ORSwgZ2wuRFNUX0FMUEhBLCBnbC5PTkUsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEFdO1xyXG4gICAgICAgIGFycmF5W0JsZW5kTW9kZXNTZXR0aW5ncy5CTEVORF9NT0RFUy5NVUxUSVBMWV0gPSBbZ2wuRFNUX0NPTE9SLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBLCBnbC5PTkUsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEFdO1xyXG4gICAgICAgIGFycmF5W0JsZW5kTW9kZXNTZXR0aW5ncy5CTEVORF9NT0RFUy5TQ1JFRU5dID0gW2dsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19DT0xPUiwgZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBXTtcclxuICAgICAgICBhcnJheVtCbGVuZE1vZGVzU2V0dGluZ3MuQkxFTkRfTU9ERVMuT1ZFUkxBWV0gPSBbZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBXTtcclxuICAgICAgICBhcnJheVtCbGVuZE1vZGVzU2V0dGluZ3MuQkxFTkRfTU9ERVMuREFSS0VOXSA9IFtnbC5PTkUsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEFdO1xyXG4gICAgICAgIGFycmF5W0JsZW5kTW9kZXNTZXR0aW5ncy5CTEVORF9NT0RFUy5MSUdIVEVOXSA9IFtnbC5PTkUsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEFdO1xyXG4gICAgICAgIGFycmF5W0JsZW5kTW9kZXNTZXR0aW5ncy5CTEVORF9NT0RFUy5DT0xPUl9ET0RHRV0gPSBbZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBXTtcclxuICAgICAgICBhcnJheVtCbGVuZE1vZGVzU2V0dGluZ3MuQkxFTkRfTU9ERVMuQ09MT1JfQlVSTl0gPSBbZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBXTtcclxuICAgICAgICBhcnJheVtCbGVuZE1vZGVzU2V0dGluZ3MuQkxFTkRfTU9ERVMuSEFSRF9MSUdIVF0gPSBbZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBXTtcclxuICAgICAgICBhcnJheVtCbGVuZE1vZGVzU2V0dGluZ3MuQkxFTkRfTU9ERVMuU09GVF9MSUdIVF0gPSBbZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBXTtcclxuICAgICAgICBhcnJheVtCbGVuZE1vZGVzU2V0dGluZ3MuQkxFTkRfTU9ERVMuRElGRkVSRU5DRV0gPSBbZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBXTtcclxuICAgICAgICBhcnJheVtCbGVuZE1vZGVzU2V0dGluZ3MuQkxFTkRfTU9ERVMuRVhDTFVTSU9OXSA9IFtnbC5PTkUsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEFdO1xyXG4gICAgICAgIGFycmF5W0JsZW5kTW9kZXNTZXR0aW5ncy5CTEVORF9NT0RFUy5IVUVdID0gW2dsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQV07XHJcbiAgICAgICAgYXJyYXlbQmxlbmRNb2Rlc1NldHRpbmdzLkJMRU5EX01PREVTLlNBVFVSQVRJT05dID0gW2dsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQV07XHJcbiAgICAgICAgYXJyYXlbQmxlbmRNb2Rlc1NldHRpbmdzLkJMRU5EX01PREVTLkNPTE9SXSA9IFtnbC5PTkUsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEFdO1xyXG4gICAgICAgIGFycmF5W0JsZW5kTW9kZXNTZXR0aW5ncy5CTEVORF9NT0RFUy5MVU1JTk9TSVRZXSA9IFtnbC5PTkUsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEFdO1xyXG4gICAgICAgIGFycmF5W0JsZW5kTW9kZXNTZXR0aW5ncy5CTEVORF9NT0RFUy5OT05FXSA9IFswLCAwXTtcclxuICAgICAgICAvLyBub3QtcHJlbXVsdGlwbGllZCBibGVuZCBtb2Rlc1xyXG4gICAgICAgIGFycmF5W0JsZW5kTW9kZXNTZXR0aW5ncy5CTEVORF9NT0RFUy5OT1JNQUxfTlBNXSA9IFtnbC5TUkNfQUxQSEEsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEEsIGdsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQV07XHJcbiAgICAgICAgYXJyYXlbQmxlbmRNb2Rlc1NldHRpbmdzLkJMRU5EX01PREVTLkFERF9OUE1dID0gW2dsLlNSQ19BTFBIQSwgZ2wuRFNUX0FMUEhBLCBnbC5PTkUsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEFdO1xyXG4gICAgICAgIGFycmF5W0JsZW5kTW9kZXNTZXR0aW5ncy5CTEVORF9NT0RFUy5TQ1JFRU5fTlBNXSA9IFtnbC5TUkNfQUxQSEEsIGdsLk9ORV9NSU5VU19TUkNfQ09MT1IsIGdsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQV07XHJcbiAgICAgICAgLy8gY29tcG9zaXRlIG9wZXJhdGlvbnNcclxuICAgICAgICBhcnJheVtCbGVuZE1vZGVzU2V0dGluZ3MuQkxFTkRfTU9ERVMuU1JDX0lOXSA9IFtnbC5EU1RfQUxQSEEsIGdsLlpFUk9dO1xyXG4gICAgICAgIGFycmF5W0JsZW5kTW9kZXNTZXR0aW5ncy5CTEVORF9NT0RFUy5TUkNfT1VUXSA9IFtnbC5PTkVfTUlOVVNfRFNUX0FMUEhBLCBnbC5aRVJPXTtcclxuICAgICAgICBhcnJheVtCbGVuZE1vZGVzU2V0dGluZ3MuQkxFTkRfTU9ERVMuU1JDX0FUT1BdID0gW2dsLkRTVF9BTFBIQSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQV07XHJcbiAgICAgICAgYXJyYXlbQmxlbmRNb2Rlc1NldHRpbmdzLkJMRU5EX01PREVTLkRTVF9PVkVSXSA9IFtnbC5PTkVfTUlOVVNfRFNUX0FMUEhBLCBnbC5PTkVdO1xyXG4gICAgICAgIGFycmF5W0JsZW5kTW9kZXNTZXR0aW5ncy5CTEVORF9NT0RFUy5EU1RfSU5dID0gW2dsLlpFUk8sIGdsLlNSQ19BTFBIQV07XHJcbiAgICAgICAgYXJyYXlbQmxlbmRNb2Rlc1NldHRpbmdzLkJMRU5EX01PREVTLkRTVF9PVVRdID0gW2dsLlpFUk8sIGdsLk9ORV9NSU5VU19TUkNfQUxQSEFdO1xyXG4gICAgICAgIGFycmF5W0JsZW5kTW9kZXNTZXR0aW5ncy5CTEVORF9NT0RFUy5EU1RfQVRPUF0gPSBbZ2wuT05FX01JTlVTX0RTVF9BTFBIQSwgZ2wuU1JDX0FMUEhBXTtcclxuICAgICAgICAvLyBTVUJUUkFDVCBmcm9tIGZsYXNoXHJcbiAgICAgICAgYXJyYXlbQmxlbmRNb2Rlc1NldHRpbmdzLkJMRU5EX01PREVTLlNVQlRSQUNUXSA9IFtnbC5PTkUsIGdsLk9ORSwgZ2wuT05FLCBnbC5PTkUsIGdsLkZVTkNfUkVWRVJTRV9TVUJUUkFDVCwgZ2wuRlVOQ19BRERdO1xyXG4gICAgICAgIHJldHVybiBhcnJheTtcclxuICAgIH1cclxufVxyXG4vKipcclxuKiBWYXJpb3VzIGJsZW5kIG1vZGVzIHN1cHBvcnRlZCBieSBQSVhJLlxyXG4qXHJcbiogSU1QT1JUQU5UIC0gVGhlIFdlYkdMIHJlbmRlcmVyIG9ubHkgc3VwcG9ydHMgdGhlIE5PUk1BTCwgQURELCBNVUxUSVBMWSBhbmQgU0NSRUVOIGJsZW5kIG1vZGVzLlxyXG4qIEFueXRoaW5nIGVsc2Ugd2lsbCBzaWxlbnRseSBhY3QgbGlrZSBOT1JNQUwuXHJcbipcclxuKiBAbWVtYmVyb2YgUElYSVxyXG4qIEBuYW1lIEJMRU5EX01PREVTXHJcbiogQGVudW0ge251bWJlcn1cclxuKiBAcHJvcGVydHkge251bWJlcn0gTk9STUFMXHJcbiogQHByb3BlcnR5IHtudW1iZXJ9IEFERFxyXG4qIEBwcm9wZXJ0eSB7bnVtYmVyfSBNVUxUSVBMWVxyXG4qIEBwcm9wZXJ0eSB7bnVtYmVyfSBTQ1JFRU5cclxuKiBAcHJvcGVydHkge251bWJlcn0gT1ZFUkxBWVxyXG4qIEBwcm9wZXJ0eSB7bnVtYmVyfSBEQVJLRU5cclxuKiBAcHJvcGVydHkge251bWJlcn0gTElHSFRFTlxyXG4qIEBwcm9wZXJ0eSB7bnVtYmVyfSBDT0xPUl9ET0RHRVxyXG4qIEBwcm9wZXJ0eSB7bnVtYmVyfSBDT0xPUl9CVVJOXHJcbiogQHByb3BlcnR5IHtudW1iZXJ9IEhBUkRfTElHSFRcclxuKiBAcHJvcGVydHkge251bWJlcn0gU09GVF9MSUdIVFxyXG4qIEBwcm9wZXJ0eSB7bnVtYmVyfSBESUZGRVJFTkNFXHJcbiogQHByb3BlcnR5IHtudW1iZXJ9IEVYQ0xVU0lPTlxyXG4qIEBwcm9wZXJ0eSB7bnVtYmVyfSBIVUVcclxuKiBAcHJvcGVydHkge251bWJlcn0gU0FUVVJBVElPTlxyXG4qIEBwcm9wZXJ0eSB7bnVtYmVyfSBDT0xPUlxyXG4qIEBwcm9wZXJ0eSB7bnVtYmVyfSBMVU1JTk9TSVRZXHJcbiogQHByb3BlcnR5IHtudW1iZXJ9IE5PUk1BTF9OUE1cclxuKiBAcHJvcGVydHkge251bWJlcn0gQUREX05QTVxyXG4qIEBwcm9wZXJ0eSB7bnVtYmVyfSBTQ1JFRU5fTlBNXHJcbiogQHByb3BlcnR5IHtudW1iZXJ9IE5PTkVcclxuKiBAcHJvcGVydHkge251bWJlcn0gU1JDX0lOXHJcbiogQHByb3BlcnR5IHtudW1iZXJ9IFNSQ19PVVRcclxuKiBAcHJvcGVydHkge251bWJlcn0gU1JDX0FUT1BcclxuKiBAcHJvcGVydHkge251bWJlcn0gRFNUX09WRVJcclxuKiBAcHJvcGVydHkge251bWJlcn0gRFNUX0lOXHJcbiogQHByb3BlcnR5IHtudW1iZXJ9IERTVF9PVVRcclxuKiBAcHJvcGVydHkge251bWJlcn0gRFNUX0FUT1BcclxuKiBAcHJvcGVydHkge251bWJlcn0gU1VCVFJBQ1RcclxuKiBAcHJvcGVydHkge251bWJlcn0gU1JDX09WRVJcclxuKiBAcHJvcGVydHkge251bWJlcn0gRVJBU0VcclxuKi9cclxuQmxlbmRNb2Rlc1NldHRpbmdzLkJMRU5EX01PREVTID0ge1xyXG4gICAgTk9STUFMOiAwLFxyXG4gICAgQUREOiAxLFxyXG4gICAgTVVMVElQTFk6IDIsXHJcbiAgICBTQ1JFRU46IDMsXHJcbiAgICBPVkVSTEFZOiA0LFxyXG4gICAgREFSS0VOOiA1LFxyXG4gICAgTElHSFRFTjogNixcclxuICAgIENPTE9SX0RPREdFOiA3LFxyXG4gICAgQ09MT1JfQlVSTjogOCxcclxuICAgIEhBUkRfTElHSFQ6IDksXHJcbiAgICBTT0ZUX0xJR0hUOiAxMCxcclxuICAgIERJRkZFUkVOQ0U6IDExLFxyXG4gICAgRVhDTFVTSU9OOiAxMixcclxuICAgIEhVRTogMTMsXHJcbiAgICBTQVRVUkFUSU9OOiAxNCxcclxuICAgIENPTE9SOiAxNSxcclxuICAgIExVTUlOT1NJVFk6IDE2LFxyXG4gICAgTk9STUFMX05QTTogMTcsXHJcbiAgICBBRERfTlBNOiAxOCxcclxuICAgIFNDUkVFTl9OUE06IDE5LFxyXG4gICAgTk9ORTogMjAsXHJcbiAgICBTUkNfT1ZFUjogMCxcclxuICAgIFNSQ19JTjogMjEsXHJcbiAgICBTUkNfT1VUOiAyMixcclxuICAgIFNSQ19BVE9QOiAyMyxcclxuICAgIERTVF9PVkVSOiAyNCxcclxuICAgIERTVF9JTjogMjUsXHJcbiAgICBEU1RfT1VUOiAyNixcclxuICAgIERTVF9BVE9QOiAyNyxcclxuICAgIEVSQVNFOiAyNixcclxuICAgIFNVQlRSQUNUOiAyOCxcclxufTtcclxuLyoqXHJcbiogbWFwcyBwcmVtdWx0aXBseSBmbGFnIGFuZCBibGVuZE1vZGUgdG8gYWRqdXN0ZWQgYmxlbmRNb2RlXHJcbiogQG1lbWJlcm9mIFBJWEkudXRpbHNcclxuKiBAY29uc3QgcHJlbXVsdGlwbHlCbGVuZE1vZGVcclxuKiBAdHlwZSB7QXJyYXk8bnVtYmVyW10+fVxyXG4qL1xyXG5CbGVuZE1vZGVzU2V0dGluZ3MucHJlbXVsdGlwbHlCbGVuZE1vZGUgPSBCbGVuZE1vZGVzU2V0dGluZ3MubWFwUHJlbXVsdGlwbGllZEJsZW5kTW9kZXMoKTtcclxuZXhwb3J0cy5CbGVuZE1vZGVzU2V0dGluZ3MgPSBCbGVuZE1vZGVzU2V0dGluZ3M7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IEZpbHRlcl8xID0gcmVxdWlyZShcIi4vRmlsdGVyXCIpO1xyXG5jb25zdCBCbHVyRmlsdGVyUGFzc18xID0gcmVxdWlyZShcIi4vQmx1ckZpbHRlclBhc3NcIik7XHJcbmNvbnN0IERpc3BsYXlTZXR0aW5nc18xID0gcmVxdWlyZShcIi4vRGlzcGxheVNldHRpbmdzXCIpO1xyXG5jbGFzcyBCbHVyRmlsdGVyIGV4dGVuZHMgRmlsdGVyXzEuRmlsdGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKHN0cmVuZ3RoID0gMSwgcXVhbGl0eSA9IDEsIHJlc29sdXRpb24gPSAxLCBrZXJuZWxTaXplID0gNSkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5ibHVyWEZpbHRlciA9IG5ldyBCbHVyRmlsdGVyUGFzc18xLkJsdXJGaWx0ZXJQYXNzKHRydWUsIHN0cmVuZ3RoLCBxdWFsaXR5LCByZXNvbHV0aW9uLCBrZXJuZWxTaXplKTtcclxuICAgICAgICB0aGlzLmJsdXJZRmlsdGVyID0gbmV3IEJsdXJGaWx0ZXJQYXNzXzEuQmx1ckZpbHRlclBhc3MoZmFsc2UsIHN0cmVuZ3RoLCBxdWFsaXR5LCByZXNvbHV0aW9uLCBrZXJuZWxTaXplKTtcclxuICAgICAgICB0aGlzLnJlc29sdXRpb24gPSByZXNvbHV0aW9uIHx8IERpc3BsYXlTZXR0aW5nc18xLkRpc3BsYXlTZXR0aW5ncy5SRVNPTFVUSU9OO1xyXG4gICAgICAgIHRoaXMucXVhbGl0eSA9IHF1YWxpdHkgfHwgNDtcclxuICAgICAgICB0aGlzLmJsdXIgPSBzdHJlbmd0aCB8fCA4O1xyXG4gICAgICAgIHRoaXMucmVwZWF0RWRnZVBpeGVscyA9IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBsaWVzIHRoZSBmaWx0ZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtQSVhJLnN5c3RlbXMuRmlsdGVyU3lzdGVtfSBmaWx0ZXJNYW5hZ2VyIC0gVGhlIG1hbmFnZXIuXHJcbiAgICAgKiBAcGFyYW0ge1BJWEkuUmVuZGVyVGV4dHVyZX0gaW5wdXQgLSBUaGUgaW5wdXQgdGFyZ2V0LlxyXG4gICAgICogQHBhcmFtIHtQSVhJLlJlbmRlclRleHR1cmV9IG91dHB1dCAtIFRoZSBvdXRwdXQgdGFyZ2V0LlxyXG4gICAgICovXHJcbiAgICBhcHBseShmaWx0ZXJNYW5hZ2VyLCBpbnB1dCwgb3V0cHV0LCBjbGVhcikge1xyXG4gICAgICAgIHZhciB4U3RyZW5ndGggPSBNYXRoLmFicyh0aGlzLmJsdXJYRmlsdGVyLnN0cmVuZ3RoKTtcclxuICAgICAgICB2YXIgeVN0cmVuZ3RoID0gTWF0aC5hYnModGhpcy5ibHVyWUZpbHRlci5zdHJlbmd0aCk7XHJcbiAgICAgICAgaWYgKHhTdHJlbmd0aCAmJiB5U3RyZW5ndGgpIHtcclxuICAgICAgICAgICAgdmFyIHJlbmRlclRhcmdldCA9IGZpbHRlck1hbmFnZXIuZ2V0RmlsdGVyVGV4dHVyZSgpO1xyXG4gICAgICAgICAgICB0aGlzLmJsdXJYRmlsdGVyLmFwcGx5KGZpbHRlck1hbmFnZXIsIGlucHV0LCByZW5kZXJUYXJnZXQsIHRydWUpO1xyXG4gICAgICAgICAgICB0aGlzLmJsdXJZRmlsdGVyLmFwcGx5KGZpbHRlck1hbmFnZXIsIHJlbmRlclRhcmdldCwgb3V0cHV0LCBjbGVhcik7XHJcbiAgICAgICAgICAgIGZpbHRlck1hbmFnZXIucmV0dXJuRmlsdGVyVGV4dHVyZShyZW5kZXJUYXJnZXQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh5U3RyZW5ndGgpIHtcclxuICAgICAgICAgICAgdGhpcy5ibHVyWUZpbHRlci5hcHBseShmaWx0ZXJNYW5hZ2VyLCBpbnB1dCwgb3V0cHV0LCBjbGVhcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmJsdXJYRmlsdGVyLmFwcGx5KGZpbHRlck1hbmFnZXIsIGlucHV0LCBvdXRwdXQsIGNsZWFyKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICB1cGRhdGVQYWRkaW5nKCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9yZXBlYXRFZGdlUGl4ZWxzKSB7XHJcbiAgICAgICAgICAgIHRoaXMucGFkZGluZyA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnBhZGRpbmcgPSBNYXRoLm1heChNYXRoLmFicyh0aGlzLmJsdXJYRmlsdGVyLnN0cmVuZ3RoKSwgTWF0aC5hYnModGhpcy5ibHVyWUZpbHRlci5zdHJlbmd0aCkpICogMjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIHN0cmVuZ3RoIG9mIGJvdGggdGhlIGJsdXJYIGFuZCBibHVyWSBwcm9wZXJ0aWVzIHNpbXVsdGFuZW91c2x5XHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICogQGRlZmF1bHQgMlxyXG4gICAgICovXHJcbiAgICBnZXQgYmx1cigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5ibHVyWEZpbHRlci5ibHVyO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgc2V0IGJsdXIodmFsdWUpIHtcclxuICAgICAgICB0aGlzLmJsdXJYRmlsdGVyLmJsdXIgPSB0aGlzLmJsdXJZRmlsdGVyLmJsdXIgPSB2YWx1ZTtcclxuICAgICAgICB0aGlzLnVwZGF0ZVBhZGRpbmcoKTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgbnVtYmVyIG9mIHBhc3NlcyBmb3IgYmx1ci4gTW9yZSBwYXNzZXMgbWVhbnMgaGlnaGVyIHF1YWlsaXR5IGJsdXJpbmcuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICogQGRlZmF1bHQgMVxyXG4gICAgICovXHJcbiAgICBnZXQgcXVhbGl0eSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5ibHVyWEZpbHRlci5xdWFsaXR5O1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgc2V0IHF1YWxpdHkodmFsdWUpIHtcclxuICAgICAgICB0aGlzLmJsdXJYRmlsdGVyLnF1YWxpdHkgPSB0aGlzLmJsdXJZRmlsdGVyLnF1YWxpdHkgPSB2YWx1ZTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgc3RyZW5ndGggb2YgdGhlIGJsdXJYIHByb3BlcnR5XHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICogQGRlZmF1bHQgMlxyXG4gICAgICovXHJcbiAgICBnZXQgYmx1clgoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYmx1clhGaWx0ZXIuYmx1cjtcclxuICAgIH1cclxuICAgIDtcclxuICAgIHNldCBibHVyWCh2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuYmx1clhGaWx0ZXIuYmx1ciA9IHZhbHVlO1xyXG4gICAgICAgIHRoaXMudXBkYXRlUGFkZGluZygpO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBzdHJlbmd0aCBvZiB0aGUgYmx1clkgcHJvcGVydHlcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgKiBAZGVmYXVsdCAyXHJcbiAgICAgKi9cclxuICAgIGdldCBibHVyWSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5ibHVyWUZpbHRlci5ibHVyO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgc2V0IGJsdXJZKHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5ibHVyWUZpbHRlci5ibHVyID0gdmFsdWU7XHJcbiAgICAgICAgdGhpcy51cGRhdGVQYWRkaW5nKCk7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIGJsZW5kbW9kZSBvZiB0aGUgZmlsdGVyXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICogQGRlZmF1bHQgUElYSS5CTEVORF9NT0RFUy5OT1JNQUxcclxuICAgICAqL1xyXG4gICAgZ2V0IGJsZW5kTW9kZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5ibHVyWUZpbHRlci5ibGVuZE1vZGU7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICBzZXQgYmxlbmRNb2RlKHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5ibHVyWUZpbHRlci5ibGVuZE1vZGUgPSB2YWx1ZTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogSWYgc2V0IHRvIHRydWUgdGhlIGVkZ2Ugb2YgdGhlIHRhcmdldCB3aWxsIGJlIGNsYW1wZWRcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtib29sfVxyXG4gICAgICogQGRlZmF1bHQgZmFsc2VcclxuICAgICAqL1xyXG4gICAgZ2V0IHJlcGVhdEVkZ2VQaXhlbHMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlcGVhdEVkZ2VQaXhlbHM7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICBzZXQgcmVwZWF0RWRnZVBpeGVscyh2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuX3JlcGVhdEVkZ2VQaXhlbHMgPSB2YWx1ZTtcclxuICAgICAgICB0aGlzLnVwZGF0ZVBhZGRpbmcoKTtcclxuICAgIH1cclxuICAgIDtcclxufVxyXG5leHBvcnRzLkJsdXJGaWx0ZXIgPSBCbHVyRmlsdGVyO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBGaWx0ZXJfMSA9IHJlcXVpcmUoXCIuL0ZpbHRlclwiKTtcclxuY29uc3QgRGlzcGxheVNldHRpbmdzXzEgPSByZXF1aXJlKFwiLi9EaXNwbGF5U2V0dGluZ3NcIik7XHJcbmNsYXNzIEJsdXJGaWx0ZXJQYXNzIGV4dGVuZHMgRmlsdGVyXzEuRmlsdGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKGhvcml6b250YWwsIHN0cmVuZ3RoLCBxdWFsaXR5LCByZXNvbHV0aW9uLCBrZXJuZWxTaXplKSB7XHJcbiAgICAgICAga2VybmVsU2l6ZSA9IGtlcm5lbFNpemUgfHwgNTtcclxuICAgICAgICB2YXIgdmVydFNyYyA9IEJsdXJGaWx0ZXJQYXNzLmdlbmVyYXRlQmx1clZlcnRTb3VyY2Uoa2VybmVsU2l6ZSwgaG9yaXpvbnRhbCk7XHJcbiAgICAgICAgdmFyIGZyYWdTcmMgPSBCbHVyRmlsdGVyUGFzcy5nZW5lcmF0ZUJsdXJGcmFnU291cmNlKGtlcm5lbFNpemUpO1xyXG4gICAgICAgIHN1cGVyKHZlcnRTcmMsIGZyYWdTcmMpO1xyXG4gICAgICAgIHRoaXMuaG9yaXpvbnRhbCA9IGhvcml6b250YWw7XHJcbiAgICAgICAgdGhpcy5yZXNvbHV0aW9uID0gcmVzb2x1dGlvbiB8fCBEaXNwbGF5U2V0dGluZ3NfMS5EaXNwbGF5U2V0dGluZ3MuUkVTT0xVVElPTjtcclxuICAgICAgICB0aGlzLl9xdWFsaXR5ID0gMDtcclxuICAgICAgICB0aGlzLnF1YWxpdHkgPSBxdWFsaXR5IHx8IDQ7XHJcbiAgICAgICAgdGhpcy5ibHVyID0gc3RyZW5ndGggfHwgODtcclxuICAgIH1cclxuICAgIHN0YXRpYyBnZW5lcmF0ZUJsdXJGcmFnU291cmNlKGtlcm5lbFNpemUpIHtcclxuICAgICAgICB2YXIga2VybmVsID0gQmx1ckZpbHRlclBhc3MuR0FVU1NJQU5fVkFMVUVTW2tlcm5lbFNpemVdO1xyXG4gICAgICAgIHZhciBoYWxmTGVuZ3RoID0ga2VybmVsLmxlbmd0aDtcclxuICAgICAgICB2YXIgZnJhZ1NvdXJjZSA9IEJsdXJGaWx0ZXJQYXNzLmZyYWdUZW1wbGF0ZSQyO1xyXG4gICAgICAgIHZhciBibHVyTG9vcCA9ICcnO1xyXG4gICAgICAgIHZhciB0ZW1wbGF0ZSA9ICdnbF9GcmFnQ29sb3IgKz0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2Qmx1clRleENvb3Jkc1slaW5kZXglXSkgKiAldmFsdWUlOyc7XHJcbiAgICAgICAgdmFyIHZhbHVlO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2VybmVsU2l6ZTsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBibHVyID0gdGVtcGxhdGUucmVwbGFjZSgnJWluZGV4JScsIGkudG9TdHJpbmcoKSk7XHJcbiAgICAgICAgICAgIHZhbHVlID0gaTtcclxuICAgICAgICAgICAgaWYgKGkgPj0gaGFsZkxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBrZXJuZWxTaXplIC0gaSAtIDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYmx1ciA9IGJsdXIucmVwbGFjZSgnJXZhbHVlJScsIGtlcm5lbFt2YWx1ZV0pO1xyXG4gICAgICAgICAgICBibHVyTG9vcCArPSBibHVyO1xyXG4gICAgICAgICAgICBibHVyTG9vcCArPSAnXFxuJztcclxuICAgICAgICB9XHJcbiAgICAgICAgZnJhZ1NvdXJjZSA9IGZyYWdTb3VyY2UucmVwbGFjZSgnJWJsdXIlJywgYmx1ckxvb3ApO1xyXG4gICAgICAgIGZyYWdTb3VyY2UgPSBmcmFnU291cmNlLnJlcGxhY2UoJyVzaXplJScsIGtlcm5lbFNpemUpO1xyXG4gICAgICAgIHJldHVybiBmcmFnU291cmNlO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGdlbmVyYXRlQmx1clZlcnRTb3VyY2Uoa2VybmVsU2l6ZSwgeCkge1xyXG4gICAgICAgIHZhciBoYWxmTGVuZ3RoID0gTWF0aC5jZWlsKGtlcm5lbFNpemUgLyAyKTtcclxuICAgICAgICB2YXIgdmVydFNvdXJjZSA9IEJsdXJGaWx0ZXJQYXNzLnZlcnRUZW1wbGF0ZTtcclxuICAgICAgICB2YXIgYmx1ckxvb3AgPSAnJztcclxuICAgICAgICB2YXIgdGVtcGxhdGU7XHJcbiAgICAgICAgLy8gbGV0IHZhbHVlO1xyXG4gICAgICAgIGlmICh4KSB7XHJcbiAgICAgICAgICAgIHRlbXBsYXRlID0gJ3ZCbHVyVGV4Q29vcmRzWyVpbmRleCVdID0gIHRleHR1cmVDb29yZCArIHZlYzIoJXNhbXBsZUluZGV4JSAqIHN0cmVuZ3RoLCAwLjApOyc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0ZW1wbGF0ZSA9ICd2Qmx1clRleENvb3Jkc1slaW5kZXglXSA9ICB0ZXh0dXJlQ29vcmQgKyB2ZWMyKDAuMCwgJXNhbXBsZUluZGV4JSAqIHN0cmVuZ3RoKTsnO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtlcm5lbFNpemU7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgYmx1ciA9IHRlbXBsYXRlLnJlcGxhY2UoJyVpbmRleCUnLCBpKTtcclxuICAgICAgICAgICAgLy8gdmFsdWUgPSBpO1xyXG4gICAgICAgICAgICAvLyBpZihpID49IGhhbGZMZW5ndGgpXHJcbiAgICAgICAgICAgIC8vIHtcclxuICAgICAgICAgICAgLy8gICAgIHZhbHVlID0ga2VybmVsU2l6ZSAtIGkgLSAxO1xyXG4gICAgICAgICAgICAvLyB9XHJcbiAgICAgICAgICAgIGJsdXIgPSBibHVyLnJlcGxhY2UoJyVzYW1wbGVJbmRleCUnLCAoKGkgLSAoaGFsZkxlbmd0aCAtIDEpKSArIFwiLjBcIikpO1xyXG4gICAgICAgICAgICBibHVyTG9vcCArPSBibHVyO1xyXG4gICAgICAgICAgICBibHVyTG9vcCArPSAnXFxuJztcclxuICAgICAgICB9XHJcbiAgICAgICAgdmVydFNvdXJjZSA9IHZlcnRTb3VyY2UucmVwbGFjZSgnJWJsdXIlJywgYmx1ckxvb3ApO1xyXG4gICAgICAgIHZlcnRTb3VyY2UgPSB2ZXJ0U291cmNlLnJlcGxhY2UoJyVzaXplJScsIGtlcm5lbFNpemUpO1xyXG4gICAgICAgIHJldHVybiB2ZXJ0U291cmNlO1xyXG4gICAgfVxyXG4gICAgYXBwbHkoZmlsdGVyTWFuYWdlciwgaW5wdXQsIG91dHB1dCwgY2xlYXIpIHtcclxuICAgICAgICBpZiAob3V0cHV0KSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmhvcml6b250YWwpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudW5pZm9ybXMuc3RyZW5ndGggPSAoMSAvIG91dHB1dC53aWR0aCkgKiAob3V0cHV0LndpZHRoIC8gaW5wdXQud2lkdGgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy51bmlmb3Jtcy5zdHJlbmd0aCA9ICgxIC8gb3V0cHV0LmhlaWdodCkgKiAob3V0cHV0LmhlaWdodCAvIGlucHV0LmhlaWdodCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmhvcml6b250YWwpIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcclxuICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudW5pZm9ybXMuc3RyZW5ndGggPSAoMSAvIGZpbHRlck1hbmFnZXIucmVuZGVyZXIud2lkdGgpICogKGZpbHRlck1hbmFnZXIucmVuZGVyZXIud2lkdGggLyBpbnB1dC53aWR0aCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnVuaWZvcm1zLnN0cmVuZ3RoID0gKDEgLyBmaWx0ZXJNYW5hZ2VyLnJlbmRlcmVyLmhlaWdodCkgKiAoZmlsdGVyTWFuYWdlci5yZW5kZXJlci5oZWlnaHQgLyBpbnB1dC5oZWlnaHQpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gc2NyZWVuIHNwYWNlIVxyXG4gICAgICAgIHRoaXMudW5pZm9ybXMuc3RyZW5ndGggKj0gdGhpcy5zdHJlbmd0aDtcclxuICAgICAgICB0aGlzLnVuaWZvcm1zLnN0cmVuZ3RoIC89IHRoaXMucGFzc2VzO1xyXG4gICAgICAgIGlmICh0aGlzLnBhc3NlcyA9PT0gMSkge1xyXG4gICAgICAgICAgICBmaWx0ZXJNYW5hZ2VyLmFwcGx5RmlsdGVyKHRoaXMsIGlucHV0LCBvdXRwdXQsIGNsZWFyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciByZW5kZXJUYXJnZXQgPSBmaWx0ZXJNYW5hZ2VyLmdldEZpbHRlclRleHR1cmUoKTtcclxuICAgICAgICAgICAgdmFyIHJlbmRlcmVyID0gZmlsdGVyTWFuYWdlci5yZW5kZXJlcjtcclxuICAgICAgICAgICAgdmFyIGZsaXAgPSBpbnB1dDtcclxuICAgICAgICAgICAgdmFyIGZsb3AgPSByZW5kZXJUYXJnZXQ7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUuYmxlbmQgPSBmYWxzZTtcclxuICAgICAgICAgICAgZmlsdGVyTWFuYWdlci5hcHBseUZpbHRlcih0aGlzLCBmbGlwLCBmbG9wLCBmYWxzZSk7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgdGhpcy5wYXNzZXMgLSAxOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHJlbmRlcmVyLnJlbmRlclRleHR1cmUuYmluZChmbGlwLCBmbGlwLmZpbHRlckZyYW1lKTtcclxuICAgICAgICAgICAgICAgIHRoaXMudW5pZm9ybXMudVNhbXBsZXIgPSBmbG9wO1xyXG4gICAgICAgICAgICAgICAgdmFyIHRlbXAgPSBmbG9wO1xyXG4gICAgICAgICAgICAgICAgZmxvcCA9IGZsaXA7XHJcbiAgICAgICAgICAgICAgICBmbGlwID0gdGVtcDtcclxuICAgICAgICAgICAgICAgIHJlbmRlcmVyLnNoYWRlci5iaW5kKHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgcmVuZGVyZXIuZ2VvbWV0cnkuZHJhdyg1KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnN0YXRlLmJsZW5kID0gdHJ1ZTtcclxuICAgICAgICAgICAgZmlsdGVyTWFuYWdlci5hcHBseUZpbHRlcih0aGlzLCBmbG9wLCBvdXRwdXQsIGNsZWFyKTtcclxuICAgICAgICAgICAgZmlsdGVyTWFuYWdlci5yZXR1cm5GaWx0ZXJUZXh0dXJlKHJlbmRlclRhcmdldCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBzdHJlbmd0aCBvZiBib3RoIHRoZSBibHVyLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAqIEBkZWZhdWx0IDE2XHJcbiAgICAgKi9cclxuICAgIGdldCBibHVyKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnN0cmVuZ3RoO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgc2V0IGJsdXIodmFsdWUpIHtcclxuICAgICAgICB0aGlzLnBhZGRpbmcgPSAxICsgKE1hdGguYWJzKHZhbHVlKSAqIDIpO1xyXG4gICAgICAgIHRoaXMuc3RyZW5ndGggPSB2YWx1ZTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgcXVhbGl0eSBvZiB0aGUgYmx1ciBieSBtb2RpZnlpbmcgdGhlIG51bWJlciBvZiBwYXNzZXMuIE1vcmUgcGFzc2VzIG1lYW5zIGhpZ2hlclxyXG4gICAgICogcXVhaWxpdHkgYmx1cmluZyBidXQgdGhlIGxvd2VyIHRoZSBwZXJmb3JtYW5jZS5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgKiBAZGVmYXVsdCA0XHJcbiAgICAgKi9cclxuICAgIGdldCBxdWFsaXR5KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9xdWFsaXR5O1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgc2V0IHF1YWxpdHkodmFsdWUpIHtcclxuICAgICAgICB0aGlzLl9xdWFsaXR5ID0gdmFsdWU7XHJcbiAgICAgICAgdGhpcy5wYXNzZXMgPSB2YWx1ZTtcclxuICAgIH1cclxuICAgIDtcclxufVxyXG5CbHVyRmlsdGVyUGFzcy5HQVVTU0lBTl9WQUxVRVMgPSB7XHJcbiAgICA1OiBbMC4xNTMzODgsIDAuMjIxNDYxLCAwLjI1MDMwMV0sXHJcbiAgICA3OiBbMC4wNzEzMDMsIDAuMTMxNTE0LCAwLjE4OTg3OSwgMC4yMTQ2MDddLFxyXG4gICAgOTogWzAuMDI4NTMyLCAwLjA2NzIzNCwgMC4xMjQwMDksIDAuMTc5MDQ0LCAwLjIwMjM2XSxcclxuICAgIDExOiBbMC4wMDkzLCAwLjAyODAwMiwgMC4wNjU5ODQsIDAuMTIxNzAzLCAwLjE3NTcxMywgMC4xOTg1OTZdLFxyXG4gICAgMTM6IFswLjAwMjQwNiwgMC4wMDkyNTUsIDAuMDI3ODY3LCAwLjA2NTY2NiwgMC4xMjExMTcsIDAuMTc0ODY4LCAwLjE5NzY0MV0sXHJcbiAgICAxNTogWzAuMDAwNDg5LCAwLjAwMjQwMywgMC4wMDkyNDYsIDAuMDI3ODQsIDAuMDY1NjAyLCAwLjEyMDk5OSwgMC4xNzQ2OTcsIDAuMTk3NDQ4XSxcclxufTtcclxuQmx1ckZpbHRlclBhc3MudmVydFRlbXBsYXRlID0gXCJcXG4gICAgYXR0cmlidXRlIHZlYzIgYVZlcnRleFBvc2l0aW9uO1xcblxcbiAgICB1bmlmb3JtIG1hdDMgcHJvamVjdGlvbk1hdHJpeDtcXG5cXG4gICAgdW5pZm9ybSBmbG9hdCBzdHJlbmd0aDtcXG5cXG4gICAgdmFyeWluZyB2ZWMyIHZCbHVyVGV4Q29vcmRzWyVzaXplJV07XFxuXFxuICAgIHVuaWZvcm0gdmVjNCBpbnB1dFNpemU7XFxuICAgIHVuaWZvcm0gdmVjNCBvdXRwdXRGcmFtZTtcXG4gICAgXFxuICAgIHZlYzQgZmlsdGVyVmVydGV4UG9zaXRpb24oIHZvaWQgKVxcbiAgICB7XFxuICAgICAgICB2ZWMyIHBvc2l0aW9uID0gYVZlcnRleFBvc2l0aW9uICogbWF4KG91dHB1dEZyYW1lLnp3LCB2ZWMyKDAuKSkgKyBvdXRwdXRGcmFtZS54eTtcXG4gICAgXFxuICAgICAgICByZXR1cm4gdmVjNCgocHJvamVjdGlvbk1hdHJpeCAqIHZlYzMocG9zaXRpb24sIDEuMCkpLnh5LCAwLjAsIDEuMCk7XFxuICAgIH1cXG4gICAgXFxuICAgIHZlYzIgZmlsdGVyVGV4dHVyZUNvb3JkKCB2b2lkIClcXG4gICAge1xcbiAgICAgICAgcmV0dXJuIGFWZXJ0ZXhQb3NpdGlvbiAqIChvdXRwdXRGcmFtZS56dyAqIGlucHV0U2l6ZS56dyk7XFxuICAgIH1cXG5cXG4gICAgdm9pZCBtYWluKHZvaWQpXFxuICAgIHtcXG4gICAgICAgIGdsX1Bvc2l0aW9uID0gZmlsdGVyVmVydGV4UG9zaXRpb24oKTtcXG5cXG4gICAgICAgIHZlYzIgdGV4dHVyZUNvb3JkID0gZmlsdGVyVGV4dHVyZUNvb3JkKCk7XFxuICAgICAgICAlYmx1ciVcXG4gICAgfVwiO1xyXG5CbHVyRmlsdGVyUGFzcy5mcmFnVGVtcGxhdGUkMiA9IFtcclxuICAgICd2YXJ5aW5nIHZlYzIgdkJsdXJUZXhDb29yZHNbJXNpemUlXTsnLFxyXG4gICAgJ3VuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyOycsXHJcbiAgICAndm9pZCBtYWluKHZvaWQpJyxcclxuICAgICd7JyxcclxuICAgICcgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCgwLjApOycsXHJcbiAgICAnICAgICVibHVyJScsXHJcbiAgICAnfSdcclxuXS5qb2luKCdcXG4nKTtcclxuZXhwb3J0cy5CbHVyRmlsdGVyUGFzcyA9IEJsdXJGaWx0ZXJQYXNzO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBSZWN0YW5nbGVfMSA9IHJlcXVpcmUoXCIuL1JlY3RhbmdsZVwiKTtcclxuY2xhc3MgQm91bmRzIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAgICAgKiBAZGVmYXVsdCAwXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5taW5YID0gSW5maW5pdHk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICAgICAqIEBkZWZhdWx0IDBcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLm1pblkgPSBJbmZpbml0eTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgICAgICogQGRlZmF1bHQgMFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMubWF4WCA9IC1JbmZpbml0eTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgICAgICogQGRlZmF1bHQgMFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMubWF4WSA9IC1JbmZpbml0eTtcclxuICAgICAgICB0aGlzLnJlY3QgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAqIENoZWNrcyBpZiBib3VuZHMgYXJlIGVtcHR5LlxyXG4gKlxyXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGVtcHR5LlxyXG4gKi9cclxuICAgIGlzRW1wdHkoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubWluWCA+IHRoaXMubWF4WCB8fCB0aGlzLm1pblkgPiB0aGlzLm1heFk7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIENsZWFycyB0aGUgYm91bmRzIGFuZCByZXNldHMuXHJcbiAgICAgKlxyXG4gICAgICovXHJcbiAgICBjbGVhcigpIHtcclxuICAgICAgICB0aGlzLnVwZGF0ZUlEKys7XHJcbiAgICAgICAgdGhpcy5taW5YID0gSW5maW5pdHk7XHJcbiAgICAgICAgdGhpcy5taW5ZID0gSW5maW5pdHk7XHJcbiAgICAgICAgdGhpcy5tYXhYID0gLUluZmluaXR5O1xyXG4gICAgICAgIHRoaXMubWF4WSA9IC1JbmZpbml0eTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gKiBDYW4gcmV0dXJuIFJlY3RhbmdsZS5FTVBUWSBjb25zdGFudCwgZWl0aGVyIGNvbnN0cnVjdCBuZXcgcmVjdGFuZ2xlLCBlaXRoZXIgdXNlIHlvdXIgcmVjdGFuZ2xlXHJcbiAqIEl0IGlzIG5vdCBndWFyYW50ZWVkIHRoYXQgaXQgd2lsbCByZXR1cm4gdGVtcFJlY3RcclxuICpcclxuICogQHBhcmFtIHtQSVhJLlJlY3RhbmdsZX0gcmVjdCAtIHRlbXBvcmFyeSBvYmplY3Qgd2lsbCBiZSB1c2VkIGlmIEFBQkIgaXMgbm90IGVtcHR5XHJcbiAqIEByZXR1cm5zIHtQSVhJLlJlY3RhbmdsZX0gQSByZWN0YW5nbGUgb2YgdGhlIGJvdW5kc1xyXG4gKi9cclxuICAgIGdldFJlY3RhbmdsZShyZWN0KSB7XHJcbiAgICAgICAgaWYgKHRoaXMubWluWCA+IHRoaXMubWF4WCB8fCB0aGlzLm1pblkgPiB0aGlzLm1heFkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFJlY3RhbmdsZV8xLlJlY3RhbmdsZS5FTVBUWTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVjdCA9IHJlY3QgfHwgbmV3IFJlY3RhbmdsZV8xLlJlY3RhbmdsZSgwLCAwLCAxLCAxKTtcclxuICAgICAgICByZWN0LnggPSB0aGlzLm1pblg7XHJcbiAgICAgICAgcmVjdC55ID0gdGhpcy5taW5ZO1xyXG4gICAgICAgIHJlY3Qud2lkdGggPSB0aGlzLm1heFggLSB0aGlzLm1pblg7XHJcbiAgICAgICAgcmVjdC5oZWlnaHQgPSB0aGlzLm1heFkgLSB0aGlzLm1pblk7XHJcbiAgICAgICAgcmV0dXJuIHJlY3Q7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgZnVuY3Rpb24gc2hvdWxkIGJlIGlubGluZWQgd2hlbiBpdHMgcG9zc2libGUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtQSVhJLlBvaW50fSBwb2ludCAtIFRoZSBwb2ludCB0byBhZGQuXHJcbiAgICAgKi9cclxuICAgIGFkZFBvaW50KHBvaW50KSB7XHJcbiAgICAgICAgdGhpcy5taW5YID0gTWF0aC5taW4odGhpcy5taW5YLCBwb2ludC54KTtcclxuICAgICAgICB0aGlzLm1heFggPSBNYXRoLm1heCh0aGlzLm1heFgsIHBvaW50LngpO1xyXG4gICAgICAgIHRoaXMubWluWSA9IE1hdGgubWluKHRoaXMubWluWSwgcG9pbnQueSk7XHJcbiAgICAgICAgdGhpcy5tYXhZID0gTWF0aC5tYXgodGhpcy5tYXhZLCBwb2ludC55KTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhIHF1YWQsIG5vdCB0cmFuc2Zvcm1lZFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fSB2ZXJ0aWNlcyAtIFRoZSB2ZXJ0cyB0byBhZGQuXHJcbiAgICAgKi9cclxuICAgIGFkZFF1YWQodmVydGljZXMpIHtcclxuICAgICAgICB2YXIgbWluWCA9IHRoaXMubWluWDtcclxuICAgICAgICB2YXIgbWluWSA9IHRoaXMubWluWTtcclxuICAgICAgICB2YXIgbWF4WCA9IHRoaXMubWF4WDtcclxuICAgICAgICB2YXIgbWF4WSA9IHRoaXMubWF4WTtcclxuICAgICAgICB2YXIgeCA9IHZlcnRpY2VzWzBdO1xyXG4gICAgICAgIHZhciB5ID0gdmVydGljZXNbMV07XHJcbiAgICAgICAgbWluWCA9IHggPCBtaW5YID8geCA6IG1pblg7XHJcbiAgICAgICAgbWluWSA9IHkgPCBtaW5ZID8geSA6IG1pblk7XHJcbiAgICAgICAgbWF4WCA9IHggPiBtYXhYID8geCA6IG1heFg7XHJcbiAgICAgICAgbWF4WSA9IHkgPiBtYXhZID8geSA6IG1heFk7XHJcbiAgICAgICAgeCA9IHZlcnRpY2VzWzJdO1xyXG4gICAgICAgIHkgPSB2ZXJ0aWNlc1szXTtcclxuICAgICAgICBtaW5YID0geCA8IG1pblggPyB4IDogbWluWDtcclxuICAgICAgICBtaW5ZID0geSA8IG1pblkgPyB5IDogbWluWTtcclxuICAgICAgICBtYXhYID0geCA+IG1heFggPyB4IDogbWF4WDtcclxuICAgICAgICBtYXhZID0geSA+IG1heFkgPyB5IDogbWF4WTtcclxuICAgICAgICB4ID0gdmVydGljZXNbNF07XHJcbiAgICAgICAgeSA9IHZlcnRpY2VzWzVdO1xyXG4gICAgICAgIG1pblggPSB4IDwgbWluWCA/IHggOiBtaW5YO1xyXG4gICAgICAgIG1pblkgPSB5IDwgbWluWSA/IHkgOiBtaW5ZO1xyXG4gICAgICAgIG1heFggPSB4ID4gbWF4WCA/IHggOiBtYXhYO1xyXG4gICAgICAgIG1heFkgPSB5ID4gbWF4WSA/IHkgOiBtYXhZO1xyXG4gICAgICAgIHggPSB2ZXJ0aWNlc1s2XTtcclxuICAgICAgICB5ID0gdmVydGljZXNbN107XHJcbiAgICAgICAgbWluWCA9IHggPCBtaW5YID8geCA6IG1pblg7XHJcbiAgICAgICAgbWluWSA9IHkgPCBtaW5ZID8geSA6IG1pblk7XHJcbiAgICAgICAgbWF4WCA9IHggPiBtYXhYID8geCA6IG1heFg7XHJcbiAgICAgICAgbWF4WSA9IHkgPiBtYXhZID8geSA6IG1heFk7XHJcbiAgICAgICAgdGhpcy5taW5YID0gbWluWDtcclxuICAgICAgICB0aGlzLm1pblkgPSBtaW5ZO1xyXG4gICAgICAgIHRoaXMubWF4WCA9IG1heFg7XHJcbiAgICAgICAgdGhpcy5tYXhZID0gbWF4WTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBzcHJpdGUgZnJhbWUsIHRyYW5zZm9ybWVkLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7UElYSS5UcmFuc2Zvcm19IHRyYW5zZm9ybSAtIFRPRE9cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4MCAtIFRPRE9cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5MCAtIFRPRE9cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4MSAtIFRPRE9cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5MSAtIFRPRE9cclxuICAgICAqL1xyXG4gICAgYWRkRnJhbWUodHJhbnNmb3JtLCB4MCwgeTAsIHgxLCB5MSkge1xyXG4gICAgICAgIHZhciBtYXRyaXggPSB0cmFuc2Zvcm0ud29ybGRUcmFuc2Zvcm07XHJcbiAgICAgICAgdmFyIGEgPSBtYXRyaXguYTtcclxuICAgICAgICB2YXIgYiA9IG1hdHJpeC5iO1xyXG4gICAgICAgIHZhciBjID0gbWF0cml4LmM7XHJcbiAgICAgICAgdmFyIGQgPSBtYXRyaXguZDtcclxuICAgICAgICB2YXIgdHggPSBtYXRyaXgudHg7XHJcbiAgICAgICAgdmFyIHR5ID0gbWF0cml4LnR5O1xyXG4gICAgICAgIHZhciBtaW5YID0gdGhpcy5taW5YO1xyXG4gICAgICAgIHZhciBtaW5ZID0gdGhpcy5taW5ZO1xyXG4gICAgICAgIHZhciBtYXhYID0gdGhpcy5tYXhYO1xyXG4gICAgICAgIHZhciBtYXhZID0gdGhpcy5tYXhZO1xyXG4gICAgICAgIHZhciB4ID0gKGEgKiB4MCkgKyAoYyAqIHkwKSArIHR4O1xyXG4gICAgICAgIHZhciB5ID0gKGIgKiB4MCkgKyAoZCAqIHkwKSArIHR5O1xyXG4gICAgICAgIG1pblggPSB4IDwgbWluWCA/IHggOiBtaW5YO1xyXG4gICAgICAgIG1pblkgPSB5IDwgbWluWSA/IHkgOiBtaW5ZO1xyXG4gICAgICAgIG1heFggPSB4ID4gbWF4WCA/IHggOiBtYXhYO1xyXG4gICAgICAgIG1heFkgPSB5ID4gbWF4WSA/IHkgOiBtYXhZO1xyXG4gICAgICAgIHggPSAoYSAqIHgxKSArIChjICogeTApICsgdHg7XHJcbiAgICAgICAgeSA9IChiICogeDEpICsgKGQgKiB5MCkgKyB0eTtcclxuICAgICAgICBtaW5YID0geCA8IG1pblggPyB4IDogbWluWDtcclxuICAgICAgICBtaW5ZID0geSA8IG1pblkgPyB5IDogbWluWTtcclxuICAgICAgICBtYXhYID0geCA+IG1heFggPyB4IDogbWF4WDtcclxuICAgICAgICBtYXhZID0geSA+IG1heFkgPyB5IDogbWF4WTtcclxuICAgICAgICB4ID0gKGEgKiB4MCkgKyAoYyAqIHkxKSArIHR4O1xyXG4gICAgICAgIHkgPSAoYiAqIHgwKSArIChkICogeTEpICsgdHk7XHJcbiAgICAgICAgbWluWCA9IHggPCBtaW5YID8geCA6IG1pblg7XHJcbiAgICAgICAgbWluWSA9IHkgPCBtaW5ZID8geSA6IG1pblk7XHJcbiAgICAgICAgbWF4WCA9IHggPiBtYXhYID8geCA6IG1heFg7XHJcbiAgICAgICAgbWF4WSA9IHkgPiBtYXhZID8geSA6IG1heFk7XHJcbiAgICAgICAgeCA9IChhICogeDEpICsgKGMgKiB5MSkgKyB0eDtcclxuICAgICAgICB5ID0gKGIgKiB4MSkgKyAoZCAqIHkxKSArIHR5O1xyXG4gICAgICAgIG1pblggPSB4IDwgbWluWCA/IHggOiBtaW5YO1xyXG4gICAgICAgIG1pblkgPSB5IDwgbWluWSA/IHkgOiBtaW5ZO1xyXG4gICAgICAgIG1heFggPSB4ID4gbWF4WCA/IHggOiBtYXhYO1xyXG4gICAgICAgIG1heFkgPSB5ID4gbWF4WSA/IHkgOiBtYXhZO1xyXG4gICAgICAgIHRoaXMubWluWCA9IG1pblg7XHJcbiAgICAgICAgdGhpcy5taW5ZID0gbWluWTtcclxuICAgICAgICB0aGlzLm1heFggPSBtYXhYO1xyXG4gICAgICAgIHRoaXMubWF4WSA9IG1heFk7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgc2NyZWVuIHZlcnRpY2VzIGZyb20gYXJyYXlcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0Zsb2F0MzJBcnJheX0gdmVydGV4RGF0YSAtIGNhbGN1bGF0ZWQgdmVydGljZXNcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiZWdpbk9mZnNldCAtIGJlZ2luIG9mZnNldFxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZE9mZnNldCAtIGVuZCBvZmZzZXQsIGV4Y2x1ZGVkXHJcbiAgICAgKi9cclxuICAgIGFkZFZlcnRleERhdGEodmVydGV4RGF0YSwgYmVnaW5PZmZzZXQsIGVuZE9mZnNldCkge1xyXG4gICAgICAgIHZhciBtaW5YID0gdGhpcy5taW5YO1xyXG4gICAgICAgIHZhciBtaW5ZID0gdGhpcy5taW5ZO1xyXG4gICAgICAgIHZhciBtYXhYID0gdGhpcy5tYXhYO1xyXG4gICAgICAgIHZhciBtYXhZID0gdGhpcy5tYXhZO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSBiZWdpbk9mZnNldDsgaSA8IGVuZE9mZnNldDsgaSArPSAyKSB7XHJcbiAgICAgICAgICAgIHZhciB4ID0gdmVydGV4RGF0YVtpXTtcclxuICAgICAgICAgICAgdmFyIHkgPSB2ZXJ0ZXhEYXRhW2kgKyAxXTtcclxuICAgICAgICAgICAgbWluWCA9IHggPCBtaW5YID8geCA6IG1pblg7XHJcbiAgICAgICAgICAgIG1pblkgPSB5IDwgbWluWSA/IHkgOiBtaW5ZO1xyXG4gICAgICAgICAgICBtYXhYID0geCA+IG1heFggPyB4IDogbWF4WDtcclxuICAgICAgICAgICAgbWF4WSA9IHkgPiBtYXhZID8geSA6IG1heFk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubWluWCA9IG1pblg7XHJcbiAgICAgICAgdGhpcy5taW5ZID0gbWluWTtcclxuICAgICAgICB0aGlzLm1heFggPSBtYXhYO1xyXG4gICAgICAgIHRoaXMubWF4WSA9IG1heFk7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIEFkZCBhbiBhcnJheSBvZiBtZXNoIHZlcnRpY2VzXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtQSVhJLlRyYW5zZm9ybX0gdHJhbnNmb3JtIC0gbWVzaCB0cmFuc2Zvcm1cclxuICAgICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fSB2ZXJ0aWNlcyAtIG1lc2ggY29vcmRpbmF0ZXMgaW4gYXJyYXlcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiZWdpbk9mZnNldCAtIGJlZ2luIG9mZnNldFxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZE9mZnNldCAtIGVuZCBvZmZzZXQsIGV4Y2x1ZGVkXHJcbiAgICAgKi9cclxuICAgIGFkZFZlcnRpY2VzKHRyYW5zZm9ybSwgdmVydGljZXMsIGJlZ2luT2Zmc2V0LCBlbmRPZmZzZXQpIHtcclxuICAgICAgICB2YXIgbWF0cml4ID0gdHJhbnNmb3JtLndvcmxkVHJhbnNmb3JtO1xyXG4gICAgICAgIHZhciBhID0gbWF0cml4LmE7XHJcbiAgICAgICAgdmFyIGIgPSBtYXRyaXguYjtcclxuICAgICAgICB2YXIgYyA9IG1hdHJpeC5jO1xyXG4gICAgICAgIHZhciBkID0gbWF0cml4LmQ7XHJcbiAgICAgICAgdmFyIHR4ID0gbWF0cml4LnR4O1xyXG4gICAgICAgIHZhciB0eSA9IG1hdHJpeC50eTtcclxuICAgICAgICB2YXIgbWluWCA9IHRoaXMubWluWDtcclxuICAgICAgICB2YXIgbWluWSA9IHRoaXMubWluWTtcclxuICAgICAgICB2YXIgbWF4WCA9IHRoaXMubWF4WDtcclxuICAgICAgICB2YXIgbWF4WSA9IHRoaXMubWF4WTtcclxuICAgICAgICBmb3IgKHZhciBpID0gYmVnaW5PZmZzZXQ7IGkgPCBlbmRPZmZzZXQ7IGkgKz0gMikge1xyXG4gICAgICAgICAgICB2YXIgcmF3WCA9IHZlcnRpY2VzW2ldO1xyXG4gICAgICAgICAgICB2YXIgcmF3WSA9IHZlcnRpY2VzW2kgKyAxXTtcclxuICAgICAgICAgICAgdmFyIHggPSAoYSAqIHJhd1gpICsgKGMgKiByYXdZKSArIHR4O1xyXG4gICAgICAgICAgICB2YXIgeSA9IChkICogcmF3WSkgKyAoYiAqIHJhd1gpICsgdHk7XHJcbiAgICAgICAgICAgIG1pblggPSB4IDwgbWluWCA/IHggOiBtaW5YO1xyXG4gICAgICAgICAgICBtaW5ZID0geSA8IG1pblkgPyB5IDogbWluWTtcclxuICAgICAgICAgICAgbWF4WCA9IHggPiBtYXhYID8geCA6IG1heFg7XHJcbiAgICAgICAgICAgIG1heFkgPSB5ID4gbWF4WSA/IHkgOiBtYXhZO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLm1pblggPSBtaW5YO1xyXG4gICAgICAgIHRoaXMubWluWSA9IG1pblk7XHJcbiAgICAgICAgdGhpcy5tYXhYID0gbWF4WDtcclxuICAgICAgICB0aGlzLm1heFkgPSBtYXhZO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIG90aGVyIEJvdW5kc1xyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7UElYSS5Cb3VuZHN9IGJvdW5kcyAtIFRPRE9cclxuICAgICAqL1xyXG4gICAgYWRkQm91bmRzKGJvdW5kcykge1xyXG4gICAgICAgIHZhciBtaW5YID0gdGhpcy5taW5YO1xyXG4gICAgICAgIHZhciBtaW5ZID0gdGhpcy5taW5ZO1xyXG4gICAgICAgIHZhciBtYXhYID0gdGhpcy5tYXhYO1xyXG4gICAgICAgIHZhciBtYXhZID0gdGhpcy5tYXhZO1xyXG4gICAgICAgIHRoaXMubWluWCA9IGJvdW5kcy5taW5YIDwgbWluWCA/IGJvdW5kcy5taW5YIDogbWluWDtcclxuICAgICAgICB0aGlzLm1pblkgPSBib3VuZHMubWluWSA8IG1pblkgPyBib3VuZHMubWluWSA6IG1pblk7XHJcbiAgICAgICAgdGhpcy5tYXhYID0gYm91bmRzLm1heFggPiBtYXhYID8gYm91bmRzLm1heFggOiBtYXhYO1xyXG4gICAgICAgIHRoaXMubWF4WSA9IGJvdW5kcy5tYXhZID4gbWF4WSA/IGJvdW5kcy5tYXhZIDogbWF4WTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBvdGhlciBCb3VuZHMsIG1hc2tlZCB3aXRoIEJvdW5kc1xyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7UElYSS5Cb3VuZHN9IGJvdW5kcyAtIFRPRE9cclxuICAgICAqIEBwYXJhbSB7UElYSS5Cb3VuZHN9IG1hc2sgLSBUT0RPXHJcbiAgICAgKi9cclxuICAgIGFkZEJvdW5kc01hc2soYm91bmRzLCBtYXNrKSB7XHJcbiAgICAgICAgdmFyIF9taW5YID0gYm91bmRzLm1pblggPiBtYXNrLm1pblggPyBib3VuZHMubWluWCA6IG1hc2subWluWDtcclxuICAgICAgICB2YXIgX21pblkgPSBib3VuZHMubWluWSA+IG1hc2subWluWSA/IGJvdW5kcy5taW5ZIDogbWFzay5taW5ZO1xyXG4gICAgICAgIHZhciBfbWF4WCA9IGJvdW5kcy5tYXhYIDwgbWFzay5tYXhYID8gYm91bmRzLm1heFggOiBtYXNrLm1heFg7XHJcbiAgICAgICAgdmFyIF9tYXhZID0gYm91bmRzLm1heFkgPCBtYXNrLm1heFkgPyBib3VuZHMubWF4WSA6IG1hc2subWF4WTtcclxuICAgICAgICBpZiAoX21pblggPD0gX21heFggJiYgX21pblkgPD0gX21heFkpIHtcclxuICAgICAgICAgICAgdmFyIG1pblggPSB0aGlzLm1pblg7XHJcbiAgICAgICAgICAgIHZhciBtaW5ZID0gdGhpcy5taW5ZO1xyXG4gICAgICAgICAgICB2YXIgbWF4WCA9IHRoaXMubWF4WDtcclxuICAgICAgICAgICAgdmFyIG1heFkgPSB0aGlzLm1heFk7XHJcbiAgICAgICAgICAgIHRoaXMubWluWCA9IF9taW5YIDwgbWluWCA/IF9taW5YIDogbWluWDtcclxuICAgICAgICAgICAgdGhpcy5taW5ZID0gX21pblkgPCBtaW5ZID8gX21pblkgOiBtaW5ZO1xyXG4gICAgICAgICAgICB0aGlzLm1heFggPSBfbWF4WCA+IG1heFggPyBfbWF4WCA6IG1heFg7XHJcbiAgICAgICAgICAgIHRoaXMubWF4WSA9IF9tYXhZID4gbWF4WSA/IF9tYXhZIDogbWF4WTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgb3RoZXIgQm91bmRzLCBtYXNrZWQgd2l0aCBSZWN0YW5nbGVcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1BJWEkuQm91bmRzfSBib3VuZHMgLSBUT0RPXHJcbiAgICAgKiBAcGFyYW0ge1BJWEkuUmVjdGFuZ2xlfSBhcmVhIC0gVE9ET1xyXG4gICAgICovXHJcbiAgICBhZGRCb3VuZHNBcmVhKGJvdW5kcywgYXJlYSkge1xyXG4gICAgICAgIHZhciBfbWluWCA9IGJvdW5kcy5taW5YID4gYXJlYS54ID8gYm91bmRzLm1pblggOiBhcmVhLng7XHJcbiAgICAgICAgdmFyIF9taW5ZID0gYm91bmRzLm1pblkgPiBhcmVhLnkgPyBib3VuZHMubWluWSA6IGFyZWEueTtcclxuICAgICAgICB2YXIgX21heFggPSBib3VuZHMubWF4WCA8IGFyZWEueCArIGFyZWEud2lkdGggPyBib3VuZHMubWF4WCA6IChhcmVhLnggKyBhcmVhLndpZHRoKTtcclxuICAgICAgICB2YXIgX21heFkgPSBib3VuZHMubWF4WSA8IGFyZWEueSArIGFyZWEuaGVpZ2h0ID8gYm91bmRzLm1heFkgOiAoYXJlYS55ICsgYXJlYS5oZWlnaHQpO1xyXG4gICAgICAgIGlmIChfbWluWCA8PSBfbWF4WCAmJiBfbWluWSA8PSBfbWF4WSkge1xyXG4gICAgICAgICAgICB2YXIgbWluWCA9IHRoaXMubWluWDtcclxuICAgICAgICAgICAgdmFyIG1pblkgPSB0aGlzLm1pblk7XHJcbiAgICAgICAgICAgIHZhciBtYXhYID0gdGhpcy5tYXhYO1xyXG4gICAgICAgICAgICB2YXIgbWF4WSA9IHRoaXMubWF4WTtcclxuICAgICAgICAgICAgdGhpcy5taW5YID0gX21pblggPCBtaW5YID8gX21pblggOiBtaW5YO1xyXG4gICAgICAgICAgICB0aGlzLm1pblkgPSBfbWluWSA8IG1pblkgPyBfbWluWSA6IG1pblk7XHJcbiAgICAgICAgICAgIHRoaXMubWF4WCA9IF9tYXhYID4gbWF4WCA/IF9tYXhYIDogbWF4WDtcclxuICAgICAgICAgICAgdGhpcy5tYXhZID0gX21heFkgPiBtYXhZID8gX21heFkgOiBtYXhZO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIDtcclxufVxyXG5leHBvcnRzLkJvdW5kcyA9IEJvdW5kcztcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgUnVubmVyXzEgPSByZXF1aXJlKFwiLi9SdW5uZXJcIik7XHJcbmNsYXNzIEJ1ZmZlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihkYXRhID0gbnVsbCwgX3N0YXRpYyA9IGZhbHNlLCBpbmRleCA9IG51bGwpIHtcclxuICAgICAgICBpZiAoX3N0YXRpYyA9PT0gdm9pZCAwKSB7XHJcbiAgICAgICAgICAgIF9zdGF0aWMgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaW5kZXggPT09IHZvaWQgMCkge1xyXG4gICAgICAgICAgICBpbmRleCA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgZGF0YSBpbiB0aGUgYnVmZmVyLCBhcyBhIHR5cGVkIGFycmF5XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAbWVtYmVyIHtBcnJheUJ1ZmZlcnwgU2hhcmVkQXJyYXlCdWZmZXJ8QXJyYXlCdWZmZXJWaWV3fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGEgfHwgbmV3IEZsb2F0MzJBcnJheSgxKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBIG1hcCBvZiByZW5kZXJlciBJRHMgdG8gd2ViZ2wgYnVmZmVyXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqIEBtZW1iZXIge29iamVjdDxudW1iZXIsIEdMQnVmZmVyPn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLl9nbEJ1ZmZlcnMgPSB7fTtcclxuICAgICAgICB0aGlzLl91cGRhdGVJRCA9IDA7XHJcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xyXG4gICAgICAgIHRoaXMuc3RhdGljID0gX3N0YXRpYztcclxuICAgICAgICB0aGlzLmlkID0gQnVmZmVyLlVJRCsrO1xyXG4gICAgICAgIHRoaXMuZGlzcG9zZVJ1bm5lciA9IG5ldyBSdW5uZXJfMS5SdW5uZXIoJ2Rpc3Bvc2VCdWZmZXInLCAyKTtcclxuICAgICAgICAvLyB0aGlzLmRpc3Bvc2VSdW5uZXIgPSBuZXcgUnVubmVyKCdkaXNwb3NlQnVmZmVyJywgMik7XHJcbiAgICB9XHJcbiAgICAvLyBUT0RPIGNvdWxkIGV4cGxvcmUgZmxhZ2dpbmcgb25seSBhIHBhcnRpYWwgdXBsb2FkP1xyXG4gICAgLyoqXHJcbiAgICAgKiBmbGFncyB0aGlzIGJ1ZmZlciBhcyByZXF1aXJpbmcgYW4gdXBsb2FkIHRvIHRoZSBHUFVcclxuICAgICAqL1xyXG4gICAgdXBkYXRlKGRhdGEpIHtcclxuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhIHx8IHRoaXMuZGF0YTtcclxuICAgICAgICB0aGlzLl91cGRhdGVJRCsrO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBkaXNwb3NlcyBXZWJHTCByZXNvdXJjZXMgdGhhdCBhcmUgY29ubmVjdGVkIHRvIHRoaXMgZ2VvbWV0cnlcclxuICAgICAqL1xyXG4gICAgZGlzcG9zZSgpIHtcclxuICAgICAgICB0aGlzLmRpc3Bvc2VSdW5uZXIucnVuKHRoaXMsIGZhbHNlKTtcclxuICAgICAgICAvLyB0aGlzLmRpc3Bvc2VSdW5uZXIucnVuKHRoaXMsIGZhbHNlKTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogRGVzdHJveXMgdGhlIGJ1ZmZlclxyXG4gICAgICovXHJcbiAgICBkZXN0cm95KCkge1xyXG4gICAgICAgIHRoaXMuZGlzcG9zZSgpO1xyXG4gICAgICAgIHRoaXMuZGF0YSA9IG51bGw7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIEhlbHBlciBmdW5jdGlvbiB0aGF0IGNyZWF0ZXMgYSBidWZmZXIgYmFzZWQgb24gYW4gYXJyYXkgb3IgVHlwZWRBcnJheVxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBwYXJhbSB7QXJyYXlCdWZmZXJWaWV3IHwgbnVtYmVyW119IGRhdGEgdGhlIFR5cGVkQXJyYXkgdGhhdCB0aGUgYnVmZmVyIHdpbGwgc3RvcmUuIElmIHRoaXMgaXMgYSByZWd1bGFyIEFycmF5IGl0IHdpbGwgYmUgY29udmVydGVkIHRvIGEgRmxvYXQzMkFycmF5LlxyXG4gICAgICogQHJldHVybiB7UElYSS5CdWZmZXJ9IEEgbmV3IEJ1ZmZlciBiYXNlZCBvbiB0aGUgZGF0YSBwcm92aWRlZC5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGZyb20oZGF0YSkge1xyXG4gICAgICAgIGlmIChkYXRhIGluc3RhbmNlb2YgQXJyYXkpIHtcclxuICAgICAgICAgICAgZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoZGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgQnVmZmVyKGRhdGEpO1xyXG4gICAgfVxyXG4gICAgO1xyXG59XHJcbkJ1ZmZlci5VSUQgPSAwO1xyXG5leHBvcnRzLkJ1ZmZlciA9IEJ1ZmZlcjtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgUmVzb3VyY2VfMSA9IHJlcXVpcmUoXCIuL1Jlc291cmNlXCIpO1xyXG5jbGFzcyBCdWZmZXJSZXNvdXJjZSBleHRlbmRzIFJlc291cmNlXzEuUmVzb3VyY2Uge1xyXG4gICAgY29uc3RydWN0b3Ioc291cmNlLCBvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIHJlZiA9IG9wdGlvbnMgfHwge307XHJcbiAgICAgICAgdmFyIHdpZHRoID0gcmVmLndpZHRoO1xyXG4gICAgICAgIHZhciBoZWlnaHQgPSByZWYuaGVpZ2h0O1xyXG4gICAgICAgIGlmICghd2lkdGggfHwgIWhlaWdodCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0J1ZmZlclJlc291cmNlIHdpZHRoIG9yIGhlaWdodCBpbnZhbGlkJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN1cGVyKHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNvdXJjZSBhcnJheVxyXG4gICAgICAgICAqIENhbm5vdCBiZSBDbGFtcGVkVWludDhBcnJheSBiZWNhdXNlIGl0IGNhbnQgYmUgdXBsb2FkZWQgdG8gV2ViR0xcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBtZW1iZXIge0Zsb2F0MzJBcnJheXxVaW50OEFycmF5fFVpbnQzMkFycmF5fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuZGF0YSA9IHNvdXJjZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVXBsb2FkIHRoZSB0ZXh0dXJlIHRvIHRoZSBHUFUuXHJcbiAgICAgKiBAcGFyYW0ge1BJWEkuUmVuZGVyZXJ9IHJlbmRlcmVyIFVwbG9hZCB0byB0aGUgcmVuZGVyZXJcclxuICAgICAqIEBwYXJhbSB7UElYSS5CYXNlVGV4dHVyZX0gYmFzZVRleHR1cmUgUmVmZXJlbmNlIHRvIHBhcmVudCB0ZXh0dXJlXHJcbiAgICAgKiBAcGFyYW0ge1BJWEkuR0xUZXh0dXJlfSBnbFRleHR1cmUgZ2xUZXh0dXJlXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpcyBzdWNjZXNzXHJcbiAgICAgKi9cclxuICAgIHVwbG9hZChyZW5kZXJlciwgYmFzZVRleHR1cmUsIGdsVGV4dHVyZSkge1xyXG4gICAgICAgIHZhciBnbCA9IHJlbmRlcmVyLmdsO1xyXG4gICAgICAgIGdsLnBpeGVsU3RvcmVpKGdsLlVOUEFDS19QUkVNVUxUSVBMWV9BTFBIQV9XRUJHTCwgYmFzZVRleHR1cmUucHJlbXVsdGlwbHlBbHBoYSk7XHJcbiAgICAgICAgaWYgKGdsVGV4dHVyZS53aWR0aCA9PT0gYmFzZVRleHR1cmUud2lkdGggJiYgZ2xUZXh0dXJlLmhlaWdodCA9PT0gYmFzZVRleHR1cmUuaGVpZ2h0KSB7XHJcbiAgICAgICAgICAgIGdsLnRleFN1YkltYWdlMkQoYmFzZVRleHR1cmUudGFyZ2V0LCAwLCAwLCAwLCBiYXNlVGV4dHVyZS53aWR0aCwgYmFzZVRleHR1cmUuaGVpZ2h0LCBiYXNlVGV4dHVyZS5mb3JtYXQsIGJhc2VUZXh0dXJlLnR5cGUsIHRoaXMuZGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBnbFRleHR1cmUud2lkdGggPSBiYXNlVGV4dHVyZS53aWR0aDtcclxuICAgICAgICAgICAgZ2xUZXh0dXJlLmhlaWdodCA9IGJhc2VUZXh0dXJlLmhlaWdodDtcclxuICAgICAgICAgICAgdmFyIGludGVybmFsRm9ybWF0ID0gYmFzZVRleHR1cmUuZm9ybWF0O1xyXG4gICAgICAgICAgICAvLyBndWVzcyBzaXplZCBmb3JtYXQgYnkgdHlwZSBhbmQgZm9ybWF0XHJcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9XZWJHTFJlbmRlcmluZ0NvbnRleHQvdGV4SW1hZ2UyRFxyXG4gICAgICAgICAgICBpZiAocmVuZGVyZXIuY29udGV4dC53ZWJHTFZlcnNpb24gPT09IDJcclxuICAgICAgICAgICAgICAgICYmIGJhc2VUZXh0dXJlLnR5cGUgPT09IHJlbmRlcmVyLmdsLkZMT0FUXHJcbiAgICAgICAgICAgICAgICAmJiBiYXNlVGV4dHVyZS5mb3JtYXQgPT09IHJlbmRlcmVyLmdsLlJHQkEpIHtcclxuICAgICAgICAgICAgICAgIGludGVybmFsRm9ybWF0ID0gcmVuZGVyZXIuZ2wuUkdCQTMyRjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBnbC50ZXhJbWFnZTJEKGJhc2VUZXh0dXJlLnRhcmdldCwgMCwgaW50ZXJuYWxGb3JtYXQsIGJhc2VUZXh0dXJlLndpZHRoLCBiYXNlVGV4dHVyZS5oZWlnaHQsIDAsIGJhc2VUZXh0dXJlLmZvcm1hdCwgYmFzZVRleHR1cmUudHlwZSwgdGhpcy5kYXRhKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIERlc3Ryb3kgYW5kIGRvbid0IHVzZSBhZnRlciB0aGlzXHJcbiAgICAgKiBAb3ZlcnJpZGVcclxuICAgICAqL1xyXG4gICAgZGlzcG9zZSgpIHtcclxuICAgICAgICB0aGlzLmRhdGEgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBVc2VkIHRvIGF1dG8tZGV0ZWN0IHRoZSB0eXBlIG9mIHJlc291cmNlLlxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBwYXJhbSB7Kn0gc291cmNlIC0gVGhlIHNvdXJjZSBvYmplY3RcclxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IGB0cnVlYCBpZiA8Y2FudmFzPlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgdGVzdChzb3VyY2UpIHtcclxuICAgICAgICByZXR1cm4gc291cmNlIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5XHJcbiAgICAgICAgICAgIHx8IHNvdXJjZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXlcclxuICAgICAgICAgICAgfHwgc291cmNlIGluc3RhbmNlb2YgVWludDMyQXJyYXk7XHJcbiAgICB9XHJcbiAgICA7XHJcbn1cclxuZXhwb3J0cy5CdWZmZXJSZXNvdXJjZSA9IEJ1ZmZlclJlc291cmNlO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jbGFzcyBDYWNoZVNldHRpbmdzIHtcclxuICAgIHN0YXRpYyBjbGVhclRleHR1cmVDYWNoZSgpIHtcclxuICAgICAgICB2YXIga2V5O1xyXG4gICAgICAgIGZvciAoa2V5IGluIENhY2hlU2V0dGluZ3MuVGV4dHVyZUNhY2hlKSB7XHJcbiAgICAgICAgICAgIGRlbGV0ZSBDYWNoZVNldHRpbmdzLlRleHR1cmVDYWNoZVtrZXldO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGtleSBpbiBDYWNoZVNldHRpbmdzLkJhc2VUZXh0dXJlQ2FjaGUpIHtcclxuICAgICAgICAgICAgZGVsZXRlIENhY2hlU2V0dGluZ3MuQmFzZVRleHR1cmVDYWNoZVtrZXldO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHN0YXRpYyBkZXN0cm95VGV4dHVyZUNhY2hlKCkge1xyXG4gICAgICAgIHZhciBrZXk7XHJcbiAgICAgICAgZm9yIChrZXkgaW4gQ2FjaGVTZXR0aW5ncy5UZXh0dXJlQ2FjaGUpIHtcclxuICAgICAgICAgICAgQ2FjaGVTZXR0aW5ncy5UZXh0dXJlQ2FjaGVba2V5XS5kZXN0cm95KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAoa2V5IGluIENhY2hlU2V0dGluZ3MuQmFzZVRleHR1cmVDYWNoZSkge1xyXG4gICAgICAgICAgICBDYWNoZVNldHRpbmdzLkJhc2VUZXh0dXJlQ2FjaGVba2V5XS5kZXN0cm95KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbkNhY2hlU2V0dGluZ3MuUHJvZ3JhbUNhY2hlID0ge307XHJcbkNhY2hlU2V0dGluZ3MubmFtZUNhY2hlID0ge307XHJcbkNhY2hlU2V0dGluZ3MucHJvZ3JhbUNhY2hlID0ge307XHJcbkNhY2hlU2V0dGluZ3MuVGV4dHVyZUNhY2hlID0ge307XHJcbkNhY2hlU2V0dGluZ3MuQmFzZVRleHR1cmVDYWNoZSA9IHt9O1xyXG5DYWNoZVNldHRpbmdzLmRlZmF1bHRHcm91cENhY2hlID0ge307XHJcbmV4cG9ydHMuQ2FjaGVTZXR0aW5ncyA9IENhY2hlU2V0dGluZ3M7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IERpc3BsYXlTZXR0aW5nc18xID0gcmVxdWlyZShcIi4vRGlzcGxheVNldHRpbmdzXCIpO1xyXG5jbGFzcyBDYW52YXNSZW5kZXJUYXJnZXQge1xyXG4gICAgY29uc3RydWN0b3Iod2lkdGgsIGhlaWdodCwgcmVzb2x1dGlvbikge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogVGhlIENhbnZhcyBvYmplY3QgdGhhdCBiZWxvbmdzIHRvIHRoaXMgQ2FudmFzUmVuZGVyVGFyZ2V0LlxyXG4gICAgICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICAgICAqIEBtZW1iZXIge0hUTUxDYW52YXNFbGVtZW50fVxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5jYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBIENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCBvYmplY3QgcmVwcmVzZW50aW5nIGEgdHdvLWRpbWVuc2lvbmFsIHJlbmRlcmluZyBjb250ZXh0LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQG1lbWJlciB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuY29udGV4dCA9IHRoaXMuY2FudmFzLmdldENvbnRleHQoJzJkJyk7XHJcbiAgICAgICAgdGhpcy5yZXNvbHV0aW9uID0gcmVzb2x1dGlvbiB8fCBEaXNwbGF5U2V0dGluZ3NfMS5EaXNwbGF5U2V0dGluZ3MuUkVTT0xVVElPTjtcclxuICAgICAgICB0aGlzLnJlc2l6ZSh3aWR0aCwgaGVpZ2h0KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2xlYXJzIHRoZSBjYW52YXMgdGhhdCB3YXMgY3JlYXRlZCBieSB0aGUgQ2FudmFzUmVuZGVyVGFyZ2V0IGNsYXNzLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIGNsZWFyKCkge1xyXG4gICAgICAgIHRoaXMuY29udGV4dC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XHJcbiAgICAgICAgdGhpcy5jb250ZXh0LmNsZWFyUmVjdCgwLCAwLCB0aGlzLmNhbnZhcy53aWR0aCwgdGhpcy5jYW52YXMuaGVpZ2h0KTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogUmVzaXplcyB0aGUgY2FudmFzIHRvIHRoZSBzcGVjaWZpZWQgd2lkdGggYW5kIGhlaWdodC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd2lkdGggLSB0aGUgbmV3IHdpZHRoIG9mIHRoZSBjYW52YXNcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgLSB0aGUgbmV3IGhlaWdodCBvZiB0aGUgY2FudmFzXHJcbiAgICAgKi9cclxuICAgIHJlc2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICAgICAgdGhpcy5jYW52YXMud2lkdGggPSB3aWR0aCAqIHRoaXMucmVzb2x1dGlvbjtcclxuICAgICAgICB0aGlzLmNhbnZhcy5oZWlnaHQgPSBoZWlnaHQgKiB0aGlzLnJlc29sdXRpb247XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIERlc3Ryb3lzIHRoaXMgY2FudmFzLlxyXG4gICAgICpcclxuICAgICAqL1xyXG4gICAgZGVzdHJveSgpIHtcclxuICAgICAgICB0aGlzLmNvbnRleHQgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuY2FudmFzID0gbnVsbDtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIHdpZHRoIG9mIHRoZSBjYW52YXMgYnVmZmVyIGluIHBpeGVscy5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIGdldCB3aWR0aCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jYW52YXMud2lkdGg7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICBzZXQgd2lkdGgodmFsKSB7XHJcbiAgICAgICAgdGhpcy5jYW52YXMud2lkdGggPSB2YWw7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBoZWlnaHQgb2YgdGhlIGNhbnZhcyBidWZmZXIgaW4gcGl4ZWxzLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgZ2V0IGhlaWdodCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jYW52YXMuaGVpZ2h0O1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgc2V0IGhlaWdodCh2YWwpIHtcclxuICAgICAgICB0aGlzLmNhbnZhcy5oZWlnaHQgPSB2YWw7XHJcbiAgICB9XHJcbiAgICA7XHJcbn1cclxuZXhwb3J0cy5DYW52YXNSZW5kZXJUYXJnZXQgPSBDYW52YXNSZW5kZXJUYXJnZXQ7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IEJhc2VJbWFnZVJlc291cmNlXzEgPSByZXF1aXJlKFwiLi9CYXNlSW1hZ2VSZXNvdXJjZVwiKTtcclxuY2xhc3MgQ2FudmFzUmVzb3VyY2UgZXh0ZW5kcyBCYXNlSW1hZ2VSZXNvdXJjZV8xLkJhc2VJbWFnZVJlc291cmNlIHtcclxuICAgIGNvbnN0cnVjdG9yKHNvdXJjZSkge1xyXG4gICAgICAgIHN1cGVyKHNvdXJjZSk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgdGVzdChzb3VyY2UpIHtcclxuICAgICAgICByZXR1cm4gKHNvdXJjZSBpbnN0YW5jZW9mIEhUTUxDYW52YXNFbGVtZW50KTtcclxuICAgIH1cclxuICAgIDtcclxufVxyXG5leHBvcnRzLkNhbnZhc1Jlc291cmNlID0gQ2FudmFzUmVzb3VyY2U7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNsYXNzIENhbnZhc1NldHRpbmdzIHtcclxuICAgIC8qKlxyXG4qIFRyaW0gdHJhbnNwYXJlbnQgYm9yZGVycyBmcm9tIGEgY2FudmFzXHJcbipcclxuKiBAbWVtYmVyb2YgUElYSS51dGlsc1xyXG4qIEBmdW5jdGlvbiB0cmltQ2FudmFzXHJcbiogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudH0gY2FudmFzIC0gdGhlIGNhbnZhcyB0byB0cmltXHJcbiogQHJldHVybnMge29iamVjdH0gVHJpbSBkYXRhXHJcbiovXHJcbiAgICBzdGF0aWMgdHJpbUNhbnZhcyhjYW52YXMpIHtcclxuICAgICAgICAvLyBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9yZW15Lzc4NDUwOFxyXG4gICAgICAgIHZhciB3aWR0aCA9IGNhbnZhcy53aWR0aDtcclxuICAgICAgICB2YXIgaGVpZ2h0ID0gY2FudmFzLmhlaWdodDtcclxuICAgICAgICB2YXIgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xyXG4gICAgICAgIHZhciBpbWFnZURhdGEgPSBjb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcclxuICAgICAgICB2YXIgcGl4ZWxzID0gaW1hZ2VEYXRhLmRhdGE7XHJcbiAgICAgICAgdmFyIGxlbiA9IHBpeGVscy5sZW5ndGg7XHJcbiAgICAgICAgdmFyIGJvdW5kID0ge1xyXG4gICAgICAgICAgICB0b3A6IG51bGwsXHJcbiAgICAgICAgICAgIGxlZnQ6IG51bGwsXHJcbiAgICAgICAgICAgIHJpZ2h0OiBudWxsLFxyXG4gICAgICAgICAgICBib3R0b206IG51bGwsXHJcbiAgICAgICAgfTtcclxuICAgICAgICB2YXIgZGF0YSA9IG51bGw7XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgdmFyIHg7XHJcbiAgICAgICAgdmFyIHk7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XHJcbiAgICAgICAgICAgIGlmIChwaXhlbHNbaSArIDNdICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICB4ID0gKGkgLyA0KSAlIHdpZHRoO1xyXG4gICAgICAgICAgICAgICAgeSA9IH5+KChpIC8gNCkgLyB3aWR0aCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoYm91bmQudG9wID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYm91bmQudG9wID0geTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChib3VuZC5sZWZ0ID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYm91bmQubGVmdCA9IHg7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh4IDwgYm91bmQubGVmdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJvdW5kLmxlZnQgPSB4O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGJvdW5kLnJpZ2h0ID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYm91bmQucmlnaHQgPSB4ICsgMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGJvdW5kLnJpZ2h0IDwgeCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJvdW5kLnJpZ2h0ID0geCArIDE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoYm91bmQuYm90dG9tID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYm91bmQuYm90dG9tID0geTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGJvdW5kLmJvdHRvbSA8IHkpIHtcclxuICAgICAgICAgICAgICAgICAgICBib3VuZC5ib3R0b20gPSB5O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChib3VuZC50b3AgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgd2lkdGggPSBib3VuZC5yaWdodCAtIGJvdW5kLmxlZnQ7XHJcbiAgICAgICAgICAgIGhlaWdodCA9IGJvdW5kLmJvdHRvbSAtIGJvdW5kLnRvcCArIDE7XHJcbiAgICAgICAgICAgIGRhdGEgPSBjb250ZXh0LmdldEltYWdlRGF0YShib3VuZC5sZWZ0LCBib3VuZC50b3AsIHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBoZWlnaHQ6IGhlaWdodCxcclxuICAgICAgICAgICAgd2lkdGg6IHdpZHRoLFxyXG4gICAgICAgICAgICBkYXRhOiBkYXRhLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5DYW52YXNTZXR0aW5ncyA9IENhbnZhc1NldHRpbmdzO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBSZWN0YW5nbGVfMSA9IHJlcXVpcmUoXCIuL1JlY3RhbmdsZVwiKTtcclxuY29uc3QgU2hhcGVTZXR0aW5nc18xID0gcmVxdWlyZShcIi4vU2hhcGVTZXR0aW5nc1wiKTtcclxuY2xhc3MgQ2lyY2xlIHtcclxuICAgIGNvbnN0cnVjdG9yKHggPSAwLCB5ID0gMCwgcmFkaXVzID0gMCkge1xyXG4gICAgICAgIGlmICh4ID09PSB2b2lkIDApIHtcclxuICAgICAgICAgICAgeCA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh5ID09PSB2b2lkIDApIHtcclxuICAgICAgICAgICAgeSA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChyYWRpdXMgPT09IHZvaWQgMCkge1xyXG4gICAgICAgICAgICByYWRpdXMgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgICAgICogQGRlZmF1bHQgMFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMueCA9IHg7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICAgICAqIEBkZWZhdWx0IDBcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnkgPSB5O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAgICAgKiBAZGVmYXVsdCAwXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5yYWRpdXMgPSByYWRpdXM7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIHR5cGUgb2YgdGhlIG9iamVjdCwgbWFpbmx5IHVzZWQgdG8gYXZvaWQgYGluc3RhbmNlb2ZgIGNoZWNrc1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICAgICAqIEByZWFkT25seVxyXG4gICAgICAgICAqIEBkZWZhdWx0IFBJWEkuU0hBUEVTLkNJUkNcclxuICAgICAgICAgKiBAc2VlIFBJWEkuU0hBUEVTXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy50eXBlID0gU2hhcGVTZXR0aW5nc18xLlNoYXBlU2V0dGluZ3MuU0hBUEVTLkNJUkM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBjbG9uZSBvZiB0aGlzIENpcmNsZSBpbnN0YW5jZVxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4ge1BJWEkuQ2lyY2xlfSBhIGNvcHkgb2YgdGhlIENpcmNsZVxyXG4gICAgICovXHJcbiAgICBjbG9uZSgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IENpcmNsZSh0aGlzLngsIHRoaXMueSwgdGhpcy5yYWRpdXMpO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgeCBhbmQgeSBjb29yZGluYXRlcyBnaXZlbiBhcmUgY29udGFpbmVkIHdpdGhpbiB0aGlzIGNpcmNsZVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQgdG8gdGVzdFxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgLSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBwb2ludCB0byB0ZXN0XHJcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSB4L3kgY29vcmRpbmF0ZXMgYXJlIHdpdGhpbiB0aGlzIENpcmNsZVxyXG4gICAgICovXHJcbiAgICBjb250YWlucyh4LCB5KSB7XHJcbiAgICAgICAgaWYgKHRoaXMucmFkaXVzIDw9IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcjIgPSB0aGlzLnJhZGl1cyAqIHRoaXMucmFkaXVzO1xyXG4gICAgICAgIHZhciBkeCA9ICh0aGlzLnggLSB4KTtcclxuICAgICAgICB2YXIgZHkgPSAodGhpcy55IC0geSk7XHJcbiAgICAgICAgZHggKj0gZHg7XHJcbiAgICAgICAgZHkgKj0gZHk7XHJcbiAgICAgICAgcmV0dXJuIChkeCArIGR5IDw9IHIyKTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgKiBSZXR1cm5zIHRoZSBmcmFtaW5nIHJlY3RhbmdsZSBvZiB0aGUgY2lyY2xlIGFzIGEgUmVjdGFuZ2xlIG9iamVjdFxyXG4gICAgKlxyXG4gICAgKiBAcmV0dXJuIHtQSVhJLlJlY3RhbmdsZX0gdGhlIGZyYW1pbmcgcmVjdGFuZ2xlXHJcbiAgICAqL1xyXG4gICAgZ2V0Qm91bmRzKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgUmVjdGFuZ2xlXzEuUmVjdGFuZ2xlKHRoaXMueCAtIHRoaXMucmFkaXVzLCB0aGlzLnkgLSB0aGlzLnJhZGl1cywgdGhpcy5yYWRpdXMgKiAyLCB0aGlzLnJhZGl1cyAqIDIpO1xyXG4gICAgfVxyXG4gICAgO1xyXG59XHJcbmV4cG9ydHMuQ2lyY2xlID0gQ2lyY2xlO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jbGFzcyBDbGVhblVwU2V0dGluZ3Mge1xyXG59XHJcbkNsZWFuVXBTZXR0aW5ncy5kZWZhdWx0RGVzdHJveU9wdGlvbnMgPSB7XHJcbiAgICB0ZXh0dXJlOiB0cnVlLFxyXG4gICAgY2hpbGRyZW46IGZhbHNlLFxyXG4gICAgYmFzZVRleHR1cmU6IHRydWUsXHJcbn07XHJcbmV4cG9ydHMuQ2xlYW5VcFNldHRpbmdzID0gQ2xlYW5VcFNldHRpbmdzO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBGaWx0ZXJfMSA9IHJlcXVpcmUoXCIuL0ZpbHRlclwiKTtcclxuY29uc3Qgc2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL3NldHRpbmdzXCIpO1xyXG5jbGFzcyBDb2xvck1hdHJpeEZpbHRlciBleHRlbmRzIEZpbHRlcl8xLkZpbHRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB2YXIgdW5pZm9ybXMgPSB7XHJcbiAgICAgICAgICAgIG06IG5ldyBGbG9hdDMyQXJyYXkoWzEsIDAsIDAsIDAsIDAsXHJcbiAgICAgICAgICAgICAgICAwLCAxLCAwLCAwLCAwLFxyXG4gICAgICAgICAgICAgICAgMCwgMCwgMSwgMCwgMCxcclxuICAgICAgICAgICAgICAgIDAsIDAsIDAsIDEsIDBdKSxcclxuICAgICAgICAgICAgdUFscGhhOiAxLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgc3VwZXIoc2V0dGluZ3NfMS5zZXR0aW5ncy5kZWZhdWx0RmlsdGVyVmVydGV4LCBDb2xvck1hdHJpeEZpbHRlci5mcmFnbWVudCQ0LCB1bmlmb3Jtcyk7XHJcbiAgICAgICAgdGhpcy5hbHBoYSA9IDE7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRyYW5zZm9ybXMgY3VycmVudCBtYXRyaXggYW5kIHNldCB0aGUgbmV3IG9uZVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyW119IG1hdHJpeCAtIDV4NCBtYXRyaXhcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gbXVsdGlwbHkgLSBpZiB0cnVlLCBjdXJyZW50IG1hdHJpeCBhbmQgbWF0cml4IGFyZSBtdWx0aXBsaWVkLiBJZiBmYWxzZSxcclxuICAgICAqICBqdXN0IHNldCB0aGUgY3VycmVudCBtYXRyaXggd2l0aCBAcGFyYW0gbWF0cml4XHJcbiAgICAgKi9cclxuICAgIF9sb2FkTWF0cml4KG1hdHJpeCwgbXVsdGlwbHkpIHtcclxuICAgICAgICBpZiAobXVsdGlwbHkgPT09IHZvaWQgMCkge1xyXG4gICAgICAgICAgICBtdWx0aXBseSA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbmV3TWF0cml4ID0gbWF0cml4O1xyXG4gICAgICAgIGlmIChtdWx0aXBseSkge1xyXG4gICAgICAgICAgICB0aGlzLl9tdWx0aXBseShuZXdNYXRyaXgsIHRoaXMudW5pZm9ybXMubSwgbWF0cml4KTtcclxuICAgICAgICAgICAgbmV3TWF0cml4ID0gdGhpcy5fY29sb3JNYXRyaXgobmV3TWF0cml4KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gc2V0IHRoZSBuZXcgbWF0cml4XHJcbiAgICAgICAgdGhpcy51bmlmb3Jtcy5tID0gbmV3TWF0cml4O1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBNdWx0aXBsaWVzIHR3byBtYXQ1J3NcclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJbXX0gb3V0IC0gNXg0IG1hdHJpeCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxyXG4gICAgICogQHBhcmFtIHtudW1iZXJbXX0gYSAtIDV4NCBtYXRyaXggdGhlIGZpcnN0IG9wZXJhbmRcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyW119IGIgLSA1eDQgbWF0cml4IHRoZSBzZWNvbmQgb3BlcmFuZFxyXG4gICAgICogQHJldHVybnMge251bWJlcltdfSA1eDQgbWF0cml4XHJcbiAgICAgKi9cclxuICAgIF9tdWx0aXBseShvdXQsIGEsIGIpIHtcclxuICAgICAgICAvLyBSZWQgQ2hhbm5lbFxyXG4gICAgICAgIG91dFswXSA9IChhWzBdICogYlswXSkgKyAoYVsxXSAqIGJbNV0pICsgKGFbMl0gKiBiWzEwXSkgKyAoYVszXSAqIGJbMTVdKTtcclxuICAgICAgICBvdXRbMV0gPSAoYVswXSAqIGJbMV0pICsgKGFbMV0gKiBiWzZdKSArIChhWzJdICogYlsxMV0pICsgKGFbM10gKiBiWzE2XSk7XHJcbiAgICAgICAgb3V0WzJdID0gKGFbMF0gKiBiWzJdKSArIChhWzFdICogYls3XSkgKyAoYVsyXSAqIGJbMTJdKSArIChhWzNdICogYlsxN10pO1xyXG4gICAgICAgIG91dFszXSA9IChhWzBdICogYlszXSkgKyAoYVsxXSAqIGJbOF0pICsgKGFbMl0gKiBiWzEzXSkgKyAoYVszXSAqIGJbMThdKTtcclxuICAgICAgICBvdXRbNF0gPSAoYVswXSAqIGJbNF0pICsgKGFbMV0gKiBiWzldKSArIChhWzJdICogYlsxNF0pICsgKGFbM10gKiBiWzE5XSkgKyBhWzRdO1xyXG4gICAgICAgIC8vIEdyZWVuIENoYW5uZWxcclxuICAgICAgICBvdXRbNV0gPSAoYVs1XSAqIGJbMF0pICsgKGFbNl0gKiBiWzVdKSArIChhWzddICogYlsxMF0pICsgKGFbOF0gKiBiWzE1XSk7XHJcbiAgICAgICAgb3V0WzZdID0gKGFbNV0gKiBiWzFdKSArIChhWzZdICogYls2XSkgKyAoYVs3XSAqIGJbMTFdKSArIChhWzhdICogYlsxNl0pO1xyXG4gICAgICAgIG91dFs3XSA9IChhWzVdICogYlsyXSkgKyAoYVs2XSAqIGJbN10pICsgKGFbN10gKiBiWzEyXSkgKyAoYVs4XSAqIGJbMTddKTtcclxuICAgICAgICBvdXRbOF0gPSAoYVs1XSAqIGJbM10pICsgKGFbNl0gKiBiWzhdKSArIChhWzddICogYlsxM10pICsgKGFbOF0gKiBiWzE4XSk7XHJcbiAgICAgICAgb3V0WzldID0gKGFbNV0gKiBiWzRdKSArIChhWzZdICogYls5XSkgKyAoYVs3XSAqIGJbMTRdKSArIChhWzhdICogYlsxOV0pICsgYVs5XTtcclxuICAgICAgICAvLyBCbHVlIENoYW5uZWxcclxuICAgICAgICBvdXRbMTBdID0gKGFbMTBdICogYlswXSkgKyAoYVsxMV0gKiBiWzVdKSArIChhWzEyXSAqIGJbMTBdKSArIChhWzEzXSAqIGJbMTVdKTtcclxuICAgICAgICBvdXRbMTFdID0gKGFbMTBdICogYlsxXSkgKyAoYVsxMV0gKiBiWzZdKSArIChhWzEyXSAqIGJbMTFdKSArIChhWzEzXSAqIGJbMTZdKTtcclxuICAgICAgICBvdXRbMTJdID0gKGFbMTBdICogYlsyXSkgKyAoYVsxMV0gKiBiWzddKSArIChhWzEyXSAqIGJbMTJdKSArIChhWzEzXSAqIGJbMTddKTtcclxuICAgICAgICBvdXRbMTNdID0gKGFbMTBdICogYlszXSkgKyAoYVsxMV0gKiBiWzhdKSArIChhWzEyXSAqIGJbMTNdKSArIChhWzEzXSAqIGJbMThdKTtcclxuICAgICAgICBvdXRbMTRdID0gKGFbMTBdICogYls0XSkgKyAoYVsxMV0gKiBiWzldKSArIChhWzEyXSAqIGJbMTRdKSArIChhWzEzXSAqIGJbMTldKSArIGFbMTRdO1xyXG4gICAgICAgIC8vIEFscGhhIENoYW5uZWxcclxuICAgICAgICBvdXRbMTVdID0gKGFbMTVdICogYlswXSkgKyAoYVsxNl0gKiBiWzVdKSArIChhWzE3XSAqIGJbMTBdKSArIChhWzE4XSAqIGJbMTVdKTtcclxuICAgICAgICBvdXRbMTZdID0gKGFbMTVdICogYlsxXSkgKyAoYVsxNl0gKiBiWzZdKSArIChhWzE3XSAqIGJbMTFdKSArIChhWzE4XSAqIGJbMTZdKTtcclxuICAgICAgICBvdXRbMTddID0gKGFbMTVdICogYlsyXSkgKyAoYVsxNl0gKiBiWzddKSArIChhWzE3XSAqIGJbMTJdKSArIChhWzE4XSAqIGJbMTddKTtcclxuICAgICAgICBvdXRbMThdID0gKGFbMTVdICogYlszXSkgKyAoYVsxNl0gKiBiWzhdKSArIChhWzE3XSAqIGJbMTNdKSArIChhWzE4XSAqIGJbMThdKTtcclxuICAgICAgICBvdXRbMTldID0gKGFbMTVdICogYls0XSkgKyAoYVsxNl0gKiBiWzldKSArIChhWzE3XSAqIGJbMTRdKSArIChhWzE4XSAqIGJbMTldKSArIGFbMTldO1xyXG4gICAgICAgIHJldHVybiBvdXQ7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZSBhIEZsb2F0MzIgQXJyYXkgYW5kIG5vcm1hbGl6ZSB0aGUgb2Zmc2V0IGNvbXBvbmVudCB0byAwLTFcclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJbXX0gbWF0cml4IC0gNXg0IG1hdHJpeFxyXG4gICAgICogQHJldHVybiB7bnVtYmVyW119IDV4NCBtYXRyaXggd2l0aCBhbGwgdmFsdWVzIGJldHdlZW4gMC0xXHJcbiAgICAgKi9cclxuICAgIF9jb2xvck1hdHJpeChtYXRyaXgpIHtcclxuICAgICAgICAvLyBDcmVhdGUgYSBGbG9hdDMyIEFycmF5IGFuZCBub3JtYWxpemUgdGhlIG9mZnNldCBjb21wb25lbnQgdG8gMC0xXHJcbiAgICAgICAgdmFyIG0gPSBuZXcgRmxvYXQzMkFycmF5KG1hdHJpeCk7XHJcbiAgICAgICAgbVs0XSAvPSAyNTU7XHJcbiAgICAgICAgbVs5XSAvPSAyNTU7XHJcbiAgICAgICAgbVsxNF0gLz0gMjU1O1xyXG4gICAgICAgIG1bMTldIC89IDI1NTtcclxuICAgICAgICByZXR1cm4gbTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQWRqdXN0cyBicmlnaHRuZXNzXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGIgLSB2YWx1ZSBvZiB0aGUgYnJpZ3RobmVzcyAoMC0xLCB3aGVyZSAwIGlzIGJsYWNrKVxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBtdWx0aXBseSAtIGlmIHRydWUsIGN1cnJlbnQgbWF0cml4IGFuZCBtYXRyaXggYXJlIG11bHRpcGxpZWQuIElmIGZhbHNlLFxyXG4gICAgICogIGp1c3Qgc2V0IHRoZSBjdXJyZW50IG1hdHJpeCB3aXRoIEBwYXJhbSBtYXRyaXhcclxuICAgICAqL1xyXG4gICAgYnJpZ2h0bmVzcyhiLCBtdWx0aXBseSkge1xyXG4gICAgICAgIHZhciBtYXRyaXggPSBbXHJcbiAgICAgICAgICAgIGIsIDAsIDAsIDAsIDAsXHJcbiAgICAgICAgICAgIDAsIGIsIDAsIDAsIDAsXHJcbiAgICAgICAgICAgIDAsIDAsIGIsIDAsIDAsXHJcbiAgICAgICAgICAgIDAsIDAsIDAsIDEsIDBcclxuICAgICAgICBdO1xyXG4gICAgICAgIHRoaXMuX2xvYWRNYXRyaXgobWF0cml4LCBtdWx0aXBseSk7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFNldCB0aGUgbWF0cmljZXMgaW4gZ3JleSBzY2FsZXNcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2NhbGUgLSB2YWx1ZSBvZiB0aGUgZ3JleSAoMC0xLCB3aGVyZSAwIGlzIGJsYWNrKVxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBtdWx0aXBseSAtIGlmIHRydWUsIGN1cnJlbnQgbWF0cml4IGFuZCBtYXRyaXggYXJlIG11bHRpcGxpZWQuIElmIGZhbHNlLFxyXG4gICAgICogIGp1c3Qgc2V0IHRoZSBjdXJyZW50IG1hdHJpeCB3aXRoIEBwYXJhbSBtYXRyaXhcclxuICAgICAqL1xyXG4gICAgZ3JleXNjYWxlKHNjYWxlLCBtdWx0aXBseSkge1xyXG4gICAgICAgIHZhciBtYXRyaXggPSBbXHJcbiAgICAgICAgICAgIHNjYWxlLCBzY2FsZSwgc2NhbGUsIDAsIDAsXHJcbiAgICAgICAgICAgIHNjYWxlLCBzY2FsZSwgc2NhbGUsIDAsIDAsXHJcbiAgICAgICAgICAgIHNjYWxlLCBzY2FsZSwgc2NhbGUsIDAsIDAsXHJcbiAgICAgICAgICAgIDAsIDAsIDAsIDEsIDBcclxuICAgICAgICBdO1xyXG4gICAgICAgIHRoaXMuX2xvYWRNYXRyaXgobWF0cml4LCBtdWx0aXBseSk7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFNldCB0aGUgYmxhY2sgYW5kIHdoaXRlIG1hdHJpY2UuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBtdWx0aXBseSAtIGlmIHRydWUsIGN1cnJlbnQgbWF0cml4IGFuZCBtYXRyaXggYXJlIG11bHRpcGxpZWQuIElmIGZhbHNlLFxyXG4gICAgICogIGp1c3Qgc2V0IHRoZSBjdXJyZW50IG1hdHJpeCB3aXRoIEBwYXJhbSBtYXRyaXhcclxuICAgICAqL1xyXG4gICAgYmxhY2tBbmRXaGl0ZShtdWx0aXBseSkge1xyXG4gICAgICAgIHZhciBtYXRyaXggPSBbXHJcbiAgICAgICAgICAgIDAuMywgMC42LCAwLjEsIDAsIDAsXHJcbiAgICAgICAgICAgIDAuMywgMC42LCAwLjEsIDAsIDAsXHJcbiAgICAgICAgICAgIDAuMywgMC42LCAwLjEsIDAsIDAsXHJcbiAgICAgICAgICAgIDAsIDAsIDAsIDEsIDBcclxuICAgICAgICBdO1xyXG4gICAgICAgIHRoaXMuX2xvYWRNYXRyaXgobWF0cml4LCBtdWx0aXBseSk7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFNldCB0aGUgaHVlIHByb3BlcnR5IG9mIHRoZSBjb2xvclxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByb3RhdGlvbiAtIGluIGRlZ3JlZXNcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gbXVsdGlwbHkgLSBpZiB0cnVlLCBjdXJyZW50IG1hdHJpeCBhbmQgbWF0cml4IGFyZSBtdWx0aXBsaWVkLiBJZiBmYWxzZSxcclxuICAgICAqICBqdXN0IHNldCB0aGUgY3VycmVudCBtYXRyaXggd2l0aCBAcGFyYW0gbWF0cml4XHJcbiAgICAgKi9cclxuICAgIGh1ZShyb3RhdGlvbiwgbXVsdGlwbHkpIHtcclxuICAgICAgICByb3RhdGlvbiA9IChyb3RhdGlvbiB8fCAwKSAvIDE4MCAqIE1hdGguUEk7XHJcbiAgICAgICAgdmFyIGNvc1IgPSBNYXRoLmNvcyhyb3RhdGlvbik7XHJcbiAgICAgICAgdmFyIHNpblIgPSBNYXRoLnNpbihyb3RhdGlvbik7XHJcbiAgICAgICAgdmFyIHNxcnQgPSBNYXRoLnNxcnQ7XHJcbiAgICAgICAgLyogYSBnb29kIGFwcHJveGltYXRpb24gZm9yIGh1ZSByb3RhdGlvblxyXG4gICAgICAgICAgICBUaGlzIG1hdHJpeCBpcyBmYXIgYmV0dGVyIHRoYW4gdGhlIHZlcnNpb25zIHdpdGggbWFnaWMgbHVtaW5hbmNlIGNvbnN0YW50c1xyXG4gICAgICAgICAgICBmb3JtZXJseSB1c2VkIGhlcmUsIGJ1dCBhbHNvIHVzZWQgaW4gdGhlIHN0YXJsaW5nIGZyYW1ld29yayAoZmxhc2gpIGFuZCBrbm93biBmcm9tIHRoaXNcclxuICAgICAgICAgICAgb2xkIHBhcnQgb2YgdGhlIGludGVybmV0OiBxdWFzaW1vbmRvLmNvbS9hcmNoaXZlcy8wMDA1NjUucGhwXHJcblxyXG4gICAgICAgICAgICBUaGlzIG5ldyBtYXRyaXggaXMgYmFzZWQgb24gcmdiIGN1YmUgcm90YXRpb24gaW4gc3BhY2UuIExvb2sgaGVyZSBmb3IgYSBtb3JlIGRlc2NyaXB0aXZlXHJcbiAgICAgICAgICAgIGltcGxlbWVudGF0aW9uIGFzIGEgc2hhZGVyIG5vdCBhIGdlbmVyYWwgbWF0cml4OlxyXG4gICAgICAgICAgICBodHRwczovL2dpdGh1Yi5jb20vZXZhbncvZ2xmeC5qcy9ibG9iLzU4ODQxYzIzOTE5YmQ1OTc4N2VmZmMwMzMzYTQ4OTdiNDM4MzU0MTIvc3JjL2ZpbHRlcnMvYWRqdXN0L2h1ZXNhdHVyYXRpb24uanNcclxuXHJcbiAgICAgICAgICAgIFRoaXMgaXMgdGhlIHNvdXJjZSBmb3IgdGhlIGNvZGU6XHJcbiAgICAgICAgICAgIHNlZSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzg1MDc4ODUvc2hpZnQtaHVlLW9mLWFuLXJnYi1jb2xvci84NTEwNzUxIzg1MTA3NTFcclxuICAgICAgICAgICAgKi9cclxuICAgICAgICB2YXIgdyA9IDEgLyAzO1xyXG4gICAgICAgIHZhciBzcXJXID0gc3FydCh3KTsgLy8gd2VpZ2h0IGlzXHJcbiAgICAgICAgdmFyIGEwMCA9IGNvc1IgKyAoKDEuMCAtIGNvc1IpICogdyk7XHJcbiAgICAgICAgdmFyIGEwMSA9ICh3ICogKDEuMCAtIGNvc1IpKSAtIChzcXJXICogc2luUik7XHJcbiAgICAgICAgdmFyIGEwMiA9ICh3ICogKDEuMCAtIGNvc1IpKSArIChzcXJXICogc2luUik7XHJcbiAgICAgICAgdmFyIGExMCA9ICh3ICogKDEuMCAtIGNvc1IpKSArIChzcXJXICogc2luUik7XHJcbiAgICAgICAgdmFyIGExMSA9IGNvc1IgKyAodyAqICgxLjAgLSBjb3NSKSk7XHJcbiAgICAgICAgdmFyIGExMiA9ICh3ICogKDEuMCAtIGNvc1IpKSAtIChzcXJXICogc2luUik7XHJcbiAgICAgICAgdmFyIGEyMCA9ICh3ICogKDEuMCAtIGNvc1IpKSAtIChzcXJXICogc2luUik7XHJcbiAgICAgICAgdmFyIGEyMSA9ICh3ICogKDEuMCAtIGNvc1IpKSArIChzcXJXICogc2luUik7XHJcbiAgICAgICAgdmFyIGEyMiA9IGNvc1IgKyAodyAqICgxLjAgLSBjb3NSKSk7XHJcbiAgICAgICAgdmFyIG1hdHJpeCA9IFtcclxuICAgICAgICAgICAgYTAwLCBhMDEsIGEwMiwgMCwgMCxcclxuICAgICAgICAgICAgYTEwLCBhMTEsIGExMiwgMCwgMCxcclxuICAgICAgICAgICAgYTIwLCBhMjEsIGEyMiwgMCwgMCxcclxuICAgICAgICAgICAgMCwgMCwgMCwgMSwgMFxyXG4gICAgICAgIF07XHJcbiAgICAgICAgdGhpcy5fbG9hZE1hdHJpeChtYXRyaXgsIG11bHRpcGx5KTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRoZSBjb250cmFzdCBtYXRyaXgsIGluY3JlYXNlIHRoZSBzZXBhcmF0aW9uIGJldHdlZW4gZGFyayBhbmQgYnJpZ2h0XHJcbiAgICAgKiBJbmNyZWFzZSBjb250cmFzdCA6IHNoYWRvd3MgZGFya2VyIGFuZCBoaWdobGlnaHRzIGJyaWdodGVyXHJcbiAgICAgKiBEZWNyZWFzZSBjb250cmFzdCA6IGJyaW5nIHRoZSBzaGFkb3dzIHVwIGFuZCB0aGUgaGlnaGxpZ2h0cyBkb3duXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGFtb3VudCAtIHZhbHVlIG9mIHRoZSBjb250cmFzdCAoMC0xKVxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBtdWx0aXBseSAtIGlmIHRydWUsIGN1cnJlbnQgbWF0cml4IGFuZCBtYXRyaXggYXJlIG11bHRpcGxpZWQuIElmIGZhbHNlLFxyXG4gICAgICogIGp1c3Qgc2V0IHRoZSBjdXJyZW50IG1hdHJpeCB3aXRoIEBwYXJhbSBtYXRyaXhcclxuICAgICAqL1xyXG4gICAgY29udHJhc3QoYW1vdW50LCBtdWx0aXBseSkge1xyXG4gICAgICAgIHZhciB2ID0gKGFtb3VudCB8fCAwKSArIDE7XHJcbiAgICAgICAgdmFyIG8gPSAtMC41ICogKHYgLSAxKTtcclxuICAgICAgICB2YXIgbWF0cml4ID0gW1xyXG4gICAgICAgICAgICB2LCAwLCAwLCAwLCBvLFxyXG4gICAgICAgICAgICAwLCB2LCAwLCAwLCBvLFxyXG4gICAgICAgICAgICAwLCAwLCB2LCAwLCBvLFxyXG4gICAgICAgICAgICAwLCAwLCAwLCAxLCAwXHJcbiAgICAgICAgXTtcclxuICAgICAgICB0aGlzLl9sb2FkTWF0cml4KG1hdHJpeCwgbXVsdGlwbHkpO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhlIHNhdHVyYXRpb24gbWF0cml4LCBpbmNyZWFzZSB0aGUgc2VwYXJhdGlvbiBiZXR3ZWVuIGNvbG9yc1xyXG4gICAgICogSW5jcmVhc2Ugc2F0dXJhdGlvbiA6IGluY3JlYXNlIGNvbnRyYXN0LCBicmlnaHRuZXNzLCBhbmQgc2hhcnBuZXNzXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGFtb3VudCAtIFRoZSBzYXR1cmF0aW9uIGFtb3VudCAoMC0xKVxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBtdWx0aXBseSAtIGlmIHRydWUsIGN1cnJlbnQgbWF0cml4IGFuZCBtYXRyaXggYXJlIG11bHRpcGxpZWQuIElmIGZhbHNlLFxyXG4gICAgICogIGp1c3Qgc2V0IHRoZSBjdXJyZW50IG1hdHJpeCB3aXRoIEBwYXJhbSBtYXRyaXhcclxuICAgICAqL1xyXG4gICAgc2F0dXJhdGUoYW1vdW50LCBtdWx0aXBseSA9IG51bGwpIHtcclxuICAgICAgICBpZiAoYW1vdW50ID09PSB2b2lkIDApIHtcclxuICAgICAgICAgICAgYW1vdW50ID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHggPSAoYW1vdW50ICogMiAvIDMpICsgMTtcclxuICAgICAgICB2YXIgeSA9ICgoeCAtIDEpICogLTAuNSk7XHJcbiAgICAgICAgdmFyIG1hdHJpeCA9IFtcclxuICAgICAgICAgICAgeCwgeSwgeSwgMCwgMCxcclxuICAgICAgICAgICAgeSwgeCwgeSwgMCwgMCxcclxuICAgICAgICAgICAgeSwgeSwgeCwgMCwgMCxcclxuICAgICAgICAgICAgMCwgMCwgMCwgMSwgMFxyXG4gICAgICAgIF07XHJcbiAgICAgICAgdGhpcy5fbG9hZE1hdHJpeChtYXRyaXgsIG11bHRpcGx5KTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogRGVzYXR1cmF0ZSBpbWFnZSAocmVtb3ZlIGNvbG9yKVxyXG4gICAgICpcclxuICAgICAqIENhbGwgdGhlIHNhdHVyYXRlIGZ1bmN0aW9uXHJcbiAgICAgKlxyXG4gICAgICovXHJcbiAgICBkZXNhdHVyYXRlKCkge1xyXG4gICAgICAgIHRoaXMuc2F0dXJhdGUoLTEpO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBOZWdhdGl2ZSBpbWFnZSAoaW52ZXJzZSBvZiBjbGFzc2ljIHJnYiBtYXRyaXgpXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBtdWx0aXBseSAtIGlmIHRydWUsIGN1cnJlbnQgbWF0cml4IGFuZCBtYXRyaXggYXJlIG11bHRpcGxpZWQuIElmIGZhbHNlLFxyXG4gICAgICogIGp1c3Qgc2V0IHRoZSBjdXJyZW50IG1hdHJpeCB3aXRoIEBwYXJhbSBtYXRyaXhcclxuICAgICAqL1xyXG4gICAgbmVnYXRpdmUobXVsdGlwbHkpIHtcclxuICAgICAgICB2YXIgbWF0cml4ID0gW1xyXG4gICAgICAgICAgICAtMSwgMCwgMCwgMSwgMCxcclxuICAgICAgICAgICAgMCwgLTEsIDAsIDEsIDAsXHJcbiAgICAgICAgICAgIDAsIDAsIC0xLCAxLCAwLFxyXG4gICAgICAgICAgICAwLCAwLCAwLCAxLCAwXHJcbiAgICAgICAgXTtcclxuICAgICAgICB0aGlzLl9sb2FkTWF0cml4KG1hdHJpeCwgbXVsdGlwbHkpO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBTZXBpYSBpbWFnZVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gbXVsdGlwbHkgLSBpZiB0cnVlLCBjdXJyZW50IG1hdHJpeCBhbmQgbWF0cml4IGFyZSBtdWx0aXBsaWVkLiBJZiBmYWxzZSxcclxuICAgICAqICBqdXN0IHNldCB0aGUgY3VycmVudCBtYXRyaXggd2l0aCBAcGFyYW0gbWF0cml4XHJcbiAgICAgKi9cclxuICAgIHNlcGlhKG11bHRpcGx5KSB7XHJcbiAgICAgICAgdmFyIG1hdHJpeCA9IFtcclxuICAgICAgICAgICAgMC4zOTMsIDAuNzY4OTk5OSwgMC4xODg5OTk5OSwgMCwgMCxcclxuICAgICAgICAgICAgMC4zNDksIDAuNjg1OTk5OSwgMC4xNjc5OTk5OSwgMCwgMCxcclxuICAgICAgICAgICAgMC4yNzIsIDAuNTMzOTk5OSwgMC4xMzA5OTk5OSwgMCwgMCxcclxuICAgICAgICAgICAgMCwgMCwgMCwgMSwgMFxyXG4gICAgICAgIF07XHJcbiAgICAgICAgdGhpcy5fbG9hZE1hdHJpeChtYXRyaXgsIG11bHRpcGx5KTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQ29sb3IgbW90aW9uIHBpY3R1cmUgcHJvY2VzcyBpbnZlbnRlZCBpbiAxOTE2ICh0aGFua3MgRG9taW5pYyBTemFibGV3c2tpKVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gbXVsdGlwbHkgLSBpZiB0cnVlLCBjdXJyZW50IG1hdHJpeCBhbmQgbWF0cml4IGFyZSBtdWx0aXBsaWVkLiBJZiBmYWxzZSxcclxuICAgICAqICBqdXN0IHNldCB0aGUgY3VycmVudCBtYXRyaXggd2l0aCBAcGFyYW0gbWF0cml4XHJcbiAgICAgKi9cclxuICAgIHRlY2huaWNvbG9yKG11bHRpcGx5KSB7XHJcbiAgICAgICAgdmFyIG1hdHJpeCA9IFtcclxuICAgICAgICAgICAgMS45MTI1Mjc3ODkxNDU2MDgzLCAtMC44NTQ1MzQ0OTc2OTUxNjQ1LCAtMC4wOTE1NTUwODQ4Mjc1NTU4NSwgMCwgMTEuNzkzNjAzNDM0Mzc3MzM3LFxyXG4gICAgICAgICAgICAtMC4zMDg3ODMzMzg1OTI4MDk3LCAxLjc2NTg5MDg1NTU0NTg0MjgsIC0wLjEwNjAxNzQzMDc0NzIyMjQ1LCAwLCAtNzAuMzUyMDUxNjE0NjEzOTgsXHJcbiAgICAgICAgICAgIC0wLjIzMTEwMzM3NzU0ODYxNiwgLTAuNzUwMTg5OTE5NzQ0MDIxMiwgMS44NDc1OTc4MTYxMDgxODksIDAsIDMwLjk1MDk0MDg2OTQ5MTEzOCxcclxuICAgICAgICAgICAgMCwgMCwgMCwgMSwgMFxyXG4gICAgICAgIF07XHJcbiAgICAgICAgdGhpcy5fbG9hZE1hdHJpeChtYXRyaXgsIG11bHRpcGx5KTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogUG9sYXJvaWQgZmlsdGVyXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBtdWx0aXBseSAtIGlmIHRydWUsIGN1cnJlbnQgbWF0cml4IGFuZCBtYXRyaXggYXJlIG11bHRpcGxpZWQuIElmIGZhbHNlLFxyXG4gICAgICogIGp1c3Qgc2V0IHRoZSBjdXJyZW50IG1hdHJpeCB3aXRoIEBwYXJhbSBtYXRyaXhcclxuICAgICAqL1xyXG4gICAgcG9sYXJvaWQobXVsdGlwbHkpIHtcclxuICAgICAgICB2YXIgbWF0cml4ID0gW1xyXG4gICAgICAgICAgICAxLjQzOCwgLTAuMDYyLCAtMC4wNjIsIDAsIDAsXHJcbiAgICAgICAgICAgIC0wLjEyMiwgMS4zNzgsIC0wLjEyMiwgMCwgMCxcclxuICAgICAgICAgICAgLTAuMDE2LCAtMC4wMTYsIDEuNDgzLCAwLCAwLFxyXG4gICAgICAgICAgICAwLCAwLCAwLCAxLCAwXHJcbiAgICAgICAgXTtcclxuICAgICAgICB0aGlzLl9sb2FkTWF0cml4KG1hdHJpeCwgbXVsdGlwbHkpO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBGaWx0ZXIgd2hvIHRyYW5zZm9ybXMgOiBSZWQgLT4gQmx1ZSBhbmQgQmx1ZSAtPiBSZWRcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IG11bHRpcGx5IC0gaWYgdHJ1ZSwgY3VycmVudCBtYXRyaXggYW5kIG1hdHJpeCBhcmUgbXVsdGlwbGllZC4gSWYgZmFsc2UsXHJcbiAgICAgKiAganVzdCBzZXQgdGhlIGN1cnJlbnQgbWF0cml4IHdpdGggQHBhcmFtIG1hdHJpeFxyXG4gICAgICovXHJcbiAgICB0b0JHUihtdWx0aXBseSkge1xyXG4gICAgICAgIHZhciBtYXRyaXggPSBbXHJcbiAgICAgICAgICAgIDAsIDAsIDEsIDAsIDAsXHJcbiAgICAgICAgICAgIDAsIDEsIDAsIDAsIDAsXHJcbiAgICAgICAgICAgIDEsIDAsIDAsIDAsIDAsXHJcbiAgICAgICAgICAgIDAsIDAsIDAsIDEsIDBcclxuICAgICAgICBdO1xyXG4gICAgICAgIHRoaXMuX2xvYWRNYXRyaXgobWF0cml4LCBtdWx0aXBseSk7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIENvbG9yIHJldmVyc2FsIGZpbG0gaW50cm9kdWNlZCBieSBFYXN0bWFuIEtvZGFrIGluIDE5MzUuICh0aGFua3MgRG9taW5pYyBTemFibGV3c2tpKVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gbXVsdGlwbHkgLSBpZiB0cnVlLCBjdXJyZW50IG1hdHJpeCBhbmQgbWF0cml4IGFyZSBtdWx0aXBsaWVkLiBJZiBmYWxzZSxcclxuICAgICAqICBqdXN0IHNldCB0aGUgY3VycmVudCBtYXRyaXggd2l0aCBAcGFyYW0gbWF0cml4XHJcbiAgICAgKi9cclxuICAgIGtvZGFjaHJvbWUobXVsdGlwbHkpIHtcclxuICAgICAgICB2YXIgbWF0cml4ID0gW1xyXG4gICAgICAgICAgICAxLjEyODU1ODIzOTY1OTM1MjUsIC0wLjM5NjczODIyODM2MDEzNDgsIC0wLjAzOTkyNTU5MTcyOTIxNzkzLCAwLCA2My43Mjk1ODc2MjE5NjUwMixcclxuICAgICAgICAgICAgLTAuMTY0MDQzMzk5NjIyNDQ2MTYsIDEuMDgzNTI1MTU2NjI5MTMwNCwgLTAuMDU0OTg4MDUxMTU2MzMxMzIsIDAsIDI0LjczMjQwNzg5NjcwNjIwMyxcclxuICAgICAgICAgICAgLTAuMTY3ODYwMTA3MDYxNTU3NjMsIC0wLjU2MDM0MTYyNzc2OTUyNDgsIDEuNjAxNDg1MDc2MTk2NDk0MywgMCwgMzUuNjI5ODI4MDc0NjA5NDYsXHJcbiAgICAgICAgICAgIDAsIDAsIDAsIDEsIDBcclxuICAgICAgICBdO1xyXG4gICAgICAgIHRoaXMuX2xvYWRNYXRyaXgobWF0cml4LCBtdWx0aXBseSk7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIEJyb3duIGRlbGljaW91cyBicm93bmkgZmlsdGVyICh0aGFua3MgRG9taW5pYyBTemFibGV3c2tpKVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gbXVsdGlwbHkgLSBpZiB0cnVlLCBjdXJyZW50IG1hdHJpeCBhbmQgbWF0cml4IGFyZSBtdWx0aXBsaWVkLiBJZiBmYWxzZSxcclxuICAgICAqICBqdXN0IHNldCB0aGUgY3VycmVudCBtYXRyaXggd2l0aCBAcGFyYW0gbWF0cml4XHJcbiAgICAgKi9cclxuICAgIGJyb3duaShtdWx0aXBseSkge1xyXG4gICAgICAgIHZhciBtYXRyaXggPSBbXHJcbiAgICAgICAgICAgIDAuNTk5NzAyMzQ5ODE1OTcxNSwgMC4zNDU1MzI0MzA0ODM5MTI2MywgLTAuMjcwODI5ODY3NDUzODA0MiwgMCwgNDcuNDMxOTI4NTU2MDA4NzMsXHJcbiAgICAgICAgICAgIC0wLjAzNzcwMzI0OTgzNzc4MzE1NywgMC44NjA5NTc3NTg3OTkyNjQxLCAwLjE1MDU5NTUyMzg4NDU5OTEzLCAwLCAtMzYuOTY4NDE0OTgzMTkxMjcsXHJcbiAgICAgICAgICAgIDAuMjQxMTM2MzUxMjgxNTMzMzUsIC0wLjA3NDQxMDM3OTA4NDIyNDkyLCAwLjQ0OTcyMTgyMDY0ODc3MTUzLCAwLCAtNy41NjIwNzUyNzc1OTEyODMsXHJcbiAgICAgICAgICAgIDAsIDAsIDAsIDEsIDBcclxuICAgICAgICBdO1xyXG4gICAgICAgIHRoaXMuX2xvYWRNYXRyaXgobWF0cml4LCBtdWx0aXBseSk7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFZpbnRhZ2UgZmlsdGVyICh0aGFua3MgRG9taW5pYyBTemFibGV3c2tpKVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gbXVsdGlwbHkgLSBpZiB0cnVlLCBjdXJyZW50IG1hdHJpeCBhbmQgbWF0cml4IGFyZSBtdWx0aXBsaWVkLiBJZiBmYWxzZSxcclxuICAgICAqICBqdXN0IHNldCB0aGUgY3VycmVudCBtYXRyaXggd2l0aCBAcGFyYW0gbWF0cml4XHJcbiAgICAgKi9cclxuICAgIHZpbnRhZ2UobXVsdGlwbHkpIHtcclxuICAgICAgICB2YXIgbWF0cml4ID0gW1xyXG4gICAgICAgICAgICAwLjYyNzkzNDU2MzU2MDU5OTQsIDAuMzIwMjE4MzQyMDgxOTM2NywgLTAuMDM5NjU0MDgyMTEzMTI0NTMsIDAsIDkuNjUxMjg1ODM1Mjk0MTIzLFxyXG4gICAgICAgICAgICAwLjAyNTc4Mzk3NzA0ODA4ODY4LCAwLjY0NDExODg2NDQzNzQ3NzEsIDAuMDMyNTkxMjc2MTYxNDkyOTQsIDAsIDcuNDYyODI5MTc2NDcwNTkxLFxyXG4gICAgICAgICAgICAwLjA0NjYwNTU1NTY3ODI3MTksIC0wLjA4NTEyMzI5ODcyNDc4OTEsIDAuNTI0MTY0ODAxODcwMDQ2NSwgMCwgNS4xNTkxOTA1ODgyMzUyOTYsXHJcbiAgICAgICAgICAgIDAsIDAsIDAsIDEsIDBcclxuICAgICAgICBdO1xyXG4gICAgICAgIHRoaXMuX2xvYWRNYXRyaXgobWF0cml4LCBtdWx0aXBseSk7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFdlIGRvbid0IGtub3cgZXhhY3RseSB3aGF0IGl0IGRvZXMsIGtpbmQgb2YgZ3JhZGllbnQgbWFwLCBidXQgZnVubnkgdG8gcGxheSB3aXRoIVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkZXNhdHVyYXRpb24gLSBUb25lIHZhbHVlcy5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0b25lZCAtIFRvbmUgdmFsdWVzLlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGxpZ2h0Q29sb3IgLSBUb25lIHZhbHVlcywgZXhhbXBsZTogYDB4RkZFNTgwYFxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRhcmtDb2xvciAtIFRvbmUgdmFsdWVzLCBleGFtcGxlOiBgMHhGRkU1ODBgXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IG11bHRpcGx5IC0gaWYgdHJ1ZSwgY3VycmVudCBtYXRyaXggYW5kIG1hdHJpeCBhcmUgbXVsdGlwbGllZC4gSWYgZmFsc2UsXHJcbiAgICAgKiAganVzdCBzZXQgdGhlIGN1cnJlbnQgbWF0cml4IHdpdGggQHBhcmFtIG1hdHJpeFxyXG4gICAgICovXHJcbiAgICBjb2xvclRvbmUoZGVzYXR1cmF0aW9uLCB0b25lZCwgbGlnaHRDb2xvciwgZGFya0NvbG9yLCBtdWx0aXBseSkge1xyXG4gICAgICAgIGRlc2F0dXJhdGlvbiA9IGRlc2F0dXJhdGlvbiB8fCAwLjI7XHJcbiAgICAgICAgdG9uZWQgPSB0b25lZCB8fCAwLjE1O1xyXG4gICAgICAgIGxpZ2h0Q29sb3IgPSBsaWdodENvbG9yIHx8IDB4RkZFNTgwO1xyXG4gICAgICAgIGRhcmtDb2xvciA9IGRhcmtDb2xvciB8fCAweDMzODAwMDtcclxuICAgICAgICB2YXIgbFIgPSAoKGxpZ2h0Q29sb3IgPj4gMTYpICYgMHhGRikgLyAyNTU7XHJcbiAgICAgICAgdmFyIGxHID0gKChsaWdodENvbG9yID4+IDgpICYgMHhGRikgLyAyNTU7XHJcbiAgICAgICAgdmFyIGxCID0gKGxpZ2h0Q29sb3IgJiAweEZGKSAvIDI1NTtcclxuICAgICAgICB2YXIgZFIgPSAoKGRhcmtDb2xvciA+PiAxNikgJiAweEZGKSAvIDI1NTtcclxuICAgICAgICB2YXIgZEcgPSAoKGRhcmtDb2xvciA+PiA4KSAmIDB4RkYpIC8gMjU1O1xyXG4gICAgICAgIHZhciBkQiA9IChkYXJrQ29sb3IgJiAweEZGKSAvIDI1NTtcclxuICAgICAgICB2YXIgbWF0cml4ID0gW1xyXG4gICAgICAgICAgICAwLjMsIDAuNTksIDAuMTEsIDAsIDAsXHJcbiAgICAgICAgICAgIGxSLCBsRywgbEIsIGRlc2F0dXJhdGlvbiwgMCxcclxuICAgICAgICAgICAgZFIsIGRHLCBkQiwgdG9uZWQsIDAsXHJcbiAgICAgICAgICAgIGxSIC0gZFIsIGxHIC0gZEcsIGxCIC0gZEIsIDAsIDBcclxuICAgICAgICBdO1xyXG4gICAgICAgIHRoaXMuX2xvYWRNYXRyaXgobWF0cml4LCBtdWx0aXBseSk7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIE5pZ2h0IGVmZmVjdFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbnRlbnNpdHkgLSBUaGUgaW50ZW5zaXR5IG9mIHRoZSBuaWdodCBlZmZlY3QuXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IG11bHRpcGx5IC0gaWYgdHJ1ZSwgY3VycmVudCBtYXRyaXggYW5kIG1hdHJpeCBhcmUgbXVsdGlwbGllZC4gSWYgZmFsc2UsXHJcbiAgICAgKiAganVzdCBzZXQgdGhlIGN1cnJlbnQgbWF0cml4IHdpdGggQHBhcmFtIG1hdHJpeFxyXG4gICAgICovXHJcbiAgICBuaWdodChpbnRlbnNpdHksIG11bHRpcGx5KSB7XHJcbiAgICAgICAgaW50ZW5zaXR5ID0gaW50ZW5zaXR5IHx8IDAuMTtcclxuICAgICAgICB2YXIgbWF0cml4ID0gW1xyXG4gICAgICAgICAgICBpbnRlbnNpdHkgKiAoLTIuMCksIC1pbnRlbnNpdHksIDAsIDAsIDAsXHJcbiAgICAgICAgICAgIC1pbnRlbnNpdHksIDAsIGludGVuc2l0eSwgMCwgMCxcclxuICAgICAgICAgICAgMCwgaW50ZW5zaXR5LCBpbnRlbnNpdHkgKiAyLjAsIDAsIDAsXHJcbiAgICAgICAgICAgIDAsIDAsIDAsIDEsIDBcclxuICAgICAgICBdO1xyXG4gICAgICAgIHRoaXMuX2xvYWRNYXRyaXgobWF0cml4LCBtdWx0aXBseSk7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFByZWRhdG9yIGVmZmVjdFxyXG4gICAgICpcclxuICAgICAqIEVyYXNlIHRoZSBjdXJyZW50IG1hdHJpeCBieSBzZXR0aW5nIGEgbmV3IGluZGVwZW50IG9uZVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhbW91bnQgLSBob3cgbXVjaCB0aGUgcHJlZGF0b3IgZmVlbHMgaGlzIGZ1dHVyZSB2aWN0aW1cclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gbXVsdGlwbHkgLSBpZiB0cnVlLCBjdXJyZW50IG1hdHJpeCBhbmQgbWF0cml4IGFyZSBtdWx0aXBsaWVkLiBJZiBmYWxzZSxcclxuICAgICAqICBqdXN0IHNldCB0aGUgY3VycmVudCBtYXRyaXggd2l0aCBAcGFyYW0gbWF0cml4XHJcbiAgICAgKi9cclxuICAgIHByZWRhdG9yKGFtb3VudCwgbXVsdGlwbHkpIHtcclxuICAgICAgICB2YXIgbWF0cml4ID0gW1xyXG4gICAgICAgICAgICAvLyByb3cgMVxyXG4gICAgICAgICAgICAxMS4yMjQxMzA2MzA0OTMxNjQgKiBhbW91bnQsXHJcbiAgICAgICAgICAgIC00Ljc5NDQ4Njk5OTUxMTcxOSAqIGFtb3VudCxcclxuICAgICAgICAgICAgLTIuODc0NjExODU0NTUzMjIyNyAqIGFtb3VudCxcclxuICAgICAgICAgICAgMCAqIGFtb3VudCxcclxuICAgICAgICAgICAgMC40MDM0MjQzODIyMDk3Nzc4MyAqIGFtb3VudCxcclxuICAgICAgICAgICAgLy8gcm93IDJcclxuICAgICAgICAgICAgLTMuNjMzMDY5NzUzNjQ2ODUwNiAqIGFtb3VudCxcclxuICAgICAgICAgICAgOS4xOTMxNTcxOTYwNDQ5MjIgKiBhbW91bnQsXHJcbiAgICAgICAgICAgIC0yLjk1MTgxMDgzNjc5MTk5MiAqIGFtb3VudCxcclxuICAgICAgICAgICAgMCAqIGFtb3VudCxcclxuICAgICAgICAgICAgLTEuMzE2MTM1MDQ4ODY2MjcyICogYW1vdW50LFxyXG4gICAgICAgICAgICAvLyByb3cgM1xyXG4gICAgICAgICAgICAtMy4yMTg0MTk3OTAyNjc5NDQzICogYW1vdW50LFxyXG4gICAgICAgICAgICAtNC4yMzc1MDMwNTE3NTc4MTI1ICogYW1vdW50LFxyXG4gICAgICAgICAgICA3LjQ3NjQ0ODA1OTA4MjAzMSAqIGFtb3VudCxcclxuICAgICAgICAgICAgMCAqIGFtb3VudCxcclxuICAgICAgICAgICAgMC44MDQ0NDU5MjIzNzQ3MjUzICogYW1vdW50LFxyXG4gICAgICAgICAgICAvLyByb3cgNFxyXG4gICAgICAgICAgICAwLCAwLCAwLCAxLCAwXHJcbiAgICAgICAgXTtcclxuICAgICAgICB0aGlzLl9sb2FkTWF0cml4KG1hdHJpeCwgbXVsdGlwbHkpO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBMU0QgZWZmZWN0XHJcbiAgICAgKlxyXG4gICAgICogTXVsdGlwbHkgdGhlIGN1cnJlbnQgbWF0cml4XHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBtdWx0aXBseSAtIGlmIHRydWUsIGN1cnJlbnQgbWF0cml4IGFuZCBtYXRyaXggYXJlIG11bHRpcGxpZWQuIElmIGZhbHNlLFxyXG4gICAgICogIGp1c3Qgc2V0IHRoZSBjdXJyZW50IG1hdHJpeCB3aXRoIEBwYXJhbSBtYXRyaXhcclxuICAgICAqL1xyXG4gICAgbHNkKG11bHRpcGx5KSB7XHJcbiAgICAgICAgdmFyIG1hdHJpeCA9IFtcclxuICAgICAgICAgICAgMiwgLTAuNCwgMC41LCAwLCAwLFxyXG4gICAgICAgICAgICAtMC41LCAyLCAtMC40LCAwLCAwLFxyXG4gICAgICAgICAgICAtMC40LCAtMC41LCAzLCAwLCAwLFxyXG4gICAgICAgICAgICAwLCAwLCAwLCAxLCAwXHJcbiAgICAgICAgXTtcclxuICAgICAgICB0aGlzLl9sb2FkTWF0cml4KG1hdHJpeCwgbXVsdGlwbHkpO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBFcmFzZSB0aGUgY3VycmVudCBtYXRyaXggYnkgc2V0dGluZyB0aGUgZGVmYXVsdCBvbmVcclxuICAgICAqXHJcbiAgICAgKi9cclxuICAgIHJlc2V0KCkge1xyXG4gICAgICAgIHZhciBtYXRyaXggPSBbXHJcbiAgICAgICAgICAgIDEsIDAsIDAsIDAsIDAsXHJcbiAgICAgICAgICAgIDAsIDEsIDAsIDAsIDAsXHJcbiAgICAgICAgICAgIDAsIDAsIDEsIDAsIDAsXHJcbiAgICAgICAgICAgIDAsIDAsIDAsIDEsIDBcclxuICAgICAgICBdO1xyXG4gICAgICAgIHRoaXMuX2xvYWRNYXRyaXgobWF0cml4LCBmYWxzZSk7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBtYXRyaXggb2YgdGhlIGNvbG9yIG1hdHJpeCBmaWx0ZXJcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJbXX1cclxuICAgICAqIEBkZWZhdWx0IFsxLCAwLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAwLCAxLCAwXVxyXG4gICAgICovXHJcbiAgICBnZXQgbWF0cml4KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLm07XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICBzZXQgbWF0cml4KHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy51bmlmb3Jtcy5tID0gdmFsdWU7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBvcGFjaXR5IHZhbHVlIHRvIHVzZSB3aGVuIG1peGluZyB0aGUgb3JpZ2luYWwgYW5kIHJlc3VsdGFudCBjb2xvcnMuXHJcbiAgICAgKlxyXG4gICAgICogV2hlbiB0aGUgdmFsdWUgaXMgMCwgdGhlIG9yaWdpbmFsIGNvbG9yIGlzIHVzZWQgd2l0aG91dCBtb2RpZmljYXRpb24uXHJcbiAgICAgKiBXaGVuIHRoZSB2YWx1ZSBpcyAxLCB0aGUgcmVzdWx0IGNvbG9yIGlzIHVzZWQuXHJcbiAgICAgKiBXaGVuIGluIHRoZSByYW5nZSAoMCwgMSkgdGhlIGNvbG9yIGlzIGludGVycG9sYXRlZCBiZXR3ZWVuIHRoZSBvcmlnaW5hbCBhbmQgcmVzdWx0IGJ5IHRoaXMgYW1vdW50LlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAqIEBkZWZhdWx0IDFcclxuICAgICAqL1xyXG4gICAgZ2V0IGFscGhhKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnVuaWZvcm1zLnVBbHBoYTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIHNldCBhbHBoYSh2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMudW5pZm9ybXMudUFscGhhID0gdmFsdWU7XHJcbiAgICB9XHJcbiAgICA7XHJcbn1cclxuLyohXHJcbiogQHBpeGkvZmlsdGVyLWNvbG9yLW1hdHJpeCAtIHY1LjAuMC1yYy4zXHJcbiogQ29tcGlsZWQgV2VkLCAxMCBBcHIgMjAxOSAwMToyMToxNSBVVENcclxuKlxyXG4qIEBwaXhpL2ZpbHRlci1jb2xvci1tYXRyaXggaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxyXG4qIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2VcclxuKi9cclxuQ29sb3JNYXRyaXhGaWx0ZXIuZnJhZ21lbnQkNCA9IFwidmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XFxyXFxudW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXI7XFxyXFxudW5pZm9ybSBmbG9hdCBtWzIwXTtcXHJcXG51bmlmb3JtIGZsb2F0IHVBbHBoYTtcXHJcXG5cXHJcXG52b2lkIG1haW4odm9pZClcXHJcXG57XFxyXFxuICAgIHZlYzQgYyA9IHRleHR1cmUyRCh1U2FtcGxlciwgdlRleHR1cmVDb29yZCk7XFxyXFxuXFxyXFxuICAgIGlmICh1QWxwaGEgPT0gMC4wKSB7XFxyXFxuICAgICAgICBnbF9GcmFnQ29sb3IgPSBjO1xcclxcbiAgICAgICAgcmV0dXJuO1xcclxcbiAgICB9XFxyXFxuXFxyXFxuICAgIC8vIFVuLXByZW11bHRpcGx5IGFscGhhIGJlZm9yZSBhcHBseWluZyB0aGUgY29sb3IgbWF0cml4LiBTZWUgaXNzdWUgIzM1MzkuXFxyXFxuICAgIGlmIChjLmEgPiAwLjApIHtcXHJcXG4gICAgICBjLnJnYiAvPSBjLmE7XFxyXFxuICAgIH1cXHJcXG5cXHJcXG4gICAgdmVjNCByZXN1bHQ7XFxyXFxuXFxyXFxuICAgIHJlc3VsdC5yID0gKG1bMF0gKiBjLnIpO1xcclxcbiAgICAgICAgcmVzdWx0LnIgKz0gKG1bMV0gKiBjLmcpO1xcclxcbiAgICAgICAgcmVzdWx0LnIgKz0gKG1bMl0gKiBjLmIpO1xcclxcbiAgICAgICAgcmVzdWx0LnIgKz0gKG1bM10gKiBjLmEpO1xcclxcbiAgICAgICAgcmVzdWx0LnIgKz0gbVs0XTtcXHJcXG5cXHJcXG4gICAgcmVzdWx0LmcgPSAobVs1XSAqIGMucik7XFxyXFxuICAgICAgICByZXN1bHQuZyArPSAobVs2XSAqIGMuZyk7XFxyXFxuICAgICAgICByZXN1bHQuZyArPSAobVs3XSAqIGMuYik7XFxyXFxuICAgICAgICByZXN1bHQuZyArPSAobVs4XSAqIGMuYSk7XFxyXFxuICAgICAgICByZXN1bHQuZyArPSBtWzldO1xcclxcblxcclxcbiAgICByZXN1bHQuYiA9IChtWzEwXSAqIGMucik7XFxyXFxuICAgICAgIHJlc3VsdC5iICs9IChtWzExXSAqIGMuZyk7XFxyXFxuICAgICAgIHJlc3VsdC5iICs9IChtWzEyXSAqIGMuYik7XFxyXFxuICAgICAgIHJlc3VsdC5iICs9IChtWzEzXSAqIGMuYSk7XFxyXFxuICAgICAgIHJlc3VsdC5iICs9IG1bMTRdO1xcclxcblxcclxcbiAgICByZXN1bHQuYSA9IChtWzE1XSAqIGMucik7XFxyXFxuICAgICAgIHJlc3VsdC5hICs9IChtWzE2XSAqIGMuZyk7XFxyXFxuICAgICAgIHJlc3VsdC5hICs9IChtWzE3XSAqIGMuYik7XFxyXFxuICAgICAgIHJlc3VsdC5hICs9IChtWzE4XSAqIGMuYSk7XFxyXFxuICAgICAgIHJlc3VsdC5hICs9IG1bMTldO1xcclxcblxcclxcbiAgICB2ZWMzIHJnYiA9IG1peChjLnJnYiwgcmVzdWx0LnJnYiwgdUFscGhhKTtcXHJcXG5cXHJcXG4gICAgLy8gUHJlbXVsdGlwbHkgYWxwaGEgYWdhaW4uXFxyXFxuICAgIHJnYiAqPSByZXN1bHQuYTtcXHJcXG5cXHJcXG4gICAgZ2xfRnJhZ0NvbG9yID0gdmVjNChyZ2IsIHJlc3VsdC5hKTtcXHJcXG59XFxyXFxuXCI7XHJcbmV4cG9ydHMuQ29sb3JNYXRyaXhGaWx0ZXIgPSBDb2xvck1hdHJpeEZpbHRlcjtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgTWF0aFNldHRpbmdzXzEgPSByZXF1aXJlKFwiLi9NYXRoU2V0dGluZ3NcIik7XHJcbmNsYXNzIENvbG9yU2V0dGluZ3Mge1xyXG4gICAgc3RhdGljIHByZW11bHRpcGx5VGludCh0aW50LCBhbHBoYSkge1xyXG4gICAgICAgIGlmIChhbHBoYSA9PT0gMS4wKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAoYWxwaGEgKiAyNTUgPDwgMjQpICsgdGludDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGFscGhhID09PSAwLjApIHtcclxuICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBSID0gKCh0aW50ID4+IDE2KSAmIDB4RkYpO1xyXG4gICAgICAgIHZhciBHID0gKCh0aW50ID4+IDgpICYgMHhGRik7XHJcbiAgICAgICAgdmFyIEIgPSAodGludCAmIDB4RkYpO1xyXG4gICAgICAgIFIgPSAoKFIgKiBhbHBoYSkgKyAwLjUpIHwgMDtcclxuICAgICAgICBHID0gKChHICogYWxwaGEpICsgMC41KSB8IDA7XHJcbiAgICAgICAgQiA9ICgoQiAqIGFscGhhKSArIDAuNSkgfCAwO1xyXG4gICAgICAgIHJldHVybiAoYWxwaGEgKiAyNTUgPDwgMjQpICsgKFIgPDwgMTYpICsgKEcgPDwgOCkgKyBCO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIHByZW11bHRpcGx5VGludFRvUmdiYSh0aW50LCBhbHBoYSwgb3V0LCBwcmVtdWx0aXBseSkge1xyXG4gICAgICAgIG91dCA9IG91dCB8fCBuZXcgRmxvYXQzMkFycmF5KDQpO1xyXG4gICAgICAgIG91dFswXSA9ICgodGludCA+PiAxNikgJiAweEZGKSAvIDI1NS4wO1xyXG4gICAgICAgIG91dFsxXSA9ICgodGludCA+PiA4KSAmIDB4RkYpIC8gMjU1LjA7XHJcbiAgICAgICAgb3V0WzJdID0gKHRpbnQgJiAweEZGKSAvIDI1NS4wO1xyXG4gICAgICAgIGlmIChwcmVtdWx0aXBseSB8fCBwcmVtdWx0aXBseSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIG91dFswXSAqPSBhbHBoYTtcclxuICAgICAgICAgICAgb3V0WzFdICo9IGFscGhhO1xyXG4gICAgICAgICAgICBvdXRbMl0gKj0gYWxwaGE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG91dFszXSA9IGFscGhhO1xyXG4gICAgICAgIHJldHVybiBvdXQ7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZ2V0U2luZ2xlQ29sb3IoY29sb3IpIHtcclxuICAgICAgICBpZiAodHlwZW9mIGNvbG9yID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICByZXR1cm4gTWF0aFNldHRpbmdzXzEuTWF0aFNldHRpbmdzLmhleDJzdHJpbmcoY29sb3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgY29sb3IgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIGlmIChjb2xvci5pbmRleE9mKCcweCcpID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBjb2xvciA9IGNvbG9yLnJlcGxhY2UoJzB4JywgJyMnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY29sb3I7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZ2V0Q29sb3IoY29sb3IpIHtcclxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoY29sb3IpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBDb2xvclNldHRpbmdzLmdldFNpbmdsZUNvbG9yKGNvbG9yKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29sb3IubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgICAgIGNvbG9yW2ldID0gQ29sb3JTZXR0aW5ncy5nZXRTaW5nbGVDb2xvcihjb2xvcltpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGNvbG9yO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHN0YXRpYyBwcmVtdWx0aXBseVJnYmEocmdiLCBhbHBoYSwgb3V0LCBwcmVtdWx0aXBseSkge1xyXG4gICAgICAgIG91dCA9IG91dCB8fCBuZXcgRmxvYXQzMkFycmF5KDQpO1xyXG4gICAgICAgIGlmIChwcmVtdWx0aXBseSB8fCBwcmVtdWx0aXBseSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIG91dFswXSA9IHJnYlswXSAqIGFscGhhO1xyXG4gICAgICAgICAgICBvdXRbMV0gPSByZ2JbMV0gKiBhbHBoYTtcclxuICAgICAgICAgICAgb3V0WzJdID0gcmdiWzJdICogYWxwaGE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBvdXRbMF0gPSByZ2JbMF07XHJcbiAgICAgICAgICAgIG91dFsxXSA9IHJnYlsxXTtcclxuICAgICAgICAgICAgb3V0WzJdID0gcmdiWzJdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBvdXRbM10gPSBhbHBoYTtcclxuICAgICAgICByZXR1cm4gb3V0O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiogQ29udmVydHMgYSBoZXhhZGVjaW1hbCBjb2xvciBudW1iZXIgdG8gYW4gW1IsIEcsIEJdIGFycmF5IG9mIG5vcm1hbGl6ZWQgZmxvYXRzIChudW1iZXJzIGZyb20gMC4wIHRvIDEuMCkuXHJcbipcclxuKiBAZXhhbXBsZVxyXG4qIFBJWEkudXRpbHMuaGV4MnJnYigweGZmZmZmZik7IC8vIHJldHVybnMgWzEsIDEsIDFdXHJcbiogQG1lbWJlcm9mIFBJWEkudXRpbHNcclxuKiBAZnVuY3Rpb24gaGV4MnJnYlxyXG4qIEBwYXJhbSB7bnVtYmVyfSBoZXggLSBUaGUgaGV4YWRlY2ltYWwgbnVtYmVyIHRvIGNvbnZlcnRcclxuKiBAcGFyYW0gIHtudW1iZXJbXX0gW291dD1bXV0gSWYgc3VwcGxpZWQsIHRoaXMgYXJyYXkgd2lsbCBiZSB1c2VkIHJhdGhlciB0aGFuIHJldHVybmluZyBhIG5ldyBvbmVcclxuKiBAcmV0dXJuIHtudW1iZXJbXX0gQW4gYXJyYXkgcmVwcmVzZW50aW5nIHRoZSBbUiwgRywgQl0gb2YgdGhlIGNvbG9yIHdoZXJlIGFsbCB2YWx1ZXMgYXJlIGZsb2F0cy5cclxuKi9cclxuICAgIHN0YXRpYyBoZXgycmdiKGhleCwgb3V0ID0gbnVsbCkge1xyXG4gICAgICAgIG91dCA9IG91dCB8fCBbXTtcclxuICAgICAgICBvdXRbMF0gPSAoKGhleCA+PiAxNikgJiAweEZGKSAvIDI1NTtcclxuICAgICAgICBvdXRbMV0gPSAoKGhleCA+PiA4KSAmIDB4RkYpIC8gMjU1O1xyXG4gICAgICAgIG91dFsyXSA9IChoZXggJiAweEZGKSAvIDI1NTtcclxuICAgICAgICByZXR1cm4gb3V0O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiogQ29udmVydHMgYSBjb2xvciBhcyBhbiBbUiwgRywgQl0gYXJyYXkgb2Ygbm9ybWFsaXplZCBmbG9hdHMgdG8gYSBoZXhhZGVjaW1hbCBudW1iZXIuXHJcbipcclxuKiBAZXhhbXBsZVxyXG4qIFBJWEkudXRpbHMucmdiMmhleChbMSwgMSwgMV0pOyAvLyByZXR1cm5zIDB4ZmZmZmZmXHJcbiogQG1lbWJlcm9mIFBJWEkudXRpbHNcclxuKiBAZnVuY3Rpb24gcmdiMmhleFxyXG4qIEBwYXJhbSB7bnVtYmVyW119IHJnYiAtIEFycmF5IG9mIG51bWJlcnMgd2hlcmUgYWxsIHZhbHVlcyBhcmUgbm9ybWFsaXplZCBmbG9hdHMgZnJvbSAwLjAgdG8gMS4wLlxyXG4qIEByZXR1cm4ge251bWJlcn0gTnVtYmVyIGluIGhleGFkZWNpbWFsLlxyXG4qL1xyXG4gICAgc3RhdGljIHJnYjJoZXgocmdiKSB7XHJcbiAgICAgICAgcmV0dXJuICgoKHJnYlswXSAqIDI1NSkgPDwgMTYpICsgKChyZ2JbMV0gKiAyNTUpIDw8IDgpICsgKHJnYlsyXSAqIDI1NSB8IDApKTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLkNvbG9yU2V0dGluZ3MgPSBDb2xvclNldHRpbmdzO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBEaXNwbGF5T2JqZWN0XzEgPSByZXF1aXJlKFwiLi9EaXNwbGF5T2JqZWN0XCIpO1xyXG5jb25zdCBFdmVudF8xID0gcmVxdWlyZShcIi4vRXZlbnRcIik7XHJcbmNvbnN0IFV0aWxzU2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL1V0aWxzU2V0dGluZ3NcIik7XHJcbmNvbnN0IERpc3BsYXlTZXR0aW5nc18xID0gcmVxdWlyZShcIi4vRGlzcGxheVNldHRpbmdzXCIpO1xyXG5jbGFzcyBDb250YWluZXIgZXh0ZW5kcyBEaXNwbGF5T2JqZWN0XzEuRGlzcGxheU9iamVjdCB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuY29udGFpbmVyVXBkYXRlVHJhbnNmb3JtID0gdGhpcy51cGRhdGVUcmFuc2Zvcm07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGFycmF5IG9mIGNoaWxkcmVuIG9mIHRoaXMgY29udGFpbmVyLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQG1lbWJlciB7UElYSS5EaXNwbGF5T2JqZWN0W119XHJcbiAgICAgICAgICogQHJlYWRvbmx5XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IFtdO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIElmIHNldCB0byB0cnVlLCB0aGUgY29udGFpbmVyIHdpbGwgc29ydCBpdHMgY2hpbGRyZW4gYnkgekluZGV4IHZhbHVlXHJcbiAgICAgICAgICogd2hlbiB1cGRhdGVUcmFuc2Zvcm0oKSBpcyBjYWxsZWQsIG9yIG1hbnVhbGx5IGlmIHNvcnRDaGlsZHJlbigpIGlzIGNhbGxlZC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIFRoaXMgYWN0dWFsbHkgY2hhbmdlcyB0aGUgb3JkZXIgb2YgZWxlbWVudHMgaW4gdGhlIGFycmF5LCBzbyBzaG91bGQgYmUgdHJlYXRlZFxyXG4gICAgICAgICAqIGFzIGEgYmFzaWMgc29sdXRpb24gdGhhdCBpcyBub3QgcGVyZm9ybWFudCBjb21wYXJlZCB0byBvdGhlciBzb2x1dGlvbnMsXHJcbiAgICAgICAgICogc3VjaCBhcyBAbGluayBodHRwczovL2dpdGh1Yi5jb20vcGl4aWpzL3BpeGktZGlzcGxheVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQWxzbyBiZSBhd2FyZSBvZiB0aGF0IHRoaXMgbWF5IG5vdCB3b3JrIG5pY2VseSB3aXRoIHRoZSBhZGRDaGlsZEF0KCkgZnVuY3Rpb24sXHJcbiAgICAgICAgICogYXMgdGhlIHpJbmRleCBzb3J0aW5nIG1heSBjYXVzZSB0aGUgY2hpbGQgdG8gYXV0b21hdGljYWxseSBzb3J0ZWQgdG8gYW5vdGhlciBwb3NpdGlvbi5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBzZWUgUElYSS5zZXR0aW5ncy5TT1JUQUJMRV9DSElMRFJFTlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQG1lbWJlciB7Ym9vbGVhbn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnNvcnRhYmxlQ2hpbGRyZW4gPSBEaXNwbGF5U2V0dGluZ3NfMS5EaXNwbGF5U2V0dGluZ3MuU09SVEFCTEVfQ0hJTERSRU47XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2hvdWxkIGNoaWxkcmVuIGJlIHNvcnRlZCBieSB6SW5kZXggYXQgdGhlIG5leHQgdXBkYXRlVHJhbnNmb3JtIGNhbGwuXHJcbiAgICAgICAgICogV2lsbCBnZXQgYXV0b21hdGljYWxseSBzZXQgdG8gdHJ1ZSBpZiBhIG5ldyBjaGlsZCBpcyBhZGRlZCwgb3IgaWYgYSBjaGlsZCdzIHpJbmRleCBjaGFuZ2VzLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQG1lbWJlciB7Ym9vbGVhbn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnNvcnREaXJ0eSA9IGZhbHNlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEZpcmVkIHdoZW4gYSBEaXNwbGF5T2JqZWN0IGlzIGFkZGVkIHRvIHRoaXMgQ29udGFpbmVyLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGV2ZW50IFBJWEkuQ29udGFpbmVyI2NoaWxkQWRkZWRcclxuICAgICAgICAgKiBAcGFyYW0ge1BJWEkuRGlzcGxheU9iamVjdH0gY2hpbGQgLSBUaGUgY2hpbGQgYWRkZWQgdG8gdGhlIENvbnRhaW5lci5cclxuICAgICAgICAgKiBAcGFyYW0ge1BJWEkuQ29udGFpbmVyfSBjb250YWluZXIgLSBUaGUgY29udGFpbmVyIHRoYXQgYWRkZWQgdGhlIGNoaWxkLlxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIFRoZSBjaGlsZHJlbidzIGluZGV4IG9mIHRoZSBhZGRlZCBjaGlsZC5cclxuICAgICAgICAgKi9cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBGaXJlZCB3aGVuIGEgRGlzcGxheU9iamVjdCBpcyByZW1vdmVkIGZyb20gdGhpcyBDb250YWluZXIuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAZXZlbnQgUElYSS5EaXNwbGF5T2JqZWN0I3JlbW92ZWRGcm9tXHJcbiAgICAgICAgICogQHBhcmFtIHtQSVhJLkRpc3BsYXlPYmplY3R9IGNoaWxkIC0gVGhlIGNoaWxkIHJlbW92ZWQgZnJvbSB0aGUgQ29udGFpbmVyLlxyXG4gICAgICAgICAqIEBwYXJhbSB7UElYSS5Db250YWluZXJ9IGNvbnRhaW5lciAtIFRoZSBjb250YWluZXIgdGhhdCByZW1vdmVkIHJlbW92ZWQgdGhlIGNoaWxkLlxyXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIFRoZSBmb3JtZXIgY2hpbGRyZW4ncyBpbmRleCBvZiB0aGUgcmVtb3ZlZCBjaGlsZFxyXG4gICAgICAgICAqL1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAqIFJldHVybnMgdGhlIGRpc3BsYXkgb2JqZWN0IGluIHRoZSBjb250YWluZXIuXHJcbiAqXHJcbiAqIEBtZXRob2QgZ2V0Q2hpbGRCeU5hbWVcclxuICogQG1lbWJlcm9mIFBJWEkuQ29udGFpbmVyI1xyXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIEluc3RhbmNlIG5hbWUuXHJcbiAqIEByZXR1cm4ge1BJWEkuRGlzcGxheU9iamVjdH0gVGhlIGNoaWxkIHdpdGggdGhlIHNwZWNpZmllZCBuYW1lLlxyXG4gKi9cclxuICAgIGdldENoaWxkQnlOYW1lKG5hbWUpIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuY2hpbGRyZW5baV0ubmFtZSA9PT0gbmFtZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW5baV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIE92ZXJyaWRhYmxlIG1ldGhvZCB0aGF0IGNhbiBiZSB1c2VkIGJ5IENvbnRhaW5lciBzdWJjbGFzc2VzIHdoZW5ldmVyIHRoZSBjaGlsZHJlbiBhcnJheSBpcyBtb2RpZmllZFxyXG4gICAgICpcclxuICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAqL1xyXG4gICAgb25DaGlsZHJlbkNoYW5nZShvcHRpb25zKSB7XHJcbiAgICAgICAgLyogZW1wdHkgKi9cclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBvbmUgb3IgbW9yZSBjaGlsZHJlbiB0byB0aGUgY29udGFpbmVyLlxyXG4gICAgICpcclxuICAgICAqIE11bHRpcGxlIGl0ZW1zIGNhbiBiZSBhZGRlZCBsaWtlIHNvOiBgbXlDb250YWluZXIuYWRkQ2hpbGQodGhpbmdPbmUsIHRoaW5nVHdvLCB0aGluZ1RocmVlKWBcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gey4uLlBJWEkuRGlzcGxheU9iamVjdH0gY2hpbGQgLSBUaGUgRGlzcGxheU9iamVjdChzKSB0byBhZGQgdG8gdGhlIGNvbnRhaW5lclxyXG4gICAgICogQHJldHVybiB7UElYSS5EaXNwbGF5T2JqZWN0fSBUaGUgZmlyc3QgY2hpbGQgdGhhdCB3YXMgYWRkZWQuXHJcbiAgICAgKi9cclxuICAgIGFkZENoaWxkKGNoaWxkKSB7XHJcbiAgICAgICAgdmFyIGFyZ3VtZW50cyQxID0gYXJndW1lbnRzO1xyXG4gICAgICAgIHZhciBhcmd1bWVudHNMZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xyXG4gICAgICAgIC8vIGlmIHRoZXJlIGlzIG9ubHkgb25lIGFyZ3VtZW50IHdlIGNhbiBieXBhc3MgbG9vcGluZyB0aHJvdWdoIHRoZSB0aGVtXHJcbiAgICAgICAgaWYgKGFyZ3VtZW50c0xlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgLy8gbG9vcCB0aHJvdWdoIHRoZSBhcmd1bWVudHMgcHJvcGVydHkgYW5kIGFkZCBhbGwgY2hpbGRyZW5cclxuICAgICAgICAgICAgLy8gdXNlIGl0IHRoZSByaWdodCB3YXkgKC5sZW5ndGggYW5kIFtpXSkgc28gdGhhdCB0aGlzIGZ1bmN0aW9uIGNhbiBzdGlsbCBiZSBvcHRpbWl6ZWQgYnkgSlMgcnVudGltZXNcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHNMZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRDaGlsZChhcmd1bWVudHMkMVtpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIGlmIHRoZSBjaGlsZCBoYXMgYSBwYXJlbnQgdGhlbiBsZXRzIHJlbW92ZSBpdCBhcyBQaXhpSlMgb2JqZWN0cyBjYW4gb25seSBleGlzdCBpbiBvbmUgcGxhY2VcclxuICAgICAgICAgICAgaWYgKGNoaWxkLnBhcmVudCkge1xyXG4gICAgICAgICAgICAgICAgY2hpbGQucGFyZW50LnJlbW92ZUNoaWxkKGNoaWxkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjaGlsZC5wYXJlbnQgPSB0aGlzO1xyXG4gICAgICAgICAgICB0aGlzLnNvcnREaXJ0eSA9IHRydWU7XHJcbiAgICAgICAgICAgIC8vIGVuc3VyZSBjaGlsZCB0cmFuc2Zvcm0gd2lsbCBiZSByZWNhbGN1bGF0ZWRcclxuICAgICAgICAgICAgY2hpbGQudHJhbnNmb3JtLl9wYXJlbnRJRCA9IC0xO1xyXG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuLnB1c2goY2hpbGQpO1xyXG4gICAgICAgICAgICAvLyBlbnN1cmUgYm91bmRzIHdpbGwgYmUgcmVjYWxjdWxhdGVkXHJcbiAgICAgICAgICAgIHRoaXMuX2JvdW5kc0lEKys7XHJcbiAgICAgICAgICAgIC8vIFRPRE8gLSBsZXRzIGVpdGhlciBkbyBhbGwgY2FsbGJhY2tzIG9yIGFsbCBldmVudHMuLiBub3QgYm90aCFcclxuICAgICAgICAgICAgdGhpcy5vbkNoaWxkcmVuQ2hhbmdlKHRoaXMuY2hpbGRyZW4ubGVuZ3RoIC0gMSk7XHJcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChFdmVudF8xLkV2ZW50LmdldEV2ZW50KFwiY2hpbGRBZGRlZFwiKSk7XHJcbiAgICAgICAgICAgIC8vIHRoaXMuZW1pdCgnY2hpbGRBZGRlZCcsIGNoaWxkLCB0aGlzLCB0aGlzLmNoaWxkcmVuLmxlbmd0aCAtIDEpO1xyXG4gICAgICAgICAgICBjaGlsZC5kaXNwYXRjaEV2ZW50KEV2ZW50XzEuRXZlbnQuZ2V0RXZlbnQoXCJhZGRlZFwiKSk7XHJcbiAgICAgICAgICAgIC8vIGNoaWxkLmVtaXQoJ2FkZGVkJywgdGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjaGlsZDtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhIGNoaWxkIHRvIHRoZSBjb250YWluZXIgYXQgYSBzcGVjaWZpZWQgaW5kZXguIElmIHRoZSBpbmRleCBpcyBvdXQgb2YgYm91bmRzIGFuIGVycm9yIHdpbGwgYmUgdGhyb3duXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtQSVhJLkRpc3BsYXlPYmplY3R9IGNoaWxkIC0gVGhlIGNoaWxkIHRvIGFkZFxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gVGhlIGluZGV4IHRvIHBsYWNlIHRoZSBjaGlsZCBpblxyXG4gICAgICogQHJldHVybiB7UElYSS5EaXNwbGF5T2JqZWN0fSBUaGUgY2hpbGQgdGhhdCB3YXMgYWRkZWQuXHJcbiAgICAgKi9cclxuICAgIGFkZENoaWxkQXQoY2hpbGQsIGluZGV4KSB7XHJcbiAgICAgICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+IHRoaXMuY2hpbGRyZW4ubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigoY2hpbGQgKyBcImFkZENoaWxkQXQ6IFRoZSBpbmRleCBcIiArIGluZGV4ICsgXCIgc3VwcGxpZWQgaXMgb3V0IG9mIGJvdW5kcyBcIiArICh0aGlzLmNoaWxkcmVuLmxlbmd0aCkpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNoaWxkLnBhcmVudCkge1xyXG4gICAgICAgICAgICBjaGlsZC5wYXJlbnQucmVtb3ZlQ2hpbGQoY2hpbGQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjaGlsZC5wYXJlbnQgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMuc29ydERpcnR5ID0gdHJ1ZTtcclxuICAgICAgICAvLyBlbnN1cmUgY2hpbGQgdHJhbnNmb3JtIHdpbGwgYmUgcmVjYWxjdWxhdGVkXHJcbiAgICAgICAgY2hpbGQudHJhbnNmb3JtLl9wYXJlbnRJRCA9IC0xO1xyXG4gICAgICAgIHRoaXMuY2hpbGRyZW4uc3BsaWNlKGluZGV4LCAwLCBjaGlsZCk7XHJcbiAgICAgICAgLy8gZW5zdXJlIGJvdW5kcyB3aWxsIGJlIHJlY2FsY3VsYXRlZFxyXG4gICAgICAgIHRoaXMuX2JvdW5kc0lEKys7XHJcbiAgICAgICAgLy8gVE9ETyAtIGxldHMgZWl0aGVyIGRvIGFsbCBjYWxsYmFja3Mgb3IgYWxsIGV2ZW50cy4uIG5vdCBib3RoIVxyXG4gICAgICAgIHRoaXMub25DaGlsZHJlbkNoYW5nZShpbmRleCk7XHJcbiAgICAgICAgLy8gY2hpbGQuZW1pdCgnYWRkZWQnLCB0aGlzKTtcclxuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoRXZlbnRfMS5FdmVudC5nZXRFdmVudChcImNoaWxkQWRkZWRcIikpO1xyXG4gICAgICAgIC8vIHRoaXMuZW1pdCgnY2hpbGRBZGRlZCcsIGNoaWxkLCB0aGlzLCBpbmRleCk7XHJcbiAgICAgICAgcmV0dXJuIGNoaWxkO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBTd2FwcyB0aGUgcG9zaXRpb24gb2YgMiBEaXNwbGF5IE9iamVjdHMgd2l0aGluIHRoaXMgY29udGFpbmVyLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7UElYSS5EaXNwbGF5T2JqZWN0fSBjaGlsZCAtIEZpcnN0IGRpc3BsYXkgb2JqZWN0IHRvIHN3YXBcclxuICAgICAqIEBwYXJhbSB7UElYSS5EaXNwbGF5T2JqZWN0fSBjaGlsZDIgLSBTZWNvbmQgZGlzcGxheSBvYmplY3QgdG8gc3dhcFxyXG4gICAgICovXHJcbiAgICBzd2FwQ2hpbGRyZW4oY2hpbGQsIGNoaWxkMikge1xyXG4gICAgICAgIGlmIChjaGlsZCA9PT0gY2hpbGQyKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGluZGV4MSA9IHRoaXMuZ2V0Q2hpbGRJbmRleChjaGlsZCk7XHJcbiAgICAgICAgdmFyIGluZGV4MiA9IHRoaXMuZ2V0Q2hpbGRJbmRleChjaGlsZDIpO1xyXG4gICAgICAgIHRoaXMuY2hpbGRyZW5baW5kZXgxXSA9IGNoaWxkMjtcclxuICAgICAgICB0aGlzLmNoaWxkcmVuW2luZGV4Ml0gPSBjaGlsZDtcclxuICAgICAgICB0aGlzLm9uQ2hpbGRyZW5DaGFuZ2UoaW5kZXgxIDwgaW5kZXgyID8gaW5kZXgxIDogaW5kZXgyKTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgaW5kZXggcG9zaXRpb24gb2YgYSBjaGlsZCBEaXNwbGF5T2JqZWN0IGluc3RhbmNlXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtQSVhJLkRpc3BsYXlPYmplY3R9IGNoaWxkIC0gVGhlIERpc3BsYXlPYmplY3QgaW5zdGFuY2UgdG8gaWRlbnRpZnlcclxuICAgICAqIEByZXR1cm4ge251bWJlcn0gVGhlIGluZGV4IHBvc2l0aW9uIG9mIHRoZSBjaGlsZCBkaXNwbGF5IG9iamVjdCB0byBpZGVudGlmeVxyXG4gICAgICovXHJcbiAgICBnZXRDaGlsZEluZGV4KGNoaWxkKSB7XHJcbiAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5jaGlsZHJlbi5pbmRleE9mKGNoaWxkKTtcclxuICAgICAgICBpZiAoaW5kZXggPT09IC0xKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHN1cHBsaWVkIERpc3BsYXlPYmplY3QgbXVzdCBiZSBhIGNoaWxkIG9mIHRoZSBjYWxsZXInKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGluZGV4O1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDaGFuZ2VzIHRoZSBwb3NpdGlvbiBvZiBhbiBleGlzdGluZyBjaGlsZCBpbiB0aGUgZGlzcGxheSBvYmplY3QgY29udGFpbmVyXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtQSVhJLkRpc3BsYXlPYmplY3R9IGNoaWxkIC0gVGhlIGNoaWxkIERpc3BsYXlPYmplY3QgaW5zdGFuY2UgZm9yIHdoaWNoIHlvdSB3YW50IHRvIGNoYW5nZSB0aGUgaW5kZXggbnVtYmVyXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggLSBUaGUgcmVzdWx0aW5nIGluZGV4IG51bWJlciBmb3IgdGhlIGNoaWxkIGRpc3BsYXkgb2JqZWN0XHJcbiAgICAgKi9cclxuICAgIHNldENoaWxkSW5kZXgoY2hpbGQsIGluZGV4KSB7XHJcbiAgICAgICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSB0aGlzLmNoaWxkcmVuLmxlbmd0aCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKFwiVGhlIGluZGV4IFwiICsgaW5kZXggKyBcIiBzdXBwbGllZCBpcyBvdXQgb2YgYm91bmRzIFwiICsgKHRoaXMuY2hpbGRyZW4ubGVuZ3RoKSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgY3VycmVudEluZGV4ID0gdGhpcy5nZXRDaGlsZEluZGV4KGNoaWxkKTtcclxuICAgICAgICBVdGlsc1NldHRpbmdzXzEuVXRpbHNTZXR0aW5ncy5yZW1vdmVJdGVtcyh0aGlzLmNoaWxkcmVuLCBjdXJyZW50SW5kZXgsIDEpOyAvLyByZW1vdmUgZnJvbSBvbGQgcG9zaXRpb25cclxuICAgICAgICB0aGlzLmNoaWxkcmVuLnNwbGljZShpbmRleCwgMCwgY2hpbGQpOyAvLyBhZGQgYXQgbmV3IHBvc2l0aW9uXHJcbiAgICAgICAgdGhpcy5vbkNoaWxkcmVuQ2hhbmdlKGluZGV4KTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgY2hpbGQgYXQgdGhlIHNwZWNpZmllZCBpbmRleFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIFRoZSBpbmRleCB0byBnZXQgdGhlIGNoaWxkIGF0XHJcbiAgICAgKiBAcmV0dXJuIHtQSVhJLkRpc3BsYXlPYmplY3R9IFRoZSBjaGlsZCBhdCB0aGUgZ2l2ZW4gaW5kZXgsIGlmIGFueS5cclxuICAgICAqL1xyXG4gICAgZ2V0Q2hpbGRBdChpbmRleCkge1xyXG4gICAgICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPj0gdGhpcy5jaGlsZHJlbi5sZW5ndGgpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKChcImdldENoaWxkQXQ6IEluZGV4IChcIiArIGluZGV4ICsgXCIpIGRvZXMgbm90IGV4aXN0LlwiKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuW2luZGV4XTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyBvbmUgb3IgbW9yZSBjaGlsZHJlbiBmcm9tIHRoZSBjb250YWluZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHsuLi5QSVhJLkRpc3BsYXlPYmplY3R9IGNoaWxkIC0gVGhlIERpc3BsYXlPYmplY3QocykgdG8gcmVtb3ZlXHJcbiAgICAgKiBAcmV0dXJuIHtQSVhJLkRpc3BsYXlPYmplY3R9IFRoZSBmaXJzdCBjaGlsZCB0aGF0IHdhcyByZW1vdmVkLlxyXG4gICAgICovXHJcbiAgICByZW1vdmVDaGlsZChjaGlsZCkge1xyXG4gICAgICAgIHZhciBhcmd1bWVudHMkMSA9IGFyZ3VtZW50cztcclxuICAgICAgICB2YXIgYXJndW1lbnRzTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcclxuICAgICAgICAvLyBpZiB0aGVyZSBpcyBvbmx5IG9uZSBhcmd1bWVudCB3ZSBjYW4gYnlwYXNzIGxvb3BpbmcgdGhyb3VnaCB0aGUgdGhlbVxyXG4gICAgICAgIGlmIChhcmd1bWVudHNMZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgIC8vIGxvb3AgdGhyb3VnaCB0aGUgYXJndW1lbnRzIHByb3BlcnR5IGFuZCBhZGQgYWxsIGNoaWxkcmVuXHJcbiAgICAgICAgICAgIC8vIHVzZSBpdCB0aGUgcmlnaHQgd2F5ICgubGVuZ3RoIGFuZCBbaV0pIHNvIHRoYXQgdGhpcyBmdW5jdGlvbiBjYW4gc3RpbGwgYmUgb3B0aW1pemVkIGJ5IEpTIHJ1bnRpbWVzXHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzTGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlQ2hpbGQoYXJndW1lbnRzJDFbaV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmNoaWxkcmVuLmluZGV4T2YoY2hpbGQpO1xyXG4gICAgICAgICAgICBpZiAoaW5kZXggPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjaGlsZC5wYXJlbnQgPSBudWxsO1xyXG4gICAgICAgICAgICAvLyBlbnN1cmUgY2hpbGQgdHJhbnNmb3JtIHdpbGwgYmUgcmVjYWxjdWxhdGVkXHJcbiAgICAgICAgICAgIGNoaWxkLnRyYW5zZm9ybS5fcGFyZW50SUQgPSAtMTtcclxuICAgICAgICAgICAgVXRpbHNTZXR0aW5nc18xLlV0aWxzU2V0dGluZ3MucmVtb3ZlSXRlbXModGhpcy5jaGlsZHJlbiwgaW5kZXgsIDEpO1xyXG4gICAgICAgICAgICAvLyBlbnN1cmUgYm91bmRzIHdpbGwgYmUgcmVjYWxjdWxhdGVkXHJcbiAgICAgICAgICAgIHRoaXMuX2JvdW5kc0lEKys7XHJcbiAgICAgICAgICAgIC8vIFRPRE8gLSBsZXRzIGVpdGhlciBkbyBhbGwgY2FsbGJhY2tzIG9yIGFsbCBldmVudHMuLiBub3QgYm90aCFcclxuICAgICAgICAgICAgdGhpcy5vbkNoaWxkcmVuQ2hhbmdlKGluZGV4KTtcclxuICAgICAgICAgICAgLy8gY2hpbGQuZW1pdCgncmVtb3ZlZCcsIHRoaXMpO1xyXG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoRXZlbnRfMS5FdmVudC5nZXRFdmVudChcImNoaWxkUmVtb3ZlZFwiKSk7XHJcbiAgICAgICAgICAgIC8vIHRoaXMuZW1pdCgnY2hpbGRSZW1vdmVkJywgY2hpbGQsIHRoaXMsIGluZGV4KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNoaWxkO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIGEgY2hpbGQgZnJvbSB0aGUgc3BlY2lmaWVkIGluZGV4IHBvc2l0aW9uLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIFRoZSBpbmRleCB0byBnZXQgdGhlIGNoaWxkIGZyb21cclxuICAgICAqIEByZXR1cm4ge1BJWEkuRGlzcGxheU9iamVjdH0gVGhlIGNoaWxkIHRoYXQgd2FzIHJlbW92ZWQuXHJcbiAgICAgKi9cclxuICAgIHJlbW92ZUNoaWxkQXQoaW5kZXgpIHtcclxuICAgICAgICB2YXIgY2hpbGQgPSB0aGlzLmdldENoaWxkQXQoaW5kZXgpO1xyXG4gICAgICAgIC8vIGVuc3VyZSBjaGlsZCB0cmFuc2Zvcm0gd2lsbCBiZSByZWNhbGN1bGF0ZWQuLlxyXG4gICAgICAgIGNoaWxkLnBhcmVudCA9IG51bGw7XHJcbiAgICAgICAgY2hpbGQudHJhbnNmb3JtLl9wYXJlbnRJRCA9IC0xO1xyXG4gICAgICAgIFV0aWxzU2V0dGluZ3NfMS5VdGlsc1NldHRpbmdzLnJlbW92ZUl0ZW1zKHRoaXMuY2hpbGRyZW4sIGluZGV4LCAxKTtcclxuICAgICAgICAvLyBlbnN1cmUgYm91bmRzIHdpbGwgYmUgcmVjYWxjdWxhdGVkXHJcbiAgICAgICAgdGhpcy5fYm91bmRzSUQrKztcclxuICAgICAgICAvLyBUT0RPIC0gbGV0cyBlaXRoZXIgZG8gYWxsIGNhbGxiYWNrcyBvciBhbGwgZXZlbnRzLi4gbm90IGJvdGghXHJcbiAgICAgICAgdGhpcy5vbkNoaWxkcmVuQ2hhbmdlKGluZGV4KTtcclxuICAgICAgICAvLyBjaGlsZC5lbWl0KCdyZW1vdmVkJywgdGhpcyk7XHJcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KEV2ZW50XzEuRXZlbnQuZ2V0RXZlbnQoXCJjaGlsZFJlbW92ZWRcIikpO1xyXG4gICAgICAgIC8vIHRoaXMuZW1pdCgnY2hpbGRSZW1vdmVkJywgY2hpbGQsIHRoaXMsIGluZGV4KTtcclxuICAgICAgICByZXR1cm4gY2hpbGQ7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgYWxsIGNoaWxkcmVuIGZyb20gdGhpcyBjb250YWluZXIgdGhhdCBhcmUgd2l0aGluIHRoZSBiZWdpbiBhbmQgZW5kIGluZGV4ZXMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtiZWdpbkluZGV4PTBdIC0gVGhlIGJlZ2lubmluZyBwb3NpdGlvbi5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZW5kSW5kZXg9dGhpcy5jaGlsZHJlbi5sZW5ndGhdIC0gVGhlIGVuZGluZyBwb3NpdGlvbi4gRGVmYXVsdCB2YWx1ZSBpcyBzaXplIG9mIHRoZSBjb250YWluZXIuXHJcbiAgICAgKiBAcmV0dXJucyB7RGlzcGxheU9iamVjdFtdfSBMaXN0IG9mIHJlbW92ZWQgY2hpbGRyZW5cclxuICAgICAqL1xyXG4gICAgcmVtb3ZlQ2hpbGRyZW4oYmVnaW5JbmRleCA9IDAsIGVuZEluZGV4ID0gSW5maW5pdHkpIHtcclxuICAgICAgICBpZiAoYmVnaW5JbmRleCA9PT0gdm9pZCAwKSB7XHJcbiAgICAgICAgICAgIGJlZ2luSW5kZXggPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgYmVnaW4gPSBiZWdpbkluZGV4O1xyXG4gICAgICAgIHZhciBlbmQgPSB0eXBlb2YgZW5kSW5kZXggPT09ICdudW1iZXInID8gZW5kSW5kZXggOiB0aGlzLmNoaWxkcmVuLmxlbmd0aDtcclxuICAgICAgICB2YXIgcmFuZ2UgPSBlbmQgLSBiZWdpbjtcclxuICAgICAgICB2YXIgcmVtb3ZlZDtcclxuICAgICAgICBpZiAocmFuZ2UgPiAwICYmIHJhbmdlIDw9IGVuZCkge1xyXG4gICAgICAgICAgICByZW1vdmVkID0gdGhpcy5jaGlsZHJlbi5zcGxpY2UoYmVnaW4sIHJhbmdlKTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZW1vdmVkLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICByZW1vdmVkW2ldLnBhcmVudCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICBpZiAocmVtb3ZlZFtpXS50cmFuc2Zvcm0pIHtcclxuICAgICAgICAgICAgICAgICAgICByZW1vdmVkW2ldLnRyYW5zZm9ybS5fcGFyZW50SUQgPSAtMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9ib3VuZHNJRCsrO1xyXG4gICAgICAgICAgICB0aGlzLm9uQ2hpbGRyZW5DaGFuZ2UoYmVnaW5JbmRleCk7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IHJlbW92ZWQubGVuZ3RoOyArK2kkMSkge1xyXG4gICAgICAgICAgICAgICAgLy8gcmVtb3ZlZFtpJDFdLmVtaXQoJ3JlbW92ZWQnLCB0aGlzKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChFdmVudF8xLkV2ZW50LmdldEV2ZW50KFwiY2hpbGRSZW1vdmVkXCIpKTtcclxuICAgICAgICAgICAgICAgIC8vIHRoaXMuZW1pdCgnY2hpbGRSZW1vdmVkJywgcmVtb3ZlZFtpJDFdLCB0aGlzLCBpJDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiByZW1vdmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChyYW5nZSA9PT0gMCAmJiB0aGlzLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdyZW1vdmVDaGlsZHJlbjogbnVtZXJpYyB2YWx1ZXMgYXJlIG91dHNpZGUgdGhlIGFjY2VwdGFibGUgcmFuZ2UuJyk7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFNvcnRzIGNoaWxkcmVuIGJ5IHpJbmRleC4gUHJldmlvdXMgb3JkZXIgaXMgbWFudGFpbmVkIGZvciAyIGNoaWxkcmVuIHdpdGggdGhlIHNhbWUgekluZGV4LlxyXG4gICAgICovXHJcbiAgICBzb3J0Q2hpbGRyZW4oKSB7XHJcbiAgICAgICAgdmFyIHNvcnRSZXF1aXJlZCA9IGZhbHNlO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBqID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgPCBqOyArK2kpIHtcclxuICAgICAgICAgICAgdmFyIGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXTtcclxuICAgICAgICAgICAgY2hpbGQuX2xhc3RTb3J0ZWRJbmRleCA9IGk7XHJcbiAgICAgICAgICAgIGlmICghc29ydFJlcXVpcmVkICYmIGNoaWxkLnpJbmRleCAhPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgc29ydFJlcXVpcmVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc29ydFJlcXVpcmVkICYmIHRoaXMuY2hpbGRyZW4ubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuLnNvcnQoQ29udGFpbmVyLnNvcnRDaGlsZHJlbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuc29ydERpcnR5ID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgdGhlIHRyYW5zZm9ybSBvbiBhbGwgY2hpbGRyZW4gb2YgdGhpcyBjb250YWluZXIgZm9yIHJlbmRlcmluZ1xyXG4gICAgICovXHJcbiAgICB1cGRhdGVUcmFuc2Zvcm0oKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuc29ydGFibGVDaGlsZHJlbiAmJiB0aGlzLnNvcnREaXJ0eSkge1xyXG4gICAgICAgICAgICB0aGlzLnNvcnRDaGlsZHJlbigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9ib3VuZHNJRCsrO1xyXG4gICAgICAgIHRoaXMudHJhbnNmb3JtLnVwZGF0ZVRyYW5zZm9ybSh0aGlzLnBhcmVudC50cmFuc2Zvcm0pO1xyXG4gICAgICAgIC8vIFRPRE86IGNoZWNrIHJlbmRlciBmbGFncywgaG93IHRvIHByb2Nlc3Mgc3R1ZmYgaGVyZVxyXG4gICAgICAgIHRoaXMud29ybGRBbHBoYSA9IHRoaXMuYWxwaGEgKiB0aGlzLnBhcmVudC53b3JsZEFscGhhO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBqID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgPCBqOyArK2kpIHtcclxuICAgICAgICAgICAgdmFyIGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXTtcclxuICAgICAgICAgICAgaWYgKGNoaWxkLnZpc2libGUpIHtcclxuICAgICAgICAgICAgICAgIGNoaWxkLnVwZGF0ZVRyYW5zZm9ybSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZWNhbGN1bGF0ZXMgdGhlIGJvdW5kcyBvZiB0aGUgY29udGFpbmVyLlxyXG4gICAgICpcclxuICAgICAqL1xyXG4gICAgY2FsY3VsYXRlQm91bmRzKCkge1xyXG4gICAgICAgIHRoaXMuX2JvdW5kcy5jbGVhcigpO1xyXG4gICAgICAgIHRoaXMuX2NhbGN1bGF0ZUJvdW5kcygpO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldO1xyXG4gICAgICAgICAgICBpZiAoIWNoaWxkLnZpc2libGUgfHwgIWNoaWxkLnJlbmRlcmFibGUpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNoaWxkLmNhbGN1bGF0ZUJvdW5kcygpO1xyXG4gICAgICAgICAgICAvLyBUT0RPOiBmaWx0ZXIrbWFzaywgbmVlZCB0byBtYXNrIGJvdGggc29tZWhvd1xyXG4gICAgICAgICAgICBpZiAoY2hpbGQuX21hc2spIHtcclxuICAgICAgICAgICAgICAgIGNoaWxkLl9tYXNrLmNhbGN1bGF0ZUJvdW5kcygpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYm91bmRzLmFkZEJvdW5kc01hc2soY2hpbGQuX2JvdW5kcywgY2hpbGQuX21hc2suX2JvdW5kcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY2hpbGQuZmlsdGVyQXJlYSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYm91bmRzLmFkZEJvdW5kc0FyZWEoY2hpbGQuX2JvdW5kcywgY2hpbGQuZmlsdGVyQXJlYSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9ib3VuZHMuYWRkQm91bmRzKGNoaWxkLl9ib3VuZHMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2xhc3RCb3VuZHNJRCA9IHRoaXMuX2JvdW5kc0lEO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZWNhbGN1bGF0ZXMgdGhlIGJvdW5kcyBvZiB0aGUgb2JqZWN0LiBPdmVycmlkZSB0aGlzIHRvXHJcbiAgICAgKiBjYWxjdWxhdGUgdGhlIGJvdW5kcyBvZiB0aGUgc3BlY2lmaWMgb2JqZWN0IChub3QgaW5jbHVkaW5nIGNoaWxkcmVuKS5cclxuICAgICAqXHJcbiAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgKi9cclxuICAgIF9jYWxjdWxhdGVCb3VuZHMoKSB7XHJcbiAgICAgICAgLy8gRklMTCBJTi8vXHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFJlbmRlcnMgdGhlIG9iamVjdCB1c2luZyB0aGUgV2ViR0wgcmVuZGVyZXJcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1BJWEkuUmVuZGVyZXJ9IHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyXHJcbiAgICAgKi9cclxuICAgIHJlbmRlcihyZW5kZXJlcikge1xyXG4gICAgICAgIC8vIGlmIHRoZSBvYmplY3QgaXMgbm90IHZpc2libGUgb3IgdGhlIGFscGhhIGlzIDAgdGhlbiBubyBuZWVkIHRvIHJlbmRlciB0aGlzIGVsZW1lbnRcclxuICAgICAgICBpZiAoIXRoaXMudmlzaWJsZSB8fCB0aGlzLndvcmxkQWxwaGEgPD0gMCB8fCAhdGhpcy5yZW5kZXJhYmxlKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gZG8gYSBxdWljayBjaGVjayB0byBzZWUgaWYgdGhpcyBlbGVtZW50IGhhcyBhIG1hc2sgb3IgYSBmaWx0ZXIuXHJcbiAgICAgICAgaWYgKHRoaXMuX21hc2sgfHwgdGhpcy5maWx0ZXJzKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVyQWR2YW5jZWQocmVuZGVyZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5fcmVuZGVyKHJlbmRlcmVyKTtcclxuICAgICAgICAgICAgLy8gc2ltcGxlIHJlbmRlciBjaGlsZHJlbiFcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGogPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGo7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jaGlsZHJlbltpXS5yZW5kZXIocmVuZGVyZXIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZW5kZXIgdGhlIG9iamVjdCB1c2luZyB0aGUgV2ViR0wgcmVuZGVyZXIgYW5kIGFkdmFuY2VkIGZlYXR1cmVzLlxyXG4gICAgICpcclxuICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAqIEBwYXJhbSB7UElYSS5SZW5kZXJlcn0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXJcclxuICAgICAqL1xyXG4gICAgcmVuZGVyQWR2YW5jZWQocmVuZGVyZXIpIHtcclxuICAgICAgICByZW5kZXJlci5iYXRjaC5mbHVzaCgpO1xyXG4gICAgICAgIHZhciBmaWx0ZXJzID0gdGhpcy5maWx0ZXJzO1xyXG4gICAgICAgIHZhciBtYXNrID0gdGhpcy5fbWFzaztcclxuICAgICAgICAvLyBwdXNoIGZpbHRlciBmaXJzdCBhcyB3ZSBuZWVkIHRvIGVuc3VyZSB0aGUgc3RlbmNpbCBidWZmZXIgaXMgY29ycmVjdCBmb3IgYW55IG1hc2tpbmdcclxuICAgICAgICBpZiAoZmlsdGVycykge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX2VuYWJsZWRGaWx0ZXJzKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9lbmFibGVkRmlsdGVycyA9IFtdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX2VuYWJsZWRGaWx0ZXJzLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmlsdGVycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGZpbHRlcnNbaV0uZW5hYmxlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2VuYWJsZWRGaWx0ZXJzLnB1c2goZmlsdGVyc1tpXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuX2VuYWJsZWRGaWx0ZXJzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgcmVuZGVyZXIuZmlsdGVyLnB1c2godGhpcywgdGhpcy5fZW5hYmxlZEZpbHRlcnMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChtYXNrKSB7XHJcbiAgICAgICAgICAgIHJlbmRlcmVyLm1hc2sucHVzaCh0aGlzLCB0aGlzLl9tYXNrKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gYWRkIHRoaXMgb2JqZWN0IHRvIHRoZSBiYXRjaCwgb25seSByZW5kZXJlZCBpZiBpdCBoYXMgYSB0ZXh0dXJlLlxyXG4gICAgICAgIHRoaXMuX3JlbmRlcihyZW5kZXJlcik7XHJcbiAgICAgICAgLy8gbm93IGxvb3AgdGhyb3VnaCB0aGUgY2hpbGRyZW4gYW5kIG1ha2Ugc3VyZSB0aGV5IGdldCByZW5kZXJlZFxyXG4gICAgICAgIGZvciAodmFyIGkkMSA9IDAsIGogPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSQxIDwgajsgaSQxKyspIHtcclxuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbltpJDFdLnJlbmRlcihyZW5kZXJlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlbmRlcmVyLmJhdGNoLmZsdXNoKCk7XHJcbiAgICAgICAgaWYgKG1hc2spIHtcclxuICAgICAgICAgICAgcmVuZGVyZXIubWFzay5wb3AodGhpcywgdGhpcy5fbWFzayk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChmaWx0ZXJzICYmIHRoaXMuX2VuYWJsZWRGaWx0ZXJzICYmIHRoaXMuX2VuYWJsZWRGaWx0ZXJzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZW5kZXJlci5maWx0ZXIucG9wKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUbyBiZSBvdmVycmlkZGVuIGJ5IHRoZSBzdWJjbGFzc2VzLlxyXG4gICAgICpcclxuICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAqIEBwYXJhbSB7UElYSS5SZW5kZXJlcn0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXJcclxuICAgICAqL1xyXG4gICAgX3JlbmRlcihyZW5kZXJlcikge1xyXG4gICAgICAgIC8vIHRoaXMgaXMgd2hlcmUgY29udGVudCBpdHNlbGYgZ2V0cyByZW5kZXJlZC4uLlxyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIGFsbCBpbnRlcm5hbCByZWZlcmVuY2VzIGFuZCBsaXN0ZW5lcnMgYXMgd2VsbCBhcyByZW1vdmVzIGNoaWxkcmVuIGZyb20gdGhlIGRpc3BsYXkgbGlzdC5cclxuICAgICAqIERvIG5vdCB1c2UgYSBDb250YWluZXIgYWZ0ZXIgY2FsbGluZyBgZGVzdHJveWAuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtvYmplY3R8Ym9vbGVhbn0gW29wdGlvbnNdIC0gT3B0aW9ucyBwYXJhbWV0ZXIuIEEgYm9vbGVhbiB3aWxsIGFjdCBhcyBpZiBhbGwgb3B0aW9uc1xyXG4gICAgICogIGhhdmUgYmVlbiBzZXQgdG8gdGhhdCB2YWx1ZVxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jaGlsZHJlbj1mYWxzZV0gLSBpZiBzZXQgdG8gdHJ1ZSwgYWxsIHRoZSBjaGlsZHJlbiB3aWxsIGhhdmUgdGhlaXIgZGVzdHJveVxyXG4gICAgICogIG1ldGhvZCBjYWxsZWQgYXMgd2VsbC4gJ29wdGlvbnMnIHdpbGwgYmUgcGFzc2VkIG9uIHRvIHRob3NlIGNhbGxzLlxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50ZXh0dXJlPWZhbHNlXSAtIE9ubHkgdXNlZCBmb3IgY2hpbGQgU3ByaXRlcyBpZiBvcHRpb25zLmNoaWxkcmVuIGlzIHNldCB0byB0cnVlXHJcbiAgICAgKiAgU2hvdWxkIGl0IGRlc3Ryb3kgdGhlIHRleHR1cmUgb2YgdGhlIGNoaWxkIHNwcml0ZVxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5iYXNlVGV4dHVyZT1mYWxzZV0gLSBPbmx5IHVzZWQgZm9yIGNoaWxkIFNwcml0ZXMgaWYgb3B0aW9ucy5jaGlsZHJlbiBpcyBzZXQgdG8gdHJ1ZVxyXG4gICAgICogIFNob3VsZCBpdCBkZXN0cm95IHRoZSBiYXNlIHRleHR1cmUgb2YgdGhlIGNoaWxkIHNwcml0ZVxyXG4gICAgICovXHJcbiAgICBkZXN0cm95KG9wdGlvbnMpIHtcclxuICAgICAgICBzdXBlci5kZXN0cm95KG9wdGlvbnMpO1xyXG4gICAgICAgIHRoaXMuc29ydERpcnR5ID0gZmFsc2U7XHJcbiAgICAgICAgdmFyIGRlc3Ryb3lDaGlsZHJlbiA9IHR5cGVvZiBvcHRpb25zID09PSAnYm9vbGVhbicgPyBvcHRpb25zIDogb3B0aW9ucyAmJiBvcHRpb25zLmNoaWxkcmVuO1xyXG4gICAgICAgIHZhciBvbGRDaGlsZHJlbiA9IHRoaXMucmVtb3ZlQ2hpbGRyZW4oMCwgdGhpcy5jaGlsZHJlbi5sZW5ndGgpO1xyXG4gICAgICAgIGlmIChkZXN0cm95Q2hpbGRyZW4pIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvbGRDaGlsZHJlbi5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgb2xkQ2hpbGRyZW5baV0uZGVzdHJveShvcHRpb25zKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIHdpZHRoIG9mIHRoZSBDb250YWluZXIsIHNldHRpbmcgdGhpcyB3aWxsIGFjdHVhbGx5IG1vZGlmeSB0aGUgc2NhbGUgdG8gYWNoaWV2ZSB0aGUgdmFsdWUgc2V0XHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICBnZXQgd2lkdGgoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NhbGUueCAqIHRoaXMuZ2V0TG9jYWxCb3VuZHMoKS53aWR0aDtcclxuICAgIH1cclxuICAgIDtcclxuICAgIHNldCB3aWR0aCh2YWx1ZSkge1xyXG4gICAgICAgIHZhciB3aWR0aCA9IHRoaXMuZ2V0TG9jYWxCb3VuZHMoKS53aWR0aDtcclxuICAgICAgICBpZiAod2lkdGggIT09IDApIHtcclxuICAgICAgICAgICAgdGhpcy5zY2FsZS54ID0gdmFsdWUgLyB3aWR0aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2NhbGUueCA9IDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3dpZHRoID0gdmFsdWU7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBoZWlnaHQgb2YgdGhlIENvbnRhaW5lciwgc2V0dGluZyB0aGlzIHdpbGwgYWN0dWFsbHkgbW9kaWZ5IHRoZSBzY2FsZSB0byBhY2hpZXZlIHRoZSB2YWx1ZSBzZXRcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIGdldCBoZWlnaHQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NhbGUueSAqIHRoaXMuZ2V0TG9jYWxCb3VuZHMoKS5oZWlnaHQ7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICBzZXQgaGVpZ2h0KHZhbHVlKSB7XHJcbiAgICAgICAgdmFyIGhlaWdodCA9IHRoaXMuZ2V0TG9jYWxCb3VuZHMoKS5oZWlnaHQ7XHJcbiAgICAgICAgaWYgKGhlaWdodCAhPT0gMCkge1xyXG4gICAgICAgICAgICB0aGlzLnNjYWxlLnkgPSB2YWx1ZSAvIGhlaWdodDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2NhbGUueSA9IDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2hlaWdodCA9IHZhbHVlO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgc3RhdGljIHNvcnRDaGlsZHJlbihhLCBiKSB7XHJcbiAgICAgICAgaWYgKGEuekluZGV4ID09PSBiLnpJbmRleCkge1xyXG4gICAgICAgICAgICByZXR1cm4gYS5fbGFzdFNvcnRlZEluZGV4IC0gYi5fbGFzdFNvcnRlZEluZGV4O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYS56SW5kZXggLSBiLnpJbmRleDtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLkNvbnRhaW5lciA9IENvbnRhaW5lcjtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgU3lzdGVtXzEgPSByZXF1aXJlKFwiLi9TeXN0ZW1cIik7XHJcbmNvbnN0IERpc3BsYXlTZXR0aW5nc18xID0gcmVxdWlyZShcIi4vRGlzcGxheVNldHRpbmdzXCIpO1xyXG5jbGFzcyBDb250ZXh0U3lzdGVtIGV4dGVuZHMgU3lzdGVtXzEuU3lzdGVtIHtcclxuICAgIGNvbnN0cnVjdG9yKHJlbmRlcmVyKSB7XHJcbiAgICAgICAgc3VwZXIocmVuZGVyZXIpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEVpdGhlciAxIG9yIDIgdG8gcmVmbGVjdCB0aGUgV2ViR0wgdmVyc2lvbiBiZWluZyB1c2VkXHJcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICAgICAqIEByZWFkb25seVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMud2ViR0xWZXJzaW9uID0gMTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBFeHRlbnNpb25zIGJlaW5nIHVzZWRcclxuICAgICAgICAgKiBAbWVtYmVyIHtvYmplY3R9XHJcbiAgICAgICAgICogQHJlYWRvbmx5XHJcbiAgICAgICAgICogQHByb3BlcnR5IHtXRUJHTF9kcmF3X2J1ZmZlcnN9IGRyYXdCdWZmZXJzIC0gV2ViR0wgdjEgZXh0ZW5zaW9uXHJcbiAgICAgICAgICogQHByb3BlcnR5IHtXRUJHTF9kZXB0aF90ZXh0dXJlfSBkZXB0aFRleHR1cmUgLSBXZWJHTCB2MSBleHRlbnNpb25cclxuICAgICAgICAgKiBAcHJvcGVydHkge09FU190ZXh0dXJlX2Zsb2F0fSBmbG9hdFRleHR1cmUgLSBXZWJHTCB2MSBleHRlbnNpb25cclxuICAgICAgICAgKiBAcHJvcGVydHkge1dFQkdMX2xvc2VfY29udGV4dH0gbG9zZUNvbnRleHQgLSBXZWJHTCB2MSBleHRlbnNpb25cclxuICAgICAgICAgKiBAcHJvcGVydHkge09FU192ZXJ0ZXhfYXJyYXlfb2JqZWN0fSB2ZXJ0ZXhBcnJheU9iamVjdCAtIFdlYkdMIHYxIGV4dGVuc2lvblxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuZXh0ZW5zaW9ucyA9IHt9O1xyXG4gICAgICAgIC8vIEJpbmQgZnVuY3Rpb25zXHJcbiAgICAgICAgdGhpcy5oYW5kbGVDb250ZXh0TG9zdCA9IHRoaXMuaGFuZGxlQ29udGV4dExvc3QuYmluZCh0aGlzKTtcclxuICAgICAgICB0aGlzLmhhbmRsZUNvbnRleHRSZXN0b3JlZCA9IHRoaXMuaGFuZGxlQ29udGV4dFJlc3RvcmVkLmJpbmQodGhpcyk7XHJcbiAgICAgICAgcmVuZGVyZXIudmlldy5hZGRFdmVudExpc3RlbmVyKCd3ZWJnbGNvbnRleHRsb3N0JywgdGhpcy5oYW5kbGVDb250ZXh0TG9zdCwgZmFsc2UpO1xyXG4gICAgICAgIHJlbmRlcmVyLnZpZXcuYWRkRXZlbnRMaXN0ZW5lcignd2ViZ2xjb250ZXh0cmVzdG9yZWQnLCB0aGlzLmhhbmRsZUNvbnRleHRSZXN0b3JlZCwgZmFsc2UpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBgdHJ1ZWAgaWYgdGhlIGNvbnRleHQgaXMgbG9zdFxyXG4gICAgICogQG1lbWJlciB7Ym9vbGVhbn1cclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICovXHJcbiAgICBnZXQgaXNMb3N0KCkge1xyXG4gICAgICAgIHJldHVybiAoIXRoaXMuZ2wgfHwgdGhpcy5nbC5pc0NvbnRleHRMb3N0KCkpO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBIYW5kbGUgdGhlIGNvbnRleHQgY2hhbmdlIGV2ZW50XHJcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgbmV3IHdlYmdsIGNvbnRleHRcclxuICAgICAqL1xyXG4gICAgY29udGV4dENoYW5nZShnbCkge1xyXG4gICAgICAgIHRoaXMuZ2wgPSBnbDtcclxuICAgICAgICAvLyByZXN0b3JlIGEgY29udGV4dCBpZiBpdCB3YXMgcHJldmlvdXNseSBsb3N0XHJcbiAgICAgICAgaWYgKGdsLmlzQ29udGV4dExvc3QoKSAmJiBnbC5nZXRFeHRlbnNpb24oJ1dFQkdMX2xvc2VfY29udGV4dCcpKSB7XHJcbiAgICAgICAgICAgIGdsLmdldEV4dGVuc2lvbignV0VCR0xfbG9zZV9jb250ZXh0JykucmVzdG9yZUNvbnRleHQoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIEluaXRpYWxpemUgdGhlIGNvbnRleHRcclxuICAgICAqXHJcbiAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgLSBXZWJHTCBjb250ZXh0XHJcbiAgICAgKi9cclxuICAgIGluaXRGcm9tQ29udGV4dChnbCkge1xyXG4gICAgICAgIHRoaXMuZ2wgPSBnbDtcclxuICAgICAgICB0aGlzLnZhbGlkYXRlQ29udGV4dChnbCk7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJlci5nbCA9IGdsO1xyXG4gICAgICAgIHRoaXMucmVuZGVyZXIuQ09OVEVYVF9VSUQgPSBDb250ZXh0U3lzdGVtLkNPTlRFWFRfVUlEKys7XHJcbiAgICAgICAgLy8gdGhpcy5kaXNwYXRjaEV2ZW50KEV2ZW50LmdldEV2ZW50KFwiY29udGV4dGNoYW5nZVwiKSlcclxuICAgICAgICB0aGlzLnJlbmRlcmVyLnJ1bm5lcnMuY29udGV4dENoYW5nZS5ydW4oZ2wpO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBJbml0aWFsaXplIGZyb20gY29udGV4dCBvcHRpb25zXHJcbiAgICAgKlxyXG4gICAgICogQHByb3RlY3RlZFxyXG4gICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvSFRNTENhbnZhc0VsZW1lbnQvZ2V0Q29udGV4dFxyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgLSBjb250ZXh0IGF0dHJpYnV0ZXNcclxuICAgICAqL1xyXG4gICAgaW5pdEZyb21PcHRpb25zKG9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgZ2wgPSB0aGlzLmNyZWF0ZUNvbnRleHQodGhpcy5yZW5kZXJlci52aWV3LCBvcHRpb25zKTtcclxuICAgICAgICB0aGlzLmluaXRGcm9tQ29udGV4dChnbCk7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIEhlbHBlciBjbGFzcyB0byBjcmVhdGUgYSBXZWJHTCBDb250ZXh0XHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGNhbnZhcyB7SFRNTENhbnZhc0VsZW1lbnR9IHRoZSBjYW52YXMgZWxlbWVudCB0aGF0IHdlIHdpbGwgZ2V0IHRoZSBjb250ZXh0IGZyb21cclxuICAgICAqIEBwYXJhbSBvcHRpb25zIHtvYmplY3R9IEFuIG9wdGlvbnMgb2JqZWN0IHRoYXQgZ2V0cyBwYXNzZWQgaW4gdG8gdGhlIGNhbnZhcyBlbGVtZW50IGNvbnRhaW5pbmcgdGhlIGNvbnRleHQgYXR0cmlidXRlc1xyXG4gICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9BUEkvSFRNTENhbnZhc0VsZW1lbnQvZ2V0Q29udGV4dFxyXG4gICAgICogQHJldHVybiB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSB0aGUgV2ViR0wgY29udGV4dFxyXG4gICAgICovXHJcbiAgICBjcmVhdGVDb250ZXh0KGNhbnZhcywgb3B0aW9ucykge1xyXG4gICAgICAgIHZhciBnbDtcclxuICAgICAgICBpZiAoRGlzcGxheVNldHRpbmdzXzEuRGlzcGxheVNldHRpbmdzLlBSRUZFUl9FTlYgPj0gRGlzcGxheVNldHRpbmdzXzEuRGlzcGxheVNldHRpbmdzLkVOVi5XRUJHTDIpIHtcclxuICAgICAgICAgICAgZ2wgPSBjYW52YXMuZ2V0Q29udGV4dCgnd2ViZ2wyJywgb3B0aW9ucyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChnbCkge1xyXG4gICAgICAgICAgICB0aGlzLndlYkdMVmVyc2lvbiA9IDI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLndlYkdMVmVyc2lvbiA9IDE7XHJcbiAgICAgICAgICAgIGdsID0gY2FudmFzLmdldENvbnRleHQoJ3dlYmdsJywgb3B0aW9ucylcclxuICAgICAgICAgICAgICAgIHx8IGNhbnZhcy5nZXRDb250ZXh0KCdleHBlcmltZW50YWwtd2ViZ2wnLCBvcHRpb25zKTtcclxuICAgICAgICAgICAgaWYgKCFnbCkge1xyXG4gICAgICAgICAgICAgICAgLy8gZmFpbCwgbm90IGFibGUgdG8gZ2V0IGEgY29udGV4dFxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBXZWJHTC4gVHJ5IHVzaW5nIHRoZSBjYW52YXMgcmVuZGVyZXInKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmdsID0gZ2w7XHJcbiAgICAgICAgdGhpcy5nZXRFeHRlbnNpb25zKCk7XHJcbiAgICAgICAgcmV0dXJuIGdsO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBdXRvLXBvcHVsYXRlIHRoZSBleHRlbnNpb25zXHJcbiAgICAgKlxyXG4gICAgICogQHByb3RlY3RlZFxyXG4gICAgICovXHJcbiAgICBnZXRFeHRlbnNpb25zKCkge1xyXG4gICAgICAgIC8vIHRpbWUgdG8gc2V0IHVwIGRlZmF1bHQgZXh0ZW5zaW9ucyB0aGF0IFBpeGkgdXNlcy5cclxuICAgICAgICB2YXIgcmVmID0gdGhpcztcclxuICAgICAgICB2YXIgZ2wgPSByZWYuZ2w7XHJcbiAgICAgICAgaWYgKHRoaXMud2ViR0xWZXJzaW9uID09PSAxKSB7XHJcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odGhpcy5leHRlbnNpb25zLCB7XHJcbiAgICAgICAgICAgICAgICBkcmF3QnVmZmVyczogZ2wuZ2V0RXh0ZW5zaW9uKCdXRUJHTF9kcmF3X2J1ZmZlcnMnKSxcclxuICAgICAgICAgICAgICAgIGRlcHRoVGV4dHVyZTogZ2wuZ2V0RXh0ZW5zaW9uKCdXRUJLSVRfV0VCR0xfZGVwdGhfdGV4dHVyZScpLFxyXG4gICAgICAgICAgICAgICAgZmxvYXRUZXh0dXJlOiBnbC5nZXRFeHRlbnNpb24oJ09FU190ZXh0dXJlX2Zsb2F0JyksXHJcbiAgICAgICAgICAgICAgICBsb3NlQ29udGV4dDogZ2wuZ2V0RXh0ZW5zaW9uKCdXRUJHTF9sb3NlX2NvbnRleHQnKSxcclxuICAgICAgICAgICAgICAgIHZlcnRleEFycmF5T2JqZWN0OiBnbC5nZXRFeHRlbnNpb24oJ09FU192ZXJ0ZXhfYXJyYXlfb2JqZWN0JylcclxuICAgICAgICAgICAgICAgICAgICB8fCBnbC5nZXRFeHRlbnNpb24oJ01PWl9PRVNfdmVydGV4X2FycmF5X29iamVjdCcpXHJcbiAgICAgICAgICAgICAgICAgICAgfHwgZ2wuZ2V0RXh0ZW5zaW9uKCdXRUJLSVRfT0VTX3ZlcnRleF9hcnJheV9vYmplY3QnKSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHdlIGRvbid0IHVzZSBhbnkgc3BlY2lmaWMgV2ViR0wgMiBvbmVzIHlldCFcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogSGFuZGxlcyBhIGxvc3Qgd2ViZ2wgY29udGV4dFxyXG4gICAgICpcclxuICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAqIEBwYXJhbSB7V2ViR0xDb250ZXh0RXZlbnR9IGV2ZW50IC0gVGhlIGNvbnRleHQgbG9zdCBldmVudC5cclxuICAgICAqL1xyXG4gICAgaGFuZGxlQ29udGV4dExvc3QoZXZlbnQpIHtcclxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBIYW5kbGVzIGEgcmVzdG9yZWQgd2ViZ2wgY29udGV4dFxyXG4gICAgICpcclxuICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAqL1xyXG4gICAgaGFuZGxlQ29udGV4dFJlc3RvcmVkKCkge1xyXG4gICAgICAgIHRoaXMucmVuZGVyZXIucnVubmVycy5jb250ZXh0Q2hhbmdlLnJ1bih0aGlzLmdsKTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIGRlc3Ryb3koKSB7XHJcbiAgICAgICAgdmFyIHZpZXcgPSB0aGlzLnJlbmRlcmVyLnZpZXc7XHJcbiAgICAgICAgLy8gcmVtb3ZlIGxpc3RlbmVyc1xyXG4gICAgICAgIHZpZXcucmVtb3ZlRXZlbnRMaXN0ZW5lcignd2ViZ2xjb250ZXh0bG9zdCcsIHRoaXMuaGFuZGxlQ29udGV4dExvc3QpO1xyXG4gICAgICAgIHZpZXcucmVtb3ZlRXZlbnRMaXN0ZW5lcignd2ViZ2xjb250ZXh0cmVzdG9yZWQnLCB0aGlzLmhhbmRsZUNvbnRleHRSZXN0b3JlZCk7XHJcbiAgICAgICAgdGhpcy5nbC51c2VQcm9ncmFtKG51bGwpO1xyXG4gICAgICAgIGlmICh0aGlzLmV4dGVuc2lvbnMubG9zZUNvbnRleHQpIHtcclxuICAgICAgICAgICAgdGhpcy5leHRlbnNpb25zLmxvc2VDb250ZXh0Lmxvc2VDb250ZXh0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBIYW5kbGUgdGhlIHBvc3QtcmVuZGVyIHJ1bm5lciBldmVudFxyXG4gICAgICpcclxuICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAqL1xyXG4gICAgcG9zdHJlbmRlcigpIHtcclxuICAgICAgICB0aGlzLmdsLmZsdXNoKCk7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFZhbGlkYXRlIGNvbnRleHRcclxuICAgICAqXHJcbiAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgLSBSZW5kZXIgY29udGV4dFxyXG4gICAgICovXHJcbiAgICB2YWxpZGF0ZUNvbnRleHQoZ2wpIHtcclxuICAgICAgICB2YXIgYXR0cmlidXRlcyA9IGdsLmdldENvbnRleHRBdHRyaWJ1dGVzKCk7XHJcbiAgICAgICAgLy8gdGhpcyBpcyBnb2luZyB0byBiZSBmYWlybHkgc2ltcGxlIGZvciBub3cuLiBidXQgYXQgbGVhc3Qgd2UgaGF2ZSByb29tIHRvIGdyb3chXHJcbiAgICAgICAgaWYgKCFhdHRyaWJ1dGVzLnN0ZW5jaWwpIHtcclxuICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xyXG4gICAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25zb2xlICovXHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignUHJvdmlkZWQgV2ViR0wgY29udGV4dCBkb2VzIG5vdCBoYXZlIGEgc3RlbmNpbCBidWZmZXIsIG1hc2tzIG1heSBub3QgcmVuZGVyIGNvcnJlY3RseScpO1xyXG4gICAgICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLWNvbnNvbGUgKi9cclxuICAgICAgICAgICAgLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuICovXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgO1xyXG59XHJcbkNvbnRleHRTeXN0ZW0uQ09OVEVYVF9VSUQgPSAwO1xyXG5leHBvcnRzLkNvbnRleHRTeXN0ZW0gPSBDb250ZXh0U3lzdGVtO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jbGFzcyBDb3VudExpbWl0ZXIge1xyXG4gICAgY29uc3RydWN0b3IobWF4SXRlbXNQZXJGcmFtZSkge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUaGUgbWF4aW11bSBudW1iZXIgb2YgaXRlbXMgdGhhdCBjYW4gYmUgcHJlcGFyZWQgZWFjaCBmcmFtZS5cclxuICAgICAgICAgICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5tYXhJdGVtc1BlckZyYW1lID0gbWF4SXRlbXNQZXJGcmFtZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgbnVtYmVyIG9mIGl0ZW1zIHRoYXQgY2FuIGJlIHByZXBhcmVkIGluIHRoZSBjdXJyZW50IGZyYW1lLlxyXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLml0ZW1zTGVmdCA9IDA7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlc2V0cyBhbnkgY291bnRpbmcgcHJvcGVydGllcyB0byBzdGFydCBmcmVzaCBvbiBhIG5ldyBmcmFtZS5cclxuICAgICAqL1xyXG4gICAgYmVnaW5GcmFtZSgpIHtcclxuICAgICAgICB0aGlzLml0ZW1zTGVmdCA9IHRoaXMubWF4SXRlbXNQZXJGcmFtZTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2tzIHRvIHNlZSBpZiBhbm90aGVyIGl0ZW0gY2FuIGJlIHVwbG9hZGVkLiBUaGlzIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBvbmNlIHBlciBpdGVtLlxyXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gSWYgdGhlIGl0ZW0gaXMgYWxsb3dlZCB0byBiZSB1cGxvYWRlZC5cclxuICAgICAqL1xyXG4gICAgYWxsb3dlZFRvVXBsb2FkKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLml0ZW1zTGVmdC0tID4gMDtcclxuICAgIH1cclxuICAgIDtcclxufVxyXG5leHBvcnRzLkNvdW50TGltaXRlciA9IENvdW50TGltaXRlcjtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgQXJyYXlSZXNvdXJjZV8xID0gcmVxdWlyZShcIi4vQXJyYXlSZXNvdXJjZVwiKTtcclxuY29uc3QgV2ViR0xTZXR0aW5nc18xID0gcmVxdWlyZShcIi4vV2ViR0xTZXR0aW5nc1wiKTtcclxuY2xhc3MgQ3ViZVJlc291cmNlIGV4dGVuZHMgQXJyYXlSZXNvdXJjZV8xLkFycmF5UmVzb3VyY2Uge1xyXG4gICAgY29uc3RydWN0b3Ioc291cmNlLCBvcHRpb25zKSB7XHJcbiAgICAgICAgc3VwZXIoc291cmNlLCBvcHRpb25zKTtcclxuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuICAgICAgICBpZiAodGhpcy5sZW5ndGggIT09IEN1YmVSZXNvdXJjZS5TSURFUykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKFwiSW52YWxpZCBsZW5ndGguIEdvdCBcIiArICh0aGlzLmxlbmd0aCkgKyBcIiwgZXhwZWN0ZWQgNlwiKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgQ3ViZVJlc291cmNlLlNJREVTOyBpKyspIHtcclxuICAgICAgICAgICAgdGhpcy5pdGVtc1tpXS50YXJnZXQgPSBXZWJHTFNldHRpbmdzXzEuV2ViR0xTZXR0aW5ncy5UQVJHRVRTLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCArIGk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvcHRpb25zLmF1dG9Mb2FkICE9PSBmYWxzZSkge1xyXG4gICAgICAgICAgICB0aGlzLmxvYWQoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFkZCBiaW5kaW5nXHJcbiAgICAgKlxyXG4gICAgICogQG92ZXJyaWRlXHJcbiAgICAgKiBAcGFyYW0ge1BJWEkuQmFzZVRleHR1cmV9IGJhc2VUZXh0dXJlIC0gcGFyZW50IGJhc2UgdGV4dHVyZVxyXG4gICAgICovXHJcbiAgICBiaW5kKGJhc2VUZXh0dXJlKSB7XHJcbiAgICAgICAgc3VwZXIuYmluZChiYXNlVGV4dHVyZSk7XHJcbiAgICAgICAgYmFzZVRleHR1cmUudGFyZ2V0ID0gV2ViR0xTZXR0aW5nc18xLldlYkdMU2V0dGluZ3MuVEFSR0VUUy5URVhUVVJFX0NVQkVfTUFQO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBVcGxvYWQgdGhlIHJlc291cmNlXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaXMgc3VjY2Vzc1xyXG4gICAgICovXHJcbiAgICB1cGxvYWQocmVuZGVyZXIsIGJhc2VUZXh0dXJlLCBnbFRleHR1cmUpIHtcclxuICAgICAgICB2YXIgZGlydHkgPSB0aGlzLml0ZW1EaXJ0eUlkcztcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IEN1YmVSZXNvdXJjZS5TSURFUzsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBzaWRlID0gdGhpcy5pdGVtc1tpXTtcclxuICAgICAgICAgICAgaWYgKGRpcnR5W2ldIDwgc2lkZS5kaXJ0eUlkKSB7XHJcbiAgICAgICAgICAgICAgICBkaXJ0eVtpXSA9IHNpZGUuZGlydHlJZDtcclxuICAgICAgICAgICAgICAgIGlmIChzaWRlLnZhbGlkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2lkZS5yZXNvdXJjZS51cGxvYWQocmVuZGVyZXIsIHNpZGUsIGdsVGV4dHVyZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICA7XHJcbn1cclxuLyoqXHJcbiogTnVtYmVyIG9mIHRleHR1cmUgc2lkZXMgdG8gc3RvcmUgZm9yIEN1YmVSZXNvdXJjZXNcclxuKlxyXG4qIEBuYW1lIFBJWEkucmVzb3VyY2VzLkN1YmVSZXNvdXJjZS5TSURFU1xyXG4qIEBzdGF0aWNcclxuKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiogQGRlZmF1bHQgNlxyXG4qL1xyXG5DdWJlUmVzb3VyY2UuU0lERVMgPSA2O1xyXG5leHBvcnRzLkN1YmVSZXNvdXJjZSA9IEN1YmVSZXNvdXJjZTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgQnVmZmVyUmVzb3VyY2VfMSA9IHJlcXVpcmUoXCIuL0J1ZmZlclJlc291cmNlXCIpO1xyXG5jbGFzcyBEZXB0aFJlc291cmNlIGV4dGVuZHMgQnVmZmVyUmVzb3VyY2VfMS5CdWZmZXJSZXNvdXJjZSB7XHJcbiAgICBjb25zdHJ1Y3Rvcihzb3VyY2UsIG9wdGlvbnMpIHtcclxuICAgICAgICBzdXBlcihzb3VyY2UsIG9wdGlvbnMpO1xyXG4gICAgfVxyXG4gICAgdXBsb2FkKHJlbmRlcmVyLCBiYXNlVGV4dHVyZSwgZ2xUZXh0dXJlKSB7XHJcbiAgICAgICAgdmFyIGdsID0gcmVuZGVyZXIuZ2w7XHJcbiAgICAgICAgZ2wucGl4ZWxTdG9yZWkoZ2wuVU5QQUNLX1BSRU1VTFRJUExZX0FMUEhBX1dFQkdMLCBiYXNlVGV4dHVyZS5wcmVtdWx0aXBseUFscGhhKTtcclxuICAgICAgICBpZiAoZ2xUZXh0dXJlLndpZHRoID09PSBiYXNlVGV4dHVyZS53aWR0aCAmJiBnbFRleHR1cmUuaGVpZ2h0ID09PSBiYXNlVGV4dHVyZS5oZWlnaHQpIHtcclxuICAgICAgICAgICAgZ2wudGV4U3ViSW1hZ2UyRChiYXNlVGV4dHVyZS50YXJnZXQsIDAsIDAsIDAsIGJhc2VUZXh0dXJlLndpZHRoLCBiYXNlVGV4dHVyZS5oZWlnaHQsIGJhc2VUZXh0dXJlLmZvcm1hdCwgYmFzZVRleHR1cmUudHlwZSwgdGhpcy5kYXRhKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGdsVGV4dHVyZS53aWR0aCA9IGJhc2VUZXh0dXJlLndpZHRoO1xyXG4gICAgICAgICAgICBnbFRleHR1cmUuaGVpZ2h0ID0gYmFzZVRleHR1cmUuaGVpZ2h0O1xyXG4gICAgICAgICAgICBnbC50ZXhJbWFnZTJEKGJhc2VUZXh0dXJlLnRhcmdldCwgMCwgZ2wuREVQVEhfQ09NUE9ORU5UMTYsIC8vIE5lZWRlZCBmb3IgZGVwdGggdG8gcmVuZGVyIHByb3Blcmx5IGluIHdlYmdsMi4wXHJcbiAgICAgICAgICAgIGJhc2VUZXh0dXJlLndpZHRoLCBiYXNlVGV4dHVyZS5oZWlnaHQsIDAsIGJhc2VUZXh0dXJlLmZvcm1hdCwgYmFzZVRleHR1cmUudHlwZSwgdGhpcy5kYXRhKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICA7XHJcbn1cclxuZXhwb3J0cy5EZXB0aFJlc291cmNlID0gRGVwdGhSZXNvdXJjZTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgRmlsdGVyXzEgPSByZXF1aXJlKFwiLi9GaWx0ZXJcIik7XHJcbmNvbnN0IE1hdHJpeF8xID0gcmVxdWlyZShcIi4vTWF0cml4XCIpO1xyXG5jb25zdCBQb2ludF8xID0gcmVxdWlyZShcIi4vUG9pbnRcIik7XHJcbmNsYXNzIERpc3BsYWNlbWVudEZpbHRlciBleHRlbmRzIEZpbHRlcl8xLkZpbHRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihzcHJpdGUsIHNjYWxlID0gMSkge1xyXG4gICAgICAgIHZhciBtYXNrTWF0cml4ID0gbmV3IE1hdHJpeF8xLk1hdHJpeCgpO1xyXG4gICAgICAgIHNwcml0ZS5yZW5kZXJhYmxlID0gZmFsc2U7XHJcbiAgICAgICAgc3VwZXIoRGlzcGxhY2VtZW50RmlsdGVyLnZlcnRleCQ0LCBEaXNwbGFjZW1lbnRGaWx0ZXIuZnJhZ21lbnQkNSwgeyBtYXBTYW1wbGVyOiBzcHJpdGUuX3RleHR1cmUsIGZpbHRlck1hdHJpeDogbWFza01hdHJpeCwgc2NhbGU6IHsgeDogMSwgeTogMSB9LCByb3RhdGlvbjogbmV3IEZsb2F0MzJBcnJheShbMSwgMCwgMCwgMV0pLCB9KTtcclxuICAgICAgICB0aGlzLm1hc2tTcHJpdGUgPSBzcHJpdGU7XHJcbiAgICAgICAgdGhpcy5tYXNrTWF0cml4ID0gbWFza01hdHJpeDtcclxuICAgICAgICBpZiAoc2NhbGUgPT09IG51bGwgfHwgc2NhbGUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBzY2FsZSA9IDIwO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBzY2FsZVgsIHNjYWxlWSBmb3IgZGlzcGxhY2VtZW50c1xyXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuUG9pbnR9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5zY2FsZSA9IG5ldyBQb2ludF8xLlBvaW50KHNjYWxlLCBzY2FsZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFwcGxpZXMgdGhlIGZpbHRlci5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1BJWEkuc3lzdGVtcy5GaWx0ZXJTeXN0ZW19IGZpbHRlck1hbmFnZXIgLSBUaGUgbWFuYWdlci5cclxuICAgICAqIEBwYXJhbSB7UElYSS5SZW5kZXJUZXh0dXJlfSBpbnB1dCAtIFRoZSBpbnB1dCB0YXJnZXQuXHJcbiAgICAgKiBAcGFyYW0ge1BJWEkuUmVuZGVyVGV4dHVyZX0gb3V0cHV0IC0gVGhlIG91dHB1dCB0YXJnZXQuXHJcbiAgICAgKi9cclxuICAgIGFwcGx5KGZpbHRlck1hbmFnZXIsIGlucHV0LCBvdXRwdXQpIHtcclxuICAgICAgICB0aGlzLnVuaWZvcm1zLmZpbHRlck1hdHJpeCA9IGZpbHRlck1hbmFnZXIuY2FsY3VsYXRlU3ByaXRlTWF0cml4KHRoaXMubWFza01hdHJpeCwgdGhpcy5tYXNrU3ByaXRlKTtcclxuICAgICAgICB0aGlzLnVuaWZvcm1zLnNjYWxlLnggPSB0aGlzLnNjYWxlLng7XHJcbiAgICAgICAgdGhpcy51bmlmb3Jtcy5zY2FsZS55ID0gdGhpcy5zY2FsZS55O1xyXG4gICAgICAgIC8vIEV4dHJhY3Qgcm90YXRpb24gZnJvbSB3b3JsZCB0cmFuc2Zvcm1cclxuICAgICAgICB2YXIgd3QgPSB0aGlzLm1hc2tTcHJpdGUudHJhbnNmb3JtLndvcmxkVHJhbnNmb3JtO1xyXG4gICAgICAgIHZhciBsZW5YID0gTWF0aC5zcXJ0KCh3dC5hICogd3QuYSkgKyAod3QuYiAqIHd0LmIpKTtcclxuICAgICAgICB2YXIgbGVuWSA9IE1hdGguc3FydCgod3QuYyAqIHd0LmMpICsgKHd0LmQgKiB3dC5kKSk7XHJcbiAgICAgICAgaWYgKGxlblggIT09IDAgJiYgbGVuWSAhPT0gMCkge1xyXG4gICAgICAgICAgICB0aGlzLnVuaWZvcm1zLnJvdGF0aW9uWzBdID0gd3QuYSAvIGxlblg7XHJcbiAgICAgICAgICAgIHRoaXMudW5pZm9ybXMucm90YXRpb25bMV0gPSB3dC5iIC8gbGVuWDtcclxuICAgICAgICAgICAgdGhpcy51bmlmb3Jtcy5yb3RhdGlvblsyXSA9IHd0LmMgLyBsZW5ZO1xyXG4gICAgICAgICAgICB0aGlzLnVuaWZvcm1zLnJvdGF0aW9uWzNdID0gd3QuZCAvIGxlblk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGRyYXcgdGhlIGZpbHRlci4uLlxyXG4gICAgICAgIGZpbHRlck1hbmFnZXIuYXBwbHlGaWx0ZXIodGhpcywgaW5wdXQsIG91dHB1dCk7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSB0ZXh0dXJlIHVzZWQgZm9yIHRoZSBkaXNwbGFjZW1lbnQgbWFwLiBNdXN0IGJlIHBvd2VyIG9mIDIgc2l6ZWQgdGV4dHVyZS5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtQSVhJLlRleHR1cmV9XHJcbiAgICAgKi9cclxuICAgIGdldCBtYXAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudW5pZm9ybXMubWFwU2FtcGxlcjtcclxuICAgIH1cclxuICAgIDtcclxuICAgIHNldCBtYXAodmFsdWUpIHtcclxuICAgICAgICB0aGlzLnVuaWZvcm1zLm1hcFNhbXBsZXIgPSB2YWx1ZTtcclxuICAgIH1cclxuICAgIDtcclxufVxyXG5EaXNwbGFjZW1lbnRGaWx0ZXIuZnJhZ21lbnQkNSA9IFwidmFyeWluZyB2ZWMyIHZGaWx0ZXJDb29yZDtcXHJcXG52YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXHJcXG5cXHJcXG51bmlmb3JtIHZlYzIgc2NhbGU7XFxyXFxudW5pZm9ybSBtYXQyIHJvdGF0aW9uO1xcclxcbnVuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyO1xcclxcbnVuaWZvcm0gc2FtcGxlcjJEIG1hcFNhbXBsZXI7XFxyXFxuXFxyXFxudW5pZm9ybSBoaWdocCB2ZWM0IGlucHV0U2l6ZTtcXHJcXG51bmlmb3JtIHZlYzQgaW5wdXRDbGFtcDtcXHJcXG5cXHJcXG52b2lkIG1haW4odm9pZClcXHJcXG57XFxyXFxuICB2ZWM0IG1hcCA9ICB0ZXh0dXJlMkQobWFwU2FtcGxlciwgdkZpbHRlckNvb3JkKTtcXHJcXG5cXHJcXG4gIG1hcCAtPSAwLjU7XFxyXFxuICBtYXAueHkgPSBzY2FsZSAqIGlucHV0U2l6ZS56dyAqIChyb3RhdGlvbiAqIG1hcC54eSk7XFxyXFxuXFxyXFxuICBnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQodVNhbXBsZXIsIGNsYW1wKHZlYzIodlRleHR1cmVDb29yZC54ICsgbWFwLngsIHZUZXh0dXJlQ29vcmQueSArIG1hcC55KSwgaW5wdXRDbGFtcC54eSwgaW5wdXRDbGFtcC56dykpO1xcclxcbn1cXHJcXG5cIjtcclxuRGlzcGxhY2VtZW50RmlsdGVyLnZlcnRleCQ0ID0gXCJhdHRyaWJ1dGUgdmVjMiBhVmVydGV4UG9zaXRpb247XFxyXFxuXFxyXFxudW5pZm9ybSBtYXQzIHByb2plY3Rpb25NYXRyaXg7XFxyXFxudW5pZm9ybSBtYXQzIGZpbHRlck1hdHJpeDtcXHJcXG5cXHJcXG52YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXHJcXG52YXJ5aW5nIHZlYzIgdkZpbHRlckNvb3JkO1xcclxcblxcclxcbnVuaWZvcm0gdmVjNCBpbnB1dFNpemU7XFxyXFxudW5pZm9ybSB2ZWM0IG91dHB1dEZyYW1lO1xcclxcblxcclxcbnZlYzQgZmlsdGVyVmVydGV4UG9zaXRpb24oIHZvaWQgKVxcclxcbntcXHJcXG4gICAgdmVjMiBwb3NpdGlvbiA9IGFWZXJ0ZXhQb3NpdGlvbiAqIG1heChvdXRwdXRGcmFtZS56dywgdmVjMigwLikpICsgb3V0cHV0RnJhbWUueHk7XFxyXFxuXFxyXFxuICAgIHJldHVybiB2ZWM0KChwcm9qZWN0aW9uTWF0cml4ICogdmVjMyhwb3NpdGlvbiwgMS4wKSkueHksIDAuMCwgMS4wKTtcXHJcXG59XFxyXFxuXFxyXFxudmVjMiBmaWx0ZXJUZXh0dXJlQ29vcmQoIHZvaWQgKVxcclxcbntcXHJcXG4gICAgcmV0dXJuIGFWZXJ0ZXhQb3NpdGlvbiAqIChvdXRwdXRGcmFtZS56dyAqIGlucHV0U2l6ZS56dyk7XFxyXFxufVxcclxcblxcclxcbnZvaWQgbWFpbih2b2lkKVxcclxcbntcXHJcXG5cXHRnbF9Qb3NpdGlvbiA9IGZpbHRlclZlcnRleFBvc2l0aW9uKCk7XFxyXFxuXFx0dlRleHR1cmVDb29yZCA9IGZpbHRlclRleHR1cmVDb29yZCgpO1xcclxcblxcdHZGaWx0ZXJDb29yZCA9ICggZmlsdGVyTWF0cml4ICogdmVjMyggdlRleHR1cmVDb29yZCwgMS4wKSAgKS54eTtcXHJcXG59XFxyXFxuXCI7XHJcbmV4cG9ydHMuRGlzcGxhY2VtZW50RmlsdGVyID0gRGlzcGxhY2VtZW50RmlsdGVyO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBFdmVudERpc3BhdGNoZXJfMSA9IHJlcXVpcmUoXCIuL0V2ZW50RGlzcGF0Y2hlclwiKTtcclxuY29uc3QgUmVjdGFuZ2xlXzEgPSByZXF1aXJlKFwiLi9SZWN0YW5nbGVcIik7XHJcbmNvbnN0IE1hdHJpeF8xID0gcmVxdWlyZShcIi4vTWF0cml4XCIpO1xyXG5jb25zdCBSZW5kZXJUZXh0dXJlXzEgPSByZXF1aXJlKFwiLi9SZW5kZXJUZXh0dXJlXCIpO1xyXG5jb25zdCBCYXNlVGV4dHVyZV8xID0gcmVxdWlyZShcIi4vQmFzZVRleHR1cmVcIik7XHJcbmNvbnN0IFRleHR1cmVfMSA9IHJlcXVpcmUoXCIuL1RleHR1cmVcIik7XHJcbmNvbnN0IEJvdW5kc18xID0gcmVxdWlyZShcIi4vQm91bmRzXCIpO1xyXG5jb25zdCBUcmFuc2Zvcm1fMSA9IHJlcXVpcmUoXCIuL1RyYW5zZm9ybVwiKTtcclxuY29uc3QgUG9pbnRfMSA9IHJlcXVpcmUoXCIuL1BvaW50XCIpO1xyXG5jb25zdCBNYXRoU2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL01hdGhTZXR0aW5nc1wiKTtcclxuY29uc3QgRGlzcGxheVNldHRpbmdzXzEgPSByZXF1aXJlKFwiLi9EaXNwbGF5U2V0dGluZ3NcIik7XHJcbmNsYXNzIERpc3BsYXlPYmplY3QgZXh0ZW5kcyBFdmVudERpc3BhdGNoZXJfMS5FdmVudERpc3BhdGNoZXIge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICAvKiFcclxuICogQHBpeGkvbWl4aW4tZ2V0LWNoaWxkLWJ5LW5hbWUgLSB2NS4wLjAtcmMuM1xyXG4gKiBDb21waWxlZCBXZWQsIDEwIEFwciAyMDE5IDAxOjIxOjE1IFVUQ1xyXG4gKlxyXG4gKiBAcGl4aS9taXhpbi1nZXQtY2hpbGQtYnktbmFtZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXHJcbiAqIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2VcclxuICovXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGluc3RhbmNlIG5hbWUgb2YgdGhlIG9iamVjdC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBQSVhJLkRpc3BsYXlPYmplY3QjXHJcbiAgICAgICAgICogQG1lbWJlciB7c3RyaW5nfSBuYW1lXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5uYW1lID0gbnVsbDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiAgRmxhZyBmb3IgaWYgdGhlIG9iamVjdCBpcyBhY2Nlc3NpYmxlLiBJZiB0cnVlIEFjY2Vzc2liaWxpdHlNYW5hZ2VyIHdpbGwgb3ZlcmxheSBhXHJcbiAgICAgICAgICogICBzaGFkb3cgZGl2IHdpdGggYXR0cmlidXRlcyBzZXRcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XHJcbiAgICAgICAgICogQG1lbWJlcm9mIFBJWEkuRGlzcGxheU9iamVjdCNcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmFjY2Vzc2libGUgPSBmYWxzZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTZXRzIHRoZSB0aXRsZSBhdHRyaWJ1dGUgb2YgdGhlIHNoYWRvdyBkaXZcclxuICAgICAgICAgKiBJZiBhY2Nlc3NpYmxlVGl0bGUgQU5EIGFjY2Vzc2libGVIaW50IGhhcyBub3QgYmVlbiB0aGlzIHdpbGwgZGVmYXVsdCB0byAnZGlzcGxheU9iamVjdCBbdGFiSW5kZXhdJ1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQG1lbWJlciB7P3N0cmluZ31cclxuICAgICAgICAgKiBAbWVtYmVyb2YgUElYSS5EaXNwbGF5T2JqZWN0I1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuYWNjZXNzaWJsZVRpdGxlID0gbnVsbDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTZXRzIHRoZSBhcmlhLWxhYmVsIGF0dHJpYnV0ZSBvZiB0aGUgc2hhZG93IGRpdlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQG1lbWJlciB7c3RyaW5nfVxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBQSVhJLkRpc3BsYXlPYmplY3QjXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5hY2Nlc3NpYmxlSGludCA9IG51bGw7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBQSVhJLkRpc3BsYXlPYmplY3QjXHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKiBAdG9kbyBOZWVkcyBkb2NzLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMudGFiSW5kZXggPSAwO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XHJcbiAgICAgICAgICogQG1lbWJlcm9mIFBJWEkuRGlzcGxheU9iamVjdCNcclxuICAgICAgICAgKiBAdG9kbyBOZWVkcyBkb2NzLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuX2FjY2Vzc2libGVBY3RpdmUgPSBmYWxzZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAbWVtYmVyIHtib29sZWFufVxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBQSVhJLkRpc3BsYXlPYmplY3QjXHJcbiAgICAgICAgICogQHRvZG8gTmVlZHMgZG9jcy5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLl9hY2Nlc3NpYmxlRGl2ID0gZmFsc2U7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgKiBFbmFibGUgaW50ZXJhY3Rpb24gZXZlbnRzIGZvciB0aGUgRGlzcGxheU9iamVjdC4gVG91Y2gsIHBvaW50ZXIgYW5kIG1vdXNlXHJcbiAgICAgICAgKiBldmVudHMgd2lsbCBub3QgYmUgZW1pdHRlZCB1bmxlc3MgYGludGVyYWN0aXZlYCBpcyBzZXQgdG8gYHRydWVgLlxyXG4gICAgICAgICpcclxuICAgICAgICAqIEBleGFtcGxlXHJcbiAgICAgICAgKiBjb25zdCBzcHJpdGUgPSBuZXcgUElYSS5TcHJpdGUodGV4dHVyZSk7XHJcbiAgICAgICAgKiBzcHJpdGUuaW50ZXJhY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgICogc3ByaXRlLm9uKCd0YXAnLCAoZXZlbnQpID0+IHtcclxuICAgICAgICAqICAgIC8vaGFuZGxlIGV2ZW50XHJcbiAgICAgICAgKiB9KTtcclxuICAgICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XHJcbiAgICAgICAgKiBAbWVtYmVyb2YgUElYSS5EaXNwbGF5T2JqZWN0I1xyXG4gICAgICAgICovXHJcbiAgICAgICAgdGhpcy5pbnRlcmFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIERldGVybWluZXMgaWYgdGhlIGNoaWxkcmVuIHRvIHRoZSBkaXNwbGF5T2JqZWN0IGNhbiBiZSBjbGlja2VkL3RvdWNoZWRcclxuICAgICAgICAgKiBTZXR0aW5nIHRoaXMgdG8gZmFsc2UgYWxsb3dzIFBpeGlKUyB0byBieXBhc3MgYSByZWN1cnNpdmUgYGhpdFRlc3RgIGZ1bmN0aW9uXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAbWVtYmVyIHtib29sZWFufVxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBQSVhJLkNvbnRhaW5lciNcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmludGVyYWN0aXZlQ2hpbGRyZW4gPSB0cnVlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEludGVyYWN0aW9uIHNoYXBlLiBDaGlsZHJlbiB3aWxsIGJlIGhpdCBmaXJzdCwgdGhlbiB0aGlzIHNoYXBlIHdpbGwgYmUgY2hlY2tlZC5cclxuICAgICAgICAgKiBTZXR0aW5nIHRoaXMgd2lsbCBjYXVzZSB0aGlzIHNoYXBlIHRvIGJlIGNoZWNrZWQgaW4gaGl0IHRlc3RzIHJhdGhlciB0aGFuIHRoZSBkaXNwbGF5T2JqZWN0J3MgYm91bmRzLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgKiBjb25zdCBzcHJpdGUgPSBuZXcgUElYSS5TcHJpdGUodGV4dHVyZSk7XHJcbiAgICAgICAgICogc3ByaXRlLmludGVyYWN0aXZlID0gdHJ1ZTtcclxuICAgICAgICAgKiBzcHJpdGUuaGl0QXJlYSA9IG5ldyBQSVhJLlJlY3RhbmdsZSgwLCAwLCAxMDAsIDEwMCk7XHJcbiAgICAgICAgICogQG1lbWJlciB7UElYSS5SZWN0YW5nbGV8UElYSS5DaXJjbGV8UElYSS5FbGxpcHNlfFBJWEkuUG9seWdvbnxQSVhJLlJvdW5kZWRSZWN0YW5nbGV9XHJcbiAgICAgICAgICogQG1lbWJlcm9mIFBJWEkuRGlzcGxheU9iamVjdCNcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmhpdEFyZWEgPSBudWxsO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoaXMgZGVmaW5lcyB3aGF0IGN1cnNvciBtb2RlIGlzIHVzZWQgd2hlbiB0aGUgbW91c2UgY3Vyc29yXHJcbiAgICAgICAgICogaXMgaG92ZXJlZCBvdmVyIHRoZSBkaXNwbGF5T2JqZWN0LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgKiBjb25zdCBzcHJpdGUgPSBuZXcgUElYSS5TcHJpdGUodGV4dHVyZSk7XHJcbiAgICAgICAgICogc3ByaXRlLmludGVyYWN0aXZlID0gdHJ1ZTtcclxuICAgICAgICAgKiBzcHJpdGUuY3Vyc29yID0gJ3dhaXQnO1xyXG4gICAgICAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvQ1NTL2N1cnNvclxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQG1lbWJlciB7c3RyaW5nfVxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBQSVhJLkRpc3BsYXlPYmplY3QjXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5jdXJzb3IgPSBudWxsO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIE1hcCBvZiBhbGwgdHJhY2tlZCBwb2ludGVycywgYnkgaWRlbnRpZmllci4gVXNlIHRyYWNrZWRQb2ludGVycyB0byBhY2Nlc3MuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqIEB0eXBlIHtNYXA8bnVtYmVyLCBJbnRlcmFjdGlvblRyYWNraW5nRGF0YT59XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5fdHJhY2tlZFBvaW50ZXJzID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMuX2NhY2hlQXNCaXRtYXAgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9jYWNoZURhdGEgPSBmYWxzZTtcclxuICAgICAgICAvLyBwZXJmb3JtYW5jZSBpbmNyZWFzZSB0byBhdm9pZCB1c2luZyBjYWxsLi4gKDEweCBmYXN0ZXIpXHJcbiAgICAgICAgdGhpcy5kaXNwbGF5T2JqZWN0VXBkYXRlVHJhbnNmb3JtID0gdGhpcy51cGRhdGVUcmFuc2Zvcm07XHJcbiAgICAgICAgdGhpcy50ZW1wRGlzcGxheU9iamVjdFBhcmVudCA9IG51bGw7XHJcbiAgICAgICAgLy8gVE9ETzogbmVlZCB0byBjcmVhdGUgVHJhbnNmb3JtIGZyb20gZmFjdG9yeVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFdvcmxkIHRyYW5zZm9ybSBhbmQgbG9jYWwgdHJhbnNmb3JtIG9mIHRoaXMgb2JqZWN0LlxyXG4gICAgICAgICAqIFRoaXMgd2lsbCBiZWNvbWUgcmVhZC1vbmx5IGxhdGVyLCBwbGVhc2UgZG8gbm90IGFzc2lnbiBhbnl0aGluZyB0aGVyZSB1bmxlc3MgeW91IGtub3cgd2hhdCBhcmUgeW91IGRvaW5nLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQG1lbWJlciB7UElYSS5UcmFuc2Zvcm19XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy50cmFuc2Zvcm0gPSBuZXcgVHJhbnNmb3JtXzEuVHJhbnNmb3JtKCk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIG9wYWNpdHkgb2YgdGhlIG9iamVjdC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmFscGhhID0gMTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgdmlzaWJpbGl0eSBvZiB0aGUgb2JqZWN0LiBJZiBmYWxzZSB0aGUgb2JqZWN0IHdpbGwgbm90IGJlIGRyYXduLCBhbmRcclxuICAgICAgICAgKiB0aGUgdXBkYXRlVHJhbnNmb3JtIGZ1bmN0aW9uIHdpbGwgbm90IGJlIGNhbGxlZC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIE9ubHkgYWZmZWN0cyByZWN1cnNpdmUgY2FsbHMgZnJvbSBwYXJlbnQuIFlvdSBjYW4gYXNrIGZvciBib3VuZHMgb3IgY2FsbCB1cGRhdGVUcmFuc2Zvcm0gbWFudWFsbHkuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAbWVtYmVyIHtib29sZWFufVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMudmlzaWJsZSA9IHRydWU7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2FuIHRoaXMgb2JqZWN0IGJlIHJlbmRlcmVkLCBpZiBmYWxzZSB0aGUgb2JqZWN0IHdpbGwgbm90IGJlIGRyYXduIGJ1dCB0aGUgdXBkYXRlVHJhbnNmb3JtXHJcbiAgICAgICAgICogbWV0aG9kcyB3aWxsIHN0aWxsIGJlIGNhbGxlZC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIE9ubHkgYWZmZWN0cyByZWN1cnNpdmUgY2FsbHMgZnJvbSBwYXJlbnQuIFlvdSBjYW4gYXNrIGZvciBib3VuZHMgbWFudWFsbHkuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAbWVtYmVyIHtib29sZWFufVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMucmVuZGVyYWJsZSA9IHRydWU7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGRpc3BsYXkgb2JqZWN0IGNvbnRhaW5lciB0aGF0IGNvbnRhaW5zIHRoaXMgZGlzcGxheSBvYmplY3QuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLkNvbnRhaW5lcn1cclxuICAgICAgICAgKiBAcmVhZG9ubHlcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnBhcmVudCA9IG51bGw7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIG11bHRpcGxpZWQgYWxwaGEgb2YgdGhlIGRpc3BsYXlPYmplY3QuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgICAgICogQHJlYWRvbmx5XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy53b3JsZEFscGhhID0gMTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBXaGljaCBpbmRleCBpbiB0aGUgY2hpbGRyZW4gYXJyYXkgdGhlIGRpc3BsYXkgY29tcG9uZW50IHdhcyBiZWZvcmUgdGhlIHByZXZpb3VzIHpJbmRleCBzb3J0LlxyXG4gICAgICAgICAqIFVzZWQgYnkgY29udGFpbmVycyB0byBoZWxwIHNvcnQgb2JqZWN0cyB3aXRoIHRoZSBzYW1lIHpJbmRleCwgYnkgdXNpbmcgcHJldmlvdXMgYXJyYXkgaW5kZXggYXMgdGhlIGRlY2lkZXIuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgICAgICogQHByb3RlY3RlZFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuX2xhc3RTb3J0ZWRJbmRleCA9IDA7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIHpJbmRleCBvZiB0aGUgZGlzcGxheU9iamVjdC5cclxuICAgICAgICAgKiBBIGhpZ2hlciB2YWx1ZSB3aWxsIG1lYW4gaXQgd2lsbCBiZSByZW5kZXJlZCBvbiB0b3Agb2Ygb3RoZXIgZGlzcGxheU9iamVjdHMgd2l0aGluIHRoZSBzYW1lIGNvbnRhaW5lci5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5fekluZGV4ID0gMDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgYXJlYSB0aGUgZmlsdGVyIGlzIGFwcGxpZWQgdG8uIFRoaXMgaXMgdXNlZCBhcyBtb3JlIG9mIGFuIG9wdGltaXphdGlvblxyXG4gICAgICAgICAqIHJhdGhlciB0aGFuIGZpZ3VyaW5nIG91dCB0aGUgZGltZW5zaW9ucyBvZiB0aGUgZGlzcGxheU9iamVjdCBlYWNoIGZyYW1lIHlvdSBjYW4gc2V0IHRoaXMgcmVjdGFuZ2xlLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQWxzbyB3b3JrcyBhcyBhbiBpbnRlcmFjdGlvbiBtYXNrLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQG1lbWJlciB7P1BJWEkuUmVjdGFuZ2xlfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuZmlsdGVyQXJlYSA9IG51bGw7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2V0cyB0aGUgZmlsdGVycyBmb3IgdGhlIGRpc3BsYXlPYmplY3QuXHJcbiAgICAgICAgICogKiBJTVBPUlRBTlQ6IFRoaXMgaXMgYSBXZWJHTCBvbmx5IGZlYXR1cmUgYW5kIHdpbGwgYmUgaWdub3JlZCBieSB0aGUgY2FudmFzIHJlbmRlcmVyLlxyXG4gICAgICAgICAqIFRvIHJlbW92ZSBmaWx0ZXJzIHNpbXBseSBzZXQgdGhpcyBwcm9wZXJ0eSB0byBgJ251bGwnYC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBtZW1iZXIgez9QSVhJLkZpbHRlcltdfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuZmlsdGVycyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5fZW5hYmxlZEZpbHRlcnMgPSBudWxsO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBib3VuZHMgb2JqZWN0LCB0aGlzIGlzIHVzZWQgdG8gY2FsY3VsYXRlIGFuZCBzdG9yZSB0aGUgYm91bmRzIG9mIHRoZSBkaXNwbGF5T2JqZWN0LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQG1lbWJlciB7UElYSS5Cb3VuZHN9XHJcbiAgICAgICAgICogQHByb3RlY3RlZFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuX2JvdW5kcyA9IG5ldyBCb3VuZHNfMS5Cb3VuZHMoKTtcclxuICAgICAgICB0aGlzLl9ib3VuZHNJRCA9IDA7XHJcbiAgICAgICAgdGhpcy5fbGFzdEJvdW5kc0lEID0gLTE7XHJcbiAgICAgICAgdGhpcy5fYm91bmRzUmVjdCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5fbG9jYWxCb3VuZHNSZWN0ID0gbnVsbDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgb3JpZ2luYWwsIGNhY2hlZCBtYXNrIG9mIHRoZSBvYmplY3QuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLkdyYXBoaWNzfFBJWEkuU3ByaXRlfVxyXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLl9tYXNrID0gbnVsbDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBGaXJlZCB3aGVuIHRoaXMgRGlzcGxheU9iamVjdCBpcyBhZGRlZCB0byBhIENvbnRhaW5lci5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBldmVudCBQSVhJLkRpc3BsYXlPYmplY3QjYWRkZWRcclxuICAgICAgICAgKiBAcGFyYW0ge1BJWEkuQ29udGFpbmVyfSBjb250YWluZXIgLSBUaGUgY29udGFpbmVyIGFkZGVkIHRvLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEZpcmVkIHdoZW4gdGhpcyBEaXNwbGF5T2JqZWN0IGlzIHJlbW92ZWQgZnJvbSBhIENvbnRhaW5lci5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBldmVudCBQSVhJLkRpc3BsYXlPYmplY3QjcmVtb3ZlZFxyXG4gICAgICAgICAqIEBwYXJhbSB7UElYSS5Db250YWluZXJ9IGNvbnRhaW5lciAtIFRoZSBjb250YWluZXIgcmVtb3ZlZCBmcm9tLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIElmIHRoZSBvYmplY3QgaGFzIGJlZW4gZGVzdHJveWVkIHZpYSBkZXN0cm95KCkuIElmIHRydWUsIGl0IHNob3VsZCBub3QgYmUgdXNlZC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XHJcbiAgICAgICAgICogQHByb3RlY3RlZFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuX2Rlc3Ryb3llZCA9IGZhbHNlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIHVzZWQgdG8gZmFzdCBjaGVjayBpZiBhIHNwcml0ZSBpcy4uIGEgc3ByaXRlIVxyXG4gICAgICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5pc1Nwcml0ZSA9IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAqIEludGVybmFsIHNldCBvZiBhbGwgYWN0aXZlIHBvaW50ZXJzLCBieSBpZGVudGlmaWVyXHJcbiAqXHJcbiAqIEBtZW1iZXIge01hcDxudW1iZXIsIEludGVyYWN0aW9uVHJhY2tpbmdEYXRhPn1cclxuICogQG1lbWJlcm9mIFBJWEkuRGlzcGxheU9iamVjdCNcclxuICogQHByaXZhdGVcclxuICovXHJcbiAgICBnZXQgdHJhY2tlZFBvaW50ZXJzKCkge1xyXG4gICAgICAgIGlmICh0aGlzLl90cmFja2VkUG9pbnRlcnMgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLl90cmFja2VkUG9pbnRlcnMgPSB7fTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RyYWNrZWRQb2ludGVycztcclxuICAgIH1cclxuICAgIC8qIVxyXG4gKiBAcGl4aS9taXhpbi1nZXQtZ2xvYmFsLXBvc2l0aW9uIC0gdjUuMC4wLXJjLjNcclxuICogQ29tcGlsZWQgV2VkLCAxMCBBcHIgMjAxOSAwMToyMToxNSBVVENcclxuICpcclxuICogQHBpeGkvbWl4aW4tZ2V0LWdsb2JhbC1wb3NpdGlvbiBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXHJcbiAqIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2VcclxuICovXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGdsb2JhbCBwb3NpdGlvbiBvZiB0aGUgZGlzcGxheU9iamVjdC4gRG9lcyBub3QgZGVwZW5kIG9uIG9iamVjdCBzY2FsZSwgcm90YXRpb24gYW5kIHBpdm90LlxyXG4gICAgICpcclxuICAgICAqIEBtZXRob2QgZ2V0R2xvYmFsUG9zaXRpb25cclxuICAgICAqIEBtZW1iZXJvZiBQSVhJLkRpc3BsYXlPYmplY3QjXHJcbiAgICAgKiBAcGFyYW0ge1BvaW50fSBwb2ludCAtIFRoZSBwb2ludCB0byB3cml0ZSB0aGUgZ2xvYmFsIHZhbHVlIHRvLiBJZiBudWxsIGEgbmV3IHBvaW50IHdpbGwgYmUgcmV0dXJuZWRcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2tpcFVwZGF0ZSAtIFNldHRpbmcgdG8gdHJ1ZSB3aWxsIHN0b3AgdGhlIHRyYW5zZm9ybXMgb2YgdGhlIHNjZW5lIGdyYXBoIGZyb21cclxuICAgICAqICBiZWluZyB1cGRhdGVkLiBUaGlzIG1lYW5zIHRoZSBjYWxjdWxhdGlvbiByZXR1cm5lZCBNQVkgYmUgb3V0IG9mIGRhdGUgQlVUIHdpbGwgZ2l2ZSB5b3UgYVxyXG4gICAgICogIG5pY2UgcGVyZm9ybWFuY2UgYm9vc3QuXHJcbiAgICAgKiBAcmV0dXJuIHtQb2ludH0gVGhlIHVwZGF0ZWQgcG9pbnQuXHJcbiAgICAgKi9cclxuICAgIGdldEdsb2JhbFBvc2l0aW9uKHBvaW50LCBza2lwVXBkYXRlKSB7XHJcbiAgICAgICAgaWYgKHBvaW50ID09PSB2b2lkIDApIHtcclxuICAgICAgICAgICAgcG9pbnQgPSBuZXcgUG9pbnRfMS5Qb2ludCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc2tpcFVwZGF0ZSA9PT0gdm9pZCAwKSB7XHJcbiAgICAgICAgICAgIHNraXBVcGRhdGUgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMucGFyZW50KSB7XHJcbiAgICAgICAgICAgIHRoaXMucGFyZW50LnRvR2xvYmFsKHRoaXMucG9zaXRpb24sIHBvaW50LCBza2lwVXBkYXRlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHBvaW50LnggPSB0aGlzLnBvc2l0aW9uLng7XHJcbiAgICAgICAgICAgIHBvaW50LnkgPSB0aGlzLnBvc2l0aW9uLnk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwb2ludDtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gKiBJZiBlbmFibGVkLCB0aGUgbW91c2UgY3Vyc29yIHVzZSB0aGUgcG9pbnRlciBiZWhhdmlvciB3aGVuIGhvdmVyZWQgb3ZlciB0aGUgZGlzcGxheU9iamVjdCBpZiBpdCBpcyBpbnRlcmFjdGl2ZVxyXG4gKiBTZXR0aW5nIHRoaXMgY2hhbmdlcyB0aGUgJ2N1cnNvcicgcHJvcGVydHkgdG8gYCdwb2ludGVyJ2AuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIGNvbnN0IHNwcml0ZSA9IG5ldyBQSVhJLlNwcml0ZSh0ZXh0dXJlKTtcclxuICogc3ByaXRlLmludGVyYWN0aXZlID0gdHJ1ZTtcclxuICogc3ByaXRlLmJ1dHRvbk1vZGUgPSB0cnVlO1xyXG4gKiBAbWVtYmVyIHtib29sZWFufVxyXG4gKiBAbWVtYmVyb2YgUElYSS5EaXNwbGF5T2JqZWN0I1xyXG4gKi9cclxuICAgIGdldCBidXR0b25Nb2RlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmN1cnNvciA9PT0gJ3BvaW50ZXInO1xyXG4gICAgfVxyXG4gICAgc2V0IGJ1dHRvbk1vZGUodmFsdWUpIHtcclxuICAgICAgICBpZiAodmFsdWUpIHtcclxuICAgICAgICAgICAgdGhpcy5jdXJzb3IgPSAncG9pbnRlcic7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMuY3Vyc29yID09PSAncG9pbnRlcicpIHtcclxuICAgICAgICAgICAgdGhpcy5jdXJzb3IgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHByb3RlY3RlZFxyXG4gICAgICogQG1lbWJlciB7UElYSS5EaXNwbGF5T2JqZWN0fVxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgbWl4aW4oc291cmNlKSB7XHJcbiAgICAgICAgLy8gaW4gRVM4L0VTMjAxNywgdGhpcyB3b3VsZCBiZSByZWFsbHkgZWFzeTpcclxuICAgICAgICAvLyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpO1xyXG4gICAgICAgIC8vIGdldCBhbGwgdGhlIGVudW1lcmFibGUgcHJvcGVydHkga2V5c1xyXG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcclxuICAgICAgICAvLyBsb29wIHRocm91Z2ggcHJvcGVydGllc1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICB2YXIgcHJvcGVydHlOYW1lID0ga2V5c1tpXTtcclxuICAgICAgICAgICAgLy8gU2V0IHRoZSBwcm9wZXJ0eSB1c2luZyB0aGUgcHJvcGVydHkgZGVzY3JpcHRvciAtIHRoaXMgd29ya3MgZm9yIGFjY2Vzc29ycyBhbmQgbm9ybWFsIHZhbHVlIHByb3BlcnRpZXNcclxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERpc3BsYXlPYmplY3QucHJvdG90eXBlLCBwcm9wZXJ0eU5hbWUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBwcm9wZXJ0eU5hbWUpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICBnZXQgX3RlbXBEaXNwbGF5T2JqZWN0UGFyZW50KCkge1xyXG4gICAgICAgIGlmICh0aGlzLnRlbXBEaXNwbGF5T2JqZWN0UGFyZW50ID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMudGVtcERpc3BsYXlPYmplY3RQYXJlbnQgPSBuZXcgRGlzcGxheU9iamVjdCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy50ZW1wRGlzcGxheU9iamVjdFBhcmVudDtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyB0aGUgb2JqZWN0IHRyYW5zZm9ybSBmb3IgcmVuZGVyaW5nLlxyXG4gICAgICpcclxuICAgICAqIFRPRE8gLSBPcHRpbWl6YXRpb24gcGFzcyFcclxuICAgICAqL1xyXG4gICAgdXBkYXRlVHJhbnNmb3JtKCkge1xyXG4gICAgICAgIHRoaXMudHJhbnNmb3JtLnVwZGF0ZVRyYW5zZm9ybSh0aGlzLnBhcmVudC50cmFuc2Zvcm0pO1xyXG4gICAgICAgIC8vIG11bHRpcGx5IHRoZSBhbHBoYXMuLlxyXG4gICAgICAgIHRoaXMud29ybGRBbHBoYSA9IHRoaXMuYWxwaGEgKiB0aGlzLnBhcmVudC53b3JsZEFscGhhO1xyXG4gICAgICAgIHRoaXMuX2JvdW5kcy51cGRhdGVJRCsrO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZWN1cnNpdmVseSB1cGRhdGVzIHRyYW5zZm9ybSBvZiBhbGwgb2JqZWN0cyBmcm9tIHRoZSByb290IHRvIHRoaXMgb25lXHJcbiAgICAgKiBpbnRlcm5hbCBmdW5jdGlvbiBmb3IgdG9Mb2NhbCgpXHJcbiAgICAgKi9cclxuICAgIF9yZWN1cnNpdmVQb3N0VXBkYXRlVHJhbnNmb3JtKCkge1xyXG4gICAgICAgIGlmICh0aGlzLnBhcmVudCkge1xyXG4gICAgICAgICAgICB0aGlzLnBhcmVudC5fcmVjdXJzaXZlUG9zdFVwZGF0ZVRyYW5zZm9ybSgpO1xyXG4gICAgICAgICAgICB0aGlzLnRyYW5zZm9ybS51cGRhdGVUcmFuc2Zvcm0odGhpcy5wYXJlbnQudHJhbnNmb3JtKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtLnVwZGF0ZVRyYW5zZm9ybSh0aGlzLl90ZW1wRGlzcGxheU9iamVjdFBhcmVudC50cmFuc2Zvcm0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogUmV0cmlldmVzIHRoZSBib3VuZHMgb2YgdGhlIGRpc3BsYXlPYmplY3QgYXMgYSByZWN0YW5nbGUgb2JqZWN0LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3NraXBVcGRhdGVdIC0gU2V0dGluZyB0byBgdHJ1ZWAgd2lsbCBzdG9wIHRoZSB0cmFuc2Zvcm1zIG9mIHRoZSBzY2VuZSBncmFwaCBmcm9tXHJcbiAgICAgKiAgYmVpbmcgdXBkYXRlZC4gVGhpcyBtZWFucyB0aGUgY2FsY3VsYXRpb24gcmV0dXJuZWQgTUFZIGJlIG91dCBvZiBkYXRlIEJVVCB3aWxsIGdpdmUgeW91IGFcclxuICAgICAqICBuaWNlIHBlcmZvcm1hbmNlIGJvb3N0LlxyXG4gICAgICogQHBhcmFtIHtQSVhJLlJlY3RhbmdsZX0gW3JlY3RdIC0gT3B0aW9uYWwgcmVjdGFuZ2xlIHRvIHN0b3JlIHRoZSByZXN1bHQgb2YgdGhlIGJvdW5kcyBjYWxjdWxhdGlvbi5cclxuICAgICAqIEByZXR1cm4ge1BJWEkuUmVjdGFuZ2xlfSBUaGUgcmVjdGFuZ3VsYXIgYm91bmRpbmcgYXJlYS5cclxuICAgICAqL1xyXG4gICAgZ2V0Qm91bmRzKHNraXBVcGRhdGUgPSB0cnVlLCByZWN0ID0gbnVsbCkge1xyXG4gICAgICAgIGlmICghc2tpcFVwZGF0ZSkge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMucGFyZW50KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudCA9IHRoaXMuX3RlbXBEaXNwbGF5T2JqZWN0UGFyZW50O1xyXG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVUcmFuc2Zvcm0oKTtcclxuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50ID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3JlY3Vyc2l2ZVBvc3RVcGRhdGVUcmFuc2Zvcm0oKTtcclxuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlVHJhbnNmb3JtKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuX2JvdW5kc0lEICE9PSB0aGlzLl9sYXN0Qm91bmRzSUQpIHtcclxuICAgICAgICAgICAgdGhpcy5jYWxjdWxhdGVCb3VuZHMoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFyZWN0KSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5fYm91bmRzUmVjdCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYm91bmRzUmVjdCA9IG5ldyBSZWN0YW5nbGVfMS5SZWN0YW5nbGUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZWN0ID0gdGhpcy5fYm91bmRzUmVjdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2JvdW5kcy5nZXRSZWN0YW5nbGUocmVjdCk7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICBjYWxjdWxhdGVCb3VuZHMoKSB7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHJpZXZlcyB0aGUgbG9jYWwgYm91bmRzIG9mIHRoZSBkaXNwbGF5T2JqZWN0IGFzIGEgcmVjdGFuZ2xlIG9iamVjdC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1BJWEkuUmVjdGFuZ2xlfSBbcmVjdF0gLSBPcHRpb25hbCByZWN0YW5nbGUgdG8gc3RvcmUgdGhlIHJlc3VsdCBvZiB0aGUgYm91bmRzIGNhbGN1bGF0aW9uLlxyXG4gICAgICogQHJldHVybiB7UElYSS5SZWN0YW5nbGV9IFRoZSByZWN0YW5ndWxhciBib3VuZGluZyBhcmVhLlxyXG4gICAgICovXHJcbiAgICBnZXRMb2NhbEJvdW5kcyhyZWN0ID0gbnVsbCkge1xyXG4gICAgICAgIHZhciB0cmFuc2Zvcm1SZWYgPSB0aGlzLnRyYW5zZm9ybTtcclxuICAgICAgICB2YXIgcGFyZW50UmVmID0gdGhpcy5wYXJlbnQ7XHJcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBudWxsO1xyXG4gICAgICAgIHRoaXMudHJhbnNmb3JtID0gdGhpcy5fdGVtcERpc3BsYXlPYmplY3RQYXJlbnQudHJhbnNmb3JtO1xyXG4gICAgICAgIGlmICghcmVjdCkge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX2xvY2FsQm91bmRzUmVjdCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbG9jYWxCb3VuZHNSZWN0ID0gbmV3IFJlY3RhbmdsZV8xLlJlY3RhbmdsZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJlY3QgPSB0aGlzLl9sb2NhbEJvdW5kc1JlY3Q7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBib3VuZHMgPSB0aGlzLmdldEJvdW5kcyhmYWxzZSwgcmVjdCk7XHJcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnRSZWY7XHJcbiAgICAgICAgdGhpcy50cmFuc2Zvcm0gPSB0cmFuc2Zvcm1SZWY7XHJcbiAgICAgICAgcmV0dXJuIGJvdW5kcztcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQ2FsY3VsYXRlcyB0aGUgZ2xvYmFsIHBvc2l0aW9uIG9mIHRoZSBkaXNwbGF5IG9iamVjdC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1BJWEkuSVBvaW50fSBwb3NpdGlvbiAtIFRoZSB3b3JsZCBvcmlnaW4gdG8gY2FsY3VsYXRlIGZyb20uXHJcbiAgICAgKiBAcGFyYW0ge1BJWEkuSVBvaW50fSBbcG9pbnRdIC0gQSBQb2ludCBvYmplY3QgaW4gd2hpY2ggdG8gc3RvcmUgdGhlIHZhbHVlLCBvcHRpb25hbFxyXG4gICAgICogIChvdGhlcndpc2Ugd2lsbCBjcmVhdGUgYSBuZXcgUG9pbnQpLlxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbc2tpcFVwZGF0ZT1mYWxzZV0gLSBTaG91bGQgd2Ugc2tpcCB0aGUgdXBkYXRlIHRyYW5zZm9ybS5cclxuICAgICAqIEByZXR1cm4ge1BJWEkuSVBvaW50fSBBIHBvaW50IG9iamVjdCByZXByZXNlbnRpbmcgdGhlIHBvc2l0aW9uIG9mIHRoaXMgb2JqZWN0LlxyXG4gICAgICovXHJcbiAgICB0b0dsb2JhbChwb3NpdGlvbiwgcG9pbnQsIHNraXBVcGRhdGUpIHtcclxuICAgICAgICBpZiAoc2tpcFVwZGF0ZSA9PT0gdm9pZCAwKSB7XHJcbiAgICAgICAgICAgIHNraXBVcGRhdGUgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFza2lwVXBkYXRlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3JlY3Vyc2l2ZVBvc3RVcGRhdGVUcmFuc2Zvcm0oKTtcclxuICAgICAgICAgICAgLy8gdGhpcyBwYXJlbnQgY2hlY2sgaXMgZm9yIGp1c3QgaW4gY2FzZSB0aGUgaXRlbSBpcyBhIHJvb3Qgb2JqZWN0LlxyXG4gICAgICAgICAgICAvLyBJZiBpdCBpcyB3ZSBuZWVkIHRvIGdpdmUgaXQgYSB0ZW1wb3JhcnkgcGFyZW50IHNvIHRoYXQgZGlzcGxheU9iamVjdFVwZGF0ZVRyYW5zZm9ybSB3b3JrcyBjb3JyZWN0bHlcclxuICAgICAgICAgICAgLy8gdGhpcyBpcyBtYWlubHkgdG8gYXZvaWQgYSBwYXJlbnQgY2hlY2sgaW4gdGhlIG1haW4gbG9vcC4gRXZlcnkgbGl0dGxlIGhlbHBzIGZvciBwZXJmb3JtYW5jZSA6KVxyXG4gICAgICAgICAgICBpZiAoIXRoaXMucGFyZW50KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudCA9IHRoaXMuX3RlbXBEaXNwbGF5T2JqZWN0UGFyZW50O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwbGF5T2JqZWN0VXBkYXRlVHJhbnNmb3JtKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudCA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BsYXlPYmplY3RVcGRhdGVUcmFuc2Zvcm0oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBkb24ndCBuZWVkIHRvIHVwZGF0ZSB0aGUgbG90XHJcbiAgICAgICAgcmV0dXJuIHRoaXMud29ybGRUcmFuc2Zvcm0uYXBwbHkocG9zaXRpb24sIHBvaW50KTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQ2FsY3VsYXRlcyB0aGUgbG9jYWwgcG9zaXRpb24gb2YgdGhlIGRpc3BsYXkgb2JqZWN0IHJlbGF0aXZlIHRvIGFub3RoZXIgcG9pbnQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtQSVhJLklQb2ludH0gcG9zaXRpb24gLSBUaGUgd29ybGQgb3JpZ2luIHRvIGNhbGN1bGF0ZSBmcm9tLlxyXG4gICAgICogQHBhcmFtIHtQSVhJLkRpc3BsYXlPYmplY3R9IFtmcm9tXSAtIFRoZSBEaXNwbGF5T2JqZWN0IHRvIGNhbGN1bGF0ZSB0aGUgZ2xvYmFsIHBvc2l0aW9uIGZyb20uXHJcbiAgICAgKiBAcGFyYW0ge1BJWEkuSVBvaW50fSBbcG9pbnRdIC0gQSBQb2ludCBvYmplY3QgaW4gd2hpY2ggdG8gc3RvcmUgdGhlIHZhbHVlLCBvcHRpb25hbFxyXG4gICAgICogIChvdGhlcndpc2Ugd2lsbCBjcmVhdGUgYSBuZXcgUG9pbnQpLlxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbc2tpcFVwZGF0ZT1mYWxzZV0gLSBTaG91bGQgd2Ugc2tpcCB0aGUgdXBkYXRlIHRyYW5zZm9ybVxyXG4gICAgICogQHJldHVybiB7UElYSS5JUG9pbnR9IEEgcG9pbnQgb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgcG9zaXRpb24gb2YgdGhpcyBvYmplY3RcclxuICAgICAqL1xyXG4gICAgdG9Mb2NhbChwb3NpdGlvbiwgZnJvbSwgcG9pbnQsIHNraXBVcGRhdGUpIHtcclxuICAgICAgICBpZiAoZnJvbSkge1xyXG4gICAgICAgICAgICBwb3NpdGlvbiA9IGZyb20udG9HbG9iYWwocG9zaXRpb24sIHBvaW50LCBza2lwVXBkYXRlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFza2lwVXBkYXRlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3JlY3Vyc2l2ZVBvc3RVcGRhdGVUcmFuc2Zvcm0oKTtcclxuICAgICAgICAgICAgLy8gdGhpcyBwYXJlbnQgY2hlY2sgaXMgZm9yIGp1c3QgaW4gY2FzZSB0aGUgaXRlbSBpcyBhIHJvb3Qgb2JqZWN0LlxyXG4gICAgICAgICAgICAvLyBJZiBpdCBpcyB3ZSBuZWVkIHRvIGdpdmUgaXQgYSB0ZW1wb3JhcnkgcGFyZW50IHNvIHRoYXQgZGlzcGxheU9iamVjdFVwZGF0ZVRyYW5zZm9ybSB3b3JrcyBjb3JyZWN0bHlcclxuICAgICAgICAgICAgLy8gdGhpcyBpcyBtYWlubHkgdG8gYXZvaWQgYSBwYXJlbnQgY2hlY2sgaW4gdGhlIG1haW4gbG9vcC4gRXZlcnkgbGl0dGxlIGhlbHBzIGZvciBwZXJmb3JtYW5jZSA6KVxyXG4gICAgICAgICAgICBpZiAoIXRoaXMucGFyZW50KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudCA9IHRoaXMuX3RlbXBEaXNwbGF5T2JqZWN0UGFyZW50O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwbGF5T2JqZWN0VXBkYXRlVHJhbnNmb3JtKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudCA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BsYXlPYmplY3RVcGRhdGVUcmFuc2Zvcm0oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBzaW1wbHkgYXBwbHkgdGhlIG1hdHJpeC4uXHJcbiAgICAgICAgcmV0dXJuIHRoaXMud29ybGRUcmFuc2Zvcm0uYXBwbHlJbnZlcnNlKHBvc2l0aW9uLCBwb2ludCk7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFJlbmRlcnMgdGhlIG9iamVjdCB1c2luZyB0aGUgV2ViR0wgcmVuZGVyZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtQSVhJLlJlbmRlcmVyfSByZW5kZXJlciAtIFRoZSByZW5kZXJlci5cclxuICAgICAqL1xyXG4gICAgcmVuZGVyKHJlbmRlcmVyKSB7XHJcbiAgICAgICAgLy8gT1ZFUldSSVRFO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhlIHBhcmVudCBDb250YWluZXIgb2YgdGhpcyBEaXNwbGF5T2JqZWN0LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7UElYSS5Db250YWluZXJ9IGNvbnRhaW5lciAtIFRoZSBDb250YWluZXIgdG8gYWRkIHRoaXMgRGlzcGxheU9iamVjdCB0by5cclxuICAgICAqIEByZXR1cm4ge1BJWEkuQ29udGFpbmVyfSBUaGUgQ29udGFpbmVyIHRoYXQgdGhpcyBEaXNwbGF5T2JqZWN0IHdhcyBhZGRlZCB0by5cclxuICAgICAqL1xyXG4gICAgc2V0UGFyZW50KGNvbnRhaW5lcikge1xyXG4gICAgICAgIGlmICghY29udGFpbmVyIHx8ICFjb250YWluZXIuYWRkQ2hpbGQpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzZXRQYXJlbnQ6IEFyZ3VtZW50IG11c3QgYmUgYSBDb250YWluZXInKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29udGFpbmVyLmFkZENoaWxkKHRoaXMpO1xyXG4gICAgICAgIHJldHVybiBjb250YWluZXI7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIENvbnZlbmllbmNlIGZ1bmN0aW9uIHRvIHNldCB0aGUgcG9zaXRpb24sIHNjYWxlLCBza2V3IGFuZCBwaXZvdCBhdCBvbmNlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbeD0wXSAtIFRoZSBYIHBvc2l0aW9uXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3k9MF0gLSBUaGUgWSBwb3NpdGlvblxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzY2FsZVg9MV0gLSBUaGUgWCBzY2FsZSB2YWx1ZVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzY2FsZVk9MV0gLSBUaGUgWSBzY2FsZSB2YWx1ZVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtyb3RhdGlvbj0wXSAtIFRoZSByb3RhdGlvblxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtza2V3WD0wXSAtIFRoZSBYIHNrZXcgdmFsdWVcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc2tld1k9MF0gLSBUaGUgWSBza2V3IHZhbHVlXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3Bpdm90WD0wXSAtIFRoZSBYIHBpdm90IHZhbHVlXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3Bpdm90WT0wXSAtIFRoZSBZIHBpdm90IHZhbHVlXHJcbiAgICAgKiBAcmV0dXJuIHtQSVhJLkRpc3BsYXlPYmplY3R9IFRoZSBEaXNwbGF5T2JqZWN0IGluc3RhbmNlXHJcbiAgICAgKi9cclxuICAgIHNldFRyYW5zZm9ybSh4LCB5LCBzY2FsZVgsIHNjYWxlWSwgcm90YXRpb24sIHNrZXdYLCBza2V3WSwgcGl2b3RYLCBwaXZvdFkpIHtcclxuICAgICAgICBpZiAoeCA9PT0gdm9pZCAwKSB7XHJcbiAgICAgICAgICAgIHggPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoeSA9PT0gdm9pZCAwKSB7XHJcbiAgICAgICAgICAgIHkgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc2NhbGVYID09PSB2b2lkIDApIHtcclxuICAgICAgICAgICAgc2NhbGVYID0gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHNjYWxlWSA9PT0gdm9pZCAwKSB7XHJcbiAgICAgICAgICAgIHNjYWxlWSA9IDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChyb3RhdGlvbiA9PT0gdm9pZCAwKSB7XHJcbiAgICAgICAgICAgIHJvdGF0aW9uID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHNrZXdYID09PSB2b2lkIDApIHtcclxuICAgICAgICAgICAgc2tld1ggPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc2tld1kgPT09IHZvaWQgMCkge1xyXG4gICAgICAgICAgICBza2V3WSA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwaXZvdFggPT09IHZvaWQgMCkge1xyXG4gICAgICAgICAgICBwaXZvdFggPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocGl2b3RZID09PSB2b2lkIDApIHtcclxuICAgICAgICAgICAgcGl2b3RZID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5wb3NpdGlvbi54ID0geDtcclxuICAgICAgICB0aGlzLnBvc2l0aW9uLnkgPSB5O1xyXG4gICAgICAgIHRoaXMuc2NhbGUueCA9ICFzY2FsZVggPyAxIDogc2NhbGVYO1xyXG4gICAgICAgIHRoaXMuc2NhbGUueSA9ICFzY2FsZVkgPyAxIDogc2NhbGVZO1xyXG4gICAgICAgIHRoaXMucm90YXRpb24gPSByb3RhdGlvbjtcclxuICAgICAgICB0aGlzLnNrZXcueCA9IHNrZXdYO1xyXG4gICAgICAgIHRoaXMuc2tldy55ID0gc2tld1k7XHJcbiAgICAgICAgdGhpcy5waXZvdC54ID0gcGl2b3RYO1xyXG4gICAgICAgIHRoaXMucGl2b3QueSA9IHBpdm90WTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQmFzZSBkZXN0cm95IG1ldGhvZCBmb3IgZ2VuZXJpYyBkaXNwbGF5IG9iamVjdHMuIFRoaXMgd2lsbCBhdXRvbWF0aWNhbGx5XHJcbiAgICAgKiByZW1vdmUgdGhlIGRpc3BsYXkgb2JqZWN0IGZyb20gaXRzIHBhcmVudCBDb250YWluZXIgYXMgd2VsbCBhcyByZW1vdmVcclxuICAgICAqIGFsbCBjdXJyZW50IGV2ZW50IGxpc3RlbmVycyBhbmQgaW50ZXJuYWwgcmVmZXJlbmNlcy4gRG8gbm90IHVzZSBhIERpc3BsYXlPYmplY3RcclxuICAgICAqIGFmdGVyIGNhbGxpbmcgYGRlc3Ryb3koKWAuXHJcbiAgICAgKlxyXG4gICAgICovXHJcbiAgICBkZXN0cm95KG9wdGlvbnMgPSBudWxsKSB7XHJcbiAgICAgICAgLy8gdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcclxuICAgICAgICBpZiAodGhpcy5wYXJlbnQpIHtcclxuICAgICAgICAgICAgdGhpcy5wYXJlbnQucmVtb3ZlQ2hpbGQodGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMudHJhbnNmb3JtID0gbnVsbDtcclxuICAgICAgICB0aGlzLnBhcmVudCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5fYm91bmRzID0gbnVsbDtcclxuICAgICAgICB0aGlzLl9jdXJyZW50Qm91bmRzID0gbnVsbDtcclxuICAgICAgICB0aGlzLl9tYXNrID0gbnVsbDtcclxuICAgICAgICB0aGlzLmZpbHRlckFyZWEgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuaW50ZXJhY3RpdmUgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmludGVyYWN0aXZlQ2hpbGRyZW4gPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9kZXN0cm95ZWQgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgcG9zaXRpb24gb2YgdGhlIGRpc3BsYXlPYmplY3Qgb24gdGhlIHggYXhpcyByZWxhdGl2ZSB0byB0aGUgbG9jYWwgY29vcmRpbmF0ZXMgb2YgdGhlIHBhcmVudC5cclxuICAgICAqIEFuIGFsaWFzIHRvIHBvc2l0aW9uLnhcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIGdldCB4KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnBvc2l0aW9uLng7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICBzZXQgeCh2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMudHJhbnNmb3JtLnBvc2l0aW9uLnggPSB2YWx1ZTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIHBvc2l0aW9uIG9mIHRoZSBkaXNwbGF5T2JqZWN0IG9uIHRoZSB5IGF4aXMgcmVsYXRpdmUgdG8gdGhlIGxvY2FsIGNvb3JkaW5hdGVzIG9mIHRoZSBwYXJlbnQuXHJcbiAgICAgKiBBbiBhbGlhcyB0byBwb3NpdGlvbi55XHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICBnZXQgeSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5wb3NpdGlvbi55O1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgc2V0IHkodmFsdWUpIHtcclxuICAgICAgICB0aGlzLnRyYW5zZm9ybS5wb3NpdGlvbi55ID0gdmFsdWU7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIEN1cnJlbnQgdHJhbnNmb3JtIG9mIHRoZSBvYmplY3QgYmFzZWQgb24gd29ybGQgKHBhcmVudCkgZmFjdG9ycy5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtQSVhJLk1hdHJpeH1cclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICovXHJcbiAgICBnZXQgd29ybGRUcmFuc2Zvcm0oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtLndvcmxkVHJhbnNmb3JtO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDdXJyZW50IHRyYW5zZm9ybSBvZiB0aGUgb2JqZWN0IGJhc2VkIG9uIGxvY2FsIGZhY3RvcnM6IHBvc2l0aW9uLCBzY2FsZSwgb3RoZXIgc3R1ZmYuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7UElYSS5NYXRyaXh9XHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqL1xyXG4gICAgZ2V0IGxvY2FsVHJhbnNmb3JtKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybS5sb2NhbFRyYW5zZm9ybTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGNvb3JkaW5hdGUgb2YgdGhlIG9iamVjdCByZWxhdGl2ZSB0byB0aGUgbG9jYWwgY29vcmRpbmF0ZXMgb2YgdGhlIHBhcmVudC5cclxuICAgICAqIEFzc2lnbm1lbnQgYnkgdmFsdWUgc2luY2UgcGl4aS12NC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtQSVhJLklQb2ludH1cclxuICAgICAqL1xyXG4gICAgZ2V0IHBvc2l0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybS5wb3NpdGlvbjtcclxuICAgIH1cclxuICAgIDtcclxuICAgIHNldCBwb3NpdGlvbih2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMudHJhbnNmb3JtLnBvc2l0aW9uLmNvcHlGcm9tKHZhbHVlKTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIHNjYWxlIGZhY3RvciBvZiB0aGUgb2JqZWN0LlxyXG4gICAgICogQXNzaWdubWVudCBieSB2YWx1ZSBzaW5jZSBwaXhpLXY0LlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge1BJWEkuSVBvaW50fVxyXG4gICAgICovXHJcbiAgICBnZXQgc2NhbGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtLnNjYWxlO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgc2V0IHNjYWxlKHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy50cmFuc2Zvcm0uc2NhbGUuY29weUZyb20odmFsdWUpO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgcGl2b3QgcG9pbnQgb2YgdGhlIGRpc3BsYXlPYmplY3QgdGhhdCBpdCByb3RhdGVzIGFyb3VuZC5cclxuICAgICAqIEFzc2lnbm1lbnQgYnkgdmFsdWUgc2luY2UgcGl4aS12NC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtQSVhJLklQb2ludH1cclxuICAgICAqL1xyXG4gICAgZ2V0IHBpdm90KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybS5waXZvdDtcclxuICAgIH1cclxuICAgIDtcclxuICAgIHNldCBwaXZvdCh2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMudHJhbnNmb3JtLnBpdm90LmNvcHlGcm9tKHZhbHVlKTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIHNrZXcgZmFjdG9yIGZvciB0aGUgb2JqZWN0IGluIHJhZGlhbnMuXHJcbiAgICAgKiBBc3NpZ25tZW50IGJ5IHZhbHVlIHNpbmNlIHBpeGktdjQuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7UElYSS5PYnNlcnZhYmxlUG9pbnR9XHJcbiAgICAgKi9cclxuICAgIGdldCBza2V3KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybS5za2V3O1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgc2V0IHNrZXcodmFsdWUpIHtcclxuICAgICAgICB0aGlzLnRyYW5zZm9ybS5za2V3LmNvcHlGcm9tKHZhbHVlKTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIHJvdGF0aW9uIG9mIHRoZSBvYmplY3QgaW4gcmFkaWFucy5cclxuICAgICAqICdyb3RhdGlvbicgYW5kICdhbmdsZScgaGF2ZSB0aGUgc2FtZSBlZmZlY3Qgb24gYSBkaXNwbGF5IG9iamVjdDsgcm90YXRpb24gaXMgaW4gcmFkaWFucywgYW5nbGUgaXMgaW4gZGVncmVlcy5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIGdldCByb3RhdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0ucm90YXRpb247XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICBzZXQgcm90YXRpb24odmFsdWUpIHtcclxuICAgICAgICB0aGlzLnRyYW5zZm9ybS5yb3RhdGlvbiA9IHZhbHVlO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgYW5nbGUgb2YgdGhlIG9iamVjdCBpbiBkZWdyZWVzLlxyXG4gICAgICogJ3JvdGF0aW9uJyBhbmQgJ2FuZ2xlJyBoYXZlIHRoZSBzYW1lIGVmZmVjdCBvbiBhIGRpc3BsYXkgb2JqZWN0OyByb3RhdGlvbiBpcyBpbiByYWRpYW5zLCBhbmdsZSBpcyBpbiBkZWdyZWVzLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgZ2V0IGFuZ2xlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybS5yb3RhdGlvbiAqIE1hdGhTZXR0aW5nc18xLk1hdGhTZXR0aW5ncy5SQURfVE9fREVHO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgc2V0IGFuZ2xlKHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy50cmFuc2Zvcm0ucm90YXRpb24gPSB2YWx1ZSAqIE1hdGhTZXR0aW5nc18xLk1hdGhTZXR0aW5ncy5ERUdfVE9fUkFEO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgekluZGV4IG9mIHRoZSBkaXNwbGF5T2JqZWN0LlxyXG4gICAgICogSWYgYSBjb250YWluZXIgaGFzIHRoZSBzb3J0YWJsZUNoaWxkcmVuIHByb3BlcnR5IHNldCB0byB0cnVlLCBjaGlsZHJlbiB3aWxsIGJlIGF1dG9tYXRpY2FsbHlcclxuICAgICAqIHNvcnRlZCBieSB6SW5kZXggdmFsdWU7IGEgaGlnaGVyIHZhbHVlIHdpbGwgbWVhbiBpdCB3aWxsIGJlIG1vdmVkIHRvd2FyZHMgdGhlIGVuZCBvZiB0aGUgYXJyYXksXHJcbiAgICAgKiBhbmQgdGh1cyByZW5kZXJlZCBvbiB0b3Agb2Ygb3RoZXIgZGlzcGxheU9iamVjdHMgd2l0aGluIHRoZSBzYW1lIGNvbnRhaW5lci5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIGdldCB6SW5kZXgoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3pJbmRleDtcclxuICAgIH1cclxuICAgIDtcclxuICAgIHNldCB6SW5kZXgodmFsdWUpIHtcclxuICAgICAgICB0aGlzLl96SW5kZXggPSB2YWx1ZTtcclxuICAgICAgICBpZiAodGhpcy5wYXJlbnQpIHtcclxuICAgICAgICAgICAgdGhpcy5wYXJlbnQuc29ydERpcnR5ID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIEluZGljYXRlcyBpZiB0aGUgb2JqZWN0IGlzIGdsb2JhbGx5IHZpc2libGUuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7Ym9vbGVhbn1cclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICovXHJcbiAgICBnZXQgd29ybGRWaXNpYmxlKCkge1xyXG4gICAgICAgIHZhciBpdGVtID0gdGhpcztcclxuICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgIGlmICghaXRlbS52aXNpYmxlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaXRlbSA9IGl0ZW0ucGFyZW50O1xyXG4gICAgICAgIH0gd2hpbGUgKGl0ZW0pO1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIGEgbWFzayBmb3IgdGhlIGRpc3BsYXlPYmplY3QuIEEgbWFzayBpcyBhbiBvYmplY3QgdGhhdCBsaW1pdHMgdGhlIHZpc2liaWxpdHkgb2YgYW5cclxuICAgICAqIG9iamVjdCB0byB0aGUgc2hhcGUgb2YgdGhlIG1hc2sgYXBwbGllZCB0byBpdC4gSW4gUGl4aUpTIGEgcmVndWxhciBtYXNrIG11c3QgYmUgYVxyXG4gICAgICoge0BsaW5rIFBJWEkuR3JhcGhpY3N9IG9yIGEge0BsaW5rIFBJWEkuU3ByaXRlfSBvYmplY3QuIFRoaXMgYWxsb3dzIGZvciBtdWNoIGZhc3RlciBtYXNraW5nIGluIGNhbnZhcyBhcyBpdFxyXG4gICAgICogdXRpbGl0aWVzIHNoYXBlIGNsaXBwaW5nLiBUbyByZW1vdmUgYSBtYXNrLCBzZXQgdGhpcyBwcm9wZXJ0eSB0byBgbnVsbGAuXHJcbiAgICAgKlxyXG4gICAgICogRm9yIHNwcml0ZSBtYXNrIGJvdGggYWxwaGEgYW5kIHJlZCBjaGFubmVsIGFyZSB1c2VkLiBCbGFjayBtYXNrIGlzIHRoZSBzYW1lIGFzIHRyYW5zcGFyZW50IG1hc2suXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogY29uc3QgZ3JhcGhpY3MgPSBuZXcgUElYSS5HcmFwaGljcygpO1xyXG4gICAgICogZ3JhcGhpY3MuYmVnaW5GaWxsKDB4RkYzMzAwKTtcclxuICAgICAqIGdyYXBoaWNzLmRyYXdSZWN0KDUwLCAyNTAsIDEwMCwgMTAwKTtcclxuICAgICAqIGdyYXBoaWNzLmVuZEZpbGwoKTtcclxuICAgICAqXHJcbiAgICAgKiBjb25zdCBzcHJpdGUgPSBuZXcgUElYSS5TcHJpdGUodGV4dHVyZSk7XHJcbiAgICAgKiBzcHJpdGUubWFzayA9IGdyYXBoaWNzO1xyXG4gICAgICogQHRvZG8gQXQgdGhlIG1vbWVudCwgUElYSS5DYW52YXNSZW5kZXJlciBkb2Vzbid0IHN1cHBvcnQgUElYSS5TcHJpdGUgYXMgbWFzay5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtQSVhJLkdyYXBoaWNzfFBJWEkuU3ByaXRlfVxyXG4gICAgICovXHJcbiAgICBnZXQgbWFzaygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbWFzaztcclxuICAgIH1cclxuICAgIDtcclxuICAgIHNldCBtYXNrKHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX21hc2spIHtcclxuICAgICAgICAgICAgdGhpcy5fbWFzay5yZW5kZXJhYmxlID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5fbWFzay5pc01hc2sgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fbWFzayA9IHZhbHVlO1xyXG4gICAgICAgIGlmICh0aGlzLl9tYXNrKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX21hc2sucmVuZGVyYWJsZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLl9tYXNrLmlzTWFzayA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgICAgICAgICAqIFNldCB0aGlzIHRvIHRydWUgaWYgeW91IHdhbnQgdGhpcyBkaXNwbGF5IG9iamVjdCB0byBiZSBjYWNoZWQgYXMgYSBiaXRtYXAuXHJcbiAgICAgICAgICAgICAqIFRoaXMgYmFzaWNhbGx5IHRha2VzIGEgc25hcCBzaG90IG9mIHRoZSBkaXNwbGF5IG9iamVjdCBhcyBpdCBpcyBhdCB0aGF0IG1vbWVudC4gSXQgY2FuXHJcbiAgICAgICAgICAgICAqIHByb3ZpZGUgYSBwZXJmb3JtYW5jZSBiZW5lZml0IGZvciBjb21wbGV4IHN0YXRpYyBkaXNwbGF5T2JqZWN0cy5cclxuICAgICAgICAgICAgICogVG8gcmVtb3ZlIHNpbXBseSBzZXQgdGhpcyBwcm9wZXJ0eSB0byBgZmFsc2VgXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqIElNUE9SVEFOVCBHT1RDSEEgLSBNYWtlIHN1cmUgdGhhdCBhbGwgeW91ciB0ZXh0dXJlcyBhcmUgcHJlbG9hZGVkIEJFRk9SRSBzZXR0aW5nIHRoaXMgcHJvcGVydHkgdG8gdHJ1ZVxyXG4gICAgICAgICAgICAgKiBhcyBpdCB3aWxsIHRha2UgYSBzbmFwc2hvdCBvZiB3aGF0IGlzIGN1cnJlbnRseSB0aGVyZS4gSWYgdGhlIHRleHR1cmVzIGhhdmUgbm90IGxvYWRlZCB0aGVuIHRoZXkgd2lsbCBub3QgYXBwZWFyLlxyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiBAbWVtYmVyIHtib29sZWFufVxyXG4gICAgICAgICAgICAgKiBAbWVtYmVyb2YgUElYSS5EaXNwbGF5T2JqZWN0I1xyXG4gICAgICAgICAgICAgKi9cclxuICAgIGdldCBjYWNoZUFzQml0bWFwKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9jYWNoZUFzQml0bWFwO1xyXG4gICAgfVxyXG4gICAgc2V0IGNhY2hlQXNCaXRtYXAodmFsdWUpIHtcclxuICAgICAgICBpZiAodGhpcy5fY2FjaGVBc0JpdG1hcCA9PT0gdmFsdWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9jYWNoZUFzQml0bWFwID0gdmFsdWU7XHJcbiAgICAgICAgdmFyIGRhdGE7XHJcbiAgICAgICAgaWYgKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5fY2FjaGVEYXRhKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZURhdGEgPSBuZXcgQ2FjaGVEYXRhKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZGF0YSA9IHRoaXMuX2NhY2hlRGF0YTtcclxuICAgICAgICAgICAgZGF0YS5vcmlnaW5hbFJlbmRlciA9IHRoaXMucmVuZGVyO1xyXG4gICAgICAgICAgICBkYXRhLm9yaWdpbmFsUmVuZGVyQ2FudmFzID0gdGhpcy5yZW5kZXJDYW52YXM7XHJcbiAgICAgICAgICAgIGRhdGEub3JpZ2luYWxVcGRhdGVUcmFuc2Zvcm0gPSB0aGlzLnVwZGF0ZVRyYW5zZm9ybTtcclxuICAgICAgICAgICAgZGF0YS5vcmlnaW5hbENhbGN1bGF0ZUJvdW5kcyA9IHRoaXMuY2FsY3VsYXRlQm91bmRzO1xyXG4gICAgICAgICAgICBkYXRhLm9yaWdpbmFsR2V0TG9jYWxCb3VuZHMgPSB0aGlzLmdldExvY2FsQm91bmRzO1xyXG4gICAgICAgICAgICBkYXRhLm9yaWdpbmFsRGVzdHJveSA9IHRoaXMuZGVzdHJveTtcclxuICAgICAgICAgICAgZGF0YS5vcmlnaW5hbENvbnRhaW5zUG9pbnQgPSB0aGlzLmNvbnRhaW5zUG9pbnQ7XHJcbiAgICAgICAgICAgIGRhdGEub3JpZ2luYWxNYXNrID0gdGhpcy5fbWFzaztcclxuICAgICAgICAgICAgZGF0YS5vcmlnaW5hbEZpbHRlckFyZWEgPSB0aGlzLmZpbHRlckFyZWE7XHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVyID0gdGhpcy5fcmVuZGVyQ2FjaGVkO1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlckNhbnZhcyA9IHRoaXMuX3JlbmRlckNhY2hlZENhbnZhcztcclxuICAgICAgICAgICAgdGhpcy5kZXN0cm95ID0gdGhpcy5fY2FjaGVBc0JpdG1hcERlc3Ryb3k7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBkYXRhID0gdGhpcy5fY2FjaGVEYXRhO1xyXG4gICAgICAgICAgICBpZiAoZGF0YS5zcHJpdGUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2Rlc3Ryb3lDYWNoZWREaXNwbGF5T2JqZWN0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5yZW5kZXIgPSBkYXRhLm9yaWdpbmFsUmVuZGVyO1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlckNhbnZhcyA9IGRhdGEub3JpZ2luYWxSZW5kZXJDYW52YXM7XHJcbiAgICAgICAgICAgIHRoaXMuY2FsY3VsYXRlQm91bmRzID0gZGF0YS5vcmlnaW5hbENhbGN1bGF0ZUJvdW5kcztcclxuICAgICAgICAgICAgdGhpcy5nZXRMb2NhbEJvdW5kcyA9IGRhdGEub3JpZ2luYWxHZXRMb2NhbEJvdW5kcztcclxuICAgICAgICAgICAgdGhpcy5kZXN0cm95ID0gZGF0YS5vcmlnaW5hbERlc3Ryb3k7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVHJhbnNmb3JtID0gZGF0YS5vcmlnaW5hbFVwZGF0ZVRyYW5zZm9ybTtcclxuICAgICAgICAgICAgdGhpcy5jb250YWluc1BvaW50ID0gZGF0YS5vcmlnaW5hbENvbnRhaW5zUG9pbnQ7XHJcbiAgICAgICAgICAgIHRoaXMuX21hc2sgPSBkYXRhLm9yaWdpbmFsTWFzaztcclxuICAgICAgICAgICAgdGhpcy5maWx0ZXJBcmVhID0gZGF0YS5vcmlnaW5hbEZpbHRlckFyZWE7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY29udGFpbnNQb2ludChwb2ludCkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVuZGVycyBhIGNhY2hlZCB2ZXJzaW9uIG9mIHRoZSBzcHJpdGUgd2l0aCBXZWJHTFxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAZnVuY3Rpb24gX3JlbmRlckNhY2hlZFxyXG4gICAgICogQG1lbWJlcm9mIFBJWEkuRGlzcGxheU9iamVjdCNcclxuICAgICAqIEBwYXJhbSB7UElYSS5SZW5kZXJlcn0gcmVuZGVyZXIgLSB0aGUgV2ViR0wgcmVuZGVyZXJcclxuICAgICAqL1xyXG4gICAgX3JlbmRlckNhY2hlZChyZW5kZXJlcikge1xyXG4gICAgICAgIGlmICghdGhpcy52aXNpYmxlIHx8IHRoaXMud29ybGRBbHBoYSA8PSAwIHx8ICF0aGlzLnJlbmRlcmFibGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9pbml0Q2FjaGVkRGlzcGxheU9iamVjdChyZW5kZXJlcik7XHJcbiAgICAgICAgdGhpcy5fY2FjaGVEYXRhLnNwcml0ZS50cmFuc2Zvcm0uX3dvcmxkSUQgPSB0aGlzLnRyYW5zZm9ybS5fd29ybGRJRDtcclxuICAgICAgICB0aGlzLl9jYWNoZURhdGEuc3ByaXRlLndvcmxkQWxwaGEgPSB0aGlzLndvcmxkQWxwaGE7XHJcbiAgICAgICAgdGhpcy5fY2FjaGVEYXRhLnNwcml0ZS5fcmVuZGVyKHJlbmRlcmVyKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUHJlcGFyZXMgdGhlIFdlYkdMIHJlbmRlcmVyIHRvIGNhY2hlIHRoZSBzcHJpdGVcclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQGZ1bmN0aW9uIF9pbml0Q2FjaGVkRGlzcGxheU9iamVjdFxyXG4gICAgICogQG1lbWJlcm9mIFBJWEkuRGlzcGxheU9iamVjdCNcclxuICAgICAqIEBwYXJhbSB7UElYSS5SZW5kZXJlcn0gcmVuZGVyZXIgLSB0aGUgV2ViR0wgcmVuZGVyZXJcclxuICAgICAqL1xyXG4gICAgX2luaXRDYWNoZWREaXNwbGF5T2JqZWN0KHJlbmRlcmVyKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2NhY2hlRGF0YSAmJiB0aGlzLl9jYWNoZURhdGEuc3ByaXRlKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gbWFrZSBzdXJlIGFscGhhIGlzIHNldCB0byAxIG90aGVyd2lzZSBpdCB3aWxsIGdldCByZW5kZXJlZCBhcyBpbnZpc2libGUhXHJcbiAgICAgICAgdmFyIGNhY2hlQWxwaGEgPSB0aGlzLmFscGhhO1xyXG4gICAgICAgIHRoaXMuYWxwaGEgPSAxO1xyXG4gICAgICAgIC8vIGZpcnN0IHdlIGZsdXNoIGFueXRoaW5nIGxlZnQgaW4gdGhlIHJlbmRlcmVyIChvdGhlcndpc2UgaXQgd291bGQgZ2V0IHJlbmRlcmVkIHRvIHRoZSBjYWNoZWQgdGV4dHVyZSlcclxuICAgICAgICByZW5kZXJlci5iYXRjaC5mbHVzaCgpO1xyXG4gICAgICAgIC8vIHRoaXMuZmlsdGVycz0gW107XHJcbiAgICAgICAgLy8gbmV4dCB3ZSBmaW5kIHRoZSBkaW1lbnNpb25zIG9mIHRoZSB1bnRyYW5zZm9ybWVkIG9iamVjdFxyXG4gICAgICAgIC8vIHRoaXMgZnVuY3Rpb24gYWxzbyBjYWxscyB1cGRhdGV0cmFuc2Zvcm0gb24gYWxsIGl0cyBjaGlsZHJlbiBhcyBwYXJ0IG9mIHRoZSBtZWFzdXJpbmcuXHJcbiAgICAgICAgLy8gVGhpcyBtZWFucyB3ZSBkb24ndCBuZWVkIHRvIHVwZGF0ZSB0aGUgdHJhbnNmb3JtIGFnYWluIGluIHRoaXMgZnVuY3Rpb25cclxuICAgICAgICAvLyBUT0RPIHBhc3MgYW4gb2JqZWN0IHRvIGNsb25lIHRvbz8gc2F2ZXMgaGF2aW5nIHRvIGNyZWF0ZSBhIG5ldyBvbmUgZWFjaCB0aW1lIVxyXG4gICAgICAgIHZhciBib3VuZHMgPSB0aGlzLmdldExvY2FsQm91bmRzKCkuY2xvbmUoKTtcclxuICAgICAgICAvLyBhZGQgc29tZSBwYWRkaW5nIVxyXG4gICAgICAgIGlmICh0aGlzLmZpbHRlcnMpIHtcclxuICAgICAgICAgICAgdmFyIHBhZGRpbmcgPSB0aGlzLmZpbHRlcnNbMF0ucGFkZGluZztcclxuICAgICAgICAgICAgYm91bmRzLnBhZChwYWRkaW5nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYm91bmRzLmNlaWwoRGlzcGxheVNldHRpbmdzXzEuRGlzcGxheVNldHRpbmdzLlJFU09MVVRJT04pO1xyXG4gICAgICAgIC8vIGZvciBub3cgd2UgY2FjaGUgdGhlIGN1cnJlbnQgcmVuZGVyVGFyZ2V0IHRoYXQgdGhlIFdlYkdMIHJlbmRlcmVyIGlzIGN1cnJlbnRseSB1c2luZy5cclxuICAgICAgICAvLyB0aGlzIGNvdWxkIGJlIG1vcmUgZWxlZ2FudC4uXHJcbiAgICAgICAgdmFyIGNhY2hlZFJlbmRlclRhcmdldCA9IHJlbmRlcmVyLl9hY3RpdmVSZW5kZXJUYXJnZXQ7XHJcbiAgICAgICAgLy8gV2UgYWxzbyBzdG9yZSB0aGUgZmlsdGVyIHN0YWNrIC0gSSB3aWxsIGRlZmluaXRlbHkgbG9vayB0byBjaGFuZ2UgaG93IHRoaXMgd29ya3MgYSBsaXR0bGUgbGF0ZXIgZG93biB0aGUgbGluZS5cclxuICAgICAgICAvLyBjb25zdCBzdGFjayA9IHJlbmRlcmVyLmZpbHRlck1hbmFnZXIuZmlsdGVyU3RhY2s7XHJcbiAgICAgICAgLy8gdGhpcyByZW5kZXJUZXh0dXJlIHdpbGwgYmUgdXNlZCB0byBzdG9yZSB0aGUgY2FjaGVkIERpc3BsYXlPYmplY3RcclxuICAgICAgICB2YXIgcmVuZGVyVGV4dHVyZSA9IFJlbmRlclRleHR1cmVfMS5SZW5kZXJUZXh0dXJlLmNyZWF0ZShib3VuZHMud2lkdGgsIGJvdW5kcy5oZWlnaHQpO1xyXG4gICAgICAgIHZhciB0ZXh0dXJlQ2FjaGVJZCA9IFwiY2FjaGVBc0JpdG1hcF9cIiArIChNYXRoU2V0dGluZ3NfMS5NYXRoU2V0dGluZ3MudWlkKCkpO1xyXG4gICAgICAgIHRoaXMuX2NhY2hlRGF0YS50ZXh0dXJlQ2FjaGVJZCA9IHRleHR1cmVDYWNoZUlkO1xyXG4gICAgICAgIEJhc2VUZXh0dXJlXzEuQmFzZVRleHR1cmUuYWRkVG9DYWNoZShyZW5kZXJUZXh0dXJlLmJhc2VUZXh0dXJlLCB0ZXh0dXJlQ2FjaGVJZCk7XHJcbiAgICAgICAgVGV4dHVyZV8xLlRleHR1cmUuYWRkVG9DYWNoZShyZW5kZXJUZXh0dXJlLCB0ZXh0dXJlQ2FjaGVJZCk7XHJcbiAgICAgICAgLy8gbmVlZCB0byBzZXQgLy9cclxuICAgICAgICB2YXIgbSA9IERpc3BsYXlPYmplY3QuX3RlbXBNYXRyaXg7XHJcbiAgICAgICAgbS50eCA9IC1ib3VuZHMueDtcclxuICAgICAgICBtLnR5ID0gLWJvdW5kcy55O1xyXG4gICAgICAgIC8vIHJlc2V0XHJcbiAgICAgICAgdGhpcy50cmFuc2Zvcm0ud29ybGRUcmFuc2Zvcm0uaWRlbnRpdHkoKTtcclxuICAgICAgICAvLyBzZXQgYWxsIHByb3BlcnRpZXMgdG8gdGhlcmUgb3JpZ2luYWwgc28gd2UgY2FuIHJlbmRlciB0byBhIHRleHR1cmVcclxuICAgICAgICB0aGlzLnJlbmRlciA9IHRoaXMuX2NhY2hlRGF0YS5vcmlnaW5hbFJlbmRlcjtcclxuICAgICAgICByZW5kZXJlci5yZW5kZXIodGhpcywgcmVuZGVyVGV4dHVyZSwgdHJ1ZSwgbSwgdHJ1ZSk7XHJcbiAgICAgICAgLy8gbm93IHJlc3RvcmUgdGhlIHN0YXRlIGJlIHNldHRpbmcgdGhlIG5ldyBwcm9wZXJ0aWVzXHJcbiAgICAgICAgcmVuZGVyZXIucmVuZGVyVGV4dHVyZS5iaW5kKGNhY2hlZFJlbmRlclRhcmdldCk7XHJcbiAgICAgICAgLy8gcmVuZGVyZXIuZmlsdGVyTWFuYWdlci5maWx0ZXJTdGFjayA9IHN0YWNrO1xyXG4gICAgICAgIHRoaXMucmVuZGVyID0gdGhpcy5fcmVuZGVyQ2FjaGVkO1xyXG4gICAgICAgIC8vIHRoZSByZXN0IGlzIHRoZSBzYW1lIGFzIGZvciBDYW52YXNcclxuICAgICAgICB0aGlzLnVwZGF0ZVRyYW5zZm9ybSA9IHRoaXMuZGlzcGxheU9iamVjdFVwZGF0ZVRyYW5zZm9ybTtcclxuICAgICAgICB0aGlzLmNhbGN1bGF0ZUJvdW5kcyA9IHRoaXMuX2NhbGN1bGF0ZUNhY2hlZEJvdW5kcztcclxuICAgICAgICB0aGlzLmdldExvY2FsQm91bmRzID0gdGhpcy5fZ2V0Q2FjaGVkTG9jYWxCb3VuZHM7XHJcbiAgICAgICAgdGhpcy5fbWFzayA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5maWx0ZXJBcmVhID0gbnVsbDtcclxuICAgICAgICAvLyBjcmVhdGUgb3VyIGNhY2hlZCBzcHJpdGVcclxuICAgICAgICB2YXIgY2FjaGVkU3ByaXRlOyAvLyA9IG5ldyBTcHJpdGUocmVuZGVyVGV4dHVyZSk7XHJcbiAgICAgICAgY2FjaGVkU3ByaXRlLnRyYW5zZm9ybS53b3JsZFRyYW5zZm9ybSA9IHRoaXMudHJhbnNmb3JtLndvcmxkVHJhbnNmb3JtO1xyXG4gICAgICAgIGNhY2hlZFNwcml0ZS5hbmNob3IueCA9IC0oYm91bmRzLnggLyBib3VuZHMud2lkdGgpO1xyXG4gICAgICAgIGNhY2hlZFNwcml0ZS5hbmNob3IueSA9IC0oYm91bmRzLnkgLyBib3VuZHMuaGVpZ2h0KTtcclxuICAgICAgICBjYWNoZWRTcHJpdGUuYWxwaGEgPSBjYWNoZUFscGhhO1xyXG4gICAgICAgIGNhY2hlZFNwcml0ZS5fYm91bmRzID0gdGhpcy5fYm91bmRzO1xyXG4gICAgICAgIHRoaXMuX2NhY2hlRGF0YS5zcHJpdGUgPSBjYWNoZWRTcHJpdGU7XHJcbiAgICAgICAgdGhpcy50cmFuc2Zvcm0uX3BhcmVudElEID0gLTE7XHJcbiAgICAgICAgLy8gcmVzdG9yZSB0aGUgdHJhbnNmb3JtIG9mIHRoZSBjYWNoZWQgc3ByaXRlIHRvIGF2b2lkIHRoZSBuYXN0eSBmbGlja2VyLi5cclxuICAgICAgICBpZiAoIXRoaXMucGFyZW50KSB7XHJcbiAgICAgICAgICAgIHRoaXMucGFyZW50ID0gcmVuZGVyZXIuX3RlbXBEaXNwbGF5T2JqZWN0UGFyZW50O1xyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVRyYW5zZm9ybSgpO1xyXG4gICAgICAgICAgICB0aGlzLnBhcmVudCA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVRyYW5zZm9ybSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBtYXAgdGhlIGhpdCB0ZXN0Li5cclxuICAgICAgICB0aGlzLmNvbnRhaW5zUG9pbnQgPSBjYWNoZWRTcHJpdGUuY29udGFpbnNQb2ludC5iaW5kKGNhY2hlZFNwcml0ZSk7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICogUmVuZGVycyBhIGNhY2hlZCB2ZXJzaW9uIG9mIHRoZSBzcHJpdGUgd2l0aCBjYW52YXNcclxuICpcclxuICogQHByaXZhdGVcclxuICogQGZ1bmN0aW9uIF9yZW5kZXJDYWNoZWRDYW52YXNcclxuICogQG1lbWJlcm9mIFBJWEkuRGlzcGxheU9iamVjdCNcclxuICogQHBhcmFtIHtQSVhJLlJlbmRlcmVyfSByZW5kZXJlciAtIHRoZSBXZWJHTCByZW5kZXJlclxyXG4gKi9cclxuICAgIF9yZW5kZXJDYWNoZWRDYW52YXMocmVuZGVyZXIpIHtcclxuICAgICAgICBpZiAoIXRoaXMudmlzaWJsZSB8fCB0aGlzLndvcmxkQWxwaGEgPD0gMCB8fCAhdGhpcy5yZW5kZXJhYmxlKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5faW5pdENhY2hlZERpc3BsYXlPYmplY3RDYW52YXMocmVuZGVyZXIpO1xyXG4gICAgICAgIHRoaXMuX2NhY2hlRGF0YS5zcHJpdGUud29ybGRBbHBoYSA9IHRoaXMud29ybGRBbHBoYTtcclxuICAgICAgICB0aGlzLl9jYWNoZURhdGEuc3ByaXRlLl9yZW5kZXJDYW52YXMocmVuZGVyZXIpO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLy8gVE9ETyB0aGlzIGNhbiBiZSB0aGUgc2FtZSBhcyB0aGUgV2ViR0wgdmVyc2lvbi4uIHdpbGwgbmVlZCB0byBkbyBhIGxpdHRsZSB0d2Vha2luZyBmaXJzdCB0aG91Z2guLlxyXG4gICAgLyoqXHJcbiAgICAgKiBQcmVwYXJlcyB0aGUgQ2FudmFzIHJlbmRlcmVyIHRvIGNhY2hlIHRoZSBzcHJpdGVcclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQGZ1bmN0aW9uIF9pbml0Q2FjaGVkRGlzcGxheU9iamVjdENhbnZhc1xyXG4gICAgICogQG1lbWJlcm9mIFBJWEkuRGlzcGxheU9iamVjdCNcclxuICAgICAqIEBwYXJhbSB7UElYSS5SZW5kZXJlcn0gcmVuZGVyZXIgLSB0aGUgV2ViR0wgcmVuZGVyZXJcclxuICAgICAqL1xyXG4gICAgX2luaXRDYWNoZWREaXNwbGF5T2JqZWN0Q2FudmFzKHJlbmRlcmVyKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2NhY2hlRGF0YSAmJiB0aGlzLl9jYWNoZURhdGEuc3ByaXRlKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gZ2V0IGJvdW5kcyBhY3R1YWxseSB0cmFuc2Zvcm1zIHRoZSBvYmplY3QgZm9yIHVzIGFscmVhZHkhXHJcbiAgICAgICAgdmFyIGJvdW5kcyA9IHRoaXMuZ2V0TG9jYWxCb3VuZHMoKTtcclxuICAgICAgICB2YXIgY2FjaGVBbHBoYSA9IHRoaXMuYWxwaGE7XHJcbiAgICAgICAgdGhpcy5hbHBoYSA9IDE7XHJcbiAgICAgICAgdmFyIGNhY2hlZFJlbmRlclRhcmdldCA9IHJlbmRlcmVyLmNvbnRleHQ7XHJcbiAgICAgICAgYm91bmRzLmNlaWwoRGlzcGxheVNldHRpbmdzXzEuRGlzcGxheVNldHRpbmdzLlJFU09MVVRJT04pO1xyXG4gICAgICAgIHZhciByZW5kZXJUZXh0dXJlID0gUmVuZGVyVGV4dHVyZV8xLlJlbmRlclRleHR1cmUuY3JlYXRlKGJvdW5kcy53aWR0aCwgYm91bmRzLmhlaWdodCk7XHJcbiAgICAgICAgdmFyIHRleHR1cmVDYWNoZUlkID0gXCJjYWNoZUFzQml0bWFwX1wiICsgKE1hdGhTZXR0aW5nc18xLk1hdGhTZXR0aW5ncy51aWQoKSk7XHJcbiAgICAgICAgdGhpcy5fY2FjaGVEYXRhLnRleHR1cmVDYWNoZUlkID0gdGV4dHVyZUNhY2hlSWQ7XHJcbiAgICAgICAgQmFzZVRleHR1cmVfMS5CYXNlVGV4dHVyZS5hZGRUb0NhY2hlKHJlbmRlclRleHR1cmUuYmFzZVRleHR1cmUsIHRleHR1cmVDYWNoZUlkKTtcclxuICAgICAgICBUZXh0dXJlXzEuVGV4dHVyZS5hZGRUb0NhY2hlKHJlbmRlclRleHR1cmUsIHRleHR1cmVDYWNoZUlkKTtcclxuICAgICAgICAvLyBuZWVkIHRvIHNldCAvL1xyXG4gICAgICAgIHZhciBtID0gRGlzcGxheU9iamVjdC5fdGVtcE1hdHJpeDtcclxuICAgICAgICB0aGlzLnRyYW5zZm9ybS5sb2NhbFRyYW5zZm9ybS5jb3B5VG8obSk7XHJcbiAgICAgICAgbS5pbnZlcnQoKTtcclxuICAgICAgICBtLnR4IC09IGJvdW5kcy54O1xyXG4gICAgICAgIG0udHkgLT0gYm91bmRzLnk7XHJcbiAgICAgICAgLy8gbS5hcHBlbmQodGhpcy50cmFuc2Zvcm0ud29ybGRUcmFuc2Zvcm0uKVxyXG4gICAgICAgIC8vIHNldCBhbGwgcHJvcGVydGllcyB0byB0aGVyZSBvcmlnaW5hbCBzbyB3ZSBjYW4gcmVuZGVyIHRvIGEgdGV4dHVyZVxyXG4gICAgICAgIHRoaXMucmVuZGVyQ2FudmFzID0gdGhpcy5fY2FjaGVEYXRhLm9yaWdpbmFsUmVuZGVyQ2FudmFzO1xyXG4gICAgICAgIC8vIHJlbmRlclRleHR1cmUucmVuZGVyKHRoaXMsIG0sIHRydWUpO1xyXG4gICAgICAgIHJlbmRlcmVyLnJlbmRlcih0aGlzLCByZW5kZXJUZXh0dXJlLCB0cnVlLCBtLCBmYWxzZSk7XHJcbiAgICAgICAgLy8gbm93IHJlc3RvcmUgdGhlIHN0YXRlIGJlIHNldHRpbmcgdGhlIG5ldyBwcm9wZXJ0aWVzXHJcbiAgICAgICAgcmVuZGVyZXIuY29udGV4dCA9IGNhY2hlZFJlbmRlclRhcmdldDtcclxuICAgICAgICB0aGlzLnJlbmRlckNhbnZhcyA9IHRoaXMuX3JlbmRlckNhY2hlZENhbnZhcztcclxuICAgICAgICAvLyB0aGUgcmVzdCBpcyB0aGUgc2FtZSBhcyBmb3IgV2ViR0xcclxuICAgICAgICB0aGlzLnVwZGF0ZVRyYW5zZm9ybSA9IHRoaXMuZGlzcGxheU9iamVjdFVwZGF0ZVRyYW5zZm9ybTtcclxuICAgICAgICB0aGlzLmNhbGN1bGF0ZUJvdW5kcyA9IHRoaXMuX2NhbGN1bGF0ZUNhY2hlZEJvdW5kcztcclxuICAgICAgICB0aGlzLmdldExvY2FsQm91bmRzID0gdGhpcy5fZ2V0Q2FjaGVkTG9jYWxCb3VuZHM7XHJcbiAgICAgICAgdGhpcy5fbWFzayA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5maWx0ZXJBcmVhID0gbnVsbDtcclxuICAgICAgICAvLyBjcmVhdGUgb3VyIGNhY2hlZCBzcHJpdGVcclxuICAgICAgICB2YXIgY2FjaGVkU3ByaXRlOyAvLz0gbmV3IFNwcml0ZShyZW5kZXJUZXh0dXJlKTtcclxuICAgICAgICBjYWNoZWRTcHJpdGUudHJhbnNmb3JtLndvcmxkVHJhbnNmb3JtID0gdGhpcy50cmFuc2Zvcm0ud29ybGRUcmFuc2Zvcm07XHJcbiAgICAgICAgY2FjaGVkU3ByaXRlLmFuY2hvci54ID0gLShib3VuZHMueCAvIGJvdW5kcy53aWR0aCk7XHJcbiAgICAgICAgY2FjaGVkU3ByaXRlLmFuY2hvci55ID0gLShib3VuZHMueSAvIGJvdW5kcy5oZWlnaHQpO1xyXG4gICAgICAgIGNhY2hlZFNwcml0ZS5hbHBoYSA9IGNhY2hlQWxwaGE7XHJcbiAgICAgICAgY2FjaGVkU3ByaXRlLl9ib3VuZHMgPSB0aGlzLl9ib3VuZHM7XHJcbiAgICAgICAgdGhpcy5fY2FjaGVEYXRhLnNwcml0ZSA9IGNhY2hlZFNwcml0ZTtcclxuICAgICAgICB0aGlzLnRyYW5zZm9ybS5fcGFyZW50SUQgPSAtMTtcclxuICAgICAgICAvLyByZXN0b3JlIHRoZSB0cmFuc2Zvcm0gb2YgdGhlIGNhY2hlZCBzcHJpdGUgdG8gYXZvaWQgdGhlIG5hc3R5IGZsaWNrZXIuLlxyXG4gICAgICAgIGlmICghdGhpcy5wYXJlbnQpIHtcclxuICAgICAgICAgICAgdGhpcy5wYXJlbnQgPSByZW5kZXJlci5fdGVtcERpc3BsYXlPYmplY3RQYXJlbnQ7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVHJhbnNmb3JtKCk7XHJcbiAgICAgICAgICAgIHRoaXMucGFyZW50ID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVHJhbnNmb3JtKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIG1hcCB0aGUgaGl0IHRlc3QuLlxyXG4gICAgICAgIHRoaXMuY29udGFpbnNQb2ludCA9IGNhY2hlZFNwcml0ZS5jb250YWluc1BvaW50LmJpbmQoY2FjaGVkU3ByaXRlKTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIHJlbmRlckNhbnZhcyhyZW5kZXJlcikge1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxjdWxhdGVzIHRoZSBib3VuZHMgb2YgdGhlIGNhY2hlZCBzcHJpdGVcclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBfY2FsY3VsYXRlQ2FjaGVkQm91bmRzKCkge1xyXG4gICAgICAgIHRoaXMuX2JvdW5kcy5jbGVhcigpO1xyXG4gICAgICAgIHRoaXMuX2NhY2hlRGF0YS5zcHJpdGUudHJhbnNmb3JtLl93b3JsZElEID0gdGhpcy50cmFuc2Zvcm0uX3dvcmxkSUQ7XHJcbiAgICAgICAgdGhpcy5fY2FjaGVEYXRhLnNwcml0ZS5fY2FsY3VsYXRlQm91bmRzKCk7XHJcbiAgICAgICAgdGhpcy5fbGFzdEJvdW5kc0lEID0gdGhpcy5fYm91bmRzSUQ7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIGJvdW5kcyBvZiB0aGUgY2FjaGVkIHNwcml0ZS5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHJldHVybiB7UmVjdGFuZ2xlfSBUaGUgbG9jYWwgYm91bmRzLlxyXG4gICAgICovXHJcbiAgICBfZ2V0Q2FjaGVkTG9jYWxCb3VuZHMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhY2hlRGF0YS5zcHJpdGUuZ2V0TG9jYWxCb3VuZHMoKTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogRGVzdHJveXMgdGhlIGNhY2hlZCBzcHJpdGUuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgX2Rlc3Ryb3lDYWNoZWREaXNwbGF5T2JqZWN0KCkge1xyXG4gICAgICAgIHRoaXMuX2NhY2hlRGF0YS5zcHJpdGUuX3RleHR1cmUuZGVzdHJveSh0cnVlKTtcclxuICAgICAgICB0aGlzLl9jYWNoZURhdGEuc3ByaXRlID0gbnVsbDtcclxuICAgICAgICBCYXNlVGV4dHVyZV8xLkJhc2VUZXh0dXJlLnJlbW92ZUZyb21DYWNoZSh0aGlzLl9jYWNoZURhdGEudGV4dHVyZUNhY2hlSWQpO1xyXG4gICAgICAgIFRleHR1cmVfMS5UZXh0dXJlLnJlbW92ZUZyb21DYWNoZSh0aGlzLl9jYWNoZURhdGEudGV4dHVyZUNhY2hlSWQpO1xyXG4gICAgICAgIHRoaXMuX2NhY2hlRGF0YS50ZXh0dXJlQ2FjaGVJZCA9IG51bGw7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICogRGVzdHJveXMgdGhlIGNhY2hlZCBvYmplY3QuXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBwYXJhbSB7b2JqZWN0fGJvb2xlYW59IFtvcHRpb25zXSAtIE9wdGlvbnMgcGFyYW1ldGVyLiBBIGJvb2xlYW4gd2lsbCBhY3QgYXMgaWYgYWxsIG9wdGlvbnNcclxuICogIGhhdmUgYmVlbiBzZXQgdG8gdGhhdCB2YWx1ZS5cclxuICogIFVzZWQgd2hlbiBkZXN0cm95aW5nIGNvbnRhaW5lcnMsIHNlZSB0aGUgQ29udGFpbmVyLmRlc3Ryb3kgbWV0aG9kLlxyXG4gKi9cclxuICAgIF9jYWNoZUFzQml0bWFwRGVzdHJveShvcHRpb25zKSB7XHJcbiAgICAgICAgdGhpcy5jYWNoZUFzQml0bWFwID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5kZXN0cm95KG9wdGlvbnMpO1xyXG4gICAgfVxyXG4gICAgO1xyXG59XHJcbkRpc3BsYXlPYmplY3QuX3RlbXBNYXRyaXggPSBuZXcgTWF0cml4XzEuTWF0cml4KCk7XHJcbmV4cG9ydHMuRGlzcGxheU9iamVjdCA9IERpc3BsYXlPYmplY3Q7XHJcbi8vIGZpZ3VyZWQgdGhlcmVzIG5vIHBvaW50IGFkZGluZyBBTEwgdGhlIGV4dHJhIHZhcmlhYmxlcyB0byBwcm90b3R5cGUuXHJcbi8vIHRoaXMgbW9kZWwgY2FuIGhvbGQgdGhlIGluZm9ybWF0aW9uIG5lZWRlZC4gVGhpcyBjYW4gYWxzbyBiZSBnZW5lcmF0ZWQgb24gZGVtYW5kIGFzXHJcbi8vIG1vc3Qgb2JqZWN0cyBhcmUgbm90IGNhY2hlZCBhcyBiaXRtYXBzLlxyXG4vKipcclxuICogQGNsYXNzXHJcbiAqIEBpZ25vcmVcclxuICovXHJcbmNsYXNzIENhY2hlRGF0YSB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLnRleHR1cmVDYWNoZUlkID0gbnVsbDtcclxuICAgICAgICB0aGlzLm9yaWdpbmFsUmVuZGVyID0gbnVsbDtcclxuICAgICAgICB0aGlzLm9yaWdpbmFsUmVuZGVyQ2FudmFzID0gbnVsbDtcclxuICAgICAgICB0aGlzLm9yaWdpbmFsQ2FsY3VsYXRlQm91bmRzID0gbnVsbDtcclxuICAgICAgICB0aGlzLm9yaWdpbmFsR2V0TG9jYWxCb3VuZHMgPSBudWxsO1xyXG4gICAgICAgIHRoaXMub3JpZ2luYWxVcGRhdGVUcmFuc2Zvcm0gPSBudWxsO1xyXG4gICAgICAgIHRoaXMub3JpZ2luYWxIaXRUZXN0ID0gbnVsbDtcclxuICAgICAgICB0aGlzLm9yaWdpbmFsRGVzdHJveSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5vcmlnaW5hbE1hc2sgPSBudWxsO1xyXG4gICAgICAgIHRoaXMub3JpZ2luYWxGaWx0ZXJBcmVhID0gbnVsbDtcclxuICAgICAgICB0aGlzLnNwcml0ZSA9IG51bGw7XHJcbiAgICB9XHJcbn1cclxuO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jbGFzcyBEaXNwbGF5U2V0dGluZ3Mge1xyXG59XHJcbkRpc3BsYXlTZXR0aW5ncy5TT1JUQUJMRV9DSElMRFJFTiA9IGZhbHNlO1xyXG5EaXNwbGF5U2V0dGluZ3MuQ1JFQVRFX0lNQUdFX0JJVE1BUCA9IHRydWU7XHJcbkRpc3BsYXlTZXR0aW5ncy5SRU5ERVJFUl9UWVBFID0ge1xyXG4gICAgVU5LTk9XTjogMCxcclxuICAgIFdFQkdMOiAxLFxyXG4gICAgQ0FOVkFTOiAyLFxyXG59O1xyXG5EaXNwbGF5U2V0dGluZ3MuRU5WID0ge1xyXG4gICAgV0VCR0xfTEVHQUNZOiAwLFxyXG4gICAgV0VCR0w6IDEsXHJcbiAgICBXRUJHTDI6IDIsXHJcbn07XHJcbkRpc3BsYXlTZXR0aW5ncy5SRVNPTFVUSU9OID0gMTtcclxuRGlzcGxheVNldHRpbmdzLlNDQUxFX01PREUgPSAxO1xyXG5EaXNwbGF5U2V0dGluZ3MuUk9VTkRfUElYRUxTID0gZmFsc2U7XHJcbkRpc3BsYXlTZXR0aW5ncy5QUkVGRVJfRU5WID0gRGlzcGxheVNldHRpbmdzLkVOVi5XRUJHTDtcclxuZXhwb3J0cy5EaXNwbGF5U2V0dGluZ3MgPSBEaXNwbGF5U2V0dGluZ3M7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNsYXNzIERyYXdNb2RlU2V0dGluZ3Mge1xyXG59XHJcbi8qKlxyXG4qIFZhcmlvdXMgd2ViZ2wgZHJhdyBtb2Rlcy4gVGhlc2UgY2FuIGJlIHVzZWQgdG8gc3BlY2lmeSB3aGljaCBHTCBkcmF3TW9kZSB0byB1c2VcclxuKiB1bmRlciBjZXJ0YWluIHNpdHVhdGlvbnMgYW5kIHJlbmRlcmVycy5cclxuKlxyXG4qIEBtZW1iZXJvZiBQSVhJXHJcbiogQHN0YXRpY1xyXG4qIEBuYW1lIERSQVdfTU9ERVNcclxuKiBAZW51bSB7bnVtYmVyfVxyXG4qIEBwcm9wZXJ0eSB7bnVtYmVyfSBQT0lOVFNcclxuKiBAcHJvcGVydHkge251bWJlcn0gTElORVNcclxuKiBAcHJvcGVydHkge251bWJlcn0gTElORV9MT09QXHJcbiogQHByb3BlcnR5IHtudW1iZXJ9IExJTkVfU1RSSVBcclxuKiBAcHJvcGVydHkge251bWJlcn0gVFJJQU5HTEVTXHJcbiogQHByb3BlcnR5IHtudW1iZXJ9IFRSSUFOR0xFX1NUUklQXHJcbiogQHByb3BlcnR5IHtudW1iZXJ9IFRSSUFOR0xFX0ZBTlxyXG4qL1xyXG5EcmF3TW9kZVNldHRpbmdzLkRSQVdfTU9ERVMgPSB7XHJcbiAgICBQT0lOVFM6IDAsXHJcbiAgICBMSU5FUzogMSxcclxuICAgIExJTkVfTE9PUDogMixcclxuICAgIExJTkVfU1RSSVA6IDMsXHJcbiAgICBUUklBTkdMRVM6IDQsXHJcbiAgICBUUklBTkdMRV9TVFJJUDogNSxcclxuICAgIFRSSUFOR0xFX0ZBTjogNixcclxufTtcclxuZXhwb3J0cy5EcmF3TW9kZVNldHRpbmdzID0gRHJhd01vZGVTZXR0aW5ncztcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgUmVjdGFuZ2xlXzEgPSByZXF1aXJlKFwiLi9SZWN0YW5nbGVcIik7XHJcbmNvbnN0IFNoYXBlU2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL1NoYXBlU2V0dGluZ3NcIik7XHJcbmNsYXNzIEVsbGlwc2Uge1xyXG4gICAgY29uc3RydWN0b3IoeCA9IDAsIHkgPSAwLCBoYWxmV2lkdGggPSAwLCBoYWxmSGVpZ2h0ID0gMCkge1xyXG4gICAgICAgIGlmICh4ID09PSB2b2lkIDApIHtcclxuICAgICAgICAgICAgeCA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh5ID09PSB2b2lkIDApIHtcclxuICAgICAgICAgICAgeSA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChoYWxmV2lkdGggPT09IHZvaWQgMCkge1xyXG4gICAgICAgICAgICBoYWxmV2lkdGggPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaGFsZkhlaWdodCA9PT0gdm9pZCAwKSB7XHJcbiAgICAgICAgICAgIGhhbGZIZWlnaHQgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgICAgICogQGRlZmF1bHQgMFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMueCA9IHg7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICAgICAqIEBkZWZhdWx0IDBcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnkgPSB5O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAgICAgKiBAZGVmYXVsdCAwXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy53aWR0aCA9IGhhbGZXaWR0aDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgICAgICogQGRlZmF1bHQgMFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGFsZkhlaWdodDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgdHlwZSBvZiB0aGUgb2JqZWN0LCBtYWlubHkgdXNlZCB0byBhdm9pZCBgaW5zdGFuY2VvZmAgY2hlY2tzXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgICAgICogQHJlYWRPbmx5XHJcbiAgICAgICAgICogQGRlZmF1bHQgUElYSS5TSEFQRVMuRUxJUFxyXG4gICAgICAgICAqIEBzZWUgUElYSS5TSEFQRVNcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnR5cGUgPSBTaGFwZVNldHRpbmdzXzEuU2hhcGVTZXR0aW5ncy5TSEFQRVMuRUxJUDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIGNsb25lIG9mIHRoaXMgRWxsaXBzZSBpbnN0YW5jZVxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4ge1BJWEkuRWxsaXBzZX0gYSBjb3B5IG9mIHRoZSBlbGxpcHNlXHJcbiAgICAgKi9cclxuICAgIGNsb25lKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgRWxsaXBzZSh0aGlzLngsIHRoaXMueSwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgeCBhbmQgeSBjb29yZGluYXRlcyBnaXZlbiBhcmUgY29udGFpbmVkIHdpdGhpbiB0aGlzIGVsbGlwc2VcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCAtIFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50IHRvIHRlc3RcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQgdG8gdGVzdFxyXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUgeC95IGNvb3JkcyBhcmUgd2l0aGluIHRoaXMgZWxsaXBzZVxyXG4gICAgICovXHJcbiAgICBjb250YWlucyh4LCB5KSB7XHJcbiAgICAgICAgaWYgKHRoaXMud2lkdGggPD0gMCB8fCB0aGlzLmhlaWdodCA8PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gbm9ybWFsaXplIHRoZSBjb29yZHMgdG8gYW4gZWxsaXBzZSB3aXRoIGNlbnRlciAwLDBcclxuICAgICAgICB2YXIgbm9ybXggPSAoKHggLSB0aGlzLngpIC8gdGhpcy53aWR0aCk7XHJcbiAgICAgICAgdmFyIG5vcm15ID0gKCh5IC0gdGhpcy55KSAvIHRoaXMuaGVpZ2h0KTtcclxuICAgICAgICBub3JteCAqPSBub3JteDtcclxuICAgICAgICBub3JteSAqPSBub3JteTtcclxuICAgICAgICByZXR1cm4gKG5vcm14ICsgbm9ybXkgPD0gMSk7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGZyYW1pbmcgcmVjdGFuZ2xlIG9mIHRoZSBlbGxpcHNlIGFzIGEgUmVjdGFuZ2xlIG9iamVjdFxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4ge1BJWEkuUmVjdGFuZ2xlfSB0aGUgZnJhbWluZyByZWN0YW5nbGVcclxuICAgICAqL1xyXG4gICAgZ2V0Qm91bmRzKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgUmVjdGFuZ2xlXzEuUmVjdGFuZ2xlKHRoaXMueCAtIHRoaXMud2lkdGgsIHRoaXMueSAtIHRoaXMuaGVpZ2h0LCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XHJcbiAgICB9XHJcbiAgICA7XHJcbn1cclxuZXhwb3J0cy5FbGxpcHNlID0gRWxsaXBzZTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgRmxhc2hCYXNlT2JqZWN0XzEgPSByZXF1aXJlKFwiLi9GbGFzaEJhc2VPYmplY3RcIik7XHJcbmNsYXNzIEV2ZW50IGV4dGVuZHMgRmxhc2hCYXNlT2JqZWN0XzEuRmxhc2hCYXNlT2JqZWN0IHtcclxuICAgIGNvbnN0cnVjdG9yKHR5cGUsIGJ1YmJsZSA9IHRydWUsIGNhbmNlbGFibGUgPSB0cnVlKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLnJlc2V0KHR5cGUsIGJ1YmJsZSwgY2FuY2VsYWJsZSk7XHJcbiAgICB9XHJcbiAgICBnZXQgY3VycmVudFRhcmdldCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fY3VycmVudFRhcmdldDtcclxuICAgIH1cclxuICAgIHNldEN1cnJlbnRUYXJnZXQodmFsdWUpIHtcclxuICAgICAgICB0aGlzLl9jdXJyZW50VGFyZ2V0ID0gdmFsdWU7XHJcbiAgICB9XHJcbiAgICBnZXQgdHlwZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fdHlwZTtcclxuICAgIH1cclxuICAgIGdldCBjYW5jZWxhYmxlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9jYW5jZWxhYmxlO1xyXG4gICAgfVxyXG4gICAgZ2V0IGJ1YmJsZXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2J1YmJsZXM7XHJcbiAgICB9XHJcbiAgICBnZXQgZXZlbnRQaGFzZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZXZlbnRQaGFzZTtcclxuICAgIH1cclxuICAgIGNsb25lKCkge1xyXG4gICAgICAgIHJldHVybiBFdmVudC5nZXRFdmVudCh0aGlzLl90eXBlLCB0aGlzLl9idWJibGVzLCB0aGlzLl9jYW5jZWxhYmxlKTtcclxuICAgIH1cclxuICAgIHJlc2V0KHR5cGUsIGJ1YmJsZSA9IHRydWUsIGNhbmNlbGFibGUgPSB0cnVlKSB7XHJcbiAgICAgICAgdGhpcy5fdHlwZSA9IHR5cGU7XHJcbiAgICAgICAgdGhpcy5fYnViYmxlcyA9IGJ1YmJsZTtcclxuICAgICAgICB0aGlzLl9jYW5jZWxhYmxlID0gY2FuY2VsYWJsZTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBnZXRFdmVudCh0eXBlLCBidWJibGUgPSB0cnVlLCBjYW5jZWxhYmxlID0gdHJ1ZSkge1xyXG4gICAgICAgIGlmIChFdmVudC5FdmVudENhY2hlLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBsZXQgdGUgPSBFdmVudC5FdmVudENhY2hlW0V2ZW50LkV2ZW50Q2FjaGUubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgICAgIEV2ZW50LkV2ZW50Q2FjaGUubGVuZ3RoIC09IDE7XHJcbiAgICAgICAgICAgIHRlLnJlc2V0KHR5cGUsIGJ1YmJsZSwgY2FuY2VsYWJsZSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBFdmVudCh0eXBlLCBidWJibGUsIGNhbmNlbGFibGUpO1xyXG4gICAgfVxyXG4gICAgZGVzdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLl9jdXJyZW50VGFyZ2V0ID0gbnVsbDtcclxuICAgICAgICBsZXQgaW5kZXggPSBFdmVudC5FdmVudENhY2hlLmluZGV4T2YodGhpcyk7XHJcbiAgICAgICAgaWYgKGluZGV4IDwgMCkge1xyXG4gICAgICAgICAgICBFdmVudC5FdmVudENhY2hlLnB1c2godGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZ2V0IGlzRGlzcG9zYWJsZSgpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIHN0b3BQcm9wYWdhdGlvbigpIHtcclxuICAgIH1cclxuICAgIHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpIHtcclxuICAgIH1cclxuICAgIHByZXZlbnREZWZhdWx0KCkge1xyXG4gICAgfVxyXG59XHJcbkV2ZW50LkFEREVEX1RPX1NUQUdFID0gXCJhZGRlZFRvU3RhZ2VcIjtcclxuRXZlbnQuQURERUQgPSBcImFkZGVkXCI7XHJcbkV2ZW50LkVOVEVSX0ZSQU1FID0gXCJlbnRlckZyYW1lXCI7XHJcbkV2ZW50LkVYSVRfRlJBTUUgPSBcImV4aXRGcmFtZVwiO1xyXG5FdmVudC5GUkFNRV9DT05TVFJVQ1RFRCA9IFwiZnJhbWVDb25zdHJ1Y3RlZFwiO1xyXG5FdmVudC5SRU1PVkVEID0gXCJyZW1vdmVkXCI7XHJcbkV2ZW50LlJFTU9WRURfRlJPTV9TVEFHRSA9IFwicmVtb3ZlZEZyb21TdGFnZVwiO1xyXG5FdmVudC5SRU5ERVIgPSBcInJlbmRlclwiO1xyXG5FdmVudC5DT01QTEVURSA9IFwiY29tcGxldGVcIjtcclxuRXZlbnQuSU5JVCA9IFwiaW5pdFwiO1xyXG5FdmVudC5PUEVOID0gXCJvcGVuXCI7XHJcbkV2ZW50LlVOTE9BRCA9IFwidW5sb2FkXCI7XHJcbkV2ZW50LkNMRUFSID0gXCJjbGVhclwiO1xyXG5FdmVudC5TT1VORF9DT01QTEVURSA9IFwic291bmRDb21wbGV0ZVwiO1xyXG5FdmVudC5TT1VORF9TVEFSVEVEID0gXCJzb3VuZFN0YXJ0ZWRcIjtcclxuRXZlbnQuQUNUSVZBVEUgPSBcImFjdGl2YXRlXCI7XHJcbkV2ZW50LkRFQUNUSVZBVEUgPSBcImRlc2FjdGl2YXRlXCI7XHJcbkV2ZW50LlJFU0laRSA9IFwicmVzaXplXCI7XHJcbkV2ZW50LkNIQU5HRSA9IFwiY2hhbmdlXCI7XHJcbkV2ZW50LkV2ZW50Q2FjaGUgPSBbXTtcclxuZXhwb3J0cy5FdmVudCA9IEV2ZW50O1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBGbGFzaEJhc2VPYmplY3RfMSA9IHJlcXVpcmUoXCIuL0ZsYXNoQmFzZU9iamVjdFwiKTtcclxuY2xhc3MgRXZlbnREaXNwYXRjaGVyIGV4dGVuZHMgRmxhc2hCYXNlT2JqZWN0XzEuRmxhc2hCYXNlT2JqZWN0IHtcclxuICAgIGNvbnN0cnVjdG9yKHRhcmdldCA9IG51bGwpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMucmVnaXN0ZXJlZExpc3RlbmVycyA9IHt9O1xyXG4gICAgfVxyXG4gICAgcmVtb3ZlTGlzdGVuZXJzKCkge1xyXG4gICAgICAgIGZvciAodmFyIGkgaW4gdGhpcy5yZWdpc3RlcmVkTGlzdGVuZXJzKSB7XHJcbiAgICAgICAgICAgIHZhciBtZXRob2RzID0gdGhpcy5yZWdpc3RlcmVkTGlzdGVuZXJzW2ldO1xyXG4gICAgICAgICAgICB3aGlsZSAobWV0aG9kcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIGxldCBtcyA9IG1ldGhvZHMuc2hpZnQoKTtcclxuICAgICAgICAgICAgICAgIG1zLmRlc3RydWN0b3IoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBkZWxldGUgdGhpcy5yZWdpc3RlcmVkTGlzdGVuZXJzW2ldO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnJlZ2lzdGVyZWRMaXN0ZW5lcnMgPSB7fTtcclxuICAgIH1cclxuICAgIGRlc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIuZGVzdHJ1Y3RvcigpO1xyXG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXJzKCk7XHJcbiAgICB9XHJcbiAgICB3aWxsVHJpZ2dlcih0eXBlKSB7XHJcbiAgICAgICAgaWYgKHRoaXMucmVnaXN0ZXJlZExpc3RlbmVyc1t0eXBlXSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHZhciBtZXRob2RzID0gdGhpcy5yZWdpc3RlcmVkTGlzdGVuZXJzW3R5cGVdO1xyXG4gICAgICAgICAgICBpZiAobWV0aG9kcyAmJiBtZXRob2RzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICByZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyLCB1c2VDYXB0dXJlID0gZmFsc2UpIHtcclxuICAgICAgICBpZiAodGhpcy5yZWdpc3RlcmVkTGlzdGVuZXJzW3R5cGVdICE9IG51bGwpIHtcclxuICAgICAgICAgICAgdmFyIG1ldGhvZHMgPSB0aGlzLnJlZ2lzdGVyZWRMaXN0ZW5lcnNbdHlwZV07XHJcbiAgICAgICAgICAgIGlmIChtZXRob2RzICYmIG1ldGhvZHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1ldGhvZHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobWV0aG9kc1tpXS5vYmplY3RGdW5jdGlvbiA9PSBsaXN0ZW5lcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRob2RzW2ldLmRlc3RydWN0b3IoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kcy5zcGxpY2UoaSwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghbWV0aG9kcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnJlZ2lzdGVyZWRMaXN0ZW5lcnNbdHlwZV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBoYXNFdmVudExpc3RlbmVyKHR5cGUpIHtcclxuICAgICAgICBpZiAodGhpcy5yZWdpc3RlcmVkTGlzdGVuZXJzW3R5cGVdICE9IG51bGwpIHtcclxuICAgICAgICAgICAgdmFyIG1ldGhvZHMgPSB0aGlzLnJlZ2lzdGVyZWRMaXN0ZW5lcnNbdHlwZV07XHJcbiAgICAgICAgICAgIGlmIChtZXRob2RzICYmIG1ldGhvZHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGRpc3BhdGNoRXZlbnQoZXZlbnQpIHtcclxuICAgICAgICBpZiAodGhpcy5yZWdpc3RlcmVkTGlzdGVuZXJzW2V2ZW50LnR5cGVdICE9IG51bGwpIHtcclxuICAgICAgICAgICAgZXZlbnQuc2V0Q3VycmVudFRhcmdldCh0aGlzKTtcclxuICAgICAgICAgICAgdmFyIG1ldGhvZHMgPSB0aGlzLnJlZ2lzdGVyZWRMaXN0ZW5lcnNbZXZlbnQudHlwZV07XHJcbiAgICAgICAgICAgIGlmIChtZXRob2RzICYmIG1ldGhvZHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgbWV0aG9kY29weSA9IG1ldGhvZHMuY29uY2F0KCk7XHJcbiAgICAgICAgICAgICAgICBtZXRob2Rjb3B5ID0gbWV0aG9kY29weS5zb3J0KHRoaXMuZ2V0TWV0aG9kUHJpb3JpdHkpO1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKG1ldGhvZGNvcHkubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1ldGhvZCA9IG1ldGhvZGNvcHkuc2hpZnQoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobWV0aG9kLmV2ZW50VHlwZSAhPSBldmVudC50eXBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAobWV0aG9kKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlcihtZXRob2QsIGV2ZW50KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGV2ZW50LmlzRGlzcG9zYWJsZSkge1xyXG4gICAgICAgICAgICBldmVudC5kZXN0cnVjdG9yKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGFkZEV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIsIHVzZUNhcHR1cmUgPSBmYWxzZSwgcHJpb3JpdHkgPSAwLCB1c2VXZWFrUmVmZXJlbmNlID0gZmFsc2UsIHNjb3BlID0gbnVsbCkge1xyXG4gICAgICAgIGlmICh0aGlzLmlzUmVnaXN0ZXJlZCh0eXBlLCBsaXN0ZW5lcikpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXRoaXMucmVnaXN0ZXJlZExpc3RlbmVyc1t0eXBlXSkge1xyXG4gICAgICAgICAgICB0aGlzLnJlZ2lzdGVyZWRMaXN0ZW5lcnNbdHlwZV0gPSBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIG1ldGhvZHMgPSB0aGlzLnJlZ2lzdGVyZWRMaXN0ZW5lcnNbdHlwZV07XHJcbiAgICAgICAgdmFyIG1ldGhvZFNjb3BlID0gTWV0aG9kU2NvcGUuZ2V0TWV0aG9kU2NvcGUoKTtcclxuICAgICAgICBtZXRob2RTY29wZS5ldmVudFR5cGUgPSB0eXBlO1xyXG4gICAgICAgIG1ldGhvZFNjb3BlLnBhcmVudERpc3BhdGNoZXIgPSB0aGlzO1xyXG4gICAgICAgIG1ldGhvZFNjb3BlLm9iamVjdEZ1bmN0aW9uID0gbGlzdGVuZXI7XHJcbiAgICAgICAgbWV0aG9kU2NvcGUuc2NvcGUgPSBzY29wZTtcclxuICAgICAgICBtZXRob2RTY29wZS5wcmlvcml0eSA9IHByaW9yaXR5O1xyXG4gICAgICAgIG1ldGhvZHMucHVzaChtZXRob2RTY29wZSk7XHJcbiAgICB9XHJcbiAgICB0cmlnZ2VyKG1ldGhvZCwgZXZlbnQpIHtcclxuICAgICAgICBpZiAobWV0aG9kLm9iamVjdEZ1bmN0aW9uKSB7XHJcbiAgICAgICAgICAgIG1ldGhvZC5vYmplY3RGdW5jdGlvbi5jYWxsKG1ldGhvZC5zY29wZSwgZXZlbnQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGdldE1ldGhvZFByaW9yaXR5KG1ldGhvZDEsIG1ldGhvZDIpIHtcclxuICAgICAgICBpZiAobWV0aG9kMS5wcmlvcml0eSA+IG1ldGhvZDIucHJpb3JpdHkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAtMTtcclxuICAgIH1cclxuICAgIGlzUmVnaXN0ZXJlZCh0eXBlLCBsaXN0ZW5lcikge1xyXG4gICAgICAgIGlmICghdGhpcy5yZWdpc3RlcmVkTGlzdGVuZXJzW3R5cGVdKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIG1ldGhvZHMgPSB0aGlzLnJlZ2lzdGVyZWRMaXN0ZW5lcnNbdHlwZV07XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXRob2RzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChtZXRob2RzW2ldLm9iamVjdEZ1bmN0aW9uID09IGxpc3RlbmVyKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5FdmVudERpc3BhdGNoZXIgPSBFdmVudERpc3BhdGNoZXI7XHJcbmNsYXNzIE1ldGhvZFNjb3BlIGV4dGVuZHMgRmxhc2hCYXNlT2JqZWN0XzEuRmxhc2hCYXNlT2JqZWN0IHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5yZXNldCgpO1xyXG4gICAgfVxyXG4gICAgcmVzZXQoKSB7XHJcbiAgICAgICAgdGhpcy5vYmplY3RGdW5jdGlvbiA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5zY29wZSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5wYXJlbnREaXNwYXRjaGVyID0gbnVsbDtcclxuICAgICAgICB0aGlzLnByaW9yaXR5ID0gMDtcclxuICAgICAgICB0aGlzLmV2ZW50VHlwZSA9IG51bGw7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZ2V0TWV0aG9kU2NvcGUoKSB7XHJcbiAgICAgICAgaWYgKE1ldGhvZFNjb3BlLk1ldGhvZFNjb3BlQ2FjaGUubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGxldCB0ZSA9IE1ldGhvZFNjb3BlLk1ldGhvZFNjb3BlQ2FjaGVbTWV0aG9kU2NvcGUuTWV0aG9kU2NvcGVDYWNoZS5sZW5ndGggLSAxXTtcclxuICAgICAgICAgICAgTWV0aG9kU2NvcGUuTWV0aG9kU2NvcGVDYWNoZS5sZW5ndGggLT0gMTtcclxuICAgICAgICAgICAgdGUucmVzZXQoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IE1ldGhvZFNjb3BlKCk7XHJcbiAgICB9XHJcbiAgICBkZXN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMub2JqZWN0RnVuY3Rpb24gPSBudWxsO1xyXG4gICAgICAgIHRoaXMuc2NvcGUgPSBudWxsO1xyXG4gICAgICAgIHRoaXMucGFyZW50RGlzcGF0Y2hlciA9IG51bGw7XHJcbiAgICAgICAgbGV0IGluZGV4ID0gTWV0aG9kU2NvcGUuTWV0aG9kU2NvcGVDYWNoZS5pbmRleE9mKHRoaXMpO1xyXG4gICAgICAgIGlmIChpbmRleCA8IDApIHtcclxuICAgICAgICAgICAgTWV0aG9kU2NvcGUuTWV0aG9kU2NvcGVDYWNoZS51bnNoaWZ0KHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5NZXRob2RTY29wZS5NZXRob2RTY29wZUNhY2hlID0gW107XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IFJlbmRlclRleHR1cmVfMSA9IHJlcXVpcmUoXCIuL1JlbmRlclRleHR1cmVcIik7XHJcbmNvbnN0IFJlY3RhbmdsZV8xID0gcmVxdWlyZShcIi4vUmVjdGFuZ2xlXCIpO1xyXG5jb25zdCBDYW52YXNSZW5kZXJUYXJnZXRfMSA9IHJlcXVpcmUoXCIuL0NhbnZhc1JlbmRlclRhcmdldFwiKTtcclxuY2xhc3MgRXh0cmFjdCB7XHJcbiAgICBjb25zdHJ1Y3RvcihyZW5kZXJlcikge1xyXG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb2xsZWN0aW9uIG9mIG1ldGhvZHMgZm9yIGV4dHJhY3RpbmcgZGF0YSAoaW1hZ2UsIHBpeGVscywgZXRjLikgZnJvbSBhIGRpc3BsYXkgb2JqZWN0IG9yIHJlbmRlciB0ZXh0dXJlXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLmV4dHJhY3QuRXh0cmFjdH0gZXh0cmFjdFxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBQSVhJLlJlbmRlcmVyI1xyXG4gICAgICAgICAqIEBzZWUgUElYSS5leHRyYWN0LkV4dHJhY3RcclxuICAgICAgICAgKi9cclxuICAgICAgICByZW5kZXJlci5leHRyYWN0ID0gdGhpcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogV2lsbCByZXR1cm4gYSBIVE1MIEltYWdlIG9mIHRoZSB0YXJnZXRcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1BJWEkuRGlzcGxheU9iamVjdHxQSVhJLlJlbmRlclRleHR1cmV9IHRhcmdldCAtIEEgZGlzcGxheU9iamVjdCBvciByZW5kZXJUZXh0dXJlXHJcbiAgICAgKiAgdG8gY29udmVydC4gSWYgbGVmdCBlbXB0eSB3aWxsIHVzZSB0aGUgbWFpbiByZW5kZXJlclxyXG4gICAgICogQHJldHVybiB7SFRNTEltYWdlRWxlbWVudH0gSFRNTCBJbWFnZSBvZiB0aGUgdGFyZ2V0XHJcbiAgICAgKi9cclxuICAgIGltYWdlKHRhcmdldCkge1xyXG4gICAgICAgIHZhciBpbWFnZSA9IG5ldyBJbWFnZSgpO1xyXG4gICAgICAgIGltYWdlLnNyYyA9IHRoaXMuYmFzZTY0KHRhcmdldCk7XHJcbiAgICAgICAgcmV0dXJuIGltYWdlO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBXaWxsIHJldHVybiBhIGEgYmFzZTY0IGVuY29kZWQgc3RyaW5nIG9mIHRoaXMgdGFyZ2V0LiBJdCB3b3JrcyBieSBjYWxsaW5nXHJcbiAgICAgKiAgYEV4dHJhY3QuZ2V0Q2FudmFzYCBhbmQgdGhlbiBydW5uaW5nIHRvRGF0YVVSTCBvbiB0aGF0LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7UElYSS5EaXNwbGF5T2JqZWN0fFBJWEkuUmVuZGVyVGV4dHVyZX0gdGFyZ2V0IC0gQSBkaXNwbGF5T2JqZWN0IG9yIHJlbmRlclRleHR1cmVcclxuICAgICAqICB0byBjb252ZXJ0LiBJZiBsZWZ0IGVtcHR5IHdpbGwgdXNlIHRoZSBtYWluIHJlbmRlcmVyXHJcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IEEgYmFzZTY0IGVuY29kZWQgc3RyaW5nIG9mIHRoZSB0ZXh0dXJlLlxyXG4gICAgICovXHJcbiAgICBiYXNlNjQodGFyZ2V0KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FudmFzKHRhcmdldCkudG9EYXRhVVJMKCk7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBDYW52YXMgZWxlbWVudCwgcmVuZGVycyB0aGlzIHRhcmdldCB0byBpdCBhbmQgdGhlbiByZXR1cm5zIGl0LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7UElYSS5EaXNwbGF5T2JqZWN0fFBJWEkuUmVuZGVyVGV4dHVyZX0gdGFyZ2V0IC0gQSBkaXNwbGF5T2JqZWN0IG9yIHJlbmRlclRleHR1cmVcclxuICAgICAqICB0byBjb252ZXJ0LiBJZiBsZWZ0IGVtcHR5IHdpbGwgdXNlIHRoZSBtYWluIHJlbmRlcmVyXHJcbiAgICAgKiBAcmV0dXJuIHtIVE1MQ2FudmFzRWxlbWVudH0gQSBDYW52YXMgZWxlbWVudCB3aXRoIHRoZSB0ZXh0dXJlIHJlbmRlcmVkIG9uLlxyXG4gICAgICovXHJcbiAgICBjYW52YXModGFyZ2V0KSB7XHJcbiAgICAgICAgdmFyIHJlbmRlcmVyID0gdGhpcy5yZW5kZXJlcjtcclxuICAgICAgICB2YXIgcmVzb2x1dGlvbjtcclxuICAgICAgICB2YXIgZnJhbWU7XHJcbiAgICAgICAgdmFyIGZsaXBZID0gZmFsc2U7XHJcbiAgICAgICAgdmFyIHJlbmRlclRleHR1cmU7XHJcbiAgICAgICAgdmFyIGdlbmVyYXRlZCA9IGZhbHNlO1xyXG4gICAgICAgIGlmICh0YXJnZXQpIHtcclxuICAgICAgICAgICAgaWYgKHRhcmdldCBpbnN0YW5jZW9mIFJlbmRlclRleHR1cmVfMS5SZW5kZXJUZXh0dXJlKSB7XHJcbiAgICAgICAgICAgICAgICByZW5kZXJUZXh0dXJlID0gdGFyZ2V0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmVuZGVyVGV4dHVyZSA9IHRoaXMucmVuZGVyZXIuZ2VuZXJhdGVUZXh0dXJlKHRhcmdldCk7XHJcbiAgICAgICAgICAgICAgICBnZW5lcmF0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChyZW5kZXJUZXh0dXJlKSB7XHJcbiAgICAgICAgICAgIHJlc29sdXRpb24gPSByZW5kZXJUZXh0dXJlLmJhc2VUZXh0dXJlLnJlc29sdXRpb247XHJcbiAgICAgICAgICAgIGZyYW1lID0gcmVuZGVyVGV4dHVyZS5mcmFtZTtcclxuICAgICAgICAgICAgZmxpcFkgPSBmYWxzZTtcclxuICAgICAgICAgICAgcmVuZGVyZXIucmVuZGVyVGV4dHVyZS5iaW5kKHJlbmRlclRleHR1cmUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmVzb2x1dGlvbiA9IHRoaXMucmVuZGVyZXIucmVzb2x1dGlvbjtcclxuICAgICAgICAgICAgZmxpcFkgPSB0cnVlO1xyXG4gICAgICAgICAgICBmcmFtZSA9IEV4dHJhY3QuVEVNUF9SRUNUO1xyXG4gICAgICAgICAgICBmcmFtZS53aWR0aCA9IHRoaXMucmVuZGVyZXIud2lkdGg7XHJcbiAgICAgICAgICAgIGZyYW1lLmhlaWdodCA9IHRoaXMucmVuZGVyZXIuaGVpZ2h0O1xyXG4gICAgICAgICAgICByZW5kZXJlci5yZW5kZXJUZXh0dXJlLmJpbmQobnVsbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciB3aWR0aCA9IGZyYW1lLndpZHRoICogcmVzb2x1dGlvbjtcclxuICAgICAgICB2YXIgaGVpZ2h0ID0gZnJhbWUuaGVpZ2h0ICogcmVzb2x1dGlvbjtcclxuICAgICAgICB2YXIgY2FudmFzQnVmZmVyID0gbmV3IENhbnZhc1JlbmRlclRhcmdldF8xLkNhbnZhc1JlbmRlclRhcmdldCh3aWR0aCwgaGVpZ2h0LCAxKTtcclxuICAgICAgICB2YXIgd2ViZ2xQaXhlbHMgPSBuZXcgVWludDhBcnJheShFeHRyYWN0LkJZVEVTX1BFUl9QSVhFTCAqIHdpZHRoICogaGVpZ2h0KTtcclxuICAgICAgICAvLyByZWFkIHBpeGVscyB0byB0aGUgYXJyYXlcclxuICAgICAgICB2YXIgZ2wgPSByZW5kZXJlci5nbDtcclxuICAgICAgICBnbC5yZWFkUGl4ZWxzKGZyYW1lLnggKiByZXNvbHV0aW9uLCBmcmFtZS55ICogcmVzb2x1dGlvbiwgd2lkdGgsIGhlaWdodCwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgd2ViZ2xQaXhlbHMpO1xyXG4gICAgICAgIC8vIGFkZCB0aGUgcGl4ZWxzIHRvIHRoZSBjYW52YXNcclxuICAgICAgICB2YXIgY2FudmFzRGF0YSA9IGNhbnZhc0J1ZmZlci5jb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcclxuICAgICAgICBjYW52YXNEYXRhLmRhdGEuc2V0KHdlYmdsUGl4ZWxzKTtcclxuICAgICAgICBjYW52YXNCdWZmZXIuY29udGV4dC5wdXRJbWFnZURhdGEoY2FudmFzRGF0YSwgMCwgMCk7XHJcbiAgICAgICAgLy8gcHVsbGluZyBwaXhlbHNcclxuICAgICAgICBpZiAoZmxpcFkpIHtcclxuICAgICAgICAgICAgY2FudmFzQnVmZmVyLmNvbnRleHQuc2NhbGUoMSwgLTEpO1xyXG4gICAgICAgICAgICBjYW52YXNCdWZmZXIuY29udGV4dC5kcmF3SW1hZ2UoY2FudmFzQnVmZmVyLmNhbnZhcywgMCwgLWhlaWdodCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChnZW5lcmF0ZWQpIHtcclxuICAgICAgICAgICAgcmVuZGVyVGV4dHVyZS5kZXN0cm95KHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBzZW5kIHRoZSBjYW52YXMgYmFjay4uXHJcbiAgICAgICAgcmV0dXJuIGNhbnZhc0J1ZmZlci5jYW52YXM7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFdpbGwgcmV0dXJuIGEgb25lLWRpbWVuc2lvbmFsIGFycmF5IGNvbnRhaW5pbmcgdGhlIHBpeGVsIGRhdGEgb2YgdGhlIGVudGlyZSB0ZXh0dXJlIGluIFJHQkFcclxuICAgICAqIG9yZGVyLCB3aXRoIGludGVnZXIgdmFsdWVzIGJldHdlZW4gMCBhbmQgMjU1IChpbmNsdWRlZCkuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtQSVhJLkRpc3BsYXlPYmplY3R8UElYSS5SZW5kZXJUZXh0dXJlfSB0YXJnZXQgLSBBIGRpc3BsYXlPYmplY3Qgb3IgcmVuZGVyVGV4dHVyZVxyXG4gICAgICogIHRvIGNvbnZlcnQuIElmIGxlZnQgZW1wdHkgd2lsbCB1c2UgdGhlIG1haW4gcmVuZGVyZXJcclxuICAgICAqIEByZXR1cm4ge1VpbnQ4Q2xhbXBlZEFycmF5fSBPbmUtZGltZW5zaW9uYWwgYXJyYXkgY29udGFpbmluZyB0aGUgcGl4ZWwgZGF0YSBvZiB0aGUgZW50aXJlIHRleHR1cmVcclxuICAgICAqL1xyXG4gICAgcGl4ZWxzKHRhcmdldCkge1xyXG4gICAgICAgIHZhciByZW5kZXJlciA9IHRoaXMucmVuZGVyZXI7XHJcbiAgICAgICAgdmFyIHJlc29sdXRpb247XHJcbiAgICAgICAgdmFyIGZyYW1lO1xyXG4gICAgICAgIHZhciByZW5kZXJUZXh0dXJlO1xyXG4gICAgICAgIHZhciBnZW5lcmF0ZWQgPSBmYWxzZTtcclxuICAgICAgICBpZiAodGFyZ2V0KSB7XHJcbiAgICAgICAgICAgIGlmICh0YXJnZXQgaW5zdGFuY2VvZiBSZW5kZXJUZXh0dXJlXzEuUmVuZGVyVGV4dHVyZSkge1xyXG4gICAgICAgICAgICAgICAgcmVuZGVyVGV4dHVyZSA9IHRhcmdldDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJlbmRlclRleHR1cmUgPSB0aGlzLnJlbmRlcmVyLmdlbmVyYXRlVGV4dHVyZSh0YXJnZXQpO1xyXG4gICAgICAgICAgICAgICAgZ2VuZXJhdGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocmVuZGVyVGV4dHVyZSkge1xyXG4gICAgICAgICAgICByZXNvbHV0aW9uID0gcmVuZGVyVGV4dHVyZS5iYXNlVGV4dHVyZS5yZXNvbHV0aW9uO1xyXG4gICAgICAgICAgICBmcmFtZSA9IHJlbmRlclRleHR1cmUuZnJhbWU7XHJcbiAgICAgICAgICAgIC8vIGJpbmQgdGhlIGJ1ZmZlclxyXG4gICAgICAgICAgICByZW5kZXJlci5yZW5kZXJUZXh0dXJlLmJpbmQocmVuZGVyVGV4dHVyZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXNvbHV0aW9uID0gcmVuZGVyZXIucmVzb2x1dGlvbjtcclxuICAgICAgICAgICAgZnJhbWUgPSBFeHRyYWN0LlRFTVBfUkVDVDtcclxuICAgICAgICAgICAgZnJhbWUud2lkdGggPSByZW5kZXJlci53aWR0aDtcclxuICAgICAgICAgICAgZnJhbWUuaGVpZ2h0ID0gcmVuZGVyZXIuaGVpZ2h0O1xyXG4gICAgICAgICAgICByZW5kZXJlci5yZW5kZXJUZXh0dXJlLmJpbmQobnVsbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciB3aWR0aCA9IGZyYW1lLndpZHRoICogcmVzb2x1dGlvbjtcclxuICAgICAgICB2YXIgaGVpZ2h0ID0gZnJhbWUuaGVpZ2h0ICogcmVzb2x1dGlvbjtcclxuICAgICAgICB2YXIgd2ViZ2xQaXhlbHMgPSBuZXcgVWludDhBcnJheShFeHRyYWN0LkJZVEVTX1BFUl9QSVhFTCAqIHdpZHRoICogaGVpZ2h0KTtcclxuICAgICAgICAvLyByZWFkIHBpeGVscyB0byB0aGUgYXJyYXlcclxuICAgICAgICB2YXIgZ2wgPSByZW5kZXJlci5nbDtcclxuICAgICAgICBnbC5yZWFkUGl4ZWxzKGZyYW1lLnggKiByZXNvbHV0aW9uLCBmcmFtZS55ICogcmVzb2x1dGlvbiwgd2lkdGgsIGhlaWdodCwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgd2ViZ2xQaXhlbHMpO1xyXG4gICAgICAgIGlmIChnZW5lcmF0ZWQpIHtcclxuICAgICAgICAgICAgcmVuZGVyVGV4dHVyZS5kZXN0cm95KHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gd2ViZ2xQaXhlbHM7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIERlc3Ryb3lzIHRoZSBleHRyYWN0XHJcbiAgICAgKlxyXG4gICAgICovXHJcbiAgICBkZXN0cm95KCkge1xyXG4gICAgICAgIHRoaXMucmVuZGVyZXIuZXh0cmFjdCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IG51bGw7XHJcbiAgICB9XHJcbiAgICA7XHJcbn1cclxuRXh0cmFjdC5URU1QX1JFQ1QgPSBuZXcgUmVjdGFuZ2xlXzEuUmVjdGFuZ2xlKCk7XHJcbkV4dHJhY3QuQllURVNfUEVSX1BJWEVMID0gNDtcclxuZXhwb3J0cy5FeHRyYWN0ID0gRXh0cmFjdDtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgVGV4dHVyZV8xID0gcmVxdWlyZShcIi4vVGV4dHVyZVwiKTtcclxuY29uc3QgRmxhc2hCYXNlT2JqZWN0XzEgPSByZXF1aXJlKFwiLi9GbGFzaEJhc2VPYmplY3RcIik7XHJcbmNsYXNzIEZpbGxTdHlsZSBleHRlbmRzIEZsYXNoQmFzZU9iamVjdF8xLkZsYXNoQmFzZU9iamVjdCB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMucmVzZXQoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2xvbmVzIHRoZSBvYmplY3RcclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIHtQSVhJLkZpbGxTdHlsZX1cclxuICAgICAqL1xyXG4gICAgY2xvbmUoKSB7XHJcbiAgICAgICAgdmFyIG9iaiA9IG5ldyBGaWxsU3R5bGUoKTtcclxuICAgICAgICBvYmouY29sb3IgPSB0aGlzLmNvbG9yO1xyXG4gICAgICAgIG9iai5hbHBoYSA9IHRoaXMuYWxwaGE7XHJcbiAgICAgICAgb2JqLnRleHR1cmUgPSB0aGlzLnRleHR1cmU7XHJcbiAgICAgICAgb2JqLm1hdHJpeCA9IHRoaXMubWF0cml4O1xyXG4gICAgICAgIG9iai52aXNpYmxlID0gdGhpcy52aXNpYmxlO1xyXG4gICAgICAgIHJldHVybiBvYmo7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFJlc2V0XHJcbiAgICAgKi9cclxuICAgIHJlc2V0KCkge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBoZXggY29sb3IgdmFsdWUgdXNlZCB3aGVuIGNvbG9yaW5nIHRoZSBHcmFwaGljcyBvYmplY3QuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgICAgICogQGRlZmF1bHQgMVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuY29sb3IgPSAweEZGRkZGRjtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgYWxwaGEgdmFsdWUgdXNlZCB3aGVuIGZpbGxpbmcgdGhlIEdyYXBoaWNzIG9iamVjdC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAgICAgKiBAZGVmYXVsdCAxXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5hbHBoYSA9IDE7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIHRleHR1cmUgdG8gYmUgdXNlZCBmb3IgdGhlIGZpbGwuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAbWVtYmVyIHtzdHJpbmd9XHJcbiAgICAgICAgICogQGRlZmF1bHQgMFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMudGV4dHVyZSA9IFRleHR1cmVfMS5UZXh0dXJlLldISVRFO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSB0cmFuc2Zvcm0gYXBscGllZCB0byB0aGUgdGV4dHVyZS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBtZW1iZXIge3N0cmluZ31cclxuICAgICAgICAgKiBAZGVmYXVsdCAwXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5tYXRyaXggPSBudWxsO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIElmIHRoZSBjdXJyZW50IGZpbGwgaXMgdmlzaWJsZS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XHJcbiAgICAgICAgICogQGRlZmF1bHQgZmFsc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnZpc2libGUgPSBmYWxzZTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogRGVzdHJveSBhbmQgZG9uJ3QgdXNlIGFmdGVyIHRoaXNcclxuICAgICAqL1xyXG4gICAgZGVzdHJveSgpIHtcclxuICAgICAgICB0aGlzLnRleHR1cmUgPSBudWxsO1xyXG4gICAgICAgIHRoaXMubWF0cml4ID0gbnVsbDtcclxuICAgIH1cclxuICAgIDtcclxufVxyXG5leHBvcnRzLkZpbGxTdHlsZSA9IEZpbGxTdHlsZTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgU2hhZGVyXzEgPSByZXF1aXJlKFwiLi9TaGFkZXJcIik7XHJcbmNvbnN0IFByb2dyYW1fMSA9IHJlcXVpcmUoXCIuL1Byb2dyYW1cIik7XHJcbmNvbnN0IHNldHRpbmdzXzEgPSByZXF1aXJlKFwiLi9zZXR0aW5nc1wiKTtcclxuY29uc3QgU3RhdGVfMSA9IHJlcXVpcmUoXCIuL1N0YXRlXCIpO1xyXG5jbGFzcyBGaWx0ZXIgZXh0ZW5kcyBTaGFkZXJfMS5TaGFkZXIge1xyXG4gICAgY29uc3RydWN0b3IodmVydGV4U3JjID0gbnVsbCwgZnJhZ21lbnRTcmMgPSBudWxsLCB1bmlmb3JtcyA9IG51bGwpIHtcclxuICAgICAgICB2YXIgcHJvZ3JhbSA9IFByb2dyYW1fMS5Qcm9ncmFtLmZyb20odmVydGV4U3JjIHx8IEZpbHRlci5kZWZhdWx0VmVydGV4U3JjLCBmcmFnbWVudFNyYyB8fCBGaWx0ZXIuZGVmYXVsdEZyYWdtZW50U3JjKTtcclxuICAgICAgICBzdXBlcihwcm9ncmFtLCB1bmlmb3Jtcyk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIHBhZGRpbmcgb2YgdGhlIGZpbHRlci4gU29tZSBmaWx0ZXJzIHJlcXVpcmUgZXh0cmEgc3BhY2UgdG8gYnJlYXRoIHN1Y2ggYXMgYSBibHVyLlxyXG4gICAgICAgICAqIEluY3JlYXNpbmcgdGhpcyB3aWxsIGFkZCBleHRyYSB3aWR0aCBhbmQgaGVpZ2h0IHRvIHRoZSBib3VuZHMgb2YgdGhlIG9iamVjdCB0aGF0IHRoZVxyXG4gICAgICAgICAqIGZpbHRlciBpcyBhcHBsaWVkIHRvLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMucGFkZGluZyA9IDA7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIHJlc29sdXRpb24gb2YgdGhlIGZpbHRlci4gU2V0dGluZyB0aGlzIHRvIGJlIGxvd2VyIHdpbGwgbG93ZXIgdGhlIHF1YWxpdHkgYnV0XHJcbiAgICAgICAgICogaW5jcmVhc2UgdGhlIHBlcmZvcm1hbmNlIG9mIHRoZSBmaWx0ZXIuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5yZXNvbHV0aW9uID0gc2V0dGluZ3NfMS5zZXR0aW5ncy5GSUxURVJfUkVTT0xVVElPTjtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJZiBlbmFibGVkIGlzIHRydWUgdGhlIGZpbHRlciBpcyBhcHBsaWVkLCBpZiBmYWxzZSBpdCB3aWxsIG5vdC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJZiBlbmFibGVkLCBQaXhpSlMgd2lsbCBmaXQgdGhlIGZpbHRlciBhcmVhIGludG8gYm91bmRhcmllcyBmb3IgYmV0dGVyIHBlcmZvcm1hbmNlLlxyXG4gICAgICAgICAqIFN3aXRjaCBpdCBvZmYgaWYgaXQgZG9lcyBub3Qgd29yayBmb3Igc3BlY2lmaWMgc2hhZGVyLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQG1lbWJlciB7Ym9vbGVhbn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmF1dG9GaXQgPSB0cnVlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIExlZ2FjeSBmaWx0ZXJzIHVzZSBwb3NpdGlvbiBhbmQgdXZzIGZyb20gYXR0cmlidXRlc1xyXG4gICAgICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XHJcbiAgICAgICAgICogQHJlYWRvbmx5XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5sZWdhY3kgPSAhIXRoaXMucHJvZ3JhbS5hdHRyaWJ1dGVEYXRhLmFUZXh0dXJlQ29vcmQ7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIFdlYkdMIHN0YXRlIHRoZSBmaWx0ZXIgcmVxdWlyZXMgdG8gcmVuZGVyXHJcbiAgICAgICAgICogQG1lbWJlciB7UElYSS5TdGF0ZX1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnN0YXRlID0gbmV3IFN0YXRlXzEuU3RhdGUoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQXBwbGllcyB0aGUgZmlsdGVyXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtQSVhJLnN5c3RlbXMuRmlsdGVyU3lzdGVtfSBmaWx0ZXJNYW5hZ2VyIC0gVGhlIHJlbmRlcmVyIHRvIHJldHJpZXZlIHRoZSBmaWx0ZXIgZnJvbVxyXG4gICAgICogQHBhcmFtIHtQSVhJLlJlbmRlclRleHR1cmV9IGlucHV0IC0gVGhlIGlucHV0IHJlbmRlciB0YXJnZXQuXHJcbiAgICAgKiBAcGFyYW0ge1BJWEkuUmVuZGVyVGV4dHVyZX0gb3V0cHV0IC0gVGhlIHRhcmdldCB0byBvdXRwdXQgdG8uXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGNsZWFyIC0gU2hvdWxkIHRoZSBvdXRwdXQgYmUgY2xlYXJlZCBiZWZvcmUgcmVuZGVyaW5nIHRvIGl0XHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW2N1cnJlbnRTdGF0ZV0gLSBJdCdzIGN1cnJlbnQgc3RhdGUgb2YgZmlsdGVyLlxyXG4gICAgICogICAgICAgIFRoZXJlIGFyZSBzb21lIHVzZWZ1bCBwcm9wZXJ0aWVzIGluIHRoZSBjdXJyZW50U3RhdGUgOlxyXG4gICAgICogICAgICAgIHRhcmdldCwgZmlsdGVycywgc291cmNlRnJhbWUsIGRlc3RpbmF0aW9uRnJhbWUsIHJlbmRlclRhcmdldCwgcmVzb2x1dGlvblxyXG4gICAgICovXHJcbiAgICBhcHBseShmaWx0ZXJNYW5hZ2VyLCBpbnB1dCwgb3V0cHV0LCBjbGVhciwgY3VycmVudFN0YXRlLCBkZXJwKSB7XHJcbiAgICAgICAgLy8gZG8gYXMgeW91IHBsZWFzZSFcclxuICAgICAgICBmaWx0ZXJNYW5hZ2VyLmFwcGx5RmlsdGVyKHRoaXMsIGlucHV0LCBvdXRwdXQsIGNsZWFyLCBjdXJyZW50U3RhdGUsIGRlcnApO1xyXG4gICAgICAgIC8vIG9yIGp1c3QgZG8gYSByZWd1bGFyIHJlbmRlci4uXHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIGJsZW5kbW9kZSBvZiB0aGUgZmlsdGVyXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICogQGRlZmF1bHQgUElYSS5CTEVORF9NT0RFUy5OT1JNQUxcclxuICAgICAqL1xyXG4gICAgZ2V0IGJsZW5kTW9kZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5ibGVuZE1vZGU7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICBzZXQgYmxlbmRNb2RlKHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5zdGF0ZS5ibGVuZE1vZGUgPSB2YWx1ZTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGRlZmF1bHQgdmVydGV4IHNoYWRlciBzb3VyY2VcclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxyXG4gICAgICogQGNvbnN0YW50XHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBnZXQgZGVmYXVsdFZlcnRleFNyYygpIHtcclxuICAgICAgICByZXR1cm4gRmlsdGVyLmRlZmF1bHRWZXJ0ZXgkMTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGRlZmF1bHQgZnJhZ21lbnQgc2hhZGVyIHNvdXJjZVxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEB0eXBlIHtzdHJpbmd9XHJcbiAgICAgKiBAY29uc3RhbnRcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGdldCBkZWZhdWx0RnJhZ21lbnRTcmMoKSB7XHJcbiAgICAgICAgcmV0dXJuIEZpbHRlci5kZWZhdWx0RnJhZ21lbnQkMTtcclxuICAgIH1cclxuICAgIDtcclxufVxyXG4vKipcclxuICogVXNlZCBmb3IgY2FjaGluZyBzaGFkZXIgSURzXHJcbiAqXHJcbiAqIEBzdGF0aWNcclxuICogQHR5cGUge29iamVjdH1cclxuICogQHByb3RlY3RlZFxyXG4gKi9cclxuRmlsdGVyLlNPVVJDRV9LRVlfTUFQID0ge307XHJcbkZpbHRlci5kZWZhdWx0VmVydGV4JDEgPSBcImF0dHJpYnV0ZSB2ZWMyIGFWZXJ0ZXhQb3NpdGlvbjtcXHJcXG5cXHJcXG51bmlmb3JtIG1hdDMgcHJvamVjdGlvbk1hdHJpeDtcXHJcXG5cXHJcXG52YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXHJcXG5cXHJcXG51bmlmb3JtIHZlYzQgaW5wdXRTaXplO1xcclxcbnVuaWZvcm0gdmVjNCBvdXRwdXRGcmFtZTtcXHJcXG5cXHJcXG52ZWM0IGZpbHRlclZlcnRleFBvc2l0aW9uKCB2b2lkIClcXHJcXG57XFxyXFxuICAgIHZlYzIgcG9zaXRpb24gPSBhVmVydGV4UG9zaXRpb24gKiBtYXgob3V0cHV0RnJhbWUuencsIHZlYzIoMC4pKSArIG91dHB1dEZyYW1lLnh5O1xcclxcblxcclxcbiAgICByZXR1cm4gdmVjNCgocHJvamVjdGlvbk1hdHJpeCAqIHZlYzMocG9zaXRpb24sIDEuMCkpLnh5LCAwLjAsIDEuMCk7XFxyXFxufVxcclxcblxcclxcbnZlYzIgZmlsdGVyVGV4dHVyZUNvb3JkKCB2b2lkIClcXHJcXG57XFxyXFxuICAgIHJldHVybiBhVmVydGV4UG9zaXRpb24gKiAob3V0cHV0RnJhbWUuencgKiBpbnB1dFNpemUuencpO1xcclxcbn1cXHJcXG5cXHJcXG52b2lkIG1haW4odm9pZClcXHJcXG57XFxyXFxuICAgIGdsX1Bvc2l0aW9uID0gZmlsdGVyVmVydGV4UG9zaXRpb24oKTtcXHJcXG4gICAgdlRleHR1cmVDb29yZCA9IGZpbHRlclRleHR1cmVDb29yZCgpO1xcclxcbn1cXHJcXG5cIjtcclxuRmlsdGVyLmRlZmF1bHRGcmFnbWVudCQxID0gXCJ2YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXHJcXG5cXHJcXG51bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjtcXHJcXG5cXHJcXG52b2lkIG1haW4odm9pZCl7XFxyXFxuICAgZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2VGV4dHVyZUNvb3JkKTtcXHJcXG59XFxyXFxuXCI7XHJcbmV4cG9ydHMuRmlsdGVyID0gRmlsdGVyO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBSZWN0YW5nbGVfMSA9IHJlcXVpcmUoXCIuL1JlY3RhbmdsZVwiKTtcclxuY2xhc3MgRmlsdGVyU3RhdGUge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJUZXh0dXJlID0gbnVsbDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUYXJnZXQgb2YgdGhlIGZpbHRlcnNcclxuICAgICAgICAgKiBXZSBzdG9yZSBmb3IgY2FzZSB3aGVuIGN1c3RvbSBmaWx0ZXIgd2FudHMgdG8ga25vdyB0aGUgZWxlbWVudCBpdCB3YXMgYXBwbGllZCBvblxyXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuRGlzcGxheU9iamVjdH1cclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMudGFyZ2V0ID0gbnVsbDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb21wYXRpYmlsaXR5IHdpdGggUGl4aUpTIHY0IGZpbHRlcnNcclxuICAgICAgICAgKiBAbWVtYmVyIHtib29sZWFufVxyXG4gICAgICAgICAqIEBkZWZhdWx0IGZhbHNlXHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmxlZ2FjeSA9IGZhbHNlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlc29sdXRpb24gb2YgZmlsdGVyc1xyXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAgICAgKiBAZGVmYXVsdCAxXHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnJlc29sdXRpb24gPSAxO1xyXG4gICAgICAgIC8vIG5leHQgdGhyZWUgZmllbGRzIGFyZSBjcmVhdGVkIG9ubHkgZm9yIHJvb3RcclxuICAgICAgICAvLyByZS1hc3NpZ25lZCBmb3IgZXZlcnl0aGluZyBlbHNlXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU291cmNlIGZyYW1lXHJcbiAgICAgICAgICogQG1lbWJlciB7UElYSS5SZWN0YW5nbGV9XHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnNvdXJjZUZyYW1lID0gbmV3IFJlY3RhbmdsZV8xLlJlY3RhbmdsZSgpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIERlc3RpbmF0aW9uIGZyYW1lXHJcbiAgICAgICAgICogQG1lbWJlciB7UElYSS5SZWN0YW5nbGV9XHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uRnJhbWUgPSBuZXcgUmVjdGFuZ2xlXzEuUmVjdGFuZ2xlKCk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ29sbGVjdGlvbiBvZiBmaWx0ZXJzXHJcbiAgICAgICAgICogQG1lbWJlciB7UElYSS5GaWx0ZXJbXX1cclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuZmlsdGVycyA9IFtdO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBjbGVhcnMgdGhlIHN0YXRlXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBjbGVhcigpIHtcclxuICAgICAgICB0aGlzLnRhcmdldCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5maWx0ZXJzID0gbnVsbDtcclxuICAgICAgICB0aGlzLnJlbmRlclRleHR1cmUgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgO1xyXG59XHJcbmV4cG9ydHMuRmlsdGVyU3RhdGUgPSBGaWx0ZXJTdGF0ZTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgU3lzdGVtXzEgPSByZXF1aXJlKFwiLi9TeXN0ZW1cIik7XHJcbmNvbnN0IFF1YWRfMSA9IHJlcXVpcmUoXCIuL1F1YWRcIik7XHJcbmNvbnN0IFF1YWRVdl8xID0gcmVxdWlyZShcIi4vUXVhZFV2XCIpO1xyXG5jb25zdCBSZWN0YW5nbGVfMSA9IHJlcXVpcmUoXCIuL1JlY3RhbmdsZVwiKTtcclxuY29uc3QgVW5pZm9ybUdyb3VwXzEgPSByZXF1aXJlKFwiLi9Vbmlmb3JtR3JvdXBcIik7XHJcbmNvbnN0IFJlbmRlclRleHR1cmVfMSA9IHJlcXVpcmUoXCIuL1JlbmRlclRleHR1cmVcIik7XHJcbmNvbnN0IE1hdHJpeF8xID0gcmVxdWlyZShcIi4vTWF0cml4XCIpO1xyXG5jb25zdCBGaWx0ZXJTdGF0ZV8xID0gcmVxdWlyZShcIi4vRmlsdGVyU3RhdGVcIik7XHJcbmNvbnN0IERyYXdNb2RlU2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL0RyYXdNb2RlU2V0dGluZ3NcIik7XHJcbmNvbnN0IE1hdGhTZXR0aW5nc18xID0gcmVxdWlyZShcIi4vTWF0aFNldHRpbmdzXCIpO1xyXG5jbGFzcyBGaWx0ZXJTeXN0ZW0gZXh0ZW5kcyBTeXN0ZW1fMS5TeXN0ZW0ge1xyXG4gICAgY29uc3RydWN0b3IocmVuZGVyZXIpIHtcclxuICAgICAgICBzdXBlcihyZW5kZXJlcik7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogTGlzdCBvZiBmaWx0ZXJzIGZvciB0aGUgRmlsdGVyU3lzdGVtXHJcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0W119XHJcbiAgICAgICAgICogQHJlYWRvbmx5XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5kZWZhdWx0RmlsdGVyU3RhY2sgPSBbe31dO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIHN0b3JlcyBhIGJ1bmNoIG9mIFBPMiB0ZXh0dXJlcyB1c2VkIGZvciBmaWx0ZXJpbmdcclxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy50ZXh0dXJlUG9vbCA9IHt9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIGEgcG9vbCBmb3Igc3RvcmluZyBmaWx0ZXIgc3RhdGVzLCBzYXZlIHVzIGNyZWF0aW5nIG5ldyBvbmVzIGVhY2ggdGlja1xyXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdFtdfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuc3RhdGVQb29sID0gW107XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQSB2ZXJ5IHNpbXBsZSBnZW9tZXRyeSB1c2VkIHdoZW4gZHJhd2luZyBhIGZpbHRlciBlZmZlY3QgdG8gdGhlIHNjcmVlblxyXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuUXVhZH1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnF1YWQgPSBuZXcgUXVhZF8xLlF1YWQoKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBRdWFkIFVWc1xyXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuUXVhZFV2fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMucXVhZFV2ID0gbmV3IFF1YWRVdl8xLlF1YWRVdigpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRlbXBvcmFyeSByZWN0IGZvciBtYXRoc1xyXG4gICAgICAgICAqIEB0eXBlIHtQSVhJLlJlY3RhbmdsZX1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnRlbXBSZWN0ID0gbmV3IFJlY3RhbmdsZV8xLlJlY3RhbmdsZSgpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFjdGl2ZSBzdGF0ZVxyXG4gICAgICAgICAqIEBtZW1iZXIge29iamVjdH1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmFjdGl2ZVN0YXRlID0ge307XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhpcyB1bmlmb3JtIGdyb3VwIGlzIGF0dGFjaGVkIHRvIGZpbHRlciB1bmlmb3JtcyB3aGVuIHVzZWRcclxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLlVuaWZvcm1Hcm91cH1cclxuICAgICAgICAgKiBAcHJvcGVydHkge1BJWEkuUmVjdGFuZ2xlfSBvdXRwdXRGcmFtZVxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7RmxvYXQzMkFycmF5fSBpbnB1dFNpemVcclxuICAgICAgICAgKiBAcHJvcGVydHkge0Zsb2F0MzJBcnJheX0gaW5wdXRQaXhlbFxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7RmxvYXQzMkFycmF5fSBpbnB1dENsYW1wXHJcbiAgICAgICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IHJlc29sdXRpb25cclxuICAgICAgICAgKiBAcHJvcGVydHkge0Zsb2F0MzJBcnJheX0gZmlsdGVyQXJlYVxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7RmxvYWQzMkFycmF5fSBmaWx0ZXJDbGFtcFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuZ2xvYmFsVW5pZm9ybXMgPSBuZXcgVW5pZm9ybUdyb3VwXzEuVW5pZm9ybUdyb3VwKHtcclxuICAgICAgICAgICAgb3V0cHV0RnJhbWU6IHRoaXMudGVtcFJlY3QsXHJcbiAgICAgICAgICAgIGlucHV0U2l6ZTogbmV3IEZsb2F0MzJBcnJheSg0KSxcclxuICAgICAgICAgICAgaW5wdXRQaXhlbDogbmV3IEZsb2F0MzJBcnJheSg0KSxcclxuICAgICAgICAgICAgaW5wdXRDbGFtcDogbmV3IEZsb2F0MzJBcnJheSg0KSxcclxuICAgICAgICAgICAgcmVzb2x1dGlvbjogMSxcclxuICAgICAgICAgICAgLy8gbGVnYWN5IHZhcmlhYmxlc1xyXG4gICAgICAgICAgICBmaWx0ZXJBcmVhOiBuZXcgRmxvYXQzMkFycmF5KDQpLFxyXG4gICAgICAgICAgICBmaWx0ZXJDbGFtcDogbmV3IEZsb2F0MzJBcnJheSg0KSxcclxuICAgICAgICB9LCB0cnVlKTtcclxuICAgICAgICB0aGlzLl9waXhlbHNXaWR0aCA9IHJlbmRlcmVyLnZpZXcud2lkdGg7XHJcbiAgICAgICAgdGhpcy5fcGl4ZWxzSGVpZ2h0ID0gcmVuZGVyZXIudmlldy5oZWlnaHQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYSBuZXcgZmlsdGVyIHRvIHRoZSBTeXN0ZW0uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtQSVhJLkRpc3BsYXlPYmplY3R9IHRhcmdldCAtIFRoZSB0YXJnZXQgb2YgdGhlIGZpbHRlciB0byByZW5kZXIuXHJcbiAgICAgKiBAcGFyYW0ge1BJWEkuRmlsdGVyW119IGZpbHRlcnMgLSBUaGUgZmlsdGVycyB0byBhcHBseS5cclxuICAgICAqL1xyXG4gICAgcHVzaCh0YXJnZXQsIGZpbHRlcnMpIHtcclxuICAgICAgICB2YXIgcmVuZGVyZXIgPSB0aGlzLnJlbmRlcmVyO1xyXG4gICAgICAgIHZhciBmaWx0ZXJTdGFjayA9IHRoaXMuZGVmYXVsdEZpbHRlclN0YWNrO1xyXG4gICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuc3RhdGVQb29sLnBvcCgpIHx8IG5ldyBGaWx0ZXJTdGF0ZV8xLkZpbHRlclN0YXRlKCk7XHJcbiAgICAgICAgdmFyIHJlc29sdXRpb24gPSBmaWx0ZXJzWzBdLnJlc29sdXRpb247XHJcbiAgICAgICAgdmFyIHBhZGRpbmcgPSBmaWx0ZXJzWzBdLnBhZGRpbmc7XHJcbiAgICAgICAgdmFyIGF1dG9GaXQgPSBmaWx0ZXJzWzBdLmF1dG9GaXQ7XHJcbiAgICAgICAgdmFyIGxlZ2FjeSA9IGZpbHRlcnNbMF0ubGVnYWN5O1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgZmlsdGVycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgZmlsdGVyID0gZmlsdGVyc1tpXTtcclxuICAgICAgICAgICAgLy8gbGV0cyB1c2UgdGhlIGxvd2VzdCByZXNvbHV0aW9uLi5cclxuICAgICAgICAgICAgcmVzb2x1dGlvbiA9IE1hdGgubWluKHJlc29sdXRpb24sIGZpbHRlci5yZXNvbHV0aW9uKTtcclxuICAgICAgICAgICAgLy8gYW5kIHRoZSBsYXJnZXN0IGFtb3VudCBvZiBwYWRkaW5nIVxyXG4gICAgICAgICAgICBwYWRkaW5nID0gTWF0aC5tYXgocGFkZGluZywgZmlsdGVyLnBhZGRpbmcpO1xyXG4gICAgICAgICAgICAvLyBvbmx5IGF1dG8gZml0IGlmIGFsbCBmaWx0ZXJzIGFyZSBhdXRvZml0XHJcbiAgICAgICAgICAgIGF1dG9GaXQgPSBhdXRvRml0IHx8IGZpbHRlci5hdXRvRml0O1xyXG4gICAgICAgICAgICBsZWdhY3kgPSBsZWdhY3kgfHwgZmlsdGVyLmxlZ2FjeTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGZpbHRlclN0YWNrLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgICAgICB0aGlzLmRlZmF1bHRGaWx0ZXJTdGFja1swXS5yZW5kZXJUZXh0dXJlID0gcmVuZGVyZXIucmVuZGVyVGV4dHVyZS5jdXJyZW50O1xyXG4gICAgICAgIH1cclxuICAgICAgICBmaWx0ZXJTdGFjay5wdXNoKHN0YXRlKTtcclxuICAgICAgICBzdGF0ZS5yZXNvbHV0aW9uID0gcmVzb2x1dGlvbjtcclxuICAgICAgICBzdGF0ZS5sZWdhY3kgPSBsZWdhY3k7XHJcbiAgICAgICAgc3RhdGUudGFyZ2V0ID0gdGFyZ2V0O1xyXG4gICAgICAgIHN0YXRlLnNvdXJjZUZyYW1lLmNvcHlGcm9tKHRhcmdldC5maWx0ZXJBcmVhIHx8IHRhcmdldC5nZXRCb3VuZHModHJ1ZSkpO1xyXG4gICAgICAgIHN0YXRlLnNvdXJjZUZyYW1lLnBhZChwYWRkaW5nKTtcclxuICAgICAgICBpZiAoYXV0b0ZpdCkge1xyXG4gICAgICAgICAgICBzdGF0ZS5zb3VyY2VGcmFtZS5maXQodGhpcy5yZW5kZXJlci5yZW5kZXJUZXh0dXJlLnNvdXJjZUZyYW1lKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gcm91bmQgdG8gd2hvbGUgbnVtYmVyIGJhc2VkIG9uIHJlc29sdXRpb25cclxuICAgICAgICBzdGF0ZS5zb3VyY2VGcmFtZS5jZWlsKHJlc29sdXRpb24pO1xyXG4gICAgICAgIHN0YXRlLnJlbmRlclRleHR1cmUgPSB0aGlzLmdldE9wdGltYWxGaWx0ZXJUZXh0dXJlKHN0YXRlLnNvdXJjZUZyYW1lLndpZHRoLCBzdGF0ZS5zb3VyY2VGcmFtZS5oZWlnaHQsIHJlc29sdXRpb24pO1xyXG4gICAgICAgIHN0YXRlLmZpbHRlcnMgPSBmaWx0ZXJzO1xyXG4gICAgICAgIHN0YXRlLmRlc3RpbmF0aW9uRnJhbWUud2lkdGggPSBzdGF0ZS5yZW5kZXJUZXh0dXJlLndpZHRoO1xyXG4gICAgICAgIHN0YXRlLmRlc3RpbmF0aW9uRnJhbWUuaGVpZ2h0ID0gc3RhdGUucmVuZGVyVGV4dHVyZS5oZWlnaHQ7XHJcbiAgICAgICAgc3RhdGUucmVuZGVyVGV4dHVyZS5maWx0ZXJGcmFtZSA9IHN0YXRlLnNvdXJjZUZyYW1lO1xyXG4gICAgICAgIHJlbmRlcmVyLnJlbmRlclRleHR1cmUuYmluZChzdGF0ZS5yZW5kZXJUZXh0dXJlLCBzdGF0ZS5zb3VyY2VGcmFtZSk7IC8vIC8sIHN0YXRlLmRlc3RpbmF0aW9uRnJhbWUpO1xyXG4gICAgICAgIHJlbmRlcmVyLnJlbmRlclRleHR1cmUuY2xlYXIoKTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogUG9wcyBvZmYgdGhlIGZpbHRlciBhbmQgYXBwbGllcyBpdC5cclxuICAgICAqXHJcbiAgICAgKi9cclxuICAgIHBvcCgpIHtcclxuICAgICAgICB2YXIgZmlsdGVyU3RhY2sgPSB0aGlzLmRlZmF1bHRGaWx0ZXJTdGFjaztcclxuICAgICAgICB2YXIgc3RhdGUgPSBmaWx0ZXJTdGFjay5wb3AoKTtcclxuICAgICAgICB2YXIgZmlsdGVycyA9IHN0YXRlLmZpbHRlcnM7XHJcbiAgICAgICAgdGhpcy5hY3RpdmVTdGF0ZSA9IHN0YXRlO1xyXG4gICAgICAgIHZhciBnbG9iYWxVbmlmb3JtcyA9IHRoaXMuZ2xvYmFsVW5pZm9ybXMudW5pZm9ybXM7XHJcbiAgICAgICAgZ2xvYmFsVW5pZm9ybXMub3V0cHV0RnJhbWUgPSBzdGF0ZS5zb3VyY2VGcmFtZTtcclxuICAgICAgICBnbG9iYWxVbmlmb3Jtcy5yZXNvbHV0aW9uID0gc3RhdGUucmVzb2x1dGlvbjtcclxuICAgICAgICB2YXIgaW5wdXRTaXplID0gZ2xvYmFsVW5pZm9ybXMuaW5wdXRTaXplO1xyXG4gICAgICAgIHZhciBpbnB1dFBpeGVsID0gZ2xvYmFsVW5pZm9ybXMuaW5wdXRQaXhlbDtcclxuICAgICAgICB2YXIgaW5wdXRDbGFtcCA9IGdsb2JhbFVuaWZvcm1zLmlucHV0Q2xhbXA7XHJcbiAgICAgICAgaW5wdXRTaXplWzBdID0gc3RhdGUuZGVzdGluYXRpb25GcmFtZS53aWR0aDtcclxuICAgICAgICBpbnB1dFNpemVbMV0gPSBzdGF0ZS5kZXN0aW5hdGlvbkZyYW1lLmhlaWdodDtcclxuICAgICAgICBpbnB1dFNpemVbMl0gPSAxLjAgLyBpbnB1dFNpemVbMF07XHJcbiAgICAgICAgaW5wdXRTaXplWzNdID0gMS4wIC8gaW5wdXRTaXplWzFdO1xyXG4gICAgICAgIGlucHV0UGl4ZWxbMF0gPSBpbnB1dFNpemVbMF0gKiBzdGF0ZS5yZXNvbHV0aW9uO1xyXG4gICAgICAgIGlucHV0UGl4ZWxbMV0gPSBpbnB1dFNpemVbMV0gKiBzdGF0ZS5yZXNvbHV0aW9uO1xyXG4gICAgICAgIGlucHV0UGl4ZWxbMl0gPSAxLjAgLyBpbnB1dFBpeGVsWzBdO1xyXG4gICAgICAgIGlucHV0UGl4ZWxbM10gPSAxLjAgLyBpbnB1dFBpeGVsWzFdO1xyXG4gICAgICAgIGlucHV0Q2xhbXBbMF0gPSAwLjUgKiBpbnB1dFBpeGVsWzJdO1xyXG4gICAgICAgIGlucHV0Q2xhbXBbMV0gPSAwLjUgKiBpbnB1dFBpeGVsWzNdO1xyXG4gICAgICAgIGlucHV0Q2xhbXBbMl0gPSAoc3RhdGUuc291cmNlRnJhbWUud2lkdGggKiBpbnB1dFNpemVbMl0pIC0gKDAuNSAqIGlucHV0UGl4ZWxbMl0pO1xyXG4gICAgICAgIGlucHV0Q2xhbXBbM10gPSAoc3RhdGUuc291cmNlRnJhbWUuaGVpZ2h0ICogaW5wdXRTaXplWzNdKSAtICgwLjUgKiBpbnB1dFBpeGVsWzNdKTtcclxuICAgICAgICAvLyBvbmx5IHVwZGF0ZSB0aGUgcmVjdCBpZiBpdHMgbGVnYWN5Li5cclxuICAgICAgICBpZiAoc3RhdGUubGVnYWN5KSB7XHJcbiAgICAgICAgICAgIHZhciBmaWx0ZXJBcmVhID0gZ2xvYmFsVW5pZm9ybXMuZmlsdGVyQXJlYTtcclxuICAgICAgICAgICAgZmlsdGVyQXJlYVswXSA9IHN0YXRlLmRlc3RpbmF0aW9uRnJhbWUud2lkdGg7XHJcbiAgICAgICAgICAgIGZpbHRlckFyZWFbMV0gPSBzdGF0ZS5kZXN0aW5hdGlvbkZyYW1lLmhlaWdodDtcclxuICAgICAgICAgICAgZmlsdGVyQXJlYVsyXSA9IHN0YXRlLnNvdXJjZUZyYW1lLng7XHJcbiAgICAgICAgICAgIGZpbHRlckFyZWFbM10gPSBzdGF0ZS5zb3VyY2VGcmFtZS55O1xyXG4gICAgICAgICAgICBnbG9iYWxVbmlmb3Jtcy5maWx0ZXJDbGFtcCA9IGdsb2JhbFVuaWZvcm1zLmlucHV0Q2xhbXA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZ2xvYmFsVW5pZm9ybXMudXBkYXRlKCk7XHJcbiAgICAgICAgdmFyIGxhc3RTdGF0ZSA9IGZpbHRlclN0YWNrW2ZpbHRlclN0YWNrLmxlbmd0aCAtIDFdO1xyXG4gICAgICAgIGlmIChmaWx0ZXJzLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgICAgICBmaWx0ZXJzWzBdLmFwcGx5KHRoaXMsIHN0YXRlLnJlbmRlclRleHR1cmUsIGxhc3RTdGF0ZS5yZW5kZXJUZXh0dXJlLCBmYWxzZSwgc3RhdGUpO1xyXG4gICAgICAgICAgICB0aGlzLnJldHVybkZpbHRlclRleHR1cmUoc3RhdGUucmVuZGVyVGV4dHVyZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgZmxpcCA9IHN0YXRlLnJlbmRlclRleHR1cmU7XHJcbiAgICAgICAgICAgIHZhciBmbG9wID0gdGhpcy5nZXRPcHRpbWFsRmlsdGVyVGV4dHVyZShmbGlwLndpZHRoLCBmbGlwLmhlaWdodCwgc3RhdGUucmVzb2x1dGlvbik7XHJcbiAgICAgICAgICAgIGZsb3AuZmlsdGVyRnJhbWUgPSBmbGlwLmZpbHRlckZyYW1lO1xyXG4gICAgICAgICAgICB2YXIgaSA9IDA7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBmaWx0ZXJzLmxlbmd0aCAtIDE7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgZmlsdGVyc1tpXS5hcHBseSh0aGlzLCBmbGlwLCBmbG9wLCB0cnVlLCBzdGF0ZSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgdCA9IGZsaXA7XHJcbiAgICAgICAgICAgICAgICBmbGlwID0gZmxvcDtcclxuICAgICAgICAgICAgICAgIGZsb3AgPSB0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZpbHRlcnNbaV0uYXBwbHkodGhpcywgZmxpcCwgbGFzdFN0YXRlLnJlbmRlclRleHR1cmUsIGZhbHNlLCBzdGF0ZSk7XHJcbiAgICAgICAgICAgIHRoaXMucmV0dXJuRmlsdGVyVGV4dHVyZShmbGlwKTtcclxuICAgICAgICAgICAgdGhpcy5yZXR1cm5GaWx0ZXJUZXh0dXJlKGZsb3ApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzdGF0ZS5jbGVhcigpO1xyXG4gICAgICAgIHRoaXMuc3RhdGVQb29sLnB1c2goc3RhdGUpO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBEcmF3cyBhIGZpbHRlci5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1BJWEkuRmlsdGVyfSBmaWx0ZXIgLSBUaGUgZmlsdGVyIHRvIGRyYXcuXHJcbiAgICAgKiBAcGFyYW0ge1BJWEkuUmVuZGVyVGV4dHVyZX0gaW5wdXQgLSBUaGUgaW5wdXQgcmVuZGVyIHRhcmdldC5cclxuICAgICAqIEBwYXJhbSB7UElYSS5SZW5kZXJUZXh0dXJlfSBvdXRwdXQgLSBUaGUgdGFyZ2V0IHRvIG91dHB1dCB0by5cclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gY2xlYXIgLSBTaG91bGQgdGhlIG91dHB1dCBiZSBjbGVhcmVkIGJlZm9yZSByZW5kZXJpbmcgdG8gaXRcclxuICAgICAqL1xyXG4gICAgYXBwbHlGaWx0ZXIoZmlsdGVyLCBpbnB1dCwgb3V0cHV0LCBjbGVhcikge1xyXG4gICAgICAgIHZhciByZW5kZXJlciA9IHRoaXMucmVuZGVyZXI7XHJcbiAgICAgICAgcmVuZGVyZXIucmVuZGVyVGV4dHVyZS5iaW5kKG91dHB1dCwgb3V0cHV0ID8gb3V0cHV0LmZpbHRlckZyYW1lIDogbnVsbCk7XHJcbiAgICAgICAgaWYgKGNsZWFyKSB7XHJcbiAgICAgICAgICAgIC8vIGdsLmRpc2FibGUoZ2wuU0NJU1NPUl9URVNUKTtcclxuICAgICAgICAgICAgcmVuZGVyZXIucmVuZGVyVGV4dHVyZS5jbGVhcigpO1xyXG4gICAgICAgICAgICAvLyBnbC5lbmFibGUoZ2wuU0NJU1NPUl9URVNUKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gc2V0IHRoZSB1bmlmb3Jtcy4uXHJcbiAgICAgICAgZmlsdGVyLnVuaWZvcm1zLnVTYW1wbGVyID0gaW5wdXQ7XHJcbiAgICAgICAgZmlsdGVyLnVuaWZvcm1zLmZpbHRlckdsb2JhbHMgPSB0aGlzLmdsb2JhbFVuaWZvcm1zO1xyXG4gICAgICAgIC8vIFRPRE8gbWFrZSBpdCBzbyB0aGF0IHRoZSBvcmRlciBvZiB0aGlzIGRvZXMgbm90IG1hdHRlci4uXHJcbiAgICAgICAgLy8gYmVjYXVzZSBpdCBkb2VzIGF0IHRoZSBtb21lbnQgY29zIG9mIGdsb2JhbCB1bmlmb3Jtcy5cclxuICAgICAgICAvLyB0aGV5IG5lZWQgdG8gZ2V0IHJlc3luY2VkXHJcbiAgICAgICAgcmVuZGVyZXIuc3RhdGUuc2V0U3RhdGUoZmlsdGVyLnN0YXRlKTtcclxuICAgICAgICByZW5kZXJlci5zaGFkZXIuYmluZChmaWx0ZXIpO1xyXG4gICAgICAgIGlmIChmaWx0ZXIubGVnYWN5KSB7XHJcbiAgICAgICAgICAgIHRoaXMucXVhZFV2Lm1hcChpbnB1dC5fZnJhbWUsIGlucHV0LmZpbHRlckZyYW1lKTtcclxuICAgICAgICAgICAgcmVuZGVyZXIuZ2VvbWV0cnkuYmluZCh0aGlzLnF1YWRVdik7XHJcbiAgICAgICAgICAgIHJlbmRlcmVyLmdlb21ldHJ5LmRyYXcoRHJhd01vZGVTZXR0aW5nc18xLkRyYXdNb2RlU2V0dGluZ3MuRFJBV19NT0RFUy5UUklBTkdMRVMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmVuZGVyZXIuZ2VvbWV0cnkuYmluZCh0aGlzLnF1YWQpO1xyXG4gICAgICAgICAgICByZW5kZXJlci5nZW9tZXRyeS5kcmF3KERyYXdNb2RlU2V0dGluZ3NfMS5EcmF3TW9kZVNldHRpbmdzLkRSQVdfTU9ERVMuVFJJQU5HTEVfU1RSSVApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQ2FsY3VsYXRlcyB0aGUgbWFwcGVkIG1hdHJpeC5cclxuICAgICAqXHJcbiAgICAgKiBUT0RPIHBsYXlpbmcgYXJvdW5kIGhlcmUuLiB0aGlzIGlzIHRlbXBvcmFyeSAtICh3aWxsIGVuZCB1cCBpbiB0aGUgc2hhZGVyKVxyXG4gICAgICogdGhpcyByZXR1cm5zIGEgbWF0cml4IHRoYXQgd2lsbCBub3JtYWxpemUgbWFwIGZpbHRlciBjb3JkcyBpbiB0aGUgZmlsdGVyIHRvIHNjcmVlbiBzcGFjZVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7UElYSS5NYXRyaXh9IG91dHB1dE1hdHJpeCAtIHRoZSBtYXRyaXggdG8gb3V0cHV0IHRvLlxyXG4gICAgICogQHJldHVybiB7UElYSS5NYXRyaXh9IFRoZSBtYXBwZWQgbWF0cml4LlxyXG4gICAgICovXHJcbiAgICBjYWxjdWxhdGVTY3JlZW5TcGFjZU1hdHJpeChvdXRwdXRNYXRyaXgpIHtcclxuICAgICAgICB2YXIgY3VycmVudFN0YXRlID0gdGhpcy5hY3RpdmVTdGF0ZTtcclxuICAgICAgICByZXR1cm4gRmlsdGVyU3lzdGVtLmNhbGN1bGF0ZVNjcmVlblNwYWNlTWF0cml4KG91dHB1dE1hdHJpeCwgY3VycmVudFN0YXRlLnNvdXJjZUZyYW1lLCBjdXJyZW50U3RhdGUuZGVzdGluYXRpb25GcmFtZSk7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgd2lsbCBtYXAgdGhlIGZpbHRlciBjb29yZCBzbyB0aGF0IGEgdGV4dHVyZSBjYW4gYmUgdXNlZCBiYXNlZCBvbiB0aGUgdHJhbnNmb3JtIG9mIGEgc3ByaXRlXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtQSVhJLk1hdHJpeH0gb3V0cHV0TWF0cml4IC0gVGhlIG1hdHJpeCB0byBvdXRwdXQgdG8uXHJcbiAgICAgKiBAcGFyYW0ge1BJWEkuU3ByaXRlfSBzcHJpdGUgLSBUaGUgc3ByaXRlIHRvIG1hcCB0by5cclxuICAgICAqIEByZXR1cm4ge1BJWEkuTWF0cml4fSBUaGUgbWFwcGVkIG1hdHJpeC5cclxuICAgICAqL1xyXG4gICAgY2FsY3VsYXRlU3ByaXRlTWF0cml4KG91dHB1dE1hdHJpeCwgc3ByaXRlKSB7XHJcbiAgICAgICAgdmFyIGN1cnJlbnRTdGF0ZSA9IHRoaXMuYWN0aXZlU3RhdGU7XHJcbiAgICAgICAgcmV0dXJuIEZpbHRlclN5c3RlbS5jYWxjdWxhdGVTcHJpdGVNYXRyaXgob3V0cHV0TWF0cml4LCBjdXJyZW50U3RhdGUuc291cmNlRnJhbWUsIGN1cnJlbnRTdGF0ZS5kZXN0aW5hdGlvbkZyYW1lLCBzcHJpdGUpO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBEZXN0cm95cyB0aGlzIEZpbHRlciBTeXN0ZW0uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbY29udGV4dExvc3Q9ZmFsc2VdIGNvbnRleHQgd2FzIGxvc3QsIGRvIG5vdCBmcmVlIHNoYWRlcnNcclxuICAgICAqXHJcbiAgICAgKi9cclxuICAgIGRlc3Ryb3koY29udGV4dExvc3QpIHtcclxuICAgICAgICBpZiAoY29udGV4dExvc3QgPT09IHZvaWQgMCkge1xyXG4gICAgICAgICAgICBjb250ZXh0TG9zdCA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWNvbnRleHRMb3N0KSB7XHJcbiAgICAgICAgICAgIHRoaXMuZW1wdHlQb29sKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnRleHR1cmVQb29sID0ge307XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIGEgUG93ZXItb2YtVHdvIHJlbmRlciB0ZXh0dXJlIG9yIGZ1bGxTY3JlZW4gdGV4dHVyZVxyXG4gICAgICpcclxuICAgICAqIFRPRE8gbW92ZSB0byBhIHNlcGFyYXRlIGNsYXNzIGNvdWxkIGJlIG9uIHJlbmRlcmVyP1xyXG4gICAgICpcclxuICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtaW5XaWR0aCAtIFRoZSBtaW5pbXVtIHdpZHRoIG9mIHRoZSByZW5kZXIgdGV4dHVyZSBpbiByZWFsIHBpeGVscy5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtaW5IZWlnaHQgLSBUaGUgbWluaW11bSBoZWlnaHQgb2YgdGhlIHJlbmRlciB0ZXh0dXJlIGluIHJlYWwgcGl4ZWxzLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtyZXNvbHV0aW9uPTFdIC0gVGhlIHJlc29sdXRpb24gb2YgdGhlIHJlbmRlciB0ZXh0dXJlLlxyXG4gICAgICogQHJldHVybiB7UElYSS5SZW5kZXJUZXh0dXJlfSBUaGUgbmV3IHJlbmRlciB0ZXh0dXJlLlxyXG4gICAgICovXHJcbiAgICBnZXRPcHRpbWFsRmlsdGVyVGV4dHVyZShtaW5XaWR0aCwgbWluSGVpZ2h0LCByZXNvbHV0aW9uKSB7XHJcbiAgICAgICAgaWYgKHJlc29sdXRpb24gPT09IHZvaWQgMCkge1xyXG4gICAgICAgICAgICByZXNvbHV0aW9uID0gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGtleSA9IEZpbHRlclN5c3RlbS5zY3JlZW5LZXk7XHJcbiAgICAgICAgbWluV2lkdGggKj0gcmVzb2x1dGlvbjtcclxuICAgICAgICBtaW5IZWlnaHQgKj0gcmVzb2x1dGlvbjtcclxuICAgICAgICBpZiAobWluV2lkdGggIT09IHRoaXMuX3BpeGVsc1dpZHRoIHx8IG1pbkhlaWdodCAhPT0gdGhpcy5fcGl4ZWxzSGVpZ2h0KSB7XHJcbiAgICAgICAgICAgIG1pbldpZHRoID0gTWF0aFNldHRpbmdzXzEuTWF0aFNldHRpbmdzLm5leHRQb3cyKG1pbldpZHRoKTtcclxuICAgICAgICAgICAgbWluSGVpZ2h0ID0gTWF0aFNldHRpbmdzXzEuTWF0aFNldHRpbmdzLm5leHRQb3cyKG1pbkhlaWdodCk7XHJcbiAgICAgICAgICAgIGtleSA9ICgobWluV2lkdGggJiAweEZGRkYpIDw8IDE2KSB8IChtaW5IZWlnaHQgJiAweEZGRkYpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXRoaXMudGV4dHVyZVBvb2xba2V5XSkge1xyXG4gICAgICAgICAgICB0aGlzLnRleHR1cmVQb29sW2tleV0gPSBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHJlbmRlclRleHR1cmUgPSB0aGlzLnRleHR1cmVQb29sW2tleV0ucG9wKCk7XHJcbiAgICAgICAgaWYgKCFyZW5kZXJUZXh0dXJlKSB7XHJcbiAgICAgICAgICAgIC8vIHRlbXBvcmFyeSBieXBhc3MgY2FjaGUuLlxyXG4gICAgICAgICAgICAvLyBpbnRlcm5hbGx5IC0gdGhpcyB3aWxsIGNhdXNlIGEgdGV4dHVyZSB0byBiZSBib3VuZC4uXHJcbiAgICAgICAgICAgIHJlbmRlclRleHR1cmUgPSBSZW5kZXJUZXh0dXJlXzEuUmVuZGVyVGV4dHVyZS5jcmVhdGUoe1xyXG4gICAgICAgICAgICAgICAgd2lkdGg6IG1pbldpZHRoIC8gcmVzb2x1dGlvbixcclxuICAgICAgICAgICAgICAgIGhlaWdodDogbWluSGVpZ2h0IC8gcmVzb2x1dGlvbixcclxuICAgICAgICAgICAgICAgIHJlc29sdXRpb246IHJlc29sdXRpb24sXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZW5kZXJUZXh0dXJlLmZpbHRlclBvb2xLZXkgPSBrZXk7XHJcbiAgICAgICAgcmV0dXJuIHJlbmRlclRleHR1cmU7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgZXh0cmEgcmVuZGVyIHRleHR1cmUgdG8gdXNlIGluc2lkZSBjdXJyZW50IGZpbHRlclxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByZXNvbHV0aW9uIHJlc29sdXRpb24gb2YgdGhlIHJlbmRlclRleHR1cmVcclxuICAgICAqIEByZXR1cm5zIHtQSVhJLlJlbmRlclRleHR1cmV9XHJcbiAgICAgKi9cclxuICAgIGdldEZpbHRlclRleHR1cmUocmVzb2x1dGlvbikge1xyXG4gICAgICAgIHZhciBydCA9IHRoaXMuYWN0aXZlU3RhdGUucmVuZGVyVGV4dHVyZTtcclxuICAgICAgICB2YXIgZmlsdGVyVGV4dHVyZSA9IHRoaXMuZ2V0T3B0aW1hbEZpbHRlclRleHR1cmUocnQud2lkdGgsIHJ0LmhlaWdodCwgcmVzb2x1dGlvbiB8fCBydC5iYXNlVGV4dHVyZS5yZXNvbHV0aW9uKTtcclxuICAgICAgICBmaWx0ZXJUZXh0dXJlLmZpbHRlckZyYW1lID0gcnQuZmlsdGVyRnJhbWU7XHJcbiAgICAgICAgcmV0dXJuIGZpbHRlclRleHR1cmU7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIEZyZWVzIGEgcmVuZGVyIHRleHR1cmUgYmFjayBpbnRvIHRoZSBwb29sLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7UElYSS5SZW5kZXJUZXh0dXJlfSByZW5kZXJUZXh0dXJlIC0gVGhlIHJlbmRlclRhcmdldCB0byBmcmVlXHJcbiAgICAgKi9cclxuICAgIHJldHVybkZpbHRlclRleHR1cmUocmVuZGVyVGV4dHVyZSkge1xyXG4gICAgICAgIHZhciBrZXkgPSByZW5kZXJUZXh0dXJlLmZpbHRlclBvb2xLZXk7XHJcbiAgICAgICAgcmVuZGVyVGV4dHVyZS5maWx0ZXJGcmFtZSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy50ZXh0dXJlUG9vbFtrZXldLnB1c2gocmVuZGVyVGV4dHVyZSk7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIEVtcHRpZXMgdGhlIHRleHR1cmUgcG9vbC5cclxuICAgICAqXHJcbiAgICAgKi9cclxuICAgIGVtcHR5UG9vbCgpIHtcclxuICAgICAgICBmb3IgKHZhciBpIGluIHRoaXMudGV4dHVyZVBvb2wpIHtcclxuICAgICAgICAgICAgdmFyIHRleHR1cmVzID0gdGhpcy50ZXh0dXJlUG9vbFtpXTtcclxuICAgICAgICAgICAgaWYgKHRleHR1cmVzKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRleHR1cmVzLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGV4dHVyZXNbal0uZGVzdHJveSh0cnVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnRleHR1cmVQb29sID0ge307XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICByZXNpemUoKSB7XHJcbiAgICAgICAgdmFyIHRleHR1cmVzID0gdGhpcy50ZXh0dXJlUG9vbFtGaWx0ZXJTeXN0ZW0uc2NyZWVuS2V5XTtcclxuICAgICAgICBpZiAodGV4dHVyZXMpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0ZXh0dXJlcy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgdGV4dHVyZXNbal0uZGVzdHJveSh0cnVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnRleHR1cmVQb29sW0ZpbHRlclN5c3RlbS5zY3JlZW5LZXldID0gW107XHJcbiAgICAgICAgdGhpcy5fcGl4ZWxzV2lkdGggPSB0aGlzLnJlbmRlcmVyLnZpZXcud2lkdGg7XHJcbiAgICAgICAgdGhpcy5fcGl4ZWxzSGVpZ2h0ID0gdGhpcy5yZW5kZXJlci52aWV3LmhlaWdodDtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8vIHRoaXMgd2lsbCBtYXAgdGhlIGZpbHRlciBjb29yZCBzbyB0aGF0IGEgdGV4dHVyZSBjYW4gYmUgdXNlZCBiYXNlZCBvbiB0aGUgdHJhbnNmb3JtIG9mIGEgc3ByaXRlXHJcbiAgICBzdGF0aWMgY2FsY3VsYXRlU3ByaXRlTWF0cml4KG91dHB1dE1hdHJpeCwgZmlsdGVyQXJlYSwgdGV4dHVyZVNpemUsIHNwcml0ZSkge1xyXG4gICAgICAgIHZhciBvcmlnID0gc3ByaXRlLl90ZXh0dXJlLm9yaWc7XHJcbiAgICAgICAgdmFyIG1hcHBlZE1hdHJpeCA9IG91dHB1dE1hdHJpeC5zZXQodGV4dHVyZVNpemUud2lkdGgsIDAsIDAsIHRleHR1cmVTaXplLmhlaWdodCwgZmlsdGVyQXJlYS54LCBmaWx0ZXJBcmVhLnkpO1xyXG4gICAgICAgIHZhciB3b3JsZFRyYW5zZm9ybSA9IHNwcml0ZS53b3JsZFRyYW5zZm9ybS5jb3B5VG8oTWF0cml4XzEuTWF0cml4LlRFTVBfTUFUUklYKTtcclxuICAgICAgICB3b3JsZFRyYW5zZm9ybS5pbnZlcnQoKTtcclxuICAgICAgICBtYXBwZWRNYXRyaXgucHJlcGVuZCh3b3JsZFRyYW5zZm9ybSk7XHJcbiAgICAgICAgbWFwcGVkTWF0cml4LnNjYWxlKDEuMCAvIG9yaWcud2lkdGgsIDEuMCAvIG9yaWcuaGVpZ2h0KTtcclxuICAgICAgICBtYXBwZWRNYXRyaXgudHJhbnNsYXRlKHNwcml0ZS5hbmNob3IueCwgc3ByaXRlLmFuY2hvci55KTtcclxuICAgICAgICByZXR1cm4gbWFwcGVkTWF0cml4O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAqIENhbGN1bGF0ZXMgdGhlIG1hcHBlZCBtYXRyaXhcclxuICogQHBhcmFtIHtQSVhJLk1hdHJpeH0gb3V0cHV0TWF0cml4IG1hdHJpeCB0aGF0IHdpbGwgbm9ybWFsaXplIG1hcCBmaWx0ZXIgY29yZHMgaW4gdGhlIGZpbHRlciB0byBzY3JlZW4gc3BhY2VcclxuICogQHBhcmFtIHtQSVhJLlJlY3RhbmdsZX0gZmlsdGVyQXJlYSBmaWx0ZXIgYXJlYVxyXG4gKiBAcGFyYW0ge1BJWEkuUmVjdGFuZ2xlfSB0ZXh0dXJlU2l6ZSB0ZXh0dXJlIHNpemVcclxuICogQHJldHVybnMge1BJWEkuTWF0cml4fSBzYW1lIGFzIG91dHB1dE1hdHJpeFxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuICAgIHN0YXRpYyBjYWxjdWxhdGVTY3JlZW5TcGFjZU1hdHJpeChvdXRwdXRNYXRyaXgsIGZpbHRlckFyZWEsIHRleHR1cmVTaXplKSB7XHJcbiAgICAgICAgLy8gVE9ETyB1bndyYXA/XHJcbiAgICAgICAgdmFyIG1hcHBlZE1hdHJpeCA9IG91dHB1dE1hdHJpeC5pZGVudGl0eSgpO1xyXG4gICAgICAgIG1hcHBlZE1hdHJpeC50cmFuc2xhdGUoZmlsdGVyQXJlYS54IC8gdGV4dHVyZVNpemUud2lkdGgsIGZpbHRlckFyZWEueSAvIHRleHR1cmVTaXplLmhlaWdodCk7XHJcbiAgICAgICAgbWFwcGVkTWF0cml4LnNjYWxlKHRleHR1cmVTaXplLndpZHRoLCB0ZXh0dXJlU2l6ZS5oZWlnaHQpO1xyXG4gICAgICAgIHJldHVybiBtYXBwZWRNYXRyaXg7XHJcbiAgICB9XHJcbn1cclxuRmlsdGVyU3lzdGVtLnNjcmVlbktleSA9ICdzY3JlZW4nO1xyXG5leHBvcnRzLkZpbHRlclN5c3RlbSA9IEZpbHRlclN5c3RlbTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY2xhc3MgRmxhc2hCYXNlT2JqZWN0IHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIEZsYXNoQmFzZU9iamVjdC5uYW1lQ291bnQrKztcclxuICAgICAgICB0aGlzLl9uYW1lID0gXCJpbnN0YW5jZS1cIiArIHRoaXMuY2xhc3NOYW1lICsgXCItXCIgKyBGbGFzaEJhc2VPYmplY3QubmFtZUNvdW50O1xyXG4gICAgICAgIHRoaXMuX2luc3RhbmNlTmFtZSA9IFwiaW5zdGFuY2UtXCIgKyB0aGlzLmNsYXNzTmFtZSArIFwiLVwiICsgRmxhc2hCYXNlT2JqZWN0Lm5hbWVDb3VudDtcclxuICAgICAgICB0aGlzLl9oYXNDaGFuZ2VkID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLl9jbGFzc05hbWUgPSB0aGlzLmNvbnN0cnVjdG9yWyduYW1lJ107XHJcbiAgICB9XHJcbiAgICBnZXQgY2xhc3NOYW1lKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yWyduYW1lJ107XHJcbiAgICB9XHJcbiAgICBkZXN0cnVjdG9yKCkge1xyXG4gICAgfVxyXG4gICAgZ2V0IGhhc0NoYW5nZWQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hhc0NoYW5nZWQ7XHJcbiAgICB9XHJcbiAgICBzZXQgaGFzQ2hhbmdlZCh2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuX2hhc0NoYW5nZWQgPSB2YWx1ZTtcclxuICAgIH1cclxuICAgIGdldCBuYW1lKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9uYW1lO1xyXG4gICAgfVxyXG4gICAgc2V0IG5hbWUodmFsdWUpIHtcclxuICAgICAgICB0aGlzLl9uYW1lID0gdmFsdWU7XHJcbiAgICB9XHJcbiAgICBnZXQgaW5zdGFuY2VOYW1lKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9pbnN0YW5jZU5hbWU7XHJcbiAgICB9XHJcbn1cclxuRmxhc2hCYXNlT2JqZWN0Lm5hbWVDb3VudCA9IDA7XHJcbmV4cG9ydHMuRmxhc2hCYXNlT2JqZWN0ID0gRmxhc2hCYXNlT2JqZWN0O1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBCYXNlVGV4dHVyZV8xID0gcmVxdWlyZShcIi4vQmFzZVRleHR1cmVcIik7XHJcbmNvbnN0IERlcHRoUmVzb3VyY2VfMSA9IHJlcXVpcmUoXCIuL0RlcHRoUmVzb3VyY2VcIik7XHJcbmNvbnN0IFdlYkdMU2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL1dlYkdMU2V0dGluZ3NcIik7XHJcbmNvbnN0IFJ1bm5lcl8xID0gcmVxdWlyZShcIi4vUnVubmVyXCIpO1xyXG5jbGFzcyBGcmFtZWJ1ZmZlciB7XHJcbiAgICBjb25zdHJ1Y3Rvcih3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICAgICAgdGhpcy53aWR0aCA9IE1hdGguY2VpbCh3aWR0aCB8fCAxMDApO1xyXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gTWF0aC5jZWlsKGhlaWdodCB8fCAxMDApO1xyXG4gICAgICAgIHRoaXMuc3RlbmNpbCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuZGVwdGggPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmRpcnR5SWQgPSAwO1xyXG4gICAgICAgIHRoaXMuZGlydHlGb3JtYXQgPSAwO1xyXG4gICAgICAgIHRoaXMuZGlydHlTaXplID0gMDtcclxuICAgICAgICB0aGlzLmRlcHRoVGV4dHVyZSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5jb2xvclRleHR1cmVzID0gW107XHJcbiAgICAgICAgdGhpcy5nbEZyYW1lYnVmZmVycyA9IHt9O1xyXG4gICAgICAgIHRoaXMuZGlzcG9zZVJ1bm5lciA9IG5ldyBSdW5uZXJfMS5SdW5uZXIoJ2Rpc3Bvc2VGcmFtZWJ1ZmZlcicsIDIpO1xyXG4gICAgICAgIC8vIHRoaXMuZGlzcG9zZVJ1bm5lciA9IG5ldyBSdW5uZXIoJ2Rpc3Bvc2VGcmFtZWJ1ZmZlcicsIDIpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWZlcmVuY2UgdG8gdGhlIGNvbG9yVGV4dHVyZS5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtQSVhJLlRleHR1cmVbXX1cclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICovXHJcbiAgICBnZXQgY29sb3JUZXh0dXJlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbG9yVGV4dHVyZXNbMF07XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIEFkZCB0ZXh0dXJlIHRvIHRoZSBjb2xvclRleHR1cmUgYXJyYXlcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2luZGV4PTBdIC0gSW5kZXggb2YgdGhlIGFycmF5IHRvIGFkZCB0aGUgdGV4dHVyZSB0b1xyXG4gICAgICogQHBhcmFtIHtQSVhJLlRleHR1cmV9IFt0ZXh0dXJlXSAtIFRleHR1cmUgdG8gYWRkIHRvIHRoZSBhcnJheVxyXG4gICAgICovXHJcbiAgICBhZGRDb2xvclRleHR1cmUoaW5kZXgsIHRleHR1cmUpIHtcclxuICAgICAgICBpZiAoaW5kZXggPT09IHZvaWQgMCkge1xyXG4gICAgICAgICAgICBpbmRleCA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFRPRE8gYWRkIHNvbWUgdmFsaWRhdGlvbiB0byB0aGUgdGV4dHVyZSAtIHNhbWUgd2lkdGggLyBoZWlnaHQgZXRjP1xyXG4gICAgICAgIHRoaXMuY29sb3JUZXh0dXJlc1tpbmRleF0gPSB0ZXh0dXJlIHx8IG5ldyBCYXNlVGV4dHVyZV8xLkJhc2VUZXh0dXJlKG51bGwsIHsgc2NhbGVNb2RlOiAwLFxyXG4gICAgICAgICAgICByZXNvbHV0aW9uOiAxLFxyXG4gICAgICAgICAgICBtaXBtYXA6IGZhbHNlLFxyXG4gICAgICAgICAgICB3aWR0aDogdGhpcy53aWR0aCxcclxuICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodCB9KTsgLy8gfHwgbmV3IFRleHR1cmUoKTtcclxuICAgICAgICB0aGlzLmRpcnR5SWQrKztcclxuICAgICAgICB0aGlzLmRpcnR5Rm9ybWF0Kys7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIEFkZCBhIGRlcHRoIHRleHR1cmUgdG8gdGhlIGZyYW1lIGJ1ZmZlclxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7UElYSS5UZXh0dXJlfSBbdGV4dHVyZV0gLSBUZXh0dXJlIHRvIGFkZFxyXG4gICAgICovXHJcbiAgICBhZGREZXB0aFRleHR1cmUodGV4dHVyZSkge1xyXG4gICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4gKi9cclxuICAgICAgICB0aGlzLmRlcHRoVGV4dHVyZSA9IHRleHR1cmUgfHwgbmV3IEJhc2VUZXh0dXJlXzEuQmFzZVRleHR1cmUobmV3IERlcHRoUmVzb3VyY2VfMS5EZXB0aFJlc291cmNlKG51bGwsIHsgd2lkdGg6IHRoaXMud2lkdGgsIGhlaWdodDogdGhpcy5oZWlnaHQgfSksIHsgc2NhbGVNb2RlOiAwLFxyXG4gICAgICAgICAgICByZXNvbHV0aW9uOiAxLFxyXG4gICAgICAgICAgICB3aWR0aDogdGhpcy53aWR0aCxcclxuICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodCxcclxuICAgICAgICAgICAgbWlwbWFwOiBmYWxzZSxcclxuICAgICAgICAgICAgZm9ybWF0OiBXZWJHTFNldHRpbmdzXzEuV2ViR0xTZXR0aW5ncy5GT1JNQVRTLkRFUFRIX0NPTVBPTkVOVCxcclxuICAgICAgICAgICAgdHlwZTogV2ViR0xTZXR0aW5nc18xLldlYkdMU2V0dGluZ3MuVFlQRVMuVU5TSUdORURfU0hPUlQgfSk7IC8vIFVOU0lHTkVEX1NIT1JUO1xyXG4gICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4gKi9cclxuICAgICAgICB0aGlzLmRpcnR5SWQrKztcclxuICAgICAgICB0aGlzLmRpcnR5Rm9ybWF0Kys7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIEVuYWJsZSBkZXB0aCBvbiB0aGUgZnJhbWUgYnVmZmVyXHJcbiAgICAgKi9cclxuICAgIGVuYWJsZURlcHRoKCkge1xyXG4gICAgICAgIHRoaXMuZGVwdGggPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuZGlydHlJZCsrO1xyXG4gICAgICAgIHRoaXMuZGlydHlGb3JtYXQrKztcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogRW5hYmxlIHN0ZW5jaWwgb24gdGhlIGZyYW1lIGJ1ZmZlclxyXG4gICAgICovXHJcbiAgICBlbmFibGVTdGVuY2lsKCkge1xyXG4gICAgICAgIHRoaXMuc3RlbmNpbCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5kaXJ0eUlkKys7XHJcbiAgICAgICAgdGhpcy5kaXJ0eUZvcm1hdCsrO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXNpemUgdGhlIGZyYW1lIGJ1ZmZlclxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCAtIFdpZHRoIG9mIHRoZSBmcmFtZSBidWZmZXIgdG8gcmVzaXplIHRvXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IC0gSGVpZ2h0IG9mIHRoZSBmcmFtZSBidWZmZXIgdG8gcmVzaXplIHRvXHJcbiAgICAgKi9cclxuICAgIHJlc2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICAgICAgd2lkdGggPSBNYXRoLmNlaWwod2lkdGgpO1xyXG4gICAgICAgIGhlaWdodCA9IE1hdGguY2VpbChoZWlnaHQpO1xyXG4gICAgICAgIGlmICh3aWR0aCA9PT0gdGhpcy53aWR0aCAmJiBoZWlnaHQgPT09IHRoaXMuaGVpZ2h0KSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xyXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xyXG4gICAgICAgIHRoaXMuZGlydHlJZCsrO1xyXG4gICAgICAgIHRoaXMuZGlydHlTaXplKys7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNvbG9yVGV4dHVyZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIHRleHR1cmUgPSB0aGlzLmNvbG9yVGV4dHVyZXNbaV07XHJcbiAgICAgICAgICAgIHZhciByZXNvbHV0aW9uID0gdGV4dHVyZS5yZXNvbHV0aW9uO1xyXG4gICAgICAgICAgICAvLyB0YWtlIGludG8gYWNvdW50IHRoZSBmYWN0IHRoZSB0ZXh0dXJlIG1heSBoYXZlIGEgZGlmZmVyZW50IHJlc29sdXRpb24uLlxyXG4gICAgICAgICAgICB0ZXh0dXJlLnNldFNpemUod2lkdGggLyByZXNvbHV0aW9uLCBoZWlnaHQgLyByZXNvbHV0aW9uKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuZGVwdGhUZXh0dXJlKSB7XHJcbiAgICAgICAgICAgIHZhciByZXNvbHV0aW9uJDEgPSB0aGlzLmRlcHRoVGV4dHVyZS5yZXNvbHV0aW9uO1xyXG4gICAgICAgICAgICB0aGlzLmRlcHRoVGV4dHVyZS5zZXRTaXplKHdpZHRoIC8gcmVzb2x1dGlvbiQxLCBoZWlnaHQgLyByZXNvbHV0aW9uJDEpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogZGlzcG9zZXMgV2ViR0wgcmVzb3VyY2VzIHRoYXQgYXJlIGNvbm5lY3RlZCB0byB0aGlzIGdlb21ldHJ5XHJcbiAgICAgKi9cclxuICAgIGRpc3Bvc2UoKSB7XHJcbiAgICAgICAgLy8gdGhpcy5kaXNwb3NlUnVubmVyLnJ1bih0aGlzLCBmYWxzZSk7XHJcbiAgICAgICAgdGhpcy5kaXNwb3NlUnVubmVyLnJ1bih0aGlzLCBmYWxzZSk7XHJcbiAgICB9XHJcbiAgICA7XHJcbn1cclxuZXhwb3J0cy5GcmFtZWJ1ZmZlciA9IEZyYW1lYnVmZmVyO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBTeXN0ZW1fMSA9IHJlcXVpcmUoXCIuL1N5c3RlbVwiKTtcclxuY29uc3QgRnJhbWVidWZmZXJfMSA9IHJlcXVpcmUoXCIuL0ZyYW1lYnVmZmVyXCIpO1xyXG5jb25zdCBSZWN0YW5nbGVfMSA9IHJlcXVpcmUoXCIuL1JlY3RhbmdsZVwiKTtcclxuY29uc3QgRGlzcGxheVNldHRpbmdzXzEgPSByZXF1aXJlKFwiLi9EaXNwbGF5U2V0dGluZ3NcIik7XHJcbmNsYXNzIEZyYW1lYnVmZmVyU3lzdGVtIGV4dGVuZHMgU3lzdGVtXzEuU3lzdGVtIHtcclxuICAgIGNvbnN0cnVjdG9yKHJlbmRlcmVyKSB7XHJcbiAgICAgICAgc3VwZXIocmVuZGVyZXIpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEEgbGlzdCBvZiBtYW5hZ2VkIGZyYW1lYnVmZmVyc1xyXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuRnJhbWVidWZmZXJbXX1cclxuICAgICAgICAgKiBAcmVhZG9ubHlcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLm1hbmFnZWRGcmFtZWJ1ZmZlcnMgPSBbXTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBGcmFtZWJ1ZmZlciB2YWx1ZSB0aGF0IHNob3dzIHRoYXQgd2UgZG9uJ3Qga25vdyB3aGF0IGlzIGJvdW5kXHJcbiAgICAgICAgICogQG1lbWJlciB7RnJhbWVidWZmZXJ9XHJcbiAgICAgICAgICogQHJlYWRvbmx5XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy51bmtub3duRnJhbWVidWZmZXIgPSBuZXcgRnJhbWVidWZmZXJfMS5GcmFtZWJ1ZmZlcigxMCwgMTApO1xyXG4gICAgICAgIHRoaXMudmlld3BvcnQgPSBuZXcgUmVjdGFuZ2xlXzEuUmVjdGFuZ2xlKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdXAgdGhlIHJlbmRlcmVyIGNvbnRleHQgYW5kIG5lY2Vzc2FyeSBidWZmZXJzLlxyXG4gICAgICovXHJcbiAgICBjb250ZXh0Q2hhbmdlKGdsKSB7XHJcbiAgICAgICAgdmFyIGdsID0gdGhpcy5nbCA9IHRoaXMucmVuZGVyZXIuZ2w7XHJcbiAgICAgICAgdGhpcy5DT05URVhUX1VJRCA9IHRoaXMucmVuZGVyZXIuQ09OVEVYVF9VSUQ7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50ID0gdGhpcy51bmtub3duRnJhbWVidWZmZXI7XHJcbiAgICAgICAgdGhpcy52aWV3cG9ydCA9IG5ldyBSZWN0YW5nbGVfMS5SZWN0YW5nbGUoKTtcclxuICAgICAgICB0aGlzLmhhc01SVCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy53cml0ZURlcHRoVGV4dHVyZSA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5kaXNwb3NlQWxsKHRydWUpO1xyXG4gICAgICAgIC8vIHdlYmdsMlxyXG4gICAgICAgIGlmICh0aGlzLnJlbmRlcmVyLmNvbnRleHQud2ViR0xWZXJzaW9uID09PSAxKSB7XHJcbiAgICAgICAgICAgIC8vIHdlYmdsIDEhXHJcbiAgICAgICAgICAgIHZhciBuYXRpdmVEcmF3QnVmZmVyc0V4dGVuc2lvbiA9IHRoaXMucmVuZGVyZXIuY29udGV4dC5leHRlbnNpb25zLmRyYXdCdWZmZXJzO1xyXG4gICAgICAgICAgICB2YXIgbmF0aXZlRGVwdGhUZXh0dXJlRXh0ZW5zaW9uID0gdGhpcy5yZW5kZXJlci5jb250ZXh0LmV4dGVuc2lvbnMuZGVwdGhUZXh0dXJlO1xyXG4gICAgICAgICAgICBpZiAoRGlzcGxheVNldHRpbmdzXzEuRGlzcGxheVNldHRpbmdzLlBSRUZFUl9FTlYgPT09IERpc3BsYXlTZXR0aW5nc18xLkRpc3BsYXlTZXR0aW5ncy5FTlYuV0VCR0xfTEVHQUNZKSB7XHJcbiAgICAgICAgICAgICAgICBuYXRpdmVEcmF3QnVmZmVyc0V4dGVuc2lvbiA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICBuYXRpdmVEZXB0aFRleHR1cmVFeHRlbnNpb24gPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChuYXRpdmVEcmF3QnVmZmVyc0V4dGVuc2lvbikge1xyXG4gICAgICAgICAgICAgICAgZ2wuZHJhd0J1ZmZlcnMgPSBmdW5jdGlvbiAoYWN0aXZlVGV4dHVyZXMpIHsgcmV0dXJuIG5hdGl2ZURyYXdCdWZmZXJzRXh0ZW5zaW9uLmRyYXdCdWZmZXJzV0VCR0woYWN0aXZlVGV4dHVyZXMpOyB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5oYXNNUlQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGdsLmRyYXdCdWZmZXJzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGVtcHR5XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghbmF0aXZlRGVwdGhUZXh0dXJlRXh0ZW5zaW9uKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLndyaXRlRGVwdGhUZXh0dXJlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAgICAgKiBCaW5kIGEgZnJhbWVidWZmZXJcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB7UElYSS5GcmFtZWJ1ZmZlcn0gZnJhbWVidWZmZXJcclxuICAgICAgICAgKiBAcGFyYW0ge1BJWEkuUmVjdGFuZ2xlfSBbZnJhbWVdIGZyYW1lLCBkZWZhdWx0IGlzIGZyYW1lYnVmZmVyIHNpemVcclxuICAgICAgICAgKi9cclxuICAgIGJpbmQoZnJhbWVidWZmZXIgPSBudWxsLCBmcmFtZSA9IG51bGwpIHtcclxuICAgICAgICB2YXIgcmVmID0gdGhpcztcclxuICAgICAgICB2YXIgZ2wgPSByZWYuZ2w7XHJcbiAgICAgICAgaWYgKGZyYW1lYnVmZmVyKSB7XHJcbiAgICAgICAgICAgIC8vIFRPRE8gY2FjaGluZyBsYXllciFcclxuICAgICAgICAgICAgdmFyIGZibyA9IGZyYW1lYnVmZmVyLmdsRnJhbWVidWZmZXJzW3RoaXMuQ09OVEVYVF9VSURdIHx8IHRoaXMuaW5pdEZyYW1lYnVmZmVyKGZyYW1lYnVmZmVyKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudCAhPT0gZnJhbWVidWZmZXIpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudCA9IGZyYW1lYnVmZmVyO1xyXG4gICAgICAgICAgICAgICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBmYm8uZnJhbWVidWZmZXIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSBhbGwgdGV4dHVyZXMgYXJlIHVuYm91bmQuLlxyXG4gICAgICAgICAgICAvLyBub3cgY2hlY2sgZm9yIHVwZGF0ZXMuLi5cclxuICAgICAgICAgICAgaWYgKGZiby5kaXJ0eUlkICE9PSBmcmFtZWJ1ZmZlci5kaXJ0eUlkKSB7XHJcbiAgICAgICAgICAgICAgICBmYm8uZGlydHlJZCA9IGZyYW1lYnVmZmVyLmRpcnR5SWQ7XHJcbiAgICAgICAgICAgICAgICBpZiAoZmJvLmRpcnR5Rm9ybWF0ICE9PSBmcmFtZWJ1ZmZlci5kaXJ0eUZvcm1hdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZiby5kaXJ0eUZvcm1hdCA9IGZyYW1lYnVmZmVyLmRpcnR5Rm9ybWF0O1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlRnJhbWVidWZmZXIoZnJhbWVidWZmZXIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZmJvLmRpcnR5U2l6ZSAhPT0gZnJhbWVidWZmZXIuZGlydHlTaXplKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmJvLmRpcnR5U2l6ZSA9IGZyYW1lYnVmZmVyLmRpcnR5U2l6ZTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc2l6ZUZyYW1lYnVmZmVyKGZyYW1lYnVmZmVyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZyYW1lYnVmZmVyLmNvbG9yVGV4dHVyZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGlmIChmcmFtZWJ1ZmZlci5jb2xvclRleHR1cmVzW2ldLnRleHR1cmVQYXJ0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci50ZXh0dXJlLnVuYmluZChmcmFtZWJ1ZmZlci5jb2xvclRleHR1cmVzW2ldLnRleHR1cmUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci50ZXh0dXJlLnVuYmluZChmcmFtZWJ1ZmZlci5jb2xvclRleHR1cmVzW2ldKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZnJhbWVidWZmZXIuZGVwdGhUZXh0dXJlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnRleHR1cmUudW5iaW5kKGZyYW1lYnVmZmVyLmRlcHRoVGV4dHVyZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGZyYW1lKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldFZpZXdwb3J0KGZyYW1lLngsIGZyYW1lLnksIGZyYW1lLndpZHRoLCBmcmFtZS5oZWlnaHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRWaWV3cG9ydCgwLCAwLCBmcmFtZWJ1ZmZlci53aWR0aCwgZnJhbWVidWZmZXIuaGVpZ2h0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50ID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgbnVsbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGZyYW1lKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldFZpZXdwb3J0KGZyYW1lLngsIGZyYW1lLnksIGZyYW1lLndpZHRoLCBmcmFtZS5oZWlnaHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRWaWV3cG9ydCgwLCAwLCB0aGlzLnJlbmRlcmVyLndpZHRoLCB0aGlzLnJlbmRlcmVyLmhlaWdodCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFNldCB0aGUgV2ViR0xSZW5kZXJpbmdDb250ZXh0J3Mgdmlld3BvcnQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHggLSBYIHBvc2l0aW9uIG9mIHZpZXdwb3J0XHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geSAtIFkgcG9zaXRpb24gb2Ygdmlld3BvcnRcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCAtIFdpZHRoIG9mIHZpZXdwb3J0XHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0IC0gSGVpZ2h0IG9mIHZpZXdwb3J0XHJcbiAgICAgKi9cclxuICAgIHNldFZpZXdwb3J0KHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcclxuICAgICAgICB2YXIgdiA9IHRoaXMudmlld3BvcnQ7XHJcbiAgICAgICAgaWYgKHYud2lkdGggIT09IHdpZHRoIHx8IHYuaGVpZ2h0ICE9PSBoZWlnaHQgfHwgdi54ICE9PSB4IHx8IHYueSAhPT0geSkge1xyXG4gICAgICAgICAgICB2LnggPSB4O1xyXG4gICAgICAgICAgICB2LnkgPSB5O1xyXG4gICAgICAgICAgICB2LndpZHRoID0gd2lkdGg7XHJcbiAgICAgICAgICAgIHYuaGVpZ2h0ID0gaGVpZ2h0O1xyXG4gICAgICAgICAgICB0aGlzLmdsLnZpZXdwb3J0KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBzaXplIG9mIHRoZSBjdXJyZW50IHdpZHRoIGFuZCBoZWlnaHQuIFJldHVybnMgb2JqZWN0IHdpdGggYHdpZHRoYCBhbmQgYGhlaWdodGAgdmFsdWVzLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge29iamVjdH1cclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICovXHJcbiAgICBnZXQgc2l6ZSgpIHtcclxuICAgICAgICBpZiAodGhpcy5jdXJyZW50KSB7XHJcbiAgICAgICAgICAgIC8vIFRPRE8gc3RvcmUgdGVtcFxyXG4gICAgICAgICAgICByZXR1cm4geyB4OiAwLCB5OiAwLCB3aWR0aDogdGhpcy5jdXJyZW50LndpZHRoLCBoZWlnaHQ6IHRoaXMuY3VycmVudC5oZWlnaHQgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHsgeDogMCwgeTogMCwgd2lkdGg6IHRoaXMucmVuZGVyZXIud2lkdGgsIGhlaWdodDogdGhpcy5yZW5kZXJlci5oZWlnaHQgfTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQ2xlYXIgdGhlIGNvbG9yIG9mIHRoZSBjb250ZXh0XHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHIgLSBSZWQgdmFsdWUgZnJvbSAwIHRvIDFcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBnIC0gR3JlZW4gdmFsdWUgZnJvbSAwIHRvIDFcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBiIC0gQmx1ZSB2YWx1ZSBmcm9tIDAgdG8gMVxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGEgLSBBbHBoYSB2YWx1ZSBmcm9tIDAgdG8gMVxyXG4gICAgICovXHJcbiAgICBjbGVhcihyID0gMCwgZyA9IDAsIGIgPSAwLCBhID0gMSkge1xyXG4gICAgICAgIHZhciByZWYgPSB0aGlzO1xyXG4gICAgICAgIHZhciBnbCA9IHJlZi5nbDtcclxuICAgICAgICAvLyBUT0RPIGNsZWFyIGNvbG9yIGNhbiBiZSBzZXQgb25seSBvbmUgcmlnaHQ/XHJcbiAgICAgICAgZ2wuY2xlYXJDb2xvcihyLCBnLCBiLCBhKTtcclxuICAgICAgICBnbC5jbGVhcihnbC5DT0xPUl9CVUZGRVJfQklUIHwgZ2wuREVQVEhfQlVGRkVSX0JJVCk7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICogSW5pdGlhbGl6ZSBmcmFtZWJ1ZmZlclxyXG4gKlxyXG4gKiBAcHJvdGVjdGVkXHJcbiAqIEBwYXJhbSB7UElYSS5GcmFtZWJ1ZmZlcn0gZnJhbWVidWZmZXJcclxuICovXHJcbiAgICBpbml0RnJhbWVidWZmZXIoZnJhbWVidWZmZXIpIHtcclxuICAgICAgICB2YXIgcmVmID0gdGhpcztcclxuICAgICAgICB2YXIgZ2wgPSByZWYuZ2w7XHJcbiAgICAgICAgLy8gVE9ETyAtIG1ha2UgdGhpcyBhIGNsYXNzP1xyXG4gICAgICAgIHZhciBmYm8gPSB7XHJcbiAgICAgICAgICAgIGZyYW1lYnVmZmVyOiBnbC5jcmVhdGVGcmFtZWJ1ZmZlcigpLFxyXG4gICAgICAgICAgICBzdGVuY2lsOiBudWxsLFxyXG4gICAgICAgICAgICBkaXJ0eUlkOiAwLFxyXG4gICAgICAgICAgICBkaXJ0eUZvcm1hdDogMCxcclxuICAgICAgICAgICAgZGlydHlTaXplOiAwLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgZnJhbWVidWZmZXIuZ2xGcmFtZWJ1ZmZlcnNbdGhpcy5DT05URVhUX1VJRF0gPSBmYm87XHJcbiAgICAgICAgdGhpcy5tYW5hZ2VkRnJhbWVidWZmZXJzLnB1c2goZnJhbWVidWZmZXIpO1xyXG4gICAgICAgIGZyYW1lYnVmZmVyLmRpc3Bvc2VSdW5uZXIuYWRkKHRoaXMpO1xyXG4gICAgICAgIHJldHVybiBmYm87XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFJlc2l6ZSB0aGUgZnJhbWVidWZmZXJcclxuICAgICAqXHJcbiAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgKiBAcGFyYW0ge1BJWEkuRnJhbWVidWZmZXJ9IGZyYW1lYnVmZmVyXHJcbiAgICAgKi9cclxuICAgIHJlc2l6ZUZyYW1lYnVmZmVyKGZyYW1lYnVmZmVyKSB7XHJcbiAgICAgICAgdmFyIHJlZiA9IHRoaXM7XHJcbiAgICAgICAgdmFyIGdsID0gcmVmLmdsO1xyXG4gICAgICAgIHZhciBmYm8gPSBmcmFtZWJ1ZmZlci5nbEZyYW1lYnVmZmVyc1t0aGlzLkNPTlRFWFRfVUlEXTtcclxuICAgICAgICBpZiAoZmJvLnN0ZW5jaWwpIHtcclxuICAgICAgICAgICAgZ2wuYmluZFJlbmRlcmJ1ZmZlcihnbC5SRU5ERVJCVUZGRVIsIGZiby5zdGVuY2lsKTtcclxuICAgICAgICAgICAgZ2wucmVuZGVyYnVmZmVyU3RvcmFnZShnbC5SRU5ERVJCVUZGRVIsIGdsLkRFUFRIX1NURU5DSUwsIGZyYW1lYnVmZmVyLndpZHRoLCBmcmFtZWJ1ZmZlci5oZWlnaHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgY29sb3JUZXh0dXJlcyA9IGZyYW1lYnVmZmVyLmNvbG9yVGV4dHVyZXM7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb2xvclRleHR1cmVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIudGV4dHVyZS5iaW5kKGNvbG9yVGV4dHVyZXNbaV0sIDApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZnJhbWVidWZmZXIuZGVwdGhUZXh0dXJlKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIudGV4dHVyZS5iaW5kKGZyYW1lYnVmZmVyLmRlcHRoVGV4dHVyZSwgMCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGUgdGhlIGZyYW1lYnVmZmVyXHJcbiAgICAgKlxyXG4gICAgICogQHByb3RlY3RlZFxyXG4gICAgICogQHBhcmFtIHtQSVhJLkZyYW1lYnVmZmVyfSBmcmFtZWJ1ZmZlclxyXG4gICAgICovXHJcbiAgICB1cGRhdGVGcmFtZWJ1ZmZlcihmcmFtZWJ1ZmZlcikge1xyXG4gICAgICAgIHZhciByZWYgPSB0aGlzO1xyXG4gICAgICAgIHZhciBnbCA9IHJlZi5nbDtcclxuICAgICAgICB2YXIgZmJvID0gZnJhbWVidWZmZXIuZ2xGcmFtZWJ1ZmZlcnNbdGhpcy5DT05URVhUX1VJRF07XHJcbiAgICAgICAgLy8gYmluZCB0aGUgY29sb3IgdGV4dHVyZVxyXG4gICAgICAgIHZhciBjb2xvclRleHR1cmVzID0gZnJhbWVidWZmZXIuY29sb3JUZXh0dXJlcztcclxuICAgICAgICB2YXIgY291bnQgPSBjb2xvclRleHR1cmVzLmxlbmd0aDtcclxuICAgICAgICBpZiAoIWdsLmRyYXdCdWZmZXJzKSB7XHJcbiAgICAgICAgICAgIGNvdW50ID0gTWF0aC5taW4oY291bnQsIDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgYWN0aXZlVGV4dHVyZXMgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIHRleHR1cmUgPSBmcmFtZWJ1ZmZlci5jb2xvclRleHR1cmVzW2ldO1xyXG4gICAgICAgICAgICBpZiAodGV4dHVyZS50ZXh0dXJlUGFydCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci50ZXh0dXJlLmJpbmQodGV4dHVyZS50ZXh0dXJlLCAwKTtcclxuICAgICAgICAgICAgICAgIGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKGdsLkZSQU1FQlVGRkVSLCBnbC5DT0xPUl9BVFRBQ0hNRU5UMCArIGksIGdsLlRFWFRVUkVfQ1VCRV9NQVBfTkVHQVRJVkVfWCArIHRleHR1cmUuc2lkZSwgdGV4dHVyZS50ZXh0dXJlLl9nbFRleHR1cmVzW3RoaXMuQ09OVEVYVF9VSURdLnRleHR1cmUsIDApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci50ZXh0dXJlLmJpbmQodGV4dHVyZSwgMCk7XHJcbiAgICAgICAgICAgICAgICBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChnbC5GUkFNRUJVRkZFUiwgZ2wuQ09MT1JfQVRUQUNITUVOVDAgKyBpLCBnbC5URVhUVVJFXzJELCB0ZXh0dXJlLl9nbFRleHR1cmVzW3RoaXMuQ09OVEVYVF9VSURdLnRleHR1cmUsIDApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGFjdGl2ZVRleHR1cmVzLnB1c2goZ2wuQ09MT1JfQVRUQUNITUVOVDAgKyBpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGFjdGl2ZVRleHR1cmVzLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgZ2wuZHJhd0J1ZmZlcnMoYWN0aXZlVGV4dHVyZXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZnJhbWVidWZmZXIuZGVwdGhUZXh0dXJlKSB7XHJcbiAgICAgICAgICAgIHZhciB3cml0ZURlcHRoVGV4dHVyZSA9IHRoaXMud3JpdGVEZXB0aFRleHR1cmU7XHJcbiAgICAgICAgICAgIGlmICh3cml0ZURlcHRoVGV4dHVyZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGRlcHRoVGV4dHVyZSA9IGZyYW1lYnVmZmVyLmRlcHRoVGV4dHVyZTtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIudGV4dHVyZS5iaW5kKGRlcHRoVGV4dHVyZSwgMCk7XHJcbiAgICAgICAgICAgICAgICBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChnbC5GUkFNRUJVRkZFUiwgZ2wuREVQVEhfQVRUQUNITUVOVCwgZ2wuVEVYVFVSRV8yRCwgZGVwdGhUZXh0dXJlLl9nbFRleHR1cmVzW3RoaXMuQ09OVEVYVF9VSURdLnRleHR1cmUsIDApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghZmJvLnN0ZW5jaWwgJiYgKGZyYW1lYnVmZmVyLnN0ZW5jaWwgfHwgZnJhbWVidWZmZXIuZGVwdGgpKSB7XHJcbiAgICAgICAgICAgIGZiby5zdGVuY2lsID0gZ2wuY3JlYXRlUmVuZGVyYnVmZmVyKCk7XHJcbiAgICAgICAgICAgIGdsLmJpbmRSZW5kZXJidWZmZXIoZ2wuUkVOREVSQlVGRkVSLCBmYm8uc3RlbmNpbCk7XHJcbiAgICAgICAgICAgIC8vIFRPRE8uLiB0aGlzIGlzIGRlcHRoIEFORCBzdGVuY2lsP1xyXG4gICAgICAgICAgICBpZiAoIWZyYW1lYnVmZmVyLmRlcHRoVGV4dHVyZSkgeyAvLyB5b3UgY2FuJ3QgaGF2ZSBib3RoLCBzbyBvbmUgc2hvdWxkIHRha2UgcHJpb3JpdHkgaWYgZW5hYmxlZFxyXG4gICAgICAgICAgICAgICAgZ2wuZnJhbWVidWZmZXJSZW5kZXJidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIGdsLkRFUFRIX1NURU5DSUxfQVRUQUNITUVOVCwgZ2wuUkVOREVSQlVGRkVSLCBmYm8uc3RlbmNpbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZ2wucmVuZGVyYnVmZmVyU3RvcmFnZShnbC5SRU5ERVJCVUZGRVIsIGdsLkRFUFRIX1NURU5DSUwsIGZyYW1lYnVmZmVyLndpZHRoLCBmcmFtZWJ1ZmZlci5oZWlnaHQpO1xyXG4gICAgICAgICAgICAvLyBmYm8uZW5hYmxlU3RlbmNpbCgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogRGlzcG9zZXMgZnJhbWVidWZmZXJcclxuICAgICAqIEBwYXJhbSB7UElYSS5GcmFtZWJ1ZmZlcn0gZnJhbWVidWZmZXIgZnJhbWVidWZmZXIgdGhhdCBoYXMgdG8gYmUgZGlzcG9zZWQgb2ZcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2NvbnRleHRMb3N0PWZhbHNlXSBJZiBjb250ZXh0IHdhcyBsb3N0LCB3ZSBzdXBwcmVzcyBhbGwgZGVsZXRlIGZ1bmN0aW9uIGNhbGxzXHJcbiAgICAgKi9cclxuICAgIGRpc3Bvc2VGcmFtZWJ1ZmZlcihmcmFtZWJ1ZmZlciwgY29udGV4dExvc3QpIHtcclxuICAgICAgICB2YXIgZmJvID0gZnJhbWVidWZmZXIuZ2xGcmFtZWJ1ZmZlcnNbdGhpcy5DT05URVhUX1VJRF07XHJcbiAgICAgICAgdmFyIGdsID0gdGhpcy5nbDtcclxuICAgICAgICBpZiAoIWZibykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRlbGV0ZSBmcmFtZWJ1ZmZlci5nbEZyYW1lYnVmZmVyc1t0aGlzLkNPTlRFWFRfVUlEXTtcclxuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLm1hbmFnZWRGcmFtZWJ1ZmZlcnMuaW5kZXhPZihmcmFtZWJ1ZmZlcik7XHJcbiAgICAgICAgaWYgKGluZGV4ID49IDApIHtcclxuICAgICAgICAgICAgdGhpcy5tYW5hZ2VkRnJhbWVidWZmZXJzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZyYW1lYnVmZmVyLmRpc3Bvc2VSdW5uZXIucmVtb3ZlKHRoaXMpO1xyXG4gICAgICAgIGlmICghY29udGV4dExvc3QpIHtcclxuICAgICAgICAgICAgZ2wuZGVsZXRlRnJhbWVidWZmZXIoZmJvLmZyYW1lYnVmZmVyKTtcclxuICAgICAgICAgICAgaWYgKGZiby5zdGVuY2lsKSB7XHJcbiAgICAgICAgICAgICAgICBnbC5kZWxldGVSZW5kZXJidWZmZXIoZmJvLnN0ZW5jaWwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBEaXNwb3NlcyBhbGwgZnJhbWVidWZmZXJzLCBidXQgbm90IHRleHR1cmVzIGJvdW5kIHRvIHRoZW1cclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2NvbnRleHRMb3N0PWZhbHNlXSBJZiBjb250ZXh0IHdhcyBsb3N0LCB3ZSBzdXBwcmVzcyBhbGwgZGVsZXRlIGZ1bmN0aW9uIGNhbGxzXHJcbiAgICAgKi9cclxuICAgIGRpc3Bvc2VBbGwoY29udGV4dExvc3QpIHtcclxuICAgICAgICB2YXIgbGlzdCA9IHRoaXMubWFuYWdlZEZyYW1lYnVmZmVycztcclxuICAgICAgICB0aGlzLm1hbmFnZWRGcmFtZWJ1ZmZlcnMgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QuY291bnQ7IGkrKykge1xyXG4gICAgICAgICAgICB0aGlzLmRpc3Bvc2VGcmFtZWJ1ZmZlcihsaXN0W2ldLCBjb250ZXh0TG9zdCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiByZXNldHMgZnJhbWVidWZmZXIgc3RvcmVkIHN0YXRlLCBiaW5kcyBzY3JlZW4gZnJhbWVidWZmZXJcclxuICAgICAqXHJcbiAgICAgKiBzaG91bGQgYmUgY2FsbGVkIGJlZm9yZSByZW5kZXJUZXh0dXJlIHJlc2V0KClcclxuICAgICAqL1xyXG4gICAgcmVzZXQoKSB7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50ID0gdGhpcy51bmtub3duRnJhbWVidWZmZXI7XHJcbiAgICAgICAgdGhpcy52aWV3cG9ydCA9IG5ldyBSZWN0YW5nbGVfMS5SZWN0YW5nbGUoKTtcclxuICAgIH1cclxuICAgIDtcclxufVxyXG5leHBvcnRzLkZyYW1lYnVmZmVyU3lzdGVtID0gRnJhbWVidWZmZXJTeXN0ZW07XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNsYXNzIEdMQnVmZmVyIHtcclxuICAgIGNvbnN0cnVjdG9yKGJ1ZmZlcikge1xyXG4gICAgICAgIHRoaXMuYnVmZmVyID0gYnVmZmVyO1xyXG4gICAgICAgIHRoaXMudXBkYXRlSUQgPSAtMTtcclxuICAgICAgICB0aGlzLmJ5dGVMZW5ndGggPSAtMTtcclxuICAgICAgICB0aGlzLnJlZkNvdW50ID0gMDtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLkdMQnVmZmVyID0gR0xCdWZmZXI7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNsYXNzIEdMUHJvZ3JhbSB7XHJcbiAgICBjb25zdHJ1Y3Rvcihwcm9ncmFtLCB1bmlmb3JtRGF0YSkge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogVGhlIHNoYWRlciBwcm9ncmFtXHJcbiAgICAgICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgICAgICogQG1lbWJlciB7V2ViR0xQcm9ncmFtfVxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5wcm9ncmFtID0gcHJvZ3JhbTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBob2xkcyB0aGUgdW5pZm9ybSBkYXRhIHdoaWNoIGNvbnRhaW5zIHVuaWZvcm0gbG9jYXRpb25zXHJcbiAgICAgICAgICogYW5kIGN1cnJlbnQgdW5pZm9ybSB2YWx1ZXMgdXNlZCBmb3IgY2FjaGluZyBhbmQgcHJldmVudGluZyB1bm5lZWRlZCBHUFUgY29tbWFuZHNcclxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy51bmlmb3JtRGF0YSA9IHVuaWZvcm1EYXRhO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIHVuaWZvcm1Hcm91cHMgaG9sZHMgdGhlIHZhcmlvdXMgdXBsb2FkIGZ1bmN0aW9ucyBmb3IgdGhlIHNoYWRlci4gRWFjaCB1bmlmb3JtIGdyb3VwXHJcbiAgICAgICAgICogYW5kIHByb2dyYW0gaGF2ZSBhIHVuaXF1ZSB1cGxvYWQgZnVuY3Rpb24gZ2VuZXJhdGVkLlxyXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnVuaWZvcm1Hcm91cHMgPSB7fTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRGVzdHJveXMgdGhpcyBwcm9ncmFtXHJcbiAgICAgKi9cclxuICAgIGRlc3Ryb3koKSB7XHJcbiAgICAgICAgdGhpcy51bmlmb3JtRGF0YSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy51bmlmb3JtR3JvdXBzID0gbnVsbDtcclxuICAgICAgICB0aGlzLnByb2dyYW0gPSBudWxsO1xyXG4gICAgfVxyXG4gICAgO1xyXG59XHJcbmV4cG9ydHMuR0xQcm9ncmFtID0gR0xQcm9ncmFtO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jbGFzcyBHTFRleHR1cmUge1xyXG4gICAgY29uc3RydWN0b3IodGV4dHVyZSkge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogVGhlIFdlYkdMIHRleHR1cmVcclxuICAgICAgICAgICAgICAgICAqIEBtZW1iZXIge1dlYkdMVGV4dHVyZX1cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMudGV4dHVyZSA9IHRleHR1cmU7XHJcbiAgICAgICAgdGhpcy53aWR0aCA9IC0xO1xyXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gLTE7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGV4dHVyZSBjb250ZW50cyBkaXJ0eSBmbGFnXHJcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuZGlydHlJZCA9IC0xO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRleHR1cmUgc3R5bGUgZGlydHkgZmxhZ1xyXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmRpcnR5U3R5bGVJZCA9IC0xO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFdoZXRoZXIgbWlwIGxldmVscyBoYXMgdG8gYmUgZ2VuZXJhdGVkXHJcbiAgICAgICAgICogQG1lbWJlciB7Ym9vbGVhbn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLm1pcG1hcCA9IGZhbHNlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFdyYXBNb2RlIGNvcGllZCBmcm9tIGJhc2VUZXh0dXJlXHJcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMud3JhcE1vZGUgPSAzMzA3MTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLkdMVGV4dHVyZSA9IEdMVGV4dHVyZTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgQXR0cmlidXRlXzEgPSByZXF1aXJlKFwiLi9BdHRyaWJ1dGVcIik7XHJcbmNvbnN0IEJ1ZmZlcl8xID0gcmVxdWlyZShcIi4vQnVmZmVyXCIpO1xyXG5jb25zdCBSdW5uZXJfMSA9IHJlcXVpcmUoXCIuL1J1bm5lclwiKTtcclxuY2xhc3MgR2VvbWV0cnkge1xyXG4gICAgY29uc3RydWN0b3IoYnVmZmVycyA9IFtdLCBhdHRyaWJ1dGVzID0ge30pIHtcclxuICAgICAgICB0aGlzLmJ1ZmZlcnMgPSBidWZmZXJzO1xyXG4gICAgICAgIHRoaXMuaW5kZXhCdWZmZXIgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXM7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQSBtYXAgb2YgcmVuZGVyZXIgSURzIHRvIHdlYmdsIFZBT3NcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAgICAgKiBAdHlwZSB7b2JqZWN0fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuZ2xWZXJ0ZXhBcnJheU9iamVjdHMgPSB7fTtcclxuICAgICAgICB0aGlzLmlkID0gR2VvbWV0cnkuVUlEJDErKztcclxuICAgICAgICB0aGlzLmluc3RhbmNlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuaW5zdGFuY2VDb3VudCA9IDE7XHJcbiAgICAgICAgdGhpcy5fc2l6ZSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5kaXNwb3NlUnVubmVyID0gbmV3IFJ1bm5lcl8xLlJ1bm5lcignZGlzcG9zZUdlb21ldHJ5JywgMik7XHJcbiAgICAgICAgLy8gdGhpcy5kaXNwb3NlUnVubmVyID0gbmV3IFJ1bm5lcignZGlzcG9zZUdlb21ldHJ5JywgMik7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ291bnQgb2YgZXhpc3RpbmcgKG5vdCBkZXN0cm95ZWQpIG1lc2hlcyB0aGF0IHJlZmVyZW5jZSB0aGlzIGdlb21ldHJ5XHJcbiAgICAgICAgICogQG1lbWJlciB7Ym9vbGVhbn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnJlZkNvdW50ID0gMDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgKlxyXG4gICAgKiBBZGRzIGFuIGF0dHJpYnV0ZSB0byB0aGUgZ2VvbWV0cnlcclxuICAgICpcclxuICAgICogQHBhcmFtIHtTdHJpbmd9IGlkIC0gdGhlIG5hbWUgb2YgdGhlIGF0dHJpYnV0ZSAobWF0Y2hpbmcgdXAgdG8gYSBzaGFkZXIpXHJcbiAgICAqIEBwYXJhbSB7UElYSS5CdWZmZXJ9IFtidWZmZXJdIHRoZSBidWZmZXIgdGhhdCBob2xkcyB0aGUgZGF0YSBvZiB0aGUgYXR0cmlidXRlIC4gWW91IGNhbiBhbHNvIHByb3ZpZGUgYW4gQXJyYXkgYW5kIGEgYnVmZmVyIHdpbGwgYmUgY3JlYXRlZCBmcm9tIGl0LlxyXG4gICAgKiBAcGFyYW0ge051bWJlcn0gW3NpemU9MF0gdGhlIHNpemUgb2YgdGhlIGF0dHJpYnV0ZS4gSWYgeW91IGhhdmUgMiBmbG9hdHMgcGVyIHZlcnRleCAoZWcgcG9zaXRpb24geCBhbmQgeSkgdGhpcyB3b3VsZCBiZSAyXHJcbiAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW25vcm1hbGl6ZWQ9ZmFsc2VdIHNob3VsZCB0aGUgZGF0YSBiZSBub3JtYWxpemVkLlxyXG4gICAgKiBAcGFyYW0ge051bWJlcn0gW3R5cGU9UElYSS5UWVBFUy5GTE9BVF0gd2hhdCB0eXBlIG9mIG51bWJlciBpcyB0aGUgYXR0cmlidXRlLiBDaGVjayB7UElYSS5UWVBFU30gdG8gc2VlIHRoZSBvbmVzIGF2YWlsYWJsZVxyXG4gICAgKiBAcGFyYW0ge051bWJlcn0gW3N0cmlkZT0wXSBIb3cgZmFyIGFwYXJ0IChpbiBmbG9hdHMpIHRoZSBzdGFydCBvZiBlYWNoIHZhbHVlIGlzLiAodXNlZCBmb3IgaW50ZXJsZWF2aW5nIGRhdGEpXHJcbiAgICAqIEBwYXJhbSB7TnVtYmVyfSBbc3RhcnQ9MF0gSG93IGZhciBpbnRvIHRoZSBhcnJheSB0byBzdGFydCByZWFkaW5nIHZhbHVlcyAodXNlZCBmb3IgaW50ZXJsZWF2aW5nIGRhdGEpXHJcbiAgICAqXHJcbiAgICAqIEByZXR1cm4ge1BJWEkuR2VvbWV0cnl9IHJldHVybnMgc2VsZiwgdXNlZnVsIGZvciBjaGFpbmluZy5cclxuICAgICovXHJcbiAgICBhZGRBdHRyaWJ1dGUoaWQsIGJ1ZmZlciwgc2l6ZSA9IG51bGwsIG5vcm1hbGl6ZWQgPSBmYWxzZSwgdHlwZSA9IG51bGwsIHN0cmlkZSA9IHVuZGVmaW5lZCwgc3RhcnQgPSB1bmRlZmluZWQsIGluc3RhbmNlID0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgaWYgKCFidWZmZXIpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgbXVzdCBwYXNzIGEgYnVmZmVyIHdoZW4gY3JlYXRpbmcgYW4gYXR0cmlidXRlJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGNoZWNrIGlmIHRoaXMgaXMgYSBidWZmZXIhXHJcbiAgICAgICAgaWYgKCFidWZmZXIuZGF0YSkge1xyXG4gICAgICAgICAgICAvLyBpdHMgYW4gYXJyYXkhXHJcbiAgICAgICAgICAgIGlmIChidWZmZXIgaW5zdGFuY2VvZiBBcnJheSkge1xyXG4gICAgICAgICAgICAgICAgYnVmZmVyID0gbmV3IEZsb2F0MzJBcnJheShidWZmZXIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJ1ZmZlciA9IG5ldyBCdWZmZXJfMS5CdWZmZXIoYnVmZmVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGlkcyA9IGlkLnNwbGl0KCd8Jyk7XHJcbiAgICAgICAgaWYgKGlkcy5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaWRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFkZEF0dHJpYnV0ZShpZHNbaV0sIGJ1ZmZlciwgc2l6ZSwgbm9ybWFsaXplZCwgdHlwZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBidWZmZXJJbmRleCA9IHRoaXMuYnVmZmVycy5pbmRleE9mKGJ1ZmZlcik7XHJcbiAgICAgICAgaWYgKGJ1ZmZlckluZGV4ID09PSAtMSkge1xyXG4gICAgICAgICAgICB0aGlzLmJ1ZmZlcnMucHVzaChidWZmZXIpO1xyXG4gICAgICAgICAgICBidWZmZXJJbmRleCA9IHRoaXMuYnVmZmVycy5sZW5ndGggLSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmF0dHJpYnV0ZXNbaWRdID0gbmV3IEF0dHJpYnV0ZV8xLkF0dHJpYnV0ZShidWZmZXJJbmRleCwgc2l6ZSwgbm9ybWFsaXplZCwgdHlwZSwgc3RyaWRlLCBzdGFydCwgaW5zdGFuY2UpO1xyXG4gICAgICAgIC8vIGFzc3VtaW5nIHRoYXQgaWYgdGhlcmUgaXMgaW5zdGFuY2VkIGRhdGEgdGhlbiB0aGlzIHdpbGwgYmUgZHJhd24gd2l0aCBpbnN0YW5jaW5nIVxyXG4gICAgICAgIHRoaXMuaW5zdGFuY2VkID0gdGhpcy5pbnN0YW5jZWQgfHwgaW5zdGFuY2U7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIHJldHVybnMgdGhlIHJlcXVlc3RlZCBhdHRyaWJ1dGVcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gaWQgIHRoZSBuYW1lIG9mIHRoZSBhdHRyaWJ1dGUgcmVxdWlyZWRcclxuICAgICAqIEByZXR1cm4ge1BJWEkuQXR0cmlidXRlfSB0aGUgYXR0cmlidXRlIHJlcXVlc3RlZC5cclxuICAgICAqL1xyXG4gICAgZ2V0QXR0cmlidXRlKGlkKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyc1t0aGlzLmF0dHJpYnV0ZXNbaWRdLmJ1ZmZlcl07XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICpcclxuICAgICogQWRkcyBhbiBpbmRleCBidWZmZXIgdG8gdGhlIGdlb21ldHJ5XHJcbiAgICAqIFRoZSBpbmRleCBidWZmZXIgY29udGFpbnMgaW50ZWdlcnMsIHRocmVlIGZvciBlYWNoIHRyaWFuZ2xlIGluIHRoZSBnZW9tZXRyeSwgd2hpY2ggcmVmZXJlbmNlIHRoZSB2YXJpb3VzIGF0dHJpYnV0ZSBidWZmZXJzIChwb3NpdGlvbiwgY29sb3VyLCBVViBjb29yZGluYXRlcywgb3RoZXIgVVYgY29vcmRpbmF0ZXMsIG5vcm1hbCwg4oCmKS4gVGhlcmUgaXMgb25seSBPTkUgaW5kZXggYnVmZmVyLlxyXG4gICAgKlxyXG4gICAgKiBAcGFyYW0ge1BJWEkuQnVmZmVyfSBbYnVmZmVyXSB0aGUgYnVmZmVyIHRoYXQgaG9sZHMgdGhlIGRhdGEgb2YgdGhlIGluZGV4IGJ1ZmZlci4gWW91IGNhbiBhbHNvIHByb3ZpZGUgYW4gQXJyYXkgYW5kIGEgYnVmZmVyIHdpbGwgYmUgY3JlYXRlZCBmcm9tIGl0LlxyXG4gICAgKiBAcmV0dXJuIHtQSVhJLkdlb21ldHJ5fSByZXR1cm5zIHNlbGYsIHVzZWZ1bCBmb3IgY2hhaW5pbmcuXHJcbiAgICAqL1xyXG4gICAgYWRkSW5kZXgoYnVmZmVyKSB7XHJcbiAgICAgICAgaWYgKCFidWZmZXIuZGF0YSkge1xyXG4gICAgICAgICAgICAvLyBpdHMgYW4gYXJyYXkhXHJcbiAgICAgICAgICAgIGlmIChidWZmZXIgaW5zdGFuY2VvZiBBcnJheSkge1xyXG4gICAgICAgICAgICAgICAgYnVmZmVyID0gbmV3IFVpbnQxNkFycmF5KGJ1ZmZlcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYnVmZmVyID0gbmV3IEJ1ZmZlcl8xLkJ1ZmZlcihidWZmZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBidWZmZXIuaW5kZXggPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuaW5kZXhCdWZmZXIgPSBidWZmZXI7XHJcbiAgICAgICAgaWYgKHRoaXMuYnVmZmVycy5pbmRleE9mKGJ1ZmZlcikgPT09IC0xKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYnVmZmVycy5wdXNoKGJ1ZmZlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiByZXR1cm5zIHRoZSBpbmRleCBidWZmZXJcclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIHtQSVhJLkJ1ZmZlcn0gdGhlIGluZGV4IGJ1ZmZlci5cclxuICAgICAqL1xyXG4gICAgZ2V0SW5kZXgoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXhCdWZmZXI7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIHRoaXMgZnVuY3Rpb24gbW9kaWZpZXMgdGhlIHN0cnVjdHVyZSBzbyB0aGF0IGFsbCBjdXJyZW50IGF0dHJpYnV0ZXMgYmVjb21lIGludGVybGVhdmVkIGludG8gYSBzaW5nbGUgYnVmZmVyXHJcbiAgICAgKiBUaGlzIGNhbiBiZSB1c2VmdWwgaWYgeW91ciBtb2RlbCByZW1haW5zIHN0YXRpYyBhcyBpdCBvZmZlcnMgYSBsaXR0bGUgcGVyZm9ybWFuY2UgYm9vc3RcclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIHtQSVhJLkdlb21ldHJ5fSByZXR1cm5zIHNlbGYsIHVzZWZ1bCBmb3IgY2hhaW5pbmcuXHJcbiAgICAgKi9cclxuICAgIGludGVybGVhdmUoKSB7XHJcbiAgICAgICAgLy8gYSBzaW1wbGUgY2hlY2sgdG8gc2VlIGlmIGJ1ZmZlcnMgYXJlIGFscmVhZHkgaW50ZXJsZWF2ZWQuLlxyXG4gICAgICAgIGlmICh0aGlzLmJ1ZmZlcnMubGVuZ3RoID09PSAxIHx8ICh0aGlzLmJ1ZmZlcnMubGVuZ3RoID09PSAyICYmIHRoaXMuaW5kZXhCdWZmZXIpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBhc3N1bWUgYWxyZWFkeSB0aGF0IG5vIGJ1ZmZlcnMgYXJlIGludGVybGVhdmVkXHJcbiAgICAgICAgdmFyIGFycmF5cyA9IFtdO1xyXG4gICAgICAgIHZhciBzaXplcyA9IFtdO1xyXG4gICAgICAgIHZhciBpbnRlcmxlYXZlZEJ1ZmZlciA9IG5ldyBCdWZmZXJfMS5CdWZmZXIoKTtcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICBmb3IgKGkgaW4gdGhpcy5hdHRyaWJ1dGVzKSB7XHJcbiAgICAgICAgICAgIHZhciBhdHRyaWJ1dGUgPSB0aGlzLmF0dHJpYnV0ZXNbaV07XHJcbiAgICAgICAgICAgIHZhciBidWZmZXIgPSB0aGlzLmJ1ZmZlcnNbYXR0cmlidXRlLmJ1ZmZlcl07XHJcbiAgICAgICAgICAgIGFycmF5cy5wdXNoKGJ1ZmZlci5kYXRhKTtcclxuICAgICAgICAgICAgc2l6ZXMucHVzaCgoYXR0cmlidXRlLnNpemUgKiBHZW9tZXRyeS5ieXRlU2l6ZU1hcFthdHRyaWJ1dGUudHlwZV0pIC8gNCk7XHJcbiAgICAgICAgICAgIGF0dHJpYnV0ZS5idWZmZXIgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpbnRlcmxlYXZlZEJ1ZmZlci5kYXRhID0gR2VvbWV0cnkuaW50ZXJsZWF2ZVR5cGVkQXJyYXlzKGFycmF5cywgc2l6ZXMpO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmJ1ZmZlcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuYnVmZmVyc1tpXSAhPT0gdGhpcy5pbmRleEJ1ZmZlcikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5idWZmZXJzW2ldLmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmJ1ZmZlcnMgPSBbaW50ZXJsZWF2ZWRCdWZmZXJdO1xyXG4gICAgICAgIGlmICh0aGlzLmluZGV4QnVmZmVyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYnVmZmVycy5wdXNoKHRoaXMuaW5kZXhCdWZmZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIDtcclxuICAgIGdldFNpemUoKSB7XHJcbiAgICAgICAgZm9yICh2YXIgaSBpbiB0aGlzLmF0dHJpYnV0ZXMpIHtcclxuICAgICAgICAgICAgdmFyIGF0dHJpYnV0ZSA9IHRoaXMuYXR0cmlidXRlc1tpXTtcclxuICAgICAgICAgICAgdmFyIGJ1ZmZlciA9IHRoaXMuYnVmZmVyc1thdHRyaWJ1dGUuYnVmZmVyXTtcclxuICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlci5kYXRhLmxlbmd0aCAvICgoYXR0cmlidXRlLnN0cmlkZSAvIDQpIHx8IGF0dHJpYnV0ZS5zaXplKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIGRpc3Bvc2VzIFdlYkdMIHJlc291cmNlcyB0aGF0IGFyZSBjb25uZWN0ZWQgdG8gdGhpcyBnZW9tZXRyeVxyXG4gICAgICovXHJcbiAgICBkaXNwb3NlKCkge1xyXG4gICAgICAgIC8vIHRoaXMuZGlzcG9zZVJ1bm5lci5ydW4odGhpcywgZmFsc2UpO1xyXG4gICAgICAgIHRoaXMuZGlzcG9zZVJ1bm5lci5ydW4odGhpcywgZmFsc2UpO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBEZXN0cm95cyB0aGUgZ2VvbWV0cnkuXHJcbiAgICAgKi9cclxuICAgIGRlc3Ryb3kob3B0aW9ucyA9IG51bGwpIHtcclxuICAgICAgICB0aGlzLmRpc3Bvc2UoKTtcclxuICAgICAgICB0aGlzLmJ1ZmZlcnMgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuaW5kZXhCdWZmZXIuZGVzdHJveSgpO1xyXG4gICAgICAgIHRoaXMuYXR0cmlidXRlcyA9IG51bGw7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIHJldHVybnMgYSBjbG9uZSBvZiB0aGUgZ2VvbWV0cnlcclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7UElYSS5HZW9tZXRyeX0gYSBuZXcgY2xvbmUgb2YgdGhpcyBnZW9tZXRyeVxyXG4gICAgICovXHJcbiAgICBjbG9uZSgpIHtcclxuICAgICAgICB2YXIgZ2VvbWV0cnkgPSBuZXcgR2VvbWV0cnkoKTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYnVmZmVycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBnZW9tZXRyeS5idWZmZXJzW2ldID0gbmV3IEJ1ZmZlcl8xLkJ1ZmZlcih0aGlzLmJ1ZmZlcnNbaV0uZGF0YS5zbGljZSgpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yICh2YXIgaSQxIGluIHRoaXMuYXR0cmlidXRlcykge1xyXG4gICAgICAgICAgICB2YXIgYXR0cmliID0gdGhpcy5hdHRyaWJ1dGVzW2kkMV07XHJcbiAgICAgICAgICAgIGdlb21ldHJ5LmF0dHJpYnV0ZXNbaSQxXSA9IG5ldyBBdHRyaWJ1dGVfMS5BdHRyaWJ1dGUoYXR0cmliLmJ1ZmZlciwgYXR0cmliLnNpemUsIGF0dHJpYi5ub3JtYWxpemVkLCBhdHRyaWIudHlwZSwgYXR0cmliLnN0cmlkZSwgYXR0cmliLnN0YXJ0LCBhdHRyaWIuaW5zdGFuY2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5pbmRleEJ1ZmZlcikge1xyXG4gICAgICAgICAgICBnZW9tZXRyeS5pbmRleEJ1ZmZlciA9IGdlb21ldHJ5LmJ1ZmZlcnNbdGhpcy5idWZmZXJzLmluZGV4T2YodGhpcy5pbmRleEJ1ZmZlcildO1xyXG4gICAgICAgICAgICBnZW9tZXRyeS5pbmRleEJ1ZmZlci5pbmRleCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBnZW9tZXRyeTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogbWVyZ2VzIGFuIGFycmF5IG9mIGdlb21ldHJpZXMgaW50byBhIG5ldyBzaW5nbGUgb25lXHJcbiAgICAgKiBnZW9tZXRyeSBhdHRyaWJ1dGUgc3R5bGVzIG11c3QgbWF0Y2ggZm9yIHRoaXMgb3BlcmF0aW9uIHRvIHdvcmtcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1BJWEkuR2VvbWV0cnlbXX0gZ2VvbWV0cmllcyBhcnJheSBvZiBnZW9tZXRyaWVzIHRvIG1lcmdlXHJcbiAgICAgKiBAcmV0dXJucyB7UElYSS5HZW9tZXRyeX0gc2hpbnkgbmV3IGdlb21ldHJ5IVxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgbWVyZ2UoZ2VvbWV0cmllcykge1xyXG4gICAgICAgIC8vIHRvZG8gYWRkIGEgZ2VvbWV0cnkgY2hlY2shXHJcbiAgICAgICAgLy8gYWxzbyBhIHNpemUgY2hlY2suLiBjYW50IGJlIHRvbyBiaWchXVxyXG4gICAgICAgIHZhciBnZW9tZXRyeU91dCA9IG5ldyBHZW9tZXRyeSgpO1xyXG4gICAgICAgIHZhciBhcnJheXMgPSBbXTtcclxuICAgICAgICB2YXIgc2l6ZXMgPSBbXTtcclxuICAgICAgICB2YXIgb2Zmc2V0cyA9IFtdO1xyXG4gICAgICAgIHZhciBnZW9tZXRyeTtcclxuICAgICAgICAvLyBwYXNzIG9uZS4uIGdldCBzaXplcy4uXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBnZW9tZXRyaWVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGdlb21ldHJ5ID0gZ2VvbWV0cmllc1tpXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBnZW9tZXRyeS5idWZmZXJzLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICBzaXplc1tqXSA9IHNpemVzW2pdIHx8IDA7XHJcbiAgICAgICAgICAgICAgICBzaXplc1tqXSArPSBnZW9tZXRyeS5idWZmZXJzW2pdLmRhdGEubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgb2Zmc2V0c1tqXSA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gYnVpbGQgdGhlIGNvcnJlY3Qgc2l6ZSBhcnJheXMuLlxyXG4gICAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGdlb21ldHJ5LmJ1ZmZlcnMubGVuZ3RoOyBpJDErKykge1xyXG4gICAgICAgICAgICAvLyBUT0RPIHR5cGVzIVxyXG4gICAgICAgICAgICBhcnJheXNbaSQxXSA9IG5ldyBHZW9tZXRyeS5tYXAkMVtHZW9tZXRyeS5nZXRCdWZmZXJUeXBlKGdlb21ldHJ5LmJ1ZmZlcnNbaSQxXS5kYXRhKV0oc2l6ZXNbaSQxXSk7XHJcbiAgICAgICAgICAgIGdlb21ldHJ5T3V0LmJ1ZmZlcnNbaSQxXSA9IG5ldyBCdWZmZXJfMS5CdWZmZXIoYXJyYXlzW2kkMV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBwYXNzIHRvIHNldCBkYXRhLi5cclxuICAgICAgICBmb3IgKHZhciBpJDIgPSAwOyBpJDIgPCBnZW9tZXRyaWVzLmxlbmd0aDsgaSQyKyspIHtcclxuICAgICAgICAgICAgZ2VvbWV0cnkgPSBnZW9tZXRyaWVzW2kkMl07XHJcbiAgICAgICAgICAgIGZvciAodmFyIGokMSA9IDA7IGokMSA8IGdlb21ldHJ5LmJ1ZmZlcnMubGVuZ3RoOyBqJDErKykge1xyXG4gICAgICAgICAgICAgICAgYXJyYXlzW2okMV0uc2V0KGdlb21ldHJ5LmJ1ZmZlcnNbaiQxXS5kYXRhLCBvZmZzZXRzW2okMV0pO1xyXG4gICAgICAgICAgICAgICAgb2Zmc2V0c1tqJDFdICs9IGdlb21ldHJ5LmJ1ZmZlcnNbaiQxXS5kYXRhLmxlbmd0aDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBnZW9tZXRyeU91dC5hdHRyaWJ1dGVzID0gZ2VvbWV0cnkuYXR0cmlidXRlcztcclxuICAgICAgICBpZiAoZ2VvbWV0cnkuaW5kZXhCdWZmZXIpIHtcclxuICAgICAgICAgICAgZ2VvbWV0cnlPdXQuaW5kZXhCdWZmZXIgPSBnZW9tZXRyeU91dC5idWZmZXJzW2dlb21ldHJ5LmJ1ZmZlcnMuaW5kZXhPZihnZW9tZXRyeS5pbmRleEJ1ZmZlcildO1xyXG4gICAgICAgICAgICBnZW9tZXRyeU91dC5pbmRleEJ1ZmZlci5pbmRleCA9IHRydWU7XHJcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSAwO1xyXG4gICAgICAgICAgICB2YXIgc3RyaWRlID0gMDtcclxuICAgICAgICAgICAgdmFyIG9mZnNldDIgPSAwO1xyXG4gICAgICAgICAgICB2YXIgYnVmZmVySW5kZXhUb0NvdW50ID0gMDtcclxuICAgICAgICAgICAgLy8gZ2V0IGEgYnVmZmVyXHJcbiAgICAgICAgICAgIGZvciAodmFyIGkkMyA9IDA7IGkkMyA8IGdlb21ldHJ5LmJ1ZmZlcnMubGVuZ3RoOyBpJDMrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGdlb21ldHJ5LmJ1ZmZlcnNbaSQzXSAhPT0gZ2VvbWV0cnkuaW5kZXhCdWZmZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICBidWZmZXJJbmRleFRvQ291bnQgPSBpJDM7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gZmlndXJlIG91dCB0aGUgc3RyaWRlIG9mIG9uZSBidWZmZXIuLlxyXG4gICAgICAgICAgICBmb3IgKHZhciBpJDQgaW4gZ2VvbWV0cnkuYXR0cmlidXRlcykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGF0dHJpYnV0ZSA9IGdlb21ldHJ5LmF0dHJpYnV0ZXNbaSQ0XTtcclxuICAgICAgICAgICAgICAgIGlmICgoYXR0cmlidXRlLmJ1ZmZlciB8IDApID09PSBidWZmZXJJbmRleFRvQ291bnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdHJpZGUgKz0gKChhdHRyaWJ1dGUuc2l6ZSAqIEdlb21ldHJ5LmJ5dGVTaXplTWFwW2F0dHJpYnV0ZS50eXBlXSkgLyA0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyB0aW1lIHRvIG9mZiBzZXQgYWxsIGluZGV4ZXMuLlxyXG4gICAgICAgICAgICBmb3IgKHZhciBpJDUgPSAwOyBpJDUgPCBnZW9tZXRyaWVzLmxlbmd0aDsgaSQ1KyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBpbmRleEJ1ZmZlckRhdGEgPSBnZW9tZXRyaWVzW2kkNV0uaW5kZXhCdWZmZXIuZGF0YTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGokMiA9IDA7IGokMiA8IGluZGV4QnVmZmVyRGF0YS5sZW5ndGg7IGokMisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZ2VvbWV0cnlPdXQuaW5kZXhCdWZmZXIuZGF0YVtqJDIgKyBvZmZzZXQyXSArPSBvZmZzZXQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gZ2VvbWV0cnkuYnVmZmVyc1tidWZmZXJJbmRleFRvQ291bnRdLmRhdGEubGVuZ3RoIC8gKHN0cmlkZSk7XHJcbiAgICAgICAgICAgICAgICBvZmZzZXQyICs9IGluZGV4QnVmZmVyRGF0YS5sZW5ndGg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGdlb21ldHJ5T3V0O1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgc3RhdGljIGdldEJ1ZmZlclR5cGUoYXJyYXkpIHtcclxuICAgICAgICBpZiAoYXJyYXkuQllURVNfUEVSX0VMRU1FTlQgPT09IDQpIHtcclxuICAgICAgICAgICAgaWYgKGFycmF5IGluc3RhbmNlb2YgRmxvYXQzMkFycmF5KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJ0Zsb2F0MzJBcnJheSc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoYXJyYXkgaW5zdGFuY2VvZiBVaW50MzJBcnJheSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICdVaW50MzJBcnJheSc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuICdJbnQzMkFycmF5JztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoYXJyYXkuQllURVNfUEVSX0VMRU1FTlQgPT09IDIpIHtcclxuICAgICAgICAgICAgaWYgKGFycmF5IGluc3RhbmNlb2YgVWludDE2QXJyYXkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAnVWludDE2QXJyYXknO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGFycmF5LkJZVEVTX1BFUl9FTEVNRU5UID09PSAxKSB7XHJcbiAgICAgICAgICAgIGlmIChhcnJheSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAnVWludDhBcnJheSc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gVE9ETyBtYXAgb3V0IHRoZSByZXN0IG9mIHRoZSBhcnJheSBlbGVtZW50cyFcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIHN0YXRpYyBpbnRlcmxlYXZlVHlwZWRBcnJheXMoYXJyYXlzLCBzaXplcykge1xyXG4gICAgICAgIHZhciBvdXRTaXplID0gMDtcclxuICAgICAgICB2YXIgc3RyaWRlID0gMDtcclxuICAgICAgICB2YXIgdmlld3MgPSB7fTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBzdHJpZGUgKz0gc2l6ZXNbaV07XHJcbiAgICAgICAgICAgIG91dFNpemUgKz0gYXJyYXlzW2ldLmxlbmd0aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcihvdXRTaXplICogNCk7XHJcbiAgICAgICAgdmFyIG91dCA9IG51bGw7XHJcbiAgICAgICAgdmFyIGxpdHRsZU9mZnNldCA9IDA7XHJcbiAgICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgYXJyYXlzLmxlbmd0aDsgaSQxKyspIHtcclxuICAgICAgICAgICAgdmFyIHNpemUgPSBzaXplc1tpJDFdO1xyXG4gICAgICAgICAgICB2YXIgYXJyYXkgPSBhcnJheXNbaSQxXTtcclxuICAgICAgICAgICAgdmFyIHR5cGUgPSBHZW9tZXRyeS5nZXRCdWZmZXJUeXBlKGFycmF5KTtcclxuICAgICAgICAgICAgaWYgKCF2aWV3c1t0eXBlXSkge1xyXG4gICAgICAgICAgICAgICAgdmlld3NbdHlwZV0gPSBuZXcgR2VvbWV0cnkubWFwW3R5cGVdKGJ1ZmZlcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb3V0ID0gdmlld3NbdHlwZV07XHJcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgYXJyYXkubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBpbmRleFN0YXJ0ID0gKChqIC8gc2l6ZSB8IDApICogc3RyaWRlKSArIGxpdHRsZU9mZnNldDtcclxuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IGogJSBzaXplO1xyXG4gICAgICAgICAgICAgICAgb3V0W2luZGV4U3RhcnQgKyBpbmRleF0gPSBhcnJheVtqXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsaXR0bGVPZmZzZXQgKz0gc2l6ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoYnVmZmVyKTtcclxuICAgIH1cclxufVxyXG4vKiBlc2xpbnQtZGlzYWJsZSBvYmplY3Qtc2hvcnRoYW5kICovXHJcbkdlb21ldHJ5Lm1hcCA9IHtcclxuICAgIEZsb2F0MzJBcnJheTogRmxvYXQzMkFycmF5LFxyXG4gICAgVWludDMyQXJyYXk6IFVpbnQzMkFycmF5LFxyXG4gICAgSW50MzJBcnJheTogSW50MzJBcnJheSxcclxuICAgIFVpbnQ4QXJyYXk6IFVpbnQ4QXJyYXksXHJcbn07XHJcbkdlb21ldHJ5LlVJRCQxID0gMDtcclxuLyogZXNsaW50LWRpc2FibGUgb2JqZWN0LXNob3J0aGFuZCAqL1xyXG5HZW9tZXRyeS5tYXAkMSA9IHtcclxuICAgIEZsb2F0MzJBcnJheTogRmxvYXQzMkFycmF5LFxyXG4gICAgVWludDMyQXJyYXk6IFVpbnQzMkFycmF5LFxyXG4gICAgSW50MzJBcnJheTogSW50MzJBcnJheSxcclxuICAgIFVpbnQ4QXJyYXk6IFVpbnQ4QXJyYXksXHJcbiAgICBVaW50MTZBcnJheTogVWludDE2QXJyYXksXHJcbn07XHJcbkdlb21ldHJ5LmJ5dGVTaXplTWFwID0geyA1MTI2OiA0LCA1MTIzOiAyLCA1MTIxOiAxIH07XHJcbmV4cG9ydHMuR2VvbWV0cnkgPSBHZW9tZXRyeTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgU3lzdGVtXzEgPSByZXF1aXJlKFwiLi9TeXN0ZW1cIik7XHJcbmNvbnN0IEdMQnVmZmVyXzEgPSByZXF1aXJlKFwiLi9HTEJ1ZmZlclwiKTtcclxuY29uc3QgRGlzcGxheVNldHRpbmdzXzEgPSByZXF1aXJlKFwiLi9EaXNwbGF5U2V0dGluZ3NcIik7XHJcbmNsYXNzIEdlb21ldHJ5U3lzdGVtIGV4dGVuZHMgU3lzdGVtXzEuU3lzdGVtIHtcclxuICAgIGNvbnN0cnVjdG9yKHJlbmRlcmVyKSB7XHJcbiAgICAgICAgc3VwZXIocmVuZGVyZXIpO1xyXG4gICAgICAgIHRoaXMuX2FjdGl2ZUdlb21ldHJ5ID0gbnVsbDtcclxuICAgICAgICB0aGlzLl9hY3RpdmVWYW8gPSBudWxsO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIGB0cnVlYCBpZiB3ZSBoYXMgYCpfdmVydGV4X2FycmF5X29iamVjdGAgZXh0ZW5zaW9uXHJcbiAgICAgICAgICogQG1lbWJlciB7Ym9vbGVhbn1cclxuICAgICAgICAgKiBAcmVhZG9ubHlcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmhhc1ZhbyA9IHRydWU7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogYHRydWVgIGlmIGhhcyBgQU5HTEVfaW5zdGFuY2VkX2FycmF5c2AgZXh0ZW5zaW9uXHJcbiAgICAgICAgICogQG1lbWJlciB7Ym9vbGVhbn1cclxuICAgICAgICAgKiBAcmVhZG9ubHlcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmhhc0luc3RhbmNlID0gdHJ1ZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBIGNhY2hlIG9mIGN1cnJlbnRseSBib3VuZCBidWZmZXIsXHJcbiAgICAgICAgICogY29udGFpbnMgb25seSB0d28gbWVtYmVycyB3aXRoIGtleXMgQVJSQVlfQlVGRkVSIGFuZCBFTEVNRU5UX0FSUkFZX0JVRkZFUlxyXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdC48bnVtYmVyLCBQSVhJLkJ1ZmZlcj59XHJcbiAgICAgICAgICogQHJlYWRvbmx5XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5ib3VuZEJ1ZmZlcnMgPSB7fTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDYWNoZSBmb3IgYWxsIGdlb21ldHJpZXMgYnkgaWQsIHVzZWQgaW4gY2FzZSByZW5kZXJlciBnZXRzIGRlc3Ryb3llZCBvciBmb3IgcHJvZmlsaW5nXHJcbiAgICAgICAgICogQG1lbWJlciB7b2JqZWN0fVxyXG4gICAgICAgICAqIEByZWFkb25seVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMubWFuYWdlZEdlb21ldHJpZXMgPSB7fTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDYWNoZSBmb3IgYWxsIGJ1ZmZlcnMgYnkgaWQsIHVzZWQgaW4gY2FzZSByZW5kZXJlciBnZXRzIGRlc3Ryb3llZCBvciBmb3IgcHJvZmlsaW5nXHJcbiAgICAgICAgICogQG1lbWJlciB7b2JqZWN0fVxyXG4gICAgICAgICAqIEByZWFkb25seVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMubWFuYWdlZEJ1ZmZlcnMgPSB7fTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB1cCB0aGUgcmVuZGVyZXIgY29udGV4dCBhbmQgbmVjZXNzYXJ5IGJ1ZmZlcnMuXHJcbiAgICAgKi9cclxuICAgIGNvbnRleHRDaGFuZ2UoKSB7XHJcbiAgICAgICAgdGhpcy5kaXNwb3NlQWxsKHRydWUpO1xyXG4gICAgICAgIHZhciBnbCA9IHRoaXMuZ2wgPSB0aGlzLnJlbmRlcmVyLmdsO1xyXG4gICAgICAgIHRoaXMuQ09OVEVYVF9VSUQgPSB0aGlzLnJlbmRlcmVyLkNPTlRFWFRfVUlEO1xyXG4gICAgICAgIC8vIHdlYmdsMlxyXG4gICAgICAgIGlmICghZ2wuY3JlYXRlVmVydGV4QXJyYXkpIHtcclxuICAgICAgICAgICAgLy8gd2ViZ2wgMSFcclxuICAgICAgICAgICAgdmFyIG5hdGl2ZVZhb0V4dGVuc2lvbiA9IHRoaXMucmVuZGVyZXIuY29udGV4dC5leHRlbnNpb25zLnZlcnRleEFycmF5T2JqZWN0O1xyXG4gICAgICAgICAgICBpZiAoRGlzcGxheVNldHRpbmdzXzEuRGlzcGxheVNldHRpbmdzLlBSRUZFUl9FTlYgPT09IERpc3BsYXlTZXR0aW5nc18xLkRpc3BsYXlTZXR0aW5ncy5FTlYuV0VCR0xfTEVHQUNZKSB7XHJcbiAgICAgICAgICAgICAgICBuYXRpdmVWYW9FeHRlbnNpb24gPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChuYXRpdmVWYW9FeHRlbnNpb24pIHtcclxuICAgICAgICAgICAgICAgIGdsLmNyZWF0ZVZlcnRleEFycmF5ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gbmF0aXZlVmFvRXh0ZW5zaW9uLmNyZWF0ZVZlcnRleEFycmF5T0VTKCk7IH07XHJcbiAgICAgICAgICAgICAgICBnbC5iaW5kVmVydGV4QXJyYXkgPSBmdW5jdGlvbiAodmFvKSB7IHJldHVybiBuYXRpdmVWYW9FeHRlbnNpb24uYmluZFZlcnRleEFycmF5T0VTKHZhbyk7IH07XHJcbiAgICAgICAgICAgICAgICBnbC5kZWxldGVWZXJ0ZXhBcnJheSA9IGZ1bmN0aW9uICh2YW8pIHsgcmV0dXJuIG5hdGl2ZVZhb0V4dGVuc2lvbi5kZWxldGVWZXJ0ZXhBcnJheU9FUyh2YW8pOyB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5oYXNWYW8gPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGdsLmNyZWF0ZVZlcnRleEFycmF5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGVtcHR5XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgZ2wuYmluZFZlcnRleEFycmF5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGVtcHR5XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgZ2wuZGVsZXRlVmVydGV4QXJyYXkgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZW1wdHlcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFnbC52ZXJ0ZXhBdHRyaWJEaXZpc29yKSB7XHJcbiAgICAgICAgICAgIHZhciBpbnN0YW5jZUV4dCA9IGdsLmdldEV4dGVuc2lvbignQU5HTEVfaW5zdGFuY2VkX2FycmF5cycpO1xyXG4gICAgICAgICAgICBpZiAoaW5zdGFuY2VFeHQpIHtcclxuICAgICAgICAgICAgICAgIGdsLnZlcnRleEF0dHJpYkRpdmlzb3IgPSBmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gaW5zdGFuY2VFeHQudmVydGV4QXR0cmliRGl2aXNvckFOR0xFKGEsIGIpOyB9O1xyXG4gICAgICAgICAgICAgICAgZ2wuZHJhd0VsZW1lbnRzSW5zdGFuY2VkID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQsIGUpIHsgcmV0dXJuIGluc3RhbmNlRXh0LmRyYXdFbGVtZW50c0luc3RhbmNlZEFOR0xFKGEsIGIsIGMsIGQsIGUpOyB9O1xyXG4gICAgICAgICAgICAgICAgZ2wuZHJhd0FycmF5c0luc3RhbmNlZCA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7IHJldHVybiBpbnN0YW5jZUV4dC5kcmF3QXJyYXlzSW5zdGFuY2VkQU5HTEUoYSwgYiwgYywgZCk7IH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmhhc0luc3RhbmNlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIEJpbmRzIGdlb21ldHJ5IHNvIHRoYXQgaXMgY2FuIGJlIGRyYXduLiBDcmVhdGluZyBhIFZhbyBpZiByZXF1aXJlZFxyXG4gICAgICogQHByb3RlY3RlZFxyXG4gICAgICogQHBhcmFtIHtQSVhJLkdlb21ldHJ5fSBnZW9tZXRyeSBpbnN0YW5jZSBvZiBnZW9tZXRyeSB0byBiaW5kXHJcbiAgICAgKiBAcGFyYW0ge1BJWEkuU2hhZGVyfSBzaGFkZXIgaW5zdGFuY2Ugb2Ygc2hhZGVyIHRvIGJpbmRcclxuICAgICAqL1xyXG4gICAgYmluZChnZW9tZXRyeSwgc2hhZGVyID0gbnVsbCkge1xyXG4gICAgICAgIHNoYWRlciA9IHNoYWRlciB8fCB0aGlzLnJlbmRlcmVyLnNoYWRlci5zaGFkZXI7XHJcbiAgICAgICAgdmFyIHJlZiA9IHRoaXM7XHJcbiAgICAgICAgdmFyIGdsID0gcmVmLmdsO1xyXG4gICAgICAgIC8vIG5vdCBzdXJlIHRoZSBiZXN0IHdheSB0byBhZGRyZXNzIHRoaXMuLlxyXG4gICAgICAgIC8vIGN1cnJlbnRseSBkaWZmZXJlbnQgc2hhZGVycyByZXF1aXJlIGRpZmZlcmVudCBWQU9zIGZvciB0aGUgc2FtZSBnZW9tZXRyeVxyXG4gICAgICAgIC8vIFN0aWxsIG11bGxpbmcgb3ZlciB0aGUgYmVzdCB3YXkgdG8gc29sdmUgdGhpcyBvbmUuLlxyXG4gICAgICAgIC8vIHdpbGwgbGlrZWx5IG5lZWQgdG8gbW9kaWZ5IHRoZSBzaGFkZXIgYXR0cmlidXRlIGxvY2F0aW9ucyBhdCBydW4gdGltZSFcclxuICAgICAgICB2YXIgdmFvcyA9IGdlb21ldHJ5LmdsVmVydGV4QXJyYXlPYmplY3RzW3RoaXMuQ09OVEVYVF9VSURdO1xyXG4gICAgICAgIGlmICghdmFvcykge1xyXG4gICAgICAgICAgICB0aGlzLm1hbmFnZWRHZW9tZXRyaWVzW2dlb21ldHJ5LmlkXSA9IGdlb21ldHJ5O1xyXG4gICAgICAgICAgICAvLyBnZW9tZXRyeS5kaXNwb3NlUnVubmVyLmFkZCh0aGlzKTtcclxuICAgICAgICAgICAgZ2VvbWV0cnkuZ2xWZXJ0ZXhBcnJheU9iamVjdHNbdGhpcy5DT05URVhUX1VJRF0gPSB2YW9zID0ge307XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciB2YW8gPSB2YW9zW3NoYWRlci5wcm9ncmFtLmlkXSB8fCB0aGlzLmluaXRHZW9tZXRyeVZhbyhnZW9tZXRyeSwgc2hhZGVyLnByb2dyYW0pO1xyXG4gICAgICAgIHRoaXMuX2FjdGl2ZUdlb21ldHJ5ID0gZ2VvbWV0cnk7XHJcbiAgICAgICAgaWYgKHRoaXMuX2FjdGl2ZVZhbyAhPT0gdmFvKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2FjdGl2ZVZhbyA9IHZhbztcclxuICAgICAgICAgICAgaWYgKHRoaXMuaGFzVmFvKSB7XHJcbiAgICAgICAgICAgICAgICBnbC5iaW5kVmVydGV4QXJyYXkodmFvKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZhdGVWYW8oZ2VvbWV0cnksIHNoYWRlci5wcm9ncmFtKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBUT0RPIC0gb3B0aW1pc2UgbGF0ZXIhXHJcbiAgICAgICAgLy8gZG9uJ3QgbmVlZCB0byBsb29wIHRocm91Z2ggaWYgbm90aGluZyBjaGFuZ2VkIVxyXG4gICAgICAgIC8vIG1heWJlIGxvb2sgdG8gYWRkIGFuICdhdXRvdXBkYXRlJyB0byBnZW9tZXRyeT9cclxuICAgICAgICB0aGlzLnVwZGF0ZUJ1ZmZlcnMoKTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogUmVzZXQgYW5kIHVuYmluZCBhbnkgYWN0aXZlIFZBTyBhbmQgZ2VvbWV0cnlcclxuICAgICAqL1xyXG4gICAgcmVzZXQoKSB7XHJcbiAgICAgICAgdGhpcy51bmJpbmQoKTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlIGJ1ZmZlcnNcclxuICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAqL1xyXG4gICAgdXBkYXRlQnVmZmVycygpIHtcclxuICAgICAgICB2YXIgZ2VvbWV0cnkgPSB0aGlzLl9hY3RpdmVHZW9tZXRyeTtcclxuICAgICAgICB2YXIgcmVmID0gdGhpcztcclxuICAgICAgICB2YXIgZ2wgPSByZWYuZ2w7XHJcbiAgICAgICAgLy8gcmV2ZWFsKGdsKTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdlb21ldHJ5LmJ1ZmZlcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIGJ1ZmZlciA9IGdlb21ldHJ5LmJ1ZmZlcnNbaV07XHJcbiAgICAgICAgICAgIHZhciBnbEJ1ZmZlciA9IGJ1ZmZlci5fZ2xCdWZmZXJzW3RoaXMuQ09OVEVYVF9VSURdO1xyXG4gICAgICAgICAgICBpZiAoYnVmZmVyLl91cGRhdGVJRCAhPT0gZ2xCdWZmZXIudXBkYXRlSUQpIHtcclxuICAgICAgICAgICAgICAgIGdsQnVmZmVyLnVwZGF0ZUlEID0gYnVmZmVyLl91cGRhdGVJRDtcclxuICAgICAgICAgICAgICAgIC8vIFRPRE8gY2FuIGNhY2hlIHRoaXMgb24gYnVmZmVyISBtYXliZSBhZGRlZCBhIGdldHRlciAvIHNldHRlcj9cclxuICAgICAgICAgICAgICAgIHZhciB0eXBlID0gYnVmZmVyLmluZGV4ID8gZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIgOiBnbC5BUlJBWV9CVUZGRVI7XHJcbiAgICAgICAgICAgICAgICAvLyBUT0RPIHRoaXMgY291bGQgY2hhbmdlIGlmIHRoZSBWQU8gY2hhbmdlcy4uLlxyXG4gICAgICAgICAgICAgICAgLy8gbmVlZCB0byBjb21lIHVwIHdpdGggYSBiZXR0ZXIgd2F5IHRvIGNhY2hlLi5cclxuICAgICAgICAgICAgICAgIC8vIGlmICh0aGlzLmJvdW5kQnVmZmVyc1t0eXBlXSAhPT0gZ2xCdWZmZXIpXHJcbiAgICAgICAgICAgICAgICAvLyB7XHJcbiAgICAgICAgICAgICAgICAvLyB0aGlzLmJvdW5kQnVmZmVyc1t0eXBlXSA9IGdsQnVmZmVyO1xyXG4gICAgICAgICAgICAgICAgZ2wuYmluZEJ1ZmZlcih0eXBlLCBnbEJ1ZmZlci5idWZmZXIpO1xyXG4gICAgICAgICAgICAgICAgLy8gfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fYm91bmRCdWZmZXIgPSBnbEJ1ZmZlcjtcclxuICAgICAgICAgICAgICAgIGlmIChnbEJ1ZmZlci5ieXRlTGVuZ3RoID49IGJ1ZmZlci5kYXRhLmJ5dGVMZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBvZmZzZXQgaXMgYWx3YXlzIHplcm8gZm9yIG5vdyFcclxuICAgICAgICAgICAgICAgICAgICBnbC5idWZmZXJTdWJEYXRhKHR5cGUsIDAsIGJ1ZmZlci5kYXRhKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBkcmF3VHlwZSA9IGJ1ZmZlci5zdGF0aWMgPyBnbC5TVEFUSUNfRFJBVyA6IGdsLkRZTkFNSUNfRFJBVztcclxuICAgICAgICAgICAgICAgICAgICBnbEJ1ZmZlci5ieXRlTGVuZ3RoID0gYnVmZmVyLmRhdGEuYnl0ZUxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICBnbC5idWZmZXJEYXRhKHR5cGUsIGJ1ZmZlci5kYXRhLCBkcmF3VHlwZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIENoZWNrIGNvbXBhYmlsaXR5IGJldHdlZW4gYSBnZW9tZXRyeSBhbmQgYSBwcm9ncmFtXHJcbiAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgKiBAcGFyYW0ge1BJWEkuR2VvbWV0cnl9IGdlb21ldHJ5IC0gR2VvbWV0cnkgaW5zdGFuY2VcclxuICAgICAqIEBwYXJhbSB7UElYSS5Qcm9ncmFtfSBwcm9ncmFtIC0gUHJvZ3JhbSBpbnN0YW5jZVxyXG4gICAgICovXHJcbiAgICBjaGVja0NvbXBhdGliaWxpdHkoZ2VvbWV0cnksIHByb2dyYW0pIHtcclxuICAgICAgICAvLyBnZW9tZXRyeSBtdXN0IGhhdmUgYXQgbGVhc3QgYWxsIHRoZSBhdHRyaWJ1dGVzIHRoYXQgdGhlIHNoYWRlciByZXF1aXJlcy5cclxuICAgICAgICB2YXIgZ2VvbWV0cnlBdHRyaWJ1dGVzID0gZ2VvbWV0cnkuYXR0cmlidXRlcztcclxuICAgICAgICB2YXIgc2hhZGVyQXR0cmlidXRlcyA9IHByb2dyYW0uYXR0cmlidXRlRGF0YTtcclxuICAgICAgICBmb3IgKHZhciBqIGluIHNoYWRlckF0dHJpYnV0ZXMpIHtcclxuICAgICAgICAgICAgaWYgKCFnZW9tZXRyeUF0dHJpYnV0ZXNbal0pIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigoXCJzaGFkZXIgYW5kIGdlb21ldHJ5IGluY29tcGF0aWJsZSwgZ2VvbWV0cnkgbWlzc2luZyB0aGUgXFxcIlwiICsgaiArIFwiXFxcIiBhdHRyaWJ1dGVcIikpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUYWtlcyBhIGdlb21ldHJ5IGFuZCBwcm9ncmFtIGFuZCBnZW5lcmF0ZXMgYSB1bmlxdWUgc2lnbmF0dXJlIGZvciB0aGVtLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7UElYSS5HZW9tZXRyeX0gZ2VvbWV0cnkgdG8gZ2V0IHNpZ25hdHVyZSBmcm9tXHJcbiAgICAgKiBAcGFyYW0ge1BJWEkuUHJvZ3JhbX0gcHJvZ3JhbSB0byB0ZXN0IGdlb21ldHJ5IGFnYWluc3RcclxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IFVuaXF1ZSBzaWduYXR1cmUgb2YgdGhlIGdlb21ldHJ5IGFuZCBwcm9ncmFtXHJcbiAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgKi9cclxuICAgIGdldFNpZ25hdHVyZShnZW9tZXRyeSwgcHJvZ3JhbSkge1xyXG4gICAgICAgIHZhciBhdHRyaWJzID0gZ2VvbWV0cnkuYXR0cmlidXRlcztcclxuICAgICAgICB2YXIgc2hhZGVyQXR0cmlidXRlcyA9IHByb2dyYW0uYXR0cmlidXRlRGF0YTtcclxuICAgICAgICB2YXIgc3RyaW5ncyA9IFsnZycsIGdlb21ldHJ5LmlkXTtcclxuICAgICAgICBmb3IgKHZhciBpIGluIGF0dHJpYnMpIHtcclxuICAgICAgICAgICAgaWYgKHNoYWRlckF0dHJpYnV0ZXNbaV0pIHtcclxuICAgICAgICAgICAgICAgIHN0cmluZ3MucHVzaChpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc3RyaW5ncy5qb2luKCctJyk7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgb3IgZ2V0cyBWYW8gd2l0aCB0aGUgc2FtZSBzdHJ1Y3R1cmUgYXMgdGhlIGdlb21ldHJ5IGFuZCBzdG9yZXMgaXQgb24gdGhlIGdlb21ldHJ5LlxyXG4gICAgICogSWYgdmFvIGlzIGNyZWF0ZWQsIGl0IGlzIGJvdW5kIGF1dG9tYXRpY2FsbHkuXHJcbiAgICAgKlxyXG4gICAgICogQHByb3RlY3RlZFxyXG4gICAgICogQHBhcmFtIHtQSVhJLkdlb21ldHJ5fSBnZW9tZXRyeSAtIEluc3RhbmNlIG9mIGdlb21ldHJ5IHRvIHRvIGdlbmVyYXRlIFZhbyBmb3JcclxuICAgICAqIEBwYXJhbSB7UElYSS5Qcm9ncmFtfSBwcm9ncmFtIC0gSW5zdGFuY2Ugb2YgcHJvZ3JhbVxyXG4gICAgICovXHJcbiAgICBpbml0R2VvbWV0cnlWYW8oZ2VvbWV0cnksIHByb2dyYW0pIHtcclxuICAgICAgICB0aGlzLmNoZWNrQ29tcGF0aWJpbGl0eShnZW9tZXRyeSwgcHJvZ3JhbSk7XHJcbiAgICAgICAgdmFyIGdsID0gdGhpcy5nbDtcclxuICAgICAgICB2YXIgQ09OVEVYVF9VSUQgPSB0aGlzLkNPTlRFWFRfVUlEO1xyXG4gICAgICAgIHZhciBzaWduYXR1cmUgPSB0aGlzLmdldFNpZ25hdHVyZShnZW9tZXRyeSwgcHJvZ3JhbSk7XHJcbiAgICAgICAgdmFyIHZhb09iamVjdEhhc2ggPSBnZW9tZXRyeS5nbFZlcnRleEFycmF5T2JqZWN0c1t0aGlzLkNPTlRFWFRfVUlEXTtcclxuICAgICAgICB2YXIgdmFvID0gdmFvT2JqZWN0SGFzaFtzaWduYXR1cmVdO1xyXG4gICAgICAgIGlmICh2YW8pIHtcclxuICAgICAgICAgICAgLy8gdGhpcyB3aWxsIGdpdmUgdXMgZWFzeSBhY2Nlc3MgdG8gdGhlIHZhb1xyXG4gICAgICAgICAgICB2YW9PYmplY3RIYXNoW3Byb2dyYW0uaWRdID0gdmFvO1xyXG4gICAgICAgICAgICByZXR1cm4gdmFvO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgYnVmZmVycyA9IGdlb21ldHJ5LmJ1ZmZlcnM7XHJcbiAgICAgICAgdmFyIGF0dHJpYnV0ZXMgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzO1xyXG4gICAgICAgIHZhciB0ZW1wU3RyaWRlID0ge307XHJcbiAgICAgICAgdmFyIHRlbXBTdGFydCA9IHt9O1xyXG4gICAgICAgIGZvciAodmFyIGogaW4gYnVmZmVycykge1xyXG4gICAgICAgICAgICB0ZW1wU3RyaWRlW2pdID0gMDtcclxuICAgICAgICAgICAgdGVtcFN0YXJ0W2pdID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yICh2YXIgaiQxIGluIGF0dHJpYnV0ZXMpIHtcclxuICAgICAgICAgICAgaWYgKCFhdHRyaWJ1dGVzW2okMV0uc2l6ZSAmJiBwcm9ncmFtLmF0dHJpYnV0ZURhdGFbaiQxXSkge1xyXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlc1tqJDFdLnNpemUgPSBwcm9ncmFtLmF0dHJpYnV0ZURhdGFbaiQxXS5zaXplO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKCFhdHRyaWJ1dGVzW2okMV0uc2l6ZSkge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKChcIlBJWEkgR2VvbWV0cnkgYXR0cmlidXRlICdcIiArIGokMSArIFwiJyBzaXplIGNhbm5vdCBiZSBkZXRlcm1pbmVkIChsaWtlbHkgdGhlIGJvdW5kIHNoYWRlciBkb2VzIG5vdCBoYXZlIHRoZSBhdHRyaWJ1dGUpXCIpKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRlbXBTdHJpZGVbYXR0cmlidXRlc1tqJDFdLmJ1ZmZlcl0gKz0gYXR0cmlidXRlc1tqJDFdLnNpemUgKiBHZW9tZXRyeVN5c3RlbS5ieXRlU2l6ZU1hcCQxW2F0dHJpYnV0ZXNbaiQxXS50eXBlXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yICh2YXIgaiQyIGluIGF0dHJpYnV0ZXMpIHtcclxuICAgICAgICAgICAgdmFyIGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNbaiQyXTtcclxuICAgICAgICAgICAgdmFyIGF0dHJpYlNpemUgPSBhdHRyaWJ1dGUuc2l6ZTtcclxuICAgICAgICAgICAgaWYgKGF0dHJpYnV0ZS5zdHJpZGUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRlbXBTdHJpZGVbYXR0cmlidXRlLmJ1ZmZlcl0gPT09IGF0dHJpYlNpemUgKiBHZW9tZXRyeVN5c3RlbS5ieXRlU2l6ZU1hcCQxW2F0dHJpYnV0ZS50eXBlXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZS5zdHJpZGUgPSAwO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlLnN0cmlkZSA9IHRlbXBTdHJpZGVbYXR0cmlidXRlLmJ1ZmZlcl07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGF0dHJpYnV0ZS5zdGFydCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGUuc3RhcnQgPSB0ZW1wU3RhcnRbYXR0cmlidXRlLmJ1ZmZlcl07XHJcbiAgICAgICAgICAgICAgICB0ZW1wU3RhcnRbYXR0cmlidXRlLmJ1ZmZlcl0gKz0gYXR0cmliU2l6ZSAqIEdlb21ldHJ5U3lzdGVtLmJ5dGVTaXplTWFwJDFbYXR0cmlidXRlLnR5cGVdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhbyA9IGdsLmNyZWF0ZVZlcnRleEFycmF5KCk7XHJcbiAgICAgICAgZ2wuYmluZFZlcnRleEFycmF5KHZhbyk7XHJcbiAgICAgICAgLy8gZmlyc3QgdXBkYXRlIC0gYW5kIGNyZWF0ZSB0aGUgYnVmZmVycyFcclxuICAgICAgICAvLyBvbmx5IGNyZWF0ZSBhIGdsIGJ1ZmZlciBpZiBpdCBhY3R1YWxseSBnZXRzXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBidWZmZXJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBidWZmZXIgPSBidWZmZXJzW2ldO1xyXG4gICAgICAgICAgICBpZiAoIWJ1ZmZlci5fZ2xCdWZmZXJzW0NPTlRFWFRfVUlEXSkge1xyXG4gICAgICAgICAgICAgICAgYnVmZmVyLl9nbEJ1ZmZlcnNbQ09OVEVYVF9VSURdID0gbmV3IEdMQnVmZmVyXzEuR0xCdWZmZXIoZ2wuY3JlYXRlQnVmZmVyKCkpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tYW5hZ2VkQnVmZmVyc1tidWZmZXIuaWRdID0gYnVmZmVyO1xyXG4gICAgICAgICAgICAgICAgLy8gYnVmZmVyLmRpc3Bvc2VSdW5uZXIuYWRkKHRoaXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJ1ZmZlci5fZ2xCdWZmZXJzW0NPTlRFWFRfVUlEXS5yZWZDb3VudCsrO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBUT0RPIC0gbWF5YmUgbWFrZSB0aGlzIGEgZGF0YSBvYmplY3Q/XHJcbiAgICAgICAgLy8gbGV0cyB3YWl0IHRvIHNlZSBpZiB3ZSBuZWVkIHRvIGZpcnN0IVxyXG4gICAgICAgIHRoaXMuYWN0aXZhdGVWYW8oZ2VvbWV0cnksIHByb2dyYW0pO1xyXG4gICAgICAgIHRoaXMuX2FjdGl2ZVZhbyA9IHZhbztcclxuICAgICAgICAvLyBhZGQgaXQgdG8gdGhlIGNhY2hlIVxyXG4gICAgICAgIHZhb09iamVjdEhhc2hbcHJvZ3JhbS5pZF0gPSB2YW87XHJcbiAgICAgICAgdmFvT2JqZWN0SGFzaFtzaWduYXR1cmVdID0gdmFvO1xyXG4gICAgICAgIHJldHVybiB2YW87XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIERpc3Bvc2VzIGJ1ZmZlclxyXG4gICAgICogQHBhcmFtIHtQSVhJLkJ1ZmZlcn0gYnVmZmVyIGJ1ZmZlciB3aXRoIGRhdGFcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2NvbnRleHRMb3N0PWZhbHNlXSBJZiBjb250ZXh0IHdhcyBsb3N0LCB3ZSBzdXBwcmVzcyBkZWxldGVWZXJ0ZXhBcnJheVxyXG4gICAgICovXHJcbiAgICBkaXNwb3NlQnVmZmVyKGJ1ZmZlciwgY29udGV4dExvc3QpIHtcclxuICAgICAgICBpZiAoIXRoaXMubWFuYWdlZEJ1ZmZlcnNbYnVmZmVyLmlkXSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRlbGV0ZSB0aGlzLm1hbmFnZWRCdWZmZXJzW2J1ZmZlci5pZF07XHJcbiAgICAgICAgdmFyIGdsQnVmZmVyID0gYnVmZmVyLl9nbEJ1ZmZlcnNbdGhpcy5DT05URVhUX1VJRF07XHJcbiAgICAgICAgdmFyIGdsID0gdGhpcy5nbDtcclxuICAgICAgICAvLyBidWZmZXIuZGlzcG9zZVJ1bm5lci5yZW1vdmUodGhpcyk7XHJcbiAgICAgICAgaWYgKCFnbEJ1ZmZlcikge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghY29udGV4dExvc3QpIHtcclxuICAgICAgICAgICAgZ2wuZGVsZXRlQnVmZmVyKGdsQnVmZmVyLmJ1ZmZlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRlbGV0ZSBidWZmZXIuX2dsQnVmZmVyc1t0aGlzLkNPTlRFWFRfVUlEXTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogRGlzcG9zZXMgZ2VvbWV0cnlcclxuICAgICAqIEBwYXJhbSB7UElYSS5HZW9tZXRyeX0gZ2VvbWV0cnkgR2VvbWV0cnkgd2l0aCBidWZmZXJzLiBPbmx5IFZBTyB3aWxsIGJlIGRpc3Bvc2VkXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtjb250ZXh0TG9zdD1mYWxzZV0gSWYgY29udGV4dCB3YXMgbG9zdCwgd2Ugc3VwcHJlc3MgZGVsZXRlVmVydGV4QXJyYXlcclxuICAgICAqL1xyXG4gICAgZGlzcG9zZUdlb21ldHJ5KGdlb21ldHJ5LCBjb250ZXh0TG9zdCkge1xyXG4gICAgICAgIGlmICghdGhpcy5tYW5hZ2VkR2VvbWV0cmllc1tnZW9tZXRyeS5pZF0pIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkZWxldGUgdGhpcy5tYW5hZ2VkR2VvbWV0cmllc1tnZW9tZXRyeS5pZF07XHJcbiAgICAgICAgdmFyIHZhb3MgPSBnZW9tZXRyeS5nbFZlcnRleEFycmF5T2JqZWN0c1t0aGlzLkNPTlRFWFRfVUlEXTtcclxuICAgICAgICB2YXIgZ2wgPSB0aGlzLmdsO1xyXG4gICAgICAgIHZhciBidWZmZXJzID0gZ2VvbWV0cnkuYnVmZmVycztcclxuICAgICAgICBnZW9tZXRyeS5kaXNwb3NlUnVubmVyLnJlbW92ZSh0aGlzKTtcclxuICAgICAgICBpZiAoIXZhb3MpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ1ZmZlcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIGJ1ZiA9IGJ1ZmZlcnNbaV0uX2dsQnVmZmVyc1t0aGlzLkNPTlRFWFRfVUlEXTtcclxuICAgICAgICAgICAgYnVmLnJlZkNvdW50LS07XHJcbiAgICAgICAgICAgIGlmIChidWYucmVmQ291bnQgPT09IDAgJiYgIWNvbnRleHRMb3N0KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3Bvc2VCdWZmZXIoYnVmZmVyc1tpXSwgY29udGV4dExvc3QpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghY29udGV4dExvc3QpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgdmFvSWQgaW4gdmFvcykge1xyXG4gICAgICAgICAgICAgICAgLy8gZGVsZXRlIG9ubHkgc2lnbmF0dXJlcywgZXZlcnl0aGluZyBlbHNlIGFyZSBjb3BpZXNcclxuICAgICAgICAgICAgICAgIGlmICh2YW9JZFswXSA9PT0gJ2cnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbyA9IHZhb3NbdmFvSWRdO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9hY3RpdmVWYW8gPT09IHZhbykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnVuYmluZCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBnbC5kZWxldGVWZXJ0ZXhBcnJheSh2YW8pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRlbGV0ZSBnZW9tZXRyeS5nbFZlcnRleEFycmF5T2JqZWN0c1t0aGlzLkNPTlRFWFRfVUlEXTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogZGlzcG9zZSBhbGwgV2ViR0wgcmVzb3VyY2VzIG9mIGFsbCBtYW5hZ2VkIGdlb21ldHJpZXMgYW5kIGJ1ZmZlcnNcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2NvbnRleHRMb3N0PWZhbHNlXSBJZiBjb250ZXh0IHdhcyBsb3N0LCB3ZSBzdXBwcmVzcyBgZ2wuZGVsZXRlYCBjYWxsc1xyXG4gICAgICovXHJcbiAgICBkaXNwb3NlQWxsKGNvbnRleHRMb3N0KSB7XHJcbiAgICAgICAgdmFyIGFsbCA9IE9iamVjdC5rZXlzKHRoaXMubWFuYWdlZEdlb21ldHJpZXMpO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWxsLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGlzcG9zZUdlb21ldHJ5KHRoaXMubWFuYWdlZEdlb21ldHJpZXNbYWxsW2ldXSwgY29udGV4dExvc3QpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBhbGwgPSBPYmplY3Qua2V5cyh0aGlzLm1hbmFnZWRCdWZmZXJzKTtcclxuICAgICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBhbGwubGVuZ3RoOyBpJDErKykge1xyXG4gICAgICAgICAgICB0aGlzLmRpc3Bvc2VCdWZmZXIodGhpcy5tYW5hZ2VkQnVmZmVyc1thbGxbaSQxXV0sIGNvbnRleHRMb3N0KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIEFjdGl2YXRlIHZlcnRleCBhcnJheSBvYmplY3RcclxuICAgICAqXHJcbiAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgKiBAcGFyYW0ge1BJWEkuR2VvbWV0cnl9IGdlb21ldHJ5IC0gR2VvbWV0cnkgaW5zdGFuY2VcclxuICAgICAqIEBwYXJhbSB7UElYSS5Qcm9ncmFtfSBwcm9ncmFtIC0gU2hhZGVyIHByb2dyYW0gaW5zdGFuY2VcclxuICAgICAqL1xyXG4gICAgYWN0aXZhdGVWYW8oZ2VvbWV0cnksIHByb2dyYW0pIHtcclxuICAgICAgICB2YXIgZ2wgPSB0aGlzLmdsO1xyXG4gICAgICAgIHZhciBDT05URVhUX1VJRCA9IHRoaXMuQ09OVEVYVF9VSUQ7XHJcbiAgICAgICAgdmFyIGJ1ZmZlcnMgPSBnZW9tZXRyeS5idWZmZXJzO1xyXG4gICAgICAgIHZhciBhdHRyaWJ1dGVzID0gZ2VvbWV0cnkuYXR0cmlidXRlcztcclxuICAgICAgICBpZiAoZ2VvbWV0cnkuaW5kZXhCdWZmZXIpIHtcclxuICAgICAgICAgICAgLy8gZmlyc3QgdXBkYXRlIHRoZSBpbmRleCBidWZmZXIgaWYgd2UgaGF2ZSBvbmUuLlxyXG4gICAgICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBnZW9tZXRyeS5pbmRleEJ1ZmZlci5fZ2xCdWZmZXJzW0NPTlRFWFRfVUlEXS5idWZmZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbGFzdEJ1ZmZlciA9IG51bGw7XHJcbiAgICAgICAgLy8gYWRkIGEgbmV3IG9uZSFcclxuICAgICAgICBmb3IgKHZhciBqIGluIGF0dHJpYnV0ZXMpIHtcclxuICAgICAgICAgICAgdmFyIGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNbal07XHJcbiAgICAgICAgICAgIHZhciBidWZmZXIgPSBidWZmZXJzW2F0dHJpYnV0ZS5idWZmZXJdO1xyXG4gICAgICAgICAgICB2YXIgZ2xCdWZmZXIgPSBidWZmZXIuX2dsQnVmZmVyc1tDT05URVhUX1VJRF07XHJcbiAgICAgICAgICAgIGlmIChwcm9ncmFtLmF0dHJpYnV0ZURhdGFbal0pIHtcclxuICAgICAgICAgICAgICAgIGlmIChsYXN0QnVmZmVyICE9PSBnbEJ1ZmZlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBnbEJ1ZmZlci5idWZmZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGxhc3RCdWZmZXIgPSBnbEJ1ZmZlcjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBsb2NhdGlvbiA9IHByb2dyYW0uYXR0cmlidXRlRGF0YVtqXS5sb2NhdGlvbjtcclxuICAgICAgICAgICAgICAgIC8vIFRPRE8gaW50cm9kdWNlIHN0YXRlIGFnYWluXHJcbiAgICAgICAgICAgICAgICAvLyB3ZSBjYW4gb3B0aW1pc2UgdGhpcyBmb3Igb2xkZXIgZGV2aWNlcyB0aGF0IGhhdmUgbm8gVkFPc1xyXG4gICAgICAgICAgICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkobG9jYXRpb24pO1xyXG4gICAgICAgICAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihsb2NhdGlvbiwgYXR0cmlidXRlLnNpemUsIGF0dHJpYnV0ZS50eXBlIHx8IGdsLkZMT0FULCBhdHRyaWJ1dGUubm9ybWFsaXplZCwgYXR0cmlidXRlLnN0cmlkZSwgYXR0cmlidXRlLnN0YXJ0KTtcclxuICAgICAgICAgICAgICAgIGlmIChhdHRyaWJ1dGUuaW5zdGFuY2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIGNhbGN1bGF0ZSBpbnN0YW5jZSBjb3VudCBiYXNlZCBvZiB0aGlzLi4uXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaGFzSW5zdGFuY2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZ2wudmVydGV4QXR0cmliRGl2aXNvcihsb2NhdGlvbiwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dlb21ldHJ5IGVycm9yLCBHUFUgSW5zdGFuY2luZyBpcyBub3Qgc3VwcG9ydGVkIG9uIHRoaXMgZGV2aWNlJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBEcmF3IHRoZSBnZW9tZXRyeVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB0eXBlIC0gdGhlIHR5cGUgcHJpbWl0aXZlIHRvIHJlbmRlclxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtzaXplXSAtIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gYmUgcmVuZGVyZWRcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbc3RhcnRdIC0gU3RhcnRpbmcgaW5kZXhcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbaW5zdGFuY2VDb3VudF0gLSB0aGUgbnVtYmVyIG9mIGluc3RhbmNlcyBvZiB0aGUgc2V0IG9mIGVsZW1lbnRzIHRvIGV4ZWN1dGVcclxuICAgICAqL1xyXG4gICAgZHJhdyh0eXBlLCBzaXplID0gLTEsIHN0YXJ0ID0gMCwgaW5zdGFuY2VDb3VudCA9IDEpIHtcclxuICAgICAgICB2YXIgcmVmID0gdGhpcztcclxuICAgICAgICB2YXIgZ2wgPSByZWYuZ2w7XHJcbiAgICAgICAgdmFyIGdlb21ldHJ5ID0gdGhpcy5fYWN0aXZlR2VvbWV0cnk7XHJcbiAgICAgICAgLy8gVE9ETy4uIHRoaXMgc2hvdWxkIG5vdCBjaGFuZ2Ugc28gbWF5YmUgY2FjaGUgdGhlIGZ1bmN0aW9uP1xyXG4gICAgICAgIGlmIChzaXplIDwgMCkge1xyXG4gICAgICAgICAgICBzaXplID0gZ2VvbWV0cnkuaW5kZXhCdWZmZXIuZGF0YS5sZW5ndGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChnZW9tZXRyeS5pbmRleEJ1ZmZlcikge1xyXG4gICAgICAgICAgICBpZiAoZ2VvbWV0cnkuaW5zdGFuY2VkKSB7XHJcbiAgICAgICAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXHJcbiAgICAgICAgICAgICAgICBnbC5kcmF3RWxlbWVudHNJbnN0YW5jZWQodHlwZSwgc2l6ZSB8fCBnZW9tZXRyeS5pbmRleEJ1ZmZlci5kYXRhLmxlbmd0aCwgZ2wuVU5TSUdORURfU0hPUlQsIChzdGFydCB8fCAwKSAqIDIsIGluc3RhbmNlQ291bnQgfHwgMSk7XHJcbiAgICAgICAgICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4gKi9cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGdsLmRyYXdFbGVtZW50cyh0eXBlLCBzaXplIHx8IGdlb21ldHJ5LmluZGV4QnVmZmVyLmRhdGEubGVuZ3RoLCBnbC5VTlNJR05FRF9TSE9SVCwgKHN0YXJ0IHx8IDApICogMik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoZ2VvbWV0cnkuaW5zdGFuY2VkKSB7XHJcbiAgICAgICAgICAgIC8vIFRPRE8gbmVlZCBhIGJldHRlciB3YXkgdG8gY2FsY3VsYXRlIHNpemUuLlxyXG4gICAgICAgICAgICBnbC5kcmF3QXJyYXlzSW5zdGFuY2VkKHR5cGUsIHN0YXJ0LCBzaXplIHx8IGdlb21ldHJ5LmdldFNpemUoKSwgaW5zdGFuY2VDb3VudCB8fCAxKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGdsLmRyYXdBcnJheXModHlwZSwgc3RhcnQsIHNpemUgfHwgZ2VvbWV0cnkuZ2V0U2l6ZSgpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFVuYmluZC9yZXNldCBldmVyeXRoaW5nXHJcbiAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgKi9cclxuICAgIHVuYmluZCgpIHtcclxuICAgICAgICB0aGlzLmdsLmJpbmRWZXJ0ZXhBcnJheShudWxsKTtcclxuICAgICAgICB0aGlzLl9hY3RpdmVWYW8gPSBudWxsO1xyXG4gICAgICAgIHRoaXMuX2FjdGl2ZUdlb21ldHJ5ID0gbnVsbDtcclxuICAgIH1cclxuICAgIDtcclxufVxyXG5HZW9tZXRyeVN5c3RlbS5ieXRlU2l6ZU1hcCQxID0geyA1MTI2OiA0LCA1MTIzOiAyLCA1MTIxOiAxIH07XHJcbmV4cG9ydHMuR2VvbWV0cnlTeXN0ZW0gPSBHZW9tZXRyeVN5c3RlbTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgQ29udGFpbmVyXzEgPSByZXF1aXJlKFwiLi9Db250YWluZXJcIik7XHJcbmNvbnN0IFN0YXRlXzEgPSByZXF1aXJlKFwiLi9TdGF0ZVwiKTtcclxuY29uc3QgRmlsbFN0eWxlXzEgPSByZXF1aXJlKFwiLi9GaWxsU3R5bGVcIik7XHJcbi8vIGltcG9ydCB7IHNldHRpbmdzIH0gZnJvbSBcIi4vc2V0dGluZ3NcIjtcclxuY29uc3QgVGV4dHVyZV8xID0gcmVxdWlyZShcIi4vVGV4dHVyZVwiKTtcclxuY29uc3QgUmVjdGFuZ2xlXzEgPSByZXF1aXJlKFwiLi9SZWN0YW5nbGVcIik7XHJcbmNvbnN0IE1hdHJpeF8xID0gcmVxdWlyZShcIi4vTWF0cml4XCIpO1xyXG5jb25zdCBVbmlmb3JtR3JvdXBfMSA9IHJlcXVpcmUoXCIuL1VuaWZvcm1Hcm91cFwiKTtcclxuY29uc3QgU2hhZGVyXzEgPSByZXF1aXJlKFwiLi9TaGFkZXJcIik7XHJcbmNvbnN0IFBvaW50XzEgPSByZXF1aXJlKFwiLi9Qb2ludFwiKTtcclxuY29uc3QgUG9seWdvbl8xID0gcmVxdWlyZShcIi4vUG9seWdvblwiKTtcclxuY29uc3QgRWxsaXBzZV8xID0gcmVxdWlyZShcIi4vRWxsaXBzZVwiKTtcclxuY29uc3QgQ2lyY2xlXzEgPSByZXF1aXJlKFwiLi9DaXJjbGVcIik7XHJcbmNvbnN0IFJvdW5kZWRSZWN0YW5nbGVfMSA9IHJlcXVpcmUoXCIuL1JvdW5kZWRSZWN0YW5nbGVcIik7XHJcbmNvbnN0IEFyY1V0aWxzXzEgPSByZXF1aXJlKFwiLi9BcmNVdGlsc1wiKTtcclxuY29uc3QgQmV6aWVyVXRpbHNfMSA9IHJlcXVpcmUoXCIuL0JlemllclV0aWxzXCIpO1xyXG5jb25zdCBRdWFkcmF0aWNVdGlsc18xID0gcmVxdWlyZShcIi4vUXVhZHJhdGljVXRpbHNcIik7XHJcbmNvbnN0IExpbmVTdHlsZV8xID0gcmVxdWlyZShcIi4vTGluZVN0eWxlXCIpO1xyXG5jb25zdCBHcmFwaGljc0dlb21ldHJ5XzEgPSByZXF1aXJlKFwiLi9HcmFwaGljc0dlb21ldHJ5XCIpO1xyXG5jb25zdCBTdGFyXzEgPSByZXF1aXJlKFwiLi9TdGFyXCIpO1xyXG5jb25zdCBNYXRoU2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL01hdGhTZXR0aW5nc1wiKTtcclxuY29uc3QgQmxlbmRNb2Rlc1NldHRpbmdzXzEgPSByZXF1aXJlKFwiLi9CbGVuZE1vZGVzU2V0dGluZ3NcIik7XHJcbmNvbnN0IENvbG9yU2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL0NvbG9yU2V0dGluZ3NcIik7XHJcbmNsYXNzIEdyYXBoaWNzIGV4dGVuZHMgQ29udGFpbmVyXzEuQ29udGFpbmVyIHtcclxuICAgIGNvbnN0cnVjdG9yKGdlb21ldHJ5ID0gbnVsbCkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgaWYgKGdlb21ldHJ5ID09PSB2b2lkIDApIHtcclxuICAgICAgICAgICAgZ2VvbWV0cnkgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJbmNsdWRlcyB2ZXJ0ZXggcG9zaXRpb25zLCBmYWNlIGluZGljZXMsIG5vcm1hbHMsIGNvbG9ycywgVVZzLCBhbmRcclxuICAgICAgICAgKiBjdXN0b20gYXR0cmlidXRlcyB3aXRoaW4gYnVmZmVycywgcmVkdWNpbmcgdGhlIGNvc3Qgb2YgcGFzc2luZyBhbGxcclxuICAgICAgICAgKiB0aGlzIGRhdGEgdG8gdGhlIEdQVS4gQ2FuIGJlIHNoYXJlZCBiZXR3ZWVuIG11bHRpcGxlIE1lc2ggb3IgR3JhcGhpY3Mgb2JqZWN0cy5cclxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLkdyYXBoaWNzR2VvbWV0cnl9XHJcbiAgICAgICAgICogQHJlYWRvbmx5XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5nZW9tZXRyeSA9IGdlb21ldHJ5IHx8IG5ldyBHcmFwaGljc0dlb21ldHJ5XzEuR3JhcGhpY3NHZW9tZXRyeSgpO1xyXG4gICAgICAgIHRoaXMuZ2VvbWV0cnkucmVmQ291bnQrKztcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXByZXNlbnRzIHRoZSB2ZXJ0ZXggYW5kIGZyYWdtZW50IHNoYWRlcnMgdGhhdCBwcm9jZXNzZXMgdGhlIGdlb21ldHJ5IGFuZCBydW5zIG9uIHRoZSBHUFUuXHJcbiAgICAgICAgICogQ2FuIGJlIHNoYXJlZCBiZXR3ZWVuIG11bHRpcGxlIEdyYXBoaWNzIG9iamVjdHMuXHJcbiAgICAgICAgICogQG1lbWJlciB7UElYSS5TaGFkZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5zaGFkZXIgPSBudWxsO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlcHJlc2VudHMgdGhlIFdlYkdMIHN0YXRlIHRoZSBHcmFwaGljcyByZXF1aXJlZCB0byByZW5kZXIsIGV4Y2x1ZGVzIHNoYWRlciBhbmQgZ2VvbWV0cnkuIEUuZy4sXHJcbiAgICAgICAgICogYmxlbmQgbW9kZSwgY3VsbGluZywgZGVwdGggdGVzdGluZywgZGlyZWN0aW9uIG9mIHJlbmRlcmluZyB0cmlhbmdsZXMsIGJhY2tmYWNlLCBldGMuXHJcbiAgICAgICAgICogQG1lbWJlciB7UElYSS5TdGF0ZX1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGVfMS5TdGF0ZS5mb3IyZCgpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEN1cnJlbnQgZmlsbCBzdHlsZVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQG1lbWJlciB7UElYSS5GaWxsU3R5bGV9XHJcbiAgICAgICAgICogQHByb3RlY3RlZFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuX2ZpbGxTdHlsZSA9IG5ldyBGaWxsU3R5bGVfMS5GaWxsU3R5bGUoKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDdXJyZW50IGxpbmUgc3R5bGVcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuTGluZVN0eWxlfVxyXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLl9saW5lU3R5bGUgPSBuZXcgTGluZVN0eWxlXzEuTGluZVN0eWxlKCk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ3VycmVudCBzaGFwZSB0cmFuc2Zvcm0gbWF0cml4LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQG1lbWJlciB7UElYSS5NYXRyaXh9XHJcbiAgICAgICAgICogQHByb3RlY3RlZFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuX21hdHJpeCA9IG51bGw7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ3VycmVudCBob2xlIG1vZGUgaXMgZW5hYmxlZC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XHJcbiAgICAgICAgICogQGRlZmF1bHQgZmFsc2VcclxuICAgICAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5faG9sZU1vZGUgPSBmYWxzZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDdXJyZW50IHBhdGhcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuUG9seWdvbn1cclxuICAgICAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5jdXJyZW50UGF0aCA9IG51bGw7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogV2hlbiBjYWNoZUFzQml0bWFwIGlzIHNldCB0byB0cnVlIHRoZSBncmFwaGljcyBvYmplY3Qgd2lsbCBiZSByZW5kZXJlZCBhcyBpZiBpdCB3YXMgYSBzcHJpdGUuXHJcbiAgICAgICAgICogVGhpcyBpcyB1c2VmdWwgaWYgeW91ciBncmFwaGljcyBlbGVtZW50IGRvZXMgbm90IGNoYW5nZSBvZnRlbiwgYXMgaXQgd2lsbCBzcGVlZCB1cCB0aGUgcmVuZGVyaW5nXHJcbiAgICAgICAgICogb2YgdGhlIG9iamVjdCBpbiBleGNoYW5nZSBmb3IgdGFraW5nIHVwIHRleHR1cmUgbWVtb3J5LiBJdCBpcyBhbHNvIHVzZWZ1bCBpZiB5b3UgbmVlZCB0aGUgZ3JhcGhpY3NcclxuICAgICAgICAgKiBvYmplY3QgdG8gYmUgYW50aS1hbGlhc2VkLCBiZWNhdXNlIGl0IHdpbGwgYmUgcmVuZGVyZWQgdXNpbmcgY2FudmFzLiBUaGlzIGlzIG5vdCByZWNvbW1lbmRlZCBpZlxyXG4gICAgICAgICAqIHlvdSBhcmUgY29uc3RhbnRseSByZWRyYXdpbmcgdGhlIGdyYXBoaWNzIGVsZW1lbnQuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAbmFtZSBjYWNoZUFzQml0bWFwXHJcbiAgICAgICAgICogQG1lbWJlciB7Ym9vbGVhbn1cclxuICAgICAgICAgKiBAbWVtYmVyb2YgUElYSS5HcmFwaGljcyNcclxuICAgICAgICAgKiBAZGVmYXVsdCBmYWxzZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEEgY29sbGVjdGlvbnMgb2YgYmF0Y2hlcyEgVGhlc2UgY2FuIGJlIGRyYXduIGJ5IHRoZSByZW5kZXJlciBiYXRjaCBzeXN0ZW0uXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgICAgICogQG1lbWJlciB7b2JqZWN0W119XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5iYXRjaGVzID0gW107XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVXBkYXRlIGRpcnR5IGZvciBsaW1pdGluZyBjYWxjdWxhdGluZyB0aW50cyBmb3IgYmF0Y2hlcy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgICAgICogQGRlZmF1bHQgLTFcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmJhdGNoVGludCA9IC0xO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvcHkgb2YgdGhlIG9iamVjdCB2ZXJ0ZXggZGF0YS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAgICAgKiBAbWVtYmVyIHtGbG9hdDMyQXJyYXl9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy52ZXJ0ZXhEYXRhID0gbnVsbDtcclxuICAgICAgICB0aGlzLl90cmFuc2Zvcm1JRCA9IC0xO1xyXG4gICAgICAgIHRoaXMuYmF0Y2hEaXJ0eSA9IC0xO1xyXG4gICAgICAgIC8vIFNldCBkZWZhdWx0XHJcbiAgICAgICAgdGhpcy50aW50ID0gMHhGRkZGRkY7XHJcbiAgICAgICAgdGhpcy5ibGVuZE1vZGUgPSBCbGVuZE1vZGVzU2V0dGluZ3NfMS5CbGVuZE1vZGVzU2V0dGluZ3MuQkxFTkRfTU9ERVMuTk9STUFMO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IEdyYXBoaWNzIG9iamVjdCB3aXRoIHRoZSBzYW1lIHZhbHVlcyBhcyB0aGlzIG9uZS5cclxuICAgICAqIE5vdGUgdGhhdCB0aGUgb25seSB0aGUgcHJvcGVydGllcyBvZiB0aGUgb2JqZWN0IGFyZSBjbG9uZWQsIG5vdCBpdHMgdHJhbnNmb3JtIChwb3NpdGlvbixzY2FsZSxldGMpXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiB7UElYSS5HcmFwaGljc30gQSBjbG9uZSBvZiB0aGUgZ3JhcGhpY3Mgb2JqZWN0XHJcbiAgICAgKi9cclxuICAgIGNsb25lKCkge1xyXG4gICAgICAgIHRoaXMuZmluaXNoUG9seSgpO1xyXG4gICAgICAgIHJldHVybiBuZXcgR3JhcGhpY3ModGhpcy5nZW9tZXRyeSk7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBibGVuZCBtb2RlIHRvIGJlIGFwcGxpZWQgdG8gdGhlIGdyYXBoaWMgc2hhcGUuIEFwcGx5IGEgdmFsdWUgb2ZcclxuICAgICAqIGBQSVhJLkJMRU5EX01PREVTLk5PUk1BTGAgdG8gcmVzZXQgdGhlIGJsZW5kIG1vZGUuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICogQGRlZmF1bHQgUElYSS5CTEVORF9NT0RFUy5OT1JNQUw7XHJcbiAgICAgKiBAc2VlIFBJWEkuQkxFTkRfTU9ERVNcclxuICAgICAqL1xyXG4gICAgc2V0IGJsZW5kTW9kZSh2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuc3RhdGUuYmxlbmRNb2RlID0gdmFsdWU7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICBnZXQgYmxlbmRNb2RlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLmJsZW5kTW9kZTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIHRpbnQgYXBwbGllZCB0byB0aGUgZ3JhcGhpYyBzaGFwZS4gVGhpcyBpcyBhIGhleCB2YWx1ZS4gQSB2YWx1ZSBvZlxyXG4gICAgICogMHhGRkZGRkYgd2lsbCByZW1vdmUgYW55IHRpbnQgZWZmZWN0LlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAqIEBkZWZhdWx0IDB4RkZGRkZGXHJcbiAgICAgKi9cclxuICAgIGdldCB0aW50KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl90aW50O1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgc2V0IHRpbnQodmFsdWUpIHtcclxuICAgICAgICB0aGlzLl90aW50ID0gdmFsdWU7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBjdXJyZW50IGZpbGwgc3R5bGUuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7UElYSS5GaWxsU3R5bGV9XHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqL1xyXG4gICAgZ2V0IGZpbGwoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZpbGxTdHlsZTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGN1cnJlbnQgbGluZSBzdHlsZS5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtQSVhJLkxpbmVTdHlsZX1cclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICovXHJcbiAgICBnZXQgbGluZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbGluZVN0eWxlO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBTcGVjaWZpZXMgdGhlIGxpbmUgc3R5bGUgdXNlZCBmb3Igc3Vic2VxdWVudCBjYWxscyB0byBHcmFwaGljcyBtZXRob2RzIHN1Y2ggYXMgdGhlIGxpbmVUbygpXHJcbiAgICAgKiBtZXRob2Qgb3IgdGhlIGRyYXdDaXJjbGUoKSBtZXRob2QuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt3aWR0aD0wXSAtIHdpZHRoIG9mIHRoZSBsaW5lIHRvIGRyYXcsIHdpbGwgdXBkYXRlIHRoZSBvYmplY3RzIHN0b3JlZCBzdHlsZVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtjb2xvcj0wXSAtIGNvbG9yIG9mIHRoZSBsaW5lIHRvIGRyYXcsIHdpbGwgdXBkYXRlIHRoZSBvYmplY3RzIHN0b3JlZCBzdHlsZVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthbHBoYT0xXSAtIGFscGhhIG9mIHRoZSBsaW5lIHRvIGRyYXcsIHdpbGwgdXBkYXRlIHRoZSBvYmplY3RzIHN0b3JlZCBzdHlsZVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthbGlnbm1lbnQ9MV0gLSBhbGlnbm1lbnQgb2YgdGhlIGxpbmUgdG8gZHJhdywgKDAgPSBpbm5lciwgMC41ID0gbWlkZGxlLCAxID0gb3V0dGVyKVxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbbmF0aXZlPWZhbHNlXSAtIElmIHRydWUgdGhlIGxpbmVzIHdpbGwgYmUgZHJhdyB1c2luZyBMSU5FUyBpbnN0ZWFkIG9mIFRSSUFOR0xFX1NUUklQXHJcbiAgICAgKiBAcmV0dXJuIHtQSVhJLkdyYXBoaWNzfSBUaGlzIEdyYXBoaWNzIG9iamVjdC4gR29vZCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzXHJcbiAgICAgKi9cclxuICAgIGxpbmVTdHlsZSh3aWR0aCwgY29sb3IgPSAwLCBhbHBoYSA9IDEsIGFsaWdubWVudCA9IDAuNSwgbmF0aXZlID0gZmFsc2UpIHtcclxuICAgICAgICBpZiAod2lkdGggPT09IHZvaWQgMCkge1xyXG4gICAgICAgICAgICB3aWR0aCA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjb2xvciA9PT0gdm9pZCAwKSB7XHJcbiAgICAgICAgICAgIGNvbG9yID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGFscGhhID09PSB2b2lkIDApIHtcclxuICAgICAgICAgICAgYWxwaGEgPSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYWxpZ25tZW50ID09PSB2b2lkIDApIHtcclxuICAgICAgICAgICAgYWxpZ25tZW50ID0gMC41O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobmF0aXZlID09PSB2b2lkIDApIHtcclxuICAgICAgICAgICAgbmF0aXZlID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubGluZVRleHR1cmVTdHlsZSh3aWR0aCwgVGV4dHVyZV8xLlRleHR1cmUuV0hJVEUsIGNvbG9yLCBhbHBoYSwgbnVsbCwgYWxpZ25tZW50LCBuYXRpdmUpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBMaWtlIGxpbmUgc3R5bGUgYnV0IHN1cHBvcnQgdGV4dHVyZSBmb3IgbGluZSBmaWxsLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbd2lkdGg9MF0gLSB3aWR0aCBvZiB0aGUgbGluZSB0byBkcmF3LCB3aWxsIHVwZGF0ZSB0aGUgb2JqZWN0cyBzdG9yZWQgc3R5bGVcclxuICAgICAqIEBwYXJhbSB7UElYSS5UZXh0dXJlfSBbdGV4dHVyZT1QSVhJLlRleHR1cmUuV0hJVEVdIC0gVGV4dHVyZSB0byB1c2VcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbY29sb3I9MF0gLSBjb2xvciBvZiB0aGUgbGluZSB0byBkcmF3LCB3aWxsIHVwZGF0ZSB0aGUgb2JqZWN0cyBzdG9yZWQgc3R5bGVcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYWxwaGE9MV0gLSBhbHBoYSBvZiB0aGUgbGluZSB0byBkcmF3LCB3aWxsIHVwZGF0ZSB0aGUgb2JqZWN0cyBzdG9yZWQgc3R5bGVcclxuICAgICAqIEBwYXJhbSB7UElYSS5NYXRyaXh9IFttYXRyaXg9bnVsbF0gVGV4dHVyZSBtYXRyaXggdG8gdHJhbnNmb3JtIHRleHR1cmVcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYWxpZ25tZW50PTAuNV0gLSBhbGlnbm1lbnQgb2YgdGhlIGxpbmUgdG8gZHJhdywgKDAgPSBpbm5lciwgMC41ID0gbWlkZGxlLCAxID0gb3V0dGVyKVxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbbmF0aXZlPWZhbHNlXSAtIElmIHRydWUgdGhlIGxpbmVzIHdpbGwgYmUgZHJhdyB1c2luZyBMSU5FUyBpbnN0ZWFkIG9mIFRSSUFOR0xFX1NUUklQXHJcbiAgICAgKiBAcmV0dXJuIHtQSVhJLkdyYXBoaWNzfSBUaGlzIEdyYXBoaWNzIG9iamVjdC4gR29vZCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzXHJcbiAgICAgKi9cclxuICAgIGxpbmVUZXh0dXJlU3R5bGUod2lkdGggPSAwLCB0ZXh0dXJlID0gVGV4dHVyZV8xLlRleHR1cmUuV0hJVEUsIGNvbG9yID0gMHhGRkZGRkYsIGFscGhhID0gMSwgbWF0cml4ID0gbnVsbCwgYWxpZ25tZW50ID0gMC41LCBuYXRpdmUgPSBmYWxzZSkge1xyXG4gICAgICAgIGlmICh3aWR0aCA9PT0gdm9pZCAwKSB7XHJcbiAgICAgICAgICAgIHdpZHRoID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRleHR1cmUgPT09IHZvaWQgMCkge1xyXG4gICAgICAgICAgICB0ZXh0dXJlID0gVGV4dHVyZV8xLlRleHR1cmUuV0hJVEU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjb2xvciA9PT0gdm9pZCAwKSB7XHJcbiAgICAgICAgICAgIGNvbG9yID0gMHhGRkZGRkY7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChhbHBoYSA9PT0gdm9pZCAwKSB7XHJcbiAgICAgICAgICAgIGFscGhhID0gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG1hdHJpeCA9PT0gdm9pZCAwKSB7XHJcbiAgICAgICAgICAgIG1hdHJpeCA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChhbGlnbm1lbnQgPT09IHZvaWQgMCkge1xyXG4gICAgICAgICAgICBhbGlnbm1lbnQgPSAwLjU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChuYXRpdmUgPT09IHZvaWQgMCkge1xyXG4gICAgICAgICAgICBuYXRpdmUgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFBhdGgpIHtcclxuICAgICAgICAgICAgdGhpcy5zdGFydFBvbHkoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHZpc2libGUgPSB3aWR0aCA+IDAgJiYgYWxwaGEgPiAwO1xyXG4gICAgICAgIGlmICghdmlzaWJsZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9saW5lU3R5bGUucmVzZXQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChtYXRyaXgpIHtcclxuICAgICAgICAgICAgICAgIG1hdHJpeCA9IG1hdHJpeC5jbG9uZSgpO1xyXG4gICAgICAgICAgICAgICAgbWF0cml4LmludmVydCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odGhpcy5fbGluZVN0eWxlLCB7XHJcbiAgICAgICAgICAgICAgICBjb2xvcjogY29sb3IsXHJcbiAgICAgICAgICAgICAgICB3aWR0aDogd2lkdGgsXHJcbiAgICAgICAgICAgICAgICBhbHBoYTogYWxwaGEsXHJcbiAgICAgICAgICAgICAgICBtYXRyaXg6IG1hdHJpeCxcclxuICAgICAgICAgICAgICAgIHRleHR1cmU6IHRleHR1cmUsXHJcbiAgICAgICAgICAgICAgICBhbGlnbm1lbnQ6IGFsaWdubWVudCxcclxuICAgICAgICAgICAgICAgIG5hdGl2ZTogbmF0aXZlLFxyXG4gICAgICAgICAgICAgICAgdmlzaWJsZTogdmlzaWJsZSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBTdGFydCBhIHBvbHlnb24gb2JqZWN0IGludGVybmFsbHlcclxuICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAqL1xyXG4gICAgc3RhcnRQb2x5KCkge1xyXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRQYXRoKSB7XHJcbiAgICAgICAgICAgIHZhciBwb2ludHMgPSB0aGlzLmN1cnJlbnRQYXRoLnBvaW50cztcclxuICAgICAgICAgICAgdmFyIGxlbiA9IHRoaXMuY3VycmVudFBhdGgucG9pbnRzLmxlbmd0aDtcclxuICAgICAgICAgICAgaWYgKGxlbiA+IDIpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NoYXBlKHRoaXMuY3VycmVudFBhdGgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50UGF0aCA9IG5ldyBQb2x5Z29uXzEuUG9seWdvbigpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50UGF0aC5jbG9zZVN0cm9rZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50UGF0aC5wb2ludHMucHVzaChwb2ludHNbbGVuIC0gMl0sIHBvaW50c1tsZW4gLSAxXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFBhdGggPSBuZXcgUG9seWdvbl8xLlBvbHlnb24oKTtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50UGF0aC5jbG9zZVN0cm9rZSA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogRmluaXNoIHRoZSBwb2x5Z29uIG9iamVjdC5cclxuICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAqL1xyXG4gICAgZmluaXNoUG9seSgpIHtcclxuICAgICAgICBpZiAodGhpcy5jdXJyZW50UGF0aCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50UGF0aC5wb2ludHMubGVuZ3RoID4gMikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kcmF3U2hhcGUodGhpcy5jdXJyZW50UGF0aCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRQYXRoID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFBhdGgucG9pbnRzLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIE1vdmVzIHRoZSBjdXJyZW50IGRyYXdpbmcgcG9zaXRpb24gdG8geCwgeS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCAtIHRoZSBYIGNvb3JkaW5hdGUgdG8gbW92ZSB0b1xyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgLSB0aGUgWSBjb29yZGluYXRlIHRvIG1vdmUgdG9cclxuICAgICAqIEByZXR1cm4ge1BJWEkuR3JhcGhpY3N9IFRoaXMgR3JhcGhpY3Mgb2JqZWN0LiBHb29kIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHNcclxuICAgICAqL1xyXG4gICAgbW92ZVRvKHgsIHkpIHtcclxuICAgICAgICB0aGlzLnN0YXJ0UG9seSgpO1xyXG4gICAgICAgIHRoaXMuY3VycmVudFBhdGgucG9pbnRzWzBdID0geDtcclxuICAgICAgICB0aGlzLmN1cnJlbnRQYXRoLnBvaW50c1sxXSA9IHk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIERyYXdzIGEgbGluZSB1c2luZyB0aGUgY3VycmVudCBsaW5lIHN0eWxlIGZyb20gdGhlIGN1cnJlbnQgZHJhd2luZyBwb3NpdGlvbiB0byAoeCwgeSk7XHJcbiAgICAgKiBUaGUgY3VycmVudCBkcmF3aW5nIHBvc2l0aW9uIGlzIHRoZW4gc2V0IHRvICh4LCB5KS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCAtIHRoZSBYIGNvb3JkaW5hdGUgdG8gZHJhdyB0b1xyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgLSB0aGUgWSBjb29yZGluYXRlIHRvIGRyYXcgdG9cclxuICAgICAqIEByZXR1cm4ge1BJWEkuR3JhcGhpY3N9IFRoaXMgR3JhcGhpY3Mgb2JqZWN0LiBHb29kIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHNcclxuICAgICAqL1xyXG4gICAgbGluZVRvKHgsIHkpIHtcclxuICAgICAgICBpZiAoIXRoaXMuY3VycmVudFBhdGgpIHtcclxuICAgICAgICAgICAgdGhpcy5tb3ZlVG8oMCwgMCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHJlbW92ZSBkdXBsaWNhdGVzLi5cclxuICAgICAgICB2YXIgcG9pbnRzID0gdGhpcy5jdXJyZW50UGF0aC5wb2ludHM7XHJcbiAgICAgICAgdmFyIGZyb21YID0gcG9pbnRzW3BvaW50cy5sZW5ndGggLSAyXTtcclxuICAgICAgICB2YXIgZnJvbVkgPSBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDFdO1xyXG4gICAgICAgIGlmIChmcm9tWCAhPT0geCB8fCBmcm9tWSAhPT0geSkge1xyXG4gICAgICAgICAgICBwb2ludHMucHVzaCh4LCB5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIEluaXRpYWxpemUgdGhlIGN1cnZlXHJcbiAgICAgKlxyXG4gICAgICogQHByb3RlY3RlZFxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt4PTBdXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3k9MF1cclxuICAgICAqL1xyXG4gICAgX2luaXRDdXJ2ZSh4ID0gMCwgeSA9IDApIHtcclxuICAgICAgICBpZiAoeCA9PT0gdm9pZCAwKSB7XHJcbiAgICAgICAgICAgIHggPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoeSA9PT0gdm9pZCAwKSB7XHJcbiAgICAgICAgICAgIHkgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5jdXJyZW50UGF0aCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50UGF0aC5wb2ludHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRQYXRoLnBvaW50cyA9IFt4LCB5XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5tb3ZlVG8oeCwgeSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxjdWxhdGUgdGhlIHBvaW50cyBmb3IgYSBxdWFkcmF0aWMgYmV6aWVyIGN1cnZlIGFuZCB0aGVuIGRyYXdzIGl0LlxyXG4gICAgICogQmFzZWQgb246IGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzc4NTA5Ny9ob3ctZG8taS1pbXBsZW1lbnQtYS1iZXppZXItY3VydmUtaW4tY1xyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjcFggLSBDb250cm9sIHBvaW50IHhcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjcFkgLSBDb250cm9sIHBvaW50IHlcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0b1ggLSBEZXN0aW5hdGlvbiBwb2ludCB4XHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdG9ZIC0gRGVzdGluYXRpb24gcG9pbnQgeVxyXG4gICAgICogQHJldHVybiB7UElYSS5HcmFwaGljc30gVGhpcyBHcmFwaGljcyBvYmplY3QuIEdvb2QgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxsc1xyXG4gICAgICovXHJcbiAgICBxdWFkcmF0aWNDdXJ2ZVRvKGNwWCwgY3BZLCB0b1gsIHRvWSkge1xyXG4gICAgICAgIHRoaXMuX2luaXRDdXJ2ZSgpO1xyXG4gICAgICAgIHZhciBwb2ludHMgPSB0aGlzLmN1cnJlbnRQYXRoLnBvaW50cztcclxuICAgICAgICBpZiAocG9pbnRzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICB0aGlzLm1vdmVUbygwLCAwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgUXVhZHJhdGljVXRpbHNfMS5RdWFkcmF0aWNVdGlscy5jdXJ2ZVRvKGNwWCwgY3BZLCB0b1gsIHRvWSwgcG9pbnRzKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQ2FsY3VsYXRlIHRoZSBwb2ludHMgZm9yIGEgYmV6aWVyIGN1cnZlIGFuZCB0aGVuIGRyYXdzIGl0LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjcFggLSBDb250cm9sIHBvaW50IHhcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjcFkgLSBDb250cm9sIHBvaW50IHlcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjcFgyIC0gU2Vjb25kIENvbnRyb2wgcG9pbnQgeFxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNwWTIgLSBTZWNvbmQgQ29udHJvbCBwb2ludCB5XHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdG9YIC0gRGVzdGluYXRpb24gcG9pbnQgeFxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRvWSAtIERlc3RpbmF0aW9uIHBvaW50IHlcclxuICAgICAqIEByZXR1cm4ge1BJWEkuR3JhcGhpY3N9IFRoaXMgR3JhcGhpY3Mgb2JqZWN0LiBHb29kIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHNcclxuICAgICAqL1xyXG4gICAgYmV6aWVyQ3VydmVUbyhjcFgsIGNwWSwgY3BYMiwgY3BZMiwgdG9YLCB0b1kpIHtcclxuICAgICAgICB0aGlzLl9pbml0Q3VydmUoKTtcclxuICAgICAgICBCZXppZXJVdGlsc18xLkJlemllclV0aWxzLmN1cnZlVG8oY3BYLCBjcFksIGNwWDIsIGNwWTIsIHRvWCwgdG9ZLCB0aGlzLmN1cnJlbnRQYXRoLnBvaW50cyk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBhcmNUbygpIG1ldGhvZCBjcmVhdGVzIGFuIGFyYy9jdXJ2ZSBiZXR3ZWVuIHR3byB0YW5nZW50cyBvbiB0aGUgY2FudmFzLlxyXG4gICAgICpcclxuICAgICAqIFwiYm9ycm93ZWRcIiBmcm9tIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvZnhjYW52YXMvIC0gdGhhbmtzIGdvb2dsZSFcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geDEgLSBUaGUgeC1jb29yZGluYXRlIG9mIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGFyY1xyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkxIC0gVGhlIHktY29vcmRpbmF0ZSBvZiB0aGUgYmVnaW5uaW5nIG9mIHRoZSBhcmNcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4MiAtIFRoZSB4LWNvb3JkaW5hdGUgb2YgdGhlIGVuZCBvZiB0aGUgYXJjXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geTIgLSBUaGUgeS1jb29yZGluYXRlIG9mIHRoZSBlbmQgb2YgdGhlIGFyY1xyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJhZGl1cyAtIFRoZSByYWRpdXMgb2YgdGhlIGFyY1xyXG4gICAgICogQHJldHVybiB7UElYSS5HcmFwaGljc30gVGhpcyBHcmFwaGljcyBvYmplY3QuIEdvb2QgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxsc1xyXG4gICAgICovXHJcbiAgICBhcmNUbyh4MSwgeTEsIHgyLCB5MiwgcmFkaXVzKSB7XHJcbiAgICAgICAgdGhpcy5faW5pdEN1cnZlKHgxLCB5MSk7XHJcbiAgICAgICAgdmFyIHBvaW50cyA9IHRoaXMuY3VycmVudFBhdGgucG9pbnRzO1xyXG4gICAgICAgIHZhciByZXN1bHQgPSBBcmNVdGlsc18xLkFyY1V0aWxzLmN1cnZlVG8oeDEsIHkxLCB4MiwgeTIsIHJhZGl1cywgcG9pbnRzKTtcclxuICAgICAgICBpZiAocmVzdWx0KSB7XHJcbiAgICAgICAgICAgIHZhciBjeCA9IHJlc3VsdC5jeDtcclxuICAgICAgICAgICAgdmFyIGN5ID0gcmVzdWx0LmN5O1xyXG4gICAgICAgICAgICB2YXIgcmFkaXVzJDEgPSByZXN1bHQucmFkaXVzO1xyXG4gICAgICAgICAgICB2YXIgc3RhcnRBbmdsZSA9IHJlc3VsdC5zdGFydEFuZ2xlO1xyXG4gICAgICAgICAgICB2YXIgZW5kQW5nbGUgPSByZXN1bHQuZW5kQW5nbGU7XHJcbiAgICAgICAgICAgIHZhciBhbnRpY2xvY2t3aXNlID0gcmVzdWx0LmFudGljbG9ja3dpc2U7XHJcbiAgICAgICAgICAgIHRoaXMuYXJjKGN4LCBjeSwgcmFkaXVzJDEsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBhbnRpY2xvY2t3aXNlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBhcmMgbWV0aG9kIGNyZWF0ZXMgYW4gYXJjL2N1cnZlICh1c2VkIHRvIGNyZWF0ZSBjaXJjbGVzLCBvciBwYXJ0cyBvZiBjaXJjbGVzKS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY3ggLSBUaGUgeC1jb29yZGluYXRlIG9mIHRoZSBjZW50ZXIgb2YgdGhlIGNpcmNsZVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGN5IC0gVGhlIHktY29vcmRpbmF0ZSBvZiB0aGUgY2VudGVyIG9mIHRoZSBjaXJjbGVcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByYWRpdXMgLSBUaGUgcmFkaXVzIG9mIHRoZSBjaXJjbGVcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydEFuZ2xlIC0gVGhlIHN0YXJ0aW5nIGFuZ2xlLCBpbiByYWRpYW5zICgwIGlzIGF0IHRoZSAzIG8nY2xvY2sgcG9zaXRpb25cclxuICAgICAqICBvZiB0aGUgYXJjJ3MgY2lyY2xlKVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZEFuZ2xlIC0gVGhlIGVuZGluZyBhbmdsZSwgaW4gcmFkaWFuc1xyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbYW50aWNsb2Nrd2lzZT1mYWxzZV0gLSBTcGVjaWZpZXMgd2hldGhlciB0aGUgZHJhd2luZyBzaG91bGQgYmVcclxuICAgICAqICBjb3VudGVyLWNsb2Nrd2lzZSBvciBjbG9ja3dpc2UuIEZhbHNlIGlzIGRlZmF1bHQsIGFuZCBpbmRpY2F0ZXMgY2xvY2t3aXNlLCB3aGlsZSB0cnVlXHJcbiAgICAgKiAgaW5kaWNhdGVzIGNvdW50ZXItY2xvY2t3aXNlLlxyXG4gICAgICogQHJldHVybiB7UElYSS5HcmFwaGljc30gVGhpcyBHcmFwaGljcyBvYmplY3QuIEdvb2QgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxsc1xyXG4gICAgICovXHJcbiAgICBhcmMoY3gsIGN5LCByYWRpdXMsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBhbnRpY2xvY2t3aXNlID0gZmFsc2UpIHtcclxuICAgICAgICBpZiAoYW50aWNsb2Nrd2lzZSA9PT0gdm9pZCAwKSB7XHJcbiAgICAgICAgICAgIGFudGljbG9ja3dpc2UgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHN0YXJ0QW5nbGUgPT09IGVuZEFuZ2xlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWFudGljbG9ja3dpc2UgJiYgZW5kQW5nbGUgPD0gc3RhcnRBbmdsZSkge1xyXG4gICAgICAgICAgICBlbmRBbmdsZSArPSBNYXRoU2V0dGluZ3NfMS5NYXRoU2V0dGluZ3MuUElfMjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoYW50aWNsb2Nrd2lzZSAmJiBzdGFydEFuZ2xlIDw9IGVuZEFuZ2xlKSB7XHJcbiAgICAgICAgICAgIHN0YXJ0QW5nbGUgKz0gTWF0aFNldHRpbmdzXzEuTWF0aFNldHRpbmdzLlBJXzI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBzd2VlcCA9IGVuZEFuZ2xlIC0gc3RhcnRBbmdsZTtcclxuICAgICAgICBpZiAoc3dlZXAgPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBzdGFydFggPSBjeCArIChNYXRoLmNvcyhzdGFydEFuZ2xlKSAqIHJhZGl1cyk7XHJcbiAgICAgICAgdmFyIHN0YXJ0WSA9IGN5ICsgKE1hdGguc2luKHN0YXJ0QW5nbGUpICogcmFkaXVzKTtcclxuICAgICAgICAvLyBJZiB0aGUgY3VycmVudFBhdGggZXhpc3RzLCB0YWtlIGl0cyBwb2ludHMuIE90aGVyd2lzZSBjYWxsIGBtb3ZlVG9gIHRvIHN0YXJ0IGEgcGF0aC5cclxuICAgICAgICB2YXIgcG9pbnRzID0gdGhpcy5jdXJyZW50UGF0aCA/IHRoaXMuY3VycmVudFBhdGgucG9pbnRzIDogbnVsbDtcclxuICAgICAgICBpZiAocG9pbnRzKSB7XHJcbiAgICAgICAgICAgIC8vIFRPRE86IG1ha2UgYSBiZXR0ZXIgZml4LlxyXG4gICAgICAgICAgICAvLyBXZSBjaGVjayBob3cgZmFyIG91ciBzdGFydCBpcyBmcm9tIHRoZSBsYXN0IGV4aXN0aW5nIHBvaW50XHJcbiAgICAgICAgICAgIHZhciB4RGlmZiA9IE1hdGguYWJzKHBvaW50c1twb2ludHMubGVuZ3RoIC0gMl0gLSBzdGFydFgpO1xyXG4gICAgICAgICAgICB2YXIgeURpZmYgPSBNYXRoLmFicyhwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDFdIC0gc3RhcnRZKTtcclxuICAgICAgICAgICAgaWYgKHhEaWZmIDwgMC4wMDEgJiYgeURpZmYgPCAwLjAwMSkge1xyXG4gICAgICAgICAgICAgICAgO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goc3RhcnRYLCBzdGFydFkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLm1vdmVUbyhzdGFydFgsIHN0YXJ0WSk7XHJcbiAgICAgICAgICAgIHBvaW50cyA9IHRoaXMuY3VycmVudFBhdGgucG9pbnRzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBBcmNVdGlsc18xLkFyY1V0aWxzLmFyYyhzdGFydFgsIHN0YXJ0WSwgY3gsIGN5LCByYWRpdXMsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBhbnRpY2xvY2t3aXNlLCBwb2ludHMpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBTcGVjaWZpZXMgYSBzaW1wbGUgb25lLWNvbG9yIGZpbGwgdGhhdCBzdWJzZXF1ZW50IGNhbGxzIHRvIG90aGVyIEdyYXBoaWNzIG1ldGhvZHNcclxuICAgICAqIChzdWNoIGFzIGxpbmVUbygpIG9yIGRyYXdDaXJjbGUoKSkgdXNlIHdoZW4gZHJhd2luZy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2NvbG9yPTBdIC0gdGhlIGNvbG9yIG9mIHRoZSBmaWxsXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FscGhhPTFdIC0gdGhlIGFscGhhIG9mIHRoZSBmaWxsXHJcbiAgICAgKiBAcmV0dXJuIHtQSVhJLkdyYXBoaWNzfSBUaGlzIEdyYXBoaWNzIG9iamVjdC4gR29vZCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzXHJcbiAgICAgKi9cclxuICAgIGJlZ2luRmlsbChjb2xvciA9IDAsIGFscGhhID0gMSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmJlZ2luVGV4dHVyZUZpbGwoVGV4dHVyZV8xLlRleHR1cmUuV0hJVEUsIGNvbG9yLCBhbHBoYSk7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIEJlZ2luIHRoZSB0ZXh0dXJlIGZpbGxcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1BJWEkuVGV4dHVyZX0gW3RleHR1cmU9UElYSS5UZXh0dXJlLldISVRFXSAtIFRleHR1cmUgdG8gZmlsbFxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtjb2xvcj0weGZmZmZmZl0gLSBCYWNrZ3JvdW5kIHRvIGZpbGwgYmVoaW5kIHRleHR1cmVcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYWxwaGE9MV0gLSBBbHBoYSBvZiBmaWxsXHJcbiAgICAgKiBAcGFyYW0ge1BJWEkuTWF0cml4fSBbbWF0cml4PW51bGxdIC0gVHJhbnNmb3JtIG1hdHJpeFxyXG4gICAgICogQHJldHVybiB7UElYSS5HcmFwaGljc30gVGhpcyBHcmFwaGljcyBvYmplY3QuIEdvb2QgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxsc1xyXG4gICAgICovXHJcbiAgICBiZWdpblRleHR1cmVGaWxsKHRleHR1cmUsIGNvbG9yLCBhbHBoYSwgbWF0cml4ID0gbnVsbCkge1xyXG4gICAgICAgIGlmICh0ZXh0dXJlID09PSB2b2lkIDApIHtcclxuICAgICAgICAgICAgdGV4dHVyZSA9IFRleHR1cmVfMS5UZXh0dXJlLldISVRFO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY29sb3IgPT09IHZvaWQgMCkge1xyXG4gICAgICAgICAgICBjb2xvciA9IDB4RkZGRkZGO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYWxwaGEgPT09IHZvaWQgMCkge1xyXG4gICAgICAgICAgICBhbHBoYSA9IDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChtYXRyaXggPT09IHZvaWQgMCkge1xyXG4gICAgICAgICAgICBtYXRyaXggPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5jdXJyZW50UGF0aCkge1xyXG4gICAgICAgICAgICB0aGlzLnN0YXJ0UG9seSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgdmlzaWJsZSA9IGFscGhhID4gMDtcclxuICAgICAgICBpZiAoIXZpc2libGUpIHtcclxuICAgICAgICAgICAgdGhpcy5fZmlsbFN0eWxlLnJlc2V0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAobWF0cml4KSB7XHJcbiAgICAgICAgICAgICAgICBtYXRyaXggPSBtYXRyaXguY2xvbmUoKTtcclxuICAgICAgICAgICAgICAgIG1hdHJpeC5pbnZlcnQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMuX2ZpbGxTdHlsZSwge1xyXG4gICAgICAgICAgICAgICAgY29sb3I6IGNvbG9yLFxyXG4gICAgICAgICAgICAgICAgYWxwaGE6IGFscGhhLFxyXG4gICAgICAgICAgICAgICAgdGV4dHVyZTogdGV4dHVyZSxcclxuICAgICAgICAgICAgICAgIG1hdHJpeDogbWF0cml4LFxyXG4gICAgICAgICAgICAgICAgdmlzaWJsZTogdmlzaWJsZSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBsaWVzIGEgZmlsbCB0byB0aGUgbGluZXMgYW5kIHNoYXBlcyB0aGF0IHdlcmUgYWRkZWQgc2luY2UgdGhlIGxhc3QgY2FsbCB0byB0aGUgYmVnaW5GaWxsKCkgbWV0aG9kLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4ge1BJWEkuR3JhcGhpY3N9IFRoaXMgR3JhcGhpY3Mgb2JqZWN0LiBHb29kIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHNcclxuICAgICAqL1xyXG4gICAgZW5kRmlsbCgpIHtcclxuICAgICAgICB0aGlzLmZpbmlzaFBvbHkoKTtcclxuICAgICAgICB0aGlzLl9maWxsU3R5bGUucmVzZXQoKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogRHJhd3MgYSByZWN0YW5nbGUgc2hhcGUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggLSBUaGUgWCBjb29yZCBvZiB0aGUgdG9wLWxlZnQgb2YgdGhlIHJlY3RhbmdsZVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgLSBUaGUgWSBjb29yZCBvZiB0aGUgdG9wLWxlZnQgb2YgdGhlIHJlY3RhbmdsZVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIC0gVGhlIHdpZHRoIG9mIHRoZSByZWN0YW5nbGVcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgLSBUaGUgaGVpZ2h0IG9mIHRoZSByZWN0YW5nbGVcclxuICAgICAqIEByZXR1cm4ge1BJWEkuR3JhcGhpY3N9IFRoaXMgR3JhcGhpY3Mgb2JqZWN0LiBHb29kIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHNcclxuICAgICAqL1xyXG4gICAgZHJhd1JlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRyYXdTaGFwZShuZXcgUmVjdGFuZ2xlXzEuUmVjdGFuZ2xlKHgsIHksIHdpZHRoLCBoZWlnaHQpKTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogRHJhdyBhIHJlY3RhbmdsZSBzaGFwZSB3aXRoIHJvdW5kZWQvYmV2ZWxlZCBjb3JuZXJzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gVGhlIFggY29vcmQgb2YgdGhlIHRvcC1sZWZ0IG9mIHRoZSByZWN0YW5nbGVcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gVGhlIFkgY29vcmQgb2YgdGhlIHRvcC1sZWZ0IG9mIHRoZSByZWN0YW5nbGVcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCAtIFRoZSB3aWR0aCBvZiB0aGUgcmVjdGFuZ2xlXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IC0gVGhlIGhlaWdodCBvZiB0aGUgcmVjdGFuZ2xlXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcmFkaXVzIC0gUmFkaXVzIG9mIHRoZSByZWN0YW5nbGUgY29ybmVyc1xyXG4gICAgICogQHJldHVybiB7UElYSS5HcmFwaGljc30gVGhpcyBHcmFwaGljcyBvYmplY3QuIEdvb2QgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxsc1xyXG4gICAgICovXHJcbiAgICBkcmF3Um91bmRlZFJlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCwgcmFkaXVzKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZHJhd1NoYXBlKG5ldyBSb3VuZGVkUmVjdGFuZ2xlXzEuUm91bmRlZFJlY3RhbmdsZSh4LCB5LCB3aWR0aCwgaGVpZ2h0LCByYWRpdXMpKTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogRHJhd3MgYSBjaXJjbGUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggLSBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBjZW50ZXIgb2YgdGhlIGNpcmNsZVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgLSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBjZW50ZXIgb2YgdGhlIGNpcmNsZVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJhZGl1cyAtIFRoZSByYWRpdXMgb2YgdGhlIGNpcmNsZVxyXG4gICAgICogQHJldHVybiB7UElYSS5HcmFwaGljc30gVGhpcyBHcmFwaGljcyBvYmplY3QuIEdvb2QgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxsc1xyXG4gICAgICovXHJcbiAgICBkcmF3Q2lyY2xlKHgsIHksIHJhZGl1cykge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRyYXdTaGFwZShuZXcgQ2lyY2xlXzEuQ2lyY2xlKHgsIHksIHJhZGl1cykpO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBEcmF3cyBhbiBlbGxpcHNlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgY2VudGVyIG9mIHRoZSBlbGxpcHNlXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSAtIFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIGNlbnRlciBvZiB0aGUgZWxsaXBzZVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIC0gVGhlIGhhbGYgd2lkdGggb2YgdGhlIGVsbGlwc2VcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgLSBUaGUgaGFsZiBoZWlnaHQgb2YgdGhlIGVsbGlwc2VcclxuICAgICAqIEByZXR1cm4ge1BJWEkuR3JhcGhpY3N9IFRoaXMgR3JhcGhpY3Mgb2JqZWN0LiBHb29kIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHNcclxuICAgICAqL1xyXG4gICAgZHJhd0VsbGlwc2UoeCwgeSwgd2lkdGgsIGhlaWdodCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRyYXdTaGFwZShuZXcgRWxsaXBzZV8xLkVsbGlwc2UoeCwgeSwgd2lkdGgsIGhlaWdodCkpO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBEcmF3cyBhIHBvbHlnb24gdXNpbmcgdGhlIGdpdmVuIHBhdGguXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJbXXxQSVhJLlBvaW50W118UElYSS5Qb2x5Z29ufSBwYXRoIC0gVGhlIHBhdGggZGF0YSB1c2VkIHRvIGNvbnN0cnVjdCB0aGUgcG9seWdvbi5cclxuICAgICAqIEByZXR1cm4ge1BJWEkuR3JhcGhpY3N9IFRoaXMgR3JhcGhpY3Mgb2JqZWN0LiBHb29kIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHNcclxuICAgICAqL1xyXG4gICAgZHJhd1BvbHlnb24ocGF0aCkge1xyXG4gICAgICAgIHZhciBhcmd1bWVudHMkMSA9IGFyZ3VtZW50cztcclxuICAgICAgICAvLyBwcmV2ZW50cyBhbiBhcmd1bWVudCBhc3NpZ25tZW50IGRlb3B0XHJcbiAgICAgICAgLy8gc2VlIHNlY3Rpb24gMy4xOiBodHRwczovL2dpdGh1Yi5jb20vcGV0a2FhbnRvbm92L2JsdWViaXJkL3dpa2kvT3B0aW1pemF0aW9uLWtpbGxlcnMjMy1tYW5hZ2luZy1hcmd1bWVudHNcclxuICAgICAgICB2YXIgcG9pbnRzID0gcGF0aDtcclxuICAgICAgICB2YXIgY2xvc2VTdHJva2UgPSB0cnVlOyAvLyAhIXRoaXMuX2ZpbGxTdHlsZTtcclxuICAgICAgICAvLyBjaGVjayBpZiBkYXRhIGhhcyBwb2ludHMuLlxyXG4gICAgICAgIGlmIChwb2ludHMucG9pbnRzKSB7XHJcbiAgICAgICAgICAgIGNsb3NlU3Ryb2tlID0gcG9pbnRzLmNsb3NlU3Ryb2tlO1xyXG4gICAgICAgICAgICBwb2ludHMgPSBwb2ludHMucG9pbnRzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkocG9pbnRzKSkge1xyXG4gICAgICAgICAgICAvLyBwcmV2ZW50cyBhbiBhcmd1bWVudCBsZWFrIGRlb3B0XHJcbiAgICAgICAgICAgIC8vIHNlZSBzZWN0aW9uIDMuMjogaHR0cHM6Ly9naXRodWIuY29tL3BldGthYW50b25vdi9ibHVlYmlyZC93aWtpL09wdGltaXphdGlvbi1raWxsZXJzIzMtbWFuYWdpbmctYXJndW1lbnRzXHJcbiAgICAgICAgICAgIHBvaW50cyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgICAgIHBvaW50c1tpXSA9IGFyZ3VtZW50cyQxW2ldOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHByZWZlci1yZXN0LXBhcmFtc1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBzaGFwZSA9IG5ldyBQb2x5Z29uXzEuUG9seWdvbihwb2ludHMpO1xyXG4gICAgICAgIHNoYXBlLmNsb3NlU3Ryb2tlID0gY2xvc2VTdHJva2U7XHJcbiAgICAgICAgdGhpcy5kcmF3U2hhcGUoc2hhcGUpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBEcmF3IGFueSBzaGFwZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1BJWEkuQ2lyY2xlfFBJWEkuRWxsaXBzZXxQSVhJLlBvbHlnb258UElYSS5SZWN0YW5nbGV8UElYSS5Sb3VuZGVkUmVjdGFuZ2xlfSBzaGFwZSAtIFNoYXBlIHRvIGRyYXdcclxuICAgICAqIEByZXR1cm4ge1BJWEkuR3JhcGhpY3N9IFRoaXMgR3JhcGhpY3Mgb2JqZWN0LiBHb29kIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHNcclxuICAgICAqL1xyXG4gICAgZHJhd1NoYXBlKHNoYXBlKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9ob2xlTW9kZSkge1xyXG4gICAgICAgICAgICB0aGlzLmdlb21ldHJ5LmRyYXdTaGFwZShzaGFwZSwgdGhpcy5fZmlsbFN0eWxlLmNsb25lKCksIHRoaXMuX2xpbmVTdHlsZS5jbG9uZSgpLCB0aGlzLl9tYXRyaXgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5nZW9tZXRyeS5kcmF3SG9sZShzaGFwZSwgdGhpcy5fbWF0cml4KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIERyYXcgYSBzdGFyIHNoYXBlIHdpdGggYW4gYXJiaXRyYXJ5IG51bWJlciBvZiBwb2ludHMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggLSBDZW50ZXIgWCBwb3NpdGlvbiBvZiB0aGUgc3RhclxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgLSBDZW50ZXIgWSBwb3NpdGlvbiBvZiB0aGUgc3RhclxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBvaW50cyAtIFRoZSBudW1iZXIgb2YgcG9pbnRzIG9mIHRoZSBzdGFyLCBtdXN0IGJlID4gMVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJhZGl1cyAtIFRoZSBvdXRlciByYWRpdXMgb2YgdGhlIHN0YXJcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbaW5uZXJSYWRpdXNdIC0gVGhlIGlubmVyIHJhZGl1cyBiZXR3ZWVuIHBvaW50cywgZGVmYXVsdCBoYWxmIGByYWRpdXNgXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3JvdGF0aW9uPTBdIC0gVGhlIHJvdGF0aW9uIG9mIHRoZSBzdGFyIGluIHJhZGlhbnMsIHdoZXJlIDAgaXMgdmVydGljYWxcclxuICAgICAqIEByZXR1cm4ge1BJWEkuR3JhcGhpY3N9IFRoaXMgR3JhcGhpY3Mgb2JqZWN0LiBHb29kIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHNcclxuICAgICAqL1xyXG4gICAgZHJhd1N0YXIoeCwgeSwgcG9pbnRzLCByYWRpdXMsIGlubmVyUmFkaXVzID0gMCwgcm90YXRpb24gPSAwKSB7XHJcbiAgICAgICAgaWYgKHJvdGF0aW9uID09PSB2b2lkIDApIHtcclxuICAgICAgICAgICAgcm90YXRpb24gPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5kcmF3UG9seWdvbihuZXcgU3Rhcl8xLlN0YXIoeCwgeSwgcG9pbnRzLCByYWRpdXMsIGlubmVyUmFkaXVzLCByb3RhdGlvbikpO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDbGVhcnMgdGhlIGdyYXBoaWNzIHRoYXQgd2VyZSBkcmF3biB0byB0aGlzIEdyYXBoaWNzIG9iamVjdCwgYW5kIHJlc2V0cyBmaWxsIGFuZCBsaW5lIHN0eWxlIHNldHRpbmdzLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4ge1BJWEkuR3JhcGhpY3N9IFRoaXMgR3JhcGhpY3Mgb2JqZWN0LiBHb29kIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHNcclxuICAgICAqL1xyXG4gICAgY2xlYXIoKSB7XHJcbiAgICAgICAgdGhpcy5nZW9tZXRyeS5jbGVhcigpO1xyXG4gICAgICAgIHRoaXMuX21hdHJpeCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5faG9sZU1vZGUgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmN1cnJlbnRQYXRoID0gbnVsbDtcclxuICAgICAgICB0aGlzLl9zcHJpdGVSZWN0ID0gbnVsbDtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogVHJ1ZSBpZiBncmFwaGljcyBjb25zaXN0cyBvZiBvbmUgcmVjdGFuZ2xlLCBhbmQgdGh1cywgY2FuIGJlIGRyYXduIGxpa2UgYSBTcHJpdGUgYW5kXHJcbiAgICAgKiBtYXNrZWQgd2l0aCBnbC5zY2lzc29yLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIG9ubHkgMSByZWN0LlxyXG4gICAgICovXHJcbiAgICBpc0Zhc3RSZWN0KCkge1xyXG4gICAgICAgIC8vIHdpbGwgZml4IHRoaXMhXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIC8vIHRoaXMuZ3JhcGhpY3NEYXRhLmxlbmd0aCA9PT0gMVxyXG4gICAgICAgIC8vICAmJiB0aGlzLmdyYXBoaWNzRGF0YVswXS5zaGFwZS50eXBlID09PSBTSEFQRVMuUkVDVFxyXG4gICAgICAgIC8vICYmICF0aGlzLmdyYXBoaWNzRGF0YVswXS5saW5lV2lkdGg7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFJlbmRlcnMgdGhlIG9iamVjdCB1c2luZyB0aGUgV2ViR0wgcmVuZGVyZXJcclxuICAgICAqXHJcbiAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgKiBAcGFyYW0ge1BJWEkuUmVuZGVyZXJ9IHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyXHJcbiAgICAgKi9cclxuICAgIF9yZW5kZXIocmVuZGVyZXIpIHtcclxuICAgICAgICB0aGlzLmZpbmlzaFBvbHkoKTtcclxuICAgICAgICB2YXIgZ2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5O1xyXG4gICAgICAgIC8vIGJhdGNoIHBhcnQuLlxyXG4gICAgICAgIC8vIGJhdGNoIGl0IVxyXG4gICAgICAgIGdlb21ldHJ5LnVwZGF0ZUJhdGNoZXMoKTtcclxuICAgICAgICBpZiAoZ2VvbWV0cnkuYmF0Y2hhYmxlKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmJhdGNoRGlydHkgIT09IGdlb21ldHJ5LmJhdGNoRGlydHkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYmF0Y2hlcyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5iYXRjaFRpbnQgPSAtMTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3RyYW5zZm9ybUlEID0gLTE7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmJhdGNoRGlydHkgPSBnZW9tZXRyeS5iYXRjaERpcnR5O1xyXG4gICAgICAgICAgICAgICAgdGhpcy52ZXJ0ZXhEYXRhID0gbmV3IEZsb2F0MzJBcnJheShnZW9tZXRyeS5wb2ludHMpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGJsZW5kTW9kZSA9IHRoaXMuYmxlbmRNb2RlO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBnZW9tZXRyeS5iYXRjaGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGdJID0gZ2VvbWV0cnkuYmF0Y2hlc1tpXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY29sb3IgPSBnSS5zdHlsZS5jb2xvcjtcclxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgKyAoYWxwaGEgKiAyNTUgPDwgMjQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB2ZXJ0ZXhEYXRhID0gbmV3IEZsb2F0MzJBcnJheSh0aGlzLnZlcnRleERhdGEuYnVmZmVyLCBnSS5hdHRyaWJTdGFydCAqIDQgKiAyLCBnSS5hdHRyaWJTaXplICogMik7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHV2cyA9IG5ldyBGbG9hdDMyQXJyYXkoZ2VvbWV0cnkudXZzRmxvYXQzMi5idWZmZXIsIGdJLmF0dHJpYlN0YXJ0ICogNCAqIDIsIGdJLmF0dHJpYlNpemUgKiAyKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaW5kaWNlcyA9IG5ldyBVaW50MTZBcnJheShnZW9tZXRyeS5pbmRpY2VzVWludDE2LmJ1ZmZlciwgZ0kuc3RhcnQgKiAyLCBnSS5zaXplKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYmF0Y2ggPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlcnRleERhdGE6IHZlcnRleERhdGEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJsZW5kTW9kZTogYmxlbmRNb2RlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRpY2VzOiBpbmRpY2VzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB1dnM6IHV2cyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2JhdGNoUkdCOiBDb2xvclNldHRpbmdzXzEuQ29sb3JTZXR0aW5ncy5oZXgycmdiKGNvbG9yKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RpbnRSR0I6IGNvbG9yLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGV4dHVyZTogZ0kuc3R5bGUudGV4dHVyZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWxwaGE6IGdJLnN0eWxlLmFscGhhLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB3b3JsZEFscGhhOiAxXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmJhdGNoZXNbaV0gPSBiYXRjaDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZW5kZXJlci5iYXRjaC5zZXRPYmplY3RSZW5kZXJlcihyZW5kZXJlci5wbHVnaW5zLmJhdGNoKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuYmF0Y2hlcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2FsY3VsYXRlVmVydGljZXMoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2FsY3VsYXRlVGludHMoKTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IHRoaXMuYmF0Y2hlcy5sZW5ndGg7IGkkMSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJhdGNoJDEgPSB0aGlzLmJhdGNoZXNbaSQxXTtcclxuICAgICAgICAgICAgICAgICAgICBiYXRjaCQxLndvcmxkQWxwaGEgPSB0aGlzLndvcmxkQWxwaGEgKiBiYXRjaCQxLmFscGhhO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbmRlcmVyLnBsdWdpbnMuYmF0Y2gucmVuZGVyKGJhdGNoJDEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBubyBiYXRjaGluZy4uLlxyXG4gICAgICAgICAgICByZW5kZXJlci5iYXRjaC5mbHVzaCgpO1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuc2hhZGVyKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGVyZSBpcyBubyBzaGFkZXIgaGVyZSwgd2UgY2FuIHVzZSB0aGUgZGVmYXVsdCBzaGFkZXIuXHJcbiAgICAgICAgICAgICAgICAvLyBhbmQgdGhhdCBvbmx5IGdldHMgY3JlYXRlZCBpZiB3ZSBhY3R1YWxseSBuZWVkIGl0Li5cclxuICAgICAgICAgICAgICAgIGlmICghR3JhcGhpY3MuZGVmYXVsdFNoYWRlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzYW1wbGVWYWx1ZXMgPSBuZXcgSW50MzJBcnJheSgxNik7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSQyID0gMDsgaSQyIDwgMTY7IGkkMisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNhbXBsZVZhbHVlc1tpJDJdID0gaSQyO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB2YXIgdW5pZm9ybXMgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbnQ6IG5ldyBGbG9hdDMyQXJyYXkoWzEsIDEsIDEsIDFdKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNsYXRpb25NYXRyaXg6IG5ldyBNYXRyaXhfMS5NYXRyaXgoKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDogVW5pZm9ybUdyb3VwXzEuVW5pZm9ybUdyb3VwLmZyb20oeyB1U2FtcGxlcnM6IHNhbXBsZVZhbHVlcyB9LCB0cnVlKSxcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHdlIGNhbiBiYmFzZSBkZWZhdWx0IHNoYWRlciBvZiB0aGUgYmF0Y2ggcmVuZGVyZXJzIHByb2dyYW1cclxuICAgICAgICAgICAgICAgICAgICB2YXIgcHJvZ3JhbSA9IHJlbmRlcmVyLnBsdWdpbnMuYmF0Y2guc2hhZGVyLnByb2dyYW07XHJcbiAgICAgICAgICAgICAgICAgICAgR3JhcGhpY3MuZGVmYXVsdFNoYWRlciA9IG5ldyBTaGFkZXJfMS5TaGFkZXIocHJvZ3JhbSwgdW5pZm9ybXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5zaGFkZXIgPSBHcmFwaGljcy5kZWZhdWx0U2hhZGVyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciB1bmlmb3JtcyQxID0gdGhpcy5zaGFkZXIudW5pZm9ybXM7XHJcbiAgICAgICAgICAgIC8vIGxldHMgc2V0IHRoZSB0cmFuc2ZvbXJcclxuICAgICAgICAgICAgdW5pZm9ybXMkMS50cmFuc2xhdGlvbk1hdHJpeCA9IHRoaXMudHJhbnNmb3JtLndvcmxkVHJhbnNmb3JtO1xyXG4gICAgICAgICAgICB2YXIgdGludCA9IHRoaXMudGludDtcclxuICAgICAgICAgICAgdmFyIHdhID0gdGhpcy53b3JsZEFscGhhO1xyXG4gICAgICAgICAgICAvLyBhbmQgdGhlbiBsZXRzIHNldCB0aGUgdGludC4uXHJcbiAgICAgICAgICAgIHVuaWZvcm1zJDEudGludFswXSA9ICgoKHRpbnQgPj4gMTYpICYgMHhGRikgLyAyNTUpICogd2E7XHJcbiAgICAgICAgICAgIHVuaWZvcm1zJDEudGludFsxXSA9ICgoKHRpbnQgPj4gOCkgJiAweEZGKSAvIDI1NSkgKiB3YTtcclxuICAgICAgICAgICAgdW5pZm9ybXMkMS50aW50WzJdID0gKCh0aW50ICYgMHhGRikgLyAyNTUpICogd2E7XHJcbiAgICAgICAgICAgIHVuaWZvcm1zJDEudGludFszXSA9IHdhO1xyXG4gICAgICAgICAgICAvLyB0aGUgZmlyc3QgZHJhdyBjYWxsLCB3ZSBjYW4gc2V0IHRoZSB1bmlmb3JtcyBvZiB0aGUgc2hhZGVyIGRpcmVjdGx5IGhlcmUuXHJcbiAgICAgICAgICAgIC8vIHRoaXMgbWVhbnMgdGhhdCB3ZSBjYW4gdGFjayBhZHZhbnRhZ2Ugb2YgdGhlIHN5bmMgZnVuY3Rpb24gb2YgcGl4aSFcclxuICAgICAgICAgICAgLy8gYmluZCBhbmQgc3luYyB1bmlmb3Jtcy4uXHJcbiAgICAgICAgICAgIC8vIHRoZXJlIGlzIGEgd2F5IHRvIG9wdGltaXNlIHRoaXMuLlxyXG4gICAgICAgICAgICByZW5kZXJlci5zaGFkZXIuYmluZCh0aGlzLnNoYWRlcik7XHJcbiAgICAgICAgICAgIC8vIHRoZW4gcmVuZGVyIGl0XHJcbiAgICAgICAgICAgIHJlbmRlcmVyLmdlb21ldHJ5LmJpbmQoZ2VvbWV0cnksIHRoaXMuc2hhZGVyKTtcclxuICAgICAgICAgICAgLy8gc2V0IHN0YXRlLi5cclxuICAgICAgICAgICAgcmVuZGVyZXIuc3RhdGUuc2V0U3RhdGUodGhpcy5zdGF0ZSk7XHJcbiAgICAgICAgICAgIC8vIHRoZW4gcmVuZGVyIHRoZSByZXN0IG9mIHRoZW0uLi5cclxuICAgICAgICAgICAgZm9yICh2YXIgaSQzID0gMDsgaSQzIDwgZ2VvbWV0cnkuZHJhd0NhbGxzLmxlbmd0aDsgaSQzKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBkcmF3Q2FsbCA9IGdlb21ldHJ5LmRyYXdDYWxsc1tpJDNdO1xyXG4gICAgICAgICAgICAgICAgdmFyIGdyb3VwVGV4dHVyZUNvdW50ID0gZHJhd0NhbGwudGV4dHVyZUNvdW50O1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBncm91cFRleHR1cmVDb3VudDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyZXIudGV4dHVyZS5iaW5kKGRyYXdDYWxsLnRleHR1cmVzW2pdLCBqKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIGJpbmQgdGhlIGdlb21ldHJ5Li4uXHJcbiAgICAgICAgICAgICAgICByZW5kZXJlci5nZW9tZXRyeS5kcmF3KGRyYXdDYWxsLnR5cGUsIGRyYXdDYWxsLnNpemUsIGRyYXdDYWxsLnN0YXJ0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogUmV0cmlldmVzIHRoZSBib3VuZHMgb2YgdGhlIGdyYXBoaWMgc2hhcGUgYXMgYSByZWN0YW5nbGUgb2JqZWN0XHJcbiAgICAgKlxyXG4gICAgICogQHByb3RlY3RlZFxyXG4gICAgICovXHJcbiAgICBfY2FsY3VsYXRlQm91bmRzKCkge1xyXG4gICAgICAgIHRoaXMuZmluaXNoUG9seSgpO1xyXG4gICAgICAgIHZhciBsYiA9IHRoaXMuZ2VvbWV0cnkuYm91bmRzO1xyXG4gICAgICAgIHRoaXMuX2JvdW5kcy5hZGRGcmFtZSh0aGlzLnRyYW5zZm9ybSwgbGIubWluWCwgbGIubWluWSwgbGIubWF4WCwgbGIubWF4WSk7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFRlc3RzIGlmIGEgcG9pbnQgaXMgaW5zaWRlIHRoaXMgZ3JhcGhpY3Mgb2JqZWN0XHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtQSVhJLlBvaW50fSBwb2ludCAtIHRoZSBwb2ludCB0byB0ZXN0XHJcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSB0aGUgcmVzdWx0IG9mIHRoZSB0ZXN0XHJcbiAgICAgKi9cclxuICAgIGNvbnRhaW5zUG9pbnQocG9pbnQpIHtcclxuICAgICAgICB0aGlzLndvcmxkVHJhbnNmb3JtLmFwcGx5SW52ZXJzZShwb2ludCwgR3JhcGhpY3MuX1RFTVBfUE9JTlQpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdlb21ldHJ5LmNvbnRhaW5zUG9pbnQoR3JhcGhpY3MuX1RFTVBfUE9JTlQpO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZWNhbGN1YXRlIHRoZSB0aW50IGJ5IGFwcGx5aW5nIHRpbiB0byBiYXRjaGVzIHVzaW5nIEdyYXBoaWNzIHRpbnQuXHJcbiAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgKi9cclxuICAgIGNhbGN1bGF0ZVRpbnRzKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmJhdGNoVGludCAhPT0gdGhpcy50aW50KSB7XHJcbiAgICAgICAgICAgIHRoaXMuYmF0Y2hUaW50ID0gdGhpcy50aW50O1xyXG4gICAgICAgICAgICB2YXIgdGludFJHQiA9IENvbG9yU2V0dGluZ3NfMS5Db2xvclNldHRpbmdzLmhleDJyZ2IodGhpcy50aW50LCBHcmFwaGljcy50ZW1wKTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmJhdGNoZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBiYXRjaCA9IHRoaXMuYmF0Y2hlc1tpXTtcclxuICAgICAgICAgICAgICAgIHZhciBiYXRjaFRpbnQgPSBiYXRjaC5fYmF0Y2hSR0I7XHJcbiAgICAgICAgICAgICAgICB2YXIgciA9ICh0aW50UkdCWzBdICogYmF0Y2hUaW50WzBdKSAqIDI1NTtcclxuICAgICAgICAgICAgICAgIHZhciBnID0gKHRpbnRSR0JbMV0gKiBiYXRjaFRpbnRbMV0pICogMjU1O1xyXG4gICAgICAgICAgICAgICAgdmFyIGIgPSAodGludFJHQlsyXSAqIGJhdGNoVGludFsyXSkgKiAyNTU7XHJcbiAgICAgICAgICAgICAgICAvLyBUT0RPIEl2YW4sIGNhbiB0aGlzIGJlIGRvbmUgaW4gb25lIGdvP1xyXG4gICAgICAgICAgICAgICAgdmFyIGNvbG9yID0gKHIgPDwgMTYpICsgKGcgPDwgOCkgKyAoYiB8IDApO1xyXG4gICAgICAgICAgICAgICAgYmF0Y2guX3RpbnRSR0IgPSAoY29sb3IgPj4gMTYpXHJcbiAgICAgICAgICAgICAgICAgICAgKyAoY29sb3IgJiAweGZmMDApXHJcbiAgICAgICAgICAgICAgICAgICAgKyAoKGNvbG9yICYgMHhmZikgPDwgMTYpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBJZiB0aGVyZSdzIGEgdHJhbnNmb3JtIHVwZGF0ZSBvciBhIGNoYW5nZSB0byB0aGUgc2hhcGUgb2YgdGhlXHJcbiAgICAgKiBnZW9tZXRyeSwgcmVjYWN1bGF0ZSB0aGUgdmVydGljZXMuXHJcbiAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgKi9cclxuICAgIGNhbGN1bGF0ZVZlcnRpY2VzKCkge1xyXG4gICAgICAgIGlmICh0aGlzLl90cmFuc2Zvcm1JRCA9PT0gdGhpcy50cmFuc2Zvcm0uX3dvcmxkSUQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl90cmFuc2Zvcm1JRCA9IHRoaXMudHJhbnNmb3JtLl93b3JsZElEO1xyXG4gICAgICAgIHZhciB3dCA9IHRoaXMudHJhbnNmb3JtLndvcmxkVHJhbnNmb3JtO1xyXG4gICAgICAgIC8vIHJldmVhbCh3dClcclxuICAgICAgICB2YXIgYSA9IHd0LmE7XHJcbiAgICAgICAgdmFyIGIgPSB3dC5iO1xyXG4gICAgICAgIHZhciBjID0gd3QuYztcclxuICAgICAgICB2YXIgZCA9IHd0LmQ7XHJcbiAgICAgICAgdmFyIHR4ID0gd3QudHg7XHJcbiAgICAgICAgdmFyIHR5ID0gd3QudHk7XHJcbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLmdlb21ldHJ5LnBvaW50czsgLy8gYmF0Y2gudmVydGV4RGF0YU9yaWdpbmFsO1xyXG4gICAgICAgIHZhciB2ZXJ0ZXhEYXRhID0gdGhpcy52ZXJ0ZXhEYXRhO1xyXG4gICAgICAgIHZhciBjb3VudCA9IDA7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSArPSAyKSB7XHJcbiAgICAgICAgICAgIHZhciB4ID0gZGF0YVtpXTtcclxuICAgICAgICAgICAgdmFyIHkgPSBkYXRhW2kgKyAxXTtcclxuICAgICAgICAgICAgdmVydGV4RGF0YVtjb3VudCsrXSA9IChhICogeCkgKyAoYyAqIHkpICsgdHg7XHJcbiAgICAgICAgICAgIHZlcnRleERhdGFbY291bnQrK10gPSAoZCAqIHkpICsgKGIgKiB4KSArIHR5O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQ2xvc2VzIHRoZSBjdXJyZW50IHBhdGguXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiB7UElYSS5HcmFwaGljc30gUmV0dXJucyBpdHNlbGYuXHJcbiAgICAgKi9cclxuICAgIGNsb3NlUGF0aCgpIHtcclxuICAgICAgICB2YXIgY3VycmVudFBhdGggPSB0aGlzLmN1cnJlbnRQYXRoO1xyXG4gICAgICAgIGlmIChjdXJyZW50UGF0aCkge1xyXG4gICAgICAgICAgICAvLyB3ZSBkb24ndCBuZWVkIHRvIGFkZCBleHRyYSBwb2ludCBpbiB0aGUgZW5kIGJlY2F1c2UgYnVpbGRMaW5lIHdpbGwgdGFrZSBjYXJlIG9mIHRoYXRcclxuICAgICAgICAgICAgY3VycmVudFBhdGguY2xvc2VTdHJva2UgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQXBwbHkgYSBtYXRyaXggdG8gdGhlIHBvc2l0aW9uYWwgZGF0YS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1BJWEkuTWF0cml4fSBtYXRyaXggLSBNYXRyaXggdG8gdXNlIGZvciB0cmFuc2Zvcm0gY3VycmVudCBzaGFwZS5cclxuICAgICAqIEByZXR1cm4ge1BJWEkuR3JhcGhpY3N9IFJldHVybnMgaXRzZWxmLlxyXG4gICAgICovXHJcbiAgICBzZXRNYXRyaXgobWF0cml4KSB7XHJcbiAgICAgICAgdGhpcy5fbWF0cml4ID0gbWF0cml4O1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBCZWdpbiBhZGRpbmcgaG9sZXMgdG8gdGhlIGxhc3QgZHJhdyBzaGFwZVxyXG4gICAgICogSU1QT1JUQU5UOiBob2xlcyBtdXN0IGJlIGZ1bGx5IGluc2lkZSBhIHNoYXBlIHRvIHdvcmtcclxuICAgICAqIEFsc28gd2VpcmRuZXNzIGVuc3VlcyBpZiBob2xlcyBvdmVybGFwIVxyXG4gICAgICogRWxsaXBzZXMsIENpcmNsZXMsIFJlY3RhbmdsZXMgYW5kIFJvdW5kZWQgUmVjdGFuZ2xlcyBjYW5ub3QgYmUgaG9sZXMgb3IgaG9zdCBmb3IgaG9sZXMgaW4gQ2FudmFzUmVuZGVyZXIsXHJcbiAgICAgKiBwbGVhc2UgdXNlIGBtb3ZlVG9gIGBsaW5lVG9gLCBgcXVhZHJhdGljQ3VydmVUb2AgaWYgeW91IHJlbHkgb24gcGl4aS1sZWdhY3kgYnVuZGxlLlxyXG4gICAgICogQHJldHVybiB7UElYSS5HcmFwaGljc30gUmV0dXJucyBpdHNlbGYuXHJcbiAgICAgKi9cclxuICAgIGJlZ2luSG9sZSgpIHtcclxuICAgICAgICB0aGlzLmZpbmlzaFBvbHkoKTtcclxuICAgICAgICB0aGlzLl9ob2xlTW9kZSA9IHRydWU7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIEVuZCBhZGRpbmcgaG9sZXMgdG8gdGhlIGxhc3QgZHJhdyBzaGFwZVxyXG4gICAgICogQHJldHVybiB7UElYSS5HcmFwaGljc30gUmV0dXJucyBpdHNlbGYuXHJcbiAgICAgKi9cclxuICAgIGVuZEhvbGUoKSB7XHJcbiAgICAgICAgdGhpcy5maW5pc2hQb2x5KCk7XHJcbiAgICAgICAgdGhpcy5faG9sZU1vZGUgPSBmYWxzZTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogRGVzdHJveXMgdGhlIEdyYXBoaWNzIG9iamVjdC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdHxib29sZWFufSBbb3B0aW9uc10gLSBPcHRpb25zIHBhcmFtZXRlci4gQSBib29sZWFuIHdpbGwgYWN0IGFzIGlmIGFsbFxyXG4gICAgICogIG9wdGlvbnMgaGF2ZSBiZWVuIHNldCB0byB0aGF0IHZhbHVlXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmNoaWxkcmVuPWZhbHNlXSAtIGlmIHNldCB0byB0cnVlLCBhbGwgdGhlIGNoaWxkcmVuIHdpbGwgaGF2ZVxyXG4gICAgICogIHRoZWlyIGRlc3Ryb3kgbWV0aG9kIGNhbGxlZCBhcyB3ZWxsLiAnb3B0aW9ucycgd2lsbCBiZSBwYXNzZWQgb24gdG8gdGhvc2UgY2FsbHMuXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRleHR1cmU9ZmFsc2VdIC0gT25seSB1c2VkIGZvciBjaGlsZCBTcHJpdGVzIGlmIG9wdGlvbnMuY2hpbGRyZW4gaXMgc2V0IHRvIHRydWVcclxuICAgICAqICBTaG91bGQgaXQgZGVzdHJveSB0aGUgdGV4dHVyZSBvZiB0aGUgY2hpbGQgc3ByaXRlXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmJhc2VUZXh0dXJlPWZhbHNlXSAtIE9ubHkgdXNlZCBmb3IgY2hpbGQgU3ByaXRlcyBpZiBvcHRpb25zLmNoaWxkcmVuIGlzIHNldCB0byB0cnVlXHJcbiAgICAgKiAgU2hvdWxkIGl0IGRlc3Ryb3kgdGhlIGJhc2UgdGV4dHVyZSBvZiB0aGUgY2hpbGQgc3ByaXRlXHJcbiAgICAgKi9cclxuICAgIGRlc3Ryb3kob3B0aW9ucykge1xyXG4gICAgICAgIHN1cGVyLmRlc3Ryb3kob3B0aW9ucyk7XHJcbiAgICAgICAgdGhpcy5nZW9tZXRyeS5yZWZDb3VudC0tO1xyXG4gICAgICAgIGlmICh0aGlzLmdlb21ldHJ5LnJlZkNvdW50ID09PSAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZ2VvbWV0cnkuZGlzcG9zZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9tYXRyaXggPSBudWxsO1xyXG4gICAgICAgIHRoaXMuY3VycmVudFBhdGggPSBudWxsO1xyXG4gICAgICAgIHRoaXMuX2xpbmVTdHlsZS5kZXN0cm95KCk7XHJcbiAgICAgICAgdGhpcy5fbGluZVN0eWxlID0gbnVsbDtcclxuICAgICAgICB0aGlzLl9maWxsU3R5bGUuZGVzdHJveSgpO1xyXG4gICAgICAgIHRoaXMuX2ZpbGxTdHlsZSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5nZW9tZXRyeSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5zaGFkZXIgPSBudWxsO1xyXG4gICAgICAgIHRoaXMudmVydGV4RGF0YSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5iYXRjaGVzLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgdGhpcy5iYXRjaGVzID0gbnVsbDtcclxuICAgICAgICBzdXBlci5kZXN0cm95KG9wdGlvbnMpO1xyXG4gICAgfVxyXG4gICAgO1xyXG59XHJcbkdyYXBoaWNzLnRlbXAgPSBuZXcgRmxvYXQzMkFycmF5KFsxLCAxLCAxXSk7XHJcbkdyYXBoaWNzLmRlZmF1bHRTaGFkZXIgPSBudWxsO1xyXG4vKipcclxuKiBUZW1wb3JhcnkgcG9pbnQgdG8gdXNlIGZvciBjb250YWluc1BvaW50XHJcbipcclxuKiBAc3RhdGljXHJcbiogQHByaXZhdGVcclxuKiBAbWVtYmVyIHtQSVhJLlBvaW50fVxyXG4qL1xyXG5HcmFwaGljcy5fVEVNUF9QT0lOVCA9IG5ldyBQb2ludF8xLlBvaW50KCk7XHJcbmV4cG9ydHMuR3JhcGhpY3MgPSBHcmFwaGljcztcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY2xhc3MgR3JhcGhpY3NEYXRhIHtcclxuICAgIGNvbnN0cnVjdG9yKHNoYXBlLCBmaWxsU3R5bGUgPSBudWxsLCBsaW5lU3R5bGUgPSBudWxsLCBtYXRyaXggPSBudWxsKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIHNoYXBlIG9iamVjdCB0byBkcmF3LlxyXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuQ2lyY2xlfFBJWEkuRWxsaXBzZXxQSVhJLlBvbHlnb258UElYSS5SZWN0YW5nbGV8UElYSS5Sb3VuZGVkUmVjdGFuZ2xlfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuc2hhcGUgPSBzaGFwZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgc3R5bGUgb2YgdGhlIGxpbmUuXHJcbiAgICAgICAgICogQG1lbWJlciB7UElYSS5MaW5lU3R5bGV9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5saW5lU3R5bGUgPSBsaW5lU3R5bGU7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIHN0eWxlIG9mIHRoZSBmaWxsLlxyXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuRmlsbFN0eWxlfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuZmlsbFN0eWxlID0gZmlsbFN0eWxlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSB0cmFuc2Zvcm0gbWF0cml4LlxyXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuTWF0cml4fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMubWF0cml4ID0gbWF0cml4O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSB0eXBlIG9mIHRoZSBzaGFwZSwgc2VlIHRoZSBDb25zdC5TaGFwZXMgZmlsZSBmb3IgYWxsIHRoZSBleGlzdGluZyB0eXBlcyxcclxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy50eXBlID0gc2hhcGUudHlwZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgY29sbGVjdGlvbiBvZiBwb2ludHMuXHJcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyW119XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5wb2ludHMgPSBbXTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgY29sbGVjdGlvbiBvZiBob2xlcy5cclxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLkdyYXBoaWNzRGF0YVtdfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuaG9sZXMgPSBbXTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBHcmFwaGljc0RhdGEgb2JqZWN0IHdpdGggdGhlIHNhbWUgdmFsdWVzIGFzIHRoaXMgb25lLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4ge1BJWEkuR3JhcGhpY3NEYXRhfSBDbG9uZWQgR3JhcGhpY3NEYXRhIG9iamVjdFxyXG4gICAgICovXHJcbiAgICBjbG9uZSgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IEdyYXBoaWNzRGF0YSh0aGlzLnNoYXBlLCB0aGlzLmZpbGxTdHlsZSwgdGhpcy5saW5lU3R5bGUsIHRoaXMubWF0cml4KTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogRGVzdHJveXMgdGhlIEdyYXBoaWNzIGRhdGEuXHJcbiAgICAgKi9cclxuICAgIGRlc3Ryb3koKSB7XHJcbiAgICAgICAgdGhpcy5zaGFwZSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5ob2xlcy5sZW5ndGggPSAwO1xyXG4gICAgICAgIHRoaXMuaG9sZXMgPSBudWxsO1xyXG4gICAgICAgIHRoaXMucG9pbnRzLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgdGhpcy5wb2ludHMgPSBudWxsO1xyXG4gICAgICAgIHRoaXMubGluZVN0eWxlID0gbnVsbDtcclxuICAgICAgICB0aGlzLmZpbGxTdHlsZSA9IG51bGw7XHJcbiAgICB9XHJcbiAgICA7XHJcbn1cclxuZXhwb3J0cy5HcmFwaGljc0RhdGEgPSBHcmFwaGljc0RhdGE7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IEJhdGNoR2VvbWV0cnlfMSA9IHJlcXVpcmUoXCIuL0JhdGNoR2VvbWV0cnlcIik7XHJcbmNvbnN0IEJvdW5kc18xID0gcmVxdWlyZShcIi4vQm91bmRzXCIpO1xyXG5jb25zdCBHcmFwaGljc0RhdGFfMSA9IHJlcXVpcmUoXCIuL0dyYXBoaWNzRGF0YVwiKTtcclxuY29uc3QgQmFzZVRleHR1cmVfMSA9IHJlcXVpcmUoXCIuL0Jhc2VUZXh0dXJlXCIpO1xyXG5jb25zdCBCYXRjaERyYXdDYWxsXzEgPSByZXF1aXJlKFwiLi9CYXRjaERyYXdDYWxsXCIpO1xyXG5jb25zdCBQb2ludF8xID0gcmVxdWlyZShcIi4vUG9pbnRcIik7XHJcbmNvbnN0IFNoYXBlU2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL1NoYXBlU2V0dGluZ3NcIik7XHJcbmNvbnN0IERyYXdNb2RlU2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL0RyYXdNb2RlU2V0dGluZ3NcIik7XHJcbmNvbnN0IENvbG9yU2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL0NvbG9yU2V0dGluZ3NcIik7XHJcbmNsYXNzIEJhdGNoUGFydCB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLnN0eWxlID0gbnVsbDtcclxuICAgICAgICB0aGlzLnNpemUgPSAwO1xyXG4gICAgICAgIHRoaXMuc3RhcnQgPSAwO1xyXG4gICAgICAgIHRoaXMuYXR0cmliU3RhcnQgPSAwO1xyXG4gICAgICAgIHRoaXMuYXR0cmliU2l6ZSA9IDA7XHJcbiAgICB9XHJcbn1cclxuY2xhc3MgR3JhcGhpY3NHZW9tZXRyeSBleHRlbmRzIEJhdGNoR2VvbWV0cnlfMS5CYXRjaEdlb21ldHJ5IHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQW4gYXJyYXkgb2YgcG9pbnRzIHRvIGRyYXdcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuUG9pbnRbXX1cclxuICAgICAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5wb2ludHMgPSBbXTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgY29sbGVjdGlvbiBvZiBjb2xvcnNcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcltdfVxyXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmNvbG9ycyA9IFtdO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBVVnMgY29sbGVjdGlvblxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyW119XHJcbiAgICAgICAgICogQHByb3RlY3RlZFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMudXZzID0gW107XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGluZGljZXMgb2YgdGhlIHZlcnRpY2VzXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJbXX1cclxuICAgICAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5pbmRpY2VzID0gW107XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmVmZXJlbmNlIHRvIHRoZSB0ZXh0dXJlIElEcy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcltdfVxyXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnRleHR1cmVJZHMgPSBbXTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgY29sbGVjdGlvbiBvZiBkcmF3biBzaGFwZXMuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLkdyYXBoaWNzRGF0YVtdfVxyXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmdyYXBoaWNzRGF0YSA9IFtdO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFVzZWQgdG8gZGV0ZWN0IGlmIHRoZSBncmFwaGljcyBvYmplY3QgaGFzIGNoYW5nZWQuIElmIHRoaXMgaXMgc2V0IHRvIHRydWUgdGhlbiB0aGUgZ3JhcGhpY3NcclxuICAgICAgICAgKiBvYmplY3Qgd2lsbCBiZSByZWNhbGN1bGF0ZWQuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgICAgICogQHByb3RlY3RlZFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuZGlydHkgPSAwO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEJhdGNoZXMgbmVlZCB0byByZWdlbmVyYXRlZCBpZiB0aGUgZ2VvbWV0cnkgaXMgdXBkYXRlZC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5iYXRjaERpcnR5ID0gLTE7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVXNlZCB0byBjaGVjayBpZiB0aGUgY2FjaGUgaXMgZGlydHkuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgICAgICogQHByb3RlY3RlZFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuY2FjaGVEaXJ0eSA9IC0xO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFVzZWQgdG8gZGV0ZWN0IGlmIHdlIGNsZWFyIHRoZSBncmFwaGljcyBXZWJHTCBkYXRhLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICAgICAqIEBkZWZhdWx0IDBcclxuICAgICAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5jbGVhckRpcnR5ID0gMDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBMaXN0IG9mIGN1cnJlbnQgZHJhdyBjYWxscyBkcml2ZWQgZnJvbSB0aGUgYmF0Y2hlcy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBtZW1iZXIge29iamVjdFtdfVxyXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmRyYXdDYWxscyA9IFtdO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEludGVybWVkaWF0ZSBhYnN0cmFjdCBmb3JtYXQgc2VudCB0byBiYXRjaCBzeXN0ZW0uXHJcbiAgICAgICAgICogQ2FuIGJlIGNvbnZlcnRlZCB0byBkcmF3Q2FsbHMgb3IgdG8gYmF0Y2hhYmxlIG9iamVjdHMuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAbWVtYmVyIHtvYmplY3RbXX1cclxuICAgICAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5iYXRjaGVzID0gW107XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSW5kZXggb2YgdGhlIGN1cnJlbnQgbGFzdCBzaGFwZSBpbiB0aGUgc3RhY2sgb2YgY2FsbHMuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgICAgICogQHByb3RlY3RlZFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuc2hhcGVJbmRleCA9IDA7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2FjaGVkIGJvdW5kcy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuQm91bmRzfVxyXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLl9ib3VuZHMgPSBuZXcgQm91bmRzXzEuQm91bmRzKCk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGJvdW5kcyBkaXJ0eSBmbGFnLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmJvdW5kc0RpcnR5ID0gLTE7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUGFkZGluZyB0byBhZGQgdG8gdGhlIGJvdW5kcy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAgICAgKiBAZGVmYXVsdCAwXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5ib3VuZHNQYWRkaW5nID0gMDtcclxuICAgICAgICB0aGlzLmJhdGNoYWJsZSA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuaW5kaWNlc1VpbnQxNiA9IG51bGw7XHJcbiAgICAgICAgdGhpcy51dnNGbG9hdDMyID0gbnVsbDtcclxuICAgIH1cclxuICAgIHN0YXRpYyBnZXRGaWxsQ29tbWFuZCh0eXBlKSB7XHJcbiAgICAgICAgaWYgKCFHcmFwaGljc0dlb21ldHJ5LmZpbGxDb21tYW5kcykge1xyXG4gICAgICAgICAgICBHcmFwaGljc0dlb21ldHJ5LmZpbGxDb21tYW5kcyA9IHt9O1xyXG4gICAgICAgICAgICBHcmFwaGljc0dlb21ldHJ5LmZpbGxDb21tYW5kc1tTaGFwZVNldHRpbmdzXzEuU2hhcGVTZXR0aW5ncy5TSEFQRVMuUE9MWV0gPSBHcmFwaGljc0dlb21ldHJ5LmJ1aWxkUG9seTtcclxuICAgICAgICAgICAgR3JhcGhpY3NHZW9tZXRyeS5maWxsQ29tbWFuZHNbU2hhcGVTZXR0aW5nc18xLlNoYXBlU2V0dGluZ3MuU0hBUEVTLkNJUkNdID0gR3JhcGhpY3NHZW9tZXRyeS5idWlsZENpcmNsZTtcclxuICAgICAgICAgICAgR3JhcGhpY3NHZW9tZXRyeS5maWxsQ29tbWFuZHNbU2hhcGVTZXR0aW5nc18xLlNoYXBlU2V0dGluZ3MuU0hBUEVTLkVMSVBdID0gR3JhcGhpY3NHZW9tZXRyeS5idWlsZENpcmNsZTtcclxuICAgICAgICAgICAgR3JhcGhpY3NHZW9tZXRyeS5maWxsQ29tbWFuZHNbU2hhcGVTZXR0aW5nc18xLlNoYXBlU2V0dGluZ3MuU0hBUEVTLlJFQ1RdID0gR3JhcGhpY3NHZW9tZXRyeS5idWlsZFJlY3RhbmdsZTtcclxuICAgICAgICAgICAgR3JhcGhpY3NHZW9tZXRyeS5maWxsQ29tbWFuZHNbU2hhcGVTZXR0aW5nc18xLlNoYXBlU2V0dGluZ3MuU0hBUEVTLlJSRUNdID0gR3JhcGhpY3NHZW9tZXRyeS5idWlsZFJvdW5kZWRSZWN0YW5nbGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBHcmFwaGljc0dlb21ldHJ5LmZpbGxDb21tYW5kc1t0eXBlXTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBjdXJyZW50IGJvdW5kcyBvZiB0aGUgZ3JhcGhpYyBnZW9tZXRyeS5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtQSVhJLkJvdW5kc31cclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICovXHJcbiAgICBnZXQgYm91bmRzKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmJvdW5kc0RpcnR5ICE9PSB0aGlzLmRpcnR5KSB7XHJcbiAgICAgICAgICAgIHRoaXMuYm91bmRzRGlydHkgPSB0aGlzLmRpcnR5O1xyXG4gICAgICAgICAgICB0aGlzLmNhbGN1bGF0ZUJvdW5kcygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5fYm91bmRzO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDbGVhcnMgdGhlIGdyYXBoaWNzIHRoYXQgd2VyZSBkcmF3biB0byB0aGlzIEdyYXBoaWNzIG9iamVjdCwgYW5kIHJlc2V0cyBmaWxsIGFuZCBsaW5lIHN0eWxlIHNldHRpbmdzLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4ge1BJWEkuR3JhcGhpY3NHZW9tZXRyeX0gVGhpcyBHcmFwaGljc0dlb21ldHJ5IG9iamVjdC4gR29vZCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzXHJcbiAgICAgKi9cclxuICAgIGNsZWFyKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmdyYXBoaWNzRGF0YS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYm91bmRzRGlydHkgPSAtMTtcclxuICAgICAgICAgICAgdGhpcy5kaXJ0eSsrO1xyXG4gICAgICAgICAgICB0aGlzLmNsZWFyRGlydHkrKztcclxuICAgICAgICAgICAgdGhpcy5iYXRjaERpcnR5Kys7XHJcbiAgICAgICAgICAgIHRoaXMuZ3JhcGhpY3NEYXRhLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuc2hhcGVJbmRleCA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMucG9pbnRzLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuY29sb3JzLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMudXZzLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuaW5kaWNlcy5sZW5ndGggPSAwO1xyXG4gICAgICAgICAgICB0aGlzLnRleHR1cmVJZHMubGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmRyYXdDYWxscy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kcmF3Q2FsbHNbaV0udGV4dHVyZXMubGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgICAgIEdyYXBoaWNzR2VvbWV0cnkuRFJBV19DQUxMX1BPT0wucHVzaCh0aGlzLmRyYXdDYWxsc1tpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5kcmF3Q2FsbHMubGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgdGhpcy5iYXRjaGVzLmxlbmd0aDsgaSQxKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBiYXRjaCA9IHRoaXMuYmF0Y2hlc1tpJDFdO1xyXG4gICAgICAgICAgICAgICAgYmF0Y2guc3RhcnQgPSAwO1xyXG4gICAgICAgICAgICAgICAgYmF0Y2guYXR0cmliU3RhcnQgPSAwO1xyXG4gICAgICAgICAgICAgICAgYmF0Y2guc3R5bGUgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgR3JhcGhpY3NHZW9tZXRyeS5CQVRDSF9QT09MLnB1c2goYmF0Y2gpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuYmF0Y2hlcy5sZW5ndGggPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogRHJhd3MgdGhlIGdpdmVuIHNoYXBlIHRvIHRoaXMgR3JhcGhpY3Mgb2JqZWN0LiBDYW4gYmUgYW55IG9mIENpcmNsZSwgUmVjdGFuZ2xlLCBFbGxpcHNlLCBMaW5lIG9yIFBvbHlnb24uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtQSVhJLkNpcmNsZXxQSVhJLkVsbGlwc2V8UElYSS5Qb2x5Z29ufFBJWEkuUmVjdGFuZ2xlfFBJWEkuUm91bmRlZFJlY3RhbmdsZX0gc2hhcGUgLSBUaGUgc2hhcGUgb2JqZWN0IHRvIGRyYXcuXHJcbiAgICAgKiBAcGFyYW0ge1BJWEkuRmlsbFN0eWxlfSBmaWxsU3R5bGUgLSBEZWZpbmVzIHN0eWxlIG9mIHRoZSBmaWxsLlxyXG4gICAgICogQHBhcmFtIHtQSVhJLkxpbmVTdHlsZX0gbGluZVN0eWxlIC0gRGVmaW5lcyBzdHlsZSBvZiB0aGUgbGluZXMuXHJcbiAgICAgKiBAcGFyYW0ge1BJWEkuTWF0cml4fSBtYXRyaXggLSBUcmFuc2Zvcm0gYXBwbGllZCB0byB0aGUgcG9pbnRzIG9mIHRoZSBzaGFwZS5cclxuICAgICAqIEByZXR1cm4ge1BJWEkuR3JhcGhpY3NHZW9tZXRyeX0gUmV0dXJucyBnZW9tZXRyeSBmb3IgY2hhaW5pbmcuXHJcbiAgICAgKi9cclxuICAgIGRyYXdTaGFwZShzaGFwZSwgZmlsbFN0eWxlLCBsaW5lU3R5bGUsIG1hdHJpeCkge1xyXG4gICAgICAgIHZhciBkYXRhID0gbmV3IEdyYXBoaWNzRGF0YV8xLkdyYXBoaWNzRGF0YShzaGFwZSwgZmlsbFN0eWxlLCBsaW5lU3R5bGUsIG1hdHJpeCk7XHJcbiAgICAgICAgdGhpcy5ncmFwaGljc0RhdGEucHVzaChkYXRhKTtcclxuICAgICAgICB0aGlzLmRpcnR5Kys7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIERyYXdzIHRoZSBnaXZlbiBzaGFwZSB0byB0aGlzIEdyYXBoaWNzIG9iamVjdC4gQ2FuIGJlIGFueSBvZiBDaXJjbGUsIFJlY3RhbmdsZSwgRWxsaXBzZSwgTGluZSBvciBQb2x5Z29uLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7UElYSS5DaXJjbGV8UElYSS5FbGxpcHNlfFBJWEkuUG9seWdvbnxQSVhJLlJlY3RhbmdsZXxQSVhJLlJvdW5kZWRSZWN0YW5nbGV9IHNoYXBlIC0gVGhlIHNoYXBlIG9iamVjdCB0byBkcmF3LlxyXG4gICAgICogQHBhcmFtIHtQSVhJLk1hdHJpeH0gbWF0cml4IC0gVHJhbnNmb3JtIGFwcGxpZWQgdG8gdGhlIHBvaW50cyBvZiB0aGUgc2hhcGUuXHJcbiAgICAgKiBAcmV0dXJuIHtQSVhJLkdyYXBoaWNzR2VvbWV0cnl9IFJldHVybnMgZ2VvbWV0cnkgZm9yIGNoYWluaW5nLlxyXG4gICAgICovXHJcbiAgICBkcmF3SG9sZShzaGFwZSwgbWF0cml4KSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmdyYXBoaWNzRGF0YS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBkYXRhID0gbmV3IEdyYXBoaWNzRGF0YV8xLkdyYXBoaWNzRGF0YShzaGFwZSwgbnVsbCwgbnVsbCwgbWF0cml4KTtcclxuICAgICAgICB2YXIgbGFzdFNoYXBlID0gdGhpcy5ncmFwaGljc0RhdGFbdGhpcy5ncmFwaGljc0RhdGEubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgZGF0YS5saW5lU3R5bGUgPSBsYXN0U2hhcGUubGluZVN0eWxlO1xyXG4gICAgICAgIGxhc3RTaGFwZS5ob2xlcy5wdXNoKGRhdGEpO1xyXG4gICAgICAgIHRoaXMuZGlydHkrKztcclxuICAgICAgICByZXR1cm4gZGF0YTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogRGVzdHJveXMgdGhlIEdyYXBoaWNzIG9iamVjdC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdHxib29sZWFufSBbb3B0aW9uc10gLSBPcHRpb25zIHBhcmFtZXRlci4gQSBib29sZWFuIHdpbGwgYWN0IGFzIGlmIGFsbFxyXG4gICAgICogIG9wdGlvbnMgaGF2ZSBiZWVuIHNldCB0byB0aGF0IHZhbHVlXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmNoaWxkcmVuPWZhbHNlXSAtIGlmIHNldCB0byB0cnVlLCBhbGwgdGhlIGNoaWxkcmVuIHdpbGwgaGF2ZVxyXG4gICAgICogIHRoZWlyIGRlc3Ryb3kgbWV0aG9kIGNhbGxlZCBhcyB3ZWxsLiAnb3B0aW9ucycgd2lsbCBiZSBwYXNzZWQgb24gdG8gdGhvc2UgY2FsbHMuXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRleHR1cmU9ZmFsc2VdIC0gT25seSB1c2VkIGZvciBjaGlsZCBTcHJpdGVzIGlmIG9wdGlvbnMuY2hpbGRyZW4gaXMgc2V0IHRvIHRydWVcclxuICAgICAqICBTaG91bGQgaXQgZGVzdHJveSB0aGUgdGV4dHVyZSBvZiB0aGUgY2hpbGQgc3ByaXRlXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmJhc2VUZXh0dXJlPWZhbHNlXSAtIE9ubHkgdXNlZCBmb3IgY2hpbGQgU3ByaXRlcyBpZiBvcHRpb25zLmNoaWxkcmVuIGlzIHNldCB0byB0cnVlXHJcbiAgICAgKiAgU2hvdWxkIGl0IGRlc3Ryb3kgdGhlIGJhc2UgdGV4dHVyZSBvZiB0aGUgY2hpbGQgc3ByaXRlXHJcbiAgICAgKi9cclxuICAgIGRlc3Ryb3kob3B0aW9ucykge1xyXG4gICAgICAgIHN1cGVyLmRlc3Ryb3kob3B0aW9ucyk7XHJcbiAgICAgICAgLy8gZGVzdHJveSBlYWNoIG9mIHRoZSBHcmFwaGljc0RhdGEgb2JqZWN0c1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5ncmFwaGljc0RhdGEubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgdGhpcy5ncmFwaGljc0RhdGFbaV0uZGVzdHJveSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnBvaW50cy5sZW5ndGggPSAwO1xyXG4gICAgICAgIHRoaXMucG9pbnRzID0gbnVsbDtcclxuICAgICAgICB0aGlzLmNvbG9ycy5sZW5ndGggPSAwO1xyXG4gICAgICAgIHRoaXMuY29sb3JzID0gbnVsbDtcclxuICAgICAgICB0aGlzLnV2cy5sZW5ndGggPSAwO1xyXG4gICAgICAgIHRoaXMudXZzID0gbnVsbDtcclxuICAgICAgICB0aGlzLmluZGljZXMubGVuZ3RoID0gMDtcclxuICAgICAgICB0aGlzLmluZGljZXMgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuaW5kZXhCdWZmZXIuZGVzdHJveSgpO1xyXG4gICAgICAgIHRoaXMuaW5kZXhCdWZmZXIgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuZ3JhcGhpY3NEYXRhLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgdGhpcy5ncmFwaGljc0RhdGEgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuZHJhd0NhbGxzLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgdGhpcy5kcmF3Q2FsbHMgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuYmF0Y2hlcy5sZW5ndGggPSAwO1xyXG4gICAgICAgIHRoaXMuYmF0Y2hlcyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5fYm91bmRzID0gbnVsbDtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2sgdG8gc2VlIGlmIGEgcG9pbnQgaXMgY29udGFpbmVkIHdpdGhpbiB0aGlzIGdlb21ldHJ5LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7UElYSS5Qb2ludH0gcG9pbnQgLSBQb2ludCB0byBjaGVjayBpZiBpdCdzIGNvbnRhaW5lZC5cclxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgcG9pbnQgaXMgY29udGFpbmVkIHdpdGhpbiBnZW9tZXRyeS5cclxuICAgICAqL1xyXG4gICAgY29udGFpbnNQb2ludChwb2ludCkge1xyXG4gICAgICAgIHZhciBncmFwaGljc0RhdGEgPSB0aGlzLmdyYXBoaWNzRGF0YTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdyYXBoaWNzRGF0YS5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICB2YXIgZGF0YSA9IGdyYXBoaWNzRGF0YVtpXTtcclxuICAgICAgICAgICAgaWYgKCFkYXRhLmZpbGxTdHlsZS52aXNpYmxlKSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBvbmx5IGRlYWwgd2l0aCBmaWxscy4uXHJcbiAgICAgICAgICAgIGlmIChkYXRhLnNoYXBlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZGF0YS5zaGFwZS5jb250YWlucyhwb2ludC54LCBwb2ludC55KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhLmhvbGVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGRhdGEuaG9sZXMubGVuZ3RoOyBpJDErKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGhvbGUgPSBkYXRhLmhvbGVzW2kkMV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaG9sZS5zaGFwZS5jb250YWlucyhwb2ludC54LCBwb2ludC55KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIEdlbmVyYXRlcyBpbnRlcm1lZGlhdGUgYmF0Y2ggZGF0YS4gRWl0aGVyIGdldHMgY29udmVydGVkIHRvIGRyYXdDYWxsc1xyXG4gICAgICogb3IgdXNlZCB0byBjb252ZXJ0IHRvIGJhdGNoIG9iamVjdHMgZGlyZWN0bHkgYnkgdGhlIEdyYXBoaWNzIG9iamVjdC5cclxuICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAqL1xyXG4gICAgdXBkYXRlQmF0Y2hlcygpIHtcclxuICAgICAgICBpZiAodGhpcy5kaXJ0eSA9PT0gdGhpcy5jYWNoZURpcnR5KSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuZ3JhcGhpY3NEYXRhLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmRpcnR5ICE9PSB0aGlzLmNhY2hlRGlydHkpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmdyYXBoaWNzRGF0YS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGRhdGEgPSB0aGlzLmdyYXBoaWNzRGF0YVtpXTtcclxuICAgICAgICAgICAgICAgIC8vIHJldmVhbChkYXRhLmZpbGxTdHlsZS50ZXh0dXJlLmJhc2VUZXh0dXJlLnJlc291cmNlKTtcclxuICAgICAgICAgICAgICAgIC8vIHJldmVhbChkYXRhLmxpbmVTdHlsZS50ZXh0dXJlLmJhc2VUZXh0dXJlLnJlc291cmNlKTtcclxuICAgICAgICAgICAgICAgIGlmIChkYXRhLmZpbGxTdHlsZSAmJiAhZGF0YS5maWxsU3R5bGUudGV4dHVyZS5iYXNlVGV4dHVyZS52YWxpZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChkYXRhLmxpbmVTdHlsZSAmJiAhZGF0YS5saW5lU3R5bGUudGV4dHVyZS5iYXNlVGV4dHVyZS52YWxpZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmNhY2hlRGlydHkgPSB0aGlzLmRpcnR5O1xyXG4gICAgICAgIHZhciB1dnMgPSB0aGlzLnV2cztcclxuICAgICAgICB2YXIgYmF0Y2hQYXJ0ID0gdGhpcy5iYXRjaGVzLnBvcCgpXHJcbiAgICAgICAgICAgIHx8IEdyYXBoaWNzR2VvbWV0cnkuQkFUQ0hfUE9PTC5wb3AoKVxyXG4gICAgICAgICAgICB8fCBuZXcgQmF0Y2hQYXJ0KCk7XHJcbiAgICAgICAgYmF0Y2hQYXJ0LnN0eWxlID0gYmF0Y2hQYXJ0LnN0eWxlXHJcbiAgICAgICAgICAgIHx8IHRoaXMuZ3JhcGhpY3NEYXRhWzBdLmZpbGxTdHlsZVxyXG4gICAgICAgICAgICB8fCB0aGlzLmdyYXBoaWNzRGF0YVswXS5saW5lU3R5bGU7XHJcbiAgICAgICAgdmFyIGN1cnJlbnRUZXh0dXJlID0gYmF0Y2hQYXJ0LnN0eWxlLnRleHR1cmUuYmFzZVRleHR1cmU7XHJcbiAgICAgICAgLy8gcmV2ZWFsKGN1cnJlbnRUZXh0dXJlKTtcclxuICAgICAgICB2YXIgY3VycmVudENvbG9yID0gYmF0Y2hQYXJ0LnN0eWxlLmNvbG9yICsgYmF0Y2hQYXJ0LnN0eWxlLmFscGhhO1xyXG4gICAgICAgIHRoaXMuYmF0Y2hlcy5wdXNoKGJhdGNoUGFydCk7XHJcbiAgICAgICAgLy8gcmV2ZWFsKHRoaXMuYmF0Y2hlcyk7XHJcbiAgICAgICAgLy8gVE9ETyAtIHRoaXMgY2FuIGJlIHNpbXBsaWZpZWRcclxuICAgICAgICBmb3IgKHZhciBpJDEgPSB0aGlzLnNoYXBlSW5kZXg7IGkkMSA8IHRoaXMuZ3JhcGhpY3NEYXRhLmxlbmd0aDsgaSQxKyspIHtcclxuICAgICAgICAgICAgdGhpcy5zaGFwZUluZGV4Kys7XHJcbiAgICAgICAgICAgIHZhciBkYXRhJDEgPSB0aGlzLmdyYXBoaWNzRGF0YVtpJDFdO1xyXG4gICAgICAgICAgICAvLyByZXZlYWwoZGF0YSQxKTtcclxuICAgICAgICAgICAgdmFyIGNvbW1hbmQgPSBHcmFwaGljc0dlb21ldHJ5LmdldEZpbGxDb21tYW5kKGRhdGEkMS50eXBlKTtcclxuICAgICAgICAgICAgLy8gcmV2ZWFsKGNvbW1hbmQpXHJcbiAgICAgICAgICAgIHZhciBmaWxsU3R5bGUgPSBkYXRhJDEuZmlsbFN0eWxlO1xyXG4gICAgICAgICAgICB2YXIgbGluZVN0eWxlID0gZGF0YSQxLmxpbmVTdHlsZTtcclxuICAgICAgICAgICAgLy8gYnVpbGQgb3V0IHRoZSBzaGFwZXMgcG9pbnRzLi5cclxuICAgICAgICAgICAgY29tbWFuZC5idWlsZChkYXRhJDEpO1xyXG4gICAgICAgICAgICBpZiAoZGF0YSQxLm1hdHJpeCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm1Qb2ludHMoZGF0YSQxLnBvaW50cywgZGF0YSQxLm1hdHJpeCk7XHJcbiAgICAgICAgICAgICAgICAvLyByZXZlYWwoZGF0YSQxLnBvaW50cylcclxuICAgICAgICAgICAgICAgIC8vIFx0cmV2ZWFsKGRhdGEkMS5tYXRyaXgpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCAyOyBqKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBzdHlsZSA9IChqID09PSAwKSA/IGZpbGxTdHlsZSA6IGxpbmVTdHlsZTtcclxuICAgICAgICAgICAgICAgIGlmICghc3R5bGUudmlzaWJsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIG5leHRUZXh0dXJlID0gc3R5bGUudGV4dHVyZS5iYXNlVGV4dHVyZTtcclxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50VGV4dHVyZSAhPT0gbmV4dFRleHR1cmUgfHwgKHN0eWxlLmNvbG9yICsgc3R5bGUuYWxwaGEpICE9PSBjdXJyZW50Q29sb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIHVzZSBhIGNvbnN0XHJcbiAgICAgICAgICAgICAgICAgICAgbmV4dFRleHR1cmUud3JhcE1vZGUgPSAxMDQ5NztcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50VGV4dHVyZSA9IG5leHRUZXh0dXJlO1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRDb2xvciA9IHN0eWxlLmNvbG9yICsgc3R5bGUuYWxwaGE7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4JDEgPSB0aGlzLmluZGljZXMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhdHRyaWJJbmRleCA9IHRoaXMucG9pbnRzLmxlbmd0aCAvIDI7XHJcbiAgICAgICAgICAgICAgICAgICAgYmF0Y2hQYXJ0LnNpemUgPSBpbmRleCQxIC0gYmF0Y2hQYXJ0LnN0YXJ0O1xyXG4gICAgICAgICAgICAgICAgICAgIGJhdGNoUGFydC5hdHRyaWJTaXplID0gYXR0cmliSW5kZXggLSBiYXRjaFBhcnQuYXR0cmliU3RhcnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJhdGNoUGFydC5zaXplID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBiYXRjaFBhcnQgPSBHcmFwaGljc0dlb21ldHJ5LkJBVENIX1BPT0wucG9wKCkgfHwgbmV3IEJhdGNoUGFydCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmJhdGNoZXMucHVzaChiYXRjaFBhcnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBiYXRjaFBhcnQuc3R5bGUgPSBzdHlsZTtcclxuICAgICAgICAgICAgICAgICAgICBiYXRjaFBhcnQuc3RhcnQgPSBpbmRleCQxO1xyXG4gICAgICAgICAgICAgICAgICAgIGJhdGNoUGFydC5hdHRyaWJTdGFydCA9IGF0dHJpYkluZGV4O1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gYWRkIHRoaXMgdG8gdGhlIHJlbmRlciBwYXJ0Li5cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBzdGFydCA9IHRoaXMucG9pbnRzLmxlbmd0aCAvIDI7XHJcbiAgICAgICAgICAgICAgICBpZiAoaiA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhJDEuaG9sZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHJvY2Vzc0hvbGVzKGRhdGEkMS5ob2xlcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIEdyYXBoaWNzR2VvbWV0cnkuYnVpbGRQb2x5LnRyaWFuZ3VsYXRlKGRhdGEkMSwgdGhpcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21tYW5kLnRyaWFuZ3VsYXRlKGRhdGEkMSwgdGhpcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgR3JhcGhpY3NHZW9tZXRyeS5idWlsZExpbmUoZGF0YSQxLCB0aGlzKTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpJDIgPSAwOyBpJDIgPCBkYXRhJDEuaG9sZXMubGVuZ3RoOyBpJDIrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBHcmFwaGljc0dlb21ldHJ5LmJ1aWxkTGluZShkYXRhJDEuaG9sZXNbaSQyXSwgdGhpcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIHNpemUgPSAodGhpcy5wb2ludHMubGVuZ3RoIC8gMikgLSBzdGFydDtcclxuICAgICAgICAgICAgICAgIHRoaXMuYWRkVXZzKHRoaXMucG9pbnRzLCB1dnMsIHN0eWxlLnRleHR1cmUsIHN0YXJ0LCBzaXplLCBzdHlsZS5tYXRyaXgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMuaW5kaWNlcy5sZW5ndGg7XHJcbiAgICAgICAgdmFyIGF0dHJpYiA9IHRoaXMucG9pbnRzLmxlbmd0aCAvIDI7XHJcbiAgICAgICAgYmF0Y2hQYXJ0LnNpemUgPSBpbmRleCAtIGJhdGNoUGFydC5zdGFydDtcclxuICAgICAgICBiYXRjaFBhcnQuYXR0cmliU2l6ZSA9IGF0dHJpYiAtIGJhdGNoUGFydC5hdHRyaWJTdGFydDtcclxuICAgICAgICB0aGlzLmluZGljZXNVaW50MTYgPSBuZXcgVWludDE2QXJyYXkodGhpcy5pbmRpY2VzKTtcclxuICAgICAgICAvLyBUT0RPIG1ha2UgdGhpcyBhIGNvbnN0Li5cclxuICAgICAgICB0aGlzLmJhdGNoYWJsZSA9IHRoaXMuaXNCYXRjaGFibGUoKTtcclxuICAgICAgICBpZiAodGhpcy5iYXRjaGFibGUpIHtcclxuICAgICAgICAgICAgdGhpcy5iYXRjaERpcnR5Kys7XHJcbiAgICAgICAgICAgIHRoaXMudXZzRmxvYXQzMiA9IG5ldyBGbG9hdDMyQXJyYXkodGhpcy51dnMpO1xyXG4gICAgICAgICAgICAvLyBvZmZzZXQgdGhlIGluZGljZXMgc28gdGhhdCBpdCB3b3JrcyB3aXRoIHRoZSBiYXRjaGVyLi4uXHJcbiAgICAgICAgICAgIGZvciAodmFyIGkkMyA9IDA7IGkkMyA8IHRoaXMuYmF0Y2hlcy5sZW5ndGg7IGkkMysrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYmF0Y2ggPSB0aGlzLmJhdGNoZXNbaSQzXTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGokMSA9IDA7IGokMSA8IGJhdGNoLnNpemU7IGokMSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4JDIgPSBiYXRjaC5zdGFydCArIGokMTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmluZGljZXNVaW50MTZbaW5kZXgkMl0gPSB0aGlzLmluZGljZXNVaW50MTZbaW5kZXgkMl0gLSBiYXRjaC5hdHRyaWJTdGFydDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5idWlsZERyYXdDYWxscygpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2tzIHRvIHNlZSBpZiB0aGlzIGdyYXBoaWNzIGdlb21ldHJ5IGNhbiBiZSBiYXRjaGVkLlxyXG4gICAgICogQ3VycmVudGx5IGl0IG5lZWRzIHRvIGJlIHNtYWxsIGVub3VnaCBhbmQgbm90IGNvbnRhaW4gYW55IG5hdGl2ZSBsaW5lcy5cclxuICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAqL1xyXG4gICAgaXNCYXRjaGFibGUoKSB7XHJcbiAgICAgICAgdmFyIGJhdGNoZXMgPSB0aGlzLmJhdGNoZXM7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiYXRjaGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChiYXRjaGVzW2ldLnN0eWxlLm5hdGl2ZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAodGhpcy5wb2ludHMubGVuZ3RoIDwgR3JhcGhpY3NHZW9tZXRyeS5CQVRDSEFCTEVfU0laRSAqIDIpO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDb252ZXJ0cyBpbnRlcm1lZGlhdGUgYmF0Y2hlcyBkYXRhIHRvIGRyYXdDYWxscy5cclxuICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAqL1xyXG4gICAgYnVpbGREcmF3Q2FsbHMoKSB7XHJcbiAgICAgICAgdmFyIFRJQ0sgPSArK0Jhc2VUZXh0dXJlXzEuQmFzZVRleHR1cmUuX2dsb2JhbEJhdGNoO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5kcmF3Q2FsbHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdGhpcy5kcmF3Q2FsbHNbaV0udGV4dHVyZXMubGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgR3JhcGhpY3NHZW9tZXRyeS5EUkFXX0NBTExfUE9PTC5wdXNoKHRoaXMuZHJhd0NhbGxzW2ldKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5kcmF3Q2FsbHMubGVuZ3RoID0gMDtcclxuICAgICAgICB2YXIgdXZzID0gdGhpcy51dnM7XHJcbiAgICAgICAgdmFyIGNvbG9ycyA9IHRoaXMuY29sb3JzO1xyXG4gICAgICAgIHZhciB0ZXh0dXJlSWRzID0gdGhpcy50ZXh0dXJlSWRzO1xyXG4gICAgICAgIHZhciBjdXJyZW50R3JvdXAgPSBHcmFwaGljc0dlb21ldHJ5LkRSQVdfQ0FMTF9QT09MLnBvcCgpIHx8IG5ldyBCYXRjaERyYXdDYWxsXzEuQmF0Y2hEcmF3Q2FsbCgpO1xyXG4gICAgICAgIGN1cnJlbnRHcm91cC50ZXh0dXJlQ291bnQgPSAwO1xyXG4gICAgICAgIGN1cnJlbnRHcm91cC5zdGFydCA9IDA7XHJcbiAgICAgICAgY3VycmVudEdyb3VwLnNpemUgPSAwO1xyXG4gICAgICAgIGN1cnJlbnRHcm91cC50eXBlID0gRHJhd01vZGVTZXR0aW5nc18xLkRyYXdNb2RlU2V0dGluZ3MuRFJBV19NT0RFUy5UUklBTkdMRVM7XHJcbiAgICAgICAgdmFyIHRleHR1cmVDb3VudCA9IDA7XHJcbiAgICAgICAgdmFyIGN1cnJlbnRUZXh0dXJlID0gbnVsbDtcclxuICAgICAgICB2YXIgdGV4dHVyZUlkID0gMDtcclxuICAgICAgICB2YXIgbmF0aXZlID0gZmFsc2U7XHJcbiAgICAgICAgdmFyIGRyYXdNb2RlID0gRHJhd01vZGVTZXR0aW5nc18xLkRyYXdNb2RlU2V0dGluZ3MuRFJBV19NT0RFUy5UUklBTkdMRVM7XHJcbiAgICAgICAgdmFyIGluZGV4ID0gMDtcclxuICAgICAgICB0aGlzLmRyYXdDYWxscy5wdXNoKGN1cnJlbnRHcm91cCk7XHJcbiAgICAgICAgLy8gVE9ETyAtIHRoaXMgY2FuIGJlIHNpbXBsaWZpZWRcclxuICAgICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCB0aGlzLmJhdGNoZXMubGVuZ3RoOyBpJDErKykge1xyXG4gICAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuYmF0Y2hlc1tpJDFdO1xyXG4gICAgICAgICAgICAvLyBUT0RPIGFkZCBzb21lIGZ1bGwgb24gTUFYX1RFWFRVUkUgQ09ERS4uXHJcbiAgICAgICAgICAgIHZhciBNQVhfVEVYVFVSRVMgPSA4O1xyXG4gICAgICAgICAgICB2YXIgc3R5bGUgPSBkYXRhLnN0eWxlO1xyXG4gICAgICAgICAgICB2YXIgbmV4dFRleHR1cmUgPSBzdHlsZS50ZXh0dXJlLmJhc2VUZXh0dXJlO1xyXG4gICAgICAgICAgICBpZiAobmF0aXZlICE9PSBzdHlsZS5uYXRpdmUpIHtcclxuICAgICAgICAgICAgICAgIG5hdGl2ZSA9IHN0eWxlLm5hdGl2ZTtcclxuICAgICAgICAgICAgICAgIGRyYXdNb2RlID0gbmF0aXZlID8gRHJhd01vZGVTZXR0aW5nc18xLkRyYXdNb2RlU2V0dGluZ3MuRFJBV19NT0RFUy5MSU5FUyA6IERyYXdNb2RlU2V0dGluZ3NfMS5EcmF3TW9kZVNldHRpbmdzLkRSQVdfTU9ERVMuVFJJQU5HTEVTO1xyXG4gICAgICAgICAgICAgICAgLy8gZm9yY2UgdGhlIGJhdGNoIHRvIGJyZWFrIVxyXG4gICAgICAgICAgICAgICAgY3VycmVudFRleHR1cmUgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgdGV4dHVyZUNvdW50ID0gTUFYX1RFWFRVUkVTO1xyXG4gICAgICAgICAgICAgICAgVElDSysrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChjdXJyZW50VGV4dHVyZSAhPT0gbmV4dFRleHR1cmUpIHtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRUZXh0dXJlID0gbmV4dFRleHR1cmU7XHJcbiAgICAgICAgICAgICAgICBpZiAobmV4dFRleHR1cmUuX2JhdGNoRW5hYmxlZCAhPT0gVElDSykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0ZXh0dXJlQ291bnQgPT09IE1BWF9URVhUVVJFUykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBUSUNLKys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHR1cmVDb3VudCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50R3JvdXAuc2l6ZSA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRHcm91cCA9IEdyYXBoaWNzR2VvbWV0cnkuRFJBV19DQUxMX1BPT0wucG9wKCkgfHwgbmV3IEJhdGNoRHJhd0NhbGxfMS5CYXRjaERyYXdDYWxsKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdDYWxscy5wdXNoKGN1cnJlbnRHcm91cCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEdyb3VwLnN0YXJ0ID0gaW5kZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRHcm91cC5zaXplID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEdyb3VwLnRleHR1cmVDb3VudCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRHcm91cC50eXBlID0gZHJhd01vZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gYWRkIHRoaXMgdG8gdGhlIHJlbmRlciBwYXJ0Li5cclxuICAgICAgICAgICAgICAgICAgICBuZXh0VGV4dHVyZS50b3VjaGVkID0gMTsgLy8gdG91Y2g7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV4dFRleHR1cmUuX2JhdGNoRW5hYmxlZCA9IFRJQ0s7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV4dFRleHR1cmUuX2lkID0gdGV4dHVyZUNvdW50O1xyXG4gICAgICAgICAgICAgICAgICAgIG5leHRUZXh0dXJlLndyYXBNb2RlID0gMTA0OTc7XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudEdyb3VwLnRleHR1cmVzW2N1cnJlbnRHcm91cC50ZXh0dXJlQ291bnQrK10gPSBuZXh0VGV4dHVyZTtcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlQ291bnQrKztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjdXJyZW50R3JvdXAuc2l6ZSArPSBkYXRhLnNpemU7XHJcbiAgICAgICAgICAgIGluZGV4ICs9IGRhdGEuc2l6ZTtcclxuICAgICAgICAgICAgdGV4dHVyZUlkID0gbmV4dFRleHR1cmUuX2lkO1xyXG4gICAgICAgICAgICB0aGlzLmFkZENvbG9ycyhjb2xvcnMsIHN0eWxlLmNvbG9yLCBzdHlsZS5hbHBoYSwgZGF0YS5hdHRyaWJTaXplKTtcclxuICAgICAgICAgICAgdGhpcy5hZGRUZXh0dXJlSWRzKHRleHR1cmVJZHMsIHRleHR1cmVJZCwgZGF0YS5hdHRyaWJTaXplKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgQmFzZVRleHR1cmVfMS5CYXNlVGV4dHVyZS5fZ2xvYmFsQmF0Y2ggPSBUSUNLO1xyXG4gICAgICAgIC8vIHVwbG9hZC4uXHJcbiAgICAgICAgLy8gbWVyZ2UgZm9yIG5vdyFcclxuICAgICAgICB2YXIgdmVydHMgPSB0aGlzLnBvaW50cztcclxuICAgICAgICAvLyB2ZXJ0cyBhcmUgMiBwb3NpdGlvbnMuLiBzbyB3ZSAqIGJ5IDMgYXMgdGhlcmUgYXJlIDYgcHJvcGVydGllcy4uIHRoZW4gNCBjb3MgaXRzIGJ5dGVzXHJcbiAgICAgICAgdmFyIGdsUG9pbnRzID0gbmV3IEFycmF5QnVmZmVyKHZlcnRzLmxlbmd0aCAqIDMgKiA0KTtcclxuICAgICAgICB2YXIgZjMyID0gbmV3IEZsb2F0MzJBcnJheShnbFBvaW50cyk7XHJcbiAgICAgICAgdmFyIHUzMiA9IG5ldyBVaW50MzJBcnJheShnbFBvaW50cyk7XHJcbiAgICAgICAgdmFyIHAgPSAwO1xyXG4gICAgICAgIGZvciAodmFyIGkkMiA9IDA7IGkkMiA8IHZlcnRzLmxlbmd0aCAvIDI7IGkkMisrKSB7XHJcbiAgICAgICAgICAgIGYzMltwKytdID0gdmVydHNbaSQyICogMl07XHJcbiAgICAgICAgICAgIGYzMltwKytdID0gdmVydHNbKGkkMiAqIDIpICsgMV07XHJcbiAgICAgICAgICAgIGYzMltwKytdID0gdXZzW2kkMiAqIDJdO1xyXG4gICAgICAgICAgICBmMzJbcCsrXSA9IHV2c1soaSQyICogMikgKyAxXTtcclxuICAgICAgICAgICAgdTMyW3ArK10gPSBjb2xvcnNbaSQyXTtcclxuICAgICAgICAgICAgZjMyW3ArK10gPSB0ZXh0dXJlSWRzW2kkMl07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2J1ZmZlci51cGRhdGUoZ2xQb2ludHMpO1xyXG4gICAgICAgIHRoaXMuX2luZGV4QnVmZmVyLnVwZGF0ZSh0aGlzLmluZGljZXNVaW50MTYpO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBQcm9jZXNzIHRoZSBob2xlcyBkYXRhLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7UElYSS5HcmFwaGljc0RhdGFbXX0gaG9sZXMgLSBIb2xlcyB0byByZW5kZXJcclxuICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAqL1xyXG4gICAgcHJvY2Vzc0hvbGVzKGhvbGVzKSB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBob2xlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgaG9sZSA9IGhvbGVzW2ldO1xyXG4gICAgICAgICAgICB2YXIgY29tbWFuZCA9IEdyYXBoaWNzR2VvbWV0cnkuZmlsbENvbW1hbmRzW2hvbGUudHlwZV07XHJcbiAgICAgICAgICAgIGNvbW1hbmQuYnVpbGQoaG9sZSk7XHJcbiAgICAgICAgICAgIGlmIChob2xlLm1hdHJpeCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm1Qb2ludHMoaG9sZS5wb2ludHMsIGhvbGUubWF0cml4KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlIHRoZSBsb2NhbCBib3VuZHMgb2YgdGhlIG9iamVjdC4gRXhwZW5zaXZlIHRvIHVzZSBwZXJmb3JtYW5jZS13aXNlLlxyXG4gICAgICogQHByb3RlY3RlZFxyXG4gICAgICovXHJcbiAgICBjYWxjdWxhdGVCb3VuZHMoKSB7XHJcbiAgICAgICAgdmFyIG1pblggPSBJbmZpbml0eTtcclxuICAgICAgICB2YXIgbWF4WCA9IC1JbmZpbml0eTtcclxuICAgICAgICB2YXIgbWluWSA9IEluZmluaXR5O1xyXG4gICAgICAgIHZhciBtYXhZID0gLUluZmluaXR5O1xyXG4gICAgICAgIGlmICh0aGlzLmdyYXBoaWNzRGF0YS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgdmFyIHNoYXBlID0gbnVsbDtcclxuICAgICAgICAgICAgdmFyIHggPSAwO1xyXG4gICAgICAgICAgICB2YXIgeSA9IDA7XHJcbiAgICAgICAgICAgIHZhciB3ID0gMDtcclxuICAgICAgICAgICAgdmFyIGggPSAwO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZ3JhcGhpY3NEYXRhLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuZ3JhcGhpY3NEYXRhW2ldO1xyXG4gICAgICAgICAgICAgICAgdmFyIHR5cGUgPSBkYXRhLnR5cGU7XHJcbiAgICAgICAgICAgICAgICB2YXIgbGluZVdpZHRoID0gZGF0YS5saW5lU3R5bGUgPyBkYXRhLmxpbmVTdHlsZS53aWR0aCA6IDA7XHJcbiAgICAgICAgICAgICAgICBzaGFwZSA9IGRhdGEuc2hhcGU7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gU2hhcGVTZXR0aW5nc18xLlNoYXBlU2V0dGluZ3MuU0hBUEVTLlJFQ1QgfHwgdHlwZSA9PT0gU2hhcGVTZXR0aW5nc18xLlNoYXBlU2V0dGluZ3MuU0hBUEVTLlJSRUMpIHtcclxuICAgICAgICAgICAgICAgICAgICB4ID0gc2hhcGUueCAtIChsaW5lV2lkdGggLyAyKTtcclxuICAgICAgICAgICAgICAgICAgICB5ID0gc2hhcGUueSAtIChsaW5lV2lkdGggLyAyKTtcclxuICAgICAgICAgICAgICAgICAgICB3ID0gc2hhcGUud2lkdGggKyBsaW5lV2lkdGg7XHJcbiAgICAgICAgICAgICAgICAgICAgaCA9IHNoYXBlLmhlaWdodCArIGxpbmVXaWR0aDtcclxuICAgICAgICAgICAgICAgICAgICBtaW5YID0geCA8IG1pblggPyB4IDogbWluWDtcclxuICAgICAgICAgICAgICAgICAgICBtYXhYID0geCArIHcgPiBtYXhYID8geCArIHcgOiBtYXhYO1xyXG4gICAgICAgICAgICAgICAgICAgIG1pblkgPSB5IDwgbWluWSA/IHkgOiBtaW5ZO1xyXG4gICAgICAgICAgICAgICAgICAgIG1heFkgPSB5ICsgaCA+IG1heFkgPyB5ICsgaCA6IG1heFk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlID09PSBTaGFwZVNldHRpbmdzXzEuU2hhcGVTZXR0aW5ncy5TSEFQRVMuQ0lSQykge1xyXG4gICAgICAgICAgICAgICAgICAgIHggPSBzaGFwZS54O1xyXG4gICAgICAgICAgICAgICAgICAgIHkgPSBzaGFwZS55O1xyXG4gICAgICAgICAgICAgICAgICAgIHcgPSBzaGFwZS5yYWRpdXMgKyAobGluZVdpZHRoIC8gMik7XHJcbiAgICAgICAgICAgICAgICAgICAgaCA9IHNoYXBlLnJhZGl1cyArIChsaW5lV2lkdGggLyAyKTtcclxuICAgICAgICAgICAgICAgICAgICBtaW5YID0geCAtIHcgPCBtaW5YID8geCAtIHcgOiBtaW5YO1xyXG4gICAgICAgICAgICAgICAgICAgIG1heFggPSB4ICsgdyA+IG1heFggPyB4ICsgdyA6IG1heFg7XHJcbiAgICAgICAgICAgICAgICAgICAgbWluWSA9IHkgLSBoIDwgbWluWSA/IHkgLSBoIDogbWluWTtcclxuICAgICAgICAgICAgICAgICAgICBtYXhZID0geSArIGggPiBtYXhZID8geSArIGggOiBtYXhZO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gU2hhcGVTZXR0aW5nc18xLlNoYXBlU2V0dGluZ3MuU0hBUEVTLkVMSVApIHtcclxuICAgICAgICAgICAgICAgICAgICB4ID0gc2hhcGUueDtcclxuICAgICAgICAgICAgICAgICAgICB5ID0gc2hhcGUueTtcclxuICAgICAgICAgICAgICAgICAgICB3ID0gc2hhcGUud2lkdGggKyAobGluZVdpZHRoIC8gMik7XHJcbiAgICAgICAgICAgICAgICAgICAgaCA9IHNoYXBlLmhlaWdodCArIChsaW5lV2lkdGggLyAyKTtcclxuICAgICAgICAgICAgICAgICAgICBtaW5YID0geCAtIHcgPCBtaW5YID8geCAtIHcgOiBtaW5YO1xyXG4gICAgICAgICAgICAgICAgICAgIG1heFggPSB4ICsgdyA+IG1heFggPyB4ICsgdyA6IG1heFg7XHJcbiAgICAgICAgICAgICAgICAgICAgbWluWSA9IHkgLSBoIDwgbWluWSA/IHkgLSBoIDogbWluWTtcclxuICAgICAgICAgICAgICAgICAgICBtYXhZID0geSArIGggPiBtYXhZID8geSArIGggOiBtYXhZO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gUE9MWVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwb2ludHMgPSBzaGFwZS5wb2ludHM7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHgyID0gMDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgeTIgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBkeCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGR5ID0gMDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcncgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciByaCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGN4ID0gMDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY3kgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqICsgMiA8IHBvaW50cy5sZW5ndGg7IGogKz0gMikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB4ID0gcG9pbnRzW2pdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB5ID0gcG9pbnRzW2ogKyAxXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeDIgPSBwb2ludHNbaiArIDJdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB5MiA9IHBvaW50c1tqICsgM107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGR4ID0gTWF0aC5hYnMoeDIgLSB4KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZHkgPSBNYXRoLmFicyh5MiAtIHkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBoID0gbGluZVdpZHRoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3ID0gTWF0aC5zcXJ0KChkeCAqIGR4KSArIChkeSAqIGR5KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3IDwgMWUtOSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcncgPSAoKGggLyB3ICogZHkpICsgZHgpIC8gMjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmggPSAoKGggLyB3ICogZHgpICsgZHkpIC8gMjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3ggPSAoeDIgKyB4KSAvIDI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN5ID0gKHkyICsgeSkgLyAyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5YID0gY3ggLSBydyA8IG1pblggPyBjeCAtIHJ3IDogbWluWDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWF4WCA9IGN4ICsgcncgPiBtYXhYID8gY3ggKyBydyA6IG1heFg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pblkgPSBjeSAtIHJoIDwgbWluWSA/IGN5IC0gcmggOiBtaW5ZO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhZID0gY3kgKyByaCA+IG1heFkgPyBjeSArIHJoIDogbWF4WTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG1pblggPSAwO1xyXG4gICAgICAgICAgICBtYXhYID0gMDtcclxuICAgICAgICAgICAgbWluWSA9IDA7XHJcbiAgICAgICAgICAgIG1heFkgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcGFkZGluZyA9IHRoaXMuYm91bmRzUGFkZGluZztcclxuICAgICAgICB0aGlzLl9ib3VuZHMubWluWCA9IG1pblggLSBwYWRkaW5nO1xyXG4gICAgICAgIHRoaXMuX2JvdW5kcy5tYXhYID0gbWF4WCArIHBhZGRpbmc7XHJcbiAgICAgICAgdGhpcy5fYm91bmRzLm1pblkgPSBtaW5ZIC0gcGFkZGluZztcclxuICAgICAgICB0aGlzLl9ib3VuZHMubWF4WSA9IG1heFkgKyBwYWRkaW5nO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUcmFuc2Zvcm0gcG9pbnRzIHVzaW5nIG1hdHJpeC5cclxuICAgICAqXHJcbiAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcltdfSBwb2ludHMgLSBQb2ludHMgdG8gdHJhbnNmb3JtXHJcbiAgICAgKiBAcGFyYW0ge1BJWEkuTWF0cml4fSBtYXRyaXggLSBUcmFuc2Zvcm0gbWF0cml4XHJcbiAgICAgKi9cclxuICAgIHRyYW5zZm9ybVBvaW50cyhwb2ludHMsIG1hdHJpeCkge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aCAvIDI7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgeCA9IHBvaW50c1soaSAqIDIpXTtcclxuICAgICAgICAgICAgdmFyIHkgPSBwb2ludHNbKGkgKiAyKSArIDFdO1xyXG4gICAgICAgICAgICBwb2ludHNbKGkgKiAyKV0gPSAobWF0cml4LmEgKiB4KSArIChtYXRyaXguYyAqIHkpICsgbWF0cml4LnR4O1xyXG4gICAgICAgICAgICBwb2ludHNbKGkgKiAyKSArIDFdID0gKG1hdHJpeC5iICogeCkgKyAobWF0cml4LmQgKiB5KSArIG1hdHJpeC50eTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIEFkZCBjb2xvcnMuXHJcbiAgICAgKlxyXG4gICAgICogQHByb3RlY3RlZFxyXG4gICAgICogQHBhcmFtIHtudW1iZXJbXX0gY29sb3JzIC0gTGlzdCBvZiBjb2xvcnMgdG8gYWRkIHRvXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY29sb3IgLSBDb2xvciB0byBhZGRcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhbHBoYSAtIEFscGhhIHRvIHVzZVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNpemUgLSBOdW1iZXIgb2YgY29sb3JzIHRvIGFkZFxyXG4gICAgICovXHJcbiAgICBhZGRDb2xvcnMoY29sb3JzLCBjb2xvciwgYWxwaGEsIHNpemUpIHtcclxuICAgICAgICAvLyBUT0RPIHVzZSB0aGUgcHJlbXVsdGlwbHkgYml0cyBJdmFuIGFkZGVkXHJcbiAgICAgICAgdmFyIHJnYiA9IChjb2xvciA+PiAxNikgKyAoY29sb3IgJiAweGZmMDApICsgKChjb2xvciAmIDB4ZmYpIDw8IDE2KTtcclxuICAgICAgICB2YXIgcmdiYSA9IENvbG9yU2V0dGluZ3NfMS5Db2xvclNldHRpbmdzLnByZW11bHRpcGx5VGludChyZ2IsIGFscGhhKTtcclxuICAgICAgICB3aGlsZSAoc2l6ZS0tID4gMCkge1xyXG4gICAgICAgICAgICBjb2xvcnMucHVzaChyZ2JhKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIEFkZCB0ZXh0dXJlIGlkIHRoYXQgdGhlIHNoYWRlci9mcmFnbWVudCB3YW50cyB0byB1c2UuXHJcbiAgICAgKlxyXG4gICAgICogQHByb3RlY3RlZFxyXG4gICAgICogQHBhcmFtIHtudW1iZXJbXX0gdGV4dHVyZUlkc1xyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGlkXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2l6ZVxyXG4gICAgICovXHJcbiAgICBhZGRUZXh0dXJlSWRzKHRleHR1cmVJZHMsIGlkLCBzaXplKSB7XHJcbiAgICAgICAgd2hpbGUgKHNpemUtLSA+IDApIHtcclxuICAgICAgICAgICAgdGV4dHVyZUlkcy5wdXNoKGlkKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIEdlbmVyYXRlcyB0aGUgVVZzIGZvciBhIHNoYXBlLlxyXG4gICAgICpcclxuICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyW119IHZlcnRzIC0gVmVydGljZXNcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyW119IHV2cyAtIFVWc1xyXG4gICAgICogQHBhcmFtIHtQSVhJLlRleHR1cmV9IHRleHR1cmUgLSBSZWZlcmVuY2UgdG8gVGV4dHVyZVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IC0gSW5kZXggYnVmZmVyIHN0YXJ0IGluZGV4LlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNpemUgLSBUaGUgc2l6ZS9sZW5ndGggZm9yIGluZGV4IGJ1ZmZlci5cclxuICAgICAqIEBwYXJhbSB7UElYSS5NYXRyaXh9IFttYXRyaXhdIC0gT3B0aW9uYWwgdHJhbnNmb3JtIGZvciBhbGwgcG9pbnRzLlxyXG4gICAgICovXHJcbiAgICBhZGRVdnModmVydHMsIHV2cywgdGV4dHVyZSwgc3RhcnQsIHNpemUsIG1hdHJpeCkge1xyXG4gICAgICAgIHZhciBpbmRleCA9IDA7XHJcbiAgICAgICAgdmFyIHV2c1N0YXJ0ID0gdXZzLmxlbmd0aDtcclxuICAgICAgICB2YXIgZnJhbWUgPSB0ZXh0dXJlLmZyYW1lO1xyXG4gICAgICAgIHdoaWxlIChpbmRleCA8IHNpemUpIHtcclxuICAgICAgICAgICAgdmFyIHggPSB2ZXJ0c1soc3RhcnQgKyBpbmRleCkgKiAyXTtcclxuICAgICAgICAgICAgdmFyIHkgPSB2ZXJ0c1soKHN0YXJ0ICsgaW5kZXgpICogMikgKyAxXTtcclxuICAgICAgICAgICAgaWYgKG1hdHJpeCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIG54ID0gKG1hdHJpeC5hICogeCkgKyAobWF0cml4LmMgKiB5KSArIG1hdHJpeC50eDtcclxuICAgICAgICAgICAgICAgIHkgPSAobWF0cml4LmIgKiB4KSArIChtYXRyaXguZCAqIHkpICsgbWF0cml4LnR5O1xyXG4gICAgICAgICAgICAgICAgeCA9IG54O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGluZGV4Kys7XHJcbiAgICAgICAgICAgIHV2cy5wdXNoKHggLyBmcmFtZS53aWR0aCwgeSAvIGZyYW1lLmhlaWdodCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBiYXNlVGV4dHVyZSA9IHRleHR1cmUuYmFzZVRleHR1cmU7XHJcbiAgICAgICAgaWYgKGZyYW1lLndpZHRoIDwgYmFzZVRleHR1cmUud2lkdGhcclxuICAgICAgICAgICAgfHwgZnJhbWUuaGVpZ2h0IDwgYmFzZVRleHR1cmUuaGVpZ2h0KSB7XHJcbiAgICAgICAgICAgIHRoaXMuYWRqdXN0VXZzKHV2cywgdGV4dHVyZSwgdXZzU3RhcnQsIHNpemUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogTW9kaWZ5IHV2cyBhcnJheSBhY2NvcmRpbmcgdG8gcG9zaXRpb24gb2YgdGV4dHVyZSByZWdpb25cclxuICAgICAqIERvZXMgbm90IHdvcmsgd2l0aCByb3RhdGVkIG9yIHRyaW1tZWQgdGV4dHVyZXNcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB1dnMgYXJyYXlcclxuICAgICAqIEBwYXJhbSB7UElYSS5UZXh0dXJlfSB0ZXh0dXJlIHJlZ2lvblxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IHN0YXJ0aW5nIGluZGV4IGZvciB1dnNcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzaXplIGhvdyBtYW55IHBvaW50cyB0byBhZGp1c3RcclxuICAgICAqL1xyXG4gICAgYWRqdXN0VXZzKHV2cywgdGV4dHVyZSwgc3RhcnQsIHNpemUpIHtcclxuICAgICAgICB2YXIgYmFzZVRleHR1cmUgPSB0ZXh0dXJlLmJhc2VUZXh0dXJlO1xyXG4gICAgICAgIHZhciBlcHMgPSAxZS02O1xyXG4gICAgICAgIHZhciBmaW5pc2ggPSBzdGFydCArIChzaXplICogMik7XHJcbiAgICAgICAgdmFyIGZyYW1lID0gdGV4dHVyZS5mcmFtZTtcclxuICAgICAgICB2YXIgc2NhbGVYID0gZnJhbWUud2lkdGggLyBiYXNlVGV4dHVyZS53aWR0aDtcclxuICAgICAgICB2YXIgc2NhbGVZID0gZnJhbWUuaGVpZ2h0IC8gYmFzZVRleHR1cmUuaGVpZ2h0O1xyXG4gICAgICAgIHZhciBvZmZzZXRYID0gZnJhbWUueCAvIGZyYW1lLndpZHRoO1xyXG4gICAgICAgIHZhciBvZmZzZXRZID0gZnJhbWUueSAvIGZyYW1lLndpZHRoO1xyXG4gICAgICAgIHZhciBtaW5YID0gTWF0aC5mbG9vcih1dnNbc3RhcnRdICsgZXBzKTtcclxuICAgICAgICB2YXIgbWluWSA9IE1hdGguZmxvb3IodXZzW3N0YXJ0ICsgMV0gKyBlcHMpO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSBzdGFydCArIDI7IGkgPCBmaW5pc2g7IGkgKz0gMikge1xyXG4gICAgICAgICAgICBtaW5YID0gTWF0aC5taW4obWluWCwgTWF0aC5mbG9vcih1dnNbaV0gKyBlcHMpKTtcclxuICAgICAgICAgICAgbWluWSA9IE1hdGgubWluKG1pblksIE1hdGguZmxvb3IodXZzW2kgKyAxXSArIGVwcykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBvZmZzZXRYIC09IG1pblg7XHJcbiAgICAgICAgb2Zmc2V0WSAtPSBtaW5ZO1xyXG4gICAgICAgIGZvciAodmFyIGkkMSA9IHN0YXJ0OyBpJDEgPCBmaW5pc2g7IGkkMSArPSAyKSB7XHJcbiAgICAgICAgICAgIHV2c1tpJDFdID0gKHV2c1tpJDFdICsgb2Zmc2V0WCkgKiBzY2FsZVg7XHJcbiAgICAgICAgICAgIHV2c1tpJDEgKyAxXSA9ICh1dnNbaSQxICsgMV0gKyBvZmZzZXRZKSAqIHNjYWxlWTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICogQnVpbGRzIGEgbGluZSB0byBkcmF3XHJcbiAqXHJcbiAqIElnbm9yZWQgZnJvbSBkb2NzIHNpbmNlIGl0IGlzIG5vdCBkaXJlY3RseSBleHBvc2VkLlxyXG4gKlxyXG4gKiBAaWdub3JlXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBwYXJhbSB7UElYSS5HcmFwaGljc0RhdGF9IGdyYXBoaWNzRGF0YSAtIFRoZSBncmFwaGljcyBvYmplY3QgY29udGFpbmluZyBhbGwgdGhlIG5lY2Vzc2FyeSBwcm9wZXJ0aWVzXHJcbiAqIEBwYXJhbSB7UElYSS5HcmFwaGljc0dlb21ldHJ5fSBncmFwaGljc0dlb21ldHJ5IC0gR2VvbWV0cnkgd2hlcmUgdG8gYXBwZW5kIG91dHB1dFxyXG4gKi9cclxuICAgIHN0YXRpYyBidWlsZExpbmUoZ3JhcGhpY3NEYXRhLCBncmFwaGljc0dlb21ldHJ5KSB7XHJcbiAgICAgICAgaWYgKGdyYXBoaWNzRGF0YS5saW5lU3R5bGUubmF0aXZlKSB7XHJcbiAgICAgICAgICAgIEdyYXBoaWNzR2VvbWV0cnkuYnVpbGROYXRpdmVMaW5lKGdyYXBoaWNzRGF0YSwgZ3JhcGhpY3NHZW9tZXRyeSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBHcmFwaGljc0dlb21ldHJ5LmJ1aWxkTGluZSQxKGdyYXBoaWNzRGF0YSwgZ3JhcGhpY3NHZW9tZXRyeSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAqIEJ1aWxkcyBhIGxpbmUgdG8gZHJhdyB1c2luZyB0aGUgZ2wuZHJhd0FycmF5cyhnbC5MSU5FUykgbWV0aG9kXHJcbiAqXHJcbiAqIElnbm9yZWQgZnJvbSBkb2NzIHNpbmNlIGl0IGlzIG5vdCBkaXJlY3RseSBleHBvc2VkLlxyXG4gKlxyXG4gKiBAaWdub3JlXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBwYXJhbSB7UElYSS5HcmFwaGljc0RhdGF9IGdyYXBoaWNzRGF0YSAtIFRoZSBncmFwaGljcyBvYmplY3QgY29udGFpbmluZyBhbGwgdGhlIG5lY2Vzc2FyeSBwcm9wZXJ0aWVzXHJcbiAqIEBwYXJhbSB7UElYSS5HcmFwaGljc0dlb21ldHJ5fSBncmFwaGljc0dlb21ldHJ5IC0gR2VvbWV0cnkgd2hlcmUgdG8gYXBwZW5kIG91dHB1dFxyXG4gKi9cclxuICAgIHN0YXRpYyBidWlsZE5hdGl2ZUxpbmUoZ3JhcGhpY3NEYXRhLCBncmFwaGljc0dlb21ldHJ5KSB7XHJcbiAgICAgICAgdmFyIGkgPSAwO1xyXG4gICAgICAgIHZhciBwb2ludHMgPSBncmFwaGljc0RhdGEucG9pbnRzIHx8IGdyYXBoaWNzRGF0YS5zaGFwZS5wb2ludHM7XHJcbiAgICAgICAgaWYgKHBvaW50cy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgdmVydHMgPSBncmFwaGljc0dlb21ldHJ5LnBvaW50cztcclxuICAgICAgICB2YXIgaW5kaWNlcyA9IGdyYXBoaWNzR2VvbWV0cnkuaW5kaWNlcztcclxuICAgICAgICB2YXIgbGVuZ3RoID0gcG9pbnRzLmxlbmd0aCAvIDI7XHJcbiAgICAgICAgdmFyIGluZGV4U3RhcnQgPSB2ZXJ0cy5sZW5ndGggLyAyO1xyXG4gICAgICAgIC8vIHNvcnQgY29sb3JcclxuICAgICAgICBmb3IgKGkgPSAxOyBpIDwgbGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIHAxeCA9IHBvaW50c1soaSAtIDEpICogMl07XHJcbiAgICAgICAgICAgIHZhciBwMXkgPSBwb2ludHNbKChpIC0gMSkgKiAyKSArIDFdO1xyXG4gICAgICAgICAgICB2YXIgcDJ4ID0gcG9pbnRzW2kgKiAyXTtcclxuICAgICAgICAgICAgdmFyIHAyeSA9IHBvaW50c1soaSAqIDIpICsgMV07XHJcbiAgICAgICAgICAgIHZlcnRzLnB1c2gocDF4LCBwMXkpO1xyXG4gICAgICAgICAgICB2ZXJ0cy5wdXNoKHAyeCwgcDJ5KTtcclxuICAgICAgICAgICAgaW5kaWNlcy5wdXNoKGluZGV4U3RhcnQrKywgaW5kZXhTdGFydCsrKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICogQnVpbGRzIGEgbGluZSB0byBkcmF3IHVzaW5nIHRoZSBwb2x5Z29uIG1ldGhvZC5cclxuICpcclxuICogSWdub3JlZCBmcm9tIGRvY3Mgc2luY2UgaXQgaXMgbm90IGRpcmVjdGx5IGV4cG9zZWQuXHJcbiAqXHJcbiAqIEBpZ25vcmVcclxuICogQHByaXZhdGVcclxuICogQHBhcmFtIHtQSVhJLkdyYXBoaWNzRGF0YX0gZ3JhcGhpY3NEYXRhIC0gVGhlIGdyYXBoaWNzIG9iamVjdCBjb250YWluaW5nIGFsbCB0aGUgbmVjZXNzYXJ5IHByb3BlcnRpZXNcclxuICogQHBhcmFtIHtQSVhJLkdyYXBoaWNzR2VvbWV0cnl9IGdyYXBoaWNzR2VvbWV0cnkgLSBHZW9tZXRyeSB3aGVyZSB0byBhcHBlbmQgb3V0cHV0XHJcbiAqL1xyXG4gICAgc3RhdGljIGJ1aWxkTGluZSQxKGdyYXBoaWNzRGF0YSwgZ3JhcGhpY3NHZW9tZXRyeSkge1xyXG4gICAgICAgIHZhciBzaGFwZSA9IGdyYXBoaWNzRGF0YS5zaGFwZTtcclxuICAgICAgICB2YXIgcG9pbnRzID0gZ3JhcGhpY3NEYXRhLnBvaW50cyB8fCBzaGFwZS5wb2ludHMuc2xpY2UoKTtcclxuICAgICAgICBpZiAocG9pbnRzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGlmIHRoZSBsaW5lIHdpZHRoIGlzIGFuIG9kZCBudW1iZXIgYWRkIDAuNSB0byBhbGlnbiB0byBhIHdob2xlIHBpeGVsXHJcbiAgICAgICAgLy8gY29tbWVudGluZyB0aGlzIG91dCBmaXhlcyAjNzExIGFuZCAjMTYyMFxyXG4gICAgICAgIC8vIGlmIChncmFwaGljc0RhdGEubGluZVdpZHRoJTIpXHJcbiAgICAgICAgLy8ge1xyXG4gICAgICAgIC8vICAgICBmb3IgKGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIC8vICAgICB7XHJcbiAgICAgICAgLy8gICAgICAgICBwb2ludHNbaV0gKz0gMC41O1xyXG4gICAgICAgIC8vICAgICB9XHJcbiAgICAgICAgLy8gfVxyXG4gICAgICAgIHZhciBzdHlsZSA9IGdyYXBoaWNzRGF0YS5saW5lU3R5bGU7XHJcbiAgICAgICAgLy8gZ2V0IGZpcnN0IGFuZCBsYXN0IHBvaW50Li4gZmlndXJlIG91dCB0aGUgbWlkZGxlIVxyXG4gICAgICAgIHZhciBmaXJzdFBvaW50ID0gbmV3IFBvaW50XzEuUG9pbnQocG9pbnRzWzBdLCBwb2ludHNbMV0pO1xyXG4gICAgICAgIHZhciBsYXN0UG9pbnQgPSBuZXcgUG9pbnRfMS5Qb2ludChwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDJdLCBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDFdKTtcclxuICAgICAgICB2YXIgY2xvc2VkU2hhcGUgPSBzaGFwZS50eXBlICE9PSBTaGFwZVNldHRpbmdzXzEuU2hhcGVTZXR0aW5ncy5TSEFQRVMuUE9MWSB8fCBzaGFwZS5jbG9zZVN0cm9rZTtcclxuICAgICAgICB2YXIgY2xvc2VkUGF0aCA9IGZpcnN0UG9pbnQueCA9PT0gbGFzdFBvaW50LnggJiYgZmlyc3RQb2ludC55ID09PSBsYXN0UG9pbnQueTtcclxuICAgICAgICAvLyBpZiB0aGUgZmlyc3QgcG9pbnQgaXMgdGhlIGxhc3QgcG9pbnQgLSBnb25uYSBoYXZlIGlzc3VlcyA6KVxyXG4gICAgICAgIGlmIChjbG9zZWRTaGFwZSkge1xyXG4gICAgICAgICAgICAvLyBuZWVkIHRvIGNsb25lIGFzIHdlIGFyZSBnb2luZyB0byBzbGlnaHRseSBtb2RpZnkgdGhlIHNoYXBlLi5cclxuICAgICAgICAgICAgcG9pbnRzID0gcG9pbnRzLnNsaWNlKCk7XHJcbiAgICAgICAgICAgIGlmIChjbG9zZWRQYXRoKSB7XHJcbiAgICAgICAgICAgICAgICBwb2ludHMucG9wKCk7XHJcbiAgICAgICAgICAgICAgICBwb2ludHMucG9wKCk7XHJcbiAgICAgICAgICAgICAgICBsYXN0UG9pbnQuc2V0KHBvaW50c1twb2ludHMubGVuZ3RoIC0gMl0sIHBvaW50c1twb2ludHMubGVuZ3RoIC0gMV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBtaWRQb2ludFggPSBsYXN0UG9pbnQueCArICgoZmlyc3RQb2ludC54IC0gbGFzdFBvaW50LngpICogMC41KTtcclxuICAgICAgICAgICAgdmFyIG1pZFBvaW50WSA9IGxhc3RQb2ludC55ICsgKChmaXJzdFBvaW50LnkgLSBsYXN0UG9pbnQueSkgKiAwLjUpO1xyXG4gICAgICAgICAgICBwb2ludHMudW5zaGlmdChtaWRQb2ludFgsIG1pZFBvaW50WSk7XHJcbiAgICAgICAgICAgIHBvaW50cy5wdXNoKG1pZFBvaW50WCwgbWlkUG9pbnRZKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHZlcnRzID0gZ3JhcGhpY3NHZW9tZXRyeS5wb2ludHM7XHJcbiAgICAgICAgdmFyIGxlbmd0aCA9IHBvaW50cy5sZW5ndGggLyAyO1xyXG4gICAgICAgIHZhciBpbmRleENvdW50ID0gcG9pbnRzLmxlbmd0aDtcclxuICAgICAgICB2YXIgaW5kZXhTdGFydCA9IHZlcnRzLmxlbmd0aCAvIDI7XHJcbiAgICAgICAgLy8gRFJBVyB0aGUgTGluZVxyXG4gICAgICAgIHZhciB3aWR0aCA9IHN0eWxlLndpZHRoIC8gMjtcclxuICAgICAgICAvLyBzb3J0IGNvbG9yXHJcbiAgICAgICAgdmFyIHAxeCA9IHBvaW50c1swXTtcclxuICAgICAgICB2YXIgcDF5ID0gcG9pbnRzWzFdO1xyXG4gICAgICAgIHZhciBwMnggPSBwb2ludHNbMl07XHJcbiAgICAgICAgdmFyIHAyeSA9IHBvaW50c1szXTtcclxuICAgICAgICB2YXIgcDN4ID0gMDtcclxuICAgICAgICB2YXIgcDN5ID0gMDtcclxuICAgICAgICB2YXIgcGVycHggPSAtKHAxeSAtIHAyeSk7XHJcbiAgICAgICAgdmFyIHBlcnB5ID0gcDF4IC0gcDJ4O1xyXG4gICAgICAgIHZhciBwZXJwMnggPSAwO1xyXG4gICAgICAgIHZhciBwZXJwMnkgPSAwO1xyXG4gICAgICAgIHZhciBwZXJwM3ggPSAwO1xyXG4gICAgICAgIHZhciBwZXJwM3kgPSAwO1xyXG4gICAgICAgIHZhciBkaXN0ID0gTWF0aC5zcXJ0KChwZXJweCAqIHBlcnB4KSArIChwZXJweSAqIHBlcnB5KSk7XHJcbiAgICAgICAgcGVycHggLz0gZGlzdDtcclxuICAgICAgICBwZXJweSAvPSBkaXN0O1xyXG4gICAgICAgIHBlcnB4ICo9IHdpZHRoO1xyXG4gICAgICAgIHBlcnB5ICo9IHdpZHRoO1xyXG4gICAgICAgIHZhciByYXRpbyA9IHN0eWxlLmFsaWdubWVudDsgLy8gMC41O1xyXG4gICAgICAgIHZhciByMSA9ICgxIC0gcmF0aW8pICogMjtcclxuICAgICAgICB2YXIgcjIgPSByYXRpbyAqIDI7XHJcbiAgICAgICAgLy8gc3RhcnRcclxuICAgICAgICB2ZXJ0cy5wdXNoKHAxeCAtIChwZXJweCAqIHIxKSwgcDF5IC0gKHBlcnB5ICogcjEpKTtcclxuICAgICAgICB2ZXJ0cy5wdXNoKHAxeCArIChwZXJweCAqIHIyKSwgcDF5ICsgKHBlcnB5ICogcjIpKTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGxlbmd0aCAtIDE7ICsraSkge1xyXG4gICAgICAgICAgICBwMXggPSBwb2ludHNbKGkgLSAxKSAqIDJdO1xyXG4gICAgICAgICAgICBwMXkgPSBwb2ludHNbKChpIC0gMSkgKiAyKSArIDFdO1xyXG4gICAgICAgICAgICBwMnggPSBwb2ludHNbaSAqIDJdO1xyXG4gICAgICAgICAgICBwMnkgPSBwb2ludHNbKGkgKiAyKSArIDFdO1xyXG4gICAgICAgICAgICBwM3ggPSBwb2ludHNbKGkgKyAxKSAqIDJdO1xyXG4gICAgICAgICAgICBwM3kgPSBwb2ludHNbKChpICsgMSkgKiAyKSArIDFdO1xyXG4gICAgICAgICAgICBwZXJweCA9IC0ocDF5IC0gcDJ5KTtcclxuICAgICAgICAgICAgcGVycHkgPSBwMXggLSBwMng7XHJcbiAgICAgICAgICAgIGRpc3QgPSBNYXRoLnNxcnQoKHBlcnB4ICogcGVycHgpICsgKHBlcnB5ICogcGVycHkpKTtcclxuICAgICAgICAgICAgcGVycHggLz0gZGlzdDtcclxuICAgICAgICAgICAgcGVycHkgLz0gZGlzdDtcclxuICAgICAgICAgICAgcGVycHggKj0gd2lkdGg7XHJcbiAgICAgICAgICAgIHBlcnB5ICo9IHdpZHRoO1xyXG4gICAgICAgICAgICBwZXJwMnggPSAtKHAyeSAtIHAzeSk7XHJcbiAgICAgICAgICAgIHBlcnAyeSA9IHAyeCAtIHAzeDtcclxuICAgICAgICAgICAgZGlzdCA9IE1hdGguc3FydCgocGVycDJ4ICogcGVycDJ4KSArIChwZXJwMnkgKiBwZXJwMnkpKTtcclxuICAgICAgICAgICAgcGVycDJ4IC89IGRpc3Q7XHJcbiAgICAgICAgICAgIHBlcnAyeSAvPSBkaXN0O1xyXG4gICAgICAgICAgICBwZXJwMnggKj0gd2lkdGg7XHJcbiAgICAgICAgICAgIHBlcnAyeSAqPSB3aWR0aDtcclxuICAgICAgICAgICAgdmFyIGExID0gKC1wZXJweSArIHAxeSkgLSAoLXBlcnB5ICsgcDJ5KTtcclxuICAgICAgICAgICAgdmFyIGIxID0gKC1wZXJweCArIHAyeCkgLSAoLXBlcnB4ICsgcDF4KTtcclxuICAgICAgICAgICAgdmFyIGMxID0gKCgtcGVycHggKyBwMXgpICogKC1wZXJweSArIHAyeSkpIC0gKCgtcGVycHggKyBwMngpICogKC1wZXJweSArIHAxeSkpO1xyXG4gICAgICAgICAgICB2YXIgYTIgPSAoLXBlcnAyeSArIHAzeSkgLSAoLXBlcnAyeSArIHAyeSk7XHJcbiAgICAgICAgICAgIHZhciBiMiA9ICgtcGVycDJ4ICsgcDJ4KSAtICgtcGVycDJ4ICsgcDN4KTtcclxuICAgICAgICAgICAgdmFyIGMyID0gKCgtcGVycDJ4ICsgcDN4KSAqICgtcGVycDJ5ICsgcDJ5KSkgLSAoKC1wZXJwMnggKyBwMngpICogKC1wZXJwMnkgKyBwM3kpKTtcclxuICAgICAgICAgICAgdmFyIGRlbm9tID0gKGExICogYjIpIC0gKGEyICogYjEpO1xyXG4gICAgICAgICAgICBpZiAoTWF0aC5hYnMoZGVub20pIDwgMC4xKSB7XHJcbiAgICAgICAgICAgICAgICBkZW5vbSArPSAxMC4xO1xyXG4gICAgICAgICAgICAgICAgdmVydHMucHVzaChwMnggLSAocGVycHggKiByMSksIHAyeSAtIChwZXJweSAqIHIxKSk7XHJcbiAgICAgICAgICAgICAgICB2ZXJ0cy5wdXNoKHAyeCArIChwZXJweCAqIHIyKSwgcDJ5ICsgKHBlcnB5ICogcjIpKTtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBweCA9ICgoYjEgKiBjMikgLSAoYjIgKiBjMSkpIC8gZGVub207XHJcbiAgICAgICAgICAgIHZhciBweSA9ICgoYTIgKiBjMSkgLSAoYTEgKiBjMikpIC8gZGVub207XHJcbiAgICAgICAgICAgIHZhciBwZGlzdCA9ICgocHggLSBwMngpICogKHB4IC0gcDJ4KSkgKyAoKHB5IC0gcDJ5KSAqIChweSAtIHAyeSkpO1xyXG4gICAgICAgICAgICBpZiAocGRpc3QgPiAoMTk2ICogd2lkdGggKiB3aWR0aCkpIHtcclxuICAgICAgICAgICAgICAgIHBlcnAzeCA9IHBlcnB4IC0gcGVycDJ4O1xyXG4gICAgICAgICAgICAgICAgcGVycDN5ID0gcGVycHkgLSBwZXJwMnk7XHJcbiAgICAgICAgICAgICAgICBkaXN0ID0gTWF0aC5zcXJ0KChwZXJwM3ggKiBwZXJwM3gpICsgKHBlcnAzeSAqIHBlcnAzeSkpO1xyXG4gICAgICAgICAgICAgICAgcGVycDN4IC89IGRpc3Q7XHJcbiAgICAgICAgICAgICAgICBwZXJwM3kgLz0gZGlzdDtcclxuICAgICAgICAgICAgICAgIHBlcnAzeCAqPSB3aWR0aDtcclxuICAgICAgICAgICAgICAgIHBlcnAzeSAqPSB3aWR0aDtcclxuICAgICAgICAgICAgICAgIHZlcnRzLnB1c2gocDJ4IC0gKHBlcnAzeCAqIHIxKSwgcDJ5IC0gKHBlcnAzeSAqIHIxKSk7XHJcbiAgICAgICAgICAgICAgICB2ZXJ0cy5wdXNoKHAyeCArIChwZXJwM3ggKiByMiksIHAyeSArIChwZXJwM3kgKiByMikpO1xyXG4gICAgICAgICAgICAgICAgdmVydHMucHVzaChwMnggLSAocGVycDN4ICogcjIgKiByMSksIHAyeSAtIChwZXJwM3kgKiByMSkpO1xyXG4gICAgICAgICAgICAgICAgaW5kZXhDb3VudCsrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmVydHMucHVzaChwMnggKyAoKHB4IC0gcDJ4KSAqIHIxKSwgcDJ5ICsgKChweSAtIHAyeSkgKiByMSkpO1xyXG4gICAgICAgICAgICAgICAgdmVydHMucHVzaChwMnggLSAoKHB4IC0gcDJ4KSAqIHIyKSwgcDJ5IC0gKChweSAtIHAyeSkgKiByMikpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHAxeCA9IHBvaW50c1sobGVuZ3RoIC0gMikgKiAyXTtcclxuICAgICAgICBwMXkgPSBwb2ludHNbKChsZW5ndGggLSAyKSAqIDIpICsgMV07XHJcbiAgICAgICAgcDJ4ID0gcG9pbnRzWyhsZW5ndGggLSAxKSAqIDJdO1xyXG4gICAgICAgIHAyeSA9IHBvaW50c1soKGxlbmd0aCAtIDEpICogMikgKyAxXTtcclxuICAgICAgICBwZXJweCA9IC0ocDF5IC0gcDJ5KTtcclxuICAgICAgICBwZXJweSA9IHAxeCAtIHAyeDtcclxuICAgICAgICBkaXN0ID0gTWF0aC5zcXJ0KChwZXJweCAqIHBlcnB4KSArIChwZXJweSAqIHBlcnB5KSk7XHJcbiAgICAgICAgcGVycHggLz0gZGlzdDtcclxuICAgICAgICBwZXJweSAvPSBkaXN0O1xyXG4gICAgICAgIHBlcnB4ICo9IHdpZHRoO1xyXG4gICAgICAgIHBlcnB5ICo9IHdpZHRoO1xyXG4gICAgICAgIHZlcnRzLnB1c2gocDJ4IC0gKHBlcnB4ICogcjEpLCBwMnkgLSAocGVycHkgKiByMSkpO1xyXG4gICAgICAgIHZlcnRzLnB1c2gocDJ4ICsgKHBlcnB4ICogcjIpLCBwMnkgKyAocGVycHkgKiByMikpO1xyXG4gICAgICAgIHZhciBpbmRpY2VzID0gZ3JhcGhpY3NHZW9tZXRyeS5pbmRpY2VzO1xyXG4gICAgICAgIC8vIGluZGljZXMucHVzaChpbmRleFN0YXJ0KTtcclxuICAgICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBpbmRleENvdW50IC0gMjsgKytpJDEpIHtcclxuICAgICAgICAgICAgaW5kaWNlcy5wdXNoKGluZGV4U3RhcnQsIGluZGV4U3RhcnQgKyAxLCBpbmRleFN0YXJ0ICsgMik7XHJcbiAgICAgICAgICAgIGluZGV4U3RhcnQrKztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZWFyY3V0KGRhdGEsIGhvbGVJbmRpY2VzLCBkaW0pIHtcclxuICAgICAgICBkaW0gPSBkaW0gfHwgMjtcclxuICAgICAgICB2YXIgaGFzSG9sZXMgPSBob2xlSW5kaWNlcyAmJiBob2xlSW5kaWNlcy5sZW5ndGgsIG91dGVyTGVuID0gaGFzSG9sZXMgPyBob2xlSW5kaWNlc1swXSAqIGRpbSA6IGRhdGEubGVuZ3RoLCBvdXRlck5vZGUgPSBHcmFwaGljc0dlb21ldHJ5LmxpbmtlZExpc3QoZGF0YSwgMCwgb3V0ZXJMZW4sIGRpbSwgdHJ1ZSksIHRyaWFuZ2xlcyA9IFtdO1xyXG4gICAgICAgIGlmICghb3V0ZXJOb2RlIHx8IG91dGVyTm9kZS5uZXh0ID09PSBvdXRlck5vZGUucHJldikge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJpYW5nbGVzO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbWluWCwgbWluWSwgbWF4WCwgbWF4WSwgeCwgeSwgaW52U2l6ZTtcclxuICAgICAgICBpZiAoaGFzSG9sZXMpIHtcclxuICAgICAgICAgICAgb3V0ZXJOb2RlID0gR3JhcGhpY3NHZW9tZXRyeS5lbGltaW5hdGVIb2xlcyhkYXRhLCBob2xlSW5kaWNlcywgb3V0ZXJOb2RlLCBkaW0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBpZiB0aGUgc2hhcGUgaXMgbm90IHRvbyBzaW1wbGUsIHdlJ2xsIHVzZSB6LW9yZGVyIGN1cnZlIGhhc2ggbGF0ZXI7IGNhbGN1bGF0ZSBwb2x5Z29uIGJib3hcclxuICAgICAgICBpZiAoZGF0YS5sZW5ndGggPiA4MCAqIGRpbSkge1xyXG4gICAgICAgICAgICBtaW5YID0gbWF4WCA9IGRhdGFbMF07XHJcbiAgICAgICAgICAgIG1pblkgPSBtYXhZID0gZGF0YVsxXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IGRpbTsgaSA8IG91dGVyTGVuOyBpICs9IGRpbSkge1xyXG4gICAgICAgICAgICAgICAgeCA9IGRhdGFbaV07XHJcbiAgICAgICAgICAgICAgICB5ID0gZGF0YVtpICsgMV07XHJcbiAgICAgICAgICAgICAgICBpZiAoeCA8IG1pblgpIHtcclxuICAgICAgICAgICAgICAgICAgICBtaW5YID0geDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh5IDwgbWluWSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG1pblkgPSB5O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHggPiBtYXhYKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWF4WCA9IHg7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoeSA+IG1heFkpIHtcclxuICAgICAgICAgICAgICAgICAgICBtYXhZID0geTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBtaW5YLCBtaW5ZIGFuZCBpbnZTaXplIGFyZSBsYXRlciB1c2VkIHRvIHRyYW5zZm9ybSBjb29yZHMgaW50byBpbnRlZ2VycyBmb3Igei1vcmRlciBjYWxjdWxhdGlvblxyXG4gICAgICAgICAgICBpbnZTaXplID0gTWF0aC5tYXgobWF4WCAtIG1pblgsIG1heFkgLSBtaW5ZKTtcclxuICAgICAgICAgICAgaW52U2l6ZSA9IGludlNpemUgIT09IDAgPyAxIC8gaW52U2l6ZSA6IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIEdyYXBoaWNzR2VvbWV0cnkuZWFyY3V0TGlua2VkKG91dGVyTm9kZSwgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIGludlNpemUpO1xyXG4gICAgICAgIHJldHVybiB0cmlhbmdsZXM7XHJcbiAgICB9XHJcbiAgICAvLyBjcmVhdGUgYSBjaXJjdWxhciBkb3VibHkgbGlua2VkIGxpc3QgZnJvbSBwb2x5Z29uIHBvaW50cyBpbiB0aGUgc3BlY2lmaWVkIHdpbmRpbmcgb3JkZXJcclxuICAgIHN0YXRpYyBsaW5rZWRMaXN0KGRhdGEsIHN0YXJ0LCBlbmQsIGRpbSwgY2xvY2t3aXNlKSB7XHJcbiAgICAgICAgdmFyIGksIGxhc3Q7XHJcbiAgICAgICAgaWYgKGNsb2Nrd2lzZSA9PT0gKEdyYXBoaWNzR2VvbWV0cnkuc2lnbmVkQXJlYShkYXRhLCBzdGFydCwgZW5kLCBkaW0pID4gMCkpIHtcclxuICAgICAgICAgICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gZGltKSB7XHJcbiAgICAgICAgICAgICAgICBsYXN0ID0gR3JhcGhpY3NHZW9tZXRyeS5pbnNlcnROb2RlKGksIGRhdGFbaV0sIGRhdGFbaSArIDFdLCBsYXN0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZm9yIChpID0gZW5kIC0gZGltOyBpID49IHN0YXJ0OyBpIC09IGRpbSkge1xyXG4gICAgICAgICAgICAgICAgbGFzdCA9IEdyYXBoaWNzR2VvbWV0cnkuaW5zZXJ0Tm9kZShpLCBkYXRhW2ldLCBkYXRhW2kgKyAxXSwgbGFzdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGxhc3QgJiYgR3JhcGhpY3NHZW9tZXRyeS5lcXVhbHMobGFzdCwgbGFzdC5uZXh0KSkge1xyXG4gICAgICAgICAgICBHcmFwaGljc0dlb21ldHJ5LnJlbW92ZU5vZGUobGFzdCk7XHJcbiAgICAgICAgICAgIGxhc3QgPSBsYXN0Lm5leHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBsYXN0O1xyXG4gICAgfVxyXG4gICAgLy8gbGluayBldmVyeSBob2xlIGludG8gdGhlIG91dGVyIGxvb3AsIHByb2R1Y2luZyBhIHNpbmdsZS1yaW5nIHBvbHlnb24gd2l0aG91dCBob2xlc1xyXG4gICAgc3RhdGljIGVsaW1pbmF0ZUhvbGVzKGRhdGEsIGhvbGVJbmRpY2VzLCBvdXRlck5vZGUsIGRpbSkge1xyXG4gICAgICAgIHZhciBxdWV1ZSA9IFtdLCBpLCBsZW4sIHN0YXJ0LCBlbmQsIGxpc3Q7XHJcbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gaG9sZUluZGljZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgc3RhcnQgPSBob2xlSW5kaWNlc1tpXSAqIGRpbTtcclxuICAgICAgICAgICAgZW5kID0gaSA8IGxlbiAtIDEgPyBob2xlSW5kaWNlc1tpICsgMV0gKiBkaW0gOiBkYXRhLmxlbmd0aDtcclxuICAgICAgICAgICAgbGlzdCA9IEdyYXBoaWNzR2VvbWV0cnkubGlua2VkTGlzdChkYXRhLCBzdGFydCwgZW5kLCBkaW0sIGZhbHNlKTtcclxuICAgICAgICAgICAgaWYgKGxpc3QgPT09IGxpc3QubmV4dCkge1xyXG4gICAgICAgICAgICAgICAgbGlzdC5zdGVpbmVyID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBxdWV1ZS5wdXNoKEdyYXBoaWNzR2VvbWV0cnkuZ2V0TGVmdG1vc3QobGlzdCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBxdWV1ZS5zb3J0KEdyYXBoaWNzR2VvbWV0cnkuY29tcGFyZVgpO1xyXG4gICAgICAgIC8vIHByb2Nlc3MgaG9sZXMgZnJvbSBsZWZ0IHRvIHJpZ2h0XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIEdyYXBoaWNzR2VvbWV0cnkuZWxpbWluYXRlSG9sZShxdWV1ZVtpXSwgb3V0ZXJOb2RlKTtcclxuICAgICAgICAgICAgb3V0ZXJOb2RlID0gR3JhcGhpY3NHZW9tZXRyeS5maWx0ZXJQb2ludHMob3V0ZXJOb2RlLCBvdXRlck5vZGUubmV4dCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBvdXRlck5vZGU7XHJcbiAgICB9XHJcbiAgICAvLyBtYWluIGVhciBzbGljaW5nIGxvb3Agd2hpY2ggdHJpYW5ndWxhdGVzIGEgcG9seWdvbiAoZ2l2ZW4gYXMgYSBsaW5rZWQgbGlzdClcclxuICAgIHN0YXRpYyBlYXJjdXRMaW5rZWQoZWFyLCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgaW52U2l6ZSwgcGFzcyA9IG51bGwpIHtcclxuICAgICAgICBpZiAoIWVhcikge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGludGVybGluayBwb2x5Z29uIG5vZGVzIGluIHotb3JkZXJcclxuICAgICAgICBpZiAoIXBhc3MgJiYgaW52U2l6ZSkge1xyXG4gICAgICAgICAgICBHcmFwaGljc0dlb21ldHJ5LmluZGV4Q3VydmUoZWFyLCBtaW5YLCBtaW5ZLCBpbnZTaXplKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHN0b3AgPSBlYXIsIHByZXYsIG5leHQ7XHJcbiAgICAgICAgLy8gaXRlcmF0ZSB0aHJvdWdoIGVhcnMsIHNsaWNpbmcgdGhlbSBvbmUgYnkgb25lXHJcbiAgICAgICAgd2hpbGUgKGVhci5wcmV2ICE9PSBlYXIubmV4dCkge1xyXG4gICAgICAgICAgICBwcmV2ID0gZWFyLnByZXY7XHJcbiAgICAgICAgICAgIG5leHQgPSBlYXIubmV4dDtcclxuICAgICAgICAgICAgaWYgKGludlNpemUgPyBHcmFwaGljc0dlb21ldHJ5LmlzRWFySGFzaGVkKGVhciwgbWluWCwgbWluWSwgaW52U2l6ZSkgOiBHcmFwaGljc0dlb21ldHJ5LmlzRWFyKGVhcikpIHtcclxuICAgICAgICAgICAgICAgIC8vIGN1dCBvZmYgdGhlIHRyaWFuZ2xlXHJcbiAgICAgICAgICAgICAgICB0cmlhbmdsZXMucHVzaChwcmV2LmkgLyBkaW0pO1xyXG4gICAgICAgICAgICAgICAgdHJpYW5nbGVzLnB1c2goZWFyLmkgLyBkaW0pO1xyXG4gICAgICAgICAgICAgICAgdHJpYW5nbGVzLnB1c2gobmV4dC5pIC8gZGltKTtcclxuICAgICAgICAgICAgICAgIEdyYXBoaWNzR2VvbWV0cnkucmVtb3ZlTm9kZShlYXIpO1xyXG4gICAgICAgICAgICAgICAgLy8gc2tpcHBpbmcgdGhlIG5leHQgdmVydGV4IGxlYWRzIHRvIGxlc3Mgc2xpdmVyIHRyaWFuZ2xlc1xyXG4gICAgICAgICAgICAgICAgZWFyID0gbmV4dC5uZXh0O1xyXG4gICAgICAgICAgICAgICAgc3RvcCA9IG5leHQubmV4dDtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVhciA9IG5leHQ7XHJcbiAgICAgICAgICAgIC8vIGlmIHdlIGxvb3BlZCB0aHJvdWdoIHRoZSB3aG9sZSByZW1haW5pbmcgcG9seWdvbiBhbmQgY2FuJ3QgZmluZCBhbnkgbW9yZSBlYXJzXHJcbiAgICAgICAgICAgIGlmIChlYXIgPT09IHN0b3ApIHtcclxuICAgICAgICAgICAgICAgIC8vIHRyeSBmaWx0ZXJpbmcgcG9pbnRzIGFuZCBzbGljaW5nIGFnYWluXHJcbiAgICAgICAgICAgICAgICBpZiAoIXBhc3MpIHtcclxuICAgICAgICAgICAgICAgICAgICBHcmFwaGljc0dlb21ldHJ5LmVhcmN1dExpbmtlZChHcmFwaGljc0dlb21ldHJ5LmZpbHRlclBvaW50cyhlYXIpLCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgaW52U2l6ZSwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhpcyBkaWRuJ3Qgd29yaywgdHJ5IGN1cmluZyBhbGwgc21hbGwgc2VsZi1pbnRlcnNlY3Rpb25zIGxvY2FsbHlcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBhc3MgPT09IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICBlYXIgPSBHcmFwaGljc0dlb21ldHJ5LmN1cmVMb2NhbEludGVyc2VjdGlvbnMoZWFyLCB0cmlhbmdsZXMsIGRpbSk7XHJcbiAgICAgICAgICAgICAgICAgICAgR3JhcGhpY3NHZW9tZXRyeS5lYXJjdXRMaW5rZWQoZWFyLCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgaW52U2l6ZSwgMik7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYXMgYSBsYXN0IHJlc29ydCwgdHJ5IHNwbGl0dGluZyB0aGUgcmVtYWluaW5nIHBvbHlnb24gaW50byB0d29cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBhc3MgPT09IDIpIHtcclxuICAgICAgICAgICAgICAgICAgICBHcmFwaGljc0dlb21ldHJ5LnNwbGl0RWFyY3V0KGVhciwgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIGludlNpemUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgc2lnbmVkQXJlYShkYXRhLCBzdGFydCwgZW5kLCBkaW0pIHtcclxuICAgICAgICB2YXIgc3VtID0gMDtcclxuICAgICAgICBmb3IgKHZhciBpID0gc3RhcnQsIGogPSBlbmQgLSBkaW07IGkgPCBlbmQ7IGkgKz0gZGltKSB7XHJcbiAgICAgICAgICAgIHN1bSArPSAoZGF0YVtqXSAtIGRhdGFbaV0pICogKGRhdGFbaSArIDFdICsgZGF0YVtqICsgMV0pO1xyXG4gICAgICAgICAgICBqID0gaTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHN1bTtcclxuICAgIH1cclxuICAgIC8vIGNyZWF0ZSBhIG5vZGUgYW5kIG9wdGlvbmFsbHkgbGluayBpdCB3aXRoIHByZXZpb3VzIG9uZSAoaW4gYSBjaXJjdWxhciBkb3VibHkgbGlua2VkIGxpc3QpXHJcbiAgICBzdGF0aWMgaW5zZXJ0Tm9kZShpLCB4LCB5LCBsYXN0KSB7XHJcbiAgICAgICAgdmFyIHAgPSBuZXcgTm9kZShpLCB4LCB5KTtcclxuICAgICAgICBpZiAoIWxhc3QpIHtcclxuICAgICAgICAgICAgcC5wcmV2ID0gcDtcclxuICAgICAgICAgICAgcC5uZXh0ID0gcDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHAubmV4dCA9IGxhc3QubmV4dDtcclxuICAgICAgICAgICAgcC5wcmV2ID0gbGFzdDtcclxuICAgICAgICAgICAgbGFzdC5uZXh0LnByZXYgPSBwO1xyXG4gICAgICAgICAgICBsYXN0Lm5leHQgPSBwO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcDtcclxuICAgIH1cclxuICAgIC8vIGNoZWNrIGlmIHR3byBwb2ludHMgYXJlIGVxdWFsXHJcbiAgICBzdGF0aWMgZXF1YWxzKHAxLCBwMikge1xyXG4gICAgICAgIHJldHVybiBwMS54ID09PSBwMi54ICYmIHAxLnkgPT09IHAyLnk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgcmVtb3ZlTm9kZShwKSB7XHJcbiAgICAgICAgcC5uZXh0LnByZXYgPSBwLnByZXY7XHJcbiAgICAgICAgcC5wcmV2Lm5leHQgPSBwLm5leHQ7XHJcbiAgICAgICAgaWYgKHAucHJldlopIHtcclxuICAgICAgICAgICAgcC5wcmV2Wi5uZXh0WiA9IHAubmV4dFo7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwLm5leHRaKSB7XHJcbiAgICAgICAgICAgIHAubmV4dFoucHJldlogPSBwLnByZXZaO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIGZpbmQgdGhlIGxlZnRtb3N0IG5vZGUgb2YgYSBwb2x5Z29uIHJpbmdcclxuICAgIHN0YXRpYyBnZXRMZWZ0bW9zdChzdGFydCkge1xyXG4gICAgICAgIHZhciBwID0gc3RhcnQsIGxlZnRtb3N0ID0gc3RhcnQ7XHJcbiAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICBpZiAocC54IDwgbGVmdG1vc3QueCB8fCAocC54ID09PSBsZWZ0bW9zdC54ICYmIHAueSA8IGxlZnRtb3N0LnkpKSB7XHJcbiAgICAgICAgICAgICAgICBsZWZ0bW9zdCA9IHA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcCA9IHAubmV4dDtcclxuICAgICAgICB9IHdoaWxlIChwICE9PSBzdGFydCk7XHJcbiAgICAgICAgcmV0dXJuIGxlZnRtb3N0O1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGNvbXBhcmVYKGEsIGIpIHtcclxuICAgICAgICByZXR1cm4gYS54IC0gYi54O1xyXG4gICAgfVxyXG4gICAgLy8gZmluZCBhIGJyaWRnZSBiZXR3ZWVuIHZlcnRpY2VzIHRoYXQgY29ubmVjdHMgaG9sZSB3aXRoIGFuIG91dGVyIHJpbmcgYW5kIGFuZCBsaW5rIGl0XHJcbiAgICBzdGF0aWMgZWxpbWluYXRlSG9sZShob2xlLCBvdXRlck5vZGUpIHtcclxuICAgICAgICBvdXRlck5vZGUgPSBHcmFwaGljc0dlb21ldHJ5LmZpbmRIb2xlQnJpZGdlKGhvbGUsIG91dGVyTm9kZSk7XHJcbiAgICAgICAgaWYgKG91dGVyTm9kZSkge1xyXG4gICAgICAgICAgICB2YXIgYiA9IEdyYXBoaWNzR2VvbWV0cnkuc3BsaXRQb2x5Z29uKG91dGVyTm9kZSwgaG9sZSk7XHJcbiAgICAgICAgICAgIEdyYXBoaWNzR2VvbWV0cnkuZmlsdGVyUG9pbnRzKGIsIGIubmV4dCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gZWxpbWluYXRlIGNvbGluZWFyIG9yIGR1cGxpY2F0ZSBwb2ludHNcclxuICAgIHN0YXRpYyBmaWx0ZXJQb2ludHMoc3RhcnQsIGVuZCA9IG51bGwpIHtcclxuICAgICAgICBpZiAoIXN0YXJ0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzdGFydDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFlbmQpIHtcclxuICAgICAgICAgICAgZW5kID0gc3RhcnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBwID0gc3RhcnQsIGFnYWluO1xyXG4gICAgICAgIGRvIHtcclxuICAgICAgICAgICAgYWdhaW4gPSBmYWxzZTtcclxuICAgICAgICAgICAgaWYgKCFwLnN0ZWluZXIgJiYgKEdyYXBoaWNzR2VvbWV0cnkuZXF1YWxzKHAsIHAubmV4dCkgfHwgR3JhcGhpY3NHZW9tZXRyeS5hcmVhKHAucHJldiwgcCwgcC5uZXh0KSA9PT0gMCkpIHtcclxuICAgICAgICAgICAgICAgIEdyYXBoaWNzR2VvbWV0cnkucmVtb3ZlTm9kZShwKTtcclxuICAgICAgICAgICAgICAgIHAgPSBlbmQgPSBwLnByZXY7XHJcbiAgICAgICAgICAgICAgICBpZiAocCA9PT0gcC5uZXh0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBhZ2FpbiA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBwID0gcC5uZXh0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSB3aGlsZSAoYWdhaW4gfHwgcCAhPT0gZW5kKTtcclxuICAgICAgICByZXR1cm4gZW5kO1xyXG4gICAgfVxyXG4gICAgLy8gc2lnbmVkIGFyZWEgb2YgYSB0cmlhbmdsZVxyXG4gICAgc3RhdGljIGFyZWEocCwgcSwgcikge1xyXG4gICAgICAgIHJldHVybiAocS55IC0gcC55KSAqIChyLnggLSBxLngpIC0gKHEueCAtIHAueCkgKiAoci55IC0gcS55KTtcclxuICAgIH1cclxuICAgIC8vIGxpbmsgdHdvIHBvbHlnb24gdmVydGljZXMgd2l0aCBhIGJyaWRnZTsgaWYgdGhlIHZlcnRpY2VzIGJlbG9uZyB0byB0aGUgc2FtZSByaW5nLCBpdCBzcGxpdHMgcG9seWdvbiBpbnRvIHR3bztcclxuICAgIC8vIGlmIG9uZSBiZWxvbmdzIHRvIHRoZSBvdXRlciByaW5nIGFuZCBhbm90aGVyIHRvIGEgaG9sZSwgaXQgbWVyZ2VzIGl0IGludG8gYSBzaW5nbGUgcmluZ1xyXG4gICAgc3RhdGljIHNwbGl0UG9seWdvbihhLCBiKSB7XHJcbiAgICAgICAgdmFyIGEyID0gbmV3IE5vZGUoYS5pLCBhLngsIGEueSksIGIyID0gbmV3IE5vZGUoYi5pLCBiLngsIGIueSksIGFuID0gYS5uZXh0LCBicCA9IGIucHJldjtcclxuICAgICAgICBhLm5leHQgPSBiO1xyXG4gICAgICAgIGIucHJldiA9IGE7XHJcbiAgICAgICAgYTIubmV4dCA9IGFuO1xyXG4gICAgICAgIGFuLnByZXYgPSBhMjtcclxuICAgICAgICBiMi5uZXh0ID0gYTI7XHJcbiAgICAgICAgYTIucHJldiA9IGIyO1xyXG4gICAgICAgIGJwLm5leHQgPSBiMjtcclxuICAgICAgICBiMi5wcmV2ID0gYnA7XHJcbiAgICAgICAgcmV0dXJuIGIyO1xyXG4gICAgfVxyXG4gICAgLy8gRGF2aWQgRWJlcmx5J3MgYWxnb3JpdGhtIGZvciBmaW5kaW5nIGEgYnJpZGdlIGJldHdlZW4gaG9sZSBhbmQgb3V0ZXIgcG9seWdvblxyXG4gICAgc3RhdGljIGZpbmRIb2xlQnJpZGdlKGhvbGUsIG91dGVyTm9kZSkge1xyXG4gICAgICAgIHZhciBwID0gb3V0ZXJOb2RlLCBoeCA9IGhvbGUueCwgaHkgPSBob2xlLnksIHF4ID0gLUluZmluaXR5LCBtO1xyXG4gICAgICAgIC8vIGZpbmQgYSBzZWdtZW50IGludGVyc2VjdGVkIGJ5IGEgcmF5IGZyb20gdGhlIGhvbGUncyBsZWZ0bW9zdCBwb2ludCB0byB0aGUgbGVmdDtcclxuICAgICAgICAvLyBzZWdtZW50J3MgZW5kcG9pbnQgd2l0aCBsZXNzZXIgeCB3aWxsIGJlIHBvdGVudGlhbCBjb25uZWN0aW9uIHBvaW50XHJcbiAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICBpZiAoaHkgPD0gcC55ICYmIGh5ID49IHAubmV4dC55ICYmIHAubmV4dC55ICE9PSBwLnkpIHtcclxuICAgICAgICAgICAgICAgIHZhciB4ID0gcC54ICsgKGh5IC0gcC55KSAqIChwLm5leHQueCAtIHAueCkgLyAocC5uZXh0LnkgLSBwLnkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHggPD0gaHggJiYgeCA+IHF4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcXggPSB4O1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh4ID09PSBoeCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaHkgPT09IHAueSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGh5ID09PSBwLm5leHQueSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHAubmV4dDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBtID0gcC54IDwgcC5uZXh0LnggPyBwIDogcC5uZXh0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHAgPSBwLm5leHQ7XHJcbiAgICAgICAgfSB3aGlsZSAocCAhPT0gb3V0ZXJOb2RlKTtcclxuICAgICAgICBpZiAoIW0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChoeCA9PT0gcXgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG0ucHJldjtcclxuICAgICAgICB9IC8vIGhvbGUgdG91Y2hlcyBvdXRlciBzZWdtZW50OyBwaWNrIGxvd2VyIGVuZHBvaW50XHJcbiAgICAgICAgLy8gbG9vayBmb3IgcG9pbnRzIGluc2lkZSB0aGUgdHJpYW5nbGUgb2YgaG9sZSBwb2ludCwgc2VnbWVudCBpbnRlcnNlY3Rpb24gYW5kIGVuZHBvaW50O1xyXG4gICAgICAgIC8vIGlmIHRoZXJlIGFyZSBubyBwb2ludHMgZm91bmQsIHdlIGhhdmUgYSB2YWxpZCBjb25uZWN0aW9uO1xyXG4gICAgICAgIC8vIG90aGVyd2lzZSBjaG9vc2UgdGhlIHBvaW50IG9mIHRoZSBtaW5pbXVtIGFuZ2xlIHdpdGggdGhlIHJheSBhcyBjb25uZWN0aW9uIHBvaW50XHJcbiAgICAgICAgdmFyIHN0b3AgPSBtLCBteCA9IG0ueCwgbXkgPSBtLnksIHRhbk1pbiA9IEluZmluaXR5LCB0YW47XHJcbiAgICAgICAgcCA9IG0ubmV4dDtcclxuICAgICAgICB3aGlsZSAocCAhPT0gc3RvcCkge1xyXG4gICAgICAgICAgICBpZiAoaHggPj0gcC54ICYmIHAueCA+PSBteCAmJiBoeCAhPT0gcC54ICYmXHJcbiAgICAgICAgICAgICAgICBHcmFwaGljc0dlb21ldHJ5LnBvaW50SW5UcmlhbmdsZShoeSA8IG15ID8gaHggOiBxeCwgaHksIG14LCBteSwgaHkgPCBteSA/IHF4IDogaHgsIGh5LCBwLngsIHAueSkpIHtcclxuICAgICAgICAgICAgICAgIHRhbiA9IE1hdGguYWJzKGh5IC0gcC55KSAvIChoeCAtIHAueCk7IC8vIHRhbmdlbnRpYWxcclxuICAgICAgICAgICAgICAgIGlmICgodGFuIDwgdGFuTWluIHx8ICh0YW4gPT09IHRhbk1pbiAmJiBwLnggPiBtLngpKSAmJiBHcmFwaGljc0dlb21ldHJ5LmxvY2FsbHlJbnNpZGUocCwgaG9sZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBtID0gcDtcclxuICAgICAgICAgICAgICAgICAgICB0YW5NaW4gPSB0YW47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcCA9IHAubmV4dDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG07XHJcbiAgICB9XHJcbiAgICAvLyBjaGVjayBpZiBhIHBvbHlnb24gZGlhZ29uYWwgaXMgbG9jYWxseSBpbnNpZGUgdGhlIHBvbHlnb25cclxuICAgIHN0YXRpYyBsb2NhbGx5SW5zaWRlKGEsIGIpIHtcclxuICAgICAgICByZXR1cm4gR3JhcGhpY3NHZW9tZXRyeS5hcmVhKGEucHJldiwgYSwgYS5uZXh0KSA8IDAgP1xyXG4gICAgICAgICAgICBHcmFwaGljc0dlb21ldHJ5LmFyZWEoYSwgYiwgYS5uZXh0KSA+PSAwICYmIEdyYXBoaWNzR2VvbWV0cnkuYXJlYShhLCBhLnByZXYsIGIpID49IDAgOlxyXG4gICAgICAgICAgICBHcmFwaGljc0dlb21ldHJ5LmFyZWEoYSwgYiwgYS5wcmV2KSA8IDAgfHwgR3JhcGhpY3NHZW9tZXRyeS5hcmVhKGEsIGEubmV4dCwgYikgPCAwO1xyXG4gICAgfVxyXG4gICAgLy8gY2hlY2sgaWYgYSBwb2ludCBsaWVzIHdpdGhpbiBhIGNvbnZleCB0cmlhbmdsZVxyXG4gICAgc3RhdGljIHBvaW50SW5UcmlhbmdsZShheCwgYXksIGJ4LCBieSwgY3gsIGN5LCBweCwgcHkpIHtcclxuICAgICAgICByZXR1cm4gKGN4IC0gcHgpICogKGF5IC0gcHkpIC0gKGF4IC0gcHgpICogKGN5IC0gcHkpID49IDAgJiZcclxuICAgICAgICAgICAgKGF4IC0gcHgpICogKGJ5IC0gcHkpIC0gKGJ4IC0gcHgpICogKGF5IC0gcHkpID49IDAgJiZcclxuICAgICAgICAgICAgKGJ4IC0gcHgpICogKGN5IC0gcHkpIC0gKGN4IC0gcHgpICogKGJ5IC0gcHkpID49IDA7XHJcbiAgICB9XHJcbiAgICAvLyB0cnkgc3BsaXR0aW5nIHBvbHlnb24gaW50byB0d28gYW5kIHRyaWFuZ3VsYXRlIHRoZW0gaW5kZXBlbmRlbnRseVxyXG4gICAgc3RhdGljIHNwbGl0RWFyY3V0KHN0YXJ0LCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgaW52U2l6ZSkge1xyXG4gICAgICAgIC8vIGxvb2sgZm9yIGEgdmFsaWQgZGlhZ29uYWwgdGhhdCBkaXZpZGVzIHRoZSBwb2x5Z29uIGludG8gdHdvXHJcbiAgICAgICAgdmFyIGEgPSBzdGFydDtcclxuICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgIHZhciBiID0gYS5uZXh0Lm5leHQ7XHJcbiAgICAgICAgICAgIHdoaWxlIChiICE9PSBhLnByZXYpIHtcclxuICAgICAgICAgICAgICAgIGlmIChhLmkgIT09IGIuaSAmJiBHcmFwaGljc0dlb21ldHJ5LmlzVmFsaWREaWFnb25hbChhLCBiKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHNwbGl0IHRoZSBwb2x5Z29uIGluIHR3byBieSB0aGUgZGlhZ29uYWxcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYyA9IEdyYXBoaWNzR2VvbWV0cnkuc3BsaXRQb2x5Z29uKGEsIGIpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGZpbHRlciBjb2xpbmVhciBwb2ludHMgYXJvdW5kIHRoZSBjdXRzXHJcbiAgICAgICAgICAgICAgICAgICAgYSA9IEdyYXBoaWNzR2VvbWV0cnkuZmlsdGVyUG9pbnRzKGEsIGEubmV4dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYyA9IEdyYXBoaWNzR2VvbWV0cnkuZmlsdGVyUG9pbnRzKGMsIGMubmV4dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gcnVuIGVhcmN1dCBvbiBlYWNoIGhhbGZcclxuICAgICAgICAgICAgICAgICAgICBHcmFwaGljc0dlb21ldHJ5LmVhcmN1dExpbmtlZChhLCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgaW52U2l6ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgR3JhcGhpY3NHZW9tZXRyeS5lYXJjdXRMaW5rZWQoYywgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIGludlNpemUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGIgPSBiLm5leHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYSA9IGEubmV4dDtcclxuICAgICAgICB9IHdoaWxlIChhICE9PSBzdGFydCk7XHJcbiAgICB9XHJcbiAgICAvLyBjaGVjayBpZiBhIGRpYWdvbmFsIGJldHdlZW4gdHdvIHBvbHlnb24gbm9kZXMgaXMgdmFsaWQgKGxpZXMgaW4gcG9seWdvbiBpbnRlcmlvcilcclxuICAgIHN0YXRpYyBpc1ZhbGlkRGlhZ29uYWwoYSwgYikge1xyXG4gICAgICAgIHJldHVybiBhLm5leHQuaSAhPT0gYi5pICYmIGEucHJldi5pICE9PSBiLmkgJiYgIUdyYXBoaWNzR2VvbWV0cnkuaW50ZXJzZWN0c1BvbHlnb24oYSwgYikgJiZcclxuICAgICAgICAgICAgR3JhcGhpY3NHZW9tZXRyeS5sb2NhbGx5SW5zaWRlKGEsIGIpICYmIEdyYXBoaWNzR2VvbWV0cnkubG9jYWxseUluc2lkZShiLCBhKSAmJiBHcmFwaGljc0dlb21ldHJ5Lm1pZGRsZUluc2lkZShhLCBiKTtcclxuICAgIH1cclxuICAgIC8vIGNoZWNrIGlmIHRoZSBtaWRkbGUgcG9pbnQgb2YgYSBwb2x5Z29uIGRpYWdvbmFsIGlzIGluc2lkZSB0aGUgcG9seWdvblxyXG4gICAgc3RhdGljIG1pZGRsZUluc2lkZShhLCBiKSB7XHJcbiAgICAgICAgdmFyIHAgPSBhLCBpbnNpZGUgPSBmYWxzZSwgcHggPSAoYS54ICsgYi54KSAvIDIsIHB5ID0gKGEueSArIGIueSkgLyAyO1xyXG4gICAgICAgIGRvIHtcclxuICAgICAgICAgICAgaWYgKCgocC55ID4gcHkpICE9PSAocC5uZXh0LnkgPiBweSkpICYmIHAubmV4dC55ICE9PSBwLnkgJiZcclxuICAgICAgICAgICAgICAgIChweCA8IChwLm5leHQueCAtIHAueCkgKiAocHkgLSBwLnkpIC8gKHAubmV4dC55IC0gcC55KSArIHAueCkpIHtcclxuICAgICAgICAgICAgICAgIGluc2lkZSA9ICFpbnNpZGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcCA9IHAubmV4dDtcclxuICAgICAgICB9IHdoaWxlIChwICE9PSBhKTtcclxuICAgICAgICByZXR1cm4gaW5zaWRlO1xyXG4gICAgfVxyXG4gICAgLy8gY2hlY2sgaWYgYSBwb2x5Z29uIGRpYWdvbmFsIGludGVyc2VjdHMgYW55IHBvbHlnb24gc2VnbWVudHNcclxuICAgIHN0YXRpYyBpbnRlcnNlY3RzUG9seWdvbihhLCBiKSB7XHJcbiAgICAgICAgdmFyIHAgPSBhO1xyXG4gICAgICAgIGRvIHtcclxuICAgICAgICAgICAgaWYgKHAuaSAhPT0gYS5pICYmIHAubmV4dC5pICE9PSBhLmkgJiYgcC5pICE9PSBiLmkgJiYgcC5uZXh0LmkgIT09IGIuaSAmJlxyXG4gICAgICAgICAgICAgICAgR3JhcGhpY3NHZW9tZXRyeS5pbnRlcnNlY3RzKHAsIHAubmV4dCwgYSwgYikpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHAgPSBwLm5leHQ7XHJcbiAgICAgICAgfSB3aGlsZSAocCAhPT0gYSk7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgLy8gY2hlY2sgaWYgdHdvIHNlZ21lbnRzIGludGVyc2VjdFxyXG4gICAgc3RhdGljIGludGVyc2VjdHMocDEsIHExLCBwMiwgcTIpIHtcclxuICAgICAgICBpZiAoKEdyYXBoaWNzR2VvbWV0cnkuZXF1YWxzKHAxLCBxMSkgJiYgR3JhcGhpY3NHZW9tZXRyeS5lcXVhbHMocDIsIHEyKSkgfHxcclxuICAgICAgICAgICAgKEdyYXBoaWNzR2VvbWV0cnkuZXF1YWxzKHAxLCBxMikgJiYgR3JhcGhpY3NHZW9tZXRyeS5lcXVhbHMocDIsIHExKSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBHcmFwaGljc0dlb21ldHJ5LmFyZWEocDEsIHExLCBwMikgPiAwICE9PSBHcmFwaGljc0dlb21ldHJ5LmFyZWEocDEsIHExLCBxMikgPiAwICYmXHJcbiAgICAgICAgICAgIEdyYXBoaWNzR2VvbWV0cnkuYXJlYShwMiwgcTIsIHAxKSA+IDAgIT09IEdyYXBoaWNzR2VvbWV0cnkuYXJlYShwMiwgcTIsIHExKSA+IDA7XHJcbiAgICB9XHJcbiAgICAvLyBnbyB0aHJvdWdoIGFsbCBwb2x5Z29uIG5vZGVzIGFuZCBjdXJlIHNtYWxsIGxvY2FsIHNlbGYtaW50ZXJzZWN0aW9uc1xyXG4gICAgc3RhdGljIGN1cmVMb2NhbEludGVyc2VjdGlvbnMoc3RhcnQsIHRyaWFuZ2xlcywgZGltKSB7XHJcbiAgICAgICAgdmFyIHAgPSBzdGFydDtcclxuICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgIHZhciBhID0gcC5wcmV2LCBiID0gcC5uZXh0Lm5leHQ7XHJcbiAgICAgICAgICAgIGlmICghR3JhcGhpY3NHZW9tZXRyeS5lcXVhbHMoYSwgYikgJiYgR3JhcGhpY3NHZW9tZXRyeS5pbnRlcnNlY3RzKGEsIHAsIHAubmV4dCwgYikgJiYgR3JhcGhpY3NHZW9tZXRyeS5sb2NhbGx5SW5zaWRlKGEsIGIpICYmIEdyYXBoaWNzR2VvbWV0cnkubG9jYWxseUluc2lkZShiLCBhKSkge1xyXG4gICAgICAgICAgICAgICAgdHJpYW5nbGVzLnB1c2goYS5pIC8gZGltKTtcclxuICAgICAgICAgICAgICAgIHRyaWFuZ2xlcy5wdXNoKHAuaSAvIGRpbSk7XHJcbiAgICAgICAgICAgICAgICB0cmlhbmdsZXMucHVzaChiLmkgLyBkaW0pO1xyXG4gICAgICAgICAgICAgICAgLy8gcmVtb3ZlIHR3byBub2RlcyBpbnZvbHZlZFxyXG4gICAgICAgICAgICAgICAgR3JhcGhpY3NHZW9tZXRyeS5yZW1vdmVOb2RlKHApO1xyXG4gICAgICAgICAgICAgICAgR3JhcGhpY3NHZW9tZXRyeS5yZW1vdmVOb2RlKHAubmV4dCk7XHJcbiAgICAgICAgICAgICAgICBwID0gc3RhcnQgPSBiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHAgPSBwLm5leHQ7XHJcbiAgICAgICAgfSB3aGlsZSAocCAhPT0gc3RhcnQpO1xyXG4gICAgICAgIHJldHVybiBwO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGlzRWFySGFzaGVkKGVhciwgbWluWCwgbWluWSwgaW52U2l6ZSkge1xyXG4gICAgICAgIHZhciBhID0gZWFyLnByZXYsIGIgPSBlYXIsIGMgPSBlYXIubmV4dDtcclxuICAgICAgICBpZiAoR3JhcGhpY3NHZW9tZXRyeS5hcmVhKGEsIGIsIGMpID49IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH0gLy8gcmVmbGV4LCBjYW4ndCBiZSBhbiBlYXJcclxuICAgICAgICAvLyB0cmlhbmdsZSBiYm94OyBtaW4gJiBtYXggYXJlIGNhbGN1bGF0ZWQgbGlrZSB0aGlzIGZvciBzcGVlZFxyXG4gICAgICAgIHZhciBtaW5UWCA9IGEueCA8IGIueCA/IChhLnggPCBjLnggPyBhLnggOiBjLngpIDogKGIueCA8IGMueCA/IGIueCA6IGMueCksIG1pblRZID0gYS55IDwgYi55ID8gKGEueSA8IGMueSA/IGEueSA6IGMueSkgOiAoYi55IDwgYy55ID8gYi55IDogYy55KSwgbWF4VFggPSBhLnggPiBiLnggPyAoYS54ID4gYy54ID8gYS54IDogYy54KSA6IChiLnggPiBjLnggPyBiLnggOiBjLngpLCBtYXhUWSA9IGEueSA+IGIueSA/IChhLnkgPiBjLnkgPyBhLnkgOiBjLnkpIDogKGIueSA+IGMueSA/IGIueSA6IGMueSk7XHJcbiAgICAgICAgLy8gei1vcmRlciByYW5nZSBmb3IgdGhlIGN1cnJlbnQgdHJpYW5nbGUgYmJveDtcclxuICAgICAgICB2YXIgbWluWiA9IEdyYXBoaWNzR2VvbWV0cnkuek9yZGVyKG1pblRYLCBtaW5UWSwgbWluWCwgbWluWSwgaW52U2l6ZSksIG1heFogPSBHcmFwaGljc0dlb21ldHJ5LnpPcmRlcihtYXhUWCwgbWF4VFksIG1pblgsIG1pblksIGludlNpemUpO1xyXG4gICAgICAgIHZhciBwID0gZWFyLnByZXZaLCBuID0gZWFyLm5leHRaO1xyXG4gICAgICAgIC8vIGxvb2sgZm9yIHBvaW50cyBpbnNpZGUgdGhlIHRyaWFuZ2xlIGluIGJvdGggZGlyZWN0aW9uc1xyXG4gICAgICAgIHdoaWxlIChwICYmIHAueiA+PSBtaW5aICYmIG4gJiYgbi56IDw9IG1heFopIHtcclxuICAgICAgICAgICAgaWYgKHAgIT09IGVhci5wcmV2ICYmIHAgIT09IGVhci5uZXh0ICYmXHJcbiAgICAgICAgICAgICAgICBHcmFwaGljc0dlb21ldHJ5LnBvaW50SW5UcmlhbmdsZShhLngsIGEueSwgYi54LCBiLnksIGMueCwgYy55LCBwLngsIHAueSkgJiZcclxuICAgICAgICAgICAgICAgIEdyYXBoaWNzR2VvbWV0cnkuYXJlYShwLnByZXYsIHAsIHAubmV4dCkgPj0gMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHAgPSBwLnByZXZaO1xyXG4gICAgICAgICAgICBpZiAobiAhPT0gZWFyLnByZXYgJiYgbiAhPT0gZWFyLm5leHQgJiZcclxuICAgICAgICAgICAgICAgIEdyYXBoaWNzR2VvbWV0cnkucG9pbnRJblRyaWFuZ2xlKGEueCwgYS55LCBiLngsIGIueSwgYy54LCBjLnksIG4ueCwgbi55KSAmJlxyXG4gICAgICAgICAgICAgICAgR3JhcGhpY3NHZW9tZXRyeS5hcmVhKG4ucHJldiwgbiwgbi5uZXh0KSA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbiA9IG4ubmV4dFo7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGxvb2sgZm9yIHJlbWFpbmluZyBwb2ludHMgaW4gZGVjcmVhc2luZyB6LW9yZGVyXHJcbiAgICAgICAgd2hpbGUgKHAgJiYgcC56ID49IG1pblopIHtcclxuICAgICAgICAgICAgaWYgKHAgIT09IGVhci5wcmV2ICYmIHAgIT09IGVhci5uZXh0ICYmXHJcbiAgICAgICAgICAgICAgICBHcmFwaGljc0dlb21ldHJ5LnBvaW50SW5UcmlhbmdsZShhLngsIGEueSwgYi54LCBiLnksIGMueCwgYy55LCBwLngsIHAueSkgJiZcclxuICAgICAgICAgICAgICAgIEdyYXBoaWNzR2VvbWV0cnkuYXJlYShwLnByZXYsIHAsIHAubmV4dCkgPj0gMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHAgPSBwLnByZXZaO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBsb29rIGZvciByZW1haW5pbmcgcG9pbnRzIGluIGluY3JlYXNpbmcgei1vcmRlclxyXG4gICAgICAgIHdoaWxlIChuICYmIG4ueiA8PSBtYXhaKSB7XHJcbiAgICAgICAgICAgIGlmIChuICE9PSBlYXIucHJldiAmJiBuICE9PSBlYXIubmV4dCAmJlxyXG4gICAgICAgICAgICAgICAgR3JhcGhpY3NHZW9tZXRyeS5wb2ludEluVHJpYW5nbGUoYS54LCBhLnksIGIueCwgYi55LCBjLngsIGMueSwgbi54LCBuLnkpICYmXHJcbiAgICAgICAgICAgICAgICBHcmFwaGljc0dlb21ldHJ5LmFyZWEobi5wcmV2LCBuLCBuLm5leHQpID49IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBuID0gbi5uZXh0WjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICAvLyB6LW9yZGVyIG9mIGEgcG9pbnQgZ2l2ZW4gY29vcmRzIGFuZCBpbnZlcnNlIG9mIHRoZSBsb25nZXIgc2lkZSBvZiBkYXRhIGJib3hcclxuICAgIHN0YXRpYyB6T3JkZXIoeCwgeSwgbWluWCwgbWluWSwgaW52U2l6ZSkge1xyXG4gICAgICAgIC8vIGNvb3JkcyBhcmUgdHJhbnNmb3JtZWQgaW50byBub24tbmVnYXRpdmUgMTUtYml0IGludGVnZXIgcmFuZ2VcclxuICAgICAgICB4ID0gMzI3NjcgKiAoeCAtIG1pblgpICogaW52U2l6ZTtcclxuICAgICAgICB5ID0gMzI3NjcgKiAoeSAtIG1pblkpICogaW52U2l6ZTtcclxuICAgICAgICB4ID0gKHggfCAoeCA8PCA4KSkgJiAweDAwRkYwMEZGO1xyXG4gICAgICAgIHggPSAoeCB8ICh4IDw8IDQpKSAmIDB4MEYwRjBGMEY7XHJcbiAgICAgICAgeCA9ICh4IHwgKHggPDwgMikpICYgMHgzMzMzMzMzMztcclxuICAgICAgICB4ID0gKHggfCAoeCA8PCAxKSkgJiAweDU1NTU1NTU1O1xyXG4gICAgICAgIHkgPSAoeSB8ICh5IDw8IDgpKSAmIDB4MDBGRjAwRkY7XHJcbiAgICAgICAgeSA9ICh5IHwgKHkgPDwgNCkpICYgMHgwRjBGMEYwRjtcclxuICAgICAgICB5ID0gKHkgfCAoeSA8PCAyKSkgJiAweDMzMzMzMzMzO1xyXG4gICAgICAgIHkgPSAoeSB8ICh5IDw8IDEpKSAmIDB4NTU1NTU1NTU7XHJcbiAgICAgICAgcmV0dXJuIHggfCAoeSA8PCAxKTtcclxuICAgIH1cclxuICAgIC8vIGNoZWNrIHdoZXRoZXIgYSBwb2x5Z29uIG5vZGUgZm9ybXMgYSB2YWxpZCBlYXIgd2l0aCBhZGphY2VudCBub2Rlc1xyXG4gICAgc3RhdGljIGlzRWFyKGVhcikge1xyXG4gICAgICAgIHZhciBhID0gZWFyLnByZXYsIGIgPSBlYXIsIGMgPSBlYXIubmV4dDtcclxuICAgICAgICBpZiAoR3JhcGhpY3NHZW9tZXRyeS5hcmVhKGEsIGIsIGMpID49IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH0gLy8gcmVmbGV4LCBjYW4ndCBiZSBhbiBlYXJcclxuICAgICAgICAvLyBub3cgbWFrZSBzdXJlIHdlIGRvbid0IGhhdmUgb3RoZXIgcG9pbnRzIGluc2lkZSB0aGUgcG90ZW50aWFsIGVhclxyXG4gICAgICAgIHZhciBwID0gZWFyLm5leHQubmV4dDtcclxuICAgICAgICB3aGlsZSAocCAhPT0gZWFyLnByZXYpIHtcclxuICAgICAgICAgICAgaWYgKEdyYXBoaWNzR2VvbWV0cnkucG9pbnRJblRyaWFuZ2xlKGEueCwgYS55LCBiLngsIGIueSwgYy54LCBjLnksIHAueCwgcC55KSAmJlxyXG4gICAgICAgICAgICAgICAgR3JhcGhpY3NHZW9tZXRyeS5hcmVhKHAucHJldiwgcCwgcC5uZXh0KSA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcCA9IHAubmV4dDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICAvLyBpbnRlcmxpbmsgcG9seWdvbiBub2RlcyBpbiB6LW9yZGVyXHJcbiAgICBzdGF0aWMgaW5kZXhDdXJ2ZShzdGFydCwgbWluWCwgbWluWSwgaW52U2l6ZSkge1xyXG4gICAgICAgIHZhciBwID0gc3RhcnQ7XHJcbiAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICBpZiAocC56ID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBwLnogPSBHcmFwaGljc0dlb21ldHJ5LnpPcmRlcihwLngsIHAueSwgbWluWCwgbWluWSwgaW52U2l6ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcC5wcmV2WiA9IHAucHJldjtcclxuICAgICAgICAgICAgcC5uZXh0WiA9IHAubmV4dDtcclxuICAgICAgICAgICAgcCA9IHAubmV4dDtcclxuICAgICAgICB9IHdoaWxlIChwICE9PSBzdGFydCk7XHJcbiAgICAgICAgcC5wcmV2Wi5uZXh0WiA9IG51bGw7XHJcbiAgICAgICAgcC5wcmV2WiA9IG51bGw7XHJcbiAgICAgICAgR3JhcGhpY3NHZW9tZXRyeS5zb3J0TGlua2VkKHApO1xyXG4gICAgfVxyXG4gICAgLy8gU2ltb24gVGF0aGFtJ3MgbGlua2VkIGxpc3QgbWVyZ2Ugc29ydCBhbGdvcml0aG1cclxuICAgIC8vIGh0dHA6Ly93d3cuY2hpYXJrLmdyZWVuZW5kLm9yZy51ay9+c2d0YXRoYW0vYWxnb3JpdGhtcy9saXN0c29ydC5odG1sXHJcbiAgICBzdGF0aWMgc29ydExpbmtlZChsaXN0KSB7XHJcbiAgICAgICAgdmFyIGksIHAsIHEsIGUsIHRhaWwsIG51bU1lcmdlcywgcFNpemUsIHFTaXplLCBpblNpemUgPSAxO1xyXG4gICAgICAgIGRvIHtcclxuICAgICAgICAgICAgcCA9IGxpc3Q7XHJcbiAgICAgICAgICAgIGxpc3QgPSBudWxsO1xyXG4gICAgICAgICAgICB0YWlsID0gbnVsbDtcclxuICAgICAgICAgICAgbnVtTWVyZ2VzID0gMDtcclxuICAgICAgICAgICAgd2hpbGUgKHApIHtcclxuICAgICAgICAgICAgICAgIG51bU1lcmdlcysrO1xyXG4gICAgICAgICAgICAgICAgcSA9IHA7XHJcbiAgICAgICAgICAgICAgICBwU2l6ZSA9IDA7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgaW5TaXplOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBwU2l6ZSsrO1xyXG4gICAgICAgICAgICAgICAgICAgIHEgPSBxLm5leHRaO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghcSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBxU2l6ZSA9IGluU2l6ZTtcclxuICAgICAgICAgICAgICAgIHdoaWxlIChwU2l6ZSA+IDAgfHwgKHFTaXplID4gMCAmJiBxKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwU2l6ZSAhPT0gMCAmJiAocVNpemUgPT09IDAgfHwgIXEgfHwgcC56IDw9IHEueikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZSA9IHA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHAgPSBwLm5leHRaO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwU2l6ZS0tO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZSA9IHE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHEgPSBxLm5leHRaO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBxU2l6ZS0tO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodGFpbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0YWlsLm5leHRaID0gZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpc3QgPSBlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlLnByZXZaID0gdGFpbDtcclxuICAgICAgICAgICAgICAgICAgICB0YWlsID0gZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHAgPSBxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRhaWwubmV4dFogPSBudWxsO1xyXG4gICAgICAgICAgICBpblNpemUgKj0gMjtcclxuICAgICAgICB9IHdoaWxlIChudW1NZXJnZXMgPiAxKTtcclxuICAgICAgICByZXR1cm4gbGlzdDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gKiBDYWxjdWxhdGUgdGhlIHBvaW50cyBmb3IgYSBxdWFkcmF0aWMgYmV6aWVyIGN1cnZlLiAoaGVscGVyIGZ1bmN0aW9uLi4pXHJcbiAqIEJhc2VkIG9uOiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy83ODUwOTcvaG93LWRvLWktaW1wbGVtZW50LWEtYmV6aWVyLWN1cnZlLWluLWNcclxuICpcclxuICogSWdub3JlZCBmcm9tIGRvY3Mgc2luY2UgaXQgaXMgbm90IGRpcmVjdGx5IGV4cG9zZWQuXHJcbiAqXHJcbiAqIEBpZ25vcmVcclxuICogQHByaXZhdGVcclxuICogQHBhcmFtIHtudW1iZXJ9IGZyb21YIC0gT3JpZ2luIHBvaW50IHhcclxuICogQHBhcmFtIHtudW1iZXJ9IGZyb21ZIC0gT3JpZ2luIHBvaW50IHhcclxuICogQHBhcmFtIHtudW1iZXJ9IGNwWCAtIENvbnRyb2wgcG9pbnQgeFxyXG4gKiBAcGFyYW0ge251bWJlcn0gY3BZIC0gQ29udHJvbCBwb2ludCB5XHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB0b1ggLSBEZXN0aW5hdGlvbiBwb2ludCB4XHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB0b1kgLSBEZXN0aW5hdGlvbiBwb2ludCB5XHJcbiAqIEBwYXJhbSB7bnVtYmVyW119IFtvdXQ9W11dIC0gVGhlIG91dHB1dCBhcnJheSB0byBhZGQgcG9pbnRzIGludG8uIElmIG5vdCBwYXNzZWQsIGEgbmV3IGFycmF5IGlzIGNyZWF0ZWQuXHJcbiAqIEByZXR1cm4ge251bWJlcltdfSBhbiBhcnJheSBvZiBwb2ludHNcclxuICovXHJcbiAgICBzdGF0aWMgcXVhZHJhdGljQmV6aWVyQ3VydmUoZnJvbVgsIGZyb21ZLCBjcFgsIGNwWSwgdG9YLCB0b1ksIG91dCkge1xyXG4gICAgICAgIGlmIChvdXQgPT09IHZvaWQgMCkge1xyXG4gICAgICAgICAgICBvdXQgPSBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIG4gPSAyMDtcclxuICAgICAgICB2YXIgcG9pbnRzID0gb3V0O1xyXG4gICAgICAgIHZhciB4YSA9IDA7XHJcbiAgICAgICAgdmFyIHlhID0gMDtcclxuICAgICAgICB2YXIgeGIgPSAwO1xyXG4gICAgICAgIHZhciB5YiA9IDA7XHJcbiAgICAgICAgdmFyIHggPSAwO1xyXG4gICAgICAgIHZhciB5ID0gMDtcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgaiA9IDA7IGkgPD0gbjsgKytpKSB7XHJcbiAgICAgICAgICAgIGogPSBpIC8gbjtcclxuICAgICAgICAgICAgLy8gVGhlIEdyZWVuIExpbmVcclxuICAgICAgICAgICAgeGEgPSBHcmFwaGljc0dlb21ldHJ5LmdldFB0KGZyb21YLCBjcFgsIGopO1xyXG4gICAgICAgICAgICB5YSA9IEdyYXBoaWNzR2VvbWV0cnkuZ2V0UHQoZnJvbVksIGNwWSwgaik7XHJcbiAgICAgICAgICAgIHhiID0gR3JhcGhpY3NHZW9tZXRyeS5nZXRQdChjcFgsIHRvWCwgaik7XHJcbiAgICAgICAgICAgIHliID0gR3JhcGhpY3NHZW9tZXRyeS5nZXRQdChjcFksIHRvWSwgaik7XHJcbiAgICAgICAgICAgIC8vIFRoZSBCbGFjayBEb3RcclxuICAgICAgICAgICAgeCA9IEdyYXBoaWNzR2VvbWV0cnkuZ2V0UHQoeGEsIHhiLCBqKTtcclxuICAgICAgICAgICAgeSA9IEdyYXBoaWNzR2VvbWV0cnkuZ2V0UHQoeWEsIHliLCBqKTtcclxuICAgICAgICAgICAgcG9pbnRzLnB1c2goeCwgeSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwb2ludHM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICogQ2FsY3VsYXRlIGEgc2luZ2xlIHBvaW50IGZvciBhIHF1YWRyYXRpYyBiZXppZXIgY3VydmUuXHJcbiAqIFV0aWxpdHkgZnVuY3Rpb24gdXNlZCBieSBxdWFkcmF0aWNCZXppZXJDdXJ2ZS5cclxuICogSWdub3JlZCBmcm9tIGRvY3Mgc2luY2UgaXQgaXMgbm90IGRpcmVjdGx5IGV4cG9zZWQuXHJcbiAqXHJcbiAqIEBpZ25vcmVcclxuICogQHByaXZhdGVcclxuICogQHBhcmFtIHtudW1iZXJ9IG4xIC0gZmlyc3QgbnVtYmVyXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBuMiAtIHNlY29uZCBudW1iZXJcclxuICogQHBhcmFtIHtudW1iZXJ9IHBlcmMgLSBwZXJjZW50YWdlXHJcbiAqIEByZXR1cm4ge251bWJlcn0gdGhlIHJlc3VsdFxyXG4gKlxyXG4gKi9cclxuICAgIHN0YXRpYyBnZXRQdChuMSwgbjIsIHBlcmMpIHtcclxuICAgICAgICB2YXIgZGlmZiA9IG4yIC0gbjE7XHJcbiAgICAgICAgcmV0dXJuIG4xICsgKGRpZmYgKiBwZXJjKTtcclxuICAgIH1cclxufVxyXG5HcmFwaGljc0dlb21ldHJ5LkJBVENIX1BPT0wgPSBbXTtcclxuR3JhcGhpY3NHZW9tZXRyeS5EUkFXX0NBTExfUE9PTCA9IFtdO1xyXG4vKipcclxuKiBUaGUgbWF4aW11bSBudW1iZXIgb2YgcG9pbnRzIHRvIGNvbnNpZGVyIGFuIG9iamVjdCBcImJhdGNoYWJsZVwiLFxyXG4qIGFibGUgdG8gYmUgYmF0Y2hlZCBieSB0aGUgcmVuZGVyZXIncyBiYXRjaCBzeXN0ZW0uXHJcbipcclxuKiBAbWVtYmVyb2YgUElYSS5HcmFwaGljc0dlb21ldHJ5XHJcbiogQHN0YXRpY1xyXG4qIEBtZW1iZXIge251bWJlcn0gQkFUQ0hBQkxFX1NJWkVcclxuKiBAZGVmYXVsdCAxMDBcclxuKi9cclxuR3JhcGhpY3NHZW9tZXRyeS5CQVRDSEFCTEVfU0laRSA9IDEwMDtcclxuLyoqXHJcbiogQnVpbGRzIGEgcG9seWdvbiB0byBkcmF3XHJcbipcclxuKiBJZ25vcmVkIGZyb20gZG9jcyBzaW5jZSBpdCBpcyBub3QgZGlyZWN0bHkgZXhwb3NlZC5cclxuKlxyXG4qIEBpZ25vcmVcclxuKiBAcHJpdmF0ZVxyXG4qIEBwYXJhbSB7UElYSS5XZWJHTEdyYXBoaWNzRGF0YX0gZ3JhcGhpY3NEYXRhIC0gVGhlIGdyYXBoaWNzIG9iamVjdCBjb250YWluaW5nIGFsbCB0aGUgbmVjZXNzYXJ5IHByb3BlcnRpZXNcclxuKiBAcGFyYW0ge29iamVjdH0gd2ViR0xEYXRhIC0gYW4gb2JqZWN0IGNvbnRhaW5pbmcgYWxsIHRoZSBXZWJHTC1zcGVjaWZpYyBpbmZvcm1hdGlvbiB0byBjcmVhdGUgdGhpcyBzaGFwZVxyXG4qIEBwYXJhbSB7b2JqZWN0fSB3ZWJHTERhdGFOYXRpdmVMaW5lcyAtIGFuIG9iamVjdCBjb250YWluaW5nIGFsbCB0aGUgV2ViR0wtc3BlY2lmaWMgaW5mb3JtYXRpb24gdG8gY3JlYXRlIG5hdGl2ZUxpbmVzXHJcbiovXHJcbkdyYXBoaWNzR2VvbWV0cnkuYnVpbGRQb2x5ID0ge1xyXG4gICAgbmFtZTogXCJidWlsZFBvbHlcIixcclxuICAgIGJ1aWxkOiBmdW5jdGlvbiBidWlsZChncmFwaGljc0RhdGEpIHtcclxuICAgICAgICBncmFwaGljc0RhdGEucG9pbnRzID0gZ3JhcGhpY3NEYXRhLnNoYXBlLnBvaW50cy5zbGljZSgpO1xyXG4gICAgfSxcclxuICAgIHRyaWFuZ3VsYXRlOiBmdW5jdGlvbiB0cmlhbmd1bGF0ZShncmFwaGljc0RhdGEsIGdyYXBoaWNzR2VvbWV0cnkpIHtcclxuICAgICAgICB2YXIgcG9pbnRzID0gZ3JhcGhpY3NEYXRhLnBvaW50cztcclxuICAgICAgICB2YXIgaG9sZXMgPSBncmFwaGljc0RhdGEuaG9sZXM7XHJcbiAgICAgICAgdmFyIHZlcnRzID0gZ3JhcGhpY3NHZW9tZXRyeS5wb2ludHM7XHJcbiAgICAgICAgdmFyIGluZGljZXMgPSBncmFwaGljc0dlb21ldHJ5LmluZGljZXM7XHJcbiAgICAgICAgaWYgKHBvaW50cy5sZW5ndGggPj0gNikge1xyXG4gICAgICAgICAgICB2YXIgaG9sZUFycmF5ID0gW107XHJcbiAgICAgICAgICAgIC8vIFByb2Nlc3MgaG9sZXMuLlxyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhvbGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaG9sZSA9IGhvbGVzW2ldO1xyXG4gICAgICAgICAgICAgICAgaG9sZUFycmF5LnB1c2gocG9pbnRzLmxlbmd0aCAvIDIpO1xyXG4gICAgICAgICAgICAgICAgcG9pbnRzID0gcG9pbnRzLmNvbmNhdChob2xlLnBvaW50cyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gc29ydCBjb2xvclxyXG4gICAgICAgICAgICB2YXIgdHJpYW5nbGVzID0gR3JhcGhpY3NHZW9tZXRyeS5lYXJjdXQocG9pbnRzLCBob2xlQXJyYXksIDIpO1xyXG4gICAgICAgICAgICBpZiAoIXRyaWFuZ2xlcykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciB2ZXJ0UG9zID0gdmVydHMubGVuZ3RoIC8gMjtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgdHJpYW5nbGVzLmxlbmd0aDsgaSQxICs9IDMpIHtcclxuICAgICAgICAgICAgICAgIGluZGljZXMucHVzaCh0cmlhbmdsZXNbaSQxXSArIHZlcnRQb3MpO1xyXG4gICAgICAgICAgICAgICAgaW5kaWNlcy5wdXNoKHRyaWFuZ2xlc1tpJDEgKyAxXSArIHZlcnRQb3MpO1xyXG4gICAgICAgICAgICAgICAgaW5kaWNlcy5wdXNoKHRyaWFuZ2xlc1tpJDEgKyAyXSArIHZlcnRQb3MpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkkMiA9IDA7IGkkMiA8IHBvaW50cy5sZW5ndGg7IGkkMisrKSB7XHJcbiAgICAgICAgICAgICAgICB2ZXJ0cy5wdXNoKHBvaW50c1tpJDJdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbn07XHJcbi8qKlxyXG4qIEJ1aWxkcyBhIHJlY3RhbmdsZSB0byBkcmF3XHJcbipcclxuKiBJZ25vcmVkIGZyb20gZG9jcyBzaW5jZSBpdCBpcyBub3QgZGlyZWN0bHkgZXhwb3NlZC5cclxuKlxyXG4qIEBpZ25vcmVcclxuKiBAcHJpdmF0ZVxyXG4qIEBwYXJhbSB7UElYSS5XZWJHTEdyYXBoaWNzRGF0YX0gZ3JhcGhpY3NEYXRhIC0gVGhlIGdyYXBoaWNzIG9iamVjdCBjb250YWluaW5nIGFsbCB0aGUgbmVjZXNzYXJ5IHByb3BlcnRpZXNcclxuKiBAcGFyYW0ge29iamVjdH0gd2ViR0xEYXRhIC0gYW4gb2JqZWN0IGNvbnRhaW5pbmcgYWxsIHRoZSBXZWJHTC1zcGVjaWZpYyBpbmZvcm1hdGlvbiB0byBjcmVhdGUgdGhpcyBzaGFwZVxyXG4qIEBwYXJhbSB7b2JqZWN0fSB3ZWJHTERhdGFOYXRpdmVMaW5lcyAtIGFuIG9iamVjdCBjb250YWluaW5nIGFsbCB0aGUgV2ViR0wtc3BlY2lmaWMgaW5mb3JtYXRpb24gdG8gY3JlYXRlIG5hdGl2ZUxpbmVzXHJcbiovXHJcbkdyYXBoaWNzR2VvbWV0cnkuYnVpbGRSZWN0YW5nbGUgPSB7XHJcbiAgICBuYW1lOiBcImJ1aWxkUmVjdGFuZ2xlXCIsXHJcbiAgICBidWlsZDogZnVuY3Rpb24gYnVpbGQoZ3JhcGhpY3NEYXRhKSB7XHJcbiAgICAgICAgLy8gLS0tIC8vXHJcbiAgICAgICAgLy8gbmVlZCB0byBjb252ZXJ0IHBvaW50cyB0byBhIG5pY2UgcmVndWxhciBkYXRhXHJcbiAgICAgICAgLy9cclxuICAgICAgICB2YXIgcmVjdERhdGEgPSBncmFwaGljc0RhdGEuc2hhcGU7XHJcbiAgICAgICAgdmFyIHggPSByZWN0RGF0YS54O1xyXG4gICAgICAgIHZhciB5ID0gcmVjdERhdGEueTtcclxuICAgICAgICB2YXIgd2lkdGggPSByZWN0RGF0YS53aWR0aDtcclxuICAgICAgICB2YXIgaGVpZ2h0ID0gcmVjdERhdGEuaGVpZ2h0O1xyXG4gICAgICAgIHZhciBwb2ludHMgPSBncmFwaGljc0RhdGEucG9pbnRzO1xyXG4gICAgICAgIHBvaW50cy5sZW5ndGggPSAwO1xyXG4gICAgICAgIHBvaW50cy5wdXNoKHgsIHksIHggKyB3aWR0aCwgeSwgeCArIHdpZHRoLCB5ICsgaGVpZ2h0LCB4LCB5ICsgaGVpZ2h0KTtcclxuICAgIH0sXHJcbiAgICB0cmlhbmd1bGF0ZTogZnVuY3Rpb24gdHJpYW5ndWxhdGUoZ3JhcGhpY3NEYXRhLCBncmFwaGljc0dlb21ldHJ5KSB7XHJcbiAgICAgICAgdmFyIHBvaW50cyA9IGdyYXBoaWNzRGF0YS5wb2ludHM7XHJcbiAgICAgICAgdmFyIHZlcnRzID0gZ3JhcGhpY3NHZW9tZXRyeS5wb2ludHM7XHJcbiAgICAgICAgdmFyIHZlcnRQb3MgPSB2ZXJ0cy5sZW5ndGggLyAyO1xyXG4gICAgICAgIHZlcnRzLnB1c2gocG9pbnRzWzBdLCBwb2ludHNbMV0sIHBvaW50c1syXSwgcG9pbnRzWzNdLCBwb2ludHNbNl0sIHBvaW50c1s3XSwgcG9pbnRzWzRdLCBwb2ludHNbNV0pO1xyXG4gICAgICAgIGdyYXBoaWNzR2VvbWV0cnkuaW5kaWNlcy5wdXNoKHZlcnRQb3MsIHZlcnRQb3MgKyAxLCB2ZXJ0UG9zICsgMiwgdmVydFBvcyArIDEsIHZlcnRQb3MgKyAyLCB2ZXJ0UG9zICsgMyk7XHJcbiAgICB9LFxyXG59O1xyXG4vKipcclxuKiBCdWlsZHMgYSByb3VuZGVkIHJlY3RhbmdsZSB0byBkcmF3XHJcbipcclxuKiBJZ25vcmVkIGZyb20gZG9jcyBzaW5jZSBpdCBpcyBub3QgZGlyZWN0bHkgZXhwb3NlZC5cclxuKlxyXG4qIEBpZ25vcmVcclxuKiBAcHJpdmF0ZVxyXG4qIEBwYXJhbSB7UElYSS5XZWJHTEdyYXBoaWNzRGF0YX0gZ3JhcGhpY3NEYXRhIC0gVGhlIGdyYXBoaWNzIG9iamVjdCBjb250YWluaW5nIGFsbCB0aGUgbmVjZXNzYXJ5IHByb3BlcnRpZXNcclxuKiBAcGFyYW0ge29iamVjdH0gd2ViR0xEYXRhIC0gYW4gb2JqZWN0IGNvbnRhaW5pbmcgYWxsIHRoZSBXZWJHTC1zcGVjaWZpYyBpbmZvcm1hdGlvbiB0byBjcmVhdGUgdGhpcyBzaGFwZVxyXG4qIEBwYXJhbSB7b2JqZWN0fSB3ZWJHTERhdGFOYXRpdmVMaW5lcyAtIGFuIG9iamVjdCBjb250YWluaW5nIGFsbCB0aGUgV2ViR0wtc3BlY2lmaWMgaW5mb3JtYXRpb24gdG8gY3JlYXRlIG5hdGl2ZUxpbmVzXHJcbiovXHJcbkdyYXBoaWNzR2VvbWV0cnkuYnVpbGRSb3VuZGVkUmVjdGFuZ2xlID0ge1xyXG4gICAgbmFtZTogXCJidWlsZFJvdW5kZWRSZWN0YW5nbGVcIixcclxuICAgIGJ1aWxkOiBmdW5jdGlvbiBidWlsZChncmFwaGljc0RhdGEpIHtcclxuICAgICAgICB2YXIgcnJlY3REYXRhID0gZ3JhcGhpY3NEYXRhLnNoYXBlO1xyXG4gICAgICAgIHZhciBwb2ludHMgPSBncmFwaGljc0RhdGEucG9pbnRzO1xyXG4gICAgICAgIHZhciB4ID0gcnJlY3REYXRhLng7XHJcbiAgICAgICAgdmFyIHkgPSBycmVjdERhdGEueTtcclxuICAgICAgICB2YXIgd2lkdGggPSBycmVjdERhdGEud2lkdGg7XHJcbiAgICAgICAgdmFyIGhlaWdodCA9IHJyZWN0RGF0YS5oZWlnaHQ7XHJcbiAgICAgICAgdmFyIHJhZGl1cyA9IHJyZWN0RGF0YS5yYWRpdXM7XHJcbiAgICAgICAgcG9pbnRzLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgR3JhcGhpY3NHZW9tZXRyeS5xdWFkcmF0aWNCZXppZXJDdXJ2ZSh4LCB5ICsgcmFkaXVzLCB4LCB5LCB4ICsgcmFkaXVzLCB5LCBwb2ludHMpO1xyXG4gICAgICAgIEdyYXBoaWNzR2VvbWV0cnkucXVhZHJhdGljQmV6aWVyQ3VydmUoeCArIHdpZHRoIC0gcmFkaXVzLCB5LCB4ICsgd2lkdGgsIHksIHggKyB3aWR0aCwgeSArIHJhZGl1cywgcG9pbnRzKTtcclxuICAgICAgICBHcmFwaGljc0dlb21ldHJ5LnF1YWRyYXRpY0JlemllckN1cnZlKHggKyB3aWR0aCwgeSArIGhlaWdodCAtIHJhZGl1cywgeCArIHdpZHRoLCB5ICsgaGVpZ2h0LCB4ICsgd2lkdGggLSByYWRpdXMsIHkgKyBoZWlnaHQsIHBvaW50cyk7XHJcbiAgICAgICAgR3JhcGhpY3NHZW9tZXRyeS5xdWFkcmF0aWNCZXppZXJDdXJ2ZSh4ICsgcmFkaXVzLCB5ICsgaGVpZ2h0LCB4LCB5ICsgaGVpZ2h0LCB4LCB5ICsgaGVpZ2h0IC0gcmFkaXVzLCBwb2ludHMpO1xyXG4gICAgICAgIC8vIHRoaXMgdGlueSBudW1iZXIgZGVhbHMgd2l0aCB0aGUgaXNzdWUgdGhhdCBvY2N1cnMgd2hlbiBwb2ludHMgb3ZlcmxhcCBhbmQgZWFyY3V0IGZhaWxzIHRvIHRyaWFuZ3VsYXRlIHRoZSBpdGVtLlxyXG4gICAgICAgIC8vIFRPRE8gLSBmaXggdGhpcyBwcm9wZXJseSwgdGhpcyBpcyBub3QgdmVyeSBlbGVnYW50Li4gYnV0IGl0IHdvcmtzIGZvciBub3cuXHJcbiAgICB9LFxyXG4gICAgdHJpYW5ndWxhdGU6IGZ1bmN0aW9uIHRyaWFuZ3VsYXRlKGdyYXBoaWNzRGF0YSwgZ3JhcGhpY3NHZW9tZXRyeSkge1xyXG4gICAgICAgIHZhciBwb2ludHMgPSBncmFwaGljc0RhdGEucG9pbnRzO1xyXG4gICAgICAgIHZhciB2ZXJ0cyA9IGdyYXBoaWNzR2VvbWV0cnkucG9pbnRzO1xyXG4gICAgICAgIHZhciBpbmRpY2VzID0gZ3JhcGhpY3NHZW9tZXRyeS5pbmRpY2VzO1xyXG4gICAgICAgIHZhciB2ZWNQb3MgPSB2ZXJ0cy5sZW5ndGggLyAyO1xyXG4gICAgICAgIHZhciB0cmlhbmdsZXMgPSBHcmFwaGljc0dlb21ldHJ5LmVhcmN1dChwb2ludHMsIG51bGwsIDIpO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBqID0gdHJpYW5nbGVzLmxlbmd0aDsgaSA8IGo7IGkgKz0gMykge1xyXG4gICAgICAgICAgICBpbmRpY2VzLnB1c2godHJpYW5nbGVzW2ldICsgdmVjUG9zKTtcclxuICAgICAgICAgICAgLy8gICAgIGluZGljZXMucHVzaCh0cmlhbmdsZXNbaV0gKyB2ZWNQb3MpO1xyXG4gICAgICAgICAgICBpbmRpY2VzLnB1c2godHJpYW5nbGVzW2kgKyAxXSArIHZlY1Bvcyk7XHJcbiAgICAgICAgICAgIC8vICAgaW5kaWNlcy5wdXNoKHRyaWFuZ2xlc1tpICsgMl0gKyB2ZWNQb3MpO1xyXG4gICAgICAgICAgICBpbmRpY2VzLnB1c2godHJpYW5nbGVzW2kgKyAyXSArIHZlY1Bvcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAodmFyIGkkMSA9IDAsIGokMSA9IHBvaW50cy5sZW5ndGg7IGkkMSA8IGokMTsgaSQxKyspIHtcclxuICAgICAgICAgICAgdmVydHMucHVzaChwb2ludHNbaSQxXSwgcG9pbnRzWysraSQxXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxufTtcclxuLyoqXHJcbiogQnVpbGRzIGEgY2lyY2xlIHRvIGRyYXdcclxuKlxyXG4qIElnbm9yZWQgZnJvbSBkb2NzIHNpbmNlIGl0IGlzIG5vdCBkaXJlY3RseSBleHBvc2VkLlxyXG4qXHJcbiogQGlnbm9yZVxyXG4qIEBwcml2YXRlXHJcbiogQHBhcmFtIHtQSVhJLldlYkdMR3JhcGhpY3NEYXRhfSBncmFwaGljc0RhdGEgLSBUaGUgZ3JhcGhpY3Mgb2JqZWN0IHRvIGRyYXdcclxuKiBAcGFyYW0ge29iamVjdH0gd2ViR0xEYXRhIC0gYW4gb2JqZWN0IGNvbnRhaW5pbmcgYWxsIHRoZSBXZWJHTC1zcGVjaWZpYyBpbmZvcm1hdGlvbiB0byBjcmVhdGUgdGhpcyBzaGFwZVxyXG4qIEBwYXJhbSB7b2JqZWN0fSB3ZWJHTERhdGFOYXRpdmVMaW5lcyAtIGFuIG9iamVjdCBjb250YWluaW5nIGFsbCB0aGUgV2ViR0wtc3BlY2lmaWMgaW5mb3JtYXRpb24gdG8gY3JlYXRlIG5hdGl2ZUxpbmVzXHJcbiovXHJcbkdyYXBoaWNzR2VvbWV0cnkuYnVpbGRDaXJjbGUgPSB7XHJcbiAgICBuYW1lOiBcImJ1aWxkQ2lyY2xlXCIsXHJcbiAgICBidWlsZDogZnVuY3Rpb24gYnVpbGQoZ3JhcGhpY3NEYXRhKSB7XHJcbiAgICAgICAgLy8gbmVlZCB0byBjb252ZXJ0IHBvaW50cyB0byBhIG5pY2UgcmVndWxhciBkYXRhXHJcbiAgICAgICAgdmFyIGNpcmNsZURhdGEgPSBncmFwaGljc0RhdGEuc2hhcGU7XHJcbiAgICAgICAgdmFyIHBvaW50cyA9IGdyYXBoaWNzRGF0YS5wb2ludHM7XHJcbiAgICAgICAgdmFyIHggPSBjaXJjbGVEYXRhLng7XHJcbiAgICAgICAgdmFyIHkgPSBjaXJjbGVEYXRhLnk7XHJcbiAgICAgICAgdmFyIHdpZHRoO1xyXG4gICAgICAgIHZhciBoZWlnaHQ7XHJcbiAgICAgICAgcG9pbnRzLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgLy8gVE9ETyAtIGJpdCBoYWNreT8/XHJcbiAgICAgICAgaWYgKGdyYXBoaWNzRGF0YS50eXBlID09PSBTaGFwZVNldHRpbmdzXzEuU2hhcGVTZXR0aW5ncy5TSEFQRVMuQ0lSQykge1xyXG4gICAgICAgICAgICB3aWR0aCA9IGNpcmNsZURhdGEucmFkaXVzO1xyXG4gICAgICAgICAgICBoZWlnaHQgPSBjaXJjbGVEYXRhLnJhZGl1cztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHdpZHRoID0gY2lyY2xlRGF0YS53aWR0aDtcclxuICAgICAgICAgICAgaGVpZ2h0ID0gY2lyY2xlRGF0YS5oZWlnaHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh3aWR0aCA9PT0gMCB8fCBoZWlnaHQgPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgdG90YWxTZWdzID0gTWF0aC5mbG9vcigzMCAqIE1hdGguc3FydChjaXJjbGVEYXRhLnJhZGl1cykpXHJcbiAgICAgICAgICAgIHx8IE1hdGguZmxvb3IoMTUgKiBNYXRoLnNxcnQoY2lyY2xlRGF0YS53aWR0aCArIGNpcmNsZURhdGEuaGVpZ2h0KSk7XHJcbiAgICAgICAgdG90YWxTZWdzIC89IDIuMztcclxuICAgICAgICB2YXIgc2VnID0gKE1hdGguUEkgKiAyKSAvIHRvdGFsU2VncztcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRvdGFsU2VnczsgaSsrKSB7XHJcbiAgICAgICAgICAgIHBvaW50cy5wdXNoKHggKyAoTWF0aC5zaW4oLXNlZyAqIGkpICogd2lkdGgpLCB5ICsgKE1hdGguY29zKC1zZWcgKiBpKSAqIGhlaWdodCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwb2ludHMucHVzaChwb2ludHNbMF0sIHBvaW50c1sxXSk7XHJcbiAgICB9LFxyXG4gICAgdHJpYW5ndWxhdGU6IGZ1bmN0aW9uIHRyaWFuZ3VsYXRlKGdyYXBoaWNzRGF0YSwgZ3JhcGhpY3NHZW9tZXRyeSkge1xyXG4gICAgICAgIHZhciBwb2ludHMgPSBncmFwaGljc0RhdGEucG9pbnRzO1xyXG4gICAgICAgIHZhciB2ZXJ0cyA9IGdyYXBoaWNzR2VvbWV0cnkucG9pbnRzO1xyXG4gICAgICAgIHZhciBpbmRpY2VzID0gZ3JhcGhpY3NHZW9tZXRyeS5pbmRpY2VzO1xyXG4gICAgICAgIHZhciB2ZXJ0UG9zID0gdmVydHMubGVuZ3RoIC8gMjtcclxuICAgICAgICB2YXIgY2VudGVyID0gdmVydFBvcztcclxuICAgICAgICB2ZXJ0cy5wdXNoKGdyYXBoaWNzRGF0YS5zaGFwZS54LCBncmFwaGljc0RhdGEuc2hhcGUueSk7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpICs9IDIpIHtcclxuICAgICAgICAgICAgdmVydHMucHVzaChwb2ludHNbaV0sIHBvaW50c1tpICsgMV0pO1xyXG4gICAgICAgICAgICAvLyBhZGQgc29tZSB1dnNcclxuICAgICAgICAgICAgaW5kaWNlcy5wdXNoKHZlcnRQb3MrKywgY2VudGVyLCB2ZXJ0UG9zKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG59O1xyXG5leHBvcnRzLkdyYXBoaWNzR2VvbWV0cnkgPSBHcmFwaGljc0dlb21ldHJ5O1xyXG5jbGFzcyBOb2RlIHtcclxuICAgIGNvbnN0cnVjdG9yKGksIHgsIHkpIHtcclxuICAgICAgICAvLyB2ZXJ0ZXggaW5kZXggaW4gY29vcmRpbmF0ZXMgYXJyYXlcclxuICAgICAgICB0aGlzLmkgPSBpO1xyXG4gICAgICAgIC8vIHZlcnRleCBjb29yZGluYXRlc1xyXG4gICAgICAgIHRoaXMueCA9IHg7XHJcbiAgICAgICAgdGhpcy55ID0geTtcclxuICAgICAgICAvLyBwcmV2aW91cyBhbmQgbmV4dCB2ZXJ0ZXggbm9kZXMgaW4gYSBwb2x5Z29uIHJpbmdcclxuICAgICAgICB0aGlzLnByZXYgPSBudWxsO1xyXG4gICAgICAgIHRoaXMubmV4dCA9IG51bGw7XHJcbiAgICAgICAgLy8gei1vcmRlciBjdXJ2ZSB2YWx1ZVxyXG4gICAgICAgIHRoaXMueiA9IG51bGw7XHJcbiAgICAgICAgLy8gcHJldmlvdXMgYW5kIG5leHQgbm9kZXMgaW4gei1vcmRlclxyXG4gICAgICAgIHRoaXMucHJldlogPSBudWxsO1xyXG4gICAgICAgIHRoaXMubmV4dFogPSBudWxsO1xyXG4gICAgICAgIC8vIGluZGljYXRlcyB3aGV0aGVyIHRoaXMgaXMgYSBzdGVpbmVyIHBvaW50XHJcbiAgICAgICAgdGhpcy5zdGVpbmVyID0gZmFsc2U7XHJcbiAgICB9XHJcbn1cclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgTWF0cml4XzEgPSByZXF1aXJlKFwiLi9NYXRyaXhcIik7XHJcbmNsYXNzIEdyb3VwRDgge1xyXG4gICAgc3RhdGljIHVYKGluZCkge1xyXG4gICAgICAgIEdyb3VwRDguaW5pdCgpO1xyXG4gICAgICAgIHJldHVybiBHcm91cEQ4LnV4W2luZF07XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgdVkoaW5kKSB7XHJcbiAgICAgICAgR3JvdXBEOC5pbml0KCk7XHJcbiAgICAgICAgcmV0dXJuIEdyb3VwRDgudXlbaW5kXTtcclxuICAgIH1cclxuICAgIHN0YXRpYyB2WChpbmQpIHtcclxuICAgICAgICBHcm91cEQ4LmluaXQoKTtcclxuICAgICAgICByZXR1cm4gR3JvdXBEOC52eFtpbmRdO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIHZZKGluZCkge1xyXG4gICAgICAgIEdyb3VwRDguaW5pdCgpO1xyXG4gICAgICAgIHJldHVybiBHcm91cEQ4LnZ5W2luZF07XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgaW52KHJvdGF0aW9uKSB7XHJcbiAgICAgICAgaWYgKHJvdGF0aW9uICYgOCkge1xyXG4gICAgICAgICAgICByZXR1cm4gcm90YXRpb24gJiAxNTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuICgtcm90YXRpb24pICYgNztcclxuICAgIH1cclxuICAgIHN0YXRpYyBhZGQocm90YXRpb25TZWNvbmQsIHJvdGF0aW9uRmlyc3QpIHtcclxuICAgICAgICBHcm91cEQ4LmluaXQoKTtcclxuICAgICAgICByZXR1cm4gR3JvdXBEOC5tdWxbcm90YXRpb25TZWNvbmRdW3JvdGF0aW9uRmlyc3RdO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIHN1Yihyb3RhdGlvblNlY29uZCwgcm90YXRpb25GaXJzdCkge1xyXG4gICAgICAgIEdyb3VwRDguaW5pdCgpO1xyXG4gICAgICAgIHJldHVybiBHcm91cEQ4Lm11bFtyb3RhdGlvblNlY29uZF1bR3JvdXBEOC5pbnYocm90YXRpb25GaXJzdCldO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIHJvdGF0ZTE4MChyb3RhdGlvbikge1xyXG4gICAgICAgIHJldHVybiByb3RhdGlvbiBeIDQ7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgaXNWZXJ0aWNhbChyb3RhdGlvbikge1xyXG4gICAgICAgIHJldHVybiAocm90YXRpb24gJiAzKSA9PT0gMjtcclxuICAgIH1cclxuICAgIHN0YXRpYyBieURpcmVjdGlvbihkeCwgZHkpIHtcclxuICAgICAgICBHcm91cEQ4LmluaXQoKTtcclxuICAgICAgICBpZiAoTWF0aC5hYnMoZHgpICogMiA8PSBNYXRoLmFicyhkeSkpIHtcclxuICAgICAgICAgICAgaWYgKGR5ID49IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBHcm91cEQ4LlM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIEdyb3VwRDguTjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoTWF0aC5hYnMoZHkpICogMiA8PSBNYXRoLmFicyhkeCkpIHtcclxuICAgICAgICAgICAgaWYgKGR4ID4gMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIEdyb3VwRDguRTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gR3JvdXBEOC5XO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChkeSA+IDApIHtcclxuICAgICAgICAgICAgaWYgKGR4ID4gMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIEdyb3VwRDguU0U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIEdyb3VwRDguU1c7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGR4ID4gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gR3JvdXBEOC5ORTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIEdyb3VwRDguTlc7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgbWF0cml4QXBwZW5kUm90YXRpb25JbnYobWF0cml4LCByb3RhdGlvbiwgdHggPSAwLCB0eSA9IDApIHtcclxuICAgICAgICBHcm91cEQ4LmluaXQoKTtcclxuICAgICAgICBsZXQgbWF0ID0gR3JvdXBEOC50ZW1wTWF0cmljZXNbR3JvdXBEOC5pbnYocm90YXRpb24pXTtcclxuICAgICAgICBtYXQudHggPSB0eDtcclxuICAgICAgICBtYXQudHkgPSB0eTtcclxuICAgICAgICBtYXRyaXguYXBwZW5kKG1hdCk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgc2lnbnVtKHgpIHtcclxuICAgICAgICBpZiAoeCA8IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoeCA+IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGluaXQoKSB7XHJcbiAgICAgICAgaWYgKEdyb3VwRDguaXNJbml0KSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgR3JvdXBEOC5pc0luaXQgPSB0cnVlO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMTY7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgcm93ID0gW107XHJcbiAgICAgICAgICAgIEdyb3VwRDgubXVsLnB1c2gocm93KTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCAxNjsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3V4ID0gR3JvdXBEOC5zaWdudW0oKEdyb3VwRDgudXhbaV0gKiBHcm91cEQ4LnV4W2pdKSArIChHcm91cEQ4LnZ4W2ldICogR3JvdXBEOC51eVtqXSkpO1xyXG4gICAgICAgICAgICAgICAgdmFyIF91eSA9IEdyb3VwRDguc2lnbnVtKChHcm91cEQ4LnV5W2ldICogR3JvdXBEOC51eFtqXSkgKyAoR3JvdXBEOC52eVtpXSAqIEdyb3VwRDgudXlbal0pKTtcclxuICAgICAgICAgICAgICAgIHZhciBfdnggPSBHcm91cEQ4LnNpZ251bSgoR3JvdXBEOC51eFtpXSAqIEdyb3VwRDgudnhbal0pICsgKEdyb3VwRDgudnhbaV0gKiBHcm91cEQ4LnZ5W2pdKSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3Z5ID0gR3JvdXBEOC5zaWdudW0oKEdyb3VwRDgudXlbaV0gKiBHcm91cEQ4LnZ4W2pdKSArIChHcm91cEQ4LnZ5W2ldICogR3JvdXBEOC52eVtqXSkpO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCAxNjsgaysrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKEdyb3VwRDgudXhba10gPT09IF91eCAmJiBHcm91cEQ4LnV5W2tdID09PSBfdXkgJiYgR3JvdXBEOC52eFtrXSA9PT0gX3Z4ICYmIEdyb3VwRDgudnlba10gPT09IF92eSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByb3cucHVzaChrKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IDE2OyBpJDErKykge1xyXG4gICAgICAgICAgICB2YXIgbWF0ID0gbmV3IE1hdHJpeF8xLk1hdHJpeCgpO1xyXG4gICAgICAgICAgICBtYXQuc2V0KEdyb3VwRDgudXhbaSQxXSwgR3JvdXBEOC51eVtpJDFdLCBHcm91cEQ4LnZ4W2kkMV0sIEdyb3VwRDgudnlbaSQxXSwgMCwgMCk7XHJcbiAgICAgICAgICAgIEdyb3VwRDgudGVtcE1hdHJpY2VzLnB1c2gobWF0KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuR3JvdXBEOC5pc0luaXQgPSBmYWxzZTtcclxuR3JvdXBEOC5FID0gMDtcclxuR3JvdXBEOC5TRSA9IDE7XHJcbkdyb3VwRDguUyA9IDI7XHJcbkdyb3VwRDguU1cgPSAzO1xyXG5Hcm91cEQ4LlcgPSA0O1xyXG5Hcm91cEQ4Lk5XID0gNTtcclxuR3JvdXBEOC5OID0gNjtcclxuR3JvdXBEOC5ORSA9IDc7XHJcbkdyb3VwRDguTUlSUk9SX1ZFUlRJQ0FMID0gODtcclxuR3JvdXBEOC5NSVJST1JfSE9SSVpPTlRBTCA9IDEyO1xyXG5Hcm91cEQ4LnV4ID0gWzEsIDEsIDAsIC0xLCAtMSwgLTEsIDAsIDEsIDEsIDEsIDAsIC0xLCAtMSwgLTEsIDAsIDFdO1xyXG5Hcm91cEQ4LnV5ID0gWzAsIDEsIDEsIDEsIDAsIC0xLCAtMSwgLTEsIDAsIDEsIDEsIDEsIDAsIC0xLCAtMSwgLTFdO1xyXG5Hcm91cEQ4LnZ4ID0gWzAsIC0xLCAtMSwgLTEsIDAsIDEsIDEsIDEsIDAsIDEsIDEsIDEsIDAsIC0xLCAtMSwgLTFdO1xyXG5Hcm91cEQ4LnZ5ID0gWzEsIDEsIDAsIC0xLCAtMSwgLTEsIDAsIDEsIC0xLCAtMSwgMCwgMSwgMSwgMSwgMCwgLTFdO1xyXG5Hcm91cEQ4LnRlbXBNYXRyaWNlcyA9IFtdO1xyXG5Hcm91cEQ4Lm11bCA9IFtdO1xyXG5leHBvcnRzLkdyb3VwRDggPSBHcm91cEQ4O1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBFdmVudF8xID0gcmVxdWlyZShcIi4vRXZlbnRcIik7XHJcbmNsYXNzIElPRXJyb3JFdmVudCBleHRlbmRzIEV2ZW50XzEuRXZlbnQge1xyXG4gICAgY29uc3RydWN0b3IodHlwZSwgYnViYmxlID0gdHJ1ZSwgY2FuY2VsYWJsZSA9IHRydWUpIHtcclxuICAgICAgICBzdXBlcih0eXBlLCBidWJibGUsIGNhbmNlbGFibGUpO1xyXG4gICAgICAgIHRoaXMuZXJyb3JJZCA9IDA7XHJcbiAgICB9XHJcbiAgICBjbG9uZSgpIHtcclxuICAgICAgICB2YXIgZXZlbnQgPSBuZXcgSU9FcnJvckV2ZW50KHRoaXMudHlwZSwgdGhpcy5idWJibGVzLCB0aGlzLmNhbmNlbGFibGUpO1xyXG4gICAgICAgIGV2ZW50LnRleHQgPSB0aGlzLnRleHQ7XHJcbiAgICAgICAgZXZlbnQuZXJyb3JJZCA9IHRoaXMuZXJyb3JJZDtcclxuICAgICAgICByZXR1cm4gZXZlbnQ7XHJcbiAgICB9XHJcbiAgICBnZXQgaXNEaXNwb3NhYmxlKCkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxufVxyXG5JT0Vycm9yRXZlbnQuSU9fRVJST1IgPSBcImlvRXJyb3JcIjtcclxuZXhwb3J0cy5JT0Vycm9yRXZlbnQgPSBJT0Vycm9yRXZlbnQ7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IEJhc2VJbWFnZVJlc291cmNlXzEgPSByZXF1aXJlKFwiLi9CYXNlSW1hZ2VSZXNvdXJjZVwiKTtcclxuY29uc3QgRGlzcGxheVNldHRpbmdzXzEgPSByZXF1aXJlKFwiLi9EaXNwbGF5U2V0dGluZ3NcIik7XHJcbmNvbnN0IExvZ2dlcl8xID0gcmVxdWlyZShcIi4vTG9nZ2VyXCIpO1xyXG5jbGFzcyBJbWFnZVJlc291cmNlIGV4dGVuZHMgQmFzZUltYWdlUmVzb3VyY2VfMS5CYXNlSW1hZ2VSZXNvdXJjZSB7XHJcbiAgICBjb25zdHJ1Y3Rvcihzb3VyY2UsIG9wdGlvbnMgPSB7fSkge1xyXG4gICAgICAgIHN1cGVyKHNvdXJjZSk7XHJcbiAgICAgICAgaWYgKCEoc291cmNlIGluc3RhbmNlb2YgSFRNTEltYWdlRWxlbWVudCkpIHtcclxuICAgICAgICAgICAgdmFyIGltYWdlRWxlbWVudCA9IG5ldyBJbWFnZSgpO1xyXG4gICAgICAgICAgICAvLyBCYXNlSW1hZ2VSZXNvdXJjZS5jcm9zc09yaWdpbihpbWFnZUVsZW1lbnQsIHNvdXJjZSwgb3B0aW9ucy5jcm9zc29yaWdpbik7XHJcbiAgICAgICAgICAgIGltYWdlRWxlbWVudC5zcmMgPSBzb3VyY2U7XHJcbiAgICAgICAgICAgIHNvdXJjZSA9IGltYWdlRWxlbWVudDtcclxuICAgICAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFVSTCBvZiB0aGUgaW1hZ2Ugc291cmNlXHJcbiAgICAgICAgICogQG1lbWJlciB7c3RyaW5nfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMudXJsID0gc291cmNlLnNyYztcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBXaGVuIHByb2Nlc3MgaXMgY29tcGxldGVkXHJcbiAgICAgICAgICogQG1lbWJlciB7UHJvbWlzZTx2b2lkPn1cclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuX3Byb2Nlc3MgPSBudWxsO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIElmIHRoZSBpbWFnZSBzaG91bGQgYmUgZGlzcG9zZWQgYWZ0ZXIgdXBsb2FkXHJcbiAgICAgICAgICogQG1lbWJlciB7Ym9vbGVhbn1cclxuICAgICAgICAgKiBAZGVmYXVsdCBmYWxzZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMucHJlc2VydmVCaXRtYXAgPSBmYWxzZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJZiBjYXBhYmxlLCBjb252ZXJ0IHRoZSBpbWFnZSB1c2luZyBjcmVhdGVJbWFnZUJpdG1hcCBBUElcclxuICAgICAgICAgKiBAbWVtYmVyIHtib29sZWFufVxyXG4gICAgICAgICAqIEBkZWZhdWx0IFBJWEkuc2V0dGluZ3MuQ1JFQVRFX0lNQUdFX0JJVE1BUFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuY3JlYXRlQml0bWFwID0gb3B0aW9ucy5jcmVhdGVCaXRtYXAgIT09IGZhbHNlICYmIERpc3BsYXlTZXR0aW5nc18xLkRpc3BsYXlTZXR0aW5ncy5DUkVBVEVfSU1BR0VfQklUTUFQICYmICEhd2luZG93LmNyZWF0ZUltYWdlQml0bWFwO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbnRyb2xzIHRleHR1cmUgcHJlbXVsdGlwbHlBbHBoYSBmaWVsZFxyXG4gICAgICAgICAqIENvcGllcyBmcm9tIG9wdGlvbnNcclxuICAgICAgICAgKiBAbWVtYmVyIHtib29sZWFufG51bGx9XHJcbiAgICAgICAgICogQHJlYWRvbmx5XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5wcmVtdWx0aXBseUFscGhhID0gb3B0aW9ucy5wcmVtdWx0aXBseUFscGhhICE9PSBmYWxzZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgSW1hZ2VCaXRtYXAgZWxlbWVudCBjcmVhdGVkIGZvciBIVE1MSW1hZ2VFbGVtZW50XHJcbiAgICAgICAgICogQG1lbWJlciB7SW1hZ2VCaXRtYXB9XHJcbiAgICAgICAgICogQGRlZmF1bHQgbnVsbFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuYml0bWFwID0gbnVsbDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBQcm9taXNlIHdoZW4gbG9hZGluZ1xyXG4gICAgICAgICAqIEBtZW1iZXIge1Byb21pc2U8dm9pZD59XHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKiBAZGVmYXVsdCBudWxsXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5fbG9hZCA9IG51bGw7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMuYXV0b0xvYWQgIT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIHRoaXMubG9hZCgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogcmV0dXJucyBhIHByb21pc2Ugd2hlbiBpbWFnZSB3aWxsIGJlIGxvYWRlZCBhbmQgcHJvY2Vzc2VkXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbY3JlYXRlQml0bWFwPXRydWVdIHdoZXRoZXIgcHJvY2VzcyBpbWFnZSBpbnRvIGJpdG1hcFxyXG4gICAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XHJcbiAgICAgKi9cclxuICAgIGxvYWQoY3JlYXRlQml0bWFwID0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgaWYgKGNyZWF0ZUJpdG1hcCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlQml0bWFwID0gY3JlYXRlQml0bWFwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5fbG9hZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbG9hZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fbG9hZCA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XHJcbiAgICAgICAgICAgIExvZ2dlcl8xLnRyYWNlKFwic291cmNlIFwiICsgdGhpcy5zb3VyY2UpO1xyXG4gICAgICAgICAgICB0aGlzLnVybCA9IHRoaXMuc291cmNlLnNyYztcclxuICAgICAgICAgICAgdmFyIHJlZiA9IHRoaXM7XHJcbiAgICAgICAgICAgIHZhciBzb3VyY2UgPSByZWYuc291cmNlO1xyXG4gICAgICAgICAgICB2YXIgY29tcGxldGVkID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgc291cmNlLm9ubG9hZCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICBzb3VyY2Uub25lcnJvciA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlc2l6ZShzb3VyY2Uud2lkdGgsIHNvdXJjZS5oZWlnaHQpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbG9hZCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jcmVhdGVCaXRtYXApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHRoaXMucHJvY2VzcygpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUodGhpcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGlmIChzb3VyY2UuY29tcGxldGUgJiYgc291cmNlLnNyYykge1xyXG4gICAgICAgICAgICAgICAgY29tcGxldGVkKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBzb3VyY2Uub25sb2FkID0gY29tcGxldGVkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvYWQ7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICogQ2FsbGVkIHdoZW4gd2UgbmVlZCB0byBjb252ZXJ0IGltYWdlIGludG8gQml0bWFwSW1hZ2UuXHJcbiAgICAqIENhbiBiZSBjYWxsZWQgbXVsdGlwbGUgdGltZXMsIHJlYWwgcHJvbWlzZSBpcyBjYWNoZWQgaW5zaWRlLlxyXG4gICAgKlxyXG4gICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn0gY2FjaGVkIHByb21pc2UgdG8gZmlsbCB0aGF0IGJpdG1hcFxyXG4gICAgKi9cclxuICAgIHByb2Nlc3MoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3Byb2Nlc3MgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Byb2Nlc3M7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmJpdG1hcCAhPT0gbnVsbCB8fCAhd2luZG93LmNyZWF0ZUltYWdlQml0bWFwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3Byb2Nlc3MgPSB3aW5kb3cuY3JlYXRlSW1hZ2VCaXRtYXAodGhpcy5zb3VyY2UsIDAsIDAsIHRoaXMuc291cmNlLndpZHRoLCB0aGlzLnNvdXJjZS5oZWlnaHQpXHJcbiAgICAgICAgICAgIC50aGVuKChiaXRtYXApID0+IHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoXCJcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5iaXRtYXAgPSBiaXRtYXA7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKDApO1xyXG4gICAgICAgICAgICB0aGlzLl9wcm9jZXNzID0gbnVsbDtcclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcHJvY2VzcztcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgKiBVcGxvYWQgdGhlIGltYWdlIHJlc291cmNlIHRvIEdQVS5cclxuICAgICpcclxuICAgICogQHBhcmFtIHtQSVhJLlJlbmRlcmVyfSByZW5kZXJlciAtIFJlbmRlcmVyIHRvIHVwbG9hZCB0b1xyXG4gICAgKiBAcGFyYW0ge1BJWEkuQmFzZVRleHR1cmV9IGJhc2VUZXh0dXJlIC0gQmFzZVRleHR1cmUgZm9yIHRoaXMgcmVzb3VyY2VcclxuICAgICogQHBhcmFtIHtQSVhJLkdMVGV4dHVyZX0gZ2xUZXh0dXJlIC0gR0xUZXh0dXJlIHRvIHVzZVxyXG4gICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpcyBzdWNjZXNzXHJcbiAgICAqL1xyXG4gICAgdXBsb2FkKHJlbmRlcmVyLCBiYXNlVGV4dHVyZSwgZ2xUZXh0dXJlKSB7XHJcbiAgICAgICAgYmFzZVRleHR1cmUucHJlbXVsdGlwbHlBbHBoYSA9IHRoaXMucHJlbXVsdGlwbHlBbHBoYTtcclxuICAgICAgICAvLyByZXZlYWwodGhpcy5iaXRtYXApXHJcbiAgICAgICAgaWYgKCF0aGlzLmNyZWF0ZUJpdG1hcCkge1xyXG4gICAgICAgICAgICByZXR1cm4gc3VwZXIudXBsb2FkKHJlbmRlcmVyLCBiYXNlVGV4dHVyZSwgZ2xUZXh0dXJlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCF0aGlzLmJpdG1hcCkge1xyXG4gICAgICAgICAgICAvLyB5ZWFoLCBpZ25vcmUgdGhlIG91dHB1dFxyXG4gICAgICAgICAgICB0aGlzLnByb2Nlc3MoKTtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmJpdG1hcCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIExvZ2dlcl8xLnRyYWNlKFwidXBsb2FkaW5nXCIpO1xyXG4gICAgICAgIHN1cGVyLnVwbG9hZChyZW5kZXJlciwgYmFzZVRleHR1cmUsIGdsVGV4dHVyZSwgdGhpcy5iaXRtYXApO1xyXG4gICAgICAgIGlmICghdGhpcy5wcmVzZXJ2ZUJpdG1hcCkge1xyXG4gICAgICAgICAgICAvLyBjaGVja3MgaWYgdGhlcmUgYXJlIG90aGVyIHJlbmRlcmVycyB0aGF0IHBvc3NpYmx5IG5lZWQgdGhpcyBiaXRtYXBcclxuICAgICAgICAgICAgdmFyIGZsYWcgPSB0cnVlO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gYmFzZVRleHR1cmUuX2dsVGV4dHVyZXMpIHtcclxuICAgICAgICAgICAgICAgIHZhciBvdGhlclRleCA9IGJhc2VUZXh0dXJlLl9nbFRleHR1cmVzW2tleV07XHJcbiAgICAgICAgICAgICAgICBpZiAob3RoZXJUZXggIT09IGdsVGV4dHVyZSAmJiBvdGhlclRleC5kaXJ0eUlkICE9PSBiYXNlVGV4dHVyZS5kaXJ0eUlkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmxhZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChmbGFnKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5iaXRtYXAuY2xvc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmJpdG1hcC5jbG9zZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgTG9nZ2VyXzEudHJhY2UoXCJiaXRtYXAgZmxhZ2dlZFwiKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuYml0bWFwID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgKiBEZXN0cm95cyB0aGlzIHRleHR1cmVcclxuICAgICogQG92ZXJyaWRlXHJcbiAgICAqL1xyXG4gICAgZGlzcG9zZSgpIHtcclxuICAgICAgICBzdXBlci5kaXNwb3NlKCk7XHJcbiAgICAgICAgaWYgKHRoaXMuYml0bWFwKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYml0bWFwLmNsb3NlKCk7XHJcbiAgICAgICAgICAgIHRoaXMuYml0bWFwID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fcHJvY2VzcyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5fbG9hZCA9IG51bGw7XHJcbiAgICB9XHJcbiAgICA7XHJcbn1cclxuZXhwb3J0cy5JbWFnZVJlc291cmNlID0gSW1hZ2VSZXNvdXJjZTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgUG9pbnRfMSA9IHJlcXVpcmUoXCIuL1BvaW50XCIpO1xyXG5jbGFzcyBJbnRlcmFjdGlvbkRhdGEge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5nbG9iYWwgPSBuZXcgUG9pbnRfMS5Qb2ludCgpO1xyXG4gICAgICAgIHRoaXMudGFyZ2V0ID0gbnVsbDtcclxuICAgICAgICB0aGlzLm9yaWdpbmFsRXZlbnQgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuaWRlbnRpZmllciA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5pc1ByaW1hcnkgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmJ1dHRvbiA9IDA7XHJcbiAgICAgICAgdGhpcy5idXR0b25zID0gMDtcclxuICAgICAgICB0aGlzLndpZHRoID0gMDtcclxuICAgICAgICB0aGlzLmhlaWdodCA9IDA7XHJcbiAgICAgICAgdGhpcy50aWx0WCA9IDA7XHJcbiAgICAgICAgdGhpcy50aWx0WSA9IDA7XHJcbiAgICAgICAgdGhpcy5wb2ludGVyVHlwZSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5wcmVzc3VyZSA9IDA7XHJcbiAgICAgICAgdGhpcy5yb3RhdGlvbkFuZ2xlID0gMDtcclxuICAgICAgICB0aGlzLnR3aXN0ID0gMDtcclxuICAgICAgICB0aGlzLnRhbmdlbnRpYWxQcmVzc3VyZSA9IDA7XHJcbiAgICAgICAgdGhpcy53aGljaCA9IDA7XHJcbiAgICB9XHJcbiAgICBnZXRMb2NhbFBvc2l0aW9uKGRpc3BsYXlPYmplY3QsIHBvaW50ID0gbnVsbCwgZ2xvYmFsUG9zID0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiBkaXNwbGF5T2JqZWN0LndvcmxkVHJhbnNmb3JtLmFwcGx5SW52ZXJzZShnbG9iYWxQb3MgfHwgdGhpcy5nbG9iYWwsIHBvaW50KTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIGNvcHlFdmVudChldmVudCkge1xyXG4gICAgICAgIGlmIChldmVudC5pc1ByaW1hcnkpIHtcclxuICAgICAgICAgICAgdGhpcy5pc1ByaW1hcnkgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmJ1dHRvbiA9IGV2ZW50LmJ1dHRvbjtcclxuICAgICAgICB0aGlzLmJ1dHRvbnMgPSBOdW1iZXIuaXNJbnRlZ2VyKGV2ZW50LmJ1dHRvbnMpID8gZXZlbnQuYnV0dG9ucyA6IGV2ZW50LndoaWNoO1xyXG4gICAgICAgIHRoaXMud2lkdGggPSBldmVudC53aWR0aDtcclxuICAgICAgICB0aGlzLmhlaWdodCA9IGV2ZW50LmhlaWdodDtcclxuICAgICAgICB0aGlzLnRpbHRYID0gZXZlbnQudGlsdFg7XHJcbiAgICAgICAgdGhpcy50aWx0WSA9IGV2ZW50LnRpbHRZO1xyXG4gICAgICAgIHRoaXMucG9pbnRlclR5cGUgPSBldmVudC5wb2ludGVyVHlwZTtcclxuICAgICAgICB0aGlzLnByZXNzdXJlID0gZXZlbnQucHJlc3N1cmU7XHJcbiAgICAgICAgdGhpcy5yb3RhdGlvbkFuZ2xlID0gZXZlbnQucm90YXRpb25BbmdsZTtcclxuICAgICAgICB0aGlzLnR3aXN0ID0gZXZlbnQudHdpc3QgfHwgMDtcclxuICAgICAgICB0aGlzLnRhbmdlbnRpYWxQcmVzc3VyZSA9IGV2ZW50LnRhbmdlbnRpYWxQcmVzc3VyZSB8fCAwO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgZ2V0IHBvaW50ZXJJZCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5pZGVudGlmaWVyO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgcmVzZXQoKSB7XHJcbiAgICAgICAgdGhpcy5pc1ByaW1hcnkgPSBmYWxzZTtcclxuICAgIH1cclxuICAgIDtcclxufVxyXG5leHBvcnRzLkludGVyYWN0aW9uRGF0YSA9IEludGVyYWN0aW9uRGF0YTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgRXZlbnRfMSA9IHJlcXVpcmUoXCIuL0V2ZW50XCIpO1xyXG5jbGFzcyBJbnRlcmFjdGlvbkV2ZW50IGV4dGVuZHMgRXZlbnRfMS5FdmVudCB7XHJcbiAgICBjb25zdHJ1Y3Rvcih0eXBlLCBidWJibGUgPSB0cnVlLCBjYW5jZWxhYmxlID0gdHJ1ZSkge1xyXG4gICAgICAgIHN1cGVyKHR5cGUsIGJ1YmJsZSwgY2FuY2VsYWJsZSk7XHJcbiAgICAgICAgdGhpcy50YXJnZXQgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuc3RvcHBlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX2N1cnJlbnRUYXJnZXQgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuX3R5cGUgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuZGF0YSA9IG51bGw7XHJcbiAgICB9XHJcbiAgICByZXNldCgpIHtcclxuICAgICAgICB0aGlzLnN0b3BwZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9jdXJyZW50VGFyZ2V0ID0gbnVsbDtcclxuICAgICAgICB0aGlzLnRhcmdldCA9IG51bGw7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICBzdG9wUHJvcGFnYXRpb24oKSB7XHJcbiAgICAgICAgdGhpcy5zdG9wcGVkID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIDtcclxufVxyXG5leHBvcnRzLkludGVyYWN0aW9uRXZlbnQgPSBJbnRlcmFjdGlvbkV2ZW50O1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBJbnRlcmFjdGlvbkRhdGFfMSA9IHJlcXVpcmUoXCIuL0ludGVyYWN0aW9uRGF0YVwiKTtcclxuY29uc3QgSW50ZXJhY3Rpb25FdmVudF8xID0gcmVxdWlyZShcIi4vSW50ZXJhY3Rpb25FdmVudFwiKTtcclxuY29uc3QgTW91c2VFdmVudF8xID0gcmVxdWlyZShcIi4vTW91c2VFdmVudFwiKTtcclxuY29uc3QgSW50ZXJhY3Rpb25UcmFja2luZ0RhdGFfMSA9IHJlcXVpcmUoXCIuL0ludGVyYWN0aW9uVHJhY2tpbmdEYXRhXCIpO1xyXG5jb25zdCBUaWNrZXJfMSA9IHJlcXVpcmUoXCIuL1RpY2tlclwiKTtcclxuY29uc3QgUG9pbnRfMSA9IHJlcXVpcmUoXCIuL1BvaW50XCIpO1xyXG5jb25zdCBDb250YWluZXJfMSA9IHJlcXVpcmUoXCIuL0NvbnRhaW5lclwiKTtcclxuY29uc3QgUmVjdGFuZ2xlXzEgPSByZXF1aXJlKFwiLi9SZWN0YW5nbGVcIik7XHJcbmNvbnN0IEV2ZW50RGlzcGF0Y2hlcl8xID0gcmVxdWlyZShcIi4vRXZlbnREaXNwYXRjaGVyXCIpO1xyXG5jbGFzcyBJbnRlcmFjdGlvbk1hbmFnZXIgZXh0ZW5kcyBFdmVudERpc3BhdGNoZXJfMS5FdmVudERpc3BhdGNoZXIge1xyXG4gICAgY29uc3RydWN0b3IocmVuZGVyZXIpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMudXBkYXRlID0gKGRlbHRhVGltZSkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLl9kZWx0YVRpbWUgKz0gZGVsdGFUaW1lO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fZGVsdGFUaW1lIDwgdGhpcy5pbnRlcmFjdGlvbkZyZXF1ZW5jeSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX2RlbHRhVGltZSA9IDA7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5pbnRlcmFjdGlvbkRPTUVsZW1lbnQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy5kaWRNb3ZlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRpZE1vdmUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmN1cnNvciA9IG51bGw7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGsgaW4gdGhpcy5hY3RpdmVJbnRlcmFjdGlvbkRhdGEpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmFjdGl2ZUludGVyYWN0aW9uRGF0YS5oYXNPd25Qcm9wZXJ0eShrKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBpbnRlcmFjdGlvbkRhdGEgPSB0aGlzLmFjdGl2ZUludGVyYWN0aW9uRGF0YVtrXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaW50ZXJhY3Rpb25EYXRhLm9yaWdpbmFsRXZlbnQgJiYgaW50ZXJhY3Rpb25EYXRhLnBvaW50ZXJUeXBlICE9PSAndG91Y2gnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBpbnRlcmFjdGlvbkV2ZW50ID0gdGhpcy5jb25maWd1cmVJbnRlcmFjdGlvbkV2ZW50Rm9yRE9NRXZlbnQodGhpcy5ldmVudERhdGEsIGludGVyYWN0aW9uRGF0YS5vcmlnaW5hbEV2ZW50LCBpbnRlcmFjdGlvbkRhdGEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3NJbnRlcmFjdGl2ZShpbnRlcmFjdGlvbkV2ZW50LCB0aGlzLnJlbmRlcmVyLl9sYXN0T2JqZWN0UmVuZGVyZWQsIHRoaXMucHJvY2Vzc1BvaW50ZXJPdmVyT3V0LCB0cnVlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5zZXRDdXJzb3JNb2RlKHRoaXMuY3Vyc29yKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMub25Qb2ludGVyVXAgPSAoZXZlbnQpID0+IHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuc3VwcG9ydHNUb3VjaEV2ZW50cyAmJiBldmVudC5wb2ludGVyVHlwZSA9PT0gJ3RvdWNoJykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMub25Qb2ludGVyQ29tcGxldGUoZXZlbnQsIGZhbHNlLCB0aGlzLnByb2Nlc3NQb2ludGVyVXApO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5vblBvaW50ZXJDYW5jZWwgPSAoZXZlbnQpID0+IHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuc3VwcG9ydHNUb3VjaEV2ZW50cyAmJiBldmVudC5wb2ludGVyVHlwZSA9PT0gJ3RvdWNoJykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMub25Qb2ludGVyQ29tcGxldGUoZXZlbnQsIHRydWUsIHRoaXMucHJvY2Vzc1BvaW50ZXJDYW5jZWwpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5vblBvaW50ZXJPdmVyID0gKG9yaWdpbmFsRXZlbnQpID0+IHtcclxuICAgICAgICAgICAgbGV0IGV2ZW50cyA9IHRoaXMubm9ybWFsaXplVG9Qb2ludGVyRGF0YShvcmlnaW5hbEV2ZW50KTtcclxuICAgICAgICAgICAgbGV0IGV2ZW50ID0gZXZlbnRzWzBdO1xyXG4gICAgICAgICAgICBsZXQgaW50ZXJhY3Rpb25EYXRhID0gdGhpcy5nZXRJbnRlcmFjdGlvbkRhdGFGb3JQb2ludGVySWQoZXZlbnQpO1xyXG4gICAgICAgICAgICBsZXQgaW50ZXJhY3Rpb25FdmVudCA9IHRoaXMuY29uZmlndXJlSW50ZXJhY3Rpb25FdmVudEZvckRPTUV2ZW50KHRoaXMuZXZlbnREYXRhLCBldmVudCwgaW50ZXJhY3Rpb25EYXRhKTtcclxuICAgICAgICAgICAgaW50ZXJhY3Rpb25FdmVudC5kYXRhLm9yaWdpbmFsRXZlbnQgPSBldmVudDtcclxuICAgICAgICAgICAgaWYgKGV2ZW50LnBvaW50ZXJUeXBlID09PSAnbW91c2UnKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1vdXNlT3ZlclJlbmRlcmVyID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXQgcG9pbnRlciA9IG5ldyBNb3VzZUV2ZW50XzEuTW91c2VFdmVudChNb3VzZUV2ZW50XzEuTW91c2VFdmVudC5QT0lOVEVSX09WRVIpO1xyXG4gICAgICAgICAgICBwb2ludGVyLmRhdGEgPSBpbnRlcmFjdGlvbkRhdGE7XHJcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChwb2ludGVyKTtcclxuICAgICAgICAgICAgaWYgKGV2ZW50LnBvaW50ZXJUeXBlID09PSAnbW91c2UnIHx8IGV2ZW50LnBvaW50ZXJUeXBlID09PSAncGVuJykge1xyXG4gICAgICAgICAgICAgICAgbGV0IHBvaW50ZXIgPSBuZXcgTW91c2VFdmVudF8xLk1vdXNlRXZlbnQoTW91c2VFdmVudF8xLk1vdXNlRXZlbnQuTU9VU0VfT1ZFUik7XHJcbiAgICAgICAgICAgICAgICBwb2ludGVyLmRhdGEgPSBpbnRlcmFjdGlvbkRhdGE7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQocG9pbnRlcik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQocG9pbnRlcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMub25Qb2ludGVyT3V0ID0gKG9yaWdpbmFsRXZlbnQpID0+IHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuc3VwcG9ydHNUb3VjaEV2ZW50cyAmJiBvcmlnaW5hbEV2ZW50LnBvaW50ZXJUeXBlID09PSAndG91Y2gnKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IGV2ZW50cyA9IHRoaXMubm9ybWFsaXplVG9Qb2ludGVyRGF0YShvcmlnaW5hbEV2ZW50KTtcclxuICAgICAgICAgICAgbGV0IGV2ZW50ID0gZXZlbnRzWzBdO1xyXG4gICAgICAgICAgICBpZiAoZXZlbnQucG9pbnRlclR5cGUgPT09ICdtb3VzZScpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubW91c2VPdmVyUmVuZGVyZXIgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0Q3Vyc29yTW9kZShudWxsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXQgaW50ZXJhY3Rpb25EYXRhID0gdGhpcy5nZXRJbnRlcmFjdGlvbkRhdGFGb3JQb2ludGVySWQoZXZlbnQpO1xyXG4gICAgICAgICAgICBsZXQgaW50ZXJhY3Rpb25FdmVudCA9IHRoaXMuY29uZmlndXJlSW50ZXJhY3Rpb25FdmVudEZvckRPTUV2ZW50KHRoaXMuZXZlbnREYXRhLCBldmVudCwgaW50ZXJhY3Rpb25EYXRhKTtcclxuICAgICAgICAgICAgaW50ZXJhY3Rpb25FdmVudC5kYXRhLm9yaWdpbmFsRXZlbnQgPSBldmVudDtcclxuICAgICAgICAgICAgdGhpcy5wcm9jZXNzSW50ZXJhY3RpdmUoaW50ZXJhY3Rpb25FdmVudCwgdGhpcy5yZW5kZXJlci5fbGFzdE9iamVjdFJlbmRlcmVkLCB0aGlzLnByb2Nlc3NQb2ludGVyT3Zlck91dCwgZmFsc2UpO1xyXG4gICAgICAgICAgICBsZXQgcG9pbnRlciA9IG5ldyBNb3VzZUV2ZW50XzEuTW91c2VFdmVudChNb3VzZUV2ZW50XzEuTW91c2VFdmVudC5QT0lOVEVSX09VVCk7XHJcbiAgICAgICAgICAgIHBvaW50ZXIuZGF0YSA9IGludGVyYWN0aW9uRGF0YTtcclxuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KHBvaW50ZXIpO1xyXG4gICAgICAgICAgICBpZiAoZXZlbnQucG9pbnRlclR5cGUgPT09ICdtb3VzZScgfHwgZXZlbnQucG9pbnRlclR5cGUgPT09ICdwZW4nKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgcG9pbnRlciA9IG5ldyBNb3VzZUV2ZW50XzEuTW91c2VFdmVudChNb3VzZUV2ZW50XzEuTW91c2VFdmVudC5NT1VTRV9PVVQpO1xyXG4gICAgICAgICAgICAgICAgcG9pbnRlci5kYXRhID0gaW50ZXJhY3Rpb25EYXRhO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KHBvaW50ZXIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZWxlYXNlSW50ZXJhY3Rpb25EYXRhRm9yUG9pbnRlcklkKGludGVyYWN0aW9uRGF0YS5pZGVudGlmaWVyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5vblBvaW50ZXJEb3duID0gKG9yaWdpbmFsRXZlbnQpID0+IHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuc3VwcG9ydHNUb3VjaEV2ZW50cyAmJiBvcmlnaW5hbEV2ZW50LnBvaW50ZXJUeXBlID09PSAndG91Y2gnKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IGV2ZW50cyA9IHRoaXMubm9ybWFsaXplVG9Qb2ludGVyRGF0YShvcmlnaW5hbEV2ZW50KTtcclxuICAgICAgICAgICAgbGV0IGV2ZW50ID0gZXZlbnRzWzBdO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5hdXRvUHJldmVudERlZmF1bHQgJiYgZXZlbnQuaXNOb3JtYWxpemVkKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgY2FuY2VsYWJsZSA9IG9yaWdpbmFsRXZlbnQuY2FuY2VsYWJsZSB8fCAhKCdjYW5jZWxhYmxlJyBpbiBvcmlnaW5hbEV2ZW50KTtcclxuICAgICAgICAgICAgICAgIGlmIChjYW5jZWxhYmxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxldCBldmVudExlbiA9IGV2ZW50cy5sZW5ndGg7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXZlbnRMZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgbGV0IGV2ZW50ID0gZXZlbnRzW2ldO1xyXG4gICAgICAgICAgICAgICAgbGV0IGludGVyYWN0aW9uRGF0YSA9IHRoaXMuZ2V0SW50ZXJhY3Rpb25EYXRhRm9yUG9pbnRlcklkKGV2ZW50KTtcclxuICAgICAgICAgICAgICAgIGxldCBpbnRlcmFjdGlvbkV2ZW50ID0gdGhpcy5jb25maWd1cmVJbnRlcmFjdGlvbkV2ZW50Rm9yRE9NRXZlbnQodGhpcy5ldmVudERhdGEsIGV2ZW50LCBpbnRlcmFjdGlvbkRhdGEpO1xyXG4gICAgICAgICAgICAgICAgaW50ZXJhY3Rpb25FdmVudC5kYXRhLm9yaWdpbmFsRXZlbnQgPSBvcmlnaW5hbEV2ZW50O1xyXG4gICAgICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMucHJvY2Vzc0ludGVyYWN0aXZlKGludGVyYWN0aW9uRXZlbnQsIHRoaXMucmVuZGVyZXIuX2xhc3RPYmplY3RSZW5kZXJlZCwgdGhpcy5wcm9jZXNzUG9pbnRlckRvd24sIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgbGV0IHBvaW50ZXIgPSBuZXcgTW91c2VFdmVudF8xLk1vdXNlRXZlbnQoTW91c2VFdmVudF8xLk1vdXNlRXZlbnQuUE9JTlRFUl9ET1dOKTtcclxuICAgICAgICAgICAgICAgIHBvaW50ZXIuZGF0YSA9IGludGVyYWN0aW9uRGF0YTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChwb2ludGVyKTtcclxuICAgICAgICAgICAgICAgIGlmIChldmVudC5wb2ludGVyVHlwZSA9PT0gJ3RvdWNoJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBwb2ludGVyID0gbmV3IE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50KE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50LlRPVUNIX1NUQVJUKTtcclxuICAgICAgICAgICAgICAgICAgICBwb2ludGVyLmRhdGEgPSBpbnRlcmFjdGlvbkRhdGE7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KHBvaW50ZXIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZXZlbnQucG9pbnRlclR5cGUgPT09ICdtb3VzZScgfHwgZXZlbnQucG9pbnRlclR5cGUgPT09ICdwZW4nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGlzUmlnaHRCdXR0b24gPSBldmVudC5idXR0b24gPT09IDI7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBvaW50ZXIgPSBuZXcgTW91c2VFdmVudF8xLk1vdXNlRXZlbnQoaXNSaWdodEJ1dHRvbiA/IE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50LlJJR0hUX01PVVNFX0RPV04gOiBNb3VzZUV2ZW50XzEuTW91c2VFdmVudC5NT1VTRV9ET1dOKTtcclxuICAgICAgICAgICAgICAgICAgICBwb2ludGVyLmRhdGEgPSBpbnRlcmFjdGlvbkRhdGE7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KHBvaW50ZXIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLm9uUG9pbnRlck1vdmUgPSAob3JpZ2luYWxFdmVudCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5zdXBwb3J0c1RvdWNoRXZlbnRzICYmIG9yaWdpbmFsRXZlbnQucG9pbnRlclR5cGUgPT09ICd0b3VjaCcpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXQgZXZlbnRzID0gdGhpcy5ub3JtYWxpemVUb1BvaW50ZXJEYXRhKG9yaWdpbmFsRXZlbnQpO1xyXG4gICAgICAgICAgICBpZiAoZXZlbnRzWzBdLnBvaW50ZXJUeXBlID09PSAnbW91c2UnIHx8IGV2ZW50c1swXS5wb2ludGVyVHlwZSA9PT0gJ3BlbicpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGlkTW92ZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnNvciA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IGV2ZW50TGVuID0gZXZlbnRzLmxlbmd0aDtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBldmVudExlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgZXZlbnQgPSBldmVudHNbaV07XHJcbiAgICAgICAgICAgICAgICBsZXQgaW50ZXJhY3Rpb25EYXRhID0gdGhpcy5nZXRJbnRlcmFjdGlvbkRhdGFGb3JQb2ludGVySWQoZXZlbnQpO1xyXG4gICAgICAgICAgICAgICAgbGV0IGludGVyYWN0aW9uRXZlbnQgPSB0aGlzLmNvbmZpZ3VyZUludGVyYWN0aW9uRXZlbnRGb3JET01FdmVudCh0aGlzLmV2ZW50RGF0YSwgZXZlbnQsIGludGVyYWN0aW9uRGF0YSk7XHJcbiAgICAgICAgICAgICAgICBpbnRlcmFjdGlvbkV2ZW50LmRhdGEub3JpZ2luYWxFdmVudCA9IG9yaWdpbmFsRXZlbnQ7XHJcbiAgICAgICAgICAgICAgICBsZXQgaW50ZXJhY3RpdmUgPSBldmVudC5wb2ludGVyVHlwZSA9PT0gJ3RvdWNoJyA/IHRoaXMubW92ZVdoZW5JbnNpZGUgOiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzSW50ZXJhY3RpdmUoaW50ZXJhY3Rpb25FdmVudCwgdGhpcy5yZW5kZXJlci5fbGFzdE9iamVjdFJlbmRlcmVkLCB0aGlzLnByb2Nlc3NQb2ludGVyTW92ZSwgaW50ZXJhY3RpdmUpO1xyXG4gICAgICAgICAgICAgICAgbGV0IHBvaW50ZXIgPSBuZXcgTW91c2VFdmVudF8xLk1vdXNlRXZlbnQoTW91c2VFdmVudF8xLk1vdXNlRXZlbnQuUE9JTlRFUl9NT1ZFKTtcclxuICAgICAgICAgICAgICAgIHBvaW50ZXIuZGF0YSA9IGludGVyYWN0aW9uRGF0YTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChwb2ludGVyKTtcclxuICAgICAgICAgICAgICAgIGlmIChldmVudC5wb2ludGVyVHlwZSA9PT0gJ3RvdWNoJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBwb2ludGVyID0gbmV3IE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50KE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50LlRPVUNIX01PVkUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHBvaW50ZXIuZGF0YSA9IGludGVyYWN0aW9uRGF0YTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQocG9pbnRlcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQucG9pbnRlclR5cGUgPT09ICdtb3VzZScgfHwgZXZlbnQucG9pbnRlclR5cGUgPT09ICdwZW4nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBvaW50ZXIgPSBuZXcgTW91c2VFdmVudF8xLk1vdXNlRXZlbnQoTW91c2VFdmVudF8xLk1vdXNlRXZlbnQuTU9VU0VfTU9WRSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRlci5kYXRhID0gaW50ZXJhY3Rpb25EYXRhO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChwb2ludGVyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZXZlbnRzWzBdLnBvaW50ZXJUeXBlID09PSAnbW91c2UnKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldEN1cnNvck1vZGUodGhpcy5jdXJzb3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLnByb2Nlc3NQb2ludGVyRG93biA9IChpbnRlcmFjdGlvbkV2ZW50LCBkaXNwbGF5T2JqZWN0LCBoaXQpID0+IHtcclxuICAgICAgICAgICAgbGV0IGRhdGEgPSBpbnRlcmFjdGlvbkV2ZW50LmRhdGE7XHJcbiAgICAgICAgICAgIGxldCBpZCA9IGludGVyYWN0aW9uRXZlbnQuZGF0YS5pZGVudGlmaWVyO1xyXG4gICAgICAgICAgICBpZiAoaGl0KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWRpc3BsYXlPYmplY3QudHJhY2tlZFBvaW50ZXJzW2lkXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXlPYmplY3QudHJhY2tlZFBvaW50ZXJzW2lkXSA9IG5ldyBJbnRlcmFjdGlvblRyYWNraW5nRGF0YV8xLkludGVyYWN0aW9uVHJhY2tpbmdEYXRhKGlkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGxldCBwb2ludGVyID0gbmV3IE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50KE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50LlBPSU5URVJfRE9XTik7XHJcbiAgICAgICAgICAgICAgICBwb2ludGVyLmRhdGEgPSBkYXRhO1xyXG4gICAgICAgICAgICAgICAgZGlzcGxheU9iamVjdC5kaXNwYXRjaEV2ZW50KHBvaW50ZXIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGRhdGEucG9pbnRlclR5cGUgPT09ICd0b3VjaCcpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgcG9pbnRlciA9IG5ldyBNb3VzZUV2ZW50XzEuTW91c2VFdmVudChNb3VzZUV2ZW50XzEuTW91c2VFdmVudC5UT1VDSF9TVEFSVCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRlci5kYXRhID0gZGF0YTtcclxuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5T2JqZWN0LmRpc3BhdGNoRXZlbnQocG9pbnRlcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChkYXRhLnBvaW50ZXJUeXBlID09PSAnbW91c2UnIHx8IGRhdGEucG9pbnRlclR5cGUgPT09ICdwZW4nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGlzUmlnaHRCdXR0b24gPSBkYXRhLmJ1dHRvbiA9PT0gMjtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNSaWdodEJ1dHRvbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5T2JqZWN0LnRyYWNrZWRQb2ludGVyc1tpZF0ucmlnaHREb3duID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXlPYmplY3QudHJhY2tlZFBvaW50ZXJzW2lkXS5sZWZ0RG93biA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGxldCBwb2ludGVyID0gbmV3IE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50KGlzUmlnaHRCdXR0b24gPyBNb3VzZUV2ZW50XzEuTW91c2VFdmVudC5SSUdIVF9NT1VTRV9ET1dOIDogTW91c2VFdmVudF8xLk1vdXNlRXZlbnQuTU9VU0VfRE9XTik7XHJcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRlci5kYXRhID0gZGF0YTtcclxuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5T2JqZWN0LmRpc3BhdGNoRXZlbnQocG9pbnRlcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMucHJvY2Vzc1BvaW50ZXJVcCA9IChpbnRlcmFjdGlvbkV2ZW50LCBkaXNwbGF5T2JqZWN0LCBoaXQpID0+IHtcclxuICAgICAgICAgICAgbGV0IGRhdGEgPSBpbnRlcmFjdGlvbkV2ZW50LmRhdGE7XHJcbiAgICAgICAgICAgIGxldCBpZCA9IGludGVyYWN0aW9uRXZlbnQuZGF0YS5pZGVudGlmaWVyO1xyXG4gICAgICAgICAgICBsZXQgdHJhY2tpbmdEYXRhID0gZGlzcGxheU9iamVjdC50cmFja2VkUG9pbnRlcnNbaWRdO1xyXG4gICAgICAgICAgICBsZXQgaXNUb3VjaCA9IGRhdGEucG9pbnRlclR5cGUgPT09ICd0b3VjaCc7XHJcbiAgICAgICAgICAgIGxldCBpc01vdXNlID0gKGRhdGEucG9pbnRlclR5cGUgPT09ICdtb3VzZScgfHwgZGF0YS5wb2ludGVyVHlwZSA9PT0gJ3BlbicpO1xyXG4gICAgICAgICAgICBsZXQgaXNNb3VzZVRhcCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBpZiAoaXNNb3VzZSkge1xyXG4gICAgICAgICAgICAgICAgbGV0IGlzUmlnaHRCdXR0b24gPSBkYXRhLmJ1dHRvbiA9PT0gMjtcclxuICAgICAgICAgICAgICAgIGxldCBmbGFncyA9IEludGVyYWN0aW9uVHJhY2tpbmdEYXRhXzEuSW50ZXJhY3Rpb25UcmFja2luZ0RhdGEuRkxBR1M7XHJcbiAgICAgICAgICAgICAgICBsZXQgdGVzdCA9IGlzUmlnaHRCdXR0b24gPyBmbGFncy5SSUdIVF9ET1dOIDogZmxhZ3MuTEVGVF9ET1dOO1xyXG4gICAgICAgICAgICAgICAgbGV0IGlzRG93biA9IHRyYWNraW5nRGF0YSAhPT0gdW5kZWZpbmVkICYmICh0cmFja2luZ0RhdGEuZmxhZ3MgJiB0ZXN0KTtcclxuICAgICAgICAgICAgICAgIGlmIChoaXQpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgcG9pbnRlciA9IG5ldyBNb3VzZUV2ZW50XzEuTW91c2VFdmVudChpc1JpZ2h0QnV0dG9uID8gTW91c2VFdmVudF8xLk1vdXNlRXZlbnQuUklHSFRfTU9VU0VfVVAgOiBNb3VzZUV2ZW50XzEuTW91c2VFdmVudC5NT1VTRV9VUCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRlci5kYXRhID0gZGF0YTtcclxuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5T2JqZWN0LmRpc3BhdGNoRXZlbnQocG9pbnRlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzRG93bikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgcG9pbnRlciA9IG5ldyBNb3VzZUV2ZW50XzEuTW91c2VFdmVudChpc1JpZ2h0QnV0dG9uID8gTW91c2VFdmVudF8xLk1vdXNlRXZlbnQuUklHSFRfQ0xJQ0sgOiBNb3VzZUV2ZW50XzEuTW91c2VFdmVudC5DTElDSyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50ZXIuZGF0YSA9IGRhdGE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXlPYmplY3QuZGlzcGF0Y2hFdmVudChwb2ludGVyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXNNb3VzZVRhcCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNEb3duKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBvaW50ZXIgPSBuZXcgTW91c2VFdmVudF8xLk1vdXNlRXZlbnQoaXNSaWdodEJ1dHRvbiA/IE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50LlJJR0hUX01PVVNFX1VQX09VVFNJREUgOiBNb3VzZUV2ZW50XzEuTW91c2VFdmVudC5NT1VTRV9VUF9PVVRTSURFKTtcclxuICAgICAgICAgICAgICAgICAgICBwb2ludGVyLmRhdGEgPSBkYXRhO1xyXG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXlPYmplY3QuZGlzcGF0Y2hFdmVudChwb2ludGVyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh0cmFja2luZ0RhdGEpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNSaWdodEJ1dHRvbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFja2luZ0RhdGEucmlnaHREb3duID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFja2luZ0RhdGEubGVmdERvd24gPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGhpdCkge1xyXG4gICAgICAgICAgICAgICAgbGV0IHBvaW50ZXIgPSBuZXcgTW91c2VFdmVudF8xLk1vdXNlRXZlbnQoTW91c2VFdmVudF8xLk1vdXNlRXZlbnQuUE9JTlRFUl9VUCk7XHJcbiAgICAgICAgICAgICAgICBwb2ludGVyLmRhdGEgPSBkYXRhO1xyXG4gICAgICAgICAgICAgICAgZGlzcGxheU9iamVjdC5kaXNwYXRjaEV2ZW50KHBvaW50ZXIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzVG91Y2gpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgcG9pbnRlciA9IG5ldyBNb3VzZUV2ZW50XzEuTW91c2VFdmVudChNb3VzZUV2ZW50XzEuTW91c2VFdmVudC5UT1VDSF9FTkQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHBvaW50ZXIuZGF0YSA9IGRhdGE7XHJcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheU9iamVjdC5kaXNwYXRjaEV2ZW50KHBvaW50ZXIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHRyYWNraW5nRGF0YSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNNb3VzZSB8fCBpc01vdXNlVGFwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBwb2ludGVyID0gbmV3IE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50KE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50LlBPSU5URVJfVEFQKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRlci5kYXRhID0gZGF0YTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheU9iamVjdC5kaXNwYXRjaEV2ZW50KHBvaW50ZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNUb3VjaCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgcG9pbnRlciA9IG5ldyBNb3VzZUV2ZW50XzEuTW91c2VFdmVudChNb3VzZUV2ZW50XzEuTW91c2VFdmVudC5UT1VDSF9UQVApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludGVyLmRhdGEgPSBkYXRhO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5T2JqZWN0LmRpc3BhdGNoRXZlbnQocG9pbnRlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYWNraW5nRGF0YS5vdmVyID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHRyYWNraW5nRGF0YSkge1xyXG4gICAgICAgICAgICAgICAgbGV0IHBvaW50ZXIgPSBuZXcgTW91c2VFdmVudF8xLk1vdXNlRXZlbnQoTW91c2VFdmVudF8xLk1vdXNlRXZlbnQuUE9JTlRFUl9VUF9PVVRTSURFKTtcclxuICAgICAgICAgICAgICAgIHBvaW50ZXIuZGF0YSA9IGRhdGE7XHJcbiAgICAgICAgICAgICAgICBkaXNwbGF5T2JqZWN0LmRpc3BhdGNoRXZlbnQocG9pbnRlcik7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNUb3VjaCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBwb2ludGVyID0gbmV3IE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50KE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50LlRPVUNIX0VORF9PVVRTSURFKTtcclxuICAgICAgICAgICAgICAgICAgICBwb2ludGVyLmRhdGEgPSBkYXRhO1xyXG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXlPYmplY3QuZGlzcGF0Y2hFdmVudChwb2ludGVyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodHJhY2tpbmdEYXRhICYmIHRyYWNraW5nRGF0YS5ub25lKSB7XHJcbiAgICAgICAgICAgICAgICBkZWxldGUgZGlzcGxheU9iamVjdC50cmFja2VkUG9pbnRlcnNbaWRdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLnByb2Nlc3NQb2ludGVyTW92ZSA9IChpbnRlcmFjdGlvbkV2ZW50LCBkaXNwbGF5T2JqZWN0LCBoaXQpID0+IHtcclxuICAgICAgICAgICAgbGV0IGRhdGEgPSBpbnRlcmFjdGlvbkV2ZW50LmRhdGE7XHJcbiAgICAgICAgICAgIGxldCBpc1RvdWNoID0gZGF0YS5wb2ludGVyVHlwZSA9PT0gJ3RvdWNoJztcclxuICAgICAgICAgICAgbGV0IGlzTW91c2UgPSAoZGF0YS5wb2ludGVyVHlwZSA9PT0gJ21vdXNlJyB8fCBkYXRhLnBvaW50ZXJUeXBlID09PSAncGVuJyk7XHJcbiAgICAgICAgICAgIGlmIChpc01vdXNlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3NQb2ludGVyT3Zlck91dChpbnRlcmFjdGlvbkV2ZW50LCBkaXNwbGF5T2JqZWN0LCBoaXQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5tb3ZlV2hlbkluc2lkZSB8fCBoaXQpIHtcclxuICAgICAgICAgICAgICAgIGxldCBwb2ludGVyID0gbmV3IE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50KE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50LlBPSU5URVJfTU9WRSk7XHJcbiAgICAgICAgICAgICAgICBwb2ludGVyLmRhdGEgPSBkYXRhO1xyXG4gICAgICAgICAgICAgICAgZGlzcGxheU9iamVjdC5kaXNwYXRjaEV2ZW50KHBvaW50ZXIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzVG91Y2gpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgcG9pbnRlciA9IG5ldyBNb3VzZUV2ZW50XzEuTW91c2VFdmVudChNb3VzZUV2ZW50XzEuTW91c2VFdmVudC5UT1VDSF9NT1ZFKTtcclxuICAgICAgICAgICAgICAgICAgICBwb2ludGVyLmRhdGEgPSBkYXRhO1xyXG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXlPYmplY3QuZGlzcGF0Y2hFdmVudChwb2ludGVyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChpc01vdXNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBvaW50ZXIgPSBuZXcgTW91c2VFdmVudF8xLk1vdXNlRXZlbnQoTW91c2VFdmVudF8xLk1vdXNlRXZlbnQuTU9VU0VfTU9WRSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRlci5kYXRhID0gZGF0YTtcclxuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5T2JqZWN0LmRpc3BhdGNoRXZlbnQocG9pbnRlcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMucHJvY2Vzc1BvaW50ZXJPdmVyT3V0ID0gKGludGVyYWN0aW9uRXZlbnQsIGRpc3BsYXlPYmplY3QsIGhpdCkgPT4ge1xyXG4gICAgICAgICAgICBsZXQgZGF0YSA9IGludGVyYWN0aW9uRXZlbnQuZGF0YTtcclxuICAgICAgICAgICAgbGV0IGlkID0gaW50ZXJhY3Rpb25FdmVudC5kYXRhLmlkZW50aWZpZXI7XHJcbiAgICAgICAgICAgIGxldCBpc01vdXNlID0gKGRhdGEucG9pbnRlclR5cGUgPT09ICdtb3VzZScgfHwgZGF0YS5wb2ludGVyVHlwZSA9PT0gJ3BlbicpO1xyXG4gICAgICAgICAgICBsZXQgdHJhY2tpbmdEYXRhID0gZGlzcGxheU9iamVjdC50cmFja2VkUG9pbnRlcnNbaWRdO1xyXG4gICAgICAgICAgICBpZiAoaGl0ICYmICF0cmFja2luZ0RhdGEpIHtcclxuICAgICAgICAgICAgICAgIHRyYWNraW5nRGF0YSA9IGRpc3BsYXlPYmplY3QudHJhY2tlZFBvaW50ZXJzW2lkXSA9IG5ldyBJbnRlcmFjdGlvblRyYWNraW5nRGF0YV8xLkludGVyYWN0aW9uVHJhY2tpbmdEYXRhKGlkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodHJhY2tpbmdEYXRhID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoaGl0ICYmIHRoaXMubW91c2VPdmVyUmVuZGVyZXIpIHtcclxuICAgICAgICAgICAgICAgIGlmICghdHJhY2tpbmdEYXRhLm92ZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICB0cmFja2luZ0RhdGEub3ZlciA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBvaW50ZXIgPSBuZXcgTW91c2VFdmVudF8xLk1vdXNlRXZlbnQoTW91c2VFdmVudF8xLk1vdXNlRXZlbnQuUE9JTlRFUl9PVkVSKTtcclxuICAgICAgICAgICAgICAgICAgICBwb2ludGVyLmRhdGEgPSBkYXRhO1xyXG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXlPYmplY3QuZGlzcGF0Y2hFdmVudChwb2ludGVyKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNNb3VzZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgcG9pbnRlciA9IG5ldyBNb3VzZUV2ZW50XzEuTW91c2VFdmVudChNb3VzZUV2ZW50XzEuTW91c2VFdmVudC5NT1VTRV9PVkVSKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRlci5kYXRhID0gZGF0YTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheU9iamVjdC5kaXNwYXRjaEV2ZW50KHBvaW50ZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChpc01vdXNlICYmIHRoaXMuY3Vyc29yID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJzb3IgPSBkaXNwbGF5T2JqZWN0LmN1cnNvcjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0cmFja2luZ0RhdGEub3Zlcikge1xyXG4gICAgICAgICAgICAgICAgdHJhY2tpbmdEYXRhLm92ZXIgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGxldCBwb2ludGVyID0gbmV3IE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50KE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50LlBPSU5URVJfT1VUKTtcclxuICAgICAgICAgICAgICAgIHBvaW50ZXIuZGF0YSA9IGRhdGE7XHJcbiAgICAgICAgICAgICAgICBkaXNwbGF5T2JqZWN0LmRpc3BhdGNoRXZlbnQocG9pbnRlcik7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNNb3VzZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBwb2ludGVyID0gbmV3IE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50KE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50Lk1PVVNFX09VVCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRlci5kYXRhID0gZGF0YTtcclxuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5T2JqZWN0LmRpc3BhdGNoRXZlbnQocG9pbnRlcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAodHJhY2tpbmdEYXRhLm5vbmUpIHtcclxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgZGlzcGxheU9iamVjdC50cmFja2VkUG9pbnRlcnNbaWRdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLmhpdFRlc3RFdmVudCA9IG5ldyBJbnRlcmFjdGlvbkV2ZW50XzEuSW50ZXJhY3Rpb25FdmVudChudWxsLCBudWxsLCBudWxsKTtcclxuICAgICAgICB0aGlzLmhpdFRlc3RFdmVudC50YXJnZXQgPSBudWxsO1xyXG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcclxuICAgICAgICB0aGlzLmF1dG9QcmV2ZW50RGVmYXVsdCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5pbnRlcmFjdGlvbkZyZXF1ZW5jeSA9IDEwO1xyXG4gICAgICAgIHRoaXMubW91c2UgPSBuZXcgSW50ZXJhY3Rpb25EYXRhXzEuSW50ZXJhY3Rpb25EYXRhKCk7XHJcbiAgICAgICAgdGhpcy5tb3VzZS5pZGVudGlmaWVyID0gSW50ZXJhY3Rpb25NYW5hZ2VyLk1PVVNFX1BPSU5URVJfSUQ7XHJcbiAgICAgICAgdGhpcy5tb3VzZS5nbG9iYWwuc2V0KC05OTk5OTkpO1xyXG4gICAgICAgIHRoaXMuYWN0aXZlSW50ZXJhY3Rpb25EYXRhID0ge307XHJcbiAgICAgICAgdGhpcy5hY3RpdmVJbnRlcmFjdGlvbkRhdGFbSW50ZXJhY3Rpb25NYW5hZ2VyLk1PVVNFX1BPSU5URVJfSURdID0gdGhpcy5tb3VzZTtcclxuICAgICAgICB0aGlzLmludGVyYWN0aW9uRGF0YVBvb2wgPSBbXTtcclxuICAgICAgICB0aGlzLmV2ZW50RGF0YSA9IG5ldyBJbnRlcmFjdGlvbkV2ZW50XzEuSW50ZXJhY3Rpb25FdmVudChcImludGVyYWN0aW9uXCIpO1xyXG4gICAgICAgIHRoaXMuaW50ZXJhY3Rpb25ET01FbGVtZW50ID0gbnVsbDtcclxuICAgICAgICB0aGlzLm1vdmVXaGVuSW5zaWRlID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5ldmVudHNBZGRlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMubW91c2VPdmVyUmVuZGVyZXIgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnN1cHBvcnRzVG91Y2hFdmVudHMgPSAnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3c7XHJcbiAgICAgICAgdGhpcy5zdXBwb3J0c1BvaW50ZXJFdmVudHMgPSAhIXdpbmRvd1snUG9pbnRlckV2ZW50J107XHJcbiAgICAgICAgdGhpcy5jdXJzb3JTdHlsZXMgPSB7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6ICdpbmhlcml0JyxcclxuICAgICAgICAgICAgcG9pbnRlcjogJ3BvaW50ZXInXHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLmN1cnJlbnRDdXJzb3JNb2RlID0gbnVsbDtcclxuICAgICAgICB0aGlzLmN1cnNvciA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5fdGVtcFBvaW50ID0gbmV3IFBvaW50XzEuUG9pbnQoKTtcclxuICAgICAgICB0aGlzLnJlc29sdXRpb24gPSAxO1xyXG4gICAgICAgIHRoaXMuc2V0VGFyZ2V0RWxlbWVudCh0aGlzLnJlbmRlcmVyLnZpZXcsIHRoaXMucmVuZGVyZXIucmVzb2x1dGlvbik7XHJcbiAgICB9XHJcbiAgICBzZXRUYXJnZXRFbGVtZW50KGVsZW1lbnQsIHJlc29sdXRpb24gPSAxKSB7XHJcbiAgICAgICAgdGhpcy5yZW1vdmVFdmVudHMoKTtcclxuICAgICAgICB0aGlzLmludGVyYWN0aW9uRE9NRWxlbWVudCA9IGVsZW1lbnQ7XHJcbiAgICAgICAgdGhpcy5yZXNvbHV0aW9uID0gcmVzb2x1dGlvbjtcclxuICAgICAgICB0aGlzLmFkZEV2ZW50cygpO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgcmVtb3ZlRXZlbnRzKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5pbnRlcmFjdGlvbkRPTUVsZW1lbnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBUaWNrZXJfMS5UaWNrZXIuc3lzdGVtLnJlbW92ZSh0aGlzLnVwZGF0ZSk7XHJcbiAgICAgICAgaWYgKHdpbmRvdy5uYXZpZ2F0b3IubXNQb2ludGVyRW5hYmxlZCkge1xyXG4gICAgICAgICAgICB0aGlzLmludGVyYWN0aW9uRE9NRWxlbWVudC5zdHlsZVsnLW1zLWNvbnRlbnQtem9vbWluZyddID0gJyc7XHJcbiAgICAgICAgICAgIHRoaXMuaW50ZXJhY3Rpb25ET01FbGVtZW50LnN0eWxlWyctbXMtdG91Y2gtYWN0aW9uJ10gPSAnJztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5zdXBwb3J0c1BvaW50ZXJFdmVudHMpIHtcclxuICAgICAgICAgICAgdGhpcy5pbnRlcmFjdGlvbkRPTUVsZW1lbnQuc3R5bGVbJ3RvdWNoLWFjdGlvbiddID0gJyc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLnN1cHBvcnRzUG9pbnRlckV2ZW50cykge1xyXG4gICAgICAgICAgICB3aW5kb3cuZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigncG9pbnRlcm1vdmUnLCB0aGlzLm9uUG9pbnRlck1vdmUpO1xyXG4gICAgICAgICAgICB0aGlzLmludGVyYWN0aW9uRE9NRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdwb2ludGVyZG93bicsIHRoaXMub25Qb2ludGVyRG93bik7XHJcbiAgICAgICAgICAgIHRoaXMuaW50ZXJhY3Rpb25ET01FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJsZWF2ZScsIHRoaXMub25Qb2ludGVyT3V0KTtcclxuICAgICAgICAgICAgdGhpcy5pbnRlcmFjdGlvbkRPTUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigncG9pbnRlcm92ZXInLCB0aGlzLm9uUG9pbnRlck92ZXIpO1xyXG4gICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncG9pbnRlcmNhbmNlbCcsIHRoaXMub25Qb2ludGVyQ2FuY2VsKTtcclxuICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJ1cCcsIHRoaXMub25Qb2ludGVyVXApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgd2luZG93LmRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMub25Qb2ludGVyTW92ZSk7XHJcbiAgICAgICAgICAgIHRoaXMuaW50ZXJhY3Rpb25ET01FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMub25Qb2ludGVyRG93bik7XHJcbiAgICAgICAgICAgIHRoaXMuaW50ZXJhY3Rpb25ET01FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlb3V0JywgdGhpcy5vblBvaW50ZXJPdXQpO1xyXG4gICAgICAgICAgICB0aGlzLmludGVyYWN0aW9uRE9NRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW92ZXInLCB0aGlzLm9uUG9pbnRlck92ZXIpO1xyXG4gICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMub25Qb2ludGVyVXApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5zdXBwb3J0c1RvdWNoRXZlbnRzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaW50ZXJhY3Rpb25ET01FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCB0aGlzLm9uUG9pbnRlckRvd24pO1xyXG4gICAgICAgICAgICB0aGlzLmludGVyYWN0aW9uRE9NRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGNhbmNlbCcsIHRoaXMub25Qb2ludGVyQ2FuY2VsKTtcclxuICAgICAgICAgICAgdGhpcy5pbnRlcmFjdGlvbkRPTUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0aGlzLm9uUG9pbnRlclVwKTtcclxuICAgICAgICAgICAgdGhpcy5pbnRlcmFjdGlvbkRPTUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5vblBvaW50ZXJNb3ZlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5pbnRlcmFjdGlvbkRPTUVsZW1lbnQgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuZXZlbnRzQWRkZWQgPSBmYWxzZTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIG1hcFBvc2l0aW9uVG9Qb2ludChwb2ludCwgeCwgeSkge1xyXG4gICAgICAgIGxldCByZWN0O1xyXG4gICAgICAgIGlmICghdGhpcy5pbnRlcmFjdGlvbkRPTUVsZW1lbnQucGFyZW50RWxlbWVudCkge1xyXG4gICAgICAgICAgICByZWN0ID0gbmV3IFJlY3RhbmdsZV8xLlJlY3RhbmdsZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmVjdCA9IHRoaXMuaW50ZXJhY3Rpb25ET01FbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgcmVzb2x1dGlvbk11bHRpcGxpZXIgPSAxLjAgLyB0aGlzLnJlc29sdXRpb247XHJcbiAgICAgICAgcG9pbnQueCA9ICgoeCAtIHJlY3QubGVmdCkgKiAodGhpcy5pbnRlcmFjdGlvbkRPTUVsZW1lbnQud2lkdGggLyByZWN0LndpZHRoKSkgKiByZXNvbHV0aW9uTXVsdGlwbGllcjtcclxuICAgICAgICBwb2ludC55ID0gKCh5IC0gcmVjdC50b3ApICogKHRoaXMuaW50ZXJhY3Rpb25ET01FbGVtZW50LmhlaWdodCAvIHJlY3QuaGVpZ2h0KSkgKiByZXNvbHV0aW9uTXVsdGlwbGllcjtcclxuICAgIH1cclxuICAgIDtcclxuICAgIGNvbmZpZ3VyZUludGVyYWN0aW9uRXZlbnRGb3JET01FdmVudChpbnRlcmFjdGlvbkV2ZW50LCBwb2ludGVyRXZlbnQsIGludGVyYWN0aW9uRGF0YSkge1xyXG4gICAgICAgIGludGVyYWN0aW9uRXZlbnQuZGF0YSA9IGludGVyYWN0aW9uRGF0YTtcclxuICAgICAgICB0aGlzLm1hcFBvc2l0aW9uVG9Qb2ludChpbnRlcmFjdGlvbkRhdGEuZ2xvYmFsLCBwb2ludGVyRXZlbnQuY2xpZW50WCwgcG9pbnRlckV2ZW50LmNsaWVudFkpO1xyXG4gICAgICAgIGlmIChwb2ludGVyRXZlbnQucG9pbnRlclR5cGUgPT09ICd0b3VjaCcpIHtcclxuICAgICAgICAgICAgcG9pbnRlckV2ZW50Lmdsb2JhbFggPSBpbnRlcmFjdGlvbkRhdGEuZ2xvYmFsLng7XHJcbiAgICAgICAgICAgIHBvaW50ZXJFdmVudC5nbG9iYWxZID0gaW50ZXJhY3Rpb25EYXRhLmdsb2JhbC55O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpbnRlcmFjdGlvbkRhdGEub3JpZ2luYWxFdmVudCA9IHBvaW50ZXJFdmVudDtcclxuICAgICAgICBpbnRlcmFjdGlvbkV2ZW50LnJlc2V0KCk7XHJcbiAgICAgICAgcmV0dXJuIGludGVyYWN0aW9uRXZlbnQ7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICBhZGRFdmVudHMoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmludGVyYWN0aW9uRE9NRWxlbWVudCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFRpY2tlcl8xLlRpY2tlci5zeXN0ZW0uYWRkKHRoaXMudXBkYXRlLCB0aGlzLCBUaWNrZXJfMS5UaWNrZXIuVVBEQVRFX1BSSU9SSVRZLklOVEVSQUNUSU9OKTtcclxuICAgICAgICBpZiAod2luZG93Lm5hdmlnYXRvci5tc1BvaW50ZXJFbmFibGVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaW50ZXJhY3Rpb25ET01FbGVtZW50LnN0eWxlWyctbXMtY29udGVudC16b29taW5nJ10gPSAnbm9uZSc7XHJcbiAgICAgICAgICAgIHRoaXMuaW50ZXJhY3Rpb25ET01FbGVtZW50LnN0eWxlWyctbXMtdG91Y2gtYWN0aW9uJ10gPSAnbm9uZSc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMuc3VwcG9ydHNQb2ludGVyRXZlbnRzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaW50ZXJhY3Rpb25ET01FbGVtZW50LnN0eWxlWyd0b3VjaC1hY3Rpb24nXSA9ICdub25lJztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuc3VwcG9ydHNQb2ludGVyRXZlbnRzKSB7XHJcbiAgICAgICAgICAgIHdpbmRvdy5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVybW92ZScsIHRoaXMub25Qb2ludGVyTW92ZSk7XHJcbiAgICAgICAgICAgIHRoaXMuaW50ZXJhY3Rpb25ET01FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJkb3duJywgdGhpcy5vblBvaW50ZXJEb3duKTtcclxuICAgICAgICAgICAgdGhpcy5pbnRlcmFjdGlvbkRPTUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcmxlYXZlJywgdGhpcy5vblBvaW50ZXJPdXQpO1xyXG4gICAgICAgICAgICB0aGlzLmludGVyYWN0aW9uRE9NRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVyb3ZlcicsIHRoaXMub25Qb2ludGVyT3Zlcik7XHJcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVyY2FuY2VsJywgdGhpcy5vblBvaW50ZXJDYW5jZWwpO1xyXG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcnVwJywgdGhpcy5vblBvaW50ZXJVcCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB3aW5kb3cuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5vblBvaW50ZXJNb3ZlKTtcclxuICAgICAgICAgICAgdGhpcy5pbnRlcmFjdGlvbkRPTUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5vblBvaW50ZXJEb3duKTtcclxuICAgICAgICAgICAgdGhpcy5pbnRlcmFjdGlvbkRPTUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VvdXQnLCB0aGlzLm9uUG9pbnRlck91dCk7XHJcbiAgICAgICAgICAgIHRoaXMuaW50ZXJhY3Rpb25ET01FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlb3ZlcicsIHRoaXMub25Qb2ludGVyT3Zlcik7XHJcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5vblBvaW50ZXJVcCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLnN1cHBvcnRzVG91Y2hFdmVudHMpIHtcclxuICAgICAgICAgICAgdGhpcy5pbnRlcmFjdGlvbkRPTUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRoaXMub25Qb2ludGVyRG93bik7XHJcbiAgICAgICAgICAgIHRoaXMuaW50ZXJhY3Rpb25ET01FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoY2FuY2VsJywgdGhpcy5vblBvaW50ZXJDYW5jZWwpO1xyXG4gICAgICAgICAgICB0aGlzLmludGVyYWN0aW9uRE9NRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMub25Qb2ludGVyVXApO1xyXG4gICAgICAgICAgICB0aGlzLmludGVyYWN0aW9uRE9NRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLm9uUG9pbnRlck1vdmUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmV2ZW50c0FkZGVkID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIHByb2Nlc3NJbnRlcmFjdGl2ZShpbnRlcmFjdGlvbkV2ZW50LCBkaXNwbGF5T2JqZWN0LCBmdW5jLCBoaXRUZXN0LCBpbnRlcmFjdGl2ZSA9IHRydWUpIHtcclxuICAgICAgICBpZiAoIWRpc3BsYXlPYmplY3QgfHwgIWRpc3BsYXlPYmplY3QudmlzaWJsZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBwb2ludCA9IGludGVyYWN0aW9uRXZlbnQuZGF0YS5nbG9iYWw7XHJcbiAgICAgICAgaW50ZXJhY3RpdmUgPSBkaXNwbGF5T2JqZWN0LmludGVyYWN0aXZlIHx8IGludGVyYWN0aXZlO1xyXG4gICAgICAgIGxldCBoaXQgPSBmYWxzZTtcclxuICAgICAgICBsZXQgaW50ZXJhY3RpdmVQYXJlbnQgPSBpbnRlcmFjdGl2ZTtcclxuICAgICAgICBsZXQgaGl0VGVzdENoaWxkcmVuID0gdHJ1ZTtcclxuICAgICAgICBpZiAoZGlzcGxheU9iamVjdC5oaXRBcmVhKSB7XHJcbiAgICAgICAgICAgIGlmIChoaXRUZXN0KSB7XHJcbiAgICAgICAgICAgICAgICBkaXNwbGF5T2JqZWN0LndvcmxkVHJhbnNmb3JtLmFwcGx5SW52ZXJzZShwb2ludCwgdGhpcy5fdGVtcFBvaW50KTtcclxuICAgICAgICAgICAgICAgIGlmICghZGlzcGxheU9iamVjdC5oaXRBcmVhLmNvbnRhaW5zKHRoaXMuX3RlbXBQb2ludC54LCB0aGlzLl90ZW1wUG9pbnQueSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBoaXRUZXN0ID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgaGl0VGVzdENoaWxkcmVuID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBoaXQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGludGVyYWN0aXZlUGFyZW50ID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGRpc3BsYXlPYmplY3QuX21hc2spIHtcclxuICAgICAgICAgICAgaWYgKGhpdFRlc3QpIHtcclxuICAgICAgICAgICAgICAgIGlmICghKGRpc3BsYXlPYmplY3QuX21hc2suY29udGFpbnNQb2ludCAmJiBkaXNwbGF5T2JqZWN0Ll9tYXNrLmNvbnRhaW5zUG9pbnQocG9pbnQpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGhpdFRlc3QgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICBoaXRUZXN0Q2hpbGRyZW4gPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZGlzcGxheU9iamVjdCBpbnN0YW5jZW9mIENvbnRhaW5lcl8xLkNvbnRhaW5lcikge1xyXG4gICAgICAgICAgICBpZiAoaGl0VGVzdENoaWxkcmVuICYmIGRpc3BsYXlPYmplY3QuaW50ZXJhY3RpdmVDaGlsZHJlbiAmJiBkaXNwbGF5T2JqZWN0LmNoaWxkcmVuKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgY2hpbGRyZW4gPSBkaXNwbGF5T2JqZWN0LmNoaWxkcmVuO1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IGNoaWxkcmVuLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNoaWxkID0gY2hpbGRyZW5baV07XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNoaWxkSGl0ID0gdGhpcy5wcm9jZXNzSW50ZXJhY3RpdmUoaW50ZXJhY3Rpb25FdmVudCwgY2hpbGQsIGZ1bmMsIGhpdFRlc3QsIGludGVyYWN0aXZlUGFyZW50KTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGRIaXQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjaGlsZC5wYXJlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVyYWN0aXZlUGFyZW50ID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZEhpdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGludGVyYWN0aW9uRXZlbnQudGFyZ2V0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGl0VGVzdCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGl0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaW50ZXJhY3RpdmUpIHtcclxuICAgICAgICAgICAgaWYgKGhpdFRlc3QgJiYgIWludGVyYWN0aW9uRXZlbnQudGFyZ2V0KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWRpc3BsYXlPYmplY3QuaGl0QXJlYSAmJiBkaXNwbGF5T2JqZWN0LmNvbnRhaW5zUG9pbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZGlzcGxheU9iamVjdC5jb250YWluc1BvaW50KHBvaW50KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBoaXQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZGlzcGxheU9iamVjdC5pbnRlcmFjdGl2ZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGhpdCAmJiAhaW50ZXJhY3Rpb25FdmVudC50YXJnZXQpIHtcclxuICAgICAgICAgICAgICAgICAgICBpbnRlcmFjdGlvbkV2ZW50LnRhcmdldCA9IGRpc3BsYXlPYmplY3Q7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoZnVuYykge1xyXG4gICAgICAgICAgICAgICAgICAgIGZ1bmMoaW50ZXJhY3Rpb25FdmVudCwgZGlzcGxheU9iamVjdCwgISFoaXQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBoaXQ7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICBzZXRDdXJzb3JNb2RlKG1vZGUgPSBcImRlZmF1bHRcIikge1xyXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRDdXJzb3JNb2RlID09PSBtb2RlKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jdXJyZW50Q3Vyc29yTW9kZSA9IG1vZGU7XHJcbiAgICAgICAgbGV0IHN0eWxlID0gdGhpcy5jdXJzb3JTdHlsZXNbbW9kZV07XHJcbiAgICAgICAgaWYgKHN0eWxlKSB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIHN0eWxlKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW50ZXJhY3Rpb25ET01FbGVtZW50LnN0eWxlLmN1cnNvciA9IHN0eWxlO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnZnVuY3Rpb24nOlxyXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlKG1vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcclxuICAgICAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMuaW50ZXJhY3Rpb25ET01FbGVtZW50LnN0eWxlLCBzdHlsZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIG1vZGUgPT09ICdzdHJpbmcnICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5jdXJzb3JTdHlsZXMsIG1vZGUpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaW50ZXJhY3Rpb25ET01FbGVtZW50LnN0eWxlLmN1cnNvciA9IG1vZGU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgaGl0VGVzdChnbG9iYWxQb2ludCwgcm9vdCkge1xyXG4gICAgICAgIHRoaXMuaGl0VGVzdEV2ZW50LnRhcmdldCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5oaXRUZXN0RXZlbnQuZGF0YS5nbG9iYWwgPSBnbG9iYWxQb2ludDtcclxuICAgICAgICBsZXQgY3VycmVudGRpc3BsYXk7XHJcbiAgICAgICAgaWYgKHJvb3QpIHtcclxuICAgICAgICAgICAgY3VycmVudGRpc3BsYXkgPSByb290O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY3VycmVudGRpc3BsYXkgPSB0aGlzLnJlbmRlcmVyLl9sYXN0T2JqZWN0UmVuZGVyZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMucHJvY2Vzc0ludGVyYWN0aXZlKHRoaXMuaGl0VGVzdEV2ZW50LCBjdXJyZW50ZGlzcGxheSwgbnVsbCwgdHJ1ZSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaGl0VGVzdEV2ZW50LnRhcmdldDtcclxuICAgIH1cclxuICAgIDtcclxuICAgIG5vcm1hbGl6ZVRvUG9pbnRlckRhdGEoZXZlbnQpIHtcclxuICAgICAgICBsZXQgbm9ybWFsaXplZEV2ZW50cyA9IFtdO1xyXG4gICAgICAgIGlmICh0aGlzLnN1cHBvcnRzVG91Y2hFdmVudHMgJiYgZXZlbnQgaW5zdGFuY2VvZiBUb3VjaEV2ZW50KSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsaSA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzLmxlbmd0aDsgaSA8IGxpOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGxldCB0b3VjaCA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzW2ldO1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0b3VjaC5idXR0b24gPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdG91Y2guYnV0dG9uID0gZXZlbnQudG91Y2hlcy5sZW5ndGggPyAxIDogMDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdG91Y2guYnV0dG9ucyA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgICAgICAgICB0b3VjaC5idXR0b25zID0gZXZlbnQudG91Y2hlcy5sZW5ndGggPyAxIDogMDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdG91Y2guaXNQcmltYXJ5ID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRvdWNoLmlzUHJpbWFyeSA9IGV2ZW50LnRvdWNoZXMubGVuZ3RoID09PSAxICYmIGV2ZW50LnR5cGUgPT09ICd0b3VjaHN0YXJ0JztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdG91Y2gud2lkdGggPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdG91Y2gud2lkdGggPSB0b3VjaC5yYWRpdXNYIHx8IDE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRvdWNoLmhlaWdodCA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgICAgICAgICB0b3VjaC5oZWlnaHQgPSB0b3VjaC5yYWRpdXNZIHx8IDE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRvdWNoLnRpbHRYID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRvdWNoLnRpbHRYID0gMDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdG91Y2gudGlsdFkgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdG91Y2gudGlsdFkgPSAwO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0b3VjaC5wb2ludGVyVHlwZSA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgICAgICAgICB0b3VjaC5wb2ludGVyVHlwZSA9ICd0b3VjaCc7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRvdWNoLnBvaW50ZXJJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgICAgICAgICB0b3VjaC5wb2ludGVySWQgPSB0b3VjaC5pZGVudGlmaWVyIHx8IDA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRvdWNoLnByZXNzdXJlID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRvdWNoLnByZXNzdXJlID0gdG91Y2guZm9yY2UgfHwgMC41O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0b3VjaC50d2lzdCA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgICAgICAgICB0b3VjaC50d2lzdCA9IDA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRvdWNoLnRhbmdlbnRpYWxQcmVzc3VyZSA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgICAgICAgICB0b3VjaC50YW5nZW50aWFsUHJlc3N1cmUgPSAwO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0b3VjaC5sYXllclggPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdG91Y2gubGF5ZXJYID0gdG91Y2gub2Zmc2V0WCA9IHRvdWNoLmNsaWVudFg7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRvdWNoLmxheWVyWSA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgICAgICAgICB0b3VjaC5sYXllclkgPSB0b3VjaC5vZmZzZXRZID0gdG91Y2guY2xpZW50WTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRvdWNoLmlzTm9ybWFsaXplZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBub3JtYWxpemVkRXZlbnRzLnB1c2godG91Y2gpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGV2ZW50IGluc3RhbmNlb2YgTW91c2VFdmVudF8xLk1vdXNlRXZlbnQgJiYgKCF0aGlzLnN1cHBvcnRzUG9pbnRlckV2ZW50cyB8fCAhKGV2ZW50IGluc3RhbmNlb2Ygd2luZG93WydQb2ludGVyRXZlbnQnXSkpKSB7XHJcbiAgICAgICAgICAgIGxldCBvcmlnaW5ldmVudCA9IGV2ZW50O1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIG9yaWdpbmV2ZW50LmlzUHJpbWFyeSA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgICAgIG9yaWdpbmV2ZW50LmlzUHJpbWFyeSA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcmlnaW5ldmVudC53aWR0aCA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgICAgIG9yaWdpbmV2ZW50LndpZHRoID0gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIG9yaWdpbmV2ZW50LmhlaWdodCA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgICAgIG9yaWdpbmV2ZW50LmhlaWdodCA9IDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcmlnaW5ldmVudC50aWx0WCA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgICAgIG9yaWdpbmV2ZW50LnRpbHRYID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIG9yaWdpbmV2ZW50LnRpbHRZID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAgICAgb3JpZ2luZXZlbnQudGlsdFkgPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3JpZ2luZXZlbnQucG9pbnRlclR5cGUgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgICAgICBvcmlnaW5ldmVudC5wb2ludGVyVHlwZSA9ICdtb3VzZSc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcmlnaW5ldmVudC5wb2ludGVySWQgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgICAgICBvcmlnaW5ldmVudC5wb2ludGVySWQgPSBJbnRlcmFjdGlvbk1hbmFnZXIuTU9VU0VfUE9JTlRFUl9JRDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIG9yaWdpbmV2ZW50LnByZXNzdXJlID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAgICAgb3JpZ2luZXZlbnQucHJlc3N1cmUgPSAwLjU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcmlnaW5ldmVudC50d2lzdCA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgICAgIG9yaWdpbmV2ZW50LnR3aXN0ID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIG9yaWdpbmV2ZW50LnRhbmdlbnRpYWxQcmVzc3VyZSA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgICAgIG9yaWdpbmV2ZW50LnRhbmdlbnRpYWxQcmVzc3VyZSA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb3JpZ2luZXZlbnQuaXNOb3JtYWxpemVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgbm9ybWFsaXplZEV2ZW50cy5wdXNoKGV2ZW50KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZWRFdmVudHMucHVzaChldmVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBub3JtYWxpemVkRXZlbnRzO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgZ2V0SW50ZXJhY3Rpb25EYXRhRm9yUG9pbnRlcklkKGV2ZW50KSB7XHJcbiAgICAgICAgbGV0IHBvaW50ZXJJZCA9IGV2ZW50LnBvaW50ZXJJZDtcclxuICAgICAgICBsZXQgaW50ZXJhY3Rpb25EYXRhO1xyXG4gICAgICAgIGlmIChwb2ludGVySWQgPT09IEludGVyYWN0aW9uTWFuYWdlci5NT1VTRV9QT0lOVEVSX0lEIHx8IGV2ZW50LnBvaW50ZXJUeXBlID09PSAnbW91c2UnKSB7XHJcbiAgICAgICAgICAgIGludGVyYWN0aW9uRGF0YSA9IHRoaXMubW91c2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMuYWN0aXZlSW50ZXJhY3Rpb25EYXRhW3BvaW50ZXJJZF0pIHtcclxuICAgICAgICAgICAgaW50ZXJhY3Rpb25EYXRhID0gdGhpcy5hY3RpdmVJbnRlcmFjdGlvbkRhdGFbcG9pbnRlcklkXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGludGVyYWN0aW9uRGF0YSA9IHRoaXMuaW50ZXJhY3Rpb25EYXRhUG9vbC5wb3AoKSB8fCBuZXcgSW50ZXJhY3Rpb25EYXRhXzEuSW50ZXJhY3Rpb25EYXRhKCk7XHJcbiAgICAgICAgICAgIGludGVyYWN0aW9uRGF0YS5pZGVudGlmaWVyID0gcG9pbnRlcklkO1xyXG4gICAgICAgICAgICB0aGlzLmFjdGl2ZUludGVyYWN0aW9uRGF0YVtwb2ludGVySWRdID0gaW50ZXJhY3Rpb25EYXRhO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpbnRlcmFjdGlvbkRhdGEuY29weUV2ZW50KGV2ZW50KTtcclxuICAgICAgICByZXR1cm4gaW50ZXJhY3Rpb25EYXRhO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgb25Qb2ludGVyQ29tcGxldGUob3JpZ2luYWxFdmVudCwgY2FuY2VsbGVkLCBmdW5jKSB7XHJcbiAgICAgICAgbGV0IGV2ZW50cyA9IHRoaXMubm9ybWFsaXplVG9Qb2ludGVyRGF0YShvcmlnaW5hbEV2ZW50KTtcclxuICAgICAgICBsZXQgZXZlbnRMZW4gPSBldmVudHMubGVuZ3RoO1xyXG4gICAgICAgIGxldCBldmVudEFwcGVuZCA9IG9yaWdpbmFsRXZlbnQudGFyZ2V0ICE9PSB0aGlzLmludGVyYWN0aW9uRE9NRWxlbWVudCA/ICdvdXRzaWRlJyA6ICcnO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXZlbnRMZW47IGkrKykge1xyXG4gICAgICAgICAgICBsZXQgZXZlbnQgPSBldmVudHNbaV07XHJcbiAgICAgICAgICAgIGxldCBpbnRlcmFjdGlvbkRhdGEgPSB0aGlzLmdldEludGVyYWN0aW9uRGF0YUZvclBvaW50ZXJJZChldmVudCk7XHJcbiAgICAgICAgICAgIGxldCBpbnRlcmFjdGlvbkV2ZW50ID0gdGhpcy5jb25maWd1cmVJbnRlcmFjdGlvbkV2ZW50Rm9yRE9NRXZlbnQodGhpcy5ldmVudERhdGEsIGV2ZW50LCBpbnRlcmFjdGlvbkRhdGEpO1xyXG4gICAgICAgICAgICBpbnRlcmFjdGlvbkV2ZW50LmRhdGEub3JpZ2luYWxFdmVudCA9IG9yaWdpbmFsRXZlbnQ7XHJcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc0ludGVyYWN0aXZlKGludGVyYWN0aW9uRXZlbnQsIHRoaXMucmVuZGVyZXIuX2xhc3RPYmplY3RSZW5kZXJlZCwgZnVuYywgY2FuY2VsbGVkIHx8ICFldmVudEFwcGVuZCk7XHJcbiAgICAgICAgICAgIGxldCBwb2ludGVyID0gbmV3IE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50KGNhbmNlbGxlZCA/IE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50LlBPSU5URVJfQ0FOQ0VMIDogKE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50LlBPSU5URVJfVVApKTtcclxuICAgICAgICAgICAgcG9pbnRlci5kYXRhID0gaW50ZXJhY3Rpb25EYXRhO1xyXG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQocG9pbnRlcik7XHJcbiAgICAgICAgICAgIGlmIChldmVudC5wb2ludGVyVHlwZSA9PT0gJ21vdXNlJyB8fCBldmVudC5wb2ludGVyVHlwZSA9PT0gJ3BlbicpIHtcclxuICAgICAgICAgICAgICAgIGxldCBpc1JpZ2h0QnV0dG9uID0gZXZlbnQuYnV0dG9uID09PSAyO1xyXG4gICAgICAgICAgICAgICAgbGV0IHBvaW50ZXIgPSBuZXcgTW91c2VFdmVudF8xLk1vdXNlRXZlbnQoaXNSaWdodEJ1dHRvbiA/IChNb3VzZUV2ZW50XzEuTW91c2VFdmVudC5SSUdIVF9NT1VTRV9VUCkgOiAoTW91c2VFdmVudF8xLk1vdXNlRXZlbnQuTU9VU0VfVVApKTtcclxuICAgICAgICAgICAgICAgIHBvaW50ZXIuZGF0YSA9IGludGVyYWN0aW9uRGF0YTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChwb2ludGVyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChldmVudC5wb2ludGVyVHlwZSA9PT0gJ3RvdWNoJykge1xyXG4gICAgICAgICAgICAgICAgbGV0IHBvaW50ZXIgPSBuZXcgTW91c2VFdmVudF8xLk1vdXNlRXZlbnQoY2FuY2VsbGVkID8gTW91c2VFdmVudF8xLk1vdXNlRXZlbnQuVE9VQ0hfQ0FOQ0VMIDogKE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50LlRPVUNIX0VORCkpO1xyXG4gICAgICAgICAgICAgICAgcG9pbnRlci5kYXRhID0gaW50ZXJhY3Rpb25EYXRhO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KHBvaW50ZXIpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZWxlYXNlSW50ZXJhY3Rpb25EYXRhRm9yUG9pbnRlcklkKGV2ZW50LnBvaW50ZXJJZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICByZWxlYXNlSW50ZXJhY3Rpb25EYXRhRm9yUG9pbnRlcklkKHBvaW50ZXJJZCkge1xyXG4gICAgICAgIGxldCBpbnRlcmFjdGlvbkRhdGEgPSB0aGlzLmFjdGl2ZUludGVyYWN0aW9uRGF0YVtwb2ludGVySWRdO1xyXG4gICAgICAgIGlmIChpbnRlcmFjdGlvbkRhdGEpIHtcclxuICAgICAgICAgICAgZGVsZXRlIHRoaXMuYWN0aXZlSW50ZXJhY3Rpb25EYXRhW3BvaW50ZXJJZF07XHJcbiAgICAgICAgICAgIGludGVyYWN0aW9uRGF0YS5yZXNldCgpO1xyXG4gICAgICAgICAgICB0aGlzLmludGVyYWN0aW9uRGF0YVBvb2wucHVzaChpbnRlcmFjdGlvbkRhdGEpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIDtcclxuICAgIHByb2Nlc3NQb2ludGVyQ2FuY2VsKGludGVyYWN0aW9uRXZlbnQsIGRpc3BsYXlPYmplY3QpIHtcclxuICAgICAgICBsZXQgZGF0YSA9IGludGVyYWN0aW9uRXZlbnQuZGF0YTtcclxuICAgICAgICBsZXQgaWQgPSBpbnRlcmFjdGlvbkV2ZW50LmRhdGEuaWRlbnRpZmllcjtcclxuICAgICAgICBpZiAoZGlzcGxheU9iamVjdC50cmFja2VkUG9pbnRlcnNbaWRdICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgZGVsZXRlIGRpc3BsYXlPYmplY3QudHJhY2tlZFBvaW50ZXJzW2lkXTtcclxuICAgICAgICAgICAgbGV0IHBvaW50ZXIgPSBuZXcgTW91c2VFdmVudF8xLk1vdXNlRXZlbnQoTW91c2VFdmVudF8xLk1vdXNlRXZlbnQuUE9JTlRFUl9DQU5DRUwpO1xyXG4gICAgICAgICAgICBwb2ludGVyLmRhdGEgPSBkYXRhO1xyXG4gICAgICAgICAgICBkaXNwbGF5T2JqZWN0LmRpc3BhdGNoRXZlbnQocG9pbnRlcik7XHJcbiAgICAgICAgICAgIGlmIChkYXRhLnBvaW50ZXJUeXBlID09PSAndG91Y2gnKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgcG9pbnRlciA9IG5ldyBNb3VzZUV2ZW50XzEuTW91c2VFdmVudChNb3VzZUV2ZW50XzEuTW91c2VFdmVudC5UT1VDSF9DQU5DRUwpO1xyXG4gICAgICAgICAgICAgICAgcG9pbnRlci5kYXRhID0gZGF0YTtcclxuICAgICAgICAgICAgICAgIGRpc3BsYXlPYmplY3QuZGlzcGF0Y2hFdmVudChwb2ludGVyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIDtcclxuICAgIGRlc3Ryb3kob3B0aW9ucyA9IG51bGwpIHtcclxuICAgICAgICB0aGlzLnJlbW92ZUV2ZW50cygpO1xyXG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSBudWxsO1xyXG4gICAgICAgIHRoaXMubW91c2UgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuZXZlbnREYXRhID0gbnVsbDtcclxuICAgICAgICB0aGlzLmludGVyYWN0aW9uRE9NRWxlbWVudCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5vblBvaW50ZXJEb3duID0gbnVsbDtcclxuICAgICAgICB0aGlzLnByb2Nlc3NQb2ludGVyRG93biA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5vblBvaW50ZXJVcCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5wcm9jZXNzUG9pbnRlclVwID0gbnVsbDtcclxuICAgICAgICB0aGlzLm9uUG9pbnRlckNhbmNlbCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5wcm9jZXNzUG9pbnRlckNhbmNlbCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5vblBvaW50ZXJNb3ZlID0gbnVsbDtcclxuICAgICAgICB0aGlzLnByb2Nlc3NQb2ludGVyTW92ZSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5vblBvaW50ZXJPdXQgPSBudWxsO1xyXG4gICAgICAgIHRoaXMucHJvY2Vzc1BvaW50ZXJPdmVyT3V0ID0gbnVsbDtcclxuICAgICAgICB0aGlzLm9uUG9pbnRlck92ZXIgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuX3RlbXBQb2ludCA9IG51bGw7XHJcbiAgICB9XHJcbiAgICA7XHJcbn1cclxuSW50ZXJhY3Rpb25NYW5hZ2VyLk1PVVNFX1BPSU5URVJfSUQgPSAxO1xyXG5leHBvcnRzLkludGVyYWN0aW9uTWFuYWdlciA9IEludGVyYWN0aW9uTWFuYWdlcjtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY2xhc3MgSW50ZXJhY3Rpb25UcmFja2luZ0RhdGEge1xyXG4gICAgY29uc3RydWN0b3IocG9pbnRlcklkKSB7XHJcbiAgICAgICAgdGhpcy5fcG9pbnRlcklkID0gcG9pbnRlcklkO1xyXG4gICAgICAgIHRoaXMuX2ZsYWdzID0gSW50ZXJhY3Rpb25UcmFja2luZ0RhdGEuRkxBR1MuTk9ORTtcclxuICAgIH1cclxuICAgIF9kb1NldChmbGFnLCB5bikge1xyXG4gICAgICAgIGlmICh5bikge1xyXG4gICAgICAgICAgICB0aGlzLl9mbGFncyA9IHRoaXMuX2ZsYWdzIHwgZmxhZztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2ZsYWdzID0gdGhpcy5fZmxhZ3MgJiAofmZsYWcpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIDtcclxuICAgIGdldCBwb2ludGVySWQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BvaW50ZXJJZDtcclxuICAgIH1cclxuICAgIDtcclxuICAgIGdldCBmbGFncygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZmxhZ3M7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICBzZXQgZmxhZ3MoZmxhZ3MpIHtcclxuICAgICAgICB0aGlzLl9mbGFncyA9IGZsYWdzO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgZ2V0IG5vbmUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZsYWdzID09PSBJbnRlcmFjdGlvblRyYWNraW5nRGF0YS5GTEFHUy5OT05FO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgZ2V0IG92ZXIoKSB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLl9mbGFncyAmIEludGVyYWN0aW9uVHJhY2tpbmdEYXRhLkZMQUdTLk9WRVIpICE9PSAwO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgc2V0IG92ZXIoeW4pIHtcclxuICAgICAgICB0aGlzLl9kb1NldChJbnRlcmFjdGlvblRyYWNraW5nRGF0YS5GTEFHUy5PVkVSLCB5bik7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICBnZXQgcmlnaHREb3duKCkge1xyXG4gICAgICAgIHJldHVybiAodGhpcy5fZmxhZ3MgJiBJbnRlcmFjdGlvblRyYWNraW5nRGF0YS5GTEFHUy5SSUdIVF9ET1dOKSAhPT0gMDtcclxuICAgIH1cclxuICAgIDtcclxuICAgIHNldCByaWdodERvd24oeW4pIHtcclxuICAgICAgICB0aGlzLl9kb1NldChJbnRlcmFjdGlvblRyYWNraW5nRGF0YS5GTEFHUy5SSUdIVF9ET1dOLCB5bik7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICBnZXQgbGVmdERvd24oKSB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLl9mbGFncyAmIEludGVyYWN0aW9uVHJhY2tpbmdEYXRhLkZMQUdTLkxFRlRfRE9XTikgIT09IDA7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICBzZXQgbGVmdERvd24oeW4pIHtcclxuICAgICAgICB0aGlzLl9kb1NldChJbnRlcmFjdGlvblRyYWNraW5nRGF0YS5GTEFHUy5MRUZUX0RPV04sIHluKTtcclxuICAgIH1cclxuICAgIDtcclxufVxyXG5JbnRlcmFjdGlvblRyYWNraW5nRGF0YS5GTEFHUyA9IHtcclxuICAgIE5PTkU6IDAsXHJcbiAgICBPVkVSOiAxIDw8IDAsXHJcbiAgICBMRUZUX0RPV046IDEgPDwgMSxcclxuICAgIFJJR0hUX0RPV046IDEgPDwgMixcclxufTtcclxuZXhwb3J0cy5JbnRlcmFjdGlvblRyYWNraW5nRGF0YSA9IEludGVyYWN0aW9uVHJhY2tpbmdEYXRhO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBGaWxsU3R5bGVfMSA9IHJlcXVpcmUoXCIuL0ZpbGxTdHlsZVwiKTtcclxuY2xhc3MgTGluZVN0eWxlIGV4dGVuZHMgRmlsbFN0eWxlXzEuRmlsbFN0eWxlIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICB9XHJcbiAgICBjbG9uZSgpIHtcclxuICAgICAgICB2YXIgb2JqID0gbmV3IExpbmVTdHlsZSgpO1xyXG4gICAgICAgIG9iai5jb2xvciA9IHRoaXMuY29sb3I7XHJcbiAgICAgICAgb2JqLmFscGhhID0gdGhpcy5hbHBoYTtcclxuICAgICAgICBvYmoudGV4dHVyZSA9IHRoaXMudGV4dHVyZTtcclxuICAgICAgICBvYmoubWF0cml4ID0gdGhpcy5tYXRyaXg7XHJcbiAgICAgICAgb2JqLnZpc2libGUgPSB0aGlzLnZpc2libGU7XHJcbiAgICAgICAgb2JqLndpZHRoID0gdGhpcy53aWR0aDtcclxuICAgICAgICBvYmouYWxpZ25tZW50ID0gdGhpcy5hbGlnbm1lbnQ7XHJcbiAgICAgICAgb2JqLm5hdGl2ZSA9IHRoaXMubmF0aXZlO1xyXG4gICAgICAgIHJldHVybiBvYmo7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFJlc2V0IHRoZSBsaW5lIHN0eWxlIHRvIGRlZmF1bHQuXHJcbiAgICAgKi9cclxuICAgIHJlc2V0KCkge1xyXG4gICAgICAgIHN1cGVyLnJlc2V0KCk7XHJcbiAgICAgICAgLy8gT3ZlcnJpZGUgZGVmYXVsdCBsaW5lIHN0eWxlIGNvbG9yXHJcbiAgICAgICAgdGhpcy5jb2xvciA9IDB4MDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgd2lkdGggKHRoaWNrbmVzcykgb2YgYW55IGxpbmVzIGRyYXduLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICAgICAqIEBkZWZhdWx0IDBcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLndpZHRoID0gMDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgYWxpZ25tZW50IG9mIGFueSBsaW5lcyBkcmF3biAoMC41ID0gbWlkZGxlLCAxID0gb3V0dGVyLCAwID0gaW5uZXIpLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICAgICAqIEBkZWZhdWx0IDBcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmFsaWdubWVudCA9IDAuNTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJZiB0cnVlIHRoZSBsaW5lcyB3aWxsIGJlIGRyYXcgdXNpbmcgTElORVMgaW5zdGVhZCBvZiBUUklBTkdMRV9TVFJJUFxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQG1lbWJlciB7Ym9vbGVhbn1cclxuICAgICAgICAgKiBAZGVmYXVsdCBmYWxzZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMubmF0aXZlID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICA7XHJcbn1cclxuZXhwb3J0cy5MaW5lU3R5bGUgPSBMaW5lU3R5bGU7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMuT1VUUFVUX1RPX0NPTlNPTEUgPSB0cnVlO1xyXG5leHBvcnRzLnRyYWNlID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGlmICghdmFsdWUpIHtcclxuICAgICAgICAgICAgaWYgKGlzTmFOKHZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFwic2hvdzogbnVsbFwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFwic2hvdzogMFwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gXCJzaG93OiBcIiArIHZhbHVlLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChleHBvcnRzLk9VVFBVVF9UT19DT05TT0xFKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHJlc3VsdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZSkge1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbn07XHJcbmV4cG9ydHMucmV2ZWFsTWV0aG9kcyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBpZiAoIXZhbHVlKSB7XHJcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBcInJldmVhbCBtZXRob2RzOiBudWxsXCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gXCJyZXZlYWwgbWV0aG9kczogXCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xyXG4gICAgICAgICAgICB2YXIgaW5zdGFuY2VJdGVtID0gdmFsdWVba2V5XTtcclxuICAgICAgICAgICAgaWYgKGluc3RhbmNlSXRlbSBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gJ21ldGhvZDogJyArIGtleSArICcgOiAnICsgdmFsdWVba2V5XSArIFwiXFxuXCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGV4cG9ydHMuT1VUUFVUX1RPX0NPTlNPTEUpIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2cocmVzdWx0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIGNhdGNoIChlKSB7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbDtcclxufTtcclxuZXhwb3J0cy5yZXZlYWwgPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgIGlmICghdmFsdWUpIHtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gXCJyZXZlYWw6IG51bGxcIjtcclxuICAgICAgICBpZiAoZXhwb3J0cy5PVVRQVVRfVE9fQ09OU09MRSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhyZXN1bHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHZhciByZXN1bHQgPSBcInJldmVhbDogdW5kZWZpbmVkXCI7XHJcbiAgICAgICAgaWYgKGV4cG9ydHMuT1VUUFVUX1RPX0NPTlNPTEUpIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2cocmVzdWx0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgdmFyIHJlc3VsdCA9IFwicmV2ZWFsOiBcIjtcclxuICAgIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xyXG4gICAgICAgIHZhciBpbnN0YW5jZUl0ZW0gPSBnZXRWYWx1ZShrZXksIHZhbHVlKTtcclxuICAgICAgICBpZiAoaW5zdGFuY2VJdGVtKSB7XHJcbiAgICAgICAgICAgIGlmIChpbnN0YW5jZUl0ZW0gaW5zdGFuY2VvZiBGdW5jdGlvbikge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9ICdtZXRob2Q6ICcgKyBrZXkgKyBcIlxcblwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0ga2V5ICsgJyA6ICcgKyBpbnN0YW5jZUl0ZW0gKyBcIlxcblwiO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChleHBvcnRzLk9VVFBVVF9UT19DT05TT0xFKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2cocmVzdWx0KTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn07XHJcbmNvbnN0IGdldFZhbHVlID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcclxuICAgIHZhciB2YWx1ZVJlc3VsdCA9IG51bGw7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHZhbHVlUmVzdWx0ID0gdmFsdWVba2V5XTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlKSB7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdmFsdWVSZXN1bHQ7XHJcbn07XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IFN5c3RlbV8xID0gcmVxdWlyZShcIi4vU3lzdGVtXCIpO1xyXG5jb25zdCBTcHJpdGVNYXNrRmlsdGVyXzEgPSByZXF1aXJlKFwiLi9TcHJpdGVNYXNrRmlsdGVyXCIpO1xyXG5jbGFzcyBNYXNrU3lzdGVtIGV4dGVuZHMgU3lzdGVtXzEuU3lzdGVtIHtcclxuICAgIGNvbnN0cnVjdG9yKHJlbmRlcmVyKSB7XHJcbiAgICAgICAgc3VwZXIocmVuZGVyZXIpO1xyXG4gICAgICAgIC8vIFRPRE8gLSB3ZSBkb24ndCBuZWVkIGJvdGghXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogYHRydWVgIGlmIGN1cnJlbnQgcHVzaGVkIG1hc2tlZCBpcyBzY2lzc29yXHJcbiAgICAgICAgICogQG1lbWJlciB7Ym9vbGVhbn1cclxuICAgICAgICAgKiBAcmVhZG9ubHlcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnNjaXNzb3IgPSBmYWxzZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBNYXNrIGRhdGFcclxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLkdyYXBoaWNzfVxyXG4gICAgICAgICAqIEByZWFkb25seVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuc2Npc3NvckRhdGEgPSBudWxsO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRhcmdldCB0byBtYXNrXHJcbiAgICAgICAgICogQG1lbWJlciB7UElYSS5EaXNwbGF5T2JqZWN0fVxyXG4gICAgICAgICAqIEByZWFkb25seVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuc2Npc3NvclJlbmRlclRhcmdldCA9IG51bGw7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRW5hYmxlIHNjaXNzb3JcclxuICAgICAgICAgKiBAbWVtYmVyIHtib29sZWFufVxyXG4gICAgICAgICAqIEByZWFkb25seVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuZW5hYmxlU2Npc3NvciA9IGZhbHNlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFBvb2wgb2YgdXNlZCBzcHJpdGUgbWFzayBmaWx0ZXJzXHJcbiAgICAgICAgICogQG1lbWJlciB7UElYSS5TcHJpdGVNYXNrRmlsdGVyW119XHJcbiAgICAgICAgICogQHJlYWRvbmx5XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5hbHBoYU1hc2tQb29sID0gW107XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ3VycmVudCBpbmRleCBvZiBhbHBoYSBtYXNrIHBvb2xcclxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgICAgICogQGRlZmF1bHQgMFxyXG4gICAgICAgICAqIEByZWFkb25seVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuYWxwaGFNYXNrSW5kZXggPSAwO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBsaWVzIHRoZSBNYXNrIGFuZCBhZGRzIGl0IHRvIHRoZSBjdXJyZW50IGZpbHRlciBzdGFjay5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1BJWEkuRGlzcGxheU9iamVjdH0gdGFyZ2V0IC0gRGlzcGxheSBPYmplY3QgdG8gcHVzaCB0aGUgbWFzayB0b1xyXG4gICAgICogQHBhcmFtIHtQSVhJLlNwcml0ZXxQSVhJLkdyYXBoaWNzfSBtYXNrRGF0YSAtIFRoZSBtYXNraW5nIGRhdGEuXHJcbiAgICAgKi9cclxuICAgIHB1c2godGFyZ2V0LCBtYXNrRGF0YSkge1xyXG4gICAgICAgIC8vIFRPRE8gdGhlIHJvb3QgY2hlY2sgbWVhbnMgc2Npc3NvciByZWN0IHdpbGwgbm90XHJcbiAgICAgICAgLy8gYmUgdXNlZCBvbiByZW5kZXIgdGV4dHVyZXMgbW9yZSBpbmZvIGhlcmU6XHJcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BpeGlqcy9waXhpLmpzL3B1bGwvMzU0NVxyXG4gICAgICAgIGlmIChtYXNrRGF0YS5pc1Nwcml0ZSkge1xyXG4gICAgICAgICAgICB0aGlzLnB1c2hTcHJpdGVNYXNrKHRhcmdldCwgbWFza0RhdGEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLmVuYWJsZVNjaXNzb3JcclxuICAgICAgICAgICAgJiYgIXRoaXMuc2Npc3NvclxyXG4gICAgICAgICAgICAmJiB0aGlzLnJlbmRlcmVyLl9hY3RpdmVSZW5kZXJUYXJnZXQucm9vdFxyXG4gICAgICAgICAgICAmJiAhdGhpcy5yZW5kZXJlci5zdGVuY2lsLnN0ZW5jaWxNYXNrU3RhY2subGVuZ3RoXHJcbiAgICAgICAgICAgICYmIG1hc2tEYXRhLmlzRmFzdFJlY3QoKSkge1xyXG4gICAgICAgICAgICB2YXIgbWF0cml4ID0gbWFza0RhdGEud29ybGRUcmFuc2Zvcm07XHJcbiAgICAgICAgICAgIHZhciByb3QgPSBNYXRoLmF0YW4yKG1hdHJpeC5iLCBtYXRyaXguYSk7XHJcbiAgICAgICAgICAgIC8vIHVzZSB0aGUgbmVhcmVzdCBkZWdyZWUhXHJcbiAgICAgICAgICAgIHJvdCA9IE1hdGgucm91bmQocm90ICogKDE4MCAvIE1hdGguUEkpKTtcclxuICAgICAgICAgICAgaWYgKHJvdCAlIDkwKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnB1c2hTdGVuY2lsTWFzayhtYXNrRGF0YSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnB1c2hTY2lzc29yTWFzayh0YXJnZXQsIG1hc2tEYXRhKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5wdXNoU3RlbmNpbE1hc2sobWFza0RhdGEpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyB0aGUgbGFzdCBtYXNrIGZyb20gdGhlIG1hc2sgc3RhY2sgYW5kIGRvZXNuJ3QgcmV0dXJuIGl0LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7UElYSS5EaXNwbGF5T2JqZWN0fSB0YXJnZXQgLSBEaXNwbGF5IE9iamVjdCB0byBwb3AgdGhlIG1hc2sgZnJvbVxyXG4gICAgICogQHBhcmFtIHtQSVhJLlNwcml0ZXxQSVhJLkdyYXBoaWNzfSBtYXNrRGF0YSAtIFRoZSBtYXNraW5nIGRhdGEuXHJcbiAgICAgKi9cclxuICAgIHBvcCh0YXJnZXQsIG1hc2tEYXRhKSB7XHJcbiAgICAgICAgaWYgKG1hc2tEYXRhLmlzU3ByaXRlKSB7XHJcbiAgICAgICAgICAgIHRoaXMucG9wU3ByaXRlTWFzayh0YXJnZXQsIG1hc2tEYXRhKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5lbmFibGVTY2lzc29yICYmICF0aGlzLnJlbmRlcmVyLnN0ZW5jaWwuc3RlbmNpbE1hc2tTdGFjay5sZW5ndGgpIHtcclxuICAgICAgICAgICAgdGhpcy5wb3BTY2lzc29yTWFzayh0YXJnZXQsIG1hc2tEYXRhKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMucG9wU3RlbmNpbE1hc2sodGFyZ2V0LCBtYXNrRGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBsaWVzIHRoZSBNYXNrIGFuZCBhZGRzIGl0IHRvIHRoZSBjdXJyZW50IGZpbHRlciBzdGFjay5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1BJWEkuUmVuZGVyVGV4dHVyZX0gdGFyZ2V0IC0gRGlzcGxheSBPYmplY3QgdG8gcHVzaCB0aGUgc3ByaXRlIG1hc2sgdG9cclxuICAgICAqIEBwYXJhbSB7UElYSS5TcHJpdGV9IG1hc2tEYXRhIC0gU3ByaXRlIHRvIGJlIHVzZWQgYXMgdGhlIG1hc2tcclxuICAgICAqL1xyXG4gICAgcHVzaFNwcml0ZU1hc2sodGFyZ2V0LCBtYXNrRGF0YSkge1xyXG4gICAgICAgIHZhciBhbHBoYU1hc2tGaWx0ZXIgPSB0aGlzLmFscGhhTWFza1Bvb2xbdGhpcy5hbHBoYU1hc2tJbmRleF07XHJcbiAgICAgICAgaWYgKCFhbHBoYU1hc2tGaWx0ZXIpIHtcclxuICAgICAgICAgICAgYWxwaGFNYXNrRmlsdGVyID0gdGhpcy5hbHBoYU1hc2tQb29sW3RoaXMuYWxwaGFNYXNrSW5kZXhdID0gW25ldyBTcHJpdGVNYXNrRmlsdGVyXzEuU3ByaXRlTWFza0ZpbHRlcihtYXNrRGF0YSldO1xyXG4gICAgICAgIH1cclxuICAgICAgICBhbHBoYU1hc2tGaWx0ZXJbMF0ucmVzb2x1dGlvbiA9IHRoaXMucmVuZGVyZXIucmVzb2x1dGlvbjtcclxuICAgICAgICBhbHBoYU1hc2tGaWx0ZXJbMF0ubWFza1Nwcml0ZSA9IG1hc2tEYXRhO1xyXG4gICAgICAgIHZhciBzdGFzaEZpbHRlckFyZWEgPSB0YXJnZXQuZmlsdGVyQXJlYTtcclxuICAgICAgICB0YXJnZXQuZmlsdGVyQXJlYSA9IG1hc2tEYXRhLmdldEJvdW5kcyh0cnVlKTtcclxuICAgICAgICB0aGlzLnJlbmRlcmVyLmZpbHRlci5wdXNoKHRhcmdldCwgYWxwaGFNYXNrRmlsdGVyKTtcclxuICAgICAgICB0YXJnZXQuZmlsdGVyQXJlYSA9IHN0YXNoRmlsdGVyQXJlYTtcclxuICAgICAgICB0aGlzLmFscGhhTWFza0luZGV4Kys7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgdGhlIGxhc3QgZmlsdGVyIGZyb20gdGhlIGZpbHRlciBzdGFjayBhbmQgZG9lc24ndCByZXR1cm4gaXQuXHJcbiAgICAgKlxyXG4gICAgICovXHJcbiAgICBwb3BTcHJpdGVNYXNrKGEsIGIpIHtcclxuICAgICAgICB0aGlzLnJlbmRlcmVyLmZpbHRlci5wb3AoKTtcclxuICAgICAgICB0aGlzLmFscGhhTWFza0luZGV4LS07XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIEFwcGxpZXMgdGhlIE1hc2sgYW5kIGFkZHMgaXQgdG8gdGhlIGN1cnJlbnQgZmlsdGVyIHN0YWNrLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7UElYSS5TcHJpdGV8UElYSS5HcmFwaGljc30gbWFza0RhdGEgLSBUaGUgbWFza2luZyBkYXRhLlxyXG4gICAgICovXHJcbiAgICBwdXNoU3RlbmNpbE1hc2sobWFza0RhdGEpIHtcclxuICAgICAgICB0aGlzLnJlbmRlcmVyLmJhdGNoLmZsdXNoKCk7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJlci5zdGVuY2lsLnB1c2hTdGVuY2lsKG1hc2tEYXRhKTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyB0aGUgbGFzdCBmaWx0ZXIgZnJvbSB0aGUgZmlsdGVyIHN0YWNrIGFuZCBkb2Vzbid0IHJldHVybiBpdC5cclxuICAgICAqXHJcbiAgICAgKi9cclxuICAgIHBvcFN0ZW5jaWxNYXNrKGEsIGIpIHtcclxuICAgICAgICAvLyB0aGlzLnJlbmRlcmVyLmN1cnJlbnRSZW5kZXJlci5zdG9wKCk7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJlci5zdGVuY2lsLnBvcFN0ZW5jaWwoKTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7UElYSS5EaXNwbGF5T2JqZWN0fSB0YXJnZXQgLSBEaXNwbGF5IE9iamVjdCB0byBwdXNoIHRoZSBtYXNrIHRvXHJcbiAgICAgKiBAcGFyYW0ge1BJWEkuR3JhcGhpY3N9IG1hc2tEYXRhIC0gVGhlIG1hc2tpbmcgZGF0YS5cclxuICAgICAqL1xyXG4gICAgcHVzaFNjaXNzb3JNYXNrKHRhcmdldCwgbWFza0RhdGEpIHtcclxuICAgICAgICBtYXNrRGF0YS5yZW5kZXJhYmxlID0gdHJ1ZTtcclxuICAgICAgICB2YXIgcmVuZGVyVGFyZ2V0ID0gdGhpcy5yZW5kZXJlci5fYWN0aXZlUmVuZGVyVGFyZ2V0O1xyXG4gICAgICAgIHZhciBib3VuZHMgPSBtYXNrRGF0YS5nZXRCb3VuZHMoKTtcclxuICAgICAgICBib3VuZHMuZml0KHJlbmRlclRhcmdldC5zaXplKTtcclxuICAgICAgICBtYXNrRGF0YS5yZW5kZXJhYmxlID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJlci5nbC5lbmFibGUodGhpcy5yZW5kZXJlci5nbC5TQ0lTU09SX1RFU1QpO1xyXG4gICAgICAgIHZhciByZXNvbHV0aW9uID0gdGhpcy5yZW5kZXJlci5yZXNvbHV0aW9uO1xyXG4gICAgICAgIHRoaXMucmVuZGVyZXIuZ2wuc2Npc3Nvcihib3VuZHMueCAqIHJlc29sdXRpb24sIChyZW5kZXJUYXJnZXQucm9vdCA/IHJlbmRlclRhcmdldC5zaXplLmhlaWdodCAtIGJvdW5kcy55IC0gYm91bmRzLmhlaWdodCA6IGJvdW5kcy55KSAqIHJlc29sdXRpb24sIGJvdW5kcy53aWR0aCAqIHJlc29sdXRpb24sIGJvdW5kcy5oZWlnaHQgKiByZXNvbHV0aW9uKTtcclxuICAgICAgICB0aGlzLnNjaXNzb3JSZW5kZXJUYXJnZXQgPSByZW5kZXJUYXJnZXQ7XHJcbiAgICAgICAgdGhpcy5zY2lzc29yRGF0YSA9IG1hc2tEYXRhO1xyXG4gICAgICAgIHRoaXMuc2Npc3NvciA9IHRydWU7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFBvcCBzY2lzc29yIG1hc2tcclxuICAgICAqXHJcbiAgICAgKi9cclxuICAgIHBvcFNjaXNzb3JNYXNrKGEsIGIpIHtcclxuICAgICAgICB0aGlzLnNjaXNzb3JSZW5kZXJUYXJnZXQgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuc2Npc3NvckRhdGEgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuc2Npc3NvciA9IGZhbHNlO1xyXG4gICAgICAgIC8vIG11c3QgYmUgc2Npc3NvciFcclxuICAgICAgICB2YXIgcmVmID0gdGhpcy5yZW5kZXJlcjtcclxuICAgICAgICB2YXIgZ2wgPSByZWYuZ2w7XHJcbiAgICAgICAgZ2wuZGlzYWJsZShnbC5TQ0lTU09SX1RFU1QpO1xyXG4gICAgfVxyXG4gICAgO1xyXG59XHJcbmV4cG9ydHMuTWFza1N5c3RlbSA9IE1hc2tTeXN0ZW07XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNsYXNzIE1hdGhTZXR0aW5ncyB7XHJcbiAgICBzdGF0aWMgdWlkKCkge1xyXG4gICAgICAgIHJldHVybiArK01hdGhTZXR0aW5ncy5uZXh0VWlkO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIHNpZ24obikge1xyXG4gICAgICAgIGlmIChuID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbiA8IDAgPyAtMSA6IDE7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgc3RyaW5nMmhleChzdHJpbmcpIHtcclxuICAgICAgICBpZiAodHlwZW9mIHN0cmluZyA9PT0gJ3N0cmluZycgJiYgc3RyaW5nWzBdID09PSAnIycpIHtcclxuICAgICAgICAgICAgc3RyaW5nID0gc3RyaW5nLnN1YnN0cigxKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KHN0cmluZywgMTYpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGhleDJzdHJpbmcoaGV4KSB7XHJcbiAgICAgICAgaGV4ID0gaGV4LnRvU3RyaW5nKDE2KTtcclxuICAgICAgICBoZXggPSAnMDAwMDAwJy5zdWJzdHIoMCwgNiAtIGhleC5sZW5ndGgpICsgaGV4O1xyXG4gICAgICAgIHJldHVybiAoXCIjXCIgKyBoZXgpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGxvZzIodikge1xyXG4gICAgICAgIHZhciByID0gKHYgPiAweEZGRkYpIDw8IDQ7XHJcbiAgICAgICAgdiA+Pj49IHI7XHJcbiAgICAgICAgdmFyIHNoaWZ0ID0gKHYgPiAweEZGKSA8PCAzO1xyXG4gICAgICAgIHYgPj4+PSBzaGlmdDtcclxuICAgICAgICByIHw9IHNoaWZ0O1xyXG4gICAgICAgIHNoaWZ0ID0gKHYgPiAweEYpIDw8IDI7XHJcbiAgICAgICAgdiA+Pj49IHNoaWZ0O1xyXG4gICAgICAgIHIgfD0gc2hpZnQ7XHJcbiAgICAgICAgc2hpZnQgPSAodiA+IDB4MykgPDwgMTtcclxuICAgICAgICB2ID4+Pj0gc2hpZnQ7XHJcbiAgICAgICAgciB8PSBzaGlmdDtcclxuICAgICAgICByZXR1cm4gciB8ICh2ID4+IDEpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIG5leHRQb3cyKHYpIHtcclxuICAgICAgICB2ICs9IHYgPT09IDA7XHJcbiAgICAgICAgLS12O1xyXG4gICAgICAgIHYgfD0gdiA+Pj4gMTtcclxuICAgICAgICB2IHw9IHYgPj4+IDI7XHJcbiAgICAgICAgdiB8PSB2ID4+PiA0O1xyXG4gICAgICAgIHYgfD0gdiA+Pj4gODtcclxuICAgICAgICB2IHw9IHYgPj4+IDE2O1xyXG4gICAgICAgIHJldHVybiB2ICsgMTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBpc1BvdzIodikge1xyXG4gICAgICAgIHJldHVybiAhKHYgJiAodiAtIDEpKSAmJiAoISF2KTtcclxuICAgIH1cclxufVxyXG5NYXRoU2V0dGluZ3MubmV4dFVpZCA9IDA7XHJcbk1hdGhTZXR0aW5ncy5QSV8yID0gTWF0aC5QSSAqIDI7XHJcbk1hdGhTZXR0aW5ncy5SQURfVE9fREVHID0gMTgwIC8gTWF0aC5QSTtcclxuTWF0aFNldHRpbmdzLkRFR19UT19SQUQgPSBNYXRoLlBJIC8gMTgwO1xyXG5leHBvcnRzLk1hdGhTZXR0aW5ncyA9IE1hdGhTZXR0aW5ncztcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgUG9pbnRfMSA9IHJlcXVpcmUoXCIuL1BvaW50XCIpO1xyXG5jb25zdCBNYXRoU2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL01hdGhTZXR0aW5nc1wiKTtcclxuY2xhc3MgTWF0cml4IHtcclxuICAgIGNvbnN0cnVjdG9yKGEgPSAxLCBiID0gMCwgYyA9IDAsIGQgPSAxLCB0eCA9IDAsIHR5ID0gMCkge1xyXG4gICAgICAgIGlmIChhID09PSB2b2lkIDApIHtcclxuICAgICAgICAgICAgYSA9IDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChiID09PSB2b2lkIDApIHtcclxuICAgICAgICAgICAgYiA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjID09PSB2b2lkIDApIHtcclxuICAgICAgICAgICAgYyA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChkID09PSB2b2lkIDApIHtcclxuICAgICAgICAgICAgZCA9IDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eCA9PT0gdm9pZCAwKSB7XHJcbiAgICAgICAgICAgIHR4ID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5ID09PSB2b2lkIDApIHtcclxuICAgICAgICAgICAgdHkgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgICAgICogQGRlZmF1bHQgMVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuYSA9IGE7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICAgICAqIEBkZWZhdWx0IDBcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmIgPSBiO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAgICAgKiBAZGVmYXVsdCAwXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5jID0gYztcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgICAgICogQGRlZmF1bHQgMVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuZCA9IGQ7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICAgICAqIEBkZWZhdWx0IDBcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnR4ID0gdHg7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICAgICAqIEBkZWZhdWx0IDBcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnR5ID0gdHk7XHJcbiAgICAgICAgdGhpcy5hcnJheSA9IG51bGw7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBNYXRyaXggb2JqZWN0IGJhc2VkIG9uIHRoZSBnaXZlbiBhcnJheS4gVGhlIEVsZW1lbnQgdG8gTWF0cml4IG1hcHBpbmcgb3JkZXIgaXMgYXMgZm9sbG93czpcclxuICAgICAqXHJcbiAgICAgKiBhID0gYXJyYXlbMF1cclxuICAgICAqIGIgPSBhcnJheVsxXVxyXG4gICAgICogYyA9IGFycmF5WzNdXHJcbiAgICAgKiBkID0gYXJyYXlbNF1cclxuICAgICAqIHR4ID0gYXJyYXlbMl1cclxuICAgICAqIHR5ID0gYXJyYXlbNV1cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcltdfSBhcnJheSAtIFRoZSBhcnJheSB0aGF0IHRoZSBtYXRyaXggd2lsbCBiZSBwb3B1bGF0ZWQgZnJvbS5cclxuICAgICAqL1xyXG4gICAgZnJvbUFycmF5KGFycmF5KSB7XHJcbiAgICAgICAgdGhpcy5hID0gYXJyYXlbMF07XHJcbiAgICAgICAgdGhpcy5iID0gYXJyYXlbMV07XHJcbiAgICAgICAgdGhpcy5jID0gYXJyYXlbM107XHJcbiAgICAgICAgdGhpcy5kID0gYXJyYXlbNF07XHJcbiAgICAgICAgdGhpcy50eCA9IGFycmF5WzJdO1xyXG4gICAgICAgIHRoaXMudHkgPSBhcnJheVs1XTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogc2V0cyB0aGUgbWF0cml4IHByb3BlcnRpZXNcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYSAtIE1hdHJpeCBjb21wb25lbnRcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiIC0gTWF0cml4IGNvbXBvbmVudFxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGMgLSBNYXRyaXggY29tcG9uZW50XHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZCAtIE1hdHJpeCBjb21wb25lbnRcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0eCAtIE1hdHJpeCBjb21wb25lbnRcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0eSAtIE1hdHJpeCBjb21wb25lbnRcclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIHtQSVhJLk1hdHJpeH0gVGhpcyBtYXRyaXguIEdvb2QgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxscy5cclxuICAgICAqL1xyXG4gICAgc2V0KGEsIGIsIGMsIGQsIHR4LCB0eSkge1xyXG4gICAgICAgIHRoaXMuYSA9IGE7XHJcbiAgICAgICAgdGhpcy5iID0gYjtcclxuICAgICAgICB0aGlzLmMgPSBjO1xyXG4gICAgICAgIHRoaXMuZCA9IGQ7XHJcbiAgICAgICAgdGhpcy50eCA9IHR4O1xyXG4gICAgICAgIHRoaXMudHkgPSB0eTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBmcm9tIHRoZSBjdXJyZW50IE1hdHJpeCBvYmplY3QuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSB0cmFuc3Bvc2UgLSBXaGV0aGVyIHdlIG5lZWQgdG8gdHJhbnNwb3NlIHRoZSBtYXRyaXggb3Igbm90XHJcbiAgICAgKiBAcGFyYW0ge0Zsb2F0MzJBcnJheX0gW291dD1uZXcgRmxvYXQzMkFycmF5KDkpXSAtIElmIHByb3ZpZGVkIHRoZSBhcnJheSB3aWxsIGJlIGFzc2lnbmVkIHRvIG91dFxyXG4gICAgICogQHJldHVybiB7bnVtYmVyW119IHRoZSBuZXdseSBjcmVhdGVkIGFycmF5IHdoaWNoIGNvbnRhaW5zIHRoZSBtYXRyaXhcclxuICAgICAqL1xyXG4gICAgdG9BcnJheSh0cmFuc3Bvc2UsIG91dCA9IG51bGwpIHtcclxuICAgICAgICBpZiAoIXRoaXMuYXJyYXkpIHtcclxuICAgICAgICAgICAgdGhpcy5hcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoOSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBhcnJheSA9IG91dCB8fCB0aGlzLmFycmF5O1xyXG4gICAgICAgIGlmICh0cmFuc3Bvc2UpIHtcclxuICAgICAgICAgICAgYXJyYXlbMF0gPSB0aGlzLmE7XHJcbiAgICAgICAgICAgIGFycmF5WzFdID0gdGhpcy5iO1xyXG4gICAgICAgICAgICBhcnJheVsyXSA9IDA7XHJcbiAgICAgICAgICAgIGFycmF5WzNdID0gdGhpcy5jO1xyXG4gICAgICAgICAgICBhcnJheVs0XSA9IHRoaXMuZDtcclxuICAgICAgICAgICAgYXJyYXlbNV0gPSAwO1xyXG4gICAgICAgICAgICBhcnJheVs2XSA9IHRoaXMudHg7XHJcbiAgICAgICAgICAgIGFycmF5WzddID0gdGhpcy50eTtcclxuICAgICAgICAgICAgYXJyYXlbOF0gPSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgYXJyYXlbMF0gPSB0aGlzLmE7XHJcbiAgICAgICAgICAgIGFycmF5WzFdID0gdGhpcy5jO1xyXG4gICAgICAgICAgICBhcnJheVsyXSA9IHRoaXMudHg7XHJcbiAgICAgICAgICAgIGFycmF5WzNdID0gdGhpcy5iO1xyXG4gICAgICAgICAgICBhcnJheVs0XSA9IHRoaXMuZDtcclxuICAgICAgICAgICAgYXJyYXlbNV0gPSB0aGlzLnR5O1xyXG4gICAgICAgICAgICBhcnJheVs2XSA9IDA7XHJcbiAgICAgICAgICAgIGFycmF5WzddID0gMDtcclxuICAgICAgICAgICAgYXJyYXlbOF0gPSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYXJyYXk7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIEdldCBhIG5ldyBwb3NpdGlvbiB3aXRoIHRoZSBjdXJyZW50IHRyYW5zZm9ybWF0aW9uIGFwcGxpZWQuXHJcbiAgICAgKiBDYW4gYmUgdXNlZCB0byBnbyBmcm9tIGEgY2hpbGQncyBjb29yZGluYXRlIHNwYWNlIHRvIHRoZSB3b3JsZCBjb29yZGluYXRlIHNwYWNlLiAoZS5nLiByZW5kZXJpbmcpXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtQSVhJLlBvaW50fSBwb3MgLSBUaGUgb3JpZ2luXHJcbiAgICAgKiBAcGFyYW0ge1BJWEkuUG9pbnR9IFtuZXdQb3NdIC0gVGhlIHBvaW50IHRoYXQgdGhlIG5ldyBwb3NpdGlvbiBpcyBhc3NpZ25lZCB0byAoYWxsb3dlZCB0byBiZSBzYW1lIGFzIGlucHV0KVxyXG4gICAgICogQHJldHVybiB7UElYSS5Qb2ludH0gVGhlIG5ldyBwb2ludCwgdHJhbnNmb3JtZWQgdGhyb3VnaCB0aGlzIG1hdHJpeFxyXG4gICAgICovXHJcbiAgICBhcHBseShwb3MsIG5ld1Bvcykge1xyXG4gICAgICAgIG5ld1BvcyA9IG5ld1BvcyB8fCBuZXcgUG9pbnRfMS5Qb2ludCgpO1xyXG4gICAgICAgIHZhciB4ID0gcG9zLng7XHJcbiAgICAgICAgdmFyIHkgPSBwb3MueTtcclxuICAgICAgICBuZXdQb3MueCA9ICh0aGlzLmEgKiB4KSArICh0aGlzLmMgKiB5KSArIHRoaXMudHg7XHJcbiAgICAgICAgbmV3UG9zLnkgPSAodGhpcy5iICogeCkgKyAodGhpcy5kICogeSkgKyB0aGlzLnR5O1xyXG4gICAgICAgIHJldHVybiBuZXdQb3M7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIEdldCBhIG5ldyBwb3NpdGlvbiB3aXRoIHRoZSBpbnZlcnNlIG9mIHRoZSBjdXJyZW50IHRyYW5zZm9ybWF0aW9uIGFwcGxpZWQuXHJcbiAgICAgKiBDYW4gYmUgdXNlZCB0byBnbyBmcm9tIHRoZSB3b3JsZCBjb29yZGluYXRlIHNwYWNlIHRvIGEgY2hpbGQncyBjb29yZGluYXRlIHNwYWNlLiAoZS5nLiBpbnB1dClcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1BJWEkuUG9pbnR9IHBvcyAtIFRoZSBvcmlnaW5cclxuICAgICAqIEBwYXJhbSB7UElYSS5Qb2ludH0gW25ld1Bvc10gLSBUaGUgcG9pbnQgdGhhdCB0aGUgbmV3IHBvc2l0aW9uIGlzIGFzc2lnbmVkIHRvIChhbGxvd2VkIHRvIGJlIHNhbWUgYXMgaW5wdXQpXHJcbiAgICAgKiBAcmV0dXJuIHtQSVhJLlBvaW50fSBUaGUgbmV3IHBvaW50LCBpbnZlcnNlLXRyYW5zZm9ybWVkIHRocm91Z2ggdGhpcyBtYXRyaXhcclxuICAgICAqL1xyXG4gICAgYXBwbHlJbnZlcnNlKHBvcywgbmV3UG9zKSB7XHJcbiAgICAgICAgbmV3UG9zID0gbmV3UG9zIHx8IG5ldyBQb2ludF8xLlBvaW50KCk7XHJcbiAgICAgICAgdmFyIGlkID0gMSAvICgodGhpcy5hICogdGhpcy5kKSArICh0aGlzLmMgKiAtdGhpcy5iKSk7XHJcbiAgICAgICAgdmFyIHggPSBwb3MueDtcclxuICAgICAgICB2YXIgeSA9IHBvcy55O1xyXG4gICAgICAgIG5ld1Bvcy54ID0gKHRoaXMuZCAqIGlkICogeCkgKyAoLXRoaXMuYyAqIGlkICogeSkgKyAoKCh0aGlzLnR5ICogdGhpcy5jKSAtICh0aGlzLnR4ICogdGhpcy5kKSkgKiBpZCk7XHJcbiAgICAgICAgbmV3UG9zLnkgPSAodGhpcy5hICogaWQgKiB5KSArICgtdGhpcy5iICogaWQgKiB4KSArICgoKC10aGlzLnR5ICogdGhpcy5hKSArICh0aGlzLnR4ICogdGhpcy5iKSkgKiBpZCk7XHJcbiAgICAgICAgcmV0dXJuIG5ld1BvcztcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogVHJhbnNsYXRlcyB0aGUgbWF0cml4IG9uIHRoZSB4IGFuZCB5LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IEhvdyBtdWNoIHRvIHRyYW5zbGF0ZSB4IGJ5XHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSBIb3cgbXVjaCB0byB0cmFuc2xhdGUgeSBieVxyXG4gICAgICogQHJldHVybiB7UElYSS5NYXRyaXh9IFRoaXMgbWF0cml4LiBHb29kIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHMuXHJcbiAgICAgKi9cclxuICAgIHRyYW5zbGF0ZSh4LCB5KSB7XHJcbiAgICAgICAgdGhpcy50eCArPSB4O1xyXG4gICAgICAgIHRoaXMudHkgKz0geTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQXBwbGllcyBhIHNjYWxlIHRyYW5zZm9ybWF0aW9uIHRvIHRoZSBtYXRyaXguXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggVGhlIGFtb3VudCB0byBzY2FsZSBob3Jpem9udGFsbHlcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IFRoZSBhbW91bnQgdG8gc2NhbGUgdmVydGljYWxseVxyXG4gICAgICogQHJldHVybiB7UElYSS5NYXRyaXh9IFRoaXMgbWF0cml4LiBHb29kIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHMuXHJcbiAgICAgKi9cclxuICAgIHNjYWxlKHgsIHkpIHtcclxuICAgICAgICB0aGlzLmEgKj0geDtcclxuICAgICAgICB0aGlzLmQgKj0geTtcclxuICAgICAgICB0aGlzLmMgKj0geDtcclxuICAgICAgICB0aGlzLmIgKj0geTtcclxuICAgICAgICB0aGlzLnR4ICo9IHg7XHJcbiAgICAgICAgdGhpcy50eSAqPSB5O1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBsaWVzIGEgcm90YXRpb24gdHJhbnNmb3JtYXRpb24gdG8gdGhlIG1hdHJpeC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYW5nbGUgLSBUaGUgYW5nbGUgaW4gcmFkaWFucy5cclxuICAgICAqIEByZXR1cm4ge1BJWEkuTWF0cml4fSBUaGlzIG1hdHJpeC4gR29vZCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzLlxyXG4gICAgICovXHJcbiAgICByb3RhdGUoYW5nbGUpIHtcclxuICAgICAgICB2YXIgY29zID0gTWF0aC5jb3MoYW5nbGUpO1xyXG4gICAgICAgIHZhciBzaW4gPSBNYXRoLnNpbihhbmdsZSk7XHJcbiAgICAgICAgdmFyIGExID0gdGhpcy5hO1xyXG4gICAgICAgIHZhciBjMSA9IHRoaXMuYztcclxuICAgICAgICB2YXIgdHgxID0gdGhpcy50eDtcclxuICAgICAgICB0aGlzLmEgPSAoYTEgKiBjb3MpIC0gKHRoaXMuYiAqIHNpbik7XHJcbiAgICAgICAgdGhpcy5iID0gKGExICogc2luKSArICh0aGlzLmIgKiBjb3MpO1xyXG4gICAgICAgIHRoaXMuYyA9IChjMSAqIGNvcykgLSAodGhpcy5kICogc2luKTtcclxuICAgICAgICB0aGlzLmQgPSAoYzEgKiBzaW4pICsgKHRoaXMuZCAqIGNvcyk7XHJcbiAgICAgICAgdGhpcy50eCA9ICh0eDEgKiBjb3MpIC0gKHRoaXMudHkgKiBzaW4pO1xyXG4gICAgICAgIHRoaXMudHkgPSAodHgxICogc2luKSArICh0aGlzLnR5ICogY29zKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQXBwZW5kcyB0aGUgZ2l2ZW4gTWF0cml4IHRvIHRoaXMgTWF0cml4LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7UElYSS5NYXRyaXh9IG1hdHJpeCAtIFRoZSBtYXRyaXggdG8gYXBwZW5kLlxyXG4gICAgICogQHJldHVybiB7UElYSS5NYXRyaXh9IFRoaXMgbWF0cml4LiBHb29kIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHMuXHJcbiAgICAgKi9cclxuICAgIGFwcGVuZChtYXRyaXgpIHtcclxuICAgICAgICB2YXIgYTEgPSB0aGlzLmE7XHJcbiAgICAgICAgdmFyIGIxID0gdGhpcy5iO1xyXG4gICAgICAgIHZhciBjMSA9IHRoaXMuYztcclxuICAgICAgICB2YXIgZDEgPSB0aGlzLmQ7XHJcbiAgICAgICAgdGhpcy5hID0gKG1hdHJpeC5hICogYTEpICsgKG1hdHJpeC5iICogYzEpO1xyXG4gICAgICAgIHRoaXMuYiA9IChtYXRyaXguYSAqIGIxKSArIChtYXRyaXguYiAqIGQxKTtcclxuICAgICAgICB0aGlzLmMgPSAobWF0cml4LmMgKiBhMSkgKyAobWF0cml4LmQgKiBjMSk7XHJcbiAgICAgICAgdGhpcy5kID0gKG1hdHJpeC5jICogYjEpICsgKG1hdHJpeC5kICogZDEpO1xyXG4gICAgICAgIHRoaXMudHggPSAobWF0cml4LnR4ICogYTEpICsgKG1hdHJpeC50eSAqIGMxKSArIHRoaXMudHg7XHJcbiAgICAgICAgdGhpcy50eSA9IChtYXRyaXgudHggKiBiMSkgKyAobWF0cml4LnR5ICogZDEpICsgdGhpcy50eTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgbWF0cml4IGJhc2VkIG9uIGFsbCB0aGUgYXZhaWxhYmxlIHByb3BlcnRpZXNcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCAtIFBvc2l0aW9uIG9uIHRoZSB4IGF4aXNcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gUG9zaXRpb24gb24gdGhlIHkgYXhpc1xyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBpdm90WCAtIFBpdm90IG9uIHRoZSB4IGF4aXNcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwaXZvdFkgLSBQaXZvdCBvbiB0aGUgeSBheGlzXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2NhbGVYIC0gU2NhbGUgb24gdGhlIHggYXhpc1xyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNjYWxlWSAtIFNjYWxlIG9uIHRoZSB5IGF4aXNcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByb3RhdGlvbiAtIFJvdGF0aW9uIGluIHJhZGlhbnNcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBza2V3WCAtIFNrZXcgb24gdGhlIHggYXhpc1xyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNrZXdZIC0gU2tldyBvbiB0aGUgeSBheGlzXHJcbiAgICAgKiBAcmV0dXJuIHtQSVhJLk1hdHJpeH0gVGhpcyBtYXRyaXguIEdvb2QgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxscy5cclxuICAgICAqL1xyXG4gICAgc2V0VHJhbnNmb3JtKHgsIHksIHBpdm90WCwgcGl2b3RZLCBzY2FsZVgsIHNjYWxlWSwgcm90YXRpb24sIHNrZXdYLCBza2V3WSkge1xyXG4gICAgICAgIHRoaXMuYSA9IE1hdGguY29zKHJvdGF0aW9uICsgc2tld1kpICogc2NhbGVYO1xyXG4gICAgICAgIHRoaXMuYiA9IE1hdGguc2luKHJvdGF0aW9uICsgc2tld1kpICogc2NhbGVYO1xyXG4gICAgICAgIHRoaXMuYyA9IC1NYXRoLnNpbihyb3RhdGlvbiAtIHNrZXdYKSAqIHNjYWxlWTtcclxuICAgICAgICB0aGlzLmQgPSBNYXRoLmNvcyhyb3RhdGlvbiAtIHNrZXdYKSAqIHNjYWxlWTtcclxuICAgICAgICB0aGlzLnR4ID0geCAtICgocGl2b3RYICogdGhpcy5hKSArIChwaXZvdFkgKiB0aGlzLmMpKTtcclxuICAgICAgICB0aGlzLnR5ID0geSAtICgocGl2b3RYICogdGhpcy5iKSArIChwaXZvdFkgKiB0aGlzLmQpKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogUHJlcGVuZHMgdGhlIGdpdmVuIE1hdHJpeCB0byB0aGlzIE1hdHJpeC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1BJWEkuTWF0cml4fSBtYXRyaXggLSBUaGUgbWF0cml4IHRvIHByZXBlbmRcclxuICAgICAqIEByZXR1cm4ge1BJWEkuTWF0cml4fSBUaGlzIG1hdHJpeC4gR29vZCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzLlxyXG4gICAgICovXHJcbiAgICBwcmVwZW5kKG1hdHJpeCkge1xyXG4gICAgICAgIHZhciB0eDEgPSB0aGlzLnR4O1xyXG4gICAgICAgIGlmIChtYXRyaXguYSAhPT0gMSB8fCBtYXRyaXguYiAhPT0gMCB8fCBtYXRyaXguYyAhPT0gMCB8fCBtYXRyaXguZCAhPT0gMSkge1xyXG4gICAgICAgICAgICB2YXIgYTEgPSB0aGlzLmE7XHJcbiAgICAgICAgICAgIHZhciBjMSA9IHRoaXMuYztcclxuICAgICAgICAgICAgdGhpcy5hID0gKGExICogbWF0cml4LmEpICsgKHRoaXMuYiAqIG1hdHJpeC5jKTtcclxuICAgICAgICAgICAgdGhpcy5iID0gKGExICogbWF0cml4LmIpICsgKHRoaXMuYiAqIG1hdHJpeC5kKTtcclxuICAgICAgICAgICAgdGhpcy5jID0gKGMxICogbWF0cml4LmEpICsgKHRoaXMuZCAqIG1hdHJpeC5jKTtcclxuICAgICAgICAgICAgdGhpcy5kID0gKGMxICogbWF0cml4LmIpICsgKHRoaXMuZCAqIG1hdHJpeC5kKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy50eCA9ICh0eDEgKiBtYXRyaXguYSkgKyAodGhpcy50eSAqIG1hdHJpeC5jKSArIG1hdHJpeC50eDtcclxuICAgICAgICB0aGlzLnR5ID0gKHR4MSAqIG1hdHJpeC5iKSArICh0aGlzLnR5ICogbWF0cml4LmQpICsgbWF0cml4LnR5O1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBEZWNvbXBvc2VzIHRoZSBtYXRyaXggKHgsIHksIHNjYWxlWCwgc2NhbGVZLCBhbmQgcm90YXRpb24pIGFuZCBzZXRzIHRoZSBwcm9wZXJ0aWVzIG9uIHRvIGEgdHJhbnNmb3JtLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7UElYSS5UcmFuc2Zvcm19IHRyYW5zZm9ybSAtIFRoZSB0cmFuc2Zvcm0gdG8gYXBwbHkgdGhlIHByb3BlcnRpZXMgdG8uXHJcbiAgICAgKiBAcmV0dXJuIHtQSVhJLlRyYW5zZm9ybX0gVGhlIHRyYW5zZm9ybSB3aXRoIHRoZSBuZXdseSBhcHBsaWVkIHByb3BlcnRpZXNcclxuICAgICAqL1xyXG4gICAgZGVjb21wb3NlKHRyYW5zZm9ybSkge1xyXG4gICAgICAgIC8vIHNvcnQgb3V0IHJvdGF0aW9uIC8gc2tldy4uXHJcbiAgICAgICAgdmFyIGEgPSB0aGlzLmE7XHJcbiAgICAgICAgdmFyIGIgPSB0aGlzLmI7XHJcbiAgICAgICAgdmFyIGMgPSB0aGlzLmM7XHJcbiAgICAgICAgdmFyIGQgPSB0aGlzLmQ7XHJcbiAgICAgICAgdmFyIHNrZXdYID0gLU1hdGguYXRhbjIoLWMsIGQpO1xyXG4gICAgICAgIHZhciBza2V3WSA9IE1hdGguYXRhbjIoYiwgYSk7XHJcbiAgICAgICAgdmFyIGRlbHRhID0gTWF0aC5hYnMoc2tld1ggKyBza2V3WSk7XHJcbiAgICAgICAgaWYgKGRlbHRhIDwgMC4wMDAwMSB8fCBNYXRoLmFicyhNYXRoU2V0dGluZ3NfMS5NYXRoU2V0dGluZ3MuUElfMiAtIGRlbHRhKSA8IDAuMDAwMDEpIHtcclxuICAgICAgICAgICAgdHJhbnNmb3JtLnJvdGF0aW9uID0gc2tld1k7XHJcbiAgICAgICAgICAgIHRyYW5zZm9ybS5za2V3LnggPSB0cmFuc2Zvcm0uc2tldy55ID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRyYW5zZm9ybS5yb3RhdGlvbiA9IDA7XHJcbiAgICAgICAgICAgIHRyYW5zZm9ybS5za2V3LnggPSBza2V3WDtcclxuICAgICAgICAgICAgdHJhbnNmb3JtLnNrZXcueSA9IHNrZXdZO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBuZXh0IHNldCBzY2FsZVxyXG4gICAgICAgIHRyYW5zZm9ybS5zY2FsZS54ID0gTWF0aC5zcXJ0KChhICogYSkgKyAoYiAqIGIpKTtcclxuICAgICAgICB0cmFuc2Zvcm0uc2NhbGUueSA9IE1hdGguc3FydCgoYyAqIGMpICsgKGQgKiBkKSk7XHJcbiAgICAgICAgLy8gbmV4dCBzZXQgcG9zaXRpb25cclxuICAgICAgICB0cmFuc2Zvcm0ucG9zaXRpb24ueCA9IHRoaXMudHg7XHJcbiAgICAgICAgdHJhbnNmb3JtLnBvc2l0aW9uLnkgPSB0aGlzLnR5O1xyXG4gICAgICAgIHJldHVybiB0cmFuc2Zvcm07XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIEludmVydHMgdGhpcyBtYXRyaXhcclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIHtQSVhJLk1hdHJpeH0gVGhpcyBtYXRyaXguIEdvb2QgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxscy5cclxuICAgICAqL1xyXG4gICAgaW52ZXJ0KCkge1xyXG4gICAgICAgIHZhciBhMSA9IHRoaXMuYTtcclxuICAgICAgICB2YXIgYjEgPSB0aGlzLmI7XHJcbiAgICAgICAgdmFyIGMxID0gdGhpcy5jO1xyXG4gICAgICAgIHZhciBkMSA9IHRoaXMuZDtcclxuICAgICAgICB2YXIgdHgxID0gdGhpcy50eDtcclxuICAgICAgICB2YXIgbiA9IChhMSAqIGQxKSAtIChiMSAqIGMxKTtcclxuICAgICAgICB0aGlzLmEgPSBkMSAvIG47XHJcbiAgICAgICAgdGhpcy5iID0gLWIxIC8gbjtcclxuICAgICAgICB0aGlzLmMgPSAtYzEgLyBuO1xyXG4gICAgICAgIHRoaXMuZCA9IGExIC8gbjtcclxuICAgICAgICB0aGlzLnR4ID0gKChjMSAqIHRoaXMudHkpIC0gKGQxICogdHgxKSkgLyBuO1xyXG4gICAgICAgIHRoaXMudHkgPSAtKChhMSAqIHRoaXMudHkpIC0gKGIxICogdHgxKSkgLyBuO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXNldHMgdGhpcyBNYXRyaXggdG8gYW4gaWRlbnRpdHkgKGRlZmF1bHQpIG1hdHJpeC5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIHtQSVhJLk1hdHJpeH0gVGhpcyBtYXRyaXguIEdvb2QgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxscy5cclxuICAgICAqL1xyXG4gICAgaWRlbnRpdHkoKSB7XHJcbiAgICAgICAgdGhpcy5hID0gMTtcclxuICAgICAgICB0aGlzLmIgPSAwO1xyXG4gICAgICAgIHRoaXMuYyA9IDA7XHJcbiAgICAgICAgdGhpcy5kID0gMTtcclxuICAgICAgICB0aGlzLnR4ID0gMDtcclxuICAgICAgICB0aGlzLnR5ID0gMDtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBNYXRyaXggb2JqZWN0IHdpdGggdGhlIHNhbWUgdmFsdWVzIGFzIHRoaXMgb25lLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4ge1BJWEkuTWF0cml4fSBBIGNvcHkgb2YgdGhpcyBtYXRyaXguIEdvb2QgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxscy5cclxuICAgICAqL1xyXG4gICAgY2xvbmUoKSB7XHJcbiAgICAgICAgdmFyIG1hdHJpeCA9IG5ldyBNYXRyaXgoKTtcclxuICAgICAgICBtYXRyaXguYSA9IHRoaXMuYTtcclxuICAgICAgICBtYXRyaXguYiA9IHRoaXMuYjtcclxuICAgICAgICBtYXRyaXguYyA9IHRoaXMuYztcclxuICAgICAgICBtYXRyaXguZCA9IHRoaXMuZDtcclxuICAgICAgICBtYXRyaXgudHggPSB0aGlzLnR4O1xyXG4gICAgICAgIG1hdHJpeC50eSA9IHRoaXMudHk7XHJcbiAgICAgICAgcmV0dXJuIG1hdHJpeDtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQ2hhbmdlcyB0aGUgdmFsdWVzIG9mIHRoZSBnaXZlbiBtYXRyaXggdG8gYmUgdGhlIHNhbWUgYXMgdGhlIG9uZXMgaW4gdGhpcyBtYXRyaXhcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1BJWEkuTWF0cml4fSBtYXRyaXggLSBUaGUgbWF0cml4IHRvIGNvcHkgdG8uXHJcbiAgICAgKiBAcmV0dXJuIHtQSVhJLk1hdHJpeH0gVGhlIG1hdHJpeCBnaXZlbiBpbiBwYXJhbWV0ZXIgd2l0aCBpdHMgdmFsdWVzIHVwZGF0ZWQuXHJcbiAgICAgKi9cclxuICAgIGNvcHlUbyhtYXRyaXgpIHtcclxuICAgICAgICBtYXRyaXguYSA9IHRoaXMuYTtcclxuICAgICAgICBtYXRyaXguYiA9IHRoaXMuYjtcclxuICAgICAgICBtYXRyaXguYyA9IHRoaXMuYztcclxuICAgICAgICBtYXRyaXguZCA9IHRoaXMuZDtcclxuICAgICAgICBtYXRyaXgudHggPSB0aGlzLnR4O1xyXG4gICAgICAgIG1hdHJpeC50eSA9IHRoaXMudHk7XHJcbiAgICAgICAgcmV0dXJuIG1hdHJpeDtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQ2hhbmdlcyB0aGUgdmFsdWVzIG9mIHRoZSBtYXRyaXggdG8gYmUgdGhlIHNhbWUgYXMgdGhlIG9uZXMgaW4gZ2l2ZW4gbWF0cml4XHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtQSVhJLk1hdHJpeH0gbWF0cml4IC0gVGhlIG1hdHJpeCB0byBjb3B5IGZyb20uXHJcbiAgICAgKiBAcmV0dXJuIHtQSVhJLk1hdHJpeH0gdGhpc1xyXG4gICAgICovXHJcbiAgICBjb3B5RnJvbShtYXRyaXgpIHtcclxuICAgICAgICB0aGlzLmEgPSBtYXRyaXguYTtcclxuICAgICAgICB0aGlzLmIgPSBtYXRyaXguYjtcclxuICAgICAgICB0aGlzLmMgPSBtYXRyaXguYztcclxuICAgICAgICB0aGlzLmQgPSBtYXRyaXguZDtcclxuICAgICAgICB0aGlzLnR4ID0gbWF0cml4LnR4O1xyXG4gICAgICAgIHRoaXMudHkgPSBtYXRyaXgudHk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIEEgZGVmYXVsdCAoaWRlbnRpdHkpIG1hdHJpeFxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBjb25zdFxyXG4gICAgICogQG1lbWJlciB7UElYSS5NYXRyaXh9XHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBnZXQgSURFTlRJVFkoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBNYXRyaXgoKTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQSB0ZW1wIG1hdHJpeFxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBjb25zdFxyXG4gICAgICogQG1lbWJlciB7UElYSS5NYXRyaXh9XHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBnZXQgVEVNUF9NQVRSSVgoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBNYXRyaXgoKTtcclxuICAgIH1cclxuICAgIDtcclxufVxyXG5leHBvcnRzLk1hdHJpeCA9IE1hdHJpeDtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgQ29udGFpbmVyXzEgPSByZXF1aXJlKFwiLi9Db250YWluZXJcIik7XHJcbmNvbnN0IFN0YXRlXzEgPSByZXF1aXJlKFwiLi9TdGF0ZVwiKTtcclxuY29uc3QgUG9seWdvbl8xID0gcmVxdWlyZShcIi4vUG9seWdvblwiKTtcclxuY29uc3QgTWVzaEJhdGNoVXZzXzEgPSByZXF1aXJlKFwiLi9NZXNoQmF0Y2hVdnNcIik7XHJcbmNvbnN0IFBvaW50XzEgPSByZXF1aXJlKFwiLi9Qb2ludFwiKTtcclxuY29uc3QgRHJhd01vZGVTZXR0aW5nc18xID0gcmVxdWlyZShcIi4vRHJhd01vZGVTZXR0aW5nc1wiKTtcclxuY29uc3QgQmxlbmRNb2Rlc1NldHRpbmdzXzEgPSByZXF1aXJlKFwiLi9CbGVuZE1vZGVzU2V0dGluZ3NcIik7XHJcbmNvbnN0IERpc3BsYXlTZXR0aW5nc18xID0gcmVxdWlyZShcIi4vRGlzcGxheVNldHRpbmdzXCIpO1xyXG5jbGFzcyBNZXNoIGV4dGVuZHMgQ29udGFpbmVyXzEuQ29udGFpbmVyIHtcclxuICAgIGNvbnN0cnVjdG9yKGdlb21ldHJ5LCBzaGFkZXIsIHN0YXRlID0gbnVsbCwgZHJhd01vZGUgPSBEcmF3TW9kZVNldHRpbmdzXzEuRHJhd01vZGVTZXR0aW5ncy5EUkFXX01PREVTLlRSSUFOR0xFUykge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5pbnRlcmFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEluY2x1ZGVzIHZlcnRleCBwb3NpdGlvbnMsIGZhY2UgaW5kaWNlcywgbm9ybWFscywgY29sb3JzLCBVVnMsIGFuZFxyXG4gICAgICAgICAqIGN1c3RvbSBhdHRyaWJ1dGVzIHdpdGhpbiBidWZmZXJzLCByZWR1Y2luZyB0aGUgY29zdCBvZiBwYXNzaW5nIGFsbFxyXG4gICAgICAgICAqIHRoaXMgZGF0YSB0byB0aGUgR1BVLiBDYW4gYmUgc2hhcmVkIGJldHdlZW4gbXVsdGlwbGUgTWVzaCBvYmplY3RzLlxyXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuR2VvbWV0cnl9XHJcbiAgICAgICAgICogQHJlYWRvbmx5XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5nZW9tZXRyeSA9IGdlb21ldHJ5O1xyXG4gICAgICAgIGdlb21ldHJ5LnJlZkNvdW50Kys7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmVwcmVzZW50cyB0aGUgdmVydGV4IGFuZCBmcmFnbWVudCBzaGFkZXJzIHRoYXQgcHJvY2Vzc2VzIHRoZSBnZW9tZXRyeSBhbmQgcnVucyBvbiB0aGUgR1BVLlxyXG4gICAgICAgICAqIENhbiBiZSBzaGFyZWQgYmV0d2VlbiBtdWx0aXBsZSBNZXNoIG9iamVjdHMuXHJcbiAgICAgICAgICogQG1lbWJlciB7UElYSS5TaGFkZXJ8UElYSS5NZXNoTWF0ZXJpYWx9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5zaGFkZXIgPSBzaGFkZXI7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmVwcmVzZW50cyB0aGUgV2ViR0wgc3RhdGUgdGhlIE1lc2ggcmVxdWlyZWQgdG8gcmVuZGVyLCBleGNsdWRlcyBzaGFkZXIgYW5kIGdlb21ldHJ5LiBFLmcuLFxyXG4gICAgICAgICAqIGJsZW5kIG1vZGUsIGN1bGxpbmcsIGRlcHRoIHRlc3RpbmcsIGRpcmVjdGlvbiBvZiByZW5kZXJpbmcgdHJpYW5nbGVzLCBiYWNrZmFjZSwgZXRjLlxyXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuU3RhdGV9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlIHx8IFN0YXRlXzEuU3RhdGUuZm9yMmQoKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgd2F5IHRoZSBNZXNoIHNob3VsZCBiZSBkcmF3biwgY2FuIGJlIGFueSBvZiB0aGUge0BsaW5rIFBJWEkuRFJBV19NT0RFU30gY29uc3RhbnRzLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICAgICAqIEBzZWUgUElYSS5EUkFXX01PREVTXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5kcmF3TW9kZSA9IGRyYXdNb2RlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFR5cGljYWxseSB0aGUgaW5kZXggb2YgdGhlIEluZGV4QnVmZmVyIHdoZXJlIHRvIHN0YXJ0IGRyYXdpbmcuXHJcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICAgICAqIEBkZWZhdWx0IDBcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnN0YXJ0ID0gMDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBIb3cgbXVjaCBvZiB0aGUgZ2VvbWV0cnkgdG8gZHJhdywgYnkgZGVmYXVsdCBgMGAgcmVuZGVycyBldmVyeXRoaW5nLlxyXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAgICAgKiBAZGVmYXVsdCAwXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5zaXplID0gMDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiB0aGVhc2UgYXJlIHVzZWQgYXMgZWFzeSBhY2Nlc3MgZm9yIGJhdGNoaW5nXHJcbiAgICAgICAgICogQG1lbWJlciB7RmxvYXQzMkFycmF5fVxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy51dnMgPSBudWxsO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIHRoZWFzZSBhcmUgdXNlZCBhcyBlYXN5IGFjY2VzcyBmb3IgYmF0Y2hpbmdcclxuICAgICAgICAgKiBAbWVtYmVyIHtVaW50MTZBcnJheX1cclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuaW5kaWNlcyA9IG51bGw7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogdGhpcyBpcyB0aGUgY2FjaGluZyBsYXllciB1c2VkIGJ5IHRoZSBiYXRjaGVyXHJcbiAgICAgICAgICogQG1lbWJlciB7RmxvYXQzMkFycmF5fVxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy52ZXJ0ZXhEYXRhID0gbmV3IEZsb2F0MzJBcnJheSgxKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJZiBnZW9tZXRyeSBpcyBjaGFuZ2VkIHVzZWQgdG8gZGVjaWRlIHRvIHJlLXRyYW5zZm9ybVxyXG4gICAgICAgICAqIHRoZSB2ZXJ0ZXhEYXRhLlxyXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMudmVydGV4RGlydHkgPSAwO1xyXG4gICAgICAgIHRoaXMuX3RyYW5zZm9ybUlEID0gLTE7XHJcbiAgICAgICAgLy8gSW5oZXJpdGVkIGZyb20gRGlzcGxheU1vZGUsIHNldCBkZWZhdWx0c1xyXG4gICAgICAgIHRoaXMudGludCA9IDB4RkZGRkZGO1xyXG4gICAgICAgIHRoaXMuYmxlbmRNb2RlID0gQmxlbmRNb2Rlc1NldHRpbmdzXzEuQmxlbmRNb2Rlc1NldHRpbmdzLkJMRU5EX01PREVTLk5PUk1BTDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJbnRlcm5hbCByb3VuZFBpeGVscyBmaWVsZFxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQG1lbWJlciB7Ym9vbGVhbn1cclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuX3JvdW5kUGl4ZWxzID0gRGlzcGxheVNldHRpbmdzXzEuRGlzcGxheVNldHRpbmdzLlJPVU5EX1BJWEVMUztcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBCYXRjaGVkIFVWJ3MgYXJlIGNhY2hlZCBmb3IgYXRsYXMgdGV4dHVyZXNcclxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLk1lc2hCYXRjaFV2c31cclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuYmF0Y2hVdnMgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUbyBjaGFuZ2UgbWVzaCB1didzLCBjaGFuZ2UgaXRzIHV2QnVmZmVyIGRhdGEgYW5kIGluY3JlbWVudCBpdHMgX3VwZGF0ZUlELlxyXG4gICAgICogQG1lbWJlciB7UElYSS5CdWZmZXJ9XHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqL1xyXG4gICAgZ2V0IHV2QnVmZmVyKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdlb21ldHJ5LmJ1ZmZlcnNbMV0uZGF0YTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogVG8gY2hhbmdlIG1lc2ggdmVydGljZXMsIGNoYW5nZSBpdHMgdXZCdWZmZXIgZGF0YSBhbmQgaW5jcmVtZW50IGl0cyBfdXBkYXRlSUQuXHJcbiAgICAgKiBJbmNyZW1lbnRpbmcgX3VwZGF0ZUlEIGlzIG9wdGlvbmFsIGJlY2F1c2UgbW9zdCBvZiBNZXNoIG9iamVjdHMgZG8gaXQgYW55d2F5LlxyXG4gICAgICogQG1lbWJlciB7UElYSS5CdWZmZXJ9XHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqL1xyXG4gICAgZ2V0IHZlcnRpY2VzQnVmZmVyKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdlb21ldHJ5LmJ1ZmZlcnNbMF0uZGF0YTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQWxpYXMgZm9yIHtAbGluayBQSVhJLk1lc2gjc2hhZGVyfS5cclxuICAgICAqIEBtZW1iZXIge1BJWEkuU2hhZGVyfFBJWEkuTWVzaE1hdGVyaWFsfVxyXG4gICAgICovXHJcbiAgICBzZXQgbWF0ZXJpYWwodmFsdWUpIHtcclxuICAgICAgICB0aGlzLnNoYWRlciA9IHZhbHVlO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgZ2V0IG1hdGVyaWFsKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNoYWRlcjtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGJsZW5kIG1vZGUgdG8gYmUgYXBwbGllZCB0byB0aGUgTWVzaC4gQXBwbHkgYSB2YWx1ZSBvZlxyXG4gICAgICogYFBJWEkuQkxFTkRfTU9ERVMuTk9STUFMYCB0byByZXNldCB0aGUgYmxlbmQgbW9kZS5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgKiBAZGVmYXVsdCBQSVhJLkJMRU5EX01PREVTLk5PUk1BTDtcclxuICAgICAqIEBzZWUgUElYSS5CTEVORF9NT0RFU1xyXG4gICAgICovXHJcbiAgICBzZXQgYmxlbmRNb2RlKHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5zdGF0ZS5ibGVuZE1vZGUgPSB2YWx1ZTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIGdldCBibGVuZE1vZGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUuYmxlbmRNb2RlO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBJZiB0cnVlIFBpeGlKUyB3aWxsIE1hdGguZmxvb3IoKSB4L3kgdmFsdWVzIHdoZW4gcmVuZGVyaW5nLCBzdG9wcGluZyBwaXhlbCBpbnRlcnBvbGF0aW9uLlxyXG4gICAgICogQWR2YW50YWdlcyBjYW4gaW5jbHVkZSBzaGFycGVyIGltYWdlIHF1YWxpdHkgKGxpa2UgdGV4dCkgYW5kIGZhc3RlciByZW5kZXJpbmcgb24gY2FudmFzLlxyXG4gICAgICogVGhlIG1haW4gZGlzYWR2YW50YWdlIGlzIG1vdmVtZW50IG9mIG9iamVjdHMgbWF5IGFwcGVhciBsZXNzIHNtb290aC5cclxuICAgICAqIFRvIHNldCB0aGUgZ2xvYmFsIGRlZmF1bHQsIGNoYW5nZSB7QGxpbmsgUElYSS5zZXR0aW5ncy5ST1VORF9QSVhFTFN9XHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7Ym9vbGVhbn1cclxuICAgICAqIEBkZWZhdWx0IGZhbHNlXHJcbiAgICAgKi9cclxuICAgIHNldCByb3VuZFBpeGVscyh2YWx1ZSkge1xyXG4gICAgICAgIGlmICh0aGlzLl9yb3VuZFBpeGVscyAhPT0gdmFsdWUpIHtcclxuICAgICAgICAgICAgdGhpcy5fdHJhbnNmb3JtSUQgPSAtMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fcm91bmRQaXhlbHMgPSB2YWx1ZTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIGdldCByb3VuZFBpeGVscygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcm91bmRQaXhlbHM7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBtdWx0aXBseSB0aW50IGFwcGxpZWQgdG8gdGhlIE1lc2guIFRoaXMgaXMgYSBoZXggdmFsdWUuIEEgdmFsdWUgb2ZcclxuICAgICAqIGAweEZGRkZGRmAgd2lsbCByZW1vdmUgYW55IHRpbnQgZWZmZWN0LlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAqIEBkZWZhdWx0IDB4RkZGRkZGXHJcbiAgICAgKi9cclxuICAgIGdldCB0aW50KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNoYWRlci50aW50O1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgc2V0IHRpbnQodmFsdWUpIHtcclxuICAgICAgICB0aGlzLnNoYWRlci50aW50ID0gdmFsdWU7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSB0ZXh0dXJlIHRoYXQgdGhlIE1lc2ggdXNlcy5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtQSVhJLlRleHR1cmV9XHJcbiAgICAgKi9cclxuICAgIGdldCB0ZXh0dXJlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNoYWRlci50ZXh0dXJlO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgc2V0IHRleHR1cmUodmFsdWUpIHtcclxuICAgICAgICB0aGlzLnNoYWRlci50ZXh0dXJlID0gdmFsdWU7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFN0YW5kYXJkIHJlbmRlcmVyIGRyYXcuXHJcbiAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgKi9cclxuICAgIF9yZW5kZXIocmVuZGVyZXIpIHtcclxuICAgICAgICAvLyBzZXQgcHJvcGVydGllcyBmb3IgYmF0Y2hpbmcuLlxyXG4gICAgICAgIC8vIFRPRE8gY291bGQgdXNlIGEgZGlmZmVyZW50IHdheSB0byBncmFiIHZlcnRzP1xyXG4gICAgICAgIHZhciB2ZXJ0aWNlcyA9IHRoaXMuZ2VvbWV0cnkuYnVmZmVyc1swXS5kYXRhO1xyXG4gICAgICAgIC8vIFRPRE8gYmVuY2htYXJrIGNoZWNrIGZvciBhdHRyaWJ1dGUgc2l6ZS4uXHJcbiAgICAgICAgaWYgKHRoaXMuc2hhZGVyLmJhdGNoYWJsZSAmJiB0aGlzLmRyYXdNb2RlID09PSBEcmF3TW9kZVNldHRpbmdzXzEuRHJhd01vZGVTZXR0aW5ncy5EUkFXX01PREVTLlRSSUFOR0xFUyAmJiB2ZXJ0aWNlcy5sZW5ndGggPCBNZXNoLkJBVENIQUJMRV9TSVpFICogMikge1xyXG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJUb0JhdGNoKHJlbmRlcmVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlckRlZmF1bHQocmVuZGVyZXIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogU3RhbmRhcmQgbm9uLWJhdGNoaW5nIHdheSBvZiByZW5kZXJpbmcuXHJcbiAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgKiBAcGFyYW0ge1BJWEkuUmVuZGVyZXJ9IHJlbmRlcmVyIC0gSW5zdGFuY2UgdG8gcmVuZGVyZXIuXHJcbiAgICAgKi9cclxuICAgIF9yZW5kZXJEZWZhdWx0KHJlbmRlcmVyKSB7XHJcbiAgICAgICAgdmFyIHNoYWRlciA9IHRoaXMuc2hhZGVyO1xyXG4gICAgICAgIHNoYWRlci5hbHBoYSA9IHRoaXMud29ybGRBbHBoYTtcclxuICAgICAgICBpZiAoc2hhZGVyLnVwZGF0ZSkge1xyXG4gICAgICAgICAgICBzaGFkZXIudXBkYXRlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlbmRlcmVyLmJhdGNoLmZsdXNoKCk7XHJcbiAgICAgICAgaWYgKHNoYWRlci5wcm9ncmFtLnVuaWZvcm1EYXRhLnRyYW5zbGF0aW9uTWF0cml4KSB7XHJcbiAgICAgICAgICAgIHNoYWRlci51bmlmb3Jtcy50cmFuc2xhdGlvbk1hdHJpeCA9IHRoaXMudHJhbnNmb3JtLndvcmxkVHJhbnNmb3JtLnRvQXJyYXkodHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGJpbmQgYW5kIHN5bmMgdW5pZm9ybXMuLlxyXG4gICAgICAgIHJlbmRlcmVyLnNoYWRlci5iaW5kKHNoYWRlcik7XHJcbiAgICAgICAgLy8gc2V0IHN0YXRlLi5cclxuICAgICAgICByZW5kZXJlci5zdGF0ZS5zZXRTdGF0ZSh0aGlzLnN0YXRlKTtcclxuICAgICAgICAvLyBiaW5kIHRoZSBnZW9tZXRyeS4uLlxyXG4gICAgICAgIHJlbmRlcmVyLmdlb21ldHJ5LmJpbmQodGhpcy5nZW9tZXRyeSwgc2hhZGVyKTtcclxuICAgICAgICAvLyB0aGVuIHJlbmRlciBpdFxyXG4gICAgICAgIHJlbmRlcmVyLmdlb21ldHJ5LmRyYXcodGhpcy5kcmF3TW9kZSwgdGhpcy5zaXplLCB0aGlzLnN0YXJ0LCB0aGlzLmdlb21ldHJ5Lmluc3RhbmNlQ291bnQpO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZW5kZXJpbmcgYnkgdXNpbmcgdGhlIEJhdGNoIHN5c3RlbS5cclxuICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAqIEBwYXJhbSB7UElYSS5SZW5kZXJlcn0gcmVuZGVyZXIgLSBJbnN0YW5jZSB0byByZW5kZXJlci5cclxuICAgICAqL1xyXG4gICAgX3JlbmRlclRvQmF0Y2gocmVuZGVyZXIpIHtcclxuICAgICAgICB2YXIgZ2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5O1xyXG4gICAgICAgIGlmICh0aGlzLnNoYWRlci51dk1hdHJpeCkge1xyXG4gICAgICAgICAgICB0aGlzLnNoYWRlci51dk1hdHJpeC51cGRhdGUoKTtcclxuICAgICAgICAgICAgdGhpcy5jYWxjdWxhdGVVdnMoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gc2V0IHByb3BlcnRpZXMgZm9yIGJhdGNoaW5nLi5cclxuICAgICAgICB0aGlzLmNhbGN1bGF0ZVZlcnRpY2VzKCk7XHJcbiAgICAgICAgdGhpcy5pbmRpY2VzID0gZ2VvbWV0cnkuaW5kZXhCdWZmZXIuZGF0YTtcclxuICAgICAgICB0aGlzLl90aW50UkdCID0gdGhpcy5zaGFkZXIuX3RpbnRSR0I7XHJcbiAgICAgICAgdGhpcy5fdGV4dHVyZSA9IHRoaXMuc2hhZGVyLnRleHR1cmU7XHJcbiAgICAgICAgdmFyIHBsdWdpbk5hbWUgPSB0aGlzLm1hdGVyaWFsLnBsdWdpbk5hbWU7XHJcbiAgICAgICAgcmVuZGVyZXIuYmF0Y2guc2V0T2JqZWN0UmVuZGVyZXIocmVuZGVyZXIucGx1Z2luc1twbHVnaW5OYW1lXSk7XHJcbiAgICAgICAgcmVuZGVyZXIucGx1Z2luc1twbHVnaW5OYW1lXS5yZW5kZXIodGhpcyk7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgdmVydGV4RGF0YSBmaWVsZCBiYXNlZCBvbiB0cmFuc2Zvcm0gYW5kIHZlcnRpY2VzXHJcbiAgICAgKi9cclxuICAgIGNhbGN1bGF0ZVZlcnRpY2VzKCkge1xyXG4gICAgICAgIHZhciBnZW9tZXRyeSA9IHRoaXMuZ2VvbWV0cnk7XHJcbiAgICAgICAgdmFyIHZlcnRpY2VzID0gZ2VvbWV0cnkuYnVmZmVyc1swXS5kYXRhO1xyXG4gICAgICAgIGlmIChnZW9tZXRyeS52ZXJ0ZXhEaXJ0eUlkID09PSB0aGlzLnZlcnRleERpcnR5ICYmIHRoaXMuX3RyYW5zZm9ybUlEID09PSB0aGlzLnRyYW5zZm9ybS5fd29ybGRJRCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3RyYW5zZm9ybUlEID0gdGhpcy50cmFuc2Zvcm0uX3dvcmxkSUQ7XHJcbiAgICAgICAgaWYgKHRoaXMudmVydGV4RGF0YS5sZW5ndGggIT09IHZlcnRpY2VzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICB0aGlzLnZlcnRleERhdGEgPSBuZXcgRmxvYXQzMkFycmF5KHZlcnRpY2VzLmxlbmd0aCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciB3dCA9IHRoaXMudHJhbnNmb3JtLndvcmxkVHJhbnNmb3JtO1xyXG4gICAgICAgIHZhciBhID0gd3QuYTtcclxuICAgICAgICB2YXIgYiA9IHd0LmI7XHJcbiAgICAgICAgdmFyIGMgPSB3dC5jO1xyXG4gICAgICAgIHZhciBkID0gd3QuZDtcclxuICAgICAgICB2YXIgdHggPSB3dC50eDtcclxuICAgICAgICB2YXIgdHkgPSB3dC50eTtcclxuICAgICAgICB2YXIgdmVydGV4RGF0YSA9IHRoaXMudmVydGV4RGF0YTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZlcnRleERhdGEubGVuZ3RoIC8gMjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciB4ID0gdmVydGljZXNbKGkgKiAyKV07XHJcbiAgICAgICAgICAgIHZhciB5ID0gdmVydGljZXNbKGkgKiAyKSArIDFdO1xyXG4gICAgICAgICAgICB2ZXJ0ZXhEYXRhWyhpICogMildID0gKGEgKiB4KSArIChjICogeSkgKyB0eDtcclxuICAgICAgICAgICAgdmVydGV4RGF0YVsoaSAqIDIpICsgMV0gPSAoYiAqIHgpICsgKGQgKiB5KSArIHR5O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5fcm91bmRQaXhlbHMpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgdmVydGV4RGF0YS5sZW5ndGg7IGkkMSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhEYXRhW2kkMV0gPSBNYXRoLnJvdW5kKHZlcnRleERhdGFbaSQxXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy52ZXJ0ZXhEaXJ0eSA9IGdlb21ldHJ5LnZlcnRleERpcnR5SWQ7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgdXYgZmllbGQgYmFzZWQgb24gZnJvbSBnZW9tZXRyeSB1didzIG9yIGJhdGNoVXZzXHJcbiAgICAgKi9cclxuICAgIGNhbGN1bGF0ZVV2cygpIHtcclxuICAgICAgICB2YXIgZ2VvbVV2cyA9IHRoaXMuZ2VvbWV0cnkuYnVmZmVyc1sxXTtcclxuICAgICAgICBpZiAoIXRoaXMuc2hhZGVyLnV2TWF0cml4LmlzU2ltcGxlKSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5iYXRjaFV2cykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5iYXRjaFV2cyA9IG5ldyBNZXNoQmF0Y2hVdnNfMS5NZXNoQmF0Y2hVdnMoZ2VvbVV2cywgdGhpcy5zaGFkZXIudXZNYXRyaXgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuYmF0Y2hVdnMudXBkYXRlKCk7XHJcbiAgICAgICAgICAgIHRoaXMudXZzID0gdGhpcy5iYXRjaFV2cy5kYXRhO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy51dnMgPSBnZW9tVXZzLmRhdGE7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGVzIHRoZSBib3VuZHMgb2YgdGhlIG1lc2ggYXMgYSByZWN0YW5nbGUuIFRoZSBib3VuZHMgY2FsY3VsYXRpb24gdGFrZXMgdGhlIHdvcmxkVHJhbnNmb3JtIGludG8gYWNjb3VudC5cclxuICAgICAqIHRoZXJlIG11c3QgYmUgYSBhVmVydGV4UG9zaXRpb24gYXR0cmlidXRlIHByZXNlbnQgaW4gdGhlIGdlb21ldHJ5IGZvciBib3VuZHMgdG8gYmUgY2FsY3VsYXRlZCBjb3JyZWN0bHkuXHJcbiAgICAgKlxyXG4gICAgICogQHByb3RlY3RlZFxyXG4gICAgICovXHJcbiAgICBfY2FsY3VsYXRlQm91bmRzKCkge1xyXG4gICAgICAgIHRoaXMuY2FsY3VsYXRlVmVydGljZXMoKTtcclxuICAgICAgICB0aGlzLl9ib3VuZHMuYWRkVmVydGV4RGF0YSh0aGlzLnZlcnRleERhdGEsIDAsIHRoaXMudmVydGV4RGF0YS5sZW5ndGgpO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUZXN0cyBpZiBhIHBvaW50IGlzIGluc2lkZSB0aGlzIG1lc2guIFdvcmtzIG9ubHkgZm9yIFBJWEkuRFJBV19NT0RFUy5UUklBTkdMRVMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtQSVhJLlBvaW50fSBwb2ludCB0aGUgcG9pbnQgdG8gdGVzdFxyXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gdGhlIHJlc3VsdCBvZiB0aGUgdGVzdFxyXG4gICAgICovXHJcbiAgICBjb250YWluc1BvaW50KHBvaW50KSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmludGVyYWN0aXZlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCF0aGlzLmdldEJvdW5kcygpLmNvbnRhaW5zKHBvaW50LngsIHBvaW50LnkpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy53b3JsZFRyYW5zZm9ybS5hcHBseUludmVyc2UocG9pbnQsIE1lc2gudGVtcFBvaW50JDIpO1xyXG4gICAgICAgIHZhciB2ZXJ0aWNlcyA9IHRoaXMuZ2VvbWV0cnkuZ2V0QXR0cmlidXRlKCdhVmVydGV4UG9zaXRpb24nKS5kYXRhO1xyXG4gICAgICAgIHZhciBwb2ludHMgPSBNZXNoLnRlbXBQb2x5Z29uLnBvaW50cztcclxuICAgICAgICB2YXIgaW5kaWNlcyA9IHRoaXMuZ2VvbWV0cnkuZ2V0SW5kZXgoKS5kYXRhO1xyXG4gICAgICAgIHZhciBsZW4gPSBpbmRpY2VzLmxlbmd0aDtcclxuICAgICAgICB2YXIgc3RlcCA9IHRoaXMuZHJhd01vZGUgPT09IDQgPyAzIDogMTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSArIDIgPCBsZW47IGkgKz0gc3RlcCkge1xyXG4gICAgICAgICAgICB2YXIgaW5kMCA9IGluZGljZXNbaV0gKiAyO1xyXG4gICAgICAgICAgICB2YXIgaW5kMSA9IGluZGljZXNbaSArIDFdICogMjtcclxuICAgICAgICAgICAgdmFyIGluZDIgPSBpbmRpY2VzW2kgKyAyXSAqIDI7XHJcbiAgICAgICAgICAgIHBvaW50c1swXSA9IHZlcnRpY2VzW2luZDBdO1xyXG4gICAgICAgICAgICBwb2ludHNbMV0gPSB2ZXJ0aWNlc1tpbmQwICsgMV07XHJcbiAgICAgICAgICAgIHBvaW50c1syXSA9IHZlcnRpY2VzW2luZDFdO1xyXG4gICAgICAgICAgICBwb2ludHNbM10gPSB2ZXJ0aWNlc1tpbmQxICsgMV07XHJcbiAgICAgICAgICAgIHBvaW50c1s0XSA9IHZlcnRpY2VzW2luZDJdO1xyXG4gICAgICAgICAgICBwb2ludHNbNV0gPSB2ZXJ0aWNlc1tpbmQyICsgMV07XHJcbiAgICAgICAgICAgIGlmIChNZXNoLnRlbXBQb2x5Z29uLmNvbnRhaW5zKE1lc2gudGVtcFBvaW50JDIueCwgTWVzaC50ZW1wUG9pbnQkMi55KSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBEZXN0cm95cyB0aGUgTWVzaCBvYmplY3QuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtvYmplY3R8Ym9vbGVhbn0gW29wdGlvbnNdIC0gT3B0aW9ucyBwYXJhbWV0ZXIuIEEgYm9vbGVhbiB3aWxsIGFjdCBhcyBpZiBhbGxcclxuICAgICAqICBvcHRpb25zIGhhdmUgYmVlbiBzZXQgdG8gdGhhdCB2YWx1ZVxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jaGlsZHJlbj1mYWxzZV0gLSBpZiBzZXQgdG8gdHJ1ZSwgYWxsIHRoZSBjaGlsZHJlbiB3aWxsIGhhdmVcclxuICAgICAqICB0aGVpciBkZXN0cm95IG1ldGhvZCBjYWxsZWQgYXMgd2VsbC4gJ29wdGlvbnMnIHdpbGwgYmUgcGFzc2VkIG9uIHRvIHRob3NlIGNhbGxzLlxyXG4gICAgICovXHJcbiAgICBkZXN0cm95KG9wdGlvbnMpIHtcclxuICAgICAgICBzdXBlci5kZXN0cm95KG9wdGlvbnMpO1xyXG4gICAgICAgIHRoaXMuZ2VvbWV0cnkucmVmQ291bnQtLTtcclxuICAgICAgICBpZiAodGhpcy5nZW9tZXRyeS5yZWZDb3VudCA9PT0gMCkge1xyXG4gICAgICAgICAgICB0aGlzLmdlb21ldHJ5LmRpc3Bvc2UoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5nZW9tZXRyeSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5zaGFkZXIgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSBudWxsO1xyXG4gICAgICAgIHRoaXMudXZzID0gbnVsbDtcclxuICAgICAgICB0aGlzLmluZGljZXMgPSBudWxsO1xyXG4gICAgICAgIHRoaXMudmVydGV4RGF0YSA9IG51bGw7XHJcbiAgICB9XHJcbiAgICA7XHJcbn1cclxuTWVzaC50ZW1wUG9seWdvbiA9IG5ldyBQb2x5Z29uXzEuUG9seWdvbigpO1xyXG5NZXNoLnRlbXBQb2ludCQyID0gbmV3IFBvaW50XzEuUG9pbnQoKTtcclxuLyoqXHJcbiAqIFRoZSBtYXhpbXVtIG51bWJlciBvZiB2ZXJ0aWNlcyB0byBjb25zaWRlciBiYXRjaGFibGUuIEdlbmVyYWxseSwgdGhlIGNvbXBsZXhpdHlcclxuICogb2YgdGhlIGdlb21ldHJ5LlxyXG4gKiBAbWVtYmVyb2YgUElYSS5NZXNoXHJcbiAqIEBzdGF0aWNcclxuICogQG1lbWJlciB7bnVtYmVyfSBCQVRDSEFCTEVfU0laRVxyXG4gKi9cclxuTWVzaC5CQVRDSEFCTEVfU0laRSA9IDEwMDtcclxuZXhwb3J0cy5NZXNoID0gTWVzaDtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY2xhc3MgTWVzaEJhdGNoVXZzIHtcclxuICAgIGNvbnN0cnVjdG9yKHV2QnVmZmVyLCB1dk1hdHJpeCkge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQnVmZmVyIHdpdGggbm9ybWFsaXplZCBVVidzXHJcbiAgICAgICAgICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLkJ1ZmZlcn1cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMudXZCdWZmZXIgPSB1dkJ1ZmZlcjtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBNYXRlcmlhbCBVViBtYXRyaXhcclxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLlRleHR1cmVNYXRyaXh9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy51dk1hdHJpeCA9IHV2TWF0cml4O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFVWIEJ1ZmZlciBkYXRhXHJcbiAgICAgICAgICogQG1lbWJlciB7RmxvYXQzMkFycmF5fVxyXG4gICAgICAgICAqIEByZWFkb25seVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuZGF0YSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5fYnVmZmVyVXBkYXRlSWQgPSAtMTtcclxuICAgICAgICB0aGlzLl90ZXh0dXJlVXBkYXRlSWQgPSAtMTtcclxuICAgICAgICB0aGlzLl91cGRhdGVJRCA9IDA7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIHVwZGF0ZXNcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGZvcmNlVXBkYXRlIC0gZm9yY2UgdGhlIHVwZGF0ZVxyXG4gICAgICovXHJcbiAgICB1cGRhdGUoZm9yY2VVcGRhdGUpIHtcclxuICAgICAgICBpZiAoIWZvcmNlVXBkYXRlXHJcbiAgICAgICAgICAgICYmIHRoaXMuX2J1ZmZlclVwZGF0ZUlkID09PSB0aGlzLnV2QnVmZmVyLl91cGRhdGVJRFxyXG4gICAgICAgICAgICAmJiB0aGlzLl90ZXh0dXJlVXBkYXRlSWQgPT09IHRoaXMudXZNYXRyaXguX3VwZGF0ZUlEKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fYnVmZmVyVXBkYXRlSWQgPSB0aGlzLnV2QnVmZmVyLl91cGRhdGVJRDtcclxuICAgICAgICB0aGlzLl90ZXh0dXJlVXBkYXRlSWQgPSB0aGlzLnV2TWF0cml4Ll91cGRhdGVJRDtcclxuICAgICAgICB2YXIgZGF0YSA9IHRoaXMudXZCdWZmZXIuZGF0YTtcclxuICAgICAgICBpZiAoIXRoaXMuZGF0YSB8fCB0aGlzLmRhdGEubGVuZ3RoICE9PSBkYXRhLmxlbmd0aCkge1xyXG4gICAgICAgICAgICB0aGlzLmRhdGEgPSBuZXcgRmxvYXQzMkFycmF5KGRhdGEubGVuZ3RoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy51dk1hdHJpeC5tdWx0aXBseVV2cyhkYXRhLCB0aGlzLmRhdGEpO1xyXG4gICAgICAgIHRoaXMuX3VwZGF0ZUlEKys7XHJcbiAgICB9XHJcbiAgICA7XHJcbn1cclxuZXhwb3J0cy5NZXNoQmF0Y2hVdnMgPSBNZXNoQmF0Y2hVdnM7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IEdlb21ldHJ5XzEgPSByZXF1aXJlKFwiLi9HZW9tZXRyeVwiKTtcclxuY29uc3QgQnVmZmVyXzEgPSByZXF1aXJlKFwiLi9CdWZmZXJcIik7XHJcbmNvbnN0IFdlYkdMU2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL1dlYkdMU2V0dGluZ3NcIik7XHJcbmNsYXNzIE1lc2hHZW9tZXRyeSBleHRlbmRzIEdlb21ldHJ5XzEuR2VvbWV0cnkge1xyXG4gICAgY29uc3RydWN0b3IodmVydGljZXMgPSBudWxsLCB1dnMgPSBudWxsLCBpbmRleCA9IG51bGwpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHZhciB2ZXJ0aWNlc0J1ZmZlciA9IG5ldyBCdWZmZXJfMS5CdWZmZXIodmVydGljZXMpO1xyXG4gICAgICAgIHZhciB1dnNCdWZmZXIgPSBuZXcgQnVmZmVyXzEuQnVmZmVyKHV2cywgdHJ1ZSk7XHJcbiAgICAgICAgdmFyIGluZGV4QnVmZmVyID0gbmV3IEJ1ZmZlcl8xLkJ1ZmZlcihpbmRleCwgdHJ1ZSwgdHJ1ZSk7XHJcbiAgICAgICAgdGhpcy5hZGRBdHRyaWJ1dGUoJ2FWZXJ0ZXhQb3NpdGlvbicsIHZlcnRpY2VzQnVmZmVyLCAyLCBmYWxzZSwgV2ViR0xTZXR0aW5nc18xLldlYkdMU2V0dGluZ3MuVFlQRVMuRkxPQVQpXHJcbiAgICAgICAgICAgIC5hZGRBdHRyaWJ1dGUoJ2FUZXh0dXJlQ29vcmQnLCB1dnNCdWZmZXIsIDIsIGZhbHNlLCBXZWJHTFNldHRpbmdzXzEuV2ViR0xTZXR0aW5ncy5UWVBFUy5GTE9BVClcclxuICAgICAgICAgICAgLmFkZEluZGV4KGluZGV4QnVmZmVyKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBEaXJ0eSBmbGFnIHRvIGxpbWl0IHVwZGF0ZSBjYWxscyBvbiBNZXNoLiBGb3IgZXhhbXBsZSxcclxuICAgICAgICAgKiBsaW1pdGluZyB1cGRhdGVzIG9uIGEgc2luZ2xlIE1lc2ggaW5zdGFuY2Ugd2l0aCBhIHNoYXJlZCBHZW9tZXRyeVxyXG4gICAgICAgICAqIHdpdGhpbiB0aGUgcmVuZGVyIGxvb3AuXHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgICAgICogQGRlZmF1bHQgLTFcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLl91cGRhdGVJZCA9IC0xO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBJZiB0aGUgdmVydGV4IHBvc2l0aW9uIGlzIHVwZGF0ZWQuXHJcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIGdldCB2ZXJ0ZXhEaXJ0eUlkKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlcnNbMF0uX3VwZGF0ZUlEO1xyXG4gICAgfVxyXG4gICAgO1xyXG59XHJcbmV4cG9ydHMuTWVzaEdlb21ldHJ5ID0gTWVzaEdlb21ldHJ5O1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBTaGFkZXJfMSA9IHJlcXVpcmUoXCIuL1NoYWRlclwiKTtcclxuY29uc3QgTWF0cml4XzEgPSByZXF1aXJlKFwiLi9NYXRyaXhcIik7XHJcbmNvbnN0IFByb2dyYW1fMSA9IHJlcXVpcmUoXCIuL1Byb2dyYW1cIik7XHJcbmNvbnN0IFRleHR1cmVNYXRyaXhfMSA9IHJlcXVpcmUoXCIuL1RleHR1cmVNYXRyaXhcIik7XHJcbmNvbnN0IENvbG9yU2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL0NvbG9yU2V0dGluZ3NcIik7XHJcbmNsYXNzIE1lc2hNYXRlcmlhbCBleHRlbmRzIFNoYWRlcl8xLlNoYWRlciB7XHJcbiAgICBjb25zdHJ1Y3Rvcih1U2FtcGxlciwgb3B0aW9ucyA9IG51bGwpIHtcclxuICAgICAgICB2YXIgdW5pZm9ybXMgPSB7XHJcbiAgICAgICAgICAgIHVTYW1wbGVyOiB1U2FtcGxlcixcclxuICAgICAgICAgICAgYWxwaGE6IDEsXHJcbiAgICAgICAgICAgIHVUZXh0dXJlTWF0cml4OiBNYXRyaXhfMS5NYXRyaXguSURFTlRJVFksXHJcbiAgICAgICAgICAgIHVDb2xvcjogbmV3IEZsb2F0MzJBcnJheShbMSwgMSwgMSwgMV0pLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gU2V0IGRlZmF1bHRzXHJcbiAgICAgICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe1xyXG4gICAgICAgICAgICB0aW50OiAweEZGRkZGRixcclxuICAgICAgICAgICAgYWxwaGE6IDEsXHJcbiAgICAgICAgICAgIHBsdWdpbk5hbWU6ICdiYXRjaCcsXHJcbiAgICAgICAgfSwgb3B0aW9ucyk7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMudW5pZm9ybXMpIHtcclxuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih1bmlmb3Jtcywgb3B0aW9ucy51bmlmb3Jtcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN1cGVyKG9wdGlvbnMucHJvZ3JhbSB8fCBQcm9ncmFtXzEuUHJvZ3JhbS5mcm9tKE1lc2hNYXRlcmlhbC52ZXJ0ZXgkNiwgTWVzaE1hdGVyaWFsLmZyYWdtZW50JDgpLCB1bmlmb3Jtcyk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogT25seSBkbyB1cGRhdGUgaWYgdGludCBvciBhbHBoYSBjaGFuZ2VzLlxyXG4gICAgICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKiBAZGVmYXVsdCBmYWxzZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuX2NvbG9yRGlydHkgPSBmYWxzZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUZXh0dXJlTWF0cml4IGluc3RhbmNlIGZvciB0aGlzIE1lc2gsIHVzZWQgdG8gdHJhY2sgVGV4dHVyZSBjaGFuZ2VzXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLlRleHR1cmVNYXRyaXh9XHJcbiAgICAgICAgICogQHJlYWRvbmx5XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy51dk1hdHJpeCA9IG5ldyBUZXh0dXJlTWF0cml4XzEuVGV4dHVyZU1hdHJpeCh1U2FtcGxlcik7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogYHRydWVgIGlmIHNoYWRlciBjYW4gYmUgYmF0Y2ggd2l0aCB0aGUgcmVuZGVyZXIncyBiYXRjaCBzeXN0ZW0uXHJcbiAgICAgICAgICogQG1lbWJlciB7Ym9vbGVhbn1cclxuICAgICAgICAgKiBAZGVmYXVsdCB0cnVlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5iYXRjaGFibGUgPSBvcHRpb25zLnByb2dyYW0gPT09IHVuZGVmaW5lZDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZW5kZXJlciBwbHVnaW4gZm9yIGJhdGNoaW5nXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAbWVtYmVyIHtzdHJpbmd9XHJcbiAgICAgICAgICogQGRlZmF1bHQgJ2JhdGNoJ1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMucGx1Z2luTmFtZSA9IG9wdGlvbnMucGx1Z2luTmFtZTtcclxuICAgICAgICB0aGlzLnRpbnQgPSBvcHRpb25zLnRpbnQ7XHJcbiAgICAgICAgdGhpcy5hbHBoYSA9IG9wdGlvbnMuYWxwaGE7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlZmVyZW5jZSB0byB0aGUgdGV4dHVyZSBiZWluZyByZW5kZXJlZC5cclxuICAgICAqIEBtZW1iZXIge1BJWEkuVGV4dHVyZX1cclxuICAgICAqL1xyXG4gICAgZ2V0IHRleHR1cmUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudW5pZm9ybXMudVNhbXBsZXI7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICBzZXQgdGV4dHVyZSh2YWx1ZSkge1xyXG4gICAgICAgIGlmICh0aGlzLnVuaWZvcm1zLnVTYW1wbGVyICE9PSB2YWx1ZSkge1xyXG4gICAgICAgICAgICB0aGlzLnVuaWZvcm1zLnVTYW1wbGVyID0gdmFsdWU7XHJcbiAgICAgICAgICAgIHRoaXMudXZNYXRyaXgudGV4dHVyZSA9IHZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBnZXRzIGF1dG9tYXRpY2FsbHkgc2V0IGJ5IHRoZSBvYmplY3QgdXNpbmcgdGhpcy5cclxuICAgICAqXHJcbiAgICAgKiBAZGVmYXVsdCAxXHJcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHNldCBhbHBoYSh2YWx1ZSkge1xyXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdGhpcy5fYWxwaGEpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9hbHBoYSA9IHZhbHVlO1xyXG4gICAgICAgIHRoaXMuX2NvbG9yRGlydHkgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgZ2V0IGFscGhhKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9hbHBoYTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogTXVsdGlwbHkgdGludCBmb3IgdGhlIG1hdGVyaWFsLlxyXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICogQGRlZmF1bHQgMHhGRkZGRkZcclxuICAgICAqL1xyXG4gICAgc2V0IHRpbnQodmFsdWUpIHtcclxuICAgICAgICBpZiAodmFsdWUgPT09IHRoaXMuX3RpbnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl90aW50ID0gdmFsdWU7XHJcbiAgICAgICAgdGhpcy5fdGludFJHQiA9ICh2YWx1ZSA+PiAxNikgKyAodmFsdWUgJiAweGZmMDApICsgKCh2YWx1ZSAmIDB4ZmYpIDw8IDE2KTtcclxuICAgICAgICB0aGlzLl9jb2xvckRpcnR5ID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIGdldCB0aW50KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl90aW50O1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIGNhbGxlZCBhdXRvbWF0aWNhbGx5IGJ5IHRoZSBNZXNoLiBJbnRlbmRlZCB0byBiZSBvdmVycmlkZGVuIGZvciBjdXN0b21cclxuICAgICAqIE1lc2hNYXRlcmlhbCBvYmplY3RzLlxyXG4gICAgICovXHJcbiAgICB1cGRhdGUoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2NvbG9yRGlydHkpIHtcclxuICAgICAgICAgICAgdGhpcy5fY29sb3JEaXJ0eSA9IGZhbHNlO1xyXG4gICAgICAgICAgICB2YXIgYmFzZVRleHR1cmUgPSB0aGlzLnRleHR1cmUuYmFzZVRleHR1cmU7XHJcbiAgICAgICAgICAgIENvbG9yU2V0dGluZ3NfMS5Db2xvclNldHRpbmdzLnByZW11bHRpcGx5VGludFRvUmdiYSh0aGlzLl90aW50LCB0aGlzLl9hbHBoYSwgdGhpcy51bmlmb3Jtcy51Q29sb3IsIGJhc2VUZXh0dXJlLnByZW11bHRpcGx5QWxwaGEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy51dk1hdHJpeC51cGRhdGUoKSkge1xyXG4gICAgICAgICAgICB0aGlzLnVuaWZvcm1zLnVUZXh0dXJlTWF0cml4ID0gdGhpcy51dk1hdHJpeC5tYXBDb29yZDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICA7XHJcbn1cclxuTWVzaE1hdGVyaWFsLnZlcnRleCQ2ID0gXCJhdHRyaWJ1dGUgdmVjMiBhVmVydGV4UG9zaXRpb247XFxyXFxuYXR0cmlidXRlIHZlYzIgYVRleHR1cmVDb29yZDtcXHJcXG5cXHJcXG51bmlmb3JtIG1hdDMgcHJvamVjdGlvbk1hdHJpeDtcXHJcXG51bmlmb3JtIG1hdDMgdHJhbnNsYXRpb25NYXRyaXg7XFxyXFxudW5pZm9ybSBtYXQzIHVUZXh0dXJlTWF0cml4O1xcclxcblxcclxcbnZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xcclxcblxcclxcbnZvaWQgbWFpbih2b2lkKVxcclxcbntcXHJcXG4gICAgZ2xfUG9zaXRpb24gPSB2ZWM0KChwcm9qZWN0aW9uTWF0cml4ICogdHJhbnNsYXRpb25NYXRyaXggKiB2ZWMzKGFWZXJ0ZXhQb3NpdGlvbiwgMS4wKSkueHksIDAuMCwgMS4wKTtcXHJcXG5cXHJcXG4gICAgdlRleHR1cmVDb29yZCA9ICh1VGV4dHVyZU1hdHJpeCAqIHZlYzMoYVRleHR1cmVDb29yZCwgMS4wKSkueHk7XFxyXFxufVxcclxcblwiO1xyXG5NZXNoTWF0ZXJpYWwuZnJhZ21lbnQkOCA9IFwidmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XFxyXFxudW5pZm9ybSB2ZWM0IHVDb2xvcjtcXHJcXG5cXHJcXG51bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjtcXHJcXG5cXHJcXG52b2lkIG1haW4odm9pZClcXHJcXG57XFxyXFxuICAgIGdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCh1U2FtcGxlciwgdlRleHR1cmVDb29yZCkgKiB1Q29sb3I7XFxyXFxufVxcclxcblwiO1xyXG5leHBvcnRzLk1lc2hNYXRlcmlhbCA9IE1lc2hNYXRlcmlhbDtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgRXZlbnRfMSA9IHJlcXVpcmUoXCIuL0V2ZW50XCIpO1xyXG5jbGFzcyBNb3VzZUV2ZW50IGV4dGVuZHMgRXZlbnRfMS5FdmVudCB7XHJcbiAgICBjb25zdHJ1Y3Rvcih0eXBlLCBidWJibGVzID0gZmFsc2UpIHtcclxuICAgICAgICBzdXBlcih0eXBlLCBidWJibGVzKTtcclxuICAgICAgICB0aGlzLm1vdmVtZW50WCA9IDA7XHJcbiAgICAgICAgdGhpcy5tb3ZlbWVudFkgPSAwO1xyXG4gICAgfVxyXG59XHJcbk1vdXNlRXZlbnQuQ0xJQ0sgPSBcImNsaWNrXCI7XHJcbk1vdXNlRXZlbnQuTU9VU0VfRE9XTiA9IFwibW91c2VEb3duXCI7XHJcbk1vdXNlRXZlbnQuTU9VU0VfVVAgPSBcIm1vdXNlVXBcIjtcclxuTW91c2VFdmVudC5NSURETEVfQ0xJQ0sgPSBcIm1pZGRsZUNsaWNrXCI7XHJcbk1vdXNlRXZlbnQuTUlERExFX01PVVNFX0RPV04gPSBcIm1pZGRsZU1vdXNlRG93blwiO1xyXG5Nb3VzZUV2ZW50Lk1JRERMRV9NT1VTRV9VUCA9IFwibWlkZGxlTW91c2VVcFwiO1xyXG5Nb3VzZUV2ZW50LlJJR0hUX0NMSUNLID0gXCJyaWdodENsaWNrXCI7XHJcbk1vdXNlRXZlbnQuUklHSFRfTU9VU0VfRE9XTiA9IFwicmlnaHRNb3VzZURvd25cIjtcclxuTW91c2VFdmVudC5SSUdIVF9NT1VTRV9VUCA9IFwicmlnaHRNb3VzZVVwXCI7XHJcbk1vdXNlRXZlbnQuTU9VU0VfTU9WRSA9IFwibW91c2VNb3ZlXCI7XHJcbk1vdXNlRXZlbnQuTU9VU0VfT1ZFUiA9IFwibW91c2VPdmVyXCI7XHJcbk1vdXNlRXZlbnQuTU9VU0VfT1VUID0gXCJtb3VzZU91dFwiO1xyXG5Nb3VzZUV2ZW50LlJJR0hUX01PVVNFX1VQX09VVFNJREUgPSBcInJpZ2h0dXBvdXRzaWRlXCI7XHJcbk1vdXNlRXZlbnQuTU9VU0VfVVBfT1VUU0lERSA9IFwibW91c2V1cG91dHNpZGVcIjtcclxuTW91c2VFdmVudC5QT0lOVEVSX09WRVIgPSBcInBvaW50ZXJvdmVyXCI7XHJcbk1vdXNlRXZlbnQuUE9JTlRFUl9FTlRFUiA9IFwicG9pbnRlcmVudGVyXCI7XHJcbk1vdXNlRXZlbnQuUE9JTlRFUl9ET1dOID0gXCJwb2ludGVyZG93blwiO1xyXG5Nb3VzZUV2ZW50LlBPSU5URVJfTU9WRSA9IFwicG9pbnRlcm1vdmVcIjtcclxuTW91c2VFdmVudC5QT0lOVEVSX1VQID0gXCJwb2ludGVydXBcIjtcclxuTW91c2VFdmVudC5QT0lOVEVSX0NBTkNFTCA9IFwicG9pbnRlcmNhbmNlbFwiO1xyXG5Nb3VzZUV2ZW50LlBPSU5URVJfT1VUID0gXCJwb2ludGVyb3V0XCI7XHJcbk1vdXNlRXZlbnQuUE9JTlRFUl9MRUFWRSA9IFwicG9pbnRlcmxlYXZlXCI7XHJcbk1vdXNlRXZlbnQuUE9JTlRFUl9DQVBUVVJFID0gXCJnb3Rwb2ludGVyY2FwdHVyZVwiO1xyXG5Nb3VzZUV2ZW50LlBPSU5URVJfTE9TVCA9IFwibG9zdHBvaW50ZXJjYXB0dXJlXCI7XHJcbk1vdXNlRXZlbnQuUE9JTlRFUl9VUF9PVVRTSURFID0gXCJwb2ludGVydXBvdXRzaWRlXCI7XHJcbk1vdXNlRXZlbnQuUE9JTlRFUl9UQVAgPSBcInBvaW50ZXJ0YXBcIjtcclxuTW91c2VFdmVudC5UT1VDSF9TVEFSVCA9IFwidG91Y2hzdGFydFwiO1xyXG5Nb3VzZUV2ZW50LlRPVUNIX0VORCA9IFwidG91Y2hlbmRcIjtcclxuTW91c2VFdmVudC5UT1VDSF9FTkRfT1VUU0lERSA9IFwidG91Y2hlbmRvdXRzaWRlXCI7XHJcbk1vdXNlRXZlbnQuVE9VQ0hfTU9WRSA9IFwidG91Y2htb3ZlXCI7XHJcbk1vdXNlRXZlbnQuVE9VQ0hfQ0FOQ0VMID0gXCJ0b3VjaGNhbmNlbFwiO1xyXG5Nb3VzZUV2ZW50LlRPVUNIX1RBUCA9IFwidGFwXCI7XHJcbmV4cG9ydHMuTW91c2VFdmVudCA9IE1vdXNlRXZlbnQ7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IFVybF8xID0gcmVxdWlyZShcIi4vVXJsXCIpO1xyXG5jbGFzcyBOZXR3b3JrU2V0dGluZ3Mge1xyXG4gICAgc3RhdGljIGdldFJlc29sdXRpb25PZlVybCh1cmwsIGRlZmF1bHRWYWx1ZSA9IG51bGwpIHtcclxuICAgICAgICB2YXIgcmVzb2x1dGlvbiA9IE5ldHdvcmtTZXR0aW5ncy5SRVRJTkFfUFJFRklYLmV4ZWModXJsKTtcclxuICAgICAgICBpZiAocmVzb2x1dGlvbikge1xyXG4gICAgICAgICAgICByZXR1cm4gcGFyc2VGbG9hdChyZXNvbHV0aW9uWzFdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZSAhPT0gdW5kZWZpbmVkID8gZGVmYXVsdFZhbHVlIDogMTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBkZXRlcm1pbmVDcm9zc09yaWdpbih1cmwkMSwgbG9jID0gbnVsbCkge1xyXG4gICAgICAgIGlmIChsb2MgPT09IHZvaWQgMCkge1xyXG4gICAgICAgICAgICBsb2MgPSB3aW5kb3cubG9jYXRpb247XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh1cmwkMS5pbmRleE9mKCdkYXRhOicpID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnJztcclxuICAgICAgICB9XHJcbiAgICAgICAgbG9jID0gbG9jIHx8IHdpbmRvdy5sb2NhdGlvbjtcclxuICAgICAgICBpZiAoIU5ldHdvcmtTZXR0aW5ncy50ZW1wQW5jaG9yKSB7XHJcbiAgICAgICAgICAgIE5ldHdvcmtTZXR0aW5ncy50ZW1wQW5jaG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBOZXR3b3JrU2V0dGluZ3MudGVtcEFuY2hvci5ocmVmID0gdXJsJDE7XHJcbiAgICAgICAgdXJsJDEgPSBOZXR3b3JrU2V0dGluZ3MudXJsLnBhcnNlKE5ldHdvcmtTZXR0aW5ncy50ZW1wQW5jaG9yLmhyZWYpO1xyXG4gICAgICAgIHZhciBzYW1lUG9ydCA9ICghdXJsJDEucG9ydCAmJiBsb2MucG9ydCA9PT0gJycpIHx8ICh1cmwkMS5wb3J0ID09PSBsb2MucG9ydCk7XHJcbiAgICAgICAgaWYgKHVybCQxLmhvc3RuYW1lICE9PSBsb2MuaG9zdG5hbWUgfHwgIXNhbWVQb3J0IHx8IHVybCQxLnByb3RvY29sICE9PSBsb2MucHJvdG9jb2wpIHtcclxuICAgICAgICAgICAgcmV0dXJuICdhbm9ueW1vdXMnO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gJyc7XHJcbiAgICB9XHJcbn1cclxuTmV0d29ya1NldHRpbmdzLlJFVElOQV9QUkVGSVggPSAvQChbMC05XFwuXSspeC87XHJcbk5ldHdvcmtTZXR0aW5ncy51cmwgPSB7XHJcbiAgICBwYXJzZTogVXJsXzEuVXJsLnVybFBhcnNlLFxyXG4gICAgcmVzb2x2ZTogVXJsXzEuVXJsLnVybFJlc29sdmUsXHJcbiAgICByZXNvbHZlT2JqZWN0OiBVcmxfMS5VcmwudXJsUmVzb2x2ZU9iamVjdCxcclxuICAgIGZvcm1hdDogVXJsXzEuVXJsLnVybEZvcm1hdCxcclxuICAgIFVybDogVXJsXzEuVXJsXHJcbn07XHJcbmV4cG9ydHMuTmV0d29ya1NldHRpbmdzID0gTmV0d29ya1NldHRpbmdzO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBTeXN0ZW1fMSA9IHJlcXVpcmUoXCIuL1N5c3RlbVwiKTtcclxuY2xhc3MgT2JqZWN0UmVuZGVyZXIgZXh0ZW5kcyBTeXN0ZW1fMS5TeXN0ZW0ge1xyXG4gICAgY29uc3RydWN0b3IocmVuZGVyZXIpIHtcclxuICAgICAgICBzdXBlcihyZW5kZXJlcik7XHJcbiAgICB9XHJcbiAgICBzdGFydCgpIHtcclxuICAgICAgICAvLyBzZXQgdGhlIHNoYWRlci4uXHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFN0b3BzIHRoZSByZW5kZXJlclxyXG4gICAgICpcclxuICAgICAqL1xyXG4gICAgc3RvcCgpIHtcclxuICAgICAgICB0aGlzLmZsdXNoKCk7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFN0dWIgbWV0aG9kIGZvciByZW5kZXJpbmcgY29udGVudCBhbmQgZW1wdHlpbmcgdGhlIGN1cnJlbnQgYmF0Y2guXHJcbiAgICAgKlxyXG4gICAgICovXHJcbiAgICBmbHVzaCgpIHtcclxuICAgICAgICAvLyBmbHVzaCFcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogUmVuZGVycyBhbiBvYmplY3RcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1BJWEkuRGlzcGxheU9iamVjdH0gb2JqZWN0IC0gVGhlIG9iamVjdCB0byByZW5kZXIuXHJcbiAgICAgKi9cclxuICAgIHJlbmRlcihvYmplY3QpIHtcclxuICAgICAgICAvLyByZW5kZXIgdGhlIG9iamVjdFxyXG4gICAgfVxyXG4gICAgO1xyXG59XHJcbmV4cG9ydHMuT2JqZWN0UmVuZGVyZXIgPSBPYmplY3RSZW5kZXJlcjtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY2xhc3MgT2JzZXJ2YWJsZVBvaW50IHtcclxuICAgIGNvbnN0cnVjdG9yKGNiLCBzY29wZSwgeCA9IDAsIHkgPSAwKSB7XHJcbiAgICAgICAgaWYgKHggPT09IHZvaWQgMCkge1xyXG4gICAgICAgICAgICB4ID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHkgPT09IHZvaWQgMCkge1xyXG4gICAgICAgICAgICB5ID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5feCA9IHg7XHJcbiAgICAgICAgdGhpcy5feSA9IHk7XHJcbiAgICAgICAgdGhpcy5jYiA9IGNiO1xyXG4gICAgICAgIHRoaXMuc2NvcGUgPSBzY29wZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIGNsb25lIG9mIHRoaXMgcG9pbnQuXHJcbiAgICAgKiBUaGUgY2FsbGJhY2sgYW5kIHNjb3BlIHBhcmFtcyBjYW4gYmUgb3ZlcmlkZGVuIG90aGVyd2lzZSB0aGV5IHdpbGwgZGVmYXVsdFxyXG4gICAgICogdG8gdGhlIGNsb25lIG9iamVjdCdzIHZhbHVlcy5cclxuICAgICAqXHJcbiAgICAgKiBAb3ZlcnJpZGVcclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYj1udWxsXSAtIGNhbGxiYWNrIHdoZW4gY2hhbmdlZFxyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtzY29wZT1udWxsXSAtIG93bmVyIG9mIGNhbGxiYWNrXHJcbiAgICAgKiBAcmV0dXJuIHtQSVhJLk9ic2VydmFibGVQb2ludH0gYSBjb3B5IG9mIHRoZSBwb2ludFxyXG4gICAgICovXHJcbiAgICBjbG9uZShjYiwgc2NvcGUpIHtcclxuICAgICAgICBpZiAoY2IgPT09IHZvaWQgMCkge1xyXG4gICAgICAgICAgICBjYiA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzY29wZSA9PT0gdm9pZCAwKSB7XHJcbiAgICAgICAgICAgIHNjb3BlID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIF9jYiA9IGNiIHx8IHRoaXMuY2I7XHJcbiAgICAgICAgdmFyIF9zY29wZSA9IHNjb3BlIHx8IHRoaXMuc2NvcGU7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBPYnNlcnZhYmxlUG9pbnQoX2NiLCBfc2NvcGUsIHRoaXMuX3gsIHRoaXMuX3kpO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBwb2ludCB0byBhIG5ldyB4IGFuZCB5IHBvc2l0aW9uLlxyXG4gICAgICogSWYgeSBpcyBvbWl0dGVkLCBib3RoIHggYW5kIHkgd2lsbCBiZSBzZXQgdG8geC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3g9MF0gLSBwb3NpdGlvbiBvZiB0aGUgcG9pbnQgb24gdGhlIHggYXhpc1xyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt5PTBdIC0gcG9zaXRpb24gb2YgdGhlIHBvaW50IG9uIHRoZSB5IGF4aXNcclxuICAgICAqL1xyXG4gICAgc2V0KHgsIHkpIHtcclxuICAgICAgICB2YXIgX3ggPSB4IHx8IDA7XHJcbiAgICAgICAgdmFyIF95ID0geSB8fCAoKHkgIT09IDApID8gX3ggOiAwKTtcclxuICAgICAgICBpZiAodGhpcy5feCAhPT0gX3ggfHwgdGhpcy5feSAhPT0gX3kpIHtcclxuICAgICAgICAgICAgdGhpcy5feCA9IF94O1xyXG4gICAgICAgICAgICB0aGlzLl95ID0gX3k7XHJcbiAgICAgICAgICAgIHRoaXMuY2IuY2FsbCh0aGlzLnNjb3BlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIENvcGllcyB4IGFuZCB5IGZyb20gdGhlIGdpdmVuIHBvaW50XHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtQSVhJLklQb2ludH0gcCAtIFRoZSBwb2ludCB0byBjb3B5IGZyb20uXHJcbiAgICAgKiBAcmV0dXJucyB7UElYSS5JUG9pbnR9IFJldHVybnMgaXRzZWxmLlxyXG4gICAgICovXHJcbiAgICBjb3B5RnJvbShwKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3ggIT09IHAueCB8fCB0aGlzLl95ICE9PSBwLnkpIHtcclxuICAgICAgICAgICAgdGhpcy5feCA9IHAueDtcclxuICAgICAgICAgICAgdGhpcy5feSA9IHAueTtcclxuICAgICAgICAgICAgdGhpcy5jYi5jYWxsKHRoaXMuc2NvcGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQ29waWVzIHggYW5kIHkgaW50byB0aGUgZ2l2ZW4gcG9pbnRcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1BJWEkuSVBvaW50fSBwIC0gVGhlIHBvaW50IHRvIGNvcHkuXHJcbiAgICAgKiBAcmV0dXJucyB7UElYSS5JUG9pbnR9IEdpdmVuIHBvaW50IHdpdGggdmFsdWVzIHVwZGF0ZWRcclxuICAgICAqL1xyXG4gICAgY29weVRvKHApIHtcclxuICAgICAgICBwLnNldCh0aGlzLl94LCB0aGlzLl95KTtcclxuICAgICAgICByZXR1cm4gcDtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBwb2ludCBpcyBlcXVhbCB0byB0aGlzIHBvaW50XHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtQSVhJLklQb2ludH0gcCAtIFRoZSBwb2ludCB0byBjaGVja1xyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFdoZXRoZXIgdGhlIGdpdmVuIHBvaW50IGVxdWFsIHRvIHRoaXMgcG9pbnRcclxuICAgICAqL1xyXG4gICAgZXF1YWxzKHApIHtcclxuICAgICAgICByZXR1cm4gKHAueCA9PT0gdGhpcy5feCkgJiYgKHAueSA9PT0gdGhpcy5feSk7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBwb3NpdGlvbiBvZiB0aGUgZGlzcGxheU9iamVjdCBvbiB0aGUgeCBheGlzIHJlbGF0aXZlIHRvIHRoZSBsb2NhbCBjb29yZGluYXRlcyBvZiB0aGUgcGFyZW50LlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgZ2V0IHgoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3g7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICBzZXQgeCh2YWx1ZSkge1xyXG4gICAgICAgIGlmICh0aGlzLl94ICE9PSB2YWx1ZSkge1xyXG4gICAgICAgICAgICB0aGlzLl94ID0gdmFsdWU7XHJcbiAgICAgICAgICAgIHRoaXMuY2IuY2FsbCh0aGlzLnNjb3BlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBwb3NpdGlvbiBvZiB0aGUgZGlzcGxheU9iamVjdCBvbiB0aGUgeCBheGlzIHJlbGF0aXZlIHRvIHRoZSBsb2NhbCBjb29yZGluYXRlcyBvZiB0aGUgcGFyZW50LlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgZ2V0IHkoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3k7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICBzZXQgeSh2YWx1ZSkge1xyXG4gICAgICAgIGlmICh0aGlzLl95ICE9PSB2YWx1ZSkge1xyXG4gICAgICAgICAgICB0aGlzLl95ID0gdmFsdWU7XHJcbiAgICAgICAgICAgIHRoaXMuY2IuY2FsbCh0aGlzLnNjb3BlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICA7XHJcbn1cclxuZXhwb3J0cy5PYnNlcnZhYmxlUG9pbnQgPSBPYnNlcnZhYmxlUG9pbnQ7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IEdlb21ldHJ5XzEgPSByZXF1aXJlKFwiLi9HZW9tZXRyeVwiKTtcclxuY29uc3QgQnVmZmVyXzEgPSByZXF1aXJlKFwiLi9CdWZmZXJcIik7XHJcbmNvbnN0IFdlYkdMU2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL1dlYkdMU2V0dGluZ3NcIik7XHJcbmNsYXNzIFBhcnRpY2xlQnVmZmVyIHtcclxuICAgIGNvbnN0cnVjdG9yKHByb3BlcnRpZXMsIGR5bmFtaWNQcm9wZXJ0eUZsYWdzLCBzaXplKSB7XHJcbiAgICAgICAgdGhpcy5nZW9tZXRyeSA9IG5ldyBHZW9tZXRyeV8xLkdlb21ldHJ5KCk7XHJcbiAgICAgICAgdGhpcy5pbmRleEJ1ZmZlciA9IG51bGw7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIG51bWJlciBvZiBwYXJ0aWNsZXMgdGhlIGJ1ZmZlciBjYW4gaG9sZFxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5zaXplID0gc2l6ZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBIGxpc3Qgb2YgdGhlIHByb3BlcnRpZXMgdGhhdCBhcmUgZHluYW1pYy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICogQG1lbWJlciB7b2JqZWN0W119XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5keW5hbWljUHJvcGVydGllcyA9IFtdO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEEgbGlzdCBvZiB0aGUgcHJvcGVydGllcyB0aGF0IGFyZSBzdGF0aWMuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqIEBtZW1iZXIge29iamVjdFtdfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuc3RhdGljUHJvcGVydGllcyA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcGVydGllcy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICB2YXIgcHJvcGVydHkgPSBwcm9wZXJ0aWVzW2ldO1xyXG4gICAgICAgICAgICAvLyBNYWtlIGNvcHkgb2YgcHJvcGVydGllcyBvYmplY3Qgc28gdGhhdCB3aGVuIHdlIGVkaXQgdGhlIG9mZnNldCBpdCBkb2Vzbid0XHJcbiAgICAgICAgICAgIC8vIGNoYW5nZSBhbGwgb3RoZXIgaW5zdGFuY2VzIG9mIHRoZSBvYmplY3QgbGl0ZXJhbFxyXG4gICAgICAgICAgICBwcm9wZXJ0eSA9IHtcclxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZU5hbWU6IHByb3BlcnR5LmF0dHJpYnV0ZU5hbWUsXHJcbiAgICAgICAgICAgICAgICBzaXplOiBwcm9wZXJ0eS5zaXplLFxyXG4gICAgICAgICAgICAgICAgdXBsb2FkRnVuY3Rpb246IHByb3BlcnR5LnVwbG9hZEZ1bmN0aW9uLFxyXG4gICAgICAgICAgICAgICAgdHlwZTogcHJvcGVydHkudHlwZSB8fCBXZWJHTFNldHRpbmdzXzEuV2ViR0xTZXR0aW5ncy5UWVBFUy5GTE9BVCxcclxuICAgICAgICAgICAgICAgIG9mZnNldDogcHJvcGVydHkub2Zmc2V0LFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBpZiAoZHluYW1pY1Byb3BlcnR5RmxhZ3NbaV0pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZHluYW1pY1Byb3BlcnRpZXMucHVzaChwcm9wZXJ0eSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRpY1Byb3BlcnRpZXMucHVzaChwcm9wZXJ0eSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zdGF0aWNTdHJpZGUgPSAwO1xyXG4gICAgICAgIHRoaXMuc3RhdGljQnVmZmVyID0gbnVsbDtcclxuICAgICAgICB0aGlzLnN0YXRpY0RhdGEgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuc3RhdGljRGF0YVVpbnQzMiA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5keW5hbWljU3RyaWRlID0gMDtcclxuICAgICAgICB0aGlzLmR5bmFtaWNCdWZmZXIgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuZHluYW1pY0RhdGEgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuZHluYW1pY0RhdGFVaW50MzIgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuX3VwZGF0ZUlEID0gMDtcclxuICAgICAgICB0aGlzLmluaXRCdWZmZXJzKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdXAgdGhlIHJlbmRlcmVyIGNvbnRleHQgYW5kIG5lY2Vzc2FyeSBidWZmZXJzLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIGluaXRCdWZmZXJzKCkge1xyXG4gICAgICAgIHZhciBnZW9tZXRyeSA9IHRoaXMuZ2VvbWV0cnk7XHJcbiAgICAgICAgdmFyIGR5bmFtaWNPZmZzZXQgPSAwO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEhvbGRzIHRoZSBpbmRpY2VzIG9mIHRoZSBnZW9tZXRyeSAocXVhZHMpIHRvIGRyYXdcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBtZW1iZXIge1VpbnQxNkFycmF5fVxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5pbmRleEJ1ZmZlciA9IG5ldyBCdWZmZXJfMS5CdWZmZXIoV2ViR0xTZXR0aW5nc18xLldlYkdMU2V0dGluZ3MuY3JlYXRlSW5kaWNlc0ZvclF1YWRzKHRoaXMuc2l6ZSksIHRydWUsIHRydWUpO1xyXG4gICAgICAgIGdlb21ldHJ5LmFkZEluZGV4KHRoaXMuaW5kZXhCdWZmZXIpO1xyXG4gICAgICAgIHRoaXMuZHluYW1pY1N0cmlkZSA9IDA7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmR5bmFtaWNQcm9wZXJ0aWVzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgIHZhciBwcm9wZXJ0eSA9IHRoaXMuZHluYW1pY1Byb3BlcnRpZXNbaV07XHJcbiAgICAgICAgICAgIHByb3BlcnR5Lm9mZnNldCA9IGR5bmFtaWNPZmZzZXQ7XHJcbiAgICAgICAgICAgIGR5bmFtaWNPZmZzZXQgKz0gcHJvcGVydHkuc2l6ZTtcclxuICAgICAgICAgICAgdGhpcy5keW5hbWljU3RyaWRlICs9IHByb3BlcnR5LnNpemU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBkeW5CdWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIodGhpcy5zaXplICogdGhpcy5keW5hbWljU3RyaWRlICogNCAqIDQpO1xyXG4gICAgICAgIHRoaXMuZHluYW1pY0RhdGEgPSBuZXcgRmxvYXQzMkFycmF5KGR5bkJ1ZmZlcik7XHJcbiAgICAgICAgdGhpcy5keW5hbWljRGF0YVVpbnQzMiA9IG5ldyBVaW50MzJBcnJheShkeW5CdWZmZXIpO1xyXG4gICAgICAgIHRoaXMuZHluYW1pY0J1ZmZlciA9IG5ldyBCdWZmZXJfMS5CdWZmZXIodGhpcy5keW5hbWljRGF0YSwgZmFsc2UsIGZhbHNlKTtcclxuICAgICAgICAvLyBzdGF0aWMgLy9cclxuICAgICAgICB2YXIgc3RhdGljT2Zmc2V0ID0gMDtcclxuICAgICAgICB0aGlzLnN0YXRpY1N0cmlkZSA9IDA7XHJcbiAgICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgdGhpcy5zdGF0aWNQcm9wZXJ0aWVzLmxlbmd0aDsgKytpJDEpIHtcclxuICAgICAgICAgICAgdmFyIHByb3BlcnR5JDEgPSB0aGlzLnN0YXRpY1Byb3BlcnRpZXNbaSQxXTtcclxuICAgICAgICAgICAgcHJvcGVydHkkMS5vZmZzZXQgPSBzdGF0aWNPZmZzZXQ7XHJcbiAgICAgICAgICAgIHN0YXRpY09mZnNldCArPSBwcm9wZXJ0eSQxLnNpemU7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGljU3RyaWRlICs9IHByb3BlcnR5JDEuc2l6ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHN0YXRCdWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIodGhpcy5zaXplICogdGhpcy5zdGF0aWNTdHJpZGUgKiA0ICogNCk7XHJcbiAgICAgICAgdGhpcy5zdGF0aWNEYXRhID0gbmV3IEZsb2F0MzJBcnJheShzdGF0QnVmZmVyKTtcclxuICAgICAgICB0aGlzLnN0YXRpY0RhdGFVaW50MzIgPSBuZXcgVWludDMyQXJyYXkoc3RhdEJ1ZmZlcik7XHJcbiAgICAgICAgdGhpcy5zdGF0aWNCdWZmZXIgPSBuZXcgQnVmZmVyXzEuQnVmZmVyKHRoaXMuc3RhdGljRGF0YSwgdHJ1ZSwgZmFsc2UpO1xyXG4gICAgICAgIGZvciAodmFyIGkkMiA9IDA7IGkkMiA8IHRoaXMuZHluYW1pY1Byb3BlcnRpZXMubGVuZ3RoOyArK2kkMikge1xyXG4gICAgICAgICAgICB2YXIgcHJvcGVydHkkMiA9IHRoaXMuZHluYW1pY1Byb3BlcnRpZXNbaSQyXTtcclxuICAgICAgICAgICAgZ2VvbWV0cnkuYWRkQXR0cmlidXRlKHByb3BlcnR5JDIuYXR0cmlidXRlTmFtZSwgdGhpcy5keW5hbWljQnVmZmVyLCAwLCBwcm9wZXJ0eSQyLnR5cGUgPT09IFdlYkdMU2V0dGluZ3NfMS5XZWJHTFNldHRpbmdzLlRZUEVTLlVOU0lHTkVEX0JZVEUsIHByb3BlcnR5JDIudHlwZSwgdGhpcy5keW5hbWljU3RyaWRlICogNCwgcHJvcGVydHkkMi5vZmZzZXQgKiA0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yICh2YXIgaSQzID0gMDsgaSQzIDwgdGhpcy5zdGF0aWNQcm9wZXJ0aWVzLmxlbmd0aDsgKytpJDMpIHtcclxuICAgICAgICAgICAgdmFyIHByb3BlcnR5JDMgPSB0aGlzLnN0YXRpY1Byb3BlcnRpZXNbaSQzXTtcclxuICAgICAgICAgICAgZ2VvbWV0cnkuYWRkQXR0cmlidXRlKHByb3BlcnR5JDMuYXR0cmlidXRlTmFtZSwgdGhpcy5zdGF0aWNCdWZmZXIsIDAsIHByb3BlcnR5JDMudHlwZSA9PT0gV2ViR0xTZXR0aW5nc18xLldlYkdMU2V0dGluZ3MuVFlQRVMuVU5TSUdORURfQllURSwgcHJvcGVydHkkMy50eXBlLCB0aGlzLnN0YXRpY1N0cmlkZSAqIDQsIHByb3BlcnR5JDMub2Zmc2V0ICogNCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBVcGxvYWRzIHRoZSBkeW5hbWljIHByb3BlcnRpZXMuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7UElYSS5EaXNwbGF5T2JqZWN0W119IGNoaWxkcmVuIC0gVGhlIGNoaWxkcmVuIHRvIHVwbG9hZC5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydEluZGV4IC0gVGhlIGluZGV4IHRvIHN0YXJ0IGF0LlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGFtb3VudCAtIFRoZSBudW1iZXIgdG8gdXBsb2FkLlxyXG4gICAgICovXHJcbiAgICB1cGxvYWREeW5hbWljKGNoaWxkcmVuLCBzdGFydEluZGV4LCBhbW91bnQpIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZHluYW1pY1Byb3BlcnRpZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIHByb3BlcnR5ID0gdGhpcy5keW5hbWljUHJvcGVydGllc1tpXTtcclxuICAgICAgICAgICAgcHJvcGVydHkudXBsb2FkRnVuY3Rpb24oY2hpbGRyZW4sIHN0YXJ0SW5kZXgsIGFtb3VudCwgcHJvcGVydHkudHlwZSA9PT0gV2ViR0xTZXR0aW5nc18xLldlYkdMU2V0dGluZ3MuVFlQRVMuVU5TSUdORURfQllURSA/IHRoaXMuZHluYW1pY0RhdGFVaW50MzIgOiB0aGlzLmR5bmFtaWNEYXRhLCB0aGlzLmR5bmFtaWNTdHJpZGUsIHByb3BlcnR5Lm9mZnNldCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZHluYW1pY0J1ZmZlci5fdXBkYXRlSUQrKztcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogVXBsb2FkcyB0aGUgc3RhdGljIHByb3BlcnRpZXMuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7UElYSS5EaXNwbGF5T2JqZWN0W119IGNoaWxkcmVuIC0gVGhlIGNoaWxkcmVuIHRvIHVwbG9hZC5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydEluZGV4IC0gVGhlIGluZGV4IHRvIHN0YXJ0IGF0LlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGFtb3VudCAtIFRoZSBudW1iZXIgdG8gdXBsb2FkLlxyXG4gICAgICovXHJcbiAgICB1cGxvYWRTdGF0aWMoY2hpbGRyZW4sIHN0YXJ0SW5kZXgsIGFtb3VudCkge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5zdGF0aWNQcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBwcm9wZXJ0eSA9IHRoaXMuc3RhdGljUHJvcGVydGllc1tpXTtcclxuICAgICAgICAgICAgcHJvcGVydHkudXBsb2FkRnVuY3Rpb24oY2hpbGRyZW4sIHN0YXJ0SW5kZXgsIGFtb3VudCwgcHJvcGVydHkudHlwZSA9PT0gV2ViR0xTZXR0aW5nc18xLldlYkdMU2V0dGluZ3MuVFlQRVMuVU5TSUdORURfQllURSA/IHRoaXMuc3RhdGljRGF0YVVpbnQzMiA6IHRoaXMuc3RhdGljRGF0YSwgdGhpcy5zdGF0aWNTdHJpZGUsIHByb3BlcnR5Lm9mZnNldCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuc3RhdGljQnVmZmVyLl91cGRhdGVJRCsrO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBEZXN0cm95cyB0aGUgUGFydGljbGVCdWZmZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgZGVzdHJveSgpIHtcclxuICAgICAgICB0aGlzLmluZGV4QnVmZmVyID0gbnVsbDtcclxuICAgICAgICB0aGlzLmR5bmFtaWNQcm9wZXJ0aWVzID0gbnVsbDtcclxuICAgICAgICAvLyB0aGlzLmR5bmFtaWNCdWZmZXIuZGVzdHJveSgpO1xyXG4gICAgICAgIHRoaXMuZHluYW1pY0J1ZmZlciA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5keW5hbWljRGF0YSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5keW5hbWljRGF0YVVpbnQzMiA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5zdGF0aWNQcm9wZXJ0aWVzID0gbnVsbDtcclxuICAgICAgICAvLyB0aGlzLnN0YXRpY0J1ZmZlci5kZXN0cm95KCk7XHJcbiAgICAgICAgdGhpcy5zdGF0aWNCdWZmZXIgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuc3RhdGljRGF0YSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5zdGF0aWNEYXRhVWludDMyID0gbnVsbDtcclxuICAgICAgICAvLyBhbGwgYnVmZmVycyBhcmUgZGVzdHJveWVkIGluc2lkZSBnZW9tZXRyeVxyXG4gICAgICAgIHRoaXMuZ2VvbWV0cnkuZGVzdHJveSgpO1xyXG4gICAgfVxyXG4gICAgO1xyXG59XHJcbmV4cG9ydHMuUGFydGljbGVCdWZmZXIgPSBQYXJ0aWNsZUJ1ZmZlcjtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgT2JqZWN0UmVuZGVyZXJfMSA9IHJlcXVpcmUoXCIuL09iamVjdFJlbmRlcmVyXCIpO1xyXG5jb25zdCBNYXRyaXhfMSA9IHJlcXVpcmUoXCIuL01hdHJpeFwiKTtcclxuY29uc3QgU2hhZGVyXzEgPSByZXF1aXJlKFwiLi9TaGFkZXJcIik7XHJcbmNvbnN0IFBhcnRpY2xlQnVmZmVyXzEgPSByZXF1aXJlKFwiLi9QYXJ0aWNsZUJ1ZmZlclwiKTtcclxuY29uc3QgQ29sb3JTZXR0aW5nc18xID0gcmVxdWlyZShcIi4vQ29sb3JTZXR0aW5nc1wiKTtcclxuY29uc3QgQmxlbmRNb2Rlc1NldHRpbmdzXzEgPSByZXF1aXJlKFwiLi9CbGVuZE1vZGVzU2V0dGluZ3NcIik7XHJcbmNvbnN0IFdlYkdMU2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL1dlYkdMU2V0dGluZ3NcIik7XHJcbmNsYXNzIFBhcnRpY2xlUmVuZGVyZXIgZXh0ZW5kcyBPYmplY3RSZW5kZXJlcl8xLk9iamVjdFJlbmRlcmVyIHtcclxuICAgIGNvbnN0cnVjdG9yKHJlbmRlcmVyKSB7XHJcbiAgICAgICAgc3VwZXIocmVuZGVyZXIpO1xyXG4gICAgICAgIC8vIDY1NTM1IGlzIG1heCB2ZXJ0ZXggaW5kZXggaW4gdGhlIGluZGV4IGJ1ZmZlciAoc2VlIFBhcnRpY2xlUmVuZGVyZXIpXHJcbiAgICAgICAgLy8gc28gbWF4IG51bWJlciBvZiBwYXJ0aWNsZXMgaXMgNjU1MzYgLyA0ID0gMTYzODRcclxuICAgICAgICAvLyBhbmQgbWF4IG51bWJlciBvZiBlbGVtZW50IGluIHRoZSBpbmRleCBidWZmZXIgaXMgMTYzODQgKiA2ID0gOTgzMDRcclxuICAgICAgICAvLyBDcmVhdGluZyBhIGZ1bGwgaW5kZXggYnVmZmVyLCBvdmVyaGVhZCBpcyA5ODMwNCAqIDIgPSAxOTZLb1xyXG4gICAgICAgIC8vIGxldCBudW1JbmRpY2VzID0gOTgzMDQ7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGRlZmF1bHQgc2hhZGVyIHRoYXQgaXMgdXNlZCBpZiBhIHNwcml0ZSBkb2Vzbid0IGhhdmUgYSBtb3JlIHNwZWNpZmljIG9uZS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuU2hhZGVyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuc2hhZGVyID0gbnVsbDtcclxuICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSBudWxsO1xyXG4gICAgICAgIHRoaXMudGVtcE1hdHJpeCA9IG5ldyBNYXRyaXhfMS5NYXRyaXgoKTtcclxuICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSBbXHJcbiAgICAgICAgICAgIC8vIHZlcnRpY2VzRGF0YVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVOYW1lOiAnYVZlcnRleFBvc2l0aW9uJyxcclxuICAgICAgICAgICAgICAgIHNpemU6IDIsXHJcbiAgICAgICAgICAgICAgICB1cGxvYWRGdW5jdGlvbjogdGhpcy51cGxvYWRWZXJ0aWNlcyxcclxuICAgICAgICAgICAgICAgIG9mZnNldDogMCxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgLy8gcG9zaXRpb25EYXRhXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZU5hbWU6ICdhUG9zaXRpb25Db29yZCcsXHJcbiAgICAgICAgICAgICAgICBzaXplOiAyLFxyXG4gICAgICAgICAgICAgICAgdXBsb2FkRnVuY3Rpb246IHRoaXMudXBsb2FkUG9zaXRpb24sXHJcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IDAsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIC8vIHJvdGF0aW9uRGF0YVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVOYW1lOiAnYVJvdGF0aW9uJyxcclxuICAgICAgICAgICAgICAgIHNpemU6IDEsXHJcbiAgICAgICAgICAgICAgICB1cGxvYWRGdW5jdGlvbjogdGhpcy51cGxvYWRSb3RhdGlvbixcclxuICAgICAgICAgICAgICAgIG9mZnNldDogMCxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgLy8gdXZzRGF0YVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVOYW1lOiAnYVRleHR1cmVDb29yZCcsXHJcbiAgICAgICAgICAgICAgICBzaXplOiAyLFxyXG4gICAgICAgICAgICAgICAgdXBsb2FkRnVuY3Rpb246IHRoaXMudXBsb2FkVXZzLFxyXG4gICAgICAgICAgICAgICAgb2Zmc2V0OiAwLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAvLyB0aW50RGF0YVxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVOYW1lOiAnYUNvbG9yJyxcclxuICAgICAgICAgICAgICAgIHNpemU6IDEsXHJcbiAgICAgICAgICAgICAgICB0eXBlOiBXZWJHTFNldHRpbmdzXzEuV2ViR0xTZXR0aW5ncy5UWVBFUy5VTlNJR05FRF9CWVRFLFxyXG4gICAgICAgICAgICAgICAgdXBsb2FkRnVuY3Rpb246IHRoaXMudXBsb2FkVGludCxcclxuICAgICAgICAgICAgICAgIG9mZnNldDogMCxcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIF07XHJcbiAgICAgICAgdGhpcy5zaGFkZXIgPSBTaGFkZXJfMS5TaGFkZXIuZnJvbShQYXJ0aWNsZVJlbmRlcmVyLnZlcnRleCQyLCBQYXJ0aWNsZVJlbmRlcmVyLmZyYWdtZW50JDEsIHt9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVuZGVycyB0aGUgcGFydGljbGUgY29udGFpbmVyIG9iamVjdC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1BJWEkuUGFydGljbGVDb250YWluZXJ9IGNvbnRhaW5lciAtIFRoZSBjb250YWluZXIgdG8gcmVuZGVyIHVzaW5nIHRoaXMgUGFydGljbGVSZW5kZXJlclxyXG4gICAgICovXHJcbiAgICByZW5kZXIoY29udGFpbmVyKSB7XHJcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gY29udGFpbmVyLmNoaWxkcmVuO1xyXG4gICAgICAgIHZhciBtYXhTaXplID0gY29udGFpbmVyLl9tYXhTaXplO1xyXG4gICAgICAgIHZhciBiYXRjaFNpemUgPSBjb250YWluZXIuX2JhdGNoU2l6ZTtcclxuICAgICAgICB2YXIgcmVuZGVyZXIgPSB0aGlzLnJlbmRlcmVyO1xyXG4gICAgICAgIHZhciB0b3RhbENoaWxkcmVuID0gY2hpbGRyZW4ubGVuZ3RoO1xyXG4gICAgICAgIGlmICh0b3RhbENoaWxkcmVuID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodG90YWxDaGlsZHJlbiA+IG1heFNpemUpIHtcclxuICAgICAgICAgICAgdG90YWxDaGlsZHJlbiA9IG1heFNpemU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBidWZmZXJzID0gY29udGFpbmVyLl9idWZmZXJzO1xyXG4gICAgICAgIGlmICghYnVmZmVycykge1xyXG4gICAgICAgICAgICBidWZmZXJzID0gY29udGFpbmVyLl9idWZmZXJzID0gdGhpcy5nZW5lcmF0ZUJ1ZmZlcnMoY29udGFpbmVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGJhc2VUZXh0dXJlID0gY2hpbGRyZW5bMF0uX3RleHR1cmUuYmFzZVRleHR1cmU7XHJcbiAgICAgICAgLy8gaWYgdGhlIHV2cyBoYXZlIG5vdCB1cGRhdGVkIHRoZW4gbm8gcG9pbnQgcmVuZGVyaW5nIGp1c3QgeWV0IVxyXG4gICAgICAgIHRoaXMucmVuZGVyZXIuc3RhdGUuc2V0QmxlbmRNb2RlKEJsZW5kTW9kZXNTZXR0aW5nc18xLkJsZW5kTW9kZXNTZXR0aW5ncy5jb3JyZWN0QmxlbmRNb2RlKGNvbnRhaW5lci5ibGVuZE1vZGUsIGJhc2VUZXh0dXJlLnByZW11bHRpcGx5QWxwaGEpKTtcclxuICAgICAgICB2YXIgZ2wgPSByZW5kZXJlci5nbDtcclxuICAgICAgICB2YXIgbSA9IGNvbnRhaW5lci53b3JsZFRyYW5zZm9ybS5jb3B5VG8odGhpcy50ZW1wTWF0cml4KTtcclxuICAgICAgICBtLnByZXBlbmQocmVuZGVyZXIuZ2xvYmFsVW5pZm9ybXMudW5pZm9ybXMucHJvamVjdGlvbk1hdHJpeCk7XHJcbiAgICAgICAgdGhpcy5zaGFkZXIudW5pZm9ybXMudHJhbnNsYXRpb25NYXRyaXggPSBtLnRvQXJyYXkodHJ1ZSk7XHJcbiAgICAgICAgdGhpcy5zaGFkZXIudW5pZm9ybXMudUNvbG9yID0gQ29sb3JTZXR0aW5nc18xLkNvbG9yU2V0dGluZ3MucHJlbXVsdGlwbHlSZ2JhKGNvbnRhaW5lci50aW50UmdiLCBjb250YWluZXIud29ybGRBbHBoYSwgdGhpcy5zaGFkZXIudW5pZm9ybXMudUNvbG9yLCBiYXNlVGV4dHVyZS5wcmVtdWx0aXBseUFscGhhKTtcclxuICAgICAgICB0aGlzLnNoYWRlci51bmlmb3Jtcy51U2FtcGxlciA9IGJhc2VUZXh0dXJlO1xyXG4gICAgICAgIHRoaXMucmVuZGVyZXIuc2hhZGVyLmJpbmQodGhpcy5zaGFkZXIpO1xyXG4gICAgICAgIHZhciB1cGRhdGVTdGF0aWMgPSBmYWxzZTtcclxuICAgICAgICAvLyBub3cgbGV0cyB1cGxvYWQgYW5kIHJlbmRlciB0aGUgYnVmZmVycy4uXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGogPSAwOyBpIDwgdG90YWxDaGlsZHJlbjsgaSArPSBiYXRjaFNpemUsIGogKz0gMSkge1xyXG4gICAgICAgICAgICB2YXIgYW1vdW50ID0gKHRvdGFsQ2hpbGRyZW4gLSBpKTtcclxuICAgICAgICAgICAgaWYgKGFtb3VudCA+IGJhdGNoU2l6ZSkge1xyXG4gICAgICAgICAgICAgICAgYW1vdW50ID0gYmF0Y2hTaXplO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChqID49IGJ1ZmZlcnMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWNvbnRhaW5lci5hdXRvUmVzaXplKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBidWZmZXJzLnB1c2godGhpcy5fZ2VuZXJhdGVPbmVNb3JlQnVmZmVyKGNvbnRhaW5lcikpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBidWZmZXIgPSBidWZmZXJzW2pdO1xyXG4gICAgICAgICAgICAvLyB3ZSBhbHdheXMgdXBsb2FkIHRoZSBkeW5hbWljXHJcbiAgICAgICAgICAgIGJ1ZmZlci51cGxvYWREeW5hbWljKGNoaWxkcmVuLCBpLCBhbW91bnQpO1xyXG4gICAgICAgICAgICB2YXIgYmlkID0gY29udGFpbmVyLl9idWZmZXJVcGRhdGVJRHNbal0gfHwgMDtcclxuICAgICAgICAgICAgdXBkYXRlU3RhdGljID0gdXBkYXRlU3RhdGljIHx8IChidWZmZXIuX3VwZGF0ZUlEIDwgYmlkKTtcclxuICAgICAgICAgICAgLy8gd2Ugb25seSB1cGxvYWQgdGhlIHN0YXRpYyBjb250ZW50IHdoZW4gd2UgaGF2ZSB0byFcclxuICAgICAgICAgICAgaWYgKHVwZGF0ZVN0YXRpYykge1xyXG4gICAgICAgICAgICAgICAgYnVmZmVyLl91cGRhdGVJRCA9IGNvbnRhaW5lci5fdXBkYXRlSUQ7XHJcbiAgICAgICAgICAgICAgICBidWZmZXIudXBsb2FkU3RhdGljKGNoaWxkcmVuLCBpLCBhbW91bnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGJpbmQgdGhlIGJ1ZmZlclxyXG4gICAgICAgICAgICByZW5kZXJlci5nZW9tZXRyeS5iaW5kKGJ1ZmZlci5nZW9tZXRyeSk7XHJcbiAgICAgICAgICAgIGdsLmRyYXdFbGVtZW50cyhnbC5UUklBTkdMRVMsIGFtb3VudCAqIDYsIGdsLlVOU0lHTkVEX1NIT1JULCAwKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgb25lIHBhcnRpY2xlIGJ1ZmZlciBmb3IgZWFjaCBjaGlsZCBpbiB0aGUgY29udGFpbmVyIHdlIHdhbnQgdG8gcmVuZGVyIGFuZCB1cGRhdGVzIGludGVybmFsIHByb3BlcnRpZXNcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1BJWEkuUGFydGljbGVDb250YWluZXJ9IGNvbnRhaW5lciAtIFRoZSBjb250YWluZXIgdG8gcmVuZGVyIHVzaW5nIHRoaXMgUGFydGljbGVSZW5kZXJlclxyXG4gICAgICogQHJldHVybiB7UElYSS5QYXJ0aWNsZUJ1ZmZlcltdfSBUaGUgYnVmZmVyc1xyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgZ2VuZXJhdGVCdWZmZXJzKGNvbnRhaW5lcikge1xyXG4gICAgICAgIHZhciBidWZmZXJzID0gW107XHJcbiAgICAgICAgdmFyIHNpemUgPSBjb250YWluZXIuX21heFNpemU7XHJcbiAgICAgICAgdmFyIGJhdGNoU2l6ZSA9IGNvbnRhaW5lci5fYmF0Y2hTaXplO1xyXG4gICAgICAgIHZhciBkeW5hbWljUHJvcGVydHlGbGFncyA9IGNvbnRhaW5lci5fcHJvcGVydGllcztcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7IGkgKz0gYmF0Y2hTaXplKSB7XHJcbiAgICAgICAgICAgIGJ1ZmZlcnMucHVzaChuZXcgUGFydGljbGVCdWZmZXJfMS5QYXJ0aWNsZUJ1ZmZlcih0aGlzLnByb3BlcnRpZXMsIGR5bmFtaWNQcm9wZXJ0eUZsYWdzLCBiYXRjaFNpemUpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGJ1ZmZlcnM7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgb25lIG1vcmUgcGFydGljbGUgYnVmZmVyLCBiZWNhdXNlIGNvbnRhaW5lciBoYXMgYXV0b1Jlc2l6ZSBmZWF0dXJlXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtQSVhJLlBhcnRpY2xlQ29udGFpbmVyfSBjb250YWluZXIgLSBUaGUgY29udGFpbmVyIHRvIHJlbmRlciB1c2luZyB0aGlzIFBhcnRpY2xlUmVuZGVyZXJcclxuICAgICAqIEByZXR1cm4ge1BJWEkuUGFydGljbGVCdWZmZXJ9IGdlbmVyYXRlZCBidWZmZXJcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIF9nZW5lcmF0ZU9uZU1vcmVCdWZmZXIoY29udGFpbmVyKSB7XHJcbiAgICAgICAgdmFyIGJhdGNoU2l6ZSA9IGNvbnRhaW5lci5fYmF0Y2hTaXplO1xyXG4gICAgICAgIHZhciBkeW5hbWljUHJvcGVydHlGbGFncyA9IGNvbnRhaW5lci5fcHJvcGVydGllcztcclxuICAgICAgICByZXR1cm4gbmV3IFBhcnRpY2xlQnVmZmVyXzEuUGFydGljbGVCdWZmZXIodGhpcy5wcm9wZXJ0aWVzLCBkeW5hbWljUHJvcGVydHlGbGFncywgYmF0Y2hTaXplKTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogVXBsb2FkcyB0aGUgdmVydGljZXMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtQSVhJLkRpc3BsYXlPYmplY3RbXX0gY2hpbGRyZW4gLSB0aGUgYXJyYXkgb2YgZGlzcGxheSBvYmplY3RzIHRvIHJlbmRlclxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0SW5kZXggLSB0aGUgaW5kZXggdG8gc3RhcnQgZnJvbSBpbiB0aGUgY2hpbGRyZW4gYXJyYXlcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhbW91bnQgLSB0aGUgYW1vdW50IG9mIGNoaWxkcmVuIHRoYXQgd2lsbCBoYXZlIHRoZWlyIHZlcnRpY2VzIHVwbG9hZGVkXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcltdfSBhcnJheSAtIFRoZSB2ZXJ0aWNlcyB0byB1cGxvYWQuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIC0gU3RyaWRlIHRvIHVzZSBmb3IgaXRlcmF0aW9uLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCAtIE9mZnNldCB0byBzdGFydCBhdC5cclxuICAgICAqL1xyXG4gICAgdXBsb2FkVmVydGljZXMoY2hpbGRyZW4sIHN0YXJ0SW5kZXgsIGFtb3VudCwgYXJyYXksIHN0cmlkZSwgb2Zmc2V0KSB7XHJcbiAgICAgICAgdmFyIHcwID0gMDtcclxuICAgICAgICB2YXIgdzEgPSAwO1xyXG4gICAgICAgIHZhciBoMCA9IDA7XHJcbiAgICAgICAgdmFyIGgxID0gMDtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFtb3VudDsgKytpKSB7XHJcbiAgICAgICAgICAgIHZhciBzcHJpdGUgPSBjaGlsZHJlbltzdGFydEluZGV4ICsgaV07XHJcbiAgICAgICAgICAgIHZhciB0ZXh0dXJlID0gc3ByaXRlLl90ZXh0dXJlO1xyXG4gICAgICAgICAgICB2YXIgc3ggPSBzcHJpdGUuc2NhbGUueDtcclxuICAgICAgICAgICAgdmFyIHN5ID0gc3ByaXRlLnNjYWxlLnk7XHJcbiAgICAgICAgICAgIHZhciB0cmltID0gdGV4dHVyZS50cmltO1xyXG4gICAgICAgICAgICB2YXIgb3JpZyA9IHRleHR1cmUub3JpZztcclxuICAgICAgICAgICAgaWYgKHRyaW0pIHtcclxuICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBzcHJpdGUgaXMgdHJpbW1lZCBhbmQgaXMgbm90IGEgdGlsaW5nc3ByaXRlIHRoZW4gd2UgbmVlZCB0byBhZGQgdGhlXHJcbiAgICAgICAgICAgICAgICAvLyBleHRyYSBzcGFjZSBiZWZvcmUgdHJhbnNmb3JtaW5nIHRoZSBzcHJpdGUgY29vcmRzLi5cclxuICAgICAgICAgICAgICAgIHcxID0gdHJpbS54IC0gKHNwcml0ZS5hbmNob3IueCAqIG9yaWcud2lkdGgpO1xyXG4gICAgICAgICAgICAgICAgdzAgPSB3MSArIHRyaW0ud2lkdGg7XHJcbiAgICAgICAgICAgICAgICBoMSA9IHRyaW0ueSAtIChzcHJpdGUuYW5jaG9yLnkgKiBvcmlnLmhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICBoMCA9IGgxICsgdHJpbS5oZWlnaHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB3MCA9IChvcmlnLndpZHRoKSAqICgxIC0gc3ByaXRlLmFuY2hvci54KTtcclxuICAgICAgICAgICAgICAgIHcxID0gKG9yaWcud2lkdGgpICogLXNwcml0ZS5hbmNob3IueDtcclxuICAgICAgICAgICAgICAgIGgwID0gb3JpZy5oZWlnaHQgKiAoMSAtIHNwcml0ZS5hbmNob3IueSk7XHJcbiAgICAgICAgICAgICAgICBoMSA9IG9yaWcuaGVpZ2h0ICogLXNwcml0ZS5hbmNob3IueTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBhcnJheVtvZmZzZXRdID0gdzEgKiBzeDtcclxuICAgICAgICAgICAgYXJyYXlbb2Zmc2V0ICsgMV0gPSBoMSAqIHN5O1xyXG4gICAgICAgICAgICBhcnJheVtvZmZzZXQgKyBzdHJpZGVdID0gdzAgKiBzeDtcclxuICAgICAgICAgICAgYXJyYXlbb2Zmc2V0ICsgc3RyaWRlICsgMV0gPSBoMSAqIHN5O1xyXG4gICAgICAgICAgICBhcnJheVtvZmZzZXQgKyAoc3RyaWRlICogMildID0gdzAgKiBzeDtcclxuICAgICAgICAgICAgYXJyYXlbb2Zmc2V0ICsgKHN0cmlkZSAqIDIpICsgMV0gPSBoMCAqIHN5O1xyXG4gICAgICAgICAgICBhcnJheVtvZmZzZXQgKyAoc3RyaWRlICogMyldID0gdzEgKiBzeDtcclxuICAgICAgICAgICAgYXJyYXlbb2Zmc2V0ICsgKHN0cmlkZSAqIDMpICsgMV0gPSBoMCAqIHN5O1xyXG4gICAgICAgICAgICBvZmZzZXQgKz0gc3RyaWRlICogNDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFVwbG9hZHMgdGhlIHBvc2l0aW9uLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7UElYSS5EaXNwbGF5T2JqZWN0W119IGNoaWxkcmVuIC0gdGhlIGFycmF5IG9mIGRpc3BsYXkgb2JqZWN0cyB0byByZW5kZXJcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydEluZGV4IC0gdGhlIGluZGV4IHRvIHN0YXJ0IGZyb20gaW4gdGhlIGNoaWxkcmVuIGFycmF5XHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYW1vdW50IC0gdGhlIGFtb3VudCBvZiBjaGlsZHJlbiB0aGF0IHdpbGwgaGF2ZSB0aGVpciBwb3NpdGlvbnMgdXBsb2FkZWRcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyW119IGFycmF5IC0gVGhlIHZlcnRpY2VzIHRvIHVwbG9hZC5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgLSBTdHJpZGUgdG8gdXNlIGZvciBpdGVyYXRpb24uXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IC0gT2Zmc2V0IHRvIHN0YXJ0IGF0LlxyXG4gICAgICovXHJcbiAgICB1cGxvYWRQb3NpdGlvbihjaGlsZHJlbiwgc3RhcnRJbmRleCwgYW1vdW50LCBhcnJheSwgc3RyaWRlLCBvZmZzZXQpIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFtb3VudDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBzcHJpdGVQb3NpdGlvbiA9IGNoaWxkcmVuW3N0YXJ0SW5kZXggKyBpXS5wb3NpdGlvbjtcclxuICAgICAgICAgICAgYXJyYXlbb2Zmc2V0XSA9IHNwcml0ZVBvc2l0aW9uLng7XHJcbiAgICAgICAgICAgIGFycmF5W29mZnNldCArIDFdID0gc3ByaXRlUG9zaXRpb24ueTtcclxuICAgICAgICAgICAgYXJyYXlbb2Zmc2V0ICsgc3RyaWRlXSA9IHNwcml0ZVBvc2l0aW9uLng7XHJcbiAgICAgICAgICAgIGFycmF5W29mZnNldCArIHN0cmlkZSArIDFdID0gc3ByaXRlUG9zaXRpb24ueTtcclxuICAgICAgICAgICAgYXJyYXlbb2Zmc2V0ICsgKHN0cmlkZSAqIDIpXSA9IHNwcml0ZVBvc2l0aW9uLng7XHJcbiAgICAgICAgICAgIGFycmF5W29mZnNldCArIChzdHJpZGUgKiAyKSArIDFdID0gc3ByaXRlUG9zaXRpb24ueTtcclxuICAgICAgICAgICAgYXJyYXlbb2Zmc2V0ICsgKHN0cmlkZSAqIDMpXSA9IHNwcml0ZVBvc2l0aW9uLng7XHJcbiAgICAgICAgICAgIGFycmF5W29mZnNldCArIChzdHJpZGUgKiAzKSArIDFdID0gc3ByaXRlUG9zaXRpb24ueTtcclxuICAgICAgICAgICAgb2Zmc2V0ICs9IHN0cmlkZSAqIDQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBVcGxvYWRzIHRoZSByb3RpYXRpb24uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtQSVhJLkRpc3BsYXlPYmplY3RbXX0gY2hpbGRyZW4gLSB0aGUgYXJyYXkgb2YgZGlzcGxheSBvYmplY3RzIHRvIHJlbmRlclxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0SW5kZXggLSB0aGUgaW5kZXggdG8gc3RhcnQgZnJvbSBpbiB0aGUgY2hpbGRyZW4gYXJyYXlcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhbW91bnQgLSB0aGUgYW1vdW50IG9mIGNoaWxkcmVuIHRoYXQgd2lsbCBoYXZlIHRoZWlyIHJvdGF0aW9uIHVwbG9hZGVkXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcltdfSBhcnJheSAtIFRoZSB2ZXJ0aWNlcyB0byB1cGxvYWQuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIC0gU3RyaWRlIHRvIHVzZSBmb3IgaXRlcmF0aW9uLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCAtIE9mZnNldCB0byBzdGFydCBhdC5cclxuICAgICAqL1xyXG4gICAgdXBsb2FkUm90YXRpb24oY2hpbGRyZW4sIHN0YXJ0SW5kZXgsIGFtb3VudCwgYXJyYXksIHN0cmlkZSwgb2Zmc2V0KSB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbW91bnQ7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgc3ByaXRlUm90YXRpb24gPSBjaGlsZHJlbltzdGFydEluZGV4ICsgaV0ucm90YXRpb247XHJcbiAgICAgICAgICAgIGFycmF5W29mZnNldF0gPSBzcHJpdGVSb3RhdGlvbjtcclxuICAgICAgICAgICAgYXJyYXlbb2Zmc2V0ICsgc3RyaWRlXSA9IHNwcml0ZVJvdGF0aW9uO1xyXG4gICAgICAgICAgICBhcnJheVtvZmZzZXQgKyAoc3RyaWRlICogMildID0gc3ByaXRlUm90YXRpb247XHJcbiAgICAgICAgICAgIGFycmF5W29mZnNldCArIChzdHJpZGUgKiAzKV0gPSBzcHJpdGVSb3RhdGlvbjtcclxuICAgICAgICAgICAgb2Zmc2V0ICs9IHN0cmlkZSAqIDQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBVcGxvYWRzIHRoZSBVdnNcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1BJWEkuRGlzcGxheU9iamVjdFtdfSBjaGlsZHJlbiAtIHRoZSBhcnJheSBvZiBkaXNwbGF5IG9iamVjdHMgdG8gcmVuZGVyXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnRJbmRleCAtIHRoZSBpbmRleCB0byBzdGFydCBmcm9tIGluIHRoZSBjaGlsZHJlbiBhcnJheVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGFtb3VudCAtIHRoZSBhbW91bnQgb2YgY2hpbGRyZW4gdGhhdCB3aWxsIGhhdmUgdGhlaXIgcm90YXRpb24gdXBsb2FkZWRcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyW119IGFycmF5IC0gVGhlIHZlcnRpY2VzIHRvIHVwbG9hZC5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgLSBTdHJpZGUgdG8gdXNlIGZvciBpdGVyYXRpb24uXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IC0gT2Zmc2V0IHRvIHN0YXJ0IGF0LlxyXG4gICAgICovXHJcbiAgICB1cGxvYWRVdnMoY2hpbGRyZW4sIHN0YXJ0SW5kZXgsIGFtb3VudCwgYXJyYXksIHN0cmlkZSwgb2Zmc2V0KSB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbW91bnQ7ICsraSkge1xyXG4gICAgICAgICAgICB2YXIgdGV4dHVyZVV2cyA9IGNoaWxkcmVuW3N0YXJ0SW5kZXggKyBpXS5fdGV4dHVyZS5fdXZzO1xyXG4gICAgICAgICAgICBpZiAodGV4dHVyZVV2cykge1xyXG4gICAgICAgICAgICAgICAgYXJyYXlbb2Zmc2V0XSA9IHRleHR1cmVVdnMueDA7XHJcbiAgICAgICAgICAgICAgICBhcnJheVtvZmZzZXQgKyAxXSA9IHRleHR1cmVVdnMueTA7XHJcbiAgICAgICAgICAgICAgICBhcnJheVtvZmZzZXQgKyBzdHJpZGVdID0gdGV4dHVyZVV2cy54MTtcclxuICAgICAgICAgICAgICAgIGFycmF5W29mZnNldCArIHN0cmlkZSArIDFdID0gdGV4dHVyZVV2cy55MTtcclxuICAgICAgICAgICAgICAgIGFycmF5W29mZnNldCArIChzdHJpZGUgKiAyKV0gPSB0ZXh0dXJlVXZzLngyO1xyXG4gICAgICAgICAgICAgICAgYXJyYXlbb2Zmc2V0ICsgKHN0cmlkZSAqIDIpICsgMV0gPSB0ZXh0dXJlVXZzLnkyO1xyXG4gICAgICAgICAgICAgICAgYXJyYXlbb2Zmc2V0ICsgKHN0cmlkZSAqIDMpXSA9IHRleHR1cmVVdnMueDM7XHJcbiAgICAgICAgICAgICAgICBhcnJheVtvZmZzZXQgKyAoc3RyaWRlICogMykgKyAxXSA9IHRleHR1cmVVdnMueTM7XHJcbiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gc3RyaWRlICogNDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIFRPRE8geW91IGtub3cgdGhpcyBjYW4gYmUgZWFzaWVyIVxyXG4gICAgICAgICAgICAgICAgYXJyYXlbb2Zmc2V0XSA9IDA7XHJcbiAgICAgICAgICAgICAgICBhcnJheVtvZmZzZXQgKyAxXSA9IDA7XHJcbiAgICAgICAgICAgICAgICBhcnJheVtvZmZzZXQgKyBzdHJpZGVdID0gMDtcclxuICAgICAgICAgICAgICAgIGFycmF5W29mZnNldCArIHN0cmlkZSArIDFdID0gMDtcclxuICAgICAgICAgICAgICAgIGFycmF5W29mZnNldCArIChzdHJpZGUgKiAyKV0gPSAwO1xyXG4gICAgICAgICAgICAgICAgYXJyYXlbb2Zmc2V0ICsgKHN0cmlkZSAqIDIpICsgMV0gPSAwO1xyXG4gICAgICAgICAgICAgICAgYXJyYXlbb2Zmc2V0ICsgKHN0cmlkZSAqIDMpXSA9IDA7XHJcbiAgICAgICAgICAgICAgICBhcnJheVtvZmZzZXQgKyAoc3RyaWRlICogMykgKyAxXSA9IDA7XHJcbiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gc3RyaWRlICogNDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogVXBsb2FkcyB0aGUgdGludC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1BJWEkuRGlzcGxheU9iamVjdFtdfSBjaGlsZHJlbiAtIHRoZSBhcnJheSBvZiBkaXNwbGF5IG9iamVjdHMgdG8gcmVuZGVyXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnRJbmRleCAtIHRoZSBpbmRleCB0byBzdGFydCBmcm9tIGluIHRoZSBjaGlsZHJlbiBhcnJheVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGFtb3VudCAtIHRoZSBhbW91bnQgb2YgY2hpbGRyZW4gdGhhdCB3aWxsIGhhdmUgdGhlaXIgcm90YXRpb24gdXBsb2FkZWRcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyW119IGFycmF5IC0gVGhlIHZlcnRpY2VzIHRvIHVwbG9hZC5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgLSBTdHJpZGUgdG8gdXNlIGZvciBpdGVyYXRpb24uXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IC0gT2Zmc2V0IHRvIHN0YXJ0IGF0LlxyXG4gICAgICovXHJcbiAgICB1cGxvYWRUaW50KGNoaWxkcmVuLCBzdGFydEluZGV4LCBhbW91bnQsIGFycmF5LCBzdHJpZGUsIG9mZnNldCkge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYW1vdW50OyArK2kpIHtcclxuICAgICAgICAgICAgdmFyIHNwcml0ZSA9IGNoaWxkcmVuW3N0YXJ0SW5kZXggKyBpXTtcclxuICAgICAgICAgICAgdmFyIHByZW11bHRpcGxpZWQgPSBzcHJpdGUuX3RleHR1cmUuYmFzZVRleHR1cmUucHJlbXVsdGlwbHlBbHBoYTtcclxuICAgICAgICAgICAgdmFyIGFscGhhID0gc3ByaXRlLmFscGhhO1xyXG4gICAgICAgICAgICAvLyB3ZSBkb250IGNhbGwgZXh0cmEgZnVuY3Rpb24gaWYgYWxwaGEgaXMgMS4wLCB0aGF0J3MgZmFzdGVyXHJcbiAgICAgICAgICAgIHZhciBhcmdiID0gYWxwaGEgPCAxLjAgJiYgcHJlbXVsdGlwbGllZCA/IENvbG9yU2V0dGluZ3NfMS5Db2xvclNldHRpbmdzLnByZW11bHRpcGx5VGludChzcHJpdGUuX3RpbnRSR0IsIGFscGhhKVxyXG4gICAgICAgICAgICAgICAgOiBzcHJpdGUuX3RpbnRSR0IgKyAoYWxwaGEgKiAyNTUgPDwgMjQpO1xyXG4gICAgICAgICAgICBhcnJheVtvZmZzZXRdID0gYXJnYjtcclxuICAgICAgICAgICAgYXJyYXlbb2Zmc2V0ICsgc3RyaWRlXSA9IGFyZ2I7XHJcbiAgICAgICAgICAgIGFycmF5W29mZnNldCArIChzdHJpZGUgKiAyKV0gPSBhcmdiO1xyXG4gICAgICAgICAgICBhcnJheVtvZmZzZXQgKyAoc3RyaWRlICogMyldID0gYXJnYjtcclxuICAgICAgICAgICAgb2Zmc2V0ICs9IHN0cmlkZSAqIDQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBEZXN0cm95cyB0aGUgUGFydGljbGVSZW5kZXJlci5cclxuICAgICAqL1xyXG4gICAgZGVzdHJveSgpIHtcclxuICAgICAgICBzdXBlci5kZXN0cm95KCk7XHJcbiAgICAgICAgaWYgKHRoaXMuc2hhZGVyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2hhZGVyLmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgdGhpcy5zaGFkZXIgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnRlbXBNYXRyaXggPSBudWxsO1xyXG4gICAgfVxyXG4gICAgO1xyXG59XHJcblBhcnRpY2xlUmVuZGVyZXIudmVydGV4JDIgPSBcImF0dHJpYnV0ZSB2ZWMyIGFWZXJ0ZXhQb3NpdGlvbjtcXHJcXG5hdHRyaWJ1dGUgdmVjMiBhVGV4dHVyZUNvb3JkO1xcclxcbmF0dHJpYnV0ZSB2ZWM0IGFDb2xvcjtcXHJcXG5cXHJcXG5hdHRyaWJ1dGUgdmVjMiBhUG9zaXRpb25Db29yZDtcXHJcXG5hdHRyaWJ1dGUgZmxvYXQgYVJvdGF0aW9uO1xcclxcblxcclxcbnVuaWZvcm0gbWF0MyB0cmFuc2xhdGlvbk1hdHJpeDtcXHJcXG51bmlmb3JtIHZlYzQgdUNvbG9yO1xcclxcblxcclxcbnZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xcclxcbnZhcnlpbmcgdmVjNCB2Q29sb3I7XFxyXFxuXFxyXFxudm9pZCBtYWluKHZvaWQpe1xcclxcbiAgICBmbG9hdCB4ID0gKGFWZXJ0ZXhQb3NpdGlvbi54KSAqIGNvcyhhUm90YXRpb24pIC0gKGFWZXJ0ZXhQb3NpdGlvbi55KSAqIHNpbihhUm90YXRpb24pO1xcclxcbiAgICBmbG9hdCB5ID0gKGFWZXJ0ZXhQb3NpdGlvbi54KSAqIHNpbihhUm90YXRpb24pICsgKGFWZXJ0ZXhQb3NpdGlvbi55KSAqIGNvcyhhUm90YXRpb24pO1xcclxcblxcclxcbiAgICB2ZWMyIHYgPSB2ZWMyKHgsIHkpO1xcclxcbiAgICB2ID0gdiArIGFQb3NpdGlvbkNvb3JkO1xcclxcblxcclxcbiAgICBnbF9Qb3NpdGlvbiA9IHZlYzQoKHRyYW5zbGF0aW9uTWF0cml4ICogdmVjMyh2LCAxLjApKS54eSwgMC4wLCAxLjApO1xcclxcblxcclxcbiAgICB2VGV4dHVyZUNvb3JkID0gYVRleHR1cmVDb29yZDtcXHJcXG4gICAgdkNvbG9yID0gYUNvbG9yICogdUNvbG9yO1xcclxcbn1cXHJcXG5cIjtcclxuUGFydGljbGVSZW5kZXJlci5mcmFnbWVudCQxID0gXCJ2YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXHJcXG52YXJ5aW5nIHZlYzQgdkNvbG9yO1xcclxcblxcclxcbnVuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyO1xcclxcblxcclxcbnZvaWQgbWFpbih2b2lkKXtcXHJcXG4gICAgdmVjNCBjb2xvciA9IHRleHR1cmUyRCh1U2FtcGxlciwgdlRleHR1cmVDb29yZCkgKiB2Q29sb3I7XFxyXFxuICAgIGdsX0ZyYWdDb2xvciA9IGNvbG9yO1xcclxcbn1cIjtcclxuZXhwb3J0cy5QYXJ0aWNsZVJlbmRlcmVyID0gUGFydGljbGVSZW5kZXJlcjtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY2xhc3MgUG9pbnQge1xyXG4gICAgY29uc3RydWN0b3IoeCA9IDAsIHkgPSAwKSB7XHJcbiAgICAgICAgaWYgKHggPT09IHZvaWQgMCkge1xyXG4gICAgICAgICAgICB4ID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHkgPT09IHZvaWQgMCkge1xyXG4gICAgICAgICAgICB5ID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICAgICAqIEBkZWZhdWx0IDBcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnggPSB4O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAgICAgKiBAZGVmYXVsdCAwXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy55ID0geTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgcG9pbnQgdG8gYSBuZXcgeCBhbmQgeSBwb3NpdGlvbi5cclxuICAgICAqIElmIHkgaXMgb21pdHRlZCwgYm90aCB4IGFuZCB5IHdpbGwgYmUgc2V0IHRvIHguXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt4PTBdIC0gcG9zaXRpb24gb2YgdGhlIHBvaW50IG9uIHRoZSB4IGF4aXNcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbeT0wXSAtIHBvc2l0aW9uIG9mIHRoZSBwb2ludCBvbiB0aGUgeSBheGlzXHJcbiAgICAgKi9cclxuICAgIHNldCh4ID0gMCwgeSA9IDApIHtcclxuICAgICAgICB0aGlzLnggPSB4IHx8IDA7XHJcbiAgICAgICAgdGhpcy55ID0geSB8fCAoKHkgIT09IDApID8gdGhpcy54IDogMCk7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gcG9pbnQgaXMgZXF1YWwgdG8gdGhpcyBwb2ludFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7UElYSS5JUG9pbnR9IHAgLSBUaGUgcG9pbnQgdG8gY2hlY2tcclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBXaGV0aGVyIHRoZSBnaXZlbiBwb2ludCBlcXVhbCB0byB0aGlzIHBvaW50XHJcbiAgICAgKi9cclxuICAgIGVxdWFscyhwKSB7XHJcbiAgICAgICAgcmV0dXJuIChwLnggPT09IHRoaXMueCkgJiYgKHAueSA9PT0gdGhpcy55KTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQ29waWVzIHggYW5kIHkgaW50byB0aGUgZ2l2ZW4gcG9pbnRcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1BJWEkuSVBvaW50fSBwIC0gVGhlIHBvaW50IHRvIGNvcHkuXHJcbiAgICAgKiBAcmV0dXJucyB7UElYSS5JUG9pbnR9IEdpdmVuIHBvaW50IHdpdGggdmFsdWVzIHVwZGF0ZWRcclxuICAgICAqL1xyXG4gICAgY29weVRvKHApIHtcclxuICAgICAgICBwLnNldCh0aGlzLngsIHRoaXMueSk7XHJcbiAgICAgICAgcmV0dXJuIHA7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIENvcGllcyB4IGFuZCB5IGZyb20gdGhlIGdpdmVuIHBvaW50XHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtQSVhJLklQb2ludH0gcCAtIFRoZSBwb2ludCB0byBjb3B5IGZyb21cclxuICAgICAqIEByZXR1cm5zIHtQSVhJLklQb2ludH0gUmV0dXJucyBpdHNlbGYuXHJcbiAgICAgKi9cclxuICAgIGNvcHlGcm9tKHApIHtcclxuICAgICAgICB0aGlzLnNldChwLngsIHAueSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBjbG9uZSBvZiB0aGlzIHBvaW50XHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiB7UElYSS5Qb2ludH0gYSBjb3B5IG9mIHRoZSBwb2ludFxyXG4gICAgICovXHJcbiAgICBjbG9uZSgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFBvaW50KHRoaXMueCwgdGhpcy55KTtcclxuICAgIH1cclxuICAgIDtcclxufVxyXG5leHBvcnRzLlBvaW50ID0gUG9pbnQ7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IFBvaW50XzEgPSByZXF1aXJlKFwiLi9Qb2ludFwiKTtcclxuY29uc3QgU2hhcGVTZXR0aW5nc18xID0gcmVxdWlyZShcIi4vU2hhcGVTZXR0aW5nc1wiKTtcclxuY2xhc3MgUG9seWdvbiB7XHJcbiAgICBjb25zdHJ1Y3RvcihhcmcgPSBudWxsKSB7XHJcbiAgICAgICAgdmFyIGFyZ3VtZW50cyQxID0gYXJndW1lbnRzO1xyXG4gICAgICAgIHZhciBwb2ludHMgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcclxuICAgICAgICB3aGlsZSAobGVuLS0pIHtcclxuICAgICAgICAgICAgcG9pbnRzW2xlbl0gPSBhcmd1bWVudHMkMVtsZW5dO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwb2ludHNbMF0pKSB7XHJcbiAgICAgICAgICAgIHBvaW50cyA9IHBvaW50c1swXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gaWYgdGhpcyBpcyBhbiBhcnJheSBvZiBwb2ludHMsIGNvbnZlcnQgaXQgdG8gYSBmbGF0IGFycmF5IG9mIG51bWJlcnNcclxuICAgICAgICBpZiAocG9pbnRzWzBdIGluc3RhbmNlb2YgUG9pbnRfMS5Qb2ludCkge1xyXG4gICAgICAgICAgICB2YXIgcCA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaWwgPSBwb2ludHMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgcC5wdXNoKHBvaW50c1tpXS54LCBwb2ludHNbaV0ueSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcG9pbnRzID0gcDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQW4gYXJyYXkgb2YgdGhlIHBvaW50cyBvZiB0aGlzIHBvbHlnb25cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcltdfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMucG9pbnRzID0gcG9pbnRzO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSB0eXBlIG9mIHRoZSBvYmplY3QsIG1haW5seSB1c2VkIHRvIGF2b2lkIGBpbnN0YW5jZW9mYCBjaGVja3NcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAgICAgKiBAcmVhZE9ubHlcclxuICAgICAgICAgKiBAZGVmYXVsdCBQSVhJLlNIQVBFUy5QT0xZXHJcbiAgICAgICAgICogQHNlZSBQSVhJLlNIQVBFU1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMudHlwZSA9IFNoYXBlU2V0dGluZ3NfMS5TaGFwZVNldHRpbmdzLlNIQVBFUy5QT0xZO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIGBmYWxzZWAgYWZ0ZXIgbW92ZVRvLCBgdHJ1ZWAgYWZ0ZXIgYGNsb3NlUGF0aGAuIEluIGFsbCBvdGhlciBjYXNlcyBpdCBpcyBgdHJ1ZWAuXHJcbiAgICAgICAgICogQG1lbWJlciB7Ym9vbGVhbn1cclxuICAgICAgICAgKiBAZGVmYXVsdCB0cnVlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5jbG9zZVN0cm9rZSA9IHRydWU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBjbG9uZSBvZiB0aGlzIHBvbHlnb25cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIHtQSVhJLlBvbHlnb259IGEgY29weSBvZiB0aGUgcG9seWdvblxyXG4gICAgICovXHJcbiAgICBjbG9uZSgpIHtcclxuICAgICAgICB2YXIgcG9seWdvbiA9IG5ldyBQb2x5Z29uKHRoaXMucG9pbnRzLnNsaWNlKCkpO1xyXG4gICAgICAgIHBvbHlnb24uY2xvc2VTdHJva2UgPSB0aGlzLmNsb3NlU3Ryb2tlO1xyXG4gICAgICAgIHJldHVybiBwb2x5Z29uO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgeCBhbmQgeSBjb29yZGluYXRlcyBwYXNzZWQgdG8gdGhpcyBmdW5jdGlvbiBhcmUgY29udGFpbmVkIHdpdGhpbiB0aGlzIHBvbHlnb25cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCAtIFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50IHRvIHRlc3RcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQgdG8gdGVzdFxyXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUgeC95IGNvb3JkaW5hdGVzIGFyZSB3aXRoaW4gdGhpcyBwb2x5Z29uXHJcbiAgICAgKi9cclxuICAgIGNvbnRhaW5zKHgsIHkpIHtcclxuICAgICAgICB2YXIgaW5zaWRlID0gZmFsc2U7XHJcbiAgICAgICAgLy8gdXNlIHNvbWUgcmF5Y2FzdGluZyB0byB0ZXN0IGhpdHNcclxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vc3Vic3RhY2svcG9pbnQtaW4tcG9seWdvbi9ibG9iL21hc3Rlci9pbmRleC5qc1xyXG4gICAgICAgIHZhciBsZW5ndGggPSB0aGlzLnBvaW50cy5sZW5ndGggLyAyO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBqID0gbGVuZ3RoIC0gMTsgaSA8IGxlbmd0aDsgaiA9IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgeGkgPSB0aGlzLnBvaW50c1tpICogMl07XHJcbiAgICAgICAgICAgIHZhciB5aSA9IHRoaXMucG9pbnRzWyhpICogMikgKyAxXTtcclxuICAgICAgICAgICAgdmFyIHhqID0gdGhpcy5wb2ludHNbaiAqIDJdO1xyXG4gICAgICAgICAgICB2YXIgeWogPSB0aGlzLnBvaW50c1soaiAqIDIpICsgMV07XHJcbiAgICAgICAgICAgIHZhciBpbnRlcnNlY3QgPSAoKHlpID4geSkgIT09ICh5aiA+IHkpKSAmJiAoeCA8ICgoeGogLSB4aSkgKiAoKHkgLSB5aSkgLyAoeWogLSB5aSkpKSArIHhpKTtcclxuICAgICAgICAgICAgaWYgKGludGVyc2VjdCkge1xyXG4gICAgICAgICAgICAgICAgaW5zaWRlID0gIWluc2lkZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaW5zaWRlO1xyXG4gICAgfVxyXG4gICAgO1xyXG59XHJcbmV4cG9ydHMuUG9seWdvbiA9IFBvbHlnb247XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IEJhc2VQcmVwYXJlXzEgPSByZXF1aXJlKFwiLi9CYXNlUHJlcGFyZVwiKTtcclxuLy8gaW1wb3J0IHsgc2V0dGluZ3MgfSBmcm9tIFwiLi9zZXR0aW5nc1wiO1xyXG5jb25zdCBHcmFwaGljc18xID0gcmVxdWlyZShcIi4vR3JhcGhpY3NcIik7XHJcbmNvbnN0IEJhc2VUZXh0dXJlXzEgPSByZXF1aXJlKFwiLi9CYXNlVGV4dHVyZVwiKTtcclxuY2xhc3MgUHJlcGFyZSBleHRlbmRzIEJhc2VQcmVwYXJlXzEuQmFzZVByZXBhcmUge1xyXG4gICAgY29uc3RydWN0b3IocmVuZGVyZXIpIHtcclxuICAgICAgICBzdXBlcihyZW5kZXJlcik7XHJcbiAgICAgICAgdGhpcy51cGxvYWRIb29rSGVscGVyID0gdGhpcy5yZW5kZXJlcjtcclxuICAgICAgICAvLyBBZGQgdGV4dHVyZXMgYW5kIGdyYXBoaWNzIHRvIHVwbG9hZFxyXG4gICAgICAgIHRoaXMucmVnaXN0ZXJGaW5kSG9vayhQcmVwYXJlLmZpbmRHcmFwaGljcyk7XHJcbiAgICAgICAgdGhpcy5yZWdpc3RlclVwbG9hZEhvb2soUHJlcGFyZS51cGxvYWRCYXNlVGV4dHVyZXMpO1xyXG4gICAgICAgIHRoaXMucmVnaXN0ZXJVcGxvYWRIb29rKFByZXBhcmUudXBsb2FkR3JhcGhpY3MpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGZpbmRHcmFwaGljcyhpdGVtLCBxdWV1ZSkge1xyXG4gICAgICAgIGlmIChpdGVtIGluc3RhbmNlb2YgR3JhcGhpY3NfMS5HcmFwaGljcykge1xyXG4gICAgICAgICAgICBxdWV1ZS5wdXNoKGl0ZW0pO1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIHVwbG9hZEJhc2VUZXh0dXJlcyhyZW5kZXJlciwgaXRlbSkge1xyXG4gICAgICAgIGlmIChpdGVtIGluc3RhbmNlb2YgQmFzZVRleHR1cmVfMS5CYXNlVGV4dHVyZSkge1xyXG4gICAgICAgICAgICBpZiAoIWl0ZW0uX2dsVGV4dHVyZXNbcmVuZGVyZXIuQ09OVEVYVF9VSURdKSB7XHJcbiAgICAgICAgICAgICAgICByZW5kZXJlci50ZXh0dXJlTWFuYWdlci51cGRhdGVUZXh0dXJlKGl0ZW0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgdXBsb2FkR3JhcGhpY3MocmVuZGVyZXIsIGl0ZW0pIHtcclxuICAgICAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIEdyYXBoaWNzXzEuR3JhcGhpY3MpIHtcclxuICAgICAgICAgICAgaWYgKGl0ZW0uZGlydHkgfHwgaXRlbS5jbGVhckRpcnR5IHx8ICFpdGVtLl93ZWJHTFtyZW5kZXJlci5wbHVnaW5zLmdyYXBoaWNzLkNPTlRFWFRfVUlEXSkge1xyXG4gICAgICAgICAgICAgICAgcmVuZGVyZXIucGx1Z2lucy5ncmFwaGljcy51cGRhdGVHcmFwaGljcyhpdGVtKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuUHJlcGFyZSA9IFByZXBhcmU7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IFNoYWRlcl8xID0gcmVxdWlyZShcIi4vU2hhZGVyXCIpO1xyXG5jb25zdCBDYWNoZVNldHRpbmdzXzEgPSByZXF1aXJlKFwiLi9DYWNoZVNldHRpbmdzXCIpO1xyXG5jb25zdCBXZWJHTFNldHRpbmdzXzEgPSByZXF1aXJlKFwiLi9XZWJHTFNldHRpbmdzXCIpO1xyXG5jbGFzcyBQcm9ncmFtIHtcclxuICAgIGNvbnN0cnVjdG9yKHZlcnRleFNyYywgZnJhZ21lbnRTcmMsIG5hbWUgPSAncGl4aS1zaGFkZXInKSB7XHJcbiAgICAgICAgdGhpcy5pZCA9IFByb2dyYW0uVUlEJDMrKztcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgdmVydGV4IHNoYWRlci5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBtZW1iZXIge3N0cmluZ31cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnZlcnRleFNyYyA9IHZlcnRleFNyYyB8fCBQcm9ncmFtLmRlZmF1bHRWZXJ0ZXhTcmM7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGZyYWdtZW50IHNoYWRlci5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBtZW1iZXIge3N0cmluZ31cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmZyYWdtZW50U3JjID0gZnJhZ21lbnRTcmMgfHwgUHJvZ3JhbS5kZWZhdWx0RnJhZ21lbnRTcmM7XHJcbiAgICAgICAgdGhpcy52ZXJ0ZXhTcmMgPSB0aGlzLnZlcnRleFNyYy50cmltKCk7XHJcbiAgICAgICAgdGhpcy5mcmFnbWVudFNyYyA9IHRoaXMuZnJhZ21lbnRTcmMudHJpbSgpO1xyXG4gICAgICAgIGlmICh0aGlzLnZlcnRleFNyYy5zdWJzdHJpbmcoMCwgOCkgIT09ICcjdmVyc2lvbicpIHtcclxuICAgICAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZSgvXFxzKy9nLCAnLScpO1xyXG4gICAgICAgICAgICBpZiAoQ2FjaGVTZXR0aW5nc18xLkNhY2hlU2V0dGluZ3MubmFtZUNhY2hlW25hbWVdKSB7XHJcbiAgICAgICAgICAgICAgICBDYWNoZVNldHRpbmdzXzEuQ2FjaGVTZXR0aW5ncy5uYW1lQ2FjaGVbbmFtZV0rKztcclxuICAgICAgICAgICAgICAgIG5hbWUgKz0gXCItXCIgKyAoQ2FjaGVTZXR0aW5nc18xLkNhY2hlU2V0dGluZ3MubmFtZUNhY2hlW25hbWVdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIENhY2hlU2V0dGluZ3NfMS5DYWNoZVNldHRpbmdzLm5hbWVDYWNoZVtuYW1lXSA9IDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy52ZXJ0ZXhTcmMgPSBcIiNkZWZpbmUgU0hBREVSX05BTUUgXCIgKyBuYW1lICsgXCJcXG5cIiArICh0aGlzLnZlcnRleFNyYyk7XHJcbiAgICAgICAgICAgIHRoaXMuZnJhZ21lbnRTcmMgPSBcIiNkZWZpbmUgU0hBREVSX05BTUUgXCIgKyBuYW1lICsgXCJcXG5cIiArICh0aGlzLmZyYWdtZW50U3JjKTtcclxuICAgICAgICAgICAgdGhpcy52ZXJ0ZXhTcmMgPSBXZWJHTFNldHRpbmdzXzEuV2ViR0xTZXR0aW5ncy5zZXRQcmVjaXNpb24odGhpcy52ZXJ0ZXhTcmMsIFdlYkdMU2V0dGluZ3NfMS5XZWJHTFNldHRpbmdzLlBSRUNJU0lPTl9WRVJURVgpO1xyXG4gICAgICAgICAgICB0aGlzLmZyYWdtZW50U3JjID0gV2ViR0xTZXR0aW5nc18xLldlYkdMU2V0dGluZ3Muc2V0UHJlY2lzaW9uKHRoaXMuZnJhZ21lbnRTcmMsIFdlYkdMU2V0dGluZ3NfMS5XZWJHTFNldHRpbmdzLlBSRUNJU0lPTl9GUkFHTUVOVCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChuYW1lID09IFwicGl4aS1zaGFkZXItNFwiKSB7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGN1cnJlbnRseSB0aGlzIGRvZXMgbm90IGV4dHJhY3Qgc3RydWN0cyBvbmx5IGRlZmF1bHQgdHlwZXNcclxuICAgICAgICB0aGlzLmV4dHJhY3REYXRhKHRoaXMudmVydGV4U3JjLCB0aGlzLmZyYWdtZW50U3JjKTtcclxuICAgICAgICAvLyB0aGlzIGlzIHdoZXJlIHdlIHN0b3JlIHNoYWRlciByZWZlcmVuY2VzLi5cclxuICAgICAgICB0aGlzLmdsUHJvZ3JhbXMgPSB7fTtcclxuICAgICAgICB0aGlzLnN5bmNVbmlmb3JtcyA9IG51bGw7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEV4dHJhY3RzIHRoZSBkYXRhIGZvciBhIGJ1eSBjcmVhdGluZyBhIHNtYWxsIHRlc3QgcHJvZ3JhbVxyXG4gICAgICogb3IgcmVhZGluZyB0aGUgc3JjIGRpcmVjdGx5LlxyXG4gICAgICogQHByb3RlY3RlZFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbdmVydGV4U3JjXSAtIFRoZSBzb3VyY2Ugb2YgdGhlIHZlcnRleCBzaGFkZXIuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2ZyYWdtZW50U3JjXSAtIFRoZSBzb3VyY2Ugb2YgdGhlIGZyYWdtZW50IHNoYWRlci5cclxuICAgICAqL1xyXG4gICAgZXh0cmFjdERhdGEodmVydGV4U3JjLCBmcmFnbWVudFNyYykge1xyXG4gICAgICAgIHZhciBnbCA9IFdlYkdMU2V0dGluZ3NfMS5XZWJHTFNldHRpbmdzLmdldFRlc3RDb250ZXh0KCk7XHJcbiAgICAgICAgaWYgKGdsKSB7XHJcbiAgICAgICAgICAgIHZhciBwcm9ncmFtID0gUHJvZ3JhbS5jb21waWxlUHJvZ3JhbShnbCwgdmVydGV4U3JjLCBmcmFnbWVudFNyYyk7XHJcbiAgICAgICAgICAgIHRoaXMuYXR0cmlidXRlRGF0YSA9IHRoaXMuZ2V0QXR0cmlidXRlRGF0YShwcm9ncmFtLCBnbCk7XHJcbiAgICAgICAgICAgIHRoaXMudW5pZm9ybURhdGEgPSB0aGlzLmdldFVuaWZvcm1EYXRhKHByb2dyYW0sIGdsKTtcclxuICAgICAgICAgICAgZ2wuZGVsZXRlUHJvZ3JhbShwcm9ncmFtKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMudW5pZm9ybURhdGEgPSB7fTtcclxuICAgICAgICAgICAgdGhpcy5hdHRyaWJ1dGVEYXRhID0ge307XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiByZXR1cm5zIHRoZSBhdHRyaWJ1dGUgZGF0YSBmcm9tIHRoZSBwcm9ncmFtXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7V2ViR0xQcm9ncmFtfSBbcHJvZ3JhbV0gLSB0aGUgV2ViR0wgcHJvZ3JhbVxyXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IFtnbF0gLSB0aGUgV2ViR0wgY29udGV4dFxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9IHRoZSBhdHRyaWJ1dGUgZGF0YSBmb3IgdGhpcyBwcm9ncmFtXHJcbiAgICAgKi9cclxuICAgIGdldEF0dHJpYnV0ZURhdGEocHJvZ3JhbSwgZ2wpIHtcclxuICAgICAgICB2YXIgYXR0cmlidXRlcyA9IHt9O1xyXG4gICAgICAgIHZhciBhdHRyaWJ1dGVzQXJyYXkgPSBbXTtcclxuICAgICAgICB2YXIgdG90YWxBdHRyaWJ1dGVzID0gZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcihwcm9ncmFtLCBnbC5BQ1RJVkVfQVRUUklCVVRFUyk7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b3RhbEF0dHJpYnV0ZXM7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgYXR0cmliRGF0YSA9IGdsLmdldEFjdGl2ZUF0dHJpYihwcm9ncmFtLCBpKTtcclxuICAgICAgICAgICAgdmFyIHR5cGUgPSBXZWJHTFNldHRpbmdzXzEuV2ViR0xTZXR0aW5ncy5tYXBUeXBlKGdsLCBhdHRyaWJEYXRhLnR5cGUpO1xyXG4gICAgICAgICAgICAvKmVzbGludC1kaXNhYmxlICovXHJcbiAgICAgICAgICAgIHZhciBkYXRhID0ge1xyXG4gICAgICAgICAgICAgICAgdHlwZTogdHlwZSxcclxuICAgICAgICAgICAgICAgIG5hbWU6IGF0dHJpYkRhdGEubmFtZSxcclxuICAgICAgICAgICAgICAgIHNpemU6IFdlYkdMU2V0dGluZ3NfMS5XZWJHTFNldHRpbmdzLm1hcFNpemUodHlwZSksXHJcbiAgICAgICAgICAgICAgICBsb2NhdGlvbjogMCxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyogZXNsaW50LWVuYWJsZSAqL1xyXG4gICAgICAgICAgICBhdHRyaWJ1dGVzW2F0dHJpYkRhdGEubmFtZV0gPSBkYXRhO1xyXG4gICAgICAgICAgICBhdHRyaWJ1dGVzQXJyYXkucHVzaChkYXRhKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYXR0cmlidXRlc0FycmF5LnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIChhLm5hbWUgPiBiLm5hbWUpID8gMSA6IC0xOyB9KTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25mdXNpbmctYXJyb3dcclxuICAgICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBhdHRyaWJ1dGVzQXJyYXkubGVuZ3RoOyBpJDErKykge1xyXG4gICAgICAgICAgICBhdHRyaWJ1dGVzQXJyYXlbaSQxXS5sb2NhdGlvbiA9IGkkMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGF0dHJpYnV0ZXM7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIHJldHVybnMgdGhlIHVuaWZvcm0gZGF0YSBmcm9tIHRoZSBwcm9ncmFtXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7d2ViR0wtcHJvZ3JhbX0gW3Byb2dyYW1dIC0gdGhlIHdlYmdsIHByb2dyYW1cclxuICAgICAqIEBwYXJhbSB7Y29udGV4dH0gW2dsXSAtIHRoZSBXZWJHTCBjb250ZXh0XHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge29iamVjdH0gdGhlIHVuaWZvcm0gZGF0YSBmb3IgdGhpcyBwcm9ncmFtXHJcbiAgICAgKi9cclxuICAgIGdldFVuaWZvcm1EYXRhKHByb2dyYW0sIGdsKSB7XHJcbiAgICAgICAgdmFyIHVuaWZvcm1zID0ge307XHJcbiAgICAgICAgdmFyIHRvdGFsVW5pZm9ybXMgPSBnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKHByb2dyYW0sIGdsLkFDVElWRV9VTklGT1JNUyk7XHJcbiAgICAgICAgLy8gVE9ETyBleHBvc2UgdGhpcyBhcyBhIHByb3A/XHJcbiAgICAgICAgLy8gY29uc3QgbWFza1JlZ2V4ID0gbmV3IFJlZ0V4cCgnXihwcm9qZWN0aW9uTWF0cml4fHVTYW1wbGVyfHRyYW5zbGF0aW9uTWF0cml4KSQnKTtcclxuICAgICAgICAvLyBjb25zdCBtYXNrUmVnZXggPSBuZXcgUmVnRXhwKCdeKHByb2plY3Rpb25NYXRyaXh8dVNhbXBsZXJ8dHJhbnNsYXRpb25NYXRyaXgpJCcpO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG90YWxVbmlmb3JtczsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciB1bmlmb3JtRGF0YSA9IGdsLmdldEFjdGl2ZVVuaWZvcm0ocHJvZ3JhbSwgaSk7XHJcbiAgICAgICAgICAgIHZhciBuYW1lID0gdW5pZm9ybURhdGEubmFtZS5yZXBsYWNlKC9cXFsuKj9cXF0vLCAnJyk7XHJcbiAgICAgICAgICAgIHZhciBpc0FycmF5ID0gdW5pZm9ybURhdGEubmFtZS5tYXRjaCgvXFxbLio/XFxdLywgJycpO1xyXG4gICAgICAgICAgICB2YXIgdHlwZSA9IFdlYkdMU2V0dGluZ3NfMS5XZWJHTFNldHRpbmdzLm1hcFR5cGUoZ2wsIHVuaWZvcm1EYXRhLnR5cGUpO1xyXG4gICAgICAgICAgICAvKmVzbGludC1kaXNhYmxlICovXHJcbiAgICAgICAgICAgIHVuaWZvcm1zW25hbWVdID0ge1xyXG4gICAgICAgICAgICAgICAgdHlwZTogdHlwZSxcclxuICAgICAgICAgICAgICAgIHNpemU6IHVuaWZvcm1EYXRhLnNpemUsXHJcbiAgICAgICAgICAgICAgICBpc0FycmF5OiBpc0FycmF5LFxyXG4gICAgICAgICAgICAgICAgdmFsdWU6IFdlYkdMU2V0dGluZ3NfMS5XZWJHTFNldHRpbmdzLmRlZmF1bHRWYWx1ZSh0eXBlLCB1bmlmb3JtRGF0YS5zaXplKSxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyogZXNsaW50LWVuYWJsZSAqL1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdW5pZm9ybXM7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBkZWZhdWx0IHZlcnRleCBzaGFkZXIgc291cmNlXHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQGNvbnN0YW50XHJcbiAgICAgKiBAbWVtYmVyIHtzdHJpbmd9XHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBnZXQgZGVmYXVsdFZlcnRleFNyYygpIHtcclxuICAgICAgICByZXR1cm4gUHJvZ3JhbS5kZWZhdWx0VmVydGV4O1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgZGVmYXVsdCBmcmFnbWVudCBzaGFkZXIgc291cmNlXHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQGNvbnN0YW50XHJcbiAgICAgKiBAbWVtYmVyIHtzdHJpbmd9XHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBnZXQgZGVmYXVsdEZyYWdtZW50U3JjKCkge1xyXG4gICAgICAgIHJldHVybiBQcm9ncmFtLmRlZmF1bHRGcmFnbWVudDtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQSBzaG9ydCBoYW5kIGZ1bmN0aW9uIHRvIGNyZWF0ZSBhIHByb2dyYW0gYmFzZWQgb2YgYSB2ZXJ0ZXggYW5kIGZyYWdtZW50IHNoYWRlclxyXG4gICAgICogdGhpcyBtZXRob2Qgd2lsbCBhbHNvIGNoZWNrIHRvIHNlZSBpZiB0aGVyZSBpcyBhIGNhY2hlZCBwcm9ncmFtLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbdmVydGV4U3JjXSAtIFRoZSBzb3VyY2Ugb2YgdGhlIHZlcnRleCBzaGFkZXIuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2ZyYWdtZW50U3JjXSAtIFRoZSBzb3VyY2Ugb2YgdGhlIGZyYWdtZW50IHNoYWRlci5cclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbdW5pZm9ybXNdIC0gQ3VzdG9tIHVuaWZvcm1zIHRvIHVzZSB0byBhdWdtZW50IHRoZSBidWlsdC1pbiBvbmVzLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHtQSVhJLlByb2dyYW19IGFuIHNoaW55IG5ldyBQaXhpIHNoYWRlciFcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGZyb20odmVydGV4U3JjLCBmcmFnbWVudFNyYywgbmFtZSA9IFwicGl4aS1zaGFkZXJcIikge1xyXG4gICAgICAgIHZhciBrZXkgPSB2ZXJ0ZXhTcmMgKyBmcmFnbWVudFNyYztcclxuICAgICAgICB2YXIgcHJvZ3JhbSA9IENhY2hlU2V0dGluZ3NfMS5DYWNoZVNldHRpbmdzLlByb2dyYW1DYWNoZVtrZXldO1xyXG4gICAgICAgIGlmICghcHJvZ3JhbSkge1xyXG4gICAgICAgICAgICBDYWNoZVNldHRpbmdzXzEuQ2FjaGVTZXR0aW5ncy5Qcm9ncmFtQ2FjaGVba2V5XSA9IHByb2dyYW0gPSBuZXcgUHJvZ3JhbSh2ZXJ0ZXhTcmMsIGZyYWdtZW50U3JjLCBuYW1lKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHByb2dyYW07XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICogQG1ldGhvZCBjb21waWxlUHJvZ3JhbVxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAbWVtYmVyb2YgUElYSS5nbENvcmUuc2hhZGVyXHJcbiAqIEBwYXJhbSBnbCB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBUaGUgY3VycmVudCBXZWJHTCBjb250ZXh0IHtXZWJHTFByb2dyYW19XHJcbiAqIEBwYXJhbSB2ZXJ0ZXhTcmMge3N0cmluZ3xzdHJpbmdbXX0gVGhlIHZlcnRleCBzaGFkZXIgc291cmNlIGFzIGFuIGFycmF5IG9mIHN0cmluZ3MuXHJcbiAqIEBwYXJhbSBmcmFnbWVudFNyYyB7c3RyaW5nfHN0cmluZ1tdfSBUaGUgZnJhZ21lbnQgc2hhZGVyIHNvdXJjZSBhcyBhbiBhcnJheSBvZiBzdHJpbmdzLlxyXG4gKiBAcGFyYW0gYXR0cmlidXRlTG9jYXRpb25zIHtPYmplY3R9IEFuIGF0dHJpYnV0ZSBsb2NhdGlvbiBtYXAgdGhhdCBsZXRzIHlvdSBtYW51YWxseSBzZXQgdGhlIGF0dHJpYnV0ZSBsb2NhdGlvbnNcclxuICogQHJldHVybiB7V2ViR0xQcm9ncmFtfSB0aGUgc2hhZGVyIHByb2dyYW1cclxuICovXHJcbiAgICBzdGF0aWMgY29tcGlsZVByb2dyYW0oZ2wsIHZlcnRleFNyYywgZnJhZ21lbnRTcmMsIGF0dHJpYnV0ZUxvY2F0aW9ucyA9IG51bGwpIHtcclxuICAgICAgICB2YXIgZ2xWZXJ0U2hhZGVyID0gU2hhZGVyXzEuU2hhZGVyLmNvbXBpbGVTaGFkZXIoZ2wsIGdsLlZFUlRFWF9TSEFERVIsIHZlcnRleFNyYyk7XHJcbiAgICAgICAgdmFyIGdsRnJhZ1NoYWRlciA9IFNoYWRlcl8xLlNoYWRlci5jb21waWxlU2hhZGVyKGdsLCBnbC5GUkFHTUVOVF9TSEFERVIsIGZyYWdtZW50U3JjKTtcclxuICAgICAgICB2YXIgcHJvZ3JhbSA9IGdsLmNyZWF0ZVByb2dyYW0oKTtcclxuICAgICAgICBnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgZ2xWZXJ0U2hhZGVyKTtcclxuICAgICAgICBnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgZ2xGcmFnU2hhZGVyKTtcclxuICAgICAgICAvLyBvcHRpb25hbGx5LCBzZXQgdGhlIGF0dHJpYnV0ZXMgbWFudWFsbHkgZm9yIHRoZSBwcm9ncmFtIHJhdGhlciB0aGFuIGxldHRpbmcgV2ViR0wgZGVjaWRlLi5cclxuICAgICAgICBpZiAoYXR0cmlidXRlTG9jYXRpb25zKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgaW4gYXR0cmlidXRlTG9jYXRpb25zKSB7XHJcbiAgICAgICAgICAgICAgICBnbC5iaW5kQXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgYXR0cmlidXRlTG9jYXRpb25zW2ldLCBpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBnbC5saW5rUHJvZ3JhbShwcm9ncmFtKTtcclxuICAgICAgICAvLyBpZiBsaW5raW5nIGZhaWxzLCB0aGVuIGxvZyBhbmQgY2xlYW51cFxyXG4gICAgICAgIGlmICghZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcihwcm9ncmFtLCBnbC5MSU5LX1NUQVRVUykpIHtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcignUGl4aS5qcyBFcnJvcjogQ291bGQgbm90IGluaXRpYWxpemUgc2hhZGVyLicpO1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdnbC5WQUxJREFURV9TVEFUVVMnLCBnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKHByb2dyYW0sIGdsLlZBTElEQVRFX1NUQVRVUykpO1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdnbC5nZXRFcnJvcigpJywgZ2wuZ2V0RXJyb3IoKSk7XHJcbiAgICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIGEgcHJvZ3JhbSBpbmZvIGxvZywgbG9nIGl0XHJcbiAgICAgICAgICAgIGlmIChnbC5nZXRQcm9ncmFtSW5mb0xvZyhwcm9ncmFtKSAhPT0gJycpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignUGl4aS5qcyBXYXJuaW5nOiBnbC5nZXRQcm9ncmFtSW5mb0xvZygpJywgZ2wuZ2V0UHJvZ3JhbUluZm9Mb2cocHJvZ3JhbSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGdsLmRlbGV0ZVByb2dyYW0ocHJvZ3JhbSk7XHJcbiAgICAgICAgICAgIHByb2dyYW0gPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBjbGVhbiB1cCBzb21lIHNoYWRlcnNcclxuICAgICAgICBnbC5kZWxldGVTaGFkZXIoZ2xWZXJ0U2hhZGVyKTtcclxuICAgICAgICBnbC5kZWxldGVTaGFkZXIoZ2xGcmFnU2hhZGVyKTtcclxuICAgICAgICByZXR1cm4gcHJvZ3JhbTtcclxuICAgIH1cclxufVxyXG5Qcm9ncmFtLlVJRCQzID0gMDtcclxuUHJvZ3JhbS5kZWZhdWx0RnJhZ21lbnQgPSBcInZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xcclxcblxcclxcbnVuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyO1xcclxcblxcclxcbnZvaWQgbWFpbih2b2lkKXtcXHJcXG4gICBnbF9GcmFnQ29sb3IgKj0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2VGV4dHVyZUNvb3JkKTtcXHJcXG59XCI7XHJcblByb2dyYW0uZGVmYXVsdFZlcnRleCA9IFwiYXR0cmlidXRlIHZlYzIgYVZlcnRleFBvc2l0aW9uO1xcclxcbmF0dHJpYnV0ZSB2ZWMyIGFUZXh0dXJlQ29vcmQ7XFxyXFxuXFxyXFxudW5pZm9ybSBtYXQzIHByb2plY3Rpb25NYXRyaXg7XFxyXFxuXFxyXFxudmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XFxyXFxuXFxyXFxudm9pZCBtYWluKHZvaWQpe1xcclxcbiAgIGdsX1Bvc2l0aW9uID0gdmVjNCgocHJvamVjdGlvbk1hdHJpeCAqIHZlYzMoYVZlcnRleFBvc2l0aW9uLCAxLjApKS54eSwgMC4wLCAxLjApO1xcclxcbiAgIHZUZXh0dXJlQ29vcmQgPSBhVGV4dHVyZUNvb3JkO1xcclxcbn1cXHJcXG5cIjtcclxuZXhwb3J0cy5Qcm9ncmFtID0gUHJvZ3JhbTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgRXZlbnRfMSA9IHJlcXVpcmUoXCIuL0V2ZW50XCIpO1xyXG5jbGFzcyBQcm9ncmVzc0V2ZW50IGV4dGVuZHMgRXZlbnRfMS5FdmVudCB7XHJcbiAgICBjb25zdHJ1Y3Rvcih0eXBlLCBidWJibGVzID0gZmFsc2UsIGNhbmNlbGFibGUgPSBmYWxzZSkge1xyXG4gICAgICAgIHN1cGVyKHR5cGUsIGJ1YmJsZXMsIGNhbmNlbGFibGUpO1xyXG4gICAgfVxyXG4gICAgY2xvbmUoKSB7XHJcbiAgICAgICAgdmFyIGV2ZW50ID0gUHJvZ3Jlc3NFdmVudC5nZXRQcm9ncmVzc0V2ZW50KHRoaXMudHlwZSwgdGhpcy5idWJibGVzLCB0aGlzLmNhbmNlbGFibGUpO1xyXG4gICAgICAgIGV2ZW50LmJ5dGVzTG9hZGVkID0gdGhpcy5ieXRlc0xvYWRlZDtcclxuICAgICAgICBldmVudC5ieXRlc1RvdGFsID0gdGhpcy5ieXRlc1RvdGFsO1xyXG4gICAgICAgIGV2ZW50LnBlcmNlbnQgPSB0aGlzLnBlcmNlbnQ7XHJcbiAgICAgICAgcmV0dXJuIGV2ZW50O1xyXG4gICAgfVxyXG4gICAgZ2V0IGlzRGlzcG9zYWJsZSgpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBnZXRQcm9ncmVzc0V2ZW50KHR5cGUsIGJ1YmJsZSA9IHRydWUsIGNhbmNlbGFibGUgPSB0cnVlKSB7XHJcbiAgICAgICAgaWYgKFByb2dyZXNzRXZlbnQuUHJvZ3Jlc3NFdmVudENhY2hlLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBsZXQgdGUgPSBQcm9ncmVzc0V2ZW50LlByb2dyZXNzRXZlbnRDYWNoZVtQcm9ncmVzc0V2ZW50LlByb2dyZXNzRXZlbnRDYWNoZS5sZW5ndGggLSAxXTtcclxuICAgICAgICAgICAgUHJvZ3Jlc3NFdmVudC5Qcm9ncmVzc0V2ZW50Q2FjaGUubGVuZ3RoIC09IDE7XHJcbiAgICAgICAgICAgIHRlLnJlc2V0KHR5cGUsIGJ1YmJsZSwgY2FuY2VsYWJsZSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9ncmVzc0V2ZW50KHR5cGUsIGJ1YmJsZSwgY2FuY2VsYWJsZSk7XHJcbiAgICB9XHJcbiAgICBkZXN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMuX2N1cnJlbnRUYXJnZXQgPSBudWxsO1xyXG4gICAgICAgIC8vIHRoaXMuX2xlZ2FjeVRhcmdldCA9IG51bGw7XHJcbiAgICAgICAgbGV0IGluZGV4ID0gUHJvZ3Jlc3NFdmVudC5Qcm9ncmVzc0V2ZW50Q2FjaGUuaW5kZXhPZih0aGlzKTtcclxuICAgICAgICBpZiAoaW5kZXggPCAwKSB7XHJcbiAgICAgICAgICAgIFByb2dyZXNzRXZlbnQuUHJvZ3Jlc3NFdmVudENhY2hlLnB1c2godGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblByb2dyZXNzRXZlbnQuUHJvZ3Jlc3NFdmVudENhY2hlID0gW107XHJcblByb2dyZXNzRXZlbnQuUFJPR1JFU1MgPSBcInByb2dyZXNzXCI7XHJcbmV4cG9ydHMuUHJvZ3Jlc3NFdmVudCA9IFByb2dyZXNzRXZlbnQ7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IFN5c3RlbV8xID0gcmVxdWlyZShcIi4vU3lzdGVtXCIpO1xyXG5jb25zdCBNYXRyaXhfMSA9IHJlcXVpcmUoXCIuL01hdHJpeFwiKTtcclxuY2xhc3MgUHJvamVjdGlvblN5c3RlbSBleHRlbmRzIFN5c3RlbV8xLlN5c3RlbSB7XHJcbiAgICBjb25zdHJ1Y3RvcihyZW5kZXJlcikge1xyXG4gICAgICAgIHN1cGVyKHJlbmRlcmVyKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBEZXN0aW5hdGlvbiBmcmFtZVxyXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuUmVjdGFuZ2xlfVxyXG4gICAgICAgICAqIEByZWFkb25seVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuZGVzdGluYXRpb25GcmFtZSA9IG51bGw7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU291cmNlIGZyYW1lXHJcbiAgICAgICAgICogQG1lbWJlciB7UElYSS5SZWN0YW5nbGV9XHJcbiAgICAgICAgICogQHJlYWRvbmx5XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5zb3VyY2VGcmFtZSA9IG51bGw7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRGVmYXVsdCBkZXN0aW5hdGlvbiBmcmFtZVxyXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuUmVjdGFuZ2xlfVxyXG4gICAgICAgICAqIEByZWFkb25seVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuZGVmYXVsdEZyYW1lID0gbnVsbDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBQcm9qZWN0IG1hdHJpeFxyXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuTWF0cml4fVxyXG4gICAgICAgICAqIEByZWFkb25seVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMucHJvamVjdGlvbk1hdHJpeCA9IG5ldyBNYXRyaXhfMS5NYXRyaXgoKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBIHRyYW5zZm9ybSB0aGF0IHdpbGwgYmUgYXBwZW5kZWQgdG8gdGhlIHByb2plY3Rpb24gbWF0cml4XHJcbiAgICAgICAgICogaWYgbnVsbCwgbm90aGluZyB3aWxsIGJlIGFwcGxpZWRcclxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLk1hdHJpeH1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnRyYW5zZm9ybSA9IG51bGw7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgdGhlIHByb2plY3Rpb24gbWF0cml4IGJhc2VkIG9uIGEgcHJvamVjdGlvbiBmcmFtZSAod2hpY2ggaXMgYSByZWN0YW5nbGUpXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtQSVhJLlJlY3RhbmdsZX0gZGVzdGluYXRpb25GcmFtZSAtIFRoZSBkZXN0aW5hdGlvbiBmcmFtZS5cclxuICAgICAqIEBwYXJhbSB7UElYSS5SZWN0YW5nbGV9IHNvdXJjZUZyYW1lIC0gVGhlIHNvdXJjZSBmcmFtZS5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSByZXNvbHV0aW9uIC0gUmVzb2x1dGlvblxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSByb290IC0gSWYgaXMgcm9vdFxyXG4gICAgICovXHJcbiAgICB1cGRhdGUoZGVzdGluYXRpb25GcmFtZSwgc291cmNlRnJhbWUsIHJlc29sdXRpb24sIHJvb3QpIHtcclxuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uRnJhbWUgPSBkZXN0aW5hdGlvbkZyYW1lIHx8IHRoaXMuZGVzdGluYXRpb25GcmFtZSB8fCB0aGlzLmRlZmF1bHRGcmFtZTtcclxuICAgICAgICB0aGlzLnNvdXJjZUZyYW1lID0gc291cmNlRnJhbWUgfHwgdGhpcy5zb3VyY2VGcmFtZSB8fCBkZXN0aW5hdGlvbkZyYW1lO1xyXG4gICAgICAgIHRoaXMuY2FsY3VsYXRlUHJvamVjdGlvbih0aGlzLmRlc3RpbmF0aW9uRnJhbWUsIHRoaXMuc291cmNlRnJhbWUsIHJlc29sdXRpb24sIHJvb3QpO1xyXG4gICAgICAgIGlmICh0aGlzLnRyYW5zZm9ybSkge1xyXG4gICAgICAgICAgICB0aGlzLnByb2plY3Rpb25NYXRyaXguYXBwZW5kKHRoaXMudHJhbnNmb3JtKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHJlbmRlcmVyID0gdGhpcy5yZW5kZXJlcjtcclxuICAgICAgICByZW5kZXJlci5nbG9iYWxVbmlmb3Jtcy51bmlmb3Jtcy5wcm9qZWN0aW9uTWF0cml4ID0gdGhpcy5wcm9qZWN0aW9uTWF0cml4O1xyXG4gICAgICAgIHJlbmRlcmVyLmdsb2JhbFVuaWZvcm1zLnVwZGF0ZSgpO1xyXG4gICAgICAgIC8vIHRoaXMgd2lsbCB3b3JrIGZvciBub3dcclxuICAgICAgICAvLyBidXQgd291bGQgYmUgc3dlZXQgdG8gc3RpY2sgYW5kIGV2ZW4gb24gdGhlIGdsb2JhbCB1bmlmb3Jtcy4uXHJcbiAgICAgICAgaWYgKHJlbmRlcmVyLnNoYWRlci5zaGFkZXIpIHtcclxuICAgICAgICAgICAgcmVuZGVyZXIuc2hhZGVyLnN5bmNVbmlmb3JtR3JvdXAocmVuZGVyZXIuc2hhZGVyLnNoYWRlci51bmlmb3Jtcy5nbG9iYWxzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgdGhlIHByb2plY3Rpb24gbWF0cml4IGJhc2VkIG9uIGEgcHJvamVjdGlvbiBmcmFtZSAod2hpY2ggaXMgYSByZWN0YW5nbGUpXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtQSVhJLlJlY3RhbmdsZX0gZGVzdGluYXRpb25GcmFtZSAtIFRoZSBkZXN0aW5hdGlvbiBmcmFtZS5cclxuICAgICAqIEBwYXJhbSB7UElYSS5SZWN0YW5nbGV9IHNvdXJjZUZyYW1lIC0gVGhlIHNvdXJjZSBmcmFtZS5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSByZXNvbHV0aW9uIC0gUmVzb2x1dGlvblxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSByb290IC0gSWYgaXMgcm9vdFxyXG4gICAgICovXHJcbiAgICBjYWxjdWxhdGVQcm9qZWN0aW9uKGRlc3RpbmF0aW9uRnJhbWUsIHNvdXJjZUZyYW1lLCByZXNvbHV0aW9uLCByb290KSB7XHJcbiAgICAgICAgdmFyIHBtID0gdGhpcy5wcm9qZWN0aW9uTWF0cml4O1xyXG4gICAgICAgIC8vIEkgZG9uJ3QgdGhpbmsgd2Ugd2lsbCBuZWVkIHRoaXMgbGluZS4uXHJcbiAgICAgICAgLy8gcG0uaWRlbnRpdHkoKTtcclxuICAgICAgICBpZiAoIXJvb3QpIHtcclxuICAgICAgICAgICAgcG0uYSA9ICgxIC8gZGVzdGluYXRpb25GcmFtZS53aWR0aCAqIDIpICogcmVzb2x1dGlvbjtcclxuICAgICAgICAgICAgcG0uZCA9ICgxIC8gZGVzdGluYXRpb25GcmFtZS5oZWlnaHQgKiAyKSAqIHJlc29sdXRpb247XHJcbiAgICAgICAgICAgIHBtLnR4ID0gLTEgLSAoc291cmNlRnJhbWUueCAqIHBtLmEpO1xyXG4gICAgICAgICAgICBwbS50eSA9IC0xIC0gKHNvdXJjZUZyYW1lLnkgKiBwbS5kKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHBtLmEgPSAoMSAvIGRlc3RpbmF0aW9uRnJhbWUud2lkdGggKiAyKSAqIHJlc29sdXRpb247XHJcbiAgICAgICAgICAgIHBtLmQgPSAoLTEgLyBkZXN0aW5hdGlvbkZyYW1lLmhlaWdodCAqIDIpICogcmVzb2x1dGlvbjtcclxuICAgICAgICAgICAgcG0udHggPSAtMSAtIChzb3VyY2VGcmFtZS54ICogcG0uYSk7XHJcbiAgICAgICAgICAgIHBtLnR5ID0gMSAtIChzb3VyY2VGcmFtZS55ICogcG0uZCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSB0cmFuc2Zvcm0gb2YgdGhlIGFjdGl2ZSByZW5kZXIgdGFyZ2V0IHRvIHRoZSBnaXZlbiBtYXRyaXhcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1BJWEkuTWF0cml4fSBtYXRyaXggLSBUaGUgdHJhbnNmb3JtYXRpb24gbWF0cml4XHJcbiAgICAgKi9cclxuICAgIHNldFRyYW5zZm9ybSgpIHtcclxuICAgICAgICAvLyB0aGlzLl9hY3RpdmVSZW5kZXJUYXJnZXQudHJhbnNmb3JtID0gbWF0cml4O1xyXG4gICAgfVxyXG4gICAgO1xyXG59XHJcbmV4cG9ydHMuUHJvamVjdGlvblN5c3RlbSA9IFByb2plY3Rpb25TeXN0ZW07XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IEdlb21ldHJ5XzEgPSByZXF1aXJlKFwiLi9HZW9tZXRyeVwiKTtcclxuY2xhc3MgUXVhZCBleHRlbmRzIEdlb21ldHJ5XzEuR2VvbWV0cnkge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLmFkZEF0dHJpYnV0ZSgnYVZlcnRleFBvc2l0aW9uJywgWzAsIDAsIDEsIDAsIDEsIDEsIDAsIDFdKS5hZGRJbmRleChbMCwgMSwgMywgMl0pO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuUXVhZCA9IFF1YWQ7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IEdlb21ldHJ5XzEgPSByZXF1aXJlKFwiLi9HZW9tZXRyeVwiKTtcclxuY29uc3QgQnVmZmVyXzEgPSByZXF1aXJlKFwiLi9CdWZmZXJcIik7XHJcbmNsYXNzIFF1YWRVdiBleHRlbmRzIEdlb21ldHJ5XzEuR2VvbWV0cnkge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBbiBhcnJheSBvZiB2ZXJ0aWNlc1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQG1lbWJlciB7RmxvYXQzMkFycmF5fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMudmVydGljZXMgPSBuZXcgRmxvYXQzMkFycmF5KFtcclxuICAgICAgICAgICAgLTEsIC0xLFxyXG4gICAgICAgICAgICAxLCAtMSxcclxuICAgICAgICAgICAgMSwgMSxcclxuICAgICAgICAgICAgLTEsIDFcclxuICAgICAgICBdKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgVXZzIG9mIHRoZSBxdWFkXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAbWVtYmVyIHtGbG9hdDMyQXJyYXl9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy51dnMgPSBuZXcgRmxvYXQzMkFycmF5KFtcclxuICAgICAgICAgICAgMCwgMCxcclxuICAgICAgICAgICAgMSwgMCxcclxuICAgICAgICAgICAgMSwgMSxcclxuICAgICAgICAgICAgMCwgMVxyXG4gICAgICAgIF0pO1xyXG4gICAgICAgIHRoaXMudmVydGV4QnVmZmVyID0gbmV3IEJ1ZmZlcl8xLkJ1ZmZlcih0aGlzLnZlcnRpY2VzKTtcclxuICAgICAgICB0aGlzLnV2QnVmZmVyID0gbmV3IEJ1ZmZlcl8xLkJ1ZmZlcih0aGlzLnV2cyk7XHJcbiAgICAgICAgdGhpcy5hZGRBdHRyaWJ1dGUoJ2FWZXJ0ZXhQb3NpdGlvbicsIHRoaXMudmVydGV4QnVmZmVyKVxyXG4gICAgICAgICAgICAuYWRkQXR0cmlidXRlKCdhVGV4dHVyZUNvb3JkJywgdGhpcy51dkJ1ZmZlcilcclxuICAgICAgICAgICAgLmFkZEluZGV4KFswLCAxLCAyLCAwLCAyLCAzXSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIE1hcHMgdHdvIFJlY3RhbmdsZSB0byB0aGUgcXVhZC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1BJWEkuUmVjdGFuZ2xlfSB0YXJnZXRUZXh0dXJlRnJhbWUgLSB0aGUgZmlyc3QgcmVjdGFuZ2xlXHJcbiAgICAgKiBAcGFyYW0ge1BJWEkuUmVjdGFuZ2xlfSBkZXN0aW5hdGlvbkZyYW1lIC0gdGhlIHNlY29uZCByZWN0YW5nbGVcclxuICAgICAqIEByZXR1cm4ge1BJWEkuUXVhZH0gUmV0dXJucyBpdHNlbGYuXHJcbiAgICAgKi9cclxuICAgIG1hcCh0YXJnZXRUZXh0dXJlRnJhbWUsIGRlc3RpbmF0aW9uRnJhbWUpIHtcclxuICAgICAgICB2YXIgeCA9IDA7IC8vIGRlc3RpbmF0aW9uRnJhbWUueCAvIHRhcmdldFRleHR1cmVGcmFtZS53aWR0aDtcclxuICAgICAgICB2YXIgeSA9IDA7IC8vIGRlc3RpbmF0aW9uRnJhbWUueSAvIHRhcmdldFRleHR1cmVGcmFtZS5oZWlnaHQ7XHJcbiAgICAgICAgdGhpcy51dnNbMF0gPSB4O1xyXG4gICAgICAgIHRoaXMudXZzWzFdID0geTtcclxuICAgICAgICB0aGlzLnV2c1syXSA9IHggKyAoZGVzdGluYXRpb25GcmFtZS53aWR0aCAvIHRhcmdldFRleHR1cmVGcmFtZS53aWR0aCk7XHJcbiAgICAgICAgdGhpcy51dnNbM10gPSB5O1xyXG4gICAgICAgIHRoaXMudXZzWzRdID0geCArIChkZXN0aW5hdGlvbkZyYW1lLndpZHRoIC8gdGFyZ2V0VGV4dHVyZUZyYW1lLndpZHRoKTtcclxuICAgICAgICB0aGlzLnV2c1s1XSA9IHkgKyAoZGVzdGluYXRpb25GcmFtZS5oZWlnaHQgLyB0YXJnZXRUZXh0dXJlRnJhbWUuaGVpZ2h0KTtcclxuICAgICAgICB0aGlzLnV2c1s2XSA9IHg7XHJcbiAgICAgICAgdGhpcy51dnNbN10gPSB5ICsgKGRlc3RpbmF0aW9uRnJhbWUuaGVpZ2h0IC8gdGFyZ2V0VGV4dHVyZUZyYW1lLmhlaWdodCk7XHJcbiAgICAgICAgeCA9IGRlc3RpbmF0aW9uRnJhbWUueDtcclxuICAgICAgICB5ID0gZGVzdGluYXRpb25GcmFtZS55O1xyXG4gICAgICAgIHRoaXMudmVydGljZXNbMF0gPSB4O1xyXG4gICAgICAgIHRoaXMudmVydGljZXNbMV0gPSB5O1xyXG4gICAgICAgIHRoaXMudmVydGljZXNbMl0gPSB4ICsgZGVzdGluYXRpb25GcmFtZS53aWR0aDtcclxuICAgICAgICB0aGlzLnZlcnRpY2VzWzNdID0geTtcclxuICAgICAgICB0aGlzLnZlcnRpY2VzWzRdID0geCArIGRlc3RpbmF0aW9uRnJhbWUud2lkdGg7XHJcbiAgICAgICAgdGhpcy52ZXJ0aWNlc1s1XSA9IHkgKyBkZXN0aW5hdGlvbkZyYW1lLmhlaWdodDtcclxuICAgICAgICB0aGlzLnZlcnRpY2VzWzZdID0geDtcclxuICAgICAgICB0aGlzLnZlcnRpY2VzWzddID0geSArIGRlc3RpbmF0aW9uRnJhbWUuaGVpZ2h0O1xyXG4gICAgICAgIHRoaXMuaW52YWxpZGF0ZSgpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBsZWdhY3kgdXBsb2FkIG1ldGhvZCwganVzdCBtYXJrcyBidWZmZXJzIGRpcnR5XHJcbiAgICAgKiBAcmV0dXJucyB7UElYSS5RdWFkVXZ9IFJldHVybnMgaXRzZWxmLlxyXG4gICAgICovXHJcbiAgICBpbnZhbGlkYXRlKCkge1xyXG4gICAgICAgIHRoaXMudmVydGV4QnVmZmVyLl91cGRhdGVJRCsrO1xyXG4gICAgICAgIHRoaXMudXZCdWZmZXIuX3VwZGF0ZUlEKys7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICA7XHJcbn1cclxuZXhwb3J0cy5RdWFkVXYgPSBRdWFkVXY7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IHNldHRpbmdzXzEgPSByZXF1aXJlKFwiLi9zZXR0aW5nc1wiKTtcclxuY2xhc3MgUXVhZHJhdGljVXRpbHMge1xyXG4gICAgc3RhdGljIGN1cnZlTGVuZ3RoKGZyb21YLCBmcm9tWSwgY3BYLCBjcFksIHRvWCwgdG9ZKSB7XHJcbiAgICAgICAgdmFyIGF4ID0gZnJvbVggLSAoMi4wICogY3BYKSArIHRvWDtcclxuICAgICAgICB2YXIgYXkgPSBmcm9tWSAtICgyLjAgKiBjcFkpICsgdG9ZO1xyXG4gICAgICAgIHZhciBieCA9ICgyLjAgKiBjcFgpIC0gKDIuMCAqIGZyb21YKTtcclxuICAgICAgICB2YXIgYnkgPSAoMi4wICogY3BZKSAtICgyLjAgKiBmcm9tWSk7XHJcbiAgICAgICAgdmFyIGEgPSA0LjAgKiAoKGF4ICogYXgpICsgKGF5ICogYXkpKTtcclxuICAgICAgICB2YXIgYiA9IDQuMCAqICgoYXggKiBieCkgKyAoYXkgKiBieSkpO1xyXG4gICAgICAgIHZhciBjID0gKGJ4ICogYngpICsgKGJ5ICogYnkpO1xyXG4gICAgICAgIHZhciBzID0gMi4wICogTWF0aC5zcXJ0KGEgKyBiICsgYyk7XHJcbiAgICAgICAgdmFyIGEyID0gTWF0aC5zcXJ0KGEpO1xyXG4gICAgICAgIHZhciBhMzIgPSAyLjAgKiBhICogYTI7XHJcbiAgICAgICAgdmFyIGMyID0gMi4wICogTWF0aC5zcXJ0KGMpO1xyXG4gICAgICAgIHZhciBiYSA9IGIgLyBhMjtcclxuICAgICAgICByZXR1cm4gKChhMzIgKiBzKVxyXG4gICAgICAgICAgICArIChhMiAqIGIgKiAocyAtIGMyKSlcclxuICAgICAgICAgICAgKyAoKCg0LjAgKiBjICogYSkgLSAoYiAqIGIpKVxyXG4gICAgICAgICAgICAgICAgKiBNYXRoLmxvZygoKDIuMCAqIGEyKSArIGJhICsgcykgLyAoYmEgKyBjMikpKSkgLyAoNC4wICogYTMyKTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQ2FsY3VsYXRlIHRoZSBwb2ludHMgZm9yIGEgcXVhZHJhdGljIGJlemllciBjdXJ2ZSBhbmQgdGhlbiBkcmF3cyBpdC5cclxuICAgICAqIEJhc2VkIG9uOiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy83ODUwOTcvaG93LWRvLWktaW1wbGVtZW50LWEtYmV6aWVyLWN1cnZlLWluLWNcclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNwWCAtIENvbnRyb2wgcG9pbnQgeFxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNwWSAtIENvbnRyb2wgcG9pbnQgeVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRvWCAtIERlc3RpbmF0aW9uIHBvaW50IHhcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0b1kgLSBEZXN0aW5hdGlvbiBwb2ludCB5XHJcbiAgICAgKiBAcGFyYW0ge251bWJlcltdfSBwb2ludHMgLSBQb2ludHMgdG8gYWRkIHNlZ21lbnRzIHRvLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgY3VydmVUbyhjcFgsIGNwWSwgdG9YLCB0b1ksIHBvaW50cykge1xyXG4gICAgICAgIHZhciBmcm9tWCA9IHBvaW50c1twb2ludHMubGVuZ3RoIC0gMl07XHJcbiAgICAgICAgdmFyIGZyb21ZID0gcG9pbnRzW3BvaW50cy5sZW5ndGggLSAxXTtcclxuICAgICAgICB2YXIgbiA9IHNldHRpbmdzXzEuc2V0dGluZ3MuR1JBUEhJQ1NfQ1VSVkVTLl9zZWdtZW50c0NvdW50KFF1YWRyYXRpY1V0aWxzLmN1cnZlTGVuZ3RoKGZyb21YLCBmcm9tWSwgY3BYLCBjcFksIHRvWCwgdG9ZKSk7XHJcbiAgICAgICAgdmFyIHhhID0gMDtcclxuICAgICAgICB2YXIgeWEgPSAwO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDw9IG47ICsraSkge1xyXG4gICAgICAgICAgICB2YXIgaiA9IGkgLyBuO1xyXG4gICAgICAgICAgICB4YSA9IGZyb21YICsgKChjcFggLSBmcm9tWCkgKiBqKTtcclxuICAgICAgICAgICAgeWEgPSBmcm9tWSArICgoY3BZIC0gZnJvbVkpICogaik7XHJcbiAgICAgICAgICAgIHBvaW50cy5wdXNoKHhhICsgKCgoY3BYICsgKCh0b1ggLSBjcFgpICogaikpIC0geGEpICogaiksIHlhICsgKCgoY3BZICsgKCh0b1kgLSBjcFkpICogaikpIC0geWEpICogaikpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIDtcclxufVxyXG5leHBvcnRzLlF1YWRyYXRpY1V0aWxzID0gUXVhZHJhdGljVXRpbHM7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IFNoYXBlU2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL1NoYXBlU2V0dGluZ3NcIik7XHJcbmNsYXNzIFJlY3RhbmdsZSB7XHJcbiAgICBjb25zdHJ1Y3Rvcih4ID0gMCwgeSA9IDAsIHdpZHRoID0gMCwgaGVpZ2h0ID0gMCkge1xyXG4gICAgICAgIGlmICh4ID09PSB2b2lkIDApIHtcclxuICAgICAgICAgICAgeCA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh5ID09PSB2b2lkIDApIHtcclxuICAgICAgICAgICAgeSA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh3aWR0aCA9PT0gdm9pZCAwKSB7XHJcbiAgICAgICAgICAgIHdpZHRoID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGhlaWdodCA9PT0gdm9pZCAwKSB7XHJcbiAgICAgICAgICAgIGhlaWdodCA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAgICAgKiBAZGVmYXVsdCAwXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy54ID0gTnVtYmVyKHgpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAgICAgKiBAZGVmYXVsdCAwXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy55ID0gTnVtYmVyKHkpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAgICAgKiBAZGVmYXVsdCAwXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy53aWR0aCA9IE51bWJlcih3aWR0aCk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICAgICAqIEBkZWZhdWx0IDBcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmhlaWdodCA9IE51bWJlcihoZWlnaHQpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSB0eXBlIG9mIHRoZSBvYmplY3QsIG1haW5seSB1c2VkIHRvIGF2b2lkIGBpbnN0YW5jZW9mYCBjaGVja3NcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAgICAgKiBAcmVhZE9ubHlcclxuICAgICAgICAgKiBAZGVmYXVsdCBQSVhJLlNIQVBFUy5SRUNUXHJcbiAgICAgICAgICogQHNlZSBQSVhJLlNIQVBFU1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMudHlwZSA9IFNoYXBlU2V0dGluZ3NfMS5TaGFwZVNldHRpbmdzLlNIQVBFUy5SRUNUO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiByZXR1cm5zIHRoZSBsZWZ0IGVkZ2Ugb2YgdGhlIHJlY3RhbmdsZVxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgZ2V0IGxlZnQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMueDtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogcmV0dXJucyB0aGUgcmlnaHQgZWRnZSBvZiB0aGUgcmVjdGFuZ2xlXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICBnZXQgcmlnaHQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMueCArIHRoaXMud2lkdGg7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIHJldHVybnMgdGhlIHRvcCBlZGdlIG9mIHRoZSByZWN0YW5nbGVcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIGdldCB0b3AoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMueTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogcmV0dXJucyB0aGUgYm90dG9tIGVkZ2Ugb2YgdGhlIHJlY3RhbmdsZVxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgZ2V0IGJvdHRvbSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy55ICsgdGhpcy5oZWlnaHQ7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIEEgY29uc3RhbnQgZW1wdHkgcmVjdGFuZ2xlLlxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBjb25zdGFudFxyXG4gICAgICogQG1lbWJlciB7UElYSS5SZWN0YW5nbGV9XHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBnZXQgRU1QVFkoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBSZWN0YW5nbGUoMCwgMCwgMCwgMCk7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBjbG9uZSBvZiB0aGlzIFJlY3RhbmdsZVxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4ge1BJWEkuUmVjdGFuZ2xlfSBhIGNvcHkgb2YgdGhlIHJlY3RhbmdsZVxyXG4gICAgICovXHJcbiAgICBjbG9uZSgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFJlY3RhbmdsZSh0aGlzLngsIHRoaXMueSwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDb3BpZXMgYW5vdGhlciByZWN0YW5nbGUgdG8gdGhpcyBvbmUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtQSVhJLlJlY3RhbmdsZX0gcmVjdGFuZ2xlIC0gVGhlIHJlY3RhbmdsZSB0byBjb3B5IGZyb20uXHJcbiAgICAgKiBAcmV0dXJuIHtQSVhJLlJlY3RhbmdsZX0gUmV0dXJucyBpdHNlbGYuXHJcbiAgICAgKi9cclxuICAgIGNvcHlGcm9tKHJlY3RhbmdsZSkge1xyXG4gICAgICAgIHRoaXMueCA9IHJlY3RhbmdsZS54O1xyXG4gICAgICAgIHRoaXMueSA9IHJlY3RhbmdsZS55O1xyXG4gICAgICAgIHRoaXMud2lkdGggPSByZWN0YW5nbGUud2lkdGg7XHJcbiAgICAgICAgdGhpcy5oZWlnaHQgPSByZWN0YW5nbGUuaGVpZ2h0O1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDb3BpZXMgdGhpcyByZWN0YW5nbGUgdG8gYW5vdGhlciBvbmUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtQSVhJLlJlY3RhbmdsZX0gcmVjdGFuZ2xlIC0gVGhlIHJlY3RhbmdsZSB0byBjb3B5IHRvLlxyXG4gICAgICogQHJldHVybiB7UElYSS5SZWN0YW5nbGV9IFJldHVybnMgZ2l2ZW4gcGFyYW1ldGVyLlxyXG4gICAgICovXHJcbiAgICBjb3B5VG8ocmVjdGFuZ2xlKSB7XHJcbiAgICAgICAgcmVjdGFuZ2xlLnggPSB0aGlzLng7XHJcbiAgICAgICAgcmVjdGFuZ2xlLnkgPSB0aGlzLnk7XHJcbiAgICAgICAgcmVjdGFuZ2xlLndpZHRoID0gdGhpcy53aWR0aDtcclxuICAgICAgICByZWN0YW5nbGUuaGVpZ2h0ID0gdGhpcy5oZWlnaHQ7XHJcbiAgICAgICAgcmV0dXJuIHJlY3RhbmdsZTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIHggYW5kIHkgY29vcmRpbmF0ZXMgZ2l2ZW4gYXJlIGNvbnRhaW5lZCB3aXRoaW4gdGhpcyBSZWN0YW5nbGVcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCAtIFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50IHRvIHRlc3RcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQgdG8gdGVzdFxyXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUgeC95IGNvb3JkaW5hdGVzIGFyZSB3aXRoaW4gdGhpcyBSZWN0YW5nbGVcclxuICAgICAqL1xyXG4gICAgY29udGFpbnMoeCwgeSkge1xyXG4gICAgICAgIGlmICh0aGlzLndpZHRoIDw9IDAgfHwgdGhpcy5oZWlnaHQgPD0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh4ID49IHRoaXMueCAmJiB4IDwgdGhpcy54ICsgdGhpcy53aWR0aCkge1xyXG4gICAgICAgICAgICBpZiAoeSA+PSB0aGlzLnkgJiYgeSA8IHRoaXMueSArIHRoaXMuaGVpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFBhZHMgdGhlIHJlY3RhbmdsZSBtYWtpbmcgaXQgZ3JvdyBpbiBhbGwgZGlyZWN0aW9ucy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcGFkZGluZ1ggLSBUaGUgaG9yaXpvbnRhbCBwYWRkaW5nIGFtb3VudC5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwYWRkaW5nWSAtIFRoZSB2ZXJ0aWNhbCBwYWRkaW5nIGFtb3VudC5cclxuICAgICAqL1xyXG4gICAgcGFkKHBhZGRpbmdYLCBwYWRkaW5nWSkge1xyXG4gICAgICAgIHBhZGRpbmdYID0gcGFkZGluZ1ggfHwgMDtcclxuICAgICAgICBwYWRkaW5nWSA9IHBhZGRpbmdZIHx8ICgocGFkZGluZ1kgIT09IDApID8gcGFkZGluZ1ggOiAwKTtcclxuICAgICAgICB0aGlzLnggLT0gcGFkZGluZ1g7XHJcbiAgICAgICAgdGhpcy55IC09IHBhZGRpbmdZO1xyXG4gICAgICAgIHRoaXMud2lkdGggKz0gcGFkZGluZ1ggKiAyO1xyXG4gICAgICAgIHRoaXMuaGVpZ2h0ICs9IHBhZGRpbmdZICogMjtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogRml0cyB0aGlzIHJlY3RhbmdsZSBhcm91bmQgdGhlIHBhc3NlZCBvbmUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtQSVhJLlJlY3RhbmdsZX0gcmVjdGFuZ2xlIC0gVGhlIHJlY3RhbmdsZSB0byBmaXQuXHJcbiAgICAgKi9cclxuICAgIGZpdChyZWN0YW5nbGUpIHtcclxuICAgICAgICB2YXIgeDEgPSBNYXRoLm1heCh0aGlzLngsIHJlY3RhbmdsZS54KTtcclxuICAgICAgICB2YXIgeDIgPSBNYXRoLm1pbih0aGlzLnggKyB0aGlzLndpZHRoLCByZWN0YW5nbGUueCArIHJlY3RhbmdsZS53aWR0aCk7XHJcbiAgICAgICAgdmFyIHkxID0gTWF0aC5tYXgodGhpcy55LCByZWN0YW5nbGUueSk7XHJcbiAgICAgICAgdmFyIHkyID0gTWF0aC5taW4odGhpcy55ICsgdGhpcy5oZWlnaHQsIHJlY3RhbmdsZS55ICsgcmVjdGFuZ2xlLmhlaWdodCk7XHJcbiAgICAgICAgdGhpcy54ID0geDE7XHJcbiAgICAgICAgdGhpcy53aWR0aCA9IE1hdGgubWF4KHgyIC0geDEsIDApO1xyXG4gICAgICAgIHRoaXMueSA9IHkxO1xyXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gTWF0aC5tYXgoeTIgLSB5MSwgMCk7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIEVubGFyZ2VzIHJlY3RhbmdsZSB0aGF0IHdheSBpdHMgY29ybmVycyBsaWUgb24gZ3JpZFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcmVzb2x1dGlvbj0xXSByZXNvbHV0aW9uXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2Vwcz0wLjAwMV0gcHJlY2lzaW9uXHJcbiAgICAgKi9cclxuICAgIGNlaWwocmVzb2x1dGlvbiwgZXBzKSB7XHJcbiAgICAgICAgaWYgKHJlc29sdXRpb24gPT09IHZvaWQgMCkge1xyXG4gICAgICAgICAgICByZXNvbHV0aW9uID0gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGVwcyA9PT0gdm9pZCAwKSB7XHJcbiAgICAgICAgICAgIGVwcyA9IDAuMDAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgeDIgPSBNYXRoLmNlaWwoKHRoaXMueCArIHRoaXMud2lkdGggLSBlcHMpICogcmVzb2x1dGlvbikgLyByZXNvbHV0aW9uO1xyXG4gICAgICAgIHZhciB5MiA9IE1hdGguY2VpbCgodGhpcy55ICsgdGhpcy5oZWlnaHQgLSBlcHMpICogcmVzb2x1dGlvbikgLyByZXNvbHV0aW9uO1xyXG4gICAgICAgIHRoaXMueCA9IE1hdGguZmxvb3IoKHRoaXMueCArIGVwcykgKiByZXNvbHV0aW9uKSAvIHJlc29sdXRpb247XHJcbiAgICAgICAgdGhpcy55ID0gTWF0aC5mbG9vcigodGhpcy55ICsgZXBzKSAqIHJlc29sdXRpb24pIC8gcmVzb2x1dGlvbjtcclxuICAgICAgICB0aGlzLndpZHRoID0geDIgLSB0aGlzLng7XHJcbiAgICAgICAgdGhpcy5oZWlnaHQgPSB5MiAtIHRoaXMueTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogRW5sYXJnZXMgdGhpcyByZWN0YW5nbGUgdG8gaW5jbHVkZSB0aGUgcGFzc2VkIHJlY3RhbmdsZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1BJWEkuUmVjdGFuZ2xlfSByZWN0YW5nbGUgLSBUaGUgcmVjdGFuZ2xlIHRvIGluY2x1ZGUuXHJcbiAgICAgKi9cclxuICAgIGVubGFyZ2UocmVjdGFuZ2xlKSB7XHJcbiAgICAgICAgdmFyIHgxID0gTWF0aC5taW4odGhpcy54LCByZWN0YW5nbGUueCk7XHJcbiAgICAgICAgdmFyIHgyID0gTWF0aC5tYXgodGhpcy54ICsgdGhpcy53aWR0aCwgcmVjdGFuZ2xlLnggKyByZWN0YW5nbGUud2lkdGgpO1xyXG4gICAgICAgIHZhciB5MSA9IE1hdGgubWluKHRoaXMueSwgcmVjdGFuZ2xlLnkpO1xyXG4gICAgICAgIHZhciB5MiA9IE1hdGgubWF4KHRoaXMueSArIHRoaXMuaGVpZ2h0LCByZWN0YW5nbGUueSArIHJlY3RhbmdsZS5oZWlnaHQpO1xyXG4gICAgICAgIHRoaXMueCA9IHgxO1xyXG4gICAgICAgIHRoaXMud2lkdGggPSB4MiAtIHgxO1xyXG4gICAgICAgIHRoaXMueSA9IHkxO1xyXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0geTIgLSB5MTtcclxuICAgIH1cclxuICAgIDtcclxufVxyXG5leHBvcnRzLlJlY3RhbmdsZSA9IFJlY3RhbmdsZTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgVGV4dHVyZV8xID0gcmVxdWlyZShcIi4vVGV4dHVyZVwiKTtcclxuY29uc3QgQmFzZVJlbmRlclRleHR1cmVfMSA9IHJlcXVpcmUoXCIuL0Jhc2VSZW5kZXJUZXh0dXJlXCIpO1xyXG5jbGFzcyBSZW5kZXJUZXh0dXJlIGV4dGVuZHMgVGV4dHVyZV8xLlRleHR1cmUge1xyXG4gICAgY29uc3RydWN0b3IoYmFzZVJlbmRlclRleHR1cmUgPSBudWxsLCBmcmFtZSA9IG51bGwpIHtcclxuICAgICAgICBzdXBlcihiYXNlUmVuZGVyVGV4dHVyZSwgZnJhbWUpO1xyXG4gICAgICAgIHZhciBfbGVnYWN5UmVuZGVyZXIgPSBudWxsO1xyXG4gICAgICAgIGlmICghKGJhc2VSZW5kZXJUZXh0dXJlIGluc3RhbmNlb2YgQmFzZVJlbmRlclRleHR1cmVfMS5CYXNlUmVuZGVyVGV4dHVyZSkpIHtcclxuICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgcHJlZmVyLXJlc3QtcGFyYW1zLCBuby1jb25zb2xlICovXHJcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IGFyZ3VtZW50c1sxXTtcclxuICAgICAgICAgICAgdmFyIGhlaWdodCA9IGFyZ3VtZW50c1syXTtcclxuICAgICAgICAgICAgdmFyIHNjYWxlTW9kZSA9IGFyZ3VtZW50c1szXTtcclxuICAgICAgICAgICAgdmFyIHJlc29sdXRpb24gPSBhcmd1bWVudHNbNF07XHJcbiAgICAgICAgICAgIC8vIHdlIGhhdmUgYW4gb2xkIHJlbmRlciB0ZXh0dXJlLi5cclxuICAgICAgICAgICAgY29uc29sZS53YXJuKChcIlBsZWFzZSB1c2UgUmVuZGVyVGV4dHVyZS5jcmVhdGUoXCIgKyB3aWR0aCArIFwiLCBcIiArIGhlaWdodCArIFwiKSBpbnN0ZWFkIG9mIHRoZSBjdG9yIGRpcmVjdGx5LlwiKSk7XHJcbiAgICAgICAgICAgIF9sZWdhY3lSZW5kZXJlciA9IGFyZ3VtZW50c1swXTtcclxuICAgICAgICAgICAgLyogZXNsaW50LWVuYWJsZSBwcmVmZXItcmVzdC1wYXJhbXMsIG5vLWNvbnNvbGUgKi9cclxuICAgICAgICAgICAgZnJhbWUgPSBudWxsO1xyXG4gICAgICAgICAgICBiYXNlUmVuZGVyVGV4dHVyZSA9IG5ldyBCYXNlUmVuZGVyVGV4dHVyZV8xLkJhc2VSZW5kZXJUZXh0dXJlKHtcclxuICAgICAgICAgICAgICAgIHdpZHRoOiB3aWR0aCxcclxuICAgICAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0LFxyXG4gICAgICAgICAgICAgICAgc2NhbGVNb2RlOiBzY2FsZU1vZGUsXHJcbiAgICAgICAgICAgICAgICByZXNvbHV0aW9uOiByZXNvbHV0aW9uLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5sZWdhY3lSZW5kZXJlciA9IF9sZWdhY3lSZW5kZXJlcjtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGlzIHdpbGwgbGV0IHRoZSByZW5kZXJlciBrbm93IGlmIHRoZSB0ZXh0dXJlIGlzIHZhbGlkLiBJZiBpdCdzIG5vdCB0aGVuIGl0IGNhbm5vdCBiZSByZW5kZXJlZC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy52YWxpZCA9IHRydWU7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRmlsdGVyU3lzdGVtIHRlbXBvcmFyeSBzdG9yYWdlXHJcbiAgICAgICAgICogQHByb3RlY3RlZFxyXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuUmVjdGFuZ2xlfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuZmlsdGVyRnJhbWUgPSBudWxsO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICogVGhlIGtleSBmb3IgcG9vbGVkIHRleHR1cmUgb2YgRmlsdGVyU3lzdGVtXHJcbiAgICAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgICAgKiBAbWVtYmVyIHtzdHJpbmd9XHJcbiAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmZpbHRlclBvb2xLZXkgPSBudWxsO1xyXG4gICAgICAgIHRoaXMudXBkYXRlVXZzKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICogUmVzaXplcyB0aGUgUmVuZGVyVGV4dHVyZS5cclxuICAgICpcclxuICAgICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIC0gVGhlIHdpZHRoIHRvIHJlc2l6ZSB0by5cclxuICAgICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCAtIFRoZSBoZWlnaHQgdG8gcmVzaXplIHRvLlxyXG4gICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtyZXNpemVCYXNlVGV4dHVyZT10cnVlXSAtIFNob3VsZCB0aGUgYmFzZVRleHR1cmUud2lkdGggYW5kIGhlaWdodCB2YWx1ZXMgYmUgcmVzaXplZCBhcyB3ZWxsP1xyXG4gICAgKi9cclxuICAgIHJlc2l6ZSh3aWR0aCwgaGVpZ2h0LCByZXNpemVCYXNlVGV4dHVyZSkge1xyXG4gICAgICAgIGlmIChyZXNpemVCYXNlVGV4dHVyZSA9PT0gdm9pZCAwKSB7XHJcbiAgICAgICAgICAgIHJlc2l6ZUJhc2VUZXh0dXJlID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgd2lkdGggPSBNYXRoLmNlaWwod2lkdGgpO1xyXG4gICAgICAgIGhlaWdodCA9IE1hdGguY2VpbChoZWlnaHQpO1xyXG4gICAgICAgIC8vIFRPRE8gLSBjb3VsZCBiZSBub3QgcmVxdWlyZWQuLlxyXG4gICAgICAgIHRoaXMudmFsaWQgPSAod2lkdGggPiAwICYmIGhlaWdodCA+IDApO1xyXG4gICAgICAgIHRoaXMuX2ZyYW1lLndpZHRoID0gdGhpcy5vcmlnLndpZHRoID0gd2lkdGg7XHJcbiAgICAgICAgdGhpcy5fZnJhbWUuaGVpZ2h0ID0gdGhpcy5vcmlnLmhlaWdodCA9IGhlaWdodDtcclxuICAgICAgICBpZiAocmVzaXplQmFzZVRleHR1cmUpIHtcclxuICAgICAgICAgICAgdGhpcy5iYXNlVGV4dHVyZS5yZXNpemUod2lkdGgsIGhlaWdodCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMudXBkYXRlVXZzKCk7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIEEgc2hvcnQgaGFuZCB3YXkgb2YgY3JlYXRpbmcgYSByZW5kZXIgdGV4dHVyZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIC0gT3B0aW9uc1xyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLndpZHRoPTEwMF0gLSBUaGUgd2lkdGggb2YgdGhlIHJlbmRlciB0ZXh0dXJlXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuaGVpZ2h0PTEwMF0gLSBUaGUgaGVpZ2h0IG9mIHRoZSByZW5kZXIgdGV4dHVyZVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnNjYWxlTW9kZT1QSVhJLnNldHRpbmdzLlNDQUxFX01PREVdIC0gU2VlIHtAbGluayBQSVhJLlNDQUxFX01PREVTfSBmb3IgcG9zc2libGUgdmFsdWVzXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMucmVzb2x1dGlvbj0xXSAtIFRoZSByZXNvbHV0aW9uIC8gZGV2aWNlIHBpeGVsIHJhdGlvIG9mIHRoZSB0ZXh0dXJlIGJlaW5nIGdlbmVyYXRlZFxyXG4gICAgICogQHJldHVybiB7UElYSS5SZW5kZXJUZXh0dXJlfSBUaGUgbmV3IHJlbmRlciB0ZXh0dXJlXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBjcmVhdGUob3B0aW9ucywgaGVpZ2h0ID0gbnVsbCwgc2NhbGVNb2RlID0gbnVsbCwgcmVzb2x1dGlvbiA9IG51bGwpIHtcclxuICAgICAgICAvLyBmYWxsYmFjaywgb2xkLXN0eWxlOiBjcmVhdGUod2lkdGgsIGhlaWdodCwgc2NhbGVNb2RlLCByZXNvbHV0aW9uKVxyXG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgcHJlZmVyLXJlc3QtcGFyYW1zICovXHJcbiAgICAgICAgICAgIG9wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgICAgICB3aWR0aDogb3B0aW9ucyxcclxuICAgICAgICAgICAgICAgIGhlaWdodDogYXJndW1lbnRzWzFdLFxyXG4gICAgICAgICAgICAgICAgc2NhbGVNb2RlOiBhcmd1bWVudHNbMl0sXHJcbiAgICAgICAgICAgICAgICByZXNvbHV0aW9uOiBhcmd1bWVudHNbM10sXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8qIGVzbGludC1lbmFibGUgcHJlZmVyLXJlc3QtcGFyYW1zICovXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgUmVuZGVyVGV4dHVyZShuZXcgQmFzZVJlbmRlclRleHR1cmVfMS5CYXNlUmVuZGVyVGV4dHVyZShvcHRpb25zKSk7XHJcbiAgICB9XHJcbiAgICA7XHJcbn1cclxuZXhwb3J0cy5SZW5kZXJUZXh0dXJlID0gUmVuZGVyVGV4dHVyZTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgU3lzdGVtXzEgPSByZXF1aXJlKFwiLi9TeXN0ZW1cIik7XHJcbmNvbnN0IFJlY3RhbmdsZV8xID0gcmVxdWlyZShcIi4vUmVjdGFuZ2xlXCIpO1xyXG5jbGFzcyBSZW5kZXJUZXh0dXJlU3lzdGVtIGV4dGVuZHMgU3lzdGVtXzEuU3lzdGVtIHtcclxuICAgIGNvbnN0cnVjdG9yKHJlbmRlcmVyKSB7XHJcbiAgICAgICAgc3VwZXIocmVuZGVyZXIpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBjbGVhciBiYWNrZ3JvdW5kIGNvbG9yIGFzIHJnYmFcclxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJbXX1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmNsZWFyQ29sb3IgPSByZW5kZXJlci5fYmFja2dyb3VuZENvbG9yUmdiYTtcclxuICAgICAgICAvLyBUT0RPIG1vdmUgdGhpcyBwcm9wZXJ0eSBzb21ld2hlcmUgZWxzZSFcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBMaXN0IG9mIG1hc2tzIGZvciB0aGUgU3RlbmNpbFN5c3RlbVxyXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuR3JhcGhpY3NbXX1cclxuICAgICAgICAgKiBAcmVhZG9ubHlcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmRlZmF1bHRNYXNrU3RhY2sgPSBbXTtcclxuICAgICAgICAvLyBlbXB0eSByZW5kZXIgdGV4dHVyZT9cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZW5kZXIgdGV4dHVyZVxyXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuUmVuZGVyVGV4dHVyZX1cclxuICAgICAgICAgKiBAcmVhZG9ubHlcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmN1cnJlbnQgPSBudWxsO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNvdXJjZSBmcmFtZVxyXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuUmVjdGFuZ2xlfVxyXG4gICAgICAgICAqIEByZWFkb25seVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuc291cmNlRnJhbWUgPSBuZXcgUmVjdGFuZ2xlXzEuUmVjdGFuZ2xlKCk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRGVzdGluYXRpb24gZnJhbWVcclxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLlJlY3RhbmdsZX1cclxuICAgICAgICAgKiBAcmVhZG9ubHlcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uRnJhbWUgPSBuZXcgUmVjdGFuZ2xlXzEuUmVjdGFuZ2xlKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEJpbmQgdGhlIGN1cnJlbnQgcmVuZGVyIHRleHR1cmVcclxuICAgICAqIEBwYXJhbSB7UElYSS5SZW5kZXJUZXh0dXJlfSByZW5kZXJUZXh0dXJlXHJcbiAgICAgKiBAcGFyYW0ge1BJWEkuUmVjdGFuZ2xlfSBzb3VyY2VGcmFtZVxyXG4gICAgICogQHBhcmFtIHtQSVhJLlJlY3RhbmdsZX0gZGVzdGluYXRpb25GcmFtZVxyXG4gICAgICovXHJcbiAgICBiaW5kKHJlbmRlclRleHR1cmUsIHNvdXJjZUZyYW1lID0gbnVsbCwgZGVzdGluYXRpb25GcmFtZSA9IG51bGwpIHtcclxuICAgICAgICBpZiAocmVuZGVyVGV4dHVyZSA9PT0gdm9pZCAwKSB7XHJcbiAgICAgICAgICAgIHJlbmRlclRleHR1cmUgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmN1cnJlbnQgPSByZW5kZXJUZXh0dXJlO1xyXG4gICAgICAgIHZhciByZW5kZXJlciA9IHRoaXMucmVuZGVyZXI7XHJcbiAgICAgICAgdmFyIHJlc29sdXRpb247XHJcbiAgICAgICAgaWYgKHJlbmRlclRleHR1cmUpIHtcclxuICAgICAgICAgICAgdmFyIGJhc2VUZXh0dXJlID0gcmVuZGVyVGV4dHVyZS5iYXNlVGV4dHVyZTtcclxuICAgICAgICAgICAgcmVzb2x1dGlvbiA9IGJhc2VUZXh0dXJlLnJlc29sdXRpb247XHJcbiAgICAgICAgICAgIGlmICghZGVzdGluYXRpb25GcmFtZSkge1xyXG4gICAgICAgICAgICAgICAgUmVuZGVyVGV4dHVyZVN5c3RlbS50ZW1wUmVjdC53aWR0aCA9IGJhc2VUZXh0dXJlLnJlYWxXaWR0aDtcclxuICAgICAgICAgICAgICAgIFJlbmRlclRleHR1cmVTeXN0ZW0udGVtcFJlY3QuaGVpZ2h0ID0gYmFzZVRleHR1cmUucmVhbEhlaWdodDtcclxuICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uRnJhbWUgPSBSZW5kZXJUZXh0dXJlU3lzdGVtLnRlbXBSZWN0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghc291cmNlRnJhbWUpIHtcclxuICAgICAgICAgICAgICAgIHNvdXJjZUZyYW1lID0gZGVzdGluYXRpb25GcmFtZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLmZyYW1lYnVmZmVyLmJpbmQoYmFzZVRleHR1cmUuZnJhbWVidWZmZXIsIGRlc3RpbmF0aW9uRnJhbWUpO1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnByb2plY3Rpb24udXBkYXRlKGRlc3RpbmF0aW9uRnJhbWUsIHNvdXJjZUZyYW1lLCByZXNvbHV0aW9uLCBmYWxzZSk7XHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuc3RlbmNpbC5zZXRNYXNrU3RhY2soYmFzZVRleHR1cmUuc3RlbmNpbE1hc2tTdGFjayk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXNvbHV0aW9uID0gdGhpcy5yZW5kZXJlci5yZXNvbHV0aW9uO1xyXG4gICAgICAgICAgICAvLyBUT0RPIHRoZXNlIHZhbGlkYXRpb24gY2hlY2tzIGhhcHBlbiBkZWVwZXIgZG93bi4uXHJcbiAgICAgICAgICAgIC8vIHRoaW5nIHRoZXkgY2FuIGJlIGF2b2lkZWQuLlxyXG4gICAgICAgICAgICBpZiAoIWRlc3RpbmF0aW9uRnJhbWUpIHtcclxuICAgICAgICAgICAgICAgIFJlbmRlclRleHR1cmVTeXN0ZW0udGVtcFJlY3Qud2lkdGggPSByZW5kZXJlci53aWR0aDtcclxuICAgICAgICAgICAgICAgIFJlbmRlclRleHR1cmVTeXN0ZW0udGVtcFJlY3QuaGVpZ2h0ID0gcmVuZGVyZXIuaGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgZGVzdGluYXRpb25GcmFtZSA9IFJlbmRlclRleHR1cmVTeXN0ZW0udGVtcFJlY3Q7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFzb3VyY2VGcmFtZSkge1xyXG4gICAgICAgICAgICAgICAgc291cmNlRnJhbWUgPSBkZXN0aW5hdGlvbkZyYW1lO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJlbmRlcmVyLmZyYW1lYnVmZmVyLmJpbmQobnVsbCwgZGVzdGluYXRpb25GcmFtZSk7XHJcbiAgICAgICAgICAgIC8vIFRPRE8gc3RvcmUgdGhpcy4uXHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIucHJvamVjdGlvbi51cGRhdGUoZGVzdGluYXRpb25GcmFtZSwgc291cmNlRnJhbWUsIHJlc29sdXRpb24sIHRydWUpO1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnN0ZW5jaWwuc2V0TWFza1N0YWNrKHRoaXMuZGVmYXVsdE1hc2tTdGFjayk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuc291cmNlRnJhbWUuY29weUZyb20oc291cmNlRnJhbWUpO1xyXG4gICAgICAgIHRoaXMuZGVzdGluYXRpb25GcmFtZS54ID0gZGVzdGluYXRpb25GcmFtZS54IC8gcmVzb2x1dGlvbjtcclxuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uRnJhbWUueSA9IGRlc3RpbmF0aW9uRnJhbWUueSAvIHJlc29sdXRpb247XHJcbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbkZyYW1lLndpZHRoID0gZGVzdGluYXRpb25GcmFtZS53aWR0aCAvIHJlc29sdXRpb247XHJcbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbkZyYW1lLmhlaWdodCA9IGRlc3RpbmF0aW9uRnJhbWUuaGVpZ2h0IC8gcmVzb2x1dGlvbjtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogRXJhc2VzIHRoZSByZW5kZXIgdGV4dHVyZSBhbmQgZmlsbHMgdGhlIGRyYXdpbmcgYXJlYSB3aXRoIGEgY29sb3VyXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJbXX0gW2NsZWFyQ29sb3JdIC0gVGhlIGNvbG9yIGFzIHJnYmEsIGRlZmF1bHQgdG8gdXNlIHRoZSByZW5kZXJlciBiYWNrZ3JvdW5kQ29sb3JcclxuICAgICAqIEByZXR1cm4ge1BJWEkuUmVuZGVyZXJ9IFJldHVybnMgaXRzZWxmLlxyXG4gICAgICovXHJcbiAgICBjbGVhcihjbGVhckNvbG9yID0gbnVsbCkge1xyXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnQpIHtcclxuICAgICAgICAgICAgY2xlYXJDb2xvciA9IGNsZWFyQ29sb3IgfHwgdGhpcy5jdXJyZW50LmJhc2VUZXh0dXJlLmNsZWFyQ29sb3I7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjbGVhckNvbG9yID0gY2xlYXJDb2xvciB8fCB0aGlzLmNsZWFyQ29sb3I7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMucmVuZGVyZXIuZnJhbWVidWZmZXIuY2xlYXIoY2xlYXJDb2xvclswXSwgY2xlYXJDb2xvclsxXSwgY2xlYXJDb2xvclsyXSwgY2xlYXJDb2xvclszXSk7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICByZXNpemUoKSB7XHJcbiAgICAgICAgLy8gcmVzaXplIHRoZSByb290IG9ubHkhXHJcbiAgICAgICAgdGhpcy5iaW5kKG51bGwpO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXNldHMgcmVuZGVyVGV4dHVyZSBzdGF0ZVxyXG4gICAgICovXHJcbiAgICByZXNldCgpIHtcclxuICAgICAgICB0aGlzLmJpbmQobnVsbCk7XHJcbiAgICB9XHJcbiAgICA7XHJcbn1cclxuUmVuZGVyVGV4dHVyZVN5c3RlbS50ZW1wUmVjdCA9IG5ldyBSZWN0YW5nbGVfMS5SZWN0YW5nbGUoKTtcclxuZXhwb3J0cy5SZW5kZXJUZXh0dXJlU3lzdGVtID0gUmVuZGVyVGV4dHVyZVN5c3RlbTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgQWJzdHJhY3RSZW5kZXJlcl8xID0gcmVxdWlyZShcIi4vQWJzdHJhY3RSZW5kZXJlclwiKTtcclxuY29uc3QgVW5pZm9ybUdyb3VwXzEgPSByZXF1aXJlKFwiLi9Vbmlmb3JtR3JvdXBcIik7XHJcbmNvbnN0IE1hdHJpeF8xID0gcmVxdWlyZShcIi4vTWF0cml4XCIpO1xyXG5jb25zdCBFdmVudF8xID0gcmVxdWlyZShcIi4vRXZlbnRcIik7XHJcbmNvbnN0IEJhdGNoUmVuZGVyZXJfMSA9IHJlcXVpcmUoXCIuL0JhdGNoUmVuZGVyZXJcIik7XHJcbmNvbnN0IEJhdGNoU3lzdGVtXzEgPSByZXF1aXJlKFwiLi9CYXRjaFN5c3RlbVwiKTtcclxuY29uc3QgUmVuZGVyVGV4dHVyZVN5c3RlbV8xID0gcmVxdWlyZShcIi4vUmVuZGVyVGV4dHVyZVN5c3RlbVwiKTtcclxuY29uc3QgRmlsdGVyU3lzdGVtXzEgPSByZXF1aXJlKFwiLi9GaWx0ZXJTeXN0ZW1cIik7XHJcbmNvbnN0IFRleHR1cmVHQ1N5c3RlbV8xID0gcmVxdWlyZShcIi4vVGV4dHVyZUdDU3lzdGVtXCIpO1xyXG5jb25zdCBQcm9qZWN0aW9uU3lzdGVtXzEgPSByZXF1aXJlKFwiLi9Qcm9qZWN0aW9uU3lzdGVtXCIpO1xyXG5jb25zdCBTdGVuY2lsU3lzdGVtXzEgPSByZXF1aXJlKFwiLi9TdGVuY2lsU3lzdGVtXCIpO1xyXG5jb25zdCBGcmFtZWJ1ZmZlclN5c3RlbV8xID0gcmVxdWlyZShcIi4vRnJhbWVidWZmZXJTeXN0ZW1cIik7XHJcbmNvbnN0IEdlb21ldHJ5U3lzdGVtXzEgPSByZXF1aXJlKFwiLi9HZW9tZXRyeVN5c3RlbVwiKTtcclxuY29uc3QgVGV4dHVyZVN5c3RlbV8xID0gcmVxdWlyZShcIi4vVGV4dHVyZVN5c3RlbVwiKTtcclxuY29uc3QgU2hhZGVyU3lzdGVtXzEgPSByZXF1aXJlKFwiLi9TaGFkZXJTeXN0ZW1cIik7XHJcbmNvbnN0IFN0YXRlU3lzdGVtXzEgPSByZXF1aXJlKFwiLi9TdGF0ZVN5c3RlbVwiKTtcclxuY29uc3QgQ29udGV4dFN5c3RlbV8xID0gcmVxdWlyZShcIi4vQ29udGV4dFN5c3RlbVwiKTtcclxuY29uc3QgTWFza1N5c3RlbV8xID0gcmVxdWlyZShcIi4vTWFza1N5c3RlbVwiKTtcclxuY29uc3QgRGlzcGxheVNldHRpbmdzXzEgPSByZXF1aXJlKFwiLi9EaXNwbGF5U2V0dGluZ3NcIik7XHJcbmNvbnN0IFRpbGluZ1Nwcml0ZVJlbmRlcmVyXzEgPSByZXF1aXJlKFwiLi9UaWxpbmdTcHJpdGVSZW5kZXJlclwiKTtcclxuY29uc3QgQWNjZXNzaWJpbGl0eU1hbmFnZXJfMSA9IHJlcXVpcmUoXCIuL0FjY2Vzc2liaWxpdHlNYW5hZ2VyXCIpO1xyXG5jb25zdCBFeHRyYWN0XzEgPSByZXF1aXJlKFwiLi9FeHRyYWN0XCIpO1xyXG5jb25zdCBJbnRlcmFjdGlvbk1hbmFnZXJfMSA9IHJlcXVpcmUoXCIuL0ludGVyYWN0aW9uTWFuYWdlclwiKTtcclxuY29uc3QgUGFydGljbGVSZW5kZXJlcl8xID0gcmVxdWlyZShcIi4vUGFydGljbGVSZW5kZXJlclwiKTtcclxuY29uc3QgUHJlcGFyZV8xID0gcmVxdWlyZShcIi4vUHJlcGFyZVwiKTtcclxuY29uc3QgUnVubmVyXzEgPSByZXF1aXJlKFwiLi9SdW5uZXJcIik7XHJcbmNsYXNzIFJlbmRlcmVyIGV4dGVuZHMgQWJzdHJhY3RSZW5kZXJlcl8xLkFic3RyYWN0UmVuZGVyZXIge1xyXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xyXG4gICAgICAgIHN1cGVyKCdXZWJHTCcsIG9wdGlvbnMpO1xyXG4gICAgICAgIHRoaXMucGx1Z2lucyA9IHt9O1xyXG4gICAgICAgIHRoaXMudHlwZSA9IERpc3BsYXlTZXR0aW5nc18xLkRpc3BsYXlTZXR0aW5ncy5SRU5ERVJFUl9UWVBFLldFQkdMO1xyXG4gICAgICAgIHRoaXMuZ2wgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuQ09OVEVYVF9VSUQgPSAwO1xyXG4gICAgICAgIHRoaXMucnVubmVycyA9IHtcclxuICAgICAgICAgICAgZGVzdHJveTogbmV3IFJ1bm5lcl8xLlJ1bm5lcignZGVzdHJveScpLFxyXG4gICAgICAgICAgICBjb250ZXh0Q2hhbmdlOiBuZXcgUnVubmVyXzEuUnVubmVyKCdjb250ZXh0Q2hhbmdlJywgMSksXHJcbiAgICAgICAgICAgIHJlc2V0OiBuZXcgUnVubmVyXzEuUnVubmVyKCdyZXNldCcpLFxyXG4gICAgICAgICAgICB1cGRhdGU6IG5ldyBSdW5uZXJfMS5SdW5uZXIoJ3VwZGF0ZScpLFxyXG4gICAgICAgICAgICBwb3N0cmVuZGVyOiBuZXcgUnVubmVyXzEuUnVubmVyKCdwb3N0cmVuZGVyJyksXHJcbiAgICAgICAgICAgIHByZXJlbmRlcjogbmV3IFJ1bm5lcl8xLlJ1bm5lcigncHJlcmVuZGVyJyksXHJcbiAgICAgICAgICAgIHJlc2l6ZTogbmV3IFJ1bm5lcl8xLlJ1bm5lcigncmVzaXplJywgMiksXHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLmdsb2JhbFVuaWZvcm1zID0gbmV3IFVuaWZvcm1Hcm91cF8xLlVuaWZvcm1Hcm91cCh7XHJcbiAgICAgICAgICAgIHByb2plY3Rpb25NYXRyaXg6IG5ldyBNYXRyaXhfMS5NYXRyaXgoKSxcclxuICAgICAgICB9LCB0cnVlKTtcclxuICAgICAgICB0aGlzLmFkZFN5c3RlbShNYXNrU3lzdGVtXzEuTWFza1N5c3RlbSwgJ21hc2snKVxyXG4gICAgICAgICAgICAuYWRkU3lzdGVtKENvbnRleHRTeXN0ZW1fMS5Db250ZXh0U3lzdGVtLCAnY29udGV4dCcpXHJcbiAgICAgICAgICAgIC5hZGRTeXN0ZW0oU3RhdGVTeXN0ZW1fMS5TdGF0ZVN5c3RlbSwgJ3N0YXRlJylcclxuICAgICAgICAgICAgLmFkZFN5c3RlbShTaGFkZXJTeXN0ZW1fMS5TaGFkZXJTeXN0ZW0sICdzaGFkZXInKVxyXG4gICAgICAgICAgICAuYWRkU3lzdGVtKFRleHR1cmVTeXN0ZW1fMS5UZXh0dXJlU3lzdGVtLCAndGV4dHVyZScpXHJcbiAgICAgICAgICAgIC5hZGRTeXN0ZW0oR2VvbWV0cnlTeXN0ZW1fMS5HZW9tZXRyeVN5c3RlbSwgJ2dlb21ldHJ5JylcclxuICAgICAgICAgICAgLmFkZFN5c3RlbShGcmFtZWJ1ZmZlclN5c3RlbV8xLkZyYW1lYnVmZmVyU3lzdGVtLCAnZnJhbWVidWZmZXInKVxyXG4gICAgICAgICAgICAuYWRkU3lzdGVtKFN0ZW5jaWxTeXN0ZW1fMS5TdGVuY2lsU3lzdGVtLCAnc3RlbmNpbCcpXHJcbiAgICAgICAgICAgIC5hZGRTeXN0ZW0oUHJvamVjdGlvblN5c3RlbV8xLlByb2plY3Rpb25TeXN0ZW0sICdwcm9qZWN0aW9uJylcclxuICAgICAgICAgICAgLmFkZFN5c3RlbShUZXh0dXJlR0NTeXN0ZW1fMS5UZXh0dXJlR0NTeXN0ZW0sICd0ZXh0dXJlR0MnKVxyXG4gICAgICAgICAgICAuYWRkU3lzdGVtKEZpbHRlclN5c3RlbV8xLkZpbHRlclN5c3RlbSwgJ2ZpbHRlcicpXHJcbiAgICAgICAgICAgIC5hZGRTeXN0ZW0oUmVuZGVyVGV4dHVyZVN5c3RlbV8xLlJlbmRlclRleHR1cmVTeXN0ZW0sICdyZW5kZXJUZXh0dXJlJylcclxuICAgICAgICAgICAgLmFkZFN5c3RlbShCYXRjaFN5c3RlbV8xLkJhdGNoU3lzdGVtLCAnYmF0Y2gnKTtcclxuICAgICAgICB0aGlzLmluaXRQbHVnaW5zKFJlbmRlcmVyLl9fcGx1Z2lucyk7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMuY29udGV4dCkge1xyXG4gICAgICAgICAgICB0aGlzLmNvbnRleHQuaW5pdEZyb21Db250ZXh0KG9wdGlvbnMuY29udGV4dCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmNvbnRleHQuaW5pdEZyb21PcHRpb25zKHtcclxuICAgICAgICAgICAgICAgIGFscGhhOiB0aGlzLnRyYW5zcGFyZW50LFxyXG4gICAgICAgICAgICAgICAgYW50aWFsaWFzOiBvcHRpb25zLmFudGlhbGlhcyxcclxuICAgICAgICAgICAgICAgIHByZW11bHRpcGxpZWRBbHBoYTogdGhpcy50cmFuc3BhcmVudCxcclxuICAgICAgICAgICAgICAgIHN0ZW5jaWw6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBwcmVzZXJ2ZURyYXdpbmdCdWZmZXI6IG9wdGlvbnMucHJlc2VydmVEcmF3aW5nQnVmZmVyLFxyXG4gICAgICAgICAgICAgICAgcG93ZXJQcmVmZXJlbmNlOiB0aGlzLm9wdGlvbnMucG93ZXJQcmVmZXJlbmNlLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5yZW5kZXJpbmdUb1NjcmVlbiA9IHRydWU7XHJcbiAgICAgICAgLy8gICAgIHNheUhlbGxvKHRoaXMuY29udGV4dC53ZWJHTFZlcnNpb24gPT09IDIgPyAnV2ViR0wgMicgOiAnV2ViR0wgMScpO1xyXG4gICAgICAgIHRoaXMucmVzaXplKHRoaXMub3B0aW9ucy53aWR0aCwgdGhpcy5vcHRpb25zLmhlaWdodCk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgcmVnaXN0ZXJQbHVnaW4ocGx1Z2luTmFtZSwgY3Rvcikge1xyXG4gICAgICAgIFJlbmRlcmVyLl9fcGx1Z2lucyA9IFJlbmRlcmVyLl9fcGx1Z2lucyB8fCB7fTtcclxuICAgICAgICBSZW5kZXJlci5fX3BsdWdpbnNbcGx1Z2luTmFtZV0gPSBjdG9yO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgaW5pdFBsdWdpbnMoc3RhdGljTWFwKSB7XHJcbiAgICAgICAgZm9yICh2YXIgbyBpbiBzdGF0aWNNYXApIHtcclxuICAgICAgICAgICAgdGhpcy5wbHVnaW5zW29dID0gbmV3IChzdGF0aWNNYXBbb10pKHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIDtcclxuICAgIGFkZFN5c3RlbShDbGFzc1JlZiwgbmFtZSkge1xyXG4gICAgICAgIGlmICghbmFtZSkge1xyXG4gICAgICAgICAgICBuYW1lID0gQ2xhc3NSZWYubmFtZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHN5c3RlbSA9IG5ldyBDbGFzc1JlZih0aGlzKTtcclxuICAgICAgICBpZiAodGhpc1tuYW1lXSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKFwiV2hvb3BzISBUaGUgbmFtZSBcXFwiXCIgKyBuYW1lICsgXCJcXFwiIGlzIGFscmVhZHkgaW4gdXNlXCIpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpc1tuYW1lXSA9IHN5c3RlbTtcclxuICAgICAgICBmb3IgKHZhciBpIGluIHRoaXMucnVubmVycykge1xyXG4gICAgICAgICAgICB0aGlzLnJ1bm5lcnNbaV0uYWRkKHN5c3RlbSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEZpcmVkIGFmdGVyIHJlbmRlcmluZyBmaW5pc2hlcy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBldmVudCBQSVhJLlJlbmRlcmVyI3Bvc3RyZW5kZXJcclxuICAgICAgICAgKi9cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBGaXJlZCBiZWZvcmUgcmVuZGVyaW5nIHN0YXJ0cy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBldmVudCBQSVhJLlJlbmRlcmVyI3ByZXJlbmRlclxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEZpcmVkIHdoZW4gdGhlIFdlYkdMIGNvbnRleHQgaXMgc2V0LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGV2ZW50IFBJWEkuUmVuZGVyZXIjY29udGV4dFxyXG4gICAgICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCAtIFdlYkdMIGNvbnRleHQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvLyBwcm90ZWN0ZWQgaGFuZGxlQ29udGV4dENoYW5nZSA9IChldmVudDpFdmVudCk9PlxyXG4gICAgLy8ge1xyXG4gICAgLy8gXHR0aGlzLnBsdWdpbnMucGFydGljbGUuY29udGV4dENoYW5nZSh0aGlzLmNvbnRleHQuZ2wpXHJcbiAgICAvLyBcdHRoaXMuZnJhbWVidWZmZXIuY29udGV4dENoYW5nZSh0aGlzLmNvbnRleHQuZ2wpXHRcdFxyXG4gICAgLy8gXHR0aGlzLnNoYWRlci5jb250ZXh0Q2hhbmdlKHRoaXMuY29udGV4dC5nbClcclxuICAgIC8vIFx0dGhpcy5nZW9tZXRyeS5jb250ZXh0Q2hhbmdlKCk7XHJcbiAgICAvLyBcdHRoaXMuc3RhdGUuY29udGV4dENoYW5nZSh0aGlzLmNvbnRleHQuZ2wpXHJcbiAgICAvLyBcdHRoaXMudGV4dHVyZS5jb250ZXh0Q2hhbmdlKCk7XHJcbiAgICAvLyBcdHRoaXMuZnJhbWVidWZmZXIuY29udGV4dENoYW5nZSh0aGlzLmNvbnRleHQuZ2wpXHJcbiAgICAvLyBcdHRoaXMuc3RlbmNpbC5jb250ZXh0Q2hhbmdlKHRoaXMuY29udGV4dC5nbClcclxuICAgIC8vIFx0dGhpcy5wcm9qZWN0aW9uLmNvbnRleHRDaGFuZ2UodGhpcy5jb250ZXh0LmdsKVxyXG4gICAgLy8gXHR0aGlzLnRleHR1cmVHQy5jb250ZXh0Q2hhbmdlKHRoaXMuY29udGV4dC5nbClcclxuICAgIC8vIFx0dGhpcy5maWx0ZXIuY29udGV4dENoYW5nZSh0aGlzLmNvbnRleHQuZ2wpXHJcbiAgICAvLyBcdHRoaXMucmVuZGVyVGV4dHVyZS5jb250ZXh0Q2hhbmdlKHRoaXMuY29udGV4dC5nbClcclxuICAgIC8vIFx0dGhpcy5iYXRjaC5jb250ZXh0Q2hhbmdlKHRoaXMuY29udGV4dC5nbClcclxuICAgIC8vIFx0dGhpcy5tYXNrLmNvbnRleHRDaGFuZ2UodGhpcy5jb250ZXh0LmdsKTtcclxuICAgIC8vIFx0dGhpcy5wbHVnaW5zLmJhdGNoLmNvbnRleHRDaGFuZ2UoKTtcdFx0XHJcbiAgICAvLyBcdHRoaXMucGx1Z2lucy50aWxpbmdTcHJpdGUuY29udGV4dENoYW5nZSh0aGlzLmNvbnRleHQuZ2wpXHRcdFxyXG4gICAgLy8gfVxyXG4gICAgcmVuZGVyKGRpc3BsYXlPYmplY3QsIHJlbmRlclRleHR1cmUgPSBudWxsLCBjbGVhciA9IHRydWUsIHRyYW5zZm9ybSA9IG51bGwsIHNraXBVcGRhdGVUcmFuc2Zvcm0gPSBmYWxzZSkge1xyXG4gICAgICAgIHRoaXMucmVuZGVyaW5nVG9TY3JlZW4gPSAhcmVuZGVyVGV4dHVyZTtcclxuICAgICAgICB0aGlzLnJ1bm5lcnMucHJlcmVuZGVyLnJ1bigpO1xyXG4gICAgICAgIC8vIHRoaXMuZW1pdCgncHJlcmVuZGVyJyk7XHJcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KEV2ZW50XzEuRXZlbnQuZ2V0RXZlbnQoXCJwcmVyZW5kZXJcIikpO1xyXG4gICAgICAgIGlmICh0aGlzLmNvbnRleHQuaXNMb3N0KSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFyZW5kZXJUZXh0dXJlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2xhc3RPYmplY3RSZW5kZXJlZCA9IGRpc3BsYXlPYmplY3Q7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghc2tpcFVwZGF0ZVRyYW5zZm9ybSkge1xyXG4gICAgICAgICAgICBsZXQgY2FjaGVQYXJlbnQgPSBkaXNwbGF5T2JqZWN0LnBhcmVudDtcclxuICAgICAgICAgICAgZGlzcGxheU9iamVjdC5wYXJlbnQgPSB0aGlzLl90ZW1wRGlzcGxheU9iamVjdFBhcmVudDtcclxuICAgICAgICAgICAgZGlzcGxheU9iamVjdC51cGRhdGVUcmFuc2Zvcm0oKTtcclxuICAgICAgICAgICAgZGlzcGxheU9iamVjdC5wYXJlbnQgPSBjYWNoZVBhcmVudDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5yZW5kZXJUZXh0dXJlLmJpbmQocmVuZGVyVGV4dHVyZSk7XHJcbiAgICAgICAgdGhpcy5iYXRjaC5jdXJyZW50UmVuZGVyZXIuc3RhcnQoKTtcclxuICAgICAgICBpZiAoY2xlYXIgIT09IHVuZGVmaW5lZCA/IGNsZWFyIDogdGhpcy5jbGVhckJlZm9yZVJlbmRlcikge1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlclRleHR1cmUuY2xlYXIoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZGlzcGxheU9iamVjdC5yZW5kZXIodGhpcyk7XHJcbiAgICAgICAgdGhpcy5iYXRjaC5jdXJyZW50UmVuZGVyZXIuZmx1c2goKTtcclxuICAgICAgICBpZiAocmVuZGVyVGV4dHVyZSkge1xyXG4gICAgICAgICAgICByZW5kZXJUZXh0dXJlLmJhc2VUZXh0dXJlLnVwZGF0ZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnJ1bm5lcnMucG9zdHJlbmRlci5ydW4oKTtcclxuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoRXZlbnRfMS5FdmVudC5nZXRFdmVudChcInBvc3RyZW5kZXJcIikpO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgcmVzaXplKHNjcmVlbldpZHRoLCBzY3JlZW5IZWlnaHQpIHtcclxuICAgICAgICBzdXBlci5yZXNpemUoc2NyZWVuV2lkdGgsIHNjcmVlbkhlaWdodCk7XHJcbiAgICAgICAgdGhpcy5ydW5uZXJzLnJlc2l6ZS5ydW4oc2NyZWVuV2lkdGgsIHNjcmVlbkhlaWdodCk7XHJcbiAgICAgICAgLy8gdGhpcy5kaXNwYXRjaEV2ZW50KEV2ZW50LmdldEV2ZW50KFwicmVzaXplXCIpKTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIHJlc2V0KCkge1xyXG4gICAgICAgIHRoaXMucnVubmVycy5yZXNldC5ydW4oKTtcclxuICAgICAgICAvLyB0aGlzLmRpc3BhdGNoRXZlbnQoRXZlbnQuZ2V0RXZlbnQoXCJyZXNldFwiKSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICBjbGVhcigpIHtcclxuICAgICAgICB0aGlzLmZyYW1lYnVmZmVyLmJpbmQoKTtcclxuICAgICAgICB0aGlzLmZyYW1lYnVmZmVyLmNsZWFyKCk7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICBkZXN0cm95KG9wdGlvbnMgPSBudWxsKSB7XHJcbiAgICAgICAgdGhpcy5ydW5uZXJzLmRlc3Ryb3kucnVuKCk7XHJcbiAgICAgICAgLy8gdGhpcy5kaXNwYXRjaEV2ZW50KEV2ZW50LmdldEV2ZW50KFwiZGVzdHJveVwiKSk7XHJcbiAgICAgICAgc3VwZXIuZGVzdHJveShvcHRpb25zKTtcclxuICAgICAgICB0aGlzLmdsID0gbnVsbDtcclxuICAgIH1cclxuICAgIDtcclxufVxyXG5SZW5kZXJlci5fX3BsdWdpbnMgPSB7fTtcclxuZXhwb3J0cy5SZW5kZXJlciA9IFJlbmRlcmVyO1xyXG5jbGFzcyBSZW5kZXJlclBsdWdpbnMge1xyXG4gICAgY29uc3RydWN0b3IocmVuZGVyZXIpIHtcclxuICAgICAgICB0aGlzLnBhcnRpY2xlID0gbmV3IFBhcnRpY2xlUmVuZGVyZXJfMS5QYXJ0aWNsZVJlbmRlcmVyKHJlbmRlcmVyKTtcclxuICAgICAgICB0aGlzLnRpbGluZ1Nwcml0ZSA9IG5ldyBUaWxpbmdTcHJpdGVSZW5kZXJlcl8xLlRpbGluZ1Nwcml0ZVJlbmRlcmVyKHJlbmRlcmVyKTtcclxuICAgICAgICB0aGlzLmFjY2Vzc2liaWxpdHkgPSBuZXcgQWNjZXNzaWJpbGl0eU1hbmFnZXJfMS5BY2Nlc3NpYmlsaXR5TWFuYWdlcihyZW5kZXJlcik7XHJcbiAgICAgICAgdGhpcy5leHRyYWN0ID0gbmV3IEV4dHJhY3RfMS5FeHRyYWN0KHJlbmRlcmVyKTtcclxuICAgICAgICB0aGlzLmludGVyYWN0aW9uID0gbmV3IEludGVyYWN0aW9uTWFuYWdlcl8xLkludGVyYWN0aW9uTWFuYWdlcihyZW5kZXJlcik7XHJcbiAgICAgICAgdGhpcy5wcmVwYXJlID0gbmV3IFByZXBhcmVfMS5QcmVwYXJlKHJlbmRlcmVyKTtcclxuICAgICAgICB0aGlzLmJhdGNoID0gbmV3IEJhdGNoUmVuZGVyZXJfMS5CYXRjaFJlbmRlcmVyKHJlbmRlcmVyKTtcclxuICAgICAgICAvLyBMb2FkZXIkMi5yZWdpc3RlclBsdWdpbihCaXRtYXBGb250TG9hZGVyKTtcclxuICAgICAgICAvLyBMb2FkZXIkMi5yZWdpc3RlclBsdWdpbihTcHJpdGVzaGVldExvYWRlcik7XHRcclxuICAgIH1cclxufVxyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBFdmVudF8xID0gcmVxdWlyZShcIi4vRXZlbnRcIik7XHJcbmNvbnN0IEV2ZW50RGlzcGF0Y2hlcl8xID0gcmVxdWlyZShcIi4vRXZlbnREaXNwYXRjaGVyXCIpO1xyXG5jb25zdCBSdW5uZXJfMSA9IHJlcXVpcmUoXCIuL1J1bm5lclwiKTtcclxuY2xhc3MgUmVzb3VyY2UgZXh0ZW5kcyBFdmVudERpc3BhdGNoZXJfMS5FdmVudERpc3BhdGNoZXIge1xyXG4gICAgY29uc3RydWN0b3Iod2lkdGggPSAwLCBoZWlnaHQgPSAwKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJbnRlcm5hbCB3aWR0aCBvZiB0aGUgcmVzb3VyY2VcclxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgICAgICogQHByb3RlY3RlZFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuX3dpZHRoID0gd2lkdGg7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSW50ZXJuYWwgaGVpZ2h0IG9mIHRoZSByZXNvdXJjZVxyXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5faGVpZ2h0ID0gaGVpZ2h0O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIElmIHJlc291cmNlIGhhcyBiZWVuIGRlc3Ryb3llZFxyXG4gICAgICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XHJcbiAgICAgICAgICogQHJlYWRvbmx5XHJcbiAgICAgICAgICogQGRlZmF1bHQgZmFsc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIGB0cnVlYCBpZiByZXNvdXJjZSBpcyBjcmVhdGVkIGJ5IEJhc2VUZXh0dXJlXHJcbiAgICAgICAgICogdXNlZnVsIGZvciBkb2luZyBjbGVhbnVwIHdpdGggQmFzZVRleHR1cmUgZGVzdHJveVxyXG4gICAgICAgICAqIGFuZCBub3QgY2xlYW5pbmcgdXAgcmVzb3VyY2VzIHRoYXQgd2VyZSBjcmVhdGVkXHJcbiAgICAgICAgICogZXh0ZXJuYWxseS5cclxuICAgICAgICAgKiBAbWVtYmVyIHtib29sZWFufVxyXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmludGVybmFsID0gZmFsc2U7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogTWluaS1ydW5uZXIgZm9yIGhhbmRsaW5nIHJlc2l6ZSBldmVudHNcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBtZW1iZXIge1J1bm5lcn1cclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIC8vIHRoaXMub25SZXNpemUgPSBFdmVudC5nZXRFdmVudChcInNldFJlYWxTaXplXCIpXHJcbiAgICAgICAgLy8gUnVubmVyKCdzZXRSZWFsU2l6ZScsIDIpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIE1pbmktcnVubmVyIGZvciBoYW5kbGluZyB1cGRhdGUgZXZlbnRzXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAbWVtYmVyIHtSdW5uZXJ9XHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICAvLyB0aGlzLm9uVXBkYXRlID0gRXZlbnQuZ2V0RXZlbnQoXCJ1cGRhdGVcIilcclxuICAgICAgICAvLyBuZXcgUnVubmVyKCd1cGRhdGUnKTtcclxuICAgICAgICB0aGlzLm9uUmVzaXplID0gbmV3IFJ1bm5lcl8xLlJ1bm5lcignc2V0UmVhbFNpemUnLCAyKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBNaW5pLXJ1bm5lciBmb3IgaGFuZGxpbmcgdXBkYXRlIGV2ZW50c1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQG1lbWJlciB7UnVubmVyfVxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5vblVwZGF0ZSA9IG5ldyBSdW5uZXJfMS5SdW5uZXIoJ3VwZGF0ZScpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBCaW5kIHRvIGEgcGFyZW50IEJhc2VUZXh0dXJlXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtQSVhJLkJhc2VUZXh0dXJlfSBiYXNlVGV4dHVyZSAtIFBhcmVudCB0ZXh0dXJlXHJcbiAgICAgKi9cclxuICAgIGJpbmQoYmFzZVRleHR1cmUpIHtcclxuICAgICAgICB0aGlzLm9uUmVzaXplLmFkZChiYXNlVGV4dHVyZSk7XHJcbiAgICAgICAgdGhpcy5vblVwZGF0ZS5hZGQoYmFzZVRleHR1cmUpO1xyXG4gICAgICAgIC8vIENhbGwgYSByZXNpemUgaW1tZWRpYXRlIGlmIHdlIGFscmVhZHlcclxuICAgICAgICAvLyBoYXZlIHRoZSB3aWR0aCBhbmQgaGVpZ2h0IG9mIHRoZSByZXNvdXJjZVxyXG4gICAgICAgIGlmICh0aGlzLl93aWR0aCB8fCB0aGlzLl9oZWlnaHQpIHtcclxuICAgICAgICAgICAgdGhpcy5vblJlc2l6ZS5ydW4odGhpcy5fd2lkdGgsIHRoaXMuX2hlaWdodCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHRoaXMub25SZXNpemUuYWRkKGJhc2VUZXh0dXJlKTtcclxuICAgICAgICAvLyB0aGlzLm9uVXBkYXRlLmFkZChiYXNlVGV4dHVyZSk7XHJcbiAgICAgICAgLy8gQ2FsbCBhIHJlc2l6ZSBpbW1lZGlhdGUgaWYgd2UgYWxyZWFkeVxyXG4gICAgICAgIC8vIGhhdmUgdGhlIHdpZHRoIGFuZCBoZWlnaHQgb2YgdGhlIHJlc291cmNlXHJcbiAgICAgICAgLy8gaWYgKHRoaXMuX3dpZHRoIHx8IHRoaXMuX2hlaWdodClcclxuICAgICAgICAvLyB7XHJcbiAgICAgICAgLy8gXHR0aGlzLmRpc3BhdGNoRXZlbnQoRXZlbnQuZ2V0RXZlbnQoXCJzZXRSZWFsU2l6ZVwiKSlcclxuICAgICAgICAvLyAgICAgLy8gdGhpcy5vblJlc2l6ZS5ydW4odGhpcy5fd2lkdGgsIHRoaXMuX2hlaWdodCk7XHJcbiAgICAgICAgLy8gfVxyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBVbmJpbmQgdG8gYSBwYXJlbnQgQmFzZVRleHR1cmVcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1BJWEkuQmFzZVRleHR1cmV9IGJhc2VUZXh0dXJlIC0gUGFyZW50IHRleHR1cmVcclxuICAgICAqL1xyXG4gICAgdW5iaW5kKGJhc2VUZXh0dXJlKSB7XHJcbiAgICAgICAgdGhpcy5vblJlc2l6ZS5yZW1vdmUoYmFzZVRleHR1cmUpO1xyXG4gICAgICAgIHRoaXMub25VcGRhdGUucmVtb3ZlKGJhc2VUZXh0dXJlKTtcclxuICAgICAgICAvLyB0aGlzLm9uUmVzaXplLnJlbW92ZShiYXNlVGV4dHVyZSk7XHJcbiAgICAgICAgLy8gdGhpcy5vblVwZGF0ZS5yZW1vdmUoYmFzZVRleHR1cmUpO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUcmlnZ2VyIGEgcmVzaXplIGV2ZW50XHJcbiAgICAgKi9cclxuICAgIHJlc2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICAgICAgaWYgKHdpZHRoICE9PSB0aGlzLl93aWR0aCB8fCBoZWlnaHQgIT09IHRoaXMuX2hlaWdodCkge1xyXG4gICAgICAgICAgICB0aGlzLl93aWR0aCA9IHdpZHRoO1xyXG4gICAgICAgICAgICB0aGlzLl9oZWlnaHQgPSBoZWlnaHQ7XHJcbiAgICAgICAgICAgIHRoaXMub25SZXNpemUucnVuKHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoRXZlbnRfMS5FdmVudC5nZXRFdmVudChcInNldFJlYWxTaXplXCIpKTtcclxuICAgICAgICAgICAgLy8gRXZlbnQuZ2V0RXZlbnQoXCJzZXRSZWFsU2l6ZVwiKVxyXG4gICAgICAgICAgICAvLyB0aGlzLm9uUmVzaXplLnJ1bih3aWR0aCwgaGVpZ2h0KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIEhhcyBiZWVuIHZhbGlkYXRlZFxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKiBAbWVtYmVyIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICBnZXQgdmFsaWQoKSB7XHJcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fd2lkdGggJiYgISF0aGlzLl9oZWlnaHQ7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIEhhcyBiZWVuIHVwZGF0ZWQgdHJpZ2dlciBldmVudFxyXG4gICAgICovXHJcbiAgICB1cGRhdGUoZGVsdGFUaW1lKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmRlc3Ryb3llZCkge1xyXG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoRXZlbnRfMS5FdmVudC5nZXRFdmVudChcInVwZGF0ZVwiKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIGNhbiBiZSBvdmVycmlkZGVuIHRvIHN0YXJ0IHByZWxvYWRpbmcgYSByZXNvdXJjZVxyXG4gICAgICogb3IgZG8gYW55IG90aGVyIHByZXBhcmUgc3RlcC5cclxuICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAqIEByZXR1cm4ge1Byb21pc2U8dm9pZD59IEhhbmRsZSB0aGUgdmFsaWRhdGUgZXZlbnRcclxuICAgICAqL1xyXG4gICAgbG9hZCgpIHtcclxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSB3aWR0aCBvZiB0aGUgcmVzb3VyY2UuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKi9cclxuICAgIGdldCB3aWR0aCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fd2lkdGg7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBoZWlnaHQgb2YgdGhlIHJlc291cmNlLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICovXHJcbiAgICBnZXQgaGVpZ2h0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9oZWlnaHQ7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFVwbG9hZHMgdGhlIHRleHR1cmUgb3IgcmV0dXJucyBmYWxzZSBpZiBpdCBjYW50IGZvciBzb21lIHJlYXNvbi4gT3ZlcnJpZGUgdGhpcy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1BJWEkuUmVuZGVyZXJ9IHJlbmRlcmVyIC0geWVhaCwgcmVuZGVyZXIhXHJcbiAgICAgKiBAcGFyYW0ge1BJWEkuQmFzZVRleHR1cmV9IGJhc2VUZXh0dXJlIC0gdGhlIHRleHR1cmVcclxuICAgICAqIEBwYXJhbSB7UElYSS5HTFRleHR1cmV9IGdsVGV4dHVyZSAtIHRleHR1cmUgaW5zdGFuY2UgZm9yIHRoaXMgd2ViZ2wgY29udGV4dFxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaXMgc3VjY2Vzc1xyXG4gICAgICovXHJcbiAgICB1cGxvYWQocmVuZGVyZXIsIGJhc2VUZXh0dXJlLCBnbFRleHR1cmUsIHNvdXJjZSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRoZSBzdHlsZSwgb3B0aW9uYWwgdG8gb3ZlcnJpZGVcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1BJWEkuUmVuZGVyZXJ9IHJlbmRlcmVyIC0geWVhaCwgcmVuZGVyZXIhXHJcbiAgICAgKiBAcGFyYW0ge1BJWEkuQmFzZVRleHR1cmV9IGJhc2VUZXh0dXJlIC0gdGhlIHRleHR1cmVcclxuICAgICAqIEBwYXJhbSB7UElYSS5HTFRleHR1cmV9IGdsVGV4dHVyZSAtIHRleHR1cmUgaW5zdGFuY2UgZm9yIHRoaXMgd2ViZ2wgY29udGV4dFxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpcyBzdWNjZXNzXHJcbiAgICAgKi9cclxuICAgIHN0eWxlKHJlbmRlcmVyLCBiYXNlVGV4dHVyZSwgZ2xUZXh0dXJlKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDbGVhbiB1cCBhbnl0aGluZywgdGhpcyBoYXBwZW5zIHdoZW4gZGVzdHJveWluZyBpcyByZWFkeS5cclxuICAgICAqXHJcbiAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgKi9cclxuICAgIGRpc3Bvc2UoKSB7XHJcbiAgICAgICAgLy8gb3ZlcnJpZGVcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQ2FsbCB3aGVuIGRlc3Ryb3lpbmcgcmVzb3VyY2UsIHVuYmluZCBhbnkgQmFzZVRleHR1cmUgb2JqZWN0XHJcbiAgICAgKiBiZWZvcmUgY2FsbGluZyB0aGlzIG1ldGhvZCwgYXMgcmVmZXJlbmNlIGNvdW50cyBhcmUgbWFpbnRhaW5lZFxyXG4gICAgICogaW50ZXJuYWxseS5cclxuICAgICAqL1xyXG4gICAgZGVzdHJveSgpIHtcclxuICAgICAgICBpZiAoIXRoaXMuZGVzdHJveWVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMub25SZXNpemUucmVtb3ZlQWxsKCk7XHJcbiAgICAgICAgICAgIHRoaXMub25SZXNpemUgPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLm9uVXBkYXRlLnJlbW92ZUFsbCgpO1xyXG4gICAgICAgICAgICB0aGlzLm9uVXBkYXRlID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLmRpc3Bvc2UoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICA7XHJcbn1cclxuZXhwb3J0cy5SZXNvdXJjZSA9IFJlc291cmNlO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBFdmVudERpc3BhdGNoZXJfMSA9IHJlcXVpcmUoXCIuL0V2ZW50RGlzcGF0Y2hlclwiKTtcclxuY29uc3QgRXZlbnRfMSA9IHJlcXVpcmUoXCIuL0V2ZW50XCIpO1xyXG5jb25zdCBQcm9ncmVzc0V2ZW50XzEgPSByZXF1aXJlKFwiLi9Qcm9ncmVzc0V2ZW50XCIpO1xyXG5jb25zdCBMb2dnZXJfMSA9IHJlcXVpcmUoXCIuL0xvZ2dlclwiKTtcclxuY2xhc3MgUmVzb3VyY2VMb2FkZXIgZXh0ZW5kcyBFdmVudERpc3BhdGNoZXJfMS5FdmVudERpc3BhdGNoZXIge1xyXG4gICAgY29uc3RydWN0b3IocmVxdWVzdCkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5jb21wbGV0ZSA9IChldmVudCkgPT4ge1xyXG4gICAgICAgICAgICBMb2dnZXJfMS50cmFjZShcImNvbXBsZXRlXCIpO1xyXG4gICAgICAgICAgICBsZXQgcHJvbWlzZSA9IHdpbmRvdy5jcmVhdGVJbWFnZUJpdG1hcCh0aGlzLl9pbWFnZUVsZW1lbnQsIDAsIDAsIHRoaXMuX2ltYWdlRWxlbWVudC53aWR0aCwgdGhpcy5faW1hZ2VFbGVtZW50LmhlaWdodCk7XHJcbiAgICAgICAgICAgIHByb21pc2UudGhlbih0aGlzLm9uSW1hZ2VCaXRtYXBDcmVhdGVkKS5jYXRjaCgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5vbkltYWdlQml0bWFwQ3JlYXRlZCA9IChpbWFnZSkgPT4ge1xyXG4gICAgICAgICAgICBMb2dnZXJfMS50cmFjZShcIm9uSW1hZ2VCaXRtYXBDcmVhdGVkXCIpO1xyXG4gICAgICAgICAgICB0aGlzLl9pbWFnZURhdGEgPSBpbWFnZTtcclxuICAgICAgICAgICAgdGhpcy5fY2xlYXJFdmVudHMoKTtcclxuICAgICAgICAgICAgdGhpcy5fZmluaXNoKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLl9vblRpbWVvdXQgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuYWJvcnQoJ0xvYWQgdGltZWQgb3V0LicpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5fb25Qcm9ncmVzcyA9IChldmVudCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoZXZlbnQgJiYgZXZlbnQubGVuZ3RoQ29tcHV0YWJsZSkge1xyXG4gICAgICAgICAgICAgICAgbGV0IHBlID0gUHJvZ3Jlc3NFdmVudF8xLlByb2dyZXNzRXZlbnQuZ2V0UHJvZ3Jlc3NFdmVudChQcm9ncmVzc0V2ZW50XzEuUHJvZ3Jlc3NFdmVudC5QUk9HUkVTUyk7XHJcbiAgICAgICAgICAgICAgICBwZS5ieXRlc0xvYWRlZCA9IGV2ZW50LmxvYWRlZDtcclxuICAgICAgICAgICAgICAgIHBlLmJ5dGVzVG90YWwgPSBldmVudC50b3RhbDtcclxuICAgICAgICAgICAgICAgIHBlLnBlcmNlbnQgPSBldmVudC5sb2FkZWQgLyBldmVudC50b3RhbDtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChwZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuX29uRXJyb3IgPSAoZXZlbnQpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5hYm9ydCgnRmFpbGVkIHRvIGxvYWQgZWxlbWVudCB1c2luZzogJyArIGV2ZW50LnRhcmdldC5ub2RlTmFtZSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLl9yZXF1ZXN0ID0gcmVxdWVzdDtcclxuICAgICAgICB0aGlzLl9mbGFncyA9IDA7XHJcbiAgICAgICAgdGhpcy5fc2V0RmxhZyhSZXNvdXJjZUxvYWRlci5TVEFUVVNfRkxBR1MuREFUQV9VUkwsIHRoaXMuX3JlcXVlc3QudXJsLmluZGV4T2YoJ2RhdGE6JykgPT09IDApO1xyXG4gICAgICAgIHRoaXMuZXh0ZW5zaW9uID0gdGhpcy5fZ2V0RXh0ZW5zaW9uKCk7XHJcbiAgICAgICAgdGhpcy5kYXRhID0gbnVsbDtcclxuICAgICAgICB0aGlzLmNyb3NzT3JpZ2luID0gcmVxdWVzdC5jcm9zc09yaWdpbiA9PT0gdHJ1ZSA/ICdhbm9ueW1vdXMnIDogXCJcIjtcclxuICAgICAgICB0aGlzLnRpbWVvdXQgPSByZXF1ZXN0LnRpbWVvdXQgfHwgMDtcclxuICAgICAgICB0aGlzLmxvYWRUeXBlID0gdGhpcy5fZGV0ZXJtaW5lTG9hZFR5cGUoKTtcclxuICAgICAgICB0aGlzLmVycm9yID0gbnVsbDtcclxuICAgICAgICB0aGlzLnhociA9IG51bGw7XHJcbiAgICAgICAgdGhpcy50eXBlID0gUmVzb3VyY2VMb2FkZXIuVFlQRS5VTktOT1dOO1xyXG4gICAgICAgIHRoaXMucHJvZ3Jlc3NDaHVuayA9IDA7XHJcbiAgICAgICAgdGhpcy5fZWxlbWVudFRpbWVyID0gMDtcclxuICAgICAgICB0aGlzLm1ldGFkYXRhID0gcmVxdWVzdC5yZXF1ZXN0TWV0YURhdGE7XHJcbiAgICAgICAgdGhpcy54aHJUeXBlID0gbnVsbDtcclxuICAgICAgICAvLyB0aGlzLmNoaWxkcmVuID0gW107XHJcbiAgICAgICAgLy8gdGhpcy5fZGVxdWV1ZSA9IFJlc291cmNlTG9hZGVyLl9ub29wO1xyXG4gICAgICAgIC8vIHRoaXMuX29uTG9hZEJpbmRpbmcgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgbG9hZCgpIHtcclxuICAgICAgICBpZiAodGhpcy5pc0xvYWRpbmcpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5pc0NvbXBsZXRlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChFdmVudF8xLkV2ZW50LmdldEV2ZW50KEV2ZW50XzEuRXZlbnQuQ09NUExFVEUpKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9zZXRGbGFnKFJlc291cmNlTG9hZGVyLlNUQVRVU19GTEFHUy5MT0FESU5HLCB0cnVlKTtcclxuICAgICAgICBpZiAoIXRoaXMuY3Jvc3NPcmlnaW4pIHtcclxuICAgICAgICAgICAgdGhpcy5jcm9zc09yaWdpbiA9IHRoaXMuX2RldGVybWluZUNyb3NzT3JpZ2luKHRoaXMuX3JlcXVlc3QudXJsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc3dpdGNoICh0aGlzLmxvYWRUeXBlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgUmVzb3VyY2VMb2FkZXIuTE9BRF9UWVBFLklNQUdFOlxyXG4gICAgICAgICAgICAgICAgdGhpcy50eXBlID0gUmVzb3VyY2VMb2FkZXIuVFlQRS5JTUFHRTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xvYWRFbGVtZW50KCdpbWFnZScpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgUmVzb3VyY2VMb2FkZXIuTE9BRF9UWVBFLkFVRElPOlxyXG4gICAgICAgICAgICAgICAgdGhpcy50eXBlID0gUmVzb3VyY2VMb2FkZXIuVFlQRS5BVURJTztcclxuICAgICAgICAgICAgICAgIC8vIHRoaXMuX2xvYWRTb3VyY2VFbGVtZW50KCdhdWRpbycpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgUmVzb3VyY2VMb2FkZXIuTE9BRF9UWVBFLlZJREVPOlxyXG4gICAgICAgICAgICAgICAgdGhpcy50eXBlID0gUmVzb3VyY2VMb2FkZXIuVFlQRS5WSURFTztcclxuICAgICAgICAgICAgICAgIC8vIHRoaXMuX2xvYWRTb3VyY2VFbGVtZW50KCd2aWRlbycpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgUmVzb3VyY2VMb2FkZXIuTE9BRF9UWVBFLlhIUjpcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIGlmIChSZXNvdXJjZUxvYWRlci51c2VYZHIgJiYgdGhpcy5jcm9zc09yaWdpbikge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xvYWRYZHIoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xvYWRYaHIoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBfbG9hZFNvdXJjZUVsZW1lbnRcclxuICAgICAgICAvLyBfbG9hZFhkclxyXG4gICAgICAgIC8vIF9sb2FkWGhyXHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIExvYWRzIHRoaXMgcmVzb3VyY2VzIHVzaW5nIGFuIGVsZW1lbnQgdGhhdCBoYXMgbXVsdGlwbGUgc291cmNlcyxcclxuICAgICAqIGxpa2UgYW4gSFRNTEF1ZGlvRWxlbWVudCBvciBIVE1MVmlkZW9FbGVtZW50LlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSAtIFRoZSB0eXBlIG9mIGVsZW1lbnQgdG8gdXNlLlxyXG4gICAgICovXHJcbiAgICAvLyBwcm90ZWN0ZWQgX2xvYWRTb3VyY2VFbGVtZW50KHR5cGUpOnZvaWRcclxuICAgIC8vIHtcclxuICAgIC8vICAgICBpZiAodGhpcy5tZXRhZGF0YS5sb2FkRWxlbWVudCkgXHJcbiAgICAvLyAgICAge1xyXG4gICAgLy8gICAgICAgICB0aGlzLmRhdGEgPSB0aGlzLm1ldGFkYXRhLmxvYWRFbGVtZW50O1xyXG4gICAgLy8gICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2F1ZGlvJyAmJiB0eXBlb2Ygd2luZG93WydBdWRpbyddICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgLy8gICAgICAgICB0aGlzLmRhdGEgPSBuZXcgQXVkaW8oKTtcclxuICAgIC8vICAgICB9IGVsc2Uge1xyXG4gICAgLy8gICAgICAgICB0aGlzLmRhdGEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHR5cGUpO1xyXG4gICAgLy8gICAgIH1cclxuICAgIC8vICAgICBpZiAodGhpcy5kYXRhID09PSBudWxsKSB7XHJcbiAgICAvLyAgICAgICAgIHRoaXMuYWJvcnQoJ1Vuc3VwcG9ydGVkIGVsZW1lbnQ6ICcgKyB0eXBlKTtcclxuICAgIC8vICAgICAgICAgcmV0dXJuO1xyXG4gICAgLy8gICAgIH1cclxuICAgIC8vICAgICBpZiAodGhpcy5jcm9zc09yaWdpbikge1xyXG4gICAgLy8gICAgICAgICB0aGlzLmRhdGEuY3Jvc3NPcmlnaW4gPSB0aGlzLmNyb3NzT3JpZ2luO1xyXG4gICAgLy8gICAgIH1cclxuICAgIC8vICAgICBpZiAoIXRoaXMubWV0YWRhdGEuc2tpcFNvdXJjZSkge1xyXG4gICAgLy8gICAgICAgICAvLyBzdXBwb3J0IGZvciBDb2Nvb25KUyBDYW52YXMrIHJ1bnRpbWUsIGxhY2tzIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NvdXJjZScpXHJcbiAgICAvLyAgICAgICAgIGlmIChuYXZpZ2F0b3JbJ2lzQ29jb29uSlMnXSkge1xyXG4gICAgLy8gICAgICAgICAgICAgdGhpcy5kYXRhLnNyYyA9IEFycmF5LmlzQXJyYXkodGhpcy5fcmVxdWVzdC51cmwpID8gdGhpcy5fcmVxdWVzdC51cmxbMF0gOiB0aGlzLl9yZXF1ZXN0LnVybDtcclxuICAgIC8vICAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHRoaXMuX3JlcXVlc3QudXJsKSkge1xyXG4gICAgLy8gICAgICAgICAgICAgdmFyIG1pbWVUeXBlcyA9IHRoaXMubWV0YWRhdGEubWltZVR5cGU7XHJcbiAgICAvLyAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3JlcXVlc3QudXJsLmxlbmd0aDsgKytpKSB7XHJcbiAgICAvLyAgICAgICAgICAgICAgICAgdGhpcy5kYXRhLmFwcGVuZENoaWxkKHRoaXMuX2NyZWF0ZVNvdXJjZSh0eXBlLCB0aGlzLl9yZXF1ZXN0LnVybFtpXSwgQXJyYXkuaXNBcnJheShtaW1lVHlwZXMpID8gbWltZVR5cGVzW2ldIDogbWltZVR5cGVzKSk7XHJcbiAgICAvLyAgICAgICAgICAgICB9XHJcbiAgICAvLyAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAvLyAgICAgICAgICAgICB2YXIgX21pbWVUeXBlcyA9IHRoaXMubWV0YWRhdGEubWltZVR5cGU7XHJcbiAgICAvLyAgICAgICAgICAgICB0aGlzLmRhdGEuYXBwZW5kQ2hpbGQodGhpcy5fY3JlYXRlU291cmNlKHR5cGUsIHRoaXMuX3JlcXVlc3QudXJsLCBBcnJheS5pc0FycmF5KF9taW1lVHlwZXMpID8gX21pbWVUeXBlc1swXSA6IF9taW1lVHlwZXMpKTtcclxuICAgIC8vICAgICAgICAgfVxyXG4gICAgLy8gICAgIH1cclxuICAgIC8vICAgICB0aGlzLmRhdGEuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCB0aGlzLl9ib3VuZE9uRXJyb3IsIGZhbHNlKTtcclxuICAgIC8vICAgICB0aGlzLmRhdGEuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIHRoaXMuX2JvdW5kQ29tcGxldGUsIGZhbHNlKTtcclxuICAgIC8vICAgICB0aGlzLmRhdGEuYWRkRXZlbnRMaXN0ZW5lcigncHJvZ3Jlc3MnLCB0aGlzLl9ib3VuZE9uUHJvZ3Jlc3MsIGZhbHNlKTtcclxuICAgIC8vICAgICB0aGlzLmRhdGEuYWRkRXZlbnRMaXN0ZW5lcignY2FucGxheXRocm91Z2gnLCB0aGlzLl9ib3VuZENvbXBsZXRlLCBmYWxzZSk7XHJcbiAgICAvLyAgICAgdGhpcy5kYXRhLmxvYWQoKTtcclxuICAgIC8vICAgICBpZiAodGhpcy50aW1lb3V0KSB7XHJcbiAgICAvLyAgICAgICAgIHRoaXMuX2VsZW1lbnRUaW1lciA9IHNldFRpbWVvdXQodGhpcy5fYm91bmRPblRpbWVvdXQsIHRoaXMudGltZW91dCk7XHJcbiAgICAvLyAgICAgfVxyXG4gICAgLy8gfTtcclxuICAgIF9jbGVhckV2ZW50cygpIHtcclxuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fZWxlbWVudFRpbWVyKTtcclxuICAgICAgICBpZiAodGhpcy5faW1hZ2VFbGVtZW50ICYmIHRoaXMuX2ltYWdlRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2ltYWdlRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdlcnJvcicsIHRoaXMuX29uRXJyb3IpO1xyXG4gICAgICAgICAgICB0aGlzLl9pbWFnZUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbG9hZCcsIHRoaXMuY29tcGxldGUpO1xyXG4gICAgICAgICAgICB0aGlzLl9pbWFnZUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigncHJvZ3Jlc3MnLCB0aGlzLl9vblByb2dyZXNzKTtcclxuICAgICAgICAgICAgdGhpcy5faW1hZ2VFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NhbnBsYXl0aHJvdWdoJywgdGhpcy5jb21wbGV0ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLnhocikge1xyXG4gICAgICAgICAgICAvLyBpZiAodGhpcy54aHIucmVtb3ZlRXZlbnRMaXN0ZW5lcikge1xyXG4gICAgICAgICAgICAvLyAgICAgdGhpcy54aHIucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXJyb3InLCB0aGlzLl9ib3VuZFhock9uRXJyb3IsIGZhbHNlKTtcclxuICAgICAgICAgICAgLy8gICAgIHRoaXMueGhyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RpbWVvdXQnLCB0aGlzLl9ib3VuZFhock9uVGltZW91dCwgZmFsc2UpO1xyXG4gICAgICAgICAgICAvLyAgICAgdGhpcy54aHIucmVtb3ZlRXZlbnRMaXN0ZW5lcignYWJvcnQnLCB0aGlzLl9ib3VuZFhock9uQWJvcnQsIGZhbHNlKTtcclxuICAgICAgICAgICAgLy8gICAgIHRoaXMueGhyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Byb2dyZXNzJywgdGhpcy5fYm91bmRPblByb2dyZXNzLCBmYWxzZSk7XHJcbiAgICAgICAgICAgIC8vICAgICB0aGlzLnhoci5yZW1vdmVFdmVudExpc3RlbmVyKCdsb2FkJywgdGhpcy5fYm91bmRYaHJPbkxvYWQsIGZhbHNlKTtcclxuICAgICAgICAgICAgLy8gfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gICAgIHRoaXMueGhyLm9uZXJyb3IgPSBudWxsO1xyXG4gICAgICAgICAgICAvLyAgICAgdGhpcy54aHIub250aW1lb3V0ID0gbnVsbDtcclxuICAgICAgICAgICAgLy8gICAgIHRoaXMueGhyLm9ucHJvZ3Jlc3MgPSBudWxsO1xyXG4gICAgICAgICAgICAvLyAgICAgdGhpcy54aHIub25sb2FkID0gbnVsbDtcclxuICAgICAgICAgICAgLy8gfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIDtcclxuICAgIF9sb2FkRWxlbWVudCh0eXBlKSB7XHJcbiAgICAgICAgTG9nZ2VyXzEudHJhY2UoXCJfbG9hZEVsZW1lbnQgXCIgKyB0eXBlKTtcclxuICAgICAgICB0aGlzLl9pbWFnZUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW1nXCIpO1xyXG4gICAgICAgIGlmICh0aGlzLmNyb3NzT3JpZ2luKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2ltYWdlRWxlbWVudC5jcm9zc09yaWdpbiA9IHRoaXMuY3Jvc3NPcmlnaW47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2ltYWdlRWxlbWVudC5zcmMgPSB0aGlzLl9yZXF1ZXN0LnVybDtcclxuICAgICAgICB0aGlzLl9pbWFnZUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCB0aGlzLl9vbkVycm9yKTtcclxuICAgICAgICB0aGlzLl9pbWFnZUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIHRoaXMuY29tcGxldGUpO1xyXG4gICAgICAgIHRoaXMuX2ltYWdlRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdwcm9ncmVzcycsIHRoaXMuX29uUHJvZ3Jlc3MpO1xyXG4gICAgICAgIC8vIGlmICh0aGlzLnRpbWVvdXQgPiAwKSBcclxuICAgICAgICAvLyB7XHJcbiAgICAgICAgLy8gICAgIHRoaXMuX2VsZW1lbnRUaW1lciA9IHNldFRpbWVvdXQodGhpcy5fb25UaW1lb3V0LCB0aGlzLnRpbWVvdXQpO1xyXG4gICAgICAgIC8vIH1cclxuICAgIH1cclxuICAgIDtcclxuICAgIGdldCBpbWFnZURhdGEoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ltYWdlRGF0YTtcclxuICAgIH1cclxuICAgIGFib3J0KG1lc3NhZ2UpIHtcclxuICAgICAgICBpZiAodGhpcy5lcnJvcikge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZXJyb3IgPSBuZXcgRXJyb3IobWVzc2FnZSk7XHJcbiAgICAgICAgdGhpcy5fY2xlYXJFdmVudHMoKTtcclxuICAgICAgICBpZiAodGhpcy54aHIpIHtcclxuICAgICAgICAgICAgdGhpcy54aHIuYWJvcnQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy54ZHIpIHtcclxuICAgICAgICAgICAgdGhpcy54ZHIuYWJvcnQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5kYXRhKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmRhdGEuc3JjKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGEuc3JjID0gUmVzb3VyY2VMb2FkZXIuRU1QVFlfR0lGO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKHRoaXMuZGF0YS5maXJzdENoaWxkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kYXRhLnJlbW92ZUNoaWxkKHRoaXMuZGF0YS5maXJzdENoaWxkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9maW5pc2goKTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIF9maW5pc2goKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNDb21wbGV0ZSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3NldEZsYWcoUmVzb3VyY2VMb2FkZXIuU1RBVFVTX0ZMQUdTLkNPTVBMRVRFLCB0cnVlKTtcclxuICAgICAgICB0aGlzLl9zZXRGbGFnKFJlc291cmNlTG9hZGVyLlNUQVRVU19GTEFHUy5MT0FESU5HLCBmYWxzZSk7XHJcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KEV2ZW50XzEuRXZlbnQuZ2V0RXZlbnQoRXZlbnRfMS5FdmVudC5DT01QTEVURSkpO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgX2RldGVybWluZUNyb3NzT3JpZ2luKHVybCwgbG9jID0gbnVsbCkge1xyXG4gICAgICAgIGlmICh1cmwuaW5kZXhPZignZGF0YTonKSA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gJyc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh3aW5kb3dbJ29yaWdpbiddICE9PSB3aW5kb3cubG9jYXRpb24ub3JpZ2luKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnYW5vbnltb3VzJztcclxuICAgICAgICB9XHJcbiAgICAgICAgbG9jID0gbG9jIHx8IHdpbmRvdy5sb2NhdGlvbjtcclxuICAgICAgICBpZiAoIVJlc291cmNlTG9hZGVyLnRlbXBBbmNob3IpIHtcclxuICAgICAgICAgICAgUmVzb3VyY2VMb2FkZXIudGVtcEFuY2hvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgUmVzb3VyY2VMb2FkZXIudGVtcEFuY2hvci5ocmVmID0gdXJsO1xyXG4gICAgICAgIGxldCB1cmkgPSBSZXNvdXJjZUxvYWRlci5wYXJzZVVyaShSZXNvdXJjZUxvYWRlci50ZW1wQW5jaG9yLmhyZWYsIHRydWUpO1xyXG4gICAgICAgIGxldCBzYW1lUG9ydCA9ICF1cmkucG9ydCAmJiBsb2MucG9ydCA9PT0gJycgfHwgdXJpLnBvcnQgPT09IGxvYy5wb3J0O1xyXG4gICAgICAgIGxldCBwcm90b2NvbCA9IHVyaS5wcm90b2NvbCA/IHVyaS5wcm90b2NvbCArICc6JyA6ICcnO1xyXG4gICAgICAgIGlmICh1cmkuaG9zdCAhPT0gbG9jLmhvc3RuYW1lIHx8ICFzYW1lUG9ydCB8fCBwcm90b2NvbCAhPT0gbG9jLnByb3RvY29sKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnYW5vbnltb3VzJztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgc3RhdGljIHBhcnNlVXJpKHN0ciwgc3RyaWN0ID0gdHJ1ZSkge1xyXG4gICAgICAgIGxldCBvID0ge1xyXG4gICAgICAgICAgICBrZXk6IFsnc291cmNlJywgJ3Byb3RvY29sJywgJ2F1dGhvcml0eScsICd1c2VySW5mbycsICd1c2VyJywgJ3Bhc3N3b3JkJywgJ2hvc3QnLCAncG9ydCcsICdyZWxhdGl2ZScsICdwYXRoJywgJ2RpcmVjdG9yeScsICdmaWxlJywgJ3F1ZXJ5JywgJ2FuY2hvciddLFxyXG4gICAgICAgICAgICBxOiB7XHJcbiAgICAgICAgICAgICAgICBuYW1lOiAncXVlcnlLZXknLFxyXG4gICAgICAgICAgICAgICAgcGFyc2VyOiAvKD86XnwmKShbXiY9XSopPT8oW14mXSopL2dcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgcGFyc2VyOiB7XHJcbiAgICAgICAgICAgICAgICBzdHJpY3Q6IC9eKD86KFteOlxcLz8jXSspOik/KD86XFwvXFwvKCg/OigoW146QF0qKSg/OjooW146QF0qKSk/KT9AKT8oW146XFwvPyNdKikoPzo6KFxcZCopKT8pKT8oKCgoPzpbXj8jXFwvXSpcXC8pKikoW14/I10qKSkoPzpcXD8oW14jXSopKT8oPzojKC4qKSk/KS8sXHJcbiAgICAgICAgICAgICAgICBsb29zZTogL14oPzooPyFbXjpAXSs6W146QFxcL10qQCkoW146XFwvPyMuXSspOik/KD86XFwvXFwvKT8oKD86KChbXjpAXSopKD86OihbXjpAXSopKT8pP0ApPyhbXjpcXC8/I10qKSg/OjooXFxkKikpPykoKChcXC8oPzpbXj8jXSg/IVtePyNcXC9dKlxcLltePyNcXC8uXSsoPzpbPyNdfCQpKSkqXFwvPyk/KFtePyNcXC9dKikpKD86XFw/KFteI10qKSk/KD86IyguKikpPykvXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIGxldCBtID0gby5wYXJzZXJbc3RyaWN0ID8gJ3N0cmljdCcgOiAnbG9vc2UnXS5leGVjKHN0cik7XHJcbiAgICAgICAgbGV0IHVyaSA9IG5ldyBVUklEYXRhKCk7XHJcbiAgICAgICAgdXJpLnNvdXJjZSA9IG1bXCJzb3VyY2VcIl0gfHwgJyc7XHJcbiAgICAgICAgdXJpLnByb3RvY29sID0gbVtcInByb3RvY29sXCJdIHx8ICcnO1xyXG4gICAgICAgIHVyaS5hdXRob3JpdHkgPSBtW1wiYXV0aG9yaXR5XCJdIHx8ICcnO1xyXG4gICAgICAgIHVyaS51c2VySW5mbyA9IG1bXCJ1c2VySW5mb1wiXSB8fCAnJztcclxuICAgICAgICB1cmkudXNlciA9IG1bXCJ1c2VyXCJdIHx8ICcnO1xyXG4gICAgICAgIHVyaS5wYXNzd29yZCA9IG1bXCJwYXNzd29yZFwiXSB8fCAnJztcclxuICAgICAgICB1cmkuaG9zdCA9IG1bXCJob3N0XCJdIHx8ICcnO1xyXG4gICAgICAgIHVyaS5wb3J0ID0gbVtcInBvcnRcIl0gfHwgJyc7XHJcbiAgICAgICAgdXJpLnJlbGF0aXZlID0gbVtcInJlbGF0aXZlXCJdIHx8ICcnO1xyXG4gICAgICAgIHVyaS5wYXRoID0gbVtcInBhdGhcIl0gfHwgJyc7XHJcbiAgICAgICAgdXJpLmRpcmVjdG9yeSA9IG1bXCJkaXJlY3RvcnlcIl0gfHwgJyc7XHJcbiAgICAgICAgdXJpLmZpbGUgPSBtW1wiZmlsZVwiXSB8fCAnJztcclxuICAgICAgICB1cmkucXVlcnkgPSBtW1wicXVlcnlcIl0gfHwgJyc7XHJcbiAgICAgICAgdXJpLmFuY2hvciA9IG1bXCJhbmNob3JcIl0gfHwgJyc7XHJcbiAgICAgICAgdXJpW28ucS5uYW1lXSA9IHt9O1xyXG4gICAgICAgIHVyaVtvLmtleVsxMl1dLnJlcGxhY2Uoby5xLnBhcnNlciwgZnVuY3Rpb24gKCQwLCAkMSwgJDIpIHtcclxuICAgICAgICAgICAgaWYgKCQxKSB7XHJcbiAgICAgICAgICAgICAgICB1cmlbby5xLm5hbWVdWyQxXSA9ICQyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHVyaTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIF9kZXRlcm1pbmVMb2FkVHlwZSgpIHtcclxuICAgICAgICByZXR1cm4gUmVzb3VyY2VMb2FkZXIuX2xvYWRUeXBlTWFwW3RoaXMuZXh0ZW5zaW9uXSB8fCBSZXNvdXJjZUxvYWRlci5MT0FEX1RZUEUuWEhSO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgX2dldEV4dGVuc2lvbigpIHtcclxuICAgICAgICBsZXQgdXJsID0gdGhpcy5fcmVxdWVzdC51cmw7XHJcbiAgICAgICAgbGV0IGV4dCA9ICcnO1xyXG4gICAgICAgIGlmICh0aGlzLmlzRGF0YVVybCkge1xyXG4gICAgICAgICAgICBsZXQgc2xhc2hJbmRleCA9IHVybC5pbmRleE9mKCcvJyk7XHJcbiAgICAgICAgICAgIGV4dCA9IHVybC5zdWJzdHJpbmcoc2xhc2hJbmRleCArIDEsIHVybC5pbmRleE9mKCc7Jywgc2xhc2hJbmRleCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbGV0IHF1ZXJ5U3RhcnQgPSB1cmwuaW5kZXhPZignPycpO1xyXG4gICAgICAgICAgICBsZXQgaGFzaFN0YXJ0ID0gdXJsLmluZGV4T2YoJyMnKTtcclxuICAgICAgICAgICAgbGV0IGluZGV4ID0gTWF0aC5taW4ocXVlcnlTdGFydCA+IC0xID8gcXVlcnlTdGFydCA6IHVybC5sZW5ndGgsIGhhc2hTdGFydCA+IC0xID8gaGFzaFN0YXJ0IDogdXJsLmxlbmd0aCk7XHJcbiAgICAgICAgICAgIHVybCA9IHVybC5zdWJzdHJpbmcoMCwgaW5kZXgpO1xyXG4gICAgICAgICAgICBleHQgPSB1cmwuc3Vic3RyaW5nKHVybC5sYXN0SW5kZXhPZignLicpICsgMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBleHQudG9Mb3dlckNhc2UoKTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIF9oYXNGbGFnKGZsYWcpIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMuX2ZsYWdzICYgZmxhZykgIT09IDA7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICBfc2V0RmxhZyhmbGFnLCB2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuX2ZsYWdzID0gdmFsdWUgPyB0aGlzLl9mbGFncyB8IGZsYWcgOiB0aGlzLl9mbGFncyAmIH5mbGFnO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgc3RhdGljIHNldEV4dE1hcChtYXAsIGV4dG5hbWUsIHZhbCkge1xyXG4gICAgICAgIGlmIChleHRuYW1lICYmIGV4dG5hbWUuaW5kZXhPZignLicpID09PSAwKSB7XHJcbiAgICAgICAgICAgIGV4dG5hbWUgPSBleHRuYW1lLnN1YnN0cmluZygxKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFleHRuYW1lKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgbWFwW2V4dG5hbWVdID0gdmFsO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIHNldEV4dGVuc2lvbkxvYWRUeXBlKGV4dG5hbWUsIGxvYWRUeXBlKSB7XHJcbiAgICAgICAgUmVzb3VyY2VMb2FkZXIuc2V0RXh0TWFwKFJlc291cmNlTG9hZGVyLl9sb2FkVHlwZU1hcCwgZXh0bmFtZSwgbG9hZFR5cGUpO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgc3RhdGljIHNldEV4dGVuc2lvblhoclR5cGUoZXh0bmFtZSwgeGhyVHlwZSkge1xyXG4gICAgICAgIFJlc291cmNlTG9hZGVyLnNldEV4dE1hcChSZXNvdXJjZUxvYWRlci5feGhyVHlwZU1hcCwgZXh0bmFtZSwgeGhyVHlwZSk7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFF1aWNrIGhlbHBlciB0byBnZXQgc3RyaW5nIHhociB0eXBlLlxyXG4gICAgICpcclxuICAgICAqIEBpZ25vcmVcclxuICAgICAqIEBwYXJhbSB7WE1MSHR0cFJlcXVlc3R8WERvbWFpblJlcXVlc3R9IHhociAtIFRoZSByZXF1ZXN0IHRvIGNoZWNrLlxyXG4gICAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgdHlwZS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIHJlcVR5cGUoeGhyKSB7XHJcbiAgICAgICAgcmV0dXJuIHhoci50b1N0cmluZygpLnJlcGxhY2UoJ29iamVjdCAnLCAnJyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIExvYWRzIHRoaXMgcmVzb3VyY2VzIHVzaW5nIGFuIFhNTEh0dHBSZXF1ZXN0LlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIF9sb2FkWGhyKCkge1xyXG4gICAgICAgIC8vIC8vIGlmIHVuc2V0LCBkZXRlcm1pbmUgdGhlIHZhbHVlXHJcbiAgICAgICAgLy8gaWYgKHR5cGVvZiB0aGlzLnhoclR5cGUgIT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgLy8gICAgIHRoaXMueGhyVHlwZSA9IHRoaXMuX2RldGVybWluZVhoclR5cGUoKTtcclxuICAgICAgICAvLyB9XHJcbiAgICAgICAgLy8gdmFyIHhociA9IHRoaXMueGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XHJcbiAgICAgICAgLy8gLy8gc2V0IHRoZSByZXF1ZXN0IHR5cGUgYW5kIHVybFxyXG4gICAgICAgIC8vIHhoci5vcGVuKCdHRVQnLCB0aGlzLl9yZXF1ZXN0LnVybCwgdHJ1ZSk7XHJcbiAgICAgICAgLy8geGhyLnRpbWVvdXQgPSB0aGlzLnRpbWVvdXQ7XHJcbiAgICAgICAgLy8gLy8gbG9hZCBqc29uIGFzIHRleHQgYW5kIHBhcnNlIGl0IG91cnNlbHZlcy4gV2UgZG8gdGhpcyBiZWNhdXNlIHNvbWUgYnJvd3NlcnNcclxuICAgICAgICAvLyAvLyAqY291Z2gqIHNhZmFyaSAqY291Z2gqIGNhbid0IGRlYWwgd2l0aCBpdC5cclxuICAgICAgICAvLyBpZiAodGhpcy54aHJUeXBlID09PSBSZXNvdXJjZUxvYWRlci5YSFJfUkVTUE9OU0VfVFlQRS5KU09OIHx8IHRoaXMueGhyVHlwZSA9PT0gUmVzb3VyY2VMb2FkZXIuWEhSX1JFU1BPTlNFX1RZUEUuRE9DVU1FTlQpIHtcclxuICAgICAgICAvLyAgICAgeGhyLnJlc3BvbnNlVHlwZSA9IDxhbnk+UmVzb3VyY2VMb2FkZXIuWEhSX1JFU1BPTlNFX1RZUEUuVEVYVDtcclxuICAgICAgICAvLyB9IGVsc2Uge1xyXG4gICAgICAgIC8vICAgICB4aHIucmVzcG9uc2VUeXBlID0gdGhpcy54aHJUeXBlO1xyXG4gICAgICAgIC8vIH1cclxuICAgICAgICAvLyB4aHIuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCB0aGlzLl9ib3VuZFhock9uRXJyb3IsIGZhbHNlKTtcclxuICAgICAgICAvLyB4aHIuYWRkRXZlbnRMaXN0ZW5lcigndGltZW91dCcsIHRoaXMuX2JvdW5kWGhyT25UaW1lb3V0LCBmYWxzZSk7XHJcbiAgICAgICAgLy8geGhyLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgdGhpcy5fYm91bmRYaHJPbkFib3J0LCBmYWxzZSk7XHJcbiAgICAgICAgLy8geGhyLmFkZEV2ZW50TGlzdGVuZXIoJ3Byb2dyZXNzJywgdGhpcy5fYm91bmRPblByb2dyZXNzLCBmYWxzZSk7XHJcbiAgICAgICAgLy8geGhyLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCB0aGlzLl9ib3VuZFhock9uTG9hZCwgZmFsc2UpO1xyXG4gICAgICAgIC8vIHhoci5zZW5kKCk7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIExvYWRzIHRoaXMgcmVzb3VyY2VzIHVzaW5nIGFuIFhEb21haW5SZXF1ZXN0LiBUaGlzIGlzIGhlcmUgYmVjYXVzZSB3ZSBuZWVkIHRvIHN1cHBvcnQgSUU5IChncm9zcykuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgX2xvYWRYZHIoKSB7XHJcbiAgICAgICAgLy8gLy8gaWYgdW5zZXQsIGRldGVybWluZSB0aGUgdmFsdWVcclxuICAgICAgICAvLyBpZiAodHlwZW9mIHRoaXMueGhyVHlwZSAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgICAvLyAgICAgdGhpcy54aHJUeXBlID0gdGhpcy5fZGV0ZXJtaW5lWGhyVHlwZSgpO1xyXG4gICAgICAgIC8vIH1cclxuICAgICAgICAvLyB2YXIgeGRyID0gdGhpcy54aHIgPSBuZXcgd2luZG93WydYRG9tYWluUmVxdWVzdCddKCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcclxuICAgICAgICAvLyAvLyBYRG9tYWluUmVxdWVzdCBoYXMgYSBmZXcgcXVpcmtzLiBPY2Nhc2lvbmFsbHkgaXQgd2lsbCBhYm9ydCByZXF1ZXN0c1xyXG4gICAgICAgIC8vIC8vIEEgd2F5IHRvIGF2b2lkIHRoaXMgaXMgdG8gbWFrZSBzdXJlIEFMTCBjYWxsYmFja3MgYXJlIHNldCBldmVuIGlmIG5vdCB1c2VkXHJcbiAgICAgICAgLy8gLy8gTW9yZSBpbmZvIGhlcmU6IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTU3ODY5NjYveGRvbWFpbnJlcXVlc3QtYWJvcnRzLXBvc3Qtb24taWUtOVxyXG4gICAgICAgIC8vIHhkci50aW1lb3V0ID0gdGhpcy50aW1lb3V0IHx8IDUwMDA7IC8vIFhEUiBuZWVkcyBhIHRpbWVvdXQgdmFsdWUgb3IgaXQgYnJlYWtzIGluIElFOVxyXG4gICAgICAgIC8vIHhkci5vbmVycm9yID0gdGhpcy5fYm91bmRYaHJPbkVycm9yO1xyXG4gICAgICAgIC8vIHhkci5vbnRpbWVvdXQgPSB0aGlzLl9ib3VuZFhock9uVGltZW91dDtcclxuICAgICAgICAvLyB4ZHIub25wcm9ncmVzcyA9IHRoaXMuX2JvdW5kT25Qcm9ncmVzcztcclxuICAgICAgICAvLyB4ZHIub25sb2FkID0gdGhpcy5fYm91bmRYaHJPbkxvYWQ7XHJcbiAgICAgICAgLy8geGRyLm9wZW4oJ0dFVCcsIHRoaXMuX3JlcXVlc3QudXJsLCB0cnVlKTtcclxuICAgICAgICAvLyAvLyBOb3RlOiBUaGUgeGRyLnNlbmQoKSBjYWxsIGlzIHdyYXBwZWQgaW4gYSB0aW1lb3V0IHRvIHByZXZlbnQgYW5cclxuICAgICAgICAvLyAvLyBpc3N1ZSB3aXRoIHRoZSBpbnRlcmZhY2Ugd2hlcmUgc29tZSByZXF1ZXN0cyBhcmUgbG9zdCBpZiBtdWx0aXBsZVxyXG4gICAgICAgIC8vIC8vIFhEb21haW5SZXF1ZXN0cyBhcmUgYmVpbmcgc2VudCBhdCB0aGUgc2FtZSB0aW1lLlxyXG4gICAgICAgIC8vIC8vIFNvbWUgaW5mbyBoZXJlOiBodHRwczovL2dpdGh1Yi5jb20vcGhvdG9uc3Rvcm0vcGhhc2VyL2lzc3Vlcy8xMjQ4XHJcbiAgICAgICAgLy8gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gICAgIHJldHVybiB4ZHIuc2VuZCgpO1xyXG4gICAgICAgIC8vIH0sIDEpO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgc291cmNlIHVzZWQgaW4gbG9hZGluZyB2aWEgYW4gZWxlbWVudC5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgLSBUaGUgZWxlbWVudCB0eXBlICh2aWRlbyBvciBhdWRpbykuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsIC0gVGhlIHNvdXJjZSBVUkwgdG8gbG9hZCBmcm9tLlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFttaW1lXSAtIFRoZSBtaW1lIHR5cGUgb2YgdGhlIHZpZGVvXHJcbiAgICAgKiBAcmV0dXJuIHtIVE1MU291cmNlRWxlbWVudH0gVGhlIHNvdXJjZSBlbGVtZW50LlxyXG4gICAgICovXHJcbiAgICBfY3JlYXRlU291cmNlKHR5cGUsIHVybCwgbWltZSkge1xyXG4gICAgICAgIC8vIGlmICghbWltZSkge1xyXG4gICAgICAgIC8vICAgICBtaW1lID0gdHlwZSArICcvJyArIHRoaXMuX2dldEV4dGVuc2lvbih1cmwpO1xyXG4gICAgICAgIC8vIH1cclxuICAgICAgICAvLyB2YXIgc291cmNlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc291cmNlJyk7XHJcbiAgICAgICAgLy8gc291cmNlLnNyYyA9IHVybDtcclxuICAgICAgICAvLyBzb3VyY2UudHlwZSA9IG1pbWU7XHJcbiAgICAgICAgLy8gcmV0dXJuIHNvdXJjZTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQ2FsbGVkIGlmIGFuIGVycm9yIGV2ZW50IGZpcmVzIGZvciB4aHIveGRyLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIF94aHJPbkVycm9yKCkge1xyXG4gICAgICAgIHZhciB4aHIgPSB0aGlzLnhocjtcclxuICAgICAgICB0aGlzLmFib3J0KFJlc291cmNlTG9hZGVyLnJlcVR5cGUoeGhyKSArICcgUmVxdWVzdCBmYWlsZWQuIFN0YXR1czogJyArIHhoci5zdGF0dXMgKyAnLCB0ZXh0OiBcIicgKyB4aHIuc3RhdHVzVGV4dCArICdcIicpO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxsZWQgaWYgYW4gZXJyb3IgZXZlbnQgZmlyZXMgZm9yIHhoci94ZHIuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgX3hock9uVGltZW91dCgpIHtcclxuICAgICAgICB2YXIgeGhyID0gdGhpcy54aHI7XHJcbiAgICAgICAgdGhpcy5hYm9ydChSZXNvdXJjZUxvYWRlci5yZXFUeXBlKHhocikgKyAnIFJlcXVlc3QgdGltZWQgb3V0LicpO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxsZWQgaWYgYW4gYWJvcnQgZXZlbnQgZmlyZXMgZm9yIHhoci94ZHIuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgX3hock9uQWJvcnQoKSB7XHJcbiAgICAgICAgdmFyIHhociA9IHRoaXMueGhyO1xyXG4gICAgICAgIHRoaXMuYWJvcnQoUmVzb3VyY2VMb2FkZXIucmVxVHlwZSh4aHIpICsgJyBSZXF1ZXN0IHdhcyBhYm9ydGVkIGJ5IHRoZSB1c2VyLicpO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxsZWQgd2hlbiBkYXRhIHN1Y2Nlc3NmdWxseSBsb2FkcyBmcm9tIGFuIHhoci94ZHIgcmVxdWVzdC5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtYTUxIdHRwUmVxdWVzdExvYWRFdmVudHxFdmVudH0gZXZlbnQgLSBMb2FkIGV2ZW50XHJcbiAgICAgKi9cclxuICAgIF94aHJPbkxvYWQoKSB7XHJcbiAgICAgICAgLy8gdmFyIHhociA9IHRoaXMueGhyO1xyXG4gICAgICAgIC8vIHZhciB0ZXh0ID0gJyc7XHJcbiAgICAgICAgLy8gdmFyIHN0YXR1cyA9IHR5cGVvZiB4aHIuc3RhdHVzID09PSAndW5kZWZpbmVkJyA/IFJlc291cmNlTG9hZGVyLlNUQVRVU19PSyA6IHhoci5zdGF0dXM7IC8vIFhEUiBoYXMgbm8gYC5zdGF0dXNgLCBhc3N1bWUgMjAwLlxyXG4gICAgICAgIC8vIC8vIHJlc3BvbnNlVGV4dCBpcyBhY2Nlc3NpYmxlIG9ubHkgaWYgcmVzcG9uc2VUeXBlIGlzICcnIG9yICd0ZXh0JyBhbmQgb24gb2xkZXIgYnJvd3NlcnNcclxuICAgICAgICAvLyBpZiAoeGhyLnJlc3BvbnNlVHlwZSA9PT0gJycgfHwgeGhyLnJlc3BvbnNlVHlwZSA9PT0gJ3RleHQnIHx8IHR5cGVvZiB4aHIucmVzcG9uc2VUeXBlID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIC8vICAgICB0ZXh0ID0geGhyLnJlc3BvbnNlVGV4dDtcclxuICAgICAgICAvLyB9XHJcbiAgICAgICAgLy8gLy8gc3RhdHVzIGNhbiBiZSAwIHdoZW4gdXNpbmcgdGhlIGBmaWxlOi8vYCBwcm90b2NvbCBzbyB3ZSBhbHNvIGNoZWNrIGlmIGEgcmVzcG9uc2UgaXMgc2V0LlxyXG4gICAgICAgIC8vIC8vIElmIGl0IGhhcyBhIHJlc3BvbnNlLCB3ZSBhc3N1bWUgMjAwOyBvdGhlcndpc2UgYSAwIHN0YXR1cyBjb2RlIHdpdGggbm8gY29udGVudHMgaXMgYW4gYWJvcnRlZCByZXF1ZXN0LlxyXG4gICAgICAgIC8vIGlmIChzdGF0dXMgPT09IFJlc291cmNlTG9hZGVyLlNUQVRVU19OT05FICYmICh0ZXh0Lmxlbmd0aCA+IDAgfHwgeGhyLnJlc3BvbnNlVHlwZSA9PT0gUmVzb3VyY2VMb2FkZXIuWEhSX1JFU1BPTlNFX1RZUEUuQlVGRkVSKSkge1xyXG4gICAgICAgIC8vICAgICBzdGF0dXMgPSBSZXNvdXJjZUxvYWRlci5TVEFUVVNfT0s7XHJcbiAgICAgICAgLy8gfVxyXG4gICAgICAgIC8vIC8vIGhhbmRsZSBJRTkgYnVnOiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzEwMDQ2OTcyL21zaWUtcmV0dXJucy1zdGF0dXMtY29kZS1vZi0xMjIzLWZvci1hamF4LXJlcXVlc3RcclxuICAgICAgICAvLyBlbHNlIGlmIChzdGF0dXMgPT09IFJlc291cmNlTG9hZGVyLlNUQVRVU19JRV9CVUdfRU1QVFkpIHtcclxuICAgICAgICAvLyAgICAgICAgIHN0YXR1cyA9IFJlc291cmNlTG9hZGVyLlNUQVRVU19FTVBUWTtcclxuICAgICAgICAvLyAgICAgfVxyXG4gICAgICAgIC8vIHZhciBzdGF0dXNUeXBlID0gc3RhdHVzIC8gMTAwIHwgMDtcclxuICAgICAgICAvLyBpZiAoc3RhdHVzVHlwZSA9PT0gUmVzb3VyY2VMb2FkZXIuU1RBVFVTX1RZUEVfT0spIHtcclxuICAgICAgICAvLyAgICAgLy8gaWYgdGV4dCwganVzdCByZXR1cm4gaXRcclxuICAgICAgICAvLyAgICAgaWYgKHRoaXMueGhyVHlwZSA9PT0gUmVzb3VyY2VMb2FkZXIuWEhSX1JFU1BPTlNFX1RZUEUuVEVYVCkge1xyXG4gICAgICAgIC8vICAgICAgICAgdGhpcy5kYXRhID0gdGV4dDtcclxuICAgICAgICAvLyAgICAgICAgIHRoaXMudHlwZSA9IFJlc291cmNlTG9hZGVyLlRZUEUuVEVYVDtcclxuICAgICAgICAvLyAgICAgfVxyXG4gICAgICAgIC8vICAgICAvLyBpZiBqc29uLCBwYXJzZSBpbnRvIGpzb24gb2JqZWN0XHJcbiAgICAgICAgLy8gICAgIGVsc2UgaWYgKHRoaXMueGhyVHlwZSA9PT0gUmVzb3VyY2VMb2FkZXIuWEhSX1JFU1BPTlNFX1RZUEUuSlNPTikge1xyXG4gICAgICAgIC8vICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgIHRoaXMuZGF0YSA9IEpTT04ucGFyc2UodGV4dCk7XHJcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgIHRoaXMudHlwZSA9IFJlc291cmNlTG9hZGVyLlRZUEUuSlNPTjtcclxuICAgICAgICAvLyAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgIHRoaXMuYWJvcnQoJ0Vycm9yIHRyeWluZyB0byBwYXJzZSBsb2FkZWQganNvbjogJyArIGUpO1xyXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgLy8gICAgICAgICAgICAgfVxyXG4gICAgICAgIC8vICAgICAgICAgfVxyXG4gICAgICAgIC8vICAgICAgICAgLy8gaWYgeG1sLCBwYXJzZSBpbnRvIGFuIHhtbCBkb2N1bWVudCBvciBkaXYgZWxlbWVudFxyXG4gICAgICAgIC8vICAgICAgICAgZWxzZSBpZiAodGhpcy54aHJUeXBlID09PSBSZXNvdXJjZUxvYWRlci5YSFJfUkVTUE9OU0VfVFlQRS5ET0NVTUVOVCkge1xyXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgaWYgKHdpbmRvd1snRE9NUGFyc2VyJ10pIHtcclxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZG9tcGFyc2VyID0gbmV3IERPTVBhcnNlcigpO1xyXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGF0YSA9IGRvbXBhcnNlci5wYXJzZUZyb21TdHJpbmcodGV4dCwgJ3RleHQveG1sJyk7XHJcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICBkaXYuaW5uZXJIVE1MID0gdGV4dDtcclxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRhdGEgPSBkaXY7XHJcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICB0aGlzLnR5cGUgPSBSZXNvdXJjZUxvYWRlci5UWVBFLlhNTDtcclxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgdGhpcy5hYm9ydCgnRXJyb3IgdHJ5aW5nIHRvIHBhcnNlIGxvYWRlZCB4bWw6ICcgKyBlKTtcclxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgIC8vICAgICAgICAgICAgIH1cclxuICAgICAgICAvLyAgICAgICAgICAgICAvLyBvdGhlciB0eXBlcyBqdXN0IHJldHVybiB0aGUgcmVzcG9uc2VcclxuICAgICAgICAvLyAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGF0YSA9IHhoci5yZXNwb25zZSB8fCB0ZXh0O1xyXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgLy8gfSBlbHNlIHtcclxuICAgICAgICAvLyAgICAgdGhpcy5hYm9ydCgnWycgKyB4aHIuc3RhdHVzICsgJ10gJyArIHhoci5zdGF0dXNUZXh0ICsgJzogJyArIHhoci5yZXNwb25zZVVSTCk7XHJcbiAgICAgICAgLy8gICAgIHJldHVybjtcclxuICAgICAgICAvLyB9XHJcbiAgICAgICAgLy8gdGhpcy5jb21wbGV0ZSgpO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBEZXRlcm1pbmVzIHRoZSByZXNwb25zZVR5cGUgb2YgYW4gWEhSIHJlcXVlc3QgYmFzZWQgb24gdGhlIGV4dGVuc2lvbiBvZiB0aGVcclxuICAgICAqIHJlc291cmNlIGJlaW5nIGxvYWRlZC5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHJldHVybiB7UmVzb3VyY2UuWEhSX1JFU1BPTlNFX1RZUEV9IFRoZSByZXNwb25zZVR5cGUgdG8gdXNlLlxyXG4gICAgICovXHJcbiAgICBfZGV0ZXJtaW5lWGhyVHlwZSgpIHtcclxuICAgICAgICByZXR1cm4gUmVzb3VyY2VMb2FkZXIuX3hoclR5cGVNYXBbdGhpcy5leHRlbnNpb25dIHx8IFJlc291cmNlTG9hZGVyLlhIUl9SRVNQT05TRV9UWVBFLlRFWFQ7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIERldGVybWluZXMgdGhlIGxvYWRUeXBlIG9mIGEgcmVzb3VyY2UgYmFzZWQgb24gdGhlIGV4dGVuc2lvbiBvZiB0aGVcclxuICAgICAqIHJlc291cmNlIGJlaW5nIGxvYWRlZC5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHJldHVybiB7UmVzb3VyY2UuTE9BRF9UWVBFfSBUaGUgbG9hZFR5cGUgdG8gdXNlLlxyXG4gICAgICovXHJcbiAgICAvKipcclxuICAgICAqIERldGVybWluZXMgdGhlIG1pbWUgdHlwZSBvZiBhbiBYSFIgcmVxdWVzdCBiYXNlZCBvbiB0aGUgcmVzcG9uc2VUeXBlIG9mXHJcbiAgICAgKiByZXNvdXJjZSBiZWluZyBsb2FkZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7UmVzb3VyY2UuWEhSX1JFU1BPTlNFX1RZUEV9IHR5cGUgLSBUaGUgdHlwZSB0byBnZXQgYSBtaW1lIHR5cGUgZm9yLlxyXG4gICAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgbWltZSB0eXBlIHRvIHVzZS5cclxuICAgICAqL1xyXG4gICAgX2dldE1pbWVGcm9tWGhyVHlwZSh0eXBlKSB7XHJcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgUmVzb3VyY2VMb2FkZXIuWEhSX1JFU1BPTlNFX1RZUEUuQlVGRkVSOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuICdhcHBsaWNhdGlvbi9vY3RldC1iaW5hcnknO1xyXG4gICAgICAgICAgICBjYXNlIFJlc291cmNlTG9hZGVyLlhIUl9SRVNQT05TRV9UWVBFLkJMT0I6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2FwcGxpY2F0aW9uL2Jsb2InO1xyXG4gICAgICAgICAgICBjYXNlIFJlc291cmNlTG9hZGVyLlhIUl9SRVNQT05TRV9UWVBFLkRPQ1VNRU5UOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuICdhcHBsaWNhdGlvbi94bWwnO1xyXG4gICAgICAgICAgICBjYXNlIFJlc291cmNlTG9hZGVyLlhIUl9SRVNQT05TRV9UWVBFLkpTT046XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2FwcGxpY2F0aW9uL2pzb24nO1xyXG4gICAgICAgICAgICBjYXNlIFJlc291cmNlTG9hZGVyLlhIUl9SRVNQT05TRV9UWVBFLkRFRkFVTFQ6XHJcbiAgICAgICAgICAgIGNhc2UgUmVzb3VyY2VMb2FkZXIuWEhSX1JFU1BPTlNFX1RZUEUuVEVYVDpcclxuICAgICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuICd0ZXh0L3BsYWluJztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICBnZXQgaXNEYXRhVXJsKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9oYXNGbGFnKFJlc291cmNlTG9hZGVyLlNUQVRVU19GTEFHUy5EQVRBX1VSTCk7XHJcbiAgICB9XHJcbiAgICBnZXQgaXNDb21wbGV0ZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5faGFzRmxhZyhSZXNvdXJjZUxvYWRlci5TVEFUVVNfRkxBR1MuQ09NUExFVEUpO1xyXG4gICAgfVxyXG4gICAgZ2V0IGlzTG9hZGluZygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5faGFzRmxhZyhSZXNvdXJjZUxvYWRlci5TVEFUVVNfRkxBR1MuTE9BRElORyk7XHJcbiAgICB9XHJcbn1cclxuUmVzb3VyY2VMb2FkZXIuU1RBVFVTX05PTkUgPSAwO1xyXG5SZXNvdXJjZUxvYWRlci5TVEFUVVNfT0sgPSAyMDA7XHJcblJlc291cmNlTG9hZGVyLlNUQVRVU19FTVBUWSA9IDIwNDtcclxuUmVzb3VyY2VMb2FkZXIuU1RBVFVTX0lFX0JVR19FTVBUWSA9IDEyMjM7XHJcblJlc291cmNlTG9hZGVyLlNUQVRVU19UWVBFX09LID0gMjtcclxuUmVzb3VyY2VMb2FkZXIudXNlWGRyID0gISEod2luZG93WydYRG9tYWluUmVxdWVzdCddICYmICEoJ3dpdGhDcmVkZW50aWFscycgaW4gbmV3IFhNTEh0dHBSZXF1ZXN0KCkpKTtcclxuUmVzb3VyY2VMb2FkZXIuRU1QVFlfR0lGID0gJ2RhdGE6aW1hZ2UvZ2lmO2Jhc2U2NCxSMGxHT0RsaEFRQUJBSUFBQVAvLy93QUFBQ0g1QkFFQUFBQUFMQUFBQUFBQkFBRUFBQUlDUkFFQU93PT0nO1xyXG5SZXNvdXJjZUxvYWRlci5MT0FEX1RZUEUgPSB7XHJcbiAgICBYSFI6IDEsXHJcbiAgICBJTUFHRTogMixcclxuICAgIEFVRElPOiAzLFxyXG4gICAgVklERU86IDRcclxufTtcclxuUmVzb3VyY2VMb2FkZXIuWEhSX1JFU1BPTlNFX1RZUEUgPSB7XHJcbiAgICBERUZBVUxUOiAndGV4dCcsXHJcbiAgICBCVUZGRVI6ICdhcnJheWJ1ZmZlcicsXHJcbiAgICBCTE9COiAnYmxvYicsXHJcbiAgICBET0NVTUVOVDogJ2RvY3VtZW50JyxcclxuICAgIEpTT046ICdqc29uJyxcclxuICAgIFRFWFQ6ICd0ZXh0J1xyXG59O1xyXG5SZXNvdXJjZUxvYWRlci5feGhyVHlwZU1hcCA9IHtcclxuICAgIHhodG1sOiBSZXNvdXJjZUxvYWRlci5YSFJfUkVTUE9OU0VfVFlQRS5ET0NVTUVOVCxcclxuICAgIGh0bWw6IFJlc291cmNlTG9hZGVyLlhIUl9SRVNQT05TRV9UWVBFLkRPQ1VNRU5ULFxyXG4gICAgaHRtOiBSZXNvdXJjZUxvYWRlci5YSFJfUkVTUE9OU0VfVFlQRS5ET0NVTUVOVCxcclxuICAgIHhtbDogUmVzb3VyY2VMb2FkZXIuWEhSX1JFU1BPTlNFX1RZUEUuRE9DVU1FTlQsXHJcbiAgICB0bXg6IFJlc291cmNlTG9hZGVyLlhIUl9SRVNQT05TRV9UWVBFLkRPQ1VNRU5ULFxyXG4gICAgc3ZnOiBSZXNvdXJjZUxvYWRlci5YSFJfUkVTUE9OU0VfVFlQRS5ET0NVTUVOVCxcclxuICAgIHRzeDogUmVzb3VyY2VMb2FkZXIuWEhSX1JFU1BPTlNFX1RZUEUuRE9DVU1FTlQsXHJcbiAgICBnaWY6IFJlc291cmNlTG9hZGVyLlhIUl9SRVNQT05TRV9UWVBFLkJMT0IsXHJcbiAgICBwbmc6IFJlc291cmNlTG9hZGVyLlhIUl9SRVNQT05TRV9UWVBFLkJMT0IsXHJcbiAgICBibXA6IFJlc291cmNlTG9hZGVyLlhIUl9SRVNQT05TRV9UWVBFLkJMT0IsXHJcbiAgICBqcGc6IFJlc291cmNlTG9hZGVyLlhIUl9SRVNQT05TRV9UWVBFLkJMT0IsXHJcbiAgICBqcGVnOiBSZXNvdXJjZUxvYWRlci5YSFJfUkVTUE9OU0VfVFlQRS5CTE9CLFxyXG4gICAgdGlmOiBSZXNvdXJjZUxvYWRlci5YSFJfUkVTUE9OU0VfVFlQRS5CTE9CLFxyXG4gICAgdGlmZjogUmVzb3VyY2VMb2FkZXIuWEhSX1JFU1BPTlNFX1RZUEUuQkxPQixcclxuICAgIHdlYnA6IFJlc291cmNlTG9hZGVyLlhIUl9SRVNQT05TRV9UWVBFLkJMT0IsXHJcbiAgICB0Z2E6IFJlc291cmNlTG9hZGVyLlhIUl9SRVNQT05TRV9UWVBFLkJMT0IsXHJcbiAgICBqc29uOiBSZXNvdXJjZUxvYWRlci5YSFJfUkVTUE9OU0VfVFlQRS5KU09OLFxyXG4gICAgdGV4dDogUmVzb3VyY2VMb2FkZXIuWEhSX1JFU1BPTlNFX1RZUEUuVEVYVCxcclxuICAgIHR4dDogUmVzb3VyY2VMb2FkZXIuWEhSX1JFU1BPTlNFX1RZUEUuVEVYVCxcclxuICAgIHR0ZjogUmVzb3VyY2VMb2FkZXIuWEhSX1JFU1BPTlNFX1RZUEUuQlVGRkVSLFxyXG4gICAgb3RmOiBSZXNvdXJjZUxvYWRlci5YSFJfUkVTUE9OU0VfVFlQRS5CVUZGRVJcclxufTtcclxuUmVzb3VyY2VMb2FkZXIuX2xvYWRUeXBlTWFwID0ge1xyXG4gICAgZ2lmOiBSZXNvdXJjZUxvYWRlci5MT0FEX1RZUEUuSU1BR0UsXHJcbiAgICBwbmc6IFJlc291cmNlTG9hZGVyLkxPQURfVFlQRS5JTUFHRSxcclxuICAgIGJtcDogUmVzb3VyY2VMb2FkZXIuTE9BRF9UWVBFLklNQUdFLFxyXG4gICAganBnOiBSZXNvdXJjZUxvYWRlci5MT0FEX1RZUEUuSU1BR0UsXHJcbiAgICBqcGVnOiBSZXNvdXJjZUxvYWRlci5MT0FEX1RZUEUuSU1BR0UsXHJcbiAgICB0aWY6IFJlc291cmNlTG9hZGVyLkxPQURfVFlQRS5JTUFHRSxcclxuICAgIHRpZmY6IFJlc291cmNlTG9hZGVyLkxPQURfVFlQRS5JTUFHRSxcclxuICAgIHdlYnA6IFJlc291cmNlTG9hZGVyLkxPQURfVFlQRS5JTUFHRSxcclxuICAgIHRnYTogUmVzb3VyY2VMb2FkZXIuTE9BRF9UWVBFLklNQUdFLFxyXG4gICAgc3ZnOiBSZXNvdXJjZUxvYWRlci5MT0FEX1RZUEUuSU1BR0UsXHJcbiAgICAnc3ZnK3htbCc6IFJlc291cmNlTG9hZGVyLkxPQURfVFlQRS5JTUFHRSxcclxuICAgIG1wMzogUmVzb3VyY2VMb2FkZXIuTE9BRF9UWVBFLkFVRElPLFxyXG4gICAgb2dnOiBSZXNvdXJjZUxvYWRlci5MT0FEX1RZUEUuQVVESU8sXHJcbiAgICB3YXY6IFJlc291cmNlTG9hZGVyLkxPQURfVFlQRS5BVURJTyxcclxuICAgIG1wNDogUmVzb3VyY2VMb2FkZXIuTE9BRF9UWVBFLlZJREVPLFxyXG4gICAgd2VibTogUmVzb3VyY2VMb2FkZXIuTE9BRF9UWVBFLlZJREVPXHJcbn07XHJcblJlc291cmNlTG9hZGVyLlRZUEUgPSB7XHJcbiAgICBVTktOT1dOOiAwLFxyXG4gICAgSlNPTjogMSxcclxuICAgIFhNTDogMixcclxuICAgIElNQUdFOiAzLFxyXG4gICAgQVVESU86IDQsXHJcbiAgICBWSURFTzogNSxcclxuICAgIFRFWFQ6IDZcclxufTtcclxuUmVzb3VyY2VMb2FkZXIuU1RBVFVTX0ZMQUdTID0ge1xyXG4gICAgTk9ORTogMCxcclxuICAgIERBVEFfVVJMOiAxIDw8IDAsXHJcbiAgICBDT01QTEVURTogMSA8PCAxLFxyXG4gICAgTE9BRElORzogMSA8PCAyXHJcbn07XHJcbmV4cG9ydHMuUmVzb3VyY2VMb2FkZXIgPSBSZXNvdXJjZUxvYWRlcjtcclxuY2xhc3MgVVJJRGF0YSB7XHJcbn1cclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgSW1hZ2VSZXNvdXJjZV8xID0gcmVxdWlyZShcIi4vSW1hZ2VSZXNvdXJjZVwiKTtcclxuY29uc3QgQ2FudmFzUmVzb3VyY2VfMSA9IHJlcXVpcmUoXCIuL0NhbnZhc1Jlc291cmNlXCIpO1xyXG5jb25zdCBWaWRlb1Jlc291cmNlXzEgPSByZXF1aXJlKFwiLi9WaWRlb1Jlc291cmNlXCIpO1xyXG5jb25zdCBTVkdSZXNvdXJjZV8xID0gcmVxdWlyZShcIi4vU1ZHUmVzb3VyY2VcIik7XHJcbmNvbnN0IEJ1ZmZlclJlc291cmNlXzEgPSByZXF1aXJlKFwiLi9CdWZmZXJSZXNvdXJjZVwiKTtcclxuY29uc3QgQ3ViZVJlc291cmNlXzEgPSByZXF1aXJlKFwiLi9DdWJlUmVzb3VyY2VcIik7XHJcbmNvbnN0IEFycmF5UmVzb3VyY2VfMSA9IHJlcXVpcmUoXCIuL0FycmF5UmVzb3VyY2VcIik7XHJcbmNsYXNzIFJlc291cmNlU2V0dGluZ3Mge1xyXG4gICAgc3RhdGljIGF1dG9EZXRlY3RSZXNvdXJjZShzb3VyY2UsIG9wdGlvbnMpIHtcclxuICAgICAgICBpZiAoIXNvdXJjZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGV4dGVuc2lvbiA9ICcnO1xyXG4gICAgICAgIGlmICh0eXBlb2Ygc291cmNlID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gKC9cXC4oXFx3ezMsNH0pKD86JHxcXD98IykvaSkuZXhlYyhzb3VyY2UpO1xyXG4gICAgICAgICAgICBpZiAocmVzdWx0KSB7XHJcbiAgICAgICAgICAgICAgICBleHRlbnNpb24gPSByZXN1bHRbMV0udG9Mb3dlckNhc2UoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKHZhciBpID0gUmVzb3VyY2VTZXR0aW5ncy5JTlNUQUxMRUQubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcclxuICAgICAgICAgICAgdmFyIFJlc291cmNlUGx1Z2luID0gUmVzb3VyY2VTZXR0aW5ncy5JTlNUQUxMRURbaV07XHJcbiAgICAgICAgICAgIGlmIChSZXNvdXJjZVBsdWdpbi50ZXN0ICYmIFJlc291cmNlUGx1Z2luLnRlc3Qoc291cmNlLCBleHRlbnNpb24pKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFJlc291cmNlUGx1Z2luKHNvdXJjZSwgb3B0aW9ucyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBJbWFnZVJlc291cmNlXzEuSW1hZ2VSZXNvdXJjZShzb3VyY2UsIG9wdGlvbnMpO1xyXG4gICAgfVxyXG59XHJcblJlc291cmNlU2V0dGluZ3MuSU5TVEFMTEVEID0gW1xyXG4gICAgSW1hZ2VSZXNvdXJjZV8xLkltYWdlUmVzb3VyY2UsXHJcbiAgICBDYW52YXNSZXNvdXJjZV8xLkNhbnZhc1Jlc291cmNlLFxyXG4gICAgVmlkZW9SZXNvdXJjZV8xLlZpZGVvUmVzb3VyY2UsXHJcbiAgICBTVkdSZXNvdXJjZV8xLlNWR1Jlc291cmNlLFxyXG4gICAgQnVmZmVyUmVzb3VyY2VfMS5CdWZmZXJSZXNvdXJjZSxcclxuICAgIEN1YmVSZXNvdXJjZV8xLkN1YmVSZXNvdXJjZSxcclxuICAgIEFycmF5UmVzb3VyY2VfMS5BcnJheVJlc291cmNlXHJcbl07XHJcbmV4cG9ydHMuUmVzb3VyY2VTZXR0aW5ncyA9IFJlc291cmNlU2V0dGluZ3M7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IE1lc2hHZW9tZXRyeV8xID0gcmVxdWlyZShcIi4vTWVzaEdlb21ldHJ5XCIpO1xyXG5jbGFzcyBSb3BlR2VvbWV0cnkgZXh0ZW5kcyBNZXNoR2VvbWV0cnlfMS5NZXNoR2VvbWV0cnkge1xyXG4gICAgY29uc3RydWN0b3Iod2lkdGggPSAyMDAsIHBvaW50cyA9IG51bGwpIHtcclxuICAgICAgICBpZiAod2lkdGggPT09IHZvaWQgMCkge1xyXG4gICAgICAgICAgICB3aWR0aCA9IDIwMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgc3VwZXIobmV3IEZsb2F0MzJBcnJheShwb2ludHMubGVuZ3RoICogNCksIG5ldyBGbG9hdDMyQXJyYXkocG9pbnRzLmxlbmd0aCAqIDQpLCBuZXcgVWludDE2QXJyYXkoKHBvaW50cy5sZW5ndGggLSAxKSAqIDYpKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAqIEFuIGFycmF5IG9mIHBvaW50cyB0aGF0IGRldGVybWluZSB0aGUgcm9wZVxyXG4gICAgICAgICogQG1lbWJlciB7UElYSS5Qb2ludFtdfVxyXG4gICAgICAgICovXHJcbiAgICAgICAgdGhpcy5wb2ludHMgPSBwb2ludHM7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgKiBUaGUgd2lkdGggKGkuZS4sIHRoaWNrbmVzcykgb2YgdGhlIHJvcGUuXHJcbiAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgICAgKiBAcmVhZE9ubHlcclxuICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcclxuICAgICAgICB0aGlzLmJ1aWxkKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICogUmVmcmVzaGVzIFJvcGUgaW5kaWNlcyBhbmQgdXZzXHJcbiAgICAqIEBwcml2YXRlXHJcbiAgICAqL1xyXG4gICAgYnVpbGQoKSB7XHJcbiAgICAgICAgdmFyIHBvaW50cyA9IHRoaXMucG9pbnRzO1xyXG4gICAgICAgIGlmICghcG9pbnRzKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHZlcnRleEJ1ZmZlciA9IHRoaXMuZ2V0QXR0cmlidXRlKCdhVmVydGV4UG9zaXRpb24nKTtcclxuICAgICAgICB2YXIgdXZCdWZmZXIgPSB0aGlzLmdldEF0dHJpYnV0ZSgnYVRleHR1cmVDb29yZCcpO1xyXG4gICAgICAgIHZhciBpbmRleEJ1ZmZlciA9IHRoaXMuZ2V0SW5kZXgoKTtcclxuICAgICAgICAvLyBpZiB0b28gbGl0dGxlIHBvaW50cywgb3IgdGV4dHVyZSBoYXNuJ3QgZ290IFVWcyBzZXQgeWV0IGp1c3QgbW92ZSBvbi5cclxuICAgICAgICBpZiAocG9pbnRzLmxlbmd0aCA8IDEpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBpZiB0aGUgbnVtYmVyIG9mIHBvaW50cyBoYXMgY2hhbmdlZCB3ZSB3aWxsIG5lZWQgdG8gcmVjcmVhdGUgdGhlIGFycmF5YnVmZmVyc1xyXG4gICAgICAgIGlmICh2ZXJ0ZXhCdWZmZXIuZGF0YS5sZW5ndGggLyA0ICE9PSBwb2ludHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHZlcnRleEJ1ZmZlci5kYXRhID0gbmV3IEZsb2F0MzJBcnJheShwb2ludHMubGVuZ3RoICogNCk7XHJcbiAgICAgICAgICAgIHV2QnVmZmVyLmRhdGEgPSBuZXcgRmxvYXQzMkFycmF5KHBvaW50cy5sZW5ndGggKiA0KTtcclxuICAgICAgICAgICAgaW5kZXhCdWZmZXIuZGF0YSA9IG5ldyBVaW50MTZBcnJheSgocG9pbnRzLmxlbmd0aCAtIDEpICogNik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciB1dnMgPSB1dkJ1ZmZlci5kYXRhO1xyXG4gICAgICAgIHZhciBpbmRpY2VzID0gaW5kZXhCdWZmZXIuZGF0YTtcclxuICAgICAgICB1dnNbMF0gPSAwO1xyXG4gICAgICAgIHV2c1sxXSA9IDA7XHJcbiAgICAgICAgdXZzWzJdID0gMDtcclxuICAgICAgICB1dnNbM10gPSAxO1xyXG4gICAgICAgIC8vIGluZGljZXNbMF0gPSAwO1xyXG4gICAgICAgIC8vIGluZGljZXNbMV0gPSAxO1xyXG4gICAgICAgIHZhciB0b3RhbCA9IHBvaW50cy5sZW5ndGg7IC8vIC0gMTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRvdGFsOyBpKyspIHtcclxuICAgICAgICAgICAgLy8gdGltZSB0byBkbyBzb21lIHNtYXJ0IGRyYXdpbmchXHJcbiAgICAgICAgICAgIHZhciBpbmRleCA9IGkgKiA0O1xyXG4gICAgICAgICAgICB2YXIgYW1vdW50ID0gaSAvICh0b3RhbCAtIDEpO1xyXG4gICAgICAgICAgICB1dnNbaW5kZXhdID0gYW1vdW50O1xyXG4gICAgICAgICAgICB1dnNbaW5kZXggKyAxXSA9IDA7XHJcbiAgICAgICAgICAgIHV2c1tpbmRleCArIDJdID0gYW1vdW50O1xyXG4gICAgICAgICAgICB1dnNbaW5kZXggKyAzXSA9IDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBpbmRleENvdW50ID0gMDtcclxuICAgICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCB0b3RhbCAtIDE7IGkkMSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBpbmRleCQxID0gaSQxICogMjtcclxuICAgICAgICAgICAgaW5kaWNlc1tpbmRleENvdW50KytdID0gaW5kZXgkMTtcclxuICAgICAgICAgICAgaW5kaWNlc1tpbmRleENvdW50KytdID0gaW5kZXgkMSArIDE7XHJcbiAgICAgICAgICAgIGluZGljZXNbaW5kZXhDb3VudCsrXSA9IGluZGV4JDEgKyAyO1xyXG4gICAgICAgICAgICBpbmRpY2VzW2luZGV4Q291bnQrK10gPSBpbmRleCQxICsgMjtcclxuICAgICAgICAgICAgaW5kaWNlc1tpbmRleENvdW50KytdID0gaW5kZXgkMSArIDE7XHJcbiAgICAgICAgICAgIGluZGljZXNbaW5kZXhDb3VudCsrXSA9IGluZGV4JDEgKyAzO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBlbnN1cmUgdGhhdCB0aGUgY2hhbmdlcyBhcmUgdXBsb2FkZWRcclxuICAgICAgICB1dkJ1ZmZlci51cGRhdGUoKTtcclxuICAgICAgICBpbmRleEJ1ZmZlci51cGRhdGUoKTtcclxuICAgICAgICB0aGlzLnVwZGF0ZVZlcnRpY2VzKCk7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICogcmVmcmVzaGVzIHZlcnRpY2VzIG9mIFJvcGUgbWVzaFxyXG4gICAgKi9cclxuICAgIHVwZGF0ZVZlcnRpY2VzKCkge1xyXG4gICAgICAgIHZhciBwb2ludHMgPSB0aGlzLnBvaW50cztcclxuICAgICAgICBpZiAocG9pbnRzLmxlbmd0aCA8IDEpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbGFzdFBvaW50ID0gcG9pbnRzWzBdO1xyXG4gICAgICAgIHZhciBuZXh0UG9pbnQ7XHJcbiAgICAgICAgdmFyIHBlcnBYID0gMDtcclxuICAgICAgICB2YXIgcGVycFkgPSAwO1xyXG4gICAgICAgIC8vIHRoaXMuY291bnQgLT0gMC4yO1xyXG4gICAgICAgIHZhciB2ZXJ0aWNlcyA9IHRoaXMuYnVmZmVyc1swXS5kYXRhO1xyXG4gICAgICAgIHZhciB0b3RhbCA9IHBvaW50cy5sZW5ndGg7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b3RhbDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBwb2ludCA9IHBvaW50c1tpXTtcclxuICAgICAgICAgICAgdmFyIGluZGV4ID0gaSAqIDQ7XHJcbiAgICAgICAgICAgIGlmIChpIDwgcG9pbnRzLmxlbmd0aCAtIDEpIHtcclxuICAgICAgICAgICAgICAgIG5leHRQb2ludCA9IHBvaW50c1tpICsgMV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBuZXh0UG9pbnQgPSBwb2ludDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBwZXJwWSA9IC0obmV4dFBvaW50LnggLSBsYXN0UG9pbnQueCk7XHJcbiAgICAgICAgICAgIHBlcnBYID0gbmV4dFBvaW50LnkgLSBsYXN0UG9pbnQueTtcclxuICAgICAgICAgICAgdmFyIHBlcnBMZW5ndGggPSBNYXRoLnNxcnQoKHBlcnBYICogcGVycFgpICsgKHBlcnBZICogcGVycFkpKTtcclxuICAgICAgICAgICAgdmFyIG51bSA9IHRoaXMud2lkdGggLyAyOyAvLyAoMjAgKyBNYXRoLmFicyhNYXRoLnNpbigoaSArIHRoaXMuY291bnQpICogMC4zKSAqIDUwKSApKiByYXRpbztcclxuICAgICAgICAgICAgcGVycFggLz0gcGVycExlbmd0aDtcclxuICAgICAgICAgICAgcGVycFkgLz0gcGVycExlbmd0aDtcclxuICAgICAgICAgICAgcGVycFggKj0gbnVtO1xyXG4gICAgICAgICAgICBwZXJwWSAqPSBudW07XHJcbiAgICAgICAgICAgIHZlcnRpY2VzW2luZGV4XSA9IHBvaW50LnggKyBwZXJwWDtcclxuICAgICAgICAgICAgdmVydGljZXNbaW5kZXggKyAxXSA9IHBvaW50LnkgKyBwZXJwWTtcclxuICAgICAgICAgICAgdmVydGljZXNbaW5kZXggKyAyXSA9IHBvaW50LnggLSBwZXJwWDtcclxuICAgICAgICAgICAgdmVydGljZXNbaW5kZXggKyAzXSA9IHBvaW50LnkgLSBwZXJwWTtcclxuICAgICAgICAgICAgbGFzdFBvaW50ID0gcG9pbnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuYnVmZmVyc1swXS51cGRhdGUoKTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIHVwZGF0ZSgpIHtcclxuICAgICAgICB0aGlzLnVwZGF0ZVZlcnRpY2VzKCk7XHJcbiAgICB9XHJcbiAgICA7XHJcbn1cclxuZXhwb3J0cy5Sb3BlR2VvbWV0cnkgPSBSb3BlR2VvbWV0cnk7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IFNoYXBlU2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL1NoYXBlU2V0dGluZ3NcIik7XHJcbmNsYXNzIFJvdW5kZWRSZWN0YW5nbGUge1xyXG4gICAgY29uc3RydWN0b3IoeCA9IDAsIHkgPSAwLCB3aWR0aCA9IDAsIGhlaWdodCA9IDAsIHJhZGl1cyA9IDIwKSB7XHJcbiAgICAgICAgaWYgKHggPT09IHZvaWQgMCkge1xyXG4gICAgICAgICAgICB4ID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHkgPT09IHZvaWQgMCkge1xyXG4gICAgICAgICAgICB5ID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHdpZHRoID09PSB2b2lkIDApIHtcclxuICAgICAgICAgICAgd2lkdGggPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaGVpZ2h0ID09PSB2b2lkIDApIHtcclxuICAgICAgICAgICAgaGVpZ2h0ID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJhZGl1cyA9PT0gdm9pZCAwKSB7XHJcbiAgICAgICAgICAgIHJhZGl1cyA9IDIwO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgICAgICogQGRlZmF1bHQgMFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMueCA9IHg7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICAgICAqIEBkZWZhdWx0IDBcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnkgPSB5O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAgICAgKiBAZGVmYXVsdCAwXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAgICAgKiBAZGVmYXVsdCAwXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICAgICAqIEBkZWZhdWx0IDIwXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5yYWRpdXMgPSByYWRpdXM7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIHR5cGUgb2YgdGhlIG9iamVjdCwgbWFpbmx5IHVzZWQgdG8gYXZvaWQgYGluc3RhbmNlb2ZgIGNoZWNrc1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICAgICAqIEByZWFkb25seVxyXG4gICAgICAgICAqIEBkZWZhdWx0IFBJWEkuU0hBUEVTLlJSRUNcclxuICAgICAgICAgKiBAc2VlIFBJWEkuU0hBUEVTXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy50eXBlID0gU2hhcGVTZXR0aW5nc18xLlNoYXBlU2V0dGluZ3MuU0hBUEVTLlJSRUM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBjbG9uZSBvZiB0aGlzIFJvdW5kZWQgUmVjdGFuZ2xlXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiB7UElYSS5Sb3VuZGVkUmVjdGFuZ2xlfSBhIGNvcHkgb2YgdGhlIHJvdW5kZWQgcmVjdGFuZ2xlXHJcbiAgICAgKi9cclxuICAgIGNsb25lKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgUm91bmRlZFJlY3RhbmdsZSh0aGlzLngsIHRoaXMueSwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQsIHRoaXMucmFkaXVzKTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIHggYW5kIHkgY29vcmRpbmF0ZXMgZ2l2ZW4gYXJlIGNvbnRhaW5lZCB3aXRoaW4gdGhpcyBSb3VuZGVkIFJlY3RhbmdsZVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQgdG8gdGVzdFxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgLSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBwb2ludCB0byB0ZXN0XHJcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSB4L3kgY29vcmRpbmF0ZXMgYXJlIHdpdGhpbiB0aGlzIFJvdW5kZWQgUmVjdGFuZ2xlXHJcbiAgICAgKi9cclxuICAgIGNvbnRhaW5zKHgsIHkpIHtcclxuICAgICAgICBpZiAodGhpcy53aWR0aCA8PSAwIHx8IHRoaXMuaGVpZ2h0IDw9IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoeCA+PSB0aGlzLnggJiYgeCA8PSB0aGlzLnggKyB0aGlzLndpZHRoKSB7XHJcbiAgICAgICAgICAgIGlmICh5ID49IHRoaXMueSAmJiB5IDw9IHRoaXMueSArIHRoaXMuaGVpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoKHkgPj0gdGhpcy55ICsgdGhpcy5yYWRpdXMgJiYgeSA8PSB0aGlzLnkgKyB0aGlzLmhlaWdodCAtIHRoaXMucmFkaXVzKVxyXG4gICAgICAgICAgICAgICAgICAgIHx8ICh4ID49IHRoaXMueCArIHRoaXMucmFkaXVzICYmIHggPD0gdGhpcy54ICsgdGhpcy53aWR0aCAtIHRoaXMucmFkaXVzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIGR4ID0geCAtICh0aGlzLnggKyB0aGlzLnJhZGl1cyk7XHJcbiAgICAgICAgICAgICAgICB2YXIgZHkgPSB5IC0gKHRoaXMueSArIHRoaXMucmFkaXVzKTtcclxuICAgICAgICAgICAgICAgIHZhciByYWRpdXMyID0gdGhpcy5yYWRpdXMgKiB0aGlzLnJhZGl1cztcclxuICAgICAgICAgICAgICAgIGlmICgoZHggKiBkeCkgKyAoZHkgKiBkeSkgPD0gcmFkaXVzMikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZHggPSB4IC0gKHRoaXMueCArIHRoaXMud2lkdGggLSB0aGlzLnJhZGl1cyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoKGR4ICogZHgpICsgKGR5ICogZHkpIDw9IHJhZGl1czIpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGR5ID0geSAtICh0aGlzLnkgKyB0aGlzLmhlaWdodCAtIHRoaXMucmFkaXVzKTtcclxuICAgICAgICAgICAgICAgIGlmICgoZHggKiBkeCkgKyAoZHkgKiBkeSkgPD0gcmFkaXVzMikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZHggPSB4IC0gKHRoaXMueCArIHRoaXMucmFkaXVzKTtcclxuICAgICAgICAgICAgICAgIGlmICgoZHggKiBkeCkgKyAoZHkgKiBkeSkgPD0gcmFkaXVzMikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIDtcclxufVxyXG5leHBvcnRzLlJvdW5kZWRSZWN0YW5nbGUgPSBSb3VuZGVkUmVjdGFuZ2xlO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jbGFzcyBSdW5uZXIge1xyXG4gICAgY29uc3RydWN0b3IobmFtZSwgcHJpb3JpdHkgPSAwKSB7XHJcbiAgICAgICAgdGhpcy5pdGVtcyA9IFtdO1xyXG4gICAgICAgIHRoaXMuX25hbWUgPSBuYW1lO1xyXG4gICAgICAgIHRoaXMuZGlzcGF0Y2ggPSB0aGlzLmVtaXQ7XHJcbiAgICAgICAgdGhpcy5ydW4gPSB0aGlzLmVtaXQ7XHJcbiAgICB9XHJcbiAgICBlbWl0KGEwLCBhMSwgYTIsIGEzLCBhNCwgYTUsIGE2LCBhNykge1xyXG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gOCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21heCBhcmd1bWVudHMgcmVhY2hlZCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcmVmID0gdGhpcztcclxuICAgICAgICB2YXIgbmFtZSA9IHJlZi5uYW1lO1xyXG4gICAgICAgIHZhciBpdGVtcyA9IHJlZi5pdGVtcztcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gaXRlbXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgaXRlbXNbaV1bbmFtZV0oYTAsIGExLCBhMiwgYTMsIGE0LCBhNSwgYTYsIGE3KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIEFkZCBhIGxpc3RlbmVyIHRvIHRoZSBSdW5uZXJcclxuICAgICAqXHJcbiAgICAgKiBSdW5uZXJzIGRvIG5vdCBuZWVkIHRvIGhhdmUgc2NvcGUgb3IgZnVuY3Rpb25zIHBhc3NlZCB0byB0aGVtLlxyXG4gICAgICogQWxsIHRoYXQgaXMgcmVxdWlyZWQgaXMgdG8gcGFzcyB0aGUgbGlzdGVuaW5nIG9iamVjdCBhbmQgZW5zdXJlIHRoYXQgaXQgaGFzIGNvbnRhaW5zIGEgZnVuY3Rpb24gdGhhdCBoYXMgdGhlIHNhbWUgbmFtZVxyXG4gICAgICogYXMgdGhlIG5hbWUgcHJvdmlkZWQgdG8gdGhlIFJ1bm5lciB3aGVuIGl0IHdhcyBjcmVhdGVkLlxyXG4gICAgICpcclxuICAgICAqIEVnIEEgbGlzdGVuZXIgcGFzc2VkIHRvIHRoaXMgUnVubmVyIHdpbGwgcmVxdWlyZSBhICdjb21wbGV0ZScgZnVuY3Rpb24uXHJcbiAgICAgKlxyXG4gICAgICogYGBgXHJcbiAgICAgKiBjb25zdCBjb21wbGV0ZSA9IG5ldyBQSVhJLlJ1bm5lcignY29tcGxldGUnKTtcclxuICAgICAqIGBgYFxyXG4gICAgICpcclxuICAgICAqIFRoZSBzY29wZSB1c2VkIHdpbGwgYmUgdGhlIG9iamVjdCBpdHNlbGYuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHthbnl9IGl0ZW0gLSBUaGUgb2JqZWN0IHRoYXQgd2lsbCBiZSBsaXN0ZW5pbmcuXHJcbiAgICAgKi9cclxuICAgIGFkZChpdGVtKSB7XHJcbiAgICAgICAgaWYgKGl0ZW1bdGhpcy5fbmFtZV0pIHtcclxuICAgICAgICAgICAgdGhpcy5yZW1vdmUoaXRlbSk7XHJcbiAgICAgICAgICAgIHRoaXMuaXRlbXMucHVzaChpdGVtKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZSBhIHNpbmdsZSBsaXN0ZW5lciBmcm9tIHRoZSBkaXNwYXRjaCBxdWV1ZS5cclxuICAgICAqIEBwYXJhbSB7YW55fSBpdGVtIC0gVGhlIGxpc3RlbnIgdGhhdCB5b3Ugd291bGQgbGlrZSB0byByZW1vdmUuXHJcbiAgICAgKi9cclxuICAgIHJlbW92ZShpdGVtKSB7XHJcbiAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5pdGVtcy5pbmRleE9mKGl0ZW0pO1xyXG4gICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcclxuICAgICAgICAgICAgdGhpcy5pdGVtcy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2sgdG8gc2VlIGlmIHRoZSBsaXN0ZW5lciBpcyBhbHJlYWR5IGluIHRoZSBSdW5uZXJcclxuICAgICAqIEBwYXJhbSB7YW55fSBpdGVtIC0gVGhlIGxpc3RlbmVyIHRoYXQgeW91IHdvdWxkIGxpa2UgdG8gY2hlY2suXHJcbiAgICAgKi9cclxuICAgIGNvbnRhaW5zKGl0ZW0pIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5pdGVtcy5pbmRleE9mKGl0ZW0pICE9PSAtMTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlIGFsbCBsaXN0ZW5lcnMgZnJvbSB0aGUgUnVubmVyXHJcbiAgICAgKi9cclxuICAgIHJlbW92ZUFsbCgpIHtcclxuICAgICAgICB0aGlzLml0ZW1zLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZSBhbGwgcmVmZXJlbmNlcywgZG9uJ3QgdXNlIGFmdGVyIHRoaXMuXHJcbiAgICAgKi9cclxuICAgIGRlc3Ryb3koKSB7XHJcbiAgICAgICAgdGhpcy5yZW1vdmVBbGwoKTtcclxuICAgICAgICB0aGlzLml0ZW1zID0gbnVsbDtcclxuICAgICAgICB0aGlzLl9uYW1lID0gbnVsbDtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogYHRydWVgIGlmIHRoZXJlIGFyZSBubyB0aGlzIFJ1bm5lciBjb250YWlucyBubyBsaXN0ZW5lcnNcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtib29sZWFufVxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKi9cclxuICAgIGdldCBlbXB0eSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5pdGVtcy5sZW5ndGggPT09IDA7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBuYW1lIG9mIHRoZSBydW5uZXIuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7c3RyaW5nfVxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKi9cclxuICAgIGdldCBuYW1lKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9uYW1lO1xyXG4gICAgfVxyXG4gICAgO1xyXG59XHJcbmV4cG9ydHMuUnVubmVyID0gUnVubmVyO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBCYXNlSW1hZ2VSZXNvdXJjZV8xID0gcmVxdWlyZShcIi4vQmFzZUltYWdlUmVzb3VyY2VcIik7XHJcbmNvbnN0IHNldHRpbmdzXzEgPSByZXF1aXJlKFwiLi9zZXR0aW5nc1wiKTtcclxuY29uc3QgTWF0aFNldHRpbmdzXzEgPSByZXF1aXJlKFwiLi9NYXRoU2V0dGluZ3NcIik7XHJcbmNsYXNzIFNWR1Jlc291cmNlIGV4dGVuZHMgQmFzZUltYWdlUmVzb3VyY2VfMS5CYXNlSW1hZ2VSZXNvdXJjZSB7XHJcbiAgICBjb25zdHJ1Y3Rvcihzb3VyY2UsIG9wdGlvbnMpIHtcclxuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuICAgICAgICBzdXBlcihkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKSk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQmFzZTY0IGVuY29kZWQgU1ZHIGVsZW1lbnQgb3IgVVJMIGZvciBTVkcgZmlsZVxyXG4gICAgICAgICAqIEByZWFkb25seVxyXG4gICAgICAgICAqIEBtZW1iZXIge3N0cmluZ31cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnN2ZyA9IHNvdXJjZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgc291cmNlIHNjYWxlIHRvIGFwcGx5IHRvIHJlbmRlclxyXG4gICAgICAgICAqIEByZWFkb25seVxyXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnNjYWxlID0gb3B0aW9ucy5zY2FsZSB8fCAxO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENhbGwgd2hlbiBjb21wbGV0ZWx5IGxvYWRlZFxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICogQG1lbWJlciB7ZnVuY3Rpb259XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5fcmVzb2x2ZSA9IG51bGw7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUHJvbWlzZSB3aGVuIGxvYWRpbmdcclxuICAgICAgICAgKiBAbWVtYmVyIHtQcm9taXNlPHZvaWQ+fVxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICogQGRlZmF1bHQgbnVsbFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuX2xvYWQgPSBudWxsO1xyXG4gICAgICAgIGlmIChvcHRpb25zLmF1dG9Mb2FkICE9PSBmYWxzZSkge1xyXG4gICAgICAgICAgICB0aGlzLmxvYWQoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBsb2FkKCkge1xyXG4gICAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xyXG4gICAgICAgIGlmICh0aGlzLl9sb2FkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9sb2FkO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9sb2FkID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcclxuICAgICAgICAgICAgLy8gU2F2ZSB0aGlzIHVudGlsIGFmdGVyIGxvYWQgaXMgZmluaXNoZWRcclxuICAgICAgICAgICAgdGhpcyQxLl9yZXNvbHZlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcyQxLnJlc2l6ZSh0aGlzJDEuc291cmNlLndpZHRoLCB0aGlzJDEuc291cmNlLmhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICByZXNvbHZlKHRoaXMkMSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8vIENvbnZlcnQgU1ZHIGlubGluZSBzdHJpbmcgdG8gZGF0YS11cmlcclxuICAgICAgICAgICAgaWYgKCgvXlxcPHN2Zy8pLnRlc3QodGhpcyQxLnN2Zy50cmltKCkpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzJDEuc3ZnID0gXCJkYXRhOmltYWdlL3N2Zyt4bWw7dXRmOCxcIiArICh0aGlzJDEuc3ZnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBDaGVja3MgaWYgYHNvdXJjZWAgaXMgYW4gU1ZHIGltYWdlIGFuZCB3aGV0aGVyIGl0J3NcclxuICAgICAgICAgICAgLy8gbG9hZGVkIHZpYSBhIFVSTCBvciBhIGRhdGEgVVJJLiBUaGVuIGNhbGxzXHJcbiAgICAgICAgICAgIC8vIGBfbG9hZERhdGFVcmlgIG9yIGBfbG9hZFhocmAuXHJcbiAgICAgICAgICAgIHZhciBkYXRhVXJpID0gc2V0dGluZ3NfMS5zZXR0aW5ncy5kZWNvbXBvc2VEYXRhVXJpKHRoaXMkMS5zdmcpO1xyXG4gICAgICAgICAgICBpZiAoZGF0YVVyaSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcyQxLl9sb2FkRGF0YVVyaShkYXRhVXJpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIFdlIGdvdCBhbiBVUkwsIHNvIHdlIG5lZWQgdG8gZG8gYW4gWEhSIHRvIGNoZWNrIHRoZSBzdmcgc2l6ZVxyXG4gICAgICAgICAgICAgICAgdGhpcyQxLl9sb2FkWGhyKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbG9hZDtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogUmVhZHMgYW4gU1ZHIHN0cmluZyBmcm9tIGRhdGEgVVJJIGFuZCB0aGVuIGNhbGxzIGBfbG9hZFN0cmluZ2AuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRhdGFVcmkgLSBUaGUgZGF0YSB1cmkgdG8gbG9hZCBmcm9tLlxyXG4gICAgICovXHJcbiAgICBfbG9hZERhdGFVcmkoZGF0YVVyaSkge1xyXG4gICAgICAgIHZhciBzdmdTdHJpbmc7XHJcbiAgICAgICAgaWYgKGRhdGFVcmkuZW5jb2RpbmcgPT09ICdiYXNlNjQnKSB7XHJcbiAgICAgICAgICAgIGlmICghYXRvYikge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3VyIGJyb3dzZXIgZG9lc25cXCd0IHN1cHBvcnQgYmFzZTY0IGNvbnZlcnNpb25zLicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHN2Z1N0cmluZyA9IGF0b2IoZGF0YVVyaS5kYXRhKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHN2Z1N0cmluZyA9IGRhdGFVcmkuZGF0YTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fbG9hZFN0cmluZyhzdmdTdHJpbmcpO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBMb2FkcyBhbiBTVkcgc3RyaW5nIGZyb20gYGltYWdlVXJsYCB1c2luZyBYSFIgYW5kIHRoZW4gY2FsbHMgYF9sb2FkU3RyaW5nYC5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBfbG9hZFhocigpIHtcclxuICAgICAgICB2YXIgdGhpcyQxID0gdGhpcztcclxuICAgICAgICB2YXIgc3ZnWGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XHJcbiAgICAgICAgLy8gVGhpcyB0aHJvd3MgZXJyb3Igb24gSUUsIHNvIFNWRyBEb2N1bWVudCBjYW4ndCBiZSB1c2VkXHJcbiAgICAgICAgLy8gc3ZnWGhyLnJlc3BvbnNlVHlwZSA9ICdkb2N1bWVudCc7XHJcbiAgICAgICAgLy8gVGhpcyBpcyBub3QgbmVlZGVkIHNpbmNlIHdlIGxvYWQgdGhlIHN2ZyBhcyBzdHJpbmcgKGJyZWFrcyBJRSB0b28pXHJcbiAgICAgICAgLy8gYnV0IG92ZXJyaWRlTWltZVR5cGUoKSBjYW4gYmUgdXNlZCB0byBmb3JjZSB0aGUgcmVzcG9uc2UgdG8gYmUgcGFyc2VkIGFzIFhNTFxyXG4gICAgICAgIC8vIHN2Z1hoci5vdmVycmlkZU1pbWVUeXBlKCdpbWFnZS9zdmcreG1sJyk7XHJcbiAgICAgICAgc3ZnWGhyLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKHN2Z1hoci5yZWFkeVN0YXRlICE9PSBzdmdYaHIuRE9ORSB8fCBzdmdYaHIuc3RhdHVzICE9PSAyMDApIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGxvYWQgU1ZHIHVzaW5nIFhIUi4nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzJDEuX2xvYWRTdHJpbmcoc3ZnWGhyLnJlc3BvbnNlKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIHN2Z1hoci5vbmVycm9yID0gKCkgPT4gdGhpcy5lbWl0KCdlcnJvcicsIHRoaXMpO1xyXG4gICAgICAgIHN2Z1hoci5vcGVuKCdHRVQnLCB0aGlzLnN2ZywgdHJ1ZSk7XHJcbiAgICAgICAgc3ZnWGhyLnNlbmQoKTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogTG9hZHMgdGV4dHVyZSB1c2luZyBhbiBTVkcgc3RyaW5nLiBUaGUgb3JpZ2luYWwgU1ZHIEltYWdlIGlzIHN0b3JlZCBhcyBgb3JpZ1NvdXJjZWAgYW5kIHRoZVxyXG4gICAgICogY3JlYXRlZCBjYW52YXMgaXMgdGhlIG5ldyBgc291cmNlYC4gVGhlIFNWRyBpcyBzY2FsZWQgdXNpbmcgYHNvdXJjZVNjYWxlYC4gQ2FsbGVkIGJ5XHJcbiAgICAgKiBgX2xvYWRYaHJgIG9yIGBfbG9hZERhdGFVcmlgLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IHN2Z1N0cmluZyBTVkcgc291cmNlIGFzIHN0cmluZ1xyXG4gICAgICpcclxuICAgICAqIEBmaXJlcyBsb2FkZWRcclxuICAgICAqL1xyXG4gICAgX2xvYWRTdHJpbmcoc3ZnU3RyaW5nKSB7XHJcbiAgICAgICAgdmFyIHN2Z1NpemUgPSBTVkdSZXNvdXJjZS5nZXRTaXplKHN2Z1N0cmluZyk7XHJcbiAgICAgICAgLy8gVE9ETyBkbyB3ZSBuZWVkIHRvIHdhaXQgZm9yIHRoaXMgdG8gbG9hZD9cclxuICAgICAgICAvLyBzZWVtcyBpbnN0YW50IVxyXG4gICAgICAgIC8vXHJcbiAgICAgICAgdmFyIHRlbXBJbWFnZSA9IG5ldyBJbWFnZSgpO1xyXG4gICAgICAgIHRlbXBJbWFnZS5zcmMgPSBcImRhdGE6aW1hZ2Uvc3ZnK3htbCxcIiArIHN2Z1N0cmluZztcclxuICAgICAgICB2YXIgc3ZnV2lkdGggPSBzdmdTaXplLndpZHRoO1xyXG4gICAgICAgIHZhciBzdmdIZWlnaHQgPSBzdmdTaXplLmhlaWdodDtcclxuICAgICAgICBpZiAoIXN2Z1dpZHRoIHx8ICFzdmdIZWlnaHQpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgU1ZHIGltYWdlIG11c3QgaGF2ZSB3aWR0aCBhbmQgaGVpZ2h0IGRlZmluZWQgKGluIHBpeGVscyksIGNhbnZhcyBBUEkgbmVlZHMgdGhlbS4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gU2NhbGUgcmVhbFdpZHRoIGFuZCByZWFsSGVpZ2h0XHJcbiAgICAgICAgdGhpcy5fd2lkdGggPSBNYXRoLnJvdW5kKHN2Z1dpZHRoICogdGhpcy5zY2FsZSk7XHJcbiAgICAgICAgdGhpcy5faGVpZ2h0ID0gTWF0aC5yb3VuZChzdmdIZWlnaHQgKiB0aGlzLnNjYWxlKTtcclxuICAgICAgICAvLyBDcmVhdGUgYSBjYW52YXMgZWxlbWVudFxyXG4gICAgICAgIHZhciBjYW52YXMgPSB0aGlzLnNvdXJjZTtcclxuICAgICAgICBjYW52YXMud2lkdGggPSB0aGlzLl93aWR0aDtcclxuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gdGhpcy5faGVpZ2h0O1xyXG4gICAgICAgIGNhbnZhcy5fcGl4aUlkID0gXCJjYW52YXNfXCIgKyAoTWF0aFNldHRpbmdzXzEuTWF0aFNldHRpbmdzLnVpZCgpKTtcclxuICAgICAgICAvLyBEcmF3IHRoZSBTdmcgdG8gdGhlIGNhbnZhc1xyXG4gICAgICAgIGNhbnZhc1xyXG4gICAgICAgICAgICAuZ2V0Q29udGV4dCgnMmQnKVxyXG4gICAgICAgICAgICAuZHJhd0ltYWdlKHRlbXBJbWFnZSwgMCwgMCwgc3ZnV2lkdGgsIHN2Z0hlaWdodCwgMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xyXG4gICAgICAgIHRoaXMuX3Jlc29sdmUoKTtcclxuICAgICAgICB0aGlzLl9yZXNvbHZlID0gbnVsbDtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogVHlwZWRlZiBmb3IgU2l6ZSBvYmplY3QuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlcm9mIFBJWEkucmVzb3VyY2VzLlNWR1Jlc291cmNlXHJcbiAgICAgKiBAdHlwZWRlZiB7b2JqZWN0fSBTaXplXHJcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gd2lkdGggLSBXaWR0aCBjb21wb25lbnRcclxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBoZWlnaHQgLSBIZWlnaHQgY29tcG9uZW50XHJcbiAgICAgKi9cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHNpemUgZnJvbSBhbiBzdmcgc3RyaW5nIHVzaW5nIHJlZ2V4cC5cclxuICAgICAqXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3ZnU3RyaW5nIC0gYSBzZXJpYWxpemVkIHN2ZyBlbGVtZW50XHJcbiAgICAgKiBAcmV0dXJuIHtQSVhJLnJlc291cmNlcy5TVkdSZXNvdXJjZS5TaXplfSBpbWFnZSBleHRlbnNpb25cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGdldFNpemUoc3ZnU3RyaW5nKSB7XHJcbiAgICAgICAgdmFyIHNpemVNYXRjaCA9IFNWR1Jlc291cmNlLlNWR19TSVpFLmV4ZWMoc3ZnU3RyaW5nKTtcclxuICAgICAgICB2YXIgc2l6ZSA9IHt9O1xyXG4gICAgICAgIGlmIChzaXplTWF0Y2gpIHtcclxuICAgICAgICAgICAgc2l6ZVtzaXplTWF0Y2hbMV1dID0gTWF0aC5yb3VuZChwYXJzZUZsb2F0KHNpemVNYXRjaFszXSkpO1xyXG4gICAgICAgICAgICBzaXplW3NpemVNYXRjaFs1XV0gPSBNYXRoLnJvdW5kKHBhcnNlRmxvYXQoc2l6ZU1hdGNoWzddKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzaXplO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBEZXN0cm95cyB0aGlzIHRleHR1cmVcclxuICAgICAqIEBvdmVycmlkZVxyXG4gICAgICovXHJcbiAgICBkaXNwb3NlKCkge1xyXG4gICAgICAgIEJhc2VJbWFnZVJlc291cmNlXzEuQmFzZUltYWdlUmVzb3VyY2UucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcclxuICAgICAgICB0aGlzLl9yZXNvbHZlID0gbnVsbDtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogVXNlZCB0byBhdXRvLWRldGVjdCB0aGUgdHlwZSBvZiByZXNvdXJjZS5cclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAcGFyYW0geyp9IHNvdXJjZSAtIFRoZSBzb3VyY2Ugb2JqZWN0XHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXh0ZW5zaW9uIC0gVGhlIGV4dGVuc2lvbiBvZiBzb3VyY2UsIGlmIHNldFxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgdGVzdChzb3VyY2UsIGV4dGVuc2lvbikge1xyXG4gICAgICAgIC8vIHVybCBmaWxlIGV4dGVuc2lvbiBpcyBTVkdcclxuICAgICAgICByZXR1cm4gZXh0ZW5zaW9uID09PSAnc3ZnJ1xyXG4gICAgICAgICAgICAvLyBzb3VyY2UgaXMgU1ZHIGRhdGEtdXJpXHJcbiAgICAgICAgICAgIHx8ICh0eXBlb2Ygc291cmNlID09PSAnc3RyaW5nJyAmJiBzb3VyY2UuaW5kZXhPZignZGF0YTppbWFnZS9zdmcreG1sJykgPT09IDApO1xyXG4gICAgfVxyXG4gICAgO1xyXG59XHJcbi8qKlxyXG4qIFJlZ0V4cCBmb3IgU1ZHIHNpemUuXHJcbipcclxuKiBAc3RhdGljXHJcbiogQGNvbnN0YW50IHtSZWdFeHB8c3RyaW5nfSBTVkdfU0laRVxyXG4qIEBtZW1iZXJvZiBQSVhJLnJlc291cmNlcy5TVkdSZXNvdXJjZVxyXG4qIEBleGFtcGxlICZsdDtzdmcgd2lkdGg9XCIxMDBcIiBoZWlnaHQ9XCIxMDBcIiZndDsmbHQ7L3N2ZyZndDtcclxuKi9cclxuU1ZHUmVzb3VyY2UuU1ZHX1NJWkUgPSAvPHN2Z1tePl0qKD86XFxzKHdpZHRofGhlaWdodCk9KCd8XCIpKFxcZCooPzpcXC5cXGQrKT8pKD86cHgpPygnfFwiKSlbXj5dKig/Olxccyh3aWR0aHxoZWlnaHQpPSgnfFwiKShcXGQqKD86XFwuXFxkKyk/KSg/OnB4KT8oJ3xcIikpW14+XSo+L2k7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbWF4LWxlblxyXG5leHBvcnRzLlNWR1Jlc291cmNlID0gU1ZHUmVzb3VyY2U7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IFVuaWZvcm1Hcm91cF8xID0gcmVxdWlyZShcIi4vVW5pZm9ybUdyb3VwXCIpO1xyXG5jb25zdCBQcm9ncmFtXzEgPSByZXF1aXJlKFwiLi9Qcm9ncmFtXCIpO1xyXG5jbGFzcyBTaGFkZXIge1xyXG4gICAgY29uc3RydWN0b3IocHJvZ3JhbSwgdW5pZm9ybXMpIHtcclxuICAgICAgICB0aGlzLnByb2dyYW0gPSBwcm9ncmFtO1xyXG4gICAgICAgIC8vIGxldHMgc2VlIHdoYXRzIGJlZW4gcGFzc2VkIGluXHJcbiAgICAgICAgLy8gdW5pZm9ybXMgc2hvdWxkIGJlIGNvbnZlcnRlZCB0byBhIHVuaWZvcm0gZ3JvdXBcclxuICAgICAgICBpZiAodW5pZm9ybXMpIHtcclxuICAgICAgICAgICAgaWYgKHVuaWZvcm1zIGluc3RhbmNlb2YgVW5pZm9ybUdyb3VwXzEuVW5pZm9ybUdyb3VwKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnVuaWZvcm1Hcm91cCA9IHVuaWZvcm1zO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy51bmlmb3JtR3JvdXAgPSBuZXcgVW5pZm9ybUdyb3VwXzEuVW5pZm9ybUdyb3VwKHVuaWZvcm1zKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy51bmlmb3JtR3JvdXAgPSBuZXcgVW5pZm9ybUdyb3VwXzEuVW5pZm9ybUdyb3VwKHt9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gdGltZSB0byBidWlsZCBzb21lIGdldHRlcnMgYW5kIHNldHRlcnMhXHJcbiAgICAgICAgLy8gSSBndWVzcyBkb3duIHRoZSBsaW5lIHRoaXMgY291bGQgc29ydCBvZiBnZW5lcmF0ZSBhbiBpbnN0cnVjdGlvbiBsaXN0IHJhdGhlciB0aGFuIHVzZSBkaXJ0eSBpZHM/XHJcbiAgICAgICAgLy8gZG9lcyB0aGUgdHJpY2sgZm9yIG5vdyB0aG91Z2ghXHJcbiAgICAgICAgZm9yICh2YXIgaSBpbiBwcm9ncmFtLnVuaWZvcm1EYXRhKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnVuaWZvcm1Hcm91cC51bmlmb3Jtc1tpXSBpbnN0YW5jZW9mIEFycmF5KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnVuaWZvcm1Hcm91cC51bmlmb3Jtc1tpXSA9IG5ldyBGbG9hdDMyQXJyYXkodGhpcy51bmlmb3JtR3JvdXAudW5pZm9ybXNbaV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gVE9ETyBtb3ZlIHRvIHNoYWRlciBzeXN0ZW0uLlxyXG4gICAgY2hlY2tVbmlmb3JtRXhpc3RzKG5hbWUsIGdyb3VwKSB7XHJcbiAgICAgICAgaWYgKGdyb3VwLnVuaWZvcm1zW25hbWVdKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKHZhciBpIGluIGdyb3VwLnVuaWZvcm1zKSB7XHJcbiAgICAgICAgICAgIHZhciB1bmlmb3JtID0gZ3JvdXAudW5pZm9ybXNbaV07XHJcbiAgICAgICAgICAgIGlmICh1bmlmb3JtLmdyb3VwKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jaGVja1VuaWZvcm1FeGlzdHMobmFtZSwgdW5pZm9ybSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICBkZXN0cm95KCkge1xyXG4gICAgICAgIC8vIHVzYWdlIGNvdW50IG9uIHByb2dyYW1zP1xyXG4gICAgICAgIC8vIHJlbW92ZSBpZiBub3QgdXNlZCFcclxuICAgICAgICB0aGlzLnVuaWZvcm1Hcm91cCA9IG51bGw7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFNoYWRlciB1bmlmb3JtIHZhbHVlcywgc2hvcnRjdXQgZm9yIGB1bmlmb3JtR3JvdXAudW5pZm9ybXNgXHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqIEBtZW1iZXIge29iamVjdH1cclxuICAgICAqL1xyXG4gICAgZ2V0IHVuaWZvcm1zKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnVuaWZvcm1Hcm91cC51bmlmb3JtcztcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQSBzaG9ydCBoYW5kIGZ1bmN0aW9uIHRvIGNyZWF0ZSBhIHNoYWRlciBiYXNlZCBvZiBhIHZlcnRleCBhbmQgZnJhZ21lbnQgc2hhZGVyXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFt2ZXJ0ZXhTcmNdIC0gVGhlIHNvdXJjZSBvZiB0aGUgdmVydGV4IHNoYWRlci5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbZnJhZ21lbnRTcmNdIC0gVGhlIHNvdXJjZSBvZiB0aGUgZnJhZ21lbnQgc2hhZGVyLlxyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFt1bmlmb3Jtc10gLSBDdXN0b20gdW5pZm9ybXMgdG8gdXNlIHRvIGF1Z21lbnQgdGhlIGJ1aWx0LWluIG9uZXMuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge1BJWEkuU2hhZGVyfSBhbiBzaGlueSBuZXcgUGl4aSBzaGFkZXIhXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBmcm9tKHZlcnRleFNyYywgZnJhZ21lbnRTcmMsIHVuaWZvcm1zKSB7XHJcbiAgICAgICAgdmFyIHByb2dyYW0gPSBQcm9ncmFtXzEuUHJvZ3JhbS5mcm9tKHZlcnRleFNyYywgZnJhZ21lbnRTcmMpO1xyXG4gICAgICAgIHJldHVybiBuZXcgU2hhZGVyKHByb2dyYW0sIHVuaWZvcm1zKTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAcGFyYW0gZ2wge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gVGhlIGN1cnJlbnQgV2ViR0wgY29udGV4dCB7V2ViR0xQcm9ncmFtfVxyXG4gKiBAcGFyYW0gdHlwZSB7TnVtYmVyfSB0aGUgdHlwZSwgY2FuIGJlIGVpdGhlciBWRVJURVhfU0hBREVSIG9yIEZSQUdNRU5UX1NIQURFUlxyXG4gKiBAcGFyYW0gdmVydGV4U3JjIHtzdHJpbmd8c3RyaW5nW119IFRoZSB2ZXJ0ZXggc2hhZGVyIHNvdXJjZSBhcyBhbiBhcnJheSBvZiBzdHJpbmdzLlxyXG4gKiBAcmV0dXJuIHtXZWJHTFNoYWRlcn0gdGhlIHNoYWRlclxyXG4gKi9cclxuICAgIHN0YXRpYyBjb21waWxlU2hhZGVyKGdsLCB0eXBlLCBzcmMpIHtcclxuICAgICAgICB2YXIgc2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKHR5cGUpO1xyXG4gICAgICAgIGdsLnNoYWRlclNvdXJjZShzaGFkZXIsIHNyYyk7XHJcbiAgICAgICAgZ2wuY29tcGlsZVNoYWRlcihzaGFkZXIpO1xyXG4gICAgICAgIGlmICghZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKHNoYWRlciwgZ2wuQ09NUElMRV9TVEFUVVMpKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihzcmMpO1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGdsLmdldFNoYWRlckluZm9Mb2coc2hhZGVyKSk7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc2hhZGVyO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuU2hhZGVyID0gU2hhZGVyO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBTeXN0ZW1fMSA9IHJlcXVpcmUoXCIuL1N5c3RlbVwiKTtcclxuY29uc3QgUHJvZ3JhbV8xID0gcmVxdWlyZShcIi4vUHJvZ3JhbVwiKTtcclxuY29uc3QgR0xQcm9ncmFtXzEgPSByZXF1aXJlKFwiLi9HTFByb2dyYW1cIik7XHJcbmNvbnN0IFN0YXRlU3lzdGVtXzEgPSByZXF1aXJlKFwiLi9TdGF0ZVN5c3RlbVwiKTtcclxuY29uc3QgVXRpbHNTZXR0aW5nc18xID0gcmVxdWlyZShcIi4vVXRpbHNTZXR0aW5nc1wiKTtcclxuY29uc3QgV2ViR0xTZXR0aW5nc18xID0gcmVxdWlyZShcIi4vV2ViR0xTZXR0aW5nc1wiKTtcclxuY2xhc3MgU2hhZGVyU3lzdGVtIGV4dGVuZHMgU3lzdGVtXzEuU3lzdGVtIHtcclxuICAgIGNvbnN0cnVjdG9yKHJlbmRlcmVyKSB7XHJcbiAgICAgICAgc3VwZXIocmVuZGVyZXIpO1xyXG4gICAgICAgIC8vIFZhbGlkYXRpb24gY2hlY2sgdGhhdCB0aGlzIGVudmlyb25tZW50IHN1cHBvcnQgYG5ldyBGdW5jdGlvbmBcclxuICAgICAgICB0aGlzLnN5c3RlbUNoZWNrKCk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGN1cnJlbnQgV2ViR0wgcmVuZGVyaW5nIGNvbnRleHRcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBtZW1iZXIge1dlYkdMUmVuZGVyaW5nQ29udGV4dH1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmdsID0gbnVsbDtcclxuICAgICAgICB0aGlzLnNoYWRlciA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5wcm9ncmFtID0gbnVsbDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDYWNoZSB0byBob2xkcyB0aGUgZ2VuZXJhdGVkIGZ1bmN0aW9ucy4gU3RvcmVkIGFnYWluc3QgVW5pZm9ybU9iamVjdHMgdW5pcXVlIHNpZ25hdHVyZVxyXG4gICAgICAgICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmNhY2hlID0ge307XHJcbiAgICAgICAgdGhpcy5pZCA9IFN0YXRlU3lzdGVtXzEuU3RhdGVTeXN0ZW0uVUlEJDQrKztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogT3ZlcnJpZGVhYmxlIGZ1bmN0aW9uIGJ5IGBAcGl4aS91bnNhZmUtZXZhbGAgdG8gc2lsZW5jZVxyXG4gICAgICogdGhyb3dpbmcgYW4gZXJyb3IgaWYgcGxhdGZvcm0gZG9lc24ndCBzdXBwb3J0IHVuc2FmZS1ldmFscy5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBzeXN0ZW1DaGVjaygpIHtcclxuICAgICAgICBpZiAoIVV0aWxzU2V0dGluZ3NfMS5VdGlsc1NldHRpbmdzLnVuc2FmZUV2YWxTdXBwb3J0ZWQoKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0N1cnJlbnQgZW52aXJvbm1lbnQgZG9lcyBub3QgYWxsb3cgdW5zYWZlLWV2YWwsICdcclxuICAgICAgICAgICAgICAgICsgJ3BsZWFzZSB1c2UgQHBpeGkvdW5zYWZlLWV2YWwgbW9kdWxlIHRvIGVuYWJsZSBzdXBwb3J0LicpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIDtcclxuICAgIGNvbnRleHRDaGFuZ2UoZ2wpIHtcclxuICAgICAgICB0aGlzLmdsID0gZ2w7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIENoYW5nZXMgdGhlIGN1cnJlbnQgc2hhZGVyIHRvIHRoZSBvbmUgZ2l2ZW4gaW4gcGFyYW1ldGVyXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtQSVhJLlNoYWRlcn0gc2hhZGVyIC0gdGhlIG5ldyBzaGFkZXJcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZG9udFN5bmMgLSBmYWxzZSBpZiB0aGUgc2hhZGVyIHNob3VsZCBhdXRvbWF0aWNhbGx5IHN5bmMgaXRzIHVuaWZvcm1zLlxyXG4gICAgICogQHJldHVybnMge1BJWEkuR0xQcm9ncmFtfSB0aGUgZ2xQcm9ncmFtIHRoYXQgYmVsb25ncyB0byB0aGUgc2hhZGVyLlxyXG4gICAgICovXHJcbiAgICBiaW5kKHNoYWRlciwgZG9udFN5bmMgPSBmYWxzZSkge1xyXG4gICAgICAgIHNoYWRlci51bmlmb3Jtcy5nbG9iYWxzID0gdGhpcy5yZW5kZXJlci5nbG9iYWxVbmlmb3JtcztcclxuICAgICAgICB2YXIgcHJvZ3JhbSA9IHNoYWRlci5wcm9ncmFtO1xyXG4gICAgICAgIHZhciBnbFByb2dyYW0gPSBwcm9ncmFtLmdsUHJvZ3JhbXNbdGhpcy5yZW5kZXJlci5DT05URVhUX1VJRF0gfHwgdGhpcy5nZW5lcmF0ZVNoYWRlcihzaGFkZXIpO1xyXG4gICAgICAgIHRoaXMuc2hhZGVyID0gc2hhZGVyO1xyXG4gICAgICAgIC8vIFRPRE8gLSBzb21lIGN1cnJlbnQgUGl4aSBwbHVnaW5zIGJ5cGFzcyB0aGlzLi4gc28gaXQgbm90IHNhZmUgdG8gdXNlIHlldC4uXHJcbiAgICAgICAgaWYgKHRoaXMucHJvZ3JhbSAhPT0gcHJvZ3JhbSkge1xyXG4gICAgICAgICAgICB0aGlzLnByb2dyYW0gPSBwcm9ncmFtO1xyXG4gICAgICAgICAgICB0aGlzLmdsLnVzZVByb2dyYW0oZ2xQcm9ncmFtLnByb2dyYW0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWRvbnRTeW5jKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3luY1VuaWZvcm1Hcm91cChzaGFkZXIudW5pZm9ybUdyb3VwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGdsUHJvZ3JhbTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogVXBsb2FkcyB0aGUgdW5pZm9ybXMgdmFsdWVzIHRvIHRoZSBjdXJyZW50bHkgYm91bmQgc2hhZGVyLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSB1bmlmb3JtcyAtIHRoZSB1bmlmb3JtcyB2YWx1ZXMgdGhhdCBiZSBhcHBsaWVkIHRvIHRoZSBjdXJyZW50IHNoYWRlclxyXG4gICAgICovXHJcbiAgICBzZXRVbmlmb3Jtcyh1bmlmb3Jtcykge1xyXG4gICAgICAgIHZhciBzaGFkZXIgPSB0aGlzLnNoYWRlci5wcm9ncmFtO1xyXG4gICAgICAgIHZhciBnbFByb2dyYW0gPSBzaGFkZXIuZ2xQcm9ncmFtc1t0aGlzLnJlbmRlcmVyLkNPTlRFWFRfVUlEXTtcclxuICAgICAgICBzaGFkZXIuc3luY1VuaWZvcm1zKGdsUHJvZ3JhbS51bmlmb3JtRGF0YSwgdW5pZm9ybXMsIHRoaXMucmVuZGVyZXIpO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgc3luY1VuaWZvcm1Hcm91cChncm91cCkge1xyXG4gICAgICAgIHZhciBnbFByb2dyYW0gPSB0aGlzLmdldGdsUHJvZ3JhbSgpO1xyXG4gICAgICAgIGlmICghZ3JvdXAuc3RhdGljIHx8IGdyb3VwLmRpcnR5SWQgIT09IGdsUHJvZ3JhbS51bmlmb3JtR3JvdXBzW2dyb3VwLmlkXSkge1xyXG4gICAgICAgICAgICBnbFByb2dyYW0udW5pZm9ybUdyb3Vwc1tncm91cC5pZF0gPSBncm91cC5kaXJ0eUlkO1xyXG4gICAgICAgICAgICB0aGlzLnN5bmNVbmlmb3Jtcyhncm91cCwgZ2xQcm9ncmFtKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIE92ZXJyaWRlYWJsZSBieSB0aGUgQHBpeGkvdW5zYWZlLWV2YWwgcGFja2FnZSB0byB1c2Ugc3RhdGljXHJcbiAgICAgKiBzeW5jVW5mb3JtcyBpbnN0ZWFkLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHN5bmNVbmlmb3Jtcyhncm91cCwgZ2xQcm9ncmFtKSB7XHJcbiAgICAgICAgdmFyIHN5bmNGdW5jID0gZ3JvdXAuc3luY1VuaWZvcm1zW3RoaXMuc2hhZGVyLnByb2dyYW0uaWRdIHx8IHRoaXMuY3JlYXRlU3luY0dyb3Vwcyhncm91cCk7XHJcbiAgICAgICAgc3luY0Z1bmMoZ2xQcm9ncmFtLnVuaWZvcm1EYXRhLCBncm91cC51bmlmb3JtcywgdGhpcy5yZW5kZXJlcik7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICBjcmVhdGVTeW5jR3JvdXBzKGdyb3VwKSB7XHJcbiAgICAgICAgdmFyIGlkID0gdGhpcy5nZXRTaWduYXR1cmUoZ3JvdXAsIHRoaXMuc2hhZGVyLnByb2dyYW0udW5pZm9ybURhdGEpO1xyXG4gICAgICAgIGlmICghdGhpcy5jYWNoZVtpZF0pIHtcclxuICAgICAgICAgICAgdGhpcy5jYWNoZVtpZF0gPSBXZWJHTFNldHRpbmdzXzEuV2ViR0xTZXR0aW5ncy5nZW5lcmF0ZVVuaWZvcm1zU3luYyhncm91cCwgdGhpcy5zaGFkZXIucHJvZ3JhbS51bmlmb3JtRGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGdyb3VwLnN5bmNVbmlmb3Jtc1t0aGlzLnNoYWRlci5wcm9ncmFtLmlkXSA9IHRoaXMuY2FjaGVbaWRdO1xyXG4gICAgICAgIHJldHVybiBncm91cC5zeW5jVW5pZm9ybXNbdGhpcy5zaGFkZXIucHJvZ3JhbS5pZF07XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFRha2VzIGEgdW5pZm9ybSBncm91cCBhbmQgZGF0YSBhbmQgZ2VuZXJhdGVzIGEgdW5pcXVlIHNpZ25hdHVyZSBmb3IgdGhlbS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1BJWEkuVW5pZm9ybUdyb3VwfSBncm91cCB0aGUgdW5pZm9ybSBncm91cCB0byBnZXQgc2lnbmF0dXJlIG9mXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdW5pZm9ybURhdGEgdW5pZm9ybSBpbmZvcm1hdGlvbiBnZW5lcmF0ZWQgYnkgdGhlIHNoYWRlclxyXG4gICAgICogQHJldHVybnMge1N0cmluZ30gVW5pcXVlIHNpZ25hdHVyZSBvZiB0aGUgdW5pZm9ybSBncm91cFxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgZ2V0U2lnbmF0dXJlKGdyb3VwLCB1bmlmb3JtRGF0YSkge1xyXG4gICAgICAgIHZhciB1bmlmb3JtcyA9IGdyb3VwLnVuaWZvcm1zO1xyXG4gICAgICAgIHZhciBzdHJpbmdzID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgaSBpbiB1bmlmb3Jtcykge1xyXG4gICAgICAgICAgICBzdHJpbmdzLnB1c2goaSk7XHJcbiAgICAgICAgICAgIGlmICh1bmlmb3JtRGF0YVtpXSkge1xyXG4gICAgICAgICAgICAgICAgc3RyaW5ncy5wdXNoKHVuaWZvcm1EYXRhW2ldLnR5cGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzdHJpbmdzLmpvaW4oJy0nKTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgdW5kZXJseWluZyBHTFNoYWRlIHJvZiB0aGUgY3VycmVudGx5IGJvdW5kIHNoYWRlci5cclxuICAgICAqIFRoaXMgY2FuIGJlIGhhbmR5IGZvciB3aGVuIHlvdSB0byBoYXZlIGEgbGl0dGxlIG1vcmUgY29udHJvbCBvdmVyIHRoZSBzZXR0aW5nIG9mIHlvdXIgdW5pZm9ybXMuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiB7UElYSS5HTFByb2dyYW19IHRoZSBnbFByb2dyYW0gZm9yIHRoZSBjdXJyZW50bHkgYm91bmQgU2hhZGVyIGZvciB0aGlzIGNvbnRleHRcclxuICAgICAqL1xyXG4gICAgZ2V0Z2xQcm9ncmFtKCkge1xyXG4gICAgICAgIGlmICh0aGlzLnNoYWRlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zaGFkZXIucHJvZ3JhbS5nbFByb2dyYW1zW3RoaXMucmVuZGVyZXIuQ09OVEVYVF9VSURdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogR2VuZXJhdGVzIGEgZ2xQcm9ncmFtIHZlcnNpb24gb2YgdGhlIFNoYWRlciBwcm92aWRlZC5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtQSVhJLlNoYWRlcn0gc2hhZGVyIHRoZSBzaGFkZXIgdGhhdCB0aGUgZ2xQcm9ncmFtIHdpbGwgYmUgYmFzZWQgb24uXHJcbiAgICAgKiBAcmV0dXJuIHtQSVhJLkdMUHJvZ3JhbX0gQSBzaGlueSBuZXcgZ2xQcm9ncmFtIVxyXG4gICAgICovXHJcbiAgICBnZW5lcmF0ZVNoYWRlcihzaGFkZXIpIHtcclxuICAgICAgICB2YXIgZ2wgPSB0aGlzLmdsO1xyXG4gICAgICAgIHZhciBwcm9ncmFtID0gc2hhZGVyLnByb2dyYW07XHJcbiAgICAgICAgdmFyIGF0dHJpYk1hcCA9IHt9O1xyXG4gICAgICAgIGZvciAodmFyIGkgaW4gcHJvZ3JhbS5hdHRyaWJ1dGVEYXRhKSB7XHJcbiAgICAgICAgICAgIGF0dHJpYk1hcFtpXSA9IHByb2dyYW0uYXR0cmlidXRlRGF0YVtpXS5sb2NhdGlvbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHNoYWRlclByb2dyYW0gPSBQcm9ncmFtXzEuUHJvZ3JhbS5jb21waWxlUHJvZ3JhbShnbCwgcHJvZ3JhbS52ZXJ0ZXhTcmMsIHByb2dyYW0uZnJhZ21lbnRTcmMsIGF0dHJpYk1hcCk7XHJcbiAgICAgICAgdmFyIHVuaWZvcm1EYXRhID0ge307XHJcbiAgICAgICAgZm9yICh2YXIgaSQxIGluIHByb2dyYW0udW5pZm9ybURhdGEpIHtcclxuICAgICAgICAgICAgdmFyIGRhdGEgPSBwcm9ncmFtLnVuaWZvcm1EYXRhW2kkMV07XHJcbiAgICAgICAgICAgIHVuaWZvcm1EYXRhW2kkMV0gPSB7XHJcbiAgICAgICAgICAgICAgICBsb2NhdGlvbjogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHNoYWRlclByb2dyYW0sIGkkMSksXHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogV2ViR0xTZXR0aW5nc18xLldlYkdMU2V0dGluZ3MuZGVmYXVsdFZhbHVlKGRhdGEudHlwZSwgZGF0YS5zaXplKSxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGdsUHJvZ3JhbSA9IG5ldyBHTFByb2dyYW1fMS5HTFByb2dyYW0oc2hhZGVyUHJvZ3JhbSwgdW5pZm9ybURhdGEpO1xyXG4gICAgICAgIHByb2dyYW0uZ2xQcm9ncmFtc1t0aGlzLnJlbmRlcmVyLkNPTlRFWFRfVUlEXSA9IGdsUHJvZ3JhbTtcclxuICAgICAgICByZXR1cm4gZ2xQcm9ncmFtO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXNldHMgU2hhZGVyU3lzdGVtIHN0YXRlLCBkb2VzIG5vdCBhZmZlY3QgV2ViR0wgc3RhdGVcclxuICAgICAqL1xyXG4gICAgcmVzZXQoKSB7XHJcbiAgICAgICAgdGhpcy5wcm9ncmFtID0gbnVsbDtcclxuICAgICAgICB0aGlzLnNoYWRlciA9IG51bGw7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIERlc3Ryb3lzIHRoaXMgU3lzdGVtIGFuZCByZW1vdmVzIGFsbCBpdHMgdGV4dHVyZXNcclxuICAgICAqL1xyXG4gICAgZGVzdHJveSgpIHtcclxuICAgICAgICAvLyBUT0RPIGltcGxlbWVudCBkZXN0cm95IG1ldGhvZCBmb3IgU2hhZGVyU3lzdGVtXHJcbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgO1xyXG59XHJcbmV4cG9ydHMuU2hhZGVyU3lzdGVtID0gU2hhZGVyU3lzdGVtO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jbGFzcyBTaGFwZVNldHRpbmdzIHtcclxufVxyXG4vKipcclxuKiBDb25zdGFudHMgdGhhdCBpZGVudGlmeSBzaGFwZXMsIG1haW5seSB0byBwcmV2ZW50IGBpbnN0YW5jZW9mYCBjYWxscy5cclxuKlxyXG4qIEBzdGF0aWNcclxuKiBAY29uc3RhbnRcclxuKiBAbmFtZSBTSEFQRVNcclxuKiBAbWVtYmVyb2YgUElYSVxyXG4qIEB0eXBlIHtvYmplY3R9XHJcbiogQHByb3BlcnR5IHtudW1iZXJ9IFBPTFkgUG9seWdvblxyXG4qIEBwcm9wZXJ0eSB7bnVtYmVyfSBSRUNUIFJlY3RhbmdsZVxyXG4qIEBwcm9wZXJ0eSB7bnVtYmVyfSBDSVJDIENpcmNsZVxyXG4qIEBwcm9wZXJ0eSB7bnVtYmVyfSBFTElQIEVsbGlwc2VcclxuKiBAcHJvcGVydHkge251bWJlcn0gUlJFQyBSb3VuZGVkIFJlY3RhbmdsZVxyXG4qL1xyXG5TaGFwZVNldHRpbmdzLlNIQVBFUyA9IHtcclxuICAgIFBPTFk6IDAsXHJcbiAgICBSRUNUOiAxLFxyXG4gICAgQ0lSQzogMixcclxuICAgIEVMSVA6IDMsXHJcbiAgICBSUkVDOiA0LFxyXG59O1xyXG5leHBvcnRzLlNoYXBlU2V0dGluZ3MgPSBTaGFwZVNldHRpbmdzO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBNZXNoXzEgPSByZXF1aXJlKFwiLi9NZXNoXCIpO1xyXG5jb25zdCBSb3BlR2VvbWV0cnlfMSA9IHJlcXVpcmUoXCIuL1JvcGVHZW9tZXRyeVwiKTtcclxuY29uc3QgTWVzaE1hdGVyaWFsXzEgPSByZXF1aXJlKFwiLi9NZXNoTWF0ZXJpYWxcIik7XHJcbmNsYXNzIFNpbXBsZVJvcGUgZXh0ZW5kcyBNZXNoXzEuTWVzaCB7XHJcbiAgICBjb25zdHJ1Y3Rvcih0ZXh0dXJlLCBwb2ludHMpIHtcclxuICAgICAgICB2YXIgcm9wZUdlb21ldHJ5ID0gbmV3IFJvcGVHZW9tZXRyeV8xLlJvcGVHZW9tZXRyeSh0ZXh0dXJlLmhlaWdodCwgcG9pbnRzKTtcclxuICAgICAgICB2YXIgbWVzaE1hdGVyaWFsID0gbmV3IE1lc2hNYXRlcmlhbF8xLk1lc2hNYXRlcmlhbCh0ZXh0dXJlKTtcclxuICAgICAgICBzdXBlcihyb3BlR2VvbWV0cnksIG1lc2hNYXRlcmlhbCk7XHJcbiAgICAgICAgdGhpcy5hdXRvVXBkYXRlID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIF9yZW5kZXIocmVuZGVyZXIpIHtcclxuICAgICAgICBpZiAodGhpcy5hdXRvVXBkYXRlXHJcbiAgICAgICAgICAgIHx8IHRoaXMuZ2VvbWV0cnkud2lkdGggIT09IHRoaXMuc2hhZGVyLnRleHR1cmUuaGVpZ2h0KSB7XHJcbiAgICAgICAgICAgIHRoaXMuZ2VvbWV0cnkud2lkdGggPSB0aGlzLnNoYWRlci50ZXh0dXJlLmhlaWdodDtcclxuICAgICAgICAgICAgdGhpcy5nZW9tZXRyeS51cGRhdGUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc3VwZXIuX3JlbmRlcihyZW5kZXJlcik7XHJcbiAgICB9XHJcbiAgICA7XHJcbn1cclxuZXhwb3J0cy5TaW1wbGVSb3BlID0gU2ltcGxlUm9wZTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgQ29udGFpbmVyXzEgPSByZXF1aXJlKFwiLi9Db250YWluZXJcIik7XHJcbmNvbnN0IE9ic2VydmFibGVQb2ludF8xID0gcmVxdWlyZShcIi4vT2JzZXJ2YWJsZVBvaW50XCIpO1xyXG5jb25zdCBUZXh0dXJlXzEgPSByZXF1aXJlKFwiLi9UZXh0dXJlXCIpO1xyXG5jb25zdCBSZWN0YW5nbGVfMSA9IHJlcXVpcmUoXCIuL1JlY3RhbmdsZVwiKTtcclxuY29uc3QgUG9pbnRfMSA9IHJlcXVpcmUoXCIuL1BvaW50XCIpO1xyXG5jb25zdCBCbGVuZE1vZGVzU2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL0JsZW5kTW9kZXNTZXR0aW5nc1wiKTtcclxuY29uc3QgRGlzcGxheVNldHRpbmdzXzEgPSByZXF1aXJlKFwiLi9EaXNwbGF5U2V0dGluZ3NcIik7XHJcbmNvbnN0IE1hdGhTZXR0aW5nc18xID0gcmVxdWlyZShcIi4vTWF0aFNldHRpbmdzXCIpO1xyXG5jb25zdCBMb2dnZXJfMSA9IHJlcXVpcmUoXCIuL0xvZ2dlclwiKTtcclxuY2xhc3MgU3ByaXRlIGV4dGVuZHMgQ29udGFpbmVyXzEuQ29udGFpbmVyIHtcclxuICAgIGNvbnN0cnVjdG9yKHRleHR1cmUpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFdoZW4gdGhlIHRleHR1cmUgaXMgdXBkYXRlZCwgdGhpcyBldmVudCB3aWxsIGZpcmUgdG8gdXBkYXRlIHRoZSBzY2FsZSBhbmQgZnJhbWVcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5fb25UZXh0dXJlVXBkYXRlID0gKCkgPT4ge1xyXG4gICAgICAgICAgICBMb2dnZXJfMS50cmFjZShcIlNwcml0ZSB1cGRhdGVcIik7XHJcbiAgICAgICAgICAgIHRoaXMuX3RleHR1cmVJRCA9IC0xO1xyXG4gICAgICAgICAgICB0aGlzLl90ZXh0dXJlVHJpbW1lZElEID0gLTE7XHJcbiAgICAgICAgICAgIHRoaXMuY2FjaGVkVGludCA9IDB4RkZGRkZGO1xyXG4gICAgICAgICAgICAvLyByZXZlYWwodGhpcy5fdGV4dHVyZSlcclxuICAgICAgICAgICAgdGhpcy51dnMgPSB0aGlzLl90ZXh0dXJlLl91dnMudXZzRmxvYXQzMjtcclxuICAgICAgICAgICAgLy8gc28gaWYgX3dpZHRoIGlzIDAgdGhlbiB3aWR0aCB3YXMgbm90IHNldC4uXHJcbiAgICAgICAgICAgIGlmICh0aGlzLl93aWR0aCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zY2FsZS54ID0gTWF0aFNldHRpbmdzXzEuTWF0aFNldHRpbmdzLnNpZ24odGhpcy5zY2FsZS54KSAqIHRoaXMuX3dpZHRoIC8gdGhpcy5fdGV4dHVyZS5vcmlnLndpZHRoO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9oZWlnaHQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2NhbGUueSA9IE1hdGhTZXR0aW5nc18xLk1hdGhTZXR0aW5ncy5zaWduKHRoaXMuc2NhbGUueSkgKiB0aGlzLl9oZWlnaHQgLyB0aGlzLl90ZXh0dXJlLm9yaWcuaGVpZ2h0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgYW5jaG9yIHNldHMgdGhlIG9yaWdpbiBwb2ludCBvZiB0aGUgdGV4dHVyZS5cclxuICAgICAgICAgKiBUaGUgZGVmYXVsdCBpcyAwLDAgb3IgdGFrZW4gZnJvbSB0aGUge0BsaW5rIFBJWEkuVGV4dHVyZSNkZWZhdWx0QW5jaG9yfFRleHR1cmV9XHJcbiAgICAgICAgICogcGFzc2VkIHRvIHRoZSBjb25zdHJ1Y3Rvci4gQSB2YWx1ZSBvZiAwLDAgbWVhbnMgdGhlIHRleHR1cmUncyBvcmlnaW4gaXMgdGhlIHRvcCBsZWZ0LlxyXG4gICAgICAgICAqIFNldHRpbmcgdGhlIGFuY2hvciB0byAwLjUsMC41IG1lYW5zIHRoZSB0ZXh0dXJlJ3Mgb3JpZ2luIGlzIGNlbnRlcmVkLlxyXG4gICAgICAgICAqIFNldHRpbmcgdGhlIGFuY2hvciB0byAxLDEgd291bGQgbWVhbiB0aGUgdGV4dHVyZSdzIG9yaWdpbiBwb2ludCB3aWxsIGJlIHRoZSBib3R0b20gcmlnaHQgY29ybmVyLlxyXG4gICAgICAgICAqIE5vdGU6IFVwZGF0aW5nIHRoZSB7QGxpbmsgUElYSS5UZXh0dXJlI2RlZmF1bHRBbmNob3J9IGFmdGVyIGEgVGV4dHVyZSBpc1xyXG4gICAgICAgICAqIGNyZWF0ZWQgZG9lcyBfbm90XyB1cGRhdGUgdGhlIFNwcml0ZSdzIGFuY2hvciB2YWx1ZXMuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLk9ic2VydmFibGVQb2ludH1cclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuX2FuY2hvciA9IG5ldyBPYnNlcnZhYmxlUG9pbnRfMS5PYnNlcnZhYmxlUG9pbnQodGhpcy5fb25BbmNob3JVcGRhdGUsIHRoaXMsICh0ZXh0dXJlID8gdGV4dHVyZS5kZWZhdWx0QW5jaG9yLnggOiAwKSwgKHRleHR1cmUgPyB0ZXh0dXJlLmRlZmF1bHRBbmNob3IueSA6IDApKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgdGV4dHVyZSB0aGF0IHRoZSBzcHJpdGUgaXMgdXNpbmdcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICogQG1lbWJlciB7UElYSS5UZXh0dXJlfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuX3RleHR1cmUgPSBudWxsO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSB3aWR0aCBvZiB0aGUgc3ByaXRlICh0aGlzIGlzIGluaXRpYWxseSBzZXQgYnkgdGhlIHRleHR1cmUpXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLl93aWR0aCA9IDA7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGhlaWdodCBvZiB0aGUgc3ByaXRlICh0aGlzIGlzIGluaXRpYWxseSBzZXQgYnkgdGhlIHRleHR1cmUpXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLl9oZWlnaHQgPSAwO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSB0aW50IGFwcGxpZWQgdG8gdGhlIHNwcml0ZS4gVGhpcyBpcyBhIGhleCB2YWx1ZS4gQSB2YWx1ZSBvZiAweEZGRkZGRiB3aWxsIHJlbW92ZSBhbnkgdGludCBlZmZlY3QuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAgICAgKiBAZGVmYXVsdCAweEZGRkZGRlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuX3RpbnQgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuX3RpbnRSR0IgPSBudWxsO1xyXG4gICAgICAgIHRoaXMudGludCA9IDB4RkZGRkZGO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBibGVuZCBtb2RlIHRvIGJlIGFwcGxpZWQgdG8gdGhlIHNwcml0ZS4gQXBwbHkgYSB2YWx1ZSBvZiBgUElYSS5CTEVORF9NT0RFUy5OT1JNQUxgIHRvIHJlc2V0IHRoZSBibGVuZCBtb2RlLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICAgICAqIEBkZWZhdWx0IFBJWEkuQkxFTkRfTU9ERVMuTk9STUFMXHJcbiAgICAgICAgICogQHNlZSBQSVhJLkJMRU5EX01PREVTXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5ibGVuZE1vZGUgPSBCbGVuZE1vZGVzU2V0dGluZ3NfMS5CbGVuZE1vZGVzU2V0dGluZ3MuQkxFTkRfTU9ERVMuTk9STUFMO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBzaGFkZXIgdGhhdCB3aWxsIGJlIHVzZWQgdG8gcmVuZGVyIHRoZSBzcHJpdGUuIFNldCB0byBudWxsIHRvIHJlbW92ZSBhIGN1cnJlbnQgc2hhZGVyLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQG1lbWJlciB7UElYSS5GaWx0ZXJ8UElYSS5TaGFkZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5zaGFkZXIgPSBudWxsO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFuIGludGVybmFsIGNhY2hlZCB2YWx1ZSBvZiB0aGUgdGludC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICAgICAqIEBkZWZhdWx0IDB4RkZGRkZGXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5jYWNoZWRUaW50ID0gMHhGRkZGRkY7XHJcbiAgICAgICAgdGhpcy51dnMgPSBudWxsO1xyXG4gICAgICAgIC8vIGNhbGwgdGV4dHVyZSBzZXR0ZXJcclxuICAgICAgICB0aGlzLnRleHR1cmUgPSB0ZXh0dXJlIHx8IFRleHR1cmVfMS5UZXh0dXJlLkVNUFRZO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIHRoaXMgaXMgdXNlZCB0byBzdG9yZSB0aGUgdmVydGV4IGRhdGEgb2YgdGhlIHNwcml0ZSAoYmFzaWNhbGx5IGEgcXVhZClcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICogQG1lbWJlciB7RmxvYXQzMkFycmF5fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMudmVydGV4RGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoOCk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhpcyBpcyB1c2VkIHRvIGNhbGN1bGF0ZSB0aGUgYm91bmRzIG9mIHRoZSBvYmplY3QgSUYgaXQgaXMgYSB0cmltbWVkIHNwcml0ZVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKiBAbWVtYmVyIHtGbG9hdDMyQXJyYXl9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy52ZXJ0ZXhUcmltbWVkRGF0YSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5fdHJhbnNmb3JtSUQgPSAtMTtcclxuICAgICAgICB0aGlzLl90ZXh0dXJlSUQgPSAtMTtcclxuICAgICAgICB0aGlzLl90cmFuc2Zvcm1UcmltbWVkSUQgPSAtMTtcclxuICAgICAgICB0aGlzLl90ZXh0dXJlVHJpbW1lZElEID0gLTE7XHJcbiAgICAgICAgLy8gQmF0Y2hhYmxlIHN0dWZmLi5cclxuICAgICAgICAvLyBUT0RPIGNvdWxkIG1ha2UgdGhpcyBhIG1peGluP1xyXG4gICAgICAgIHRoaXMuaW5kaWNlcyA9IFNwcml0ZS5pbmRpY2VzO1xyXG4gICAgICAgIHRoaXMuc2l6ZSA9IDQ7XHJcbiAgICAgICAgdGhpcy5zdGFydCA9IDA7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUGx1Z2luIHRoYXQgaXMgcmVzcG9uc2libGUgZm9yIHJlbmRlcmluZyB0aGlzIGVsZW1lbnQuXHJcbiAgICAgICAgICogQWxsb3dzIHRvIGN1c3RvbWl6ZSB0aGUgcmVuZGVyaW5nIHByb2Nlc3Mgd2l0aG91dCBvdmVycmlkaW5nICdfcmVuZGVyJyAmICdfcmVuZGVyQ2FudmFzJyBtZXRob2RzLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQG1lbWJlciB7c3RyaW5nfVxyXG4gICAgICAgICAqIEBkZWZhdWx0ICdzcHJpdGUnXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5wbHVnaW5OYW1lID0gJ2JhdGNoJztcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiB1c2VkIHRvIGZhc3QgY2hlY2sgaWYgYSBzcHJpdGUgaXMuLiBhIHNwcml0ZSFcclxuICAgICAgICAgKiBAbWVtYmVyIHtib29sZWFufVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuaXNTcHJpdGUgPSB0cnVlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEludGVybmFsIHJvdW5kUGl4ZWxzIGZpZWxkXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAbWVtYmVyIHtib29sZWFufVxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5fcm91bmRQaXhlbHMgPSBEaXNwbGF5U2V0dGluZ3NfMS5EaXNwbGF5U2V0dGluZ3MuUk9VTkRfUElYRUxTO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxsZWQgd2hlbiB0aGUgYW5jaG9yIHBvc2l0aW9uIHVwZGF0ZXMuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgX29uQW5jaG9yVXBkYXRlKCkge1xyXG4gICAgICAgIHRoaXMuX3RyYW5zZm9ybUlEID0gLTE7XHJcbiAgICAgICAgdGhpcy5fdHJhbnNmb3JtVHJpbW1lZElEID0gLTE7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIGNhbGN1bGF0ZXMgd29ybGRUcmFuc2Zvcm0gKiB2ZXJ0aWNlcywgc3RvcmUgaXQgaW4gdmVydGV4RGF0YVxyXG4gICAgICovXHJcbiAgICBjYWxjdWxhdGVWZXJ0aWNlcygpIHtcclxuICAgICAgICB2YXIgdGV4dHVyZSA9IHRoaXMuX3RleHR1cmU7XHJcbiAgICAgICAgaWYgKHRoaXMuX3RyYW5zZm9ybUlEID09PSB0aGlzLnRyYW5zZm9ybS5fd29ybGRJRCAmJiB0aGlzLl90ZXh0dXJlSUQgPT09IHRleHR1cmUuX3VwZGF0ZUlEKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fdHJhbnNmb3JtSUQgPSB0aGlzLnRyYW5zZm9ybS5fd29ybGRJRDtcclxuICAgICAgICB0aGlzLl90ZXh0dXJlSUQgPSB0ZXh0dXJlLl91cGRhdGVJRDtcclxuICAgICAgICAvLyBzZXQgdGhlIHZlcnRleCBkYXRhXHJcbiAgICAgICAgdmFyIHd0ID0gdGhpcy50cmFuc2Zvcm0ud29ybGRUcmFuc2Zvcm07XHJcbiAgICAgICAgdmFyIGEgPSB3dC5hO1xyXG4gICAgICAgIHZhciBiID0gd3QuYjtcclxuICAgICAgICB2YXIgYyA9IHd0LmM7XHJcbiAgICAgICAgdmFyIGQgPSB3dC5kO1xyXG4gICAgICAgIHZhciB0eCA9IHd0LnR4O1xyXG4gICAgICAgIHZhciB0eSA9IHd0LnR5O1xyXG4gICAgICAgIHZhciB2ZXJ0ZXhEYXRhID0gdGhpcy52ZXJ0ZXhEYXRhO1xyXG4gICAgICAgIHZhciB0cmltID0gdGV4dHVyZS50cmltO1xyXG4gICAgICAgIHZhciBvcmlnID0gdGV4dHVyZS5vcmlnO1xyXG4gICAgICAgIHZhciBhbmNob3IgPSB0aGlzLl9hbmNob3I7XHJcbiAgICAgICAgdmFyIHcwID0gMDtcclxuICAgICAgICB2YXIgdzEgPSAwO1xyXG4gICAgICAgIHZhciBoMCA9IDA7XHJcbiAgICAgICAgdmFyIGgxID0gMDtcclxuICAgICAgICBpZiAodHJpbSkge1xyXG4gICAgICAgICAgICAvLyBpZiB0aGUgc3ByaXRlIGlzIHRyaW1tZWQgYW5kIGlzIG5vdCBhIHRpbGluZ3Nwcml0ZSB0aGVuIHdlIG5lZWQgdG8gYWRkIHRoZSBleHRyYVxyXG4gICAgICAgICAgICAvLyBzcGFjZSBiZWZvcmUgdHJhbnNmb3JtaW5nIHRoZSBzcHJpdGUgY29vcmRzLlxyXG4gICAgICAgICAgICB3MSA9IHRyaW0ueCAtIChhbmNob3IuX3ggKiBvcmlnLndpZHRoKTtcclxuICAgICAgICAgICAgdzAgPSB3MSArIHRyaW0ud2lkdGg7XHJcbiAgICAgICAgICAgIGgxID0gdHJpbS55IC0gKGFuY2hvci5feSAqIG9yaWcuaGVpZ2h0KTtcclxuICAgICAgICAgICAgaDAgPSBoMSArIHRyaW0uaGVpZ2h0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdzEgPSAtYW5jaG9yLl94ICogb3JpZy53aWR0aDtcclxuICAgICAgICAgICAgdzAgPSB3MSArIG9yaWcud2lkdGg7XHJcbiAgICAgICAgICAgIGgxID0gLWFuY2hvci5feSAqIG9yaWcuaGVpZ2h0O1xyXG4gICAgICAgICAgICBoMCA9IGgxICsgb3JpZy5oZWlnaHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHh5XHJcbiAgICAgICAgdmVydGV4RGF0YVswXSA9IChhICogdzEpICsgKGMgKiBoMSkgKyB0eDtcclxuICAgICAgICB2ZXJ0ZXhEYXRhWzFdID0gKGQgKiBoMSkgKyAoYiAqIHcxKSArIHR5O1xyXG4gICAgICAgIC8vIHh5XHJcbiAgICAgICAgdmVydGV4RGF0YVsyXSA9IChhICogdzApICsgKGMgKiBoMSkgKyB0eDtcclxuICAgICAgICB2ZXJ0ZXhEYXRhWzNdID0gKGQgKiBoMSkgKyAoYiAqIHcwKSArIHR5O1xyXG4gICAgICAgIC8vIHh5XHJcbiAgICAgICAgdmVydGV4RGF0YVs0XSA9IChhICogdzApICsgKGMgKiBoMCkgKyB0eDtcclxuICAgICAgICB2ZXJ0ZXhEYXRhWzVdID0gKGQgKiBoMCkgKyAoYiAqIHcwKSArIHR5O1xyXG4gICAgICAgIC8vIHh5XHJcbiAgICAgICAgdmVydGV4RGF0YVs2XSA9IChhICogdzEpICsgKGMgKiBoMCkgKyB0eDtcclxuICAgICAgICB2ZXJ0ZXhEYXRhWzddID0gKGQgKiBoMCkgKyAoYiAqIHcxKSArIHR5O1xyXG4gICAgICAgIGlmICh0aGlzLl9yb3VuZFBpeGVscykge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmVydGV4RGF0YVtpXSA9IE1hdGgucm91bmQodmVydGV4RGF0YVtpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIGNhbGN1bGF0ZXMgd29ybGRUcmFuc2Zvcm0gKiB2ZXJ0aWNlcyBmb3IgYSBub24gdGV4dHVyZSB3aXRoIGEgdHJpbS4gc3RvcmUgaXQgaW4gdmVydGV4VHJpbW1lZERhdGFcclxuICAgICAqIFRoaXMgaXMgdXNlZCB0byBlbnN1cmUgdGhhdCB0aGUgdHJ1ZSB3aWR0aCBhbmQgaGVpZ2h0IG9mIGEgdHJpbW1lZCB0ZXh0dXJlIGlzIHJlc3BlY3RlZFxyXG4gICAgICovXHJcbiAgICBjYWxjdWxhdGVUcmltbWVkVmVydGljZXMoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLnZlcnRleFRyaW1tZWREYXRhKSB7XHJcbiAgICAgICAgICAgIHRoaXMudmVydGV4VHJpbW1lZERhdGEgPSBuZXcgRmxvYXQzMkFycmF5KDgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLl90cmFuc2Zvcm1UcmltbWVkSUQgPT09IHRoaXMudHJhbnNmb3JtLl93b3JsZElEICYmIHRoaXMuX3RleHR1cmVUcmltbWVkSUQgPT09IHRoaXMuX3RleHR1cmUuX3VwZGF0ZUlEKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fdHJhbnNmb3JtVHJpbW1lZElEID0gdGhpcy50cmFuc2Zvcm0uX3dvcmxkSUQ7XHJcbiAgICAgICAgdGhpcy5fdGV4dHVyZVRyaW1tZWRJRCA9IHRoaXMuX3RleHR1cmUuX3VwZGF0ZUlEO1xyXG4gICAgICAgIC8vIGxldHMgZG8gc29tZSBzcGVjaWFsIHRyaW0gY29kZSFcclxuICAgICAgICB2YXIgdGV4dHVyZSA9IHRoaXMuX3RleHR1cmU7XHJcbiAgICAgICAgdmFyIHZlcnRleERhdGEgPSB0aGlzLnZlcnRleFRyaW1tZWREYXRhO1xyXG4gICAgICAgIHZhciBvcmlnID0gdGV4dHVyZS5vcmlnO1xyXG4gICAgICAgIHZhciBhbmNob3IgPSB0aGlzLl9hbmNob3I7XHJcbiAgICAgICAgLy8gbGV0cyBjYWxjdWxhdGUgdGhlIG5ldyB1bnRyaW1tZWQgYm91bmRzLi5cclxuICAgICAgICB2YXIgd3QgPSB0aGlzLnRyYW5zZm9ybS53b3JsZFRyYW5zZm9ybTtcclxuICAgICAgICB2YXIgYSA9IHd0LmE7XHJcbiAgICAgICAgdmFyIGIgPSB3dC5iO1xyXG4gICAgICAgIHZhciBjID0gd3QuYztcclxuICAgICAgICB2YXIgZCA9IHd0LmQ7XHJcbiAgICAgICAgdmFyIHR4ID0gd3QudHg7XHJcbiAgICAgICAgdmFyIHR5ID0gd3QudHk7XHJcbiAgICAgICAgdmFyIHcxID0gLWFuY2hvci5feCAqIG9yaWcud2lkdGg7XHJcbiAgICAgICAgdmFyIHcwID0gdzEgKyBvcmlnLndpZHRoO1xyXG4gICAgICAgIHZhciBoMSA9IC1hbmNob3IuX3kgKiBvcmlnLmhlaWdodDtcclxuICAgICAgICB2YXIgaDAgPSBoMSArIG9yaWcuaGVpZ2h0O1xyXG4gICAgICAgIC8vIHh5XHJcbiAgICAgICAgdmVydGV4RGF0YVswXSA9IChhICogdzEpICsgKGMgKiBoMSkgKyB0eDtcclxuICAgICAgICB2ZXJ0ZXhEYXRhWzFdID0gKGQgKiBoMSkgKyAoYiAqIHcxKSArIHR5O1xyXG4gICAgICAgIC8vIHh5XHJcbiAgICAgICAgdmVydGV4RGF0YVsyXSA9IChhICogdzApICsgKGMgKiBoMSkgKyB0eDtcclxuICAgICAgICB2ZXJ0ZXhEYXRhWzNdID0gKGQgKiBoMSkgKyAoYiAqIHcwKSArIHR5O1xyXG4gICAgICAgIC8vIHh5XHJcbiAgICAgICAgdmVydGV4RGF0YVs0XSA9IChhICogdzApICsgKGMgKiBoMCkgKyB0eDtcclxuICAgICAgICB2ZXJ0ZXhEYXRhWzVdID0gKGQgKiBoMCkgKyAoYiAqIHcwKSArIHR5O1xyXG4gICAgICAgIC8vIHh5XHJcbiAgICAgICAgdmVydGV4RGF0YVs2XSA9IChhICogdzEpICsgKGMgKiBoMCkgKyB0eDtcclxuICAgICAgICB2ZXJ0ZXhEYXRhWzddID0gKGQgKiBoMCkgKyAoYiAqIHcxKSArIHR5O1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAqXHJcbiAgICAqIFJlbmRlcnMgdGhlIG9iamVjdCB1c2luZyB0aGUgV2ViR0wgcmVuZGVyZXJcclxuICAgICpcclxuICAgICogQHByb3RlY3RlZFxyXG4gICAgKiBAcGFyYW0ge1BJWEkuUmVuZGVyZXJ9IHJlbmRlcmVyIC0gVGhlIHdlYmdsIHJlbmRlcmVyIHRvIHVzZS5cclxuICAgICovXHJcbiAgICBfcmVuZGVyKHJlbmRlcmVyKSB7XHJcbiAgICAgICAgdGhpcy5jYWxjdWxhdGVWZXJ0aWNlcygpO1xyXG4gICAgICAgIHJlbmRlcmVyLmJhdGNoLnNldE9iamVjdFJlbmRlcmVyKHJlbmRlcmVyLnBsdWdpbnNbdGhpcy5wbHVnaW5OYW1lXSk7XHJcbiAgICAgICAgcmVuZGVyZXIucGx1Z2luc1t0aGlzLnBsdWdpbk5hbWVdLnJlbmRlcih0aGlzKTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyB0aGUgYm91bmRzIG9mIHRoZSBzcHJpdGUuXHJcbiAgICAgKlxyXG4gICAgICogQHByb3RlY3RlZFxyXG4gICAgICovXHJcbiAgICBfY2FsY3VsYXRlQm91bmRzKCkge1xyXG4gICAgICAgIHZhciB0cmltID0gdGhpcy5fdGV4dHVyZS50cmltO1xyXG4gICAgICAgIHZhciBvcmlnID0gdGhpcy5fdGV4dHVyZS5vcmlnO1xyXG4gICAgICAgIC8vIEZpcnN0IGxldHMgY2hlY2sgdG8gc2VlIGlmIHRoZSBjdXJyZW50IHRleHR1cmUgaGFzIGEgdHJpbS4uXHJcbiAgICAgICAgaWYgKCF0cmltIHx8ICh0cmltLndpZHRoID09PSBvcmlnLndpZHRoICYmIHRyaW0uaGVpZ2h0ID09PSBvcmlnLmhlaWdodCkpIHtcclxuICAgICAgICAgICAgLy8gbm8gdHJpbSEgbGV0cyB1c2UgdGhlIHVzdWFsIGNhbGN1bGF0aW9ucy4uXHJcbiAgICAgICAgICAgIHRoaXMuY2FsY3VsYXRlVmVydGljZXMoKTtcclxuICAgICAgICAgICAgdGhpcy5fYm91bmRzLmFkZFF1YWQodGhpcy52ZXJ0ZXhEYXRhKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIGxldHMgY2FsY3VsYXRlIGEgc3BlY2lhbCB0cmltbWVkIGJvdW5kcy4uLlxyXG4gICAgICAgICAgICB0aGlzLmNhbGN1bGF0ZVRyaW1tZWRWZXJ0aWNlcygpO1xyXG4gICAgICAgICAgICB0aGlzLl9ib3VuZHMuYWRkUXVhZCh0aGlzLnZlcnRleFRyaW1tZWREYXRhKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIGxvY2FsIGJvdW5kcyBvZiB0aGUgc3ByaXRlIG9iamVjdC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1BJWEkuUmVjdGFuZ2xlfSByZWN0IC0gVGhlIG91dHB1dCByZWN0YW5nbGUuXHJcbiAgICAgKiBAcmV0dXJuIHtQSVhJLlJlY3RhbmdsZX0gVGhlIGJvdW5kcy5cclxuICAgICAqL1xyXG4gICAgZ2V0TG9jYWxCb3VuZHMocmVjdCkge1xyXG4gICAgICAgIC8vIHdlIGNhbiBkbyBhIGZhc3QgbG9jYWwgYm91bmRzIGlmIHRoZSBzcHJpdGUgaGFzIG5vIGNoaWxkcmVuIVxyXG4gICAgICAgIGlmICh0aGlzLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICB0aGlzLl9ib3VuZHMubWluWCA9IHRoaXMuX3RleHR1cmUub3JpZy53aWR0aCAqIC10aGlzLl9hbmNob3IuX3g7XHJcbiAgICAgICAgICAgIHRoaXMuX2JvdW5kcy5taW5ZID0gdGhpcy5fdGV4dHVyZS5vcmlnLmhlaWdodCAqIC10aGlzLl9hbmNob3IuX3k7XHJcbiAgICAgICAgICAgIHRoaXMuX2JvdW5kcy5tYXhYID0gdGhpcy5fdGV4dHVyZS5vcmlnLndpZHRoICogKDEgLSB0aGlzLl9hbmNob3IuX3gpO1xyXG4gICAgICAgICAgICB0aGlzLl9ib3VuZHMubWF4WSA9IHRoaXMuX3RleHR1cmUub3JpZy5oZWlnaHQgKiAoMSAtIHRoaXMuX2FuY2hvci5feSk7XHJcbiAgICAgICAgICAgIGlmICghcmVjdCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9sb2NhbEJvdW5kc1JlY3QpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sb2NhbEJvdW5kc1JlY3QgPSBuZXcgUmVjdGFuZ2xlXzEuUmVjdGFuZ2xlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZWN0ID0gdGhpcy5fbG9jYWxCb3VuZHNSZWN0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9ib3VuZHMuZ2V0UmVjdGFuZ2xlKHJlY3QpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gQ29udGFpbmVyXzEuQ29udGFpbmVyLnByb3RvdHlwZS5nZXRMb2NhbEJvdW5kcy5jYWxsKHRoaXMsIHJlY3QpO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUZXN0cyBpZiBhIHBvaW50IGlzIGluc2lkZSB0aGlzIHNwcml0ZVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7UElYSS5Qb2ludH0gcG9pbnQgLSB0aGUgcG9pbnQgdG8gdGVzdFxyXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gdGhlIHJlc3VsdCBvZiB0aGUgdGVzdFxyXG4gICAgICovXHJcbiAgICBjb250YWluc1BvaW50KHBvaW50KSB7XHJcbiAgICAgICAgdGhpcy53b3JsZFRyYW5zZm9ybS5hcHBseUludmVyc2UocG9pbnQsIFNwcml0ZS50ZW1wUG9pbnQpO1xyXG4gICAgICAgIHZhciB3aWR0aCA9IHRoaXMuX3RleHR1cmUub3JpZy53aWR0aDtcclxuICAgICAgICB2YXIgaGVpZ2h0ID0gdGhpcy5fdGV4dHVyZS5vcmlnLmhlaWdodDtcclxuICAgICAgICB2YXIgeDEgPSAtd2lkdGggKiB0aGlzLmFuY2hvci54O1xyXG4gICAgICAgIHZhciB5MSA9IDA7XHJcbiAgICAgICAgaWYgKFNwcml0ZS50ZW1wUG9pbnQueCA+PSB4MSAmJiBTcHJpdGUudGVtcFBvaW50LnggPCB4MSArIHdpZHRoKSB7XHJcbiAgICAgICAgICAgIHkxID0gLWhlaWdodCAqIHRoaXMuYW5jaG9yLnk7XHJcbiAgICAgICAgICAgIGlmIChTcHJpdGUudGVtcFBvaW50LnkgPj0geTEgJiYgU3ByaXRlLnRlbXBQb2ludC55IDwgeTEgKyBoZWlnaHQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogRGVzdHJveXMgdGhpcyBzcHJpdGUgYW5kIG9wdGlvbmFsbHkgaXRzIHRleHR1cmUgYW5kIGNoaWxkcmVuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtvYmplY3R8Ym9vbGVhbn0gW29wdGlvbnNdIC0gT3B0aW9ucyBwYXJhbWV0ZXIuIEEgYm9vbGVhbiB3aWxsIGFjdCBhcyBpZiBhbGwgb3B0aW9uc1xyXG4gICAgICogIGhhdmUgYmVlbiBzZXQgdG8gdGhhdCB2YWx1ZVxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jaGlsZHJlbj1mYWxzZV0gLSBpZiBzZXQgdG8gdHJ1ZSwgYWxsIHRoZSBjaGlsZHJlbiB3aWxsIGhhdmUgdGhlaXIgZGVzdHJveVxyXG4gICAgICogICAgICBtZXRob2QgY2FsbGVkIGFzIHdlbGwuICdvcHRpb25zJyB3aWxsIGJlIHBhc3NlZCBvbiB0byB0aG9zZSBjYWxscy5cclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudGV4dHVyZT1mYWxzZV0gLSBTaG91bGQgaXQgZGVzdHJveSB0aGUgY3VycmVudCB0ZXh0dXJlIG9mIHRoZSBzcHJpdGUgYXMgd2VsbFxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5iYXNlVGV4dHVyZT1mYWxzZV0gLSBTaG91bGQgaXQgZGVzdHJveSB0aGUgYmFzZSB0ZXh0dXJlIG9mIHRoZSBzcHJpdGUgYXMgd2VsbFxyXG4gICAgICovXHJcbiAgICBkZXN0cm95KG9wdGlvbnMpIHtcclxuICAgICAgICBzdXBlci5kZXN0cm95KG9wdGlvbnMpO1xyXG4gICAgICAgIC8vIHRoaXMuX3RleHR1cmUub2ZmKCd1cGRhdGUnLCB0aGlzLl9vblRleHR1cmVVcGRhdGUsIHRoaXMpO1xyXG4gICAgICAgIHRoaXMuX2FuY2hvciA9IG51bGw7XHJcbiAgICAgICAgdmFyIGRlc3Ryb3lUZXh0dXJlID0gdHlwZW9mIG9wdGlvbnMgPT09ICdib29sZWFuJyA/IG9wdGlvbnMgOiBvcHRpb25zICYmIG9wdGlvbnMudGV4dHVyZTtcclxuICAgICAgICBpZiAoZGVzdHJveVRleHR1cmUpIHtcclxuICAgICAgICAgICAgdmFyIGRlc3Ryb3lCYXNlVGV4dHVyZSA9IHR5cGVvZiBvcHRpb25zID09PSAnYm9vbGVhbicgPyBvcHRpb25zIDogb3B0aW9ucyAmJiBvcHRpb25zLmJhc2VUZXh0dXJlO1xyXG4gICAgICAgICAgICB0aGlzLl90ZXh0dXJlLmRlc3Ryb3koISFkZXN0cm95QmFzZVRleHR1cmUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl90ZXh0dXJlID0gbnVsbDtcclxuICAgICAgICB0aGlzLnNoYWRlciA9IG51bGw7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIElmIHRydWUgUGl4aUpTIHdpbGwgTWF0aC5mbG9vcigpIHgveSB2YWx1ZXMgd2hlbiByZW5kZXJpbmcsIHN0b3BwaW5nIHBpeGVsIGludGVycG9sYXRpb24uXHJcbiAgICAgKiBBZHZhbnRhZ2VzIGNhbiBpbmNsdWRlIHNoYXJwZXIgaW1hZ2UgcXVhbGl0eSAobGlrZSB0ZXh0KSBhbmQgZmFzdGVyIHJlbmRlcmluZyBvbiBjYW52YXMuXHJcbiAgICAgKiBUaGUgbWFpbiBkaXNhZHZhbnRhZ2UgaXMgbW92ZW1lbnQgb2Ygb2JqZWN0cyBtYXkgYXBwZWFyIGxlc3Mgc21vb3RoLlxyXG4gICAgICogVG8gc2V0IHRoZSBnbG9iYWwgZGVmYXVsdCwgY2hhbmdlIHtAbGluayBQSVhJLnNldHRpbmdzLlJPVU5EX1BJWEVMU31cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtib29sZWFufVxyXG4gICAgICogQGRlZmF1bHQgZmFsc2VcclxuICAgICAqL1xyXG4gICAgc2V0IHJvdW5kUGl4ZWxzKHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3JvdW5kUGl4ZWxzICE9PSB2YWx1ZSkge1xyXG4gICAgICAgICAgICB0aGlzLl90cmFuc2Zvcm1JRCA9IC0xO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9yb3VuZFBpeGVscyA9IHZhbHVlO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgZ2V0IHJvdW5kUGl4ZWxzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9yb3VuZFBpeGVscztcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIHdpZHRoIG9mIHRoZSBzcHJpdGUsIHNldHRpbmcgdGhpcyB3aWxsIGFjdHVhbGx5IG1vZGlmeSB0aGUgc2NhbGUgdG8gYWNoaWV2ZSB0aGUgdmFsdWUgc2V0XHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICBnZXQgd2lkdGgoKSB7XHJcbiAgICAgICAgcmV0dXJuIE1hdGguYWJzKHRoaXMuc2NhbGUueCkgKiB0aGlzLl90ZXh0dXJlLm9yaWcud2lkdGg7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICBzZXQgd2lkdGgodmFsdWUpIHtcclxuICAgICAgICB2YXIgcyA9IE1hdGhTZXR0aW5nc18xLk1hdGhTZXR0aW5ncy5zaWduKHRoaXMuc2NhbGUueCkgfHwgMTtcclxuICAgICAgICB0aGlzLnNjYWxlLnggPSBzICogdmFsdWUgLyB0aGlzLl90ZXh0dXJlLm9yaWcud2lkdGg7XHJcbiAgICAgICAgdGhpcy5fd2lkdGggPSB2YWx1ZTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGhlaWdodCBvZiB0aGUgc3ByaXRlLCBzZXR0aW5nIHRoaXMgd2lsbCBhY3R1YWxseSBtb2RpZnkgdGhlIHNjYWxlIHRvIGFjaGlldmUgdGhlIHZhbHVlIHNldFxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgZ2V0IGhlaWdodCgpIHtcclxuICAgICAgICByZXR1cm4gTWF0aC5hYnModGhpcy5zY2FsZS55KSAqIHRoaXMuX3RleHR1cmUub3JpZy5oZWlnaHQ7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICBzZXQgaGVpZ2h0KHZhbHVlKSB7XHJcbiAgICAgICAgdmFyIHMgPSBNYXRoU2V0dGluZ3NfMS5NYXRoU2V0dGluZ3Muc2lnbih0aGlzLnNjYWxlLnkpIHx8IDE7XHJcbiAgICAgICAgdGhpcy5zY2FsZS55ID0gcyAqIHZhbHVlIC8gdGhpcy5fdGV4dHVyZS5vcmlnLmhlaWdodDtcclxuICAgICAgICB0aGlzLl9oZWlnaHQgPSB2YWx1ZTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGFuY2hvciBzZXRzIHRoZSBvcmlnaW4gcG9pbnQgb2YgdGhlIHRleHQuIFRoZSBkZWZhdWx0IHZhbHVlIGlzIHRha2VuIGZyb20gdGhlIHtAbGluayBQSVhJLlRleHR1cmV8VGV4dHVyZX1cclxuICAgICAqIGFuZCBwYXNzZWQgdG8gdGhlIGNvbnN0cnVjdG9yLlxyXG4gICAgICpcclxuICAgICAqIFRoZSBkZWZhdWx0IGlzIGAoMCwwKWAsIHRoaXMgbWVhbnMgdGhlIHRleHQncyBvcmlnaW4gaXMgdGhlIHRvcCBsZWZ0LlxyXG4gICAgICpcclxuICAgICAqIFNldHRpbmcgdGhlIGFuY2hvciB0byBgKDAuNSwwLjUpYCBtZWFucyB0aGUgdGV4dCdzIG9yaWdpbiBpcyBjZW50ZXJlZC5cclxuICAgICAqXHJcbiAgICAgKiBTZXR0aW5nIHRoZSBhbmNob3IgdG8gYCgxLDEpYCB3b3VsZCBtZWFuIHRoZSB0ZXh0J3Mgb3JpZ2luIHBvaW50IHdpbGwgYmUgdGhlIGJvdHRvbSByaWdodCBjb3JuZXIuXHJcbiAgICAgKlxyXG4gICAgICogSWYgeW91IHBhc3Mgb25seSBzaW5nbGUgcGFyYW1ldGVyLCBpdCB3aWxsIHNldCBib3RoIHggYW5kIHkgdG8gdGhlIHNhbWUgdmFsdWUgYXMgc2hvd24gaW4gdGhlIGV4YW1wbGUgYmVsb3cuXHJcbiAgICAgKlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGNvbnN0IHNwcml0ZSA9IG5ldyBQSVhJLlNwcml0ZSh0ZXh0dXJlKTtcclxuICAgICAqIHNwcml0ZS5hbmNob3Iuc2V0KDAuNSk7IC8vIFRoaXMgd2lsbCBzZXQgdGhlIG9yaWdpbiB0byBjZW50ZXIuICgwLjUpIGlzIHNhbWUgYXMgKDAuNSwgMC41KS5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtQSVhJLk9ic2VydmFibGVQb2ludH1cclxuICAgICAqL1xyXG4gICAgZ2V0IGFuY2hvcigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fYW5jaG9yO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgc2V0IGFuY2hvcih2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuX2FuY2hvci5jb3B5RnJvbSh2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSB0aW50IGFwcGxpZWQgdG8gdGhlIHNwcml0ZS4gVGhpcyBpcyBhIGhleCB2YWx1ZS5cclxuICAgICAqIEEgdmFsdWUgb2YgMHhGRkZGRkYgd2lsbCByZW1vdmUgYW55IHRpbnQgZWZmZWN0LlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAqIEBkZWZhdWx0IDB4RkZGRkZGXHJcbiAgICAgKi9cclxuICAgIGdldCB0aW50KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl90aW50O1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgc2V0IHRpbnQodmFsdWUpIHtcclxuICAgICAgICB0aGlzLl90aW50ID0gdmFsdWU7XHJcbiAgICAgICAgdGhpcy5fdGludFJHQiA9ICh2YWx1ZSA+PiAxNikgKyAodmFsdWUgJiAweGZmMDApICsgKCh2YWx1ZSAmIDB4ZmYpIDw8IDE2KTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIHRleHR1cmUgdGhhdCB0aGUgc3ByaXRlIGlzIHVzaW5nXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7UElYSS5UZXh0dXJlfVxyXG4gICAgICovXHJcbiAgICBnZXQgdGV4dHVyZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fdGV4dHVyZTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIHNldCB0ZXh0dXJlKHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3RleHR1cmUgPT09IHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fdGV4dHVyZSA9IHZhbHVlIHx8IFRleHR1cmVfMS5UZXh0dXJlLkVNUFRZO1xyXG4gICAgICAgIHRoaXMuY2FjaGVkVGludCA9IDB4RkZGRkZGO1xyXG4gICAgICAgIHRoaXMuX3RleHR1cmVJRCA9IC0xO1xyXG4gICAgICAgIHRoaXMuX3RleHR1cmVUcmltbWVkSUQgPSAtMTtcclxuICAgICAgICBpZiAodmFsdWUpIHtcclxuICAgICAgICAgICAgLy8gd2FpdCBmb3IgdGhlIHRleHR1cmUgdG8gbG9hZFxyXG4gICAgICAgICAgICBpZiAodmFsdWUuYmFzZVRleHR1cmUudmFsaWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX29uVGV4dHVyZVVwZGF0ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmFsdWUuYWRkRXZlbnRMaXN0ZW5lcigndXBkYXRlJywgdGhpcy5fb25UZXh0dXJlVXBkYXRlKTtcclxuICAgICAgICAgICAgICAgIC8vIHZhbHVlLm9uY2UoJ3VwZGF0ZScsIHRoaXMuX29uVGV4dHVyZVVwZGF0ZSwgdGhpcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICA7XHJcbn1cclxuU3ByaXRlLnRlbXBQb2ludCA9IG5ldyBQb2ludF8xLlBvaW50KCk7XHJcblNwcml0ZS5pbmRpY2VzID0gbmV3IFVpbnQxNkFycmF5KFswLCAxLCAyLCAwLCAyLCAzXSk7XHJcbi8vIHNvbWUgaGVscGVyIGZ1bmN0aW9ucy4uXHJcbi8qKlxyXG4gKiBIZWxwZXIgZnVuY3Rpb24gdGhhdCBjcmVhdGVzIGEgbmV3IHNwcml0ZSBiYXNlZCBvbiB0aGUgc291cmNlIHlvdSBwcm92aWRlLlxyXG4gKiBUaGUgc291cmNlIGNhbiBiZSAtIGZyYW1lIGlkLCBpbWFnZSB1cmwsIHZpZGVvIHVybCwgY2FudmFzIGVsZW1lbnQsIHZpZGVvIGVsZW1lbnQsIGJhc2UgdGV4dHVyZVxyXG4gKlxyXG4gKiBAc3RhdGljXHJcbiAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ3xQSVhJLlRleHR1cmV8SFRNTENhbnZhc0VsZW1lbnR8SFRNTFZpZGVvRWxlbWVudH0gc291cmNlIFNvdXJjZSB0byBjcmVhdGUgdGV4dHVyZSBmcm9tXHJcbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gU2VlIHtAbGluayBQSVhJLkJhc2VUZXh0dXJlfSdzIGNvbnN0cnVjdG9yIGZvciBvcHRpb25zLlxyXG4gKiBAcmV0dXJuIHtQSVhJLlNwcml0ZX0gVGhlIG5ld2x5IGNyZWF0ZWQgc3ByaXRlXHJcbiAqL1xyXG5TcHJpdGUuZnJvbSA9IGZ1bmN0aW9uIGZyb20oc291cmNlLCBvcHRpb25zID0ge30pIHtcclxuICAgIGlmIChvcHRpb25zID09IG51bGwpIHtcclxuICAgICAgICBvcHRpb25zID0ge307XHJcbiAgICB9XHJcbiAgICB2YXIgdGV4dHVyZSA9IChzb3VyY2UgaW5zdGFuY2VvZiBUZXh0dXJlXzEuVGV4dHVyZSlcclxuICAgICAgICA/IHNvdXJjZVxyXG4gICAgICAgIDogVGV4dHVyZV8xLlRleHR1cmUuZnJvbShzb3VyY2UsIG9wdGlvbnMpO1xyXG4gICAgcmV0dXJuIG5ldyBTcHJpdGUodGV4dHVyZSk7XHJcbn07XHJcbmV4cG9ydHMuU3ByaXRlID0gU3ByaXRlO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBGaWx0ZXJfMSA9IHJlcXVpcmUoXCIuL0ZpbHRlclwiKTtcclxuY29uc3QgTWF0cml4XzEgPSByZXF1aXJlKFwiLi9NYXRyaXhcIik7XHJcbmNvbnN0IFRleHR1cmVNYXRyaXhfMSA9IHJlcXVpcmUoXCIuL1RleHR1cmVNYXRyaXhcIik7XHJcbmNsYXNzIFNwcml0ZU1hc2tGaWx0ZXIgZXh0ZW5kcyBGaWx0ZXJfMS5GaWx0ZXIge1xyXG4gICAgY29uc3RydWN0b3Ioc3ByaXRlKSB7XHJcbiAgICAgICAgdmFyIG1hc2tNYXRyaXggPSBuZXcgTWF0cml4XzEuTWF0cml4KCk7XHJcbiAgICAgICAgc3VwZXIoU3ByaXRlTWFza0ZpbHRlci52ZXJ0ZXgsIFNwcml0ZU1hc2tGaWx0ZXIuZnJhZ21lbnQpO1xyXG4gICAgICAgIHNwcml0ZS5yZW5kZXJhYmxlID0gZmFsc2U7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU3ByaXRlIG1hc2tcclxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLlNwcml0ZX1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLm1hc2tTcHJpdGUgPSBzcHJpdGU7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogTWFzayBtYXRyaXhcclxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLk1hdHJpeH1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLm1hc2tNYXRyaXggPSBtYXNrTWF0cml4O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBsaWVzIHRoZSBmaWx0ZXJcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1BJWEkuc3lzdGVtcy5GaWx0ZXJTeXN0ZW19IGZpbHRlck1hbmFnZXIgLSBUaGUgcmVuZGVyZXIgdG8gcmV0cmlldmUgdGhlIGZpbHRlciBmcm9tXHJcbiAgICAgKiBAcGFyYW0ge1BJWEkuUmVuZGVyVGV4dHVyZX0gaW5wdXQgLSBUaGUgaW5wdXQgcmVuZGVyIHRhcmdldC5cclxuICAgICAqIEBwYXJhbSB7UElYSS5SZW5kZXJUZXh0dXJlfSBvdXRwdXQgLSBUaGUgdGFyZ2V0IHRvIG91dHB1dCB0by5cclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gY2xlYXIgLSBTaG91bGQgdGhlIG91dHB1dCBiZSBjbGVhcmVkIGJlZm9yZSByZW5kZXJpbmcgdG8gaXQuXHJcbiAgICAgKi9cclxuICAgIGFwcGx5KGZpbHRlck1hbmFnZXIsIGlucHV0LCBvdXRwdXQsIGNsZWFyKSB7XHJcbiAgICAgICAgdmFyIG1hc2tTcHJpdGUgPSB0aGlzLm1hc2tTcHJpdGU7XHJcbiAgICAgICAgdmFyIHRleCA9IHRoaXMubWFza1Nwcml0ZS50ZXh0dXJlO1xyXG4gICAgICAgIGlmICghdGV4LnZhbGlkKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCF0ZXgudHJhbnNmb3JtKSB7XHJcbiAgICAgICAgICAgIC8vIG1hcmdpbiA9IDAuMCwgbGV0IGl0IGJsZWVkIGEgYml0LCBzaGFkZXIgY29kZSBiZWNvbWVzIGVhc2llclxyXG4gICAgICAgICAgICAvLyBhc3N1bWluZyB0aGF0IGF0bGFzIHRleHR1cmVzIHdlcmUgbWFkZSB3aXRoIDEtcGl4ZWwgcGFkZGluZ1xyXG4gICAgICAgICAgICB0ZXgudHJhbnNmb3JtID0gbmV3IFRleHR1cmVNYXRyaXhfMS5UZXh0dXJlTWF0cml4KHRleCwgMC4wKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGV4LnRyYW5zZm9ybS51cGRhdGUoKTtcclxuICAgICAgICB0aGlzLnVuaWZvcm1zLm5wbUFscGhhID0gdGV4LmJhc2VUZXh0dXJlLnByZW11bHRpcGx5QWxwaGEgPyAwLjAgOiAxLjA7XHJcbiAgICAgICAgdGhpcy51bmlmb3Jtcy5tYXNrID0gdGV4O1xyXG4gICAgICAgIHRoaXMudW5pZm9ybXMub3RoZXJNYXRyaXggPSBmaWx0ZXJNYW5hZ2VyLmNhbGN1bGF0ZVNwcml0ZU1hdHJpeCh0aGlzLm1hc2tNYXRyaXgsIG1hc2tTcHJpdGUpXHJcbiAgICAgICAgICAgIC5wcmVwZW5kKHRleC50cmFuc2Zvcm0ubWFwQ29vcmQpO1xyXG4gICAgICAgIHRoaXMudW5pZm9ybXMuYWxwaGEgPSBtYXNrU3ByaXRlLndvcmxkQWxwaGE7XHJcbiAgICAgICAgdGhpcy51bmlmb3Jtcy5tYXNrQ2xhbXAgPSB0ZXgudHJhbnNmb3JtLnVDbGFtcEZyYW1lO1xyXG4gICAgICAgIGZpbHRlck1hbmFnZXIuYXBwbHlGaWx0ZXIodGhpcywgaW5wdXQsIG91dHB1dCwgY2xlYXIpO1xyXG4gICAgfVxyXG4gICAgO1xyXG59XHJcblNwcml0ZU1hc2tGaWx0ZXIudmVydGV4ID0gXCJhdHRyaWJ1dGUgdmVjMiBhVmVydGV4UG9zaXRpb247XFxyXFxuYXR0cmlidXRlIHZlYzIgYVRleHR1cmVDb29yZDtcXHJcXG5cXHJcXG51bmlmb3JtIG1hdDMgcHJvamVjdGlvbk1hdHJpeDtcXHJcXG51bmlmb3JtIG1hdDMgb3RoZXJNYXRyaXg7XFxyXFxuXFxyXFxudmFyeWluZyB2ZWMyIHZNYXNrQ29vcmQ7XFxyXFxudmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XFxyXFxuXFxyXFxudm9pZCBtYWluKHZvaWQpXFxyXFxue1xcclxcbiAgICBnbF9Qb3NpdGlvbiA9IHZlYzQoKHByb2plY3Rpb25NYXRyaXggKiB2ZWMzKGFWZXJ0ZXhQb3NpdGlvbiwgMS4wKSkueHksIDAuMCwgMS4wKTtcXHJcXG5cXHJcXG4gICAgdlRleHR1cmVDb29yZCA9IGFUZXh0dXJlQ29vcmQ7XFxyXFxuICAgIHZNYXNrQ29vcmQgPSAoIG90aGVyTWF0cml4ICogdmVjMyggYVRleHR1cmVDb29yZCwgMS4wKSAgKS54eTtcXHJcXG59XFxyXFxuXCI7XHJcblNwcml0ZU1hc2tGaWx0ZXIuZnJhZ21lbnQgPSBcInZhcnlpbmcgdmVjMiB2TWFza0Nvb3JkO1xcclxcbnZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xcclxcblxcclxcbnVuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyO1xcclxcbnVuaWZvcm0gc2FtcGxlcjJEIG1hc2s7XFxyXFxudW5pZm9ybSBmbG9hdCBhbHBoYTtcXHJcXG51bmlmb3JtIGZsb2F0IG5wbUFscGhhO1xcclxcbnVuaWZvcm0gdmVjNCBtYXNrQ2xhbXA7XFxyXFxuXFxyXFxudm9pZCBtYWluKHZvaWQpXFxyXFxue1xcclxcbiAgICBmbG9hdCBjbGlwID0gc3RlcCgzLjUsXFxyXFxuICAgICAgICBzdGVwKG1hc2tDbGFtcC54LCB2TWFza0Nvb3JkLngpICtcXHJcXG4gICAgICAgIHN0ZXAobWFza0NsYW1wLnksIHZNYXNrQ29vcmQueSkgK1xcclxcbiAgICAgICAgc3RlcCh2TWFza0Nvb3JkLngsIG1hc2tDbGFtcC56KSArXFxyXFxuICAgICAgICBzdGVwKHZNYXNrQ29vcmQueSwgbWFza0NsYW1wLncpKTtcXHJcXG5cXHJcXG4gICAgdmVjNCBvcmlnaW5hbCA9IHRleHR1cmUyRCh1U2FtcGxlciwgdlRleHR1cmVDb29yZCk7XFxyXFxuICAgIHZlYzQgbWFza3kgPSB0ZXh0dXJlMkQobWFzaywgdk1hc2tDb29yZCk7XFxyXFxuICAgIGZsb2F0IGFscGhhTXVsID0gMS4wIC0gbnBtQWxwaGEgKiAoMS4wIC0gbWFza3kuYSk7XFxyXFxuXFxyXFxuICAgIG9yaWdpbmFsICo9IChhbHBoYU11bCAqIG1hc2t5LnIgKiBhbHBoYSAqIGNsaXApO1xcclxcblxcclxcbiAgICBnbF9GcmFnQ29sb3IgPSBvcmlnaW5hbDtcXHJcXG59XFxyXFxuXCI7XHJcbmV4cG9ydHMuU3ByaXRlTWFza0ZpbHRlciA9IFNwcml0ZU1hc2tGaWx0ZXI7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IFJlY3RhbmdsZV8xID0gcmVxdWlyZShcIi4vUmVjdGFuZ2xlXCIpO1xyXG5jb25zdCBUZXh0dXJlXzEgPSByZXF1aXJlKFwiLi9UZXh0dXJlXCIpO1xyXG5jb25zdCBOZXR3b3JrU2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL05ldHdvcmtTZXR0aW5nc1wiKTtcclxuY2xhc3MgU3ByaXRlc2hlZXQge1xyXG4gICAgY29uc3RydWN0b3IoYmFzZVRleHR1cmUsIGRhdGEsIHJlc29sdXRpb25GaWxlbmFtZSA9IG51bGwpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZWZlcmVuY2UgdG8gdGhzIHNvdXJjZSB0ZXh0dXJlXHJcbiAgICAgICAgICogQHR5cGUge1BJWEkuQmFzZVRleHR1cmV9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5iYXNlVGV4dHVyZSA9IGJhc2VUZXh0dXJlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEEgbWFwIGNvbnRhaW5pbmcgYWxsIHRleHR1cmVzIG9mIHRoZSBzcHJpdGUgc2hlZXQuXHJcbiAgICAgICAgICogQ2FuIGJlIHVzZWQgdG8gY3JlYXRlIGEge0BsaW5rIFBJWEkuU3ByaXRlfFNwcml0ZX06XHJcbiAgICAgICAgICogYGBganNcclxuICAgICAgICAgKiBuZXcgUElYSS5TcHJpdGUoc2hlZXQudGV4dHVyZXNbXCJpbWFnZS5wbmdcIl0pO1xyXG4gICAgICAgICAqIGBgYFxyXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnRleHR1cmVzID0ge307XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQSBtYXAgY29udGFpbmluZyB0aGUgdGV4dHVyZXMgZm9yIGVhY2ggYW5pbWF0aW9uLlxyXG4gICAgICAgICAqIENhbiBiZSB1c2VkIHRvIGNyZWF0ZSBhbiB7QGxpbmsgUElYSS5BbmltYXRlZFNwcml0ZXxBbmltYXRlZFNwcml0ZX06XHJcbiAgICAgICAgICogYGBganNcclxuICAgICAgICAgKiBuZXcgUElYSS5BbmltYXRlZFNwcml0ZShzaGVldC5hbmltYXRpb25zW1wiYW5pbV9uYW1lXCJdKVxyXG4gICAgICAgICAqIGBgYFxyXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmFuaW1hdGlvbnMgPSB7fTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZWZlcmVuY2UgdG8gdGhlIG9yaWdpbmFsIEpTT04gZGF0YS5cclxuICAgICAgICAgKiBAdHlwZSB7T2JqZWN0fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIHJlc29sdXRpb24gb2YgdGhlIHNwcml0ZXNoZWV0LlxyXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5yZXNvbHV0aW9uID0gdGhpcy5fdXBkYXRlUmVzb2x1dGlvbihyZXNvbHV0aW9uRmlsZW5hbWVcclxuICAgICAgICAgICAgfHwgKHRoaXMuYmFzZVRleHR1cmUucmVzb3VyY2UgPyB0aGlzLmJhc2VUZXh0dXJlLnJlc291cmNlLnVybCA6IG51bGwpKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBNYXAgb2Ygc3ByaXRlc2hlZXQgZnJhbWVzLlxyXG4gICAgICAgICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLl9mcmFtZXMgPSB0aGlzLmRhdGEuZnJhbWVzO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbGxlY3Rpb24gb2YgZnJhbWUgbmFtZXMuXHJcbiAgICAgICAgICogQHR5cGUge3N0cmluZ1tdfVxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5fZnJhbWVLZXlzID0gT2JqZWN0LmtleXModGhpcy5fZnJhbWVzKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDdXJyZW50IGJhdGNoIGluZGV4IGJlaW5nIHByb2Nlc3NlZC5cclxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5fYmF0Y2hJbmRleCA9IDA7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2FsbGJhY2sgd2hlbiBwYXJzZSBpcyBjb21wbGV0ZWQuXHJcbiAgICAgICAgICogQHR5cGUge0Z1bmN0aW9ufVxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5fY2FsbGJhY2sgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgX3VwZGF0ZVJlc29sdXRpb24ocmVzb2x1dGlvbkZpbGVuYW1lKSB7XHJcbiAgICAgICAgdmFyIHNjYWxlID0gdGhpcy5kYXRhLm1ldGEuc2NhbGU7XHJcbiAgICAgICAgLy8gVXNlIGEgZGVmYXVsdFZhbHVlIG9mIGBudWxsYCB0byBjaGVjayBpZiBhIHVybC1iYXNlZCByZXNvbHV0aW9uIGlzIHNldFxyXG4gICAgICAgIHZhciByZXNvbHV0aW9uID0gTmV0d29ya1NldHRpbmdzXzEuTmV0d29ya1NldHRpbmdzLmdldFJlc29sdXRpb25PZlVybChyZXNvbHV0aW9uRmlsZW5hbWUsIG51bGwpO1xyXG4gICAgICAgIC8vIE5vIHJlc29sdXRpb24gZm91bmQgdmlhIFVSTFxyXG4gICAgICAgIGlmIChyZXNvbHV0aW9uID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIC8vIFVzZSB0aGUgc2NhbGUgdmFsdWUgb3IgZGVmYXVsdCB0byAxXHJcbiAgICAgICAgICAgIHJlc29sdXRpb24gPSBzY2FsZSAhPT0gdW5kZWZpbmVkID8gcGFyc2VGbG9hdChzY2FsZSkgOiAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBGb3Igbm9uLTEgcmVzb2x1dGlvbnMsIHVwZGF0ZSBiYXNlVGV4dHVyZVxyXG4gICAgICAgIGlmIChyZXNvbHV0aW9uICE9PSAxKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYmFzZVRleHR1cmUuc2V0UmVzb2x1dGlvbihyZXNvbHV0aW9uKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc29sdXRpb247XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIEdlbmVyYXRlIHRoZSByZXNvbHV0aW9uIGZyb20gdGhlIGZpbGVuYW1lIG9yIGZhbGxiYWNrXHJcbiAgICAgKiB0byB0aGUgbWV0YS5zY2FsZSBmaWVsZCBvZiB0aGUgSlNPTiBkYXRhLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcmVzb2x1dGlvbkZpbGVuYW1lIC0gVGhlIGZpbGVuYW1lIHRvIHVzZSBmb3IgcmVzb2x2aW5nXHJcbiAgICAgKiAgICB0aGUgZGVmYXVsdCByZXNvbHV0aW9uLlxyXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBSZXNvbHV0aW9uIHRvIHVzZSBmb3Igc3ByaXRlc2hlZXQuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBnZXQgQkFUQ0hfU0laRSgpIHtcclxuICAgICAgICByZXR1cm4gMTAwMDtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogUGFyc2VyIHNwcml0ZXNoZWV0IGZyb20gbG9hZGVkIGRhdGEuIFRoaXMgaXMgZG9uZSBhc3luY2hyb25vdXNseVxyXG4gICAgICogdG8gcHJldmVudCBjcmVhdGluZyB0b28gbWFueSBUZXh0dXJlIHdpdGhpbiBhIHNpbmdsZSBwcm9jZXNzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIC0gQ2FsbGJhY2sgd2hlbiBjb21wbGV0ZSByZXR1cm5zXHJcbiAgICAgKiAgICBhIG1hcCBvZiB0aGUgVGV4dHVyZXMgZm9yIHRoaXMgc3ByaXRlc2hlZXQuXHJcbiAgICAgKi9cclxuICAgIHBhcnNlKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgdGhpcy5fYmF0Y2hJbmRleCA9IDA7XHJcbiAgICAgICAgdGhpcy5fY2FsbGJhY2sgPSBjYWxsYmFjaztcclxuICAgICAgICBpZiAodGhpcy5fZnJhbWVLZXlzLmxlbmd0aCA8PSBTcHJpdGVzaGVldC5CQVRDSF9TSVpFKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3Byb2Nlc3NGcmFtZXMoMCk7XHJcbiAgICAgICAgICAgIHRoaXMuX3Byb2Nlc3NBbmltYXRpb25zKCk7XHJcbiAgICAgICAgICAgIHRoaXMuX3BhcnNlQ29tcGxldGUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuX25leHRCYXRjaCgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogUHJvY2VzcyBhIGJhdGNoIG9mIGZyYW1lc1xyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5pdGlhbEZyYW1lSW5kZXggLSBUaGUgaW5kZXggb2YgZnJhbWUgdG8gc3RhcnQuXHJcbiAgICAgKi9cclxuICAgIF9wcm9jZXNzRnJhbWVzKGluaXRpYWxGcmFtZUluZGV4KSB7XHJcbiAgICAgICAgdmFyIGZyYW1lSW5kZXggPSBpbml0aWFsRnJhbWVJbmRleDtcclxuICAgICAgICB2YXIgbWF4RnJhbWVzID0gU3ByaXRlc2hlZXQuQkFUQ0hfU0laRTtcclxuICAgICAgICB3aGlsZSAoZnJhbWVJbmRleCAtIGluaXRpYWxGcmFtZUluZGV4IDwgbWF4RnJhbWVzICYmIGZyYW1lSW5kZXggPCB0aGlzLl9mcmFtZUtleXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHZhciBpID0gdGhpcy5fZnJhbWVLZXlzW2ZyYW1lSW5kZXhdO1xyXG4gICAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuX2ZyYW1lc1tpXTtcclxuICAgICAgICAgICAgdmFyIHJlY3QgPSBkYXRhLmZyYW1lO1xyXG4gICAgICAgICAgICBpZiAocmVjdCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGZyYW1lID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIHZhciB0cmltID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIHZhciBzb3VyY2VTaXplID0gZGF0YS50cmltbWVkICE9PSBmYWxzZSAmJiBkYXRhLnNvdXJjZVNpemVcclxuICAgICAgICAgICAgICAgICAgICA/IGRhdGEuc291cmNlU2l6ZSA6IGRhdGEuZnJhbWU7XHJcbiAgICAgICAgICAgICAgICB2YXIgb3JpZyA9IG5ldyBSZWN0YW5nbGVfMS5SZWN0YW5nbGUoMCwgMCwgTWF0aC5mbG9vcihzb3VyY2VTaXplLncpIC8gdGhpcy5yZXNvbHV0aW9uLCBNYXRoLmZsb29yKHNvdXJjZVNpemUuaCkgLyB0aGlzLnJlc29sdXRpb24pO1xyXG4gICAgICAgICAgICAgICAgaWYgKGRhdGEucm90YXRlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZyYW1lID0gbmV3IFJlY3RhbmdsZV8xLlJlY3RhbmdsZShNYXRoLmZsb29yKHJlY3QueCkgLyB0aGlzLnJlc29sdXRpb24sIE1hdGguZmxvb3IocmVjdC55KSAvIHRoaXMucmVzb2x1dGlvbiwgTWF0aC5mbG9vcihyZWN0LmgpIC8gdGhpcy5yZXNvbHV0aW9uLCBNYXRoLmZsb29yKHJlY3QudykgLyB0aGlzLnJlc29sdXRpb24pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZnJhbWUgPSBuZXcgUmVjdGFuZ2xlXzEuUmVjdGFuZ2xlKE1hdGguZmxvb3IocmVjdC54KSAvIHRoaXMucmVzb2x1dGlvbiwgTWF0aC5mbG9vcihyZWN0LnkpIC8gdGhpcy5yZXNvbHV0aW9uLCBNYXRoLmZsb29yKHJlY3QudykgLyB0aGlzLnJlc29sdXRpb24sIE1hdGguZmxvb3IocmVjdC5oKSAvIHRoaXMucmVzb2x1dGlvbik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyAgQ2hlY2sgdG8gc2VlIGlmIHRoZSBzcHJpdGUgaXMgdHJpbW1lZFxyXG4gICAgICAgICAgICAgICAgaWYgKGRhdGEudHJpbW1lZCAhPT0gZmFsc2UgJiYgZGF0YS5zcHJpdGVTb3VyY2VTaXplKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJpbSA9IG5ldyBSZWN0YW5nbGVfMS5SZWN0YW5nbGUoTWF0aC5mbG9vcihkYXRhLnNwcml0ZVNvdXJjZVNpemUueCkgLyB0aGlzLnJlc29sdXRpb24sIE1hdGguZmxvb3IoZGF0YS5zcHJpdGVTb3VyY2VTaXplLnkpIC8gdGhpcy5yZXNvbHV0aW9uLCBNYXRoLmZsb29yKHJlY3QudykgLyB0aGlzLnJlc29sdXRpb24sIE1hdGguZmxvb3IocmVjdC5oKSAvIHRoaXMucmVzb2x1dGlvbik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRleHR1cmVzW2ldID0gbmV3IFRleHR1cmVfMS5UZXh0dXJlKHRoaXMuYmFzZVRleHR1cmUsIGZyYW1lLCBvcmlnLCB0cmltLCBkYXRhLnJvdGF0ZWQgPyAyIDogMCwgZGF0YS5hbmNob3IpO1xyXG4gICAgICAgICAgICAgICAgLy8gbGV0cyBhbHNvIGFkZCB0aGUgZnJhbWUgdG8gcGl4aSdzIGdsb2JhbCBjYWNoZSBmb3IgZnJvbUZyYW1lIGFuZCBmcm9tSW1hZ2UgZnVuY3Rpb25zXHJcbiAgICAgICAgICAgICAgICBUZXh0dXJlXzEuVGV4dHVyZS5hZGRUb0NhY2hlKHRoaXMudGV4dHVyZXNbaV0sIGkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZyYW1lSW5kZXgrKztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFBhcnNlIGFuaW1hdGlvbnMgY29uZmlnXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgX3Byb2Nlc3NBbmltYXRpb25zKCkge1xyXG4gICAgICAgIHZhciBhbmltYXRpb25zID0gdGhpcy5kYXRhLmFuaW1hdGlvbnMgfHwge307XHJcbiAgICAgICAgZm9yICh2YXIgYW5pbU5hbWUgaW4gYW5pbWF0aW9ucykge1xyXG4gICAgICAgICAgICB0aGlzLmFuaW1hdGlvbnNbYW5pbU5hbWVdID0gW107XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYW5pbWF0aW9uc1thbmltTmFtZV0ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBmcmFtZU5hbWUgPSBhbmltYXRpb25zW2FuaW1OYW1lXVtpXTtcclxuICAgICAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9uc1thbmltTmFtZV0ucHVzaCh0aGlzLnRleHR1cmVzW2ZyYW1lTmFtZV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgcGFyc2UgaGFzIGNvbXBsZXRlZC5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBfcGFyc2VDb21wbGV0ZSgpIHtcclxuICAgICAgICB2YXIgY2FsbGJhY2sgPSB0aGlzLl9jYWxsYmFjaztcclxuICAgICAgICB0aGlzLl9jYWxsYmFjayA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5fYmF0Y2hJbmRleCA9IDA7XHJcbiAgICAgICAgY2FsbGJhY2suY2FsbCh0aGlzLCB0aGlzLnRleHR1cmVzKTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQmVnaW4gdGhlIG5leHQgYmF0Y2ggb2YgdGV4dHVyZXMuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgX25leHRCYXRjaCgpIHtcclxuICAgICAgICB2YXIgdGhpcyQxID0gdGhpcztcclxuICAgICAgICB0aGlzLl9wcm9jZXNzRnJhbWVzKHRoaXMuX2JhdGNoSW5kZXggKiBTcHJpdGVzaGVldC5CQVRDSF9TSVpFKTtcclxuICAgICAgICB0aGlzLl9iYXRjaEluZGV4Kys7XHJcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzJDEuX2JhdGNoSW5kZXggKiBTcHJpdGVzaGVldC5CQVRDSF9TSVpFIDwgdGhpcyQxLl9mcmFtZUtleXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzJDEuX25leHRCYXRjaCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcyQxLl9wcm9jZXNzQW5pbWF0aW9ucygpO1xyXG4gICAgICAgICAgICAgICAgdGhpcyQxLl9wYXJzZUNvbXBsZXRlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LCAwKTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogRGVzdHJveSBTcHJpdGVzaGVldCBhbmQgZG9uJ3QgdXNlIGFmdGVyIHRoaXMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZGVzdHJveUJhc2U9ZmFsc2VdIFdoZXRoZXIgdG8gZGVzdHJveSB0aGUgYmFzZSB0ZXh0dXJlIGFzIHdlbGxcclxuICAgICAqL1xyXG4gICAgZGVzdHJveShkZXN0cm95QmFzZSkge1xyXG4gICAgICAgIGlmIChkZXN0cm95QmFzZSA9PT0gdm9pZCAwKSB7XHJcbiAgICAgICAgICAgIGRlc3Ryb3lCYXNlID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAodmFyIGkgaW4gdGhpcy50ZXh0dXJlcykge1xyXG4gICAgICAgICAgICB0aGlzLnRleHR1cmVzW2ldLmRlc3Ryb3koKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fZnJhbWVzID0gbnVsbDtcclxuICAgICAgICB0aGlzLl9mcmFtZUtleXMgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuZGF0YSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy50ZXh0dXJlcyA9IG51bGw7XHJcbiAgICAgICAgaWYgKGRlc3Ryb3lCYXNlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYmFzZVRleHR1cmUuZGVzdHJveSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmJhc2VUZXh0dXJlID0gbnVsbDtcclxuICAgIH1cclxuICAgIDtcclxufVxyXG5leHBvcnRzLlNwcml0ZXNoZWV0ID0gU3ByaXRlc2hlZXQ7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNsYXNzIFN0YWdlT3B0aW9ucyB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLnNoYXJlZExvYWRlciA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuZm9yY2VDYW52YXMgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnZpZXcgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuYW50aWFsaWFzID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5mb3JjZUZYQUEgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmF1dG9EZW5zaXR5ID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmF1dG9SZXNpemUgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMudHJhbnNwYXJlbnQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmJhY2tncm91bmRDb2xvciA9IDB4MDAwMDAwO1xyXG4gICAgICAgIHRoaXMuY2xlYXJCZWZvcmVSZW5kZXIgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuYXV0b1N0YXJ0ID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLnByZXNlcnZlRHJhd2luZ0J1ZmZlciA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMud2lkdGggPSAxMDI0O1xyXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gNzY4O1xyXG4gICAgICAgIHRoaXMucmVzb2x1dGlvbiA9IDE7XHJcbiAgICAgICAgdGhpcy5sZWdhY3kgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnJvdW5kUGl4ZWxzID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5zaGFyZWRUaWNrZXIgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmNvbnRleHQgPSBudWxsO1xyXG4gICAgICAgIHRoaXMucmVzaXplVG8gPSBudWxsO1xyXG4gICAgICAgIHRoaXMucG93ZXJQcmVmZXJlbmNlID0gXCJoaWdoLXBlcmZvcm1hbmNlXCI7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5TdGFnZU9wdGlvbnMgPSBTdGFnZU9wdGlvbnM7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IFBvbHlnb25fMSA9IHJlcXVpcmUoXCIuL1BvbHlnb25cIik7XHJcbmNvbnN0IE1hdGhTZXR0aW5nc18xID0gcmVxdWlyZShcIi4vTWF0aFNldHRpbmdzXCIpO1xyXG5jbGFzcyBTdGFyIGV4dGVuZHMgUG9seWdvbl8xLlBvbHlnb24ge1xyXG4gICAgY29uc3RydWN0b3IoeCwgeSwgcG9pbnRzLCByYWRpdXMsIGlubmVyUmFkaXVzLCByb3RhdGlvbikge1xyXG4gICAgICAgIGlubmVyUmFkaXVzID0gaW5uZXJSYWRpdXMgfHwgcmFkaXVzIC8gMjtcclxuICAgICAgICB2YXIgc3RhcnRBbmdsZSA9ICgtMSAqIE1hdGguUEkgLyAyKSArIHJvdGF0aW9uO1xyXG4gICAgICAgIHZhciBsZW4gPSBwb2ludHMgKiAyO1xyXG4gICAgICAgIHZhciBkZWx0YSA9IE1hdGhTZXR0aW5nc18xLk1hdGhTZXR0aW5ncy5QSV8yIC8gbGVuO1xyXG4gICAgICAgIHZhciBwb2x5Z29uID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgciA9IGkgJSAyID8gaW5uZXJSYWRpdXMgOiByYWRpdXM7XHJcbiAgICAgICAgICAgIHZhciBhbmdsZSA9IChpICogZGVsdGEpICsgc3RhcnRBbmdsZTtcclxuICAgICAgICAgICAgcG9seWdvbi5wdXNoKHggKyAociAqIE1hdGguY29zKGFuZ2xlKSksIHkgKyAociAqIE1hdGguc2luKGFuZ2xlKSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzdXBlcihwb2x5Z29uKTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLlN0YXIgPSBTdGFyO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBCbGVuZE1vZGVzU2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL0JsZW5kTW9kZXNTZXR0aW5nc1wiKTtcclxuY2xhc3MgU3RhdGUge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5kYXRhID0gMDtcclxuICAgICAgICB0aGlzLmJsZW5kTW9kZSA9IEJsZW5kTW9kZXNTZXR0aW5nc18xLkJsZW5kTW9kZXNTZXR0aW5ncy5CTEVORF9NT0RFUy5OT1JNQUw7XHJcbiAgICAgICAgdGhpcy5wb2x5Z29uT2Zmc2V0ID0gMDtcclxuICAgICAgICB0aGlzLmJsZW5kID0gdHJ1ZTtcclxuICAgICAgICAvLyAgdGhpcy5kZXB0aFRlc3QgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBY3RpdmF0ZXMgYmxlbmRpbmcgb2YgdGhlIGNvbXB1dGVkIGZyYWdtZW50IGNvbG9yIHZhbHVlc1xyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIGdldCBibGVuZCgpIHtcclxuICAgICAgICByZXR1cm4gISEodGhpcy5kYXRhICYgKDEgPDwgU3RhdGUuQkxFTkQpKTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIHNldCBibGVuZCh2YWx1ZSkge1xyXG4gICAgICAgIGlmICghISh0aGlzLmRhdGEgJiAoMSA8PCBTdGF0ZS5CTEVORCkpICE9PSB2YWx1ZSkge1xyXG4gICAgICAgICAgICB0aGlzLmRhdGEgXj0gKDEgPDwgU3RhdGUuQkxFTkQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQWN0aXZhdGVzIGFkZGluZyBhbiBvZmZzZXQgdG8gZGVwdGggdmFsdWVzIG9mIHBvbHlnb24ncyBmcmFnbWVudHNcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtib29sZWFufVxyXG4gICAgICogQGRlZmF1bHQgZmFsc2VcclxuICAgICAqL1xyXG4gICAgZ2V0IG9mZnNldHMoKSB7XHJcbiAgICAgICAgcmV0dXJuICEhKHRoaXMuZGF0YSAmICgxIDw8IFN0YXRlLk9GRlNFVCkpO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgc2V0IG9mZnNldHModmFsdWUpIHtcclxuICAgICAgICBpZiAoISEodGhpcy5kYXRhICYgKDEgPDwgU3RhdGUuT0ZGU0VUKSkgIT09IHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGF0YSBePSAoMSA8PCBTdGF0ZS5PRkZTRVQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQWN0aXZhdGVzIGN1bGxpbmcgb2YgcG9seWdvbnMuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7Ym9vbGVhbn1cclxuICAgICAqIEBkZWZhdWx0IGZhbHNlXHJcbiAgICAgKi9cclxuICAgIGdldCBjdWxsaW5nKCkge1xyXG4gICAgICAgIHJldHVybiAhISh0aGlzLmRhdGEgJiAoMSA8PCBTdGF0ZS5DVUxMSU5HKSk7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICBzZXQgY3VsbGluZyh2YWx1ZSkge1xyXG4gICAgICAgIGlmICghISh0aGlzLmRhdGEgJiAoMSA8PCBTdGF0ZS5DVUxMSU5HKSkgIT09IHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGF0YSBePSAoMSA8PCBTdGF0ZS5DVUxMSU5HKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIEFjdGl2YXRlcyBkZXB0aCBjb21wYXJpc29ucyBhbmQgdXBkYXRlcyB0byB0aGUgZGVwdGggYnVmZmVyLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XHJcbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxyXG4gICAgICovXHJcbiAgICBnZXQgZGVwdGhUZXN0KCkge1xyXG4gICAgICAgIHJldHVybiAhISh0aGlzLmRhdGEgJiAoMSA8PCBTdGF0ZS5ERVBUSF9URVNUKSk7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICBzZXQgZGVwdGhUZXN0KHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKCEhKHRoaXMuZGF0YSAmICgxIDw8IFN0YXRlLkRFUFRIX1RFU1QpKSAhPT0gdmFsdWUpIHtcclxuICAgICAgICAgICAgdGhpcy5kYXRhIF49ICgxIDw8IFN0YXRlLkRFUFRIX1RFU1QpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IGZyb250IG9yIGJhY2stZmFjaW5nIHBvbHlnb25zIGNhbiBiZSBjdWxsZWQuXHJcbiAgICAgKiBAbWVtYmVyIHtib29sZWFufVxyXG4gICAgICogQGRlZmF1bHQgZmFsc2VcclxuICAgICAqL1xyXG4gICAgZ2V0IGNsb2Nrd2lzZUZyb250RmFjZSgpIHtcclxuICAgICAgICByZXR1cm4gISEodGhpcy5kYXRhICYgKDEgPDwgU3RhdGUuV0lORElORykpO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgc2V0IGNsb2Nrd2lzZUZyb250RmFjZSh2YWx1ZSkge1xyXG4gICAgICAgIGlmICghISh0aGlzLmRhdGEgJiAoMSA8PCBTdGF0ZS5XSU5ESU5HKSkgIT09IHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGF0YSBePSAoMSA8PCBTdGF0ZS5XSU5ESU5HKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBibGVuZCBtb2RlIHRvIGJlIGFwcGxpZWQgd2hlbiB0aGlzIHN0YXRlIGlzIHNldC4gQXBwbHkgYSB2YWx1ZSBvZiBgUElYSS5CTEVORF9NT0RFUy5OT1JNQUxgIHRvIHJlc2V0IHRoZSBibGVuZCBtb2RlLlxyXG4gICAgICogU2V0dGluZyB0aGlzIG1vZGUgdG8gYW55dGhpbmcgb3RoZXIgdGhhbiBOT19CTEVORCB3aWxsIGF1dG9tYXRpY2FsbHkgc3dpdGNoIGJsZW5kaW5nIG9uLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XHJcbiAgICAgKiBAZGVmYXVsdCBQSVhJLkJMRU5EX01PREVTLk5PUk1BTFxyXG4gICAgICogQHNlZSBQSVhJLkJMRU5EX01PREVTXHJcbiAgICAgKi9cclxuICAgIGdldCBibGVuZE1vZGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2JsZW5kTW9kZTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIHNldCBibGVuZE1vZGUodmFsdWUpIHtcclxuICAgICAgICB0aGlzLmJsZW5kID0gKHZhbHVlICE9PSBCbGVuZE1vZGVzU2V0dGluZ3NfMS5CbGVuZE1vZGVzU2V0dGluZ3MuQkxFTkRfTU9ERVMuTk9ORSk7XHJcbiAgICAgICAgdGhpcy5fYmxlbmRNb2RlID0gdmFsdWU7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBwb2x5Z29uIG9mZnNldC4gU2V0dGluZyB0aGlzIHByb3BlcnR5IHRvIGFueXRoaW5nIG90aGVyIHRoYW4gMCB3aWxsIGF1dG9tYXRpY2FsbHkgZW5hYmxlIHBvbHlnb24gb2Zmc2V0IGZpbGwuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICogQGRlZmF1bHQgMFxyXG4gICAgICovXHJcbiAgICBnZXQgcG9seWdvbk9mZnNldCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcG9seWdvbk9mZnNldDtcclxuICAgIH1cclxuICAgIDtcclxuICAgIHNldCBwb2x5Z29uT2Zmc2V0KHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5vZmZzZXRzID0gISF2YWx1ZTtcclxuICAgICAgICB0aGlzLl9wb2x5Z29uT2Zmc2V0ID0gdmFsdWU7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICBzdGF0aWMgZm9yMmQoKSB7XHJcbiAgICAgICAgdmFyIHN0YXRlID0gbmV3IFN0YXRlKCk7XHJcbiAgICAgICAgc3RhdGUuZGVwdGhUZXN0ID0gZmFsc2U7XHJcbiAgICAgICAgc3RhdGUuYmxlbmQgPSB0cnVlO1xyXG4gICAgICAgIHJldHVybiBzdGF0ZTtcclxuICAgIH1cclxuICAgIDtcclxufVxyXG5TdGF0ZS5CTEVORCA9IDA7XHJcblN0YXRlLk9GRlNFVCA9IDE7XHJcblN0YXRlLkNVTExJTkcgPSAyO1xyXG5TdGF0ZS5ERVBUSF9URVNUID0gMztcclxuU3RhdGUuV0lORElORyA9IDQ7XHJcbmV4cG9ydHMuU3RhdGUgPSBTdGF0ZTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgU3lzdGVtXzEgPSByZXF1aXJlKFwiLi9TeXN0ZW1cIik7XHJcbmNvbnN0IFN0YXRlXzEgPSByZXF1aXJlKFwiLi9TdGF0ZVwiKTtcclxuY29uc3QgQmxlbmRNb2Rlc1NldHRpbmdzXzEgPSByZXF1aXJlKFwiLi9CbGVuZE1vZGVzU2V0dGluZ3NcIik7XHJcbmNsYXNzIFN0YXRlU3lzdGVtIGV4dGVuZHMgU3lzdGVtXzEuU3lzdGVtIHtcclxuICAgIGNvbnN0cnVjdG9yKHJlbmRlcmVyKSB7XHJcbiAgICAgICAgc3VwZXIocmVuZGVyZXIpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdMIGNvbnRleHRcclxuICAgICAgICAgKiBAbWVtYmVyIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9XHJcbiAgICAgICAgICogQHJlYWRvbmx5XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5nbCA9IG51bGw7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU3RhdGUgSURcclxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgICAgICogQHJlYWRvbmx5XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5zdGF0ZUlkID0gMDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBQb2x5Z29uIG9mZnNldFxyXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAgICAgKiBAcmVhZG9ubHlcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnBvbHlnb25PZmZzZXQgPSAwO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEJsZW5kIG1vZGVcclxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgICAgICogQGRlZmF1bHQgUElYSS5CTEVORF9NT0RFUy5OT05FXHJcbiAgICAgICAgICogQHJlYWRvbmx5XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5ibGVuZE1vZGUgPSBCbGVuZE1vZGVzU2V0dGluZ3NfMS5CbGVuZE1vZGVzU2V0dGluZ3MuQkxFTkRfTU9ERVMuTk9ORTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBXaGV0aGVyIGN1cnJlbnQgYmxlbmQgZXF1YXRpb24gaXMgZGlmZmVyZW50XHJcbiAgICAgICAgICogQG1lbWJlciB7Ym9vbGVhbn1cclxuICAgICAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5fYmxlbmRFcSA9IGZhbHNlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbGxlY3Rpb24gb2YgY2FsbHNcclxuICAgICAgICAgKiBAbWVtYmVyIHtmdW5jdGlvbltdfVxyXG4gICAgICAgICAqIEByZWFkb25seVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMubWFwID0gW107XHJcbiAgICAgICAgLy8gbWFwIGZ1bmN0aW9ucyBmb3Igd2hlbiB3ZSBzZXQgc3RhdGUuLlxyXG4gICAgICAgIHRoaXMubWFwW1N0YXRlU3lzdGVtLkJMRU5EJDFdID0gdGhpcy5zZXRCbGVuZDtcclxuICAgICAgICB0aGlzLm1hcFtTdGF0ZVN5c3RlbS5PRkZTRVQkMV0gPSB0aGlzLnNldE9mZnNldDtcclxuICAgICAgICB0aGlzLm1hcFtTdGF0ZVN5c3RlbS5DVUxMSU5HJDFdID0gdGhpcy5zZXRDdWxsRmFjZTtcclxuICAgICAgICB0aGlzLm1hcFtTdGF0ZVN5c3RlbS5ERVBUSF9URVNUJDFdID0gdGhpcy5zZXREZXB0aFRlc3Q7XHJcbiAgICAgICAgdGhpcy5tYXBbU3RhdGVTeXN0ZW0uV0lORElORyQxXSA9IHRoaXMuc2V0RnJvbnRGYWNlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbGxlY3Rpb24gb2YgY2hlY2sgY2FsbHNcclxuICAgICAgICAgKiBAbWVtYmVyIHtmdW5jdGlvbltdfVxyXG4gICAgICAgICAqIEByZWFkb25seVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuY2hlY2tzID0gW107XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRGVmYXVsdCBXZWJHTCBTdGF0ZVxyXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuU3RhdGV9XHJcbiAgICAgICAgICogQHJlYWRvbmx5XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5kZWZhdWx0U3RhdGUgPSBuZXcgU3RhdGVfMS5TdGF0ZSgpO1xyXG4gICAgICAgIHRoaXMuZGVmYXVsdFN0YXRlLmJsZW5kID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmRlZmF1bHRTdGF0ZS5kZXB0aCA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBjb250ZXh0Q2hhbmdlKGdsKSB7XHJcbiAgICAgICAgdGhpcy5nbCA9IGdsO1xyXG4gICAgICAgIHRoaXMuYmxlbmRNb2RlcyA9IEJsZW5kTW9kZXNTZXR0aW5nc18xLkJsZW5kTW9kZXNTZXR0aW5ncy5tYXBXZWJHTEJsZW5kTW9kZXNUb1BpeGkoZ2wpO1xyXG4gICAgICAgIHRoaXMuc2V0U3RhdGUodGhpcy5kZWZhdWx0U3RhdGUpO1xyXG4gICAgICAgIHRoaXMucmVzZXQoKTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgY3VycmVudCBzdGF0ZVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7Kn0gc3RhdGUgLSBUaGUgc3RhdGUgdG8gc2V0LlxyXG4gICAgICovXHJcbiAgICBzZXRTdGF0ZShzdGF0ZSkge1xyXG4gICAgICAgIHN0YXRlID0gc3RhdGUgfHwgdGhpcy5kZWZhdWx0U3RhdGU7XHJcbiAgICAgICAgLy8gVE9ETyBtYXliZSB0byBhbiBvYmplY3QgY2hlY2s/ICggdGhpcy5zdGF0ZSA9PT0gc3RhdGUgKT9cclxuICAgICAgICBpZiAodGhpcy5zdGF0ZUlkICE9PSBzdGF0ZS5kYXRhKSB7XHJcbiAgICAgICAgICAgIHZhciBkaWZmID0gdGhpcy5zdGF0ZUlkIF4gc3RhdGUuZGF0YTtcclxuICAgICAgICAgICAgdmFyIGkgPSAwO1xyXG4gICAgICAgICAgICAvLyBvcmRlciBmcm9tIGxlYXN0IHRvIG1vc3QgY29tbW9uXHJcbiAgICAgICAgICAgIHdoaWxlIChkaWZmKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZGlmZiAmIDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBzdGF0ZSBjaGFuZ2UhXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXBbaV0uY2FsbCh0aGlzLCAhIShzdGF0ZS5kYXRhICYgKDEgPDwgaSkpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGRpZmYgPSBkaWZmID4+IDE7XHJcbiAgICAgICAgICAgICAgICBpKys7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5zdGF0ZUlkID0gc3RhdGUuZGF0YTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gYmFzZWQgb24gdGhlIGFib3ZlIHNldHRpbmdzIHdlIGNoZWNrIGZvciBzcGVjaWZpYyBtb2Rlcy4uXHJcbiAgICAgICAgLy8gZm9yIGV4YW1wbGUgaWYgYmxlbmQgaXMgYWN0aXZlIHdlIGNoZWNrIGFuZCBzZXQgdGhlIGJsZW5kIG1vZGVzXHJcbiAgICAgICAgLy8gb3Igb2YgcG9seWdvbiBvZmZzZXQgaXMgYWN0aXZlIHdlIGNoZWNrIHRoZSBwb2x5IGRlcHRoLlxyXG4gICAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IHRoaXMuY2hlY2tzLmxlbmd0aDsgaSQxKyspIHtcclxuICAgICAgICAgICAgdGhpcy5jaGVja3NbaSQxXSh0aGlzLCBzdGF0ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBzdGF0ZSwgd2hlbiBwcmV2aW91cyBzdGF0ZSBpcyB1bmtub3duXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHsqfSBzdGF0ZSAtIFRoZSBzdGF0ZSB0byBzZXRcclxuICAgICAqL1xyXG4gICAgZm9yY2VTdGF0ZShzdGF0ZSkge1xyXG4gICAgICAgIHN0YXRlID0gc3RhdGUgfHwgdGhpcy5kZWZhdWx0U3RhdGU7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm1hcC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB0aGlzLm1hcFtpXS5jYWxsKHRoaXMsICEhKHN0YXRlLmRhdGEgJiAoMSA8PCBpKSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCB0aGlzLmNoZWNrcy5sZW5ndGg7IGkkMSsrKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2hlY2tzW2kkMV0odGhpcywgc3RhdGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnN0YXRlSWQgPSBzdGF0ZS5kYXRhO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBFbmFibGVzIG9yIGRpc2FibGVkIGJsZW5kaW5nLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gdmFsdWUgLSBUdXJuIG9uIG9yIG9mZiB3ZWJnbCBibGVuZGluZy5cclxuICAgICAqL1xyXG4gICAgc2V0QmxlbmQodmFsdWUpIHtcclxuICAgICAgICB0aGlzLnVwZGF0ZUNoZWNrKFN0YXRlU3lzdGVtLmNoZWNrQmxlbmRNb2RlLCB2YWx1ZSk7XHJcbiAgICAgICAgdGhpcy5nbFt2YWx1ZSA/ICdlbmFibGUnIDogJ2Rpc2FibGUnXSh0aGlzLmdsLkJMRU5EKTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogRW5hYmxlcyBvciBkaXNhYmxlIHBvbHlnb24gb2Zmc2V0IGZpbGxcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHZhbHVlIC0gVHVybiBvbiBvciBvZmYgd2ViZ2wgcG9seWdvbiBvZmZzZXQgdGVzdGluZy5cclxuICAgICAqL1xyXG4gICAgc2V0T2Zmc2V0KHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5nbFt2YWx1ZSA/ICdlbmFibGUnIDogJ2Rpc2FibGUnXSh0aGlzLmdsLlBPTFlHT05fT0ZGU0VUX0ZJTEwpO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHdoZXRoZXIgdG8gZW5hYmxlIG9yIGRpc2FibGUgZGVwdGggdGVzdC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHZhbHVlIC0gVHVybiBvbiBvciBvZmYgd2ViZ2wgZGVwdGggdGVzdGluZy5cclxuICAgICAqL1xyXG4gICAgc2V0RGVwdGhUZXN0KHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5nbFt2YWx1ZSA/ICdlbmFibGUnIDogJ2Rpc2FibGUnXSh0aGlzLmdsLkRFUFRIX1RFU1QpO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHdoZXRoZXIgdG8gZW5hYmxlIG9yIGRpc2FibGUgY3VsbCBmYWNlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gdmFsdWUgLSBUdXJuIG9uIG9yIG9mZiB3ZWJnbCBjdWxsIGZhY2UuXHJcbiAgICAgKi9cclxuICAgIHNldEN1bGxGYWNlKHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5nbFt2YWx1ZSA/ICdlbmFibGUnIDogJ2Rpc2FibGUnXSh0aGlzLmdsLkNVTExfRkFDRSk7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIGdsIGZyb250IGZhY2UuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSB2YWx1ZSAtIHRydWUgaXMgY2xvY2t3aXNlIGFuZCBmYWxzZSBpcyBjb3VudGVyLWNsb2Nrd2lzZVxyXG4gICAgICovXHJcbiAgICBzZXRGcm9udEZhY2UodmFsdWUpIHtcclxuICAgICAgICB0aGlzLmdsLmZyb250RmFjZSh0aGlzLmdsW3ZhbHVlID8gJ0NXJyA6ICdDQ1cnXSk7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIGJsZW5kIG1vZGUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIC0gVGhlIGJsZW5kIG1vZGUgdG8gc2V0IHRvLlxyXG4gICAgICovXHJcbiAgICBzZXRCbGVuZE1vZGUodmFsdWUpIHtcclxuICAgICAgICBpZiAodmFsdWUgPT09IHRoaXMuYmxlbmRNb2RlKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5ibGVuZE1vZGUgPSB2YWx1ZTtcclxuICAgICAgICB2YXIgbW9kZSA9IHRoaXMuYmxlbmRNb2Rlc1t2YWx1ZV07XHJcbiAgICAgICAgdmFyIGdsID0gdGhpcy5nbDtcclxuICAgICAgICBpZiAobW9kZS5sZW5ndGggPT09IDIpIHtcclxuICAgICAgICAgICAgZ2wuYmxlbmRGdW5jKG1vZGVbMF0sIG1vZGVbMV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZ2wuYmxlbmRGdW5jU2VwYXJhdGUobW9kZVswXSwgbW9kZVsxXSwgbW9kZVsyXSwgbW9kZVszXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChtb2RlLmxlbmd0aCA9PT0gNikge1xyXG4gICAgICAgICAgICB0aGlzLl9ibGVuZEVxID0gdHJ1ZTtcclxuICAgICAgICAgICAgZ2wuYmxlbmRFcXVhdGlvblNlcGFyYXRlKG1vZGVbNF0sIG1vZGVbNV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLl9ibGVuZEVxKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2JsZW5kRXEgPSBmYWxzZTtcclxuICAgICAgICAgICAgZ2wuYmxlbmRFcXVhdGlvblNlcGFyYXRlKGdsLkZVTkNfQURELCBnbC5GVU5DX0FERCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBwb2x5Z29uIG9mZnNldC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgLSB0aGUgcG9seWdvbiBvZmZzZXRcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzY2FsZSAtIHRoZSBwb2x5Z29uIG9mZnNldCBzY2FsZVxyXG4gICAgICovXHJcbiAgICBzZXRQb2x5Z29uT2Zmc2V0KHZhbHVlLCBzY2FsZSkge1xyXG4gICAgICAgIHRoaXMuZ2wucG9seWdvbk9mZnNldCh2YWx1ZSwgc2NhbGUpO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLy8gdXNlZFxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXNldHMgYWxsIHRoZSBsb2dpYyBhbmQgZGlzYWJsZXMgdGhlIHZhb3NcclxuICAgICAqL1xyXG4gICAgcmVzZXQoKSB7XHJcbiAgICAgICAgdGhpcy5nbC5waXhlbFN0b3JlaSh0aGlzLmdsLlVOUEFDS19GTElQX1lfV0VCR0wsIGZhbHNlKTtcclxuICAgICAgICB0aGlzLmZvcmNlU3RhdGUoMCk7XHJcbiAgICAgICAgdGhpcy5fYmxlbmRFcSA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5ibGVuZE1vZGUgPSAtMTtcclxuICAgICAgICB0aGlzLnNldEJsZW5kTW9kZSgwKTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogY2hlY2tzIHRvIHNlZSB3aGljaCB1cGRhdGVzIHNob3VsZCBiZSBjaGVja2VkIGJhc2VkIG9uIHdoaWNoIHNldHRpbmdzIGhhdmUgYmVlbiBhY3RpdmF0ZWQuXHJcbiAgICAgKiBGb3IgZXhhbXBsZSwgaWYgYmxlbmQgaXMgZW5hYmxlZCB0aGVuIHdlIHNob3VsZCBjaGVjayB0aGUgYmxlbmQgbW9kZXMgZWFjaCB0aW1lIHRoZSBzdGF0ZSBpcyBjaGFuZ2VkXHJcbiAgICAgKiBvciBpZiBwb2x5Z29uIGZpbGwgaXMgYWN0aXZhdGVkIHRoZW4gd2UgbmVlZCB0byBjaGVjayBpZiB0aGUgcG9seWdvbiBvZmZzZXQgY2hhbmdlcy5cclxuICAgICAqIFRoZSBpZGVhIGlzIHRoYXQgd2Ugb25seSBjaGVjayB3aGF0IHdlIGhhdmUgdG9vLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgIHRoZSBjaGVja2luZyBmdW5jdGlvbiB0byBhZGQgb3IgcmVtb3ZlXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHZhbHVlICBzaG91bGQgdGhlIGNoZWNrIGZ1bmN0aW9uIGJlIGFkZGVkIG9yIHJlbW92ZWQuXHJcbiAgICAgKi9cclxuICAgIHVwZGF0ZUNoZWNrKGZ1bmMsIHZhbHVlKSB7XHJcbiAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5jaGVja3MuaW5kZXhPZihmdW5jKTtcclxuICAgICAgICBpZiAodmFsdWUgJiYgaW5kZXggPT09IC0xKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2hlY2tzLnB1c2goZnVuYyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKCF2YWx1ZSAmJiBpbmRleCAhPT0gLTEpIHtcclxuICAgICAgICAgICAgdGhpcy5jaGVja3Muc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIEEgcHJpdmF0ZSBsaXR0bGUgd3JhcHBlciBmdW5jdGlvbiB0aGF0IHdlIGNhbGwgdG8gY2hlY2sgdGhlIGJsZW5kIG1vZGUuXHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7UElYSS5TdGF0ZVN5c3RlbX0gU3lzdGVtICB0aGUgU3lzdGVtIHRvIHBlcmZvcm0gdGhlIHN0YXRlIGNoZWNrIG9uXHJcbiAgICAgKiBAcGFyYW0ge1BJWEkuU3RhdGV9IHN0YXRlICB0aGUgc3RhdGUgdGhhdCB0aGUgYmxlbmRNb2RlIHdpbGwgcHVsbGVkIGZyb21cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGNoZWNrQmxlbmRNb2RlKHN5c3RlbSwgc3RhdGUpIHtcclxuICAgICAgICBzeXN0ZW0uc2V0QmxlbmRNb2RlKHN0YXRlLmJsZW5kTW9kZSk7XHJcbiAgICB9XHJcbiAgICA7XHJcbn1cclxuU3RhdGVTeXN0ZW0uVUlEJDQgPSAwO1xyXG5TdGF0ZVN5c3RlbS5CTEVORCQxID0gMDtcclxuU3RhdGVTeXN0ZW0uT0ZGU0VUJDEgPSAxO1xyXG5TdGF0ZVN5c3RlbS5DVUxMSU5HJDEgPSAyO1xyXG5TdGF0ZVN5c3RlbS5ERVBUSF9URVNUJDEgPSAzO1xyXG5TdGF0ZVN5c3RlbS5XSU5ESU5HJDEgPSA0O1xyXG5leHBvcnRzLlN0YXRlU3lzdGVtID0gU3RhdGVTeXN0ZW07XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IFN5c3RlbV8xID0gcmVxdWlyZShcIi4vU3lzdGVtXCIpO1xyXG5jbGFzcyBTdGVuY2lsU3lzdGVtIGV4dGVuZHMgU3lzdGVtXzEuU3lzdGVtIHtcclxuICAgIGNvbnN0cnVjdG9yKHJlbmRlcmVyKSB7XHJcbiAgICAgICAgc3VwZXIocmVuZGVyZXIpO1xyXG4gICAgICAgIHRoaXMuc3RlbmNpbE1hc2tTdGFjayA9IFtdO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGFuZ2VzIHRoZSBtYXNrIHN0YWNrIHRoYXQgaXMgdXNlZCBieSB0aGlzIFN5c3RlbS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1BJWEkuR3JhcGhpY3NbXX0gc3RlbmNpbE1hc2tTdGFjayAtIFRoZSBtYXNrIHN0YWNrXHJcbiAgICAgKi9cclxuICAgIHNldE1hc2tTdGFjayhzdGVuY2lsTWFza1N0YWNrKSB7XHJcbiAgICAgICAgdmFyIGdsID0gdGhpcy5yZW5kZXJlci5nbDtcclxuICAgICAgICBpZiAoc3RlbmNpbE1hc2tTdGFjay5sZW5ndGggIT09IHRoaXMuc3RlbmNpbE1hc2tTdGFjay5sZW5ndGgpIHtcclxuICAgICAgICAgICAgaWYgKHN0ZW5jaWxNYXNrU3RhY2subGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBnbC5kaXNhYmxlKGdsLlNURU5DSUxfVEVTVCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBnbC5lbmFibGUoZ2wuU1RFTkNJTF9URVNUKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnN0ZW5jaWxNYXNrU3RhY2sgPSBzdGVuY2lsTWFza1N0YWNrO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBsaWVzIHRoZSBNYXNrIGFuZCBhZGRzIGl0IHRvIHRoZSBjdXJyZW50IHN0ZW5jaWwgc3RhY2suIEBhbHZpblxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7UElYSS5HcmFwaGljc30gZ3JhcGhpY3MgLSBUaGUgbWFza1xyXG4gICAgICovXHJcbiAgICBwdXNoU3RlbmNpbChncmFwaGljcykge1xyXG4gICAgICAgIHZhciBnbCA9IHRoaXMucmVuZGVyZXIuZ2w7XHJcbiAgICAgICAgdmFyIHByZXZNYXNrQ291bnQgPSB0aGlzLnN0ZW5jaWxNYXNrU3RhY2subGVuZ3RoO1xyXG4gICAgICAgIGlmIChwcmV2TWFza0NvdW50ID09PSAwKSB7XHJcbiAgICAgICAgICAgIGdsLmVuYWJsZShnbC5TVEVOQ0lMX1RFU1QpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnN0ZW5jaWxNYXNrU3RhY2sucHVzaChncmFwaGljcyk7XHJcbiAgICAgICAgLy8gSW5jcmVtZW50IHRoZSByZWZlcmVuY2Ugc3RlbmNpbCB2YWx1ZSB3aGVyZSB0aGUgbmV3IG1hc2sgb3ZlcmxhcHMgd2l0aCB0aGUgb2xkIG9uZXMuXHJcbiAgICAgICAgZ2wuY29sb3JNYXNrKGZhbHNlLCBmYWxzZSwgZmFsc2UsIGZhbHNlKTtcclxuICAgICAgICBnbC5zdGVuY2lsRnVuYyhnbC5FUVVBTCwgcHJldk1hc2tDb3VudCwgdGhpcy5fZ2V0Qml0d2lzZU1hc2soKSk7XHJcbiAgICAgICAgZ2wuc3RlbmNpbE9wKGdsLktFRVAsIGdsLktFRVAsIGdsLklOQ1IpO1xyXG4gICAgICAgIGdyYXBoaWNzLnJlbmRlcmFibGUgPSB0cnVlO1xyXG4gICAgICAgIGdyYXBoaWNzLnJlbmRlcih0aGlzLnJlbmRlcmVyKTtcclxuICAgICAgICB0aGlzLnJlbmRlcmVyLmJhdGNoLmZsdXNoKCk7XHJcbiAgICAgICAgZ3JhcGhpY3MucmVuZGVyYWJsZSA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX3VzZUN1cnJlbnQoKTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyB0aGUgbGFzdCBtYXNrIGZyb20gdGhlIHN0ZW5jaWwgc3RhY2suIEBhbHZpblxyXG4gICAgICovXHJcbiAgICBwb3BTdGVuY2lsKCkge1xyXG4gICAgICAgIHZhciBnbCA9IHRoaXMucmVuZGVyZXIuZ2w7XHJcbiAgICAgICAgdmFyIGdyYXBoaWNzID0gdGhpcy5zdGVuY2lsTWFza1N0YWNrLnBvcCgpO1xyXG4gICAgICAgIGlmICh0aGlzLnN0ZW5jaWxNYXNrU3RhY2subGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIC8vIHRoZSBzdGFjayBpcyBlbXB0eSFcclxuICAgICAgICAgICAgZ2wuZGlzYWJsZShnbC5TVEVOQ0lMX1RFU1QpO1xyXG4gICAgICAgICAgICBnbC5jbGVhcihnbC5TVEVOQ0lMX0JVRkZFUl9CSVQpO1xyXG4gICAgICAgICAgICBnbC5jbGVhclN0ZW5jaWwoMCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBEZWNyZW1lbnQgdGhlIHJlZmVyZW5jZSBzdGVuY2lsIHZhbHVlIHdoZXJlIHRoZSBwb3BwZWQgbWFzayBvdmVybGFwcyB3aXRoIHRoZSBvdGhlciBvbmVzXHJcbiAgICAgICAgICAgIGdsLmNvbG9yTWFzayhmYWxzZSwgZmFsc2UsIGZhbHNlLCBmYWxzZSk7XHJcbiAgICAgICAgICAgIGdsLnN0ZW5jaWxPcChnbC5LRUVQLCBnbC5LRUVQLCBnbC5ERUNSKTtcclxuICAgICAgICAgICAgZ3JhcGhpY3MucmVuZGVyYWJsZSA9IHRydWU7XHJcbiAgICAgICAgICAgIGdyYXBoaWNzLnJlbmRlcih0aGlzLnJlbmRlcmVyKTtcclxuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5iYXRjaC5mbHVzaCgpO1xyXG4gICAgICAgICAgICBncmFwaGljcy5yZW5kZXJhYmxlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuX3VzZUN1cnJlbnQoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFNldHVwIHJlbmRlcmVyIHRvIHVzZSB0aGUgY3VycmVudCBzdGVuY2lsIGRhdGEuXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBfdXNlQ3VycmVudCgpIHtcclxuICAgICAgICB2YXIgZ2wgPSB0aGlzLnJlbmRlcmVyLmdsO1xyXG4gICAgICAgIGdsLmNvbG9yTWFzayh0cnVlLCB0cnVlLCB0cnVlLCB0cnVlKTtcclxuICAgICAgICBnbC5zdGVuY2lsRnVuYyhnbC5FUVVBTCwgdGhpcy5zdGVuY2lsTWFza1N0YWNrLmxlbmd0aCwgdGhpcy5fZ2V0Qml0d2lzZU1hc2soKSk7XHJcbiAgICAgICAgZ2wuc3RlbmNpbE9wKGdsLktFRVAsIGdsLktFRVAsIGdsLktFRVApO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBGaWxsIDFzIGVxdWFsIHRvIHRoZSBudW1iZXIgb2YgYWNpdHZlIHN0ZW5jaWwgbWFza3MuXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgYml0d2lzZSBtYXNrLlxyXG4gICAgICovXHJcbiAgICBfZ2V0Qml0d2lzZU1hc2soKSB7XHJcbiAgICAgICAgcmV0dXJuICgxIDw8IHRoaXMuc3RlbmNpbE1hc2tTdGFjay5sZW5ndGgpIC0gMTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogRGVzdHJveXMgdGhlIG1hc2sgc3RhY2suXHJcbiAgICAgKlxyXG4gICAgICovXHJcbiAgICBkZXN0cm95KCkge1xyXG4gICAgICAgIHN1cGVyLmRlc3Ryb3koKTtcclxuICAgICAgICB0aGlzLnN0ZW5jaWxNYXNrU3RhY2sgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgO1xyXG59XHJcbmV4cG9ydHMuU3RlbmNpbFN5c3RlbSA9IFN0ZW5jaWxTeXN0ZW07XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IEV2ZW50RGlzcGF0Y2hlcl8xID0gcmVxdWlyZShcIi4vRXZlbnREaXNwYXRjaGVyXCIpO1xyXG5jbGFzcyBTeXN0ZW0gZXh0ZW5kcyBFdmVudERpc3BhdGNoZXJfMS5FdmVudERpc3BhdGNoZXIge1xyXG4gICAgY29uc3RydWN0b3IocmVuZGVyZXIgPSBudWxsKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJlci5ydW5uZXJzLmNvbnRleHRDaGFuZ2UuYWRkKHRoaXMpO1xyXG4gICAgfVxyXG4gICAgY29udGV4dENoYW5nZShnbCkge1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgZGVzdHJveShvcHRpb25zID0gbnVsbCkge1xyXG4gICAgICAgIHRoaXMucmVuZGVyZXIucnVubmVycy5jb250ZXh0Q2hhbmdlLnJlbW92ZSh0aGlzKTtcclxuICAgICAgICB0aGlzLnJlbmRlcmVyID0gbnVsbDtcclxuICAgIH1cclxuICAgIDtcclxufVxyXG5leHBvcnRzLlN5c3RlbSA9IFN5c3RlbTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgU3ByaXRlXzEgPSByZXF1aXJlKFwiLi9TcHJpdGVcIik7XHJcbmNvbnN0IFRleHR1cmVfMSA9IHJlcXVpcmUoXCIuL1RleHR1cmVcIik7XHJcbmNvbnN0IFJlY3RhbmdsZV8xID0gcmVxdWlyZShcIi4vUmVjdGFuZ2xlXCIpO1xyXG5jb25zdCBUZXh0TWV0cmljc18xID0gcmVxdWlyZShcIi4vVGV4dE1ldHJpY3NcIik7XHJcbmNvbnN0IFRleHRTdHlsZV8xID0gcmVxdWlyZShcIi4vVGV4dFN0eWxlXCIpO1xyXG5jb25zdCBEaXNwbGF5U2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL0Rpc3BsYXlTZXR0aW5nc1wiKTtcclxuY29uc3QgTWF0aFNldHRpbmdzXzEgPSByZXF1aXJlKFwiLi9NYXRoU2V0dGluZ3NcIik7XHJcbmNvbnN0IENhbnZhc1NldHRpbmdzXzEgPSByZXF1aXJlKFwiLi9DYW52YXNTZXR0aW5nc1wiKTtcclxuY29uc3QgVGV4dFNldHRpbmdzXzEgPSByZXF1aXJlKFwiLi9UZXh0U2V0dGluZ3NcIik7XHJcbmNvbnN0IENsZWFuVXBTZXR0aW5nc18xID0gcmVxdWlyZShcIi4vQ2xlYW5VcFNldHRpbmdzXCIpO1xyXG5jb25zdCBDb2xvclNldHRpbmdzXzEgPSByZXF1aXJlKFwiLi9Db2xvclNldHRpbmdzXCIpO1xyXG5jbGFzcyBUZXh0IGV4dGVuZHMgU3ByaXRlXzEuU3ByaXRlIHtcclxuICAgIGNvbnN0cnVjdG9yKHRleHQsIHN0eWxlID0gbnVsbCwgY2FudmFzID0gbnVsbCkge1xyXG4gICAgICAgIGNhbnZhcyA9IGNhbnZhcyB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcclxuICAgICAgICBjYW52YXMud2lkdGggPSAzO1xyXG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSAzO1xyXG4gICAgICAgIHZhciB0ZXh0dXJlID0gVGV4dHVyZV8xLlRleHR1cmUuZnJvbShjYW52YXMpO1xyXG4gICAgICAgIHRleHR1cmUub3JpZyA9IG5ldyBSZWN0YW5nbGVfMS5SZWN0YW5nbGUoKTtcclxuICAgICAgICB0ZXh0dXJlLnRyaW0gPSBuZXcgUmVjdGFuZ2xlXzEuUmVjdGFuZ2xlKCk7XHJcbiAgICAgICAgc3VwZXIodGV4dHVyZSk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGNhbnZhcyBlbGVtZW50IHRoYXQgZXZlcnl0aGluZyBpcyBkcmF3biB0b1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQG1lbWJlciB7SFRNTENhbnZhc0VsZW1lbnR9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5jYW52YXMgPSBjYW52YXM7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGNhbnZhcyAyZCBjb250ZXh0IHRoYXQgZXZlcnl0aGluZyBpcyBkcmF3biB3aXRoXHJcbiAgICAgICAgICogQG1lbWJlciB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuY29udGV4dCA9IHRoaXMuY2FudmFzLmdldENvbnRleHQoJzJkJyk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIHJlc29sdXRpb24gLyBkZXZpY2UgcGl4ZWwgcmF0aW8gb2YgdGhlIGNhbnZhcy5cclxuICAgICAgICAgKiBUaGlzIGlzIHNldCB0byBhdXRvbWF0aWNhbGx5IG1hdGNoIHRoZSByZW5kZXJlciByZXNvbHV0aW9uIGJ5IGRlZmF1bHQsIGJ1dCBjYW4gYmUgb3ZlcnJpZGRlbiBieSBzZXR0aW5nIG1hbnVhbGx5LlxyXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAgICAgKiBAZGVmYXVsdCAxXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5fcmVzb2x1dGlvbiA9IERpc3BsYXlTZXR0aW5nc18xLkRpc3BsYXlTZXR0aW5ncy5SRVNPTFVUSU9OO1xyXG4gICAgICAgIHRoaXMuX2F1dG9SZXNvbHV0aW9uID0gdHJ1ZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBQcml2YXRlIHRyYWNrZXIgZm9yIHRoZSBjdXJyZW50IHRleHQuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAbWVtYmVyIHtzdHJpbmd9XHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLl90ZXh0ID0gbnVsbDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBQcml2YXRlIHRyYWNrZXIgZm9yIHRoZSBjdXJyZW50IHN0eWxlLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQG1lbWJlciB7b2JqZWN0fVxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5fc3R5bGUgPSBudWxsO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFByaXZhdGUgbGlzdGVuZXIgdG8gdHJhY2sgc3R5bGUgY2hhbmdlcy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBtZW1iZXIge0Z1bmN0aW9ufVxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5fc3R5bGVMaXN0ZW5lciA9IG51bGw7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUHJpdmF0ZSB0cmFja2VyIGZvciB0aGUgY3VycmVudCBmb250LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQG1lbWJlciB7c3RyaW5nfVxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5fZm9udCA9ICcnO1xyXG4gICAgICAgIHRoaXMudGV4dCA9IHRleHQ7XHJcbiAgICAgICAgdGhpcy5zdHlsZSA9IHN0eWxlO1xyXG4gICAgICAgIHRoaXMubG9jYWxTdHlsZUlEID0gLTE7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlbmRlcnMgdGV4dCBhbmQgdXBkYXRlcyBpdCB3aGVuIG5lZWRlZC5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSByZXNwZWN0RGlydHkgLSBXaGV0aGVyIHRvIGFib3J0IHVwZGF0aW5nIHRoZSB0ZXh0IGlmIHRoZSBUZXh0IGlzbid0IGRpcnR5IGFuZCB0aGUgZnVuY3Rpb24gaXMgY2FsbGVkLlxyXG4gICAgICovXHJcbiAgICB1cGRhdGVUZXh0KHJlc3BlY3REaXJ0eSkge1xyXG4gICAgICAgIHZhciBzdHlsZSA9IHRoaXMuX3N0eWxlO1xyXG4gICAgICAgIC8vIGNoZWNrIGlmIHN0eWxlIGhhcyBjaGFuZ2VkLi5cclxuICAgICAgICBpZiAodGhpcy5sb2NhbFN0eWxlSUQgIT09IHN0eWxlLnN0eWxlSUQpIHtcclxuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMubG9jYWxTdHlsZUlEID0gc3R5bGUuc3R5bGVJRDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCF0aGlzLmRpcnR5ICYmIHJlc3BlY3REaXJ0eSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2ZvbnQgPSB0aGlzLl9zdHlsZS50b0ZvbnRTdHJpbmcoKTtcclxuICAgICAgICB2YXIgY29udGV4dCA9IHRoaXMuY29udGV4dDtcclxuICAgICAgICBUZXh0TWV0cmljc18xLlRleHRNZXRyaWNzLmluaXQoKTtcclxuICAgICAgICB2YXIgbWVhc3VyZWQgPSBUZXh0TWV0cmljc18xLlRleHRNZXRyaWNzLm1lYXN1cmVUZXh0KHRoaXMuX3RleHQgfHwgJyAnLCB0aGlzLl9zdHlsZSwgdGhpcy5fc3R5bGUud29yZFdyYXAsIHRoaXMuY2FudmFzKTtcclxuICAgICAgICB2YXIgd2lkdGggPSBtZWFzdXJlZC53aWR0aDtcclxuICAgICAgICB2YXIgaGVpZ2h0ID0gbWVhc3VyZWQuaGVpZ2h0O1xyXG4gICAgICAgIHZhciBsaW5lcyA9IG1lYXN1cmVkLmxpbmVzO1xyXG4gICAgICAgIHZhciBsaW5lSGVpZ2h0ID0gbWVhc3VyZWQubGluZUhlaWdodDtcclxuICAgICAgICB2YXIgbGluZVdpZHRocyA9IG1lYXN1cmVkLmxpbmVXaWR0aHM7XHJcbiAgICAgICAgdmFyIG1heExpbmVXaWR0aCA9IG1lYXN1cmVkLm1heExpbmVXaWR0aDtcclxuICAgICAgICB2YXIgZm9udFByb3BlcnRpZXMgPSBtZWFzdXJlZC5mb250UHJvcGVydGllcztcclxuICAgICAgICB0aGlzLmNhbnZhcy53aWR0aCA9IE1hdGguY2VpbCgoTWF0aC5tYXgoMSwgd2lkdGgpICsgKHN0eWxlLnBhZGRpbmcgKiAyKSkgKiB0aGlzLl9yZXNvbHV0aW9uKTtcclxuICAgICAgICB0aGlzLmNhbnZhcy5oZWlnaHQgPSBNYXRoLmNlaWwoKE1hdGgubWF4KDEsIGhlaWdodCkgKyAoc3R5bGUucGFkZGluZyAqIDIpKSAqIHRoaXMuX3Jlc29sdXRpb24pO1xyXG4gICAgICAgIGNvbnRleHQuc2NhbGUodGhpcy5fcmVzb2x1dGlvbiwgdGhpcy5fcmVzb2x1dGlvbik7XHJcbiAgICAgICAgY29udGV4dC5jbGVhclJlY3QoMCwgMCwgdGhpcy5jYW52YXMud2lkdGgsIHRoaXMuY2FudmFzLmhlaWdodCk7XHJcbiAgICAgICAgY29udGV4dC5mb250ID0gdGhpcy5fZm9udDtcclxuICAgICAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gc3R5bGUuc3Ryb2tlO1xyXG4gICAgICAgIGNvbnRleHQubGluZVdpZHRoID0gc3R5bGUuc3Ryb2tlVGhpY2tuZXNzO1xyXG4gICAgICAgIGNvbnRleHQudGV4dEJhc2VsaW5lID0gc3R5bGUudGV4dEJhc2VsaW5lO1xyXG4gICAgICAgIGNvbnRleHQubGluZUpvaW4gPSBzdHlsZS5saW5lSm9pbjtcclxuICAgICAgICBjb250ZXh0Lm1pdGVyTGltaXQgPSBzdHlsZS5taXRlckxpbWl0O1xyXG4gICAgICAgIHZhciBsaW5lUG9zaXRpb25YO1xyXG4gICAgICAgIHZhciBsaW5lUG9zaXRpb25ZO1xyXG4gICAgICAgIGlmIChzdHlsZS5kcm9wU2hhZG93KSB7XHJcbiAgICAgICAgICAgIHZhciBkcm9wU2hhZG93Q29sb3IgPSBzdHlsZS5kcm9wU2hhZG93Q29sb3I7XHJcbiAgICAgICAgICAgIHZhciByZ2IgPSBDb2xvclNldHRpbmdzXzEuQ29sb3JTZXR0aW5ncy5oZXgycmdiKHR5cGVvZiBkcm9wU2hhZG93Q29sb3IgPT09ICdudW1iZXInID8gZHJvcFNoYWRvd0NvbG9yIDogTWF0aFNldHRpbmdzXzEuTWF0aFNldHRpbmdzLnN0cmluZzJoZXgoZHJvcFNoYWRvd0NvbG9yKSk7XHJcbiAgICAgICAgICAgIGNvbnRleHQuc2hhZG93Q29sb3IgPSBcInJnYmEoXCIgKyAocmdiWzBdICogMjU1KSArIFwiLFwiICsgKHJnYlsxXSAqIDI1NSkgKyBcIixcIiArIChyZ2JbMl0gKiAyNTUpICsgXCIsXCIgKyAoc3R5bGUuZHJvcFNoYWRvd0FscGhhKSArIFwiKVwiO1xyXG4gICAgICAgICAgICBjb250ZXh0LnNoYWRvd0JsdXIgPSBzdHlsZS5kcm9wU2hhZG93Qmx1cjtcclxuICAgICAgICAgICAgY29udGV4dC5zaGFkb3dPZmZzZXRYID0gTWF0aC5jb3Moc3R5bGUuZHJvcFNoYWRvd0FuZ2xlKSAqIHN0eWxlLmRyb3BTaGFkb3dEaXN0YW5jZTtcclxuICAgICAgICAgICAgY29udGV4dC5zaGFkb3dPZmZzZXRZID0gTWF0aC5zaW4oc3R5bGUuZHJvcFNoYWRvd0FuZ2xlKSAqIHN0eWxlLmRyb3BTaGFkb3dEaXN0YW5jZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnRleHQuc2hhZG93Q29sb3IgPSAwO1xyXG4gICAgICAgICAgICBjb250ZXh0LnNoYWRvd0JsdXIgPSAwO1xyXG4gICAgICAgICAgICBjb250ZXh0LnNoYWRvd09mZnNldFggPSAwO1xyXG4gICAgICAgICAgICBjb250ZXh0LnNoYWRvd09mZnNldFkgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBzZXQgY2FudmFzIHRleHQgc3R5bGVzXHJcbiAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSB0aGlzLl9nZW5lcmF0ZUZpbGxTdHlsZShzdHlsZSwgbGluZXMpO1xyXG4gICAgICAgIC8vIGRyYXcgbGluZXMgbGluZSBieSBsaW5lXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBsaW5lUG9zaXRpb25YID0gc3R5bGUuc3Ryb2tlVGhpY2tuZXNzIC8gMjtcclxuICAgICAgICAgICAgbGluZVBvc2l0aW9uWSA9ICgoc3R5bGUuc3Ryb2tlVGhpY2tuZXNzIC8gMikgKyAoaSAqIGxpbmVIZWlnaHQpKSArIGZvbnRQcm9wZXJ0aWVzLmFzY2VudDtcclxuICAgICAgICAgICAgaWYgKHN0eWxlLmFsaWduID09PSAncmlnaHQnKSB7XHJcbiAgICAgICAgICAgICAgICBsaW5lUG9zaXRpb25YICs9IG1heExpbmVXaWR0aCAtIGxpbmVXaWR0aHNbaV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoc3R5bGUuYWxpZ24gPT09ICdjZW50ZXInKSB7XHJcbiAgICAgICAgICAgICAgICBsaW5lUG9zaXRpb25YICs9IChtYXhMaW5lV2lkdGggLSBsaW5lV2lkdGhzW2ldKSAvIDI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHN0eWxlLnN0cm9rZSAmJiBzdHlsZS5zdHJva2VUaGlja25lc3MpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZHJhd0xldHRlclNwYWNpbmcobGluZXNbaV0sIGxpbmVQb3NpdGlvblggKyBzdHlsZS5wYWRkaW5nLCBsaW5lUG9zaXRpb25ZICsgc3R5bGUucGFkZGluZywgdHJ1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHN0eWxlLmZpbGwpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZHJhd0xldHRlclNwYWNpbmcobGluZXNbaV0sIGxpbmVQb3NpdGlvblggKyBzdHlsZS5wYWRkaW5nLCBsaW5lUG9zaXRpb25ZICsgc3R5bGUucGFkZGluZyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy51cGRhdGVUZXh0dXJlKCk7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFJlbmRlciB0aGUgdGV4dCB3aXRoIGxldHRlci1zcGFjaW5nLlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgLSBUaGUgdGV4dCB0byBkcmF3XHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCAtIEhvcml6b250YWwgcG9zaXRpb24gdG8gZHJhdyB0aGUgdGV4dFxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgLSBWZXJ0aWNhbCBwb3NpdGlvbiB0byBkcmF3IHRoZSB0ZXh0XHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc1N0cm9rZT1mYWxzZV0gLSBJcyB0aGlzIGRyYXdpbmcgZm9yIHRoZSBvdXRzaWRlIHN0cm9rZSBvZiB0aGVcclxuICAgICAqICB0ZXh0PyBJZiBub3QsIGl0J3MgZm9yIHRoZSBpbnNpZGUgZmlsbFxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgZHJhd0xldHRlclNwYWNpbmcodGV4dCwgeCwgeSwgaXNTdHJva2UgPSBmYWxzZSkge1xyXG4gICAgICAgIGlmIChpc1N0cm9rZSA9PT0gdm9pZCAwKSB7XHJcbiAgICAgICAgICAgIGlzU3Ryb2tlID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBzdHlsZSA9IHRoaXMuX3N0eWxlO1xyXG4gICAgICAgIC8vIGxldHRlclNwYWNpbmcgb2YgMCBtZWFucyBub3JtYWxcclxuICAgICAgICB2YXIgbGV0dGVyU3BhY2luZyA9IHN0eWxlLmxldHRlclNwYWNpbmc7XHJcbiAgICAgICAgaWYgKGxldHRlclNwYWNpbmcgPT09IDApIHtcclxuICAgICAgICAgICAgaWYgKGlzU3Ryb2tlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuc3Ryb2tlVGV4dCh0ZXh0LCB4LCB5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5maWxsVGV4dCh0ZXh0LCB4LCB5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBjaGFyYWN0ZXJzID0gU3RyaW5nLnByb3RvdHlwZS5zcGxpdC5jYWxsKHRleHQsICcnKTtcclxuICAgICAgICB2YXIgY3VycmVudFBvc2l0aW9uID0geDtcclxuICAgICAgICB2YXIgaW5kZXggPSAwO1xyXG4gICAgICAgIHZhciBjdXJyZW50ID0gJyc7XHJcbiAgICAgICAgd2hpbGUgKGluZGV4IDwgdGV4dC5sZW5ndGgpIHtcclxuICAgICAgICAgICAgY3VycmVudCA9IGNoYXJhY3RlcnNbaW5kZXgrK107XHJcbiAgICAgICAgICAgIGlmIChpc1N0cm9rZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LnN0cm9rZVRleHQoY3VycmVudCwgY3VycmVudFBvc2l0aW9uLCB5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5maWxsVGV4dChjdXJyZW50LCBjdXJyZW50UG9zaXRpb24sIHkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGN1cnJlbnRQb3NpdGlvbiArPSB0aGlzLmNvbnRleHQubWVhc3VyZVRleHQoY3VycmVudCkud2lkdGggKyBsZXR0ZXJTcGFjaW5nO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyB0ZXh0dXJlIHNpemUgYmFzZWQgb24gY2FudmFzIHNpemVcclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICB1cGRhdGVUZXh0dXJlKCkge1xyXG4gICAgICAgIHZhciBjYW52YXMgPSB0aGlzLmNhbnZhcztcclxuICAgICAgICBpZiAodGhpcy5fc3R5bGUudHJpbSkge1xyXG4gICAgICAgICAgICB2YXIgdHJpbW1lZCA9IENhbnZhc1NldHRpbmdzXzEuQ2FudmFzU2V0dGluZ3MudHJpbUNhbnZhcyhjYW52YXMpO1xyXG4gICAgICAgICAgICBpZiAodHJpbW1lZC5kYXRhKSB7XHJcbiAgICAgICAgICAgICAgICBjYW52YXMud2lkdGggPSB0cmltbWVkLndpZHRoO1xyXG4gICAgICAgICAgICAgICAgY2FudmFzLmhlaWdodCA9IHRyaW1tZWQuaGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LnB1dEltYWdlRGF0YSh0cmltbWVkLmRhdGEsIDAsIDApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciB0ZXh0dXJlID0gdGhpcy5fdGV4dHVyZTtcclxuICAgICAgICB2YXIgc3R5bGUgPSB0aGlzLl9zdHlsZTtcclxuICAgICAgICB2YXIgcGFkZGluZyA9IHN0eWxlLnRyaW0gPyAwIDogc3R5bGUucGFkZGluZztcclxuICAgICAgICB2YXIgYmFzZVRleHR1cmUgPSB0ZXh0dXJlLmJhc2VUZXh0dXJlO1xyXG4gICAgICAgIHRleHR1cmUudHJpbS53aWR0aCA9IHRleHR1cmUuX2ZyYW1lLndpZHRoID0gY2FudmFzLndpZHRoIC8gdGhpcy5fcmVzb2x1dGlvbjtcclxuICAgICAgICB0ZXh0dXJlLnRyaW0uaGVpZ2h0ID0gdGV4dHVyZS5fZnJhbWUuaGVpZ2h0ID0gY2FudmFzLmhlaWdodCAvIHRoaXMuX3Jlc29sdXRpb247XHJcbiAgICAgICAgdGV4dHVyZS50cmltLnggPSAtcGFkZGluZztcclxuICAgICAgICB0ZXh0dXJlLnRyaW0ueSA9IC1wYWRkaW5nO1xyXG4gICAgICAgIHRleHR1cmUub3JpZy53aWR0aCA9IHRleHR1cmUuX2ZyYW1lLndpZHRoIC0gKHBhZGRpbmcgKiAyKTtcclxuICAgICAgICB0ZXh0dXJlLm9yaWcuaGVpZ2h0ID0gdGV4dHVyZS5fZnJhbWUuaGVpZ2h0IC0gKHBhZGRpbmcgKiAyKTtcclxuICAgICAgICAvLyBjYWxsIHNwcml0ZSBvblRleHR1cmVVcGRhdGUgdG8gdXBkYXRlIHNjYWxlIGlmIF93aWR0aCBvciBfaGVpZ2h0IHdlcmUgc2V0XHJcbiAgICAgICAgdGhpcy5fb25UZXh0dXJlVXBkYXRlKCk7XHJcbiAgICAgICAgYmFzZVRleHR1cmUuc2V0UmVhbFNpemUoY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0LCB0aGlzLl9yZXNvbHV0aW9uKTtcclxuICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFJlbmRlcnMgdGhlIG9iamVjdCB1c2luZyB0aGUgV2ViR0wgcmVuZGVyZXJcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1BJWEkuUmVuZGVyZXJ9IHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyXHJcbiAgICAgKi9cclxuICAgIHJlbmRlcihyZW5kZXJlcikge1xyXG4gICAgICAgIGlmICh0aGlzLl9hdXRvUmVzb2x1dGlvbiAmJiB0aGlzLl9yZXNvbHV0aW9uICE9PSByZW5kZXJlci5yZXNvbHV0aW9uKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3Jlc29sdXRpb24gPSByZW5kZXJlci5yZXNvbHV0aW9uO1xyXG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy51cGRhdGVUZXh0KHRydWUpO1xyXG4gICAgICAgIHN1cGVyLnJlbmRlcihyZW5kZXJlcik7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFJlbmRlcnMgdGhlIG9iamVjdCB1c2luZyB0aGUgQ2FudmFzIHJlbmRlcmVyXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7UElYSS5DYW52YXNSZW5kZXJlcn0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXJcclxuICAgICAqL1xyXG4gICAgX3JlbmRlckNhbnZhcyhyZW5kZXJlcikge1xyXG4gICAgICAgIGlmICh0aGlzLl9hdXRvUmVzb2x1dGlvbiAmJiB0aGlzLl9yZXNvbHV0aW9uICE9PSByZW5kZXJlci5yZXNvbHV0aW9uKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3Jlc29sdXRpb24gPSByZW5kZXJlci5yZXNvbHV0aW9uO1xyXG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy51cGRhdGVUZXh0KHRydWUpO1xyXG4gICAgICAgIC8vIHN1cGVyLl9yZW5kZXJDYW52YXMocmVuZGVyZXIpO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBsb2NhbCBib3VuZHMgb2YgdGhlIHRleHQgb2JqZWN0LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7UmVjdGFuZ2xlfSByZWN0IC0gVGhlIG91dHB1dCByZWN0YW5nbGUuXHJcbiAgICAgKiBAcmV0dXJuIHtSZWN0YW5nbGV9IFRoZSBib3VuZHMuXHJcbiAgICAgKi9cclxuICAgIGdldExvY2FsQm91bmRzKHJlY3QpIHtcclxuICAgICAgICB0aGlzLnVwZGF0ZVRleHQodHJ1ZSk7XHJcbiAgICAgICAgcmV0dXJuIHN1cGVyLmdldExvY2FsQm91bmRzKHJlY3QpO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBjYWxjdWxhdGVzIHRoZSBib3VuZHMgb2YgdGhlIFRleHQgYXMgYSByZWN0YW5nbGUuIFRoZSBib3VuZHMgY2FsY3VsYXRpb24gdGFrZXMgdGhlIHdvcmxkVHJhbnNmb3JtIGludG8gYWNjb3VudC5cclxuICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAqL1xyXG4gICAgX2NhbGN1bGF0ZUJvdW5kcygpIHtcclxuICAgICAgICB0aGlzLnVwZGF0ZVRleHQodHJ1ZSk7XHJcbiAgICAgICAgdGhpcy5jYWxjdWxhdGVWZXJ0aWNlcygpO1xyXG4gICAgICAgIC8vIGlmIHdlIGhhdmUgYWxyZWFkeSBkb25lIHRoaXMgb24gVEhJUyBmcmFtZS5cclxuICAgICAgICB0aGlzLl9ib3VuZHMuYWRkUXVhZCh0aGlzLnZlcnRleERhdGEpO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBNZXRob2QgdG8gYmUgY2FsbGVkIHVwb24gYSBUZXh0U3R5bGUgY2hhbmdlLlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgX29uU3R5bGVDaGFuZ2UoKSB7XHJcbiAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIEdlbmVyYXRlcyB0aGUgZmlsbCBzdHlsZS4gQ2FuIGF1dG9tYXRpY2FsbHkgZ2VuZXJhdGUgYSBncmFkaWVudCBiYXNlZCBvbiB0aGUgZmlsbCBzdHlsZSBiZWluZyBhbiBhcnJheVxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gc3R5bGUgLSBUaGUgc3R5bGUuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBsaW5lcyAtIFRoZSBsaW5lcyBvZiB0ZXh0LlxyXG4gICAgICogQHJldHVybiB7c3RyaW5nfG51bWJlcnxDYW52YXNHcmFkaWVudH0gVGhlIGZpbGwgc3R5bGVcclxuICAgICAqL1xyXG4gICAgX2dlbmVyYXRlRmlsbFN0eWxlKHN0eWxlLCBsaW5lcykge1xyXG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShzdHlsZS5maWxsKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gc3R5bGUuZmlsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gdGhlIGdyYWRpZW50IHdpbGwgYmUgZXZlbmx5IHNwYWNlZCBvdXQgYWNjb3JkaW5nIHRvIGhvdyBsYXJnZSB0aGUgYXJyYXkgaXMuXHJcbiAgICAgICAgLy8gWycjRkYwMDAwJywgJyMwMEZGMDAnLCAnIzAwMDBGRiddIHdvdWxkIGNyZWF0ZWQgc3RvcHMgYXQgMC4yNSwgMC41IGFuZCAwLjc1XHJcbiAgICAgICAgdmFyIGdyYWRpZW50O1xyXG4gICAgICAgIHZhciB0b3RhbEl0ZXJhdGlvbnM7XHJcbiAgICAgICAgdmFyIGN1cnJlbnRJdGVyYXRpb247XHJcbiAgICAgICAgdmFyIHN0b3A7XHJcbiAgICAgICAgdmFyIHdpZHRoID0gdGhpcy5jYW52YXMud2lkdGggLyB0aGlzLl9yZXNvbHV0aW9uO1xyXG4gICAgICAgIHZhciBoZWlnaHQgPSB0aGlzLmNhbnZhcy5oZWlnaHQgLyB0aGlzLl9yZXNvbHV0aW9uO1xyXG4gICAgICAgIC8vIG1ha2UgYSBjb3B5IG9mIHRoZSBzdHlsZSBzZXR0aW5ncywgc28gd2UgY2FuIG1hbmlwdWxhdGUgdGhlbSBsYXRlclxyXG4gICAgICAgIHZhciBmaWxsID0gc3R5bGUuZmlsbC5zbGljZSgpO1xyXG4gICAgICAgIHZhciBmaWxsR3JhZGllbnRTdG9wcyA9IHN0eWxlLmZpbGxHcmFkaWVudFN0b3BzLnNsaWNlKCk7XHJcbiAgICAgICAgLy8gd2FudGluZyB0byBldmVubHkgZGlzdHJpYnV0ZSB0aGUgZmlsbHMuIFNvIGFuIGFycmF5IG9mIDQgY29sb3VycyBzaG91bGQgZ2l2ZSBmaWxscyBvZiAwLjI1LCAwLjUgYW5kIDAuNzVcclxuICAgICAgICBpZiAoIWZpbGxHcmFkaWVudFN0b3BzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICB2YXIgbGVuZ3RoUGx1czEgPSBmaWxsLmxlbmd0aCArIDE7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgbGVuZ3RoUGx1czE7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgZmlsbEdyYWRpZW50U3RvcHMucHVzaChpIC8gbGVuZ3RoUGx1czEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHN0b3AgdGhlIGJsZWVkaW5nIG9mIHRoZSBsYXN0IGdyYWRpZW50IG9uIHRoZSBsaW5lIGFib3ZlIHRvIHRoZSB0b3AgZ3JhZGllbnQgb2YgdGhlIHRoaXMgbGluZVxyXG4gICAgICAgIC8vIGJ5IGhhcmQgZGVmaW5pbmcgdGhlIGZpcnN0IGdyYWRpZW50IGNvbG91ciBhdCBwb2ludCAwLCBhbmQgbGFzdCBncmFkaWVudCBjb2xvdXIgYXQgcG9pbnQgMVxyXG4gICAgICAgIGZpbGwudW5zaGlmdChzdHlsZS5maWxsWzBdKTtcclxuICAgICAgICBmaWxsR3JhZGllbnRTdG9wcy51bnNoaWZ0KDApO1xyXG4gICAgICAgIGZpbGwucHVzaChzdHlsZS5maWxsW3N0eWxlLmZpbGwubGVuZ3RoIC0gMV0pO1xyXG4gICAgICAgIGZpbGxHcmFkaWVudFN0b3BzLnB1c2goMSk7XHJcbiAgICAgICAgaWYgKHN0eWxlLmZpbGxHcmFkaWVudFR5cGUgPT09IFRleHRTZXR0aW5nc18xLlRleHRTZXR0aW5ncy5URVhUX0dSQURJRU5ULkxJTkVBUl9WRVJUSUNBTCkge1xyXG4gICAgICAgICAgICAvLyBzdGFydCB0aGUgZ3JhZGllbnQgYXQgdGhlIHRvcCBjZW50ZXIgb2YgdGhlIGNhbnZhcywgYW5kIGVuZCBhdCB0aGUgYm90dG9tIG1pZGRsZSBvZiB0aGUgY2FudmFzXHJcbiAgICAgICAgICAgIGdyYWRpZW50ID0gdGhpcy5jb250ZXh0LmNyZWF0ZUxpbmVhckdyYWRpZW50KHdpZHRoIC8gMiwgMCwgd2lkdGggLyAyLCBoZWlnaHQpO1xyXG4gICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIHJlcGVhdCB0aGUgZ3JhZGllbnQgc28gdGhhdCBlYWNoIGluZGl2aWR1YWwgbGluZSBvZiB0ZXh0IGhhcyB0aGUgc2FtZSB2ZXJ0aWNhbCBncmFkaWVudCBlZmZlY3RcclxuICAgICAgICAgICAgLy8gWycjRkYwMDAwJywgJyMwMEZGMDAnLCAnIzAwMDBGRiddIG92ZXIgMiBsaW5lcyB3b3VsZCBjcmVhdGUgc3RvcHMgYXQgMC4xMjUsIDAuMjUsIDAuMzc1LCAwLjYyNSwgMC43NSwgMC44NzVcclxuICAgICAgICAgICAgdG90YWxJdGVyYXRpb25zID0gKGZpbGwubGVuZ3RoICsgMSkgKiBsaW5lcy5sZW5ndGg7XHJcbiAgICAgICAgICAgIGN1cnJlbnRJdGVyYXRpb24gPSAwO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBsaW5lcy5sZW5ndGg7IGkkMSsrKSB7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50SXRlcmF0aW9uICs9IDE7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGZpbGwubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGZpbGxHcmFkaWVudFN0b3BzW2pdID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdG9wID0gKGZpbGxHcmFkaWVudFN0b3BzW2pdIC8gbGluZXMubGVuZ3RoKSArIChpJDEgLyBsaW5lcy5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RvcCA9IGN1cnJlbnRJdGVyYXRpb24gLyB0b3RhbEl0ZXJhdGlvbnM7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGdyYWRpZW50LmFkZENvbG9yU3RvcChzdG9wLCBmaWxsW2pdKTtcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50SXRlcmF0aW9uKys7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIHN0YXJ0IHRoZSBncmFkaWVudCBhdCB0aGUgY2VudGVyIGxlZnQgb2YgdGhlIGNhbnZhcywgYW5kIGVuZCBhdCB0aGUgY2VudGVyIHJpZ2h0IG9mIHRoZSBjYW52YXNcclxuICAgICAgICAgICAgZ3JhZGllbnQgPSB0aGlzLmNvbnRleHQuY3JlYXRlTGluZWFyR3JhZGllbnQoMCwgaGVpZ2h0IC8gMiwgd2lkdGgsIGhlaWdodCAvIDIpO1xyXG4gICAgICAgICAgICAvLyBjYW4ganVzdCBldmVubHkgc3BhY2Ugb3V0IHRoZSBncmFkaWVudHMgaW4gdGhpcyBjYXNlLCBhcyBtdWx0aXBsZSBsaW5lcyBtYWtlcyBubyBkaWZmZXJlbmNlXHJcbiAgICAgICAgICAgIC8vIHRvIGFuIGV2ZW4gbGVmdCB0byByaWdodCBncmFkaWVudFxyXG4gICAgICAgICAgICB0b3RhbEl0ZXJhdGlvbnMgPSBmaWxsLmxlbmd0aCArIDE7XHJcbiAgICAgICAgICAgIGN1cnJlbnRJdGVyYXRpb24gPSAxO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpJDIgPSAwOyBpJDIgPCBmaWxsLmxlbmd0aDsgaSQyKyspIHtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZmlsbEdyYWRpZW50U3RvcHNbaSQyXSA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdG9wID0gZmlsbEdyYWRpZW50U3RvcHNbaSQyXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0b3AgPSBjdXJyZW50SXRlcmF0aW9uIC8gdG90YWxJdGVyYXRpb25zO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZ3JhZGllbnQuYWRkQ29sb3JTdG9wKHN0b3AsIGZpbGxbaSQyXSk7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50SXRlcmF0aW9uKys7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGdyYWRpZW50O1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBEZXN0cm95cyB0aGlzIHRleHQgb2JqZWN0LlxyXG4gICAgICogTm90ZSogVW5saWtlIGEgU3ByaXRlLCBhIFRleHQgb2JqZWN0IHdpbGwgYXV0b21hdGljYWxseSBkZXN0cm95IGl0cyBiYXNlVGV4dHVyZSBhbmQgdGV4dHVyZSBhc1xyXG4gICAgICogdGhlIG1ham9yaXR5IG9mIHRoZSB0aW1lIHRoZSB0ZXh0dXJlIHdpbGwgbm90IGJlIHNoYXJlZCB3aXRoIGFueSBvdGhlciBTcHJpdGVzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fGJvb2xlYW59IFtvcHRpb25zXSAtIE9wdGlvbnMgcGFyYW1ldGVyLiBBIGJvb2xlYW4gd2lsbCBhY3QgYXMgaWYgYWxsIG9wdGlvbnNcclxuICAgICAqICBoYXZlIGJlZW4gc2V0IHRvIHRoYXQgdmFsdWVcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuY2hpbGRyZW49ZmFsc2VdIC0gaWYgc2V0IHRvIHRydWUsIGFsbCB0aGUgY2hpbGRyZW4gd2lsbCBoYXZlIHRoZWlyXHJcbiAgICAgKiAgZGVzdHJveSBtZXRob2QgY2FsbGVkIGFzIHdlbGwuICdvcHRpb25zJyB3aWxsIGJlIHBhc3NlZCBvbiB0byB0aG9zZSBjYWxscy5cclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudGV4dHVyZT10cnVlXSAtIFNob3VsZCBpdCBkZXN0cm95IHRoZSBjdXJyZW50IHRleHR1cmUgb2YgdGhlIHNwcml0ZSBhcyB3ZWxsXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmJhc2VUZXh0dXJlPXRydWVdIC0gU2hvdWxkIGl0IGRlc3Ryb3kgdGhlIGJhc2UgdGV4dHVyZSBvZiB0aGUgc3ByaXRlIGFzIHdlbGxcclxuICAgICAqL1xyXG4gICAgZGVzdHJveShvcHRpb25zKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnYm9vbGVhbicpIHtcclxuICAgICAgICAgICAgb3B0aW9ucyA9IHsgY2hpbGRyZW46IG9wdGlvbnMgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIENsZWFuVXBTZXR0aW5nc18xLkNsZWFuVXBTZXR0aW5ncy5kZWZhdWx0RGVzdHJveU9wdGlvbnMsIG9wdGlvbnMpO1xyXG4gICAgICAgIHN1cGVyLmRlc3Ryb3kob3B0aW9ucyk7XHJcbiAgICAgICAgLy8gbWFrZSBzdXJlIHRvIHJlc2V0IHRoZSB0aGUgY29udGV4dCBhbmQgY2FudmFzLi4gZG9udCB3YW50IHRoaXMgaGFuZ2luZyBhcm91bmQgaW4gbWVtb3J5IVxyXG4gICAgICAgIHRoaXMuY29udGV4dCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5jYW52YXMgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuX3N0eWxlID0gbnVsbDtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIHdpZHRoIG9mIHRoZSBUZXh0LCBzZXR0aW5nIHRoaXMgd2lsbCBhY3R1YWxseSBtb2RpZnkgdGhlIHNjYWxlIHRvIGFjaGlldmUgdGhlIHZhbHVlIHNldFxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgZ2V0IHdpZHRoKCkge1xyXG4gICAgICAgIHRoaXMudXBkYXRlVGV4dCh0cnVlKTtcclxuICAgICAgICByZXR1cm4gTWF0aC5hYnModGhpcy5zY2FsZS54KSAqIHRoaXMuX3RleHR1cmUub3JpZy53aWR0aDtcclxuICAgIH1cclxuICAgIDtcclxuICAgIHNldCB3aWR0aCh2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMudXBkYXRlVGV4dCh0cnVlKTtcclxuICAgICAgICB2YXIgcyA9IE1hdGhTZXR0aW5nc18xLk1hdGhTZXR0aW5ncy5zaWduKHRoaXMuc2NhbGUueCkgfHwgMTtcclxuICAgICAgICB0aGlzLnNjYWxlLnggPSBzICogdmFsdWUgLyB0aGlzLl90ZXh0dXJlLm9yaWcud2lkdGg7XHJcbiAgICAgICAgdGhpcy5fd2lkdGggPSB2YWx1ZTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGhlaWdodCBvZiB0aGUgVGV4dCwgc2V0dGluZyB0aGlzIHdpbGwgYWN0dWFsbHkgbW9kaWZ5IHRoZSBzY2FsZSB0byBhY2hpZXZlIHRoZSB2YWx1ZSBzZXRcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIGdldCBoZWlnaHQoKSB7XHJcbiAgICAgICAgdGhpcy51cGRhdGVUZXh0KHRydWUpO1xyXG4gICAgICAgIHJldHVybiBNYXRoLmFicyh0aGlzLnNjYWxlLnkpICogdGhpcy5fdGV4dHVyZS5vcmlnLmhlaWdodDtcclxuICAgIH1cclxuICAgIDtcclxuICAgIHNldCBoZWlnaHQodmFsdWUpIHtcclxuICAgICAgICB0aGlzLnVwZGF0ZVRleHQodHJ1ZSk7XHJcbiAgICAgICAgdmFyIHMgPSBNYXRoU2V0dGluZ3NfMS5NYXRoU2V0dGluZ3Muc2lnbih0aGlzLnNjYWxlLnkpIHx8IDE7XHJcbiAgICAgICAgdGhpcy5zY2FsZS55ID0gcyAqIHZhbHVlIC8gdGhpcy5fdGV4dHVyZS5vcmlnLmhlaWdodDtcclxuICAgICAgICB0aGlzLl9oZWlnaHQgPSB2YWx1ZTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRoZSBzdHlsZSBvZiB0aGUgdGV4dC4gU2V0IHVwIGFuIGV2ZW50IGxpc3RlbmVyIHRvIGxpc3RlbiBmb3IgY2hhbmdlcyBvbiB0aGUgc3R5bGVcclxuICAgICAqIG9iamVjdCBhbmQgbWFyayB0aGUgdGV4dCBhcyBkaXJ0eS5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtvYmplY3R8UElYSS5UZXh0U3R5bGV9XHJcbiAgICAgKi9cclxuICAgIGdldCBzdHlsZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fc3R5bGU7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICBzZXQgc3R5bGUoc3R5bGUpIHtcclxuICAgICAgICBzdHlsZSA9IHN0eWxlIHx8IHt9O1xyXG4gICAgICAgIGlmIChzdHlsZSBpbnN0YW5jZW9mIFRleHRTdHlsZV8xLlRleHRTdHlsZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9zdHlsZSA9IHN0eWxlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5fc3R5bGUgPSBuZXcgVGV4dFN0eWxlXzEuVGV4dFN0eWxlKHN0eWxlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5sb2NhbFN0eWxlSUQgPSAtMTtcclxuICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRoZSBjb3B5IGZvciB0aGUgdGV4dCBvYmplY3QuIFRvIHNwbGl0IGEgbGluZSB5b3UgY2FuIHVzZSAnXFxuJy5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtzdHJpbmd9XHJcbiAgICAgKi9cclxuICAgIGdldCB0ZXh0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl90ZXh0O1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgc2V0IHRleHQodGV4dCkge1xyXG4gICAgICAgIHRleHQgPSBTdHJpbmcodGV4dCA9PT0gbnVsbCB8fCB0ZXh0ID09PSB1bmRlZmluZWQgPyAnJyA6IHRleHQpO1xyXG4gICAgICAgIGlmICh0aGlzLl90ZXh0ID09PSB0ZXh0KSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fdGV4dCA9IHRleHQ7XHJcbiAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSByZXNvbHV0aW9uIC8gZGV2aWNlIHBpeGVsIHJhdGlvIG9mIHRoZSBjYW52YXMuXHJcbiAgICAgKiBUaGlzIGlzIHNldCB0byBhdXRvbWF0aWNhbGx5IG1hdGNoIHRoZSByZW5kZXJlciByZXNvbHV0aW9uIGJ5IGRlZmF1bHQsIGJ1dCBjYW4gYmUgb3ZlcnJpZGRlbiBieSBzZXR0aW5nIG1hbnVhbGx5LlxyXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICogQGRlZmF1bHQgMVxyXG4gICAgICovXHJcbiAgICBnZXQgcmVzb2x1dGlvbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcmVzb2x1dGlvbjtcclxuICAgIH1cclxuICAgIDtcclxuICAgIHNldCByZXNvbHV0aW9uKHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5fYXV0b1Jlc29sdXRpb24gPSBmYWxzZTtcclxuICAgICAgICBpZiAodGhpcy5fcmVzb2x1dGlvbiA9PT0gdmFsdWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9yZXNvbHV0aW9uID0gdmFsdWU7XHJcbiAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XHJcbiAgICB9XHJcbiAgICA7XHJcbn1cclxuZXhwb3J0cy5UZXh0ID0gVGV4dDtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY2xhc3MgVGV4dE1ldHJpY3Mge1xyXG4gICAgY29uc3RydWN0b3IodGV4dCwgc3R5bGUsIHdpZHRoLCBoZWlnaHQsIGxpbmVzLCBsaW5lV2lkdGhzLCBsaW5lSGVpZ2h0LCBtYXhMaW5lV2lkdGgsIGZvbnRQcm9wZXJ0aWVzKSB7XHJcbiAgICAgICAgaWYgKCFUZXh0TWV0cmljcy5jYW52YXMpIHtcclxuICAgICAgICAgICAgVGV4dE1ldHJpY3MuY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XHJcbiAgICAgICAgICAgIFRleHRNZXRyaWNzLmNhbnZhcy53aWR0aCA9IFRleHRNZXRyaWNzLmNhbnZhcy5oZWlnaHQgPSAxMDtcclxuICAgICAgICAgICAgVGV4dE1ldHJpY3MuX2NhbnZhcyA9IFRleHRNZXRyaWNzLmNhbnZhcztcclxuICAgICAgICAgICAgVGV4dE1ldHJpY3MuX2NvbnRleHQgPSBUZXh0TWV0cmljcy5jYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy50ZXh0ID0gdGV4dDtcclxuICAgICAgICB0aGlzLnN0eWxlID0gc3R5bGU7XHJcbiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xyXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xyXG4gICAgICAgIHRoaXMubGluZXMgPSBsaW5lcztcclxuICAgICAgICB0aGlzLmxpbmVXaWR0aHMgPSBsaW5lV2lkdGhzO1xyXG4gICAgICAgIHRoaXMubGluZUhlaWdodCA9IGxpbmVIZWlnaHQ7XHJcbiAgICAgICAgdGhpcy5tYXhMaW5lV2lkdGggPSBtYXhMaW5lV2lkdGg7XHJcbiAgICAgICAgdGhpcy5mb250UHJvcGVydGllcyA9IGZvbnRQcm9wZXJ0aWVzO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGluaXQoKSB7XHJcbiAgICAgICAgaWYgKCFUZXh0TWV0cmljcy5jYW52YXMpIHtcclxuICAgICAgICAgICAgVGV4dE1ldHJpY3MuY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XHJcbiAgICAgICAgICAgIFRleHRNZXRyaWNzLmNhbnZhcy53aWR0aCA9IFRleHRNZXRyaWNzLmNhbnZhcy5oZWlnaHQgPSAxMDtcclxuICAgICAgICAgICAgVGV4dE1ldHJpY3MuX2NhbnZhcyA9IFRleHRNZXRyaWNzLmNhbnZhcztcclxuICAgICAgICAgICAgVGV4dE1ldHJpY3MuX2NvbnRleHQgPSBUZXh0TWV0cmljcy5jYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIE1lYXN1cmVzIHRoZSBzdXBwbGllZCBzdHJpbmcgb2YgdGV4dCBhbmQgcmV0dXJucyBhIFJlY3RhbmdsZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCAtIHRoZSB0ZXh0IHRvIG1lYXN1cmUuXHJcbiAgICAgKiBAcGFyYW0ge1BJWEkuVGV4dFN0eWxlfSBzdHlsZSAtIHRoZSB0ZXh0IHN0eWxlIHRvIHVzZSBmb3IgbWVhc3VyaW5nXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFt3b3JkV3JhcF0gLSBvcHRpb25hbCBvdmVycmlkZSBmb3IgaWYgd29yZC13cmFwIHNob3VsZCBiZSBhcHBsaWVkIHRvIHRoZSB0ZXh0LlxyXG4gICAgICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudH0gW2NhbnZhc10gLSBvcHRpb25hbCBzcGVjaWZpY2F0aW9uIG9mIHRoZSBjYW52YXMgdG8gdXNlIGZvciBtZWFzdXJpbmcuXHJcbiAgICAgKiBAcmV0dXJuIHtQSVhJLlRleHRNZXRyaWNzfSBtZWFzdXJlZCB3aWR0aCBhbmQgaGVpZ2h0IG9mIHRoZSB0ZXh0LlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgbWVhc3VyZVRleHQodGV4dCwgc3R5bGUsIHdvcmRXcmFwLCBjYW52YXMgPSBUZXh0TWV0cmljcy5fY2FudmFzKSB7XHJcbiAgICAgICAgd29yZFdyYXAgPSAod29yZFdyYXAgPT09IHVuZGVmaW5lZCB8fCB3b3JkV3JhcCA9PT0gbnVsbCkgPyBzdHlsZS53b3JkV3JhcCA6IHdvcmRXcmFwO1xyXG4gICAgICAgIHZhciBmb250ID0gc3R5bGUudG9Gb250U3RyaW5nKCk7XHJcbiAgICAgICAgdmFyIGZvbnRQcm9wZXJ0aWVzID0gVGV4dE1ldHJpY3MubWVhc3VyZUZvbnQoZm9udCk7XHJcbiAgICAgICAgLy8gZmFsbGJhY2sgaW4gY2FzZSBVQSBkaXNhbGxvdyBjYW52YXMgZGF0YSBleHRyYWN0aW9uXHJcbiAgICAgICAgLy8gKHRvRGF0YVVSSSwgZ2V0SW1hZ2VEYXRhIGZ1bmN0aW9ucylcclxuICAgICAgICBpZiAoZm9udFByb3BlcnRpZXMuZm9udFNpemUgPT09IDApIHtcclxuICAgICAgICAgICAgZm9udFByb3BlcnRpZXMuZm9udFNpemUgPSBzdHlsZS5mb250U2l6ZTtcclxuICAgICAgICAgICAgZm9udFByb3BlcnRpZXMuYXNjZW50ID0gc3R5bGUuZm9udFNpemU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XHJcbiAgICAgICAgY29udGV4dC5mb250ID0gZm9udDtcclxuICAgICAgICB2YXIgb3V0cHV0VGV4dCA9IHdvcmRXcmFwID8gVGV4dE1ldHJpY3Mud29yZFdyYXAodGV4dCwgc3R5bGUsIGNhbnZhcykgOiB0ZXh0O1xyXG4gICAgICAgIHZhciBsaW5lcyA9IG91dHB1dFRleHQuc3BsaXQoLyg/OlxcclxcbnxcXHJ8XFxuKS8pO1xyXG4gICAgICAgIHZhciBsaW5lV2lkdGhzID0gbmV3IEFycmF5KGxpbmVzLmxlbmd0aCk7XHJcbiAgICAgICAgdmFyIG1heExpbmVXaWR0aCA9IDA7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgbGluZVdpZHRoID0gY29udGV4dC5tZWFzdXJlVGV4dChsaW5lc1tpXSkud2lkdGggKyAoKGxpbmVzW2ldLmxlbmd0aCAtIDEpICogc3R5bGUubGV0dGVyU3BhY2luZyk7XHJcbiAgICAgICAgICAgIGxpbmVXaWR0aHNbaV0gPSBsaW5lV2lkdGg7XHJcbiAgICAgICAgICAgIG1heExpbmVXaWR0aCA9IE1hdGgubWF4KG1heExpbmVXaWR0aCwgbGluZVdpZHRoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHdpZHRoID0gbWF4TGluZVdpZHRoICsgc3R5bGUuc3Ryb2tlVGhpY2tuZXNzO1xyXG4gICAgICAgIGlmIChzdHlsZS5kcm9wU2hhZG93KSB7XHJcbiAgICAgICAgICAgIHdpZHRoICs9IHN0eWxlLmRyb3BTaGFkb3dEaXN0YW5jZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGxpbmVIZWlnaHQgPSBzdHlsZS5saW5lSGVpZ2h0IHx8IGZvbnRQcm9wZXJ0aWVzLmZvbnRTaXplICsgc3R5bGUuc3Ryb2tlVGhpY2tuZXNzO1xyXG4gICAgICAgIHZhciBoZWlnaHQgPSBNYXRoLm1heChsaW5lSGVpZ2h0LCBmb250UHJvcGVydGllcy5mb250U2l6ZSArIHN0eWxlLnN0cm9rZVRoaWNrbmVzcylcclxuICAgICAgICAgICAgKyAoKGxpbmVzLmxlbmd0aCAtIDEpICogKGxpbmVIZWlnaHQgKyBzdHlsZS5sZWFkaW5nKSk7XHJcbiAgICAgICAgaWYgKHN0eWxlLmRyb3BTaGFkb3cpIHtcclxuICAgICAgICAgICAgaGVpZ2h0ICs9IHN0eWxlLmRyb3BTaGFkb3dEaXN0YW5jZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBUZXh0TWV0cmljcyh0ZXh0LCBzdHlsZSwgd2lkdGgsIGhlaWdodCwgbGluZXMsIGxpbmVXaWR0aHMsIGxpbmVIZWlnaHQgKyBzdHlsZS5sZWFkaW5nLCBtYXhMaW5lV2lkdGgsIGZvbnRQcm9wZXJ0aWVzKTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQXBwbGllcyBuZXdsaW5lcyB0byBhIHN0cmluZyB0byBoYXZlIGl0IG9wdGltYWxseSBmaXQgaW50byB0aGUgaG9yaXpvbnRhbFxyXG4gICAgICogYm91bmRzIHNldCBieSB0aGUgVGV4dCBvYmplY3QncyB3b3JkV3JhcFdpZHRoIHByb3BlcnR5LlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCAtIFN0cmluZyB0byBhcHBseSB3b3JkIHdyYXBwaW5nIHRvXHJcbiAgICAgKiBAcGFyYW0ge1BJWEkuVGV4dFN0eWxlfSBzdHlsZSAtIHRoZSBzdHlsZSB0byB1c2Ugd2hlbiB3cmFwcGluZ1xyXG4gICAgICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudH0gW2NhbnZhc10gLSBvcHRpb25hbCBzcGVjaWZpY2F0aW9uIG9mIHRoZSBjYW52YXMgdG8gdXNlIGZvciBtZWFzdXJpbmcuXHJcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IE5ldyBzdHJpbmcgd2l0aCBuZXcgbGluZXMgYXBwbGllZCB3aGVyZSByZXF1aXJlZFxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgd29yZFdyYXAodGV4dCwgc3R5bGUsIGNhbnZhcykge1xyXG4gICAgICAgIGlmIChjYW52YXMgPT09IHZvaWQgMCkge1xyXG4gICAgICAgICAgICBjYW52YXMgPSBUZXh0TWV0cmljcy5fY2FudmFzO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xyXG4gICAgICAgIHZhciB3aWR0aCA9IDA7XHJcbiAgICAgICAgdmFyIGxpbmUgPSAnJztcclxuICAgICAgICB2YXIgbGluZXMgPSAnJztcclxuICAgICAgICB2YXIgY2FjaGUgPSB7fTtcclxuICAgICAgICB2YXIgbGV0dGVyU3BhY2luZyA9IHN0eWxlLmxldHRlclNwYWNpbmc7XHJcbiAgICAgICAgdmFyIHdoaXRlU3BhY2UgPSBzdHlsZS53aGl0ZVNwYWNlO1xyXG4gICAgICAgIC8vIEhvdyB0byBoYW5kbGUgd2hpdGVzcGFjZXNcclxuICAgICAgICB2YXIgY29sbGFwc2VTcGFjZXMgPSBUZXh0TWV0cmljcy5jb2xsYXBzZVNwYWNlcyh3aGl0ZVNwYWNlKTtcclxuICAgICAgICB2YXIgY29sbGFwc2VOZXdsaW5lcyA9IFRleHRNZXRyaWNzLmNvbGxhcHNlTmV3bGluZXMod2hpdGVTcGFjZSk7XHJcbiAgICAgICAgLy8gd2hldGhlciBvciBub3Qgc3BhY2VzIG1heSBiZSBhZGRlZCB0byB0aGUgYmVnaW5uaW5nIG9mIGxpbmVzXHJcbiAgICAgICAgdmFyIGNhblByZXBlbmRTcGFjZXMgPSAhY29sbGFwc2VTcGFjZXM7XHJcbiAgICAgICAgLy8gVGhlcmUgaXMgbGV0dGVyU3BhY2luZyBhZnRlciBldmVyeSBjaGFyIGV4Y2VwdCB0aGUgbGFzdCBvbmVcclxuICAgICAgICAvLyB0X2hfaV9zXycgJ19pX3NfJyAnX2Ffbl8nICdfZV94X2FfbV9wX2xfZV8nICdfIVxyXG4gICAgICAgIC8vIHNvIGZvciBjb252ZW5pZW5jZSB0aGUgYWJvdmUgbmVlZHMgdG8gYmUgY29tcGFyZWQgdG8gd2lkdGggKyAxIGV4dHJhIGxldHRlclNwYWNlXHJcbiAgICAgICAgLy8gdF9oX2lfc18nICdfaV9zXycgJ19hX25fJyAnX2VfeF9hX21fcF9sX2VfJyAnXyFfXHJcbiAgICAgICAgLy8gX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fXHJcbiAgICAgICAgLy8gQW5kIHRoZW4gdGhlIGZpbmFsIHNwYWNlIGlzIHNpbXBseSBubyBhcHBlbmRlZCB0byBlYWNoIGxpbmVcclxuICAgICAgICB2YXIgd29yZFdyYXBXaWR0aCA9IHN0eWxlLndvcmRXcmFwV2lkdGggKyBsZXR0ZXJTcGFjaW5nO1xyXG4gICAgICAgIC8vIGJyZWFrIHRleHQgaW50byB3b3Jkcywgc3BhY2VzIGFuZCBuZXdsaW5lIGNoYXJzXHJcbiAgICAgICAgdmFyIHRva2VucyA9IFRleHRNZXRyaWNzLnRva2VuaXplKHRleHQpO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIC8vIGdldCB0aGUgd29yZCwgc3BhY2Ugb3IgbmV3bGluZUNoYXJcclxuICAgICAgICAgICAgdmFyIHRva2VuID0gdG9rZW5zW2ldO1xyXG4gICAgICAgICAgICAvLyBpZiB3b3JkIGlzIGEgbmV3IGxpbmVcclxuICAgICAgICAgICAgaWYgKFRleHRNZXRyaWNzLmlzTmV3bGluZSh0b2tlbikpIHtcclxuICAgICAgICAgICAgICAgIC8vIGtlZXAgdGhlIG5ldyBsaW5lXHJcbiAgICAgICAgICAgICAgICBpZiAoIWNvbGxhcHNlTmV3bGluZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICBsaW5lcyArPSBUZXh0TWV0cmljcy5hZGRMaW5lKGxpbmUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhblByZXBlbmRTcGFjZXMgPSAhY29sbGFwc2VTcGFjZXM7XHJcbiAgICAgICAgICAgICAgICAgICAgbGluZSA9ICcnO1xyXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoID0gMDtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIGlmIHdlIHNob3VsZCBjb2xsYXBzZSBuZXcgbGluZXNcclxuICAgICAgICAgICAgICAgIC8vIHdlIHNpbXBseSBjb252ZXJ0IGl0IGludG8gYSBzcGFjZVxyXG4gICAgICAgICAgICAgICAgdG9rZW4gPSAnICc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gaWYgd2Ugc2hvdWxkIGNvbGxhcHNlIHJlcGVhdGVkIHdoaXRlc3BhY2VzXHJcbiAgICAgICAgICAgIGlmIChjb2xsYXBzZVNwYWNlcykge1xyXG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgYm90aCB0aGlzIGFuZCB0aGUgbGFzdCB0b2tlbnMgZm9yIHNwYWNlc1xyXG4gICAgICAgICAgICAgICAgdmFyIGN1cnJJc0JyZWFraW5nU3BhY2UgPSBUZXh0TWV0cmljcy5pc0JyZWFraW5nU3BhY2UodG9rZW4pO1xyXG4gICAgICAgICAgICAgICAgdmFyIGxhc3RJc0JyZWFraW5nU3BhY2UgPSBUZXh0TWV0cmljcy5pc0JyZWFraW5nU3BhY2UobGluZVtsaW5lLmxlbmd0aCAtIDFdKTtcclxuICAgICAgICAgICAgICAgIGlmIChjdXJySXNCcmVha2luZ1NwYWNlICYmIGxhc3RJc0JyZWFraW5nU3BhY2UpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBnZXQgd29yZCB3aWR0aCBmcm9tIGNhY2hlIGlmIHBvc3NpYmxlXHJcbiAgICAgICAgICAgIHZhciB0b2tlbldpZHRoID0gVGV4dE1ldHJpY3MuZ2V0RnJvbUNhY2hlKHRva2VuLCBsZXR0ZXJTcGFjaW5nLCBjYWNoZSwgY29udGV4dCk7XHJcbiAgICAgICAgICAgIC8vIHdvcmQgaXMgbG9uZ2VyIHRoYW4gZGVzaXJlZCBib3VuZHNcclxuICAgICAgICAgICAgaWYgKHRva2VuV2lkdGggPiB3b3JkV3JhcFdpZHRoKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBpZiB3ZSBhcmUgbm90IGFscmVhZHkgYXQgdGhlIGJlZ2lubmluZyBvZiBhIGxpbmVcclxuICAgICAgICAgICAgICAgIGlmIChsaW5lICE9PSAnJykge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHN0YXJ0IG5ld2xpbmVzIGZvciBvdmVyZmxvdyB3b3Jkc1xyXG4gICAgICAgICAgICAgICAgICAgIGxpbmVzICs9IFRleHRNZXRyaWNzLmFkZExpbmUobGluZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGluZSA9ICcnO1xyXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoID0gMDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIGJyZWFrIGxhcmdlIHdvcmQgb3ZlciBtdWx0aXBsZSBsaW5lc1xyXG4gICAgICAgICAgICAgICAgaWYgKFRleHRNZXRyaWNzLmNhbkJyZWFrV29yZHModG9rZW4sIHN0eWxlLmJyZWFrV29yZHMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYnJlYWsgd29yZCBpbnRvIGNoYXJhY3RlcnNcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY2hhcmFjdGVycyA9IHRva2VuLnNwbGl0KCcnKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBsb29wIHRoZSBjaGFyYWN0ZXJzXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjaGFyYWN0ZXJzLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjaGFyID0gY2hhcmFjdGVyc1tqXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGsgPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSBhcmUgbm90IGF0IHRoZSBlbmQgb2YgdGhlIHRva2VuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChjaGFyYWN0ZXJzW2ogKyBrXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5leHRDaGFyID0gY2hhcmFjdGVyc1tqICsga107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGFzdENoYXIgPSBjaGFyW2NoYXIubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzaG91bGQgbm90IHNwbGl0IGNoYXJzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIVRleHRNZXRyaWNzLmNhbkJyZWFrQ2hhcnMobGFzdENoYXIsIG5leHRDaGFyLCB0b2tlbiwgaiwgc3R5bGUuYnJlYWtXb3JkcykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjb21iaW5lIGNoYXJzICYgbW92ZSBmb3J3YXJkIG9uZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYXIgKz0gbmV4dENoYXI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGsrKztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBqICs9IGNoYXIubGVuZ3RoIC0gMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNoYXJhY3RlcldpZHRoID0gVGV4dE1ldHJpY3MuZ2V0RnJvbUNhY2hlKGNoYXIsIGxldHRlclNwYWNpbmcsIGNhY2hlLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoYXJhY3RlcldpZHRoICsgd2lkdGggPiB3b3JkV3JhcFdpZHRoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lcyArPSBUZXh0TWV0cmljcy5hZGRMaW5lKGxpbmUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FuUHJlcGVuZFNwYWNlcyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZSA9ICcnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGggPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmUgKz0gY2hhcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGggKz0gY2hhcmFjdGVyV2lkdGg7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gcnVuIHdvcmQgb3V0IG9mIHRoZSBib3VuZHNcclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZXJlIGFyZSB3b3JkcyBpbiB0aGlzIGxpbmUgYWxyZWFkeVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGZpbmlzaCB0aGF0IGxpbmUgYW5kIHN0YXJ0IGEgbmV3IG9uZVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChsaW5lLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGluZXMgKz0gVGV4dE1ldHJpY3MuYWRkTGluZShsaW5lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGluZSA9ICcnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpc0xhc3RUb2tlbiA9IGkgPT09IHRva2Vucy5sZW5ndGggLSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGdpdmUgaXQgaXRzIG93biBsaW5lIGlmIGl0J3Mgbm90IHRoZSBlbmRcclxuICAgICAgICAgICAgICAgICAgICBsaW5lcyArPSBUZXh0TWV0cmljcy5hZGRMaW5lKHRva2VuLCAhaXNMYXN0VG9rZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhblByZXBlbmRTcGFjZXMgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICBsaW5lID0gJyc7XHJcbiAgICAgICAgICAgICAgICAgICAgd2lkdGggPSAwO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHdvcmQgY291bGQgZml0XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gd29yZCB3b24ndCBmaXQgYmVjYXVzZSBvZiBleGlzdGluZyB3b3Jkc1xyXG4gICAgICAgICAgICAgICAgLy8gc3RhcnQgYSBuZXcgbGluZVxyXG4gICAgICAgICAgICAgICAgaWYgKHRva2VuV2lkdGggKyB3aWR0aCA+IHdvcmRXcmFwV2lkdGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBpZiBpdHMgYSBzcGFjZSB3ZSBkb24ndCB3YW50IGl0XHJcbiAgICAgICAgICAgICAgICAgICAgY2FuUHJlcGVuZFNwYWNlcyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGFkZCBhIG5ldyBsaW5lXHJcbiAgICAgICAgICAgICAgICAgICAgbGluZXMgKz0gVGV4dE1ldHJpY3MuYWRkTGluZShsaW5lKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBzdGFydCBhIG5ldyBsaW5lXHJcbiAgICAgICAgICAgICAgICAgICAgbGluZSA9ICcnO1xyXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoID0gMDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIGRvbid0IGFkZCBzcGFjZXMgdG8gdGhlIGJlZ2lubmluZyBvZiBsaW5lc1xyXG4gICAgICAgICAgICAgICAgaWYgKGxpbmUubGVuZ3RoID4gMCB8fCAhVGV4dE1ldHJpY3MuaXNCcmVha2luZ1NwYWNlKHRva2VuKSB8fCBjYW5QcmVwZW5kU3BhY2VzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYWRkIHRoZSB3b3JkIHRvIHRoZSBjdXJyZW50IGxpbmVcclxuICAgICAgICAgICAgICAgICAgICBsaW5lICs9IHRva2VuO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSB3aWR0aCBjb3VudGVyXHJcbiAgICAgICAgICAgICAgICAgICAgd2lkdGggKz0gdG9rZW5XaWR0aDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBsaW5lcyArPSBUZXh0TWV0cmljcy5hZGRMaW5lKGxpbmUsIGZhbHNlKTtcclxuICAgICAgICByZXR1cm4gbGluZXM7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIENvbnZpZW5pZW5jZSBmdW5jdGlvbiBmb3IgbG9nZ2luZyBlYWNoIGxpbmUgYWRkZWQgZHVyaW5nIHRoZSB3b3JkV3JhcFxyXG4gICAgICogbWV0aG9kXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSAge3N0cmluZ30gICBsaW5lICAgIC0gVGhlIGxpbmUgb2YgdGV4dCB0byBhZGRcclxuICAgICAqIEBwYXJhbSAge2Jvb2xlYW59ICBuZXdMaW5lIC0gQWRkIG5ldyBsaW5lIGNoYXJhY3RlciB0byBlbmRcclxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gICBBIGZvcm1hdHRlZCBsaW5lXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBhZGRMaW5lKGxpbmUsIG5ld0xpbmUgPSB0cnVlKSB7XHJcbiAgICAgICAgaWYgKG5ld0xpbmUgPT09IHZvaWQgMCkge1xyXG4gICAgICAgICAgICBuZXdMaW5lID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGluZSA9IFRleHRNZXRyaWNzLnRyaW1SaWdodChsaW5lKTtcclxuICAgICAgICBsaW5lID0gKG5ld0xpbmUpID8gKGxpbmUgKyBcIlxcblwiKSA6IGxpbmU7XHJcbiAgICAgICAgcmV0dXJuIGxpbmU7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgJiBzZXRzIHRoZSB3aWR0aHMgb2YgY2FsY3VsYXRlZCBjaGFyYWN0ZXJzIGluIGEgY2FjaGUgb2JqZWN0XHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSAge3N0cmluZ30gICAgICAgICAgICAgICAga2V5ICAgICAgICBUaGUga2V5XHJcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9ICAgICAgICAgICAgICAgIGxldHRlclNwYWNpbmcgIFRoZSBsZXR0ZXIgc3BhY2luZ1xyXG4gICAgICogQHBhcmFtICB7b2JqZWN0fSAgICAgICAgICAgICAgICBjYWNoZSAgICAgIFRoZSBjYWNoZVxyXG4gICAgICogQHBhcmFtICB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSAgY29udGV4dCAgICBUaGUgY2FudmFzIGNvbnRleHRcclxuICAgICAqIEByZXR1cm4ge251bWJlcn0gICAgICAgICAgICAgICAgVGhlIGZyb20gY2FjaGUuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBnZXRGcm9tQ2FjaGUoa2V5LCBsZXR0ZXJTcGFjaW5nLCBjYWNoZSwgY29udGV4dCkge1xyXG4gICAgICAgIHZhciB3aWR0aCA9IGNhY2hlW2tleV07XHJcbiAgICAgICAgaWYgKHdpZHRoID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdmFyIHNwYWNpbmcgPSAoKGtleS5sZW5ndGgpICogbGV0dGVyU3BhY2luZyk7XHJcbiAgICAgICAgICAgIHdpZHRoID0gY29udGV4dC5tZWFzdXJlVGV4dChrZXkpLndpZHRoICsgc3BhY2luZztcclxuICAgICAgICAgICAgY2FjaGVba2V5XSA9IHdpZHRoO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gd2lkdGg7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIERldGVybWluZXMgd2hldGhlciB3ZSBzaG91bGQgY29sbGFwc2UgYnJlYWtpbmcgc3BhY2VzXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSAge3N0cmluZ30gICB3aGl0ZVNwYWNlICBUaGUgVGV4dFN0eWxlIHByb3BlcnR5IHdoaXRlU3BhY2VcclxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59ICBzaG91bGQgY29sbGFwc2VcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGNvbGxhcHNlU3BhY2VzKHdoaXRlU3BhY2UpIHtcclxuICAgICAgICByZXR1cm4gKHdoaXRlU3BhY2UgPT09ICdub3JtYWwnIHx8IHdoaXRlU3BhY2UgPT09ICdwcmUtbGluZScpO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgd2Ugc2hvdWxkIGNvbGxhcHNlIG5ld0xpbmUgY2hhcnNcclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSAgIHdoaXRlU3BhY2UgIFRoZSB3aGl0ZSBzcGFjZVxyXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gIHNob3VsZCBjb2xsYXBzZVxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgY29sbGFwc2VOZXdsaW5lcyh3aGl0ZVNwYWNlKSB7XHJcbiAgICAgICAgcmV0dXJuICh3aGl0ZVNwYWNlID09PSAnbm9ybWFsJyk7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIHRyaW1zIGJyZWFraW5nIHdoaXRlc3BhY2VzIGZyb20gc3RyaW5nXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSAge3N0cmluZ30gIHRleHQgIFRoZSB0ZXh0XHJcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9ICB0cmltbWVkIHN0cmluZ1xyXG4gICAgICovXHJcbiAgICBzdGF0aWMgdHJpbVJpZ2h0KHRleHQpIHtcclxuICAgICAgICBpZiAodHlwZW9mIHRleHQgIT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnJztcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IHRleHQubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICAgICAgdmFyIGNoYXIgPSB0ZXh0W2ldO1xyXG4gICAgICAgICAgICBpZiAoIVRleHRNZXRyaWNzLmlzQnJlYWtpbmdTcGFjZShjaGFyKSkge1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGV4dCA9IHRleHQuc2xpY2UoMCwgLTEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGV4dDtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogRGV0ZXJtaW5lcyBpZiBjaGFyIGlzIGEgbmV3bGluZS5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSAgY2hhciAgVGhlIGNoYXJhY3RlclxyXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gIFRydWUgaWYgbmV3bGluZSwgRmFsc2Ugb3RoZXJ3aXNlLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgaXNOZXdsaW5lKGNoYXIpIHtcclxuICAgICAgICBpZiAodHlwZW9mIGNoYXIgIT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIChUZXh0TWV0cmljcy5fbmV3bGluZXMuaW5kZXhPZihjaGFyLmNoYXJDb2RlQXQoMCkpID49IDApO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBEZXRlcm1pbmVzIGlmIGNoYXIgaXMgYSBicmVha2luZyB3aGl0ZXNwYWNlLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9ICBjaGFyICBUaGUgY2hhcmFjdGVyXHJcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSAgVHJ1ZSBpZiB3aGl0ZXNwYWNlLCBGYWxzZSBvdGhlcndpc2UuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBpc0JyZWFraW5nU3BhY2UoY2hhcikge1xyXG4gICAgICAgIGlmICh0eXBlb2YgY2hhciAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gKFRleHRNZXRyaWNzLl9icmVha2luZ1NwYWNlcy5pbmRleE9mKGNoYXIuY2hhckNvZGVBdCgwKSkgPj0gMCk7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFNwbGl0cyBhIHN0cmluZyBpbnRvIHdvcmRzLCBicmVha2luZy1zcGFjZXMgYW5kIG5ld0xpbmUgY2hhcmFjdGVyc1xyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9ICB0ZXh0ICAgVGhlIHRleHRcclxuICAgICAqIEByZXR1cm4ge3N0cmluZ1tdfSAgQSB0b2tlbml6ZWQgYXJyYXlcclxuICAgICAqL1xyXG4gICAgc3RhdGljIHRva2VuaXplKHRleHQpIHtcclxuICAgICAgICB2YXIgdG9rZW5zID0gW107XHJcbiAgICAgICAgdmFyIHRva2VuID0gJyc7XHJcbiAgICAgICAgaWYgKHR5cGVvZiB0ZXh0ICE9PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICByZXR1cm4gdG9rZW5zO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRleHQubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIGNoYXIgPSB0ZXh0W2ldO1xyXG4gICAgICAgICAgICBpZiAoVGV4dE1ldHJpY3MuaXNCcmVha2luZ1NwYWNlKGNoYXIpIHx8IFRleHRNZXRyaWNzLmlzTmV3bGluZShjaGFyKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRva2VuICE9PSAnJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcclxuICAgICAgICAgICAgICAgICAgICB0b2tlbiA9ICcnO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdG9rZW5zLnB1c2goY2hhcik7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0b2tlbiArPSBjaGFyO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodG9rZW4gIT09ICcnKSB7XHJcbiAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRva2VucztcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBtZXRob2QgZXhpc3RzIHRvIGJlIGVhc2lseSBvdmVycmlkZGVuXHJcbiAgICAgKiBJdCBhbGxvd3Mgb25lIHRvIGN1c3RvbWlzZSB3aGljaCB3b3JkcyBzaG91bGQgYnJlYWtcclxuICAgICAqIEV4YW1wbGVzIGFyZSBpZiB0aGUgdG9rZW4gaXMgQ0pLIG9yIG51bWJlcnMuXHJcbiAgICAgKiBJdCBtdXN0IHJldHVybiBhIGJvb2xlYW4uXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSAge3N0cmluZ30gIHRva2VuICAgVGhlIHRva2VuXHJcbiAgICAgKiBAcGFyYW0gIHtib29sZWFufSAgYnJlYWtXb3JkcyAgVGhlIHN0eWxlIGF0dHIgYnJlYWsgd29yZHNcclxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IHdoZXRoZXIgdG8gYnJlYWsgd29yZCBvciBub3RcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGNhbkJyZWFrV29yZHModG9rZW4sIGJyZWFrV29yZHMpIHtcclxuICAgICAgICByZXR1cm4gYnJlYWtXb3JkcztcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBtZXRob2QgZXhpc3RzIHRvIGJlIGVhc2lseSBvdmVycmlkZGVuXHJcbiAgICAgKiBJdCBhbGxvd3Mgb25lIHRvIGRldGVybWluZSB3aGV0aGVyIGEgcGFpciBvZiBjaGFyYWN0ZXJzXHJcbiAgICAgKiBzaG91bGQgYmUgYnJva2VuIGJ5IG5ld2xpbmVzXHJcbiAgICAgKiBGb3IgZXhhbXBsZSBjZXJ0YWluIGNoYXJhY3RlcnMgaW4gQ0pLIGxhbmdzIG9yIG51bWJlcnMuXHJcbiAgICAgKiBJdCBtdXN0IHJldHVybiBhIGJvb2xlYW4uXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSAge3N0cmluZ30gIGNoYXIgIFRoZSBjaGFyYWN0ZXJcclxuICAgICAqIEBwYXJhbSAge3N0cmluZ30gIG5leHRDaGFyICBUaGUgbmV4dCBjaGFyYWN0ZXJcclxuICAgICAqIEBwYXJhbSAge3N0cmluZ30gIHRva2VuIFRoZSB0b2tlbi93b3JkIHRoZSBjaGFyYWN0ZXJzIGFyZSBmcm9tXHJcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9ICBpbmRleCBUaGUgaW5kZXggaW4gdGhlIHRva2VuIG9mIHRoZSBjaGFyXHJcbiAgICAgKiBAcGFyYW0gIHtib29sZWFufSAgYnJlYWtXb3JkcyAgVGhlIHN0eWxlIGF0dHIgYnJlYWsgd29yZHNcclxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IHdoZXRoZXIgdG8gYnJlYWsgd29yZCBvciBub3RcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGNhbkJyZWFrQ2hhcnMoY2hhciwgbmV4dENoYXIsIHRva2VuLCBpbmRleCwgYnJlYWtXb3Jkcykge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxjdWxhdGVzIHRoZSBhc2NlbnQsIGRlc2NlbnQgYW5kIGZvbnRTaXplIG9mIGEgZ2l2ZW4gZm9udC1zdHlsZVxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmb250IC0gU3RyaW5nIHJlcHJlc2VudGluZyB0aGUgc3R5bGUgb2YgdGhlIGZvbnRcclxuICAgICAqIEByZXR1cm4ge1BJWEkuSUZvbnRNZXRyaWNzfSBGb250IHByb3BlcnRpZXMgb2JqZWN0XHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBtZWFzdXJlRm9udChmb250KSB7XHJcbiAgICAgICAgLy8gYXMgdGhpcyBtZXRob2QgaXMgdXNlZCBmb3IgcHJlcGFyaW5nIGFzc2V0cywgZG9uJ3QgcmVjYWxjdWxhdGUgdGhpbmdzIGlmIHdlIGRvbid0IG5lZWQgdG9cclxuICAgICAgICBpZiAoVGV4dE1ldHJpY3MuX2ZvbnRzW2ZvbnRdKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBUZXh0TWV0cmljcy5fZm9udHNbZm9udF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBwcm9wZXJ0aWVzID0ge307XHJcbiAgICAgICAgdmFyIGNhbnZhcyA9IFRleHRNZXRyaWNzLl9jYW52YXM7XHJcbiAgICAgICAgdmFyIGNvbnRleHQgPSBUZXh0TWV0cmljcy5fY29udGV4dDtcclxuICAgICAgICBjb250ZXh0LmZvbnQgPSBmb250O1xyXG4gICAgICAgIHZhciBtZXRyaWNzU3RyaW5nID0gVGV4dE1ldHJpY3MuTUVUUklDU19TVFJJTkcgKyBUZXh0TWV0cmljcy5CQVNFTElORV9TWU1CT0w7XHJcbiAgICAgICAgdmFyIHdpZHRoID0gTWF0aC5jZWlsKGNvbnRleHQubWVhc3VyZVRleHQobWV0cmljc1N0cmluZykud2lkdGgpO1xyXG4gICAgICAgIHZhciBiYXNlbGluZSA9IE1hdGguY2VpbChjb250ZXh0Lm1lYXN1cmVUZXh0KFRleHRNZXRyaWNzLkJBU0VMSU5FX1NZTUJPTCkud2lkdGgpO1xyXG4gICAgICAgIHZhciBoZWlnaHQgPSAyICogYmFzZWxpbmU7XHJcbiAgICAgICAgYmFzZWxpbmUgPSBiYXNlbGluZSAqIFRleHRNZXRyaWNzLkJBU0VMSU5FX01VTFRJUExJRVIgfCAwO1xyXG4gICAgICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoO1xyXG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XHJcbiAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSAnI2YwMCc7XHJcbiAgICAgICAgY29udGV4dC5maWxsUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcclxuICAgICAgICBjb250ZXh0LmZvbnQgPSBmb250O1xyXG4gICAgICAgIGNvbnRleHQudGV4dEJhc2VsaW5lID0gJ2FscGhhYmV0aWMnO1xyXG4gICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gJyMwMDAnO1xyXG4gICAgICAgIGNvbnRleHQuZmlsbFRleHQobWV0cmljc1N0cmluZywgMCwgYmFzZWxpbmUpO1xyXG4gICAgICAgIHZhciBpbWFnZWRhdGEgPSBjb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCB3aWR0aCwgaGVpZ2h0KS5kYXRhO1xyXG4gICAgICAgIHZhciBwaXhlbHMgPSBpbWFnZWRhdGEubGVuZ3RoO1xyXG4gICAgICAgIHZhciBsaW5lID0gd2lkdGggKiA0O1xyXG4gICAgICAgIHZhciBpID0gMDtcclxuICAgICAgICB2YXIgaWR4ID0gMDtcclxuICAgICAgICB2YXIgc3RvcCA9IGZhbHNlO1xyXG4gICAgICAgIC8vIGFzY2VudC4gc2NhbiBmcm9tIHRvcCB0byBib3R0b20gdW50aWwgd2UgZmluZCBhIG5vbiByZWQgcGl4ZWxcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYmFzZWxpbmU7ICsraSkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxpbmU7IGogKz0gNCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGltYWdlZGF0YVtpZHggKyBqXSAhPT0gMjU1KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RvcCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFzdG9wKSB7XHJcbiAgICAgICAgICAgICAgICBpZHggKz0gbGluZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHByb3BlcnRpZXMuYXNjZW50ID0gYmFzZWxpbmUgLSBpO1xyXG4gICAgICAgIGlkeCA9IHBpeGVscyAtIGxpbmU7XHJcbiAgICAgICAgc3RvcCA9IGZhbHNlO1xyXG4gICAgICAgIC8vIGRlc2NlbnQuIHNjYW4gZnJvbSBib3R0b20gdG8gdG9wIHVudGlsIHdlIGZpbmQgYSBub24gcmVkIHBpeGVsXHJcbiAgICAgICAgZm9yIChpID0gaGVpZ2h0OyBpID4gYmFzZWxpbmU7IC0taSkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBqJDEgPSAwOyBqJDEgPCBsaW5lOyBqJDEgKz0gNCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGltYWdlZGF0YVtpZHggKyBqJDFdICE9PSAyNTUpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdG9wID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIXN0b3ApIHtcclxuICAgICAgICAgICAgICAgIGlkeCAtPSBsaW5lO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcHJvcGVydGllcy5kZXNjZW50ID0gaSAtIGJhc2VsaW5lO1xyXG4gICAgICAgIHByb3BlcnRpZXMuZm9udFNpemUgPSBwcm9wZXJ0aWVzLmFzY2VudCArIHByb3BlcnRpZXMuZGVzY2VudDtcclxuICAgICAgICBUZXh0TWV0cmljcy5fZm9udHNbZm9udF0gPSBwcm9wZXJ0aWVzO1xyXG4gICAgICAgIHJldHVybiBwcm9wZXJ0aWVzO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDbGVhciBmb250IG1ldHJpY3MgaW4gbWV0cmljcyBjYWNoZS5cclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2ZvbnRdIC0gZm9udCBuYW1lLiBJZiBmb250IG5hbWUgbm90IHNldCB0aGVuIGNsZWFyIGNhY2hlIGZvciBhbGwgZm9udHMuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBjbGVhck1ldHJpY3MoZm9udCkge1xyXG4gICAgICAgIGlmIChmb250ID09PSB2b2lkIDApIHtcclxuICAgICAgICAgICAgZm9udCA9ICcnO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZm9udCkge1xyXG4gICAgICAgICAgICBkZWxldGUgVGV4dE1ldHJpY3MuX2ZvbnRzW2ZvbnRdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgVGV4dE1ldHJpY3MuX2ZvbnRzID0ge307XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgO1xyXG59XHJcbi8qKlxyXG4gKiBJbnRlcm5hbCByZXR1cm4gb2JqZWN0IGZvciB7QGxpbmsgUElYSS5UZXh0TWV0cmljcy5tZWFzdXJlRm9udCBgVGV4dE1ldHJpY3MubWVhc3VyZUZvbnRgfS5cclxuICpcclxuICogQHR5cGVkZWYge29iamVjdH0gRm9udE1ldHJpY3NcclxuICogQHByb3BlcnR5IHtudW1iZXJ9IGFzY2VudCAtIFRoZSBhc2NlbnQgZGlzdGFuY2VcclxuICogQHByb3BlcnR5IHtudW1iZXJ9IGRlc2NlbnQgLSBUaGUgZGVzY2VudCBkaXN0YW5jZVxyXG4gKiBAcHJvcGVydHkge251bWJlcn0gZm9udFNpemUgLSBGb250IHNpemUgZnJvbSBhc2NlbnQgdG8gZGVzY2VudFxyXG4gKiBAbWVtYmVyb2YgUElYSS5UZXh0TWV0cmljc1xyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuLyoqXHJcbiAqIENhY2hlIG9mIHtAc2VlIFBJWEkuVGV4dE1ldHJpY3MuRm9udE1ldHJpY3N9IG9iamVjdHMuXHJcbiAqIEBtZW1iZXJvZiBQSVhJLlRleHRNZXRyaWNzXHJcbiAqIEB0eXBlIHtPYmplY3R9XHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5UZXh0TWV0cmljcy5fZm9udHMgPSB7fTtcclxuLyoqXHJcbiAqIFN0cmluZyB1c2VkIGZvciBjYWxjdWxhdGUgZm9udCBtZXRyaWNzLlxyXG4gKiBAc3RhdGljXHJcbiAqIEBtZW1iZXJvZiBQSVhJLlRleHRNZXRyaWNzXHJcbiAqIEBuYW1lIE1FVFJJQ1NfU1RSSU5HXHJcbiAqIEB0eXBlIHtzdHJpbmd9XHJcbiAqIEBkZWZhdWx0IHzDiXFcclxuICovXHJcblRleHRNZXRyaWNzLk1FVFJJQ1NfU1RSSU5HID0gJ3zDiXEnO1xyXG4vKipcclxuICogQmFzZWxpbmUgc3ltYm9sIGZvciBjYWxjdWxhdGUgZm9udCBtZXRyaWNzLlxyXG4gKiBAc3RhdGljXHJcbiAqIEBtZW1iZXJvZiBQSVhJLlRleHRNZXRyaWNzXHJcbiAqIEBuYW1lIEJBU0VMSU5FX1NZTUJPTFxyXG4gKiBAdHlwZSB7c3RyaW5nfVxyXG4gKiBAZGVmYXVsdCBNXHJcbiAqL1xyXG5UZXh0TWV0cmljcy5CQVNFTElORV9TWU1CT0wgPSAnTSc7XHJcbi8qKlxyXG4gKiBCYXNlbGluZSBtdWx0aXBsaWVyIGZvciBjYWxjdWxhdGUgZm9udCBtZXRyaWNzLlxyXG4gKiBAc3RhdGljXHJcbiAqIEBtZW1iZXJvZiBQSVhJLlRleHRNZXRyaWNzXHJcbiAqIEBuYW1lIEJBU0VMSU5FX01VTFRJUExJRVJcclxuICogQHR5cGUge251bWJlcn1cclxuICogQGRlZmF1bHQgMS40XHJcbiAqL1xyXG5UZXh0TWV0cmljcy5CQVNFTElORV9NVUxUSVBMSUVSID0gMS40O1xyXG4vKipcclxuICogQ2FjaGUgb2YgbmV3IGxpbmUgY2hhcnMuXHJcbiAqIEBtZW1iZXJvZiBQSVhJLlRleHRNZXRyaWNzXHJcbiAqIEB0eXBlIHtudW1iZXJbXX1cclxuICogQHByaXZhdGVcclxuICovXHJcblRleHRNZXRyaWNzLl9uZXdsaW5lcyA9IFtcclxuICAgIDB4MDAwQSxcclxuICAgIDB4MDAwRFxyXG5dO1xyXG4vKipcclxuICogQ2FjaGUgb2YgYnJlYWtpbmcgc3BhY2VzLlxyXG4gKiBAbWVtYmVyb2YgUElYSS5UZXh0TWV0cmljc1xyXG4gKiBAdHlwZSB7bnVtYmVyW119XHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5UZXh0TWV0cmljcy5fYnJlYWtpbmdTcGFjZXMgPSBbXHJcbiAgICAweDAwMDksXHJcbiAgICAweDAwMjAsXHJcbiAgICAweDIwMDAsXHJcbiAgICAweDIwMDEsXHJcbiAgICAweDIwMDIsXHJcbiAgICAweDIwMDMsXHJcbiAgICAweDIwMDQsXHJcbiAgICAweDIwMDUsXHJcbiAgICAweDIwMDYsXHJcbiAgICAweDIwMDgsXHJcbiAgICAweDIwMDksXHJcbiAgICAweDIwMEEsXHJcbiAgICAweDIwNUYsXHJcbiAgICAweDMwMDBcclxuXTtcclxuZXhwb3J0cy5UZXh0TWV0cmljcyA9IFRleHRNZXRyaWNzO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jbGFzcyBUZXh0U2V0dGluZ3Mge1xyXG59XHJcblRleHRTZXR0aW5ncy5URVhUX0dSQURJRU5UID0ge1xyXG4gICAgTElORUFSX1ZFUlRJQ0FMOiAwLFxyXG4gICAgTElORUFSX0hPUklaT05UQUw6IDEsXHJcbn07XHJcblRleHRTZXR0aW5ncy5kZWZhdWx0U3R5bGUgPSB7XHJcbiAgICBhbGlnbjogJ2xlZnQnLFxyXG4gICAgYnJlYWtXb3JkczogZmFsc2UsXHJcbiAgICBkcm9wU2hhZG93OiBmYWxzZSxcclxuICAgIGRyb3BTaGFkb3dBbHBoYTogMSxcclxuICAgIGRyb3BTaGFkb3dBbmdsZTogTWF0aC5QSSAvIDYsXHJcbiAgICBkcm9wU2hhZG93Qmx1cjogMCxcclxuICAgIGRyb3BTaGFkb3dDb2xvcjogJ2JsYWNrJyxcclxuICAgIGRyb3BTaGFkb3dEaXN0YW5jZTogNSxcclxuICAgIGZpbGw6ICdibGFjaycsXHJcbiAgICBmaWxsR3JhZGllbnRUeXBlOiBUZXh0U2V0dGluZ3MuVEVYVF9HUkFESUVOVC5MSU5FQVJfVkVSVElDQUwsXHJcbiAgICBmaWxsR3JhZGllbnRTdG9wczogW10sXHJcbiAgICBmb250RmFtaWx5OiAnQXJpYWwnLFxyXG4gICAgZm9udFNpemU6IDI2LFxyXG4gICAgZm9udFN0eWxlOiAnbm9ybWFsJyxcclxuICAgIGZvbnRWYXJpYW50OiAnbm9ybWFsJyxcclxuICAgIGZvbnRXZWlnaHQ6ICdub3JtYWwnLFxyXG4gICAgbGV0dGVyU3BhY2luZzogMCxcclxuICAgIGxpbmVIZWlnaHQ6IDAsXHJcbiAgICBsaW5lSm9pbjogJ21pdGVyJyxcclxuICAgIG1pdGVyTGltaXQ6IDEwLFxyXG4gICAgcGFkZGluZzogMCxcclxuICAgIHN0cm9rZTogJ2JsYWNrJyxcclxuICAgIHN0cm9rZVRoaWNrbmVzczogMCxcclxuICAgIHRleHRCYXNlbGluZTogJ2FscGhhYmV0aWMnLFxyXG4gICAgdHJpbTogZmFsc2UsXHJcbiAgICB3aGl0ZVNwYWNlOiAncHJlJyxcclxuICAgIHdvcmRXcmFwOiBmYWxzZSxcclxuICAgIHdvcmRXcmFwV2lkdGg6IDEwMCxcclxuICAgIGxlYWRpbmc6IDAsXHJcbn07XHJcbmV4cG9ydHMuVGV4dFNldHRpbmdzID0gVGV4dFNldHRpbmdzO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBUZXh0U2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL1RleHRTZXR0aW5nc1wiKTtcclxuY29uc3QgQ29sb3JTZXR0aW5nc18xID0gcmVxdWlyZShcIi4vQ29sb3JTZXR0aW5nc1wiKTtcclxuY29uc3QgVXRpbHNTZXR0aW5nc18xID0gcmVxdWlyZShcIi4vVXRpbHNTZXR0aW5nc1wiKTtcclxuY2xhc3MgVGV4dFN0eWxlIHtcclxuICAgIGNvbnN0cnVjdG9yKHN0eWxlKSB7XHJcbiAgICAgICAgdGhpcy5zdHlsZUlEID0gMDtcclxuICAgICAgICB0aGlzLnJlc2V0KCk7XHJcbiAgICAgICAgVXRpbHNTZXR0aW5nc18xLlV0aWxzU2V0dGluZ3MuZGVlcENvcHlQcm9wZXJ0aWVzKHRoaXMsIHN0eWxlLCBzdHlsZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgVGV4dFN0eWxlIG9iamVjdCB3aXRoIHRoZSBzYW1lIHZhbHVlcyBhcyB0aGlzIG9uZS5cclxuICAgICAqIE5vdGUgdGhhdCB0aGUgb25seSB0aGUgcHJvcGVydGllcyBvZiB0aGUgb2JqZWN0IGFyZSBjbG9uZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiB7UElYSS5UZXh0U3R5bGV9IE5ldyBjbG9uZWQgVGV4dFN0eWxlIG9iamVjdFxyXG4gICAgICovXHJcbiAgICBjbG9uZSgpIHtcclxuICAgICAgICB2YXIgY2xvbmVkUHJvcGVydGllcyA9IHt9O1xyXG4gICAgICAgIFV0aWxzU2V0dGluZ3NfMS5VdGlsc1NldHRpbmdzLmRlZXBDb3B5UHJvcGVydGllcyhjbG9uZWRQcm9wZXJ0aWVzLCB0aGlzLCBUZXh0U2V0dGluZ3NfMS5UZXh0U2V0dGluZ3MuZGVmYXVsdFN0eWxlKTtcclxuICAgICAgICByZXR1cm4gbmV3IFRleHRTdHlsZShjbG9uZWRQcm9wZXJ0aWVzKTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogUmVzZXRzIGFsbCBwcm9wZXJ0aWVzIHRvIHRoZSBkZWZhdWx0cyBzcGVjaWZpZWQgaW4gVGV4dFN0eWxlLnByb3RvdHlwZS5fZGVmYXVsdFxyXG4gICAgICovXHJcbiAgICByZXNldCgpIHtcclxuICAgICAgICBVdGlsc1NldHRpbmdzXzEuVXRpbHNTZXR0aW5ncy5kZWVwQ29weVByb3BlcnRpZXModGhpcywgVGV4dFNldHRpbmdzXzEuVGV4dFNldHRpbmdzLmRlZmF1bHRTdHlsZSwgVGV4dFNldHRpbmdzXzEuVGV4dFNldHRpbmdzLmRlZmF1bHRTdHlsZSk7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIEFsaWdubWVudCBmb3IgbXVsdGlsaW5lIHRleHQgKCdsZWZ0JywgJ2NlbnRlcicgb3IgJ3JpZ2h0JyksIGRvZXMgbm90IGFmZmVjdCBzaW5nbGUgbGluZSB0ZXh0XHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7c3RyaW5nfVxyXG4gICAgICovXHJcbiAgICBnZXQgYWxpZ24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FsaWduO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgc2V0IGFsaWduKGFsaWduKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2FsaWduICE9PSBhbGlnbikge1xyXG4gICAgICAgICAgICB0aGlzLl9hbGlnbiA9IGFsaWduO1xyXG4gICAgICAgICAgICB0aGlzLnN0eWxlSUQrKztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIEluZGljYXRlcyBpZiBsaW5lcyBjYW4gYmUgd3JhcHBlZCB3aXRoaW4gd29yZHMsIGl0IG5lZWRzIHdvcmRXcmFwIHRvIGJlIHNldCB0byB0cnVlXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgZ2V0IGJyZWFrV29yZHMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2JyZWFrV29yZHM7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICBzZXQgYnJlYWtXb3JkcyhicmVha1dvcmRzKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2JyZWFrV29yZHMgIT09IGJyZWFrV29yZHMpIHtcclxuICAgICAgICAgICAgdGhpcy5fYnJlYWtXb3JkcyA9IGJyZWFrV29yZHM7XHJcbiAgICAgICAgICAgIHRoaXMuc3R5bGVJRCsrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogU2V0IGEgZHJvcCBzaGFkb3cgZm9yIHRoZSB0ZXh0XHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgZ2V0IGRyb3BTaGFkb3coKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Ryb3BTaGFkb3c7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICBzZXQgZHJvcFNoYWRvdyhkcm9wU2hhZG93KSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2Ryb3BTaGFkb3cgIT09IGRyb3BTaGFkb3cpIHtcclxuICAgICAgICAgICAgdGhpcy5fZHJvcFNoYWRvdyA9IGRyb3BTaGFkb3c7XHJcbiAgICAgICAgICAgIHRoaXMuc3R5bGVJRCsrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogU2V0IGFscGhhIGZvciB0aGUgZHJvcCBzaGFkb3dcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIGdldCBkcm9wU2hhZG93QWxwaGEoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Ryb3BTaGFkb3dBbHBoYTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIHNldCBkcm9wU2hhZG93QWxwaGEoZHJvcFNoYWRvd0FscGhhKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2Ryb3BTaGFkb3dBbHBoYSAhPT0gZHJvcFNoYWRvd0FscGhhKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2Ryb3BTaGFkb3dBbHBoYSA9IGRyb3BTaGFkb3dBbHBoYTtcclxuICAgICAgICAgICAgdGhpcy5zdHlsZUlEKys7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgYSBhbmdsZSBvZiB0aGUgZHJvcCBzaGFkb3dcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIGdldCBkcm9wU2hhZG93QW5nbGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Ryb3BTaGFkb3dBbmdsZTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIHNldCBkcm9wU2hhZG93QW5nbGUoZHJvcFNoYWRvd0FuZ2xlKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2Ryb3BTaGFkb3dBbmdsZSAhPT0gZHJvcFNoYWRvd0FuZ2xlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2Ryb3BTaGFkb3dBbmdsZSA9IGRyb3BTaGFkb3dBbmdsZTtcclxuICAgICAgICAgICAgdGhpcy5zdHlsZUlEKys7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgYSBzaGFkb3cgYmx1ciByYWRpdXNcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIGdldCBkcm9wU2hhZG93Qmx1cigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZHJvcFNoYWRvd0JsdXI7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICBzZXQgZHJvcFNoYWRvd0JsdXIoZHJvcFNoYWRvd0JsdXIpIHtcclxuICAgICAgICBpZiAodGhpcy5fZHJvcFNoYWRvd0JsdXIgIT09IGRyb3BTaGFkb3dCbHVyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2Ryb3BTaGFkb3dCbHVyID0gZHJvcFNoYWRvd0JsdXI7XHJcbiAgICAgICAgICAgIHRoaXMuc3R5bGVJRCsrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQSBmaWxsIHN0eWxlIHRvIGJlIHVzZWQgb24gdGhlIGRyb3BzaGFkb3cgZS5nICdyZWQnLCAnIzAwRkYwMCdcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtzdHJpbmd8bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICBnZXQgZHJvcFNoYWRvd0NvbG9yKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9kcm9wU2hhZG93Q29sb3I7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICBzZXQgZHJvcFNoYWRvd0NvbG9yKGRyb3BTaGFkb3dDb2xvcikge1xyXG4gICAgICAgIHZhciBvdXRwdXRDb2xvciA9IENvbG9yU2V0dGluZ3NfMS5Db2xvclNldHRpbmdzLmdldENvbG9yKGRyb3BTaGFkb3dDb2xvcik7XHJcbiAgICAgICAgaWYgKHRoaXMuX2Ryb3BTaGFkb3dDb2xvciAhPT0gb3V0cHV0Q29sb3IpIHtcclxuICAgICAgICAgICAgdGhpcy5fZHJvcFNoYWRvd0NvbG9yID0gb3V0cHV0Q29sb3I7XHJcbiAgICAgICAgICAgIHRoaXMuc3R5bGVJRCsrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogU2V0IGEgZGlzdGFuY2Ugb2YgdGhlIGRyb3Agc2hhZG93XHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICBnZXQgZHJvcFNoYWRvd0Rpc3RhbmNlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9kcm9wU2hhZG93RGlzdGFuY2U7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICBzZXQgZHJvcFNoYWRvd0Rpc3RhbmNlKGRyb3BTaGFkb3dEaXN0YW5jZSkge1xyXG4gICAgICAgIGlmICh0aGlzLl9kcm9wU2hhZG93RGlzdGFuY2UgIT09IGRyb3BTaGFkb3dEaXN0YW5jZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9kcm9wU2hhZG93RGlzdGFuY2UgPSBkcm9wU2hhZG93RGlzdGFuY2U7XHJcbiAgICAgICAgICAgIHRoaXMuc3R5bGVJRCsrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQSBjYW52YXMgZmlsbHN0eWxlIHRoYXQgd2lsbCBiZSB1c2VkIG9uIHRoZSB0ZXh0IGUuZyAncmVkJywgJyMwMEZGMDAnLlxyXG4gICAgICogQ2FuIGJlIGFuIGFycmF5IHRvIGNyZWF0ZSBhIGdyYWRpZW50IGVnIFsnIzAwMDAwMCcsJyNGRkZGRkYnXVxyXG4gICAgICoge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQvZmlsbFN0eWxlfE1ETn1cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtzdHJpbmd8c3RyaW5nW118bnVtYmVyfG51bWJlcltdfENhbnZhc0dyYWRpZW50fENhbnZhc1BhdHRlcm59XHJcbiAgICAgKi9cclxuICAgIGdldCBmaWxsKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9maWxsO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgc2V0IGZpbGwoZmlsbCkge1xyXG4gICAgICAgIHZhciBvdXRwdXRDb2xvciA9IENvbG9yU2V0dGluZ3NfMS5Db2xvclNldHRpbmdzLmdldENvbG9yKGZpbGwpO1xyXG4gICAgICAgIGlmICh0aGlzLl9maWxsICE9PSBvdXRwdXRDb2xvcikge1xyXG4gICAgICAgICAgICB0aGlzLl9maWxsID0gb3V0cHV0Q29sb3I7XHJcbiAgICAgICAgICAgIHRoaXMuc3R5bGVJRCsrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogSWYgZmlsbCBpcyBhbiBhcnJheSBvZiBjb2xvdXJzIHRvIGNyZWF0ZSBhIGdyYWRpZW50LCB0aGlzIGNhbiBjaGFuZ2UgdGhlIHR5cGUvZGlyZWN0aW9uIG9mIHRoZSBncmFkaWVudC5cclxuICAgICAqIFNlZSB7QGxpbmsgUElYSS5URVhUX0dSQURJRU5UfVxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgZ2V0IGZpbGxHcmFkaWVudFR5cGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZpbGxHcmFkaWVudFR5cGU7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICBzZXQgZmlsbEdyYWRpZW50VHlwZShmaWxsR3JhZGllbnRUeXBlKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2ZpbGxHcmFkaWVudFR5cGUgIT09IGZpbGxHcmFkaWVudFR5cGUpIHtcclxuICAgICAgICAgICAgdGhpcy5fZmlsbEdyYWRpZW50VHlwZSA9IGZpbGxHcmFkaWVudFR5cGU7XHJcbiAgICAgICAgICAgIHRoaXMuc3R5bGVJRCsrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogSWYgZmlsbCBpcyBhbiBhcnJheSBvZiBjb2xvdXJzIHRvIGNyZWF0ZSBhIGdyYWRpZW50LCB0aGlzIGFycmF5IGNhbiBzZXQgdGhlIHN0b3AgcG9pbnRzXHJcbiAgICAgKiAobnVtYmVycyBiZXR3ZWVuIDAgYW5kIDEpIGZvciB0aGUgY29sb3IsIG92ZXJyaWRpbmcgdGhlIGRlZmF1bHQgYmVoYXZpb3VyIG9mIGV2ZW5seSBzcGFjaW5nIHRoZW0uXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7bnVtYmVyW119XHJcbiAgICAgKi9cclxuICAgIGdldCBmaWxsR3JhZGllbnRTdG9wcygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZmlsbEdyYWRpZW50U3RvcHM7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICBzZXQgZmlsbEdyYWRpZW50U3RvcHMoZmlsbEdyYWRpZW50U3RvcHMpIHtcclxuICAgICAgICBpZiAoIVV0aWxzU2V0dGluZ3NfMS5VdGlsc1NldHRpbmdzLmFyZUFycmF5c0VxdWFsKHRoaXMuX2ZpbGxHcmFkaWVudFN0b3BzLCBmaWxsR3JhZGllbnRTdG9wcykpIHtcclxuICAgICAgICAgICAgdGhpcy5fZmlsbEdyYWRpZW50U3RvcHMgPSBmaWxsR3JhZGllbnRTdG9wcztcclxuICAgICAgICAgICAgdGhpcy5zdHlsZUlEKys7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgZm9udCBmYW1pbHlcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtzdHJpbmd8c3RyaW5nW119XHJcbiAgICAgKi9cclxuICAgIGdldCBmb250RmFtaWx5KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9mb250RmFtaWx5O1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgc2V0IGZvbnRGYW1pbHkoZm9udEZhbWlseSkge1xyXG4gICAgICAgIGlmICh0aGlzLmZvbnRGYW1pbHkgIT09IGZvbnRGYW1pbHkpIHtcclxuICAgICAgICAgICAgdGhpcy5fZm9udEZhbWlseSA9IGZvbnRGYW1pbHk7XHJcbiAgICAgICAgICAgIHRoaXMuc3R5bGVJRCsrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGZvbnQgc2l6ZVxyXG4gICAgICogKGFzIGEgbnVtYmVyIGl0IGNvbnZlcnRzIHRvIHB4LCBidXQgYXMgYSBzdHJpbmcsIGVxdWl2YWxlbnRzIGFyZSAnMjZweCcsJzIwcHQnLCcxNjAlJyBvciAnMS42ZW0nKVxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge251bWJlcnxzdHJpbmd9XHJcbiAgICAgKi9cclxuICAgIGdldCBmb250U2l6ZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZm9udFNpemU7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICBzZXQgZm9udFNpemUoZm9udFNpemUpIHtcclxuICAgICAgICBpZiAodGhpcy5fZm9udFNpemUgIT09IGZvbnRTaXplKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2ZvbnRTaXplID0gZm9udFNpemU7XHJcbiAgICAgICAgICAgIHRoaXMuc3R5bGVJRCsrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGZvbnQgc3R5bGVcclxuICAgICAqICgnbm9ybWFsJywgJ2l0YWxpYycgb3IgJ29ibGlxdWUnKVxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge3N0cmluZ31cclxuICAgICAqL1xyXG4gICAgZ2V0IGZvbnRTdHlsZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZm9udFN0eWxlO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgc2V0IGZvbnRTdHlsZShmb250U3R5bGUpIHtcclxuICAgICAgICBpZiAodGhpcy5fZm9udFN0eWxlICE9PSBmb250U3R5bGUpIHtcclxuICAgICAgICAgICAgdGhpcy5fZm9udFN0eWxlID0gZm9udFN0eWxlO1xyXG4gICAgICAgICAgICB0aGlzLnN0eWxlSUQrKztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBmb250IHZhcmlhbnRcclxuICAgICAqICgnbm9ybWFsJyBvciAnc21hbGwtY2FwcycpXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7c3RyaW5nfVxyXG4gICAgICovXHJcbiAgICBnZXQgZm9udFZhcmlhbnQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZvbnRWYXJpYW50O1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgc2V0IGZvbnRWYXJpYW50KGZvbnRWYXJpYW50KSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2ZvbnRWYXJpYW50ICE9PSBmb250VmFyaWFudCkge1xyXG4gICAgICAgICAgICB0aGlzLl9mb250VmFyaWFudCA9IGZvbnRWYXJpYW50O1xyXG4gICAgICAgICAgICB0aGlzLnN0eWxlSUQrKztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBmb250IHdlaWdodFxyXG4gICAgICogKCdub3JtYWwnLCAnYm9sZCcsICdib2xkZXInLCAnbGlnaHRlcicgYW5kICcxMDAnLCAnMjAwJywgJzMwMCcsICc0MDAnLCAnNTAwJywgJzYwMCcsICc3MDAnLCA4MDAnIG9yICc5MDAnKVxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge3N0cmluZ31cclxuICAgICAqL1xyXG4gICAgZ2V0IGZvbnRXZWlnaHQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZvbnRXZWlnaHQ7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICBzZXQgZm9udFdlaWdodChmb250V2VpZ2h0KSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2ZvbnRXZWlnaHQgIT09IGZvbnRXZWlnaHQpIHtcclxuICAgICAgICAgICAgdGhpcy5fZm9udFdlaWdodCA9IGZvbnRXZWlnaHQ7XHJcbiAgICAgICAgICAgIHRoaXMuc3R5bGVJRCsrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGFtb3VudCBvZiBzcGFjaW5nIGJldHdlZW4gbGV0dGVycywgZGVmYXVsdCBpcyAwXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICBnZXQgbGV0dGVyU3BhY2luZygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbGV0dGVyU3BhY2luZztcclxuICAgIH1cclxuICAgIDtcclxuICAgIHNldCBsZXR0ZXJTcGFjaW5nKGxldHRlclNwYWNpbmcpIHtcclxuICAgICAgICBpZiAodGhpcy5fbGV0dGVyU3BhY2luZyAhPT0gbGV0dGVyU3BhY2luZykge1xyXG4gICAgICAgICAgICB0aGlzLl9sZXR0ZXJTcGFjaW5nID0gbGV0dGVyU3BhY2luZztcclxuICAgICAgICAgICAgdGhpcy5zdHlsZUlEKys7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbGluZSBoZWlnaHQsIGEgbnVtYmVyIHRoYXQgcmVwcmVzZW50cyB0aGUgdmVydGljYWwgc3BhY2UgdGhhdCBhIGxldHRlciB1c2VzXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICBnZXQgbGluZUhlaWdodCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbGluZUhlaWdodDtcclxuICAgIH1cclxuICAgIDtcclxuICAgIHNldCBsaW5lSGVpZ2h0KGxpbmVIZWlnaHQpIHtcclxuICAgICAgICBpZiAodGhpcy5fbGluZUhlaWdodCAhPT0gbGluZUhlaWdodCkge1xyXG4gICAgICAgICAgICB0aGlzLl9saW5lSGVpZ2h0ID0gbGluZUhlaWdodDtcclxuICAgICAgICAgICAgdGhpcy5zdHlsZUlEKys7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgc3BhY2UgYmV0d2VlbiBsaW5lc1xyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgZ2V0IGxlYWRpbmcoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xlYWRpbmc7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICBzZXQgbGVhZGluZyhsZWFkaW5nKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2xlYWRpbmcgIT09IGxlYWRpbmcpIHtcclxuICAgICAgICAgICAgdGhpcy5fbGVhZGluZyA9IGxlYWRpbmc7XHJcbiAgICAgICAgICAgIHRoaXMuc3R5bGVJRCsrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGxpbmVKb2luIHByb3BlcnR5IHNldHMgdGhlIHR5cGUgb2YgY29ybmVyIGNyZWF0ZWQsIGl0IGNhbiByZXNvbHZlIHNwaWtlZCB0ZXh0IGlzc3Vlcy5cclxuICAgICAqIERlZmF1bHQgaXMgJ21pdGVyJyAoY3JlYXRlcyBhIHNoYXJwIGNvcm5lcikuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7c3RyaW5nfVxyXG4gICAgICovXHJcbiAgICBnZXQgbGluZUpvaW4oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xpbmVKb2luO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgc2V0IGxpbmVKb2luKGxpbmVKb2luKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2xpbmVKb2luICE9PSBsaW5lSm9pbikge1xyXG4gICAgICAgICAgICB0aGlzLl9saW5lSm9pbiA9IGxpbmVKb2luO1xyXG4gICAgICAgICAgICB0aGlzLnN0eWxlSUQrKztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBtaXRlciBsaW1pdCB0byB1c2Ugd2hlbiB1c2luZyB0aGUgJ21pdGVyJyBsaW5lSm9pbiBtb2RlXHJcbiAgICAgKiBUaGlzIGNhbiByZWR1Y2Ugb3IgaW5jcmVhc2UgdGhlIHNwaWtpbmVzcyBvZiByZW5kZXJlZCB0ZXh0LlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgZ2V0IG1pdGVyTGltaXQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX21pdGVyTGltaXQ7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICBzZXQgbWl0ZXJMaW1pdChtaXRlckxpbWl0KSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX21pdGVyTGltaXQgIT09IG1pdGVyTGltaXQpIHtcclxuICAgICAgICAgICAgdGhpcy5fbWl0ZXJMaW1pdCA9IG1pdGVyTGltaXQ7XHJcbiAgICAgICAgICAgIHRoaXMuc3R5bGVJRCsrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogT2NjYXNpb25hbGx5IHNvbWUgZm9udHMgYXJlIGNyb3BwZWQuIEFkZGluZyBzb21lIHBhZGRpbmcgd2lsbCBwcmV2ZW50IHRoaXMgZnJvbSBoYXBwZW5pbmdcclxuICAgICAqIGJ5IGFkZGluZyBwYWRkaW5nIHRvIGFsbCBzaWRlcyBvZiB0aGUgdGV4dC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIGdldCBwYWRkaW5nKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9wYWRkaW5nO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgc2V0IHBhZGRpbmcocGFkZGluZykge1xyXG4gICAgICAgIGlmICh0aGlzLl9wYWRkaW5nICE9PSBwYWRkaW5nKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3BhZGRpbmcgPSBwYWRkaW5nO1xyXG4gICAgICAgICAgICB0aGlzLnN0eWxlSUQrKztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIEEgY2FudmFzIGZpbGxzdHlsZSB0aGF0IHdpbGwgYmUgdXNlZCBvbiB0aGUgdGV4dCBzdHJva2VcclxuICAgICAqIGUuZyAnYmx1ZScsICcjRkNGRjAwJ1xyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge3N0cmluZ3xudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIGdldCBzdHJva2UoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0cm9rZTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIHNldCBzdHJva2Uoc3Ryb2tlKSB7XHJcbiAgICAgICAgdmFyIG91dHB1dENvbG9yID0gQ29sb3JTZXR0aW5nc18xLkNvbG9yU2V0dGluZ3MuZ2V0Q29sb3Ioc3Ryb2tlKTtcclxuICAgICAgICBpZiAodGhpcy5fc3Ryb2tlICE9PSBvdXRwdXRDb2xvcikge1xyXG4gICAgICAgICAgICB0aGlzLl9zdHJva2UgPSBvdXRwdXRDb2xvcjtcclxuICAgICAgICAgICAgdGhpcy5zdHlsZUlEKys7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBIG51bWJlciB0aGF0IHJlcHJlc2VudHMgdGhlIHRoaWNrbmVzcyBvZiB0aGUgc3Ryb2tlLlxyXG4gICAgICogRGVmYXVsdCBpcyAwIChubyBzdHJva2UpXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICBnZXQgc3Ryb2tlVGhpY2tuZXNzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9zdHJva2VUaGlja25lc3M7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICBzZXQgc3Ryb2tlVGhpY2tuZXNzKHN0cm9rZVRoaWNrbmVzcykge1xyXG4gICAgICAgIGlmICh0aGlzLl9zdHJva2VUaGlja25lc3MgIT09IHN0cm9rZVRoaWNrbmVzcykge1xyXG4gICAgICAgICAgICB0aGlzLl9zdHJva2VUaGlja25lc3MgPSBzdHJva2VUaGlja25lc3M7XHJcbiAgICAgICAgICAgIHRoaXMuc3R5bGVJRCsrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGJhc2VsaW5lIG9mIHRoZSB0ZXh0IHRoYXQgaXMgcmVuZGVyZWQuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7c3RyaW5nfVxyXG4gICAgICovXHJcbiAgICBnZXQgdGV4dEJhc2VsaW5lKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl90ZXh0QmFzZWxpbmU7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICBzZXQgdGV4dEJhc2VsaW5lKHRleHRCYXNlbGluZSkge1xyXG4gICAgICAgIGlmICh0aGlzLl90ZXh0QmFzZWxpbmUgIT09IHRleHRCYXNlbGluZSkge1xyXG4gICAgICAgICAgICB0aGlzLl90ZXh0QmFzZWxpbmUgPSB0ZXh0QmFzZWxpbmU7XHJcbiAgICAgICAgICAgIHRoaXMuc3R5bGVJRCsrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogVHJpbSB0cmFuc3BhcmVudCBib3JkZXJzXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgZ2V0IHRyaW0oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RyaW07XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICBzZXQgdHJpbSh0cmltKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3RyaW0gIT09IHRyaW0pIHtcclxuICAgICAgICAgICAgdGhpcy5fdHJpbSA9IHRyaW07XHJcbiAgICAgICAgICAgIHRoaXMuc3R5bGVJRCsrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogSG93IG5ld2xpbmVzIGFuZCBzcGFjZXMgc2hvdWxkIGJlIGhhbmRsZWQuXHJcbiAgICAgKiBEZWZhdWx0IGlzICdwcmUnIChwcmVzZXJ2ZSwgcHJlc2VydmUpLlxyXG4gICAgICpcclxuICAgICAqICB2YWx1ZSAgIHwgTmV3IGxpbmVzIHwgICBTcGFjZXNcclxuICAgICAqICAtLS0gICAgIHwgLS0tICAgICAgIHwgICAtLS1cclxuICAgICAqICdub3JtYWwnIHwgQ29sbGFwc2UgIHwgICBDb2xsYXBzZVxyXG4gICAgICogJ3ByZScgICAgfCBQcmVzZXJ2ZSAgfCAgIFByZXNlcnZlXHJcbiAgICAgKiAncHJlLWxpbmUnICAgfCBQcmVzZXJ2ZSAgfCAgIENvbGxhcHNlXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7c3RyaW5nfVxyXG4gICAgICovXHJcbiAgICBnZXQgd2hpdGVTcGFjZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fd2hpdGVTcGFjZTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIHNldCB3aGl0ZVNwYWNlKHdoaXRlU3BhY2UpIHtcclxuICAgICAgICBpZiAodGhpcy5fd2hpdGVTcGFjZSAhPT0gd2hpdGVTcGFjZSkge1xyXG4gICAgICAgICAgICB0aGlzLl93aGl0ZVNwYWNlID0gd2hpdGVTcGFjZTtcclxuICAgICAgICAgICAgdGhpcy5zdHlsZUlEKys7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBJbmRpY2F0ZXMgaWYgd29yZCB3cmFwIHNob3VsZCBiZSB1c2VkXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgZ2V0IHdvcmRXcmFwKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl93b3JkV3JhcDtcclxuICAgIH1cclxuICAgIDtcclxuICAgIHNldCB3b3JkV3JhcCh3b3JkV3JhcCkge1xyXG4gICAgICAgIGlmICh0aGlzLl93b3JkV3JhcCAhPT0gd29yZFdyYXApIHtcclxuICAgICAgICAgICAgdGhpcy5fd29yZFdyYXAgPSB3b3JkV3JhcDtcclxuICAgICAgICAgICAgdGhpcy5zdHlsZUlEKys7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgd2lkdGggYXQgd2hpY2ggdGV4dCB3aWxsIHdyYXAsIGl0IG5lZWRzIHdvcmRXcmFwIHRvIGJlIHNldCB0byB0cnVlXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICBnZXQgd29yZFdyYXBXaWR0aCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fd29yZFdyYXBXaWR0aDtcclxuICAgIH1cclxuICAgIDtcclxuICAgIHNldCB3b3JkV3JhcFdpZHRoKHdvcmRXcmFwV2lkdGgpIHtcclxuICAgICAgICBpZiAodGhpcy5fd29yZFdyYXBXaWR0aCAhPT0gd29yZFdyYXBXaWR0aCkge1xyXG4gICAgICAgICAgICB0aGlzLl93b3JkV3JhcFdpZHRoID0gd29yZFdyYXBXaWR0aDtcclxuICAgICAgICAgICAgdGhpcy5zdHlsZUlEKys7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBHZW5lcmF0ZXMgYSBmb250IHN0eWxlIHN0cmluZyB0byB1c2UgZm9yIGBUZXh0TWV0cmljcy5tZWFzdXJlRm9udCgpYC5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IEZvbnQgc3R5bGUgc3RyaW5nLCBmb3IgcGFzc2luZyB0byBgVGV4dE1ldHJpY3MubWVhc3VyZUZvbnQoKWBcclxuICAgICAqL1xyXG4gICAgdG9Gb250U3RyaW5nKCkge1xyXG4gICAgICAgIC8vIGJ1aWxkIGNhbnZhcyBhcGkgZm9udCBzZXR0aW5nIGZyb20gaW5kaXZpZHVhbCBjb21wb25lbnRzLiBDb252ZXJ0IGEgbnVtZXJpYyB0aGlzLmZvbnRTaXplIHRvIHB4XHJcbiAgICAgICAgdmFyIGZvbnRTaXplU3RyaW5nID0gKHR5cGVvZiB0aGlzLmZvbnRTaXplID09PSAnbnVtYmVyJykgPyAoKHRoaXMuZm9udFNpemUpICsgXCJweFwiKSA6IHRoaXMuZm9udFNpemU7XHJcbiAgICAgICAgLy8gQ2xlYW4tdXAgZm9udEZhbWlseSBwcm9wZXJ0eSBieSBxdW90aW5nIGVhY2ggZm9udCBuYW1lXHJcbiAgICAgICAgLy8gdGhpcyB3aWxsIHN1cHBvcnQgZm9udCBuYW1lcyB3aXRoIHNwYWNlc1xyXG4gICAgICAgIHZhciBmb250RmFtaWxpZXMgPSB0aGlzLmZvbnRGYW1pbHk7XHJcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHRoaXMuZm9udEZhbWlseSkpIHtcclxuICAgICAgICAgICAgZm9udEZhbWlsaWVzID0gdGhpcy5mb250RmFtaWx5LnNwbGl0KCcsJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAodmFyIGkgPSBmb250RmFtaWxpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICAgICAgLy8gVHJpbSBhbnkgZXh0cmEgd2hpdGUtc3BhY2VcclxuICAgICAgICAgICAgdmFyIGZvbnRGYW1pbHkgPSBmb250RmFtaWxpZXNbaV0udHJpbSgpO1xyXG4gICAgICAgICAgICAvLyBDaGVjayBpZiBmb250IGFscmVhZHkgY29udGFpbnMgc3RyaW5nc1xyXG4gICAgICAgICAgICBpZiAoISgvKFtcXFwiXFwnXSlbXlxcJ1xcXCJdK1xcMS8pLnRlc3QoZm9udEZhbWlseSkpIHtcclxuICAgICAgICAgICAgICAgIGZvbnRGYW1pbHkgPSBcIlxcXCJcIiArIGZvbnRGYW1pbHkgKyBcIlxcXCJcIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb250RmFtaWxpZXNbaV0gPSBmb250RmFtaWx5O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gKCh0aGlzLmZvbnRTdHlsZSkgKyBcIiBcIiArICh0aGlzLmZvbnRWYXJpYW50KSArIFwiIFwiICsgKHRoaXMuZm9udFdlaWdodCkgKyBcIiBcIiArIGZvbnRTaXplU3RyaW5nICsgXCIgXCIgKyAoZm9udEZhbWlsaWVzLmpvaW4oJywnKSkpO1xyXG4gICAgfVxyXG4gICAgO1xyXG59XHJcbmV4cG9ydHMuVGV4dFN0eWxlID0gVGV4dFN0eWxlO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBFdmVudERpc3BhdGNoZXJfMSA9IHJlcXVpcmUoXCIuL0V2ZW50RGlzcGF0Y2hlclwiKTtcclxuY29uc3QgUmVjdGFuZ2xlXzEgPSByZXF1aXJlKFwiLi9SZWN0YW5nbGVcIik7XHJcbmNvbnN0IFBvaW50XzEgPSByZXF1aXJlKFwiLi9Qb2ludFwiKTtcclxuY29uc3QgRXZlbnRfMSA9IHJlcXVpcmUoXCIuL0V2ZW50XCIpO1xyXG5jb25zdCBUZXh0dXJlVXZzXzEgPSByZXF1aXJlKFwiLi9UZXh0dXJlVXZzXCIpO1xyXG5jb25zdCBCYXNlVGV4dHVyZV8xID0gcmVxdWlyZShcIi4vQmFzZVRleHR1cmVcIik7XHJcbmNvbnN0IEltYWdlUmVzb3VyY2VfMSA9IHJlcXVpcmUoXCIuL0ltYWdlUmVzb3VyY2VcIik7XHJcbmNvbnN0IENhbnZhc1Jlc291cmNlXzEgPSByZXF1aXJlKFwiLi9DYW52YXNSZXNvdXJjZVwiKTtcclxuY29uc3QgTWF0aFNldHRpbmdzXzEgPSByZXF1aXJlKFwiLi9NYXRoU2V0dGluZ3NcIik7XHJcbmNvbnN0IENhY2hlU2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL0NhY2hlU2V0dGluZ3NcIik7XHJcbmNvbnN0IERpc3BsYXlTZXR0aW5nc18xID0gcmVxdWlyZShcIi4vRGlzcGxheVNldHRpbmdzXCIpO1xyXG5jb25zdCBOZXR3b3JrU2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL05ldHdvcmtTZXR0aW5nc1wiKTtcclxuY29uc3QgTG9nZ2VyXzEgPSByZXF1aXJlKFwiLi9Mb2dnZXJcIik7XHJcbmNsYXNzIFRleHR1cmUgZXh0ZW5kcyBFdmVudERpc3BhdGNoZXJfMS5FdmVudERpc3BhdGNoZXIge1xyXG4gICAgY29uc3RydWN0b3IoYmFzZVRleHR1cmUsIGZyYW1lID0gbnVsbCwgb3JpZyA9IG51bGwsIHRyaW0gPSBudWxsLCByb3RhdGUgPSBudWxsLCBhbmNob3IgPSBudWxsKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDYWxsZWQgd2hlbiB0aGUgYmFzZSB0ZXh0dXJlIGlzIHVwZGF0ZWRcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAgICAgKiBAcGFyYW0ge1BJWEkuQmFzZVRleHR1cmV9IGJhc2VUZXh0dXJlIC0gVGhlIGJhc2UgdGV4dHVyZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLm9uQmFzZVRleHR1cmVVcGRhdGVkID0gKGJhc2VUZXh0dXJlKSA9PiB7XHJcbiAgICAgICAgICAgIExvZ2dlcl8xLnRyYWNlKFwib25CYXNlVGV4dHVyZVVwZGF0ZWRcIik7XHJcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUlEKys7XHJcbiAgICAgICAgICAgIC8vIFRPRE8gdGhpcyBjb2RlIGxvb2tzIGNvbmZ1c2luZy4uIGJvbyB0byBhYnVzaW5nIGdldHRlcnMgYW5kIHNldHRlcnMhXHJcbiAgICAgICAgICAgIGlmICh0aGlzLm5vRnJhbWUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZnJhbWUgPSBuZXcgUmVjdGFuZ2xlXzEuUmVjdGFuZ2xlKDAsIDAsIGJhc2VUZXh0dXJlLndpZHRoLCBiYXNlVGV4dHVyZS5oZWlnaHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5mcmFtZSA9IHRoaXMuX2ZyYW1lO1xyXG4gICAgICAgICAgICAgICAgLy8gVE9ETyBtYXliZSB3YXRjaCBvdXQgZm9yIHRoZSBubyBmcmFtZSBvcHRpb25cclxuICAgICAgICAgICAgICAgIC8vIHVwZGF0aW5nIHRoZSB0ZXh0dXJlIHdpbGwgc2hvdWxkIHVwZGF0ZSB0aGUgZnJhbWUgaWYgaXQgd2FzIHNldCB0byBubyBmcmFtZS4uXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy52YWxpZCA9IHRoaXMuYmFzZVRleHR1cmUudmFsaWQ7XHJcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChFdmVudF8xLkV2ZW50LmdldEV2ZW50KFwidXBkYXRlXCIpKTtcclxuICAgICAgICAgICAgLy8gdGhpcy5lbWl0KCd1cGRhdGUnLCB0aGlzKTtcclxuICAgICAgICAgICAgLy8gdGhpcy5iYXNlVGV4dHVyZS5hZGRFdmVudExpc3RlbmVyKFwidXBkYXRlXCIsIHRoaXMub25CYXNlVGV4dHVyZVVwZGF0ZWQpXHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLm5vRnJhbWUgPSBmYWxzZTtcclxuICAgICAgICBpZiAoIWZyYW1lKSB7XHJcbiAgICAgICAgICAgIHRoaXMubm9GcmFtZSA9IHRydWU7XHJcbiAgICAgICAgICAgIGZyYW1lID0gbmV3IFJlY3RhbmdsZV8xLlJlY3RhbmdsZSgwLCAwLCAxLCAxKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGJhc2VUZXh0dXJlIGluc3RhbmNlb2YgVGV4dHVyZSkge1xyXG4gICAgICAgICAgICBiYXNlVGV4dHVyZSA9IGJhc2VUZXh0dXJlLmJhc2VUZXh0dXJlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgYmFzZSB0ZXh0dXJlIHRoYXQgdGhpcyB0ZXh0dXJlIHVzZXMuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLkJhc2VUZXh0dXJlfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuYmFzZVRleHR1cmUgPSBiYXNlVGV4dHVyZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGlzIGlzIHRoZSBhcmVhIG9mIHRoZSBCYXNlVGV4dHVyZSBpbWFnZSB0byBhY3R1YWxseSBjb3B5IHRvIHRoZSBDYW52YXMgLyBXZWJHTCB3aGVuIHJlbmRlcmluZyxcclxuICAgICAgICAgKiBpcnJlc3BlY3RpdmUgb2YgdGhlIGFjdHVhbCBmcmFtZSBzaXplIG9yIHBsYWNlbWVudCAod2hpY2ggY2FuIGJlIGluZmx1ZW5jZWQgYnkgdHJpbW1lZCB0ZXh0dXJlIGF0bGFzZXMpXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLlJlY3RhbmdsZX1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLl9mcmFtZSA9IGZyYW1lO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoaXMgaXMgdGhlIHRyaW1tZWQgYXJlYSBvZiBvcmlnaW5hbCB0ZXh0dXJlLCBiZWZvcmUgaXQgd2FzIHB1dCBpbiBhdGxhc1xyXG4gICAgICAgICAqIFBsZWFzZSBjYWxsIGB1cGRhdGVVdnMoKWAgYWZ0ZXIgeW91IGNoYW5nZSBjb29yZGluYXRlcyBvZiBgdHJpbWAgbWFudWFsbHkuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLlJlY3RhbmdsZX1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnRyaW0gPSB0cmltO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoaXMgd2lsbCBsZXQgdGhlIHJlbmRlcmVyIGtub3cgaWYgdGhlIHRleHR1cmUgaXMgdmFsaWQuIElmIGl0J3Mgbm90IHRoZW4gaXQgY2Fubm90IGJlIHJlbmRlcmVkLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQG1lbWJlciB7Ym9vbGVhbn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnZhbGlkID0gZmFsc2U7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhpcyB3aWxsIGxldCBhIHJlbmRlcmVyIGtub3cgdGhhdCBhIHRleHR1cmUgaGFzIGJlZW4gdXBkYXRlZCAodXNlZCBtYWlubHkgZm9yIFdlYkdMIHV2IHVwZGF0ZXMpXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAbWVtYmVyIHtib29sZWFufVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMucmVxdWlyZXNVcGRhdGUgPSBmYWxzZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgV2ViR0wgVVYgZGF0YSBjYWNoZS4gQ2FuIGJlIHVzZWQgYXMgcXVhZCBVVlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQG1lbWJlciB7UElYSS5UZXh0dXJlVXZzfVxyXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLl91dnMgPSBUZXh0dXJlLkRFRkFVTFRfVVZTO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIERlZmF1bHQgVGV4dHVyZU1hdHJpeCBpbnN0YW5jZSBmb3IgdGhpcyB0ZXh0dXJlXHJcbiAgICAgICAgICogQnkgZGVmYXVsdCB0aGF0IG9iamVjdCBpcyBub3QgY3JlYXRlZCBiZWNhdXNlIGl0cyBoZWF2eVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQG1lbWJlciB7UElYSS5UZXh0dXJlTWF0cml4fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMudXZNYXRyaXggPSBudWxsO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoaXMgaXMgdGhlIGFyZWEgb2Ygb3JpZ2luYWwgdGV4dHVyZSwgYmVmb3JlIGl0IHdhcyBwdXQgaW4gYXRsYXNcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuUmVjdGFuZ2xlfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMub3JpZyA9IG9yaWcgfHwgZnJhbWU7IC8vIG5ldyBSZWN0YW5nbGUoMCwgMCwgMSwgMSk7XHJcbiAgICAgICAgdGhpcy5fcm90YXRlID0gTnVtYmVyKHJvdGF0ZSB8fCAwKTtcclxuICAgICAgICBpZiAocm90YXRlID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgIC8vIHRoaXMgaXMgb2xkIHRleHR1cmVwYWNrZXIgbGVnYWN5LCBzb21lIGdhbWVzL2xpYnJhcmllcyBhcmUgcGFzc2luZyBcInRydWVcIiBmb3Igcm90YXRlZCB0ZXh0dXJlc1xyXG4gICAgICAgICAgICB0aGlzLl9yb3RhdGUgPSAyO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLl9yb3RhdGUgJSAyICE9PSAwKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYXR0ZW1wdCB0byB1c2UgZGlhbW9uZC1zaGFwZWQgVVZzLiBJZiB5b3UgYXJlIHN1cmUsIHNldCByb3RhdGlvbiBtYW51YWxseScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYmFzZVRleHR1cmUudmFsaWQpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMubm9GcmFtZSkge1xyXG4gICAgICAgICAgICAgICAgZnJhbWUgPSBuZXcgUmVjdGFuZ2xlXzEuUmVjdGFuZ2xlKDAsIDAsIGJhc2VUZXh0dXJlLndpZHRoLCBiYXNlVGV4dHVyZS5oZWlnaHQpO1xyXG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlcmUgaXMgbm8gZnJhbWUgd2Ugc2hvdWxkIG1vbml0b3IgZm9yIGFueSBiYXNlIHRleHR1cmUgY2hhbmdlcy4uXHJcbiAgICAgICAgICAgICAgICBiYXNlVGV4dHVyZS5hZGRFdmVudExpc3RlbmVyKFwidXBkYXRlXCIsIHRoaXMub25CYXNlVGV4dHVyZVVwZGF0ZWQpO1xyXG4gICAgICAgICAgICAgICAgLy8gYmFzZVRleHR1cmUub24oJ3VwZGF0ZScsIHRoaXMub25CYXNlVGV4dHVyZVVwZGF0ZWQsIHRoaXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuZnJhbWUgPSBmcmFtZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGJhc2VUZXh0dXJlLmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkZWRcIiwgdGhpcy5vbkJhc2VUZXh0dXJlVXBkYXRlZCk7XHJcbiAgICAgICAgICAgIC8vIGJhc2VUZXh0dXJlLm9uY2UoJ2xvYWRlZCcsIHRoaXMub25CYXNlVGV4dHVyZVVwZGF0ZWQsIHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBbmNob3IgcG9pbnQgdGhhdCBpcyB1c2VkIGFzIGRlZmF1bHQgaWYgc3ByaXRlIGlzIGNyZWF0ZWQgd2l0aCB0aGlzIHRleHR1cmUuXHJcbiAgICAgICAgICogQ2hhbmdpbmcgdGhlIGBkZWZhdWx0QW5jaG9yYCBhdCBhIGxhdGVyIHBvaW50IG9mIHRpbWUgd2lsbCBub3QgdXBkYXRlIFNwcml0ZSdzIGFuY2hvciBwb2ludC5cclxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLlBvaW50fVxyXG4gICAgICAgICAqIEBkZWZhdWx0IHswLDB9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgaWYgKGFuY2hvcikge1xyXG4gICAgICAgICAgICB0aGlzLmRlZmF1bHRBbmNob3IgPSBuZXcgUG9pbnRfMS5Qb2ludChhbmNob3IueCwgYW5jaG9yLnkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5kZWZhdWx0QW5jaG9yID0gbmV3IFBvaW50XzEuUG9pbnQoMCwgMCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFVwZGF0ZSBJRCBpcyBvYnNlcnZlZCBieSBzcHJpdGVzIGFuZCBUZXh0dXJlTWF0cml4IGluc3RhbmNlcy5cclxuICAgICAgICAgKiBDYWxsIHVwZGF0ZVV2cygpIHRvIGluY3JlbWVudCBpdC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5fdXBkYXRlSUQgPSAwO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBpZHMgdW5kZXIgd2hpY2ggdGhpcyBUZXh0dXJlIGhhcyBiZWVuIGFkZGVkIHRvIHRoZSB0ZXh0dXJlIGNhY2hlLiBUaGlzIGlzXHJcbiAgICAgICAgICogYXV0b21hdGljYWxseSBzZXQgYXMgbG9uZyBhcyBUZXh0dXJlLmFkZFRvQ2FjaGUgaXMgdXNlZCwgYnV0IG1heSBub3QgYmUgc2V0IGlmIGFcclxuICAgICAgICAgKiBUZXh0dXJlIGlzIGFkZGVkIGRpcmVjdGx5IHRvIHRoZSBUZXh0dXJlQ2FjaGUgYXJyYXkuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAbWVtYmVyIHtzdHJpbmdbXX1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnRleHR1cmVDYWNoZUlkcyA9IFtdO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGVzIHRoaXMgdGV4dHVyZSBvbiB0aGUgZ3B1LlxyXG4gICAgICpcclxuICAgICAqL1xyXG4gICAgdXBkYXRlKCkge1xyXG4gICAgICAgIHRoaXMuYmFzZVRleHR1cmUudXBkYXRlKCk7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIERlc3Ryb3lzIHRoaXMgdGV4dHVyZVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Rlc3Ryb3lCYXNlPWZhbHNlXSBXaGV0aGVyIHRvIGRlc3Ryb3kgdGhlIGJhc2UgdGV4dHVyZSBhcyB3ZWxsXHJcbiAgICAgKi9cclxuICAgIGRlc3Ryb3koZGVzdHJveUJhc2UpIHtcclxuICAgICAgICBpZiAodGhpcy5iYXNlVGV4dHVyZSkge1xyXG4gICAgICAgICAgICBpZiAoZGVzdHJveUJhc2UpIHtcclxuICAgICAgICAgICAgICAgIC8vIGRlbGV0ZSB0aGUgdGV4dHVyZSBpZiBpdCBleGlzdHMgaW4gdGhlIHRleHR1cmUgY2FjaGUuLlxyXG4gICAgICAgICAgICAgICAgLy8gdGhpcyBvbmx5IG5lZWRzIHRvIGJlIHJlbW92ZWQgaWYgdGhlIGJhc2UgdGV4dHVyZSBpcyBhY3R1YWxseSBkZXN0cm95ZWQgdG9vLi5cclxuICAgICAgICAgICAgICAgIGlmIChDYWNoZVNldHRpbmdzXzEuQ2FjaGVTZXR0aW5ncy5UZXh0dXJlQ2FjaGVbdGhpcy5iYXNlVGV4dHVyZS5pbWFnZVVybF0pIHtcclxuICAgICAgICAgICAgICAgICAgICBUZXh0dXJlLnJlbW92ZUZyb21DYWNoZSh0aGlzLmJhc2VUZXh0dXJlLmltYWdlVXJsKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuYmFzZVRleHR1cmUuZGVzdHJveSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHRoaXMuYmFzZVRleHR1cmUucmVtbygndXBkYXRlJywgdGhpcy5vbkJhc2VUZXh0dXJlVXBkYXRlZCwgdGhpcyk7XHJcbiAgICAgICAgICAgIHRoaXMuYmFzZVRleHR1cmUgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9mcmFtZSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5fdXZzID0gbnVsbDtcclxuICAgICAgICB0aGlzLnRyaW0gPSBudWxsO1xyXG4gICAgICAgIHRoaXMub3JpZyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy52YWxpZCA9IGZhbHNlO1xyXG4gICAgICAgIFRleHR1cmUucmVtb3ZlRnJvbUNhY2hlKHRoaXMpO1xyXG4gICAgICAgIHRoaXMudGV4dHVyZUNhY2hlSWRzID0gbnVsbDtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyB0ZXh0dXJlIG9iamVjdCB0aGF0IGFjdHMgdGhlIHNhbWUgYXMgdGhpcyBvbmUuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiB7UElYSS5UZXh0dXJlfSBUaGUgbmV3IHRleHR1cmVcclxuICAgICAqL1xyXG4gICAgY2xvbmUoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBUZXh0dXJlKHRoaXMuYmFzZVRleHR1cmUsIHRoaXMuZnJhbWUsIHRoaXMub3JpZywgdGhpcy50cmltLCB0aGlzLnJvdGF0ZSwgdGhpcy5kZWZhdWx0QW5jaG9yKTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyB0aGUgaW50ZXJuYWwgV2ViR0wgVVYgY2FjaGUuIFVzZSBpdCBhZnRlciB5b3UgY2hhbmdlIGBmcmFtZWAgb3IgYHRyaW1gIG9mIHRoZSB0ZXh0dXJlLlxyXG4gICAgICogQ2FsbCBpdCBhZnRlciBjaGFuZ2luZyB0aGUgZnJhbWVcclxuICAgICAqL1xyXG4gICAgdXBkYXRlVXZzKCkge1xyXG4gICAgICAgIGlmICh0aGlzLl91dnMgPT09IFRleHR1cmUuREVGQVVMVF9VVlMpIHtcclxuICAgICAgICAgICAgdGhpcy5fdXZzID0gbmV3IFRleHR1cmVVdnNfMS5UZXh0dXJlVXZzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3V2cy5zZXQodGhpcy5fZnJhbWUsIHRoaXMuYmFzZVRleHR1cmUsIHRoaXMucm90YXRlKTtcclxuICAgICAgICB0aGlzLl91cGRhdGVJRCsrO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBIZWxwZXIgZnVuY3Rpb24gdGhhdCBjcmVhdGVzIGEgbmV3IFRleHR1cmUgYmFzZWQgb24gdGhlIHNvdXJjZSB5b3UgcHJvdmlkZS5cclxuICAgICAqIFRoZSBzb3VyY2UgY2FuIGJlIC0gZnJhbWUgaWQsIGltYWdlIHVybCwgdmlkZW8gdXJsLCBjYW52YXMgZWxlbWVudCwgdmlkZW8gZWxlbWVudCwgYmFzZSB0ZXh0dXJlXHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfEhUTUxJbWFnZUVsZW1lbnR8SFRNTENhbnZhc0VsZW1lbnR8SFRNTFZpZGVvRWxlbWVudHxQSVhJLkJhc2VUZXh0dXJlfSBzb3VyY2VcclxuICAgICAqICAgICAgICBTb3VyY2UgdG8gY3JlYXRlIHRleHR1cmUgZnJvbVxyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSBTZWUge0BsaW5rIFBJWEkuQmFzZVRleHR1cmV9J3MgY29uc3RydWN0b3IgZm9yIG9wdGlvbnMuXHJcbiAgICAgKiBAcmV0dXJuIHtQSVhJLlRleHR1cmV9IFRoZSBuZXdseSBjcmVhdGVkIHRleHR1cmVcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGZyb20oc291cmNlLCBvcHRpb25zID0ge30pIHtcclxuICAgICAgICB2YXIgY2FjaGVJZCA9IG51bGw7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBzb3VyY2UgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIGNhY2hlSWQgPSBzb3VyY2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoIXNvdXJjZS5fcGl4aUlkKSB7XHJcbiAgICAgICAgICAgICAgICBzb3VyY2UuX3BpeGlJZCA9IFwicGl4aWlkX1wiICsgKE1hdGhTZXR0aW5nc18xLk1hdGhTZXR0aW5ncy51aWQoKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2FjaGVJZCA9IHNvdXJjZS5fcGl4aUlkO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgdGV4dHVyZSA9IENhY2hlU2V0dGluZ3NfMS5DYWNoZVNldHRpbmdzLlRleHR1cmVDYWNoZVtjYWNoZUlkXTtcclxuICAgICAgICBpZiAoIXRleHR1cmUpIHtcclxuICAgICAgICAgICAgaWYgKG9wdGlvbnNbJ3Jlc29sdXRpb24nXSA9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIG9wdGlvbnMucmVzb2x1dGlvbiA9IE5ldHdvcmtTZXR0aW5nc18xLk5ldHdvcmtTZXR0aW5ncy5nZXRSZXNvbHV0aW9uT2ZVcmwoc291cmNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0ZXh0dXJlID0gbmV3IFRleHR1cmUobmV3IEJhc2VUZXh0dXJlXzEuQmFzZVRleHR1cmUoc291cmNlLCBvcHRpb25zKSk7XHJcbiAgICAgICAgICAgIHRleHR1cmUuYmFzZVRleHR1cmUuY2FjaGVJZCA9IGNhY2hlSWQ7XHJcbiAgICAgICAgICAgIEJhc2VUZXh0dXJlXzEuQmFzZVRleHR1cmUuYWRkVG9DYWNoZSh0ZXh0dXJlLmJhc2VUZXh0dXJlLCBjYWNoZUlkKTtcclxuICAgICAgICAgICAgVGV4dHVyZS5hZGRUb0NhY2hlKHRleHR1cmUsIGNhY2hlSWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBsZXRzIGFzc3VtZSBpdHMgYSBiYXNlIHRleHR1cmUhXHJcbiAgICAgICAgcmV0dXJuIHRleHR1cmU7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYSBUZXh0dXJlIHRvIHRoZSBnbG9iYWwgVGV4dHVyZUNhY2hlLiBUaGlzIGNhY2hlIGlzIHNoYXJlZCBhY3Jvc3MgdGhlIHdob2xlIFBJWEkgb2JqZWN0LlxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBwYXJhbSB7UElYSS5UZXh0dXJlfSB0ZXh0dXJlIC0gVGhlIFRleHR1cmUgdG8gYWRkIHRvIHRoZSBjYWNoZS5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZCAtIFRoZSBpZCB0aGF0IHRoZSBUZXh0dXJlIHdpbGwgYmUgc3RvcmVkIGFnYWluc3QuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBhZGRUb0NhY2hlKHRleHR1cmUsIGlkKSB7XHJcbiAgICAgICAgaWYgKGlkKSB7XHJcbiAgICAgICAgICAgIGlmICh0ZXh0dXJlLnRleHR1cmVDYWNoZUlkcy5pbmRleE9mKGlkKSA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIHRleHR1cmUudGV4dHVyZUNhY2hlSWRzLnB1c2goaWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChDYWNoZVNldHRpbmdzXzEuQ2FjaGVTZXR0aW5ncy5UZXh0dXJlQ2FjaGVbaWRdKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxyXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKChcIlRleHR1cmUgYWRkZWQgdG8gdGhlIGNhY2hlIHdpdGggYW4gaWQgW1wiICsgaWQgKyBcIl0gdGhhdCBhbHJlYWR5IGhhZCBhbiBlbnRyeVwiKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgQ2FjaGVTZXR0aW5nc18xLkNhY2hlU2V0dGluZ3MuVGV4dHVyZUNhY2hlW2lkXSA9IHRleHR1cmU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmUgYSBUZXh0dXJlIGZyb20gdGhlIGdsb2JhbCBUZXh0dXJlQ2FjaGUuXHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQHBhcmFtIHtzdHJpbmd8UElYSS5UZXh0dXJlfSB0ZXh0dXJlIC0gaWQgb2YgYSBUZXh0dXJlIHRvIGJlIHJlbW92ZWQsIG9yIGEgVGV4dHVyZSBpbnN0YW5jZSBpdHNlbGZcclxuICAgICAqIEByZXR1cm4ge1BJWEkuVGV4dHVyZXxudWxsfSBUaGUgVGV4dHVyZSB0aGF0IHdhcyByZW1vdmVkXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyByZW1vdmVGcm9tQ2FjaGUodGV4dHVyZSkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgdGV4dHVyZSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgdmFyIHRleHR1cmVGcm9tQ2FjaGUgPSBDYWNoZVNldHRpbmdzXzEuQ2FjaGVTZXR0aW5ncy5UZXh0dXJlQ2FjaGVbdGV4dHVyZV07XHJcbiAgICAgICAgICAgIGlmICh0ZXh0dXJlRnJvbUNhY2hlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSB0ZXh0dXJlRnJvbUNhY2hlLnRleHR1cmVDYWNoZUlkcy5pbmRleE9mKHRleHR1cmUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlRnJvbUNhY2hlLnRleHR1cmVDYWNoZUlkcy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZGVsZXRlIENhY2hlU2V0dGluZ3NfMS5DYWNoZVNldHRpbmdzLlRleHR1cmVDYWNoZVt0ZXh0dXJlXTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0ZXh0dXJlRnJvbUNhY2hlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRleHR1cmUgJiYgdGV4dHVyZS50ZXh0dXJlQ2FjaGVJZHMpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZXh0dXJlLnRleHR1cmVDYWNoZUlkcy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgdGhhdCB0ZXh0dXJlIG1hdGNoZXMgdGhlIG9uZSBiZWluZyBwYXNzZWQgaW4gYmVmb3JlIGRlbGV0aW5nIGl0IGZyb20gdGhlIGNhY2hlLlxyXG4gICAgICAgICAgICAgICAgaWYgKENhY2hlU2V0dGluZ3NfMS5DYWNoZVNldHRpbmdzLlRleHR1cmVDYWNoZVt0ZXh0dXJlLnRleHR1cmVDYWNoZUlkc1tpXV0gPT09IHRleHR1cmUpIHtcclxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgQ2FjaGVTZXR0aW5nc18xLkNhY2hlU2V0dGluZ3MuVGV4dHVyZUNhY2hlW3RleHR1cmUudGV4dHVyZUNhY2hlSWRzW2ldXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0ZXh0dXJlLnRleHR1cmVDYWNoZUlkcy5sZW5ndGggPSAwO1xyXG4gICAgICAgICAgICByZXR1cm4gdGV4dHVyZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBmcmFtZSBzcGVjaWZpZXMgdGhlIHJlZ2lvbiBvZiB0aGUgYmFzZSB0ZXh0dXJlIHRoYXQgdGhpcyB0ZXh0dXJlIHVzZXMuXHJcbiAgICAgKiBQbGVhc2UgY2FsbCBgdXBkYXRlVXZzKClgIGFmdGVyIHlvdSBjaGFuZ2UgY29vcmRpbmF0ZXMgb2YgYGZyYW1lYCBtYW51YWxseS5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtQSVhJLlJlY3RhbmdsZX1cclxuICAgICAqL1xyXG4gICAgZ2V0IGZyYW1lKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9mcmFtZTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIHNldCBmcmFtZShmcmFtZSkge1xyXG4gICAgICAgIHRoaXMuX2ZyYW1lID0gZnJhbWU7XHJcbiAgICAgICAgdGhpcy5ub0ZyYW1lID0gZmFsc2U7XHJcbiAgICAgICAgdmFyIHggPSBmcmFtZS54O1xyXG4gICAgICAgIHZhciB5ID0gZnJhbWUueTtcclxuICAgICAgICB2YXIgd2lkdGggPSBmcmFtZS53aWR0aDtcclxuICAgICAgICB2YXIgaGVpZ2h0ID0gZnJhbWUuaGVpZ2h0O1xyXG4gICAgICAgIHZhciB4Tm90Rml0ID0geCArIHdpZHRoID4gdGhpcy5iYXNlVGV4dHVyZS53aWR0aDtcclxuICAgICAgICB2YXIgeU5vdEZpdCA9IHkgKyBoZWlnaHQgPiB0aGlzLmJhc2VUZXh0dXJlLmhlaWdodDtcclxuICAgICAgICBpZiAoeE5vdEZpdCB8fCB5Tm90Rml0KSB7XHJcbiAgICAgICAgICAgIHZhciByZWxhdGlvbnNoaXAgPSB4Tm90Rml0ICYmIHlOb3RGaXQgPyAnYW5kJyA6ICdvcic7XHJcbiAgICAgICAgICAgIHZhciBlcnJvclggPSBcIlg6IFwiICsgeCArIFwiICsgXCIgKyB3aWR0aCArIFwiID0gXCIgKyAoeCArIHdpZHRoKSArIFwiID4gXCIgKyAodGhpcy5iYXNlVGV4dHVyZS53aWR0aCk7XHJcbiAgICAgICAgICAgIHZhciBlcnJvclkgPSBcIlk6IFwiICsgeSArIFwiICsgXCIgKyBoZWlnaHQgKyBcIiA9IFwiICsgKHkgKyBoZWlnaHQpICsgXCIgPiBcIiArICh0aGlzLmJhc2VUZXh0dXJlLmhlaWdodCk7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGV4dHVyZSBFcnJvcjogZnJhbWUgZG9lcyBub3QgZml0IGluc2lkZSB0aGUgYmFzZSBUZXh0dXJlIGRpbWVuc2lvbnM6ICdcclxuICAgICAgICAgICAgICAgICsgZXJyb3JYICsgXCIgXCIgKyByZWxhdGlvbnNoaXAgKyBcIiBcIiArIGVycm9yWSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMudmFsaWQgPSB3aWR0aCAmJiBoZWlnaHQgJiYgdGhpcy5iYXNlVGV4dHVyZS52YWxpZDtcclxuICAgICAgICBpZiAoIXRoaXMudHJpbSAmJiAhdGhpcy5yb3RhdGUpIHtcclxuICAgICAgICAgICAgdGhpcy5vcmlnID0gZnJhbWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLnZhbGlkKSB7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVXZzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgdGV4dHVyZSBpcyByb3RhdGVkIGluc2lkZSB0aGUgYXRsYXNcclxuICAgICAqIHNldCB0byAyIHRvIGNvbXBlbnNhdGUgZm9yIHRleHR1cmUgcGFja2VyIHJvdGF0aW9uXHJcbiAgICAgKiBzZXQgdG8gNiB0byBjb21wZW5zYXRlIGZvciBzcGluZSBwYWNrZXIgcm90YXRpb25cclxuICAgICAqIGNhbiBiZSB1c2VkIHRvIHJvdGF0ZSBvciBtaXJyb3Igc3ByaXRlc1xyXG4gICAgICogU2VlIHtAbGluayBQSVhJLkdyb3VwRDh9IGZvciBleHBsYW5hdGlvblxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgZ2V0IHJvdGF0ZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcm90YXRlO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgc2V0IHJvdGF0ZShyb3RhdGUpIHtcclxuICAgICAgICB0aGlzLl9yb3RhdGUgPSByb3RhdGU7XHJcbiAgICAgICAgaWYgKHRoaXMudmFsaWQpIHtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVVdnMoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSB3aWR0aCBvZiB0aGUgVGV4dHVyZSBpbiBwaXhlbHMuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICBnZXQgd2lkdGgoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMub3JpZy53aWR0aDtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGhlaWdodCBvZiB0aGUgVGV4dHVyZSBpbiBwaXhlbHMuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICBnZXQgaGVpZ2h0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm9yaWcuaGVpZ2h0O1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBbiBlbXB0eSB0ZXh0dXJlLCB1c2VkIG9mdGVuIHRvIG5vdCBoYXZlIHRvIGNyZWF0ZSBtdWx0aXBsZSBlbXB0eSB0ZXh0dXJlcy5cclxuICAgICAqIENhbiBub3QgYmUgZGVzdHJveWVkLlxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBjb25zdGFudFxyXG4gICAgICogQG1lbWJlciB7UElYSS5UZXh0dXJlfVxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZ2V0IEVNUFRZKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgVGV4dHVyZShuZXcgQmFzZVRleHR1cmVfMS5CYXNlVGV4dHVyZSgpKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gKiBBIHdoaXRlIHRleHR1cmUgb2YgMTB4MTAgc2l6ZSwgdXNlZCBmb3IgZ3JhcGhpY3MgYW5kIG90aGVyIHRoaW5nc1xyXG4gKiBDYW4gbm90IGJlIGRlc3Ryb3llZC5cclxuICpcclxuICogQHN0YXRpY1xyXG4gKiBAY29uc3RhbnRcclxuICogQG1lbWJlciB7UElYSS5UZXh0dXJlfVxyXG4gKi9cclxuICAgIHN0YXRpYyBnZXQgV0hJVEUoKSB7XHJcbiAgICAgICAgcmV0dXJuIFRleHR1cmUuY3JlYXRlV2hpdGVUZXh0dXJlKCk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgY3JlYXRlV2hpdGVUZXh0dXJlKCkge1xyXG4gICAgICAgIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcclxuICAgICAgICBjYW52YXMud2lkdGggPSAxNjtcclxuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gMTY7XHJcbiAgICAgICAgdmFyIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcclxuICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9ICd3aGl0ZSc7XHJcbiAgICAgICAgY29udGV4dC5maWxsUmVjdCgwLCAwLCAxNiwgMTYpO1xyXG4gICAgICAgIHJldHVybiBuZXcgVGV4dHVyZShuZXcgQmFzZVRleHR1cmVfMS5CYXNlVGV4dHVyZShuZXcgQ2FudmFzUmVzb3VyY2VfMS5DYW52YXNSZXNvdXJjZShjYW52YXMpKSk7XHJcbiAgICB9XHJcbn1cclxuVGV4dHVyZS5ERUZBVUxUX1VWUyA9IG5ldyBUZXh0dXJlVXZzXzEuVGV4dHVyZVV2cygpO1xyXG4vKipcclxuICogQ3JlYXRlIGEgbmV3IFRleHR1cmUgd2l0aCBhIEJ1ZmZlclJlc291cmNlIGZyb20gYSBGbG9hdDMyQXJyYXkuXHJcbiAqIFJHQkEgdmFsdWVzIGFyZSBmbG9hdHMgZnJvbSAwIHRvIDEuXHJcbiAqIEBzdGF0aWNcclxuICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8VWludDhBcnJheX0gYnVmZmVyIFRoZSBvcHRpb25hbCBhcnJheSB0byB1c2UsIGlmIG5vIGRhdGFcclxuICogICAgICAgIGlzIHByb3ZpZGVkLCBhIG5ldyBGbG9hdDMyQXJyYXkgaXMgY3JlYXRlZC5cclxuICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIC0gV2lkdGggb2YgdGhlIHJlc291cmNlXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgLSBIZWlnaHQgb2YgdGhlIHJlc291cmNlXHJcbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gU2VlIHtAbGluayBQSVhJLkJhc2VUZXh0dXJlfSdzIGNvbnN0cnVjdG9yIGZvciBvcHRpb25zLlxyXG4gKiBAcmV0dXJuIHtQSVhJLlRleHR1cmV9IFRoZSByZXN1bHRpbmcgbmV3IEJhc2VUZXh0dXJlXHJcbiAqL1xyXG5UZXh0dXJlLmZyb21CdWZmZXIgPSBmdW5jdGlvbiBmcm9tQnVmZmVyKGJ1ZmZlciwgd2lkdGgsIGhlaWdodCwgb3B0aW9ucykge1xyXG4gICAgcmV0dXJuIG5ldyBUZXh0dXJlKEJhc2VUZXh0dXJlXzEuQmFzZVRleHR1cmUuZnJvbUJ1ZmZlcihidWZmZXIsIHdpZHRoLCBoZWlnaHQsIG9wdGlvbnMpKTtcclxufTtcclxuLyoqXHJcbiAqIENyZWF0ZSBhIHRleHR1cmUgZnJvbSBhIHNvdXJjZSBhbmQgYWRkIHRvIHRoZSBjYWNoZS5cclxuICpcclxuICogQHN0YXRpY1xyXG4gKiBAcGFyYW0ge0hUTUxJbWFnZUVsZW1lbnR8SFRNTENhbnZhc0VsZW1lbnR9IHNvdXJjZSAtIFRoZSBpbnB1dCBzb3VyY2UuXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBpbWFnZVVybCAtIEZpbGUgbmFtZSBvZiB0ZXh0dXJlLCBmb3IgY2FjaGUgYW5kIHJlc29sdmluZyByZXNvbHV0aW9uLlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gW25hbWVdIC0gSHVtYW4gcmVhZGFibGUgbmFtZSBmb3IgdGhlIHRleHR1cmUgY2FjaGUuIElmIG5vIG5hbWUgaXNcclxuICogICAgICAgIHNwZWNpZmllZCwgb25seSBgaW1hZ2VVcmxgIHdpbGwgYmUgdXNlZCBhcyB0aGUgY2FjaGUgSUQuXHJcbiAqIEByZXR1cm4ge1BJWEkuVGV4dHVyZX0gT3V0cHV0IHRleHR1cmVcclxuICovXHJcblRleHR1cmUuZnJvbUxvYWRlciA9IGZ1bmN0aW9uIGZyb21Mb2FkZXIoc291cmNlLCBpbWFnZVVybCwgbmFtZSkge1xyXG4gICAgdmFyIHJlc291cmNlID0gbmV3IEltYWdlUmVzb3VyY2VfMS5JbWFnZVJlc291cmNlKHNvdXJjZSk7XHJcbiAgICByZXNvdXJjZS51cmwgPSBpbWFnZVVybDtcclxuICAgIHZhciBiYXNlVGV4dHVyZSA9IG5ldyBCYXNlVGV4dHVyZV8xLkJhc2VUZXh0dXJlKHJlc291cmNlLCB7XHJcbiAgICAgICAgc2NhbGVNb2RlOiBEaXNwbGF5U2V0dGluZ3NfMS5EaXNwbGF5U2V0dGluZ3MuU0NBTEVfTU9ERSxcclxuICAgICAgICByZXNvbHV0aW9uOiBOZXR3b3JrU2V0dGluZ3NfMS5OZXR3b3JrU2V0dGluZ3MuZ2V0UmVzb2x1dGlvbk9mVXJsKGltYWdlVXJsKSxcclxuICAgIH0pO1xyXG4gICAgdmFyIHRleHR1cmUgPSBuZXcgVGV4dHVyZShiYXNlVGV4dHVyZSk7XHJcbiAgICAvLyBObyBuYW1lLCB1c2UgaW1hZ2VVcmwgaW5zdGVhZFxyXG4gICAgaWYgKCFuYW1lKSB7XHJcbiAgICAgICAgbmFtZSA9IGltYWdlVXJsO1xyXG4gICAgfVxyXG4gICAgLy8gbGV0cyBhbHNvIGFkZCB0aGUgZnJhbWUgdG8gcGl4aSdzIGdsb2JhbCBjYWNoZSBmb3IgZnJvbUZyYW1lIGFuZCBmcm9tSW1hZ2UgZnVuY3Rpb25zXHJcbiAgICBCYXNlVGV4dHVyZV8xLkJhc2VUZXh0dXJlLmFkZFRvQ2FjaGUodGV4dHVyZS5iYXNlVGV4dHVyZSwgbmFtZSk7XHJcbiAgICBUZXh0dXJlLmFkZFRvQ2FjaGUodGV4dHVyZSwgbmFtZSk7XHJcbiAgICAvLyBhbHNvIGFkZCByZWZlcmVuY2VzIGJ5IHVybCBpZiB0aGV5IGFyZSBkaWZmZXJlbnQuXHJcbiAgICBpZiAobmFtZSAhPT0gaW1hZ2VVcmwpIHtcclxuICAgICAgICBCYXNlVGV4dHVyZV8xLkJhc2VUZXh0dXJlLmFkZFRvQ2FjaGUodGV4dHVyZS5iYXNlVGV4dHVyZSwgaW1hZ2VVcmwpO1xyXG4gICAgICAgIFRleHR1cmUuYWRkVG9DYWNoZSh0ZXh0dXJlLCBpbWFnZVVybCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGV4dHVyZTtcclxufTtcclxuZXhwb3J0cy5UZXh0dXJlID0gVGV4dHVyZTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgU3lzdGVtXzEgPSByZXF1aXJlKFwiLi9TeXN0ZW1cIik7XHJcbmNvbnN0IHNldHRpbmdzXzEgPSByZXF1aXJlKFwiLi9zZXR0aW5nc1wiKTtcclxuY2xhc3MgVGV4dHVyZUdDU3lzdGVtIGV4dGVuZHMgU3lzdGVtXzEuU3lzdGVtIHtcclxuICAgIGNvbnN0cnVjdG9yKHJlbmRlcmVyKSB7XHJcbiAgICAgICAgc3VwZXIocmVuZGVyZXIpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvdW50XHJcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICAgICAqIEByZWFkb25seVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuY291bnQgPSAwO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENoZWNrIGNvdW50XHJcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICAgICAqIEByZWFkb25seVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuY2hlY2tDb3VudCA9IDA7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogTWF4aW11bSBpZGxlIHRpbWUsIGluIHNlY29uZHNcclxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgICAgICogQHNlZSBQSVhJLnNldHRpbmdzLkdDX01BWF9JRExFXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5tYXhJZGxlID0gc2V0dGluZ3NfMS5zZXR0aW5ncy5HQ19NQVhfSURMRTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBNYXhpbXVtIG51bWJlciBvZiBpdGVzbSB0byBjaGVja1xyXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAgICAgKiBAc2VlIFBJWEkuc2V0dGluZ3MuR0NfTUFYX0NIRUNLX0NPVU5UXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5jaGVja0NvdW50TWF4ID0gc2V0dGluZ3NfMS5zZXR0aW5ncy5HQ19NQVhfQ0hFQ0tfQ09VTlQ7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ3VycmVudCBnYXJhYmFnZSBjb2xsZWN0aW9uIG1vZGVcclxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLkdDX01PREVTfVxyXG4gICAgICAgICAqIEBzZWUgUElYSS5zZXR0aW5ncy5HQ19NT0RFXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5tb2RlID0gc2V0dGluZ3NfMS5zZXR0aW5ncy5HQ19NT0RFO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVja3MgdG8gc2VlIHdoZW4gdGhlIGxhc3QgdGltZSBhIHRleHR1cmUgd2FzIHVzZWRcclxuICAgICAqIGlmIHRoZSB0ZXh0dXJlIGhhcyBub3QgYmVlbiB1c2VkIGZvciBhIHNwZWNpZmllZCBhbW91bnQgb2YgdGltZSBpdCB3aWxsIGJlIHJlbW92ZWQgZnJvbSB0aGUgR1BVXHJcbiAgICAgKi9cclxuICAgIHBvc3RyZW5kZXIoKSB7XHJcbiAgICAgICAgdGhpcy5jb3VudCsrO1xyXG4gICAgICAgIGlmICh0aGlzLm1vZGUgPT09IHNldHRpbmdzXzEuc2V0dGluZ3MuR0NfTU9ERVMuTUFOVUFMKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jaGVja0NvdW50Kys7XHJcbiAgICAgICAgaWYgKHRoaXMuY2hlY2tDb3VudCA+IHRoaXMuY2hlY2tDb3VudE1heCkge1xyXG4gICAgICAgICAgICB0aGlzLmNoZWNrQ291bnQgPSAwO1xyXG4gICAgICAgICAgICB0aGlzLnJ1bigpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2tzIHRvIHNlZSB3aGVuIHRoZSBsYXN0IHRpbWUgYSB0ZXh0dXJlIHdhcyB1c2VkXHJcbiAgICAgKiBpZiB0aGUgdGV4dHVyZSBoYXMgbm90IGJlZW4gdXNlZCBmb3IgYSBzcGVjaWZpZWQgYW1vdW50IG9mIHRpbWUgaXQgd2lsbCBiZSByZW1vdmVkIGZyb20gdGhlIEdQVVxyXG4gICAgICovXHJcbiAgICBydW4oKSB7XHJcbiAgICAgICAgdmFyIHRtID0gdGhpcy5yZW5kZXJlci50ZXh0dXJlO1xyXG4gICAgICAgIHZhciBtYW5hZ2VkVGV4dHVyZXMgPSB0bS5tYW5hZ2VkVGV4dHVyZXM7XHJcbiAgICAgICAgdmFyIHdhc1JlbW92ZWQgPSBmYWxzZTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1hbmFnZWRUZXh0dXJlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgdGV4dHVyZSA9IG1hbmFnZWRUZXh0dXJlc1tpXTtcclxuICAgICAgICAgICAgLy8gb25seSBzdXBwb3J0cyBub24gZ2VuZXJhdGVkIHRleHR1cmVzIGF0IHRoZSBtb21lbnQhXHJcbiAgICAgICAgICAgIGlmICghdGV4dHVyZS5mcmFtZWJ1ZmZlciAmJiB0aGlzLmNvdW50IC0gdGV4dHVyZS50b3VjaGVkID4gdGhpcy5tYXhJZGxlKSB7XHJcbiAgICAgICAgICAgICAgICB0bS5kZXN0cm95VGV4dHVyZSh0ZXh0dXJlLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIG1hbmFnZWRUZXh0dXJlc1tpXSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB3YXNSZW1vdmVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAod2FzUmVtb3ZlZCkge1xyXG4gICAgICAgICAgICB2YXIgaiA9IDA7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IG1hbmFnZWRUZXh0dXJlcy5sZW5ndGg7IGkkMSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobWFuYWdlZFRleHR1cmVzW2kkMV0gIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBtYW5hZ2VkVGV4dHVyZXNbaisrXSA9IG1hbmFnZWRUZXh0dXJlc1tpJDFdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG1hbmFnZWRUZXh0dXJlcy5sZW5ndGggPSBqO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyBhbGwgdGhlIHRleHR1cmVzIHdpdGhpbiB0aGUgc3BlY2lmaWVkIGRpc3BsYXlPYmplY3QgYW5kIGl0cyBjaGlsZHJlbiBmcm9tIHRoZSBHUFVcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1BJWEkuRGlzcGxheU9iamVjdH0gZGlzcGxheU9iamVjdCAtIHRoZSBkaXNwbGF5T2JqZWN0IHRvIHJlbW92ZSB0aGUgdGV4dHVyZXMgZnJvbS5cclxuICAgICAqL1xyXG4gICAgdW5sb2FkKGRpc3BsYXlPYmplY3QpIHtcclxuICAgICAgICAvLyB2YXIgdG0gPSB0aGlzLnJlbmRlcmVyLnRleHR1cmVTeXN0ZW07XHJcbiAgICAgICAgdmFyIHRtID0gdGhpcy5yZW5kZXJlci50ZXh0dXJlO1xyXG4gICAgICAgIC8vIG9ubHkgZGVzdHJveSBub24gZ2VuZXJhdGVkIHRleHR1cmVzXHJcbiAgICAgICAgaWYgKGRpc3BsYXlPYmplY3QuX3RleHR1cmUgJiYgZGlzcGxheU9iamVjdC5fdGV4dHVyZS5fZ2xSZW5kZXJUYXJnZXRzKSB7XHJcbiAgICAgICAgICAgIHRtLmRlc3Ryb3lUZXh0dXJlKGRpc3BsYXlPYmplY3QuX3RleHR1cmUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKHZhciBpID0gZGlzcGxheU9iamVjdC5jaGlsZHJlbi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgICAgICB0aGlzLnVubG9hZChkaXNwbGF5T2JqZWN0LmNoaWxkcmVuW2ldKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICA7XHJcbn1cclxuZXhwb3J0cy5UZXh0dXJlR0NTeXN0ZW0gPSBUZXh0dXJlR0NTeXN0ZW07XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IE1hdHJpeF8xID0gcmVxdWlyZShcIi4vTWF0cml4XCIpO1xyXG5jbGFzcyBUZXh0dXJlTWF0cml4IHtcclxuICAgIGNvbnN0cnVjdG9yKHRleHR1cmUsIGNsYW1wTWFyZ2luID0gbnVsbCkge1xyXG4gICAgICAgIHRoaXMuX3RleHR1cmUgPSB0ZXh0dXJlO1xyXG4gICAgICAgIHRoaXMubWFwQ29vcmQgPSBuZXcgTWF0cml4XzEuTWF0cml4KCk7XHJcbiAgICAgICAgdGhpcy51Q2xhbXBGcmFtZSA9IG5ldyBGbG9hdDMyQXJyYXkoNCk7XHJcbiAgICAgICAgdGhpcy51Q2xhbXBPZmZzZXQgPSBuZXcgRmxvYXQzMkFycmF5KDIpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRyYWNrcyBUZXh0dXJlIGZyYW1lIGNoYW5nZXNcclxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgICAgICogQHByb3RlY3RlZFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuX3VwZGF0ZUlEID0gLTE7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2hhbmdlcyBmcmFtZSBjbGFtcGluZ1xyXG4gICAgICAgICAqIFdvcmtzIHdpdGggVGlsaW5nU3ByaXRlIGFuZCBNZXNoXHJcbiAgICAgICAgICogQ2hhbmdlIHRvIDEuNSBpZiB5b3UgdGV4dHVyZSBoYXMgcmVwZWF0ZWQgcmlnaHQgYW5kIGJvdHRvbSBsaW5lcywgdGhhdCBsZWFkcyB0byBzbW9vdGhlciBib3JkZXJzXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAZGVmYXVsdCAwXHJcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuY2xhbXBPZmZzZXQgPSAwO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENoYW5nZXMgZnJhbWUgY2xhbXBpbmdcclxuICAgICAgICAgKiBXb3JrcyB3aXRoIFRpbGluZ1Nwcml0ZSBhbmQgTWVzaFxyXG4gICAgICAgICAqIENoYW5nZSB0byAtMC41IHRvIGFkZCBhIHBpeGVsIHRvIHRoZSBlZGdlLCByZWNvbW1lbmRlZCBmb3IgdHJhbnNwYXJlbnQgdHJpbW1lZCB0ZXh0dXJlcyBpbiBhdGxhc1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGRlZmF1bHQgMC41XHJcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuY2xhbXBNYXJnaW4gPSAodHlwZW9mIGNsYW1wTWFyZ2luID09PSAndW5kZWZpbmVkJykgPyAwLjUgOiBjbGFtcE1hcmdpbjtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJZiB0ZXh0dXJlIHNpemUgaXMgdGhlIHNhbWUgYXMgYmFzZVRleHR1cmVcclxuICAgICAgICAgKiBAbWVtYmVyIHtib29sZWFufVxyXG4gICAgICAgICAqIEBkZWZhdWx0IGZhbHNlXHJcbiAgICAgICAgICogQHJlYWRvbmx5XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5pc1NpbXBsZSA9IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiB0ZXh0dXJlIHByb3BlcnR5XHJcbiAgICAgKiBAbWVtYmVyIHtQSVhJLlRleHR1cmV9XHJcbiAgICAgKi9cclxuICAgIGdldCB0ZXh0dXJlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl90ZXh0dXJlO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgc2V0IHRleHR1cmUodmFsdWUpIHtcclxuICAgICAgICB0aGlzLl90ZXh0dXJlID0gdmFsdWU7XHJcbiAgICAgICAgdGhpcy5fdXBkYXRlSUQgPSAtMTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogTXVsdGlwbGllcyB1dnMgYXJyYXkgdG8gdHJhbnNmb3JtXHJcbiAgICAgKiBAcGFyYW0ge0Zsb2F0MzJBcnJheX0gdXZzIG1lc2ggdXZzXHJcbiAgICAgKiBAcGFyYW0ge0Zsb2F0MzJBcnJheX0gW291dD11dnNdIG91dHB1dFxyXG4gICAgICogQHJldHVybnMge0Zsb2F0MzJBcnJheX0gb3V0cHV0XHJcbiAgICAgKi9cclxuICAgIG11bHRpcGx5VXZzKHV2cywgb3V0KSB7XHJcbiAgICAgICAgaWYgKG91dCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIG91dCA9IHV2cztcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIG1hdCA9IHRoaXMubWFwQ29vcmQ7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB1dnMubGVuZ3RoOyBpICs9IDIpIHtcclxuICAgICAgICAgICAgdmFyIHggPSB1dnNbaV07XHJcbiAgICAgICAgICAgIHZhciB5ID0gdXZzW2kgKyAxXTtcclxuICAgICAgICAgICAgb3V0W2ldID0gKHggKiBtYXQuYSkgKyAoeSAqIG1hdC5jKSArIG1hdC50eDtcclxuICAgICAgICAgICAgb3V0W2kgKyAxXSA9ICh4ICogbWF0LmIpICsgKHkgKiBtYXQuZCkgKyBtYXQudHk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBvdXQ7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIHVwZGF0ZXMgbWF0cmljZXMgaWYgdGV4dHVyZSB3YXMgY2hhbmdlZFxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBmb3JjZVVwZGF0ZSBpZiB0cnVlLCBtYXRyaWNlcyB3aWxsIGJlIHVwZGF0ZWQgYW55IGNhc2VcclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSB3aGV0aGVyIG9yIG5vdCBpdCB3YXMgdXBkYXRlZFxyXG4gICAgICovXHJcbiAgICB1cGRhdGUoZm9yY2VVcGRhdGUpIHtcclxuICAgICAgICB2YXIgdGV4ID0gdGhpcy5fdGV4dHVyZTtcclxuICAgICAgICBpZiAoIXRleCB8fCAhdGV4LnZhbGlkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFmb3JjZVVwZGF0ZVxyXG4gICAgICAgICAgICAmJiB0aGlzLl91cGRhdGVJRCA9PT0gdGV4Ll91cGRhdGVJRCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3VwZGF0ZUlEID0gdGV4Ll91cGRhdGVJRDtcclxuICAgICAgICB2YXIgdXZzID0gdGV4Ll91dnM7XHJcbiAgICAgICAgdGhpcy5tYXBDb29yZC5zZXQodXZzLngxIC0gdXZzLngwLCB1dnMueTEgLSB1dnMueTAsIHV2cy54MyAtIHV2cy54MCwgdXZzLnkzIC0gdXZzLnkwLCB1dnMueDAsIHV2cy55MCk7XHJcbiAgICAgICAgdmFyIG9yaWcgPSB0ZXgub3JpZztcclxuICAgICAgICB2YXIgdHJpbSA9IHRleC50cmltO1xyXG4gICAgICAgIGlmICh0cmltKSB7XHJcbiAgICAgICAgICAgIFRleHR1cmVNYXRyaXgudGVtcE1hdC5zZXQob3JpZy53aWR0aCAvIHRyaW0ud2lkdGgsIDAsIDAsIG9yaWcuaGVpZ2h0IC8gdHJpbS5oZWlnaHQsIC10cmltLnggLyB0cmltLndpZHRoLCAtdHJpbS55IC8gdHJpbS5oZWlnaHQpO1xyXG4gICAgICAgICAgICB0aGlzLm1hcENvb3JkLmFwcGVuZChUZXh0dXJlTWF0cml4LnRlbXBNYXQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgdGV4QmFzZSA9IHRleC5iYXNlVGV4dHVyZTtcclxuICAgICAgICB2YXIgZnJhbWUgPSB0aGlzLnVDbGFtcEZyYW1lO1xyXG4gICAgICAgIHZhciBtYXJnaW4gPSB0aGlzLmNsYW1wTWFyZ2luIC8gdGV4QmFzZS5yZXNvbHV0aW9uO1xyXG4gICAgICAgIHZhciBvZmZzZXQgPSB0aGlzLmNsYW1wT2Zmc2V0O1xyXG4gICAgICAgIGZyYW1lWzBdID0gKHRleC5fZnJhbWUueCArIG1hcmdpbiArIG9mZnNldCkgLyB0ZXhCYXNlLndpZHRoO1xyXG4gICAgICAgIGZyYW1lWzFdID0gKHRleC5fZnJhbWUueSArIG1hcmdpbiArIG9mZnNldCkgLyB0ZXhCYXNlLmhlaWdodDtcclxuICAgICAgICBmcmFtZVsyXSA9ICh0ZXguX2ZyYW1lLnggKyB0ZXguX2ZyYW1lLndpZHRoIC0gbWFyZ2luICsgb2Zmc2V0KSAvIHRleEJhc2Uud2lkdGg7XHJcbiAgICAgICAgZnJhbWVbM10gPSAodGV4Ll9mcmFtZS55ICsgdGV4Ll9mcmFtZS5oZWlnaHQgLSBtYXJnaW4gKyBvZmZzZXQpIC8gdGV4QmFzZS5oZWlnaHQ7XHJcbiAgICAgICAgdGhpcy51Q2xhbXBPZmZzZXRbMF0gPSBvZmZzZXQgLyB0ZXhCYXNlLnJlYWxXaWR0aDtcclxuICAgICAgICB0aGlzLnVDbGFtcE9mZnNldFsxXSA9IG9mZnNldCAvIHRleEJhc2UucmVhbEhlaWdodDtcclxuICAgICAgICB0aGlzLmlzU2ltcGxlID0gdGV4Ll9mcmFtZS53aWR0aCA9PT0gdGV4QmFzZS53aWR0aFxyXG4gICAgICAgICAgICAmJiB0ZXguX2ZyYW1lLmhlaWdodCA9PT0gdGV4QmFzZS5oZWlnaHRcclxuICAgICAgICAgICAgJiYgdGV4LnJvdGF0ZSA9PT0gMDtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIDtcclxufVxyXG5UZXh0dXJlTWF0cml4LnRlbXBNYXQgPSBuZXcgTWF0cml4XzEuTWF0cml4KCk7XHJcbmV4cG9ydHMuVGV4dHVyZU1hdHJpeCA9IFRleHR1cmVNYXRyaXg7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IFN5c3RlbV8xID0gcmVxdWlyZShcIi4vU3lzdGVtXCIpO1xyXG5jb25zdCBCYXNlVGV4dHVyZV8xID0gcmVxdWlyZShcIi4vQmFzZVRleHR1cmVcIik7XHJcbmNvbnN0IEdMVGV4dHVyZV8xID0gcmVxdWlyZShcIi4vR0xUZXh0dXJlXCIpO1xyXG5jb25zdCBVdGlsc1NldHRpbmdzXzEgPSByZXF1aXJlKFwiLi9VdGlsc1NldHRpbmdzXCIpO1xyXG5jb25zdCBXZWJHTFNldHRpbmdzXzEgPSByZXF1aXJlKFwiLi9XZWJHTFNldHRpbmdzXCIpO1xyXG5jb25zdCBMb2dnZXJfMSA9IHJlcXVpcmUoXCIuL0xvZ2dlclwiKTtcclxuY2xhc3MgVGV4dHVyZVN5c3RlbSBleHRlbmRzIFN5c3RlbV8xLlN5c3RlbSB7XHJcbiAgICBjb25zdHJ1Y3RvcihyZW5kZXJlcikge1xyXG4gICAgICAgIHN1cGVyKHJlbmRlcmVyKTtcclxuICAgICAgICAvLyBUT0RPIHNldCB0byBtYXggdGV4dHVyZXMuLi5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBCb3VuZCB0ZXh0dXJlc1xyXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuQmFzZVRleHR1cmVbXX1cclxuICAgICAgICAgKiBAcmVhZG9ubHlcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmJvdW5kVGV4dHVyZXMgPSBbXTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDdXJyZW50IGxvY2F0aW9uXHJcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICAgICAqIEByZWFkb25seVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuY3VycmVudExvY2F0aW9uID0gLTE7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogTGlzdCBvZiBtYW5hZ2VkIHRleHR1cmVzXHJcbiAgICAgICAgICogQG1lbWJlciB7UElYSS5CYXNlVGV4dHVyZVtdfVxyXG4gICAgICAgICAqIEByZWFkb25seVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMubWFuYWdlZFRleHR1cmVzID0gW107XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRGlkIHNvbWVvbmUgdGVtcGVyIHdpdGggdGV4dHVyZXMgc3RhdGU/IFdlJ2xsIG92ZXJ3cml0ZSB0aGVtIHdoZW4gd2UgbmVlZCB0byB1bmJpbmQgc29tZXRoaW5nLlxyXG4gICAgICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLl91bmtub3duQm91bmRUZXh0dXJlcyA9IGZhbHNlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEJhc2VUZXh0dXJlIHZhbHVlIHRoYXQgc2hvd3MgdGhhdCB3ZSBkb24ndCBrbm93IHdoYXQgaXMgYm91bmRcclxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLkJhc2VUZXh0dXJlfVxyXG4gICAgICAgICAqIEByZWFkb25seVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMudW5rbm93blRleHR1cmUgPSBuZXcgQmFzZVRleHR1cmVfMS5CYXNlVGV4dHVyZSgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHVwIHRoZSByZW5kZXJlciBjb250ZXh0IGFuZCBuZWNlc3NhcnkgYnVmZmVycy5cclxuICAgICAqL1xyXG4gICAgY29udGV4dENoYW5nZSgpIHtcclxuICAgICAgICB2YXIgZ2wgPSB0aGlzLmdsID0gdGhpcy5yZW5kZXJlci5nbDtcclxuICAgICAgICB0aGlzLkNPTlRFWFRfVUlEID0gdGhpcy5yZW5kZXJlci5DT05URVhUX1VJRDtcclxuICAgICAgICB0aGlzLndlYkdMVmVyc2lvbiA9IHRoaXMucmVuZGVyZXIuY29udGV4dC53ZWJHTFZlcnNpb247XHJcbiAgICAgICAgdmFyIG1heFRleHR1cmVzID0gZ2wuZ2V0UGFyYW1ldGVyKGdsLk1BWF9URVhUVVJFX0lNQUdFX1VOSVRTKTtcclxuICAgICAgICB0aGlzLmJvdW5kVGV4dHVyZXMubGVuZ3RoID0gbWF4VGV4dHVyZXM7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXhUZXh0dXJlczsgaSsrKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYm91bmRUZXh0dXJlc1tpXSA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFRPRE8gbW92ZSB0aGlzLi4gdG8gYSBuaWNlIG1ha2UgZW1wdHkgdGV4dHVyZXMgY2xhc3MuLlxyXG4gICAgICAgIHRoaXMuZW1wdHlUZXh0dXJlcyA9IHt9O1xyXG4gICAgICAgIHZhciBlbXB0eVRleHR1cmUyRCA9IG5ldyBHTFRleHR1cmVfMS5HTFRleHR1cmUoZ2wuY3JlYXRlVGV4dHVyZSgpKTtcclxuICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBlbXB0eVRleHR1cmUyRC50ZXh0dXJlKTtcclxuICAgICAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIDEsIDEsIDAsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIG5ldyBVaW50OEFycmF5KDQpKTtcclxuICAgICAgICB0aGlzLmVtcHR5VGV4dHVyZXNbZ2wuVEVYVFVSRV8yRF0gPSBlbXB0eVRleHR1cmUyRDtcclxuICAgICAgICB0aGlzLmVtcHR5VGV4dHVyZXNbZ2wuVEVYVFVSRV9DVUJFX01BUF0gPSBuZXcgR0xUZXh0dXJlXzEuR0xUZXh0dXJlKGdsLmNyZWF0ZVRleHR1cmUoKSk7XHJcbiAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV9DVUJFX01BUCwgdGhpcy5lbXB0eVRleHR1cmVzW2dsLlRFWFRVUkVfQ1VCRV9NQVBdLnRleHR1cmUpO1xyXG4gICAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IDY7IGkkMSsrKSB7XHJcbiAgICAgICAgICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YICsgaSQxLCAwLCBnbC5SR0JBLCAxLCAxLCAwLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBudWxsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFX0NVQkVfTUFQLCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLkxJTkVBUik7XHJcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFX0NVQkVfTUFQLCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLkxJTkVBUik7XHJcbiAgICAgICAgZm9yICh2YXIgaSQyID0gMDsgaSQyIDwgdGhpcy5ib3VuZFRleHR1cmVzLmxlbmd0aDsgaSQyKyspIHtcclxuICAgICAgICAgICAgdGhpcy5iaW5kKG51bGwsIGkkMik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBCaW5kIGEgdGV4dHVyZSB0byBhIHNwZWNpZmljIGxvY2F0aW9uXHJcbiAgICAgKlxyXG4gICAgICogSWYgeW91IHdhbnQgdG8gdW5iaW5kIHNvbWV0aGluZywgcGxlYXNlIHVzZSBgdW5iaW5kKHRleHR1cmUpYCBpbnN0ZWFkIG9mIGBiaW5kKG51bGwsIHRleHR1cmVMb2NhdGlvbilgXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtQSVhJLlRleHR1cmV8UElYSS5CYXNlVGV4dHVyZX0gdGV4dHVyZSAtIFRleHR1cmUgdG8gYmluZFxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtsb2NhdGlvbj0wXSAtIExvY2F0aW9uIHRvIGJpbmQgYXRcclxuICAgICAqL1xyXG4gICAgYmluZCh0ZXh0dXJlLCBsb2NhdGlvbiA9IDApIHtcclxuICAgICAgICB2YXIgcmVmID0gdGhpcztcclxuICAgICAgICB2YXIgZ2wgPSByZWYuZ2w7XHJcbiAgICAgICAgaWYgKHRleHR1cmUpIHtcclxuICAgICAgICAgICAgdGV4dHVyZSA9IHRleHR1cmUuYmFzZVRleHR1cmUgfHwgdGV4dHVyZTtcclxuICAgICAgICAgICAgaWYgKHRleHR1cmUudmFsaWQpIHtcclxuICAgICAgICAgICAgICAgIHRleHR1cmUudG91Y2hlZCA9IHRoaXMucmVuZGVyZXIudGV4dHVyZUdDLmNvdW50O1xyXG4gICAgICAgICAgICAgICAgdmFyIGdsVGV4dHVyZSA9IHRleHR1cmUuX2dsVGV4dHVyZXNbdGhpcy5DT05URVhUX1VJRF0gfHwgdGhpcy5pbml0VGV4dHVyZSh0ZXh0dXJlKTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRMb2NhdGlvbiAhPT0gbG9jYXRpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRMb2NhdGlvbiA9IGxvY2F0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTAgKyBsb2NhdGlvbik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5ib3VuZFRleHR1cmVzW2xvY2F0aW9uXSAhPT0gdGV4dHVyZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGdsLmJpbmRUZXh0dXJlKHRleHR1cmUudGFyZ2V0LCBnbFRleHR1cmUudGV4dHVyZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoZ2xUZXh0dXJlLmRpcnR5SWQgIT09IHRleHR1cmUuZGlydHlJZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlVGV4dHVyZSh0ZXh0dXJlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuYm91bmRUZXh0dXJlc1tsb2NhdGlvbl0gPSB0ZXh0dXJlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50TG9jYXRpb24gIT09IGxvY2F0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRMb2NhdGlvbiA9IGxvY2F0aW9uO1xyXG4gICAgICAgICAgICAgICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCArIGxvY2F0aW9uKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0aGlzLmVtcHR5VGV4dHVyZXNbZ2wuVEVYVFVSRV8yRF0udGV4dHVyZSk7XHJcbiAgICAgICAgICAgIHRoaXMuYm91bmRUZXh0dXJlc1tsb2NhdGlvbl0gPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogUmVzZXRzIHRleHR1cmUgbG9jYXRpb24gYW5kIGJvdW5kIHRleHR1cmVzXHJcbiAgICAgKlxyXG4gICAgICogQWN0dWFsIGBiaW5kKG51bGwsIGkpYCBjYWxscyB3aWxsIGJlIHBlcmZvcm1lZCBhdCBuZXh0IGB1bmJpbmQoKWAgY2FsbFxyXG4gICAgICovXHJcbiAgICByZXNldCgpIHtcclxuICAgICAgICB0aGlzLl91bmtub3duQm91bmRUZXh0dXJlcyA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50TG9jYXRpb24gPSAtMTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYm91bmRUZXh0dXJlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB0aGlzLmJvdW5kVGV4dHVyZXNbaV0gPSB0aGlzLnVua25vd25UZXh0dXJlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogVW5iaW5kIGEgdGV4dHVyZVxyXG4gICAgICogQHBhcmFtIHtQSVhJLlRleHR1cmV8UElYSS5CYXNlVGV4dHVyZX0gdGV4dHVyZSAtIFRleHR1cmUgdG8gYmluZFxyXG4gICAgICovXHJcbiAgICB1bmJpbmQodGV4dHVyZSkge1xyXG4gICAgICAgIHZhciByZWYgPSB0aGlzO1xyXG4gICAgICAgIHZhciBnbCA9IHJlZi5nbDtcclxuICAgICAgICB2YXIgYm91bmRUZXh0dXJlcyA9IHJlZi5ib3VuZFRleHR1cmVzO1xyXG4gICAgICAgIGlmICh0aGlzLl91bmtub3duQm91bmRUZXh0dXJlcykge1xyXG4gICAgICAgICAgICB0aGlzLl91bmtub3duQm91bmRUZXh0dXJlcyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAvLyBzb21lb25lIGNoYW5nZWQgd2ViR0wgc3RhdGUsXHJcbiAgICAgICAgICAgIC8vIHdlIGhhdmUgdG8gYmUgc3VyZSB0aGF0IG91ciB0ZXh0dXJlIGRvZXMgbm90IGFwcGVhciBpbiBtdWx0aS10ZXh0dXJlIHJlbmRlcmVyIHNhbXBsZXJzXHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYm91bmRUZXh0dXJlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGJvdW5kVGV4dHVyZXNbaV0gPT09IHRoaXMudW5rbm93blRleHR1cmUpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmJpbmQobnVsbCwgaSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgYm91bmRUZXh0dXJlcy5sZW5ndGg7IGkkMSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChib3VuZFRleHR1cmVzW2kkMV0gPT09IHRleHR1cmUpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRMb2NhdGlvbiAhPT0gaSQxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCArIGkkMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50TG9jYXRpb24gPSBpJDE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0aGlzLmVtcHR5VGV4dHVyZXNbdGV4dHVyZS50YXJnZXRdLnRleHR1cmUpO1xyXG4gICAgICAgICAgICAgICAgYm91bmRUZXh0dXJlc1tpJDFdID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogSW5pdGlhbGl6ZSBhIHRleHR1cmVcclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtQSVhJLkJhc2VUZXh0dXJlfSB0ZXh0dXJlIC0gVGV4dHVyZSB0byBpbml0aWFsaXplXHJcbiAgICAgKi9cclxuICAgIGluaXRUZXh0dXJlKHRleHR1cmUpIHtcclxuICAgICAgICB2YXIgZ2xUZXh0dXJlID0gbmV3IEdMVGV4dHVyZV8xLkdMVGV4dHVyZSh0aGlzLmdsLmNyZWF0ZVRleHR1cmUoKSk7XHJcbiAgICAgICAgLy8gZ3VhcmFudGVlIGFuIHVwZGF0ZS4uXHJcbiAgICAgICAgZ2xUZXh0dXJlLmRpcnR5SWQgPSAtMTtcclxuICAgICAgICB0ZXh0dXJlLl9nbFRleHR1cmVzW3RoaXMuQ09OVEVYVF9VSURdID0gZ2xUZXh0dXJlO1xyXG4gICAgICAgIHRoaXMubWFuYWdlZFRleHR1cmVzLnB1c2godGV4dHVyZSk7XHJcbiAgICAgICAgLy8gdGV4dHVyZS5vbignZGlzcG9zZScsIHRoaXMuZGVzdHJveVRleHR1cmUsIHRoaXMpO1xyXG4gICAgICAgIHJldHVybiBnbFRleHR1cmU7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZSBhIHRleHR1cmVcclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtQSVhJLkJhc2VUZXh0dXJlfSB0ZXh0dXJlIC0gVGV4dHVyZSB0byBpbml0aWFsaXplXHJcbiAgICAgKi9cclxuICAgIHVwZGF0ZVRleHR1cmUodGV4dHVyZSkge1xyXG4gICAgICAgIHZhciBnbFRleHR1cmUgPSB0ZXh0dXJlLl9nbFRleHR1cmVzW3RoaXMuQ09OVEVYVF9VSURdO1xyXG4gICAgICAgIHZhciByZW5kZXJlciA9IHRoaXMucmVuZGVyZXI7XHJcbiAgICAgICAgaWYgKHRleHR1cmUucmVzb3VyY2UgJiYgdGV4dHVyZS5yZXNvdXJjZS5jYW5VcGxvYWQpIHtcclxuICAgICAgICAgICAgdGV4dHVyZS5yZXNvdXJjZS51cGxvYWQocmVuZGVyZXIsIHRleHR1cmUsIGdsVGV4dHVyZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGlmICh0ZXh0dXJlLnJlc291cmNlICYmIHRleHR1cmUucmVzb3VyY2UudXBsb2FkKHJlbmRlcmVyLCB0ZXh0dXJlLCBnbFRleHR1cmUpKVxyXG4gICAgICAgIGVsc2UgaWYgKHRleHR1cmUucmVzb3VyY2UgJiYgdGhpcy51cGxvYWRUZXh0dXJlKHJlbmRlcmVyLCB0ZXh0dXJlLCBnbFRleHR1cmUsIHRleHR1cmUucmVzb3VyY2UpKSB7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBkZWZhdWx0LCByZW5kZXJUZXh0dXJlLWxpa2UgbG9naWNcclxuICAgICAgICAgICAgdmFyIHdpZHRoID0gdGV4dHVyZS5yZWFsV2lkdGg7XHJcbiAgICAgICAgICAgIHZhciBoZWlnaHQgPSB0ZXh0dXJlLnJlYWxIZWlnaHQ7XHJcbiAgICAgICAgICAgIHZhciBnbCA9IHJlbmRlcmVyLmdsO1xyXG4gICAgICAgICAgICBpZiAoZ2xUZXh0dXJlLndpZHRoICE9PSB3aWR0aFxyXG4gICAgICAgICAgICAgICAgfHwgZ2xUZXh0dXJlLmhlaWdodCAhPT0gaGVpZ2h0XHJcbiAgICAgICAgICAgICAgICB8fCBnbFRleHR1cmUuZGlydHlJZCA8IDApIHtcclxuICAgICAgICAgICAgICAgIGdsVGV4dHVyZS53aWR0aCA9IHdpZHRoO1xyXG4gICAgICAgICAgICAgICAgZ2xUZXh0dXJlLmhlaWdodCA9IGhlaWdodDtcclxuICAgICAgICAgICAgICAgIGdsLnRleEltYWdlMkQodGV4dHVyZS50YXJnZXQsIDAsIHRleHR1cmUuZm9ybWF0LCB3aWR0aCwgaGVpZ2h0LCAwLCB0ZXh0dXJlLmZvcm1hdCwgdGV4dHVyZS50eXBlLCBudWxsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBsZXRzIG9ubHkgdXBkYXRlIHdoYXQgY2hhbmdlcy4uXHJcbiAgICAgICAgaWYgKHRleHR1cmUuZGlydHlTdHlsZUlkICE9PSBnbFRleHR1cmUuZGlydHlTdHlsZUlkKSB7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVGV4dHVyZVN0eWxlKHRleHR1cmUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBnbFRleHR1cmUuZGlydHlJZCA9IHRleHR1cmUuZGlydHlJZDtcclxuICAgIH1cclxuICAgIDtcclxuICAgIHVwbG9hZFRleHR1cmUocmVuZGVyZXIsIGJhc2VUZXh0dXJlLCBnbFRleHR1cmUsIHNvdXJjZSkge1xyXG4gICAgICAgIHZhciBnbCA9IHJlbmRlcmVyLmdsO1xyXG4gICAgICAgIHZhciB3aWR0aCA9IGJhc2VUZXh0dXJlLnJlYWxXaWR0aDtcclxuICAgICAgICB2YXIgaGVpZ2h0ID0gYmFzZVRleHR1cmUucmVhbEhlaWdodDtcclxuICAgICAgICAvLyBzb3VyY2UgPSBzb3VyY2UgfHwgdGhpcy5zb3VyY2U7XHJcbiAgICAgICAgaWYgKHNvdXJjZS5jb25zdHJ1Y3RvclsnbmFtZSddID09IFwiQ2FudmFzUmVzb3VyY2VcIikge1xyXG4gICAgICAgICAgICBzb3VyY2UgPSBzb3VyY2Uuc291cmNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChzb3VyY2UuY29uc3RydWN0b3JbJ25hbWUnXSA9PSBcIkltYWdlUmVzb3VyY2VcIikge1xyXG4gICAgICAgICAgICBzb3VyY2UgPSBzb3VyY2Uuc291cmNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChzb3VyY2UuY29uc3RydWN0b3JbJ25hbWUnXSA9PSBcIlZpZGVvUmVzb3VyY2VcIikge1xyXG4gICAgICAgICAgICBzb3VyY2UgPSBzb3VyY2Uuc291cmNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBlbHNlIGlmKHNvdXJjZS5jb25zdHJ1Y3RvclsnbmFtZSddID09IFwiR3JhZGllbnRSZXNvdXJjZVwiKVxyXG4gICAgICAgIC8vIHtcclxuICAgICAgICAvLyAgICAgaWYoIXNvdXJjZS5zb3VyY2UpXHJcbiAgICAgICAgLy8gICAgIHtcclxuICAgICAgICAvLyAgICAgICAgIHJldHVyblxyXG4gICAgICAgIC8vICAgICB9XHJcbiAgICAgICAgLy8gICAgIHNvdXJjZSA9IHNvdXJjZS5zb3VyY2VcclxuICAgICAgICAvLyAgICAgcmV2ZWFsKHNvdXJjZSlcclxuICAgICAgICAvLyB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIExvZ2dlcl8xLnJldmVhbChzb3VyY2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBnbC5waXhlbFN0b3JlaShnbC5VTlBBQ0tfUFJFTVVMVElQTFlfQUxQSEFfV0VCR0wsIGJhc2VUZXh0dXJlLnByZW11bHRpcGx5QWxwaGEpO1xyXG4gICAgICAgIGlmIChiYXNlVGV4dHVyZS50YXJnZXQgPT09IGdsLlRFWFRVUkVfMkQgJiYgZ2xUZXh0dXJlLndpZHRoID09PSB3aWR0aCAmJiBnbFRleHR1cmUuaGVpZ2h0ID09PSBoZWlnaHQpIHtcclxuICAgICAgICAgICAgZ2wudGV4U3ViSW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCAwLCAwLCBiYXNlVGV4dHVyZS5mb3JtYXQsIGJhc2VUZXh0dXJlLnR5cGUsIHNvdXJjZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBnbFRleHR1cmUud2lkdGggPSB3aWR0aDtcclxuICAgICAgICAgICAgZ2xUZXh0dXJlLmhlaWdodCA9IGhlaWdodDtcclxuICAgICAgICAgICAgZ2wudGV4SW1hZ2UyRChiYXNlVGV4dHVyZS50YXJnZXQsIDAsIGJhc2VUZXh0dXJlLmZvcm1hdCwgYmFzZVRleHR1cmUuZm9ybWF0LCBiYXNlVGV4dHVyZS50eXBlLCBzb3VyY2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogRGVsZXRlcyB0aGUgdGV4dHVyZSBmcm9tIFdlYkdMXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7UElYSS5CYXNlVGV4dHVyZXxQSVhJLlRleHR1cmV9IHRleHR1cmUgLSB0aGUgdGV4dHVyZSB0byBkZXN0cm95XHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtza2lwUmVtb3ZlPWZhbHNlXSAtIFdoZXRoZXIgdG8gc2tpcCByZW1vdmluZyB0aGUgdGV4dHVyZSBmcm9tIHRoZSBUZXh0dXJlTWFuYWdlci5cclxuICAgICAqL1xyXG4gICAgZGVzdHJveVRleHR1cmUodGV4dHVyZSwgc2tpcFJlbW92ZSA9IGZhbHNlKSB7XHJcbiAgICAgICAgdmFyIHJlZiA9IHRoaXM7XHJcbiAgICAgICAgdmFyIGdsID0gcmVmLmdsO1xyXG4gICAgICAgIHRleHR1cmUgPSB0ZXh0dXJlLmJhc2VUZXh0dXJlIHx8IHRleHR1cmU7XHJcbiAgICAgICAgaWYgKHRleHR1cmUuX2dsVGV4dHVyZXNbdGhpcy5yZW5kZXJlci5DT05URVhUX1VJRF0pIHtcclxuICAgICAgICAgICAgdGhpcy51bmJpbmQodGV4dHVyZSk7XHJcbiAgICAgICAgICAgIGdsLmRlbGV0ZVRleHR1cmUodGV4dHVyZS5fZ2xUZXh0dXJlc1t0aGlzLnJlbmRlcmVyLkNPTlRFWFRfVUlEXS50ZXh0dXJlKTtcclxuICAgICAgICAgICAgLy8gdGV4dHVyZS5vZmYoJ2Rpc3Bvc2UnLCB0aGlzLmRlc3Ryb3lUZXh0dXJlLCB0aGlzKTtcclxuICAgICAgICAgICAgZGVsZXRlIHRleHR1cmUuX2dsVGV4dHVyZXNbdGhpcy5yZW5kZXJlci5DT05URVhUX1VJRF07XHJcbiAgICAgICAgICAgIGlmICghc2tpcFJlbW92ZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGkgPSB0aGlzLm1hbmFnZWRUZXh0dXJlcy5pbmRleE9mKHRleHR1cmUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGkgIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgVXRpbHNTZXR0aW5nc18xLlV0aWxzU2V0dGluZ3MucmVtb3ZlSXRlbXModGhpcy5tYW5hZ2VkVGV4dHVyZXMsIGksIDEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGUgdGV4dHVyZSBzdHlsZSBzdWNoIGFzIG1pcG1hcCBmbGFnXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7UElYSS5CYXNlVGV4dHVyZX0gdGV4dHVyZSAtIFRleHR1cmUgdG8gdXBkYXRlXHJcbiAgICAgKi9cclxuICAgIHVwZGF0ZVRleHR1cmVTdHlsZSh0ZXh0dXJlKSB7XHJcbiAgICAgICAgdmFyIGdsVGV4dHVyZSA9IHRleHR1cmUuX2dsVGV4dHVyZXNbdGhpcy5DT05URVhUX1VJRF07XHJcbiAgICAgICAgaWYgKCFnbFRleHR1cmUpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoKHRleHR1cmUubWlwbWFwID09PSBXZWJHTFNldHRpbmdzXzEuV2ViR0xTZXR0aW5ncy5NSVBNQVBfTU9ERVMuUE9XMiB8fCB0aGlzLndlYkdMVmVyc2lvbiAhPT0gMikgJiYgIXRleHR1cmUuaXNQb3dlck9mVHdvKSB7XHJcbiAgICAgICAgICAgIGdsVGV4dHVyZS5taXBtYXAgPSAwO1xyXG4gICAgICAgICAgICBnbFRleHR1cmUud3JhcE1vZGUgPSBXZWJHTFNldHRpbmdzXzEuV2ViR0xTZXR0aW5ncy5XUkFQX01PREVTLkNMQU1QO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZ2xUZXh0dXJlLm1pcG1hcCA9IHRleHR1cmUubWlwbWFwID49IDE7XHJcbiAgICAgICAgICAgIGdsVGV4dHVyZS53cmFwTW9kZSA9IHRleHR1cmUud3JhcE1vZGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGlmICh0ZXh0dXJlLnJlc291cmNlICYmIHRleHR1cmUucmVzb3VyY2Uuc3R5bGUodGhpcy5yZW5kZXJlciwgdGV4dHVyZSwgZ2xUZXh0dXJlKSlcclxuICAgICAgICAvLyB7IDsgfVxyXG4gICAgICAgIC8vIGVsc2VcclxuICAgICAgICAvLyB7XHJcbiAgICAgICAgdGhpcy5zZXRTdHlsZSh0ZXh0dXJlLCBnbFRleHR1cmUpO1xyXG4gICAgICAgIC8vIH1cclxuICAgICAgICBnbFRleHR1cmUuZGlydHlTdHlsZUlkID0gdGV4dHVyZS5kaXJ0eVN0eWxlSWQ7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFNldCBzdHlsZSBmb3IgdGV4dHVyZVxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge1BJWEkuQmFzZVRleHR1cmV9IHRleHR1cmUgLSBUZXh0dXJlIHRvIHVwZGF0ZVxyXG4gICAgICogQHBhcmFtIHtnbFRleHR1cmV9IGdsVGV4dHVyZVxyXG4gICAgICovXHJcbiAgICBzZXRTdHlsZSh0ZXh0dXJlLCBnbFRleHR1cmUpIHtcclxuICAgICAgICB2YXIgZ2wgPSB0aGlzLmdsO1xyXG4gICAgICAgIGlmIChnbFRleHR1cmUubWlwbWFwKSB7XHJcbiAgICAgICAgICAgIGdsLmdlbmVyYXRlTWlwbWFwKHRleHR1cmUudGFyZ2V0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaSh0ZXh0dXJlLnRhcmdldCwgZ2wuVEVYVFVSRV9XUkFQX1MsIGdsVGV4dHVyZS53cmFwTW9kZSk7XHJcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaSh0ZXh0dXJlLnRhcmdldCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsVGV4dHVyZS53cmFwTW9kZSk7XHJcbiAgICAgICAgaWYgKGdsVGV4dHVyZS5taXBtYXApIHtcclxuICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xyXG4gICAgICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKHRleHR1cmUudGFyZ2V0LCBnbC5URVhUVVJFX01JTl9GSUxURVIsIHRleHR1cmUuc2NhbGVNb2RlID8gZ2wuTElORUFSX01JUE1BUF9MSU5FQVIgOiBnbC5ORUFSRVNUX01JUE1BUF9ORUFSRVNUKTtcclxuICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZ2wudGV4UGFyYW1ldGVyaSh0ZXh0dXJlLnRhcmdldCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCB0ZXh0dXJlLnNjYWxlTW9kZSA/IGdsLkxJTkVBUiA6IGdsLk5FQVJFU1QpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKHRleHR1cmUudGFyZ2V0LCBnbC5URVhUVVJFX01BR19GSUxURVIsIHRleHR1cmUuc2NhbGVNb2RlID8gZ2wuTElORUFSIDogZ2wuTkVBUkVTVCk7XHJcbiAgICB9XHJcbiAgICA7XHJcbn1cclxuZXhwb3J0cy5UZXh0dXJlU3lzdGVtID0gVGV4dHVyZVN5c3RlbTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgR3JvdXBEOF8xID0gcmVxdWlyZShcIi4vR3JvdXBEOFwiKTtcclxuY2xhc3MgVGV4dHVyZVV2cyB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLngwID0gMDtcclxuICAgICAgICB0aGlzLnkwID0gMDtcclxuICAgICAgICB0aGlzLngxID0gMTtcclxuICAgICAgICB0aGlzLnkxID0gMDtcclxuICAgICAgICB0aGlzLngyID0gMTtcclxuICAgICAgICB0aGlzLnkyID0gMTtcclxuICAgICAgICB0aGlzLngzID0gMDtcclxuICAgICAgICB0aGlzLnkzID0gMTtcclxuICAgICAgICB0aGlzLnV2c0Zsb2F0MzIgPSBuZXcgRmxvYXQzMkFycmF5KDgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAqIFNldHMgdGhlIHRleHR1cmUgVXZzIGJhc2VkIG9uIHRoZSBnaXZlbiBmcmFtZSBpbmZvcm1hdGlvbi5cclxuICpcclxuICogQHByb3RlY3RlZFxyXG4gKiBAcGFyYW0ge1BJWEkuUmVjdGFuZ2xlfSBmcmFtZSAtIFRoZSBmcmFtZSBvZiB0aGUgdGV4dHVyZVxyXG4gKiBAcGFyYW0ge1BJWEkuUmVjdGFuZ2xlfSBiYXNlRnJhbWUgLSBUaGUgYmFzZSBmcmFtZSBvZiB0aGUgdGV4dHVyZVxyXG4gKiBAcGFyYW0ge251bWJlcn0gcm90YXRlIC0gUm90YXRpb24gb2YgZnJhbWUsIHNlZSB7QGxpbmsgUElYSS5Hcm91cEQ4fVxyXG4gKi9cclxuICAgIHNldChmcmFtZSwgYmFzZUZyYW1lLCByb3RhdGUpIHtcclxuICAgICAgICB2YXIgdHcgPSBiYXNlRnJhbWUud2lkdGg7XHJcbiAgICAgICAgdmFyIHRoID0gYmFzZUZyYW1lLmhlaWdodDtcclxuICAgICAgICBpZiAocm90YXRlKSB7XHJcbiAgICAgICAgICAgIC8vIHdpZHRoIGFuZCBoZWlnaHQgZGl2IDIgZGl2IGJhc2VGcmFtZSBzaXplXHJcbiAgICAgICAgICAgIHZhciB3MiA9IGZyYW1lLndpZHRoIC8gMiAvIHR3O1xyXG4gICAgICAgICAgICB2YXIgaDIgPSBmcmFtZS5oZWlnaHQgLyAyIC8gdGg7XHJcbiAgICAgICAgICAgIC8vIGNvb3JkaW5hdGVzIG9mIGNlbnRlclxyXG4gICAgICAgICAgICB2YXIgY1ggPSAoZnJhbWUueCAvIHR3KSArIHcyO1xyXG4gICAgICAgICAgICB2YXIgY1kgPSAoZnJhbWUueSAvIHRoKSArIGgyO1xyXG4gICAgICAgICAgICByb3RhdGUgPSBHcm91cEQ4XzEuR3JvdXBEOC5hZGQocm90YXRlLCBHcm91cEQ4XzEuR3JvdXBEOC5OVyk7IC8vIE5XIGlzIHRvcC1sZWZ0IGNvcm5lclxyXG4gICAgICAgICAgICB0aGlzLngwID0gY1ggKyAodzIgKiBHcm91cEQ4XzEuR3JvdXBEOC51WChyb3RhdGUpKTtcclxuICAgICAgICAgICAgdGhpcy55MCA9IGNZICsgKGgyICogR3JvdXBEOF8xLkdyb3VwRDgudVkocm90YXRlKSk7XHJcbiAgICAgICAgICAgIHJvdGF0ZSA9IEdyb3VwRDhfMS5Hcm91cEQ4LmFkZChyb3RhdGUsIDIpOyAvLyByb3RhdGUgOTAgZGVncmVlcyBjbG9ja3dpc2VcclxuICAgICAgICAgICAgdGhpcy54MSA9IGNYICsgKHcyICogR3JvdXBEOF8xLkdyb3VwRDgudVgocm90YXRlKSk7XHJcbiAgICAgICAgICAgIHRoaXMueTEgPSBjWSArIChoMiAqIEdyb3VwRDhfMS5Hcm91cEQ4LnVZKHJvdGF0ZSkpO1xyXG4gICAgICAgICAgICByb3RhdGUgPSBHcm91cEQ4XzEuR3JvdXBEOC5hZGQocm90YXRlLCAyKTtcclxuICAgICAgICAgICAgdGhpcy54MiA9IGNYICsgKHcyICogR3JvdXBEOF8xLkdyb3VwRDgudVgocm90YXRlKSk7XHJcbiAgICAgICAgICAgIHRoaXMueTIgPSBjWSArIChoMiAqIEdyb3VwRDhfMS5Hcm91cEQ4LnVZKHJvdGF0ZSkpO1xyXG4gICAgICAgICAgICByb3RhdGUgPSBHcm91cEQ4XzEuR3JvdXBEOC5hZGQocm90YXRlLCAyKTtcclxuICAgICAgICAgICAgdGhpcy54MyA9IGNYICsgKHcyICogR3JvdXBEOF8xLkdyb3VwRDgudVgocm90YXRlKSk7XHJcbiAgICAgICAgICAgIHRoaXMueTMgPSBjWSArIChoMiAqIEdyb3VwRDhfMS5Hcm91cEQ4LnVZKHJvdGF0ZSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy54MCA9IGZyYW1lLnggLyB0dztcclxuICAgICAgICAgICAgdGhpcy55MCA9IGZyYW1lLnkgLyB0aDtcclxuICAgICAgICAgICAgdGhpcy54MSA9IChmcmFtZS54ICsgZnJhbWUud2lkdGgpIC8gdHc7XHJcbiAgICAgICAgICAgIHRoaXMueTEgPSBmcmFtZS55IC8gdGg7XHJcbiAgICAgICAgICAgIHRoaXMueDIgPSAoZnJhbWUueCArIGZyYW1lLndpZHRoKSAvIHR3O1xyXG4gICAgICAgICAgICB0aGlzLnkyID0gKGZyYW1lLnkgKyBmcmFtZS5oZWlnaHQpIC8gdGg7XHJcbiAgICAgICAgICAgIHRoaXMueDMgPSBmcmFtZS54IC8gdHc7XHJcbiAgICAgICAgICAgIHRoaXMueTMgPSAoZnJhbWUueSArIGZyYW1lLmhlaWdodCkgLyB0aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy51dnNGbG9hdDMyWzBdID0gdGhpcy54MDtcclxuICAgICAgICB0aGlzLnV2c0Zsb2F0MzJbMV0gPSB0aGlzLnkwO1xyXG4gICAgICAgIHRoaXMudXZzRmxvYXQzMlsyXSA9IHRoaXMueDE7XHJcbiAgICAgICAgdGhpcy51dnNGbG9hdDMyWzNdID0gdGhpcy55MTtcclxuICAgICAgICB0aGlzLnV2c0Zsb2F0MzJbNF0gPSB0aGlzLngyO1xyXG4gICAgICAgIHRoaXMudXZzRmxvYXQzMls1XSA9IHRoaXMueTI7XHJcbiAgICAgICAgdGhpcy51dnNGbG9hdDMyWzZdID0gdGhpcy54MztcclxuICAgICAgICB0aGlzLnV2c0Zsb2F0MzJbN10gPSB0aGlzLnkzO1xyXG4gICAgfVxyXG4gICAgO1xyXG59XHJcbmV4cG9ydHMuVGV4dHVyZVV2cyA9IFRleHR1cmVVdnM7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IEV2ZW50RGlzcGF0Y2hlcl8xID0gcmVxdWlyZShcIi4vRXZlbnREaXNwYXRjaGVyXCIpO1xyXG5jb25zdCBUaWNrZXJMaXN0ZW5lcl8xID0gcmVxdWlyZShcIi4vVGlja2VyTGlzdGVuZXJcIik7XHJcbmNvbnN0IHNldHRpbmdzXzEgPSByZXF1aXJlKFwiLi9zZXR0aW5nc1wiKTtcclxuY2xhc3MgVGlja2VyIGV4dGVuZHMgRXZlbnREaXNwYXRjaGVyXzEuRXZlbnREaXNwYXRjaGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGZpcnN0IGxpc3RlbmVyLiBBbGwgbmV3IGxpc3RlbmVycyBhZGRlZCBhcmUgY2hhaW5lZCBvbiB0aGlzLlxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICogQHR5cGUge1RpY2tlckxpc3RlbmVyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuX2hlYWQgPSBuZXcgVGlja2VyTGlzdGVuZXJfMS5UaWNrZXJMaXN0ZW5lcihudWxsLCBudWxsLCBJbmZpbml0eSk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSW50ZXJuYWwgY3VycmVudCBmcmFtZSByZXF1ZXN0IElEXHJcbiAgICAgICAgICogQHR5cGUgez9udW1iZXJ9XHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLl9yZXF1ZXN0SWQgPSBudWxsO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEludGVybmFsIHZhbHVlIG1hbmFnZWQgYnkgbWluRlBTIHByb3BlcnR5IHNldHRlciBhbmQgZ2V0dGVyLlxyXG4gICAgICAgICAqIFRoaXMgaXMgdGhlIG1heGltdW0gYWxsb3dlZCBtaWxsaXNlY29uZHMgYmV0d2VlbiB1cGRhdGVzLlxyXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLl9tYXhFbGFwc2VkTVMgPSAxMDA7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSW50ZXJuYWwgdmFsdWUgbWFuYWdlZCBieSBtYXhGUFMgcHJvcGVydHkgc2V0dGVyIGFuZCBnZXR0ZXIuXHJcbiAgICAgICAgICogVGhpcyBpcyB0aGUgbWluaW11bSBhbGxvd2VkIG1pbGxpc2Vjb25kcyBiZXR3ZWVuIHVwZGF0ZXMuXHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLl9taW5FbGFwc2VkTVMgPSAwO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFdoZXRoZXIgb3Igbm90IHRoaXMgdGlja2VyIHNob3VsZCBpbnZva2UgdGhlIG1ldGhvZFxyXG4gICAgICAgICAqIHtAbGluayBQSVhJLlRpY2tlciNzdGFydH0gYXV0b21hdGljYWxseVxyXG4gICAgICAgICAqIHdoZW4gYSBsaXN0ZW5lciBpcyBhZGRlZC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XHJcbiAgICAgICAgICogQGRlZmF1bHQgZmFsc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmF1dG9TdGFydCA9IGZhbHNlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNjYWxhciB0aW1lIHZhbHVlIGZyb20gbGFzdCBmcmFtZSB0byB0aGlzIGZyYW1lLlxyXG4gICAgICAgICAqIFRoaXMgdmFsdWUgaXMgY2FwcGVkIGJ5IHNldHRpbmcge0BsaW5rIFBJWEkuVGlja2VyI21pbkZQU31cclxuICAgICAgICAgKiBhbmQgaXMgc2NhbGVkIHdpdGgge0BsaW5rIFBJWEkuVGlja2VyI3NwZWVkfS5cclxuICAgICAgICAgKiAqKk5vdGU6KiogVGhlIGNhcCBtYXkgYmUgZXhjZWVkZWQgYnkgc2NhbGluZy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAgICAgKiBAZGVmYXVsdCAxXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5kZWx0YVRpbWUgPSAxO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNjYWxlciB0aW1lIGVsYXBzZWQgaW4gbWlsbGlzZWNvbmRzIGZyb20gbGFzdCBmcmFtZSB0byB0aGlzIGZyYW1lLlxyXG4gICAgICAgICAqIFRoaXMgdmFsdWUgaXMgY2FwcGVkIGJ5IHNldHRpbmcge0BsaW5rIFBJWEkuVGlja2VyI21pbkZQU31cclxuICAgICAgICAgKiBhbmQgaXMgc2NhbGVkIHdpdGgge0BsaW5rIFBJWEkuVGlja2VyI3NwZWVkfS5cclxuICAgICAgICAgKiAqKk5vdGU6KiogVGhlIGNhcCBtYXkgYmUgZXhjZWVkZWQgYnkgc2NhbGluZy5cclxuICAgICAgICAgKiBJZiB0aGUgcGxhdGZvcm0gc3VwcG9ydHMgRE9NSGlnaFJlc1RpbWVTdGFtcCxcclxuICAgICAgICAgKiB0aGlzIHZhbHVlIHdpbGwgaGF2ZSBhIHByZWNpc2lvbiBvZiAxIMK1cy5cclxuICAgICAgICAgKiBEZWZhdWx0cyB0byB0YXJnZXQgZnJhbWUgdGltZVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICAgICAqIEBkZWZhdWx0IDE2LjY2XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5kZWx0YU1TID0gMSAvIHNldHRpbmdzXzEuc2V0dGluZ3MuVEFSR0VUX0ZQTVM7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGltZSBlbGFwc2VkIGluIG1pbGxpc2Vjb25kcyBmcm9tIGxhc3QgZnJhbWUgdG8gdGhpcyBmcmFtZS5cclxuICAgICAgICAgKiBPcHBvc2VkIHRvIHdoYXQgdGhlIHNjYWxhciB7QGxpbmsgUElYSS5UaWNrZXIjZGVsdGFUaW1lfVxyXG4gICAgICAgICAqIGlzIGJhc2VkLCB0aGlzIHZhbHVlIGlzIG5laXRoZXIgY2FwcGVkIG5vciBzY2FsZWQuXHJcbiAgICAgICAgICogSWYgdGhlIHBsYXRmb3JtIHN1cHBvcnRzIERPTUhpZ2hSZXNUaW1lU3RhbXAsXHJcbiAgICAgICAgICogdGhpcyB2YWx1ZSB3aWxsIGhhdmUgYSBwcmVjaXNpb24gb2YgMSDCtXMuXHJcbiAgICAgICAgICogRGVmYXVsdHMgdG8gdGFyZ2V0IGZyYW1lIHRpbWVcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAgICAgKiBAZGVmYXVsdCAxNi42NlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuZWxhcHNlZE1TID0gMSAvIHNldHRpbmdzXzEuc2V0dGluZ3MuVEFSR0VUX0ZQTVM7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGxhc3QgdGltZSB7QGxpbmsgUElYSS5UaWNrZXIjdXBkYXRlfSB3YXMgaW52b2tlZC5cclxuICAgICAgICAgKiBUaGlzIHZhbHVlIGlzIGFsc28gcmVzZXQgaW50ZXJuYWxseSBvdXRzaWRlIG9mIGludm9raW5nXHJcbiAgICAgICAgICogdXBkYXRlLCBidXQgb25seSB3aGVuIGEgbmV3IGFuaW1hdGlvbiBmcmFtZSBpcyByZXF1ZXN0ZWQuXHJcbiAgICAgICAgICogSWYgdGhlIHBsYXRmb3JtIHN1cHBvcnRzIERPTUhpZ2hSZXNUaW1lU3RhbXAsXHJcbiAgICAgICAgICogdGhpcyB2YWx1ZSB3aWxsIGhhdmUgYSBwcmVjaXNpb24gb2YgMSDCtXMuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgICAgICogQGRlZmF1bHQgLTFcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmxhc3RUaW1lID0gLTE7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRmFjdG9yIG9mIGN1cnJlbnQge0BsaW5rIFBJWEkuVGlja2VyI2RlbHRhVGltZX0uXHJcbiAgICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAgKiAvLyBTY2FsZXMgdGlja2VyLmRlbHRhVGltZSB0byB3aGF0IHdvdWxkIGJlXHJcbiAgICAgICAgICogLy8gdGhlIGVxdWl2YWxlbnQgb2YgYXBwcm94aW1hdGVseSAxMjAgRlBTXHJcbiAgICAgICAgICogdGlja2VyLnNwZWVkID0gMjtcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAgICAgKiBAZGVmYXVsdCAxXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5zcGVlZCA9IDE7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogV2hldGhlciBvciBub3QgdGhpcyB0aWNrZXIgaGFzIGJlZW4gc3RhcnRlZC5cclxuICAgICAgICAgKiBgdHJ1ZWAgaWYge0BsaW5rIFBJWEkuVGlja2VyI3N0YXJ0fSBoYXMgYmVlbiBjYWxsZWQuXHJcbiAgICAgICAgICogYGZhbHNlYCBpZiB7QGxpbmsgUElYSS5UaWNrZXIjc3RvcH0gaGFzIGJlZW4gY2FsbGVkLlxyXG4gICAgICAgICAqIFdoaWxlIGBmYWxzZWAsIHRoaXMgdmFsdWUgbWF5IGNoYW5nZSB0byBgdHJ1ZWAgaW4gdGhlXHJcbiAgICAgICAgICogZXZlbnQgb2Yge0BsaW5rIFBJWEkuVGlja2VyI2F1dG9TdGFydH0gYmVpbmcgYHRydWVgXHJcbiAgICAgICAgICogYW5kIGEgbGlzdGVuZXIgaXMgYWRkZWQuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAbWVtYmVyIHtib29sZWFufVxyXG4gICAgICAgICAqIEBkZWZhdWx0IGZhbHNlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5zdGFydGVkID0gZmFsc2U7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSWYgZW5hYmxlZCwgZGVsZXRpbmcgaXMgZGlzYWJsZWQuXHJcbiAgICAgICAgICogQG1lbWJlciB7Ym9vbGVhbn1cclxuICAgICAgICAgKiBAZGVmYXVsdCBmYWxzZVxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5fcHJvdGVjdGVkID0gZmFsc2U7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSW50ZXJuYWwgdGljayBtZXRob2QgYm91bmQgdG8gdGlja2VyIGluc3RhbmNlLlxyXG4gICAgICAgICAqIFRoaXMgaXMgYmVjYXVzZSBpbiBlYXJseSAyMDE1LCBGdW5jdGlvbi5iaW5kXHJcbiAgICAgICAgICogaXMgc3RpbGwgNjAlIHNsb3dlciBpbiBoaWdoIHBlcmZvcm1hbmNlIHNjZW5hcmlvcy5cclxuICAgICAgICAgKiBBbHNvIHNlcGFyYXRpbmcgZnJhbWUgcmVxdWVzdHMgZnJvbSB1cGRhdGUgbWV0aG9kXHJcbiAgICAgICAgICogc28gbGlzdGVuZXJzIG1heSBiZSBjYWxsZWQgYXQgYW55IHRpbWUgYW5kIHdpdGhcclxuICAgICAgICAgKiBhbnkgYW5pbWF0aW9uIEFQSSwganVzdCBpbnZva2UgdGlja2VyLnVwZGF0ZSh0aW1lKS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHRpbWUgLSBUaW1lIHNpbmNlIGxhc3QgdGljay5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLl90aWNrID0gZnVuY3Rpb24gKHRpbWUpIHtcclxuICAgICAgICAgICAgdGhpcyQxLl9yZXF1ZXN0SWQgPSBudWxsO1xyXG4gICAgICAgICAgICBpZiAodGhpcyQxLnN0YXJ0ZWQpIHtcclxuICAgICAgICAgICAgICAgIC8vIEludm9rZSBsaXN0ZW5lcnMgbm93XHJcbiAgICAgICAgICAgICAgICB0aGlzJDEudXBkYXRlKHRpbWUpO1xyXG4gICAgICAgICAgICAgICAgLy8gTGlzdGVuZXIgc2lkZSBlZmZlY3RzIG1heSBoYXZlIG1vZGlmaWVkIHRpY2tlciBzdGF0ZS5cclxuICAgICAgICAgICAgICAgIGlmICh0aGlzJDEuc3RhcnRlZCAmJiB0aGlzJDEuX3JlcXVlc3RJZCA9PT0gbnVsbCAmJiB0aGlzJDEuX2hlYWQubmV4dCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMkMS5fcmVxdWVzdElkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMkMS5fdGljayk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBJbnRlcm5hbGx5IGFkZHMgdGhlIGV2ZW50IGhhbmRsZXIgc28gdGhhdCBpdCBjYW4gYmUgc29ydGVkIGJ5IHByaW9yaXR5LlxyXG4gICAgICogUHJpb3JpdHkgYWxsb3dzIGNlcnRhaW4gaGFuZGxlciAodXNlciwgQW5pbWF0ZWRTcHJpdGUsIEludGVyYWN0aW9uKSB0byBiZSBydW5cclxuICAgICAqIGJlZm9yZSB0aGUgcmVuZGVyaW5nLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge1RpY2tlckxpc3RlbmVyfSBsaXN0ZW5lciAtIEN1cnJlbnQgbGlzdGVuZXIgYmVpbmcgYWRkZWQuXHJcbiAgICAgKiBAcmV0dXJucyB7UElYSS5UaWNrZXJ9IFRoaXMgaW5zdGFuY2Ugb2YgYSB0aWNrZXJcclxuICAgICAqL1xyXG4gICAgX2FkZExpc3RlbmVyKGxpc3RlbmVyKSB7XHJcbiAgICAgICAgLy8gRm9yIGF0dGFjaGluZyB0byBoZWFkXHJcbiAgICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzLl9oZWFkLm5leHQ7XHJcbiAgICAgICAgdmFyIHByZXZpb3VzID0gdGhpcy5faGVhZDtcclxuICAgICAgICAvLyBBZGQgdGhlIGZpcnN0IGl0ZW1cclxuICAgICAgICBpZiAoIWN1cnJlbnQpIHtcclxuICAgICAgICAgICAgbGlzdGVuZXIuY29ubmVjdChwcmV2aW91cyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBHbyBmcm9tIGhpZ2hlc3QgdG8gbG93ZXN0IHByaW9yaXR5XHJcbiAgICAgICAgICAgIHdoaWxlIChjdXJyZW50KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobGlzdGVuZXIucHJpb3JpdHkgPiBjdXJyZW50LnByaW9yaXR5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXIuY29ubmVjdChwcmV2aW91cyk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBwcmV2aW91cyA9IGN1cnJlbnQ7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIE5vdCB5ZXQgY29ubmVjdGVkXHJcbiAgICAgICAgICAgIGlmICghbGlzdGVuZXIucHJldmlvdXMpIHtcclxuICAgICAgICAgICAgICAgIGxpc3RlbmVyLmNvbm5lY3QocHJldmlvdXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3N0YXJ0SWZQb3NzaWJsZSgpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUcmlnZ2VycyBhbiB1cGRhdGUuIEFuIHVwZGF0ZSBlbnRhaWxzIHNldHRpbmcgdGhlXHJcbiAgICAgKiBjdXJyZW50IHtAbGluayBQSVhJLlRpY2tlciNlbGFwc2VkTVN9LFxyXG4gICAgICogdGhlIGN1cnJlbnQge0BsaW5rIFBJWEkuVGlja2VyI2RlbHRhVGltZX0sXHJcbiAgICAgKiBpbnZva2luZyBhbGwgbGlzdGVuZXJzIHdpdGggY3VycmVudCBkZWx0YVRpbWUsXHJcbiAgICAgKiBhbmQgdGhlbiBmaW5hbGx5IHNldHRpbmcge0BsaW5rIFBJWEkuVGlja2VyI2xhc3RUaW1lfVxyXG4gICAgICogd2l0aCB0aGUgdmFsdWUgb2YgY3VycmVudFRpbWUgdGhhdCB3YXMgcHJvdmlkZWQuXHJcbiAgICAgKiBUaGlzIG1ldGhvZCB3aWxsIGJlIGNhbGxlZCBhdXRvbWF0aWNhbGx5IGJ5IGFuaW1hdGlvblxyXG4gICAgICogZnJhbWUgY2FsbGJhY2tzIGlmIHRoZSB0aWNrZXIgaW5zdGFuY2UgaGFzIGJlZW4gc3RhcnRlZFxyXG4gICAgICogYW5kIGxpc3RlbmVycyBhcmUgYWRkZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtjdXJyZW50VGltZT1wZXJmb3JtYW5jZS5ub3coKV0gLSB0aGUgY3VycmVudCB0aW1lIG9mIGV4ZWN1dGlvblxyXG4gICAgICovXHJcbiAgICB1cGRhdGUoY3VycmVudFRpbWUpIHtcclxuICAgICAgICBpZiAoY3VycmVudFRpbWUgPT09IHZvaWQgMCkge1xyXG4gICAgICAgICAgICBjdXJyZW50VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgZWxhcHNlZE1TO1xyXG4gICAgICAgIC8vIElmIHRoZSBkaWZmZXJlbmNlIGluIHRpbWUgaXMgemVybyBvciBuZWdhdGl2ZSwgd2UgaWdub3JlIG1vc3Qgb2YgdGhlIHdvcmsgZG9uZSBoZXJlLlxyXG4gICAgICAgIC8vIElmIHRoZXJlIGlzIG5vIHZhbGlkIGRpZmZlcmVuY2UsIHRoZW4gc2hvdWxkIGJlIG5vIHJlYXNvbiB0byBsZXQgYW55b25lIGtub3cgYWJvdXQgaXQuXHJcbiAgICAgICAgLy8gQSB6ZXJvIGRlbHRhLCBpcyBleGFjdGx5IHRoYXQsIG5vdGhpbmcgc2hvdWxkIHVwZGF0ZS5cclxuICAgICAgICAvL1xyXG4gICAgICAgIC8vIFRoZSBkaWZmZXJlbmNlIGluIHRpbWUgY2FuIGJlIG5lZ2F0aXZlLCBhbmQgbm8gdGhpcyBkb2VzIG5vdCBtZWFuIHRpbWUgdHJhdmVsaW5nLlxyXG4gICAgICAgIC8vIFRoaXMgY2FuIGJlIHRoZSByZXN1bHQgb2YgYSByYWNlIGNvbmRpdGlvbiBiZXR3ZWVuIHdoZW4gYW4gYW5pbWF0aW9uIGZyYW1lIGlzIHJlcXVlc3RlZFxyXG4gICAgICAgIC8vIG9uIHRoZSBjdXJyZW50IEphdmFTY3JpcHQgZW5naW5lIGV2ZW50IGxvb3AsIGFuZCB3aGVuIHRoZSB0aWNrZXIncyBzdGFydCBtZXRob2QgaXMgaW52b2tlZFxyXG4gICAgICAgIC8vICh3aGljaCBpbnZva2VzIHRoZSBpbnRlcm5hbCBfcmVxdWVzdElmTmVlZGVkIG1ldGhvZCkuIElmIGEgZnJhbWUgaXMgcmVxdWVzdGVkIGJlZm9yZVxyXG4gICAgICAgIC8vIF9yZXF1ZXN0SWZOZWVkZWQgaXMgaW52b2tlZCwgdGhlbiB0aGUgY2FsbGJhY2sgZm9yIHRoZSBhbmltYXRpb24gZnJhbWUgdGhlIHRpY2tlciByZXF1ZXN0cyxcclxuICAgICAgICAvLyBjYW4gcmVjZWl2ZSBhIHRpbWUgYXJndW1lbnQgdGhhdCBjYW4gYmUgbGVzcyB0aGFuIHRoZSBsYXN0VGltZSB2YWx1ZSB0aGF0IHdhcyBzZXQgd2l0aGluXHJcbiAgICAgICAgLy8gX3JlcXVlc3RJZk5lZWRlZC4gVGhpcyBkaWZmZXJlbmNlIGlzIGluIG1pY3Jvc2Vjb25kcywgYnV0IHRoaXMgaXMgZW5vdWdoIHRvIGNhdXNlIHByb2JsZW1zLlxyXG4gICAgICAgIC8vXHJcbiAgICAgICAgLy8gVGhpcyBjaGVjayBjb3ZlcnMgdGhpcyBicm93c2VyIGVuZ2luZSB0aW1pbmcgaXNzdWUsIGFzIHdlbGwgYXMgaWYgY29uc3VtZXJzIHBhc3MgYW4gaW52YWxpZFxyXG4gICAgICAgIC8vIGN1cnJlbnRUaW1lIHZhbHVlLiBUaGlzIG1heSBoYXBwZW4gaWYgY29uc3VtZXJzIG9wdC1vdXQgb2YgdGhlIGF1dG9TdGFydCwgYW5kIHVwZGF0ZSB0aGVtc2VsdmVzLlxyXG4gICAgICAgIGlmIChjdXJyZW50VGltZSA+IHRoaXMubGFzdFRpbWUpIHtcclxuICAgICAgICAgICAgLy8gU2F2ZSB1bmNhcHBlZCBlbGFwc2VkTVMgZm9yIG1lYXN1cmVtZW50XHJcbiAgICAgICAgICAgIGVsYXBzZWRNUyA9IHRoaXMuZWxhcHNlZE1TID0gY3VycmVudFRpbWUgLSB0aGlzLmxhc3RUaW1lO1xyXG4gICAgICAgICAgICAvLyBjYXAgdGhlIG1pbGxpc2Vjb25kcyBlbGFwc2VkIHVzZWQgZm9yIGRlbHRhVGltZVxyXG4gICAgICAgICAgICBpZiAoZWxhcHNlZE1TID4gdGhpcy5fbWF4RWxhcHNlZE1TKSB7XHJcbiAgICAgICAgICAgICAgICBlbGFwc2VkTVMgPSB0aGlzLl9tYXhFbGFwc2VkTVM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxhcHNlZE1TICo9IHRoaXMuc3BlZWQ7XHJcbiAgICAgICAgICAgIC8vIGlmIG5vdCBlbm91Z2ggdGltZSBoYXMgcGFzc2VkLCBleGl0IHRoZSBmdW5jdGlvbi5cclxuICAgICAgICAgICAgLy8gV2UgZ2l2ZSBhbiBleHRyYSBtcyB0byBlbGFwc2VkTVMgZm9yIHRoaXMgY2hlY2ssIGJlY2F1c2UgdGhlIG5hdHVyZSBvZlxyXG4gICAgICAgICAgICAvLyByZXF1ZXN0IGFuaW1hdGlvbiBmcmFtZSBtZWFucyB0aGF0IG5vdCBhbGwgYnJvd3NlcnMgd2lsbCByZXR1cm4gcHJlY2lzZSB2YWx1ZXMuXHJcbiAgICAgICAgICAgIC8vIEhvd2V2ZXIsIGJlY2F1c2UgckFGIHdvcmtzIGJhc2VkIG9uIHYtc3luYywgaXQncyB3b24ndCBjaGFuZ2UgdGhlIGVmZmVjdGl2ZSBGUFMuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9taW5FbGFwc2VkTVMgJiYgZWxhcHNlZE1TICsgMSA8IHRoaXMuX21pbkVsYXBzZWRNUykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuZGVsdGFNUyA9IGVsYXBzZWRNUztcclxuICAgICAgICAgICAgdGhpcy5kZWx0YVRpbWUgPSB0aGlzLmRlbHRhTVMgKiBzZXR0aW5nc18xLnNldHRpbmdzLlRBUkdFVF9GUE1TO1xyXG4gICAgICAgICAgICAvLyBDYWNoZSBhIGxvY2FsIHJlZmVyZW5jZSwgaW4tY2FzZSB0aWNrZXIgaXMgZGVzdHJveWVkXHJcbiAgICAgICAgICAgIC8vIGR1cmluZyB0aGUgZW1pdCwgd2UgY2FuIHN0aWxsIGNoZWNrIGZvciBoZWFkLm5leHRcclxuICAgICAgICAgICAgdmFyIGhlYWQgPSB0aGlzLl9oZWFkO1xyXG4gICAgICAgICAgICAvLyBJbnZva2UgbGlzdGVuZXJzIGFkZGVkIHRvIGludGVybmFsIGVtaXR0ZXJcclxuICAgICAgICAgICAgdmFyIGxpc3RlbmVyID0gaGVhZC5uZXh0O1xyXG4gICAgICAgICAgICB3aGlsZSAobGlzdGVuZXIpIHtcclxuICAgICAgICAgICAgICAgIGxpc3RlbmVyID0gbGlzdGVuZXIuZW1pdCh0aGlzLmRlbHRhVGltZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFoZWFkLm5leHQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2NhbmNlbElmTmVlZGVkKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGVsdGFUaW1lID0gdGhpcy5kZWx0YU1TID0gdGhpcy5lbGFwc2VkTVMgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmxhc3RUaW1lID0gY3VycmVudFRpbWU7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIERlc3Ryb3kgdGhlIHRpY2tlciBhbmQgZG9uJ3QgdXNlIGFmdGVyIHRoaXMuIENhbGxpbmdcclxuICAgICAqIHRoaXMgbWV0aG9kIHJlbW92ZXMgYWxsIHJlZmVyZW5jZXMgdG8gaW50ZXJuYWwgZXZlbnRzLlxyXG4gICAgICovXHJcbiAgICBkZXN0cm95KCkge1xyXG4gICAgICAgIGlmICghdGhpcy5fcHJvdGVjdGVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3RvcCgpO1xyXG4gICAgICAgICAgICB2YXIgbGlzdGVuZXIgPSB0aGlzLl9oZWFkLm5leHQ7XHJcbiAgICAgICAgICAgIHdoaWxlIChsaXN0ZW5lcikge1xyXG4gICAgICAgICAgICAgICAgbGlzdGVuZXIgPSBsaXN0ZW5lci5kZXN0cm95KHRydWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX2hlYWQuZGVzdHJveSgpO1xyXG4gICAgICAgICAgICB0aGlzLl9oZWFkID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFN0b3BzIHRoZSB0aWNrZXIuIElmIHRoZSB0aWNrZXIgaGFzIHJlcXVlc3RlZFxyXG4gICAgICogYW4gYW5pbWF0aW9uIGZyYW1lIGl0IGlzIGNhbmNlbGVkIGF0IHRoaXMgcG9pbnQuXHJcbiAgICAgKi9cclxuICAgIHN0b3AoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuc3RhcnRlZCkge1xyXG4gICAgICAgICAgICB0aGlzLnN0YXJ0ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5fY2FuY2VsSWZOZWVkZWQoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFN0YXJ0cyB0aGUgdGlja2VyLiBJZiB0aGUgdGlja2VyIGhhcyBsaXN0ZW5lcnNcclxuICAgICAqIGEgbmV3IGFuaW1hdGlvbiBmcmFtZSBpcyByZXF1ZXN0ZWQgYXQgdGhpcyBwb2ludC5cclxuICAgICAqL1xyXG4gICAgc3RhcnQoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLnN0YXJ0ZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5zdGFydGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5fcmVxdWVzdElmTmVlZGVkKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIGFueSBoYW5kbGVycyBtYXRjaGluZyB0aGUgZnVuY3Rpb24gYW5kIGNvbnRleHQgcGFyYW1ldGVycy5cclxuICAgICAqIElmIG5vIGhhbmRsZXJzIGFyZSBsZWZ0IGFmdGVyIHJlbW92aW5nLCB0aGVuIGl0IGNhbmNlbHMgdGhlIGFuaW1hdGlvbiBmcmFtZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAtIFRoZSBsaXN0ZW5lciBmdW5jdGlvbiB0byBiZSByZW1vdmVkXHJcbiAgICAgKiBAcGFyYW0geyp9IFtjb250ZXh0XSAtIFRoZSBsaXN0ZW5lciBjb250ZXh0IHRvIGJlIHJlbW92ZWRcclxuICAgICAqIEByZXR1cm5zIHtQSVhJLlRpY2tlcn0gVGhpcyBpbnN0YW5jZSBvZiBhIHRpY2tlclxyXG4gICAgICovXHJcbiAgICByZW1vdmUoZm4sIGNvbnRleHQpIHtcclxuICAgICAgICB2YXIgbGlzdGVuZXIgPSB0aGlzLl9oZWFkLm5leHQ7XHJcbiAgICAgICAgd2hpbGUgKGxpc3RlbmVyKSB7XHJcbiAgICAgICAgICAgIC8vIFdlIGZvdW5kIGEgbWF0Y2gsIGxldHMgcmVtb3ZlIGl0XHJcbiAgICAgICAgICAgIC8vIG5vIGJyZWFrIHRvIGRlbGV0ZSBhbGwgcG9zc2libGUgbWF0Y2hlc1xyXG4gICAgICAgICAgICAvLyBpbmNhc2UgYSBsaXN0ZW5lciB3YXMgYWRkZWQgMisgdGltZXNcclxuICAgICAgICAgICAgaWYgKGxpc3RlbmVyLm1hdGNoKGZuLCBjb250ZXh0KSkge1xyXG4gICAgICAgICAgICAgICAgbGlzdGVuZXIgPSBsaXN0ZW5lci5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBsaXN0ZW5lciA9IGxpc3RlbmVyLm5leHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCF0aGlzLl9oZWFkLm5leHQpIHtcclxuICAgICAgICAgICAgdGhpcy5fY2FuY2VsSWZOZWVkZWQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIEFkZCBhIGhhbmRsZXIgZm9yIHRoZSB0aWNrIGV2ZW50IHdoaWNoIGlzIG9ubHkgZXhlY3V0ZSBvbmNlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIC0gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uIHRvIGJlIGFkZGVkIGZvciBvbmUgdXBkYXRlXHJcbiAgICAgKiBAcGFyYW0geyp9IFtjb250ZXh0XSAtIFRoZSBsaXN0ZW5lciBjb250ZXh0XHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3ByaW9yaXR5PVBJWEkuVVBEQVRFX1BSSU9SSVRZLk5PUk1BTF0gLSBUaGUgcHJpb3JpdHkgZm9yIGVtaXR0aW5nXHJcbiAgICAgKiBAcmV0dXJucyB7UElYSS5UaWNrZXJ9IFRoaXMgaW5zdGFuY2Ugb2YgYSB0aWNrZXJcclxuICAgICAqL1xyXG4gICAgYWRkT25jZShmbiwgY29udGV4dCwgcHJpb3JpdHkpIHtcclxuICAgICAgICBpZiAocHJpb3JpdHkgPT09IHZvaWQgMCkge1xyXG4gICAgICAgICAgICBwcmlvcml0eSA9IFRpY2tlci5VUERBVEVfUFJJT1JJVFkuTk9STUFMO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5fYWRkTGlzdGVuZXIobmV3IFRpY2tlckxpc3RlbmVyXzEuVGlja2VyTGlzdGVuZXIoZm4sIGNvbnRleHQsIHByaW9yaXR5LCB0cnVlKSk7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFJlZ2lzdGVyIGEgaGFuZGxlciBmb3IgdGljayBldmVudHMuIENhbGxzIGNvbnRpbnVvdXNseSB1bmxlc3NcclxuICAgICAqIGl0IGlzIHJlbW92ZWQgb3IgdGhlIHRpY2tlciBpcyBzdG9wcGVkLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIC0gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uIHRvIGJlIGFkZGVkIGZvciB1cGRhdGVzXHJcbiAgICAgKiBAcGFyYW0geyp9IFtjb250ZXh0XSAtIFRoZSBsaXN0ZW5lciBjb250ZXh0XHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3ByaW9yaXR5PVBJWEkuVVBEQVRFX1BSSU9SSVRZLk5PUk1BTF0gLSBUaGUgcHJpb3JpdHkgZm9yIGVtaXR0aW5nXHJcbiAgICAgKiBAcmV0dXJucyB7UElYSS5UaWNrZXJ9IFRoaXMgaW5zdGFuY2Ugb2YgYSB0aWNrZXJcclxuICAgICAqL1xyXG4gICAgYWRkKGZuLCBjb250ZXh0ID0gbnVsbCwgcHJpb3JpdHkgPSBudWxsKSB7XHJcbiAgICAgICAgaWYgKHByaW9yaXR5ID09PSB2b2lkIDApIHtcclxuICAgICAgICAgICAgcHJpb3JpdHkgPSBUaWNrZXIuVVBEQVRFX1BSSU9SSVRZLk5PUk1BTDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZExpc3RlbmVyKG5ldyBUaWNrZXJMaXN0ZW5lcl8xLlRpY2tlckxpc3RlbmVyKGZuLCBjb250ZXh0LCBwcmlvcml0eSkpO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDb25kaXRpb25hbGx5IHJlcXVlc3RzIGEgbmV3IGFuaW1hdGlvbiBmcmFtZS5cclxuICAgICAqIElmIHRoZSB0aWNrZXIgaGFzIGJlZW4gc3RhcnRlZCBpdCBjaGVja3MgaWYgYSBmcmFtZSBoYXMgbm90IGFscmVhZHlcclxuICAgICAqIGJlZW4gcmVxdWVzdGVkLCBhbmQgaWYgdGhlIGludGVybmFsIGVtaXR0ZXIgaGFzIGxpc3RlbmVycy4gSWYgdGhlc2VcclxuICAgICAqIGNvbmRpdGlvbnMgYXJlIG1ldCwgYSBuZXcgZnJhbWUgaXMgcmVxdWVzdGVkLiBJZiB0aGUgdGlja2VyIGhhcyBub3RcclxuICAgICAqIGJlZW4gc3RhcnRlZCwgYnV0IGF1dG9TdGFydCBpcyBgdHJ1ZWAsIHRoZW4gdGhlIHRpY2tlciBzdGFydHMgbm93LFxyXG4gICAgICogYW5kIGNvbnRpbnVlcyB3aXRoIHRoZSBwcmV2aW91cyBjb25kaXRpb25zIHRvIHJlcXVlc3QgYSBuZXcgZnJhbWUuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgX3N0YXJ0SWZQb3NzaWJsZSgpIHtcclxuICAgICAgICBpZiAodGhpcy5zdGFydGVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3JlcXVlc3RJZk5lZWRlZCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLmF1dG9TdGFydCkge1xyXG4gICAgICAgICAgICB0aGlzLnN0YXJ0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDb25kaXRpb25hbGx5IGNhbmNlbHMgYSBwZW5kaW5nIGFuaW1hdGlvbiBmcmFtZS5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBfY2FuY2VsSWZOZWVkZWQoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3JlcXVlc3RJZCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLl9yZXF1ZXN0SWQpO1xyXG4gICAgICAgICAgICB0aGlzLl9yZXF1ZXN0SWQgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gKiBDb25kaXRpb25hbGx5IHJlcXVlc3RzIGEgbmV3IGFuaW1hdGlvbiBmcmFtZS5cclxuICogSWYgYSBmcmFtZSBoYXMgbm90IGFscmVhZHkgYmVlbiByZXF1ZXN0ZWQsIGFuZCBpZiB0aGUgaW50ZXJuYWxcclxuICogZW1pdHRlciBoYXMgbGlzdGVuZXJzLCBhIG5ldyBmcmFtZSBpcyByZXF1ZXN0ZWQuXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG4gICAgX3JlcXVlc3RJZk5lZWRlZCgpIHtcclxuICAgICAgICBpZiAodGhpcy5fcmVxdWVzdElkID09PSBudWxsICYmIHRoaXMuX2hlYWQubmV4dCkge1xyXG4gICAgICAgICAgICAvLyBlbnN1cmUgY2FsbGJhY2tzIGdldCBjb3JyZWN0IGRlbHRhXHJcbiAgICAgICAgICAgIHRoaXMubGFzdFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcclxuICAgICAgICAgICAgdGhpcy5fcmVxdWVzdElkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuX3RpY2spO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGZyYW1lcyBwZXIgc2Vjb25kIGF0IHdoaWNoIHRoaXMgdGlja2VyIGlzIHJ1bm5pbmcuXHJcbiAgICAgKiBUaGUgZGVmYXVsdCBpcyBhcHByb3hpbWF0ZWx5IDYwIGluIG1vc3QgbW9kZXJuIGJyb3dzZXJzLlxyXG4gICAgICogKipOb3RlOioqIFRoaXMgZG9lcyBub3QgZmFjdG9yIGluIHRoZSB2YWx1ZSBvZlxyXG4gICAgICoge0BsaW5rIFBJWEkuVGlja2VyI3NwZWVkfSwgd2hpY2ggaXMgc3BlY2lmaWNcclxuICAgICAqIHRvIHNjYWxpbmcge0BsaW5rIFBJWEkuVGlja2VyI2RlbHRhVGltZX0uXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKi9cclxuICAgIGdldCBGUFMoKSB7XHJcbiAgICAgICAgcmV0dXJuIDEwMDAgLyB0aGlzLmVsYXBzZWRNUztcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogTWFuYWdlcyB0aGUgbWF4aW11bSBhbW91bnQgb2YgbWlsbGlzZWNvbmRzIGFsbG93ZWQgdG9cclxuICAgICAqIGVsYXBzZSBiZXR3ZWVuIGludm9raW5nIHtAbGluayBQSVhJLlRpY2tlciN1cGRhdGV9LlxyXG4gICAgICogVGhpcyB2YWx1ZSBpcyB1c2VkIHRvIGNhcCB7QGxpbmsgUElYSS5UaWNrZXIjZGVsdGFUaW1lfSxcclxuICAgICAqIGJ1dCBkb2VzIG5vdCBlZmZlY3QgdGhlIG1lYXN1cmVkIHZhbHVlIG9mIHtAbGluayBQSVhJLlRpY2tlciNGUFN9LlxyXG4gICAgICogV2hlbiBzZXR0aW5nIHRoaXMgcHJvcGVydHkgaXQgaXMgY2xhbXBlZCB0byBhIHZhbHVlIGJldHdlZW5cclxuICAgICAqIGAwYCBhbmQgYFBJWEkuc2V0dGluZ3MuVEFSR0VUX0ZQTVMgKiAxMDAwYC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgKiBAZGVmYXVsdCAxMFxyXG4gICAgICovXHJcbiAgICBnZXQgbWluRlBTKCkge1xyXG4gICAgICAgIHJldHVybiAxMDAwIC8gdGhpcy5fbWF4RWxhcHNlZE1TO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgc2V0IG1pbkZQUyhmcHMpIHtcclxuICAgICAgICAvLyBNaW5pbXVtIG11c3QgYmUgYmVsb3cgdGhlIG1heEZQU1xyXG4gICAgICAgIHZhciBtaW5GUFMgPSBNYXRoLm1pbih0aGlzLm1heEZQUywgZnBzKTtcclxuICAgICAgICAvLyBNdXN0IGJlIGF0IGxlYXN0IDAsIGJ1dCBiZWxvdyAxIC8gc2V0dGluZ3MuVEFSR0VUX0ZQTVNcclxuICAgICAgICB2YXIgbWluRlBNUyA9IE1hdGgubWluKE1hdGgubWF4KDAsIG1pbkZQUykgLyAxMDAwLCBzZXR0aW5nc18xLnNldHRpbmdzLlRBUkdFVF9GUE1TKTtcclxuICAgICAgICB0aGlzLl9tYXhFbGFwc2VkTVMgPSAxIC8gbWluRlBNUztcclxuICAgIH1cclxuICAgIDtcclxuICAgIHNldCBtYXhGUFMoZnBzKSB7XHJcbiAgICAgICAgaWYgKGZwcyAvIDEwMDAgPj0gc2V0dGluZ3NfMS5zZXR0aW5ncy5UQVJHRVRfRlBNUykge1xyXG4gICAgICAgICAgICB0aGlzLl9taW5FbGFwc2VkTVMgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gTWF4IG11c3QgYmUgYXQgbGVhc3QgdGhlIG1pbkZQU1xyXG4gICAgICAgICAgICB2YXIgbWF4RlBTID0gTWF0aC5tYXgodGhpcy5taW5GUFMsIGZwcyk7XHJcbiAgICAgICAgICAgIC8vIE11c3QgYmUgYXQgbGVhc3QgMSwgYnV0IGJlbG93IDEgLyBzZXR0aW5ncy5UQVJHRVRfRlBNU1xyXG4gICAgICAgICAgICB2YXIgbWF4RlBNUyA9IE1hdGgubWluKE1hdGgubWF4KDEsIG1heEZQUykgLyAxMDAwLCBzZXR0aW5nc18xLnNldHRpbmdzLlRBUkdFVF9GUE1TKTtcclxuICAgICAgICAgICAgdGhpcy5fbWluRWxhcHNlZE1TID0gMSAvIG1heEZQTVM7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAqIFRoZSBzaGFyZWQgdGlja2VyIGluc3RhbmNlIHVzZWQgYnkge0BsaW5rIFBJWEkuQW5pbWF0ZWRTcHJpdGV9IGFuZCBieVxyXG4gKiB7QGxpbmsgUElYSS5WaWRlb1Jlc291cmNlfSB0byB1cGRhdGUgYW5pbWF0aW9uIGZyYW1lcyAvIHZpZGVvIHRleHR1cmVzLlxyXG4gKlxyXG4gKiBJdCBtYXkgYWxzbyBiZSB1c2VkIGJ5IHtAbGluayBQSVhJLkFwcGxpY2F0aW9ufSBpZiBjcmVhdGVkIHdpdGggdGhlIGBzaGFyZWRUaWNrZXJgIG9wdGlvbiBwcm9wZXJ0eSBzZXQgdG8gdHJ1ZS5cclxuICpcclxuICogVGhlIHByb3BlcnR5IHtAbGluayBQSVhJLlRpY2tlciNhdXRvU3RhcnR9IGlzIHNldCB0byBgdHJ1ZWAgZm9yIHRoaXMgaW5zdGFuY2UuXHJcbiAqIFBsZWFzZSBmb2xsb3cgdGhlIGV4YW1wbGVzIGZvciB1c2FnZSwgaW5jbHVkaW5nIGhvdyB0byBvcHQtb3V0IG9mIGF1dG8tc3RhcnRpbmcgdGhlIHNoYXJlZCB0aWNrZXIuXHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIGxldCB0aWNrZXIgPSBQSVhJLlRpY2tlci5zaGFyZWQ7XHJcbiAqIC8vIFNldCB0aGlzIHRvIHByZXZlbnQgc3RhcnRpbmcgdGhpcyB0aWNrZXIgd2hlbiBsaXN0ZW5lcnMgYXJlIGFkZGVkLlxyXG4gKiAvLyBCeSBkZWZhdWx0IHRoaXMgaXMgdHJ1ZSBvbmx5IGZvciB0aGUgUElYSS5UaWNrZXIuc2hhcmVkIGluc3RhbmNlLlxyXG4gKiB0aWNrZXIuYXV0b1N0YXJ0ID0gZmFsc2U7XHJcbiAqIC8vIEZZSSwgY2FsbCB0aGlzIHRvIGVuc3VyZSB0aGUgdGlja2VyIGlzIHN0b3BwZWQuIEl0IHNob3VsZCBiZSBzdG9wcGVkXHJcbiAqIC8vIGlmIHlvdSBoYXZlIG5vdCBhdHRlbXB0ZWQgdG8gcmVuZGVyIGFueXRoaW5nIHlldC5cclxuICogdGlja2VyLnN0b3AoKTtcclxuICogLy8gQ2FsbCB0aGlzIHdoZW4geW91IGFyZSByZWFkeSBmb3IgYSBydW5uaW5nIHNoYXJlZCB0aWNrZXIuXHJcbiAqIHRpY2tlci5zdGFydCgpO1xyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiAvLyBZb3UgbWF5IHVzZSB0aGUgc2hhcmVkIHRpY2tlciB0byByZW5kZXIuLi5cclxuICogbGV0IHJlbmRlcmVyID0gUElYSS5hdXRvRGV0ZWN0UmVuZGVyZXIoKTtcclxuICogbGV0IHN0YWdlID0gbmV3IFBJWEkuQ29udGFpbmVyKCk7XHJcbiAqIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQocmVuZGVyZXIudmlldyk7XHJcbiAqIHRpY2tlci5hZGQoZnVuY3Rpb24gKHRpbWUpIHtcclxuICogcmVuZGVyZXIucmVuZGVyKHN0YWdlKTtcclxuICogfSk7XHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIC8vIE9yIHlvdSBjYW4ganVzdCB1cGRhdGUgaXQgbWFudWFsbHkuXHJcbiAqIHRpY2tlci5hdXRvU3RhcnQgPSBmYWxzZTtcclxuICogdGlja2VyLnN0b3AoKTtcclxuICogZnVuY3Rpb24gYW5pbWF0ZSh0aW1lKSB7XHJcbiAqIHRpY2tlci51cGRhdGUodGltZSk7XHJcbiAqIHJlbmRlcmVyLnJlbmRlcihzdGFnZSk7XHJcbiAqIHJlcXVlc3RBbmltYXRpb25GcmFtZShhbmltYXRlKTtcclxuICogfVxyXG4gKiBhbmltYXRlKHBlcmZvcm1hbmNlLm5vdygpKTtcclxuICpcclxuICogQG1lbWJlciB7UElYSS5UaWNrZXJ9XHJcbiAqIEBzdGF0aWNcclxuICovXHJcbiAgICBzdGF0aWMgZ2V0IHNoYXJlZCgpIHtcclxuICAgICAgICBpZiAoIVRpY2tlci5fc2hhcmVkKSB7XHJcbiAgICAgICAgICAgIHZhciBzaGFyZWQgPSBUaWNrZXIuX3NoYXJlZCA9IG5ldyBUaWNrZXIoKTtcclxuICAgICAgICAgICAgc2hhcmVkLmF1dG9TdGFydCA9IHRydWU7XHJcbiAgICAgICAgICAgIHNoYXJlZC5fcHJvdGVjdGVkID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFRpY2tlci5fc2hhcmVkO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgc3lzdGVtIHRpY2tlciBpbnN0YW5jZSB1c2VkIGJ5IHtAbGluayBQSVhJLmludGVyYWN0aW9uLkludGVyYWN0aW9uTWFuYWdlcn0gYW5kIGJ5XHJcbiAgICAgKiB7QGxpbmsgUElYSS5CYXNlUHJlcGFyZX0gZm9yIGNvcmUgdGltaW5nIGZ1bmN0aW9uYWxpdHkgdGhhdCBzaG91bGRuJ3QgdXN1YWxseSBuZWVkIHRvIGJlIHBhdXNlZCxcclxuICAgICAqIHVubGlrZSB0aGUgYHNoYXJlZGAgdGlja2VyIHdoaWNoIGRyaXZlcyB2aXN1YWwgYW5pbWF0aW9ucyBhbmQgcmVuZGVyaW5nIHdoaWNoIG1heSB3YW50IHRvIGJlIHBhdXNlZC5cclxuICAgICAqXHJcbiAgICAgKiBUaGUgcHJvcGVydHkge0BsaW5rIFBJWEkuVGlja2VyI2F1dG9TdGFydH0gaXMgc2V0IHRvIGB0cnVlYCBmb3IgdGhpcyBpbnN0YW5jZS5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtQSVhJLlRpY2tlcn1cclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGdldCBzeXN0ZW0oKSB7XHJcbiAgICAgICAgaWYgKCFUaWNrZXIuX3N5c3RlbSkge1xyXG4gICAgICAgICAgICB2YXIgc3lzdGVtID0gVGlja2VyLl9zeXN0ZW0gPSBuZXcgVGlja2VyKCk7XHJcbiAgICAgICAgICAgIHN5c3RlbS5hdXRvU3RhcnQgPSB0cnVlO1xyXG4gICAgICAgICAgICBzeXN0ZW0uX3Byb3RlY3RlZCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBUaWNrZXIuX3N5c3RlbTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogTWFuYWdlcyB0aGUgbWluaW11bSBhbW91bnQgb2YgbWlsbGlzZWNvbmRzIGFsbG93ZWQgdG9cclxuICAgICAqIGVsYXBzZSBiZXR3ZWVuIGludm9raW5nIHtAbGluayBQSVhJLlRpY2tlciN1cGRhdGV9LlxyXG4gICAgICogVGhpcyB3aWxsIGVmZmVjdCB0aGUgbWVhc3VyZWQgdmFsdWUgb2Yge0BsaW5rIFBJWEkudGlja2VyLlRpY2tlciNGUFN9LlxyXG4gICAgICogV2hlbiBzZXR0aW5nIHRoaXMgcHJvcGVydHkgaXQgaXMgY2xhbXBlZCB0byBhIHZhbHVlIGJldHdlZW5cclxuICAgICAqIGAxYCBhbmQgYFRBUkdFVF9GUE1TICogMTAwMGAuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICogQGRlZmF1bHQgNjBcclxuICAgICAqL1xyXG4gICAgZ2V0IG1heEZQUygpIHtcclxuICAgICAgICBpZiAodGhpcy5fbWluRWxhcHNlZE1TKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAxMDAwIC8gdGhpcy5fbWluRWxhcHNlZE1TO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc2V0dGluZ3NfMS5zZXR0aW5ncy5UQVJHRVRfRlBNUyAqIDEwMDA7XHJcbiAgICB9XHJcbiAgICA7XHJcbn1cclxuLyoqXHJcbiAqIFJlcHJlc2VudHMgdGhlIHVwZGF0ZSBwcmlvcml0aWVzIHVzZWQgYnkgaW50ZXJuYWwgUElYSSBjbGFzc2VzIHdoZW4gcmVnaXN0ZXJlZCB3aXRoXHJcbiAqIHRoZSB7QGxpbmsgUElYSS5UaWNrZXJ9IG9iamVjdC4gSGlnaGVyIHByaW9yaXR5IGl0ZW1zIGFyZSB1cGRhdGVkIGZpcnN0IGFuZCBsb3dlclxyXG4gKiBwcmlvcml0eSBpdGVtcywgc3VjaCBhcyByZW5kZXIsIHNob3VsZCBnbyBsYXRlci5cclxuICpcclxuICogQHN0YXRpY1xyXG4gKiBAY29uc3RhbnRcclxuICogQG5hbWUgVVBEQVRFX1BSSU9SSVRZXHJcbiAqIEBtZW1iZXJvZiBQSVhJXHJcbiAqIEB0eXBlIHtvYmplY3R9XHJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBJTlRFUkFDVElPTj01MCBIaWdoZXN0IHByaW9yaXR5LCB1c2VkIGZvciB7QGxpbmsgUElYSS5pbnRlcmFjdGlvbi5JbnRlcmFjdGlvbk1hbmFnZXJ9XHJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBISUdIPTI1IEhpZ2ggcHJpb3JpdHkgdXBkYXRpbmcsIHtAbGluayBQSVhJLlZpZGVvQmFzZVRleHR1cmV9IGFuZCB7QGxpbmsgUElYSS5BbmltYXRlZFNwcml0ZX1cclxuICogQHByb3BlcnR5IHtudW1iZXJ9IE5PUk1BTD0wIERlZmF1bHQgcHJpb3JpdHkgZm9yIHRpY2tlciBldmVudHMsIHNlZSB7QGxpbmsgUElYSS5UaWNrZXIjYWRkfS5cclxuICogQHByb3BlcnR5IHtudW1iZXJ9IExPVz0tMjUgTG93IHByaW9yaXR5IHVzZWQgZm9yIHtAbGluayBQSVhJLkFwcGxpY2F0aW9ufSByZW5kZXJpbmcuXHJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBVVElMSVRZPS01MCBMb3dlc3QgcHJpb3JpdHkgdXNlZCBmb3Ige0BsaW5rIFBJWEkucHJlcGFyZS5CYXNlUHJlcGFyZX0gdXRpbGl0eS5cclxuICovXHJcblRpY2tlci5VUERBVEVfUFJJT1JJVFkgPSB7XHJcbiAgICBJTlRFUkFDVElPTjogNTAsXHJcbiAgICBISUdIOiAyNSxcclxuICAgIE5PUk1BTDogMCxcclxuICAgIExPVzogLTI1LFxyXG4gICAgVVRJTElUWTogLTUwLFxyXG59O1xyXG5leHBvcnRzLlRpY2tlciA9IFRpY2tlcjtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY2xhc3MgVGlja2VyTGlzdGVuZXIge1xyXG4gICAgY29uc3RydWN0b3IoZm4sIGNvbnRleHQsIHByaW9yaXR5LCBvbmNlID0gZmFsc2UpIHtcclxuICAgICAgICBpZiAoY29udGV4dCA9PT0gdm9pZCAwKSB7XHJcbiAgICAgICAgICAgIGNvbnRleHQgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocHJpb3JpdHkgPT09IHZvaWQgMCkge1xyXG4gICAgICAgICAgICBwcmlvcml0eSA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvbmNlID09PSB2b2lkIDApIHtcclxuICAgICAgICAgICAgb25jZSA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgaGFuZGxlciBmdW5jdGlvbiB0byBleGVjdXRlLlxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICogQG1lbWJlciB7RnVuY3Rpb259XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5mbiA9IGZuO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBjYWxsaW5nIHRvIGV4ZWN1dGUuXHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKiBAbWVtYmVyIHsqfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGN1cnJlbnQgcHJpb3JpdHkuXHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5wcmlvcml0eSA9IHByaW9yaXR5O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIElmIHRoaXMgc2hvdWxkIG9ubHkgZXhlY3V0ZSBvbmNlLlxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICogQG1lbWJlciB7Ym9vbGVhbn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLm9uY2UgPSBvbmNlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBuZXh0IGl0ZW0gaW4gY2hhaW4uXHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKiBAbWVtYmVyIHtUaWNrZXJMaXN0ZW5lcn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLm5leHQgPSBudWxsO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBwcmV2aW91cyBpdGVtIGluIGNoYWluLlxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICogQG1lbWJlciB7VGlja2VyTGlzdGVuZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5wcmV2aW91cyA9IG51bGw7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogYHRydWVgIGlmIHRoaXMgbGlzdGVuZXIgaGFzIGJlZW4gZGVzdHJveWVkIGFscmVhZHkuXHJcbiAgICAgICAgICogQG1lbWJlciB7Ym9vbGVhbn1cclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuX2Rlc3Ryb3llZCA9IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBFbWl0IGJ5IGNhbGxpbmcgdGhlIGN1cnJlbnQgZnVuY3Rpb24uXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRlbHRhVGltZSAtIHRpbWUgc2luY2UgdGhlIGxhc3QgZW1pdC5cclxuICAgICAqIEByZXR1cm4ge1RpY2tlckxpc3RlbmVyfSBOZXh0IHRpY2tlclxyXG4gICAgICovXHJcbiAgICBlbWl0KGRlbHRhVGltZSkge1xyXG4gICAgICAgIGlmICh0aGlzLmZuKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbnRleHQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZm4uY2FsbCh0aGlzLmNvbnRleHQsIGRlbHRhVGltZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmZuKGRlbHRhVGltZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHJlZGlyZWN0ID0gdGhpcy5uZXh0O1xyXG4gICAgICAgIGlmICh0aGlzLm9uY2UpIHtcclxuICAgICAgICAgICAgdGhpcy5kZXN0cm95KHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBTb2Z0LWRlc3Ryb3lpbmcgc2hvdWxkIHJlbW92ZVxyXG4gICAgICAgIC8vIHRoZSBuZXh0IHJlZmVyZW5jZVxyXG4gICAgICAgIGlmICh0aGlzLl9kZXN0cm95ZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5uZXh0ID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlZGlyZWN0O1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBEZXN0cm95IGFuZCBkb24ndCB1c2UgYWZ0ZXIgdGhpcy5cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtoYXJkID0gZmFsc2VdIGB0cnVlYCB0byByZW1vdmUgdGhlIGBuZXh0YCByZWZlcmVuY2UsIHRoaXNcclxuICAgICAqICAgIGlzIGNvbnNpZGVyZWQgYSBoYXJkIGRlc3Ryb3kuIFNvZnQgZGVzdHJveSBtYWludGFpbnMgdGhlIG5leHQgcmVmZXJlbmNlLlxyXG4gICAgICogQHJldHVybiB7VGlja2VyTGlzdGVuZXJ9IFRoZSBsaXN0ZW5lciB0byByZWRpcmVjdCB3aGlsZSBlbWl0dGluZyBvciByZW1vdmluZy5cclxuICAgICAqL1xyXG4gICAgZGVzdHJveShoYXJkKSB7XHJcbiAgICAgICAgaWYgKGhhcmQgPT09IHZvaWQgMCkge1xyXG4gICAgICAgICAgICBoYXJkID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2Rlc3Ryb3llZCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5mbiA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gbnVsbDtcclxuICAgICAgICAvLyBEaXNjb25uZWN0LCBob29rIHVwIG5leHQgYW5kIHByZXZpb3VzXHJcbiAgICAgICAgaWYgKHRoaXMucHJldmlvdXMpIHtcclxuICAgICAgICAgICAgdGhpcy5wcmV2aW91cy5uZXh0ID0gdGhpcy5uZXh0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5uZXh0KSB7XHJcbiAgICAgICAgICAgIHRoaXMubmV4dC5wcmV2aW91cyA9IHRoaXMucHJldmlvdXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFJlZGlyZWN0IHRvIHRoZSBuZXh0IGl0ZW1cclxuICAgICAgICB2YXIgcmVkaXJlY3QgPSB0aGlzLm5leHQ7XHJcbiAgICAgICAgLy8gUmVtb3ZlIHJlZmVyZW5jZXNcclxuICAgICAgICB0aGlzLm5leHQgPSBoYXJkID8gbnVsbCA6IHJlZGlyZWN0O1xyXG4gICAgICAgIHRoaXMucHJldmlvdXMgPSBudWxsO1xyXG4gICAgICAgIHJldHVybiByZWRpcmVjdDtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQ29ubmVjdCB0byB0aGUgbGlzdC5cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge1RpY2tlckxpc3RlbmVyfSBwcmV2aW91cyAtIElucHV0IG5vZGUsIHByZXZpb3VzIGxpc3RlbmVyXHJcbiAgICAgKi9cclxuICAgIGNvbm5lY3QocHJldmlvdXMpIHtcclxuICAgICAgICB0aGlzLnByZXZpb3VzID0gcHJldmlvdXM7XHJcbiAgICAgICAgaWYgKHByZXZpb3VzLm5leHQpIHtcclxuICAgICAgICAgICAgcHJldmlvdXMubmV4dC5wcmV2aW91cyA9IHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubmV4dCA9IHByZXZpb3VzLm5leHQ7XHJcbiAgICAgICAgcHJldmlvdXMubmV4dCA9IHRoaXM7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFNpbXBsZSBjb21wYXJlIGZ1bmN0aW9uIHRvIGZpZ3VyZSBvdXQgaWYgYSBmdW5jdGlvbiBhbmQgY29udGV4dCBtYXRjaC5cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAtIFRoZSBsaXN0ZW5lciBmdW5jdGlvbiB0byBiZSBhZGRlZCBmb3Igb25lIHVwZGF0ZVxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY29udGV4dCAtIFRoZSBsaXN0ZW5lciBjb250ZXh0XHJcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBgdHJ1ZWAgaWYgdGhlIGxpc3RlbmVyIG1hdGNoIHRoZSBhcmd1bWVudHNcclxuICAgICAqL1xyXG4gICAgbWF0Y2goZm4sIGNvbnRleHQpIHtcclxuICAgICAgICBjb250ZXh0ID0gY29udGV4dCB8fCBudWxsO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmZuID09PSBmbiAmJiB0aGlzLmNvbnRleHQgPT09IGNvbnRleHQ7XHJcbiAgICB9XHJcbiAgICA7XHJcbn1cclxuZXhwb3J0cy5UaWNrZXJMaXN0ZW5lciA9IFRpY2tlckxpc3RlbmVyO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBPYmplY3RSZW5kZXJlcl8xID0gcmVxdWlyZShcIi4vT2JqZWN0UmVuZGVyZXJcIik7XHJcbmNvbnN0IFNoYWRlcl8xID0gcmVxdWlyZShcIi4vU2hhZGVyXCIpO1xyXG5jb25zdCBRdWFkVXZfMSA9IHJlcXVpcmUoXCIuL1F1YWRVdlwiKTtcclxuY29uc3QgTWF0cml4XzEgPSByZXF1aXJlKFwiLi9NYXRyaXhcIik7XHJcbmNvbnN0IFdlYkdMU2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL1dlYkdMU2V0dGluZ3NcIik7XHJcbmNvbnN0IENvbG9yU2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL0NvbG9yU2V0dGluZ3NcIik7XHJcbmNvbnN0IEJsZW5kTW9kZXNTZXR0aW5nc18xID0gcmVxdWlyZShcIi4vQmxlbmRNb2Rlc1NldHRpbmdzXCIpO1xyXG5jbGFzcyBUaWxpbmdTcHJpdGVSZW5kZXJlciBleHRlbmRzIE9iamVjdFJlbmRlcmVyXzEuT2JqZWN0UmVuZGVyZXIge1xyXG4gICAgY29uc3RydWN0b3IocmVuZGVyZXIpIHtcclxuICAgICAgICBzdXBlcihyZW5kZXJlcik7XHJcbiAgICAgICAgdmFyIHVuaWZvcm1zID0geyBnbG9iYWxzOiB0aGlzLnJlbmRlcmVyLmdsb2JhbFVuaWZvcm1zIH07XHJcbiAgICAgICAgdGhpcy5zaGFkZXIgPSBTaGFkZXJfMS5TaGFkZXIuZnJvbShUaWxpbmdTcHJpdGVSZW5kZXJlci52ZXJ0ZXgkMywgVGlsaW5nU3ByaXRlUmVuZGVyZXIuZnJhZ21lbnQkMiwgdW5pZm9ybXMpO1xyXG4gICAgICAgIHRoaXMuc2ltcGxlU2hhZGVyID0gU2hhZGVyXzEuU2hhZGVyLmZyb20oVGlsaW5nU3ByaXRlUmVuZGVyZXIudmVydGV4JDMsIFRpbGluZ1Nwcml0ZVJlbmRlcmVyLmZyYWdtZW50U2ltcGxlLCB1bmlmb3Jtcyk7XHJcbiAgICAgICAgdGhpcy5xdWFkID0gbmV3IFF1YWRVdl8xLlF1YWRVdigpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtQSVhJLlRpbGluZ1Nwcml0ZX0gdHMgdGlsaW5nU3ByaXRlIHRvIGJlIHJlbmRlcmVkXHJcbiAgICAgKi9cclxuICAgIHJlbmRlcih0cykge1xyXG4gICAgICAgIHZhciByZW5kZXJlciA9IHRoaXMucmVuZGVyZXI7XHJcbiAgICAgICAgdmFyIHF1YWQgPSB0aGlzLnF1YWQ7XHJcbiAgICAgICAgdmFyIHZlcnRpY2VzID0gcXVhZC52ZXJ0aWNlcztcclxuICAgICAgICB2ZXJ0aWNlc1swXSA9IHZlcnRpY2VzWzZdID0gKHRzLl93aWR0aCkgKiAtdHMuYW5jaG9yLng7XHJcbiAgICAgICAgdmVydGljZXNbMV0gPSB2ZXJ0aWNlc1szXSA9IHRzLl9oZWlnaHQgKiAtdHMuYW5jaG9yLnk7XHJcbiAgICAgICAgdmVydGljZXNbMl0gPSB2ZXJ0aWNlc1s0XSA9ICh0cy5fd2lkdGgpICogKDEuMCAtIHRzLmFuY2hvci54KTtcclxuICAgICAgICB2ZXJ0aWNlc1s1XSA9IHZlcnRpY2VzWzddID0gdHMuX2hlaWdodCAqICgxLjAgLSB0cy5hbmNob3IueSk7XHJcbiAgICAgICAgaWYgKHRzLnV2UmVzcGVjdEFuY2hvcikge1xyXG4gICAgICAgICAgICB2ZXJ0aWNlcyA9IHF1YWQudXZzO1xyXG4gICAgICAgICAgICB2ZXJ0aWNlc1swXSA9IHZlcnRpY2VzWzZdID0gLXRzLmFuY2hvci54O1xyXG4gICAgICAgICAgICB2ZXJ0aWNlc1sxXSA9IHZlcnRpY2VzWzNdID0gLXRzLmFuY2hvci55O1xyXG4gICAgICAgICAgICB2ZXJ0aWNlc1syXSA9IHZlcnRpY2VzWzRdID0gMS4wIC0gdHMuYW5jaG9yLng7XHJcbiAgICAgICAgICAgIHZlcnRpY2VzWzVdID0gdmVydGljZXNbN10gPSAxLjAgLSB0cy5hbmNob3IueTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcXVhZC5pbnZhbGlkYXRlKCk7XHJcbiAgICAgICAgdmFyIHRleCA9IHRzLl90ZXh0dXJlO1xyXG4gICAgICAgIHZhciBiYXNlVGV4ID0gdGV4LmJhc2VUZXh0dXJlO1xyXG4gICAgICAgIHZhciBsdCA9IHRzLnRpbGVUcmFuc2Zvcm0ubG9jYWxUcmFuc2Zvcm07XHJcbiAgICAgICAgdmFyIHV2ID0gdHMudXZNYXRyaXg7XHJcbiAgICAgICAgdmFyIGlzU2ltcGxlID0gYmFzZVRleC5pc1Bvd2VyT2ZUd29cclxuICAgICAgICAgICAgJiYgdGV4LmZyYW1lLndpZHRoID09PSBiYXNlVGV4LndpZHRoICYmIHRleC5mcmFtZS5oZWlnaHQgPT09IGJhc2VUZXguaGVpZ2h0O1xyXG4gICAgICAgIC8vIGF1dG8sIGZvcmNlIHJlcGVhdCB3cmFwTW9kZSBmb3IgYmlnIHRpbGluZyB0ZXh0dXJlc1xyXG4gICAgICAgIGlmIChpc1NpbXBsZSkge1xyXG4gICAgICAgICAgICBpZiAoIWJhc2VUZXguX2dsVGV4dHVyZXNbcmVuZGVyZXIuQ09OVEVYVF9VSURdKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYmFzZVRleC53cmFwTW9kZSA9PT0gV2ViR0xTZXR0aW5nc18xLldlYkdMU2V0dGluZ3MuV1JBUF9NT0RFUy5DTEFNUCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJhc2VUZXgud3JhcE1vZGUgPSBXZWJHTFNldHRpbmdzXzEuV2ViR0xTZXR0aW5ncy5XUkFQX01PREVTLlJFUEVBVDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlzU2ltcGxlID0gYmFzZVRleC53cmFwTW9kZSAhPT0gV2ViR0xTZXR0aW5nc18xLldlYkdMU2V0dGluZ3MuV1JBUF9NT0RFUy5DTEFNUDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgc2hhZGVyID0gaXNTaW1wbGUgPyB0aGlzLnNpbXBsZVNoYWRlciA6IHRoaXMuc2hhZGVyO1xyXG4gICAgICAgIHZhciB3ID0gdGV4LndpZHRoO1xyXG4gICAgICAgIHZhciBoID0gdGV4LmhlaWdodDtcclxuICAgICAgICB2YXIgVyA9IHRzLl93aWR0aDtcclxuICAgICAgICB2YXIgSCA9IHRzLl9oZWlnaHQ7XHJcbiAgICAgICAgVGlsaW5nU3ByaXRlUmVuZGVyZXIudGVtcE1hdCQxLnNldChsdC5hICogdyAvIFcsIGx0LmIgKiB3IC8gSCwgbHQuYyAqIGggLyBXLCBsdC5kICogaCAvIEgsIGx0LnR4IC8gVywgbHQudHkgLyBIKTtcclxuICAgICAgICAvLyB0aGF0IHBhcnQgaXMgdGhlIHNhbWUgYXMgYWJvdmU6XHJcbiAgICAgICAgLy8gdGVtcE1hdC5pZGVudGl0eSgpO1xyXG4gICAgICAgIC8vIHRlbXBNYXQuc2NhbGUodGV4LndpZHRoLCB0ZXguaGVpZ2h0KTtcclxuICAgICAgICAvLyB0ZW1wTWF0LnByZXBlbmQobHQpO1xyXG4gICAgICAgIC8vIHRlbXBNYXQuc2NhbGUoMS4wIC8gdHMuX3dpZHRoLCAxLjAgLyB0cy5faGVpZ2h0KTtcclxuICAgICAgICBUaWxpbmdTcHJpdGVSZW5kZXJlci50ZW1wTWF0JDEuaW52ZXJ0KCk7XHJcbiAgICAgICAgaWYgKGlzU2ltcGxlKSB7XHJcbiAgICAgICAgICAgIFRpbGluZ1Nwcml0ZVJlbmRlcmVyLnRlbXBNYXQkMS5wcmVwZW5kKHV2Lm1hcENvb3JkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHNoYWRlci51bmlmb3Jtcy51TWFwQ29vcmQgPSB1di5tYXBDb29yZC50b0FycmF5KHRydWUpO1xyXG4gICAgICAgICAgICBzaGFkZXIudW5pZm9ybXMudUNsYW1wRnJhbWUgPSB1di51Q2xhbXBGcmFtZTtcclxuICAgICAgICAgICAgc2hhZGVyLnVuaWZvcm1zLnVDbGFtcE9mZnNldCA9IHV2LnVDbGFtcE9mZnNldDtcclxuICAgICAgICB9XHJcbiAgICAgICAgc2hhZGVyLnVuaWZvcm1zLnVUcmFuc2Zvcm0gPSBUaWxpbmdTcHJpdGVSZW5kZXJlci50ZW1wTWF0JDEudG9BcnJheSh0cnVlKTtcclxuICAgICAgICBzaGFkZXIudW5pZm9ybXMudUNvbG9yID0gQ29sb3JTZXR0aW5nc18xLkNvbG9yU2V0dGluZ3MucHJlbXVsdGlwbHlUaW50VG9SZ2JhKHRzLnRpbnQsIHRzLndvcmxkQWxwaGEsIHNoYWRlci51bmlmb3Jtcy51Q29sb3IsIGJhc2VUZXgucHJlbXVsdGlwbHlBbHBoYSk7XHJcbiAgICAgICAgc2hhZGVyLnVuaWZvcm1zLnRyYW5zbGF0aW9uTWF0cml4ID0gdHMudHJhbnNmb3JtLndvcmxkVHJhbnNmb3JtLnRvQXJyYXkodHJ1ZSk7XHJcbiAgICAgICAgc2hhZGVyLnVuaWZvcm1zLnVTYW1wbGVyID0gdGV4O1xyXG4gICAgICAgIHJlbmRlcmVyLnNoYWRlci5iaW5kKHNoYWRlcik7XHJcbiAgICAgICAgcmVuZGVyZXIuZ2VvbWV0cnkuYmluZChxdWFkKTsgLy8gLCByZW5kZXJlci5zaGFkZXIuZ2V0R0xTaGFkZXIoKSk7XHJcbiAgICAgICAgcmVuZGVyZXIuc3RhdGUuc2V0QmxlbmRNb2RlKEJsZW5kTW9kZXNTZXR0aW5nc18xLkJsZW5kTW9kZXNTZXR0aW5ncy5jb3JyZWN0QmxlbmRNb2RlKHRzLmJsZW5kTW9kZSwgYmFzZVRleC5wcmVtdWx0aXBseUFscGhhKSk7XHJcbiAgICAgICAgcmVuZGVyZXIuZ2VvbWV0cnkuZHJhdyh0aGlzLnJlbmRlcmVyLmdsLlRSSUFOR0xFUywgNiwgMCk7XHJcbiAgICB9XHJcbiAgICA7XHJcbn1cclxuVGlsaW5nU3ByaXRlUmVuZGVyZXIuZnJhZ21lbnRTaW1wbGUgPSBcInZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xcclxcblxcclxcbnVuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyO1xcclxcbnVuaWZvcm0gdmVjNCB1Q29sb3I7XFxyXFxuXFxyXFxudm9pZCBtYWluKHZvaWQpXFxyXFxue1xcclxcbiAgICB2ZWM0IHNhbXBsZSA9IHRleHR1cmUyRCh1U2FtcGxlciwgdlRleHR1cmVDb29yZCk7XFxyXFxuICAgIGdsX0ZyYWdDb2xvciA9IHNhbXBsZSAqIHVDb2xvcjtcXHJcXG59XFxyXFxuXCI7XHJcblRpbGluZ1Nwcml0ZVJlbmRlcmVyLmZyYWdtZW50JDIgPSBcInZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xcclxcblxcclxcbnVuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyO1xcclxcbnVuaWZvcm0gdmVjNCB1Q29sb3I7XFxyXFxudW5pZm9ybSBtYXQzIHVNYXBDb29yZDtcXHJcXG51bmlmb3JtIHZlYzQgdUNsYW1wRnJhbWU7XFxyXFxudW5pZm9ybSB2ZWMyIHVDbGFtcE9mZnNldDtcXHJcXG5cXHJcXG52b2lkIG1haW4odm9pZClcXHJcXG57XFxyXFxuICAgIHZlYzIgY29vcmQgPSBtb2QodlRleHR1cmVDb29yZCAtIHVDbGFtcE9mZnNldCwgdmVjMigxLjAsIDEuMCkpICsgdUNsYW1wT2Zmc2V0O1xcclxcbiAgICBjb29yZCA9ICh1TWFwQ29vcmQgKiB2ZWMzKGNvb3JkLCAxLjApKS54eTtcXHJcXG4gICAgY29vcmQgPSBjbGFtcChjb29yZCwgdUNsYW1wRnJhbWUueHksIHVDbGFtcEZyYW1lLnp3KTtcXHJcXG5cXHJcXG4gICAgdmVjNCBzYW1wbGUgPSB0ZXh0dXJlMkQodVNhbXBsZXIsIGNvb3JkKTtcXHJcXG4gICAgZ2xfRnJhZ0NvbG9yID0gc2FtcGxlICogdUNvbG9yO1xcclxcbn1cXHJcXG5cIjtcclxuVGlsaW5nU3ByaXRlUmVuZGVyZXIudmVydGV4JDMgPSBcImF0dHJpYnV0ZSB2ZWMyIGFWZXJ0ZXhQb3NpdGlvbjtcXHJcXG5hdHRyaWJ1dGUgdmVjMiBhVGV4dHVyZUNvb3JkO1xcclxcblxcclxcbnVuaWZvcm0gbWF0MyBwcm9qZWN0aW9uTWF0cml4O1xcclxcbnVuaWZvcm0gbWF0MyB0cmFuc2xhdGlvbk1hdHJpeDtcXHJcXG51bmlmb3JtIG1hdDMgdVRyYW5zZm9ybTtcXHJcXG5cXHJcXG52YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXHJcXG5cXHJcXG52b2lkIG1haW4odm9pZClcXHJcXG57XFxyXFxuICAgIGdsX1Bvc2l0aW9uID0gdmVjNCgocHJvamVjdGlvbk1hdHJpeCAqIHRyYW5zbGF0aW9uTWF0cml4ICogdmVjMyhhVmVydGV4UG9zaXRpb24sIDEuMCkpLnh5LCAwLjAsIDEuMCk7XFxyXFxuXFxyXFxuICAgIHZUZXh0dXJlQ29vcmQgPSAodVRyYW5zZm9ybSAqIHZlYzMoYVRleHR1cmVDb29yZCwgMS4wKSkueHk7XFxyXFxufVxcclxcblwiO1xyXG5UaWxpbmdTcHJpdGVSZW5kZXJlci50ZW1wTWF0JDEgPSBuZXcgTWF0cml4XzEuTWF0cml4KCk7XHJcbmV4cG9ydHMuVGlsaW5nU3ByaXRlUmVuZGVyZXIgPSBUaWxpbmdTcHJpdGVSZW5kZXJlcjtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgTWF0cml4XzEgPSByZXF1aXJlKFwiLi9NYXRyaXhcIik7XHJcbmNvbnN0IE9ic2VydmFibGVQb2ludF8xID0gcmVxdWlyZShcIi4vT2JzZXJ2YWJsZVBvaW50XCIpO1xyXG5jbGFzcyBUcmFuc2Zvcm0ge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBUaGUgZ2xvYmFsIG1hdHJpeCB0cmFuc2Zvcm0uIEl0IGNhbiBiZSBzd2FwcGVkIHRlbXBvcmFyaWx5IGJ5IHNvbWUgZnVuY3Rpb25zIGxpa2UgZ2V0TG9jYWxCb3VuZHMoKVxyXG4gICAgICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICAgICAqIEBtZW1iZXIge1BJWEkuTWF0cml4fVxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy53b3JsZFRyYW5zZm9ybSA9IG5ldyBNYXRyaXhfMS5NYXRyaXgoKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgbG9jYWwgbWF0cml4IHRyYW5zZm9ybVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQG1lbWJlciB7UElYSS5NYXRyaXh9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5sb2NhbFRyYW5zZm9ybSA9IG5ldyBNYXRyaXhfMS5NYXRyaXgoKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgY29vcmRpbmF0ZSBvZiB0aGUgb2JqZWN0IHJlbGF0aXZlIHRvIHRoZSBsb2NhbCBjb29yZGluYXRlcyBvZiB0aGUgcGFyZW50LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQG1lbWJlciB7UElYSS5PYnNlcnZhYmxlUG9pbnR9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IG5ldyBPYnNlcnZhYmxlUG9pbnRfMS5PYnNlcnZhYmxlUG9pbnQodGhpcy5vbkNoYW5nZSwgdGhpcywgMCwgMCk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIHNjYWxlIGZhY3RvciBvZiB0aGUgb2JqZWN0LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQG1lbWJlciB7UElYSS5PYnNlcnZhYmxlUG9pbnR9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5zY2FsZSA9IG5ldyBPYnNlcnZhYmxlUG9pbnRfMS5PYnNlcnZhYmxlUG9pbnQodGhpcy5vbkNoYW5nZSwgdGhpcywgMSwgMSk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIHBpdm90IHBvaW50IG9mIHRoZSBkaXNwbGF5T2JqZWN0IHRoYXQgaXQgcm90YXRlcyBhcm91bmQuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLk9ic2VydmFibGVQb2ludH1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnBpdm90ID0gbmV3IE9ic2VydmFibGVQb2ludF8xLk9ic2VydmFibGVQb2ludCh0aGlzLm9uQ2hhbmdlLCB0aGlzLCAwLCAwKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgc2tldyBhbW91bnQsIG9uIHRoZSB4IGFuZCB5IGF4aXMuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLk9ic2VydmFibGVQb2ludH1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnNrZXcgPSBuZXcgT2JzZXJ2YWJsZVBvaW50XzEuT2JzZXJ2YWJsZVBvaW50KHRoaXMudXBkYXRlU2tldywgdGhpcywgMCwgMCk7XHJcbiAgICAgICAgdGhpcy5fcm90YXRpb24gPSAwO1xyXG4gICAgICAgIHRoaXMuX2N4ID0gMTsgLy8gY29zIHJvdGF0aW9uICsgc2tld1k7XHJcbiAgICAgICAgdGhpcy5fc3ggPSAwOyAvLyBzaW4gcm90YXRpb24gKyBza2V3WTtcclxuICAgICAgICB0aGlzLl9jeSA9IDA7IC8vIGNvcyByb3RhdGlvbiArIE1hdGguUEkvMiAtIHNrZXdYO1xyXG4gICAgICAgIHRoaXMuX3N5ID0gMTsgLy8gc2luIHJvdGF0aW9uICsgTWF0aC5QSS8yIC0gc2tld1g7XHJcbiAgICAgICAgdGhpcy5fbG9jYWxJRCA9IDA7XHJcbiAgICAgICAgdGhpcy5fY3VycmVudExvY2FsSUQgPSAwO1xyXG4gICAgICAgIHRoaXMuX3dvcmxkSUQgPSAwO1xyXG4gICAgICAgIHRoaXMuX3BhcmVudElEID0gMDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2FsbGVkIHdoZW4gYSB2YWx1ZSBjaGFuZ2VzLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIG9uQ2hhbmdlKCkge1xyXG4gICAgICAgIHRoaXMuX2xvY2FsSUQrKztcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQ2FsbGVkIHdoZW4gc2tldyBvciByb3RhdGlvbiBjaGFuZ2VzXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgdXBkYXRlU2tldygpIHtcclxuICAgICAgICB0aGlzLl9jeCA9IE1hdGguY29zKHRoaXMuX3JvdGF0aW9uICsgdGhpcy5za2V3Ll95KTtcclxuICAgICAgICB0aGlzLl9zeCA9IE1hdGguc2luKHRoaXMuX3JvdGF0aW9uICsgdGhpcy5za2V3Ll95KTtcclxuICAgICAgICB0aGlzLl9jeSA9IC1NYXRoLnNpbih0aGlzLl9yb3RhdGlvbiAtIHRoaXMuc2tldy5feCk7IC8vIGNvcywgYWRkZWQgUEkvMlxyXG4gICAgICAgIHRoaXMuX3N5ID0gTWF0aC5jb3ModGhpcy5fcm90YXRpb24gLSB0aGlzLnNrZXcuX3gpOyAvLyBzaW4sIGFkZGVkIFBJLzJcclxuICAgICAgICB0aGlzLl9sb2NhbElEKys7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgb25seSBsb2NhbCBtYXRyaXhcclxuICAgICAqL1xyXG4gICAgdXBkYXRlTG9jYWxUcmFuc2Zvcm0oKSB7XHJcbiAgICAgICAgdmFyIGx0ID0gdGhpcy5sb2NhbFRyYW5zZm9ybTtcclxuICAgICAgICBpZiAodGhpcy5fbG9jYWxJRCAhPT0gdGhpcy5fY3VycmVudExvY2FsSUQpIHtcclxuICAgICAgICAgICAgLy8gZ2V0IHRoZSBtYXRyaXggdmFsdWVzIG9mIHRoZSBkaXNwbGF5b2JqZWN0IGJhc2VkIG9uIGl0cyB0cmFuc2Zvcm0gcHJvcGVydGllcy4uXHJcbiAgICAgICAgICAgIGx0LmEgPSB0aGlzLl9jeCAqIHRoaXMuc2NhbGUuX3g7XHJcbiAgICAgICAgICAgIGx0LmIgPSB0aGlzLl9zeCAqIHRoaXMuc2NhbGUuX3g7XHJcbiAgICAgICAgICAgIGx0LmMgPSB0aGlzLl9jeSAqIHRoaXMuc2NhbGUuX3k7XHJcbiAgICAgICAgICAgIGx0LmQgPSB0aGlzLl9zeSAqIHRoaXMuc2NhbGUuX3k7XHJcbiAgICAgICAgICAgIGx0LnR4ID0gdGhpcy5wb3NpdGlvbi5feCAtICgodGhpcy5waXZvdC5feCAqIGx0LmEpICsgKHRoaXMucGl2b3QuX3kgKiBsdC5jKSk7XHJcbiAgICAgICAgICAgIGx0LnR5ID0gdGhpcy5wb3NpdGlvbi5feSAtICgodGhpcy5waXZvdC5feCAqIGx0LmIpICsgKHRoaXMucGl2b3QuX3kgKiBsdC5kKSk7XHJcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRMb2NhbElEID0gdGhpcy5fbG9jYWxJRDtcclxuICAgICAgICAgICAgLy8gZm9yY2UgYW4gdXBkYXRlLi5cclxuICAgICAgICAgICAgdGhpcy5fcGFyZW50SUQgPSAtMTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgdGhlIHZhbHVlcyBvZiB0aGUgb2JqZWN0IGFuZCBhcHBsaWVzIHRoZSBwYXJlbnQncyB0cmFuc2Zvcm0uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtQSVhJLlRyYW5zZm9ybX0gcGFyZW50VHJhbnNmb3JtIC0gVGhlIHRyYW5zZm9ybSBvZiB0aGUgcGFyZW50IG9mIHRoaXMgb2JqZWN0XHJcbiAgICAgKi9cclxuICAgIHVwZGF0ZVRyYW5zZm9ybShwYXJlbnRUcmFuc2Zvcm0pIHtcclxuICAgICAgICB2YXIgbHQgPSB0aGlzLmxvY2FsVHJhbnNmb3JtO1xyXG4gICAgICAgIGlmICh0aGlzLl9sb2NhbElEICE9PSB0aGlzLl9jdXJyZW50TG9jYWxJRCkge1xyXG4gICAgICAgICAgICAvLyBnZXQgdGhlIG1hdHJpeCB2YWx1ZXMgb2YgdGhlIGRpc3BsYXlvYmplY3QgYmFzZWQgb24gaXRzIHRyYW5zZm9ybSBwcm9wZXJ0aWVzLi5cclxuICAgICAgICAgICAgbHQuYSA9IHRoaXMuX2N4ICogdGhpcy5zY2FsZS5feDtcclxuICAgICAgICAgICAgbHQuYiA9IHRoaXMuX3N4ICogdGhpcy5zY2FsZS5feDtcclxuICAgICAgICAgICAgbHQuYyA9IHRoaXMuX2N5ICogdGhpcy5zY2FsZS5feTtcclxuICAgICAgICAgICAgbHQuZCA9IHRoaXMuX3N5ICogdGhpcy5zY2FsZS5feTtcclxuICAgICAgICAgICAgbHQudHggPSB0aGlzLnBvc2l0aW9uLl94IC0gKCh0aGlzLnBpdm90Ll94ICogbHQuYSkgKyAodGhpcy5waXZvdC5feSAqIGx0LmMpKTtcclxuICAgICAgICAgICAgbHQudHkgPSB0aGlzLnBvc2l0aW9uLl95IC0gKCh0aGlzLnBpdm90Ll94ICogbHQuYikgKyAodGhpcy5waXZvdC5feSAqIGx0LmQpKTtcclxuICAgICAgICAgICAgdGhpcy5fY3VycmVudExvY2FsSUQgPSB0aGlzLl9sb2NhbElEO1xyXG4gICAgICAgICAgICAvLyBmb3JjZSBhbiB1cGRhdGUuLlxyXG4gICAgICAgICAgICB0aGlzLl9wYXJlbnRJRCA9IC0xO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5fcGFyZW50SUQgIT09IHBhcmVudFRyYW5zZm9ybS5fd29ybGRJRCkge1xyXG4gICAgICAgICAgICAvLyBjb25jYXQgdGhlIHBhcmVudCBtYXRyaXggd2l0aCB0aGUgb2JqZWN0cyB0cmFuc2Zvcm0uXHJcbiAgICAgICAgICAgIHZhciBwdCA9IHBhcmVudFRyYW5zZm9ybS53b3JsZFRyYW5zZm9ybTtcclxuICAgICAgICAgICAgdmFyIHd0ID0gdGhpcy53b3JsZFRyYW5zZm9ybTtcclxuICAgICAgICAgICAgd3QuYSA9IChsdC5hICogcHQuYSkgKyAobHQuYiAqIHB0LmMpO1xyXG4gICAgICAgICAgICB3dC5iID0gKGx0LmEgKiBwdC5iKSArIChsdC5iICogcHQuZCk7XHJcbiAgICAgICAgICAgIHd0LmMgPSAobHQuYyAqIHB0LmEpICsgKGx0LmQgKiBwdC5jKTtcclxuICAgICAgICAgICAgd3QuZCA9IChsdC5jICogcHQuYikgKyAobHQuZCAqIHB0LmQpO1xyXG4gICAgICAgICAgICB3dC50eCA9IChsdC50eCAqIHB0LmEpICsgKGx0LnR5ICogcHQuYykgKyBwdC50eDtcclxuICAgICAgICAgICAgd3QudHkgPSAobHQudHggKiBwdC5iKSArIChsdC50eSAqIHB0LmQpICsgcHQudHk7XHJcbiAgICAgICAgICAgIHRoaXMuX3BhcmVudElEID0gcGFyZW50VHJhbnNmb3JtLl93b3JsZElEO1xyXG4gICAgICAgICAgICAvLyB1cGRhdGUgdGhlIGlkIG9mIHRoZSB0cmFuc2Zvcm0uLlxyXG4gICAgICAgICAgICB0aGlzLl93b3JsZElEKys7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBEZWNvbXBvc2VzIGEgbWF0cml4IGFuZCBzZXRzIHRoZSB0cmFuc2Zvcm1zIHByb3BlcnRpZXMgYmFzZWQgb24gaXQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtQSVhJLk1hdHJpeH0gbWF0cml4IC0gVGhlIG1hdHJpeCB0byBkZWNvbXBvc2VcclxuICAgICAqL1xyXG4gICAgc2V0RnJvbU1hdHJpeChtYXRyaXgpIHtcclxuICAgICAgICBtYXRyaXguZGVjb21wb3NlKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuX2xvY2FsSUQrKztcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIHJvdGF0aW9uIG9mIHRoZSBvYmplY3QgaW4gcmFkaWFucy5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIGdldCByb3RhdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcm90YXRpb247XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICBzZXQgcm90YXRpb24odmFsdWUpIHtcclxuICAgICAgICBpZiAodGhpcy5fcm90YXRpb24gIT09IHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3JvdGF0aW9uID0gdmFsdWU7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlU2tldygpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIDtcclxufVxyXG5UcmFuc2Zvcm0uSURFTlRJVFkgPSBuZXcgVHJhbnNmb3JtKCk7XHJcbmV4cG9ydHMuVHJhbnNmb3JtID0gVHJhbnNmb3JtO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBJT0Vycm9yRXZlbnRfMSA9IHJlcXVpcmUoXCIuL0lPRXJyb3JFdmVudFwiKTtcclxuY29uc3QgRXZlbnREaXNwYXRjaGVyXzEgPSByZXF1aXJlKFwiLi9FdmVudERpc3BhdGNoZXJcIik7XHJcbmNvbnN0IEV2ZW50XzEgPSByZXF1aXJlKFwiLi9FdmVudFwiKTtcclxuY2xhc3MgVVJMTG9hZGVyIGV4dGVuZHMgRXZlbnREaXNwYXRjaGVyXzEuRXZlbnREaXNwYXRjaGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5vbkh0dHBSZXNwb25zZSA9ICgpID0+IHtcclxuICAgICAgICAgICAgaWYgKHRoaXMueG1saHR0cC5yZWFkeVN0YXRlID09IDQgJiYgdGhpcy54bWxodHRwLnN0YXR1cyA9PSAyMDApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2RhdGEgPSB0aGlzLnhtbGh0dHAucmVzcG9uc2VUZXh0O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KEV2ZW50XzEuRXZlbnQuZ2V0RXZlbnQoRXZlbnRfMS5FdmVudC5DT01QTEVURSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMueG1saHR0cC5yZWFkeVN0YXRlID09IDQgJiYgdGhpcy54bWxodHRwLnN0YXR1cyA9PSAwICYmIHRoaXMueG1saHR0cC5yZXNwb25zZVRleHQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2RhdGEgPSB0aGlzLnhtbGh0dHAucmVzcG9uc2VUZXh0O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KEV2ZW50XzEuRXZlbnQuZ2V0RXZlbnQoRXZlbnRfMS5FdmVudC5DT01QTEVURSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMueG1saHR0cC5yZWFkeVN0YXRlID09IDQgJiYgdGhpcy54bWxodHRwLnN0YXR1cyA9PSA0MDQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBlcnJvcmV2ZW50ID0gbmV3IElPRXJyb3JFdmVudF8xLklPRXJyb3JFdmVudChJT0Vycm9yRXZlbnRfMS5JT0Vycm9yRXZlbnQuSU9fRVJST1IpO1xyXG4gICAgICAgICAgICAgICAgZXJyb3JldmVudC50ZXh0ID0gXCJDb3VsZCBub3QgZmluZCBmaWxlIFwiICsgdGhpcy5yZXF1ZXN0LnVybDtcclxuICAgICAgICAgICAgICAgIGVycm9yZXZlbnQuZXJyb3JJZCA9IDQwNDtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChlcnJvcmV2ZW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLnhtbGh0dHAucmVhZHlTdGF0ZSA9PSA0ICYmIHRoaXMueG1saHR0cC5zdGF0dXMgPT0gNDAzKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZXJyb3JldmVudCA9IG5ldyBJT0Vycm9yRXZlbnRfMS5JT0Vycm9yRXZlbnQoSU9FcnJvckV2ZW50XzEuSU9FcnJvckV2ZW50LklPX0VSUk9SKTtcclxuICAgICAgICAgICAgICAgIGVycm9yZXZlbnQudGV4dCA9IFwiQ3Jvc3MgT3JpZ2luIEVycm9yIFwiICsgdGhpcy5yZXF1ZXN0LnVybDtcclxuICAgICAgICAgICAgICAgIGVycm9yZXZlbnQuZXJyb3JJZCA9IDQwMztcclxuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChlcnJvcmV2ZW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLnhtbGh0dHAucmVhZHlTdGF0ZSA9PSA0ICYmIHRoaXMueG1saHR0cC5zdGF0dXMgIT0gMjAwKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZXJyb3JldmVudCA9IG5ldyBJT0Vycm9yRXZlbnRfMS5JT0Vycm9yRXZlbnQoSU9FcnJvckV2ZW50XzEuSU9FcnJvckV2ZW50LklPX0VSUk9SKTtcclxuICAgICAgICAgICAgICAgIGVycm9yZXZlbnQudGV4dCA9IFwiVW5rb3duIEVycm9yIFwiICsgdGhpcy5yZXF1ZXN0LnVybDtcclxuICAgICAgICAgICAgICAgIGVycm9yZXZlbnQuZXJyb3JJZCA9IHRoaXMueG1saHR0cC5zdGF0dXM7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZXJyb3JldmVudCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMueG1saHR0cCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xyXG4gICAgfVxyXG4gICAgZGVzdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlci5kZXN0cnVjdG9yKCk7XHJcbiAgICAgICAgaWYgKHRoaXMueG1saHR0cCkge1xyXG4gICAgICAgICAgICB0aGlzLnhtbGh0dHAub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy54bWxodHRwID0gbnVsbDtcclxuICAgICAgICBpZiAodGhpcy5yZXF1ZXN0KSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVxdWVzdC5kZXN0cnVjdG9yKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMucmVxdWVzdCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5fZGF0YSA9IG51bGw7XHJcbiAgICB9XHJcbiAgICBnZXQgdXJsKCkge1xyXG4gICAgICAgIGlmICh0aGlzLnJlcXVlc3QpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdC51cmw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgZ2V0IGRhdGEoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGE7XHJcbiAgICB9XHJcbiAgICBzZXQgZGF0YSh2YWx1ZSkge1xyXG4gICAgfVxyXG4gICAgY2xvc2UoKSB7XHJcbiAgICB9XHJcbiAgICBsb2FkKHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5yZXF1ZXN0ID0gdmFsdWU7XHJcbiAgICAgICAgdmFyIHBhdGggPSB0aGlzLnJlcXVlc3QudXJsO1xyXG4gICAgICAgIGlmICghcGF0aCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLnJlcXVlc3QuZGF0YSkge1xyXG4gICAgICAgICAgICB2YXIgcGFyYW1zID0gJyc7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiB0aGlzLnJlcXVlc3QuZGF0YSkge1xyXG4gICAgICAgICAgICAgICAgcGFyYW1zICs9IGtleSArIFwiPVwiICsgdGhpcy5yZXF1ZXN0LmRhdGFba2V5XSArIFwiJlwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHBhcmFtcyA9IHBhcmFtcy5zdWJzdHIoMCwgcGFyYW1zLmxlbmd0aCAtIDEpO1xyXG4gICAgICAgICAgICBwYXRoICs9IFwiP1wiICsgcGFyYW1zO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnhtbGh0dHAub3Blbih0aGlzLnJlcXVlc3QubWV0aG9kLCBwYXRoLCB0cnVlKTtcclxuICAgICAgICB0aGlzLnhtbGh0dHAub25yZWFkeXN0YXRlY2hhbmdlID0gdGhpcy5vbkh0dHBSZXNwb25zZTtcclxuICAgICAgICBpZiAocGF0aC5pbmRleE9mKFwiLmpzb25cIikgPCAwKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnJlcXVlc3QuY29udGVudFR5cGUgIT0gJ2pzb24nKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnhtbGh0dHAuc2V0UmVxdWVzdEhlYWRlcignQ29udGVudC1UeXBlJywgJ3RleHQveG1sJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMucmVxdWVzdC5lbnZlbG9wKSB7XHJcbiAgICAgICAgICAgIHRoaXMueG1saHR0cC5zZW5kKHRoaXMucmVxdWVzdC5lbnZlbG9wKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMueG1saHR0cC5zZW5kKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZ2V0IGRhdGFGb3JtYXQoKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICBzZXQgZGF0YUZvcm1hdCh2YWx1ZSkge1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuVVJMTG9hZGVyID0gVVJMTG9hZGVyO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBVUkxSZXF1ZXN0TWV0aG9kXzEgPSByZXF1aXJlKFwiLi9VUkxSZXF1ZXN0TWV0aG9kXCIpO1xyXG5jb25zdCBGbGFzaEJhc2VPYmplY3RfMSA9IHJlcXVpcmUoXCIuL0ZsYXNoQmFzZU9iamVjdFwiKTtcclxuY2xhc3MgVVJMUmVxdWVzdCBleHRlbmRzIEZsYXNoQmFzZU9iamVjdF8xLkZsYXNoQmFzZU9iamVjdCB7XHJcbiAgICBjb25zdHJ1Y3RvcihwYXRoID0gbnVsbCkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5fcmVxdWVzdE1ldGFEYXRhID0gbmV3IFJlcXVlc3RNZXRhRGF0YSgpO1xyXG4gICAgICAgIHRoaXMuX3RpbWVvdXQgPSAwO1xyXG4gICAgICAgIHRoaXMuX2Nyb3NzT3JpZ2luID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLnJlc2V0KHBhdGgpO1xyXG4gICAgfVxyXG4gICAgZGVzdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLl91cmwgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuX21ldGhvZCA9IFVSTFJlcXVlc3RNZXRob2RfMS5VUkxSZXF1ZXN0TWV0aG9kLlBPU1Q7XHJcbiAgICAgICAgbGV0IGluZGV4ID0gVVJMUmVxdWVzdC5VUkxSZXF1ZXN0Q2FjaGUuaW5kZXhPZih0aGlzKTtcclxuICAgICAgICBpZiAoaW5kZXggPCAwKSB7XHJcbiAgICAgICAgICAgIFVSTFJlcXVlc3QuVVJMUmVxdWVzdENhY2hlLnB1c2godGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmVzZXQocGF0aCA9IG51bGwpIHtcclxuICAgICAgICB0aGlzLl91cmwgPSBwYXRoO1xyXG4gICAgICAgIHRoaXMuX21ldGhvZCA9IFVSTFJlcXVlc3RNZXRob2RfMS5VUkxSZXF1ZXN0TWV0aG9kLlBPU1Q7XHJcbiAgICAgICAgdGhpcy5fY29udGVudFR5cGUgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuX2VudmVsb3AgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuX2RhdGEgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGdldFVSTFJlcXVlc3QocGF0aCA9IG51bGwpIHtcclxuICAgICAgICBpZiAoVVJMUmVxdWVzdC5VUkxSZXF1ZXN0Q2FjaGUubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGxldCB1ciA9IFVSTFJlcXVlc3QuVVJMUmVxdWVzdENhY2hlW1VSTFJlcXVlc3QuVVJMUmVxdWVzdENhY2hlLmxlbmd0aCAtIDFdO1xyXG4gICAgICAgICAgICBVUkxSZXF1ZXN0LlVSTFJlcXVlc3RDYWNoZS5sZW5ndGggLT0gMTtcclxuICAgICAgICAgICAgdXIucmVzZXQocGF0aCk7XHJcbiAgICAgICAgICAgIHJldHVybiB1cjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBVUkxSZXF1ZXN0KHBhdGgpO1xyXG4gICAgfVxyXG4gICAgc2V0IHJlcXVlc3RNZXRhRGF0YSh2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuX3JlcXVlc3RNZXRhRGF0YSA9IHZhbHVlO1xyXG4gICAgfVxyXG4gICAgZ2V0IHJlcXVlc3RNZXRhRGF0YSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdE1ldGFEYXRhO1xyXG4gICAgfVxyXG4gICAgc2V0IHRpbWVvdXQodmFsdWUpIHtcclxuICAgICAgICB0aGlzLl90aW1lb3V0ID0gdmFsdWU7XHJcbiAgICB9XHJcbiAgICBnZXQgdGltZW91dCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fdGltZW91dDtcclxuICAgIH1cclxuICAgIHNldCBjcm9zc09yaWdpbih2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuX2Nyb3NzT3JpZ2luID0gdmFsdWU7XHJcbiAgICB9XHJcbiAgICBnZXQgY3Jvc3NPcmlnaW4oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Nyb3NzT3JpZ2luO1xyXG4gICAgfVxyXG4gICAgc2V0IGVudmVsb3AodmFsdWUpIHtcclxuICAgICAgICB0aGlzLl9lbnZlbG9wID0gdmFsdWU7XHJcbiAgICB9XHJcbiAgICBnZXQgZW52ZWxvcCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZW52ZWxvcDtcclxuICAgIH1cclxuICAgIGdldCByZXF1ZXN0SGVhZGVycygpIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIHNldCByZXF1ZXN0SGVhZGVycyh2YWx1ZSkge1xyXG4gICAgfVxyXG4gICAgZ2V0IGNvbnRlbnRUeXBlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9jb250ZW50VHlwZTtcclxuICAgIH1cclxuICAgIHNldCBjb250ZW50VHlwZSh2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuX2NvbnRlbnRUeXBlID0gdmFsdWU7XHJcbiAgICB9XHJcbiAgICBnZXQgdXJsKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl91cmw7XHJcbiAgICB9XHJcbiAgICBzZXQgdXJsKHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5fdXJsID0gdmFsdWU7XHJcbiAgICB9XHJcbiAgICBzZXQgZGF0YSh2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuX2RhdGEgPSB2YWx1ZTtcclxuICAgIH1cclxuICAgIGdldCBkYXRhKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9kYXRhO1xyXG4gICAgfVxyXG4gICAgZ2V0IG1ldGhvZCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbWV0aG9kO1xyXG4gICAgfVxyXG4gICAgc2V0IG1ldGhvZCh2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuX21ldGhvZCA9IHZhbHVlO1xyXG4gICAgfVxyXG59XHJcblVSTFJlcXVlc3QuVVJMUmVxdWVzdENhY2hlID0gW107XHJcbmV4cG9ydHMuVVJMUmVxdWVzdCA9IFVSTFJlcXVlc3Q7XHJcbmNsYXNzIFJlcXVlc3RNZXRhRGF0YSB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLm1pbWVUeXBlID0gJyc7XHJcbiAgICAgICAgdGhpcy5za2lwU291cmNlID0gZmFsc2U7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5SZXF1ZXN0TWV0YURhdGEgPSBSZXF1ZXN0TWV0YURhdGE7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNsYXNzIFVSTFJlcXVlc3RNZXRob2Qge1xyXG59XHJcblVSTFJlcXVlc3RNZXRob2QuR0VUID0gXCJHRVRcIjtcclxuVVJMUmVxdWVzdE1ldGhvZC5QT1NUID0gXCJQT1NUXCI7XHJcbmV4cG9ydHMuVVJMUmVxdWVzdE1ldGhvZCA9IFVSTFJlcXVlc3RNZXRob2Q7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNsYXNzIFVuaWZvcm1Hcm91cCB7XHJcbiAgICBjb25zdHJ1Y3Rvcih1bmlmb3JtcyA9IG51bGwsIF9zdGF0aWMgPSBudWxsKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiB1bmlmb3JtIHZhbHVlc1xyXG4gICAgICAgICAgICAgICAgICogQG1lbWJlciB7b2JqZWN0fVxyXG4gICAgICAgICAgICAgICAgICogQHJlYWRvbmx5XHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnVuaWZvcm1zID0gdW5pZm9ybXM7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSXRzIGEgZ3JvdXAgYW5kIG5vdCBhIHNpbmdsZSB1bmlmb3Jtc1xyXG4gICAgICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XHJcbiAgICAgICAgICogQHJlYWRvbmx5XHJcbiAgICAgICAgICogQGRlZmF1bHQgdHJ1ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuZ3JvdXAgPSB0cnVlO1xyXG4gICAgICAgIC8vIGxldHMgZ2VuZXJhdGUgdGhpcyB3aGVuIHRoZSBzaGFkZXIgP1xyXG4gICAgICAgIHRoaXMuc3luY1VuaWZvcm1zID0ge307XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogZGlydHkgdmVyc2lvblxyXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5kaXJ0eUlkID0gMDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiB1bmlxdWUgaWRcclxuICAgICAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuaWQgPSBVbmlmb3JtR3JvdXAuVUlEJDIrKztcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBVbmlmb3JtcyB3b250IGJlIGNoYW5nZWQgYWZ0ZXIgY3JlYXRpb25cclxuICAgICAgICAgKiBAbWVtYmVyIHtib29sZWFufVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuc3RhdGljID0gISFfc3RhdGljO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlKCkge1xyXG4gICAgICAgIHRoaXMuZGlydHlJZCsrO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgYWRkKG5hbWUsIHVuaWZvcm1zLCBfc3RhdGljKSB7XHJcbiAgICAgICAgdGhpcy51bmlmb3Jtc1tuYW1lXSA9IG5ldyBVbmlmb3JtR3JvdXAodW5pZm9ybXMsIF9zdGF0aWMpO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgc3RhdGljIGZyb20odW5pZm9ybXMsIF9zdGF0aWMpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFVuaWZvcm1Hcm91cCh1bmlmb3JtcywgX3N0YXRpYyk7XHJcbiAgICB9XHJcbiAgICA7XHJcbn1cclxuVW5pZm9ybUdyb3VwLlVJRCQyID0gMDtcclxuZXhwb3J0cy5Vbmlmb3JtR3JvdXAgPSBVbmlmb3JtR3JvdXA7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IFV0aWxzU2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL1V0aWxzU2V0dGluZ3NcIik7XHJcbmNsYXNzIFVybCB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLnByb3RvY29sID0gbnVsbDtcclxuICAgICAgICB0aGlzLnNsYXNoZXMgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuYXV0aCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5ob3N0ID0gbnVsbDtcclxuICAgICAgICB0aGlzLnBvcnQgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuaG9zdG5hbWUgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuaGFzaCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5zZWFyY2ggPSBudWxsO1xyXG4gICAgICAgIHRoaXMucXVlcnkgPSBudWxsO1xyXG4gICAgICAgIHRoaXMucGF0aG5hbWUgPSBudWxsO1xyXG4gICAgICAgIHRoaXMucGF0aCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5ocmVmID0gbnVsbDtcclxuICAgIH1cclxuICAgIC8vIGZvcm1hdCBhIHBhcnNlZCBvYmplY3QgaW50byBhIHVybCBzdHJpbmdcclxuICAgIHN0YXRpYyB1cmxGb3JtYXQob2JqKSB7XHJcbiAgICAgICAgLy8gZW5zdXJlIGl0J3MgYW4gb2JqZWN0LCBhbmQgbm90IGEgc3RyaW5nIHVybC5cclxuICAgICAgICAvLyBJZiBpdCdzIGFuIG9iaiwgdGhpcyBpcyBhIG5vLW9wLlxyXG4gICAgICAgIC8vIHRoaXMgd2F5LCB5b3UgY2FuIGNhbGwgdXJsX2Zvcm1hdCgpIG9uIHN0cmluZ3NcclxuICAgICAgICAvLyB0byBjbGVhbiB1cCBwb3RlbnRpYWxseSB3b25reSB1cmxzLlxyXG4gICAgICAgIGlmIChVdGlsc1NldHRpbmdzXzEuVXRpbHNTZXR0aW5ncy51dGlsLmlzU3RyaW5nKG9iaikpIHtcclxuICAgICAgICAgICAgb2JqID0gVXJsLnVybFBhcnNlKG9iaik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghKG9iaiBpbnN0YW5jZW9mIFVybCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFVybC5wcm90b3R5cGUuZm9ybWF0LmNhbGwob2JqKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG9iai5mb3JtYXQoKTtcclxuICAgIH1cclxuICAgIHN0YXRpYyB1cmxSZXNvbHZlT2JqZWN0KHNvdXJjZSwgcmVsYXRpdmUpIHtcclxuICAgICAgICBpZiAoIXNvdXJjZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gcmVsYXRpdmU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBVcmwudXJsUGFyc2Uoc291cmNlLCBmYWxzZSwgdHJ1ZSkucmVzb2x2ZU9iamVjdChyZWxhdGl2ZSk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgdXJsUmVzb2x2ZShzb3VyY2UsIHJlbGF0aXZlKSB7XHJcbiAgICAgICAgcmV0dXJuIFVybC51cmxQYXJzZShzb3VyY2UsIGZhbHNlLCB0cnVlKS5yZXNvbHZlKHJlbGF0aXZlKTtcclxuICAgIH1cclxuICAgIHJlc29sdmVPYmplY3QocmVsYXRpdmUpIHtcclxuICAgICAgICBpZiAoVXRpbHNTZXR0aW5nc18xLlV0aWxzU2V0dGluZ3MudXRpbC5pc1N0cmluZyhyZWxhdGl2ZSkpIHtcclxuICAgICAgICAgICAgdmFyIHJlbCA9IG5ldyBVcmwoKTtcclxuICAgICAgICAgICAgcmVsLnBhcnNlKHJlbGF0aXZlLCBmYWxzZSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIHJlbGF0aXZlID0gcmVsO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IFVybCgpO1xyXG4gICAgICAgIHZhciB0a2V5cyA9IE9iamVjdC5rZXlzKHRoaXMpO1xyXG4gICAgICAgIGZvciAodmFyIHRrID0gMDsgdGsgPCB0a2V5cy5sZW5ndGg7IHRrKyspIHtcclxuICAgICAgICAgICAgdmFyIHRrZXkgPSB0a2V5c1t0a107XHJcbiAgICAgICAgICAgIHJlc3VsdFt0a2V5XSA9IHRoaXNbdGtleV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGhhc2ggaXMgYWx3YXlzIG92ZXJyaWRkZW4sIG5vIG1hdHRlciB3aGF0LlxyXG4gICAgICAgIC8vIGV2ZW4gaHJlZj1cIlwiIHdpbGwgcmVtb3ZlIGl0LlxyXG4gICAgICAgIHJlc3VsdC5oYXNoID0gcmVsYXRpdmUuaGFzaDtcclxuICAgICAgICAvLyBpZiB0aGUgcmVsYXRpdmUgdXJsIGlzIGVtcHR5LCB0aGVuIHRoZXJlJ3Mgbm90aGluZyBsZWZ0IHRvIGRvIGhlcmUuXHJcbiAgICAgICAgaWYgKHJlbGF0aXZlLmhyZWYgPT09ICcnKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBocmVmcyBsaWtlIC8vZm9vL2JhciBhbHdheXMgY3V0IHRvIHRoZSBwcm90b2NvbC5cclxuICAgICAgICBpZiAocmVsYXRpdmUuc2xhc2hlcyAmJiAhcmVsYXRpdmUucHJvdG9jb2wpIHtcclxuICAgICAgICAgICAgLy8gdGFrZSBldmVyeXRoaW5nIGV4Y2VwdCB0aGUgcHJvdG9jb2wgZnJvbSByZWxhdGl2ZVxyXG4gICAgICAgICAgICB2YXIgcmtleXMgPSBPYmplY3Qua2V5cyhyZWxhdGl2ZSk7XHJcbiAgICAgICAgICAgIGZvciAodmFyIHJrID0gMDsgcmsgPCBya2V5cy5sZW5ndGg7IHJrKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBya2V5ID0gcmtleXNbcmtdO1xyXG4gICAgICAgICAgICAgICAgaWYgKHJrZXkgIT09ICdwcm90b2NvbCcpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHRbcmtleV0gPSByZWxhdGl2ZVtya2V5XTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvL3VybFBhcnNlIGFwcGVuZHMgdHJhaWxpbmcgLyB0byB1cmxzIGxpa2UgaHR0cDovL3d3dy5leGFtcGxlLmNvbVxyXG4gICAgICAgICAgICBpZiAoVXJsLnNsYXNoZWRQcm90b2NvbFtyZXN1bHQucHJvdG9jb2xdICYmXHJcbiAgICAgICAgICAgICAgICByZXN1bHQuaG9zdG5hbWUgJiYgIXJlc3VsdC5wYXRobmFtZSkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LnBhdGggPSByZXN1bHQucGF0aG5hbWUgPSAnLyc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChyZWxhdGl2ZS5wcm90b2NvbCAmJiByZWxhdGl2ZS5wcm90b2NvbCAhPT0gcmVzdWx0LnByb3RvY29sKSB7XHJcbiAgICAgICAgICAgIC8vIGlmIGl0J3MgYSBrbm93biB1cmwgcHJvdG9jb2wsIHRoZW4gY2hhbmdpbmdcclxuICAgICAgICAgICAgLy8gdGhlIHByb3RvY29sIGRvZXMgd2VpcmQgdGhpbmdzXHJcbiAgICAgICAgICAgIC8vIGZpcnN0LCBpZiBpdCdzIG5vdCBmaWxlOiwgdGhlbiB3ZSBNVVNUIGhhdmUgYSBob3N0LFxyXG4gICAgICAgICAgICAvLyBhbmQgaWYgdGhlcmUgd2FzIGEgcGF0aFxyXG4gICAgICAgICAgICAvLyB0byBiZWdpbiB3aXRoLCB0aGVuIHdlIE1VU1QgaGF2ZSBhIHBhdGguXHJcbiAgICAgICAgICAgIC8vIGlmIGl0IGlzIGZpbGU6LCB0aGVuIHRoZSBob3N0IGlzIGRyb3BwZWQsXHJcbiAgICAgICAgICAgIC8vIGJlY2F1c2UgdGhhdCdzIGtub3duIHRvIGJlIGhvc3RsZXNzLlxyXG4gICAgICAgICAgICAvLyBhbnl0aGluZyBlbHNlIGlzIGFzc3VtZWQgdG8gYmUgYWJzb2x1dGUuXHJcbiAgICAgICAgICAgIGlmICghVXJsLnNsYXNoZWRQcm90b2NvbFtyZWxhdGl2ZS5wcm90b2NvbF0pIHtcclxuICAgICAgICAgICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMocmVsYXRpdmUpO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgdiA9IDA7IHYgPCBrZXlzLmxlbmd0aDsgdisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGsgPSBrZXlzW3ZdO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtrXSA9IHJlbGF0aXZlW2tdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJlc3VsdC5wcm90b2NvbCA9IHJlbGF0aXZlLnByb3RvY29sO1xyXG4gICAgICAgICAgICBpZiAoIXJlbGF0aXZlLmhvc3QgJiYgIVVybC5ob3N0bGVzc1Byb3RvY29sW3JlbGF0aXZlLnByb3RvY29sXSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlbFBhdGggPSAocmVsYXRpdmUucGF0aG5hbWUgfHwgJycpLnNwbGl0KCcvJyk7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAocmVsUGF0aC5sZW5ndGggJiYgIShyZWxhdGl2ZS5ob3N0ID0gcmVsUGF0aC5zaGlmdCgpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICghcmVsYXRpdmUuaG9zdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbGF0aXZlLmhvc3QgPSAnJztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICghcmVsYXRpdmUuaG9zdG5hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZWxhdGl2ZS5ob3N0bmFtZSA9ICcnO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHJlbFBhdGhbMF0gIT09ICcnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVsUGF0aC51bnNoaWZ0KCcnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChyZWxQYXRoLmxlbmd0aCA8IDIpIHtcclxuICAgICAgICAgICAgICAgICAgICByZWxQYXRoLnVuc2hpZnQoJycpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmVzdWx0LnBhdGhuYW1lID0gcmVsUGF0aC5qb2luKCcvJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQucGF0aG5hbWUgPSByZWxhdGl2ZS5wYXRobmFtZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xyXG4gICAgICAgICAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcclxuICAgICAgICAgICAgcmVzdWx0Lmhvc3QgPSByZWxhdGl2ZS5ob3N0IHx8ICcnO1xyXG4gICAgICAgICAgICByZXN1bHQuYXV0aCA9IHJlbGF0aXZlLmF1dGg7XHJcbiAgICAgICAgICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlbGF0aXZlLmhvc3RuYW1lIHx8IHJlbGF0aXZlLmhvc3Q7XHJcbiAgICAgICAgICAgIHJlc3VsdC5wb3J0ID0gcmVsYXRpdmUucG9ydDtcclxuICAgICAgICAgICAgLy8gdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcclxuICAgICAgICAgICAgaWYgKHJlc3VsdC5wYXRobmFtZSB8fCByZXN1bHQuc2VhcmNoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcCA9IHJlc3VsdC5wYXRobmFtZSB8fCAnJztcclxuICAgICAgICAgICAgICAgIHZhciBzID0gcmVzdWx0LnNlYXJjaCB8fCAnJztcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5wYXRoID0gcCArIHM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmVzdWx0LnNsYXNoZXMgPSByZXN1bHQuc2xhc2hlcyB8fCByZWxhdGl2ZS5zbGFzaGVzO1xyXG4gICAgICAgICAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGlzU291cmNlQWJzID0gKHJlc3VsdC5wYXRobmFtZSAmJiByZXN1bHQucGF0aG5hbWUuY2hhckF0KDApID09PSAnLycpLCBpc1JlbEFicyA9IChyZWxhdGl2ZS5ob3N0IHx8XHJcbiAgICAgICAgICAgIHJlbGF0aXZlLnBhdGhuYW1lICYmIHJlbGF0aXZlLnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gJy8nKSwgbXVzdEVuZEFicyA9IChpc1JlbEFicyB8fCBpc1NvdXJjZUFicyB8fFxyXG4gICAgICAgICAgICAocmVzdWx0Lmhvc3QgJiYgcmVsYXRpdmUucGF0aG5hbWUpKSwgcmVtb3ZlQWxsRG90cyA9IG11c3RFbmRBYnMsIHNyY1BhdGggPSByZXN1bHQucGF0aG5hbWUgJiYgcmVzdWx0LnBhdGhuYW1lLnNwbGl0KCcvJykgfHwgW10sIHJlbFBhdGggPSByZWxhdGl2ZS5wYXRobmFtZSAmJiByZWxhdGl2ZS5wYXRobmFtZS5zcGxpdCgnLycpIHx8IFtdLCBwc3ljaG90aWMgPSByZXN1bHQucHJvdG9jb2wgJiYgIVVybC5zbGFzaGVkUHJvdG9jb2xbcmVzdWx0LnByb3RvY29sXTtcclxuICAgICAgICAvLyBpZiB0aGUgdXJsIGlzIGEgbm9uLXNsYXNoZWQgdXJsLCB0aGVuIHJlbGF0aXZlXHJcbiAgICAgICAgLy8gbGlua3MgbGlrZSAuLi8uLiBzaG91bGQgYmUgYWJsZVxyXG4gICAgICAgIC8vIHRvIGNyYXdsIHVwIHRvIHRoZSBob3N0bmFtZSwgYXMgd2VsbC4gIFRoaXMgaXMgc3RyYW5nZS5cclxuICAgICAgICAvLyByZXN1bHQucHJvdG9jb2wgaGFzIGFscmVhZHkgYmVlbiBzZXQgYnkgbm93LlxyXG4gICAgICAgIC8vIExhdGVyIG9uLCBwdXQgdGhlIGZpcnN0IHBhdGggcGFydCBpbnRvIHRoZSBob3N0IGZpZWxkLlxyXG4gICAgICAgIGlmIChwc3ljaG90aWMpIHtcclxuICAgICAgICAgICAgcmVzdWx0Lmhvc3RuYW1lID0gJyc7XHJcbiAgICAgICAgICAgIHJlc3VsdC5wb3J0ID0gbnVsbDtcclxuICAgICAgICAgICAgaWYgKHJlc3VsdC5ob3N0KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoc3JjUGF0aFswXSA9PT0gJycpIHtcclxuICAgICAgICAgICAgICAgICAgICBzcmNQYXRoWzBdID0gcmVzdWx0Lmhvc3Q7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBzcmNQYXRoLnVuc2hpZnQocmVzdWx0Lmhvc3QpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJlc3VsdC5ob3N0ID0gJyc7XHJcbiAgICAgICAgICAgIGlmIChyZWxhdGl2ZS5wcm90b2NvbCkge1xyXG4gICAgICAgICAgICAgICAgcmVsYXRpdmUuaG9zdG5hbWUgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgcmVsYXRpdmUucG9ydCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICBpZiAocmVsYXRpdmUuaG9zdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWxQYXRoWzBdID09PSAnJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZWxQYXRoWzBdID0gcmVsYXRpdmUuaG9zdDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbFBhdGgudW5zaGlmdChyZWxhdGl2ZS5ob3N0KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZWxhdGl2ZS5ob3N0ID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBtdXN0RW5kQWJzID0gbXVzdEVuZEFicyAmJiAocmVsUGF0aFswXSA9PT0gJycgfHwgc3JjUGF0aFswXSA9PT0gJycpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNSZWxBYnMpIHtcclxuICAgICAgICAgICAgLy8gaXQncyBhYnNvbHV0ZS5cclxuICAgICAgICAgICAgcmVzdWx0Lmhvc3QgPSAocmVsYXRpdmUuaG9zdCB8fCByZWxhdGl2ZS5ob3N0ID09PSAnJykgP1xyXG4gICAgICAgICAgICAgICAgcmVsYXRpdmUuaG9zdCA6IHJlc3VsdC5ob3N0O1xyXG4gICAgICAgICAgICByZXN1bHQuaG9zdG5hbWUgPSAocmVsYXRpdmUuaG9zdG5hbWUgfHwgcmVsYXRpdmUuaG9zdG5hbWUgPT09ICcnKSA/XHJcbiAgICAgICAgICAgICAgICByZWxhdGl2ZS5ob3N0bmFtZSA6IHJlc3VsdC5ob3N0bmFtZTtcclxuICAgICAgICAgICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcclxuICAgICAgICAgICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XHJcbiAgICAgICAgICAgIHNyY1BhdGggPSByZWxQYXRoO1xyXG4gICAgICAgICAgICAvLyBmYWxsIHRocm91Z2ggdG8gdGhlIGRvdC1oYW5kbGluZyBiZWxvdy5cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAocmVsUGF0aC5sZW5ndGgpIHtcclxuICAgICAgICAgICAgLy8gaXQncyByZWxhdGl2ZVxyXG4gICAgICAgICAgICAvLyB0aHJvdyBhd2F5IHRoZSBleGlzdGluZyBmaWxlLCBhbmQgdGFrZSB0aGUgbmV3IHBhdGggaW5zdGVhZC5cclxuICAgICAgICAgICAgaWYgKCFzcmNQYXRoKSB7XHJcbiAgICAgICAgICAgICAgICBzcmNQYXRoID0gW107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc3JjUGF0aC5wb3AoKTtcclxuICAgICAgICAgICAgc3JjUGF0aCA9IHNyY1BhdGguY29uY2F0KHJlbFBhdGgpO1xyXG4gICAgICAgICAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xyXG4gICAgICAgICAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoIVV0aWxzU2V0dGluZ3NfMS5VdGlsc1NldHRpbmdzLnV0aWwuaXNOdWxsT3JVbmRlZmluZWQocmVsYXRpdmUuc2VhcmNoKSkge1xyXG4gICAgICAgICAgICAvLyBqdXN0IHB1bGwgb3V0IHRoZSBzZWFyY2guXHJcbiAgICAgICAgICAgIC8vIGxpa2UgaHJlZj0nP2ZvbycuXHJcbiAgICAgICAgICAgIC8vIFB1dCB0aGlzIGFmdGVyIHRoZSBvdGhlciB0d28gY2FzZXMgYmVjYXVzZSBpdCBzaW1wbGlmaWVzIHRoZSBib29sZWFuc1xyXG4gICAgICAgICAgICBpZiAocHN5Y2hvdGljKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQuaG9zdG5hbWUgPSByZXN1bHQuaG9zdCA9IHNyY1BhdGguc2hpZnQoKTtcclxuICAgICAgICAgICAgICAgIC8vb2NjYXRpb25hbHkgdGhlIGF1dGggY2FuIGdldCBzdHVjayBvbmx5IGluIGhvc3RcclxuICAgICAgICAgICAgICAgIC8vdGhpcyBlc3BlY2lhbGx5IGhhcHBlbnMgaW4gY2FzZXMgbGlrZVxyXG4gICAgICAgICAgICAgICAgLy91cmwucmVzb2x2ZU9iamVjdCgnbWFpbHRvOmxvY2FsMUBkb21haW4xJywgJ2xvY2FsMkBkb21haW4yJylcclxuICAgICAgICAgICAgICAgIHZhciBhdXRoSW5Ib3N0ID0gcmVzdWx0Lmhvc3QgJiYgcmVzdWx0Lmhvc3QuaW5kZXhPZignQCcpID4gMCA/XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0Lmhvc3Quc3BsaXQoJ0AnKSA6IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgaWYgKGF1dGhJbkhvc3QpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQuYXV0aCA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQuaG9zdCA9IHJlc3VsdC5ob3N0bmFtZSA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xyXG4gICAgICAgICAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcclxuICAgICAgICAgICAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxyXG4gICAgICAgICAgICBpZiAoIVV0aWxzU2V0dGluZ3NfMS5VdGlsc1NldHRpbmdzLnV0aWwuaXNOdWxsKHJlc3VsdC5wYXRobmFtZSkgfHwgIVV0aWxzU2V0dGluZ3NfMS5VdGlsc1NldHRpbmdzLnV0aWwuaXNOdWxsKHJlc3VsdC5zZWFyY2gpKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQucGF0aCA9IChyZXN1bHQucGF0aG5hbWUgPyByZXN1bHQucGF0aG5hbWUgOiAnJykgK1xyXG4gICAgICAgICAgICAgICAgICAgIChyZXN1bHQuc2VhcmNoID8gcmVzdWx0LnNlYXJjaCA6ICcnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFzcmNQYXRoLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAvLyBubyBwYXRoIGF0IGFsbC4gIGVhc3kuXHJcbiAgICAgICAgICAgIC8vIHdlJ3ZlIGFscmVhZHkgaGFuZGxlZCB0aGUgb3RoZXIgc3R1ZmYgYWJvdmUuXHJcbiAgICAgICAgICAgIHJlc3VsdC5wYXRobmFtZSA9IG51bGw7XHJcbiAgICAgICAgICAgIC8vdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcclxuICAgICAgICAgICAgaWYgKHJlc3VsdC5zZWFyY2gpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5wYXRoID0gJy8nICsgcmVzdWx0LnNlYXJjaDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5wYXRoID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gaWYgYSB1cmwgRU5EcyBpbiAuIG9yIC4uLCB0aGVuIGl0IG11c3QgZ2V0IGEgdHJhaWxpbmcgc2xhc2guXHJcbiAgICAgICAgLy8gaG93ZXZlciwgaWYgaXQgZW5kcyBpbiBhbnl0aGluZyBlbHNlIG5vbi1zbGFzaHksXHJcbiAgICAgICAgLy8gdGhlbiBpdCBtdXN0IE5PVCBnZXQgYSB0cmFpbGluZyBzbGFzaC5cclxuICAgICAgICB2YXIgbGFzdCA9IHNyY1BhdGguc2xpY2UoLTEpWzBdO1xyXG4gICAgICAgIHZhciBoYXNUcmFpbGluZ1NsYXNoID0gKChyZXN1bHQuaG9zdCB8fCByZWxhdGl2ZS5ob3N0IHx8IHNyY1BhdGgubGVuZ3RoID4gMSkgJiZcclxuICAgICAgICAgICAgKGxhc3QgPT09ICcuJyB8fCBsYXN0ID09PSAnLi4nKSB8fCBsYXN0ID09PSAnJyk7XHJcbiAgICAgICAgLy8gc3RyaXAgc2luZ2xlIGRvdHMsIHJlc29sdmUgZG91YmxlIGRvdHMgdG8gcGFyZW50IGRpclxyXG4gICAgICAgIC8vIGlmIHRoZSBwYXRoIHRyaWVzIHRvIGdvIGFib3ZlIHRoZSByb290LCBgdXBgIGVuZHMgdXAgPiAwXHJcbiAgICAgICAgdmFyIHVwID0gMDtcclxuICAgICAgICBmb3IgKHZhciBpID0gc3JjUGF0aC5sZW5ndGg7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgICAgIGxhc3QgPSBzcmNQYXRoW2ldO1xyXG4gICAgICAgICAgICBpZiAobGFzdCA9PT0gJy4nKSB7XHJcbiAgICAgICAgICAgICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChsYXN0ID09PSAnLi4nKSB7XHJcbiAgICAgICAgICAgICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcclxuICAgICAgICAgICAgICAgIHVwKys7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodXApIHtcclxuICAgICAgICAgICAgICAgIHNyY1BhdGguc3BsaWNlKGksIDEpO1xyXG4gICAgICAgICAgICAgICAgdXAtLTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBpZiB0aGUgcGF0aCBpcyBhbGxvd2VkIHRvIGdvIGFib3ZlIHRoZSByb290LCByZXN0b3JlIGxlYWRpbmcgLi5zXHJcbiAgICAgICAgaWYgKCFtdXN0RW5kQWJzICYmICFyZW1vdmVBbGxEb3RzKSB7XHJcbiAgICAgICAgICAgIGZvciAoOyB1cC0tOyB1cCkge1xyXG4gICAgICAgICAgICAgICAgc3JjUGF0aC51bnNoaWZ0KCcuLicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChtdXN0RW5kQWJzICYmIHNyY1BhdGhbMF0gIT09ICcnICYmXHJcbiAgICAgICAgICAgICghc3JjUGF0aFswXSB8fCBzcmNQYXRoWzBdLmNoYXJBdCgwKSAhPT0gJy8nKSkge1xyXG4gICAgICAgICAgICBzcmNQYXRoLnVuc2hpZnQoJycpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaGFzVHJhaWxpbmdTbGFzaCAmJiAoc3JjUGF0aC5qb2luKCcvJykuc3Vic3RyKC0xKSAhPT0gJy8nKSkge1xyXG4gICAgICAgICAgICBzcmNQYXRoLnB1c2goJycpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgaXNBYnNvbHV0ZSA9IHNyY1BhdGhbMF0gPT09ICcnIHx8XHJcbiAgICAgICAgICAgIChzcmNQYXRoWzBdICYmIHNyY1BhdGhbMF0uY2hhckF0KDApID09PSAnLycpO1xyXG4gICAgICAgIC8vIHB1dCB0aGUgaG9zdCBiYWNrXHJcbiAgICAgICAgaWYgKHBzeWNob3RpYykge1xyXG4gICAgICAgICAgICByZXN1bHQuaG9zdG5hbWUgPSByZXN1bHQuaG9zdCA9IGlzQWJzb2x1dGUgPyAnJyA6XHJcbiAgICAgICAgICAgICAgICBzcmNQYXRoLmxlbmd0aCA/IHNyY1BhdGguc2hpZnQoKSA6ICcnO1xyXG4gICAgICAgICAgICAvL29jY2F0aW9uYWx5IHRoZSBhdXRoIGNhbiBnZXQgc3R1Y2sgb25seSBpbiBob3N0XHJcbiAgICAgICAgICAgIC8vdGhpcyBlc3BlY2lhbGx5IGhhcHBlbnMgaW4gY2FzZXMgbGlrZVxyXG4gICAgICAgICAgICAvL3VybC5yZXNvbHZlT2JqZWN0KCdtYWlsdG86bG9jYWwxQGRvbWFpbjEnLCAnbG9jYWwyQGRvbWFpbjInKVxyXG4gICAgICAgICAgICB2YXIgYXV0aEluSG9zdCA9IHJlc3VsdC5ob3N0ICYmIHJlc3VsdC5ob3N0LmluZGV4T2YoJ0AnKSA+IDAgP1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0Lmhvc3Quc3BsaXQoJ0AnKSA6IGZhbHNlO1xyXG4gICAgICAgICAgICBpZiAoYXV0aEluSG9zdCkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LmF1dGggPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQuaG9zdCA9IHJlc3VsdC5ob3N0bmFtZSA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBtdXN0RW5kQWJzID0gbXVzdEVuZEFicyB8fCAocmVzdWx0Lmhvc3QgJiYgc3JjUGF0aC5sZW5ndGgpO1xyXG4gICAgICAgIGlmIChtdXN0RW5kQWJzICYmICFpc0Fic29sdXRlKSB7XHJcbiAgICAgICAgICAgIHNyY1BhdGgudW5zaGlmdCgnJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghc3JjUGF0aC5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmVzdWx0LnBhdGhuYW1lID0gbnVsbDtcclxuICAgICAgICAgICAgcmVzdWx0LnBhdGggPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmVzdWx0LnBhdGhuYW1lID0gc3JjUGF0aC5qb2luKCcvJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vdG8gc3VwcG9ydCByZXF1ZXN0Lmh0dHBcclxuICAgICAgICBpZiAoIVV0aWxzU2V0dGluZ3NfMS5VdGlsc1NldHRpbmdzLnV0aWwuaXNOdWxsKHJlc3VsdC5wYXRobmFtZSkgfHwgIVV0aWxzU2V0dGluZ3NfMS5VdGlsc1NldHRpbmdzLnV0aWwuaXNOdWxsKHJlc3VsdC5zZWFyY2gpKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5wYXRoID0gKHJlc3VsdC5wYXRobmFtZSA/IHJlc3VsdC5wYXRobmFtZSA6ICcnKSArXHJcbiAgICAgICAgICAgICAgICAocmVzdWx0LnNlYXJjaCA/IHJlc3VsdC5zZWFyY2ggOiAnJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlc3VsdC5hdXRoID0gcmVsYXRpdmUuYXV0aCB8fCByZXN1bHQuYXV0aDtcclxuICAgICAgICByZXN1bHQuc2xhc2hlcyA9IHJlc3VsdC5zbGFzaGVzIHx8IHJlbGF0aXZlLnNsYXNoZXM7XHJcbiAgICAgICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIDtcclxuICAgIHN0YXRpYyB1cmxQYXJzZSh1cmwsIHBhcnNlUXVlcnlTdHJpbmcgPSBudWxsLCBzbGFzaGVzRGVub3RlSG9zdCA9IG51bGwpIHtcclxuICAgICAgICBpZiAodXJsICYmIFV0aWxzU2V0dGluZ3NfMS5VdGlsc1NldHRpbmdzLnV0aWwuaXNPYmplY3QodXJsKSAmJiB1cmwgaW5zdGFuY2VvZiBVcmwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHVybDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHUgPSBuZXcgVXJsO1xyXG4gICAgICAgIHUucGFyc2UodXJsLCBwYXJzZVF1ZXJ5U3RyaW5nLCBzbGFzaGVzRGVub3RlSG9zdCk7XHJcbiAgICAgICAgcmV0dXJuIHU7XHJcbiAgICB9XHJcbiAgICByZXNvbHZlKHJlbGF0aXZlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzb2x2ZU9iamVjdChVcmwudXJsUGFyc2UocmVsYXRpdmUsIGZhbHNlLCB0cnVlKSkuZm9ybWF0KCk7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICBwYXJzZUhvc3QoKSB7XHJcbiAgICAgICAgdmFyIGhvc3QgPSB0aGlzLmhvc3Q7XHJcbiAgICAgICAgdmFyIHBvcnQgPSBVcmwucG9ydFBhdHRlcm4uZXhlYyhob3N0KTtcclxuICAgICAgICBpZiAocG9ydCkge1xyXG4gICAgICAgICAgICBwb3J0ID0gcG9ydFswXTtcclxuICAgICAgICAgICAgaWYgKHBvcnQgIT09ICc6Jykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wb3J0ID0gcG9ydC5zdWJzdHIoMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaG9zdCA9IGhvc3Quc3Vic3RyKDAsIGhvc3QubGVuZ3RoIC0gcG9ydC5sZW5ndGgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaG9zdCkge1xyXG4gICAgICAgICAgICB0aGlzLmhvc3RuYW1lID0gaG9zdDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICBwYXJzZSh1cmwsIHBhcnNlUXVlcnlTdHJpbmcgPSBudWxsLCBzbGFzaGVzRGVub3RlSG9zdCA9IG51bGwpIHtcclxuICAgICAgICBpZiAoIVV0aWxzU2V0dGluZ3NfMS5VdGlsc1NldHRpbmdzLnV0aWwuaXNTdHJpbmcodXJsKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUGFyYW1ldGVyICd1cmwnIG11c3QgYmUgYSBzdHJpbmcsIG5vdCBcIiArIHR5cGVvZiB1cmwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBDb3B5IGNocm9tZSwgSUUsIG9wZXJhIGJhY2tzbGFzaC1oYW5kbGluZyBiZWhhdmlvci5cclxuICAgICAgICAvLyBCYWNrIHNsYXNoZXMgYmVmb3JlIHRoZSBxdWVyeSBzdHJpbmcgZ2V0IGNvbnZlcnRlZCB0byBmb3J3YXJkIHNsYXNoZXNcclxuICAgICAgICAvLyBTZWU6IGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0yNTkxNlxyXG4gICAgICAgIHZhciBxdWVyeUluZGV4ID0gdXJsLmluZGV4T2YoJz8nKSwgc3BsaXR0ZXIgPSAocXVlcnlJbmRleCAhPT0gLTEgJiYgcXVlcnlJbmRleCA8IHVybC5pbmRleE9mKCcjJykpID8gJz8nIDogJyMnLCB1U3BsaXQgPSB1cmwuc3BsaXQoc3BsaXR0ZXIpLCBzbGFzaFJlZ2V4ID0gL1xcXFwvZztcclxuICAgICAgICB1U3BsaXRbMF0gPSB1U3BsaXRbMF0ucmVwbGFjZShzbGFzaFJlZ2V4LCAnLycpO1xyXG4gICAgICAgIHVybCA9IHVTcGxpdC5qb2luKHNwbGl0dGVyKTtcclxuICAgICAgICB2YXIgcmVzdCA9IHVybDtcclxuICAgICAgICAvLyB0cmltIGJlZm9yZSBwcm9jZWVkaW5nLlxyXG4gICAgICAgIC8vIFRoaXMgaXMgdG8gc3VwcG9ydCBwYXJzZSBzdHVmZiBsaWtlIFwiICBodHRwOi8vZm9vLmNvbSAgXFxuXCJcclxuICAgICAgICByZXN0ID0gcmVzdC50cmltKCk7XHJcbiAgICAgICAgaWYgKCFzbGFzaGVzRGVub3RlSG9zdCAmJiB1cmwuc3BsaXQoJyMnKS5sZW5ndGggPT09IDEpIHtcclxuICAgICAgICAgICAgLy8gVHJ5IGZhc3QgcGF0aCByZWdleHBcclxuICAgICAgICAgICAgdmFyIHNpbXBsZVBhdGggPSBVcmwuc2ltcGxlUGF0aFBhdHRlcm4uZXhlYyhyZXN0KTtcclxuICAgICAgICAgICAgaWYgKHNpbXBsZVBhdGgpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucGF0aCA9IHJlc3Q7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmhyZWYgPSByZXN0O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wYXRobmFtZSA9IHNpbXBsZVBhdGhbMV07XHJcbiAgICAgICAgICAgICAgICBpZiAoc2ltcGxlUGF0aFsyXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VhcmNoID0gc2ltcGxlUGF0aFsyXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocGFyc2VRdWVyeVN0cmluZykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnF1ZXJ5ID0gdGhpcy5wYXJzZSh0aGlzLnNlYXJjaC5zdWJzdHIoMSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5xdWVyeSA9IHRoaXMuc2VhcmNoLnN1YnN0cigxKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWFyY2ggPSAnJztcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnF1ZXJ5ID0ge307XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcHJvdG8gPSBVcmwucHJvdG9jb2xQYXR0ZXJuLmV4ZWMocmVzdCk7XHJcbiAgICAgICAgaWYgKHByb3RvKSB7XHJcbiAgICAgICAgICAgIHByb3RvID0gcHJvdG9bMF07XHJcbiAgICAgICAgICAgIHZhciBsb3dlclByb3RvID0gcHJvdG8udG9Mb3dlckNhc2UoKTtcclxuICAgICAgICAgICAgdGhpcy5wcm90b2NvbCA9IGxvd2VyUHJvdG87XHJcbiAgICAgICAgICAgIHJlc3QgPSByZXN0LnN1YnN0cihwcm90by5sZW5ndGgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBmaWd1cmUgb3V0IGlmIGl0J3MgZ290IGEgaG9zdFxyXG4gICAgICAgIC8vIHVzZXJAc2VydmVyIGlzICphbHdheXMqIGludGVycHJldGVkIGFzIGEgaG9zdG5hbWUsIGFuZCB1cmxcclxuICAgICAgICAvLyByZXNvbHV0aW9uIHdpbGwgdHJlYXQgLy9mb28vYmFyIGFzIGhvc3Q9Zm9vLHBhdGg9YmFyIGJlY2F1c2UgdGhhdCdzXHJcbiAgICAgICAgLy8gaG93IHRoZSBicm93c2VyIHJlc29sdmVzIHJlbGF0aXZlIFVSTHMuXHJcbiAgICAgICAgaWYgKHNsYXNoZXNEZW5vdGVIb3N0IHx8IHByb3RvIHx8IHJlc3QubWF0Y2goL15cXC9cXC9bXkBcXC9dK0BbXkBcXC9dKy8pKSB7XHJcbiAgICAgICAgICAgIHZhciBzbGFzaGVzID0gcmVzdC5zdWJzdHIoMCwgMikgPT09ICcvLyc7XHJcbiAgICAgICAgICAgIGlmIChzbGFzaGVzICYmICEocHJvdG8gJiYgVXJsLmhvc3RsZXNzUHJvdG9jb2xbcHJvdG9dKSkge1xyXG4gICAgICAgICAgICAgICAgcmVzdCA9IHJlc3Quc3Vic3RyKDIpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zbGFzaGVzID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIVVybC5ob3N0bGVzc1Byb3RvY29sW3Byb3RvXSAmJlxyXG4gICAgICAgICAgICAoc2xhc2hlcyB8fCAocHJvdG8gJiYgIVVybC5zbGFzaGVkUHJvdG9jb2xbcHJvdG9dKSkpIHtcclxuICAgICAgICAgICAgLy8gdGhlcmUncyBhIGhvc3RuYW1lLlxyXG4gICAgICAgICAgICAvLyB0aGUgZmlyc3QgaW5zdGFuY2Ugb2YgLywgPywgOywgb3IgIyBlbmRzIHRoZSBob3N0LlxyXG4gICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBhbiBAIGluIHRoZSBob3N0bmFtZSwgdGhlbiBub24taG9zdCBjaGFycyAqYXJlKiBhbGxvd2VkXHJcbiAgICAgICAgICAgIC8vIHRvIHRoZSBsZWZ0IG9mIHRoZSBsYXN0IEAgc2lnbiwgdW5sZXNzIHNvbWUgaG9zdC1lbmRpbmcgY2hhcmFjdGVyXHJcbiAgICAgICAgICAgIC8vIGNvbWVzICpiZWZvcmUqIHRoZSBALXNpZ24uXHJcbiAgICAgICAgICAgIC8vIFVSTHMgYXJlIG9ibm94aW91cy5cclxuICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgLy8gZXg6XHJcbiAgICAgICAgICAgIC8vIGh0dHA6Ly9hQGJAYy8gPT4gdXNlcjphQGIgaG9zdDpjXHJcbiAgICAgICAgICAgIC8vIGh0dHA6Ly9hQGI/QGMgPT4gdXNlcjphIGhvc3Q6YyBwYXRoOi8/QGNcclxuICAgICAgICAgICAgLy8gdjAuMTIgVE9ETyhpc2FhY3MpOiBUaGlzIGlzIG5vdCBxdWl0ZSBob3cgQ2hyb21lIGRvZXMgdGhpbmdzLlxyXG4gICAgICAgICAgICAvLyBSZXZpZXcgb3VyIHRlc3QgY2FzZSBhZ2FpbnN0IGJyb3dzZXJzIG1vcmUgY29tcHJlaGVuc2l2ZWx5LlxyXG4gICAgICAgICAgICAvLyBmaW5kIHRoZSBmaXJzdCBpbnN0YW5jZSBvZiBhbnkgaG9zdEVuZGluZ0NoYXJzXHJcbiAgICAgICAgICAgIHZhciBob3N0RW5kID0gLTE7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgVXJsLmhvc3RFbmRpbmdDaGFycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGhlYyA9IHJlc3QuaW5kZXhPZihVcmwuaG9zdEVuZGluZ0NoYXJzW2ldKTtcclxuICAgICAgICAgICAgICAgIGlmIChoZWMgIT09IC0xICYmIChob3N0RW5kID09PSAtMSB8fCBoZWMgPCBob3N0RW5kKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGhvc3RFbmQgPSBoZWM7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gYXQgdGhpcyBwb2ludCwgZWl0aGVyIHdlIGhhdmUgYW4gZXhwbGljaXQgcG9pbnQgd2hlcmUgdGhlXHJcbiAgICAgICAgICAgIC8vIGF1dGggcG9ydGlvbiBjYW5ub3QgZ28gcGFzdCwgb3IgdGhlIGxhc3QgQCBjaGFyIGlzIHRoZSBkZWNpZGVyLlxyXG4gICAgICAgICAgICB2YXIgYXV0aCwgYXRTaWduO1xyXG4gICAgICAgICAgICBpZiAoaG9zdEVuZCA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIC8vIGF0U2lnbiBjYW4gYmUgYW55d2hlcmUuXHJcbiAgICAgICAgICAgICAgICBhdFNpZ24gPSByZXN0Lmxhc3RJbmRleE9mKCdAJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBhdFNpZ24gbXVzdCBiZSBpbiBhdXRoIHBvcnRpb24uXHJcbiAgICAgICAgICAgICAgICAvLyBodHRwOi8vYUBiL2NAZCA9PiBob3N0OmIgYXV0aDphIHBhdGg6L2NAZFxyXG4gICAgICAgICAgICAgICAgYXRTaWduID0gcmVzdC5sYXN0SW5kZXhPZignQCcsIGhvc3RFbmQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIE5vdyB3ZSBoYXZlIGEgcG9ydGlvbiB3aGljaCBpcyBkZWZpbml0ZWx5IHRoZSBhdXRoLlxyXG4gICAgICAgICAgICAvLyBQdWxsIHRoYXQgb2ZmLlxyXG4gICAgICAgICAgICBpZiAoYXRTaWduICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgYXV0aCA9IHJlc3Quc2xpY2UoMCwgYXRTaWduKTtcclxuICAgICAgICAgICAgICAgIHJlc3QgPSByZXN0LnNsaWNlKGF0U2lnbiArIDEpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hdXRoID0gZGVjb2RlVVJJQ29tcG9uZW50KGF1dGgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHRoZSBob3N0IGlzIHRoZSByZW1haW5pbmcgdG8gdGhlIGxlZnQgb2YgdGhlIGZpcnN0IG5vbi1ob3N0IGNoYXJcclxuICAgICAgICAgICAgaG9zdEVuZCA9IC0xO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IFVybC5ub25Ib3N0Q2hhcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBoZWMgPSByZXN0LmluZGV4T2YoVXJsLm5vbkhvc3RDaGFyc1tpXSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaGVjICE9PSAtMSAmJiAoaG9zdEVuZCA9PT0gLTEgfHwgaGVjIDwgaG9zdEVuZCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBob3N0RW5kID0gaGVjO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGlmIHdlIHN0aWxsIGhhdmUgbm90IGhpdCBpdCwgdGhlbiB0aGUgZW50aXJlIHRoaW5nIGlzIGEgaG9zdC5cclxuICAgICAgICAgICAgaWYgKGhvc3RFbmQgPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICBob3N0RW5kID0gcmVzdC5sZW5ndGg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5ob3N0ID0gcmVzdC5zbGljZSgwLCBob3N0RW5kKTtcclxuICAgICAgICAgICAgcmVzdCA9IHJlc3Quc2xpY2UoaG9zdEVuZCk7XHJcbiAgICAgICAgICAgIC8vIHB1bGwgb3V0IHBvcnQuXHJcbiAgICAgICAgICAgIHRoaXMucGFyc2VIb3N0KCk7XHJcbiAgICAgICAgICAgIC8vIHdlJ3ZlIGluZGljYXRlZCB0aGF0IHRoZXJlIGlzIGEgaG9zdG5hbWUsXHJcbiAgICAgICAgICAgIC8vIHNvIGV2ZW4gaWYgaXQncyBlbXB0eSwgaXQgaGFzIHRvIGJlIHByZXNlbnQuXHJcbiAgICAgICAgICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lIHx8ICcnO1xyXG4gICAgICAgICAgICAvLyBpZiBob3N0bmFtZSBiZWdpbnMgd2l0aCBbIGFuZCBlbmRzIHdpdGggXVxyXG4gICAgICAgICAgICAvLyBhc3N1bWUgdGhhdCBpdCdzIGFuIElQdjYgYWRkcmVzcy5cclxuICAgICAgICAgICAgdmFyIGlwdjZIb3N0bmFtZSA9IHRoaXMuaG9zdG5hbWVbMF0gPT09ICdbJyAmJlxyXG4gICAgICAgICAgICAgICAgdGhpcy5ob3N0bmFtZVt0aGlzLmhvc3RuYW1lLmxlbmd0aCAtIDFdID09PSAnXSc7XHJcbiAgICAgICAgICAgIC8vIHZhbGlkYXRlIGEgbGl0dGxlLlxyXG4gICAgICAgICAgICBpZiAoIWlwdjZIb3N0bmFtZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGhvc3RwYXJ0cyA9IHRoaXMuaG9zdG5hbWUuc3BsaXQoL1xcLi8pO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBob3N0cGFydHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhcnQgPSBob3N0cGFydHNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwYXJ0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXBhcnQubWF0Y2goVXJsLmhvc3RuYW1lUGFydFBhdHRlcm4pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXdwYXJ0ID0gJyc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwLCBrID0gcGFydC5sZW5ndGg7IGogPCBrOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJ0LmNoYXJDb2RlQXQoaikgPiAxMjcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSByZXBsYWNlIG5vbi1BU0NJSSBjaGFyIHdpdGggYSB0ZW1wb3JhcnkgcGxhY2Vob2xkZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSBuZWVkIHRoaXMgdG8gbWFrZSBzdXJlIHNpemUgb2YgaG9zdG5hbWUgaXMgbm90XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYnJva2VuIGJ5IHJlcGxhY2luZyBub24tQVNDSUkgYnkgbm90aGluZ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld3BhcnQgKz0gJ3gnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3cGFydCArPSBwYXJ0W2pdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIHRlc3QgYWdhaW4gd2l0aCBBU0NJSSBjaGFyIG9ubHlcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFuZXdwYXJ0Lm1hdGNoKFVybC5ob3N0bmFtZVBhcnRQYXR0ZXJuKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbGlkUGFydHMgPSBob3N0cGFydHMuc2xpY2UoMCwgaSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbm90SG9zdCA9IGhvc3RwYXJ0cy5zbGljZShpICsgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYml0ID0gcGFydC5tYXRjaChVcmwuaG9zdG5hbWVQYXJ0U3RhcnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJpdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkUGFydHMucHVzaChiaXRbMV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vdEhvc3QudW5zaGlmdChiaXRbMl0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vdEhvc3QubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdCA9ICcvJyArIG5vdEhvc3Quam9pbignLicpICsgcmVzdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaG9zdG5hbWUgPSB2YWxpZFBhcnRzLmpvaW4oJy4nKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmhvc3RuYW1lLmxlbmd0aCA+IFVybC5ob3N0bmFtZU1heExlbikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ob3N0bmFtZSA9ICcnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gaG9zdG5hbWVzIGFyZSBhbHdheXMgbG93ZXIgY2FzZS5cclxuICAgICAgICAgICAgICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFpcHY2SG9zdG5hbWUpIHtcclxuICAgICAgICAgICAgICAgIC8vIElETkEgU3VwcG9ydDogUmV0dXJucyBhIHB1bnljb2RlZCByZXByZXNlbnRhdGlvbiBvZiBcImRvbWFpblwiLlxyXG4gICAgICAgICAgICAgICAgLy8gSXQgb25seSBjb252ZXJ0cyBwYXJ0cyBvZiB0aGUgZG9tYWluIG5hbWUgdGhhdFxyXG4gICAgICAgICAgICAgICAgLy8gaGF2ZSBub24tQVNDSUkgY2hhcmFjdGVycywgaS5lLiBpdCBkb2Vzbid0IG1hdHRlciBpZlxyXG4gICAgICAgICAgICAgICAgLy8geW91IGNhbGwgaXQgd2l0aCBhIGRvbWFpbiB0aGF0IGFscmVhZHkgaXMgQVNDSUktb25seS5cclxuICAgICAgICAgICAgICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLnRvQVNDSUkodGhpcy5ob3N0bmFtZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHAgPSB0aGlzLnBvcnQgPyAnOicgKyB0aGlzLnBvcnQgOiAnJztcclxuICAgICAgICAgICAgdmFyIGggPSB0aGlzLmhvc3RuYW1lIHx8ICcnO1xyXG4gICAgICAgICAgICB0aGlzLmhvc3QgPSBoICsgcDtcclxuICAgICAgICAgICAgdGhpcy5ocmVmICs9IHRoaXMuaG9zdDtcclxuICAgICAgICAgICAgLy8gc3RyaXAgWyBhbmQgXSBmcm9tIHRoZSBob3N0bmFtZVxyXG4gICAgICAgICAgICAvLyB0aGUgaG9zdCBmaWVsZCBzdGlsbCByZXRhaW5zIHRoZW0sIHRob3VnaFxyXG4gICAgICAgICAgICBpZiAoaXB2Nkhvc3RuYW1lKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZS5zdWJzdHIoMSwgdGhpcy5ob3N0bmFtZS5sZW5ndGggLSAyKTtcclxuICAgICAgICAgICAgICAgIGlmIChyZXN0WzBdICE9PSAnLycpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN0ID0gJy8nICsgcmVzdDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBub3cgcmVzdCBpcyBzZXQgdG8gdGhlIHBvc3QtaG9zdCBzdHVmZi5cclxuICAgICAgICAvLyBjaG9wIG9mZiBhbnkgZGVsaW0gY2hhcnMuXHJcbiAgICAgICAgaWYgKCFVcmwudW5zYWZlUHJvdG9jb2xbbG93ZXJQcm90b10pIHtcclxuICAgICAgICAgICAgLy8gRmlyc3QsIG1ha2UgMTAwJSBzdXJlIHRoYXQgYW55IFwiYXV0b0VzY2FwZVwiIGNoYXJzIGdldFxyXG4gICAgICAgICAgICAvLyBlc2NhcGVkLCBldmVuIGlmIGVuY29kZVVSSUNvbXBvbmVudCBkb2Vzbid0IHRoaW5rIHRoZXlcclxuICAgICAgICAgICAgLy8gbmVlZCB0byBiZS5cclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBVcmwuYXV0b0VzY2FwZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBhZSA9IFVybC5hdXRvRXNjYXBlW2ldO1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlc3QuaW5kZXhPZihhZSkgPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgZXNjID0gZW5jb2RlVVJJQ29tcG9uZW50KGFlKTtcclxuICAgICAgICAgICAgICAgIGlmIChlc2MgPT09IGFlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXNjID0gZXNjYXBlKGFlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJlc3QgPSByZXN0LnNwbGl0KGFlKS5qb2luKGVzYyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gY2hvcCBvZmYgZnJvbSB0aGUgdGFpbCBmaXJzdC5cclxuICAgICAgICB2YXIgaGFzaCA9IHJlc3QuaW5kZXhPZignIycpO1xyXG4gICAgICAgIGlmIChoYXNoICE9PSAtMSkge1xyXG4gICAgICAgICAgICAvLyBnb3QgYSBmcmFnbWVudCBzdHJpbmcuXHJcbiAgICAgICAgICAgIHRoaXMuaGFzaCA9IHJlc3Quc3Vic3RyKGhhc2gpO1xyXG4gICAgICAgICAgICByZXN0ID0gcmVzdC5zbGljZSgwLCBoYXNoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHFtID0gcmVzdC5pbmRleE9mKCc/Jyk7XHJcbiAgICAgICAgaWYgKHFtICE9PSAtMSkge1xyXG4gICAgICAgICAgICB0aGlzLnNlYXJjaCA9IHJlc3Quc3Vic3RyKHFtKTtcclxuICAgICAgICAgICAgdGhpcy5xdWVyeSA9IHJlc3Quc3Vic3RyKHFtICsgMSk7XHJcbiAgICAgICAgICAgIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnF1ZXJ5ID0gdGhpcy5wYXJzZSh0aGlzLnF1ZXJ5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXN0ID0gcmVzdC5zbGljZSgwLCBxbSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcclxuICAgICAgICAgICAgLy8gbm8gcXVlcnkgc3RyaW5nLCBidXQgcGFyc2VRdWVyeVN0cmluZyBzdGlsbCByZXF1ZXN0ZWRcclxuICAgICAgICAgICAgdGhpcy5zZWFyY2ggPSAnJztcclxuICAgICAgICAgICAgdGhpcy5xdWVyeSA9IHt9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocmVzdCkge1xyXG4gICAgICAgICAgICB0aGlzLnBhdGhuYW1lID0gcmVzdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKFVybC5zbGFzaGVkUHJvdG9jb2xbbG93ZXJQcm90b10gJiZcclxuICAgICAgICAgICAgdGhpcy5ob3N0bmFtZSAmJiAhdGhpcy5wYXRobmFtZSkge1xyXG4gICAgICAgICAgICB0aGlzLnBhdGhuYW1lID0gJy8nO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvL3RvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XHJcbiAgICAgICAgaWYgKHRoaXMucGF0aG5hbWUgfHwgdGhpcy5zZWFyY2gpIHtcclxuICAgICAgICAgICAgdmFyIHAgPSB0aGlzLnBhdGhuYW1lIHx8ICcnO1xyXG4gICAgICAgICAgICB2YXIgcyA9IHRoaXMuc2VhcmNoIHx8ICcnO1xyXG4gICAgICAgICAgICB0aGlzLnBhdGggPSBwICsgcztcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gZmluYWxseSwgcmVjb25zdHJ1Y3QgdGhlIGhyZWYgYmFzZWQgb24gd2hhdCBoYXMgYmVlbiB2YWxpZGF0ZWQuXHJcbiAgICAgICAgdGhpcy5ocmVmID0gdGhpcy5mb3JtYXQoKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gKiBDb252ZXJ0cyBhIFVuaWNvZGUgc3RyaW5nIHJlcHJlc2VudGluZyBhIGRvbWFpbiBuYW1lIG9yIGFuIGVtYWlsIGFkZHJlc3MgdG9cclxuICogUHVueWNvZGUuIE9ubHkgdGhlIG5vbi1BU0NJSSBwYXJ0cyBvZiB0aGUgZG9tYWluIG5hbWUgd2lsbCBiZSBjb252ZXJ0ZWQsXHJcbiAqIGkuZS4gaXQgZG9lc24ndCBtYXR0ZXIgaWYgeW91IGNhbGwgaXQgd2l0aCBhIGRvbWFpbiB0aGF0J3MgYWxyZWFkeSBpblxyXG4gKiBBU0NJSS5cclxuICogQG1lbWJlck9mIHB1bnljb2RlXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcyB0byBjb252ZXJ0LCBhcyBhXHJcbiAqIFVuaWNvZGUgc3RyaW5nLlxyXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgUHVueWNvZGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIGRvbWFpbiBuYW1lIG9yXHJcbiAqIGVtYWlsIGFkZHJlc3MuXHJcbiAqL1xyXG4gICAgdG9BU0NJSShpbnB1dCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm1hcERvbWFpbihpbnB1dCwgZnVuY3Rpb24gKHN0cmluZykge1xyXG4gICAgICAgICAgICByZXR1cm4gVXJsLnJlZ2V4Tm9uQVNDSUkudGVzdChzdHJpbmcpXHJcbiAgICAgICAgICAgICAgICA/ICd4bi0tJyArIHRoaXMuZW5jb2RlKHN0cmluZylcclxuICAgICAgICAgICAgICAgIDogc3RyaW5nO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgc3RyaW5naWZ5UHJpbWl0aXZlKHYpIHtcclxuICAgICAgICBzd2l0Y2ggKHR5cGVvZiB2KSB7XHJcbiAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdjtcclxuICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdiA/ICd0cnVlJyA6ICdmYWxzZSc7XHJcbiAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNGaW5pdGUodikgPyB2IDogJyc7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJyc7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgZW5jb2RlKG9iaiwgc2VwID0gbnVsbCwgZXEgPSBudWxsLCBuYW1lID0gbnVsbCkge1xyXG4gICAgICAgIHNlcCA9IHNlcCB8fCAnJic7XHJcbiAgICAgICAgZXEgPSBlcSB8fCAnPSc7XHJcbiAgICAgICAgaWYgKG9iaiA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICBvYmogPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMob2JqKS5tYXAoZnVuY3Rpb24gKGspIHtcclxuICAgICAgICAgICAgICAgIHZhciBrcyA9IGVuY29kZVVSSUNvbXBvbmVudCh0aGlzLnN0cmluZ2lmeVByaW1pdGl2ZShrKSkgKyBlcTtcclxuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9ialtrXSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2JqW2tdLm1hcChmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ga3MgKyBlbmNvZGVVUklDb21wb25lbnQodGhpcy5zdHJpbmdpZnlQcmltaXRpdmUodikpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pLmpvaW4oc2VwKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBrcyArIGVuY29kZVVSSUNvbXBvbmVudCh0aGlzLnN0cmluZ2lmeVByaW1pdGl2ZShvYmpba10pKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSkuam9pbihzZXApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIW5hbWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHRoaXMuc3RyaW5naWZ5UHJpbWl0aXZlKG5hbWUpKSArIGVxICtcclxuICAgICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KHRoaXMuc3RyaW5naWZ5UHJpbWl0aXZlKG9iaikpO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBIHNpbXBsZSBgQXJyYXkjbWFwYC1saWtlIHdyYXBwZXIgdG8gd29yayB3aXRoIGRvbWFpbiBuYW1lIHN0cmluZ3Mgb3IgZW1haWxcclxuICAgICAqIGFkZHJlc3Nlcy5cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZG9tYWluIFRoZSBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzLlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgZm9yIGV2ZXJ5XHJcbiAgICAgKiBjaGFyYWN0ZXIuXHJcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IEEgbmV3IHN0cmluZyBvZiBjaGFyYWN0ZXJzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFja1xyXG4gICAgICogZnVuY3Rpb24uXHJcbiAgICAgKi9cclxuICAgIG1hcERvbWFpbihzdHJpbmcsIGZuKSB7XHJcbiAgICAgICAgdmFyIHBhcnRzID0gc3RyaW5nLnNwbGl0KCdAJyk7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9ICcnO1xyXG4gICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgIC8vIEluIGVtYWlsIGFkZHJlc3Nlcywgb25seSB0aGUgZG9tYWluIG5hbWUgc2hvdWxkIGJlIHB1bnljb2RlZC4gTGVhdmVcclxuICAgICAgICAgICAgLy8gdGhlIGxvY2FsIHBhcnQgKGkuZS4gZXZlcnl0aGluZyB1cCB0byBgQGApIGludGFjdC5cclxuICAgICAgICAgICAgcmVzdWx0ID0gcGFydHNbMF0gKyAnQCc7XHJcbiAgICAgICAgICAgIHN0cmluZyA9IHBhcnRzWzFdO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBBdm9pZCBgc3BsaXQocmVnZXgpYCBmb3IgSUU4IGNvbXBhdGliaWxpdHkuIFNlZSAjMTcuXHJcbiAgICAgICAgc3RyaW5nID0gc3RyaW5nLnJlcGxhY2UoVXJsLnJlZ2V4U2VwYXJhdG9ycywgJ1xceDJFJyk7XHJcbiAgICAgICAgdmFyIGxhYmVscyA9IHN0cmluZy5zcGxpdCgnLicpO1xyXG4gICAgICAgIHZhciBlbmNvZGVkID0gdGhpcy5tYXAobGFiZWxzLCBmbikuam9pbignLicpO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQgKyBlbmNvZGVkO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBIGdlbmVyaWMgYEFycmF5I21hcGAgdXRpbGl0eSBmdW5jdGlvbi5cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgZm9yIGV2ZXJ5IGFycmF5XHJcbiAgICAgKiBpdGVtLlxyXG4gICAgICogQHJldHVybnMge0FycmF5fSBBIG5ldyBhcnJheSBvZiB2YWx1ZXMgcmV0dXJuZWQgYnkgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uLlxyXG4gICAgICovXHJcbiAgICBtYXAoYXJyYXksIGZuKSB7XHJcbiAgICAgICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gW107XHJcbiAgICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdFtsZW5ndGhdID0gZm4oYXJyYXlbbGVuZ3RoXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICBmb3JtYXQoKSB7XHJcbiAgICAgICAgdmFyIGF1dGggPSB0aGlzLmF1dGggfHwgJyc7XHJcbiAgICAgICAgaWYgKGF1dGgpIHtcclxuICAgICAgICAgICAgYXV0aCA9IGVuY29kZVVSSUNvbXBvbmVudChhdXRoKTtcclxuICAgICAgICAgICAgYXV0aCA9IGF1dGgucmVwbGFjZSgvJTNBL2ksICc6Jyk7XHJcbiAgICAgICAgICAgIGF1dGggKz0gJ0AnO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcHJvdG9jb2wgPSB0aGlzLnByb3RvY29sIHx8ICcnLCBwYXRobmFtZSA9IHRoaXMucGF0aG5hbWUgfHwgJycsIGhhc2ggPSB0aGlzLmhhc2ggfHwgJycsIGhvc3QgPSBmYWxzZSwgcXVlcnkgPSAnJztcclxuICAgICAgICBpZiAodGhpcy5ob3N0KSB7XHJcbiAgICAgICAgICAgIGhvc3QgPSBhdXRoICsgdGhpcy5ob3N0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLmhvc3RuYW1lKSB7XHJcbiAgICAgICAgICAgIGhvc3QgPSBhdXRoICsgKHRoaXMuaG9zdG5hbWUuaW5kZXhPZignOicpID09PSAtMSA/XHJcbiAgICAgICAgICAgICAgICB0aGlzLmhvc3RuYW1lIDpcclxuICAgICAgICAgICAgICAgICdbJyArIHRoaXMuaG9zdG5hbWUgKyAnXScpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5wb3J0KSB7XHJcbiAgICAgICAgICAgICAgICBob3N0ICs9ICc6JyArIHRoaXMucG9ydDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5xdWVyeSAmJlxyXG4gICAgICAgICAgICBVdGlsc1NldHRpbmdzXzEuVXRpbHNTZXR0aW5ncy51dGlsLmlzT2JqZWN0KHRoaXMucXVlcnkpICYmXHJcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHRoaXMucXVlcnkpLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBxdWVyeSA9IHRoaXMuZW5jb2RlKHRoaXMucXVlcnkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgc2VhcmNoID0gdGhpcy5zZWFyY2ggfHwgKHF1ZXJ5ICYmICgnPycgKyBxdWVyeSkpIHx8ICcnO1xyXG4gICAgICAgIGlmIChwcm90b2NvbCAmJiBwcm90b2NvbC5zdWJzdHIoLTEpICE9PSAnOicpIHtcclxuICAgICAgICAgICAgcHJvdG9jb2wgKz0gJzonO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBvbmx5IHRoZSBzbGFzaGVkUHJvdG9jb2xzIGdldCB0aGUgLy8uICBOb3QgbWFpbHRvOiwgeG1wcDosIGV0Yy5cclxuICAgICAgICAvLyB1bmxlc3MgdGhleSBoYWQgdGhlbSB0byBiZWdpbiB3aXRoLlxyXG4gICAgICAgIGlmICh0aGlzLnNsYXNoZXMgfHxcclxuICAgICAgICAgICAgKCFwcm90b2NvbCB8fCBVcmwuc2xhc2hlZFByb3RvY29sW3Byb3RvY29sXSkgJiYgaG9zdCAhPT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgaG9zdCA9ICcvLycgKyAoaG9zdCB8fCAnJyk7XHJcbiAgICAgICAgICAgIGlmIChwYXRobmFtZSAmJiBwYXRobmFtZS5jaGFyQXQoMCkgIT09ICcvJykge1xyXG4gICAgICAgICAgICAgICAgcGF0aG5hbWUgPSAnLycgKyBwYXRobmFtZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICghaG9zdCkge1xyXG4gICAgICAgICAgICBob3N0ID0gJyc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChoYXNoICYmIGhhc2guY2hhckF0KDApICE9PSAnIycpIHtcclxuICAgICAgICAgICAgaGFzaCA9ICcjJyArIGhhc2g7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzZWFyY2ggJiYgc2VhcmNoLmNoYXJBdCgwKSAhPT0gJz8nKSB7XHJcbiAgICAgICAgICAgIHNlYXJjaCA9ICc/JyArIHNlYXJjaDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcGF0aG5hbWUgPSBwYXRobmFtZS5yZXBsYWNlKC9bPyNdL2csIGZ1bmN0aW9uIChtYXRjaCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KG1hdGNoKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBzZWFyY2ggPSBzZWFyY2gucmVwbGFjZSgnIycsICclMjMnKTtcclxuICAgICAgICByZXR1cm4gcHJvdG9jb2wgKyBob3N0ICsgcGF0aG5hbWUgKyBzZWFyY2ggKyBoYXNoO1xyXG4gICAgfVxyXG4gICAgO1xyXG59XHJcblVybC5yZWdleFNlcGFyYXRvcnMgPSAvW1xceDJFXFx1MzAwMlxcdUZGMEVcXHVGRjYxXS9nO1xyXG5VcmwucG9ydFBhdHRlcm4gPSAvOlswLTldKiQvO1xyXG5Vcmwuc2ltcGxlUGF0aFBhdHRlcm4gPSAvXihcXC9cXC8/KD8hXFwvKVteXFw/XFxzXSopKFxcP1teXFxzXSopPyQvO1xyXG5VcmwucHJvdG9jb2xQYXR0ZXJuID0gL14oW2EtejAtOS4rLV0rOikvaTtcclxuVXJsLnJlZ2V4Tm9uQVNDSUkgPSAvW15cXHgyMC1cXHg3RV0vO1xyXG5VcmwuaG9zdGxlc3NQcm90b2NvbCA9IHtcclxuICAgICdqYXZhc2NyaXB0JzogdHJ1ZSxcclxuICAgICdqYXZhc2NyaXB0Oic6IHRydWVcclxufTtcclxuVXJsLnNsYXNoZWRQcm90b2NvbCA9IHtcclxuICAgICdodHRwJzogdHJ1ZSxcclxuICAgICdodHRwcyc6IHRydWUsXHJcbiAgICAnZnRwJzogdHJ1ZSxcclxuICAgICdnb3BoZXInOiB0cnVlLFxyXG4gICAgJ2ZpbGUnOiB0cnVlLFxyXG4gICAgJ2h0dHA6JzogdHJ1ZSxcclxuICAgICdodHRwczonOiB0cnVlLFxyXG4gICAgJ2Z0cDonOiB0cnVlLFxyXG4gICAgJ2dvcGhlcjonOiB0cnVlLFxyXG4gICAgJ2ZpbGU6JzogdHJ1ZVxyXG59O1xyXG5VcmwuaG9zdEVuZGluZ0NoYXJzID0gWycvJywgJz8nLCAnIyddO1xyXG5VcmwuZGVsaW1zID0gWyc8JywgJz4nLCAnXCInLCAnYCcsICcgJywgJ1xccicsICdcXG4nLCAnXFx0J107XHJcblVybC51bndpc2UgPSBbJ3snLCAnfScsICd8JywgJ1xcXFwnLCAnXicsICdgJ10uY29uY2F0KFVybC5kZWxpbXMpO1xyXG5VcmwuYXV0b0VzY2FwZSA9IFsnXFwnJ10uY29uY2F0KFVybC51bndpc2UpO1xyXG5Vcmwubm9uSG9zdENoYXJzID0gWyclJywgJy8nLCAnPycsICc7JywgJyMnXS5jb25jYXQoVXJsLmF1dG9Fc2NhcGUpO1xyXG5VcmwuaG9zdG5hbWVQYXJ0UGF0dGVybiA9IC9eWythLXowLTlBLVpfLV17MCw2M30kLztcclxuVXJsLmhvc3RuYW1lUGFydFN0YXJ0ID0gL14oWythLXowLTlBLVpfLV17MCw2M30pKC4qKSQvO1xyXG5VcmwuaG9zdG5hbWVNYXhMZW4gPSAyNTU7XHJcblVybC51bnNhZmVQcm90b2NvbCA9IHtcclxuICAgICdqYXZhc2NyaXB0JzogdHJ1ZSxcclxuICAgICdqYXZhc2NyaXB0Oic6IHRydWVcclxufTtcclxuZXhwb3J0cy5VcmwgPSBVcmw7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNsYXNzIFV0aWxzU2V0dGluZ3Mge1xyXG4gICAgc3RhdGljIHJlbW92ZUl0ZW1zKGFyciwgc3RhcnRJZHgsIHJlbW92ZUNvdW50KSB7XHJcbiAgICAgICAgdmFyIGxlbmd0aCA9IGFyci5sZW5ndGg7XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgaWYgKHN0YXJ0SWR4ID49IGxlbmd0aCB8fCByZW1vdmVDb3VudCA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlbW92ZUNvdW50ID0gKHN0YXJ0SWR4ICsgcmVtb3ZlQ291bnQgPiBsZW5ndGggPyBsZW5ndGggLSBzdGFydElkeCA6IHJlbW92ZUNvdW50KTtcclxuICAgICAgICB2YXIgbGVuID0gbGVuZ3RoIC0gcmVtb3ZlQ291bnQ7XHJcbiAgICAgICAgZm9yIChpID0gc3RhcnRJZHg7IGkgPCBsZW47ICsraSkge1xyXG4gICAgICAgICAgICBhcnJbaV0gPSBhcnJbaSArIHJlbW92ZUNvdW50XTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYXJyLmxlbmd0aCA9IGxlbjtcclxuICAgIH1cclxuICAgIHN0YXRpYyBkZWVwQ29weVByb3BlcnRpZXModGFyZ2V0LCBzb3VyY2UsIHByb3BlcnR5T2JqKSB7XHJcbiAgICAgICAgZm9yICh2YXIgcHJvcCBpbiBwcm9wZXJ0eU9iaikge1xyXG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzb3VyY2VbcHJvcF0pKSB7XHJcbiAgICAgICAgICAgICAgICB0YXJnZXRbcHJvcF0gPSBzb3VyY2VbcHJvcF0uc2xpY2UoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRhcmdldFtwcm9wXSA9IHNvdXJjZVtwcm9wXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHN0YXRpYyBhcmVBcnJheXNFcXVhbChhcnJheTEsIGFycmF5Mikge1xyXG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShhcnJheTEpIHx8ICFBcnJheS5pc0FycmF5KGFycmF5MikpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYXJyYXkxLmxlbmd0aCAhPT0gYXJyYXkyLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkxLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgIGlmIChhcnJheTFbaV0gIT09IGFycmF5MltpXSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIHVuc2FmZUV2YWxTdXBwb3J0ZWQoKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBVdGlsc1NldHRpbmdzLnVuc2FmZUV2YWwgPT09ICdib29sZWFuJykge1xyXG4gICAgICAgICAgICByZXR1cm4gVXRpbHNTZXR0aW5ncy51bnNhZmVFdmFsO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICB2YXIgZnVuYyA9IG5ldyBGdW5jdGlvbigncGFyYW0xJywgJ3BhcmFtMicsICdwYXJhbTMnLCAncmV0dXJuIHBhcmFtMVtwYXJhbTJdID09PSBwYXJhbTM7Jyk7XHJcbiAgICAgICAgICAgIFV0aWxzU2V0dGluZ3MudW5zYWZlRXZhbCA9IGZ1bmMoeyBhOiAnYicgfSwgJ2EnLCAnYicpID09PSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICBVdGlsc1NldHRpbmdzLnVuc2FmZUV2YWwgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFV0aWxzU2V0dGluZ3MudW5zYWZlRXZhbDtcclxuICAgIH1cclxuICAgIHN0YXRpYyBpc1dlYkdMU3VwcG9ydGVkKCkge1xyXG4gICAgICAgIHZhciBjb250ZXh0T3B0aW9ucyA9IHsgc3RlbmNpbDogdHJ1ZSwgZmFpbElmTWFqb3JQZXJmb3JtYW5jZUNhdmVhdDogdHJ1ZSB9O1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGlmICghd2luZG93WydXZWJHTFJlbmRlcmluZ0NvbnRleHQnXSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcclxuICAgICAgICAgICAgdmFyIGdsID0gY2FudmFzLmdldENvbnRleHQoJ3dlYmdsJywgY29udGV4dE9wdGlvbnMpIHx8IGNhbnZhcy5nZXRDb250ZXh0KCdleHBlcmltZW50YWwtd2ViZ2wnLCBjb250ZXh0T3B0aW9ucyk7XHJcbiAgICAgICAgICAgIHZhciBzdWNjZXNzID0gISEoZ2wgJiYgZ2wuZ2V0Q29udGV4dEF0dHJpYnV0ZXMoKS5zdGVuY2lsKTtcclxuICAgICAgICAgICAgaWYgKGdsKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbG9zZUNvbnRleHQgPSBnbC5nZXRFeHRlbnNpb24oJ1dFQkdMX2xvc2VfY29udGV4dCcpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGxvc2VDb250ZXh0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbG9zZUNvbnRleHQubG9zZUNvbnRleHQoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBnbCA9IG51bGw7XHJcbiAgICAgICAgICAgIHJldHVybiBzdWNjZXNzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblV0aWxzU2V0dGluZ3MudXRpbCA9IHtcclxuICAgIGlzU3RyaW5nOiBmdW5jdGlvbiAoYXJnKSB7XHJcbiAgICAgICAgcmV0dXJuIHR5cGVvZiAoYXJnKSA9PT0gJ3N0cmluZyc7XHJcbiAgICB9LFxyXG4gICAgaXNPYmplY3Q6IGZ1bmN0aW9uIChhcmcpIHtcclxuICAgICAgICByZXR1cm4gdHlwZW9mIChhcmcpID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XHJcbiAgICB9LFxyXG4gICAgaXNOdWxsOiBmdW5jdGlvbiAoYXJnKSB7XHJcbiAgICAgICAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcclxuICAgIH0sXHJcbiAgICBpc051bGxPclVuZGVmaW5lZDogZnVuY3Rpb24gKGFyZykge1xyXG4gICAgICAgIHJldHVybiBhcmcgPT0gbnVsbDtcclxuICAgIH1cclxufTtcclxuZXhwb3J0cy5VdGlsc1NldHRpbmdzID0gVXRpbHNTZXR0aW5ncztcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgQmFzZUltYWdlUmVzb3VyY2VfMSA9IHJlcXVpcmUoXCIuL0Jhc2VJbWFnZVJlc291cmNlXCIpO1xyXG5jb25zdCBUaWNrZXJfMSA9IHJlcXVpcmUoXCIuL1RpY2tlclwiKTtcclxuY29uc3QgTG9nZ2VyXzEgPSByZXF1aXJlKFwiLi9Mb2dnZXJcIik7XHJcbmNsYXNzIFZpZGVvUmVzb3VyY2UgZXh0ZW5kcyBCYXNlSW1hZ2VSZXNvdXJjZV8xLkJhc2VJbWFnZVJlc291cmNlIHtcclxuICAgIGNvbnN0cnVjdG9yKHNvdXJjZSwgb3B0aW9ucykge1xyXG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG4gICAgICAgIC8vIHRocm93IFwic3RvcFwiXHJcbiAgICAgICAgaWYgKCEoc291cmNlIGluc3RhbmNlb2YgSFRNTFZpZGVvRWxlbWVudCkpIHtcclxuICAgICAgICAgICAgdmFyIHZpZGVvRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3ZpZGVvJyk7XHJcbiAgICAgICAgICAgIHZpZGVvRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3dlYmtpdC1wbGF5c2lubGluZScsICcnKTtcclxuICAgICAgICAgICAgdmlkZW9FbGVtZW50LnNldEF0dHJpYnV0ZSgncGxheXNpbmxpbmUnLCAnJyk7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc291cmNlID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgc291cmNlID0gW3NvdXJjZV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgQmFzZUltYWdlUmVzb3VyY2VfMS5CYXNlSW1hZ2VSZXNvdXJjZS5jcm9zc09yaWdpbih2aWRlb0VsZW1lbnQsIChzb3VyY2VbMF0uc3JjIHx8IHNvdXJjZVswXSksIG9wdGlvbnMuY3Jvc3NvcmlnaW4pO1xyXG4gICAgICAgICAgICAvLyBhcnJheSBvZiBvYmplY3RzIG9yIHN0cmluZ3NcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzb3VyY2UubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgICAgIHZhciBzb3VyY2VFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc291cmNlJyk7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVmID0gc291cmNlW2ldO1xyXG4gICAgICAgICAgICAgICAgdmFyIHNyYyA9IHJlZi5zcmM7XHJcbiAgICAgICAgICAgICAgICB2YXIgbWltZSA9IHJlZi5taW1lO1xyXG4gICAgICAgICAgICAgICAgc3JjID0gc3JjIHx8IHNvdXJjZVtpXTtcclxuICAgICAgICAgICAgICAgIHZhciBiYXNlU3JjID0gc3JjLnNwbGl0KCc/Jykuc2hpZnQoKS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGV4dCA9IGJhc2VTcmMuc3Vic3RyKGJhc2VTcmMubGFzdEluZGV4T2YoJy4nKSArIDEpO1xyXG4gICAgICAgICAgICAgICAgbWltZSA9IG1pbWUgfHwgKFwidmlkZW8vXCIgKyBleHQpO1xyXG4gICAgICAgICAgICAgICAgc291cmNlRWxlbWVudC5zcmMgPSBzcmM7XHJcbiAgICAgICAgICAgICAgICBzb3VyY2VFbGVtZW50LnR5cGUgPSBtaW1lO1xyXG4gICAgICAgICAgICAgICAgdmlkZW9FbGVtZW50LmFwcGVuZENoaWxkKHNvdXJjZUVsZW1lbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIE92ZXJyaWRlIHRoZSBzb3VyY2VcclxuICAgICAgICAgICAgc291cmNlID0gdmlkZW9FbGVtZW50O1xyXG4gICAgICAgIH1cclxuICAgICAgICBzdXBlcihzb3VyY2UpO1xyXG4gICAgICAgIHRoaXMuY2FuVXBsb2FkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fYXV0b1VwZGF0ZSA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5faXNBdXRvVXBkYXRpbmcgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl91cGRhdGVGUFMgPSBvcHRpb25zLnVwZGF0ZUZQUyB8fCAwO1xyXG4gICAgICAgIHRoaXMuX21zVG9OZXh0VXBkYXRlID0gMDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBXaGVuIHNldCB0byB0cnVlIHdpbGwgYXV0b21hdGljYWxseSBwbGF5IHZpZGVvcyB1c2VkIGJ5IHRoaXMgdGV4dHVyZSBvbmNlXHJcbiAgICAgICAgICogdGhleSBhcmUgbG9hZGVkLiBJZiBmYWxzZSwgaXQgd2lsbCBub3QgbW9kaWZ5IHRoZSBwbGF5aW5nIHN0YXRlLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQG1lbWJlciB7Ym9vbGVhbn1cclxuICAgICAgICAgKiBAZGVmYXVsdCB0cnVlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5hdXRvUGxheSA9IG9wdGlvbnMuYXV0b1BsYXkgIT09IGZhbHNlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFByb21pc2Ugd2hlbiBsb2FkaW5nXHJcbiAgICAgICAgICogQG1lbWJlciB7UHJvbWlzZTx2b2lkPn1cclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqIEBkZWZhdWx0IG51bGxcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLl9sb2FkID0gbnVsbDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDYWxsYmFjayB3aGVuIGNvbXBsZXRlZCB3aXRoIGxvYWQuXHJcbiAgICAgICAgICogQG1lbWJlciB7ZnVuY3Rpb259XHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLl9yZXNvbHZlID0gbnVsbDtcclxuICAgICAgICAvLyBCaW5kIGZvciBsaXN0ZW5lcnNcclxuICAgICAgICB0aGlzLl9vbkNhblBsYXkgPSB0aGlzLl9vbkNhblBsYXkuYmluZCh0aGlzKTtcclxuICAgICAgICBpZiAob3B0aW9ucy5hdXRvTG9hZCAhPT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgdGhpcy5sb2FkKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUcmlnZ2VyIHVwZGF0aW5nIG9mIHRoZSB0ZXh0dXJlXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtkZWx0YVRpbWU9MF0gLSB0aW1lIGRlbHRhIHNpbmNlIGxhc3QgdGlja1xyXG4gICAgICovXHJcbiAgICB1cGRhdGUoZGVsdGFUaW1lID0gMCkge1xyXG4gICAgICAgIGlmICghdGhpcy5kZXN0cm95ZWQpIHtcclxuICAgICAgICAgICAgLy8gYWNjb3VudCBmb3IgaWYgdmlkZW8gaGFzIGhhZCBpdHMgcGxheWJhY2tSYXRlIGNoYW5nZWRcclxuICAgICAgICAgICAgdmFyIGVsYXBzZWRNUyA9IFRpY2tlcl8xLlRpY2tlci5zaGFyZWQuZWxhcHNlZE1TICogdGhpcy5zb3VyY2UucGxheWJhY2tSYXRlO1xyXG4gICAgICAgICAgICAvLyB0cmFjZShcImVsYXBzZWQ6IFwiICsgZWxhcHNlZE1TKVxyXG4gICAgICAgICAgICB0aGlzLl9tc1RvTmV4dFVwZGF0ZSA9IE1hdGguZmxvb3IodGhpcy5fbXNUb05leHRVcGRhdGUgLSBlbGFwc2VkTVMpO1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX3VwZGF0ZUZQUyB8fCB0aGlzLl9tc1RvTmV4dFVwZGF0ZSA8PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAvLyB0cmFjZShcInN1cGVyIHVwZGF0ZTogXCIgKyBkZWx0YVRpbWUpXHJcbiAgICAgICAgICAgICAgICBzdXBlci51cGRhdGUoZGVsdGFUaW1lKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX21zVG9OZXh0VXBkYXRlID0gdGhpcy5fdXBkYXRlRlBTID8gTWF0aC5mbG9vcigxMDAwIC8gdGhpcy5fdXBkYXRlRlBTKSA6IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFN0YXJ0IHByZWxvYWRpbmcgdGhlIHZpZGVvIHJlc291cmNlLlxyXG4gICAgICpcclxuICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAqIEByZXR1cm4ge1Byb21pc2U8dm9pZD59IEhhbmRsZSB0aGUgdmFsaWRhdGUgZXZlbnRcclxuICAgICAqL1xyXG4gICAgbG9hZCgpIHtcclxuICAgICAgICBMb2dnZXJfMS50cmFjZShcImxvYWRpbmcgdmlkZW9cIik7XHJcbiAgICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XHJcbiAgICAgICAgaWYgKHRoaXMuX2xvYWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xvYWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBzb3VyY2UgPSB0aGlzLnNvdXJjZTtcclxuICAgICAgICBpZiAoKHNvdXJjZS5yZWFkeVN0YXRlID09PSBzb3VyY2UuSEFWRV9FTk9VR0hfREFUQSB8fCBzb3VyY2UucmVhZHlTdGF0ZSA9PT0gc291cmNlLkhBVkVfRlVUVVJFX0RBVEEpXHJcbiAgICAgICAgICAgICYmIHNvdXJjZS53aWR0aCAmJiBzb3VyY2UuaGVpZ2h0KSB7XHJcbiAgICAgICAgICAgIHNvdXJjZS5jb21wbGV0ZSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNvdXJjZS5hZGRFdmVudExpc3RlbmVyKCdwbGF5JywgdGhpcy5fb25QbGF5U3RhcnQuYmluZCh0aGlzKSk7XHJcbiAgICAgICAgc291cmNlLmFkZEV2ZW50TGlzdGVuZXIoJ3BhdXNlJywgdGhpcy5fb25QbGF5U3RvcC5iaW5kKHRoaXMpKTtcclxuICAgICAgICBpZiAoIXRoaXMuX2lzU291cmNlUmVhZHkoKSkge1xyXG4gICAgICAgICAgICBzb3VyY2UuYWRkRXZlbnRMaXN0ZW5lcignY2FucGxheScsIHRoaXMuX29uQ2FuUGxheSk7XHJcbiAgICAgICAgICAgIHNvdXJjZS5hZGRFdmVudExpc3RlbmVyKCdjYW5wbGF5dGhyb3VnaCcsIHRoaXMuX29uQ2FuUGxheSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLl9vbkNhblBsYXkoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fbG9hZCA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzJDEudmFsaWQpIHtcclxuICAgICAgICAgICAgICAgIHJlc29sdmUodGhpcyQxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMkMS5fcmVzb2x2ZSA9IHJlc29sdmU7XHJcbiAgICAgICAgICAgICAgICBzb3VyY2UubG9hZCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvYWQ7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgdW5kZXJseWluZyBzb3VyY2UgaXMgcGxheWluZy5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBwbGF5aW5nLlxyXG4gICAgICovXHJcbiAgICBfaXNTb3VyY2VQbGF5aW5nKCkge1xyXG4gICAgICAgIHZhciBzb3VyY2UgPSB0aGlzLnNvdXJjZTtcclxuICAgICAgICByZXR1cm4gKHNvdXJjZS5jdXJyZW50VGltZSA+IDAgJiYgc291cmNlLnBhdXNlZCA9PT0gZmFsc2UgJiYgc291cmNlLmVuZGVkID09PSBmYWxzZSAmJiBzb3VyY2UucmVhZHlTdGF0ZSA+IDIpO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHVuZGVybHlpbmcgc291cmNlIGlzIHJlYWR5IGZvciBwbGF5aW5nLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHJlYWR5LlxyXG4gICAgICovXHJcbiAgICBfaXNTb3VyY2VSZWFkeSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2UucmVhZHlTdGF0ZSA9PT0gMyB8fCB0aGlzLnNvdXJjZS5yZWFkeVN0YXRlID09PSA0O1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBSdW5zIHRoZSB1cGRhdGUgbG9vcCB3aGVuIHRoZSB2aWRlbyBpcyByZWFkeSB0byBwbGF5XHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgX29uUGxheVN0YXJ0KCkge1xyXG4gICAgICAgIC8vIEp1c3QgaW4gY2FzZSB0aGUgdmlkZW8gaGFzIG5vdCByZWNlaXZlZCBpdHMgY2FuIHBsYXkgZXZlbiB5ZXQuLlxyXG4gICAgICAgIGlmICghdGhpcy52YWxpZCkge1xyXG4gICAgICAgICAgICB0aGlzLl9vbkNhblBsYXkoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCF0aGlzLl9pc0F1dG9VcGRhdGluZyAmJiB0aGlzLmF1dG9VcGRhdGUpIHtcclxuICAgICAgICAgICAgVGlja2VyXzEuVGlja2VyLnNoYXJlZC5hZGQodGhpcy51cGRhdGUsIHRoaXMpO1xyXG4gICAgICAgICAgICB0aGlzLl9pc0F1dG9VcGRhdGluZyA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBGaXJlZCB3aGVuIGEgcGF1c2UgZXZlbnQgaXMgdHJpZ2dlcmVkLCBzdG9wcyB0aGUgdXBkYXRlIGxvb3BcclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBfb25QbGF5U3RvcCgpIHtcclxuICAgICAgICBpZiAodGhpcy5faXNBdXRvVXBkYXRpbmcpIHtcclxuICAgICAgICAgICAgVGlja2VyXzEuVGlja2VyLnNoYXJlZC5yZW1vdmUodGhpcy51cGRhdGUsIHRoaXMpO1xyXG4gICAgICAgICAgICB0aGlzLl9pc0F1dG9VcGRhdGluZyA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogRmlyZWQgd2hlbiB0aGUgdmlkZW8gaXMgbG9hZGVkIGFuZCByZWFkeSB0byBwbGF5XHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgX29uQ2FuUGxheSgpIHtcclxuICAgICAgICB2YXIgcmVmID0gdGhpcztcclxuICAgICAgICB2YXIgc291cmNlID0gcmVmLnNvdXJjZTtcclxuICAgICAgICBzb3VyY2UucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2FucGxheScsIHRoaXMuX29uQ2FuUGxheSk7XHJcbiAgICAgICAgc291cmNlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NhbnBsYXl0aHJvdWdoJywgdGhpcy5fb25DYW5QbGF5KTtcclxuICAgICAgICB2YXIgdmFsaWQgPSB0aGlzLnZhbGlkO1xyXG4gICAgICAgIHRoaXMucmVzaXplKHNvdXJjZS52aWRlb1dpZHRoLCBzb3VyY2UudmlkZW9IZWlnaHQpO1xyXG4gICAgICAgIC8vIHByZXZlbnQgbXVsdGlwbGUgbG9hZGVkIGRpc3BhdGNoZXMuLlxyXG4gICAgICAgIGlmICghdmFsaWQgJiYgdGhpcy5fcmVzb2x2ZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9yZXNvbHZlKHRoaXMpO1xyXG4gICAgICAgICAgICB0aGlzLl9yZXNvbHZlID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuX2lzU291cmNlUGxheWluZygpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX29uUGxheVN0YXJ0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMuYXV0b1BsYXkpIHtcclxuICAgICAgICAgICAgc291cmNlLnBsYXkoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIERlc3Ryb3lzIHRoaXMgdGV4dHVyZVxyXG4gICAgICogQG92ZXJyaWRlXHJcbiAgICAgKi9cclxuICAgIGRpc3Bvc2UoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2lzQXV0b1VwZGF0aW5nKSB7XHJcbiAgICAgICAgICAgIFRpY2tlcl8xLlRpY2tlci5zaGFyZWQucmVtb3ZlKHRoaXMudXBkYXRlLCB0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuc291cmNlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc291cmNlLnBhdXNlKCk7XHJcbiAgICAgICAgICAgIHRoaXMuc291cmNlLnNyYyA9ICcnO1xyXG4gICAgICAgICAgICB0aGlzLnNvdXJjZS5sb2FkKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIEJhc2VJbWFnZVJlc291cmNlXzEuQmFzZUltYWdlUmVzb3VyY2UucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogU2hvdWxkIHRoZSBiYXNlIHRleHR1cmUgYXV0b21hdGljYWxseSB1cGRhdGUgaXRzZWxmLCBzZXQgdG8gdHJ1ZSBieSBkZWZhdWx0XHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgZ2V0IGF1dG9VcGRhdGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2F1dG9VcGRhdGU7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICBzZXQgYXV0b1VwZGF0ZSh2YWx1ZSkge1xyXG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdGhpcy5fYXV0b1VwZGF0ZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9hdXRvVXBkYXRlID0gdmFsdWU7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5fYXV0b1VwZGF0ZSAmJiB0aGlzLl9pc0F1dG9VcGRhdGluZykge1xyXG4gICAgICAgICAgICAgICAgVGlja2VyXzEuVGlja2VyLnNoYXJlZC5yZW1vdmUodGhpcy51cGRhdGUsIHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faXNBdXRvVXBkYXRpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9hdXRvVXBkYXRlICYmICF0aGlzLl9pc0F1dG9VcGRhdGluZykge1xyXG4gICAgICAgICAgICAgICAgVGlja2VyXzEuVGlja2VyLnNoYXJlZC5hZGQodGhpcy51cGRhdGUsIHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faXNBdXRvVXBkYXRpbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBIb3cgbWFueSB0aW1lcyBhIHNlY29uZCB0byB1cGRhdGUgdGhlIHRleHR1cmUgZnJvbSB0aGUgdmlkZW8uIExlYXZlIGF0IDAgdG8gdXBkYXRlIGF0IGV2ZXJ5IHJlbmRlci5cclxuICAgICAqIEEgbG93ZXIgZnBzIGNhbiBoZWxwIHBlcmZvcm1hbmNlLCBhcyB1cGRhdGluZyB0aGUgdGV4dHVyZSBhdCA2MGZwcyBvbiBhIDMwcHMgdmlkZW8gbWF5IG5vdCBiZSBlZmZpY2llbnQuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICBnZXQgdXBkYXRlRlBTKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl91cGRhdGVGUFM7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICBzZXQgdXBkYXRlRlBTKHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKHZhbHVlICE9PSB0aGlzLl91cGRhdGVGUFMpIHtcclxuICAgICAgICAgICAgdGhpcy5fdXBkYXRlRlBTID0gdmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBVc2VkIHRvIGF1dG8tZGV0ZWN0IHRoZSB0eXBlIG9mIHJlc291cmNlLlxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBwYXJhbSB7Kn0gc291cmNlIC0gVGhlIHNvdXJjZSBvYmplY3RcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBleHRlbnNpb24gLSBUaGUgZXh0ZW5zaW9uIG9mIHNvdXJjZSwgaWYgc2V0XHJcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBgdHJ1ZWAgaWYgdmlkZW8gc291cmNlXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyB0ZXN0KHNvdXJjZSwgZXh0ZW5zaW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIChzb3VyY2UgaW5zdGFuY2VvZiBIVE1MVmlkZW9FbGVtZW50KVxyXG4gICAgICAgICAgICB8fCBWaWRlb1Jlc291cmNlLlRZUEVTLmluZGV4T2YoZXh0ZW5zaW9uKSA+IC0xO1xyXG4gICAgfVxyXG4gICAgO1xyXG59XHJcblZpZGVvUmVzb3VyY2UuVFlQRVMgPSBbJ21wNCcsICdtNHYnLCAnd2VibScsICdvZ2cnLCAnb2d2JywgJ2gyNjQnLCAnYXZpJywgJ21vdiddO1xyXG5leHBvcnRzLlZpZGVvUmVzb3VyY2UgPSBWaWRlb1Jlc291cmNlO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBQcm9ncmFtXzEgPSByZXF1aXJlKFwiLi9Qcm9ncmFtXCIpO1xyXG5jb25zdCBNYXRyaXhfMSA9IHJlcXVpcmUoXCIuL01hdHJpeFwiKTtcclxuY29uc3QgU2hhZGVyXzEgPSByZXF1aXJlKFwiLi9TaGFkZXJcIik7XHJcbmNvbnN0IENhY2hlU2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL0NhY2hlU2V0dGluZ3NcIik7XHJcbmNvbnN0IFVuaWZvcm1Hcm91cF8xID0gcmVxdWlyZShcIi4vVW5pZm9ybUdyb3VwXCIpO1xyXG5jb25zdCBEaXNwbGF5U2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL0Rpc3BsYXlTZXR0aW5nc1wiKTtcclxuY2xhc3MgV2ViR0xTZXR0aW5ncyB7XHJcbiAgICBzdGF0aWMgY3JlYXRlSW5kaWNlc0ZvclF1YWRzKHNpemUpIHtcclxuICAgICAgICB2YXIgdG90YWxJbmRpY2VzID0gc2l6ZSAqIDY7XHJcbiAgICAgICAgdmFyIGluZGljZXMgPSBuZXcgVWludDE2QXJyYXkodG90YWxJbmRpY2VzKTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgaiA9IDA7IGkgPCB0b3RhbEluZGljZXM7IGkgKz0gNiwgaiArPSA0KSB7XHJcbiAgICAgICAgICAgIGluZGljZXNbaSArIDBdID0gaiArIDA7XHJcbiAgICAgICAgICAgIGluZGljZXNbaSArIDFdID0gaiArIDE7XHJcbiAgICAgICAgICAgIGluZGljZXNbaSArIDJdID0gaiArIDI7XHJcbiAgICAgICAgICAgIGluZGljZXNbaSArIDNdID0gaiArIDA7XHJcbiAgICAgICAgICAgIGluZGljZXNbaSArIDRdID0gaiArIDI7XHJcbiAgICAgICAgICAgIGluZGljZXNbaSArIDVdID0gaiArIDM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBpbmRpY2VzO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGNhblVwbG9hZFNhbWVCdWZmZXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZ2VuZXJhdGVNdWx0aVRleHR1cmVTaGFkZXIoZ2wsIG1heFRleHR1cmVzKSB7XHJcbiAgICAgICAgaWYgKCFDYWNoZVNldHRpbmdzXzEuQ2FjaGVTZXR0aW5ncy5wcm9ncmFtQ2FjaGVbbWF4VGV4dHVyZXNdKSB7XHJcbiAgICAgICAgICAgIHZhciBzYW1wbGVWYWx1ZXMgPSBuZXcgSW50MzJBcnJheShtYXhUZXh0dXJlcyk7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWF4VGV4dHVyZXM7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgc2FtcGxlVmFsdWVzW2ldID0gaTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBDYWNoZVNldHRpbmdzXzEuQ2FjaGVTZXR0aW5ncy5kZWZhdWx0R3JvdXBDYWNoZVttYXhUZXh0dXJlc10gPSBVbmlmb3JtR3JvdXBfMS5Vbmlmb3JtR3JvdXAuZnJvbSh7IHVTYW1wbGVyczogc2FtcGxlVmFsdWVzIH0sIHRydWUpO1xyXG4gICAgICAgICAgICB2YXIgZnJhZ21lbnRTcmMgPSBXZWJHTFNldHRpbmdzLmZyYWdUZW1wbGF0ZSQxO1xyXG4gICAgICAgICAgICBmcmFnbWVudFNyYyA9IGZyYWdtZW50U3JjLnJlcGxhY2UoLyVjb3VudCUvZ2ksIG1heFRleHR1cmVzKTtcclxuICAgICAgICAgICAgZnJhZ21lbnRTcmMgPSBmcmFnbWVudFNyYy5yZXBsYWNlKC8lZm9ybG9vcCUvZ2ksIFdlYkdMU2V0dGluZ3MuZ2VuZXJhdGVTYW1wbGVTcmMobWF4VGV4dHVyZXMpKTtcclxuICAgICAgICAgICAgQ2FjaGVTZXR0aW5nc18xLkNhY2hlU2V0dGluZ3MucHJvZ3JhbUNhY2hlW21heFRleHR1cmVzXSA9IG5ldyBQcm9ncmFtXzEuUHJvZ3JhbShXZWJHTFNldHRpbmdzLnZlcnRleCQxLCBmcmFnbWVudFNyYyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciB1bmlmb3JtcyA9IHtcclxuICAgICAgICAgICAgdGludDogbmV3IEZsb2F0MzJBcnJheShbMSwgMSwgMSwgMV0pLFxyXG4gICAgICAgICAgICB0cmFuc2xhdGlvbk1hdHJpeDogbmV3IE1hdHJpeF8xLk1hdHJpeCgpLFxyXG4gICAgICAgICAgICBkZWZhdWx0OiBDYWNoZVNldHRpbmdzXzEuQ2FjaGVTZXR0aW5ncy5kZWZhdWx0R3JvdXBDYWNoZVttYXhUZXh0dXJlc10sXHJcbiAgICAgICAgfTtcclxuICAgICAgICB2YXIgc2hhZGVyID0gbmV3IFNoYWRlcl8xLlNoYWRlcihDYWNoZVNldHRpbmdzXzEuQ2FjaGVTZXR0aW5ncy5wcm9ncmFtQ2FjaGVbbWF4VGV4dHVyZXNdLCB1bmlmb3Jtcyk7XHJcbiAgICAgICAgcmV0dXJuIHNoYWRlcjtcclxuICAgIH1cclxuICAgIHN0YXRpYyBnZW5lcmF0ZVNhbXBsZVNyYyhtYXhUZXh0dXJlcykge1xyXG4gICAgICAgIHZhciBzcmMgPSAnJztcclxuICAgICAgICBzcmMgKz0gJ1xcbic7XHJcbiAgICAgICAgc3JjICs9ICdcXG4nO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWF4VGV4dHVyZXM7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoaSA+IDApIHtcclxuICAgICAgICAgICAgICAgIHNyYyArPSAnXFxuZWxzZSAnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChpIDwgbWF4VGV4dHVyZXMgLSAxKSB7XHJcbiAgICAgICAgICAgICAgICBzcmMgKz0gXCJpZih2VGV4dHVyZUlkIDwgXCIgKyBpICsgXCIuNSlcIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzcmMgKz0gJ1xcbnsnO1xyXG4gICAgICAgICAgICBzcmMgKz0gXCJcXG5cXHRjb2xvciA9IHRleHR1cmUyRCh1U2FtcGxlcnNbXCIgKyBpICsgXCJdLCB2VGV4dHVyZUNvb3JkKTtcIjtcclxuICAgICAgICAgICAgc3JjICs9ICdcXG59JztcclxuICAgICAgICB9XHJcbiAgICAgICAgc3JjICs9ICdcXG4nO1xyXG4gICAgICAgIHNyYyArPSAnXFxuJztcclxuICAgICAgICByZXR1cm4gc3JjO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGNoZWNrTWF4SWZTdGF0ZW1lbnRzSW5TaGFkZXIobWF4SWZzLCBnbCkge1xyXG4gICAgICAgIGlmIChtYXhJZnMgPT09IDApIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHZhbHVlIG9mIGAwYCBwYXNzZWQgdG8gYGNoZWNrTWF4SWZTdGF0ZW1lbnRzSW5TaGFkZXJgJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBzaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIoZ2wuRlJBR01FTlRfU0hBREVSKTtcclxuICAgICAgICB3aGlsZSAodHJ1ZSkgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zdGFudC1jb25kaXRpb25cclxuICAgICAgICAge1xyXG4gICAgICAgICAgICB2YXIgZnJhZ21lbnRTcmMgPSBXZWJHTFNldHRpbmdzLmZyYWdUZW1wbGF0ZS5yZXBsYWNlKC8lZm9ybG9vcCUvZ2ksIFdlYkdMU2V0dGluZ3MuZ2VuZXJhdGVJZlRlc3RTcmMobWF4SWZzKSk7XHJcbiAgICAgICAgICAgIGdsLnNoYWRlclNvdXJjZShzaGFkZXIsIGZyYWdtZW50U3JjKTtcclxuICAgICAgICAgICAgZ2wuY29tcGlsZVNoYWRlcihzaGFkZXIpO1xyXG4gICAgICAgICAgICBpZiAoIWdsLmdldFNoYWRlclBhcmFtZXRlcihzaGFkZXIsIGdsLkNPTVBJTEVfU1RBVFVTKSkge1xyXG4gICAgICAgICAgICAgICAgbWF4SWZzID0gKG1heElmcyAvIDIpIHwgMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIHZhbGlkIVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG1heElmcztcclxuICAgIH1cclxuICAgIHN0YXRpYyBnZW5lcmF0ZUlmVGVzdFNyYyhtYXhJZnMpIHtcclxuICAgICAgICB2YXIgc3JjID0gJyc7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXhJZnM7ICsraSkge1xyXG4gICAgICAgICAgICBpZiAoaSA+IDApIHtcclxuICAgICAgICAgICAgICAgIHNyYyArPSAnXFxuZWxzZSAnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChpIDwgbWF4SWZzIC0gMSkge1xyXG4gICAgICAgICAgICAgICAgc3JjICs9IFwiaWYodGVzdCA9PSBcIiArIGkgKyBcIi4wKXt9XCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHNyYztcclxuICAgIH1cclxuICAgIHN0YXRpYyBtYXhSZWNvbW1lbmRlZFRleHR1cmVzKG1heCkge1xyXG4gICAgICAgIHZhciBhbGxvd01heCA9IHRydWU7XHJcbiAgICAgICAgdmFyIG1hdGNoID0gKG5hdmlnYXRvci51c2VyQWdlbnQpLm1hdGNoKC9PUyAoXFxkKylfKFxcZCspPy8pO1xyXG4gICAgICAgIGlmIChtYXRjaCkge1xyXG4gICAgICAgICAgICB2YXIgbWFqb3JWZXJzaW9uID0gcGFyc2VJbnQobWF0Y2hbMV0sIDEwKTtcclxuICAgICAgICAgICAgaWYgKG1ham9yVmVyc2lvbiA+PSAxMSkge1xyXG4gICAgICAgICAgICAgICAgYWxsb3dNYXggPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBtYXRjaCQxID0gKG5hdmlnYXRvci51c2VyQWdlbnQpLm1hdGNoKC9BbmRyb2lkXFxzKFswLTkuXSopLyk7XHJcbiAgICAgICAgaWYgKG1hdGNoJDEpIHtcclxuICAgICAgICAgICAgdmFyIG1ham9yVmVyc2lvbiQxID0gcGFyc2VJbnQobWF0Y2gkMVsxXSwgMTApO1xyXG4gICAgICAgICAgICBpZiAobWFqb3JWZXJzaW9uJDEgPj0gNykge1xyXG4gICAgICAgICAgICAgICAgYWxsb3dNYXggPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhbGxvd01heCA/IG1heCA6IDQ7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgc2V0UHJlY2lzaW9uKHNyYywgcHJlY2lzaW9uKSB7XHJcbiAgICAgICAgaWYgKHNyYy5zdWJzdHJpbmcoMCwgOSkgIT09ICdwcmVjaXNpb24nKSAvLyAmJiBzcmMuc3Vic3RyaW5nKDAsIDEpICE9PSAnIycpXHJcbiAgICAgICAgIHtcclxuICAgICAgICAgICAgcmV0dXJuIChcInByZWNpc2lvbiBcIiArIHByZWNpc2lvbiArIFwiIGZsb2F0O1xcblwiICsgc3JjKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHNyYztcclxuICAgIH1cclxuICAgIHN0YXRpYyBnZXRUZXN0Q29udGV4dCgpIHtcclxuICAgICAgICBpZiAoIVdlYkdMU2V0dGluZ3MuY29udGV4dCkge1xyXG4gICAgICAgICAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XHJcbiAgICAgICAgICAgIHZhciBnbDtcclxuICAgICAgICAgICAgaWYgKERpc3BsYXlTZXR0aW5nc18xLkRpc3BsYXlTZXR0aW5ncy5QUkVGRVJfRU5WID49IERpc3BsYXlTZXR0aW5nc18xLkRpc3BsYXlTZXR0aW5ncy5FTlYuV0VCR0wyKSB7XHJcbiAgICAgICAgICAgICAgICBnbCA9IGNhbnZhcy5nZXRDb250ZXh0KCd3ZWJnbDInLCB7fSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFnbCkge1xyXG4gICAgICAgICAgICAgICAgZ2wgPSBjYW52YXMuZ2V0Q29udGV4dCgnd2ViZ2wnLCB7fSlcclxuICAgICAgICAgICAgICAgICAgICB8fCBjYW52YXMuZ2V0Q29udGV4dCgnZXhwZXJpbWVudGFsLXdlYmdsJywge30pO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFnbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGZhaWwsIG5vdCBhYmxlIHRvIGdldCBhIGNvbnRleHRcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IFdlYkdMLiBUcnkgdXNpbmcgdGhlIGNhbnZhcyByZW5kZXJlcicpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZm9yIHNoYWRlciB0ZXN0aW5nLi5cclxuICAgICAgICAgICAgICAgICAgICBnbC5nZXRFeHRlbnNpb24oJ1dFQkdMX2RyYXdfYnVmZmVycycpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFdlYkdMU2V0dGluZ3MuY29udGV4dCA9IGdsO1xyXG4gICAgICAgICAgICByZXR1cm4gZ2w7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBXZWJHTFNldHRpbmdzLmNvbnRleHQ7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZGVmYXVsdFZhbHVlKHR5cGUsIHNpemUpIHtcclxuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcclxuICAgICAgICAgICAgY2FzZSAnZmxvYXQnOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgICAgIGNhc2UgJ3ZlYzInOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoMiAqIHNpemUpO1xyXG4gICAgICAgICAgICBjYXNlICd2ZWMzJzpcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRmxvYXQzMkFycmF5KDMgKiBzaXplKTtcclxuICAgICAgICAgICAgY2FzZSAndmVjNCc6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEZsb2F0MzJBcnJheSg0ICogc2l6ZSk7XHJcbiAgICAgICAgICAgIGNhc2UgJ2ludCc6XHJcbiAgICAgICAgICAgIGNhc2UgJ3NhbXBsZXIyRCc6XHJcbiAgICAgICAgICAgIGNhc2UgJ3NhbXBsZXIyREFycmF5JzpcclxuICAgICAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgICAgICBjYXNlICdpdmVjMic6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEludDMyQXJyYXkoMiAqIHNpemUpO1xyXG4gICAgICAgICAgICBjYXNlICdpdmVjMyc6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEludDMyQXJyYXkoMyAqIHNpemUpO1xyXG4gICAgICAgICAgICBjYXNlICdpdmVjNCc6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEludDMyQXJyYXkoNCAqIHNpemUpO1xyXG4gICAgICAgICAgICBjYXNlICdib29sJzpcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgY2FzZSAnYnZlYzInOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFdlYkdMU2V0dGluZ3MuYm9vbGVhbkFycmF5KDIgKiBzaXplKTtcclxuICAgICAgICAgICAgY2FzZSAnYnZlYzMnOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFdlYkdMU2V0dGluZ3MuYm9vbGVhbkFycmF5KDMgKiBzaXplKTtcclxuICAgICAgICAgICAgY2FzZSAnYnZlYzQnOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFdlYkdMU2V0dGluZ3MuYm9vbGVhbkFycmF5KDQgKiBzaXplKTtcclxuICAgICAgICAgICAgY2FzZSAnbWF0Mic6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEZsb2F0MzJBcnJheShbMSwgMCxcclxuICAgICAgICAgICAgICAgICAgICAwLCAxXSk7XHJcbiAgICAgICAgICAgIGNhc2UgJ21hdDMnOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoWzEsIDAsIDAsXHJcbiAgICAgICAgICAgICAgICAgICAgMCwgMSwgMCxcclxuICAgICAgICAgICAgICAgICAgICAwLCAwLCAxXSk7XHJcbiAgICAgICAgICAgIGNhc2UgJ21hdDQnOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoWzEsIDAsIDAsIDAsXHJcbiAgICAgICAgICAgICAgICAgICAgMCwgMSwgMCwgMCxcclxuICAgICAgICAgICAgICAgICAgICAwLCAwLCAxLCAwLFxyXG4gICAgICAgICAgICAgICAgICAgIDAsIDAsIDAsIDFdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgYm9vbGVhbkFycmF5KHNpemUpIHtcclxuICAgICAgICB2YXIgYXJyYXkgPSBuZXcgQXJyYXkoc2l6ZSk7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBhcnJheVtpXSA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYXJyYXk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgbWFwVHlwZShnbCwgdHlwZSkge1xyXG4gICAgICAgIGlmICghV2ViR0xTZXR0aW5ncy5HTF9UQUJMRSkge1xyXG4gICAgICAgICAgICB2YXIgdHlwZU5hbWVzID0gT2JqZWN0LmtleXMoV2ViR0xTZXR0aW5ncy5HTF9UT19HTFNMX1RZUEVTKTtcclxuICAgICAgICAgICAgV2ViR0xTZXR0aW5ncy5HTF9UQUJMRSA9IHt9O1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHR5cGVOYW1lcy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHRuID0gdHlwZU5hbWVzW2ldO1xyXG4gICAgICAgICAgICAgICAgV2ViR0xTZXR0aW5ncy5HTF9UQUJMRVtnbFt0bl1dID0gV2ViR0xTZXR0aW5ncy5HTF9UT19HTFNMX1RZUEVTW3RuXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gV2ViR0xTZXR0aW5ncy5HTF9UQUJMRVt0eXBlXTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBtYXBTaXplKHR5cGUpIHtcclxuICAgICAgICByZXR1cm4gV2ViR0xTZXR0aW5ncy5HTFNMX1RPX1NJWkVbdHlwZV07XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZ2VuZXJhdGVVbmlmb3Jtc1N5bmMoZ3JvdXAsIHVuaWZvcm1EYXRhKSB7XHJcbiAgICAgICAgdmFyIHRleHR1cmVDb3VudCA9IDA7XHJcbiAgICAgICAgdmFyIGZ1bmMgPSBcInZhciB2ID0gbnVsbDtcXG4gICAgdmFyIGN2ID0gbnVsbFxcbiAgICB2YXIgZ2wgPSByZW5kZXJlci5nbFwiO1xyXG4gICAgICAgIGZvciAodmFyIGkgaW4gZ3JvdXAudW5pZm9ybXMpIHtcclxuICAgICAgICAgICAgdmFyIGRhdGEgPSB1bmlmb3JtRGF0YVtpXTtcclxuICAgICAgICAgICAgaWYgKCFkYXRhKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZ3JvdXAudW5pZm9ybXNbaV0uZ3JvdXApIHtcclxuICAgICAgICAgICAgICAgICAgICBmdW5jICs9IFwiXFxuICAgICAgICAgICAgICAgICAgICByZW5kZXJlci5zaGFkZXIuc3luY1VuaWZvcm1Hcm91cCh1di5cIiArIGkgKyBcIik7XFxuICAgICAgICAgICAgICAgIFwiO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gVE9ETyAmJiB1bmlmb3JtRGF0YVtpXS52YWx1ZSAhPT0gMCA8LS0gZG8gd2Ugc3RpbGwgbmVlZCB0aGlzP1xyXG4gICAgICAgICAgICBpZiAoZGF0YS50eXBlID09PSAnZmxvYXQnICYmIGRhdGEuc2l6ZSA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgZnVuYyArPSBcIlxcbiAgICAgICAgICAgIGlmKHV2LlwiICsgaSArIFwiICE9PSB1ZC5cIiArIGkgKyBcIi52YWx1ZSlcXG4gICAgICAgICAgICB7XFxuICAgICAgICAgICAgICAgIHVkLlwiICsgaSArIFwiLnZhbHVlID0gdXYuXCIgKyBpICsgXCJcXG4gICAgICAgICAgICAgICAgZ2wudW5pZm9ybTFmKHVkLlwiICsgaSArIFwiLmxvY2F0aW9uLCB1di5cIiArIGkgKyBcIilcXG4gICAgICAgICAgICB9XFxuXCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xyXG4gICAgICAgICAgICBlbHNlIGlmICgoZGF0YS50eXBlID09PSAnc2FtcGxlcjJEJyB8fCBkYXRhLnR5cGUgPT09ICdzYW1wbGVyQ3ViZScgfHwgZGF0YS50eXBlID09PSAnc2FtcGxlcjJEQXJyYXknKSAmJiBkYXRhLnNpemUgPT09IDEgJiYgIWRhdGEuaXNBcnJheSkgXHJcbiAgICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4gKi9cclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgZnVuYyArPSBcIlxcbiAgICAgICAgICAgIHJlbmRlcmVyLnRleHR1cmUuYmluZCh1di5cIiArIGkgKyBcIiwgXCIgKyB0ZXh0dXJlQ291bnQgKyBcIik7XFxuXFxuICAgICAgICAgICAgaWYodWQuXCIgKyBpICsgXCIudmFsdWUgIT09IFwiICsgdGV4dHVyZUNvdW50ICsgXCIpXFxuICAgICAgICAgICAge1xcbiAgICAgICAgICAgICAgICB1ZC5cIiArIGkgKyBcIi52YWx1ZSA9IFwiICsgdGV4dHVyZUNvdW50ICsgXCI7XFxuICAgICAgICAgICAgICAgIGdsLnVuaWZvcm0xaSh1ZC5cIiArIGkgKyBcIi5sb2NhdGlvbiwgXCIgKyB0ZXh0dXJlQ291bnQgKyBcIik7XFxuOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG1heC1sZW5cXG4gICAgICAgICAgICB9XFxuXCI7XHJcbiAgICAgICAgICAgICAgICB0ZXh0dXJlQ291bnQrKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChkYXRhLnR5cGUgPT09ICdtYXQzJyAmJiBkYXRhLnNpemUgPT09IDEpIHtcclxuICAgICAgICAgICAgICAgIGlmIChncm91cC51bmlmb3Jtc1tpXS5hICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIGFuZCBzb21lIHNtYXJ0IGNhY2hpbmcgZGlydHkgaWRzIGhlcmUhXHJcbiAgICAgICAgICAgICAgICAgICAgZnVuYyArPSBcIlxcbiAgICAgICAgICAgICAgICBnbC51bmlmb3JtTWF0cml4M2Z2KHVkLlwiICsgaSArIFwiLmxvY2F0aW9uLCBmYWxzZSwgdXYuXCIgKyBpICsgXCIudG9BcnJheSh0cnVlKSk7XFxuICAgICAgICAgICAgICAgIFxcblwiO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZnVuYyArPSBcIlxcbiAgICAgICAgICAgICAgICBnbC51bmlmb3JtTWF0cml4M2Z2KHVkLlwiICsgaSArIFwiLmxvY2F0aW9uLCBmYWxzZSwgdXYuXCIgKyBpICsgXCIpO1xcbiAgICAgICAgICAgICAgICBcXG5cIjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChkYXRhLnR5cGUgPT09ICd2ZWMyJyAmJiBkYXRhLnNpemUgPT09IDEpIHtcclxuICAgICAgICAgICAgICAgIC8vIFRPRE8gLSBkbyB3ZSBuZWVkIGJvdGggaGVyZT9cclxuICAgICAgICAgICAgICAgIC8vIG1heWJlIHdlIGNhbiBnZXQgYXdheSB3aXRoIG9ubHkgdXNpbmcgcG9pbnRzP1xyXG4gICAgICAgICAgICAgICAgaWYgKGdyb3VwLnVuaWZvcm1zW2ldLnggIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZ1bmMgKz0gXCJcXG4gICAgICAgICAgICAgICAgY3YgPSB1ZC5cIiArIGkgKyBcIi52YWx1ZTtcXG4gICAgICAgICAgICAgICAgdiA9IHV2LlwiICsgaSArIFwiO1xcblxcbiAgICAgICAgICAgICAgICBpZihjdlswXSAhPT0gdi54IHx8IGN2WzFdICE9PSB2LnkpXFxuICAgICAgICAgICAgICAgIHtcXG4gICAgICAgICAgICAgICAgICAgIGN2WzBdID0gdi54O1xcbiAgICAgICAgICAgICAgICAgICAgY3ZbMV0gPSB2Lnk7XFxuICAgICAgICAgICAgICAgICAgICBnbC51bmlmb3JtMmYodWQuXCIgKyBpICsgXCIubG9jYXRpb24sIHYueCwgdi55KTtcXG4gICAgICAgICAgICAgICAgfVxcblwiO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZnVuYyArPSBcIlxcbiAgICAgICAgICAgICAgICBjdiA9IHVkLlwiICsgaSArIFwiLnZhbHVlO1xcbiAgICAgICAgICAgICAgICB2ID0gdXYuXCIgKyBpICsgXCI7XFxuXFxuICAgICAgICAgICAgICAgIGlmKGN2WzBdICE9PSB2WzBdIHx8IGN2WzFdICE9PSB2WzFdKVxcbiAgICAgICAgICAgICAgICB7XFxuICAgICAgICAgICAgICAgICAgICBjdlswXSA9IHZbMF07XFxuICAgICAgICAgICAgICAgICAgICBjdlsxXSA9IHZbMV07XFxuICAgICAgICAgICAgICAgICAgICBnbC51bmlmb3JtMmYodWQuXCIgKyBpICsgXCIubG9jYXRpb24sIHZbMF0sIHZbMV0pO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIFxcblwiO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGRhdGEudHlwZSA9PT0gJ3ZlYzQnICYmIGRhdGEuc2l6ZSA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgLy8gVE9ETyAtIGRvIHdlIG5lZWQgYm90aCBoZXJlP1xyXG4gICAgICAgICAgICAgICAgLy8gbWF5YmUgd2UgY2FuIGdldCBhd2F5IHdpdGggb25seSB1c2luZyBwb2ludHM/XHJcbiAgICAgICAgICAgICAgICBpZiAoZ3JvdXAudW5pZm9ybXNbaV0ud2lkdGggIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZ1bmMgKz0gXCJcXG4gICAgICAgICAgICAgICAgY3YgPSB1ZC5cIiArIGkgKyBcIi52YWx1ZTtcXG4gICAgICAgICAgICAgICAgdiA9IHV2LlwiICsgaSArIFwiO1xcblxcbiAgICAgICAgICAgICAgICBpZihjdlswXSAhPT0gdi54IHx8IGN2WzFdICE9PSB2LnkgfHwgY3ZbMl0gIT09IHYud2lkdGggfHwgY3ZbM10gIT09IHYuaGVpZ2h0KVxcbiAgICAgICAgICAgICAgICB7XFxuICAgICAgICAgICAgICAgICAgICBjdlswXSA9IHYueDtcXG4gICAgICAgICAgICAgICAgICAgIGN2WzFdID0gdi55O1xcbiAgICAgICAgICAgICAgICAgICAgY3ZbMl0gPSB2LndpZHRoO1xcbiAgICAgICAgICAgICAgICAgICAgY3ZbM10gPSB2LmhlaWdodDtcXG4gICAgICAgICAgICAgICAgICAgIGdsLnVuaWZvcm00Zih1ZC5cIiArIGkgKyBcIi5sb2NhdGlvbiwgdi54LCB2LnksIHYud2lkdGgsIHYuaGVpZ2h0KVxcbiAgICAgICAgICAgICAgICB9XFxuXCI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBmdW5jICs9IFwiXFxuICAgICAgICAgICAgICAgIGN2ID0gdWQuXCIgKyBpICsgXCIudmFsdWU7XFxuICAgICAgICAgICAgICAgIHYgPSB1di5cIiArIGkgKyBcIjtcXG5cXG4gICAgICAgICAgICAgICAgaWYoY3ZbMF0gIT09IHZbMF0gfHwgY3ZbMV0gIT09IHZbMV0gfHwgY3ZbMl0gIT09IHZbMl0gfHwgY3ZbM10gIT09IHZbM10pXFxuICAgICAgICAgICAgICAgIHtcXG4gICAgICAgICAgICAgICAgICAgIGN2WzBdID0gdlswXTtcXG4gICAgICAgICAgICAgICAgICAgIGN2WzFdID0gdlsxXTtcXG4gICAgICAgICAgICAgICAgICAgIGN2WzJdID0gdlsyXTtcXG4gICAgICAgICAgICAgICAgICAgIGN2WzNdID0gdlszXTtcXG5cXG4gICAgICAgICAgICAgICAgICAgIGdsLnVuaWZvcm00Zih1ZC5cIiArIGkgKyBcIi5sb2NhdGlvbiwgdlswXSwgdlsxXSwgdlsyXSwgdlszXSlcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBcXG5cIjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZhciB0ZW1wbGF0ZVR5cGUgPSAoZGF0YS5zaXplID09PSAxKSA/IFdlYkdMU2V0dGluZ3MuR0xTTF9UT19TSU5HTEVfU0VUVEVSU19DQUNIRUQgOiBXZWJHTFNldHRpbmdzLkdMU0xfVE9fQVJSQVlfU0VUVEVSUztcclxuICAgICAgICAgICAgICAgIHZhciB0ZW1wbGF0ZSA9IHRlbXBsYXRlVHlwZVtkYXRhLnR5cGVdLnJlcGxhY2UoJ2xvY2F0aW9uJywgKFwidWQuXCIgKyBpICsgXCIubG9jYXRpb25cIikpO1xyXG4gICAgICAgICAgICAgICAgZnVuYyArPSBcIlxcbiAgICAgICAgICAgIGN2ID0gdWQuXCIgKyBpICsgXCIudmFsdWU7XFxuICAgICAgICAgICAgdiA9IHV2LlwiICsgaSArIFwiO1xcbiAgICAgICAgICAgIFwiICsgdGVtcGxhdGUgKyBcIjtcXG5cIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IEZ1bmN0aW9uKCd1ZCcsICd1dicsICdyZW5kZXJlcicsIGZ1bmMpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ldy1mdW5jXHJcbiAgICB9XHJcbn1cclxuV2ViR0xTZXR0aW5ncy5VUExPQURTX1BFUl9GUkFNRSA9IDQ7XHJcbldlYkdMU2V0dGluZ3MuR0xTTF9UT19BUlJBWV9TRVRURVJTID0ge1xyXG4gICAgZmxvYXQ6IFwiZ2wudW5pZm9ybTFmdihsb2NhdGlvbiwgdilcIixcclxuICAgIHZlYzI6IFwiZ2wudW5pZm9ybTJmdihsb2NhdGlvbiwgdilcIixcclxuICAgIHZlYzM6IFwiZ2wudW5pZm9ybTNmdihsb2NhdGlvbiwgdilcIixcclxuICAgIHZlYzQ6ICdnbC51bmlmb3JtNGZ2KGxvY2F0aW9uLCB2KScsXHJcbiAgICBtYXQ0OiAnZ2wudW5pZm9ybU1hdHJpeDRmdihsb2NhdGlvbiwgZmFsc2UsIHYpJyxcclxuICAgIG1hdDM6ICdnbC51bmlmb3JtTWF0cml4M2Z2KGxvY2F0aW9uLCBmYWxzZSwgdiknLFxyXG4gICAgbWF0MjogJ2dsLnVuaWZvcm1NYXRyaXgyZnYobG9jYXRpb24sIGZhbHNlLCB2KScsXHJcbiAgICBpbnQ6ICdnbC51bmlmb3JtMWl2KGxvY2F0aW9uLCB2KScsXHJcbiAgICBpdmVjMjogJ2dsLnVuaWZvcm0yaXYobG9jYXRpb24sIHYpJyxcclxuICAgIGl2ZWMzOiAnZ2wudW5pZm9ybTNpdihsb2NhdGlvbiwgdiknLFxyXG4gICAgaXZlYzQ6ICdnbC51bmlmb3JtNGl2KGxvY2F0aW9uLCB2KScsXHJcbiAgICBib29sOiAnZ2wudW5pZm9ybTFpdihsb2NhdGlvbiwgdiknLFxyXG4gICAgYnZlYzI6ICdnbC51bmlmb3JtMml2KGxvY2F0aW9uLCB2KScsXHJcbiAgICBidmVjMzogJ2dsLnVuaWZvcm0zaXYobG9jYXRpb24sIHYpJyxcclxuICAgIGJ2ZWM0OiAnZ2wudW5pZm9ybTRpdihsb2NhdGlvbiwgdiknLFxyXG4gICAgc2FtcGxlcjJEOiAnZ2wudW5pZm9ybTFpdihsb2NhdGlvbiwgdiknLFxyXG4gICAgc2FtcGxlckN1YmU6ICdnbC51bmlmb3JtMWl2KGxvY2F0aW9uLCB2KScsXHJcbiAgICBzYW1wbGVyMkRBcnJheTogJ2dsLnVuaWZvcm0xaXYobG9jYXRpb24sIHYpJyxcclxufTtcclxuV2ViR0xTZXR0aW5ncy5HTFNMX1RPX1NJTkdMRV9TRVRURVJTX0NBQ0hFRCA9IHtcclxuICAgIGZsb2F0OiBcIlxcbiAgICBpZihjdiAhPT0gdilcXG4gICAge1xcbiAgICAgICAgY3YudiA9IHY7XFxuICAgICAgICBnbC51bmlmb3JtMWYobG9jYXRpb24sIHYpXFxuICAgIH1cIixcclxuICAgIHZlYzI6IFwiXFxuICAgIGlmKGN2WzBdICE9PSB2WzBdIHx8IGN2WzFdICE9PSB2WzFdKVxcbiAgICB7XFxuICAgICAgICBjdlswXSA9IHZbMF07XFxuICAgICAgICBjdlsxXSA9IHZbMV07XFxuICAgICAgICBnbC51bmlmb3JtMmYobG9jYXRpb24sIHZbMF0sIHZbMV0pXFxuICAgIH1cIixcclxuICAgIHZlYzM6IFwiXFxuICAgIGlmKGN2WzBdICE9PSB2WzBdIHx8IGN2WzFdICE9PSB2WzFdIHx8IGN2WzJdICE9PSB2WzJdKVxcbiAgICB7XFxuICAgICAgICBjdlswXSA9IHZbMF07XFxuICAgICAgICBjdlsxXSA9IHZbMV07XFxuICAgICAgICBjdlsyXSA9IHZbMl07XFxuXFxuICAgICAgICBnbC51bmlmb3JtM2YobG9jYXRpb24sIHZbMF0sIHZbMV0sIHZbMl0pXFxuICAgIH1cIixcclxuICAgIHZlYzQ6ICdnbC51bmlmb3JtNGYobG9jYXRpb24sIHZbMF0sIHZbMV0sIHZbMl0sIHZbM10pJyxcclxuICAgIGludDogJ2dsLnVuaWZvcm0xaShsb2NhdGlvbiwgdiknLFxyXG4gICAgaXZlYzI6ICdnbC51bmlmb3JtMmkobG9jYXRpb24sIHZbMF0sIHZbMV0pJyxcclxuICAgIGl2ZWMzOiAnZ2wudW5pZm9ybTNpKGxvY2F0aW9uLCB2WzBdLCB2WzFdLCB2WzJdKScsXHJcbiAgICBpdmVjNDogJ2dsLnVuaWZvcm00aShsb2NhdGlvbiwgdlswXSwgdlsxXSwgdlsyXSwgdlszXSknLFxyXG4gICAgYm9vbDogJ2dsLnVuaWZvcm0xaShsb2NhdGlvbiwgdiknLFxyXG4gICAgYnZlYzI6ICdnbC51bmlmb3JtMmkobG9jYXRpb24sIHZbMF0sIHZbMV0pJyxcclxuICAgIGJ2ZWMzOiAnZ2wudW5pZm9ybTNpKGxvY2F0aW9uLCB2WzBdLCB2WzFdLCB2WzJdKScsXHJcbiAgICBidmVjNDogJ2dsLnVuaWZvcm00aShsb2NhdGlvbiwgdlswXSwgdlsxXSwgdlsyXSwgdlszXSknLFxyXG4gICAgbWF0MjogJ2dsLnVuaWZvcm1NYXRyaXgyZnYobG9jYXRpb24sIGZhbHNlLCB2KScsXHJcbiAgICBtYXQzOiAnZ2wudW5pZm9ybU1hdHJpeDNmdihsb2NhdGlvbiwgZmFsc2UsIHYpJyxcclxuICAgIG1hdDQ6ICdnbC51bmlmb3JtTWF0cml4NGZ2KGxvY2F0aW9uLCBmYWxzZSwgdiknLFxyXG4gICAgc2FtcGxlcjJEOiAnZ2wudW5pZm9ybTFpKGxvY2F0aW9uLCB2KScsXHJcbiAgICBzYW1wbGVyQ3ViZTogJ2dsLnVuaWZvcm0xaShsb2NhdGlvbiwgdiknLFxyXG4gICAgc2FtcGxlcjJEQXJyYXk6ICdnbC51bmlmb3JtMWkobG9jYXRpb24sIHYpJyxcclxufTtcclxuV2ViR0xTZXR0aW5ncy5HTFNMX1RPX1NJWkUgPSB7XHJcbiAgICBmbG9hdDogMSxcclxuICAgIHZlYzI6IDIsXHJcbiAgICB2ZWMzOiAzLFxyXG4gICAgdmVjNDogNCxcclxuICAgIGludDogMSxcclxuICAgIGl2ZWMyOiAyLFxyXG4gICAgaXZlYzM6IDMsXHJcbiAgICBpdmVjNDogNCxcclxuICAgIGJvb2w6IDEsXHJcbiAgICBidmVjMjogMixcclxuICAgIGJ2ZWMzOiAzLFxyXG4gICAgYnZlYzQ6IDQsXHJcbiAgICBtYXQyOiA0LFxyXG4gICAgbWF0MzogOSxcclxuICAgIG1hdDQ6IDE2LFxyXG4gICAgc2FtcGxlcjJEOiAxLFxyXG59O1xyXG5XZWJHTFNldHRpbmdzLkdMX1RPX0dMU0xfVFlQRVMgPSB7XHJcbiAgICBGTE9BVDogJ2Zsb2F0JyxcclxuICAgIEZMT0FUX1ZFQzI6ICd2ZWMyJyxcclxuICAgIEZMT0FUX1ZFQzM6ICd2ZWMzJyxcclxuICAgIEZMT0FUX1ZFQzQ6ICd2ZWM0JyxcclxuICAgIElOVDogJ2ludCcsXHJcbiAgICBJTlRfVkVDMjogJ2l2ZWMyJyxcclxuICAgIElOVF9WRUMzOiAnaXZlYzMnLFxyXG4gICAgSU5UX1ZFQzQ6ICdpdmVjNCcsXHJcbiAgICBCT09MOiAnYm9vbCcsXHJcbiAgICBCT09MX1ZFQzI6ICdidmVjMicsXHJcbiAgICBCT09MX1ZFQzM6ICdidmVjMycsXHJcbiAgICBCT09MX1ZFQzQ6ICdidmVjNCcsXHJcbiAgICBGTE9BVF9NQVQyOiAnbWF0MicsXHJcbiAgICBGTE9BVF9NQVQzOiAnbWF0MycsXHJcbiAgICBGTE9BVF9NQVQ0OiAnbWF0NCcsXHJcbiAgICBTQU1QTEVSXzJEOiAnc2FtcGxlcjJEJyxcclxuICAgIFNBTVBMRVJfQ1VCRTogJ3NhbXBsZXJDdWJlJyxcclxuICAgIFNBTVBMRVJfMkRfQVJSQVk6ICdzYW1wbGVyMkRBcnJheScsXHJcbn07XHJcbldlYkdMU2V0dGluZ3MuR0xfVEFCTEUgPSBudWxsO1xyXG5XZWJHTFNldHRpbmdzLmNvbnRleHQgPSBudWxsO1xyXG5XZWJHTFNldHRpbmdzLlBSRUNJU0lPTl9GUkFHTUVOVCA9ICdoaWdocCc7XHJcbldlYkdMU2V0dGluZ3MuUFJFQ0lTSU9OX1ZFUlRFWCA9ICdoaWdocCc7XHJcbldlYkdMU2V0dGluZ3MuZnJhZ1RlbXBsYXRlID0gW1xyXG4gICAgJ3ByZWNpc2lvbiBtZWRpdW1wIGZsb2F0OycsXHJcbiAgICAndm9pZCBtYWluKHZvaWQpeycsXHJcbiAgICAnZmxvYXQgdGVzdCA9IDAuMTsnLFxyXG4gICAgJyVmb3Jsb29wJScsXHJcbiAgICAnZ2xfRnJhZ0NvbG9yID0gdmVjNCgwLjApOycsXHJcbiAgICAnfSdcclxuXS5qb2luKCdcXG4nKTtcclxuV2ViR0xTZXR0aW5ncy52ZXJ0ZXgkMSA9IFwicHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcclxcbmF0dHJpYnV0ZSB2ZWMyIGFWZXJ0ZXhQb3NpdGlvbjtcXHJcXG5hdHRyaWJ1dGUgdmVjMiBhVGV4dHVyZUNvb3JkO1xcclxcbmF0dHJpYnV0ZSB2ZWM0IGFDb2xvcjtcXHJcXG5hdHRyaWJ1dGUgZmxvYXQgYVRleHR1cmVJZDtcXHJcXG5cXHJcXG51bmlmb3JtIG1hdDMgcHJvamVjdGlvbk1hdHJpeDtcXHJcXG51bmlmb3JtIG1hdDMgdHJhbnNsYXRpb25NYXRyaXg7XFxyXFxudW5pZm9ybSB2ZWM0IHRpbnQ7XFxyXFxuXFxyXFxudmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XFxyXFxudmFyeWluZyB2ZWM0IHZDb2xvcjtcXHJcXG52YXJ5aW5nIGZsb2F0IHZUZXh0dXJlSWQ7XFxyXFxuXFxyXFxudm9pZCBtYWluKHZvaWQpe1xcclxcbiAgICBnbF9Qb3NpdGlvbiA9IHZlYzQoKHByb2plY3Rpb25NYXRyaXggKiB0cmFuc2xhdGlvbk1hdHJpeCAqIHZlYzMoYVZlcnRleFBvc2l0aW9uLCAxLjApKS54eSwgMC4wLCAxLjApO1xcclxcblxcclxcbiAgICB2VGV4dHVyZUNvb3JkID0gYVRleHR1cmVDb29yZDtcXHJcXG4gICAgdlRleHR1cmVJZCA9IGFUZXh0dXJlSWQ7XFxyXFxuICAgIHZDb2xvciA9IGFDb2xvciAqIHRpbnQ7XFxyXFxufVxcclxcblwiO1xyXG5XZWJHTFNldHRpbmdzLmZyYWdUZW1wbGF0ZSQxID0gW1xyXG4gICAgJ3ZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkOycsXHJcbiAgICAndmFyeWluZyB2ZWM0IHZDb2xvcjsnLFxyXG4gICAgJ3ZhcnlpbmcgZmxvYXQgdlRleHR1cmVJZDsnLFxyXG4gICAgJ3VuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyc1slY291bnQlXTsnLFxyXG4gICAgJ3ZvaWQgbWFpbih2b2lkKXsnLFxyXG4gICAgJ3ZlYzQgY29sb3I7JyxcclxuICAgICclZm9ybG9vcCUnLFxyXG4gICAgJ2dsX0ZyYWdDb2xvciA9IGNvbG9yICogdkNvbG9yOycsXHJcbiAgICAnfSdcclxuXS5qb2luKCdcXG4nKTtcclxuV2ViR0xTZXR0aW5ncy5NSVBNQVBfVEVYVFVSRVMgPSAxO1xyXG5XZWJHTFNldHRpbmdzLldSQVBfTU9ERSA9IDMzMDcxO1xyXG5XZWJHTFNldHRpbmdzLlRBUkdFVFMgPSB7XHJcbiAgICBURVhUVVJFXzJEOiAzNTUzLFxyXG4gICAgVEVYVFVSRV9DVUJFX01BUDogMzQwNjcsXHJcbiAgICBURVhUVVJFXzJEX0FSUkFZOiAzNTg2NixcclxuICAgIFRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWDogMzQwNjksXHJcbiAgICBURVhUVVJFX0NVQkVfTUFQX05FR0FUSVZFX1g6IDM0MDcwLFxyXG4gICAgVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9ZOiAzNDA3MSxcclxuICAgIFRFWFRVUkVfQ1VCRV9NQVBfTkVHQVRJVkVfWTogMzQwNzIsXHJcbiAgICBURVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1o6IDM0MDczLFxyXG4gICAgVEVYVFVSRV9DVUJFX01BUF9ORUdBVElWRV9aOiAzNDA3NCxcclxufTtcclxuV2ViR0xTZXR0aW5ncy5GT1JNQVRTID0ge1xyXG4gICAgUkdCQTogNjQwOCxcclxuICAgIFJHQjogNjQwNyxcclxuICAgIEFMUEhBOiA2NDA2LFxyXG4gICAgTFVNSU5BTkNFOiA2NDA5LFxyXG4gICAgTFVNSU5BTkNFX0FMUEhBOiA2NDEwLFxyXG4gICAgREVQVEhfQ09NUE9ORU5UOiA2NDAyLFxyXG4gICAgREVQVEhfU1RFTkNJTDogMzQwNDEsXHJcbn07XHJcbldlYkdMU2V0dGluZ3MuVFlQRVMgPSB7XHJcbiAgICBVTlNJR05FRF9CWVRFOiA1MTIxLFxyXG4gICAgVU5TSUdORURfU0hPUlQ6IDUxMjMsXHJcbiAgICBVTlNJR05FRF9TSE9SVF81XzZfNTogMzM2MzUsXHJcbiAgICBVTlNJR05FRF9TSE9SVF80XzRfNF80OiAzMjgxOSxcclxuICAgIFVOU0lHTkVEX1NIT1JUXzVfNV81XzE6IDMyODIwLFxyXG4gICAgRkxPQVQ6IDUxMjYsXHJcbiAgICBIQUxGX0ZMT0FUOiAzNjE5MyxcclxufTtcclxuV2ViR0xTZXR0aW5ncy5NSVBNQVBfTU9ERVMgPSB7XHJcbiAgICBPRkY6IDAsXHJcbiAgICBQT1cyOiAxLFxyXG4gICAgT046IDIsXHJcbn07XHJcbldlYkdMU2V0dGluZ3MuU0NBTEVfTU9ERVMgPSB7XHJcbiAgICBMSU5FQVI6IDEsXHJcbiAgICBORUFSRVNUOiAwLFxyXG59O1xyXG5XZWJHTFNldHRpbmdzLldSQVBfTU9ERVMgPSB7XHJcbiAgICBDTEFNUDogMzMwNzEsXHJcbiAgICBSRVBFQVQ6IDEwNDk3LFxyXG4gICAgTUlSUk9SRURfUkVQRUFUOiAzMzY0OCxcclxufTtcclxuV2ViR0xTZXR0aW5ncy5kZWZhdWx0QnVmZmVyT3B0aW9ucyA9IHtcclxuICAgIHNjYWxlTW9kZTogV2ViR0xTZXR0aW5ncy5TQ0FMRV9NT0RFUy5ORUFSRVNULFxyXG4gICAgZm9ybWF0OiBXZWJHTFNldHRpbmdzLkZPUk1BVFMuUkdCQSxcclxuICAgIHByZW11bHRpcGx5QWxwaGE6IGZhbHNlLFxyXG59O1xyXG5XZWJHTFNldHRpbmdzLkNBTl9VUExPQURfU0FNRV9CVUZGRVIgPSBXZWJHTFNldHRpbmdzLmNhblVwbG9hZFNhbWVCdWZmZXIoKTtcclxuV2ViR0xTZXR0aW5ncy5TUFJJVEVfTUFYX1RFWFRVUkVTID0gV2ViR0xTZXR0aW5ncy5tYXhSZWNvbW1lbmRlZFRleHR1cmVzKDMyKTtcclxuZXhwb3J0cy5XZWJHTFNldHRpbmdzID0gV2ViR0xTZXR0aW5ncztcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY2xhc3Mgc2V0dGluZ3Mge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDb252ZXJ0cyBhIGRpZ2l0L2ludGVnZXIgaW50byBhIGJhc2ljIGNvZGUgcG9pbnQuXHJcbiAgICAgKiBAc2VlIGBiYXNpY1RvRGlnaXQoKWBcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZGlnaXQgVGhlIG51bWVyaWMgdmFsdWUgb2YgYSBiYXNpYyBjb2RlIHBvaW50LlxyXG4gICAgICogQHJldHVybnMge051bWJlcn0gVGhlIGJhc2ljIGNvZGUgcG9pbnQgd2hvc2UgdmFsdWUgKHdoZW4gdXNlZCBmb3JcclxuICAgICAqIHJlcHJlc2VudGluZyBpbnRlZ2VycykgaXMgYGRpZ2l0YCwgd2hpY2ggbmVlZHMgdG8gYmUgaW4gdGhlIHJhbmdlXHJcbiAgICAgKiBgMGAgdG8gYGJhc2UgLSAxYC4gSWYgYGZsYWdgIGlzIG5vbi16ZXJvLCB0aGUgdXBwZXJjYXNlIGZvcm0gaXNcclxuICAgICAqIHVzZWQ7IGVsc2UsIHRoZSBsb3dlcmNhc2UgZm9ybSBpcyB1c2VkLiBUaGUgYmVoYXZpb3IgaXMgdW5kZWZpbmVkXHJcbiAgICAgKiBpZiBgZmxhZ2AgaXMgbm9uLXplcm8gYW5kIGBkaWdpdGAgaGFzIG5vIHVwcGVyY2FzZSBmb3JtLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZGlnaXRUb0Jhc2ljKGRpZ2l0LCBmbGFnKSB7XHJcbiAgICAgICAgLy8gIDAuLjI1IG1hcCB0byBBU0NJSSBhLi56IG9yIEEuLlpcclxuICAgICAgICAvLyAyNi4uMzUgbWFwIHRvIEFTQ0lJIDAuLjlcclxuICAgICAgICByZXR1cm4gZGlnaXQgKyAyMiArIDc1ICogKGRpZ2l0IDwgMjYpIC0gKChmbGFnICE9IDApIDw8IDUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBIGdlbmVyaWMgZXJyb3IgdXRpbGl0eSBmdW5jdGlvbi5cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgZXJyb3IgdHlwZS5cclxuICAgICAqIEByZXR1cm5zIHtFcnJvcn0gVGhyb3dzIGEgYFJhbmdlRXJyb3JgIHdpdGggdGhlIGFwcGxpY2FibGUgZXJyb3IgbWVzc2FnZS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGVycm9yKHR5cGUpIHtcclxuICAgICAgICB0aHJvdyBSYW5nZUVycm9yKHNldHRpbmdzLmVycm9yc1t0eXBlXSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICogQ29udmVydHMgYSBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzIChlLmcuIGEgZG9tYWluIG5hbWUgbGFiZWwpIHRvIGFcclxuICogUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cclxuICogQG1lbWJlck9mIHB1bnljb2RlXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scy5cclxuICogQHJldHVybnMge1N0cmluZ30gVGhlIHJlc3VsdGluZyBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxyXG4gKi9cclxuICAgIHN0YXRpYyBlbmNvZGUoaW5wdXQpIHtcclxuICAgICAgICB2YXIgbiwgZGVsdGEsIGhhbmRsZWRDUENvdW50LCBiYXNpY0xlbmd0aCwgYmlhcywgaiwgbSwgcSwgaywgdCwgY3VycmVudFZhbHVlLCBvdXRwdXQgPSBbXSwgXHJcbiAgICAgICAgLyoqIGBpbnB1dExlbmd0aGAgd2lsbCBob2xkIHRoZSBudW1iZXIgb2YgY29kZSBwb2ludHMgaW4gYGlucHV0YC4gKi9cclxuICAgICAgICBpbnB1dExlbmd0aCwgXHJcbiAgICAgICAgLyoqIENhY2hlZCBjYWxjdWxhdGlvbiByZXN1bHRzICovXHJcbiAgICAgICAgaGFuZGxlZENQQ291bnRQbHVzT25lLCBiYXNlTWludXNULCBxTWludXNUO1xyXG4gICAgICAgIC8vIENvbnZlcnQgdGhlIGlucHV0IGluIFVDUy0yIHRvIFVuaWNvZGVcclxuICAgICAgICBpbnB1dCA9IHNldHRpbmdzLnVjczJkZWNvZGUoaW5wdXQpO1xyXG4gICAgICAgIC8vIENhY2hlIHRoZSBsZW5ndGhcclxuICAgICAgICBpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aDtcclxuICAgICAgICAvLyBJbml0aWFsaXplIHRoZSBzdGF0ZVxyXG4gICAgICAgIG4gPSBzZXR0aW5ncy5pbml0aWFsTjtcclxuICAgICAgICBkZWx0YSA9IDA7XHJcbiAgICAgICAgYmlhcyA9IHNldHRpbmdzLmluaXRpYWxCaWFzO1xyXG4gICAgICAgIC8vIEhhbmRsZSB0aGUgYmFzaWMgY29kZSBwb2ludHNcclxuICAgICAgICBmb3IgKGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xyXG4gICAgICAgICAgICBjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcclxuICAgICAgICAgICAgaWYgKGN1cnJlbnRWYWx1ZSA8IDB4ODApIHtcclxuICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKHNldHRpbmdzLnN0cmluZ0Zyb21DaGFyQ29kZShjdXJyZW50VmFsdWUpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBoYW5kbGVkQ1BDb3VudCA9IGJhc2ljTGVuZ3RoID0gb3V0cHV0Lmxlbmd0aDtcclxuICAgICAgICAvLyBgaGFuZGxlZENQQ291bnRgIGlzIHRoZSBudW1iZXIgb2YgY29kZSBwb2ludHMgdGhhdCBoYXZlIGJlZW4gaGFuZGxlZDtcclxuICAgICAgICAvLyBgYmFzaWNMZW5ndGhgIGlzIHRoZSBudW1iZXIgb2YgYmFzaWMgY29kZSBwb2ludHMuXHJcbiAgICAgICAgLy8gRmluaXNoIHRoZSBiYXNpYyBzdHJpbmcgLSBpZiBpdCBpcyBub3QgZW1wdHkgLSB3aXRoIGEgZGVsaW1pdGVyXHJcbiAgICAgICAgaWYgKGJhc2ljTGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIG91dHB1dC5wdXNoKHNldHRpbmdzLmRlbGltaXRlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIE1haW4gZW5jb2RpbmcgbG9vcDpcclxuICAgICAgICB3aGlsZSAoaGFuZGxlZENQQ291bnQgPCBpbnB1dExlbmd0aCkge1xyXG4gICAgICAgICAgICAvLyBBbGwgbm9uLWJhc2ljIGNvZGUgcG9pbnRzIDwgbiBoYXZlIGJlZW4gaGFuZGxlZCBhbHJlYWR5LiBGaW5kIHRoZSBuZXh0XHJcbiAgICAgICAgICAgIC8vIGxhcmdlciBvbmU6XHJcbiAgICAgICAgICAgIGZvciAobSA9IHNldHRpbmdzLm1heEludCwgaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcclxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50VmFsdWUgPj0gbiAmJiBjdXJyZW50VmFsdWUgPCBtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbSA9IGN1cnJlbnRWYWx1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBJbmNyZWFzZSBgZGVsdGFgIGVub3VnaCB0byBhZHZhbmNlIHRoZSBkZWNvZGVyJ3MgPG4saT4gc3RhdGUgdG8gPG0sMD4sXHJcbiAgICAgICAgICAgIC8vIGJ1dCBndWFyZCBhZ2FpbnN0IG92ZXJmbG93XHJcbiAgICAgICAgICAgIGhhbmRsZWRDUENvdW50UGx1c09uZSA9IGhhbmRsZWRDUENvdW50ICsgMTtcclxuICAgICAgICAgICAgaWYgKG0gLSBuID4gc2V0dGluZ3MuZmxvb3IoKHNldHRpbmdzLm1heEludCAtIGRlbHRhKSAvIGhhbmRsZWRDUENvdW50UGx1c09uZSkpIHtcclxuICAgICAgICAgICAgICAgIHNldHRpbmdzLmVycm9yKCdvdmVyZmxvdycpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGRlbHRhICs9IChtIC0gbikgKiBoYW5kbGVkQ1BDb3VudFBsdXNPbmU7XHJcbiAgICAgICAgICAgIG4gPSBtO1xyXG4gICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xyXG4gICAgICAgICAgICAgICAgY3VycmVudFZhbHVlID0gaW5wdXRbal07XHJcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudFZhbHVlIDwgbiAmJiArK2RlbHRhID4gc2V0dGluZ3MubWF4SW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MuZXJyb3IoJ292ZXJmbG93Jyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudFZhbHVlID09IG4pIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBSZXByZXNlbnQgZGVsdGEgYXMgYSBnZW5lcmFsaXplZCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlclxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAocSA9IGRlbHRhLCBrID0gc2V0dGluZ3MuYmFzZTsgLyogbm8gY29uZGl0aW9uICovOyBrICs9IHNldHRpbmdzLmJhc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdCA9IGsgPD0gYmlhcyA/IHNldHRpbmdzLnRNaW4gOiAoayA+PSBiaWFzICsgc2V0dGluZ3MudE1heCA/IHNldHRpbmdzLnRNYXggOiBrIC0gYmlhcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChxIDwgdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcU1pbnVzVCA9IHEgLSB0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBiYXNlTWludXNUID0gc2V0dGluZ3MuYmFzZSAtIHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKHNldHRpbmdzLnN0cmluZ0Zyb21DaGFyQ29kZShzZXR0aW5ncy5kaWdpdFRvQmFzaWModCArIHFNaW51c1QgJSBiYXNlTWludXNULCAwKSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBxID0gc2V0dGluZ3MuZmxvb3IocU1pbnVzVCAvIGJhc2VNaW51c1QpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBvdXRwdXQucHVzaChzZXR0aW5ncy5zdHJpbmdGcm9tQ2hhckNvZGUoc2V0dGluZ3MuZGlnaXRUb0Jhc2ljKHEsIDApKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYmlhcyA9IHNldHRpbmdzLmFkYXB0KGRlbHRhLCBoYW5kbGVkQ1BDb3VudFBsdXNPbmUsIGhhbmRsZWRDUENvdW50ID09IGJhc2ljTGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgICAgICBkZWx0YSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgKytoYW5kbGVkQ1BDb3VudDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICArK2RlbHRhO1xyXG4gICAgICAgICAgICArK247XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBvdXRwdXQuam9pbignJyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuKiBCaWFzIGFkYXB0YXRpb24gZnVuY3Rpb24gYXMgcGVyIHNlY3Rpb24gMy40IG9mIFJGQyAzNDkyLlxyXG4qIGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM0OTIjc2VjdGlvbi0zLjRcclxuKiBAcHJpdmF0ZVxyXG4qL1xyXG4gICAgc3RhdGljIGFkYXB0KGRlbHRhLCBudW1Qb2ludHMsIGZpcnN0VGltZSkge1xyXG4gICAgICAgIHZhciBrID0gMDtcclxuICAgICAgICBkZWx0YSA9IGZpcnN0VGltZSA/IHNldHRpbmdzLmZsb29yKGRlbHRhIC8gc2V0dGluZ3MuZGFtcCkgOiBkZWx0YSA+PiAxO1xyXG4gICAgICAgIGRlbHRhICs9IHNldHRpbmdzLmZsb29yKGRlbHRhIC8gbnVtUG9pbnRzKTtcclxuICAgICAgICBmb3IgKCAvKiBubyBpbml0aWFsaXphdGlvbiAqLzsgZGVsdGEgPiBzZXR0aW5ncy5iYXNlTWludXNUTWluICogc2V0dGluZ3MudE1heCA+PiAxOyBrICs9IHNldHRpbmdzLmJhc2UpIHtcclxuICAgICAgICAgICAgZGVsdGEgPSBzZXR0aW5ncy5mbG9vcihkZWx0YSAvIHNldHRpbmdzLmJhc2VNaW51c1RNaW4pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc2V0dGluZ3MuZmxvb3IoayArIChzZXR0aW5ncy5iYXNlTWludXNUTWluICsgMSkgKiBkZWx0YSAvIChkZWx0YSArIHNldHRpbmdzLnNrZXcpKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4qIENyZWF0ZXMgYW4gYXJyYXkgY29udGFpbmluZyB0aGUgbnVtZXJpYyBjb2RlIHBvaW50cyBvZiBlYWNoIFVuaWNvZGVcclxuKiBjaGFyYWN0ZXIgaW4gdGhlIHN0cmluZy4gV2hpbGUgSmF2YVNjcmlwdCB1c2VzIFVDUy0yIGludGVybmFsbHksXHJcbiogdGhpcyBmdW5jdGlvbiB3aWxsIGNvbnZlcnQgYSBwYWlyIG9mIHN1cnJvZ2F0ZSBoYWx2ZXMgKGVhY2ggb2Ygd2hpY2hcclxuKiBVQ1MtMiBleHBvc2VzIGFzIHNlcGFyYXRlIGNoYXJhY3RlcnMpIGludG8gYSBzaW5nbGUgY29kZSBwb2ludCxcclxuKiBtYXRjaGluZyBVVEYtMTYuXHJcbiogQHNlZSBgcHVueWNvZGUudWNzMi5lbmNvZGVgXHJcbiogQHNlZSA8aHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmc+XHJcbiogQG1lbWJlck9mIHB1bnljb2RlLnVjczJcclxuKiBAbmFtZSBkZWNvZGVcclxuKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nIFRoZSBVbmljb2RlIGlucHV0IHN0cmluZyAoVUNTLTIpLlxyXG4qIEByZXR1cm5zIHtBcnJheX0gVGhlIG5ldyBhcnJheSBvZiBjb2RlIHBvaW50cy5cclxuKi9cclxuICAgIHN0YXRpYyB1Y3MyZGVjb2RlKHN0cmluZykge1xyXG4gICAgICAgIHZhciBvdXRwdXQgPSBbXSwgY291bnRlciA9IDAsIGxlbmd0aCA9IHN0cmluZy5sZW5ndGgsIHZhbHVlLCBleHRyYTtcclxuICAgICAgICB3aGlsZSAoY291bnRlciA8IGxlbmd0aCkge1xyXG4gICAgICAgICAgICB2YWx1ZSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSA+PSAweEQ4MDAgJiYgdmFsdWUgPD0gMHhEQkZGICYmIGNvdW50ZXIgPCBsZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIC8vIGhpZ2ggc3Vycm9nYXRlLCBhbmQgdGhlcmUgaXMgYSBuZXh0IGNoYXJhY3RlclxyXG4gICAgICAgICAgICAgICAgZXh0cmEgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xyXG4gICAgICAgICAgICAgICAgaWYgKChleHRyYSAmIDB4RkMwMCkgPT0gMHhEQzAwKSB7IC8vIGxvdyBzdXJyb2dhdGVcclxuICAgICAgICAgICAgICAgICAgICBvdXRwdXQucHVzaCgoKHZhbHVlICYgMHgzRkYpIDw8IDEwKSArIChleHRyYSAmIDB4M0ZGKSArIDB4MTAwMDApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdW5tYXRjaGVkIHN1cnJvZ2F0ZTsgb25seSBhcHBlbmQgdGhpcyBjb2RlIHVuaXQsIGluIGNhc2UgdGhlIG5leHRcclxuICAgICAgICAgICAgICAgICAgICAvLyBjb2RlIHVuaXQgaXMgdGhlIGhpZ2ggc3Vycm9nYXRlIG9mIGEgc3Vycm9nYXRlIHBhaXJcclxuICAgICAgICAgICAgICAgICAgICBvdXRwdXQucHVzaCh2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY291bnRlci0tO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgb3V0cHV0LnB1c2godmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBvdXRwdXQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICogVHlwZWRlZiBmb3IgZGVjb21wb3NlRGF0YVVyaSByZXR1cm4gb2JqZWN0LlxyXG4gKlxyXG4gKiBAbWVtYmVyb2YgUElYSS51dGlsc1xyXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBEZWNvbXBvc2VkRGF0YVVyaVxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbWVkaWFUeXBlIE1lZGlhIHR5cGUsIGVnLiBgaW1hZ2VgXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzdWJUeXBlIFN1YiB0eXBlLCBlZy4gYHBuZ2BcclxuICogQHByb3BlcnR5IHtzdHJpbmd9IGVuY29kaW5nIERhdGEgZW5jb2RpbmcsIGVnLiBgYmFzZTY0YFxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gZGF0YSBUaGUgYWN0dWFsIGRhdGFcclxuICovXHJcbiAgICAvKipcclxuICAgICAqIFNwbGl0IGEgZGF0YSBVUkkgaW50byBjb21wb25lbnRzLiBSZXR1cm5zIHVuZGVmaW5lZCBpZlxyXG4gICAgICogcGFyYW1ldGVyIGBkYXRhVXJpYCBpcyBub3QgYSB2YWxpZCBkYXRhIFVSSS5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgUElYSS51dGlsc1xyXG4gICAgICogQGZ1bmN0aW9uIGRlY29tcG9zZURhdGFVcmlcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhVXJpIC0gdGhlIGRhdGEgVVJJIHRvIGNoZWNrXHJcbiAgICAgKiBAcmV0dXJuIHtQSVhJLnV0aWxzLkRlY29tcG9zZWREYXRhVXJpfHVuZGVmaW5lZH0gVGhlIGRlY29tcG9zZWQgZGF0YSB1cmkgb3IgdW5kZWZpbmVkXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBkZWNvbXBvc2VEYXRhVXJpKGRhdGFVcmkpIHtcclxuICAgICAgICB2YXIgZGF0YVVyaU1hdGNoID0gc2V0dGluZ3MuREFUQV9VUkkuZXhlYyhkYXRhVXJpKTtcclxuICAgICAgICBpZiAoZGF0YVVyaU1hdGNoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBtZWRpYVR5cGU6IGRhdGFVcmlNYXRjaFsxXSA/IGRhdGFVcmlNYXRjaFsxXS50b0xvd2VyQ2FzZSgpIDogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICAgICAgc3ViVHlwZTogZGF0YVVyaU1hdGNoWzJdID8gZGF0YVVyaU1hdGNoWzJdLnRvTG93ZXJDYXNlKCkgOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgICAgICBjaGFyc2V0OiBkYXRhVXJpTWF0Y2hbM10gPyBkYXRhVXJpTWF0Y2hbM10udG9Mb3dlckNhc2UoKSA6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgICAgIGVuY29kaW5nOiBkYXRhVXJpTWF0Y2hbNF0gPyBkYXRhVXJpTWF0Y2hbNF0udG9Mb3dlckNhc2UoKSA6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgICAgIGRhdGE6IGRhdGFVcmlNYXRjaFs1XSxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogVGFyZ2V0IGZyYW1lcyBwZXIgbWlsbGlzZWNvbmQuXHJcbiAqXHJcbiAqIEBzdGF0aWNcclxuICogQG5hbWUgVEFSR0VUX0ZQTVNcclxuICogQG1lbWJlcm9mIFBJWEkuc2V0dGluZ3NcclxuICogQHR5cGUge251bWJlcn1cclxuICogQGRlZmF1bHQgMC4wNlxyXG4gKi9cclxuc2V0dGluZ3MuVEFSR0VUX0ZQTVMgPSAwLjA2O1xyXG4vKipcclxuICogRGVmYXVsdCBmaWx0ZXIgcmVzb2x1dGlvbi5cclxuICpcclxuICogQHN0YXRpY1xyXG4gKiBAbmFtZSBGSUxURVJfUkVTT0xVVElPTlxyXG4gKiBAbWVtYmVyb2YgUElYSS5zZXR0aW5nc1xyXG4gKiBAdHlwZSB7bnVtYmVyfVxyXG4gKiBAZGVmYXVsdCAxXHJcbiAqL1xyXG5zZXR0aW5ncy5GSUxURVJfUkVTT0xVVElPTiA9IDE7XHJcbi8vIFRPRE86IG1heWJlIGNoYW5nZSB0byBTUFJJVEUuQkFUQ0hfU0laRTogMjAwMFxyXG4vLyBUT0RPOiBtYXliZSBhZGQgUEFSVElDTEUuQkFUQ0hfU0laRTogMTUwMDBcclxuLyoqXHJcbiAqIFRoZSBkZWZhdWx0IHNwcml0ZSBiYXRjaCBzaXplLlxyXG4gKlxyXG4gKiBUaGUgZGVmYXVsdCBhaW1zIHRvIGJhbGFuY2UgZGVza3RvcCBhbmQgbW9iaWxlIGRldmljZXMuXHJcbiAqXHJcbiAqIEBzdGF0aWNcclxuICogQG5hbWUgU1BSSVRFX0JBVENIX1NJWkVcclxuICogQG1lbWJlcm9mIFBJWEkuc2V0dGluZ3NcclxuICogQHR5cGUge251bWJlcn1cclxuICogQGRlZmF1bHQgNDA5NlxyXG4gKi9cclxuc2V0dGluZ3MuU1BSSVRFX0JBVENIX1NJWkUgPSA0MDk2O1xyXG4vKipcclxuICogRGVmYXVsdCBHYXJiYWdlIENvbGxlY3Rpb24gbW9kZS5cclxuICpcclxuICogQHN0YXRpY1xyXG4gKiBAbmFtZSBHQ19NT0RFXHJcbiAqIEBtZW1iZXJvZiBQSVhJLnNldHRpbmdzXHJcbiAqIEB0eXBlIHtQSVhJLkdDX01PREVTfVxyXG4gKiBAZGVmYXVsdCBQSVhJLkdDX01PREVTLkFVVE9cclxuICovXHJcbnNldHRpbmdzLkdDX01PREUgPSAwO1xyXG4vKipcclxuICogRGVmYXVsdCBHYXJiYWdlIENvbGxlY3Rpb24gbWF4IGlkbGUuXHJcbiAqXHJcbiAqIEBzdGF0aWNcclxuICogQG5hbWUgR0NfTUFYX0lETEVcclxuICogQG1lbWJlcm9mIFBJWEkuc2V0dGluZ3NcclxuICogQHR5cGUge251bWJlcn1cclxuICogQGRlZmF1bHQgMzYwMFxyXG4gKi9cclxuc2V0dGluZ3MuR0NfTUFYX0lETEUgPSA2MCAqIDYwO1xyXG4vKipcclxuICogRGVmYXVsdCBHYXJiYWdlIENvbGxlY3Rpb24gbWF4aW11bSBjaGVjayBjb3VudC5cclxuICpcclxuICogQHN0YXRpY1xyXG4gKiBAbmFtZSBHQ19NQVhfQ0hFQ0tfQ09VTlRcclxuICogQG1lbWJlcm9mIFBJWEkuc2V0dGluZ3NcclxuICogQHR5cGUge251bWJlcn1cclxuICogQGRlZmF1bHQgNjAwXHJcbiAqL1xyXG5zZXR0aW5ncy5HQ19NQVhfQ0hFQ0tfQ09VTlQgPSA2MCAqIDEwO1xyXG4vKipcclxuKiBUaGUgZ2MgbW9kZXMgdGhhdCBhcmUgc3VwcG9ydGVkIGJ5IHBpeGkuXHJcbipcclxuKiBUaGUge0BsaW5rIFBJWEkuc2V0dGluZ3MuR0NfTU9ERX0gR2FyYmFnZSBDb2xsZWN0aW9uIG1vZGUgZm9yIFBpeGlKUyB0ZXh0dXJlcyBpcyBBVVRPXHJcbiogSWYgc2V0IHRvIEdDX01PREUsIHRoZSByZW5kZXJlciB3aWxsIG9jY2FzaW9uYWxseSBjaGVjayB0ZXh0dXJlcyB1c2FnZS4gSWYgdGhleSBhcmUgbm90XHJcbiogdXNlZCBmb3IgYSBzcGVjaWZpZWQgcGVyaW9kIG9mIHRpbWUgdGhleSB3aWxsIGJlIHJlbW92ZWQgZnJvbSB0aGUgR1BVLiBUaGV5IHdpbGwgb2YgY291cnNlXHJcbiogYmUgdXBsb2FkZWQgYWdhaW4gd2hlbiB0aGV5IGFyZSByZXF1aXJlZC4gVGhpcyBpcyBhIHNpbGVudCBiZWhpbmQgdGhlIHNjZW5lcyBwcm9jZXNzIHRoYXRcclxuKiBzaG91bGQgZW5zdXJlIHRoYXQgdGhlIEdQVSBkb2VzIG5vdCAgZ2V0IGZpbGxlZCB1cC5cclxuKlxyXG4qIEhhbmR5IGZvciBtb2JpbGUgZGV2aWNlcyFcclxuKiBUaGlzIHByb3BlcnR5IG9ubHkgYWZmZWN0cyBXZWJHTC5cclxuKlxyXG4qIEBuYW1lIEdDX01PREVTXHJcbiogQGVudW0ge251bWJlcn1cclxuKiBAc3RhdGljXHJcbiogQG1lbWJlcm9mIFBJWElcclxuKiBAcHJvcGVydHkge251bWJlcn0gQVVUTyAtIEdhcmJhZ2UgY29sbGVjdGlvbiB3aWxsIGhhcHBlbiBwZXJpb2RpY2FsbHkgYXV0b21hdGljYWxseVxyXG4qIEBwcm9wZXJ0eSB7bnVtYmVyfSBNQU5VQUwgLSBHYXJiYWdlIGNvbGxlY3Rpb24gd2lsbCBuZWVkIHRvIGJlIGNhbGxlZCBtYW51YWxseVxyXG4qL1xyXG5zZXR0aW5ncy5HQ19NT0RFUyA9IHtcclxuICAgIEFVVE86IDAsXHJcbiAgICBNQU5VQUw6IDEsXHJcbn07XHJcbi8qKlxyXG4gKiBDb25zdGFudHMgdGhhdCBzcGVjaWZ5IGZsb2F0IHByZWNpc2lvbiBpbiBzaGFkZXJzLlxyXG4gKlxyXG4gKiBAbmFtZSBQUkVDSVNJT05cclxuICogQG1lbWJlcm9mIFBJWElcclxuICogQHN0YXRpY1xyXG4gKiBAZW51bSB7c3RyaW5nfVxyXG4gKiBAY29uc3RhbnRcclxuICogQHByb3BlcnR5IHtzdHJpbmd9IExPVz0nbG93cCdcclxuICogQHByb3BlcnR5IHtzdHJpbmd9IE1FRElVTT0nbWVkaXVtcCdcclxuICogQHByb3BlcnR5IHtzdHJpbmd9IEhJR0g9J2hpZ2hwJ1xyXG4gKi9cclxuc2V0dGluZ3MuUFJFQ0lTSU9OID0ge1xyXG4gICAgTE9XOiAnbG93cCcsXHJcbiAgICBNRURJVU06ICdtZWRpdW1wJyxcclxuICAgIEhJR0g6ICdoaWdocCcsXHJcbn07XHJcbi8qKlxyXG4qIEdyYXBoaWNzIGN1cnZlcyByZXNvbHV0aW9uIHNldHRpbmdzLiBJZiBgYWRhcHRpdmVgIGZsYWcgaXMgc2V0IHRvIGB0cnVlYCxcclxuKiB0aGUgcmVzb2x1dGlvbiBpcyBjYWxjdWxhdGVkIGJhc2VkIG9uIHRoZSBjdXJ2ZSdzIGxlbmd0aCB0byBlbnN1cmUgYmV0dGVyIHZpc3VhbCBxdWFsaXR5LlxyXG4qIEFkYXB0aXZlIGRyYXcgd29ya3Mgd2l0aCBgYmV6aWVyQ3VydmVUb2AgYW5kIGBxdWFkcmF0aWNDdXJ2ZVRvYC5cclxuKlxyXG4qIEBzdGF0aWNcclxuKiBAY29uc3RhbnRcclxuKiBAbWVtYmVyb2YgUElYSVxyXG4qIEBuYW1lIEdSQVBISUNTX0NVUlZFU1xyXG4qIEB0eXBlIHtvYmplY3R9XHJcbiogQHByb3BlcnR5IHtib29sZWFufSBhZGFwdGl2ZT1mYWxzZSAtIGZsYWcgaW5kaWNhdGluZyBpZiB0aGUgcmVzb2x1dGlvbiBzaG91bGQgYmUgYWRhcHRpdmVcclxuKiBAcHJvcGVydHkge251bWJlcn0gbWF4TGVuZ3RoPTEwIC0gbWF4aW1hbCBsZW5ndGggb2YgYSBzaW5nbGUgc2VnbWVudCBvZiB0aGUgY3VydmUgKGlmIGFkYXB0aXZlID0gZmFsc2UsIGlnbm9yZWQpXHJcbiogQHByb3BlcnR5IHtudW1iZXJ9IG1pblNlZ21lbnRzPTggLSBtaW5pbWFsIG51bWJlciBvZiBzZWdtZW50cyBpbiB0aGUgY3VydmUgKGlmIGFkYXB0aXZlID0gZmFsc2UsIGlnbm9yZWQpXHJcbiogQHByb3BlcnR5IHtudW1iZXJ9IG1heFNlZ21lbnRzPTIwNDggLSBtYXhpbWFsIG51bWJlciBvZiBzZWdtZW50cyBpbiB0aGUgY3VydmUgKGlmIGFkYXB0aXZlID0gZmFsc2UsIGlnbm9yZWQpXHJcbiovXHJcbnNldHRpbmdzLkdSQVBISUNTX0NVUlZFUyA9IHtcclxuICAgIGFkYXB0aXZlOiB0cnVlLFxyXG4gICAgbWF4TGVuZ3RoOiAxMCxcclxuICAgIG1pblNlZ21lbnRzOiA4LFxyXG4gICAgbWF4U2VnbWVudHM6IDIwNDgsXHJcbiAgICBfc2VnbWVudHNDb3VudDogZnVuY3Rpb24gX3NlZ21lbnRzQ291bnQobGVuZ3RoLCBkZWZhdWx0U2VnbWVudHMgPSBudWxsKSB7XHJcbiAgICAgICAgaWYgKGRlZmF1bHRTZWdtZW50cyA9PT0gdm9pZCAwKSB7XHJcbiAgICAgICAgICAgIGRlZmF1bHRTZWdtZW50cyA9IDIwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXRoaXMuYWRhcHRpdmUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRTZWdtZW50cztcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IE1hdGguY2VpbChsZW5ndGggLyB0aGlzLm1heExlbmd0aCk7XHJcbiAgICAgICAgaWYgKHJlc3VsdCA8IHRoaXMubWluU2VnbWVudHMpIHtcclxuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5taW5TZWdtZW50cztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAocmVzdWx0ID4gdGhpcy5tYXhTZWdtZW50cykge1xyXG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLm1heFNlZ21lbnRzO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfSxcclxufTtcclxuc2V0dGluZ3MuaW5pdGlhbE4gPSAxMjg7XHJcbnNldHRpbmdzLmluaXRpYWxCaWFzID0gNzI7XHJcbnNldHRpbmdzLnN0cmluZ0Zyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGU7XHJcbnNldHRpbmdzLmRlbGltaXRlciA9ICctJztcclxuc2V0dGluZ3MubWF4SW50ID0gMjE0NzQ4MzY0Nztcclxuc2V0dGluZ3MuZmxvb3IgPSBNYXRoLmZsb29yO1xyXG5zZXR0aW5ncy5iYXNlID0gMzY7XHJcbnNldHRpbmdzLnRNaW4gPSAxO1xyXG5zZXR0aW5ncy50TWF4ID0gMjY7XHJcbi8qKiBFcnJvciBtZXNzYWdlcyAqL1xyXG5zZXR0aW5ncy5lcnJvcnMgPSB7XHJcbiAgICAnb3ZlcmZsb3cnOiAnT3ZlcmZsb3c6IGlucHV0IG5lZWRzIHdpZGVyIGludGVnZXJzIHRvIHByb2Nlc3MnLFxyXG4gICAgJ25vdC1iYXNpYyc6ICdJbGxlZ2FsIGlucHV0ID49IDB4ODAgKG5vdCBhIGJhc2ljIGNvZGUgcG9pbnQpJyxcclxuICAgICdpbnZhbGlkLWlucHV0JzogJ0ludmFsaWQgaW5wdXQnXHJcbn07XHJcbnNldHRpbmdzLmRhbXAgPSA3MDA7XHJcbnNldHRpbmdzLmJhc2VNaW51c1RNaW4gPSBzZXR0aW5ncy5iYXNlIC0gc2V0dGluZ3MudE1pbjtcclxuc2V0dGluZ3Muc2tldyA9IDM4O1xyXG4vKipcclxuKiBSZWdleHAgZm9yIGRhdGEgVVJJLlxyXG4qIEJhc2VkIG9uOiB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3JhZ2luZ3dpbmQvZGF0YS11cmktcmVnZXh9XHJcbipcclxuKiBAc3RhdGljXHJcbiogQGNvbnN0YW50IHtSZWdFeHB8c3RyaW5nfSBEQVRBX1VSSVxyXG4qIEBtZW1iZXJvZiBQSVhJXHJcbiogQGV4YW1wbGUgZGF0YTppbWFnZS9wbmc7YmFzZTY0XHJcbiovXHJcbnNldHRpbmdzLkRBVEFfVVJJID0gL15cXHMqZGF0YTooPzooW1xcdy1dKylcXC8oW1xcdysuLV0rKSk/KD86O2NoYXJzZXQ9KFtcXHctXSspKT8oPzo7KGJhc2U2NCkpPywoLiopL2k7XHJcbi8vIFRha2VuIGZyb20gdGhlIGJpdC10d2lkZGxlIHBhY2thZ2Vcclxuc2V0dGluZ3MuZGVmYXVsdFZlcnRleCA9IFwiYXR0cmlidXRlIHZlYzIgYVZlcnRleFBvc2l0aW9uO1xcclxcbmF0dHJpYnV0ZSB2ZWMyIGFUZXh0dXJlQ29vcmQ7XFxyXFxuXFxyXFxudW5pZm9ybSBtYXQzIHByb2plY3Rpb25NYXRyaXg7XFxyXFxuXFxyXFxudmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XFxyXFxuXFxyXFxudm9pZCBtYWluKHZvaWQpXFxyXFxue1xcclxcbiAgICBnbF9Qb3NpdGlvbiA9IHZlYzQoKHByb2plY3Rpb25NYXRyaXggKiB2ZWMzKGFWZXJ0ZXhQb3NpdGlvbiwgMS4wKSkueHksIDAuMCwgMS4wKTtcXHJcXG4gICAgdlRleHR1cmVDb29yZCA9IGFUZXh0dXJlQ29vcmQ7XFxyXFxufVwiO1xyXG5zZXR0aW5ncy5kZWZhdWx0RmlsdGVyVmVydGV4ID0gXCJhdHRyaWJ1dGUgdmVjMiBhVmVydGV4UG9zaXRpb247XFxyXFxuXFxyXFxudW5pZm9ybSBtYXQzIHByb2plY3Rpb25NYXRyaXg7XFxyXFxuXFxyXFxudmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XFxyXFxuXFxyXFxudW5pZm9ybSB2ZWM0IGlucHV0U2l6ZTtcXHJcXG51bmlmb3JtIHZlYzQgb3V0cHV0RnJhbWU7XFxyXFxuXFxyXFxudmVjNCBmaWx0ZXJWZXJ0ZXhQb3NpdGlvbiggdm9pZCApXFxyXFxue1xcclxcbiAgICB2ZWMyIHBvc2l0aW9uID0gYVZlcnRleFBvc2l0aW9uICogbWF4KG91dHB1dEZyYW1lLnp3LCB2ZWMyKDAuKSkgKyBvdXRwdXRGcmFtZS54eTtcXHJcXG5cXHJcXG4gICAgcmV0dXJuIHZlYzQoKHByb2plY3Rpb25NYXRyaXggKiB2ZWMzKHBvc2l0aW9uLCAxLjApKS54eSwgMC4wLCAxLjApO1xcclxcbn1cXHJcXG5cXHJcXG52ZWMyIGZpbHRlclRleHR1cmVDb29yZCggdm9pZCApXFxyXFxue1xcclxcbiAgICByZXR1cm4gYVZlcnRleFBvc2l0aW9uICogKG91dHB1dEZyYW1lLnp3ICogaW5wdXRTaXplLnp3KTtcXHJcXG59XFxyXFxuXFxyXFxudm9pZCBtYWluKHZvaWQpXFxyXFxue1xcclxcbiAgICBnbF9Qb3NpdGlvbiA9IGZpbHRlclZlcnRleFBvc2l0aW9uKCk7XFxyXFxuICAgIHZUZXh0dXJlQ29vcmQgPSBmaWx0ZXJUZXh0dXJlQ29vcmQoKTtcXHJcXG59XFxyXFxuXCI7XHJcbmV4cG9ydHMuc2V0dGluZ3MgPSBzZXR0aW5ncztcclxuIl0sInNvdXJjZVJvb3QiOiIifQ==