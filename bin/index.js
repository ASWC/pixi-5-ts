/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./js-compile/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./js-compile/examples/BaseExample.js":
/*!********************************************!*\
  !*** ./js-compile/examples/BaseExample.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Graphics_1 = __webpack_require__(/*! ../raw-pixi-ts/Graphics */ "./js-compile/raw-pixi-ts/Graphics.js");
const Container_1 = __webpack_require__(/*! ../raw-pixi-ts/Container */ "./js-compile/raw-pixi-ts/Container.js");
const EventDispatcher_1 = __webpack_require__(/*! ../raw-pixi-ts/EventDispatcher */ "./js-compile/raw-pixi-ts/EventDispatcher.js");
const Event_1 = __webpack_require__(/*! ../raw-pixi-ts/Event */ "./js-compile/raw-pixi-ts/Event.js");
class BaseExample extends EventDispatcher_1.EventDispatcher {
    constructor(app, width = 100, height = 100) {
        super();
        this.backColor = 0x969696;
        this.sizew = width;
        this.sizeh = height;
        this.app = app;
        this.stage = new Container_1.Container();
    }
    activateMask() {
        this.stageMask = new Graphics_1.Graphics();
        this.stageMask.beginFill(0);
        this.stageMask.drawRect(0, 0, this.sizew, this.sizeh);
        this.stage.mask = this.stageMask;
    }
    destructor() {
        this.stage.removeChildren();
        if (this.stageMask) {
            this.stageMask.destroy(null);
        }
    }
    exampleReady() {
        this.dispatchEvent(Event_1.Event.getEvent(Event_1.Event.COMPLETE));
    }
}
exports.BaseExample = BaseExample;


/***/ }),

/***/ "./js-compile/examples/FilterBlending.js":
/*!***********************************************!*\
  !*** ./js-compile/examples/FilterBlending.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseExample_1 = __webpack_require__(/*! ./BaseExample */ "./js-compile/examples/BaseExample.js");
const ResourceLoader_1 = __webpack_require__(/*! ../raw-pixi-ts/ResourceLoader */ "./js-compile/raw-pixi-ts/ResourceLoader.js");
const URLRequest_1 = __webpack_require__(/*! ../raw-pixi-ts/URLRequest */ "./js-compile/raw-pixi-ts/URLRequest.js");
const Event_1 = __webpack_require__(/*! ../raw-pixi-ts/Event */ "./js-compile/raw-pixi-ts/Event.js");
const Texture_1 = __webpack_require__(/*! ../raw-pixi-ts/Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const BaseTexture_1 = __webpack_require__(/*! ../raw-pixi-ts/BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const Sprite_1 = __webpack_require__(/*! ../raw-pixi-ts/Sprite */ "./js-compile/raw-pixi-ts/Sprite.js");
const Container_1 = __webpack_require__(/*! ../raw-pixi-ts/Container */ "./js-compile/raw-pixi-ts/Container.js");
const Rectangle_1 = __webpack_require__(/*! ../raw-pixi-ts/Rectangle */ "./js-compile/raw-pixi-ts/Rectangle.js");
const Filter_1 = __webpack_require__(/*! ../raw-pixi-ts/Filter */ "./js-compile/raw-pixi-ts/Filter.js");
const Point_1 = __webpack_require__(/*! ../raw-pixi-ts/Point */ "./js-compile/raw-pixi-ts/Point.js");
class FilterBlending extends BaseExample_1.BaseExample {
    constructor(app, width, height) {
        super(app, width, height);
        this.handleGrassLoaded = (event) => {
            this.backgroundtxt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            const background = new Sprite_1.Sprite(this.backgroundtxt);
            background.width = this.sizew;
            background.height = this.sizeh;
            this.stage.addChild(background);
            const shaderFrag = `
            precision highp float;
            varying vec2 vTextureCoord;
            uniform vec2 mouse;
            uniform vec4 inputSize;
            uniform vec4 outputFrame;
            uniform float time;
            void main() {
            vec2 screenPos = vTextureCoord * inputSize.xy + outputFrame.xy;
            if (length(mouse - screenPos) < 25.0) {
                gl_FragColor = vec4(1.0, 1.0, 0.0, 1.0) * 0.7; //yellow circle, alpha=0.7
            } else {
                gl_FragColor = vec4( sin(time), (mouse.xy - outputFrame.xy) / outputFrame.zw, 1.0) * 0.5; // blend with underlying image, alpha=0.5
            }
            }
            `;
            const container = new Container_1.Container();
            container.filterArea = new Rectangle_1.Rectangle(100, 100, this.sizew - 200, this.sizeh - 200);
            this.stage.addChild(container);
            this.filter = new Filter_1.Filter(null, shaderFrag, {
                mouse: new Point_1.Point()
            });
            container.filters = [this.filter];
            this.app.ticker.add(this.runExample);
            this.exampleReady();
        };
        this.runExample = (delta) => {
            this.filter.uniforms.mouse.copyFrom(this.app.renderer.plugins.interaction.mouse.global);
        };
        this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/bg_grass.jpg"));
        this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleGrassLoaded);
        this.loader.load();
    }
    destructor() {
        super.destructor();
        this.backgroundtxt.destroy(null);
        this.backgroundtxt = null;
        this.filter.destroy();
        this.filter = null;
        this.app.ticker.remove(this.runExample, null);
    }
}
exports.FilterBlending = FilterBlending;


/***/ }),

/***/ "./js-compile/examples/FilterBlur.js":
/*!*******************************************!*\
  !*** ./js-compile/examples/FilterBlur.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseExample_1 = __webpack_require__(/*! ./BaseExample */ "./js-compile/examples/BaseExample.js");
const ResourceLoader_1 = __webpack_require__(/*! ../raw-pixi-ts/ResourceLoader */ "./js-compile/raw-pixi-ts/ResourceLoader.js");
const Texture_1 = __webpack_require__(/*! ../raw-pixi-ts/Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const URLRequest_1 = __webpack_require__(/*! ../raw-pixi-ts/URLRequest */ "./js-compile/raw-pixi-ts/URLRequest.js");
const Event_1 = __webpack_require__(/*! ../raw-pixi-ts/Event */ "./js-compile/raw-pixi-ts/Event.js");
const BaseTexture_1 = __webpack_require__(/*! ../raw-pixi-ts/BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const Sprite_1 = __webpack_require__(/*! ../raw-pixi-ts/Sprite */ "./js-compile/raw-pixi-ts/Sprite.js");
const BlurFilter_1 = __webpack_require__(/*! ../raw-pixi-ts/BlurFilter */ "./js-compile/raw-pixi-ts/BlurFilter.js");
class FilterBlur extends BaseExample_1.BaseExample {
    constructor(app, width, height) {
        super(app, width, height);
        this.handleMobyLoaded = (event) => {
            this.mobyTxt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            const bg = new Sprite_1.Sprite(this.depthTxt);
            bg.width = this.sizew;
            bg.height = this.sizeh;
            this.stage.addChild(bg);
            const littleDudes = new Sprite_1.Sprite(this.dudesTxt);
            littleDudes.x = (this.sizew / 2) - 315;
            littleDudes.y = 200;
            this.stage.addChild(littleDudes);
            const littleRobot = new Sprite_1.Sprite(this.mobyTxt);
            littleRobot.x = (this.sizew / 2) - 200;
            littleRobot.y = 100;
            this.stage.addChild(littleRobot);
            this.blurFilter1 = new BlurFilter_1.BlurFilter();
            this.blurFilter2 = new BlurFilter_1.BlurFilter();
            littleDudes.filters = [this.blurFilter1];
            littleRobot.filters = [this.blurFilter2];
            this.count = 0;
            this.app.ticker.add(this.runExample);
            this.exampleReady();
        };
        this.runExample = (delta) => {
            this.count += 0.005;
            const blurAmount = Math.cos(this.count);
            const blurAmount2 = Math.sin(this.count);
            this.blurFilter1.blur = 20 * (blurAmount);
            this.blurFilter2.blur = 20 * (blurAmount2);
        };
        this.handleDudesLoaded = (event) => {
            this.dudesTxt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/pixi-filters/depth_blur_moby.jpg"));
            this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleMobyLoaded);
            this.loader.load();
        };
        this.handleDepthLoaded = (event) => {
            this.depthTxt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/pixi-filters/depth_blur_dudes.jpg"));
            this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleDudesLoaded);
            this.loader.load();
        };
        this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/pixi-filters/bg_depth_blur.jpg"));
        this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleDepthLoaded);
        this.loader.load();
    }
    destructor() {
        super.destructor();
        this.app.ticker.remove(this.runExample, null);
        this.blurFilter1.destroy();
        this.blurFilter1 = null;
        this.blurFilter2.destroy();
        this.blurFilter2 = null;
        this.mobyTxt.destroy(null);
        this.mobyTxt = null;
        this.dudesTxt.destroy(null);
        this.dudesTxt = null;
        this.depthTxt.destroy(null);
        this.depthTxt = null;
    }
}
exports.FilterBlur = FilterBlur;


/***/ }),

/***/ "./js-compile/examples/FilterColor.js":
/*!********************************************!*\
  !*** ./js-compile/examples/FilterColor.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseExample_1 = __webpack_require__(/*! ./BaseExample */ "./js-compile/examples/BaseExample.js");
const ResourceLoader_1 = __webpack_require__(/*! ../raw-pixi-ts/ResourceLoader */ "./js-compile/raw-pixi-ts/ResourceLoader.js");
const Texture_1 = __webpack_require__(/*! ../raw-pixi-ts/Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const URLRequest_1 = __webpack_require__(/*! ../raw-pixi-ts/URLRequest */ "./js-compile/raw-pixi-ts/URLRequest.js");
const Event_1 = __webpack_require__(/*! ../raw-pixi-ts/Event */ "./js-compile/raw-pixi-ts/Event.js");
const BaseTexture_1 = __webpack_require__(/*! ../raw-pixi-ts/BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const Sprite_1 = __webpack_require__(/*! ../raw-pixi-ts/Sprite */ "./js-compile/raw-pixi-ts/Sprite.js");
const ColorMatrixFilter_1 = __webpack_require__(/*! ../raw-pixi-ts/ColorMatrixFilter */ "./js-compile/raw-pixi-ts/ColorMatrixFilter.js");
const Text_1 = __webpack_require__(/*! ../raw-pixi-ts/Text */ "./js-compile/raw-pixi-ts/Text.js");
const Container_1 = __webpack_require__(/*! ../raw-pixi-ts/Container */ "./js-compile/raw-pixi-ts/Container.js");
const MouseEvent_1 = __webpack_require__(/*! ../raw-pixi-ts/MouseEvent */ "./js-compile/raw-pixi-ts/MouseEvent.js");
class FilterColor extends BaseExample_1.BaseExample {
    constructor(app, width, height) {
        super(app, width, height);
        this.handlePandaLoaded = (event) => {
            this.pandaTxt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            this.bg = new Sprite_1.Sprite(this.rotateTxt);
            this.bg.anchor.set(0.5);
            this.bg.x = this.sizew / 2;
            this.bg.y = this.sizeh / 2;
            this.filter = new ColorMatrixFilter_1.ColorMatrixFilter();
            const container = new Container_1.Container();
            container.x = this.sizew / 2;
            container.y = this.sizeh / 2;
            this.bgFront = new Sprite_1.Sprite(this.scenerotateTxt);
            this.bgFront.anchor.set(0.5);
            container.addChild(this.bgFront);
            this.light2 = new Sprite_1.Sprite(this.lightrotate2Txt);
            this.light2.anchor.set(0.5);
            container.addChild(this.light2);
            this.light1 = new Sprite_1.Sprite(this.lightrotate1Txt);
            this.light1.anchor.set(0.5);
            container.addChild(this.light1);
            this.panda = new Sprite_1.Sprite(this.pandaTxt);
            this.panda.anchor.set(0.5);
            container.addChild(this.panda);
            this.stage.addChild(container);
            this.stage.filters = [this.filter];
            this.count = 0;
            this.enabled = true;
            this.stage.addEventListener(MouseEvent_1.MouseEvent.POINTER_TAP, this.handlePointer);
            const help = new Text_1.Text('Click or tap to turn filters on / off.', {
                fontFamily: 'Arial',
                fontSize: 12,
                fontWeight: 'bold',
                fill: 'white',
            });
            help.y = this.sizeh - 25;
            help.x = 10;
            this.stage.addChild(help);
            this.app.ticker.add(this.runExample);
            this.exampleReady();
        };
        this.runExample = (delta) => {
            this.bg.rotation += 0.01;
            this.bgFront.rotation -= 0.01;
            this.light1.rotation += 0.02;
            this.light2.rotation += 0.01;
            this.panda.scale.x = 1 + Math.sin(this.count) * 0.04;
            this.panda.scale.y = 1 + Math.cos(this.count) * 0.04;
            this.count += 0.1;
            const { matrix } = this.filter;
            matrix[1] = Math.sin(this.count) * 3;
            matrix[2] = Math.cos(this.count);
            matrix[3] = Math.cos(this.count) * 1.5;
            matrix[4] = Math.sin(this.count / 3) * 2;
            matrix[5] = Math.sin(this.count / 2);
            matrix[6] = Math.sin(this.count / 4);
        };
        this.handlePointer = (event) => {
            this.enabled = !this.enabled;
            this.stage.filters = this.enabled ? [this.filter] : null;
        };
        this.handleLightRotate1Loaded = (event) => {
            this.lightrotate1Txt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/light_rotate_1.png"));
            this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleLightRotate1Loaded);
            this.loader.load();
        };
        this.handleRotateLoaded = (event) => {
            this.rotateTxt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/bg_scene_rotate.jpg"));
            this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleSceneRotateLoaded);
            this.loader.load();
        };
        this.handleSceneRotateLoaded = (event) => {
            this.scenerotateTxt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/light_rotate_2.png"));
            this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleLightRotate2Loaded);
            this.loader.load();
        };
        this.handleLightRotate2Loaded = (event) => {
            this.lightrotate2Txt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/panda.png"));
            this.loader.addEventListener(Event_1.Event.COMPLETE, this.handlePandaLoaded);
            this.loader.load();
        };
        this.backColor = 0;
        this.activateMask();
        this.stage.interactive = true;
        this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/bg_rotate.jpg"));
        this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleRotateLoaded);
        this.loader.load();
    }
    destructor() {
        super.destructor();
        this.bg.destroy(null);
        this.bg = null;
        this.bgFront.destroy(null);
        this.bgFront = null;
        this.light2.destroy(null);
        this.light2 = null;
        this.panda.destroy(null);
        this.panda = null;
        this.light1.destroy(null);
        this.light1 = null;
        this.filter.destroy();
        this.filter = null;
        this.app.ticker.remove(this.runExample, null);
        this.rotateTxt.destroy(null);
        this.rotateTxt = null;
        this.scenerotateTxt.destroy(null);
        this.scenerotateTxt = null;
        this.lightrotate2Txt.destroy(null);
        this.lightrotate2Txt = null;
        this.lightrotate1Txt.destroy(null);
        this.lightrotate1Txt = null;
        this.pandaTxt.destroy(null);
        this.pandaTxt = null;
    }
}
exports.FilterColor = FilterColor;


/***/ }),

/***/ "./js-compile/examples/FilterCrawlies.js":
/*!***********************************************!*\
  !*** ./js-compile/examples/FilterCrawlies.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseExample_1 = __webpack_require__(/*! ./BaseExample */ "./js-compile/examples/BaseExample.js");
const ResourceLoader_1 = __webpack_require__(/*! ../raw-pixi-ts/ResourceLoader */ "./js-compile/raw-pixi-ts/ResourceLoader.js");
const Texture_1 = __webpack_require__(/*! ../raw-pixi-ts/Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const Container_1 = __webpack_require__(/*! ../raw-pixi-ts/Container */ "./js-compile/raw-pixi-ts/Container.js");
const Rectangle_1 = __webpack_require__(/*! ../raw-pixi-ts/Rectangle */ "./js-compile/raw-pixi-ts/Rectangle.js");
const MouseEvent_1 = __webpack_require__(/*! ../raw-pixi-ts/MouseEvent */ "./js-compile/raw-pixi-ts/MouseEvent.js");
const Sprite_1 = __webpack_require__(/*! ../raw-pixi-ts/Sprite */ "./js-compile/raw-pixi-ts/Sprite.js");
const URLRequest_1 = __webpack_require__(/*! ../raw-pixi-ts/URLRequest */ "./js-compile/raw-pixi-ts/URLRequest.js");
const Event_1 = __webpack_require__(/*! ../raw-pixi-ts/Event */ "./js-compile/raw-pixi-ts/Event.js");
const BaseTexture_1 = __webpack_require__(/*! ../raw-pixi-ts/BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const Point_1 = __webpack_require__(/*! ../raw-pixi-ts/Point */ "./js-compile/raw-pixi-ts/Point.js");
const DisplacementFilter_1 = __webpack_require__(/*! ../raw-pixi-ts/DisplacementFilter */ "./js-compile/raw-pixi-ts/DisplacementFilter.js");
class FilterCrawlies extends BaseExample_1.BaseExample {
    constructor(app, width, height) {
        super(app, width, height);
        this.handleGrassLoaded = (event) => {
            this.grassTxt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            this.container = new Container_1.Container();
            this.stage.addChild(this.container);
            const padding = 100;
            this.bounds = new Rectangle_1.Rectangle(-padding, -padding, this.sizew + padding * 2, this.sizeh + padding * 2);
            for (let i = 0; i < 20; i++) {
                const maggot = new ExtendedSprite(this.maggotTxt);
                maggot.anchor.set(0.5);
                this.container.addChild(maggot);
                maggot.direction = Math.random() * Math.PI * 2;
                maggot.speed = 1;
                maggot.turnSpeed = Math.random() - 0.8;
                maggot.x = Math.random() * this.bounds.width;
                maggot.y = Math.random() * this.bounds.height;
                maggot.scale.set(1 + Math.random() * 0.3);
                maggot.original = new Point_1.Point();
                maggot.original.copyFrom(maggot.scale);
                this.maggots.push(maggot);
            }
            this.displacementSprite = new Sprite_1.Sprite(this.displacementTxt);
            const displacementFilter = new DisplacementFilter_1.DisplacementFilter(this.displacementSprite);
            this.stage.addChild(this.displacementSprite);
            this.container.filters = [displacementFilter];
            displacementFilter.scale.x = 110;
            displacementFilter.scale.y = 110;
            this.displacementSprite.anchor.set(0.5);
            this.ring = new Sprite_1.Sprite(this.ringTxt);
            this.ring.anchor.set(0.5);
            this.ring.visible = false;
            this.stage.addChild(this.ring);
            const bg = new Sprite_1.Sprite(this.grassTxt);
            bg.width = this.sizew;
            bg.height = this.sizeh;
            bg.alpha = 0.4;
            this.container.addChild(bg);
            this.stage.addEventListener(MouseEvent_1.MouseEvent.MOUSE_MOVE, this.onPointerMove);
            this.stage.addEventListener(MouseEvent_1.MouseEvent.TOUCH_MOVE, this.onPointerMove);
            this.app.ticker.add(this.runExample);
            this.exampleReady();
        };
        this.handleMaggotLoaded = (event) => {
            this.maggotTxt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest('examples/assets/bg_grass.jpg'));
            this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleGrassLoaded);
            this.loader.load();
        };
        this.handleRingLoaded = (event) => {
            this.ringTxt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest('examples/assets/maggot.png'));
            this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleMaggotLoaded);
            this.loader.load();
        };
        this.handleDisplacementLoaded = (event) => {
            this.displacementTxt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest('examples/assets/pixi-filters/ring.png'));
            this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleRingLoaded);
            this.loader.load();
        };
        this.handleRotateLoaded = (event) => {
            this.maggotTxt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest('examples/assets/pixi-filters/displace.png'));
            this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleDisplacementLoaded);
            this.loader.load();
        };
        this.onPointerMove = (event) => {
            this.ring.visible = true;
            this.displacementSprite.position.set(event.data.global.x - 25, event.data.global.y);
            this.ring.position.copyFrom(this.displacementSprite.position);
        };
        this.runExample = (delta) => {
            this.count += 0.05;
            for (let i = 0; i < this.maggots.length; i++) {
                const maggot = this.maggots[i];
                maggot.direction += maggot.turnSpeed * 0.01;
                maggot.x += Math.sin(maggot.direction) * maggot.speed;
                maggot.y += Math.cos(maggot.direction) * maggot.speed;
                maggot.rotation = -maggot.direction - Math.PI / 2;
                maggot.scale.x = maggot.original.x + Math.sin(this.count) * 0.2;
                if (maggot.x < this.bounds.x) {
                    maggot.x += this.bounds.width;
                }
                else if (maggot.x > this.bounds.x + this.bounds.width) {
                    maggot.x -= this.bounds.width;
                }
                if (maggot.y < this.bounds.y) {
                    maggot.y += this.bounds.height;
                }
                else if (maggot.y > this.bounds.y + this.bounds.height) {
                    maggot.y -= this.bounds.height;
                }
            }
        };
        this.activateMask();
        this.count = 0;
        this.maggots = [];
        this.stage.interactive = true;
        this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/bg_rotate.jpg"));
        this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleRotateLoaded);
        this.loader.load();
    }
    destructor() {
        super.destructor();
        this.maggotTxt.destroy(null);
        this.maggotTxt = null;
        this.displacementTxt.destroy(null);
        this.displacementTxt = null;
        this.ringTxt.destroy(null);
        this.ringTxt = null;
        this.grassTxt.destroy(null);
        this.grassTxt = null;
        this.maggots = null;
        this.ring.destroy(null);
        this.ring = null;
        this.app.ticker.remove(this.runExample, null);
        this.displacementSprite.destroy(null);
        this.displacementSprite = null;
        this.container.destroy(null);
        this.container = null;
    }
}
exports.FilterCrawlies = FilterCrawlies;
class ExtendedSprite extends Sprite_1.Sprite {
}


/***/ }),

/***/ "./js-compile/examples/FilterCustom.js":
/*!*********************************************!*\
  !*** ./js-compile/examples/FilterCustom.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseExample_1 = __webpack_require__(/*! ./BaseExample */ "./js-compile/examples/BaseExample.js");
const ResourceLoader_1 = __webpack_require__(/*! ../raw-pixi-ts/ResourceLoader */ "./js-compile/raw-pixi-ts/ResourceLoader.js");
const Texture_1 = __webpack_require__(/*! ../raw-pixi-ts/Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const URLRequest_1 = __webpack_require__(/*! ../raw-pixi-ts/URLRequest */ "./js-compile/raw-pixi-ts/URLRequest.js");
const Event_1 = __webpack_require__(/*! ../raw-pixi-ts/Event */ "./js-compile/raw-pixi-ts/Event.js");
const BaseTexture_1 = __webpack_require__(/*! ../raw-pixi-ts/BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const Sprite_1 = __webpack_require__(/*! ../raw-pixi-ts/Sprite */ "./js-compile/raw-pixi-ts/Sprite.js");
const URLLoader_1 = __webpack_require__(/*! ../raw-pixi-ts/URLLoader */ "./js-compile/raw-pixi-ts/URLLoader.js");
const Filter_1 = __webpack_require__(/*! ../raw-pixi-ts/Filter */ "./js-compile/raw-pixi-ts/Filter.js");
const Logger_1 = __webpack_require__(/*! ../raw-pixi-ts/Logger */ "./js-compile/raw-pixi-ts/Logger.js");
class FilterCustom extends BaseExample_1.BaseExample {
    constructor(app, width, height) {
        super(app, width, height);
        this.handleGrassLoaded = (event) => {
            this.grasstxt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            this.background = new Sprite_1.Sprite(this.grasstxt);
            this.background.width = this.app.screen.width;
            this.background.height = this.app.screen.height;
            this.app.stage.addChild(this.background);
            this.urlloader = new URLLoader_1.URLLoader();
            this.urlloader.addEventListener(Event_1.Event.COMPLETE, this.handleFragLoaded);
            this.urlloader.load(new URLRequest_1.URLRequest("examples/assets/pixi-filters/shader.frag"));
        };
        this.handleFragLoaded = (event) => {
            let fragdata = this.urlloader.data;
            Logger_1.trace(fragdata);
            this.filter = new Filter_1.Filter(null, fragdata, {
                customUniform: 0.0
            });
            this.background.filters = [this.filter];
            this.app.ticker.add(this.runExample);
        };
        this.runExample = (delta) => {
            this.filter.uniforms.customUniform += 0.04 * delta;
        };
        this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/bg_grass.jpg"));
        this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleGrassLoaded);
        this.loader.load();
    }
}
exports.FilterCustom = FilterCustom;


/***/ }),

/***/ "./js-compile/examples/FilterFlag.js":
/*!*******************************************!*\
  !*** ./js-compile/examples/FilterFlag.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseExample_1 = __webpack_require__(/*! ./BaseExample */ "./js-compile/examples/BaseExample.js");
const Container_1 = __webpack_require__(/*! ../raw-pixi-ts/Container */ "./js-compile/raw-pixi-ts/Container.js");
const ResourceLoader_1 = __webpack_require__(/*! ../raw-pixi-ts/ResourceLoader */ "./js-compile/raw-pixi-ts/ResourceLoader.js");
const Texture_1 = __webpack_require__(/*! ../raw-pixi-ts/Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const URLRequest_1 = __webpack_require__(/*! ../raw-pixi-ts/URLRequest */ "./js-compile/raw-pixi-ts/URLRequest.js");
const Event_1 = __webpack_require__(/*! ../raw-pixi-ts/Event */ "./js-compile/raw-pixi-ts/Event.js");
const BaseTexture_1 = __webpack_require__(/*! ../raw-pixi-ts/BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const Sprite_1 = __webpack_require__(/*! ../raw-pixi-ts/Sprite */ "./js-compile/raw-pixi-ts/Sprite.js");
const WebGLSettings_1 = __webpack_require__(/*! ../raw-pixi-ts/WebGLSettings */ "./js-compile/raw-pixi-ts/WebGLSettings.js");
const DisplacementFilter_1 = __webpack_require__(/*! ../raw-pixi-ts/DisplacementFilter */ "./js-compile/raw-pixi-ts/DisplacementFilter.js");
class FilterFlag extends BaseExample_1.BaseExample {
    constructor(app, width, height) {
        super(app, width, height);
        this.handleDisplacementLoaded = (event) => {
            this.repeatTxt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            const container = new Container_1.Container();
            this.stage.addChild(container);
            const flag = new Sprite_1.Sprite(this.flagTxt);
            container.addChild(flag);
            flag.x = 100;
            flag.y = 100;
            this.displacementSprite = new Sprite_1.Sprite(this.repeatTxt);
            this.displacementSprite.texture.baseTexture.wrapMode = WebGLSettings_1.WebGLSettings.WRAP_MODES.REPEAT;
            const displacementFilter = new DisplacementFilter_1.DisplacementFilter(this.displacementSprite);
            displacementFilter.padding = 10;
            this.displacementSprite.position = flag.position;
            this.stage.addChild(this.displacementSprite);
            flag.filters = [displacementFilter];
            displacementFilter.scale.x = 30;
            displacementFilter.scale.y = 60;
            this.app.ticker.add(this.runExample);
            this.exampleReady();
        };
        this.runExample = (delta) => {
            this.displacementSprite.x++;
            if (this.displacementSprite.x > this.displacementSprite.width) {
                this.displacementSprite.x = 0;
            }
        };
        this.handleRotateLoaded = (event) => {
            this.flagTxt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest('examples/assets/pixi-filters/displacement_map_repeat.jpg'));
            this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleDisplacementLoaded);
            this.loader.load();
        };
        this.stage.interactive = true;
        this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/pixi-filters/flag.png"));
        this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleRotateLoaded);
        this.loader.load();
    }
    destructor() {
        super.destructor();
        this.flagTxt.destroy(null);
        this.flagTxt = null;
        this.repeatTxt.destroy(null);
        this.repeatTxt = null;
        this.displacementSprite.destroy(null);
        this.displacementSprite = null;
        this.app.ticker.remove(this.runExample, null);
    }
}
exports.FilterFlag = FilterFlag;


/***/ }),

/***/ "./js-compile/examples/FilterShadow.js":
/*!*********************************************!*\
  !*** ./js-compile/examples/FilterShadow.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseExample_1 = __webpack_require__(/*! ./BaseExample */ "./js-compile/examples/BaseExample.js");
const URLLoader_1 = __webpack_require__(/*! ../raw-pixi-ts/URLLoader */ "./js-compile/raw-pixi-ts/URLLoader.js");
const Event_1 = __webpack_require__(/*! ../raw-pixi-ts/Event */ "./js-compile/raw-pixi-ts/Event.js");
const URLRequest_1 = __webpack_require__(/*! ../raw-pixi-ts/URLRequest */ "./js-compile/raw-pixi-ts/URLRequest.js");
const ResourceLoader_1 = __webpack_require__(/*! ../raw-pixi-ts/ResourceLoader */ "./js-compile/raw-pixi-ts/ResourceLoader.js");
const Texture_1 = __webpack_require__(/*! ../raw-pixi-ts/Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const BaseTexture_1 = __webpack_require__(/*! ../raw-pixi-ts/BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const Spritesheet_1 = __webpack_require__(/*! ../raw-pixi-ts/Spritesheet */ "./js-compile/raw-pixi-ts/Spritesheet.js");
const AnimatedSprite_1 = __webpack_require__(/*! ../raw-pixi-ts/AnimatedSprite */ "./js-compile/raw-pixi-ts/AnimatedSprite.js");
const Filter_1 = __webpack_require__(/*! ../raw-pixi-ts/Filter */ "./js-compile/raw-pixi-ts/Filter.js");
class FilterShadow extends BaseExample_1.BaseExample {
    constructor(app, width, height) {
        super(app, width, height);
        this.onAnimationParsed = (textures) => {
            this.app.stage.interactive = true;
            const frames = [];
            for (let i = 0; i < 30; i++) {
                const val = i < 10 ? `0${i}` : i;
                frames.push(textures[`rollSequence00${val}.png`]);
            }
            this.anim = new AnimatedSprite_1.AnimatedSprite(frames);
            this.anim.x = this.app.screen.width / 2;
            this.anim.y = this.app.screen.height / 2;
            this.anim.anchor.set(0.5);
            this.anim.animationSpeed = 0.5;
            this.anim.play();
            this.app.stage.addChild(this.anim);
            this.filter = new Filter_1.Filter(FilterShadow.myVertex, FilterShadow.myFragment);
            this.filter.uniforms.shadowDirection = [0.1, 0.5];
            this.filter.uniforms.floorY = this.anim.height * 2;
            this.filter.padding = 200;
            this.anim.filters = [this.filter];
            this.app.ticker.add(this.runExample);
        };
        this.runExample = (delta) => {
            this.filter.uniforms.floorY = this.app.renderer.plugins.interaction.mouse.global.y;
        };
        this.handleJsonLoaded = (event) => {
            this.jsondata = JSON.parse(this.urlloader.data);
            this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/spritesheet/fighter.png"));
            this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleRotateLoaded);
            this.loader.load();
        };
        this.handleRotateLoaded = (event) => {
            this.txt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            let spritesheet = new Spritesheet_1.Spritesheet(this.txt, this.jsondata);
            spritesheet.parse(this.onAnimationParsed);
        };
        this.urlloader = new URLLoader_1.URLLoader();
        this.urlloader.addEventListener(Event_1.Event.COMPLETE, this.handleJsonLoaded);
        this.urlloader.load(new URLRequest_1.URLRequest("examples/assets/spritesheet/fighter.json"));
    }
}
FilterShadow.myVertex = `
        attribute vec2 aVertexPosition;
        attribute vec2 aTextureCoord;
        uniform mat3 projectionMatrix;
        varying vec2 vTextureCoord;
        void main(void) {
            gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);
            vTextureCoord = aTextureCoord;
        }
    `;
FilterShadow.myFragment = `
        varying vec2 vTextureCoord;
        uniform sampler2D uSampler;
        uniform vec4 inputSize;
        uniform vec4 outputFrame;
        uniform vec2 shadowDirection;
        uniform float floorY;
        void main(void) {
            //1. get the screen coordinate
            vec2 screenCoord = vTextureCoord * inputSize.xy + outputFrame.xy;
            //2. calculate Y shift of our dimension vector
            vec2 shadow;
            //shadow coordinate system is a bit skewed, but it has to be the same for screenCoord.y = floorY
            float paramY = (screenCoord.y - floorY) / shadowDirection.y;
            shadow.y = paramY + floorY;
            shadow.x = screenCoord.x + paramY * shadowDirection.x;
            vec2 bodyFilterCoord = (shadow - outputFrame.xy) * inputSize.zw; // same as / inputSize.xy
            vec4 originalColor = texture2D(uSampler, vTextureCoord);
            vec4 shadowColor = texture2D(uSampler, bodyFilterCoord);
            shadowColor.rgb = vec3(0.0);
            shadowColor.a *= 0.5;
            // normal blend mode coefficients (1, 1-src_alpha)
            // shadow is destination (backdrop), original is source
            gl_FragColor = originalColor + shadowColor * (1.0 - originalColor.a);
        }
    `;
exports.FilterShadow = FilterShadow;


/***/ }),

/***/ "./js-compile/examples/MaskFilter.js":
/*!*******************************************!*\
  !*** ./js-compile/examples/MaskFilter.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseExample_1 = __webpack_require__(/*! ./BaseExample */ "./js-compile/examples/BaseExample.js");
const ResourceLoader_1 = __webpack_require__(/*! ../raw-pixi-ts/ResourceLoader */ "./js-compile/raw-pixi-ts/ResourceLoader.js");
const Texture_1 = __webpack_require__(/*! ../raw-pixi-ts/Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const URLRequest_1 = __webpack_require__(/*! ../raw-pixi-ts/URLRequest */ "./js-compile/raw-pixi-ts/URLRequest.js");
const Event_1 = __webpack_require__(/*! ../raw-pixi-ts/Event */ "./js-compile/raw-pixi-ts/Event.js");
const BaseTexture_1 = __webpack_require__(/*! ../raw-pixi-ts/BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const Graphics_1 = __webpack_require__(/*! ../raw-pixi-ts/Graphics */ "./js-compile/raw-pixi-ts/Graphics.js");
const BlurFilter_1 = __webpack_require__(/*! ../raw-pixi-ts/BlurFilter */ "./js-compile/raw-pixi-ts/BlurFilter.js");
const Rectangle_1 = __webpack_require__(/*! ../raw-pixi-ts/Rectangle */ "./js-compile/raw-pixi-ts/Rectangle.js");
const WebGLSettings_1 = __webpack_require__(/*! ../raw-pixi-ts/WebGLSettings */ "./js-compile/raw-pixi-ts/WebGLSettings.js");
const Sprite_1 = __webpack_require__(/*! ../raw-pixi-ts/Sprite */ "./js-compile/raw-pixi-ts/Sprite.js");
const MouseEvent_1 = __webpack_require__(/*! ../raw-pixi-ts/MouseEvent */ "./js-compile/raw-pixi-ts/MouseEvent.js");
class MaskFilter extends BaseExample_1.BaseExample {
    constructor(app, width, height) {
        super(app, width, height);
        this.handleRotateLoaded = (event) => {
            this.flagTxt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            const radius = 100;
            const blurSize = 32;
            const background = new Sprite_1.Sprite(this.flagTxt);
            this.stage.addChild(background);
            background.width = this.sizew;
            background.height = this.sizeh;
            const circle = new Graphics_1.Graphics()
                .beginFill(0xFF0000)
                .drawCircle(radius + blurSize, radius + blurSize, radius)
                .endFill();
            circle.filters = [new BlurFilter_1.BlurFilter(blurSize)];
            const bounds = new Rectangle_1.Rectangle(0, 0, (radius + blurSize) * 2, (radius + blurSize) * 2);
            const texture = this.app.renderer.generateTexture(circle, WebGLSettings_1.WebGLSettings.SCALE_MODES.NEAREST, 1, bounds);
            this.focus = new Sprite_1.Sprite(texture);
            this.stage.addChild(this.focus);
            background.mask = this.focus;
            this.stage.interactive = true;
            this.stage.addEventListener(MouseEvent_1.MouseEvent.MOUSE_MOVE, this.pointerMove);
            this.exampleReady();
        };
        this.pointerMove = (event) => {
            this.focus.position.x = event.data.global.x - this.focus.width / 2;
            this.focus.position.y = event.data.global.y - this.focus.height / 2;
        };
        this.backColor = 0;
        this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/bg_grass.jpg"));
        this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleRotateLoaded);
        this.loader.load();
    }
    destructor() {
        super.destructor();
        this.flagTxt.destroy(null);
        this.flagTxt = null;
        this.focus.destroy(null);
        this.focus = null;
    }
}
exports.MaskFilter = MaskFilter;


/***/ }),

/***/ "./js-compile/examples/MeshAdvanced.js":
/*!*********************************************!*\
  !*** ./js-compile/examples/MeshAdvanced.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseExample_1 = __webpack_require__(/*! ./BaseExample */ "./js-compile/examples/BaseExample.js");
const Texture_1 = __webpack_require__(/*! ../raw-pixi-ts/Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const BaseTexture_1 = __webpack_require__(/*! ../raw-pixi-ts/BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const Event_1 = __webpack_require__(/*! ../raw-pixi-ts/Event */ "./js-compile/raw-pixi-ts/Event.js");
const ResourceLoader_1 = __webpack_require__(/*! ../raw-pixi-ts/ResourceLoader */ "./js-compile/raw-pixi-ts/ResourceLoader.js");
const URLRequest_1 = __webpack_require__(/*! ../raw-pixi-ts/URLRequest */ "./js-compile/raw-pixi-ts/URLRequest.js");
const Point_1 = __webpack_require__(/*! ../raw-pixi-ts/Point */ "./js-compile/raw-pixi-ts/Point.js");
const SimpleRope_1 = __webpack_require__(/*! ../raw-pixi-ts/SimpleRope */ "./js-compile/raw-pixi-ts/SimpleRope.js");
const Graphics_1 = __webpack_require__(/*! ../raw-pixi-ts/Graphics */ "./js-compile/raw-pixi-ts/Graphics.js");
class MeshAdvanced extends BaseExample_1.BaseExample {
    constructor(app, width, height) {
        super(app, width, height);
        this.runExample = (delta) => {
            this.count += 0.1;
            for (let i = 0; i < this.points.length; i++) {
                this.points[i].y = Math.sin((i * 0.5) + this.count) * 30;
                this.points[i].x = i * this.ropeLength + Math.cos((i * 0.3) + this.count) * 20;
            }
            this.renderPoints();
        };
        this.handlePlaneLoaded = (event) => {
            this.planeTxt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            this.count = 0;
            this.ropeLength = 45;
            this.points = [];
            for (let i = 0; i < 25; i++) {
                this.points.push(new Point_1.Point(i * this.ropeLength, 0));
            }
            const strip = new SimpleRope_1.SimpleRope(this.planeTxt, this.points);
            strip.x = -40;
            strip.y = 300;
            this.app.stage.addChild(strip);
            this.g = new Graphics_1.Graphics();
            this.g.x = strip.x;
            this.g.y = strip.y;
            this.app.stage.addChild(this.g);
            this.app.ticker.add(this.runExample);
        };
        this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/snake.png"));
        this.loader.addEventListener(Event_1.Event.COMPLETE, this.handlePlaneLoaded);
        this.loader.load();
    }
    renderPoints() {
        this.g.clear();
        this.g.lineStyle(2, 0xffc2c2);
        this.g.moveTo(this.points[0].x, this.points[0].y);
        for (let i = 1; i < this.points.length; i++) {
            this.g.lineTo(this.points[i].x, this.points[i].y);
        }
        for (let i = 1; i < this.points.length; i++) {
            this.g.beginFill(0xff0022);
            this.g.drawCircle(this.points[i].x, this.points[i].y, 10);
            this.g.endFill();
        }
    }
}
exports.MeshAdvanced = MeshAdvanced;


/***/ }),

/***/ "./js-compile/examples/MeshBasic.js":
/*!******************************************!*\
  !*** ./js-compile/examples/MeshBasic.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseExample_1 = __webpack_require__(/*! ./BaseExample */ "./js-compile/examples/BaseExample.js");
const ResourceLoader_1 = __webpack_require__(/*! ../raw-pixi-ts/ResourceLoader */ "./js-compile/raw-pixi-ts/ResourceLoader.js");
const Texture_1 = __webpack_require__(/*! ../raw-pixi-ts/Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const URLRequest_1 = __webpack_require__(/*! ../raw-pixi-ts/URLRequest */ "./js-compile/raw-pixi-ts/URLRequest.js");
const Event_1 = __webpack_require__(/*! ../raw-pixi-ts/Event */ "./js-compile/raw-pixi-ts/Event.js");
const BaseTexture_1 = __webpack_require__(/*! ../raw-pixi-ts/BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const Point_1 = __webpack_require__(/*! ../raw-pixi-ts/Point */ "./js-compile/raw-pixi-ts/Point.js");
const SimpleRope_1 = __webpack_require__(/*! ../raw-pixi-ts/SimpleRope */ "./js-compile/raw-pixi-ts/SimpleRope.js");
const Container_1 = __webpack_require__(/*! ../raw-pixi-ts/Container */ "./js-compile/raw-pixi-ts/Container.js");
class MeshBasic extends BaseExample_1.BaseExample {
    constructor(app, width, height) {
        super(app, width, height);
        this.runExample = (delta) => {
            this.count += 0.1;
            for (let i = 0; i < this.points.length; i++) {
                this.points[i].y = Math.sin((i * 0.5) + this.count) * 30;
                this.points[i].x = i * this.ropeLength + Math.cos((i * 0.3) + this.count) * 20;
            }
        };
        this.handlePlaneLoaded = (event) => {
            this.planeTxt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            this.count = 0;
            this.ropeLength = 918 / 20;
            this.points = [];
            for (let i = 0; i < 20; i++) {
                this.points.push(new Point_1.Point(i * this.ropeLength, 0));
            }
            const strip = new SimpleRope_1.SimpleRope(this.planeTxt, this.points);
            strip.x = -459;
            const snakeContainer = new Container_1.Container();
            snakeContainer.x = 400;
            snakeContainer.y = 300;
            snakeContainer.scale.set(800 / 1100);
            this.app.stage.addChild(snakeContainer);
            snakeContainer.addChild(strip);
            this.app.ticker.add(this.runExample);
        };
        this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/snake.png"));
        this.loader.addEventListener(Event_1.Event.COMPLETE, this.handlePlaneLoaded);
        this.loader.load();
    }
}
exports.MeshBasic = MeshBasic;


/***/ }),

/***/ "./js-compile/examples/MeshColoredTriangle.js":
/*!****************************************************!*\
  !*** ./js-compile/examples/MeshColoredTriangle.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseExample_1 = __webpack_require__(/*! ./BaseExample */ "./js-compile/examples/BaseExample.js");
const Geometry_1 = __webpack_require__(/*! ../raw-pixi-ts/Geometry */ "./js-compile/raw-pixi-ts/Geometry.js");
const Program_1 = __webpack_require__(/*! ../raw-pixi-ts/Program */ "./js-compile/raw-pixi-ts/Program.js");
const Shader_1 = __webpack_require__(/*! ../raw-pixi-ts/Shader */ "./js-compile/raw-pixi-ts/Shader.js");
const Mesh_1 = __webpack_require__(/*! ../raw-pixi-ts/Mesh */ "./js-compile/raw-pixi-ts/Mesh.js");
class MeshColoredTriangle extends BaseExample_1.BaseExample {
    constructor(app, width, height) {
        super(app, width, height);
        this.runExample = (delta) => {
            this.triangle.rotation += 0.01;
        };
        const geometry = new Geometry_1.Geometry();
        geometry.addAttribute('aVertexPosition', // the attribute name
        [-100, -50,
            100, -50,
            0.0, 100.0], // x, y
        2); // the size of the attribute
        geometry.addAttribute('aColor', // the attribute name
        [1, 0, 0,
            0, 1, 0,
            0, 0, 1], // r, g, b
        3); // the size of the attribute
        let vx = `
            precision mediump float;
            attribute vec2 aVertexPosition;
            attribute vec3 aColor;    
            uniform mat3 translationMatrix;
            uniform mat3 projectionMatrix;    
            varying vec3 vColor;    
            void main() {    
                vColor = aColor;
                gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);    
            }`;
        let fx = `precision mediump float;
            varying vec3 vColor;    
            void main() {
                gl_FragColor = vec4(vColor, 1.0);
            }    
            `;
        let program = new Program_1.Program(vx, fx);
        const shader = new Shader_1.Shader(program, null);
        this.triangle = new Mesh_1.Mesh(geometry, shader);
        this.triangle.position.set(400, 300);
        this.triangle.scale.set(2);
        app.stage.addChild(this.triangle);
        this.app.ticker.add(this.runExample);
    }
}
exports.MeshColoredTriangle = MeshColoredTriangle;


/***/ }),

/***/ "./js-compile/examples/MeshGeometry.js":
/*!*********************************************!*\
  !*** ./js-compile/examples/MeshGeometry.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseExample_1 = __webpack_require__(/*! ./BaseExample */ "./js-compile/examples/BaseExample.js");
const ResourceLoader_1 = __webpack_require__(/*! ../raw-pixi-ts/ResourceLoader */ "./js-compile/raw-pixi-ts/ResourceLoader.js");
const Texture_1 = __webpack_require__(/*! ../raw-pixi-ts/Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const URLRequest_1 = __webpack_require__(/*! ../raw-pixi-ts/URLRequest */ "./js-compile/raw-pixi-ts/URLRequest.js");
const Event_1 = __webpack_require__(/*! ../raw-pixi-ts/Event */ "./js-compile/raw-pixi-ts/Event.js");
const BaseTexture_1 = __webpack_require__(/*! ../raw-pixi-ts/BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const Geometry_1 = __webpack_require__(/*! ../raw-pixi-ts/Geometry */ "./js-compile/raw-pixi-ts/Geometry.js");
const Program_1 = __webpack_require__(/*! ../raw-pixi-ts/Program */ "./js-compile/raw-pixi-ts/Program.js");
const Mesh_1 = __webpack_require__(/*! ../raw-pixi-ts/Mesh */ "./js-compile/raw-pixi-ts/Mesh.js");
const Shader_1 = __webpack_require__(/*! ../raw-pixi-ts/Shader */ "./js-compile/raw-pixi-ts/Shader.js");
class MeshGeometry extends BaseExample_1.BaseExample {
    constructor(app, width, height) {
        super(app, width, height);
        this.handleTxt3Loaded = (event) => {
            this.txt3 = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            const geometry = new Geometry_1.Geometry();
            geometry.addAttribute('aVertexPosition', // the attribute name
            [-100, -100,
                100, -100,
                100, 100], // x, y
            2); // the size of the attribute    
            geometry.addAttribute('aUvs', // the attribute name
            [0, 0,
                1, 0,
                1, 1], // u, v
            2); // the size of the attribute    
            const program = Program_1.Program.from(`    
            precision mediump float;    
            attribute vec2 aVertexPosition;
            attribute vec2 aUvs;    
            uniform mat3 translationMatrix;
            uniform mat3 projectionMatrix;    
            varying vec2 vUvs;    
            void main() {    
                vUvs = aUvs;
                gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);    
            }`, `precision mediump float;    
            varying vec2 vUvs;    
            uniform sampler2D uSamplerTexture;    
            void main() {    
                gl_FragColor = texture2D(uSamplerTexture, vUvs);
            }    
        `);
            this.triangle = new Mesh_1.Mesh(geometry, new Shader_1.Shader(program, {
                uSamplerTexture: this.txt1,
            }));
            this.triangle2 = new Mesh_1.Mesh(geometry, new Shader_1.Shader(program, {
                uSamplerTexture: this.txt2,
            }));
            this.triangle3 = new Mesh_1.Mesh(geometry, new Shader_1.Shader(program, {
                uSamplerTexture: this.txt3,
            }));
            this.triangle.position.set(400, 300);
            this.triangle.scale.set(2);
            this.triangle2.position.set(200, 100);
            this.triangle3.position.set(500, 400);
            this.triangle3.scale.set(3);
            this.app.stage.addChild(this.triangle3);
            this.app.stage.addChild(this.triangle2);
            this.app.stage.addChild(this.triangle);
            this.app.ticker.add(this.runExample);
        };
        this.runExample = (delta) => {
            this.triangle.rotation += 0.01;
            this.triangle2.rotation -= 0.01;
            this.triangle3.rotation -= 0.005;
        };
        this.handleTxt2Loaded = (event) => {
            this.txt2 = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/bg_displacement.jpg"));
            this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleTxt3Loaded);
            this.loader.load();
        };
        this.handleTxt1Loaded = (event) => {
            this.txt1 = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/bg_rotate.jpg"));
            this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleTxt2Loaded);
            this.loader.load();
        };
        this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/bg_scene_rotate.jpg"));
        this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleTxt1Loaded);
        this.loader.load();
    }
}
exports.MeshGeometry = MeshGeometry;


/***/ }),

/***/ "./js-compile/examples/MeshShader.js":
/*!*******************************************!*\
  !*** ./js-compile/examples/MeshShader.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseExample_1 = __webpack_require__(/*! ./BaseExample */ "./js-compile/examples/BaseExample.js");
const ResourceLoader_1 = __webpack_require__(/*! ../raw-pixi-ts/ResourceLoader */ "./js-compile/raw-pixi-ts/ResourceLoader.js");
const Texture_1 = __webpack_require__(/*! ../raw-pixi-ts/Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const URLRequest_1 = __webpack_require__(/*! ../raw-pixi-ts/URLRequest */ "./js-compile/raw-pixi-ts/URLRequest.js");
const Event_1 = __webpack_require__(/*! ../raw-pixi-ts/Event */ "./js-compile/raw-pixi-ts/Event.js");
const BaseTexture_1 = __webpack_require__(/*! ../raw-pixi-ts/BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const Geometry_1 = __webpack_require__(/*! ../raw-pixi-ts/Geometry */ "./js-compile/raw-pixi-ts/Geometry.js");
const Program_1 = __webpack_require__(/*! ../raw-pixi-ts/Program */ "./js-compile/raw-pixi-ts/Program.js");
const Shader_1 = __webpack_require__(/*! ../raw-pixi-ts/Shader */ "./js-compile/raw-pixi-ts/Shader.js");
const Mesh_1 = __webpack_require__(/*! ../raw-pixi-ts/Mesh */ "./js-compile/raw-pixi-ts/Mesh.js");
class MeshShader extends BaseExample_1.BaseExample {
    constructor(app, width, height) {
        super(app, width, height);
        this.handleTxt1Loaded = (event) => {
            this.txt1 = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            const geometry = new Geometry_1.Geometry();
            geometry.addAttribute('aVertexPosition', // the attribute name
            [-100, -100,
                100, -100,
                100, 100]); // x, y
            geometry.addAttribute('aUvs', // the attribute name
            [0, 0,
                1, 0,
                1, 1]); // u, v
            let vx = `
            precision mediump float;
            attribute vec2 aVertexPosition;
            attribute vec2 aUvs;
            uniform mat3 translationMatrix;
            uniform mat3 projectionMatrix;
            varying vec2 vUvs;
            void main() {
                vUvs = aUvs;
                gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);
            }`;
            let fx = `precision mediump float;
            varying vec2 vUvs;
            uniform sampler2D uSampler2;
            void main() {
                gl_FragColor = texture2D(uSampler2, vUvs);
            }        
            `;
            let program = new Program_1.Program(vx, fx);
            const shader = new Shader_1.Shader(program, { uSampler2: this.txt1 });
            let vx2 = `
            precision mediump float;    
            attribute vec2 aVertexPosition;
            attribute vec2 aUvs;    
            uniform mat3 translationMatrix;
            uniform mat3 projectionMatrix;    
            varying vec2 vUvs;    
            void main() {    
                vUvs = aUvs;
                gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);    
            }`;
            let fx2 = `precision mediump float;
            varying vec2 vUvs;    
            uniform sampler2D uSampler2;    
            void main() {    
                gl_FragColor = texture2D(uSampler2, vUvs);
                gl_FragColor.r += (abs(sin(gl_FragCoord.x * 0.06)) * 0.5) * 2.;
                gl_FragColor.g += (abs(cos(gl_FragCoord.y * 0.06)) * 0.5) * 2.;
            }    
            `;
            let program2 = new Program_1.Program(vx2, fx2);
            const shader2 = new Shader_1.Shader(program2, { uSampler2: this.txt1 });
            this.triangle = new Mesh_1.Mesh(geometry, shader);
            this.triangle2 = new Mesh_1.Mesh(geometry, shader2);
            this.triangle.position.set(400, 300);
            this.triangle.scale.set(2);
            this.triangle2.position.set(500, 400);
            this.triangle2.scale.set(3);
            this.app.stage.addChild(this.triangle2);
            this.app.stage.addChild(this.triangle);
            this.app.ticker.add(this.runExample);
        };
        this.runExample = (delta) => {
            this.triangle.rotation += 0.01;
            this.triangle2.rotation -= 0.005;
        };
        this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/bg_scene_rotate.jpg"));
        this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleTxt1Loaded);
        this.loader.load();
    }
}
exports.MeshShader = MeshShader;


/***/ }),

/***/ "./js-compile/examples/MeshTextured.js":
/*!*********************************************!*\
  !*** ./js-compile/examples/MeshTextured.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseExample_1 = __webpack_require__(/*! ./BaseExample */ "./js-compile/examples/BaseExample.js");
const ResourceLoader_1 = __webpack_require__(/*! ../raw-pixi-ts/ResourceLoader */ "./js-compile/raw-pixi-ts/ResourceLoader.js");
const Texture_1 = __webpack_require__(/*! ../raw-pixi-ts/Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const URLRequest_1 = __webpack_require__(/*! ../raw-pixi-ts/URLRequest */ "./js-compile/raw-pixi-ts/URLRequest.js");
const Event_1 = __webpack_require__(/*! ../raw-pixi-ts/Event */ "./js-compile/raw-pixi-ts/Event.js");
const BaseTexture_1 = __webpack_require__(/*! ../raw-pixi-ts/BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const Geometry_1 = __webpack_require__(/*! ../raw-pixi-ts/Geometry */ "./js-compile/raw-pixi-ts/Geometry.js");
const Program_1 = __webpack_require__(/*! ../raw-pixi-ts/Program */ "./js-compile/raw-pixi-ts/Program.js");
const Shader_1 = __webpack_require__(/*! ../raw-pixi-ts/Shader */ "./js-compile/raw-pixi-ts/Shader.js");
const Mesh_1 = __webpack_require__(/*! ../raw-pixi-ts/Mesh */ "./js-compile/raw-pixi-ts/Mesh.js");
class MeshTextured extends BaseExample_1.BaseExample {
    constructor(app, width, height) {
        super(app, width, height);
        this.handlePlaneLoaded = (event) => {
            this.planeTxt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            const geometry = new Geometry_1.Geometry();
            geometry.addAttribute('aVertexPosition', // the attribute name
            [-100, -100,
                100, -100,
                100, 100], // x, y
            2); // the size of the attribute
            geometry.addAttribute('aColor', // the attribute name
            [1, 0, 0,
                0, 1, 0,
                0, 0, 1], // r, g, b
            3); // the size of the attribute
            geometry.addAttribute('aUvs', // the attribute name
            [0, 0,
                1, 0,
                1, 1], // u, v
            2); // the size of the attribute
            const vertexSrc = `
            precision mediump float;
            attribute vec2 aVertexPosition;
            attribute vec3 aColor;
            attribute vec2 aUvs;
            uniform mat3 translationMatrix;
            uniform mat3 projectionMatrix;
            varying vec2 vUvs;
            varying vec3 vColor;
            void main() {
                vUvs = aUvs;
                vColor = aColor;
                gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);
            }`;
            const fragmentSrc = `
            precision mediump float;
            varying vec3 vColor;
            varying vec2 vUvs;
            uniform sampler2D uSampler2;
            void main() {
                gl_FragColor = texture2D(uSampler2, vUvs) * vec4(vColor, 1.0);
            }`;
            const uniforms = { uSampler2: this.planeTxt };
            let program = new Program_1.Program(vertexSrc, fragmentSrc);
            const shader = new Shader_1.Shader(program, uniforms);
            this.triangle = new Mesh_1.Mesh(geometry, shader);
            this.triangle.position.set(400, 300);
            this.triangle.scale.set(2);
            this.app.stage.addChild(this.triangle);
            this.app.ticker.add(this.runExample);
        };
        this.runExample = (delta) => {
            this.triangle.rotation += 0.01;
        };
        this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/bg_scene_rotate.jpg"));
        this.loader.addEventListener(Event_1.Event.COMPLETE, this.handlePlaneLoaded);
        this.loader.load();
    }
}
exports.MeshTextured = MeshTextured;


/***/ }),

/***/ "./js-compile/examples/MeshTriangle.js":
/*!*********************************************!*\
  !*** ./js-compile/examples/MeshTriangle.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseExample_1 = __webpack_require__(/*! ./BaseExample */ "./js-compile/examples/BaseExample.js");
const Geometry_1 = __webpack_require__(/*! ../raw-pixi-ts/Geometry */ "./js-compile/raw-pixi-ts/Geometry.js");
const Shader_1 = __webpack_require__(/*! ../raw-pixi-ts/Shader */ "./js-compile/raw-pixi-ts/Shader.js");
const Program_1 = __webpack_require__(/*! ../raw-pixi-ts/Program */ "./js-compile/raw-pixi-ts/Program.js");
const Mesh_1 = __webpack_require__(/*! ../raw-pixi-ts/Mesh */ "./js-compile/raw-pixi-ts/Mesh.js");
class MeshTriangle extends BaseExample_1.BaseExample {
    constructor(app, width, height) {
        super(app, width, height);
        this.runExample = (delta) => {
            this.triangle.rotation += 0.01;
        };
        const geometry = new Geometry_1.Geometry();
        geometry.addAttribute('aVertexPosition', [-100, -50, 100, -50, 0, 100]);
        let vx = `
            precision mediump float;
            attribute vec2 aVertexPosition;
            uniform mat3 translationMatrix;
            uniform mat3 projectionMatrix;
            void main() {
                gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);
            }`;
        let fx = `precision mediump float;
            void main() {
                gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
            }
        `;
        let program = new Program_1.Program(vx, fx);
        const shader = new Shader_1.Shader(program, null);
        this.triangle = new Mesh_1.Mesh(geometry, shader);
        this.triangle.position.set(400, 300);
        app.stage.addChild(this.triangle);
        this.app.ticker.add(this.runExample);
    }
}
exports.MeshTriangle = MeshTriangle;


/***/ }),

/***/ "./js-compile/examples/MeshUniforms.js":
/*!*********************************************!*\
  !*** ./js-compile/examples/MeshUniforms.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseExample_1 = __webpack_require__(/*! ./BaseExample */ "./js-compile/examples/BaseExample.js");
const Mesh_1 = __webpack_require__(/*! ../raw-pixi-ts/Mesh */ "./js-compile/raw-pixi-ts/Mesh.js");
const ResourceLoader_1 = __webpack_require__(/*! ../raw-pixi-ts/ResourceLoader */ "./js-compile/raw-pixi-ts/ResourceLoader.js");
const Texture_1 = __webpack_require__(/*! ../raw-pixi-ts/Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const URLRequest_1 = __webpack_require__(/*! ../raw-pixi-ts/URLRequest */ "./js-compile/raw-pixi-ts/URLRequest.js");
const Event_1 = __webpack_require__(/*! ../raw-pixi-ts/Event */ "./js-compile/raw-pixi-ts/Event.js");
const BaseTexture_1 = __webpack_require__(/*! ../raw-pixi-ts/BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const Geometry_1 = __webpack_require__(/*! ../raw-pixi-ts/Geometry */ "./js-compile/raw-pixi-ts/Geometry.js");
const Program_1 = __webpack_require__(/*! ../raw-pixi-ts/Program */ "./js-compile/raw-pixi-ts/Program.js");
const Shader_1 = __webpack_require__(/*! ../raw-pixi-ts/Shader */ "./js-compile/raw-pixi-ts/Shader.js");
class MeshUniforms extends BaseExample_1.BaseExample {
    constructor(app, width, height) {
        super(app, width, height);
        this.handlePlaneLoaded = (event) => {
            this.planeTxt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            const geometry = new Geometry_1.Geometry();
            geometry.addAttribute('aVertexPosition', // the attribute name
            [-100, -100,
                100, -100,
                100, 100,
                -100, 100], // x, y
            2); // the size of the attribute
            geometry.addAttribute('aUvs', // the attribute name
            [0, 0,
                1, 0,
                1, 1,
                0, 1], // u, v
            2); // the size of the attribute
            geometry.addIndex([0, 1, 2, 0, 2, 3]);
            const vertexSrc = `
            precision mediump float;    
            attribute vec2 aVertexPosition;
            attribute vec2 aUvs;    
            uniform mat3 translationMatrix;
            uniform mat3 projectionMatrix;    
            varying vec2 vUvs;    
            void main() {    
                vUvs = aUvs;
                gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);    
            }`;
            const fragmentSrc = `    
            precision mediump float;    
            varying vec2 vUvs;    
            uniform sampler2D uSampler2;
            uniform float time;    
            void main() {    
                gl_FragColor = texture2D(uSampler2, vUvs + sin( (time + (vUvs.x) * 14.) ) * 0.1 );
            }`;
            const uniforms = {
                uSampler2: this.planeTxt,
                time: 0,
            };
            let program = new Program_1.Program(vertexSrc, fragmentSrc);
            const shader = new Shader_1.Shader(program, uniforms);
            this.triangle = new Mesh_1.Mesh(geometry, shader);
            this.triangle.position.set(400, 300);
            this.triangle.scale.set(2);
            this.app.stage.addChild(this.triangle);
            this.app.ticker.add(this.runExample);
        };
        this.runExample = (delta) => {
            this.triangle.rotation += 0.01;
            this.triangle.shader.uniforms.time += 0.1;
        };
        this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/bg_scene_rotate.jpg"));
        this.loader.addEventListener(Event_1.Event.COMPLETE, this.handlePlaneLoaded);
        this.loader.load();
    }
}
exports.MeshUniforms = MeshUniforms;


/***/ }),

/***/ "./js-compile/examples/SpriteBasic.js":
/*!********************************************!*\
  !*** ./js-compile/examples/SpriteBasic.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseExample_1 = __webpack_require__(/*! ./BaseExample */ "./js-compile/examples/BaseExample.js");
const ResourceLoader_1 = __webpack_require__(/*! ../raw-pixi-ts/ResourceLoader */ "./js-compile/raw-pixi-ts/ResourceLoader.js");
const URLRequest_1 = __webpack_require__(/*! ../raw-pixi-ts/URLRequest */ "./js-compile/raw-pixi-ts/URLRequest.js");
const Event_1 = __webpack_require__(/*! ../raw-pixi-ts/Event */ "./js-compile/raw-pixi-ts/Event.js");
const Texture_1 = __webpack_require__(/*! ../raw-pixi-ts/Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const BaseTexture_1 = __webpack_require__(/*! ../raw-pixi-ts/BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const Sprite_1 = __webpack_require__(/*! ../raw-pixi-ts/Sprite */ "./js-compile/raw-pixi-ts/Sprite.js");
class SpriteBasic extends BaseExample_1.BaseExample {
    constructor(app, width = 100, height = 100) {
        super(app, width, height);
        this.handleRotateLoaded = (event) => {
            let texture = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            this.bunny = new Sprite_1.Sprite(texture);
            this.bunny.anchor.set(0.5);
            this.bunny.x = this.sizew / 2;
            this.bunny.y = this.sizeh / 2;
            this.stage.addChild(this.bunny);
            this.app.ticker.add(this.runExample);
            this.exampleReady();
        };
        this.runExample = (delta) => {
            this.bunny.rotation += 0.1 * delta;
        };
        this.backColor = 0xFFF000;
        this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/bunny.png"));
        this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleRotateLoaded);
        this.loader.load();
    }
    destructor() {
        super.destructor();
        this.app.ticker.remove(this.runExample, null);
        this.bunny.destroy(null);
    }
}
exports.SpriteBasic = SpriteBasic;


/***/ }),

/***/ "./js-compile/examples/TextureGradientResource.js":
/*!********************************************************!*\
  !*** ./js-compile/examples/TextureGradientResource.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseExample_1 = __webpack_require__(/*! ./BaseExample */ "./js-compile/examples/BaseExample.js");
const Resource_1 = __webpack_require__(/*! ../raw-pixi-ts/Resource */ "./js-compile/raw-pixi-ts/Resource.js");
const BaseTexture_1 = __webpack_require__(/*! ../raw-pixi-ts/BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const Texture_1 = __webpack_require__(/*! ../raw-pixi-ts/Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const Sprite_1 = __webpack_require__(/*! ../raw-pixi-ts/Sprite */ "./js-compile/raw-pixi-ts/Sprite.js");
class TextureGradientResource extends BaseExample_1.BaseExample {
    constructor(app, width, height) {
        super(app, width, height);
        const gradBaseTexture = new BaseTexture_1.BaseTexture(new GradientResource());
        gradBaseTexture.setSize(500, 50);
        const gradTexture = new Texture_1.Texture(gradBaseTexture);
        const sprite = new Sprite_1.Sprite(gradTexture);
        sprite.position.set(100, 100);
        sprite.rotation = Math.PI / 8;
        this.stage.addChild(sprite);
        setTimeout(() => {
            this.exampleReady();
        }, 1000);
    }
}
exports.TextureGradientResource = TextureGradientResource;
class GradientResource extends Resource_1.Resource {
    constructor() {
        super(256, 100);
        this.canUpload = true;
    }
    upload(renderer, baseTexture, glTexture) {
        const { width } = this; // default size or from baseTexture?
        const { height } = this; // your choice.
        const canvas = document.createElement('canvas');
        this.source = canvas;
        this.source.width = width;
        this.source.height = height;
        const ctx = this.source.getContext('2d');
        const grd = ctx.createLinearGradient(0, 0, width, 0);
        grd.addColorStop(0, 'rgba(255, 255, 255, 0.0)');
        grd.addColorStop(0.3, 'cyan');
        grd.addColorStop(0.7, 'red');
        grd.addColorStop(1, 'green');
        ctx.fillStyle = grd;
        ctx.fillRect(0, 0, width, height);
        glTexture.width = width;
        glTexture.height = height;
        const { gl } = renderer;
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, baseTexture.premultiplyAlpha);
        gl.texImage2D(baseTexture.target, 0, baseTexture.format, baseTexture.format, baseTexture.type, this.source);
        return true;
    }
}


/***/ }),

/***/ "./js-compile/examples/TextureRender.js":
/*!**********************************************!*\
  !*** ./js-compile/examples/TextureRender.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseExample_1 = __webpack_require__(/*! ./BaseExample */ "./js-compile/examples/BaseExample.js");
const ResourceLoader_1 = __webpack_require__(/*! ../raw-pixi-ts/ResourceLoader */ "./js-compile/raw-pixi-ts/ResourceLoader.js");
const URLRequest_1 = __webpack_require__(/*! ../raw-pixi-ts/URLRequest */ "./js-compile/raw-pixi-ts/URLRequest.js");
const Event_1 = __webpack_require__(/*! ../raw-pixi-ts/Event */ "./js-compile/raw-pixi-ts/Event.js");
const Texture_1 = __webpack_require__(/*! ../raw-pixi-ts/Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const BaseTexture_1 = __webpack_require__(/*! ../raw-pixi-ts/BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const Container_1 = __webpack_require__(/*! ../raw-pixi-ts/Container */ "./js-compile/raw-pixi-ts/Container.js");
const Sprite_1 = __webpack_require__(/*! ../raw-pixi-ts/Sprite */ "./js-compile/raw-pixi-ts/Sprite.js");
const WebGLSettings_1 = __webpack_require__(/*! ../raw-pixi-ts/WebGLSettings */ "./js-compile/raw-pixi-ts/WebGLSettings.js");
const BaseRenderTexture_1 = __webpack_require__(/*! ../raw-pixi-ts/BaseRenderTexture */ "./js-compile/raw-pixi-ts/BaseRenderTexture.js");
const RenderTexture_1 = __webpack_require__(/*! ../raw-pixi-ts/RenderTexture */ "./js-compile/raw-pixi-ts/RenderTexture.js");
class TextureRender extends BaseExample_1.BaseExample {
    constructor(app, width, height) {
        super(app, width, height);
        this.handleResourceLoaded = (event) => {
            let txt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            this.container = new Container_1.Container();
            this.stage.addChild(this.container);
            for (let i = 0; i < 25; i++) {
                const bunny = new Sprite_1.Sprite(txt);
                bunny.x = (i % 5) * 30;
                bunny.y = Math.floor(i / 5) * 30;
                bunny.rotation = Math.random() * (Math.PI * 2);
                this.container.addChild(bunny);
            }
            const brt = new BaseRenderTexture_1.BaseRenderTexture(300, 300, WebGLSettings_1.WebGLSettings.SCALE_MODES.LINEAR, 1);
            this.rt = new RenderTexture_1.RenderTexture(brt);
            const sprite = new Sprite_1.Sprite(this.rt);
            sprite.x = 450;
            sprite.y = 60;
            this.stage.addChild(sprite);
            this.container.x = 100;
            this.container.y = 60;
            this.app.ticker.add(this.runExample);
            this.exampleReady();
        };
        this.runExample = (delta) => {
            this.app.renderer.render(this.container, this.rt);
        };
        this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/bunny.png"));
        this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleResourceLoaded);
        this.loader.load();
    }
    destructor() {
        super.destructor();
        this.app.ticker.remove(this.runExample, null);
        this.container.destroy(null);
        this.container = null;
        this.rt.destroy(null);
        this.rt = null;
    }
}
exports.TextureRender = TextureRender;


/***/ }),

/***/ "./js-compile/examples/TextureRotate.js":
/*!**********************************************!*\
  !*** ./js-compile/examples/TextureRotate.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseExample_1 = __webpack_require__(/*! ./BaseExample */ "./js-compile/examples/BaseExample.js");
const ResourceLoader_1 = __webpack_require__(/*! ../raw-pixi-ts/ResourceLoader */ "./js-compile/raw-pixi-ts/ResourceLoader.js");
const URLRequest_1 = __webpack_require__(/*! ../raw-pixi-ts/URLRequest */ "./js-compile/raw-pixi-ts/URLRequest.js");
const Event_1 = __webpack_require__(/*! ../raw-pixi-ts/Event */ "./js-compile/raw-pixi-ts/Event.js");
const Texture_1 = __webpack_require__(/*! ../raw-pixi-ts/Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const BaseTexture_1 = __webpack_require__(/*! ../raw-pixi-ts/BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const GroupD8_1 = __webpack_require__(/*! ../raw-pixi-ts/GroupD8 */ "./js-compile/raw-pixi-ts/GroupD8.js");
const Rectangle_1 = __webpack_require__(/*! ../raw-pixi-ts/Rectangle */ "./js-compile/raw-pixi-ts/Rectangle.js");
const Sprite_1 = __webpack_require__(/*! ../raw-pixi-ts/Sprite */ "./js-compile/raw-pixi-ts/Sprite.js");
const Text_1 = __webpack_require__(/*! ../raw-pixi-ts/Text */ "./js-compile/raw-pixi-ts/Text.js");
class TextureRotate extends BaseExample_1.BaseExample {
    constructor(app, width, height) {
        super(app, width, height);
        this.handleResourceLoaded = (event) => {
            let txt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            const textures = [txt];
            const D8 = GroupD8_1.GroupD8;
            for (let rotate = 1; rotate < 16; rotate++) {
                const h = D8.isVertical(rotate) ? txt.frame.width : txt.frame.height;
                const w = D8.isVertical(rotate) ? txt.frame.height : txt.frame.width;
                const { frame } = txt;
                const crop = new Rectangle_1.Rectangle(txt.frame.x, txt.frame.y, w, h);
                const trim = crop;
                let rotatedTexture;
                if (rotate % 2 === 0) {
                    rotatedTexture = new Texture_1.Texture(txt.baseTexture, frame, crop, trim, rotate);
                }
                else {
                    rotatedTexture = new Texture_1.Texture(txt.baseTexture, frame, crop, trim, rotate - 1);
                    rotatedTexture.rotate++;
                }
                textures.push(rotatedTexture);
            }
            const offsetX = this.sizew / 16 | 0;
            const offsetY = this.sizeh / 8 | 0;
            const gridW = this.sizew / 4 | 0;
            const gridH = this.sizeh / 5 | 0;
            for (let i = 0; i < 16; i++) {
                const dude = new Sprite_1.Sprite(textures[i < 8 ? i * 2 : (i - 8) * 2 + 1]);
                dude.scale.x = 0.5;
                dude.scale.y = 0.5;
                dude.x = offsetX + gridW * (i % 4);
                dude.y = offsetY + gridH * (i / 4 | 0);
                this.stage.addChild(dude);
                const text = new Text_1.Text(`rotate = ${dude.texture.rotate}`, {
                    fontFamily: 'Courier New', fontSize: '12px', fill: 'white', align: 'left',
                });
                text.x = dude.x;
                text.y = dude.y - 20;
                this.stage.addChild(text);
            }
            this.exampleReady();
        };
        this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/flowerTop.png"));
        this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleResourceLoaded);
        this.loader.load();
    }
}
exports.TextureRotate = TextureRotate;


/***/ }),

/***/ "./js-compile/examples/controls/ExampleDisplay.js":
/*!********************************************************!*\
  !*** ./js-compile/examples/controls/ExampleDisplay.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Container_1 = __webpack_require__(/*! ../../raw-pixi-ts/Container */ "./js-compile/raw-pixi-ts/Container.js");
const Graphics_1 = __webpack_require__(/*! ../../raw-pixi-ts/Graphics */ "./js-compile/raw-pixi-ts/Graphics.js");
const ExampleList_1 = __webpack_require__(/*! ./ExampleList */ "./js-compile/examples/controls/ExampleList.js");
const TextureRotate_1 = __webpack_require__(/*! ../TextureRotate */ "./js-compile/examples/TextureRotate.js");
const TextureRender_1 = __webpack_require__(/*! ../TextureRender */ "./js-compile/examples/TextureRender.js");
const TextureGradientResource_1 = __webpack_require__(/*! ../TextureGradientResource */ "./js-compile/examples/TextureGradientResource.js");
const FilterBlur_1 = __webpack_require__(/*! ../FilterBlur */ "./js-compile/examples/FilterBlur.js");
const FilterColor_1 = __webpack_require__(/*! ../FilterColor */ "./js-compile/examples/FilterColor.js");
const FilterCrawlies_1 = __webpack_require__(/*! ../FilterCrawlies */ "./js-compile/examples/FilterCrawlies.js");
const FilterFlag_1 = __webpack_require__(/*! ../FilterFlag */ "./js-compile/examples/FilterFlag.js");
const MaskFilter_1 = __webpack_require__(/*! ../MaskFilter */ "./js-compile/examples/MaskFilter.js");
const SpriteBasic_1 = __webpack_require__(/*! ../SpriteBasic */ "./js-compile/examples/SpriteBasic.js");
const FilterBlending_1 = __webpack_require__(/*! ../FilterBlending */ "./js-compile/examples/FilterBlending.js");
const FilterCustom_1 = __webpack_require__(/*! ../FilterCustom */ "./js-compile/examples/FilterCustom.js");
const FilterShadow_1 = __webpack_require__(/*! ../FilterShadow */ "./js-compile/examples/FilterShadow.js");
const MeshBasic_1 = __webpack_require__(/*! ../MeshBasic */ "./js-compile/examples/MeshBasic.js");
const MeshAdvanced_1 = __webpack_require__(/*! ../MeshAdvanced */ "./js-compile/examples/MeshAdvanced.js");
const MeshTriangle_1 = __webpack_require__(/*! ../MeshTriangle */ "./js-compile/examples/MeshTriangle.js");
const MeshColoredTriangle_1 = __webpack_require__(/*! ../MeshColoredTriangle */ "./js-compile/examples/MeshColoredTriangle.js");
const MeshTextured_1 = __webpack_require__(/*! ../MeshTextured */ "./js-compile/examples/MeshTextured.js");
const MeshUniforms_1 = __webpack_require__(/*! ../MeshUniforms */ "./js-compile/examples/MeshUniforms.js");
const MeshGeometry_1 = __webpack_require__(/*! ../MeshGeometry */ "./js-compile/examples/MeshGeometry.js");
const MeshShader_1 = __webpack_require__(/*! ../MeshShader */ "./js-compile/examples/MeshShader.js");
const Event_1 = __webpack_require__(/*! ../../raw-pixi-ts/Event */ "./js-compile/raw-pixi-ts/Event.js");
class ExampleDisplay extends Container_1.Container {
    constructor(app, displayWidth, displayheight) {
        super();
        this.handleExampleRequest = (event) => {
            this.setExample(this.list.selectedClass);
        };
        this.handleComplete = (event) => {
            this.list.addEventListener(Event_1.Event.CHANGE, this.handleExampleRequest);
        };
        let controlSize = 200;
        this.app = app;
        this.background = new Graphics_1.Graphics();
        this.refreshBackground(0x969696);
        app.stage.addChild(this.background);
        this.stageLayer = new Container_1.Container();
        app.stage.addChild(this.stageLayer);
        this.list = new ExampleList_1.ExampleList(controlSize, displayheight);
        this.list.x = displayWidth - controlSize;
        displayWidth = displayWidth - controlSize;
        app.stage.addChild(this.list);
        this.controlLayer = new Container_1.Container();
        app.stage.addChild(this.controlLayer);
        this.framesize = 5;
        this.exampleWidth = displayWidth; //(displayWidth - controlSize) - (this.framesize / 2)
        this.exampleheight = displayheight - (this.framesize / 2);
        this.frame = new Graphics_1.Graphics();
        this.frame.beginFill(0x000FFF);
        this.frame.drawRect(0, 0, this.framesize, displayheight);
        this.frame.drawRect(displayWidth - this.framesize, 0, 5, displayheight);
        this.frame.drawRect(this.framesize, 0, displayWidth - (this.framesize * 2), this.framesize);
        this.frame.drawRect(this.framesize, displayheight - this.framesize, displayWidth - (this.framesize * 2), this.framesize);
        this.controlLayer.addChild(this.frame);
        // this.list.addExample("Sprite Basic", SpriteBasic);
        // this.list.addExample("Sprite Reveal", AdvancedCard);
        // this.list.addExample("Sprite Slots", AdvancedSlots);
        // this.list.addExample("Sprite Trail", AdvancedTrail);
        // this.list.addExample("Sprite Warp", AdvancedWarp);  
        // this.list.addExample("Sprite Blend", BasicBlend);
        // this.list.addExample("Sprite Tinting", BasicTinting);
        // this.list.addExample("Sprite Video", SpriteVideo);
        // this.list.addExample("Sprite Tiling", SpriteTiling);
        // this.list.addExample("Sprite Animation", SpriteExplosion);
        // this.list.addExample("Sprite Animation 2", Spritejet);
        // this.list.addExample("Sprite Animation 3", SpriteSpeed);
        // this.list.addExample("Graphics Basic", GraphicsSimple);
        // this.list.addExample("Graphics Advanced", GraphicsAdvanced);
        // this.list.addExample("Graphics Dynamic", GraphicsDynamic);
        // this.list.addExample("Container", BasicContainer);
        // this.list.addExample("Mask Graphics", MaskGraphics);
        // this.list.addExample("Mask Sprite", MaskSprite);
        // this.list.addExample("Particles", BasicParticles);
        // this.list.addExample("Text", TextBase);
        // this.list.addExample("Text Bitmap", TextBitmap);
        // this.list.addExample("Text WebFont", TextWebFont);
        // this.list.addExample("Interaction", InteractionInteractivity);
        // this.list.addExample("Interaction Click", InteractionClick);  
        // this.list.addExample("Interaction Drag", InteractionDragging);
        // this.list.addExample("Interaction Icon", InteractionIcon);    
        // this.list.addExample("texture Swap", SpriteSwap);
        // this.list.addExample("Texture Advanced", TextureAdvanced);
        // this.list.addExample("Texture Gradient", TextureGradientBasic);
        this.list.addExample("Texture Gradient 2", TextureGradientResource_1.TextureGradientResource);
        this.list.addExample("Texture Rotate", TextureRotate_1.TextureRotate);
        this.list.addExample("Texture Render", TextureRender_1.TextureRender);
        this.list.addExample("Filter Blur", FilterBlur_1.FilterBlur);
        this.list.addExample("Filter ColorMatrix", FilterColor_1.FilterColor);
        this.list.addExample("Filter Displacement", FilterCrawlies_1.FilterCrawlies);
        this.list.addExample("Filter Displacement 2", FilterFlag_1.FilterFlag);
        this.list.addExample("Filter Blur 2", MaskFilter_1.MaskFilter);
        this.list.addExample("Filter Blending", FilterBlending_1.FilterBlending);
        this.list.addExample("Filter Custom", FilterCustom_1.FilterCustom);
        this.list.addExample("Filter Shadow", FilterShadow_1.FilterShadow);
        this.list.addExample("Mesh Basic", MeshBasic_1.MeshBasic);
        this.list.addExample("Mesh Triangle", MeshTriangle_1.MeshTriangle);
        this.list.addExample("Mesh Triangle 2", MeshColoredTriangle_1.MeshColoredTriangle);
        this.list.addExample("Mesh Texture", MeshTextured_1.MeshTextured);
        this.list.addExample("Mesh Advanced", MeshAdvanced_1.MeshAdvanced);
        this.list.addExample("Mesh Uniforms", MeshUniforms_1.MeshUniforms);
        this.list.addExample("Mesh Geometry", MeshGeometry_1.MeshGeometry);
        this.list.addExample("Mesh Shader", MeshShader_1.MeshShader);
        this.setExample(SpriteBasic_1.SpriteBasic);
    }
    setExample(keyclass) {
        this.list.removeEventListener(Event_1.Event.CHANGE, this.handleExampleRequest);
        if (this.currentExample) {
            this.currentExample.destructor();
        }
        this.currentExample = new keyclass(this.app, this.exampleWidth, this.exampleheight);
        this.currentExample.addEventListener(Event_1.Event.COMPLETE, this.handleComplete);
        // this.currentExample.stage.x = this.currentExample.stage.y = this.framesize;
        this.stageLayer.removeChildren();
        this.stageLayer.addChild(this.currentExample.stage);
        this.refreshBackground(this.currentExample.backColor);
    }
    refreshBackground(color) {
        this.background.clear();
        this.background.beginFill(color);
        this.background.drawRect(0, 0, this.exampleWidth, this.exampleheight);
    }
}
exports.ExampleDisplay = ExampleDisplay;


/***/ }),

/***/ "./js-compile/examples/controls/ExampleList.js":
/*!*****************************************************!*\
  !*** ./js-compile/examples/controls/ExampleList.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Container_1 = __webpack_require__(/*! ../../raw-pixi-ts/Container */ "./js-compile/raw-pixi-ts/Container.js");
const Button_1 = __webpack_require__(/*! ../../fl-package/Button */ "./js-compile/fl-package/Button.js");
const Graphics_1 = __webpack_require__(/*! ../../raw-pixi-ts/Graphics */ "./js-compile/raw-pixi-ts/Graphics.js");
const MouseEvent_1 = __webpack_require__(/*! ../../raw-pixi-ts/MouseEvent */ "./js-compile/raw-pixi-ts/MouseEvent.js");
const Event_1 = __webpack_require__(/*! ../../raw-pixi-ts/Event */ "./js-compile/raw-pixi-ts/Event.js");
class ExampleList extends Container_1.Container {
    constructor(displayWidth, displayheight) {
        super();
        this.handleScrollChange = (event) => {
            this.listContainer.y = this.scroll.targetPosition;
        };
        this.handleButtonTap = (event) => {
            this._selectedClass = this.classReference[event.currentTarget.name];
            this.dispatchEvent(Event_1.Event.getEvent(Event_1.Event.CHANGE));
        };
        this.buttons = [];
        this.classReference = {};
        this.itemGap = 2;
        this.sideGap = 2;
        this.listContainer = new Container_1.Container();
        this.addChild(this.listContainer);
        this.listmask = new Graphics_1.Graphics();
        this.listmask.beginFill(0);
        this.listmask.drawRect(0, 0, displayWidth, displayheight);
        this.listContainer.mask = this.listmask;
        this.addChild(this.listmask);
        let gr = new Graphics_1.Graphics();
        gr.beginFill(0xAAA0AA);
        gr.drawRect(0, 0, 25, displayheight);
        this.addChild(gr);
        gr.x = displayWidth - 25;
        this.buttonWidth = displayWidth - 25 - (this.sideGap * 2);
        this.buttonheight = 40;
        this.scroll = new ScrollBar();
        this.addChild(this.scroll);
        this.scroll.x = displayWidth - 25;
        this.scroll.scrollArea = displayheight;
        this.scroll.addEventListener(Event_1.Event.CHANGE, this.handleScrollChange);
    }
    get selectedClass() {
        return this._selectedClass;
    }
    addExample(keyname, keyclass) {
        let button = new Button_1.Button(keyname, this.buttonWidth, this.buttonheight);
        button.addEventListener(MouseEvent_1.MouseEvent.POINTER_TAP, this.handleButtonTap);
        this.buttons.push(button);
        button.name = keyname;
        button.x = this.sideGap;
        this.listContainer.addChild(button);
        this.classReference[keyname] = keyclass;
        this.refreshList();
    }
    refreshList() {
        let start = this.itemGap;
        for (let button of this.buttons) {
            button.y = start;
            start += button.height + this.itemGap;
        }
        this.scroll.scrollDistance = start;
    }
}
exports.ExampleList = ExampleList;
class ScrollBar extends Container_1.Container {
    constructor() {
        super();
        this.handleHandleUp = (event) => {
            this.dragging = false;
            this.eventData = null;
        };
        this.handleHandleMove = (event) => {
            if (this.eventData) {
                const newPosition = this.eventData.getLocalPosition(this._handle.parent);
                this._handle.y = newPosition.y - (this._handle.height / 2);
                if (this._handle.y > this._scrollArea) {
                    this._handle.y = this._scrollArea;
                }
                else if (this._handle.y < 0) {
                    this._handle.y = 0;
                }
                this.areaPercent = this._handle.y / this._scrollArea;
                this._targetPosition = (this._scrollDistance - this._visibleArea) * this.areaPercent * -1;
                this.dispatchEvent(Event_1.Event.getEvent(Event_1.Event.CHANGE));
            }
        };
        this.handleHandleDown = (event) => {
            this.dragging = true;
            this.eventData = event.data;
        };
        this._handle = new Graphics_1.Graphics();
        this._handle.beginFill(0x636363);
        this._handle.drawRect(0, 0, 25, 25);
        this.addChild(this._handle);
        this._handle.buttonMode = this._handle.interactive = true;
        this._handle.addEventListener(MouseEvent_1.MouseEvent.POINTER_DOWN, this.handleHandleDown);
        this._handle.addEventListener(MouseEvent_1.MouseEvent.POINTER_UP, this.handleHandleUp);
        this._handle.addEventListener(MouseEvent_1.MouseEvent.POINTER_UP_OUTSIDE, this.handleHandleUp);
        this._handle.addEventListener(MouseEvent_1.MouseEvent.POINTER_MOVE, this.handleHandleMove);
    }
    get targetPosition() {
        return this._targetPosition;
    }
    set scrollDistance(value) {
        this._scrollDistance = value;
    }
    set scrollArea(value) {
        this._scrollArea = value - 25;
        this._visibleArea = value;
    }
}


/***/ }),

/***/ "./js-compile/fl-package/Button.js":
/*!*****************************************!*\
  !*** ./js-compile/fl-package/Button.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Container_1 = __webpack_require__(/*! ../raw-pixi-ts/Container */ "./js-compile/raw-pixi-ts/Container.js");
const Graphics_1 = __webpack_require__(/*! ../raw-pixi-ts/Graphics */ "./js-compile/raw-pixi-ts/Graphics.js");
const MouseEvent_1 = __webpack_require__(/*! ../raw-pixi-ts/MouseEvent */ "./js-compile/raw-pixi-ts/MouseEvent.js");
const Text_1 = __webpack_require__(/*! ../raw-pixi-ts/Text */ "./js-compile/raw-pixi-ts/Text.js");
const TextStyle_1 = __webpack_require__(/*! ../raw-pixi-ts/TextStyle */ "./js-compile/raw-pixi-ts/TextStyle.js");
class Button extends Container_1.Container {
    constructor(caption, buttonWidth = 150, buttonheight = 40) {
        super();
        this.handleOut = (event) => {
            this.buttongraphic.visible = true;
            this.buttonovergraphic.visible = false;
            this.buttondowngraphic.visible = false;
        };
        this.handleOver = (event) => {
            this.buttongraphic.visible = false;
            this.buttonovergraphic.visible = true;
            this.buttondowngraphic.visible = false;
        };
        this.handleUp = (event) => {
            this.buttongraphic.visible = true;
            this.buttonovergraphic.visible = false;
            this.buttondowngraphic.visible = false;
        };
        this.handleDown = (event) => {
            this.buttongraphic.visible = false;
            this.buttonovergraphic.visible = false;
            this.buttondowngraphic.visible = true;
        };
        this.interactive = true;
        this.buttongraphic = new Graphics_1.Graphics();
        this.buttongraphic.beginFill(0x969696);
        this.buttongraphic.drawRoundedRect(0, 0, buttonWidth, buttonheight, 10);
        this.addChild(this.buttongraphic);
        this.buttonovergraphic = new Graphics_1.Graphics();
        this.buttonovergraphic.beginFill(0xB9B9B9);
        this.buttonovergraphic.drawRoundedRect(0, 0, buttonWidth, buttonheight, 10);
        this.addChild(this.buttonovergraphic);
        this.buttonovergraphic.visible = false;
        this.buttondowngraphic = new Graphics_1.Graphics();
        this.buttondowngraphic.beginFill(0x636363);
        this.buttondowngraphic.drawRoundedRect(0, 0, buttonWidth, buttonheight, 10);
        this.addChild(this.buttondowngraphic);
        this.buttondowngraphic.visible = false;
        let style = new TextStyle_1.TextStyle({});
        style.fontSize = 16;
        style.align = "center";
        style.fontFamily = "Arial";
        this.label = new Text_1.Text(caption, style);
        this.label.interactive = false;
        this.label.y = (buttonheight - (this.label.height)) / 2;
        this.label.x = (buttonWidth / 2 - this.label.width / 2);
        this.addChild(this.label);
        this.addEventListener(MouseEvent_1.MouseEvent.POINTER_DOWN, this.handleDown);
        this.addEventListener(MouseEvent_1.MouseEvent.POINTER_OVER, this.handleOver);
        this.addEventListener(MouseEvent_1.MouseEvent.POINTER_UP, this.handleUp);
        this.addEventListener(MouseEvent_1.MouseEvent.POINTER_OUT, this.handleOut);
        this.addEventListener(MouseEvent_1.MouseEvent.POINTER_UP_OUTSIDE, this.handleOut);
    }
}
exports.Button = Button;


/***/ }),

/***/ "./js-compile/index.js":
/*!*****************************!*\
  !*** ./js-compile/index.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Application_1 = __webpack_require__(/*! ./raw-pixi-ts/Application */ "./js-compile/raw-pixi-ts/Application.js");
const StageOptions_1 = __webpack_require__(/*! ./raw-pixi-ts/StageOptions */ "./js-compile/raw-pixi-ts/StageOptions.js");
const ExampleDisplay_1 = __webpack_require__(/*! ./examples/controls/ExampleDisplay */ "./js-compile/examples/controls/ExampleDisplay.js");
window.addEventListener("load", () => {
    var options = new StageOptions_1.StageOptions();
    options.width = 1000;
    options.height = 600;
    options.autoResize = false;
    options.backgroundColor = 0x00000000;
    options.clearBeforeRender = true;
    options.resolution = 1;
    options.autoStart = true;
    options.transparent = true;
    options.antialias = true;
    options.view = document.getElementById("fakecanvas");
    var app = new Application_1.Application(options);
    let display = new ExampleDisplay_1.ExampleDisplay(app, 1024, 768);
    app.stage.addChild(display);
    // create a view class with frame
    // create a control class with buttons
    // each button click change content of class frame
    // let button:Button = new Button("Test", 200, 40);
    // app.stage.addChild(button);
    // button.x = 800;
    // let example:BasicCache = new BasicCache(app); NOT WORKING
    // let example:InteractionIcon = new InteractionIcon(app);
    // let example:SpriteVideo = new SpriteVideo(app);
    // let example:AdvancedSlots = new AdvancedSlots(app); 
    // let example:TextureRotate = new TextureRotate(app); 
    // let example:BasicContainer = new BasicContainer(app);
    // let example:BasicBackground = new BasicBackground(app);
    // let example:BasicTinting = new BasicTinting(app);    
    // let example:BasicParticles = new BasicParticles(app);
    // let example:BasicBlend = new BasicBlend(app);    
    // let example:GraphicsSimple = new GraphicsSimple(app);
    // let example:GraphicsAdvanced = new GraphicsAdvanced(app);
    // let example:GraphicsDynamic = new GraphicsDynamic(app);
    // let example:TextureRender = new TextureRender(app);
    // let example:TextureAdvanced = new TextureAdvanced(app);
    // let example:TextureGradientBasic = new TextureGradientBasic(app);
    // let example:TextureGradientResource = new TextureGradientResource(app);
    // let example:TextBase = new TextBase(app);
    // let example:TextBitmap = new TextBitmap(app); 
    // let example:TextWebFont = new TextWebFont(app); 
    // let example:MaskGraphics = new MaskGraphics(app);
    // let example:MaskSprite = new MaskSprite(app);
    // let example:FilterBlur = new FilterBlur(app);
    // let example:FilterColor = new FilterColor(app);
    // let example:FilterCrawlies = new FilterCrawlies(app);
    // let example:FilterFlag = new FilterFlag(app);
    // let example:MaskFilter = new MaskFilter(app);
    // let example:InteractionClick = new InteractionClick(app);
    // let example:InteractionInteractivity = new InteractionInteractivity(app);
    // let example:InteractionDragging = new InteractionDragging(app); 
    // let example:SpriteBasic = new SpriteBasic(app);  
    // let example:SpriteSwap = new SpriteSwap(app);    
    // let example:SpriteTiling = new SpriteTiling(app);    
    // let example:SpriteExplosion = new SpriteExplosion(app);
    // let example:Spritejet = new Spritejet(app); 
    // let example:SpriteSpeed = new SpriteSpeed(app); 
    // let example:AdvancedCard = new AdvancedCard(app); 
    // let example:AdvancedTrail = new AdvancedTrail(app); 
    // let example:AdvancedWarp = new AdvancedWarp(app); 
    // let example:FilterBlending = new FilterBlending(app); 
    // let example:FilterCustom = new FilterCustom(app); 
    // let example:FilterShadow = new FilterShadow(app); 
    // let example:MeshBasic = new MeshBasic(app);
    // let example:MeshAdvanced = new MeshAdvanced(app);
    // let example:MeshTriangle = new MeshTriangle(app);
    // let example:MeshColoredTriangle = new MeshColoredTriangle(app);
    // let example:MeshTextured = new MeshTextured(app);
    // let example:MeshUniforms = new MeshUniforms(app);
    // let example:MeshGeometry = new MeshGeometry(app);
    // let example:MeshShader = new MeshShader(app);
});


/***/ }),

/***/ "./js-compile/raw-pixi-ts/AbstractRenderer.js":
/*!****************************************************!*\
  !*** ./js-compile/raw-pixi-ts/AbstractRenderer.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const EventDispatcher_1 = __webpack_require__(/*! ./EventDispatcher */ "./js-compile/raw-pixi-ts/EventDispatcher.js");
const Matrix_1 = __webpack_require__(/*! ./Matrix */ "./js-compile/raw-pixi-ts/Matrix.js");
const Rectangle_1 = __webpack_require__(/*! ./Rectangle */ "./js-compile/raw-pixi-ts/Rectangle.js");
const RenderTexture_1 = __webpack_require__(/*! ./RenderTexture */ "./js-compile/raw-pixi-ts/RenderTexture.js");
const Container_1 = __webpack_require__(/*! ./Container */ "./js-compile/raw-pixi-ts/Container.js");
const DisplaySettings_1 = __webpack_require__(/*! ./DisplaySettings */ "./js-compile/raw-pixi-ts/DisplaySettings.js");
const MathSettings_1 = __webpack_require__(/*! ./MathSettings */ "./js-compile/raw-pixi-ts/MathSettings.js");
const ColorSettings_1 = __webpack_require__(/*! ./ColorSettings */ "./js-compile/raw-pixi-ts/ColorSettings.js");
class AbstractRenderer extends EventDispatcher_1.EventDispatcher {
    constructor(system, options) {
        super();
        if (options.roundPixels) {
            DisplaySettings_1.DisplaySettings.ROUND_PIXELS = options.roundPixels;
        }
        this.options = options;
        this.type = DisplaySettings_1.DisplaySettings.RENDERER_TYPE.UNKNOWN;
        this.screen = new Rectangle_1.Rectangle(0, 0, options.width, options.height);
        this.view = options.view || document.createElement('canvas');
        this.resolution = options.resolution || DisplaySettings_1.DisplaySettings.RESOLUTION;
        this.transparent = options.transparent;
        this.autoDensity = options.autoDensity || options.autoResize || false;
        this.preserveDrawingBuffer = options.preserveDrawingBuffer;
        this.clearBeforeRender = options.clearBeforeRender;
        this._backgroundColor = 0x000000;
        this._backgroundColorRgba = [0, 0, 0, 0];
        this._backgroundColorString = '#000000';
        this.backgroundColor = options.backgroundColor || this._backgroundColor;
        this._tempDisplayObjectParent = new Container_1.Container();
        this._lastObjectRendered = this._tempDisplayObjectParent;
        this.blendModes = 0;
    }
    resize(screenWidth, screenHeight) {
        this.screen.width = screenWidth;
        this.screen.height = screenHeight;
        this.view.width = screenWidth * this.resolution;
        this.view.height = screenHeight * this.resolution;
        if (this.autoDensity) {
            this.view.style.width = screenWidth + "px";
            this.view.style.height = screenHeight + "px";
        }
    }
    ;
    get width() {
        return this.view.width;
    }
    ;
    get height() {
        return this.view.height;
    }
    ;
    generateTexture(displayObject, scaleMode, resolution, region) {
        region = region || displayObject.getLocalBounds();
        if (region.width === 0) {
            region.width = 1;
        }
        if (region.height === 0) {
            region.height = 1;
        }
        var renderTexture = RenderTexture_1.RenderTexture.create(region.width | 0, region.height | 0, scaleMode, resolution);
        AbstractRenderer.tempMatrix.tx = -region.x;
        AbstractRenderer.tempMatrix.ty = -region.y;
        this.render(displayObject, renderTexture, false, AbstractRenderer.tempMatrix, !!displayObject.parent);
        return renderTexture;
    }
    ;
    render(displayObject, renderTexture, b, m, parent) {
    }
    /**
     * Removes everything from the renderer and optionally removes the Canvas DOM element.
     *
     * @param {boolean} [removeView=false] - Removes the Canvas element from the DOM.
     */
    destroy(removeView) {
        // for (var o in this.plugins)
        // {
        //     this.plugins[o].destroy();
        //     this.plugins[o] = null;
        // }
        if (removeView && this.view.parentNode) {
            this.view.parentNode.removeChild(this.view);
        }
        // this.plugins = null;
        this.type = DisplaySettings_1.DisplaySettings.RENDERER_TYPE.UNKNOWN;
        this.view = null;
        this.screen = null;
        this.resolution = 0;
        this.transparent = false;
        this.autoDensity = false;
        this.blendModes = null;
        this.options = null;
        this.preserveDrawingBuffer = false;
        this.clearBeforeRender = false;
        this._backgroundColor = 0;
        this._backgroundColorRgba = null;
        this._backgroundColorString = null;
        this._tempDisplayObjectParent = null;
        this._lastObjectRendered = null;
    }
    ;
    /**
     * The background color to fill if not transparent
     *
     * @member {number}
     */
    get backgroundColor() {
        return this._backgroundColor;
    }
    ;
    set backgroundColor(value) {
        this._backgroundColor = value;
        this._backgroundColorString = MathSettings_1.MathSettings.hex2string(value);
        ColorSettings_1.ColorSettings.hex2rgb(value, this._backgroundColorRgba);
    }
    ;
}
AbstractRenderer.tempMatrix = new Matrix_1.Matrix();
exports.AbstractRenderer = AbstractRenderer;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/AccessibilityManager.js":
/*!********************************************************!*\
  !*** ./js-compile/raw-pixi-ts/AccessibilityManager.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
// import { settings } from './settings';
const UtilsSettings_1 = __webpack_require__(/*! ./UtilsSettings */ "./js-compile/raw-pixi-ts/UtilsSettings.js");
class AccessibilityManager {
    constructor(renderer) {
        /**
                 * @type {?HTMLElement}
                 * @private
                 */
        this._hookDiv = null;
        // if (settings.isMobile_min.tablet || settings.isMobile_min.phone)
        // {
        this.createTouchHook();
        // }
        // first we create a div that will sit over the PixiJS element. This is where the div overlays will go.
        var div = document.createElement('div');
        div.style.width = AccessibilityManager.DIV_TOUCH_SIZE + "px";
        div.style.height = AccessibilityManager.DIV_TOUCH_SIZE + "px";
        div.style.position = 'absolute';
        div.style.top = AccessibilityManager.DIV_TOUCH_POS_X + "px";
        div.style.left = AccessibilityManager.DIV_TOUCH_POS_Y + "px";
        div.style.zIndex = AccessibilityManager.DIV_TOUCH_ZINDEX.toString();
        /**
         * This is the dom element that will sit over the PixiJS element. This is where the div overlays will go.
         *
         * @type {HTMLElement}
         * @private
         */
        this.div = div;
        /**
         * A simple pool for storing divs.
         *
         * @type {*}
         * @private
         */
        this.pool = [];
        /**
         * This is a tick used to check if an object is no longer being rendered.
         *
         * @type {Number}
         * @private
         */
        this.renderId = 0;
        /**
         * Setting this to true will visually show the divs.
         *
         * @type {boolean}
         */
        this.debug = false;
        /**
         * The renderer this accessibility manager works for.
         *
         * @member {PIXI.AbstractRenderer}
         */
        this.renderer = renderer;
        /**
         * The array of currently active accessible items.
         *
         * @member {Array<*>}
         * @private
         */
        this.children = [];
        /**
         * pre-bind the functions
         *
         * @type {Function}
         * @private
         */
        this._onKeyDown = this._onKeyDown.bind(this);
        /**
         * pre-bind the functions
         *
         * @type {Function}
         * @private
         */
        this._onMouseMove = this._onMouseMove.bind(this);
        /**
         * A flag
         * @type {boolean}
         * @readonly
         */
        this.isActive = false;
        /**
         * A flag
         * @type {boolean}
         * @readonly
         */
        this.isMobileAccessibility = false;
        // let listen for tab.. once pressed we can fire up and show the accessibility layer
        window.addEventListener('keydown', this._onKeyDown, false);
    }
    /**
     * Creates the touch hooks.
     *
     * @private
     */
    createTouchHook() {
        var this$1 = this;
        var hookDiv = document.createElement('button');
        hookDiv.style.width = AccessibilityManager.DIV_HOOK_SIZE + "px";
        hookDiv.style.height = AccessibilityManager.DIV_HOOK_SIZE + "px";
        hookDiv.style.position = 'absolute';
        hookDiv.style.top = AccessibilityManager.DIV_HOOK_POS_X + "px";
        hookDiv.style.left = AccessibilityManager.DIV_HOOK_POS_Y + "px";
        hookDiv.style.zIndex = AccessibilityManager.DIV_HOOK_ZINDEX.toString();
        hookDiv.style.backgroundColor = '#FF0000';
        hookDiv.title = 'HOOK DIV';
        hookDiv.addEventListener('focus', function () {
            this$1.isMobileAccessibility = true;
            this$1.activate();
            this$1.destroyTouchHook();
        });
        document.body.appendChild(hookDiv);
        this._hookDiv = hookDiv;
    }
    ;
    /**
     * Destroys the touch hooks.
     *
     * @private
     */
    destroyTouchHook() {
        if (!this._hookDiv) {
            return;
        }
        document.body.removeChild(this._hookDiv);
        this._hookDiv = null;
    }
    ;
    /**
     * Activating will cause the Accessibility layer to be shown.
     * This is called when a user presses the tab key.
     *
     * @private
     */
    activate() {
        if (this.isActive) {
            return;
        }
        this.isActive = true;
        window.document.addEventListener('mousemove', this._onMouseMove, true);
        window.removeEventListener('keydown', this._onKeyDown, false);
        this.renderer.on('postrender', this.update, this);
        if (this.renderer.view.parentNode) {
            this.renderer.view.parentNode.appendChild(this.div);
        }
    }
    ;
    /**
     * Deactivating will cause the Accessibility layer to be hidden.
     * This is called when a user moves the mouse.
     *
     * @private
     */
    deactivate() {
        if (!this.isActive || this.isMobileAccessibility) {
            return;
        }
        this.isActive = false;
        window.document.removeEventListener('mousemove', this._onMouseMove, true);
        window.addEventListener('keydown', this._onKeyDown, false);
        this.renderer.off('postrender', this.update);
        if (this.div.parentNode) {
            this.div.parentNode.removeChild(this.div);
        }
    }
    ;
    /**
     * This recursive function will run through the scene graph and add any new accessible objects to the DOM layer.
     *
     * @private
     * @param {PIXI.Container} displayObject - The DisplayObject to check.
     */
    updateAccessibleObjects(displayObject) {
        if (!displayObject.visible) {
            return;
        }
        if (displayObject.accessible && displayObject.interactive) {
            if (!displayObject._accessibleActive) {
                this.addChild(displayObject);
            }
            displayObject.renderId = this.renderId;
        }
        var children = displayObject.children;
        for (var i = 0; i < children.length; i++) {
            this.updateAccessibleObjects(children[i]);
        }
    }
    ;
    /**
     * Before each render this function will ensure that all divs are mapped correctly to their DisplayObjects.
     *
     * @private
     */
    update() {
        if (!this.renderer.renderingToScreen) {
            return;
        }
        // update children...
        this.updateAccessibleObjects(this.renderer._lastObjectRendered);
        var rect = this.renderer.view.getBoundingClientRect();
        var sx = rect.width / this.renderer.width;
        var sy = rect.height / this.renderer.height;
        var div = this.div;
        div.style.left = (rect.left) + "px";
        div.style.top = (rect.top) + "px";
        div.style.width = (this.renderer.width) + "px";
        div.style.height = (this.renderer.height) + "px";
        for (var i = 0; i < this.children.length; i++) {
            var child = this.children[i];
            if (child.renderId !== this.renderId) {
                child._accessibleActive = false;
                UtilsSettings_1.UtilsSettings.removeItems(this.children, i, 1);
                this.div.removeChild(child._accessibleDiv);
                this.pool.push(child._accessibleDiv);
                child._accessibleDiv = null;
                i--;
                if (this.children.length === 0) {
                    this.deactivate();
                }
            }
            else {
                // map div to display..
                div = child._accessibleDiv;
                var hitArea = child.hitArea;
                var wt = child.worldTransform;
                if (child.hitArea) {
                    div.style.left = ((wt.tx + (hitArea.x * wt.a)) * sx) + "px";
                    div.style.top = ((wt.ty + (hitArea.y * wt.d)) * sy) + "px";
                    div.style.width = (hitArea.width * wt.a * sx) + "px";
                    div.style.height = (hitArea.height * wt.d * sy) + "px";
                }
                else {
                    hitArea = child.getBounds();
                    this.capHitArea(hitArea);
                    div.style.left = (hitArea.x * sx) + "px";
                    div.style.top = (hitArea.y * sy) + "px";
                    div.style.width = (hitArea.width * sx) + "px";
                    div.style.height = (hitArea.height * sy) + "px";
                    // update button titles and hints if they exist and they've changed
                    if (div.title !== child.accessibleTitle && child.accessibleTitle !== null) {
                        div.title = child.accessibleTitle;
                    }
                    if (div.getAttribute('aria-label') !== child.accessibleHint
                        && child.accessibleHint !== null) {
                        div.setAttribute('aria-label', child.accessibleHint);
                    }
                }
            }
        }
        // increment the render id..
        this.renderId++;
    }
    ;
    /**
     * Adjust the hit area based on the bounds of a display object
     *
     * @param {Rectangle} hitArea - Bounds of the child
     */
    capHitArea(hitArea) {
        if (hitArea.x < 0) {
            hitArea.width += hitArea.x;
            hitArea.x = 0;
        }
        if (hitArea.y < 0) {
            hitArea.height += hitArea.y;
            hitArea.y = 0;
        }
        if (hitArea.x + hitArea.width > this.renderer.width) {
            hitArea.width = this.renderer.width - hitArea.x;
        }
        if (hitArea.y + hitArea.height > this.renderer.height) {
            hitArea.height = this.renderer.height - hitArea.y;
        }
    }
    ;
    /**
     * Adds a DisplayObject to the accessibility manager
     *
     * @private
     * @param {DisplayObject} displayObject - The child to make accessible.
     */
    addChild(displayObject) {
        //this.activate();
        var div = this.pool.pop();
        if (!div) {
            div = document.createElement('button');
            div.style.width = AccessibilityManager.DIV_TOUCH_SIZE + "px";
            div.style.height = AccessibilityManager.DIV_TOUCH_SIZE + "px";
            div.style.backgroundColor = this.debug ? 'rgba(255,0,0,0.5)' : 'transparent';
            div.style.position = 'absolute';
            div.style.zIndex = AccessibilityManager.DIV_TOUCH_ZINDEX;
            div.style.borderStyle = 'none';
            // ARIA attributes ensure that button title and hint updates are announced properly
            if (navigator.userAgent.toLowerCase().indexOf('chrome') > -1) {
                // Chrome doesn't need aria-live to work as intended; in fact it just gets more confused.
                div.setAttribute('aria-live', 'off');
            }
            else {
                div.setAttribute('aria-live', 'polite');
            }
            if (navigator.userAgent.match(/rv:.*Gecko\//)) {
                // FireFox needs this to announce only the new button name
                div.setAttribute('aria-relevant', 'additions');
            }
            else {
                // required by IE, other browsers don't much care
                div.setAttribute('aria-relevant', 'text');
            }
            div.addEventListener('click', this._onClick.bind(this));
            div.addEventListener('focus', this._onFocus.bind(this));
            div.addEventListener('focusout', this._onFocusOut.bind(this));
        }
        if (displayObject.accessibleTitle && displayObject.accessibleTitle !== null) {
            div.title = displayObject.accessibleTitle;
        }
        else if (!displayObject.accessibleHint
            || displayObject.accessibleHint === null) {
            div.title = "displayObject " + (displayObject.tabIndex);
        }
        if (displayObject.accessibleHint
            && displayObject.accessibleHint !== null) {
            div.setAttribute('aria-label', displayObject.accessibleHint);
        }
        //
        displayObject._accessibleActive = true;
        displayObject._accessibleDiv = div;
        div.displayObject = displayObject;
        this.children.push(displayObject);
        this.div.appendChild(displayObject._accessibleDiv);
        displayObject._accessibleDiv.tabIndex = displayObject.tabIndex;
    }
    ;
    /**
     * Maps the div button press to pixi's  (click)
     *
     * @private
     * @param {MouseEvent} e - The click event.
     */
    _onClick(e) {
        var interactionManager = this.renderer.plugins.interaction;
        interactionManager.dispatchEvent(e.target.displayObject, 'click', interactionManager.eventData);
    }
    ;
    /**
     * Maps the div focus events to pixi's  (mouseover)
     *
     * @private
     * @param {FocusEvent} e - The focus event.
     */
    _onFocus(e) {
        if (!e.target.getAttribute('aria-live', 'off')) {
            e.target.setAttribute('aria-live', 'assertive');
        }
        var interactionManager = this.renderer.plugins.interaction;
        interactionManager.dispatchEvent(e.target.displayObject, 'mouseover', interactionManager.eventData);
    }
    ;
    /**
     * Maps the div focus events to pixi's  (mouseout)
     *
     * @private
     * @param {FocusEvent} e - The focusout event.
     */
    _onFocusOut(e) {
        if (!e.target.getAttribute('aria-live', 'off')) {
            e.target.setAttribute('aria-live', 'polite');
        }
        var interactionManager = this.renderer.plugins.interaction;
        interactionManager.dispatchEvent(e.target.displayObject, 'mouseout', interactionManager.eventData);
    }
    ;
    /**
     * Is called when a key is pressed
     *
     * @private
     * @param {KeyboardEvent} e - The keydown event.
     */
    _onKeyDown(e) {
        if (e.keyCode !== AccessibilityManager.KEY_CODE_TAB) {
            return;
        }
        this.activate();
    }
    ;
    /**
     * Is called when the mouse moves across the renderer element
     *
     * @private
     * @param {MouseEvent} e - The mouse event.
     */
    _onMouseMove(e) {
        if (e.movementX === 0 && e.movementY === 0) {
            return;
        }
        this.deactivate();
    }
    ;
    /**
     * Destroys the accessibility manager
     *
     */
    destroy() {
        this.destroyTouchHook();
        this.div = null;
        for (var i = 0; i < this.children.length; i++) {
            this.children[i].div = null;
        }
        window.document.removeEventListener('mousemove', this._onMouseMove, true);
        window.removeEventListener('keydown', this._onKeyDown);
        this.pool = null;
        this.children = null;
        this.renderer = null;
    }
    ;
}
AccessibilityManager.DIV_HOOK_SIZE = 1;
AccessibilityManager.DIV_HOOK_POS_X = -1000;
AccessibilityManager.DIV_HOOK_POS_Y = -1000;
AccessibilityManager.DIV_HOOK_ZINDEX = 2;
AccessibilityManager.KEY_CODE_TAB = 9;
AccessibilityManager.DIV_TOUCH_SIZE = 100;
AccessibilityManager.DIV_TOUCH_POS_X = 0;
AccessibilityManager.DIV_TOUCH_POS_Y = 0;
AccessibilityManager.DIV_TOUCH_ZINDEX = 2;
exports.AccessibilityManager = AccessibilityManager;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/AnimatedSprite.js":
/*!**************************************************!*\
  !*** ./js-compile/raw-pixi-ts/AnimatedSprite.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Sprite_1 = __webpack_require__(/*! ./Sprite */ "./js-compile/raw-pixi-ts/Sprite.js");
const Texture_1 = __webpack_require__(/*! ./Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const Ticker_1 = __webpack_require__(/*! ./Ticker */ "./js-compile/raw-pixi-ts/Ticker.js");
class AnimatedSprite extends Sprite_1.Sprite {
    constructor(textures, autoUpdate = true) {
        super(textures[0] instanceof Texture_1.Texture ? textures[0] : textures[0].texture);
        /**
         * @type {PIXI.Texture[]}
         * @private
         */
        this._textures = null;
        /**
         * @type {number[]}
         * @private
         */
        this._durations = null;
        this.textures = textures;
        /**
         * `true` uses PIXI.Ticker.shared to auto update animation time.
         * @type {boolean}
         * @default true
         * @private
         */
        this._autoUpdate = autoUpdate !== false;
        /**
         * The speed that the AnimatedSprite will play at. Higher is faster, lower is slower.
         *
         * @member {number}
         * @default 1
         */
        this.animationSpeed = 1;
        /**
         * Whether or not the animate sprite repeats after playing.
         *
         * @member {boolean}
         * @default true
         */
        this.loop = true;
        /**
         * Update anchor to [Texture's defaultAnchor]{@link PIXI.Texture#defaultAnchor} when frame changes.
         *
         * Useful with [sprite sheet animations]{@link PIXI.Spritesheet#animations} created with tools.
         * Changing anchor for each frame allows to pin sprite origin to certain moving feature
         * of the frame (e.g. left foot).
         *
         * Note: Enabling this will override any previously set `anchor` on each frame change.
         *
         * @member {boolean}
         * @default false
         */
        this.updateAnchor = false;
        /**
         * Function to call when a AnimatedSprite finishes playing.
         *
         * @member {Function}
         */
        this.onComplete = null;
        /**
         * Function to call when a AnimatedSprite changes which texture is being rendered.
         *
         * @member {Function}
         */
        this.onFrameChange = null;
        /**
         * Function to call when `loop` is true, and an AnimatedSprite is played and loops around to start again.
         *
         * @member {Function}
         */
        this.onLoop = null;
        /**
         * Elapsed time since animation has been started, used internally to display current texture.
         *
         * @member {number}
         * @private
         */
        this._currentTime = 0;
        /**
         * Indicates if the AnimatedSprite is currently playing.
         *
         * @member {boolean}
         * @readonly
         */
        this.playing = false;
    }
    /**
     * Stops the AnimatedSprite.
     *
     */
    stop() {
        if (!this.playing) {
            return;
        }
        this.playing = false;
        if (this._autoUpdate) {
            Ticker_1.Ticker.shared.remove(this.update, this);
        }
    }
    ;
    /**
     * Plays the AnimatedSprite.
     *
     */
    play() {
        if (this.playing) {
            return;
        }
        this.playing = true;
        if (this._autoUpdate) {
            Ticker_1.Ticker.shared.add(this.update, this, Ticker_1.Ticker.UPDATE_PRIORITY.HIGH);
        }
    }
    ;
    /**
     * Stops the AnimatedSprite and goes to a specific frame.
     *
     * @param {number} frameNumber - Frame index to stop at.
     */
    gotoAndStop(frameNumber) {
        this.stop();
        var previousFrame = this.currentFrame;
        this._currentTime = frameNumber;
        if (previousFrame !== this.currentFrame) {
            this.updateTexture();
        }
    }
    ;
    /**
     * Goes to a specific frame and begins playing the AnimatedSprite.
     *
     * @param {number} frameNumber - Frame index to start at.
     */
    gotoAndPlay(frameNumber) {
        var previousFrame = this.currentFrame;
        this._currentTime = frameNumber;
        if (previousFrame !== this.currentFrame) {
            this.updateTexture();
        }
        this.play();
    }
    ;
    /**
     * Updates the object transform for rendering.
     *
     * @private
     * @param {number} deltaTime - Time since last tick.
     */
    update(deltaTime) {
        var elapsed = this.animationSpeed * deltaTime;
        var previousFrame = this.currentFrame;
        if (this._durations !== null) {
            var lag = this._currentTime % 1 * this._durations[this.currentFrame];
            lag += elapsed / 60 * 1000;
            while (lag < 0) {
                this._currentTime--;
                lag += this._durations[this.currentFrame];
            }
            var sign = Math.sign(this.animationSpeed * deltaTime);
            this._currentTime = Math.floor(this._currentTime);
            while (lag >= this._durations[this.currentFrame]) {
                lag -= this._durations[this.currentFrame] * sign;
                this._currentTime += sign;
            }
            this._currentTime += lag / this._durations[this.currentFrame];
        }
        else {
            this._currentTime += elapsed;
        }
        if (this._currentTime < 0 && !this.loop) {
            this.gotoAndStop(0);
            if (this.onComplete) {
                this.onComplete();
            }
        }
        else if (this._currentTime >= this._textures.length && !this.loop) {
            this.gotoAndStop(this._textures.length - 1);
            if (this.onComplete) {
                this.onComplete();
            }
        }
        else if (previousFrame !== this.currentFrame) {
            if (this.loop && this.onLoop) {
                if (this.animationSpeed > 0 && this.currentFrame < previousFrame) {
                    this.onLoop();
                }
                else if (this.animationSpeed < 0 && this.currentFrame > previousFrame) {
                    this.onLoop();
                }
            }
            this.updateTexture();
        }
    }
    ;
    /**
     * Updates the displayed texture to match the current frame index.
     *
     * @private
     */
    updateTexture() {
        this._texture = this._textures[this.currentFrame];
        this._textureID = -1;
        this._textureTrimmedID = -1;
        this.cachedTint = 0xFFFFFF;
        this.uvs = this._texture._uvs.uvsFloat32;
        if (this.updateAnchor) {
            this._anchor.copy(this._texture.defaultAnchor);
        }
        if (this.onFrameChange) {
            this.onFrameChange(this.currentFrame);
        }
    }
    ;
    /**
     * Stops the AnimatedSprite and destroys it.
     *
     * @param {object|boolean} [options] - Options parameter. A boolean will act as if all options
     *  have been set to that value.
     * @param {boolean} [options.children=false] - If set to true, all the children will have their destroy
     *      method called as well. 'options' will be passed on to those calls.
     * @param {boolean} [options.texture=false] - Should it destroy the current texture of the sprite as well.
     * @param {boolean} [options.baseTexture=false] - Should it destroy the base texture of the sprite as well.
     */
    destroy(options) {
        this.stop();
        Sprite_1.Sprite.prototype.destroy.call(this, options);
        this.onComplete = null;
        this.onFrameChange = null;
        this.onLoop = null;
    }
    ;
    /**
     * A short hand way of creating a movieclip from an array of frame ids.
     *
     * @static
     * @param {string[]} frames - The array of frames ids the movieclip will use as its texture frames.
     * @return {AnimatedSprite} The new animated sprite with the specified frames.
     */
    static fromFrames(frames) {
        var textures = [];
        for (var i = 0; i < frames.length; ++i) {
            textures.push(Texture_1.Texture.from(frames[i]));
        }
        return new AnimatedSprite(textures);
    }
    ;
    /**
     * A short hand way of creating a movieclip from an array of image ids.
     *
     * @static
     * @param {string[]} images - The array of image urls the movieclip will use as its texture frames.
     * @return {AnimatedSprite} The new animate sprite with the specified images as frames.
     */
    static fromImages(images) {
        var textures = [];
        for (var i = 0; i < images.length; ++i) {
            textures.push(Texture_1.Texture.from(images[i]));
        }
        return new AnimatedSprite(textures);
    }
    ;
    /**
     * The total number of frames in the AnimatedSprite. This is the same as number of textures
     * assigned to the AnimatedSprite.
     *
     * @readonly
     * @member {number}
     * @default 0
     */
    get totalFrames() {
        return this._textures.length;
    }
    ;
    /**
     * The array of textures used for this AnimatedSprite.
     *
     * @member {PIXI.Texture[]}
     */
    get textures() {
        return this._textures;
    }
    ;
    set textures(value) {
        if (value[0] instanceof Texture_1.Texture) {
            this._textures = value;
            this._durations = null;
        }
        else {
            this._textures = [];
            this._durations = [];
            for (var i = 0; i < value.length; i++) {
                this._textures.push(value[i].texture);
                this._durations.push(value[i].time);
            }
        }
        this.gotoAndStop(0);
        this.updateTexture();
    }
    ;
    /**
    * The AnimatedSprites current frame index.
    *
    * @member {number}
    * @readonly
    */
    get currentFrame() {
        var currentFrame = Math.floor(this._currentTime) % this._textures.length;
        if (currentFrame < 0) {
            currentFrame += this._textures.length;
        }
        return currentFrame;
    }
    ;
}
exports.AnimatedSprite = AnimatedSprite;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/Application.js":
/*!***********************************************!*\
  !*** ./js-compile/raw-pixi-ts/Application.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Container_1 = __webpack_require__(/*! ./Container */ "./js-compile/raw-pixi-ts/Container.js");
const Renderer_1 = __webpack_require__(/*! ./Renderer */ "./js-compile/raw-pixi-ts/Renderer.js");
const StageOptions_1 = __webpack_require__(/*! ./StageOptions */ "./js-compile/raw-pixi-ts/StageOptions.js");
const Ticker_1 = __webpack_require__(/*! ./Ticker */ "./js-compile/raw-pixi-ts/Ticker.js");
const AccessibilityManager_1 = __webpack_require__(/*! ./AccessibilityManager */ "./js-compile/raw-pixi-ts/AccessibilityManager.js");
const Extract_1 = __webpack_require__(/*! ./Extract */ "./js-compile/raw-pixi-ts/Extract.js");
const InteractionManager_1 = __webpack_require__(/*! ./InteractionManager */ "./js-compile/raw-pixi-ts/InteractionManager.js");
const ParticleRenderer_1 = __webpack_require__(/*! ./ParticleRenderer */ "./js-compile/raw-pixi-ts/ParticleRenderer.js");
const Prepare_1 = __webpack_require__(/*! ./Prepare */ "./js-compile/raw-pixi-ts/Prepare.js");
const BatchRenderer_1 = __webpack_require__(/*! ./BatchRenderer */ "./js-compile/raw-pixi-ts/BatchRenderer.js");
const TilingSpriteRenderer_1 = __webpack_require__(/*! ./TilingSpriteRenderer */ "./js-compile/raw-pixi-ts/TilingSpriteRenderer.js");
class Application {
    constructor(options = null) {
        this.resize = () => {
            if (this._resizeTo) {
                if (this._resizeTo === window) {
                    this.renderer.resize(window.innerWidth, window.innerHeight);
                }
                else {
                    this.renderer.resize(this._resizeTo['clientWidth'], this._resizeTo['clientHeight']);
                }
            }
        };
        if (!options) {
            options = new StageOptions_1.StageOptions();
        }
        Renderer_1.Renderer.registerPlugin('accessibility', AccessibilityManager_1.AccessibilityManager);
        Renderer_1.Renderer.registerPlugin('extract', Extract_1.Extract);
        Renderer_1.Renderer.registerPlugin('interaction', InteractionManager_1.InteractionManager);
        Renderer_1.Renderer.registerPlugin('particle', ParticleRenderer_1.ParticleRenderer);
        Renderer_1.Renderer.registerPlugin('prepare', Prepare_1.Prepare);
        Renderer_1.Renderer.registerPlugin('batch', BatchRenderer_1.BatchRenderer);
        Renderer_1.Renderer.registerPlugin('tilingSprite', TilingSpriteRenderer_1.TilingSpriteRenderer);
        // this.loader = /*options.sharedLoader ? Loader.shared : */new Loader();
        this.renderer = new Renderer_1.Renderer(options); //Application.autoDetectRenderer(options);
        this._stage = new Container_1.Container();
        this.ticker = options.sharedTicker ? Ticker_1.Ticker.shared : new Ticker_1.Ticker();
        this.resizeTo = window;
        // DisplayObject.mixin(interactiveTarget);
        if (options.autoStart) {
            this.start();
        }
    }
    get ticker() {
        return this._ticker;
    }
    set ticker(ticker) {
        if (this._ticker) {
            this._ticker.remove(this.render, this);
        }
        this._ticker = ticker;
        if (ticker) {
            ticker.add(this.render, this, Ticker_1.Ticker.UPDATE_PRIORITY.LOW);
        }
    }
    start() {
        this._ticker.start();
    }
    ;
    stop() {
        this._ticker.stop();
    }
    ;
    get resizeTo() {
        return this._resizeTo;
    }
    set resizeTo(value) {
        window.removeEventListener('resize', this.resize);
        this._resizeTo = value;
        if (value) {
            window.addEventListener('resize', this.resize);
            this.resize();
        }
    }
    render() {
        this.renderer.render(this._stage);
    }
    ;
    get stage() {
        return this._stage;
    }
    get view() {
        return this.renderer.view;
    }
    ;
    get screen() {
        return this.renderer.screen;
    }
    ;
    destroy(options = null) {
        this._stage.destroy(options);
        this._stage = null;
        this.renderer.destroy(options);
        this.renderer = null;
        this._options = null;
        // if (this.loader)
        // {
        //     this.loader.destroy();
        //     this.loader = null;
        // }
    }
    ;
}
exports.Application = Application;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/ArcUtils.js":
/*!********************************************!*\
  !*** ./js-compile/raw-pixi-ts/ArcUtils.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const settings_1 = __webpack_require__(/*! ./settings */ "./js-compile/raw-pixi-ts/settings.js");
const MathSettings_1 = __webpack_require__(/*! ./MathSettings */ "./js-compile/raw-pixi-ts/MathSettings.js");
class ArcUtils {
    constructor() {
    }
    static curveTo(x1, y1, x2, y2, radius, points) {
        var fromX = points[points.length - 2];
        var fromY = points[points.length - 1];
        var a1 = fromY - y1;
        var b1 = fromX - x1;
        var a2 = y2 - y1;
        var b2 = x2 - x1;
        var mm = Math.abs((a1 * b2) - (b1 * a2));
        if (mm < 1.0e-8 || radius === 0) {
            if (points[points.length - 2] !== x1 || points[points.length - 1] !== y1) {
                points.push(x1, y1);
            }
            return null;
        }
        var dd = (a1 * a1) + (b1 * b1);
        var cc = (a2 * a2) + (b2 * b2);
        var tt = (a1 * a2) + (b1 * b2);
        var k1 = radius * Math.sqrt(dd) / mm;
        var k2 = radius * Math.sqrt(cc) / mm;
        var j1 = k1 * tt / dd;
        var j2 = k2 * tt / cc;
        var cx = (k1 * b2) + (k2 * b1);
        var cy = (k1 * a2) + (k2 * a1);
        var px = b1 * (k2 + j1);
        var py = a1 * (k2 + j1);
        var qx = b2 * (k1 + j2);
        var qy = a2 * (k1 + j2);
        var startAngle = Math.atan2(py - cy, px - cx);
        var endAngle = Math.atan2(qy - cy, qx - cx);
        return {
            cx: (cx + x1),
            cy: (cy + y1),
            radius: radius,
            startAngle: startAngle,
            endAngle: endAngle,
            anticlockwise: (b1 * a2 > b2 * a1),
        };
    }
    ;
    /**
     * The arc method creates an arc/curve (used to create circles, or parts of circles).
     *
     * @private
     * @param {number} startX - Start x location of arc
     * @param {number} startY - Start y location of arc
     * @param {number} cx - The x-coordinate of the center of the circle
     * @param {number} cy - The y-coordinate of the center of the circle
     * @param {number} radius - The radius of the circle
     * @param {number} startAngle - The starting angle, in radians (0 is at the 3 o'clock position
     *  of the arc's circle)
     * @param {number} endAngle - The ending angle, in radians
     * @param {boolean} anticlockwise - Specifies whether the drawing should be
     *  counter-clockwise or clockwise. False is default, and indicates clockwise, while true
     *  indicates counter-clockwise.
     * @param {number} n - Number of segments
     * @param {number[]} points - Collection of points to add to
     */
    static arc(startX, startY, cx, cy, radius, startAngle, endAngle, anticlockwise, points) {
        var sweep = endAngle - startAngle;
        var n = settings_1.settings.GRAPHICS_CURVES._segmentsCount(Math.abs(sweep) * radius, Math.ceil(Math.abs(sweep) / MathSettings_1.MathSettings.PI_2) * 40);
        var theta = (sweep) / (n * 2);
        var theta2 = theta * 2;
        var cTheta = Math.cos(theta);
        var sTheta = Math.sin(theta);
        var segMinus = n - 1;
        var remainder = (segMinus % 1) / segMinus;
        for (var i = 0; i <= segMinus; ++i) {
            var real = i + (remainder * i);
            var angle = ((theta) + startAngle + (theta2 * real));
            var c = Math.cos(angle);
            var s = -Math.sin(angle);
            points.push((((cTheta * c) + (sTheta * s)) * radius) + cx, (((cTheta * -s) + (sTheta * c)) * radius) + cy);
        }
    }
    ;
}
exports.ArcUtils = ArcUtils;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/ArrayResource.js":
/*!*************************************************!*\
  !*** ./js-compile/raw-pixi-ts/ArrayResource.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Resource_1 = __webpack_require__(/*! ./Resource */ "./js-compile/raw-pixi-ts/Resource.js");
const BaseTexture_1 = __webpack_require__(/*! ./BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const ResourceSettings_1 = __webpack_require__(/*! ./ResourceSettings */ "./js-compile/raw-pixi-ts/ResourceSettings.js");
const WebGLSettings_1 = __webpack_require__(/*! ./WebGLSettings */ "./js-compile/raw-pixi-ts/WebGLSettings.js");
class ArrayResource extends Resource_1.Resource {
    constructor(source, options) {
        options = options || {};
        var urls;
        var length = source;
        if (Array.isArray(source)) {
            urls = source;
            length = source.length;
        }
        super(options.width, options.height);
        /**
         * Collection of resources.
         * @member {Array<PIXI.BaseTexture>}
         * @readonly
         */
        this.items = [];
        /**
         * Dirty IDs for each part
         * @member {Array<number>}
         * @readonly
         */
        this.itemDirtyIds = [];
        for (var i = 0; i < length; i++) {
            var partTexture = new BaseTexture_1.BaseTexture();
            this.items.push(partTexture);
            this.itemDirtyIds.push(-1);
        }
        /**
         * Number of elements in array
         *
         * @member {number}
         * @readonly
         */
        this.length = length;
        /**
         * Promise when loading
         * @member {Promise}
         * @private
         * @default null
         */
        this._load = null;
        if (urls) {
            for (var i$1 = 0; i$1 < length; i$1++) {
                this.addResourceAt(ResourceSettings_1.ResourceSettings.autoDetectResource(urls[i$1], options), i$1);
            }
        }
    }
    /**
     * Destroy this BaseImageResource
     * @override
     */
    dispose() {
        for (var i = 0, len = this.length; i < len; i++) {
            this.items[i].destroy();
        }
        this.items = null;
        this.itemDirtyIds = null;
        this._load = null;
    }
    ;
    /**
     * Set a resource by ID
     *
     * @param {PIXI.resources.Resource} resource
     * @param {number} index - Zero-based index of resource to set
     * @return {PIXI.resources.ArrayResource} Instance for chaining
     */
    addResourceAt(resource, index) {
        var baseTexture = this.items[index];
        if (!baseTexture) {
            throw new Error(("Index " + index + " is out of bounds"));
        }
        // Inherit the first resource dimensions
        if (resource.valid && !this.valid) {
            this.resize(resource.width, resource.height);
        }
        this.items[index].setResource(resource);
        return this;
    }
    ;
    /**
     * Set the parent base texture
     * @member {PIXI.BaseTexture}
     * @override
     */
    bind(baseTexture) {
        super.bind(baseTexture);
        baseTexture.target = WebGLSettings_1.WebGLSettings.TARGETS.TEXTURE_2D_ARRAY;
        for (var i = 0; i < this.length; i++) {
            this.items[i].on('update', baseTexture.update, baseTexture);
        }
    }
    ;
    /**
     * Unset the parent base texture
     * @member {PIXI.BaseTexture}
     * @override
     */
    unbind(baseTexture) {
        super.unbind(baseTexture);
        for (var i = 0; i < this.length; i++) {
            this.items[i].off('update', baseTexture.update, baseTexture);
        }
    }
    ;
    /**
     * Load all the resources simultaneously
     * @override
     * @return {Promise<void>} When load is resolved
     */
    load() {
        var this$1 = this;
        if (this._load) {
            return this._load;
        }
        var resources = this.items.map(function (item) { return item.resource; });
        // TODO: also implement load part-by-part strategy
        var promises = resources.map(function (item) { return item.load(); });
        this._load = Promise.all(promises)
            .then(function () {
            var ref = resources[0];
            var width = ref.width;
            var height = ref.height;
            this$1.resize(width, height);
            return Promise.resolve(this$1);
        });
        return this._load;
    }
    ;
    /**
     * Upload the resources to the GPU.
     * @param {PIXI.Renderer} renderer
     * @param {PIXI.BaseTexture} texture
     * @param {PIXI.GLTexture} glTexture
     * @returns {boolean} whether texture was uploaded
     */
    upload(renderer, texture, glTexture) {
        var ref = this;
        var length = ref.length;
        var itemDirtyIds = ref.itemDirtyIds;
        var items = ref.items;
        var gl = renderer.gl;
        if (glTexture.dirtyId < 0) {
            gl.texImage3D(gl.TEXTURE_2D_ARRAY, 0, texture.format, this._width, this._height, length, 0, texture.format, texture.type, null);
        }
        for (var i = 0; i < length; i++) {
            var item = items[i];
            if (itemDirtyIds[i] < item.dirtyId) {
                itemDirtyIds[i] = item.dirtyId;
                if (item.valid) {
                    gl.texSubImage3D(gl.TEXTURE_2D_ARRAY, 0, 0, // xoffset
                    0, // yoffset
                    i, // zoffset
                    item.resource.width, item.resource.height, 1, texture.format, texture.type, item.resource.source);
                }
            }
        }
        return true;
    }
    ;
}
exports.ArrayResource = ArrayResource;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/Attribute.js":
/*!*********************************************!*\
  !*** ./js-compile/raw-pixi-ts/Attribute.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Logger_1 = __webpack_require__(/*! .//Logger */ "./js-compile/raw-pixi-ts/Logger.js");
class Attribute {
    constructor(buffer, size, normalized = false, type = 5126, stride = undefined, start = undefined, instance = undefined) {
        this.buffer = buffer;
        this.size = size;
        this.normalized = normalized;
        this.type = type;
        this._stride = stride;
        this.start = start;
        this.instance = instance;
    }
    ;
    set stride(value) {
        Logger_1.trace("set to " + value);
        this._stride = value;
    }
    get stride() {
        return this._stride;
    }
    destroy(options = null) {
        this.buffer = null;
    }
    ;
}
exports.Attribute = Attribute;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/BaseImageResource.js":
/*!*****************************************************!*\
  !*** ./js-compile/raw-pixi-ts/BaseImageResource.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Resource_1 = __webpack_require__(/*! ./Resource */ "./js-compile/raw-pixi-ts/Resource.js");
const NetworkSettings_1 = __webpack_require__(/*! ./NetworkSettings */ "./js-compile/raw-pixi-ts/NetworkSettings.js");
const Logger_1 = __webpack_require__(/*! ./Logger */ "./js-compile/raw-pixi-ts/Logger.js");
class BaseImageResource extends Resource_1.Resource {
    constructor(source) {
        super(source.width, source.height);
        this.source = source;
    }
    /**
     * Set cross origin based detecting the url and the crossorigin
     * @protected
     * @param {HTMLElement} element - Element to apply crossOrigin
     * @param {string} url - URL to check
     * @param {boolean|string} [crossorigin=true] - Cross origin value to use
     */
    static crossOrigin(element, url, crossorigin) {
        if (crossorigin === undefined && url.indexOf('data:') !== 0) {
            element.crossOrigin = NetworkSettings_1.NetworkSettings.determineCrossOrigin(url);
        }
        else if (crossorigin !== false) {
            element.crossOrigin = typeof crossorigin === 'string' ? crossorigin : 'anonymous';
        }
    }
    ;
    /**
     * Upload the texture to the GPU.
     * @param {PIXI.Renderer} renderer Upload to the renderer
     * @param {PIXI.BaseTexture} baseTexture Reference to parent texture
     * @param {PIXI.GLTexture} glTexture
     * @param {HTMLImageElement|HTMLCanvasElement|HTMLVideoElement|SVGElement} [source] (optional)
     * @returns {boolean} true is success
     */
    upload(renderer, baseTexture, glTexture, source = null) {
        var gl = renderer.gl;
        var width = baseTexture.realWidth;
        var height = baseTexture.realHeight;
        source = source || this.source;
        Logger_1.trace("update upload " + baseTexture.type);
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, baseTexture.premultiplyAlpha);
        if (baseTexture.target === gl.TEXTURE_2D && glTexture.width === width && glTexture.height === height) {
            // trace("update upload " + glTexture.width + ":" + glTexture.height)
            gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, baseTexture.format, baseTexture.type, source);
        }
        else {
            glTexture.width = width;
            glTexture.height = height;
            Logger_1.trace("first upload " + width + ":" + height);
            gl.texImage2D(baseTexture.target, 0, baseTexture.format, baseTexture.format, baseTexture.type, source);
        }
        return true;
    }
    ;
    /**
     * Destroy this BaseImageResource
     * @override
     * @param {PIXI.BaseTexture} [fromTexture] Optional base texture
     * @return {boolean} Destroy was successful
     */
    dispose() {
        this.source = null;
    }
    ;
}
exports.BaseImageResource = BaseImageResource;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/BasePrepare.js":
/*!***********************************************!*\
  !*** ./js-compile/raw-pixi-ts/BasePrepare.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Ticker_1 = __webpack_require__(/*! ./Ticker */ "./js-compile/raw-pixi-ts/Ticker.js");
const Container_1 = __webpack_require__(/*! ./Container */ "./js-compile/raw-pixi-ts/Container.js");
const TextStyle_1 = __webpack_require__(/*! ./TextStyle */ "./js-compile/raw-pixi-ts/TextStyle.js");
const Text_1 = __webpack_require__(/*! ./Text */ "./js-compile/raw-pixi-ts/Text.js");
const Texture_1 = __webpack_require__(/*! ./Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const BaseTexture_1 = __webpack_require__(/*! ./BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const TextMetrics_1 = __webpack_require__(/*! ./TextMetrics */ "./js-compile/raw-pixi-ts/TextMetrics.js");
const CountLimiter_1 = __webpack_require__(/*! ./CountLimiter */ "./js-compile/raw-pixi-ts/CountLimiter.js");
const WebGLSettings_1 = __webpack_require__(/*! ./WebGLSettings */ "./js-compile/raw-pixi-ts/WebGLSettings.js");
class BasePrepare //extends Renderer
 {
    constructor(renderer) {
        // super(null);
        /**
         * The limiter to be used to control how quickly items are prepared.
         * @type {PIXI.prepare.CountLimiter|PIXI.prepare.TimeLimiter}
         */
        this.limiter = new CountLimiter_1.CountLimiter(WebGLSettings_1.WebGLSettings.UPLOADS_PER_FRAME);
        /**
         * Reference to the renderer.
         * @type {PIXI.AbstractRenderer}
         * @protected
         */
        this.renderer = renderer;
        /**
         * The only real difference between CanvasPrepare and WebGLPrepare is what they pass
         * to upload hooks. That different parameter is stored here.
         * @type {PIXI.prepare.CanvasPrepare|PIXI.Renderer}
         * @protected
         */
        this.uploadHookHelper = renderer;
        /**
         * Collection of items to uploads at once.
         * @type {Array<*>}
         * @private
         */
        this.queue = [];
        /**
         * Collection of additional hooks for finding assets.
         * @type {Array<Function>}
         * @private
         */
        this.addHooks = [];
        /**
         * Collection of additional hooks for processing assets.
         * @type {Array<Function>}
         * @private
         */
        this.uploadHooks = [];
        /**
         * Callback to call after completed.
         * @type {Array<Function>}
         * @private
         */
        this.completes = [];
        /**
         * If prepare is ticking (running).
         * @type {boolean}
         * @private
         */
        this.ticking = false;
        /**
         * 'bound' call for prepareItems().
         * @type {Function}
         * @private
         */
        this.delayedTick = function () {
            // unlikely, but in case we were destroyed between tick() and delayedTick()
            if (!this.queue) {
                return;
            }
            this.prepareItems();
        };
        // hooks to find the correct texture
        this.registerFindHook(BasePrepare.findText);
        this.registerFindHook(BasePrepare.findTextStyle);
        this.registerFindHook(BasePrepare.findMultipleBaseTextures);
        this.registerFindHook(BasePrepare.findBaseTexture);
        this.registerFindHook(BasePrepare.findTexture);
        // upload hooks
        this.registerUploadHook(BasePrepare.drawText);
        this.registerUploadHook(BasePrepare.calculateTextStyle);
    }
    /**
     * Upload all the textures and graphics to the GPU.
     *
     * @param {Function|PIXI.DisplayObject|PIXI.Container|PIXI.BaseTexture|PIXI.Texture|PIXI.Graphics|PIXI.Text} item -
     *    Either the container or display object to search for items to upload, the items to upload themselves,
     *    or the callback function, if items have been added using `prepare.add`.
     * @param {Function} [done] - Optional callback when all queued uploads have completed
     */
    upload(item, done) {
        if (typeof item === 'function') {
            done = item;
            item = null;
        }
        // If a display object, search for items
        // that we could upload
        if (item) {
            this.add(item);
        }
        // Get the items for upload from the display
        if (this.queue.length) {
            if (done) {
                this.completes.push(done);
            }
            if (!this.ticking) {
                this.ticking = true;
                Ticker_1.Ticker.system.addOnce(this.tick, this, Ticker_1.Ticker.UPDATE_PRIORITY.UTILITY);
            }
        }
        else if (done) {
            done();
        }
    }
    ;
    /**
     * Handle tick update
     *
     * @private
     */
    tick() {
        setTimeout(this.delayedTick, 0);
    }
    ;
    /**
     * Actually prepare items. This is handled outside of the tick because it will take a while
     * and we do NOT want to block the current animation frame from rendering.
     *
     * @private
     */
    prepareItems() {
        this.limiter.beginFrame();
        // Upload the graphics
        while (this.queue.length && this.limiter.allowedToUpload()) {
            var item = this.queue[0];
            var uploaded = false;
            if (item && !item._destroyed) {
                for (var i = 0, len = this.uploadHooks.length; i < len; i++) {
                    if (this.uploadHooks[i](this.uploadHookHelper, item)) {
                        this.queue.shift();
                        uploaded = true;
                        break;
                    }
                }
            }
            if (!uploaded) {
                this.queue.shift();
            }
        }
        // We're finished
        if (!this.queue.length) {
            this.ticking = false;
            var completes = this.completes.slice(0);
            this.completes.length = 0;
            for (var i$1 = 0, len$1 = completes.length; i$1 < len$1; i$1++) {
                completes[i$1]();
            }
        }
        else {
            // if we are not finished, on the next rAF do this again
            Ticker_1.Ticker.system.addOnce(this.tick, this, Ticker_1.Ticker.UPDATE_PRIORITY.UTILITY);
        }
    }
    ;
    /**
     * Adds hooks for finding items.
     *
     * @param {Function} addHook - Function call that takes two parameters: `item:*, queue:Array`
     *      function must return `true` if it was able to add item to the queue.
     * @return {PIXI.prepare.BasePrepare} Instance of plugin for chaining.
     */
    registerFindHook(addHook) {
        if (addHook) {
            this.addHooks.push(addHook);
        }
        return this;
    }
    ;
    /**
     * Adds hooks for uploading items.
     *
     * @param {Function} uploadHook - Function call that takes two parameters: `prepare:CanvasPrepare, item:*` and
     *      function must return `true` if it was able to handle upload of item.
     * @return {PIXI.prepare.BasePrepare} Instance of plugin for chaining.
     */
    registerUploadHook(uploadHook) {
        if (uploadHook) {
            this.uploadHooks.push(uploadHook);
        }
        return this;
    }
    ;
    /**
     * Manually add an item to the uploading queue.
     *
     * @param {PIXI.DisplayObject|PIXI.Container|PIXI.BaseTexture|PIXI.Texture|PIXI.Graphics|PIXI.Text|*} item - Object to
     *    add to the queue
     * @return {PIXI.prepare.BasePrepare} Instance of plugin for chaining.
     */
    add(item) {
        // Add additional hooks for finding elements on special
        // types of objects that
        for (var i = 0, len = this.addHooks.length; i < len; i++) {
            if (this.addHooks[i](item, this.queue)) {
                break;
            }
        }
        // Get children recursively
        if (item instanceof Container_1.Container) {
            for (var i$1 = item.children.length - 1; i$1 >= 0; i$1--) {
                this.add(item.children[i$1]);
            }
        }
        return this;
    }
    ;
    /**
     * Destroys the plugin, don't use after this.
     *
     */
    destroy() {
        if (this.ticking) {
            Ticker_1.Ticker.system.remove(this.tick, this);
        }
        this.ticking = false;
        this.addHooks = null;
        this.uploadHooks = null;
        this.renderer = null;
        this.completes = null;
        this.queue = null;
        this.limiter = null;
        this.uploadHookHelper = null;
    }
    ;
    /**
 * Built-in hook to find Text objects.
 *
 * @private
 * @param {PIXI.DisplayObject} item - Display object to check
 * @param {Array<*>} queue - Collection of items to upload
 * @return {boolean} if a PIXI.Text object was found.
 */
    static findText(item, queue) {
        if (item instanceof Text_1.Text) {
            // push the text style to prepare it - this can be really expensive
            if (queue.indexOf(item.style) === -1) {
                queue.push(item.style);
            }
            // also push the text object so that we can render it (to canvas/texture) if needed
            if (queue.indexOf(item) === -1) {
                queue.push(item);
            }
            // also push the Text's texture for upload to GPU
            var texture = item._texture.baseTexture;
            if (queue.indexOf(texture) === -1) {
                queue.push(texture);
            }
            return true;
        }
        return false;
    }
    /**
 * Built-in hook to find TextStyle objects.
 *
 * @private
 * @param {PIXI.TextStyle} item - Display object to check
 * @param {Array<*>} queue - Collection of items to upload
 * @return {boolean} if a PIXI.TextStyle object was found.
 */
    static findTextStyle(item, queue) {
        if (item instanceof TextStyle_1.TextStyle) {
            if (queue.indexOf(item) === -1) {
                queue.push(item);
            }
            return true;
        }
        return false;
    }
    /**
 * Built-in hook to find multiple textures from objects like AnimatedSprites.
 *
 * @private
 * @param {PIXI.DisplayObject} item - Display object to check
 * @param {Array<*>} queue - Collection of items to upload
 * @return {boolean} if a PIXI.Texture object was found.
 */
    static findMultipleBaseTextures(item, queue) {
        var result = false;
        // Objects with multiple textures
        if (item && item._textures && item._textures.length) {
            for (var i = 0; i < item._textures.length; i++) {
                if (item._textures[i] instanceof Texture_1.Texture) {
                    var baseTexture = item._textures[i].baseTexture;
                    if (queue.indexOf(baseTexture) === -1) {
                        queue.push(baseTexture);
                        result = true;
                    }
                }
            }
        }
        return result;
    }
    /**
 * Built-in hook to find BaseTextures from Sprites.
 *
 * @private
 * @param {PIXI.DisplayObject} item - Display object to check
 * @param {Array<*>} queue - Collection of items to upload
 * @return {boolean} if a PIXI.Texture object was found.
 */
    static findBaseTexture(item, queue) {
        // Objects with textures, like Sprites/Text
        if (item instanceof BaseTexture_1.BaseTexture) {
            if (queue.indexOf(item) === -1) {
                queue.push(item);
            }
            return true;
        }
        return false;
    }
    /**
 * Built-in hook to find textures from objects.
 *
 * @private
 * @param {PIXI.DisplayObject} item - Display object to check
 * @param {Array<*>} queue - Collection of items to upload
 * @return {boolean} if a PIXI.Texture object was found.
 */
    static findTexture(item, queue) {
        if (item._texture && item._texture instanceof Texture_1.Texture) {
            var texture = item._texture.baseTexture;
            if (queue.indexOf(texture) === -1) {
                queue.push(texture);
            }
            return true;
        }
        return false;
    }
    /**
     * Built-in hook to draw PIXI.Text to its texture.
     *
     * @private
     * @param {PIXI.Renderer|PIXI.CanvasPrepare} helper - Not used by this upload handler
     * @param {PIXI.DisplayObject} item - Item to check
     * @return {boolean} If item was uploaded.
     */
    static drawText(helper, item) {
        if (item instanceof Text_1.Text) {
            // updating text will return early if it is not dirty
            item.updateText(true);
            return true;
        }
        return false;
    }
    /**
 * Built-in hook to calculate a text style for a PIXI.Text object.
 *
 * @private
 * @param {PIXI.Renderer|PIXI.CanvasPrepare} helper - Not used by this upload handler
 * @param {PIXI.DisplayObject} item - Item to check
 * @return {boolean} If item was uploaded.
 */
    static calculateTextStyle(helper, item) {
        if (item instanceof TextStyle_1.TextStyle) {
            var font = item.toFontString();
            TextMetrics_1.TextMetrics.measureFont(font);
            return true;
        }
        return false;
    }
}
exports.BasePrepare = BasePrepare;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/BaseRenderTexture.js":
/*!*****************************************************!*\
  !*** ./js-compile/raw-pixi-ts/BaseRenderTexture.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseTexture_1 = __webpack_require__(/*! ./BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const Framebuffer_1 = __webpack_require__(/*! ./Framebuffer */ "./js-compile/raw-pixi-ts/Framebuffer.js");
class BaseRenderTexture extends BaseTexture_1.BaseTexture {
    constructor(options, arg1 = null, arg2 = null, arg4 = null) {
        super(null, options);
        if (typeof options === 'number') {
            /* eslint-disable prefer-rest-params */
            // Backward compatibility of signature
            var width$1 = arguments[0];
            var height$1 = arguments[1];
            var scaleMode = arguments[2];
            var resolution = arguments[3];
            options = { width: width$1, height: height$1, scaleMode: scaleMode, resolution: resolution };
            /* eslint-enable prefer-rest-params */
        }
        var ref = options || {};
        var width = ref.width;
        var height = ref.height;
        // Set defaults
        this.mipmap = false;
        this.width = Math.ceil(width) || 100;
        this.height = Math.ceil(height) || 100;
        this.valid = true;
        /**
         * A reference to the canvas render target (we only need one as this can be shared across renderers)
         *
         * @protected
         * @member {object}
         */
        this._canvasRenderTarget = null;
        this.clearColor = [0, 0, 0, 0];
        this.framebuffer = new Framebuffer_1.Framebuffer(this.width * this.resolution, this.height * this.resolution)
            .addColorTexture(0, this)
            .enableStencil();
        // TODO - could this be added the systems?
        /**
         * The data structure for the stencil masks.
         *
         * @member {PIXI.Graphics[]}
         */
        this.stencilMaskStack = [];
        /**
         * The data structure for the filters.
         *
         * @member {PIXI.Graphics[]}
         */
        this.filterStack = [{}];
    }
    /**
     * Resizes the BaseRenderTexture.
     *
     * @param {number} width - The width to resize to.
     * @param {number} height - The height to resize to.
     */
    resize(width, height) {
        width = Math.ceil(width);
        height = Math.ceil(height);
        this.framebuffer.resize(width * this.resolution, height * this.resolution);
    }
    ;
    /**
     * Frees the texture and framebuffer from WebGL memory without destroying this texture object.
     * This means you can still use the texture later which will upload it to GPU
     * memory again.
     *
     * @fires PIXI.BaseTexture#dispose
     */
    dispose() {
        this.framebuffer.dispose();
        super.dispose();
    }
    ;
    /**
     * Destroys this texture.
     *
     */
    destroy() {
        super.destroy();
        this.framebuffer = null;
        this.renderer = null;
    }
    ;
}
exports.BaseRenderTexture = BaseRenderTexture;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/BaseTexture.js":
/*!***********************************************!*\
  !*** ./js-compile/raw-pixi-ts/BaseTexture.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const EventDispatcher_1 = __webpack_require__(/*! ./EventDispatcher */ "./js-compile/raw-pixi-ts/EventDispatcher.js");
const Event_1 = __webpack_require__(/*! ./Event */ "./js-compile/raw-pixi-ts/Event.js");
const Resource_1 = __webpack_require__(/*! ./Resource */ "./js-compile/raw-pixi-ts/Resource.js");
const BufferResource_1 = __webpack_require__(/*! ./BufferResource */ "./js-compile/raw-pixi-ts/BufferResource.js");
const DisplaySettings_1 = __webpack_require__(/*! ./DisplaySettings */ "./js-compile/raw-pixi-ts/DisplaySettings.js");
const MathSettings_1 = __webpack_require__(/*! ./MathSettings */ "./js-compile/raw-pixi-ts/MathSettings.js");
const WebGLSettings_1 = __webpack_require__(/*! ./WebGLSettings */ "./js-compile/raw-pixi-ts/WebGLSettings.js");
const CacheSettings_1 = __webpack_require__(/*! ./CacheSettings */ "./js-compile/raw-pixi-ts/CacheSettings.js");
const ResourceSettings_1 = __webpack_require__(/*! ./ResourceSettings */ "./js-compile/raw-pixi-ts/ResourceSettings.js");
const Logger_1 = __webpack_require__(/*! ./Logger */ "./js-compile/raw-pixi-ts/Logger.js");
class BaseTexture extends EventDispatcher_1.EventDispatcher {
    constructor(resource = null, options = null) {
        super();
        this.handleResize = (event) => {
            this.setRealSize(this.resource.width, this.resource.height);
        };
        this.handleUpdate = (event) => {
            this.update();
        };
        options = options || {};
        var premultiplyAlpha = options.premultiplyAlpha;
        var mipmap = options.mipmap;
        var scaleMode = options.scaleMode;
        var width = options.width;
        var height = options.height;
        var wrapMode = options.wrapMode;
        var format = options.format;
        var type = options.type;
        var target = options.target;
        var resolution = options.resolution;
        var resourceOptions = options.resourceOptions;
        // Convert the resource to a Resource object
        if (resource && resource instanceof ImageBitmap) {
        }
        else if (resource && !(resource instanceof Resource_1.Resource)) {
            resource = ResourceSettings_1.ResourceSettings.autoDetectResource(resource, resourceOptions);
            Logger_1.reveal(resource);
            resource.internal = true;
        }
        /**
         * The width of the base texture set when the image has loaded
         *
         * @readonly
         * @member {number}
         */
        this.width = width || 0;
        /**
         * The height of the base texture set when the image has loaded
         *
         * @readonly
         * @member {number}
         */
        this.height = height || 0;
        /**
         * The resolution / device pixel ratio of the texture
         *
         * @member {number}
         * @default PIXI.settings.RESOLUTION
         */
        this.resolution = resolution || DisplaySettings_1.DisplaySettings.RESOLUTION;
        /**
         * Mipmap mode of the texture, affects downscaled images
         *
         * @member {PIXI.MIPMAP_MODES}
         * @default PIXI.settings.MIPMAP_TEXTURES
         */
        this.mipmap = mipmap !== undefined ? mipmap : WebGLSettings_1.WebGLSettings.MIPMAP_TEXTURES;
        /**
         * How the texture wraps
         * @member {number}
         */
        this.wrapMode = wrapMode || WebGLSettings_1.WebGLSettings.WRAP_MODE;
        /**
         * The scale mode to apply when scaling this texture
         *
         * @member {PIXI.SCALE_MODES}
         * @default PIXI.settings.SCALE_MODE
         */
        this.scaleMode = scaleMode !== undefined ? scaleMode : DisplaySettings_1.DisplaySettings.SCALE_MODE;
        /**
         * The pixel format of the texture
         *
         * @member {PIXI.FORMATS}
         * @default PIXI.FORMATS.RGBA
         */
        this.format = format || WebGLSettings_1.WebGLSettings.FORMATS.RGBA;
        /**
         * The type of resource data
         *
         * @member {PIXI.TYPES}
         * @default PIXI.TYPES.UNSIGNED_BYTE
         */
        this.type = type || WebGLSettings_1.WebGLSettings.TYPES.UNSIGNED_BYTE;
        /**
         * The target type
         *
         * @member {PIXI.TARGETS}
         * @default PIXI.TARGETS.TEXTURE_2D
         */
        this.target = target || WebGLSettings_1.WebGLSettings.TARGETS.TEXTURE_2D;
        /**
         * Set to true to enable pre-multiplied alpha
         *
         * @member {boolean}
         * @default true
         */
        this.premultiplyAlpha = premultiplyAlpha !== false;
        /**
         * Global unique identifier for this BaseTexture
         *
         * @member {string}
         * @protected
         */
        this.uid = MathSettings_1.MathSettings.uid();
        /**
         * Used by automatic texture Garbage Collection, stores last GC tick when it was bound
         *
         * @member {number}
         * @protected
         */
        this.touched = 0;
        /**
         * Whether or not the texture is a power of two, try to use power of two textures as much
         * as you can
         *
         * @readonly
         * @member {boolean}
         * @default false
         */
        this.isPowerOfTwo = false;
        this._refreshPOT();
        /**
         * The map of render context textures where this is bound
         *
         * @member {Object}
         * @private
         */
        this._glTextures = {};
        /**
         * Used by TextureSystem to only update texture to the GPU when needed.
         *
         * @protected
         * @member {number}
         */
        this.dirtyId = 0;
        /**
         * Used by TextureSystem to only update texture style when needed.
         *
         * @protected
         * @member {number}
         */
        this.dirtyStyleId = 0;
        /**
         * Currently default cache ID.
         *
         * @member {string}
         */
        this.cacheId = null;
        /**
         * Generally speaking means when resource is loaded.
         * @readonly
         * @member {boolean}
         */
        this.valid = width > 0 && height > 0;
        /**
         * The collection of alternative cache ids, since some BaseTextures
         * can have more than one ID, short name and longer full URL
         *
         * @member {Array<string>}
         * @readonly
         */
        this.textureCacheIds = [];
        /**
         * Flag if BaseTexture has been destroyed.
         *
         * @member {boolean}
         * @readonly
         */
        this.destroyed = false;
        /**
         * The resource used by this BaseTexture, there can only
         * be one resource per BaseTexture, but textures can share
         * resources.
         *
         * @member {PIXI.resources.Resource}
         * @readonly
         */
        this.resource = null;
        /**
         * Number of the texture batch, used by multi-texture renderers
         *
         * @member {number}
         */
        this._batchEnabled = 0;
        /**
         * Fired when a not-immediately-available source finishes loading.
         *
         * @protected
         * @event PIXI.BaseTexture#loaded
         * @param {PIXI.BaseTexture} baseTexture - Resource loaded.
         */
        /**
         * Fired when a not-immediately-available source fails to load.
         *
         * @protected
         * @event PIXI.BaseTexture#error
         * @param {PIXI.BaseTexture} baseTexture - Resource errored.
         */
        /**
         * Fired when BaseTexture is updated.
         *
         * @protected
         * @event PIXI.BaseTexture#loaded
         * @param {PIXI.BaseTexture} baseTexture - Resource loaded.
         */
        /**
         * Fired when BaseTexture is destroyed.
         *
         * @protected
         * @event PIXI.BaseTexture#error
         * @param {PIXI.BaseTexture} baseTexture - Resource errored.
         */
        /**
         * Fired when BaseTexture is updated.
         *
         * @protected
         * @event PIXI.BaseTexture#update
         * @param {PIXI.BaseTexture} baseTexture - Instance of texture being updated.
         */
        /**
         * Fired when BaseTexture is destroyed.
         *
         * @protected
         * @event PIXI.BaseTexture#dispose
         * @param {PIXI.BaseTexture} baseTexture - Instance of texture being destroyed.
         */
        // Set the resource
        this.setResource(resource);
    }
    /**
     * Pixel width of the source of this texture
     *
     * @readonly
     * @member {number}
     */
    get realWidth() {
        return this.width * this.resolution;
    }
    ;
    /**
     * Pixel height of the source of this texture
     *
     * @readonly
     * @member {number}
     */
    get realHeight() {
        return this.height * this.resolution;
    }
    ;
    /**
     * Changes style options of BaseTexture
     *
     * @param {PIXI.SCALE_MODES} [scaleMode] - Pixi scalemode
     * @param {PIXI.MIPMAP_MODES} [mipmap] - enable mipmaps
     * @returns {BaseTexture} this
     */
    BsetStyle(scaleMode, mipmap) {
        var dirty;
        if (scaleMode !== undefined && scaleMode !== this.scaleMode) {
            this.scaleMode = scaleMode;
            dirty = true;
        }
        if (mipmap !== undefined && mipmap !== this.mipmap) {
            this.mipmap = mipmap;
            dirty = true;
        }
        if (dirty) {
            this.dirtyStyleId++;
        }
        return this;
    }
    ;
    /**
     * Changes w/h/resolution. Texture becomes valid if width and height are greater than zero.
     *
     * @param {number} width Visual width
     * @param {number} height Visual height
     * @param {number} [resolution] Optionally set resolution
     * @returns {BaseTexture} this
     */
    setSize(width, height, resolution = null) {
        this.resolution = resolution || this.resolution;
        this.width = width;
        this.height = height;
        this._refreshPOT();
        this.update();
        return this;
    }
    ;
    /**
     * Sets real size of baseTexture, preserves current resolution.
     *
     * @param {number} realWidth Full rendered width
     * @param {number} realHeight Full rendered height
     * @param {number} [resolution] Optionally set resolution
     * @returns {BaseTexture} this
     */
    setRealSize(realWidth, realHeight, resolution = null) {
        this.resolution = resolution || this.resolution;
        this.width = realWidth / this.resolution;
        this.height = realHeight / this.resolution;
        this._refreshPOT();
        this.update();
        return this;
    }
    ;
    /**
     * Refresh check for isPowerOfTwo texture based on size
     *
     * @private
     */
    _refreshPOT() {
        this.isPowerOfTwo = MathSettings_1.MathSettings.isPow2(this.realWidth) && MathSettings_1.MathSettings.isPow2(this.realHeight);
    }
    ;
    /**
     * Changes resolution
     *
     * @param {number} [resolution] res
     * @returns {BaseTexture} this
     */
    setResolution(resolution) {
        var oldResolution = this.resolution;
        if (oldResolution === resolution) {
            return this;
        }
        this.resolution = resolution;
        if (this.valid) {
            this.width = this.width * oldResolution / resolution;
            this.height = this.height * oldResolution / resolution;
            this.dispatchEvent(Event_1.Event.getEvent("update"));
            // this.emit('update');
        }
        this._refreshPOT();
        return this;
    }
    ;
    /**
     * Sets the resource if it wasn't set. Throws error if resource already present
     *
     * @param {PIXI.resources.Resource} resource - that is managing this BaseTexture
     * @returns {BaseTexture} this
     */
    setResource(resource) {
        if (this.resource === resource) {
            return this;
        }
        if (this.resource) {
            throw new Error('Resource can be set only once');
        }
        this.resource = resource;
        if (resource instanceof ImageBitmap) {
            this.setRealSize(this.resource.width, this.resource.height);
            this.handleUpdate(null);
        }
        else {
            resource.addEventListener("update", this.handleUpdate);
            resource.addEventListener("setRealSize", this.handleResize);
            this.setRealSize(this.resource.width, this.resource.height);
        }
        // resource.bind(this);
        return this;
    }
    ;
    /**
     * Invalidates the object. Texture becomes valid if width and height are greater than zero.
     */
    update() {
        if (!this.valid) {
            if (this.width > 0 && this.height > 0) {
                this.valid = true;
                this.dispatchEvent(Event_1.Event.getEvent("loaded"));
                this.dispatchEvent(Event_1.Event.getEvent("update"));
                // this.emit('loaded', this);
                // this.emit('update', this);
            }
        }
        else {
            this.dirtyId++;
            this.dirtyStyleId++;
            this.dispatchEvent(Event_1.Event.getEvent("update"));
            // this.emit('update', this);
        }
    }
    ;
    /**
     * Destroys this base texture.
     * The method stops if resource doesn't want this texture to be destroyed.
     * Removes texture from all caches.
     */
    destroy() {
        // remove and destroy the resource
        if (this.resource) {
            this.resource.unbind(this);
            // only destroy resourced created internally
            if (this.resource.internal) {
                this.resource.destroy();
            }
            this.resource = null;
        }
        if (this.cacheId) {
            delete CacheSettings_1.CacheSettings.BaseTextureCache[this.cacheId];
            delete CacheSettings_1.CacheSettings.TextureCache[this.cacheId];
            this.cacheId = null;
        }
        // finally let the WebGL renderer know..
        this.dispose();
        BaseTexture.removeFromCache(this);
        this.textureCacheIds = null;
        this.destroyed = true;
    }
    ;
    /**
     * Frees the texture from WebGL memory without destroying this texture object.
     * This means you can still use the texture later which will upload it to GPU
     * memory again.
     *
     * @fires PIXI.BaseTexture#dispose
     */
    dispose() {
        this.dispatchEvent(Event_1.Event.getEvent("dispose"));
        // this.emit('dispose', this);
    }
    ;
    /**
     * Helper function that creates a base texture based on the source you provide.
     * The source can be - image url, image element, canvas element. If the
     * source is an image url or an image element and not in the base texture
     * cache, it will be created and loaded.
     *
     * @static
     * @param {string|HTMLImageElement|HTMLCanvasElement|SVGElement|HTMLVideoElement} source - The
     *        source to create base texture from.
     * @param {object} [options] See {@link PIXI.BaseTexture}'s constructor for options.
     * @returns {PIXI.BaseTexture} The new base texture.
     */
    static from(source, options) {
        var cacheId = null;
        if (typeof source === 'string') {
            cacheId = source;
        }
        else {
            if (!source._pixiId) {
                source._pixiId = "pixiid_" + (MathSettings_1.MathSettings.uid());
            }
            cacheId = source._pixiId;
        }
        var baseTexture = CacheSettings_1.CacheSettings.BaseTextureCache[cacheId];
        if (!baseTexture) {
            baseTexture = new BaseTexture(source, options);
            baseTexture.cacheId = cacheId;
            BaseTexture.addToCache(baseTexture, cacheId);
        }
        return baseTexture;
    }
    ;
    /**
     * Create a new BaseTexture with a BufferResource from a Float32Array.
     * RGBA values are floats from 0 to 1.
     * @static
     * @param {Float32Array|Uint8Array} buffer The optional array to use, if no data
     *        is provided, a new Float32Array is created.
     * @param {number} width - Width of the resource
     * @param {number} height - Height of the resource
     * @param {object} [options] See {@link PIXI.BaseTexture}'s constructor for options.
     * @return {PIXI.BaseTexture} The resulting new BaseTexture
     */
    static fromBuffer(buffer, width, height, options) {
        buffer = buffer || new Float32Array(width * height * 4);
        var resource = new BufferResource_1.BufferResource(buffer, { width: width, height: height });
        var type = buffer instanceof Float32Array ? WebGLSettings_1.WebGLSettings.TYPES.FLOAT : WebGLSettings_1.WebGLSettings.TYPES.UNSIGNED_BYTE;
        return new BaseTexture(resource, Object.assign(WebGLSettings_1.WebGLSettings.defaultBufferOptions, options || { width: width, height: height, type: type }));
    }
    ;
    /**
     * Adds a BaseTexture to the global BaseTextureCache. This cache is shared across the whole PIXI object.
     *
     * @static
     * @param {PIXI.BaseTexture} baseTexture - The BaseTexture to add to the cache.
     * @param {string} id - The id that the BaseTexture will be stored against.
     */
    static addToCache(baseTexture, id) {
        if (id) {
            if (baseTexture.textureCacheIds.indexOf(id) === -1) {
                baseTexture.textureCacheIds.push(id);
            }
            if (CacheSettings_1.CacheSettings.BaseTextureCache[id]) {
                // eslint-disable-next-line no-console
                console.warn(("BaseTexture added to the cache with an id [" + id + "] that already had an entry"));
            }
            CacheSettings_1.CacheSettings.BaseTextureCache[id] = baseTexture;
        }
    }
    ;
    /**
     * Remove a BaseTexture from the global BaseTextureCache.
     *
     * @static
     * @param {string|PIXI.BaseTexture} baseTexture - id of a BaseTexture to be removed, or a BaseTexture instance itself.
     * @return {PIXI.BaseTexture|null} The BaseTexture that was removed.
     */
    static removeFromCache(baseTexture) {
        if (typeof baseTexture === 'string') {
            var baseTextureFromCache = CacheSettings_1.CacheSettings.BaseTextureCache[baseTexture];
            if (baseTextureFromCache) {
                var index = baseTextureFromCache.textureCacheIds.indexOf(baseTexture);
                if (index > -1) {
                    baseTextureFromCache.textureCacheIds.splice(index, 1);
                }
                delete CacheSettings_1.CacheSettings.BaseTextureCache[baseTexture];
                return baseTextureFromCache;
            }
        }
        else if (baseTexture && baseTexture.textureCacheIds) {
            for (var i = 0; i < baseTexture.textureCacheIds.length; ++i) {
                delete CacheSettings_1.CacheSettings.BaseTextureCache[baseTexture.textureCacheIds[i]];
            }
            baseTexture.textureCacheIds.length = 0;
            return baseTexture;
        }
        return null;
    }
    ;
}
/**
 * Global number of the texture batch, used by multi-texture renderers
 *
 * @static
 * @member {number} new texture batch number
 */
BaseTexture._globalBatch = 0;
exports.BaseTexture = BaseTexture;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/BatchBuffer.js":
/*!***********************************************!*\
  !*** ./js-compile/raw-pixi-ts/BatchBuffer.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class BatchBuffer {
    constructor(size) {
        this.vertices = new ArrayBuffer(size);
        /**
         * View on the vertices as a Float32Array for positions
         *
         * @member {Float32Array}
         */
        this.float32View = new Float32Array(this.vertices);
        /**
         * View on the vertices as a Uint32Array for uvs
         *
         * @member {Float32Array}
         */
        this.uint32View = new Uint32Array(this.vertices);
    }
    destroy() {
        this.vertices = null;
        this.float32View = null;
        this.uint32View = null;
    }
    ;
}
exports.BatchBuffer = BatchBuffer;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/BatchDrawCall.js":
/*!*************************************************!*\
  !*** ./js-compile/raw-pixi-ts/BatchDrawCall.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class BatchDrawCall {
    constructor() {
        this.textures = [];
        this.ids = [];
        this.blend = 0;
        this.textureCount = 0;
        this.start = 0;
        this.size = 0;
        this.type = 4;
    }
    ;
}
exports.BatchDrawCall = BatchDrawCall;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/BatchGeometry.js":
/*!*************************************************!*\
  !*** ./js-compile/raw-pixi-ts/BatchGeometry.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Geometry_1 = __webpack_require__(/*! ./Geometry */ "./js-compile/raw-pixi-ts/Geometry.js");
const Buffer_1 = __webpack_require__(/*! ./Buffer */ "./js-compile/raw-pixi-ts/Buffer.js");
const WebGLSettings_1 = __webpack_require__(/*! ./WebGLSettings */ "./js-compile/raw-pixi-ts/WebGLSettings.js");
class BatchGeometry extends Geometry_1.Geometry {
    constructor(_static = false) {
        super();
        /**
         * Buffer used for position, color, texture IDs
         *
         * @member {PIXI.Buffer}
         * @protected
         */
        this._buffer = new Buffer_1.Buffer(null, _static, false);
        /**
         * Index buffer data
         *
         * @member {PIXI.Buffer}
         * @protected
         */
        this._indexBuffer = new Buffer_1.Buffer(null, _static, true);
        this.addAttribute('aVertexPosition', this._buffer, 2, false, WebGLSettings_1.WebGLSettings.TYPES.FLOAT)
            .addAttribute('aTextureCoord', this._buffer, 2, false, WebGLSettings_1.WebGLSettings.TYPES.FLOAT)
            .addAttribute('aColor', this._buffer, 4, true, WebGLSettings_1.WebGLSettings.TYPES.UNSIGNED_BYTE)
            .addAttribute('aTextureId', this._buffer, 1, true, WebGLSettings_1.WebGLSettings.TYPES.FLOAT)
            .addIndex(this._indexBuffer);
    }
}
exports.BatchGeometry = BatchGeometry;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/BatchRenderer.js":
/*!*************************************************!*\
  !*** ./js-compile/raw-pixi-ts/BatchRenderer.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const ObjectRenderer_1 = __webpack_require__(/*! ./ObjectRenderer */ "./js-compile/raw-pixi-ts/ObjectRenderer.js");
const BatchGeometry_1 = __webpack_require__(/*! ./BatchGeometry */ "./js-compile/raw-pixi-ts/BatchGeometry.js");
const BaseTexture_1 = __webpack_require__(/*! ./BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const BatchDrawCall_1 = __webpack_require__(/*! ./BatchDrawCall */ "./js-compile/raw-pixi-ts/BatchDrawCall.js");
const State_1 = __webpack_require__(/*! ./State */ "./js-compile/raw-pixi-ts/State.js");
const BatchBuffer_1 = __webpack_require__(/*! ./BatchBuffer */ "./js-compile/raw-pixi-ts/BatchBuffer.js");
const ColorSettings_1 = __webpack_require__(/*! ./ColorSettings */ "./js-compile/raw-pixi-ts/ColorSettings.js");
const WebGLSettings_1 = __webpack_require__(/*! ./WebGLSettings */ "./js-compile/raw-pixi-ts/WebGLSettings.js");
const BlendModesSettings_1 = __webpack_require__(/*! ./BlendModesSettings */ "./js-compile/raw-pixi-ts/BlendModesSettings.js");
const MathSettings_1 = __webpack_require__(/*! ./MathSettings */ "./js-compile/raw-pixi-ts/MathSettings.js");
const DisplaySettings_1 = __webpack_require__(/*! ./DisplaySettings */ "./js-compile/raw-pixi-ts/DisplaySettings.js");
class BatchRenderer extends ObjectRenderer_1.ObjectRenderer {
    constructor(renderer) {
        super(renderer);
        /**
         * Called before the renderer starts rendering.
         *
         */
        this.onPrerender = (event) => {
            this.vertexCount = 0;
        };
        /**
         * Number of values sent in the vertex buffer.
         * aVertexPosition(2), aTextureCoord(1), aColor(1), aTextureId(1) = 5
         *
         * @member {number}
         */
        this.vertSize = 6;
        /**
         * The size of the vertex information in bytes.
         *
         * @member {number}
         */
        this.vertByteSize = this.vertSize * 4;
        /**
         * The number of images in the SpriteRenderer before it flushes.
         *
         * @member {number}
         */
        this.size = 2000 * 4; // settings.SPRITE_BATCH_SIZE; // 2000 is a nice balance between mobile / desktop
        this.currentSize = 0;
        this.currentIndexSize = 0;
        // the total number of bytes in our batch
        // let numVerts = this.size * 4 * this.vertByteSize;
        this.attributeBuffers = {};
        this.aBuffers = {};
        this.iBuffers = {};
        //     this.defualtSpriteIndexBuffer = new Buffer(createIndicesForQuads(this.size), true, true);
        /**
         * Holds the defualt indices of the geometry (quads) to draw
         *
         * @member {Uint16Array}
         */
        // const indicies = createIndicesForQuads(this.size);
        //  this.defaultQuadIndexBuffer = new Buffer(indicies, true, true);
        this.onlySprites = false;
        /**
         * The default shaders that is used if a sprite doesn't have a more specific one.
         * there is a shader for each number of textures that can be rendered.
         * These shaders will also be generated on the fly as required.
         * @member {PIXI.Shader[]}
         */
        this.shader = null;
        this.currentIndex = 0;
        this.groups = [];
        for (var k = 0; k < this.size / 4; k++) {
            this.groups[k] = new BatchDrawCall_1.BatchDrawCall();
        }
        this.elements = [];
        this.vaos = [];
        this.vaoMax = 2;
        this.vertexCount = 0;
        this.renderer.addEventListener("prerender", this.onPrerender);
        // this.renderer.on('prerender', this.onPrerender, this);
        this.state = State_1.State.for2d();
    }
    /**
     * Sets up the renderer context and necessary buffers.
     */
    contextChange() {
        var gl = this.renderer.gl;
        if (DisplaySettings_1.DisplaySettings.PREFER_ENV === DisplaySettings_1.DisplaySettings.ENV.WEBGL_LEGACY) {
            this.MAX_TEXTURES = 1;
        }
        else {
            // step 1: first check max textures the GPU can handle.
            this.MAX_TEXTURES = Math.min(gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS), WebGLSettings_1.WebGLSettings.SPRITE_MAX_TEXTURES);
            // step 2: check the maximum number of if statements the shader can have too..
            this.MAX_TEXTURES = WebGLSettings_1.WebGLSettings.checkMaxIfStatementsInShader(this.MAX_TEXTURES, gl);
        }
        // generate generateMultiTextureProgram, may be a better move?
        this.shader = WebGLSettings_1.WebGLSettings.generateMultiTextureShader(gl, this.MAX_TEXTURES);
        // we use the second shader as the first one depending on your browser may omit aTextureId
        // as it is not used by the shader so is optimized out.
        for (var i = 0; i < this.vaoMax; i++) {
            /* eslint-disable max-len */
            this.vaos[i] = new BatchGeometry_1.BatchGeometry();
        }
    }
    ;
    /**
     * Renders the sprite object.
     *
     * @param {PIXI.Sprite} sprite - the sprite to render when using this spritebatch
     */
    render(element) {
        // trace("rendering element: " + element._texture.valid)
        if (!element._texture.valid) {
            return;
        }
        if (this.currentSize + (element.vertexData.length / 2) > this.size) {
            this.flush();
        }
        this.elements[this.currentIndex++] = element;
        this.currentSize += element.vertexData.length / 2;
        // trace("currentSize: " + this.currentSize)
        this.currentIndexSize += element.indices.length;
    }
    ;
    getIndexBuffer(size) {
        // 12 indices is enough for 2 quads
        var roundedP2 = MathSettings_1.MathSettings.nextPow2(Math.ceil(size / 12));
        var roundedSizeIndex = MathSettings_1.MathSettings.log2(roundedP2);
        var roundedSize = roundedP2 * 12;
        if (this.iBuffers.length <= roundedSizeIndex) {
            this.iBuffers.length = roundedSizeIndex + 1;
        }
        var buffer = this.iBuffers[roundedSizeIndex];
        if (!buffer) {
            this.iBuffers[roundedSizeIndex] = buffer = new Uint16Array(roundedSize);
        }
        return buffer;
    }
    ;
    getAttributeBuffer(size) {
        // 8 vertices is enough for 2 quads
        var roundedP2 = MathSettings_1.MathSettings.nextPow2(Math.ceil(size / 8));
        var roundedSizeIndex = MathSettings_1.MathSettings.log2(roundedP2);
        var roundedSize = roundedP2 * 8;
        if (this.aBuffers.length <= roundedSizeIndex) {
            this.iBuffers.length = roundedSizeIndex + 1;
        }
        var buffer = this.aBuffers[roundedSize];
        if (!buffer) {
            this.aBuffers[roundedSize] = buffer = new BatchBuffer_1.BatchBuffer(roundedSize * this.vertByteSize);
        }
        return buffer;
    }
    ;
    /**
     * Renders the content and empties the current batch.
     *
     */
    flush() {
        // trace("BatchRender flush " + this.currentSize)
        if (this.currentSize === 0) {
            return;
        }
        var gl = this.renderer.gl;
        var MAX_TEXTURES = this.MAX_TEXTURES;
        var buffer = this.getAttributeBuffer(this.currentSize);
        // reveal(buffer);
        var indexBuffer = this.getIndexBuffer(this.currentIndexSize);
        // reveal(indexBuffer);
        var elements = this.elements;
        var groups = this.groups;
        var float32View = buffer.float32View;
        // reveal(float32View);
        var uint32View = buffer.uint32View;
        // reveal(uint32View);
        var touch = this.renderer.textureGC.count;
        var index = 0;
        var indexCount = 0;
        var nextTexture;
        var currentTexture;
        var groupCount = 0;
        var textureCount = 0;
        var currentGroup = groups[0];
        // reveal(currentGroup);
        var blendMode = -1; // premultiplyBlendMode[elements[0]._texture.baseTexture.premultiplyAlpha ? 0 : ][elements[0].blendMode];
        currentGroup.textureCount = 0;
        currentGroup.start = 0;
        currentGroup.blend = blendMode;
        var TICK = ++BaseTexture_1.BaseTexture._globalBatch;
        var i;
        for (i = 0; i < this.currentIndex; ++i) {
            // upload the sprite elements...
            // they have all ready been calculated so we just need to push them into the buffer.
            var sprite = elements[i];
            elements[i] = null;
            nextTexture = sprite._texture.baseTexture;
            // reveal(nextTexture);
            var spriteBlendMode = BlendModesSettings_1.BlendModesSettings.premultiplyBlendMode[nextTexture.premultiplyAlpha ? 1 : 0][sprite.blendMode];
            if (blendMode !== spriteBlendMode) {
                blendMode = spriteBlendMode;
                // force the batch to break!
                currentTexture = null;
                textureCount = MAX_TEXTURES;
                TICK++;
            }
            if (currentTexture !== nextTexture) {
                currentTexture = nextTexture;
                if (nextTexture._batchEnabled !== TICK) {
                    if (textureCount === MAX_TEXTURES) {
                        TICK++;
                        textureCount = 0;
                        currentGroup.size = indexCount - currentGroup.start;
                        currentGroup = groups[groupCount++];
                        currentGroup.textureCount = 0;
                        currentGroup.blend = blendMode;
                        currentGroup.start = indexCount;
                    }
                    nextTexture.touched = touch;
                    nextTexture._batchEnabled = TICK;
                    nextTexture._id = textureCount;
                    currentGroup.textures[currentGroup.textureCount++] = nextTexture;
                    // reveal(currentGroup);
                    // reveal(nextTexture);
                    textureCount++;
                }
            }
            this.packGeometry(sprite, float32View, uint32View, indexBuffer, index, indexCount); // argb, nextTexture._id, float32View, uint32View, indexBuffer, index, indexCount);
            // HERE 
            // push a graphics..
            index += (sprite.vertexData.length / 2) * this.vertSize;
            indexCount += sprite.indices.length;
        }
        BaseTexture_1.BaseTexture._globalBatch = TICK;
        currentGroup.size = indexCount - currentGroup.start;
        //        this.indexBuffer.update();
        if (!WebGLSettings_1.WebGLSettings.CAN_UPLOAD_SAME_BUFFER) {
            // this is still needed for IOS performance..
            // it really does not like uploading to the same buffer in a single frame!
            if (this.vaoMax <= this.vertexCount) {
                this.vaoMax++;
                /* eslint-disable max-len */
                this.vaos[this.vertexCount] = new BatchGeometry_1.BatchGeometry();
            }
            this.vaos[this.vertexCount]._buffer.update(buffer.vertices, 0);
            this.vaos[this.vertexCount]._indexBuffer.update(indexBuffer, 0);
            //   this.vertexBuffers[this.vertexCount].update(buffer.vertices, 0);
            this.renderer.geometry.bind(this.vaos[this.vertexCount]);
            this.renderer.geometry.updateBuffers();
            this.vertexCount++;
        }
        else {
            // lets use the faster option, always use buffer number 0
            this.vaos[this.vertexCount]._buffer.update(buffer.vertices, 0);
            this.vaos[this.vertexCount]._indexBuffer.update(indexBuffer, 0);
            //   if (true)// this.spriteOnly)
            // {
            // this.vaos[this.vertexCount].indexBuffer = this.defualtSpriteIndexBuffer;
            // this.vaos[this.vertexCount].buffers[1] = this.defualtSpriteIndexBuffer;
            // }
            // this.vaos[0].attributes.aColor.stride = 24
            // this.vaos[0].attributes.aColor.start = 16
            // NOT SET
            // this.vaos[0].attributes.aTextureCoord.stride = 24
            // this.vaos[0].attributes.aTextureCoord.start = 8
            // NOT SET
            // this.vaos[0].attributes.aVertexPosition.stride = 24
            // NOT SET
            this.renderer.geometry.updateBuffers();
            //    
        }
        //   this.renderer.state.set(this.state);
        var textureSystem = this.renderer.texture;
        var stateSystem = this.renderer.state;
        // e.log(groupCount);
        // / render the groups..
        //    trace("groupcount: " + groupCount)
        // trace("BatchRenderer count: " + groupCount)
        for (i = 0; i < groupCount; i++) {
            var group = groups[i];
            var groupTextureCount = group.textureCount;
            for (var j = 0; j < groupTextureCount; j++) {
                // trace("possible textureSystem bind call (BathRenderer)")
                // trace("binding: " + group.textures[j] + " to " + j)
                textureSystem.bind(group.textures[j], j);
                group.textures[j] = null;
            }
            // this.state.blendMode = group.blend;
            // this.state.blend = true;
            // this.renderer.state.setState(this.state);
            // set the blend mode..
            stateSystem.setBlendMode(group.blend);
            gl.drawElements(group.type, group.size, gl.UNSIGNED_SHORT, group.start * 2);
        }
        // reset elements for the next flush
        this.currentIndex = 0;
        this.currentSize = 0;
        this.currentIndexSize = 0;
    }
    ;
    packGeometry(element, float32View, uint32View, indexBuffer, index, indexCount) {
        var p = index / this.vertSize; // float32View.length / 6 / 2;
        var uvs = element.uvs;
        var indicies = element.indices; // geometry.getIndex().data;// indicies;
        var vertexData = element.vertexData;
        var textureId = element._texture.baseTexture._id;
        var alpha = Math.min(element.worldAlpha, 1.0);
        var argb = alpha < 1.0 && element._texture.baseTexture.premultiplyAlpha ? ColorSettings_1.ColorSettings.premultiplyTint(element._tintRGB, alpha)
            : element._tintRGB + (alpha * 255 << 24);
        // lets not worry about tint! for now..
        for (var i = 0; i < vertexData.length; i += 2) {
            float32View[index++] = vertexData[i];
            float32View[index++] = vertexData[i + 1];
            float32View[index++] = uvs[i];
            float32View[index++] = uvs[i + 1];
            uint32View[index++] = argb;
            float32View[index++] = textureId;
        }
        for (var i$1 = 0; i$1 < indicies.length; i$1++) {
            indexBuffer[indexCount++] = p + indicies[i$1];
        }
    }
    ;
    /**
     * Starts a new sprite batch.
     */
    start() {
        this.renderer.state.setState(this.state);
        this.renderer.shader.bind(this.shader);
        if (WebGLSettings_1.WebGLSettings.CAN_UPLOAD_SAME_BUFFER) {
            // bind buffer #0, we don't need others
            this.renderer.geometry.bind(this.vaos[this.vertexCount]);
        }
    }
    ;
    /**
     * Stops and flushes the current batch.
     *
     */
    stop() {
        this.flush();
    }
    ;
    /**
     * Destroys the SpriteRenderer.
     *
     */
    destroy() {
        for (var i = 0; i < this.vaoMax; i++) {
            // if (this.vertexBuffers[i])
            // {
            //     this.vertexBuffers[i].destroy();
            // }
            if (this.vaos[i]) {
                this.vaos[i].destroy(null);
            }
        }
        if (this.indexBuffer) {
            this.indexBuffer.destroy();
        }
        this.renderer.removeEventListener('prerender', this.onPrerender);
        if (this.shader) {
            this.shader.destroy();
            this.shader = null;
        }
        // this.vertexBuffers = null;
        this.vaos = null;
        this.indexBuffer = null;
        this.indices = null;
        this.sprites = null;
        // for (let i = 0; i < this.buffers.length; ++i)
        // {
        //     this.buffers[i].destroy();
        // }
        super.destroy();
    }
    ;
}
exports.BatchRenderer = BatchRenderer;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/BatchSystem.js":
/*!***********************************************!*\
  !*** ./js-compile/raw-pixi-ts/BatchSystem.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const System_1 = __webpack_require__(/*! ./System */ "./js-compile/raw-pixi-ts/System.js");
const ObjectRenderer_1 = __webpack_require__(/*! ./ObjectRenderer */ "./js-compile/raw-pixi-ts/ObjectRenderer.js");
class BatchSystem extends System_1.System {
    constructor(renderer) {
        super(renderer);
        /**
         * An empty renderer.
         *
         * @member {PIXI.ObjectRenderer}
         */
        this.emptyRenderer = new ObjectRenderer_1.ObjectRenderer(renderer);
        /**
         * The currently active ObjectRenderer.
         *
         * @member {PIXI.ObjectRenderer}
         */
        this.currentRenderer = this.emptyRenderer;
    }
    /**
     * Changes the current renderer to the one given in parameter
     *
     * @param {PIXI.ObjectRenderer} objectRenderer - The object renderer to use.
     */
    setObjectRenderer(objectRenderer) {
        if (this.currentRenderer === objectRenderer) {
            return;
        }
        this.currentRenderer.stop();
        this.currentRenderer = objectRenderer;
        this.currentRenderer.start();
    }
    ;
    /**
     * This should be called if you wish to do some custom rendering
     * It will basically render anything that may be batched up such as sprites
     */
    flush() {
        this.setObjectRenderer(this.emptyRenderer);
    }
    ;
    /**
     * Reset the system to an empty renderer
     */
    reset() {
        this.setObjectRenderer(this.emptyRenderer);
    }
    ;
}
exports.BatchSystem = BatchSystem;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/BezierUtils.js":
/*!***********************************************!*\
  !*** ./js-compile/raw-pixi-ts/BezierUtils.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const settings_1 = __webpack_require__(/*! ./settings */ "./js-compile/raw-pixi-ts/settings.js");
class BezierUtils {
    constructor() {
    }
    static curveLength(fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY) {
        var n = 10;
        var result = 0.0;
        var t = 0.0;
        var t2 = 0.0;
        var t3 = 0.0;
        var nt = 0.0;
        var nt2 = 0.0;
        var nt3 = 0.0;
        var x = 0.0;
        var y = 0.0;
        var dx = 0.0;
        var dy = 0.0;
        var prevX = fromX;
        var prevY = fromY;
        for (var i = 1; i <= n; ++i) {
            t = i / n;
            t2 = t * t;
            t3 = t2 * t;
            nt = (1.0 - t);
            nt2 = nt * nt;
            nt3 = nt2 * nt;
            x = (nt3 * fromX) + (3.0 * nt2 * t * cpX) + (3.0 * nt * t2 * cpX2) + (t3 * toX);
            y = (nt3 * fromY) + (3.0 * nt2 * t * cpY) + (3 * nt * t2 * cpY2) + (t3 * toY);
            dx = prevX - x;
            dy = prevY - y;
            prevX = x;
            prevY = y;
            result += Math.sqrt((dx * dx) + (dy * dy));
        }
        return result;
    }
    ;
    /**
     * Calculate the points for a bezier curve and then draws it.
     *
     * Ignored from docs since it is not directly exposed.
     *
     * @ignore
     * @param {number} cpX - Control point x
     * @param {number} cpY - Control point y
     * @param {number} cpX2 - Second Control point x
     * @param {number} cpY2 - Second Control point y
     * @param {number} toX - Destination point x
     * @param {number} toY - Destination point y
     * @param {number[]} points - Path array to push points into
     */
    static curveTo(cpX, cpY, cpX2, cpY2, toX, toY, points) {
        var fromX = points[points.length - 2];
        var fromY = points[points.length - 1];
        points.length -= 2;
        var n = settings_1.settings.GRAPHICS_CURVES._segmentsCount(BezierUtils.curveLength(fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY));
        var dt = 0;
        var dt2 = 0;
        var dt3 = 0;
        var t2 = 0;
        var t3 = 0;
        points.push(fromX, fromY);
        for (var i = 1, j = 0; i <= n; ++i) {
            j = i / n;
            dt = (1 - j);
            dt2 = dt * dt;
            dt3 = dt2 * dt;
            t2 = j * j;
            t3 = t2 * j;
            points.push((dt3 * fromX) + (3 * dt2 * j * cpX) + (3 * dt * t2 * cpX2) + (t3 * toX), (dt3 * fromY) + (3 * dt2 * j * cpY) + (3 * dt * t2 * cpY2) + (t3 * toY));
        }
    }
    ;
}
exports.BezierUtils = BezierUtils;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/BlendModesSettings.js":
/*!******************************************************!*\
  !*** ./js-compile/raw-pixi-ts/BlendModesSettings.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class BlendModesSettings {
    /**
* Corrects PixiJS blend, takes premultiplied alpha into account
*
* @memberof PIXI.utils
* @function mapPremultipliedBlendModes
* @private
* @param {Array<number[]>} [array] - The array to output into.
* @return {Array<number[]>} Mapped modes.
*/
    static mapPremultipliedBlendModes() {
        var pm = [];
        var npm = [];
        for (var i = 0; i < 32; i++) {
            pm[i] = i;
            npm[i] = i;
        }
        pm[BlendModesSettings.BLEND_MODES.NORMAL_NPM] = BlendModesSettings.BLEND_MODES.NORMAL;
        pm[BlendModesSettings.BLEND_MODES.ADD_NPM] = BlendModesSettings.BLEND_MODES.ADD;
        pm[BlendModesSettings.BLEND_MODES.SCREEN_NPM] = BlendModesSettings.BLEND_MODES.SCREEN;
        npm[BlendModesSettings.BLEND_MODES.NORMAL] = BlendModesSettings.BLEND_MODES.NORMAL_NPM;
        npm[BlendModesSettings.BLEND_MODES.ADD] = BlendModesSettings.BLEND_MODES.ADD_NPM;
        npm[BlendModesSettings.BLEND_MODES.SCREEN] = BlendModesSettings.BLEND_MODES.SCREEN_NPM;
        var array = [];
        array.push(npm);
        array.push(pm);
        return array;
    }
    /**
* changes blendMode according to texture format
*
* @memberof PIXI.utils
* @function correctBlendMode
* @param {number} blendMode supposed blend mode
* @param {boolean} premultiplied  whether source is premultiplied
* @returns {number} true blend mode for this texture
*/
    static correctBlendMode(blendMode, premultiplied) {
        return BlendModesSettings.premultiplyBlendMode[premultiplied ? 1 : 0][blendMode];
    }
    /**
* Maps gl blend combinations to WebGL.
*
* @memberof PIXI
* @function mapWebGLBlendModesToPixi
* @private
* @param {WebGLRenderingContext} gl - The rendering context.
* @param {number[][]} [array=[]] - The array to output into.
* @return {number[][]} Mapped modes.
*/
    static mapWebGLBlendModesToPixi(gl, array = []) {
        // TODO - premultiply alpha would be different.
        // add a boolean for that!
        array[BlendModesSettings.BLEND_MODES.NORMAL] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
        array[BlendModesSettings.BLEND_MODES.ADD] = [gl.ONE, gl.DST_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
        array[BlendModesSettings.BLEND_MODES.MULTIPLY] = [gl.DST_COLOR, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
        array[BlendModesSettings.BLEND_MODES.SCREEN] = [gl.ONE, gl.ONE_MINUS_SRC_COLOR, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
        array[BlendModesSettings.BLEND_MODES.OVERLAY] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
        array[BlendModesSettings.BLEND_MODES.DARKEN] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
        array[BlendModesSettings.BLEND_MODES.LIGHTEN] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
        array[BlendModesSettings.BLEND_MODES.COLOR_DODGE] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
        array[BlendModesSettings.BLEND_MODES.COLOR_BURN] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
        array[BlendModesSettings.BLEND_MODES.HARD_LIGHT] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
        array[BlendModesSettings.BLEND_MODES.SOFT_LIGHT] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
        array[BlendModesSettings.BLEND_MODES.DIFFERENCE] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
        array[BlendModesSettings.BLEND_MODES.EXCLUSION] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
        array[BlendModesSettings.BLEND_MODES.HUE] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
        array[BlendModesSettings.BLEND_MODES.SATURATION] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
        array[BlendModesSettings.BLEND_MODES.COLOR] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
        array[BlendModesSettings.BLEND_MODES.LUMINOSITY] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
        array[BlendModesSettings.BLEND_MODES.NONE] = [0, 0];
        // not-premultiplied blend modes
        array[BlendModesSettings.BLEND_MODES.NORMAL_NPM] = [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
        array[BlendModesSettings.BLEND_MODES.ADD_NPM] = [gl.SRC_ALPHA, gl.DST_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
        array[BlendModesSettings.BLEND_MODES.SCREEN_NPM] = [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_COLOR, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
        // composite operations
        array[BlendModesSettings.BLEND_MODES.SRC_IN] = [gl.DST_ALPHA, gl.ZERO];
        array[BlendModesSettings.BLEND_MODES.SRC_OUT] = [gl.ONE_MINUS_DST_ALPHA, gl.ZERO];
        array[BlendModesSettings.BLEND_MODES.SRC_ATOP] = [gl.DST_ALPHA, gl.ONE_MINUS_SRC_ALPHA];
        array[BlendModesSettings.BLEND_MODES.DST_OVER] = [gl.ONE_MINUS_DST_ALPHA, gl.ONE];
        array[BlendModesSettings.BLEND_MODES.DST_IN] = [gl.ZERO, gl.SRC_ALPHA];
        array[BlendModesSettings.BLEND_MODES.DST_OUT] = [gl.ZERO, gl.ONE_MINUS_SRC_ALPHA];
        array[BlendModesSettings.BLEND_MODES.DST_ATOP] = [gl.ONE_MINUS_DST_ALPHA, gl.SRC_ALPHA];
        // SUBTRACT from flash
        array[BlendModesSettings.BLEND_MODES.SUBTRACT] = [gl.ONE, gl.ONE, gl.ONE, gl.ONE, gl.FUNC_REVERSE_SUBTRACT, gl.FUNC_ADD];
        return array;
    }
}
/**
* Various blend modes supported by PIXI.
*
* IMPORTANT - The WebGL renderer only supports the NORMAL, ADD, MULTIPLY and SCREEN blend modes.
* Anything else will silently act like NORMAL.
*
* @memberof PIXI
* @name BLEND_MODES
* @enum {number}
* @property {number} NORMAL
* @property {number} ADD
* @property {number} MULTIPLY
* @property {number} SCREEN
* @property {number} OVERLAY
* @property {number} DARKEN
* @property {number} LIGHTEN
* @property {number} COLOR_DODGE
* @property {number} COLOR_BURN
* @property {number} HARD_LIGHT
* @property {number} SOFT_LIGHT
* @property {number} DIFFERENCE
* @property {number} EXCLUSION
* @property {number} HUE
* @property {number} SATURATION
* @property {number} COLOR
* @property {number} LUMINOSITY
* @property {number} NORMAL_NPM
* @property {number} ADD_NPM
* @property {number} SCREEN_NPM
* @property {number} NONE
* @property {number} SRC_IN
* @property {number} SRC_OUT
* @property {number} SRC_ATOP
* @property {number} DST_OVER
* @property {number} DST_IN
* @property {number} DST_OUT
* @property {number} DST_ATOP
* @property {number} SUBTRACT
* @property {number} SRC_OVER
* @property {number} ERASE
*/
BlendModesSettings.BLEND_MODES = {
    NORMAL: 0,
    ADD: 1,
    MULTIPLY: 2,
    SCREEN: 3,
    OVERLAY: 4,
    DARKEN: 5,
    LIGHTEN: 6,
    COLOR_DODGE: 7,
    COLOR_BURN: 8,
    HARD_LIGHT: 9,
    SOFT_LIGHT: 10,
    DIFFERENCE: 11,
    EXCLUSION: 12,
    HUE: 13,
    SATURATION: 14,
    COLOR: 15,
    LUMINOSITY: 16,
    NORMAL_NPM: 17,
    ADD_NPM: 18,
    SCREEN_NPM: 19,
    NONE: 20,
    SRC_OVER: 0,
    SRC_IN: 21,
    SRC_OUT: 22,
    SRC_ATOP: 23,
    DST_OVER: 24,
    DST_IN: 25,
    DST_OUT: 26,
    DST_ATOP: 27,
    ERASE: 26,
    SUBTRACT: 28,
};
/**
* maps premultiply flag and blendMode to adjusted blendMode
* @memberof PIXI.utils
* @const premultiplyBlendMode
* @type {Array<number[]>}
*/
BlendModesSettings.premultiplyBlendMode = BlendModesSettings.mapPremultipliedBlendModes();
exports.BlendModesSettings = BlendModesSettings;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/BlurFilter.js":
/*!**********************************************!*\
  !*** ./js-compile/raw-pixi-ts/BlurFilter.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Filter_1 = __webpack_require__(/*! ./Filter */ "./js-compile/raw-pixi-ts/Filter.js");
const BlurFilterPass_1 = __webpack_require__(/*! ./BlurFilterPass */ "./js-compile/raw-pixi-ts/BlurFilterPass.js");
const DisplaySettings_1 = __webpack_require__(/*! ./DisplaySettings */ "./js-compile/raw-pixi-ts/DisplaySettings.js");
class BlurFilter extends Filter_1.Filter {
    constructor(strength = 1, quality = 1, resolution = 1, kernelSize = 5) {
        super();
        this.blurXFilter = new BlurFilterPass_1.BlurFilterPass(true, strength, quality, resolution, kernelSize);
        this.blurYFilter = new BlurFilterPass_1.BlurFilterPass(false, strength, quality, resolution, kernelSize);
        this.resolution = resolution || DisplaySettings_1.DisplaySettings.RESOLUTION;
        this.quality = quality || 4;
        this.blur = strength || 8;
        this.repeatEdgePixels = false;
    }
    /**
     * Applies the filter.
     *
     * @param {PIXI.systems.FilterSystem} filterManager - The manager.
     * @param {PIXI.RenderTexture} input - The input target.
     * @param {PIXI.RenderTexture} output - The output target.
     */
    apply(filterManager, input, output, clear) {
        var xStrength = Math.abs(this.blurXFilter.strength);
        var yStrength = Math.abs(this.blurYFilter.strength);
        if (xStrength && yStrength) {
            var renderTarget = filterManager.getFilterTexture();
            this.blurXFilter.apply(filterManager, input, renderTarget, true);
            this.blurYFilter.apply(filterManager, renderTarget, output, clear);
            filterManager.returnFilterTexture(renderTarget);
        }
        else if (yStrength) {
            this.blurYFilter.apply(filterManager, input, output, clear);
        }
        else {
            this.blurXFilter.apply(filterManager, input, output, clear);
        }
    }
    ;
    updatePadding() {
        if (this._repeatEdgePixels) {
            this.padding = 0;
        }
        else {
            this.padding = Math.max(Math.abs(this.blurXFilter.strength), Math.abs(this.blurYFilter.strength)) * 2;
        }
    }
    ;
    /**
     * Sets the strength of both the blurX and blurY properties simultaneously
     *
     * @member {number}
     * @default 2
     */
    get blur() {
        return this.blurXFilter.blur;
    }
    ;
    set blur(value) {
        this.blurXFilter.blur = this.blurYFilter.blur = value;
        this.updatePadding();
    }
    ;
    /**
     * Sets the number of passes for blur. More passes means higher quaility bluring.
     *
     * @member {number}
     * @default 1
     */
    get quality() {
        return this.blurXFilter.quality;
    }
    ;
    set quality(value) {
        this.blurXFilter.quality = this.blurYFilter.quality = value;
    }
    ;
    /**
     * Sets the strength of the blurX property
     *
     * @member {number}
     * @default 2
     */
    get blurX() {
        return this.blurXFilter.blur;
    }
    ;
    set blurX(value) {
        this.blurXFilter.blur = value;
        this.updatePadding();
    }
    ;
    /**
     * Sets the strength of the blurY property
     *
     * @member {number}
     * @default 2
     */
    get blurY() {
        return this.blurYFilter.blur;
    }
    ;
    set blurY(value) {
        this.blurYFilter.blur = value;
        this.updatePadding();
    }
    ;
    /**
     * Sets the blendmode of the filter
     *
     * @member {number}
     * @default PIXI.BLEND_MODES.NORMAL
     */
    get blendMode() {
        return this.blurYFilter.blendMode;
    }
    ;
    set blendMode(value) {
        this.blurYFilter.blendMode = value;
    }
    ;
    /**
     * If set to true the edge of the target will be clamped
     *
     * @member {bool}
     * @default false
     */
    get repeatEdgePixels() {
        return this._repeatEdgePixels;
    }
    ;
    set repeatEdgePixels(value) {
        this._repeatEdgePixels = value;
        this.updatePadding();
    }
    ;
}
exports.BlurFilter = BlurFilter;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/BlurFilterPass.js":
/*!**************************************************!*\
  !*** ./js-compile/raw-pixi-ts/BlurFilterPass.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Filter_1 = __webpack_require__(/*! ./Filter */ "./js-compile/raw-pixi-ts/Filter.js");
const DisplaySettings_1 = __webpack_require__(/*! ./DisplaySettings */ "./js-compile/raw-pixi-ts/DisplaySettings.js");
class BlurFilterPass extends Filter_1.Filter {
    constructor(horizontal, strength, quality, resolution, kernelSize) {
        kernelSize = kernelSize || 5;
        var vertSrc = BlurFilterPass.generateBlurVertSource(kernelSize, horizontal);
        var fragSrc = BlurFilterPass.generateBlurFragSource(kernelSize);
        super(vertSrc, fragSrc);
        this.horizontal = horizontal;
        this.resolution = resolution || DisplaySettings_1.DisplaySettings.RESOLUTION;
        this._quality = 0;
        this.quality = quality || 4;
        this.blur = strength || 8;
    }
    static generateBlurFragSource(kernelSize) {
        var kernel = BlurFilterPass.GAUSSIAN_VALUES[kernelSize];
        var halfLength = kernel.length;
        var fragSource = BlurFilterPass.fragTemplate$2;
        var blurLoop = '';
        var template = 'gl_FragColor += texture2D(uSampler, vBlurTexCoords[%index%]) * %value%;';
        var value;
        for (var i = 0; i < kernelSize; i++) {
            var blur = template.replace('%index%', i.toString());
            value = i;
            if (i >= halfLength) {
                value = kernelSize - i - 1;
            }
            blur = blur.replace('%value%', kernel[value]);
            blurLoop += blur;
            blurLoop += '\n';
        }
        fragSource = fragSource.replace('%blur%', blurLoop);
        fragSource = fragSource.replace('%size%', kernelSize);
        return fragSource;
    }
    static generateBlurVertSource(kernelSize, x) {
        var halfLength = Math.ceil(kernelSize / 2);
        var vertSource = BlurFilterPass.vertTemplate;
        var blurLoop = '';
        var template;
        // let value;
        if (x) {
            template = 'vBlurTexCoords[%index%] =  textureCoord + vec2(%sampleIndex% * strength, 0.0);';
        }
        else {
            template = 'vBlurTexCoords[%index%] =  textureCoord + vec2(0.0, %sampleIndex% * strength);';
        }
        for (var i = 0; i < kernelSize; i++) {
            var blur = template.replace('%index%', i);
            // value = i;
            // if(i >= halfLength)
            // {
            //     value = kernelSize - i - 1;
            // }
            blur = blur.replace('%sampleIndex%', ((i - (halfLength - 1)) + ".0"));
            blurLoop += blur;
            blurLoop += '\n';
        }
        vertSource = vertSource.replace('%blur%', blurLoop);
        vertSource = vertSource.replace('%size%', kernelSize);
        return vertSource;
    }
    apply(filterManager, input, output, clear) {
        if (output) {
            if (this.horizontal) {
                this.uniforms.strength = (1 / output.width) * (output.width / input.width);
            }
            else {
                this.uniforms.strength = (1 / output.height) * (output.height / input.height);
            }
        }
        else {
            if (this.horizontal) // eslint-disable-line
             {
                this.uniforms.strength = (1 / filterManager.renderer.width) * (filterManager.renderer.width / input.width);
            }
            else {
                this.uniforms.strength = (1 / filterManager.renderer.height) * (filterManager.renderer.height / input.height); // eslint-disable-line
            }
        }
        // screen space!
        this.uniforms.strength *= this.strength;
        this.uniforms.strength /= this.passes;
        if (this.passes === 1) {
            filterManager.applyFilter(this, input, output, clear);
        }
        else {
            var renderTarget = filterManager.getFilterTexture();
            var renderer = filterManager.renderer;
            var flip = input;
            var flop = renderTarget;
            this.state.blend = false;
            filterManager.applyFilter(this, flip, flop, false);
            for (var i = 1; i < this.passes - 1; i++) {
                renderer.renderTexture.bind(flip, flip.filterFrame);
                this.uniforms.uSampler = flop;
                var temp = flop;
                flop = flip;
                flip = temp;
                renderer.shader.bind(this);
                renderer.geometry.draw(5);
            }
            this.state.blend = true;
            filterManager.applyFilter(this, flop, output, clear);
            filterManager.returnFilterTexture(renderTarget);
        }
    }
    ;
    /**
     * Sets the strength of both the blur.
     *
     * @member {number}
     * @default 16
     */
    get blur() {
        return this.strength;
    }
    ;
    set blur(value) {
        this.padding = 1 + (Math.abs(value) * 2);
        this.strength = value;
    }
    ;
    /**
     * Sets the quality of the blur by modifying the number of passes. More passes means higher
     * quaility bluring but the lower the performance.
     *
     * @member {number}
     * @default 4
     */
    get quality() {
        return this._quality;
    }
    ;
    set quality(value) {
        this._quality = value;
        this.passes = value;
    }
    ;
}
BlurFilterPass.GAUSSIAN_VALUES = {
    5: [0.153388, 0.221461, 0.250301],
    7: [0.071303, 0.131514, 0.189879, 0.214607],
    9: [0.028532, 0.067234, 0.124009, 0.179044, 0.20236],
    11: [0.0093, 0.028002, 0.065984, 0.121703, 0.175713, 0.198596],
    13: [0.002406, 0.009255, 0.027867, 0.065666, 0.121117, 0.174868, 0.197641],
    15: [0.000489, 0.002403, 0.009246, 0.02784, 0.065602, 0.120999, 0.174697, 0.197448],
};
BlurFilterPass.vertTemplate = "\n    attribute vec2 aVertexPosition;\n\n    uniform mat3 projectionMatrix;\n\n    uniform float strength;\n\n    varying vec2 vBlurTexCoords[%size%];\n\n    uniform vec4 inputSize;\n    uniform vec4 outputFrame;\n    \n    vec4 filterVertexPosition( void )\n    {\n        vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n    \n        return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n    }\n    \n    vec2 filterTextureCoord( void )\n    {\n        return aVertexPosition * (outputFrame.zw * inputSize.zw);\n    }\n\n    void main(void)\n    {\n        gl_Position = filterVertexPosition();\n\n        vec2 textureCoord = filterTextureCoord();\n        %blur%\n    }";
BlurFilterPass.fragTemplate$2 = [
    'varying vec2 vBlurTexCoords[%size%];',
    'uniform sampler2D uSampler;',
    'void main(void)',
    '{',
    '    gl_FragColor = vec4(0.0);',
    '    %blur%',
    '}'
].join('\n');
exports.BlurFilterPass = BlurFilterPass;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/Bounds.js":
/*!******************************************!*\
  !*** ./js-compile/raw-pixi-ts/Bounds.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Rectangle_1 = __webpack_require__(/*! ./Rectangle */ "./js-compile/raw-pixi-ts/Rectangle.js");
class Bounds {
    constructor() {
        /**
         * @member {number}
         * @default 0
         */
        this.minX = Infinity;
        /**
         * @member {number}
         * @default 0
         */
        this.minY = Infinity;
        /**
         * @member {number}
         * @default 0
         */
        this.maxX = -Infinity;
        /**
         * @member {number}
         * @default 0
         */
        this.maxY = -Infinity;
        this.rect = null;
    }
    /**
 * Checks if bounds are empty.
 *
 * @return {boolean} True if empty.
 */
    isEmpty() {
        return this.minX > this.maxX || this.minY > this.maxY;
    }
    ;
    /**
     * Clears the bounds and resets.
     *
     */
    clear() {
        this.updateID++;
        this.minX = Infinity;
        this.minY = Infinity;
        this.maxX = -Infinity;
        this.maxY = -Infinity;
    }
    ;
    /**
 * Can return Rectangle.EMPTY constant, either construct new rectangle, either use your rectangle
 * It is not guaranteed that it will return tempRect
 *
 * @param {PIXI.Rectangle} rect - temporary object will be used if AABB is not empty
 * @returns {PIXI.Rectangle} A rectangle of the bounds
 */
    getRectangle(rect) {
        if (this.minX > this.maxX || this.minY > this.maxY) {
            return Rectangle_1.Rectangle.EMPTY;
        }
        rect = rect || new Rectangle_1.Rectangle(0, 0, 1, 1);
        rect.x = this.minX;
        rect.y = this.minY;
        rect.width = this.maxX - this.minX;
        rect.height = this.maxY - this.minY;
        return rect;
    }
    ;
    /**
     * This function should be inlined when its possible.
     *
     * @param {PIXI.Point} point - The point to add.
     */
    addPoint(point) {
        this.minX = Math.min(this.minX, point.x);
        this.maxX = Math.max(this.maxX, point.x);
        this.minY = Math.min(this.minY, point.y);
        this.maxY = Math.max(this.maxY, point.y);
    }
    ;
    /**
     * Adds a quad, not transformed
     *
     * @param {Float32Array} vertices - The verts to add.
     */
    addQuad(vertices) {
        var minX = this.minX;
        var minY = this.minY;
        var maxX = this.maxX;
        var maxY = this.maxY;
        var x = vertices[0];
        var y = vertices[1];
        minX = x < minX ? x : minX;
        minY = y < minY ? y : minY;
        maxX = x > maxX ? x : maxX;
        maxY = y > maxY ? y : maxY;
        x = vertices[2];
        y = vertices[3];
        minX = x < minX ? x : minX;
        minY = y < minY ? y : minY;
        maxX = x > maxX ? x : maxX;
        maxY = y > maxY ? y : maxY;
        x = vertices[4];
        y = vertices[5];
        minX = x < minX ? x : minX;
        minY = y < minY ? y : minY;
        maxX = x > maxX ? x : maxX;
        maxY = y > maxY ? y : maxY;
        x = vertices[6];
        y = vertices[7];
        minX = x < minX ? x : minX;
        minY = y < minY ? y : minY;
        maxX = x > maxX ? x : maxX;
        maxY = y > maxY ? y : maxY;
        this.minX = minX;
        this.minY = minY;
        this.maxX = maxX;
        this.maxY = maxY;
    }
    ;
    /**
     * Adds sprite frame, transformed.
     *
     * @param {PIXI.Transform} transform - TODO
     * @param {number} x0 - TODO
     * @param {number} y0 - TODO
     * @param {number} x1 - TODO
     * @param {number} y1 - TODO
     */
    addFrame(transform, x0, y0, x1, y1) {
        var matrix = transform.worldTransform;
        var a = matrix.a;
        var b = matrix.b;
        var c = matrix.c;
        var d = matrix.d;
        var tx = matrix.tx;
        var ty = matrix.ty;
        var minX = this.minX;
        var minY = this.minY;
        var maxX = this.maxX;
        var maxY = this.maxY;
        var x = (a * x0) + (c * y0) + tx;
        var y = (b * x0) + (d * y0) + ty;
        minX = x < minX ? x : minX;
        minY = y < minY ? y : minY;
        maxX = x > maxX ? x : maxX;
        maxY = y > maxY ? y : maxY;
        x = (a * x1) + (c * y0) + tx;
        y = (b * x1) + (d * y0) + ty;
        minX = x < minX ? x : minX;
        minY = y < minY ? y : minY;
        maxX = x > maxX ? x : maxX;
        maxY = y > maxY ? y : maxY;
        x = (a * x0) + (c * y1) + tx;
        y = (b * x0) + (d * y1) + ty;
        minX = x < minX ? x : minX;
        minY = y < minY ? y : minY;
        maxX = x > maxX ? x : maxX;
        maxY = y > maxY ? y : maxY;
        x = (a * x1) + (c * y1) + tx;
        y = (b * x1) + (d * y1) + ty;
        minX = x < minX ? x : minX;
        minY = y < minY ? y : minY;
        maxX = x > maxX ? x : maxX;
        maxY = y > maxY ? y : maxY;
        this.minX = minX;
        this.minY = minY;
        this.maxX = maxX;
        this.maxY = maxY;
    }
    ;
    /**
     * Adds screen vertices from array
     *
     * @param {Float32Array} vertexData - calculated vertices
     * @param {number} beginOffset - begin offset
     * @param {number} endOffset - end offset, excluded
     */
    addVertexData(vertexData, beginOffset, endOffset) {
        var minX = this.minX;
        var minY = this.minY;
        var maxX = this.maxX;
        var maxY = this.maxY;
        for (var i = beginOffset; i < endOffset; i += 2) {
            var x = vertexData[i];
            var y = vertexData[i + 1];
            minX = x < minX ? x : minX;
            minY = y < minY ? y : minY;
            maxX = x > maxX ? x : maxX;
            maxY = y > maxY ? y : maxY;
        }
        this.minX = minX;
        this.minY = minY;
        this.maxX = maxX;
        this.maxY = maxY;
    }
    ;
    /**
     * Add an array of mesh vertices
     *
     * @param {PIXI.Transform} transform - mesh transform
     * @param {Float32Array} vertices - mesh coordinates in array
     * @param {number} beginOffset - begin offset
     * @param {number} endOffset - end offset, excluded
     */
    addVertices(transform, vertices, beginOffset, endOffset) {
        var matrix = transform.worldTransform;
        var a = matrix.a;
        var b = matrix.b;
        var c = matrix.c;
        var d = matrix.d;
        var tx = matrix.tx;
        var ty = matrix.ty;
        var minX = this.minX;
        var minY = this.minY;
        var maxX = this.maxX;
        var maxY = this.maxY;
        for (var i = beginOffset; i < endOffset; i += 2) {
            var rawX = vertices[i];
            var rawY = vertices[i + 1];
            var x = (a * rawX) + (c * rawY) + tx;
            var y = (d * rawY) + (b * rawX) + ty;
            minX = x < minX ? x : minX;
            minY = y < minY ? y : minY;
            maxX = x > maxX ? x : maxX;
            maxY = y > maxY ? y : maxY;
        }
        this.minX = minX;
        this.minY = minY;
        this.maxX = maxX;
        this.maxY = maxY;
    }
    ;
    /**
     * Adds other Bounds
     *
     * @param {PIXI.Bounds} bounds - TODO
     */
    addBounds(bounds) {
        var minX = this.minX;
        var minY = this.minY;
        var maxX = this.maxX;
        var maxY = this.maxY;
        this.minX = bounds.minX < minX ? bounds.minX : minX;
        this.minY = bounds.minY < minY ? bounds.minY : minY;
        this.maxX = bounds.maxX > maxX ? bounds.maxX : maxX;
        this.maxY = bounds.maxY > maxY ? bounds.maxY : maxY;
    }
    ;
    /**
     * Adds other Bounds, masked with Bounds
     *
     * @param {PIXI.Bounds} bounds - TODO
     * @param {PIXI.Bounds} mask - TODO
     */
    addBoundsMask(bounds, mask) {
        var _minX = bounds.minX > mask.minX ? bounds.minX : mask.minX;
        var _minY = bounds.minY > mask.minY ? bounds.minY : mask.minY;
        var _maxX = bounds.maxX < mask.maxX ? bounds.maxX : mask.maxX;
        var _maxY = bounds.maxY < mask.maxY ? bounds.maxY : mask.maxY;
        if (_minX <= _maxX && _minY <= _maxY) {
            var minX = this.minX;
            var minY = this.minY;
            var maxX = this.maxX;
            var maxY = this.maxY;
            this.minX = _minX < minX ? _minX : minX;
            this.minY = _minY < minY ? _minY : minY;
            this.maxX = _maxX > maxX ? _maxX : maxX;
            this.maxY = _maxY > maxY ? _maxY : maxY;
        }
    }
    ;
    /**
     * Adds other Bounds, masked with Rectangle
     *
     * @param {PIXI.Bounds} bounds - TODO
     * @param {PIXI.Rectangle} area - TODO
     */
    addBoundsArea(bounds, area) {
        var _minX = bounds.minX > area.x ? bounds.minX : area.x;
        var _minY = bounds.minY > area.y ? bounds.minY : area.y;
        var _maxX = bounds.maxX < area.x + area.width ? bounds.maxX : (area.x + area.width);
        var _maxY = bounds.maxY < area.y + area.height ? bounds.maxY : (area.y + area.height);
        if (_minX <= _maxX && _minY <= _maxY) {
            var minX = this.minX;
            var minY = this.minY;
            var maxX = this.maxX;
            var maxY = this.maxY;
            this.minX = _minX < minX ? _minX : minX;
            this.minY = _minY < minY ? _minY : minY;
            this.maxX = _maxX > maxX ? _maxX : maxX;
            this.maxY = _maxY > maxY ? _maxY : maxY;
        }
    }
    ;
}
exports.Bounds = Bounds;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/Buffer.js":
/*!******************************************!*\
  !*** ./js-compile/raw-pixi-ts/Buffer.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Runner_1 = __webpack_require__(/*! ./Runner */ "./js-compile/raw-pixi-ts/Runner.js");
class Buffer {
    constructor(data = null, _static = false, index = null) {
        if (_static === void 0) {
            _static = true;
        }
        if (index === void 0) {
            index = false;
        }
        /**
         * The data in the buffer, as a typed array
         *
         * @member {ArrayBuffer| SharedArrayBuffer|ArrayBufferView}
         */
        this.data = data || new Float32Array(1);
        /**
         * A map of renderer IDs to webgl buffer
         *
         * @private
         * @member {object<number, GLBuffer>}
         */
        this._glBuffers = {};
        this._updateID = 0;
        this.index = index;
        this.static = _static;
        this.id = Buffer.UID++;
        this.disposeRunner = new Runner_1.Runner('disposeBuffer', 2);
        // this.disposeRunner = new Runner('disposeBuffer', 2);
    }
    // TODO could explore flagging only a partial upload?
    /**
     * flags this buffer as requiring an upload to the GPU
     */
    update(data) {
        this.data = data || this.data;
        this._updateID++;
    }
    ;
    /**
     * disposes WebGL resources that are connected to this geometry
     */
    dispose() {
        this.disposeRunner.run(this, false);
        // this.disposeRunner.run(this, false);
    }
    ;
    /**
     * Destroys the buffer
     */
    destroy() {
        this.dispose();
        this.data = null;
    }
    ;
    /**
     * Helper function that creates a buffer based on an array or TypedArray
     *
     * @static
     * @param {ArrayBufferView | number[]} data the TypedArray that the buffer will store. If this is a regular Array it will be converted to a Float32Array.
     * @return {PIXI.Buffer} A new Buffer based on the data provided.
     */
    static from(data) {
        if (data instanceof Array) {
            data = new Float32Array(data);
        }
        return new Buffer(data);
    }
    ;
}
Buffer.UID = 0;
exports.Buffer = Buffer;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/BufferResource.js":
/*!**************************************************!*\
  !*** ./js-compile/raw-pixi-ts/BufferResource.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Resource_1 = __webpack_require__(/*! ./Resource */ "./js-compile/raw-pixi-ts/Resource.js");
class BufferResource extends Resource_1.Resource {
    constructor(source, options) {
        var ref = options || {};
        var width = ref.width;
        var height = ref.height;
        if (!width || !height) {
            throw new Error('BufferResource width or height invalid');
        }
        super(width, height);
        /**
         * Source array
         * Cannot be ClampedUint8Array because it cant be uploaded to WebGL
         *
         * @member {Float32Array|Uint8Array|Uint32Array}
         */
        this.data = source;
    }
    /**
     * Upload the texture to the GPU.
     * @param {PIXI.Renderer} renderer Upload to the renderer
     * @param {PIXI.BaseTexture} baseTexture Reference to parent texture
     * @param {PIXI.GLTexture} glTexture glTexture
     * @returns {boolean} true is success
     */
    upload(renderer, baseTexture, glTexture) {
        var gl = renderer.gl;
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, baseTexture.premultiplyAlpha);
        if (glTexture.width === baseTexture.width && glTexture.height === baseTexture.height) {
            gl.texSubImage2D(baseTexture.target, 0, 0, 0, baseTexture.width, baseTexture.height, baseTexture.format, baseTexture.type, this.data);
        }
        else {
            glTexture.width = baseTexture.width;
            glTexture.height = baseTexture.height;
            var internalFormat = baseTexture.format;
            // guess sized format by type and format
            // https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/texImage2D
            if (renderer.context.webGLVersion === 2
                && baseTexture.type === renderer.gl.FLOAT
                && baseTexture.format === renderer.gl.RGBA) {
                internalFormat = renderer.gl.RGBA32F;
            }
            gl.texImage2D(baseTexture.target, 0, internalFormat, baseTexture.width, baseTexture.height, 0, baseTexture.format, baseTexture.type, this.data);
        }
        return true;
    }
    ;
    /**
     * Destroy and don't use after this
     * @override
     */
    dispose() {
        this.data = null;
    }
    ;
    /**
     * Used to auto-detect the type of resource.
     *
     * @static
     * @param {*} source - The source object
     * @return {boolean} `true` if <canvas>
     */
    static test(source) {
        return source instanceof Float32Array
            || source instanceof Uint8Array
            || source instanceof Uint32Array;
    }
    ;
}
exports.BufferResource = BufferResource;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/CacheSettings.js":
/*!*************************************************!*\
  !*** ./js-compile/raw-pixi-ts/CacheSettings.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class CacheSettings {
    static clearTextureCache() {
        var key;
        for (key in CacheSettings.TextureCache) {
            delete CacheSettings.TextureCache[key];
        }
        for (key in CacheSettings.BaseTextureCache) {
            delete CacheSettings.BaseTextureCache[key];
        }
    }
    static destroyTextureCache() {
        var key;
        for (key in CacheSettings.TextureCache) {
            CacheSettings.TextureCache[key].destroy();
        }
        for (key in CacheSettings.BaseTextureCache) {
            CacheSettings.BaseTextureCache[key].destroy();
        }
    }
}
CacheSettings.ProgramCache = {};
CacheSettings.nameCache = {};
CacheSettings.programCache = {};
CacheSettings.TextureCache = {};
CacheSettings.BaseTextureCache = {};
CacheSettings.defaultGroupCache = {};
exports.CacheSettings = CacheSettings;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/CanvasRenderTarget.js":
/*!******************************************************!*\
  !*** ./js-compile/raw-pixi-ts/CanvasRenderTarget.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const DisplaySettings_1 = __webpack_require__(/*! ./DisplaySettings */ "./js-compile/raw-pixi-ts/DisplaySettings.js");
class CanvasRenderTarget {
    constructor(width, height, resolution) {
        /**
                 * The Canvas object that belongs to this CanvasRenderTarget.
                 *
                 * @member {HTMLCanvasElement}
                 */
        this.canvas = document.createElement('canvas');
        /**
         * A CanvasRenderingContext2D object representing a two-dimensional rendering context.
         *
         * @member {CanvasRenderingContext2D}
         */
        this.context = this.canvas.getContext('2d');
        this.resolution = resolution || DisplaySettings_1.DisplaySettings.RESOLUTION;
        this.resize(width, height);
    }
    /**
     * Clears the canvas that was created by the CanvasRenderTarget class.
     *
     * @private
     */
    clear() {
        this.context.setTransform(1, 0, 0, 1, 0, 0);
        this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
    }
    ;
    /**
     * Resizes the canvas to the specified width and height.
     *
     * @param {number} width - the new width of the canvas
     * @param {number} height - the new height of the canvas
     */
    resize(width, height) {
        this.canvas.width = width * this.resolution;
        this.canvas.height = height * this.resolution;
    }
    ;
    /**
     * Destroys this canvas.
     *
     */
    destroy() {
        this.context = null;
        this.canvas = null;
    }
    ;
    /**
     * The width of the canvas buffer in pixels.
     *
     * @member {number}
     */
    get width() {
        return this.canvas.width;
    }
    ;
    set width(val) {
        this.canvas.width = val;
    }
    ;
    /**
     * The height of the canvas buffer in pixels.
     *
     * @member {number}
     */
    get height() {
        return this.canvas.height;
    }
    ;
    set height(val) {
        this.canvas.height = val;
    }
    ;
}
exports.CanvasRenderTarget = CanvasRenderTarget;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/CanvasResource.js":
/*!**************************************************!*\
  !*** ./js-compile/raw-pixi-ts/CanvasResource.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseImageResource_1 = __webpack_require__(/*! ./BaseImageResource */ "./js-compile/raw-pixi-ts/BaseImageResource.js");
class CanvasResource extends BaseImageResource_1.BaseImageResource {
    constructor(source) {
        super(source);
    }
    static test(source) {
        return (source instanceof HTMLCanvasElement);
    }
    ;
}
exports.CanvasResource = CanvasResource;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/CanvasSettings.js":
/*!**************************************************!*\
  !*** ./js-compile/raw-pixi-ts/CanvasSettings.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class CanvasSettings {
    /**
* Trim transparent borders from a canvas
*
* @memberof PIXI.utils
* @function trimCanvas
* @param {HTMLCanvasElement} canvas - the canvas to trim
* @returns {object} Trim data
*/
    static trimCanvas(canvas) {
        // https://gist.github.com/remy/784508
        var width = canvas.width;
        var height = canvas.height;
        var context = canvas.getContext('2d');
        var imageData = context.getImageData(0, 0, width, height);
        var pixels = imageData.data;
        var len = pixels.length;
        var bound = {
            top: null,
            left: null,
            right: null,
            bottom: null,
        };
        var data = null;
        var i;
        var x;
        var y;
        for (i = 0; i < len; i += 4) {
            if (pixels[i + 3] !== 0) {
                x = (i / 4) % width;
                y = ~~((i / 4) / width);
                if (bound.top === null) {
                    bound.top = y;
                }
                if (bound.left === null) {
                    bound.left = x;
                }
                else if (x < bound.left) {
                    bound.left = x;
                }
                if (bound.right === null) {
                    bound.right = x + 1;
                }
                else if (bound.right < x) {
                    bound.right = x + 1;
                }
                if (bound.bottom === null) {
                    bound.bottom = y;
                }
                else if (bound.bottom < y) {
                    bound.bottom = y;
                }
            }
        }
        if (bound.top !== null) {
            width = bound.right - bound.left;
            height = bound.bottom - bound.top + 1;
            data = context.getImageData(bound.left, bound.top, width, height);
        }
        return {
            height: height,
            width: width,
            data: data,
        };
    }
}
exports.CanvasSettings = CanvasSettings;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/Circle.js":
/*!******************************************!*\
  !*** ./js-compile/raw-pixi-ts/Circle.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Rectangle_1 = __webpack_require__(/*! ./Rectangle */ "./js-compile/raw-pixi-ts/Rectangle.js");
const ShapeSettings_1 = __webpack_require__(/*! ./ShapeSettings */ "./js-compile/raw-pixi-ts/ShapeSettings.js");
class Circle {
    constructor(x = 0, y = 0, radius = 0) {
        if (x === void 0) {
            x = 0;
        }
        if (y === void 0) {
            y = 0;
        }
        if (radius === void 0) {
            radius = 0;
        }
        /**
         * @member {number}
         * @default 0
         */
        this.x = x;
        /**
         * @member {number}
         * @default 0
         */
        this.y = y;
        /**
         * @member {number}
         * @default 0
         */
        this.radius = radius;
        /**
         * The type of the object, mainly used to avoid `instanceof` checks
         *
         * @member {number}
         * @readOnly
         * @default PIXI.SHAPES.CIRC
         * @see PIXI.SHAPES
         */
        this.type = ShapeSettings_1.ShapeSettings.SHAPES.CIRC;
    }
    /**
     * Creates a clone of this Circle instance
     *
     * @return {PIXI.Circle} a copy of the Circle
     */
    clone() {
        return new Circle(this.x, this.y, this.radius);
    }
    ;
    /**
     * Checks whether the x and y coordinates given are contained within this circle
     *
     * @param {number} x - The X coordinate of the point to test
     * @param {number} y - The Y coordinate of the point to test
     * @return {boolean} Whether the x/y coordinates are within this Circle
     */
    contains(x, y) {
        if (this.radius <= 0) {
            return false;
        }
        var r2 = this.radius * this.radius;
        var dx = (this.x - x);
        var dy = (this.y - y);
        dx *= dx;
        dy *= dy;
        return (dx + dy <= r2);
    }
    ;
    /**
    * Returns the framing rectangle of the circle as a Rectangle object
    *
    * @return {PIXI.Rectangle} the framing rectangle
    */
    getBounds() {
        return new Rectangle_1.Rectangle(this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2);
    }
    ;
}
exports.Circle = Circle;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/CleanUpSettings.js":
/*!***************************************************!*\
  !*** ./js-compile/raw-pixi-ts/CleanUpSettings.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class CleanUpSettings {
}
CleanUpSettings.defaultDestroyOptions = {
    texture: true,
    children: false,
    baseTexture: true,
};
exports.CleanUpSettings = CleanUpSettings;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/ColorMatrixFilter.js":
/*!*****************************************************!*\
  !*** ./js-compile/raw-pixi-ts/ColorMatrixFilter.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Filter_1 = __webpack_require__(/*! ./Filter */ "./js-compile/raw-pixi-ts/Filter.js");
const settings_1 = __webpack_require__(/*! ./settings */ "./js-compile/raw-pixi-ts/settings.js");
class ColorMatrixFilter extends Filter_1.Filter {
    constructor() {
        var uniforms = {
            m: new Float32Array([1, 0, 0, 0, 0,
                0, 1, 0, 0, 0,
                0, 0, 1, 0, 0,
                0, 0, 0, 1, 0]),
            uAlpha: 1,
        };
        super(settings_1.settings.defaultFilterVertex, ColorMatrixFilter.fragment$4, uniforms);
        this.alpha = 1;
    }
    /**
     * Transforms current matrix and set the new one
     *
     * @param {number[]} matrix - 5x4 matrix
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */
    _loadMatrix(matrix, multiply) {
        if (multiply === void 0) {
            multiply = false;
        }
        var newMatrix = matrix;
        if (multiply) {
            this._multiply(newMatrix, this.uniforms.m, matrix);
            newMatrix = this._colorMatrix(newMatrix);
        }
        // set the new matrix
        this.uniforms.m = newMatrix;
    }
    ;
    /**
     * Multiplies two mat5's
     *
     * @private
     * @param {number[]} out - 5x4 matrix the receiving matrix
     * @param {number[]} a - 5x4 matrix the first operand
     * @param {number[]} b - 5x4 matrix the second operand
     * @returns {number[]} 5x4 matrix
     */
    _multiply(out, a, b) {
        // Red Channel
        out[0] = (a[0] * b[0]) + (a[1] * b[5]) + (a[2] * b[10]) + (a[3] * b[15]);
        out[1] = (a[0] * b[1]) + (a[1] * b[6]) + (a[2] * b[11]) + (a[3] * b[16]);
        out[2] = (a[0] * b[2]) + (a[1] * b[7]) + (a[2] * b[12]) + (a[3] * b[17]);
        out[3] = (a[0] * b[3]) + (a[1] * b[8]) + (a[2] * b[13]) + (a[3] * b[18]);
        out[4] = (a[0] * b[4]) + (a[1] * b[9]) + (a[2] * b[14]) + (a[3] * b[19]) + a[4];
        // Green Channel
        out[5] = (a[5] * b[0]) + (a[6] * b[5]) + (a[7] * b[10]) + (a[8] * b[15]);
        out[6] = (a[5] * b[1]) + (a[6] * b[6]) + (a[7] * b[11]) + (a[8] * b[16]);
        out[7] = (a[5] * b[2]) + (a[6] * b[7]) + (a[7] * b[12]) + (a[8] * b[17]);
        out[8] = (a[5] * b[3]) + (a[6] * b[8]) + (a[7] * b[13]) + (a[8] * b[18]);
        out[9] = (a[5] * b[4]) + (a[6] * b[9]) + (a[7] * b[14]) + (a[8] * b[19]) + a[9];
        // Blue Channel
        out[10] = (a[10] * b[0]) + (a[11] * b[5]) + (a[12] * b[10]) + (a[13] * b[15]);
        out[11] = (a[10] * b[1]) + (a[11] * b[6]) + (a[12] * b[11]) + (a[13] * b[16]);
        out[12] = (a[10] * b[2]) + (a[11] * b[7]) + (a[12] * b[12]) + (a[13] * b[17]);
        out[13] = (a[10] * b[3]) + (a[11] * b[8]) + (a[12] * b[13]) + (a[13] * b[18]);
        out[14] = (a[10] * b[4]) + (a[11] * b[9]) + (a[12] * b[14]) + (a[13] * b[19]) + a[14];
        // Alpha Channel
        out[15] = (a[15] * b[0]) + (a[16] * b[5]) + (a[17] * b[10]) + (a[18] * b[15]);
        out[16] = (a[15] * b[1]) + (a[16] * b[6]) + (a[17] * b[11]) + (a[18] * b[16]);
        out[17] = (a[15] * b[2]) + (a[16] * b[7]) + (a[17] * b[12]) + (a[18] * b[17]);
        out[18] = (a[15] * b[3]) + (a[16] * b[8]) + (a[17] * b[13]) + (a[18] * b[18]);
        out[19] = (a[15] * b[4]) + (a[16] * b[9]) + (a[17] * b[14]) + (a[18] * b[19]) + a[19];
        return out;
    }
    ;
    /**
     * Create a Float32 Array and normalize the offset component to 0-1
     *
     * @private
     * @param {number[]} matrix - 5x4 matrix
     * @return {number[]} 5x4 matrix with all values between 0-1
     */
    _colorMatrix(matrix) {
        // Create a Float32 Array and normalize the offset component to 0-1
        var m = new Float32Array(matrix);
        m[4] /= 255;
        m[9] /= 255;
        m[14] /= 255;
        m[19] /= 255;
        return m;
    }
    ;
    /**
     * Adjusts brightness
     *
     * @param {number} b - value of the brigthness (0-1, where 0 is black)
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */
    brightness(b, multiply) {
        var matrix = [
            b, 0, 0, 0, 0,
            0, b, 0, 0, 0,
            0, 0, b, 0, 0,
            0, 0, 0, 1, 0
        ];
        this._loadMatrix(matrix, multiply);
    }
    ;
    /**
     * Set the matrices in grey scales
     *
     * @param {number} scale - value of the grey (0-1, where 0 is black)
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */
    greyscale(scale, multiply) {
        var matrix = [
            scale, scale, scale, 0, 0,
            scale, scale, scale, 0, 0,
            scale, scale, scale, 0, 0,
            0, 0, 0, 1, 0
        ];
        this._loadMatrix(matrix, multiply);
    }
    ;
    /**
     * Set the black and white matrice.
     *
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */
    blackAndWhite(multiply) {
        var matrix = [
            0.3, 0.6, 0.1, 0, 0,
            0.3, 0.6, 0.1, 0, 0,
            0.3, 0.6, 0.1, 0, 0,
            0, 0, 0, 1, 0
        ];
        this._loadMatrix(matrix, multiply);
    }
    ;
    /**
     * Set the hue property of the color
     *
     * @param {number} rotation - in degrees
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */
    hue(rotation, multiply) {
        rotation = (rotation || 0) / 180 * Math.PI;
        var cosR = Math.cos(rotation);
        var sinR = Math.sin(rotation);
        var sqrt = Math.sqrt;
        /* a good approximation for hue rotation
            This matrix is far better than the versions with magic luminance constants
            formerly used here, but also used in the starling framework (flash) and known from this
            old part of the internet: quasimondo.com/archives/000565.php

            This new matrix is based on rgb cube rotation in space. Look here for a more descriptive
            implementation as a shader not a general matrix:
            https://github.com/evanw/glfx.js/blob/58841c23919bd59787effc0333a4897b43835412/src/filters/adjust/huesaturation.js

            This is the source for the code:
            see http://stackoverflow.com/questions/8507885/shift-hue-of-an-rgb-color/8510751#8510751
            */
        var w = 1 / 3;
        var sqrW = sqrt(w); // weight is
        var a00 = cosR + ((1.0 - cosR) * w);
        var a01 = (w * (1.0 - cosR)) - (sqrW * sinR);
        var a02 = (w * (1.0 - cosR)) + (sqrW * sinR);
        var a10 = (w * (1.0 - cosR)) + (sqrW * sinR);
        var a11 = cosR + (w * (1.0 - cosR));
        var a12 = (w * (1.0 - cosR)) - (sqrW * sinR);
        var a20 = (w * (1.0 - cosR)) - (sqrW * sinR);
        var a21 = (w * (1.0 - cosR)) + (sqrW * sinR);
        var a22 = cosR + (w * (1.0 - cosR));
        var matrix = [
            a00, a01, a02, 0, 0,
            a10, a11, a12, 0, 0,
            a20, a21, a22, 0, 0,
            0, 0, 0, 1, 0
        ];
        this._loadMatrix(matrix, multiply);
    }
    ;
    /**
     * Set the contrast matrix, increase the separation between dark and bright
     * Increase contrast : shadows darker and highlights brighter
     * Decrease contrast : bring the shadows up and the highlights down
     *
     * @param {number} amount - value of the contrast (0-1)
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */
    contrast(amount, multiply) {
        var v = (amount || 0) + 1;
        var o = -0.5 * (v - 1);
        var matrix = [
            v, 0, 0, 0, o,
            0, v, 0, 0, o,
            0, 0, v, 0, o,
            0, 0, 0, 1, 0
        ];
        this._loadMatrix(matrix, multiply);
    }
    ;
    /**
     * Set the saturation matrix, increase the separation between colors
     * Increase saturation : increase contrast, brightness, and sharpness
     *
     * @param {number} amount - The saturation amount (0-1)
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */
    saturate(amount, multiply = null) {
        if (amount === void 0) {
            amount = 0;
        }
        var x = (amount * 2 / 3) + 1;
        var y = ((x - 1) * -0.5);
        var matrix = [
            x, y, y, 0, 0,
            y, x, y, 0, 0,
            y, y, x, 0, 0,
            0, 0, 0, 1, 0
        ];
        this._loadMatrix(matrix, multiply);
    }
    ;
    /**
     * Desaturate image (remove color)
     *
     * Call the saturate function
     *
     */
    desaturate() {
        this.saturate(-1);
    }
    ;
    /**
     * Negative image (inverse of classic rgb matrix)
     *
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */
    negative(multiply) {
        var matrix = [
            -1, 0, 0, 1, 0,
            0, -1, 0, 1, 0,
            0, 0, -1, 1, 0,
            0, 0, 0, 1, 0
        ];
        this._loadMatrix(matrix, multiply);
    }
    ;
    /**
     * Sepia image
     *
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */
    sepia(multiply) {
        var matrix = [
            0.393, 0.7689999, 0.18899999, 0, 0,
            0.349, 0.6859999, 0.16799999, 0, 0,
            0.272, 0.5339999, 0.13099999, 0, 0,
            0, 0, 0, 1, 0
        ];
        this._loadMatrix(matrix, multiply);
    }
    ;
    /**
     * Color motion picture process invented in 1916 (thanks Dominic Szablewski)
     *
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */
    technicolor(multiply) {
        var matrix = [
            1.9125277891456083, -0.8545344976951645, -0.09155508482755585, 0, 11.793603434377337,
            -0.3087833385928097, 1.7658908555458428, -0.10601743074722245, 0, -70.35205161461398,
            -0.231103377548616, -0.7501899197440212, 1.847597816108189, 0, 30.950940869491138,
            0, 0, 0, 1, 0
        ];
        this._loadMatrix(matrix, multiply);
    }
    ;
    /**
     * Polaroid filter
     *
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */
    polaroid(multiply) {
        var matrix = [
            1.438, -0.062, -0.062, 0, 0,
            -0.122, 1.378, -0.122, 0, 0,
            -0.016, -0.016, 1.483, 0, 0,
            0, 0, 0, 1, 0
        ];
        this._loadMatrix(matrix, multiply);
    }
    ;
    /**
     * Filter who transforms : Red -> Blue and Blue -> Red
     *
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */
    toBGR(multiply) {
        var matrix = [
            0, 0, 1, 0, 0,
            0, 1, 0, 0, 0,
            1, 0, 0, 0, 0,
            0, 0, 0, 1, 0
        ];
        this._loadMatrix(matrix, multiply);
    }
    ;
    /**
     * Color reversal film introduced by Eastman Kodak in 1935. (thanks Dominic Szablewski)
     *
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */
    kodachrome(multiply) {
        var matrix = [
            1.1285582396593525, -0.3967382283601348, -0.03992559172921793, 0, 63.72958762196502,
            -0.16404339962244616, 1.0835251566291304, -0.05498805115633132, 0, 24.732407896706203,
            -0.16786010706155763, -0.5603416277695248, 1.6014850761964943, 0, 35.62982807460946,
            0, 0, 0, 1, 0
        ];
        this._loadMatrix(matrix, multiply);
    }
    ;
    /**
     * Brown delicious browni filter (thanks Dominic Szablewski)
     *
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */
    browni(multiply) {
        var matrix = [
            0.5997023498159715, 0.34553243048391263, -0.2708298674538042, 0, 47.43192855600873,
            -0.037703249837783157, 0.8609577587992641, 0.15059552388459913, 0, -36.96841498319127,
            0.24113635128153335, -0.07441037908422492, 0.44972182064877153, 0, -7.562075277591283,
            0, 0, 0, 1, 0
        ];
        this._loadMatrix(matrix, multiply);
    }
    ;
    /**
     * Vintage filter (thanks Dominic Szablewski)
     *
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */
    vintage(multiply) {
        var matrix = [
            0.6279345635605994, 0.3202183420819367, -0.03965408211312453, 0, 9.651285835294123,
            0.02578397704808868, 0.6441188644374771, 0.03259127616149294, 0, 7.462829176470591,
            0.0466055556782719, -0.0851232987247891, 0.5241648018700465, 0, 5.159190588235296,
            0, 0, 0, 1, 0
        ];
        this._loadMatrix(matrix, multiply);
    }
    ;
    /**
     * We don't know exactly what it does, kind of gradient map, but funny to play with!
     *
     * @param {number} desaturation - Tone values.
     * @param {number} toned - Tone values.
     * @param {string} lightColor - Tone values, example: `0xFFE580`
     * @param {string} darkColor - Tone values, example: `0xFFE580`
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */
    colorTone(desaturation, toned, lightColor, darkColor, multiply) {
        desaturation = desaturation || 0.2;
        toned = toned || 0.15;
        lightColor = lightColor || 0xFFE580;
        darkColor = darkColor || 0x338000;
        var lR = ((lightColor >> 16) & 0xFF) / 255;
        var lG = ((lightColor >> 8) & 0xFF) / 255;
        var lB = (lightColor & 0xFF) / 255;
        var dR = ((darkColor >> 16) & 0xFF) / 255;
        var dG = ((darkColor >> 8) & 0xFF) / 255;
        var dB = (darkColor & 0xFF) / 255;
        var matrix = [
            0.3, 0.59, 0.11, 0, 0,
            lR, lG, lB, desaturation, 0,
            dR, dG, dB, toned, 0,
            lR - dR, lG - dG, lB - dB, 0, 0
        ];
        this._loadMatrix(matrix, multiply);
    }
    ;
    /**
     * Night effect
     *
     * @param {number} intensity - The intensity of the night effect.
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */
    night(intensity, multiply) {
        intensity = intensity || 0.1;
        var matrix = [
            intensity * (-2.0), -intensity, 0, 0, 0,
            -intensity, 0, intensity, 0, 0,
            0, intensity, intensity * 2.0, 0, 0,
            0, 0, 0, 1, 0
        ];
        this._loadMatrix(matrix, multiply);
    }
    ;
    /**
     * Predator effect
     *
     * Erase the current matrix by setting a new indepent one
     *
     * @param {number} amount - how much the predator feels his future victim
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */
    predator(amount, multiply) {
        var matrix = [
            // row 1
            11.224130630493164 * amount,
            -4.794486999511719 * amount,
            -2.8746118545532227 * amount,
            0 * amount,
            0.40342438220977783 * amount,
            // row 2
            -3.6330697536468506 * amount,
            9.193157196044922 * amount,
            -2.951810836791992 * amount,
            0 * amount,
            -1.316135048866272 * amount,
            // row 3
            -3.2184197902679443 * amount,
            -4.2375030517578125 * amount,
            7.476448059082031 * amount,
            0 * amount,
            0.8044459223747253 * amount,
            // row 4
            0, 0, 0, 1, 0
        ];
        this._loadMatrix(matrix, multiply);
    }
    ;
    /**
     * LSD effect
     *
     * Multiply the current matrix
     *
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */
    lsd(multiply) {
        var matrix = [
            2, -0.4, 0.5, 0, 0,
            -0.5, 2, -0.4, 0, 0,
            -0.4, -0.5, 3, 0, 0,
            0, 0, 0, 1, 0
        ];
        this._loadMatrix(matrix, multiply);
    }
    ;
    /**
     * Erase the current matrix by setting the default one
     *
     */
    reset() {
        var matrix = [
            1, 0, 0, 0, 0,
            0, 1, 0, 0, 0,
            0, 0, 1, 0, 0,
            0, 0, 0, 1, 0
        ];
        this._loadMatrix(matrix, false);
    }
    ;
    /**
     * The matrix of the color matrix filter
     *
     * @member {number[]}
     * @default [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0]
     */
    get matrix() {
        return this.uniforms.m;
    }
    ;
    set matrix(value) {
        this.uniforms.m = value;
    }
    ;
    /**
     * The opacity value to use when mixing the original and resultant colors.
     *
     * When the value is 0, the original color is used without modification.
     * When the value is 1, the result color is used.
     * When in the range (0, 1) the color is interpolated between the original and result by this amount.
     *
     * @member {number}
     * @default 1
     */
    get alpha() {
        return this.uniforms.uAlpha;
    }
    ;
    set alpha(value) {
        this.uniforms.uAlpha = value;
    }
    ;
}
/*!
* @pixi/filter-color-matrix - v5.0.0-rc.3
* Compiled Wed, 10 Apr 2019 01:21:15 UTC
*
* @pixi/filter-color-matrix is licensed under the MIT License.
* http://www.opensource.org/licenses/mit-license
*/
ColorMatrixFilter.fragment$4 = "varying vec2 vTextureCoord;\r\nuniform sampler2D uSampler;\r\nuniform float m[20];\r\nuniform float uAlpha;\r\n\r\nvoid main(void)\r\n{\r\n    vec4 c = texture2D(uSampler, vTextureCoord);\r\n\r\n    if (uAlpha == 0.0) {\r\n        gl_FragColor = c;\r\n        return;\r\n    }\r\n\r\n    // Un-premultiply alpha before applying the color matrix. See issue #3539.\r\n    if (c.a > 0.0) {\r\n      c.rgb /= c.a;\r\n    }\r\n\r\n    vec4 result;\r\n\r\n    result.r = (m[0] * c.r);\r\n        result.r += (m[1] * c.g);\r\n        result.r += (m[2] * c.b);\r\n        result.r += (m[3] * c.a);\r\n        result.r += m[4];\r\n\r\n    result.g = (m[5] * c.r);\r\n        result.g += (m[6] * c.g);\r\n        result.g += (m[7] * c.b);\r\n        result.g += (m[8] * c.a);\r\n        result.g += m[9];\r\n\r\n    result.b = (m[10] * c.r);\r\n       result.b += (m[11] * c.g);\r\n       result.b += (m[12] * c.b);\r\n       result.b += (m[13] * c.a);\r\n       result.b += m[14];\r\n\r\n    result.a = (m[15] * c.r);\r\n       result.a += (m[16] * c.g);\r\n       result.a += (m[17] * c.b);\r\n       result.a += (m[18] * c.a);\r\n       result.a += m[19];\r\n\r\n    vec3 rgb = mix(c.rgb, result.rgb, uAlpha);\r\n\r\n    // Premultiply alpha again.\r\n    rgb *= result.a;\r\n\r\n    gl_FragColor = vec4(rgb, result.a);\r\n}\r\n";
exports.ColorMatrixFilter = ColorMatrixFilter;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/ColorSettings.js":
/*!*************************************************!*\
  !*** ./js-compile/raw-pixi-ts/ColorSettings.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const MathSettings_1 = __webpack_require__(/*! ./MathSettings */ "./js-compile/raw-pixi-ts/MathSettings.js");
class ColorSettings {
    static premultiplyTint(tint, alpha) {
        if (alpha === 1.0) {
            return (alpha * 255 << 24) + tint;
        }
        if (alpha === 0.0) {
            return 0;
        }
        var R = ((tint >> 16) & 0xFF);
        var G = ((tint >> 8) & 0xFF);
        var B = (tint & 0xFF);
        R = ((R * alpha) + 0.5) | 0;
        G = ((G * alpha) + 0.5) | 0;
        B = ((B * alpha) + 0.5) | 0;
        return (alpha * 255 << 24) + (R << 16) + (G << 8) + B;
    }
    static premultiplyTintToRgba(tint, alpha, out, premultiply) {
        out = out || new Float32Array(4);
        out[0] = ((tint >> 16) & 0xFF) / 255.0;
        out[1] = ((tint >> 8) & 0xFF) / 255.0;
        out[2] = (tint & 0xFF) / 255.0;
        if (premultiply || premultiply === undefined) {
            out[0] *= alpha;
            out[1] *= alpha;
            out[2] *= alpha;
        }
        out[3] = alpha;
        return out;
    }
    static getSingleColor(color) {
        if (typeof color === 'number') {
            return MathSettings_1.MathSettings.hex2string(color);
        }
        else if (typeof color === 'string') {
            if (color.indexOf('0x') === 0) {
                color = color.replace('0x', '#');
            }
        }
        return color;
    }
    static getColor(color) {
        if (!Array.isArray(color)) {
            return ColorSettings.getSingleColor(color);
        }
        else {
            for (var i = 0; i < color.length; ++i) {
                color[i] = ColorSettings.getSingleColor(color[i]);
            }
            return color;
        }
    }
    static premultiplyRgba(rgb, alpha, out, premultiply) {
        out = out || new Float32Array(4);
        if (premultiply || premultiply === undefined) {
            out[0] = rgb[0] * alpha;
            out[1] = rgb[1] * alpha;
            out[2] = rgb[2] * alpha;
        }
        else {
            out[0] = rgb[0];
            out[1] = rgb[1];
            out[2] = rgb[2];
        }
        out[3] = alpha;
        return out;
    }
    /**
* Converts a hexadecimal color number to an [R, G, B] array of normalized floats (numbers from 0.0 to 1.0).
*
* @example
* PIXI.utils.hex2rgb(0xffffff); // returns [1, 1, 1]
* @memberof PIXI.utils
* @function hex2rgb
* @param {number} hex - The hexadecimal number to convert
* @param  {number[]} [out=[]] If supplied, this array will be used rather than returning a new one
* @return {number[]} An array representing the [R, G, B] of the color where all values are floats.
*/
    static hex2rgb(hex, out = null) {
        out = out || [];
        out[0] = ((hex >> 16) & 0xFF) / 255;
        out[1] = ((hex >> 8) & 0xFF) / 255;
        out[2] = (hex & 0xFF) / 255;
        return out;
    }
    /**
* Converts a color as an [R, G, B] array of normalized floats to a hexadecimal number.
*
* @example
* PIXI.utils.rgb2hex([1, 1, 1]); // returns 0xffffff
* @memberof PIXI.utils
* @function rgb2hex
* @param {number[]} rgb - Array of numbers where all values are normalized floats from 0.0 to 1.0.
* @return {number} Number in hexadecimal.
*/
    static rgb2hex(rgb) {
        return (((rgb[0] * 255) << 16) + ((rgb[1] * 255) << 8) + (rgb[2] * 255 | 0));
    }
}
exports.ColorSettings = ColorSettings;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/Container.js":
/*!*********************************************!*\
  !*** ./js-compile/raw-pixi-ts/Container.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const DisplayObject_1 = __webpack_require__(/*! ./DisplayObject */ "./js-compile/raw-pixi-ts/DisplayObject.js");
const Event_1 = __webpack_require__(/*! ./Event */ "./js-compile/raw-pixi-ts/Event.js");
const UtilsSettings_1 = __webpack_require__(/*! ./UtilsSettings */ "./js-compile/raw-pixi-ts/UtilsSettings.js");
const DisplaySettings_1 = __webpack_require__(/*! ./DisplaySettings */ "./js-compile/raw-pixi-ts/DisplaySettings.js");
class Container extends DisplayObject_1.DisplayObject {
    constructor() {
        super();
        this.containerUpdateTransform = this.updateTransform;
        /**
         * The array of children of this container.
         *
         * @member {PIXI.DisplayObject[]}
         * @readonly
         */
        this.children = [];
        /**
         * If set to true, the container will sort its children by zIndex value
         * when updateTransform() is called, or manually if sortChildren() is called.
         *
         * This actually changes the order of elements in the array, so should be treated
         * as a basic solution that is not performant compared to other solutions,
         * such as @link https://github.com/pixijs/pixi-display
         *
         * Also be aware of that this may not work nicely with the addChildAt() function,
         * as the zIndex sorting may cause the child to automatically sorted to another position.
         *
         * @see PIXI.settings.SORTABLE_CHILDREN
         *
         * @member {boolean}
         */
        this.sortableChildren = DisplaySettings_1.DisplaySettings.SORTABLE_CHILDREN;
        /**
         * Should children be sorted by zIndex at the next updateTransform call.
         * Will get automatically set to true if a new child is added, or if a child's zIndex changes.
         *
         * @member {boolean}
         */
        this.sortDirty = false;
        /**
         * Fired when a DisplayObject is added to this Container.
         *
         * @event PIXI.Container#childAdded
         * @param {PIXI.DisplayObject} child - The child added to the Container.
         * @param {PIXI.Container} container - The container that added the child.
         * @param {number} index - The children's index of the added child.
         */
        /**
         * Fired when a DisplayObject is removed from this Container.
         *
         * @event PIXI.DisplayObject#removedFrom
         * @param {PIXI.DisplayObject} child - The child removed from the Container.
         * @param {PIXI.Container} container - The container that removed removed the child.
         * @param {number} index - The former children's index of the removed child
         */
    }
    /**
 * Returns the display object in the container.
 *
 * @method getChildByName
 * @memberof PIXI.Container#
 * @param {string} name - Instance name.
 * @return {PIXI.DisplayObject} The child with the specified name.
 */
    getChildByName(name) {
        for (var i = 0; i < this.children.length; i++) {
            if (this.children[i].name === name) {
                return this.children[i];
            }
        }
        return null;
    }
    ;
    /**
     * Overridable method that can be used by Container subclasses whenever the children array is modified
     *
     * @protected
     */
    onChildrenChange(options) {
        /* empty */
    }
    ;
    /**
     * Adds one or more children to the container.
     *
     * Multiple items can be added like so: `myContainer.addChild(thingOne, thingTwo, thingThree)`
     *
     * @param {...PIXI.DisplayObject} child - The DisplayObject(s) to add to the container
     * @return {PIXI.DisplayObject} The first child that was added.
     */
    addChild(child) {
        var arguments$1 = arguments;
        var argumentsLength = arguments.length;
        // if there is only one argument we can bypass looping through the them
        if (argumentsLength > 1) {
            // loop through the arguments property and add all children
            // use it the right way (.length and [i]) so that this function can still be optimized by JS runtimes
            for (var i = 0; i < argumentsLength; i++) {
                this.addChild(arguments$1[i]);
            }
        }
        else {
            // if the child has a parent then lets remove it as PixiJS objects can only exist in one place
            if (child.parent) {
                child.parent.removeChild(child);
            }
            child.parent = this;
            this.sortDirty = true;
            // ensure child transform will be recalculated
            child.transform._parentID = -1;
            this.children.push(child);
            // ensure bounds will be recalculated
            this._boundsID++;
            // TODO - lets either do all callbacks or all events.. not both!
            this.onChildrenChange(this.children.length - 1);
            this.dispatchEvent(Event_1.Event.getEvent("childAdded"));
            // this.emit('childAdded', child, this, this.children.length - 1);
            child.dispatchEvent(Event_1.Event.getEvent("added"));
            // child.emit('added', this);
        }
        return child;
    }
    ;
    /**
     * Adds a child to the container at a specified index. If the index is out of bounds an error will be thrown
     *
     * @param {PIXI.DisplayObject} child - The child to add
     * @param {number} index - The index to place the child in
     * @return {PIXI.DisplayObject} The child that was added.
     */
    addChildAt(child, index) {
        if (index < 0 || index > this.children.length) {
            throw new Error((child + "addChildAt: The index " + index + " supplied is out of bounds " + (this.children.length)));
        }
        if (child.parent) {
            child.parent.removeChild(child);
        }
        child.parent = this;
        this.sortDirty = true;
        // ensure child transform will be recalculated
        child.transform._parentID = -1;
        this.children.splice(index, 0, child);
        // ensure bounds will be recalculated
        this._boundsID++;
        // TODO - lets either do all callbacks or all events.. not both!
        this.onChildrenChange(index);
        // child.emit('added', this);
        this.dispatchEvent(Event_1.Event.getEvent("childAdded"));
        // this.emit('childAdded', child, this, index);
        return child;
    }
    ;
    /**
     * Swaps the position of 2 Display Objects within this container.
     *
     * @param {PIXI.DisplayObject} child - First display object to swap
     * @param {PIXI.DisplayObject} child2 - Second display object to swap
     */
    swapChildren(child, child2) {
        if (child === child2) {
            return;
        }
        var index1 = this.getChildIndex(child);
        var index2 = this.getChildIndex(child2);
        this.children[index1] = child2;
        this.children[index2] = child;
        this.onChildrenChange(index1 < index2 ? index1 : index2);
    }
    ;
    /**
     * Returns the index position of a child DisplayObject instance
     *
     * @param {PIXI.DisplayObject} child - The DisplayObject instance to identify
     * @return {number} The index position of the child display object to identify
     */
    getChildIndex(child) {
        var index = this.children.indexOf(child);
        if (index === -1) {
            throw new Error('The supplied DisplayObject must be a child of the caller');
        }
        return index;
    }
    ;
    /**
     * Changes the position of an existing child in the display object container
     *
     * @param {PIXI.DisplayObject} child - The child DisplayObject instance for which you want to change the index number
     * @param {number} index - The resulting index number for the child display object
     */
    setChildIndex(child, index) {
        if (index < 0 || index >= this.children.length) {
            throw new Error(("The index " + index + " supplied is out of bounds " + (this.children.length)));
        }
        var currentIndex = this.getChildIndex(child);
        UtilsSettings_1.UtilsSettings.removeItems(this.children, currentIndex, 1); // remove from old position
        this.children.splice(index, 0, child); // add at new position
        this.onChildrenChange(index);
    }
    ;
    /**
     * Returns the child at the specified index
     *
     * @param {number} index - The index to get the child at
     * @return {PIXI.DisplayObject} The child at the given index, if any.
     */
    getChildAt(index) {
        if (index < 0 || index >= this.children.length) {
            throw new Error(("getChildAt: Index (" + index + ") does not exist."));
        }
        return this.children[index];
    }
    ;
    /**
     * Removes one or more children from the container.
     *
     * @param {...PIXI.DisplayObject} child - The DisplayObject(s) to remove
     * @return {PIXI.DisplayObject} The first child that was removed.
     */
    removeChild(child) {
        var arguments$1 = arguments;
        var argumentsLength = arguments.length;
        // if there is only one argument we can bypass looping through the them
        if (argumentsLength > 1) {
            // loop through the arguments property and add all children
            // use it the right way (.length and [i]) so that this function can still be optimized by JS runtimes
            for (var i = 0; i < argumentsLength; i++) {
                this.removeChild(arguments$1[i]);
            }
        }
        else {
            var index = this.children.indexOf(child);
            if (index === -1) {
                return null;
            }
            child.parent = null;
            // ensure child transform will be recalculated
            child.transform._parentID = -1;
            UtilsSettings_1.UtilsSettings.removeItems(this.children, index, 1);
            // ensure bounds will be recalculated
            this._boundsID++;
            // TODO - lets either do all callbacks or all events.. not both!
            this.onChildrenChange(index);
            // child.emit('removed', this);
            this.dispatchEvent(Event_1.Event.getEvent("childRemoved"));
            // this.emit('childRemoved', child, this, index);
        }
        return child;
    }
    ;
    /**
     * Removes a child from the specified index position.
     *
     * @param {number} index - The index to get the child from
     * @return {PIXI.DisplayObject} The child that was removed.
     */
    removeChildAt(index) {
        var child = this.getChildAt(index);
        // ensure child transform will be recalculated..
        child.parent = null;
        child.transform._parentID = -1;
        UtilsSettings_1.UtilsSettings.removeItems(this.children, index, 1);
        // ensure bounds will be recalculated
        this._boundsID++;
        // TODO - lets either do all callbacks or all events.. not both!
        this.onChildrenChange(index);
        // child.emit('removed', this);
        this.dispatchEvent(Event_1.Event.getEvent("childRemoved"));
        // this.emit('childRemoved', child, this, index);
        return child;
    }
    ;
    /**
     * Removes all children from this container that are within the begin and end indexes.
     *
     * @param {number} [beginIndex=0] - The beginning position.
     * @param {number} [endIndex=this.children.length] - The ending position. Default value is size of the container.
     * @returns {DisplayObject[]} List of removed children
     */
    removeChildren(beginIndex = 0, endIndex = Infinity) {
        if (beginIndex === void 0) {
            beginIndex = 0;
        }
        var begin = beginIndex;
        var end = typeof endIndex === 'number' ? endIndex : this.children.length;
        var range = end - begin;
        var removed;
        if (range > 0 && range <= end) {
            removed = this.children.splice(begin, range);
            for (var i = 0; i < removed.length; ++i) {
                removed[i].parent = null;
                if (removed[i].transform) {
                    removed[i].transform._parentID = -1;
                }
            }
            this._boundsID++;
            this.onChildrenChange(beginIndex);
            for (var i$1 = 0; i$1 < removed.length; ++i$1) {
                // removed[i$1].emit('removed', this);
                this.dispatchEvent(Event_1.Event.getEvent("childRemoved"));
                // this.emit('childRemoved', removed[i$1], this, i$1);
            }
            return removed;
        }
        else if (range === 0 && this.children.length === 0) {
            return [];
        }
        throw new RangeError('removeChildren: numeric values are outside the acceptable range.');
    }
    ;
    /**
     * Sorts children by zIndex. Previous order is mantained for 2 children with the same zIndex.
     */
    sortChildren() {
        var sortRequired = false;
        for (var i = 0, j = this.children.length; i < j; ++i) {
            var child = this.children[i];
            child._lastSortedIndex = i;
            if (!sortRequired && child.zIndex !== 0) {
                sortRequired = true;
            }
        }
        if (sortRequired && this.children.length > 1) {
            this.children.sort(Container.sortChildren);
        }
        this.sortDirty = false;
    }
    ;
    /**
     * Updates the transform on all children of this container for rendering
     */
    updateTransform() {
        if (this.sortableChildren && this.sortDirty) {
            this.sortChildren();
        }
        this._boundsID++;
        this.transform.updateTransform(this.parent.transform);
        // TODO: check render flags, how to process stuff here
        this.worldAlpha = this.alpha * this.parent.worldAlpha;
        for (var i = 0, j = this.children.length; i < j; ++i) {
            var child = this.children[i];
            if (child.visible) {
                child.updateTransform();
            }
        }
    }
    ;
    /**
     * Recalculates the bounds of the container.
     *
     */
    calculateBounds() {
        this._bounds.clear();
        this._calculateBounds();
        for (var i = 0; i < this.children.length; i++) {
            var child = this.children[i];
            if (!child.visible || !child.renderable) {
                continue;
            }
            child.calculateBounds();
            // TODO: filter+mask, need to mask both somehow
            if (child._mask) {
                child._mask.calculateBounds();
                this._bounds.addBoundsMask(child._bounds, child._mask._bounds);
            }
            else if (child.filterArea) {
                this._bounds.addBoundsArea(child._bounds, child.filterArea);
            }
            else {
                this._bounds.addBounds(child._bounds);
            }
        }
        this._lastBoundsID = this._boundsID;
    }
    ;
    /**
     * Recalculates the bounds of the object. Override this to
     * calculate the bounds of the specific object (not including children).
     *
     * @protected
     */
    _calculateBounds() {
        // FILL IN//
    }
    ;
    /**
     * Renders the object using the WebGL renderer
     *
     * @param {PIXI.Renderer} renderer - The renderer
     */
    render(renderer) {
        // if the object is not visible or the alpha is 0 then no need to render this element
        if (!this.visible || this.worldAlpha <= 0 || !this.renderable) {
            return;
        }
        // do a quick check to see if this element has a mask or a filter.
        if (this._mask || this.filters) {
            this.renderAdvanced(renderer);
        }
        else {
            this._render(renderer);
            // simple render children!
            for (var i = 0, j = this.children.length; i < j; ++i) {
                this.children[i].render(renderer);
            }
        }
    }
    ;
    /**
     * Render the object using the WebGL renderer and advanced features.
     *
     * @protected
     * @param {PIXI.Renderer} renderer - The renderer
     */
    renderAdvanced(renderer) {
        renderer.batch.flush();
        var filters = this.filters;
        var mask = this._mask;
        // push filter first as we need to ensure the stencil buffer is correct for any masking
        if (filters) {
            if (!this._enabledFilters) {
                this._enabledFilters = [];
            }
            this._enabledFilters.length = 0;
            for (var i = 0; i < filters.length; i++) {
                if (filters[i].enabled) {
                    this._enabledFilters.push(filters[i]);
                }
            }
            if (this._enabledFilters.length) {
                renderer.filter.push(this, this._enabledFilters);
            }
        }
        if (mask) {
            renderer.mask.push(this, this._mask);
        }
        // add this object to the batch, only rendered if it has a texture.
        this._render(renderer);
        // now loop through the children and make sure they get rendered
        for (var i$1 = 0, j = this.children.length; i$1 < j; i$1++) {
            this.children[i$1].render(renderer);
        }
        renderer.batch.flush();
        if (mask) {
            renderer.mask.pop(this, this._mask);
        }
        if (filters && this._enabledFilters && this._enabledFilters.length) {
            renderer.filter.pop();
        }
    }
    ;
    /**
     * To be overridden by the subclasses.
     *
     * @protected
     * @param {PIXI.Renderer} renderer - The renderer
     */
    _render(renderer) {
        // this is where content itself gets rendered...
    }
    ;
    /**
     * Removes all internal references and listeners as well as removes children from the display list.
     * Do not use a Container after calling `destroy`.
     *
     * @param {object|boolean} [options] - Options parameter. A boolean will act as if all options
     *  have been set to that value
     * @param {boolean} [options.children=false] - if set to true, all the children will have their destroy
     *  method called as well. 'options' will be passed on to those calls.
     * @param {boolean} [options.texture=false] - Only used for child Sprites if options.children is set to true
     *  Should it destroy the texture of the child sprite
     * @param {boolean} [options.baseTexture=false] - Only used for child Sprites if options.children is set to true
     *  Should it destroy the base texture of the child sprite
     */
    destroy(options) {
        super.destroy(options);
        this.sortDirty = false;
        var destroyChildren = typeof options === 'boolean' ? options : options && options.children;
        var oldChildren = this.removeChildren(0, this.children.length);
        if (destroyChildren) {
            for (var i = 0; i < oldChildren.length; ++i) {
                oldChildren[i].destroy(options);
            }
        }
    }
    ;
    /**
     * The width of the Container, setting this will actually modify the scale to achieve the value set
     *
     * @member {number}
     */
    get width() {
        return this.scale.x * this.getLocalBounds().width;
    }
    ;
    set width(value) {
        var width = this.getLocalBounds().width;
        if (width !== 0) {
            this.scale.x = value / width;
        }
        else {
            this.scale.x = 1;
        }
        this._width = value;
    }
    ;
    /**
     * The height of the Container, setting this will actually modify the scale to achieve the value set
     *
     * @member {number}
     */
    get height() {
        return this.scale.y * this.getLocalBounds().height;
    }
    ;
    set height(value) {
        var height = this.getLocalBounds().height;
        if (height !== 0) {
            this.scale.y = value / height;
        }
        else {
            this.scale.y = 1;
        }
        this._height = value;
    }
    ;
    static sortChildren(a, b) {
        if (a.zIndex === b.zIndex) {
            return a._lastSortedIndex - b._lastSortedIndex;
        }
        return a.zIndex - b.zIndex;
    }
}
exports.Container = Container;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/ContextSystem.js":
/*!*************************************************!*\
  !*** ./js-compile/raw-pixi-ts/ContextSystem.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const System_1 = __webpack_require__(/*! ./System */ "./js-compile/raw-pixi-ts/System.js");
const DisplaySettings_1 = __webpack_require__(/*! ./DisplaySettings */ "./js-compile/raw-pixi-ts/DisplaySettings.js");
class ContextSystem extends System_1.System {
    constructor(renderer) {
        super(renderer);
        /**
         * Either 1 or 2 to reflect the WebGL version being used
         * @member {number}
         * @readonly
         */
        this.webGLVersion = 1;
        /**
         * Extensions being used
         * @member {object}
         * @readonly
         * @property {WEBGL_draw_buffers} drawBuffers - WebGL v1 extension
         * @property {WEBGL_depth_texture} depthTexture - WebGL v1 extension
         * @property {OES_texture_float} floatTexture - WebGL v1 extension
         * @property {WEBGL_lose_context} loseContext - WebGL v1 extension
         * @property {OES_vertex_array_object} vertexArrayObject - WebGL v1 extension
         */
        this.extensions = {};
        // Bind functions
        this.handleContextLost = this.handleContextLost.bind(this);
        this.handleContextRestored = this.handleContextRestored.bind(this);
        renderer.view.addEventListener('webglcontextlost', this.handleContextLost, false);
        renderer.view.addEventListener('webglcontextrestored', this.handleContextRestored, false);
    }
    /**
     * `true` if the context is lost
     * @member {boolean}
     * @readonly
     */
    get isLost() {
        return (!this.gl || this.gl.isContextLost());
    }
    ;
    /**
     * Handle the context change event
     * @param {WebGLRenderingContext} gl new webgl context
     */
    contextChange(gl) {
        this.gl = gl;
        // restore a context if it was previously lost
        if (gl.isContextLost() && gl.getExtension('WEBGL_lose_context')) {
            gl.getExtension('WEBGL_lose_context').restoreContext();
        }
    }
    ;
    /**
     * Initialize the context
     *
     * @protected
     * @param {WebGLRenderingContext} gl - WebGL context
     */
    initFromContext(gl) {
        this.gl = gl;
        this.validateContext(gl);
        this.renderer.gl = gl;
        this.renderer.CONTEXT_UID = ContextSystem.CONTEXT_UID++;
        // this.dispatchEvent(Event.getEvent("contextchange"))
        this.renderer.runners.contextChange.run(gl);
    }
    ;
    /**
     * Initialize from context options
     *
     * @protected
     * @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/getContext
     * @param {object} options - context attributes
     */
    initFromOptions(options) {
        var gl = this.createContext(this.renderer.view, options);
        this.initFromContext(gl);
    }
    ;
    /**
     * Helper class to create a WebGL Context
     *
     * @param canvas {HTMLCanvasElement} the canvas element that we will get the context from
     * @param options {object} An options object that gets passed in to the canvas element containing the context attributes
     * @see https://developer.mozilla.org/en/docs/Web/API/HTMLCanvasElement/getContext
     * @return {WebGLRenderingContext} the WebGL context
     */
    createContext(canvas, options) {
        var gl;
        if (DisplaySettings_1.DisplaySettings.PREFER_ENV >= DisplaySettings_1.DisplaySettings.ENV.WEBGL2) {
            gl = canvas.getContext('webgl2', options);
        }
        if (gl) {
            this.webGLVersion = 2;
        }
        else {
            this.webGLVersion = 1;
            gl = canvas.getContext('webgl', options)
                || canvas.getContext('experimental-webgl', options);
            if (!gl) {
                // fail, not able to get a context
                throw new Error('This browser does not support WebGL. Try using the canvas renderer');
            }
        }
        this.gl = gl;
        this.getExtensions();
        return gl;
    }
    ;
    /**
     * Auto-populate the extensions
     *
     * @protected
     */
    getExtensions() {
        // time to set up default extensions that Pixi uses.
        var ref = this;
        var gl = ref.gl;
        if (this.webGLVersion === 1) {
            Object.assign(this.extensions, {
                drawBuffers: gl.getExtension('WEBGL_draw_buffers'),
                depthTexture: gl.getExtension('WEBKIT_WEBGL_depth_texture'),
                floatTexture: gl.getExtension('OES_texture_float'),
                loseContext: gl.getExtension('WEBGL_lose_context'),
                vertexArrayObject: gl.getExtension('OES_vertex_array_object')
                    || gl.getExtension('MOZ_OES_vertex_array_object')
                    || gl.getExtension('WEBKIT_OES_vertex_array_object'),
            });
        }
        // we don't use any specific WebGL 2 ones yet!
    }
    ;
    /**
     * Handles a lost webgl context
     *
     * @protected
     * @param {WebGLContextEvent} event - The context lost event.
     */
    handleContextLost(event) {
        event.preventDefault();
    }
    ;
    /**
     * Handles a restored webgl context
     *
     * @protected
     */
    handleContextRestored() {
        this.renderer.runners.contextChange.run(this.gl);
    }
    ;
    destroy() {
        var view = this.renderer.view;
        // remove listeners
        view.removeEventListener('webglcontextlost', this.handleContextLost);
        view.removeEventListener('webglcontextrestored', this.handleContextRestored);
        this.gl.useProgram(null);
        if (this.extensions.loseContext) {
            this.extensions.loseContext.loseContext();
        }
    }
    ;
    /**
     * Handle the post-render runner event
     *
     * @protected
     */
    postrender() {
        this.gl.flush();
    }
    ;
    /**
     * Validate context
     *
     * @protected
     * @param {WebGLRenderingContext} gl - Render context
     */
    validateContext(gl) {
        var attributes = gl.getContextAttributes();
        // this is going to be fairly simple for now.. but at least we have room to grow!
        if (!attributes.stencil) {
            /* eslint-disable max-len */
            /* eslint-disable no-console */
            console.warn('Provided WebGL context does not have a stencil buffer, masks may not render correctly');
            /* eslint-enable no-console */
            /* eslint-enable max-len */
        }
    }
    ;
}
ContextSystem.CONTEXT_UID = 0;
exports.ContextSystem = ContextSystem;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/CountLimiter.js":
/*!************************************************!*\
  !*** ./js-compile/raw-pixi-ts/CountLimiter.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class CountLimiter {
    constructor(maxItemsPerFrame) {
        /**
             * The maximum number of items that can be prepared each frame.
             * @type {number}
             * @private
             */
        this.maxItemsPerFrame = maxItemsPerFrame;
        /**
         * The number of items that can be prepared in the current frame.
         * @type {number}
         * @private
         */
        this.itemsLeft = 0;
    }
    /**
     * Resets any counting properties to start fresh on a new frame.
     */
    beginFrame() {
        this.itemsLeft = this.maxItemsPerFrame;
    }
    ;
    /**
     * Checks to see if another item can be uploaded. This should only be called once per item.
     * @return {boolean} If the item is allowed to be uploaded.
     */
    allowedToUpload() {
        return this.itemsLeft-- > 0;
    }
    ;
}
exports.CountLimiter = CountLimiter;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/CubeResource.js":
/*!************************************************!*\
  !*** ./js-compile/raw-pixi-ts/CubeResource.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const ArrayResource_1 = __webpack_require__(/*! ./ArrayResource */ "./js-compile/raw-pixi-ts/ArrayResource.js");
const WebGLSettings_1 = __webpack_require__(/*! ./WebGLSettings */ "./js-compile/raw-pixi-ts/WebGLSettings.js");
class CubeResource extends ArrayResource_1.ArrayResource {
    constructor(source, options) {
        super(source, options);
        options = options || {};
        if (this.length !== CubeResource.SIDES) {
            throw new Error(("Invalid length. Got " + (this.length) + ", expected 6"));
        }
        for (var i = 0; i < CubeResource.SIDES; i++) {
            this.items[i].target = WebGLSettings_1.WebGLSettings.TARGETS.TEXTURE_CUBE_MAP_POSITIVE_X + i;
        }
        if (options.autoLoad !== false) {
            this.load();
        }
    }
    /**
     * Add binding
     *
     * @override
     * @param {PIXI.BaseTexture} baseTexture - parent base texture
     */
    bind(baseTexture) {
        super.bind(baseTexture);
        baseTexture.target = WebGLSettings_1.WebGLSettings.TARGETS.TEXTURE_CUBE_MAP;
    }
    ;
    /**
     * Upload the resource
     *
     * @returns {boolean} true is success
     */
    upload(renderer, baseTexture, glTexture) {
        var dirty = this.itemDirtyIds;
        for (var i = 0; i < CubeResource.SIDES; i++) {
            var side = this.items[i];
            if (dirty[i] < side.dirtyId) {
                dirty[i] = side.dirtyId;
                if (side.valid) {
                    side.resource.upload(renderer, side, glTexture);
                }
            }
        }
        return true;
    }
    ;
}
/**
* Number of texture sides to store for CubeResources
*
* @name PIXI.resources.CubeResource.SIDES
* @static
* @member {number}
* @default 6
*/
CubeResource.SIDES = 6;
exports.CubeResource = CubeResource;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/DepthResource.js":
/*!*************************************************!*\
  !*** ./js-compile/raw-pixi-ts/DepthResource.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BufferResource_1 = __webpack_require__(/*! ./BufferResource */ "./js-compile/raw-pixi-ts/BufferResource.js");
class DepthResource extends BufferResource_1.BufferResource {
    constructor(source, options) {
        super(source, options);
    }
    upload(renderer, baseTexture, glTexture) {
        var gl = renderer.gl;
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, baseTexture.premultiplyAlpha);
        if (glTexture.width === baseTexture.width && glTexture.height === baseTexture.height) {
            gl.texSubImage2D(baseTexture.target, 0, 0, 0, baseTexture.width, baseTexture.height, baseTexture.format, baseTexture.type, this.data);
        }
        else {
            glTexture.width = baseTexture.width;
            glTexture.height = baseTexture.height;
            gl.texImage2D(baseTexture.target, 0, gl.DEPTH_COMPONENT16, // Needed for depth to render properly in webgl2.0
            baseTexture.width, baseTexture.height, 0, baseTexture.format, baseTexture.type, this.data);
        }
        return true;
    }
    ;
}
exports.DepthResource = DepthResource;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/DisplacementFilter.js":
/*!******************************************************!*\
  !*** ./js-compile/raw-pixi-ts/DisplacementFilter.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Filter_1 = __webpack_require__(/*! ./Filter */ "./js-compile/raw-pixi-ts/Filter.js");
const Matrix_1 = __webpack_require__(/*! ./Matrix */ "./js-compile/raw-pixi-ts/Matrix.js");
const Point_1 = __webpack_require__(/*! ./Point */ "./js-compile/raw-pixi-ts/Point.js");
class DisplacementFilter extends Filter_1.Filter {
    constructor(sprite, scale = 1) {
        var maskMatrix = new Matrix_1.Matrix();
        sprite.renderable = false;
        super(DisplacementFilter.vertex$4, DisplacementFilter.fragment$5, { mapSampler: sprite._texture, filterMatrix: maskMatrix, scale: { x: 1, y: 1 }, rotation: new Float32Array([1, 0, 0, 1]), });
        this.maskSprite = sprite;
        this.maskMatrix = maskMatrix;
        if (scale === null || scale === undefined) {
            scale = 20;
        }
        /**
         * scaleX, scaleY for displacements
         * @member {PIXI.Point}
         */
        this.scale = new Point_1.Point(scale, scale);
    }
    /**
     * Applies the filter.
     *
     * @param {PIXI.systems.FilterSystem} filterManager - The manager.
     * @param {PIXI.RenderTexture} input - The input target.
     * @param {PIXI.RenderTexture} output - The output target.
     */
    apply(filterManager, input, output) {
        this.uniforms.filterMatrix = filterManager.calculateSpriteMatrix(this.maskMatrix, this.maskSprite);
        this.uniforms.scale.x = this.scale.x;
        this.uniforms.scale.y = this.scale.y;
        // Extract rotation from world transform
        var wt = this.maskSprite.transform.worldTransform;
        var lenX = Math.sqrt((wt.a * wt.a) + (wt.b * wt.b));
        var lenY = Math.sqrt((wt.c * wt.c) + (wt.d * wt.d));
        if (lenX !== 0 && lenY !== 0) {
            this.uniforms.rotation[0] = wt.a / lenX;
            this.uniforms.rotation[1] = wt.b / lenX;
            this.uniforms.rotation[2] = wt.c / lenY;
            this.uniforms.rotation[3] = wt.d / lenY;
        }
        // draw the filter...
        filterManager.applyFilter(this, input, output);
    }
    ;
    /**
     * The texture used for the displacement map. Must be power of 2 sized texture.
     *
     * @member {PIXI.Texture}
     */
    get map() {
        return this.uniforms.mapSampler;
    }
    ;
    set map(value) {
        this.uniforms.mapSampler = value;
    }
    ;
}
DisplacementFilter.fragment$5 = "varying vec2 vFilterCoord;\r\nvarying vec2 vTextureCoord;\r\n\r\nuniform vec2 scale;\r\nuniform mat2 rotation;\r\nuniform sampler2D uSampler;\r\nuniform sampler2D mapSampler;\r\n\r\nuniform highp vec4 inputSize;\r\nuniform vec4 inputClamp;\r\n\r\nvoid main(void)\r\n{\r\n  vec4 map =  texture2D(mapSampler, vFilterCoord);\r\n\r\n  map -= 0.5;\r\n  map.xy = scale * inputSize.zw * (rotation * map.xy);\r\n\r\n  gl_FragColor = texture2D(uSampler, clamp(vec2(vTextureCoord.x + map.x, vTextureCoord.y + map.y), inputClamp.xy, inputClamp.zw));\r\n}\r\n";
DisplacementFilter.vertex$4 = "attribute vec2 aVertexPosition;\r\n\r\nuniform mat3 projectionMatrix;\r\nuniform mat3 filterMatrix;\r\n\r\nvarying vec2 vTextureCoord;\r\nvarying vec2 vFilterCoord;\r\n\r\nuniform vec4 inputSize;\r\nuniform vec4 outputFrame;\r\n\r\nvec4 filterVertexPosition( void )\r\n{\r\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\r\n\r\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\r\n}\r\n\r\nvec2 filterTextureCoord( void )\r\n{\r\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\r\n}\r\n\r\nvoid main(void)\r\n{\r\n\tgl_Position = filterVertexPosition();\r\n\tvTextureCoord = filterTextureCoord();\r\n\tvFilterCoord = ( filterMatrix * vec3( vTextureCoord, 1.0)  ).xy;\r\n}\r\n";
exports.DisplacementFilter = DisplacementFilter;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/DisplayObject.js":
/*!*************************************************!*\
  !*** ./js-compile/raw-pixi-ts/DisplayObject.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const EventDispatcher_1 = __webpack_require__(/*! ./EventDispatcher */ "./js-compile/raw-pixi-ts/EventDispatcher.js");
const Rectangle_1 = __webpack_require__(/*! ./Rectangle */ "./js-compile/raw-pixi-ts/Rectangle.js");
const Matrix_1 = __webpack_require__(/*! ./Matrix */ "./js-compile/raw-pixi-ts/Matrix.js");
const RenderTexture_1 = __webpack_require__(/*! ./RenderTexture */ "./js-compile/raw-pixi-ts/RenderTexture.js");
const BaseTexture_1 = __webpack_require__(/*! ./BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const Texture_1 = __webpack_require__(/*! ./Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const Bounds_1 = __webpack_require__(/*! ./Bounds */ "./js-compile/raw-pixi-ts/Bounds.js");
const Transform_1 = __webpack_require__(/*! ./Transform */ "./js-compile/raw-pixi-ts/Transform.js");
const Point_1 = __webpack_require__(/*! ./Point */ "./js-compile/raw-pixi-ts/Point.js");
const MathSettings_1 = __webpack_require__(/*! ./MathSettings */ "./js-compile/raw-pixi-ts/MathSettings.js");
const DisplaySettings_1 = __webpack_require__(/*! ./DisplaySettings */ "./js-compile/raw-pixi-ts/DisplaySettings.js");
class DisplayObject extends EventDispatcher_1.EventDispatcher {
    constructor() {
        super();
        /*!
 * @pixi/mixin-get-child-by-name - v5.0.0-rc.3
 * Compiled Wed, 10 Apr 2019 01:21:15 UTC
 *
 * @pixi/mixin-get-child-by-name is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
        /**
         * The instance name of the object.
         *
         * @memberof PIXI.DisplayObject#
         * @member {string} name
         */
        this.name = null;
        /**
         *  Flag for if the object is accessible. If true AccessibilityManager will overlay a
         *   shadow div with attributes set
         *
         * @member {boolean}
         * @memberof PIXI.DisplayObject#
         */
        this.accessible = false;
        /**
         * Sets the title attribute of the shadow div
         * If accessibleTitle AND accessibleHint has not been this will default to 'displayObject [tabIndex]'
         *
         * @member {?string}
         * @memberof PIXI.DisplayObject#
         */
        this.accessibleTitle = null;
        /**
         * Sets the aria-label attribute of the shadow div
         *
         * @member {string}
         * @memberof PIXI.DisplayObject#
         */
        this.accessibleHint = null;
        /**
         * @member {number}
         * @memberof PIXI.DisplayObject#
         * @private
         * @todo Needs docs.
         */
        this.tabIndex = 0;
        /**
         * @member {boolean}
         * @memberof PIXI.DisplayObject#
         * @todo Needs docs.
         */
        this._accessibleActive = false;
        /**
         * @member {boolean}
         * @memberof PIXI.DisplayObject#
         * @todo Needs docs.
         */
        this._accessibleDiv = false;
        /**
        * Enable interaction events for the DisplayObject. Touch, pointer and mouse
        * events will not be emitted unless `interactive` is set to `true`.
        *
        * @example
        * const sprite = new PIXI.Sprite(texture);
        * sprite.interactive = true;
        * sprite.on('tap', (event) => {
        *    //handle event
        * });
        * @member {boolean}
        * @memberof PIXI.DisplayObject#
        */
        this.interactive = false;
        /**
         * Determines if the children to the displayObject can be clicked/touched
         * Setting this to false allows PixiJS to bypass a recursive `hitTest` function
         *
         * @member {boolean}
         * @memberof PIXI.Container#
         */
        this.interactiveChildren = true;
        /**
         * Interaction shape. Children will be hit first, then this shape will be checked.
         * Setting this will cause this shape to be checked in hit tests rather than the displayObject's bounds.
         *
         * @example
         * const sprite = new PIXI.Sprite(texture);
         * sprite.interactive = true;
         * sprite.hitArea = new PIXI.Rectangle(0, 0, 100, 100);
         * @member {PIXI.Rectangle|PIXI.Circle|PIXI.Ellipse|PIXI.Polygon|PIXI.RoundedRectangle}
         * @memberof PIXI.DisplayObject#
         */
        this.hitArea = null;
        /**
         * This defines what cursor mode is used when the mouse cursor
         * is hovered over the displayObject.
         *
         * @example
         * const sprite = new PIXI.Sprite(texture);
         * sprite.interactive = true;
         * sprite.cursor = 'wait';
         * @see https://developer.mozilla.org/en/docs/Web/CSS/cursor
         *
         * @member {string}
         * @memberof PIXI.DisplayObject#
         */
        this.cursor = null;
        /**
         * Map of all tracked pointers, by identifier. Use trackedPointers to access.
         *
         * @private
         * @type {Map<number, InteractionTrackingData>}
         */
        this._trackedPointers = undefined;
        this._cacheAsBitmap = false;
        this._cacheData = false;
        // performance increase to avoid using call.. (10x faster)
        this.displayObjectUpdateTransform = this.updateTransform;
        this.tempDisplayObjectParent = null;
        // TODO: need to create Transform from factory
        /**
         * World transform and local transform of this object.
         * This will become read-only later, please do not assign anything there unless you know what are you doing.
         *
         * @member {PIXI.Transform}
         */
        this.transform = new Transform_1.Transform();
        /**
         * The opacity of the object.
         *
         * @member {number}
         */
        this.alpha = 1;
        /**
         * The visibility of the object. If false the object will not be drawn, and
         * the updateTransform function will not be called.
         *
         * Only affects recursive calls from parent. You can ask for bounds or call updateTransform manually.
         *
         * @member {boolean}
         */
        this.visible = true;
        /**
         * Can this object be rendered, if false the object will not be drawn but the updateTransform
         * methods will still be called.
         *
         * Only affects recursive calls from parent. You can ask for bounds manually.
         *
         * @member {boolean}
         */
        this.renderable = true;
        /**
         * The display object container that contains this display object.
         *
         * @member {PIXI.Container}
         * @readonly
         */
        this.parent = null;
        /**
         * The multiplied alpha of the displayObject.
         *
         * @member {number}
         * @readonly
         */
        this.worldAlpha = 1;
        /**
         * Which index in the children array the display component was before the previous zIndex sort.
         * Used by containers to help sort objects with the same zIndex, by using previous array index as the decider.
         *
         * @member {number}
         * @protected
         */
        this._lastSortedIndex = 0;
        /**
         * The zIndex of the displayObject.
         * A higher value will mean it will be rendered on top of other displayObjects within the same container.
         *
         * @member {number}
         * @protected
         */
        this._zIndex = 0;
        /**
         * The area the filter is applied to. This is used as more of an optimization
         * rather than figuring out the dimensions of the displayObject each frame you can set this rectangle.
         *
         * Also works as an interaction mask.
         *
         * @member {?PIXI.Rectangle}
         */
        this.filterArea = null;
        /**
         * Sets the filters for the displayObject.
         * * IMPORTANT: This is a WebGL only feature and will be ignored by the canvas renderer.
         * To remove filters simply set this property to `'null'`.
         *
         * @member {?PIXI.Filter[]}
         */
        this.filters = null;
        this._enabledFilters = null;
        /**
         * The bounds object, this is used to calculate and store the bounds of the displayObject.
         *
         * @member {PIXI.Bounds}
         * @protected
         */
        this._bounds = new Bounds_1.Bounds();
        this._boundsID = 0;
        this._lastBoundsID = -1;
        this._boundsRect = null;
        this._localBoundsRect = null;
        /**
         * The original, cached mask of the object.
         *
         * @member {PIXI.Graphics|PIXI.Sprite}
         * @protected
         */
        this._mask = null;
        /**
         * Fired when this DisplayObject is added to a Container.
         *
         * @event PIXI.DisplayObject#added
         * @param {PIXI.Container} container - The container added to.
         */
        /**
         * Fired when this DisplayObject is removed from a Container.
         *
         * @event PIXI.DisplayObject#removed
         * @param {PIXI.Container} container - The container removed from.
         */
        /**
         * If the object has been destroyed via destroy(). If true, it should not be used.
         *
         * @member {boolean}
         * @protected
         */
        this._destroyed = false;
        /**
         * used to fast check if a sprite is.. a sprite!
         * @member {boolean}
         */
        this.isSprite = false;
    }
    /**
 * Internal set of all active pointers, by identifier
 *
 * @member {Map<number, InteractionTrackingData>}
 * @memberof PIXI.DisplayObject#
 * @private
 */
    get trackedPointers() {
        if (this._trackedPointers === undefined) {
            this._trackedPointers = {};
        }
        return this._trackedPointers;
    }
    /*!
 * @pixi/mixin-get-global-position - v5.0.0-rc.3
 * Compiled Wed, 10 Apr 2019 01:21:15 UTC
 *
 * @pixi/mixin-get-global-position is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
    /**
     * Returns the global position of the displayObject. Does not depend on object scale, rotation and pivot.
     *
     * @method getGlobalPosition
     * @memberof PIXI.DisplayObject#
     * @param {Point} point - The point to write the global value to. If null a new point will be returned
     * @param {boolean} skipUpdate - Setting to true will stop the transforms of the scene graph from
     *  being updated. This means the calculation returned MAY be out of date BUT will give you a
     *  nice performance boost.
     * @return {Point} The updated point.
     */
    getGlobalPosition(point, skipUpdate) {
        if (point === void 0) {
            point = new Point_1.Point();
        }
        if (skipUpdate === void 0) {
            skipUpdate = false;
        }
        if (this.parent) {
            this.parent.toGlobal(this.position, point, skipUpdate);
        }
        else {
            point.x = this.position.x;
            point.y = this.position.y;
        }
        return point;
    }
    ;
    /**
 * If enabled, the mouse cursor use the pointer behavior when hovered over the displayObject if it is interactive
 * Setting this changes the 'cursor' property to `'pointer'`.
 *
 * @example
 * const sprite = new PIXI.Sprite(texture);
 * sprite.interactive = true;
 * sprite.buttonMode = true;
 * @member {boolean}
 * @memberof PIXI.DisplayObject#
 */
    get buttonMode() {
        return this.cursor === 'pointer';
    }
    set buttonMode(value) {
        if (value) {
            this.cursor = 'pointer';
        }
        else if (this.cursor === 'pointer') {
            this.cursor = null;
        }
    }
    /**
     * @protected
     * @member {PIXI.DisplayObject}
     */
    static mixin(source) {
        // in ES8/ES2017, this would be really easy:
        // Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        // get all the enumerable property keys
        var keys = Object.keys(source);
        // loop through properties
        for (var i = 0; i < keys.length; ++i) {
            var propertyName = keys[i];
            // Set the property using the property descriptor - this works for accessors and normal value properties
            Object.defineProperty(DisplayObject.prototype, propertyName, Object.getOwnPropertyDescriptor(source, propertyName));
        }
    }
    ;
    get _tempDisplayObjectParent() {
        if (this.tempDisplayObjectParent === null) {
            this.tempDisplayObjectParent = new DisplayObject();
        }
        return this.tempDisplayObjectParent;
    }
    ;
    /**
     * Updates the object transform for rendering.
     *
     * TODO - Optimization pass!
     */
    updateTransform() {
        this.transform.updateTransform(this.parent.transform);
        // multiply the alphas..
        this.worldAlpha = this.alpha * this.parent.worldAlpha;
        this._bounds.updateID++;
    }
    ;
    /**
     * Recursively updates transform of all objects from the root to this one
     * internal function for toLocal()
     */
    _recursivePostUpdateTransform() {
        if (this.parent) {
            this.parent._recursivePostUpdateTransform();
            this.transform.updateTransform(this.parent.transform);
        }
        else {
            this.transform.updateTransform(this._tempDisplayObjectParent.transform);
        }
    }
    ;
    /**
     * Retrieves the bounds of the displayObject as a rectangle object.
     *
     * @param {boolean} [skipUpdate] - Setting to `true` will stop the transforms of the scene graph from
     *  being updated. This means the calculation returned MAY be out of date BUT will give you a
     *  nice performance boost.
     * @param {PIXI.Rectangle} [rect] - Optional rectangle to store the result of the bounds calculation.
     * @return {PIXI.Rectangle} The rectangular bounding area.
     */
    getBounds(skipUpdate = true, rect = null) {
        if (!skipUpdate) {
            if (!this.parent) {
                this.parent = this._tempDisplayObjectParent;
                this.updateTransform();
                this.parent = null;
            }
            else {
                this._recursivePostUpdateTransform();
                this.updateTransform();
            }
        }
        if (this._boundsID !== this._lastBoundsID) {
            this.calculateBounds();
        }
        if (!rect) {
            if (!this._boundsRect) {
                this._boundsRect = new Rectangle_1.Rectangle();
            }
            rect = this._boundsRect;
        }
        return this._bounds.getRectangle(rect);
    }
    ;
    calculateBounds() {
    }
    /**
     * Retrieves the local bounds of the displayObject as a rectangle object.
     *
     * @param {PIXI.Rectangle} [rect] - Optional rectangle to store the result of the bounds calculation.
     * @return {PIXI.Rectangle} The rectangular bounding area.
     */
    getLocalBounds(rect = null) {
        var transformRef = this.transform;
        var parentRef = this.parent;
        this.parent = null;
        this.transform = this._tempDisplayObjectParent.transform;
        if (!rect) {
            if (!this._localBoundsRect) {
                this._localBoundsRect = new Rectangle_1.Rectangle();
            }
            rect = this._localBoundsRect;
        }
        var bounds = this.getBounds(false, rect);
        this.parent = parentRef;
        this.transform = transformRef;
        return bounds;
    }
    ;
    /**
     * Calculates the global position of the display object.
     *
     * @param {PIXI.IPoint} position - The world origin to calculate from.
     * @param {PIXI.IPoint} [point] - A Point object in which to store the value, optional
     *  (otherwise will create a new Point).
     * @param {boolean} [skipUpdate=false] - Should we skip the update transform.
     * @return {PIXI.IPoint} A point object representing the position of this object.
     */
    toGlobal(position, point, skipUpdate) {
        if (skipUpdate === void 0) {
            skipUpdate = false;
        }
        if (!skipUpdate) {
            this._recursivePostUpdateTransform();
            // this parent check is for just in case the item is a root object.
            // If it is we need to give it a temporary parent so that displayObjectUpdateTransform works correctly
            // this is mainly to avoid a parent check in the main loop. Every little helps for performance :)
            if (!this.parent) {
                this.parent = this._tempDisplayObjectParent;
                this.displayObjectUpdateTransform();
                this.parent = null;
            }
            else {
                this.displayObjectUpdateTransform();
            }
        }
        // don't need to update the lot
        return this.worldTransform.apply(position, point);
    }
    ;
    /**
     * Calculates the local position of the display object relative to another point.
     *
     * @param {PIXI.IPoint} position - The world origin to calculate from.
     * @param {PIXI.DisplayObject} [from] - The DisplayObject to calculate the global position from.
     * @param {PIXI.IPoint} [point] - A Point object in which to store the value, optional
     *  (otherwise will create a new Point).
     * @param {boolean} [skipUpdate=false] - Should we skip the update transform
     * @return {PIXI.IPoint} A point object representing the position of this object
     */
    toLocal(position, from, point, skipUpdate) {
        if (from) {
            position = from.toGlobal(position, point, skipUpdate);
        }
        if (!skipUpdate) {
            this._recursivePostUpdateTransform();
            // this parent check is for just in case the item is a root object.
            // If it is we need to give it a temporary parent so that displayObjectUpdateTransform works correctly
            // this is mainly to avoid a parent check in the main loop. Every little helps for performance :)
            if (!this.parent) {
                this.parent = this._tempDisplayObjectParent;
                this.displayObjectUpdateTransform();
                this.parent = null;
            }
            else {
                this.displayObjectUpdateTransform();
            }
        }
        // simply apply the matrix..
        return this.worldTransform.applyInverse(position, point);
    }
    ;
    /**
     * Renders the object using the WebGL renderer.
     *
     * @param {PIXI.Renderer} renderer - The renderer.
     */
    render(renderer) {
        // OVERWRITE;
    }
    ;
    /**
     * Set the parent Container of this DisplayObject.
     *
     * @param {PIXI.Container} container - The Container to add this DisplayObject to.
     * @return {PIXI.Container} The Container that this DisplayObject was added to.
     */
    setParent(container) {
        if (!container || !container.addChild) {
            throw new Error('setParent: Argument must be a Container');
        }
        container.addChild(this);
        return container;
    }
    ;
    /**
     * Convenience function to set the position, scale, skew and pivot at once.
     *
     * @param {number} [x=0] - The X position
     * @param {number} [y=0] - The Y position
     * @param {number} [scaleX=1] - The X scale value
     * @param {number} [scaleY=1] - The Y scale value
     * @param {number} [rotation=0] - The rotation
     * @param {number} [skewX=0] - The X skew value
     * @param {number} [skewY=0] - The Y skew value
     * @param {number} [pivotX=0] - The X pivot value
     * @param {number} [pivotY=0] - The Y pivot value
     * @return {PIXI.DisplayObject} The DisplayObject instance
     */
    setTransform(x, y, scaleX, scaleY, rotation, skewX, skewY, pivotX, pivotY) {
        if (x === void 0) {
            x = 0;
        }
        if (y === void 0) {
            y = 0;
        }
        if (scaleX === void 0) {
            scaleX = 1;
        }
        if (scaleY === void 0) {
            scaleY = 1;
        }
        if (rotation === void 0) {
            rotation = 0;
        }
        if (skewX === void 0) {
            skewX = 0;
        }
        if (skewY === void 0) {
            skewY = 0;
        }
        if (pivotX === void 0) {
            pivotX = 0;
        }
        if (pivotY === void 0) {
            pivotY = 0;
        }
        this.position.x = x;
        this.position.y = y;
        this.scale.x = !scaleX ? 1 : scaleX;
        this.scale.y = !scaleY ? 1 : scaleY;
        this.rotation = rotation;
        this.skew.x = skewX;
        this.skew.y = skewY;
        this.pivot.x = pivotX;
        this.pivot.y = pivotY;
        return this;
    }
    ;
    /**
     * Base destroy method for generic display objects. This will automatically
     * remove the display object from its parent Container as well as remove
     * all current event listeners and internal references. Do not use a DisplayObject
     * after calling `destroy()`.
     *
     */
    destroy(options = null) {
        // this.removeAllListeners();
        if (this.parent) {
            this.parent.removeChild(this);
        }
        this.transform = null;
        this.parent = null;
        this._bounds = null;
        this._currentBounds = null;
        this._mask = null;
        this.filterArea = null;
        this.interactive = false;
        this.interactiveChildren = false;
        this._destroyed = true;
    }
    ;
    /**
     * The position of the displayObject on the x axis relative to the local coordinates of the parent.
     * An alias to position.x
     *
     * @member {number}
     */
    get x() {
        return this.position.x;
    }
    ;
    set x(value) {
        this.transform.position.x = value;
    }
    ;
    /**
     * The position of the displayObject on the y axis relative to the local coordinates of the parent.
     * An alias to position.y
     *
     * @member {number}
     */
    get y() {
        return this.position.y;
    }
    ;
    set y(value) {
        this.transform.position.y = value;
    }
    ;
    /**
     * Current transform of the object based on world (parent) factors.
     *
     * @member {PIXI.Matrix}
     * @readonly
     */
    get worldTransform() {
        return this.transform.worldTransform;
    }
    ;
    /**
     * Current transform of the object based on local factors: position, scale, other stuff.
     *
     * @member {PIXI.Matrix}
     * @readonly
     */
    get localTransform() {
        return this.transform.localTransform;
    }
    ;
    /**
     * The coordinate of the object relative to the local coordinates of the parent.
     * Assignment by value since pixi-v4.
     *
     * @member {PIXI.IPoint}
     */
    get position() {
        return this.transform.position;
    }
    ;
    set position(value) {
        this.transform.position.copyFrom(value);
    }
    ;
    /**
     * The scale factor of the object.
     * Assignment by value since pixi-v4.
     *
     * @member {PIXI.IPoint}
     */
    get scale() {
        return this.transform.scale;
    }
    ;
    set scale(value) {
        this.transform.scale.copyFrom(value);
    }
    ;
    /**
     * The pivot point of the displayObject that it rotates around.
     * Assignment by value since pixi-v4.
     *
     * @member {PIXI.IPoint}
     */
    get pivot() {
        return this.transform.pivot;
    }
    ;
    set pivot(value) {
        this.transform.pivot.copyFrom(value);
    }
    ;
    /**
     * The skew factor for the object in radians.
     * Assignment by value since pixi-v4.
     *
     * @member {PIXI.ObservablePoint}
     */
    get skew() {
        return this.transform.skew;
    }
    ;
    set skew(value) {
        this.transform.skew.copyFrom(value);
    }
    ;
    /**
     * The rotation of the object in radians.
     * 'rotation' and 'angle' have the same effect on a display object; rotation is in radians, angle is in degrees.
     *
     * @member {number}
     */
    get rotation() {
        return this.transform.rotation;
    }
    ;
    set rotation(value) {
        this.transform.rotation = value;
    }
    ;
    /**
     * The angle of the object in degrees.
     * 'rotation' and 'angle' have the same effect on a display object; rotation is in radians, angle is in degrees.
     *
     * @member {number}
     */
    get angle() {
        return this.transform.rotation * MathSettings_1.MathSettings.RAD_TO_DEG;
    }
    ;
    set angle(value) {
        this.transform.rotation = value * MathSettings_1.MathSettings.DEG_TO_RAD;
    }
    ;
    /**
     * The zIndex of the displayObject.
     * If a container has the sortableChildren property set to true, children will be automatically
     * sorted by zIndex value; a higher value will mean it will be moved towards the end of the array,
     * and thus rendered on top of other displayObjects within the same container.
     *
     * @member {number}
     */
    get zIndex() {
        return this._zIndex;
    }
    ;
    set zIndex(value) {
        this._zIndex = value;
        if (this.parent) {
            this.parent.sortDirty = true;
        }
    }
    ;
    /**
     * Indicates if the object is globally visible.
     *
     * @member {boolean}
     * @readonly
     */
    get worldVisible() {
        var item = this;
        do {
            if (!item.visible) {
                return false;
            }
            item = item.parent;
        } while (item);
        return true;
    }
    ;
    /**
     * Sets a mask for the displayObject. A mask is an object that limits the visibility of an
     * object to the shape of the mask applied to it. In PixiJS a regular mask must be a
     * {@link PIXI.Graphics} or a {@link PIXI.Sprite} object. This allows for much faster masking in canvas as it
     * utilities shape clipping. To remove a mask, set this property to `null`.
     *
     * For sprite mask both alpha and red channel are used. Black mask is the same as transparent mask.
     * @example
     * const graphics = new PIXI.Graphics();
     * graphics.beginFill(0xFF3300);
     * graphics.drawRect(50, 250, 100, 100);
     * graphics.endFill();
     *
     * const sprite = new PIXI.Sprite(texture);
     * sprite.mask = graphics;
     * @todo At the moment, PIXI.CanvasRenderer doesn't support PIXI.Sprite as mask.
     *
     * @member {PIXI.Graphics|PIXI.Sprite}
     */
    get mask() {
        return this._mask;
    }
    ;
    set mask(value) {
        if (this._mask) {
            this._mask.renderable = true;
            this._mask.isMask = false;
        }
        this._mask = value;
        if (this._mask) {
            this._mask.renderable = false;
            this._mask.isMask = true;
        }
    }
    ;
    /**
             * Set this to true if you want this display object to be cached as a bitmap.
             * This basically takes a snap shot of the display object as it is at that moment. It can
             * provide a performance benefit for complex static displayObjects.
             * To remove simply set this property to `false`
             *
             * IMPORTANT GOTCHA - Make sure that all your textures are preloaded BEFORE setting this property to true
             * as it will take a snapshot of what is currently there. If the textures have not loaded then they will not appear.
             *
             * @member {boolean}
             * @memberof PIXI.DisplayObject#
             */
    get cacheAsBitmap() {
        return this._cacheAsBitmap;
    }
    set cacheAsBitmap(value) {
        if (this._cacheAsBitmap === value) {
            return;
        }
        this._cacheAsBitmap = value;
        var data;
        if (value) {
            if (!this._cacheData) {
                this._cacheData = new CacheData();
            }
            data = this._cacheData;
            data.originalRender = this.render;
            data.originalRenderCanvas = this.renderCanvas;
            data.originalUpdateTransform = this.updateTransform;
            data.originalCalculateBounds = this.calculateBounds;
            data.originalGetLocalBounds = this.getLocalBounds;
            data.originalDestroy = this.destroy;
            data.originalContainsPoint = this.containsPoint;
            data.originalMask = this._mask;
            data.originalFilterArea = this.filterArea;
            this.render = this._renderCached;
            this.renderCanvas = this._renderCachedCanvas;
            this.destroy = this._cacheAsBitmapDestroy;
        }
        else {
            data = this._cacheData;
            if (data.sprite) {
                this._destroyCachedDisplayObject();
            }
            this.render = data.originalRender;
            this.renderCanvas = data.originalRenderCanvas;
            this.calculateBounds = data.originalCalculateBounds;
            this.getLocalBounds = data.originalGetLocalBounds;
            this.destroy = data.originalDestroy;
            this.updateTransform = data.originalUpdateTransform;
            this.containsPoint = data.originalContainsPoint;
            this._mask = data.originalMask;
            this.filterArea = data.originalFilterArea;
        }
    }
    containsPoint(point) {
        return false;
    }
    /**
     * Renders a cached version of the sprite with WebGL
     *
     * @private
     * @function _renderCached
     * @memberof PIXI.DisplayObject#
     * @param {PIXI.Renderer} renderer - the WebGL renderer
     */
    _renderCached(renderer) {
        if (!this.visible || this.worldAlpha <= 0 || !this.renderable) {
            return;
        }
        this._initCachedDisplayObject(renderer);
        this._cacheData.sprite.transform._worldID = this.transform._worldID;
        this._cacheData.sprite.worldAlpha = this.worldAlpha;
        this._cacheData.sprite._render(renderer);
    }
    /**
     * Prepares the WebGL renderer to cache the sprite
     *
     * @private
     * @function _initCachedDisplayObject
     * @memberof PIXI.DisplayObject#
     * @param {PIXI.Renderer} renderer - the WebGL renderer
     */
    _initCachedDisplayObject(renderer) {
        if (this._cacheData && this._cacheData.sprite) {
            return;
        }
        // make sure alpha is set to 1 otherwise it will get rendered as invisible!
        var cacheAlpha = this.alpha;
        this.alpha = 1;
        // first we flush anything left in the renderer (otherwise it would get rendered to the cached texture)
        renderer.batch.flush();
        // this.filters= [];
        // next we find the dimensions of the untransformed object
        // this function also calls updatetransform on all its children as part of the measuring.
        // This means we don't need to update the transform again in this function
        // TODO pass an object to clone too? saves having to create a new one each time!
        var bounds = this.getLocalBounds().clone();
        // add some padding!
        if (this.filters) {
            var padding = this.filters[0].padding;
            bounds.pad(padding);
        }
        bounds.ceil(DisplaySettings_1.DisplaySettings.RESOLUTION);
        // for now we cache the current renderTarget that the WebGL renderer is currently using.
        // this could be more elegant..
        var cachedRenderTarget = renderer._activeRenderTarget;
        // We also store the filter stack - I will definitely look to change how this works a little later down the line.
        // const stack = renderer.filterManager.filterStack;
        // this renderTexture will be used to store the cached DisplayObject
        var renderTexture = RenderTexture_1.RenderTexture.create(bounds.width, bounds.height);
        var textureCacheId = "cacheAsBitmap_" + (MathSettings_1.MathSettings.uid());
        this._cacheData.textureCacheId = textureCacheId;
        BaseTexture_1.BaseTexture.addToCache(renderTexture.baseTexture, textureCacheId);
        Texture_1.Texture.addToCache(renderTexture, textureCacheId);
        // need to set //
        var m = DisplayObject._tempMatrix;
        m.tx = -bounds.x;
        m.ty = -bounds.y;
        // reset
        this.transform.worldTransform.identity();
        // set all properties to there original so we can render to a texture
        this.render = this._cacheData.originalRender;
        renderer.render(this, renderTexture, true, m, true);
        // now restore the state be setting the new properties
        renderer.renderTexture.bind(cachedRenderTarget);
        // renderer.filterManager.filterStack = stack;
        this.render = this._renderCached;
        // the rest is the same as for Canvas
        this.updateTransform = this.displayObjectUpdateTransform;
        this.calculateBounds = this._calculateCachedBounds;
        this.getLocalBounds = this._getCachedLocalBounds;
        this._mask = null;
        this.filterArea = null;
        // create our cached sprite
        var cachedSprite; // = new Sprite(renderTexture);
        cachedSprite.transform.worldTransform = this.transform.worldTransform;
        cachedSprite.anchor.x = -(bounds.x / bounds.width);
        cachedSprite.anchor.y = -(bounds.y / bounds.height);
        cachedSprite.alpha = cacheAlpha;
        cachedSprite._bounds = this._bounds;
        this._cacheData.sprite = cachedSprite;
        this.transform._parentID = -1;
        // restore the transform of the cached sprite to avoid the nasty flicker..
        if (!this.parent) {
            this.parent = renderer._tempDisplayObjectParent;
            this.updateTransform();
            this.parent = null;
        }
        else {
            this.updateTransform();
        }
        // map the hit test..
        this.containsPoint = cachedSprite.containsPoint.bind(cachedSprite);
    }
    ;
    /**
 * Renders a cached version of the sprite with canvas
 *
 * @private
 * @function _renderCachedCanvas
 * @memberof PIXI.DisplayObject#
 * @param {PIXI.Renderer} renderer - the WebGL renderer
 */
    _renderCachedCanvas(renderer) {
        if (!this.visible || this.worldAlpha <= 0 || !this.renderable) {
            return;
        }
        this._initCachedDisplayObjectCanvas(renderer);
        this._cacheData.sprite.worldAlpha = this.worldAlpha;
        this._cacheData.sprite._renderCanvas(renderer);
    }
    ;
    // TODO this can be the same as the WebGL version.. will need to do a little tweaking first though..
    /**
     * Prepares the Canvas renderer to cache the sprite
     *
     * @private
     * @function _initCachedDisplayObjectCanvas
     * @memberof PIXI.DisplayObject#
     * @param {PIXI.Renderer} renderer - the WebGL renderer
     */
    _initCachedDisplayObjectCanvas(renderer) {
        if (this._cacheData && this._cacheData.sprite) {
            return;
        }
        // get bounds actually transforms the object for us already!
        var bounds = this.getLocalBounds();
        var cacheAlpha = this.alpha;
        this.alpha = 1;
        var cachedRenderTarget = renderer.context;
        bounds.ceil(DisplaySettings_1.DisplaySettings.RESOLUTION);
        var renderTexture = RenderTexture_1.RenderTexture.create(bounds.width, bounds.height);
        var textureCacheId = "cacheAsBitmap_" + (MathSettings_1.MathSettings.uid());
        this._cacheData.textureCacheId = textureCacheId;
        BaseTexture_1.BaseTexture.addToCache(renderTexture.baseTexture, textureCacheId);
        Texture_1.Texture.addToCache(renderTexture, textureCacheId);
        // need to set //
        var m = DisplayObject._tempMatrix;
        this.transform.localTransform.copyTo(m);
        m.invert();
        m.tx -= bounds.x;
        m.ty -= bounds.y;
        // m.append(this.transform.worldTransform.)
        // set all properties to there original so we can render to a texture
        this.renderCanvas = this._cacheData.originalRenderCanvas;
        // renderTexture.render(this, m, true);
        renderer.render(this, renderTexture, true, m, false);
        // now restore the state be setting the new properties
        renderer.context = cachedRenderTarget;
        this.renderCanvas = this._renderCachedCanvas;
        // the rest is the same as for WebGL
        this.updateTransform = this.displayObjectUpdateTransform;
        this.calculateBounds = this._calculateCachedBounds;
        this.getLocalBounds = this._getCachedLocalBounds;
        this._mask = null;
        this.filterArea = null;
        // create our cached sprite
        var cachedSprite; //= new Sprite(renderTexture);
        cachedSprite.transform.worldTransform = this.transform.worldTransform;
        cachedSprite.anchor.x = -(bounds.x / bounds.width);
        cachedSprite.anchor.y = -(bounds.y / bounds.height);
        cachedSprite.alpha = cacheAlpha;
        cachedSprite._bounds = this._bounds;
        this._cacheData.sprite = cachedSprite;
        this.transform._parentID = -1;
        // restore the transform of the cached sprite to avoid the nasty flicker..
        if (!this.parent) {
            this.parent = renderer._tempDisplayObjectParent;
            this.updateTransform();
            this.parent = null;
        }
        else {
            this.updateTransform();
        }
        // map the hit test..
        this.containsPoint = cachedSprite.containsPoint.bind(cachedSprite);
    }
    ;
    renderCanvas(renderer) {
    }
    /**
     * Calculates the bounds of the cached sprite
     *
     * @private
     */
    _calculateCachedBounds() {
        this._bounds.clear();
        this._cacheData.sprite.transform._worldID = this.transform._worldID;
        this._cacheData.sprite._calculateBounds();
        this._lastBoundsID = this._boundsID;
    }
    ;
    /**
     * Gets the bounds of the cached sprite.
     *
     * @private
     * @return {Rectangle} The local bounds.
     */
    _getCachedLocalBounds() {
        return this._cacheData.sprite.getLocalBounds();
    }
    ;
    /**
     * Destroys the cached sprite.
     *
     * @private
     */
    _destroyCachedDisplayObject() {
        this._cacheData.sprite._texture.destroy(true);
        this._cacheData.sprite = null;
        BaseTexture_1.BaseTexture.removeFromCache(this._cacheData.textureCacheId);
        Texture_1.Texture.removeFromCache(this._cacheData.textureCacheId);
        this._cacheData.textureCacheId = null;
    }
    ;
    /**
 * Destroys the cached object.
 *
 * @private
 * @param {object|boolean} [options] - Options parameter. A boolean will act as if all options
 *  have been set to that value.
 *  Used when destroying containers, see the Container.destroy method.
 */
    _cacheAsBitmapDestroy(options) {
        this.cacheAsBitmap = false;
        this.destroy(options);
    }
    ;
}
DisplayObject._tempMatrix = new Matrix_1.Matrix();
exports.DisplayObject = DisplayObject;
// figured theres no point adding ALL the extra variables to prototype.
// this model can hold the information needed. This can also be generated on demand as
// most objects are not cached as bitmaps.
/**
 * @class
 * @ignore
 */
class CacheData {
    constructor() {
        this.textureCacheId = null;
        this.originalRender = null;
        this.originalRenderCanvas = null;
        this.originalCalculateBounds = null;
        this.originalGetLocalBounds = null;
        this.originalUpdateTransform = null;
        this.originalHitTest = null;
        this.originalDestroy = null;
        this.originalMask = null;
        this.originalFilterArea = null;
        this.sprite = null;
    }
}
;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/DisplaySettings.js":
/*!***************************************************!*\
  !*** ./js-compile/raw-pixi-ts/DisplaySettings.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class DisplaySettings {
}
DisplaySettings.SORTABLE_CHILDREN = false;
DisplaySettings.CREATE_IMAGE_BITMAP = true;
DisplaySettings.RENDERER_TYPE = {
    UNKNOWN: 0,
    WEBGL: 1,
    CANVAS: 2,
};
DisplaySettings.ENV = {
    WEBGL_LEGACY: 0,
    WEBGL: 1,
    WEBGL2: 2,
};
DisplaySettings.RESOLUTION = 1;
DisplaySettings.SCALE_MODE = 1;
DisplaySettings.ROUND_PIXELS = false;
DisplaySettings.PREFER_ENV = DisplaySettings.ENV.WEBGL;
exports.DisplaySettings = DisplaySettings;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/DrawModeSettings.js":
/*!****************************************************!*\
  !*** ./js-compile/raw-pixi-ts/DrawModeSettings.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class DrawModeSettings {
}
/**
* Various webgl draw modes. These can be used to specify which GL drawMode to use
* under certain situations and renderers.
*
* @memberof PIXI
* @static
* @name DRAW_MODES
* @enum {number}
* @property {number} POINTS
* @property {number} LINES
* @property {number} LINE_LOOP
* @property {number} LINE_STRIP
* @property {number} TRIANGLES
* @property {number} TRIANGLE_STRIP
* @property {number} TRIANGLE_FAN
*/
DrawModeSettings.DRAW_MODES = {
    POINTS: 0,
    LINES: 1,
    LINE_LOOP: 2,
    LINE_STRIP: 3,
    TRIANGLES: 4,
    TRIANGLE_STRIP: 5,
    TRIANGLE_FAN: 6,
};
exports.DrawModeSettings = DrawModeSettings;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/Ellipse.js":
/*!*******************************************!*\
  !*** ./js-compile/raw-pixi-ts/Ellipse.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Rectangle_1 = __webpack_require__(/*! ./Rectangle */ "./js-compile/raw-pixi-ts/Rectangle.js");
const ShapeSettings_1 = __webpack_require__(/*! ./ShapeSettings */ "./js-compile/raw-pixi-ts/ShapeSettings.js");
class Ellipse {
    constructor(x = 0, y = 0, halfWidth = 0, halfHeight = 0) {
        if (x === void 0) {
            x = 0;
        }
        if (y === void 0) {
            y = 0;
        }
        if (halfWidth === void 0) {
            halfWidth = 0;
        }
        if (halfHeight === void 0) {
            halfHeight = 0;
        }
        /**
         * @member {number}
         * @default 0
         */
        this.x = x;
        /**
         * @member {number}
         * @default 0
         */
        this.y = y;
        /**
         * @member {number}
         * @default 0
         */
        this.width = halfWidth;
        /**
         * @member {number}
         * @default 0
         */
        this.height = halfHeight;
        /**
         * The type of the object, mainly used to avoid `instanceof` checks
         *
         * @member {number}
         * @readOnly
         * @default PIXI.SHAPES.ELIP
         * @see PIXI.SHAPES
         */
        this.type = ShapeSettings_1.ShapeSettings.SHAPES.ELIP;
    }
    /**
     * Creates a clone of this Ellipse instance
     *
     * @return {PIXI.Ellipse} a copy of the ellipse
     */
    clone() {
        return new Ellipse(this.x, this.y, this.width, this.height);
    }
    ;
    /**
     * Checks whether the x and y coordinates given are contained within this ellipse
     *
     * @param {number} x - The X coordinate of the point to test
     * @param {number} y - The Y coordinate of the point to test
     * @return {boolean} Whether the x/y coords are within this ellipse
     */
    contains(x, y) {
        if (this.width <= 0 || this.height <= 0) {
            return false;
        }
        // normalize the coords to an ellipse with center 0,0
        var normx = ((x - this.x) / this.width);
        var normy = ((y - this.y) / this.height);
        normx *= normx;
        normy *= normy;
        return (normx + normy <= 1);
    }
    ;
    /**
     * Returns the framing rectangle of the ellipse as a Rectangle object
     *
     * @return {PIXI.Rectangle} the framing rectangle
     */
    getBounds() {
        return new Rectangle_1.Rectangle(this.x - this.width, this.y - this.height, this.width, this.height);
    }
    ;
}
exports.Ellipse = Ellipse;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/Event.js":
/*!*****************************************!*\
  !*** ./js-compile/raw-pixi-ts/Event.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const FlashBaseObject_1 = __webpack_require__(/*! ./FlashBaseObject */ "./js-compile/raw-pixi-ts/FlashBaseObject.js");
class Event extends FlashBaseObject_1.FlashBaseObject {
    constructor(type, bubble = true, cancelable = true) {
        super();
        this.reset(type, bubble, cancelable);
    }
    get currentTarget() {
        return this._currentTarget;
    }
    setCurrentTarget(value) {
        this._currentTarget = value;
    }
    get type() {
        return this._type;
    }
    get cancelable() {
        return this._cancelable;
    }
    get bubbles() {
        return this._bubbles;
    }
    get eventPhase() {
        return this._eventPhase;
    }
    clone() {
        return Event.getEvent(this._type, this._bubbles, this._cancelable);
    }
    reset(type, bubble = true, cancelable = true) {
        this._type = type;
        this._bubbles = bubble;
        this._cancelable = cancelable;
    }
    static getEvent(type, bubble = true, cancelable = true) {
        if (Event.EventCache.length) {
            let te = Event.EventCache[Event.EventCache.length - 1];
            Event.EventCache.length -= 1;
            te.reset(type, bubble, cancelable);
            return te;
        }
        return new Event(type, bubble, cancelable);
    }
    destructor() {
        this._currentTarget = null;
        let index = Event.EventCache.indexOf(this);
        if (index < 0) {
            Event.EventCache.push(this);
        }
    }
    get isDisposable() {
        return true;
    }
    stopPropagation() {
    }
    stopImmediatePropagation() {
    }
    preventDefault() {
    }
}
Event.ADDED_TO_STAGE = "addedToStage";
Event.ADDED = "added";
Event.ENTER_FRAME = "enterFrame";
Event.EXIT_FRAME = "exitFrame";
Event.FRAME_CONSTRUCTED = "frameConstructed";
Event.REMOVED = "removed";
Event.REMOVED_FROM_STAGE = "removedFromStage";
Event.RENDER = "render";
Event.COMPLETE = "complete";
Event.INIT = "init";
Event.OPEN = "open";
Event.UNLOAD = "unload";
Event.CLEAR = "clear";
Event.SOUND_COMPLETE = "soundComplete";
Event.SOUND_STARTED = "soundStarted";
Event.ACTIVATE = "activate";
Event.DEACTIVATE = "desactivate";
Event.RESIZE = "resize";
Event.CHANGE = "change";
Event.EventCache = [];
exports.Event = Event;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/EventDispatcher.js":
/*!***************************************************!*\
  !*** ./js-compile/raw-pixi-ts/EventDispatcher.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const FlashBaseObject_1 = __webpack_require__(/*! ./FlashBaseObject */ "./js-compile/raw-pixi-ts/FlashBaseObject.js");
class EventDispatcher extends FlashBaseObject_1.FlashBaseObject {
    constructor(target = null) {
        super();
        this.registeredListeners = {};
    }
    removeListeners() {
        for (var i in this.registeredListeners) {
            var methods = this.registeredListeners[i];
            while (methods.length) {
                let ms = methods.shift();
                ms.destructor();
            }
            delete this.registeredListeners[i];
        }
        this.registeredListeners = {};
    }
    destructor() {
        super.destructor();
        this.removeListeners();
    }
    willTrigger(type) {
        if (this.registeredListeners[type] != null) {
            var methods = this.registeredListeners[type];
            if (methods && methods.length) {
                return true;
            }
            return false;
        }
        return false;
    }
    removeEventListener(type, listener, useCapture = false) {
        if (this.registeredListeners[type] != null) {
            var methods = this.registeredListeners[type];
            if (methods && methods.length) {
                for (var i = 0; i < methods.length; i++) {
                    if (methods[i].objectFunction == listener) {
                        methods[i].destructor();
                        methods.splice(i, 1);
                    }
                }
            }
            if (!methods.length) {
                delete this.registeredListeners[type];
            }
        }
    }
    hasEventListener(type) {
        if (this.registeredListeners[type] != null) {
            var methods = this.registeredListeners[type];
            if (methods && methods.length) {
                return true;
            }
            return false;
        }
        return false;
    }
    dispatchEvent(event) {
        if (this.registeredListeners[event.type] != null) {
            event.setCurrentTarget(this);
            var methods = this.registeredListeners[event.type];
            if (methods && methods.length) {
                let methodcopy = methods.concat();
                methodcopy = methodcopy.sort(this.getMethodPriority);
                while (methodcopy.length) {
                    var method = methodcopy.shift();
                    if (method.eventType != event.type) {
                        continue;
                    }
                    if (method) {
                        this.trigger(method, event);
                    }
                }
            }
        }
        if (event.isDisposable) {
            event.destructor();
        }
        return false;
    }
    addEventListener(type, listener, useCapture = false, priority = 0, useWeakReference = false, scope = null) {
        if (this.isRegistered(type, listener)) {
            return;
        }
        if (!this.registeredListeners[type]) {
            this.registeredListeners[type] = [];
        }
        var methods = this.registeredListeners[type];
        var methodScope = MethodScope.getMethodScope();
        methodScope.eventType = type;
        methodScope.parentDispatcher = this;
        methodScope.objectFunction = listener;
        methodScope.scope = scope;
        methodScope.priority = priority;
        methods.push(methodScope);
    }
    trigger(method, event) {
        if (method.objectFunction) {
            method.objectFunction.call(method.scope, event);
        }
    }
    getMethodPriority(method1, method2) {
        if (method1.priority > method2.priority) {
            return 1;
        }
        return -1;
    }
    isRegistered(type, listener) {
        if (!this.registeredListeners[type]) {
            return false;
        }
        var methods = this.registeredListeners[type];
        for (var i = 0; i < methods.length; i++) {
            if (methods[i].objectFunction == listener) {
                return true;
            }
        }
        return false;
    }
}
exports.EventDispatcher = EventDispatcher;
class MethodScope extends FlashBaseObject_1.FlashBaseObject {
    constructor() {
        super();
        this.reset();
    }
    reset() {
        this.objectFunction = null;
        this.scope = null;
        this.parentDispatcher = null;
        this.priority = 0;
        this.eventType = null;
    }
    static getMethodScope() {
        if (MethodScope.MethodScopeCache.length) {
            let te = MethodScope.MethodScopeCache[MethodScope.MethodScopeCache.length - 1];
            MethodScope.MethodScopeCache.length -= 1;
            te.reset();
            return te;
        }
        return new MethodScope();
    }
    destructor() {
        this.objectFunction = null;
        this.scope = null;
        this.parentDispatcher = null;
        let index = MethodScope.MethodScopeCache.indexOf(this);
        if (index < 0) {
            MethodScope.MethodScopeCache.unshift(this);
        }
    }
}
MethodScope.MethodScopeCache = [];


/***/ }),

/***/ "./js-compile/raw-pixi-ts/Extract.js":
/*!*******************************************!*\
  !*** ./js-compile/raw-pixi-ts/Extract.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const RenderTexture_1 = __webpack_require__(/*! ./RenderTexture */ "./js-compile/raw-pixi-ts/RenderTexture.js");
const Rectangle_1 = __webpack_require__(/*! ./Rectangle */ "./js-compile/raw-pixi-ts/Rectangle.js");
const CanvasRenderTarget_1 = __webpack_require__(/*! ./CanvasRenderTarget */ "./js-compile/raw-pixi-ts/CanvasRenderTarget.js");
class Extract {
    constructor(renderer) {
        this.renderer = renderer;
        /**
         * Collection of methods for extracting data (image, pixels, etc.) from a display object or render texture
         *
         * @member {PIXI.extract.Extract} extract
         * @memberof PIXI.Renderer#
         * @see PIXI.extract.Extract
         */
        renderer.extract = this;
    }
    /**
     * Will return a HTML Image of the target
     *
     * @param {PIXI.DisplayObject|PIXI.RenderTexture} target - A displayObject or renderTexture
     *  to convert. If left empty will use the main renderer
     * @return {HTMLImageElement} HTML Image of the target
     */
    image(target) {
        var image = new Image();
        image.src = this.base64(target);
        return image;
    }
    ;
    /**
     * Will return a a base64 encoded string of this target. It works by calling
     *  `Extract.getCanvas` and then running toDataURL on that.
     *
     * @param {PIXI.DisplayObject|PIXI.RenderTexture} target - A displayObject or renderTexture
     *  to convert. If left empty will use the main renderer
     * @return {string} A base64 encoded string of the texture.
     */
    base64(target) {
        return this.canvas(target).toDataURL();
    }
    ;
    /**
     * Creates a Canvas element, renders this target to it and then returns it.
     *
     * @param {PIXI.DisplayObject|PIXI.RenderTexture} target - A displayObject or renderTexture
     *  to convert. If left empty will use the main renderer
     * @return {HTMLCanvasElement} A Canvas element with the texture rendered on.
     */
    canvas(target) {
        var renderer = this.renderer;
        var resolution;
        var frame;
        var flipY = false;
        var renderTexture;
        var generated = false;
        if (target) {
            if (target instanceof RenderTexture_1.RenderTexture) {
                renderTexture = target;
            }
            else {
                renderTexture = this.renderer.generateTexture(target);
                generated = true;
            }
        }
        if (renderTexture) {
            resolution = renderTexture.baseTexture.resolution;
            frame = renderTexture.frame;
            flipY = false;
            renderer.renderTexture.bind(renderTexture);
        }
        else {
            resolution = this.renderer.resolution;
            flipY = true;
            frame = Extract.TEMP_RECT;
            frame.width = this.renderer.width;
            frame.height = this.renderer.height;
            renderer.renderTexture.bind(null);
        }
        var width = frame.width * resolution;
        var height = frame.height * resolution;
        var canvasBuffer = new CanvasRenderTarget_1.CanvasRenderTarget(width, height, 1);
        var webglPixels = new Uint8Array(Extract.BYTES_PER_PIXEL * width * height);
        // read pixels to the array
        var gl = renderer.gl;
        gl.readPixels(frame.x * resolution, frame.y * resolution, width, height, gl.RGBA, gl.UNSIGNED_BYTE, webglPixels);
        // add the pixels to the canvas
        var canvasData = canvasBuffer.context.getImageData(0, 0, width, height);
        canvasData.data.set(webglPixels);
        canvasBuffer.context.putImageData(canvasData, 0, 0);
        // pulling pixels
        if (flipY) {
            canvasBuffer.context.scale(1, -1);
            canvasBuffer.context.drawImage(canvasBuffer.canvas, 0, -height);
        }
        if (generated) {
            renderTexture.destroy(true);
        }
        // send the canvas back..
        return canvasBuffer.canvas;
    }
    ;
    /**
     * Will return a one-dimensional array containing the pixel data of the entire texture in RGBA
     * order, with integer values between 0 and 255 (included).
     *
     * @param {PIXI.DisplayObject|PIXI.RenderTexture} target - A displayObject or renderTexture
     *  to convert. If left empty will use the main renderer
     * @return {Uint8ClampedArray} One-dimensional array containing the pixel data of the entire texture
     */
    pixels(target) {
        var renderer = this.renderer;
        var resolution;
        var frame;
        var renderTexture;
        var generated = false;
        if (target) {
            if (target instanceof RenderTexture_1.RenderTexture) {
                renderTexture = target;
            }
            else {
                renderTexture = this.renderer.generateTexture(target);
                generated = true;
            }
        }
        if (renderTexture) {
            resolution = renderTexture.baseTexture.resolution;
            frame = renderTexture.frame;
            // bind the buffer
            renderer.renderTexture.bind(renderTexture);
        }
        else {
            resolution = renderer.resolution;
            frame = Extract.TEMP_RECT;
            frame.width = renderer.width;
            frame.height = renderer.height;
            renderer.renderTexture.bind(null);
        }
        var width = frame.width * resolution;
        var height = frame.height * resolution;
        var webglPixels = new Uint8Array(Extract.BYTES_PER_PIXEL * width * height);
        // read pixels to the array
        var gl = renderer.gl;
        gl.readPixels(frame.x * resolution, frame.y * resolution, width, height, gl.RGBA, gl.UNSIGNED_BYTE, webglPixels);
        if (generated) {
            renderTexture.destroy(true);
        }
        return webglPixels;
    }
    ;
    /**
     * Destroys the extract
     *
     */
    destroy() {
        this.renderer.extract = null;
        this.renderer = null;
    }
    ;
}
Extract.TEMP_RECT = new Rectangle_1.Rectangle();
Extract.BYTES_PER_PIXEL = 4;
exports.Extract = Extract;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/FillStyle.js":
/*!*********************************************!*\
  !*** ./js-compile/raw-pixi-ts/FillStyle.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Texture_1 = __webpack_require__(/*! ./Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const FlashBaseObject_1 = __webpack_require__(/*! ./FlashBaseObject */ "./js-compile/raw-pixi-ts/FlashBaseObject.js");
class FillStyle extends FlashBaseObject_1.FlashBaseObject {
    constructor() {
        super();
        this.reset();
    }
    /**
     * Clones the object
     *
     * @return {PIXI.FillStyle}
     */
    clone() {
        var obj = new FillStyle();
        obj.color = this.color;
        obj.alpha = this.alpha;
        obj.texture = this.texture;
        obj.matrix = this.matrix;
        obj.visible = this.visible;
        return obj;
    }
    ;
    /**
     * Reset
     */
    reset() {
        /**
         * The hex color value used when coloring the Graphics object.
         *
         * @member {number}
         * @default 1
         */
        this.color = 0xFFFFFF;
        /**
         * The alpha value used when filling the Graphics object.
         *
         * @member {number}
         * @default 1
         */
        this.alpha = 1;
        /**
         * The texture to be used for the fill.
         *
         * @member {string}
         * @default 0
         */
        this.texture = Texture_1.Texture.WHITE;
        /**
         * The transform aplpied to the texture.
         *
         * @member {string}
         * @default 0
         */
        this.matrix = null;
        /**
         * If the current fill is visible.
         *
         * @member {boolean}
         * @default false
         */
        this.visible = false;
    }
    ;
    /**
     * Destroy and don't use after this
     */
    destroy() {
        this.texture = null;
        this.matrix = null;
    }
    ;
}
exports.FillStyle = FillStyle;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/Filter.js":
/*!******************************************!*\
  !*** ./js-compile/raw-pixi-ts/Filter.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Shader_1 = __webpack_require__(/*! ./Shader */ "./js-compile/raw-pixi-ts/Shader.js");
const Program_1 = __webpack_require__(/*! ./Program */ "./js-compile/raw-pixi-ts/Program.js");
const settings_1 = __webpack_require__(/*! ./settings */ "./js-compile/raw-pixi-ts/settings.js");
const State_1 = __webpack_require__(/*! ./State */ "./js-compile/raw-pixi-ts/State.js");
class Filter extends Shader_1.Shader {
    constructor(vertexSrc = null, fragmentSrc = null, uniforms = null) {
        var program = Program_1.Program.from(vertexSrc || Filter.defaultVertexSrc, fragmentSrc || Filter.defaultFragmentSrc);
        super(program, uniforms);
        /**
         * The padding of the filter. Some filters require extra space to breath such as a blur.
         * Increasing this will add extra width and height to the bounds of the object that the
         * filter is applied to.
         *
         * @member {number}
         */
        this.padding = 0;
        /**
         * The resolution of the filter. Setting this to be lower will lower the quality but
         * increase the performance of the filter.
         *
         * @member {number}
         */
        this.resolution = settings_1.settings.FILTER_RESOLUTION;
        /**
         * If enabled is true the filter is applied, if false it will not.
         *
         * @member {boolean}
         */
        this.enabled = true;
        /**
         * If enabled, PixiJS will fit the filter area into boundaries for better performance.
         * Switch it off if it does not work for specific shader.
         *
         * @member {boolean}
         */
        this.autoFit = true;
        /**
         * Legacy filters use position and uvs from attributes
         * @member {boolean}
         * @readonly
         */
        this.legacy = !!this.program.attributeData.aTextureCoord;
        /**
         * The WebGL state the filter requires to render
         * @member {PIXI.State}
         */
        this.state = new State_1.State();
    }
    /**
     * Applies the filter
     *
     * @param {PIXI.systems.FilterSystem} filterManager - The renderer to retrieve the filter from
     * @param {PIXI.RenderTexture} input - The input render target.
     * @param {PIXI.RenderTexture} output - The target to output to.
     * @param {boolean} clear - Should the output be cleared before rendering to it
     * @param {object} [currentState] - It's current state of filter.
     *        There are some useful properties in the currentState :
     *        target, filters, sourceFrame, destinationFrame, renderTarget, resolution
     */
    apply(filterManager, input, output, clear, currentState, derp) {
        // do as you please!
        filterManager.applyFilter(this, input, output, clear, currentState, derp);
        // or just do a regular render..
    }
    ;
    /**
     * Sets the blendmode of the filter
     *
     * @member {number}
     * @default PIXI.BLEND_MODES.NORMAL
     */
    get blendMode() {
        return this.state.blendMode;
    }
    ;
    set blendMode(value) {
        this.state.blendMode = value;
    }
    ;
    /**
     * The default vertex shader source
     *
     * @static
     * @type {string}
     * @constant
     */
    static get defaultVertexSrc() {
        return Filter.defaultVertex$1;
    }
    ;
    /**
     * The default fragment shader source
     *
     * @static
     * @type {string}
     * @constant
     */
    static get defaultFragmentSrc() {
        return Filter.defaultFragment$1;
    }
    ;
}
/**
 * Used for caching shader IDs
 *
 * @static
 * @type {object}
 * @protected
 */
Filter.SOURCE_KEY_MAP = {};
Filter.defaultVertex$1 = "attribute vec2 aVertexPosition;\r\n\r\nuniform mat3 projectionMatrix;\r\n\r\nvarying vec2 vTextureCoord;\r\n\r\nuniform vec4 inputSize;\r\nuniform vec4 outputFrame;\r\n\r\nvec4 filterVertexPosition( void )\r\n{\r\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\r\n\r\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\r\n}\r\n\r\nvec2 filterTextureCoord( void )\r\n{\r\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\r\n}\r\n\r\nvoid main(void)\r\n{\r\n    gl_Position = filterVertexPosition();\r\n    vTextureCoord = filterTextureCoord();\r\n}\r\n";
Filter.defaultFragment$1 = "varying vec2 vTextureCoord;\r\n\r\nuniform sampler2D uSampler;\r\n\r\nvoid main(void){\r\n   gl_FragColor = texture2D(uSampler, vTextureCoord);\r\n}\r\n";
exports.Filter = Filter;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/FilterState.js":
/*!***********************************************!*\
  !*** ./js-compile/raw-pixi-ts/FilterState.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Rectangle_1 = __webpack_require__(/*! ./Rectangle */ "./js-compile/raw-pixi-ts/Rectangle.js");
class FilterState {
    constructor() {
        this.renderTexture = null;
        /**
         * Target of the filters
         * We store for case when custom filter wants to know the element it was applied on
         * @member {PIXI.DisplayObject}
         * @private
         */
        this.target = null;
        /**
         * Compatibility with PixiJS v4 filters
         * @member {boolean}
         * @default false
         * @private
         */
        this.legacy = false;
        /**
         * Resolution of filters
         * @member {number}
         * @default 1
         * @private
         */
        this.resolution = 1;
        // next three fields are created only for root
        // re-assigned for everything else
        /**
         * Source frame
         * @member {PIXI.Rectangle}
         * @private
         */
        this.sourceFrame = new Rectangle_1.Rectangle();
        /**
         * Destination frame
         * @member {PIXI.Rectangle}
         * @private
         */
        this.destinationFrame = new Rectangle_1.Rectangle();
        /**
         * Collection of filters
         * @member {PIXI.Filter[]}
         * @private
         */
        this.filters = [];
    }
    /**
     * clears the state
     * @private
     */
    clear() {
        this.target = null;
        this.filters = null;
        this.renderTexture = null;
    }
    ;
}
exports.FilterState = FilterState;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/FilterSystem.js":
/*!************************************************!*\
  !*** ./js-compile/raw-pixi-ts/FilterSystem.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const System_1 = __webpack_require__(/*! ./System */ "./js-compile/raw-pixi-ts/System.js");
const Quad_1 = __webpack_require__(/*! ./Quad */ "./js-compile/raw-pixi-ts/Quad.js");
const QuadUv_1 = __webpack_require__(/*! ./QuadUv */ "./js-compile/raw-pixi-ts/QuadUv.js");
const Rectangle_1 = __webpack_require__(/*! ./Rectangle */ "./js-compile/raw-pixi-ts/Rectangle.js");
const UniformGroup_1 = __webpack_require__(/*! ./UniformGroup */ "./js-compile/raw-pixi-ts/UniformGroup.js");
const RenderTexture_1 = __webpack_require__(/*! ./RenderTexture */ "./js-compile/raw-pixi-ts/RenderTexture.js");
const Matrix_1 = __webpack_require__(/*! ./Matrix */ "./js-compile/raw-pixi-ts/Matrix.js");
const FilterState_1 = __webpack_require__(/*! ./FilterState */ "./js-compile/raw-pixi-ts/FilterState.js");
const DrawModeSettings_1 = __webpack_require__(/*! ./DrawModeSettings */ "./js-compile/raw-pixi-ts/DrawModeSettings.js");
const MathSettings_1 = __webpack_require__(/*! ./MathSettings */ "./js-compile/raw-pixi-ts/MathSettings.js");
class FilterSystem extends System_1.System {
    constructor(renderer) {
        super(renderer);
        /**
         * List of filters for the FilterSystem
         * @member {Object[]}
         * @readonly
         */
        this.defaultFilterStack = [{}];
        /**
         * stores a bunch of PO2 textures used for filtering
         * @member {Object}
         */
        this.texturePool = {};
        /**
         * a pool for storing filter states, save us creating new ones each tick
         * @member {Object[]}
         */
        this.statePool = [];
        /**
         * A very simple geometry used when drawing a filter effect to the screen
         * @member {PIXI.Quad}
         */
        this.quad = new Quad_1.Quad();
        /**
         * Quad UVs
         * @member {PIXI.QuadUv}
         */
        this.quadUv = new QuadUv_1.QuadUv();
        /**
         * Temporary rect for maths
         * @type {PIXI.Rectangle}
         */
        this.tempRect = new Rectangle_1.Rectangle();
        /**
         * Active state
         * @member {object}
         */
        this.activeState = {};
        /**
         * This uniform group is attached to filter uniforms when used
         * @member {PIXI.UniformGroup}
         * @property {PIXI.Rectangle} outputFrame
         * @property {Float32Array} inputSize
         * @property {Float32Array} inputPixel
         * @property {Float32Array} inputClamp
         * @property {Number} resolution
         * @property {Float32Array} filterArea
         * @property {Fload32Array} filterClamp
         */
        this.globalUniforms = new UniformGroup_1.UniformGroup({
            outputFrame: this.tempRect,
            inputSize: new Float32Array(4),
            inputPixel: new Float32Array(4),
            inputClamp: new Float32Array(4),
            resolution: 1,
            // legacy variables
            filterArea: new Float32Array(4),
            filterClamp: new Float32Array(4),
        }, true);
        this._pixelsWidth = renderer.view.width;
        this._pixelsHeight = renderer.view.height;
    }
    /**
     * Adds a new filter to the System.
     *
     * @param {PIXI.DisplayObject} target - The target of the filter to render.
     * @param {PIXI.Filter[]} filters - The filters to apply.
     */
    push(target, filters) {
        var renderer = this.renderer;
        var filterStack = this.defaultFilterStack;
        var state = this.statePool.pop() || new FilterState_1.FilterState();
        var resolution = filters[0].resolution;
        var padding = filters[0].padding;
        var autoFit = filters[0].autoFit;
        var legacy = filters[0].legacy;
        for (var i = 1; i < filters.length; i++) {
            var filter = filters[i];
            // lets use the lowest resolution..
            resolution = Math.min(resolution, filter.resolution);
            // and the largest amount of padding!
            padding = Math.max(padding, filter.padding);
            // only auto fit if all filters are autofit
            autoFit = autoFit || filter.autoFit;
            legacy = legacy || filter.legacy;
        }
        if (filterStack.length === 1) {
            this.defaultFilterStack[0].renderTexture = renderer.renderTexture.current;
        }
        filterStack.push(state);
        state.resolution = resolution;
        state.legacy = legacy;
        state.target = target;
        state.sourceFrame.copyFrom(target.filterArea || target.getBounds(true));
        state.sourceFrame.pad(padding);
        if (autoFit) {
            state.sourceFrame.fit(this.renderer.renderTexture.sourceFrame);
        }
        // round to whole number based on resolution
        state.sourceFrame.ceil(resolution);
        state.renderTexture = this.getOptimalFilterTexture(state.sourceFrame.width, state.sourceFrame.height, resolution);
        state.filters = filters;
        state.destinationFrame.width = state.renderTexture.width;
        state.destinationFrame.height = state.renderTexture.height;
        state.renderTexture.filterFrame = state.sourceFrame;
        renderer.renderTexture.bind(state.renderTexture, state.sourceFrame); // /, state.destinationFrame);
        renderer.renderTexture.clear();
    }
    ;
    /**
     * Pops off the filter and applies it.
     *
     */
    pop() {
        var filterStack = this.defaultFilterStack;
        var state = filterStack.pop();
        var filters = state.filters;
        this.activeState = state;
        var globalUniforms = this.globalUniforms.uniforms;
        globalUniforms.outputFrame = state.sourceFrame;
        globalUniforms.resolution = state.resolution;
        var inputSize = globalUniforms.inputSize;
        var inputPixel = globalUniforms.inputPixel;
        var inputClamp = globalUniforms.inputClamp;
        inputSize[0] = state.destinationFrame.width;
        inputSize[1] = state.destinationFrame.height;
        inputSize[2] = 1.0 / inputSize[0];
        inputSize[3] = 1.0 / inputSize[1];
        inputPixel[0] = inputSize[0] * state.resolution;
        inputPixel[1] = inputSize[1] * state.resolution;
        inputPixel[2] = 1.0 / inputPixel[0];
        inputPixel[3] = 1.0 / inputPixel[1];
        inputClamp[0] = 0.5 * inputPixel[2];
        inputClamp[1] = 0.5 * inputPixel[3];
        inputClamp[2] = (state.sourceFrame.width * inputSize[2]) - (0.5 * inputPixel[2]);
        inputClamp[3] = (state.sourceFrame.height * inputSize[3]) - (0.5 * inputPixel[3]);
        // only update the rect if its legacy..
        if (state.legacy) {
            var filterArea = globalUniforms.filterArea;
            filterArea[0] = state.destinationFrame.width;
            filterArea[1] = state.destinationFrame.height;
            filterArea[2] = state.sourceFrame.x;
            filterArea[3] = state.sourceFrame.y;
            globalUniforms.filterClamp = globalUniforms.inputClamp;
        }
        this.globalUniforms.update();
        var lastState = filterStack[filterStack.length - 1];
        if (filters.length === 1) {
            filters[0].apply(this, state.renderTexture, lastState.renderTexture, false, state);
            this.returnFilterTexture(state.renderTexture);
        }
        else {
            var flip = state.renderTexture;
            var flop = this.getOptimalFilterTexture(flip.width, flip.height, state.resolution);
            flop.filterFrame = flip.filterFrame;
            var i = 0;
            for (i = 0; i < filters.length - 1; ++i) {
                filters[i].apply(this, flip, flop, true, state);
                var t = flip;
                flip = flop;
                flop = t;
            }
            filters[i].apply(this, flip, lastState.renderTexture, false, state);
            this.returnFilterTexture(flip);
            this.returnFilterTexture(flop);
        }
        state.clear();
        this.statePool.push(state);
    }
    ;
    /**
     * Draws a filter.
     *
     * @param {PIXI.Filter} filter - The filter to draw.
     * @param {PIXI.RenderTexture} input - The input render target.
     * @param {PIXI.RenderTexture} output - The target to output to.
     * @param {boolean} clear - Should the output be cleared before rendering to it
     */
    applyFilter(filter, input, output, clear) {
        var renderer = this.renderer;
        renderer.renderTexture.bind(output, output ? output.filterFrame : null);
        if (clear) {
            // gl.disable(gl.SCISSOR_TEST);
            renderer.renderTexture.clear();
            // gl.enable(gl.SCISSOR_TEST);
        }
        // set the uniforms..
        filter.uniforms.uSampler = input;
        filter.uniforms.filterGlobals = this.globalUniforms;
        // TODO make it so that the order of this does not matter..
        // because it does at the moment cos of global uniforms.
        // they need to get resynced
        renderer.state.setState(filter.state);
        renderer.shader.bind(filter);
        if (filter.legacy) {
            this.quadUv.map(input._frame, input.filterFrame);
            renderer.geometry.bind(this.quadUv);
            renderer.geometry.draw(DrawModeSettings_1.DrawModeSettings.DRAW_MODES.TRIANGLES);
        }
        else {
            renderer.geometry.bind(this.quad);
            renderer.geometry.draw(DrawModeSettings_1.DrawModeSettings.DRAW_MODES.TRIANGLE_STRIP);
        }
    }
    ;
    /**
     * Calculates the mapped matrix.
     *
     * TODO playing around here.. this is temporary - (will end up in the shader)
     * this returns a matrix that will normalize map filter cords in the filter to screen space
     *
     * @param {PIXI.Matrix} outputMatrix - the matrix to output to.
     * @return {PIXI.Matrix} The mapped matrix.
     */
    calculateScreenSpaceMatrix(outputMatrix) {
        var currentState = this.activeState;
        return FilterSystem.calculateScreenSpaceMatrix(outputMatrix, currentState.sourceFrame, currentState.destinationFrame);
    }
    ;
    /**
     * This will map the filter coord so that a texture can be used based on the transform of a sprite
     *
     * @param {PIXI.Matrix} outputMatrix - The matrix to output to.
     * @param {PIXI.Sprite} sprite - The sprite to map to.
     * @return {PIXI.Matrix} The mapped matrix.
     */
    calculateSpriteMatrix(outputMatrix, sprite) {
        var currentState = this.activeState;
        return FilterSystem.calculateSpriteMatrix(outputMatrix, currentState.sourceFrame, currentState.destinationFrame, sprite);
    }
    ;
    /**
     * Destroys this Filter System.
     *
     * @param {boolean} [contextLost=false] context was lost, do not free shaders
     *
     */
    destroy(contextLost) {
        if (contextLost === void 0) {
            contextLost = false;
        }
        if (!contextLost) {
            this.emptyPool();
        }
        else {
            this.texturePool = {};
        }
    }
    ;
    /**
     * Gets a Power-of-Two render texture or fullScreen texture
     *
     * TODO move to a separate class could be on renderer?
     *
     * @protected
     * @param {number} minWidth - The minimum width of the render texture in real pixels.
     * @param {number} minHeight - The minimum height of the render texture in real pixels.
     * @param {number} [resolution=1] - The resolution of the render texture.
     * @return {PIXI.RenderTexture} The new render texture.
     */
    getOptimalFilterTexture(minWidth, minHeight, resolution) {
        if (resolution === void 0) {
            resolution = 1;
        }
        var key = FilterSystem.screenKey;
        minWidth *= resolution;
        minHeight *= resolution;
        if (minWidth !== this._pixelsWidth || minHeight !== this._pixelsHeight) {
            minWidth = MathSettings_1.MathSettings.nextPow2(minWidth);
            minHeight = MathSettings_1.MathSettings.nextPow2(minHeight);
            key = ((minWidth & 0xFFFF) << 16) | (minHeight & 0xFFFF);
        }
        if (!this.texturePool[key]) {
            this.texturePool[key] = [];
        }
        var renderTexture = this.texturePool[key].pop();
        if (!renderTexture) {
            // temporary bypass cache..
            // internally - this will cause a texture to be bound..
            renderTexture = RenderTexture_1.RenderTexture.create({
                width: minWidth / resolution,
                height: minHeight / resolution,
                resolution: resolution,
            });
        }
        renderTexture.filterPoolKey = key;
        return renderTexture;
    }
    ;
    /**
     * Gets extra render texture to use inside current filter
     *
     * @param {number} resolution resolution of the renderTexture
     * @returns {PIXI.RenderTexture}
     */
    getFilterTexture(resolution) {
        var rt = this.activeState.renderTexture;
        var filterTexture = this.getOptimalFilterTexture(rt.width, rt.height, resolution || rt.baseTexture.resolution);
        filterTexture.filterFrame = rt.filterFrame;
        return filterTexture;
    }
    ;
    /**
     * Frees a render texture back into the pool.
     *
     * @param {PIXI.RenderTexture} renderTexture - The renderTarget to free
     */
    returnFilterTexture(renderTexture) {
        var key = renderTexture.filterPoolKey;
        renderTexture.filterFrame = null;
        this.texturePool[key].push(renderTexture);
    }
    ;
    /**
     * Empties the texture pool.
     *
     */
    emptyPool() {
        for (var i in this.texturePool) {
            var textures = this.texturePool[i];
            if (textures) {
                for (var j = 0; j < textures.length; j++) {
                    textures[j].destroy(true);
                }
            }
        }
        this.texturePool = {};
    }
    ;
    resize() {
        var textures = this.texturePool[FilterSystem.screenKey];
        if (textures) {
            for (var j = 0; j < textures.length; j++) {
                textures[j].destroy(true);
            }
        }
        this.texturePool[FilterSystem.screenKey] = [];
        this._pixelsWidth = this.renderer.view.width;
        this._pixelsHeight = this.renderer.view.height;
    }
    ;
    // this will map the filter coord so that a texture can be used based on the transform of a sprite
    static calculateSpriteMatrix(outputMatrix, filterArea, textureSize, sprite) {
        var orig = sprite._texture.orig;
        var mappedMatrix = outputMatrix.set(textureSize.width, 0, 0, textureSize.height, filterArea.x, filterArea.y);
        var worldTransform = sprite.worldTransform.copyTo(Matrix_1.Matrix.TEMP_MATRIX);
        worldTransform.invert();
        mappedMatrix.prepend(worldTransform);
        mappedMatrix.scale(1.0 / orig.width, 1.0 / orig.height);
        mappedMatrix.translate(sprite.anchor.x, sprite.anchor.y);
        return mappedMatrix;
    }
    /**
 * Calculates the mapped matrix
 * @param {PIXI.Matrix} outputMatrix matrix that will normalize map filter cords in the filter to screen space
 * @param {PIXI.Rectangle} filterArea filter area
 * @param {PIXI.Rectangle} textureSize texture size
 * @returns {PIXI.Matrix} same as outputMatrix
 * @private
 */
    static calculateScreenSpaceMatrix(outputMatrix, filterArea, textureSize) {
        // TODO unwrap?
        var mappedMatrix = outputMatrix.identity();
        mappedMatrix.translate(filterArea.x / textureSize.width, filterArea.y / textureSize.height);
        mappedMatrix.scale(textureSize.width, textureSize.height);
        return mappedMatrix;
    }
}
FilterSystem.screenKey = 'screen';
exports.FilterSystem = FilterSystem;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/FlashBaseObject.js":
/*!***************************************************!*\
  !*** ./js-compile/raw-pixi-ts/FlashBaseObject.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class FlashBaseObject {
    constructor() {
        FlashBaseObject.nameCount++;
        this._name = "instance-" + this.className + "-" + FlashBaseObject.nameCount;
        this._instanceName = "instance-" + this.className + "-" + FlashBaseObject.nameCount;
        this._hasChanged = true;
        this._className = this.constructor['name'];
    }
    get className() {
        return this.constructor['name'];
    }
    destructor() {
    }
    get hasChanged() {
        return this._hasChanged;
    }
    set hasChanged(value) {
        this._hasChanged = value;
    }
    get name() {
        return this._name;
    }
    set name(value) {
        this._name = value;
    }
    get instanceName() {
        return this._instanceName;
    }
}
FlashBaseObject.nameCount = 0;
exports.FlashBaseObject = FlashBaseObject;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/Framebuffer.js":
/*!***********************************************!*\
  !*** ./js-compile/raw-pixi-ts/Framebuffer.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseTexture_1 = __webpack_require__(/*! ./BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const DepthResource_1 = __webpack_require__(/*! ./DepthResource */ "./js-compile/raw-pixi-ts/DepthResource.js");
const WebGLSettings_1 = __webpack_require__(/*! ./WebGLSettings */ "./js-compile/raw-pixi-ts/WebGLSettings.js");
const Runner_1 = __webpack_require__(/*! ./Runner */ "./js-compile/raw-pixi-ts/Runner.js");
class Framebuffer {
    constructor(width, height) {
        this.width = Math.ceil(width || 100);
        this.height = Math.ceil(height || 100);
        this.stencil = false;
        this.depth = false;
        this.dirtyId = 0;
        this.dirtyFormat = 0;
        this.dirtySize = 0;
        this.depthTexture = null;
        this.colorTextures = [];
        this.glFramebuffers = {};
        this.disposeRunner = new Runner_1.Runner('disposeFramebuffer', 2);
        // this.disposeRunner = new Runner('disposeFramebuffer', 2);
    }
    /**
     * Reference to the colorTexture.
     *
     * @member {PIXI.Texture[]}
     * @readonly
     */
    get colorTexture() {
        return this.colorTextures[0];
    }
    ;
    /**
     * Add texture to the colorTexture array
     *
     * @param {number} [index=0] - Index of the array to add the texture to
     * @param {PIXI.Texture} [texture] - Texture to add to the array
     */
    addColorTexture(index, texture) {
        if (index === void 0) {
            index = 0;
        }
        // TODO add some validation to the texture - same width / height etc?
        this.colorTextures[index] = texture || new BaseTexture_1.BaseTexture(null, { scaleMode: 0,
            resolution: 1,
            mipmap: false,
            width: this.width,
            height: this.height }); // || new Texture();
        this.dirtyId++;
        this.dirtyFormat++;
        return this;
    }
    ;
    /**
     * Add a depth texture to the frame buffer
     *
     * @param {PIXI.Texture} [texture] - Texture to add
     */
    addDepthTexture(texture) {
        /* eslint-disable max-len */
        this.depthTexture = texture || new BaseTexture_1.BaseTexture(new DepthResource_1.DepthResource(null, { width: this.width, height: this.height }), { scaleMode: 0,
            resolution: 1,
            width: this.width,
            height: this.height,
            mipmap: false,
            format: WebGLSettings_1.WebGLSettings.FORMATS.DEPTH_COMPONENT,
            type: WebGLSettings_1.WebGLSettings.TYPES.UNSIGNED_SHORT }); // UNSIGNED_SHORT;
        /* eslint-disable max-len */
        this.dirtyId++;
        this.dirtyFormat++;
        return this;
    }
    ;
    /**
     * Enable depth on the frame buffer
     */
    enableDepth() {
        this.depth = true;
        this.dirtyId++;
        this.dirtyFormat++;
        return this;
    }
    ;
    /**
     * Enable stencil on the frame buffer
     */
    enableStencil() {
        this.stencil = true;
        this.dirtyId++;
        this.dirtyFormat++;
        return this;
    }
    ;
    /**
     * Resize the frame buffer
     *
     * @param {number} width - Width of the frame buffer to resize to
     * @param {number} height - Height of the frame buffer to resize to
     */
    resize(width, height) {
        width = Math.ceil(width);
        height = Math.ceil(height);
        if (width === this.width && height === this.height) {
            return;
        }
        this.width = width;
        this.height = height;
        this.dirtyId++;
        this.dirtySize++;
        for (var i = 0; i < this.colorTextures.length; i++) {
            var texture = this.colorTextures[i];
            var resolution = texture.resolution;
            // take into acount the fact the texture may have a different resolution..
            texture.setSize(width / resolution, height / resolution);
        }
        if (this.depthTexture) {
            var resolution$1 = this.depthTexture.resolution;
            this.depthTexture.setSize(width / resolution$1, height / resolution$1);
        }
    }
    ;
    /**
     * disposes WebGL resources that are connected to this geometry
     */
    dispose() {
        // this.disposeRunner.run(this, false);
        this.disposeRunner.run(this, false);
    }
    ;
}
exports.Framebuffer = Framebuffer;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/FramebufferSystem.js":
/*!*****************************************************!*\
  !*** ./js-compile/raw-pixi-ts/FramebufferSystem.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const System_1 = __webpack_require__(/*! ./System */ "./js-compile/raw-pixi-ts/System.js");
const Framebuffer_1 = __webpack_require__(/*! ./Framebuffer */ "./js-compile/raw-pixi-ts/Framebuffer.js");
const Rectangle_1 = __webpack_require__(/*! ./Rectangle */ "./js-compile/raw-pixi-ts/Rectangle.js");
const DisplaySettings_1 = __webpack_require__(/*! ./DisplaySettings */ "./js-compile/raw-pixi-ts/DisplaySettings.js");
class FramebufferSystem extends System_1.System {
    constructor(renderer) {
        super(renderer);
        /**
         * A list of managed framebuffers
         * @member {PIXI.Framebuffer[]}
         * @readonly
         */
        this.managedFramebuffers = [];
        /**
         * Framebuffer value that shows that we don't know what is bound
         * @member {Framebuffer}
         * @readonly
         */
        this.unknownFramebuffer = new Framebuffer_1.Framebuffer(10, 10);
        this.viewport = new Rectangle_1.Rectangle();
    }
    /**
     * Sets up the renderer context and necessary buffers.
     */
    contextChange(gl) {
        var gl = this.gl = this.renderer.gl;
        this.CONTEXT_UID = this.renderer.CONTEXT_UID;
        this.current = this.unknownFramebuffer;
        this.viewport = new Rectangle_1.Rectangle();
        this.hasMRT = true;
        this.writeDepthTexture = true;
        this.disposeAll(true);
        // webgl2
        if (this.renderer.context.webGLVersion === 1) {
            // webgl 1!
            var nativeDrawBuffersExtension = this.renderer.context.extensions.drawBuffers;
            var nativeDepthTextureExtension = this.renderer.context.extensions.depthTexture;
            if (DisplaySettings_1.DisplaySettings.PREFER_ENV === DisplaySettings_1.DisplaySettings.ENV.WEBGL_LEGACY) {
                nativeDrawBuffersExtension = null;
                nativeDepthTextureExtension = null;
            }
            if (nativeDrawBuffersExtension) {
                gl.drawBuffers = function (activeTextures) { return nativeDrawBuffersExtension.drawBuffersWEBGL(activeTextures); };
            }
            else {
                this.hasMRT = false;
                gl.drawBuffers = function () {
                    // empty
                };
            }
            if (!nativeDepthTextureExtension) {
                this.writeDepthTexture = false;
            }
        }
    }
    ;
    /**
         * Bind a framebuffer
         *
         * @param {PIXI.Framebuffer} framebuffer
         * @param {PIXI.Rectangle} [frame] frame, default is framebuffer size
         */
    bind(framebuffer = null, frame = null) {
        var ref = this;
        var gl = ref.gl;
        if (framebuffer) {
            // TODO caching layer!
            var fbo = framebuffer.glFramebuffers[this.CONTEXT_UID] || this.initFramebuffer(framebuffer);
            if (this.current !== framebuffer) {
                this.current = framebuffer;
                gl.bindFramebuffer(gl.FRAMEBUFFER, fbo.framebuffer);
            }
            // make sure all textures are unbound..
            // now check for updates...
            if (fbo.dirtyId !== framebuffer.dirtyId) {
                fbo.dirtyId = framebuffer.dirtyId;
                if (fbo.dirtyFormat !== framebuffer.dirtyFormat) {
                    fbo.dirtyFormat = framebuffer.dirtyFormat;
                    this.updateFramebuffer(framebuffer);
                }
                else if (fbo.dirtySize !== framebuffer.dirtySize) {
                    fbo.dirtySize = framebuffer.dirtySize;
                    this.resizeFramebuffer(framebuffer);
                }
            }
            for (var i = 0; i < framebuffer.colorTextures.length; i++) {
                if (framebuffer.colorTextures[i].texturePart) {
                    this.renderer.texture.unbind(framebuffer.colorTextures[i].texture);
                }
                else {
                    this.renderer.texture.unbind(framebuffer.colorTextures[i]);
                }
            }
            if (framebuffer.depthTexture) {
                this.renderer.texture.unbind(framebuffer.depthTexture);
            }
            if (frame) {
                this.setViewport(frame.x, frame.y, frame.width, frame.height);
            }
            else {
                this.setViewport(0, 0, framebuffer.width, framebuffer.height);
            }
        }
        else {
            if (this.current) {
                this.current = null;
                gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            }
            if (frame) {
                this.setViewport(frame.x, frame.y, frame.width, frame.height);
            }
            else {
                this.setViewport(0, 0, this.renderer.width, this.renderer.height);
            }
        }
    }
    ;
    /**
     * Set the WebGLRenderingContext's viewport.
     *
     * @param {Number} x - X position of viewport
     * @param {Number} y - Y position of viewport
     * @param {Number} width - Width of viewport
     * @param {Number} height - Height of viewport
     */
    setViewport(x, y, width, height) {
        var v = this.viewport;
        if (v.width !== width || v.height !== height || v.x !== x || v.y !== y) {
            v.x = x;
            v.y = y;
            v.width = width;
            v.height = height;
            this.gl.viewport(x, y, width, height);
        }
    }
    ;
    /**
     * Get the size of the current width and height. Returns object with `width` and `height` values.
     *
     * @member {object}
     * @readonly
     */
    get size() {
        if (this.current) {
            // TODO store temp
            return { x: 0, y: 0, width: this.current.width, height: this.current.height };
        }
        return { x: 0, y: 0, width: this.renderer.width, height: this.renderer.height };
    }
    ;
    /**
     * Clear the color of the context
     *
     * @param {Number} r - Red value from 0 to 1
     * @param {Number} g - Green value from 0 to 1
     * @param {Number} b - Blue value from 0 to 1
     * @param {Number} a - Alpha value from 0 to 1
     */
    clear(r = 0, g = 0, b = 0, a = 1) {
        var ref = this;
        var gl = ref.gl;
        // TODO clear color can be set only one right?
        gl.clearColor(r, g, b, a);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    }
    ;
    /**
 * Initialize framebuffer
 *
 * @protected
 * @param {PIXI.Framebuffer} framebuffer
 */
    initFramebuffer(framebuffer) {
        var ref = this;
        var gl = ref.gl;
        // TODO - make this a class?
        var fbo = {
            framebuffer: gl.createFramebuffer(),
            stencil: null,
            dirtyId: 0,
            dirtyFormat: 0,
            dirtySize: 0,
        };
        framebuffer.glFramebuffers[this.CONTEXT_UID] = fbo;
        this.managedFramebuffers.push(framebuffer);
        framebuffer.disposeRunner.add(this);
        return fbo;
    }
    ;
    /**
     * Resize the framebuffer
     *
     * @protected
     * @param {PIXI.Framebuffer} framebuffer
     */
    resizeFramebuffer(framebuffer) {
        var ref = this;
        var gl = ref.gl;
        var fbo = framebuffer.glFramebuffers[this.CONTEXT_UID];
        if (fbo.stencil) {
            gl.bindRenderbuffer(gl.RENDERBUFFER, fbo.stencil);
            gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, framebuffer.width, framebuffer.height);
        }
        var colorTextures = framebuffer.colorTextures;
        for (var i = 0; i < colorTextures.length; i++) {
            this.renderer.texture.bind(colorTextures[i], 0);
        }
        if (framebuffer.depthTexture) {
            this.renderer.texture.bind(framebuffer.depthTexture, 0);
        }
    }
    ;
    /**
     * Update the framebuffer
     *
     * @protected
     * @param {PIXI.Framebuffer} framebuffer
     */
    updateFramebuffer(framebuffer) {
        var ref = this;
        var gl = ref.gl;
        var fbo = framebuffer.glFramebuffers[this.CONTEXT_UID];
        // bind the color texture
        var colorTextures = framebuffer.colorTextures;
        var count = colorTextures.length;
        if (!gl.drawBuffers) {
            count = Math.min(count, 1);
        }
        var activeTextures = [];
        for (var i = 0; i < count; i++) {
            var texture = framebuffer.colorTextures[i];
            if (texture.texturePart) {
                this.renderer.texture.bind(texture.texture, 0);
                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, gl.TEXTURE_CUBE_MAP_NEGATIVE_X + texture.side, texture.texture._glTextures[this.CONTEXT_UID].texture, 0);
            }
            else {
                this.renderer.texture.bind(texture, 0);
                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, gl.TEXTURE_2D, texture._glTextures[this.CONTEXT_UID].texture, 0);
            }
            activeTextures.push(gl.COLOR_ATTACHMENT0 + i);
        }
        if (activeTextures.length > 1) {
            gl.drawBuffers(activeTextures);
        }
        if (framebuffer.depthTexture) {
            var writeDepthTexture = this.writeDepthTexture;
            if (writeDepthTexture) {
                var depthTexture = framebuffer.depthTexture;
                this.renderer.texture.bind(depthTexture, 0);
                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, depthTexture._glTextures[this.CONTEXT_UID].texture, 0);
            }
        }
        if (!fbo.stencil && (framebuffer.stencil || framebuffer.depth)) {
            fbo.stencil = gl.createRenderbuffer();
            gl.bindRenderbuffer(gl.RENDERBUFFER, fbo.stencil);
            // TODO.. this is depth AND stencil?
            if (!framebuffer.depthTexture) { // you can't have both, so one should take priority if enabled
                gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, fbo.stencil);
            }
            gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, framebuffer.width, framebuffer.height);
            // fbo.enableStencil();
        }
    }
    ;
    /**
     * Disposes framebuffer
     * @param {PIXI.Framebuffer} framebuffer framebuffer that has to be disposed of
     * @param {boolean} [contextLost=false] If context was lost, we suppress all delete function calls
     */
    disposeFramebuffer(framebuffer, contextLost) {
        var fbo = framebuffer.glFramebuffers[this.CONTEXT_UID];
        var gl = this.gl;
        if (!fbo) {
            return;
        }
        delete framebuffer.glFramebuffers[this.CONTEXT_UID];
        var index = this.managedFramebuffers.indexOf(framebuffer);
        if (index >= 0) {
            this.managedFramebuffers.splice(index, 1);
        }
        framebuffer.disposeRunner.remove(this);
        if (!contextLost) {
            gl.deleteFramebuffer(fbo.framebuffer);
            if (fbo.stencil) {
                gl.deleteRenderbuffer(fbo.stencil);
            }
        }
    }
    ;
    /**
     * Disposes all framebuffers, but not textures bound to them
     * @param {boolean} [contextLost=false] If context was lost, we suppress all delete function calls
     */
    disposeAll(contextLost) {
        var list = this.managedFramebuffers;
        this.managedFramebuffers = [];
        for (var i = 0; i < list.count; i++) {
            this.disposeFramebuffer(list[i], contextLost);
        }
    }
    ;
    /**
     * resets framebuffer stored state, binds screen framebuffer
     *
     * should be called before renderTexture reset()
     */
    reset() {
        this.current = this.unknownFramebuffer;
        this.viewport = new Rectangle_1.Rectangle();
    }
    ;
}
exports.FramebufferSystem = FramebufferSystem;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/GLBuffer.js":
/*!********************************************!*\
  !*** ./js-compile/raw-pixi-ts/GLBuffer.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class GLBuffer {
    constructor(buffer) {
        this.buffer = buffer;
        this.updateID = -1;
        this.byteLength = -1;
        this.refCount = 0;
    }
}
exports.GLBuffer = GLBuffer;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/GLProgram.js":
/*!*********************************************!*\
  !*** ./js-compile/raw-pixi-ts/GLProgram.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class GLProgram {
    constructor(program, uniformData) {
        /**
                 * The shader program
                 *
                 * @member {WebGLProgram}
                 */
        this.program = program;
        /**
         * holds the uniform data which contains uniform locations
         * and current uniform values used for caching and preventing unneeded GPU commands
         * @member {Object}
         */
        this.uniformData = uniformData;
        /**
         * uniformGroups holds the various upload functions for the shader. Each uniform group
         * and program have a unique upload function generated.
         * @member {Object}
         */
        this.uniformGroups = {};
    }
    /**
     * Destroys this program
     */
    destroy() {
        this.uniformData = null;
        this.uniformGroups = null;
        this.program = null;
    }
    ;
}
exports.GLProgram = GLProgram;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/GLTexture.js":
/*!*********************************************!*\
  !*** ./js-compile/raw-pixi-ts/GLTexture.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class GLTexture {
    constructor(texture) {
        /**
                 * The WebGL texture
                 * @member {WebGLTexture}
                 */
        this.texture = texture;
        this.width = -1;
        this.height = -1;
        /**
         * Texture contents dirty flag
         * @member {number}
         */
        this.dirtyId = -1;
        /**
         * Texture style dirty flag
         * @member {number}
         */
        this.dirtyStyleId = -1;
        /**
         * Whether mip levels has to be generated
         * @member {boolean}
         */
        this.mipmap = false;
        /**
         * WrapMode copied from baseTexture
         * @member {number}
         */
        this.wrapMode = 33071;
    }
}
exports.GLTexture = GLTexture;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/Geometry.js":
/*!********************************************!*\
  !*** ./js-compile/raw-pixi-ts/Geometry.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Attribute_1 = __webpack_require__(/*! ./Attribute */ "./js-compile/raw-pixi-ts/Attribute.js");
const Buffer_1 = __webpack_require__(/*! ./Buffer */ "./js-compile/raw-pixi-ts/Buffer.js");
const Runner_1 = __webpack_require__(/*! ./Runner */ "./js-compile/raw-pixi-ts/Runner.js");
class Geometry {
    constructor(buffers = [], attributes = {}) {
        this.buffers = buffers;
        this.indexBuffer = null;
        this.attributes = attributes;
        /**
         * A map of renderer IDs to webgl VAOs
         *
         * @protected
         * @type {object}
         */
        this.glVertexArrayObjects = {};
        this.id = Geometry.UID$1++;
        this.instanced = false;
        this.instanceCount = 1;
        this._size = null;
        this.disposeRunner = new Runner_1.Runner('disposeGeometry', 2);
        // this.disposeRunner = new Runner('disposeGeometry', 2);
        /**
         * Count of existing (not destroyed) meshes that reference this geometry
         * @member {boolean}
         */
        this.refCount = 0;
    }
    /**
    *
    * Adds an attribute to the geometry
    *
    * @param {String} id - the name of the attribute (matching up to a shader)
    * @param {PIXI.Buffer} [buffer] the buffer that holds the data of the attribute . You can also provide an Array and a buffer will be created from it.
    * @param {Number} [size=0] the size of the attribute. If you have 2 floats per vertex (eg position x and y) this would be 2
    * @param {Boolean} [normalized=false] should the data be normalized.
    * @param {Number} [type=PIXI.TYPES.FLOAT] what type of number is the attribute. Check {PIXI.TYPES} to see the ones available
    * @param {Number} [stride=0] How far apart (in floats) the start of each value is. (used for interleaving data)
    * @param {Number} [start=0] How far into the array to start reading values (used for interleaving data)
    *
    * @return {PIXI.Geometry} returns self, useful for chaining.
    */
    addAttribute(id, buffer, size = null, normalized = false, type = null, stride = undefined, start = undefined, instance = undefined) {
        if (!buffer) {
            throw new Error('You must pass a buffer when creating an attribute');
        }
        // check if this is a buffer!
        if (!buffer.data) {
            // its an array!
            if (buffer instanceof Array) {
                buffer = new Float32Array(buffer);
            }
            buffer = new Buffer_1.Buffer(buffer);
        }
        var ids = id.split('|');
        if (ids.length > 1) {
            for (var i = 0; i < ids.length; i++) {
                this.addAttribute(ids[i], buffer, size, normalized, type);
            }
            return this;
        }
        var bufferIndex = this.buffers.indexOf(buffer);
        if (bufferIndex === -1) {
            this.buffers.push(buffer);
            bufferIndex = this.buffers.length - 1;
        }
        this.attributes[id] = new Attribute_1.Attribute(bufferIndex, size, normalized, type, stride, start, instance);
        // assuming that if there is instanced data then this will be drawn with instancing!
        this.instanced = this.instanced || instance;
        return this;
    }
    ;
    /**
     * returns the requested attribute
     *
     * @param {String} id  the name of the attribute required
     * @return {PIXI.Attribute} the attribute requested.
     */
    getAttribute(id) {
        return this.buffers[this.attributes[id].buffer];
    }
    ;
    /**
    *
    * Adds an index buffer to the geometry
    * The index buffer contains integers, three for each triangle in the geometry, which reference the various attribute buffers (position, colour, UV coordinates, other UV coordinates, normal, …). There is only ONE index buffer.
    *
    * @param {PIXI.Buffer} [buffer] the buffer that holds the data of the index buffer. You can also provide an Array and a buffer will be created from it.
    * @return {PIXI.Geometry} returns self, useful for chaining.
    */
    addIndex(buffer) {
        if (!buffer.data) {
            // its an array!
            if (buffer instanceof Array) {
                buffer = new Uint16Array(buffer);
            }
            buffer = new Buffer_1.Buffer(buffer);
        }
        buffer.index = true;
        this.indexBuffer = buffer;
        if (this.buffers.indexOf(buffer) === -1) {
            this.buffers.push(buffer);
        }
        return this;
    }
    ;
    /**
     * returns the index buffer
     *
     * @return {PIXI.Buffer} the index buffer.
     */
    getIndex() {
        return this.indexBuffer;
    }
    ;
    /**
     * this function modifies the structure so that all current attributes become interleaved into a single buffer
     * This can be useful if your model remains static as it offers a little performance boost
     *
     * @return {PIXI.Geometry} returns self, useful for chaining.
     */
    interleave() {
        // a simple check to see if buffers are already interleaved..
        if (this.buffers.length === 1 || (this.buffers.length === 2 && this.indexBuffer)) {
            return this;
        }
        // assume already that no buffers are interleaved
        var arrays = [];
        var sizes = [];
        var interleavedBuffer = new Buffer_1.Buffer();
        var i;
        for (i in this.attributes) {
            var attribute = this.attributes[i];
            var buffer = this.buffers[attribute.buffer];
            arrays.push(buffer.data);
            sizes.push((attribute.size * Geometry.byteSizeMap[attribute.type]) / 4);
            attribute.buffer = 0;
        }
        interleavedBuffer.data = Geometry.interleaveTypedArrays(arrays, sizes);
        for (i = 0; i < this.buffers.length; i++) {
            if (this.buffers[i] !== this.indexBuffer) {
                this.buffers[i].destroy();
            }
        }
        this.buffers = [interleavedBuffer];
        if (this.indexBuffer) {
            this.buffers.push(this.indexBuffer);
        }
        return this;
    }
    ;
    getSize() {
        for (var i in this.attributes) {
            var attribute = this.attributes[i];
            var buffer = this.buffers[attribute.buffer];
            return buffer.data.length / ((attribute.stride / 4) || attribute.size);
        }
        return 0;
    }
    ;
    /**
     * disposes WebGL resources that are connected to this geometry
     */
    dispose() {
        // this.disposeRunner.run(this, false);
        this.disposeRunner.run(this, false);
    }
    ;
    /**
     * Destroys the geometry.
     */
    destroy(options = null) {
        this.dispose();
        this.buffers = null;
        this.indexBuffer.destroy();
        this.attributes = null;
    }
    ;
    /**
     * returns a clone of the geometry
     *
     * @returns {PIXI.Geometry} a new clone of this geometry
     */
    clone() {
        var geometry = new Geometry();
        for (var i = 0; i < this.buffers.length; i++) {
            geometry.buffers[i] = new Buffer_1.Buffer(this.buffers[i].data.slice());
        }
        for (var i$1 in this.attributes) {
            var attrib = this.attributes[i$1];
            geometry.attributes[i$1] = new Attribute_1.Attribute(attrib.buffer, attrib.size, attrib.normalized, attrib.type, attrib.stride, attrib.start, attrib.instance);
        }
        if (this.indexBuffer) {
            geometry.indexBuffer = geometry.buffers[this.buffers.indexOf(this.indexBuffer)];
            geometry.indexBuffer.index = true;
        }
        return geometry;
    }
    ;
    /**
     * merges an array of geometries into a new single one
     * geometry attribute styles must match for this operation to work
     *
     * @param {PIXI.Geometry[]} geometries array of geometries to merge
     * @returns {PIXI.Geometry} shiny new geometry!
     */
    static merge(geometries) {
        // todo add a geometry check!
        // also a size check.. cant be too big!]
        var geometryOut = new Geometry();
        var arrays = [];
        var sizes = [];
        var offsets = [];
        var geometry;
        // pass one.. get sizes..
        for (var i = 0; i < geometries.length; i++) {
            geometry = geometries[i];
            for (var j = 0; j < geometry.buffers.length; j++) {
                sizes[j] = sizes[j] || 0;
                sizes[j] += geometry.buffers[j].data.length;
                offsets[j] = 0;
            }
        }
        // build the correct size arrays..
        for (var i$1 = 0; i$1 < geometry.buffers.length; i$1++) {
            // TODO types!
            arrays[i$1] = new Geometry.map$1[Geometry.getBufferType(geometry.buffers[i$1].data)](sizes[i$1]);
            geometryOut.buffers[i$1] = new Buffer_1.Buffer(arrays[i$1]);
        }
        // pass to set data..
        for (var i$2 = 0; i$2 < geometries.length; i$2++) {
            geometry = geometries[i$2];
            for (var j$1 = 0; j$1 < geometry.buffers.length; j$1++) {
                arrays[j$1].set(geometry.buffers[j$1].data, offsets[j$1]);
                offsets[j$1] += geometry.buffers[j$1].data.length;
            }
        }
        geometryOut.attributes = geometry.attributes;
        if (geometry.indexBuffer) {
            geometryOut.indexBuffer = geometryOut.buffers[geometry.buffers.indexOf(geometry.indexBuffer)];
            geometryOut.indexBuffer.index = true;
            var offset = 0;
            var stride = 0;
            var offset2 = 0;
            var bufferIndexToCount = 0;
            // get a buffer
            for (var i$3 = 0; i$3 < geometry.buffers.length; i$3++) {
                if (geometry.buffers[i$3] !== geometry.indexBuffer) {
                    bufferIndexToCount = i$3;
                    break;
                }
            }
            // figure out the stride of one buffer..
            for (var i$4 in geometry.attributes) {
                var attribute = geometry.attributes[i$4];
                if ((attribute.buffer | 0) === bufferIndexToCount) {
                    stride += ((attribute.size * Geometry.byteSizeMap[attribute.type]) / 4);
                }
            }
            // time to off set all indexes..
            for (var i$5 = 0; i$5 < geometries.length; i$5++) {
                var indexBufferData = geometries[i$5].indexBuffer.data;
                for (var j$2 = 0; j$2 < indexBufferData.length; j$2++) {
                    geometryOut.indexBuffer.data[j$2 + offset2] += offset;
                }
                offset += geometry.buffers[bufferIndexToCount].data.length / (stride);
                offset2 += indexBufferData.length;
            }
        }
        return geometryOut;
    }
    ;
    static getBufferType(array) {
        if (array.BYTES_PER_ELEMENT === 4) {
            if (array instanceof Float32Array) {
                return 'Float32Array';
            }
            else if (array instanceof Uint32Array) {
                return 'Uint32Array';
            }
            return 'Int32Array';
        }
        else if (array.BYTES_PER_ELEMENT === 2) {
            if (array instanceof Uint16Array) {
                return 'Uint16Array';
            }
        }
        else if (array.BYTES_PER_ELEMENT === 1) {
            if (array instanceof Uint8Array) {
                return 'Uint8Array';
            }
        }
        // TODO map out the rest of the array elements!
        return null;
    }
    static interleaveTypedArrays(arrays, sizes) {
        var outSize = 0;
        var stride = 0;
        var views = {};
        for (var i = 0; i < arrays.length; i++) {
            stride += sizes[i];
            outSize += arrays[i].length;
        }
        var buffer = new ArrayBuffer(outSize * 4);
        var out = null;
        var littleOffset = 0;
        for (var i$1 = 0; i$1 < arrays.length; i$1++) {
            var size = sizes[i$1];
            var array = arrays[i$1];
            var type = Geometry.getBufferType(array);
            if (!views[type]) {
                views[type] = new Geometry.map[type](buffer);
            }
            out = views[type];
            for (var j = 0; j < array.length; j++) {
                var indexStart = ((j / size | 0) * stride) + littleOffset;
                var index = j % size;
                out[indexStart + index] = array[j];
            }
            littleOffset += size;
        }
        return new Float32Array(buffer);
    }
}
/* eslint-disable object-shorthand */
Geometry.map = {
    Float32Array: Float32Array,
    Uint32Array: Uint32Array,
    Int32Array: Int32Array,
    Uint8Array: Uint8Array,
};
Geometry.UID$1 = 0;
/* eslint-disable object-shorthand */
Geometry.map$1 = {
    Float32Array: Float32Array,
    Uint32Array: Uint32Array,
    Int32Array: Int32Array,
    Uint8Array: Uint8Array,
    Uint16Array: Uint16Array,
};
Geometry.byteSizeMap = { 5126: 4, 5123: 2, 5121: 1 };
exports.Geometry = Geometry;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/GeometrySystem.js":
/*!**************************************************!*\
  !*** ./js-compile/raw-pixi-ts/GeometrySystem.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const System_1 = __webpack_require__(/*! ./System */ "./js-compile/raw-pixi-ts/System.js");
const GLBuffer_1 = __webpack_require__(/*! ./GLBuffer */ "./js-compile/raw-pixi-ts/GLBuffer.js");
const DisplaySettings_1 = __webpack_require__(/*! ./DisplaySettings */ "./js-compile/raw-pixi-ts/DisplaySettings.js");
class GeometrySystem extends System_1.System {
    constructor(renderer) {
        super(renderer);
        this._activeGeometry = null;
        this._activeVao = null;
        /**
         * `true` if we has `*_vertex_array_object` extension
         * @member {boolean}
         * @readonly
         */
        this.hasVao = true;
        /**
         * `true` if has `ANGLE_instanced_arrays` extension
         * @member {boolean}
         * @readonly
         */
        this.hasInstance = true;
        /**
         * A cache of currently bound buffer,
         * contains only two members with keys ARRAY_BUFFER and ELEMENT_ARRAY_BUFFER
         * @member {Object.<number, PIXI.Buffer>}
         * @readonly
         */
        this.boundBuffers = {};
        /**
         * Cache for all geometries by id, used in case renderer gets destroyed or for profiling
         * @member {object}
         * @readonly
         */
        this.managedGeometries = {};
        /**
         * Cache for all buffers by id, used in case renderer gets destroyed or for profiling
         * @member {object}
         * @readonly
         */
        this.managedBuffers = {};
    }
    /**
     * Sets up the renderer context and necessary buffers.
     */
    contextChange() {
        this.disposeAll(true);
        var gl = this.gl = this.renderer.gl;
        this.CONTEXT_UID = this.renderer.CONTEXT_UID;
        // webgl2
        if (!gl.createVertexArray) {
            // webgl 1!
            var nativeVaoExtension = this.renderer.context.extensions.vertexArrayObject;
            if (DisplaySettings_1.DisplaySettings.PREFER_ENV === DisplaySettings_1.DisplaySettings.ENV.WEBGL_LEGACY) {
                nativeVaoExtension = null;
            }
            if (nativeVaoExtension) {
                gl.createVertexArray = function () { return nativeVaoExtension.createVertexArrayOES(); };
                gl.bindVertexArray = function (vao) { return nativeVaoExtension.bindVertexArrayOES(vao); };
                gl.deleteVertexArray = function (vao) { return nativeVaoExtension.deleteVertexArrayOES(vao); };
            }
            else {
                this.hasVao = false;
                gl.createVertexArray = function () {
                    // empty
                };
                gl.bindVertexArray = function () {
                    // empty
                };
                gl.deleteVertexArray = function () {
                    // empty
                };
            }
        }
        if (!gl.vertexAttribDivisor) {
            var instanceExt = gl.getExtension('ANGLE_instanced_arrays');
            if (instanceExt) {
                gl.vertexAttribDivisor = function (a, b) { return instanceExt.vertexAttribDivisorANGLE(a, b); };
                gl.drawElementsInstanced = function (a, b, c, d, e) { return instanceExt.drawElementsInstancedANGLE(a, b, c, d, e); };
                gl.drawArraysInstanced = function (a, b, c, d) { return instanceExt.drawArraysInstancedANGLE(a, b, c, d); };
            }
            else {
                this.hasInstance = false;
            }
        }
    }
    ;
    /**
     * Binds geometry so that is can be drawn. Creating a Vao if required
     * @protected
     * @param {PIXI.Geometry} geometry instance of geometry to bind
     * @param {PIXI.Shader} shader instance of shader to bind
     */
    bind(geometry, shader = null) {
        shader = shader || this.renderer.shader.shader;
        var ref = this;
        var gl = ref.gl;
        // not sure the best way to address this..
        // currently different shaders require different VAOs for the same geometry
        // Still mulling over the best way to solve this one..
        // will likely need to modify the shader attribute locations at run time!
        var vaos = geometry.glVertexArrayObjects[this.CONTEXT_UID];
        if (!vaos) {
            this.managedGeometries[geometry.id] = geometry;
            // geometry.disposeRunner.add(this);
            geometry.glVertexArrayObjects[this.CONTEXT_UID] = vaos = {};
        }
        var vao = vaos[shader.program.id] || this.initGeometryVao(geometry, shader.program);
        this._activeGeometry = geometry;
        if (this._activeVao !== vao) {
            this._activeVao = vao;
            if (this.hasVao) {
                gl.bindVertexArray(vao);
            }
            else {
                this.activateVao(geometry, shader.program);
            }
        }
        // TODO - optimise later!
        // don't need to loop through if nothing changed!
        // maybe look to add an 'autoupdate' to geometry?
        this.updateBuffers();
    }
    ;
    /**
     * Reset and unbind any active VAO and geometry
     */
    reset() {
        this.unbind();
    }
    ;
    /**
     * Update buffers
     * @protected
     */
    updateBuffers() {
        var geometry = this._activeGeometry;
        var ref = this;
        var gl = ref.gl;
        // reveal(gl);
        for (var i = 0; i < geometry.buffers.length; i++) {
            var buffer = geometry.buffers[i];
            var glBuffer = buffer._glBuffers[this.CONTEXT_UID];
            if (buffer._updateID !== glBuffer.updateID) {
                glBuffer.updateID = buffer._updateID;
                // TODO can cache this on buffer! maybe added a getter / setter?
                var type = buffer.index ? gl.ELEMENT_ARRAY_BUFFER : gl.ARRAY_BUFFER;
                // TODO this could change if the VAO changes...
                // need to come up with a better way to cache..
                // if (this.boundBuffers[type] !== glBuffer)
                // {
                // this.boundBuffers[type] = glBuffer;
                gl.bindBuffer(type, glBuffer.buffer);
                // }
                this._boundBuffer = glBuffer;
                if (glBuffer.byteLength >= buffer.data.byteLength) {
                    // offset is always zero for now!
                    gl.bufferSubData(type, 0, buffer.data);
                }
                else {
                    var drawType = buffer.static ? gl.STATIC_DRAW : gl.DYNAMIC_DRAW;
                    glBuffer.byteLength = buffer.data.byteLength;
                    gl.bufferData(type, buffer.data, drawType);
                }
            }
        }
    }
    ;
    /**
     * Check compability between a geometry and a program
     * @protected
     * @param {PIXI.Geometry} geometry - Geometry instance
     * @param {PIXI.Program} program - Program instance
     */
    checkCompatibility(geometry, program) {
        // geometry must have at least all the attributes that the shader requires.
        var geometryAttributes = geometry.attributes;
        var shaderAttributes = program.attributeData;
        for (var j in shaderAttributes) {
            if (!geometryAttributes[j]) {
                throw new Error(("shader and geometry incompatible, geometry missing the \"" + j + "\" attribute"));
            }
        }
    }
    ;
    /**
     * Takes a geometry and program and generates a unique signature for them.
     *
     * @param {PIXI.Geometry} geometry to get signature from
     * @param {PIXI.Program} program to test geometry against
     * @returns {String} Unique signature of the geometry and program
     * @protected
     */
    getSignature(geometry, program) {
        var attribs = geometry.attributes;
        var shaderAttributes = program.attributeData;
        var strings = ['g', geometry.id];
        for (var i in attribs) {
            if (shaderAttributes[i]) {
                strings.push(i);
            }
        }
        return strings.join('-');
    }
    ;
    /**
     * Creates or gets Vao with the same structure as the geometry and stores it on the geometry.
     * If vao is created, it is bound automatically.
     *
     * @protected
     * @param {PIXI.Geometry} geometry - Instance of geometry to to generate Vao for
     * @param {PIXI.Program} program - Instance of program
     */
    initGeometryVao(geometry, program) {
        this.checkCompatibility(geometry, program);
        var gl = this.gl;
        var CONTEXT_UID = this.CONTEXT_UID;
        var signature = this.getSignature(geometry, program);
        var vaoObjectHash = geometry.glVertexArrayObjects[this.CONTEXT_UID];
        var vao = vaoObjectHash[signature];
        if (vao) {
            // this will give us easy access to the vao
            vaoObjectHash[program.id] = vao;
            return vao;
        }
        var buffers = geometry.buffers;
        var attributes = geometry.attributes;
        var tempStride = {};
        var tempStart = {};
        for (var j in buffers) {
            tempStride[j] = 0;
            tempStart[j] = 0;
        }
        for (var j$1 in attributes) {
            if (!attributes[j$1].size && program.attributeData[j$1]) {
                attributes[j$1].size = program.attributeData[j$1].size;
            }
            else if (!attributes[j$1].size) {
                console.warn(("PIXI Geometry attribute '" + j$1 + "' size cannot be determined (likely the bound shader does not have the attribute)")); // eslint-disable-line
            }
            tempStride[attributes[j$1].buffer] += attributes[j$1].size * GeometrySystem.byteSizeMap$1[attributes[j$1].type];
        }
        for (var j$2 in attributes) {
            var attribute = attributes[j$2];
            var attribSize = attribute.size;
            if (attribute.stride === undefined) {
                if (tempStride[attribute.buffer] === attribSize * GeometrySystem.byteSizeMap$1[attribute.type]) {
                    attribute.stride = 0;
                }
                else {
                    attribute.stride = tempStride[attribute.buffer];
                }
            }
            if (attribute.start === undefined) {
                attribute.start = tempStart[attribute.buffer];
                tempStart[attribute.buffer] += attribSize * GeometrySystem.byteSizeMap$1[attribute.type];
            }
        }
        vao = gl.createVertexArray();
        gl.bindVertexArray(vao);
        // first update - and create the buffers!
        // only create a gl buffer if it actually gets
        for (var i = 0; i < buffers.length; i++) {
            var buffer = buffers[i];
            if (!buffer._glBuffers[CONTEXT_UID]) {
                buffer._glBuffers[CONTEXT_UID] = new GLBuffer_1.GLBuffer(gl.createBuffer());
                this.managedBuffers[buffer.id] = buffer;
                // buffer.disposeRunner.add(this);
            }
            buffer._glBuffers[CONTEXT_UID].refCount++;
        }
        // TODO - maybe make this a data object?
        // lets wait to see if we need to first!
        this.activateVao(geometry, program);
        this._activeVao = vao;
        // add it to the cache!
        vaoObjectHash[program.id] = vao;
        vaoObjectHash[signature] = vao;
        return vao;
    }
    ;
    /**
     * Disposes buffer
     * @param {PIXI.Buffer} buffer buffer with data
     * @param {boolean} [contextLost=false] If context was lost, we suppress deleteVertexArray
     */
    disposeBuffer(buffer, contextLost) {
        if (!this.managedBuffers[buffer.id]) {
            return;
        }
        delete this.managedBuffers[buffer.id];
        var glBuffer = buffer._glBuffers[this.CONTEXT_UID];
        var gl = this.gl;
        // buffer.disposeRunner.remove(this);
        if (!glBuffer) {
            return;
        }
        if (!contextLost) {
            gl.deleteBuffer(glBuffer.buffer);
        }
        delete buffer._glBuffers[this.CONTEXT_UID];
    }
    ;
    /**
     * Disposes geometry
     * @param {PIXI.Geometry} geometry Geometry with buffers. Only VAO will be disposed
     * @param {boolean} [contextLost=false] If context was lost, we suppress deleteVertexArray
     */
    disposeGeometry(geometry, contextLost) {
        if (!this.managedGeometries[geometry.id]) {
            return;
        }
        delete this.managedGeometries[geometry.id];
        var vaos = geometry.glVertexArrayObjects[this.CONTEXT_UID];
        var gl = this.gl;
        var buffers = geometry.buffers;
        geometry.disposeRunner.remove(this);
        if (!vaos) {
            return;
        }
        for (var i = 0; i < buffers.length; i++) {
            var buf = buffers[i]._glBuffers[this.CONTEXT_UID];
            buf.refCount--;
            if (buf.refCount === 0 && !contextLost) {
                this.disposeBuffer(buffers[i], contextLost);
            }
        }
        if (!contextLost) {
            for (var vaoId in vaos) {
                // delete only signatures, everything else are copies
                if (vaoId[0] === 'g') {
                    var vao = vaos[vaoId];
                    if (this._activeVao === vao) {
                        this.unbind();
                    }
                    gl.deleteVertexArray(vao);
                }
            }
        }
        delete geometry.glVertexArrayObjects[this.CONTEXT_UID];
    }
    ;
    /**
     * dispose all WebGL resources of all managed geometries and buffers
     * @param {boolean} [contextLost=false] If context was lost, we suppress `gl.delete` calls
     */
    disposeAll(contextLost) {
        var all = Object.keys(this.managedGeometries);
        for (var i = 0; i < all.length; i++) {
            this.disposeGeometry(this.managedGeometries[all[i]], contextLost);
        }
        all = Object.keys(this.managedBuffers);
        for (var i$1 = 0; i$1 < all.length; i$1++) {
            this.disposeBuffer(this.managedBuffers[all[i$1]], contextLost);
        }
    }
    ;
    /**
     * Activate vertex array object
     *
     * @protected
     * @param {PIXI.Geometry} geometry - Geometry instance
     * @param {PIXI.Program} program - Shader program instance
     */
    activateVao(geometry, program) {
        var gl = this.gl;
        var CONTEXT_UID = this.CONTEXT_UID;
        var buffers = geometry.buffers;
        var attributes = geometry.attributes;
        if (geometry.indexBuffer) {
            // first update the index buffer if we have one..
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, geometry.indexBuffer._glBuffers[CONTEXT_UID].buffer);
        }
        var lastBuffer = null;
        // add a new one!
        for (var j in attributes) {
            var attribute = attributes[j];
            var buffer = buffers[attribute.buffer];
            var glBuffer = buffer._glBuffers[CONTEXT_UID];
            if (program.attributeData[j]) {
                if (lastBuffer !== glBuffer) {
                    gl.bindBuffer(gl.ARRAY_BUFFER, glBuffer.buffer);
                    lastBuffer = glBuffer;
                }
                var location = program.attributeData[j].location;
                // TODO introduce state again
                // we can optimise this for older devices that have no VAOs
                gl.enableVertexAttribArray(location);
                gl.vertexAttribPointer(location, attribute.size, attribute.type || gl.FLOAT, attribute.normalized, attribute.stride, attribute.start);
                if (attribute.instance) {
                    // TODO calculate instance count based of this...
                    if (this.hasInstance) {
                        gl.vertexAttribDivisor(location, 1);
                    }
                    else {
                        throw new Error('geometry error, GPU Instancing is not supported on this device');
                    }
                }
            }
        }
    }
    ;
    /**
     * Draw the geometry
     *
     * @param {Number} type - the type primitive to render
     * @param {Number} [size] - the number of elements to be rendered
     * @param {Number} [start] - Starting index
     * @param {Number} [instanceCount] - the number of instances of the set of elements to execute
     */
    draw(type, size = -1, start = 0, instanceCount = 1) {
        var ref = this;
        var gl = ref.gl;
        var geometry = this._activeGeometry;
        // TODO.. this should not change so maybe cache the function?
        if (size < 0) {
            size = geometry.indexBuffer.data.length;
        }
        if (geometry.indexBuffer) {
            if (geometry.instanced) {
                /* eslint-disable max-len */
                gl.drawElementsInstanced(type, size || geometry.indexBuffer.data.length, gl.UNSIGNED_SHORT, (start || 0) * 2, instanceCount || 1);
                /* eslint-enable max-len */
            }
            else {
                gl.drawElements(type, size || geometry.indexBuffer.data.length, gl.UNSIGNED_SHORT, (start || 0) * 2);
            }
        }
        else if (geometry.instanced) {
            // TODO need a better way to calculate size..
            gl.drawArraysInstanced(type, start, size || geometry.getSize(), instanceCount || 1);
        }
        else {
            gl.drawArrays(type, start, size || geometry.getSize());
        }
        return this;
    }
    ;
    /**
     * Unbind/reset everything
     * @protected
     */
    unbind() {
        this.gl.bindVertexArray(null);
        this._activeVao = null;
        this._activeGeometry = null;
    }
    ;
}
GeometrySystem.byteSizeMap$1 = { 5126: 4, 5123: 2, 5121: 1 };
exports.GeometrySystem = GeometrySystem;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/Graphics.js":
/*!********************************************!*\
  !*** ./js-compile/raw-pixi-ts/Graphics.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Container_1 = __webpack_require__(/*! ./Container */ "./js-compile/raw-pixi-ts/Container.js");
const State_1 = __webpack_require__(/*! ./State */ "./js-compile/raw-pixi-ts/State.js");
const FillStyle_1 = __webpack_require__(/*! ./FillStyle */ "./js-compile/raw-pixi-ts/FillStyle.js");
// import { settings } from "./settings";
const Texture_1 = __webpack_require__(/*! ./Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const Rectangle_1 = __webpack_require__(/*! ./Rectangle */ "./js-compile/raw-pixi-ts/Rectangle.js");
const Matrix_1 = __webpack_require__(/*! ./Matrix */ "./js-compile/raw-pixi-ts/Matrix.js");
const UniformGroup_1 = __webpack_require__(/*! ./UniformGroup */ "./js-compile/raw-pixi-ts/UniformGroup.js");
const Shader_1 = __webpack_require__(/*! ./Shader */ "./js-compile/raw-pixi-ts/Shader.js");
const Point_1 = __webpack_require__(/*! ./Point */ "./js-compile/raw-pixi-ts/Point.js");
const Polygon_1 = __webpack_require__(/*! ./Polygon */ "./js-compile/raw-pixi-ts/Polygon.js");
const Ellipse_1 = __webpack_require__(/*! ./Ellipse */ "./js-compile/raw-pixi-ts/Ellipse.js");
const Circle_1 = __webpack_require__(/*! ./Circle */ "./js-compile/raw-pixi-ts/Circle.js");
const RoundedRectangle_1 = __webpack_require__(/*! ./RoundedRectangle */ "./js-compile/raw-pixi-ts/RoundedRectangle.js");
const ArcUtils_1 = __webpack_require__(/*! ./ArcUtils */ "./js-compile/raw-pixi-ts/ArcUtils.js");
const BezierUtils_1 = __webpack_require__(/*! ./BezierUtils */ "./js-compile/raw-pixi-ts/BezierUtils.js");
const QuadraticUtils_1 = __webpack_require__(/*! ./QuadraticUtils */ "./js-compile/raw-pixi-ts/QuadraticUtils.js");
const LineStyle_1 = __webpack_require__(/*! ./LineStyle */ "./js-compile/raw-pixi-ts/LineStyle.js");
const GraphicsGeometry_1 = __webpack_require__(/*! ./GraphicsGeometry */ "./js-compile/raw-pixi-ts/GraphicsGeometry.js");
const Star_1 = __webpack_require__(/*! ./Star */ "./js-compile/raw-pixi-ts/Star.js");
const MathSettings_1 = __webpack_require__(/*! ./MathSettings */ "./js-compile/raw-pixi-ts/MathSettings.js");
const BlendModesSettings_1 = __webpack_require__(/*! ./BlendModesSettings */ "./js-compile/raw-pixi-ts/BlendModesSettings.js");
const ColorSettings_1 = __webpack_require__(/*! ./ColorSettings */ "./js-compile/raw-pixi-ts/ColorSettings.js");
class Graphics extends Container_1.Container {
    constructor(geometry = null) {
        super();
        if (geometry === void 0) {
            geometry = null;
        }
        /**
         * Includes vertex positions, face indices, normals, colors, UVs, and
         * custom attributes within buffers, reducing the cost of passing all
         * this data to the GPU. Can be shared between multiple Mesh or Graphics objects.
         * @member {PIXI.GraphicsGeometry}
         * @readonly
         */
        this.geometry = geometry || new GraphicsGeometry_1.GraphicsGeometry();
        this.geometry.refCount++;
        /**
         * Represents the vertex and fragment shaders that processes the geometry and runs on the GPU.
         * Can be shared between multiple Graphics objects.
         * @member {PIXI.Shader}
         */
        this.shader = null;
        /**
         * Represents the WebGL state the Graphics required to render, excludes shader and geometry. E.g.,
         * blend mode, culling, depth testing, direction of rendering triangles, backface, etc.
         * @member {PIXI.State}
         */
        this.state = State_1.State.for2d();
        /**
         * Current fill style
         *
         * @member {PIXI.FillStyle}
         * @protected
         */
        this._fillStyle = new FillStyle_1.FillStyle();
        /**
         * Current line style
         *
         * @member {PIXI.LineStyle}
         * @protected
         */
        this._lineStyle = new LineStyle_1.LineStyle();
        /**
         * Current shape transform matrix.
         *
         * @member {PIXI.Matrix}
         * @protected
         */
        this._matrix = null;
        /**
         * Current hole mode is enabled.
         *
         * @member {boolean}
         * @default false
         * @protected
         */
        this._holeMode = false;
        /**
         * Current path
         *
         * @member {PIXI.Polygon}
         * @protected
         */
        this.currentPath = null;
        /**
         * When cacheAsBitmap is set to true the graphics object will be rendered as if it was a sprite.
         * This is useful if your graphics element does not change often, as it will speed up the rendering
         * of the object in exchange for taking up texture memory. It is also useful if you need the graphics
         * object to be anti-aliased, because it will be rendered using canvas. This is not recommended if
         * you are constantly redrawing the graphics element.
         *
         * @name cacheAsBitmap
         * @member {boolean}
         * @memberof PIXI.Graphics#
         * @default false
         */
        /**
         * A collections of batches! These can be drawn by the renderer batch system.
         *
         * @protected
         * @member {object[]}
         */
        this.batches = [];
        /**
         * Update dirty for limiting calculating tints for batches.
         *
         * @protected
         * @member {number}
         * @default -1
         */
        this.batchTint = -1;
        /**
         * Copy of the object vertex data.
         *
         * @protected
         * @member {Float32Array}
         */
        this.vertexData = null;
        this._transformID = -1;
        this.batchDirty = -1;
        // Set default
        this.tint = 0xFFFFFF;
        this.blendMode = BlendModesSettings_1.BlendModesSettings.BLEND_MODES.NORMAL;
    }
    /**
     * Creates a new Graphics object with the same values as this one.
     * Note that the only the properties of the object are cloned, not its transform (position,scale,etc)
     *
     * @return {PIXI.Graphics} A clone of the graphics object
     */
    clone() {
        this.finishPoly();
        return new Graphics(this.geometry);
    }
    ;
    /**
     * The blend mode to be applied to the graphic shape. Apply a value of
     * `PIXI.BLEND_MODES.NORMAL` to reset the blend mode.
     *
     * @member {number}
     * @default PIXI.BLEND_MODES.NORMAL;
     * @see PIXI.BLEND_MODES
     */
    set blendMode(value) {
        this.state.blendMode = value;
    }
    ;
    get blendMode() {
        return this.state.blendMode;
    }
    ;
    /**
     * The tint applied to the graphic shape. This is a hex value. A value of
     * 0xFFFFFF will remove any tint effect.
     *
     * @member {number}
     * @default 0xFFFFFF
     */
    get tint() {
        return this._tint;
    }
    ;
    set tint(value) {
        this._tint = value;
    }
    ;
    /**
     * The current fill style.
     *
     * @member {PIXI.FillStyle}
     * @readonly
     */
    get fill() {
        return this._fillStyle;
    }
    ;
    /**
     * The current line style.
     *
     * @member {PIXI.LineStyle}
     * @readonly
     */
    get line() {
        return this._lineStyle;
    }
    ;
    /**
     * Specifies the line style used for subsequent calls to Graphics methods such as the lineTo()
     * method or the drawCircle() method.
     *
     * @param {number} [width=0] - width of the line to draw, will update the objects stored style
     * @param {number} [color=0] - color of the line to draw, will update the objects stored style
     * @param {number} [alpha=1] - alpha of the line to draw, will update the objects stored style
     * @param {number} [alignment=1] - alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outter)
     * @param {boolean} [native=false] - If true the lines will be draw using LINES instead of TRIANGLE_STRIP
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */
    lineStyle(width, color = 0, alpha = 1, alignment = 0.5, native = false) {
        if (width === void 0) {
            width = 0;
        }
        if (color === void 0) {
            color = 0;
        }
        if (alpha === void 0) {
            alpha = 1;
        }
        if (alignment === void 0) {
            alignment = 0.5;
        }
        if (native === void 0) {
            native = false;
        }
        this.lineTextureStyle(width, Texture_1.Texture.WHITE, color, alpha, null, alignment, native);
        return this;
    }
    ;
    /**
     * Like line style but support texture for line fill.
     *
     * @param {number} [width=0] - width of the line to draw, will update the objects stored style
     * @param {PIXI.Texture} [texture=PIXI.Texture.WHITE] - Texture to use
     * @param {number} [color=0] - color of the line to draw, will update the objects stored style
     * @param {number} [alpha=1] - alpha of the line to draw, will update the objects stored style
     * @param {PIXI.Matrix} [matrix=null] Texture matrix to transform texture
     * @param {number} [alignment=0.5] - alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outter)
     * @param {boolean} [native=false] - If true the lines will be draw using LINES instead of TRIANGLE_STRIP
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */
    lineTextureStyle(width = 0, texture = Texture_1.Texture.WHITE, color = 0xFFFFFF, alpha = 1, matrix = null, alignment = 0.5, native = false) {
        if (width === void 0) {
            width = 0;
        }
        if (texture === void 0) {
            texture = Texture_1.Texture.WHITE;
        }
        if (color === void 0) {
            color = 0xFFFFFF;
        }
        if (alpha === void 0) {
            alpha = 1;
        }
        if (matrix === void 0) {
            matrix = null;
        }
        if (alignment === void 0) {
            alignment = 0.5;
        }
        if (native === void 0) {
            native = false;
        }
        if (this.currentPath) {
            this.startPoly();
        }
        var visible = width > 0 && alpha > 0;
        if (!visible) {
            this._lineStyle.reset();
        }
        else {
            if (matrix) {
                matrix = matrix.clone();
                matrix.invert();
            }
            Object.assign(this._lineStyle, {
                color: color,
                width: width,
                alpha: alpha,
                matrix: matrix,
                texture: texture,
                alignment: alignment,
                native: native,
                visible: visible,
            });
        }
        return this;
    }
    ;
    /**
     * Start a polygon object internally
     * @protected
     */
    startPoly() {
        if (this.currentPath) {
            var points = this.currentPath.points;
            var len = this.currentPath.points.length;
            if (len > 2) {
                this.drawShape(this.currentPath);
                this.currentPath = new Polygon_1.Polygon();
                this.currentPath.closeStroke = false;
                this.currentPath.points.push(points[len - 2], points[len - 1]);
            }
        }
        else {
            this.currentPath = new Polygon_1.Polygon();
            this.currentPath.closeStroke = false;
        }
    }
    ;
    /**
     * Finish the polygon object.
     * @protected
     */
    finishPoly() {
        if (this.currentPath) {
            if (this.currentPath.points.length > 2) {
                this.drawShape(this.currentPath);
                this.currentPath = null;
            }
            else {
                this.currentPath.points.length = 0;
            }
        }
    }
    ;
    /**
     * Moves the current drawing position to x, y.
     *
     * @param {number} x - the X coordinate to move to
     * @param {number} y - the Y coordinate to move to
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */
    moveTo(x, y) {
        this.startPoly();
        this.currentPath.points[0] = x;
        this.currentPath.points[1] = y;
        return this;
    }
    ;
    /**
     * Draws a line using the current line style from the current drawing position to (x, y);
     * The current drawing position is then set to (x, y).
     *
     * @param {number} x - the X coordinate to draw to
     * @param {number} y - the Y coordinate to draw to
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */
    lineTo(x, y) {
        if (!this.currentPath) {
            this.moveTo(0, 0);
        }
        // remove duplicates..
        var points = this.currentPath.points;
        var fromX = points[points.length - 2];
        var fromY = points[points.length - 1];
        if (fromX !== x || fromY !== y) {
            points.push(x, y);
        }
        return this;
    }
    ;
    /**
     * Initialize the curve
     *
     * @protected
     * @param {number} [x=0]
     * @param {number} [y=0]
     */
    _initCurve(x = 0, y = 0) {
        if (x === void 0) {
            x = 0;
        }
        if (y === void 0) {
            y = 0;
        }
        if (this.currentPath) {
            if (this.currentPath.points.length === 0) {
                this.currentPath.points = [x, y];
            }
        }
        else {
            this.moveTo(x, y);
        }
    }
    ;
    /**
     * Calculate the points for a quadratic bezier curve and then draws it.
     * Based on: https://stackoverflow.com/questions/785097/how-do-i-implement-a-bezier-curve-in-c
     *
     * @param {number} cpX - Control point x
     * @param {number} cpY - Control point y
     * @param {number} toX - Destination point x
     * @param {number} toY - Destination point y
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */
    quadraticCurveTo(cpX, cpY, toX, toY) {
        this._initCurve();
        var points = this.currentPath.points;
        if (points.length === 0) {
            this.moveTo(0, 0);
        }
        QuadraticUtils_1.QuadraticUtils.curveTo(cpX, cpY, toX, toY, points);
        return this;
    }
    ;
    /**
     * Calculate the points for a bezier curve and then draws it.
     *
     * @param {number} cpX - Control point x
     * @param {number} cpY - Control point y
     * @param {number} cpX2 - Second Control point x
     * @param {number} cpY2 - Second Control point y
     * @param {number} toX - Destination point x
     * @param {number} toY - Destination point y
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */
    bezierCurveTo(cpX, cpY, cpX2, cpY2, toX, toY) {
        this._initCurve();
        BezierUtils_1.BezierUtils.curveTo(cpX, cpY, cpX2, cpY2, toX, toY, this.currentPath.points);
        return this;
    }
    ;
    /**
     * The arcTo() method creates an arc/curve between two tangents on the canvas.
     *
     * "borrowed" from https://code.google.com/p/fxcanvas/ - thanks google!
     *
     * @param {number} x1 - The x-coordinate of the beginning of the arc
     * @param {number} y1 - The y-coordinate of the beginning of the arc
     * @param {number} x2 - The x-coordinate of the end of the arc
     * @param {number} y2 - The y-coordinate of the end of the arc
     * @param {number} radius - The radius of the arc
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */
    arcTo(x1, y1, x2, y2, radius) {
        this._initCurve(x1, y1);
        var points = this.currentPath.points;
        var result = ArcUtils_1.ArcUtils.curveTo(x1, y1, x2, y2, radius, points);
        if (result) {
            var cx = result.cx;
            var cy = result.cy;
            var radius$1 = result.radius;
            var startAngle = result.startAngle;
            var endAngle = result.endAngle;
            var anticlockwise = result.anticlockwise;
            this.arc(cx, cy, radius$1, startAngle, endAngle, anticlockwise);
        }
        return this;
    }
    ;
    /**
     * The arc method creates an arc/curve (used to create circles, or parts of circles).
     *
     * @param {number} cx - The x-coordinate of the center of the circle
     * @param {number} cy - The y-coordinate of the center of the circle
     * @param {number} radius - The radius of the circle
     * @param {number} startAngle - The starting angle, in radians (0 is at the 3 o'clock position
     *  of the arc's circle)
     * @param {number} endAngle - The ending angle, in radians
     * @param {boolean} [anticlockwise=false] - Specifies whether the drawing should be
     *  counter-clockwise or clockwise. False is default, and indicates clockwise, while true
     *  indicates counter-clockwise.
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */
    arc(cx, cy, radius, startAngle, endAngle, anticlockwise = false) {
        if (anticlockwise === void 0) {
            anticlockwise = false;
        }
        if (startAngle === endAngle) {
            return this;
        }
        if (!anticlockwise && endAngle <= startAngle) {
            endAngle += MathSettings_1.MathSettings.PI_2;
        }
        else if (anticlockwise && startAngle <= endAngle) {
            startAngle += MathSettings_1.MathSettings.PI_2;
        }
        var sweep = endAngle - startAngle;
        if (sweep === 0) {
            return this;
        }
        var startX = cx + (Math.cos(startAngle) * radius);
        var startY = cy + (Math.sin(startAngle) * radius);
        // If the currentPath exists, take its points. Otherwise call `moveTo` to start a path.
        var points = this.currentPath ? this.currentPath.points : null;
        if (points) {
            // TODO: make a better fix.
            // We check how far our start is from the last existing point
            var xDiff = Math.abs(points[points.length - 2] - startX);
            var yDiff = Math.abs(points[points.length - 1] - startY);
            if (xDiff < 0.001 && yDiff < 0.001) {
                ;
            }
            else {
                points.push(startX, startY);
            }
        }
        else {
            this.moveTo(startX, startY);
            points = this.currentPath.points;
        }
        ArcUtils_1.ArcUtils.arc(startX, startY, cx, cy, radius, startAngle, endAngle, anticlockwise, points);
        return this;
    }
    ;
    /**
     * Specifies a simple one-color fill that subsequent calls to other Graphics methods
     * (such as lineTo() or drawCircle()) use when drawing.
     *
     * @param {number} [color=0] - the color of the fill
     * @param {number} [alpha=1] - the alpha of the fill
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */
    beginFill(color = 0, alpha = 1) {
        return this.beginTextureFill(Texture_1.Texture.WHITE, color, alpha);
    }
    ;
    /**
     * Begin the texture fill
     *
     * @param {PIXI.Texture} [texture=PIXI.Texture.WHITE] - Texture to fill
     * @param {number} [color=0xffffff] - Background to fill behind texture
     * @param {number} [alpha=1] - Alpha of fill
     * @param {PIXI.Matrix} [matrix=null] - Transform matrix
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */
    beginTextureFill(texture, color, alpha, matrix = null) {
        if (texture === void 0) {
            texture = Texture_1.Texture.WHITE;
        }
        if (color === void 0) {
            color = 0xFFFFFF;
        }
        if (alpha === void 0) {
            alpha = 1;
        }
        if (matrix === void 0) {
            matrix = null;
        }
        if (this.currentPath) {
            this.startPoly();
        }
        var visible = alpha > 0;
        if (!visible) {
            this._fillStyle.reset();
        }
        else {
            if (matrix) {
                matrix = matrix.clone();
                matrix.invert();
            }
            Object.assign(this._fillStyle, {
                color: color,
                alpha: alpha,
                texture: texture,
                matrix: matrix,
                visible: visible,
            });
        }
        return this;
    }
    ;
    /**
     * Applies a fill to the lines and shapes that were added since the last call to the beginFill() method.
     *
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */
    endFill() {
        this.finishPoly();
        this._fillStyle.reset();
        return this;
    }
    ;
    /**
     * Draws a rectangle shape.
     *
     * @param {number} x - The X coord of the top-left of the rectangle
     * @param {number} y - The Y coord of the top-left of the rectangle
     * @param {number} width - The width of the rectangle
     * @param {number} height - The height of the rectangle
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */
    drawRect(x, y, width, height) {
        return this.drawShape(new Rectangle_1.Rectangle(x, y, width, height));
    }
    ;
    /**
     * Draw a rectangle shape with rounded/beveled corners.
     *
     * @param {number} x - The X coord of the top-left of the rectangle
     * @param {number} y - The Y coord of the top-left of the rectangle
     * @param {number} width - The width of the rectangle
     * @param {number} height - The height of the rectangle
     * @param {number} radius - Radius of the rectangle corners
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */
    drawRoundedRect(x, y, width, height, radius) {
        return this.drawShape(new RoundedRectangle_1.RoundedRectangle(x, y, width, height, radius));
    }
    ;
    /**
     * Draws a circle.
     *
     * @param {number} x - The X coordinate of the center of the circle
     * @param {number} y - The Y coordinate of the center of the circle
     * @param {number} radius - The radius of the circle
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */
    drawCircle(x, y, radius) {
        return this.drawShape(new Circle_1.Circle(x, y, radius));
    }
    ;
    /**
     * Draws an ellipse.
     *
     * @param {number} x - The X coordinate of the center of the ellipse
     * @param {number} y - The Y coordinate of the center of the ellipse
     * @param {number} width - The half width of the ellipse
     * @param {number} height - The half height of the ellipse
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */
    drawEllipse(x, y, width, height) {
        return this.drawShape(new Ellipse_1.Ellipse(x, y, width, height));
    }
    ;
    /**
     * Draws a polygon using the given path.
     *
     * @param {number[]|PIXI.Point[]|PIXI.Polygon} path - The path data used to construct the polygon.
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */
    drawPolygon(path) {
        var arguments$1 = arguments;
        // prevents an argument assignment deopt
        // see section 3.1: https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#3-managing-arguments
        var points = path;
        var closeStroke = true; // !!this._fillStyle;
        // check if data has points..
        if (points.points) {
            closeStroke = points.closeStroke;
            points = points.points;
        }
        if (!Array.isArray(points)) {
            // prevents an argument leak deopt
            // see section 3.2: https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#3-managing-arguments
            points = new Array(arguments.length);
            for (var i = 0; i < points.length; ++i) {
                points[i] = arguments$1[i]; // eslint-disable-line prefer-rest-params
            }
        }
        var shape = new Polygon_1.Polygon(points);
        shape.closeStroke = closeStroke;
        this.drawShape(shape);
        return this;
    }
    ;
    /**
     * Draw any shape.
     *
     * @param {PIXI.Circle|PIXI.Ellipse|PIXI.Polygon|PIXI.Rectangle|PIXI.RoundedRectangle} shape - Shape to draw
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */
    drawShape(shape) {
        if (!this._holeMode) {
            this.geometry.drawShape(shape, this._fillStyle.clone(), this._lineStyle.clone(), this._matrix);
        }
        else {
            this.geometry.drawHole(shape, this._matrix);
        }
        return this;
    }
    ;
    /**
     * Draw a star shape with an arbitrary number of points.
     *
     * @param {number} x - Center X position of the star
     * @param {number} y - Center Y position of the star
     * @param {number} points - The number of points of the star, must be > 1
     * @param {number} radius - The outer radius of the star
     * @param {number} [innerRadius] - The inner radius between points, default half `radius`
     * @param {number} [rotation=0] - The rotation of the star in radians, where 0 is vertical
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */
    drawStar(x, y, points, radius, innerRadius = 0, rotation = 0) {
        if (rotation === void 0) {
            rotation = 0;
        }
        return this.drawPolygon(new Star_1.Star(x, y, points, radius, innerRadius, rotation));
    }
    ;
    /**
     * Clears the graphics that were drawn to this Graphics object, and resets fill and line style settings.
     *
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */
    clear() {
        this.geometry.clear();
        this._matrix = null;
        this._holeMode = false;
        this.currentPath = null;
        this._spriteRect = null;
        return this;
    }
    ;
    /**
     * True if graphics consists of one rectangle, and thus, can be drawn like a Sprite and
     * masked with gl.scissor.
     *
     * @returns {boolean} True if only 1 rect.
     */
    isFastRect() {
        // will fix this!
        return false;
        // this.graphicsData.length === 1
        //  && this.graphicsData[0].shape.type === SHAPES.RECT
        // && !this.graphicsData[0].lineWidth;
    }
    ;
    /**
     * Renders the object using the WebGL renderer
     *
     * @protected
     * @param {PIXI.Renderer} renderer - The renderer
     */
    _render(renderer) {
        this.finishPoly();
        var geometry = this.geometry;
        // batch part..
        // batch it!
        geometry.updateBatches();
        if (geometry.batchable) {
            if (this.batchDirty !== geometry.batchDirty) {
                this.batches = [];
                this.batchTint = -1;
                this._transformID = -1;
                this.batchDirty = geometry.batchDirty;
                this.vertexData = new Float32Array(geometry.points);
                var blendMode = this.blendMode;
                for (var i = 0; i < geometry.batches.length; i++) {
                    var gI = geometry.batches[i];
                    var color = gI.style.color;
                    //        + (alpha * 255 << 24);
                    var vertexData = new Float32Array(this.vertexData.buffer, gI.attribStart * 4 * 2, gI.attribSize * 2);
                    var uvs = new Float32Array(geometry.uvsFloat32.buffer, gI.attribStart * 4 * 2, gI.attribSize * 2);
                    var indices = new Uint16Array(geometry.indicesUint16.buffer, gI.start * 2, gI.size);
                    var batch = {
                        vertexData: vertexData,
                        blendMode: blendMode,
                        indices: indices,
                        uvs: uvs,
                        _batchRGB: ColorSettings_1.ColorSettings.hex2rgb(color),
                        _tintRGB: color,
                        _texture: gI.style.texture,
                        alpha: gI.style.alpha,
                        worldAlpha: 1
                    };
                    this.batches[i] = batch;
                }
            }
            renderer.batch.setObjectRenderer(renderer.plugins.batch);
            if (this.batches.length) {
                this.calculateVertices();
                this.calculateTints();
                for (var i$1 = 0; i$1 < this.batches.length; i$1++) {
                    var batch$1 = this.batches[i$1];
                    batch$1.worldAlpha = this.worldAlpha * batch$1.alpha;
                    renderer.plugins.batch.render(batch$1);
                }
            }
        }
        else {
            // no batching...
            renderer.batch.flush();
            if (!this.shader) {
                // if there is no shader here, we can use the default shader.
                // and that only gets created if we actually need it..
                if (!Graphics.defaultShader) {
                    var sampleValues = new Int32Array(16);
                    for (var i$2 = 0; i$2 < 16; i$2++) {
                        sampleValues[i$2] = i$2;
                    }
                    var uniforms = {
                        tint: new Float32Array([1, 1, 1, 1]),
                        translationMatrix: new Matrix_1.Matrix(),
                        default: UniformGroup_1.UniformGroup.from({ uSamplers: sampleValues }, true),
                    };
                    // we can bbase default shader of the batch renderers program
                    var program = renderer.plugins.batch.shader.program;
                    Graphics.defaultShader = new Shader_1.Shader(program, uniforms);
                }
                this.shader = Graphics.defaultShader;
            }
            var uniforms$1 = this.shader.uniforms;
            // lets set the transfomr
            uniforms$1.translationMatrix = this.transform.worldTransform;
            var tint = this.tint;
            var wa = this.worldAlpha;
            // and then lets set the tint..
            uniforms$1.tint[0] = (((tint >> 16) & 0xFF) / 255) * wa;
            uniforms$1.tint[1] = (((tint >> 8) & 0xFF) / 255) * wa;
            uniforms$1.tint[2] = ((tint & 0xFF) / 255) * wa;
            uniforms$1.tint[3] = wa;
            // the first draw call, we can set the uniforms of the shader directly here.
            // this means that we can tack advantage of the sync function of pixi!
            // bind and sync uniforms..
            // there is a way to optimise this..
            renderer.shader.bind(this.shader);
            // then render it
            renderer.geometry.bind(geometry, this.shader);
            // set state..
            renderer.state.setState(this.state);
            // then render the rest of them...
            for (var i$3 = 0; i$3 < geometry.drawCalls.length; i$3++) {
                var drawCall = geometry.drawCalls[i$3];
                var groupTextureCount = drawCall.textureCount;
                for (var j = 0; j < groupTextureCount; j++) {
                    renderer.texture.bind(drawCall.textures[j], j);
                }
                // bind the geometry...
                renderer.geometry.draw(drawCall.type, drawCall.size, drawCall.start);
            }
        }
    }
    ;
    /**
     * Retrieves the bounds of the graphic shape as a rectangle object
     *
     * @protected
     */
    _calculateBounds() {
        this.finishPoly();
        var lb = this.geometry.bounds;
        this._bounds.addFrame(this.transform, lb.minX, lb.minY, lb.maxX, lb.maxY);
    }
    ;
    /**
     * Tests if a point is inside this graphics object
     *
     * @param {PIXI.Point} point - the point to test
     * @return {boolean} the result of the test
     */
    containsPoint(point) {
        this.worldTransform.applyInverse(point, Graphics._TEMP_POINT);
        return this.geometry.containsPoint(Graphics._TEMP_POINT);
    }
    ;
    /**
     * Recalcuate the tint by applying tin to batches using Graphics tint.
     * @protected
     */
    calculateTints() {
        if (this.batchTint !== this.tint) {
            this.batchTint = this.tint;
            var tintRGB = ColorSettings_1.ColorSettings.hex2rgb(this.tint, Graphics.temp);
            for (var i = 0; i < this.batches.length; i++) {
                var batch = this.batches[i];
                var batchTint = batch._batchRGB;
                var r = (tintRGB[0] * batchTint[0]) * 255;
                var g = (tintRGB[1] * batchTint[1]) * 255;
                var b = (tintRGB[2] * batchTint[2]) * 255;
                // TODO Ivan, can this be done in one go?
                var color = (r << 16) + (g << 8) + (b | 0);
                batch._tintRGB = (color >> 16)
                    + (color & 0xff00)
                    + ((color & 0xff) << 16);
            }
        }
    }
    ;
    /**
     * If there's a transform update or a change to the shape of the
     * geometry, recaculate the vertices.
     * @protected
     */
    calculateVertices() {
        if (this._transformID === this.transform._worldID) {
            return;
        }
        this._transformID = this.transform._worldID;
        var wt = this.transform.worldTransform;
        // reveal(wt)
        var a = wt.a;
        var b = wt.b;
        var c = wt.c;
        var d = wt.d;
        var tx = wt.tx;
        var ty = wt.ty;
        var data = this.geometry.points; // batch.vertexDataOriginal;
        var vertexData = this.vertexData;
        var count = 0;
        for (var i = 0; i < data.length; i += 2) {
            var x = data[i];
            var y = data[i + 1];
            vertexData[count++] = (a * x) + (c * y) + tx;
            vertexData[count++] = (d * y) + (b * x) + ty;
        }
    }
    ;
    /**
     * Closes the current path.
     *
     * @return {PIXI.Graphics} Returns itself.
     */
    closePath() {
        var currentPath = this.currentPath;
        if (currentPath) {
            // we don't need to add extra point in the end because buildLine will take care of that
            currentPath.closeStroke = true;
        }
        return this;
    }
    ;
    /**
     * Apply a matrix to the positional data.
     *
     * @param {PIXI.Matrix} matrix - Matrix to use for transform current shape.
     * @return {PIXI.Graphics} Returns itself.
     */
    setMatrix(matrix) {
        this._matrix = matrix;
        return this;
    }
    ;
    /**
     * Begin adding holes to the last draw shape
     * IMPORTANT: holes must be fully inside a shape to work
     * Also weirdness ensues if holes overlap!
     * Ellipses, Circles, Rectangles and Rounded Rectangles cannot be holes or host for holes in CanvasRenderer,
     * please use `moveTo` `lineTo`, `quadraticCurveTo` if you rely on pixi-legacy bundle.
     * @return {PIXI.Graphics} Returns itself.
     */
    beginHole() {
        this.finishPoly();
        this._holeMode = true;
        return this;
    }
    ;
    /**
     * End adding holes to the last draw shape
     * @return {PIXI.Graphics} Returns itself.
     */
    endHole() {
        this.finishPoly();
        this._holeMode = false;
        return this;
    }
    ;
    /**
     * Destroys the Graphics object.
     *
     * @param {object|boolean} [options] - Options parameter. A boolean will act as if all
     *  options have been set to that value
     * @param {boolean} [options.children=false] - if set to true, all the children will have
     *  their destroy method called as well. 'options' will be passed on to those calls.
     * @param {boolean} [options.texture=false] - Only used for child Sprites if options.children is set to true
     *  Should it destroy the texture of the child sprite
     * @param {boolean} [options.baseTexture=false] - Only used for child Sprites if options.children is set to true
     *  Should it destroy the base texture of the child sprite
     */
    destroy(options) {
        super.destroy(options);
        this.geometry.refCount--;
        if (this.geometry.refCount === 0) {
            this.geometry.dispose();
        }
        this._matrix = null;
        this.currentPath = null;
        this._lineStyle.destroy();
        this._lineStyle = null;
        this._fillStyle.destroy();
        this._fillStyle = null;
        this.geometry = null;
        this.shader = null;
        this.vertexData = null;
        this.batches.length = 0;
        this.batches = null;
        super.destroy(options);
    }
    ;
}
Graphics.temp = new Float32Array([1, 1, 1]);
Graphics.defaultShader = null;
/**
* Temporary point to use for containsPoint
*
* @static
* @private
* @member {PIXI.Point}
*/
Graphics._TEMP_POINT = new Point_1.Point();
exports.Graphics = Graphics;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/GraphicsData.js":
/*!************************************************!*\
  !*** ./js-compile/raw-pixi-ts/GraphicsData.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class GraphicsData {
    constructor(shape, fillStyle = null, lineStyle = null, matrix = null) {
        /**
         * The shape object to draw.
         * @member {PIXI.Circle|PIXI.Ellipse|PIXI.Polygon|PIXI.Rectangle|PIXI.RoundedRectangle}
         */
        this.shape = shape;
        /**
         * The style of the line.
         * @member {PIXI.LineStyle}
         */
        this.lineStyle = lineStyle;
        /**
         * The style of the fill.
         * @member {PIXI.FillStyle}
         */
        this.fillStyle = fillStyle;
        /**
         * The transform matrix.
         * @member {PIXI.Matrix}
         */
        this.matrix = matrix;
        /**
         * The type of the shape, see the Const.Shapes file for all the existing types,
         * @member {number}
         */
        this.type = shape.type;
        /**
         * The collection of points.
         * @member {number[]}
         */
        this.points = [];
        /**
         * The collection of holes.
         * @member {PIXI.GraphicsData[]}
         */
        this.holes = [];
    }
    /**
     * Creates a new GraphicsData object with the same values as this one.
     *
     * @return {PIXI.GraphicsData} Cloned GraphicsData object
     */
    clone() {
        return new GraphicsData(this.shape, this.fillStyle, this.lineStyle, this.matrix);
    }
    ;
    /**
     * Destroys the Graphics data.
     */
    destroy() {
        this.shape = null;
        this.holes.length = 0;
        this.holes = null;
        this.points.length = 0;
        this.points = null;
        this.lineStyle = null;
        this.fillStyle = null;
    }
    ;
}
exports.GraphicsData = GraphicsData;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/GraphicsGeometry.js":
/*!****************************************************!*\
  !*** ./js-compile/raw-pixi-ts/GraphicsGeometry.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BatchGeometry_1 = __webpack_require__(/*! ./BatchGeometry */ "./js-compile/raw-pixi-ts/BatchGeometry.js");
const Bounds_1 = __webpack_require__(/*! ./Bounds */ "./js-compile/raw-pixi-ts/Bounds.js");
const GraphicsData_1 = __webpack_require__(/*! ./GraphicsData */ "./js-compile/raw-pixi-ts/GraphicsData.js");
const BaseTexture_1 = __webpack_require__(/*! ./BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const BatchDrawCall_1 = __webpack_require__(/*! ./BatchDrawCall */ "./js-compile/raw-pixi-ts/BatchDrawCall.js");
const Point_1 = __webpack_require__(/*! ./Point */ "./js-compile/raw-pixi-ts/Point.js");
const ShapeSettings_1 = __webpack_require__(/*! ./ShapeSettings */ "./js-compile/raw-pixi-ts/ShapeSettings.js");
const DrawModeSettings_1 = __webpack_require__(/*! ./DrawModeSettings */ "./js-compile/raw-pixi-ts/DrawModeSettings.js");
const ColorSettings_1 = __webpack_require__(/*! ./ColorSettings */ "./js-compile/raw-pixi-ts/ColorSettings.js");
class BatchPart {
    constructor() {
        this.style = null;
        this.size = 0;
        this.start = 0;
        this.attribStart = 0;
        this.attribSize = 0;
    }
}
class GraphicsGeometry extends BatchGeometry_1.BatchGeometry {
    constructor() {
        super();
        /**
         * An array of points to draw
         *
         * @member {PIXI.Point[]}
         * @protected
         */
        this.points = [];
        /**
         * The collection of colors
         *
         * @member {number[]}
         * @protected
         */
        this.colors = [];
        /**
         * The UVs collection
         *
         * @member {number[]}
         * @protected
         */
        this.uvs = [];
        /**
         * The indices of the vertices
         *
         * @member {number[]}
         * @protected
         */
        this.indices = [];
        /**
         * Reference to the texture IDs.
         *
         * @member {number[]}
         * @protected
         */
        this.textureIds = [];
        /**
         * The collection of drawn shapes.
         *
         * @member {PIXI.GraphicsData[]}
         * @protected
         */
        this.graphicsData = [];
        /**
         * Used to detect if the graphics object has changed. If this is set to true then the graphics
         * object will be recalculated.
         *
         * @member {number}
         * @protected
         */
        this.dirty = 0;
        /**
         * Batches need to regenerated if the geometry is updated.
         *
         * @member {number}
         * @protected
         */
        this.batchDirty = -1;
        /**
         * Used to check if the cache is dirty.
         *
         * @member {number}
         * @protected
         */
        this.cacheDirty = -1;
        /**
         * Used to detect if we clear the graphics WebGL data.
         *
         * @member {number}
         * @default 0
         * @protected
         */
        this.clearDirty = 0;
        /**
         * List of current draw calls drived from the batches.
         *
         * @member {object[]}
         * @protected
         */
        this.drawCalls = [];
        /**
         * Intermediate abstract format sent to batch system.
         * Can be converted to drawCalls or to batchable objects.
         *
         * @member {object[]}
         * @protected
         */
        this.batches = [];
        /**
         * Index of the current last shape in the stack of calls.
         *
         * @member {number}
         * @protected
         */
        this.shapeIndex = 0;
        /**
         * Cached bounds.
         *
         * @member {PIXI.Bounds}
         * @protected
         */
        this._bounds = new Bounds_1.Bounds();
        /**
         * The bounds dirty flag.
         *
         * @member {number}
         * @protected
         */
        this.boundsDirty = -1;
        /**
         * Padding to add to the bounds.
         *
         * @member {number}
         * @default 0
         */
        this.boundsPadding = 0;
        this.batchable = false;
        this.indicesUint16 = null;
        this.uvsFloat32 = null;
    }
    static getFillCommand(type) {
        if (!GraphicsGeometry.fillCommands) {
            GraphicsGeometry.fillCommands = {};
            GraphicsGeometry.fillCommands[ShapeSettings_1.ShapeSettings.SHAPES.POLY] = GraphicsGeometry.buildPoly;
            GraphicsGeometry.fillCommands[ShapeSettings_1.ShapeSettings.SHAPES.CIRC] = GraphicsGeometry.buildCircle;
            GraphicsGeometry.fillCommands[ShapeSettings_1.ShapeSettings.SHAPES.ELIP] = GraphicsGeometry.buildCircle;
            GraphicsGeometry.fillCommands[ShapeSettings_1.ShapeSettings.SHAPES.RECT] = GraphicsGeometry.buildRectangle;
            GraphicsGeometry.fillCommands[ShapeSettings_1.ShapeSettings.SHAPES.RREC] = GraphicsGeometry.buildRoundedRectangle;
        }
        return GraphicsGeometry.fillCommands[type];
    }
    /**
     * Get the current bounds of the graphic geometry.
     *
     * @member {PIXI.Bounds}
     * @readonly
     */
    get bounds() {
        if (this.boundsDirty !== this.dirty) {
            this.boundsDirty = this.dirty;
            this.calculateBounds();
        }
        return this._bounds;
    }
    ;
    /**
     * Clears the graphics that were drawn to this Graphics object, and resets fill and line style settings.
     *
     * @return {PIXI.GraphicsGeometry} This GraphicsGeometry object. Good for chaining method calls
     */
    clear() {
        if (this.graphicsData.length > 0) {
            this.boundsDirty = -1;
            this.dirty++;
            this.clearDirty++;
            this.batchDirty++;
            this.graphicsData.length = 0;
            this.shapeIndex = 0;
            this.points.length = 0;
            this.colors.length = 0;
            this.uvs.length = 0;
            this.indices.length = 0;
            this.textureIds.length = 0;
            for (var i = 0; i < this.drawCalls.length; i++) {
                this.drawCalls[i].textures.length = 0;
                GraphicsGeometry.DRAW_CALL_POOL.push(this.drawCalls[i]);
            }
            this.drawCalls.length = 0;
            for (var i$1 = 0; i$1 < this.batches.length; i$1++) {
                var batch = this.batches[i$1];
                batch.start = 0;
                batch.attribStart = 0;
                batch.style = null;
                GraphicsGeometry.BATCH_POOL.push(batch);
            }
            this.batches.length = 0;
        }
        return this;
    }
    ;
    /**
     * Draws the given shape to this Graphics object. Can be any of Circle, Rectangle, Ellipse, Line or Polygon.
     *
     * @param {PIXI.Circle|PIXI.Ellipse|PIXI.Polygon|PIXI.Rectangle|PIXI.RoundedRectangle} shape - The shape object to draw.
     * @param {PIXI.FillStyle} fillStyle - Defines style of the fill.
     * @param {PIXI.LineStyle} lineStyle - Defines style of the lines.
     * @param {PIXI.Matrix} matrix - Transform applied to the points of the shape.
     * @return {PIXI.GraphicsGeometry} Returns geometry for chaining.
     */
    drawShape(shape, fillStyle, lineStyle, matrix) {
        var data = new GraphicsData_1.GraphicsData(shape, fillStyle, lineStyle, matrix);
        this.graphicsData.push(data);
        this.dirty++;
        return this;
    }
    ;
    /**
     * Draws the given shape to this Graphics object. Can be any of Circle, Rectangle, Ellipse, Line or Polygon.
     *
     * @param {PIXI.Circle|PIXI.Ellipse|PIXI.Polygon|PIXI.Rectangle|PIXI.RoundedRectangle} shape - The shape object to draw.
     * @param {PIXI.Matrix} matrix - Transform applied to the points of the shape.
     * @return {PIXI.GraphicsGeometry} Returns geometry for chaining.
     */
    drawHole(shape, matrix) {
        if (!this.graphicsData.length) {
            return null;
        }
        var data = new GraphicsData_1.GraphicsData(shape, null, null, matrix);
        var lastShape = this.graphicsData[this.graphicsData.length - 1];
        data.lineStyle = lastShape.lineStyle;
        lastShape.holes.push(data);
        this.dirty++;
        return data;
    }
    ;
    /**
     * Destroys the Graphics object.
     *
     * @param {object|boolean} [options] - Options parameter. A boolean will act as if all
     *  options have been set to that value
     * @param {boolean} [options.children=false] - if set to true, all the children will have
     *  their destroy method called as well. 'options' will be passed on to those calls.
     * @param {boolean} [options.texture=false] - Only used for child Sprites if options.children is set to true
     *  Should it destroy the texture of the child sprite
     * @param {boolean} [options.baseTexture=false] - Only used for child Sprites if options.children is set to true
     *  Should it destroy the base texture of the child sprite
     */
    destroy(options) {
        super.destroy(options);
        // destroy each of the GraphicsData objects
        for (var i = 0; i < this.graphicsData.length; ++i) {
            this.graphicsData[i].destroy();
        }
        this.points.length = 0;
        this.points = null;
        this.colors.length = 0;
        this.colors = null;
        this.uvs.length = 0;
        this.uvs = null;
        this.indices.length = 0;
        this.indices = null;
        this.indexBuffer.destroy();
        this.indexBuffer = null;
        this.graphicsData.length = 0;
        this.graphicsData = null;
        this.drawCalls.length = 0;
        this.drawCalls = null;
        this.batches.length = 0;
        this.batches = null;
        this._bounds = null;
    }
    ;
    /**
     * Check to see if a point is contained within this geometry.
     *
     * @param {PIXI.Point} point - Point to check if it's contained.
     * @return {Boolean} `true` if the point is contained within geometry.
     */
    containsPoint(point) {
        var graphicsData = this.graphicsData;
        for (var i = 0; i < graphicsData.length; ++i) {
            var data = graphicsData[i];
            if (!data.fillStyle.visible) {
                continue;
            }
            // only deal with fills..
            if (data.shape) {
                if (data.shape.contains(point.x, point.y)) {
                    if (data.holes) {
                        for (var i$1 = 0; i$1 < data.holes.length; i$1++) {
                            var hole = data.holes[i$1];
                            if (hole.shape.contains(point.x, point.y)) {
                                return false;
                            }
                        }
                    }
                    return true;
                }
            }
        }
        return false;
    }
    ;
    /**
     * Generates intermediate batch data. Either gets converted to drawCalls
     * or used to convert to batch objects directly by the Graphics object.
     * @protected
     */
    updateBatches() {
        if (this.dirty === this.cacheDirty) {
            return;
        }
        if (this.graphicsData.length === 0) {
            return;
        }
        if (this.dirty !== this.cacheDirty) {
            for (var i = 0; i < this.graphicsData.length; i++) {
                var data = this.graphicsData[i];
                // reveal(data.fillStyle.texture.baseTexture.resource);
                // reveal(data.lineStyle.texture.baseTexture.resource);
                if (data.fillStyle && !data.fillStyle.texture.baseTexture.valid) {
                    return;
                }
                if (data.lineStyle && !data.lineStyle.texture.baseTexture.valid) {
                    return;
                }
            }
        }
        this.cacheDirty = this.dirty;
        var uvs = this.uvs;
        var batchPart = this.batches.pop()
            || GraphicsGeometry.BATCH_POOL.pop()
            || new BatchPart();
        batchPart.style = batchPart.style
            || this.graphicsData[0].fillStyle
            || this.graphicsData[0].lineStyle;
        var currentTexture = batchPart.style.texture.baseTexture;
        // reveal(currentTexture);
        var currentColor = batchPart.style.color + batchPart.style.alpha;
        this.batches.push(batchPart);
        // reveal(this.batches);
        // TODO - this can be simplified
        for (var i$1 = this.shapeIndex; i$1 < this.graphicsData.length; i$1++) {
            this.shapeIndex++;
            var data$1 = this.graphicsData[i$1];
            // reveal(data$1);
            var command = GraphicsGeometry.getFillCommand(data$1.type);
            // reveal(command)
            var fillStyle = data$1.fillStyle;
            var lineStyle = data$1.lineStyle;
            // build out the shapes points..
            command.build(data$1);
            if (data$1.matrix) {
                this.transformPoints(data$1.points, data$1.matrix);
                // reveal(data$1.points)
                // 	reveal(data$1.matrix)
            }
            for (var j = 0; j < 2; j++) {
                var style = (j === 0) ? fillStyle : lineStyle;
                if (!style.visible) {
                    continue;
                }
                var nextTexture = style.texture.baseTexture;
                if (currentTexture !== nextTexture || (style.color + style.alpha) !== currentColor) {
                    // TODO use a const
                    nextTexture.wrapMode = 10497;
                    currentTexture = nextTexture;
                    currentColor = style.color + style.alpha;
                    var index$1 = this.indices.length;
                    var attribIndex = this.points.length / 2;
                    batchPart.size = index$1 - batchPart.start;
                    batchPart.attribSize = attribIndex - batchPart.attribStart;
                    if (batchPart.size > 0) {
                        batchPart = GraphicsGeometry.BATCH_POOL.pop() || new BatchPart();
                        this.batches.push(batchPart);
                    }
                    batchPart.style = style;
                    batchPart.start = index$1;
                    batchPart.attribStart = attribIndex;
                    // TODO add this to the render part..
                }
                var start = this.points.length / 2;
                if (j === 0) {
                    if (data$1.holes.length) {
                        this.processHoles(data$1.holes);
                        GraphicsGeometry.buildPoly.triangulate(data$1, this);
                    }
                    else {
                        command.triangulate(data$1, this);
                    }
                }
                else {
                    GraphicsGeometry.buildLine(data$1, this);
                    for (var i$2 = 0; i$2 < data$1.holes.length; i$2++) {
                        GraphicsGeometry.buildLine(data$1.holes[i$2], this);
                    }
                }
                var size = (this.points.length / 2) - start;
                this.addUvs(this.points, uvs, style.texture, start, size, style.matrix);
            }
        }
        var index = this.indices.length;
        var attrib = this.points.length / 2;
        batchPart.size = index - batchPart.start;
        batchPart.attribSize = attrib - batchPart.attribStart;
        this.indicesUint16 = new Uint16Array(this.indices);
        // TODO make this a const..
        this.batchable = this.isBatchable();
        if (this.batchable) {
            this.batchDirty++;
            this.uvsFloat32 = new Float32Array(this.uvs);
            // offset the indices so that it works with the batcher...
            for (var i$3 = 0; i$3 < this.batches.length; i$3++) {
                var batch = this.batches[i$3];
                for (var j$1 = 0; j$1 < batch.size; j$1++) {
                    var index$2 = batch.start + j$1;
                    this.indicesUint16[index$2] = this.indicesUint16[index$2] - batch.attribStart;
                }
            }
        }
        else {
            this.buildDrawCalls();
        }
    }
    ;
    /**
     * Checks to see if this graphics geometry can be batched.
     * Currently it needs to be small enough and not contain any native lines.
     * @protected
     */
    isBatchable() {
        var batches = this.batches;
        for (var i = 0; i < batches.length; i++) {
            if (batches[i].style.native) {
                return false;
            }
        }
        return (this.points.length < GraphicsGeometry.BATCHABLE_SIZE * 2);
    }
    ;
    /**
     * Converts intermediate batches data to drawCalls.
     * @protected
     */
    buildDrawCalls() {
        var TICK = ++BaseTexture_1.BaseTexture._globalBatch;
        for (var i = 0; i < this.drawCalls.length; i++) {
            this.drawCalls[i].textures.length = 0;
            GraphicsGeometry.DRAW_CALL_POOL.push(this.drawCalls[i]);
        }
        this.drawCalls.length = 0;
        var uvs = this.uvs;
        var colors = this.colors;
        var textureIds = this.textureIds;
        var currentGroup = GraphicsGeometry.DRAW_CALL_POOL.pop() || new BatchDrawCall_1.BatchDrawCall();
        currentGroup.textureCount = 0;
        currentGroup.start = 0;
        currentGroup.size = 0;
        currentGroup.type = DrawModeSettings_1.DrawModeSettings.DRAW_MODES.TRIANGLES;
        var textureCount = 0;
        var currentTexture = null;
        var textureId = 0;
        var native = false;
        var drawMode = DrawModeSettings_1.DrawModeSettings.DRAW_MODES.TRIANGLES;
        var index = 0;
        this.drawCalls.push(currentGroup);
        // TODO - this can be simplified
        for (var i$1 = 0; i$1 < this.batches.length; i$1++) {
            var data = this.batches[i$1];
            // TODO add some full on MAX_TEXTURE CODE..
            var MAX_TEXTURES = 8;
            var style = data.style;
            var nextTexture = style.texture.baseTexture;
            if (native !== style.native) {
                native = style.native;
                drawMode = native ? DrawModeSettings_1.DrawModeSettings.DRAW_MODES.LINES : DrawModeSettings_1.DrawModeSettings.DRAW_MODES.TRIANGLES;
                // force the batch to break!
                currentTexture = null;
                textureCount = MAX_TEXTURES;
                TICK++;
            }
            if (currentTexture !== nextTexture) {
                currentTexture = nextTexture;
                if (nextTexture._batchEnabled !== TICK) {
                    if (textureCount === MAX_TEXTURES) {
                        TICK++;
                        textureCount = 0;
                        if (currentGroup.size > 0) {
                            currentGroup = GraphicsGeometry.DRAW_CALL_POOL.pop() || new BatchDrawCall_1.BatchDrawCall();
                            this.drawCalls.push(currentGroup);
                        }
                        currentGroup.start = index;
                        currentGroup.size = 0;
                        currentGroup.textureCount = 0;
                        currentGroup.type = drawMode;
                    }
                    // TODO add this to the render part..
                    nextTexture.touched = 1; // touch;
                    nextTexture._batchEnabled = TICK;
                    nextTexture._id = textureCount;
                    nextTexture.wrapMode = 10497;
                    currentGroup.textures[currentGroup.textureCount++] = nextTexture;
                    textureCount++;
                }
            }
            currentGroup.size += data.size;
            index += data.size;
            textureId = nextTexture._id;
            this.addColors(colors, style.color, style.alpha, data.attribSize);
            this.addTextureIds(textureIds, textureId, data.attribSize);
        }
        BaseTexture_1.BaseTexture._globalBatch = TICK;
        // upload..
        // merge for now!
        var verts = this.points;
        // verts are 2 positions.. so we * by 3 as there are 6 properties.. then 4 cos its bytes
        var glPoints = new ArrayBuffer(verts.length * 3 * 4);
        var f32 = new Float32Array(glPoints);
        var u32 = new Uint32Array(glPoints);
        var p = 0;
        for (var i$2 = 0; i$2 < verts.length / 2; i$2++) {
            f32[p++] = verts[i$2 * 2];
            f32[p++] = verts[(i$2 * 2) + 1];
            f32[p++] = uvs[i$2 * 2];
            f32[p++] = uvs[(i$2 * 2) + 1];
            u32[p++] = colors[i$2];
            f32[p++] = textureIds[i$2];
        }
        this._buffer.update(glPoints);
        this._indexBuffer.update(this.indicesUint16);
    }
    ;
    /**
     * Process the holes data.
     *
     * @param {PIXI.GraphicsData[]} holes - Holes to render
     * @protected
     */
    processHoles(holes) {
        for (var i = 0; i < holes.length; i++) {
            var hole = holes[i];
            var command = GraphicsGeometry.fillCommands[hole.type];
            command.build(hole);
            if (hole.matrix) {
                this.transformPoints(hole.points, hole.matrix);
            }
        }
    }
    ;
    /**
     * Update the local bounds of the object. Expensive to use performance-wise.
     * @protected
     */
    calculateBounds() {
        var minX = Infinity;
        var maxX = -Infinity;
        var minY = Infinity;
        var maxY = -Infinity;
        if (this.graphicsData.length) {
            var shape = null;
            var x = 0;
            var y = 0;
            var w = 0;
            var h = 0;
            for (var i = 0; i < this.graphicsData.length; i++) {
                var data = this.graphicsData[i];
                var type = data.type;
                var lineWidth = data.lineStyle ? data.lineStyle.width : 0;
                shape = data.shape;
                if (type === ShapeSettings_1.ShapeSettings.SHAPES.RECT || type === ShapeSettings_1.ShapeSettings.SHAPES.RREC) {
                    x = shape.x - (lineWidth / 2);
                    y = shape.y - (lineWidth / 2);
                    w = shape.width + lineWidth;
                    h = shape.height + lineWidth;
                    minX = x < minX ? x : minX;
                    maxX = x + w > maxX ? x + w : maxX;
                    minY = y < minY ? y : minY;
                    maxY = y + h > maxY ? y + h : maxY;
                }
                else if (type === ShapeSettings_1.ShapeSettings.SHAPES.CIRC) {
                    x = shape.x;
                    y = shape.y;
                    w = shape.radius + (lineWidth / 2);
                    h = shape.radius + (lineWidth / 2);
                    minX = x - w < minX ? x - w : minX;
                    maxX = x + w > maxX ? x + w : maxX;
                    minY = y - h < minY ? y - h : minY;
                    maxY = y + h > maxY ? y + h : maxY;
                }
                else if (type === ShapeSettings_1.ShapeSettings.SHAPES.ELIP) {
                    x = shape.x;
                    y = shape.y;
                    w = shape.width + (lineWidth / 2);
                    h = shape.height + (lineWidth / 2);
                    minX = x - w < minX ? x - w : minX;
                    maxX = x + w > maxX ? x + w : maxX;
                    minY = y - h < minY ? y - h : minY;
                    maxY = y + h > maxY ? y + h : maxY;
                }
                else {
                    // POLY
                    var points = shape.points;
                    var x2 = 0;
                    var y2 = 0;
                    var dx = 0;
                    var dy = 0;
                    var rw = 0;
                    var rh = 0;
                    var cx = 0;
                    var cy = 0;
                    for (var j = 0; j + 2 < points.length; j += 2) {
                        x = points[j];
                        y = points[j + 1];
                        x2 = points[j + 2];
                        y2 = points[j + 3];
                        dx = Math.abs(x2 - x);
                        dy = Math.abs(y2 - y);
                        h = lineWidth;
                        w = Math.sqrt((dx * dx) + (dy * dy));
                        if (w < 1e-9) {
                            continue;
                        }
                        rw = ((h / w * dy) + dx) / 2;
                        rh = ((h / w * dx) + dy) / 2;
                        cx = (x2 + x) / 2;
                        cy = (y2 + y) / 2;
                        minX = cx - rw < minX ? cx - rw : minX;
                        maxX = cx + rw > maxX ? cx + rw : maxX;
                        minY = cy - rh < minY ? cy - rh : minY;
                        maxY = cy + rh > maxY ? cy + rh : maxY;
                    }
                }
            }
        }
        else {
            minX = 0;
            maxX = 0;
            minY = 0;
            maxY = 0;
        }
        var padding = this.boundsPadding;
        this._bounds.minX = minX - padding;
        this._bounds.maxX = maxX + padding;
        this._bounds.minY = minY - padding;
        this._bounds.maxY = maxY + padding;
    }
    ;
    /**
     * Transform points using matrix.
     *
     * @protected
     * @param {number[]} points - Points to transform
     * @param {PIXI.Matrix} matrix - Transform matrix
     */
    transformPoints(points, matrix) {
        for (var i = 0; i < points.length / 2; i++) {
            var x = points[(i * 2)];
            var y = points[(i * 2) + 1];
            points[(i * 2)] = (matrix.a * x) + (matrix.c * y) + matrix.tx;
            points[(i * 2) + 1] = (matrix.b * x) + (matrix.d * y) + matrix.ty;
        }
    }
    ;
    /**
     * Add colors.
     *
     * @protected
     * @param {number[]} colors - List of colors to add to
     * @param {number} color - Color to add
     * @param {number} alpha - Alpha to use
     * @param {number} size - Number of colors to add
     */
    addColors(colors, color, alpha, size) {
        // TODO use the premultiply bits Ivan added
        var rgb = (color >> 16) + (color & 0xff00) + ((color & 0xff) << 16);
        var rgba = ColorSettings_1.ColorSettings.premultiplyTint(rgb, alpha);
        while (size-- > 0) {
            colors.push(rgba);
        }
    }
    ;
    /**
     * Add texture id that the shader/fragment wants to use.
     *
     * @protected
     * @param {number[]} textureIds
     * @param {number} id
     * @param {number} size
     */
    addTextureIds(textureIds, id, size) {
        while (size-- > 0) {
            textureIds.push(id);
        }
    }
    ;
    /**
     * Generates the UVs for a shape.
     *
     * @protected
     * @param {number[]} verts - Vertices
     * @param {number[]} uvs - UVs
     * @param {PIXI.Texture} texture - Reference to Texture
     * @param {number} start - Index buffer start index.
     * @param {number} size - The size/length for index buffer.
     * @param {PIXI.Matrix} [matrix] - Optional transform for all points.
     */
    addUvs(verts, uvs, texture, start, size, matrix) {
        var index = 0;
        var uvsStart = uvs.length;
        var frame = texture.frame;
        while (index < size) {
            var x = verts[(start + index) * 2];
            var y = verts[((start + index) * 2) + 1];
            if (matrix) {
                var nx = (matrix.a * x) + (matrix.c * y) + matrix.tx;
                y = (matrix.b * x) + (matrix.d * y) + matrix.ty;
                x = nx;
            }
            index++;
            uvs.push(x / frame.width, y / frame.height);
        }
        var baseTexture = texture.baseTexture;
        if (frame.width < baseTexture.width
            || frame.height < baseTexture.height) {
            this.adjustUvs(uvs, texture, uvsStart, size);
        }
    }
    ;
    /**
     * Modify uvs array according to position of texture region
     * Does not work with rotated or trimmed textures
     * @param {number} uvs array
     * @param {PIXI.Texture} texture region
     * @param {number} start starting index for uvs
     * @param {number} size how many points to adjust
     */
    adjustUvs(uvs, texture, start, size) {
        var baseTexture = texture.baseTexture;
        var eps = 1e-6;
        var finish = start + (size * 2);
        var frame = texture.frame;
        var scaleX = frame.width / baseTexture.width;
        var scaleY = frame.height / baseTexture.height;
        var offsetX = frame.x / frame.width;
        var offsetY = frame.y / frame.width;
        var minX = Math.floor(uvs[start] + eps);
        var minY = Math.floor(uvs[start + 1] + eps);
        for (var i = start + 2; i < finish; i += 2) {
            minX = Math.min(minX, Math.floor(uvs[i] + eps));
            minY = Math.min(minY, Math.floor(uvs[i + 1] + eps));
        }
        offsetX -= minX;
        offsetY -= minY;
        for (var i$1 = start; i$1 < finish; i$1 += 2) {
            uvs[i$1] = (uvs[i$1] + offsetX) * scaleX;
            uvs[i$1 + 1] = (uvs[i$1 + 1] + offsetY) * scaleY;
        }
    }
    ;
    /**
 * Builds a line to draw
 *
 * Ignored from docs since it is not directly exposed.
 *
 * @ignore
 * @private
 * @param {PIXI.GraphicsData} graphicsData - The graphics object containing all the necessary properties
 * @param {PIXI.GraphicsGeometry} graphicsGeometry - Geometry where to append output
 */
    static buildLine(graphicsData, graphicsGeometry) {
        if (graphicsData.lineStyle.native) {
            GraphicsGeometry.buildNativeLine(graphicsData, graphicsGeometry);
        }
        else {
            GraphicsGeometry.buildLine$1(graphicsData, graphicsGeometry);
        }
    }
    /**
 * Builds a line to draw using the gl.drawArrays(gl.LINES) method
 *
 * Ignored from docs since it is not directly exposed.
 *
 * @ignore
 * @private
 * @param {PIXI.GraphicsData} graphicsData - The graphics object containing all the necessary properties
 * @param {PIXI.GraphicsGeometry} graphicsGeometry - Geometry where to append output
 */
    static buildNativeLine(graphicsData, graphicsGeometry) {
        var i = 0;
        var points = graphicsData.points || graphicsData.shape.points;
        if (points.length === 0) {
            return;
        }
        var verts = graphicsGeometry.points;
        var indices = graphicsGeometry.indices;
        var length = points.length / 2;
        var indexStart = verts.length / 2;
        // sort color
        for (i = 1; i < length; i++) {
            var p1x = points[(i - 1) * 2];
            var p1y = points[((i - 1) * 2) + 1];
            var p2x = points[i * 2];
            var p2y = points[(i * 2) + 1];
            verts.push(p1x, p1y);
            verts.push(p2x, p2y);
            indices.push(indexStart++, indexStart++);
        }
    }
    /**
 * Builds a line to draw using the polygon method.
 *
 * Ignored from docs since it is not directly exposed.
 *
 * @ignore
 * @private
 * @param {PIXI.GraphicsData} graphicsData - The graphics object containing all the necessary properties
 * @param {PIXI.GraphicsGeometry} graphicsGeometry - Geometry where to append output
 */
    static buildLine$1(graphicsData, graphicsGeometry) {
        var shape = graphicsData.shape;
        var points = graphicsData.points || shape.points.slice();
        if (points.length === 0) {
            return;
        }
        // if the line width is an odd number add 0.5 to align to a whole pixel
        // commenting this out fixes #711 and #1620
        // if (graphicsData.lineWidth%2)
        // {
        //     for (i = 0; i < points.length; i++)
        //     {
        //         points[i] += 0.5;
        //     }
        // }
        var style = graphicsData.lineStyle;
        // get first and last point.. figure out the middle!
        var firstPoint = new Point_1.Point(points[0], points[1]);
        var lastPoint = new Point_1.Point(points[points.length - 2], points[points.length - 1]);
        var closedShape = shape.type !== ShapeSettings_1.ShapeSettings.SHAPES.POLY || shape.closeStroke;
        var closedPath = firstPoint.x === lastPoint.x && firstPoint.y === lastPoint.y;
        // if the first point is the last point - gonna have issues :)
        if (closedShape) {
            // need to clone as we are going to slightly modify the shape..
            points = points.slice();
            if (closedPath) {
                points.pop();
                points.pop();
                lastPoint.set(points[points.length - 2], points[points.length - 1]);
            }
            var midPointX = lastPoint.x + ((firstPoint.x - lastPoint.x) * 0.5);
            var midPointY = lastPoint.y + ((firstPoint.y - lastPoint.y) * 0.5);
            points.unshift(midPointX, midPointY);
            points.push(midPointX, midPointY);
        }
        var verts = graphicsGeometry.points;
        var length = points.length / 2;
        var indexCount = points.length;
        var indexStart = verts.length / 2;
        // DRAW the Line
        var width = style.width / 2;
        // sort color
        var p1x = points[0];
        var p1y = points[1];
        var p2x = points[2];
        var p2y = points[3];
        var p3x = 0;
        var p3y = 0;
        var perpx = -(p1y - p2y);
        var perpy = p1x - p2x;
        var perp2x = 0;
        var perp2y = 0;
        var perp3x = 0;
        var perp3y = 0;
        var dist = Math.sqrt((perpx * perpx) + (perpy * perpy));
        perpx /= dist;
        perpy /= dist;
        perpx *= width;
        perpy *= width;
        var ratio = style.alignment; // 0.5;
        var r1 = (1 - ratio) * 2;
        var r2 = ratio * 2;
        // start
        verts.push(p1x - (perpx * r1), p1y - (perpy * r1));
        verts.push(p1x + (perpx * r2), p1y + (perpy * r2));
        for (var i = 1; i < length - 1; ++i) {
            p1x = points[(i - 1) * 2];
            p1y = points[((i - 1) * 2) + 1];
            p2x = points[i * 2];
            p2y = points[(i * 2) + 1];
            p3x = points[(i + 1) * 2];
            p3y = points[((i + 1) * 2) + 1];
            perpx = -(p1y - p2y);
            perpy = p1x - p2x;
            dist = Math.sqrt((perpx * perpx) + (perpy * perpy));
            perpx /= dist;
            perpy /= dist;
            perpx *= width;
            perpy *= width;
            perp2x = -(p2y - p3y);
            perp2y = p2x - p3x;
            dist = Math.sqrt((perp2x * perp2x) + (perp2y * perp2y));
            perp2x /= dist;
            perp2y /= dist;
            perp2x *= width;
            perp2y *= width;
            var a1 = (-perpy + p1y) - (-perpy + p2y);
            var b1 = (-perpx + p2x) - (-perpx + p1x);
            var c1 = ((-perpx + p1x) * (-perpy + p2y)) - ((-perpx + p2x) * (-perpy + p1y));
            var a2 = (-perp2y + p3y) - (-perp2y + p2y);
            var b2 = (-perp2x + p2x) - (-perp2x + p3x);
            var c2 = ((-perp2x + p3x) * (-perp2y + p2y)) - ((-perp2x + p2x) * (-perp2y + p3y));
            var denom = (a1 * b2) - (a2 * b1);
            if (Math.abs(denom) < 0.1) {
                denom += 10.1;
                verts.push(p2x - (perpx * r1), p2y - (perpy * r1));
                verts.push(p2x + (perpx * r2), p2y + (perpy * r2));
                continue;
            }
            var px = ((b1 * c2) - (b2 * c1)) / denom;
            var py = ((a2 * c1) - (a1 * c2)) / denom;
            var pdist = ((px - p2x) * (px - p2x)) + ((py - p2y) * (py - p2y));
            if (pdist > (196 * width * width)) {
                perp3x = perpx - perp2x;
                perp3y = perpy - perp2y;
                dist = Math.sqrt((perp3x * perp3x) + (perp3y * perp3y));
                perp3x /= dist;
                perp3y /= dist;
                perp3x *= width;
                perp3y *= width;
                verts.push(p2x - (perp3x * r1), p2y - (perp3y * r1));
                verts.push(p2x + (perp3x * r2), p2y + (perp3y * r2));
                verts.push(p2x - (perp3x * r2 * r1), p2y - (perp3y * r1));
                indexCount++;
            }
            else {
                verts.push(p2x + ((px - p2x) * r1), p2y + ((py - p2y) * r1));
                verts.push(p2x - ((px - p2x) * r2), p2y - ((py - p2y) * r2));
            }
        }
        p1x = points[(length - 2) * 2];
        p1y = points[((length - 2) * 2) + 1];
        p2x = points[(length - 1) * 2];
        p2y = points[((length - 1) * 2) + 1];
        perpx = -(p1y - p2y);
        perpy = p1x - p2x;
        dist = Math.sqrt((perpx * perpx) + (perpy * perpy));
        perpx /= dist;
        perpy /= dist;
        perpx *= width;
        perpy *= width;
        verts.push(p2x - (perpx * r1), p2y - (perpy * r1));
        verts.push(p2x + (perpx * r2), p2y + (perpy * r2));
        var indices = graphicsGeometry.indices;
        // indices.push(indexStart);
        for (var i$1 = 0; i$1 < indexCount - 2; ++i$1) {
            indices.push(indexStart, indexStart + 1, indexStart + 2);
            indexStart++;
        }
    }
    static earcut(data, holeIndices, dim) {
        dim = dim || 2;
        var hasHoles = holeIndices && holeIndices.length, outerLen = hasHoles ? holeIndices[0] * dim : data.length, outerNode = GraphicsGeometry.linkedList(data, 0, outerLen, dim, true), triangles = [];
        if (!outerNode || outerNode.next === outerNode.prev) {
            return triangles;
        }
        var minX, minY, maxX, maxY, x, y, invSize;
        if (hasHoles) {
            outerNode = GraphicsGeometry.eliminateHoles(data, holeIndices, outerNode, dim);
        }
        // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
        if (data.length > 80 * dim) {
            minX = maxX = data[0];
            minY = maxY = data[1];
            for (var i = dim; i < outerLen; i += dim) {
                x = data[i];
                y = data[i + 1];
                if (x < minX) {
                    minX = x;
                }
                if (y < minY) {
                    minY = y;
                }
                if (x > maxX) {
                    maxX = x;
                }
                if (y > maxY) {
                    maxY = y;
                }
            }
            // minX, minY and invSize are later used to transform coords into integers for z-order calculation
            invSize = Math.max(maxX - minX, maxY - minY);
            invSize = invSize !== 0 ? 1 / invSize : 0;
        }
        GraphicsGeometry.earcutLinked(outerNode, triangles, dim, minX, minY, invSize);
        return triangles;
    }
    // create a circular doubly linked list from polygon points in the specified winding order
    static linkedList(data, start, end, dim, clockwise) {
        var i, last;
        if (clockwise === (GraphicsGeometry.signedArea(data, start, end, dim) > 0)) {
            for (i = start; i < end; i += dim) {
                last = GraphicsGeometry.insertNode(i, data[i], data[i + 1], last);
            }
        }
        else {
            for (i = end - dim; i >= start; i -= dim) {
                last = GraphicsGeometry.insertNode(i, data[i], data[i + 1], last);
            }
        }
        if (last && GraphicsGeometry.equals(last, last.next)) {
            GraphicsGeometry.removeNode(last);
            last = last.next;
        }
        return last;
    }
    // link every hole into the outer loop, producing a single-ring polygon without holes
    static eliminateHoles(data, holeIndices, outerNode, dim) {
        var queue = [], i, len, start, end, list;
        for (i = 0, len = holeIndices.length; i < len; i++) {
            start = holeIndices[i] * dim;
            end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
            list = GraphicsGeometry.linkedList(data, start, end, dim, false);
            if (list === list.next) {
                list.steiner = true;
            }
            queue.push(GraphicsGeometry.getLeftmost(list));
        }
        queue.sort(GraphicsGeometry.compareX);
        // process holes from left to right
        for (i = 0; i < queue.length; i++) {
            GraphicsGeometry.eliminateHole(queue[i], outerNode);
            outerNode = GraphicsGeometry.filterPoints(outerNode, outerNode.next);
        }
        return outerNode;
    }
    // main ear slicing loop which triangulates a polygon (given as a linked list)
    static earcutLinked(ear, triangles, dim, minX, minY, invSize, pass = null) {
        if (!ear) {
            return;
        }
        // interlink polygon nodes in z-order
        if (!pass && invSize) {
            GraphicsGeometry.indexCurve(ear, minX, minY, invSize);
        }
        var stop = ear, prev, next;
        // iterate through ears, slicing them one by one
        while (ear.prev !== ear.next) {
            prev = ear.prev;
            next = ear.next;
            if (invSize ? GraphicsGeometry.isEarHashed(ear, minX, minY, invSize) : GraphicsGeometry.isEar(ear)) {
                // cut off the triangle
                triangles.push(prev.i / dim);
                triangles.push(ear.i / dim);
                triangles.push(next.i / dim);
                GraphicsGeometry.removeNode(ear);
                // skipping the next vertex leads to less sliver triangles
                ear = next.next;
                stop = next.next;
                continue;
            }
            ear = next;
            // if we looped through the whole remaining polygon and can't find any more ears
            if (ear === stop) {
                // try filtering points and slicing again
                if (!pass) {
                    GraphicsGeometry.earcutLinked(GraphicsGeometry.filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
                    // if this didn't work, try curing all small self-intersections locally
                }
                else if (pass === 1) {
                    ear = GraphicsGeometry.cureLocalIntersections(ear, triangles, dim);
                    GraphicsGeometry.earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
                    // as a last resort, try splitting the remaining polygon into two
                }
                else if (pass === 2) {
                    GraphicsGeometry.splitEarcut(ear, triangles, dim, minX, minY, invSize);
                }
                break;
            }
        }
    }
    static signedArea(data, start, end, dim) {
        var sum = 0;
        for (var i = start, j = end - dim; i < end; i += dim) {
            sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
            j = i;
        }
        return sum;
    }
    // create a node and optionally link it with previous one (in a circular doubly linked list)
    static insertNode(i, x, y, last) {
        var p = new Node(i, x, y);
        if (!last) {
            p.prev = p;
            p.next = p;
        }
        else {
            p.next = last.next;
            p.prev = last;
            last.next.prev = p;
            last.next = p;
        }
        return p;
    }
    // check if two points are equal
    static equals(p1, p2) {
        return p1.x === p2.x && p1.y === p2.y;
    }
    static removeNode(p) {
        p.next.prev = p.prev;
        p.prev.next = p.next;
        if (p.prevZ) {
            p.prevZ.nextZ = p.nextZ;
        }
        if (p.nextZ) {
            p.nextZ.prevZ = p.prevZ;
        }
    }
    // find the leftmost node of a polygon ring
    static getLeftmost(start) {
        var p = start, leftmost = start;
        do {
            if (p.x < leftmost.x || (p.x === leftmost.x && p.y < leftmost.y)) {
                leftmost = p;
            }
            p = p.next;
        } while (p !== start);
        return leftmost;
    }
    static compareX(a, b) {
        return a.x - b.x;
    }
    // find a bridge between vertices that connects hole with an outer ring and and link it
    static eliminateHole(hole, outerNode) {
        outerNode = GraphicsGeometry.findHoleBridge(hole, outerNode);
        if (outerNode) {
            var b = GraphicsGeometry.splitPolygon(outerNode, hole);
            GraphicsGeometry.filterPoints(b, b.next);
        }
    }
    // eliminate colinear or duplicate points
    static filterPoints(start, end = null) {
        if (!start) {
            return start;
        }
        if (!end) {
            end = start;
        }
        var p = start, again;
        do {
            again = false;
            if (!p.steiner && (GraphicsGeometry.equals(p, p.next) || GraphicsGeometry.area(p.prev, p, p.next) === 0)) {
                GraphicsGeometry.removeNode(p);
                p = end = p.prev;
                if (p === p.next) {
                    break;
                }
                again = true;
            }
            else {
                p = p.next;
            }
        } while (again || p !== end);
        return end;
    }
    // signed area of a triangle
    static area(p, q, r) {
        return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
    }
    // link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
    // if one belongs to the outer ring and another to a hole, it merges it into a single ring
    static splitPolygon(a, b) {
        var a2 = new Node(a.i, a.x, a.y), b2 = new Node(b.i, b.x, b.y), an = a.next, bp = b.prev;
        a.next = b;
        b.prev = a;
        a2.next = an;
        an.prev = a2;
        b2.next = a2;
        a2.prev = b2;
        bp.next = b2;
        b2.prev = bp;
        return b2;
    }
    // David Eberly's algorithm for finding a bridge between hole and outer polygon
    static findHoleBridge(hole, outerNode) {
        var p = outerNode, hx = hole.x, hy = hole.y, qx = -Infinity, m;
        // find a segment intersected by a ray from the hole's leftmost point to the left;
        // segment's endpoint with lesser x will be potential connection point
        do {
            if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
                var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
                if (x <= hx && x > qx) {
                    qx = x;
                    if (x === hx) {
                        if (hy === p.y) {
                            return p;
                        }
                        if (hy === p.next.y) {
                            return p.next;
                        }
                    }
                    m = p.x < p.next.x ? p : p.next;
                }
            }
            p = p.next;
        } while (p !== outerNode);
        if (!m) {
            return null;
        }
        if (hx === qx) {
            return m.prev;
        } // hole touches outer segment; pick lower endpoint
        // look for points inside the triangle of hole point, segment intersection and endpoint;
        // if there are no points found, we have a valid connection;
        // otherwise choose the point of the minimum angle with the ray as connection point
        var stop = m, mx = m.x, my = m.y, tanMin = Infinity, tan;
        p = m.next;
        while (p !== stop) {
            if (hx >= p.x && p.x >= mx && hx !== p.x &&
                GraphicsGeometry.pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
                tan = Math.abs(hy - p.y) / (hx - p.x); // tangential
                if ((tan < tanMin || (tan === tanMin && p.x > m.x)) && GraphicsGeometry.locallyInside(p, hole)) {
                    m = p;
                    tanMin = tan;
                }
            }
            p = p.next;
        }
        return m;
    }
    // check if a polygon diagonal is locally inside the polygon
    static locallyInside(a, b) {
        return GraphicsGeometry.area(a.prev, a, a.next) < 0 ?
            GraphicsGeometry.area(a, b, a.next) >= 0 && GraphicsGeometry.area(a, a.prev, b) >= 0 :
            GraphicsGeometry.area(a, b, a.prev) < 0 || GraphicsGeometry.area(a, a.next, b) < 0;
    }
    // check if a point lies within a convex triangle
    static pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
        return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 &&
            (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 &&
            (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
    }
    // try splitting polygon into two and triangulate them independently
    static splitEarcut(start, triangles, dim, minX, minY, invSize) {
        // look for a valid diagonal that divides the polygon into two
        var a = start;
        do {
            var b = a.next.next;
            while (b !== a.prev) {
                if (a.i !== b.i && GraphicsGeometry.isValidDiagonal(a, b)) {
                    // split the polygon in two by the diagonal
                    var c = GraphicsGeometry.splitPolygon(a, b);
                    // filter colinear points around the cuts
                    a = GraphicsGeometry.filterPoints(a, a.next);
                    c = GraphicsGeometry.filterPoints(c, c.next);
                    // run earcut on each half
                    GraphicsGeometry.earcutLinked(a, triangles, dim, minX, minY, invSize);
                    GraphicsGeometry.earcutLinked(c, triangles, dim, minX, minY, invSize);
                    return;
                }
                b = b.next;
            }
            a = a.next;
        } while (a !== start);
    }
    // check if a diagonal between two polygon nodes is valid (lies in polygon interior)
    static isValidDiagonal(a, b) {
        return a.next.i !== b.i && a.prev.i !== b.i && !GraphicsGeometry.intersectsPolygon(a, b) &&
            GraphicsGeometry.locallyInside(a, b) && GraphicsGeometry.locallyInside(b, a) && GraphicsGeometry.middleInside(a, b);
    }
    // check if the middle point of a polygon diagonal is inside the polygon
    static middleInside(a, b) {
        var p = a, inside = false, px = (a.x + b.x) / 2, py = (a.y + b.y) / 2;
        do {
            if (((p.y > py) !== (p.next.y > py)) && p.next.y !== p.y &&
                (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x)) {
                inside = !inside;
            }
            p = p.next;
        } while (p !== a);
        return inside;
    }
    // check if a polygon diagonal intersects any polygon segments
    static intersectsPolygon(a, b) {
        var p = a;
        do {
            if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&
                GraphicsGeometry.intersects(p, p.next, a, b)) {
                return true;
            }
            p = p.next;
        } while (p !== a);
        return false;
    }
    // check if two segments intersect
    static intersects(p1, q1, p2, q2) {
        if ((GraphicsGeometry.equals(p1, q1) && GraphicsGeometry.equals(p2, q2)) ||
            (GraphicsGeometry.equals(p1, q2) && GraphicsGeometry.equals(p2, q1))) {
            return true;
        }
        return GraphicsGeometry.area(p1, q1, p2) > 0 !== GraphicsGeometry.area(p1, q1, q2) > 0 &&
            GraphicsGeometry.area(p2, q2, p1) > 0 !== GraphicsGeometry.area(p2, q2, q1) > 0;
    }
    // go through all polygon nodes and cure small local self-intersections
    static cureLocalIntersections(start, triangles, dim) {
        var p = start;
        do {
            var a = p.prev, b = p.next.next;
            if (!GraphicsGeometry.equals(a, b) && GraphicsGeometry.intersects(a, p, p.next, b) && GraphicsGeometry.locallyInside(a, b) && GraphicsGeometry.locallyInside(b, a)) {
                triangles.push(a.i / dim);
                triangles.push(p.i / dim);
                triangles.push(b.i / dim);
                // remove two nodes involved
                GraphicsGeometry.removeNode(p);
                GraphicsGeometry.removeNode(p.next);
                p = start = b;
            }
            p = p.next;
        } while (p !== start);
        return p;
    }
    static isEarHashed(ear, minX, minY, invSize) {
        var a = ear.prev, b = ear, c = ear.next;
        if (GraphicsGeometry.area(a, b, c) >= 0) {
            return false;
        } // reflex, can't be an ear
        // triangle bbox; min & max are calculated like this for speed
        var minTX = a.x < b.x ? (a.x < c.x ? a.x : c.x) : (b.x < c.x ? b.x : c.x), minTY = a.y < b.y ? (a.y < c.y ? a.y : c.y) : (b.y < c.y ? b.y : c.y), maxTX = a.x > b.x ? (a.x > c.x ? a.x : c.x) : (b.x > c.x ? b.x : c.x), maxTY = a.y > b.y ? (a.y > c.y ? a.y : c.y) : (b.y > c.y ? b.y : c.y);
        // z-order range for the current triangle bbox;
        var minZ = GraphicsGeometry.zOrder(minTX, minTY, minX, minY, invSize), maxZ = GraphicsGeometry.zOrder(maxTX, maxTY, minX, minY, invSize);
        var p = ear.prevZ, n = ear.nextZ;
        // look for points inside the triangle in both directions
        while (p && p.z >= minZ && n && n.z <= maxZ) {
            if (p !== ear.prev && p !== ear.next &&
                GraphicsGeometry.pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
                GraphicsGeometry.area(p.prev, p, p.next) >= 0) {
                return false;
            }
            p = p.prevZ;
            if (n !== ear.prev && n !== ear.next &&
                GraphicsGeometry.pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) &&
                GraphicsGeometry.area(n.prev, n, n.next) >= 0) {
                return false;
            }
            n = n.nextZ;
        }
        // look for remaining points in decreasing z-order
        while (p && p.z >= minZ) {
            if (p !== ear.prev && p !== ear.next &&
                GraphicsGeometry.pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
                GraphicsGeometry.area(p.prev, p, p.next) >= 0) {
                return false;
            }
            p = p.prevZ;
        }
        // look for remaining points in increasing z-order
        while (n && n.z <= maxZ) {
            if (n !== ear.prev && n !== ear.next &&
                GraphicsGeometry.pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) &&
                GraphicsGeometry.area(n.prev, n, n.next) >= 0) {
                return false;
            }
            n = n.nextZ;
        }
        return true;
    }
    // z-order of a point given coords and inverse of the longer side of data bbox
    static zOrder(x, y, minX, minY, invSize) {
        // coords are transformed into non-negative 15-bit integer range
        x = 32767 * (x - minX) * invSize;
        y = 32767 * (y - minY) * invSize;
        x = (x | (x << 8)) & 0x00FF00FF;
        x = (x | (x << 4)) & 0x0F0F0F0F;
        x = (x | (x << 2)) & 0x33333333;
        x = (x | (x << 1)) & 0x55555555;
        y = (y | (y << 8)) & 0x00FF00FF;
        y = (y | (y << 4)) & 0x0F0F0F0F;
        y = (y | (y << 2)) & 0x33333333;
        y = (y | (y << 1)) & 0x55555555;
        return x | (y << 1);
    }
    // check whether a polygon node forms a valid ear with adjacent nodes
    static isEar(ear) {
        var a = ear.prev, b = ear, c = ear.next;
        if (GraphicsGeometry.area(a, b, c) >= 0) {
            return false;
        } // reflex, can't be an ear
        // now make sure we don't have other points inside the potential ear
        var p = ear.next.next;
        while (p !== ear.prev) {
            if (GraphicsGeometry.pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
                GraphicsGeometry.area(p.prev, p, p.next) >= 0) {
                return false;
            }
            p = p.next;
        }
        return true;
    }
    // interlink polygon nodes in z-order
    static indexCurve(start, minX, minY, invSize) {
        var p = start;
        do {
            if (p.z === null) {
                p.z = GraphicsGeometry.zOrder(p.x, p.y, minX, minY, invSize);
            }
            p.prevZ = p.prev;
            p.nextZ = p.next;
            p = p.next;
        } while (p !== start);
        p.prevZ.nextZ = null;
        p.prevZ = null;
        GraphicsGeometry.sortLinked(p);
    }
    // Simon Tatham's linked list merge sort algorithm
    // http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
    static sortLinked(list) {
        var i, p, q, e, tail, numMerges, pSize, qSize, inSize = 1;
        do {
            p = list;
            list = null;
            tail = null;
            numMerges = 0;
            while (p) {
                numMerges++;
                q = p;
                pSize = 0;
                for (i = 0; i < inSize; i++) {
                    pSize++;
                    q = q.nextZ;
                    if (!q) {
                        break;
                    }
                }
                qSize = inSize;
                while (pSize > 0 || (qSize > 0 && q)) {
                    if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
                        e = p;
                        p = p.nextZ;
                        pSize--;
                    }
                    else {
                        e = q;
                        q = q.nextZ;
                        qSize--;
                    }
                    if (tail) {
                        tail.nextZ = e;
                    }
                    else {
                        list = e;
                    }
                    e.prevZ = tail;
                    tail = e;
                }
                p = q;
            }
            tail.nextZ = null;
            inSize *= 2;
        } while (numMerges > 1);
        return list;
    }
    /**
 * Calculate the points for a quadratic bezier curve. (helper function..)
 * Based on: https://stackoverflow.com/questions/785097/how-do-i-implement-a-bezier-curve-in-c
 *
 * Ignored from docs since it is not directly exposed.
 *
 * @ignore
 * @private
 * @param {number} fromX - Origin point x
 * @param {number} fromY - Origin point x
 * @param {number} cpX - Control point x
 * @param {number} cpY - Control point y
 * @param {number} toX - Destination point x
 * @param {number} toY - Destination point y
 * @param {number[]} [out=[]] - The output array to add points into. If not passed, a new array is created.
 * @return {number[]} an array of points
 */
    static quadraticBezierCurve(fromX, fromY, cpX, cpY, toX, toY, out) {
        if (out === void 0) {
            out = [];
        }
        var n = 20;
        var points = out;
        var xa = 0;
        var ya = 0;
        var xb = 0;
        var yb = 0;
        var x = 0;
        var y = 0;
        for (var i = 0, j = 0; i <= n; ++i) {
            j = i / n;
            // The Green Line
            xa = GraphicsGeometry.getPt(fromX, cpX, j);
            ya = GraphicsGeometry.getPt(fromY, cpY, j);
            xb = GraphicsGeometry.getPt(cpX, toX, j);
            yb = GraphicsGeometry.getPt(cpY, toY, j);
            // The Black Dot
            x = GraphicsGeometry.getPt(xa, xb, j);
            y = GraphicsGeometry.getPt(ya, yb, j);
            points.push(x, y);
        }
        return points;
    }
    /**
 * Calculate a single point for a quadratic bezier curve.
 * Utility function used by quadraticBezierCurve.
 * Ignored from docs since it is not directly exposed.
 *
 * @ignore
 * @private
 * @param {number} n1 - first number
 * @param {number} n2 - second number
 * @param {number} perc - percentage
 * @return {number} the result
 *
 */
    static getPt(n1, n2, perc) {
        var diff = n2 - n1;
        return n1 + (diff * perc);
    }
}
GraphicsGeometry.BATCH_POOL = [];
GraphicsGeometry.DRAW_CALL_POOL = [];
/**
* The maximum number of points to consider an object "batchable",
* able to be batched by the renderer's batch system.
*
* @memberof PIXI.GraphicsGeometry
* @static
* @member {number} BATCHABLE_SIZE
* @default 100
*/
GraphicsGeometry.BATCHABLE_SIZE = 100;
/**
* Builds a polygon to draw
*
* Ignored from docs since it is not directly exposed.
*
* @ignore
* @private
* @param {PIXI.WebGLGraphicsData} graphicsData - The graphics object containing all the necessary properties
* @param {object} webGLData - an object containing all the WebGL-specific information to create this shape
* @param {object} webGLDataNativeLines - an object containing all the WebGL-specific information to create nativeLines
*/
GraphicsGeometry.buildPoly = {
    name: "buildPoly",
    build: function build(graphicsData) {
        graphicsData.points = graphicsData.shape.points.slice();
    },
    triangulate: function triangulate(graphicsData, graphicsGeometry) {
        var points = graphicsData.points;
        var holes = graphicsData.holes;
        var verts = graphicsGeometry.points;
        var indices = graphicsGeometry.indices;
        if (points.length >= 6) {
            var holeArray = [];
            // Process holes..
            for (var i = 0; i < holes.length; i++) {
                var hole = holes[i];
                holeArray.push(points.length / 2);
                points = points.concat(hole.points);
            }
            // sort color
            var triangles = GraphicsGeometry.earcut(points, holeArray, 2);
            if (!triangles) {
                return;
            }
            var vertPos = verts.length / 2;
            for (var i$1 = 0; i$1 < triangles.length; i$1 += 3) {
                indices.push(triangles[i$1] + vertPos);
                indices.push(triangles[i$1 + 1] + vertPos);
                indices.push(triangles[i$1 + 2] + vertPos);
            }
            for (var i$2 = 0; i$2 < points.length; i$2++) {
                verts.push(points[i$2]);
            }
        }
    },
};
/**
* Builds a rectangle to draw
*
* Ignored from docs since it is not directly exposed.
*
* @ignore
* @private
* @param {PIXI.WebGLGraphicsData} graphicsData - The graphics object containing all the necessary properties
* @param {object} webGLData - an object containing all the WebGL-specific information to create this shape
* @param {object} webGLDataNativeLines - an object containing all the WebGL-specific information to create nativeLines
*/
GraphicsGeometry.buildRectangle = {
    name: "buildRectangle",
    build: function build(graphicsData) {
        // --- //
        // need to convert points to a nice regular data
        //
        var rectData = graphicsData.shape;
        var x = rectData.x;
        var y = rectData.y;
        var width = rectData.width;
        var height = rectData.height;
        var points = graphicsData.points;
        points.length = 0;
        points.push(x, y, x + width, y, x + width, y + height, x, y + height);
    },
    triangulate: function triangulate(graphicsData, graphicsGeometry) {
        var points = graphicsData.points;
        var verts = graphicsGeometry.points;
        var vertPos = verts.length / 2;
        verts.push(points[0], points[1], points[2], points[3], points[6], points[7], points[4], points[5]);
        graphicsGeometry.indices.push(vertPos, vertPos + 1, vertPos + 2, vertPos + 1, vertPos + 2, vertPos + 3);
    },
};
/**
* Builds a rounded rectangle to draw
*
* Ignored from docs since it is not directly exposed.
*
* @ignore
* @private
* @param {PIXI.WebGLGraphicsData} graphicsData - The graphics object containing all the necessary properties
* @param {object} webGLData - an object containing all the WebGL-specific information to create this shape
* @param {object} webGLDataNativeLines - an object containing all the WebGL-specific information to create nativeLines
*/
GraphicsGeometry.buildRoundedRectangle = {
    name: "buildRoundedRectangle",
    build: function build(graphicsData) {
        var rrectData = graphicsData.shape;
        var points = graphicsData.points;
        var x = rrectData.x;
        var y = rrectData.y;
        var width = rrectData.width;
        var height = rrectData.height;
        var radius = rrectData.radius;
        points.length = 0;
        GraphicsGeometry.quadraticBezierCurve(x, y + radius, x, y, x + radius, y, points);
        GraphicsGeometry.quadraticBezierCurve(x + width - radius, y, x + width, y, x + width, y + radius, points);
        GraphicsGeometry.quadraticBezierCurve(x + width, y + height - radius, x + width, y + height, x + width - radius, y + height, points);
        GraphicsGeometry.quadraticBezierCurve(x + radius, y + height, x, y + height, x, y + height - radius, points);
        // this tiny number deals with the issue that occurs when points overlap and earcut fails to triangulate the item.
        // TODO - fix this properly, this is not very elegant.. but it works for now.
    },
    triangulate: function triangulate(graphicsData, graphicsGeometry) {
        var points = graphicsData.points;
        var verts = graphicsGeometry.points;
        var indices = graphicsGeometry.indices;
        var vecPos = verts.length / 2;
        var triangles = GraphicsGeometry.earcut(points, null, 2);
        for (var i = 0, j = triangles.length; i < j; i += 3) {
            indices.push(triangles[i] + vecPos);
            //     indices.push(triangles[i] + vecPos);
            indices.push(triangles[i + 1] + vecPos);
            //   indices.push(triangles[i + 2] + vecPos);
            indices.push(triangles[i + 2] + vecPos);
        }
        for (var i$1 = 0, j$1 = points.length; i$1 < j$1; i$1++) {
            verts.push(points[i$1], points[++i$1]);
        }
    },
};
/**
* Builds a circle to draw
*
* Ignored from docs since it is not directly exposed.
*
* @ignore
* @private
* @param {PIXI.WebGLGraphicsData} graphicsData - The graphics object to draw
* @param {object} webGLData - an object containing all the WebGL-specific information to create this shape
* @param {object} webGLDataNativeLines - an object containing all the WebGL-specific information to create nativeLines
*/
GraphicsGeometry.buildCircle = {
    name: "buildCircle",
    build: function build(graphicsData) {
        // need to convert points to a nice regular data
        var circleData = graphicsData.shape;
        var points = graphicsData.points;
        var x = circleData.x;
        var y = circleData.y;
        var width;
        var height;
        points.length = 0;
        // TODO - bit hacky??
        if (graphicsData.type === ShapeSettings_1.ShapeSettings.SHAPES.CIRC) {
            width = circleData.radius;
            height = circleData.radius;
        }
        else {
            width = circleData.width;
            height = circleData.height;
        }
        if (width === 0 || height === 0) {
            return;
        }
        var totalSegs = Math.floor(30 * Math.sqrt(circleData.radius))
            || Math.floor(15 * Math.sqrt(circleData.width + circleData.height));
        totalSegs /= 2.3;
        var seg = (Math.PI * 2) / totalSegs;
        for (var i = 0; i < totalSegs; i++) {
            points.push(x + (Math.sin(-seg * i) * width), y + (Math.cos(-seg * i) * height));
        }
        points.push(points[0], points[1]);
    },
    triangulate: function triangulate(graphicsData, graphicsGeometry) {
        var points = graphicsData.points;
        var verts = graphicsGeometry.points;
        var indices = graphicsGeometry.indices;
        var vertPos = verts.length / 2;
        var center = vertPos;
        verts.push(graphicsData.shape.x, graphicsData.shape.y);
        for (var i = 0; i < points.length; i += 2) {
            verts.push(points[i], points[i + 1]);
            // add some uvs
            indices.push(vertPos++, center, vertPos);
        }
    },
};
exports.GraphicsGeometry = GraphicsGeometry;
class Node {
    constructor(i, x, y) {
        // vertex index in coordinates array
        this.i = i;
        // vertex coordinates
        this.x = x;
        this.y = y;
        // previous and next vertex nodes in a polygon ring
        this.prev = null;
        this.next = null;
        // z-order curve value
        this.z = null;
        // previous and next nodes in z-order
        this.prevZ = null;
        this.nextZ = null;
        // indicates whether this is a steiner point
        this.steiner = false;
    }
}


/***/ }),

/***/ "./js-compile/raw-pixi-ts/GroupD8.js":
/*!*******************************************!*\
  !*** ./js-compile/raw-pixi-ts/GroupD8.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Matrix_1 = __webpack_require__(/*! ./Matrix */ "./js-compile/raw-pixi-ts/Matrix.js");
class GroupD8 {
    static uX(ind) {
        GroupD8.init();
        return GroupD8.ux[ind];
    }
    static uY(ind) {
        GroupD8.init();
        return GroupD8.uy[ind];
    }
    static vX(ind) {
        GroupD8.init();
        return GroupD8.vx[ind];
    }
    static vY(ind) {
        GroupD8.init();
        return GroupD8.vy[ind];
    }
    static inv(rotation) {
        if (rotation & 8) {
            return rotation & 15;
        }
        return (-rotation) & 7;
    }
    static add(rotationSecond, rotationFirst) {
        GroupD8.init();
        return GroupD8.mul[rotationSecond][rotationFirst];
    }
    static sub(rotationSecond, rotationFirst) {
        GroupD8.init();
        return GroupD8.mul[rotationSecond][GroupD8.inv(rotationFirst)];
    }
    static rotate180(rotation) {
        return rotation ^ 4;
    }
    static isVertical(rotation) {
        return (rotation & 3) === 2;
    }
    static byDirection(dx, dy) {
        GroupD8.init();
        if (Math.abs(dx) * 2 <= Math.abs(dy)) {
            if (dy >= 0) {
                return GroupD8.S;
            }
            return GroupD8.N;
        }
        else if (Math.abs(dy) * 2 <= Math.abs(dx)) {
            if (dx > 0) {
                return GroupD8.E;
            }
            return GroupD8.W;
        }
        else if (dy > 0) {
            if (dx > 0) {
                return GroupD8.SE;
            }
            return GroupD8.SW;
        }
        else if (dx > 0) {
            return GroupD8.NE;
        }
        return GroupD8.NW;
    }
    static matrixAppendRotationInv(matrix, rotation, tx = 0, ty = 0) {
        GroupD8.init();
        let mat = GroupD8.tempMatrices[GroupD8.inv(rotation)];
        mat.tx = tx;
        mat.ty = ty;
        matrix.append(mat);
    }
    static signum(x) {
        if (x < 0) {
            return -1;
        }
        if (x > 0) {
            return 1;
        }
        return 0;
    }
    static init() {
        if (GroupD8.isInit) {
            return;
        }
        GroupD8.isInit = true;
        for (var i = 0; i < 16; i++) {
            var row = [];
            GroupD8.mul.push(row);
            for (var j = 0; j < 16; j++) {
                var _ux = GroupD8.signum((GroupD8.ux[i] * GroupD8.ux[j]) + (GroupD8.vx[i] * GroupD8.uy[j]));
                var _uy = GroupD8.signum((GroupD8.uy[i] * GroupD8.ux[j]) + (GroupD8.vy[i] * GroupD8.uy[j]));
                var _vx = GroupD8.signum((GroupD8.ux[i] * GroupD8.vx[j]) + (GroupD8.vx[i] * GroupD8.vy[j]));
                var _vy = GroupD8.signum((GroupD8.uy[i] * GroupD8.vx[j]) + (GroupD8.vy[i] * GroupD8.vy[j]));
                for (var k = 0; k < 16; k++) {
                    if (GroupD8.ux[k] === _ux && GroupD8.uy[k] === _uy && GroupD8.vx[k] === _vx && GroupD8.vy[k] === _vy) {
                        row.push(k);
                        break;
                    }
                }
            }
        }
        for (var i$1 = 0; i$1 < 16; i$1++) {
            var mat = new Matrix_1.Matrix();
            mat.set(GroupD8.ux[i$1], GroupD8.uy[i$1], GroupD8.vx[i$1], GroupD8.vy[i$1], 0, 0);
            GroupD8.tempMatrices.push(mat);
        }
    }
}
GroupD8.isInit = false;
GroupD8.E = 0;
GroupD8.SE = 1;
GroupD8.S = 2;
GroupD8.SW = 3;
GroupD8.W = 4;
GroupD8.NW = 5;
GroupD8.N = 6;
GroupD8.NE = 7;
GroupD8.MIRROR_VERTICAL = 8;
GroupD8.MIRROR_HORIZONTAL = 12;
GroupD8.ux = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1];
GroupD8.uy = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1];
GroupD8.vx = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1];
GroupD8.vy = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1];
GroupD8.tempMatrices = [];
GroupD8.mul = [];
exports.GroupD8 = GroupD8;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/IOErrorEvent.js":
/*!************************************************!*\
  !*** ./js-compile/raw-pixi-ts/IOErrorEvent.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Event_1 = __webpack_require__(/*! ./Event */ "./js-compile/raw-pixi-ts/Event.js");
class IOErrorEvent extends Event_1.Event {
    constructor(type, bubble = true, cancelable = true) {
        super(type, bubble, cancelable);
        this.errorId = 0;
    }
    clone() {
        var event = new IOErrorEvent(this.type, this.bubbles, this.cancelable);
        event.text = this.text;
        event.errorId = this.errorId;
        return event;
    }
    get isDisposable() {
        return false;
    }
}
IOErrorEvent.IO_ERROR = "ioError";
exports.IOErrorEvent = IOErrorEvent;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/ImageResource.js":
/*!*************************************************!*\
  !*** ./js-compile/raw-pixi-ts/ImageResource.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseImageResource_1 = __webpack_require__(/*! ./BaseImageResource */ "./js-compile/raw-pixi-ts/BaseImageResource.js");
const DisplaySettings_1 = __webpack_require__(/*! ./DisplaySettings */ "./js-compile/raw-pixi-ts/DisplaySettings.js");
const Logger_1 = __webpack_require__(/*! ./Logger */ "./js-compile/raw-pixi-ts/Logger.js");
class ImageResource extends BaseImageResource_1.BaseImageResource {
    constructor(source, options = {}) {
        super(source);
        if (!(source instanceof HTMLImageElement)) {
            var imageElement = new Image();
            // BaseImageResource.crossOrigin(imageElement, source, options.crossorigin);
            imageElement.src = source;
            source = imageElement;
            this.source = source;
        }
        /**
         * URL of the image source
         * @member {string}
         */
        this.url = source.src;
        /**
         * When process is completed
         * @member {Promise<void>}
         * @private
         */
        this._process = null;
        /**
         * If the image should be disposed after upload
         * @member {boolean}
         * @default false
         */
        this.preserveBitmap = false;
        /**
         * If capable, convert the image using createImageBitmap API
         * @member {boolean}
         * @default PIXI.settings.CREATE_IMAGE_BITMAP
         */
        this.createBitmap = options.createBitmap !== false && DisplaySettings_1.DisplaySettings.CREATE_IMAGE_BITMAP && !!window.createImageBitmap;
        /**
         * Controls texture premultiplyAlpha field
         * Copies from options
         * @member {boolean|null}
         * @readonly
         */
        this.premultiplyAlpha = options.premultiplyAlpha !== false;
        /**
         * The ImageBitmap element created for HTMLImageElement
         * @member {ImageBitmap}
         * @default null
         */
        this.bitmap = null;
        /**
         * Promise when loading
         * @member {Promise<void>}
         * @private
         * @default null
         */
        this._load = null;
        if (options.autoLoad !== false) {
            this.load();
        }
    }
    /**
     * returns a promise when image will be loaded and processed
     *
     * @param {boolean} [createBitmap=true] whether process image into bitmap
     * @returns {Promise<void>}
     */
    load(createBitmap = undefined) {
        if (createBitmap !== undefined) {
            this.createBitmap = createBitmap;
        }
        if (this._load) {
            return this._load;
        }
        this._load = new Promise((resolve) => {
            Logger_1.trace("source " + this.source);
            this.url = this.source.src;
            var ref = this;
            var source = ref.source;
            var completed = () => {
                if (this.destroyed) {
                    return;
                }
                source.onload = null;
                source.onerror = null;
                this.resize(source.width, source.height);
                this._load = null;
                if (this.createBitmap) {
                    resolve(this.process());
                }
                else {
                    resolve(this);
                }
            };
            if (source.complete && source.src) {
                completed();
            }
            else {
                source.onload = completed;
            }
        });
        return this._load;
    }
    ;
    /**
    * Called when we need to convert image into BitmapImage.
    * Can be called multiple times, real promise is cached inside.
    *
    * @returns {Promise<void>} cached promise to fill that bitmap
    */
    process() {
        if (this._process !== null) {
            return this._process;
        }
        if (this.bitmap !== null || !window.createImageBitmap) {
            return Promise.resolve(this);
        }
        this._process = window.createImageBitmap(this.source, 0, 0, this.source.width, this.source.height)
            .then((bitmap) => {
            if (this.destroyed) {
                return Promise.reject("");
            }
            this.bitmap = bitmap;
            this.update(0);
            this._process = null;
            return Promise.resolve(this);
        });
        return this._process;
    }
    ;
    /**
    * Upload the image resource to GPU.
    *
    * @param {PIXI.Renderer} renderer - Renderer to upload to
    * @param {PIXI.BaseTexture} baseTexture - BaseTexture for this resource
    * @param {PIXI.GLTexture} glTexture - GLTexture to use
    * @returns {boolean} true is success
    */
    upload(renderer, baseTexture, glTexture) {
        baseTexture.premultiplyAlpha = this.premultiplyAlpha;
        // reveal(this.bitmap)
        if (!this.createBitmap) {
            return super.upload(renderer, baseTexture, glTexture);
        }
        if (!this.bitmap) {
            // yeah, ignore the output
            this.process();
            if (!this.bitmap) {
                return false;
            }
        }
        Logger_1.trace("uploading");
        super.upload(renderer, baseTexture, glTexture, this.bitmap);
        if (!this.preserveBitmap) {
            // checks if there are other renderers that possibly need this bitmap
            var flag = true;
            for (var key in baseTexture._glTextures) {
                var otherTex = baseTexture._glTextures[key];
                if (otherTex !== glTexture && otherTex.dirtyId !== baseTexture.dirtyId) {
                    flag = false;
                    break;
                }
            }
            if (flag) {
                if (this.bitmap.close) {
                    this.bitmap.close();
                }
                Logger_1.trace("bitmap flagged");
                this.bitmap = null;
            }
        }
        return true;
    }
    ;
    /**
    * Destroys this texture
    * @override
    */
    dispose() {
        super.dispose();
        if (this.bitmap) {
            this.bitmap.close();
            this.bitmap = null;
        }
        this._process = null;
        this._load = null;
    }
    ;
}
exports.ImageResource = ImageResource;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/InteractionData.js":
/*!***************************************************!*\
  !*** ./js-compile/raw-pixi-ts/InteractionData.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Point_1 = __webpack_require__(/*! ./Point */ "./js-compile/raw-pixi-ts/Point.js");
class InteractionData {
    constructor() {
        this.global = new Point_1.Point();
        this.target = null;
        this.originalEvent = null;
        this.identifier = null;
        this.isPrimary = false;
        this.button = 0;
        this.buttons = 0;
        this.width = 0;
        this.height = 0;
        this.tiltX = 0;
        this.tiltY = 0;
        this.pointerType = null;
        this.pressure = 0;
        this.rotationAngle = 0;
        this.twist = 0;
        this.tangentialPressure = 0;
        this.which = 0;
    }
    getLocalPosition(displayObject, point = null, globalPos = null) {
        return displayObject.worldTransform.applyInverse(globalPos || this.global, point);
    }
    ;
    copyEvent(event) {
        if (event.isPrimary) {
            this.isPrimary = true;
        }
        this.button = event.button;
        this.buttons = Number.isInteger(event.buttons) ? event.buttons : event.which;
        this.width = event.width;
        this.height = event.height;
        this.tiltX = event.tiltX;
        this.tiltY = event.tiltY;
        this.pointerType = event.pointerType;
        this.pressure = event.pressure;
        this.rotationAngle = event.rotationAngle;
        this.twist = event.twist || 0;
        this.tangentialPressure = event.tangentialPressure || 0;
    }
    ;
    get pointerId() {
        return this.identifier;
    }
    ;
    reset() {
        this.isPrimary = false;
    }
    ;
}
exports.InteractionData = InteractionData;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/InteractionEvent.js":
/*!****************************************************!*\
  !*** ./js-compile/raw-pixi-ts/InteractionEvent.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Event_1 = __webpack_require__(/*! ./Event */ "./js-compile/raw-pixi-ts/Event.js");
class InteractionEvent extends Event_1.Event {
    constructor(type, bubble = true, cancelable = true) {
        super(type, bubble, cancelable);
        this.target = null;
        this.stopped = false;
        this._currentTarget = null;
        this._type = null;
        this.data = null;
    }
    reset() {
        this.stopped = false;
        this._currentTarget = null;
        this.target = null;
    }
    ;
    stopPropagation() {
        this.stopped = true;
    }
    ;
}
exports.InteractionEvent = InteractionEvent;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/InteractionManager.js":
/*!******************************************************!*\
  !*** ./js-compile/raw-pixi-ts/InteractionManager.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const InteractionData_1 = __webpack_require__(/*! ./InteractionData */ "./js-compile/raw-pixi-ts/InteractionData.js");
const InteractionEvent_1 = __webpack_require__(/*! ./InteractionEvent */ "./js-compile/raw-pixi-ts/InteractionEvent.js");
const MouseEvent_1 = __webpack_require__(/*! ./MouseEvent */ "./js-compile/raw-pixi-ts/MouseEvent.js");
const InteractionTrackingData_1 = __webpack_require__(/*! ./InteractionTrackingData */ "./js-compile/raw-pixi-ts/InteractionTrackingData.js");
const Ticker_1 = __webpack_require__(/*! ./Ticker */ "./js-compile/raw-pixi-ts/Ticker.js");
const Point_1 = __webpack_require__(/*! ./Point */ "./js-compile/raw-pixi-ts/Point.js");
const Container_1 = __webpack_require__(/*! ./Container */ "./js-compile/raw-pixi-ts/Container.js");
const Rectangle_1 = __webpack_require__(/*! ./Rectangle */ "./js-compile/raw-pixi-ts/Rectangle.js");
const EventDispatcher_1 = __webpack_require__(/*! ./EventDispatcher */ "./js-compile/raw-pixi-ts/EventDispatcher.js");
class InteractionManager extends EventDispatcher_1.EventDispatcher {
    constructor(renderer) {
        super();
        this.update = (deltaTime) => {
            this._deltaTime += deltaTime;
            if (this._deltaTime < this.interactionFrequency) {
                return;
            }
            this._deltaTime = 0;
            if (!this.interactionDOMElement) {
                return;
            }
            if (this.didMove) {
                this.didMove = false;
                return;
            }
            this.cursor = null;
            for (let k in this.activeInteractionData) {
                if (this.activeInteractionData.hasOwnProperty(k)) {
                    let interactionData = this.activeInteractionData[k];
                    if (interactionData.originalEvent && interactionData.pointerType !== 'touch') {
                        let interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, interactionData.originalEvent, interactionData);
                        this.processInteractive(interactionEvent, this.renderer._lastObjectRendered, this.processPointerOverOut, true);
                    }
                }
            }
            this.setCursorMode(this.cursor);
        };
        this.onPointerUp = (event) => {
            if (this.supportsTouchEvents && event.pointerType === 'touch') {
                return;
            }
            this.onPointerComplete(event, false, this.processPointerUp);
        };
        this.onPointerCancel = (event) => {
            if (this.supportsTouchEvents && event.pointerType === 'touch') {
                return;
            }
            this.onPointerComplete(event, true, this.processPointerCancel);
        };
        this.onPointerOver = (originalEvent) => {
            let events = this.normalizeToPointerData(originalEvent);
            let event = events[0];
            let interactionData = this.getInteractionDataForPointerId(event);
            let interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);
            interactionEvent.data.originalEvent = event;
            if (event.pointerType === 'mouse') {
                this.mouseOverRenderer = true;
            }
            let pointer = new MouseEvent_1.MouseEvent(MouseEvent_1.MouseEvent.POINTER_OVER);
            pointer.data = interactionData;
            this.dispatchEvent(pointer);
            if (event.pointerType === 'mouse' || event.pointerType === 'pen') {
                let pointer = new MouseEvent_1.MouseEvent(MouseEvent_1.MouseEvent.MOUSE_OVER);
                pointer.data = interactionData;
                this.dispatchEvent(pointer);
                this.dispatchEvent(pointer);
            }
        };
        this.onPointerOut = (originalEvent) => {
            if (this.supportsTouchEvents && originalEvent.pointerType === 'touch') {
                return;
            }
            let events = this.normalizeToPointerData(originalEvent);
            let event = events[0];
            if (event.pointerType === 'mouse') {
                this.mouseOverRenderer = false;
                this.setCursorMode(null);
            }
            let interactionData = this.getInteractionDataForPointerId(event);
            let interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);
            interactionEvent.data.originalEvent = event;
            this.processInteractive(interactionEvent, this.renderer._lastObjectRendered, this.processPointerOverOut, false);
            let pointer = new MouseEvent_1.MouseEvent(MouseEvent_1.MouseEvent.POINTER_OUT);
            pointer.data = interactionData;
            this.dispatchEvent(pointer);
            if (event.pointerType === 'mouse' || event.pointerType === 'pen') {
                let pointer = new MouseEvent_1.MouseEvent(MouseEvent_1.MouseEvent.MOUSE_OUT);
                pointer.data = interactionData;
                this.dispatchEvent(pointer);
            }
            else {
                this.releaseInteractionDataForPointerId(interactionData.identifier);
            }
        };
        this.onPointerDown = (originalEvent) => {
            if (this.supportsTouchEvents && originalEvent.pointerType === 'touch') {
                return;
            }
            let events = this.normalizeToPointerData(originalEvent);
            let event = events[0];
            if (this.autoPreventDefault && event.isNormalized) {
                let cancelable = originalEvent.cancelable || !('cancelable' in originalEvent);
                if (cancelable) {
                    originalEvent.preventDefault();
                }
            }
            let eventLen = events.length;
            for (let i = 0; i < eventLen; i++) {
                let event = events[i];
                let interactionData = this.getInteractionDataForPointerId(event);
                let interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);
                interactionEvent.data.originalEvent = originalEvent;
                let result = this.processInteractive(interactionEvent, this.renderer._lastObjectRendered, this.processPointerDown, true);
                let pointer = new MouseEvent_1.MouseEvent(MouseEvent_1.MouseEvent.POINTER_DOWN);
                pointer.data = interactionData;
                this.dispatchEvent(pointer);
                if (event.pointerType === 'touch') {
                    let pointer = new MouseEvent_1.MouseEvent(MouseEvent_1.MouseEvent.TOUCH_START);
                    pointer.data = interactionData;
                    this.dispatchEvent(pointer);
                }
                else if (event.pointerType === 'mouse' || event.pointerType === 'pen') {
                    let isRightButton = event.button === 2;
                    let pointer = new MouseEvent_1.MouseEvent(isRightButton ? MouseEvent_1.MouseEvent.RIGHT_MOUSE_DOWN : MouseEvent_1.MouseEvent.MOUSE_DOWN);
                    pointer.data = interactionData;
                    this.dispatchEvent(pointer);
                }
            }
        };
        this.onPointerMove = (originalEvent) => {
            if (this.supportsTouchEvents && originalEvent.pointerType === 'touch') {
                return;
            }
            let events = this.normalizeToPointerData(originalEvent);
            if (events[0].pointerType === 'mouse' || events[0].pointerType === 'pen') {
                this.didMove = true;
                this.cursor = null;
            }
            let eventLen = events.length;
            for (var i = 0; i < eventLen; i++) {
                let event = events[i];
                let interactionData = this.getInteractionDataForPointerId(event);
                let interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);
                interactionEvent.data.originalEvent = originalEvent;
                let interactive = event.pointerType === 'touch' ? this.moveWhenInside : true;
                this.processInteractive(interactionEvent, this.renderer._lastObjectRendered, this.processPointerMove, interactive);
                let pointer = new MouseEvent_1.MouseEvent(MouseEvent_1.MouseEvent.POINTER_MOVE);
                pointer.data = interactionData;
                this.dispatchEvent(pointer);
                if (event.pointerType === 'touch') {
                    let pointer = new MouseEvent_1.MouseEvent(MouseEvent_1.MouseEvent.TOUCH_MOVE);
                    pointer.data = interactionData;
                    this.dispatchEvent(pointer);
                }
                if (event.pointerType === 'mouse' || event.pointerType === 'pen') {
                    let pointer = new MouseEvent_1.MouseEvent(MouseEvent_1.MouseEvent.MOUSE_MOVE);
                    pointer.data = interactionData;
                    this.dispatchEvent(pointer);
                }
            }
            if (events[0].pointerType === 'mouse') {
                this.setCursorMode(this.cursor);
            }
        };
        this.processPointerDown = (interactionEvent, displayObject, hit) => {
            let data = interactionEvent.data;
            let id = interactionEvent.data.identifier;
            if (hit) {
                if (!displayObject.trackedPointers[id]) {
                    displayObject.trackedPointers[id] = new InteractionTrackingData_1.InteractionTrackingData(id);
                }
                let pointer = new MouseEvent_1.MouseEvent(MouseEvent_1.MouseEvent.POINTER_DOWN);
                pointer.data = data;
                displayObject.dispatchEvent(pointer);
                if (data.pointerType === 'touch') {
                    let pointer = new MouseEvent_1.MouseEvent(MouseEvent_1.MouseEvent.TOUCH_START);
                    pointer.data = data;
                    displayObject.dispatchEvent(pointer);
                }
                else if (data.pointerType === 'mouse' || data.pointerType === 'pen') {
                    let isRightButton = data.button === 2;
                    if (isRightButton) {
                        displayObject.trackedPointers[id].rightDown = true;
                    }
                    else {
                        displayObject.trackedPointers[id].leftDown = true;
                    }
                    let pointer = new MouseEvent_1.MouseEvent(isRightButton ? MouseEvent_1.MouseEvent.RIGHT_MOUSE_DOWN : MouseEvent_1.MouseEvent.MOUSE_DOWN);
                    pointer.data = data;
                    displayObject.dispatchEvent(pointer);
                }
            }
        };
        this.processPointerUp = (interactionEvent, displayObject, hit) => {
            let data = interactionEvent.data;
            let id = interactionEvent.data.identifier;
            let trackingData = displayObject.trackedPointers[id];
            let isTouch = data.pointerType === 'touch';
            let isMouse = (data.pointerType === 'mouse' || data.pointerType === 'pen');
            let isMouseTap = false;
            if (isMouse) {
                let isRightButton = data.button === 2;
                let flags = InteractionTrackingData_1.InteractionTrackingData.FLAGS;
                let test = isRightButton ? flags.RIGHT_DOWN : flags.LEFT_DOWN;
                let isDown = trackingData !== undefined && (trackingData.flags & test);
                if (hit) {
                    let pointer = new MouseEvent_1.MouseEvent(isRightButton ? MouseEvent_1.MouseEvent.RIGHT_MOUSE_UP : MouseEvent_1.MouseEvent.MOUSE_UP);
                    pointer.data = data;
                    displayObject.dispatchEvent(pointer);
                    if (isDown) {
                        let pointer = new MouseEvent_1.MouseEvent(isRightButton ? MouseEvent_1.MouseEvent.RIGHT_CLICK : MouseEvent_1.MouseEvent.CLICK);
                        pointer.data = data;
                        displayObject.dispatchEvent(pointer);
                        isMouseTap = true;
                    }
                }
                else if (isDown) {
                    let pointer = new MouseEvent_1.MouseEvent(isRightButton ? MouseEvent_1.MouseEvent.RIGHT_MOUSE_UP_OUTSIDE : MouseEvent_1.MouseEvent.MOUSE_UP_OUTSIDE);
                    pointer.data = data;
                    displayObject.dispatchEvent(pointer);
                }
                if (trackingData) {
                    if (isRightButton) {
                        trackingData.rightDown = false;
                    }
                    else {
                        trackingData.leftDown = false;
                    }
                }
            }
            if (hit) {
                let pointer = new MouseEvent_1.MouseEvent(MouseEvent_1.MouseEvent.POINTER_UP);
                pointer.data = data;
                displayObject.dispatchEvent(pointer);
                if (isTouch) {
                    let pointer = new MouseEvent_1.MouseEvent(MouseEvent_1.MouseEvent.TOUCH_END);
                    pointer.data = data;
                    displayObject.dispatchEvent(pointer);
                }
                if (trackingData) {
                    if (!isMouse || isMouseTap) {
                        let pointer = new MouseEvent_1.MouseEvent(MouseEvent_1.MouseEvent.POINTER_TAP);
                        pointer.data = data;
                        displayObject.dispatchEvent(pointer);
                    }
                    if (isTouch) {
                        let pointer = new MouseEvent_1.MouseEvent(MouseEvent_1.MouseEvent.TOUCH_TAP);
                        pointer.data = data;
                        displayObject.dispatchEvent(pointer);
                        trackingData.over = false;
                    }
                }
            }
            else if (trackingData) {
                let pointer = new MouseEvent_1.MouseEvent(MouseEvent_1.MouseEvent.POINTER_UP_OUTSIDE);
                pointer.data = data;
                displayObject.dispatchEvent(pointer);
                if (isTouch) {
                    let pointer = new MouseEvent_1.MouseEvent(MouseEvent_1.MouseEvent.TOUCH_END_OUTSIDE);
                    pointer.data = data;
                    displayObject.dispatchEvent(pointer);
                }
            }
            if (trackingData && trackingData.none) {
                delete displayObject.trackedPointers[id];
            }
        };
        this.processPointerMove = (interactionEvent, displayObject, hit) => {
            let data = interactionEvent.data;
            let isTouch = data.pointerType === 'touch';
            let isMouse = (data.pointerType === 'mouse' || data.pointerType === 'pen');
            if (isMouse) {
                this.processPointerOverOut(interactionEvent, displayObject, hit);
            }
            if (!this.moveWhenInside || hit) {
                let pointer = new MouseEvent_1.MouseEvent(MouseEvent_1.MouseEvent.POINTER_MOVE);
                pointer.data = data;
                displayObject.dispatchEvent(pointer);
                if (isTouch) {
                    let pointer = new MouseEvent_1.MouseEvent(MouseEvent_1.MouseEvent.TOUCH_MOVE);
                    pointer.data = data;
                    displayObject.dispatchEvent(pointer);
                }
                if (isMouse) {
                    let pointer = new MouseEvent_1.MouseEvent(MouseEvent_1.MouseEvent.MOUSE_MOVE);
                    pointer.data = data;
                    displayObject.dispatchEvent(pointer);
                }
            }
        };
        this.processPointerOverOut = (interactionEvent, displayObject, hit) => {
            let data = interactionEvent.data;
            let id = interactionEvent.data.identifier;
            let isMouse = (data.pointerType === 'mouse' || data.pointerType === 'pen');
            let trackingData = displayObject.trackedPointers[id];
            if (hit && !trackingData) {
                trackingData = displayObject.trackedPointers[id] = new InteractionTrackingData_1.InteractionTrackingData(id);
            }
            if (trackingData === undefined) {
                return;
            }
            if (hit && this.mouseOverRenderer) {
                if (!trackingData.over) {
                    trackingData.over = true;
                    let pointer = new MouseEvent_1.MouseEvent(MouseEvent_1.MouseEvent.POINTER_OVER);
                    pointer.data = data;
                    displayObject.dispatchEvent(pointer);
                    if (isMouse) {
                        let pointer = new MouseEvent_1.MouseEvent(MouseEvent_1.MouseEvent.MOUSE_OVER);
                        pointer.data = data;
                        displayObject.dispatchEvent(pointer);
                    }
                }
                if (isMouse && this.cursor === null) {
                    this.cursor = displayObject.cursor;
                }
            }
            else if (trackingData.over) {
                trackingData.over = false;
                let pointer = new MouseEvent_1.MouseEvent(MouseEvent_1.MouseEvent.POINTER_OUT);
                pointer.data = data;
                displayObject.dispatchEvent(pointer);
                if (isMouse) {
                    let pointer = new MouseEvent_1.MouseEvent(MouseEvent_1.MouseEvent.MOUSE_OUT);
                    pointer.data = data;
                    displayObject.dispatchEvent(pointer);
                }
                if (trackingData.none) {
                    delete displayObject.trackedPointers[id];
                }
            }
        };
        this.hitTestEvent = new InteractionEvent_1.InteractionEvent(null, null, null);
        this.hitTestEvent.target = null;
        this.renderer = renderer;
        this.autoPreventDefault = true;
        this.interactionFrequency = 10;
        this.mouse = new InteractionData_1.InteractionData();
        this.mouse.identifier = InteractionManager.MOUSE_POINTER_ID;
        this.mouse.global.set(-999999);
        this.activeInteractionData = {};
        this.activeInteractionData[InteractionManager.MOUSE_POINTER_ID] = this.mouse;
        this.interactionDataPool = [];
        this.eventData = new InteractionEvent_1.InteractionEvent("interaction");
        this.interactionDOMElement = null;
        this.moveWhenInside = false;
        this.eventsAdded = false;
        this.mouseOverRenderer = false;
        this.supportsTouchEvents = 'ontouchstart' in window;
        this.supportsPointerEvents = !!window['PointerEvent'];
        this.cursorStyles = {
            default: 'inherit',
            pointer: 'pointer'
        };
        this.currentCursorMode = null;
        this.cursor = null;
        this._tempPoint = new Point_1.Point();
        this.resolution = 1;
        this.setTargetElement(this.renderer.view, this.renderer.resolution);
    }
    setTargetElement(element, resolution = 1) {
        this.removeEvents();
        this.interactionDOMElement = element;
        this.resolution = resolution;
        this.addEvents();
    }
    ;
    removeEvents() {
        if (!this.interactionDOMElement) {
            return;
        }
        Ticker_1.Ticker.system.remove(this.update);
        if (window.navigator.msPointerEnabled) {
            this.interactionDOMElement.style['-ms-content-zooming'] = '';
            this.interactionDOMElement.style['-ms-touch-action'] = '';
        }
        else if (this.supportsPointerEvents) {
            this.interactionDOMElement.style['touch-action'] = '';
        }
        if (this.supportsPointerEvents) {
            window.document.removeEventListener('pointermove', this.onPointerMove);
            this.interactionDOMElement.removeEventListener('pointerdown', this.onPointerDown);
            this.interactionDOMElement.removeEventListener('pointerleave', this.onPointerOut);
            this.interactionDOMElement.removeEventListener('pointerover', this.onPointerOver);
            window.removeEventListener('pointercancel', this.onPointerCancel);
            window.removeEventListener('pointerup', this.onPointerUp);
        }
        else {
            window.document.removeEventListener('mousemove', this.onPointerMove);
            this.interactionDOMElement.removeEventListener('mousedown', this.onPointerDown);
            this.interactionDOMElement.removeEventListener('mouseout', this.onPointerOut);
            this.interactionDOMElement.removeEventListener('mouseover', this.onPointerOver);
            window.removeEventListener('mouseup', this.onPointerUp);
        }
        if (this.supportsTouchEvents) {
            this.interactionDOMElement.removeEventListener('touchstart', this.onPointerDown);
            this.interactionDOMElement.removeEventListener('touchcancel', this.onPointerCancel);
            this.interactionDOMElement.removeEventListener('touchend', this.onPointerUp);
            this.interactionDOMElement.removeEventListener('touchmove', this.onPointerMove);
        }
        this.interactionDOMElement = null;
        this.eventsAdded = false;
    }
    ;
    mapPositionToPoint(point, x, y) {
        let rect;
        if (!this.interactionDOMElement.parentElement) {
            rect = new Rectangle_1.Rectangle();
        }
        else {
            rect = this.interactionDOMElement.getBoundingClientRect();
        }
        let resolutionMultiplier = 1.0 / this.resolution;
        point.x = ((x - rect.left) * (this.interactionDOMElement.width / rect.width)) * resolutionMultiplier;
        point.y = ((y - rect.top) * (this.interactionDOMElement.height / rect.height)) * resolutionMultiplier;
    }
    ;
    configureInteractionEventForDOMEvent(interactionEvent, pointerEvent, interactionData) {
        interactionEvent.data = interactionData;
        this.mapPositionToPoint(interactionData.global, pointerEvent.clientX, pointerEvent.clientY);
        if (pointerEvent.pointerType === 'touch') {
            pointerEvent.globalX = interactionData.global.x;
            pointerEvent.globalY = interactionData.global.y;
        }
        interactionData.originalEvent = pointerEvent;
        interactionEvent.reset();
        return interactionEvent;
    }
    ;
    addEvents() {
        if (!this.interactionDOMElement) {
            return;
        }
        Ticker_1.Ticker.system.add(this.update, this, Ticker_1.Ticker.UPDATE_PRIORITY.INTERACTION);
        if (window.navigator.msPointerEnabled) {
            this.interactionDOMElement.style['-ms-content-zooming'] = 'none';
            this.interactionDOMElement.style['-ms-touch-action'] = 'none';
        }
        else if (this.supportsPointerEvents) {
            this.interactionDOMElement.style['touch-action'] = 'none';
        }
        if (this.supportsPointerEvents) {
            window.document.addEventListener('pointermove', this.onPointerMove);
            this.interactionDOMElement.addEventListener('pointerdown', this.onPointerDown);
            this.interactionDOMElement.addEventListener('pointerleave', this.onPointerOut);
            this.interactionDOMElement.addEventListener('pointerover', this.onPointerOver);
            window.addEventListener('pointercancel', this.onPointerCancel);
            window.addEventListener('pointerup', this.onPointerUp);
        }
        else {
            window.document.addEventListener('mousemove', this.onPointerMove);
            this.interactionDOMElement.addEventListener('mousedown', this.onPointerDown);
            this.interactionDOMElement.addEventListener('mouseout', this.onPointerOut);
            this.interactionDOMElement.addEventListener('mouseover', this.onPointerOver);
            window.addEventListener('mouseup', this.onPointerUp);
        }
        if (this.supportsTouchEvents) {
            this.interactionDOMElement.addEventListener('touchstart', this.onPointerDown);
            this.interactionDOMElement.addEventListener('touchcancel', this.onPointerCancel);
            this.interactionDOMElement.addEventListener('touchend', this.onPointerUp);
            this.interactionDOMElement.addEventListener('touchmove', this.onPointerMove);
        }
        this.eventsAdded = true;
    }
    ;
    processInteractive(interactionEvent, displayObject, func, hitTest, interactive = true) {
        if (!displayObject || !displayObject.visible) {
            return false;
        }
        let point = interactionEvent.data.global;
        interactive = displayObject.interactive || interactive;
        let hit = false;
        let interactiveParent = interactive;
        let hitTestChildren = true;
        if (displayObject.hitArea) {
            if (hitTest) {
                displayObject.worldTransform.applyInverse(point, this._tempPoint);
                if (!displayObject.hitArea.contains(this._tempPoint.x, this._tempPoint.y)) {
                    hitTest = false;
                    hitTestChildren = false;
                }
                else {
                    hit = true;
                }
            }
            interactiveParent = false;
        }
        else if (displayObject._mask) {
            if (hitTest) {
                if (!(displayObject._mask.containsPoint && displayObject._mask.containsPoint(point))) {
                    hitTest = false;
                    hitTestChildren = false;
                }
            }
        }
        if (displayObject instanceof Container_1.Container) {
            if (hitTestChildren && displayObject.interactiveChildren && displayObject.children) {
                let children = displayObject.children;
                for (let i = children.length - 1; i >= 0; i--) {
                    let child = children[i];
                    let childHit = this.processInteractive(interactionEvent, child, func, hitTest, interactiveParent);
                    if (childHit) {
                        if (!child.parent) {
                            continue;
                        }
                        interactiveParent = false;
                        if (childHit) {
                            if (interactionEvent.target) {
                                hitTest = false;
                            }
                            hit = true;
                        }
                    }
                }
            }
        }
        if (interactive) {
            if (hitTest && !interactionEvent.target) {
                if (!displayObject.hitArea && displayObject.containsPoint) {
                    if (displayObject.containsPoint(point)) {
                        hit = true;
                    }
                }
            }
            if (displayObject.interactive) {
                if (hit && !interactionEvent.target) {
                    interactionEvent.target = displayObject;
                }
                if (func) {
                    func(interactionEvent, displayObject, !!hit);
                }
            }
        }
        return hit;
    }
    ;
    setCursorMode(mode = "default") {
        if (this.currentCursorMode === mode) {
            return;
        }
        this.currentCursorMode = mode;
        let style = this.cursorStyles[mode];
        if (style) {
            switch (typeof style) {
                case 'string':
                    this.interactionDOMElement.style.cursor = style;
                    break;
                case 'function':
                    style(mode);
                    break;
                case 'object':
                    Object.assign(this.interactionDOMElement.style, style);
                    break;
            }
        }
        else if (typeof mode === 'string' && !Object.prototype.hasOwnProperty.call(this.cursorStyles, mode)) {
            this.interactionDOMElement.style.cursor = mode;
        }
    }
    ;
    hitTest(globalPoint, root) {
        this.hitTestEvent.target = null;
        this.hitTestEvent.data.global = globalPoint;
        let currentdisplay;
        if (root) {
            currentdisplay = root;
        }
        else {
            currentdisplay = this.renderer._lastObjectRendered;
        }
        this.processInteractive(this.hitTestEvent, currentdisplay, null, true);
        return this.hitTestEvent.target;
    }
    ;
    normalizeToPointerData(event) {
        let normalizedEvents = [];
        if (this.supportsTouchEvents && event instanceof TouchEvent) {
            for (let i = 0, li = event.changedTouches.length; i < li; i++) {
                let touch = event.changedTouches[i];
                if (typeof touch.button === 'undefined') {
                    touch.button = event.touches.length ? 1 : 0;
                }
                if (typeof touch.buttons === 'undefined') {
                    touch.buttons = event.touches.length ? 1 : 0;
                }
                if (typeof touch.isPrimary === 'undefined') {
                    touch.isPrimary = event.touches.length === 1 && event.type === 'touchstart';
                }
                if (typeof touch.width === 'undefined') {
                    touch.width = touch.radiusX || 1;
                }
                if (typeof touch.height === 'undefined') {
                    touch.height = touch.radiusY || 1;
                }
                if (typeof touch.tiltX === 'undefined') {
                    touch.tiltX = 0;
                }
                if (typeof touch.tiltY === 'undefined') {
                    touch.tiltY = 0;
                }
                if (typeof touch.pointerType === 'undefined') {
                    touch.pointerType = 'touch';
                }
                if (typeof touch.pointerId === 'undefined') {
                    touch.pointerId = touch.identifier || 0;
                }
                if (typeof touch.pressure === 'undefined') {
                    touch.pressure = touch.force || 0.5;
                }
                if (typeof touch.twist === 'undefined') {
                    touch.twist = 0;
                }
                if (typeof touch.tangentialPressure === 'undefined') {
                    touch.tangentialPressure = 0;
                }
                if (typeof touch.layerX === 'undefined') {
                    touch.layerX = touch.offsetX = touch.clientX;
                }
                if (typeof touch.layerY === 'undefined') {
                    touch.layerY = touch.offsetY = touch.clientY;
                }
                touch.isNormalized = true;
                normalizedEvents.push(touch);
            }
        }
        else if (event instanceof MouseEvent_1.MouseEvent && (!this.supportsPointerEvents || !(event instanceof window['PointerEvent']))) {
            let originevent = event;
            if (typeof originevent.isPrimary === 'undefined') {
                originevent.isPrimary = true;
            }
            if (typeof originevent.width === 'undefined') {
                originevent.width = 1;
            }
            if (typeof originevent.height === 'undefined') {
                originevent.height = 1;
            }
            if (typeof originevent.tiltX === 'undefined') {
                originevent.tiltX = 0;
            }
            if (typeof originevent.tiltY === 'undefined') {
                originevent.tiltY = 0;
            }
            if (typeof originevent.pointerType === 'undefined') {
                originevent.pointerType = 'mouse';
            }
            if (typeof originevent.pointerId === 'undefined') {
                originevent.pointerId = InteractionManager.MOUSE_POINTER_ID;
            }
            if (typeof originevent.pressure === 'undefined') {
                originevent.pressure = 0.5;
            }
            if (typeof originevent.twist === 'undefined') {
                originevent.twist = 0;
            }
            if (typeof originevent.tangentialPressure === 'undefined') {
                originevent.tangentialPressure = 0;
            }
            originevent.isNormalized = true;
            normalizedEvents.push(event);
        }
        else {
            normalizedEvents.push(event);
        }
        return normalizedEvents;
    }
    ;
    getInteractionDataForPointerId(event) {
        let pointerId = event.pointerId;
        let interactionData;
        if (pointerId === InteractionManager.MOUSE_POINTER_ID || event.pointerType === 'mouse') {
            interactionData = this.mouse;
        }
        else if (this.activeInteractionData[pointerId]) {
            interactionData = this.activeInteractionData[pointerId];
        }
        else {
            interactionData = this.interactionDataPool.pop() || new InteractionData_1.InteractionData();
            interactionData.identifier = pointerId;
            this.activeInteractionData[pointerId] = interactionData;
        }
        interactionData.copyEvent(event);
        return interactionData;
    }
    ;
    onPointerComplete(originalEvent, cancelled, func) {
        let events = this.normalizeToPointerData(originalEvent);
        let eventLen = events.length;
        let eventAppend = originalEvent.target !== this.interactionDOMElement ? 'outside' : '';
        for (let i = 0; i < eventLen; i++) {
            let event = events[i];
            let interactionData = this.getInteractionDataForPointerId(event);
            let interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);
            interactionEvent.data.originalEvent = originalEvent;
            this.processInteractive(interactionEvent, this.renderer._lastObjectRendered, func, cancelled || !eventAppend);
            let pointer = new MouseEvent_1.MouseEvent(cancelled ? MouseEvent_1.MouseEvent.POINTER_CANCEL : (MouseEvent_1.MouseEvent.POINTER_UP));
            pointer.data = interactionData;
            this.dispatchEvent(pointer);
            if (event.pointerType === 'mouse' || event.pointerType === 'pen') {
                let isRightButton = event.button === 2;
                let pointer = new MouseEvent_1.MouseEvent(isRightButton ? (MouseEvent_1.MouseEvent.RIGHT_MOUSE_UP) : (MouseEvent_1.MouseEvent.MOUSE_UP));
                pointer.data = interactionData;
                this.dispatchEvent(pointer);
            }
            else if (event.pointerType === 'touch') {
                let pointer = new MouseEvent_1.MouseEvent(cancelled ? MouseEvent_1.MouseEvent.TOUCH_CANCEL : (MouseEvent_1.MouseEvent.TOUCH_END));
                pointer.data = interactionData;
                this.dispatchEvent(pointer);
                this.releaseInteractionDataForPointerId(event.pointerId);
            }
        }
    }
    ;
    releaseInteractionDataForPointerId(pointerId) {
        let interactionData = this.activeInteractionData[pointerId];
        if (interactionData) {
            delete this.activeInteractionData[pointerId];
            interactionData.reset();
            this.interactionDataPool.push(interactionData);
        }
    }
    ;
    processPointerCancel(interactionEvent, displayObject) {
        let data = interactionEvent.data;
        let id = interactionEvent.data.identifier;
        if (displayObject.trackedPointers[id] !== undefined) {
            delete displayObject.trackedPointers[id];
            let pointer = new MouseEvent_1.MouseEvent(MouseEvent_1.MouseEvent.POINTER_CANCEL);
            pointer.data = data;
            displayObject.dispatchEvent(pointer);
            if (data.pointerType === 'touch') {
                let pointer = new MouseEvent_1.MouseEvent(MouseEvent_1.MouseEvent.TOUCH_CANCEL);
                pointer.data = data;
                displayObject.dispatchEvent(pointer);
            }
        }
    }
    ;
    destroy(options = null) {
        this.removeEvents();
        this.renderer = null;
        this.mouse = null;
        this.eventData = null;
        this.interactionDOMElement = null;
        this.onPointerDown = null;
        this.processPointerDown = null;
        this.onPointerUp = null;
        this.processPointerUp = null;
        this.onPointerCancel = null;
        this.processPointerCancel = null;
        this.onPointerMove = null;
        this.processPointerMove = null;
        this.onPointerOut = null;
        this.processPointerOverOut = null;
        this.onPointerOver = null;
        this._tempPoint = null;
    }
    ;
}
InteractionManager.MOUSE_POINTER_ID = 1;
exports.InteractionManager = InteractionManager;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/InteractionTrackingData.js":
/*!***********************************************************!*\
  !*** ./js-compile/raw-pixi-ts/InteractionTrackingData.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class InteractionTrackingData {
    constructor(pointerId) {
        this._pointerId = pointerId;
        this._flags = InteractionTrackingData.FLAGS.NONE;
    }
    _doSet(flag, yn) {
        if (yn) {
            this._flags = this._flags | flag;
        }
        else {
            this._flags = this._flags & (~flag);
        }
    }
    ;
    get pointerId() {
        return this._pointerId;
    }
    ;
    get flags() {
        return this._flags;
    }
    ;
    set flags(flags) {
        this._flags = flags;
    }
    ;
    get none() {
        return this._flags === InteractionTrackingData.FLAGS.NONE;
    }
    ;
    get over() {
        return (this._flags & InteractionTrackingData.FLAGS.OVER) !== 0;
    }
    ;
    set over(yn) {
        this._doSet(InteractionTrackingData.FLAGS.OVER, yn);
    }
    ;
    get rightDown() {
        return (this._flags & InteractionTrackingData.FLAGS.RIGHT_DOWN) !== 0;
    }
    ;
    set rightDown(yn) {
        this._doSet(InteractionTrackingData.FLAGS.RIGHT_DOWN, yn);
    }
    ;
    get leftDown() {
        return (this._flags & InteractionTrackingData.FLAGS.LEFT_DOWN) !== 0;
    }
    ;
    set leftDown(yn) {
        this._doSet(InteractionTrackingData.FLAGS.LEFT_DOWN, yn);
    }
    ;
}
InteractionTrackingData.FLAGS = {
    NONE: 0,
    OVER: 1 << 0,
    LEFT_DOWN: 1 << 1,
    RIGHT_DOWN: 1 << 2,
};
exports.InteractionTrackingData = InteractionTrackingData;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/LineStyle.js":
/*!*********************************************!*\
  !*** ./js-compile/raw-pixi-ts/LineStyle.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const FillStyle_1 = __webpack_require__(/*! ./FillStyle */ "./js-compile/raw-pixi-ts/FillStyle.js");
class LineStyle extends FillStyle_1.FillStyle {
    constructor() {
        super();
    }
    clone() {
        var obj = new LineStyle();
        obj.color = this.color;
        obj.alpha = this.alpha;
        obj.texture = this.texture;
        obj.matrix = this.matrix;
        obj.visible = this.visible;
        obj.width = this.width;
        obj.alignment = this.alignment;
        obj.native = this.native;
        return obj;
    }
    ;
    /**
     * Reset the line style to default.
     */
    reset() {
        super.reset();
        // Override default line style color
        this.color = 0x0;
        /**
         * The width (thickness) of any lines drawn.
         *
         * @member {number}
         * @default 0
         */
        this.width = 0;
        /**
         * The alignment of any lines drawn (0.5 = middle, 1 = outter, 0 = inner).
         *
         * @member {number}
         * @default 0
         */
        this.alignment = 0.5;
        /**
         * If true the lines will be draw using LINES instead of TRIANGLE_STRIP
         *
         * @member {boolean}
         * @default false
         */
        this.native = false;
    }
    ;
}
exports.LineStyle = LineStyle;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/Logger.js":
/*!******************************************!*\
  !*** ./js-compile/raw-pixi-ts/Logger.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.OUTPUT_TO_CONSOLE = true;
exports.trace = function (value) {
    try {
        if (!value) {
            if (isNaN(value)) {
                var result = "show: null";
            }
            else {
                var result = "show: 0";
            }
        }
        else {
            var result = "show: " + value.toString();
        }
        if (exports.OUTPUT_TO_CONSOLE) {
            console.log(result);
        }
        return result;
    }
    catch (e) {
    }
    return null;
};
exports.revealMethods = function (value) {
    try {
        if (!value) {
            var result = "reveal methods: null";
        }
        else {
            var result = "reveal methods: ";
        }
        for (var key in value) {
            var instanceItem = value[key];
            if (instanceItem instanceof Function) {
                result += 'method: ' + key + ' : ' + value[key] + "\n";
            }
        }
        if (exports.OUTPUT_TO_CONSOLE) {
            console.log(result);
        }
        return result;
    }
    catch (e) {
    }
    return null;
};
exports.reveal = function (value) {
    if (!value) {
        var result = "reveal: null";
        if (exports.OUTPUT_TO_CONSOLE) {
            console.log(result);
        }
        return;
    }
    if (value === undefined) {
        var result = "reveal: undefined";
        if (exports.OUTPUT_TO_CONSOLE) {
            console.log(result);
        }
        return;
    }
    var result = "reveal: ";
    for (var key in value) {
        var instanceItem = getValue(key, value);
        if (instanceItem) {
            if (instanceItem instanceof Function) {
                result += 'method: ' + key + "\n";
            }
            else {
                try {
                    result += key + ' : ' + instanceItem + "\n";
                }
                catch (e) {
                }
            }
        }
    }
    if (exports.OUTPUT_TO_CONSOLE) {
        console.log(result);
    }
    return result;
};
const getValue = function (key, value) {
    var valueResult = null;
    try {
        valueResult = value[key];
    }
    catch (e) {
    }
    return valueResult;
};


/***/ }),

/***/ "./js-compile/raw-pixi-ts/MaskSystem.js":
/*!**********************************************!*\
  !*** ./js-compile/raw-pixi-ts/MaskSystem.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const System_1 = __webpack_require__(/*! ./System */ "./js-compile/raw-pixi-ts/System.js");
const SpriteMaskFilter_1 = __webpack_require__(/*! ./SpriteMaskFilter */ "./js-compile/raw-pixi-ts/SpriteMaskFilter.js");
class MaskSystem extends System_1.System {
    constructor(renderer) {
        super(renderer);
        // TODO - we don't need both!
        /**
         * `true` if current pushed masked is scissor
         * @member {boolean}
         * @readonly
         */
        this.scissor = false;
        /**
         * Mask data
         * @member {PIXI.Graphics}
         * @readonly
         */
        this.scissorData = null;
        /**
         * Target to mask
         * @member {PIXI.DisplayObject}
         * @readonly
         */
        this.scissorRenderTarget = null;
        /**
         * Enable scissor
         * @member {boolean}
         * @readonly
         */
        this.enableScissor = false;
        /**
         * Pool of used sprite mask filters
         * @member {PIXI.SpriteMaskFilter[]}
         * @readonly
         */
        this.alphaMaskPool = [];
        /**
         * Current index of alpha mask pool
         * @member {number}
         * @default 0
         * @readonly
         */
        this.alphaMaskIndex = 0;
    }
    /**
     * Applies the Mask and adds it to the current filter stack.
     *
     * @param {PIXI.DisplayObject} target - Display Object to push the mask to
     * @param {PIXI.Sprite|PIXI.Graphics} maskData - The masking data.
     */
    push(target, maskData) {
        // TODO the root check means scissor rect will not
        // be used on render textures more info here:
        // https://github.com/pixijs/pixi.js/pull/3545
        if (maskData.isSprite) {
            this.pushSpriteMask(target, maskData);
        }
        else if (this.enableScissor
            && !this.scissor
            && this.renderer._activeRenderTarget.root
            && !this.renderer.stencil.stencilMaskStack.length
            && maskData.isFastRect()) {
            var matrix = maskData.worldTransform;
            var rot = Math.atan2(matrix.b, matrix.a);
            // use the nearest degree!
            rot = Math.round(rot * (180 / Math.PI));
            if (rot % 90) {
                this.pushStencilMask(maskData);
            }
            else {
                this.pushScissorMask(target, maskData);
            }
        }
        else {
            this.pushStencilMask(maskData);
        }
    }
    ;
    /**
     * Removes the last mask from the mask stack and doesn't return it.
     *
     * @param {PIXI.DisplayObject} target - Display Object to pop the mask from
     * @param {PIXI.Sprite|PIXI.Graphics} maskData - The masking data.
     */
    pop(target, maskData) {
        if (maskData.isSprite) {
            this.popSpriteMask(target, maskData);
        }
        else if (this.enableScissor && !this.renderer.stencil.stencilMaskStack.length) {
            this.popScissorMask(target, maskData);
        }
        else {
            this.popStencilMask(target, maskData);
        }
    }
    ;
    /**
     * Applies the Mask and adds it to the current filter stack.
     *
     * @param {PIXI.RenderTexture} target - Display Object to push the sprite mask to
     * @param {PIXI.Sprite} maskData - Sprite to be used as the mask
     */
    pushSpriteMask(target, maskData) {
        var alphaMaskFilter = this.alphaMaskPool[this.alphaMaskIndex];
        if (!alphaMaskFilter) {
            alphaMaskFilter = this.alphaMaskPool[this.alphaMaskIndex] = [new SpriteMaskFilter_1.SpriteMaskFilter(maskData)];
        }
        alphaMaskFilter[0].resolution = this.renderer.resolution;
        alphaMaskFilter[0].maskSprite = maskData;
        var stashFilterArea = target.filterArea;
        target.filterArea = maskData.getBounds(true);
        this.renderer.filter.push(target, alphaMaskFilter);
        target.filterArea = stashFilterArea;
        this.alphaMaskIndex++;
    }
    ;
    /**
     * Removes the last filter from the filter stack and doesn't return it.
     *
     */
    popSpriteMask(a, b) {
        this.renderer.filter.pop();
        this.alphaMaskIndex--;
    }
    ;
    /**
     * Applies the Mask and adds it to the current filter stack.
     *
     * @param {PIXI.Sprite|PIXI.Graphics} maskData - The masking data.
     */
    pushStencilMask(maskData) {
        this.renderer.batch.flush();
        this.renderer.stencil.pushStencil(maskData);
    }
    ;
    /**
     * Removes the last filter from the filter stack and doesn't return it.
     *
     */
    popStencilMask(a, b) {
        // this.renderer.currentRenderer.stop();
        this.renderer.stencil.popStencil();
    }
    ;
    /**
     *
     * @param {PIXI.DisplayObject} target - Display Object to push the mask to
     * @param {PIXI.Graphics} maskData - The masking data.
     */
    pushScissorMask(target, maskData) {
        maskData.renderable = true;
        var renderTarget = this.renderer._activeRenderTarget;
        var bounds = maskData.getBounds();
        bounds.fit(renderTarget.size);
        maskData.renderable = false;
        this.renderer.gl.enable(this.renderer.gl.SCISSOR_TEST);
        var resolution = this.renderer.resolution;
        this.renderer.gl.scissor(bounds.x * resolution, (renderTarget.root ? renderTarget.size.height - bounds.y - bounds.height : bounds.y) * resolution, bounds.width * resolution, bounds.height * resolution);
        this.scissorRenderTarget = renderTarget;
        this.scissorData = maskData;
        this.scissor = true;
    }
    ;
    /**
     * Pop scissor mask
     *
     */
    popScissorMask(a, b) {
        this.scissorRenderTarget = null;
        this.scissorData = null;
        this.scissor = false;
        // must be scissor!
        var ref = this.renderer;
        var gl = ref.gl;
        gl.disable(gl.SCISSOR_TEST);
    }
    ;
}
exports.MaskSystem = MaskSystem;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/MathSettings.js":
/*!************************************************!*\
  !*** ./js-compile/raw-pixi-ts/MathSettings.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class MathSettings {
    static uid() {
        return ++MathSettings.nextUid;
    }
    static sign(n) {
        if (n === 0) {
            return 0;
        }
        return n < 0 ? -1 : 1;
    }
    static string2hex(string) {
        if (typeof string === 'string' && string[0] === '#') {
            string = string.substr(1);
        }
        return parseInt(string, 16);
    }
    static hex2string(hex) {
        hex = hex.toString(16);
        hex = '000000'.substr(0, 6 - hex.length) + hex;
        return ("#" + hex);
    }
    static log2(v) {
        var r = (v > 0xFFFF) << 4;
        v >>>= r;
        var shift = (v > 0xFF) << 3;
        v >>>= shift;
        r |= shift;
        shift = (v > 0xF) << 2;
        v >>>= shift;
        r |= shift;
        shift = (v > 0x3) << 1;
        v >>>= shift;
        r |= shift;
        return r | (v >> 1);
    }
    static nextPow2(v) {
        v += v === 0;
        --v;
        v |= v >>> 1;
        v |= v >>> 2;
        v |= v >>> 4;
        v |= v >>> 8;
        v |= v >>> 16;
        return v + 1;
    }
    static isPow2(v) {
        return !(v & (v - 1)) && (!!v);
    }
}
MathSettings.nextUid = 0;
MathSettings.PI_2 = Math.PI * 2;
MathSettings.RAD_TO_DEG = 180 / Math.PI;
MathSettings.DEG_TO_RAD = Math.PI / 180;
exports.MathSettings = MathSettings;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/Matrix.js":
/*!******************************************!*\
  !*** ./js-compile/raw-pixi-ts/Matrix.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Point_1 = __webpack_require__(/*! ./Point */ "./js-compile/raw-pixi-ts/Point.js");
const MathSettings_1 = __webpack_require__(/*! ./MathSettings */ "./js-compile/raw-pixi-ts/MathSettings.js");
class Matrix {
    constructor(a = 1, b = 0, c = 0, d = 1, tx = 0, ty = 0) {
        if (a === void 0) {
            a = 1;
        }
        if (b === void 0) {
            b = 0;
        }
        if (c === void 0) {
            c = 0;
        }
        if (d === void 0) {
            d = 1;
        }
        if (tx === void 0) {
            tx = 0;
        }
        if (ty === void 0) {
            ty = 0;
        }
        /**
         * @member {number}
         * @default 1
         */
        this.a = a;
        /**
         * @member {number}
         * @default 0
         */
        this.b = b;
        /**
         * @member {number}
         * @default 0
         */
        this.c = c;
        /**
         * @member {number}
         * @default 1
         */
        this.d = d;
        /**
         * @member {number}
         * @default 0
         */
        this.tx = tx;
        /**
         * @member {number}
         * @default 0
         */
        this.ty = ty;
        this.array = null;
    }
    /**
     * Creates a Matrix object based on the given array. The Element to Matrix mapping order is as follows:
     *
     * a = array[0]
     * b = array[1]
     * c = array[3]
     * d = array[4]
     * tx = array[2]
     * ty = array[5]
     *
     * @param {number[]} array - The array that the matrix will be populated from.
     */
    fromArray(array) {
        this.a = array[0];
        this.b = array[1];
        this.c = array[3];
        this.d = array[4];
        this.tx = array[2];
        this.ty = array[5];
    }
    ;
    /**
     * sets the matrix properties
     *
     * @param {number} a - Matrix component
     * @param {number} b - Matrix component
     * @param {number} c - Matrix component
     * @param {number} d - Matrix component
     * @param {number} tx - Matrix component
     * @param {number} ty - Matrix component
     *
     * @return {PIXI.Matrix} This matrix. Good for chaining method calls.
     */
    set(a, b, c, d, tx, ty) {
        this.a = a;
        this.b = b;
        this.c = c;
        this.d = d;
        this.tx = tx;
        this.ty = ty;
        return this;
    }
    ;
    /**
     * Creates an array from the current Matrix object.
     *
     * @param {boolean} transpose - Whether we need to transpose the matrix or not
     * @param {Float32Array} [out=new Float32Array(9)] - If provided the array will be assigned to out
     * @return {number[]} the newly created array which contains the matrix
     */
    toArray(transpose, out = null) {
        if (!this.array) {
            this.array = new Float32Array(9);
        }
        var array = out || this.array;
        if (transpose) {
            array[0] = this.a;
            array[1] = this.b;
            array[2] = 0;
            array[3] = this.c;
            array[4] = this.d;
            array[5] = 0;
            array[6] = this.tx;
            array[7] = this.ty;
            array[8] = 1;
        }
        else {
            array[0] = this.a;
            array[1] = this.c;
            array[2] = this.tx;
            array[3] = this.b;
            array[4] = this.d;
            array[5] = this.ty;
            array[6] = 0;
            array[7] = 0;
            array[8] = 1;
        }
        return array;
    }
    ;
    /**
     * Get a new position with the current transformation applied.
     * Can be used to go from a child's coordinate space to the world coordinate space. (e.g. rendering)
     *
     * @param {PIXI.Point} pos - The origin
     * @param {PIXI.Point} [newPos] - The point that the new position is assigned to (allowed to be same as input)
     * @return {PIXI.Point} The new point, transformed through this matrix
     */
    apply(pos, newPos) {
        newPos = newPos || new Point_1.Point();
        var x = pos.x;
        var y = pos.y;
        newPos.x = (this.a * x) + (this.c * y) + this.tx;
        newPos.y = (this.b * x) + (this.d * y) + this.ty;
        return newPos;
    }
    ;
    /**
     * Get a new position with the inverse of the current transformation applied.
     * Can be used to go from the world coordinate space to a child's coordinate space. (e.g. input)
     *
     * @param {PIXI.Point} pos - The origin
     * @param {PIXI.Point} [newPos] - The point that the new position is assigned to (allowed to be same as input)
     * @return {PIXI.Point} The new point, inverse-transformed through this matrix
     */
    applyInverse(pos, newPos) {
        newPos = newPos || new Point_1.Point();
        var id = 1 / ((this.a * this.d) + (this.c * -this.b));
        var x = pos.x;
        var y = pos.y;
        newPos.x = (this.d * id * x) + (-this.c * id * y) + (((this.ty * this.c) - (this.tx * this.d)) * id);
        newPos.y = (this.a * id * y) + (-this.b * id * x) + (((-this.ty * this.a) + (this.tx * this.b)) * id);
        return newPos;
    }
    ;
    /**
     * Translates the matrix on the x and y.
     *
     * @param {number} x How much to translate x by
     * @param {number} y How much to translate y by
     * @return {PIXI.Matrix} This matrix. Good for chaining method calls.
     */
    translate(x, y) {
        this.tx += x;
        this.ty += y;
        return this;
    }
    ;
    /**
     * Applies a scale transformation to the matrix.
     *
     * @param {number} x The amount to scale horizontally
     * @param {number} y The amount to scale vertically
     * @return {PIXI.Matrix} This matrix. Good for chaining method calls.
     */
    scale(x, y) {
        this.a *= x;
        this.d *= y;
        this.c *= x;
        this.b *= y;
        this.tx *= x;
        this.ty *= y;
        return this;
    }
    ;
    /**
     * Applies a rotation transformation to the matrix.
     *
     * @param {number} angle - The angle in radians.
     * @return {PIXI.Matrix} This matrix. Good for chaining method calls.
     */
    rotate(angle) {
        var cos = Math.cos(angle);
        var sin = Math.sin(angle);
        var a1 = this.a;
        var c1 = this.c;
        var tx1 = this.tx;
        this.a = (a1 * cos) - (this.b * sin);
        this.b = (a1 * sin) + (this.b * cos);
        this.c = (c1 * cos) - (this.d * sin);
        this.d = (c1 * sin) + (this.d * cos);
        this.tx = (tx1 * cos) - (this.ty * sin);
        this.ty = (tx1 * sin) + (this.ty * cos);
        return this;
    }
    ;
    /**
     * Appends the given Matrix to this Matrix.
     *
     * @param {PIXI.Matrix} matrix - The matrix to append.
     * @return {PIXI.Matrix} This matrix. Good for chaining method calls.
     */
    append(matrix) {
        var a1 = this.a;
        var b1 = this.b;
        var c1 = this.c;
        var d1 = this.d;
        this.a = (matrix.a * a1) + (matrix.b * c1);
        this.b = (matrix.a * b1) + (matrix.b * d1);
        this.c = (matrix.c * a1) + (matrix.d * c1);
        this.d = (matrix.c * b1) + (matrix.d * d1);
        this.tx = (matrix.tx * a1) + (matrix.ty * c1) + this.tx;
        this.ty = (matrix.tx * b1) + (matrix.ty * d1) + this.ty;
        return this;
    }
    ;
    /**
     * Sets the matrix based on all the available properties
     *
     * @param {number} x - Position on the x axis
     * @param {number} y - Position on the y axis
     * @param {number} pivotX - Pivot on the x axis
     * @param {number} pivotY - Pivot on the y axis
     * @param {number} scaleX - Scale on the x axis
     * @param {number} scaleY - Scale on the y axis
     * @param {number} rotation - Rotation in radians
     * @param {number} skewX - Skew on the x axis
     * @param {number} skewY - Skew on the y axis
     * @return {PIXI.Matrix} This matrix. Good for chaining method calls.
     */
    setTransform(x, y, pivotX, pivotY, scaleX, scaleY, rotation, skewX, skewY) {
        this.a = Math.cos(rotation + skewY) * scaleX;
        this.b = Math.sin(rotation + skewY) * scaleX;
        this.c = -Math.sin(rotation - skewX) * scaleY;
        this.d = Math.cos(rotation - skewX) * scaleY;
        this.tx = x - ((pivotX * this.a) + (pivotY * this.c));
        this.ty = y - ((pivotX * this.b) + (pivotY * this.d));
        return this;
    }
    ;
    /**
     * Prepends the given Matrix to this Matrix.
     *
     * @param {PIXI.Matrix} matrix - The matrix to prepend
     * @return {PIXI.Matrix} This matrix. Good for chaining method calls.
     */
    prepend(matrix) {
        var tx1 = this.tx;
        if (matrix.a !== 1 || matrix.b !== 0 || matrix.c !== 0 || matrix.d !== 1) {
            var a1 = this.a;
            var c1 = this.c;
            this.a = (a1 * matrix.a) + (this.b * matrix.c);
            this.b = (a1 * matrix.b) + (this.b * matrix.d);
            this.c = (c1 * matrix.a) + (this.d * matrix.c);
            this.d = (c1 * matrix.b) + (this.d * matrix.d);
        }
        this.tx = (tx1 * matrix.a) + (this.ty * matrix.c) + matrix.tx;
        this.ty = (tx1 * matrix.b) + (this.ty * matrix.d) + matrix.ty;
        return this;
    }
    ;
    /**
     * Decomposes the matrix (x, y, scaleX, scaleY, and rotation) and sets the properties on to a transform.
     *
     * @param {PIXI.Transform} transform - The transform to apply the properties to.
     * @return {PIXI.Transform} The transform with the newly applied properties
     */
    decompose(transform) {
        // sort out rotation / skew..
        var a = this.a;
        var b = this.b;
        var c = this.c;
        var d = this.d;
        var skewX = -Math.atan2(-c, d);
        var skewY = Math.atan2(b, a);
        var delta = Math.abs(skewX + skewY);
        if (delta < 0.00001 || Math.abs(MathSettings_1.MathSettings.PI_2 - delta) < 0.00001) {
            transform.rotation = skewY;
            transform.skew.x = transform.skew.y = 0;
        }
        else {
            transform.rotation = 0;
            transform.skew.x = skewX;
            transform.skew.y = skewY;
        }
        // next set scale
        transform.scale.x = Math.sqrt((a * a) + (b * b));
        transform.scale.y = Math.sqrt((c * c) + (d * d));
        // next set position
        transform.position.x = this.tx;
        transform.position.y = this.ty;
        return transform;
    }
    ;
    /**
     * Inverts this matrix
     *
     * @return {PIXI.Matrix} This matrix. Good for chaining method calls.
     */
    invert() {
        var a1 = this.a;
        var b1 = this.b;
        var c1 = this.c;
        var d1 = this.d;
        var tx1 = this.tx;
        var n = (a1 * d1) - (b1 * c1);
        this.a = d1 / n;
        this.b = -b1 / n;
        this.c = -c1 / n;
        this.d = a1 / n;
        this.tx = ((c1 * this.ty) - (d1 * tx1)) / n;
        this.ty = -((a1 * this.ty) - (b1 * tx1)) / n;
        return this;
    }
    ;
    /**
     * Resets this Matrix to an identity (default) matrix.
     *
     * @return {PIXI.Matrix} This matrix. Good for chaining method calls.
     */
    identity() {
        this.a = 1;
        this.b = 0;
        this.c = 0;
        this.d = 1;
        this.tx = 0;
        this.ty = 0;
        return this;
    }
    ;
    /**
     * Creates a new Matrix object with the same values as this one.
     *
     * @return {PIXI.Matrix} A copy of this matrix. Good for chaining method calls.
     */
    clone() {
        var matrix = new Matrix();
        matrix.a = this.a;
        matrix.b = this.b;
        matrix.c = this.c;
        matrix.d = this.d;
        matrix.tx = this.tx;
        matrix.ty = this.ty;
        return matrix;
    }
    ;
    /**
     * Changes the values of the given matrix to be the same as the ones in this matrix
     *
     * @param {PIXI.Matrix} matrix - The matrix to copy to.
     * @return {PIXI.Matrix} The matrix given in parameter with its values updated.
     */
    copyTo(matrix) {
        matrix.a = this.a;
        matrix.b = this.b;
        matrix.c = this.c;
        matrix.d = this.d;
        matrix.tx = this.tx;
        matrix.ty = this.ty;
        return matrix;
    }
    ;
    /**
     * Changes the values of the matrix to be the same as the ones in given matrix
     *
     * @param {PIXI.Matrix} matrix - The matrix to copy from.
     * @return {PIXI.Matrix} this
     */
    copyFrom(matrix) {
        this.a = matrix.a;
        this.b = matrix.b;
        this.c = matrix.c;
        this.d = matrix.d;
        this.tx = matrix.tx;
        this.ty = matrix.ty;
        return this;
    }
    ;
    /**
     * A default (identity) matrix
     *
     * @static
     * @const
     * @member {PIXI.Matrix}
     */
    static get IDENTITY() {
        return new Matrix();
    }
    ;
    /**
     * A temp matrix
     *
     * @static
     * @const
     * @member {PIXI.Matrix}
     */
    static get TEMP_MATRIX() {
        return new Matrix();
    }
    ;
}
exports.Matrix = Matrix;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/Mesh.js":
/*!****************************************!*\
  !*** ./js-compile/raw-pixi-ts/Mesh.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Container_1 = __webpack_require__(/*! ./Container */ "./js-compile/raw-pixi-ts/Container.js");
const State_1 = __webpack_require__(/*! ./State */ "./js-compile/raw-pixi-ts/State.js");
const Polygon_1 = __webpack_require__(/*! ./Polygon */ "./js-compile/raw-pixi-ts/Polygon.js");
const MeshBatchUvs_1 = __webpack_require__(/*! ./MeshBatchUvs */ "./js-compile/raw-pixi-ts/MeshBatchUvs.js");
const Point_1 = __webpack_require__(/*! ./Point */ "./js-compile/raw-pixi-ts/Point.js");
const DrawModeSettings_1 = __webpack_require__(/*! ./DrawModeSettings */ "./js-compile/raw-pixi-ts/DrawModeSettings.js");
const BlendModesSettings_1 = __webpack_require__(/*! ./BlendModesSettings */ "./js-compile/raw-pixi-ts/BlendModesSettings.js");
const DisplaySettings_1 = __webpack_require__(/*! ./DisplaySettings */ "./js-compile/raw-pixi-ts/DisplaySettings.js");
class Mesh extends Container_1.Container {
    constructor(geometry, shader, state = null, drawMode = DrawModeSettings_1.DrawModeSettings.DRAW_MODES.TRIANGLES) {
        super();
        this.interactive = false;
        /**
         * Includes vertex positions, face indices, normals, colors, UVs, and
         * custom attributes within buffers, reducing the cost of passing all
         * this data to the GPU. Can be shared between multiple Mesh objects.
         * @member {PIXI.Geometry}
         * @readonly
         */
        this.geometry = geometry;
        geometry.refCount++;
        /**
         * Represents the vertex and fragment shaders that processes the geometry and runs on the GPU.
         * Can be shared between multiple Mesh objects.
         * @member {PIXI.Shader|PIXI.MeshMaterial}
         */
        this.shader = shader;
        /**
         * Represents the WebGL state the Mesh required to render, excludes shader and geometry. E.g.,
         * blend mode, culling, depth testing, direction of rendering triangles, backface, etc.
         * @member {PIXI.State}
         */
        this.state = state || State_1.State.for2d();
        /**
         * The way the Mesh should be drawn, can be any of the {@link PIXI.DRAW_MODES} constants.
         *
         * @member {number}
         * @see PIXI.DRAW_MODES
         */
        this.drawMode = drawMode;
        /**
         * Typically the index of the IndexBuffer where to start drawing.
         * @member {number}
         * @default 0
         */
        this.start = 0;
        /**
         * How much of the geometry to draw, by default `0` renders everything.
         * @member {number}
         * @default 0
         */
        this.size = 0;
        /**
         * thease are used as easy access for batching
         * @member {Float32Array}
         * @private
         */
        this.uvs = null;
        /**
         * thease are used as easy access for batching
         * @member {Uint16Array}
         * @private
         */
        this.indices = null;
        /**
         * this is the caching layer used by the batcher
         * @member {Float32Array}
         * @private
         */
        this.vertexData = new Float32Array(1);
        /**
         * If geometry is changed used to decide to re-transform
         * the vertexData.
         * @member {number}
         * @private
         */
        this.vertexDirty = 0;
        this._transformID = -1;
        // Inherited from DisplayMode, set defaults
        this.tint = 0xFFFFFF;
        this.blendMode = BlendModesSettings_1.BlendModesSettings.BLEND_MODES.NORMAL;
        /**
         * Internal roundPixels field
         *
         * @member {boolean}
         * @private
         */
        this._roundPixels = DisplaySettings_1.DisplaySettings.ROUND_PIXELS;
        /**
         * Batched UV's are cached for atlas textures
         * @member {PIXI.MeshBatchUvs}
         * @private
         */
        this.batchUvs = null;
    }
    /**
     * To change mesh uv's, change its uvBuffer data and increment its _updateID.
     * @member {PIXI.Buffer}
     * @readonly
     */
    get uvBuffer() {
        return this.geometry.buffers[1].data;
    }
    ;
    /**
     * To change mesh vertices, change its uvBuffer data and increment its _updateID.
     * Incrementing _updateID is optional because most of Mesh objects do it anyway.
     * @member {PIXI.Buffer}
     * @readonly
     */
    get verticesBuffer() {
        return this.geometry.buffers[0].data;
    }
    ;
    /**
     * Alias for {@link PIXI.Mesh#shader}.
     * @member {PIXI.Shader|PIXI.MeshMaterial}
     */
    set material(value) {
        this.shader = value;
    }
    ;
    get material() {
        return this.shader;
    }
    ;
    /**
     * The blend mode to be applied to the Mesh. Apply a value of
     * `PIXI.BLEND_MODES.NORMAL` to reset the blend mode.
     *
     * @member {number}
     * @default PIXI.BLEND_MODES.NORMAL;
     * @see PIXI.BLEND_MODES
     */
    set blendMode(value) {
        this.state.blendMode = value;
    }
    ;
    get blendMode() {
        return this.state.blendMode;
    }
    ;
    /**
     * If true PixiJS will Math.floor() x/y values when rendering, stopping pixel interpolation.
     * Advantages can include sharper image quality (like text) and faster rendering on canvas.
     * The main disadvantage is movement of objects may appear less smooth.
     * To set the global default, change {@link PIXI.settings.ROUND_PIXELS}
     *
     * @member {boolean}
     * @default false
     */
    set roundPixels(value) {
        if (this._roundPixels !== value) {
            this._transformID = -1;
        }
        this._roundPixels = value;
    }
    ;
    get roundPixels() {
        return this._roundPixels;
    }
    ;
    /**
     * The multiply tint applied to the Mesh. This is a hex value. A value of
     * `0xFFFFFF` will remove any tint effect.
     *
     * @member {number}
     * @default 0xFFFFFF
     */
    get tint() {
        return this.shader.tint;
    }
    ;
    set tint(value) {
        this.shader.tint = value;
    }
    ;
    /**
     * The texture that the Mesh uses.
     *
     * @member {PIXI.Texture}
     */
    get texture() {
        return this.shader.texture;
    }
    ;
    set texture(value) {
        this.shader.texture = value;
    }
    ;
    /**
     * Standard renderer draw.
     * @protected
     */
    _render(renderer) {
        // set properties for batching..
        // TODO could use a different way to grab verts?
        var vertices = this.geometry.buffers[0].data;
        // TODO benchmark check for attribute size..
        if (this.shader.batchable && this.drawMode === DrawModeSettings_1.DrawModeSettings.DRAW_MODES.TRIANGLES && vertices.length < Mesh.BATCHABLE_SIZE * 2) {
            this._renderToBatch(renderer);
        }
        else {
            this._renderDefault(renderer);
        }
    }
    ;
    /**
     * Standard non-batching way of rendering.
     * @protected
     * @param {PIXI.Renderer} renderer - Instance to renderer.
     */
    _renderDefault(renderer) {
        var shader = this.shader;
        shader.alpha = this.worldAlpha;
        if (shader.update) {
            shader.update();
        }
        renderer.batch.flush();
        if (shader.program.uniformData.translationMatrix) {
            shader.uniforms.translationMatrix = this.transform.worldTransform.toArray(true);
        }
        // bind and sync uniforms..
        renderer.shader.bind(shader);
        // set state..
        renderer.state.setState(this.state);
        // bind the geometry...
        renderer.geometry.bind(this.geometry, shader);
        // then render it
        renderer.geometry.draw(this.drawMode, this.size, this.start, this.geometry.instanceCount);
    }
    ;
    /**
     * Rendering by using the Batch system.
     * @protected
     * @param {PIXI.Renderer} renderer - Instance to renderer.
     */
    _renderToBatch(renderer) {
        var geometry = this.geometry;
        if (this.shader.uvMatrix) {
            this.shader.uvMatrix.update();
            this.calculateUvs();
        }
        // set properties for batching..
        this.calculateVertices();
        this.indices = geometry.indexBuffer.data;
        this._tintRGB = this.shader._tintRGB;
        this._texture = this.shader.texture;
        var pluginName = this.material.pluginName;
        renderer.batch.setObjectRenderer(renderer.plugins[pluginName]);
        renderer.plugins[pluginName].render(this);
    }
    ;
    /**
     * Updates vertexData field based on transform and vertices
     */
    calculateVertices() {
        var geometry = this.geometry;
        var vertices = geometry.buffers[0].data;
        if (geometry.vertexDirtyId === this.vertexDirty && this._transformID === this.transform._worldID) {
            return;
        }
        this._transformID = this.transform._worldID;
        if (this.vertexData.length !== vertices.length) {
            this.vertexData = new Float32Array(vertices.length);
        }
        var wt = this.transform.worldTransform;
        var a = wt.a;
        var b = wt.b;
        var c = wt.c;
        var d = wt.d;
        var tx = wt.tx;
        var ty = wt.ty;
        var vertexData = this.vertexData;
        for (var i = 0; i < vertexData.length / 2; i++) {
            var x = vertices[(i * 2)];
            var y = vertices[(i * 2) + 1];
            vertexData[(i * 2)] = (a * x) + (c * y) + tx;
            vertexData[(i * 2) + 1] = (b * x) + (d * y) + ty;
        }
        if (this._roundPixels) {
            for (var i$1 = 0; i$1 < vertexData.length; i$1++) {
                vertexData[i$1] = Math.round(vertexData[i$1]);
            }
        }
        this.vertexDirty = geometry.vertexDirtyId;
    }
    ;
    /**
     * Updates uv field based on from geometry uv's or batchUvs
     */
    calculateUvs() {
        var geomUvs = this.geometry.buffers[1];
        if (!this.shader.uvMatrix.isSimple) {
            if (!this.batchUvs) {
                this.batchUvs = new MeshBatchUvs_1.MeshBatchUvs(geomUvs, this.shader.uvMatrix);
            }
            this.batchUvs.update();
            this.uvs = this.batchUvs.data;
        }
        else {
            this.uvs = geomUvs.data;
        }
    }
    ;
    /**
     * Updates the bounds of the mesh as a rectangle. The bounds calculation takes the worldTransform into account.
     * there must be a aVertexPosition attribute present in the geometry for bounds to be calculated correctly.
     *
     * @protected
     */
    _calculateBounds() {
        this.calculateVertices();
        this._bounds.addVertexData(this.vertexData, 0, this.vertexData.length);
    }
    ;
    /**
     * Tests if a point is inside this mesh. Works only for PIXI.DRAW_MODES.TRIANGLES.
     *
     * @param {PIXI.Point} point the point to test
     * @return {boolean} the result of the test
     */
    containsPoint(point) {
        if (!this.interactive) {
            return false;
        }
        if (!this.getBounds().contains(point.x, point.y)) {
            return false;
        }
        this.worldTransform.applyInverse(point, Mesh.tempPoint$2);
        var vertices = this.geometry.getAttribute('aVertexPosition').data;
        var points = Mesh.tempPolygon.points;
        var indices = this.geometry.getIndex().data;
        var len = indices.length;
        var step = this.drawMode === 4 ? 3 : 1;
        for (var i = 0; i + 2 < len; i += step) {
            var ind0 = indices[i] * 2;
            var ind1 = indices[i + 1] * 2;
            var ind2 = indices[i + 2] * 2;
            points[0] = vertices[ind0];
            points[1] = vertices[ind0 + 1];
            points[2] = vertices[ind1];
            points[3] = vertices[ind1 + 1];
            points[4] = vertices[ind2];
            points[5] = vertices[ind2 + 1];
            if (Mesh.tempPolygon.contains(Mesh.tempPoint$2.x, Mesh.tempPoint$2.y)) {
                return true;
            }
        }
        return false;
    }
    ;
    /**
     * Destroys the Mesh object.
     *
     * @param {object|boolean} [options] - Options parameter. A boolean will act as if all
     *  options have been set to that value
     * @param {boolean} [options.children=false] - if set to true, all the children will have
     *  their destroy method called as well. 'options' will be passed on to those calls.
     */
    destroy(options) {
        super.destroy(options);
        this.geometry.refCount--;
        if (this.geometry.refCount === 0) {
            this.geometry.dispose();
        }
        this.geometry = null;
        this.shader = null;
        this.state = null;
        this.uvs = null;
        this.indices = null;
        this.vertexData = null;
    }
    ;
}
Mesh.tempPolygon = new Polygon_1.Polygon();
Mesh.tempPoint$2 = new Point_1.Point();
/**
 * The maximum number of vertices to consider batchable. Generally, the complexity
 * of the geometry.
 * @memberof PIXI.Mesh
 * @static
 * @member {number} BATCHABLE_SIZE
 */
Mesh.BATCHABLE_SIZE = 100;
exports.Mesh = Mesh;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/MeshBatchUvs.js":
/*!************************************************!*\
  !*** ./js-compile/raw-pixi-ts/MeshBatchUvs.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class MeshBatchUvs {
    constructor(uvBuffer, uvMatrix) {
        /**
                 * Buffer with normalized UV's
                 * @member {PIXI.Buffer}
                 */
        this.uvBuffer = uvBuffer;
        /**
         * Material UV matrix
         * @member {PIXI.TextureMatrix}
         */
        this.uvMatrix = uvMatrix;
        /**
         * UV Buffer data
         * @member {Float32Array}
         * @readonly
         */
        this.data = null;
        this._bufferUpdateId = -1;
        this._textureUpdateId = -1;
        this._updateID = 0;
    }
    /**
     * updates
     *
     * @param {boolean} forceUpdate - force the update
     */
    update(forceUpdate) {
        if (!forceUpdate
            && this._bufferUpdateId === this.uvBuffer._updateID
            && this._textureUpdateId === this.uvMatrix._updateID) {
            return;
        }
        this._bufferUpdateId = this.uvBuffer._updateID;
        this._textureUpdateId = this.uvMatrix._updateID;
        var data = this.uvBuffer.data;
        if (!this.data || this.data.length !== data.length) {
            this.data = new Float32Array(data.length);
        }
        this.uvMatrix.multiplyUvs(data, this.data);
        this._updateID++;
    }
    ;
}
exports.MeshBatchUvs = MeshBatchUvs;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/MeshGeometry.js":
/*!************************************************!*\
  !*** ./js-compile/raw-pixi-ts/MeshGeometry.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Geometry_1 = __webpack_require__(/*! ./Geometry */ "./js-compile/raw-pixi-ts/Geometry.js");
const Buffer_1 = __webpack_require__(/*! ./Buffer */ "./js-compile/raw-pixi-ts/Buffer.js");
const WebGLSettings_1 = __webpack_require__(/*! ./WebGLSettings */ "./js-compile/raw-pixi-ts/WebGLSettings.js");
class MeshGeometry extends Geometry_1.Geometry {
    constructor(vertices = null, uvs = null, index = null) {
        super();
        var verticesBuffer = new Buffer_1.Buffer(vertices);
        var uvsBuffer = new Buffer_1.Buffer(uvs, true);
        var indexBuffer = new Buffer_1.Buffer(index, true, true);
        this.addAttribute('aVertexPosition', verticesBuffer, 2, false, WebGLSettings_1.WebGLSettings.TYPES.FLOAT)
            .addAttribute('aTextureCoord', uvsBuffer, 2, false, WebGLSettings_1.WebGLSettings.TYPES.FLOAT)
            .addIndex(indexBuffer);
        /**
         * Dirty flag to limit update calls on Mesh. For example,
         * limiting updates on a single Mesh instance with a shared Geometry
         * within the render loop.
         * @private
         * @member {number}
         * @default -1
         */
        this._updateId = -1;
    }
    /**
     * If the vertex position is updated.
     * @member {number}
     * @readonly
     * @private
     */
    get vertexDirtyId() {
        return this.buffers[0]._updateID;
    }
    ;
}
exports.MeshGeometry = MeshGeometry;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/MeshMaterial.js":
/*!************************************************!*\
  !*** ./js-compile/raw-pixi-ts/MeshMaterial.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Shader_1 = __webpack_require__(/*! ./Shader */ "./js-compile/raw-pixi-ts/Shader.js");
const Matrix_1 = __webpack_require__(/*! ./Matrix */ "./js-compile/raw-pixi-ts/Matrix.js");
const Program_1 = __webpack_require__(/*! ./Program */ "./js-compile/raw-pixi-ts/Program.js");
const TextureMatrix_1 = __webpack_require__(/*! ./TextureMatrix */ "./js-compile/raw-pixi-ts/TextureMatrix.js");
const ColorSettings_1 = __webpack_require__(/*! ./ColorSettings */ "./js-compile/raw-pixi-ts/ColorSettings.js");
class MeshMaterial extends Shader_1.Shader {
    constructor(uSampler, options = null) {
        var uniforms = {
            uSampler: uSampler,
            alpha: 1,
            uTextureMatrix: Matrix_1.Matrix.IDENTITY,
            uColor: new Float32Array([1, 1, 1, 1]),
        };
        // Set defaults
        options = Object.assign({
            tint: 0xFFFFFF,
            alpha: 1,
            pluginName: 'batch',
        }, options);
        if (options.uniforms) {
            Object.assign(uniforms, options.uniforms);
        }
        super(options.program || Program_1.Program.from(MeshMaterial.vertex$6, MeshMaterial.fragment$8), uniforms);
        /**
         * Only do update if tint or alpha changes.
         * @member {boolean}
         * @private
         * @default false
         */
        this._colorDirty = false;
        /**
         * TextureMatrix instance for this Mesh, used to track Texture changes
         *
         * @member {PIXI.TextureMatrix}
         * @readonly
         */
        this.uvMatrix = new TextureMatrix_1.TextureMatrix(uSampler);
        /**
         * `true` if shader can be batch with the renderer's batch system.
         * @member {boolean}
         * @default true
         */
        this.batchable = options.program === undefined;
        /**
         * Renderer plugin for batching
         *
         * @member {string}
         * @default 'batch'
         */
        this.pluginName = options.pluginName;
        this.tint = options.tint;
        this.alpha = options.alpha;
    }
    /**
     * Reference to the texture being rendered.
     * @member {PIXI.Texture}
     */
    get texture() {
        return this.uniforms.uSampler;
    }
    ;
    set texture(value) {
        if (this.uniforms.uSampler !== value) {
            this.uniforms.uSampler = value;
            this.uvMatrix.texture = value;
        }
    }
    ;
    /**
     * This gets automatically set by the object using this.
     *
     * @default 1
     * @member {number}
     */
    set alpha(value) {
        if (value === this._alpha) {
            return;
        }
        this._alpha = value;
        this._colorDirty = true;
    }
    ;
    get alpha() {
        return this._alpha;
    }
    ;
    /**
     * Multiply tint for the material.
     * @member {number}
     * @default 0xFFFFFF
     */
    set tint(value) {
        if (value === this._tint) {
            return;
        }
        this._tint = value;
        this._tintRGB = (value >> 16) + (value & 0xff00) + ((value & 0xff) << 16);
        this._colorDirty = true;
    }
    ;
    get tint() {
        return this._tint;
    }
    ;
    /**
     * Gets called automatically by the Mesh. Intended to be overridden for custom
     * MeshMaterial objects.
     */
    update() {
        if (this._colorDirty) {
            this._colorDirty = false;
            var baseTexture = this.texture.baseTexture;
            ColorSettings_1.ColorSettings.premultiplyTintToRgba(this._tint, this._alpha, this.uniforms.uColor, baseTexture.premultiplyAlpha);
        }
        if (this.uvMatrix.update()) {
            this.uniforms.uTextureMatrix = this.uvMatrix.mapCoord;
        }
    }
    ;
}
MeshMaterial.vertex$6 = "attribute vec2 aVertexPosition;\r\nattribute vec2 aTextureCoord;\r\n\r\nuniform mat3 projectionMatrix;\r\nuniform mat3 translationMatrix;\r\nuniform mat3 uTextureMatrix;\r\n\r\nvarying vec2 vTextureCoord;\r\n\r\nvoid main(void)\r\n{\r\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\r\n\r\n    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;\r\n}\r\n";
MeshMaterial.fragment$8 = "varying vec2 vTextureCoord;\r\nuniform vec4 uColor;\r\n\r\nuniform sampler2D uSampler;\r\n\r\nvoid main(void)\r\n{\r\n    gl_FragColor = texture2D(uSampler, vTextureCoord) * uColor;\r\n}\r\n";
exports.MeshMaterial = MeshMaterial;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/MouseEvent.js":
/*!**********************************************!*\
  !*** ./js-compile/raw-pixi-ts/MouseEvent.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Event_1 = __webpack_require__(/*! ./Event */ "./js-compile/raw-pixi-ts/Event.js");
class MouseEvent extends Event_1.Event {
    constructor(type, bubbles = false) {
        super(type, bubbles);
        this.movementX = 0;
        this.movementY = 0;
    }
}
MouseEvent.CLICK = "click";
MouseEvent.MOUSE_DOWN = "mouseDown";
MouseEvent.MOUSE_UP = "mouseUp";
MouseEvent.MIDDLE_CLICK = "middleClick";
MouseEvent.MIDDLE_MOUSE_DOWN = "middleMouseDown";
MouseEvent.MIDDLE_MOUSE_UP = "middleMouseUp";
MouseEvent.RIGHT_CLICK = "rightClick";
MouseEvent.RIGHT_MOUSE_DOWN = "rightMouseDown";
MouseEvent.RIGHT_MOUSE_UP = "rightMouseUp";
MouseEvent.MOUSE_MOVE = "mouseMove";
MouseEvent.MOUSE_OVER = "mouseOver";
MouseEvent.MOUSE_OUT = "mouseOut";
MouseEvent.RIGHT_MOUSE_UP_OUTSIDE = "rightupoutside";
MouseEvent.MOUSE_UP_OUTSIDE = "mouseupoutside";
MouseEvent.POINTER_OVER = "pointerover";
MouseEvent.POINTER_ENTER = "pointerenter";
MouseEvent.POINTER_DOWN = "pointerdown";
MouseEvent.POINTER_MOVE = "pointermove";
MouseEvent.POINTER_UP = "pointerup";
MouseEvent.POINTER_CANCEL = "pointercancel";
MouseEvent.POINTER_OUT = "pointerout";
MouseEvent.POINTER_LEAVE = "pointerleave";
MouseEvent.POINTER_CAPTURE = "gotpointercapture";
MouseEvent.POINTER_LOST = "lostpointercapture";
MouseEvent.POINTER_UP_OUTSIDE = "pointerupoutside";
MouseEvent.POINTER_TAP = "pointertap";
MouseEvent.TOUCH_START = "touchstart";
MouseEvent.TOUCH_END = "touchend";
MouseEvent.TOUCH_END_OUTSIDE = "touchendoutside";
MouseEvent.TOUCH_MOVE = "touchmove";
MouseEvent.TOUCH_CANCEL = "touchcancel";
MouseEvent.TOUCH_TAP = "tap";
exports.MouseEvent = MouseEvent;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/NetworkSettings.js":
/*!***************************************************!*\
  !*** ./js-compile/raw-pixi-ts/NetworkSettings.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Url_1 = __webpack_require__(/*! ./Url */ "./js-compile/raw-pixi-ts/Url.js");
class NetworkSettings {
    static getResolutionOfUrl(url, defaultValue = null) {
        var resolution = NetworkSettings.RETINA_PREFIX.exec(url);
        if (resolution) {
            return parseFloat(resolution[1]);
        }
        return defaultValue !== undefined ? defaultValue : 1;
    }
    static determineCrossOrigin(url$1, loc = null) {
        if (loc === void 0) {
            loc = window.location;
        }
        if (url$1.indexOf('data:') === 0) {
            return '';
        }
        loc = loc || window.location;
        if (!NetworkSettings.tempAnchor) {
            NetworkSettings.tempAnchor = document.createElement('a');
        }
        NetworkSettings.tempAnchor.href = url$1;
        url$1 = NetworkSettings.url.parse(NetworkSettings.tempAnchor.href);
        var samePort = (!url$1.port && loc.port === '') || (url$1.port === loc.port);
        if (url$1.hostname !== loc.hostname || !samePort || url$1.protocol !== loc.protocol) {
            return 'anonymous';
        }
        return '';
    }
}
NetworkSettings.RETINA_PREFIX = /@([0-9\.]+)x/;
NetworkSettings.url = {
    parse: Url_1.Url.urlParse,
    resolve: Url_1.Url.urlResolve,
    resolveObject: Url_1.Url.urlResolveObject,
    format: Url_1.Url.urlFormat,
    Url: Url_1.Url
};
exports.NetworkSettings = NetworkSettings;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/ObjectRenderer.js":
/*!**************************************************!*\
  !*** ./js-compile/raw-pixi-ts/ObjectRenderer.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const System_1 = __webpack_require__(/*! ./System */ "./js-compile/raw-pixi-ts/System.js");
class ObjectRenderer extends System_1.System {
    constructor(renderer) {
        super(renderer);
    }
    start() {
        // set the shader..
    }
    ;
    /**
     * Stops the renderer
     *
     */
    stop() {
        this.flush();
    }
    ;
    /**
     * Stub method for rendering content and emptying the current batch.
     *
     */
    flush() {
        // flush!
    }
    ;
    /**
     * Renders an object
     *
     * @param {PIXI.DisplayObject} object - The object to render.
     */
    render(object) {
        // render the object
    }
    ;
}
exports.ObjectRenderer = ObjectRenderer;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/ObservablePoint.js":
/*!***************************************************!*\
  !*** ./js-compile/raw-pixi-ts/ObservablePoint.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class ObservablePoint {
    constructor(cb, scope, x = 0, y = 0) {
        if (x === void 0) {
            x = 0;
        }
        if (y === void 0) {
            y = 0;
        }
        this._x = x;
        this._y = y;
        this.cb = cb;
        this.scope = scope;
    }
    /**
     * Creates a clone of this point.
     * The callback and scope params can be overidden otherwise they will default
     * to the clone object's values.
     *
     * @override
     * @param {Function} [cb=null] - callback when changed
     * @param {object} [scope=null] - owner of callback
     * @return {PIXI.ObservablePoint} a copy of the point
     */
    clone(cb, scope) {
        if (cb === void 0) {
            cb = null;
        }
        if (scope === void 0) {
            scope = null;
        }
        var _cb = cb || this.cb;
        var _scope = scope || this.scope;
        return new ObservablePoint(_cb, _scope, this._x, this._y);
    }
    ;
    /**
     * Sets the point to a new x and y position.
     * If y is omitted, both x and y will be set to x.
     *
     * @param {number} [x=0] - position of the point on the x axis
     * @param {number} [y=0] - position of the point on the y axis
     */
    set(x, y) {
        var _x = x || 0;
        var _y = y || ((y !== 0) ? _x : 0);
        if (this._x !== _x || this._y !== _y) {
            this._x = _x;
            this._y = _y;
            this.cb.call(this.scope);
        }
    }
    ;
    /**
     * Copies x and y from the given point
     *
     * @param {PIXI.IPoint} p - The point to copy from.
     * @returns {PIXI.IPoint} Returns itself.
     */
    copyFrom(p) {
        if (this._x !== p.x || this._y !== p.y) {
            this._x = p.x;
            this._y = p.y;
            this.cb.call(this.scope);
        }
        return this;
    }
    ;
    /**
     * Copies x and y into the given point
     *
     * @param {PIXI.IPoint} p - The point to copy.
     * @returns {PIXI.IPoint} Given point with values updated
     */
    copyTo(p) {
        p.set(this._x, this._y);
        return p;
    }
    ;
    /**
     * Returns true if the given point is equal to this point
     *
     * @param {PIXI.IPoint} p - The point to check
     * @returns {boolean} Whether the given point equal to this point
     */
    equals(p) {
        return (p.x === this._x) && (p.y === this._y);
    }
    ;
    /**
     * The position of the displayObject on the x axis relative to the local coordinates of the parent.
     *
     * @member {number}
     */
    get x() {
        return this._x;
    }
    ;
    set x(value) {
        if (this._x !== value) {
            this._x = value;
            this.cb.call(this.scope);
        }
    }
    ;
    /**
     * The position of the displayObject on the x axis relative to the local coordinates of the parent.
     *
     * @member {number}
     */
    get y() {
        return this._y;
    }
    ;
    set y(value) {
        if (this._y !== value) {
            this._y = value;
            this.cb.call(this.scope);
        }
    }
    ;
}
exports.ObservablePoint = ObservablePoint;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/ParticleBuffer.js":
/*!**************************************************!*\
  !*** ./js-compile/raw-pixi-ts/ParticleBuffer.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Geometry_1 = __webpack_require__(/*! ./Geometry */ "./js-compile/raw-pixi-ts/Geometry.js");
const Buffer_1 = __webpack_require__(/*! ./Buffer */ "./js-compile/raw-pixi-ts/Buffer.js");
const WebGLSettings_1 = __webpack_require__(/*! ./WebGLSettings */ "./js-compile/raw-pixi-ts/WebGLSettings.js");
class ParticleBuffer {
    constructor(properties, dynamicPropertyFlags, size) {
        this.geometry = new Geometry_1.Geometry();
        this.indexBuffer = null;
        /**
         * The number of particles the buffer can hold
         *
         * @private
         * @member {number}
         */
        this.size = size;
        /**
         * A list of the properties that are dynamic.
         *
         * @private
         * @member {object[]}
         */
        this.dynamicProperties = [];
        /**
         * A list of the properties that are static.
         *
         * @private
         * @member {object[]}
         */
        this.staticProperties = [];
        for (var i = 0; i < properties.length; ++i) {
            var property = properties[i];
            // Make copy of properties object so that when we edit the offset it doesn't
            // change all other instances of the object literal
            property = {
                attributeName: property.attributeName,
                size: property.size,
                uploadFunction: property.uploadFunction,
                type: property.type || WebGLSettings_1.WebGLSettings.TYPES.FLOAT,
                offset: property.offset,
            };
            if (dynamicPropertyFlags[i]) {
                this.dynamicProperties.push(property);
            }
            else {
                this.staticProperties.push(property);
            }
        }
        this.staticStride = 0;
        this.staticBuffer = null;
        this.staticData = null;
        this.staticDataUint32 = null;
        this.dynamicStride = 0;
        this.dynamicBuffer = null;
        this.dynamicData = null;
        this.dynamicDataUint32 = null;
        this._updateID = 0;
        this.initBuffers();
    }
    /**
     * Sets up the renderer context and necessary buffers.
     *
     * @private
     */
    initBuffers() {
        var geometry = this.geometry;
        var dynamicOffset = 0;
        /**
         * Holds the indices of the geometry (quads) to draw
         *
         * @member {Uint16Array}
         * @private
         */
        this.indexBuffer = new Buffer_1.Buffer(WebGLSettings_1.WebGLSettings.createIndicesForQuads(this.size), true, true);
        geometry.addIndex(this.indexBuffer);
        this.dynamicStride = 0;
        for (var i = 0; i < this.dynamicProperties.length; ++i) {
            var property = this.dynamicProperties[i];
            property.offset = dynamicOffset;
            dynamicOffset += property.size;
            this.dynamicStride += property.size;
        }
        var dynBuffer = new ArrayBuffer(this.size * this.dynamicStride * 4 * 4);
        this.dynamicData = new Float32Array(dynBuffer);
        this.dynamicDataUint32 = new Uint32Array(dynBuffer);
        this.dynamicBuffer = new Buffer_1.Buffer(this.dynamicData, false, false);
        // static //
        var staticOffset = 0;
        this.staticStride = 0;
        for (var i$1 = 0; i$1 < this.staticProperties.length; ++i$1) {
            var property$1 = this.staticProperties[i$1];
            property$1.offset = staticOffset;
            staticOffset += property$1.size;
            this.staticStride += property$1.size;
        }
        var statBuffer = new ArrayBuffer(this.size * this.staticStride * 4 * 4);
        this.staticData = new Float32Array(statBuffer);
        this.staticDataUint32 = new Uint32Array(statBuffer);
        this.staticBuffer = new Buffer_1.Buffer(this.staticData, true, false);
        for (var i$2 = 0; i$2 < this.dynamicProperties.length; ++i$2) {
            var property$2 = this.dynamicProperties[i$2];
            geometry.addAttribute(property$2.attributeName, this.dynamicBuffer, 0, property$2.type === WebGLSettings_1.WebGLSettings.TYPES.UNSIGNED_BYTE, property$2.type, this.dynamicStride * 4, property$2.offset * 4);
        }
        for (var i$3 = 0; i$3 < this.staticProperties.length; ++i$3) {
            var property$3 = this.staticProperties[i$3];
            geometry.addAttribute(property$3.attributeName, this.staticBuffer, 0, property$3.type === WebGLSettings_1.WebGLSettings.TYPES.UNSIGNED_BYTE, property$3.type, this.staticStride * 4, property$3.offset * 4);
        }
    }
    ;
    /**
     * Uploads the dynamic properties.
     *
     * @private
     * @param {PIXI.DisplayObject[]} children - The children to upload.
     * @param {number} startIndex - The index to start at.
     * @param {number} amount - The number to upload.
     */
    uploadDynamic(children, startIndex, amount) {
        for (var i = 0; i < this.dynamicProperties.length; i++) {
            var property = this.dynamicProperties[i];
            property.uploadFunction(children, startIndex, amount, property.type === WebGLSettings_1.WebGLSettings.TYPES.UNSIGNED_BYTE ? this.dynamicDataUint32 : this.dynamicData, this.dynamicStride, property.offset);
        }
        this.dynamicBuffer._updateID++;
    }
    ;
    /**
     * Uploads the static properties.
     *
     * @private
     * @param {PIXI.DisplayObject[]} children - The children to upload.
     * @param {number} startIndex - The index to start at.
     * @param {number} amount - The number to upload.
     */
    uploadStatic(children, startIndex, amount) {
        for (var i = 0; i < this.staticProperties.length; i++) {
            var property = this.staticProperties[i];
            property.uploadFunction(children, startIndex, amount, property.type === WebGLSettings_1.WebGLSettings.TYPES.UNSIGNED_BYTE ? this.staticDataUint32 : this.staticData, this.staticStride, property.offset);
        }
        this.staticBuffer._updateID++;
    }
    ;
    /**
     * Destroys the ParticleBuffer.
     *
     * @private
     */
    destroy() {
        this.indexBuffer = null;
        this.dynamicProperties = null;
        // this.dynamicBuffer.destroy();
        this.dynamicBuffer = null;
        this.dynamicData = null;
        this.dynamicDataUint32 = null;
        this.staticProperties = null;
        // this.staticBuffer.destroy();
        this.staticBuffer = null;
        this.staticData = null;
        this.staticDataUint32 = null;
        // all buffers are destroyed inside geometry
        this.geometry.destroy();
    }
    ;
}
exports.ParticleBuffer = ParticleBuffer;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/ParticleRenderer.js":
/*!****************************************************!*\
  !*** ./js-compile/raw-pixi-ts/ParticleRenderer.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const ObjectRenderer_1 = __webpack_require__(/*! ./ObjectRenderer */ "./js-compile/raw-pixi-ts/ObjectRenderer.js");
const Matrix_1 = __webpack_require__(/*! ./Matrix */ "./js-compile/raw-pixi-ts/Matrix.js");
const Shader_1 = __webpack_require__(/*! ./Shader */ "./js-compile/raw-pixi-ts/Shader.js");
const ParticleBuffer_1 = __webpack_require__(/*! ./ParticleBuffer */ "./js-compile/raw-pixi-ts/ParticleBuffer.js");
const ColorSettings_1 = __webpack_require__(/*! ./ColorSettings */ "./js-compile/raw-pixi-ts/ColorSettings.js");
const BlendModesSettings_1 = __webpack_require__(/*! ./BlendModesSettings */ "./js-compile/raw-pixi-ts/BlendModesSettings.js");
const WebGLSettings_1 = __webpack_require__(/*! ./WebGLSettings */ "./js-compile/raw-pixi-ts/WebGLSettings.js");
class ParticleRenderer extends ObjectRenderer_1.ObjectRenderer {
    constructor(renderer) {
        super(renderer);
        // 65535 is max vertex index in the index buffer (see ParticleRenderer)
        // so max number of particles is 65536 / 4 = 16384
        // and max number of element in the index buffer is 16384 * 6 = 98304
        // Creating a full index buffer, overhead is 98304 * 2 = 196Ko
        // let numIndices = 98304;
        /**
         * The default shader that is used if a sprite doesn't have a more specific one.
         *
         * @member {PIXI.Shader}
         */
        this.shader = null;
        this.properties = null;
        this.tempMatrix = new Matrix_1.Matrix();
        this.properties = [
            // verticesData
            {
                attributeName: 'aVertexPosition',
                size: 2,
                uploadFunction: this.uploadVertices,
                offset: 0,
            },
            // positionData
            {
                attributeName: 'aPositionCoord',
                size: 2,
                uploadFunction: this.uploadPosition,
                offset: 0,
            },
            // rotationData
            {
                attributeName: 'aRotation',
                size: 1,
                uploadFunction: this.uploadRotation,
                offset: 0,
            },
            // uvsData
            {
                attributeName: 'aTextureCoord',
                size: 2,
                uploadFunction: this.uploadUvs,
                offset: 0,
            },
            // tintData
            {
                attributeName: 'aColor',
                size: 1,
                type: WebGLSettings_1.WebGLSettings.TYPES.UNSIGNED_BYTE,
                uploadFunction: this.uploadTint,
                offset: 0,
            }
        ];
        this.shader = Shader_1.Shader.from(ParticleRenderer.vertex$2, ParticleRenderer.fragment$1, {});
    }
    /**
     * Renders the particle container object.
     *
     * @param {PIXI.ParticleContainer} container - The container to render using this ParticleRenderer
     */
    render(container) {
        var children = container.children;
        var maxSize = container._maxSize;
        var batchSize = container._batchSize;
        var renderer = this.renderer;
        var totalChildren = children.length;
        if (totalChildren === 0) {
            return;
        }
        else if (totalChildren > maxSize) {
            totalChildren = maxSize;
        }
        var buffers = container._buffers;
        if (!buffers) {
            buffers = container._buffers = this.generateBuffers(container);
        }
        var baseTexture = children[0]._texture.baseTexture;
        // if the uvs have not updated then no point rendering just yet!
        this.renderer.state.setBlendMode(BlendModesSettings_1.BlendModesSettings.correctBlendMode(container.blendMode, baseTexture.premultiplyAlpha));
        var gl = renderer.gl;
        var m = container.worldTransform.copyTo(this.tempMatrix);
        m.prepend(renderer.globalUniforms.uniforms.projectionMatrix);
        this.shader.uniforms.translationMatrix = m.toArray(true);
        this.shader.uniforms.uColor = ColorSettings_1.ColorSettings.premultiplyRgba(container.tintRgb, container.worldAlpha, this.shader.uniforms.uColor, baseTexture.premultiplyAlpha);
        this.shader.uniforms.uSampler = baseTexture;
        this.renderer.shader.bind(this.shader);
        var updateStatic = false;
        // now lets upload and render the buffers..
        for (var i = 0, j = 0; i < totalChildren; i += batchSize, j += 1) {
            var amount = (totalChildren - i);
            if (amount > batchSize) {
                amount = batchSize;
            }
            if (j >= buffers.length) {
                if (!container.autoResize) {
                    break;
                }
                buffers.push(this._generateOneMoreBuffer(container));
            }
            var buffer = buffers[j];
            // we always upload the dynamic
            buffer.uploadDynamic(children, i, amount);
            var bid = container._bufferUpdateIDs[j] || 0;
            updateStatic = updateStatic || (buffer._updateID < bid);
            // we only upload the static content when we have to!
            if (updateStatic) {
                buffer._updateID = container._updateID;
                buffer.uploadStatic(children, i, amount);
            }
            // bind the buffer
            renderer.geometry.bind(buffer.geometry);
            gl.drawElements(gl.TRIANGLES, amount * 6, gl.UNSIGNED_SHORT, 0);
        }
    }
    ;
    /**
     * Creates one particle buffer for each child in the container we want to render and updates internal properties
     *
     * @param {PIXI.ParticleContainer} container - The container to render using this ParticleRenderer
     * @return {PIXI.ParticleBuffer[]} The buffers
     * @private
     */
    generateBuffers(container) {
        var buffers = [];
        var size = container._maxSize;
        var batchSize = container._batchSize;
        var dynamicPropertyFlags = container._properties;
        for (var i = 0; i < size; i += batchSize) {
            buffers.push(new ParticleBuffer_1.ParticleBuffer(this.properties, dynamicPropertyFlags, batchSize));
        }
        return buffers;
    }
    ;
    /**
     * Creates one more particle buffer, because container has autoResize feature
     *
     * @param {PIXI.ParticleContainer} container - The container to render using this ParticleRenderer
     * @return {PIXI.ParticleBuffer} generated buffer
     * @private
     */
    _generateOneMoreBuffer(container) {
        var batchSize = container._batchSize;
        var dynamicPropertyFlags = container._properties;
        return new ParticleBuffer_1.ParticleBuffer(this.properties, dynamicPropertyFlags, batchSize);
    }
    ;
    /**
     * Uploads the vertices.
     *
     * @param {PIXI.DisplayObject[]} children - the array of display objects to render
     * @param {number} startIndex - the index to start from in the children array
     * @param {number} amount - the amount of children that will have their vertices uploaded
     * @param {number[]} array - The vertices to upload.
     * @param {number} stride - Stride to use for iteration.
     * @param {number} offset - Offset to start at.
     */
    uploadVertices(children, startIndex, amount, array, stride, offset) {
        var w0 = 0;
        var w1 = 0;
        var h0 = 0;
        var h1 = 0;
        for (var i = 0; i < amount; ++i) {
            var sprite = children[startIndex + i];
            var texture = sprite._texture;
            var sx = sprite.scale.x;
            var sy = sprite.scale.y;
            var trim = texture.trim;
            var orig = texture.orig;
            if (trim) {
                // if the sprite is trimmed and is not a tilingsprite then we need to add the
                // extra space before transforming the sprite coords..
                w1 = trim.x - (sprite.anchor.x * orig.width);
                w0 = w1 + trim.width;
                h1 = trim.y - (sprite.anchor.y * orig.height);
                h0 = h1 + trim.height;
            }
            else {
                w0 = (orig.width) * (1 - sprite.anchor.x);
                w1 = (orig.width) * -sprite.anchor.x;
                h0 = orig.height * (1 - sprite.anchor.y);
                h1 = orig.height * -sprite.anchor.y;
            }
            array[offset] = w1 * sx;
            array[offset + 1] = h1 * sy;
            array[offset + stride] = w0 * sx;
            array[offset + stride + 1] = h1 * sy;
            array[offset + (stride * 2)] = w0 * sx;
            array[offset + (stride * 2) + 1] = h0 * sy;
            array[offset + (stride * 3)] = w1 * sx;
            array[offset + (stride * 3) + 1] = h0 * sy;
            offset += stride * 4;
        }
    }
    ;
    /**
     * Uploads the position.
     *
     * @param {PIXI.DisplayObject[]} children - the array of display objects to render
     * @param {number} startIndex - the index to start from in the children array
     * @param {number} amount - the amount of children that will have their positions uploaded
     * @param {number[]} array - The vertices to upload.
     * @param {number} stride - Stride to use for iteration.
     * @param {number} offset - Offset to start at.
     */
    uploadPosition(children, startIndex, amount, array, stride, offset) {
        for (var i = 0; i < amount; i++) {
            var spritePosition = children[startIndex + i].position;
            array[offset] = spritePosition.x;
            array[offset + 1] = spritePosition.y;
            array[offset + stride] = spritePosition.x;
            array[offset + stride + 1] = spritePosition.y;
            array[offset + (stride * 2)] = spritePosition.x;
            array[offset + (stride * 2) + 1] = spritePosition.y;
            array[offset + (stride * 3)] = spritePosition.x;
            array[offset + (stride * 3) + 1] = spritePosition.y;
            offset += stride * 4;
        }
    }
    ;
    /**
     * Uploads the rotiation.
     *
     * @param {PIXI.DisplayObject[]} children - the array of display objects to render
     * @param {number} startIndex - the index to start from in the children array
     * @param {number} amount - the amount of children that will have their rotation uploaded
     * @param {number[]} array - The vertices to upload.
     * @param {number} stride - Stride to use for iteration.
     * @param {number} offset - Offset to start at.
     */
    uploadRotation(children, startIndex, amount, array, stride, offset) {
        for (var i = 0; i < amount; i++) {
            var spriteRotation = children[startIndex + i].rotation;
            array[offset] = spriteRotation;
            array[offset + stride] = spriteRotation;
            array[offset + (stride * 2)] = spriteRotation;
            array[offset + (stride * 3)] = spriteRotation;
            offset += stride * 4;
        }
    }
    ;
    /**
     * Uploads the Uvs
     *
     * @param {PIXI.DisplayObject[]} children - the array of display objects to render
     * @param {number} startIndex - the index to start from in the children array
     * @param {number} amount - the amount of children that will have their rotation uploaded
     * @param {number[]} array - The vertices to upload.
     * @param {number} stride - Stride to use for iteration.
     * @param {number} offset - Offset to start at.
     */
    uploadUvs(children, startIndex, amount, array, stride, offset) {
        for (var i = 0; i < amount; ++i) {
            var textureUvs = children[startIndex + i]._texture._uvs;
            if (textureUvs) {
                array[offset] = textureUvs.x0;
                array[offset + 1] = textureUvs.y0;
                array[offset + stride] = textureUvs.x1;
                array[offset + stride + 1] = textureUvs.y1;
                array[offset + (stride * 2)] = textureUvs.x2;
                array[offset + (stride * 2) + 1] = textureUvs.y2;
                array[offset + (stride * 3)] = textureUvs.x3;
                array[offset + (stride * 3) + 1] = textureUvs.y3;
                offset += stride * 4;
            }
            else {
                // TODO you know this can be easier!
                array[offset] = 0;
                array[offset + 1] = 0;
                array[offset + stride] = 0;
                array[offset + stride + 1] = 0;
                array[offset + (stride * 2)] = 0;
                array[offset + (stride * 2) + 1] = 0;
                array[offset + (stride * 3)] = 0;
                array[offset + (stride * 3) + 1] = 0;
                offset += stride * 4;
            }
        }
    }
    ;
    /**
     * Uploads the tint.
     *
     * @param {PIXI.DisplayObject[]} children - the array of display objects to render
     * @param {number} startIndex - the index to start from in the children array
     * @param {number} amount - the amount of children that will have their rotation uploaded
     * @param {number[]} array - The vertices to upload.
     * @param {number} stride - Stride to use for iteration.
     * @param {number} offset - Offset to start at.
     */
    uploadTint(children, startIndex, amount, array, stride, offset) {
        for (var i = 0; i < amount; ++i) {
            var sprite = children[startIndex + i];
            var premultiplied = sprite._texture.baseTexture.premultiplyAlpha;
            var alpha = sprite.alpha;
            // we dont call extra function if alpha is 1.0, that's faster
            var argb = alpha < 1.0 && premultiplied ? ColorSettings_1.ColorSettings.premultiplyTint(sprite._tintRGB, alpha)
                : sprite._tintRGB + (alpha * 255 << 24);
            array[offset] = argb;
            array[offset + stride] = argb;
            array[offset + (stride * 2)] = argb;
            array[offset + (stride * 3)] = argb;
            offset += stride * 4;
        }
    }
    ;
    /**
     * Destroys the ParticleRenderer.
     */
    destroy() {
        super.destroy();
        if (this.shader) {
            this.shader.destroy();
            this.shader = null;
        }
        this.tempMatrix = null;
    }
    ;
}
ParticleRenderer.vertex$2 = "attribute vec2 aVertexPosition;\r\nattribute vec2 aTextureCoord;\r\nattribute vec4 aColor;\r\n\r\nattribute vec2 aPositionCoord;\r\nattribute float aRotation;\r\n\r\nuniform mat3 translationMatrix;\r\nuniform vec4 uColor;\r\n\r\nvarying vec2 vTextureCoord;\r\nvarying vec4 vColor;\r\n\r\nvoid main(void){\r\n    float x = (aVertexPosition.x) * cos(aRotation) - (aVertexPosition.y) * sin(aRotation);\r\n    float y = (aVertexPosition.x) * sin(aRotation) + (aVertexPosition.y) * cos(aRotation);\r\n\r\n    vec2 v = vec2(x, y);\r\n    v = v + aPositionCoord;\r\n\r\n    gl_Position = vec4((translationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);\r\n\r\n    vTextureCoord = aTextureCoord;\r\n    vColor = aColor * uColor;\r\n}\r\n";
ParticleRenderer.fragment$1 = "varying vec2 vTextureCoord;\r\nvarying vec4 vColor;\r\n\r\nuniform sampler2D uSampler;\r\n\r\nvoid main(void){\r\n    vec4 color = texture2D(uSampler, vTextureCoord) * vColor;\r\n    gl_FragColor = color;\r\n}";
exports.ParticleRenderer = ParticleRenderer;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/Point.js":
/*!*****************************************!*\
  !*** ./js-compile/raw-pixi-ts/Point.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class Point {
    constructor(x = 0, y = 0) {
        if (x === void 0) {
            x = 0;
        }
        if (y === void 0) {
            y = 0;
        }
        /**
         * @member {number}
         * @default 0
         */
        this.x = x;
        /**
         * @member {number}
         * @default 0
         */
        this.y = y;
    }
    /**
     * Sets the point to a new x and y position.
     * If y is omitted, both x and y will be set to x.
     *
     * @param {number} [x=0] - position of the point on the x axis
     * @param {number} [y=0] - position of the point on the y axis
     */
    set(x = 0, y = 0) {
        this.x = x || 0;
        this.y = y || ((y !== 0) ? this.x : 0);
    }
    ;
    /**
     * Returns true if the given point is equal to this point
     *
     * @param {PIXI.IPoint} p - The point to check
     * @returns {boolean} Whether the given point equal to this point
     */
    equals(p) {
        return (p.x === this.x) && (p.y === this.y);
    }
    ;
    /**
     * Copies x and y into the given point
     *
     * @param {PIXI.IPoint} p - The point to copy.
     * @returns {PIXI.IPoint} Given point with values updated
     */
    copyTo(p) {
        p.set(this.x, this.y);
        return p;
    }
    ;
    /**
     * Copies x and y from the given point
     *
     * @param {PIXI.IPoint} p - The point to copy from
     * @returns {PIXI.IPoint} Returns itself.
     */
    copyFrom(p) {
        this.set(p.x, p.y);
        return this;
    }
    ;
    /**
     * Creates a clone of this point
     *
     * @return {PIXI.Point} a copy of the point
     */
    clone() {
        return new Point(this.x, this.y);
    }
    ;
}
exports.Point = Point;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/Polygon.js":
/*!*******************************************!*\
  !*** ./js-compile/raw-pixi-ts/Polygon.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Point_1 = __webpack_require__(/*! ./Point */ "./js-compile/raw-pixi-ts/Point.js");
const ShapeSettings_1 = __webpack_require__(/*! ./ShapeSettings */ "./js-compile/raw-pixi-ts/ShapeSettings.js");
class Polygon {
    constructor(arg = null) {
        var arguments$1 = arguments;
        var points = [], len = arguments.length;
        while (len--) {
            points[len] = arguments$1[len];
        }
        if (Array.isArray(points[0])) {
            points = points[0];
        }
        // if this is an array of points, convert it to a flat array of numbers
        if (points[0] instanceof Point_1.Point) {
            var p = [];
            for (var i = 0, il = points.length; i < il; i++) {
                p.push(points[i].x, points[i].y);
            }
            points = p;
        }
        /**
         * An array of the points of this polygon
         *
         * @member {number[]}
         */
        this.points = points;
        /**
         * The type of the object, mainly used to avoid `instanceof` checks
         *
         * @member {number}
         * @readOnly
         * @default PIXI.SHAPES.POLY
         * @see PIXI.SHAPES
         */
        this.type = ShapeSettings_1.ShapeSettings.SHAPES.POLY;
        /**
         * `false` after moveTo, `true` after `closePath`. In all other cases it is `true`.
         * @member {boolean}
         * @default true
         */
        this.closeStroke = true;
    }
    /**
     * Creates a clone of this polygon
     *
     * @return {PIXI.Polygon} a copy of the polygon
     */
    clone() {
        var polygon = new Polygon(this.points.slice());
        polygon.closeStroke = this.closeStroke;
        return polygon;
    }
    ;
    /**
     * Checks whether the x and y coordinates passed to this function are contained within this polygon
     *
     * @param {number} x - The X coordinate of the point to test
     * @param {number} y - The Y coordinate of the point to test
     * @return {boolean} Whether the x/y coordinates are within this polygon
     */
    contains(x, y) {
        var inside = false;
        // use some raycasting to test hits
        // https://github.com/substack/point-in-polygon/blob/master/index.js
        var length = this.points.length / 2;
        for (var i = 0, j = length - 1; i < length; j = i++) {
            var xi = this.points[i * 2];
            var yi = this.points[(i * 2) + 1];
            var xj = this.points[j * 2];
            var yj = this.points[(j * 2) + 1];
            var intersect = ((yi > y) !== (yj > y)) && (x < ((xj - xi) * ((y - yi) / (yj - yi))) + xi);
            if (intersect) {
                inside = !inside;
            }
        }
        return inside;
    }
    ;
}
exports.Polygon = Polygon;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/Prepare.js":
/*!*******************************************!*\
  !*** ./js-compile/raw-pixi-ts/Prepare.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BasePrepare_1 = __webpack_require__(/*! ./BasePrepare */ "./js-compile/raw-pixi-ts/BasePrepare.js");
// import { settings } from "./settings";
const Graphics_1 = __webpack_require__(/*! ./Graphics */ "./js-compile/raw-pixi-ts/Graphics.js");
const BaseTexture_1 = __webpack_require__(/*! ./BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
class Prepare extends BasePrepare_1.BasePrepare {
    constructor(renderer) {
        super(renderer);
        this.uploadHookHelper = this.renderer;
        // Add textures and graphics to upload
        this.registerFindHook(Prepare.findGraphics);
        this.registerUploadHook(Prepare.uploadBaseTextures);
        this.registerUploadHook(Prepare.uploadGraphics);
    }
    static findGraphics(item, queue) {
        if (item instanceof Graphics_1.Graphics) {
            queue.push(item);
            return true;
        }
        return false;
    }
    static uploadBaseTextures(renderer, item) {
        if (item instanceof BaseTexture_1.BaseTexture) {
            if (!item._glTextures[renderer.CONTEXT_UID]) {
                renderer.textureManager.updateTexture(item);
            }
            return true;
        }
        return false;
    }
    static uploadGraphics(renderer, item) {
        if (item instanceof Graphics_1.Graphics) {
            if (item.dirty || item.clearDirty || !item._webGL[renderer.plugins.graphics.CONTEXT_UID]) {
                renderer.plugins.graphics.updateGraphics(item);
            }
            return true;
        }
        return false;
    }
}
exports.Prepare = Prepare;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/Program.js":
/*!*******************************************!*\
  !*** ./js-compile/raw-pixi-ts/Program.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Shader_1 = __webpack_require__(/*! ./Shader */ "./js-compile/raw-pixi-ts/Shader.js");
const CacheSettings_1 = __webpack_require__(/*! ./CacheSettings */ "./js-compile/raw-pixi-ts/CacheSettings.js");
const WebGLSettings_1 = __webpack_require__(/*! ./WebGLSettings */ "./js-compile/raw-pixi-ts/WebGLSettings.js");
class Program {
    constructor(vertexSrc, fragmentSrc, name = 'pixi-shader') {
        this.id = Program.UID$3++;
        /**
         * The vertex shader.
         *
         * @member {string}
         */
        this.vertexSrc = vertexSrc || Program.defaultVertexSrc;
        /**
         * The fragment shader.
         *
         * @member {string}
         */
        this.fragmentSrc = fragmentSrc || Program.defaultFragmentSrc;
        this.vertexSrc = this.vertexSrc.trim();
        this.fragmentSrc = this.fragmentSrc.trim();
        if (this.vertexSrc.substring(0, 8) !== '#version') {
            name = name.replace(/\s+/g, '-');
            if (CacheSettings_1.CacheSettings.nameCache[name]) {
                CacheSettings_1.CacheSettings.nameCache[name]++;
                name += "-" + (CacheSettings_1.CacheSettings.nameCache[name]);
            }
            else {
                CacheSettings_1.CacheSettings.nameCache[name] = 1;
            }
            this.vertexSrc = "#define SHADER_NAME " + name + "\n" + (this.vertexSrc);
            this.fragmentSrc = "#define SHADER_NAME " + name + "\n" + (this.fragmentSrc);
            this.vertexSrc = WebGLSettings_1.WebGLSettings.setPrecision(this.vertexSrc, WebGLSettings_1.WebGLSettings.PRECISION_VERTEX);
            this.fragmentSrc = WebGLSettings_1.WebGLSettings.setPrecision(this.fragmentSrc, WebGLSettings_1.WebGLSettings.PRECISION_FRAGMENT);
        }
        if (name == "pixi-shader-4") {
        }
        // currently this does not extract structs only default types
        this.extractData(this.vertexSrc, this.fragmentSrc);
        // this is where we store shader references..
        this.glPrograms = {};
        this.syncUniforms = null;
    }
    /**
     * Extracts the data for a buy creating a small test program
     * or reading the src directly.
     * @protected
     *
     * @param {string} [vertexSrc] - The source of the vertex shader.
     * @param {string} [fragmentSrc] - The source of the fragment shader.
     */
    extractData(vertexSrc, fragmentSrc) {
        var gl = WebGLSettings_1.WebGLSettings.getTestContext();
        if (gl) {
            var program = Program.compileProgram(gl, vertexSrc, fragmentSrc);
            this.attributeData = this.getAttributeData(program, gl);
            this.uniformData = this.getUniformData(program, gl);
            gl.deleteProgram(program);
        }
        else {
            this.uniformData = {};
            this.attributeData = {};
        }
    }
    ;
    /**
     * returns the attribute data from the program
     * @private
     *
     * @param {WebGLProgram} [program] - the WebGL program
     * @param {WebGLRenderingContext} [gl] - the WebGL context
     *
     * @returns {object} the attribute data for this program
     */
    getAttributeData(program, gl) {
        var attributes = {};
        var attributesArray = [];
        var totalAttributes = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
        for (var i = 0; i < totalAttributes; i++) {
            var attribData = gl.getActiveAttrib(program, i);
            var type = WebGLSettings_1.WebGLSettings.mapType(gl, attribData.type);
            /*eslint-disable */
            var data = {
                type: type,
                name: attribData.name,
                size: WebGLSettings_1.WebGLSettings.mapSize(type),
                location: 0,
            };
            /* eslint-enable */
            attributes[attribData.name] = data;
            attributesArray.push(data);
        }
        attributesArray.sort(function (a, b) { return (a.name > b.name) ? 1 : -1; }); // eslint-disable-line no-confusing-arrow
        for (var i$1 = 0; i$1 < attributesArray.length; i$1++) {
            attributesArray[i$1].location = i$1;
        }
        return attributes;
    }
    ;
    /**
     * returns the uniform data from the program
     * @private
     *
     * @param {webGL-program} [program] - the webgl program
     * @param {context} [gl] - the WebGL context
     *
     * @returns {object} the uniform data for this program
     */
    getUniformData(program, gl) {
        var uniforms = {};
        var totalUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
        // TODO expose this as a prop?
        // const maskRegex = new RegExp('^(projectionMatrix|uSampler|translationMatrix)$');
        // const maskRegex = new RegExp('^(projectionMatrix|uSampler|translationMatrix)$');
        for (var i = 0; i < totalUniforms; i++) {
            var uniformData = gl.getActiveUniform(program, i);
            var name = uniformData.name.replace(/\[.*?\]/, '');
            var isArray = uniformData.name.match(/\[.*?\]/, '');
            var type = WebGLSettings_1.WebGLSettings.mapType(gl, uniformData.type);
            /*eslint-disable */
            uniforms[name] = {
                type: type,
                size: uniformData.size,
                isArray: isArray,
                value: WebGLSettings_1.WebGLSettings.defaultValue(type, uniformData.size),
            };
            /* eslint-enable */
        }
        return uniforms;
    }
    ;
    /**
     * The default vertex shader source
     *
     * @static
     * @constant
     * @member {string}
     */
    static get defaultVertexSrc() {
        return Program.defaultVertex;
    }
    ;
    /**
     * The default fragment shader source
     *
     * @static
     * @constant
     * @member {string}
     */
    static get defaultFragmentSrc() {
        return Program.defaultFragment;
    }
    ;
    /**
     * A short hand function to create a program based of a vertex and fragment shader
     * this method will also check to see if there is a cached program.
     *
     * @param {string} [vertexSrc] - The source of the vertex shader.
     * @param {string} [fragmentSrc] - The source of the fragment shader.
     * @param {object} [uniforms] - Custom uniforms to use to augment the built-in ones.
     *
     * @returns {PIXI.Program} an shiny new Pixi shader!
     */
    static from(vertexSrc, fragmentSrc, name = "pixi-shader") {
        var key = vertexSrc + fragmentSrc;
        var program = CacheSettings_1.CacheSettings.ProgramCache[key];
        if (!program) {
            CacheSettings_1.CacheSettings.ProgramCache[key] = program = new Program(vertexSrc, fragmentSrc, name);
        }
        return program;
    }
    ;
    /**
 * @method compileProgram
 * @private
 * @memberof PIXI.glCore.shader
 * @param gl {WebGLRenderingContext} The current WebGL context {WebGLProgram}
 * @param vertexSrc {string|string[]} The vertex shader source as an array of strings.
 * @param fragmentSrc {string|string[]} The fragment shader source as an array of strings.
 * @param attributeLocations {Object} An attribute location map that lets you manually set the attribute locations
 * @return {WebGLProgram} the shader program
 */
    static compileProgram(gl, vertexSrc, fragmentSrc, attributeLocations = null) {
        var glVertShader = Shader_1.Shader.compileShader(gl, gl.VERTEX_SHADER, vertexSrc);
        var glFragShader = Shader_1.Shader.compileShader(gl, gl.FRAGMENT_SHADER, fragmentSrc);
        var program = gl.createProgram();
        gl.attachShader(program, glVertShader);
        gl.attachShader(program, glFragShader);
        // optionally, set the attributes manually for the program rather than letting WebGL decide..
        if (attributeLocations) {
            for (var i in attributeLocations) {
                gl.bindAttribLocation(program, attributeLocations[i], i);
            }
        }
        gl.linkProgram(program);
        // if linking fails, then log and cleanup
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            console.error('Pixi.js Error: Could not initialize shader.');
            console.error('gl.VALIDATE_STATUS', gl.getProgramParameter(program, gl.VALIDATE_STATUS));
            console.error('gl.getError()', gl.getError());
            // if there is a program info log, log it
            if (gl.getProgramInfoLog(program) !== '') {
                console.warn('Pixi.js Warning: gl.getProgramInfoLog()', gl.getProgramInfoLog(program));
            }
            gl.deleteProgram(program);
            program = null;
        }
        // clean up some shaders
        gl.deleteShader(glVertShader);
        gl.deleteShader(glFragShader);
        return program;
    }
}
Program.UID$3 = 0;
Program.defaultFragment = "varying vec2 vTextureCoord;\r\n\r\nuniform sampler2D uSampler;\r\n\r\nvoid main(void){\r\n   gl_FragColor *= texture2D(uSampler, vTextureCoord);\r\n}";
Program.defaultVertex = "attribute vec2 aVertexPosition;\r\nattribute vec2 aTextureCoord;\r\n\r\nuniform mat3 projectionMatrix;\r\n\r\nvarying vec2 vTextureCoord;\r\n\r\nvoid main(void){\r\n   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\r\n   vTextureCoord = aTextureCoord;\r\n}\r\n";
exports.Program = Program;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/ProgressEvent.js":
/*!*************************************************!*\
  !*** ./js-compile/raw-pixi-ts/ProgressEvent.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Event_1 = __webpack_require__(/*! ./Event */ "./js-compile/raw-pixi-ts/Event.js");
class ProgressEvent extends Event_1.Event {
    constructor(type, bubbles = false, cancelable = false) {
        super(type, bubbles, cancelable);
    }
    clone() {
        var event = ProgressEvent.getProgressEvent(this.type, this.bubbles, this.cancelable);
        event.bytesLoaded = this.bytesLoaded;
        event.bytesTotal = this.bytesTotal;
        event.percent = this.percent;
        return event;
    }
    get isDisposable() {
        return true;
    }
    static getProgressEvent(type, bubble = true, cancelable = true) {
        if (ProgressEvent.ProgressEventCache.length) {
            let te = ProgressEvent.ProgressEventCache[ProgressEvent.ProgressEventCache.length - 1];
            ProgressEvent.ProgressEventCache.length -= 1;
            te.reset(type, bubble, cancelable);
            return te;
        }
        return new ProgressEvent(type, bubble, cancelable);
    }
    destructor() {
        this._currentTarget = null;
        // this._legacyTarget = null;
        let index = ProgressEvent.ProgressEventCache.indexOf(this);
        if (index < 0) {
            ProgressEvent.ProgressEventCache.push(this);
        }
    }
}
ProgressEvent.ProgressEventCache = [];
ProgressEvent.PROGRESS = "progress";
exports.ProgressEvent = ProgressEvent;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/ProjectionSystem.js":
/*!****************************************************!*\
  !*** ./js-compile/raw-pixi-ts/ProjectionSystem.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const System_1 = __webpack_require__(/*! ./System */ "./js-compile/raw-pixi-ts/System.js");
const Matrix_1 = __webpack_require__(/*! ./Matrix */ "./js-compile/raw-pixi-ts/Matrix.js");
class ProjectionSystem extends System_1.System {
    constructor(renderer) {
        super(renderer);
        /**
         * Destination frame
         * @member {PIXI.Rectangle}
         * @readonly
         */
        this.destinationFrame = null;
        /**
         * Source frame
         * @member {PIXI.Rectangle}
         * @readonly
         */
        this.sourceFrame = null;
        /**
         * Default destination frame
         * @member {PIXI.Rectangle}
         * @readonly
         */
        this.defaultFrame = null;
        /**
         * Project matrix
         * @member {PIXI.Matrix}
         * @readonly
         */
        this.projectionMatrix = new Matrix_1.Matrix();
        /**
         * A transform that will be appended to the projection matrix
         * if null, nothing will be applied
         * @member {PIXI.Matrix}
         */
        this.transform = null;
    }
    /**
     * Updates the projection matrix based on a projection frame (which is a rectangle)
     *
     * @param {PIXI.Rectangle} destinationFrame - The destination frame.
     * @param {PIXI.Rectangle} sourceFrame - The source frame.
     * @param {Number} resolution - Resolution
     * @param {boolean} root - If is root
     */
    update(destinationFrame, sourceFrame, resolution, root) {
        this.destinationFrame = destinationFrame || this.destinationFrame || this.defaultFrame;
        this.sourceFrame = sourceFrame || this.sourceFrame || destinationFrame;
        this.calculateProjection(this.destinationFrame, this.sourceFrame, resolution, root);
        if (this.transform) {
            this.projectionMatrix.append(this.transform);
        }
        var renderer = this.renderer;
        renderer.globalUniforms.uniforms.projectionMatrix = this.projectionMatrix;
        renderer.globalUniforms.update();
        // this will work for now
        // but would be sweet to stick and even on the global uniforms..
        if (renderer.shader.shader) {
            renderer.shader.syncUniformGroup(renderer.shader.shader.uniforms.globals);
        }
    }
    ;
    /**
     * Updates the projection matrix based on a projection frame (which is a rectangle)
     *
     * @param {PIXI.Rectangle} destinationFrame - The destination frame.
     * @param {PIXI.Rectangle} sourceFrame - The source frame.
     * @param {Number} resolution - Resolution
     * @param {boolean} root - If is root
     */
    calculateProjection(destinationFrame, sourceFrame, resolution, root) {
        var pm = this.projectionMatrix;
        // I don't think we will need this line..
        // pm.identity();
        if (!root) {
            pm.a = (1 / destinationFrame.width * 2) * resolution;
            pm.d = (1 / destinationFrame.height * 2) * resolution;
            pm.tx = -1 - (sourceFrame.x * pm.a);
            pm.ty = -1 - (sourceFrame.y * pm.d);
        }
        else {
            pm.a = (1 / destinationFrame.width * 2) * resolution;
            pm.d = (-1 / destinationFrame.height * 2) * resolution;
            pm.tx = -1 - (sourceFrame.x * pm.a);
            pm.ty = 1 - (sourceFrame.y * pm.d);
        }
    }
    ;
    /**
     * Sets the transform of the active render target to the given matrix
     *
     * @param {PIXI.Matrix} matrix - The transformation matrix
     */
    setTransform() {
        // this._activeRenderTarget.transform = matrix;
    }
    ;
}
exports.ProjectionSystem = ProjectionSystem;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/Quad.js":
/*!****************************************!*\
  !*** ./js-compile/raw-pixi-ts/Quad.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Geometry_1 = __webpack_require__(/*! ./Geometry */ "./js-compile/raw-pixi-ts/Geometry.js");
class Quad extends Geometry_1.Geometry {
    constructor() {
        super();
        this.addAttribute('aVertexPosition', [0, 0, 1, 0, 1, 1, 0, 1]).addIndex([0, 1, 3, 2]);
    }
}
exports.Quad = Quad;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/QuadUv.js":
/*!******************************************!*\
  !*** ./js-compile/raw-pixi-ts/QuadUv.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Geometry_1 = __webpack_require__(/*! ./Geometry */ "./js-compile/raw-pixi-ts/Geometry.js");
const Buffer_1 = __webpack_require__(/*! ./Buffer */ "./js-compile/raw-pixi-ts/Buffer.js");
class QuadUv extends Geometry_1.Geometry {
    constructor() {
        super();
        /**
         * An array of vertices
         *
         * @member {Float32Array}
         */
        this.vertices = new Float32Array([
            -1, -1,
            1, -1,
            1, 1,
            -1, 1
        ]);
        /**
         * The Uvs of the quad
         *
         * @member {Float32Array}
         */
        this.uvs = new Float32Array([
            0, 0,
            1, 0,
            1, 1,
            0, 1
        ]);
        this.vertexBuffer = new Buffer_1.Buffer(this.vertices);
        this.uvBuffer = new Buffer_1.Buffer(this.uvs);
        this.addAttribute('aVertexPosition', this.vertexBuffer)
            .addAttribute('aTextureCoord', this.uvBuffer)
            .addIndex([0, 1, 2, 0, 2, 3]);
    }
    /**
     * Maps two Rectangle to the quad.
     *
     * @param {PIXI.Rectangle} targetTextureFrame - the first rectangle
     * @param {PIXI.Rectangle} destinationFrame - the second rectangle
     * @return {PIXI.Quad} Returns itself.
     */
    map(targetTextureFrame, destinationFrame) {
        var x = 0; // destinationFrame.x / targetTextureFrame.width;
        var y = 0; // destinationFrame.y / targetTextureFrame.height;
        this.uvs[0] = x;
        this.uvs[1] = y;
        this.uvs[2] = x + (destinationFrame.width / targetTextureFrame.width);
        this.uvs[3] = y;
        this.uvs[4] = x + (destinationFrame.width / targetTextureFrame.width);
        this.uvs[5] = y + (destinationFrame.height / targetTextureFrame.height);
        this.uvs[6] = x;
        this.uvs[7] = y + (destinationFrame.height / targetTextureFrame.height);
        x = destinationFrame.x;
        y = destinationFrame.y;
        this.vertices[0] = x;
        this.vertices[1] = y;
        this.vertices[2] = x + destinationFrame.width;
        this.vertices[3] = y;
        this.vertices[4] = x + destinationFrame.width;
        this.vertices[5] = y + destinationFrame.height;
        this.vertices[6] = x;
        this.vertices[7] = y + destinationFrame.height;
        this.invalidate();
        return this;
    }
    ;
    /**
     * legacy upload method, just marks buffers dirty
     * @returns {PIXI.QuadUv} Returns itself.
     */
    invalidate() {
        this.vertexBuffer._updateID++;
        this.uvBuffer._updateID++;
        return this;
    }
    ;
}
exports.QuadUv = QuadUv;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/QuadraticUtils.js":
/*!**************************************************!*\
  !*** ./js-compile/raw-pixi-ts/QuadraticUtils.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const settings_1 = __webpack_require__(/*! ./settings */ "./js-compile/raw-pixi-ts/settings.js");
class QuadraticUtils {
    static curveLength(fromX, fromY, cpX, cpY, toX, toY) {
        var ax = fromX - (2.0 * cpX) + toX;
        var ay = fromY - (2.0 * cpY) + toY;
        var bx = (2.0 * cpX) - (2.0 * fromX);
        var by = (2.0 * cpY) - (2.0 * fromY);
        var a = 4.0 * ((ax * ax) + (ay * ay));
        var b = 4.0 * ((ax * bx) + (ay * by));
        var c = (bx * bx) + (by * by);
        var s = 2.0 * Math.sqrt(a + b + c);
        var a2 = Math.sqrt(a);
        var a32 = 2.0 * a * a2;
        var c2 = 2.0 * Math.sqrt(c);
        var ba = b / a2;
        return ((a32 * s)
            + (a2 * b * (s - c2))
            + (((4.0 * c * a) - (b * b))
                * Math.log(((2.0 * a2) + ba + s) / (ba + c2)))) / (4.0 * a32);
    }
    ;
    /**
     * Calculate the points for a quadratic bezier curve and then draws it.
     * Based on: https://stackoverflow.com/questions/785097/how-do-i-implement-a-bezier-curve-in-c
     *
     * @private
     * @param {number} cpX - Control point x
     * @param {number} cpY - Control point y
     * @param {number} toX - Destination point x
     * @param {number} toY - Destination point y
     * @param {number[]} points - Points to add segments to.
     */
    static curveTo(cpX, cpY, toX, toY, points) {
        var fromX = points[points.length - 2];
        var fromY = points[points.length - 1];
        var n = settings_1.settings.GRAPHICS_CURVES._segmentsCount(QuadraticUtils.curveLength(fromX, fromY, cpX, cpY, toX, toY));
        var xa = 0;
        var ya = 0;
        for (var i = 1; i <= n; ++i) {
            var j = i / n;
            xa = fromX + ((cpX - fromX) * j);
            ya = fromY + ((cpY - fromY) * j);
            points.push(xa + (((cpX + ((toX - cpX) * j)) - xa) * j), ya + (((cpY + ((toY - cpY) * j)) - ya) * j));
        }
    }
    ;
}
exports.QuadraticUtils = QuadraticUtils;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/Rectangle.js":
/*!*********************************************!*\
  !*** ./js-compile/raw-pixi-ts/Rectangle.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const ShapeSettings_1 = __webpack_require__(/*! ./ShapeSettings */ "./js-compile/raw-pixi-ts/ShapeSettings.js");
class Rectangle {
    constructor(x = 0, y = 0, width = 0, height = 0) {
        if (x === void 0) {
            x = 0;
        }
        if (y === void 0) {
            y = 0;
        }
        if (width === void 0) {
            width = 0;
        }
        if (height === void 0) {
            height = 0;
        }
        /**
         * @member {number}
         * @default 0
         */
        this.x = Number(x);
        /**
         * @member {number}
         * @default 0
         */
        this.y = Number(y);
        /**
         * @member {number}
         * @default 0
         */
        this.width = Number(width);
        /**
         * @member {number}
         * @default 0
         */
        this.height = Number(height);
        /**
         * The type of the object, mainly used to avoid `instanceof` checks
         *
         * @member {number}
         * @readOnly
         * @default PIXI.SHAPES.RECT
         * @see PIXI.SHAPES
         */
        this.type = ShapeSettings_1.ShapeSettings.SHAPES.RECT;
    }
    /**
     * returns the left edge of the rectangle
     *
     * @member {number}
     */
    get left() {
        return this.x;
    }
    ;
    /**
     * returns the right edge of the rectangle
     *
     * @member {number}
     */
    get right() {
        return this.x + this.width;
    }
    ;
    /**
     * returns the top edge of the rectangle
     *
     * @member {number}
     */
    get top() {
        return this.y;
    }
    ;
    /**
     * returns the bottom edge of the rectangle
     *
     * @member {number}
     */
    get bottom() {
        return this.y + this.height;
    }
    ;
    /**
     * A constant empty rectangle.
     *
     * @static
     * @constant
     * @member {PIXI.Rectangle}
     */
    static get EMPTY() {
        return new Rectangle(0, 0, 0, 0);
    }
    ;
    /**
     * Creates a clone of this Rectangle
     *
     * @return {PIXI.Rectangle} a copy of the rectangle
     */
    clone() {
        return new Rectangle(this.x, this.y, this.width, this.height);
    }
    ;
    /**
     * Copies another rectangle to this one.
     *
     * @param {PIXI.Rectangle} rectangle - The rectangle to copy from.
     * @return {PIXI.Rectangle} Returns itself.
     */
    copyFrom(rectangle) {
        this.x = rectangle.x;
        this.y = rectangle.y;
        this.width = rectangle.width;
        this.height = rectangle.height;
        return this;
    }
    ;
    /**
     * Copies this rectangle to another one.
     *
     * @param {PIXI.Rectangle} rectangle - The rectangle to copy to.
     * @return {PIXI.Rectangle} Returns given parameter.
     */
    copyTo(rectangle) {
        rectangle.x = this.x;
        rectangle.y = this.y;
        rectangle.width = this.width;
        rectangle.height = this.height;
        return rectangle;
    }
    ;
    /**
     * Checks whether the x and y coordinates given are contained within this Rectangle
     *
     * @param {number} x - The X coordinate of the point to test
     * @param {number} y - The Y coordinate of the point to test
     * @return {boolean} Whether the x/y coordinates are within this Rectangle
     */
    contains(x, y) {
        if (this.width <= 0 || this.height <= 0) {
            return false;
        }
        if (x >= this.x && x < this.x + this.width) {
            if (y >= this.y && y < this.y + this.height) {
                return true;
            }
        }
        return false;
    }
    ;
    /**
     * Pads the rectangle making it grow in all directions.
     *
     * @param {number} paddingX - The horizontal padding amount.
     * @param {number} paddingY - The vertical padding amount.
     */
    pad(paddingX, paddingY) {
        paddingX = paddingX || 0;
        paddingY = paddingY || ((paddingY !== 0) ? paddingX : 0);
        this.x -= paddingX;
        this.y -= paddingY;
        this.width += paddingX * 2;
        this.height += paddingY * 2;
    }
    ;
    /**
     * Fits this rectangle around the passed one.
     *
     * @param {PIXI.Rectangle} rectangle - The rectangle to fit.
     */
    fit(rectangle) {
        var x1 = Math.max(this.x, rectangle.x);
        var x2 = Math.min(this.x + this.width, rectangle.x + rectangle.width);
        var y1 = Math.max(this.y, rectangle.y);
        var y2 = Math.min(this.y + this.height, rectangle.y + rectangle.height);
        this.x = x1;
        this.width = Math.max(x2 - x1, 0);
        this.y = y1;
        this.height = Math.max(y2 - y1, 0);
    }
    ;
    /**
     * Enlarges rectangle that way its corners lie on grid
     *
     * @param {number} [resolution=1] resolution
     * @param {number} [eps=0.001] precision
     */
    ceil(resolution, eps) {
        if (resolution === void 0) {
            resolution = 1;
        }
        if (eps === void 0) {
            eps = 0.001;
        }
        var x2 = Math.ceil((this.x + this.width - eps) * resolution) / resolution;
        var y2 = Math.ceil((this.y + this.height - eps) * resolution) / resolution;
        this.x = Math.floor((this.x + eps) * resolution) / resolution;
        this.y = Math.floor((this.y + eps) * resolution) / resolution;
        this.width = x2 - this.x;
        this.height = y2 - this.y;
    }
    ;
    /**
     * Enlarges this rectangle to include the passed rectangle.
     *
     * @param {PIXI.Rectangle} rectangle - The rectangle to include.
     */
    enlarge(rectangle) {
        var x1 = Math.min(this.x, rectangle.x);
        var x2 = Math.max(this.x + this.width, rectangle.x + rectangle.width);
        var y1 = Math.min(this.y, rectangle.y);
        var y2 = Math.max(this.y + this.height, rectangle.y + rectangle.height);
        this.x = x1;
        this.width = x2 - x1;
        this.y = y1;
        this.height = y2 - y1;
    }
    ;
}
exports.Rectangle = Rectangle;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/RenderTexture.js":
/*!*************************************************!*\
  !*** ./js-compile/raw-pixi-ts/RenderTexture.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Texture_1 = __webpack_require__(/*! ./Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const BaseRenderTexture_1 = __webpack_require__(/*! ./BaseRenderTexture */ "./js-compile/raw-pixi-ts/BaseRenderTexture.js");
class RenderTexture extends Texture_1.Texture {
    constructor(baseRenderTexture = null, frame = null) {
        super(baseRenderTexture, frame);
        var _legacyRenderer = null;
        if (!(baseRenderTexture instanceof BaseRenderTexture_1.BaseRenderTexture)) {
            /* eslint-disable prefer-rest-params, no-console */
            var width = arguments[1];
            var height = arguments[2];
            var scaleMode = arguments[3];
            var resolution = arguments[4];
            // we have an old render texture..
            console.warn(("Please use RenderTexture.create(" + width + ", " + height + ") instead of the ctor directly."));
            _legacyRenderer = arguments[0];
            /* eslint-enable prefer-rest-params, no-console */
            frame = null;
            baseRenderTexture = new BaseRenderTexture_1.BaseRenderTexture({
                width: width,
                height: height,
                scaleMode: scaleMode,
                resolution: resolution,
            });
        }
        this.legacyRenderer = _legacyRenderer;
        /**
         * This will let the renderer know if the texture is valid. If it's not then it cannot be rendered.
         *
         * @member {boolean}
         */
        this.valid = true;
        /**
         * FilterSystem temporary storage
         * @protected
         * @member {PIXI.Rectangle}
         */
        this.filterFrame = null;
        /**
        * The key for pooled texture of FilterSystem
        * @protected
        * @member {string}
        */
        this.filterPoolKey = null;
        this.updateUvs();
    }
    /**
    * Resizes the RenderTexture.
    *
    * @param {number} width - The width to resize to.
    * @param {number} height - The height to resize to.
    * @param {boolean} [resizeBaseTexture=true] - Should the baseTexture.width and height values be resized as well?
    */
    resize(width, height, resizeBaseTexture) {
        if (resizeBaseTexture === void 0) {
            resizeBaseTexture = true;
        }
        width = Math.ceil(width);
        height = Math.ceil(height);
        // TODO - could be not required..
        this.valid = (width > 0 && height > 0);
        this._frame.width = this.orig.width = width;
        this._frame.height = this.orig.height = height;
        if (resizeBaseTexture) {
            this.baseTexture.resize(width, height);
        }
        this.updateUvs();
    }
    ;
    /**
     * A short hand way of creating a render texture.
     *
     * @param {object} [options] - Options
     * @param {number} [options.width=100] - The width of the render texture
     * @param {number} [options.height=100] - The height of the render texture
     * @param {number} [options.scaleMode=PIXI.settings.SCALE_MODE] - See {@link PIXI.SCALE_MODES} for possible values
     * @param {number} [options.resolution=1] - The resolution / device pixel ratio of the texture being generated
     * @return {PIXI.RenderTexture} The new render texture
     */
    static create(options, height = null, scaleMode = null, resolution = null) {
        // fallback, old-style: create(width, height, scaleMode, resolution)
        if (typeof options === 'number') {
            /* eslint-disable prefer-rest-params */
            options = {
                width: options,
                height: arguments[1],
                scaleMode: arguments[2],
                resolution: arguments[3],
            };
            /* eslint-enable prefer-rest-params */
        }
        return new RenderTexture(new BaseRenderTexture_1.BaseRenderTexture(options));
    }
    ;
}
exports.RenderTexture = RenderTexture;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/RenderTextureSystem.js":
/*!*******************************************************!*\
  !*** ./js-compile/raw-pixi-ts/RenderTextureSystem.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const System_1 = __webpack_require__(/*! ./System */ "./js-compile/raw-pixi-ts/System.js");
const Rectangle_1 = __webpack_require__(/*! ./Rectangle */ "./js-compile/raw-pixi-ts/Rectangle.js");
class RenderTextureSystem extends System_1.System {
    constructor(renderer) {
        super(renderer);
        /**
         * The clear background color as rgba
         * @member {number[]}
         */
        this.clearColor = renderer._backgroundColorRgba;
        // TODO move this property somewhere else!
        /**
         * List of masks for the StencilSystem
         * @member {PIXI.Graphics[]}
         * @readonly
         */
        this.defaultMaskStack = [];
        // empty render texture?
        /**
         * Render texture
         * @member {PIXI.RenderTexture}
         * @readonly
         */
        this.current = null;
        /**
         * Source frame
         * @member {PIXI.Rectangle}
         * @readonly
         */
        this.sourceFrame = new Rectangle_1.Rectangle();
        /**
         * Destination frame
         * @member {PIXI.Rectangle}
         * @readonly
         */
        this.destinationFrame = new Rectangle_1.Rectangle();
    }
    /**
     * Bind the current render texture
     * @param {PIXI.RenderTexture} renderTexture
     * @param {PIXI.Rectangle} sourceFrame
     * @param {PIXI.Rectangle} destinationFrame
     */
    bind(renderTexture, sourceFrame = null, destinationFrame = null) {
        if (renderTexture === void 0) {
            renderTexture = null;
        }
        this.current = renderTexture;
        var renderer = this.renderer;
        var resolution;
        if (renderTexture) {
            var baseTexture = renderTexture.baseTexture;
            resolution = baseTexture.resolution;
            if (!destinationFrame) {
                RenderTextureSystem.tempRect.width = baseTexture.realWidth;
                RenderTextureSystem.tempRect.height = baseTexture.realHeight;
                destinationFrame = RenderTextureSystem.tempRect;
            }
            if (!sourceFrame) {
                sourceFrame = destinationFrame;
            }
            this.renderer.framebuffer.bind(baseTexture.framebuffer, destinationFrame);
            this.renderer.projection.update(destinationFrame, sourceFrame, resolution, false);
            this.renderer.stencil.setMaskStack(baseTexture.stencilMaskStack);
        }
        else {
            resolution = this.renderer.resolution;
            // TODO these validation checks happen deeper down..
            // thing they can be avoided..
            if (!destinationFrame) {
                RenderTextureSystem.tempRect.width = renderer.width;
                RenderTextureSystem.tempRect.height = renderer.height;
                destinationFrame = RenderTextureSystem.tempRect;
            }
            if (!sourceFrame) {
                sourceFrame = destinationFrame;
            }
            renderer.framebuffer.bind(null, destinationFrame);
            // TODO store this..
            this.renderer.projection.update(destinationFrame, sourceFrame, resolution, true);
            this.renderer.stencil.setMaskStack(this.defaultMaskStack);
        }
        this.sourceFrame.copyFrom(sourceFrame);
        this.destinationFrame.x = destinationFrame.x / resolution;
        this.destinationFrame.y = destinationFrame.y / resolution;
        this.destinationFrame.width = destinationFrame.width / resolution;
        this.destinationFrame.height = destinationFrame.height / resolution;
    }
    ;
    /**
     * Erases the render texture and fills the drawing area with a colour
     *
     * @param {number[]} [clearColor] - The color as rgba, default to use the renderer backgroundColor
     * @return {PIXI.Renderer} Returns itself.
     */
    clear(clearColor = null) {
        if (this.current) {
            clearColor = clearColor || this.current.baseTexture.clearColor;
        }
        else {
            clearColor = clearColor || this.clearColor;
        }
        this.renderer.framebuffer.clear(clearColor[0], clearColor[1], clearColor[2], clearColor[3]);
    }
    ;
    resize() {
        // resize the root only!
        this.bind(null);
    }
    ;
    /**
     * Resets renderTexture state
     */
    reset() {
        this.bind(null);
    }
    ;
}
RenderTextureSystem.tempRect = new Rectangle_1.Rectangle();
exports.RenderTextureSystem = RenderTextureSystem;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/Renderer.js":
/*!********************************************!*\
  !*** ./js-compile/raw-pixi-ts/Renderer.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const AbstractRenderer_1 = __webpack_require__(/*! ./AbstractRenderer */ "./js-compile/raw-pixi-ts/AbstractRenderer.js");
const UniformGroup_1 = __webpack_require__(/*! ./UniformGroup */ "./js-compile/raw-pixi-ts/UniformGroup.js");
const Matrix_1 = __webpack_require__(/*! ./Matrix */ "./js-compile/raw-pixi-ts/Matrix.js");
const Event_1 = __webpack_require__(/*! ./Event */ "./js-compile/raw-pixi-ts/Event.js");
const BatchRenderer_1 = __webpack_require__(/*! ./BatchRenderer */ "./js-compile/raw-pixi-ts/BatchRenderer.js");
const BatchSystem_1 = __webpack_require__(/*! ./BatchSystem */ "./js-compile/raw-pixi-ts/BatchSystem.js");
const RenderTextureSystem_1 = __webpack_require__(/*! ./RenderTextureSystem */ "./js-compile/raw-pixi-ts/RenderTextureSystem.js");
const FilterSystem_1 = __webpack_require__(/*! ./FilterSystem */ "./js-compile/raw-pixi-ts/FilterSystem.js");
const TextureGCSystem_1 = __webpack_require__(/*! ./TextureGCSystem */ "./js-compile/raw-pixi-ts/TextureGCSystem.js");
const ProjectionSystem_1 = __webpack_require__(/*! ./ProjectionSystem */ "./js-compile/raw-pixi-ts/ProjectionSystem.js");
const StencilSystem_1 = __webpack_require__(/*! ./StencilSystem */ "./js-compile/raw-pixi-ts/StencilSystem.js");
const FramebufferSystem_1 = __webpack_require__(/*! ./FramebufferSystem */ "./js-compile/raw-pixi-ts/FramebufferSystem.js");
const GeometrySystem_1 = __webpack_require__(/*! ./GeometrySystem */ "./js-compile/raw-pixi-ts/GeometrySystem.js");
const TextureSystem_1 = __webpack_require__(/*! ./TextureSystem */ "./js-compile/raw-pixi-ts/TextureSystem.js");
const ShaderSystem_1 = __webpack_require__(/*! ./ShaderSystem */ "./js-compile/raw-pixi-ts/ShaderSystem.js");
const StateSystem_1 = __webpack_require__(/*! ./StateSystem */ "./js-compile/raw-pixi-ts/StateSystem.js");
const ContextSystem_1 = __webpack_require__(/*! ./ContextSystem */ "./js-compile/raw-pixi-ts/ContextSystem.js");
const MaskSystem_1 = __webpack_require__(/*! ./MaskSystem */ "./js-compile/raw-pixi-ts/MaskSystem.js");
const DisplaySettings_1 = __webpack_require__(/*! ./DisplaySettings */ "./js-compile/raw-pixi-ts/DisplaySettings.js");
const TilingSpriteRenderer_1 = __webpack_require__(/*! ./TilingSpriteRenderer */ "./js-compile/raw-pixi-ts/TilingSpriteRenderer.js");
const AccessibilityManager_1 = __webpack_require__(/*! ./AccessibilityManager */ "./js-compile/raw-pixi-ts/AccessibilityManager.js");
const Extract_1 = __webpack_require__(/*! ./Extract */ "./js-compile/raw-pixi-ts/Extract.js");
const InteractionManager_1 = __webpack_require__(/*! ./InteractionManager */ "./js-compile/raw-pixi-ts/InteractionManager.js");
const ParticleRenderer_1 = __webpack_require__(/*! ./ParticleRenderer */ "./js-compile/raw-pixi-ts/ParticleRenderer.js");
const Prepare_1 = __webpack_require__(/*! ./Prepare */ "./js-compile/raw-pixi-ts/Prepare.js");
const Runner_1 = __webpack_require__(/*! ./Runner */ "./js-compile/raw-pixi-ts/Runner.js");
class Renderer extends AbstractRenderer_1.AbstractRenderer {
    constructor(options) {
        super('WebGL', options);
        this.plugins = {};
        this.type = DisplaySettings_1.DisplaySettings.RENDERER_TYPE.WEBGL;
        this.gl = null;
        this.CONTEXT_UID = 0;
        this.runners = {
            destroy: new Runner_1.Runner('destroy'),
            contextChange: new Runner_1.Runner('contextChange', 1),
            reset: new Runner_1.Runner('reset'),
            update: new Runner_1.Runner('update'),
            postrender: new Runner_1.Runner('postrender'),
            prerender: new Runner_1.Runner('prerender'),
            resize: new Runner_1.Runner('resize', 2),
        };
        this.globalUniforms = new UniformGroup_1.UniformGroup({
            projectionMatrix: new Matrix_1.Matrix(),
        }, true);
        this.addSystem(MaskSystem_1.MaskSystem, 'mask')
            .addSystem(ContextSystem_1.ContextSystem, 'context')
            .addSystem(StateSystem_1.StateSystem, 'state')
            .addSystem(ShaderSystem_1.ShaderSystem, 'shader')
            .addSystem(TextureSystem_1.TextureSystem, 'texture')
            .addSystem(GeometrySystem_1.GeometrySystem, 'geometry')
            .addSystem(FramebufferSystem_1.FramebufferSystem, 'framebuffer')
            .addSystem(StencilSystem_1.StencilSystem, 'stencil')
            .addSystem(ProjectionSystem_1.ProjectionSystem, 'projection')
            .addSystem(TextureGCSystem_1.TextureGCSystem, 'textureGC')
            .addSystem(FilterSystem_1.FilterSystem, 'filter')
            .addSystem(RenderTextureSystem_1.RenderTextureSystem, 'renderTexture')
            .addSystem(BatchSystem_1.BatchSystem, 'batch');
        this.initPlugins(Renderer.__plugins);
        if (options.context) {
            this.context.initFromContext(options.context);
        }
        else {
            this.context.initFromOptions({
                alpha: this.transparent,
                antialias: options.antialias,
                premultipliedAlpha: this.transparent,
                stencil: true,
                preserveDrawingBuffer: options.preserveDrawingBuffer,
                powerPreference: this.options.powerPreference,
            });
        }
        this.renderingToScreen = true;
        //     sayHello(this.context.webGLVersion === 2 ? 'WebGL 2' : 'WebGL 1');
        this.resize(this.options.width, this.options.height);
    }
    static registerPlugin(pluginName, ctor) {
        Renderer.__plugins = Renderer.__plugins || {};
        Renderer.__plugins[pluginName] = ctor;
    }
    ;
    initPlugins(staticMap) {
        for (var o in staticMap) {
            this.plugins[o] = new (staticMap[o])(this);
        }
    }
    ;
    addSystem(ClassRef, name) {
        if (!name) {
            name = ClassRef.name;
        }
        var system = new ClassRef(this);
        if (this[name]) {
            throw new Error(("Whoops! The name \"" + name + "\" is already in use"));
        }
        this[name] = system;
        for (var i in this.runners) {
            this.runners[i].add(system);
        }
        /**
         * Fired after rendering finishes.
         *
         * @event PIXI.Renderer#postrender
         */
        /**
         * Fired before rendering starts.
         *
         * @event PIXI.Renderer#prerender
         */
        /**
         * Fired when the WebGL context is set.
         *
         * @event PIXI.Renderer#context
         * @param {WebGLRenderingContext} gl - WebGL context.
         */
        return this;
    }
    ;
    // protected handleContextChange = (event:Event)=>
    // {
    // 	this.plugins.particle.contextChange(this.context.gl)
    // 	this.framebuffer.contextChange(this.context.gl)		
    // 	this.shader.contextChange(this.context.gl)
    // 	this.geometry.contextChange();
    // 	this.state.contextChange(this.context.gl)
    // 	this.texture.contextChange();
    // 	this.framebuffer.contextChange(this.context.gl)
    // 	this.stencil.contextChange(this.context.gl)
    // 	this.projection.contextChange(this.context.gl)
    // 	this.textureGC.contextChange(this.context.gl)
    // 	this.filter.contextChange(this.context.gl)
    // 	this.renderTexture.contextChange(this.context.gl)
    // 	this.batch.contextChange(this.context.gl)
    // 	this.mask.contextChange(this.context.gl);
    // 	this.plugins.batch.contextChange();		
    // 	this.plugins.tilingSprite.contextChange(this.context.gl)		
    // }
    render(displayObject, renderTexture = null, clear = true, transform = null, skipUpdateTransform = false) {
        this.renderingToScreen = !renderTexture;
        this.runners.prerender.run();
        // this.emit('prerender');
        this.dispatchEvent(Event_1.Event.getEvent("prerender"));
        if (this.context.isLost) {
            return;
        }
        if (!renderTexture) {
            this._lastObjectRendered = displayObject;
        }
        if (!skipUpdateTransform) {
            let cacheParent = displayObject.parent;
            displayObject.parent = this._tempDisplayObjectParent;
            displayObject.updateTransform();
            displayObject.parent = cacheParent;
        }
        this.renderTexture.bind(renderTexture);
        this.batch.currentRenderer.start();
        if (clear !== undefined ? clear : this.clearBeforeRender) {
            this.renderTexture.clear();
        }
        displayObject.render(this);
        this.batch.currentRenderer.flush();
        if (renderTexture) {
            renderTexture.baseTexture.update();
        }
        this.runners.postrender.run();
        this.dispatchEvent(Event_1.Event.getEvent("postrender"));
    }
    ;
    resize(screenWidth, screenHeight) {
        super.resize(screenWidth, screenHeight);
        this.runners.resize.run(screenWidth, screenHeight);
        // this.dispatchEvent(Event.getEvent("resize"));
    }
    ;
    reset() {
        this.runners.reset.run();
        // this.dispatchEvent(Event.getEvent("reset"));
        return this;
    }
    ;
    clear() {
        this.framebuffer.bind();
        this.framebuffer.clear();
    }
    ;
    destroy(options = null) {
        this.runners.destroy.run();
        // this.dispatchEvent(Event.getEvent("destroy"));
        super.destroy(options);
        this.gl = null;
    }
    ;
}
Renderer.__plugins = {};
exports.Renderer = Renderer;
class RendererPlugins {
    constructor(renderer) {
        this.particle = new ParticleRenderer_1.ParticleRenderer(renderer);
        this.tilingSprite = new TilingSpriteRenderer_1.TilingSpriteRenderer(renderer);
        this.accessibility = new AccessibilityManager_1.AccessibilityManager(renderer);
        this.extract = new Extract_1.Extract(renderer);
        this.interaction = new InteractionManager_1.InteractionManager(renderer);
        this.prepare = new Prepare_1.Prepare(renderer);
        this.batch = new BatchRenderer_1.BatchRenderer(renderer);
        // Loader$2.registerPlugin(BitmapFontLoader);
        // Loader$2.registerPlugin(SpritesheetLoader);	
    }
}


/***/ }),

/***/ "./js-compile/raw-pixi-ts/Resource.js":
/*!********************************************!*\
  !*** ./js-compile/raw-pixi-ts/Resource.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Event_1 = __webpack_require__(/*! ./Event */ "./js-compile/raw-pixi-ts/Event.js");
const EventDispatcher_1 = __webpack_require__(/*! ./EventDispatcher */ "./js-compile/raw-pixi-ts/EventDispatcher.js");
const Runner_1 = __webpack_require__(/*! ./Runner */ "./js-compile/raw-pixi-ts/Runner.js");
class Resource extends EventDispatcher_1.EventDispatcher {
    constructor(width = 0, height = 0) {
        super();
        /**
         * Internal width of the resource
         * @member {number}
         * @protected
         */
        this._width = width;
        /**
         * Internal height of the resource
         * @member {number}
         * @protected
         */
        this._height = height;
        /**
         * If resource has been destroyed
         * @member {boolean}
         * @readonly
         * @default false
         */
        this.destroyed = false;
        /**
         * `true` if resource is created by BaseTexture
         * useful for doing cleanup with BaseTexture destroy
         * and not cleaning up resources that were created
         * externally.
         * @member {boolean}
         * @protected
         */
        this.internal = false;
        /**
         * Mini-runner for handling resize events
         *
         * @member {Runner}
         * @private
         */
        // this.onResize = Event.getEvent("setRealSize")
        // Runner('setRealSize', 2);
        /**
         * Mini-runner for handling update events
         *
         * @member {Runner}
         * @private
         */
        // this.onUpdate = Event.getEvent("update")
        // new Runner('update');
        this.onResize = new Runner_1.Runner('setRealSize', 2);
        /**
         * Mini-runner for handling update events
         *
         * @member {Runner}
         * @private
         */
        this.onUpdate = new Runner_1.Runner('update');
    }
    /**
     * Bind to a parent BaseTexture
     *
     * @param {PIXI.BaseTexture} baseTexture - Parent texture
     */
    bind(baseTexture) {
        this.onResize.add(baseTexture);
        this.onUpdate.add(baseTexture);
        // Call a resize immediate if we already
        // have the width and height of the resource
        if (this._width || this._height) {
            this.onResize.run(this._width, this._height);
        }
        // this.onResize.add(baseTexture);
        // this.onUpdate.add(baseTexture);
        // Call a resize immediate if we already
        // have the width and height of the resource
        // if (this._width || this._height)
        // {
        // 	this.dispatchEvent(Event.getEvent("setRealSize"))
        //     // this.onResize.run(this._width, this._height);
        // }
    }
    ;
    /**
     * Unbind to a parent BaseTexture
     *
     * @param {PIXI.BaseTexture} baseTexture - Parent texture
     */
    unbind(baseTexture) {
        this.onResize.remove(baseTexture);
        this.onUpdate.remove(baseTexture);
        // this.onResize.remove(baseTexture);
        // this.onUpdate.remove(baseTexture);
    }
    ;
    /**
     * Trigger a resize event
     */
    resize(width, height) {
        if (width !== this._width || height !== this._height) {
            this._width = width;
            this._height = height;
            this.onResize.run(width, height);
            this.dispatchEvent(Event_1.Event.getEvent("setRealSize"));
            // Event.getEvent("setRealSize")
            // this.onResize.run(width, height);
        }
    }
    ;
    /**
     * Has been validated
     * @readonly
     * @member {boolean}
     */
    get valid() {
        return !!this._width && !!this._height;
    }
    ;
    /**
     * Has been updated trigger event
     */
    update(deltaTime) {
        if (!this.destroyed) {
            this.dispatchEvent(Event_1.Event.getEvent("update"));
        }
    }
    ;
    /**
     * This can be overridden to start preloading a resource
     * or do any other prepare step.
     * @protected
     * @return {Promise<void>} Handle the validate event
     */
    load() {
        return Promise.resolve();
    }
    ;
    /**
     * The width of the resource.
     *
     * @member {number}
     * @readonly
     */
    get width() {
        return this._width;
    }
    ;
    /**
     * The height of the resource.
     *
     * @member {number}
     * @readonly
     */
    get height() {
        return this._height;
    }
    ;
    /**
     * Uploads the texture or returns false if it cant for some reason. Override this.
     *
     * @param {PIXI.Renderer} renderer - yeah, renderer!
     * @param {PIXI.BaseTexture} baseTexture - the texture
     * @param {PIXI.GLTexture} glTexture - texture instance for this webgl context
     * @returns {boolean} true is success
     */
    upload(renderer, baseTexture, glTexture, source) {
        return false;
    }
    ;
    /**
     * Set the style, optional to override
     *
     * @param {PIXI.Renderer} renderer - yeah, renderer!
     * @param {PIXI.BaseTexture} baseTexture - the texture
     * @param {PIXI.GLTexture} glTexture - texture instance for this webgl context
     * @returns {boolean} `true` is success
     */
    style(renderer, baseTexture, glTexture) {
        return false;
    }
    ;
    /**
     * Clean up anything, this happens when destroying is ready.
     *
     * @protected
     */
    dispose() {
        // override
    }
    ;
    /**
     * Call when destroying resource, unbind any BaseTexture object
     * before calling this method, as reference counts are maintained
     * internally.
     */
    destroy() {
        if (!this.destroyed) {
            this.onResize.removeAll();
            this.onResize = null;
            this.onUpdate.removeAll();
            this.onUpdate = null;
            this.destroyed = true;
            this.dispose();
        }
    }
    ;
}
exports.Resource = Resource;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/ResourceLoader.js":
/*!**************************************************!*\
  !*** ./js-compile/raw-pixi-ts/ResourceLoader.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const EventDispatcher_1 = __webpack_require__(/*! ./EventDispatcher */ "./js-compile/raw-pixi-ts/EventDispatcher.js");
const Event_1 = __webpack_require__(/*! ./Event */ "./js-compile/raw-pixi-ts/Event.js");
const ProgressEvent_1 = __webpack_require__(/*! ./ProgressEvent */ "./js-compile/raw-pixi-ts/ProgressEvent.js");
const Logger_1 = __webpack_require__(/*! ./Logger */ "./js-compile/raw-pixi-ts/Logger.js");
class ResourceLoader extends EventDispatcher_1.EventDispatcher {
    constructor(request) {
        super();
        this.complete = (event) => {
            Logger_1.trace("complete");
            let promise = window.createImageBitmap(this._imageElement, 0, 0, this._imageElement.width, this._imageElement.height);
            promise.then(this.onImageBitmapCreated).catch();
        };
        this.onImageBitmapCreated = (image) => {
            Logger_1.trace("onImageBitmapCreated");
            this._imageData = image;
            this._clearEvents();
            this._finish();
        };
        this._onTimeout = () => {
            this.abort('Load timed out.');
        };
        this._onProgress = (event) => {
            if (event && event.lengthComputable) {
                let pe = ProgressEvent_1.ProgressEvent.getProgressEvent(ProgressEvent_1.ProgressEvent.PROGRESS);
                pe.bytesLoaded = event.loaded;
                pe.bytesTotal = event.total;
                pe.percent = event.loaded / event.total;
                this.dispatchEvent(pe);
            }
        };
        this._onError = (event) => {
            this.abort('Failed to load element using: ' + event.target.nodeName);
        };
        this._request = request;
        this._flags = 0;
        this._setFlag(ResourceLoader.STATUS_FLAGS.DATA_URL, this._request.url.indexOf('data:') === 0);
        this.extension = this._getExtension();
        this.data = null;
        this.crossOrigin = request.crossOrigin === true ? 'anonymous' : "";
        this.timeout = request.timeout || 0;
        this.loadType = this._determineLoadType();
        this.error = null;
        this.xhr = null;
        this.type = ResourceLoader.TYPE.UNKNOWN;
        this.progressChunk = 0;
        this._elementTimer = 0;
        this.metadata = request.requestMetaData;
        this.xhrType = null;
        // this.children = [];
        // this._dequeue = ResourceLoader._noop;
        // this._onLoadBinding = null;
    }
    load() {
        if (this.isLoading) {
            return;
        }
        if (this.isComplete) {
            this.dispatchEvent(Event_1.Event.getEvent(Event_1.Event.COMPLETE));
            return;
        }
        this._setFlag(ResourceLoader.STATUS_FLAGS.LOADING, true);
        if (!this.crossOrigin) {
            this.crossOrigin = this._determineCrossOrigin(this._request.url);
        }
        switch (this.loadType) {
            case ResourceLoader.LOAD_TYPE.IMAGE:
                this.type = ResourceLoader.TYPE.IMAGE;
                this._loadElement('image');
                break;
            case ResourceLoader.LOAD_TYPE.AUDIO:
                this.type = ResourceLoader.TYPE.AUDIO;
                // this._loadSourceElement('audio');
                break;
            case ResourceLoader.LOAD_TYPE.VIDEO:
                this.type = ResourceLoader.TYPE.VIDEO;
                // this._loadSourceElement('video');
                break;
            case ResourceLoader.LOAD_TYPE.XHR:
            default:
                if (ResourceLoader.useXdr && this.crossOrigin) {
                    this._loadXdr();
                }
                else {
                    this._loadXhr();
                }
                break;
        }
        // _loadSourceElement
        // _loadXdr
        // _loadXhr
    }
    ;
    /**
     * Loads this resources using an element that has multiple sources,
     * like an HTMLAudioElement or HTMLVideoElement.
     *
     * @private
     * @param {string} type - The type of element to use.
     */
    // protected _loadSourceElement(type):void
    // {
    //     if (this.metadata.loadElement) 
    //     {
    //         this.data = this.metadata.loadElement;
    //     } else if (type === 'audio' && typeof window['Audio'] !== 'undefined') {
    //         this.data = new Audio();
    //     } else {
    //         this.data = document.createElement(type);
    //     }
    //     if (this.data === null) {
    //         this.abort('Unsupported element: ' + type);
    //         return;
    //     }
    //     if (this.crossOrigin) {
    //         this.data.crossOrigin = this.crossOrigin;
    //     }
    //     if (!this.metadata.skipSource) {
    //         // support for CocoonJS Canvas+ runtime, lacks document.createElement('source')
    //         if (navigator['isCocoonJS']) {
    //             this.data.src = Array.isArray(this._request.url) ? this._request.url[0] : this._request.url;
    //         } else if (Array.isArray(this._request.url)) {
    //             var mimeTypes = this.metadata.mimeType;
    //             for (var i = 0; i < this._request.url.length; ++i) {
    //                 this.data.appendChild(this._createSource(type, this._request.url[i], Array.isArray(mimeTypes) ? mimeTypes[i] : mimeTypes));
    //             }
    //         } else {
    //             var _mimeTypes = this.metadata.mimeType;
    //             this.data.appendChild(this._createSource(type, this._request.url, Array.isArray(_mimeTypes) ? _mimeTypes[0] : _mimeTypes));
    //         }
    //     }
    //     this.data.addEventListener('error', this._boundOnError, false);
    //     this.data.addEventListener('load', this._boundComplete, false);
    //     this.data.addEventListener('progress', this._boundOnProgress, false);
    //     this.data.addEventListener('canplaythrough', this._boundComplete, false);
    //     this.data.load();
    //     if (this.timeout) {
    //         this._elementTimer = setTimeout(this._boundOnTimeout, this.timeout);
    //     }
    // };
    _clearEvents() {
        clearTimeout(this._elementTimer);
        if (this._imageElement && this._imageElement.removeEventListener) {
            this._imageElement.removeEventListener('error', this._onError);
            this._imageElement.removeEventListener('load', this.complete);
            this._imageElement.removeEventListener('progress', this._onProgress);
            this._imageElement.removeEventListener('canplaythrough', this.complete);
        }
        if (this.xhr) {
            // if (this.xhr.removeEventListener) {
            //     this.xhr.removeEventListener('error', this._boundXhrOnError, false);
            //     this.xhr.removeEventListener('timeout', this._boundXhrOnTimeout, false);
            //     this.xhr.removeEventListener('abort', this._boundXhrOnAbort, false);
            //     this.xhr.removeEventListener('progress', this._boundOnProgress, false);
            //     this.xhr.removeEventListener('load', this._boundXhrOnLoad, false);
            // } else {
            //     this.xhr.onerror = null;
            //     this.xhr.ontimeout = null;
            //     this.xhr.onprogress = null;
            //     this.xhr.onload = null;
            // }
        }
    }
    ;
    _loadElement(type) {
        Logger_1.trace("_loadElement " + type);
        this._imageElement = document.createElement("img");
        if (this.crossOrigin) {
            this._imageElement.crossOrigin = this.crossOrigin;
        }
        this._imageElement.src = this._request.url;
        this._imageElement.addEventListener('error', this._onError);
        this._imageElement.addEventListener('load', this.complete);
        this._imageElement.addEventListener('progress', this._onProgress);
        // if (this.timeout > 0) 
        // {
        //     this._elementTimer = setTimeout(this._onTimeout, this.timeout);
        // }
    }
    ;
    get imageData() {
        return this._imageData;
    }
    abort(message) {
        if (this.error) {
            return;
        }
        this.error = new Error(message);
        this._clearEvents();
        if (this.xhr) {
            this.xhr.abort();
        }
        else if (this.xdr) {
            this.xdr.abort();
        }
        else if (this.data) {
            if (this.data.src) {
                this.data.src = ResourceLoader.EMPTY_GIF;
            }
            else {
                while (this.data.firstChild) {
                    this.data.removeChild(this.data.firstChild);
                }
            }
        }
        this._finish();
    }
    ;
    _finish() {
        if (this.isComplete) {
            return;
        }
        this._setFlag(ResourceLoader.STATUS_FLAGS.COMPLETE, true);
        this._setFlag(ResourceLoader.STATUS_FLAGS.LOADING, false);
        this.dispatchEvent(Event_1.Event.getEvent(Event_1.Event.COMPLETE));
    }
    ;
    _determineCrossOrigin(url, loc = null) {
        if (url.indexOf('data:') === 0) {
            return '';
        }
        if (window['origin'] !== window.location.origin) {
            return 'anonymous';
        }
        loc = loc || window.location;
        if (!ResourceLoader.tempAnchor) {
            ResourceLoader.tempAnchor = document.createElement('a');
        }
        ResourceLoader.tempAnchor.href = url;
        let uri = ResourceLoader.parseUri(ResourceLoader.tempAnchor.href, true);
        let samePort = !uri.port && loc.port === '' || uri.port === loc.port;
        let protocol = uri.protocol ? uri.protocol + ':' : '';
        if (uri.host !== loc.hostname || !samePort || protocol !== loc.protocol) {
            return 'anonymous';
        }
        return '';
    }
    ;
    static parseUri(str, strict = true) {
        let o = {
            key: ['source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'],
            q: {
                name: 'queryKey',
                parser: /(?:^|&)([^&=]*)=?([^&]*)/g
            },
            parser: {
                strict: /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/,
                loose: /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/
            }
        };
        let m = o.parser[strict ? 'strict' : 'loose'].exec(str);
        let uri = new URIData();
        uri.source = m["source"] || '';
        uri.protocol = m["protocol"] || '';
        uri.authority = m["authority"] || '';
        uri.userInfo = m["userInfo"] || '';
        uri.user = m["user"] || '';
        uri.password = m["password"] || '';
        uri.host = m["host"] || '';
        uri.port = m["port"] || '';
        uri.relative = m["relative"] || '';
        uri.path = m["path"] || '';
        uri.directory = m["directory"] || '';
        uri.file = m["file"] || '';
        uri.query = m["query"] || '';
        uri.anchor = m["anchor"] || '';
        uri[o.q.name] = {};
        uri[o.key[12]].replace(o.q.parser, function ($0, $1, $2) {
            if ($1) {
                uri[o.q.name][$1] = $2;
            }
        });
        return uri;
    }
    ;
    _determineLoadType() {
        return ResourceLoader._loadTypeMap[this.extension] || ResourceLoader.LOAD_TYPE.XHR;
    }
    ;
    _getExtension() {
        let url = this._request.url;
        let ext = '';
        if (this.isDataUrl) {
            let slashIndex = url.indexOf('/');
            ext = url.substring(slashIndex + 1, url.indexOf(';', slashIndex));
        }
        else {
            let queryStart = url.indexOf('?');
            let hashStart = url.indexOf('#');
            let index = Math.min(queryStart > -1 ? queryStart : url.length, hashStart > -1 ? hashStart : url.length);
            url = url.substring(0, index);
            ext = url.substring(url.lastIndexOf('.') + 1);
        }
        return ext.toLowerCase();
    }
    ;
    _hasFlag(flag) {
        return (this._flags & flag) !== 0;
    }
    ;
    _setFlag(flag, value) {
        this._flags = value ? this._flags | flag : this._flags & ~flag;
    }
    ;
    static setExtMap(map, extname, val) {
        if (extname && extname.indexOf('.') === 0) {
            extname = extname.substring(1);
        }
        if (!extname) {
            return;
        }
        map[extname] = val;
    }
    static setExtensionLoadType(extname, loadType) {
        ResourceLoader.setExtMap(ResourceLoader._loadTypeMap, extname, loadType);
    }
    ;
    static setExtensionXhrType(extname, xhrType) {
        ResourceLoader.setExtMap(ResourceLoader._xhrTypeMap, extname, xhrType);
    }
    ;
    /**
     * Quick helper to get string xhr type.
     *
     * @ignore
     * @param {XMLHttpRequest|XDomainRequest} xhr - The request to check.
     * @return {string} The type.
     */
    static reqType(xhr) {
        return xhr.toString().replace('object ', '');
    }
    /**
     * Loads this resources using an XMLHttpRequest.
     *
     * @private
     */
    _loadXhr() {
        // // if unset, determine the value
        // if (typeof this.xhrType !== 'string') {
        //     this.xhrType = this._determineXhrType();
        // }
        // var xhr = this.xhr = new XMLHttpRequest();
        // // set the request type and url
        // xhr.open('GET', this._request.url, true);
        // xhr.timeout = this.timeout;
        // // load json as text and parse it ourselves. We do this because some browsers
        // // *cough* safari *cough* can't deal with it.
        // if (this.xhrType === ResourceLoader.XHR_RESPONSE_TYPE.JSON || this.xhrType === ResourceLoader.XHR_RESPONSE_TYPE.DOCUMENT) {
        //     xhr.responseType = <any>ResourceLoader.XHR_RESPONSE_TYPE.TEXT;
        // } else {
        //     xhr.responseType = this.xhrType;
        // }
        // xhr.addEventListener('error', this._boundXhrOnError, false);
        // xhr.addEventListener('timeout', this._boundXhrOnTimeout, false);
        // xhr.addEventListener('abort', this._boundXhrOnAbort, false);
        // xhr.addEventListener('progress', this._boundOnProgress, false);
        // xhr.addEventListener('load', this._boundXhrOnLoad, false);
        // xhr.send();
    }
    ;
    /**
     * Loads this resources using an XDomainRequest. This is here because we need to support IE9 (gross).
     *
     * @private
     */
    _loadXdr() {
        // // if unset, determine the value
        // if (typeof this.xhrType !== 'string') {
        //     this.xhrType = this._determineXhrType();
        // }
        // var xdr = this.xhr = new window['XDomainRequest'](); // eslint-disable-line no-undef
        // // XDomainRequest has a few quirks. Occasionally it will abort requests
        // // A way to avoid this is to make sure ALL callbacks are set even if not used
        // // More info here: http://stackoverflow.com/questions/15786966/xdomainrequest-aborts-post-on-ie-9
        // xdr.timeout = this.timeout || 5000; // XDR needs a timeout value or it breaks in IE9
        // xdr.onerror = this._boundXhrOnError;
        // xdr.ontimeout = this._boundXhrOnTimeout;
        // xdr.onprogress = this._boundOnProgress;
        // xdr.onload = this._boundXhrOnLoad;
        // xdr.open('GET', this._request.url, true);
        // // Note: The xdr.send() call is wrapped in a timeout to prevent an
        // // issue with the interface where some requests are lost if multiple
        // // XDomainRequests are being sent at the same time.
        // // Some info here: https://github.com/photonstorm/phaser/issues/1248
        // setTimeout(function () {
        //     return xdr.send();
        // }, 1);
    }
    ;
    /**
     * Creates a source used in loading via an element.
     *
     * @private
     * @param {string} type - The element type (video or audio).
     * @param {string} url - The source URL to load from.
     * @param {string} [mime] - The mime type of the video
     * @return {HTMLSourceElement} The source element.
     */
    _createSource(type, url, mime) {
        // if (!mime) {
        //     mime = type + '/' + this._getExtension(url);
        // }
        // var source = document.createElement('source');
        // source.src = url;
        // source.type = mime;
        // return source;
    }
    ;
    /**
     * Called if an error event fires for xhr/xdr.
     *
     * @private
     */
    _xhrOnError() {
        var xhr = this.xhr;
        this.abort(ResourceLoader.reqType(xhr) + ' Request failed. Status: ' + xhr.status + ', text: "' + xhr.statusText + '"');
    }
    ;
    /**
     * Called if an error event fires for xhr/xdr.
     *
     * @private
     */
    _xhrOnTimeout() {
        var xhr = this.xhr;
        this.abort(ResourceLoader.reqType(xhr) + ' Request timed out.');
    }
    ;
    /**
     * Called if an abort event fires for xhr/xdr.
     *
     * @private
     */
    _xhrOnAbort() {
        var xhr = this.xhr;
        this.abort(ResourceLoader.reqType(xhr) + ' Request was aborted by the user.');
    }
    ;
    /**
     * Called when data successfully loads from an xhr/xdr request.
     *
     * @private
     * @param {XMLHttpRequestLoadEvent|Event} event - Load event
     */
    _xhrOnLoad() {
        // var xhr = this.xhr;
        // var text = '';
        // var status = typeof xhr.status === 'undefined' ? ResourceLoader.STATUS_OK : xhr.status; // XDR has no `.status`, assume 200.
        // // responseText is accessible only if responseType is '' or 'text' and on older browsers
        // if (xhr.responseType === '' || xhr.responseType === 'text' || typeof xhr.responseType === 'undefined') {
        //     text = xhr.responseText;
        // }
        // // status can be 0 when using the `file://` protocol so we also check if a response is set.
        // // If it has a response, we assume 200; otherwise a 0 status code with no contents is an aborted request.
        // if (status === ResourceLoader.STATUS_NONE && (text.length > 0 || xhr.responseType === ResourceLoader.XHR_RESPONSE_TYPE.BUFFER)) {
        //     status = ResourceLoader.STATUS_OK;
        // }
        // // handle IE9 bug: http://stackoverflow.com/questions/10046972/msie-returns-status-code-of-1223-for-ajax-request
        // else if (status === ResourceLoader.STATUS_IE_BUG_EMPTY) {
        //         status = ResourceLoader.STATUS_EMPTY;
        //     }
        // var statusType = status / 100 | 0;
        // if (statusType === ResourceLoader.STATUS_TYPE_OK) {
        //     // if text, just return it
        //     if (this.xhrType === ResourceLoader.XHR_RESPONSE_TYPE.TEXT) {
        //         this.data = text;
        //         this.type = ResourceLoader.TYPE.TEXT;
        //     }
        //     // if json, parse into json object
        //     else if (this.xhrType === ResourceLoader.XHR_RESPONSE_TYPE.JSON) {
        //             try {
        //                 this.data = JSON.parse(text);
        //                 this.type = ResourceLoader.TYPE.JSON;
        //             } catch (e) {
        //                 this.abort('Error trying to parse loaded json: ' + e);
        //                 return;
        //             }
        //         }
        //         // if xml, parse into an xml document or div element
        //         else if (this.xhrType === ResourceLoader.XHR_RESPONSE_TYPE.DOCUMENT) {
        //                 try {
        //                     if (window['DOMParser']) {
        //                         var domparser = new DOMParser();
        //                         this.data = domparser.parseFromString(text, 'text/xml');
        //                     } else {
        //                         var div = document.createElement('div');
        //                         div.innerHTML = text;
        //                         this.data = div;
        //                     }
        //                     this.type = ResourceLoader.TYPE.XML;
        //                 } catch (e) {
        //                     this.abort('Error trying to parse loaded xml: ' + e);
        //                     return;
        //                 }
        //             }
        //             // other types just return the response
        //             else {
        //                     this.data = xhr.response || text;
        //                 }
        // } else {
        //     this.abort('[' + xhr.status + '] ' + xhr.statusText + ': ' + xhr.responseURL);
        //     return;
        // }
        // this.complete();
    }
    ;
    /**
     * Determines the responseType of an XHR request based on the extension of the
     * resource being loaded.
     *
     * @private
     * @return {Resource.XHR_RESPONSE_TYPE} The responseType to use.
     */
    _determineXhrType() {
        return ResourceLoader._xhrTypeMap[this.extension] || ResourceLoader.XHR_RESPONSE_TYPE.TEXT;
    }
    ;
    /**
     * Determines the loadType of a resource based on the extension of the
     * resource being loaded.
     *
     * @private
     * @return {Resource.LOAD_TYPE} The loadType to use.
     */
    /**
     * Determines the mime type of an XHR request based on the responseType of
     * resource being loaded.
     *
     * @private
     * @param {Resource.XHR_RESPONSE_TYPE} type - The type to get a mime type for.
     * @return {string} The mime type to use.
     */
    _getMimeFromXhrType(type) {
        switch (type) {
            case ResourceLoader.XHR_RESPONSE_TYPE.BUFFER:
                return 'application/octet-binary';
            case ResourceLoader.XHR_RESPONSE_TYPE.BLOB:
                return 'application/blob';
            case ResourceLoader.XHR_RESPONSE_TYPE.DOCUMENT:
                return 'application/xml';
            case ResourceLoader.XHR_RESPONSE_TYPE.JSON:
                return 'application/json';
            case ResourceLoader.XHR_RESPONSE_TYPE.DEFAULT:
            case ResourceLoader.XHR_RESPONSE_TYPE.TEXT:
            /* falls through */
            default:
                return 'text/plain';
        }
    }
    ;
    get isDataUrl() {
        return this._hasFlag(ResourceLoader.STATUS_FLAGS.DATA_URL);
    }
    get isComplete() {
        return this._hasFlag(ResourceLoader.STATUS_FLAGS.COMPLETE);
    }
    get isLoading() {
        return this._hasFlag(ResourceLoader.STATUS_FLAGS.LOADING);
    }
}
ResourceLoader.STATUS_NONE = 0;
ResourceLoader.STATUS_OK = 200;
ResourceLoader.STATUS_EMPTY = 204;
ResourceLoader.STATUS_IE_BUG_EMPTY = 1223;
ResourceLoader.STATUS_TYPE_OK = 2;
ResourceLoader.useXdr = !!(window['XDomainRequest'] && !('withCredentials' in new XMLHttpRequest()));
ResourceLoader.EMPTY_GIF = 'data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==';
ResourceLoader.LOAD_TYPE = {
    XHR: 1,
    IMAGE: 2,
    AUDIO: 3,
    VIDEO: 4
};
ResourceLoader.XHR_RESPONSE_TYPE = {
    DEFAULT: 'text',
    BUFFER: 'arraybuffer',
    BLOB: 'blob',
    DOCUMENT: 'document',
    JSON: 'json',
    TEXT: 'text'
};
ResourceLoader._xhrTypeMap = {
    xhtml: ResourceLoader.XHR_RESPONSE_TYPE.DOCUMENT,
    html: ResourceLoader.XHR_RESPONSE_TYPE.DOCUMENT,
    htm: ResourceLoader.XHR_RESPONSE_TYPE.DOCUMENT,
    xml: ResourceLoader.XHR_RESPONSE_TYPE.DOCUMENT,
    tmx: ResourceLoader.XHR_RESPONSE_TYPE.DOCUMENT,
    svg: ResourceLoader.XHR_RESPONSE_TYPE.DOCUMENT,
    tsx: ResourceLoader.XHR_RESPONSE_TYPE.DOCUMENT,
    gif: ResourceLoader.XHR_RESPONSE_TYPE.BLOB,
    png: ResourceLoader.XHR_RESPONSE_TYPE.BLOB,
    bmp: ResourceLoader.XHR_RESPONSE_TYPE.BLOB,
    jpg: ResourceLoader.XHR_RESPONSE_TYPE.BLOB,
    jpeg: ResourceLoader.XHR_RESPONSE_TYPE.BLOB,
    tif: ResourceLoader.XHR_RESPONSE_TYPE.BLOB,
    tiff: ResourceLoader.XHR_RESPONSE_TYPE.BLOB,
    webp: ResourceLoader.XHR_RESPONSE_TYPE.BLOB,
    tga: ResourceLoader.XHR_RESPONSE_TYPE.BLOB,
    json: ResourceLoader.XHR_RESPONSE_TYPE.JSON,
    text: ResourceLoader.XHR_RESPONSE_TYPE.TEXT,
    txt: ResourceLoader.XHR_RESPONSE_TYPE.TEXT,
    ttf: ResourceLoader.XHR_RESPONSE_TYPE.BUFFER,
    otf: ResourceLoader.XHR_RESPONSE_TYPE.BUFFER
};
ResourceLoader._loadTypeMap = {
    gif: ResourceLoader.LOAD_TYPE.IMAGE,
    png: ResourceLoader.LOAD_TYPE.IMAGE,
    bmp: ResourceLoader.LOAD_TYPE.IMAGE,
    jpg: ResourceLoader.LOAD_TYPE.IMAGE,
    jpeg: ResourceLoader.LOAD_TYPE.IMAGE,
    tif: ResourceLoader.LOAD_TYPE.IMAGE,
    tiff: ResourceLoader.LOAD_TYPE.IMAGE,
    webp: ResourceLoader.LOAD_TYPE.IMAGE,
    tga: ResourceLoader.LOAD_TYPE.IMAGE,
    svg: ResourceLoader.LOAD_TYPE.IMAGE,
    'svg+xml': ResourceLoader.LOAD_TYPE.IMAGE,
    mp3: ResourceLoader.LOAD_TYPE.AUDIO,
    ogg: ResourceLoader.LOAD_TYPE.AUDIO,
    wav: ResourceLoader.LOAD_TYPE.AUDIO,
    mp4: ResourceLoader.LOAD_TYPE.VIDEO,
    webm: ResourceLoader.LOAD_TYPE.VIDEO
};
ResourceLoader.TYPE = {
    UNKNOWN: 0,
    JSON: 1,
    XML: 2,
    IMAGE: 3,
    AUDIO: 4,
    VIDEO: 5,
    TEXT: 6
};
ResourceLoader.STATUS_FLAGS = {
    NONE: 0,
    DATA_URL: 1 << 0,
    COMPLETE: 1 << 1,
    LOADING: 1 << 2
};
exports.ResourceLoader = ResourceLoader;
class URIData {
}


/***/ }),

/***/ "./js-compile/raw-pixi-ts/ResourceSettings.js":
/*!****************************************************!*\
  !*** ./js-compile/raw-pixi-ts/ResourceSettings.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const ImageResource_1 = __webpack_require__(/*! ./ImageResource */ "./js-compile/raw-pixi-ts/ImageResource.js");
const CanvasResource_1 = __webpack_require__(/*! ./CanvasResource */ "./js-compile/raw-pixi-ts/CanvasResource.js");
const VideoResource_1 = __webpack_require__(/*! ./VideoResource */ "./js-compile/raw-pixi-ts/VideoResource.js");
const SVGResource_1 = __webpack_require__(/*! ./SVGResource */ "./js-compile/raw-pixi-ts/SVGResource.js");
const BufferResource_1 = __webpack_require__(/*! ./BufferResource */ "./js-compile/raw-pixi-ts/BufferResource.js");
const CubeResource_1 = __webpack_require__(/*! ./CubeResource */ "./js-compile/raw-pixi-ts/CubeResource.js");
const ArrayResource_1 = __webpack_require__(/*! ./ArrayResource */ "./js-compile/raw-pixi-ts/ArrayResource.js");
class ResourceSettings {
    static autoDetectResource(source, options) {
        if (!source) {
            return null;
        }
        var extension = '';
        if (typeof source === 'string') {
            var result = (/\.(\w{3,4})(?:$|\?|#)/i).exec(source);
            if (result) {
                extension = result[1].toLowerCase();
            }
        }
        for (var i = ResourceSettings.INSTALLED.length - 1; i >= 0; --i) {
            var ResourcePlugin = ResourceSettings.INSTALLED[i];
            if (ResourcePlugin.test && ResourcePlugin.test(source, extension)) {
                return new ResourcePlugin(source, options);
            }
        }
        return new ImageResource_1.ImageResource(source, options);
    }
}
ResourceSettings.INSTALLED = [
    ImageResource_1.ImageResource,
    CanvasResource_1.CanvasResource,
    VideoResource_1.VideoResource,
    SVGResource_1.SVGResource,
    BufferResource_1.BufferResource,
    CubeResource_1.CubeResource,
    ArrayResource_1.ArrayResource
];
exports.ResourceSettings = ResourceSettings;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/RopeGeometry.js":
/*!************************************************!*\
  !*** ./js-compile/raw-pixi-ts/RopeGeometry.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const MeshGeometry_1 = __webpack_require__(/*! ./MeshGeometry */ "./js-compile/raw-pixi-ts/MeshGeometry.js");
class RopeGeometry extends MeshGeometry_1.MeshGeometry {
    constructor(width = 200, points = null) {
        if (width === void 0) {
            width = 200;
        }
        super(new Float32Array(points.length * 4), new Float32Array(points.length * 4), new Uint16Array((points.length - 1) * 6));
        /**
        * An array of points that determine the rope
        * @member {PIXI.Point[]}
        */
        this.points = points;
        /**
        * The width (i.e., thickness) of the rope.
        * @member {number}
        * @readOnly
        */
        this.width = width;
        this.build();
    }
    /**
    * Refreshes Rope indices and uvs
    * @private
    */
    build() {
        var points = this.points;
        if (!points) {
            return;
        }
        var vertexBuffer = this.getAttribute('aVertexPosition');
        var uvBuffer = this.getAttribute('aTextureCoord');
        var indexBuffer = this.getIndex();
        // if too little points, or texture hasn't got UVs set yet just move on.
        if (points.length < 1) {
            return;
        }
        // if the number of points has changed we will need to recreate the arraybuffers
        if (vertexBuffer.data.length / 4 !== points.length) {
            vertexBuffer.data = new Float32Array(points.length * 4);
            uvBuffer.data = new Float32Array(points.length * 4);
            indexBuffer.data = new Uint16Array((points.length - 1) * 6);
        }
        var uvs = uvBuffer.data;
        var indices = indexBuffer.data;
        uvs[0] = 0;
        uvs[1] = 0;
        uvs[2] = 0;
        uvs[3] = 1;
        // indices[0] = 0;
        // indices[1] = 1;
        var total = points.length; // - 1;
        for (var i = 0; i < total; i++) {
            // time to do some smart drawing!
            var index = i * 4;
            var amount = i / (total - 1);
            uvs[index] = amount;
            uvs[index + 1] = 0;
            uvs[index + 2] = amount;
            uvs[index + 3] = 1;
        }
        var indexCount = 0;
        for (var i$1 = 0; i$1 < total - 1; i$1++) {
            var index$1 = i$1 * 2;
            indices[indexCount++] = index$1;
            indices[indexCount++] = index$1 + 1;
            indices[indexCount++] = index$1 + 2;
            indices[indexCount++] = index$1 + 2;
            indices[indexCount++] = index$1 + 1;
            indices[indexCount++] = index$1 + 3;
        }
        // ensure that the changes are uploaded
        uvBuffer.update();
        indexBuffer.update();
        this.updateVertices();
    }
    ;
    /**
    * refreshes vertices of Rope mesh
    */
    updateVertices() {
        var points = this.points;
        if (points.length < 1) {
            return;
        }
        var lastPoint = points[0];
        var nextPoint;
        var perpX = 0;
        var perpY = 0;
        // this.count -= 0.2;
        var vertices = this.buffers[0].data;
        var total = points.length;
        for (var i = 0; i < total; i++) {
            var point = points[i];
            var index = i * 4;
            if (i < points.length - 1) {
                nextPoint = points[i + 1];
            }
            else {
                nextPoint = point;
            }
            perpY = -(nextPoint.x - lastPoint.x);
            perpX = nextPoint.y - lastPoint.y;
            var perpLength = Math.sqrt((perpX * perpX) + (perpY * perpY));
            var num = this.width / 2; // (20 + Math.abs(Math.sin((i + this.count) * 0.3) * 50) )* ratio;
            perpX /= perpLength;
            perpY /= perpLength;
            perpX *= num;
            perpY *= num;
            vertices[index] = point.x + perpX;
            vertices[index + 1] = point.y + perpY;
            vertices[index + 2] = point.x - perpX;
            vertices[index + 3] = point.y - perpY;
            lastPoint = point;
        }
        this.buffers[0].update();
    }
    ;
    update() {
        this.updateVertices();
    }
    ;
}
exports.RopeGeometry = RopeGeometry;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/RoundedRectangle.js":
/*!****************************************************!*\
  !*** ./js-compile/raw-pixi-ts/RoundedRectangle.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const ShapeSettings_1 = __webpack_require__(/*! ./ShapeSettings */ "./js-compile/raw-pixi-ts/ShapeSettings.js");
class RoundedRectangle {
    constructor(x = 0, y = 0, width = 0, height = 0, radius = 20) {
        if (x === void 0) {
            x = 0;
        }
        if (y === void 0) {
            y = 0;
        }
        if (width === void 0) {
            width = 0;
        }
        if (height === void 0) {
            height = 0;
        }
        if (radius === void 0) {
            radius = 20;
        }
        /**
         * @member {number}
         * @default 0
         */
        this.x = x;
        /**
         * @member {number}
         * @default 0
         */
        this.y = y;
        /**
         * @member {number}
         * @default 0
         */
        this.width = width;
        /**
         * @member {number}
         * @default 0
         */
        this.height = height;
        /**
         * @member {number}
         * @default 20
         */
        this.radius = radius;
        /**
         * The type of the object, mainly used to avoid `instanceof` checks
         *
         * @member {number}
         * @readonly
         * @default PIXI.SHAPES.RREC
         * @see PIXI.SHAPES
         */
        this.type = ShapeSettings_1.ShapeSettings.SHAPES.RREC;
    }
    /**
     * Creates a clone of this Rounded Rectangle
     *
     * @return {PIXI.RoundedRectangle} a copy of the rounded rectangle
     */
    clone() {
        return new RoundedRectangle(this.x, this.y, this.width, this.height, this.radius);
    }
    ;
    /**
     * Checks whether the x and y coordinates given are contained within this Rounded Rectangle
     *
     * @param {number} x - The X coordinate of the point to test
     * @param {number} y - The Y coordinate of the point to test
     * @return {boolean} Whether the x/y coordinates are within this Rounded Rectangle
     */
    contains(x, y) {
        if (this.width <= 0 || this.height <= 0) {
            return false;
        }
        if (x >= this.x && x <= this.x + this.width) {
            if (y >= this.y && y <= this.y + this.height) {
                if ((y >= this.y + this.radius && y <= this.y + this.height - this.radius)
                    || (x >= this.x + this.radius && x <= this.x + this.width - this.radius)) {
                    return true;
                }
                var dx = x - (this.x + this.radius);
                var dy = y - (this.y + this.radius);
                var radius2 = this.radius * this.radius;
                if ((dx * dx) + (dy * dy) <= radius2) {
                    return true;
                }
                dx = x - (this.x + this.width - this.radius);
                if ((dx * dx) + (dy * dy) <= radius2) {
                    return true;
                }
                dy = y - (this.y + this.height - this.radius);
                if ((dx * dx) + (dy * dy) <= radius2) {
                    return true;
                }
                dx = x - (this.x + this.radius);
                if ((dx * dx) + (dy * dy) <= radius2) {
                    return true;
                }
            }
        }
        return false;
    }
    ;
}
exports.RoundedRectangle = RoundedRectangle;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/Runner.js":
/*!******************************************!*\
  !*** ./js-compile/raw-pixi-ts/Runner.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class Runner {
    constructor(name, priority = 0) {
        this.items = [];
        this._name = name;
        this.dispatch = this.emit;
        this.run = this.emit;
    }
    emit(a0, a1, a2, a3, a4, a5, a6, a7) {
        if (arguments.length > 8) {
            throw new Error('max arguments reached');
        }
        var ref = this;
        var name = ref.name;
        var items = ref.items;
        for (var i = 0, len = items.length; i < len; i++) {
            items[i][name](a0, a1, a2, a3, a4, a5, a6, a7);
        }
        return this;
    }
    ;
    /**
     * Add a listener to the Runner
     *
     * Runners do not need to have scope or functions passed to them.
     * All that is required is to pass the listening object and ensure that it has contains a function that has the same name
     * as the name provided to the Runner when it was created.
     *
     * Eg A listener passed to this Runner will require a 'complete' function.
     *
     * ```
     * const complete = new PIXI.Runner('complete');
     * ```
     *
     * The scope used will be the object itself.
     *
     * @param {any} item - The object that will be listening.
     */
    add(item) {
        if (item[this._name]) {
            this.remove(item);
            this.items.push(item);
        }
        return this;
    }
    ;
    /**
     * Remove a single listener from the dispatch queue.
     * @param {any} item - The listenr that you would like to remove.
     */
    remove(item) {
        var index = this.items.indexOf(item);
        if (index !== -1) {
            this.items.splice(index, 1);
        }
        return this;
    }
    ;
    /**
     * Check to see if the listener is already in the Runner
     * @param {any} item - The listener that you would like to check.
     */
    contains(item) {
        return this.items.indexOf(item) !== -1;
    }
    ;
    /**
     * Remove all listeners from the Runner
     */
    removeAll() {
        this.items.length = 0;
        return this;
    }
    ;
    /**
     * Remove all references, don't use after this.
     */
    destroy() {
        this.removeAll();
        this.items = null;
        this._name = null;
    }
    ;
    /**
     * `true` if there are no this Runner contains no listeners
     *
     * @member {boolean}
     * @readonly
     */
    get empty() {
        return this.items.length === 0;
    }
    ;
    /**
     * The name of the runner.
     *
     * @member {string}
     * @readonly
     */
    get name() {
        return this._name;
    }
    ;
}
exports.Runner = Runner;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/SVGResource.js":
/*!***********************************************!*\
  !*** ./js-compile/raw-pixi-ts/SVGResource.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseImageResource_1 = __webpack_require__(/*! ./BaseImageResource */ "./js-compile/raw-pixi-ts/BaseImageResource.js");
const settings_1 = __webpack_require__(/*! ./settings */ "./js-compile/raw-pixi-ts/settings.js");
const MathSettings_1 = __webpack_require__(/*! ./MathSettings */ "./js-compile/raw-pixi-ts/MathSettings.js");
class SVGResource extends BaseImageResource_1.BaseImageResource {
    constructor(source, options) {
        options = options || {};
        super(document.createElement('canvas'));
        /**
         * Base64 encoded SVG element or URL for SVG file
         * @readonly
         * @member {string}
         */
        this.svg = source;
        /**
         * The source scale to apply to render
         * @readonly
         * @member {number}
         */
        this.scale = options.scale || 1;
        /**
         * Call when completely loaded
         * @private
         * @member {function}
         */
        this._resolve = null;
        /**
         * Promise when loading
         * @member {Promise<void>}
         * @private
         * @default null
         */
        this._load = null;
        if (options.autoLoad !== false) {
            this.load();
        }
    }
    load() {
        var this$1 = this;
        if (this._load) {
            return this._load;
        }
        this._load = new Promise(function (resolve) {
            // Save this until after load is finished
            this$1._resolve = function () {
                this$1.resize(this$1.source.width, this$1.source.height);
                resolve(this$1);
            };
            // Convert SVG inline string to data-uri
            if ((/^\<svg/).test(this$1.svg.trim())) {
                this$1.svg = "data:image/svg+xml;utf8," + (this$1.svg);
            }
            // Checks if `source` is an SVG image and whether it's
            // loaded via a URL or a data URI. Then calls
            // `_loadDataUri` or `_loadXhr`.
            var dataUri = settings_1.settings.decomposeDataUri(this$1.svg);
            if (dataUri) {
                this$1._loadDataUri(dataUri);
            }
            else {
                // We got an URL, so we need to do an XHR to check the svg size
                this$1._loadXhr();
            }
        });
        return this._load;
    }
    ;
    /**
     * Reads an SVG string from data URI and then calls `_loadString`.
     *
     * @param {string} dataUri - The data uri to load from.
     */
    _loadDataUri(dataUri) {
        var svgString;
        if (dataUri.encoding === 'base64') {
            if (!atob) {
                throw new Error('Your browser doesn\'t support base64 conversions.');
            }
            svgString = atob(dataUri.data);
        }
        else {
            svgString = dataUri.data;
        }
        this._loadString(svgString);
    }
    ;
    /**
     * Loads an SVG string from `imageUrl` using XHR and then calls `_loadString`.
     *
     * @private
     */
    _loadXhr() {
        var this$1 = this;
        var svgXhr = new XMLHttpRequest();
        // This throws error on IE, so SVG Document can't be used
        // svgXhr.responseType = 'document';
        // This is not needed since we load the svg as string (breaks IE too)
        // but overrideMimeType() can be used to force the response to be parsed as XML
        // svgXhr.overrideMimeType('image/svg+xml');
        svgXhr.onload = function () {
            if (svgXhr.readyState !== svgXhr.DONE || svgXhr.status !== 200) {
                throw new Error('Failed to load SVG using XHR.');
            }
            this$1._loadString(svgXhr.response);
        };
        // svgXhr.onerror = () => this.emit('error', this);
        svgXhr.open('GET', this.svg, true);
        svgXhr.send();
    }
    ;
    /**
     * Loads texture using an SVG string. The original SVG Image is stored as `origSource` and the
     * created canvas is the new `source`. The SVG is scaled using `sourceScale`. Called by
     * `_loadXhr` or `_loadDataUri`.
     *
     * @private
     * @param  {string} svgString SVG source as string
     *
     * @fires loaded
     */
    _loadString(svgString) {
        var svgSize = SVGResource.getSize(svgString);
        // TODO do we need to wait for this to load?
        // seems instant!
        //
        var tempImage = new Image();
        tempImage.src = "data:image/svg+xml," + svgString;
        var svgWidth = svgSize.width;
        var svgHeight = svgSize.height;
        if (!svgWidth || !svgHeight) {
            throw new Error('The SVG image must have width and height defined (in pixels), canvas API needs them.');
        }
        // Scale realWidth and realHeight
        this._width = Math.round(svgWidth * this.scale);
        this._height = Math.round(svgHeight * this.scale);
        // Create a canvas element
        var canvas = this.source;
        canvas.width = this._width;
        canvas.height = this._height;
        canvas._pixiId = "canvas_" + (MathSettings_1.MathSettings.uid());
        // Draw the Svg to the canvas
        canvas
            .getContext('2d')
            .drawImage(tempImage, 0, 0, svgWidth, svgHeight, 0, 0, this.width, this.height);
        this._resolve();
        this._resolve = null;
    }
    ;
    /**
     * Typedef for Size object.
     *
     * @memberof PIXI.resources.SVGResource
     * @typedef {object} Size
     * @property {number} width - Width component
     * @property {number} height - Height component
     */
    /**
     * Get size from an svg string using regexp.
     *
     * @method
     * @param {string} svgString - a serialized svg element
     * @return {PIXI.resources.SVGResource.Size} image extension
     */
    static getSize(svgString) {
        var sizeMatch = SVGResource.SVG_SIZE.exec(svgString);
        var size = {};
        if (sizeMatch) {
            size[sizeMatch[1]] = Math.round(parseFloat(sizeMatch[3]));
            size[sizeMatch[5]] = Math.round(parseFloat(sizeMatch[7]));
        }
        return size;
    }
    ;
    /**
     * Destroys this texture
     * @override
     */
    dispose() {
        BaseImageResource_1.BaseImageResource.prototype.dispose.call(this);
        this._resolve = null;
    }
    ;
    /**
     * Used to auto-detect the type of resource.
     *
     * @static
     * @param {*} source - The source object
     * @param {string} extension - The extension of source, if set
     */
    static test(source, extension) {
        // url file extension is SVG
        return extension === 'svg'
            // source is SVG data-uri
            || (typeof source === 'string' && source.indexOf('data:image/svg+xml') === 0);
    }
    ;
}
/**
* RegExp for SVG size.
*
* @static
* @constant {RegExp|string} SVG_SIZE
* @memberof PIXI.resources.SVGResource
* @example &lt;svg width="100" height="100"&gt;&lt;/svg&gt;
*/
SVGResource.SVG_SIZE = /<svg[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*>/i; // eslint-disable-line max-len
exports.SVGResource = SVGResource;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/Shader.js":
/*!******************************************!*\
  !*** ./js-compile/raw-pixi-ts/Shader.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const UniformGroup_1 = __webpack_require__(/*! ./UniformGroup */ "./js-compile/raw-pixi-ts/UniformGroup.js");
const Program_1 = __webpack_require__(/*! ./Program */ "./js-compile/raw-pixi-ts/Program.js");
class Shader {
    constructor(program, uniforms) {
        this.program = program;
        // lets see whats been passed in
        // uniforms should be converted to a uniform group
        if (uniforms) {
            if (uniforms instanceof UniformGroup_1.UniformGroup) {
                this.uniformGroup = uniforms;
            }
            else {
                this.uniformGroup = new UniformGroup_1.UniformGroup(uniforms);
            }
        }
        else {
            this.uniformGroup = new UniformGroup_1.UniformGroup({});
        }
        // time to build some getters and setters!
        // I guess down the line this could sort of generate an instruction list rather than use dirty ids?
        // does the trick for now though!
        for (var i in program.uniformData) {
            if (this.uniformGroup.uniforms[i] instanceof Array) {
                this.uniformGroup.uniforms[i] = new Float32Array(this.uniformGroup.uniforms[i]);
            }
        }
    }
    // TODO move to shader system..
    checkUniformExists(name, group) {
        if (group.uniforms[name]) {
            return true;
        }
        for (var i in group.uniforms) {
            var uniform = group.uniforms[i];
            if (uniform.group) {
                if (this.checkUniformExists(name, uniform)) {
                    return true;
                }
            }
        }
        return false;
    }
    ;
    destroy() {
        // usage count on programs?
        // remove if not used!
        this.uniformGroup = null;
    }
    ;
    /**
     * Shader uniform values, shortcut for `uniformGroup.uniforms`
     * @readonly
     * @member {object}
     */
    get uniforms() {
        return this.uniformGroup.uniforms;
    }
    ;
    /**
     * A short hand function to create a shader based of a vertex and fragment shader
     *
     * @param {string} [vertexSrc] - The source of the vertex shader.
     * @param {string} [fragmentSrc] - The source of the fragment shader.
     * @param {object} [uniforms] - Custom uniforms to use to augment the built-in ones.
     *
     * @returns {PIXI.Shader} an shiny new Pixi shader!
     */
    static from(vertexSrc, fragmentSrc, uniforms) {
        var program = Program_1.Program.from(vertexSrc, fragmentSrc);
        return new Shader(program, uniforms);
    }
    ;
    /**
 * @private
 * @param gl {WebGLRenderingContext} The current WebGL context {WebGLProgram}
 * @param type {Number} the type, can be either VERTEX_SHADER or FRAGMENT_SHADER
 * @param vertexSrc {string|string[]} The vertex shader source as an array of strings.
 * @return {WebGLShader} the shader
 */
    static compileShader(gl, type, src) {
        var shader = gl.createShader(type);
        gl.shaderSource(shader, src);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            console.warn(src);
            console.error(gl.getShaderInfoLog(shader));
            return null;
        }
        return shader;
    }
}
exports.Shader = Shader;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/ShaderSystem.js":
/*!************************************************!*\
  !*** ./js-compile/raw-pixi-ts/ShaderSystem.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const System_1 = __webpack_require__(/*! ./System */ "./js-compile/raw-pixi-ts/System.js");
const Program_1 = __webpack_require__(/*! ./Program */ "./js-compile/raw-pixi-ts/Program.js");
const GLProgram_1 = __webpack_require__(/*! ./GLProgram */ "./js-compile/raw-pixi-ts/GLProgram.js");
const StateSystem_1 = __webpack_require__(/*! ./StateSystem */ "./js-compile/raw-pixi-ts/StateSystem.js");
const UtilsSettings_1 = __webpack_require__(/*! ./UtilsSettings */ "./js-compile/raw-pixi-ts/UtilsSettings.js");
const WebGLSettings_1 = __webpack_require__(/*! ./WebGLSettings */ "./js-compile/raw-pixi-ts/WebGLSettings.js");
class ShaderSystem extends System_1.System {
    constructor(renderer) {
        super(renderer);
        // Validation check that this environment support `new Function`
        this.systemCheck();
        /**
         * The current WebGL rendering context
         *
         * @member {WebGLRenderingContext}
         */
        this.gl = null;
        this.shader = null;
        this.program = null;
        /**
         * Cache to holds the generated functions. Stored against UniformObjects unique signature
         * @type {Object}
         * @private
         */
        this.cache = {};
        this.id = StateSystem_1.StateSystem.UID$4++;
    }
    /**
     * Overrideable function by `@pixi/unsafe-eval` to silence
     * throwing an error if platform doesn't support unsafe-evals.
     *
     * @private
     */
    systemCheck() {
        if (!UtilsSettings_1.UtilsSettings.unsafeEvalSupported()) {
            throw new Error('Current environment does not allow unsafe-eval, '
                + 'please use @pixi/unsafe-eval module to enable support.');
        }
    }
    ;
    contextChange(gl) {
        this.gl = gl;
    }
    ;
    /**
     * Changes the current shader to the one given in parameter
     *
     * @param {PIXI.Shader} shader - the new shader
     * @param {boolean} dontSync - false if the shader should automatically sync its uniforms.
     * @returns {PIXI.GLProgram} the glProgram that belongs to the shader.
     */
    bind(shader, dontSync = false) {
        shader.uniforms.globals = this.renderer.globalUniforms;
        var program = shader.program;
        var glProgram = program.glPrograms[this.renderer.CONTEXT_UID] || this.generateShader(shader);
        this.shader = shader;
        // TODO - some current Pixi plugins bypass this.. so it not safe to use yet..
        if (this.program !== program) {
            this.program = program;
            this.gl.useProgram(glProgram.program);
        }
        if (!dontSync) {
            this.syncUniformGroup(shader.uniformGroup);
        }
        return glProgram;
    }
    ;
    /**
     * Uploads the uniforms values to the currently bound shader.
     *
     * @param {object} uniforms - the uniforms values that be applied to the current shader
     */
    setUniforms(uniforms) {
        var shader = this.shader.program;
        var glProgram = shader.glPrograms[this.renderer.CONTEXT_UID];
        shader.syncUniforms(glProgram.uniformData, uniforms, this.renderer);
    }
    ;
    syncUniformGroup(group) {
        var glProgram = this.getglProgram();
        if (!group.static || group.dirtyId !== glProgram.uniformGroups[group.id]) {
            glProgram.uniformGroups[group.id] = group.dirtyId;
            this.syncUniforms(group, glProgram);
        }
    }
    ;
    /**
     * Overrideable by the @pixi/unsafe-eval package to use static
     * syncUnforms instead.
     *
     * @private
     */
    syncUniforms(group, glProgram) {
        var syncFunc = group.syncUniforms[this.shader.program.id] || this.createSyncGroups(group);
        syncFunc(glProgram.uniformData, group.uniforms, this.renderer);
    }
    ;
    createSyncGroups(group) {
        var id = this.getSignature(group, this.shader.program.uniformData);
        if (!this.cache[id]) {
            this.cache[id] = WebGLSettings_1.WebGLSettings.generateUniformsSync(group, this.shader.program.uniformData);
        }
        group.syncUniforms[this.shader.program.id] = this.cache[id];
        return group.syncUniforms[this.shader.program.id];
    }
    ;
    /**
     * Takes a uniform group and data and generates a unique signature for them.
     *
     * @param {PIXI.UniformGroup} group the uniform group to get signature of
     * @param {Object} uniformData uniform information generated by the shader
     * @returns {String} Unique signature of the uniform group
     * @private
     */
    getSignature(group, uniformData) {
        var uniforms = group.uniforms;
        var strings = [];
        for (var i in uniforms) {
            strings.push(i);
            if (uniformData[i]) {
                strings.push(uniformData[i].type);
            }
        }
        return strings.join('-');
    }
    ;
    /**
     * Returns the underlying GLShade rof the currently bound shader.
     * This can be handy for when you to have a little more control over the setting of your uniforms.
     *
     * @return {PIXI.GLProgram} the glProgram for the currently bound Shader for this context
     */
    getglProgram() {
        if (this.shader) {
            return this.shader.program.glPrograms[this.renderer.CONTEXT_UID];
        }
        return null;
    }
    ;
    /**
     * Generates a glProgram version of the Shader provided.
     *
     * @private
     * @param {PIXI.Shader} shader the shader that the glProgram will be based on.
     * @return {PIXI.GLProgram} A shiny new glProgram!
     */
    generateShader(shader) {
        var gl = this.gl;
        var program = shader.program;
        var attribMap = {};
        for (var i in program.attributeData) {
            attribMap[i] = program.attributeData[i].location;
        }
        var shaderProgram = Program_1.Program.compileProgram(gl, program.vertexSrc, program.fragmentSrc, attribMap);
        var uniformData = {};
        for (var i$1 in program.uniformData) {
            var data = program.uniformData[i$1];
            uniformData[i$1] = {
                location: gl.getUniformLocation(shaderProgram, i$1),
                value: WebGLSettings_1.WebGLSettings.defaultValue(data.type, data.size),
            };
        }
        var glProgram = new GLProgram_1.GLProgram(shaderProgram, uniformData);
        program.glPrograms[this.renderer.CONTEXT_UID] = glProgram;
        return glProgram;
    }
    ;
    /**
     * Resets ShaderSystem state, does not affect WebGL state
     */
    reset() {
        this.program = null;
        this.shader = null;
    }
    ;
    /**
     * Destroys this System and removes all its textures
     */
    destroy() {
        // TODO implement destroy method for ShaderSystem
        this.destroyed = true;
    }
    ;
}
exports.ShaderSystem = ShaderSystem;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/ShapeSettings.js":
/*!*************************************************!*\
  !*** ./js-compile/raw-pixi-ts/ShapeSettings.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class ShapeSettings {
}
/**
* Constants that identify shapes, mainly to prevent `instanceof` calls.
*
* @static
* @constant
* @name SHAPES
* @memberof PIXI
* @type {object}
* @property {number} POLY Polygon
* @property {number} RECT Rectangle
* @property {number} CIRC Circle
* @property {number} ELIP Ellipse
* @property {number} RREC Rounded Rectangle
*/
ShapeSettings.SHAPES = {
    POLY: 0,
    RECT: 1,
    CIRC: 2,
    ELIP: 3,
    RREC: 4,
};
exports.ShapeSettings = ShapeSettings;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/SimpleRope.js":
/*!**********************************************!*\
  !*** ./js-compile/raw-pixi-ts/SimpleRope.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Mesh_1 = __webpack_require__(/*! ./Mesh */ "./js-compile/raw-pixi-ts/Mesh.js");
const RopeGeometry_1 = __webpack_require__(/*! ./RopeGeometry */ "./js-compile/raw-pixi-ts/RopeGeometry.js");
const MeshMaterial_1 = __webpack_require__(/*! ./MeshMaterial */ "./js-compile/raw-pixi-ts/MeshMaterial.js");
class SimpleRope extends Mesh_1.Mesh {
    constructor(texture, points) {
        var ropeGeometry = new RopeGeometry_1.RopeGeometry(texture.height, points);
        var meshMaterial = new MeshMaterial_1.MeshMaterial(texture);
        super(ropeGeometry, meshMaterial);
        this.autoUpdate = true;
    }
    _render(renderer) {
        if (this.autoUpdate
            || this.geometry.width !== this.shader.texture.height) {
            this.geometry.width = this.shader.texture.height;
            this.geometry.update();
        }
        super._render(renderer);
    }
    ;
}
exports.SimpleRope = SimpleRope;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/Sprite.js":
/*!******************************************!*\
  !*** ./js-compile/raw-pixi-ts/Sprite.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Container_1 = __webpack_require__(/*! ./Container */ "./js-compile/raw-pixi-ts/Container.js");
const ObservablePoint_1 = __webpack_require__(/*! ./ObservablePoint */ "./js-compile/raw-pixi-ts/ObservablePoint.js");
const Texture_1 = __webpack_require__(/*! ./Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const Rectangle_1 = __webpack_require__(/*! ./Rectangle */ "./js-compile/raw-pixi-ts/Rectangle.js");
const Point_1 = __webpack_require__(/*! ./Point */ "./js-compile/raw-pixi-ts/Point.js");
const BlendModesSettings_1 = __webpack_require__(/*! ./BlendModesSettings */ "./js-compile/raw-pixi-ts/BlendModesSettings.js");
const DisplaySettings_1 = __webpack_require__(/*! ./DisplaySettings */ "./js-compile/raw-pixi-ts/DisplaySettings.js");
const MathSettings_1 = __webpack_require__(/*! ./MathSettings */ "./js-compile/raw-pixi-ts/MathSettings.js");
const Logger_1 = __webpack_require__(/*! ./Logger */ "./js-compile/raw-pixi-ts/Logger.js");
class Sprite extends Container_1.Container {
    constructor(texture) {
        super();
        /**
         * When the texture is updated, this event will fire to update the scale and frame
         *
         * @private
         */
        this._onTextureUpdate = () => {
            Logger_1.trace("Sprite update");
            this._textureID = -1;
            this._textureTrimmedID = -1;
            this.cachedTint = 0xFFFFFF;
            // reveal(this._texture)
            this.uvs = this._texture._uvs.uvsFloat32;
            // so if _width is 0 then width was not set..
            if (this._width) {
                this.scale.x = MathSettings_1.MathSettings.sign(this.scale.x) * this._width / this._texture.orig.width;
            }
            if (this._height) {
                this.scale.y = MathSettings_1.MathSettings.sign(this.scale.y) * this._height / this._texture.orig.height;
            }
        };
        /**
         * The anchor sets the origin point of the texture.
         * The default is 0,0 or taken from the {@link PIXI.Texture#defaultAnchor|Texture}
         * passed to the constructor. A value of 0,0 means the texture's origin is the top left.
         * Setting the anchor to 0.5,0.5 means the texture's origin is centered.
         * Setting the anchor to 1,1 would mean the texture's origin point will be the bottom right corner.
         * Note: Updating the {@link PIXI.Texture#defaultAnchor} after a Texture is
         * created does _not_ update the Sprite's anchor values.
         *
         * @member {PIXI.ObservablePoint}
         * @private
         */
        this._anchor = new ObservablePoint_1.ObservablePoint(this._onAnchorUpdate, this, (texture ? texture.defaultAnchor.x : 0), (texture ? texture.defaultAnchor.y : 0));
        /**
         * The texture that the sprite is using
         *
         * @private
         * @member {PIXI.Texture}
         */
        this._texture = null;
        /**
         * The width of the sprite (this is initially set by the texture)
         *
         * @private
         * @member {number}
         */
        this._width = 0;
        /**
         * The height of the sprite (this is initially set by the texture)
         *
         * @private
         * @member {number}
         */
        this._height = 0;
        /**
         * The tint applied to the sprite. This is a hex value. A value of 0xFFFFFF will remove any tint effect.
         *
         * @private
         * @member {number}
         * @default 0xFFFFFF
         */
        this._tint = null;
        this._tintRGB = null;
        this.tint = 0xFFFFFF;
        /**
         * The blend mode to be applied to the sprite. Apply a value of `PIXI.BLEND_MODES.NORMAL` to reset the blend mode.
         *
         * @member {number}
         * @default PIXI.BLEND_MODES.NORMAL
         * @see PIXI.BLEND_MODES
         */
        this.blendMode = BlendModesSettings_1.BlendModesSettings.BLEND_MODES.NORMAL;
        /**
         * The shader that will be used to render the sprite. Set to null to remove a current shader.
         *
         * @member {PIXI.Filter|PIXI.Shader}
         */
        this.shader = null;
        /**
         * An internal cached value of the tint.
         *
         * @private
         * @member {number}
         * @default 0xFFFFFF
         */
        this.cachedTint = 0xFFFFFF;
        this.uvs = null;
        // call texture setter
        this.texture = texture || Texture_1.Texture.EMPTY;
        /**
         * this is used to store the vertex data of the sprite (basically a quad)
         *
         * @private
         * @member {Float32Array}
         */
        this.vertexData = new Float32Array(8);
        /**
         * This is used to calculate the bounds of the object IF it is a trimmed sprite
         *
         * @private
         * @member {Float32Array}
         */
        this.vertexTrimmedData = null;
        this._transformID = -1;
        this._textureID = -1;
        this._transformTrimmedID = -1;
        this._textureTrimmedID = -1;
        // Batchable stuff..
        // TODO could make this a mixin?
        this.indices = Sprite.indices;
        this.size = 4;
        this.start = 0;
        /**
         * Plugin that is responsible for rendering this element.
         * Allows to customize the rendering process without overriding '_render' & '_renderCanvas' methods.
         *
         * @member {string}
         * @default 'sprite'
         */
        this.pluginName = 'batch';
        /**
         * used to fast check if a sprite is.. a sprite!
         * @member {boolean}
         */
        this.isSprite = true;
        /**
         * Internal roundPixels field
         *
         * @member {boolean}
         * @private
         */
        this._roundPixels = DisplaySettings_1.DisplaySettings.ROUND_PIXELS;
    }
    /**
     * Called when the anchor position updates.
     *
     * @private
     */
    _onAnchorUpdate() {
        this._transformID = -1;
        this._transformTrimmedID = -1;
    }
    ;
    /**
     * calculates worldTransform * vertices, store it in vertexData
     */
    calculateVertices() {
        var texture = this._texture;
        if (this._transformID === this.transform._worldID && this._textureID === texture._updateID) {
            return;
        }
        this._transformID = this.transform._worldID;
        this._textureID = texture._updateID;
        // set the vertex data
        var wt = this.transform.worldTransform;
        var a = wt.a;
        var b = wt.b;
        var c = wt.c;
        var d = wt.d;
        var tx = wt.tx;
        var ty = wt.ty;
        var vertexData = this.vertexData;
        var trim = texture.trim;
        var orig = texture.orig;
        var anchor = this._anchor;
        var w0 = 0;
        var w1 = 0;
        var h0 = 0;
        var h1 = 0;
        if (trim) {
            // if the sprite is trimmed and is not a tilingsprite then we need to add the extra
            // space before transforming the sprite coords.
            w1 = trim.x - (anchor._x * orig.width);
            w0 = w1 + trim.width;
            h1 = trim.y - (anchor._y * orig.height);
            h0 = h1 + trim.height;
        }
        else {
            w1 = -anchor._x * orig.width;
            w0 = w1 + orig.width;
            h1 = -anchor._y * orig.height;
            h0 = h1 + orig.height;
        }
        // xy
        vertexData[0] = (a * w1) + (c * h1) + tx;
        vertexData[1] = (d * h1) + (b * w1) + ty;
        // xy
        vertexData[2] = (a * w0) + (c * h1) + tx;
        vertexData[3] = (d * h1) + (b * w0) + ty;
        // xy
        vertexData[4] = (a * w0) + (c * h0) + tx;
        vertexData[5] = (d * h0) + (b * w0) + ty;
        // xy
        vertexData[6] = (a * w1) + (c * h0) + tx;
        vertexData[7] = (d * h0) + (b * w1) + ty;
        if (this._roundPixels) {
            for (var i = 0; i < 8; i++) {
                vertexData[i] = Math.round(vertexData[i]);
            }
        }
    }
    ;
    /**
     * calculates worldTransform * vertices for a non texture with a trim. store it in vertexTrimmedData
     * This is used to ensure that the true width and height of a trimmed texture is respected
     */
    calculateTrimmedVertices() {
        if (!this.vertexTrimmedData) {
            this.vertexTrimmedData = new Float32Array(8);
        }
        else if (this._transformTrimmedID === this.transform._worldID && this._textureTrimmedID === this._texture._updateID) {
            return;
        }
        this._transformTrimmedID = this.transform._worldID;
        this._textureTrimmedID = this._texture._updateID;
        // lets do some special trim code!
        var texture = this._texture;
        var vertexData = this.vertexTrimmedData;
        var orig = texture.orig;
        var anchor = this._anchor;
        // lets calculate the new untrimmed bounds..
        var wt = this.transform.worldTransform;
        var a = wt.a;
        var b = wt.b;
        var c = wt.c;
        var d = wt.d;
        var tx = wt.tx;
        var ty = wt.ty;
        var w1 = -anchor._x * orig.width;
        var w0 = w1 + orig.width;
        var h1 = -anchor._y * orig.height;
        var h0 = h1 + orig.height;
        // xy
        vertexData[0] = (a * w1) + (c * h1) + tx;
        vertexData[1] = (d * h1) + (b * w1) + ty;
        // xy
        vertexData[2] = (a * w0) + (c * h1) + tx;
        vertexData[3] = (d * h1) + (b * w0) + ty;
        // xy
        vertexData[4] = (a * w0) + (c * h0) + tx;
        vertexData[5] = (d * h0) + (b * w0) + ty;
        // xy
        vertexData[6] = (a * w1) + (c * h0) + tx;
        vertexData[7] = (d * h0) + (b * w1) + ty;
    }
    ;
    /**
    *
    * Renders the object using the WebGL renderer
    *
    * @protected
    * @param {PIXI.Renderer} renderer - The webgl renderer to use.
    */
    _render(renderer) {
        this.calculateVertices();
        renderer.batch.setObjectRenderer(renderer.plugins[this.pluginName]);
        renderer.plugins[this.pluginName].render(this);
    }
    ;
    /**
     * Updates the bounds of the sprite.
     *
     * @protected
     */
    _calculateBounds() {
        var trim = this._texture.trim;
        var orig = this._texture.orig;
        // First lets check to see if the current texture has a trim..
        if (!trim || (trim.width === orig.width && trim.height === orig.height)) {
            // no trim! lets use the usual calculations..
            this.calculateVertices();
            this._bounds.addQuad(this.vertexData);
        }
        else {
            // lets calculate a special trimmed bounds...
            this.calculateTrimmedVertices();
            this._bounds.addQuad(this.vertexTrimmedData);
        }
    }
    ;
    /**
     * Gets the local bounds of the sprite object.
     *
     * @param {PIXI.Rectangle} rect - The output rectangle.
     * @return {PIXI.Rectangle} The bounds.
     */
    getLocalBounds(rect) {
        // we can do a fast local bounds if the sprite has no children!
        if (this.children.length === 0) {
            this._bounds.minX = this._texture.orig.width * -this._anchor._x;
            this._bounds.minY = this._texture.orig.height * -this._anchor._y;
            this._bounds.maxX = this._texture.orig.width * (1 - this._anchor._x);
            this._bounds.maxY = this._texture.orig.height * (1 - this._anchor._y);
            if (!rect) {
                if (!this._localBoundsRect) {
                    this._localBoundsRect = new Rectangle_1.Rectangle();
                }
                rect = this._localBoundsRect;
            }
            return this._bounds.getRectangle(rect);
        }
        return Container_1.Container.prototype.getLocalBounds.call(this, rect);
    }
    ;
    /**
     * Tests if a point is inside this sprite
     *
     * @param {PIXI.Point} point - the point to test
     * @return {boolean} the result of the test
     */
    containsPoint(point) {
        this.worldTransform.applyInverse(point, Sprite.tempPoint);
        var width = this._texture.orig.width;
        var height = this._texture.orig.height;
        var x1 = -width * this.anchor.x;
        var y1 = 0;
        if (Sprite.tempPoint.x >= x1 && Sprite.tempPoint.x < x1 + width) {
            y1 = -height * this.anchor.y;
            if (Sprite.tempPoint.y >= y1 && Sprite.tempPoint.y < y1 + height) {
                return true;
            }
        }
        return false;
    }
    ;
    /**
     * Destroys this sprite and optionally its texture and children
     *
     * @param {object|boolean} [options] - Options parameter. A boolean will act as if all options
     *  have been set to that value
     * @param {boolean} [options.children=false] - if set to true, all the children will have their destroy
     *      method called as well. 'options' will be passed on to those calls.
     * @param {boolean} [options.texture=false] - Should it destroy the current texture of the sprite as well
     * @param {boolean} [options.baseTexture=false] - Should it destroy the base texture of the sprite as well
     */
    destroy(options) {
        super.destroy(options);
        // this._texture.off('update', this._onTextureUpdate, this);
        this._anchor = null;
        var destroyTexture = typeof options === 'boolean' ? options : options && options.texture;
        if (destroyTexture) {
            var destroyBaseTexture = typeof options === 'boolean' ? options : options && options.baseTexture;
            this._texture.destroy(!!destroyBaseTexture);
        }
        this._texture = null;
        this.shader = null;
    }
    ;
    /**
     * If true PixiJS will Math.floor() x/y values when rendering, stopping pixel interpolation.
     * Advantages can include sharper image quality (like text) and faster rendering on canvas.
     * The main disadvantage is movement of objects may appear less smooth.
     * To set the global default, change {@link PIXI.settings.ROUND_PIXELS}
     *
     * @member {boolean}
     * @default false
     */
    set roundPixels(value) {
        if (this._roundPixels !== value) {
            this._transformID = -1;
        }
        this._roundPixels = value;
    }
    ;
    get roundPixels() {
        return this._roundPixels;
    }
    ;
    /**
     * The width of the sprite, setting this will actually modify the scale to achieve the value set
     *
     * @member {number}
     */
    get width() {
        return Math.abs(this.scale.x) * this._texture.orig.width;
    }
    ;
    set width(value) {
        var s = MathSettings_1.MathSettings.sign(this.scale.x) || 1;
        this.scale.x = s * value / this._texture.orig.width;
        this._width = value;
    }
    ;
    /**
     * The height of the sprite, setting this will actually modify the scale to achieve the value set
     *
     * @member {number}
     */
    get height() {
        return Math.abs(this.scale.y) * this._texture.orig.height;
    }
    ;
    set height(value) {
        var s = MathSettings_1.MathSettings.sign(this.scale.y) || 1;
        this.scale.y = s * value / this._texture.orig.height;
        this._height = value;
    }
    ;
    /**
     * The anchor sets the origin point of the text. The default value is taken from the {@link PIXI.Texture|Texture}
     * and passed to the constructor.
     *
     * The default is `(0,0)`, this means the text's origin is the top left.
     *
     * Setting the anchor to `(0.5,0.5)` means the text's origin is centered.
     *
     * Setting the anchor to `(1,1)` would mean the text's origin point will be the bottom right corner.
     *
     * If you pass only single parameter, it will set both x and y to the same value as shown in the example below.
     *
     * @example
     * const sprite = new PIXI.Sprite(texture);
     * sprite.anchor.set(0.5); // This will set the origin to center. (0.5) is same as (0.5, 0.5).
     *
     * @member {PIXI.ObservablePoint}
     */
    get anchor() {
        return this._anchor;
    }
    ;
    set anchor(value) {
        this._anchor.copyFrom(value);
    }
    ;
    /**
     * The tint applied to the sprite. This is a hex value.
     * A value of 0xFFFFFF will remove any tint effect.
     *
     * @member {number}
     * @default 0xFFFFFF
     */
    get tint() {
        return this._tint;
    }
    ;
    set tint(value) {
        this._tint = value;
        this._tintRGB = (value >> 16) + (value & 0xff00) + ((value & 0xff) << 16);
    }
    ;
    /**
     * The texture that the sprite is using
     *
     * @member {PIXI.Texture}
     */
    get texture() {
        return this._texture;
    }
    ;
    set texture(value) {
        if (this._texture === value) {
            return;
        }
        this._texture = value || Texture_1.Texture.EMPTY;
        this.cachedTint = 0xFFFFFF;
        this._textureID = -1;
        this._textureTrimmedID = -1;
        if (value) {
            // wait for the texture to load
            if (value.baseTexture.valid) {
                this._onTextureUpdate();
            }
            else {
                value.addEventListener('update', this._onTextureUpdate);
                // value.once('update', this._onTextureUpdate, this);
            }
        }
    }
    ;
}
Sprite.tempPoint = new Point_1.Point();
Sprite.indices = new Uint16Array([0, 1, 2, 0, 2, 3]);
// some helper functions..
/**
 * Helper function that creates a new sprite based on the source you provide.
 * The source can be - frame id, image url, video url, canvas element, video element, base texture
 *
 * @static
 * @param {number|string|PIXI.Texture|HTMLCanvasElement|HTMLVideoElement} source Source to create texture from
 * @param {object} [options] See {@link PIXI.BaseTexture}'s constructor for options.
 * @return {PIXI.Sprite} The newly created sprite
 */
Sprite.from = function from(source, options = {}) {
    if (options == null) {
        options = {};
    }
    var texture = (source instanceof Texture_1.Texture)
        ? source
        : Texture_1.Texture.from(source, options);
    return new Sprite(texture);
};
exports.Sprite = Sprite;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/SpriteMaskFilter.js":
/*!****************************************************!*\
  !*** ./js-compile/raw-pixi-ts/SpriteMaskFilter.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Filter_1 = __webpack_require__(/*! ./Filter */ "./js-compile/raw-pixi-ts/Filter.js");
const Matrix_1 = __webpack_require__(/*! ./Matrix */ "./js-compile/raw-pixi-ts/Matrix.js");
const TextureMatrix_1 = __webpack_require__(/*! ./TextureMatrix */ "./js-compile/raw-pixi-ts/TextureMatrix.js");
class SpriteMaskFilter extends Filter_1.Filter {
    constructor(sprite) {
        var maskMatrix = new Matrix_1.Matrix();
        super(SpriteMaskFilter.vertex, SpriteMaskFilter.fragment);
        sprite.renderable = false;
        /**
         * Sprite mask
         * @member {PIXI.Sprite}
         */
        this.maskSprite = sprite;
        /**
         * Mask matrix
         * @member {PIXI.Matrix}
         */
        this.maskMatrix = maskMatrix;
    }
    /**
     * Applies the filter
     *
     * @param {PIXI.systems.FilterSystem} filterManager - The renderer to retrieve the filter from
     * @param {PIXI.RenderTexture} input - The input render target.
     * @param {PIXI.RenderTexture} output - The target to output to.
     * @param {boolean} clear - Should the output be cleared before rendering to it.
     */
    apply(filterManager, input, output, clear) {
        var maskSprite = this.maskSprite;
        var tex = this.maskSprite.texture;
        if (!tex.valid) {
            return;
        }
        if (!tex.transform) {
            // margin = 0.0, let it bleed a bit, shader code becomes easier
            // assuming that atlas textures were made with 1-pixel padding
            tex.transform = new TextureMatrix_1.TextureMatrix(tex, 0.0);
        }
        tex.transform.update();
        this.uniforms.npmAlpha = tex.baseTexture.premultiplyAlpha ? 0.0 : 1.0;
        this.uniforms.mask = tex;
        this.uniforms.otherMatrix = filterManager.calculateSpriteMatrix(this.maskMatrix, maskSprite)
            .prepend(tex.transform.mapCoord);
        this.uniforms.alpha = maskSprite.worldAlpha;
        this.uniforms.maskClamp = tex.transform.uClampFrame;
        filterManager.applyFilter(this, input, output, clear);
    }
    ;
}
SpriteMaskFilter.vertex = "attribute vec2 aVertexPosition;\r\nattribute vec2 aTextureCoord;\r\n\r\nuniform mat3 projectionMatrix;\r\nuniform mat3 otherMatrix;\r\n\r\nvarying vec2 vMaskCoord;\r\nvarying vec2 vTextureCoord;\r\n\r\nvoid main(void)\r\n{\r\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\r\n\r\n    vTextureCoord = aTextureCoord;\r\n    vMaskCoord = ( otherMatrix * vec3( aTextureCoord, 1.0)  ).xy;\r\n}\r\n";
SpriteMaskFilter.fragment = "varying vec2 vMaskCoord;\r\nvarying vec2 vTextureCoord;\r\n\r\nuniform sampler2D uSampler;\r\nuniform sampler2D mask;\r\nuniform float alpha;\r\nuniform float npmAlpha;\r\nuniform vec4 maskClamp;\r\n\r\nvoid main(void)\r\n{\r\n    float clip = step(3.5,\r\n        step(maskClamp.x, vMaskCoord.x) +\r\n        step(maskClamp.y, vMaskCoord.y) +\r\n        step(vMaskCoord.x, maskClamp.z) +\r\n        step(vMaskCoord.y, maskClamp.w));\r\n\r\n    vec4 original = texture2D(uSampler, vTextureCoord);\r\n    vec4 masky = texture2D(mask, vMaskCoord);\r\n    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);\r\n\r\n    original *= (alphaMul * masky.r * alpha * clip);\r\n\r\n    gl_FragColor = original;\r\n}\r\n";
exports.SpriteMaskFilter = SpriteMaskFilter;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/Spritesheet.js":
/*!***********************************************!*\
  !*** ./js-compile/raw-pixi-ts/Spritesheet.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Rectangle_1 = __webpack_require__(/*! ./Rectangle */ "./js-compile/raw-pixi-ts/Rectangle.js");
const Texture_1 = __webpack_require__(/*! ./Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const NetworkSettings_1 = __webpack_require__(/*! ./NetworkSettings */ "./js-compile/raw-pixi-ts/NetworkSettings.js");
class Spritesheet {
    constructor(baseTexture, data, resolutionFilename = null) {
        /**
         * Reference to ths source texture
         * @type {PIXI.BaseTexture}
         */
        this.baseTexture = baseTexture;
        /**
         * A map containing all textures of the sprite sheet.
         * Can be used to create a {@link PIXI.Sprite|Sprite}:
         * ```js
         * new PIXI.Sprite(sheet.textures["image.png"]);
         * ```
         * @member {Object}
         */
        this.textures = {};
        /**
         * A map containing the textures for each animation.
         * Can be used to create an {@link PIXI.AnimatedSprite|AnimatedSprite}:
         * ```js
         * new PIXI.AnimatedSprite(sheet.animations["anim_name"])
         * ```
         * @member {Object}
         */
        this.animations = {};
        /**
         * Reference to the original JSON data.
         * @type {Object}
         */
        this.data = data;
        /**
         * The resolution of the spritesheet.
         * @type {number}
         */
        this.resolution = this._updateResolution(resolutionFilename
            || (this.baseTexture.resource ? this.baseTexture.resource.url : null));
        /**
         * Map of spritesheet frames.
         * @type {Object}
         * @private
         */
        this._frames = this.data.frames;
        /**
         * Collection of frame names.
         * @type {string[]}
         * @private
         */
        this._frameKeys = Object.keys(this._frames);
        /**
         * Current batch index being processed.
         * @type {number}
         * @private
         */
        this._batchIndex = 0;
        /**
         * Callback when parse is completed.
         * @type {Function}
         * @private
         */
        this._callback = null;
    }
    _updateResolution(resolutionFilename) {
        var scale = this.data.meta.scale;
        // Use a defaultValue of `null` to check if a url-based resolution is set
        var resolution = NetworkSettings_1.NetworkSettings.getResolutionOfUrl(resolutionFilename, null);
        // No resolution found via URL
        if (resolution === null) {
            // Use the scale value or default to 1
            resolution = scale !== undefined ? parseFloat(scale) : 1;
        }
        // For non-1 resolutions, update baseTexture
        if (resolution !== 1) {
            this.baseTexture.setResolution(resolution);
        }
        return resolution;
    }
    ;
    /**
     * Generate the resolution from the filename or fallback
     * to the meta.scale field of the JSON data.
     *
     * @private
     * @param {string} resolutionFilename - The filename to use for resolving
     *    the default resolution.
     * @return {number} Resolution to use for spritesheet.
     */
    static get BATCH_SIZE() {
        return 1000;
    }
    ;
    /**
     * Parser spritesheet from loaded data. This is done asynchronously
     * to prevent creating too many Texture within a single process.
     *
     * @param {Function} callback - Callback when complete returns
     *    a map of the Textures for this spritesheet.
     */
    parse(callback) {
        this._batchIndex = 0;
        this._callback = callback;
        if (this._frameKeys.length <= Spritesheet.BATCH_SIZE) {
            this._processFrames(0);
            this._processAnimations();
            this._parseComplete();
        }
        else {
            this._nextBatch();
        }
    }
    ;
    /**
     * Process a batch of frames
     *
     * @private
     * @param {number} initialFrameIndex - The index of frame to start.
     */
    _processFrames(initialFrameIndex) {
        var frameIndex = initialFrameIndex;
        var maxFrames = Spritesheet.BATCH_SIZE;
        while (frameIndex - initialFrameIndex < maxFrames && frameIndex < this._frameKeys.length) {
            var i = this._frameKeys[frameIndex];
            var data = this._frames[i];
            var rect = data.frame;
            if (rect) {
                var frame = null;
                var trim = null;
                var sourceSize = data.trimmed !== false && data.sourceSize
                    ? data.sourceSize : data.frame;
                var orig = new Rectangle_1.Rectangle(0, 0, Math.floor(sourceSize.w) / this.resolution, Math.floor(sourceSize.h) / this.resolution);
                if (data.rotated) {
                    frame = new Rectangle_1.Rectangle(Math.floor(rect.x) / this.resolution, Math.floor(rect.y) / this.resolution, Math.floor(rect.h) / this.resolution, Math.floor(rect.w) / this.resolution);
                }
                else {
                    frame = new Rectangle_1.Rectangle(Math.floor(rect.x) / this.resolution, Math.floor(rect.y) / this.resolution, Math.floor(rect.w) / this.resolution, Math.floor(rect.h) / this.resolution);
                }
                //  Check to see if the sprite is trimmed
                if (data.trimmed !== false && data.spriteSourceSize) {
                    trim = new Rectangle_1.Rectangle(Math.floor(data.spriteSourceSize.x) / this.resolution, Math.floor(data.spriteSourceSize.y) / this.resolution, Math.floor(rect.w) / this.resolution, Math.floor(rect.h) / this.resolution);
                }
                this.textures[i] = new Texture_1.Texture(this.baseTexture, frame, orig, trim, data.rotated ? 2 : 0, data.anchor);
                // lets also add the frame to pixi's global cache for fromFrame and fromImage functions
                Texture_1.Texture.addToCache(this.textures[i], i);
            }
            frameIndex++;
        }
    }
    ;
    /**
     * Parse animations config
     *
     * @private
     */
    _processAnimations() {
        var animations = this.data.animations || {};
        for (var animName in animations) {
            this.animations[animName] = [];
            for (var i = 0; i < animations[animName].length; i++) {
                var frameName = animations[animName][i];
                this.animations[animName].push(this.textures[frameName]);
            }
        }
    }
    ;
    /**
     * The parse has completed.
     *
     * @private
     */
    _parseComplete() {
        var callback = this._callback;
        this._callback = null;
        this._batchIndex = 0;
        callback.call(this, this.textures);
    }
    ;
    /**
     * Begin the next batch of textures.
     *
     * @private
     */
    _nextBatch() {
        var this$1 = this;
        this._processFrames(this._batchIndex * Spritesheet.BATCH_SIZE);
        this._batchIndex++;
        setTimeout(function () {
            if (this$1._batchIndex * Spritesheet.BATCH_SIZE < this$1._frameKeys.length) {
                this$1._nextBatch();
            }
            else {
                this$1._processAnimations();
                this$1._parseComplete();
            }
        }, 0);
    }
    ;
    /**
     * Destroy Spritesheet and don't use after this.
     *
     * @param {boolean} [destroyBase=false] Whether to destroy the base texture as well
     */
    destroy(destroyBase) {
        if (destroyBase === void 0) {
            destroyBase = false;
        }
        for (var i in this.textures) {
            this.textures[i].destroy();
        }
        this._frames = null;
        this._frameKeys = null;
        this.data = null;
        this.textures = null;
        if (destroyBase) {
            this.baseTexture.destroy();
        }
        this.baseTexture = null;
    }
    ;
}
exports.Spritesheet = Spritesheet;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/StageOptions.js":
/*!************************************************!*\
  !*** ./js-compile/raw-pixi-ts/StageOptions.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class StageOptions {
    constructor() {
        this.sharedLoader = false;
        this.forceCanvas = false;
        this.view = null;
        this.antialias = false;
        this.forceFXAA = false;
        this.autoDensity = true;
        this.autoResize = true;
        this.transparent = false;
        this.backgroundColor = 0x000000;
        this.clearBeforeRender = true;
        this.autoStart = true;
        this.preserveDrawingBuffer = false;
        this.width = 1024;
        this.height = 768;
        this.resolution = 1;
        this.legacy = false;
        this.roundPixels = false;
        this.sharedTicker = false;
        this.context = null;
        this.resizeTo = null;
        this.powerPreference = "high-performance";
    }
}
exports.StageOptions = StageOptions;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/Star.js":
/*!****************************************!*\
  !*** ./js-compile/raw-pixi-ts/Star.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Polygon_1 = __webpack_require__(/*! ./Polygon */ "./js-compile/raw-pixi-ts/Polygon.js");
const MathSettings_1 = __webpack_require__(/*! ./MathSettings */ "./js-compile/raw-pixi-ts/MathSettings.js");
class Star extends Polygon_1.Polygon {
    constructor(x, y, points, radius, innerRadius, rotation) {
        innerRadius = innerRadius || radius / 2;
        var startAngle = (-1 * Math.PI / 2) + rotation;
        var len = points * 2;
        var delta = MathSettings_1.MathSettings.PI_2 / len;
        var polygon = [];
        for (var i = 0; i < len; i++) {
            var r = i % 2 ? innerRadius : radius;
            var angle = (i * delta) + startAngle;
            polygon.push(x + (r * Math.cos(angle)), y + (r * Math.sin(angle)));
        }
        super(polygon);
    }
}
exports.Star = Star;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/State.js":
/*!*****************************************!*\
  !*** ./js-compile/raw-pixi-ts/State.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BlendModesSettings_1 = __webpack_require__(/*! ./BlendModesSettings */ "./js-compile/raw-pixi-ts/BlendModesSettings.js");
class State {
    constructor() {
        this.data = 0;
        this.blendMode = BlendModesSettings_1.BlendModesSettings.BLEND_MODES.NORMAL;
        this.polygonOffset = 0;
        this.blend = true;
        //  this.depthTest = true;
    }
    /**
     * Activates blending of the computed fragment color values
     *
     * @member {boolean}
     */
    get blend() {
        return !!(this.data & (1 << State.BLEND));
    }
    ;
    set blend(value) {
        if (!!(this.data & (1 << State.BLEND)) !== value) {
            this.data ^= (1 << State.BLEND);
        }
    }
    ;
    /**
     * Activates adding an offset to depth values of polygon's fragments
     *
     * @member {boolean}
     * @default false
     */
    get offsets() {
        return !!(this.data & (1 << State.OFFSET));
    }
    ;
    set offsets(value) {
        if (!!(this.data & (1 << State.OFFSET)) !== value) {
            this.data ^= (1 << State.OFFSET);
        }
    }
    ;
    /**
     * Activates culling of polygons.
     *
     * @member {boolean}
     * @default false
     */
    get culling() {
        return !!(this.data & (1 << State.CULLING));
    }
    ;
    set culling(value) {
        if (!!(this.data & (1 << State.CULLING)) !== value) {
            this.data ^= (1 << State.CULLING);
        }
    }
    ;
    /**
     * Activates depth comparisons and updates to the depth buffer.
     *
     * @member {boolean}
     * @default false
     */
    get depthTest() {
        return !!(this.data & (1 << State.DEPTH_TEST));
    }
    ;
    set depthTest(value) {
        if (!!(this.data & (1 << State.DEPTH_TEST)) !== value) {
            this.data ^= (1 << State.DEPTH_TEST);
        }
    }
    ;
    /**
     * Specifies whether or not front or back-facing polygons can be culled.
     * @member {boolean}
     * @default false
     */
    get clockwiseFrontFace() {
        return !!(this.data & (1 << State.WINDING));
    }
    ;
    set clockwiseFrontFace(value) {
        if (!!(this.data & (1 << State.WINDING)) !== value) {
            this.data ^= (1 << State.WINDING);
        }
    }
    ;
    /**
     * The blend mode to be applied when this state is set. Apply a value of `PIXI.BLEND_MODES.NORMAL` to reset the blend mode.
     * Setting this mode to anything other than NO_BLEND will automatically switch blending on.
     *
     * @member {boolean}
     * @default PIXI.BLEND_MODES.NORMAL
     * @see PIXI.BLEND_MODES
     */
    get blendMode() {
        return this._blendMode;
    }
    ;
    set blendMode(value) {
        this.blend = (value !== BlendModesSettings_1.BlendModesSettings.BLEND_MODES.NONE);
        this._blendMode = value;
    }
    ;
    /**
     * The polygon offset. Setting this property to anything other than 0 will automatically enable polygon offset fill.
     *
     * @member {number}
     * @default 0
     */
    get polygonOffset() {
        return this._polygonOffset;
    }
    ;
    set polygonOffset(value) {
        this.offsets = !!value;
        this._polygonOffset = value;
    }
    ;
    static for2d() {
        var state = new State();
        state.depthTest = false;
        state.blend = true;
        return state;
    }
    ;
}
State.BLEND = 0;
State.OFFSET = 1;
State.CULLING = 2;
State.DEPTH_TEST = 3;
State.WINDING = 4;
exports.State = State;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/StateSystem.js":
/*!***********************************************!*\
  !*** ./js-compile/raw-pixi-ts/StateSystem.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const System_1 = __webpack_require__(/*! ./System */ "./js-compile/raw-pixi-ts/System.js");
const State_1 = __webpack_require__(/*! ./State */ "./js-compile/raw-pixi-ts/State.js");
const BlendModesSettings_1 = __webpack_require__(/*! ./BlendModesSettings */ "./js-compile/raw-pixi-ts/BlendModesSettings.js");
class StateSystem extends System_1.System {
    constructor(renderer) {
        super(renderer);
        /**
         * GL context
         * @member {WebGLRenderingContext}
         * @readonly
         */
        this.gl = null;
        /**
         * State ID
         * @member {number}
         * @readonly
         */
        this.stateId = 0;
        /**
         * Polygon offset
         * @member {number}
         * @readonly
         */
        this.polygonOffset = 0;
        /**
         * Blend mode
         * @member {number}
         * @default PIXI.BLEND_MODES.NONE
         * @readonly
         */
        this.blendMode = BlendModesSettings_1.BlendModesSettings.BLEND_MODES.NONE;
        /**
         * Whether current blend equation is different
         * @member {boolean}
         * @protected
         */
        this._blendEq = false;
        /**
         * Collection of calls
         * @member {function[]}
         * @readonly
         */
        this.map = [];
        // map functions for when we set state..
        this.map[StateSystem.BLEND$1] = this.setBlend;
        this.map[StateSystem.OFFSET$1] = this.setOffset;
        this.map[StateSystem.CULLING$1] = this.setCullFace;
        this.map[StateSystem.DEPTH_TEST$1] = this.setDepthTest;
        this.map[StateSystem.WINDING$1] = this.setFrontFace;
        /**
         * Collection of check calls
         * @member {function[]}
         * @readonly
         */
        this.checks = [];
        /**
         * Default WebGL State
         * @member {PIXI.State}
         * @readonly
         */
        this.defaultState = new State_1.State();
        this.defaultState.blend = true;
        this.defaultState.depth = true;
    }
    contextChange(gl) {
        this.gl = gl;
        this.blendModes = BlendModesSettings_1.BlendModesSettings.mapWebGLBlendModesToPixi(gl);
        this.setState(this.defaultState);
        this.reset();
    }
    ;
    /**
     * Sets the current state
     *
     * @param {*} state - The state to set.
     */
    setState(state) {
        state = state || this.defaultState;
        // TODO maybe to an object check? ( this.state === state )?
        if (this.stateId !== state.data) {
            var diff = this.stateId ^ state.data;
            var i = 0;
            // order from least to most common
            while (diff) {
                if (diff & 1) {
                    // state change!
                    this.map[i].call(this, !!(state.data & (1 << i)));
                }
                diff = diff >> 1;
                i++;
            }
            this.stateId = state.data;
        }
        // based on the above settings we check for specific modes..
        // for example if blend is active we check and set the blend modes
        // or of polygon offset is active we check the poly depth.
        for (var i$1 = 0; i$1 < this.checks.length; i$1++) {
            this.checks[i$1](this, state);
        }
    }
    ;
    /**
     * Sets the state, when previous state is unknown
     *
     * @param {*} state - The state to set
     */
    forceState(state) {
        state = state || this.defaultState;
        for (var i = 0; i < this.map.length; i++) {
            this.map[i].call(this, !!(state.data & (1 << i)));
        }
        for (var i$1 = 0; i$1 < this.checks.length; i$1++) {
            this.checks[i$1](this, state);
        }
        this.stateId = state.data;
    }
    ;
    /**
     * Enables or disabled blending.
     *
     * @param {boolean} value - Turn on or off webgl blending.
     */
    setBlend(value) {
        this.updateCheck(StateSystem.checkBlendMode, value);
        this.gl[value ? 'enable' : 'disable'](this.gl.BLEND);
    }
    ;
    /**
     * Enables or disable polygon offset fill
     *
     * @param {boolean} value - Turn on or off webgl polygon offset testing.
     */
    setOffset(value) {
        this.gl[value ? 'enable' : 'disable'](this.gl.POLYGON_OFFSET_FILL);
    }
    ;
    /**
     * Sets whether to enable or disable depth test.
     *
     * @param {boolean} value - Turn on or off webgl depth testing.
     */
    setDepthTest(value) {
        this.gl[value ? 'enable' : 'disable'](this.gl.DEPTH_TEST);
    }
    ;
    /**
     * Sets whether to enable or disable cull face.
     *
     * @param {boolean} value - Turn on or off webgl cull face.
     */
    setCullFace(value) {
        this.gl[value ? 'enable' : 'disable'](this.gl.CULL_FACE);
    }
    ;
    /**
     * Sets the gl front face.
     *
     * @param {boolean} value - true is clockwise and false is counter-clockwise
     */
    setFrontFace(value) {
        this.gl.frontFace(this.gl[value ? 'CW' : 'CCW']);
    }
    ;
    /**
     * Sets the blend mode.
     *
     * @param {number} value - The blend mode to set to.
     */
    setBlendMode(value) {
        if (value === this.blendMode) {
            return;
        }
        this.blendMode = value;
        var mode = this.blendModes[value];
        var gl = this.gl;
        if (mode.length === 2) {
            gl.blendFunc(mode[0], mode[1]);
        }
        else {
            gl.blendFuncSeparate(mode[0], mode[1], mode[2], mode[3]);
        }
        if (mode.length === 6) {
            this._blendEq = true;
            gl.blendEquationSeparate(mode[4], mode[5]);
        }
        else if (this._blendEq) {
            this._blendEq = false;
            gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
        }
    }
    ;
    /**
     * Sets the polygon offset.
     *
     * @param {number} value - the polygon offset
     * @param {number} scale - the polygon offset scale
     */
    setPolygonOffset(value, scale) {
        this.gl.polygonOffset(value, scale);
    }
    ;
    // used
    /**
     * Resets all the logic and disables the vaos
     */
    reset() {
        this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, false);
        this.forceState(0);
        this._blendEq = true;
        this.blendMode = -1;
        this.setBlendMode(0);
    }
    ;
    /**
     * checks to see which updates should be checked based on which settings have been activated.
     * For example, if blend is enabled then we should check the blend modes each time the state is changed
     * or if polygon fill is activated then we need to check if the polygon offset changes.
     * The idea is that we only check what we have too.
     *
     * @param {Function} func  the checking function to add or remove
     * @param {boolean} value  should the check function be added or removed.
     */
    updateCheck(func, value) {
        var index = this.checks.indexOf(func);
        if (value && index === -1) {
            this.checks.push(func);
        }
        else if (!value && index !== -1) {
            this.checks.splice(index, 1);
        }
    }
    ;
    /**
     * A private little wrapper function that we call to check the blend mode.
     *
     * @static
     * @private
     * @param {PIXI.StateSystem} System  the System to perform the state check on
     * @param {PIXI.State} state  the state that the blendMode will pulled from
     */
    static checkBlendMode(system, state) {
        system.setBlendMode(state.blendMode);
    }
    ;
}
StateSystem.UID$4 = 0;
StateSystem.BLEND$1 = 0;
StateSystem.OFFSET$1 = 1;
StateSystem.CULLING$1 = 2;
StateSystem.DEPTH_TEST$1 = 3;
StateSystem.WINDING$1 = 4;
exports.StateSystem = StateSystem;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/StencilSystem.js":
/*!*************************************************!*\
  !*** ./js-compile/raw-pixi-ts/StencilSystem.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const System_1 = __webpack_require__(/*! ./System */ "./js-compile/raw-pixi-ts/System.js");
class StencilSystem extends System_1.System {
    constructor(renderer) {
        super(renderer);
        this.stencilMaskStack = [];
    }
    /**
     * Changes the mask stack that is used by this System.
     *
     * @param {PIXI.Graphics[]} stencilMaskStack - The mask stack
     */
    setMaskStack(stencilMaskStack) {
        var gl = this.renderer.gl;
        if (stencilMaskStack.length !== this.stencilMaskStack.length) {
            if (stencilMaskStack.length === 0) {
                gl.disable(gl.STENCIL_TEST);
            }
            else {
                gl.enable(gl.STENCIL_TEST);
            }
        }
        this.stencilMaskStack = stencilMaskStack;
    }
    ;
    /**
     * Applies the Mask and adds it to the current stencil stack. @alvin
     *
     * @param {PIXI.Graphics} graphics - The mask
     */
    pushStencil(graphics) {
        var gl = this.renderer.gl;
        var prevMaskCount = this.stencilMaskStack.length;
        if (prevMaskCount === 0) {
            gl.enable(gl.STENCIL_TEST);
        }
        this.stencilMaskStack.push(graphics);
        // Increment the reference stencil value where the new mask overlaps with the old ones.
        gl.colorMask(false, false, false, false);
        gl.stencilFunc(gl.EQUAL, prevMaskCount, this._getBitwiseMask());
        gl.stencilOp(gl.KEEP, gl.KEEP, gl.INCR);
        graphics.renderable = true;
        graphics.render(this.renderer);
        this.renderer.batch.flush();
        graphics.renderable = false;
        this._useCurrent();
    }
    ;
    /**
     * Removes the last mask from the stencil stack. @alvin
     */
    popStencil() {
        var gl = this.renderer.gl;
        var graphics = this.stencilMaskStack.pop();
        if (this.stencilMaskStack.length === 0) {
            // the stack is empty!
            gl.disable(gl.STENCIL_TEST);
            gl.clear(gl.STENCIL_BUFFER_BIT);
            gl.clearStencil(0);
        }
        else {
            // Decrement the reference stencil value where the popped mask overlaps with the other ones
            gl.colorMask(false, false, false, false);
            gl.stencilOp(gl.KEEP, gl.KEEP, gl.DECR);
            graphics.renderable = true;
            graphics.render(this.renderer);
            this.renderer.batch.flush();
            graphics.renderable = false;
            this._useCurrent();
        }
    }
    ;
    /**
     * Setup renderer to use the current stencil data.
     * @private
     */
    _useCurrent() {
        var gl = this.renderer.gl;
        gl.colorMask(true, true, true, true);
        gl.stencilFunc(gl.EQUAL, this.stencilMaskStack.length, this._getBitwiseMask());
        gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
    }
    ;
    /**
     * Fill 1s equal to the number of acitve stencil masks.
     * @private
     * @return {number} The bitwise mask.
     */
    _getBitwiseMask() {
        return (1 << this.stencilMaskStack.length) - 1;
    }
    ;
    /**
     * Destroys the mask stack.
     *
     */
    destroy() {
        super.destroy();
        this.stencilMaskStack = null;
    }
    ;
}
exports.StencilSystem = StencilSystem;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/System.js":
/*!******************************************!*\
  !*** ./js-compile/raw-pixi-ts/System.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const EventDispatcher_1 = __webpack_require__(/*! ./EventDispatcher */ "./js-compile/raw-pixi-ts/EventDispatcher.js");
class System extends EventDispatcher_1.EventDispatcher {
    constructor(renderer = null) {
        super();
        this.renderer = renderer;
        this.renderer.runners.contextChange.add(this);
    }
    contextChange(gl) {
    }
    ;
    destroy(options = null) {
        this.renderer.runners.contextChange.remove(this);
        this.renderer = null;
    }
    ;
}
exports.System = System;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/Text.js":
/*!****************************************!*\
  !*** ./js-compile/raw-pixi-ts/Text.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Sprite_1 = __webpack_require__(/*! ./Sprite */ "./js-compile/raw-pixi-ts/Sprite.js");
const Texture_1 = __webpack_require__(/*! ./Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const Rectangle_1 = __webpack_require__(/*! ./Rectangle */ "./js-compile/raw-pixi-ts/Rectangle.js");
const TextMetrics_1 = __webpack_require__(/*! ./TextMetrics */ "./js-compile/raw-pixi-ts/TextMetrics.js");
const TextStyle_1 = __webpack_require__(/*! ./TextStyle */ "./js-compile/raw-pixi-ts/TextStyle.js");
const DisplaySettings_1 = __webpack_require__(/*! ./DisplaySettings */ "./js-compile/raw-pixi-ts/DisplaySettings.js");
const MathSettings_1 = __webpack_require__(/*! ./MathSettings */ "./js-compile/raw-pixi-ts/MathSettings.js");
const CanvasSettings_1 = __webpack_require__(/*! ./CanvasSettings */ "./js-compile/raw-pixi-ts/CanvasSettings.js");
const TextSettings_1 = __webpack_require__(/*! ./TextSettings */ "./js-compile/raw-pixi-ts/TextSettings.js");
const CleanUpSettings_1 = __webpack_require__(/*! ./CleanUpSettings */ "./js-compile/raw-pixi-ts/CleanUpSettings.js");
const ColorSettings_1 = __webpack_require__(/*! ./ColorSettings */ "./js-compile/raw-pixi-ts/ColorSettings.js");
class Text extends Sprite_1.Sprite {
    constructor(text, style = null, canvas = null) {
        canvas = canvas || document.createElement('canvas');
        canvas.width = 3;
        canvas.height = 3;
        var texture = Texture_1.Texture.from(canvas);
        texture.orig = new Rectangle_1.Rectangle();
        texture.trim = new Rectangle_1.Rectangle();
        super(texture);
        /**
         * The canvas element that everything is drawn to
         *
         * @member {HTMLCanvasElement}
         */
        this.canvas = canvas;
        /**
         * The canvas 2d context that everything is drawn with
         * @member {CanvasRenderingContext2D}
         */
        this.context = this.canvas.getContext('2d');
        /**
         * The resolution / device pixel ratio of the canvas.
         * This is set to automatically match the renderer resolution by default, but can be overridden by setting manually.
         * @member {number}
         * @default 1
         */
        this._resolution = DisplaySettings_1.DisplaySettings.RESOLUTION;
        this._autoResolution = true;
        /**
         * Private tracker for the current text.
         *
         * @member {string}
         * @private
         */
        this._text = null;
        /**
         * Private tracker for the current style.
         *
         * @member {object}
         * @private
         */
        this._style = null;
        /**
         * Private listener to track style changes.
         *
         * @member {Function}
         * @private
         */
        this._styleListener = null;
        /**
         * Private tracker for the current font.
         *
         * @member {string}
         * @private
         */
        this._font = '';
        this.text = text;
        this.style = style;
        this.localStyleID = -1;
    }
    /**
     * Renders text and updates it when needed.
     *
     * @private
     * @param {boolean} respectDirty - Whether to abort updating the text if the Text isn't dirty and the function is called.
     */
    updateText(respectDirty) {
        var style = this._style;
        // check if style has changed..
        if (this.localStyleID !== style.styleID) {
            this.dirty = true;
            this.localStyleID = style.styleID;
        }
        if (!this.dirty && respectDirty) {
            return;
        }
        this._font = this._style.toFontString();
        var context = this.context;
        TextMetrics_1.TextMetrics.init();
        var measured = TextMetrics_1.TextMetrics.measureText(this._text || ' ', this._style, this._style.wordWrap, this.canvas);
        var width = measured.width;
        var height = measured.height;
        var lines = measured.lines;
        var lineHeight = measured.lineHeight;
        var lineWidths = measured.lineWidths;
        var maxLineWidth = measured.maxLineWidth;
        var fontProperties = measured.fontProperties;
        this.canvas.width = Math.ceil((Math.max(1, width) + (style.padding * 2)) * this._resolution);
        this.canvas.height = Math.ceil((Math.max(1, height) + (style.padding * 2)) * this._resolution);
        context.scale(this._resolution, this._resolution);
        context.clearRect(0, 0, this.canvas.width, this.canvas.height);
        context.font = this._font;
        context.strokeStyle = style.stroke;
        context.lineWidth = style.strokeThickness;
        context.textBaseline = style.textBaseline;
        context.lineJoin = style.lineJoin;
        context.miterLimit = style.miterLimit;
        var linePositionX;
        var linePositionY;
        if (style.dropShadow) {
            var dropShadowColor = style.dropShadowColor;
            var rgb = ColorSettings_1.ColorSettings.hex2rgb(typeof dropShadowColor === 'number' ? dropShadowColor : MathSettings_1.MathSettings.string2hex(dropShadowColor));
            context.shadowColor = "rgba(" + (rgb[0] * 255) + "," + (rgb[1] * 255) + "," + (rgb[2] * 255) + "," + (style.dropShadowAlpha) + ")";
            context.shadowBlur = style.dropShadowBlur;
            context.shadowOffsetX = Math.cos(style.dropShadowAngle) * style.dropShadowDistance;
            context.shadowOffsetY = Math.sin(style.dropShadowAngle) * style.dropShadowDistance;
        }
        else {
            context.shadowColor = 0;
            context.shadowBlur = 0;
            context.shadowOffsetX = 0;
            context.shadowOffsetY = 0;
        }
        // set canvas text styles
        context.fillStyle = this._generateFillStyle(style, lines);
        // draw lines line by line
        for (var i = 0; i < lines.length; i++) {
            linePositionX = style.strokeThickness / 2;
            linePositionY = ((style.strokeThickness / 2) + (i * lineHeight)) + fontProperties.ascent;
            if (style.align === 'right') {
                linePositionX += maxLineWidth - lineWidths[i];
            }
            else if (style.align === 'center') {
                linePositionX += (maxLineWidth - lineWidths[i]) / 2;
            }
            if (style.stroke && style.strokeThickness) {
                this.drawLetterSpacing(lines[i], linePositionX + style.padding, linePositionY + style.padding, true);
            }
            if (style.fill) {
                this.drawLetterSpacing(lines[i], linePositionX + style.padding, linePositionY + style.padding);
            }
        }
        this.updateTexture();
    }
    ;
    /**
     * Render the text with letter-spacing.
     * @param {string} text - The text to draw
     * @param {number} x - Horizontal position to draw the text
     * @param {number} y - Vertical position to draw the text
     * @param {boolean} [isStroke=false] - Is this drawing for the outside stroke of the
     *  text? If not, it's for the inside fill
     * @private
     */
    drawLetterSpacing(text, x, y, isStroke = false) {
        if (isStroke === void 0) {
            isStroke = false;
        }
        var style = this._style;
        // letterSpacing of 0 means normal
        var letterSpacing = style.letterSpacing;
        if (letterSpacing === 0) {
            if (isStroke) {
                this.context.strokeText(text, x, y);
            }
            else {
                this.context.fillText(text, x, y);
            }
            return;
        }
        var characters = String.prototype.split.call(text, '');
        var currentPosition = x;
        var index = 0;
        var current = '';
        while (index < text.length) {
            current = characters[index++];
            if (isStroke) {
                this.context.strokeText(current, currentPosition, y);
            }
            else {
                this.context.fillText(current, currentPosition, y);
            }
            currentPosition += this.context.measureText(current).width + letterSpacing;
        }
    }
    ;
    /**
     * Updates texture size based on canvas size
     *
     * @private
     */
    updateTexture() {
        var canvas = this.canvas;
        if (this._style.trim) {
            var trimmed = CanvasSettings_1.CanvasSettings.trimCanvas(canvas);
            if (trimmed.data) {
                canvas.width = trimmed.width;
                canvas.height = trimmed.height;
                this.context.putImageData(trimmed.data, 0, 0);
            }
        }
        var texture = this._texture;
        var style = this._style;
        var padding = style.trim ? 0 : style.padding;
        var baseTexture = texture.baseTexture;
        texture.trim.width = texture._frame.width = canvas.width / this._resolution;
        texture.trim.height = texture._frame.height = canvas.height / this._resolution;
        texture.trim.x = -padding;
        texture.trim.y = -padding;
        texture.orig.width = texture._frame.width - (padding * 2);
        texture.orig.height = texture._frame.height - (padding * 2);
        // call sprite onTextureUpdate to update scale if _width or _height were set
        this._onTextureUpdate();
        baseTexture.setRealSize(canvas.width, canvas.height, this._resolution);
        this.dirty = false;
    }
    ;
    /**
     * Renders the object using the WebGL renderer
     *
     * @param {PIXI.Renderer} renderer - The renderer
     */
    render(renderer) {
        if (this._autoResolution && this._resolution !== renderer.resolution) {
            this._resolution = renderer.resolution;
            this.dirty = true;
        }
        this.updateText(true);
        super.render(renderer);
    }
    ;
    /**
     * Renders the object using the Canvas renderer
     *
     * @private
     * @param {PIXI.CanvasRenderer} renderer - The renderer
     */
    _renderCanvas(renderer) {
        if (this._autoResolution && this._resolution !== renderer.resolution) {
            this._resolution = renderer.resolution;
            this.dirty = true;
        }
        this.updateText(true);
        // super._renderCanvas(renderer);
    }
    ;
    /**
     * Gets the local bounds of the text object.
     *
     * @param {Rectangle} rect - The output rectangle.
     * @return {Rectangle} The bounds.
     */
    getLocalBounds(rect) {
        this.updateText(true);
        return super.getLocalBounds(rect);
    }
    ;
    /**
     * calculates the bounds of the Text as a rectangle. The bounds calculation takes the worldTransform into account.
     * @protected
     */
    _calculateBounds() {
        this.updateText(true);
        this.calculateVertices();
        // if we have already done this on THIS frame.
        this._bounds.addQuad(this.vertexData);
    }
    ;
    /**
     * Method to be called upon a TextStyle change.
     * @private
     */
    _onStyleChange() {
        this.dirty = true;
    }
    ;
    /**
     * Generates the fill style. Can automatically generate a gradient based on the fill style being an array
     *
     * @private
     * @param {object} style - The style.
     * @param {string[]} lines - The lines of text.
     * @return {string|number|CanvasGradient} The fill style
     */
    _generateFillStyle(style, lines) {
        if (!Array.isArray(style.fill)) {
            return style.fill;
        }
        // the gradient will be evenly spaced out according to how large the array is.
        // ['#FF0000', '#00FF00', '#0000FF'] would created stops at 0.25, 0.5 and 0.75
        var gradient;
        var totalIterations;
        var currentIteration;
        var stop;
        var width = this.canvas.width / this._resolution;
        var height = this.canvas.height / this._resolution;
        // make a copy of the style settings, so we can manipulate them later
        var fill = style.fill.slice();
        var fillGradientStops = style.fillGradientStops.slice();
        // wanting to evenly distribute the fills. So an array of 4 colours should give fills of 0.25, 0.5 and 0.75
        if (!fillGradientStops.length) {
            var lengthPlus1 = fill.length + 1;
            for (var i = 1; i < lengthPlus1; ++i) {
                fillGradientStops.push(i / lengthPlus1);
            }
        }
        // stop the bleeding of the last gradient on the line above to the top gradient of the this line
        // by hard defining the first gradient colour at point 0, and last gradient colour at point 1
        fill.unshift(style.fill[0]);
        fillGradientStops.unshift(0);
        fill.push(style.fill[style.fill.length - 1]);
        fillGradientStops.push(1);
        if (style.fillGradientType === TextSettings_1.TextSettings.TEXT_GRADIENT.LINEAR_VERTICAL) {
            // start the gradient at the top center of the canvas, and end at the bottom middle of the canvas
            gradient = this.context.createLinearGradient(width / 2, 0, width / 2, height);
            // we need to repeat the gradient so that each individual line of text has the same vertical gradient effect
            // ['#FF0000', '#00FF00', '#0000FF'] over 2 lines would create stops at 0.125, 0.25, 0.375, 0.625, 0.75, 0.875
            totalIterations = (fill.length + 1) * lines.length;
            currentIteration = 0;
            for (var i$1 = 0; i$1 < lines.length; i$1++) {
                currentIteration += 1;
                for (var j = 0; j < fill.length; j++) {
                    if (typeof fillGradientStops[j] === 'number') {
                        stop = (fillGradientStops[j] / lines.length) + (i$1 / lines.length);
                    }
                    else {
                        stop = currentIteration / totalIterations;
                    }
                    gradient.addColorStop(stop, fill[j]);
                    currentIteration++;
                }
            }
        }
        else {
            // start the gradient at the center left of the canvas, and end at the center right of the canvas
            gradient = this.context.createLinearGradient(0, height / 2, width, height / 2);
            // can just evenly space out the gradients in this case, as multiple lines makes no difference
            // to an even left to right gradient
            totalIterations = fill.length + 1;
            currentIteration = 1;
            for (var i$2 = 0; i$2 < fill.length; i$2++) {
                if (typeof fillGradientStops[i$2] === 'number') {
                    stop = fillGradientStops[i$2];
                }
                else {
                    stop = currentIteration / totalIterations;
                }
                gradient.addColorStop(stop, fill[i$2]);
                currentIteration++;
            }
        }
        return gradient;
    }
    ;
    /**
     * Destroys this text object.
     * Note* Unlike a Sprite, a Text object will automatically destroy its baseTexture and texture as
     * the majority of the time the texture will not be shared with any other Sprites.
     *
     * @param {object|boolean} [options] - Options parameter. A boolean will act as if all options
     *  have been set to that value
     * @param {boolean} [options.children=false] - if set to true, all the children will have their
     *  destroy method called as well. 'options' will be passed on to those calls.
     * @param {boolean} [options.texture=true] - Should it destroy the current texture of the sprite as well
     * @param {boolean} [options.baseTexture=true] - Should it destroy the base texture of the sprite as well
     */
    destroy(options) {
        if (typeof options === 'boolean') {
            options = { children: options };
        }
        options = Object.assign({}, CleanUpSettings_1.CleanUpSettings.defaultDestroyOptions, options);
        super.destroy(options);
        // make sure to reset the the context and canvas.. dont want this hanging around in memory!
        this.context = null;
        this.canvas = null;
        this._style = null;
    }
    ;
    /**
     * The width of the Text, setting this will actually modify the scale to achieve the value set
     *
     * @member {number}
     */
    get width() {
        this.updateText(true);
        return Math.abs(this.scale.x) * this._texture.orig.width;
    }
    ;
    set width(value) {
        this.updateText(true);
        var s = MathSettings_1.MathSettings.sign(this.scale.x) || 1;
        this.scale.x = s * value / this._texture.orig.width;
        this._width = value;
    }
    ;
    /**
     * The height of the Text, setting this will actually modify the scale to achieve the value set
     *
     * @member {number}
     */
    get height() {
        this.updateText(true);
        return Math.abs(this.scale.y) * this._texture.orig.height;
    }
    ;
    set height(value) {
        this.updateText(true);
        var s = MathSettings_1.MathSettings.sign(this.scale.y) || 1;
        this.scale.y = s * value / this._texture.orig.height;
        this._height = value;
    }
    ;
    /**
     * Set the style of the text. Set up an event listener to listen for changes on the style
     * object and mark the text as dirty.
     *
     * @member {object|PIXI.TextStyle}
     */
    get style() {
        return this._style;
    }
    ;
    set style(style) {
        style = style || {};
        if (style instanceof TextStyle_1.TextStyle) {
            this._style = style;
        }
        else {
            this._style = new TextStyle_1.TextStyle(style);
        }
        this.localStyleID = -1;
        this.dirty = true;
    }
    ;
    /**
     * Set the copy for the text object. To split a line you can use '\n'.
     *
     * @member {string}
     */
    get text() {
        return this._text;
    }
    ;
    set text(text) {
        text = String(text === null || text === undefined ? '' : text);
        if (this._text === text) {
            return;
        }
        this._text = text;
        this.dirty = true;
    }
    ;
    /**
     * The resolution / device pixel ratio of the canvas.
     * This is set to automatically match the renderer resolution by default, but can be overridden by setting manually.
     * @member {number}
     * @default 1
     */
    get resolution() {
        return this._resolution;
    }
    ;
    set resolution(value) {
        this._autoResolution = false;
        if (this._resolution === value) {
            return;
        }
        this._resolution = value;
        this.dirty = true;
    }
    ;
}
exports.Text = Text;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/TextMetrics.js":
/*!***********************************************!*\
  !*** ./js-compile/raw-pixi-ts/TextMetrics.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class TextMetrics {
    constructor(text, style, width, height, lines, lineWidths, lineHeight, maxLineWidth, fontProperties) {
        if (!TextMetrics.canvas) {
            TextMetrics.canvas = document.createElement('canvas');
            TextMetrics.canvas.width = TextMetrics.canvas.height = 10;
            TextMetrics._canvas = TextMetrics.canvas;
            TextMetrics._context = TextMetrics.canvas.getContext('2d');
        }
        this.text = text;
        this.style = style;
        this.width = width;
        this.height = height;
        this.lines = lines;
        this.lineWidths = lineWidths;
        this.lineHeight = lineHeight;
        this.maxLineWidth = maxLineWidth;
        this.fontProperties = fontProperties;
    }
    static init() {
        if (!TextMetrics.canvas) {
            TextMetrics.canvas = document.createElement('canvas');
            TextMetrics.canvas.width = TextMetrics.canvas.height = 10;
            TextMetrics._canvas = TextMetrics.canvas;
            TextMetrics._context = TextMetrics.canvas.getContext('2d');
        }
    }
    /**
     * Measures the supplied string of text and returns a Rectangle.
     *
     * @param {string} text - the text to measure.
     * @param {PIXI.TextStyle} style - the text style to use for measuring
     * @param {boolean} [wordWrap] - optional override for if word-wrap should be applied to the text.
     * @param {HTMLCanvasElement} [canvas] - optional specification of the canvas to use for measuring.
     * @return {PIXI.TextMetrics} measured width and height of the text.
     */
    static measureText(text, style, wordWrap, canvas = TextMetrics._canvas) {
        wordWrap = (wordWrap === undefined || wordWrap === null) ? style.wordWrap : wordWrap;
        var font = style.toFontString();
        var fontProperties = TextMetrics.measureFont(font);
        // fallback in case UA disallow canvas data extraction
        // (toDataURI, getImageData functions)
        if (fontProperties.fontSize === 0) {
            fontProperties.fontSize = style.fontSize;
            fontProperties.ascent = style.fontSize;
        }
        var context = canvas.getContext('2d');
        context.font = font;
        var outputText = wordWrap ? TextMetrics.wordWrap(text, style, canvas) : text;
        var lines = outputText.split(/(?:\r\n|\r|\n)/);
        var lineWidths = new Array(lines.length);
        var maxLineWidth = 0;
        for (var i = 0; i < lines.length; i++) {
            var lineWidth = context.measureText(lines[i]).width + ((lines[i].length - 1) * style.letterSpacing);
            lineWidths[i] = lineWidth;
            maxLineWidth = Math.max(maxLineWidth, lineWidth);
        }
        var width = maxLineWidth + style.strokeThickness;
        if (style.dropShadow) {
            width += style.dropShadowDistance;
        }
        var lineHeight = style.lineHeight || fontProperties.fontSize + style.strokeThickness;
        var height = Math.max(lineHeight, fontProperties.fontSize + style.strokeThickness)
            + ((lines.length - 1) * (lineHeight + style.leading));
        if (style.dropShadow) {
            height += style.dropShadowDistance;
        }
        return new TextMetrics(text, style, width, height, lines, lineWidths, lineHeight + style.leading, maxLineWidth, fontProperties);
    }
    ;
    /**
     * Applies newlines to a string to have it optimally fit into the horizontal
     * bounds set by the Text object's wordWrapWidth property.
     *
     * @private
     * @param {string} text - String to apply word wrapping to
     * @param {PIXI.TextStyle} style - the style to use when wrapping
     * @param {HTMLCanvasElement} [canvas] - optional specification of the canvas to use for measuring.
     * @return {string} New string with new lines applied where required
     */
    static wordWrap(text, style, canvas) {
        if (canvas === void 0) {
            canvas = TextMetrics._canvas;
        }
        var context = canvas.getContext('2d');
        var width = 0;
        var line = '';
        var lines = '';
        var cache = {};
        var letterSpacing = style.letterSpacing;
        var whiteSpace = style.whiteSpace;
        // How to handle whitespaces
        var collapseSpaces = TextMetrics.collapseSpaces(whiteSpace);
        var collapseNewlines = TextMetrics.collapseNewlines(whiteSpace);
        // whether or not spaces may be added to the beginning of lines
        var canPrependSpaces = !collapseSpaces;
        // There is letterSpacing after every char except the last one
        // t_h_i_s_' '_i_s_' '_a_n_' '_e_x_a_m_p_l_e_' '_!
        // so for convenience the above needs to be compared to width + 1 extra letterSpace
        // t_h_i_s_' '_i_s_' '_a_n_' '_e_x_a_m_p_l_e_' '_!_
        // ________________________________________________
        // And then the final space is simply no appended to each line
        var wordWrapWidth = style.wordWrapWidth + letterSpacing;
        // break text into words, spaces and newline chars
        var tokens = TextMetrics.tokenize(text);
        for (var i = 0; i < tokens.length; i++) {
            // get the word, space or newlineChar
            var token = tokens[i];
            // if word is a new line
            if (TextMetrics.isNewline(token)) {
                // keep the new line
                if (!collapseNewlines) {
                    lines += TextMetrics.addLine(line);
                    canPrependSpaces = !collapseSpaces;
                    line = '';
                    width = 0;
                    continue;
                }
                // if we should collapse new lines
                // we simply convert it into a space
                token = ' ';
            }
            // if we should collapse repeated whitespaces
            if (collapseSpaces) {
                // check both this and the last tokens for spaces
                var currIsBreakingSpace = TextMetrics.isBreakingSpace(token);
                var lastIsBreakingSpace = TextMetrics.isBreakingSpace(line[line.length - 1]);
                if (currIsBreakingSpace && lastIsBreakingSpace) {
                    continue;
                }
            }
            // get word width from cache if possible
            var tokenWidth = TextMetrics.getFromCache(token, letterSpacing, cache, context);
            // word is longer than desired bounds
            if (tokenWidth > wordWrapWidth) {
                // if we are not already at the beginning of a line
                if (line !== '') {
                    // start newlines for overflow words
                    lines += TextMetrics.addLine(line);
                    line = '';
                    width = 0;
                }
                // break large word over multiple lines
                if (TextMetrics.canBreakWords(token, style.breakWords)) {
                    // break word into characters
                    var characters = token.split('');
                    // loop the characters
                    for (var j = 0; j < characters.length; j++) {
                        var char = characters[j];
                        var k = 1;
                        // we are not at the end of the token
                        while (characters[j + k]) {
                            var nextChar = characters[j + k];
                            var lastChar = char[char.length - 1];
                            // should not split chars
                            if (!TextMetrics.canBreakChars(lastChar, nextChar, token, j, style.breakWords)) {
                                // combine chars & move forward one
                                char += nextChar;
                            }
                            else {
                                break;
                            }
                            k++;
                        }
                        j += char.length - 1;
                        var characterWidth = TextMetrics.getFromCache(char, letterSpacing, cache, context);
                        if (characterWidth + width > wordWrapWidth) {
                            lines += TextMetrics.addLine(line);
                            canPrependSpaces = false;
                            line = '';
                            width = 0;
                        }
                        line += char;
                        width += characterWidth;
                    }
                }
                // run word out of the bounds
                else {
                    // if there are words in this line already
                    // finish that line and start a new one
                    if (line.length > 0) {
                        lines += TextMetrics.addLine(line);
                        line = '';
                        width = 0;
                    }
                    var isLastToken = i === tokens.length - 1;
                    // give it its own line if it's not the end
                    lines += TextMetrics.addLine(token, !isLastToken);
                    canPrependSpaces = false;
                    line = '';
                    width = 0;
                }
            }
            // word could fit
            else {
                // word won't fit because of existing words
                // start a new line
                if (tokenWidth + width > wordWrapWidth) {
                    // if its a space we don't want it
                    canPrependSpaces = false;
                    // add a new line
                    lines += TextMetrics.addLine(line);
                    // start a new line
                    line = '';
                    width = 0;
                }
                // don't add spaces to the beginning of lines
                if (line.length > 0 || !TextMetrics.isBreakingSpace(token) || canPrependSpaces) {
                    // add the word to the current line
                    line += token;
                    // update width counter
                    width += tokenWidth;
                }
            }
        }
        lines += TextMetrics.addLine(line, false);
        return lines;
    }
    ;
    /**
     * Convienience function for logging each line added during the wordWrap
     * method
     *
     * @private
     * @param  {string}   line    - The line of text to add
     * @param  {boolean}  newLine - Add new line character to end
     * @return {string}   A formatted line
     */
    static addLine(line, newLine = true) {
        if (newLine === void 0) {
            newLine = true;
        }
        line = TextMetrics.trimRight(line);
        line = (newLine) ? (line + "\n") : line;
        return line;
    }
    ;
    /**
     * Gets & sets the widths of calculated characters in a cache object
     *
     * @private
     * @param  {string}                key        The key
     * @param  {number}                letterSpacing  The letter spacing
     * @param  {object}                cache      The cache
     * @param  {CanvasRenderingContext2D}  context    The canvas context
     * @return {number}                The from cache.
     */
    static getFromCache(key, letterSpacing, cache, context) {
        var width = cache[key];
        if (width === undefined) {
            var spacing = ((key.length) * letterSpacing);
            width = context.measureText(key).width + spacing;
            cache[key] = width;
        }
        return width;
    }
    ;
    /**
     * Determines whether we should collapse breaking spaces
     *
     * @private
     * @param  {string}   whiteSpace  The TextStyle property whiteSpace
     * @return {boolean}  should collapse
     */
    static collapseSpaces(whiteSpace) {
        return (whiteSpace === 'normal' || whiteSpace === 'pre-line');
    }
    ;
    /**
     * Determines whether we should collapse newLine chars
     *
     * @private
     * @param  {string}   whiteSpace  The white space
     * @return {boolean}  should collapse
     */
    static collapseNewlines(whiteSpace) {
        return (whiteSpace === 'normal');
    }
    ;
    /**
     * trims breaking whitespaces from string
     *
     * @private
     * @param  {string}  text  The text
     * @return {string}  trimmed string
     */
    static trimRight(text) {
        if (typeof text !== 'string') {
            return '';
        }
        for (var i = text.length - 1; i >= 0; i--) {
            var char = text[i];
            if (!TextMetrics.isBreakingSpace(char)) {
                break;
            }
            text = text.slice(0, -1);
        }
        return text;
    }
    ;
    /**
     * Determines if char is a newline.
     *
     * @private
     * @param  {string}  char  The character
     * @return {boolean}  True if newline, False otherwise.
     */
    static isNewline(char) {
        if (typeof char !== 'string') {
            return false;
        }
        return (TextMetrics._newlines.indexOf(char.charCodeAt(0)) >= 0);
    }
    ;
    /**
     * Determines if char is a breaking whitespace.
     *
     * @private
     * @param  {string}  char  The character
     * @return {boolean}  True if whitespace, False otherwise.
     */
    static isBreakingSpace(char) {
        if (typeof char !== 'string') {
            return false;
        }
        return (TextMetrics._breakingSpaces.indexOf(char.charCodeAt(0)) >= 0);
    }
    ;
    /**
     * Splits a string into words, breaking-spaces and newLine characters
     *
     * @private
     * @param  {string}  text   The text
     * @return {string[]}  A tokenized array
     */
    static tokenize(text) {
        var tokens = [];
        var token = '';
        if (typeof text !== 'string') {
            return tokens;
        }
        for (var i = 0; i < text.length; i++) {
            var char = text[i];
            if (TextMetrics.isBreakingSpace(char) || TextMetrics.isNewline(char)) {
                if (token !== '') {
                    tokens.push(token);
                    token = '';
                }
                tokens.push(char);
                continue;
            }
            token += char;
        }
        if (token !== '') {
            tokens.push(token);
        }
        return tokens;
    }
    ;
    /**
     * This method exists to be easily overridden
     * It allows one to customise which words should break
     * Examples are if the token is CJK or numbers.
     * It must return a boolean.
     *
     * @private
     * @param  {string}  token   The token
     * @param  {boolean}  breakWords  The style attr break words
     * @return {boolean} whether to break word or not
     */
    static canBreakWords(token, breakWords) {
        return breakWords;
    }
    ;
    /**
     * This method exists to be easily overridden
     * It allows one to determine whether a pair of characters
     * should be broken by newlines
     * For example certain characters in CJK langs or numbers.
     * It must return a boolean.
     *
     * @private
     * @param  {string}  char  The character
     * @param  {string}  nextChar  The next character
     * @param  {string}  token The token/word the characters are from
     * @param  {number}  index The index in the token of the char
     * @param  {boolean}  breakWords  The style attr break words
     * @return {boolean} whether to break word or not
     */
    static canBreakChars(char, nextChar, token, index, breakWords) {
        return true;
    }
    ;
    /**
     * Calculates the ascent, descent and fontSize of a given font-style
     *
     * @static
     * @param {string} font - String representing the style of the font
     * @return {PIXI.IFontMetrics} Font properties object
     */
    static measureFont(font) {
        // as this method is used for preparing assets, don't recalculate things if we don't need to
        if (TextMetrics._fonts[font]) {
            return TextMetrics._fonts[font];
        }
        var properties = {};
        var canvas = TextMetrics._canvas;
        var context = TextMetrics._context;
        context.font = font;
        var metricsString = TextMetrics.METRICS_STRING + TextMetrics.BASELINE_SYMBOL;
        var width = Math.ceil(context.measureText(metricsString).width);
        var baseline = Math.ceil(context.measureText(TextMetrics.BASELINE_SYMBOL).width);
        var height = 2 * baseline;
        baseline = baseline * TextMetrics.BASELINE_MULTIPLIER | 0;
        canvas.width = width;
        canvas.height = height;
        context.fillStyle = '#f00';
        context.fillRect(0, 0, width, height);
        context.font = font;
        context.textBaseline = 'alphabetic';
        context.fillStyle = '#000';
        context.fillText(metricsString, 0, baseline);
        var imagedata = context.getImageData(0, 0, width, height).data;
        var pixels = imagedata.length;
        var line = width * 4;
        var i = 0;
        var idx = 0;
        var stop = false;
        // ascent. scan from top to bottom until we find a non red pixel
        for (i = 0; i < baseline; ++i) {
            for (var j = 0; j < line; j += 4) {
                if (imagedata[idx + j] !== 255) {
                    stop = true;
                    break;
                }
            }
            if (!stop) {
                idx += line;
            }
            else {
                break;
            }
        }
        properties.ascent = baseline - i;
        idx = pixels - line;
        stop = false;
        // descent. scan from bottom to top until we find a non red pixel
        for (i = height; i > baseline; --i) {
            for (var j$1 = 0; j$1 < line; j$1 += 4) {
                if (imagedata[idx + j$1] !== 255) {
                    stop = true;
                    break;
                }
            }
            if (!stop) {
                idx -= line;
            }
            else {
                break;
            }
        }
        properties.descent = i - baseline;
        properties.fontSize = properties.ascent + properties.descent;
        TextMetrics._fonts[font] = properties;
        return properties;
    }
    ;
    /**
     * Clear font metrics in metrics cache.
     *
     * @static
     * @param {string} [font] - font name. If font name not set then clear cache for all fonts.
     */
    static clearMetrics(font) {
        if (font === void 0) {
            font = '';
        }
        if (font) {
            delete TextMetrics._fonts[font];
        }
        else {
            TextMetrics._fonts = {};
        }
    }
    ;
}
/**
 * Internal return object for {@link PIXI.TextMetrics.measureFont `TextMetrics.measureFont`}.
 *
 * @typedef {object} FontMetrics
 * @property {number} ascent - The ascent distance
 * @property {number} descent - The descent distance
 * @property {number} fontSize - Font size from ascent to descent
 * @memberof PIXI.TextMetrics
 * @private
 */
/**
 * Cache of {@see PIXI.TextMetrics.FontMetrics} objects.
 * @memberof PIXI.TextMetrics
 * @type {Object}
 * @private
 */
TextMetrics._fonts = {};
/**
 * String used for calculate font metrics.
 * @static
 * @memberof PIXI.TextMetrics
 * @name METRICS_STRING
 * @type {string}
 * @default |Éq
 */
TextMetrics.METRICS_STRING = '|Éq';
/**
 * Baseline symbol for calculate font metrics.
 * @static
 * @memberof PIXI.TextMetrics
 * @name BASELINE_SYMBOL
 * @type {string}
 * @default M
 */
TextMetrics.BASELINE_SYMBOL = 'M';
/**
 * Baseline multiplier for calculate font metrics.
 * @static
 * @memberof PIXI.TextMetrics
 * @name BASELINE_MULTIPLIER
 * @type {number}
 * @default 1.4
 */
TextMetrics.BASELINE_MULTIPLIER = 1.4;
/**
 * Cache of new line chars.
 * @memberof PIXI.TextMetrics
 * @type {number[]}
 * @private
 */
TextMetrics._newlines = [
    0x000A,
    0x000D
];
/**
 * Cache of breaking spaces.
 * @memberof PIXI.TextMetrics
 * @type {number[]}
 * @private
 */
TextMetrics._breakingSpaces = [
    0x0009,
    0x0020,
    0x2000,
    0x2001,
    0x2002,
    0x2003,
    0x2004,
    0x2005,
    0x2006,
    0x2008,
    0x2009,
    0x200A,
    0x205F,
    0x3000
];
exports.TextMetrics = TextMetrics;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/TextSettings.js":
/*!************************************************!*\
  !*** ./js-compile/raw-pixi-ts/TextSettings.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class TextSettings {
}
TextSettings.TEXT_GRADIENT = {
    LINEAR_VERTICAL: 0,
    LINEAR_HORIZONTAL: 1,
};
TextSettings.defaultStyle = {
    align: 'left',
    breakWords: false,
    dropShadow: false,
    dropShadowAlpha: 1,
    dropShadowAngle: Math.PI / 6,
    dropShadowBlur: 0,
    dropShadowColor: 'black',
    dropShadowDistance: 5,
    fill: 'black',
    fillGradientType: TextSettings.TEXT_GRADIENT.LINEAR_VERTICAL,
    fillGradientStops: [],
    fontFamily: 'Arial',
    fontSize: 26,
    fontStyle: 'normal',
    fontVariant: 'normal',
    fontWeight: 'normal',
    letterSpacing: 0,
    lineHeight: 0,
    lineJoin: 'miter',
    miterLimit: 10,
    padding: 0,
    stroke: 'black',
    strokeThickness: 0,
    textBaseline: 'alphabetic',
    trim: false,
    whiteSpace: 'pre',
    wordWrap: false,
    wordWrapWidth: 100,
    leading: 0,
};
exports.TextSettings = TextSettings;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/TextStyle.js":
/*!*********************************************!*\
  !*** ./js-compile/raw-pixi-ts/TextStyle.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const TextSettings_1 = __webpack_require__(/*! ./TextSettings */ "./js-compile/raw-pixi-ts/TextSettings.js");
const ColorSettings_1 = __webpack_require__(/*! ./ColorSettings */ "./js-compile/raw-pixi-ts/ColorSettings.js");
const UtilsSettings_1 = __webpack_require__(/*! ./UtilsSettings */ "./js-compile/raw-pixi-ts/UtilsSettings.js");
class TextStyle {
    constructor(style) {
        this.styleID = 0;
        this.reset();
        UtilsSettings_1.UtilsSettings.deepCopyProperties(this, style, style);
    }
    /**
     * Creates a new TextStyle object with the same values as this one.
     * Note that the only the properties of the object are cloned.
     *
     * @return {PIXI.TextStyle} New cloned TextStyle object
     */
    clone() {
        var clonedProperties = {};
        UtilsSettings_1.UtilsSettings.deepCopyProperties(clonedProperties, this, TextSettings_1.TextSettings.defaultStyle);
        return new TextStyle(clonedProperties);
    }
    ;
    /**
     * Resets all properties to the defaults specified in TextStyle.prototype._default
     */
    reset() {
        UtilsSettings_1.UtilsSettings.deepCopyProperties(this, TextSettings_1.TextSettings.defaultStyle, TextSettings_1.TextSettings.defaultStyle);
    }
    ;
    /**
     * Alignment for multiline text ('left', 'center' or 'right'), does not affect single line text
     *
     * @member {string}
     */
    get align() {
        return this._align;
    }
    ;
    set align(align) {
        if (this._align !== align) {
            this._align = align;
            this.styleID++;
        }
    }
    ;
    /**
     * Indicates if lines can be wrapped within words, it needs wordWrap to be set to true
     *
     * @member {boolean}
     */
    get breakWords() {
        return this._breakWords;
    }
    ;
    set breakWords(breakWords) {
        if (this._breakWords !== breakWords) {
            this._breakWords = breakWords;
            this.styleID++;
        }
    }
    ;
    /**
     * Set a drop shadow for the text
     *
     * @member {boolean}
     */
    get dropShadow() {
        return this._dropShadow;
    }
    ;
    set dropShadow(dropShadow) {
        if (this._dropShadow !== dropShadow) {
            this._dropShadow = dropShadow;
            this.styleID++;
        }
    }
    ;
    /**
     * Set alpha for the drop shadow
     *
     * @member {number}
     */
    get dropShadowAlpha() {
        return this._dropShadowAlpha;
    }
    ;
    set dropShadowAlpha(dropShadowAlpha) {
        if (this._dropShadowAlpha !== dropShadowAlpha) {
            this._dropShadowAlpha = dropShadowAlpha;
            this.styleID++;
        }
    }
    ;
    /**
     * Set a angle of the drop shadow
     *
     * @member {number}
     */
    get dropShadowAngle() {
        return this._dropShadowAngle;
    }
    ;
    set dropShadowAngle(dropShadowAngle) {
        if (this._dropShadowAngle !== dropShadowAngle) {
            this._dropShadowAngle = dropShadowAngle;
            this.styleID++;
        }
    }
    ;
    /**
     * Set a shadow blur radius
     *
     * @member {number}
     */
    get dropShadowBlur() {
        return this._dropShadowBlur;
    }
    ;
    set dropShadowBlur(dropShadowBlur) {
        if (this._dropShadowBlur !== dropShadowBlur) {
            this._dropShadowBlur = dropShadowBlur;
            this.styleID++;
        }
    }
    ;
    /**
     * A fill style to be used on the dropshadow e.g 'red', '#00FF00'
     *
     * @member {string|number}
     */
    get dropShadowColor() {
        return this._dropShadowColor;
    }
    ;
    set dropShadowColor(dropShadowColor) {
        var outputColor = ColorSettings_1.ColorSettings.getColor(dropShadowColor);
        if (this._dropShadowColor !== outputColor) {
            this._dropShadowColor = outputColor;
            this.styleID++;
        }
    }
    ;
    /**
     * Set a distance of the drop shadow
     *
     * @member {number}
     */
    get dropShadowDistance() {
        return this._dropShadowDistance;
    }
    ;
    set dropShadowDistance(dropShadowDistance) {
        if (this._dropShadowDistance !== dropShadowDistance) {
            this._dropShadowDistance = dropShadowDistance;
            this.styleID++;
        }
    }
    ;
    /**
     * A canvas fillstyle that will be used on the text e.g 'red', '#00FF00'.
     * Can be an array to create a gradient eg ['#000000','#FFFFFF']
     * {@link https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/fillStyle|MDN}
     *
     * @member {string|string[]|number|number[]|CanvasGradient|CanvasPattern}
     */
    get fill() {
        return this._fill;
    }
    ;
    set fill(fill) {
        var outputColor = ColorSettings_1.ColorSettings.getColor(fill);
        if (this._fill !== outputColor) {
            this._fill = outputColor;
            this.styleID++;
        }
    }
    ;
    /**
     * If fill is an array of colours to create a gradient, this can change the type/direction of the gradient.
     * See {@link PIXI.TEXT_GRADIENT}
     *
     * @member {number}
     */
    get fillGradientType() {
        return this._fillGradientType;
    }
    ;
    set fillGradientType(fillGradientType) {
        if (this._fillGradientType !== fillGradientType) {
            this._fillGradientType = fillGradientType;
            this.styleID++;
        }
    }
    ;
    /**
     * If fill is an array of colours to create a gradient, this array can set the stop points
     * (numbers between 0 and 1) for the color, overriding the default behaviour of evenly spacing them.
     *
     * @member {number[]}
     */
    get fillGradientStops() {
        return this._fillGradientStops;
    }
    ;
    set fillGradientStops(fillGradientStops) {
        if (!UtilsSettings_1.UtilsSettings.areArraysEqual(this._fillGradientStops, fillGradientStops)) {
            this._fillGradientStops = fillGradientStops;
            this.styleID++;
        }
    }
    ;
    /**
     * The font family
     *
     * @member {string|string[]}
     */
    get fontFamily() {
        return this._fontFamily;
    }
    ;
    set fontFamily(fontFamily) {
        if (this.fontFamily !== fontFamily) {
            this._fontFamily = fontFamily;
            this.styleID++;
        }
    }
    ;
    /**
     * The font size
     * (as a number it converts to px, but as a string, equivalents are '26px','20pt','160%' or '1.6em')
     *
     * @member {number|string}
     */
    get fontSize() {
        return this._fontSize;
    }
    ;
    set fontSize(fontSize) {
        if (this._fontSize !== fontSize) {
            this._fontSize = fontSize;
            this.styleID++;
        }
    }
    ;
    /**
     * The font style
     * ('normal', 'italic' or 'oblique')
     *
     * @member {string}
     */
    get fontStyle() {
        return this._fontStyle;
    }
    ;
    set fontStyle(fontStyle) {
        if (this._fontStyle !== fontStyle) {
            this._fontStyle = fontStyle;
            this.styleID++;
        }
    }
    ;
    /**
     * The font variant
     * ('normal' or 'small-caps')
     *
     * @member {string}
     */
    get fontVariant() {
        return this._fontVariant;
    }
    ;
    set fontVariant(fontVariant) {
        if (this._fontVariant !== fontVariant) {
            this._fontVariant = fontVariant;
            this.styleID++;
        }
    }
    ;
    /**
     * The font weight
     * ('normal', 'bold', 'bolder', 'lighter' and '100', '200', '300', '400', '500', '600', '700', 800' or '900')
     *
     * @member {string}
     */
    get fontWeight() {
        return this._fontWeight;
    }
    ;
    set fontWeight(fontWeight) {
        if (this._fontWeight !== fontWeight) {
            this._fontWeight = fontWeight;
            this.styleID++;
        }
    }
    ;
    /**
     * The amount of spacing between letters, default is 0
     *
     * @member {number}
     */
    get letterSpacing() {
        return this._letterSpacing;
    }
    ;
    set letterSpacing(letterSpacing) {
        if (this._letterSpacing !== letterSpacing) {
            this._letterSpacing = letterSpacing;
            this.styleID++;
        }
    }
    ;
    /**
     * The line height, a number that represents the vertical space that a letter uses
     *
     * @member {number}
     */
    get lineHeight() {
        return this._lineHeight;
    }
    ;
    set lineHeight(lineHeight) {
        if (this._lineHeight !== lineHeight) {
            this._lineHeight = lineHeight;
            this.styleID++;
        }
    }
    ;
    /**
     * The space between lines
     *
     * @member {number}
     */
    get leading() {
        return this._leading;
    }
    ;
    set leading(leading) {
        if (this._leading !== leading) {
            this._leading = leading;
            this.styleID++;
        }
    }
    ;
    /**
     * The lineJoin property sets the type of corner created, it can resolve spiked text issues.
     * Default is 'miter' (creates a sharp corner).
     *
     * @member {string}
     */
    get lineJoin() {
        return this._lineJoin;
    }
    ;
    set lineJoin(lineJoin) {
        if (this._lineJoin !== lineJoin) {
            this._lineJoin = lineJoin;
            this.styleID++;
        }
    }
    ;
    /**
     * The miter limit to use when using the 'miter' lineJoin mode
     * This can reduce or increase the spikiness of rendered text.
     *
     * @member {number}
     */
    get miterLimit() {
        return this._miterLimit;
    }
    ;
    set miterLimit(miterLimit) {
        if (this._miterLimit !== miterLimit) {
            this._miterLimit = miterLimit;
            this.styleID++;
        }
    }
    ;
    /**
     * Occasionally some fonts are cropped. Adding some padding will prevent this from happening
     * by adding padding to all sides of the text.
     *
     * @member {number}
     */
    get padding() {
        return this._padding;
    }
    ;
    set padding(padding) {
        if (this._padding !== padding) {
            this._padding = padding;
            this.styleID++;
        }
    }
    ;
    /**
     * A canvas fillstyle that will be used on the text stroke
     * e.g 'blue', '#FCFF00'
     *
     * @member {string|number}
     */
    get stroke() {
        return this._stroke;
    }
    ;
    set stroke(stroke) {
        var outputColor = ColorSettings_1.ColorSettings.getColor(stroke);
        if (this._stroke !== outputColor) {
            this._stroke = outputColor;
            this.styleID++;
        }
    }
    ;
    /**
     * A number that represents the thickness of the stroke.
     * Default is 0 (no stroke)
     *
     * @member {number}
     */
    get strokeThickness() {
        return this._strokeThickness;
    }
    ;
    set strokeThickness(strokeThickness) {
        if (this._strokeThickness !== strokeThickness) {
            this._strokeThickness = strokeThickness;
            this.styleID++;
        }
    }
    ;
    /**
     * The baseline of the text that is rendered.
     *
     * @member {string}
     */
    get textBaseline() {
        return this._textBaseline;
    }
    ;
    set textBaseline(textBaseline) {
        if (this._textBaseline !== textBaseline) {
            this._textBaseline = textBaseline;
            this.styleID++;
        }
    }
    ;
    /**
     * Trim transparent borders
     *
     * @member {boolean}
     */
    get trim() {
        return this._trim;
    }
    ;
    set trim(trim) {
        if (this._trim !== trim) {
            this._trim = trim;
            this.styleID++;
        }
    }
    ;
    /**
     * How newlines and spaces should be handled.
     * Default is 'pre' (preserve, preserve).
     *
     *  value   | New lines |   Spaces
     *  ---     | ---       |   ---
     * 'normal' | Collapse  |   Collapse
     * 'pre'    | Preserve  |   Preserve
     * 'pre-line'   | Preserve  |   Collapse
     *
     * @member {string}
     */
    get whiteSpace() {
        return this._whiteSpace;
    }
    ;
    set whiteSpace(whiteSpace) {
        if (this._whiteSpace !== whiteSpace) {
            this._whiteSpace = whiteSpace;
            this.styleID++;
        }
    }
    ;
    /**
     * Indicates if word wrap should be used
     *
     * @member {boolean}
     */
    get wordWrap() {
        return this._wordWrap;
    }
    ;
    set wordWrap(wordWrap) {
        if (this._wordWrap !== wordWrap) {
            this._wordWrap = wordWrap;
            this.styleID++;
        }
    }
    ;
    /**
     * The width at which text will wrap, it needs wordWrap to be set to true
     *
     * @member {number}
     */
    get wordWrapWidth() {
        return this._wordWrapWidth;
    }
    ;
    set wordWrapWidth(wordWrapWidth) {
        if (this._wordWrapWidth !== wordWrapWidth) {
            this._wordWrapWidth = wordWrapWidth;
            this.styleID++;
        }
    }
    ;
    /**
     * Generates a font style string to use for `TextMetrics.measureFont()`.
     *
     * @return {string} Font style string, for passing to `TextMetrics.measureFont()`
     */
    toFontString() {
        // build canvas api font setting from individual components. Convert a numeric this.fontSize to px
        var fontSizeString = (typeof this.fontSize === 'number') ? ((this.fontSize) + "px") : this.fontSize;
        // Clean-up fontFamily property by quoting each font name
        // this will support font names with spaces
        var fontFamilies = this.fontFamily;
        if (!Array.isArray(this.fontFamily)) {
            fontFamilies = this.fontFamily.split(',');
        }
        for (var i = fontFamilies.length - 1; i >= 0; i--) {
            // Trim any extra white-space
            var fontFamily = fontFamilies[i].trim();
            // Check if font already contains strings
            if (!(/([\"\'])[^\'\"]+\1/).test(fontFamily)) {
                fontFamily = "\"" + fontFamily + "\"";
            }
            fontFamilies[i] = fontFamily;
        }
        return ((this.fontStyle) + " " + (this.fontVariant) + " " + (this.fontWeight) + " " + fontSizeString + " " + (fontFamilies.join(',')));
    }
    ;
}
exports.TextStyle = TextStyle;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/Texture.js":
/*!*******************************************!*\
  !*** ./js-compile/raw-pixi-ts/Texture.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const EventDispatcher_1 = __webpack_require__(/*! ./EventDispatcher */ "./js-compile/raw-pixi-ts/EventDispatcher.js");
const Rectangle_1 = __webpack_require__(/*! ./Rectangle */ "./js-compile/raw-pixi-ts/Rectangle.js");
const Point_1 = __webpack_require__(/*! ./Point */ "./js-compile/raw-pixi-ts/Point.js");
const Event_1 = __webpack_require__(/*! ./Event */ "./js-compile/raw-pixi-ts/Event.js");
const TextureUvs_1 = __webpack_require__(/*! ./TextureUvs */ "./js-compile/raw-pixi-ts/TextureUvs.js");
const BaseTexture_1 = __webpack_require__(/*! ./BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const ImageResource_1 = __webpack_require__(/*! ./ImageResource */ "./js-compile/raw-pixi-ts/ImageResource.js");
const CanvasResource_1 = __webpack_require__(/*! ./CanvasResource */ "./js-compile/raw-pixi-ts/CanvasResource.js");
const MathSettings_1 = __webpack_require__(/*! ./MathSettings */ "./js-compile/raw-pixi-ts/MathSettings.js");
const CacheSettings_1 = __webpack_require__(/*! ./CacheSettings */ "./js-compile/raw-pixi-ts/CacheSettings.js");
const DisplaySettings_1 = __webpack_require__(/*! ./DisplaySettings */ "./js-compile/raw-pixi-ts/DisplaySettings.js");
const NetworkSettings_1 = __webpack_require__(/*! ./NetworkSettings */ "./js-compile/raw-pixi-ts/NetworkSettings.js");
const Logger_1 = __webpack_require__(/*! ./Logger */ "./js-compile/raw-pixi-ts/Logger.js");
class Texture extends EventDispatcher_1.EventDispatcher {
    constructor(baseTexture, frame = null, orig = null, trim = null, rotate = null, anchor = null) {
        super();
        /**
         * Called when the base texture is updated
         *
         * @protected
         * @param {PIXI.BaseTexture} baseTexture - The base texture.
         */
        this.onBaseTextureUpdated = (baseTexture) => {
            Logger_1.trace("onBaseTextureUpdated");
            this._updateID++;
            // TODO this code looks confusing.. boo to abusing getters and setters!
            if (this.noFrame) {
                this.frame = new Rectangle_1.Rectangle(0, 0, baseTexture.width, baseTexture.height);
            }
            else {
                this.frame = this._frame;
                // TODO maybe watch out for the no frame option
                // updating the texture will should update the frame if it was set to no frame..
            }
            this.valid = this.baseTexture.valid;
            this.dispatchEvent(Event_1.Event.getEvent("update"));
            // this.emit('update', this);
            // this.baseTexture.addEventListener("update", this.onBaseTextureUpdated)
        };
        this.noFrame = false;
        if (!frame) {
            this.noFrame = true;
            frame = new Rectangle_1.Rectangle(0, 0, 1, 1);
        }
        if (baseTexture instanceof Texture) {
            baseTexture = baseTexture.baseTexture;
        }
        /**
         * The base texture that this texture uses.
         *
         * @member {PIXI.BaseTexture}
         */
        this.baseTexture = baseTexture;
        /**
         * This is the area of the BaseTexture image to actually copy to the Canvas / WebGL when rendering,
         * irrespective of the actual frame size or placement (which can be influenced by trimmed texture atlases)
         *
         * @member {PIXI.Rectangle}
         */
        this._frame = frame;
        /**
         * This is the trimmed area of original texture, before it was put in atlas
         * Please call `updateUvs()` after you change coordinates of `trim` manually.
         *
         * @member {PIXI.Rectangle}
         */
        this.trim = trim;
        /**
         * This will let the renderer know if the texture is valid. If it's not then it cannot be rendered.
         *
         * @member {boolean}
         */
        this.valid = false;
        /**
         * This will let a renderer know that a texture has been updated (used mainly for WebGL uv updates)
         *
         * @member {boolean}
         */
        this.requiresUpdate = false;
        /**
         * The WebGL UV data cache. Can be used as quad UV
         *
         * @member {PIXI.TextureUvs}
         * @protected
         */
        this._uvs = Texture.DEFAULT_UVS;
        /**
         * Default TextureMatrix instance for this texture
         * By default that object is not created because its heavy
         *
         * @member {PIXI.TextureMatrix}
         */
        this.uvMatrix = null;
        /**
         * This is the area of original texture, before it was put in atlas
         *
         * @member {PIXI.Rectangle}
         */
        this.orig = orig || frame; // new Rectangle(0, 0, 1, 1);
        this._rotate = Number(rotate || 0);
        if (rotate === true) {
            // this is old texturepacker legacy, some games/libraries are passing "true" for rotated textures
            this._rotate = 2;
        }
        else if (this._rotate % 2 !== 0) {
            throw new Error('attempt to use diamond-shaped UVs. If you are sure, set rotation manually');
        }
        if (baseTexture.valid) {
            if (this.noFrame) {
                frame = new Rectangle_1.Rectangle(0, 0, baseTexture.width, baseTexture.height);
                // if there is no frame we should monitor for any base texture changes..
                baseTexture.addEventListener("update", this.onBaseTextureUpdated);
                // baseTexture.on('update', this.onBaseTextureUpdated, this);
            }
            this.frame = frame;
        }
        else {
            baseTexture.addEventListener("loaded", this.onBaseTextureUpdated);
            // baseTexture.once('loaded', this.onBaseTextureUpdated, this);
        }
        /**
         * Anchor point that is used as default if sprite is created with this texture.
         * Changing the `defaultAnchor` at a later point of time will not update Sprite's anchor point.
         * @member {PIXI.Point}
         * @default {0,0}
         */
        if (anchor) {
            this.defaultAnchor = new Point_1.Point(anchor.x, anchor.y);
        }
        else {
            this.defaultAnchor = new Point_1.Point(0, 0);
        }
        /**
         * Update ID is observed by sprites and TextureMatrix instances.
         * Call updateUvs() to increment it.
         *
         * @member {number}
         * @protected
         */
        this._updateID = 0;
        /**
         * The ids under which this Texture has been added to the texture cache. This is
         * automatically set as long as Texture.addToCache is used, but may not be set if a
         * Texture is added directly to the TextureCache array.
         *
         * @member {string[]}
         */
        this.textureCacheIds = [];
    }
    /**
     * Updates this texture on the gpu.
     *
     */
    update() {
        this.baseTexture.update();
    }
    ;
    /**
     * Destroys this texture
     *
     * @param {boolean} [destroyBase=false] Whether to destroy the base texture as well
     */
    destroy(destroyBase) {
        if (this.baseTexture) {
            if (destroyBase) {
                // delete the texture if it exists in the texture cache..
                // this only needs to be removed if the base texture is actually destroyed too..
                if (CacheSettings_1.CacheSettings.TextureCache[this.baseTexture.imageUrl]) {
                    Texture.removeFromCache(this.baseTexture.imageUrl);
                }
                this.baseTexture.destroy();
            }
            // this.baseTexture.remo('update', this.onBaseTextureUpdated, this);
            this.baseTexture = null;
        }
        this._frame = null;
        this._uvs = null;
        this.trim = null;
        this.orig = null;
        this.valid = false;
        Texture.removeFromCache(this);
        this.textureCacheIds = null;
    }
    ;
    /**
     * Creates a new texture object that acts the same as this one.
     *
     * @return {PIXI.Texture} The new texture
     */
    clone() {
        return new Texture(this.baseTexture, this.frame, this.orig, this.trim, this.rotate, this.defaultAnchor);
    }
    ;
    /**
     * Updates the internal WebGL UV cache. Use it after you change `frame` or `trim` of the texture.
     * Call it after changing the frame
     */
    updateUvs() {
        if (this._uvs === Texture.DEFAULT_UVS) {
            this._uvs = new TextureUvs_1.TextureUvs();
        }
        this._uvs.set(this._frame, this.baseTexture, this.rotate);
        this._updateID++;
    }
    ;
    /**
     * Helper function that creates a new Texture based on the source you provide.
     * The source can be - frame id, image url, video url, canvas element, video element, base texture
     *
     * @static
     * @param {number|string|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement|PIXI.BaseTexture} source
     *        Source to create texture from
     * @param {object} [options] See {@link PIXI.BaseTexture}'s constructor for options.
     * @return {PIXI.Texture} The newly created texture
     */
    static from(source, options = {}) {
        var cacheId = null;
        if (typeof source === 'string') {
            cacheId = source;
        }
        else {
            if (!source._pixiId) {
                source._pixiId = "pixiid_" + (MathSettings_1.MathSettings.uid());
            }
            cacheId = source._pixiId;
        }
        var texture = CacheSettings_1.CacheSettings.TextureCache[cacheId];
        if (!texture) {
            if (options['resolution'] == undefined) {
                options.resolution = NetworkSettings_1.NetworkSettings.getResolutionOfUrl(source);
            }
            texture = new Texture(new BaseTexture_1.BaseTexture(source, options));
            texture.baseTexture.cacheId = cacheId;
            BaseTexture_1.BaseTexture.addToCache(texture.baseTexture, cacheId);
            Texture.addToCache(texture, cacheId);
        }
        // lets assume its a base texture!
        return texture;
    }
    ;
    /**
     * Adds a Texture to the global TextureCache. This cache is shared across the whole PIXI object.
     *
     * @static
     * @param {PIXI.Texture} texture - The Texture to add to the cache.
     * @param {string} id - The id that the Texture will be stored against.
     */
    static addToCache(texture, id) {
        if (id) {
            if (texture.textureCacheIds.indexOf(id) === -1) {
                texture.textureCacheIds.push(id);
            }
            if (CacheSettings_1.CacheSettings.TextureCache[id]) {
                // eslint-disable-next-line no-console
                console.warn(("Texture added to the cache with an id [" + id + "] that already had an entry"));
            }
            CacheSettings_1.CacheSettings.TextureCache[id] = texture;
        }
    }
    ;
    /**
     * Remove a Texture from the global TextureCache.
     *
     * @static
     * @param {string|PIXI.Texture} texture - id of a Texture to be removed, or a Texture instance itself
     * @return {PIXI.Texture|null} The Texture that was removed
     */
    static removeFromCache(texture) {
        if (typeof texture === 'string') {
            var textureFromCache = CacheSettings_1.CacheSettings.TextureCache[texture];
            if (textureFromCache) {
                var index = textureFromCache.textureCacheIds.indexOf(texture);
                if (index > -1) {
                    textureFromCache.textureCacheIds.splice(index, 1);
                }
                delete CacheSettings_1.CacheSettings.TextureCache[texture];
                return textureFromCache;
            }
        }
        else if (texture && texture.textureCacheIds) {
            for (var i = 0; i < texture.textureCacheIds.length; ++i) {
                // Check that texture matches the one being passed in before deleting it from the cache.
                if (CacheSettings_1.CacheSettings.TextureCache[texture.textureCacheIds[i]] === texture) {
                    delete CacheSettings_1.CacheSettings.TextureCache[texture.textureCacheIds[i]];
                }
            }
            texture.textureCacheIds.length = 0;
            return texture;
        }
        return null;
    }
    ;
    /**
     * The frame specifies the region of the base texture that this texture uses.
     * Please call `updateUvs()` after you change coordinates of `frame` manually.
     *
     * @member {PIXI.Rectangle}
     */
    get frame() {
        return this._frame;
    }
    ;
    set frame(frame) {
        this._frame = frame;
        this.noFrame = false;
        var x = frame.x;
        var y = frame.y;
        var width = frame.width;
        var height = frame.height;
        var xNotFit = x + width > this.baseTexture.width;
        var yNotFit = y + height > this.baseTexture.height;
        if (xNotFit || yNotFit) {
            var relationship = xNotFit && yNotFit ? 'and' : 'or';
            var errorX = "X: " + x + " + " + width + " = " + (x + width) + " > " + (this.baseTexture.width);
            var errorY = "Y: " + y + " + " + height + " = " + (y + height) + " > " + (this.baseTexture.height);
            throw new Error('Texture Error: frame does not fit inside the base Texture dimensions: '
                + errorX + " " + relationship + " " + errorY);
        }
        this.valid = width && height && this.baseTexture.valid;
        if (!this.trim && !this.rotate) {
            this.orig = frame;
        }
        if (this.valid) {
            this.updateUvs();
        }
    }
    ;
    /**
     * Indicates whether the texture is rotated inside the atlas
     * set to 2 to compensate for texture packer rotation
     * set to 6 to compensate for spine packer rotation
     * can be used to rotate or mirror sprites
     * See {@link PIXI.GroupD8} for explanation
     *
     * @member {number}
     */
    get rotate() {
        return this._rotate;
    }
    ;
    set rotate(rotate) {
        this._rotate = rotate;
        if (this.valid) {
            this.updateUvs();
        }
    }
    ;
    /**
     * The width of the Texture in pixels.
     *
     * @member {number}
     */
    get width() {
        return this.orig.width;
    }
    ;
    /**
     * The height of the Texture in pixels.
     *
     * @member {number}
     */
    get height() {
        return this.orig.height;
    }
    ;
    /**
     * An empty texture, used often to not have to create multiple empty textures.
     * Can not be destroyed.
     *
     * @static
     * @constant
     * @member {PIXI.Texture}
     */
    static get EMPTY() {
        return new Texture(new BaseTexture_1.BaseTexture());
    }
    /**
 * A white texture of 10x10 size, used for graphics and other things
 * Can not be destroyed.
 *
 * @static
 * @constant
 * @member {PIXI.Texture}
 */
    static get WHITE() {
        return Texture.createWhiteTexture();
    }
    static createWhiteTexture() {
        var canvas = document.createElement('canvas');
        canvas.width = 16;
        canvas.height = 16;
        var context = canvas.getContext('2d');
        context.fillStyle = 'white';
        context.fillRect(0, 0, 16, 16);
        return new Texture(new BaseTexture_1.BaseTexture(new CanvasResource_1.CanvasResource(canvas)));
    }
}
Texture.DEFAULT_UVS = new TextureUvs_1.TextureUvs();
/**
 * Create a new Texture with a BufferResource from a Float32Array.
 * RGBA values are floats from 0 to 1.
 * @static
 * @param {Float32Array|Uint8Array} buffer The optional array to use, if no data
 *        is provided, a new Float32Array is created.
 * @param {number} width - Width of the resource
 * @param {number} height - Height of the resource
 * @param {object} [options] See {@link PIXI.BaseTexture}'s constructor for options.
 * @return {PIXI.Texture} The resulting new BaseTexture
 */
Texture.fromBuffer = function fromBuffer(buffer, width, height, options) {
    return new Texture(BaseTexture_1.BaseTexture.fromBuffer(buffer, width, height, options));
};
/**
 * Create a texture from a source and add to the cache.
 *
 * @static
 * @param {HTMLImageElement|HTMLCanvasElement} source - The input source.
 * @param {String} imageUrl - File name of texture, for cache and resolving resolution.
 * @param {String} [name] - Human readable name for the texture cache. If no name is
 *        specified, only `imageUrl` will be used as the cache ID.
 * @return {PIXI.Texture} Output texture
 */
Texture.fromLoader = function fromLoader(source, imageUrl, name) {
    var resource = new ImageResource_1.ImageResource(source);
    resource.url = imageUrl;
    var baseTexture = new BaseTexture_1.BaseTexture(resource, {
        scaleMode: DisplaySettings_1.DisplaySettings.SCALE_MODE,
        resolution: NetworkSettings_1.NetworkSettings.getResolutionOfUrl(imageUrl),
    });
    var texture = new Texture(baseTexture);
    // No name, use imageUrl instead
    if (!name) {
        name = imageUrl;
    }
    // lets also add the frame to pixi's global cache for fromFrame and fromImage functions
    BaseTexture_1.BaseTexture.addToCache(texture.baseTexture, name);
    Texture.addToCache(texture, name);
    // also add references by url if they are different.
    if (name !== imageUrl) {
        BaseTexture_1.BaseTexture.addToCache(texture.baseTexture, imageUrl);
        Texture.addToCache(texture, imageUrl);
    }
    return texture;
};
exports.Texture = Texture;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/TextureGCSystem.js":
/*!***************************************************!*\
  !*** ./js-compile/raw-pixi-ts/TextureGCSystem.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const System_1 = __webpack_require__(/*! ./System */ "./js-compile/raw-pixi-ts/System.js");
const settings_1 = __webpack_require__(/*! ./settings */ "./js-compile/raw-pixi-ts/settings.js");
class TextureGCSystem extends System_1.System {
    constructor(renderer) {
        super(renderer);
        /**
         * Count
         * @member {number}
         * @readonly
         */
        this.count = 0;
        /**
         * Check count
         * @member {number}
         * @readonly
         */
        this.checkCount = 0;
        /**
         * Maximum idle time, in seconds
         * @member {number}
         * @see PIXI.settings.GC_MAX_IDLE
         */
        this.maxIdle = settings_1.settings.GC_MAX_IDLE;
        /**
         * Maximum number of itesm to check
         * @member {number}
         * @see PIXI.settings.GC_MAX_CHECK_COUNT
         */
        this.checkCountMax = settings_1.settings.GC_MAX_CHECK_COUNT;
        /**
         * Current garabage collection mode
         * @member {PIXI.GC_MODES}
         * @see PIXI.settings.GC_MODE
         */
        this.mode = settings_1.settings.GC_MODE;
    }
    /**
     * Checks to see when the last time a texture was used
     * if the texture has not been used for a specified amount of time it will be removed from the GPU
     */
    postrender() {
        this.count++;
        if (this.mode === settings_1.settings.GC_MODES.MANUAL) {
            return;
        }
        this.checkCount++;
        if (this.checkCount > this.checkCountMax) {
            this.checkCount = 0;
            this.run();
        }
    }
    ;
    /**
     * Checks to see when the last time a texture was used
     * if the texture has not been used for a specified amount of time it will be removed from the GPU
     */
    run() {
        var tm = this.renderer.texture;
        var managedTextures = tm.managedTextures;
        var wasRemoved = false;
        for (var i = 0; i < managedTextures.length; i++) {
            var texture = managedTextures[i];
            // only supports non generated textures at the moment!
            if (!texture.framebuffer && this.count - texture.touched > this.maxIdle) {
                tm.destroyTexture(texture, true);
                managedTextures[i] = null;
                wasRemoved = true;
            }
        }
        if (wasRemoved) {
            var j = 0;
            for (var i$1 = 0; i$1 < managedTextures.length; i$1++) {
                if (managedTextures[i$1] !== null) {
                    managedTextures[j++] = managedTextures[i$1];
                }
            }
            managedTextures.length = j;
        }
    }
    ;
    /**
     * Removes all the textures within the specified displayObject and its children from the GPU
     *
     * @param {PIXI.DisplayObject} displayObject - the displayObject to remove the textures from.
     */
    unload(displayObject) {
        // var tm = this.renderer.textureSystem;
        var tm = this.renderer.texture;
        // only destroy non generated textures
        if (displayObject._texture && displayObject._texture._glRenderTargets) {
            tm.destroyTexture(displayObject._texture);
        }
        for (var i = displayObject.children.length - 1; i >= 0; i--) {
            this.unload(displayObject.children[i]);
        }
    }
    ;
}
exports.TextureGCSystem = TextureGCSystem;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/TextureMatrix.js":
/*!*************************************************!*\
  !*** ./js-compile/raw-pixi-ts/TextureMatrix.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Matrix_1 = __webpack_require__(/*! ./Matrix */ "./js-compile/raw-pixi-ts/Matrix.js");
class TextureMatrix {
    constructor(texture, clampMargin = null) {
        this._texture = texture;
        this.mapCoord = new Matrix_1.Matrix();
        this.uClampFrame = new Float32Array(4);
        this.uClampOffset = new Float32Array(2);
        /**
         * Tracks Texture frame changes
         * @member {number}
         * @protected
         */
        this._updateID = -1;
        /**
         * Changes frame clamping
         * Works with TilingSprite and Mesh
         * Change to 1.5 if you texture has repeated right and bottom lines, that leads to smoother borders
         *
         * @default 0
         * @member {number}
         */
        this.clampOffset = 0;
        /**
         * Changes frame clamping
         * Works with TilingSprite and Mesh
         * Change to -0.5 to add a pixel to the edge, recommended for transparent trimmed textures in atlas
         *
         * @default 0.5
         * @member {number}
         */
        this.clampMargin = (typeof clampMargin === 'undefined') ? 0.5 : clampMargin;
        /**
         * If texture size is the same as baseTexture
         * @member {boolean}
         * @default false
         * @readonly
         */
        this.isSimple = false;
    }
    /**
     * texture property
     * @member {PIXI.Texture}
     */
    get texture() {
        return this._texture;
    }
    ;
    set texture(value) {
        this._texture = value;
        this._updateID = -1;
    }
    ;
    /**
     * Multiplies uvs array to transform
     * @param {Float32Array} uvs mesh uvs
     * @param {Float32Array} [out=uvs] output
     * @returns {Float32Array} output
     */
    multiplyUvs(uvs, out) {
        if (out === undefined) {
            out = uvs;
        }
        var mat = this.mapCoord;
        for (var i = 0; i < uvs.length; i += 2) {
            var x = uvs[i];
            var y = uvs[i + 1];
            out[i] = (x * mat.a) + (y * mat.c) + mat.tx;
            out[i + 1] = (x * mat.b) + (y * mat.d) + mat.ty;
        }
        return out;
    }
    ;
    /**
     * updates matrices if texture was changed
     * @param {boolean} forceUpdate if true, matrices will be updated any case
     * @returns {boolean} whether or not it was updated
     */
    update(forceUpdate) {
        var tex = this._texture;
        if (!tex || !tex.valid) {
            return false;
        }
        if (!forceUpdate
            && this._updateID === tex._updateID) {
            return false;
        }
        this._updateID = tex._updateID;
        var uvs = tex._uvs;
        this.mapCoord.set(uvs.x1 - uvs.x0, uvs.y1 - uvs.y0, uvs.x3 - uvs.x0, uvs.y3 - uvs.y0, uvs.x0, uvs.y0);
        var orig = tex.orig;
        var trim = tex.trim;
        if (trim) {
            TextureMatrix.tempMat.set(orig.width / trim.width, 0, 0, orig.height / trim.height, -trim.x / trim.width, -trim.y / trim.height);
            this.mapCoord.append(TextureMatrix.tempMat);
        }
        var texBase = tex.baseTexture;
        var frame = this.uClampFrame;
        var margin = this.clampMargin / texBase.resolution;
        var offset = this.clampOffset;
        frame[0] = (tex._frame.x + margin + offset) / texBase.width;
        frame[1] = (tex._frame.y + margin + offset) / texBase.height;
        frame[2] = (tex._frame.x + tex._frame.width - margin + offset) / texBase.width;
        frame[3] = (tex._frame.y + tex._frame.height - margin + offset) / texBase.height;
        this.uClampOffset[0] = offset / texBase.realWidth;
        this.uClampOffset[1] = offset / texBase.realHeight;
        this.isSimple = tex._frame.width === texBase.width
            && tex._frame.height === texBase.height
            && tex.rotate === 0;
        return true;
    }
    ;
}
TextureMatrix.tempMat = new Matrix_1.Matrix();
exports.TextureMatrix = TextureMatrix;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/TextureSystem.js":
/*!*************************************************!*\
  !*** ./js-compile/raw-pixi-ts/TextureSystem.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const System_1 = __webpack_require__(/*! ./System */ "./js-compile/raw-pixi-ts/System.js");
const BaseTexture_1 = __webpack_require__(/*! ./BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const GLTexture_1 = __webpack_require__(/*! ./GLTexture */ "./js-compile/raw-pixi-ts/GLTexture.js");
const UtilsSettings_1 = __webpack_require__(/*! ./UtilsSettings */ "./js-compile/raw-pixi-ts/UtilsSettings.js");
const WebGLSettings_1 = __webpack_require__(/*! ./WebGLSettings */ "./js-compile/raw-pixi-ts/WebGLSettings.js");
const Logger_1 = __webpack_require__(/*! ./Logger */ "./js-compile/raw-pixi-ts/Logger.js");
class TextureSystem extends System_1.System {
    constructor(renderer) {
        super(renderer);
        // TODO set to max textures...
        /**
         * Bound textures
         * @member {PIXI.BaseTexture[]}
         * @readonly
         */
        this.boundTextures = [];
        /**
         * Current location
         * @member {number}
         * @readonly
         */
        this.currentLocation = -1;
        /**
         * List of managed textures
         * @member {PIXI.BaseTexture[]}
         * @readonly
         */
        this.managedTextures = [];
        /**
         * Did someone temper with textures state? We'll overwrite them when we need to unbind something.
         * @member {boolean}
         * @private
         */
        this._unknownBoundTextures = false;
        /**
         * BaseTexture value that shows that we don't know what is bound
         * @member {PIXI.BaseTexture}
         * @readonly
         */
        this.unknownTexture = new BaseTexture_1.BaseTexture();
    }
    /**
     * Sets up the renderer context and necessary buffers.
     */
    contextChange() {
        var gl = this.gl = this.renderer.gl;
        this.CONTEXT_UID = this.renderer.CONTEXT_UID;
        this.webGLVersion = this.renderer.context.webGLVersion;
        var maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
        this.boundTextures.length = maxTextures;
        for (var i = 0; i < maxTextures; i++) {
            this.boundTextures[i] = null;
        }
        // TODO move this.. to a nice make empty textures class..
        this.emptyTextures = {};
        var emptyTexture2D = new GLTexture_1.GLTexture(gl.createTexture());
        gl.bindTexture(gl.TEXTURE_2D, emptyTexture2D.texture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array(4));
        this.emptyTextures[gl.TEXTURE_2D] = emptyTexture2D;
        this.emptyTextures[gl.TEXTURE_CUBE_MAP] = new GLTexture_1.GLTexture(gl.createTexture());
        gl.bindTexture(gl.TEXTURE_CUBE_MAP, this.emptyTextures[gl.TEXTURE_CUBE_MAP].texture);
        for (var i$1 = 0; i$1 < 6; i$1++) {
            gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + i$1, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
        }
        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        for (var i$2 = 0; i$2 < this.boundTextures.length; i$2++) {
            this.bind(null, i$2);
        }
    }
    ;
    /**
     * Bind a texture to a specific location
     *
     * If you want to unbind something, please use `unbind(texture)` instead of `bind(null, textureLocation)`
     *
     * @param {PIXI.Texture|PIXI.BaseTexture} texture - Texture to bind
     * @param {number} [location=0] - Location to bind at
     */
    bind(texture, location = 0) {
        var ref = this;
        var gl = ref.gl;
        if (texture) {
            texture = texture.baseTexture || texture;
            if (texture.valid) {
                texture.touched = this.renderer.textureGC.count;
                var glTexture = texture._glTextures[this.CONTEXT_UID] || this.initTexture(texture);
                if (this.currentLocation !== location) {
                    this.currentLocation = location;
                    gl.activeTexture(gl.TEXTURE0 + location);
                }
                if (this.boundTextures[location] !== texture) {
                    gl.bindTexture(texture.target, glTexture.texture);
                }
                if (glTexture.dirtyId !== texture.dirtyId) {
                    this.updateTexture(texture);
                }
                this.boundTextures[location] = texture;
            }
        }
        else {
            if (this.currentLocation !== location) {
                this.currentLocation = location;
                gl.activeTexture(gl.TEXTURE0 + location);
            }
            gl.bindTexture(gl.TEXTURE_2D, this.emptyTextures[gl.TEXTURE_2D].texture);
            this.boundTextures[location] = null;
        }
    }
    ;
    /**
     * Resets texture location and bound textures
     *
     * Actual `bind(null, i)` calls will be performed at next `unbind()` call
     */
    reset() {
        this._unknownBoundTextures = true;
        this.currentLocation = -1;
        for (var i = 0; i < this.boundTextures.length; i++) {
            this.boundTextures[i] = this.unknownTexture;
        }
    }
    ;
    /**
     * Unbind a texture
     * @param {PIXI.Texture|PIXI.BaseTexture} texture - Texture to bind
     */
    unbind(texture) {
        var ref = this;
        var gl = ref.gl;
        var boundTextures = ref.boundTextures;
        if (this._unknownBoundTextures) {
            this._unknownBoundTextures = false;
            // someone changed webGL state,
            // we have to be sure that our texture does not appear in multi-texture renderer samplers
            for (var i = 0; i < boundTextures.length; i++) {
                if (boundTextures[i] === this.unknownTexture) {
                    this.bind(null, i);
                }
            }
        }
        for (var i$1 = 0; i$1 < boundTextures.length; i$1++) {
            if (boundTextures[i$1] === texture) {
                if (this.currentLocation !== i$1) {
                    gl.activeTexture(gl.TEXTURE0 + i$1);
                    this.currentLocation = i$1;
                }
                gl.bindTexture(gl.TEXTURE_2D, this.emptyTextures[texture.target].texture);
                boundTextures[i$1] = null;
            }
        }
    }
    ;
    /**
     * Initialize a texture
     *
     * @private
     * @param {PIXI.BaseTexture} texture - Texture to initialize
     */
    initTexture(texture) {
        var glTexture = new GLTexture_1.GLTexture(this.gl.createTexture());
        // guarantee an update..
        glTexture.dirtyId = -1;
        texture._glTextures[this.CONTEXT_UID] = glTexture;
        this.managedTextures.push(texture);
        // texture.on('dispose', this.destroyTexture, this);
        return glTexture;
    }
    ;
    /**
     * Update a texture
     *
     * @private
     * @param {PIXI.BaseTexture} texture - Texture to initialize
     */
    updateTexture(texture) {
        var glTexture = texture._glTextures[this.CONTEXT_UID];
        var renderer = this.renderer;
        if (texture.resource && texture.resource.canUpload) {
            texture.resource.upload(renderer, texture, glTexture);
        }
        // if (texture.resource && texture.resource.upload(renderer, texture, glTexture))
        else if (texture.resource && this.uploadTexture(renderer, texture, glTexture, texture.resource)) {
        }
        else {
            // default, renderTexture-like logic
            var width = texture.realWidth;
            var height = texture.realHeight;
            var gl = renderer.gl;
            if (glTexture.width !== width
                || glTexture.height !== height
                || glTexture.dirtyId < 0) {
                glTexture.width = width;
                glTexture.height = height;
                gl.texImage2D(texture.target, 0, texture.format, width, height, 0, texture.format, texture.type, null);
            }
        }
        // lets only update what changes..
        if (texture.dirtyStyleId !== glTexture.dirtyStyleId) {
            this.updateTextureStyle(texture);
        }
        glTexture.dirtyId = texture.dirtyId;
    }
    ;
    uploadTexture(renderer, baseTexture, glTexture, source) {
        var gl = renderer.gl;
        var width = baseTexture.realWidth;
        var height = baseTexture.realHeight;
        // source = source || this.source;
        if (source.constructor['name'] == "CanvasResource") {
            source = source.source;
        }
        else if (source.constructor['name'] == "ImageResource") {
            source = source.source;
        }
        else if (source.constructor['name'] == "VideoResource") {
            source = source.source;
        }
        // else if(source.constructor['name'] == "GradientResource")
        // {
        //     if(!source.source)
        //     {
        //         return
        //     }
        //     source = source.source
        //     reveal(source)
        // }
        else {
            Logger_1.reveal(source);
        }
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, baseTexture.premultiplyAlpha);
        if (baseTexture.target === gl.TEXTURE_2D && glTexture.width === width && glTexture.height === height) {
            gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, baseTexture.format, baseTexture.type, source);
        }
        else {
            glTexture.width = width;
            glTexture.height = height;
            gl.texImage2D(baseTexture.target, 0, baseTexture.format, baseTexture.format, baseTexture.type, source);
        }
        return true;
    }
    ;
    /**
     * Deletes the texture from WebGL
     *
     * @private
     * @param {PIXI.BaseTexture|PIXI.Texture} texture - the texture to destroy
     * @param {boolean} [skipRemove=false] - Whether to skip removing the texture from the TextureManager.
     */
    destroyTexture(texture, skipRemove = false) {
        var ref = this;
        var gl = ref.gl;
        texture = texture.baseTexture || texture;
        if (texture._glTextures[this.renderer.CONTEXT_UID]) {
            this.unbind(texture);
            gl.deleteTexture(texture._glTextures[this.renderer.CONTEXT_UID].texture);
            // texture.off('dispose', this.destroyTexture, this);
            delete texture._glTextures[this.renderer.CONTEXT_UID];
            if (!skipRemove) {
                var i = this.managedTextures.indexOf(texture);
                if (i !== -1) {
                    UtilsSettings_1.UtilsSettings.removeItems(this.managedTextures, i, 1);
                }
            }
        }
    }
    ;
    /**
     * Update texture style such as mipmap flag
     *
     * @private
     * @param {PIXI.BaseTexture} texture - Texture to update
     */
    updateTextureStyle(texture) {
        var glTexture = texture._glTextures[this.CONTEXT_UID];
        if (!glTexture) {
            return;
        }
        if ((texture.mipmap === WebGLSettings_1.WebGLSettings.MIPMAP_MODES.POW2 || this.webGLVersion !== 2) && !texture.isPowerOfTwo) {
            glTexture.mipmap = 0;
            glTexture.wrapMode = WebGLSettings_1.WebGLSettings.WRAP_MODES.CLAMP;
        }
        else {
            glTexture.mipmap = texture.mipmap >= 1;
            glTexture.wrapMode = texture.wrapMode;
        }
        // if (texture.resource && texture.resource.style(this.renderer, texture, glTexture))
        // { ; }
        // else
        // {
        this.setStyle(texture, glTexture);
        // }
        glTexture.dirtyStyleId = texture.dirtyStyleId;
    }
    ;
    /**
     * Set style for texture
     *
     * @private
     * @param {PIXI.BaseTexture} texture - Texture to update
     * @param {glTexture} glTexture
     */
    setStyle(texture, glTexture) {
        var gl = this.gl;
        if (glTexture.mipmap) {
            gl.generateMipmap(texture.target);
        }
        gl.texParameteri(texture.target, gl.TEXTURE_WRAP_S, glTexture.wrapMode);
        gl.texParameteri(texture.target, gl.TEXTURE_WRAP_T, glTexture.wrapMode);
        if (glTexture.mipmap) {
            /* eslint-disable max-len */
            gl.texParameteri(texture.target, gl.TEXTURE_MIN_FILTER, texture.scaleMode ? gl.LINEAR_MIPMAP_LINEAR : gl.NEAREST_MIPMAP_NEAREST);
            /* eslint-disable max-len */
        }
        else {
            gl.texParameteri(texture.target, gl.TEXTURE_MIN_FILTER, texture.scaleMode ? gl.LINEAR : gl.NEAREST);
        }
        gl.texParameteri(texture.target, gl.TEXTURE_MAG_FILTER, texture.scaleMode ? gl.LINEAR : gl.NEAREST);
    }
    ;
}
exports.TextureSystem = TextureSystem;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/TextureUvs.js":
/*!**********************************************!*\
  !*** ./js-compile/raw-pixi-ts/TextureUvs.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const GroupD8_1 = __webpack_require__(/*! ./GroupD8 */ "./js-compile/raw-pixi-ts/GroupD8.js");
class TextureUvs {
    constructor() {
        this.x0 = 0;
        this.y0 = 0;
        this.x1 = 1;
        this.y1 = 0;
        this.x2 = 1;
        this.y2 = 1;
        this.x3 = 0;
        this.y3 = 1;
        this.uvsFloat32 = new Float32Array(8);
    }
    /**
 * Sets the texture Uvs based on the given frame information.
 *
 * @protected
 * @param {PIXI.Rectangle} frame - The frame of the texture
 * @param {PIXI.Rectangle} baseFrame - The base frame of the texture
 * @param {number} rotate - Rotation of frame, see {@link PIXI.GroupD8}
 */
    set(frame, baseFrame, rotate) {
        var tw = baseFrame.width;
        var th = baseFrame.height;
        if (rotate) {
            // width and height div 2 div baseFrame size
            var w2 = frame.width / 2 / tw;
            var h2 = frame.height / 2 / th;
            // coordinates of center
            var cX = (frame.x / tw) + w2;
            var cY = (frame.y / th) + h2;
            rotate = GroupD8_1.GroupD8.add(rotate, GroupD8_1.GroupD8.NW); // NW is top-left corner
            this.x0 = cX + (w2 * GroupD8_1.GroupD8.uX(rotate));
            this.y0 = cY + (h2 * GroupD8_1.GroupD8.uY(rotate));
            rotate = GroupD8_1.GroupD8.add(rotate, 2); // rotate 90 degrees clockwise
            this.x1 = cX + (w2 * GroupD8_1.GroupD8.uX(rotate));
            this.y1 = cY + (h2 * GroupD8_1.GroupD8.uY(rotate));
            rotate = GroupD8_1.GroupD8.add(rotate, 2);
            this.x2 = cX + (w2 * GroupD8_1.GroupD8.uX(rotate));
            this.y2 = cY + (h2 * GroupD8_1.GroupD8.uY(rotate));
            rotate = GroupD8_1.GroupD8.add(rotate, 2);
            this.x3 = cX + (w2 * GroupD8_1.GroupD8.uX(rotate));
            this.y3 = cY + (h2 * GroupD8_1.GroupD8.uY(rotate));
        }
        else {
            this.x0 = frame.x / tw;
            this.y0 = frame.y / th;
            this.x1 = (frame.x + frame.width) / tw;
            this.y1 = frame.y / th;
            this.x2 = (frame.x + frame.width) / tw;
            this.y2 = (frame.y + frame.height) / th;
            this.x3 = frame.x / tw;
            this.y3 = (frame.y + frame.height) / th;
        }
        this.uvsFloat32[0] = this.x0;
        this.uvsFloat32[1] = this.y0;
        this.uvsFloat32[2] = this.x1;
        this.uvsFloat32[3] = this.y1;
        this.uvsFloat32[4] = this.x2;
        this.uvsFloat32[5] = this.y2;
        this.uvsFloat32[6] = this.x3;
        this.uvsFloat32[7] = this.y3;
    }
    ;
}
exports.TextureUvs = TextureUvs;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/Ticker.js":
/*!******************************************!*\
  !*** ./js-compile/raw-pixi-ts/Ticker.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const EventDispatcher_1 = __webpack_require__(/*! ./EventDispatcher */ "./js-compile/raw-pixi-ts/EventDispatcher.js");
const TickerListener_1 = __webpack_require__(/*! ./TickerListener */ "./js-compile/raw-pixi-ts/TickerListener.js");
const settings_1 = __webpack_require__(/*! ./settings */ "./js-compile/raw-pixi-ts/settings.js");
class Ticker extends EventDispatcher_1.EventDispatcher {
    constructor() {
        super();
        var this$1 = this;
        /**
         * The first listener. All new listeners added are chained on this.
         * @private
         * @type {TickerListener}
         */
        this._head = new TickerListener_1.TickerListener(null, null, Infinity);
        /**
         * Internal current frame request ID
         * @type {?number}
         * @private
         */
        this._requestId = null;
        /**
         * Internal value managed by minFPS property setter and getter.
         * This is the maximum allowed milliseconds between updates.
         * @type {number}
         * @private
         */
        this._maxElapsedMS = 100;
        /**
         * Internal value managed by maxFPS property setter and getter.
         * This is the minimum allowed milliseconds between updates.
         * @private
         */
        this._minElapsedMS = 0;
        /**
         * Whether or not this ticker should invoke the method
         * {@link PIXI.Ticker#start} automatically
         * when a listener is added.
         *
         * @member {boolean}
         * @default false
         */
        this.autoStart = false;
        /**
         * Scalar time value from last frame to this frame.
         * This value is capped by setting {@link PIXI.Ticker#minFPS}
         * and is scaled with {@link PIXI.Ticker#speed}.
         * **Note:** The cap may be exceeded by scaling.
         *
         * @member {number}
         * @default 1
         */
        this.deltaTime = 1;
        /**
         * Scaler time elapsed in milliseconds from last frame to this frame.
         * This value is capped by setting {@link PIXI.Ticker#minFPS}
         * and is scaled with {@link PIXI.Ticker#speed}.
         * **Note:** The cap may be exceeded by scaling.
         * If the platform supports DOMHighResTimeStamp,
         * this value will have a precision of 1 µs.
         * Defaults to target frame time
         *
         * @member {number}
         * @default 16.66
         */
        this.deltaMS = 1 / settings_1.settings.TARGET_FPMS;
        /**
         * Time elapsed in milliseconds from last frame to this frame.
         * Opposed to what the scalar {@link PIXI.Ticker#deltaTime}
         * is based, this value is neither capped nor scaled.
         * If the platform supports DOMHighResTimeStamp,
         * this value will have a precision of 1 µs.
         * Defaults to target frame time
         *
         * @member {number}
         * @default 16.66
         */
        this.elapsedMS = 1 / settings_1.settings.TARGET_FPMS;
        /**
         * The last time {@link PIXI.Ticker#update} was invoked.
         * This value is also reset internally outside of invoking
         * update, but only when a new animation frame is requested.
         * If the platform supports DOMHighResTimeStamp,
         * this value will have a precision of 1 µs.
         *
         * @member {number}
         * @default -1
         */
        this.lastTime = -1;
        /**
         * Factor of current {@link PIXI.Ticker#deltaTime}.
         * @example
         * // Scales ticker.deltaTime to what would be
         * // the equivalent of approximately 120 FPS
         * ticker.speed = 2;
         *
         * @member {number}
         * @default 1
         */
        this.speed = 1;
        /**
         * Whether or not this ticker has been started.
         * `true` if {@link PIXI.Ticker#start} has been called.
         * `false` if {@link PIXI.Ticker#stop} has been called.
         * While `false`, this value may change to `true` in the
         * event of {@link PIXI.Ticker#autoStart} being `true`
         * and a listener is added.
         *
         * @member {boolean}
         * @default false
         */
        this.started = false;
        /**
         * If enabled, deleting is disabled.
         * @member {boolean}
         * @default false
         * @private
         */
        this._protected = false;
        /**
         * Internal tick method bound to ticker instance.
         * This is because in early 2015, Function.bind
         * is still 60% slower in high performance scenarios.
         * Also separating frame requests from update method
         * so listeners may be called at any time and with
         * any animation API, just invoke ticker.update(time).
         *
         * @private
         * @param {number} time - Time since last tick.
         */
        this._tick = function (time) {
            this$1._requestId = null;
            if (this$1.started) {
                // Invoke listeners now
                this$1.update(time);
                // Listener side effects may have modified ticker state.
                if (this$1.started && this$1._requestId === null && this$1._head.next) {
                    this$1._requestId = requestAnimationFrame(this$1._tick);
                }
            }
        };
    }
    /**
     * Internally adds the event handler so that it can be sorted by priority.
     * Priority allows certain handler (user, AnimatedSprite, Interaction) to be run
     * before the rendering.
     *
     * @private
     * @param {TickerListener} listener - Current listener being added.
     * @returns {PIXI.Ticker} This instance of a ticker
     */
    _addListener(listener) {
        // For attaching to head
        var current = this._head.next;
        var previous = this._head;
        // Add the first item
        if (!current) {
            listener.connect(previous);
        }
        else {
            // Go from highest to lowest priority
            while (current) {
                if (listener.priority > current.priority) {
                    listener.connect(previous);
                    break;
                }
                previous = current;
                current = current.next;
            }
            // Not yet connected
            if (!listener.previous) {
                listener.connect(previous);
            }
        }
        this._startIfPossible();
        return this;
    }
    ;
    /**
     * Triggers an update. An update entails setting the
     * current {@link PIXI.Ticker#elapsedMS},
     * the current {@link PIXI.Ticker#deltaTime},
     * invoking all listeners with current deltaTime,
     * and then finally setting {@link PIXI.Ticker#lastTime}
     * with the value of currentTime that was provided.
     * This method will be called automatically by animation
     * frame callbacks if the ticker instance has been started
     * and listeners are added.
     *
     * @param {number} [currentTime=performance.now()] - the current time of execution
     */
    update(currentTime) {
        if (currentTime === void 0) {
            currentTime = performance.now();
        }
        var elapsedMS;
        // If the difference in time is zero or negative, we ignore most of the work done here.
        // If there is no valid difference, then should be no reason to let anyone know about it.
        // A zero delta, is exactly that, nothing should update.
        //
        // The difference in time can be negative, and no this does not mean time traveling.
        // This can be the result of a race condition between when an animation frame is requested
        // on the current JavaScript engine event loop, and when the ticker's start method is invoked
        // (which invokes the internal _requestIfNeeded method). If a frame is requested before
        // _requestIfNeeded is invoked, then the callback for the animation frame the ticker requests,
        // can receive a time argument that can be less than the lastTime value that was set within
        // _requestIfNeeded. This difference is in microseconds, but this is enough to cause problems.
        //
        // This check covers this browser engine timing issue, as well as if consumers pass an invalid
        // currentTime value. This may happen if consumers opt-out of the autoStart, and update themselves.
        if (currentTime > this.lastTime) {
            // Save uncapped elapsedMS for measurement
            elapsedMS = this.elapsedMS = currentTime - this.lastTime;
            // cap the milliseconds elapsed used for deltaTime
            if (elapsedMS > this._maxElapsedMS) {
                elapsedMS = this._maxElapsedMS;
            }
            elapsedMS *= this.speed;
            // if not enough time has passed, exit the function.
            // We give an extra ms to elapsedMS for this check, because the nature of
            // request animation frame means that not all browsers will return precise values.
            // However, because rAF works based on v-sync, it's won't change the effective FPS.
            if (this._minElapsedMS && elapsedMS + 1 < this._minElapsedMS) {
                return;
            }
            this.deltaMS = elapsedMS;
            this.deltaTime = this.deltaMS * settings_1.settings.TARGET_FPMS;
            // Cache a local reference, in-case ticker is destroyed
            // during the emit, we can still check for head.next
            var head = this._head;
            // Invoke listeners added to internal emitter
            var listener = head.next;
            while (listener) {
                listener = listener.emit(this.deltaTime);
            }
            if (!head.next) {
                this._cancelIfNeeded();
            }
        }
        else {
            this.deltaTime = this.deltaMS = this.elapsedMS = 0;
        }
        this.lastTime = currentTime;
    }
    ;
    /**
     * Destroy the ticker and don't use after this. Calling
     * this method removes all references to internal events.
     */
    destroy() {
        if (!this._protected) {
            this.stop();
            var listener = this._head.next;
            while (listener) {
                listener = listener.destroy(true);
            }
            this._head.destroy();
            this._head = null;
        }
    }
    ;
    /**
     * Stops the ticker. If the ticker has requested
     * an animation frame it is canceled at this point.
     */
    stop() {
        if (this.started) {
            this.started = false;
            this._cancelIfNeeded();
        }
    }
    ;
    /**
     * Starts the ticker. If the ticker has listeners
     * a new animation frame is requested at this point.
     */
    start() {
        if (!this.started) {
            this.started = true;
            this._requestIfNeeded();
        }
    }
    ;
    /**
     * Removes any handlers matching the function and context parameters.
     * If no handlers are left after removing, then it cancels the animation frame.
     *
     * @param {Function} fn - The listener function to be removed
     * @param {*} [context] - The listener context to be removed
     * @returns {PIXI.Ticker} This instance of a ticker
     */
    remove(fn, context) {
        var listener = this._head.next;
        while (listener) {
            // We found a match, lets remove it
            // no break to delete all possible matches
            // incase a listener was added 2+ times
            if (listener.match(fn, context)) {
                listener = listener.destroy();
            }
            else {
                listener = listener.next;
            }
        }
        if (!this._head.next) {
            this._cancelIfNeeded();
        }
        return this;
    }
    ;
    /**
     * Add a handler for the tick event which is only execute once.
     *
     * @param {Function} fn - The listener function to be added for one update
     * @param {*} [context] - The listener context
     * @param {number} [priority=PIXI.UPDATE_PRIORITY.NORMAL] - The priority for emitting
     * @returns {PIXI.Ticker} This instance of a ticker
     */
    addOnce(fn, context, priority) {
        if (priority === void 0) {
            priority = Ticker.UPDATE_PRIORITY.NORMAL;
        }
        return this._addListener(new TickerListener_1.TickerListener(fn, context, priority, true));
    }
    ;
    /**
     * Register a handler for tick events. Calls continuously unless
     * it is removed or the ticker is stopped.
     *
     * @param {Function} fn - The listener function to be added for updates
     * @param {*} [context] - The listener context
     * @param {number} [priority=PIXI.UPDATE_PRIORITY.NORMAL] - The priority for emitting
     * @returns {PIXI.Ticker} This instance of a ticker
     */
    add(fn, context = null, priority = null) {
        if (priority === void 0) {
            priority = Ticker.UPDATE_PRIORITY.NORMAL;
        }
        return this._addListener(new TickerListener_1.TickerListener(fn, context, priority));
    }
    ;
    /**
     * Conditionally requests a new animation frame.
     * If the ticker has been started it checks if a frame has not already
     * been requested, and if the internal emitter has listeners. If these
     * conditions are met, a new frame is requested. If the ticker has not
     * been started, but autoStart is `true`, then the ticker starts now,
     * and continues with the previous conditions to request a new frame.
     *
     * @private
     */
    _startIfPossible() {
        if (this.started) {
            this._requestIfNeeded();
        }
        else if (this.autoStart) {
            this.start();
        }
    }
    ;
    /**
     * Conditionally cancels a pending animation frame.
     *
     * @private
     */
    _cancelIfNeeded() {
        if (this._requestId !== null) {
            cancelAnimationFrame(this._requestId);
            this._requestId = null;
        }
    }
    ;
    /**
 * Conditionally requests a new animation frame.
 * If a frame has not already been requested, and if the internal
 * emitter has listeners, a new frame is requested.
 *
 * @private
 */
    _requestIfNeeded() {
        if (this._requestId === null && this._head.next) {
            // ensure callbacks get correct delta
            this.lastTime = performance.now();
            this._requestId = requestAnimationFrame(this._tick);
        }
    }
    ;
    /**
     * The frames per second at which this ticker is running.
     * The default is approximately 60 in most modern browsers.
     * **Note:** This does not factor in the value of
     * {@link PIXI.Ticker#speed}, which is specific
     * to scaling {@link PIXI.Ticker#deltaTime}.
     *
     * @member {number}
     * @readonly
     */
    get FPS() {
        return 1000 / this.elapsedMS;
    }
    ;
    /**
     * Manages the maximum amount of milliseconds allowed to
     * elapse between invoking {@link PIXI.Ticker#update}.
     * This value is used to cap {@link PIXI.Ticker#deltaTime},
     * but does not effect the measured value of {@link PIXI.Ticker#FPS}.
     * When setting this property it is clamped to a value between
     * `0` and `PIXI.settings.TARGET_FPMS * 1000`.
     *
     * @member {number}
     * @default 10
     */
    get minFPS() {
        return 1000 / this._maxElapsedMS;
    }
    ;
    set minFPS(fps) {
        // Minimum must be below the maxFPS
        var minFPS = Math.min(this.maxFPS, fps);
        // Must be at least 0, but below 1 / settings.TARGET_FPMS
        var minFPMS = Math.min(Math.max(0, minFPS) / 1000, settings_1.settings.TARGET_FPMS);
        this._maxElapsedMS = 1 / minFPMS;
    }
    ;
    set maxFPS(fps) {
        if (fps / 1000 >= settings_1.settings.TARGET_FPMS) {
            this._minElapsedMS = 0;
        }
        else {
            // Max must be at least the minFPS
            var maxFPS = Math.max(this.minFPS, fps);
            // Must be at least 1, but below 1 / settings.TARGET_FPMS
            var maxFPMS = Math.min(Math.max(1, maxFPS) / 1000, settings_1.settings.TARGET_FPMS);
            this._minElapsedMS = 1 / maxFPMS;
        }
    }
    ;
    /**
 * The shared ticker instance used by {@link PIXI.AnimatedSprite} and by
 * {@link PIXI.VideoResource} to update animation frames / video textures.
 *
 * It may also be used by {@link PIXI.Application} if created with the `sharedTicker` option property set to true.
 *
 * The property {@link PIXI.Ticker#autoStart} is set to `true` for this instance.
 * Please follow the examples for usage, including how to opt-out of auto-starting the shared ticker.
 *
 * @example
 * let ticker = PIXI.Ticker.shared;
 * // Set this to prevent starting this ticker when listeners are added.
 * // By default this is true only for the PIXI.Ticker.shared instance.
 * ticker.autoStart = false;
 * // FYI, call this to ensure the ticker is stopped. It should be stopped
 * // if you have not attempted to render anything yet.
 * ticker.stop();
 * // Call this when you are ready for a running shared ticker.
 * ticker.start();
 *
 * @example
 * // You may use the shared ticker to render...
 * let renderer = PIXI.autoDetectRenderer();
 * let stage = new PIXI.Container();
 * document.body.appendChild(renderer.view);
 * ticker.add(function (time) {
 * renderer.render(stage);
 * });
 *
 * @example
 * // Or you can just update it manually.
 * ticker.autoStart = false;
 * ticker.stop();
 * function animate(time) {
 * ticker.update(time);
 * renderer.render(stage);
 * requestAnimationFrame(animate);
 * }
 * animate(performance.now());
 *
 * @member {PIXI.Ticker}
 * @static
 */
    static get shared() {
        if (!Ticker._shared) {
            var shared = Ticker._shared = new Ticker();
            shared.autoStart = true;
            shared._protected = true;
        }
        return Ticker._shared;
    }
    ;
    /**
     * The system ticker instance used by {@link PIXI.interaction.InteractionManager} and by
     * {@link PIXI.BasePrepare} for core timing functionality that shouldn't usually need to be paused,
     * unlike the `shared` ticker which drives visual animations and rendering which may want to be paused.
     *
     * The property {@link PIXI.Ticker#autoStart} is set to `true` for this instance.
     *
     * @member {PIXI.Ticker}
     * @static
     */
    static get system() {
        if (!Ticker._system) {
            var system = Ticker._system = new Ticker();
            system.autoStart = true;
            system._protected = true;
        }
        return Ticker._system;
    }
    ;
    /**
     * Manages the minimum amount of milliseconds allowed to
     * elapse between invoking {@link PIXI.Ticker#update}.
     * This will effect the measured value of {@link PIXI.ticker.Ticker#FPS}.
     * When setting this property it is clamped to a value between
     * `1` and `TARGET_FPMS * 1000`.
     *
     * @member {number}
     * @default 60
     */
    get maxFPS() {
        if (this._minElapsedMS) {
            return 1000 / this._minElapsedMS;
        }
        return settings_1.settings.TARGET_FPMS * 1000;
    }
    ;
}
/**
 * Represents the update priorities used by internal PIXI classes when registered with
 * the {@link PIXI.Ticker} object. Higher priority items are updated first and lower
 * priority items, such as render, should go later.
 *
 * @static
 * @constant
 * @name UPDATE_PRIORITY
 * @memberof PIXI
 * @type {object}
 * @property {number} INTERACTION=50 Highest priority, used for {@link PIXI.interaction.InteractionManager}
 * @property {number} HIGH=25 High priority updating, {@link PIXI.VideoBaseTexture} and {@link PIXI.AnimatedSprite}
 * @property {number} NORMAL=0 Default priority for ticker events, see {@link PIXI.Ticker#add}.
 * @property {number} LOW=-25 Low priority used for {@link PIXI.Application} rendering.
 * @property {number} UTILITY=-50 Lowest priority used for {@link PIXI.prepare.BasePrepare} utility.
 */
Ticker.UPDATE_PRIORITY = {
    INTERACTION: 50,
    HIGH: 25,
    NORMAL: 0,
    LOW: -25,
    UTILITY: -50,
};
exports.Ticker = Ticker;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/TickerListener.js":
/*!**************************************************!*\
  !*** ./js-compile/raw-pixi-ts/TickerListener.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class TickerListener {
    constructor(fn, context, priority, once = false) {
        if (context === void 0) {
            context = null;
        }
        if (priority === void 0) {
            priority = 0;
        }
        if (once === void 0) {
            once = false;
        }
        /**
         * The handler function to execute.
         * @private
         * @member {Function}
         */
        this.fn = fn;
        /**
         * The calling to execute.
         * @private
         * @member {*}
         */
        this.context = context;
        /**
         * The current priority.
         * @private
         * @member {number}
         */
        this.priority = priority;
        /**
         * If this should only execute once.
         * @private
         * @member {boolean}
         */
        this.once = once;
        /**
         * The next item in chain.
         * @private
         * @member {TickerListener}
         */
        this.next = null;
        /**
         * The previous item in chain.
         * @private
         * @member {TickerListener}
         */
        this.previous = null;
        /**
         * `true` if this listener has been destroyed already.
         * @member {boolean}
         * @private
         */
        this._destroyed = false;
    }
    /**
     * Emit by calling the current function.
     * @private
     * @param {number} deltaTime - time since the last emit.
     * @return {TickerListener} Next ticker
     */
    emit(deltaTime) {
        if (this.fn) {
            if (this.context) {
                this.fn.call(this.context, deltaTime);
            }
            else {
                this.fn(deltaTime);
            }
        }
        var redirect = this.next;
        if (this.once) {
            this.destroy(true);
        }
        // Soft-destroying should remove
        // the next reference
        if (this._destroyed) {
            this.next = null;
        }
        return redirect;
    }
    ;
    /**
     * Destroy and don't use after this.
     * @private
     * @param {boolean} [hard = false] `true` to remove the `next` reference, this
     *    is considered a hard destroy. Soft destroy maintains the next reference.
     * @return {TickerListener} The listener to redirect while emitting or removing.
     */
    destroy(hard) {
        if (hard === void 0) {
            hard = false;
        }
        this._destroyed = true;
        this.fn = null;
        this.context = null;
        // Disconnect, hook up next and previous
        if (this.previous) {
            this.previous.next = this.next;
        }
        if (this.next) {
            this.next.previous = this.previous;
        }
        // Redirect to the next item
        var redirect = this.next;
        // Remove references
        this.next = hard ? null : redirect;
        this.previous = null;
        return redirect;
    }
    ;
    /**
     * Connect to the list.
     * @private
     * @param {TickerListener} previous - Input node, previous listener
     */
    connect(previous) {
        this.previous = previous;
        if (previous.next) {
            previous.next.previous = this;
        }
        this.next = previous.next;
        previous.next = this;
    }
    ;
    /**
     * Simple compare function to figure out if a function and context match.
     * @private
     * @param {Function} fn - The listener function to be added for one update
     * @param {Function} context - The listener context
     * @return {boolean} `true` if the listener match the arguments
     */
    match(fn, context) {
        context = context || null;
        return this.fn === fn && this.context === context;
    }
    ;
}
exports.TickerListener = TickerListener;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/TilingSpriteRenderer.js":
/*!********************************************************!*\
  !*** ./js-compile/raw-pixi-ts/TilingSpriteRenderer.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const ObjectRenderer_1 = __webpack_require__(/*! ./ObjectRenderer */ "./js-compile/raw-pixi-ts/ObjectRenderer.js");
const Shader_1 = __webpack_require__(/*! ./Shader */ "./js-compile/raw-pixi-ts/Shader.js");
const QuadUv_1 = __webpack_require__(/*! ./QuadUv */ "./js-compile/raw-pixi-ts/QuadUv.js");
const Matrix_1 = __webpack_require__(/*! ./Matrix */ "./js-compile/raw-pixi-ts/Matrix.js");
const WebGLSettings_1 = __webpack_require__(/*! ./WebGLSettings */ "./js-compile/raw-pixi-ts/WebGLSettings.js");
const ColorSettings_1 = __webpack_require__(/*! ./ColorSettings */ "./js-compile/raw-pixi-ts/ColorSettings.js");
const BlendModesSettings_1 = __webpack_require__(/*! ./BlendModesSettings */ "./js-compile/raw-pixi-ts/BlendModesSettings.js");
class TilingSpriteRenderer extends ObjectRenderer_1.ObjectRenderer {
    constructor(renderer) {
        super(renderer);
        var uniforms = { globals: this.renderer.globalUniforms };
        this.shader = Shader_1.Shader.from(TilingSpriteRenderer.vertex$3, TilingSpriteRenderer.fragment$2, uniforms);
        this.simpleShader = Shader_1.Shader.from(TilingSpriteRenderer.vertex$3, TilingSpriteRenderer.fragmentSimple, uniforms);
        this.quad = new QuadUv_1.QuadUv();
    }
    /**
     *
     * @param {PIXI.TilingSprite} ts tilingSprite to be rendered
     */
    render(ts) {
        var renderer = this.renderer;
        var quad = this.quad;
        var vertices = quad.vertices;
        vertices[0] = vertices[6] = (ts._width) * -ts.anchor.x;
        vertices[1] = vertices[3] = ts._height * -ts.anchor.y;
        vertices[2] = vertices[4] = (ts._width) * (1.0 - ts.anchor.x);
        vertices[5] = vertices[7] = ts._height * (1.0 - ts.anchor.y);
        if (ts.uvRespectAnchor) {
            vertices = quad.uvs;
            vertices[0] = vertices[6] = -ts.anchor.x;
            vertices[1] = vertices[3] = -ts.anchor.y;
            vertices[2] = vertices[4] = 1.0 - ts.anchor.x;
            vertices[5] = vertices[7] = 1.0 - ts.anchor.y;
        }
        quad.invalidate();
        var tex = ts._texture;
        var baseTex = tex.baseTexture;
        var lt = ts.tileTransform.localTransform;
        var uv = ts.uvMatrix;
        var isSimple = baseTex.isPowerOfTwo
            && tex.frame.width === baseTex.width && tex.frame.height === baseTex.height;
        // auto, force repeat wrapMode for big tiling textures
        if (isSimple) {
            if (!baseTex._glTextures[renderer.CONTEXT_UID]) {
                if (baseTex.wrapMode === WebGLSettings_1.WebGLSettings.WRAP_MODES.CLAMP) {
                    baseTex.wrapMode = WebGLSettings_1.WebGLSettings.WRAP_MODES.REPEAT;
                }
            }
            else {
                isSimple = baseTex.wrapMode !== WebGLSettings_1.WebGLSettings.WRAP_MODES.CLAMP;
            }
        }
        var shader = isSimple ? this.simpleShader : this.shader;
        var w = tex.width;
        var h = tex.height;
        var W = ts._width;
        var H = ts._height;
        TilingSpriteRenderer.tempMat$1.set(lt.a * w / W, lt.b * w / H, lt.c * h / W, lt.d * h / H, lt.tx / W, lt.ty / H);
        // that part is the same as above:
        // tempMat.identity();
        // tempMat.scale(tex.width, tex.height);
        // tempMat.prepend(lt);
        // tempMat.scale(1.0 / ts._width, 1.0 / ts._height);
        TilingSpriteRenderer.tempMat$1.invert();
        if (isSimple) {
            TilingSpriteRenderer.tempMat$1.prepend(uv.mapCoord);
        }
        else {
            shader.uniforms.uMapCoord = uv.mapCoord.toArray(true);
            shader.uniforms.uClampFrame = uv.uClampFrame;
            shader.uniforms.uClampOffset = uv.uClampOffset;
        }
        shader.uniforms.uTransform = TilingSpriteRenderer.tempMat$1.toArray(true);
        shader.uniforms.uColor = ColorSettings_1.ColorSettings.premultiplyTintToRgba(ts.tint, ts.worldAlpha, shader.uniforms.uColor, baseTex.premultiplyAlpha);
        shader.uniforms.translationMatrix = ts.transform.worldTransform.toArray(true);
        shader.uniforms.uSampler = tex;
        renderer.shader.bind(shader);
        renderer.geometry.bind(quad); // , renderer.shader.getGLShader());
        renderer.state.setBlendMode(BlendModesSettings_1.BlendModesSettings.correctBlendMode(ts.blendMode, baseTex.premultiplyAlpha));
        renderer.geometry.draw(this.renderer.gl.TRIANGLES, 6, 0);
    }
    ;
}
TilingSpriteRenderer.fragmentSimple = "varying vec2 vTextureCoord;\r\n\r\nuniform sampler2D uSampler;\r\nuniform vec4 uColor;\r\n\r\nvoid main(void)\r\n{\r\n    vec4 sample = texture2D(uSampler, vTextureCoord);\r\n    gl_FragColor = sample * uColor;\r\n}\r\n";
TilingSpriteRenderer.fragment$2 = "varying vec2 vTextureCoord;\r\n\r\nuniform sampler2D uSampler;\r\nuniform vec4 uColor;\r\nuniform mat3 uMapCoord;\r\nuniform vec4 uClampFrame;\r\nuniform vec2 uClampOffset;\r\n\r\nvoid main(void)\r\n{\r\n    vec2 coord = mod(vTextureCoord - uClampOffset, vec2(1.0, 1.0)) + uClampOffset;\r\n    coord = (uMapCoord * vec3(coord, 1.0)).xy;\r\n    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\r\n\r\n    vec4 sample = texture2D(uSampler, coord);\r\n    gl_FragColor = sample * uColor;\r\n}\r\n";
TilingSpriteRenderer.vertex$3 = "attribute vec2 aVertexPosition;\r\nattribute vec2 aTextureCoord;\r\n\r\nuniform mat3 projectionMatrix;\r\nuniform mat3 translationMatrix;\r\nuniform mat3 uTransform;\r\n\r\nvarying vec2 vTextureCoord;\r\n\r\nvoid main(void)\r\n{\r\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\r\n\r\n    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;\r\n}\r\n";
TilingSpriteRenderer.tempMat$1 = new Matrix_1.Matrix();
exports.TilingSpriteRenderer = TilingSpriteRenderer;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/Transform.js":
/*!*********************************************!*\
  !*** ./js-compile/raw-pixi-ts/Transform.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Matrix_1 = __webpack_require__(/*! ./Matrix */ "./js-compile/raw-pixi-ts/Matrix.js");
const ObservablePoint_1 = __webpack_require__(/*! ./ObservablePoint */ "./js-compile/raw-pixi-ts/ObservablePoint.js");
class Transform {
    constructor() {
        /**
                 * The global matrix transform. It can be swapped temporarily by some functions like getLocalBounds()
                 *
                 * @member {PIXI.Matrix}
                 */
        this.worldTransform = new Matrix_1.Matrix();
        /**
         * The local matrix transform
         *
         * @member {PIXI.Matrix}
         */
        this.localTransform = new Matrix_1.Matrix();
        /**
         * The coordinate of the object relative to the local coordinates of the parent.
         *
         * @member {PIXI.ObservablePoint}
         */
        this.position = new ObservablePoint_1.ObservablePoint(this.onChange, this, 0, 0);
        /**
         * The scale factor of the object.
         *
         * @member {PIXI.ObservablePoint}
         */
        this.scale = new ObservablePoint_1.ObservablePoint(this.onChange, this, 1, 1);
        /**
         * The pivot point of the displayObject that it rotates around.
         *
         * @member {PIXI.ObservablePoint}
         */
        this.pivot = new ObservablePoint_1.ObservablePoint(this.onChange, this, 0, 0);
        /**
         * The skew amount, on the x and y axis.
         *
         * @member {PIXI.ObservablePoint}
         */
        this.skew = new ObservablePoint_1.ObservablePoint(this.updateSkew, this, 0, 0);
        this._rotation = 0;
        this._cx = 1; // cos rotation + skewY;
        this._sx = 0; // sin rotation + skewY;
        this._cy = 0; // cos rotation + Math.PI/2 - skewX;
        this._sy = 1; // sin rotation + Math.PI/2 - skewX;
        this._localID = 0;
        this._currentLocalID = 0;
        this._worldID = 0;
        this._parentID = 0;
    }
    /**
     * Called when a value changes.
     *
     * @private
     */
    onChange() {
        this._localID++;
    }
    ;
    /**
     * Called when skew or rotation changes
     *
     * @private
     */
    updateSkew() {
        this._cx = Math.cos(this._rotation + this.skew._y);
        this._sx = Math.sin(this._rotation + this.skew._y);
        this._cy = -Math.sin(this._rotation - this.skew._x); // cos, added PI/2
        this._sy = Math.cos(this._rotation - this.skew._x); // sin, added PI/2
        this._localID++;
    }
    ;
    /**
     * Updates only local matrix
     */
    updateLocalTransform() {
        var lt = this.localTransform;
        if (this._localID !== this._currentLocalID) {
            // get the matrix values of the displayobject based on its transform properties..
            lt.a = this._cx * this.scale._x;
            lt.b = this._sx * this.scale._x;
            lt.c = this._cy * this.scale._y;
            lt.d = this._sy * this.scale._y;
            lt.tx = this.position._x - ((this.pivot._x * lt.a) + (this.pivot._y * lt.c));
            lt.ty = this.position._y - ((this.pivot._x * lt.b) + (this.pivot._y * lt.d));
            this._currentLocalID = this._localID;
            // force an update..
            this._parentID = -1;
        }
    }
    ;
    /**
     * Updates the values of the object and applies the parent's transform.
     *
     * @param {PIXI.Transform} parentTransform - The transform of the parent of this object
     */
    updateTransform(parentTransform) {
        var lt = this.localTransform;
        if (this._localID !== this._currentLocalID) {
            // get the matrix values of the displayobject based on its transform properties..
            lt.a = this._cx * this.scale._x;
            lt.b = this._sx * this.scale._x;
            lt.c = this._cy * this.scale._y;
            lt.d = this._sy * this.scale._y;
            lt.tx = this.position._x - ((this.pivot._x * lt.a) + (this.pivot._y * lt.c));
            lt.ty = this.position._y - ((this.pivot._x * lt.b) + (this.pivot._y * lt.d));
            this._currentLocalID = this._localID;
            // force an update..
            this._parentID = -1;
        }
        if (this._parentID !== parentTransform._worldID) {
            // concat the parent matrix with the objects transform.
            var pt = parentTransform.worldTransform;
            var wt = this.worldTransform;
            wt.a = (lt.a * pt.a) + (lt.b * pt.c);
            wt.b = (lt.a * pt.b) + (lt.b * pt.d);
            wt.c = (lt.c * pt.a) + (lt.d * pt.c);
            wt.d = (lt.c * pt.b) + (lt.d * pt.d);
            wt.tx = (lt.tx * pt.a) + (lt.ty * pt.c) + pt.tx;
            wt.ty = (lt.tx * pt.b) + (lt.ty * pt.d) + pt.ty;
            this._parentID = parentTransform._worldID;
            // update the id of the transform..
            this._worldID++;
        }
    }
    ;
    /**
     * Decomposes a matrix and sets the transforms properties based on it.
     *
     * @param {PIXI.Matrix} matrix - The matrix to decompose
     */
    setFromMatrix(matrix) {
        matrix.decompose(this);
        this._localID++;
    }
    ;
    /**
     * The rotation of the object in radians.
     *
     * @member {number}
     */
    get rotation() {
        return this._rotation;
    }
    ;
    set rotation(value) {
        if (this._rotation !== value) {
            this._rotation = value;
            this.updateSkew();
        }
    }
    ;
}
Transform.IDENTITY = new Transform();
exports.Transform = Transform;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/URLLoader.js":
/*!*********************************************!*\
  !*** ./js-compile/raw-pixi-ts/URLLoader.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const IOErrorEvent_1 = __webpack_require__(/*! ./IOErrorEvent */ "./js-compile/raw-pixi-ts/IOErrorEvent.js");
const EventDispatcher_1 = __webpack_require__(/*! ./EventDispatcher */ "./js-compile/raw-pixi-ts/EventDispatcher.js");
const Event_1 = __webpack_require__(/*! ./Event */ "./js-compile/raw-pixi-ts/Event.js");
class URLLoader extends EventDispatcher_1.EventDispatcher {
    constructor() {
        super();
        this.onHttpResponse = () => {
            if (this.xmlhttp.readyState == 4 && this.xmlhttp.status == 200) {
                this._data = this.xmlhttp.responseText;
                this.dispatchEvent(Event_1.Event.getEvent(Event_1.Event.COMPLETE));
            }
            else if (this.xmlhttp.readyState == 4 && this.xmlhttp.status == 0 && this.xmlhttp.responseText) {
                this._data = this.xmlhttp.responseText;
                this.dispatchEvent(Event_1.Event.getEvent(Event_1.Event.COMPLETE));
            }
            else if (this.xmlhttp.readyState == 4 && this.xmlhttp.status == 404) {
                var errorevent = new IOErrorEvent_1.IOErrorEvent(IOErrorEvent_1.IOErrorEvent.IO_ERROR);
                errorevent.text = "Could not find file " + this.request.url;
                errorevent.errorId = 404;
                this.dispatchEvent(errorevent);
            }
            else if (this.xmlhttp.readyState == 4 && this.xmlhttp.status == 403) {
                var errorevent = new IOErrorEvent_1.IOErrorEvent(IOErrorEvent_1.IOErrorEvent.IO_ERROR);
                errorevent.text = "Cross Origin Error " + this.request.url;
                errorevent.errorId = 403;
                this.dispatchEvent(errorevent);
            }
            else if (this.xmlhttp.readyState == 4 && this.xmlhttp.status != 200) {
                var errorevent = new IOErrorEvent_1.IOErrorEvent(IOErrorEvent_1.IOErrorEvent.IO_ERROR);
                errorevent.text = "Unkown Error " + this.request.url;
                errorevent.errorId = this.xmlhttp.status;
                this.dispatchEvent(errorevent);
            }
        };
        this.xmlhttp = new XMLHttpRequest();
    }
    destructor() {
        super.destructor();
        if (this.xmlhttp) {
            this.xmlhttp.onreadystatechange = null;
        }
        this.xmlhttp = null;
        if (this.request) {
            this.request.destructor();
        }
        this.request = null;
        this._data = null;
    }
    get url() {
        if (this.request) {
            return this.request.url;
        }
        return null;
    }
    get data() {
        return this._data;
    }
    set data(value) {
    }
    close() {
    }
    load(value) {
        this.request = value;
        var path = this.request.url;
        if (!path) {
            return;
        }
        if (this.request.data) {
            var params = '';
            for (var key in this.request.data) {
                params += key + "=" + this.request.data[key] + "&";
            }
            params = params.substr(0, params.length - 1);
            path += "?" + params;
        }
        this.xmlhttp.open(this.request.method, path, true);
        this.xmlhttp.onreadystatechange = this.onHttpResponse;
        if (path.indexOf(".json") < 0) {
            if (this.request.contentType != 'json') {
                this.xmlhttp.setRequestHeader('Content-Type', 'text/xml');
            }
        }
        if (this.request.envelop) {
            this.xmlhttp.send(this.request.envelop);
        }
        else {
            this.xmlhttp.send();
        }
    }
    get dataFormat() {
        return null;
    }
    set dataFormat(value) {
    }
}
exports.URLLoader = URLLoader;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/URLRequest.js":
/*!**********************************************!*\
  !*** ./js-compile/raw-pixi-ts/URLRequest.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const URLRequestMethod_1 = __webpack_require__(/*! ./URLRequestMethod */ "./js-compile/raw-pixi-ts/URLRequestMethod.js");
const FlashBaseObject_1 = __webpack_require__(/*! ./FlashBaseObject */ "./js-compile/raw-pixi-ts/FlashBaseObject.js");
class URLRequest extends FlashBaseObject_1.FlashBaseObject {
    constructor(path = null) {
        super();
        this._requestMetaData = new RequestMetaData();
        this._timeout = 0;
        this._crossOrigin = true;
        this.reset(path);
    }
    destructor() {
        this._url = null;
        this._method = URLRequestMethod_1.URLRequestMethod.POST;
        let index = URLRequest.URLRequestCache.indexOf(this);
        if (index < 0) {
            URLRequest.URLRequestCache.push(this);
        }
    }
    reset(path = null) {
        this._url = path;
        this._method = URLRequestMethod_1.URLRequestMethod.POST;
        this._contentType = null;
        this._envelop = null;
        this._data = null;
    }
    static getURLRequest(path = null) {
        if (URLRequest.URLRequestCache.length) {
            let ur = URLRequest.URLRequestCache[URLRequest.URLRequestCache.length - 1];
            URLRequest.URLRequestCache.length -= 1;
            ur.reset(path);
            return ur;
        }
        return new URLRequest(path);
    }
    set requestMetaData(value) {
        this._requestMetaData = value;
    }
    get requestMetaData() {
        return this._requestMetaData;
    }
    set timeout(value) {
        this._timeout = value;
    }
    get timeout() {
        return this._timeout;
    }
    set crossOrigin(value) {
        this._crossOrigin = value;
    }
    get crossOrigin() {
        return this._crossOrigin;
    }
    set envelop(value) {
        this._envelop = value;
    }
    get envelop() {
        return this._envelop;
    }
    get requestHeaders() {
        return null;
    }
    set requestHeaders(value) {
    }
    get contentType() {
        return this._contentType;
    }
    set contentType(value) {
        this._contentType = value;
    }
    get url() {
        return this._url;
    }
    set url(value) {
        this._url = value;
    }
    set data(value) {
        this._data = value;
    }
    get data() {
        return this._data;
    }
    get method() {
        return this._method;
    }
    set method(value) {
        this._method = value;
    }
}
URLRequest.URLRequestCache = [];
exports.URLRequest = URLRequest;
class RequestMetaData {
    constructor() {
        this.mimeType = '';
        this.skipSource = false;
    }
}
exports.RequestMetaData = RequestMetaData;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/URLRequestMethod.js":
/*!****************************************************!*\
  !*** ./js-compile/raw-pixi-ts/URLRequestMethod.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class URLRequestMethod {
}
URLRequestMethod.GET = "GET";
URLRequestMethod.POST = "POST";
exports.URLRequestMethod = URLRequestMethod;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/UniformGroup.js":
/*!************************************************!*\
  !*** ./js-compile/raw-pixi-ts/UniformGroup.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class UniformGroup {
    constructor(uniforms = null, _static = null) {
        /**
                 * uniform values
                 * @member {object}
                 * @readonly
                 */
        this.uniforms = uniforms;
        /**
         * Its a group and not a single uniforms
         * @member {boolean}
         * @readonly
         * @default true
         */
        this.group = true;
        // lets generate this when the shader ?
        this.syncUniforms = {};
        /**
         * dirty version
         * @protected
         * @member {number}
         */
        this.dirtyId = 0;
        /**
         * unique id
         * @protected
         * @member {number}
         */
        this.id = UniformGroup.UID$2++;
        /**
         * Uniforms wont be changed after creation
         * @member {boolean}
         */
        this.static = !!_static;
    }
    update() {
        this.dirtyId++;
    }
    ;
    add(name, uniforms, _static) {
        this.uniforms[name] = new UniformGroup(uniforms, _static);
    }
    ;
    static from(uniforms, _static) {
        return new UniformGroup(uniforms, _static);
    }
    ;
}
UniformGroup.UID$2 = 0;
exports.UniformGroup = UniformGroup;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/Url.js":
/*!***************************************!*\
  !*** ./js-compile/raw-pixi-ts/Url.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const UtilsSettings_1 = __webpack_require__(/*! ./UtilsSettings */ "./js-compile/raw-pixi-ts/UtilsSettings.js");
class Url {
    constructor() {
        this.protocol = null;
        this.slashes = null;
        this.auth = null;
        this.host = null;
        this.port = null;
        this.hostname = null;
        this.hash = null;
        this.search = null;
        this.query = null;
        this.pathname = null;
        this.path = null;
        this.href = null;
    }
    // format a parsed object into a url string
    static urlFormat(obj) {
        // ensure it's an object, and not a string url.
        // If it's an obj, this is a no-op.
        // this way, you can call url_format() on strings
        // to clean up potentially wonky urls.
        if (UtilsSettings_1.UtilsSettings.util.isString(obj)) {
            obj = Url.urlParse(obj);
        }
        if (!(obj instanceof Url)) {
            return Url.prototype.format.call(obj);
        }
        return obj.format();
    }
    static urlResolveObject(source, relative) {
        if (!source) {
            return relative;
        }
        return Url.urlParse(source, false, true).resolveObject(relative);
    }
    static urlResolve(source, relative) {
        return Url.urlParse(source, false, true).resolve(relative);
    }
    resolveObject(relative) {
        if (UtilsSettings_1.UtilsSettings.util.isString(relative)) {
            var rel = new Url();
            rel.parse(relative, false, true);
            relative = rel;
        }
        var result = new Url();
        var tkeys = Object.keys(this);
        for (var tk = 0; tk < tkeys.length; tk++) {
            var tkey = tkeys[tk];
            result[tkey] = this[tkey];
        }
        // hash is always overridden, no matter what.
        // even href="" will remove it.
        result.hash = relative.hash;
        // if the relative url is empty, then there's nothing left to do here.
        if (relative.href === '') {
            result.href = result.format();
            return result;
        }
        // hrefs like //foo/bar always cut to the protocol.
        if (relative.slashes && !relative.protocol) {
            // take everything except the protocol from relative
            var rkeys = Object.keys(relative);
            for (var rk = 0; rk < rkeys.length; rk++) {
                var rkey = rkeys[rk];
                if (rkey !== 'protocol') {
                    result[rkey] = relative[rkey];
                }
            }
            //urlParse appends trailing / to urls like http://www.example.com
            if (Url.slashedProtocol[result.protocol] &&
                result.hostname && !result.pathname) {
                result.path = result.pathname = '/';
            }
            result.href = result.format();
            return result;
        }
        if (relative.protocol && relative.protocol !== result.protocol) {
            // if it's a known url protocol, then changing
            // the protocol does weird things
            // first, if it's not file:, then we MUST have a host,
            // and if there was a path
            // to begin with, then we MUST have a path.
            // if it is file:, then the host is dropped,
            // because that's known to be hostless.
            // anything else is assumed to be absolute.
            if (!Url.slashedProtocol[relative.protocol]) {
                var keys = Object.keys(relative);
                for (var v = 0; v < keys.length; v++) {
                    var k = keys[v];
                    result[k] = relative[k];
                }
                result.href = result.format();
                return result;
            }
            result.protocol = relative.protocol;
            if (!relative.host && !Url.hostlessProtocol[relative.protocol]) {
                var relPath = (relative.pathname || '').split('/');
                while (relPath.length && !(relative.host = relPath.shift())) {
                    ;
                }
                if (!relative.host) {
                    relative.host = '';
                }
                if (!relative.hostname) {
                    relative.hostname = '';
                }
                if (relPath[0] !== '') {
                    relPath.unshift('');
                }
                if (relPath.length < 2) {
                    relPath.unshift('');
                }
                result.pathname = relPath.join('/');
            }
            else {
                result.pathname = relative.pathname;
            }
            result.search = relative.search;
            result.query = relative.query;
            result.host = relative.host || '';
            result.auth = relative.auth;
            result.hostname = relative.hostname || relative.host;
            result.port = relative.port;
            // to support http.request
            if (result.pathname || result.search) {
                var p = result.pathname || '';
                var s = result.search || '';
                result.path = p + s;
            }
            result.slashes = result.slashes || relative.slashes;
            result.href = result.format();
            return result;
        }
        var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'), isRelAbs = (relative.host ||
            relative.pathname && relative.pathname.charAt(0) === '/'), mustEndAbs = (isRelAbs || isSourceAbs ||
            (result.host && relative.pathname)), removeAllDots = mustEndAbs, srcPath = result.pathname && result.pathname.split('/') || [], relPath = relative.pathname && relative.pathname.split('/') || [], psychotic = result.protocol && !Url.slashedProtocol[result.protocol];
        // if the url is a non-slashed url, then relative
        // links like ../.. should be able
        // to crawl up to the hostname, as well.  This is strange.
        // result.protocol has already been set by now.
        // Later on, put the first path part into the host field.
        if (psychotic) {
            result.hostname = '';
            result.port = null;
            if (result.host) {
                if (srcPath[0] === '') {
                    srcPath[0] = result.host;
                }
                else {
                    srcPath.unshift(result.host);
                }
            }
            result.host = '';
            if (relative.protocol) {
                relative.hostname = null;
                relative.port = null;
                if (relative.host) {
                    if (relPath[0] === '') {
                        relPath[0] = relative.host;
                    }
                    else {
                        relPath.unshift(relative.host);
                    }
                }
                relative.host = null;
            }
            mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
        }
        if (isRelAbs) {
            // it's absolute.
            result.host = (relative.host || relative.host === '') ?
                relative.host : result.host;
            result.hostname = (relative.hostname || relative.hostname === '') ?
                relative.hostname : result.hostname;
            result.search = relative.search;
            result.query = relative.query;
            srcPath = relPath;
            // fall through to the dot-handling below.
        }
        else if (relPath.length) {
            // it's relative
            // throw away the existing file, and take the new path instead.
            if (!srcPath) {
                srcPath = [];
            }
            srcPath.pop();
            srcPath = srcPath.concat(relPath);
            result.search = relative.search;
            result.query = relative.query;
        }
        else if (!UtilsSettings_1.UtilsSettings.util.isNullOrUndefined(relative.search)) {
            // just pull out the search.
            // like href='?foo'.
            // Put this after the other two cases because it simplifies the booleans
            if (psychotic) {
                result.hostname = result.host = srcPath.shift();
                //occationaly the auth can get stuck only in host
                //this especially happens in cases like
                //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
                var authInHost = result.host && result.host.indexOf('@') > 0 ?
                    result.host.split('@') : false;
                if (authInHost) {
                    result.auth = authInHost.shift();
                    result.host = result.hostname = authInHost.shift();
                }
            }
            result.search = relative.search;
            result.query = relative.query;
            //to support http.request
            if (!UtilsSettings_1.UtilsSettings.util.isNull(result.pathname) || !UtilsSettings_1.UtilsSettings.util.isNull(result.search)) {
                result.path = (result.pathname ? result.pathname : '') +
                    (result.search ? result.search : '');
            }
            result.href = result.format();
            return result;
        }
        if (!srcPath.length) {
            // no path at all.  easy.
            // we've already handled the other stuff above.
            result.pathname = null;
            //to support http.request
            if (result.search) {
                result.path = '/' + result.search;
            }
            else {
                result.path = null;
            }
            result.href = result.format();
            return result;
        }
        // if a url ENDs in . or .., then it must get a trailing slash.
        // however, if it ends in anything else non-slashy,
        // then it must NOT get a trailing slash.
        var last = srcPath.slice(-1)[0];
        var hasTrailingSlash = ((result.host || relative.host || srcPath.length > 1) &&
            (last === '.' || last === '..') || last === '');
        // strip single dots, resolve double dots to parent dir
        // if the path tries to go above the root, `up` ends up > 0
        var up = 0;
        for (var i = srcPath.length; i >= 0; i--) {
            last = srcPath[i];
            if (last === '.') {
                srcPath.splice(i, 1);
            }
            else if (last === '..') {
                srcPath.splice(i, 1);
                up++;
            }
            else if (up) {
                srcPath.splice(i, 1);
                up--;
            }
        }
        // if the path is allowed to go above the root, restore leading ..s
        if (!mustEndAbs && !removeAllDots) {
            for (; up--; up) {
                srcPath.unshift('..');
            }
        }
        if (mustEndAbs && srcPath[0] !== '' &&
            (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
            srcPath.unshift('');
        }
        if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
            srcPath.push('');
        }
        var isAbsolute = srcPath[0] === '' ||
            (srcPath[0] && srcPath[0].charAt(0) === '/');
        // put the host back
        if (psychotic) {
            result.hostname = result.host = isAbsolute ? '' :
                srcPath.length ? srcPath.shift() : '';
            //occationaly the auth can get stuck only in host
            //this especially happens in cases like
            //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
            var authInHost = result.host && result.host.indexOf('@') > 0 ?
                result.host.split('@') : false;
            if (authInHost) {
                result.auth = authInHost.shift();
                result.host = result.hostname = authInHost.shift();
            }
        }
        mustEndAbs = mustEndAbs || (result.host && srcPath.length);
        if (mustEndAbs && !isAbsolute) {
            srcPath.unshift('');
        }
        if (!srcPath.length) {
            result.pathname = null;
            result.path = null;
        }
        else {
            result.pathname = srcPath.join('/');
        }
        //to support request.http
        if (!UtilsSettings_1.UtilsSettings.util.isNull(result.pathname) || !UtilsSettings_1.UtilsSettings.util.isNull(result.search)) {
            result.path = (result.pathname ? result.pathname : '') +
                (result.search ? result.search : '');
        }
        result.auth = relative.auth || result.auth;
        result.slashes = result.slashes || relative.slashes;
        result.href = result.format();
        return result;
    }
    ;
    static urlParse(url, parseQueryString = null, slashesDenoteHost = null) {
        if (url && UtilsSettings_1.UtilsSettings.util.isObject(url) && url instanceof Url) {
            return url;
        }
        var u = new Url;
        u.parse(url, parseQueryString, slashesDenoteHost);
        return u;
    }
    resolve(relative) {
        return this.resolveObject(Url.urlParse(relative, false, true)).format();
    }
    ;
    parseHost() {
        var host = this.host;
        var port = Url.portPattern.exec(host);
        if (port) {
            port = port[0];
            if (port !== ':') {
                this.port = port.substr(1);
            }
            host = host.substr(0, host.length - port.length);
        }
        if (host) {
            this.hostname = host;
        }
    }
    ;
    parse(url, parseQueryString = null, slashesDenoteHost = null) {
        if (!UtilsSettings_1.UtilsSettings.util.isString(url)) {
            throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
        }
        // Copy chrome, IE, opera backslash-handling behavior.
        // Back slashes before the query string get converted to forward slashes
        // See: https://code.google.com/p/chromium/issues/detail?id=25916
        var queryIndex = url.indexOf('?'), splitter = (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#', uSplit = url.split(splitter), slashRegex = /\\/g;
        uSplit[0] = uSplit[0].replace(slashRegex, '/');
        url = uSplit.join(splitter);
        var rest = url;
        // trim before proceeding.
        // This is to support parse stuff like "  http://foo.com  \n"
        rest = rest.trim();
        if (!slashesDenoteHost && url.split('#').length === 1) {
            // Try fast path regexp
            var simplePath = Url.simplePathPattern.exec(rest);
            if (simplePath) {
                this.path = rest;
                this.href = rest;
                this.pathname = simplePath[1];
                if (simplePath[2]) {
                    this.search = simplePath[2];
                    if (parseQueryString) {
                        this.query = this.parse(this.search.substr(1));
                    }
                    else {
                        this.query = this.search.substr(1);
                    }
                }
                else if (parseQueryString) {
                    this.search = '';
                    this.query = {};
                }
                return this;
            }
        }
        var proto = Url.protocolPattern.exec(rest);
        if (proto) {
            proto = proto[0];
            var lowerProto = proto.toLowerCase();
            this.protocol = lowerProto;
            rest = rest.substr(proto.length);
        }
        // figure out if it's got a host
        // user@server is *always* interpreted as a hostname, and url
        // resolution will treat //foo/bar as host=foo,path=bar because that's
        // how the browser resolves relative URLs.
        if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
            var slashes = rest.substr(0, 2) === '//';
            if (slashes && !(proto && Url.hostlessProtocol[proto])) {
                rest = rest.substr(2);
                this.slashes = true;
            }
        }
        if (!Url.hostlessProtocol[proto] &&
            (slashes || (proto && !Url.slashedProtocol[proto]))) {
            // there's a hostname.
            // the first instance of /, ?, ;, or # ends the host.
            //
            // If there is an @ in the hostname, then non-host chars *are* allowed
            // to the left of the last @ sign, unless some host-ending character
            // comes *before* the @-sign.
            // URLs are obnoxious.
            //
            // ex:
            // http://a@b@c/ => user:a@b host:c
            // http://a@b?@c => user:a host:c path:/?@c
            // v0.12 TODO(isaacs): This is not quite how Chrome does things.
            // Review our test case against browsers more comprehensively.
            // find the first instance of any hostEndingChars
            var hostEnd = -1;
            for (var i = 0; i < Url.hostEndingChars.length; i++) {
                var hec = rest.indexOf(Url.hostEndingChars[i]);
                if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
                    hostEnd = hec;
                }
            }
            // at this point, either we have an explicit point where the
            // auth portion cannot go past, or the last @ char is the decider.
            var auth, atSign;
            if (hostEnd === -1) {
                // atSign can be anywhere.
                atSign = rest.lastIndexOf('@');
            }
            else {
                // atSign must be in auth portion.
                // http://a@b/c@d => host:b auth:a path:/c@d
                atSign = rest.lastIndexOf('@', hostEnd);
            }
            // Now we have a portion which is definitely the auth.
            // Pull that off.
            if (atSign !== -1) {
                auth = rest.slice(0, atSign);
                rest = rest.slice(atSign + 1);
                this.auth = decodeURIComponent(auth);
            }
            // the host is the remaining to the left of the first non-host char
            hostEnd = -1;
            for (var i = 0; i < Url.nonHostChars.length; i++) {
                var hec = rest.indexOf(Url.nonHostChars[i]);
                if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
                    hostEnd = hec;
                }
            }
            // if we still have not hit it, then the entire thing is a host.
            if (hostEnd === -1) {
                hostEnd = rest.length;
            }
            this.host = rest.slice(0, hostEnd);
            rest = rest.slice(hostEnd);
            // pull out port.
            this.parseHost();
            // we've indicated that there is a hostname,
            // so even if it's empty, it has to be present.
            this.hostname = this.hostname || '';
            // if hostname begins with [ and ends with ]
            // assume that it's an IPv6 address.
            var ipv6Hostname = this.hostname[0] === '[' &&
                this.hostname[this.hostname.length - 1] === ']';
            // validate a little.
            if (!ipv6Hostname) {
                var hostparts = this.hostname.split(/\./);
                for (var i = 0, l = hostparts.length; i < l; i++) {
                    var part = hostparts[i];
                    if (!part) {
                        continue;
                    }
                    if (!part.match(Url.hostnamePartPattern)) {
                        var newpart = '';
                        for (var j = 0, k = part.length; j < k; j++) {
                            if (part.charCodeAt(j) > 127) {
                                // we replace non-ASCII char with a temporary placeholder
                                // we need this to make sure size of hostname is not
                                // broken by replacing non-ASCII by nothing
                                newpart += 'x';
                            }
                            else {
                                newpart += part[j];
                            }
                        }
                        // we test again with ASCII char only
                        if (!newpart.match(Url.hostnamePartPattern)) {
                            var validParts = hostparts.slice(0, i);
                            var notHost = hostparts.slice(i + 1);
                            var bit = part.match(Url.hostnamePartStart);
                            if (bit) {
                                validParts.push(bit[1]);
                                notHost.unshift(bit[2]);
                            }
                            if (notHost.length) {
                                rest = '/' + notHost.join('.') + rest;
                            }
                            this.hostname = validParts.join('.');
                            break;
                        }
                    }
                }
            }
            if (this.hostname.length > Url.hostnameMaxLen) {
                this.hostname = '';
            }
            else {
                // hostnames are always lower case.
                this.hostname = this.hostname.toLowerCase();
            }
            if (!ipv6Hostname) {
                // IDNA Support: Returns a punycoded representation of "domain".
                // It only converts parts of the domain name that
                // have non-ASCII characters, i.e. it doesn't matter if
                // you call it with a domain that already is ASCII-only.
                this.hostname = this.toASCII(this.hostname);
            }
            var p = this.port ? ':' + this.port : '';
            var h = this.hostname || '';
            this.host = h + p;
            this.href += this.host;
            // strip [ and ] from the hostname
            // the host field still retains them, though
            if (ipv6Hostname) {
                this.hostname = this.hostname.substr(1, this.hostname.length - 2);
                if (rest[0] !== '/') {
                    rest = '/' + rest;
                }
            }
        }
        // now rest is set to the post-host stuff.
        // chop off any delim chars.
        if (!Url.unsafeProtocol[lowerProto]) {
            // First, make 100% sure that any "autoEscape" chars get
            // escaped, even if encodeURIComponent doesn't think they
            // need to be.
            for (var i = 0, l = Url.autoEscape.length; i < l; i++) {
                var ae = Url.autoEscape[i];
                if (rest.indexOf(ae) === -1) {
                    continue;
                }
                var esc = encodeURIComponent(ae);
                if (esc === ae) {
                    esc = escape(ae);
                }
                rest = rest.split(ae).join(esc);
            }
        }
        // chop off from the tail first.
        var hash = rest.indexOf('#');
        if (hash !== -1) {
            // got a fragment string.
            this.hash = rest.substr(hash);
            rest = rest.slice(0, hash);
        }
        var qm = rest.indexOf('?');
        if (qm !== -1) {
            this.search = rest.substr(qm);
            this.query = rest.substr(qm + 1);
            if (parseQueryString) {
                this.query = this.parse(this.query);
            }
            rest = rest.slice(0, qm);
        }
        else if (parseQueryString) {
            // no query string, but parseQueryString still requested
            this.search = '';
            this.query = {};
        }
        if (rest) {
            this.pathname = rest;
        }
        if (Url.slashedProtocol[lowerProto] &&
            this.hostname && !this.pathname) {
            this.pathname = '/';
        }
        //to support http.request
        if (this.pathname || this.search) {
            var p = this.pathname || '';
            var s = this.search || '';
            this.path = p + s;
        }
        // finally, reconstruct the href based on what has been validated.
        this.href = this.format();
        return this;
    }
    ;
    /**
 * Converts a Unicode string representing a domain name or an email address to
 * Punycode. Only the non-ASCII parts of the domain name will be converted,
 * i.e. it doesn't matter if you call it with a domain that's already in
 * ASCII.
 * @memberOf punycode
 * @param {String} input The domain name or email address to convert, as a
 * Unicode string.
 * @returns {String} The Punycode representation of the given domain name or
 * email address.
 */
    toASCII(input) {
        return this.mapDomain(input, function (string) {
            return Url.regexNonASCII.test(string)
                ? 'xn--' + this.encode(string)
                : string;
        });
    }
    stringifyPrimitive(v) {
        switch (typeof v) {
            case 'string':
                return v;
            case 'boolean':
                return v ? 'true' : 'false';
            case 'number':
                return isFinite(v) ? v : '';
            default:
                return '';
        }
    }
    ;
    encode(obj, sep = null, eq = null, name = null) {
        sep = sep || '&';
        eq = eq || '=';
        if (obj === null) {
            obj = undefined;
        }
        if (typeof obj === 'object') {
            return Object.keys(obj).map(function (k) {
                var ks = encodeURIComponent(this.stringifyPrimitive(k)) + eq;
                if (Array.isArray(obj[k])) {
                    return obj[k].map(function (v) {
                        return ks + encodeURIComponent(this.stringifyPrimitive(v));
                    }).join(sep);
                }
                else {
                    return ks + encodeURIComponent(this.stringifyPrimitive(obj[k]));
                }
            }).join(sep);
        }
        if (!name) {
            return '';
        }
        return encodeURIComponent(this.stringifyPrimitive(name)) + eq +
            encodeURIComponent(this.stringifyPrimitive(obj));
    }
    ;
    /**
     * A simple `Array#map`-like wrapper to work with domain name strings or email
     * addresses.
     * @private
     * @param {String} domain The domain name or email address.
     * @param {Function} callback The function that gets called for every
     * character.
     * @returns {Array} A new string of characters returned by the callback
     * function.
     */
    mapDomain(string, fn) {
        var parts = string.split('@');
        var result = '';
        if (parts.length > 1) {
            // In email addresses, only the domain name should be punycoded. Leave
            // the local part (i.e. everything up to `@`) intact.
            result = parts[0] + '@';
            string = parts[1];
        }
        // Avoid `split(regex)` for IE8 compatibility. See #17.
        string = string.replace(Url.regexSeparators, '\x2E');
        var labels = string.split('.');
        var encoded = this.map(labels, fn).join('.');
        return result + encoded;
    }
    /**
     * A generic `Array#map` utility function.
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} callback The function that gets called for every array
     * item.
     * @returns {Array} A new array of values returned by the callback function.
     */
    map(array, fn) {
        var length = array.length;
        var result = [];
        while (length--) {
            result[length] = fn(array[length]);
        }
        return result;
    }
    format() {
        var auth = this.auth || '';
        if (auth) {
            auth = encodeURIComponent(auth);
            auth = auth.replace(/%3A/i, ':');
            auth += '@';
        }
        var protocol = this.protocol || '', pathname = this.pathname || '', hash = this.hash || '', host = false, query = '';
        if (this.host) {
            host = auth + this.host;
        }
        else if (this.hostname) {
            host = auth + (this.hostname.indexOf(':') === -1 ?
                this.hostname :
                '[' + this.hostname + ']');
            if (this.port) {
                host += ':' + this.port;
            }
        }
        if (this.query &&
            UtilsSettings_1.UtilsSettings.util.isObject(this.query) &&
            Object.keys(this.query).length) {
            query = this.encode(this.query);
        }
        var search = this.search || (query && ('?' + query)) || '';
        if (protocol && protocol.substr(-1) !== ':') {
            protocol += ':';
        }
        // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
        // unless they had them to begin with.
        if (this.slashes ||
            (!protocol || Url.slashedProtocol[protocol]) && host !== false) {
            host = '//' + (host || '');
            if (pathname && pathname.charAt(0) !== '/') {
                pathname = '/' + pathname;
            }
        }
        else if (!host) {
            host = '';
        }
        if (hash && hash.charAt(0) !== '#') {
            hash = '#' + hash;
        }
        if (search && search.charAt(0) !== '?') {
            search = '?' + search;
        }
        pathname = pathname.replace(/[?#]/g, function (match) {
            return encodeURIComponent(match);
        });
        search = search.replace('#', '%23');
        return protocol + host + pathname + search + hash;
    }
    ;
}
Url.regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g;
Url.portPattern = /:[0-9]*$/;
Url.simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/;
Url.protocolPattern = /^([a-z0-9.+-]+:)/i;
Url.regexNonASCII = /[^\x20-\x7E]/;
Url.hostlessProtocol = {
    'javascript': true,
    'javascript:': true
};
Url.slashedProtocol = {
    'http': true,
    'https': true,
    'ftp': true,
    'gopher': true,
    'file': true,
    'http:': true,
    'https:': true,
    'ftp:': true,
    'gopher:': true,
    'file:': true
};
Url.hostEndingChars = ['/', '?', '#'];
Url.delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'];
Url.unwise = ['{', '}', '|', '\\', '^', '`'].concat(Url.delims);
Url.autoEscape = ['\''].concat(Url.unwise);
Url.nonHostChars = ['%', '/', '?', ';', '#'].concat(Url.autoEscape);
Url.hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/;
Url.hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/;
Url.hostnameMaxLen = 255;
Url.unsafeProtocol = {
    'javascript': true,
    'javascript:': true
};
exports.Url = Url;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/UtilsSettings.js":
/*!*************************************************!*\
  !*** ./js-compile/raw-pixi-ts/UtilsSettings.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class UtilsSettings {
    static removeItems(arr, startIdx, removeCount) {
        var length = arr.length;
        var i;
        if (startIdx >= length || removeCount === 0) {
            return;
        }
        removeCount = (startIdx + removeCount > length ? length - startIdx : removeCount);
        var len = length - removeCount;
        for (i = startIdx; i < len; ++i) {
            arr[i] = arr[i + removeCount];
        }
        arr.length = len;
    }
    static deepCopyProperties(target, source, propertyObj) {
        for (var prop in propertyObj) {
            if (Array.isArray(source[prop])) {
                target[prop] = source[prop].slice();
            }
            else {
                target[prop] = source[prop];
            }
        }
    }
    static areArraysEqual(array1, array2) {
        if (!Array.isArray(array1) || !Array.isArray(array2)) {
            return false;
        }
        if (array1.length !== array2.length) {
            return false;
        }
        for (var i = 0; i < array1.length; ++i) {
            if (array1[i] !== array2[i]) {
                return false;
            }
        }
        return true;
    }
    static unsafeEvalSupported() {
        if (typeof UtilsSettings.unsafeEval === 'boolean') {
            return UtilsSettings.unsafeEval;
        }
        try {
            var func = new Function('param1', 'param2', 'param3', 'return param1[param2] === param3;');
            UtilsSettings.unsafeEval = func({ a: 'b' }, 'a', 'b') === true;
        }
        catch (e) {
            UtilsSettings.unsafeEval = false;
        }
        return UtilsSettings.unsafeEval;
    }
    static isWebGLSupported() {
        var contextOptions = { stencil: true, failIfMajorPerformanceCaveat: true };
        try {
            if (!window['WebGLRenderingContext']) {
                return false;
            }
            var canvas = document.createElement('canvas');
            var gl = canvas.getContext('webgl', contextOptions) || canvas.getContext('experimental-webgl', contextOptions);
            var success = !!(gl && gl.getContextAttributes().stencil);
            if (gl) {
                var loseContext = gl.getExtension('WEBGL_lose_context');
                if (loseContext) {
                    loseContext.loseContext();
                }
            }
            gl = null;
            return success;
        }
        catch (e) {
            return false;
        }
    }
}
UtilsSettings.util = {
    isString: function (arg) {
        return typeof (arg) === 'string';
    },
    isObject: function (arg) {
        return typeof (arg) === 'object' && arg !== null;
    },
    isNull: function (arg) {
        return arg === null;
    },
    isNullOrUndefined: function (arg) {
        return arg == null;
    }
};
exports.UtilsSettings = UtilsSettings;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/VideoResource.js":
/*!*************************************************!*\
  !*** ./js-compile/raw-pixi-ts/VideoResource.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseImageResource_1 = __webpack_require__(/*! ./BaseImageResource */ "./js-compile/raw-pixi-ts/BaseImageResource.js");
const Ticker_1 = __webpack_require__(/*! ./Ticker */ "./js-compile/raw-pixi-ts/Ticker.js");
const Logger_1 = __webpack_require__(/*! ./Logger */ "./js-compile/raw-pixi-ts/Logger.js");
class VideoResource extends BaseImageResource_1.BaseImageResource {
    constructor(source, options) {
        options = options || {};
        // throw "stop"
        if (!(source instanceof HTMLVideoElement)) {
            var videoElement = document.createElement('video');
            videoElement.setAttribute('webkit-playsinline', '');
            videoElement.setAttribute('playsinline', '');
            if (typeof source === 'string') {
                source = [source];
            }
            BaseImageResource_1.BaseImageResource.crossOrigin(videoElement, (source[0].src || source[0]), options.crossorigin);
            // array of objects or strings
            for (var i = 0; i < source.length; ++i) {
                var sourceElement = document.createElement('source');
                var ref = source[i];
                var src = ref.src;
                var mime = ref.mime;
                src = src || source[i];
                var baseSrc = src.split('?').shift().toLowerCase();
                var ext = baseSrc.substr(baseSrc.lastIndexOf('.') + 1);
                mime = mime || ("video/" + ext);
                sourceElement.src = src;
                sourceElement.type = mime;
                videoElement.appendChild(sourceElement);
            }
            // Override the source
            source = videoElement;
        }
        super(source);
        this.canUpload = false;
        this._autoUpdate = true;
        this._isAutoUpdating = false;
        this._updateFPS = options.updateFPS || 0;
        this._msToNextUpdate = 0;
        /**
         * When set to true will automatically play videos used by this texture once
         * they are loaded. If false, it will not modify the playing state.
         *
         * @member {boolean}
         * @default true
         */
        this.autoPlay = options.autoPlay !== false;
        /**
         * Promise when loading
         * @member {Promise<void>}
         * @private
         * @default null
         */
        this._load = null;
        /**
         * Callback when completed with load.
         * @member {function}
         * @private
         */
        this._resolve = null;
        // Bind for listeners
        this._onCanPlay = this._onCanPlay.bind(this);
        if (options.autoLoad !== false) {
            this.load();
        }
    }
    /**
     * Trigger updating of the texture
     *
     * @param {number} [deltaTime=0] - time delta since last tick
     */
    update(deltaTime = 0) {
        if (!this.destroyed) {
            // account for if video has had its playbackRate changed
            var elapsedMS = Ticker_1.Ticker.shared.elapsedMS * this.source.playbackRate;
            // trace("elapsed: " + elapsedMS)
            this._msToNextUpdate = Math.floor(this._msToNextUpdate - elapsedMS);
            if (!this._updateFPS || this._msToNextUpdate <= 0) {
                // trace("super update: " + deltaTime)
                super.update(deltaTime);
                this._msToNextUpdate = this._updateFPS ? Math.floor(1000 / this._updateFPS) : 0;
            }
        }
    }
    ;
    /**
     * Start preloading the video resource.
     *
     * @protected
     * @return {Promise<void>} Handle the validate event
     */
    load() {
        Logger_1.trace("loading video");
        var this$1 = this;
        if (this._load) {
            return this._load;
        }
        var source = this.source;
        if ((source.readyState === source.HAVE_ENOUGH_DATA || source.readyState === source.HAVE_FUTURE_DATA)
            && source.width && source.height) {
            source.complete = true;
        }
        source.addEventListener('play', this._onPlayStart.bind(this));
        source.addEventListener('pause', this._onPlayStop.bind(this));
        if (!this._isSourceReady()) {
            source.addEventListener('canplay', this._onCanPlay);
            source.addEventListener('canplaythrough', this._onCanPlay);
        }
        else {
            this._onCanPlay();
        }
        this._load = new Promise(function (resolve) {
            if (this$1.valid) {
                resolve(this$1);
            }
            else {
                this$1._resolve = resolve;
                source.load();
            }
        });
        return this._load;
    }
    ;
    /**
     * Returns true if the underlying source is playing.
     *
     * @private
     * @return {boolean} True if playing.
     */
    _isSourcePlaying() {
        var source = this.source;
        return (source.currentTime > 0 && source.paused === false && source.ended === false && source.readyState > 2);
    }
    ;
    /**
     * Returns true if the underlying source is ready for playing.
     *
     * @private
     * @return {boolean} True if ready.
     */
    _isSourceReady() {
        return this.source.readyState === 3 || this.source.readyState === 4;
    }
    ;
    /**
     * Runs the update loop when the video is ready to play
     *
     * @private
     */
    _onPlayStart() {
        // Just in case the video has not received its can play even yet..
        if (!this.valid) {
            this._onCanPlay();
        }
        if (!this._isAutoUpdating && this.autoUpdate) {
            Ticker_1.Ticker.shared.add(this.update, this);
            this._isAutoUpdating = true;
        }
    }
    ;
    /**
     * Fired when a pause event is triggered, stops the update loop
     *
     * @private
     */
    _onPlayStop() {
        if (this._isAutoUpdating) {
            Ticker_1.Ticker.shared.remove(this.update, this);
            this._isAutoUpdating = false;
        }
    }
    ;
    /**
     * Fired when the video is loaded and ready to play
     *
     * @private
     */
    _onCanPlay() {
        var ref = this;
        var source = ref.source;
        source.removeEventListener('canplay', this._onCanPlay);
        source.removeEventListener('canplaythrough', this._onCanPlay);
        var valid = this.valid;
        this.resize(source.videoWidth, source.videoHeight);
        // prevent multiple loaded dispatches..
        if (!valid && this._resolve) {
            this._resolve(this);
            this._resolve = null;
        }
        if (this._isSourcePlaying()) {
            this._onPlayStart();
        }
        else if (this.autoPlay) {
            source.play();
        }
    }
    ;
    /**
     * Destroys this texture
     * @override
     */
    dispose() {
        if (this._isAutoUpdating) {
            Ticker_1.Ticker.shared.remove(this.update, this);
        }
        if (this.source) {
            this.source.pause();
            this.source.src = '';
            this.source.load();
        }
        BaseImageResource_1.BaseImageResource.prototype.dispose.call(this);
    }
    ;
    /**
     * Should the base texture automatically update itself, set to true by default
     *
     * @member {boolean}
     */
    get autoUpdate() {
        return this._autoUpdate;
    }
    ;
    set autoUpdate(value) {
        if (value !== this._autoUpdate) {
            this._autoUpdate = value;
            if (!this._autoUpdate && this._isAutoUpdating) {
                Ticker_1.Ticker.shared.remove(this.update, this);
                this._isAutoUpdating = false;
            }
            else if (this._autoUpdate && !this._isAutoUpdating) {
                Ticker_1.Ticker.shared.add(this.update, this);
                this._isAutoUpdating = true;
            }
        }
    }
    ;
    /**
     * How many times a second to update the texture from the video. Leave at 0 to update at every render.
     * A lower fps can help performance, as updating the texture at 60fps on a 30ps video may not be efficient.
     *
     * @member {number}
     */
    get updateFPS() {
        return this._updateFPS;
    }
    ;
    set updateFPS(value) {
        if (value !== this._updateFPS) {
            this._updateFPS = value;
        }
    }
    ;
    /**
     * Used to auto-detect the type of resource.
     *
     * @static
     * @param {*} source - The source object
     * @param {string} extension - The extension of source, if set
     * @return {boolean} `true` if video source
     */
    static test(source, extension) {
        return (source instanceof HTMLVideoElement)
            || VideoResource.TYPES.indexOf(extension) > -1;
    }
    ;
}
VideoResource.TYPES = ['mp4', 'm4v', 'webm', 'ogg', 'ogv', 'h264', 'avi', 'mov'];
exports.VideoResource = VideoResource;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/WebGLSettings.js":
/*!*************************************************!*\
  !*** ./js-compile/raw-pixi-ts/WebGLSettings.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Program_1 = __webpack_require__(/*! ./Program */ "./js-compile/raw-pixi-ts/Program.js");
const Matrix_1 = __webpack_require__(/*! ./Matrix */ "./js-compile/raw-pixi-ts/Matrix.js");
const Shader_1 = __webpack_require__(/*! ./Shader */ "./js-compile/raw-pixi-ts/Shader.js");
const CacheSettings_1 = __webpack_require__(/*! ./CacheSettings */ "./js-compile/raw-pixi-ts/CacheSettings.js");
const UniformGroup_1 = __webpack_require__(/*! ./UniformGroup */ "./js-compile/raw-pixi-ts/UniformGroup.js");
const DisplaySettings_1 = __webpack_require__(/*! ./DisplaySettings */ "./js-compile/raw-pixi-ts/DisplaySettings.js");
class WebGLSettings {
    static createIndicesForQuads(size) {
        var totalIndices = size * 6;
        var indices = new Uint16Array(totalIndices);
        for (var i = 0, j = 0; i < totalIndices; i += 6, j += 4) {
            indices[i + 0] = j + 0;
            indices[i + 1] = j + 1;
            indices[i + 2] = j + 2;
            indices[i + 3] = j + 0;
            indices[i + 4] = j + 2;
            indices[i + 5] = j + 3;
        }
        return indices;
    }
    static canUploadSameBuffer() {
        return true;
    }
    static generateMultiTextureShader(gl, maxTextures) {
        if (!CacheSettings_1.CacheSettings.programCache[maxTextures]) {
            var sampleValues = new Int32Array(maxTextures);
            for (var i = 0; i < maxTextures; i++) {
                sampleValues[i] = i;
            }
            CacheSettings_1.CacheSettings.defaultGroupCache[maxTextures] = UniformGroup_1.UniformGroup.from({ uSamplers: sampleValues }, true);
            var fragmentSrc = WebGLSettings.fragTemplate$1;
            fragmentSrc = fragmentSrc.replace(/%count%/gi, maxTextures);
            fragmentSrc = fragmentSrc.replace(/%forloop%/gi, WebGLSettings.generateSampleSrc(maxTextures));
            CacheSettings_1.CacheSettings.programCache[maxTextures] = new Program_1.Program(WebGLSettings.vertex$1, fragmentSrc);
        }
        var uniforms = {
            tint: new Float32Array([1, 1, 1, 1]),
            translationMatrix: new Matrix_1.Matrix(),
            default: CacheSettings_1.CacheSettings.defaultGroupCache[maxTextures],
        };
        var shader = new Shader_1.Shader(CacheSettings_1.CacheSettings.programCache[maxTextures], uniforms);
        return shader;
    }
    static generateSampleSrc(maxTextures) {
        var src = '';
        src += '\n';
        src += '\n';
        for (var i = 0; i < maxTextures; i++) {
            if (i > 0) {
                src += '\nelse ';
            }
            if (i < maxTextures - 1) {
                src += "if(vTextureId < " + i + ".5)";
            }
            src += '\n{';
            src += "\n\tcolor = texture2D(uSamplers[" + i + "], vTextureCoord);";
            src += '\n}';
        }
        src += '\n';
        src += '\n';
        return src;
    }
    static checkMaxIfStatementsInShader(maxIfs, gl) {
        if (maxIfs === 0) {
            throw new Error('Invalid value of `0` passed to `checkMaxIfStatementsInShader`');
        }
        var shader = gl.createShader(gl.FRAGMENT_SHADER);
        while (true) // eslint-disable-line no-constant-condition
         {
            var fragmentSrc = WebGLSettings.fragTemplate.replace(/%forloop%/gi, WebGLSettings.generateIfTestSrc(maxIfs));
            gl.shaderSource(shader, fragmentSrc);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                maxIfs = (maxIfs / 2) | 0;
            }
            else {
                // valid!
                break;
            }
        }
        return maxIfs;
    }
    static generateIfTestSrc(maxIfs) {
        var src = '';
        for (var i = 0; i < maxIfs; ++i) {
            if (i > 0) {
                src += '\nelse ';
            }
            if (i < maxIfs - 1) {
                src += "if(test == " + i + ".0){}";
            }
        }
        return src;
    }
    static maxRecommendedTextures(max) {
        var allowMax = true;
        var match = (navigator.userAgent).match(/OS (\d+)_(\d+)?/);
        if (match) {
            var majorVersion = parseInt(match[1], 10);
            if (majorVersion >= 11) {
                allowMax = true;
            }
        }
        var match$1 = (navigator.userAgent).match(/Android\s([0-9.]*)/);
        if (match$1) {
            var majorVersion$1 = parseInt(match$1[1], 10);
            if (majorVersion$1 >= 7) {
                allowMax = true;
            }
        }
        return allowMax ? max : 4;
    }
    static setPrecision(src, precision) {
        if (src.substring(0, 9) !== 'precision') // && src.substring(0, 1) !== '#')
         {
            return ("precision " + precision + " float;\n" + src);
        }
        return src;
    }
    static getTestContext() {
        if (!WebGLSettings.context) {
            var canvas = document.createElement('canvas');
            var gl;
            if (DisplaySettings_1.DisplaySettings.PREFER_ENV >= DisplaySettings_1.DisplaySettings.ENV.WEBGL2) {
                gl = canvas.getContext('webgl2', {});
            }
            if (!gl) {
                gl = canvas.getContext('webgl', {})
                    || canvas.getContext('experimental-webgl', {});
                if (!gl) {
                    // fail, not able to get a context
                    throw new Error('This browser does not support WebGL. Try using the canvas renderer');
                }
                else {
                    // for shader testing..
                    gl.getExtension('WEBGL_draw_buffers');
                }
            }
            WebGLSettings.context = gl;
            return gl;
        }
        return WebGLSettings.context;
    }
    static defaultValue(type, size) {
        switch (type) {
            case 'float':
                return 0;
            case 'vec2':
                return new Float32Array(2 * size);
            case 'vec3':
                return new Float32Array(3 * size);
            case 'vec4':
                return new Float32Array(4 * size);
            case 'int':
            case 'sampler2D':
            case 'sampler2DArray':
                return 0;
            case 'ivec2':
                return new Int32Array(2 * size);
            case 'ivec3':
                return new Int32Array(3 * size);
            case 'ivec4':
                return new Int32Array(4 * size);
            case 'bool':
                return false;
            case 'bvec2':
                return WebGLSettings.booleanArray(2 * size);
            case 'bvec3':
                return WebGLSettings.booleanArray(3 * size);
            case 'bvec4':
                return WebGLSettings.booleanArray(4 * size);
            case 'mat2':
                return new Float32Array([1, 0,
                    0, 1]);
            case 'mat3':
                return new Float32Array([1, 0, 0,
                    0, 1, 0,
                    0, 0, 1]);
            case 'mat4':
                return new Float32Array([1, 0, 0, 0,
                    0, 1, 0, 0,
                    0, 0, 1, 0,
                    0, 0, 0, 1]);
        }
        return null;
    }
    static booleanArray(size) {
        var array = new Array(size);
        for (var i = 0; i < array.length; i++) {
            array[i] = false;
        }
        return array;
    }
    static mapType(gl, type) {
        if (!WebGLSettings.GL_TABLE) {
            var typeNames = Object.keys(WebGLSettings.GL_TO_GLSL_TYPES);
            WebGLSettings.GL_TABLE = {};
            for (var i = 0; i < typeNames.length; ++i) {
                var tn = typeNames[i];
                WebGLSettings.GL_TABLE[gl[tn]] = WebGLSettings.GL_TO_GLSL_TYPES[tn];
            }
        }
        return WebGLSettings.GL_TABLE[type];
    }
    static mapSize(type) {
        return WebGLSettings.GLSL_TO_SIZE[type];
    }
    static generateUniformsSync(group, uniformData) {
        var textureCount = 0;
        var func = "var v = null;\n    var cv = null\n    var gl = renderer.gl";
        for (var i in group.uniforms) {
            var data = uniformData[i];
            if (!data) {
                if (group.uniforms[i].group) {
                    func += "\n                    renderer.shader.syncUniformGroup(uv." + i + ");\n                ";
                }
                continue;
            }
            // TODO && uniformData[i].value !== 0 <-- do we still need this?
            if (data.type === 'float' && data.size === 1) {
                func += "\n            if(uv." + i + " !== ud." + i + ".value)\n            {\n                ud." + i + ".value = uv." + i + "\n                gl.uniform1f(ud." + i + ".location, uv." + i + ")\n            }\n";
            }
            /* eslint-disable max-len */
            else if ((data.type === 'sampler2D' || data.type === 'samplerCube' || data.type === 'sampler2DArray') && data.size === 1 && !data.isArray) 
            /* eslint-disable max-len */
            {
                func += "\n            renderer.texture.bind(uv." + i + ", " + textureCount + ");\n\n            if(ud." + i + ".value !== " + textureCount + ")\n            {\n                ud." + i + ".value = " + textureCount + ";\n                gl.uniform1i(ud." + i + ".location, " + textureCount + ");\n; // eslint-disable-line max-len\n            }\n";
                textureCount++;
            }
            else if (data.type === 'mat3' && data.size === 1) {
                if (group.uniforms[i].a !== undefined) {
                    // TODO and some smart caching dirty ids here!
                    func += "\n                gl.uniformMatrix3fv(ud." + i + ".location, false, uv." + i + ".toArray(true));\n                \n";
                }
                else {
                    func += "\n                gl.uniformMatrix3fv(ud." + i + ".location, false, uv." + i + ");\n                \n";
                }
            }
            else if (data.type === 'vec2' && data.size === 1) {
                // TODO - do we need both here?
                // maybe we can get away with only using points?
                if (group.uniforms[i].x !== undefined) {
                    func += "\n                cv = ud." + i + ".value;\n                v = uv." + i + ";\n\n                if(cv[0] !== v.x || cv[1] !== v.y)\n                {\n                    cv[0] = v.x;\n                    cv[1] = v.y;\n                    gl.uniform2f(ud." + i + ".location, v.x, v.y);\n                }\n";
                }
                else {
                    func += "\n                cv = ud." + i + ".value;\n                v = uv." + i + ";\n\n                if(cv[0] !== v[0] || cv[1] !== v[1])\n                {\n                    cv[0] = v[0];\n                    cv[1] = v[1];\n                    gl.uniform2f(ud." + i + ".location, v[0], v[1]);\n                }\n                \n";
                }
            }
            else if (data.type === 'vec4' && data.size === 1) {
                // TODO - do we need both here?
                // maybe we can get away with only using points?
                if (group.uniforms[i].width !== undefined) {
                    func += "\n                cv = ud." + i + ".value;\n                v = uv." + i + ";\n\n                if(cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height)\n                {\n                    cv[0] = v.x;\n                    cv[1] = v.y;\n                    cv[2] = v.width;\n                    cv[3] = v.height;\n                    gl.uniform4f(ud." + i + ".location, v.x, v.y, v.width, v.height)\n                }\n";
                }
                else {
                    func += "\n                cv = ud." + i + ".value;\n                v = uv." + i + ";\n\n                if(cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n                {\n                    cv[0] = v[0];\n                    cv[1] = v[1];\n                    cv[2] = v[2];\n                    cv[3] = v[3];\n\n                    gl.uniform4f(ud." + i + ".location, v[0], v[1], v[2], v[3])\n                }\n                \n";
                }
            }
            else {
                var templateType = (data.size === 1) ? WebGLSettings.GLSL_TO_SINGLE_SETTERS_CACHED : WebGLSettings.GLSL_TO_ARRAY_SETTERS;
                var template = templateType[data.type].replace('location', ("ud." + i + ".location"));
                func += "\n            cv = ud." + i + ".value;\n            v = uv." + i + ";\n            " + template + ";\n";
            }
        }
        return new Function('ud', 'uv', 'renderer', func); // eslint-disable-line no-new-func
    }
}
WebGLSettings.UPLOADS_PER_FRAME = 4;
WebGLSettings.GLSL_TO_ARRAY_SETTERS = {
    float: "gl.uniform1fv(location, v)",
    vec2: "gl.uniform2fv(location, v)",
    vec3: "gl.uniform3fv(location, v)",
    vec4: 'gl.uniform4fv(location, v)',
    mat4: 'gl.uniformMatrix4fv(location, false, v)',
    mat3: 'gl.uniformMatrix3fv(location, false, v)',
    mat2: 'gl.uniformMatrix2fv(location, false, v)',
    int: 'gl.uniform1iv(location, v)',
    ivec2: 'gl.uniform2iv(location, v)',
    ivec3: 'gl.uniform3iv(location, v)',
    ivec4: 'gl.uniform4iv(location, v)',
    bool: 'gl.uniform1iv(location, v)',
    bvec2: 'gl.uniform2iv(location, v)',
    bvec3: 'gl.uniform3iv(location, v)',
    bvec4: 'gl.uniform4iv(location, v)',
    sampler2D: 'gl.uniform1iv(location, v)',
    samplerCube: 'gl.uniform1iv(location, v)',
    sampler2DArray: 'gl.uniform1iv(location, v)',
};
WebGLSettings.GLSL_TO_SINGLE_SETTERS_CACHED = {
    float: "\n    if(cv !== v)\n    {\n        cv.v = v;\n        gl.uniform1f(location, v)\n    }",
    vec2: "\n    if(cv[0] !== v[0] || cv[1] !== v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        gl.uniform2f(location, v[0], v[1])\n    }",
    vec3: "\n    if(cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3f(location, v[0], v[1], v[2])\n    }",
    vec4: 'gl.uniform4f(location, v[0], v[1], v[2], v[3])',
    int: 'gl.uniform1i(location, v)',
    ivec2: 'gl.uniform2i(location, v[0], v[1])',
    ivec3: 'gl.uniform3i(location, v[0], v[1], v[2])',
    ivec4: 'gl.uniform4i(location, v[0], v[1], v[2], v[3])',
    bool: 'gl.uniform1i(location, v)',
    bvec2: 'gl.uniform2i(location, v[0], v[1])',
    bvec3: 'gl.uniform3i(location, v[0], v[1], v[2])',
    bvec4: 'gl.uniform4i(location, v[0], v[1], v[2], v[3])',
    mat2: 'gl.uniformMatrix2fv(location, false, v)',
    mat3: 'gl.uniformMatrix3fv(location, false, v)',
    mat4: 'gl.uniformMatrix4fv(location, false, v)',
    sampler2D: 'gl.uniform1i(location, v)',
    samplerCube: 'gl.uniform1i(location, v)',
    sampler2DArray: 'gl.uniform1i(location, v)',
};
WebGLSettings.GLSL_TO_SIZE = {
    float: 1,
    vec2: 2,
    vec3: 3,
    vec4: 4,
    int: 1,
    ivec2: 2,
    ivec3: 3,
    ivec4: 4,
    bool: 1,
    bvec2: 2,
    bvec3: 3,
    bvec4: 4,
    mat2: 4,
    mat3: 9,
    mat4: 16,
    sampler2D: 1,
};
WebGLSettings.GL_TO_GLSL_TYPES = {
    FLOAT: 'float',
    FLOAT_VEC2: 'vec2',
    FLOAT_VEC3: 'vec3',
    FLOAT_VEC4: 'vec4',
    INT: 'int',
    INT_VEC2: 'ivec2',
    INT_VEC3: 'ivec3',
    INT_VEC4: 'ivec4',
    BOOL: 'bool',
    BOOL_VEC2: 'bvec2',
    BOOL_VEC3: 'bvec3',
    BOOL_VEC4: 'bvec4',
    FLOAT_MAT2: 'mat2',
    FLOAT_MAT3: 'mat3',
    FLOAT_MAT4: 'mat4',
    SAMPLER_2D: 'sampler2D',
    SAMPLER_CUBE: 'samplerCube',
    SAMPLER_2D_ARRAY: 'sampler2DArray',
};
WebGLSettings.GL_TABLE = null;
WebGLSettings.context = null;
WebGLSettings.PRECISION_FRAGMENT = 'highp';
WebGLSettings.PRECISION_VERTEX = 'highp';
WebGLSettings.fragTemplate = [
    'precision mediump float;',
    'void main(void){',
    'float test = 0.1;',
    '%forloop%',
    'gl_FragColor = vec4(0.0);',
    '}'
].join('\n');
WebGLSettings.vertex$1 = "precision highp float;\r\nattribute vec2 aVertexPosition;\r\nattribute vec2 aTextureCoord;\r\nattribute vec4 aColor;\r\nattribute float aTextureId;\r\n\r\nuniform mat3 projectionMatrix;\r\nuniform mat3 translationMatrix;\r\nuniform vec4 tint;\r\n\r\nvarying vec2 vTextureCoord;\r\nvarying vec4 vColor;\r\nvarying float vTextureId;\r\n\r\nvoid main(void){\r\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\r\n\r\n    vTextureCoord = aTextureCoord;\r\n    vTextureId = aTextureId;\r\n    vColor = aColor * tint;\r\n}\r\n";
WebGLSettings.fragTemplate$1 = [
    'varying vec2 vTextureCoord;',
    'varying vec4 vColor;',
    'varying float vTextureId;',
    'uniform sampler2D uSamplers[%count%];',
    'void main(void){',
    'vec4 color;',
    '%forloop%',
    'gl_FragColor = color * vColor;',
    '}'
].join('\n');
WebGLSettings.MIPMAP_TEXTURES = 1;
WebGLSettings.WRAP_MODE = 33071;
WebGLSettings.TARGETS = {
    TEXTURE_2D: 3553,
    TEXTURE_CUBE_MAP: 34067,
    TEXTURE_2D_ARRAY: 35866,
    TEXTURE_CUBE_MAP_POSITIVE_X: 34069,
    TEXTURE_CUBE_MAP_NEGATIVE_X: 34070,
    TEXTURE_CUBE_MAP_POSITIVE_Y: 34071,
    TEXTURE_CUBE_MAP_NEGATIVE_Y: 34072,
    TEXTURE_CUBE_MAP_POSITIVE_Z: 34073,
    TEXTURE_CUBE_MAP_NEGATIVE_Z: 34074,
};
WebGLSettings.FORMATS = {
    RGBA: 6408,
    RGB: 6407,
    ALPHA: 6406,
    LUMINANCE: 6409,
    LUMINANCE_ALPHA: 6410,
    DEPTH_COMPONENT: 6402,
    DEPTH_STENCIL: 34041,
};
WebGLSettings.TYPES = {
    UNSIGNED_BYTE: 5121,
    UNSIGNED_SHORT: 5123,
    UNSIGNED_SHORT_5_6_5: 33635,
    UNSIGNED_SHORT_4_4_4_4: 32819,
    UNSIGNED_SHORT_5_5_5_1: 32820,
    FLOAT: 5126,
    HALF_FLOAT: 36193,
};
WebGLSettings.MIPMAP_MODES = {
    OFF: 0,
    POW2: 1,
    ON: 2,
};
WebGLSettings.SCALE_MODES = {
    LINEAR: 1,
    NEAREST: 0,
};
WebGLSettings.WRAP_MODES = {
    CLAMP: 33071,
    REPEAT: 10497,
    MIRRORED_REPEAT: 33648,
};
WebGLSettings.defaultBufferOptions = {
    scaleMode: WebGLSettings.SCALE_MODES.NEAREST,
    format: WebGLSettings.FORMATS.RGBA,
    premultiplyAlpha: false,
};
WebGLSettings.CAN_UPLOAD_SAME_BUFFER = WebGLSettings.canUploadSameBuffer();
WebGLSettings.SPRITE_MAX_TEXTURES = WebGLSettings.maxRecommendedTextures(32);
exports.WebGLSettings = WebGLSettings;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/settings.js":
/*!********************************************!*\
  !*** ./js-compile/raw-pixi-ts/settings.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class settings {
    /**
     * Converts a digit/integer into a basic code point.
     * @see `basicToDigit()`
     * @private
     * @param {Number} digit The numeric value of a basic code point.
     * @returns {Number} The basic code point whose value (when used for
     * representing integers) is `digit`, which needs to be in the range
     * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
     * used; else, the lowercase form is used. The behavior is undefined
     * if `flag` is non-zero and `digit` has no uppercase form.
     */
    static digitToBasic(digit, flag) {
        //  0..25 map to ASCII a..z or A..Z
        // 26..35 map to ASCII 0..9
        return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
    }
    /**
     * A generic error utility function.
     * @private
     * @param {String} type The error type.
     * @returns {Error} Throws a `RangeError` with the applicable error message.
     */
    static error(type) {
        throw RangeError(settings.errors[type]);
    }
    /**
 * Converts a string of Unicode symbols (e.g. a domain name label) to a
 * Punycode string of ASCII-only symbols.
 * @memberOf punycode
 * @param {String} input The string of Unicode symbols.
 * @returns {String} The resulting Punycode string of ASCII-only symbols.
 */
    static encode(input) {
        var n, delta, handledCPCount, basicLength, bias, j, m, q, k, t, currentValue, output = [], 
        /** `inputLength` will hold the number of code points in `input`. */
        inputLength, 
        /** Cached calculation results */
        handledCPCountPlusOne, baseMinusT, qMinusT;
        // Convert the input in UCS-2 to Unicode
        input = settings.ucs2decode(input);
        // Cache the length
        inputLength = input.length;
        // Initialize the state
        n = settings.initialN;
        delta = 0;
        bias = settings.initialBias;
        // Handle the basic code points
        for (j = 0; j < inputLength; ++j) {
            currentValue = input[j];
            if (currentValue < 0x80) {
                output.push(settings.stringFromCharCode(currentValue));
            }
        }
        handledCPCount = basicLength = output.length;
        // `handledCPCount` is the number of code points that have been handled;
        // `basicLength` is the number of basic code points.
        // Finish the basic string - if it is not empty - with a delimiter
        if (basicLength) {
            output.push(settings.delimiter);
        }
        // Main encoding loop:
        while (handledCPCount < inputLength) {
            // All non-basic code points < n have been handled already. Find the next
            // larger one:
            for (m = settings.maxInt, j = 0; j < inputLength; ++j) {
                currentValue = input[j];
                if (currentValue >= n && currentValue < m) {
                    m = currentValue;
                }
            }
            // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
            // but guard against overflow
            handledCPCountPlusOne = handledCPCount + 1;
            if (m - n > settings.floor((settings.maxInt - delta) / handledCPCountPlusOne)) {
                settings.error('overflow');
            }
            delta += (m - n) * handledCPCountPlusOne;
            n = m;
            for (j = 0; j < inputLength; ++j) {
                currentValue = input[j];
                if (currentValue < n && ++delta > settings.maxInt) {
                    settings.error('overflow');
                }
                if (currentValue == n) {
                    // Represent delta as a generalized variable-length integer
                    for (q = delta, k = settings.base; /* no condition */; k += settings.base) {
                        t = k <= bias ? settings.tMin : (k >= bias + settings.tMax ? settings.tMax : k - bias);
                        if (q < t) {
                            break;
                        }
                        qMinusT = q - t;
                        baseMinusT = settings.base - t;
                        output.push(settings.stringFromCharCode(settings.digitToBasic(t + qMinusT % baseMinusT, 0)));
                        q = settings.floor(qMinusT / baseMinusT);
                    }
                    output.push(settings.stringFromCharCode(settings.digitToBasic(q, 0)));
                    bias = settings.adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
                    delta = 0;
                    ++handledCPCount;
                }
            }
            ++delta;
            ++n;
        }
        return output.join('');
    }
    /**
* Bias adaptation function as per section 3.4 of RFC 3492.
* http://tools.ietf.org/html/rfc3492#section-3.4
* @private
*/
    static adapt(delta, numPoints, firstTime) {
        var k = 0;
        delta = firstTime ? settings.floor(delta / settings.damp) : delta >> 1;
        delta += settings.floor(delta / numPoints);
        for ( /* no initialization */; delta > settings.baseMinusTMin * settings.tMax >> 1; k += settings.base) {
            delta = settings.floor(delta / settings.baseMinusTMin);
        }
        return settings.floor(k + (settings.baseMinusTMin + 1) * delta / (delta + settings.skew));
    }
    /**
* Creates an array containing the numeric code points of each Unicode
* character in the string. While JavaScript uses UCS-2 internally,
* this function will convert a pair of surrogate halves (each of which
* UCS-2 exposes as separate characters) into a single code point,
* matching UTF-16.
* @see `punycode.ucs2.encode`
* @see <https://mathiasbynens.be/notes/javascript-encoding>
* @memberOf punycode.ucs2
* @name decode
* @param {String} string The Unicode input string (UCS-2).
* @returns {Array} The new array of code points.
*/
    static ucs2decode(string) {
        var output = [], counter = 0, length = string.length, value, extra;
        while (counter < length) {
            value = string.charCodeAt(counter++);
            if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
                // high surrogate, and there is a next character
                extra = string.charCodeAt(counter++);
                if ((extra & 0xFC00) == 0xDC00) { // low surrogate
                    output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
                }
                else {
                    // unmatched surrogate; only append this code unit, in case the next
                    // code unit is the high surrogate of a surrogate pair
                    output.push(value);
                    counter--;
                }
            }
            else {
                output.push(value);
            }
        }
        return output;
    }
    /**
 * Typedef for decomposeDataUri return object.
 *
 * @memberof PIXI.utils
 * @typedef {object} DecomposedDataUri
 * @property {string} mediaType Media type, eg. `image`
 * @property {string} subType Sub type, eg. `png`
 * @property {string} encoding Data encoding, eg. `base64`
 * @property {string} data The actual data
 */
    /**
     * Split a data URI into components. Returns undefined if
     * parameter `dataUri` is not a valid data URI.
     *
     * @memberof PIXI.utils
     * @function decomposeDataUri
     * @param {string} dataUri - the data URI to check
     * @return {PIXI.utils.DecomposedDataUri|undefined} The decomposed data uri or undefined
     */
    static decomposeDataUri(dataUri) {
        var dataUriMatch = settings.DATA_URI.exec(dataUri);
        if (dataUriMatch) {
            return {
                mediaType: dataUriMatch[1] ? dataUriMatch[1].toLowerCase() : undefined,
                subType: dataUriMatch[2] ? dataUriMatch[2].toLowerCase() : undefined,
                charset: dataUriMatch[3] ? dataUriMatch[3].toLowerCase() : undefined,
                encoding: dataUriMatch[4] ? dataUriMatch[4].toLowerCase() : undefined,
                data: dataUriMatch[5],
            };
        }
        return undefined;
    }
}
/**
 * Target frames per millisecond.
 *
 * @static
 * @name TARGET_FPMS
 * @memberof PIXI.settings
 * @type {number}
 * @default 0.06
 */
settings.TARGET_FPMS = 0.06;
/**
 * Default filter resolution.
 *
 * @static
 * @name FILTER_RESOLUTION
 * @memberof PIXI.settings
 * @type {number}
 * @default 1
 */
settings.FILTER_RESOLUTION = 1;
// TODO: maybe change to SPRITE.BATCH_SIZE: 2000
// TODO: maybe add PARTICLE.BATCH_SIZE: 15000
/**
 * The default sprite batch size.
 *
 * The default aims to balance desktop and mobile devices.
 *
 * @static
 * @name SPRITE_BATCH_SIZE
 * @memberof PIXI.settings
 * @type {number}
 * @default 4096
 */
settings.SPRITE_BATCH_SIZE = 4096;
/**
 * Default Garbage Collection mode.
 *
 * @static
 * @name GC_MODE
 * @memberof PIXI.settings
 * @type {PIXI.GC_MODES}
 * @default PIXI.GC_MODES.AUTO
 */
settings.GC_MODE = 0;
/**
 * Default Garbage Collection max idle.
 *
 * @static
 * @name GC_MAX_IDLE
 * @memberof PIXI.settings
 * @type {number}
 * @default 3600
 */
settings.GC_MAX_IDLE = 60 * 60;
/**
 * Default Garbage Collection maximum check count.
 *
 * @static
 * @name GC_MAX_CHECK_COUNT
 * @memberof PIXI.settings
 * @type {number}
 * @default 600
 */
settings.GC_MAX_CHECK_COUNT = 60 * 10;
/**
* The gc modes that are supported by pixi.
*
* The {@link PIXI.settings.GC_MODE} Garbage Collection mode for PixiJS textures is AUTO
* If set to GC_MODE, the renderer will occasionally check textures usage. If they are not
* used for a specified period of time they will be removed from the GPU. They will of course
* be uploaded again when they are required. This is a silent behind the scenes process that
* should ensure that the GPU does not  get filled up.
*
* Handy for mobile devices!
* This property only affects WebGL.
*
* @name GC_MODES
* @enum {number}
* @static
* @memberof PIXI
* @property {number} AUTO - Garbage collection will happen periodically automatically
* @property {number} MANUAL - Garbage collection will need to be called manually
*/
settings.GC_MODES = {
    AUTO: 0,
    MANUAL: 1,
};
/**
 * Constants that specify float precision in shaders.
 *
 * @name PRECISION
 * @memberof PIXI
 * @static
 * @enum {string}
 * @constant
 * @property {string} LOW='lowp'
 * @property {string} MEDIUM='mediump'
 * @property {string} HIGH='highp'
 */
settings.PRECISION = {
    LOW: 'lowp',
    MEDIUM: 'mediump',
    HIGH: 'highp',
};
/**
* Graphics curves resolution settings. If `adaptive` flag is set to `true`,
* the resolution is calculated based on the curve's length to ensure better visual quality.
* Adaptive draw works with `bezierCurveTo` and `quadraticCurveTo`.
*
* @static
* @constant
* @memberof PIXI
* @name GRAPHICS_CURVES
* @type {object}
* @property {boolean} adaptive=false - flag indicating if the resolution should be adaptive
* @property {number} maxLength=10 - maximal length of a single segment of the curve (if adaptive = false, ignored)
* @property {number} minSegments=8 - minimal number of segments in the curve (if adaptive = false, ignored)
* @property {number} maxSegments=2048 - maximal number of segments in the curve (if adaptive = false, ignored)
*/
settings.GRAPHICS_CURVES = {
    adaptive: true,
    maxLength: 10,
    minSegments: 8,
    maxSegments: 2048,
    _segmentsCount: function _segmentsCount(length, defaultSegments = null) {
        if (defaultSegments === void 0) {
            defaultSegments = 20;
        }
        if (!this.adaptive) {
            return defaultSegments;
        }
        var result = Math.ceil(length / this.maxLength);
        if (result < this.minSegments) {
            result = this.minSegments;
        }
        else if (result > this.maxSegments) {
            result = this.maxSegments;
        }
        return result;
    },
};
settings.initialN = 128;
settings.initialBias = 72;
settings.stringFromCharCode = String.fromCharCode;
settings.delimiter = '-';
settings.maxInt = 2147483647;
settings.floor = Math.floor;
settings.base = 36;
settings.tMin = 1;
settings.tMax = 26;
/** Error messages */
settings.errors = {
    'overflow': 'Overflow: input needs wider integers to process',
    'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
    'invalid-input': 'Invalid input'
};
settings.damp = 700;
settings.baseMinusTMin = settings.base - settings.tMin;
settings.skew = 38;
/**
* Regexp for data URI.
* Based on: {@link https://github.com/ragingwind/data-uri-regex}
*
* @static
* @constant {RegExp|string} DATA_URI
* @memberof PIXI
* @example data:image/png;base64
*/
settings.DATA_URI = /^\s*data:(?:([\w-]+)\/([\w+.-]+))?(?:;charset=([\w-]+))?(?:;(base64))?,(.*)/i;
// Taken from the bit-twiddle package
settings.defaultVertex = "attribute vec2 aVertexPosition;\r\nattribute vec2 aTextureCoord;\r\n\r\nuniform mat3 projectionMatrix;\r\n\r\nvarying vec2 vTextureCoord;\r\n\r\nvoid main(void)\r\n{\r\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\r\n    vTextureCoord = aTextureCoord;\r\n}";
settings.defaultFilterVertex = "attribute vec2 aVertexPosition;\r\n\r\nuniform mat3 projectionMatrix;\r\n\r\nvarying vec2 vTextureCoord;\r\n\r\nuniform vec4 inputSize;\r\nuniform vec4 outputFrame;\r\n\r\nvec4 filterVertexPosition( void )\r\n{\r\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\r\n\r\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\r\n}\r\n\r\nvec2 filterTextureCoord( void )\r\n{\r\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\r\n}\r\n\r\nvoid main(void)\r\n{\r\n    gl_Position = filterVertexPosition();\r\n    vTextureCoord = filterTextureCoord();\r\n}\r\n";
exports.settings = settings;


/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9leGFtcGxlcy9CYXNlRXhhbXBsZS5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL2V4YW1wbGVzL0ZpbHRlckJsZW5kaW5nLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvZXhhbXBsZXMvRmlsdGVyQmx1ci5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL2V4YW1wbGVzL0ZpbHRlckNvbG9yLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvZXhhbXBsZXMvRmlsdGVyQ3Jhd2xpZXMuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9leGFtcGxlcy9GaWx0ZXJDdXN0b20uanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9leGFtcGxlcy9GaWx0ZXJGbGFnLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvZXhhbXBsZXMvRmlsdGVyU2hhZG93LmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvZXhhbXBsZXMvTWFza0ZpbHRlci5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL2V4YW1wbGVzL01lc2hBZHZhbmNlZC5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL2V4YW1wbGVzL01lc2hCYXNpYy5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL2V4YW1wbGVzL01lc2hDb2xvcmVkVHJpYW5nbGUuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9leGFtcGxlcy9NZXNoR2VvbWV0cnkuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9leGFtcGxlcy9NZXNoU2hhZGVyLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvZXhhbXBsZXMvTWVzaFRleHR1cmVkLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvZXhhbXBsZXMvTWVzaFRyaWFuZ2xlLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvZXhhbXBsZXMvTWVzaFVuaWZvcm1zLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvZXhhbXBsZXMvU3ByaXRlQmFzaWMuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9leGFtcGxlcy9UZXh0dXJlR3JhZGllbnRSZXNvdXJjZS5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL2V4YW1wbGVzL1RleHR1cmVSZW5kZXIuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9leGFtcGxlcy9UZXh0dXJlUm90YXRlLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvZXhhbXBsZXMvY29udHJvbHMvRXhhbXBsZURpc3BsYXkuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9leGFtcGxlcy9jb250cm9scy9FeGFtcGxlTGlzdC5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL2ZsLXBhY2thZ2UvQnV0dG9uLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9BYnN0cmFjdFJlbmRlcmVyLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvQWNjZXNzaWJpbGl0eU1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9BbmltYXRlZFNwcml0ZS5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL0FwcGxpY2F0aW9uLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvQXJjVXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9BcnJheVJlc291cmNlLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvQXR0cmlidXRlLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvQmFzZUltYWdlUmVzb3VyY2UuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9CYXNlUHJlcGFyZS5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL0Jhc2VSZW5kZXJUZXh0dXJlLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvQmFzZVRleHR1cmUuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9CYXRjaEJ1ZmZlci5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL0JhdGNoRHJhd0NhbGwuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9CYXRjaEdlb21ldHJ5LmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvQmF0Y2hSZW5kZXJlci5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL0JhdGNoU3lzdGVtLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvQmV6aWVyVXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9CbGVuZE1vZGVzU2V0dGluZ3MuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9CbHVyRmlsdGVyLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvQmx1ckZpbHRlclBhc3MuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9Cb3VuZHMuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9CdWZmZXIuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9CdWZmZXJSZXNvdXJjZS5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL0NhY2hlU2V0dGluZ3MuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9DYW52YXNSZW5kZXJUYXJnZXQuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9DYW52YXNSZXNvdXJjZS5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL0NhbnZhc1NldHRpbmdzLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvQ2lyY2xlLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvQ2xlYW5VcFNldHRpbmdzLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvQ29sb3JNYXRyaXhGaWx0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9Db2xvclNldHRpbmdzLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvQ29udGFpbmVyLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvQ29udGV4dFN5c3RlbS5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL0NvdW50TGltaXRlci5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL0N1YmVSZXNvdXJjZS5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL0RlcHRoUmVzb3VyY2UuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9EaXNwbGFjZW1lbnRGaWx0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9EaXNwbGF5T2JqZWN0LmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvRGlzcGxheVNldHRpbmdzLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvRHJhd01vZGVTZXR0aW5ncy5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL0VsbGlwc2UuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9FdmVudC5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL0V2ZW50RGlzcGF0Y2hlci5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL0V4dHJhY3QuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9GaWxsU3R5bGUuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9GaWx0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9GaWx0ZXJTdGF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL0ZpbHRlclN5c3RlbS5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL0ZsYXNoQmFzZU9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL0ZyYW1lYnVmZmVyLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvRnJhbWVidWZmZXJTeXN0ZW0uanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9HTEJ1ZmZlci5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL0dMUHJvZ3JhbS5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL0dMVGV4dHVyZS5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL0dlb21ldHJ5LmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvR2VvbWV0cnlTeXN0ZW0uanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9HcmFwaGljcy5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL0dyYXBoaWNzRGF0YS5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL0dyYXBoaWNzR2VvbWV0cnkuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9Hcm91cEQ4LmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvSU9FcnJvckV2ZW50LmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvSW1hZ2VSZXNvdXJjZS5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL0ludGVyYWN0aW9uRGF0YS5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL0ludGVyYWN0aW9uRXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9JbnRlcmFjdGlvbk1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9JbnRlcmFjdGlvblRyYWNraW5nRGF0YS5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL0xpbmVTdHlsZS5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL0xvZ2dlci5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL01hc2tTeXN0ZW0uanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9NYXRoU2V0dGluZ3MuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9NYXRyaXguanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9NZXNoLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvTWVzaEJhdGNoVXZzLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvTWVzaEdlb21ldHJ5LmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvTWVzaE1hdGVyaWFsLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvTW91c2VFdmVudC5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL05ldHdvcmtTZXR0aW5ncy5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL09iamVjdFJlbmRlcmVyLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvT2JzZXJ2YWJsZVBvaW50LmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvUGFydGljbGVCdWZmZXIuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9QYXJ0aWNsZVJlbmRlcmVyLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvUG9pbnQuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9Qb2x5Z29uLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvUHJlcGFyZS5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL1Byb2dyYW0uanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9Qcm9ncmVzc0V2ZW50LmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvUHJvamVjdGlvblN5c3RlbS5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL1F1YWQuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9RdWFkVXYuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9RdWFkcmF0aWNVdGlscy5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL1JlY3RhbmdsZS5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL1JlbmRlclRleHR1cmUuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9SZW5kZXJUZXh0dXJlU3lzdGVtLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvUmVuZGVyZXIuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9SZXNvdXJjZS5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL1Jlc291cmNlTG9hZGVyLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvUmVzb3VyY2VTZXR0aW5ncy5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL1JvcGVHZW9tZXRyeS5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL1JvdW5kZWRSZWN0YW5nbGUuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9SdW5uZXIuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9TVkdSZXNvdXJjZS5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL1NoYWRlci5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL1NoYWRlclN5c3RlbS5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL1NoYXBlU2V0dGluZ3MuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9TaW1wbGVSb3BlLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvU3ByaXRlLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvU3ByaXRlTWFza0ZpbHRlci5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL1Nwcml0ZXNoZWV0LmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvU3RhZ2VPcHRpb25zLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvU3Rhci5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL1N0YXRlLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvU3RhdGVTeXN0ZW0uanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9TdGVuY2lsU3lzdGVtLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvU3lzdGVtLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvVGV4dC5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL1RleHRNZXRyaWNzLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvVGV4dFNldHRpbmdzLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvVGV4dFN0eWxlLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvVGV4dHVyZS5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL1RleHR1cmVHQ1N5c3RlbS5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL1RleHR1cmVNYXRyaXguanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9UZXh0dXJlU3lzdGVtLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvVGV4dHVyZVV2cy5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL1RpY2tlci5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL1RpY2tlckxpc3RlbmVyLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvVGlsaW5nU3ByaXRlUmVuZGVyZXIuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9UcmFuc2Zvcm0uanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9VUkxMb2FkZXIuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9VUkxSZXF1ZXN0LmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvVVJMUmVxdWVzdE1ldGhvZC5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL1VuaWZvcm1Hcm91cC5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL1VybC5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL1V0aWxzU2V0dGluZ3MuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9WaWRlb1Jlc291cmNlLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvV2ViR0xTZXR0aW5ncy5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL3NldHRpbmdzLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtEQUEwQyxnQ0FBZ0M7QUFDMUU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnRUFBd0Qsa0JBQWtCO0FBQzFFO0FBQ0EseURBQWlELGNBQWM7QUFDL0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUF5QyxpQ0FBaUM7QUFDMUUsd0hBQWdILG1CQUFtQixFQUFFO0FBQ3JJO0FBQ0E7O0FBRUE7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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGVBQWU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHFCQUFxQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDBCQUEwQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGNBQWM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsaUJBQWlCO0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsdUJBQXVCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRkFBK0Y7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZUFBZTtBQUM5QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsZUFBZTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZUFBZTtBQUM5QixlQUFlLGFBQWE7QUFDNUIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxlQUFlO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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Q3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGVBQWU7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixlQUFlO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RTtBQUN2RTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFO0FBQ3ZFO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxvQkFBb0IsT0FBTyxrQkFBa0I7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGNBQWM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGNBQWM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGNBQWM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLGFBQWE7QUFDNUIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLFlBQVk7QUFDM0IsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsUUFBUTtBQUN2QixnQkFBZ0IsY0FBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQixjQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZ0JBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQixjQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixnQkFBZ0IsY0FBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQixjQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEI7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQSxnQkFBZ0IsY0FBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZ0JBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsYUFBYTtBQUM1QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsWUFBWTtBQUMzQixnQkFBZ0IsY0FBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZ0JBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZ0JBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0Qixl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QUNBO0FBQ0E7QUFDQSw4RUFBOEU7QUFDOUU7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGNBQWM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixTQUFTO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLFlBQVk7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFNBQVM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFNBQVM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsK0JBQStCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFlBQVk7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLFNBQVM7QUFDcEIsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLFFBQVE7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHVCQUF1QjtBQUNqQyxVQUFVLE9BQU87QUFDakIsVUFBVSxPQUFPO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixrQkFBa0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsd0JBQXdCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHFCQUFxQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsdUJBQXVCO0FBQ2pDLFVBQVUsT0FBTztBQUNqQixVQUFVLE9BQU87QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSx1QkFBdUI7QUFDakMsVUFBVSxPQUFPO0FBQ2pCLFVBQVUsT0FBTztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLE9BQU87QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLFdBQVc7QUFDekQ7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSx1QkFBdUI7QUFDakMsVUFBVSxPQUFPO0FBQ2pCLFVBQVUsT0FBTztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixlQUFlO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixtQkFBbUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDenNEYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVELGlCQUFpQixtQkFBTyxDQUFDLG9EQUFVO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsUUFBUTtBQUMvQjtBQUNBO0FBQ0EsMkJBQTJCLFFBQVE7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsUUFBUTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixVQUFVO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzlIYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVELGdCQUFnQixtQkFBTyxDQUFDLGtEQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNuQmE7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RCw0QkFBNEIsbUJBQU8sQ0FBQywwRUFBcUI7QUFDekQsMEJBQTBCLG1CQUFPLENBQUMsc0VBQW1CO0FBQ3JELGlCQUFpQixtQkFBTyxDQUFDLG9EQUFVO0FBQ25DO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGNBQWM7QUFDNUIsY0FBYyxpQkFBaUI7QUFDL0IsY0FBYyxlQUFlO0FBQzdCLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUM5TGE7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RCxnQkFBZ0IsbUJBQU8sQ0FBQyxrREFBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNyRGE7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RCxnQkFBZ0IsbUJBQU8sQ0FBQyxrREFBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUN2QmE7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RCwwQkFBMEIsbUJBQU8sQ0FBQyxzRUFBbUI7QUFDckQsMkJBQTJCLG1CQUFPLENBQUMsd0VBQW9CO0FBQ3ZELHFCQUFxQixtQkFBTyxDQUFDLDREQUFjO0FBQzNDLGtDQUFrQyxtQkFBTyxDQUFDLHNGQUEyQjtBQUNyRSxpQkFBaUIsbUJBQU8sQ0FBQyxvREFBVTtBQUNuQyxnQkFBZ0IsbUJBQU8sQ0FBQyxrREFBUztBQUNqQyxvQkFBb0IsbUJBQU8sQ0FBQywwREFBYTtBQUN6QyxvQkFBb0IsbUJBQU8sQ0FBQywwREFBYTtBQUN6QywwQkFBMEIsbUJBQU8sQ0FBQyxzRUFBbUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixjQUFjO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGNBQWM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsUUFBUTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsUUFBUTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQixnQkFBZ0IsWUFBWTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixnQkFBZ0IsWUFBWTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCLGdCQUFnQixZQUFZO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxlQUFlO0FBQzlCLGdCQUFnQixlQUFlO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFlBQVk7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixZQUFZO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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Q2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGNBQWM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxjQUFjO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsMkJBQTJCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qix5QkFBeUI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFdBQVc7QUFDMUIsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixhQUFhO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixPQUFPO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsY0FBYztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZUFBZTtBQUM5QixnQkFBZ0IsZUFBZTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsV0FBVztBQUMxQixnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZUFBZTtBQUM5QjtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEZBQTBGO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBLGdCQUFnQjtBQUNoQjtBQUNB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsdUJBQXVCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkIsZ0JBQWdCLFFBQVE7QUFDeEIsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQix5QkFBeUI7QUFDekMsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkIsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkIsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFFBQVE7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNoaUJhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQsMEJBQTBCLG1CQUFPLENBQUMsc0VBQW1CO0FBQ3JELG9CQUFvQixtQkFBTyxDQUFDLDBEQUFhO0FBQ3pDLGdCQUFnQixtQkFBTyxDQUFDLGtEQUFTO0FBQ2pDLGdCQUFnQixtQkFBTyxDQUFDLGtEQUFTO0FBQ2pDLHFCQUFxQixtQkFBTyxDQUFDLDREQUFjO0FBQzNDLHNCQUFzQixtQkFBTyxDQUFDLDhEQUFlO0FBQzdDLHdCQUF3QixtQkFBTyxDQUFDLGtFQUFpQjtBQUNqRCx5QkFBeUIsbUJBQU8sQ0FBQyxvRUFBa0I7QUFDbkQsdUJBQXVCLG1CQUFPLENBQUMsZ0VBQWdCO0FBQy9DLHdCQUF3QixtQkFBTyxDQUFDLGtFQUFpQjtBQUNqRCwwQkFBMEIsbUJBQU8sQ0FBQyxzRUFBbUI7QUFDckQsMEJBQTBCLG1CQUFPLENBQUMsc0VBQW1CO0FBQ3JELGlCQUFpQixtQkFBTyxDQUFDLG9EQUFVO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsYUFBYTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUZBQW1GO0FBQ2xHO0FBQ0EsZUFBZSxPQUFPLGdCQUFnQix1QkFBdUI7QUFDN0QsZ0JBQWdCLGFBQWE7QUFDN0I7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0JBQW9CO0FBQ25DLGdCQUFnQixrQkFBa0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixvQ0FBb0M7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG1CQUFtQjtBQUMvQjtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx3QkFBd0I7QUFDbkM7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTyxnQkFBZ0IsdUJBQXVCO0FBQ3pELFlBQVksYUFBYTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxtQ0FBbUM7QUFDOUMsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQjtBQUNBLFlBQVksYUFBYTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzliYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVELGlCQUFpQixtQkFBTyxDQUFDLG9EQUFVO0FBQ25DLG1CQUFtQixtQkFBTyxDQUFDLHdEQUFZO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qiw0QkFBNEI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1CQUFtQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELFFBQVE7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDcEdhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQsaUJBQWlCLG1CQUFPLENBQUMsb0RBQVU7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUIsZUFBZSxhQUFhO0FBQzVCLGlCQUFpQixhQUFhO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixnQkFBZ0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ25IYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVELGlCQUFpQixtQkFBTyxDQUFDLG9EQUFVO0FBQ25DLHNCQUFzQixtQkFBTyxDQUFDLDhEQUFlO0FBQzdDLG9CQUFvQixtQkFBTyxDQUFDLDBEQUFhO0FBQ3pDLHdCQUF3QixtQkFBTyxDQUFDLGtFQUFpQjtBQUNqRCx3QkFBd0IsbUJBQU8sQ0FBQyxrRUFBaUI7QUFDakQsaUJBQWlCLG1CQUFPLENBQUMsb0RBQVU7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsaUJBQWlCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFNBQVM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsaUNBQWlDO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsOEJBQThCO0FBQzdDLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QiwrQkFBK0I7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSw4QkFBOEI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDBCQUEwQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDRCQUE0QjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlCQUFpQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlCQUFpQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDhCQUE4QjtBQUM3QyxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsaUJBQWlCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksRUFBRTtBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlCQUFpQjtBQUNoQyxlQUFlLFVBQVU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsRUFBRTtBQUNqQixpQkFBaUIsWUFBWTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsRUFBRTtBQUNqQixlQUFlLE9BQU87QUFDdEIsaUJBQWlCLFlBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsRUFBRTtBQUNqQixlQUFlLE9BQU87QUFDdEIsaUJBQWlCLFlBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2pHYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVELDJCQUEyQixtQkFBTyxDQUFDLHdFQUFvQjtBQUN2RCwwQkFBMEIsbUJBQU8sQ0FBQyxzRUFBbUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2xHYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNOYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDbkRhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQsd0JBQXdCLG1CQUFPLENBQUMsa0VBQWlCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG1CQUFtQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsbUJBQW1CO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixpQkFBaUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsUUFBUTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsTUFBTTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixnQ0FBZ0M7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiw2QkFBNkI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxPQUFPO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxPQUFPO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELE9BQU87QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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Q0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULGFBQWEsUUFBUTtBQUNyQixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhLGNBQWM7QUFDM0I7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQSwyREFBMkQsc0JBQXNCO0FBQ2pGO0FBQ0EseURBQXlELGlDQUFpQyxzQ0FBc0MsbUNBQW1DLDRCQUE0Qix5RkFBeUYsc0NBQXNDLEtBQUs7QUFDblUsK0RBQStELHNDQUFzQyxtQ0FBbUMsK0JBQStCLDZCQUE2Qiw4Q0FBOEMseUZBQXlGLCtFQUErRSxLQUFLLDRDQUE0QyxpRUFBaUUsS0FBSyw0QkFBNEIsNkNBQTZDLDZDQUE2QyxLQUFLO0FBQzVvQiIsImZpbGUiOiJpbmRleC5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGdldHRlciB9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuIFx0XHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcbiBcdFx0fVxuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuIFx0fTtcblxuIFx0Ly8gY3JlYXRlIGEgZmFrZSBuYW1lc3BhY2Ugb2JqZWN0XG4gXHQvLyBtb2RlICYgMTogdmFsdWUgaXMgYSBtb2R1bGUgaWQsIHJlcXVpcmUgaXRcbiBcdC8vIG1vZGUgJiAyOiBtZXJnZSBhbGwgcHJvcGVydGllcyBvZiB2YWx1ZSBpbnRvIHRoZSBuc1xuIFx0Ly8gbW9kZSAmIDQ6IHJldHVybiB2YWx1ZSB3aGVuIGFscmVhZHkgbnMgb2JqZWN0XG4gXHQvLyBtb2RlICYgOHwxOiBiZWhhdmUgbGlrZSByZXF1aXJlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnQgPSBmdW5jdGlvbih2YWx1ZSwgbW9kZSkge1xuIFx0XHRpZihtb2RlICYgMSkgdmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKHZhbHVlKTtcbiBcdFx0aWYobW9kZSAmIDgpIHJldHVybiB2YWx1ZTtcbiBcdFx0aWYoKG1vZGUgJiA0KSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICYmIHZhbHVlLl9fZXNNb2R1bGUpIHJldHVybiB2YWx1ZTtcbiBcdFx0dmFyIG5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yKG5zKTtcbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG5zLCAnZGVmYXVsdCcsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHZhbHVlIH0pO1xuIFx0XHRpZihtb2RlICYgMiAmJiB0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIGZvcih2YXIga2V5IGluIHZhbHVlKSBfX3dlYnBhY2tfcmVxdWlyZV9fLmQobnMsIGtleSwgZnVuY3Rpb24oa2V5KSB7IHJldHVybiB2YWx1ZVtrZXldOyB9LmJpbmQobnVsbCwga2V5KSk7XG4gXHRcdHJldHVybiBucztcbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSBcIi4vanMtY29tcGlsZS9pbmRleC5qc1wiKTtcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IEdyYXBoaWNzXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvR3JhcGhpY3NcIik7XHJcbmNvbnN0IENvbnRhaW5lcl8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0NvbnRhaW5lclwiKTtcclxuY29uc3QgRXZlbnREaXNwYXRjaGVyXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvRXZlbnREaXNwYXRjaGVyXCIpO1xyXG5jb25zdCBFdmVudF8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0V2ZW50XCIpO1xyXG5jbGFzcyBCYXNlRXhhbXBsZSBleHRlbmRzIEV2ZW50RGlzcGF0Y2hlcl8xLkV2ZW50RGlzcGF0Y2hlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihhcHAsIHdpZHRoID0gMTAwLCBoZWlnaHQgPSAxMDApIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuYmFja0NvbG9yID0gMHg5Njk2OTY7XHJcbiAgICAgICAgdGhpcy5zaXpldyA9IHdpZHRoO1xyXG4gICAgICAgIHRoaXMuc2l6ZWggPSBoZWlnaHQ7XHJcbiAgICAgICAgdGhpcy5hcHAgPSBhcHA7XHJcbiAgICAgICAgdGhpcy5zdGFnZSA9IG5ldyBDb250YWluZXJfMS5Db250YWluZXIoKTtcclxuICAgIH1cclxuICAgIGFjdGl2YXRlTWFzaygpIHtcclxuICAgICAgICB0aGlzLnN0YWdlTWFzayA9IG5ldyBHcmFwaGljc18xLkdyYXBoaWNzKCk7XHJcbiAgICAgICAgdGhpcy5zdGFnZU1hc2suYmVnaW5GaWxsKDApO1xyXG4gICAgICAgIHRoaXMuc3RhZ2VNYXNrLmRyYXdSZWN0KDAsIDAsIHRoaXMuc2l6ZXcsIHRoaXMuc2l6ZWgpO1xyXG4gICAgICAgIHRoaXMuc3RhZ2UubWFzayA9IHRoaXMuc3RhZ2VNYXNrO1xyXG4gICAgfVxyXG4gICAgZGVzdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLnN0YWdlLnJlbW92ZUNoaWxkcmVuKCk7XHJcbiAgICAgICAgaWYgKHRoaXMuc3RhZ2VNYXNrKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhZ2VNYXNrLmRlc3Ryb3kobnVsbCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZXhhbXBsZVJlYWR5KCkge1xyXG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChFdmVudF8xLkV2ZW50LmdldEV2ZW50KEV2ZW50XzEuRXZlbnQuQ09NUExFVEUpKTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLkJhc2VFeGFtcGxlID0gQmFzZUV4YW1wbGU7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IEJhc2VFeGFtcGxlXzEgPSByZXF1aXJlKFwiLi9CYXNlRXhhbXBsZVwiKTtcclxuY29uc3QgUmVzb3VyY2VMb2FkZXJfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9SZXNvdXJjZUxvYWRlclwiKTtcclxuY29uc3QgVVJMUmVxdWVzdF8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1VSTFJlcXVlc3RcIik7XHJcbmNvbnN0IEV2ZW50XzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvRXZlbnRcIik7XHJcbmNvbnN0IFRleHR1cmVfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9UZXh0dXJlXCIpO1xyXG5jb25zdCBCYXNlVGV4dHVyZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0Jhc2VUZXh0dXJlXCIpO1xyXG5jb25zdCBTcHJpdGVfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9TcHJpdGVcIik7XHJcbmNvbnN0IENvbnRhaW5lcl8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0NvbnRhaW5lclwiKTtcclxuY29uc3QgUmVjdGFuZ2xlXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvUmVjdGFuZ2xlXCIpO1xyXG5jb25zdCBGaWx0ZXJfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9GaWx0ZXJcIik7XHJcbmNvbnN0IFBvaW50XzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvUG9pbnRcIik7XHJcbmNsYXNzIEZpbHRlckJsZW5kaW5nIGV4dGVuZHMgQmFzZUV4YW1wbGVfMS5CYXNlRXhhbXBsZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihhcHAsIHdpZHRoLCBoZWlnaHQpIHtcclxuICAgICAgICBzdXBlcihhcHAsIHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgICAgIHRoaXMuaGFuZGxlR3Jhc3NMb2FkZWQgPSAoZXZlbnQpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5iYWNrZ3JvdW5kdHh0ID0gbmV3IFRleHR1cmVfMS5UZXh0dXJlKG5ldyBCYXNlVGV4dHVyZV8xLkJhc2VUZXh0dXJlKHRoaXMubG9hZGVyLmltYWdlRGF0YSkpO1xyXG4gICAgICAgICAgICBjb25zdCBiYWNrZ3JvdW5kID0gbmV3IFNwcml0ZV8xLlNwcml0ZSh0aGlzLmJhY2tncm91bmR0eHQpO1xyXG4gICAgICAgICAgICBiYWNrZ3JvdW5kLndpZHRoID0gdGhpcy5zaXpldztcclxuICAgICAgICAgICAgYmFja2dyb3VuZC5oZWlnaHQgPSB0aGlzLnNpemVoO1xyXG4gICAgICAgICAgICB0aGlzLnN0YWdlLmFkZENoaWxkKGJhY2tncm91bmQpO1xyXG4gICAgICAgICAgICBjb25zdCBzaGFkZXJGcmFnID0gYFxyXG4gICAgICAgICAgICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XHJcbiAgICAgICAgICAgIHZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xyXG4gICAgICAgICAgICB1bmlmb3JtIHZlYzIgbW91c2U7XHJcbiAgICAgICAgICAgIHVuaWZvcm0gdmVjNCBpbnB1dFNpemU7XHJcbiAgICAgICAgICAgIHVuaWZvcm0gdmVjNCBvdXRwdXRGcmFtZTtcclxuICAgICAgICAgICAgdW5pZm9ybSBmbG9hdCB0aW1lO1xyXG4gICAgICAgICAgICB2b2lkIG1haW4oKSB7XHJcbiAgICAgICAgICAgIHZlYzIgc2NyZWVuUG9zID0gdlRleHR1cmVDb29yZCAqIGlucHV0U2l6ZS54eSArIG91dHB1dEZyYW1lLnh5O1xyXG4gICAgICAgICAgICBpZiAobGVuZ3RoKG1vdXNlIC0gc2NyZWVuUG9zKSA8IDI1LjApIHtcclxuICAgICAgICAgICAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoMS4wLCAxLjAsIDAuMCwgMS4wKSAqIDAuNzsgLy95ZWxsb3cgY2lyY2xlLCBhbHBoYT0wLjdcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoIHNpbih0aW1lKSwgKG1vdXNlLnh5IC0gb3V0cHV0RnJhbWUueHkpIC8gb3V0cHV0RnJhbWUuencsIDEuMCkgKiAwLjU7IC8vIGJsZW5kIHdpdGggdW5kZXJseWluZyBpbWFnZSwgYWxwaGE9MC41XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBgO1xyXG4gICAgICAgICAgICBjb25zdCBjb250YWluZXIgPSBuZXcgQ29udGFpbmVyXzEuQ29udGFpbmVyKCk7XHJcbiAgICAgICAgICAgIGNvbnRhaW5lci5maWx0ZXJBcmVhID0gbmV3IFJlY3RhbmdsZV8xLlJlY3RhbmdsZSgxMDAsIDEwMCwgdGhpcy5zaXpldyAtIDIwMCwgdGhpcy5zaXplaCAtIDIwMCk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhZ2UuYWRkQ2hpbGQoY29udGFpbmVyKTtcclxuICAgICAgICAgICAgdGhpcy5maWx0ZXIgPSBuZXcgRmlsdGVyXzEuRmlsdGVyKG51bGwsIHNoYWRlckZyYWcsIHtcclxuICAgICAgICAgICAgICAgIG1vdXNlOiBuZXcgUG9pbnRfMS5Qb2ludCgpXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBjb250YWluZXIuZmlsdGVycyA9IFt0aGlzLmZpbHRlcl07XHJcbiAgICAgICAgICAgIHRoaXMuYXBwLnRpY2tlci5hZGQodGhpcy5ydW5FeGFtcGxlKTtcclxuICAgICAgICAgICAgdGhpcy5leGFtcGxlUmVhZHkoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMucnVuRXhhbXBsZSA9IChkZWx0YSkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLmZpbHRlci51bmlmb3Jtcy5tb3VzZS5jb3B5RnJvbSh0aGlzLmFwcC5yZW5kZXJlci5wbHVnaW5zLmludGVyYWN0aW9uLm1vdXNlLmdsb2JhbCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLmxvYWRlciA9IG5ldyBSZXNvdXJjZUxvYWRlcl8xLlJlc291cmNlTG9hZGVyKG5ldyBVUkxSZXF1ZXN0XzEuVVJMUmVxdWVzdChcImV4YW1wbGVzL2Fzc2V0cy9iZ19ncmFzcy5qcGdcIikpO1xyXG4gICAgICAgIHRoaXMubG9hZGVyLmFkZEV2ZW50TGlzdGVuZXIoRXZlbnRfMS5FdmVudC5DT01QTEVURSwgdGhpcy5oYW5kbGVHcmFzc0xvYWRlZCk7XHJcbiAgICAgICAgdGhpcy5sb2FkZXIubG9hZCgpO1xyXG4gICAgfVxyXG4gICAgZGVzdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlci5kZXN0cnVjdG9yKCk7XHJcbiAgICAgICAgdGhpcy5iYWNrZ3JvdW5kdHh0LmRlc3Ryb3kobnVsbCk7XHJcbiAgICAgICAgdGhpcy5iYWNrZ3JvdW5kdHh0ID0gbnVsbDtcclxuICAgICAgICB0aGlzLmZpbHRlci5kZXN0cm95KCk7XHJcbiAgICAgICAgdGhpcy5maWx0ZXIgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuYXBwLnRpY2tlci5yZW1vdmUodGhpcy5ydW5FeGFtcGxlLCBudWxsKTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLkZpbHRlckJsZW5kaW5nID0gRmlsdGVyQmxlbmRpbmc7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IEJhc2VFeGFtcGxlXzEgPSByZXF1aXJlKFwiLi9CYXNlRXhhbXBsZVwiKTtcclxuY29uc3QgUmVzb3VyY2VMb2FkZXJfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9SZXNvdXJjZUxvYWRlclwiKTtcclxuY29uc3QgVGV4dHVyZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1RleHR1cmVcIik7XHJcbmNvbnN0IFVSTFJlcXVlc3RfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9VUkxSZXF1ZXN0XCIpO1xyXG5jb25zdCBFdmVudF8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0V2ZW50XCIpO1xyXG5jb25zdCBCYXNlVGV4dHVyZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0Jhc2VUZXh0dXJlXCIpO1xyXG5jb25zdCBTcHJpdGVfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9TcHJpdGVcIik7XHJcbmNvbnN0IEJsdXJGaWx0ZXJfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9CbHVyRmlsdGVyXCIpO1xyXG5jbGFzcyBGaWx0ZXJCbHVyIGV4dGVuZHMgQmFzZUV4YW1wbGVfMS5CYXNlRXhhbXBsZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihhcHAsIHdpZHRoLCBoZWlnaHQpIHtcclxuICAgICAgICBzdXBlcihhcHAsIHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgICAgIHRoaXMuaGFuZGxlTW9ieUxvYWRlZCA9IChldmVudCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLm1vYnlUeHQgPSBuZXcgVGV4dHVyZV8xLlRleHR1cmUobmV3IEJhc2VUZXh0dXJlXzEuQmFzZVRleHR1cmUodGhpcy5sb2FkZXIuaW1hZ2VEYXRhKSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGJnID0gbmV3IFNwcml0ZV8xLlNwcml0ZSh0aGlzLmRlcHRoVHh0KTtcclxuICAgICAgICAgICAgYmcud2lkdGggPSB0aGlzLnNpemV3O1xyXG4gICAgICAgICAgICBiZy5oZWlnaHQgPSB0aGlzLnNpemVoO1xyXG4gICAgICAgICAgICB0aGlzLnN0YWdlLmFkZENoaWxkKGJnKTtcclxuICAgICAgICAgICAgY29uc3QgbGl0dGxlRHVkZXMgPSBuZXcgU3ByaXRlXzEuU3ByaXRlKHRoaXMuZHVkZXNUeHQpO1xyXG4gICAgICAgICAgICBsaXR0bGVEdWRlcy54ID0gKHRoaXMuc2l6ZXcgLyAyKSAtIDMxNTtcclxuICAgICAgICAgICAgbGl0dGxlRHVkZXMueSA9IDIwMDtcclxuICAgICAgICAgICAgdGhpcy5zdGFnZS5hZGRDaGlsZChsaXR0bGVEdWRlcyk7XHJcbiAgICAgICAgICAgIGNvbnN0IGxpdHRsZVJvYm90ID0gbmV3IFNwcml0ZV8xLlNwcml0ZSh0aGlzLm1vYnlUeHQpO1xyXG4gICAgICAgICAgICBsaXR0bGVSb2JvdC54ID0gKHRoaXMuc2l6ZXcgLyAyKSAtIDIwMDtcclxuICAgICAgICAgICAgbGl0dGxlUm9ib3QueSA9IDEwMDtcclxuICAgICAgICAgICAgdGhpcy5zdGFnZS5hZGRDaGlsZChsaXR0bGVSb2JvdCk7XHJcbiAgICAgICAgICAgIHRoaXMuYmx1ckZpbHRlcjEgPSBuZXcgQmx1ckZpbHRlcl8xLkJsdXJGaWx0ZXIoKTtcclxuICAgICAgICAgICAgdGhpcy5ibHVyRmlsdGVyMiA9IG5ldyBCbHVyRmlsdGVyXzEuQmx1ckZpbHRlcigpO1xyXG4gICAgICAgICAgICBsaXR0bGVEdWRlcy5maWx0ZXJzID0gW3RoaXMuYmx1ckZpbHRlcjFdO1xyXG4gICAgICAgICAgICBsaXR0bGVSb2JvdC5maWx0ZXJzID0gW3RoaXMuYmx1ckZpbHRlcjJdO1xyXG4gICAgICAgICAgICB0aGlzLmNvdW50ID0gMDtcclxuICAgICAgICAgICAgdGhpcy5hcHAudGlja2VyLmFkZCh0aGlzLnJ1bkV4YW1wbGUpO1xyXG4gICAgICAgICAgICB0aGlzLmV4YW1wbGVSZWFkeSgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5ydW5FeGFtcGxlID0gKGRlbHRhKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuY291bnQgKz0gMC4wMDU7XHJcbiAgICAgICAgICAgIGNvbnN0IGJsdXJBbW91bnQgPSBNYXRoLmNvcyh0aGlzLmNvdW50KTtcclxuICAgICAgICAgICAgY29uc3QgYmx1ckFtb3VudDIgPSBNYXRoLnNpbih0aGlzLmNvdW50KTtcclxuICAgICAgICAgICAgdGhpcy5ibHVyRmlsdGVyMS5ibHVyID0gMjAgKiAoYmx1ckFtb3VudCk7XHJcbiAgICAgICAgICAgIHRoaXMuYmx1ckZpbHRlcjIuYmx1ciA9IDIwICogKGJsdXJBbW91bnQyKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuaGFuZGxlRHVkZXNMb2FkZWQgPSAoZXZlbnQpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5kdWRlc1R4dCA9IG5ldyBUZXh0dXJlXzEuVGV4dHVyZShuZXcgQmFzZVRleHR1cmVfMS5CYXNlVGV4dHVyZSh0aGlzLmxvYWRlci5pbWFnZURhdGEpKTtcclxuICAgICAgICAgICAgdGhpcy5sb2FkZXIgPSBuZXcgUmVzb3VyY2VMb2FkZXJfMS5SZXNvdXJjZUxvYWRlcihuZXcgVVJMUmVxdWVzdF8xLlVSTFJlcXVlc3QoXCJleGFtcGxlcy9hc3NldHMvcGl4aS1maWx0ZXJzL2RlcHRoX2JsdXJfbW9ieS5qcGdcIikpO1xyXG4gICAgICAgICAgICB0aGlzLmxvYWRlci5hZGRFdmVudExpc3RlbmVyKEV2ZW50XzEuRXZlbnQuQ09NUExFVEUsIHRoaXMuaGFuZGxlTW9ieUxvYWRlZCk7XHJcbiAgICAgICAgICAgIHRoaXMubG9hZGVyLmxvYWQoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuaGFuZGxlRGVwdGhMb2FkZWQgPSAoZXZlbnQpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5kZXB0aFR4dCA9IG5ldyBUZXh0dXJlXzEuVGV4dHVyZShuZXcgQmFzZVRleHR1cmVfMS5CYXNlVGV4dHVyZSh0aGlzLmxvYWRlci5pbWFnZURhdGEpKTtcclxuICAgICAgICAgICAgdGhpcy5sb2FkZXIgPSBuZXcgUmVzb3VyY2VMb2FkZXJfMS5SZXNvdXJjZUxvYWRlcihuZXcgVVJMUmVxdWVzdF8xLlVSTFJlcXVlc3QoXCJleGFtcGxlcy9hc3NldHMvcGl4aS1maWx0ZXJzL2RlcHRoX2JsdXJfZHVkZXMuanBnXCIpKTtcclxuICAgICAgICAgICAgdGhpcy5sb2FkZXIuYWRkRXZlbnRMaXN0ZW5lcihFdmVudF8xLkV2ZW50LkNPTVBMRVRFLCB0aGlzLmhhbmRsZUR1ZGVzTG9hZGVkKTtcclxuICAgICAgICAgICAgdGhpcy5sb2FkZXIubG9hZCgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5sb2FkZXIgPSBuZXcgUmVzb3VyY2VMb2FkZXJfMS5SZXNvdXJjZUxvYWRlcihuZXcgVVJMUmVxdWVzdF8xLlVSTFJlcXVlc3QoXCJleGFtcGxlcy9hc3NldHMvcGl4aS1maWx0ZXJzL2JnX2RlcHRoX2JsdXIuanBnXCIpKTtcclxuICAgICAgICB0aGlzLmxvYWRlci5hZGRFdmVudExpc3RlbmVyKEV2ZW50XzEuRXZlbnQuQ09NUExFVEUsIHRoaXMuaGFuZGxlRGVwdGhMb2FkZWQpO1xyXG4gICAgICAgIHRoaXMubG9hZGVyLmxvYWQoKTtcclxuICAgIH1cclxuICAgIGRlc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIuZGVzdHJ1Y3RvcigpO1xyXG4gICAgICAgIHRoaXMuYXBwLnRpY2tlci5yZW1vdmUodGhpcy5ydW5FeGFtcGxlLCBudWxsKTtcclxuICAgICAgICB0aGlzLmJsdXJGaWx0ZXIxLmRlc3Ryb3koKTtcclxuICAgICAgICB0aGlzLmJsdXJGaWx0ZXIxID0gbnVsbDtcclxuICAgICAgICB0aGlzLmJsdXJGaWx0ZXIyLmRlc3Ryb3koKTtcclxuICAgICAgICB0aGlzLmJsdXJGaWx0ZXIyID0gbnVsbDtcclxuICAgICAgICB0aGlzLm1vYnlUeHQuZGVzdHJveShudWxsKTtcclxuICAgICAgICB0aGlzLm1vYnlUeHQgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuZHVkZXNUeHQuZGVzdHJveShudWxsKTtcclxuICAgICAgICB0aGlzLmR1ZGVzVHh0ID0gbnVsbDtcclxuICAgICAgICB0aGlzLmRlcHRoVHh0LmRlc3Ryb3kobnVsbCk7XHJcbiAgICAgICAgdGhpcy5kZXB0aFR4dCA9IG51bGw7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5GaWx0ZXJCbHVyID0gRmlsdGVyQmx1cjtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgQmFzZUV4YW1wbGVfMSA9IHJlcXVpcmUoXCIuL0Jhc2VFeGFtcGxlXCIpO1xyXG5jb25zdCBSZXNvdXJjZUxvYWRlcl8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1Jlc291cmNlTG9hZGVyXCIpO1xyXG5jb25zdCBUZXh0dXJlXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvVGV4dHVyZVwiKTtcclxuY29uc3QgVVJMUmVxdWVzdF8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1VSTFJlcXVlc3RcIik7XHJcbmNvbnN0IEV2ZW50XzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvRXZlbnRcIik7XHJcbmNvbnN0IEJhc2VUZXh0dXJlXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvQmFzZVRleHR1cmVcIik7XHJcbmNvbnN0IFNwcml0ZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1Nwcml0ZVwiKTtcclxuY29uc3QgQ29sb3JNYXRyaXhGaWx0ZXJfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9Db2xvck1hdHJpeEZpbHRlclwiKTtcclxuY29uc3QgVGV4dF8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1RleHRcIik7XHJcbmNvbnN0IENvbnRhaW5lcl8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0NvbnRhaW5lclwiKTtcclxuY29uc3QgTW91c2VFdmVudF8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL01vdXNlRXZlbnRcIik7XHJcbmNsYXNzIEZpbHRlckNvbG9yIGV4dGVuZHMgQmFzZUV4YW1wbGVfMS5CYXNlRXhhbXBsZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihhcHAsIHdpZHRoLCBoZWlnaHQpIHtcclxuICAgICAgICBzdXBlcihhcHAsIHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgICAgIHRoaXMuaGFuZGxlUGFuZGFMb2FkZWQgPSAoZXZlbnQpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5wYW5kYVR4dCA9IG5ldyBUZXh0dXJlXzEuVGV4dHVyZShuZXcgQmFzZVRleHR1cmVfMS5CYXNlVGV4dHVyZSh0aGlzLmxvYWRlci5pbWFnZURhdGEpKTtcclxuICAgICAgICAgICAgdGhpcy5iZyA9IG5ldyBTcHJpdGVfMS5TcHJpdGUodGhpcy5yb3RhdGVUeHQpO1xyXG4gICAgICAgICAgICB0aGlzLmJnLmFuY2hvci5zZXQoMC41KTtcclxuICAgICAgICAgICAgdGhpcy5iZy54ID0gdGhpcy5zaXpldyAvIDI7XHJcbiAgICAgICAgICAgIHRoaXMuYmcueSA9IHRoaXMuc2l6ZWggLyAyO1xyXG4gICAgICAgICAgICB0aGlzLmZpbHRlciA9IG5ldyBDb2xvck1hdHJpeEZpbHRlcl8xLkNvbG9yTWF0cml4RmlsdGVyKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IG5ldyBDb250YWluZXJfMS5Db250YWluZXIoKTtcclxuICAgICAgICAgICAgY29udGFpbmVyLnggPSB0aGlzLnNpemV3IC8gMjtcclxuICAgICAgICAgICAgY29udGFpbmVyLnkgPSB0aGlzLnNpemVoIC8gMjtcclxuICAgICAgICAgICAgdGhpcy5iZ0Zyb250ID0gbmV3IFNwcml0ZV8xLlNwcml0ZSh0aGlzLnNjZW5lcm90YXRlVHh0KTtcclxuICAgICAgICAgICAgdGhpcy5iZ0Zyb250LmFuY2hvci5zZXQoMC41KTtcclxuICAgICAgICAgICAgY29udGFpbmVyLmFkZENoaWxkKHRoaXMuYmdGcm9udCk7XHJcbiAgICAgICAgICAgIHRoaXMubGlnaHQyID0gbmV3IFNwcml0ZV8xLlNwcml0ZSh0aGlzLmxpZ2h0cm90YXRlMlR4dCk7XHJcbiAgICAgICAgICAgIHRoaXMubGlnaHQyLmFuY2hvci5zZXQoMC41KTtcclxuICAgICAgICAgICAgY29udGFpbmVyLmFkZENoaWxkKHRoaXMubGlnaHQyKTtcclxuICAgICAgICAgICAgdGhpcy5saWdodDEgPSBuZXcgU3ByaXRlXzEuU3ByaXRlKHRoaXMubGlnaHRyb3RhdGUxVHh0KTtcclxuICAgICAgICAgICAgdGhpcy5saWdodDEuYW5jaG9yLnNldCgwLjUpO1xyXG4gICAgICAgICAgICBjb250YWluZXIuYWRkQ2hpbGQodGhpcy5saWdodDEpO1xyXG4gICAgICAgICAgICB0aGlzLnBhbmRhID0gbmV3IFNwcml0ZV8xLlNwcml0ZSh0aGlzLnBhbmRhVHh0KTtcclxuICAgICAgICAgICAgdGhpcy5wYW5kYS5hbmNob3Iuc2V0KDAuNSk7XHJcbiAgICAgICAgICAgIGNvbnRhaW5lci5hZGRDaGlsZCh0aGlzLnBhbmRhKTtcclxuICAgICAgICAgICAgdGhpcy5zdGFnZS5hZGRDaGlsZChjb250YWluZXIpO1xyXG4gICAgICAgICAgICB0aGlzLnN0YWdlLmZpbHRlcnMgPSBbdGhpcy5maWx0ZXJdO1xyXG4gICAgICAgICAgICB0aGlzLmNvdW50ID0gMDtcclxuICAgICAgICAgICAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5zdGFnZS5hZGRFdmVudExpc3RlbmVyKE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50LlBPSU5URVJfVEFQLCB0aGlzLmhhbmRsZVBvaW50ZXIpO1xyXG4gICAgICAgICAgICBjb25zdCBoZWxwID0gbmV3IFRleHRfMS5UZXh0KCdDbGljayBvciB0YXAgdG8gdHVybiBmaWx0ZXJzIG9uIC8gb2ZmLicsIHtcclxuICAgICAgICAgICAgICAgIGZvbnRGYW1pbHk6ICdBcmlhbCcsXHJcbiAgICAgICAgICAgICAgICBmb250U2l6ZTogMTIsXHJcbiAgICAgICAgICAgICAgICBmb250V2VpZ2h0OiAnYm9sZCcsXHJcbiAgICAgICAgICAgICAgICBmaWxsOiAnd2hpdGUnLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgaGVscC55ID0gdGhpcy5zaXplaCAtIDI1O1xyXG4gICAgICAgICAgICBoZWxwLnggPSAxMDtcclxuICAgICAgICAgICAgdGhpcy5zdGFnZS5hZGRDaGlsZChoZWxwKTtcclxuICAgICAgICAgICAgdGhpcy5hcHAudGlja2VyLmFkZCh0aGlzLnJ1bkV4YW1wbGUpO1xyXG4gICAgICAgICAgICB0aGlzLmV4YW1wbGVSZWFkeSgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5ydW5FeGFtcGxlID0gKGRlbHRhKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuYmcucm90YXRpb24gKz0gMC4wMTtcclxuICAgICAgICAgICAgdGhpcy5iZ0Zyb250LnJvdGF0aW9uIC09IDAuMDE7XHJcbiAgICAgICAgICAgIHRoaXMubGlnaHQxLnJvdGF0aW9uICs9IDAuMDI7XHJcbiAgICAgICAgICAgIHRoaXMubGlnaHQyLnJvdGF0aW9uICs9IDAuMDE7XHJcbiAgICAgICAgICAgIHRoaXMucGFuZGEuc2NhbGUueCA9IDEgKyBNYXRoLnNpbih0aGlzLmNvdW50KSAqIDAuMDQ7XHJcbiAgICAgICAgICAgIHRoaXMucGFuZGEuc2NhbGUueSA9IDEgKyBNYXRoLmNvcyh0aGlzLmNvdW50KSAqIDAuMDQ7XHJcbiAgICAgICAgICAgIHRoaXMuY291bnQgKz0gMC4xO1xyXG4gICAgICAgICAgICBjb25zdCB7IG1hdHJpeCB9ID0gdGhpcy5maWx0ZXI7XHJcbiAgICAgICAgICAgIG1hdHJpeFsxXSA9IE1hdGguc2luKHRoaXMuY291bnQpICogMztcclxuICAgICAgICAgICAgbWF0cml4WzJdID0gTWF0aC5jb3ModGhpcy5jb3VudCk7XHJcbiAgICAgICAgICAgIG1hdHJpeFszXSA9IE1hdGguY29zKHRoaXMuY291bnQpICogMS41O1xyXG4gICAgICAgICAgICBtYXRyaXhbNF0gPSBNYXRoLnNpbih0aGlzLmNvdW50IC8gMykgKiAyO1xyXG4gICAgICAgICAgICBtYXRyaXhbNV0gPSBNYXRoLnNpbih0aGlzLmNvdW50IC8gMik7XHJcbiAgICAgICAgICAgIG1hdHJpeFs2XSA9IE1hdGguc2luKHRoaXMuY291bnQgLyA0KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuaGFuZGxlUG9pbnRlciA9IChldmVudCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLmVuYWJsZWQgPSAhdGhpcy5lbmFibGVkO1xyXG4gICAgICAgICAgICB0aGlzLnN0YWdlLmZpbHRlcnMgPSB0aGlzLmVuYWJsZWQgPyBbdGhpcy5maWx0ZXJdIDogbnVsbDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuaGFuZGxlTGlnaHRSb3RhdGUxTG9hZGVkID0gKGV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMubGlnaHRyb3RhdGUxVHh0ID0gbmV3IFRleHR1cmVfMS5UZXh0dXJlKG5ldyBCYXNlVGV4dHVyZV8xLkJhc2VUZXh0dXJlKHRoaXMubG9hZGVyLmltYWdlRGF0YSkpO1xyXG4gICAgICAgICAgICB0aGlzLmxvYWRlciA9IG5ldyBSZXNvdXJjZUxvYWRlcl8xLlJlc291cmNlTG9hZGVyKG5ldyBVUkxSZXF1ZXN0XzEuVVJMUmVxdWVzdChcImV4YW1wbGVzL2Fzc2V0cy9saWdodF9yb3RhdGVfMS5wbmdcIikpO1xyXG4gICAgICAgICAgICB0aGlzLmxvYWRlci5hZGRFdmVudExpc3RlbmVyKEV2ZW50XzEuRXZlbnQuQ09NUExFVEUsIHRoaXMuaGFuZGxlTGlnaHRSb3RhdGUxTG9hZGVkKTtcclxuICAgICAgICAgICAgdGhpcy5sb2FkZXIubG9hZCgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5oYW5kbGVSb3RhdGVMb2FkZWQgPSAoZXZlbnQpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5yb3RhdGVUeHQgPSBuZXcgVGV4dHVyZV8xLlRleHR1cmUobmV3IEJhc2VUZXh0dXJlXzEuQmFzZVRleHR1cmUodGhpcy5sb2FkZXIuaW1hZ2VEYXRhKSk7XHJcbiAgICAgICAgICAgIHRoaXMubG9hZGVyID0gbmV3IFJlc291cmNlTG9hZGVyXzEuUmVzb3VyY2VMb2FkZXIobmV3IFVSTFJlcXVlc3RfMS5VUkxSZXF1ZXN0KFwiZXhhbXBsZXMvYXNzZXRzL2JnX3NjZW5lX3JvdGF0ZS5qcGdcIikpO1xyXG4gICAgICAgICAgICB0aGlzLmxvYWRlci5hZGRFdmVudExpc3RlbmVyKEV2ZW50XzEuRXZlbnQuQ09NUExFVEUsIHRoaXMuaGFuZGxlU2NlbmVSb3RhdGVMb2FkZWQpO1xyXG4gICAgICAgICAgICB0aGlzLmxvYWRlci5sb2FkKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLmhhbmRsZVNjZW5lUm90YXRlTG9hZGVkID0gKGV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuc2NlbmVyb3RhdGVUeHQgPSBuZXcgVGV4dHVyZV8xLlRleHR1cmUobmV3IEJhc2VUZXh0dXJlXzEuQmFzZVRleHR1cmUodGhpcy5sb2FkZXIuaW1hZ2VEYXRhKSk7XHJcbiAgICAgICAgICAgIHRoaXMubG9hZGVyID0gbmV3IFJlc291cmNlTG9hZGVyXzEuUmVzb3VyY2VMb2FkZXIobmV3IFVSTFJlcXVlc3RfMS5VUkxSZXF1ZXN0KFwiZXhhbXBsZXMvYXNzZXRzL2xpZ2h0X3JvdGF0ZV8yLnBuZ1wiKSk7XHJcbiAgICAgICAgICAgIHRoaXMubG9hZGVyLmFkZEV2ZW50TGlzdGVuZXIoRXZlbnRfMS5FdmVudC5DT01QTEVURSwgdGhpcy5oYW5kbGVMaWdodFJvdGF0ZTJMb2FkZWQpO1xyXG4gICAgICAgICAgICB0aGlzLmxvYWRlci5sb2FkKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLmhhbmRsZUxpZ2h0Um90YXRlMkxvYWRlZCA9IChldmVudCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLmxpZ2h0cm90YXRlMlR4dCA9IG5ldyBUZXh0dXJlXzEuVGV4dHVyZShuZXcgQmFzZVRleHR1cmVfMS5CYXNlVGV4dHVyZSh0aGlzLmxvYWRlci5pbWFnZURhdGEpKTtcclxuICAgICAgICAgICAgdGhpcy5sb2FkZXIgPSBuZXcgUmVzb3VyY2VMb2FkZXJfMS5SZXNvdXJjZUxvYWRlcihuZXcgVVJMUmVxdWVzdF8xLlVSTFJlcXVlc3QoXCJleGFtcGxlcy9hc3NldHMvcGFuZGEucG5nXCIpKTtcclxuICAgICAgICAgICAgdGhpcy5sb2FkZXIuYWRkRXZlbnRMaXN0ZW5lcihFdmVudF8xLkV2ZW50LkNPTVBMRVRFLCB0aGlzLmhhbmRsZVBhbmRhTG9hZGVkKTtcclxuICAgICAgICAgICAgdGhpcy5sb2FkZXIubG9hZCgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5iYWNrQ29sb3IgPSAwO1xyXG4gICAgICAgIHRoaXMuYWN0aXZhdGVNYXNrKCk7XHJcbiAgICAgICAgdGhpcy5zdGFnZS5pbnRlcmFjdGl2ZSA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5sb2FkZXIgPSBuZXcgUmVzb3VyY2VMb2FkZXJfMS5SZXNvdXJjZUxvYWRlcihuZXcgVVJMUmVxdWVzdF8xLlVSTFJlcXVlc3QoXCJleGFtcGxlcy9hc3NldHMvYmdfcm90YXRlLmpwZ1wiKSk7XHJcbiAgICAgICAgdGhpcy5sb2FkZXIuYWRkRXZlbnRMaXN0ZW5lcihFdmVudF8xLkV2ZW50LkNPTVBMRVRFLCB0aGlzLmhhbmRsZVJvdGF0ZUxvYWRlZCk7XHJcbiAgICAgICAgdGhpcy5sb2FkZXIubG9hZCgpO1xyXG4gICAgfVxyXG4gICAgZGVzdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlci5kZXN0cnVjdG9yKCk7XHJcbiAgICAgICAgdGhpcy5iZy5kZXN0cm95KG51bGwpO1xyXG4gICAgICAgIHRoaXMuYmcgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuYmdGcm9udC5kZXN0cm95KG51bGwpO1xyXG4gICAgICAgIHRoaXMuYmdGcm9udCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5saWdodDIuZGVzdHJveShudWxsKTtcclxuICAgICAgICB0aGlzLmxpZ2h0MiA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5wYW5kYS5kZXN0cm95KG51bGwpO1xyXG4gICAgICAgIHRoaXMucGFuZGEgPSBudWxsO1xyXG4gICAgICAgIHRoaXMubGlnaHQxLmRlc3Ryb3kobnVsbCk7XHJcbiAgICAgICAgdGhpcy5saWdodDEgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuZmlsdGVyLmRlc3Ryb3koKTtcclxuICAgICAgICB0aGlzLmZpbHRlciA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5hcHAudGlja2VyLnJlbW92ZSh0aGlzLnJ1bkV4YW1wbGUsIG51bGwpO1xyXG4gICAgICAgIHRoaXMucm90YXRlVHh0LmRlc3Ryb3kobnVsbCk7XHJcbiAgICAgICAgdGhpcy5yb3RhdGVUeHQgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuc2NlbmVyb3RhdGVUeHQuZGVzdHJveShudWxsKTtcclxuICAgICAgICB0aGlzLnNjZW5lcm90YXRlVHh0ID0gbnVsbDtcclxuICAgICAgICB0aGlzLmxpZ2h0cm90YXRlMlR4dC5kZXN0cm95KG51bGwpO1xyXG4gICAgICAgIHRoaXMubGlnaHRyb3RhdGUyVHh0ID0gbnVsbDtcclxuICAgICAgICB0aGlzLmxpZ2h0cm90YXRlMVR4dC5kZXN0cm95KG51bGwpO1xyXG4gICAgICAgIHRoaXMubGlnaHRyb3RhdGUxVHh0ID0gbnVsbDtcclxuICAgICAgICB0aGlzLnBhbmRhVHh0LmRlc3Ryb3kobnVsbCk7XHJcbiAgICAgICAgdGhpcy5wYW5kYVR4dCA9IG51bGw7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5GaWx0ZXJDb2xvciA9IEZpbHRlckNvbG9yO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBCYXNlRXhhbXBsZV8xID0gcmVxdWlyZShcIi4vQmFzZUV4YW1wbGVcIik7XHJcbmNvbnN0IFJlc291cmNlTG9hZGVyXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvUmVzb3VyY2VMb2FkZXJcIik7XHJcbmNvbnN0IFRleHR1cmVfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9UZXh0dXJlXCIpO1xyXG5jb25zdCBDb250YWluZXJfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9Db250YWluZXJcIik7XHJcbmNvbnN0IFJlY3RhbmdsZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1JlY3RhbmdsZVwiKTtcclxuY29uc3QgTW91c2VFdmVudF8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL01vdXNlRXZlbnRcIik7XHJcbmNvbnN0IFNwcml0ZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1Nwcml0ZVwiKTtcclxuY29uc3QgVVJMUmVxdWVzdF8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1VSTFJlcXVlc3RcIik7XHJcbmNvbnN0IEV2ZW50XzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvRXZlbnRcIik7XHJcbmNvbnN0IEJhc2VUZXh0dXJlXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvQmFzZVRleHR1cmVcIik7XHJcbmNvbnN0IFBvaW50XzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvUG9pbnRcIik7XHJcbmNvbnN0IERpc3BsYWNlbWVudEZpbHRlcl8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0Rpc3BsYWNlbWVudEZpbHRlclwiKTtcclxuY2xhc3MgRmlsdGVyQ3Jhd2xpZXMgZXh0ZW5kcyBCYXNlRXhhbXBsZV8xLkJhc2VFeGFtcGxlIHtcclxuICAgIGNvbnN0cnVjdG9yKGFwcCwgd2lkdGgsIGhlaWdodCkge1xyXG4gICAgICAgIHN1cGVyKGFwcCwgd2lkdGgsIGhlaWdodCk7XHJcbiAgICAgICAgdGhpcy5oYW5kbGVHcmFzc0xvYWRlZCA9IChldmVudCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLmdyYXNzVHh0ID0gbmV3IFRleHR1cmVfMS5UZXh0dXJlKG5ldyBCYXNlVGV4dHVyZV8xLkJhc2VUZXh0dXJlKHRoaXMubG9hZGVyLmltYWdlRGF0YSkpO1xyXG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lciA9IG5ldyBDb250YWluZXJfMS5Db250YWluZXIoKTtcclxuICAgICAgICAgICAgdGhpcy5zdGFnZS5hZGRDaGlsZCh0aGlzLmNvbnRhaW5lcik7XHJcbiAgICAgICAgICAgIGNvbnN0IHBhZGRpbmcgPSAxMDA7XHJcbiAgICAgICAgICAgIHRoaXMuYm91bmRzID0gbmV3IFJlY3RhbmdsZV8xLlJlY3RhbmdsZSgtcGFkZGluZywgLXBhZGRpbmcsIHRoaXMuc2l6ZXcgKyBwYWRkaW5nICogMiwgdGhpcy5zaXplaCArIHBhZGRpbmcgKiAyKTtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAyMDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBtYWdnb3QgPSBuZXcgRXh0ZW5kZWRTcHJpdGUodGhpcy5tYWdnb3RUeHQpO1xyXG4gICAgICAgICAgICAgICAgbWFnZ290LmFuY2hvci5zZXQoMC41KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLmFkZENoaWxkKG1hZ2dvdCk7XHJcbiAgICAgICAgICAgICAgICBtYWdnb3QuZGlyZWN0aW9uID0gTWF0aC5yYW5kb20oKSAqIE1hdGguUEkgKiAyO1xyXG4gICAgICAgICAgICAgICAgbWFnZ290LnNwZWVkID0gMTtcclxuICAgICAgICAgICAgICAgIG1hZ2dvdC50dXJuU3BlZWQgPSBNYXRoLnJhbmRvbSgpIC0gMC44O1xyXG4gICAgICAgICAgICAgICAgbWFnZ290LnggPSBNYXRoLnJhbmRvbSgpICogdGhpcy5ib3VuZHMud2lkdGg7XHJcbiAgICAgICAgICAgICAgICBtYWdnb3QueSA9IE1hdGgucmFuZG9tKCkgKiB0aGlzLmJvdW5kcy5oZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICBtYWdnb3Quc2NhbGUuc2V0KDEgKyBNYXRoLnJhbmRvbSgpICogMC4zKTtcclxuICAgICAgICAgICAgICAgIG1hZ2dvdC5vcmlnaW5hbCA9IG5ldyBQb2ludF8xLlBvaW50KCk7XHJcbiAgICAgICAgICAgICAgICBtYWdnb3Qub3JpZ2luYWwuY29weUZyb20obWFnZ290LnNjYWxlKTtcclxuICAgICAgICAgICAgICAgIHRoaXMubWFnZ290cy5wdXNoKG1hZ2dvdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5kaXNwbGFjZW1lbnRTcHJpdGUgPSBuZXcgU3ByaXRlXzEuU3ByaXRlKHRoaXMuZGlzcGxhY2VtZW50VHh0KTtcclxuICAgICAgICAgICAgY29uc3QgZGlzcGxhY2VtZW50RmlsdGVyID0gbmV3IERpc3BsYWNlbWVudEZpbHRlcl8xLkRpc3BsYWNlbWVudEZpbHRlcih0aGlzLmRpc3BsYWNlbWVudFNwcml0ZSk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhZ2UuYWRkQ2hpbGQodGhpcy5kaXNwbGFjZW1lbnRTcHJpdGUpO1xyXG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5maWx0ZXJzID0gW2Rpc3BsYWNlbWVudEZpbHRlcl07XHJcbiAgICAgICAgICAgIGRpc3BsYWNlbWVudEZpbHRlci5zY2FsZS54ID0gMTEwO1xyXG4gICAgICAgICAgICBkaXNwbGFjZW1lbnRGaWx0ZXIuc2NhbGUueSA9IDExMDtcclxuICAgICAgICAgICAgdGhpcy5kaXNwbGFjZW1lbnRTcHJpdGUuYW5jaG9yLnNldCgwLjUpO1xyXG4gICAgICAgICAgICB0aGlzLnJpbmcgPSBuZXcgU3ByaXRlXzEuU3ByaXRlKHRoaXMucmluZ1R4dCk7XHJcbiAgICAgICAgICAgIHRoaXMucmluZy5hbmNob3Iuc2V0KDAuNSk7XHJcbiAgICAgICAgICAgIHRoaXMucmluZy52aXNpYmxlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhZ2UuYWRkQ2hpbGQodGhpcy5yaW5nKTtcclxuICAgICAgICAgICAgY29uc3QgYmcgPSBuZXcgU3ByaXRlXzEuU3ByaXRlKHRoaXMuZ3Jhc3NUeHQpO1xyXG4gICAgICAgICAgICBiZy53aWR0aCA9IHRoaXMuc2l6ZXc7XHJcbiAgICAgICAgICAgIGJnLmhlaWdodCA9IHRoaXMuc2l6ZWg7XHJcbiAgICAgICAgICAgIGJnLmFscGhhID0gMC40O1xyXG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5hZGRDaGlsZChiZyk7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhZ2UuYWRkRXZlbnRMaXN0ZW5lcihNb3VzZUV2ZW50XzEuTW91c2VFdmVudC5NT1VTRV9NT1ZFLCB0aGlzLm9uUG9pbnRlck1vdmUpO1xyXG4gICAgICAgICAgICB0aGlzLnN0YWdlLmFkZEV2ZW50TGlzdGVuZXIoTW91c2VFdmVudF8xLk1vdXNlRXZlbnQuVE9VQ0hfTU9WRSwgdGhpcy5vblBvaW50ZXJNb3ZlKTtcclxuICAgICAgICAgICAgdGhpcy5hcHAudGlja2VyLmFkZCh0aGlzLnJ1bkV4YW1wbGUpO1xyXG4gICAgICAgICAgICB0aGlzLmV4YW1wbGVSZWFkeSgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5oYW5kbGVNYWdnb3RMb2FkZWQgPSAoZXZlbnQpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5tYWdnb3RUeHQgPSBuZXcgVGV4dHVyZV8xLlRleHR1cmUobmV3IEJhc2VUZXh0dXJlXzEuQmFzZVRleHR1cmUodGhpcy5sb2FkZXIuaW1hZ2VEYXRhKSk7XHJcbiAgICAgICAgICAgIHRoaXMubG9hZGVyID0gbmV3IFJlc291cmNlTG9hZGVyXzEuUmVzb3VyY2VMb2FkZXIobmV3IFVSTFJlcXVlc3RfMS5VUkxSZXF1ZXN0KCdleGFtcGxlcy9hc3NldHMvYmdfZ3Jhc3MuanBnJykpO1xyXG4gICAgICAgICAgICB0aGlzLmxvYWRlci5hZGRFdmVudExpc3RlbmVyKEV2ZW50XzEuRXZlbnQuQ09NUExFVEUsIHRoaXMuaGFuZGxlR3Jhc3NMb2FkZWQpO1xyXG4gICAgICAgICAgICB0aGlzLmxvYWRlci5sb2FkKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLmhhbmRsZVJpbmdMb2FkZWQgPSAoZXZlbnQpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5yaW5nVHh0ID0gbmV3IFRleHR1cmVfMS5UZXh0dXJlKG5ldyBCYXNlVGV4dHVyZV8xLkJhc2VUZXh0dXJlKHRoaXMubG9hZGVyLmltYWdlRGF0YSkpO1xyXG4gICAgICAgICAgICB0aGlzLmxvYWRlciA9IG5ldyBSZXNvdXJjZUxvYWRlcl8xLlJlc291cmNlTG9hZGVyKG5ldyBVUkxSZXF1ZXN0XzEuVVJMUmVxdWVzdCgnZXhhbXBsZXMvYXNzZXRzL21hZ2dvdC5wbmcnKSk7XHJcbiAgICAgICAgICAgIHRoaXMubG9hZGVyLmFkZEV2ZW50TGlzdGVuZXIoRXZlbnRfMS5FdmVudC5DT01QTEVURSwgdGhpcy5oYW5kbGVNYWdnb3RMb2FkZWQpO1xyXG4gICAgICAgICAgICB0aGlzLmxvYWRlci5sb2FkKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLmhhbmRsZURpc3BsYWNlbWVudExvYWRlZCA9IChldmVudCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLmRpc3BsYWNlbWVudFR4dCA9IG5ldyBUZXh0dXJlXzEuVGV4dHVyZShuZXcgQmFzZVRleHR1cmVfMS5CYXNlVGV4dHVyZSh0aGlzLmxvYWRlci5pbWFnZURhdGEpKTtcclxuICAgICAgICAgICAgdGhpcy5sb2FkZXIgPSBuZXcgUmVzb3VyY2VMb2FkZXJfMS5SZXNvdXJjZUxvYWRlcihuZXcgVVJMUmVxdWVzdF8xLlVSTFJlcXVlc3QoJ2V4YW1wbGVzL2Fzc2V0cy9waXhpLWZpbHRlcnMvcmluZy5wbmcnKSk7XHJcbiAgICAgICAgICAgIHRoaXMubG9hZGVyLmFkZEV2ZW50TGlzdGVuZXIoRXZlbnRfMS5FdmVudC5DT01QTEVURSwgdGhpcy5oYW5kbGVSaW5nTG9hZGVkKTtcclxuICAgICAgICAgICAgdGhpcy5sb2FkZXIubG9hZCgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5oYW5kbGVSb3RhdGVMb2FkZWQgPSAoZXZlbnQpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5tYWdnb3RUeHQgPSBuZXcgVGV4dHVyZV8xLlRleHR1cmUobmV3IEJhc2VUZXh0dXJlXzEuQmFzZVRleHR1cmUodGhpcy5sb2FkZXIuaW1hZ2VEYXRhKSk7XHJcbiAgICAgICAgICAgIHRoaXMubG9hZGVyID0gbmV3IFJlc291cmNlTG9hZGVyXzEuUmVzb3VyY2VMb2FkZXIobmV3IFVSTFJlcXVlc3RfMS5VUkxSZXF1ZXN0KCdleGFtcGxlcy9hc3NldHMvcGl4aS1maWx0ZXJzL2Rpc3BsYWNlLnBuZycpKTtcclxuICAgICAgICAgICAgdGhpcy5sb2FkZXIuYWRkRXZlbnRMaXN0ZW5lcihFdmVudF8xLkV2ZW50LkNPTVBMRVRFLCB0aGlzLmhhbmRsZURpc3BsYWNlbWVudExvYWRlZCk7XHJcbiAgICAgICAgICAgIHRoaXMubG9hZGVyLmxvYWQoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMub25Qb2ludGVyTW92ZSA9IChldmVudCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnJpbmcudmlzaWJsZSA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuZGlzcGxhY2VtZW50U3ByaXRlLnBvc2l0aW9uLnNldChldmVudC5kYXRhLmdsb2JhbC54IC0gMjUsIGV2ZW50LmRhdGEuZ2xvYmFsLnkpO1xyXG4gICAgICAgICAgICB0aGlzLnJpbmcucG9zaXRpb24uY29weUZyb20odGhpcy5kaXNwbGFjZW1lbnRTcHJpdGUucG9zaXRpb24pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5ydW5FeGFtcGxlID0gKGRlbHRhKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuY291bnQgKz0gMC4wNTtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm1hZ2dvdHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG1hZ2dvdCA9IHRoaXMubWFnZ290c1tpXTtcclxuICAgICAgICAgICAgICAgIG1hZ2dvdC5kaXJlY3Rpb24gKz0gbWFnZ290LnR1cm5TcGVlZCAqIDAuMDE7XHJcbiAgICAgICAgICAgICAgICBtYWdnb3QueCArPSBNYXRoLnNpbihtYWdnb3QuZGlyZWN0aW9uKSAqIG1hZ2dvdC5zcGVlZDtcclxuICAgICAgICAgICAgICAgIG1hZ2dvdC55ICs9IE1hdGguY29zKG1hZ2dvdC5kaXJlY3Rpb24pICogbWFnZ290LnNwZWVkO1xyXG4gICAgICAgICAgICAgICAgbWFnZ290LnJvdGF0aW9uID0gLW1hZ2dvdC5kaXJlY3Rpb24gLSBNYXRoLlBJIC8gMjtcclxuICAgICAgICAgICAgICAgIG1hZ2dvdC5zY2FsZS54ID0gbWFnZ290Lm9yaWdpbmFsLnggKyBNYXRoLnNpbih0aGlzLmNvdW50KSAqIDAuMjtcclxuICAgICAgICAgICAgICAgIGlmIChtYWdnb3QueCA8IHRoaXMuYm91bmRzLngpIHtcclxuICAgICAgICAgICAgICAgICAgICBtYWdnb3QueCArPSB0aGlzLmJvdW5kcy53aWR0aDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1hZ2dvdC54ID4gdGhpcy5ib3VuZHMueCArIHRoaXMuYm91bmRzLndpZHRoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWFnZ290LnggLT0gdGhpcy5ib3VuZHMud2lkdGg7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAobWFnZ290LnkgPCB0aGlzLmJvdW5kcy55KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWFnZ290LnkgKz0gdGhpcy5ib3VuZHMuaGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobWFnZ290LnkgPiB0aGlzLmJvdW5kcy55ICsgdGhpcy5ib3VuZHMuaGVpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWFnZ290LnkgLT0gdGhpcy5ib3VuZHMuaGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLmFjdGl2YXRlTWFzaygpO1xyXG4gICAgICAgIHRoaXMuY291bnQgPSAwO1xyXG4gICAgICAgIHRoaXMubWFnZ290cyA9IFtdO1xyXG4gICAgICAgIHRoaXMuc3RhZ2UuaW50ZXJhY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMubG9hZGVyID0gbmV3IFJlc291cmNlTG9hZGVyXzEuUmVzb3VyY2VMb2FkZXIobmV3IFVSTFJlcXVlc3RfMS5VUkxSZXF1ZXN0KFwiZXhhbXBsZXMvYXNzZXRzL2JnX3JvdGF0ZS5qcGdcIikpO1xyXG4gICAgICAgIHRoaXMubG9hZGVyLmFkZEV2ZW50TGlzdGVuZXIoRXZlbnRfMS5FdmVudC5DT01QTEVURSwgdGhpcy5oYW5kbGVSb3RhdGVMb2FkZWQpO1xyXG4gICAgICAgIHRoaXMubG9hZGVyLmxvYWQoKTtcclxuICAgIH1cclxuICAgIGRlc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIuZGVzdHJ1Y3RvcigpO1xyXG4gICAgICAgIHRoaXMubWFnZ290VHh0LmRlc3Ryb3kobnVsbCk7XHJcbiAgICAgICAgdGhpcy5tYWdnb3RUeHQgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuZGlzcGxhY2VtZW50VHh0LmRlc3Ryb3kobnVsbCk7XHJcbiAgICAgICAgdGhpcy5kaXNwbGFjZW1lbnRUeHQgPSBudWxsO1xyXG4gICAgICAgIHRoaXMucmluZ1R4dC5kZXN0cm95KG51bGwpO1xyXG4gICAgICAgIHRoaXMucmluZ1R4dCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5ncmFzc1R4dC5kZXN0cm95KG51bGwpO1xyXG4gICAgICAgIHRoaXMuZ3Jhc3NUeHQgPSBudWxsO1xyXG4gICAgICAgIHRoaXMubWFnZ290cyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5yaW5nLmRlc3Ryb3kobnVsbCk7XHJcbiAgICAgICAgdGhpcy5yaW5nID0gbnVsbDtcclxuICAgICAgICB0aGlzLmFwcC50aWNrZXIucmVtb3ZlKHRoaXMucnVuRXhhbXBsZSwgbnVsbCk7XHJcbiAgICAgICAgdGhpcy5kaXNwbGFjZW1lbnRTcHJpdGUuZGVzdHJveShudWxsKTtcclxuICAgICAgICB0aGlzLmRpc3BsYWNlbWVudFNwcml0ZSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5jb250YWluZXIuZGVzdHJveShudWxsKTtcclxuICAgICAgICB0aGlzLmNvbnRhaW5lciA9IG51bGw7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5GaWx0ZXJDcmF3bGllcyA9IEZpbHRlckNyYXdsaWVzO1xyXG5jbGFzcyBFeHRlbmRlZFNwcml0ZSBleHRlbmRzIFNwcml0ZV8xLlNwcml0ZSB7XHJcbn1cclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgQmFzZUV4YW1wbGVfMSA9IHJlcXVpcmUoXCIuL0Jhc2VFeGFtcGxlXCIpO1xyXG5jb25zdCBSZXNvdXJjZUxvYWRlcl8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1Jlc291cmNlTG9hZGVyXCIpO1xyXG5jb25zdCBUZXh0dXJlXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvVGV4dHVyZVwiKTtcclxuY29uc3QgVVJMUmVxdWVzdF8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1VSTFJlcXVlc3RcIik7XHJcbmNvbnN0IEV2ZW50XzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvRXZlbnRcIik7XHJcbmNvbnN0IEJhc2VUZXh0dXJlXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvQmFzZVRleHR1cmVcIik7XHJcbmNvbnN0IFNwcml0ZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1Nwcml0ZVwiKTtcclxuY29uc3QgVVJMTG9hZGVyXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvVVJMTG9hZGVyXCIpO1xyXG5jb25zdCBGaWx0ZXJfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9GaWx0ZXJcIik7XHJcbmNvbnN0IExvZ2dlcl8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0xvZ2dlclwiKTtcclxuY2xhc3MgRmlsdGVyQ3VzdG9tIGV4dGVuZHMgQmFzZUV4YW1wbGVfMS5CYXNlRXhhbXBsZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihhcHAsIHdpZHRoLCBoZWlnaHQpIHtcclxuICAgICAgICBzdXBlcihhcHAsIHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgICAgIHRoaXMuaGFuZGxlR3Jhc3NMb2FkZWQgPSAoZXZlbnQpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5ncmFzc3R4dCA9IG5ldyBUZXh0dXJlXzEuVGV4dHVyZShuZXcgQmFzZVRleHR1cmVfMS5CYXNlVGV4dHVyZSh0aGlzLmxvYWRlci5pbWFnZURhdGEpKTtcclxuICAgICAgICAgICAgdGhpcy5iYWNrZ3JvdW5kID0gbmV3IFNwcml0ZV8xLlNwcml0ZSh0aGlzLmdyYXNzdHh0KTtcclxuICAgICAgICAgICAgdGhpcy5iYWNrZ3JvdW5kLndpZHRoID0gdGhpcy5hcHAuc2NyZWVuLndpZHRoO1xyXG4gICAgICAgICAgICB0aGlzLmJhY2tncm91bmQuaGVpZ2h0ID0gdGhpcy5hcHAuc2NyZWVuLmhlaWdodDtcclxuICAgICAgICAgICAgdGhpcy5hcHAuc3RhZ2UuYWRkQ2hpbGQodGhpcy5iYWNrZ3JvdW5kKTtcclxuICAgICAgICAgICAgdGhpcy51cmxsb2FkZXIgPSBuZXcgVVJMTG9hZGVyXzEuVVJMTG9hZGVyKCk7XHJcbiAgICAgICAgICAgIHRoaXMudXJsbG9hZGVyLmFkZEV2ZW50TGlzdGVuZXIoRXZlbnRfMS5FdmVudC5DT01QTEVURSwgdGhpcy5oYW5kbGVGcmFnTG9hZGVkKTtcclxuICAgICAgICAgICAgdGhpcy51cmxsb2FkZXIubG9hZChuZXcgVVJMUmVxdWVzdF8xLlVSTFJlcXVlc3QoXCJleGFtcGxlcy9hc3NldHMvcGl4aS1maWx0ZXJzL3NoYWRlci5mcmFnXCIpKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuaGFuZGxlRnJhZ0xvYWRlZCA9IChldmVudCkgPT4ge1xyXG4gICAgICAgICAgICBsZXQgZnJhZ2RhdGEgPSB0aGlzLnVybGxvYWRlci5kYXRhO1xyXG4gICAgICAgICAgICBMb2dnZXJfMS50cmFjZShmcmFnZGF0YSk7XHJcbiAgICAgICAgICAgIHRoaXMuZmlsdGVyID0gbmV3IEZpbHRlcl8xLkZpbHRlcihudWxsLCBmcmFnZGF0YSwge1xyXG4gICAgICAgICAgICAgICAgY3VzdG9tVW5pZm9ybTogMC4wXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB0aGlzLmJhY2tncm91bmQuZmlsdGVycyA9IFt0aGlzLmZpbHRlcl07XHJcbiAgICAgICAgICAgIHRoaXMuYXBwLnRpY2tlci5hZGQodGhpcy5ydW5FeGFtcGxlKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMucnVuRXhhbXBsZSA9IChkZWx0YSkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLmZpbHRlci51bmlmb3Jtcy5jdXN0b21Vbmlmb3JtICs9IDAuMDQgKiBkZWx0YTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMubG9hZGVyID0gbmV3IFJlc291cmNlTG9hZGVyXzEuUmVzb3VyY2VMb2FkZXIobmV3IFVSTFJlcXVlc3RfMS5VUkxSZXF1ZXN0KFwiZXhhbXBsZXMvYXNzZXRzL2JnX2dyYXNzLmpwZ1wiKSk7XHJcbiAgICAgICAgdGhpcy5sb2FkZXIuYWRkRXZlbnRMaXN0ZW5lcihFdmVudF8xLkV2ZW50LkNPTVBMRVRFLCB0aGlzLmhhbmRsZUdyYXNzTG9hZGVkKTtcclxuICAgICAgICB0aGlzLmxvYWRlci5sb2FkKCk7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5GaWx0ZXJDdXN0b20gPSBGaWx0ZXJDdXN0b207XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IEJhc2VFeGFtcGxlXzEgPSByZXF1aXJlKFwiLi9CYXNlRXhhbXBsZVwiKTtcclxuY29uc3QgQ29udGFpbmVyXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvQ29udGFpbmVyXCIpO1xyXG5jb25zdCBSZXNvdXJjZUxvYWRlcl8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1Jlc291cmNlTG9hZGVyXCIpO1xyXG5jb25zdCBUZXh0dXJlXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvVGV4dHVyZVwiKTtcclxuY29uc3QgVVJMUmVxdWVzdF8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1VSTFJlcXVlc3RcIik7XHJcbmNvbnN0IEV2ZW50XzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvRXZlbnRcIik7XHJcbmNvbnN0IEJhc2VUZXh0dXJlXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvQmFzZVRleHR1cmVcIik7XHJcbmNvbnN0IFNwcml0ZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1Nwcml0ZVwiKTtcclxuY29uc3QgV2ViR0xTZXR0aW5nc18xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1dlYkdMU2V0dGluZ3NcIik7XHJcbmNvbnN0IERpc3BsYWNlbWVudEZpbHRlcl8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0Rpc3BsYWNlbWVudEZpbHRlclwiKTtcclxuY2xhc3MgRmlsdGVyRmxhZyBleHRlbmRzIEJhc2VFeGFtcGxlXzEuQmFzZUV4YW1wbGUge1xyXG4gICAgY29uc3RydWN0b3IoYXBwLCB3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICAgICAgc3VwZXIoYXBwLCB3aWR0aCwgaGVpZ2h0KTtcclxuICAgICAgICB0aGlzLmhhbmRsZURpc3BsYWNlbWVudExvYWRlZCA9IChldmVudCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnJlcGVhdFR4dCA9IG5ldyBUZXh0dXJlXzEuVGV4dHVyZShuZXcgQmFzZVRleHR1cmVfMS5CYXNlVGV4dHVyZSh0aGlzLmxvYWRlci5pbWFnZURhdGEpKTtcclxuICAgICAgICAgICAgY29uc3QgY29udGFpbmVyID0gbmV3IENvbnRhaW5lcl8xLkNvbnRhaW5lcigpO1xyXG4gICAgICAgICAgICB0aGlzLnN0YWdlLmFkZENoaWxkKGNvbnRhaW5lcik7XHJcbiAgICAgICAgICAgIGNvbnN0IGZsYWcgPSBuZXcgU3ByaXRlXzEuU3ByaXRlKHRoaXMuZmxhZ1R4dCk7XHJcbiAgICAgICAgICAgIGNvbnRhaW5lci5hZGRDaGlsZChmbGFnKTtcclxuICAgICAgICAgICAgZmxhZy54ID0gMTAwO1xyXG4gICAgICAgICAgICBmbGFnLnkgPSAxMDA7XHJcbiAgICAgICAgICAgIHRoaXMuZGlzcGxhY2VtZW50U3ByaXRlID0gbmV3IFNwcml0ZV8xLlNwcml0ZSh0aGlzLnJlcGVhdFR4dCk7XHJcbiAgICAgICAgICAgIHRoaXMuZGlzcGxhY2VtZW50U3ByaXRlLnRleHR1cmUuYmFzZVRleHR1cmUud3JhcE1vZGUgPSBXZWJHTFNldHRpbmdzXzEuV2ViR0xTZXR0aW5ncy5XUkFQX01PREVTLlJFUEVBVDtcclxuICAgICAgICAgICAgY29uc3QgZGlzcGxhY2VtZW50RmlsdGVyID0gbmV3IERpc3BsYWNlbWVudEZpbHRlcl8xLkRpc3BsYWNlbWVudEZpbHRlcih0aGlzLmRpc3BsYWNlbWVudFNwcml0ZSk7XHJcbiAgICAgICAgICAgIGRpc3BsYWNlbWVudEZpbHRlci5wYWRkaW5nID0gMTA7XHJcbiAgICAgICAgICAgIHRoaXMuZGlzcGxhY2VtZW50U3ByaXRlLnBvc2l0aW9uID0gZmxhZy5wb3NpdGlvbjtcclxuICAgICAgICAgICAgdGhpcy5zdGFnZS5hZGRDaGlsZCh0aGlzLmRpc3BsYWNlbWVudFNwcml0ZSk7XHJcbiAgICAgICAgICAgIGZsYWcuZmlsdGVycyA9IFtkaXNwbGFjZW1lbnRGaWx0ZXJdO1xyXG4gICAgICAgICAgICBkaXNwbGFjZW1lbnRGaWx0ZXIuc2NhbGUueCA9IDMwO1xyXG4gICAgICAgICAgICBkaXNwbGFjZW1lbnRGaWx0ZXIuc2NhbGUueSA9IDYwO1xyXG4gICAgICAgICAgICB0aGlzLmFwcC50aWNrZXIuYWRkKHRoaXMucnVuRXhhbXBsZSk7XHJcbiAgICAgICAgICAgIHRoaXMuZXhhbXBsZVJlYWR5KCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLnJ1bkV4YW1wbGUgPSAoZGVsdGEpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5kaXNwbGFjZW1lbnRTcHJpdGUueCsrO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5kaXNwbGFjZW1lbnRTcHJpdGUueCA+IHRoaXMuZGlzcGxhY2VtZW50U3ByaXRlLndpZHRoKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BsYWNlbWVudFNwcml0ZS54ID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5oYW5kbGVSb3RhdGVMb2FkZWQgPSAoZXZlbnQpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5mbGFnVHh0ID0gbmV3IFRleHR1cmVfMS5UZXh0dXJlKG5ldyBCYXNlVGV4dHVyZV8xLkJhc2VUZXh0dXJlKHRoaXMubG9hZGVyLmltYWdlRGF0YSkpO1xyXG4gICAgICAgICAgICB0aGlzLmxvYWRlciA9IG5ldyBSZXNvdXJjZUxvYWRlcl8xLlJlc291cmNlTG9hZGVyKG5ldyBVUkxSZXF1ZXN0XzEuVVJMUmVxdWVzdCgnZXhhbXBsZXMvYXNzZXRzL3BpeGktZmlsdGVycy9kaXNwbGFjZW1lbnRfbWFwX3JlcGVhdC5qcGcnKSk7XHJcbiAgICAgICAgICAgIHRoaXMubG9hZGVyLmFkZEV2ZW50TGlzdGVuZXIoRXZlbnRfMS5FdmVudC5DT01QTEVURSwgdGhpcy5oYW5kbGVEaXNwbGFjZW1lbnRMb2FkZWQpO1xyXG4gICAgICAgICAgICB0aGlzLmxvYWRlci5sb2FkKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLnN0YWdlLmludGVyYWN0aXZlID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmxvYWRlciA9IG5ldyBSZXNvdXJjZUxvYWRlcl8xLlJlc291cmNlTG9hZGVyKG5ldyBVUkxSZXF1ZXN0XzEuVVJMUmVxdWVzdChcImV4YW1wbGVzL2Fzc2V0cy9waXhpLWZpbHRlcnMvZmxhZy5wbmdcIikpO1xyXG4gICAgICAgIHRoaXMubG9hZGVyLmFkZEV2ZW50TGlzdGVuZXIoRXZlbnRfMS5FdmVudC5DT01QTEVURSwgdGhpcy5oYW5kbGVSb3RhdGVMb2FkZWQpO1xyXG4gICAgICAgIHRoaXMubG9hZGVyLmxvYWQoKTtcclxuICAgIH1cclxuICAgIGRlc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIuZGVzdHJ1Y3RvcigpO1xyXG4gICAgICAgIHRoaXMuZmxhZ1R4dC5kZXN0cm95KG51bGwpO1xyXG4gICAgICAgIHRoaXMuZmxhZ1R4dCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5yZXBlYXRUeHQuZGVzdHJveShudWxsKTtcclxuICAgICAgICB0aGlzLnJlcGVhdFR4dCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5kaXNwbGFjZW1lbnRTcHJpdGUuZGVzdHJveShudWxsKTtcclxuICAgICAgICB0aGlzLmRpc3BsYWNlbWVudFNwcml0ZSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5hcHAudGlja2VyLnJlbW92ZSh0aGlzLnJ1bkV4YW1wbGUsIG51bGwpO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuRmlsdGVyRmxhZyA9IEZpbHRlckZsYWc7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IEJhc2VFeGFtcGxlXzEgPSByZXF1aXJlKFwiLi9CYXNlRXhhbXBsZVwiKTtcclxuY29uc3QgVVJMTG9hZGVyXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvVVJMTG9hZGVyXCIpO1xyXG5jb25zdCBFdmVudF8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0V2ZW50XCIpO1xyXG5jb25zdCBVUkxSZXF1ZXN0XzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvVVJMUmVxdWVzdFwiKTtcclxuY29uc3QgUmVzb3VyY2VMb2FkZXJfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9SZXNvdXJjZUxvYWRlclwiKTtcclxuY29uc3QgVGV4dHVyZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1RleHR1cmVcIik7XHJcbmNvbnN0IEJhc2VUZXh0dXJlXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvQmFzZVRleHR1cmVcIik7XHJcbmNvbnN0IFNwcml0ZXNoZWV0XzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvU3ByaXRlc2hlZXRcIik7XHJcbmNvbnN0IEFuaW1hdGVkU3ByaXRlXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvQW5pbWF0ZWRTcHJpdGVcIik7XHJcbmNvbnN0IEZpbHRlcl8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0ZpbHRlclwiKTtcclxuY2xhc3MgRmlsdGVyU2hhZG93IGV4dGVuZHMgQmFzZUV4YW1wbGVfMS5CYXNlRXhhbXBsZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihhcHAsIHdpZHRoLCBoZWlnaHQpIHtcclxuICAgICAgICBzdXBlcihhcHAsIHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgICAgIHRoaXMub25BbmltYXRpb25QYXJzZWQgPSAodGV4dHVyZXMpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5hcHAuc3RhZ2UuaW50ZXJhY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgICAgICBjb25zdCBmcmFtZXMgPSBbXTtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAzMDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB2YWwgPSBpIDwgMTAgPyBgMCR7aX1gIDogaTtcclxuICAgICAgICAgICAgICAgIGZyYW1lcy5wdXNoKHRleHR1cmVzW2Byb2xsU2VxdWVuY2UwMCR7dmFsfS5wbmdgXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5hbmltID0gbmV3IEFuaW1hdGVkU3ByaXRlXzEuQW5pbWF0ZWRTcHJpdGUoZnJhbWVzKTtcclxuICAgICAgICAgICAgdGhpcy5hbmltLnggPSB0aGlzLmFwcC5zY3JlZW4ud2lkdGggLyAyO1xyXG4gICAgICAgICAgICB0aGlzLmFuaW0ueSA9IHRoaXMuYXBwLnNjcmVlbi5oZWlnaHQgLyAyO1xyXG4gICAgICAgICAgICB0aGlzLmFuaW0uYW5jaG9yLnNldCgwLjUpO1xyXG4gICAgICAgICAgICB0aGlzLmFuaW0uYW5pbWF0aW9uU3BlZWQgPSAwLjU7XHJcbiAgICAgICAgICAgIHRoaXMuYW5pbS5wbGF5KCk7XHJcbiAgICAgICAgICAgIHRoaXMuYXBwLnN0YWdlLmFkZENoaWxkKHRoaXMuYW5pbSk7XHJcbiAgICAgICAgICAgIHRoaXMuZmlsdGVyID0gbmV3IEZpbHRlcl8xLkZpbHRlcihGaWx0ZXJTaGFkb3cubXlWZXJ0ZXgsIEZpbHRlclNoYWRvdy5teUZyYWdtZW50KTtcclxuICAgICAgICAgICAgdGhpcy5maWx0ZXIudW5pZm9ybXMuc2hhZG93RGlyZWN0aW9uID0gWzAuMSwgMC41XTtcclxuICAgICAgICAgICAgdGhpcy5maWx0ZXIudW5pZm9ybXMuZmxvb3JZID0gdGhpcy5hbmltLmhlaWdodCAqIDI7XHJcbiAgICAgICAgICAgIHRoaXMuZmlsdGVyLnBhZGRpbmcgPSAyMDA7XHJcbiAgICAgICAgICAgIHRoaXMuYW5pbS5maWx0ZXJzID0gW3RoaXMuZmlsdGVyXTtcclxuICAgICAgICAgICAgdGhpcy5hcHAudGlja2VyLmFkZCh0aGlzLnJ1bkV4YW1wbGUpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5ydW5FeGFtcGxlID0gKGRlbHRhKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuZmlsdGVyLnVuaWZvcm1zLmZsb29yWSA9IHRoaXMuYXBwLnJlbmRlcmVyLnBsdWdpbnMuaW50ZXJhY3Rpb24ubW91c2UuZ2xvYmFsLnk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLmhhbmRsZUpzb25Mb2FkZWQgPSAoZXZlbnQpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5qc29uZGF0YSA9IEpTT04ucGFyc2UodGhpcy51cmxsb2FkZXIuZGF0YSk7XHJcbiAgICAgICAgICAgIHRoaXMubG9hZGVyID0gbmV3IFJlc291cmNlTG9hZGVyXzEuUmVzb3VyY2VMb2FkZXIobmV3IFVSTFJlcXVlc3RfMS5VUkxSZXF1ZXN0KFwiZXhhbXBsZXMvYXNzZXRzL3Nwcml0ZXNoZWV0L2ZpZ2h0ZXIucG5nXCIpKTtcclxuICAgICAgICAgICAgdGhpcy5sb2FkZXIuYWRkRXZlbnRMaXN0ZW5lcihFdmVudF8xLkV2ZW50LkNPTVBMRVRFLCB0aGlzLmhhbmRsZVJvdGF0ZUxvYWRlZCk7XHJcbiAgICAgICAgICAgIHRoaXMubG9hZGVyLmxvYWQoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuaGFuZGxlUm90YXRlTG9hZGVkID0gKGV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMudHh0ID0gbmV3IFRleHR1cmVfMS5UZXh0dXJlKG5ldyBCYXNlVGV4dHVyZV8xLkJhc2VUZXh0dXJlKHRoaXMubG9hZGVyLmltYWdlRGF0YSkpO1xyXG4gICAgICAgICAgICBsZXQgc3ByaXRlc2hlZXQgPSBuZXcgU3ByaXRlc2hlZXRfMS5TcHJpdGVzaGVldCh0aGlzLnR4dCwgdGhpcy5qc29uZGF0YSk7XHJcbiAgICAgICAgICAgIHNwcml0ZXNoZWV0LnBhcnNlKHRoaXMub25BbmltYXRpb25QYXJzZWQpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy51cmxsb2FkZXIgPSBuZXcgVVJMTG9hZGVyXzEuVVJMTG9hZGVyKCk7XHJcbiAgICAgICAgdGhpcy51cmxsb2FkZXIuYWRkRXZlbnRMaXN0ZW5lcihFdmVudF8xLkV2ZW50LkNPTVBMRVRFLCB0aGlzLmhhbmRsZUpzb25Mb2FkZWQpO1xyXG4gICAgICAgIHRoaXMudXJsbG9hZGVyLmxvYWQobmV3IFVSTFJlcXVlc3RfMS5VUkxSZXF1ZXN0KFwiZXhhbXBsZXMvYXNzZXRzL3Nwcml0ZXNoZWV0L2ZpZ2h0ZXIuanNvblwiKSk7XHJcbiAgICB9XHJcbn1cclxuRmlsdGVyU2hhZG93Lm15VmVydGV4ID0gYFxyXG4gICAgICAgIGF0dHJpYnV0ZSB2ZWMyIGFWZXJ0ZXhQb3NpdGlvbjtcclxuICAgICAgICBhdHRyaWJ1dGUgdmVjMiBhVGV4dHVyZUNvb3JkO1xyXG4gICAgICAgIHVuaWZvcm0gbWF0MyBwcm9qZWN0aW9uTWF0cml4O1xyXG4gICAgICAgIHZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xyXG4gICAgICAgIHZvaWQgbWFpbih2b2lkKSB7XHJcbiAgICAgICAgICAgIGdsX1Bvc2l0aW9uID0gdmVjNCgocHJvamVjdGlvbk1hdHJpeCAqIHZlYzMoYVZlcnRleFBvc2l0aW9uLCAxLjApKS54eSwgMC4wLCAxLjApO1xyXG4gICAgICAgICAgICB2VGV4dHVyZUNvb3JkID0gYVRleHR1cmVDb29yZDtcclxuICAgICAgICB9XHJcbiAgICBgO1xyXG5GaWx0ZXJTaGFkb3cubXlGcmFnbWVudCA9IGBcclxuICAgICAgICB2YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcclxuICAgICAgICB1bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjtcclxuICAgICAgICB1bmlmb3JtIHZlYzQgaW5wdXRTaXplO1xyXG4gICAgICAgIHVuaWZvcm0gdmVjNCBvdXRwdXRGcmFtZTtcclxuICAgICAgICB1bmlmb3JtIHZlYzIgc2hhZG93RGlyZWN0aW9uO1xyXG4gICAgICAgIHVuaWZvcm0gZmxvYXQgZmxvb3JZO1xyXG4gICAgICAgIHZvaWQgbWFpbih2b2lkKSB7XHJcbiAgICAgICAgICAgIC8vMS4gZ2V0IHRoZSBzY3JlZW4gY29vcmRpbmF0ZVxyXG4gICAgICAgICAgICB2ZWMyIHNjcmVlbkNvb3JkID0gdlRleHR1cmVDb29yZCAqIGlucHV0U2l6ZS54eSArIG91dHB1dEZyYW1lLnh5O1xyXG4gICAgICAgICAgICAvLzIuIGNhbGN1bGF0ZSBZIHNoaWZ0IG9mIG91ciBkaW1lbnNpb24gdmVjdG9yXHJcbiAgICAgICAgICAgIHZlYzIgc2hhZG93O1xyXG4gICAgICAgICAgICAvL3NoYWRvdyBjb29yZGluYXRlIHN5c3RlbSBpcyBhIGJpdCBza2V3ZWQsIGJ1dCBpdCBoYXMgdG8gYmUgdGhlIHNhbWUgZm9yIHNjcmVlbkNvb3JkLnkgPSBmbG9vcllcclxuICAgICAgICAgICAgZmxvYXQgcGFyYW1ZID0gKHNjcmVlbkNvb3JkLnkgLSBmbG9vclkpIC8gc2hhZG93RGlyZWN0aW9uLnk7XHJcbiAgICAgICAgICAgIHNoYWRvdy55ID0gcGFyYW1ZICsgZmxvb3JZO1xyXG4gICAgICAgICAgICBzaGFkb3cueCA9IHNjcmVlbkNvb3JkLnggKyBwYXJhbVkgKiBzaGFkb3dEaXJlY3Rpb24ueDtcclxuICAgICAgICAgICAgdmVjMiBib2R5RmlsdGVyQ29vcmQgPSAoc2hhZG93IC0gb3V0cHV0RnJhbWUueHkpICogaW5wdXRTaXplLnp3OyAvLyBzYW1lIGFzIC8gaW5wdXRTaXplLnh5XHJcbiAgICAgICAgICAgIHZlYzQgb3JpZ2luYWxDb2xvciA9IHRleHR1cmUyRCh1U2FtcGxlciwgdlRleHR1cmVDb29yZCk7XHJcbiAgICAgICAgICAgIHZlYzQgc2hhZG93Q29sb3IgPSB0ZXh0dXJlMkQodVNhbXBsZXIsIGJvZHlGaWx0ZXJDb29yZCk7XHJcbiAgICAgICAgICAgIHNoYWRvd0NvbG9yLnJnYiA9IHZlYzMoMC4wKTtcclxuICAgICAgICAgICAgc2hhZG93Q29sb3IuYSAqPSAwLjU7XHJcbiAgICAgICAgICAgIC8vIG5vcm1hbCBibGVuZCBtb2RlIGNvZWZmaWNpZW50cyAoMSwgMS1zcmNfYWxwaGEpXHJcbiAgICAgICAgICAgIC8vIHNoYWRvdyBpcyBkZXN0aW5hdGlvbiAoYmFja2Ryb3ApLCBvcmlnaW5hbCBpcyBzb3VyY2VcclxuICAgICAgICAgICAgZ2xfRnJhZ0NvbG9yID0gb3JpZ2luYWxDb2xvciArIHNoYWRvd0NvbG9yICogKDEuMCAtIG9yaWdpbmFsQ29sb3IuYSk7XHJcbiAgICAgICAgfVxyXG4gICAgYDtcclxuZXhwb3J0cy5GaWx0ZXJTaGFkb3cgPSBGaWx0ZXJTaGFkb3c7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IEJhc2VFeGFtcGxlXzEgPSByZXF1aXJlKFwiLi9CYXNlRXhhbXBsZVwiKTtcclxuY29uc3QgUmVzb3VyY2VMb2FkZXJfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9SZXNvdXJjZUxvYWRlclwiKTtcclxuY29uc3QgVGV4dHVyZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1RleHR1cmVcIik7XHJcbmNvbnN0IFVSTFJlcXVlc3RfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9VUkxSZXF1ZXN0XCIpO1xyXG5jb25zdCBFdmVudF8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0V2ZW50XCIpO1xyXG5jb25zdCBCYXNlVGV4dHVyZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0Jhc2VUZXh0dXJlXCIpO1xyXG5jb25zdCBHcmFwaGljc18xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0dyYXBoaWNzXCIpO1xyXG5jb25zdCBCbHVyRmlsdGVyXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvQmx1ckZpbHRlclwiKTtcclxuY29uc3QgUmVjdGFuZ2xlXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvUmVjdGFuZ2xlXCIpO1xyXG5jb25zdCBXZWJHTFNldHRpbmdzXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvV2ViR0xTZXR0aW5nc1wiKTtcclxuY29uc3QgU3ByaXRlXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvU3ByaXRlXCIpO1xyXG5jb25zdCBNb3VzZUV2ZW50XzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvTW91c2VFdmVudFwiKTtcclxuY2xhc3MgTWFza0ZpbHRlciBleHRlbmRzIEJhc2VFeGFtcGxlXzEuQmFzZUV4YW1wbGUge1xyXG4gICAgY29uc3RydWN0b3IoYXBwLCB3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICAgICAgc3VwZXIoYXBwLCB3aWR0aCwgaGVpZ2h0KTtcclxuICAgICAgICB0aGlzLmhhbmRsZVJvdGF0ZUxvYWRlZCA9IChldmVudCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLmZsYWdUeHQgPSBuZXcgVGV4dHVyZV8xLlRleHR1cmUobmV3IEJhc2VUZXh0dXJlXzEuQmFzZVRleHR1cmUodGhpcy5sb2FkZXIuaW1hZ2VEYXRhKSk7XHJcbiAgICAgICAgICAgIGNvbnN0IHJhZGl1cyA9IDEwMDtcclxuICAgICAgICAgICAgY29uc3QgYmx1clNpemUgPSAzMjtcclxuICAgICAgICAgICAgY29uc3QgYmFja2dyb3VuZCA9IG5ldyBTcHJpdGVfMS5TcHJpdGUodGhpcy5mbGFnVHh0KTtcclxuICAgICAgICAgICAgdGhpcy5zdGFnZS5hZGRDaGlsZChiYWNrZ3JvdW5kKTtcclxuICAgICAgICAgICAgYmFja2dyb3VuZC53aWR0aCA9IHRoaXMuc2l6ZXc7XHJcbiAgICAgICAgICAgIGJhY2tncm91bmQuaGVpZ2h0ID0gdGhpcy5zaXplaDtcclxuICAgICAgICAgICAgY29uc3QgY2lyY2xlID0gbmV3IEdyYXBoaWNzXzEuR3JhcGhpY3MoKVxyXG4gICAgICAgICAgICAgICAgLmJlZ2luRmlsbCgweEZGMDAwMClcclxuICAgICAgICAgICAgICAgIC5kcmF3Q2lyY2xlKHJhZGl1cyArIGJsdXJTaXplLCByYWRpdXMgKyBibHVyU2l6ZSwgcmFkaXVzKVxyXG4gICAgICAgICAgICAgICAgLmVuZEZpbGwoKTtcclxuICAgICAgICAgICAgY2lyY2xlLmZpbHRlcnMgPSBbbmV3IEJsdXJGaWx0ZXJfMS5CbHVyRmlsdGVyKGJsdXJTaXplKV07XHJcbiAgICAgICAgICAgIGNvbnN0IGJvdW5kcyA9IG5ldyBSZWN0YW5nbGVfMS5SZWN0YW5nbGUoMCwgMCwgKHJhZGl1cyArIGJsdXJTaXplKSAqIDIsIChyYWRpdXMgKyBibHVyU2l6ZSkgKiAyKTtcclxuICAgICAgICAgICAgY29uc3QgdGV4dHVyZSA9IHRoaXMuYXBwLnJlbmRlcmVyLmdlbmVyYXRlVGV4dHVyZShjaXJjbGUsIFdlYkdMU2V0dGluZ3NfMS5XZWJHTFNldHRpbmdzLlNDQUxFX01PREVTLk5FQVJFU1QsIDEsIGJvdW5kcyk7XHJcbiAgICAgICAgICAgIHRoaXMuZm9jdXMgPSBuZXcgU3ByaXRlXzEuU3ByaXRlKHRleHR1cmUpO1xyXG4gICAgICAgICAgICB0aGlzLnN0YWdlLmFkZENoaWxkKHRoaXMuZm9jdXMpO1xyXG4gICAgICAgICAgICBiYWNrZ3JvdW5kLm1hc2sgPSB0aGlzLmZvY3VzO1xyXG4gICAgICAgICAgICB0aGlzLnN0YWdlLmludGVyYWN0aXZlID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5zdGFnZS5hZGRFdmVudExpc3RlbmVyKE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50Lk1PVVNFX01PVkUsIHRoaXMucG9pbnRlck1vdmUpO1xyXG4gICAgICAgICAgICB0aGlzLmV4YW1wbGVSZWFkeSgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5wb2ludGVyTW92ZSA9IChldmVudCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLmZvY3VzLnBvc2l0aW9uLnggPSBldmVudC5kYXRhLmdsb2JhbC54IC0gdGhpcy5mb2N1cy53aWR0aCAvIDI7XHJcbiAgICAgICAgICAgIHRoaXMuZm9jdXMucG9zaXRpb24ueSA9IGV2ZW50LmRhdGEuZ2xvYmFsLnkgLSB0aGlzLmZvY3VzLmhlaWdodCAvIDI7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLmJhY2tDb2xvciA9IDA7XHJcbiAgICAgICAgdGhpcy5sb2FkZXIgPSBuZXcgUmVzb3VyY2VMb2FkZXJfMS5SZXNvdXJjZUxvYWRlcihuZXcgVVJMUmVxdWVzdF8xLlVSTFJlcXVlc3QoXCJleGFtcGxlcy9hc3NldHMvYmdfZ3Jhc3MuanBnXCIpKTtcclxuICAgICAgICB0aGlzLmxvYWRlci5hZGRFdmVudExpc3RlbmVyKEV2ZW50XzEuRXZlbnQuQ09NUExFVEUsIHRoaXMuaGFuZGxlUm90YXRlTG9hZGVkKTtcclxuICAgICAgICB0aGlzLmxvYWRlci5sb2FkKCk7XHJcbiAgICB9XHJcbiAgICBkZXN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyLmRlc3RydWN0b3IoKTtcclxuICAgICAgICB0aGlzLmZsYWdUeHQuZGVzdHJveShudWxsKTtcclxuICAgICAgICB0aGlzLmZsYWdUeHQgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuZm9jdXMuZGVzdHJveShudWxsKTtcclxuICAgICAgICB0aGlzLmZvY3VzID0gbnVsbDtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLk1hc2tGaWx0ZXIgPSBNYXNrRmlsdGVyO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBCYXNlRXhhbXBsZV8xID0gcmVxdWlyZShcIi4vQmFzZUV4YW1wbGVcIik7XHJcbmNvbnN0IFRleHR1cmVfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9UZXh0dXJlXCIpO1xyXG5jb25zdCBCYXNlVGV4dHVyZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0Jhc2VUZXh0dXJlXCIpO1xyXG5jb25zdCBFdmVudF8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0V2ZW50XCIpO1xyXG5jb25zdCBSZXNvdXJjZUxvYWRlcl8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1Jlc291cmNlTG9hZGVyXCIpO1xyXG5jb25zdCBVUkxSZXF1ZXN0XzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvVVJMUmVxdWVzdFwiKTtcclxuY29uc3QgUG9pbnRfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9Qb2ludFwiKTtcclxuY29uc3QgU2ltcGxlUm9wZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1NpbXBsZVJvcGVcIik7XHJcbmNvbnN0IEdyYXBoaWNzXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvR3JhcGhpY3NcIik7XHJcbmNsYXNzIE1lc2hBZHZhbmNlZCBleHRlbmRzIEJhc2VFeGFtcGxlXzEuQmFzZUV4YW1wbGUge1xyXG4gICAgY29uc3RydWN0b3IoYXBwLCB3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICAgICAgc3VwZXIoYXBwLCB3aWR0aCwgaGVpZ2h0KTtcclxuICAgICAgICB0aGlzLnJ1bkV4YW1wbGUgPSAoZGVsdGEpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5jb3VudCArPSAwLjE7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5wb2ludHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucG9pbnRzW2ldLnkgPSBNYXRoLnNpbigoaSAqIDAuNSkgKyB0aGlzLmNvdW50KSAqIDMwO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wb2ludHNbaV0ueCA9IGkgKiB0aGlzLnJvcGVMZW5ndGggKyBNYXRoLmNvcygoaSAqIDAuMykgKyB0aGlzLmNvdW50KSAqIDIwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVyUG9pbnRzKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLmhhbmRsZVBsYW5lTG9hZGVkID0gKGV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMucGxhbmVUeHQgPSBuZXcgVGV4dHVyZV8xLlRleHR1cmUobmV3IEJhc2VUZXh0dXJlXzEuQmFzZVRleHR1cmUodGhpcy5sb2FkZXIuaW1hZ2VEYXRhKSk7XHJcbiAgICAgICAgICAgIHRoaXMuY291bnQgPSAwO1xyXG4gICAgICAgICAgICB0aGlzLnJvcGVMZW5ndGggPSA0NTtcclxuICAgICAgICAgICAgdGhpcy5wb2ludHMgPSBbXTtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAyNTsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBvaW50cy5wdXNoKG5ldyBQb2ludF8xLlBvaW50KGkgKiB0aGlzLnJvcGVMZW5ndGgsIDApKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBzdHJpcCA9IG5ldyBTaW1wbGVSb3BlXzEuU2ltcGxlUm9wZSh0aGlzLnBsYW5lVHh0LCB0aGlzLnBvaW50cyk7XHJcbiAgICAgICAgICAgIHN0cmlwLnggPSAtNDA7XHJcbiAgICAgICAgICAgIHN0cmlwLnkgPSAzMDA7XHJcbiAgICAgICAgICAgIHRoaXMuYXBwLnN0YWdlLmFkZENoaWxkKHN0cmlwKTtcclxuICAgICAgICAgICAgdGhpcy5nID0gbmV3IEdyYXBoaWNzXzEuR3JhcGhpY3MoKTtcclxuICAgICAgICAgICAgdGhpcy5nLnggPSBzdHJpcC54O1xyXG4gICAgICAgICAgICB0aGlzLmcueSA9IHN0cmlwLnk7XHJcbiAgICAgICAgICAgIHRoaXMuYXBwLnN0YWdlLmFkZENoaWxkKHRoaXMuZyk7XHJcbiAgICAgICAgICAgIHRoaXMuYXBwLnRpY2tlci5hZGQodGhpcy5ydW5FeGFtcGxlKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMubG9hZGVyID0gbmV3IFJlc291cmNlTG9hZGVyXzEuUmVzb3VyY2VMb2FkZXIobmV3IFVSTFJlcXVlc3RfMS5VUkxSZXF1ZXN0KFwiZXhhbXBsZXMvYXNzZXRzL3NuYWtlLnBuZ1wiKSk7XHJcbiAgICAgICAgdGhpcy5sb2FkZXIuYWRkRXZlbnRMaXN0ZW5lcihFdmVudF8xLkV2ZW50LkNPTVBMRVRFLCB0aGlzLmhhbmRsZVBsYW5lTG9hZGVkKTtcclxuICAgICAgICB0aGlzLmxvYWRlci5sb2FkKCk7XHJcbiAgICB9XHJcbiAgICByZW5kZXJQb2ludHMoKSB7XHJcbiAgICAgICAgdGhpcy5nLmNsZWFyKCk7XHJcbiAgICAgICAgdGhpcy5nLmxpbmVTdHlsZSgyLCAweGZmYzJjMik7XHJcbiAgICAgICAgdGhpcy5nLm1vdmVUbyh0aGlzLnBvaW50c1swXS54LCB0aGlzLnBvaW50c1swXS55KTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHRoaXMucG9pbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZy5saW5lVG8odGhpcy5wb2ludHNbaV0ueCwgdGhpcy5wb2ludHNbaV0ueSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgdGhpcy5wb2ludHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdGhpcy5nLmJlZ2luRmlsbCgweGZmMDAyMik7XHJcbiAgICAgICAgICAgIHRoaXMuZy5kcmF3Q2lyY2xlKHRoaXMucG9pbnRzW2ldLngsIHRoaXMucG9pbnRzW2ldLnksIDEwKTtcclxuICAgICAgICAgICAgdGhpcy5nLmVuZEZpbGwoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5NZXNoQWR2YW5jZWQgPSBNZXNoQWR2YW5jZWQ7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IEJhc2VFeGFtcGxlXzEgPSByZXF1aXJlKFwiLi9CYXNlRXhhbXBsZVwiKTtcclxuY29uc3QgUmVzb3VyY2VMb2FkZXJfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9SZXNvdXJjZUxvYWRlclwiKTtcclxuY29uc3QgVGV4dHVyZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1RleHR1cmVcIik7XHJcbmNvbnN0IFVSTFJlcXVlc3RfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9VUkxSZXF1ZXN0XCIpO1xyXG5jb25zdCBFdmVudF8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0V2ZW50XCIpO1xyXG5jb25zdCBCYXNlVGV4dHVyZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0Jhc2VUZXh0dXJlXCIpO1xyXG5jb25zdCBQb2ludF8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1BvaW50XCIpO1xyXG5jb25zdCBTaW1wbGVSb3BlXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvU2ltcGxlUm9wZVwiKTtcclxuY29uc3QgQ29udGFpbmVyXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvQ29udGFpbmVyXCIpO1xyXG5jbGFzcyBNZXNoQmFzaWMgZXh0ZW5kcyBCYXNlRXhhbXBsZV8xLkJhc2VFeGFtcGxlIHtcclxuICAgIGNvbnN0cnVjdG9yKGFwcCwgd2lkdGgsIGhlaWdodCkge1xyXG4gICAgICAgIHN1cGVyKGFwcCwgd2lkdGgsIGhlaWdodCk7XHJcbiAgICAgICAgdGhpcy5ydW5FeGFtcGxlID0gKGRlbHRhKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuY291bnQgKz0gMC4xO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucG9pbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBvaW50c1tpXS55ID0gTWF0aC5zaW4oKGkgKiAwLjUpICsgdGhpcy5jb3VudCkgKiAzMDtcclxuICAgICAgICAgICAgICAgIHRoaXMucG9pbnRzW2ldLnggPSBpICogdGhpcy5yb3BlTGVuZ3RoICsgTWF0aC5jb3MoKGkgKiAwLjMpICsgdGhpcy5jb3VudCkgKiAyMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5oYW5kbGVQbGFuZUxvYWRlZCA9IChldmVudCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnBsYW5lVHh0ID0gbmV3IFRleHR1cmVfMS5UZXh0dXJlKG5ldyBCYXNlVGV4dHVyZV8xLkJhc2VUZXh0dXJlKHRoaXMubG9hZGVyLmltYWdlRGF0YSkpO1xyXG4gICAgICAgICAgICB0aGlzLmNvdW50ID0gMDtcclxuICAgICAgICAgICAgdGhpcy5yb3BlTGVuZ3RoID0gOTE4IC8gMjA7XHJcbiAgICAgICAgICAgIHRoaXMucG9pbnRzID0gW107XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMjA7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wb2ludHMucHVzaChuZXcgUG9pbnRfMS5Qb2ludChpICogdGhpcy5yb3BlTGVuZ3RoLCAwKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3Qgc3RyaXAgPSBuZXcgU2ltcGxlUm9wZV8xLlNpbXBsZVJvcGUodGhpcy5wbGFuZVR4dCwgdGhpcy5wb2ludHMpO1xyXG4gICAgICAgICAgICBzdHJpcC54ID0gLTQ1OTtcclxuICAgICAgICAgICAgY29uc3Qgc25ha2VDb250YWluZXIgPSBuZXcgQ29udGFpbmVyXzEuQ29udGFpbmVyKCk7XHJcbiAgICAgICAgICAgIHNuYWtlQ29udGFpbmVyLnggPSA0MDA7XHJcbiAgICAgICAgICAgIHNuYWtlQ29udGFpbmVyLnkgPSAzMDA7XHJcbiAgICAgICAgICAgIHNuYWtlQ29udGFpbmVyLnNjYWxlLnNldCg4MDAgLyAxMTAwKTtcclxuICAgICAgICAgICAgdGhpcy5hcHAuc3RhZ2UuYWRkQ2hpbGQoc25ha2VDb250YWluZXIpO1xyXG4gICAgICAgICAgICBzbmFrZUNvbnRhaW5lci5hZGRDaGlsZChzdHJpcCk7XHJcbiAgICAgICAgICAgIHRoaXMuYXBwLnRpY2tlci5hZGQodGhpcy5ydW5FeGFtcGxlKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMubG9hZGVyID0gbmV3IFJlc291cmNlTG9hZGVyXzEuUmVzb3VyY2VMb2FkZXIobmV3IFVSTFJlcXVlc3RfMS5VUkxSZXF1ZXN0KFwiZXhhbXBsZXMvYXNzZXRzL3NuYWtlLnBuZ1wiKSk7XHJcbiAgICAgICAgdGhpcy5sb2FkZXIuYWRkRXZlbnRMaXN0ZW5lcihFdmVudF8xLkV2ZW50LkNPTVBMRVRFLCB0aGlzLmhhbmRsZVBsYW5lTG9hZGVkKTtcclxuICAgICAgICB0aGlzLmxvYWRlci5sb2FkKCk7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5NZXNoQmFzaWMgPSBNZXNoQmFzaWM7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IEJhc2VFeGFtcGxlXzEgPSByZXF1aXJlKFwiLi9CYXNlRXhhbXBsZVwiKTtcclxuY29uc3QgR2VvbWV0cnlfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9HZW9tZXRyeVwiKTtcclxuY29uc3QgUHJvZ3JhbV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1Byb2dyYW1cIik7XHJcbmNvbnN0IFNoYWRlcl8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1NoYWRlclwiKTtcclxuY29uc3QgTWVzaF8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL01lc2hcIik7XHJcbmNsYXNzIE1lc2hDb2xvcmVkVHJpYW5nbGUgZXh0ZW5kcyBCYXNlRXhhbXBsZV8xLkJhc2VFeGFtcGxlIHtcclxuICAgIGNvbnN0cnVjdG9yKGFwcCwgd2lkdGgsIGhlaWdodCkge1xyXG4gICAgICAgIHN1cGVyKGFwcCwgd2lkdGgsIGhlaWdodCk7XHJcbiAgICAgICAgdGhpcy5ydW5FeGFtcGxlID0gKGRlbHRhKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMudHJpYW5nbGUucm90YXRpb24gKz0gMC4wMTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIGNvbnN0IGdlb21ldHJ5ID0gbmV3IEdlb21ldHJ5XzEuR2VvbWV0cnkoKTtcclxuICAgICAgICBnZW9tZXRyeS5hZGRBdHRyaWJ1dGUoJ2FWZXJ0ZXhQb3NpdGlvbicsIC8vIHRoZSBhdHRyaWJ1dGUgbmFtZVxyXG4gICAgICAgIFstMTAwLCAtNTAsXHJcbiAgICAgICAgICAgIDEwMCwgLTUwLFxyXG4gICAgICAgICAgICAwLjAsIDEwMC4wXSwgLy8geCwgeVxyXG4gICAgICAgIDIpOyAvLyB0aGUgc2l6ZSBvZiB0aGUgYXR0cmlidXRlXHJcbiAgICAgICAgZ2VvbWV0cnkuYWRkQXR0cmlidXRlKCdhQ29sb3InLCAvLyB0aGUgYXR0cmlidXRlIG5hbWVcclxuICAgICAgICBbMSwgMCwgMCxcclxuICAgICAgICAgICAgMCwgMSwgMCxcclxuICAgICAgICAgICAgMCwgMCwgMV0sIC8vIHIsIGcsIGJcclxuICAgICAgICAzKTsgLy8gdGhlIHNpemUgb2YgdGhlIGF0dHJpYnV0ZVxyXG4gICAgICAgIGxldCB2eCA9IGBcclxuICAgICAgICAgICAgcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XHJcbiAgICAgICAgICAgIGF0dHJpYnV0ZSB2ZWMyIGFWZXJ0ZXhQb3NpdGlvbjtcclxuICAgICAgICAgICAgYXR0cmlidXRlIHZlYzMgYUNvbG9yOyAgICBcclxuICAgICAgICAgICAgdW5pZm9ybSBtYXQzIHRyYW5zbGF0aW9uTWF0cml4O1xyXG4gICAgICAgICAgICB1bmlmb3JtIG1hdDMgcHJvamVjdGlvbk1hdHJpeDsgICAgXHJcbiAgICAgICAgICAgIHZhcnlpbmcgdmVjMyB2Q29sb3I7ICAgIFxyXG4gICAgICAgICAgICB2b2lkIG1haW4oKSB7ICAgIFxyXG4gICAgICAgICAgICAgICAgdkNvbG9yID0gYUNvbG9yO1xyXG4gICAgICAgICAgICAgICAgZ2xfUG9zaXRpb24gPSB2ZWM0KChwcm9qZWN0aW9uTWF0cml4ICogdHJhbnNsYXRpb25NYXRyaXggKiB2ZWMzKGFWZXJ0ZXhQb3NpdGlvbiwgMS4wKSkueHksIDAuMCwgMS4wKTsgICAgXHJcbiAgICAgICAgICAgIH1gO1xyXG4gICAgICAgIGxldCBmeCA9IGBwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcclxuICAgICAgICAgICAgdmFyeWluZyB2ZWMzIHZDb2xvcjsgICAgXHJcbiAgICAgICAgICAgIHZvaWQgbWFpbigpIHtcclxuICAgICAgICAgICAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQodkNvbG9yLCAxLjApO1xyXG4gICAgICAgICAgICB9ICAgIFxyXG4gICAgICAgICAgICBgO1xyXG4gICAgICAgIGxldCBwcm9ncmFtID0gbmV3IFByb2dyYW1fMS5Qcm9ncmFtKHZ4LCBmeCk7XHJcbiAgICAgICAgY29uc3Qgc2hhZGVyID0gbmV3IFNoYWRlcl8xLlNoYWRlcihwcm9ncmFtLCBudWxsKTtcclxuICAgICAgICB0aGlzLnRyaWFuZ2xlID0gbmV3IE1lc2hfMS5NZXNoKGdlb21ldHJ5LCBzaGFkZXIpO1xyXG4gICAgICAgIHRoaXMudHJpYW5nbGUucG9zaXRpb24uc2V0KDQwMCwgMzAwKTtcclxuICAgICAgICB0aGlzLnRyaWFuZ2xlLnNjYWxlLnNldCgyKTtcclxuICAgICAgICBhcHAuc3RhZ2UuYWRkQ2hpbGQodGhpcy50cmlhbmdsZSk7XHJcbiAgICAgICAgdGhpcy5hcHAudGlja2VyLmFkZCh0aGlzLnJ1bkV4YW1wbGUpO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuTWVzaENvbG9yZWRUcmlhbmdsZSA9IE1lc2hDb2xvcmVkVHJpYW5nbGU7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IEJhc2VFeGFtcGxlXzEgPSByZXF1aXJlKFwiLi9CYXNlRXhhbXBsZVwiKTtcclxuY29uc3QgUmVzb3VyY2VMb2FkZXJfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9SZXNvdXJjZUxvYWRlclwiKTtcclxuY29uc3QgVGV4dHVyZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1RleHR1cmVcIik7XHJcbmNvbnN0IFVSTFJlcXVlc3RfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9VUkxSZXF1ZXN0XCIpO1xyXG5jb25zdCBFdmVudF8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0V2ZW50XCIpO1xyXG5jb25zdCBCYXNlVGV4dHVyZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0Jhc2VUZXh0dXJlXCIpO1xyXG5jb25zdCBHZW9tZXRyeV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0dlb21ldHJ5XCIpO1xyXG5jb25zdCBQcm9ncmFtXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvUHJvZ3JhbVwiKTtcclxuY29uc3QgTWVzaF8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL01lc2hcIik7XHJcbmNvbnN0IFNoYWRlcl8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1NoYWRlclwiKTtcclxuY2xhc3MgTWVzaEdlb21ldHJ5IGV4dGVuZHMgQmFzZUV4YW1wbGVfMS5CYXNlRXhhbXBsZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihhcHAsIHdpZHRoLCBoZWlnaHQpIHtcclxuICAgICAgICBzdXBlcihhcHAsIHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgICAgIHRoaXMuaGFuZGxlVHh0M0xvYWRlZCA9IChldmVudCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnR4dDMgPSBuZXcgVGV4dHVyZV8xLlRleHR1cmUobmV3IEJhc2VUZXh0dXJlXzEuQmFzZVRleHR1cmUodGhpcy5sb2FkZXIuaW1hZ2VEYXRhKSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGdlb21ldHJ5ID0gbmV3IEdlb21ldHJ5XzEuR2VvbWV0cnkoKTtcclxuICAgICAgICAgICAgZ2VvbWV0cnkuYWRkQXR0cmlidXRlKCdhVmVydGV4UG9zaXRpb24nLCAvLyB0aGUgYXR0cmlidXRlIG5hbWVcclxuICAgICAgICAgICAgWy0xMDAsIC0xMDAsXHJcbiAgICAgICAgICAgICAgICAxMDAsIC0xMDAsXHJcbiAgICAgICAgICAgICAgICAxMDAsIDEwMF0sIC8vIHgsIHlcclxuICAgICAgICAgICAgMik7IC8vIHRoZSBzaXplIG9mIHRoZSBhdHRyaWJ1dGUgICAgXHJcbiAgICAgICAgICAgIGdlb21ldHJ5LmFkZEF0dHJpYnV0ZSgnYVV2cycsIC8vIHRoZSBhdHRyaWJ1dGUgbmFtZVxyXG4gICAgICAgICAgICBbMCwgMCxcclxuICAgICAgICAgICAgICAgIDEsIDAsXHJcbiAgICAgICAgICAgICAgICAxLCAxXSwgLy8gdSwgdlxyXG4gICAgICAgICAgICAyKTsgLy8gdGhlIHNpemUgb2YgdGhlIGF0dHJpYnV0ZSAgICBcclxuICAgICAgICAgICAgY29uc3QgcHJvZ3JhbSA9IFByb2dyYW1fMS5Qcm9ncmFtLmZyb20oYCAgICBcclxuICAgICAgICAgICAgcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7ICAgIFxyXG4gICAgICAgICAgICBhdHRyaWJ1dGUgdmVjMiBhVmVydGV4UG9zaXRpb247XHJcbiAgICAgICAgICAgIGF0dHJpYnV0ZSB2ZWMyIGFVdnM7ICAgIFxyXG4gICAgICAgICAgICB1bmlmb3JtIG1hdDMgdHJhbnNsYXRpb25NYXRyaXg7XHJcbiAgICAgICAgICAgIHVuaWZvcm0gbWF0MyBwcm9qZWN0aW9uTWF0cml4OyAgICBcclxuICAgICAgICAgICAgdmFyeWluZyB2ZWMyIHZVdnM7ICAgIFxyXG4gICAgICAgICAgICB2b2lkIG1haW4oKSB7ICAgIFxyXG4gICAgICAgICAgICAgICAgdlV2cyA9IGFVdnM7XHJcbiAgICAgICAgICAgICAgICBnbF9Qb3NpdGlvbiA9IHZlYzQoKHByb2plY3Rpb25NYXRyaXggKiB0cmFuc2xhdGlvbk1hdHJpeCAqIHZlYzMoYVZlcnRleFBvc2l0aW9uLCAxLjApKS54eSwgMC4wLCAxLjApOyAgICBcclxuICAgICAgICAgICAgfWAsIGBwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDsgICAgXHJcbiAgICAgICAgICAgIHZhcnlpbmcgdmVjMiB2VXZzOyAgICBcclxuICAgICAgICAgICAgdW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXJUZXh0dXJlOyAgICBcclxuICAgICAgICAgICAgdm9pZCBtYWluKCkgeyAgICBcclxuICAgICAgICAgICAgICAgIGdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCh1U2FtcGxlclRleHR1cmUsIHZVdnMpO1xyXG4gICAgICAgICAgICB9ICAgIFxyXG4gICAgICAgIGApO1xyXG4gICAgICAgICAgICB0aGlzLnRyaWFuZ2xlID0gbmV3IE1lc2hfMS5NZXNoKGdlb21ldHJ5LCBuZXcgU2hhZGVyXzEuU2hhZGVyKHByb2dyYW0sIHtcclxuICAgICAgICAgICAgICAgIHVTYW1wbGVyVGV4dHVyZTogdGhpcy50eHQxLFxyXG4gICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgIHRoaXMudHJpYW5nbGUyID0gbmV3IE1lc2hfMS5NZXNoKGdlb21ldHJ5LCBuZXcgU2hhZGVyXzEuU2hhZGVyKHByb2dyYW0sIHtcclxuICAgICAgICAgICAgICAgIHVTYW1wbGVyVGV4dHVyZTogdGhpcy50eHQyLFxyXG4gICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgIHRoaXMudHJpYW5nbGUzID0gbmV3IE1lc2hfMS5NZXNoKGdlb21ldHJ5LCBuZXcgU2hhZGVyXzEuU2hhZGVyKHByb2dyYW0sIHtcclxuICAgICAgICAgICAgICAgIHVTYW1wbGVyVGV4dHVyZTogdGhpcy50eHQzLFxyXG4gICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgIHRoaXMudHJpYW5nbGUucG9zaXRpb24uc2V0KDQwMCwgMzAwKTtcclxuICAgICAgICAgICAgdGhpcy50cmlhbmdsZS5zY2FsZS5zZXQoMik7XHJcbiAgICAgICAgICAgIHRoaXMudHJpYW5nbGUyLnBvc2l0aW9uLnNldCgyMDAsIDEwMCk7XHJcbiAgICAgICAgICAgIHRoaXMudHJpYW5nbGUzLnBvc2l0aW9uLnNldCg1MDAsIDQwMCk7XHJcbiAgICAgICAgICAgIHRoaXMudHJpYW5nbGUzLnNjYWxlLnNldCgzKTtcclxuICAgICAgICAgICAgdGhpcy5hcHAuc3RhZ2UuYWRkQ2hpbGQodGhpcy50cmlhbmdsZTMpO1xyXG4gICAgICAgICAgICB0aGlzLmFwcC5zdGFnZS5hZGRDaGlsZCh0aGlzLnRyaWFuZ2xlMik7XHJcbiAgICAgICAgICAgIHRoaXMuYXBwLnN0YWdlLmFkZENoaWxkKHRoaXMudHJpYW5nbGUpO1xyXG4gICAgICAgICAgICB0aGlzLmFwcC50aWNrZXIuYWRkKHRoaXMucnVuRXhhbXBsZSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLnJ1bkV4YW1wbGUgPSAoZGVsdGEpID0+IHtcclxuICAgICAgICAgICAgdGhpcy50cmlhbmdsZS5yb3RhdGlvbiArPSAwLjAxO1xyXG4gICAgICAgICAgICB0aGlzLnRyaWFuZ2xlMi5yb3RhdGlvbiAtPSAwLjAxO1xyXG4gICAgICAgICAgICB0aGlzLnRyaWFuZ2xlMy5yb3RhdGlvbiAtPSAwLjAwNTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuaGFuZGxlVHh0MkxvYWRlZCA9IChldmVudCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnR4dDIgPSBuZXcgVGV4dHVyZV8xLlRleHR1cmUobmV3IEJhc2VUZXh0dXJlXzEuQmFzZVRleHR1cmUodGhpcy5sb2FkZXIuaW1hZ2VEYXRhKSk7XHJcbiAgICAgICAgICAgIHRoaXMubG9hZGVyID0gbmV3IFJlc291cmNlTG9hZGVyXzEuUmVzb3VyY2VMb2FkZXIobmV3IFVSTFJlcXVlc3RfMS5VUkxSZXF1ZXN0KFwiZXhhbXBsZXMvYXNzZXRzL2JnX2Rpc3BsYWNlbWVudC5qcGdcIikpO1xyXG4gICAgICAgICAgICB0aGlzLmxvYWRlci5hZGRFdmVudExpc3RlbmVyKEV2ZW50XzEuRXZlbnQuQ09NUExFVEUsIHRoaXMuaGFuZGxlVHh0M0xvYWRlZCk7XHJcbiAgICAgICAgICAgIHRoaXMubG9hZGVyLmxvYWQoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuaGFuZGxlVHh0MUxvYWRlZCA9IChldmVudCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnR4dDEgPSBuZXcgVGV4dHVyZV8xLlRleHR1cmUobmV3IEJhc2VUZXh0dXJlXzEuQmFzZVRleHR1cmUodGhpcy5sb2FkZXIuaW1hZ2VEYXRhKSk7XHJcbiAgICAgICAgICAgIHRoaXMubG9hZGVyID0gbmV3IFJlc291cmNlTG9hZGVyXzEuUmVzb3VyY2VMb2FkZXIobmV3IFVSTFJlcXVlc3RfMS5VUkxSZXF1ZXN0KFwiZXhhbXBsZXMvYXNzZXRzL2JnX3JvdGF0ZS5qcGdcIikpO1xyXG4gICAgICAgICAgICB0aGlzLmxvYWRlci5hZGRFdmVudExpc3RlbmVyKEV2ZW50XzEuRXZlbnQuQ09NUExFVEUsIHRoaXMuaGFuZGxlVHh0MkxvYWRlZCk7XHJcbiAgICAgICAgICAgIHRoaXMubG9hZGVyLmxvYWQoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMubG9hZGVyID0gbmV3IFJlc291cmNlTG9hZGVyXzEuUmVzb3VyY2VMb2FkZXIobmV3IFVSTFJlcXVlc3RfMS5VUkxSZXF1ZXN0KFwiZXhhbXBsZXMvYXNzZXRzL2JnX3NjZW5lX3JvdGF0ZS5qcGdcIikpO1xyXG4gICAgICAgIHRoaXMubG9hZGVyLmFkZEV2ZW50TGlzdGVuZXIoRXZlbnRfMS5FdmVudC5DT01QTEVURSwgdGhpcy5oYW5kbGVUeHQxTG9hZGVkKTtcclxuICAgICAgICB0aGlzLmxvYWRlci5sb2FkKCk7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5NZXNoR2VvbWV0cnkgPSBNZXNoR2VvbWV0cnk7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IEJhc2VFeGFtcGxlXzEgPSByZXF1aXJlKFwiLi9CYXNlRXhhbXBsZVwiKTtcclxuY29uc3QgUmVzb3VyY2VMb2FkZXJfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9SZXNvdXJjZUxvYWRlclwiKTtcclxuY29uc3QgVGV4dHVyZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1RleHR1cmVcIik7XHJcbmNvbnN0IFVSTFJlcXVlc3RfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9VUkxSZXF1ZXN0XCIpO1xyXG5jb25zdCBFdmVudF8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0V2ZW50XCIpO1xyXG5jb25zdCBCYXNlVGV4dHVyZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0Jhc2VUZXh0dXJlXCIpO1xyXG5jb25zdCBHZW9tZXRyeV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0dlb21ldHJ5XCIpO1xyXG5jb25zdCBQcm9ncmFtXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvUHJvZ3JhbVwiKTtcclxuY29uc3QgU2hhZGVyXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvU2hhZGVyXCIpO1xyXG5jb25zdCBNZXNoXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvTWVzaFwiKTtcclxuY2xhc3MgTWVzaFNoYWRlciBleHRlbmRzIEJhc2VFeGFtcGxlXzEuQmFzZUV4YW1wbGUge1xyXG4gICAgY29uc3RydWN0b3IoYXBwLCB3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICAgICAgc3VwZXIoYXBwLCB3aWR0aCwgaGVpZ2h0KTtcclxuICAgICAgICB0aGlzLmhhbmRsZVR4dDFMb2FkZWQgPSAoZXZlbnQpID0+IHtcclxuICAgICAgICAgICAgdGhpcy50eHQxID0gbmV3IFRleHR1cmVfMS5UZXh0dXJlKG5ldyBCYXNlVGV4dHVyZV8xLkJhc2VUZXh0dXJlKHRoaXMubG9hZGVyLmltYWdlRGF0YSkpO1xyXG4gICAgICAgICAgICBjb25zdCBnZW9tZXRyeSA9IG5ldyBHZW9tZXRyeV8xLkdlb21ldHJ5KCk7XHJcbiAgICAgICAgICAgIGdlb21ldHJ5LmFkZEF0dHJpYnV0ZSgnYVZlcnRleFBvc2l0aW9uJywgLy8gdGhlIGF0dHJpYnV0ZSBuYW1lXHJcbiAgICAgICAgICAgIFstMTAwLCAtMTAwLFxyXG4gICAgICAgICAgICAgICAgMTAwLCAtMTAwLFxyXG4gICAgICAgICAgICAgICAgMTAwLCAxMDBdKTsgLy8geCwgeVxyXG4gICAgICAgICAgICBnZW9tZXRyeS5hZGRBdHRyaWJ1dGUoJ2FVdnMnLCAvLyB0aGUgYXR0cmlidXRlIG5hbWVcclxuICAgICAgICAgICAgWzAsIDAsXHJcbiAgICAgICAgICAgICAgICAxLCAwLFxyXG4gICAgICAgICAgICAgICAgMSwgMV0pOyAvLyB1LCB2XHJcbiAgICAgICAgICAgIGxldCB2eCA9IGBcclxuICAgICAgICAgICAgcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XHJcbiAgICAgICAgICAgIGF0dHJpYnV0ZSB2ZWMyIGFWZXJ0ZXhQb3NpdGlvbjtcclxuICAgICAgICAgICAgYXR0cmlidXRlIHZlYzIgYVV2cztcclxuICAgICAgICAgICAgdW5pZm9ybSBtYXQzIHRyYW5zbGF0aW9uTWF0cml4O1xyXG4gICAgICAgICAgICB1bmlmb3JtIG1hdDMgcHJvamVjdGlvbk1hdHJpeDtcclxuICAgICAgICAgICAgdmFyeWluZyB2ZWMyIHZVdnM7XHJcbiAgICAgICAgICAgIHZvaWQgbWFpbigpIHtcclxuICAgICAgICAgICAgICAgIHZVdnMgPSBhVXZzO1xyXG4gICAgICAgICAgICAgICAgZ2xfUG9zaXRpb24gPSB2ZWM0KChwcm9qZWN0aW9uTWF0cml4ICogdHJhbnNsYXRpb25NYXRyaXggKiB2ZWMzKGFWZXJ0ZXhQb3NpdGlvbiwgMS4wKSkueHksIDAuMCwgMS4wKTtcclxuICAgICAgICAgICAgfWA7XHJcbiAgICAgICAgICAgIGxldCBmeCA9IGBwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcclxuICAgICAgICAgICAgdmFyeWluZyB2ZWMyIHZVdnM7XHJcbiAgICAgICAgICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyMjtcclxuICAgICAgICAgICAgdm9pZCBtYWluKCkge1xyXG4gICAgICAgICAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKHVTYW1wbGVyMiwgdlV2cyk7XHJcbiAgICAgICAgICAgIH0gICAgICAgIFxyXG4gICAgICAgICAgICBgO1xyXG4gICAgICAgICAgICBsZXQgcHJvZ3JhbSA9IG5ldyBQcm9ncmFtXzEuUHJvZ3JhbSh2eCwgZngpO1xyXG4gICAgICAgICAgICBjb25zdCBzaGFkZXIgPSBuZXcgU2hhZGVyXzEuU2hhZGVyKHByb2dyYW0sIHsgdVNhbXBsZXIyOiB0aGlzLnR4dDEgfSk7XHJcbiAgICAgICAgICAgIGxldCB2eDIgPSBgXHJcbiAgICAgICAgICAgIHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0OyAgICBcclxuICAgICAgICAgICAgYXR0cmlidXRlIHZlYzIgYVZlcnRleFBvc2l0aW9uO1xyXG4gICAgICAgICAgICBhdHRyaWJ1dGUgdmVjMiBhVXZzOyAgICBcclxuICAgICAgICAgICAgdW5pZm9ybSBtYXQzIHRyYW5zbGF0aW9uTWF0cml4O1xyXG4gICAgICAgICAgICB1bmlmb3JtIG1hdDMgcHJvamVjdGlvbk1hdHJpeDsgICAgXHJcbiAgICAgICAgICAgIHZhcnlpbmcgdmVjMiB2VXZzOyAgICBcclxuICAgICAgICAgICAgdm9pZCBtYWluKCkgeyAgICBcclxuICAgICAgICAgICAgICAgIHZVdnMgPSBhVXZzO1xyXG4gICAgICAgICAgICAgICAgZ2xfUG9zaXRpb24gPSB2ZWM0KChwcm9qZWN0aW9uTWF0cml4ICogdHJhbnNsYXRpb25NYXRyaXggKiB2ZWMzKGFWZXJ0ZXhQb3NpdGlvbiwgMS4wKSkueHksIDAuMCwgMS4wKTsgICAgXHJcbiAgICAgICAgICAgIH1gO1xyXG4gICAgICAgICAgICBsZXQgZngyID0gYHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xyXG4gICAgICAgICAgICB2YXJ5aW5nIHZlYzIgdlV2czsgICAgXHJcbiAgICAgICAgICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyMjsgICAgXHJcbiAgICAgICAgICAgIHZvaWQgbWFpbigpIHsgICAgXHJcbiAgICAgICAgICAgICAgICBnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQodVNhbXBsZXIyLCB2VXZzKTtcclxuICAgICAgICAgICAgICAgIGdsX0ZyYWdDb2xvci5yICs9IChhYnMoc2luKGdsX0ZyYWdDb29yZC54ICogMC4wNikpICogMC41KSAqIDIuO1xyXG4gICAgICAgICAgICAgICAgZ2xfRnJhZ0NvbG9yLmcgKz0gKGFicyhjb3MoZ2xfRnJhZ0Nvb3JkLnkgKiAwLjA2KSkgKiAwLjUpICogMi47XHJcbiAgICAgICAgICAgIH0gICAgXHJcbiAgICAgICAgICAgIGA7XHJcbiAgICAgICAgICAgIGxldCBwcm9ncmFtMiA9IG5ldyBQcm9ncmFtXzEuUHJvZ3JhbSh2eDIsIGZ4Mik7XHJcbiAgICAgICAgICAgIGNvbnN0IHNoYWRlcjIgPSBuZXcgU2hhZGVyXzEuU2hhZGVyKHByb2dyYW0yLCB7IHVTYW1wbGVyMjogdGhpcy50eHQxIH0pO1xyXG4gICAgICAgICAgICB0aGlzLnRyaWFuZ2xlID0gbmV3IE1lc2hfMS5NZXNoKGdlb21ldHJ5LCBzaGFkZXIpO1xyXG4gICAgICAgICAgICB0aGlzLnRyaWFuZ2xlMiA9IG5ldyBNZXNoXzEuTWVzaChnZW9tZXRyeSwgc2hhZGVyMik7XHJcbiAgICAgICAgICAgIHRoaXMudHJpYW5nbGUucG9zaXRpb24uc2V0KDQwMCwgMzAwKTtcclxuICAgICAgICAgICAgdGhpcy50cmlhbmdsZS5zY2FsZS5zZXQoMik7XHJcbiAgICAgICAgICAgIHRoaXMudHJpYW5nbGUyLnBvc2l0aW9uLnNldCg1MDAsIDQwMCk7XHJcbiAgICAgICAgICAgIHRoaXMudHJpYW5nbGUyLnNjYWxlLnNldCgzKTtcclxuICAgICAgICAgICAgdGhpcy5hcHAuc3RhZ2UuYWRkQ2hpbGQodGhpcy50cmlhbmdsZTIpO1xyXG4gICAgICAgICAgICB0aGlzLmFwcC5zdGFnZS5hZGRDaGlsZCh0aGlzLnRyaWFuZ2xlKTtcclxuICAgICAgICAgICAgdGhpcy5hcHAudGlja2VyLmFkZCh0aGlzLnJ1bkV4YW1wbGUpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5ydW5FeGFtcGxlID0gKGRlbHRhKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMudHJpYW5nbGUucm90YXRpb24gKz0gMC4wMTtcclxuICAgICAgICAgICAgdGhpcy50cmlhbmdsZTIucm90YXRpb24gLT0gMC4wMDU7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLmxvYWRlciA9IG5ldyBSZXNvdXJjZUxvYWRlcl8xLlJlc291cmNlTG9hZGVyKG5ldyBVUkxSZXF1ZXN0XzEuVVJMUmVxdWVzdChcImV4YW1wbGVzL2Fzc2V0cy9iZ19zY2VuZV9yb3RhdGUuanBnXCIpKTtcclxuICAgICAgICB0aGlzLmxvYWRlci5hZGRFdmVudExpc3RlbmVyKEV2ZW50XzEuRXZlbnQuQ09NUExFVEUsIHRoaXMuaGFuZGxlVHh0MUxvYWRlZCk7XHJcbiAgICAgICAgdGhpcy5sb2FkZXIubG9hZCgpO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuTWVzaFNoYWRlciA9IE1lc2hTaGFkZXI7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IEJhc2VFeGFtcGxlXzEgPSByZXF1aXJlKFwiLi9CYXNlRXhhbXBsZVwiKTtcclxuY29uc3QgUmVzb3VyY2VMb2FkZXJfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9SZXNvdXJjZUxvYWRlclwiKTtcclxuY29uc3QgVGV4dHVyZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1RleHR1cmVcIik7XHJcbmNvbnN0IFVSTFJlcXVlc3RfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9VUkxSZXF1ZXN0XCIpO1xyXG5jb25zdCBFdmVudF8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0V2ZW50XCIpO1xyXG5jb25zdCBCYXNlVGV4dHVyZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0Jhc2VUZXh0dXJlXCIpO1xyXG5jb25zdCBHZW9tZXRyeV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0dlb21ldHJ5XCIpO1xyXG5jb25zdCBQcm9ncmFtXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvUHJvZ3JhbVwiKTtcclxuY29uc3QgU2hhZGVyXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvU2hhZGVyXCIpO1xyXG5jb25zdCBNZXNoXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvTWVzaFwiKTtcclxuY2xhc3MgTWVzaFRleHR1cmVkIGV4dGVuZHMgQmFzZUV4YW1wbGVfMS5CYXNlRXhhbXBsZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihhcHAsIHdpZHRoLCBoZWlnaHQpIHtcclxuICAgICAgICBzdXBlcihhcHAsIHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgICAgIHRoaXMuaGFuZGxlUGxhbmVMb2FkZWQgPSAoZXZlbnQpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5wbGFuZVR4dCA9IG5ldyBUZXh0dXJlXzEuVGV4dHVyZShuZXcgQmFzZVRleHR1cmVfMS5CYXNlVGV4dHVyZSh0aGlzLmxvYWRlci5pbWFnZURhdGEpKTtcclxuICAgICAgICAgICAgY29uc3QgZ2VvbWV0cnkgPSBuZXcgR2VvbWV0cnlfMS5HZW9tZXRyeSgpO1xyXG4gICAgICAgICAgICBnZW9tZXRyeS5hZGRBdHRyaWJ1dGUoJ2FWZXJ0ZXhQb3NpdGlvbicsIC8vIHRoZSBhdHRyaWJ1dGUgbmFtZVxyXG4gICAgICAgICAgICBbLTEwMCwgLTEwMCxcclxuICAgICAgICAgICAgICAgIDEwMCwgLTEwMCxcclxuICAgICAgICAgICAgICAgIDEwMCwgMTAwXSwgLy8geCwgeVxyXG4gICAgICAgICAgICAyKTsgLy8gdGhlIHNpemUgb2YgdGhlIGF0dHJpYnV0ZVxyXG4gICAgICAgICAgICBnZW9tZXRyeS5hZGRBdHRyaWJ1dGUoJ2FDb2xvcicsIC8vIHRoZSBhdHRyaWJ1dGUgbmFtZVxyXG4gICAgICAgICAgICBbMSwgMCwgMCxcclxuICAgICAgICAgICAgICAgIDAsIDEsIDAsXHJcbiAgICAgICAgICAgICAgICAwLCAwLCAxXSwgLy8gciwgZywgYlxyXG4gICAgICAgICAgICAzKTsgLy8gdGhlIHNpemUgb2YgdGhlIGF0dHJpYnV0ZVxyXG4gICAgICAgICAgICBnZW9tZXRyeS5hZGRBdHRyaWJ1dGUoJ2FVdnMnLCAvLyB0aGUgYXR0cmlidXRlIG5hbWVcclxuICAgICAgICAgICAgWzAsIDAsXHJcbiAgICAgICAgICAgICAgICAxLCAwLFxyXG4gICAgICAgICAgICAgICAgMSwgMV0sIC8vIHUsIHZcclxuICAgICAgICAgICAgMik7IC8vIHRoZSBzaXplIG9mIHRoZSBhdHRyaWJ1dGVcclxuICAgICAgICAgICAgY29uc3QgdmVydGV4U3JjID0gYFxyXG4gICAgICAgICAgICBwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcclxuICAgICAgICAgICAgYXR0cmlidXRlIHZlYzIgYVZlcnRleFBvc2l0aW9uO1xyXG4gICAgICAgICAgICBhdHRyaWJ1dGUgdmVjMyBhQ29sb3I7XHJcbiAgICAgICAgICAgIGF0dHJpYnV0ZSB2ZWMyIGFVdnM7XHJcbiAgICAgICAgICAgIHVuaWZvcm0gbWF0MyB0cmFuc2xhdGlvbk1hdHJpeDtcclxuICAgICAgICAgICAgdW5pZm9ybSBtYXQzIHByb2plY3Rpb25NYXRyaXg7XHJcbiAgICAgICAgICAgIHZhcnlpbmcgdmVjMiB2VXZzO1xyXG4gICAgICAgICAgICB2YXJ5aW5nIHZlYzMgdkNvbG9yO1xyXG4gICAgICAgICAgICB2b2lkIG1haW4oKSB7XHJcbiAgICAgICAgICAgICAgICB2VXZzID0gYVV2cztcclxuICAgICAgICAgICAgICAgIHZDb2xvciA9IGFDb2xvcjtcclxuICAgICAgICAgICAgICAgIGdsX1Bvc2l0aW9uID0gdmVjNCgocHJvamVjdGlvbk1hdHJpeCAqIHRyYW5zbGF0aW9uTWF0cml4ICogdmVjMyhhVmVydGV4UG9zaXRpb24sIDEuMCkpLnh5LCAwLjAsIDEuMCk7XHJcbiAgICAgICAgICAgIH1gO1xyXG4gICAgICAgICAgICBjb25zdCBmcmFnbWVudFNyYyA9IGBcclxuICAgICAgICAgICAgcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XHJcbiAgICAgICAgICAgIHZhcnlpbmcgdmVjMyB2Q29sb3I7XHJcbiAgICAgICAgICAgIHZhcnlpbmcgdmVjMiB2VXZzO1xyXG4gICAgICAgICAgICB1bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjI7XHJcbiAgICAgICAgICAgIHZvaWQgbWFpbigpIHtcclxuICAgICAgICAgICAgICAgIGdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCh1U2FtcGxlcjIsIHZVdnMpICogdmVjNCh2Q29sb3IsIDEuMCk7XHJcbiAgICAgICAgICAgIH1gO1xyXG4gICAgICAgICAgICBjb25zdCB1bmlmb3JtcyA9IHsgdVNhbXBsZXIyOiB0aGlzLnBsYW5lVHh0IH07XHJcbiAgICAgICAgICAgIGxldCBwcm9ncmFtID0gbmV3IFByb2dyYW1fMS5Qcm9ncmFtKHZlcnRleFNyYywgZnJhZ21lbnRTcmMpO1xyXG4gICAgICAgICAgICBjb25zdCBzaGFkZXIgPSBuZXcgU2hhZGVyXzEuU2hhZGVyKHByb2dyYW0sIHVuaWZvcm1zKTtcclxuICAgICAgICAgICAgdGhpcy50cmlhbmdsZSA9IG5ldyBNZXNoXzEuTWVzaChnZW9tZXRyeSwgc2hhZGVyKTtcclxuICAgICAgICAgICAgdGhpcy50cmlhbmdsZS5wb3NpdGlvbi5zZXQoNDAwLCAzMDApO1xyXG4gICAgICAgICAgICB0aGlzLnRyaWFuZ2xlLnNjYWxlLnNldCgyKTtcclxuICAgICAgICAgICAgdGhpcy5hcHAuc3RhZ2UuYWRkQ2hpbGQodGhpcy50cmlhbmdsZSk7XHJcbiAgICAgICAgICAgIHRoaXMuYXBwLnRpY2tlci5hZGQodGhpcy5ydW5FeGFtcGxlKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMucnVuRXhhbXBsZSA9IChkZWx0YSkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnRyaWFuZ2xlLnJvdGF0aW9uICs9IDAuMDE7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLmxvYWRlciA9IG5ldyBSZXNvdXJjZUxvYWRlcl8xLlJlc291cmNlTG9hZGVyKG5ldyBVUkxSZXF1ZXN0XzEuVVJMUmVxdWVzdChcImV4YW1wbGVzL2Fzc2V0cy9iZ19zY2VuZV9yb3RhdGUuanBnXCIpKTtcclxuICAgICAgICB0aGlzLmxvYWRlci5hZGRFdmVudExpc3RlbmVyKEV2ZW50XzEuRXZlbnQuQ09NUExFVEUsIHRoaXMuaGFuZGxlUGxhbmVMb2FkZWQpO1xyXG4gICAgICAgIHRoaXMubG9hZGVyLmxvYWQoKTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLk1lc2hUZXh0dXJlZCA9IE1lc2hUZXh0dXJlZDtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgQmFzZUV4YW1wbGVfMSA9IHJlcXVpcmUoXCIuL0Jhc2VFeGFtcGxlXCIpO1xyXG5jb25zdCBHZW9tZXRyeV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0dlb21ldHJ5XCIpO1xyXG5jb25zdCBTaGFkZXJfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9TaGFkZXJcIik7XHJcbmNvbnN0IFByb2dyYW1fMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9Qcm9ncmFtXCIpO1xyXG5jb25zdCBNZXNoXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvTWVzaFwiKTtcclxuY2xhc3MgTWVzaFRyaWFuZ2xlIGV4dGVuZHMgQmFzZUV4YW1wbGVfMS5CYXNlRXhhbXBsZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihhcHAsIHdpZHRoLCBoZWlnaHQpIHtcclxuICAgICAgICBzdXBlcihhcHAsIHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgICAgIHRoaXMucnVuRXhhbXBsZSA9IChkZWx0YSkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnRyaWFuZ2xlLnJvdGF0aW9uICs9IDAuMDE7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCBnZW9tZXRyeSA9IG5ldyBHZW9tZXRyeV8xLkdlb21ldHJ5KCk7XHJcbiAgICAgICAgZ2VvbWV0cnkuYWRkQXR0cmlidXRlKCdhVmVydGV4UG9zaXRpb24nLCBbLTEwMCwgLTUwLCAxMDAsIC01MCwgMCwgMTAwXSk7XHJcbiAgICAgICAgbGV0IHZ4ID0gYFxyXG4gICAgICAgICAgICBwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcclxuICAgICAgICAgICAgYXR0cmlidXRlIHZlYzIgYVZlcnRleFBvc2l0aW9uO1xyXG4gICAgICAgICAgICB1bmlmb3JtIG1hdDMgdHJhbnNsYXRpb25NYXRyaXg7XHJcbiAgICAgICAgICAgIHVuaWZvcm0gbWF0MyBwcm9qZWN0aW9uTWF0cml4O1xyXG4gICAgICAgICAgICB2b2lkIG1haW4oKSB7XHJcbiAgICAgICAgICAgICAgICBnbF9Qb3NpdGlvbiA9IHZlYzQoKHByb2plY3Rpb25NYXRyaXggKiB0cmFuc2xhdGlvbk1hdHJpeCAqIHZlYzMoYVZlcnRleFBvc2l0aW9uLCAxLjApKS54eSwgMC4wLCAxLjApO1xyXG4gICAgICAgICAgICB9YDtcclxuICAgICAgICBsZXQgZnggPSBgcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XHJcbiAgICAgICAgICAgIHZvaWQgbWFpbigpIHtcclxuICAgICAgICAgICAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoMS4wLCAwLjAsIDAuMCwgMS4wKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIGA7XHJcbiAgICAgICAgbGV0IHByb2dyYW0gPSBuZXcgUHJvZ3JhbV8xLlByb2dyYW0odngsIGZ4KTtcclxuICAgICAgICBjb25zdCBzaGFkZXIgPSBuZXcgU2hhZGVyXzEuU2hhZGVyKHByb2dyYW0sIG51bGwpO1xyXG4gICAgICAgIHRoaXMudHJpYW5nbGUgPSBuZXcgTWVzaF8xLk1lc2goZ2VvbWV0cnksIHNoYWRlcik7XHJcbiAgICAgICAgdGhpcy50cmlhbmdsZS5wb3NpdGlvbi5zZXQoNDAwLCAzMDApO1xyXG4gICAgICAgIGFwcC5zdGFnZS5hZGRDaGlsZCh0aGlzLnRyaWFuZ2xlKTtcclxuICAgICAgICB0aGlzLmFwcC50aWNrZXIuYWRkKHRoaXMucnVuRXhhbXBsZSk7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5NZXNoVHJpYW5nbGUgPSBNZXNoVHJpYW5nbGU7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IEJhc2VFeGFtcGxlXzEgPSByZXF1aXJlKFwiLi9CYXNlRXhhbXBsZVwiKTtcclxuY29uc3QgTWVzaF8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL01lc2hcIik7XHJcbmNvbnN0IFJlc291cmNlTG9hZGVyXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvUmVzb3VyY2VMb2FkZXJcIik7XHJcbmNvbnN0IFRleHR1cmVfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9UZXh0dXJlXCIpO1xyXG5jb25zdCBVUkxSZXF1ZXN0XzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvVVJMUmVxdWVzdFwiKTtcclxuY29uc3QgRXZlbnRfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9FdmVudFwiKTtcclxuY29uc3QgQmFzZVRleHR1cmVfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9CYXNlVGV4dHVyZVwiKTtcclxuY29uc3QgR2VvbWV0cnlfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9HZW9tZXRyeVwiKTtcclxuY29uc3QgUHJvZ3JhbV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1Byb2dyYW1cIik7XHJcbmNvbnN0IFNoYWRlcl8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1NoYWRlclwiKTtcclxuY2xhc3MgTWVzaFVuaWZvcm1zIGV4dGVuZHMgQmFzZUV4YW1wbGVfMS5CYXNlRXhhbXBsZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihhcHAsIHdpZHRoLCBoZWlnaHQpIHtcclxuICAgICAgICBzdXBlcihhcHAsIHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgICAgIHRoaXMuaGFuZGxlUGxhbmVMb2FkZWQgPSAoZXZlbnQpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5wbGFuZVR4dCA9IG5ldyBUZXh0dXJlXzEuVGV4dHVyZShuZXcgQmFzZVRleHR1cmVfMS5CYXNlVGV4dHVyZSh0aGlzLmxvYWRlci5pbWFnZURhdGEpKTtcclxuICAgICAgICAgICAgY29uc3QgZ2VvbWV0cnkgPSBuZXcgR2VvbWV0cnlfMS5HZW9tZXRyeSgpO1xyXG4gICAgICAgICAgICBnZW9tZXRyeS5hZGRBdHRyaWJ1dGUoJ2FWZXJ0ZXhQb3NpdGlvbicsIC8vIHRoZSBhdHRyaWJ1dGUgbmFtZVxyXG4gICAgICAgICAgICBbLTEwMCwgLTEwMCxcclxuICAgICAgICAgICAgICAgIDEwMCwgLTEwMCxcclxuICAgICAgICAgICAgICAgIDEwMCwgMTAwLFxyXG4gICAgICAgICAgICAgICAgLTEwMCwgMTAwXSwgLy8geCwgeVxyXG4gICAgICAgICAgICAyKTsgLy8gdGhlIHNpemUgb2YgdGhlIGF0dHJpYnV0ZVxyXG4gICAgICAgICAgICBnZW9tZXRyeS5hZGRBdHRyaWJ1dGUoJ2FVdnMnLCAvLyB0aGUgYXR0cmlidXRlIG5hbWVcclxuICAgICAgICAgICAgWzAsIDAsXHJcbiAgICAgICAgICAgICAgICAxLCAwLFxyXG4gICAgICAgICAgICAgICAgMSwgMSxcclxuICAgICAgICAgICAgICAgIDAsIDFdLCAvLyB1LCB2XHJcbiAgICAgICAgICAgIDIpOyAvLyB0aGUgc2l6ZSBvZiB0aGUgYXR0cmlidXRlXHJcbiAgICAgICAgICAgIGdlb21ldHJ5LmFkZEluZGV4KFswLCAxLCAyLCAwLCAyLCAzXSk7XHJcbiAgICAgICAgICAgIGNvbnN0IHZlcnRleFNyYyA9IGBcclxuICAgICAgICAgICAgcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7ICAgIFxyXG4gICAgICAgICAgICBhdHRyaWJ1dGUgdmVjMiBhVmVydGV4UG9zaXRpb247XHJcbiAgICAgICAgICAgIGF0dHJpYnV0ZSB2ZWMyIGFVdnM7ICAgIFxyXG4gICAgICAgICAgICB1bmlmb3JtIG1hdDMgdHJhbnNsYXRpb25NYXRyaXg7XHJcbiAgICAgICAgICAgIHVuaWZvcm0gbWF0MyBwcm9qZWN0aW9uTWF0cml4OyAgICBcclxuICAgICAgICAgICAgdmFyeWluZyB2ZWMyIHZVdnM7ICAgIFxyXG4gICAgICAgICAgICB2b2lkIG1haW4oKSB7ICAgIFxyXG4gICAgICAgICAgICAgICAgdlV2cyA9IGFVdnM7XHJcbiAgICAgICAgICAgICAgICBnbF9Qb3NpdGlvbiA9IHZlYzQoKHByb2plY3Rpb25NYXRyaXggKiB0cmFuc2xhdGlvbk1hdHJpeCAqIHZlYzMoYVZlcnRleFBvc2l0aW9uLCAxLjApKS54eSwgMC4wLCAxLjApOyAgICBcclxuICAgICAgICAgICAgfWA7XHJcbiAgICAgICAgICAgIGNvbnN0IGZyYWdtZW50U3JjID0gYCAgICBcclxuICAgICAgICAgICAgcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7ICAgIFxyXG4gICAgICAgICAgICB2YXJ5aW5nIHZlYzIgdlV2czsgICAgXHJcbiAgICAgICAgICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyMjtcclxuICAgICAgICAgICAgdW5pZm9ybSBmbG9hdCB0aW1lOyAgICBcclxuICAgICAgICAgICAgdm9pZCBtYWluKCkgeyAgICBcclxuICAgICAgICAgICAgICAgIGdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCh1U2FtcGxlcjIsIHZVdnMgKyBzaW4oICh0aW1lICsgKHZVdnMueCkgKiAxNC4pICkgKiAwLjEgKTtcclxuICAgICAgICAgICAgfWA7XHJcbiAgICAgICAgICAgIGNvbnN0IHVuaWZvcm1zID0ge1xyXG4gICAgICAgICAgICAgICAgdVNhbXBsZXIyOiB0aGlzLnBsYW5lVHh0LFxyXG4gICAgICAgICAgICAgICAgdGltZTogMCxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgbGV0IHByb2dyYW0gPSBuZXcgUHJvZ3JhbV8xLlByb2dyYW0odmVydGV4U3JjLCBmcmFnbWVudFNyYyk7XHJcbiAgICAgICAgICAgIGNvbnN0IHNoYWRlciA9IG5ldyBTaGFkZXJfMS5TaGFkZXIocHJvZ3JhbSwgdW5pZm9ybXMpO1xyXG4gICAgICAgICAgICB0aGlzLnRyaWFuZ2xlID0gbmV3IE1lc2hfMS5NZXNoKGdlb21ldHJ5LCBzaGFkZXIpO1xyXG4gICAgICAgICAgICB0aGlzLnRyaWFuZ2xlLnBvc2l0aW9uLnNldCg0MDAsIDMwMCk7XHJcbiAgICAgICAgICAgIHRoaXMudHJpYW5nbGUuc2NhbGUuc2V0KDIpO1xyXG4gICAgICAgICAgICB0aGlzLmFwcC5zdGFnZS5hZGRDaGlsZCh0aGlzLnRyaWFuZ2xlKTtcclxuICAgICAgICAgICAgdGhpcy5hcHAudGlja2VyLmFkZCh0aGlzLnJ1bkV4YW1wbGUpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5ydW5FeGFtcGxlID0gKGRlbHRhKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMudHJpYW5nbGUucm90YXRpb24gKz0gMC4wMTtcclxuICAgICAgICAgICAgdGhpcy50cmlhbmdsZS5zaGFkZXIudW5pZm9ybXMudGltZSArPSAwLjE7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLmxvYWRlciA9IG5ldyBSZXNvdXJjZUxvYWRlcl8xLlJlc291cmNlTG9hZGVyKG5ldyBVUkxSZXF1ZXN0XzEuVVJMUmVxdWVzdChcImV4YW1wbGVzL2Fzc2V0cy9iZ19zY2VuZV9yb3RhdGUuanBnXCIpKTtcclxuICAgICAgICB0aGlzLmxvYWRlci5hZGRFdmVudExpc3RlbmVyKEV2ZW50XzEuRXZlbnQuQ09NUExFVEUsIHRoaXMuaGFuZGxlUGxhbmVMb2FkZWQpO1xyXG4gICAgICAgIHRoaXMubG9hZGVyLmxvYWQoKTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLk1lc2hVbmlmb3JtcyA9IE1lc2hVbmlmb3JtcztcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgQmFzZUV4YW1wbGVfMSA9IHJlcXVpcmUoXCIuL0Jhc2VFeGFtcGxlXCIpO1xyXG5jb25zdCBSZXNvdXJjZUxvYWRlcl8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1Jlc291cmNlTG9hZGVyXCIpO1xyXG5jb25zdCBVUkxSZXF1ZXN0XzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvVVJMUmVxdWVzdFwiKTtcclxuY29uc3QgRXZlbnRfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9FdmVudFwiKTtcclxuY29uc3QgVGV4dHVyZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1RleHR1cmVcIik7XHJcbmNvbnN0IEJhc2VUZXh0dXJlXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvQmFzZVRleHR1cmVcIik7XHJcbmNvbnN0IFNwcml0ZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1Nwcml0ZVwiKTtcclxuY2xhc3MgU3ByaXRlQmFzaWMgZXh0ZW5kcyBCYXNlRXhhbXBsZV8xLkJhc2VFeGFtcGxlIHtcclxuICAgIGNvbnN0cnVjdG9yKGFwcCwgd2lkdGggPSAxMDAsIGhlaWdodCA9IDEwMCkge1xyXG4gICAgICAgIHN1cGVyKGFwcCwgd2lkdGgsIGhlaWdodCk7XHJcbiAgICAgICAgdGhpcy5oYW5kbGVSb3RhdGVMb2FkZWQgPSAoZXZlbnQpID0+IHtcclxuICAgICAgICAgICAgbGV0IHRleHR1cmUgPSBuZXcgVGV4dHVyZV8xLlRleHR1cmUobmV3IEJhc2VUZXh0dXJlXzEuQmFzZVRleHR1cmUodGhpcy5sb2FkZXIuaW1hZ2VEYXRhKSk7XHJcbiAgICAgICAgICAgIHRoaXMuYnVubnkgPSBuZXcgU3ByaXRlXzEuU3ByaXRlKHRleHR1cmUpO1xyXG4gICAgICAgICAgICB0aGlzLmJ1bm55LmFuY2hvci5zZXQoMC41KTtcclxuICAgICAgICAgICAgdGhpcy5idW5ueS54ID0gdGhpcy5zaXpldyAvIDI7XHJcbiAgICAgICAgICAgIHRoaXMuYnVubnkueSA9IHRoaXMuc2l6ZWggLyAyO1xyXG4gICAgICAgICAgICB0aGlzLnN0YWdlLmFkZENoaWxkKHRoaXMuYnVubnkpO1xyXG4gICAgICAgICAgICB0aGlzLmFwcC50aWNrZXIuYWRkKHRoaXMucnVuRXhhbXBsZSk7XHJcbiAgICAgICAgICAgIHRoaXMuZXhhbXBsZVJlYWR5KCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLnJ1bkV4YW1wbGUgPSAoZGVsdGEpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5idW5ueS5yb3RhdGlvbiArPSAwLjEgKiBkZWx0YTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuYmFja0NvbG9yID0gMHhGRkYwMDA7XHJcbiAgICAgICAgdGhpcy5sb2FkZXIgPSBuZXcgUmVzb3VyY2VMb2FkZXJfMS5SZXNvdXJjZUxvYWRlcihuZXcgVVJMUmVxdWVzdF8xLlVSTFJlcXVlc3QoXCJleGFtcGxlcy9hc3NldHMvYnVubnkucG5nXCIpKTtcclxuICAgICAgICB0aGlzLmxvYWRlci5hZGRFdmVudExpc3RlbmVyKEV2ZW50XzEuRXZlbnQuQ09NUExFVEUsIHRoaXMuaGFuZGxlUm90YXRlTG9hZGVkKTtcclxuICAgICAgICB0aGlzLmxvYWRlci5sb2FkKCk7XHJcbiAgICB9XHJcbiAgICBkZXN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyLmRlc3RydWN0b3IoKTtcclxuICAgICAgICB0aGlzLmFwcC50aWNrZXIucmVtb3ZlKHRoaXMucnVuRXhhbXBsZSwgbnVsbCk7XHJcbiAgICAgICAgdGhpcy5idW5ueS5kZXN0cm95KG51bGwpO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuU3ByaXRlQmFzaWMgPSBTcHJpdGVCYXNpYztcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgQmFzZUV4YW1wbGVfMSA9IHJlcXVpcmUoXCIuL0Jhc2VFeGFtcGxlXCIpO1xyXG5jb25zdCBSZXNvdXJjZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1Jlc291cmNlXCIpO1xyXG5jb25zdCBCYXNlVGV4dHVyZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0Jhc2VUZXh0dXJlXCIpO1xyXG5jb25zdCBUZXh0dXJlXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvVGV4dHVyZVwiKTtcclxuY29uc3QgU3ByaXRlXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvU3ByaXRlXCIpO1xyXG5jbGFzcyBUZXh0dXJlR3JhZGllbnRSZXNvdXJjZSBleHRlbmRzIEJhc2VFeGFtcGxlXzEuQmFzZUV4YW1wbGUge1xyXG4gICAgY29uc3RydWN0b3IoYXBwLCB3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICAgICAgc3VwZXIoYXBwLCB3aWR0aCwgaGVpZ2h0KTtcclxuICAgICAgICBjb25zdCBncmFkQmFzZVRleHR1cmUgPSBuZXcgQmFzZVRleHR1cmVfMS5CYXNlVGV4dHVyZShuZXcgR3JhZGllbnRSZXNvdXJjZSgpKTtcclxuICAgICAgICBncmFkQmFzZVRleHR1cmUuc2V0U2l6ZSg1MDAsIDUwKTtcclxuICAgICAgICBjb25zdCBncmFkVGV4dHVyZSA9IG5ldyBUZXh0dXJlXzEuVGV4dHVyZShncmFkQmFzZVRleHR1cmUpO1xyXG4gICAgICAgIGNvbnN0IHNwcml0ZSA9IG5ldyBTcHJpdGVfMS5TcHJpdGUoZ3JhZFRleHR1cmUpO1xyXG4gICAgICAgIHNwcml0ZS5wb3NpdGlvbi5zZXQoMTAwLCAxMDApO1xyXG4gICAgICAgIHNwcml0ZS5yb3RhdGlvbiA9IE1hdGguUEkgLyA4O1xyXG4gICAgICAgIHRoaXMuc3RhZ2UuYWRkQ2hpbGQoc3ByaXRlKTtcclxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5leGFtcGxlUmVhZHkoKTtcclxuICAgICAgICB9LCAxMDAwKTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLlRleHR1cmVHcmFkaWVudFJlc291cmNlID0gVGV4dHVyZUdyYWRpZW50UmVzb3VyY2U7XHJcbmNsYXNzIEdyYWRpZW50UmVzb3VyY2UgZXh0ZW5kcyBSZXNvdXJjZV8xLlJlc291cmNlIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKDI1NiwgMTAwKTtcclxuICAgICAgICB0aGlzLmNhblVwbG9hZCA9IHRydWU7XHJcbiAgICB9XHJcbiAgICB1cGxvYWQocmVuZGVyZXIsIGJhc2VUZXh0dXJlLCBnbFRleHR1cmUpIHtcclxuICAgICAgICBjb25zdCB7IHdpZHRoIH0gPSB0aGlzOyAvLyBkZWZhdWx0IHNpemUgb3IgZnJvbSBiYXNlVGV4dHVyZT9cclxuICAgICAgICBjb25zdCB7IGhlaWdodCB9ID0gdGhpczsgLy8geW91ciBjaG9pY2UuXHJcbiAgICAgICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XHJcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBjYW52YXM7XHJcbiAgICAgICAgdGhpcy5zb3VyY2Uud2lkdGggPSB3aWR0aDtcclxuICAgICAgICB0aGlzLnNvdXJjZS5oZWlnaHQgPSBoZWlnaHQ7XHJcbiAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5zb3VyY2UuZ2V0Q29udGV4dCgnMmQnKTtcclxuICAgICAgICBjb25zdCBncmQgPSBjdHguY3JlYXRlTGluZWFyR3JhZGllbnQoMCwgMCwgd2lkdGgsIDApO1xyXG4gICAgICAgIGdyZC5hZGRDb2xvclN0b3AoMCwgJ3JnYmEoMjU1LCAyNTUsIDI1NSwgMC4wKScpO1xyXG4gICAgICAgIGdyZC5hZGRDb2xvclN0b3AoMC4zLCAnY3lhbicpO1xyXG4gICAgICAgIGdyZC5hZGRDb2xvclN0b3AoMC43LCAncmVkJyk7XHJcbiAgICAgICAgZ3JkLmFkZENvbG9yU3RvcCgxLCAnZ3JlZW4nKTtcclxuICAgICAgICBjdHguZmlsbFN0eWxlID0gZ3JkO1xyXG4gICAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcclxuICAgICAgICBnbFRleHR1cmUud2lkdGggPSB3aWR0aDtcclxuICAgICAgICBnbFRleHR1cmUuaGVpZ2h0ID0gaGVpZ2h0O1xyXG4gICAgICAgIGNvbnN0IHsgZ2wgfSA9IHJlbmRlcmVyO1xyXG4gICAgICAgIGdsLnBpeGVsU3RvcmVpKGdsLlVOUEFDS19QUkVNVUxUSVBMWV9BTFBIQV9XRUJHTCwgYmFzZVRleHR1cmUucHJlbXVsdGlwbHlBbHBoYSk7XHJcbiAgICAgICAgZ2wudGV4SW1hZ2UyRChiYXNlVGV4dHVyZS50YXJnZXQsIDAsIGJhc2VUZXh0dXJlLmZvcm1hdCwgYmFzZVRleHR1cmUuZm9ybWF0LCBiYXNlVGV4dHVyZS50eXBlLCB0aGlzLnNvdXJjZSk7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbn1cclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgQmFzZUV4YW1wbGVfMSA9IHJlcXVpcmUoXCIuL0Jhc2VFeGFtcGxlXCIpO1xyXG5jb25zdCBSZXNvdXJjZUxvYWRlcl8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1Jlc291cmNlTG9hZGVyXCIpO1xyXG5jb25zdCBVUkxSZXF1ZXN0XzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvVVJMUmVxdWVzdFwiKTtcclxuY29uc3QgRXZlbnRfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9FdmVudFwiKTtcclxuY29uc3QgVGV4dHVyZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1RleHR1cmVcIik7XHJcbmNvbnN0IEJhc2VUZXh0dXJlXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvQmFzZVRleHR1cmVcIik7XHJcbmNvbnN0IENvbnRhaW5lcl8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0NvbnRhaW5lclwiKTtcclxuY29uc3QgU3ByaXRlXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvU3ByaXRlXCIpO1xyXG5jb25zdCBXZWJHTFNldHRpbmdzXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvV2ViR0xTZXR0aW5nc1wiKTtcclxuY29uc3QgQmFzZVJlbmRlclRleHR1cmVfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9CYXNlUmVuZGVyVGV4dHVyZVwiKTtcclxuY29uc3QgUmVuZGVyVGV4dHVyZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1JlbmRlclRleHR1cmVcIik7XHJcbmNsYXNzIFRleHR1cmVSZW5kZXIgZXh0ZW5kcyBCYXNlRXhhbXBsZV8xLkJhc2VFeGFtcGxlIHtcclxuICAgIGNvbnN0cnVjdG9yKGFwcCwgd2lkdGgsIGhlaWdodCkge1xyXG4gICAgICAgIHN1cGVyKGFwcCwgd2lkdGgsIGhlaWdodCk7XHJcbiAgICAgICAgdGhpcy5oYW5kbGVSZXNvdXJjZUxvYWRlZCA9IChldmVudCkgPT4ge1xyXG4gICAgICAgICAgICBsZXQgdHh0ID0gbmV3IFRleHR1cmVfMS5UZXh0dXJlKG5ldyBCYXNlVGV4dHVyZV8xLkJhc2VUZXh0dXJlKHRoaXMubG9hZGVyLmltYWdlRGF0YSkpO1xyXG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lciA9IG5ldyBDb250YWluZXJfMS5Db250YWluZXIoKTtcclxuICAgICAgICAgICAgdGhpcy5zdGFnZS5hZGRDaGlsZCh0aGlzLmNvbnRhaW5lcik7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMjU7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYnVubnkgPSBuZXcgU3ByaXRlXzEuU3ByaXRlKHR4dCk7XHJcbiAgICAgICAgICAgICAgICBidW5ueS54ID0gKGkgJSA1KSAqIDMwO1xyXG4gICAgICAgICAgICAgICAgYnVubnkueSA9IE1hdGguZmxvb3IoaSAvIDUpICogMzA7XHJcbiAgICAgICAgICAgICAgICBidW5ueS5yb3RhdGlvbiA9IE1hdGgucmFuZG9tKCkgKiAoTWF0aC5QSSAqIDIpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb250YWluZXIuYWRkQ2hpbGQoYnVubnkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGJydCA9IG5ldyBCYXNlUmVuZGVyVGV4dHVyZV8xLkJhc2VSZW5kZXJUZXh0dXJlKDMwMCwgMzAwLCBXZWJHTFNldHRpbmdzXzEuV2ViR0xTZXR0aW5ncy5TQ0FMRV9NT0RFUy5MSU5FQVIsIDEpO1xyXG4gICAgICAgICAgICB0aGlzLnJ0ID0gbmV3IFJlbmRlclRleHR1cmVfMS5SZW5kZXJUZXh0dXJlKGJydCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHNwcml0ZSA9IG5ldyBTcHJpdGVfMS5TcHJpdGUodGhpcy5ydCk7XHJcbiAgICAgICAgICAgIHNwcml0ZS54ID0gNDUwO1xyXG4gICAgICAgICAgICBzcHJpdGUueSA9IDYwO1xyXG4gICAgICAgICAgICB0aGlzLnN0YWdlLmFkZENoaWxkKHNwcml0ZSk7XHJcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLnggPSAxMDA7XHJcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLnkgPSA2MDtcclxuICAgICAgICAgICAgdGhpcy5hcHAudGlja2VyLmFkZCh0aGlzLnJ1bkV4YW1wbGUpO1xyXG4gICAgICAgICAgICB0aGlzLmV4YW1wbGVSZWFkeSgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5ydW5FeGFtcGxlID0gKGRlbHRhKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuYXBwLnJlbmRlcmVyLnJlbmRlcih0aGlzLmNvbnRhaW5lciwgdGhpcy5ydCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLmxvYWRlciA9IG5ldyBSZXNvdXJjZUxvYWRlcl8xLlJlc291cmNlTG9hZGVyKG5ldyBVUkxSZXF1ZXN0XzEuVVJMUmVxdWVzdChcImV4YW1wbGVzL2Fzc2V0cy9idW5ueS5wbmdcIikpO1xyXG4gICAgICAgIHRoaXMubG9hZGVyLmFkZEV2ZW50TGlzdGVuZXIoRXZlbnRfMS5FdmVudC5DT01QTEVURSwgdGhpcy5oYW5kbGVSZXNvdXJjZUxvYWRlZCk7XHJcbiAgICAgICAgdGhpcy5sb2FkZXIubG9hZCgpO1xyXG4gICAgfVxyXG4gICAgZGVzdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlci5kZXN0cnVjdG9yKCk7XHJcbiAgICAgICAgdGhpcy5hcHAudGlja2VyLnJlbW92ZSh0aGlzLnJ1bkV4YW1wbGUsIG51bGwpO1xyXG4gICAgICAgIHRoaXMuY29udGFpbmVyLmRlc3Ryb3kobnVsbCk7XHJcbiAgICAgICAgdGhpcy5jb250YWluZXIgPSBudWxsO1xyXG4gICAgICAgIHRoaXMucnQuZGVzdHJveShudWxsKTtcclxuICAgICAgICB0aGlzLnJ0ID0gbnVsbDtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLlRleHR1cmVSZW5kZXIgPSBUZXh0dXJlUmVuZGVyO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBCYXNlRXhhbXBsZV8xID0gcmVxdWlyZShcIi4vQmFzZUV4YW1wbGVcIik7XHJcbmNvbnN0IFJlc291cmNlTG9hZGVyXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvUmVzb3VyY2VMb2FkZXJcIik7XHJcbmNvbnN0IFVSTFJlcXVlc3RfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9VUkxSZXF1ZXN0XCIpO1xyXG5jb25zdCBFdmVudF8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0V2ZW50XCIpO1xyXG5jb25zdCBUZXh0dXJlXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvVGV4dHVyZVwiKTtcclxuY29uc3QgQmFzZVRleHR1cmVfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9CYXNlVGV4dHVyZVwiKTtcclxuY29uc3QgR3JvdXBEOF8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0dyb3VwRDhcIik7XHJcbmNvbnN0IFJlY3RhbmdsZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1JlY3RhbmdsZVwiKTtcclxuY29uc3QgU3ByaXRlXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvU3ByaXRlXCIpO1xyXG5jb25zdCBUZXh0XzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvVGV4dFwiKTtcclxuY2xhc3MgVGV4dHVyZVJvdGF0ZSBleHRlbmRzIEJhc2VFeGFtcGxlXzEuQmFzZUV4YW1wbGUge1xyXG4gICAgY29uc3RydWN0b3IoYXBwLCB3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICAgICAgc3VwZXIoYXBwLCB3aWR0aCwgaGVpZ2h0KTtcclxuICAgICAgICB0aGlzLmhhbmRsZVJlc291cmNlTG9hZGVkID0gKGV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgIGxldCB0eHQgPSBuZXcgVGV4dHVyZV8xLlRleHR1cmUobmV3IEJhc2VUZXh0dXJlXzEuQmFzZVRleHR1cmUodGhpcy5sb2FkZXIuaW1hZ2VEYXRhKSk7XHJcbiAgICAgICAgICAgIGNvbnN0IHRleHR1cmVzID0gW3R4dF07XHJcbiAgICAgICAgICAgIGNvbnN0IEQ4ID0gR3JvdXBEOF8xLkdyb3VwRDg7XHJcbiAgICAgICAgICAgIGZvciAobGV0IHJvdGF0ZSA9IDE7IHJvdGF0ZSA8IDE2OyByb3RhdGUrKykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaCA9IEQ4LmlzVmVydGljYWwocm90YXRlKSA/IHR4dC5mcmFtZS53aWR0aCA6IHR4dC5mcmFtZS5oZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB3ID0gRDguaXNWZXJ0aWNhbChyb3RhdGUpID8gdHh0LmZyYW1lLmhlaWdodCA6IHR4dC5mcmFtZS53aWR0aDtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHsgZnJhbWUgfSA9IHR4dDtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNyb3AgPSBuZXcgUmVjdGFuZ2xlXzEuUmVjdGFuZ2xlKHR4dC5mcmFtZS54LCB0eHQuZnJhbWUueSwgdywgaCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0cmltID0gY3JvcDtcclxuICAgICAgICAgICAgICAgIGxldCByb3RhdGVkVGV4dHVyZTtcclxuICAgICAgICAgICAgICAgIGlmIChyb3RhdGUgJSAyID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcm90YXRlZFRleHR1cmUgPSBuZXcgVGV4dHVyZV8xLlRleHR1cmUodHh0LmJhc2VUZXh0dXJlLCBmcmFtZSwgY3JvcCwgdHJpbSwgcm90YXRlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJvdGF0ZWRUZXh0dXJlID0gbmV3IFRleHR1cmVfMS5UZXh0dXJlKHR4dC5iYXNlVGV4dHVyZSwgZnJhbWUsIGNyb3AsIHRyaW0sIHJvdGF0ZSAtIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJvdGF0ZWRUZXh0dXJlLnJvdGF0ZSsrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGV4dHVyZXMucHVzaChyb3RhdGVkVGV4dHVyZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0WCA9IHRoaXMuc2l6ZXcgLyAxNiB8IDA7XHJcbiAgICAgICAgICAgIGNvbnN0IG9mZnNldFkgPSB0aGlzLnNpemVoIC8gOCB8IDA7XHJcbiAgICAgICAgICAgIGNvbnN0IGdyaWRXID0gdGhpcy5zaXpldyAvIDQgfCAwO1xyXG4gICAgICAgICAgICBjb25zdCBncmlkSCA9IHRoaXMuc2l6ZWggLyA1IHwgMDtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBkdWRlID0gbmV3IFNwcml0ZV8xLlNwcml0ZSh0ZXh0dXJlc1tpIDwgOCA/IGkgKiAyIDogKGkgLSA4KSAqIDIgKyAxXSk7XHJcbiAgICAgICAgICAgICAgICBkdWRlLnNjYWxlLnggPSAwLjU7XHJcbiAgICAgICAgICAgICAgICBkdWRlLnNjYWxlLnkgPSAwLjU7XHJcbiAgICAgICAgICAgICAgICBkdWRlLnggPSBvZmZzZXRYICsgZ3JpZFcgKiAoaSAlIDQpO1xyXG4gICAgICAgICAgICAgICAgZHVkZS55ID0gb2Zmc2V0WSArIGdyaWRIICogKGkgLyA0IHwgMCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0YWdlLmFkZENoaWxkKGR1ZGUpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdGV4dCA9IG5ldyBUZXh0XzEuVGV4dChgcm90YXRlID0gJHtkdWRlLnRleHR1cmUucm90YXRlfWAsIHtcclxuICAgICAgICAgICAgICAgICAgICBmb250RmFtaWx5OiAnQ291cmllciBOZXcnLCBmb250U2l6ZTogJzEycHgnLCBmaWxsOiAnd2hpdGUnLCBhbGlnbjogJ2xlZnQnLFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB0ZXh0LnggPSBkdWRlLng7XHJcbiAgICAgICAgICAgICAgICB0ZXh0LnkgPSBkdWRlLnkgLSAyMDtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3RhZ2UuYWRkQ2hpbGQodGV4dCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5leGFtcGxlUmVhZHkoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMubG9hZGVyID0gbmV3IFJlc291cmNlTG9hZGVyXzEuUmVzb3VyY2VMb2FkZXIobmV3IFVSTFJlcXVlc3RfMS5VUkxSZXF1ZXN0KFwiZXhhbXBsZXMvYXNzZXRzL2Zsb3dlclRvcC5wbmdcIikpO1xyXG4gICAgICAgIHRoaXMubG9hZGVyLmFkZEV2ZW50TGlzdGVuZXIoRXZlbnRfMS5FdmVudC5DT01QTEVURSwgdGhpcy5oYW5kbGVSZXNvdXJjZUxvYWRlZCk7XHJcbiAgICAgICAgdGhpcy5sb2FkZXIubG9hZCgpO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuVGV4dHVyZVJvdGF0ZSA9IFRleHR1cmVSb3RhdGU7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IENvbnRhaW5lcl8xID0gcmVxdWlyZShcIi4uLy4uL3Jhdy1waXhpLXRzL0NvbnRhaW5lclwiKTtcclxuY29uc3QgR3JhcGhpY3NfMSA9IHJlcXVpcmUoXCIuLi8uLi9yYXctcGl4aS10cy9HcmFwaGljc1wiKTtcclxuY29uc3QgRXhhbXBsZUxpc3RfMSA9IHJlcXVpcmUoXCIuL0V4YW1wbGVMaXN0XCIpO1xyXG5jb25zdCBUZXh0dXJlUm90YXRlXzEgPSByZXF1aXJlKFwiLi4vVGV4dHVyZVJvdGF0ZVwiKTtcclxuY29uc3QgVGV4dHVyZVJlbmRlcl8xID0gcmVxdWlyZShcIi4uL1RleHR1cmVSZW5kZXJcIik7XHJcbmNvbnN0IFRleHR1cmVHcmFkaWVudFJlc291cmNlXzEgPSByZXF1aXJlKFwiLi4vVGV4dHVyZUdyYWRpZW50UmVzb3VyY2VcIik7XHJcbmNvbnN0IEZpbHRlckJsdXJfMSA9IHJlcXVpcmUoXCIuLi9GaWx0ZXJCbHVyXCIpO1xyXG5jb25zdCBGaWx0ZXJDb2xvcl8xID0gcmVxdWlyZShcIi4uL0ZpbHRlckNvbG9yXCIpO1xyXG5jb25zdCBGaWx0ZXJDcmF3bGllc18xID0gcmVxdWlyZShcIi4uL0ZpbHRlckNyYXdsaWVzXCIpO1xyXG5jb25zdCBGaWx0ZXJGbGFnXzEgPSByZXF1aXJlKFwiLi4vRmlsdGVyRmxhZ1wiKTtcclxuY29uc3QgTWFza0ZpbHRlcl8xID0gcmVxdWlyZShcIi4uL01hc2tGaWx0ZXJcIik7XHJcbmNvbnN0IFNwcml0ZUJhc2ljXzEgPSByZXF1aXJlKFwiLi4vU3ByaXRlQmFzaWNcIik7XHJcbmNvbnN0IEZpbHRlckJsZW5kaW5nXzEgPSByZXF1aXJlKFwiLi4vRmlsdGVyQmxlbmRpbmdcIik7XHJcbmNvbnN0IEZpbHRlckN1c3RvbV8xID0gcmVxdWlyZShcIi4uL0ZpbHRlckN1c3RvbVwiKTtcclxuY29uc3QgRmlsdGVyU2hhZG93XzEgPSByZXF1aXJlKFwiLi4vRmlsdGVyU2hhZG93XCIpO1xyXG5jb25zdCBNZXNoQmFzaWNfMSA9IHJlcXVpcmUoXCIuLi9NZXNoQmFzaWNcIik7XHJcbmNvbnN0IE1lc2hBZHZhbmNlZF8xID0gcmVxdWlyZShcIi4uL01lc2hBZHZhbmNlZFwiKTtcclxuY29uc3QgTWVzaFRyaWFuZ2xlXzEgPSByZXF1aXJlKFwiLi4vTWVzaFRyaWFuZ2xlXCIpO1xyXG5jb25zdCBNZXNoQ29sb3JlZFRyaWFuZ2xlXzEgPSByZXF1aXJlKFwiLi4vTWVzaENvbG9yZWRUcmlhbmdsZVwiKTtcclxuY29uc3QgTWVzaFRleHR1cmVkXzEgPSByZXF1aXJlKFwiLi4vTWVzaFRleHR1cmVkXCIpO1xyXG5jb25zdCBNZXNoVW5pZm9ybXNfMSA9IHJlcXVpcmUoXCIuLi9NZXNoVW5pZm9ybXNcIik7XHJcbmNvbnN0IE1lc2hHZW9tZXRyeV8xID0gcmVxdWlyZShcIi4uL01lc2hHZW9tZXRyeVwiKTtcclxuY29uc3QgTWVzaFNoYWRlcl8xID0gcmVxdWlyZShcIi4uL01lc2hTaGFkZXJcIik7XHJcbmNvbnN0IEV2ZW50XzEgPSByZXF1aXJlKFwiLi4vLi4vcmF3LXBpeGktdHMvRXZlbnRcIik7XHJcbmNsYXNzIEV4YW1wbGVEaXNwbGF5IGV4dGVuZHMgQ29udGFpbmVyXzEuQ29udGFpbmVyIHtcclxuICAgIGNvbnN0cnVjdG9yKGFwcCwgZGlzcGxheVdpZHRoLCBkaXNwbGF5aGVpZ2h0KSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLmhhbmRsZUV4YW1wbGVSZXF1ZXN0ID0gKGV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0RXhhbXBsZSh0aGlzLmxpc3Quc2VsZWN0ZWRDbGFzcyk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLmhhbmRsZUNvbXBsZXRlID0gKGV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMubGlzdC5hZGRFdmVudExpc3RlbmVyKEV2ZW50XzEuRXZlbnQuQ0hBTkdFLCB0aGlzLmhhbmRsZUV4YW1wbGVSZXF1ZXN0KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIGxldCBjb250cm9sU2l6ZSA9IDIwMDtcclxuICAgICAgICB0aGlzLmFwcCA9IGFwcDtcclxuICAgICAgICB0aGlzLmJhY2tncm91bmQgPSBuZXcgR3JhcGhpY3NfMS5HcmFwaGljcygpO1xyXG4gICAgICAgIHRoaXMucmVmcmVzaEJhY2tncm91bmQoMHg5Njk2OTYpO1xyXG4gICAgICAgIGFwcC5zdGFnZS5hZGRDaGlsZCh0aGlzLmJhY2tncm91bmQpO1xyXG4gICAgICAgIHRoaXMuc3RhZ2VMYXllciA9IG5ldyBDb250YWluZXJfMS5Db250YWluZXIoKTtcclxuICAgICAgICBhcHAuc3RhZ2UuYWRkQ2hpbGQodGhpcy5zdGFnZUxheWVyKTtcclxuICAgICAgICB0aGlzLmxpc3QgPSBuZXcgRXhhbXBsZUxpc3RfMS5FeGFtcGxlTGlzdChjb250cm9sU2l6ZSwgZGlzcGxheWhlaWdodCk7XHJcbiAgICAgICAgdGhpcy5saXN0LnggPSBkaXNwbGF5V2lkdGggLSBjb250cm9sU2l6ZTtcclxuICAgICAgICBkaXNwbGF5V2lkdGggPSBkaXNwbGF5V2lkdGggLSBjb250cm9sU2l6ZTtcclxuICAgICAgICBhcHAuc3RhZ2UuYWRkQ2hpbGQodGhpcy5saXN0KTtcclxuICAgICAgICB0aGlzLmNvbnRyb2xMYXllciA9IG5ldyBDb250YWluZXJfMS5Db250YWluZXIoKTtcclxuICAgICAgICBhcHAuc3RhZ2UuYWRkQ2hpbGQodGhpcy5jb250cm9sTGF5ZXIpO1xyXG4gICAgICAgIHRoaXMuZnJhbWVzaXplID0gNTtcclxuICAgICAgICB0aGlzLmV4YW1wbGVXaWR0aCA9IGRpc3BsYXlXaWR0aDsgLy8oZGlzcGxheVdpZHRoIC0gY29udHJvbFNpemUpIC0gKHRoaXMuZnJhbWVzaXplIC8gMilcclxuICAgICAgICB0aGlzLmV4YW1wbGVoZWlnaHQgPSBkaXNwbGF5aGVpZ2h0IC0gKHRoaXMuZnJhbWVzaXplIC8gMik7XHJcbiAgICAgICAgdGhpcy5mcmFtZSA9IG5ldyBHcmFwaGljc18xLkdyYXBoaWNzKCk7XHJcbiAgICAgICAgdGhpcy5mcmFtZS5iZWdpbkZpbGwoMHgwMDBGRkYpO1xyXG4gICAgICAgIHRoaXMuZnJhbWUuZHJhd1JlY3QoMCwgMCwgdGhpcy5mcmFtZXNpemUsIGRpc3BsYXloZWlnaHQpO1xyXG4gICAgICAgIHRoaXMuZnJhbWUuZHJhd1JlY3QoZGlzcGxheVdpZHRoIC0gdGhpcy5mcmFtZXNpemUsIDAsIDUsIGRpc3BsYXloZWlnaHQpO1xyXG4gICAgICAgIHRoaXMuZnJhbWUuZHJhd1JlY3QodGhpcy5mcmFtZXNpemUsIDAsIGRpc3BsYXlXaWR0aCAtICh0aGlzLmZyYW1lc2l6ZSAqIDIpLCB0aGlzLmZyYW1lc2l6ZSk7XHJcbiAgICAgICAgdGhpcy5mcmFtZS5kcmF3UmVjdCh0aGlzLmZyYW1lc2l6ZSwgZGlzcGxheWhlaWdodCAtIHRoaXMuZnJhbWVzaXplLCBkaXNwbGF5V2lkdGggLSAodGhpcy5mcmFtZXNpemUgKiAyKSwgdGhpcy5mcmFtZXNpemUpO1xyXG4gICAgICAgIHRoaXMuY29udHJvbExheWVyLmFkZENoaWxkKHRoaXMuZnJhbWUpO1xyXG4gICAgICAgIC8vIHRoaXMubGlzdC5hZGRFeGFtcGxlKFwiU3ByaXRlIEJhc2ljXCIsIFNwcml0ZUJhc2ljKTtcclxuICAgICAgICAvLyB0aGlzLmxpc3QuYWRkRXhhbXBsZShcIlNwcml0ZSBSZXZlYWxcIiwgQWR2YW5jZWRDYXJkKTtcclxuICAgICAgICAvLyB0aGlzLmxpc3QuYWRkRXhhbXBsZShcIlNwcml0ZSBTbG90c1wiLCBBZHZhbmNlZFNsb3RzKTtcclxuICAgICAgICAvLyB0aGlzLmxpc3QuYWRkRXhhbXBsZShcIlNwcml0ZSBUcmFpbFwiLCBBZHZhbmNlZFRyYWlsKTtcclxuICAgICAgICAvLyB0aGlzLmxpc3QuYWRkRXhhbXBsZShcIlNwcml0ZSBXYXJwXCIsIEFkdmFuY2VkV2FycCk7ICBcclxuICAgICAgICAvLyB0aGlzLmxpc3QuYWRkRXhhbXBsZShcIlNwcml0ZSBCbGVuZFwiLCBCYXNpY0JsZW5kKTtcclxuICAgICAgICAvLyB0aGlzLmxpc3QuYWRkRXhhbXBsZShcIlNwcml0ZSBUaW50aW5nXCIsIEJhc2ljVGludGluZyk7XHJcbiAgICAgICAgLy8gdGhpcy5saXN0LmFkZEV4YW1wbGUoXCJTcHJpdGUgVmlkZW9cIiwgU3ByaXRlVmlkZW8pO1xyXG4gICAgICAgIC8vIHRoaXMubGlzdC5hZGRFeGFtcGxlKFwiU3ByaXRlIFRpbGluZ1wiLCBTcHJpdGVUaWxpbmcpO1xyXG4gICAgICAgIC8vIHRoaXMubGlzdC5hZGRFeGFtcGxlKFwiU3ByaXRlIEFuaW1hdGlvblwiLCBTcHJpdGVFeHBsb3Npb24pO1xyXG4gICAgICAgIC8vIHRoaXMubGlzdC5hZGRFeGFtcGxlKFwiU3ByaXRlIEFuaW1hdGlvbiAyXCIsIFNwcml0ZWpldCk7XHJcbiAgICAgICAgLy8gdGhpcy5saXN0LmFkZEV4YW1wbGUoXCJTcHJpdGUgQW5pbWF0aW9uIDNcIiwgU3ByaXRlU3BlZWQpO1xyXG4gICAgICAgIC8vIHRoaXMubGlzdC5hZGRFeGFtcGxlKFwiR3JhcGhpY3MgQmFzaWNcIiwgR3JhcGhpY3NTaW1wbGUpO1xyXG4gICAgICAgIC8vIHRoaXMubGlzdC5hZGRFeGFtcGxlKFwiR3JhcGhpY3MgQWR2YW5jZWRcIiwgR3JhcGhpY3NBZHZhbmNlZCk7XHJcbiAgICAgICAgLy8gdGhpcy5saXN0LmFkZEV4YW1wbGUoXCJHcmFwaGljcyBEeW5hbWljXCIsIEdyYXBoaWNzRHluYW1pYyk7XHJcbiAgICAgICAgLy8gdGhpcy5saXN0LmFkZEV4YW1wbGUoXCJDb250YWluZXJcIiwgQmFzaWNDb250YWluZXIpO1xyXG4gICAgICAgIC8vIHRoaXMubGlzdC5hZGRFeGFtcGxlKFwiTWFzayBHcmFwaGljc1wiLCBNYXNrR3JhcGhpY3MpO1xyXG4gICAgICAgIC8vIHRoaXMubGlzdC5hZGRFeGFtcGxlKFwiTWFzayBTcHJpdGVcIiwgTWFza1Nwcml0ZSk7XHJcbiAgICAgICAgLy8gdGhpcy5saXN0LmFkZEV4YW1wbGUoXCJQYXJ0aWNsZXNcIiwgQmFzaWNQYXJ0aWNsZXMpO1xyXG4gICAgICAgIC8vIHRoaXMubGlzdC5hZGRFeGFtcGxlKFwiVGV4dFwiLCBUZXh0QmFzZSk7XHJcbiAgICAgICAgLy8gdGhpcy5saXN0LmFkZEV4YW1wbGUoXCJUZXh0IEJpdG1hcFwiLCBUZXh0Qml0bWFwKTtcclxuICAgICAgICAvLyB0aGlzLmxpc3QuYWRkRXhhbXBsZShcIlRleHQgV2ViRm9udFwiLCBUZXh0V2ViRm9udCk7XHJcbiAgICAgICAgLy8gdGhpcy5saXN0LmFkZEV4YW1wbGUoXCJJbnRlcmFjdGlvblwiLCBJbnRlcmFjdGlvbkludGVyYWN0aXZpdHkpO1xyXG4gICAgICAgIC8vIHRoaXMubGlzdC5hZGRFeGFtcGxlKFwiSW50ZXJhY3Rpb24gQ2xpY2tcIiwgSW50ZXJhY3Rpb25DbGljayk7ICBcclxuICAgICAgICAvLyB0aGlzLmxpc3QuYWRkRXhhbXBsZShcIkludGVyYWN0aW9uIERyYWdcIiwgSW50ZXJhY3Rpb25EcmFnZ2luZyk7XHJcbiAgICAgICAgLy8gdGhpcy5saXN0LmFkZEV4YW1wbGUoXCJJbnRlcmFjdGlvbiBJY29uXCIsIEludGVyYWN0aW9uSWNvbik7ICAgIFxyXG4gICAgICAgIC8vIHRoaXMubGlzdC5hZGRFeGFtcGxlKFwidGV4dHVyZSBTd2FwXCIsIFNwcml0ZVN3YXApO1xyXG4gICAgICAgIC8vIHRoaXMubGlzdC5hZGRFeGFtcGxlKFwiVGV4dHVyZSBBZHZhbmNlZFwiLCBUZXh0dXJlQWR2YW5jZWQpO1xyXG4gICAgICAgIC8vIHRoaXMubGlzdC5hZGRFeGFtcGxlKFwiVGV4dHVyZSBHcmFkaWVudFwiLCBUZXh0dXJlR3JhZGllbnRCYXNpYyk7XHJcbiAgICAgICAgdGhpcy5saXN0LmFkZEV4YW1wbGUoXCJUZXh0dXJlIEdyYWRpZW50IDJcIiwgVGV4dHVyZUdyYWRpZW50UmVzb3VyY2VfMS5UZXh0dXJlR3JhZGllbnRSZXNvdXJjZSk7XHJcbiAgICAgICAgdGhpcy5saXN0LmFkZEV4YW1wbGUoXCJUZXh0dXJlIFJvdGF0ZVwiLCBUZXh0dXJlUm90YXRlXzEuVGV4dHVyZVJvdGF0ZSk7XHJcbiAgICAgICAgdGhpcy5saXN0LmFkZEV4YW1wbGUoXCJUZXh0dXJlIFJlbmRlclwiLCBUZXh0dXJlUmVuZGVyXzEuVGV4dHVyZVJlbmRlcik7XHJcbiAgICAgICAgdGhpcy5saXN0LmFkZEV4YW1wbGUoXCJGaWx0ZXIgQmx1clwiLCBGaWx0ZXJCbHVyXzEuRmlsdGVyQmx1cik7XHJcbiAgICAgICAgdGhpcy5saXN0LmFkZEV4YW1wbGUoXCJGaWx0ZXIgQ29sb3JNYXRyaXhcIiwgRmlsdGVyQ29sb3JfMS5GaWx0ZXJDb2xvcik7XHJcbiAgICAgICAgdGhpcy5saXN0LmFkZEV4YW1wbGUoXCJGaWx0ZXIgRGlzcGxhY2VtZW50XCIsIEZpbHRlckNyYXdsaWVzXzEuRmlsdGVyQ3Jhd2xpZXMpO1xyXG4gICAgICAgIHRoaXMubGlzdC5hZGRFeGFtcGxlKFwiRmlsdGVyIERpc3BsYWNlbWVudCAyXCIsIEZpbHRlckZsYWdfMS5GaWx0ZXJGbGFnKTtcclxuICAgICAgICB0aGlzLmxpc3QuYWRkRXhhbXBsZShcIkZpbHRlciBCbHVyIDJcIiwgTWFza0ZpbHRlcl8xLk1hc2tGaWx0ZXIpO1xyXG4gICAgICAgIHRoaXMubGlzdC5hZGRFeGFtcGxlKFwiRmlsdGVyIEJsZW5kaW5nXCIsIEZpbHRlckJsZW5kaW5nXzEuRmlsdGVyQmxlbmRpbmcpO1xyXG4gICAgICAgIHRoaXMubGlzdC5hZGRFeGFtcGxlKFwiRmlsdGVyIEN1c3RvbVwiLCBGaWx0ZXJDdXN0b21fMS5GaWx0ZXJDdXN0b20pO1xyXG4gICAgICAgIHRoaXMubGlzdC5hZGRFeGFtcGxlKFwiRmlsdGVyIFNoYWRvd1wiLCBGaWx0ZXJTaGFkb3dfMS5GaWx0ZXJTaGFkb3cpO1xyXG4gICAgICAgIHRoaXMubGlzdC5hZGRFeGFtcGxlKFwiTWVzaCBCYXNpY1wiLCBNZXNoQmFzaWNfMS5NZXNoQmFzaWMpO1xyXG4gICAgICAgIHRoaXMubGlzdC5hZGRFeGFtcGxlKFwiTWVzaCBUcmlhbmdsZVwiLCBNZXNoVHJpYW5nbGVfMS5NZXNoVHJpYW5nbGUpO1xyXG4gICAgICAgIHRoaXMubGlzdC5hZGRFeGFtcGxlKFwiTWVzaCBUcmlhbmdsZSAyXCIsIE1lc2hDb2xvcmVkVHJpYW5nbGVfMS5NZXNoQ29sb3JlZFRyaWFuZ2xlKTtcclxuICAgICAgICB0aGlzLmxpc3QuYWRkRXhhbXBsZShcIk1lc2ggVGV4dHVyZVwiLCBNZXNoVGV4dHVyZWRfMS5NZXNoVGV4dHVyZWQpO1xyXG4gICAgICAgIHRoaXMubGlzdC5hZGRFeGFtcGxlKFwiTWVzaCBBZHZhbmNlZFwiLCBNZXNoQWR2YW5jZWRfMS5NZXNoQWR2YW5jZWQpO1xyXG4gICAgICAgIHRoaXMubGlzdC5hZGRFeGFtcGxlKFwiTWVzaCBVbmlmb3Jtc1wiLCBNZXNoVW5pZm9ybXNfMS5NZXNoVW5pZm9ybXMpO1xyXG4gICAgICAgIHRoaXMubGlzdC5hZGRFeGFtcGxlKFwiTWVzaCBHZW9tZXRyeVwiLCBNZXNoR2VvbWV0cnlfMS5NZXNoR2VvbWV0cnkpO1xyXG4gICAgICAgIHRoaXMubGlzdC5hZGRFeGFtcGxlKFwiTWVzaCBTaGFkZXJcIiwgTWVzaFNoYWRlcl8xLk1lc2hTaGFkZXIpO1xyXG4gICAgICAgIHRoaXMuc2V0RXhhbXBsZShTcHJpdGVCYXNpY18xLlNwcml0ZUJhc2ljKTtcclxuICAgIH1cclxuICAgIHNldEV4YW1wbGUoa2V5Y2xhc3MpIHtcclxuICAgICAgICB0aGlzLmxpc3QucmVtb3ZlRXZlbnRMaXN0ZW5lcihFdmVudF8xLkV2ZW50LkNIQU5HRSwgdGhpcy5oYW5kbGVFeGFtcGxlUmVxdWVzdCk7XHJcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudEV4YW1wbGUpIHtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50RXhhbXBsZS5kZXN0cnVjdG9yKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY3VycmVudEV4YW1wbGUgPSBuZXcga2V5Y2xhc3ModGhpcy5hcHAsIHRoaXMuZXhhbXBsZVdpZHRoLCB0aGlzLmV4YW1wbGVoZWlnaHQpO1xyXG4gICAgICAgIHRoaXMuY3VycmVudEV4YW1wbGUuYWRkRXZlbnRMaXN0ZW5lcihFdmVudF8xLkV2ZW50LkNPTVBMRVRFLCB0aGlzLmhhbmRsZUNvbXBsZXRlKTtcclxuICAgICAgICAvLyB0aGlzLmN1cnJlbnRFeGFtcGxlLnN0YWdlLnggPSB0aGlzLmN1cnJlbnRFeGFtcGxlLnN0YWdlLnkgPSB0aGlzLmZyYW1lc2l6ZTtcclxuICAgICAgICB0aGlzLnN0YWdlTGF5ZXIucmVtb3ZlQ2hpbGRyZW4oKTtcclxuICAgICAgICB0aGlzLnN0YWdlTGF5ZXIuYWRkQ2hpbGQodGhpcy5jdXJyZW50RXhhbXBsZS5zdGFnZSk7XHJcbiAgICAgICAgdGhpcy5yZWZyZXNoQmFja2dyb3VuZCh0aGlzLmN1cnJlbnRFeGFtcGxlLmJhY2tDb2xvcik7XHJcbiAgICB9XHJcbiAgICByZWZyZXNoQmFja2dyb3VuZChjb2xvcikge1xyXG4gICAgICAgIHRoaXMuYmFja2dyb3VuZC5jbGVhcigpO1xyXG4gICAgICAgIHRoaXMuYmFja2dyb3VuZC5iZWdpbkZpbGwoY29sb3IpO1xyXG4gICAgICAgIHRoaXMuYmFja2dyb3VuZC5kcmF3UmVjdCgwLCAwLCB0aGlzLmV4YW1wbGVXaWR0aCwgdGhpcy5leGFtcGxlaGVpZ2h0KTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLkV4YW1wbGVEaXNwbGF5ID0gRXhhbXBsZURpc3BsYXk7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IENvbnRhaW5lcl8xID0gcmVxdWlyZShcIi4uLy4uL3Jhdy1waXhpLXRzL0NvbnRhaW5lclwiKTtcclxuY29uc3QgQnV0dG9uXzEgPSByZXF1aXJlKFwiLi4vLi4vZmwtcGFja2FnZS9CdXR0b25cIik7XHJcbmNvbnN0IEdyYXBoaWNzXzEgPSByZXF1aXJlKFwiLi4vLi4vcmF3LXBpeGktdHMvR3JhcGhpY3NcIik7XHJcbmNvbnN0IE1vdXNlRXZlbnRfMSA9IHJlcXVpcmUoXCIuLi8uLi9yYXctcGl4aS10cy9Nb3VzZUV2ZW50XCIpO1xyXG5jb25zdCBFdmVudF8xID0gcmVxdWlyZShcIi4uLy4uL3Jhdy1waXhpLXRzL0V2ZW50XCIpO1xyXG5jbGFzcyBFeGFtcGxlTGlzdCBleHRlbmRzIENvbnRhaW5lcl8xLkNvbnRhaW5lciB7XHJcbiAgICBjb25zdHJ1Y3RvcihkaXNwbGF5V2lkdGgsIGRpc3BsYXloZWlnaHQpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuaGFuZGxlU2Nyb2xsQ2hhbmdlID0gKGV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMubGlzdENvbnRhaW5lci55ID0gdGhpcy5zY3JvbGwudGFyZ2V0UG9zaXRpb247XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLmhhbmRsZUJ1dHRvblRhcCA9IChldmVudCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLl9zZWxlY3RlZENsYXNzID0gdGhpcy5jbGFzc1JlZmVyZW5jZVtldmVudC5jdXJyZW50VGFyZ2V0Lm5hbWVdO1xyXG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoRXZlbnRfMS5FdmVudC5nZXRFdmVudChFdmVudF8xLkV2ZW50LkNIQU5HRSkpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5idXR0b25zID0gW107XHJcbiAgICAgICAgdGhpcy5jbGFzc1JlZmVyZW5jZSA9IHt9O1xyXG4gICAgICAgIHRoaXMuaXRlbUdhcCA9IDI7XHJcbiAgICAgICAgdGhpcy5zaWRlR2FwID0gMjtcclxuICAgICAgICB0aGlzLmxpc3RDb250YWluZXIgPSBuZXcgQ29udGFpbmVyXzEuQ29udGFpbmVyKCk7XHJcbiAgICAgICAgdGhpcy5hZGRDaGlsZCh0aGlzLmxpc3RDb250YWluZXIpO1xyXG4gICAgICAgIHRoaXMubGlzdG1hc2sgPSBuZXcgR3JhcGhpY3NfMS5HcmFwaGljcygpO1xyXG4gICAgICAgIHRoaXMubGlzdG1hc2suYmVnaW5GaWxsKDApO1xyXG4gICAgICAgIHRoaXMubGlzdG1hc2suZHJhd1JlY3QoMCwgMCwgZGlzcGxheVdpZHRoLCBkaXNwbGF5aGVpZ2h0KTtcclxuICAgICAgICB0aGlzLmxpc3RDb250YWluZXIubWFzayA9IHRoaXMubGlzdG1hc2s7XHJcbiAgICAgICAgdGhpcy5hZGRDaGlsZCh0aGlzLmxpc3RtYXNrKTtcclxuICAgICAgICBsZXQgZ3IgPSBuZXcgR3JhcGhpY3NfMS5HcmFwaGljcygpO1xyXG4gICAgICAgIGdyLmJlZ2luRmlsbCgweEFBQTBBQSk7XHJcbiAgICAgICAgZ3IuZHJhd1JlY3QoMCwgMCwgMjUsIGRpc3BsYXloZWlnaHQpO1xyXG4gICAgICAgIHRoaXMuYWRkQ2hpbGQoZ3IpO1xyXG4gICAgICAgIGdyLnggPSBkaXNwbGF5V2lkdGggLSAyNTtcclxuICAgICAgICB0aGlzLmJ1dHRvbldpZHRoID0gZGlzcGxheVdpZHRoIC0gMjUgLSAodGhpcy5zaWRlR2FwICogMik7XHJcbiAgICAgICAgdGhpcy5idXR0b25oZWlnaHQgPSA0MDtcclxuICAgICAgICB0aGlzLnNjcm9sbCA9IG5ldyBTY3JvbGxCYXIoKTtcclxuICAgICAgICB0aGlzLmFkZENoaWxkKHRoaXMuc2Nyb2xsKTtcclxuICAgICAgICB0aGlzLnNjcm9sbC54ID0gZGlzcGxheVdpZHRoIC0gMjU7XHJcbiAgICAgICAgdGhpcy5zY3JvbGwuc2Nyb2xsQXJlYSA9IGRpc3BsYXloZWlnaHQ7XHJcbiAgICAgICAgdGhpcy5zY3JvbGwuYWRkRXZlbnRMaXN0ZW5lcihFdmVudF8xLkV2ZW50LkNIQU5HRSwgdGhpcy5oYW5kbGVTY3JvbGxDaGFuZ2UpO1xyXG4gICAgfVxyXG4gICAgZ2V0IHNlbGVjdGVkQ2xhc3MoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NlbGVjdGVkQ2xhc3M7XHJcbiAgICB9XHJcbiAgICBhZGRFeGFtcGxlKGtleW5hbWUsIGtleWNsYXNzKSB7XHJcbiAgICAgICAgbGV0IGJ1dHRvbiA9IG5ldyBCdXR0b25fMS5CdXR0b24oa2V5bmFtZSwgdGhpcy5idXR0b25XaWR0aCwgdGhpcy5idXR0b25oZWlnaHQpO1xyXG4gICAgICAgIGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50LlBPSU5URVJfVEFQLCB0aGlzLmhhbmRsZUJ1dHRvblRhcCk7XHJcbiAgICAgICAgdGhpcy5idXR0b25zLnB1c2goYnV0dG9uKTtcclxuICAgICAgICBidXR0b24ubmFtZSA9IGtleW5hbWU7XHJcbiAgICAgICAgYnV0dG9uLnggPSB0aGlzLnNpZGVHYXA7XHJcbiAgICAgICAgdGhpcy5saXN0Q29udGFpbmVyLmFkZENoaWxkKGJ1dHRvbik7XHJcbiAgICAgICAgdGhpcy5jbGFzc1JlZmVyZW5jZVtrZXluYW1lXSA9IGtleWNsYXNzO1xyXG4gICAgICAgIHRoaXMucmVmcmVzaExpc3QoKTtcclxuICAgIH1cclxuICAgIHJlZnJlc2hMaXN0KCkge1xyXG4gICAgICAgIGxldCBzdGFydCA9IHRoaXMuaXRlbUdhcDtcclxuICAgICAgICBmb3IgKGxldCBidXR0b24gb2YgdGhpcy5idXR0b25zKSB7XHJcbiAgICAgICAgICAgIGJ1dHRvbi55ID0gc3RhcnQ7XHJcbiAgICAgICAgICAgIHN0YXJ0ICs9IGJ1dHRvbi5oZWlnaHQgKyB0aGlzLml0ZW1HYXA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuc2Nyb2xsLnNjcm9sbERpc3RhbmNlID0gc3RhcnQ7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5FeGFtcGxlTGlzdCA9IEV4YW1wbGVMaXN0O1xyXG5jbGFzcyBTY3JvbGxCYXIgZXh0ZW5kcyBDb250YWluZXJfMS5Db250YWluZXIge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLmhhbmRsZUhhbmRsZVVwID0gKGV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuZHJhZ2dpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5ldmVudERhdGEgPSBudWxsO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5oYW5kbGVIYW5kbGVNb3ZlID0gKGV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmV2ZW50RGF0YSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbmV3UG9zaXRpb24gPSB0aGlzLmV2ZW50RGF0YS5nZXRMb2NhbFBvc2l0aW9uKHRoaXMuX2hhbmRsZS5wYXJlbnQpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faGFuZGxlLnkgPSBuZXdQb3NpdGlvbi55IC0gKHRoaXMuX2hhbmRsZS5oZWlnaHQgLyAyKTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9oYW5kbGUueSA+IHRoaXMuX3Njcm9sbEFyZWEpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGUueSA9IHRoaXMuX3Njcm9sbEFyZWE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9oYW5kbGUueSA8IDApIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGUueSA9IDA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFyZWFQZXJjZW50ID0gdGhpcy5faGFuZGxlLnkgLyB0aGlzLl9zY3JvbGxBcmVhO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdGFyZ2V0UG9zaXRpb24gPSAodGhpcy5fc2Nyb2xsRGlzdGFuY2UgLSB0aGlzLl92aXNpYmxlQXJlYSkgKiB0aGlzLmFyZWFQZXJjZW50ICogLTE7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoRXZlbnRfMS5FdmVudC5nZXRFdmVudChFdmVudF8xLkV2ZW50LkNIQU5HRSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLmhhbmRsZUhhbmRsZURvd24gPSAoZXZlbnQpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5kcmFnZ2luZyA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuZXZlbnREYXRhID0gZXZlbnQuZGF0YTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuX2hhbmRsZSA9IG5ldyBHcmFwaGljc18xLkdyYXBoaWNzKCk7XHJcbiAgICAgICAgdGhpcy5faGFuZGxlLmJlZ2luRmlsbCgweDYzNjM2Myk7XHJcbiAgICAgICAgdGhpcy5faGFuZGxlLmRyYXdSZWN0KDAsIDAsIDI1LCAyNSk7XHJcbiAgICAgICAgdGhpcy5hZGRDaGlsZCh0aGlzLl9oYW5kbGUpO1xyXG4gICAgICAgIHRoaXMuX2hhbmRsZS5idXR0b25Nb2RlID0gdGhpcy5faGFuZGxlLmludGVyYWN0aXZlID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLl9oYW5kbGUuYWRkRXZlbnRMaXN0ZW5lcihNb3VzZUV2ZW50XzEuTW91c2VFdmVudC5QT0lOVEVSX0RPV04sIHRoaXMuaGFuZGxlSGFuZGxlRG93bik7XHJcbiAgICAgICAgdGhpcy5faGFuZGxlLmFkZEV2ZW50TGlzdGVuZXIoTW91c2VFdmVudF8xLk1vdXNlRXZlbnQuUE9JTlRFUl9VUCwgdGhpcy5oYW5kbGVIYW5kbGVVcCk7XHJcbiAgICAgICAgdGhpcy5faGFuZGxlLmFkZEV2ZW50TGlzdGVuZXIoTW91c2VFdmVudF8xLk1vdXNlRXZlbnQuUE9JTlRFUl9VUF9PVVRTSURFLCB0aGlzLmhhbmRsZUhhbmRsZVVwKTtcclxuICAgICAgICB0aGlzLl9oYW5kbGUuYWRkRXZlbnRMaXN0ZW5lcihNb3VzZUV2ZW50XzEuTW91c2VFdmVudC5QT0lOVEVSX01PVkUsIHRoaXMuaGFuZGxlSGFuZGxlTW92ZSk7XHJcbiAgICB9XHJcbiAgICBnZXQgdGFyZ2V0UG9zaXRpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RhcmdldFBvc2l0aW9uO1xyXG4gICAgfVxyXG4gICAgc2V0IHNjcm9sbERpc3RhbmNlKHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5fc2Nyb2xsRGlzdGFuY2UgPSB2YWx1ZTtcclxuICAgIH1cclxuICAgIHNldCBzY3JvbGxBcmVhKHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5fc2Nyb2xsQXJlYSA9IHZhbHVlIC0gMjU7XHJcbiAgICAgICAgdGhpcy5fdmlzaWJsZUFyZWEgPSB2YWx1ZTtcclxuICAgIH1cclxufVxyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBDb250YWluZXJfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9Db250YWluZXJcIik7XHJcbmNvbnN0IEdyYXBoaWNzXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvR3JhcGhpY3NcIik7XHJcbmNvbnN0IE1vdXNlRXZlbnRfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9Nb3VzZUV2ZW50XCIpO1xyXG5jb25zdCBUZXh0XzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvVGV4dFwiKTtcclxuY29uc3QgVGV4dFN0eWxlXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvVGV4dFN0eWxlXCIpO1xyXG5jbGFzcyBCdXR0b24gZXh0ZW5kcyBDb250YWluZXJfMS5Db250YWluZXIge1xyXG4gICAgY29uc3RydWN0b3IoY2FwdGlvbiwgYnV0dG9uV2lkdGggPSAxNTAsIGJ1dHRvbmhlaWdodCA9IDQwKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLmhhbmRsZU91dCA9IChldmVudCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLmJ1dHRvbmdyYXBoaWMudmlzaWJsZSA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuYnV0dG9ub3ZlcmdyYXBoaWMudmlzaWJsZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLmJ1dHRvbmRvd25ncmFwaGljLnZpc2libGUgPSBmYWxzZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuaGFuZGxlT3ZlciA9IChldmVudCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLmJ1dHRvbmdyYXBoaWMudmlzaWJsZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLmJ1dHRvbm92ZXJncmFwaGljLnZpc2libGUgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLmJ1dHRvbmRvd25ncmFwaGljLnZpc2libGUgPSBmYWxzZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuaGFuZGxlVXAgPSAoZXZlbnQpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5idXR0b25ncmFwaGljLnZpc2libGUgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLmJ1dHRvbm92ZXJncmFwaGljLnZpc2libGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5idXR0b25kb3duZ3JhcGhpYy52aXNpYmxlID0gZmFsc2U7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLmhhbmRsZURvd24gPSAoZXZlbnQpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5idXR0b25ncmFwaGljLnZpc2libGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5idXR0b25vdmVyZ3JhcGhpYy52aXNpYmxlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuYnV0dG9uZG93bmdyYXBoaWMudmlzaWJsZSA9IHRydWU7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLmludGVyYWN0aXZlID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmJ1dHRvbmdyYXBoaWMgPSBuZXcgR3JhcGhpY3NfMS5HcmFwaGljcygpO1xyXG4gICAgICAgIHRoaXMuYnV0dG9uZ3JhcGhpYy5iZWdpbkZpbGwoMHg5Njk2OTYpO1xyXG4gICAgICAgIHRoaXMuYnV0dG9uZ3JhcGhpYy5kcmF3Um91bmRlZFJlY3QoMCwgMCwgYnV0dG9uV2lkdGgsIGJ1dHRvbmhlaWdodCwgMTApO1xyXG4gICAgICAgIHRoaXMuYWRkQ2hpbGQodGhpcy5idXR0b25ncmFwaGljKTtcclxuICAgICAgICB0aGlzLmJ1dHRvbm92ZXJncmFwaGljID0gbmV3IEdyYXBoaWNzXzEuR3JhcGhpY3MoKTtcclxuICAgICAgICB0aGlzLmJ1dHRvbm92ZXJncmFwaGljLmJlZ2luRmlsbCgweEI5QjlCOSk7XHJcbiAgICAgICAgdGhpcy5idXR0b25vdmVyZ3JhcGhpYy5kcmF3Um91bmRlZFJlY3QoMCwgMCwgYnV0dG9uV2lkdGgsIGJ1dHRvbmhlaWdodCwgMTApO1xyXG4gICAgICAgIHRoaXMuYWRkQ2hpbGQodGhpcy5idXR0b25vdmVyZ3JhcGhpYyk7XHJcbiAgICAgICAgdGhpcy5idXR0b25vdmVyZ3JhcGhpYy52aXNpYmxlID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5idXR0b25kb3duZ3JhcGhpYyA9IG5ldyBHcmFwaGljc18xLkdyYXBoaWNzKCk7XHJcbiAgICAgICAgdGhpcy5idXR0b25kb3duZ3JhcGhpYy5iZWdpbkZpbGwoMHg2MzYzNjMpO1xyXG4gICAgICAgIHRoaXMuYnV0dG9uZG93bmdyYXBoaWMuZHJhd1JvdW5kZWRSZWN0KDAsIDAsIGJ1dHRvbldpZHRoLCBidXR0b25oZWlnaHQsIDEwKTtcclxuICAgICAgICB0aGlzLmFkZENoaWxkKHRoaXMuYnV0dG9uZG93bmdyYXBoaWMpO1xyXG4gICAgICAgIHRoaXMuYnV0dG9uZG93bmdyYXBoaWMudmlzaWJsZSA9IGZhbHNlO1xyXG4gICAgICAgIGxldCBzdHlsZSA9IG5ldyBUZXh0U3R5bGVfMS5UZXh0U3R5bGUoe30pO1xyXG4gICAgICAgIHN0eWxlLmZvbnRTaXplID0gMTY7XHJcbiAgICAgICAgc3R5bGUuYWxpZ24gPSBcImNlbnRlclwiO1xyXG4gICAgICAgIHN0eWxlLmZvbnRGYW1pbHkgPSBcIkFyaWFsXCI7XHJcbiAgICAgICAgdGhpcy5sYWJlbCA9IG5ldyBUZXh0XzEuVGV4dChjYXB0aW9uLCBzdHlsZSk7XHJcbiAgICAgICAgdGhpcy5sYWJlbC5pbnRlcmFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMubGFiZWwueSA9IChidXR0b25oZWlnaHQgLSAodGhpcy5sYWJlbC5oZWlnaHQpKSAvIDI7XHJcbiAgICAgICAgdGhpcy5sYWJlbC54ID0gKGJ1dHRvbldpZHRoIC8gMiAtIHRoaXMubGFiZWwud2lkdGggLyAyKTtcclxuICAgICAgICB0aGlzLmFkZENoaWxkKHRoaXMubGFiZWwpO1xyXG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihNb3VzZUV2ZW50XzEuTW91c2VFdmVudC5QT0lOVEVSX0RPV04sIHRoaXMuaGFuZGxlRG93bik7XHJcbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50LlBPSU5URVJfT1ZFUiwgdGhpcy5oYW5kbGVPdmVyKTtcclxuICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoTW91c2VFdmVudF8xLk1vdXNlRXZlbnQuUE9JTlRFUl9VUCwgdGhpcy5oYW5kbGVVcCk7XHJcbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50LlBPSU5URVJfT1VULCB0aGlzLmhhbmRsZU91dCk7XHJcbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50LlBPSU5URVJfVVBfT1VUU0lERSwgdGhpcy5oYW5kbGVPdXQpO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuQnV0dG9uID0gQnV0dG9uO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBBcHBsaWNhdGlvbl8xID0gcmVxdWlyZShcIi4vcmF3LXBpeGktdHMvQXBwbGljYXRpb25cIik7XHJcbmNvbnN0IFN0YWdlT3B0aW9uc18xID0gcmVxdWlyZShcIi4vcmF3LXBpeGktdHMvU3RhZ2VPcHRpb25zXCIpO1xyXG5jb25zdCBFeGFtcGxlRGlzcGxheV8xID0gcmVxdWlyZShcIi4vZXhhbXBsZXMvY29udHJvbHMvRXhhbXBsZURpc3BsYXlcIik7XHJcbndpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCAoKSA9PiB7XHJcbiAgICB2YXIgb3B0aW9ucyA9IG5ldyBTdGFnZU9wdGlvbnNfMS5TdGFnZU9wdGlvbnMoKTtcclxuICAgIG9wdGlvbnMud2lkdGggPSAxMDAwO1xyXG4gICAgb3B0aW9ucy5oZWlnaHQgPSA2MDA7XHJcbiAgICBvcHRpb25zLmF1dG9SZXNpemUgPSBmYWxzZTtcclxuICAgIG9wdGlvbnMuYmFja2dyb3VuZENvbG9yID0gMHgwMDAwMDAwMDtcclxuICAgIG9wdGlvbnMuY2xlYXJCZWZvcmVSZW5kZXIgPSB0cnVlO1xyXG4gICAgb3B0aW9ucy5yZXNvbHV0aW9uID0gMTtcclxuICAgIG9wdGlvbnMuYXV0b1N0YXJ0ID0gdHJ1ZTtcclxuICAgIG9wdGlvbnMudHJhbnNwYXJlbnQgPSB0cnVlO1xyXG4gICAgb3B0aW9ucy5hbnRpYWxpYXMgPSB0cnVlO1xyXG4gICAgb3B0aW9ucy52aWV3ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJmYWtlY2FudmFzXCIpO1xyXG4gICAgdmFyIGFwcCA9IG5ldyBBcHBsaWNhdGlvbl8xLkFwcGxpY2F0aW9uKG9wdGlvbnMpO1xyXG4gICAgbGV0IGRpc3BsYXkgPSBuZXcgRXhhbXBsZURpc3BsYXlfMS5FeGFtcGxlRGlzcGxheShhcHAsIDEwMjQsIDc2OCk7XHJcbiAgICBhcHAuc3RhZ2UuYWRkQ2hpbGQoZGlzcGxheSk7XHJcbiAgICAvLyBjcmVhdGUgYSB2aWV3IGNsYXNzIHdpdGggZnJhbWVcclxuICAgIC8vIGNyZWF0ZSBhIGNvbnRyb2wgY2xhc3Mgd2l0aCBidXR0b25zXHJcbiAgICAvLyBlYWNoIGJ1dHRvbiBjbGljayBjaGFuZ2UgY29udGVudCBvZiBjbGFzcyBmcmFtZVxyXG4gICAgLy8gbGV0IGJ1dHRvbjpCdXR0b24gPSBuZXcgQnV0dG9uKFwiVGVzdFwiLCAyMDAsIDQwKTtcclxuICAgIC8vIGFwcC5zdGFnZS5hZGRDaGlsZChidXR0b24pO1xyXG4gICAgLy8gYnV0dG9uLnggPSA4MDA7XHJcbiAgICAvLyBsZXQgZXhhbXBsZTpCYXNpY0NhY2hlID0gbmV3IEJhc2ljQ2FjaGUoYXBwKTsgTk9UIFdPUktJTkdcclxuICAgIC8vIGxldCBleGFtcGxlOkludGVyYWN0aW9uSWNvbiA9IG5ldyBJbnRlcmFjdGlvbkljb24oYXBwKTtcclxuICAgIC8vIGxldCBleGFtcGxlOlNwcml0ZVZpZGVvID0gbmV3IFNwcml0ZVZpZGVvKGFwcCk7XHJcbiAgICAvLyBsZXQgZXhhbXBsZTpBZHZhbmNlZFNsb3RzID0gbmV3IEFkdmFuY2VkU2xvdHMoYXBwKTsgXHJcbiAgICAvLyBsZXQgZXhhbXBsZTpUZXh0dXJlUm90YXRlID0gbmV3IFRleHR1cmVSb3RhdGUoYXBwKTsgXHJcbiAgICAvLyBsZXQgZXhhbXBsZTpCYXNpY0NvbnRhaW5lciA9IG5ldyBCYXNpY0NvbnRhaW5lcihhcHApO1xyXG4gICAgLy8gbGV0IGV4YW1wbGU6QmFzaWNCYWNrZ3JvdW5kID0gbmV3IEJhc2ljQmFja2dyb3VuZChhcHApO1xyXG4gICAgLy8gbGV0IGV4YW1wbGU6QmFzaWNUaW50aW5nID0gbmV3IEJhc2ljVGludGluZyhhcHApOyAgICBcclxuICAgIC8vIGxldCBleGFtcGxlOkJhc2ljUGFydGljbGVzID0gbmV3IEJhc2ljUGFydGljbGVzKGFwcCk7XHJcbiAgICAvLyBsZXQgZXhhbXBsZTpCYXNpY0JsZW5kID0gbmV3IEJhc2ljQmxlbmQoYXBwKTsgICAgXHJcbiAgICAvLyBsZXQgZXhhbXBsZTpHcmFwaGljc1NpbXBsZSA9IG5ldyBHcmFwaGljc1NpbXBsZShhcHApO1xyXG4gICAgLy8gbGV0IGV4YW1wbGU6R3JhcGhpY3NBZHZhbmNlZCA9IG5ldyBHcmFwaGljc0FkdmFuY2VkKGFwcCk7XHJcbiAgICAvLyBsZXQgZXhhbXBsZTpHcmFwaGljc0R5bmFtaWMgPSBuZXcgR3JhcGhpY3NEeW5hbWljKGFwcCk7XHJcbiAgICAvLyBsZXQgZXhhbXBsZTpUZXh0dXJlUmVuZGVyID0gbmV3IFRleHR1cmVSZW5kZXIoYXBwKTtcclxuICAgIC8vIGxldCBleGFtcGxlOlRleHR1cmVBZHZhbmNlZCA9IG5ldyBUZXh0dXJlQWR2YW5jZWQoYXBwKTtcclxuICAgIC8vIGxldCBleGFtcGxlOlRleHR1cmVHcmFkaWVudEJhc2ljID0gbmV3IFRleHR1cmVHcmFkaWVudEJhc2ljKGFwcCk7XHJcbiAgICAvLyBsZXQgZXhhbXBsZTpUZXh0dXJlR3JhZGllbnRSZXNvdXJjZSA9IG5ldyBUZXh0dXJlR3JhZGllbnRSZXNvdXJjZShhcHApO1xyXG4gICAgLy8gbGV0IGV4YW1wbGU6VGV4dEJhc2UgPSBuZXcgVGV4dEJhc2UoYXBwKTtcclxuICAgIC8vIGxldCBleGFtcGxlOlRleHRCaXRtYXAgPSBuZXcgVGV4dEJpdG1hcChhcHApOyBcclxuICAgIC8vIGxldCBleGFtcGxlOlRleHRXZWJGb250ID0gbmV3IFRleHRXZWJGb250KGFwcCk7IFxyXG4gICAgLy8gbGV0IGV4YW1wbGU6TWFza0dyYXBoaWNzID0gbmV3IE1hc2tHcmFwaGljcyhhcHApO1xyXG4gICAgLy8gbGV0IGV4YW1wbGU6TWFza1Nwcml0ZSA9IG5ldyBNYXNrU3ByaXRlKGFwcCk7XHJcbiAgICAvLyBsZXQgZXhhbXBsZTpGaWx0ZXJCbHVyID0gbmV3IEZpbHRlckJsdXIoYXBwKTtcclxuICAgIC8vIGxldCBleGFtcGxlOkZpbHRlckNvbG9yID0gbmV3IEZpbHRlckNvbG9yKGFwcCk7XHJcbiAgICAvLyBsZXQgZXhhbXBsZTpGaWx0ZXJDcmF3bGllcyA9IG5ldyBGaWx0ZXJDcmF3bGllcyhhcHApO1xyXG4gICAgLy8gbGV0IGV4YW1wbGU6RmlsdGVyRmxhZyA9IG5ldyBGaWx0ZXJGbGFnKGFwcCk7XHJcbiAgICAvLyBsZXQgZXhhbXBsZTpNYXNrRmlsdGVyID0gbmV3IE1hc2tGaWx0ZXIoYXBwKTtcclxuICAgIC8vIGxldCBleGFtcGxlOkludGVyYWN0aW9uQ2xpY2sgPSBuZXcgSW50ZXJhY3Rpb25DbGljayhhcHApO1xyXG4gICAgLy8gbGV0IGV4YW1wbGU6SW50ZXJhY3Rpb25JbnRlcmFjdGl2aXR5ID0gbmV3IEludGVyYWN0aW9uSW50ZXJhY3Rpdml0eShhcHApO1xyXG4gICAgLy8gbGV0IGV4YW1wbGU6SW50ZXJhY3Rpb25EcmFnZ2luZyA9IG5ldyBJbnRlcmFjdGlvbkRyYWdnaW5nKGFwcCk7IFxyXG4gICAgLy8gbGV0IGV4YW1wbGU6U3ByaXRlQmFzaWMgPSBuZXcgU3ByaXRlQmFzaWMoYXBwKTsgIFxyXG4gICAgLy8gbGV0IGV4YW1wbGU6U3ByaXRlU3dhcCA9IG5ldyBTcHJpdGVTd2FwKGFwcCk7ICAgIFxyXG4gICAgLy8gbGV0IGV4YW1wbGU6U3ByaXRlVGlsaW5nID0gbmV3IFNwcml0ZVRpbGluZyhhcHApOyAgICBcclxuICAgIC8vIGxldCBleGFtcGxlOlNwcml0ZUV4cGxvc2lvbiA9IG5ldyBTcHJpdGVFeHBsb3Npb24oYXBwKTtcclxuICAgIC8vIGxldCBleGFtcGxlOlNwcml0ZWpldCA9IG5ldyBTcHJpdGVqZXQoYXBwKTsgXHJcbiAgICAvLyBsZXQgZXhhbXBsZTpTcHJpdGVTcGVlZCA9IG5ldyBTcHJpdGVTcGVlZChhcHApOyBcclxuICAgIC8vIGxldCBleGFtcGxlOkFkdmFuY2VkQ2FyZCA9IG5ldyBBZHZhbmNlZENhcmQoYXBwKTsgXHJcbiAgICAvLyBsZXQgZXhhbXBsZTpBZHZhbmNlZFRyYWlsID0gbmV3IEFkdmFuY2VkVHJhaWwoYXBwKTsgXHJcbiAgICAvLyBsZXQgZXhhbXBsZTpBZHZhbmNlZFdhcnAgPSBuZXcgQWR2YW5jZWRXYXJwKGFwcCk7IFxyXG4gICAgLy8gbGV0IGV4YW1wbGU6RmlsdGVyQmxlbmRpbmcgPSBuZXcgRmlsdGVyQmxlbmRpbmcoYXBwKTsgXHJcbiAgICAvLyBsZXQgZXhhbXBsZTpGaWx0ZXJDdXN0b20gPSBuZXcgRmlsdGVyQ3VzdG9tKGFwcCk7IFxyXG4gICAgLy8gbGV0IGV4YW1wbGU6RmlsdGVyU2hhZG93ID0gbmV3IEZpbHRlclNoYWRvdyhhcHApOyBcclxuICAgIC8vIGxldCBleGFtcGxlOk1lc2hCYXNpYyA9IG5ldyBNZXNoQmFzaWMoYXBwKTtcclxuICAgIC8vIGxldCBleGFtcGxlOk1lc2hBZHZhbmNlZCA9IG5ldyBNZXNoQWR2YW5jZWQoYXBwKTtcclxuICAgIC8vIGxldCBleGFtcGxlOk1lc2hUcmlhbmdsZSA9IG5ldyBNZXNoVHJpYW5nbGUoYXBwKTtcclxuICAgIC8vIGxldCBleGFtcGxlOk1lc2hDb2xvcmVkVHJpYW5nbGUgPSBuZXcgTWVzaENvbG9yZWRUcmlhbmdsZShhcHApO1xyXG4gICAgLy8gbGV0IGV4YW1wbGU6TWVzaFRleHR1cmVkID0gbmV3IE1lc2hUZXh0dXJlZChhcHApO1xyXG4gICAgLy8gbGV0IGV4YW1wbGU6TWVzaFVuaWZvcm1zID0gbmV3IE1lc2hVbmlmb3JtcyhhcHApO1xyXG4gICAgLy8gbGV0IGV4YW1wbGU6TWVzaEdlb21ldHJ5ID0gbmV3IE1lc2hHZW9tZXRyeShhcHApO1xyXG4gICAgLy8gbGV0IGV4YW1wbGU6TWVzaFNoYWRlciA9IG5ldyBNZXNoU2hhZGVyKGFwcCk7XHJcbn0pO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBFdmVudERpc3BhdGNoZXJfMSA9IHJlcXVpcmUoXCIuL0V2ZW50RGlzcGF0Y2hlclwiKTtcclxuY29uc3QgTWF0cml4XzEgPSByZXF1aXJlKFwiLi9NYXRyaXhcIik7XHJcbmNvbnN0IFJlY3RhbmdsZV8xID0gcmVxdWlyZShcIi4vUmVjdGFuZ2xlXCIpO1xyXG5jb25zdCBSZW5kZXJUZXh0dXJlXzEgPSByZXF1aXJlKFwiLi9SZW5kZXJUZXh0dXJlXCIpO1xyXG5jb25zdCBDb250YWluZXJfMSA9IHJlcXVpcmUoXCIuL0NvbnRhaW5lclwiKTtcclxuY29uc3QgRGlzcGxheVNldHRpbmdzXzEgPSByZXF1aXJlKFwiLi9EaXNwbGF5U2V0dGluZ3NcIik7XHJcbmNvbnN0IE1hdGhTZXR0aW5nc18xID0gcmVxdWlyZShcIi4vTWF0aFNldHRpbmdzXCIpO1xyXG5jb25zdCBDb2xvclNldHRpbmdzXzEgPSByZXF1aXJlKFwiLi9Db2xvclNldHRpbmdzXCIpO1xyXG5jbGFzcyBBYnN0cmFjdFJlbmRlcmVyIGV4dGVuZHMgRXZlbnREaXNwYXRjaGVyXzEuRXZlbnREaXNwYXRjaGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKHN5c3RlbSwgb3B0aW9ucykge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMucm91bmRQaXhlbHMpIHtcclxuICAgICAgICAgICAgRGlzcGxheVNldHRpbmdzXzEuRGlzcGxheVNldHRpbmdzLlJPVU5EX1BJWEVMUyA9IG9wdGlvbnMucm91bmRQaXhlbHM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XHJcbiAgICAgICAgdGhpcy50eXBlID0gRGlzcGxheVNldHRpbmdzXzEuRGlzcGxheVNldHRpbmdzLlJFTkRFUkVSX1RZUEUuVU5LTk9XTjtcclxuICAgICAgICB0aGlzLnNjcmVlbiA9IG5ldyBSZWN0YW5nbGVfMS5SZWN0YW5nbGUoMCwgMCwgb3B0aW9ucy53aWR0aCwgb3B0aW9ucy5oZWlnaHQpO1xyXG4gICAgICAgIHRoaXMudmlldyA9IG9wdGlvbnMudmlldyB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcclxuICAgICAgICB0aGlzLnJlc29sdXRpb24gPSBvcHRpb25zLnJlc29sdXRpb24gfHwgRGlzcGxheVNldHRpbmdzXzEuRGlzcGxheVNldHRpbmdzLlJFU09MVVRJT047XHJcbiAgICAgICAgdGhpcy50cmFuc3BhcmVudCA9IG9wdGlvbnMudHJhbnNwYXJlbnQ7XHJcbiAgICAgICAgdGhpcy5hdXRvRGVuc2l0eSA9IG9wdGlvbnMuYXV0b0RlbnNpdHkgfHwgb3B0aW9ucy5hdXRvUmVzaXplIHx8IGZhbHNlO1xyXG4gICAgICAgIHRoaXMucHJlc2VydmVEcmF3aW5nQnVmZmVyID0gb3B0aW9ucy5wcmVzZXJ2ZURyYXdpbmdCdWZmZXI7XHJcbiAgICAgICAgdGhpcy5jbGVhckJlZm9yZVJlbmRlciA9IG9wdGlvbnMuY2xlYXJCZWZvcmVSZW5kZXI7XHJcbiAgICAgICAgdGhpcy5fYmFja2dyb3VuZENvbG9yID0gMHgwMDAwMDA7XHJcbiAgICAgICAgdGhpcy5fYmFja2dyb3VuZENvbG9yUmdiYSA9IFswLCAwLCAwLCAwXTtcclxuICAgICAgICB0aGlzLl9iYWNrZ3JvdW5kQ29sb3JTdHJpbmcgPSAnIzAwMDAwMCc7XHJcbiAgICAgICAgdGhpcy5iYWNrZ3JvdW5kQ29sb3IgPSBvcHRpb25zLmJhY2tncm91bmRDb2xvciB8fCB0aGlzLl9iYWNrZ3JvdW5kQ29sb3I7XHJcbiAgICAgICAgdGhpcy5fdGVtcERpc3BsYXlPYmplY3RQYXJlbnQgPSBuZXcgQ29udGFpbmVyXzEuQ29udGFpbmVyKCk7XHJcbiAgICAgICAgdGhpcy5fbGFzdE9iamVjdFJlbmRlcmVkID0gdGhpcy5fdGVtcERpc3BsYXlPYmplY3RQYXJlbnQ7XHJcbiAgICAgICAgdGhpcy5ibGVuZE1vZGVzID0gMDtcclxuICAgIH1cclxuICAgIHJlc2l6ZShzY3JlZW5XaWR0aCwgc2NyZWVuSGVpZ2h0KSB7XHJcbiAgICAgICAgdGhpcy5zY3JlZW4ud2lkdGggPSBzY3JlZW5XaWR0aDtcclxuICAgICAgICB0aGlzLnNjcmVlbi5oZWlnaHQgPSBzY3JlZW5IZWlnaHQ7XHJcbiAgICAgICAgdGhpcy52aWV3LndpZHRoID0gc2NyZWVuV2lkdGggKiB0aGlzLnJlc29sdXRpb247XHJcbiAgICAgICAgdGhpcy52aWV3LmhlaWdodCA9IHNjcmVlbkhlaWdodCAqIHRoaXMucmVzb2x1dGlvbjtcclxuICAgICAgICBpZiAodGhpcy5hdXRvRGVuc2l0eSkge1xyXG4gICAgICAgICAgICB0aGlzLnZpZXcuc3R5bGUud2lkdGggPSBzY3JlZW5XaWR0aCArIFwicHhcIjtcclxuICAgICAgICAgICAgdGhpcy52aWV3LnN0eWxlLmhlaWdodCA9IHNjcmVlbkhlaWdodCArIFwicHhcIjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICBnZXQgd2lkdGgoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudmlldy53aWR0aDtcclxuICAgIH1cclxuICAgIDtcclxuICAgIGdldCBoZWlnaHQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudmlldy5oZWlnaHQ7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICBnZW5lcmF0ZVRleHR1cmUoZGlzcGxheU9iamVjdCwgc2NhbGVNb2RlLCByZXNvbHV0aW9uLCByZWdpb24pIHtcclxuICAgICAgICByZWdpb24gPSByZWdpb24gfHwgZGlzcGxheU9iamVjdC5nZXRMb2NhbEJvdW5kcygpO1xyXG4gICAgICAgIGlmIChyZWdpb24ud2lkdGggPT09IDApIHtcclxuICAgICAgICAgICAgcmVnaW9uLndpZHRoID0gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJlZ2lvbi5oZWlnaHQgPT09IDApIHtcclxuICAgICAgICAgICAgcmVnaW9uLmhlaWdodCA9IDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciByZW5kZXJUZXh0dXJlID0gUmVuZGVyVGV4dHVyZV8xLlJlbmRlclRleHR1cmUuY3JlYXRlKHJlZ2lvbi53aWR0aCB8IDAsIHJlZ2lvbi5oZWlnaHQgfCAwLCBzY2FsZU1vZGUsIHJlc29sdXRpb24pO1xyXG4gICAgICAgIEFic3RyYWN0UmVuZGVyZXIudGVtcE1hdHJpeC50eCA9IC1yZWdpb24ueDtcclxuICAgICAgICBBYnN0cmFjdFJlbmRlcmVyLnRlbXBNYXRyaXgudHkgPSAtcmVnaW9uLnk7XHJcbiAgICAgICAgdGhpcy5yZW5kZXIoZGlzcGxheU9iamVjdCwgcmVuZGVyVGV4dHVyZSwgZmFsc2UsIEFic3RyYWN0UmVuZGVyZXIudGVtcE1hdHJpeCwgISFkaXNwbGF5T2JqZWN0LnBhcmVudCk7XHJcbiAgICAgICAgcmV0dXJuIHJlbmRlclRleHR1cmU7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICByZW5kZXIoZGlzcGxheU9iamVjdCwgcmVuZGVyVGV4dHVyZSwgYiwgbSwgcGFyZW50KSB7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgZXZlcnl0aGluZyBmcm9tIHRoZSByZW5kZXJlciBhbmQgb3B0aW9uYWxseSByZW1vdmVzIHRoZSBDYW52YXMgRE9NIGVsZW1lbnQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbcmVtb3ZlVmlldz1mYWxzZV0gLSBSZW1vdmVzIHRoZSBDYW52YXMgZWxlbWVudCBmcm9tIHRoZSBET00uXHJcbiAgICAgKi9cclxuICAgIGRlc3Ryb3kocmVtb3ZlVmlldykge1xyXG4gICAgICAgIC8vIGZvciAodmFyIG8gaW4gdGhpcy5wbHVnaW5zKVxyXG4gICAgICAgIC8vIHtcclxuICAgICAgICAvLyAgICAgdGhpcy5wbHVnaW5zW29dLmRlc3Ryb3koKTtcclxuICAgICAgICAvLyAgICAgdGhpcy5wbHVnaW5zW29dID0gbnVsbDtcclxuICAgICAgICAvLyB9XHJcbiAgICAgICAgaWYgKHJlbW92ZVZpZXcgJiYgdGhpcy52aWV3LnBhcmVudE5vZGUpIHtcclxuICAgICAgICAgICAgdGhpcy52aWV3LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy52aWV3KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gdGhpcy5wbHVnaW5zID0gbnVsbDtcclxuICAgICAgICB0aGlzLnR5cGUgPSBEaXNwbGF5U2V0dGluZ3NfMS5EaXNwbGF5U2V0dGluZ3MuUkVOREVSRVJfVFlQRS5VTktOT1dOO1xyXG4gICAgICAgIHRoaXMudmlldyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5zY3JlZW4gPSBudWxsO1xyXG4gICAgICAgIHRoaXMucmVzb2x1dGlvbiA9IDA7XHJcbiAgICAgICAgdGhpcy50cmFuc3BhcmVudCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuYXV0b0RlbnNpdHkgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmJsZW5kTW9kZXMgPSBudWxsO1xyXG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5wcmVzZXJ2ZURyYXdpbmdCdWZmZXIgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmNsZWFyQmVmb3JlUmVuZGVyID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fYmFja2dyb3VuZENvbG9yID0gMDtcclxuICAgICAgICB0aGlzLl9iYWNrZ3JvdW5kQ29sb3JSZ2JhID0gbnVsbDtcclxuICAgICAgICB0aGlzLl9iYWNrZ3JvdW5kQ29sb3JTdHJpbmcgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuX3RlbXBEaXNwbGF5T2JqZWN0UGFyZW50ID0gbnVsbDtcclxuICAgICAgICB0aGlzLl9sYXN0T2JqZWN0UmVuZGVyZWQgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgYmFja2dyb3VuZCBjb2xvciB0byBmaWxsIGlmIG5vdCB0cmFuc3BhcmVudFxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgZ2V0IGJhY2tncm91bmRDb2xvcigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fYmFja2dyb3VuZENvbG9yO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgc2V0IGJhY2tncm91bmRDb2xvcih2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuX2JhY2tncm91bmRDb2xvciA9IHZhbHVlO1xyXG4gICAgICAgIHRoaXMuX2JhY2tncm91bmRDb2xvclN0cmluZyA9IE1hdGhTZXR0aW5nc18xLk1hdGhTZXR0aW5ncy5oZXgyc3RyaW5nKHZhbHVlKTtcclxuICAgICAgICBDb2xvclNldHRpbmdzXzEuQ29sb3JTZXR0aW5ncy5oZXgycmdiKHZhbHVlLCB0aGlzLl9iYWNrZ3JvdW5kQ29sb3JSZ2JhKTtcclxuICAgIH1cclxuICAgIDtcclxufVxyXG5BYnN0cmFjdFJlbmRlcmVyLnRlbXBNYXRyaXggPSBuZXcgTWF0cml4XzEuTWF0cml4KCk7XHJcbmV4cG9ydHMuQWJzdHJhY3RSZW5kZXJlciA9IEFic3RyYWN0UmVuZGVyZXI7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbi8vIGltcG9ydCB7IHNldHRpbmdzIH0gZnJvbSAnLi9zZXR0aW5ncyc7XHJcbmNvbnN0IFV0aWxzU2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL1V0aWxzU2V0dGluZ3NcIik7XHJcbmNsYXNzIEFjY2Vzc2liaWxpdHlNYW5hZ2VyIHtcclxuICAgIGNvbnN0cnVjdG9yKHJlbmRlcmVyKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBAdHlwZSB7P0hUTUxFbGVtZW50fVxyXG4gICAgICAgICAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuX2hvb2tEaXYgPSBudWxsO1xyXG4gICAgICAgIC8vIGlmIChzZXR0aW5ncy5pc01vYmlsZV9taW4udGFibGV0IHx8IHNldHRpbmdzLmlzTW9iaWxlX21pbi5waG9uZSlcclxuICAgICAgICAvLyB7XHJcbiAgICAgICAgdGhpcy5jcmVhdGVUb3VjaEhvb2soKTtcclxuICAgICAgICAvLyB9XHJcbiAgICAgICAgLy8gZmlyc3Qgd2UgY3JlYXRlIGEgZGl2IHRoYXQgd2lsbCBzaXQgb3ZlciB0aGUgUGl4aUpTIGVsZW1lbnQuIFRoaXMgaXMgd2hlcmUgdGhlIGRpdiBvdmVybGF5cyB3aWxsIGdvLlxyXG4gICAgICAgIHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgICAgICBkaXYuc3R5bGUud2lkdGggPSBBY2Nlc3NpYmlsaXR5TWFuYWdlci5ESVZfVE9VQ0hfU0laRSArIFwicHhcIjtcclxuICAgICAgICBkaXYuc3R5bGUuaGVpZ2h0ID0gQWNjZXNzaWJpbGl0eU1hbmFnZXIuRElWX1RPVUNIX1NJWkUgKyBcInB4XCI7XHJcbiAgICAgICAgZGl2LnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcclxuICAgICAgICBkaXYuc3R5bGUudG9wID0gQWNjZXNzaWJpbGl0eU1hbmFnZXIuRElWX1RPVUNIX1BPU19YICsgXCJweFwiO1xyXG4gICAgICAgIGRpdi5zdHlsZS5sZWZ0ID0gQWNjZXNzaWJpbGl0eU1hbmFnZXIuRElWX1RPVUNIX1BPU19ZICsgXCJweFwiO1xyXG4gICAgICAgIGRpdi5zdHlsZS56SW5kZXggPSBBY2Nlc3NpYmlsaXR5TWFuYWdlci5ESVZfVE9VQ0hfWklOREVYLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhpcyBpcyB0aGUgZG9tIGVsZW1lbnQgdGhhdCB3aWxsIHNpdCBvdmVyIHRoZSBQaXhpSlMgZWxlbWVudC4gVGhpcyBpcyB3aGVyZSB0aGUgZGl2IG92ZXJsYXlzIHdpbGwgZ28uXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmRpdiA9IGRpdjtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBIHNpbXBsZSBwb29sIGZvciBzdG9yaW5nIGRpdnMuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAdHlwZSB7Kn1cclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMucG9vbCA9IFtdO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoaXMgaXMgYSB0aWNrIHVzZWQgdG8gY2hlY2sgaWYgYW4gb2JqZWN0IGlzIG5vIGxvbmdlciBiZWluZyByZW5kZXJlZC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnJlbmRlcklkID0gMDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTZXR0aW5nIHRoaXMgdG8gdHJ1ZSB3aWxsIHZpc3VhbGx5IHNob3cgdGhlIGRpdnMuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmRlYnVnID0gZmFsc2U7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIHJlbmRlcmVyIHRoaXMgYWNjZXNzaWJpbGl0eSBtYW5hZ2VyIHdvcmtzIGZvci5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuQWJzdHJhY3RSZW5kZXJlcn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGFycmF5IG9mIGN1cnJlbnRseSBhY3RpdmUgYWNjZXNzaWJsZSBpdGVtcy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBtZW1iZXIge0FycmF5PCo+fVxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IFtdO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIHByZS1iaW5kIHRoZSBmdW5jdGlvbnNcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuX29uS2V5RG93biA9IHRoaXMuX29uS2V5RG93bi5iaW5kKHRoaXMpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIHByZS1iaW5kIHRoZSBmdW5jdGlvbnNcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuX29uTW91c2VNb3ZlID0gdGhpcy5fb25Nb3VzZU1vdmUuYmluZCh0aGlzKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBIGZsYWdcclxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgICAgICAgKiBAcmVhZG9ubHlcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmlzQWN0aXZlID0gZmFsc2U7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQSBmbGFnXHJcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgICAgICogQHJlYWRvbmx5XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5pc01vYmlsZUFjY2Vzc2liaWxpdHkgPSBmYWxzZTtcclxuICAgICAgICAvLyBsZXQgbGlzdGVuIGZvciB0YWIuLiBvbmNlIHByZXNzZWQgd2UgY2FuIGZpcmUgdXAgYW5kIHNob3cgdGhlIGFjY2Vzc2liaWxpdHkgbGF5ZXJcclxuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuX29uS2V5RG93biwgZmFsc2UpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIHRoZSB0b3VjaCBob29rcy5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBjcmVhdGVUb3VjaEhvb2soKSB7XHJcbiAgICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XHJcbiAgICAgICAgdmFyIGhvb2tEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKTtcclxuICAgICAgICBob29rRGl2LnN0eWxlLndpZHRoID0gQWNjZXNzaWJpbGl0eU1hbmFnZXIuRElWX0hPT0tfU0laRSArIFwicHhcIjtcclxuICAgICAgICBob29rRGl2LnN0eWxlLmhlaWdodCA9IEFjY2Vzc2liaWxpdHlNYW5hZ2VyLkRJVl9IT09LX1NJWkUgKyBcInB4XCI7XHJcbiAgICAgICAgaG9va0Rpdi5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XHJcbiAgICAgICAgaG9va0Rpdi5zdHlsZS50b3AgPSBBY2Nlc3NpYmlsaXR5TWFuYWdlci5ESVZfSE9PS19QT1NfWCArIFwicHhcIjtcclxuICAgICAgICBob29rRGl2LnN0eWxlLmxlZnQgPSBBY2Nlc3NpYmlsaXR5TWFuYWdlci5ESVZfSE9PS19QT1NfWSArIFwicHhcIjtcclxuICAgICAgICBob29rRGl2LnN0eWxlLnpJbmRleCA9IEFjY2Vzc2liaWxpdHlNYW5hZ2VyLkRJVl9IT09LX1pJTkRFWC50b1N0cmluZygpO1xyXG4gICAgICAgIGhvb2tEaXYuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gJyNGRjAwMDAnO1xyXG4gICAgICAgIGhvb2tEaXYudGl0bGUgPSAnSE9PSyBESVYnO1xyXG4gICAgICAgIGhvb2tEaXYuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXMnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMkMS5pc01vYmlsZUFjY2Vzc2liaWxpdHkgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzJDEuYWN0aXZhdGUoKTtcclxuICAgICAgICAgICAgdGhpcyQxLmRlc3Ryb3lUb3VjaEhvb2soKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGhvb2tEaXYpO1xyXG4gICAgICAgIHRoaXMuX2hvb2tEaXYgPSBob29rRGl2O1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBEZXN0cm95cyB0aGUgdG91Y2ggaG9va3MuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgZGVzdHJveVRvdWNoSG9vaygpIHtcclxuICAgICAgICBpZiAoIXRoaXMuX2hvb2tEaXYpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHRoaXMuX2hvb2tEaXYpO1xyXG4gICAgICAgIHRoaXMuX2hvb2tEaXYgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBY3RpdmF0aW5nIHdpbGwgY2F1c2UgdGhlIEFjY2Vzc2liaWxpdHkgbGF5ZXIgdG8gYmUgc2hvd24uXHJcbiAgICAgKiBUaGlzIGlzIGNhbGxlZCB3aGVuIGEgdXNlciBwcmVzc2VzIHRoZSB0YWIga2V5LlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIGFjdGl2YXRlKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmlzQWN0aXZlKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5pc0FjdGl2ZSA9IHRydWU7XHJcbiAgICAgICAgd2luZG93LmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMuX29uTW91c2VNb3ZlLCB0cnVlKTtcclxuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuX29uS2V5RG93biwgZmFsc2UpO1xyXG4gICAgICAgIHRoaXMucmVuZGVyZXIub24oJ3Bvc3RyZW5kZXInLCB0aGlzLnVwZGF0ZSwgdGhpcyk7XHJcbiAgICAgICAgaWYgKHRoaXMucmVuZGVyZXIudmlldy5wYXJlbnROb2RlKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIudmlldy5wYXJlbnROb2RlLmFwcGVuZENoaWxkKHRoaXMuZGl2KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIERlYWN0aXZhdGluZyB3aWxsIGNhdXNlIHRoZSBBY2Nlc3NpYmlsaXR5IGxheWVyIHRvIGJlIGhpZGRlbi5cclxuICAgICAqIFRoaXMgaXMgY2FsbGVkIHdoZW4gYSB1c2VyIG1vdmVzIHRoZSBtb3VzZS5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBkZWFjdGl2YXRlKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5pc0FjdGl2ZSB8fCB0aGlzLmlzTW9iaWxlQWNjZXNzaWJpbGl0eSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuaXNBY3RpdmUgPSBmYWxzZTtcclxuICAgICAgICB3aW5kb3cuZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5fb25Nb3VzZU1vdmUsIHRydWUpO1xyXG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5fb25LZXlEb3duLCBmYWxzZSk7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJlci5vZmYoJ3Bvc3RyZW5kZXInLCB0aGlzLnVwZGF0ZSk7XHJcbiAgICAgICAgaWYgKHRoaXMuZGl2LnBhcmVudE5vZGUpIHtcclxuICAgICAgICAgICAgdGhpcy5kaXYucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmRpdik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIHJlY3Vyc2l2ZSBmdW5jdGlvbiB3aWxsIHJ1biB0aHJvdWdoIHRoZSBzY2VuZSBncmFwaCBhbmQgYWRkIGFueSBuZXcgYWNjZXNzaWJsZSBvYmplY3RzIHRvIHRoZSBET00gbGF5ZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7UElYSS5Db250YWluZXJ9IGRpc3BsYXlPYmplY3QgLSBUaGUgRGlzcGxheU9iamVjdCB0byBjaGVjay5cclxuICAgICAqL1xyXG4gICAgdXBkYXRlQWNjZXNzaWJsZU9iamVjdHMoZGlzcGxheU9iamVjdCkge1xyXG4gICAgICAgIGlmICghZGlzcGxheU9iamVjdC52aXNpYmxlKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGRpc3BsYXlPYmplY3QuYWNjZXNzaWJsZSAmJiBkaXNwbGF5T2JqZWN0LmludGVyYWN0aXZlKSB7XHJcbiAgICAgICAgICAgIGlmICghZGlzcGxheU9iamVjdC5fYWNjZXNzaWJsZUFjdGl2ZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRDaGlsZChkaXNwbGF5T2JqZWN0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBkaXNwbGF5T2JqZWN0LnJlbmRlcklkID0gdGhpcy5yZW5kZXJJZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gZGlzcGxheU9iamVjdC5jaGlsZHJlbjtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQWNjZXNzaWJsZU9iamVjdHMoY2hpbGRyZW5baV0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQmVmb3JlIGVhY2ggcmVuZGVyIHRoaXMgZnVuY3Rpb24gd2lsbCBlbnN1cmUgdGhhdCBhbGwgZGl2cyBhcmUgbWFwcGVkIGNvcnJlY3RseSB0byB0aGVpciBEaXNwbGF5T2JqZWN0cy5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICB1cGRhdGUoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLnJlbmRlcmVyLnJlbmRlcmluZ1RvU2NyZWVuKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gdXBkYXRlIGNoaWxkcmVuLi4uXHJcbiAgICAgICAgdGhpcy51cGRhdGVBY2Nlc3NpYmxlT2JqZWN0cyh0aGlzLnJlbmRlcmVyLl9sYXN0T2JqZWN0UmVuZGVyZWQpO1xyXG4gICAgICAgIHZhciByZWN0ID0gdGhpcy5yZW5kZXJlci52aWV3LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgICAgIHZhciBzeCA9IHJlY3Qud2lkdGggLyB0aGlzLnJlbmRlcmVyLndpZHRoO1xyXG4gICAgICAgIHZhciBzeSA9IHJlY3QuaGVpZ2h0IC8gdGhpcy5yZW5kZXJlci5oZWlnaHQ7XHJcbiAgICAgICAgdmFyIGRpdiA9IHRoaXMuZGl2O1xyXG4gICAgICAgIGRpdi5zdHlsZS5sZWZ0ID0gKHJlY3QubGVmdCkgKyBcInB4XCI7XHJcbiAgICAgICAgZGl2LnN0eWxlLnRvcCA9IChyZWN0LnRvcCkgKyBcInB4XCI7XHJcbiAgICAgICAgZGl2LnN0eWxlLndpZHRoID0gKHRoaXMucmVuZGVyZXIud2lkdGgpICsgXCJweFwiO1xyXG4gICAgICAgIGRpdi5zdHlsZS5oZWlnaHQgPSAodGhpcy5yZW5kZXJlci5oZWlnaHQpICsgXCJweFwiO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldO1xyXG4gICAgICAgICAgICBpZiAoY2hpbGQucmVuZGVySWQgIT09IHRoaXMucmVuZGVySWQpIHtcclxuICAgICAgICAgICAgICAgIGNoaWxkLl9hY2Nlc3NpYmxlQWN0aXZlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBVdGlsc1NldHRpbmdzXzEuVXRpbHNTZXR0aW5ncy5yZW1vdmVJdGVtcyh0aGlzLmNoaWxkcmVuLCBpLCAxKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGl2LnJlbW92ZUNoaWxkKGNoaWxkLl9hY2Nlc3NpYmxlRGl2KTtcclxuICAgICAgICAgICAgICAgIHRoaXMucG9vbC5wdXNoKGNoaWxkLl9hY2Nlc3NpYmxlRGl2KTtcclxuICAgICAgICAgICAgICAgIGNoaWxkLl9hY2Nlc3NpYmxlRGl2ID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIGktLTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVhY3RpdmF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gbWFwIGRpdiB0byBkaXNwbGF5Li5cclxuICAgICAgICAgICAgICAgIGRpdiA9IGNoaWxkLl9hY2Nlc3NpYmxlRGl2O1xyXG4gICAgICAgICAgICAgICAgdmFyIGhpdEFyZWEgPSBjaGlsZC5oaXRBcmVhO1xyXG4gICAgICAgICAgICAgICAgdmFyIHd0ID0gY2hpbGQud29ybGRUcmFuc2Zvcm07XHJcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQuaGl0QXJlYSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRpdi5zdHlsZS5sZWZ0ID0gKCh3dC50eCArIChoaXRBcmVhLnggKiB3dC5hKSkgKiBzeCkgKyBcInB4XCI7XHJcbiAgICAgICAgICAgICAgICAgICAgZGl2LnN0eWxlLnRvcCA9ICgod3QudHkgKyAoaGl0QXJlYS55ICogd3QuZCkpICogc3kpICsgXCJweFwiO1xyXG4gICAgICAgICAgICAgICAgICAgIGRpdi5zdHlsZS53aWR0aCA9IChoaXRBcmVhLndpZHRoICogd3QuYSAqIHN4KSArIFwicHhcIjtcclxuICAgICAgICAgICAgICAgICAgICBkaXYuc3R5bGUuaGVpZ2h0ID0gKGhpdEFyZWEuaGVpZ2h0ICogd3QuZCAqIHN5KSArIFwicHhcIjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGhpdEFyZWEgPSBjaGlsZC5nZXRCb3VuZHMoKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNhcEhpdEFyZWEoaGl0QXJlYSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZGl2LnN0eWxlLmxlZnQgPSAoaGl0QXJlYS54ICogc3gpICsgXCJweFwiO1xyXG4gICAgICAgICAgICAgICAgICAgIGRpdi5zdHlsZS50b3AgPSAoaGl0QXJlYS55ICogc3kpICsgXCJweFwiO1xyXG4gICAgICAgICAgICAgICAgICAgIGRpdi5zdHlsZS53aWR0aCA9IChoaXRBcmVhLndpZHRoICogc3gpICsgXCJweFwiO1xyXG4gICAgICAgICAgICAgICAgICAgIGRpdi5zdHlsZS5oZWlnaHQgPSAoaGl0QXJlYS5oZWlnaHQgKiBzeSkgKyBcInB4XCI7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdXBkYXRlIGJ1dHRvbiB0aXRsZXMgYW5kIGhpbnRzIGlmIHRoZXkgZXhpc3QgYW5kIHRoZXkndmUgY2hhbmdlZFxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChkaXYudGl0bGUgIT09IGNoaWxkLmFjY2Vzc2libGVUaXRsZSAmJiBjaGlsZC5hY2Nlc3NpYmxlVGl0bGUgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGl2LnRpdGxlID0gY2hpbGQuYWNjZXNzaWJsZVRpdGxlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoZGl2LmdldEF0dHJpYnV0ZSgnYXJpYS1sYWJlbCcpICE9PSBjaGlsZC5hY2Nlc3NpYmxlSGludFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAmJiBjaGlsZC5hY2Nlc3NpYmxlSGludCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXYuc2V0QXR0cmlidXRlKCdhcmlhLWxhYmVsJywgY2hpbGQuYWNjZXNzaWJsZUhpbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBpbmNyZW1lbnQgdGhlIHJlbmRlciBpZC4uXHJcbiAgICAgICAgdGhpcy5yZW5kZXJJZCsrO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBZGp1c3QgdGhlIGhpdCBhcmVhIGJhc2VkIG9uIHRoZSBib3VuZHMgb2YgYSBkaXNwbGF5IG9iamVjdFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7UmVjdGFuZ2xlfSBoaXRBcmVhIC0gQm91bmRzIG9mIHRoZSBjaGlsZFxyXG4gICAgICovXHJcbiAgICBjYXBIaXRBcmVhKGhpdEFyZWEpIHtcclxuICAgICAgICBpZiAoaGl0QXJlYS54IDwgMCkge1xyXG4gICAgICAgICAgICBoaXRBcmVhLndpZHRoICs9IGhpdEFyZWEueDtcclxuICAgICAgICAgICAgaGl0QXJlYS54ID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGhpdEFyZWEueSA8IDApIHtcclxuICAgICAgICAgICAgaGl0QXJlYS5oZWlnaHQgKz0gaGl0QXJlYS55O1xyXG4gICAgICAgICAgICBoaXRBcmVhLnkgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaGl0QXJlYS54ICsgaGl0QXJlYS53aWR0aCA+IHRoaXMucmVuZGVyZXIud2lkdGgpIHtcclxuICAgICAgICAgICAgaGl0QXJlYS53aWR0aCA9IHRoaXMucmVuZGVyZXIud2lkdGggLSBoaXRBcmVhLng7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChoaXRBcmVhLnkgKyBoaXRBcmVhLmhlaWdodCA+IHRoaXMucmVuZGVyZXIuaGVpZ2h0KSB7XHJcbiAgICAgICAgICAgIGhpdEFyZWEuaGVpZ2h0ID0gdGhpcy5yZW5kZXJlci5oZWlnaHQgLSBoaXRBcmVhLnk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGEgRGlzcGxheU9iamVjdCB0byB0aGUgYWNjZXNzaWJpbGl0eSBtYW5hZ2VyXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7RGlzcGxheU9iamVjdH0gZGlzcGxheU9iamVjdCAtIFRoZSBjaGlsZCB0byBtYWtlIGFjY2Vzc2libGUuXHJcbiAgICAgKi9cclxuICAgIGFkZENoaWxkKGRpc3BsYXlPYmplY3QpIHtcclxuICAgICAgICAvL3RoaXMuYWN0aXZhdGUoKTtcclxuICAgICAgICB2YXIgZGl2ID0gdGhpcy5wb29sLnBvcCgpO1xyXG4gICAgICAgIGlmICghZGl2KSB7XHJcbiAgICAgICAgICAgIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpO1xyXG4gICAgICAgICAgICBkaXYuc3R5bGUud2lkdGggPSBBY2Nlc3NpYmlsaXR5TWFuYWdlci5ESVZfVE9VQ0hfU0laRSArIFwicHhcIjtcclxuICAgICAgICAgICAgZGl2LnN0eWxlLmhlaWdodCA9IEFjY2Vzc2liaWxpdHlNYW5hZ2VyLkRJVl9UT1VDSF9TSVpFICsgXCJweFwiO1xyXG4gICAgICAgICAgICBkaXYuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gdGhpcy5kZWJ1ZyA/ICdyZ2JhKDI1NSwwLDAsMC41KScgOiAndHJhbnNwYXJlbnQnO1xyXG4gICAgICAgICAgICBkaXYuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xyXG4gICAgICAgICAgICBkaXYuc3R5bGUuekluZGV4ID0gQWNjZXNzaWJpbGl0eU1hbmFnZXIuRElWX1RPVUNIX1pJTkRFWDtcclxuICAgICAgICAgICAgZGl2LnN0eWxlLmJvcmRlclN0eWxlID0gJ25vbmUnO1xyXG4gICAgICAgICAgICAvLyBBUklBIGF0dHJpYnV0ZXMgZW5zdXJlIHRoYXQgYnV0dG9uIHRpdGxlIGFuZCBoaW50IHVwZGF0ZXMgYXJlIGFubm91bmNlZCBwcm9wZXJseVxyXG4gICAgICAgICAgICBpZiAobmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ2Nocm9tZScpID4gLTEpIHtcclxuICAgICAgICAgICAgICAgIC8vIENocm9tZSBkb2Vzbid0IG5lZWQgYXJpYS1saXZlIHRvIHdvcmsgYXMgaW50ZW5kZWQ7IGluIGZhY3QgaXQganVzdCBnZXRzIG1vcmUgY29uZnVzZWQuXHJcbiAgICAgICAgICAgICAgICBkaXYuc2V0QXR0cmlidXRlKCdhcmlhLWxpdmUnLCAnb2ZmJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBkaXYuc2V0QXR0cmlidXRlKCdhcmlhLWxpdmUnLCAncG9saXRlJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL3J2Oi4qR2Vja29cXC8vKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gRmlyZUZveCBuZWVkcyB0aGlzIHRvIGFubm91bmNlIG9ubHkgdGhlIG5ldyBidXR0b24gbmFtZVxyXG4gICAgICAgICAgICAgICAgZGl2LnNldEF0dHJpYnV0ZSgnYXJpYS1yZWxldmFudCcsICdhZGRpdGlvbnMnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIHJlcXVpcmVkIGJ5IElFLCBvdGhlciBicm93c2VycyBkb24ndCBtdWNoIGNhcmVcclxuICAgICAgICAgICAgICAgIGRpdi5zZXRBdHRyaWJ1dGUoJ2FyaWEtcmVsZXZhbnQnLCAndGV4dCcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGRpdi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX29uQ2xpY2suYmluZCh0aGlzKSk7XHJcbiAgICAgICAgICAgIGRpdi5hZGRFdmVudExpc3RlbmVyKCdmb2N1cycsIHRoaXMuX29uRm9jdXMuYmluZCh0aGlzKSk7XHJcbiAgICAgICAgICAgIGRpdi5hZGRFdmVudExpc3RlbmVyKCdmb2N1c291dCcsIHRoaXMuX29uRm9jdXNPdXQuYmluZCh0aGlzKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChkaXNwbGF5T2JqZWN0LmFjY2Vzc2libGVUaXRsZSAmJiBkaXNwbGF5T2JqZWN0LmFjY2Vzc2libGVUaXRsZSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBkaXYudGl0bGUgPSBkaXNwbGF5T2JqZWN0LmFjY2Vzc2libGVUaXRsZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoIWRpc3BsYXlPYmplY3QuYWNjZXNzaWJsZUhpbnRcclxuICAgICAgICAgICAgfHwgZGlzcGxheU9iamVjdC5hY2Nlc3NpYmxlSGludCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICBkaXYudGl0bGUgPSBcImRpc3BsYXlPYmplY3QgXCIgKyAoZGlzcGxheU9iamVjdC50YWJJbmRleCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChkaXNwbGF5T2JqZWN0LmFjY2Vzc2libGVIaW50XHJcbiAgICAgICAgICAgICYmIGRpc3BsYXlPYmplY3QuYWNjZXNzaWJsZUhpbnQgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgZGl2LnNldEF0dHJpYnV0ZSgnYXJpYS1sYWJlbCcsIGRpc3BsYXlPYmplY3QuYWNjZXNzaWJsZUhpbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvL1xyXG4gICAgICAgIGRpc3BsYXlPYmplY3QuX2FjY2Vzc2libGVBY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgIGRpc3BsYXlPYmplY3QuX2FjY2Vzc2libGVEaXYgPSBkaXY7XHJcbiAgICAgICAgZGl2LmRpc3BsYXlPYmplY3QgPSBkaXNwbGF5T2JqZWN0O1xyXG4gICAgICAgIHRoaXMuY2hpbGRyZW4ucHVzaChkaXNwbGF5T2JqZWN0KTtcclxuICAgICAgICB0aGlzLmRpdi5hcHBlbmRDaGlsZChkaXNwbGF5T2JqZWN0Ll9hY2Nlc3NpYmxlRGl2KTtcclxuICAgICAgICBkaXNwbGF5T2JqZWN0Ll9hY2Nlc3NpYmxlRGl2LnRhYkluZGV4ID0gZGlzcGxheU9iamVjdC50YWJJbmRleDtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogTWFwcyB0aGUgZGl2IGJ1dHRvbiBwcmVzcyB0byBwaXhpJ3MgIChjbGljaylcclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtNb3VzZUV2ZW50fSBlIC0gVGhlIGNsaWNrIGV2ZW50LlxyXG4gICAgICovXHJcbiAgICBfb25DbGljayhlKSB7XHJcbiAgICAgICAgdmFyIGludGVyYWN0aW9uTWFuYWdlciA9IHRoaXMucmVuZGVyZXIucGx1Z2lucy5pbnRlcmFjdGlvbjtcclxuICAgICAgICBpbnRlcmFjdGlvbk1hbmFnZXIuZGlzcGF0Y2hFdmVudChlLnRhcmdldC5kaXNwbGF5T2JqZWN0LCAnY2xpY2snLCBpbnRlcmFjdGlvbk1hbmFnZXIuZXZlbnREYXRhKTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogTWFwcyB0aGUgZGl2IGZvY3VzIGV2ZW50cyB0byBwaXhpJ3MgIChtb3VzZW92ZXIpXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7Rm9jdXNFdmVudH0gZSAtIFRoZSBmb2N1cyBldmVudC5cclxuICAgICAqL1xyXG4gICAgX29uRm9jdXMoZSkge1xyXG4gICAgICAgIGlmICghZS50YXJnZXQuZ2V0QXR0cmlidXRlKCdhcmlhLWxpdmUnLCAnb2ZmJykpIHtcclxuICAgICAgICAgICAgZS50YXJnZXQuc2V0QXR0cmlidXRlKCdhcmlhLWxpdmUnLCAnYXNzZXJ0aXZlJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBpbnRlcmFjdGlvbk1hbmFnZXIgPSB0aGlzLnJlbmRlcmVyLnBsdWdpbnMuaW50ZXJhY3Rpb247XHJcbiAgICAgICAgaW50ZXJhY3Rpb25NYW5hZ2VyLmRpc3BhdGNoRXZlbnQoZS50YXJnZXQuZGlzcGxheU9iamVjdCwgJ21vdXNlb3ZlcicsIGludGVyYWN0aW9uTWFuYWdlci5ldmVudERhdGEpO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBNYXBzIHRoZSBkaXYgZm9jdXMgZXZlbnRzIHRvIHBpeGkncyAgKG1vdXNlb3V0KVxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge0ZvY3VzRXZlbnR9IGUgLSBUaGUgZm9jdXNvdXQgZXZlbnQuXHJcbiAgICAgKi9cclxuICAgIF9vbkZvY3VzT3V0KGUpIHtcclxuICAgICAgICBpZiAoIWUudGFyZ2V0LmdldEF0dHJpYnV0ZSgnYXJpYS1saXZlJywgJ29mZicpKSB7XHJcbiAgICAgICAgICAgIGUudGFyZ2V0LnNldEF0dHJpYnV0ZSgnYXJpYS1saXZlJywgJ3BvbGl0ZScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgaW50ZXJhY3Rpb25NYW5hZ2VyID0gdGhpcy5yZW5kZXJlci5wbHVnaW5zLmludGVyYWN0aW9uO1xyXG4gICAgICAgIGludGVyYWN0aW9uTWFuYWdlci5kaXNwYXRjaEV2ZW50KGUudGFyZ2V0LmRpc3BsYXlPYmplY3QsICdtb3VzZW91dCcsIGludGVyYWN0aW9uTWFuYWdlci5ldmVudERhdGEpO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBJcyBjYWxsZWQgd2hlbiBhIGtleSBpcyBwcmVzc2VkXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7S2V5Ym9hcmRFdmVudH0gZSAtIFRoZSBrZXlkb3duIGV2ZW50LlxyXG4gICAgICovXHJcbiAgICBfb25LZXlEb3duKGUpIHtcclxuICAgICAgICBpZiAoZS5rZXlDb2RlICE9PSBBY2Nlc3NpYmlsaXR5TWFuYWdlci5LRVlfQ09ERV9UQUIpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmFjdGl2YXRlKCk7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIElzIGNhbGxlZCB3aGVuIHRoZSBtb3VzZSBtb3ZlcyBhY3Jvc3MgdGhlIHJlbmRlcmVyIGVsZW1lbnRcclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtNb3VzZUV2ZW50fSBlIC0gVGhlIG1vdXNlIGV2ZW50LlxyXG4gICAgICovXHJcbiAgICBfb25Nb3VzZU1vdmUoZSkge1xyXG4gICAgICAgIGlmIChlLm1vdmVtZW50WCA9PT0gMCAmJiBlLm1vdmVtZW50WSA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZGVhY3RpdmF0ZSgpO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBEZXN0cm95cyB0aGUgYWNjZXNzaWJpbGl0eSBtYW5hZ2VyXHJcbiAgICAgKlxyXG4gICAgICovXHJcbiAgICBkZXN0cm95KCkge1xyXG4gICAgICAgIHRoaXMuZGVzdHJveVRvdWNoSG9vaygpO1xyXG4gICAgICAgIHRoaXMuZGl2ID0gbnVsbDtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbltpXS5kaXYgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICB3aW5kb3cuZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5fb25Nb3VzZU1vdmUsIHRydWUpO1xyXG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5fb25LZXlEb3duKTtcclxuICAgICAgICB0aGlzLnBvb2wgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBudWxsO1xyXG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgO1xyXG59XHJcbkFjY2Vzc2liaWxpdHlNYW5hZ2VyLkRJVl9IT09LX1NJWkUgPSAxO1xyXG5BY2Nlc3NpYmlsaXR5TWFuYWdlci5ESVZfSE9PS19QT1NfWCA9IC0xMDAwO1xyXG5BY2Nlc3NpYmlsaXR5TWFuYWdlci5ESVZfSE9PS19QT1NfWSA9IC0xMDAwO1xyXG5BY2Nlc3NpYmlsaXR5TWFuYWdlci5ESVZfSE9PS19aSU5ERVggPSAyO1xyXG5BY2Nlc3NpYmlsaXR5TWFuYWdlci5LRVlfQ09ERV9UQUIgPSA5O1xyXG5BY2Nlc3NpYmlsaXR5TWFuYWdlci5ESVZfVE9VQ0hfU0laRSA9IDEwMDtcclxuQWNjZXNzaWJpbGl0eU1hbmFnZXIuRElWX1RPVUNIX1BPU19YID0gMDtcclxuQWNjZXNzaWJpbGl0eU1hbmFnZXIuRElWX1RPVUNIX1BPU19ZID0gMDtcclxuQWNjZXNzaWJpbGl0eU1hbmFnZXIuRElWX1RPVUNIX1pJTkRFWCA9IDI7XHJcbmV4cG9ydHMuQWNjZXNzaWJpbGl0eU1hbmFnZXIgPSBBY2Nlc3NpYmlsaXR5TWFuYWdlcjtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgU3ByaXRlXzEgPSByZXF1aXJlKFwiLi9TcHJpdGVcIik7XHJcbmNvbnN0IFRleHR1cmVfMSA9IHJlcXVpcmUoXCIuL1RleHR1cmVcIik7XHJcbmNvbnN0IFRpY2tlcl8xID0gcmVxdWlyZShcIi4vVGlja2VyXCIpO1xyXG5jbGFzcyBBbmltYXRlZFNwcml0ZSBleHRlbmRzIFNwcml0ZV8xLlNwcml0ZSB7XHJcbiAgICBjb25zdHJ1Y3Rvcih0ZXh0dXJlcywgYXV0b1VwZGF0ZSA9IHRydWUpIHtcclxuICAgICAgICBzdXBlcih0ZXh0dXJlc1swXSBpbnN0YW5jZW9mIFRleHR1cmVfMS5UZXh0dXJlID8gdGV4dHVyZXNbMF0gOiB0ZXh0dXJlc1swXS50ZXh0dXJlKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAdHlwZSB7UElYSS5UZXh0dXJlW119XHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLl90ZXh0dXJlcyA9IG51bGw7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHR5cGUge251bWJlcltdfVxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5fZHVyYXRpb25zID0gbnVsbDtcclxuICAgICAgICB0aGlzLnRleHR1cmVzID0gdGV4dHVyZXM7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogYHRydWVgIHVzZXMgUElYSS5UaWNrZXIuc2hhcmVkIHRvIGF1dG8gdXBkYXRlIGFuaW1hdGlvbiB0aW1lLlxyXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAgICAgICAqIEBkZWZhdWx0IHRydWVcclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuX2F1dG9VcGRhdGUgPSBhdXRvVXBkYXRlICE9PSBmYWxzZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgc3BlZWQgdGhhdCB0aGUgQW5pbWF0ZWRTcHJpdGUgd2lsbCBwbGF5IGF0LiBIaWdoZXIgaXMgZmFzdGVyLCBsb3dlciBpcyBzbG93ZXIuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgICAgICogQGRlZmF1bHQgMVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuYW5pbWF0aW9uU3BlZWQgPSAxO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFdoZXRoZXIgb3Igbm90IHRoZSBhbmltYXRlIHNwcml0ZSByZXBlYXRzIGFmdGVyIHBsYXlpbmcuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAbWVtYmVyIHtib29sZWFufVxyXG4gICAgICAgICAqIEBkZWZhdWx0IHRydWVcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmxvb3AgPSB0cnVlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFVwZGF0ZSBhbmNob3IgdG8gW1RleHR1cmUncyBkZWZhdWx0QW5jaG9yXXtAbGluayBQSVhJLlRleHR1cmUjZGVmYXVsdEFuY2hvcn0gd2hlbiBmcmFtZSBjaGFuZ2VzLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogVXNlZnVsIHdpdGggW3Nwcml0ZSBzaGVldCBhbmltYXRpb25zXXtAbGluayBQSVhJLlNwcml0ZXNoZWV0I2FuaW1hdGlvbnN9IGNyZWF0ZWQgd2l0aCB0b29scy5cclxuICAgICAgICAgKiBDaGFuZ2luZyBhbmNob3IgZm9yIGVhY2ggZnJhbWUgYWxsb3dzIHRvIHBpbiBzcHJpdGUgb3JpZ2luIHRvIGNlcnRhaW4gbW92aW5nIGZlYXR1cmVcclxuICAgICAgICAgKiBvZiB0aGUgZnJhbWUgKGUuZy4gbGVmdCBmb290KS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIE5vdGU6IEVuYWJsaW5nIHRoaXMgd2lsbCBvdmVycmlkZSBhbnkgcHJldmlvdXNseSBzZXQgYGFuY2hvcmAgb24gZWFjaCBmcmFtZSBjaGFuZ2UuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAbWVtYmVyIHtib29sZWFufVxyXG4gICAgICAgICAqIEBkZWZhdWx0IGZhbHNlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy51cGRhdGVBbmNob3IgPSBmYWxzZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBGdW5jdGlvbiB0byBjYWxsIHdoZW4gYSBBbmltYXRlZFNwcml0ZSBmaW5pc2hlcyBwbGF5aW5nLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQG1lbWJlciB7RnVuY3Rpb259XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5vbkNvbXBsZXRlID0gbnVsbDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBGdW5jdGlvbiB0byBjYWxsIHdoZW4gYSBBbmltYXRlZFNwcml0ZSBjaGFuZ2VzIHdoaWNoIHRleHR1cmUgaXMgYmVpbmcgcmVuZGVyZWQuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAbWVtYmVyIHtGdW5jdGlvbn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLm9uRnJhbWVDaGFuZ2UgPSBudWxsO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEZ1bmN0aW9uIHRvIGNhbGwgd2hlbiBgbG9vcGAgaXMgdHJ1ZSwgYW5kIGFuIEFuaW1hdGVkU3ByaXRlIGlzIHBsYXllZCBhbmQgbG9vcHMgYXJvdW5kIHRvIHN0YXJ0IGFnYWluLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQG1lbWJlciB7RnVuY3Rpb259XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5vbkxvb3AgPSBudWxsO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEVsYXBzZWQgdGltZSBzaW5jZSBhbmltYXRpb24gaGFzIGJlZW4gc3RhcnRlZCwgdXNlZCBpbnRlcm5hbGx5IHRvIGRpc3BsYXkgY3VycmVudCB0ZXh0dXJlLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5fY3VycmVudFRpbWUgPSAwO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEluZGljYXRlcyBpZiB0aGUgQW5pbWF0ZWRTcHJpdGUgaXMgY3VycmVudGx5IHBsYXlpbmcuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAbWVtYmVyIHtib29sZWFufVxyXG4gICAgICAgICAqIEByZWFkb25seVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMucGxheWluZyA9IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTdG9wcyB0aGUgQW5pbWF0ZWRTcHJpdGUuXHJcbiAgICAgKlxyXG4gICAgICovXHJcbiAgICBzdG9wKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5wbGF5aW5nKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5wbGF5aW5nID0gZmFsc2U7XHJcbiAgICAgICAgaWYgKHRoaXMuX2F1dG9VcGRhdGUpIHtcclxuICAgICAgICAgICAgVGlja2VyXzEuVGlja2VyLnNoYXJlZC5yZW1vdmUodGhpcy51cGRhdGUsIHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogUGxheXMgdGhlIEFuaW1hdGVkU3ByaXRlLlxyXG4gICAgICpcclxuICAgICAqL1xyXG4gICAgcGxheSgpIHtcclxuICAgICAgICBpZiAodGhpcy5wbGF5aW5nKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5wbGF5aW5nID0gdHJ1ZTtcclxuICAgICAgICBpZiAodGhpcy5fYXV0b1VwZGF0ZSkge1xyXG4gICAgICAgICAgICBUaWNrZXJfMS5UaWNrZXIuc2hhcmVkLmFkZCh0aGlzLnVwZGF0ZSwgdGhpcywgVGlja2VyXzEuVGlja2VyLlVQREFURV9QUklPUklUWS5ISUdIKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFN0b3BzIHRoZSBBbmltYXRlZFNwcml0ZSBhbmQgZ29lcyB0byBhIHNwZWNpZmljIGZyYW1lLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBmcmFtZU51bWJlciAtIEZyYW1lIGluZGV4IHRvIHN0b3AgYXQuXHJcbiAgICAgKi9cclxuICAgIGdvdG9BbmRTdG9wKGZyYW1lTnVtYmVyKSB7XHJcbiAgICAgICAgdGhpcy5zdG9wKCk7XHJcbiAgICAgICAgdmFyIHByZXZpb3VzRnJhbWUgPSB0aGlzLmN1cnJlbnRGcmFtZTtcclxuICAgICAgICB0aGlzLl9jdXJyZW50VGltZSA9IGZyYW1lTnVtYmVyO1xyXG4gICAgICAgIGlmIChwcmV2aW91c0ZyYW1lICE9PSB0aGlzLmN1cnJlbnRGcmFtZSkge1xyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVRleHR1cmUoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIEdvZXMgdG8gYSBzcGVjaWZpYyBmcmFtZSBhbmQgYmVnaW5zIHBsYXlpbmcgdGhlIEFuaW1hdGVkU3ByaXRlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBmcmFtZU51bWJlciAtIEZyYW1lIGluZGV4IHRvIHN0YXJ0IGF0LlxyXG4gICAgICovXHJcbiAgICBnb3RvQW5kUGxheShmcmFtZU51bWJlcikge1xyXG4gICAgICAgIHZhciBwcmV2aW91c0ZyYW1lID0gdGhpcy5jdXJyZW50RnJhbWU7XHJcbiAgICAgICAgdGhpcy5fY3VycmVudFRpbWUgPSBmcmFtZU51bWJlcjtcclxuICAgICAgICBpZiAocHJldmlvdXNGcmFtZSAhPT0gdGhpcy5jdXJyZW50RnJhbWUpIHtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVUZXh0dXJlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMucGxheSgpO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGVzIHRoZSBvYmplY3QgdHJhbnNmb3JtIGZvciByZW5kZXJpbmcuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkZWx0YVRpbWUgLSBUaW1lIHNpbmNlIGxhc3QgdGljay5cclxuICAgICAqL1xyXG4gICAgdXBkYXRlKGRlbHRhVGltZSkge1xyXG4gICAgICAgIHZhciBlbGFwc2VkID0gdGhpcy5hbmltYXRpb25TcGVlZCAqIGRlbHRhVGltZTtcclxuICAgICAgICB2YXIgcHJldmlvdXNGcmFtZSA9IHRoaXMuY3VycmVudEZyYW1lO1xyXG4gICAgICAgIGlmICh0aGlzLl9kdXJhdGlvbnMgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgdmFyIGxhZyA9IHRoaXMuX2N1cnJlbnRUaW1lICUgMSAqIHRoaXMuX2R1cmF0aW9uc1t0aGlzLmN1cnJlbnRGcmFtZV07XHJcbiAgICAgICAgICAgIGxhZyArPSBlbGFwc2VkIC8gNjAgKiAxMDAwO1xyXG4gICAgICAgICAgICB3aGlsZSAobGFnIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudFRpbWUtLTtcclxuICAgICAgICAgICAgICAgIGxhZyArPSB0aGlzLl9kdXJhdGlvbnNbdGhpcy5jdXJyZW50RnJhbWVdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBzaWduID0gTWF0aC5zaWduKHRoaXMuYW5pbWF0aW9uU3BlZWQgKiBkZWx0YVRpbWUpO1xyXG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50VGltZSA9IE1hdGguZmxvb3IodGhpcy5fY3VycmVudFRpbWUpO1xyXG4gICAgICAgICAgICB3aGlsZSAobGFnID49IHRoaXMuX2R1cmF0aW9uc1t0aGlzLmN1cnJlbnRGcmFtZV0pIHtcclxuICAgICAgICAgICAgICAgIGxhZyAtPSB0aGlzLl9kdXJhdGlvbnNbdGhpcy5jdXJyZW50RnJhbWVdICogc2lnbjtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRUaW1lICs9IHNpZ247XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fY3VycmVudFRpbWUgKz0gbGFnIC8gdGhpcy5fZHVyYXRpb25zW3RoaXMuY3VycmVudEZyYW1lXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRUaW1lICs9IGVsYXBzZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLl9jdXJyZW50VGltZSA8IDAgJiYgIXRoaXMubG9vcCkge1xyXG4gICAgICAgICAgICB0aGlzLmdvdG9BbmRTdG9wKDApO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5vbkNvbXBsZXRlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9uQ29tcGxldGUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLl9jdXJyZW50VGltZSA+PSB0aGlzLl90ZXh0dXJlcy5sZW5ndGggJiYgIXRoaXMubG9vcCkge1xyXG4gICAgICAgICAgICB0aGlzLmdvdG9BbmRTdG9wKHRoaXMuX3RleHR1cmVzLmxlbmd0aCAtIDEpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5vbkNvbXBsZXRlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9uQ29tcGxldGUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChwcmV2aW91c0ZyYW1lICE9PSB0aGlzLmN1cnJlbnRGcmFtZSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5sb29wICYmIHRoaXMub25Mb29wKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5hbmltYXRpb25TcGVlZCA+IDAgJiYgdGhpcy5jdXJyZW50RnJhbWUgPCBwcmV2aW91c0ZyYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbkxvb3AoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuYW5pbWF0aW9uU3BlZWQgPCAwICYmIHRoaXMuY3VycmVudEZyYW1lID4gcHJldmlvdXNGcmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25Mb29wKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy51cGRhdGVUZXh0dXJlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGVzIHRoZSBkaXNwbGF5ZWQgdGV4dHVyZSB0byBtYXRjaCB0aGUgY3VycmVudCBmcmFtZSBpbmRleC5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICB1cGRhdGVUZXh0dXJlKCkge1xyXG4gICAgICAgIHRoaXMuX3RleHR1cmUgPSB0aGlzLl90ZXh0dXJlc1t0aGlzLmN1cnJlbnRGcmFtZV07XHJcbiAgICAgICAgdGhpcy5fdGV4dHVyZUlEID0gLTE7XHJcbiAgICAgICAgdGhpcy5fdGV4dHVyZVRyaW1tZWRJRCA9IC0xO1xyXG4gICAgICAgIHRoaXMuY2FjaGVkVGludCA9IDB4RkZGRkZGO1xyXG4gICAgICAgIHRoaXMudXZzID0gdGhpcy5fdGV4dHVyZS5fdXZzLnV2c0Zsb2F0MzI7XHJcbiAgICAgICAgaWYgKHRoaXMudXBkYXRlQW5jaG9yKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2FuY2hvci5jb3B5KHRoaXMuX3RleHR1cmUuZGVmYXVsdEFuY2hvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLm9uRnJhbWVDaGFuZ2UpIHtcclxuICAgICAgICAgICAgdGhpcy5vbkZyYW1lQ2hhbmdlKHRoaXMuY3VycmVudEZyYW1lKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFN0b3BzIHRoZSBBbmltYXRlZFNwcml0ZSBhbmQgZGVzdHJveXMgaXQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtvYmplY3R8Ym9vbGVhbn0gW29wdGlvbnNdIC0gT3B0aW9ucyBwYXJhbWV0ZXIuIEEgYm9vbGVhbiB3aWxsIGFjdCBhcyBpZiBhbGwgb3B0aW9uc1xyXG4gICAgICogIGhhdmUgYmVlbiBzZXQgdG8gdGhhdCB2YWx1ZS5cclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuY2hpbGRyZW49ZmFsc2VdIC0gSWYgc2V0IHRvIHRydWUsIGFsbCB0aGUgY2hpbGRyZW4gd2lsbCBoYXZlIHRoZWlyIGRlc3Ryb3lcclxuICAgICAqICAgICAgbWV0aG9kIGNhbGxlZCBhcyB3ZWxsLiAnb3B0aW9ucycgd2lsbCBiZSBwYXNzZWQgb24gdG8gdGhvc2UgY2FsbHMuXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRleHR1cmU9ZmFsc2VdIC0gU2hvdWxkIGl0IGRlc3Ryb3kgdGhlIGN1cnJlbnQgdGV4dHVyZSBvZiB0aGUgc3ByaXRlIGFzIHdlbGwuXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmJhc2VUZXh0dXJlPWZhbHNlXSAtIFNob3VsZCBpdCBkZXN0cm95IHRoZSBiYXNlIHRleHR1cmUgb2YgdGhlIHNwcml0ZSBhcyB3ZWxsLlxyXG4gICAgICovXHJcbiAgICBkZXN0cm95KG9wdGlvbnMpIHtcclxuICAgICAgICB0aGlzLnN0b3AoKTtcclxuICAgICAgICBTcHJpdGVfMS5TcHJpdGUucHJvdG90eXBlLmRlc3Ryb3kuY2FsbCh0aGlzLCBvcHRpb25zKTtcclxuICAgICAgICB0aGlzLm9uQ29tcGxldGUgPSBudWxsO1xyXG4gICAgICAgIHRoaXMub25GcmFtZUNoYW5nZSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5vbkxvb3AgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBIHNob3J0IGhhbmQgd2F5IG9mIGNyZWF0aW5nIGEgbW92aWVjbGlwIGZyb20gYW4gYXJyYXkgb2YgZnJhbWUgaWRzLlxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IGZyYW1lcyAtIFRoZSBhcnJheSBvZiBmcmFtZXMgaWRzIHRoZSBtb3ZpZWNsaXAgd2lsbCB1c2UgYXMgaXRzIHRleHR1cmUgZnJhbWVzLlxyXG4gICAgICogQHJldHVybiB7QW5pbWF0ZWRTcHJpdGV9IFRoZSBuZXcgYW5pbWF0ZWQgc3ByaXRlIHdpdGggdGhlIHNwZWNpZmllZCBmcmFtZXMuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBmcm9tRnJhbWVzKGZyYW1lcykge1xyXG4gICAgICAgIHZhciB0ZXh0dXJlcyA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZnJhbWVzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgIHRleHR1cmVzLnB1c2goVGV4dHVyZV8xLlRleHR1cmUuZnJvbShmcmFtZXNbaV0pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBBbmltYXRlZFNwcml0ZSh0ZXh0dXJlcyk7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIEEgc2hvcnQgaGFuZCB3YXkgb2YgY3JlYXRpbmcgYSBtb3ZpZWNsaXAgZnJvbSBhbiBhcnJheSBvZiBpbWFnZSBpZHMuXHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gaW1hZ2VzIC0gVGhlIGFycmF5IG9mIGltYWdlIHVybHMgdGhlIG1vdmllY2xpcCB3aWxsIHVzZSBhcyBpdHMgdGV4dHVyZSBmcmFtZXMuXHJcbiAgICAgKiBAcmV0dXJuIHtBbmltYXRlZFNwcml0ZX0gVGhlIG5ldyBhbmltYXRlIHNwcml0ZSB3aXRoIHRoZSBzcGVjaWZpZWQgaW1hZ2VzIGFzIGZyYW1lcy5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGZyb21JbWFnZXMoaW1hZ2VzKSB7XHJcbiAgICAgICAgdmFyIHRleHR1cmVzID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbWFnZXMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgdGV4dHVyZXMucHVzaChUZXh0dXJlXzEuVGV4dHVyZS5mcm9tKGltYWdlc1tpXSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IEFuaW1hdGVkU3ByaXRlKHRleHR1cmVzKTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIHRvdGFsIG51bWJlciBvZiBmcmFtZXMgaW4gdGhlIEFuaW1hdGVkU3ByaXRlLiBUaGlzIGlzIHRoZSBzYW1lIGFzIG51bWJlciBvZiB0ZXh0dXJlc1xyXG4gICAgICogYXNzaWduZWQgdG8gdGhlIEFuaW1hdGVkU3ByaXRlLlxyXG4gICAgICpcclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICogQGRlZmF1bHQgMFxyXG4gICAgICovXHJcbiAgICBnZXQgdG90YWxGcmFtZXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RleHR1cmVzLmxlbmd0aDtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGFycmF5IG9mIHRleHR1cmVzIHVzZWQgZm9yIHRoaXMgQW5pbWF0ZWRTcHJpdGUuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7UElYSS5UZXh0dXJlW119XHJcbiAgICAgKi9cclxuICAgIGdldCB0ZXh0dXJlcygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fdGV4dHVyZXM7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICBzZXQgdGV4dHVyZXModmFsdWUpIHtcclxuICAgICAgICBpZiAodmFsdWVbMF0gaW5zdGFuY2VvZiBUZXh0dXJlXzEuVGV4dHVyZSkge1xyXG4gICAgICAgICAgICB0aGlzLl90ZXh0dXJlcyA9IHZhbHVlO1xyXG4gICAgICAgICAgICB0aGlzLl9kdXJhdGlvbnMgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5fdGV4dHVyZXMgPSBbXTtcclxuICAgICAgICAgICAgdGhpcy5fZHVyYXRpb25zID0gW107XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3RleHR1cmVzLnB1c2godmFsdWVbaV0udGV4dHVyZSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9kdXJhdGlvbnMucHVzaCh2YWx1ZVtpXS50aW1lKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmdvdG9BbmRTdG9wKDApO1xyXG4gICAgICAgIHRoaXMudXBkYXRlVGV4dHVyZSgpO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAqIFRoZSBBbmltYXRlZFNwcml0ZXMgY3VycmVudCBmcmFtZSBpbmRleC5cclxuICAgICpcclxuICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgKiBAcmVhZG9ubHlcclxuICAgICovXHJcbiAgICBnZXQgY3VycmVudEZyYW1lKCkge1xyXG4gICAgICAgIHZhciBjdXJyZW50RnJhbWUgPSBNYXRoLmZsb29yKHRoaXMuX2N1cnJlbnRUaW1lKSAlIHRoaXMuX3RleHR1cmVzLmxlbmd0aDtcclxuICAgICAgICBpZiAoY3VycmVudEZyYW1lIDwgMCkge1xyXG4gICAgICAgICAgICBjdXJyZW50RnJhbWUgKz0gdGhpcy5fdGV4dHVyZXMubGVuZ3RoO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY3VycmVudEZyYW1lO1xyXG4gICAgfVxyXG4gICAgO1xyXG59XHJcbmV4cG9ydHMuQW5pbWF0ZWRTcHJpdGUgPSBBbmltYXRlZFNwcml0ZTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgQ29udGFpbmVyXzEgPSByZXF1aXJlKFwiLi9Db250YWluZXJcIik7XHJcbmNvbnN0IFJlbmRlcmVyXzEgPSByZXF1aXJlKFwiLi9SZW5kZXJlclwiKTtcclxuY29uc3QgU3RhZ2VPcHRpb25zXzEgPSByZXF1aXJlKFwiLi9TdGFnZU9wdGlvbnNcIik7XHJcbmNvbnN0IFRpY2tlcl8xID0gcmVxdWlyZShcIi4vVGlja2VyXCIpO1xyXG5jb25zdCBBY2Nlc3NpYmlsaXR5TWFuYWdlcl8xID0gcmVxdWlyZShcIi4vQWNjZXNzaWJpbGl0eU1hbmFnZXJcIik7XHJcbmNvbnN0IEV4dHJhY3RfMSA9IHJlcXVpcmUoXCIuL0V4dHJhY3RcIik7XHJcbmNvbnN0IEludGVyYWN0aW9uTWFuYWdlcl8xID0gcmVxdWlyZShcIi4vSW50ZXJhY3Rpb25NYW5hZ2VyXCIpO1xyXG5jb25zdCBQYXJ0aWNsZVJlbmRlcmVyXzEgPSByZXF1aXJlKFwiLi9QYXJ0aWNsZVJlbmRlcmVyXCIpO1xyXG5jb25zdCBQcmVwYXJlXzEgPSByZXF1aXJlKFwiLi9QcmVwYXJlXCIpO1xyXG5jb25zdCBCYXRjaFJlbmRlcmVyXzEgPSByZXF1aXJlKFwiLi9CYXRjaFJlbmRlcmVyXCIpO1xyXG5jb25zdCBUaWxpbmdTcHJpdGVSZW5kZXJlcl8xID0gcmVxdWlyZShcIi4vVGlsaW5nU3ByaXRlUmVuZGVyZXJcIik7XHJcbmNsYXNzIEFwcGxpY2F0aW9uIHtcclxuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSBudWxsKSB7XHJcbiAgICAgICAgdGhpcy5yZXNpemUgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9yZXNpemVUbykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3Jlc2l6ZVRvID09PSB3aW5kb3cpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnJlc2l6ZSh3aW5kb3cuaW5uZXJXaWR0aCwgd2luZG93LmlubmVySGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIucmVzaXplKHRoaXMuX3Jlc2l6ZVRvWydjbGllbnRXaWR0aCddLCB0aGlzLl9yZXNpemVUb1snY2xpZW50SGVpZ2h0J10pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAoIW9wdGlvbnMpIHtcclxuICAgICAgICAgICAgb3B0aW9ucyA9IG5ldyBTdGFnZU9wdGlvbnNfMS5TdGFnZU9wdGlvbnMoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgUmVuZGVyZXJfMS5SZW5kZXJlci5yZWdpc3RlclBsdWdpbignYWNjZXNzaWJpbGl0eScsIEFjY2Vzc2liaWxpdHlNYW5hZ2VyXzEuQWNjZXNzaWJpbGl0eU1hbmFnZXIpO1xyXG4gICAgICAgIFJlbmRlcmVyXzEuUmVuZGVyZXIucmVnaXN0ZXJQbHVnaW4oJ2V4dHJhY3QnLCBFeHRyYWN0XzEuRXh0cmFjdCk7XHJcbiAgICAgICAgUmVuZGVyZXJfMS5SZW5kZXJlci5yZWdpc3RlclBsdWdpbignaW50ZXJhY3Rpb24nLCBJbnRlcmFjdGlvbk1hbmFnZXJfMS5JbnRlcmFjdGlvbk1hbmFnZXIpO1xyXG4gICAgICAgIFJlbmRlcmVyXzEuUmVuZGVyZXIucmVnaXN0ZXJQbHVnaW4oJ3BhcnRpY2xlJywgUGFydGljbGVSZW5kZXJlcl8xLlBhcnRpY2xlUmVuZGVyZXIpO1xyXG4gICAgICAgIFJlbmRlcmVyXzEuUmVuZGVyZXIucmVnaXN0ZXJQbHVnaW4oJ3ByZXBhcmUnLCBQcmVwYXJlXzEuUHJlcGFyZSk7XHJcbiAgICAgICAgUmVuZGVyZXJfMS5SZW5kZXJlci5yZWdpc3RlclBsdWdpbignYmF0Y2gnLCBCYXRjaFJlbmRlcmVyXzEuQmF0Y2hSZW5kZXJlcik7XHJcbiAgICAgICAgUmVuZGVyZXJfMS5SZW5kZXJlci5yZWdpc3RlclBsdWdpbigndGlsaW5nU3ByaXRlJywgVGlsaW5nU3ByaXRlUmVuZGVyZXJfMS5UaWxpbmdTcHJpdGVSZW5kZXJlcik7XHJcbiAgICAgICAgLy8gdGhpcy5sb2FkZXIgPSAvKm9wdGlvbnMuc2hhcmVkTG9hZGVyID8gTG9hZGVyLnNoYXJlZCA6ICovbmV3IExvYWRlcigpO1xyXG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSBuZXcgUmVuZGVyZXJfMS5SZW5kZXJlcihvcHRpb25zKTsgLy9BcHBsaWNhdGlvbi5hdXRvRGV0ZWN0UmVuZGVyZXIob3B0aW9ucyk7XHJcbiAgICAgICAgdGhpcy5fc3RhZ2UgPSBuZXcgQ29udGFpbmVyXzEuQ29udGFpbmVyKCk7XHJcbiAgICAgICAgdGhpcy50aWNrZXIgPSBvcHRpb25zLnNoYXJlZFRpY2tlciA/IFRpY2tlcl8xLlRpY2tlci5zaGFyZWQgOiBuZXcgVGlja2VyXzEuVGlja2VyKCk7XHJcbiAgICAgICAgdGhpcy5yZXNpemVUbyA9IHdpbmRvdztcclxuICAgICAgICAvLyBEaXNwbGF5T2JqZWN0Lm1peGluKGludGVyYWN0aXZlVGFyZ2V0KTtcclxuICAgICAgICBpZiAob3B0aW9ucy5hdXRvU3RhcnQpIHtcclxuICAgICAgICAgICAgdGhpcy5zdGFydCgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGdldCB0aWNrZXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RpY2tlcjtcclxuICAgIH1cclxuICAgIHNldCB0aWNrZXIodGlja2VyKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3RpY2tlcikge1xyXG4gICAgICAgICAgICB0aGlzLl90aWNrZXIucmVtb3ZlKHRoaXMucmVuZGVyLCB0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fdGlja2VyID0gdGlja2VyO1xyXG4gICAgICAgIGlmICh0aWNrZXIpIHtcclxuICAgICAgICAgICAgdGlja2VyLmFkZCh0aGlzLnJlbmRlciwgdGhpcywgVGlja2VyXzEuVGlja2VyLlVQREFURV9QUklPUklUWS5MT1cpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHN0YXJ0KCkge1xyXG4gICAgICAgIHRoaXMuX3RpY2tlci5zdGFydCgpO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgc3RvcCgpIHtcclxuICAgICAgICB0aGlzLl90aWNrZXIuc3RvcCgpO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgZ2V0IHJlc2l6ZVRvKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9yZXNpemVUbztcclxuICAgIH1cclxuICAgIHNldCByZXNpemVUbyh2YWx1ZSkge1xyXG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLnJlc2l6ZSk7XHJcbiAgICAgICAgdGhpcy5fcmVzaXplVG8gPSB2YWx1ZTtcclxuICAgICAgICBpZiAodmFsdWUpIHtcclxuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMucmVzaXplKTtcclxuICAgICAgICAgICAgdGhpcy5yZXNpemUoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZW5kZXIoKSB7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJlci5yZW5kZXIodGhpcy5fc3RhZ2UpO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgZ2V0IHN0YWdlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9zdGFnZTtcclxuICAgIH1cclxuICAgIGdldCB2aWV3KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJlbmRlcmVyLnZpZXc7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICBnZXQgc2NyZWVuKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJlbmRlcmVyLnNjcmVlbjtcclxuICAgIH1cclxuICAgIDtcclxuICAgIGRlc3Ryb3kob3B0aW9ucyA9IG51bGwpIHtcclxuICAgICAgICB0aGlzLl9zdGFnZS5kZXN0cm95KG9wdGlvbnMpO1xyXG4gICAgICAgIHRoaXMuX3N0YWdlID0gbnVsbDtcclxuICAgICAgICB0aGlzLnJlbmRlcmVyLmRlc3Ryb3kob3B0aW9ucyk7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5fb3B0aW9ucyA9IG51bGw7XHJcbiAgICAgICAgLy8gaWYgKHRoaXMubG9hZGVyKVxyXG4gICAgICAgIC8vIHtcclxuICAgICAgICAvLyAgICAgdGhpcy5sb2FkZXIuZGVzdHJveSgpO1xyXG4gICAgICAgIC8vICAgICB0aGlzLmxvYWRlciA9IG51bGw7XHJcbiAgICAgICAgLy8gfVxyXG4gICAgfVxyXG4gICAgO1xyXG59XHJcbmV4cG9ydHMuQXBwbGljYXRpb24gPSBBcHBsaWNhdGlvbjtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3Qgc2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL3NldHRpbmdzXCIpO1xyXG5jb25zdCBNYXRoU2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL01hdGhTZXR0aW5nc1wiKTtcclxuY2xhc3MgQXJjVXRpbHMge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgY3VydmVUbyh4MSwgeTEsIHgyLCB5MiwgcmFkaXVzLCBwb2ludHMpIHtcclxuICAgICAgICB2YXIgZnJvbVggPSBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDJdO1xyXG4gICAgICAgIHZhciBmcm9tWSA9IHBvaW50c1twb2ludHMubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgdmFyIGExID0gZnJvbVkgLSB5MTtcclxuICAgICAgICB2YXIgYjEgPSBmcm9tWCAtIHgxO1xyXG4gICAgICAgIHZhciBhMiA9IHkyIC0geTE7XHJcbiAgICAgICAgdmFyIGIyID0geDIgLSB4MTtcclxuICAgICAgICB2YXIgbW0gPSBNYXRoLmFicygoYTEgKiBiMikgLSAoYjEgKiBhMikpO1xyXG4gICAgICAgIGlmIChtbSA8IDEuMGUtOCB8fCByYWRpdXMgPT09IDApIHtcclxuICAgICAgICAgICAgaWYgKHBvaW50c1twb2ludHMubGVuZ3RoIC0gMl0gIT09IHgxIHx8IHBvaW50c1twb2ludHMubGVuZ3RoIC0gMV0gIT09IHkxKSB7XHJcbiAgICAgICAgICAgICAgICBwb2ludHMucHVzaCh4MSwgeTEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgZGQgPSAoYTEgKiBhMSkgKyAoYjEgKiBiMSk7XHJcbiAgICAgICAgdmFyIGNjID0gKGEyICogYTIpICsgKGIyICogYjIpO1xyXG4gICAgICAgIHZhciB0dCA9IChhMSAqIGEyKSArIChiMSAqIGIyKTtcclxuICAgICAgICB2YXIgazEgPSByYWRpdXMgKiBNYXRoLnNxcnQoZGQpIC8gbW07XHJcbiAgICAgICAgdmFyIGsyID0gcmFkaXVzICogTWF0aC5zcXJ0KGNjKSAvIG1tO1xyXG4gICAgICAgIHZhciBqMSA9IGsxICogdHQgLyBkZDtcclxuICAgICAgICB2YXIgajIgPSBrMiAqIHR0IC8gY2M7XHJcbiAgICAgICAgdmFyIGN4ID0gKGsxICogYjIpICsgKGsyICogYjEpO1xyXG4gICAgICAgIHZhciBjeSA9IChrMSAqIGEyKSArIChrMiAqIGExKTtcclxuICAgICAgICB2YXIgcHggPSBiMSAqIChrMiArIGoxKTtcclxuICAgICAgICB2YXIgcHkgPSBhMSAqIChrMiArIGoxKTtcclxuICAgICAgICB2YXIgcXggPSBiMiAqIChrMSArIGoyKTtcclxuICAgICAgICB2YXIgcXkgPSBhMiAqIChrMSArIGoyKTtcclxuICAgICAgICB2YXIgc3RhcnRBbmdsZSA9IE1hdGguYXRhbjIocHkgLSBjeSwgcHggLSBjeCk7XHJcbiAgICAgICAgdmFyIGVuZEFuZ2xlID0gTWF0aC5hdGFuMihxeSAtIGN5LCBxeCAtIGN4KTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBjeDogKGN4ICsgeDEpLFxyXG4gICAgICAgICAgICBjeTogKGN5ICsgeTEpLFxyXG4gICAgICAgICAgICByYWRpdXM6IHJhZGl1cyxcclxuICAgICAgICAgICAgc3RhcnRBbmdsZTogc3RhcnRBbmdsZSxcclxuICAgICAgICAgICAgZW5kQW5nbGU6IGVuZEFuZ2xlLFxyXG4gICAgICAgICAgICBhbnRpY2xvY2t3aXNlOiAoYjEgKiBhMiA+IGIyICogYTEpLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBhcmMgbWV0aG9kIGNyZWF0ZXMgYW4gYXJjL2N1cnZlICh1c2VkIHRvIGNyZWF0ZSBjaXJjbGVzLCBvciBwYXJ0cyBvZiBjaXJjbGVzKS5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0WCAtIFN0YXJ0IHggbG9jYXRpb24gb2YgYXJjXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnRZIC0gU3RhcnQgeSBsb2NhdGlvbiBvZiBhcmNcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjeCAtIFRoZSB4LWNvb3JkaW5hdGUgb2YgdGhlIGNlbnRlciBvZiB0aGUgY2lyY2xlXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY3kgLSBUaGUgeS1jb29yZGluYXRlIG9mIHRoZSBjZW50ZXIgb2YgdGhlIGNpcmNsZVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJhZGl1cyAtIFRoZSByYWRpdXMgb2YgdGhlIGNpcmNsZVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0QW5nbGUgLSBUaGUgc3RhcnRpbmcgYW5nbGUsIGluIHJhZGlhbnMgKDAgaXMgYXQgdGhlIDMgbydjbG9jayBwb3NpdGlvblxyXG4gICAgICogIG9mIHRoZSBhcmMncyBjaXJjbGUpXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZW5kQW5nbGUgLSBUaGUgZW5kaW5nIGFuZ2xlLCBpbiByYWRpYW5zXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGFudGljbG9ja3dpc2UgLSBTcGVjaWZpZXMgd2hldGhlciB0aGUgZHJhd2luZyBzaG91bGQgYmVcclxuICAgICAqICBjb3VudGVyLWNsb2Nrd2lzZSBvciBjbG9ja3dpc2UuIEZhbHNlIGlzIGRlZmF1bHQsIGFuZCBpbmRpY2F0ZXMgY2xvY2t3aXNlLCB3aGlsZSB0cnVlXHJcbiAgICAgKiAgaW5kaWNhdGVzIGNvdW50ZXItY2xvY2t3aXNlLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG4gLSBOdW1iZXIgb2Ygc2VnbWVudHNcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyW119IHBvaW50cyAtIENvbGxlY3Rpb24gb2YgcG9pbnRzIHRvIGFkZCB0b1xyXG4gICAgICovXHJcbiAgICBzdGF0aWMgYXJjKHN0YXJ0WCwgc3RhcnRZLCBjeCwgY3ksIHJhZGl1cywgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGFudGljbG9ja3dpc2UsIHBvaW50cykge1xyXG4gICAgICAgIHZhciBzd2VlcCA9IGVuZEFuZ2xlIC0gc3RhcnRBbmdsZTtcclxuICAgICAgICB2YXIgbiA9IHNldHRpbmdzXzEuc2V0dGluZ3MuR1JBUEhJQ1NfQ1VSVkVTLl9zZWdtZW50c0NvdW50KE1hdGguYWJzKHN3ZWVwKSAqIHJhZGl1cywgTWF0aC5jZWlsKE1hdGguYWJzKHN3ZWVwKSAvIE1hdGhTZXR0aW5nc18xLk1hdGhTZXR0aW5ncy5QSV8yKSAqIDQwKTtcclxuICAgICAgICB2YXIgdGhldGEgPSAoc3dlZXApIC8gKG4gKiAyKTtcclxuICAgICAgICB2YXIgdGhldGEyID0gdGhldGEgKiAyO1xyXG4gICAgICAgIHZhciBjVGhldGEgPSBNYXRoLmNvcyh0aGV0YSk7XHJcbiAgICAgICAgdmFyIHNUaGV0YSA9IE1hdGguc2luKHRoZXRhKTtcclxuICAgICAgICB2YXIgc2VnTWludXMgPSBuIC0gMTtcclxuICAgICAgICB2YXIgcmVtYWluZGVyID0gKHNlZ01pbnVzICUgMSkgLyBzZWdNaW51cztcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8PSBzZWdNaW51czsgKytpKSB7XHJcbiAgICAgICAgICAgIHZhciByZWFsID0gaSArIChyZW1haW5kZXIgKiBpKTtcclxuICAgICAgICAgICAgdmFyIGFuZ2xlID0gKCh0aGV0YSkgKyBzdGFydEFuZ2xlICsgKHRoZXRhMiAqIHJlYWwpKTtcclxuICAgICAgICAgICAgdmFyIGMgPSBNYXRoLmNvcyhhbmdsZSk7XHJcbiAgICAgICAgICAgIHZhciBzID0gLU1hdGguc2luKGFuZ2xlKTtcclxuICAgICAgICAgICAgcG9pbnRzLnB1c2goKCgoY1RoZXRhICogYykgKyAoc1RoZXRhICogcykpICogcmFkaXVzKSArIGN4LCAoKChjVGhldGEgKiAtcykgKyAoc1RoZXRhICogYykpICogcmFkaXVzKSArIGN5KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICA7XHJcbn1cclxuZXhwb3J0cy5BcmNVdGlscyA9IEFyY1V0aWxzO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBSZXNvdXJjZV8xID0gcmVxdWlyZShcIi4vUmVzb3VyY2VcIik7XHJcbmNvbnN0IEJhc2VUZXh0dXJlXzEgPSByZXF1aXJlKFwiLi9CYXNlVGV4dHVyZVwiKTtcclxuY29uc3QgUmVzb3VyY2VTZXR0aW5nc18xID0gcmVxdWlyZShcIi4vUmVzb3VyY2VTZXR0aW5nc1wiKTtcclxuY29uc3QgV2ViR0xTZXR0aW5nc18xID0gcmVxdWlyZShcIi4vV2ViR0xTZXR0aW5nc1wiKTtcclxuY2xhc3MgQXJyYXlSZXNvdXJjZSBleHRlbmRzIFJlc291cmNlXzEuUmVzb3VyY2Uge1xyXG4gICAgY29uc3RydWN0b3Ioc291cmNlLCBvcHRpb25zKSB7XHJcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcbiAgICAgICAgdmFyIHVybHM7XHJcbiAgICAgICAgdmFyIGxlbmd0aCA9IHNvdXJjZTtcclxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzb3VyY2UpKSB7XHJcbiAgICAgICAgICAgIHVybHMgPSBzb3VyY2U7XHJcbiAgICAgICAgICAgIGxlbmd0aCA9IHNvdXJjZS5sZW5ndGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN1cGVyKG9wdGlvbnMud2lkdGgsIG9wdGlvbnMuaGVpZ2h0KTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb2xsZWN0aW9uIG9mIHJlc291cmNlcy5cclxuICAgICAgICAgKiBAbWVtYmVyIHtBcnJheTxQSVhJLkJhc2VUZXh0dXJlPn1cclxuICAgICAgICAgKiBAcmVhZG9ubHlcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLml0ZW1zID0gW107XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRGlydHkgSURzIGZvciBlYWNoIHBhcnRcclxuICAgICAgICAgKiBAbWVtYmVyIHtBcnJheTxudW1iZXI+fVxyXG4gICAgICAgICAqIEByZWFkb25seVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuaXRlbURpcnR5SWRzID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgcGFydFRleHR1cmUgPSBuZXcgQmFzZVRleHR1cmVfMS5CYXNlVGV4dHVyZSgpO1xyXG4gICAgICAgICAgICB0aGlzLml0ZW1zLnB1c2gocGFydFRleHR1cmUpO1xyXG4gICAgICAgICAgICB0aGlzLml0ZW1EaXJ0eUlkcy5wdXNoKC0xKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogTnVtYmVyIG9mIGVsZW1lbnRzIGluIGFycmF5XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgICAgICogQHJlYWRvbmx5XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5sZW5ndGggPSBsZW5ndGg7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUHJvbWlzZSB3aGVuIGxvYWRpbmdcclxuICAgICAgICAgKiBAbWVtYmVyIHtQcm9taXNlfVxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICogQGRlZmF1bHQgbnVsbFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuX2xvYWQgPSBudWxsO1xyXG4gICAgICAgIGlmICh1cmxzKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGxlbmd0aDsgaSQxKyspIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYWRkUmVzb3VyY2VBdChSZXNvdXJjZVNldHRpbmdzXzEuUmVzb3VyY2VTZXR0aW5ncy5hdXRvRGV0ZWN0UmVzb3VyY2UodXJsc1tpJDFdLCBvcHRpb25zKSwgaSQxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRGVzdHJveSB0aGlzIEJhc2VJbWFnZVJlc291cmNlXHJcbiAgICAgKiBAb3ZlcnJpZGVcclxuICAgICAqL1xyXG4gICAgZGlzcG9zZSgpIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICB0aGlzLml0ZW1zW2ldLmRlc3Ryb3koKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5pdGVtcyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5pdGVtRGlydHlJZHMgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuX2xvYWQgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgYSByZXNvdXJjZSBieSBJRFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7UElYSS5yZXNvdXJjZXMuUmVzb3VyY2V9IHJlc291cmNlXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggLSBaZXJvLWJhc2VkIGluZGV4IG9mIHJlc291cmNlIHRvIHNldFxyXG4gICAgICogQHJldHVybiB7UElYSS5yZXNvdXJjZXMuQXJyYXlSZXNvdXJjZX0gSW5zdGFuY2UgZm9yIGNoYWluaW5nXHJcbiAgICAgKi9cclxuICAgIGFkZFJlc291cmNlQXQocmVzb3VyY2UsIGluZGV4KSB7XHJcbiAgICAgICAgdmFyIGJhc2VUZXh0dXJlID0gdGhpcy5pdGVtc1tpbmRleF07XHJcbiAgICAgICAgaWYgKCFiYXNlVGV4dHVyZSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKFwiSW5kZXggXCIgKyBpbmRleCArIFwiIGlzIG91dCBvZiBib3VuZHNcIikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBJbmhlcml0IHRoZSBmaXJzdCByZXNvdXJjZSBkaW1lbnNpb25zXHJcbiAgICAgICAgaWYgKHJlc291cmNlLnZhbGlkICYmICF0aGlzLnZhbGlkKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVzaXplKHJlc291cmNlLndpZHRoLCByZXNvdXJjZS5oZWlnaHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLml0ZW1zW2luZGV4XS5zZXRSZXNvdXJjZShyZXNvdXJjZSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFNldCB0aGUgcGFyZW50IGJhc2UgdGV4dHVyZVxyXG4gICAgICogQG1lbWJlciB7UElYSS5CYXNlVGV4dHVyZX1cclxuICAgICAqIEBvdmVycmlkZVxyXG4gICAgICovXHJcbiAgICBiaW5kKGJhc2VUZXh0dXJlKSB7XHJcbiAgICAgICAgc3VwZXIuYmluZChiYXNlVGV4dHVyZSk7XHJcbiAgICAgICAgYmFzZVRleHR1cmUudGFyZ2V0ID0gV2ViR0xTZXR0aW5nc18xLldlYkdMU2V0dGluZ3MuVEFSR0VUUy5URVhUVVJFXzJEX0FSUkFZO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB0aGlzLml0ZW1zW2ldLm9uKCd1cGRhdGUnLCBiYXNlVGV4dHVyZS51cGRhdGUsIGJhc2VUZXh0dXJlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFVuc2V0IHRoZSBwYXJlbnQgYmFzZSB0ZXh0dXJlXHJcbiAgICAgKiBAbWVtYmVyIHtQSVhJLkJhc2VUZXh0dXJlfVxyXG4gICAgICogQG92ZXJyaWRlXHJcbiAgICAgKi9cclxuICAgIHVuYmluZChiYXNlVGV4dHVyZSkge1xyXG4gICAgICAgIHN1cGVyLnVuYmluZChiYXNlVGV4dHVyZSk7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaXRlbXNbaV0ub2ZmKCd1cGRhdGUnLCBiYXNlVGV4dHVyZS51cGRhdGUsIGJhc2VUZXh0dXJlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIExvYWQgYWxsIHRoZSByZXNvdXJjZXMgc2ltdWx0YW5lb3VzbHlcclxuICAgICAqIEBvdmVycmlkZVxyXG4gICAgICogQHJldHVybiB7UHJvbWlzZTx2b2lkPn0gV2hlbiBsb2FkIGlzIHJlc29sdmVkXHJcbiAgICAgKi9cclxuICAgIGxvYWQoKSB7XHJcbiAgICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XHJcbiAgICAgICAgaWYgKHRoaXMuX2xvYWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xvYWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciByZXNvdXJjZXMgPSB0aGlzLml0ZW1zLm1hcChmdW5jdGlvbiAoaXRlbSkgeyByZXR1cm4gaXRlbS5yZXNvdXJjZTsgfSk7XHJcbiAgICAgICAgLy8gVE9ETzogYWxzbyBpbXBsZW1lbnQgbG9hZCBwYXJ0LWJ5LXBhcnQgc3RyYXRlZ3lcclxuICAgICAgICB2YXIgcHJvbWlzZXMgPSByZXNvdXJjZXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiBpdGVtLmxvYWQoKTsgfSk7XHJcbiAgICAgICAgdGhpcy5fbG9hZCA9IFByb21pc2UuYWxsKHByb21pc2VzKVxyXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciByZWYgPSByZXNvdXJjZXNbMF07XHJcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IHJlZi53aWR0aDtcclxuICAgICAgICAgICAgdmFyIGhlaWdodCA9IHJlZi5oZWlnaHQ7XHJcbiAgICAgICAgICAgIHRoaXMkMS5yZXNpemUod2lkdGgsIGhlaWdodCk7XHJcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcyQxKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbG9hZDtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogVXBsb2FkIHRoZSByZXNvdXJjZXMgdG8gdGhlIEdQVS5cclxuICAgICAqIEBwYXJhbSB7UElYSS5SZW5kZXJlcn0gcmVuZGVyZXJcclxuICAgICAqIEBwYXJhbSB7UElYSS5CYXNlVGV4dHVyZX0gdGV4dHVyZVxyXG4gICAgICogQHBhcmFtIHtQSVhJLkdMVGV4dHVyZX0gZ2xUZXh0dXJlXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gd2hldGhlciB0ZXh0dXJlIHdhcyB1cGxvYWRlZFxyXG4gICAgICovXHJcbiAgICB1cGxvYWQocmVuZGVyZXIsIHRleHR1cmUsIGdsVGV4dHVyZSkge1xyXG4gICAgICAgIHZhciByZWYgPSB0aGlzO1xyXG4gICAgICAgIHZhciBsZW5ndGggPSByZWYubGVuZ3RoO1xyXG4gICAgICAgIHZhciBpdGVtRGlydHlJZHMgPSByZWYuaXRlbURpcnR5SWRzO1xyXG4gICAgICAgIHZhciBpdGVtcyA9IHJlZi5pdGVtcztcclxuICAgICAgICB2YXIgZ2wgPSByZW5kZXJlci5nbDtcclxuICAgICAgICBpZiAoZ2xUZXh0dXJlLmRpcnR5SWQgPCAwKSB7XHJcbiAgICAgICAgICAgIGdsLnRleEltYWdlM0QoZ2wuVEVYVFVSRV8yRF9BUlJBWSwgMCwgdGV4dHVyZS5mb3JtYXQsIHRoaXMuX3dpZHRoLCB0aGlzLl9oZWlnaHQsIGxlbmd0aCwgMCwgdGV4dHVyZS5mb3JtYXQsIHRleHR1cmUudHlwZSwgbnVsbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIGl0ZW0gPSBpdGVtc1tpXTtcclxuICAgICAgICAgICAgaWYgKGl0ZW1EaXJ0eUlkc1tpXSA8IGl0ZW0uZGlydHlJZCkge1xyXG4gICAgICAgICAgICAgICAgaXRlbURpcnR5SWRzW2ldID0gaXRlbS5kaXJ0eUlkO1xyXG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0udmFsaWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBnbC50ZXhTdWJJbWFnZTNEKGdsLlRFWFRVUkVfMkRfQVJSQVksIDAsIDAsIC8vIHhvZmZzZXRcclxuICAgICAgICAgICAgICAgICAgICAwLCAvLyB5b2Zmc2V0XHJcbiAgICAgICAgICAgICAgICAgICAgaSwgLy8gem9mZnNldFxyXG4gICAgICAgICAgICAgICAgICAgIGl0ZW0ucmVzb3VyY2Uud2lkdGgsIGl0ZW0ucmVzb3VyY2UuaGVpZ2h0LCAxLCB0ZXh0dXJlLmZvcm1hdCwgdGV4dHVyZS50eXBlLCBpdGVtLnJlc291cmNlLnNvdXJjZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICA7XHJcbn1cclxuZXhwb3J0cy5BcnJheVJlc291cmNlID0gQXJyYXlSZXNvdXJjZTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgTG9nZ2VyXzEgPSByZXF1aXJlKFwiLi8vTG9nZ2VyXCIpO1xyXG5jbGFzcyBBdHRyaWJ1dGUge1xyXG4gICAgY29uc3RydWN0b3IoYnVmZmVyLCBzaXplLCBub3JtYWxpemVkID0gZmFsc2UsIHR5cGUgPSA1MTI2LCBzdHJpZGUgPSB1bmRlZmluZWQsIHN0YXJ0ID0gdW5kZWZpbmVkLCBpbnN0YW5jZSA9IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHRoaXMuYnVmZmVyID0gYnVmZmVyO1xyXG4gICAgICAgIHRoaXMuc2l6ZSA9IHNpemU7XHJcbiAgICAgICAgdGhpcy5ub3JtYWxpemVkID0gbm9ybWFsaXplZDtcclxuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xyXG4gICAgICAgIHRoaXMuX3N0cmlkZSA9IHN0cmlkZTtcclxuICAgICAgICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XHJcbiAgICAgICAgdGhpcy5pbnN0YW5jZSA9IGluc3RhbmNlO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgc2V0IHN0cmlkZSh2YWx1ZSkge1xyXG4gICAgICAgIExvZ2dlcl8xLnRyYWNlKFwic2V0IHRvIFwiICsgdmFsdWUpO1xyXG4gICAgICAgIHRoaXMuX3N0cmlkZSA9IHZhbHVlO1xyXG4gICAgfVxyXG4gICAgZ2V0IHN0cmlkZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fc3RyaWRlO1xyXG4gICAgfVxyXG4gICAgZGVzdHJveShvcHRpb25zID0gbnVsbCkge1xyXG4gICAgICAgIHRoaXMuYnVmZmVyID0gbnVsbDtcclxuICAgIH1cclxuICAgIDtcclxufVxyXG5leHBvcnRzLkF0dHJpYnV0ZSA9IEF0dHJpYnV0ZTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgUmVzb3VyY2VfMSA9IHJlcXVpcmUoXCIuL1Jlc291cmNlXCIpO1xyXG5jb25zdCBOZXR3b3JrU2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL05ldHdvcmtTZXR0aW5nc1wiKTtcclxuY29uc3QgTG9nZ2VyXzEgPSByZXF1aXJlKFwiLi9Mb2dnZXJcIik7XHJcbmNsYXNzIEJhc2VJbWFnZVJlc291cmNlIGV4dGVuZHMgUmVzb3VyY2VfMS5SZXNvdXJjZSB7XHJcbiAgICBjb25zdHJ1Y3Rvcihzb3VyY2UpIHtcclxuICAgICAgICBzdXBlcihzb3VyY2Uud2lkdGgsIHNvdXJjZS5oZWlnaHQpO1xyXG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgY3Jvc3Mgb3JpZ2luIGJhc2VkIGRldGVjdGluZyB0aGUgdXJsIGFuZCB0aGUgY3Jvc3NvcmlnaW5cclxuICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgLSBFbGVtZW50IHRvIGFwcGx5IGNyb3NzT3JpZ2luXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsIC0gVVJMIHRvIGNoZWNrXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW58c3RyaW5nfSBbY3Jvc3NvcmlnaW49dHJ1ZV0gLSBDcm9zcyBvcmlnaW4gdmFsdWUgdG8gdXNlXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBjcm9zc09yaWdpbihlbGVtZW50LCB1cmwsIGNyb3Nzb3JpZ2luKSB7XHJcbiAgICAgICAgaWYgKGNyb3Nzb3JpZ2luID09PSB1bmRlZmluZWQgJiYgdXJsLmluZGV4T2YoJ2RhdGE6JykgIT09IDApIHtcclxuICAgICAgICAgICAgZWxlbWVudC5jcm9zc09yaWdpbiA9IE5ldHdvcmtTZXR0aW5nc18xLk5ldHdvcmtTZXR0aW5ncy5kZXRlcm1pbmVDcm9zc09yaWdpbih1cmwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChjcm9zc29yaWdpbiAhPT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgZWxlbWVudC5jcm9zc09yaWdpbiA9IHR5cGVvZiBjcm9zc29yaWdpbiA9PT0gJ3N0cmluZycgPyBjcm9zc29yaWdpbiA6ICdhbm9ueW1vdXMnO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogVXBsb2FkIHRoZSB0ZXh0dXJlIHRvIHRoZSBHUFUuXHJcbiAgICAgKiBAcGFyYW0ge1BJWEkuUmVuZGVyZXJ9IHJlbmRlcmVyIFVwbG9hZCB0byB0aGUgcmVuZGVyZXJcclxuICAgICAqIEBwYXJhbSB7UElYSS5CYXNlVGV4dHVyZX0gYmFzZVRleHR1cmUgUmVmZXJlbmNlIHRvIHBhcmVudCB0ZXh0dXJlXHJcbiAgICAgKiBAcGFyYW0ge1BJWEkuR0xUZXh0dXJlfSBnbFRleHR1cmVcclxuICAgICAqIEBwYXJhbSB7SFRNTEltYWdlRWxlbWVudHxIVE1MQ2FudmFzRWxlbWVudHxIVE1MVmlkZW9FbGVtZW50fFNWR0VsZW1lbnR9IFtzb3VyY2VdIChvcHRpb25hbClcclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlzIHN1Y2Nlc3NcclxuICAgICAqL1xyXG4gICAgdXBsb2FkKHJlbmRlcmVyLCBiYXNlVGV4dHVyZSwgZ2xUZXh0dXJlLCBzb3VyY2UgPSBudWxsKSB7XHJcbiAgICAgICAgdmFyIGdsID0gcmVuZGVyZXIuZ2w7XHJcbiAgICAgICAgdmFyIHdpZHRoID0gYmFzZVRleHR1cmUucmVhbFdpZHRoO1xyXG4gICAgICAgIHZhciBoZWlnaHQgPSBiYXNlVGV4dHVyZS5yZWFsSGVpZ2h0O1xyXG4gICAgICAgIHNvdXJjZSA9IHNvdXJjZSB8fCB0aGlzLnNvdXJjZTtcclxuICAgICAgICBMb2dnZXJfMS50cmFjZShcInVwZGF0ZSB1cGxvYWQgXCIgKyBiYXNlVGV4dHVyZS50eXBlKTtcclxuICAgICAgICBnbC5waXhlbFN0b3JlaShnbC5VTlBBQ0tfUFJFTVVMVElQTFlfQUxQSEFfV0VCR0wsIGJhc2VUZXh0dXJlLnByZW11bHRpcGx5QWxwaGEpO1xyXG4gICAgICAgIGlmIChiYXNlVGV4dHVyZS50YXJnZXQgPT09IGdsLlRFWFRVUkVfMkQgJiYgZ2xUZXh0dXJlLndpZHRoID09PSB3aWR0aCAmJiBnbFRleHR1cmUuaGVpZ2h0ID09PSBoZWlnaHQpIHtcclxuICAgICAgICAgICAgLy8gdHJhY2UoXCJ1cGRhdGUgdXBsb2FkIFwiICsgZ2xUZXh0dXJlLndpZHRoICsgXCI6XCIgKyBnbFRleHR1cmUuaGVpZ2h0KVxyXG4gICAgICAgICAgICBnbC50ZXhTdWJJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIDAsIDAsIGJhc2VUZXh0dXJlLmZvcm1hdCwgYmFzZVRleHR1cmUudHlwZSwgc291cmNlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGdsVGV4dHVyZS53aWR0aCA9IHdpZHRoO1xyXG4gICAgICAgICAgICBnbFRleHR1cmUuaGVpZ2h0ID0gaGVpZ2h0O1xyXG4gICAgICAgICAgICBMb2dnZXJfMS50cmFjZShcImZpcnN0IHVwbG9hZCBcIiArIHdpZHRoICsgXCI6XCIgKyBoZWlnaHQpO1xyXG4gICAgICAgICAgICBnbC50ZXhJbWFnZTJEKGJhc2VUZXh0dXJlLnRhcmdldCwgMCwgYmFzZVRleHR1cmUuZm9ybWF0LCBiYXNlVGV4dHVyZS5mb3JtYXQsIGJhc2VUZXh0dXJlLnR5cGUsIHNvdXJjZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBEZXN0cm95IHRoaXMgQmFzZUltYWdlUmVzb3VyY2VcclxuICAgICAqIEBvdmVycmlkZVxyXG4gICAgICogQHBhcmFtIHtQSVhJLkJhc2VUZXh0dXJlfSBbZnJvbVRleHR1cmVdIE9wdGlvbmFsIGJhc2UgdGV4dHVyZVxyXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gRGVzdHJveSB3YXMgc3VjY2Vzc2Z1bFxyXG4gICAgICovXHJcbiAgICBkaXNwb3NlKCkge1xyXG4gICAgICAgIHRoaXMuc291cmNlID0gbnVsbDtcclxuICAgIH1cclxuICAgIDtcclxufVxyXG5leHBvcnRzLkJhc2VJbWFnZVJlc291cmNlID0gQmFzZUltYWdlUmVzb3VyY2U7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IFRpY2tlcl8xID0gcmVxdWlyZShcIi4vVGlja2VyXCIpO1xyXG5jb25zdCBDb250YWluZXJfMSA9IHJlcXVpcmUoXCIuL0NvbnRhaW5lclwiKTtcclxuY29uc3QgVGV4dFN0eWxlXzEgPSByZXF1aXJlKFwiLi9UZXh0U3R5bGVcIik7XHJcbmNvbnN0IFRleHRfMSA9IHJlcXVpcmUoXCIuL1RleHRcIik7XHJcbmNvbnN0IFRleHR1cmVfMSA9IHJlcXVpcmUoXCIuL1RleHR1cmVcIik7XHJcbmNvbnN0IEJhc2VUZXh0dXJlXzEgPSByZXF1aXJlKFwiLi9CYXNlVGV4dHVyZVwiKTtcclxuY29uc3QgVGV4dE1ldHJpY3NfMSA9IHJlcXVpcmUoXCIuL1RleHRNZXRyaWNzXCIpO1xyXG5jb25zdCBDb3VudExpbWl0ZXJfMSA9IHJlcXVpcmUoXCIuL0NvdW50TGltaXRlclwiKTtcclxuY29uc3QgV2ViR0xTZXR0aW5nc18xID0gcmVxdWlyZShcIi4vV2ViR0xTZXR0aW5nc1wiKTtcclxuY2xhc3MgQmFzZVByZXBhcmUgLy9leHRlbmRzIFJlbmRlcmVyXHJcbiB7XHJcbiAgICBjb25zdHJ1Y3RvcihyZW5kZXJlcikge1xyXG4gICAgICAgIC8vIHN1cGVyKG51bGwpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBsaW1pdGVyIHRvIGJlIHVzZWQgdG8gY29udHJvbCBob3cgcXVpY2tseSBpdGVtcyBhcmUgcHJlcGFyZWQuXHJcbiAgICAgICAgICogQHR5cGUge1BJWEkucHJlcGFyZS5Db3VudExpbWl0ZXJ8UElYSS5wcmVwYXJlLlRpbWVMaW1pdGVyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMubGltaXRlciA9IG5ldyBDb3VudExpbWl0ZXJfMS5Db3VudExpbWl0ZXIoV2ViR0xTZXR0aW5nc18xLldlYkdMU2V0dGluZ3MuVVBMT0FEU19QRVJfRlJBTUUpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlZmVyZW5jZSB0byB0aGUgcmVuZGVyZXIuXHJcbiAgICAgICAgICogQHR5cGUge1BJWEkuQWJzdHJhY3RSZW5kZXJlcn1cclxuICAgICAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBvbmx5IHJlYWwgZGlmZmVyZW5jZSBiZXR3ZWVuIENhbnZhc1ByZXBhcmUgYW5kIFdlYkdMUHJlcGFyZSBpcyB3aGF0IHRoZXkgcGFzc1xyXG4gICAgICAgICAqIHRvIHVwbG9hZCBob29rcy4gVGhhdCBkaWZmZXJlbnQgcGFyYW1ldGVyIGlzIHN0b3JlZCBoZXJlLlxyXG4gICAgICAgICAqIEB0eXBlIHtQSVhJLnByZXBhcmUuQ2FudmFzUHJlcGFyZXxQSVhJLlJlbmRlcmVyfVxyXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnVwbG9hZEhvb2tIZWxwZXIgPSByZW5kZXJlcjtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb2xsZWN0aW9uIG9mIGl0ZW1zIHRvIHVwbG9hZHMgYXQgb25jZS5cclxuICAgICAgICAgKiBAdHlwZSB7QXJyYXk8Kj59XHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnF1ZXVlID0gW107XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ29sbGVjdGlvbiBvZiBhZGRpdGlvbmFsIGhvb2tzIGZvciBmaW5kaW5nIGFzc2V0cy5cclxuICAgICAgICAgKiBAdHlwZSB7QXJyYXk8RnVuY3Rpb24+fVxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5hZGRIb29rcyA9IFtdO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbGxlY3Rpb24gb2YgYWRkaXRpb25hbCBob29rcyBmb3IgcHJvY2Vzc2luZyBhc3NldHMuXHJcbiAgICAgICAgICogQHR5cGUge0FycmF5PEZ1bmN0aW9uPn1cclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMudXBsb2FkSG9va3MgPSBbXTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDYWxsYmFjayB0byBjYWxsIGFmdGVyIGNvbXBsZXRlZC5cclxuICAgICAgICAgKiBAdHlwZSB7QXJyYXk8RnVuY3Rpb24+fVxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5jb21wbGV0ZXMgPSBbXTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJZiBwcmVwYXJlIGlzIHRpY2tpbmcgKHJ1bm5pbmcpLlxyXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy50aWNraW5nID0gZmFsc2U7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogJ2JvdW5kJyBjYWxsIGZvciBwcmVwYXJlSXRlbXMoKS5cclxuICAgICAgICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmRlbGF5ZWRUaWNrID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAvLyB1bmxpa2VseSwgYnV0IGluIGNhc2Ugd2Ugd2VyZSBkZXN0cm95ZWQgYmV0d2VlbiB0aWNrKCkgYW5kIGRlbGF5ZWRUaWNrKClcclxuICAgICAgICAgICAgaWYgKCF0aGlzLnF1ZXVlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5wcmVwYXJlSXRlbXMoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIGhvb2tzIHRvIGZpbmQgdGhlIGNvcnJlY3QgdGV4dHVyZVxyXG4gICAgICAgIHRoaXMucmVnaXN0ZXJGaW5kSG9vayhCYXNlUHJlcGFyZS5maW5kVGV4dCk7XHJcbiAgICAgICAgdGhpcy5yZWdpc3RlckZpbmRIb29rKEJhc2VQcmVwYXJlLmZpbmRUZXh0U3R5bGUpO1xyXG4gICAgICAgIHRoaXMucmVnaXN0ZXJGaW5kSG9vayhCYXNlUHJlcGFyZS5maW5kTXVsdGlwbGVCYXNlVGV4dHVyZXMpO1xyXG4gICAgICAgIHRoaXMucmVnaXN0ZXJGaW5kSG9vayhCYXNlUHJlcGFyZS5maW5kQmFzZVRleHR1cmUpO1xyXG4gICAgICAgIHRoaXMucmVnaXN0ZXJGaW5kSG9vayhCYXNlUHJlcGFyZS5maW5kVGV4dHVyZSk7XHJcbiAgICAgICAgLy8gdXBsb2FkIGhvb2tzXHJcbiAgICAgICAgdGhpcy5yZWdpc3RlclVwbG9hZEhvb2soQmFzZVByZXBhcmUuZHJhd1RleHQpO1xyXG4gICAgICAgIHRoaXMucmVnaXN0ZXJVcGxvYWRIb29rKEJhc2VQcmVwYXJlLmNhbGN1bGF0ZVRleHRTdHlsZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFVwbG9hZCBhbGwgdGhlIHRleHR1cmVzIGFuZCBncmFwaGljcyB0byB0aGUgR1BVLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258UElYSS5EaXNwbGF5T2JqZWN0fFBJWEkuQ29udGFpbmVyfFBJWEkuQmFzZVRleHR1cmV8UElYSS5UZXh0dXJlfFBJWEkuR3JhcGhpY3N8UElYSS5UZXh0fSBpdGVtIC1cclxuICAgICAqICAgIEVpdGhlciB0aGUgY29udGFpbmVyIG9yIGRpc3BsYXkgb2JqZWN0IHRvIHNlYXJjaCBmb3IgaXRlbXMgdG8gdXBsb2FkLCB0aGUgaXRlbXMgdG8gdXBsb2FkIHRoZW1zZWx2ZXMsXHJcbiAgICAgKiAgICBvciB0aGUgY2FsbGJhY2sgZnVuY3Rpb24sIGlmIGl0ZW1zIGhhdmUgYmVlbiBhZGRlZCB1c2luZyBgcHJlcGFyZS5hZGRgLlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2RvbmVdIC0gT3B0aW9uYWwgY2FsbGJhY2sgd2hlbiBhbGwgcXVldWVkIHVwbG9hZHMgaGF2ZSBjb21wbGV0ZWRcclxuICAgICAqL1xyXG4gICAgdXBsb2FkKGl0ZW0sIGRvbmUpIHtcclxuICAgICAgICBpZiAodHlwZW9mIGl0ZW0gPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgZG9uZSA9IGl0ZW07XHJcbiAgICAgICAgICAgIGl0ZW0gPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBJZiBhIGRpc3BsYXkgb2JqZWN0LCBzZWFyY2ggZm9yIGl0ZW1zXHJcbiAgICAgICAgLy8gdGhhdCB3ZSBjb3VsZCB1cGxvYWRcclxuICAgICAgICBpZiAoaXRlbSkge1xyXG4gICAgICAgICAgICB0aGlzLmFkZChpdGVtKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gR2V0IHRoZSBpdGVtcyBmb3IgdXBsb2FkIGZyb20gdGhlIGRpc3BsYXlcclxuICAgICAgICBpZiAodGhpcy5xdWV1ZS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgaWYgKGRvbmUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29tcGxldGVzLnB1c2goZG9uZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCF0aGlzLnRpY2tpbmcpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudGlja2luZyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBUaWNrZXJfMS5UaWNrZXIuc3lzdGVtLmFkZE9uY2UodGhpcy50aWNrLCB0aGlzLCBUaWNrZXJfMS5UaWNrZXIuVVBEQVRFX1BSSU9SSVRZLlVUSUxJVFkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGRvbmUpIHtcclxuICAgICAgICAgICAgZG9uZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogSGFuZGxlIHRpY2sgdXBkYXRlXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgdGljaygpIHtcclxuICAgICAgICBzZXRUaW1lb3V0KHRoaXMuZGVsYXllZFRpY2ssIDApO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBY3R1YWxseSBwcmVwYXJlIGl0ZW1zLiBUaGlzIGlzIGhhbmRsZWQgb3V0c2lkZSBvZiB0aGUgdGljayBiZWNhdXNlIGl0IHdpbGwgdGFrZSBhIHdoaWxlXHJcbiAgICAgKiBhbmQgd2UgZG8gTk9UIHdhbnQgdG8gYmxvY2sgdGhlIGN1cnJlbnQgYW5pbWF0aW9uIGZyYW1lIGZyb20gcmVuZGVyaW5nLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHByZXBhcmVJdGVtcygpIHtcclxuICAgICAgICB0aGlzLmxpbWl0ZXIuYmVnaW5GcmFtZSgpO1xyXG4gICAgICAgIC8vIFVwbG9hZCB0aGUgZ3JhcGhpY3NcclxuICAgICAgICB3aGlsZSAodGhpcy5xdWV1ZS5sZW5ndGggJiYgdGhpcy5saW1pdGVyLmFsbG93ZWRUb1VwbG9hZCgpKSB7XHJcbiAgICAgICAgICAgIHZhciBpdGVtID0gdGhpcy5xdWV1ZVswXTtcclxuICAgICAgICAgICAgdmFyIHVwbG9hZGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGlmIChpdGVtICYmICFpdGVtLl9kZXN0cm95ZWQpIHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLnVwbG9hZEhvb2tzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudXBsb2FkSG9va3NbaV0odGhpcy51cGxvYWRIb29rSGVscGVyLCBpdGVtKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnF1ZXVlLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwbG9hZGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghdXBsb2FkZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucXVldWUuc2hpZnQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBXZSdyZSBmaW5pc2hlZFxyXG4gICAgICAgIGlmICghdGhpcy5xdWV1ZS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgdGhpcy50aWNraW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHZhciBjb21wbGV0ZXMgPSB0aGlzLmNvbXBsZXRlcy5zbGljZSgwKTtcclxuICAgICAgICAgICAgdGhpcy5jb21wbGV0ZXMubGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSQxID0gMCwgbGVuJDEgPSBjb21wbGV0ZXMubGVuZ3RoOyBpJDEgPCBsZW4kMTsgaSQxKyspIHtcclxuICAgICAgICAgICAgICAgIGNvbXBsZXRlc1tpJDFdKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIGlmIHdlIGFyZSBub3QgZmluaXNoZWQsIG9uIHRoZSBuZXh0IHJBRiBkbyB0aGlzIGFnYWluXHJcbiAgICAgICAgICAgIFRpY2tlcl8xLlRpY2tlci5zeXN0ZW0uYWRkT25jZSh0aGlzLnRpY2ssIHRoaXMsIFRpY2tlcl8xLlRpY2tlci5VUERBVEVfUFJJT1JJVFkuVVRJTElUWSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGhvb2tzIGZvciBmaW5kaW5nIGl0ZW1zLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGFkZEhvb2sgLSBGdW5jdGlvbiBjYWxsIHRoYXQgdGFrZXMgdHdvIHBhcmFtZXRlcnM6IGBpdGVtOiosIHF1ZXVlOkFycmF5YFxyXG4gICAgICogICAgICBmdW5jdGlvbiBtdXN0IHJldHVybiBgdHJ1ZWAgaWYgaXQgd2FzIGFibGUgdG8gYWRkIGl0ZW0gdG8gdGhlIHF1ZXVlLlxyXG4gICAgICogQHJldHVybiB7UElYSS5wcmVwYXJlLkJhc2VQcmVwYXJlfSBJbnN0YW5jZSBvZiBwbHVnaW4gZm9yIGNoYWluaW5nLlxyXG4gICAgICovXHJcbiAgICByZWdpc3RlckZpbmRIb29rKGFkZEhvb2spIHtcclxuICAgICAgICBpZiAoYWRkSG9vaykge1xyXG4gICAgICAgICAgICB0aGlzLmFkZEhvb2tzLnB1c2goYWRkSG9vayk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGhvb2tzIGZvciB1cGxvYWRpbmcgaXRlbXMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gdXBsb2FkSG9vayAtIEZ1bmN0aW9uIGNhbGwgdGhhdCB0YWtlcyB0d28gcGFyYW1ldGVyczogYHByZXBhcmU6Q2FudmFzUHJlcGFyZSwgaXRlbToqYCBhbmRcclxuICAgICAqICAgICAgZnVuY3Rpb24gbXVzdCByZXR1cm4gYHRydWVgIGlmIGl0IHdhcyBhYmxlIHRvIGhhbmRsZSB1cGxvYWQgb2YgaXRlbS5cclxuICAgICAqIEByZXR1cm4ge1BJWEkucHJlcGFyZS5CYXNlUHJlcGFyZX0gSW5zdGFuY2Ugb2YgcGx1Z2luIGZvciBjaGFpbmluZy5cclxuICAgICAqL1xyXG4gICAgcmVnaXN0ZXJVcGxvYWRIb29rKHVwbG9hZEhvb2spIHtcclxuICAgICAgICBpZiAodXBsb2FkSG9vaykge1xyXG4gICAgICAgICAgICB0aGlzLnVwbG9hZEhvb2tzLnB1c2godXBsb2FkSG9vayk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBNYW51YWxseSBhZGQgYW4gaXRlbSB0byB0aGUgdXBsb2FkaW5nIHF1ZXVlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7UElYSS5EaXNwbGF5T2JqZWN0fFBJWEkuQ29udGFpbmVyfFBJWEkuQmFzZVRleHR1cmV8UElYSS5UZXh0dXJlfFBJWEkuR3JhcGhpY3N8UElYSS5UZXh0fCp9IGl0ZW0gLSBPYmplY3QgdG9cclxuICAgICAqICAgIGFkZCB0byB0aGUgcXVldWVcclxuICAgICAqIEByZXR1cm4ge1BJWEkucHJlcGFyZS5CYXNlUHJlcGFyZX0gSW5zdGFuY2Ugb2YgcGx1Z2luIGZvciBjaGFpbmluZy5cclxuICAgICAqL1xyXG4gICAgYWRkKGl0ZW0pIHtcclxuICAgICAgICAvLyBBZGQgYWRkaXRpb25hbCBob29rcyBmb3IgZmluZGluZyBlbGVtZW50cyBvbiBzcGVjaWFsXHJcbiAgICAgICAgLy8gdHlwZXMgb2Ygb2JqZWN0cyB0aGF0XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuYWRkSG9va3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuYWRkSG9va3NbaV0oaXRlbSwgdGhpcy5xdWV1ZSkpIHtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEdldCBjaGlsZHJlbiByZWN1cnNpdmVseVxyXG4gICAgICAgIGlmIChpdGVtIGluc3RhbmNlb2YgQ29udGFpbmVyXzEuQ29udGFpbmVyKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkkMSA9IGl0ZW0uY2hpbGRyZW4ubGVuZ3RoIC0gMTsgaSQxID49IDA7IGkkMS0tKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFkZChpdGVtLmNoaWxkcmVuW2kkMV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBEZXN0cm95cyB0aGUgcGx1Z2luLCBkb24ndCB1c2UgYWZ0ZXIgdGhpcy5cclxuICAgICAqXHJcbiAgICAgKi9cclxuICAgIGRlc3Ryb3koKSB7XHJcbiAgICAgICAgaWYgKHRoaXMudGlja2luZykge1xyXG4gICAgICAgICAgICBUaWNrZXJfMS5UaWNrZXIuc3lzdGVtLnJlbW92ZSh0aGlzLnRpY2ssIHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnRpY2tpbmcgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmFkZEhvb2tzID0gbnVsbDtcclxuICAgICAgICB0aGlzLnVwbG9hZEhvb2tzID0gbnVsbDtcclxuICAgICAgICB0aGlzLnJlbmRlcmVyID0gbnVsbDtcclxuICAgICAgICB0aGlzLmNvbXBsZXRlcyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5xdWV1ZSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5saW1pdGVyID0gbnVsbDtcclxuICAgICAgICB0aGlzLnVwbG9hZEhvb2tIZWxwZXIgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAqIEJ1aWx0LWluIGhvb2sgdG8gZmluZCBUZXh0IG9iamVjdHMuXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBwYXJhbSB7UElYSS5EaXNwbGF5T2JqZWN0fSBpdGVtIC0gRGlzcGxheSBvYmplY3QgdG8gY2hlY2tcclxuICogQHBhcmFtIHtBcnJheTwqPn0gcXVldWUgLSBDb2xsZWN0aW9uIG9mIGl0ZW1zIHRvIHVwbG9hZFxyXG4gKiBAcmV0dXJuIHtib29sZWFufSBpZiBhIFBJWEkuVGV4dCBvYmplY3Qgd2FzIGZvdW5kLlxyXG4gKi9cclxuICAgIHN0YXRpYyBmaW5kVGV4dChpdGVtLCBxdWV1ZSkge1xyXG4gICAgICAgIGlmIChpdGVtIGluc3RhbmNlb2YgVGV4dF8xLlRleHQpIHtcclxuICAgICAgICAgICAgLy8gcHVzaCB0aGUgdGV4dCBzdHlsZSB0byBwcmVwYXJlIGl0IC0gdGhpcyBjYW4gYmUgcmVhbGx5IGV4cGVuc2l2ZVxyXG4gICAgICAgICAgICBpZiAocXVldWUuaW5kZXhPZihpdGVtLnN0eWxlKSA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIHF1ZXVlLnB1c2goaXRlbS5zdHlsZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gYWxzbyBwdXNoIHRoZSB0ZXh0IG9iamVjdCBzbyB0aGF0IHdlIGNhbiByZW5kZXIgaXQgKHRvIGNhbnZhcy90ZXh0dXJlKSBpZiBuZWVkZWRcclxuICAgICAgICAgICAgaWYgKHF1ZXVlLmluZGV4T2YoaXRlbSkgPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICBxdWV1ZS5wdXNoKGl0ZW0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGFsc28gcHVzaCB0aGUgVGV4dCdzIHRleHR1cmUgZm9yIHVwbG9hZCB0byBHUFVcclxuICAgICAgICAgICAgdmFyIHRleHR1cmUgPSBpdGVtLl90ZXh0dXJlLmJhc2VUZXh0dXJlO1xyXG4gICAgICAgICAgICBpZiAocXVldWUuaW5kZXhPZih0ZXh0dXJlKSA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIHF1ZXVlLnB1c2godGV4dHVyZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gKiBCdWlsdC1pbiBob29rIHRvIGZpbmQgVGV4dFN0eWxlIG9iamVjdHMuXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBwYXJhbSB7UElYSS5UZXh0U3R5bGV9IGl0ZW0gLSBEaXNwbGF5IG9iamVjdCB0byBjaGVja1xyXG4gKiBAcGFyYW0ge0FycmF5PCo+fSBxdWV1ZSAtIENvbGxlY3Rpb24gb2YgaXRlbXMgdG8gdXBsb2FkXHJcbiAqIEByZXR1cm4ge2Jvb2xlYW59IGlmIGEgUElYSS5UZXh0U3R5bGUgb2JqZWN0IHdhcyBmb3VuZC5cclxuICovXHJcbiAgICBzdGF0aWMgZmluZFRleHRTdHlsZShpdGVtLCBxdWV1ZSkge1xyXG4gICAgICAgIGlmIChpdGVtIGluc3RhbmNlb2YgVGV4dFN0eWxlXzEuVGV4dFN0eWxlKSB7XHJcbiAgICAgICAgICAgIGlmIChxdWV1ZS5pbmRleE9mKGl0ZW0pID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgcXVldWUucHVzaChpdGVtKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAqIEJ1aWx0LWluIGhvb2sgdG8gZmluZCBtdWx0aXBsZSB0ZXh0dXJlcyBmcm9tIG9iamVjdHMgbGlrZSBBbmltYXRlZFNwcml0ZXMuXHJcbiAqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBwYXJhbSB7UElYSS5EaXNwbGF5T2JqZWN0fSBpdGVtIC0gRGlzcGxheSBvYmplY3QgdG8gY2hlY2tcclxuICogQHBhcmFtIHtBcnJheTwqPn0gcXVldWUgLSBDb2xsZWN0aW9uIG9mIGl0ZW1zIHRvIHVwbG9hZFxyXG4gKiBAcmV0dXJuIHtib29sZWFufSBpZiBhIFBJWEkuVGV4dHVyZSBvYmplY3Qgd2FzIGZvdW5kLlxyXG4gKi9cclxuICAgIHN0YXRpYyBmaW5kTXVsdGlwbGVCYXNlVGV4dHVyZXMoaXRlbSwgcXVldWUpIHtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gZmFsc2U7XHJcbiAgICAgICAgLy8gT2JqZWN0cyB3aXRoIG11bHRpcGxlIHRleHR1cmVzXHJcbiAgICAgICAgaWYgKGl0ZW0gJiYgaXRlbS5fdGV4dHVyZXMgJiYgaXRlbS5fdGV4dHVyZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaXRlbS5fdGV4dHVyZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGlmIChpdGVtLl90ZXh0dXJlc1tpXSBpbnN0YW5jZW9mIFRleHR1cmVfMS5UZXh0dXJlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJhc2VUZXh0dXJlID0gaXRlbS5fdGV4dHVyZXNbaV0uYmFzZVRleHR1cmU7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHF1ZXVlLmluZGV4T2YoYmFzZVRleHR1cmUpID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBxdWV1ZS5wdXNoKGJhc2VUZXh0dXJlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gKiBCdWlsdC1pbiBob29rIHRvIGZpbmQgQmFzZVRleHR1cmVzIGZyb20gU3ByaXRlcy5cclxuICpcclxuICogQHByaXZhdGVcclxuICogQHBhcmFtIHtQSVhJLkRpc3BsYXlPYmplY3R9IGl0ZW0gLSBEaXNwbGF5IG9iamVjdCB0byBjaGVja1xyXG4gKiBAcGFyYW0ge0FycmF5PCo+fSBxdWV1ZSAtIENvbGxlY3Rpb24gb2YgaXRlbXMgdG8gdXBsb2FkXHJcbiAqIEByZXR1cm4ge2Jvb2xlYW59IGlmIGEgUElYSS5UZXh0dXJlIG9iamVjdCB3YXMgZm91bmQuXHJcbiAqL1xyXG4gICAgc3RhdGljIGZpbmRCYXNlVGV4dHVyZShpdGVtLCBxdWV1ZSkge1xyXG4gICAgICAgIC8vIE9iamVjdHMgd2l0aCB0ZXh0dXJlcywgbGlrZSBTcHJpdGVzL1RleHRcclxuICAgICAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIEJhc2VUZXh0dXJlXzEuQmFzZVRleHR1cmUpIHtcclxuICAgICAgICAgICAgaWYgKHF1ZXVlLmluZGV4T2YoaXRlbSkgPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICBxdWV1ZS5wdXNoKGl0ZW0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICogQnVpbHQtaW4gaG9vayB0byBmaW5kIHRleHR1cmVzIGZyb20gb2JqZWN0cy5cclxuICpcclxuICogQHByaXZhdGVcclxuICogQHBhcmFtIHtQSVhJLkRpc3BsYXlPYmplY3R9IGl0ZW0gLSBEaXNwbGF5IG9iamVjdCB0byBjaGVja1xyXG4gKiBAcGFyYW0ge0FycmF5PCo+fSBxdWV1ZSAtIENvbGxlY3Rpb24gb2YgaXRlbXMgdG8gdXBsb2FkXHJcbiAqIEByZXR1cm4ge2Jvb2xlYW59IGlmIGEgUElYSS5UZXh0dXJlIG9iamVjdCB3YXMgZm91bmQuXHJcbiAqL1xyXG4gICAgc3RhdGljIGZpbmRUZXh0dXJlKGl0ZW0sIHF1ZXVlKSB7XHJcbiAgICAgICAgaWYgKGl0ZW0uX3RleHR1cmUgJiYgaXRlbS5fdGV4dHVyZSBpbnN0YW5jZW9mIFRleHR1cmVfMS5UZXh0dXJlKSB7XHJcbiAgICAgICAgICAgIHZhciB0ZXh0dXJlID0gaXRlbS5fdGV4dHVyZS5iYXNlVGV4dHVyZTtcclxuICAgICAgICAgICAgaWYgKHF1ZXVlLmluZGV4T2YodGV4dHVyZSkgPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICBxdWV1ZS5wdXNoKHRleHR1cmUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEJ1aWx0LWluIGhvb2sgdG8gZHJhdyBQSVhJLlRleHQgdG8gaXRzIHRleHR1cmUuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7UElYSS5SZW5kZXJlcnxQSVhJLkNhbnZhc1ByZXBhcmV9IGhlbHBlciAtIE5vdCB1c2VkIGJ5IHRoaXMgdXBsb2FkIGhhbmRsZXJcclxuICAgICAqIEBwYXJhbSB7UElYSS5EaXNwbGF5T2JqZWN0fSBpdGVtIC0gSXRlbSB0byBjaGVja1xyXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gSWYgaXRlbSB3YXMgdXBsb2FkZWQuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBkcmF3VGV4dChoZWxwZXIsIGl0ZW0pIHtcclxuICAgICAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIFRleHRfMS5UZXh0KSB7XHJcbiAgICAgICAgICAgIC8vIHVwZGF0aW5nIHRleHQgd2lsbCByZXR1cm4gZWFybHkgaWYgaXQgaXMgbm90IGRpcnR5XHJcbiAgICAgICAgICAgIGl0ZW0udXBkYXRlVGV4dCh0cnVlKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gKiBCdWlsdC1pbiBob29rIHRvIGNhbGN1bGF0ZSBhIHRleHQgc3R5bGUgZm9yIGEgUElYSS5UZXh0IG9iamVjdC5cclxuICpcclxuICogQHByaXZhdGVcclxuICogQHBhcmFtIHtQSVhJLlJlbmRlcmVyfFBJWEkuQ2FudmFzUHJlcGFyZX0gaGVscGVyIC0gTm90IHVzZWQgYnkgdGhpcyB1cGxvYWQgaGFuZGxlclxyXG4gKiBAcGFyYW0ge1BJWEkuRGlzcGxheU9iamVjdH0gaXRlbSAtIEl0ZW0gdG8gY2hlY2tcclxuICogQHJldHVybiB7Ym9vbGVhbn0gSWYgaXRlbSB3YXMgdXBsb2FkZWQuXHJcbiAqL1xyXG4gICAgc3RhdGljIGNhbGN1bGF0ZVRleHRTdHlsZShoZWxwZXIsIGl0ZW0pIHtcclxuICAgICAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIFRleHRTdHlsZV8xLlRleHRTdHlsZSkge1xyXG4gICAgICAgICAgICB2YXIgZm9udCA9IGl0ZW0udG9Gb250U3RyaW5nKCk7XHJcbiAgICAgICAgICAgIFRleHRNZXRyaWNzXzEuVGV4dE1ldHJpY3MubWVhc3VyZUZvbnQoZm9udCk7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5CYXNlUHJlcGFyZSA9IEJhc2VQcmVwYXJlO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBCYXNlVGV4dHVyZV8xID0gcmVxdWlyZShcIi4vQmFzZVRleHR1cmVcIik7XHJcbmNvbnN0IEZyYW1lYnVmZmVyXzEgPSByZXF1aXJlKFwiLi9GcmFtZWJ1ZmZlclwiKTtcclxuY2xhc3MgQmFzZVJlbmRlclRleHR1cmUgZXh0ZW5kcyBCYXNlVGV4dHVyZV8xLkJhc2VUZXh0dXJlIHtcclxuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMsIGFyZzEgPSBudWxsLCBhcmcyID0gbnVsbCwgYXJnNCA9IG51bGwpIHtcclxuICAgICAgICBzdXBlcihudWxsLCBvcHRpb25zKTtcclxuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlIHByZWZlci1yZXN0LXBhcmFtcyAqL1xyXG4gICAgICAgICAgICAvLyBCYWNrd2FyZCBjb21wYXRpYmlsaXR5IG9mIHNpZ25hdHVyZVxyXG4gICAgICAgICAgICB2YXIgd2lkdGgkMSA9IGFyZ3VtZW50c1swXTtcclxuICAgICAgICAgICAgdmFyIGhlaWdodCQxID0gYXJndW1lbnRzWzFdO1xyXG4gICAgICAgICAgICB2YXIgc2NhbGVNb2RlID0gYXJndW1lbnRzWzJdO1xyXG4gICAgICAgICAgICB2YXIgcmVzb2x1dGlvbiA9IGFyZ3VtZW50c1szXTtcclxuICAgICAgICAgICAgb3B0aW9ucyA9IHsgd2lkdGg6IHdpZHRoJDEsIGhlaWdodDogaGVpZ2h0JDEsIHNjYWxlTW9kZTogc2NhbGVNb2RlLCByZXNvbHV0aW9uOiByZXNvbHV0aW9uIH07XHJcbiAgICAgICAgICAgIC8qIGVzbGludC1lbmFibGUgcHJlZmVyLXJlc3QtcGFyYW1zICovXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciByZWYgPSBvcHRpb25zIHx8IHt9O1xyXG4gICAgICAgIHZhciB3aWR0aCA9IHJlZi53aWR0aDtcclxuICAgICAgICB2YXIgaGVpZ2h0ID0gcmVmLmhlaWdodDtcclxuICAgICAgICAvLyBTZXQgZGVmYXVsdHNcclxuICAgICAgICB0aGlzLm1pcG1hcCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMud2lkdGggPSBNYXRoLmNlaWwod2lkdGgpIHx8IDEwMDtcclxuICAgICAgICB0aGlzLmhlaWdodCA9IE1hdGguY2VpbChoZWlnaHQpIHx8IDEwMDtcclxuICAgICAgICB0aGlzLnZhbGlkID0gdHJ1ZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBIHJlZmVyZW5jZSB0byB0aGUgY2FudmFzIHJlbmRlciB0YXJnZXQgKHdlIG9ubHkgbmVlZCBvbmUgYXMgdGhpcyBjYW4gYmUgc2hhcmVkIGFjcm9zcyByZW5kZXJlcnMpXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgICAgICogQG1lbWJlciB7b2JqZWN0fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuX2NhbnZhc1JlbmRlclRhcmdldCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5jbGVhckNvbG9yID0gWzAsIDAsIDAsIDBdO1xyXG4gICAgICAgIHRoaXMuZnJhbWVidWZmZXIgPSBuZXcgRnJhbWVidWZmZXJfMS5GcmFtZWJ1ZmZlcih0aGlzLndpZHRoICogdGhpcy5yZXNvbHV0aW9uLCB0aGlzLmhlaWdodCAqIHRoaXMucmVzb2x1dGlvbilcclxuICAgICAgICAgICAgLmFkZENvbG9yVGV4dHVyZSgwLCB0aGlzKVxyXG4gICAgICAgICAgICAuZW5hYmxlU3RlbmNpbCgpO1xyXG4gICAgICAgIC8vIFRPRE8gLSBjb3VsZCB0aGlzIGJlIGFkZGVkIHRoZSBzeXN0ZW1zP1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBkYXRhIHN0cnVjdHVyZSBmb3IgdGhlIHN0ZW5jaWwgbWFza3MuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLkdyYXBoaWNzW119XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5zdGVuY2lsTWFza1N0YWNrID0gW107XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGRhdGEgc3RydWN0dXJlIGZvciB0aGUgZmlsdGVycy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuR3JhcGhpY3NbXX1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmZpbHRlclN0YWNrID0gW3t9XTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVzaXplcyB0aGUgQmFzZVJlbmRlclRleHR1cmUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIC0gVGhlIHdpZHRoIHRvIHJlc2l6ZSB0by5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgLSBUaGUgaGVpZ2h0IHRvIHJlc2l6ZSB0by5cclxuICAgICAqL1xyXG4gICAgcmVzaXplKHdpZHRoLCBoZWlnaHQpIHtcclxuICAgICAgICB3aWR0aCA9IE1hdGguY2VpbCh3aWR0aCk7XHJcbiAgICAgICAgaGVpZ2h0ID0gTWF0aC5jZWlsKGhlaWdodCk7XHJcbiAgICAgICAgdGhpcy5mcmFtZWJ1ZmZlci5yZXNpemUod2lkdGggKiB0aGlzLnJlc29sdXRpb24sIGhlaWdodCAqIHRoaXMucmVzb2x1dGlvbik7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIEZyZWVzIHRoZSB0ZXh0dXJlIGFuZCBmcmFtZWJ1ZmZlciBmcm9tIFdlYkdMIG1lbW9yeSB3aXRob3V0IGRlc3Ryb3lpbmcgdGhpcyB0ZXh0dXJlIG9iamVjdC5cclxuICAgICAqIFRoaXMgbWVhbnMgeW91IGNhbiBzdGlsbCB1c2UgdGhlIHRleHR1cmUgbGF0ZXIgd2hpY2ggd2lsbCB1cGxvYWQgaXQgdG8gR1BVXHJcbiAgICAgKiBtZW1vcnkgYWdhaW4uXHJcbiAgICAgKlxyXG4gICAgICogQGZpcmVzIFBJWEkuQmFzZVRleHR1cmUjZGlzcG9zZVxyXG4gICAgICovXHJcbiAgICBkaXNwb3NlKCkge1xyXG4gICAgICAgIHRoaXMuZnJhbWVidWZmZXIuZGlzcG9zZSgpO1xyXG4gICAgICAgIHN1cGVyLmRpc3Bvc2UoKTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogRGVzdHJveXMgdGhpcyB0ZXh0dXJlLlxyXG4gICAgICpcclxuICAgICAqL1xyXG4gICAgZGVzdHJveSgpIHtcclxuICAgICAgICBzdXBlci5kZXN0cm95KCk7XHJcbiAgICAgICAgdGhpcy5mcmFtZWJ1ZmZlciA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IG51bGw7XHJcbiAgICB9XHJcbiAgICA7XHJcbn1cclxuZXhwb3J0cy5CYXNlUmVuZGVyVGV4dHVyZSA9IEJhc2VSZW5kZXJUZXh0dXJlO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBFdmVudERpc3BhdGNoZXJfMSA9IHJlcXVpcmUoXCIuL0V2ZW50RGlzcGF0Y2hlclwiKTtcclxuY29uc3QgRXZlbnRfMSA9IHJlcXVpcmUoXCIuL0V2ZW50XCIpO1xyXG5jb25zdCBSZXNvdXJjZV8xID0gcmVxdWlyZShcIi4vUmVzb3VyY2VcIik7XHJcbmNvbnN0IEJ1ZmZlclJlc291cmNlXzEgPSByZXF1aXJlKFwiLi9CdWZmZXJSZXNvdXJjZVwiKTtcclxuY29uc3QgRGlzcGxheVNldHRpbmdzXzEgPSByZXF1aXJlKFwiLi9EaXNwbGF5U2V0dGluZ3NcIik7XHJcbmNvbnN0IE1hdGhTZXR0aW5nc18xID0gcmVxdWlyZShcIi4vTWF0aFNldHRpbmdzXCIpO1xyXG5jb25zdCBXZWJHTFNldHRpbmdzXzEgPSByZXF1aXJlKFwiLi9XZWJHTFNldHRpbmdzXCIpO1xyXG5jb25zdCBDYWNoZVNldHRpbmdzXzEgPSByZXF1aXJlKFwiLi9DYWNoZVNldHRpbmdzXCIpO1xyXG5jb25zdCBSZXNvdXJjZVNldHRpbmdzXzEgPSByZXF1aXJlKFwiLi9SZXNvdXJjZVNldHRpbmdzXCIpO1xyXG5jb25zdCBMb2dnZXJfMSA9IHJlcXVpcmUoXCIuL0xvZ2dlclwiKTtcclxuY2xhc3MgQmFzZVRleHR1cmUgZXh0ZW5kcyBFdmVudERpc3BhdGNoZXJfMS5FdmVudERpc3BhdGNoZXIge1xyXG4gICAgY29uc3RydWN0b3IocmVzb3VyY2UgPSBudWxsLCBvcHRpb25zID0gbnVsbCkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5oYW5kbGVSZXNpemUgPSAoZXZlbnQpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5zZXRSZWFsU2l6ZSh0aGlzLnJlc291cmNlLndpZHRoLCB0aGlzLnJlc291cmNlLmhlaWdodCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLmhhbmRsZVVwZGF0ZSA9IChldmVudCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcbiAgICAgICAgdmFyIHByZW11bHRpcGx5QWxwaGEgPSBvcHRpb25zLnByZW11bHRpcGx5QWxwaGE7XHJcbiAgICAgICAgdmFyIG1pcG1hcCA9IG9wdGlvbnMubWlwbWFwO1xyXG4gICAgICAgIHZhciBzY2FsZU1vZGUgPSBvcHRpb25zLnNjYWxlTW9kZTtcclxuICAgICAgICB2YXIgd2lkdGggPSBvcHRpb25zLndpZHRoO1xyXG4gICAgICAgIHZhciBoZWlnaHQgPSBvcHRpb25zLmhlaWdodDtcclxuICAgICAgICB2YXIgd3JhcE1vZGUgPSBvcHRpb25zLndyYXBNb2RlO1xyXG4gICAgICAgIHZhciBmb3JtYXQgPSBvcHRpb25zLmZvcm1hdDtcclxuICAgICAgICB2YXIgdHlwZSA9IG9wdGlvbnMudHlwZTtcclxuICAgICAgICB2YXIgdGFyZ2V0ID0gb3B0aW9ucy50YXJnZXQ7XHJcbiAgICAgICAgdmFyIHJlc29sdXRpb24gPSBvcHRpb25zLnJlc29sdXRpb247XHJcbiAgICAgICAgdmFyIHJlc291cmNlT3B0aW9ucyA9IG9wdGlvbnMucmVzb3VyY2VPcHRpb25zO1xyXG4gICAgICAgIC8vIENvbnZlcnQgdGhlIHJlc291cmNlIHRvIGEgUmVzb3VyY2Ugb2JqZWN0XHJcbiAgICAgICAgaWYgKHJlc291cmNlICYmIHJlc291cmNlIGluc3RhbmNlb2YgSW1hZ2VCaXRtYXApIHtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAocmVzb3VyY2UgJiYgIShyZXNvdXJjZSBpbnN0YW5jZW9mIFJlc291cmNlXzEuUmVzb3VyY2UpKSB7XHJcbiAgICAgICAgICAgIHJlc291cmNlID0gUmVzb3VyY2VTZXR0aW5nc18xLlJlc291cmNlU2V0dGluZ3MuYXV0b0RldGVjdFJlc291cmNlKHJlc291cmNlLCByZXNvdXJjZU9wdGlvbnMpO1xyXG4gICAgICAgICAgICBMb2dnZXJfMS5yZXZlYWwocmVzb3VyY2UpO1xyXG4gICAgICAgICAgICByZXNvdXJjZS5pbnRlcm5hbCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSB3aWR0aCBvZiB0aGUgYmFzZSB0ZXh0dXJlIHNldCB3aGVuIHRoZSBpbWFnZSBoYXMgbG9hZGVkXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcmVhZG9ubHlcclxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoIHx8IDA7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGhlaWdodCBvZiB0aGUgYmFzZSB0ZXh0dXJlIHNldCB3aGVuIHRoZSBpbWFnZSBoYXMgbG9hZGVkXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcmVhZG9ubHlcclxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQgfHwgMDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgcmVzb2x1dGlvbiAvIGRldmljZSBwaXhlbCByYXRpbyBvZiB0aGUgdGV4dHVyZVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICAgICAqIEBkZWZhdWx0IFBJWEkuc2V0dGluZ3MuUkVTT0xVVElPTlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMucmVzb2x1dGlvbiA9IHJlc29sdXRpb24gfHwgRGlzcGxheVNldHRpbmdzXzEuRGlzcGxheVNldHRpbmdzLlJFU09MVVRJT047XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogTWlwbWFwIG1vZGUgb2YgdGhlIHRleHR1cmUsIGFmZmVjdHMgZG93bnNjYWxlZCBpbWFnZXNcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuTUlQTUFQX01PREVTfVxyXG4gICAgICAgICAqIEBkZWZhdWx0IFBJWEkuc2V0dGluZ3MuTUlQTUFQX1RFWFRVUkVTXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5taXBtYXAgPSBtaXBtYXAgIT09IHVuZGVmaW5lZCA/IG1pcG1hcCA6IFdlYkdMU2V0dGluZ3NfMS5XZWJHTFNldHRpbmdzLk1JUE1BUF9URVhUVVJFUztcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBIb3cgdGhlIHRleHR1cmUgd3JhcHNcclxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy53cmFwTW9kZSA9IHdyYXBNb2RlIHx8IFdlYkdMU2V0dGluZ3NfMS5XZWJHTFNldHRpbmdzLldSQVBfTU9ERTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgc2NhbGUgbW9kZSB0byBhcHBseSB3aGVuIHNjYWxpbmcgdGhpcyB0ZXh0dXJlXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLlNDQUxFX01PREVTfVxyXG4gICAgICAgICAqIEBkZWZhdWx0IFBJWEkuc2V0dGluZ3MuU0NBTEVfTU9ERVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuc2NhbGVNb2RlID0gc2NhbGVNb2RlICE9PSB1bmRlZmluZWQgPyBzY2FsZU1vZGUgOiBEaXNwbGF5U2V0dGluZ3NfMS5EaXNwbGF5U2V0dGluZ3MuU0NBTEVfTU9ERTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgcGl4ZWwgZm9ybWF0IG9mIHRoZSB0ZXh0dXJlXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLkZPUk1BVFN9XHJcbiAgICAgICAgICogQGRlZmF1bHQgUElYSS5GT1JNQVRTLlJHQkFcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmZvcm1hdCA9IGZvcm1hdCB8fCBXZWJHTFNldHRpbmdzXzEuV2ViR0xTZXR0aW5ncy5GT1JNQVRTLlJHQkE7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIHR5cGUgb2YgcmVzb3VyY2UgZGF0YVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQG1lbWJlciB7UElYSS5UWVBFU31cclxuICAgICAgICAgKiBAZGVmYXVsdCBQSVhJLlRZUEVTLlVOU0lHTkVEX0JZVEVcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlIHx8IFdlYkdMU2V0dGluZ3NfMS5XZWJHTFNldHRpbmdzLlRZUEVTLlVOU0lHTkVEX0JZVEU7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIHRhcmdldCB0eXBlXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLlRBUkdFVFN9XHJcbiAgICAgICAgICogQGRlZmF1bHQgUElYSS5UQVJHRVRTLlRFWFRVUkVfMkRcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldCB8fCBXZWJHTFNldHRpbmdzXzEuV2ViR0xTZXR0aW5ncy5UQVJHRVRTLlRFWFRVUkVfMkQ7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2V0IHRvIHRydWUgdG8gZW5hYmxlIHByZS1tdWx0aXBsaWVkIGFscGhhXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAbWVtYmVyIHtib29sZWFufVxyXG4gICAgICAgICAqIEBkZWZhdWx0IHRydWVcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnByZW11bHRpcGx5QWxwaGEgPSBwcmVtdWx0aXBseUFscGhhICE9PSBmYWxzZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHbG9iYWwgdW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoaXMgQmFzZVRleHR1cmVcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBtZW1iZXIge3N0cmluZ31cclxuICAgICAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy51aWQgPSBNYXRoU2V0dGluZ3NfMS5NYXRoU2V0dGluZ3MudWlkKCk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVXNlZCBieSBhdXRvbWF0aWMgdGV4dHVyZSBHYXJiYWdlIENvbGxlY3Rpb24sIHN0b3JlcyBsYXN0IEdDIHRpY2sgd2hlbiBpdCB3YXMgYm91bmRcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy50b3VjaGVkID0gMDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBXaGV0aGVyIG9yIG5vdCB0aGUgdGV4dHVyZSBpcyBhIHBvd2VyIG9mIHR3bywgdHJ5IHRvIHVzZSBwb3dlciBvZiB0d28gdGV4dHVyZXMgYXMgbXVjaFxyXG4gICAgICAgICAqIGFzIHlvdSBjYW5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEByZWFkb25seVxyXG4gICAgICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XHJcbiAgICAgICAgICogQGRlZmF1bHQgZmFsc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmlzUG93ZXJPZlR3byA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX3JlZnJlc2hQT1QoKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgbWFwIG9mIHJlbmRlciBjb250ZXh0IHRleHR1cmVzIHdoZXJlIHRoaXMgaXMgYm91bmRcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH1cclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuX2dsVGV4dHVyZXMgPSB7fTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBVc2VkIGJ5IFRleHR1cmVTeXN0ZW0gdG8gb25seSB1cGRhdGUgdGV4dHVyZSB0byB0aGUgR1BVIHdoZW4gbmVlZGVkLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHByb3RlY3RlZFxyXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmRpcnR5SWQgPSAwO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFVzZWQgYnkgVGV4dHVyZVN5c3RlbSB0byBvbmx5IHVwZGF0ZSB0ZXh0dXJlIHN0eWxlIHdoZW4gbmVlZGVkLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHByb3RlY3RlZFxyXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmRpcnR5U3R5bGVJZCA9IDA7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ3VycmVudGx5IGRlZmF1bHQgY2FjaGUgSUQuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAbWVtYmVyIHtzdHJpbmd9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5jYWNoZUlkID0gbnVsbDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZW5lcmFsbHkgc3BlYWtpbmcgbWVhbnMgd2hlbiByZXNvdXJjZSBpcyBsb2FkZWQuXHJcbiAgICAgICAgICogQHJlYWRvbmx5XHJcbiAgICAgICAgICogQG1lbWJlciB7Ym9vbGVhbn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnZhbGlkID0gd2lkdGggPiAwICYmIGhlaWdodCA+IDA7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGNvbGxlY3Rpb24gb2YgYWx0ZXJuYXRpdmUgY2FjaGUgaWRzLCBzaW5jZSBzb21lIEJhc2VUZXh0dXJlc1xyXG4gICAgICAgICAqIGNhbiBoYXZlIG1vcmUgdGhhbiBvbmUgSUQsIHNob3J0IG5hbWUgYW5kIGxvbmdlciBmdWxsIFVSTFxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQG1lbWJlciB7QXJyYXk8c3RyaW5nPn1cclxuICAgICAgICAgKiBAcmVhZG9ubHlcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnRleHR1cmVDYWNoZUlkcyA9IFtdO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEZsYWcgaWYgQmFzZVRleHR1cmUgaGFzIGJlZW4gZGVzdHJveWVkLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQG1lbWJlciB7Ym9vbGVhbn1cclxuICAgICAgICAgKiBAcmVhZG9ubHlcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSByZXNvdXJjZSB1c2VkIGJ5IHRoaXMgQmFzZVRleHR1cmUsIHRoZXJlIGNhbiBvbmx5XHJcbiAgICAgICAgICogYmUgb25lIHJlc291cmNlIHBlciBCYXNlVGV4dHVyZSwgYnV0IHRleHR1cmVzIGNhbiBzaGFyZVxyXG4gICAgICAgICAqIHJlc291cmNlcy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkucmVzb3VyY2VzLlJlc291cmNlfVxyXG4gICAgICAgICAqIEByZWFkb25seVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMucmVzb3VyY2UgPSBudWxsO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIE51bWJlciBvZiB0aGUgdGV4dHVyZSBiYXRjaCwgdXNlZCBieSBtdWx0aS10ZXh0dXJlIHJlbmRlcmVyc1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuX2JhdGNoRW5hYmxlZCA9IDA7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRmlyZWQgd2hlbiBhIG5vdC1pbW1lZGlhdGVseS1hdmFpbGFibGUgc291cmNlIGZpbmlzaGVzIGxvYWRpbmcuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgICAgICogQGV2ZW50IFBJWEkuQmFzZVRleHR1cmUjbG9hZGVkXHJcbiAgICAgICAgICogQHBhcmFtIHtQSVhJLkJhc2VUZXh0dXJlfSBiYXNlVGV4dHVyZSAtIFJlc291cmNlIGxvYWRlZC5cclxuICAgICAgICAgKi9cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBGaXJlZCB3aGVuIGEgbm90LWltbWVkaWF0ZWx5LWF2YWlsYWJsZSBzb3VyY2UgZmFpbHMgdG8gbG9hZC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAgICAgKiBAZXZlbnQgUElYSS5CYXNlVGV4dHVyZSNlcnJvclxyXG4gICAgICAgICAqIEBwYXJhbSB7UElYSS5CYXNlVGV4dHVyZX0gYmFzZVRleHR1cmUgLSBSZXNvdXJjZSBlcnJvcmVkLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEZpcmVkIHdoZW4gQmFzZVRleHR1cmUgaXMgdXBkYXRlZC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAgICAgKiBAZXZlbnQgUElYSS5CYXNlVGV4dHVyZSNsb2FkZWRcclxuICAgICAgICAgKiBAcGFyYW0ge1BJWEkuQmFzZVRleHR1cmV9IGJhc2VUZXh0dXJlIC0gUmVzb3VyY2UgbG9hZGVkLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEZpcmVkIHdoZW4gQmFzZVRleHR1cmUgaXMgZGVzdHJveWVkLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHByb3RlY3RlZFxyXG4gICAgICAgICAqIEBldmVudCBQSVhJLkJhc2VUZXh0dXJlI2Vycm9yXHJcbiAgICAgICAgICogQHBhcmFtIHtQSVhJLkJhc2VUZXh0dXJlfSBiYXNlVGV4dHVyZSAtIFJlc291cmNlIGVycm9yZWQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRmlyZWQgd2hlbiBCYXNlVGV4dHVyZSBpcyB1cGRhdGVkLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHByb3RlY3RlZFxyXG4gICAgICAgICAqIEBldmVudCBQSVhJLkJhc2VUZXh0dXJlI3VwZGF0ZVxyXG4gICAgICAgICAqIEBwYXJhbSB7UElYSS5CYXNlVGV4dHVyZX0gYmFzZVRleHR1cmUgLSBJbnN0YW5jZSBvZiB0ZXh0dXJlIGJlaW5nIHVwZGF0ZWQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRmlyZWQgd2hlbiBCYXNlVGV4dHVyZSBpcyBkZXN0cm95ZWQuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgICAgICogQGV2ZW50IFBJWEkuQmFzZVRleHR1cmUjZGlzcG9zZVxyXG4gICAgICAgICAqIEBwYXJhbSB7UElYSS5CYXNlVGV4dHVyZX0gYmFzZVRleHR1cmUgLSBJbnN0YW5jZSBvZiB0ZXh0dXJlIGJlaW5nIGRlc3Ryb3llZC5cclxuICAgICAgICAgKi9cclxuICAgICAgICAvLyBTZXQgdGhlIHJlc291cmNlXHJcbiAgICAgICAgdGhpcy5zZXRSZXNvdXJjZShyZXNvdXJjZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFBpeGVsIHdpZHRoIG9mIHRoZSBzb3VyY2Ugb2YgdGhpcyB0ZXh0dXJlXHJcbiAgICAgKlxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIGdldCByZWFsV2lkdGgoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMud2lkdGggKiB0aGlzLnJlc29sdXRpb247XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFBpeGVsIGhlaWdodCBvZiB0aGUgc291cmNlIG9mIHRoaXMgdGV4dHVyZVxyXG4gICAgICpcclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICBnZXQgcmVhbEhlaWdodCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5oZWlnaHQgKiB0aGlzLnJlc29sdXRpb247XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIENoYW5nZXMgc3R5bGUgb3B0aW9ucyBvZiBCYXNlVGV4dHVyZVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7UElYSS5TQ0FMRV9NT0RFU30gW3NjYWxlTW9kZV0gLSBQaXhpIHNjYWxlbW9kZVxyXG4gICAgICogQHBhcmFtIHtQSVhJLk1JUE1BUF9NT0RFU30gW21pcG1hcF0gLSBlbmFibGUgbWlwbWFwc1xyXG4gICAgICogQHJldHVybnMge0Jhc2VUZXh0dXJlfSB0aGlzXHJcbiAgICAgKi9cclxuICAgIEJzZXRTdHlsZShzY2FsZU1vZGUsIG1pcG1hcCkge1xyXG4gICAgICAgIHZhciBkaXJ0eTtcclxuICAgICAgICBpZiAoc2NhbGVNb2RlICE9PSB1bmRlZmluZWQgJiYgc2NhbGVNb2RlICE9PSB0aGlzLnNjYWxlTW9kZSkge1xyXG4gICAgICAgICAgICB0aGlzLnNjYWxlTW9kZSA9IHNjYWxlTW9kZTtcclxuICAgICAgICAgICAgZGlydHkgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobWlwbWFwICE9PSB1bmRlZmluZWQgJiYgbWlwbWFwICE9PSB0aGlzLm1pcG1hcCkge1xyXG4gICAgICAgICAgICB0aGlzLm1pcG1hcCA9IG1pcG1hcDtcclxuICAgICAgICAgICAgZGlydHkgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZGlydHkpIHtcclxuICAgICAgICAgICAgdGhpcy5kaXJ0eVN0eWxlSWQrKztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIENoYW5nZXMgdy9oL3Jlc29sdXRpb24uIFRleHR1cmUgYmVjb21lcyB2YWxpZCBpZiB3aWR0aCBhbmQgaGVpZ2h0IGFyZSBncmVhdGVyIHRoYW4gemVyby5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd2lkdGggVmlzdWFsIHdpZHRoXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IFZpc3VhbCBoZWlnaHRcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcmVzb2x1dGlvbl0gT3B0aW9uYWxseSBzZXQgcmVzb2x1dGlvblxyXG4gICAgICogQHJldHVybnMge0Jhc2VUZXh0dXJlfSB0aGlzXHJcbiAgICAgKi9cclxuICAgIHNldFNpemUod2lkdGgsIGhlaWdodCwgcmVzb2x1dGlvbiA9IG51bGwpIHtcclxuICAgICAgICB0aGlzLnJlc29sdXRpb24gPSByZXNvbHV0aW9uIHx8IHRoaXMucmVzb2x1dGlvbjtcclxuICAgICAgICB0aGlzLndpZHRoID0gd2lkdGg7XHJcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XHJcbiAgICAgICAgdGhpcy5fcmVmcmVzaFBPVCgpO1xyXG4gICAgICAgIHRoaXMudXBkYXRlKCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFNldHMgcmVhbCBzaXplIG9mIGJhc2VUZXh0dXJlLCBwcmVzZXJ2ZXMgY3VycmVudCByZXNvbHV0aW9uLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByZWFsV2lkdGggRnVsbCByZW5kZXJlZCB3aWR0aFxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJlYWxIZWlnaHQgRnVsbCByZW5kZXJlZCBoZWlnaHRcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcmVzb2x1dGlvbl0gT3B0aW9uYWxseSBzZXQgcmVzb2x1dGlvblxyXG4gICAgICogQHJldHVybnMge0Jhc2VUZXh0dXJlfSB0aGlzXHJcbiAgICAgKi9cclxuICAgIHNldFJlYWxTaXplKHJlYWxXaWR0aCwgcmVhbEhlaWdodCwgcmVzb2x1dGlvbiA9IG51bGwpIHtcclxuICAgICAgICB0aGlzLnJlc29sdXRpb24gPSByZXNvbHV0aW9uIHx8IHRoaXMucmVzb2x1dGlvbjtcclxuICAgICAgICB0aGlzLndpZHRoID0gcmVhbFdpZHRoIC8gdGhpcy5yZXNvbHV0aW9uO1xyXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gcmVhbEhlaWdodCAvIHRoaXMucmVzb2x1dGlvbjtcclxuICAgICAgICB0aGlzLl9yZWZyZXNoUE9UKCk7XHJcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogUmVmcmVzaCBjaGVjayBmb3IgaXNQb3dlck9mVHdvIHRleHR1cmUgYmFzZWQgb24gc2l6ZVxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIF9yZWZyZXNoUE9UKCkge1xyXG4gICAgICAgIHRoaXMuaXNQb3dlck9mVHdvID0gTWF0aFNldHRpbmdzXzEuTWF0aFNldHRpbmdzLmlzUG93Mih0aGlzLnJlYWxXaWR0aCkgJiYgTWF0aFNldHRpbmdzXzEuTWF0aFNldHRpbmdzLmlzUG93Mih0aGlzLnJlYWxIZWlnaHQpO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDaGFuZ2VzIHJlc29sdXRpb25cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3Jlc29sdXRpb25dIHJlc1xyXG4gICAgICogQHJldHVybnMge0Jhc2VUZXh0dXJlfSB0aGlzXHJcbiAgICAgKi9cclxuICAgIHNldFJlc29sdXRpb24ocmVzb2x1dGlvbikge1xyXG4gICAgICAgIHZhciBvbGRSZXNvbHV0aW9uID0gdGhpcy5yZXNvbHV0aW9uO1xyXG4gICAgICAgIGlmIChvbGRSZXNvbHV0aW9uID09PSByZXNvbHV0aW9uKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnJlc29sdXRpb24gPSByZXNvbHV0aW9uO1xyXG4gICAgICAgIGlmICh0aGlzLnZhbGlkKSB7XHJcbiAgICAgICAgICAgIHRoaXMud2lkdGggPSB0aGlzLndpZHRoICogb2xkUmVzb2x1dGlvbiAvIHJlc29sdXRpb247XHJcbiAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5oZWlnaHQgKiBvbGRSZXNvbHV0aW9uIC8gcmVzb2x1dGlvbjtcclxuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KEV2ZW50XzEuRXZlbnQuZ2V0RXZlbnQoXCJ1cGRhdGVcIikpO1xyXG4gICAgICAgICAgICAvLyB0aGlzLmVtaXQoJ3VwZGF0ZScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9yZWZyZXNoUE9UKCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIHJlc291cmNlIGlmIGl0IHdhc24ndCBzZXQuIFRocm93cyBlcnJvciBpZiByZXNvdXJjZSBhbHJlYWR5IHByZXNlbnRcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1BJWEkucmVzb3VyY2VzLlJlc291cmNlfSByZXNvdXJjZSAtIHRoYXQgaXMgbWFuYWdpbmcgdGhpcyBCYXNlVGV4dHVyZVxyXG4gICAgICogQHJldHVybnMge0Jhc2VUZXh0dXJlfSB0aGlzXHJcbiAgICAgKi9cclxuICAgIHNldFJlc291cmNlKHJlc291cmNlKSB7XHJcbiAgICAgICAgaWYgKHRoaXMucmVzb3VyY2UgPT09IHJlc291cmNlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5yZXNvdXJjZSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Jlc291cmNlIGNhbiBiZSBzZXQgb25seSBvbmNlJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMucmVzb3VyY2UgPSByZXNvdXJjZTtcclxuICAgICAgICBpZiAocmVzb3VyY2UgaW5zdGFuY2VvZiBJbWFnZUJpdG1hcCkge1xyXG4gICAgICAgICAgICB0aGlzLnNldFJlYWxTaXplKHRoaXMucmVzb3VyY2Uud2lkdGgsIHRoaXMucmVzb3VyY2UuaGVpZ2h0KTtcclxuICAgICAgICAgICAgdGhpcy5oYW5kbGVVcGRhdGUobnVsbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXNvdXJjZS5hZGRFdmVudExpc3RlbmVyKFwidXBkYXRlXCIsIHRoaXMuaGFuZGxlVXBkYXRlKTtcclxuICAgICAgICAgICAgcmVzb3VyY2UuYWRkRXZlbnRMaXN0ZW5lcihcInNldFJlYWxTaXplXCIsIHRoaXMuaGFuZGxlUmVzaXplKTtcclxuICAgICAgICAgICAgdGhpcy5zZXRSZWFsU2l6ZSh0aGlzLnJlc291cmNlLndpZHRoLCB0aGlzLnJlc291cmNlLmhlaWdodCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHJlc291cmNlLmJpbmQodGhpcyk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIEludmFsaWRhdGVzIHRoZSBvYmplY3QuIFRleHR1cmUgYmVjb21lcyB2YWxpZCBpZiB3aWR0aCBhbmQgaGVpZ2h0IGFyZSBncmVhdGVyIHRoYW4gemVyby5cclxuICAgICAqL1xyXG4gICAgdXBkYXRlKCkge1xyXG4gICAgICAgIGlmICghdGhpcy52YWxpZCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy53aWR0aCA+IDAgJiYgdGhpcy5oZWlnaHQgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnZhbGlkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChFdmVudF8xLkV2ZW50LmdldEV2ZW50KFwibG9hZGVkXCIpKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChFdmVudF8xLkV2ZW50LmdldEV2ZW50KFwidXBkYXRlXCIpKTtcclxuICAgICAgICAgICAgICAgIC8vIHRoaXMuZW1pdCgnbG9hZGVkJywgdGhpcyk7XHJcbiAgICAgICAgICAgICAgICAvLyB0aGlzLmVtaXQoJ3VwZGF0ZScsIHRoaXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmRpcnR5SWQrKztcclxuICAgICAgICAgICAgdGhpcy5kaXJ0eVN0eWxlSWQrKztcclxuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KEV2ZW50XzEuRXZlbnQuZ2V0RXZlbnQoXCJ1cGRhdGVcIikpO1xyXG4gICAgICAgICAgICAvLyB0aGlzLmVtaXQoJ3VwZGF0ZScsIHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogRGVzdHJveXMgdGhpcyBiYXNlIHRleHR1cmUuXHJcbiAgICAgKiBUaGUgbWV0aG9kIHN0b3BzIGlmIHJlc291cmNlIGRvZXNuJ3Qgd2FudCB0aGlzIHRleHR1cmUgdG8gYmUgZGVzdHJveWVkLlxyXG4gICAgICogUmVtb3ZlcyB0ZXh0dXJlIGZyb20gYWxsIGNhY2hlcy5cclxuICAgICAqL1xyXG4gICAgZGVzdHJveSgpIHtcclxuICAgICAgICAvLyByZW1vdmUgYW5kIGRlc3Ryb3kgdGhlIHJlc291cmNlXHJcbiAgICAgICAgaWYgKHRoaXMucmVzb3VyY2UpIHtcclxuICAgICAgICAgICAgdGhpcy5yZXNvdXJjZS51bmJpbmQodGhpcyk7XHJcbiAgICAgICAgICAgIC8vIG9ubHkgZGVzdHJveSByZXNvdXJjZWQgY3JlYXRlZCBpbnRlcm5hbGx5XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnJlc291cmNlLmludGVybmFsKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlc291cmNlLmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnJlc291cmNlID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuY2FjaGVJZCkge1xyXG4gICAgICAgICAgICBkZWxldGUgQ2FjaGVTZXR0aW5nc18xLkNhY2hlU2V0dGluZ3MuQmFzZVRleHR1cmVDYWNoZVt0aGlzLmNhY2hlSWRdO1xyXG4gICAgICAgICAgICBkZWxldGUgQ2FjaGVTZXR0aW5nc18xLkNhY2hlU2V0dGluZ3MuVGV4dHVyZUNhY2hlW3RoaXMuY2FjaGVJZF07XHJcbiAgICAgICAgICAgIHRoaXMuY2FjaGVJZCA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGZpbmFsbHkgbGV0IHRoZSBXZWJHTCByZW5kZXJlciBrbm93Li5cclxuICAgICAgICB0aGlzLmRpc3Bvc2UoKTtcclxuICAgICAgICBCYXNlVGV4dHVyZS5yZW1vdmVGcm9tQ2FjaGUodGhpcyk7XHJcbiAgICAgICAgdGhpcy50ZXh0dXJlQ2FjaGVJZHMgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogRnJlZXMgdGhlIHRleHR1cmUgZnJvbSBXZWJHTCBtZW1vcnkgd2l0aG91dCBkZXN0cm95aW5nIHRoaXMgdGV4dHVyZSBvYmplY3QuXHJcbiAgICAgKiBUaGlzIG1lYW5zIHlvdSBjYW4gc3RpbGwgdXNlIHRoZSB0ZXh0dXJlIGxhdGVyIHdoaWNoIHdpbGwgdXBsb2FkIGl0IHRvIEdQVVxyXG4gICAgICogbWVtb3J5IGFnYWluLlxyXG4gICAgICpcclxuICAgICAqIEBmaXJlcyBQSVhJLkJhc2VUZXh0dXJlI2Rpc3Bvc2VcclxuICAgICAqL1xyXG4gICAgZGlzcG9zZSgpIHtcclxuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoRXZlbnRfMS5FdmVudC5nZXRFdmVudChcImRpc3Bvc2VcIikpO1xyXG4gICAgICAgIC8vIHRoaXMuZW1pdCgnZGlzcG9zZScsIHRoaXMpO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBIZWxwZXIgZnVuY3Rpb24gdGhhdCBjcmVhdGVzIGEgYmFzZSB0ZXh0dXJlIGJhc2VkIG9uIHRoZSBzb3VyY2UgeW91IHByb3ZpZGUuXHJcbiAgICAgKiBUaGUgc291cmNlIGNhbiBiZSAtIGltYWdlIHVybCwgaW1hZ2UgZWxlbWVudCwgY2FudmFzIGVsZW1lbnQuIElmIHRoZVxyXG4gICAgICogc291cmNlIGlzIGFuIGltYWdlIHVybCBvciBhbiBpbWFnZSBlbGVtZW50IGFuZCBub3QgaW4gdGhlIGJhc2UgdGV4dHVyZVxyXG4gICAgICogY2FjaGUsIGl0IHdpbGwgYmUgY3JlYXRlZCBhbmQgbG9hZGVkLlxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfEhUTUxJbWFnZUVsZW1lbnR8SFRNTENhbnZhc0VsZW1lbnR8U1ZHRWxlbWVudHxIVE1MVmlkZW9FbGVtZW50fSBzb3VyY2UgLSBUaGVcclxuICAgICAqICAgICAgICBzb3VyY2UgdG8gY3JlYXRlIGJhc2UgdGV4dHVyZSBmcm9tLlxyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSBTZWUge0BsaW5rIFBJWEkuQmFzZVRleHR1cmV9J3MgY29uc3RydWN0b3IgZm9yIG9wdGlvbnMuXHJcbiAgICAgKiBAcmV0dXJucyB7UElYSS5CYXNlVGV4dHVyZX0gVGhlIG5ldyBiYXNlIHRleHR1cmUuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBmcm9tKHNvdXJjZSwgb3B0aW9ucykge1xyXG4gICAgICAgIHZhciBjYWNoZUlkID0gbnVsbDtcclxuICAgICAgICBpZiAodHlwZW9mIHNvdXJjZSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgY2FjaGVJZCA9IHNvdXJjZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmICghc291cmNlLl9waXhpSWQpIHtcclxuICAgICAgICAgICAgICAgIHNvdXJjZS5fcGl4aUlkID0gXCJwaXhpaWRfXCIgKyAoTWF0aFNldHRpbmdzXzEuTWF0aFNldHRpbmdzLnVpZCgpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYWNoZUlkID0gc291cmNlLl9waXhpSWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBiYXNlVGV4dHVyZSA9IENhY2hlU2V0dGluZ3NfMS5DYWNoZVNldHRpbmdzLkJhc2VUZXh0dXJlQ2FjaGVbY2FjaGVJZF07XHJcbiAgICAgICAgaWYgKCFiYXNlVGV4dHVyZSkge1xyXG4gICAgICAgICAgICBiYXNlVGV4dHVyZSA9IG5ldyBCYXNlVGV4dHVyZShzb3VyY2UsIG9wdGlvbnMpO1xyXG4gICAgICAgICAgICBiYXNlVGV4dHVyZS5jYWNoZUlkID0gY2FjaGVJZDtcclxuICAgICAgICAgICAgQmFzZVRleHR1cmUuYWRkVG9DYWNoZShiYXNlVGV4dHVyZSwgY2FjaGVJZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBiYXNlVGV4dHVyZTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIGEgbmV3IEJhc2VUZXh0dXJlIHdpdGggYSBCdWZmZXJSZXNvdXJjZSBmcm9tIGEgRmxvYXQzMkFycmF5LlxyXG4gICAgICogUkdCQSB2YWx1ZXMgYXJlIGZsb2F0cyBmcm9tIDAgdG8gMS5cclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fFVpbnQ4QXJyYXl9IGJ1ZmZlciBUaGUgb3B0aW9uYWwgYXJyYXkgdG8gdXNlLCBpZiBubyBkYXRhXHJcbiAgICAgKiAgICAgICAgaXMgcHJvdmlkZWQsIGEgbmV3IEZsb2F0MzJBcnJheSBpcyBjcmVhdGVkLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIC0gV2lkdGggb2YgdGhlIHJlc291cmNlXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IC0gSGVpZ2h0IG9mIHRoZSByZXNvdXJjZVxyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSBTZWUge0BsaW5rIFBJWEkuQmFzZVRleHR1cmV9J3MgY29uc3RydWN0b3IgZm9yIG9wdGlvbnMuXHJcbiAgICAgKiBAcmV0dXJuIHtQSVhJLkJhc2VUZXh0dXJlfSBUaGUgcmVzdWx0aW5nIG5ldyBCYXNlVGV4dHVyZVxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZnJvbUJ1ZmZlcihidWZmZXIsIHdpZHRoLCBoZWlnaHQsIG9wdGlvbnMpIHtcclxuICAgICAgICBidWZmZXIgPSBidWZmZXIgfHwgbmV3IEZsb2F0MzJBcnJheSh3aWR0aCAqIGhlaWdodCAqIDQpO1xyXG4gICAgICAgIHZhciByZXNvdXJjZSA9IG5ldyBCdWZmZXJSZXNvdXJjZV8xLkJ1ZmZlclJlc291cmNlKGJ1ZmZlciwgeyB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0IH0pO1xyXG4gICAgICAgIHZhciB0eXBlID0gYnVmZmVyIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5ID8gV2ViR0xTZXR0aW5nc18xLldlYkdMU2V0dGluZ3MuVFlQRVMuRkxPQVQgOiBXZWJHTFNldHRpbmdzXzEuV2ViR0xTZXR0aW5ncy5UWVBFUy5VTlNJR05FRF9CWVRFO1xyXG4gICAgICAgIHJldHVybiBuZXcgQmFzZVRleHR1cmUocmVzb3VyY2UsIE9iamVjdC5hc3NpZ24oV2ViR0xTZXR0aW5nc18xLldlYkdMU2V0dGluZ3MuZGVmYXVsdEJ1ZmZlck9wdGlvbnMsIG9wdGlvbnMgfHwgeyB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0LCB0eXBlOiB0eXBlIH0pKTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhIEJhc2VUZXh0dXJlIHRvIHRoZSBnbG9iYWwgQmFzZVRleHR1cmVDYWNoZS4gVGhpcyBjYWNoZSBpcyBzaGFyZWQgYWNyb3NzIHRoZSB3aG9sZSBQSVhJIG9iamVjdC5cclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAcGFyYW0ge1BJWEkuQmFzZVRleHR1cmV9IGJhc2VUZXh0dXJlIC0gVGhlIEJhc2VUZXh0dXJlIHRvIGFkZCB0byB0aGUgY2FjaGUuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgLSBUaGUgaWQgdGhhdCB0aGUgQmFzZVRleHR1cmUgd2lsbCBiZSBzdG9yZWQgYWdhaW5zdC5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGFkZFRvQ2FjaGUoYmFzZVRleHR1cmUsIGlkKSB7XHJcbiAgICAgICAgaWYgKGlkKSB7XHJcbiAgICAgICAgICAgIGlmIChiYXNlVGV4dHVyZS50ZXh0dXJlQ2FjaGVJZHMuaW5kZXhPZihpZCkgPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICBiYXNlVGV4dHVyZS50ZXh0dXJlQ2FjaGVJZHMucHVzaChpZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKENhY2hlU2V0dGluZ3NfMS5DYWNoZVNldHRpbmdzLkJhc2VUZXh0dXJlQ2FjaGVbaWRdKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxyXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKChcIkJhc2VUZXh0dXJlIGFkZGVkIHRvIHRoZSBjYWNoZSB3aXRoIGFuIGlkIFtcIiArIGlkICsgXCJdIHRoYXQgYWxyZWFkeSBoYWQgYW4gZW50cnlcIikpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIENhY2hlU2V0dGluZ3NfMS5DYWNoZVNldHRpbmdzLkJhc2VUZXh0dXJlQ2FjaGVbaWRdID0gYmFzZVRleHR1cmU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmUgYSBCYXNlVGV4dHVyZSBmcm9tIHRoZSBnbG9iYWwgQmFzZVRleHR1cmVDYWNoZS5cclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xQSVhJLkJhc2VUZXh0dXJlfSBiYXNlVGV4dHVyZSAtIGlkIG9mIGEgQmFzZVRleHR1cmUgdG8gYmUgcmVtb3ZlZCwgb3IgYSBCYXNlVGV4dHVyZSBpbnN0YW5jZSBpdHNlbGYuXHJcbiAgICAgKiBAcmV0dXJuIHtQSVhJLkJhc2VUZXh0dXJlfG51bGx9IFRoZSBCYXNlVGV4dHVyZSB0aGF0IHdhcyByZW1vdmVkLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgcmVtb3ZlRnJvbUNhY2hlKGJhc2VUZXh0dXJlKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBiYXNlVGV4dHVyZSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgdmFyIGJhc2VUZXh0dXJlRnJvbUNhY2hlID0gQ2FjaGVTZXR0aW5nc18xLkNhY2hlU2V0dGluZ3MuQmFzZVRleHR1cmVDYWNoZVtiYXNlVGV4dHVyZV07XHJcbiAgICAgICAgICAgIGlmIChiYXNlVGV4dHVyZUZyb21DYWNoZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gYmFzZVRleHR1cmVGcm9tQ2FjaGUudGV4dHVyZUNhY2hlSWRzLmluZGV4T2YoYmFzZVRleHR1cmUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICBiYXNlVGV4dHVyZUZyb21DYWNoZS50ZXh0dXJlQ2FjaGVJZHMuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGRlbGV0ZSBDYWNoZVNldHRpbmdzXzEuQ2FjaGVTZXR0aW5ncy5CYXNlVGV4dHVyZUNhY2hlW2Jhc2VUZXh0dXJlXTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBiYXNlVGV4dHVyZUZyb21DYWNoZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChiYXNlVGV4dHVyZSAmJiBiYXNlVGV4dHVyZS50ZXh0dXJlQ2FjaGVJZHMpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiYXNlVGV4dHVyZS50ZXh0dXJlQ2FjaGVJZHMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgICAgIGRlbGV0ZSBDYWNoZVNldHRpbmdzXzEuQ2FjaGVTZXR0aW5ncy5CYXNlVGV4dHVyZUNhY2hlW2Jhc2VUZXh0dXJlLnRleHR1cmVDYWNoZUlkc1tpXV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYmFzZVRleHR1cmUudGV4dHVyZUNhY2hlSWRzLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgIHJldHVybiBiYXNlVGV4dHVyZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICA7XHJcbn1cclxuLyoqXHJcbiAqIEdsb2JhbCBudW1iZXIgb2YgdGhlIHRleHR1cmUgYmF0Y2gsIHVzZWQgYnkgbXVsdGktdGV4dHVyZSByZW5kZXJlcnNcclxuICpcclxuICogQHN0YXRpY1xyXG4gKiBAbWVtYmVyIHtudW1iZXJ9IG5ldyB0ZXh0dXJlIGJhdGNoIG51bWJlclxyXG4gKi9cclxuQmFzZVRleHR1cmUuX2dsb2JhbEJhdGNoID0gMDtcclxuZXhwb3J0cy5CYXNlVGV4dHVyZSA9IEJhc2VUZXh0dXJlO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jbGFzcyBCYXRjaEJ1ZmZlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihzaXplKSB7XHJcbiAgICAgICAgdGhpcy52ZXJ0aWNlcyA9IG5ldyBBcnJheUJ1ZmZlcihzaXplKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBWaWV3IG9uIHRoZSB2ZXJ0aWNlcyBhcyBhIEZsb2F0MzJBcnJheSBmb3IgcG9zaXRpb25zXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAbWVtYmVyIHtGbG9hdDMyQXJyYXl9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5mbG9hdDMyVmlldyA9IG5ldyBGbG9hdDMyQXJyYXkodGhpcy52ZXJ0aWNlcyk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVmlldyBvbiB0aGUgdmVydGljZXMgYXMgYSBVaW50MzJBcnJheSBmb3IgdXZzXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAbWVtYmVyIHtGbG9hdDMyQXJyYXl9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy51aW50MzJWaWV3ID0gbmV3IFVpbnQzMkFycmF5KHRoaXMudmVydGljZXMpO1xyXG4gICAgfVxyXG4gICAgZGVzdHJveSgpIHtcclxuICAgICAgICB0aGlzLnZlcnRpY2VzID0gbnVsbDtcclxuICAgICAgICB0aGlzLmZsb2F0MzJWaWV3ID0gbnVsbDtcclxuICAgICAgICB0aGlzLnVpbnQzMlZpZXcgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgO1xyXG59XHJcbmV4cG9ydHMuQmF0Y2hCdWZmZXIgPSBCYXRjaEJ1ZmZlcjtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY2xhc3MgQmF0Y2hEcmF3Q2FsbCB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLnRleHR1cmVzID0gW107XHJcbiAgICAgICAgdGhpcy5pZHMgPSBbXTtcclxuICAgICAgICB0aGlzLmJsZW5kID0gMDtcclxuICAgICAgICB0aGlzLnRleHR1cmVDb3VudCA9IDA7XHJcbiAgICAgICAgdGhpcy5zdGFydCA9IDA7XHJcbiAgICAgICAgdGhpcy5zaXplID0gMDtcclxuICAgICAgICB0aGlzLnR5cGUgPSA0O1xyXG4gICAgfVxyXG4gICAgO1xyXG59XHJcbmV4cG9ydHMuQmF0Y2hEcmF3Q2FsbCA9IEJhdGNoRHJhd0NhbGw7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IEdlb21ldHJ5XzEgPSByZXF1aXJlKFwiLi9HZW9tZXRyeVwiKTtcclxuY29uc3QgQnVmZmVyXzEgPSByZXF1aXJlKFwiLi9CdWZmZXJcIik7XHJcbmNvbnN0IFdlYkdMU2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL1dlYkdMU2V0dGluZ3NcIik7XHJcbmNsYXNzIEJhdGNoR2VvbWV0cnkgZXh0ZW5kcyBHZW9tZXRyeV8xLkdlb21ldHJ5IHtcclxuICAgIGNvbnN0cnVjdG9yKF9zdGF0aWMgPSBmYWxzZSkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQnVmZmVyIHVzZWQgZm9yIHBvc2l0aW9uLCBjb2xvciwgdGV4dHVyZSBJRHNcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuQnVmZmVyfVxyXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLl9idWZmZXIgPSBuZXcgQnVmZmVyXzEuQnVmZmVyKG51bGwsIF9zdGF0aWMsIGZhbHNlKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJbmRleCBidWZmZXIgZGF0YVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQG1lbWJlciB7UElYSS5CdWZmZXJ9XHJcbiAgICAgICAgICogQHByb3RlY3RlZFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuX2luZGV4QnVmZmVyID0gbmV3IEJ1ZmZlcl8xLkJ1ZmZlcihudWxsLCBfc3RhdGljLCB0cnVlKTtcclxuICAgICAgICB0aGlzLmFkZEF0dHJpYnV0ZSgnYVZlcnRleFBvc2l0aW9uJywgdGhpcy5fYnVmZmVyLCAyLCBmYWxzZSwgV2ViR0xTZXR0aW5nc18xLldlYkdMU2V0dGluZ3MuVFlQRVMuRkxPQVQpXHJcbiAgICAgICAgICAgIC5hZGRBdHRyaWJ1dGUoJ2FUZXh0dXJlQ29vcmQnLCB0aGlzLl9idWZmZXIsIDIsIGZhbHNlLCBXZWJHTFNldHRpbmdzXzEuV2ViR0xTZXR0aW5ncy5UWVBFUy5GTE9BVClcclxuICAgICAgICAgICAgLmFkZEF0dHJpYnV0ZSgnYUNvbG9yJywgdGhpcy5fYnVmZmVyLCA0LCB0cnVlLCBXZWJHTFNldHRpbmdzXzEuV2ViR0xTZXR0aW5ncy5UWVBFUy5VTlNJR05FRF9CWVRFKVxyXG4gICAgICAgICAgICAuYWRkQXR0cmlidXRlKCdhVGV4dHVyZUlkJywgdGhpcy5fYnVmZmVyLCAxLCB0cnVlLCBXZWJHTFNldHRpbmdzXzEuV2ViR0xTZXR0aW5ncy5UWVBFUy5GTE9BVClcclxuICAgICAgICAgICAgLmFkZEluZGV4KHRoaXMuX2luZGV4QnVmZmVyKTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLkJhdGNoR2VvbWV0cnkgPSBCYXRjaEdlb21ldHJ5O1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBPYmplY3RSZW5kZXJlcl8xID0gcmVxdWlyZShcIi4vT2JqZWN0UmVuZGVyZXJcIik7XHJcbmNvbnN0IEJhdGNoR2VvbWV0cnlfMSA9IHJlcXVpcmUoXCIuL0JhdGNoR2VvbWV0cnlcIik7XHJcbmNvbnN0IEJhc2VUZXh0dXJlXzEgPSByZXF1aXJlKFwiLi9CYXNlVGV4dHVyZVwiKTtcclxuY29uc3QgQmF0Y2hEcmF3Q2FsbF8xID0gcmVxdWlyZShcIi4vQmF0Y2hEcmF3Q2FsbFwiKTtcclxuY29uc3QgU3RhdGVfMSA9IHJlcXVpcmUoXCIuL1N0YXRlXCIpO1xyXG5jb25zdCBCYXRjaEJ1ZmZlcl8xID0gcmVxdWlyZShcIi4vQmF0Y2hCdWZmZXJcIik7XHJcbmNvbnN0IENvbG9yU2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL0NvbG9yU2V0dGluZ3NcIik7XHJcbmNvbnN0IFdlYkdMU2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL1dlYkdMU2V0dGluZ3NcIik7XHJcbmNvbnN0IEJsZW5kTW9kZXNTZXR0aW5nc18xID0gcmVxdWlyZShcIi4vQmxlbmRNb2Rlc1NldHRpbmdzXCIpO1xyXG5jb25zdCBNYXRoU2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL01hdGhTZXR0aW5nc1wiKTtcclxuY29uc3QgRGlzcGxheVNldHRpbmdzXzEgPSByZXF1aXJlKFwiLi9EaXNwbGF5U2V0dGluZ3NcIik7XHJcbmNsYXNzIEJhdGNoUmVuZGVyZXIgZXh0ZW5kcyBPYmplY3RSZW5kZXJlcl8xLk9iamVjdFJlbmRlcmVyIHtcclxuICAgIGNvbnN0cnVjdG9yKHJlbmRlcmVyKSB7XHJcbiAgICAgICAgc3VwZXIocmVuZGVyZXIpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENhbGxlZCBiZWZvcmUgdGhlIHJlbmRlcmVyIHN0YXJ0cyByZW5kZXJpbmcuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLm9uUHJlcmVuZGVyID0gKGV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMudmVydGV4Q291bnQgPSAwO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogTnVtYmVyIG9mIHZhbHVlcyBzZW50IGluIHRoZSB2ZXJ0ZXggYnVmZmVyLlxyXG4gICAgICAgICAqIGFWZXJ0ZXhQb3NpdGlvbigyKSwgYVRleHR1cmVDb29yZCgxKSwgYUNvbG9yKDEpLCBhVGV4dHVyZUlkKDEpID0gNVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMudmVydFNpemUgPSA2O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBzaXplIG9mIHRoZSB2ZXJ0ZXggaW5mb3JtYXRpb24gaW4gYnl0ZXMuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy52ZXJ0Qnl0ZVNpemUgPSB0aGlzLnZlcnRTaXplICogNDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgbnVtYmVyIG9mIGltYWdlcyBpbiB0aGUgU3ByaXRlUmVuZGVyZXIgYmVmb3JlIGl0IGZsdXNoZXMuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5zaXplID0gMjAwMCAqIDQ7IC8vIHNldHRpbmdzLlNQUklURV9CQVRDSF9TSVpFOyAvLyAyMDAwIGlzIGEgbmljZSBiYWxhbmNlIGJldHdlZW4gbW9iaWxlIC8gZGVza3RvcFxyXG4gICAgICAgIHRoaXMuY3VycmVudFNpemUgPSAwO1xyXG4gICAgICAgIHRoaXMuY3VycmVudEluZGV4U2l6ZSA9IDA7XHJcbiAgICAgICAgLy8gdGhlIHRvdGFsIG51bWJlciBvZiBieXRlcyBpbiBvdXIgYmF0Y2hcclxuICAgICAgICAvLyBsZXQgbnVtVmVydHMgPSB0aGlzLnNpemUgKiA0ICogdGhpcy52ZXJ0Qnl0ZVNpemU7XHJcbiAgICAgICAgdGhpcy5hdHRyaWJ1dGVCdWZmZXJzID0ge307XHJcbiAgICAgICAgdGhpcy5hQnVmZmVycyA9IHt9O1xyXG4gICAgICAgIHRoaXMuaUJ1ZmZlcnMgPSB7fTtcclxuICAgICAgICAvLyAgICAgdGhpcy5kZWZ1YWx0U3ByaXRlSW5kZXhCdWZmZXIgPSBuZXcgQnVmZmVyKGNyZWF0ZUluZGljZXNGb3JRdWFkcyh0aGlzLnNpemUpLCB0cnVlLCB0cnVlKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBIb2xkcyB0aGUgZGVmdWFsdCBpbmRpY2VzIG9mIHRoZSBnZW9tZXRyeSAocXVhZHMpIHRvIGRyYXdcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBtZW1iZXIge1VpbnQxNkFycmF5fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIC8vIGNvbnN0IGluZGljaWVzID0gY3JlYXRlSW5kaWNlc0ZvclF1YWRzKHRoaXMuc2l6ZSk7XHJcbiAgICAgICAgLy8gIHRoaXMuZGVmYXVsdFF1YWRJbmRleEJ1ZmZlciA9IG5ldyBCdWZmZXIoaW5kaWNpZXMsIHRydWUsIHRydWUpO1xyXG4gICAgICAgIHRoaXMub25seVNwcml0ZXMgPSBmYWxzZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgZGVmYXVsdCBzaGFkZXJzIHRoYXQgaXMgdXNlZCBpZiBhIHNwcml0ZSBkb2Vzbid0IGhhdmUgYSBtb3JlIHNwZWNpZmljIG9uZS5cclxuICAgICAgICAgKiB0aGVyZSBpcyBhIHNoYWRlciBmb3IgZWFjaCBudW1iZXIgb2YgdGV4dHVyZXMgdGhhdCBjYW4gYmUgcmVuZGVyZWQuXHJcbiAgICAgICAgICogVGhlc2Ugc2hhZGVycyB3aWxsIGFsc28gYmUgZ2VuZXJhdGVkIG9uIHRoZSBmbHkgYXMgcmVxdWlyZWQuXHJcbiAgICAgICAgICogQG1lbWJlciB7UElYSS5TaGFkZXJbXX1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnNoYWRlciA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50SW5kZXggPSAwO1xyXG4gICAgICAgIHRoaXMuZ3JvdXBzID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCB0aGlzLnNpemUgLyA0OyBrKyspIHtcclxuICAgICAgICAgICAgdGhpcy5ncm91cHNba10gPSBuZXcgQmF0Y2hEcmF3Q2FsbF8xLkJhdGNoRHJhd0NhbGwoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5lbGVtZW50cyA9IFtdO1xyXG4gICAgICAgIHRoaXMudmFvcyA9IFtdO1xyXG4gICAgICAgIHRoaXMudmFvTWF4ID0gMjtcclxuICAgICAgICB0aGlzLnZlcnRleENvdW50ID0gMDtcclxuICAgICAgICB0aGlzLnJlbmRlcmVyLmFkZEV2ZW50TGlzdGVuZXIoXCJwcmVyZW5kZXJcIiwgdGhpcy5vblByZXJlbmRlcik7XHJcbiAgICAgICAgLy8gdGhpcy5yZW5kZXJlci5vbigncHJlcmVuZGVyJywgdGhpcy5vblByZXJlbmRlciwgdGhpcyk7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlXzEuU3RhdGUuZm9yMmQoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB1cCB0aGUgcmVuZGVyZXIgY29udGV4dCBhbmQgbmVjZXNzYXJ5IGJ1ZmZlcnMuXHJcbiAgICAgKi9cclxuICAgIGNvbnRleHRDaGFuZ2UoKSB7XHJcbiAgICAgICAgdmFyIGdsID0gdGhpcy5yZW5kZXJlci5nbDtcclxuICAgICAgICBpZiAoRGlzcGxheVNldHRpbmdzXzEuRGlzcGxheVNldHRpbmdzLlBSRUZFUl9FTlYgPT09IERpc3BsYXlTZXR0aW5nc18xLkRpc3BsYXlTZXR0aW5ncy5FTlYuV0VCR0xfTEVHQUNZKSB7XHJcbiAgICAgICAgICAgIHRoaXMuTUFYX1RFWFRVUkVTID0gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIHN0ZXAgMTogZmlyc3QgY2hlY2sgbWF4IHRleHR1cmVzIHRoZSBHUFUgY2FuIGhhbmRsZS5cclxuICAgICAgICAgICAgdGhpcy5NQVhfVEVYVFVSRVMgPSBNYXRoLm1pbihnbC5nZXRQYXJhbWV0ZXIoZ2wuTUFYX1RFWFRVUkVfSU1BR0VfVU5JVFMpLCBXZWJHTFNldHRpbmdzXzEuV2ViR0xTZXR0aW5ncy5TUFJJVEVfTUFYX1RFWFRVUkVTKTtcclxuICAgICAgICAgICAgLy8gc3RlcCAyOiBjaGVjayB0aGUgbWF4aW11bSBudW1iZXIgb2YgaWYgc3RhdGVtZW50cyB0aGUgc2hhZGVyIGNhbiBoYXZlIHRvby4uXHJcbiAgICAgICAgICAgIHRoaXMuTUFYX1RFWFRVUkVTID0gV2ViR0xTZXR0aW5nc18xLldlYkdMU2V0dGluZ3MuY2hlY2tNYXhJZlN0YXRlbWVudHNJblNoYWRlcih0aGlzLk1BWF9URVhUVVJFUywgZ2wpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBnZW5lcmF0ZSBnZW5lcmF0ZU11bHRpVGV4dHVyZVByb2dyYW0sIG1heSBiZSBhIGJldHRlciBtb3ZlP1xyXG4gICAgICAgIHRoaXMuc2hhZGVyID0gV2ViR0xTZXR0aW5nc18xLldlYkdMU2V0dGluZ3MuZ2VuZXJhdGVNdWx0aVRleHR1cmVTaGFkZXIoZ2wsIHRoaXMuTUFYX1RFWFRVUkVTKTtcclxuICAgICAgICAvLyB3ZSB1c2UgdGhlIHNlY29uZCBzaGFkZXIgYXMgdGhlIGZpcnN0IG9uZSBkZXBlbmRpbmcgb24geW91ciBicm93c2VyIG1heSBvbWl0IGFUZXh0dXJlSWRcclxuICAgICAgICAvLyBhcyBpdCBpcyBub3QgdXNlZCBieSB0aGUgc2hhZGVyIHNvIGlzIG9wdGltaXplZCBvdXQuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnZhb01heDsgaSsrKSB7XHJcbiAgICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4gKi9cclxuICAgICAgICAgICAgdGhpcy52YW9zW2ldID0gbmV3IEJhdGNoR2VvbWV0cnlfMS5CYXRjaEdlb21ldHJ5KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZW5kZXJzIHRoZSBzcHJpdGUgb2JqZWN0LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7UElYSS5TcHJpdGV9IHNwcml0ZSAtIHRoZSBzcHJpdGUgdG8gcmVuZGVyIHdoZW4gdXNpbmcgdGhpcyBzcHJpdGViYXRjaFxyXG4gICAgICovXHJcbiAgICByZW5kZXIoZWxlbWVudCkge1xyXG4gICAgICAgIC8vIHRyYWNlKFwicmVuZGVyaW5nIGVsZW1lbnQ6IFwiICsgZWxlbWVudC5fdGV4dHVyZS52YWxpZClcclxuICAgICAgICBpZiAoIWVsZW1lbnQuX3RleHR1cmUudmFsaWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5jdXJyZW50U2l6ZSArIChlbGVtZW50LnZlcnRleERhdGEubGVuZ3RoIC8gMikgPiB0aGlzLnNpemUpIHtcclxuICAgICAgICAgICAgdGhpcy5mbHVzaCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmVsZW1lbnRzW3RoaXMuY3VycmVudEluZGV4KytdID0gZWxlbWVudDtcclxuICAgICAgICB0aGlzLmN1cnJlbnRTaXplICs9IGVsZW1lbnQudmVydGV4RGF0YS5sZW5ndGggLyAyO1xyXG4gICAgICAgIC8vIHRyYWNlKFwiY3VycmVudFNpemU6IFwiICsgdGhpcy5jdXJyZW50U2l6ZSlcclxuICAgICAgICB0aGlzLmN1cnJlbnRJbmRleFNpemUgKz0gZWxlbWVudC5pbmRpY2VzLmxlbmd0aDtcclxuICAgIH1cclxuICAgIDtcclxuICAgIGdldEluZGV4QnVmZmVyKHNpemUpIHtcclxuICAgICAgICAvLyAxMiBpbmRpY2VzIGlzIGVub3VnaCBmb3IgMiBxdWFkc1xyXG4gICAgICAgIHZhciByb3VuZGVkUDIgPSBNYXRoU2V0dGluZ3NfMS5NYXRoU2V0dGluZ3MubmV4dFBvdzIoTWF0aC5jZWlsKHNpemUgLyAxMikpO1xyXG4gICAgICAgIHZhciByb3VuZGVkU2l6ZUluZGV4ID0gTWF0aFNldHRpbmdzXzEuTWF0aFNldHRpbmdzLmxvZzIocm91bmRlZFAyKTtcclxuICAgICAgICB2YXIgcm91bmRlZFNpemUgPSByb3VuZGVkUDIgKiAxMjtcclxuICAgICAgICBpZiAodGhpcy5pQnVmZmVycy5sZW5ndGggPD0gcm91bmRlZFNpemVJbmRleCkge1xyXG4gICAgICAgICAgICB0aGlzLmlCdWZmZXJzLmxlbmd0aCA9IHJvdW5kZWRTaXplSW5kZXggKyAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgYnVmZmVyID0gdGhpcy5pQnVmZmVyc1tyb3VuZGVkU2l6ZUluZGV4XTtcclxuICAgICAgICBpZiAoIWJ1ZmZlcikge1xyXG4gICAgICAgICAgICB0aGlzLmlCdWZmZXJzW3JvdW5kZWRTaXplSW5kZXhdID0gYnVmZmVyID0gbmV3IFVpbnQxNkFycmF5KHJvdW5kZWRTaXplKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGJ1ZmZlcjtcclxuICAgIH1cclxuICAgIDtcclxuICAgIGdldEF0dHJpYnV0ZUJ1ZmZlcihzaXplKSB7XHJcbiAgICAgICAgLy8gOCB2ZXJ0aWNlcyBpcyBlbm91Z2ggZm9yIDIgcXVhZHNcclxuICAgICAgICB2YXIgcm91bmRlZFAyID0gTWF0aFNldHRpbmdzXzEuTWF0aFNldHRpbmdzLm5leHRQb3cyKE1hdGguY2VpbChzaXplIC8gOCkpO1xyXG4gICAgICAgIHZhciByb3VuZGVkU2l6ZUluZGV4ID0gTWF0aFNldHRpbmdzXzEuTWF0aFNldHRpbmdzLmxvZzIocm91bmRlZFAyKTtcclxuICAgICAgICB2YXIgcm91bmRlZFNpemUgPSByb3VuZGVkUDIgKiA4O1xyXG4gICAgICAgIGlmICh0aGlzLmFCdWZmZXJzLmxlbmd0aCA8PSByb3VuZGVkU2l6ZUluZGV4KSB7XHJcbiAgICAgICAgICAgIHRoaXMuaUJ1ZmZlcnMubGVuZ3RoID0gcm91bmRlZFNpemVJbmRleCArIDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBidWZmZXIgPSB0aGlzLmFCdWZmZXJzW3JvdW5kZWRTaXplXTtcclxuICAgICAgICBpZiAoIWJ1ZmZlcikge1xyXG4gICAgICAgICAgICB0aGlzLmFCdWZmZXJzW3JvdW5kZWRTaXplXSA9IGJ1ZmZlciA9IG5ldyBCYXRjaEJ1ZmZlcl8xLkJhdGNoQnVmZmVyKHJvdW5kZWRTaXplICogdGhpcy52ZXJ0Qnl0ZVNpemUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYnVmZmVyO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZW5kZXJzIHRoZSBjb250ZW50IGFuZCBlbXB0aWVzIHRoZSBjdXJyZW50IGJhdGNoLlxyXG4gICAgICpcclxuICAgICAqL1xyXG4gICAgZmx1c2goKSB7XHJcbiAgICAgICAgLy8gdHJhY2UoXCJCYXRjaFJlbmRlciBmbHVzaCBcIiArIHRoaXMuY3VycmVudFNpemUpXHJcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFNpemUgPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgZ2wgPSB0aGlzLnJlbmRlcmVyLmdsO1xyXG4gICAgICAgIHZhciBNQVhfVEVYVFVSRVMgPSB0aGlzLk1BWF9URVhUVVJFUztcclxuICAgICAgICB2YXIgYnVmZmVyID0gdGhpcy5nZXRBdHRyaWJ1dGVCdWZmZXIodGhpcy5jdXJyZW50U2l6ZSk7XHJcbiAgICAgICAgLy8gcmV2ZWFsKGJ1ZmZlcik7XHJcbiAgICAgICAgdmFyIGluZGV4QnVmZmVyID0gdGhpcy5nZXRJbmRleEJ1ZmZlcih0aGlzLmN1cnJlbnRJbmRleFNpemUpO1xyXG4gICAgICAgIC8vIHJldmVhbChpbmRleEJ1ZmZlcik7XHJcbiAgICAgICAgdmFyIGVsZW1lbnRzID0gdGhpcy5lbGVtZW50cztcclxuICAgICAgICB2YXIgZ3JvdXBzID0gdGhpcy5ncm91cHM7XHJcbiAgICAgICAgdmFyIGZsb2F0MzJWaWV3ID0gYnVmZmVyLmZsb2F0MzJWaWV3O1xyXG4gICAgICAgIC8vIHJldmVhbChmbG9hdDMyVmlldyk7XHJcbiAgICAgICAgdmFyIHVpbnQzMlZpZXcgPSBidWZmZXIudWludDMyVmlldztcclxuICAgICAgICAvLyByZXZlYWwodWludDMyVmlldyk7XHJcbiAgICAgICAgdmFyIHRvdWNoID0gdGhpcy5yZW5kZXJlci50ZXh0dXJlR0MuY291bnQ7XHJcbiAgICAgICAgdmFyIGluZGV4ID0gMDtcclxuICAgICAgICB2YXIgaW5kZXhDb3VudCA9IDA7XHJcbiAgICAgICAgdmFyIG5leHRUZXh0dXJlO1xyXG4gICAgICAgIHZhciBjdXJyZW50VGV4dHVyZTtcclxuICAgICAgICB2YXIgZ3JvdXBDb3VudCA9IDA7XHJcbiAgICAgICAgdmFyIHRleHR1cmVDb3VudCA9IDA7XHJcbiAgICAgICAgdmFyIGN1cnJlbnRHcm91cCA9IGdyb3Vwc1swXTtcclxuICAgICAgICAvLyByZXZlYWwoY3VycmVudEdyb3VwKTtcclxuICAgICAgICB2YXIgYmxlbmRNb2RlID0gLTE7IC8vIHByZW11bHRpcGx5QmxlbmRNb2RlW2VsZW1lbnRzWzBdLl90ZXh0dXJlLmJhc2VUZXh0dXJlLnByZW11bHRpcGx5QWxwaGEgPyAwIDogXVtlbGVtZW50c1swXS5ibGVuZE1vZGVdO1xyXG4gICAgICAgIGN1cnJlbnRHcm91cC50ZXh0dXJlQ291bnQgPSAwO1xyXG4gICAgICAgIGN1cnJlbnRHcm91cC5zdGFydCA9IDA7XHJcbiAgICAgICAgY3VycmVudEdyb3VwLmJsZW5kID0gYmxlbmRNb2RlO1xyXG4gICAgICAgIHZhciBUSUNLID0gKytCYXNlVGV4dHVyZV8xLkJhc2VUZXh0dXJlLl9nbG9iYWxCYXRjaDtcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5jdXJyZW50SW5kZXg7ICsraSkge1xyXG4gICAgICAgICAgICAvLyB1cGxvYWQgdGhlIHNwcml0ZSBlbGVtZW50cy4uLlxyXG4gICAgICAgICAgICAvLyB0aGV5IGhhdmUgYWxsIHJlYWR5IGJlZW4gY2FsY3VsYXRlZCBzbyB3ZSBqdXN0IG5lZWQgdG8gcHVzaCB0aGVtIGludG8gdGhlIGJ1ZmZlci5cclxuICAgICAgICAgICAgdmFyIHNwcml0ZSA9IGVsZW1lbnRzW2ldO1xyXG4gICAgICAgICAgICBlbGVtZW50c1tpXSA9IG51bGw7XHJcbiAgICAgICAgICAgIG5leHRUZXh0dXJlID0gc3ByaXRlLl90ZXh0dXJlLmJhc2VUZXh0dXJlO1xyXG4gICAgICAgICAgICAvLyByZXZlYWwobmV4dFRleHR1cmUpO1xyXG4gICAgICAgICAgICB2YXIgc3ByaXRlQmxlbmRNb2RlID0gQmxlbmRNb2Rlc1NldHRpbmdzXzEuQmxlbmRNb2Rlc1NldHRpbmdzLnByZW11bHRpcGx5QmxlbmRNb2RlW25leHRUZXh0dXJlLnByZW11bHRpcGx5QWxwaGEgPyAxIDogMF1bc3ByaXRlLmJsZW5kTW9kZV07XHJcbiAgICAgICAgICAgIGlmIChibGVuZE1vZGUgIT09IHNwcml0ZUJsZW5kTW9kZSkge1xyXG4gICAgICAgICAgICAgICAgYmxlbmRNb2RlID0gc3ByaXRlQmxlbmRNb2RlO1xyXG4gICAgICAgICAgICAgICAgLy8gZm9yY2UgdGhlIGJhdGNoIHRvIGJyZWFrIVxyXG4gICAgICAgICAgICAgICAgY3VycmVudFRleHR1cmUgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgdGV4dHVyZUNvdW50ID0gTUFYX1RFWFRVUkVTO1xyXG4gICAgICAgICAgICAgICAgVElDSysrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChjdXJyZW50VGV4dHVyZSAhPT0gbmV4dFRleHR1cmUpIHtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRUZXh0dXJlID0gbmV4dFRleHR1cmU7XHJcbiAgICAgICAgICAgICAgICBpZiAobmV4dFRleHR1cmUuX2JhdGNoRW5hYmxlZCAhPT0gVElDSykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0ZXh0dXJlQ291bnQgPT09IE1BWF9URVhUVVJFUykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBUSUNLKys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHR1cmVDb3VudCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRHcm91cC5zaXplID0gaW5kZXhDb3VudCAtIGN1cnJlbnRHcm91cC5zdGFydDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEdyb3VwID0gZ3JvdXBzW2dyb3VwQ291bnQrK107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRHcm91cC50ZXh0dXJlQ291bnQgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50R3JvdXAuYmxlbmQgPSBibGVuZE1vZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRHcm91cC5zdGFydCA9IGluZGV4Q291bnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIG5leHRUZXh0dXJlLnRvdWNoZWQgPSB0b3VjaDtcclxuICAgICAgICAgICAgICAgICAgICBuZXh0VGV4dHVyZS5fYmF0Y2hFbmFibGVkID0gVElDSztcclxuICAgICAgICAgICAgICAgICAgICBuZXh0VGV4dHVyZS5faWQgPSB0ZXh0dXJlQ291bnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudEdyb3VwLnRleHR1cmVzW2N1cnJlbnRHcm91cC50ZXh0dXJlQ291bnQrK10gPSBuZXh0VGV4dHVyZTtcclxuICAgICAgICAgICAgICAgICAgICAvLyByZXZlYWwoY3VycmVudEdyb3VwKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyByZXZlYWwobmV4dFRleHR1cmUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRleHR1cmVDb3VudCsrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMucGFja0dlb21ldHJ5KHNwcml0ZSwgZmxvYXQzMlZpZXcsIHVpbnQzMlZpZXcsIGluZGV4QnVmZmVyLCBpbmRleCwgaW5kZXhDb3VudCk7IC8vIGFyZ2IsIG5leHRUZXh0dXJlLl9pZCwgZmxvYXQzMlZpZXcsIHVpbnQzMlZpZXcsIGluZGV4QnVmZmVyLCBpbmRleCwgaW5kZXhDb3VudCk7XHJcbiAgICAgICAgICAgIC8vIEhFUkUgXHJcbiAgICAgICAgICAgIC8vIHB1c2ggYSBncmFwaGljcy4uXHJcbiAgICAgICAgICAgIGluZGV4ICs9IChzcHJpdGUudmVydGV4RGF0YS5sZW5ndGggLyAyKSAqIHRoaXMudmVydFNpemU7XHJcbiAgICAgICAgICAgIGluZGV4Q291bnQgKz0gc3ByaXRlLmluZGljZXMubGVuZ3RoO1xyXG4gICAgICAgIH1cclxuICAgICAgICBCYXNlVGV4dHVyZV8xLkJhc2VUZXh0dXJlLl9nbG9iYWxCYXRjaCA9IFRJQ0s7XHJcbiAgICAgICAgY3VycmVudEdyb3VwLnNpemUgPSBpbmRleENvdW50IC0gY3VycmVudEdyb3VwLnN0YXJ0O1xyXG4gICAgICAgIC8vICAgICAgICB0aGlzLmluZGV4QnVmZmVyLnVwZGF0ZSgpO1xyXG4gICAgICAgIGlmICghV2ViR0xTZXR0aW5nc18xLldlYkdMU2V0dGluZ3MuQ0FOX1VQTE9BRF9TQU1FX0JVRkZFUikge1xyXG4gICAgICAgICAgICAvLyB0aGlzIGlzIHN0aWxsIG5lZWRlZCBmb3IgSU9TIHBlcmZvcm1hbmNlLi5cclxuICAgICAgICAgICAgLy8gaXQgcmVhbGx5IGRvZXMgbm90IGxpa2UgdXBsb2FkaW5nIHRvIHRoZSBzYW1lIGJ1ZmZlciBpbiBhIHNpbmdsZSBmcmFtZSFcclxuICAgICAgICAgICAgaWYgKHRoaXMudmFvTWF4IDw9IHRoaXMudmVydGV4Q291bnQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudmFvTWF4Kys7XHJcbiAgICAgICAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXHJcbiAgICAgICAgICAgICAgICB0aGlzLnZhb3NbdGhpcy52ZXJ0ZXhDb3VudF0gPSBuZXcgQmF0Y2hHZW9tZXRyeV8xLkJhdGNoR2VvbWV0cnkoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnZhb3NbdGhpcy52ZXJ0ZXhDb3VudF0uX2J1ZmZlci51cGRhdGUoYnVmZmVyLnZlcnRpY2VzLCAwKTtcclxuICAgICAgICAgICAgdGhpcy52YW9zW3RoaXMudmVydGV4Q291bnRdLl9pbmRleEJ1ZmZlci51cGRhdGUoaW5kZXhCdWZmZXIsIDApO1xyXG4gICAgICAgICAgICAvLyAgIHRoaXMudmVydGV4QnVmZmVyc1t0aGlzLnZlcnRleENvdW50XS51cGRhdGUoYnVmZmVyLnZlcnRpY2VzLCAwKTtcclxuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5nZW9tZXRyeS5iaW5kKHRoaXMudmFvc1t0aGlzLnZlcnRleENvdW50XSk7XHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuZ2VvbWV0cnkudXBkYXRlQnVmZmVycygpO1xyXG4gICAgICAgICAgICB0aGlzLnZlcnRleENvdW50Kys7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBsZXRzIHVzZSB0aGUgZmFzdGVyIG9wdGlvbiwgYWx3YXlzIHVzZSBidWZmZXIgbnVtYmVyIDBcclxuICAgICAgICAgICAgdGhpcy52YW9zW3RoaXMudmVydGV4Q291bnRdLl9idWZmZXIudXBkYXRlKGJ1ZmZlci52ZXJ0aWNlcywgMCk7XHJcbiAgICAgICAgICAgIHRoaXMudmFvc1t0aGlzLnZlcnRleENvdW50XS5faW5kZXhCdWZmZXIudXBkYXRlKGluZGV4QnVmZmVyLCAwKTtcclxuICAgICAgICAgICAgLy8gICBpZiAodHJ1ZSkvLyB0aGlzLnNwcml0ZU9ubHkpXHJcbiAgICAgICAgICAgIC8vIHtcclxuICAgICAgICAgICAgLy8gdGhpcy52YW9zW3RoaXMudmVydGV4Q291bnRdLmluZGV4QnVmZmVyID0gdGhpcy5kZWZ1YWx0U3ByaXRlSW5kZXhCdWZmZXI7XHJcbiAgICAgICAgICAgIC8vIHRoaXMudmFvc1t0aGlzLnZlcnRleENvdW50XS5idWZmZXJzWzFdID0gdGhpcy5kZWZ1YWx0U3ByaXRlSW5kZXhCdWZmZXI7XHJcbiAgICAgICAgICAgIC8vIH1cclxuICAgICAgICAgICAgLy8gdGhpcy52YW9zWzBdLmF0dHJpYnV0ZXMuYUNvbG9yLnN0cmlkZSA9IDI0XHJcbiAgICAgICAgICAgIC8vIHRoaXMudmFvc1swXS5hdHRyaWJ1dGVzLmFDb2xvci5zdGFydCA9IDE2XHJcbiAgICAgICAgICAgIC8vIE5PVCBTRVRcclxuICAgICAgICAgICAgLy8gdGhpcy52YW9zWzBdLmF0dHJpYnV0ZXMuYVRleHR1cmVDb29yZC5zdHJpZGUgPSAyNFxyXG4gICAgICAgICAgICAvLyB0aGlzLnZhb3NbMF0uYXR0cmlidXRlcy5hVGV4dHVyZUNvb3JkLnN0YXJ0ID0gOFxyXG4gICAgICAgICAgICAvLyBOT1QgU0VUXHJcbiAgICAgICAgICAgIC8vIHRoaXMudmFvc1swXS5hdHRyaWJ1dGVzLmFWZXJ0ZXhQb3NpdGlvbi5zdHJpZGUgPSAyNFxyXG4gICAgICAgICAgICAvLyBOT1QgU0VUXHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuZ2VvbWV0cnkudXBkYXRlQnVmZmVycygpO1xyXG4gICAgICAgICAgICAvLyAgICBcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gICB0aGlzLnJlbmRlcmVyLnN0YXRlLnNldCh0aGlzLnN0YXRlKTtcclxuICAgICAgICB2YXIgdGV4dHVyZVN5c3RlbSA9IHRoaXMucmVuZGVyZXIudGV4dHVyZTtcclxuICAgICAgICB2YXIgc3RhdGVTeXN0ZW0gPSB0aGlzLnJlbmRlcmVyLnN0YXRlO1xyXG4gICAgICAgIC8vIGUubG9nKGdyb3VwQ291bnQpO1xyXG4gICAgICAgIC8vIC8gcmVuZGVyIHRoZSBncm91cHMuLlxyXG4gICAgICAgIC8vICAgIHRyYWNlKFwiZ3JvdXBjb3VudDogXCIgKyBncm91cENvdW50KVxyXG4gICAgICAgIC8vIHRyYWNlKFwiQmF0Y2hSZW5kZXJlciBjb3VudDogXCIgKyBncm91cENvdW50KVxyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBncm91cENvdW50OyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIGdyb3VwID0gZ3JvdXBzW2ldO1xyXG4gICAgICAgICAgICB2YXIgZ3JvdXBUZXh0dXJlQ291bnQgPSBncm91cC50ZXh0dXJlQ291bnQ7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZ3JvdXBUZXh0dXJlQ291bnQ7IGorKykge1xyXG4gICAgICAgICAgICAgICAgLy8gdHJhY2UoXCJwb3NzaWJsZSB0ZXh0dXJlU3lzdGVtIGJpbmQgY2FsbCAoQmF0aFJlbmRlcmVyKVwiKVxyXG4gICAgICAgICAgICAgICAgLy8gdHJhY2UoXCJiaW5kaW5nOiBcIiArIGdyb3VwLnRleHR1cmVzW2pdICsgXCIgdG8gXCIgKyBqKVxyXG4gICAgICAgICAgICAgICAgdGV4dHVyZVN5c3RlbS5iaW5kKGdyb3VwLnRleHR1cmVzW2pdLCBqKTtcclxuICAgICAgICAgICAgICAgIGdyb3VwLnRleHR1cmVzW2pdID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyB0aGlzLnN0YXRlLmJsZW5kTW9kZSA9IGdyb3VwLmJsZW5kO1xyXG4gICAgICAgICAgICAvLyB0aGlzLnN0YXRlLmJsZW5kID0gdHJ1ZTtcclxuICAgICAgICAgICAgLy8gdGhpcy5yZW5kZXJlci5zdGF0ZS5zZXRTdGF0ZSh0aGlzLnN0YXRlKTtcclxuICAgICAgICAgICAgLy8gc2V0IHRoZSBibGVuZCBtb2RlLi5cclxuICAgICAgICAgICAgc3RhdGVTeXN0ZW0uc2V0QmxlbmRNb2RlKGdyb3VwLmJsZW5kKTtcclxuICAgICAgICAgICAgZ2wuZHJhd0VsZW1lbnRzKGdyb3VwLnR5cGUsIGdyb3VwLnNpemUsIGdsLlVOU0lHTkVEX1NIT1JULCBncm91cC5zdGFydCAqIDIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyByZXNldCBlbGVtZW50cyBmb3IgdGhlIG5leHQgZmx1c2hcclxuICAgICAgICB0aGlzLmN1cnJlbnRJbmRleCA9IDA7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50U2l6ZSA9IDA7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50SW5kZXhTaXplID0gMDtcclxuICAgIH1cclxuICAgIDtcclxuICAgIHBhY2tHZW9tZXRyeShlbGVtZW50LCBmbG9hdDMyVmlldywgdWludDMyVmlldywgaW5kZXhCdWZmZXIsIGluZGV4LCBpbmRleENvdW50KSB7XHJcbiAgICAgICAgdmFyIHAgPSBpbmRleCAvIHRoaXMudmVydFNpemU7IC8vIGZsb2F0MzJWaWV3Lmxlbmd0aCAvIDYgLyAyO1xyXG4gICAgICAgIHZhciB1dnMgPSBlbGVtZW50LnV2cztcclxuICAgICAgICB2YXIgaW5kaWNpZXMgPSBlbGVtZW50LmluZGljZXM7IC8vIGdlb21ldHJ5LmdldEluZGV4KCkuZGF0YTsvLyBpbmRpY2llcztcclxuICAgICAgICB2YXIgdmVydGV4RGF0YSA9IGVsZW1lbnQudmVydGV4RGF0YTtcclxuICAgICAgICB2YXIgdGV4dHVyZUlkID0gZWxlbWVudC5fdGV4dHVyZS5iYXNlVGV4dHVyZS5faWQ7XHJcbiAgICAgICAgdmFyIGFscGhhID0gTWF0aC5taW4oZWxlbWVudC53b3JsZEFscGhhLCAxLjApO1xyXG4gICAgICAgIHZhciBhcmdiID0gYWxwaGEgPCAxLjAgJiYgZWxlbWVudC5fdGV4dHVyZS5iYXNlVGV4dHVyZS5wcmVtdWx0aXBseUFscGhhID8gQ29sb3JTZXR0aW5nc18xLkNvbG9yU2V0dGluZ3MucHJlbXVsdGlwbHlUaW50KGVsZW1lbnQuX3RpbnRSR0IsIGFscGhhKVxyXG4gICAgICAgICAgICA6IGVsZW1lbnQuX3RpbnRSR0IgKyAoYWxwaGEgKiAyNTUgPDwgMjQpO1xyXG4gICAgICAgIC8vIGxldHMgbm90IHdvcnJ5IGFib3V0IHRpbnQhIGZvciBub3cuLlxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmVydGV4RGF0YS5sZW5ndGg7IGkgKz0gMikge1xyXG4gICAgICAgICAgICBmbG9hdDMyVmlld1tpbmRleCsrXSA9IHZlcnRleERhdGFbaV07XHJcbiAgICAgICAgICAgIGZsb2F0MzJWaWV3W2luZGV4KytdID0gdmVydGV4RGF0YVtpICsgMV07XHJcbiAgICAgICAgICAgIGZsb2F0MzJWaWV3W2luZGV4KytdID0gdXZzW2ldO1xyXG4gICAgICAgICAgICBmbG9hdDMyVmlld1tpbmRleCsrXSA9IHV2c1tpICsgMV07XHJcbiAgICAgICAgICAgIHVpbnQzMlZpZXdbaW5kZXgrK10gPSBhcmdiO1xyXG4gICAgICAgICAgICBmbG9hdDMyVmlld1tpbmRleCsrXSA9IHRleHR1cmVJZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgaW5kaWNpZXMubGVuZ3RoOyBpJDErKykge1xyXG4gICAgICAgICAgICBpbmRleEJ1ZmZlcltpbmRleENvdW50KytdID0gcCArIGluZGljaWVzW2kkMV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBTdGFydHMgYSBuZXcgc3ByaXRlIGJhdGNoLlxyXG4gICAgICovXHJcbiAgICBzdGFydCgpIHtcclxuICAgICAgICB0aGlzLnJlbmRlcmVyLnN0YXRlLnNldFN0YXRlKHRoaXMuc3RhdGUpO1xyXG4gICAgICAgIHRoaXMucmVuZGVyZXIuc2hhZGVyLmJpbmQodGhpcy5zaGFkZXIpO1xyXG4gICAgICAgIGlmIChXZWJHTFNldHRpbmdzXzEuV2ViR0xTZXR0aW5ncy5DQU5fVVBMT0FEX1NBTUVfQlVGRkVSKSB7XHJcbiAgICAgICAgICAgIC8vIGJpbmQgYnVmZmVyICMwLCB3ZSBkb24ndCBuZWVkIG90aGVyc1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLmdlb21ldHJ5LmJpbmQodGhpcy52YW9zW3RoaXMudmVydGV4Q291bnRdKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFN0b3BzIGFuZCBmbHVzaGVzIHRoZSBjdXJyZW50IGJhdGNoLlxyXG4gICAgICpcclxuICAgICAqL1xyXG4gICAgc3RvcCgpIHtcclxuICAgICAgICB0aGlzLmZsdXNoKCk7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIERlc3Ryb3lzIHRoZSBTcHJpdGVSZW5kZXJlci5cclxuICAgICAqXHJcbiAgICAgKi9cclxuICAgIGRlc3Ryb3koKSB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnZhb01heDsgaSsrKSB7XHJcbiAgICAgICAgICAgIC8vIGlmICh0aGlzLnZlcnRleEJ1ZmZlcnNbaV0pXHJcbiAgICAgICAgICAgIC8vIHtcclxuICAgICAgICAgICAgLy8gICAgIHRoaXMudmVydGV4QnVmZmVyc1tpXS5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgIC8vIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMudmFvc1tpXSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy52YW9zW2ldLmRlc3Ryb3kobnVsbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuaW5kZXhCdWZmZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5pbmRleEJ1ZmZlci5kZXN0cm95KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMucmVuZGVyZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcigncHJlcmVuZGVyJywgdGhpcy5vblByZXJlbmRlcik7XHJcbiAgICAgICAgaWYgKHRoaXMuc2hhZGVyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2hhZGVyLmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgdGhpcy5zaGFkZXIgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyB0aGlzLnZlcnRleEJ1ZmZlcnMgPSBudWxsO1xyXG4gICAgICAgIHRoaXMudmFvcyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5pbmRleEJ1ZmZlciA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5pbmRpY2VzID0gbnVsbDtcclxuICAgICAgICB0aGlzLnNwcml0ZXMgPSBudWxsO1xyXG4gICAgICAgIC8vIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5idWZmZXJzLmxlbmd0aDsgKytpKVxyXG4gICAgICAgIC8vIHtcclxuICAgICAgICAvLyAgICAgdGhpcy5idWZmZXJzW2ldLmRlc3Ryb3koKTtcclxuICAgICAgICAvLyB9XHJcbiAgICAgICAgc3VwZXIuZGVzdHJveSgpO1xyXG4gICAgfVxyXG4gICAgO1xyXG59XHJcbmV4cG9ydHMuQmF0Y2hSZW5kZXJlciA9IEJhdGNoUmVuZGVyZXI7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IFN5c3RlbV8xID0gcmVxdWlyZShcIi4vU3lzdGVtXCIpO1xyXG5jb25zdCBPYmplY3RSZW5kZXJlcl8xID0gcmVxdWlyZShcIi4vT2JqZWN0UmVuZGVyZXJcIik7XHJcbmNsYXNzIEJhdGNoU3lzdGVtIGV4dGVuZHMgU3lzdGVtXzEuU3lzdGVtIHtcclxuICAgIGNvbnN0cnVjdG9yKHJlbmRlcmVyKSB7XHJcbiAgICAgICAgc3VwZXIocmVuZGVyZXIpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFuIGVtcHR5IHJlbmRlcmVyLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQG1lbWJlciB7UElYSS5PYmplY3RSZW5kZXJlcn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmVtcHR5UmVuZGVyZXIgPSBuZXcgT2JqZWN0UmVuZGVyZXJfMS5PYmplY3RSZW5kZXJlcihyZW5kZXJlcik7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGN1cnJlbnRseSBhY3RpdmUgT2JqZWN0UmVuZGVyZXIuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLk9iamVjdFJlbmRlcmVyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuY3VycmVudFJlbmRlcmVyID0gdGhpcy5lbXB0eVJlbmRlcmVyO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGFuZ2VzIHRoZSBjdXJyZW50IHJlbmRlcmVyIHRvIHRoZSBvbmUgZ2l2ZW4gaW4gcGFyYW1ldGVyXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtQSVhJLk9iamVjdFJlbmRlcmVyfSBvYmplY3RSZW5kZXJlciAtIFRoZSBvYmplY3QgcmVuZGVyZXIgdG8gdXNlLlxyXG4gICAgICovXHJcbiAgICBzZXRPYmplY3RSZW5kZXJlcihvYmplY3RSZW5kZXJlcikge1xyXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRSZW5kZXJlciA9PT0gb2JqZWN0UmVuZGVyZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmN1cnJlbnRSZW5kZXJlci5zdG9wKCk7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50UmVuZGVyZXIgPSBvYmplY3RSZW5kZXJlcjtcclxuICAgICAgICB0aGlzLmN1cnJlbnRSZW5kZXJlci5zdGFydCgpO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIHNob3VsZCBiZSBjYWxsZWQgaWYgeW91IHdpc2ggdG8gZG8gc29tZSBjdXN0b20gcmVuZGVyaW5nXHJcbiAgICAgKiBJdCB3aWxsIGJhc2ljYWxseSByZW5kZXIgYW55dGhpbmcgdGhhdCBtYXkgYmUgYmF0Y2hlZCB1cCBzdWNoIGFzIHNwcml0ZXNcclxuICAgICAqL1xyXG4gICAgZmx1c2goKSB7XHJcbiAgICAgICAgdGhpcy5zZXRPYmplY3RSZW5kZXJlcih0aGlzLmVtcHR5UmVuZGVyZXIpO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXNldCB0aGUgc3lzdGVtIHRvIGFuIGVtcHR5IHJlbmRlcmVyXHJcbiAgICAgKi9cclxuICAgIHJlc2V0KCkge1xyXG4gICAgICAgIHRoaXMuc2V0T2JqZWN0UmVuZGVyZXIodGhpcy5lbXB0eVJlbmRlcmVyKTtcclxuICAgIH1cclxuICAgIDtcclxufVxyXG5leHBvcnRzLkJhdGNoU3lzdGVtID0gQmF0Y2hTeXN0ZW07XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IHNldHRpbmdzXzEgPSByZXF1aXJlKFwiLi9zZXR0aW5nc1wiKTtcclxuY2xhc3MgQmV6aWVyVXRpbHMge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgY3VydmVMZW5ndGgoZnJvbVgsIGZyb21ZLCBjcFgsIGNwWSwgY3BYMiwgY3BZMiwgdG9YLCB0b1kpIHtcclxuICAgICAgICB2YXIgbiA9IDEwO1xyXG4gICAgICAgIHZhciByZXN1bHQgPSAwLjA7XHJcbiAgICAgICAgdmFyIHQgPSAwLjA7XHJcbiAgICAgICAgdmFyIHQyID0gMC4wO1xyXG4gICAgICAgIHZhciB0MyA9IDAuMDtcclxuICAgICAgICB2YXIgbnQgPSAwLjA7XHJcbiAgICAgICAgdmFyIG50MiA9IDAuMDtcclxuICAgICAgICB2YXIgbnQzID0gMC4wO1xyXG4gICAgICAgIHZhciB4ID0gMC4wO1xyXG4gICAgICAgIHZhciB5ID0gMC4wO1xyXG4gICAgICAgIHZhciBkeCA9IDAuMDtcclxuICAgICAgICB2YXIgZHkgPSAwLjA7XHJcbiAgICAgICAgdmFyIHByZXZYID0gZnJvbVg7XHJcbiAgICAgICAgdmFyIHByZXZZID0gZnJvbVk7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPD0gbjsgKytpKSB7XHJcbiAgICAgICAgICAgIHQgPSBpIC8gbjtcclxuICAgICAgICAgICAgdDIgPSB0ICogdDtcclxuICAgICAgICAgICAgdDMgPSB0MiAqIHQ7XHJcbiAgICAgICAgICAgIG50ID0gKDEuMCAtIHQpO1xyXG4gICAgICAgICAgICBudDIgPSBudCAqIG50O1xyXG4gICAgICAgICAgICBudDMgPSBudDIgKiBudDtcclxuICAgICAgICAgICAgeCA9IChudDMgKiBmcm9tWCkgKyAoMy4wICogbnQyICogdCAqIGNwWCkgKyAoMy4wICogbnQgKiB0MiAqIGNwWDIpICsgKHQzICogdG9YKTtcclxuICAgICAgICAgICAgeSA9IChudDMgKiBmcm9tWSkgKyAoMy4wICogbnQyICogdCAqIGNwWSkgKyAoMyAqIG50ICogdDIgKiBjcFkyKSArICh0MyAqIHRvWSk7XHJcbiAgICAgICAgICAgIGR4ID0gcHJldlggLSB4O1xyXG4gICAgICAgICAgICBkeSA9IHByZXZZIC0geTtcclxuICAgICAgICAgICAgcHJldlggPSB4O1xyXG4gICAgICAgICAgICBwcmV2WSA9IHk7XHJcbiAgICAgICAgICAgIHJlc3VsdCArPSBNYXRoLnNxcnQoKGR4ICogZHgpICsgKGR5ICogZHkpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQ2FsY3VsYXRlIHRoZSBwb2ludHMgZm9yIGEgYmV6aWVyIGN1cnZlIGFuZCB0aGVuIGRyYXdzIGl0LlxyXG4gICAgICpcclxuICAgICAqIElnbm9yZWQgZnJvbSBkb2NzIHNpbmNlIGl0IGlzIG5vdCBkaXJlY3RseSBleHBvc2VkLlxyXG4gICAgICpcclxuICAgICAqIEBpZ25vcmVcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjcFggLSBDb250cm9sIHBvaW50IHhcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjcFkgLSBDb250cm9sIHBvaW50IHlcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjcFgyIC0gU2Vjb25kIENvbnRyb2wgcG9pbnQgeFxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNwWTIgLSBTZWNvbmQgQ29udHJvbCBwb2ludCB5XHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdG9YIC0gRGVzdGluYXRpb24gcG9pbnQgeFxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRvWSAtIERlc3RpbmF0aW9uIHBvaW50IHlcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyW119IHBvaW50cyAtIFBhdGggYXJyYXkgdG8gcHVzaCBwb2ludHMgaW50b1xyXG4gICAgICovXHJcbiAgICBzdGF0aWMgY3VydmVUbyhjcFgsIGNwWSwgY3BYMiwgY3BZMiwgdG9YLCB0b1ksIHBvaW50cykge1xyXG4gICAgICAgIHZhciBmcm9tWCA9IHBvaW50c1twb2ludHMubGVuZ3RoIC0gMl07XHJcbiAgICAgICAgdmFyIGZyb21ZID0gcG9pbnRzW3BvaW50cy5sZW5ndGggLSAxXTtcclxuICAgICAgICBwb2ludHMubGVuZ3RoIC09IDI7XHJcbiAgICAgICAgdmFyIG4gPSBzZXR0aW5nc18xLnNldHRpbmdzLkdSQVBISUNTX0NVUlZFUy5fc2VnbWVudHNDb3VudChCZXppZXJVdGlscy5jdXJ2ZUxlbmd0aChmcm9tWCwgZnJvbVksIGNwWCwgY3BZLCBjcFgyLCBjcFkyLCB0b1gsIHRvWSkpO1xyXG4gICAgICAgIHZhciBkdCA9IDA7XHJcbiAgICAgICAgdmFyIGR0MiA9IDA7XHJcbiAgICAgICAgdmFyIGR0MyA9IDA7XHJcbiAgICAgICAgdmFyIHQyID0gMDtcclxuICAgICAgICB2YXIgdDMgPSAwO1xyXG4gICAgICAgIHBvaW50cy5wdXNoKGZyb21YLCBmcm9tWSk7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDEsIGogPSAwOyBpIDw9IG47ICsraSkge1xyXG4gICAgICAgICAgICBqID0gaSAvIG47XHJcbiAgICAgICAgICAgIGR0ID0gKDEgLSBqKTtcclxuICAgICAgICAgICAgZHQyID0gZHQgKiBkdDtcclxuICAgICAgICAgICAgZHQzID0gZHQyICogZHQ7XHJcbiAgICAgICAgICAgIHQyID0gaiAqIGo7XHJcbiAgICAgICAgICAgIHQzID0gdDIgKiBqO1xyXG4gICAgICAgICAgICBwb2ludHMucHVzaCgoZHQzICogZnJvbVgpICsgKDMgKiBkdDIgKiBqICogY3BYKSArICgzICogZHQgKiB0MiAqIGNwWDIpICsgKHQzICogdG9YKSwgKGR0MyAqIGZyb21ZKSArICgzICogZHQyICogaiAqIGNwWSkgKyAoMyAqIGR0ICogdDIgKiBjcFkyKSArICh0MyAqIHRvWSkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIDtcclxufVxyXG5leHBvcnRzLkJlemllclV0aWxzID0gQmV6aWVyVXRpbHM7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNsYXNzIEJsZW5kTW9kZXNTZXR0aW5ncyB7XHJcbiAgICAvKipcclxuKiBDb3JyZWN0cyBQaXhpSlMgYmxlbmQsIHRha2VzIHByZW11bHRpcGxpZWQgYWxwaGEgaW50byBhY2NvdW50XHJcbipcclxuKiBAbWVtYmVyb2YgUElYSS51dGlsc1xyXG4qIEBmdW5jdGlvbiBtYXBQcmVtdWx0aXBsaWVkQmxlbmRNb2Rlc1xyXG4qIEBwcml2YXRlXHJcbiogQHBhcmFtIHtBcnJheTxudW1iZXJbXT59IFthcnJheV0gLSBUaGUgYXJyYXkgdG8gb3V0cHV0IGludG8uXHJcbiogQHJldHVybiB7QXJyYXk8bnVtYmVyW10+fSBNYXBwZWQgbW9kZXMuXHJcbiovXHJcbiAgICBzdGF0aWMgbWFwUHJlbXVsdGlwbGllZEJsZW5kTW9kZXMoKSB7XHJcbiAgICAgICAgdmFyIHBtID0gW107XHJcbiAgICAgICAgdmFyIG5wbSA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMzI7IGkrKykge1xyXG4gICAgICAgICAgICBwbVtpXSA9IGk7XHJcbiAgICAgICAgICAgIG5wbVtpXSA9IGk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHBtW0JsZW5kTW9kZXNTZXR0aW5ncy5CTEVORF9NT0RFUy5OT1JNQUxfTlBNXSA9IEJsZW5kTW9kZXNTZXR0aW5ncy5CTEVORF9NT0RFUy5OT1JNQUw7XHJcbiAgICAgICAgcG1bQmxlbmRNb2Rlc1NldHRpbmdzLkJMRU5EX01PREVTLkFERF9OUE1dID0gQmxlbmRNb2Rlc1NldHRpbmdzLkJMRU5EX01PREVTLkFERDtcclxuICAgICAgICBwbVtCbGVuZE1vZGVzU2V0dGluZ3MuQkxFTkRfTU9ERVMuU0NSRUVOX05QTV0gPSBCbGVuZE1vZGVzU2V0dGluZ3MuQkxFTkRfTU9ERVMuU0NSRUVOO1xyXG4gICAgICAgIG5wbVtCbGVuZE1vZGVzU2V0dGluZ3MuQkxFTkRfTU9ERVMuTk9STUFMXSA9IEJsZW5kTW9kZXNTZXR0aW5ncy5CTEVORF9NT0RFUy5OT1JNQUxfTlBNO1xyXG4gICAgICAgIG5wbVtCbGVuZE1vZGVzU2V0dGluZ3MuQkxFTkRfTU9ERVMuQUREXSA9IEJsZW5kTW9kZXNTZXR0aW5ncy5CTEVORF9NT0RFUy5BRERfTlBNO1xyXG4gICAgICAgIG5wbVtCbGVuZE1vZGVzU2V0dGluZ3MuQkxFTkRfTU9ERVMuU0NSRUVOXSA9IEJsZW5kTW9kZXNTZXR0aW5ncy5CTEVORF9NT0RFUy5TQ1JFRU5fTlBNO1xyXG4gICAgICAgIHZhciBhcnJheSA9IFtdO1xyXG4gICAgICAgIGFycmF5LnB1c2gobnBtKTtcclxuICAgICAgICBhcnJheS5wdXNoKHBtKTtcclxuICAgICAgICByZXR1cm4gYXJyYXk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuKiBjaGFuZ2VzIGJsZW5kTW9kZSBhY2NvcmRpbmcgdG8gdGV4dHVyZSBmb3JtYXRcclxuKlxyXG4qIEBtZW1iZXJvZiBQSVhJLnV0aWxzXHJcbiogQGZ1bmN0aW9uIGNvcnJlY3RCbGVuZE1vZGVcclxuKiBAcGFyYW0ge251bWJlcn0gYmxlbmRNb2RlIHN1cHBvc2VkIGJsZW5kIG1vZGVcclxuKiBAcGFyYW0ge2Jvb2xlYW59IHByZW11bHRpcGxpZWQgIHdoZXRoZXIgc291cmNlIGlzIHByZW11bHRpcGxpZWRcclxuKiBAcmV0dXJucyB7bnVtYmVyfSB0cnVlIGJsZW5kIG1vZGUgZm9yIHRoaXMgdGV4dHVyZVxyXG4qL1xyXG4gICAgc3RhdGljIGNvcnJlY3RCbGVuZE1vZGUoYmxlbmRNb2RlLCBwcmVtdWx0aXBsaWVkKSB7XHJcbiAgICAgICAgcmV0dXJuIEJsZW5kTW9kZXNTZXR0aW5ncy5wcmVtdWx0aXBseUJsZW5kTW9kZVtwcmVtdWx0aXBsaWVkID8gMSA6IDBdW2JsZW5kTW9kZV07XHJcbiAgICB9XHJcbiAgICAvKipcclxuKiBNYXBzIGdsIGJsZW5kIGNvbWJpbmF0aW9ucyB0byBXZWJHTC5cclxuKlxyXG4qIEBtZW1iZXJvZiBQSVhJXHJcbiogQGZ1bmN0aW9uIG1hcFdlYkdMQmxlbmRNb2Rlc1RvUGl4aVxyXG4qIEBwcml2YXRlXHJcbiogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIC0gVGhlIHJlbmRlcmluZyBjb250ZXh0LlxyXG4qIEBwYXJhbSB7bnVtYmVyW11bXX0gW2FycmF5PVtdXSAtIFRoZSBhcnJheSB0byBvdXRwdXQgaW50by5cclxuKiBAcmV0dXJuIHtudW1iZXJbXVtdfSBNYXBwZWQgbW9kZXMuXHJcbiovXHJcbiAgICBzdGF0aWMgbWFwV2ViR0xCbGVuZE1vZGVzVG9QaXhpKGdsLCBhcnJheSA9IFtdKSB7XHJcbiAgICAgICAgLy8gVE9ETyAtIHByZW11bHRpcGx5IGFscGhhIHdvdWxkIGJlIGRpZmZlcmVudC5cclxuICAgICAgICAvLyBhZGQgYSBib29sZWFuIGZvciB0aGF0IVxyXG4gICAgICAgIGFycmF5W0JsZW5kTW9kZXNTZXR0aW5ncy5CTEVORF9NT0RFUy5OT1JNQUxdID0gW2dsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQV07XHJcbiAgICAgICAgYXJyYXlbQmxlbmRNb2Rlc1NldHRpbmdzLkJMRU5EX01PREVTLkFERF0gPSBbZ2wuT05FLCBnbC5EU1RfQUxQSEEsIGdsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQV07XHJcbiAgICAgICAgYXJyYXlbQmxlbmRNb2Rlc1NldHRpbmdzLkJMRU5EX01PREVTLk1VTFRJUExZXSA9IFtnbC5EU1RfQ09MT1IsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEEsIGdsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQV07XHJcbiAgICAgICAgYXJyYXlbQmxlbmRNb2Rlc1NldHRpbmdzLkJMRU5EX01PREVTLlNDUkVFTl0gPSBbZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0NPTE9SLCBnbC5PTkUsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEFdO1xyXG4gICAgICAgIGFycmF5W0JsZW5kTW9kZXNTZXR0aW5ncy5CTEVORF9NT0RFUy5PVkVSTEFZXSA9IFtnbC5PTkUsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEFdO1xyXG4gICAgICAgIGFycmF5W0JsZW5kTW9kZXNTZXR0aW5ncy5CTEVORF9NT0RFUy5EQVJLRU5dID0gW2dsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQV07XHJcbiAgICAgICAgYXJyYXlbQmxlbmRNb2Rlc1NldHRpbmdzLkJMRU5EX01PREVTLkxJR0hURU5dID0gW2dsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQV07XHJcbiAgICAgICAgYXJyYXlbQmxlbmRNb2Rlc1NldHRpbmdzLkJMRU5EX01PREVTLkNPTE9SX0RPREdFXSA9IFtnbC5PTkUsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEFdO1xyXG4gICAgICAgIGFycmF5W0JsZW5kTW9kZXNTZXR0aW5ncy5CTEVORF9NT0RFUy5DT0xPUl9CVVJOXSA9IFtnbC5PTkUsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEFdO1xyXG4gICAgICAgIGFycmF5W0JsZW5kTW9kZXNTZXR0aW5ncy5CTEVORF9NT0RFUy5IQVJEX0xJR0hUXSA9IFtnbC5PTkUsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEFdO1xyXG4gICAgICAgIGFycmF5W0JsZW5kTW9kZXNTZXR0aW5ncy5CTEVORF9NT0RFUy5TT0ZUX0xJR0hUXSA9IFtnbC5PTkUsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEFdO1xyXG4gICAgICAgIGFycmF5W0JsZW5kTW9kZXNTZXR0aW5ncy5CTEVORF9NT0RFUy5ESUZGRVJFTkNFXSA9IFtnbC5PTkUsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEFdO1xyXG4gICAgICAgIGFycmF5W0JsZW5kTW9kZXNTZXR0aW5ncy5CTEVORF9NT0RFUy5FWENMVVNJT05dID0gW2dsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQV07XHJcbiAgICAgICAgYXJyYXlbQmxlbmRNb2Rlc1NldHRpbmdzLkJMRU5EX01PREVTLkhVRV0gPSBbZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBXTtcclxuICAgICAgICBhcnJheVtCbGVuZE1vZGVzU2V0dGluZ3MuQkxFTkRfTU9ERVMuU0FUVVJBVElPTl0gPSBbZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBXTtcclxuICAgICAgICBhcnJheVtCbGVuZE1vZGVzU2V0dGluZ3MuQkxFTkRfTU9ERVMuQ09MT1JdID0gW2dsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQV07XHJcbiAgICAgICAgYXJyYXlbQmxlbmRNb2Rlc1NldHRpbmdzLkJMRU5EX01PREVTLkxVTUlOT1NJVFldID0gW2dsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQV07XHJcbiAgICAgICAgYXJyYXlbQmxlbmRNb2Rlc1NldHRpbmdzLkJMRU5EX01PREVTLk5PTkVdID0gWzAsIDBdO1xyXG4gICAgICAgIC8vIG5vdC1wcmVtdWx0aXBsaWVkIGJsZW5kIG1vZGVzXHJcbiAgICAgICAgYXJyYXlbQmxlbmRNb2Rlc1NldHRpbmdzLkJMRU5EX01PREVTLk5PUk1BTF9OUE1dID0gW2dsLlNSQ19BTFBIQSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQSwgZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBXTtcclxuICAgICAgICBhcnJheVtCbGVuZE1vZGVzU2V0dGluZ3MuQkxFTkRfTU9ERVMuQUREX05QTV0gPSBbZ2wuU1JDX0FMUEhBLCBnbC5EU1RfQUxQSEEsIGdsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQV07XHJcbiAgICAgICAgYXJyYXlbQmxlbmRNb2Rlc1NldHRpbmdzLkJMRU5EX01PREVTLlNDUkVFTl9OUE1dID0gW2dsLlNSQ19BTFBIQSwgZ2wuT05FX01JTlVTX1NSQ19DT0xPUiwgZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBXTtcclxuICAgICAgICAvLyBjb21wb3NpdGUgb3BlcmF0aW9uc1xyXG4gICAgICAgIGFycmF5W0JsZW5kTW9kZXNTZXR0aW5ncy5CTEVORF9NT0RFUy5TUkNfSU5dID0gW2dsLkRTVF9BTFBIQSwgZ2wuWkVST107XHJcbiAgICAgICAgYXJyYXlbQmxlbmRNb2Rlc1NldHRpbmdzLkJMRU5EX01PREVTLlNSQ19PVVRdID0gW2dsLk9ORV9NSU5VU19EU1RfQUxQSEEsIGdsLlpFUk9dO1xyXG4gICAgICAgIGFycmF5W0JsZW5kTW9kZXNTZXR0aW5ncy5CTEVORF9NT0RFUy5TUkNfQVRPUF0gPSBbZ2wuRFNUX0FMUEhBLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBXTtcclxuICAgICAgICBhcnJheVtCbGVuZE1vZGVzU2V0dGluZ3MuQkxFTkRfTU9ERVMuRFNUX09WRVJdID0gW2dsLk9ORV9NSU5VU19EU1RfQUxQSEEsIGdsLk9ORV07XHJcbiAgICAgICAgYXJyYXlbQmxlbmRNb2Rlc1NldHRpbmdzLkJMRU5EX01PREVTLkRTVF9JTl0gPSBbZ2wuWkVSTywgZ2wuU1JDX0FMUEhBXTtcclxuICAgICAgICBhcnJheVtCbGVuZE1vZGVzU2V0dGluZ3MuQkxFTkRfTU9ERVMuRFNUX09VVF0gPSBbZ2wuWkVSTywgZ2wuT05FX01JTlVTX1NSQ19BTFBIQV07XHJcbiAgICAgICAgYXJyYXlbQmxlbmRNb2Rlc1NldHRpbmdzLkJMRU5EX01PREVTLkRTVF9BVE9QXSA9IFtnbC5PTkVfTUlOVVNfRFNUX0FMUEhBLCBnbC5TUkNfQUxQSEFdO1xyXG4gICAgICAgIC8vIFNVQlRSQUNUIGZyb20gZmxhc2hcclxuICAgICAgICBhcnJheVtCbGVuZE1vZGVzU2V0dGluZ3MuQkxFTkRfTU9ERVMuU1VCVFJBQ1RdID0gW2dsLk9ORSwgZ2wuT05FLCBnbC5PTkUsIGdsLk9ORSwgZ2wuRlVOQ19SRVZFUlNFX1NVQlRSQUNULCBnbC5GVU5DX0FERF07XHJcbiAgICAgICAgcmV0dXJuIGFycmF5O1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4qIFZhcmlvdXMgYmxlbmQgbW9kZXMgc3VwcG9ydGVkIGJ5IFBJWEkuXHJcbipcclxuKiBJTVBPUlRBTlQgLSBUaGUgV2ViR0wgcmVuZGVyZXIgb25seSBzdXBwb3J0cyB0aGUgTk9STUFMLCBBREQsIE1VTFRJUExZIGFuZCBTQ1JFRU4gYmxlbmQgbW9kZXMuXHJcbiogQW55dGhpbmcgZWxzZSB3aWxsIHNpbGVudGx5IGFjdCBsaWtlIE5PUk1BTC5cclxuKlxyXG4qIEBtZW1iZXJvZiBQSVhJXHJcbiogQG5hbWUgQkxFTkRfTU9ERVNcclxuKiBAZW51bSB7bnVtYmVyfVxyXG4qIEBwcm9wZXJ0eSB7bnVtYmVyfSBOT1JNQUxcclxuKiBAcHJvcGVydHkge251bWJlcn0gQUREXHJcbiogQHByb3BlcnR5IHtudW1iZXJ9IE1VTFRJUExZXHJcbiogQHByb3BlcnR5IHtudW1iZXJ9IFNDUkVFTlxyXG4qIEBwcm9wZXJ0eSB7bnVtYmVyfSBPVkVSTEFZXHJcbiogQHByb3BlcnR5IHtudW1iZXJ9IERBUktFTlxyXG4qIEBwcm9wZXJ0eSB7bnVtYmVyfSBMSUdIVEVOXHJcbiogQHByb3BlcnR5IHtudW1iZXJ9IENPTE9SX0RPREdFXHJcbiogQHByb3BlcnR5IHtudW1iZXJ9IENPTE9SX0JVUk5cclxuKiBAcHJvcGVydHkge251bWJlcn0gSEFSRF9MSUdIVFxyXG4qIEBwcm9wZXJ0eSB7bnVtYmVyfSBTT0ZUX0xJR0hUXHJcbiogQHByb3BlcnR5IHtudW1iZXJ9IERJRkZFUkVOQ0VcclxuKiBAcHJvcGVydHkge251bWJlcn0gRVhDTFVTSU9OXHJcbiogQHByb3BlcnR5IHtudW1iZXJ9IEhVRVxyXG4qIEBwcm9wZXJ0eSB7bnVtYmVyfSBTQVRVUkFUSU9OXHJcbiogQHByb3BlcnR5IHtudW1iZXJ9IENPTE9SXHJcbiogQHByb3BlcnR5IHtudW1iZXJ9IExVTUlOT1NJVFlcclxuKiBAcHJvcGVydHkge251bWJlcn0gTk9STUFMX05QTVxyXG4qIEBwcm9wZXJ0eSB7bnVtYmVyfSBBRERfTlBNXHJcbiogQHByb3BlcnR5IHtudW1iZXJ9IFNDUkVFTl9OUE1cclxuKiBAcHJvcGVydHkge251bWJlcn0gTk9ORVxyXG4qIEBwcm9wZXJ0eSB7bnVtYmVyfSBTUkNfSU5cclxuKiBAcHJvcGVydHkge251bWJlcn0gU1JDX09VVFxyXG4qIEBwcm9wZXJ0eSB7bnVtYmVyfSBTUkNfQVRPUFxyXG4qIEBwcm9wZXJ0eSB7bnVtYmVyfSBEU1RfT1ZFUlxyXG4qIEBwcm9wZXJ0eSB7bnVtYmVyfSBEU1RfSU5cclxuKiBAcHJvcGVydHkge251bWJlcn0gRFNUX09VVFxyXG4qIEBwcm9wZXJ0eSB7bnVtYmVyfSBEU1RfQVRPUFxyXG4qIEBwcm9wZXJ0eSB7bnVtYmVyfSBTVUJUUkFDVFxyXG4qIEBwcm9wZXJ0eSB7bnVtYmVyfSBTUkNfT1ZFUlxyXG4qIEBwcm9wZXJ0eSB7bnVtYmVyfSBFUkFTRVxyXG4qL1xyXG5CbGVuZE1vZGVzU2V0dGluZ3MuQkxFTkRfTU9ERVMgPSB7XHJcbiAgICBOT1JNQUw6IDAsXHJcbiAgICBBREQ6IDEsXHJcbiAgICBNVUxUSVBMWTogMixcclxuICAgIFNDUkVFTjogMyxcclxuICAgIE9WRVJMQVk6IDQsXHJcbiAgICBEQVJLRU46IDUsXHJcbiAgICBMSUdIVEVOOiA2LFxyXG4gICAgQ09MT1JfRE9ER0U6IDcsXHJcbiAgICBDT0xPUl9CVVJOOiA4LFxyXG4gICAgSEFSRF9MSUdIVDogOSxcclxuICAgIFNPRlRfTElHSFQ6IDEwLFxyXG4gICAgRElGRkVSRU5DRTogMTEsXHJcbiAgICBFWENMVVNJT046IDEyLFxyXG4gICAgSFVFOiAxMyxcclxuICAgIFNBVFVSQVRJT046IDE0LFxyXG4gICAgQ09MT1I6IDE1LFxyXG4gICAgTFVNSU5PU0lUWTogMTYsXHJcbiAgICBOT1JNQUxfTlBNOiAxNyxcclxuICAgIEFERF9OUE06IDE4LFxyXG4gICAgU0NSRUVOX05QTTogMTksXHJcbiAgICBOT05FOiAyMCxcclxuICAgIFNSQ19PVkVSOiAwLFxyXG4gICAgU1JDX0lOOiAyMSxcclxuICAgIFNSQ19PVVQ6IDIyLFxyXG4gICAgU1JDX0FUT1A6IDIzLFxyXG4gICAgRFNUX09WRVI6IDI0LFxyXG4gICAgRFNUX0lOOiAyNSxcclxuICAgIERTVF9PVVQ6IDI2LFxyXG4gICAgRFNUX0FUT1A6IDI3LFxyXG4gICAgRVJBU0U6IDI2LFxyXG4gICAgU1VCVFJBQ1Q6IDI4LFxyXG59O1xyXG4vKipcclxuKiBtYXBzIHByZW11bHRpcGx5IGZsYWcgYW5kIGJsZW5kTW9kZSB0byBhZGp1c3RlZCBibGVuZE1vZGVcclxuKiBAbWVtYmVyb2YgUElYSS51dGlsc1xyXG4qIEBjb25zdCBwcmVtdWx0aXBseUJsZW5kTW9kZVxyXG4qIEB0eXBlIHtBcnJheTxudW1iZXJbXT59XHJcbiovXHJcbkJsZW5kTW9kZXNTZXR0aW5ncy5wcmVtdWx0aXBseUJsZW5kTW9kZSA9IEJsZW5kTW9kZXNTZXR0aW5ncy5tYXBQcmVtdWx0aXBsaWVkQmxlbmRNb2RlcygpO1xyXG5leHBvcnRzLkJsZW5kTW9kZXNTZXR0aW5ncyA9IEJsZW5kTW9kZXNTZXR0aW5ncztcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgRmlsdGVyXzEgPSByZXF1aXJlKFwiLi9GaWx0ZXJcIik7XHJcbmNvbnN0IEJsdXJGaWx0ZXJQYXNzXzEgPSByZXF1aXJlKFwiLi9CbHVyRmlsdGVyUGFzc1wiKTtcclxuY29uc3QgRGlzcGxheVNldHRpbmdzXzEgPSByZXF1aXJlKFwiLi9EaXNwbGF5U2V0dGluZ3NcIik7XHJcbmNsYXNzIEJsdXJGaWx0ZXIgZXh0ZW5kcyBGaWx0ZXJfMS5GaWx0ZXIge1xyXG4gICAgY29uc3RydWN0b3Ioc3RyZW5ndGggPSAxLCBxdWFsaXR5ID0gMSwgcmVzb2x1dGlvbiA9IDEsIGtlcm5lbFNpemUgPSA1KSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLmJsdXJYRmlsdGVyID0gbmV3IEJsdXJGaWx0ZXJQYXNzXzEuQmx1ckZpbHRlclBhc3ModHJ1ZSwgc3RyZW5ndGgsIHF1YWxpdHksIHJlc29sdXRpb24sIGtlcm5lbFNpemUpO1xyXG4gICAgICAgIHRoaXMuYmx1cllGaWx0ZXIgPSBuZXcgQmx1ckZpbHRlclBhc3NfMS5CbHVyRmlsdGVyUGFzcyhmYWxzZSwgc3RyZW5ndGgsIHF1YWxpdHksIHJlc29sdXRpb24sIGtlcm5lbFNpemUpO1xyXG4gICAgICAgIHRoaXMucmVzb2x1dGlvbiA9IHJlc29sdXRpb24gfHwgRGlzcGxheVNldHRpbmdzXzEuRGlzcGxheVNldHRpbmdzLlJFU09MVVRJT047XHJcbiAgICAgICAgdGhpcy5xdWFsaXR5ID0gcXVhbGl0eSB8fCA0O1xyXG4gICAgICAgIHRoaXMuYmx1ciA9IHN0cmVuZ3RoIHx8IDg7XHJcbiAgICAgICAgdGhpcy5yZXBlYXRFZGdlUGl4ZWxzID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFwcGxpZXMgdGhlIGZpbHRlci5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1BJWEkuc3lzdGVtcy5GaWx0ZXJTeXN0ZW19IGZpbHRlck1hbmFnZXIgLSBUaGUgbWFuYWdlci5cclxuICAgICAqIEBwYXJhbSB7UElYSS5SZW5kZXJUZXh0dXJlfSBpbnB1dCAtIFRoZSBpbnB1dCB0YXJnZXQuXHJcbiAgICAgKiBAcGFyYW0ge1BJWEkuUmVuZGVyVGV4dHVyZX0gb3V0cHV0IC0gVGhlIG91dHB1dCB0YXJnZXQuXHJcbiAgICAgKi9cclxuICAgIGFwcGx5KGZpbHRlck1hbmFnZXIsIGlucHV0LCBvdXRwdXQsIGNsZWFyKSB7XHJcbiAgICAgICAgdmFyIHhTdHJlbmd0aCA9IE1hdGguYWJzKHRoaXMuYmx1clhGaWx0ZXIuc3RyZW5ndGgpO1xyXG4gICAgICAgIHZhciB5U3RyZW5ndGggPSBNYXRoLmFicyh0aGlzLmJsdXJZRmlsdGVyLnN0cmVuZ3RoKTtcclxuICAgICAgICBpZiAoeFN0cmVuZ3RoICYmIHlTdHJlbmd0aCkge1xyXG4gICAgICAgICAgICB2YXIgcmVuZGVyVGFyZ2V0ID0gZmlsdGVyTWFuYWdlci5nZXRGaWx0ZXJUZXh0dXJlKCk7XHJcbiAgICAgICAgICAgIHRoaXMuYmx1clhGaWx0ZXIuYXBwbHkoZmlsdGVyTWFuYWdlciwgaW5wdXQsIHJlbmRlclRhcmdldCwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIHRoaXMuYmx1cllGaWx0ZXIuYXBwbHkoZmlsdGVyTWFuYWdlciwgcmVuZGVyVGFyZ2V0LCBvdXRwdXQsIGNsZWFyKTtcclxuICAgICAgICAgICAgZmlsdGVyTWFuYWdlci5yZXR1cm5GaWx0ZXJUZXh0dXJlKHJlbmRlclRhcmdldCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHlTdHJlbmd0aCkge1xyXG4gICAgICAgICAgICB0aGlzLmJsdXJZRmlsdGVyLmFwcGx5KGZpbHRlck1hbmFnZXIsIGlucHV0LCBvdXRwdXQsIGNsZWFyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuYmx1clhGaWx0ZXIuYXBwbHkoZmlsdGVyTWFuYWdlciwgaW5wdXQsIG91dHB1dCwgY2xlYXIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIDtcclxuICAgIHVwZGF0ZVBhZGRpbmcoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3JlcGVhdEVkZ2VQaXhlbHMpIHtcclxuICAgICAgICAgICAgdGhpcy5wYWRkaW5nID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMucGFkZGluZyA9IE1hdGgubWF4KE1hdGguYWJzKHRoaXMuYmx1clhGaWx0ZXIuc3RyZW5ndGgpLCBNYXRoLmFicyh0aGlzLmJsdXJZRmlsdGVyLnN0cmVuZ3RoKSkgKiAyO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgc3RyZW5ndGggb2YgYm90aCB0aGUgYmx1clggYW5kIGJsdXJZIHByb3BlcnRpZXMgc2ltdWx0YW5lb3VzbHlcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgKiBAZGVmYXVsdCAyXHJcbiAgICAgKi9cclxuICAgIGdldCBibHVyKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmJsdXJYRmlsdGVyLmJsdXI7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICBzZXQgYmx1cih2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuYmx1clhGaWx0ZXIuYmx1ciA9IHRoaXMuYmx1cllGaWx0ZXIuYmx1ciA9IHZhbHVlO1xyXG4gICAgICAgIHRoaXMudXBkYXRlUGFkZGluZygpO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBudW1iZXIgb2YgcGFzc2VzIGZvciBibHVyLiBNb3JlIHBhc3NlcyBtZWFucyBoaWdoZXIgcXVhaWxpdHkgYmx1cmluZy5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgKiBAZGVmYXVsdCAxXHJcbiAgICAgKi9cclxuICAgIGdldCBxdWFsaXR5KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmJsdXJYRmlsdGVyLnF1YWxpdHk7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICBzZXQgcXVhbGl0eSh2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuYmx1clhGaWx0ZXIucXVhbGl0eSA9IHRoaXMuYmx1cllGaWx0ZXIucXVhbGl0eSA9IHZhbHVlO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBzdHJlbmd0aCBvZiB0aGUgYmx1clggcHJvcGVydHlcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgKiBAZGVmYXVsdCAyXHJcbiAgICAgKi9cclxuICAgIGdldCBibHVyWCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5ibHVyWEZpbHRlci5ibHVyO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgc2V0IGJsdXJYKHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5ibHVyWEZpbHRlci5ibHVyID0gdmFsdWU7XHJcbiAgICAgICAgdGhpcy51cGRhdGVQYWRkaW5nKCk7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIHN0cmVuZ3RoIG9mIHRoZSBibHVyWSBwcm9wZXJ0eVxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAqIEBkZWZhdWx0IDJcclxuICAgICAqL1xyXG4gICAgZ2V0IGJsdXJZKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmJsdXJZRmlsdGVyLmJsdXI7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICBzZXQgYmx1clkodmFsdWUpIHtcclxuICAgICAgICB0aGlzLmJsdXJZRmlsdGVyLmJsdXIgPSB2YWx1ZTtcclxuICAgICAgICB0aGlzLnVwZGF0ZVBhZGRpbmcoKTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgYmxlbmRtb2RlIG9mIHRoZSBmaWx0ZXJcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgKiBAZGVmYXVsdCBQSVhJLkJMRU5EX01PREVTLk5PUk1BTFxyXG4gICAgICovXHJcbiAgICBnZXQgYmxlbmRNb2RlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmJsdXJZRmlsdGVyLmJsZW5kTW9kZTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIHNldCBibGVuZE1vZGUodmFsdWUpIHtcclxuICAgICAgICB0aGlzLmJsdXJZRmlsdGVyLmJsZW5kTW9kZSA9IHZhbHVlO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBJZiBzZXQgdG8gdHJ1ZSB0aGUgZWRnZSBvZiB0aGUgdGFyZ2V0IHdpbGwgYmUgY2xhbXBlZFxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge2Jvb2x9XHJcbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxyXG4gICAgICovXHJcbiAgICBnZXQgcmVwZWF0RWRnZVBpeGVscygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcmVwZWF0RWRnZVBpeGVscztcclxuICAgIH1cclxuICAgIDtcclxuICAgIHNldCByZXBlYXRFZGdlUGl4ZWxzKHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5fcmVwZWF0RWRnZVBpeGVscyA9IHZhbHVlO1xyXG4gICAgICAgIHRoaXMudXBkYXRlUGFkZGluZygpO1xyXG4gICAgfVxyXG4gICAgO1xyXG59XHJcbmV4cG9ydHMuQmx1ckZpbHRlciA9IEJsdXJGaWx0ZXI7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IEZpbHRlcl8xID0gcmVxdWlyZShcIi4vRmlsdGVyXCIpO1xyXG5jb25zdCBEaXNwbGF5U2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL0Rpc3BsYXlTZXR0aW5nc1wiKTtcclxuY2xhc3MgQmx1ckZpbHRlclBhc3MgZXh0ZW5kcyBGaWx0ZXJfMS5GaWx0ZXIge1xyXG4gICAgY29uc3RydWN0b3IoaG9yaXpvbnRhbCwgc3RyZW5ndGgsIHF1YWxpdHksIHJlc29sdXRpb24sIGtlcm5lbFNpemUpIHtcclxuICAgICAgICBrZXJuZWxTaXplID0ga2VybmVsU2l6ZSB8fCA1O1xyXG4gICAgICAgIHZhciB2ZXJ0U3JjID0gQmx1ckZpbHRlclBhc3MuZ2VuZXJhdGVCbHVyVmVydFNvdXJjZShrZXJuZWxTaXplLCBob3Jpem9udGFsKTtcclxuICAgICAgICB2YXIgZnJhZ1NyYyA9IEJsdXJGaWx0ZXJQYXNzLmdlbmVyYXRlQmx1ckZyYWdTb3VyY2Uoa2VybmVsU2l6ZSk7XHJcbiAgICAgICAgc3VwZXIodmVydFNyYywgZnJhZ1NyYyk7XHJcbiAgICAgICAgdGhpcy5ob3Jpem9udGFsID0gaG9yaXpvbnRhbDtcclxuICAgICAgICB0aGlzLnJlc29sdXRpb24gPSByZXNvbHV0aW9uIHx8IERpc3BsYXlTZXR0aW5nc18xLkRpc3BsYXlTZXR0aW5ncy5SRVNPTFVUSU9OO1xyXG4gICAgICAgIHRoaXMuX3F1YWxpdHkgPSAwO1xyXG4gICAgICAgIHRoaXMucXVhbGl0eSA9IHF1YWxpdHkgfHwgNDtcclxuICAgICAgICB0aGlzLmJsdXIgPSBzdHJlbmd0aCB8fCA4O1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGdlbmVyYXRlQmx1ckZyYWdTb3VyY2Uoa2VybmVsU2l6ZSkge1xyXG4gICAgICAgIHZhciBrZXJuZWwgPSBCbHVyRmlsdGVyUGFzcy5HQVVTU0lBTl9WQUxVRVNba2VybmVsU2l6ZV07XHJcbiAgICAgICAgdmFyIGhhbGZMZW5ndGggPSBrZXJuZWwubGVuZ3RoO1xyXG4gICAgICAgIHZhciBmcmFnU291cmNlID0gQmx1ckZpbHRlclBhc3MuZnJhZ1RlbXBsYXRlJDI7XHJcbiAgICAgICAgdmFyIGJsdXJMb29wID0gJyc7XHJcbiAgICAgICAgdmFyIHRlbXBsYXRlID0gJ2dsX0ZyYWdDb2xvciArPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZCbHVyVGV4Q29vcmRzWyVpbmRleCVdKSAqICV2YWx1ZSU7JztcclxuICAgICAgICB2YXIgdmFsdWU7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXJuZWxTaXplOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIGJsdXIgPSB0ZW1wbGF0ZS5yZXBsYWNlKCclaW5kZXglJywgaS50b1N0cmluZygpKTtcclxuICAgICAgICAgICAgdmFsdWUgPSBpO1xyXG4gICAgICAgICAgICBpZiAoaSA+PSBoYWxmTGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGtlcm5lbFNpemUgLSBpIC0gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBibHVyID0gYmx1ci5yZXBsYWNlKCcldmFsdWUlJywga2VybmVsW3ZhbHVlXSk7XHJcbiAgICAgICAgICAgIGJsdXJMb29wICs9IGJsdXI7XHJcbiAgICAgICAgICAgIGJsdXJMb29wICs9ICdcXG4nO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmcmFnU291cmNlID0gZnJhZ1NvdXJjZS5yZXBsYWNlKCclYmx1ciUnLCBibHVyTG9vcCk7XHJcbiAgICAgICAgZnJhZ1NvdXJjZSA9IGZyYWdTb3VyY2UucmVwbGFjZSgnJXNpemUlJywga2VybmVsU2l6ZSk7XHJcbiAgICAgICAgcmV0dXJuIGZyYWdTb3VyY2U7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZ2VuZXJhdGVCbHVyVmVydFNvdXJjZShrZXJuZWxTaXplLCB4KSB7XHJcbiAgICAgICAgdmFyIGhhbGZMZW5ndGggPSBNYXRoLmNlaWwoa2VybmVsU2l6ZSAvIDIpO1xyXG4gICAgICAgIHZhciB2ZXJ0U291cmNlID0gQmx1ckZpbHRlclBhc3MudmVydFRlbXBsYXRlO1xyXG4gICAgICAgIHZhciBibHVyTG9vcCA9ICcnO1xyXG4gICAgICAgIHZhciB0ZW1wbGF0ZTtcclxuICAgICAgICAvLyBsZXQgdmFsdWU7XHJcbiAgICAgICAgaWYgKHgpIHtcclxuICAgICAgICAgICAgdGVtcGxhdGUgPSAndkJsdXJUZXhDb29yZHNbJWluZGV4JV0gPSAgdGV4dHVyZUNvb3JkICsgdmVjMiglc2FtcGxlSW5kZXglICogc3RyZW5ndGgsIDAuMCk7JztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRlbXBsYXRlID0gJ3ZCbHVyVGV4Q29vcmRzWyVpbmRleCVdID0gIHRleHR1cmVDb29yZCArIHZlYzIoMC4wLCAlc2FtcGxlSW5kZXglICogc3RyZW5ndGgpOyc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2VybmVsU2l6ZTsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBibHVyID0gdGVtcGxhdGUucmVwbGFjZSgnJWluZGV4JScsIGkpO1xyXG4gICAgICAgICAgICAvLyB2YWx1ZSA9IGk7XHJcbiAgICAgICAgICAgIC8vIGlmKGkgPj0gaGFsZkxlbmd0aClcclxuICAgICAgICAgICAgLy8ge1xyXG4gICAgICAgICAgICAvLyAgICAgdmFsdWUgPSBrZXJuZWxTaXplIC0gaSAtIDE7XHJcbiAgICAgICAgICAgIC8vIH1cclxuICAgICAgICAgICAgYmx1ciA9IGJsdXIucmVwbGFjZSgnJXNhbXBsZUluZGV4JScsICgoaSAtIChoYWxmTGVuZ3RoIC0gMSkpICsgXCIuMFwiKSk7XHJcbiAgICAgICAgICAgIGJsdXJMb29wICs9IGJsdXI7XHJcbiAgICAgICAgICAgIGJsdXJMb29wICs9ICdcXG4nO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2ZXJ0U291cmNlID0gdmVydFNvdXJjZS5yZXBsYWNlKCclYmx1ciUnLCBibHVyTG9vcCk7XHJcbiAgICAgICAgdmVydFNvdXJjZSA9IHZlcnRTb3VyY2UucmVwbGFjZSgnJXNpemUlJywga2VybmVsU2l6ZSk7XHJcbiAgICAgICAgcmV0dXJuIHZlcnRTb3VyY2U7XHJcbiAgICB9XHJcbiAgICBhcHBseShmaWx0ZXJNYW5hZ2VyLCBpbnB1dCwgb3V0cHV0LCBjbGVhcikge1xyXG4gICAgICAgIGlmIChvdXRwdXQpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaG9yaXpvbnRhbCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy51bmlmb3Jtcy5zdHJlbmd0aCA9ICgxIC8gb3V0cHV0LndpZHRoKSAqIChvdXRwdXQud2lkdGggLyBpbnB1dC53aWR0aCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnVuaWZvcm1zLnN0cmVuZ3RoID0gKDEgLyBvdXRwdXQuaGVpZ2h0KSAqIChvdXRwdXQuaGVpZ2h0IC8gaW5wdXQuaGVpZ2h0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaG9yaXpvbnRhbCkgLy8gZXNsaW50LWRpc2FibGUtbGluZVxyXG4gICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGhpcy51bmlmb3Jtcy5zdHJlbmd0aCA9ICgxIC8gZmlsdGVyTWFuYWdlci5yZW5kZXJlci53aWR0aCkgKiAoZmlsdGVyTWFuYWdlci5yZW5kZXJlci53aWR0aCAvIGlucHV0LndpZHRoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudW5pZm9ybXMuc3RyZW5ndGggPSAoMSAvIGZpbHRlck1hbmFnZXIucmVuZGVyZXIuaGVpZ2h0KSAqIChmaWx0ZXJNYW5hZ2VyLnJlbmRlcmVyLmhlaWdodCAvIGlucHV0LmhlaWdodCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBzY3JlZW4gc3BhY2UhXHJcbiAgICAgICAgdGhpcy51bmlmb3Jtcy5zdHJlbmd0aCAqPSB0aGlzLnN0cmVuZ3RoO1xyXG4gICAgICAgIHRoaXMudW5pZm9ybXMuc3RyZW5ndGggLz0gdGhpcy5wYXNzZXM7XHJcbiAgICAgICAgaWYgKHRoaXMucGFzc2VzID09PSAxKSB7XHJcbiAgICAgICAgICAgIGZpbHRlck1hbmFnZXIuYXBwbHlGaWx0ZXIodGhpcywgaW5wdXQsIG91dHB1dCwgY2xlYXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdmFyIHJlbmRlclRhcmdldCA9IGZpbHRlck1hbmFnZXIuZ2V0RmlsdGVyVGV4dHVyZSgpO1xyXG4gICAgICAgICAgICB2YXIgcmVuZGVyZXIgPSBmaWx0ZXJNYW5hZ2VyLnJlbmRlcmVyO1xyXG4gICAgICAgICAgICB2YXIgZmxpcCA9IGlucHV0O1xyXG4gICAgICAgICAgICB2YXIgZmxvcCA9IHJlbmRlclRhcmdldDtcclxuICAgICAgICAgICAgdGhpcy5zdGF0ZS5ibGVuZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBmaWx0ZXJNYW5hZ2VyLmFwcGx5RmlsdGVyKHRoaXMsIGZsaXAsIGZsb3AsIGZhbHNlKTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCB0aGlzLnBhc3NlcyAtIDE7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgcmVuZGVyZXIucmVuZGVyVGV4dHVyZS5iaW5kKGZsaXAsIGZsaXAuZmlsdGVyRnJhbWUpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy51bmlmb3Jtcy51U2FtcGxlciA9IGZsb3A7XHJcbiAgICAgICAgICAgICAgICB2YXIgdGVtcCA9IGZsb3A7XHJcbiAgICAgICAgICAgICAgICBmbG9wID0gZmxpcDtcclxuICAgICAgICAgICAgICAgIGZsaXAgPSB0ZW1wO1xyXG4gICAgICAgICAgICAgICAgcmVuZGVyZXIuc2hhZGVyLmJpbmQodGhpcyk7XHJcbiAgICAgICAgICAgICAgICByZW5kZXJlci5nZW9tZXRyeS5kcmF3KDUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuc3RhdGUuYmxlbmQgPSB0cnVlO1xyXG4gICAgICAgICAgICBmaWx0ZXJNYW5hZ2VyLmFwcGx5RmlsdGVyKHRoaXMsIGZsb3AsIG91dHB1dCwgY2xlYXIpO1xyXG4gICAgICAgICAgICBmaWx0ZXJNYW5hZ2VyLnJldHVybkZpbHRlclRleHR1cmUocmVuZGVyVGFyZ2V0KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIHN0cmVuZ3RoIG9mIGJvdGggdGhlIGJsdXIuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICogQGRlZmF1bHQgMTZcclxuICAgICAqL1xyXG4gICAgZ2V0IGJsdXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RyZW5ndGg7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICBzZXQgYmx1cih2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMucGFkZGluZyA9IDEgKyAoTWF0aC5hYnModmFsdWUpICogMik7XHJcbiAgICAgICAgdGhpcy5zdHJlbmd0aCA9IHZhbHVlO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBxdWFsaXR5IG9mIHRoZSBibHVyIGJ5IG1vZGlmeWluZyB0aGUgbnVtYmVyIG9mIHBhc3Nlcy4gTW9yZSBwYXNzZXMgbWVhbnMgaGlnaGVyXHJcbiAgICAgKiBxdWFpbGl0eSBibHVyaW5nIGJ1dCB0aGUgbG93ZXIgdGhlIHBlcmZvcm1hbmNlLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAqIEBkZWZhdWx0IDRcclxuICAgICAqL1xyXG4gICAgZ2V0IHF1YWxpdHkoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3F1YWxpdHk7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICBzZXQgcXVhbGl0eSh2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuX3F1YWxpdHkgPSB2YWx1ZTtcclxuICAgICAgICB0aGlzLnBhc3NlcyA9IHZhbHVlO1xyXG4gICAgfVxyXG4gICAgO1xyXG59XHJcbkJsdXJGaWx0ZXJQYXNzLkdBVVNTSUFOX1ZBTFVFUyA9IHtcclxuICAgIDU6IFswLjE1MzM4OCwgMC4yMjE0NjEsIDAuMjUwMzAxXSxcclxuICAgIDc6IFswLjA3MTMwMywgMC4xMzE1MTQsIDAuMTg5ODc5LCAwLjIxNDYwN10sXHJcbiAgICA5OiBbMC4wMjg1MzIsIDAuMDY3MjM0LCAwLjEyNDAwOSwgMC4xNzkwNDQsIDAuMjAyMzZdLFxyXG4gICAgMTE6IFswLjAwOTMsIDAuMDI4MDAyLCAwLjA2NTk4NCwgMC4xMjE3MDMsIDAuMTc1NzEzLCAwLjE5ODU5Nl0sXHJcbiAgICAxMzogWzAuMDAyNDA2LCAwLjAwOTI1NSwgMC4wMjc4NjcsIDAuMDY1NjY2LCAwLjEyMTExNywgMC4xNzQ4NjgsIDAuMTk3NjQxXSxcclxuICAgIDE1OiBbMC4wMDA0ODksIDAuMDAyNDAzLCAwLjAwOTI0NiwgMC4wMjc4NCwgMC4wNjU2MDIsIDAuMTIwOTk5LCAwLjE3NDY5NywgMC4xOTc0NDhdLFxyXG59O1xyXG5CbHVyRmlsdGVyUGFzcy52ZXJ0VGVtcGxhdGUgPSBcIlxcbiAgICBhdHRyaWJ1dGUgdmVjMiBhVmVydGV4UG9zaXRpb247XFxuXFxuICAgIHVuaWZvcm0gbWF0MyBwcm9qZWN0aW9uTWF0cml4O1xcblxcbiAgICB1bmlmb3JtIGZsb2F0IHN0cmVuZ3RoO1xcblxcbiAgICB2YXJ5aW5nIHZlYzIgdkJsdXJUZXhDb29yZHNbJXNpemUlXTtcXG5cXG4gICAgdW5pZm9ybSB2ZWM0IGlucHV0U2l6ZTtcXG4gICAgdW5pZm9ybSB2ZWM0IG91dHB1dEZyYW1lO1xcbiAgICBcXG4gICAgdmVjNCBmaWx0ZXJWZXJ0ZXhQb3NpdGlvbiggdm9pZCApXFxuICAgIHtcXG4gICAgICAgIHZlYzIgcG9zaXRpb24gPSBhVmVydGV4UG9zaXRpb24gKiBtYXgob3V0cHV0RnJhbWUuencsIHZlYzIoMC4pKSArIG91dHB1dEZyYW1lLnh5O1xcbiAgICBcXG4gICAgICAgIHJldHVybiB2ZWM0KChwcm9qZWN0aW9uTWF0cml4ICogdmVjMyhwb3NpdGlvbiwgMS4wKSkueHksIDAuMCwgMS4wKTtcXG4gICAgfVxcbiAgICBcXG4gICAgdmVjMiBmaWx0ZXJUZXh0dXJlQ29vcmQoIHZvaWQgKVxcbiAgICB7XFxuICAgICAgICByZXR1cm4gYVZlcnRleFBvc2l0aW9uICogKG91dHB1dEZyYW1lLnp3ICogaW5wdXRTaXplLnp3KTtcXG4gICAgfVxcblxcbiAgICB2b2lkIG1haW4odm9pZClcXG4gICAge1xcbiAgICAgICAgZ2xfUG9zaXRpb24gPSBmaWx0ZXJWZXJ0ZXhQb3NpdGlvbigpO1xcblxcbiAgICAgICAgdmVjMiB0ZXh0dXJlQ29vcmQgPSBmaWx0ZXJUZXh0dXJlQ29vcmQoKTtcXG4gICAgICAgICVibHVyJVxcbiAgICB9XCI7XHJcbkJsdXJGaWx0ZXJQYXNzLmZyYWdUZW1wbGF0ZSQyID0gW1xyXG4gICAgJ3ZhcnlpbmcgdmVjMiB2Qmx1clRleENvb3Jkc1slc2l6ZSVdOycsXHJcbiAgICAndW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXI7JyxcclxuICAgICd2b2lkIG1haW4odm9pZCknLFxyXG4gICAgJ3snLFxyXG4gICAgJyAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KDAuMCk7JyxcclxuICAgICcgICAgJWJsdXIlJyxcclxuICAgICd9J1xyXG5dLmpvaW4oJ1xcbicpO1xyXG5leHBvcnRzLkJsdXJGaWx0ZXJQYXNzID0gQmx1ckZpbHRlclBhc3M7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IFJlY3RhbmdsZV8xID0gcmVxdWlyZShcIi4vUmVjdGFuZ2xlXCIpO1xyXG5jbGFzcyBCb3VuZHMge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICAgICAqIEBkZWZhdWx0IDBcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLm1pblggPSBJbmZpbml0eTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgICAgICogQGRlZmF1bHQgMFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMubWluWSA9IEluZmluaXR5O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAgICAgKiBAZGVmYXVsdCAwXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5tYXhYID0gLUluZmluaXR5O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAgICAgKiBAZGVmYXVsdCAwXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5tYXhZID0gLUluZmluaXR5O1xyXG4gICAgICAgIHRoaXMucmVjdCA9IG51bGw7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICogQ2hlY2tzIGlmIGJvdW5kcyBhcmUgZW1wdHkuXHJcbiAqXHJcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgZW1wdHkuXHJcbiAqL1xyXG4gICAgaXNFbXB0eSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5taW5YID4gdGhpcy5tYXhYIHx8IHRoaXMubWluWSA+IHRoaXMubWF4WTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQ2xlYXJzIHRoZSBib3VuZHMgYW5kIHJlc2V0cy5cclxuICAgICAqXHJcbiAgICAgKi9cclxuICAgIGNsZWFyKCkge1xyXG4gICAgICAgIHRoaXMudXBkYXRlSUQrKztcclxuICAgICAgICB0aGlzLm1pblggPSBJbmZpbml0eTtcclxuICAgICAgICB0aGlzLm1pblkgPSBJbmZpbml0eTtcclxuICAgICAgICB0aGlzLm1heFggPSAtSW5maW5pdHk7XHJcbiAgICAgICAgdGhpcy5tYXhZID0gLUluZmluaXR5O1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAqIENhbiByZXR1cm4gUmVjdGFuZ2xlLkVNUFRZIGNvbnN0YW50LCBlaXRoZXIgY29uc3RydWN0IG5ldyByZWN0YW5nbGUsIGVpdGhlciB1c2UgeW91ciByZWN0YW5nbGVcclxuICogSXQgaXMgbm90IGd1YXJhbnRlZWQgdGhhdCBpdCB3aWxsIHJldHVybiB0ZW1wUmVjdFxyXG4gKlxyXG4gKiBAcGFyYW0ge1BJWEkuUmVjdGFuZ2xlfSByZWN0IC0gdGVtcG9yYXJ5IG9iamVjdCB3aWxsIGJlIHVzZWQgaWYgQUFCQiBpcyBub3QgZW1wdHlcclxuICogQHJldHVybnMge1BJWEkuUmVjdGFuZ2xlfSBBIHJlY3RhbmdsZSBvZiB0aGUgYm91bmRzXHJcbiAqL1xyXG4gICAgZ2V0UmVjdGFuZ2xlKHJlY3QpIHtcclxuICAgICAgICBpZiAodGhpcy5taW5YID4gdGhpcy5tYXhYIHx8IHRoaXMubWluWSA+IHRoaXMubWF4WSkge1xyXG4gICAgICAgICAgICByZXR1cm4gUmVjdGFuZ2xlXzEuUmVjdGFuZ2xlLkVNUFRZO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZWN0ID0gcmVjdCB8fCBuZXcgUmVjdGFuZ2xlXzEuUmVjdGFuZ2xlKDAsIDAsIDEsIDEpO1xyXG4gICAgICAgIHJlY3QueCA9IHRoaXMubWluWDtcclxuICAgICAgICByZWN0LnkgPSB0aGlzLm1pblk7XHJcbiAgICAgICAgcmVjdC53aWR0aCA9IHRoaXMubWF4WCAtIHRoaXMubWluWDtcclxuICAgICAgICByZWN0LmhlaWdodCA9IHRoaXMubWF4WSAtIHRoaXMubWluWTtcclxuICAgICAgICByZXR1cm4gcmVjdDtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBmdW5jdGlvbiBzaG91bGQgYmUgaW5saW5lZCB3aGVuIGl0cyBwb3NzaWJsZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1BJWEkuUG9pbnR9IHBvaW50IC0gVGhlIHBvaW50IHRvIGFkZC5cclxuICAgICAqL1xyXG4gICAgYWRkUG9pbnQocG9pbnQpIHtcclxuICAgICAgICB0aGlzLm1pblggPSBNYXRoLm1pbih0aGlzLm1pblgsIHBvaW50LngpO1xyXG4gICAgICAgIHRoaXMubWF4WCA9IE1hdGgubWF4KHRoaXMubWF4WCwgcG9pbnQueCk7XHJcbiAgICAgICAgdGhpcy5taW5ZID0gTWF0aC5taW4odGhpcy5taW5ZLCBwb2ludC55KTtcclxuICAgICAgICB0aGlzLm1heFkgPSBNYXRoLm1heCh0aGlzLm1heFksIHBvaW50LnkpO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGEgcXVhZCwgbm90IHRyYW5zZm9ybWVkXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtGbG9hdDMyQXJyYXl9IHZlcnRpY2VzIC0gVGhlIHZlcnRzIHRvIGFkZC5cclxuICAgICAqL1xyXG4gICAgYWRkUXVhZCh2ZXJ0aWNlcykge1xyXG4gICAgICAgIHZhciBtaW5YID0gdGhpcy5taW5YO1xyXG4gICAgICAgIHZhciBtaW5ZID0gdGhpcy5taW5ZO1xyXG4gICAgICAgIHZhciBtYXhYID0gdGhpcy5tYXhYO1xyXG4gICAgICAgIHZhciBtYXhZID0gdGhpcy5tYXhZO1xyXG4gICAgICAgIHZhciB4ID0gdmVydGljZXNbMF07XHJcbiAgICAgICAgdmFyIHkgPSB2ZXJ0aWNlc1sxXTtcclxuICAgICAgICBtaW5YID0geCA8IG1pblggPyB4IDogbWluWDtcclxuICAgICAgICBtaW5ZID0geSA8IG1pblkgPyB5IDogbWluWTtcclxuICAgICAgICBtYXhYID0geCA+IG1heFggPyB4IDogbWF4WDtcclxuICAgICAgICBtYXhZID0geSA+IG1heFkgPyB5IDogbWF4WTtcclxuICAgICAgICB4ID0gdmVydGljZXNbMl07XHJcbiAgICAgICAgeSA9IHZlcnRpY2VzWzNdO1xyXG4gICAgICAgIG1pblggPSB4IDwgbWluWCA/IHggOiBtaW5YO1xyXG4gICAgICAgIG1pblkgPSB5IDwgbWluWSA/IHkgOiBtaW5ZO1xyXG4gICAgICAgIG1heFggPSB4ID4gbWF4WCA/IHggOiBtYXhYO1xyXG4gICAgICAgIG1heFkgPSB5ID4gbWF4WSA/IHkgOiBtYXhZO1xyXG4gICAgICAgIHggPSB2ZXJ0aWNlc1s0XTtcclxuICAgICAgICB5ID0gdmVydGljZXNbNV07XHJcbiAgICAgICAgbWluWCA9IHggPCBtaW5YID8geCA6IG1pblg7XHJcbiAgICAgICAgbWluWSA9IHkgPCBtaW5ZID8geSA6IG1pblk7XHJcbiAgICAgICAgbWF4WCA9IHggPiBtYXhYID8geCA6IG1heFg7XHJcbiAgICAgICAgbWF4WSA9IHkgPiBtYXhZID8geSA6IG1heFk7XHJcbiAgICAgICAgeCA9IHZlcnRpY2VzWzZdO1xyXG4gICAgICAgIHkgPSB2ZXJ0aWNlc1s3XTtcclxuICAgICAgICBtaW5YID0geCA8IG1pblggPyB4IDogbWluWDtcclxuICAgICAgICBtaW5ZID0geSA8IG1pblkgPyB5IDogbWluWTtcclxuICAgICAgICBtYXhYID0geCA+IG1heFggPyB4IDogbWF4WDtcclxuICAgICAgICBtYXhZID0geSA+IG1heFkgPyB5IDogbWF4WTtcclxuICAgICAgICB0aGlzLm1pblggPSBtaW5YO1xyXG4gICAgICAgIHRoaXMubWluWSA9IG1pblk7XHJcbiAgICAgICAgdGhpcy5tYXhYID0gbWF4WDtcclxuICAgICAgICB0aGlzLm1heFkgPSBtYXhZO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIHNwcml0ZSBmcmFtZSwgdHJhbnNmb3JtZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtQSVhJLlRyYW5zZm9ybX0gdHJhbnNmb3JtIC0gVE9ET1xyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHgwIC0gVE9ET1xyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkwIC0gVE9ET1xyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHgxIC0gVE9ET1xyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkxIC0gVE9ET1xyXG4gICAgICovXHJcbiAgICBhZGRGcmFtZSh0cmFuc2Zvcm0sIHgwLCB5MCwgeDEsIHkxKSB7XHJcbiAgICAgICAgdmFyIG1hdHJpeCA9IHRyYW5zZm9ybS53b3JsZFRyYW5zZm9ybTtcclxuICAgICAgICB2YXIgYSA9IG1hdHJpeC5hO1xyXG4gICAgICAgIHZhciBiID0gbWF0cml4LmI7XHJcbiAgICAgICAgdmFyIGMgPSBtYXRyaXguYztcclxuICAgICAgICB2YXIgZCA9IG1hdHJpeC5kO1xyXG4gICAgICAgIHZhciB0eCA9IG1hdHJpeC50eDtcclxuICAgICAgICB2YXIgdHkgPSBtYXRyaXgudHk7XHJcbiAgICAgICAgdmFyIG1pblggPSB0aGlzLm1pblg7XHJcbiAgICAgICAgdmFyIG1pblkgPSB0aGlzLm1pblk7XHJcbiAgICAgICAgdmFyIG1heFggPSB0aGlzLm1heFg7XHJcbiAgICAgICAgdmFyIG1heFkgPSB0aGlzLm1heFk7XHJcbiAgICAgICAgdmFyIHggPSAoYSAqIHgwKSArIChjICogeTApICsgdHg7XHJcbiAgICAgICAgdmFyIHkgPSAoYiAqIHgwKSArIChkICogeTApICsgdHk7XHJcbiAgICAgICAgbWluWCA9IHggPCBtaW5YID8geCA6IG1pblg7XHJcbiAgICAgICAgbWluWSA9IHkgPCBtaW5ZID8geSA6IG1pblk7XHJcbiAgICAgICAgbWF4WCA9IHggPiBtYXhYID8geCA6IG1heFg7XHJcbiAgICAgICAgbWF4WSA9IHkgPiBtYXhZID8geSA6IG1heFk7XHJcbiAgICAgICAgeCA9IChhICogeDEpICsgKGMgKiB5MCkgKyB0eDtcclxuICAgICAgICB5ID0gKGIgKiB4MSkgKyAoZCAqIHkwKSArIHR5O1xyXG4gICAgICAgIG1pblggPSB4IDwgbWluWCA/IHggOiBtaW5YO1xyXG4gICAgICAgIG1pblkgPSB5IDwgbWluWSA/IHkgOiBtaW5ZO1xyXG4gICAgICAgIG1heFggPSB4ID4gbWF4WCA/IHggOiBtYXhYO1xyXG4gICAgICAgIG1heFkgPSB5ID4gbWF4WSA/IHkgOiBtYXhZO1xyXG4gICAgICAgIHggPSAoYSAqIHgwKSArIChjICogeTEpICsgdHg7XHJcbiAgICAgICAgeSA9IChiICogeDApICsgKGQgKiB5MSkgKyB0eTtcclxuICAgICAgICBtaW5YID0geCA8IG1pblggPyB4IDogbWluWDtcclxuICAgICAgICBtaW5ZID0geSA8IG1pblkgPyB5IDogbWluWTtcclxuICAgICAgICBtYXhYID0geCA+IG1heFggPyB4IDogbWF4WDtcclxuICAgICAgICBtYXhZID0geSA+IG1heFkgPyB5IDogbWF4WTtcclxuICAgICAgICB4ID0gKGEgKiB4MSkgKyAoYyAqIHkxKSArIHR4O1xyXG4gICAgICAgIHkgPSAoYiAqIHgxKSArIChkICogeTEpICsgdHk7XHJcbiAgICAgICAgbWluWCA9IHggPCBtaW5YID8geCA6IG1pblg7XHJcbiAgICAgICAgbWluWSA9IHkgPCBtaW5ZID8geSA6IG1pblk7XHJcbiAgICAgICAgbWF4WCA9IHggPiBtYXhYID8geCA6IG1heFg7XHJcbiAgICAgICAgbWF4WSA9IHkgPiBtYXhZID8geSA6IG1heFk7XHJcbiAgICAgICAgdGhpcy5taW5YID0gbWluWDtcclxuICAgICAgICB0aGlzLm1pblkgPSBtaW5ZO1xyXG4gICAgICAgIHRoaXMubWF4WCA9IG1heFg7XHJcbiAgICAgICAgdGhpcy5tYXhZID0gbWF4WTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBzY3JlZW4gdmVydGljZXMgZnJvbSBhcnJheVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fSB2ZXJ0ZXhEYXRhIC0gY2FsY3VsYXRlZCB2ZXJ0aWNlc1xyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJlZ2luT2Zmc2V0IC0gYmVnaW4gb2Zmc2V0XHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZW5kT2Zmc2V0IC0gZW5kIG9mZnNldCwgZXhjbHVkZWRcclxuICAgICAqL1xyXG4gICAgYWRkVmVydGV4RGF0YSh2ZXJ0ZXhEYXRhLCBiZWdpbk9mZnNldCwgZW5kT2Zmc2V0KSB7XHJcbiAgICAgICAgdmFyIG1pblggPSB0aGlzLm1pblg7XHJcbiAgICAgICAgdmFyIG1pblkgPSB0aGlzLm1pblk7XHJcbiAgICAgICAgdmFyIG1heFggPSB0aGlzLm1heFg7XHJcbiAgICAgICAgdmFyIG1heFkgPSB0aGlzLm1heFk7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IGJlZ2luT2Zmc2V0OyBpIDwgZW5kT2Zmc2V0OyBpICs9IDIpIHtcclxuICAgICAgICAgICAgdmFyIHggPSB2ZXJ0ZXhEYXRhW2ldO1xyXG4gICAgICAgICAgICB2YXIgeSA9IHZlcnRleERhdGFbaSArIDFdO1xyXG4gICAgICAgICAgICBtaW5YID0geCA8IG1pblggPyB4IDogbWluWDtcclxuICAgICAgICAgICAgbWluWSA9IHkgPCBtaW5ZID8geSA6IG1pblk7XHJcbiAgICAgICAgICAgIG1heFggPSB4ID4gbWF4WCA/IHggOiBtYXhYO1xyXG4gICAgICAgICAgICBtYXhZID0geSA+IG1heFkgPyB5IDogbWF4WTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5taW5YID0gbWluWDtcclxuICAgICAgICB0aGlzLm1pblkgPSBtaW5ZO1xyXG4gICAgICAgIHRoaXMubWF4WCA9IG1heFg7XHJcbiAgICAgICAgdGhpcy5tYXhZID0gbWF4WTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQWRkIGFuIGFycmF5IG9mIG1lc2ggdmVydGljZXNcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1BJWEkuVHJhbnNmb3JtfSB0cmFuc2Zvcm0gLSBtZXNoIHRyYW5zZm9ybVxyXG4gICAgICogQHBhcmFtIHtGbG9hdDMyQXJyYXl9IHZlcnRpY2VzIC0gbWVzaCBjb29yZGluYXRlcyBpbiBhcnJheVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJlZ2luT2Zmc2V0IC0gYmVnaW4gb2Zmc2V0XHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZW5kT2Zmc2V0IC0gZW5kIG9mZnNldCwgZXhjbHVkZWRcclxuICAgICAqL1xyXG4gICAgYWRkVmVydGljZXModHJhbnNmb3JtLCB2ZXJ0aWNlcywgYmVnaW5PZmZzZXQsIGVuZE9mZnNldCkge1xyXG4gICAgICAgIHZhciBtYXRyaXggPSB0cmFuc2Zvcm0ud29ybGRUcmFuc2Zvcm07XHJcbiAgICAgICAgdmFyIGEgPSBtYXRyaXguYTtcclxuICAgICAgICB2YXIgYiA9IG1hdHJpeC5iO1xyXG4gICAgICAgIHZhciBjID0gbWF0cml4LmM7XHJcbiAgICAgICAgdmFyIGQgPSBtYXRyaXguZDtcclxuICAgICAgICB2YXIgdHggPSBtYXRyaXgudHg7XHJcbiAgICAgICAgdmFyIHR5ID0gbWF0cml4LnR5O1xyXG4gICAgICAgIHZhciBtaW5YID0gdGhpcy5taW5YO1xyXG4gICAgICAgIHZhciBtaW5ZID0gdGhpcy5taW5ZO1xyXG4gICAgICAgIHZhciBtYXhYID0gdGhpcy5tYXhYO1xyXG4gICAgICAgIHZhciBtYXhZID0gdGhpcy5tYXhZO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSBiZWdpbk9mZnNldDsgaSA8IGVuZE9mZnNldDsgaSArPSAyKSB7XHJcbiAgICAgICAgICAgIHZhciByYXdYID0gdmVydGljZXNbaV07XHJcbiAgICAgICAgICAgIHZhciByYXdZID0gdmVydGljZXNbaSArIDFdO1xyXG4gICAgICAgICAgICB2YXIgeCA9IChhICogcmF3WCkgKyAoYyAqIHJhd1kpICsgdHg7XHJcbiAgICAgICAgICAgIHZhciB5ID0gKGQgKiByYXdZKSArIChiICogcmF3WCkgKyB0eTtcclxuICAgICAgICAgICAgbWluWCA9IHggPCBtaW5YID8geCA6IG1pblg7XHJcbiAgICAgICAgICAgIG1pblkgPSB5IDwgbWluWSA/IHkgOiBtaW5ZO1xyXG4gICAgICAgICAgICBtYXhYID0geCA+IG1heFggPyB4IDogbWF4WDtcclxuICAgICAgICAgICAgbWF4WSA9IHkgPiBtYXhZID8geSA6IG1heFk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubWluWCA9IG1pblg7XHJcbiAgICAgICAgdGhpcy5taW5ZID0gbWluWTtcclxuICAgICAgICB0aGlzLm1heFggPSBtYXhYO1xyXG4gICAgICAgIHRoaXMubWF4WSA9IG1heFk7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgb3RoZXIgQm91bmRzXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtQSVhJLkJvdW5kc30gYm91bmRzIC0gVE9ET1xyXG4gICAgICovXHJcbiAgICBhZGRCb3VuZHMoYm91bmRzKSB7XHJcbiAgICAgICAgdmFyIG1pblggPSB0aGlzLm1pblg7XHJcbiAgICAgICAgdmFyIG1pblkgPSB0aGlzLm1pblk7XHJcbiAgICAgICAgdmFyIG1heFggPSB0aGlzLm1heFg7XHJcbiAgICAgICAgdmFyIG1heFkgPSB0aGlzLm1heFk7XHJcbiAgICAgICAgdGhpcy5taW5YID0gYm91bmRzLm1pblggPCBtaW5YID8gYm91bmRzLm1pblggOiBtaW5YO1xyXG4gICAgICAgIHRoaXMubWluWSA9IGJvdW5kcy5taW5ZIDwgbWluWSA/IGJvdW5kcy5taW5ZIDogbWluWTtcclxuICAgICAgICB0aGlzLm1heFggPSBib3VuZHMubWF4WCA+IG1heFggPyBib3VuZHMubWF4WCA6IG1heFg7XHJcbiAgICAgICAgdGhpcy5tYXhZID0gYm91bmRzLm1heFkgPiBtYXhZID8gYm91bmRzLm1heFkgOiBtYXhZO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIG90aGVyIEJvdW5kcywgbWFza2VkIHdpdGggQm91bmRzXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtQSVhJLkJvdW5kc30gYm91bmRzIC0gVE9ET1xyXG4gICAgICogQHBhcmFtIHtQSVhJLkJvdW5kc30gbWFzayAtIFRPRE9cclxuICAgICAqL1xyXG4gICAgYWRkQm91bmRzTWFzayhib3VuZHMsIG1hc2spIHtcclxuICAgICAgICB2YXIgX21pblggPSBib3VuZHMubWluWCA+IG1hc2subWluWCA/IGJvdW5kcy5taW5YIDogbWFzay5taW5YO1xyXG4gICAgICAgIHZhciBfbWluWSA9IGJvdW5kcy5taW5ZID4gbWFzay5taW5ZID8gYm91bmRzLm1pblkgOiBtYXNrLm1pblk7XHJcbiAgICAgICAgdmFyIF9tYXhYID0gYm91bmRzLm1heFggPCBtYXNrLm1heFggPyBib3VuZHMubWF4WCA6IG1hc2subWF4WDtcclxuICAgICAgICB2YXIgX21heFkgPSBib3VuZHMubWF4WSA8IG1hc2subWF4WSA/IGJvdW5kcy5tYXhZIDogbWFzay5tYXhZO1xyXG4gICAgICAgIGlmIChfbWluWCA8PSBfbWF4WCAmJiBfbWluWSA8PSBfbWF4WSkge1xyXG4gICAgICAgICAgICB2YXIgbWluWCA9IHRoaXMubWluWDtcclxuICAgICAgICAgICAgdmFyIG1pblkgPSB0aGlzLm1pblk7XHJcbiAgICAgICAgICAgIHZhciBtYXhYID0gdGhpcy5tYXhYO1xyXG4gICAgICAgICAgICB2YXIgbWF4WSA9IHRoaXMubWF4WTtcclxuICAgICAgICAgICAgdGhpcy5taW5YID0gX21pblggPCBtaW5YID8gX21pblggOiBtaW5YO1xyXG4gICAgICAgICAgICB0aGlzLm1pblkgPSBfbWluWSA8IG1pblkgPyBfbWluWSA6IG1pblk7XHJcbiAgICAgICAgICAgIHRoaXMubWF4WCA9IF9tYXhYID4gbWF4WCA/IF9tYXhYIDogbWF4WDtcclxuICAgICAgICAgICAgdGhpcy5tYXhZID0gX21heFkgPiBtYXhZID8gX21heFkgOiBtYXhZO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBvdGhlciBCb3VuZHMsIG1hc2tlZCB3aXRoIFJlY3RhbmdsZVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7UElYSS5Cb3VuZHN9IGJvdW5kcyAtIFRPRE9cclxuICAgICAqIEBwYXJhbSB7UElYSS5SZWN0YW5nbGV9IGFyZWEgLSBUT0RPXHJcbiAgICAgKi9cclxuICAgIGFkZEJvdW5kc0FyZWEoYm91bmRzLCBhcmVhKSB7XHJcbiAgICAgICAgdmFyIF9taW5YID0gYm91bmRzLm1pblggPiBhcmVhLnggPyBib3VuZHMubWluWCA6IGFyZWEueDtcclxuICAgICAgICB2YXIgX21pblkgPSBib3VuZHMubWluWSA+IGFyZWEueSA/IGJvdW5kcy5taW5ZIDogYXJlYS55O1xyXG4gICAgICAgIHZhciBfbWF4WCA9IGJvdW5kcy5tYXhYIDwgYXJlYS54ICsgYXJlYS53aWR0aCA/IGJvdW5kcy5tYXhYIDogKGFyZWEueCArIGFyZWEud2lkdGgpO1xyXG4gICAgICAgIHZhciBfbWF4WSA9IGJvdW5kcy5tYXhZIDwgYXJlYS55ICsgYXJlYS5oZWlnaHQgPyBib3VuZHMubWF4WSA6IChhcmVhLnkgKyBhcmVhLmhlaWdodCk7XHJcbiAgICAgICAgaWYgKF9taW5YIDw9IF9tYXhYICYmIF9taW5ZIDw9IF9tYXhZKSB7XHJcbiAgICAgICAgICAgIHZhciBtaW5YID0gdGhpcy5taW5YO1xyXG4gICAgICAgICAgICB2YXIgbWluWSA9IHRoaXMubWluWTtcclxuICAgICAgICAgICAgdmFyIG1heFggPSB0aGlzLm1heFg7XHJcbiAgICAgICAgICAgIHZhciBtYXhZID0gdGhpcy5tYXhZO1xyXG4gICAgICAgICAgICB0aGlzLm1pblggPSBfbWluWCA8IG1pblggPyBfbWluWCA6IG1pblg7XHJcbiAgICAgICAgICAgIHRoaXMubWluWSA9IF9taW5ZIDwgbWluWSA/IF9taW5ZIDogbWluWTtcclxuICAgICAgICAgICAgdGhpcy5tYXhYID0gX21heFggPiBtYXhYID8gX21heFggOiBtYXhYO1xyXG4gICAgICAgICAgICB0aGlzLm1heFkgPSBfbWF4WSA+IG1heFkgPyBfbWF4WSA6IG1heFk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgO1xyXG59XHJcbmV4cG9ydHMuQm91bmRzID0gQm91bmRzO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBSdW5uZXJfMSA9IHJlcXVpcmUoXCIuL1J1bm5lclwiKTtcclxuY2xhc3MgQnVmZmVyIHtcclxuICAgIGNvbnN0cnVjdG9yKGRhdGEgPSBudWxsLCBfc3RhdGljID0gZmFsc2UsIGluZGV4ID0gbnVsbCkge1xyXG4gICAgICAgIGlmIChfc3RhdGljID09PSB2b2lkIDApIHtcclxuICAgICAgICAgICAgX3N0YXRpYyA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpbmRleCA9PT0gdm9pZCAwKSB7XHJcbiAgICAgICAgICAgIGluZGV4ID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBkYXRhIGluIHRoZSBidWZmZXIsIGFzIGEgdHlwZWQgYXJyYXlcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBtZW1iZXIge0FycmF5QnVmZmVyfCBTaGFyZWRBcnJheUJ1ZmZlcnxBcnJheUJ1ZmZlclZpZXd9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YSB8fCBuZXcgRmxvYXQzMkFycmF5KDEpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEEgbWFwIG9mIHJlbmRlcmVyIElEcyB0byB3ZWJnbCBidWZmZXJcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICogQG1lbWJlciB7b2JqZWN0PG51bWJlciwgR0xCdWZmZXI+fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuX2dsQnVmZmVycyA9IHt9O1xyXG4gICAgICAgIHRoaXMuX3VwZGF0ZUlEID0gMDtcclxuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XHJcbiAgICAgICAgdGhpcy5zdGF0aWMgPSBfc3RhdGljO1xyXG4gICAgICAgIHRoaXMuaWQgPSBCdWZmZXIuVUlEKys7XHJcbiAgICAgICAgdGhpcy5kaXNwb3NlUnVubmVyID0gbmV3IFJ1bm5lcl8xLlJ1bm5lcignZGlzcG9zZUJ1ZmZlcicsIDIpO1xyXG4gICAgICAgIC8vIHRoaXMuZGlzcG9zZVJ1bm5lciA9IG5ldyBSdW5uZXIoJ2Rpc3Bvc2VCdWZmZXInLCAyKTtcclxuICAgIH1cclxuICAgIC8vIFRPRE8gY291bGQgZXhwbG9yZSBmbGFnZ2luZyBvbmx5IGEgcGFydGlhbCB1cGxvYWQ/XHJcbiAgICAvKipcclxuICAgICAqIGZsYWdzIHRoaXMgYnVmZmVyIGFzIHJlcXVpcmluZyBhbiB1cGxvYWQgdG8gdGhlIEdQVVxyXG4gICAgICovXHJcbiAgICB1cGRhdGUoZGF0YSkge1xyXG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGEgfHwgdGhpcy5kYXRhO1xyXG4gICAgICAgIHRoaXMuX3VwZGF0ZUlEKys7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIGRpc3Bvc2VzIFdlYkdMIHJlc291cmNlcyB0aGF0IGFyZSBjb25uZWN0ZWQgdG8gdGhpcyBnZW9tZXRyeVxyXG4gICAgICovXHJcbiAgICBkaXNwb3NlKCkge1xyXG4gICAgICAgIHRoaXMuZGlzcG9zZVJ1bm5lci5ydW4odGhpcywgZmFsc2UpO1xyXG4gICAgICAgIC8vIHRoaXMuZGlzcG9zZVJ1bm5lci5ydW4odGhpcywgZmFsc2UpO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBEZXN0cm95cyB0aGUgYnVmZmVyXHJcbiAgICAgKi9cclxuICAgIGRlc3Ryb3koKSB7XHJcbiAgICAgICAgdGhpcy5kaXNwb3NlKCk7XHJcbiAgICAgICAgdGhpcy5kYXRhID0gbnVsbDtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogSGVscGVyIGZ1bmN0aW9uIHRoYXQgY3JlYXRlcyBhIGJ1ZmZlciBiYXNlZCBvbiBhbiBhcnJheSBvciBUeXBlZEFycmF5XHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQHBhcmFtIHtBcnJheUJ1ZmZlclZpZXcgfCBudW1iZXJbXX0gZGF0YSB0aGUgVHlwZWRBcnJheSB0aGF0IHRoZSBidWZmZXIgd2lsbCBzdG9yZS4gSWYgdGhpcyBpcyBhIHJlZ3VsYXIgQXJyYXkgaXQgd2lsbCBiZSBjb252ZXJ0ZWQgdG8gYSBGbG9hdDMyQXJyYXkuXHJcbiAgICAgKiBAcmV0dXJuIHtQSVhJLkJ1ZmZlcn0gQSBuZXcgQnVmZmVyIGJhc2VkIG9uIHRoZSBkYXRhIHByb3ZpZGVkLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZnJvbShkYXRhKSB7XHJcbiAgICAgICAgaWYgKGRhdGEgaW5zdGFuY2VvZiBBcnJheSkge1xyXG4gICAgICAgICAgICBkYXRhID0gbmV3IEZsb2F0MzJBcnJheShkYXRhKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBCdWZmZXIoZGF0YSk7XHJcbiAgICB9XHJcbiAgICA7XHJcbn1cclxuQnVmZmVyLlVJRCA9IDA7XHJcbmV4cG9ydHMuQnVmZmVyID0gQnVmZmVyO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBSZXNvdXJjZV8xID0gcmVxdWlyZShcIi4vUmVzb3VyY2VcIik7XHJcbmNsYXNzIEJ1ZmZlclJlc291cmNlIGV4dGVuZHMgUmVzb3VyY2VfMS5SZXNvdXJjZSB7XHJcbiAgICBjb25zdHJ1Y3Rvcihzb3VyY2UsIG9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgcmVmID0gb3B0aW9ucyB8fCB7fTtcclxuICAgICAgICB2YXIgd2lkdGggPSByZWYud2lkdGg7XHJcbiAgICAgICAgdmFyIGhlaWdodCA9IHJlZi5oZWlnaHQ7XHJcbiAgICAgICAgaWYgKCF3aWR0aCB8fCAhaGVpZ2h0KSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQnVmZmVyUmVzb3VyY2Ugd2lkdGggb3IgaGVpZ2h0IGludmFsaWQnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc3VwZXIod2lkdGgsIGhlaWdodCk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU291cmNlIGFycmF5XHJcbiAgICAgICAgICogQ2Fubm90IGJlIENsYW1wZWRVaW50OEFycmF5IGJlY2F1c2UgaXQgY2FudCBiZSB1cGxvYWRlZCB0byBXZWJHTFxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQG1lbWJlciB7RmxvYXQzMkFycmF5fFVpbnQ4QXJyYXl8VWludDMyQXJyYXl9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5kYXRhID0gc291cmNlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBVcGxvYWQgdGhlIHRleHR1cmUgdG8gdGhlIEdQVS5cclxuICAgICAqIEBwYXJhbSB7UElYSS5SZW5kZXJlcn0gcmVuZGVyZXIgVXBsb2FkIHRvIHRoZSByZW5kZXJlclxyXG4gICAgICogQHBhcmFtIHtQSVhJLkJhc2VUZXh0dXJlfSBiYXNlVGV4dHVyZSBSZWZlcmVuY2UgdG8gcGFyZW50IHRleHR1cmVcclxuICAgICAqIEBwYXJhbSB7UElYSS5HTFRleHR1cmV9IGdsVGV4dHVyZSBnbFRleHR1cmVcclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlzIHN1Y2Nlc3NcclxuICAgICAqL1xyXG4gICAgdXBsb2FkKHJlbmRlcmVyLCBiYXNlVGV4dHVyZSwgZ2xUZXh0dXJlKSB7XHJcbiAgICAgICAgdmFyIGdsID0gcmVuZGVyZXIuZ2w7XHJcbiAgICAgICAgZ2wucGl4ZWxTdG9yZWkoZ2wuVU5QQUNLX1BSRU1VTFRJUExZX0FMUEhBX1dFQkdMLCBiYXNlVGV4dHVyZS5wcmVtdWx0aXBseUFscGhhKTtcclxuICAgICAgICBpZiAoZ2xUZXh0dXJlLndpZHRoID09PSBiYXNlVGV4dHVyZS53aWR0aCAmJiBnbFRleHR1cmUuaGVpZ2h0ID09PSBiYXNlVGV4dHVyZS5oZWlnaHQpIHtcclxuICAgICAgICAgICAgZ2wudGV4U3ViSW1hZ2UyRChiYXNlVGV4dHVyZS50YXJnZXQsIDAsIDAsIDAsIGJhc2VUZXh0dXJlLndpZHRoLCBiYXNlVGV4dHVyZS5oZWlnaHQsIGJhc2VUZXh0dXJlLmZvcm1hdCwgYmFzZVRleHR1cmUudHlwZSwgdGhpcy5kYXRhKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGdsVGV4dHVyZS53aWR0aCA9IGJhc2VUZXh0dXJlLndpZHRoO1xyXG4gICAgICAgICAgICBnbFRleHR1cmUuaGVpZ2h0ID0gYmFzZVRleHR1cmUuaGVpZ2h0O1xyXG4gICAgICAgICAgICB2YXIgaW50ZXJuYWxGb3JtYXQgPSBiYXNlVGV4dHVyZS5mb3JtYXQ7XHJcbiAgICAgICAgICAgIC8vIGd1ZXNzIHNpemVkIGZvcm1hdCBieSB0eXBlIGFuZCBmb3JtYXRcclxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dlYkdMUmVuZGVyaW5nQ29udGV4dC90ZXhJbWFnZTJEXHJcbiAgICAgICAgICAgIGlmIChyZW5kZXJlci5jb250ZXh0LndlYkdMVmVyc2lvbiA9PT0gMlxyXG4gICAgICAgICAgICAgICAgJiYgYmFzZVRleHR1cmUudHlwZSA9PT0gcmVuZGVyZXIuZ2wuRkxPQVRcclxuICAgICAgICAgICAgICAgICYmIGJhc2VUZXh0dXJlLmZvcm1hdCA9PT0gcmVuZGVyZXIuZ2wuUkdCQSkge1xyXG4gICAgICAgICAgICAgICAgaW50ZXJuYWxGb3JtYXQgPSByZW5kZXJlci5nbC5SR0JBMzJGO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGdsLnRleEltYWdlMkQoYmFzZVRleHR1cmUudGFyZ2V0LCAwLCBpbnRlcm5hbEZvcm1hdCwgYmFzZVRleHR1cmUud2lkdGgsIGJhc2VUZXh0dXJlLmhlaWdodCwgMCwgYmFzZVRleHR1cmUuZm9ybWF0LCBiYXNlVGV4dHVyZS50eXBlLCB0aGlzLmRhdGEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogRGVzdHJveSBhbmQgZG9uJ3QgdXNlIGFmdGVyIHRoaXNcclxuICAgICAqIEBvdmVycmlkZVxyXG4gICAgICovXHJcbiAgICBkaXNwb3NlKCkge1xyXG4gICAgICAgIHRoaXMuZGF0YSA9IG51bGw7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFVzZWQgdG8gYXV0by1kZXRlY3QgdGhlIHR5cGUgb2YgcmVzb3VyY2UuXHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQHBhcmFtIHsqfSBzb3VyY2UgLSBUaGUgc291cmNlIG9iamVjdFxyXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gYHRydWVgIGlmIDxjYW52YXM+XHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyB0ZXN0KHNvdXJjZSkge1xyXG4gICAgICAgIHJldHVybiBzb3VyY2UgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXlcclxuICAgICAgICAgICAgfHwgc291cmNlIGluc3RhbmNlb2YgVWludDhBcnJheVxyXG4gICAgICAgICAgICB8fCBzb3VyY2UgaW5zdGFuY2VvZiBVaW50MzJBcnJheTtcclxuICAgIH1cclxuICAgIDtcclxufVxyXG5leHBvcnRzLkJ1ZmZlclJlc291cmNlID0gQnVmZmVyUmVzb3VyY2U7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNsYXNzIENhY2hlU2V0dGluZ3Mge1xyXG4gICAgc3RhdGljIGNsZWFyVGV4dHVyZUNhY2hlKCkge1xyXG4gICAgICAgIHZhciBrZXk7XHJcbiAgICAgICAgZm9yIChrZXkgaW4gQ2FjaGVTZXR0aW5ncy5UZXh0dXJlQ2FjaGUpIHtcclxuICAgICAgICAgICAgZGVsZXRlIENhY2hlU2V0dGluZ3MuVGV4dHVyZUNhY2hlW2tleV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAoa2V5IGluIENhY2hlU2V0dGluZ3MuQmFzZVRleHR1cmVDYWNoZSkge1xyXG4gICAgICAgICAgICBkZWxldGUgQ2FjaGVTZXR0aW5ncy5CYXNlVGV4dHVyZUNhY2hlW2tleV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc3RhdGljIGRlc3Ryb3lUZXh0dXJlQ2FjaGUoKSB7XHJcbiAgICAgICAgdmFyIGtleTtcclxuICAgICAgICBmb3IgKGtleSBpbiBDYWNoZVNldHRpbmdzLlRleHR1cmVDYWNoZSkge1xyXG4gICAgICAgICAgICBDYWNoZVNldHRpbmdzLlRleHR1cmVDYWNoZVtrZXldLmRlc3Ryb3koKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChrZXkgaW4gQ2FjaGVTZXR0aW5ncy5CYXNlVGV4dHVyZUNhY2hlKSB7XHJcbiAgICAgICAgICAgIENhY2hlU2V0dGluZ3MuQmFzZVRleHR1cmVDYWNoZVtrZXldLmRlc3Ryb3koKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuQ2FjaGVTZXR0aW5ncy5Qcm9ncmFtQ2FjaGUgPSB7fTtcclxuQ2FjaGVTZXR0aW5ncy5uYW1lQ2FjaGUgPSB7fTtcclxuQ2FjaGVTZXR0aW5ncy5wcm9ncmFtQ2FjaGUgPSB7fTtcclxuQ2FjaGVTZXR0aW5ncy5UZXh0dXJlQ2FjaGUgPSB7fTtcclxuQ2FjaGVTZXR0aW5ncy5CYXNlVGV4dHVyZUNhY2hlID0ge307XHJcbkNhY2hlU2V0dGluZ3MuZGVmYXVsdEdyb3VwQ2FjaGUgPSB7fTtcclxuZXhwb3J0cy5DYWNoZVNldHRpbmdzID0gQ2FjaGVTZXR0aW5ncztcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgRGlzcGxheVNldHRpbmdzXzEgPSByZXF1aXJlKFwiLi9EaXNwbGF5U2V0dGluZ3NcIik7XHJcbmNsYXNzIENhbnZhc1JlbmRlclRhcmdldCB7XHJcbiAgICBjb25zdHJ1Y3Rvcih3aWR0aCwgaGVpZ2h0LCByZXNvbHV0aW9uKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBUaGUgQ2FudmFzIG9iamVjdCB0aGF0IGJlbG9uZ3MgdG8gdGhpcyBDYW52YXNSZW5kZXJUYXJnZXQuXHJcbiAgICAgICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgICAgICogQG1lbWJlciB7SFRNTENhbnZhc0VsZW1lbnR9XHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEEgQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEIG9iamVjdCByZXByZXNlbnRpbmcgYSB0d28tZGltZW5zaW9uYWwgcmVuZGVyaW5nIGNvbnRleHQuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAbWVtYmVyIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gdGhpcy5jYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcclxuICAgICAgICB0aGlzLnJlc29sdXRpb24gPSByZXNvbHV0aW9uIHx8IERpc3BsYXlTZXR0aW5nc18xLkRpc3BsYXlTZXR0aW5ncy5SRVNPTFVUSU9OO1xyXG4gICAgICAgIHRoaXMucmVzaXplKHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDbGVhcnMgdGhlIGNhbnZhcyB0aGF0IHdhcyBjcmVhdGVkIGJ5IHRoZSBDYW52YXNSZW5kZXJUYXJnZXQgY2xhc3MuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgY2xlYXIoKSB7XHJcbiAgICAgICAgdGhpcy5jb250ZXh0LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcclxuICAgICAgICB0aGlzLmNvbnRleHQuY2xlYXJSZWN0KDAsIDAsIHRoaXMuY2FudmFzLndpZHRoLCB0aGlzLmNhbnZhcy5oZWlnaHQpO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXNpemVzIHRoZSBjYW52YXMgdG8gdGhlIHNwZWNpZmllZCB3aWR0aCBhbmQgaGVpZ2h0LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCAtIHRoZSBuZXcgd2lkdGggb2YgdGhlIGNhbnZhc1xyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCAtIHRoZSBuZXcgaGVpZ2h0IG9mIHRoZSBjYW52YXNcclxuICAgICAqL1xyXG4gICAgcmVzaXplKHdpZHRoLCBoZWlnaHQpIHtcclxuICAgICAgICB0aGlzLmNhbnZhcy53aWR0aCA9IHdpZHRoICogdGhpcy5yZXNvbHV0aW9uO1xyXG4gICAgICAgIHRoaXMuY2FudmFzLmhlaWdodCA9IGhlaWdodCAqIHRoaXMucmVzb2x1dGlvbjtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogRGVzdHJveXMgdGhpcyBjYW52YXMuXHJcbiAgICAgKlxyXG4gICAgICovXHJcbiAgICBkZXN0cm95KCkge1xyXG4gICAgICAgIHRoaXMuY29udGV4dCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5jYW52YXMgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgd2lkdGggb2YgdGhlIGNhbnZhcyBidWZmZXIgaW4gcGl4ZWxzLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgZ2V0IHdpZHRoKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNhbnZhcy53aWR0aDtcclxuICAgIH1cclxuICAgIDtcclxuICAgIHNldCB3aWR0aCh2YWwpIHtcclxuICAgICAgICB0aGlzLmNhbnZhcy53aWR0aCA9IHZhbDtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGhlaWdodCBvZiB0aGUgY2FudmFzIGJ1ZmZlciBpbiBwaXhlbHMuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICBnZXQgaGVpZ2h0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNhbnZhcy5oZWlnaHQ7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICBzZXQgaGVpZ2h0KHZhbCkge1xyXG4gICAgICAgIHRoaXMuY2FudmFzLmhlaWdodCA9IHZhbDtcclxuICAgIH1cclxuICAgIDtcclxufVxyXG5leHBvcnRzLkNhbnZhc1JlbmRlclRhcmdldCA9IENhbnZhc1JlbmRlclRhcmdldDtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgQmFzZUltYWdlUmVzb3VyY2VfMSA9IHJlcXVpcmUoXCIuL0Jhc2VJbWFnZVJlc291cmNlXCIpO1xyXG5jbGFzcyBDYW52YXNSZXNvdXJjZSBleHRlbmRzIEJhc2VJbWFnZVJlc291cmNlXzEuQmFzZUltYWdlUmVzb3VyY2Uge1xyXG4gICAgY29uc3RydWN0b3Ioc291cmNlKSB7XHJcbiAgICAgICAgc3VwZXIoc291cmNlKTtcclxuICAgIH1cclxuICAgIHN0YXRpYyB0ZXN0KHNvdXJjZSkge1xyXG4gICAgICAgIHJldHVybiAoc291cmNlIGluc3RhbmNlb2YgSFRNTENhbnZhc0VsZW1lbnQpO1xyXG4gICAgfVxyXG4gICAgO1xyXG59XHJcbmV4cG9ydHMuQ2FudmFzUmVzb3VyY2UgPSBDYW52YXNSZXNvdXJjZTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY2xhc3MgQ2FudmFzU2V0dGluZ3Mge1xyXG4gICAgLyoqXHJcbiogVHJpbSB0cmFuc3BhcmVudCBib3JkZXJzIGZyb20gYSBjYW52YXNcclxuKlxyXG4qIEBtZW1iZXJvZiBQSVhJLnV0aWxzXHJcbiogQGZ1bmN0aW9uIHRyaW1DYW52YXNcclxuKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50fSBjYW52YXMgLSB0aGUgY2FudmFzIHRvIHRyaW1cclxuKiBAcmV0dXJucyB7b2JqZWN0fSBUcmltIGRhdGFcclxuKi9cclxuICAgIHN0YXRpYyB0cmltQ2FudmFzKGNhbnZhcykge1xyXG4gICAgICAgIC8vIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL3JlbXkvNzg0NTA4XHJcbiAgICAgICAgdmFyIHdpZHRoID0gY2FudmFzLndpZHRoO1xyXG4gICAgICAgIHZhciBoZWlnaHQgPSBjYW52YXMuaGVpZ2h0O1xyXG4gICAgICAgIHZhciBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XHJcbiAgICAgICAgdmFyIGltYWdlRGF0YSA9IGNvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgICAgIHZhciBwaXhlbHMgPSBpbWFnZURhdGEuZGF0YTtcclxuICAgICAgICB2YXIgbGVuID0gcGl4ZWxzLmxlbmd0aDtcclxuICAgICAgICB2YXIgYm91bmQgPSB7XHJcbiAgICAgICAgICAgIHRvcDogbnVsbCxcclxuICAgICAgICAgICAgbGVmdDogbnVsbCxcclxuICAgICAgICAgICAgcmlnaHQ6IG51bGwsXHJcbiAgICAgICAgICAgIGJvdHRvbTogbnVsbCxcclxuICAgICAgICB9O1xyXG4gICAgICAgIHZhciBkYXRhID0gbnVsbDtcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICB2YXIgeDtcclxuICAgICAgICB2YXIgeTtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcclxuICAgICAgICAgICAgaWYgKHBpeGVsc1tpICsgM10gIT09IDApIHtcclxuICAgICAgICAgICAgICAgIHggPSAoaSAvIDQpICUgd2lkdGg7XHJcbiAgICAgICAgICAgICAgICB5ID0gfn4oKGkgLyA0KSAvIHdpZHRoKTtcclxuICAgICAgICAgICAgICAgIGlmIChib3VuZC50b3AgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBib3VuZC50b3AgPSB5O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGJvdW5kLmxlZnQgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBib3VuZC5sZWZ0ID0geDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHggPCBib3VuZC5sZWZ0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYm91bmQubGVmdCA9IHg7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoYm91bmQucmlnaHQgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBib3VuZC5yaWdodCA9IHggKyAxO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYm91bmQucmlnaHQgPCB4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYm91bmQucmlnaHQgPSB4ICsgMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChib3VuZC5ib3R0b20gPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBib3VuZC5ib3R0b20gPSB5O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYm91bmQuYm90dG9tIDwgeSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJvdW5kLmJvdHRvbSA9IHk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGJvdW5kLnRvcCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB3aWR0aCA9IGJvdW5kLnJpZ2h0IC0gYm91bmQubGVmdDtcclxuICAgICAgICAgICAgaGVpZ2h0ID0gYm91bmQuYm90dG9tIC0gYm91bmQudG9wICsgMTtcclxuICAgICAgICAgICAgZGF0YSA9IGNvbnRleHQuZ2V0SW1hZ2VEYXRhKGJvdW5kLmxlZnQsIGJvdW5kLnRvcCwgd2lkdGgsIGhlaWdodCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0LFxyXG4gICAgICAgICAgICB3aWR0aDogd2lkdGgsXHJcbiAgICAgICAgICAgIGRhdGE6IGRhdGEsXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLkNhbnZhc1NldHRpbmdzID0gQ2FudmFzU2V0dGluZ3M7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IFJlY3RhbmdsZV8xID0gcmVxdWlyZShcIi4vUmVjdGFuZ2xlXCIpO1xyXG5jb25zdCBTaGFwZVNldHRpbmdzXzEgPSByZXF1aXJlKFwiLi9TaGFwZVNldHRpbmdzXCIpO1xyXG5jbGFzcyBDaXJjbGUge1xyXG4gICAgY29uc3RydWN0b3IoeCA9IDAsIHkgPSAwLCByYWRpdXMgPSAwKSB7XHJcbiAgICAgICAgaWYgKHggPT09IHZvaWQgMCkge1xyXG4gICAgICAgICAgICB4ID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHkgPT09IHZvaWQgMCkge1xyXG4gICAgICAgICAgICB5ID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJhZGl1cyA9PT0gdm9pZCAwKSB7XHJcbiAgICAgICAgICAgIHJhZGl1cyA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAgICAgKiBAZGVmYXVsdCAwXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy54ID0geDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgICAgICogQGRlZmF1bHQgMFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMueSA9IHk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICAgICAqIEBkZWZhdWx0IDBcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnJhZGl1cyA9IHJhZGl1cztcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgdHlwZSBvZiB0aGUgb2JqZWN0LCBtYWlubHkgdXNlZCB0byBhdm9pZCBgaW5zdGFuY2VvZmAgY2hlY2tzXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgICAgICogQHJlYWRPbmx5XHJcbiAgICAgICAgICogQGRlZmF1bHQgUElYSS5TSEFQRVMuQ0lSQ1xyXG4gICAgICAgICAqIEBzZWUgUElYSS5TSEFQRVNcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnR5cGUgPSBTaGFwZVNldHRpbmdzXzEuU2hhcGVTZXR0aW5ncy5TSEFQRVMuQ0lSQztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIGNsb25lIG9mIHRoaXMgQ2lyY2xlIGluc3RhbmNlXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiB7UElYSS5DaXJjbGV9IGEgY29weSBvZiB0aGUgQ2lyY2xlXHJcbiAgICAgKi9cclxuICAgIGNsb25lKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgQ2lyY2xlKHRoaXMueCwgdGhpcy55LCB0aGlzLnJhZGl1cyk7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSB4IGFuZCB5IGNvb3JkaW5hdGVzIGdpdmVuIGFyZSBjb250YWluZWQgd2l0aGluIHRoaXMgY2lyY2xlXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggLSBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBwb2ludCB0byB0ZXN0XHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSAtIFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50IHRvIHRlc3RcclxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIHgveSBjb29yZGluYXRlcyBhcmUgd2l0aGluIHRoaXMgQ2lyY2xlXHJcbiAgICAgKi9cclxuICAgIGNvbnRhaW5zKHgsIHkpIHtcclxuICAgICAgICBpZiAodGhpcy5yYWRpdXMgPD0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciByMiA9IHRoaXMucmFkaXVzICogdGhpcy5yYWRpdXM7XHJcbiAgICAgICAgdmFyIGR4ID0gKHRoaXMueCAtIHgpO1xyXG4gICAgICAgIHZhciBkeSA9ICh0aGlzLnkgLSB5KTtcclxuICAgICAgICBkeCAqPSBkeDtcclxuICAgICAgICBkeSAqPSBkeTtcclxuICAgICAgICByZXR1cm4gKGR4ICsgZHkgPD0gcjIpO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAqIFJldHVybnMgdGhlIGZyYW1pbmcgcmVjdGFuZ2xlIG9mIHRoZSBjaXJjbGUgYXMgYSBSZWN0YW5nbGUgb2JqZWN0XHJcbiAgICAqXHJcbiAgICAqIEByZXR1cm4ge1BJWEkuUmVjdGFuZ2xlfSB0aGUgZnJhbWluZyByZWN0YW5nbGVcclxuICAgICovXHJcbiAgICBnZXRCb3VuZHMoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBSZWN0YW5nbGVfMS5SZWN0YW5nbGUodGhpcy54IC0gdGhpcy5yYWRpdXMsIHRoaXMueSAtIHRoaXMucmFkaXVzLCB0aGlzLnJhZGl1cyAqIDIsIHRoaXMucmFkaXVzICogMik7XHJcbiAgICB9XHJcbiAgICA7XHJcbn1cclxuZXhwb3J0cy5DaXJjbGUgPSBDaXJjbGU7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNsYXNzIENsZWFuVXBTZXR0aW5ncyB7XHJcbn1cclxuQ2xlYW5VcFNldHRpbmdzLmRlZmF1bHREZXN0cm95T3B0aW9ucyA9IHtcclxuICAgIHRleHR1cmU6IHRydWUsXHJcbiAgICBjaGlsZHJlbjogZmFsc2UsXHJcbiAgICBiYXNlVGV4dHVyZTogdHJ1ZSxcclxufTtcclxuZXhwb3J0cy5DbGVhblVwU2V0dGluZ3MgPSBDbGVhblVwU2V0dGluZ3M7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IEZpbHRlcl8xID0gcmVxdWlyZShcIi4vRmlsdGVyXCIpO1xyXG5jb25zdCBzZXR0aW5nc18xID0gcmVxdWlyZShcIi4vc2V0dGluZ3NcIik7XHJcbmNsYXNzIENvbG9yTWF0cml4RmlsdGVyIGV4dGVuZHMgRmlsdGVyXzEuRmlsdGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHZhciB1bmlmb3JtcyA9IHtcclxuICAgICAgICAgICAgbTogbmV3IEZsb2F0MzJBcnJheShbMSwgMCwgMCwgMCwgMCxcclxuICAgICAgICAgICAgICAgIDAsIDEsIDAsIDAsIDAsXHJcbiAgICAgICAgICAgICAgICAwLCAwLCAxLCAwLCAwLFxyXG4gICAgICAgICAgICAgICAgMCwgMCwgMCwgMSwgMF0pLFxyXG4gICAgICAgICAgICB1QWxwaGE6IDEsXHJcbiAgICAgICAgfTtcclxuICAgICAgICBzdXBlcihzZXR0aW5nc18xLnNldHRpbmdzLmRlZmF1bHRGaWx0ZXJWZXJ0ZXgsIENvbG9yTWF0cml4RmlsdGVyLmZyYWdtZW50JDQsIHVuaWZvcm1zKTtcclxuICAgICAgICB0aGlzLmFscGhhID0gMTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVHJhbnNmb3JtcyBjdXJyZW50IG1hdHJpeCBhbmQgc2V0IHRoZSBuZXcgb25lXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJbXX0gbWF0cml4IC0gNXg0IG1hdHJpeFxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBtdWx0aXBseSAtIGlmIHRydWUsIGN1cnJlbnQgbWF0cml4IGFuZCBtYXRyaXggYXJlIG11bHRpcGxpZWQuIElmIGZhbHNlLFxyXG4gICAgICogIGp1c3Qgc2V0IHRoZSBjdXJyZW50IG1hdHJpeCB3aXRoIEBwYXJhbSBtYXRyaXhcclxuICAgICAqL1xyXG4gICAgX2xvYWRNYXRyaXgobWF0cml4LCBtdWx0aXBseSkge1xyXG4gICAgICAgIGlmIChtdWx0aXBseSA9PT0gdm9pZCAwKSB7XHJcbiAgICAgICAgICAgIG11bHRpcGx5ID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBuZXdNYXRyaXggPSBtYXRyaXg7XHJcbiAgICAgICAgaWYgKG11bHRpcGx5KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX211bHRpcGx5KG5ld01hdHJpeCwgdGhpcy51bmlmb3Jtcy5tLCBtYXRyaXgpO1xyXG4gICAgICAgICAgICBuZXdNYXRyaXggPSB0aGlzLl9jb2xvck1hdHJpeChuZXdNYXRyaXgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBzZXQgdGhlIG5ldyBtYXRyaXhcclxuICAgICAgICB0aGlzLnVuaWZvcm1zLm0gPSBuZXdNYXRyaXg7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIE11bHRpcGxpZXMgdHdvIG1hdDUnc1xyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcltdfSBvdXQgLSA1eDQgbWF0cml4IHRoZSByZWNlaXZpbmcgbWF0cml4XHJcbiAgICAgKiBAcGFyYW0ge251bWJlcltdfSBhIC0gNXg0IG1hdHJpeCB0aGUgZmlyc3Qgb3BlcmFuZFxyXG4gICAgICogQHBhcmFtIHtudW1iZXJbXX0gYiAtIDV4NCBtYXRyaXggdGhlIHNlY29uZCBvcGVyYW5kXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyW119IDV4NCBtYXRyaXhcclxuICAgICAqL1xyXG4gICAgX211bHRpcGx5KG91dCwgYSwgYikge1xyXG4gICAgICAgIC8vIFJlZCBDaGFubmVsXHJcbiAgICAgICAgb3V0WzBdID0gKGFbMF0gKiBiWzBdKSArIChhWzFdICogYls1XSkgKyAoYVsyXSAqIGJbMTBdKSArIChhWzNdICogYlsxNV0pO1xyXG4gICAgICAgIG91dFsxXSA9IChhWzBdICogYlsxXSkgKyAoYVsxXSAqIGJbNl0pICsgKGFbMl0gKiBiWzExXSkgKyAoYVszXSAqIGJbMTZdKTtcclxuICAgICAgICBvdXRbMl0gPSAoYVswXSAqIGJbMl0pICsgKGFbMV0gKiBiWzddKSArIChhWzJdICogYlsxMl0pICsgKGFbM10gKiBiWzE3XSk7XHJcbiAgICAgICAgb3V0WzNdID0gKGFbMF0gKiBiWzNdKSArIChhWzFdICogYls4XSkgKyAoYVsyXSAqIGJbMTNdKSArIChhWzNdICogYlsxOF0pO1xyXG4gICAgICAgIG91dFs0XSA9IChhWzBdICogYls0XSkgKyAoYVsxXSAqIGJbOV0pICsgKGFbMl0gKiBiWzE0XSkgKyAoYVszXSAqIGJbMTldKSArIGFbNF07XHJcbiAgICAgICAgLy8gR3JlZW4gQ2hhbm5lbFxyXG4gICAgICAgIG91dFs1XSA9IChhWzVdICogYlswXSkgKyAoYVs2XSAqIGJbNV0pICsgKGFbN10gKiBiWzEwXSkgKyAoYVs4XSAqIGJbMTVdKTtcclxuICAgICAgICBvdXRbNl0gPSAoYVs1XSAqIGJbMV0pICsgKGFbNl0gKiBiWzZdKSArIChhWzddICogYlsxMV0pICsgKGFbOF0gKiBiWzE2XSk7XHJcbiAgICAgICAgb3V0WzddID0gKGFbNV0gKiBiWzJdKSArIChhWzZdICogYls3XSkgKyAoYVs3XSAqIGJbMTJdKSArIChhWzhdICogYlsxN10pO1xyXG4gICAgICAgIG91dFs4XSA9IChhWzVdICogYlszXSkgKyAoYVs2XSAqIGJbOF0pICsgKGFbN10gKiBiWzEzXSkgKyAoYVs4XSAqIGJbMThdKTtcclxuICAgICAgICBvdXRbOV0gPSAoYVs1XSAqIGJbNF0pICsgKGFbNl0gKiBiWzldKSArIChhWzddICogYlsxNF0pICsgKGFbOF0gKiBiWzE5XSkgKyBhWzldO1xyXG4gICAgICAgIC8vIEJsdWUgQ2hhbm5lbFxyXG4gICAgICAgIG91dFsxMF0gPSAoYVsxMF0gKiBiWzBdKSArIChhWzExXSAqIGJbNV0pICsgKGFbMTJdICogYlsxMF0pICsgKGFbMTNdICogYlsxNV0pO1xyXG4gICAgICAgIG91dFsxMV0gPSAoYVsxMF0gKiBiWzFdKSArIChhWzExXSAqIGJbNl0pICsgKGFbMTJdICogYlsxMV0pICsgKGFbMTNdICogYlsxNl0pO1xyXG4gICAgICAgIG91dFsxMl0gPSAoYVsxMF0gKiBiWzJdKSArIChhWzExXSAqIGJbN10pICsgKGFbMTJdICogYlsxMl0pICsgKGFbMTNdICogYlsxN10pO1xyXG4gICAgICAgIG91dFsxM10gPSAoYVsxMF0gKiBiWzNdKSArIChhWzExXSAqIGJbOF0pICsgKGFbMTJdICogYlsxM10pICsgKGFbMTNdICogYlsxOF0pO1xyXG4gICAgICAgIG91dFsxNF0gPSAoYVsxMF0gKiBiWzRdKSArIChhWzExXSAqIGJbOV0pICsgKGFbMTJdICogYlsxNF0pICsgKGFbMTNdICogYlsxOV0pICsgYVsxNF07XHJcbiAgICAgICAgLy8gQWxwaGEgQ2hhbm5lbFxyXG4gICAgICAgIG91dFsxNV0gPSAoYVsxNV0gKiBiWzBdKSArIChhWzE2XSAqIGJbNV0pICsgKGFbMTddICogYlsxMF0pICsgKGFbMThdICogYlsxNV0pO1xyXG4gICAgICAgIG91dFsxNl0gPSAoYVsxNV0gKiBiWzFdKSArIChhWzE2XSAqIGJbNl0pICsgKGFbMTddICogYlsxMV0pICsgKGFbMThdICogYlsxNl0pO1xyXG4gICAgICAgIG91dFsxN10gPSAoYVsxNV0gKiBiWzJdKSArIChhWzE2XSAqIGJbN10pICsgKGFbMTddICogYlsxMl0pICsgKGFbMThdICogYlsxN10pO1xyXG4gICAgICAgIG91dFsxOF0gPSAoYVsxNV0gKiBiWzNdKSArIChhWzE2XSAqIGJbOF0pICsgKGFbMTddICogYlsxM10pICsgKGFbMThdICogYlsxOF0pO1xyXG4gICAgICAgIG91dFsxOV0gPSAoYVsxNV0gKiBiWzRdKSArIChhWzE2XSAqIGJbOV0pICsgKGFbMTddICogYlsxNF0pICsgKGFbMThdICogYlsxOV0pICsgYVsxOV07XHJcbiAgICAgICAgcmV0dXJuIG91dDtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIGEgRmxvYXQzMiBBcnJheSBhbmQgbm9ybWFsaXplIHRoZSBvZmZzZXQgY29tcG9uZW50IHRvIDAtMVxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcltdfSBtYXRyaXggLSA1eDQgbWF0cml4XHJcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJbXX0gNXg0IG1hdHJpeCB3aXRoIGFsbCB2YWx1ZXMgYmV0d2VlbiAwLTFcclxuICAgICAqL1xyXG4gICAgX2NvbG9yTWF0cml4KG1hdHJpeCkge1xyXG4gICAgICAgIC8vIENyZWF0ZSBhIEZsb2F0MzIgQXJyYXkgYW5kIG5vcm1hbGl6ZSB0aGUgb2Zmc2V0IGNvbXBvbmVudCB0byAwLTFcclxuICAgICAgICB2YXIgbSA9IG5ldyBGbG9hdDMyQXJyYXkobWF0cml4KTtcclxuICAgICAgICBtWzRdIC89IDI1NTtcclxuICAgICAgICBtWzldIC89IDI1NTtcclxuICAgICAgICBtWzE0XSAvPSAyNTU7XHJcbiAgICAgICAgbVsxOV0gLz0gMjU1O1xyXG4gICAgICAgIHJldHVybiBtO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBZGp1c3RzIGJyaWdodG5lc3NcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYiAtIHZhbHVlIG9mIHRoZSBicmlndGhuZXNzICgwLTEsIHdoZXJlIDAgaXMgYmxhY2spXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IG11bHRpcGx5IC0gaWYgdHJ1ZSwgY3VycmVudCBtYXRyaXggYW5kIG1hdHJpeCBhcmUgbXVsdGlwbGllZC4gSWYgZmFsc2UsXHJcbiAgICAgKiAganVzdCBzZXQgdGhlIGN1cnJlbnQgbWF0cml4IHdpdGggQHBhcmFtIG1hdHJpeFxyXG4gICAgICovXHJcbiAgICBicmlnaHRuZXNzKGIsIG11bHRpcGx5KSB7XHJcbiAgICAgICAgdmFyIG1hdHJpeCA9IFtcclxuICAgICAgICAgICAgYiwgMCwgMCwgMCwgMCxcclxuICAgICAgICAgICAgMCwgYiwgMCwgMCwgMCxcclxuICAgICAgICAgICAgMCwgMCwgYiwgMCwgMCxcclxuICAgICAgICAgICAgMCwgMCwgMCwgMSwgMFxyXG4gICAgICAgIF07XHJcbiAgICAgICAgdGhpcy5fbG9hZE1hdHJpeChtYXRyaXgsIG11bHRpcGx5KTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRoZSBtYXRyaWNlcyBpbiBncmV5IHNjYWxlc1xyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzY2FsZSAtIHZhbHVlIG9mIHRoZSBncmV5ICgwLTEsIHdoZXJlIDAgaXMgYmxhY2spXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IG11bHRpcGx5IC0gaWYgdHJ1ZSwgY3VycmVudCBtYXRyaXggYW5kIG1hdHJpeCBhcmUgbXVsdGlwbGllZC4gSWYgZmFsc2UsXHJcbiAgICAgKiAganVzdCBzZXQgdGhlIGN1cnJlbnQgbWF0cml4IHdpdGggQHBhcmFtIG1hdHJpeFxyXG4gICAgICovXHJcbiAgICBncmV5c2NhbGUoc2NhbGUsIG11bHRpcGx5KSB7XHJcbiAgICAgICAgdmFyIG1hdHJpeCA9IFtcclxuICAgICAgICAgICAgc2NhbGUsIHNjYWxlLCBzY2FsZSwgMCwgMCxcclxuICAgICAgICAgICAgc2NhbGUsIHNjYWxlLCBzY2FsZSwgMCwgMCxcclxuICAgICAgICAgICAgc2NhbGUsIHNjYWxlLCBzY2FsZSwgMCwgMCxcclxuICAgICAgICAgICAgMCwgMCwgMCwgMSwgMFxyXG4gICAgICAgIF07XHJcbiAgICAgICAgdGhpcy5fbG9hZE1hdHJpeChtYXRyaXgsIG11bHRpcGx5KTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRoZSBibGFjayBhbmQgd2hpdGUgbWF0cmljZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IG11bHRpcGx5IC0gaWYgdHJ1ZSwgY3VycmVudCBtYXRyaXggYW5kIG1hdHJpeCBhcmUgbXVsdGlwbGllZC4gSWYgZmFsc2UsXHJcbiAgICAgKiAganVzdCBzZXQgdGhlIGN1cnJlbnQgbWF0cml4IHdpdGggQHBhcmFtIG1hdHJpeFxyXG4gICAgICovXHJcbiAgICBibGFja0FuZFdoaXRlKG11bHRpcGx5KSB7XHJcbiAgICAgICAgdmFyIG1hdHJpeCA9IFtcclxuICAgICAgICAgICAgMC4zLCAwLjYsIDAuMSwgMCwgMCxcclxuICAgICAgICAgICAgMC4zLCAwLjYsIDAuMSwgMCwgMCxcclxuICAgICAgICAgICAgMC4zLCAwLjYsIDAuMSwgMCwgMCxcclxuICAgICAgICAgICAgMCwgMCwgMCwgMSwgMFxyXG4gICAgICAgIF07XHJcbiAgICAgICAgdGhpcy5fbG9hZE1hdHJpeChtYXRyaXgsIG11bHRpcGx5KTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRoZSBodWUgcHJvcGVydHkgb2YgdGhlIGNvbG9yXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJvdGF0aW9uIC0gaW4gZGVncmVlc1xyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBtdWx0aXBseSAtIGlmIHRydWUsIGN1cnJlbnQgbWF0cml4IGFuZCBtYXRyaXggYXJlIG11bHRpcGxpZWQuIElmIGZhbHNlLFxyXG4gICAgICogIGp1c3Qgc2V0IHRoZSBjdXJyZW50IG1hdHJpeCB3aXRoIEBwYXJhbSBtYXRyaXhcclxuICAgICAqL1xyXG4gICAgaHVlKHJvdGF0aW9uLCBtdWx0aXBseSkge1xyXG4gICAgICAgIHJvdGF0aW9uID0gKHJvdGF0aW9uIHx8IDApIC8gMTgwICogTWF0aC5QSTtcclxuICAgICAgICB2YXIgY29zUiA9IE1hdGguY29zKHJvdGF0aW9uKTtcclxuICAgICAgICB2YXIgc2luUiA9IE1hdGguc2luKHJvdGF0aW9uKTtcclxuICAgICAgICB2YXIgc3FydCA9IE1hdGguc3FydDtcclxuICAgICAgICAvKiBhIGdvb2QgYXBwcm94aW1hdGlvbiBmb3IgaHVlIHJvdGF0aW9uXHJcbiAgICAgICAgICAgIFRoaXMgbWF0cml4IGlzIGZhciBiZXR0ZXIgdGhhbiB0aGUgdmVyc2lvbnMgd2l0aCBtYWdpYyBsdW1pbmFuY2UgY29uc3RhbnRzXHJcbiAgICAgICAgICAgIGZvcm1lcmx5IHVzZWQgaGVyZSwgYnV0IGFsc28gdXNlZCBpbiB0aGUgc3RhcmxpbmcgZnJhbWV3b3JrIChmbGFzaCkgYW5kIGtub3duIGZyb20gdGhpc1xyXG4gICAgICAgICAgICBvbGQgcGFydCBvZiB0aGUgaW50ZXJuZXQ6IHF1YXNpbW9uZG8uY29tL2FyY2hpdmVzLzAwMDU2NS5waHBcclxuXHJcbiAgICAgICAgICAgIFRoaXMgbmV3IG1hdHJpeCBpcyBiYXNlZCBvbiByZ2IgY3ViZSByb3RhdGlvbiBpbiBzcGFjZS4gTG9vayBoZXJlIGZvciBhIG1vcmUgZGVzY3JpcHRpdmVcclxuICAgICAgICAgICAgaW1wbGVtZW50YXRpb24gYXMgYSBzaGFkZXIgbm90IGEgZ2VuZXJhbCBtYXRyaXg6XHJcbiAgICAgICAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9ldmFudy9nbGZ4LmpzL2Jsb2IvNTg4NDFjMjM5MTliZDU5Nzg3ZWZmYzAzMzNhNDg5N2I0MzgzNTQxMi9zcmMvZmlsdGVycy9hZGp1c3QvaHVlc2F0dXJhdGlvbi5qc1xyXG5cclxuICAgICAgICAgICAgVGhpcyBpcyB0aGUgc291cmNlIGZvciB0aGUgY29kZTpcclxuICAgICAgICAgICAgc2VlIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvODUwNzg4NS9zaGlmdC1odWUtb2YtYW4tcmdiLWNvbG9yLzg1MTA3NTEjODUxMDc1MVxyXG4gICAgICAgICAgICAqL1xyXG4gICAgICAgIHZhciB3ID0gMSAvIDM7XHJcbiAgICAgICAgdmFyIHNxclcgPSBzcXJ0KHcpOyAvLyB3ZWlnaHQgaXNcclxuICAgICAgICB2YXIgYTAwID0gY29zUiArICgoMS4wIC0gY29zUikgKiB3KTtcclxuICAgICAgICB2YXIgYTAxID0gKHcgKiAoMS4wIC0gY29zUikpIC0gKHNxclcgKiBzaW5SKTtcclxuICAgICAgICB2YXIgYTAyID0gKHcgKiAoMS4wIC0gY29zUikpICsgKHNxclcgKiBzaW5SKTtcclxuICAgICAgICB2YXIgYTEwID0gKHcgKiAoMS4wIC0gY29zUikpICsgKHNxclcgKiBzaW5SKTtcclxuICAgICAgICB2YXIgYTExID0gY29zUiArICh3ICogKDEuMCAtIGNvc1IpKTtcclxuICAgICAgICB2YXIgYTEyID0gKHcgKiAoMS4wIC0gY29zUikpIC0gKHNxclcgKiBzaW5SKTtcclxuICAgICAgICB2YXIgYTIwID0gKHcgKiAoMS4wIC0gY29zUikpIC0gKHNxclcgKiBzaW5SKTtcclxuICAgICAgICB2YXIgYTIxID0gKHcgKiAoMS4wIC0gY29zUikpICsgKHNxclcgKiBzaW5SKTtcclxuICAgICAgICB2YXIgYTIyID0gY29zUiArICh3ICogKDEuMCAtIGNvc1IpKTtcclxuICAgICAgICB2YXIgbWF0cml4ID0gW1xyXG4gICAgICAgICAgICBhMDAsIGEwMSwgYTAyLCAwLCAwLFxyXG4gICAgICAgICAgICBhMTAsIGExMSwgYTEyLCAwLCAwLFxyXG4gICAgICAgICAgICBhMjAsIGEyMSwgYTIyLCAwLCAwLFxyXG4gICAgICAgICAgICAwLCAwLCAwLCAxLCAwXHJcbiAgICAgICAgXTtcclxuICAgICAgICB0aGlzLl9sb2FkTWF0cml4KG1hdHJpeCwgbXVsdGlwbHkpO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhlIGNvbnRyYXN0IG1hdHJpeCwgaW5jcmVhc2UgdGhlIHNlcGFyYXRpb24gYmV0d2VlbiBkYXJrIGFuZCBicmlnaHRcclxuICAgICAqIEluY3JlYXNlIGNvbnRyYXN0IDogc2hhZG93cyBkYXJrZXIgYW5kIGhpZ2hsaWdodHMgYnJpZ2h0ZXJcclxuICAgICAqIERlY3JlYXNlIGNvbnRyYXN0IDogYnJpbmcgdGhlIHNoYWRvd3MgdXAgYW5kIHRoZSBoaWdobGlnaHRzIGRvd25cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYW1vdW50IC0gdmFsdWUgb2YgdGhlIGNvbnRyYXN0ICgwLTEpXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IG11bHRpcGx5IC0gaWYgdHJ1ZSwgY3VycmVudCBtYXRyaXggYW5kIG1hdHJpeCBhcmUgbXVsdGlwbGllZC4gSWYgZmFsc2UsXHJcbiAgICAgKiAganVzdCBzZXQgdGhlIGN1cnJlbnQgbWF0cml4IHdpdGggQHBhcmFtIG1hdHJpeFxyXG4gICAgICovXHJcbiAgICBjb250cmFzdChhbW91bnQsIG11bHRpcGx5KSB7XHJcbiAgICAgICAgdmFyIHYgPSAoYW1vdW50IHx8IDApICsgMTtcclxuICAgICAgICB2YXIgbyA9IC0wLjUgKiAodiAtIDEpO1xyXG4gICAgICAgIHZhciBtYXRyaXggPSBbXHJcbiAgICAgICAgICAgIHYsIDAsIDAsIDAsIG8sXHJcbiAgICAgICAgICAgIDAsIHYsIDAsIDAsIG8sXHJcbiAgICAgICAgICAgIDAsIDAsIHYsIDAsIG8sXHJcbiAgICAgICAgICAgIDAsIDAsIDAsIDEsIDBcclxuICAgICAgICBdO1xyXG4gICAgICAgIHRoaXMuX2xvYWRNYXRyaXgobWF0cml4LCBtdWx0aXBseSk7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFNldCB0aGUgc2F0dXJhdGlvbiBtYXRyaXgsIGluY3JlYXNlIHRoZSBzZXBhcmF0aW9uIGJldHdlZW4gY29sb3JzXHJcbiAgICAgKiBJbmNyZWFzZSBzYXR1cmF0aW9uIDogaW5jcmVhc2UgY29udHJhc3QsIGJyaWdodG5lc3MsIGFuZCBzaGFycG5lc3NcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYW1vdW50IC0gVGhlIHNhdHVyYXRpb24gYW1vdW50ICgwLTEpXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IG11bHRpcGx5IC0gaWYgdHJ1ZSwgY3VycmVudCBtYXRyaXggYW5kIG1hdHJpeCBhcmUgbXVsdGlwbGllZC4gSWYgZmFsc2UsXHJcbiAgICAgKiAganVzdCBzZXQgdGhlIGN1cnJlbnQgbWF0cml4IHdpdGggQHBhcmFtIG1hdHJpeFxyXG4gICAgICovXHJcbiAgICBzYXR1cmF0ZShhbW91bnQsIG11bHRpcGx5ID0gbnVsbCkge1xyXG4gICAgICAgIGlmIChhbW91bnQgPT09IHZvaWQgMCkge1xyXG4gICAgICAgICAgICBhbW91bnQgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgeCA9IChhbW91bnQgKiAyIC8gMykgKyAxO1xyXG4gICAgICAgIHZhciB5ID0gKCh4IC0gMSkgKiAtMC41KTtcclxuICAgICAgICB2YXIgbWF0cml4ID0gW1xyXG4gICAgICAgICAgICB4LCB5LCB5LCAwLCAwLFxyXG4gICAgICAgICAgICB5LCB4LCB5LCAwLCAwLFxyXG4gICAgICAgICAgICB5LCB5LCB4LCAwLCAwLFxyXG4gICAgICAgICAgICAwLCAwLCAwLCAxLCAwXHJcbiAgICAgICAgXTtcclxuICAgICAgICB0aGlzLl9sb2FkTWF0cml4KG1hdHJpeCwgbXVsdGlwbHkpO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBEZXNhdHVyYXRlIGltYWdlIChyZW1vdmUgY29sb3IpXHJcbiAgICAgKlxyXG4gICAgICogQ2FsbCB0aGUgc2F0dXJhdGUgZnVuY3Rpb25cclxuICAgICAqXHJcbiAgICAgKi9cclxuICAgIGRlc2F0dXJhdGUoKSB7XHJcbiAgICAgICAgdGhpcy5zYXR1cmF0ZSgtMSk7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIE5lZ2F0aXZlIGltYWdlIChpbnZlcnNlIG9mIGNsYXNzaWMgcmdiIG1hdHJpeClcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IG11bHRpcGx5IC0gaWYgdHJ1ZSwgY3VycmVudCBtYXRyaXggYW5kIG1hdHJpeCBhcmUgbXVsdGlwbGllZC4gSWYgZmFsc2UsXHJcbiAgICAgKiAganVzdCBzZXQgdGhlIGN1cnJlbnQgbWF0cml4IHdpdGggQHBhcmFtIG1hdHJpeFxyXG4gICAgICovXHJcbiAgICBuZWdhdGl2ZShtdWx0aXBseSkge1xyXG4gICAgICAgIHZhciBtYXRyaXggPSBbXHJcbiAgICAgICAgICAgIC0xLCAwLCAwLCAxLCAwLFxyXG4gICAgICAgICAgICAwLCAtMSwgMCwgMSwgMCxcclxuICAgICAgICAgICAgMCwgMCwgLTEsIDEsIDAsXHJcbiAgICAgICAgICAgIDAsIDAsIDAsIDEsIDBcclxuICAgICAgICBdO1xyXG4gICAgICAgIHRoaXMuX2xvYWRNYXRyaXgobWF0cml4LCBtdWx0aXBseSk7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFNlcGlhIGltYWdlXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBtdWx0aXBseSAtIGlmIHRydWUsIGN1cnJlbnQgbWF0cml4IGFuZCBtYXRyaXggYXJlIG11bHRpcGxpZWQuIElmIGZhbHNlLFxyXG4gICAgICogIGp1c3Qgc2V0IHRoZSBjdXJyZW50IG1hdHJpeCB3aXRoIEBwYXJhbSBtYXRyaXhcclxuICAgICAqL1xyXG4gICAgc2VwaWEobXVsdGlwbHkpIHtcclxuICAgICAgICB2YXIgbWF0cml4ID0gW1xyXG4gICAgICAgICAgICAwLjM5MywgMC43Njg5OTk5LCAwLjE4ODk5OTk5LCAwLCAwLFxyXG4gICAgICAgICAgICAwLjM0OSwgMC42ODU5OTk5LCAwLjE2Nzk5OTk5LCAwLCAwLFxyXG4gICAgICAgICAgICAwLjI3MiwgMC41MzM5OTk5LCAwLjEzMDk5OTk5LCAwLCAwLFxyXG4gICAgICAgICAgICAwLCAwLCAwLCAxLCAwXHJcbiAgICAgICAgXTtcclxuICAgICAgICB0aGlzLl9sb2FkTWF0cml4KG1hdHJpeCwgbXVsdGlwbHkpO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDb2xvciBtb3Rpb24gcGljdHVyZSBwcm9jZXNzIGludmVudGVkIGluIDE5MTYgKHRoYW5rcyBEb21pbmljIFN6YWJsZXdza2kpXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBtdWx0aXBseSAtIGlmIHRydWUsIGN1cnJlbnQgbWF0cml4IGFuZCBtYXRyaXggYXJlIG11bHRpcGxpZWQuIElmIGZhbHNlLFxyXG4gICAgICogIGp1c3Qgc2V0IHRoZSBjdXJyZW50IG1hdHJpeCB3aXRoIEBwYXJhbSBtYXRyaXhcclxuICAgICAqL1xyXG4gICAgdGVjaG5pY29sb3IobXVsdGlwbHkpIHtcclxuICAgICAgICB2YXIgbWF0cml4ID0gW1xyXG4gICAgICAgICAgICAxLjkxMjUyNzc4OTE0NTYwODMsIC0wLjg1NDUzNDQ5NzY5NTE2NDUsIC0wLjA5MTU1NTA4NDgyNzU1NTg1LCAwLCAxMS43OTM2MDM0MzQzNzczMzcsXHJcbiAgICAgICAgICAgIC0wLjMwODc4MzMzODU5MjgwOTcsIDEuNzY1ODkwODU1NTQ1ODQyOCwgLTAuMTA2MDE3NDMwNzQ3MjIyNDUsIDAsIC03MC4zNTIwNTE2MTQ2MTM5OCxcclxuICAgICAgICAgICAgLTAuMjMxMTAzMzc3NTQ4NjE2LCAtMC43NTAxODk5MTk3NDQwMjEyLCAxLjg0NzU5NzgxNjEwODE4OSwgMCwgMzAuOTUwOTQwODY5NDkxMTM4LFxyXG4gICAgICAgICAgICAwLCAwLCAwLCAxLCAwXHJcbiAgICAgICAgXTtcclxuICAgICAgICB0aGlzLl9sb2FkTWF0cml4KG1hdHJpeCwgbXVsdGlwbHkpO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBQb2xhcm9pZCBmaWx0ZXJcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IG11bHRpcGx5IC0gaWYgdHJ1ZSwgY3VycmVudCBtYXRyaXggYW5kIG1hdHJpeCBhcmUgbXVsdGlwbGllZC4gSWYgZmFsc2UsXHJcbiAgICAgKiAganVzdCBzZXQgdGhlIGN1cnJlbnQgbWF0cml4IHdpdGggQHBhcmFtIG1hdHJpeFxyXG4gICAgICovXHJcbiAgICBwb2xhcm9pZChtdWx0aXBseSkge1xyXG4gICAgICAgIHZhciBtYXRyaXggPSBbXHJcbiAgICAgICAgICAgIDEuNDM4LCAtMC4wNjIsIC0wLjA2MiwgMCwgMCxcclxuICAgICAgICAgICAgLTAuMTIyLCAxLjM3OCwgLTAuMTIyLCAwLCAwLFxyXG4gICAgICAgICAgICAtMC4wMTYsIC0wLjAxNiwgMS40ODMsIDAsIDAsXHJcbiAgICAgICAgICAgIDAsIDAsIDAsIDEsIDBcclxuICAgICAgICBdO1xyXG4gICAgICAgIHRoaXMuX2xvYWRNYXRyaXgobWF0cml4LCBtdWx0aXBseSk7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIEZpbHRlciB3aG8gdHJhbnNmb3JtcyA6IFJlZCAtPiBCbHVlIGFuZCBCbHVlIC0+IFJlZFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gbXVsdGlwbHkgLSBpZiB0cnVlLCBjdXJyZW50IG1hdHJpeCBhbmQgbWF0cml4IGFyZSBtdWx0aXBsaWVkLiBJZiBmYWxzZSxcclxuICAgICAqICBqdXN0IHNldCB0aGUgY3VycmVudCBtYXRyaXggd2l0aCBAcGFyYW0gbWF0cml4XHJcbiAgICAgKi9cclxuICAgIHRvQkdSKG11bHRpcGx5KSB7XHJcbiAgICAgICAgdmFyIG1hdHJpeCA9IFtcclxuICAgICAgICAgICAgMCwgMCwgMSwgMCwgMCxcclxuICAgICAgICAgICAgMCwgMSwgMCwgMCwgMCxcclxuICAgICAgICAgICAgMSwgMCwgMCwgMCwgMCxcclxuICAgICAgICAgICAgMCwgMCwgMCwgMSwgMFxyXG4gICAgICAgIF07XHJcbiAgICAgICAgdGhpcy5fbG9hZE1hdHJpeChtYXRyaXgsIG11bHRpcGx5KTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQ29sb3IgcmV2ZXJzYWwgZmlsbSBpbnRyb2R1Y2VkIGJ5IEVhc3RtYW4gS29kYWsgaW4gMTkzNS4gKHRoYW5rcyBEb21pbmljIFN6YWJsZXdza2kpXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBtdWx0aXBseSAtIGlmIHRydWUsIGN1cnJlbnQgbWF0cml4IGFuZCBtYXRyaXggYXJlIG11bHRpcGxpZWQuIElmIGZhbHNlLFxyXG4gICAgICogIGp1c3Qgc2V0IHRoZSBjdXJyZW50IG1hdHJpeCB3aXRoIEBwYXJhbSBtYXRyaXhcclxuICAgICAqL1xyXG4gICAga29kYWNocm9tZShtdWx0aXBseSkge1xyXG4gICAgICAgIHZhciBtYXRyaXggPSBbXHJcbiAgICAgICAgICAgIDEuMTI4NTU4MjM5NjU5MzUyNSwgLTAuMzk2NzM4MjI4MzYwMTM0OCwgLTAuMDM5OTI1NTkxNzI5MjE3OTMsIDAsIDYzLjcyOTU4NzYyMTk2NTAyLFxyXG4gICAgICAgICAgICAtMC4xNjQwNDMzOTk2MjI0NDYxNiwgMS4wODM1MjUxNTY2MjkxMzA0LCAtMC4wNTQ5ODgwNTExNTYzMzEzMiwgMCwgMjQuNzMyNDA3ODk2NzA2MjAzLFxyXG4gICAgICAgICAgICAtMC4xNjc4NjAxMDcwNjE1NTc2MywgLTAuNTYwMzQxNjI3NzY5NTI0OCwgMS42MDE0ODUwNzYxOTY0OTQzLCAwLCAzNS42Mjk4MjgwNzQ2MDk0NixcclxuICAgICAgICAgICAgMCwgMCwgMCwgMSwgMFxyXG4gICAgICAgIF07XHJcbiAgICAgICAgdGhpcy5fbG9hZE1hdHJpeChtYXRyaXgsIG11bHRpcGx5KTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQnJvd24gZGVsaWNpb3VzIGJyb3duaSBmaWx0ZXIgKHRoYW5rcyBEb21pbmljIFN6YWJsZXdza2kpXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBtdWx0aXBseSAtIGlmIHRydWUsIGN1cnJlbnQgbWF0cml4IGFuZCBtYXRyaXggYXJlIG11bHRpcGxpZWQuIElmIGZhbHNlLFxyXG4gICAgICogIGp1c3Qgc2V0IHRoZSBjdXJyZW50IG1hdHJpeCB3aXRoIEBwYXJhbSBtYXRyaXhcclxuICAgICAqL1xyXG4gICAgYnJvd25pKG11bHRpcGx5KSB7XHJcbiAgICAgICAgdmFyIG1hdHJpeCA9IFtcclxuICAgICAgICAgICAgMC41OTk3MDIzNDk4MTU5NzE1LCAwLjM0NTUzMjQzMDQ4MzkxMjYzLCAtMC4yNzA4Mjk4Njc0NTM4MDQyLCAwLCA0Ny40MzE5Mjg1NTYwMDg3MyxcclxuICAgICAgICAgICAgLTAuMDM3NzAzMjQ5ODM3NzgzMTU3LCAwLjg2MDk1Nzc1ODc5OTI2NDEsIDAuMTUwNTk1NTIzODg0NTk5MTMsIDAsIC0zNi45Njg0MTQ5ODMxOTEyNyxcclxuICAgICAgICAgICAgMC4yNDExMzYzNTEyODE1MzMzNSwgLTAuMDc0NDEwMzc5MDg0MjI0OTIsIDAuNDQ5NzIxODIwNjQ4NzcxNTMsIDAsIC03LjU2MjA3NTI3NzU5MTI4MyxcclxuICAgICAgICAgICAgMCwgMCwgMCwgMSwgMFxyXG4gICAgICAgIF07XHJcbiAgICAgICAgdGhpcy5fbG9hZE1hdHJpeChtYXRyaXgsIG11bHRpcGx5KTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogVmludGFnZSBmaWx0ZXIgKHRoYW5rcyBEb21pbmljIFN6YWJsZXdza2kpXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBtdWx0aXBseSAtIGlmIHRydWUsIGN1cnJlbnQgbWF0cml4IGFuZCBtYXRyaXggYXJlIG11bHRpcGxpZWQuIElmIGZhbHNlLFxyXG4gICAgICogIGp1c3Qgc2V0IHRoZSBjdXJyZW50IG1hdHJpeCB3aXRoIEBwYXJhbSBtYXRyaXhcclxuICAgICAqL1xyXG4gICAgdmludGFnZShtdWx0aXBseSkge1xyXG4gICAgICAgIHZhciBtYXRyaXggPSBbXHJcbiAgICAgICAgICAgIDAuNjI3OTM0NTYzNTYwNTk5NCwgMC4zMjAyMTgzNDIwODE5MzY3LCAtMC4wMzk2NTQwODIxMTMxMjQ1MywgMCwgOS42NTEyODU4MzUyOTQxMjMsXHJcbiAgICAgICAgICAgIDAuMDI1NzgzOTc3MDQ4MDg4NjgsIDAuNjQ0MTE4ODY0NDM3NDc3MSwgMC4wMzI1OTEyNzYxNjE0OTI5NCwgMCwgNy40NjI4MjkxNzY0NzA1OTEsXHJcbiAgICAgICAgICAgIDAuMDQ2NjA1NTU1Njc4MjcxOSwgLTAuMDg1MTIzMjk4NzI0Nzg5MSwgMC41MjQxNjQ4MDE4NzAwNDY1LCAwLCA1LjE1OTE5MDU4ODIzNTI5NixcclxuICAgICAgICAgICAgMCwgMCwgMCwgMSwgMFxyXG4gICAgICAgIF07XHJcbiAgICAgICAgdGhpcy5fbG9hZE1hdHJpeChtYXRyaXgsIG11bHRpcGx5KTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogV2UgZG9uJ3Qga25vdyBleGFjdGx5IHdoYXQgaXQgZG9lcywga2luZCBvZiBncmFkaWVudCBtYXAsIGJ1dCBmdW5ueSB0byBwbGF5IHdpdGghXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRlc2F0dXJhdGlvbiAtIFRvbmUgdmFsdWVzLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRvbmVkIC0gVG9uZSB2YWx1ZXMuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbGlnaHRDb2xvciAtIFRvbmUgdmFsdWVzLCBleGFtcGxlOiBgMHhGRkU1ODBgXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZGFya0NvbG9yIC0gVG9uZSB2YWx1ZXMsIGV4YW1wbGU6IGAweEZGRTU4MGBcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gbXVsdGlwbHkgLSBpZiB0cnVlLCBjdXJyZW50IG1hdHJpeCBhbmQgbWF0cml4IGFyZSBtdWx0aXBsaWVkLiBJZiBmYWxzZSxcclxuICAgICAqICBqdXN0IHNldCB0aGUgY3VycmVudCBtYXRyaXggd2l0aCBAcGFyYW0gbWF0cml4XHJcbiAgICAgKi9cclxuICAgIGNvbG9yVG9uZShkZXNhdHVyYXRpb24sIHRvbmVkLCBsaWdodENvbG9yLCBkYXJrQ29sb3IsIG11bHRpcGx5KSB7XHJcbiAgICAgICAgZGVzYXR1cmF0aW9uID0gZGVzYXR1cmF0aW9uIHx8IDAuMjtcclxuICAgICAgICB0b25lZCA9IHRvbmVkIHx8IDAuMTU7XHJcbiAgICAgICAgbGlnaHRDb2xvciA9IGxpZ2h0Q29sb3IgfHwgMHhGRkU1ODA7XHJcbiAgICAgICAgZGFya0NvbG9yID0gZGFya0NvbG9yIHx8IDB4MzM4MDAwO1xyXG4gICAgICAgIHZhciBsUiA9ICgobGlnaHRDb2xvciA+PiAxNikgJiAweEZGKSAvIDI1NTtcclxuICAgICAgICB2YXIgbEcgPSAoKGxpZ2h0Q29sb3IgPj4gOCkgJiAweEZGKSAvIDI1NTtcclxuICAgICAgICB2YXIgbEIgPSAobGlnaHRDb2xvciAmIDB4RkYpIC8gMjU1O1xyXG4gICAgICAgIHZhciBkUiA9ICgoZGFya0NvbG9yID4+IDE2KSAmIDB4RkYpIC8gMjU1O1xyXG4gICAgICAgIHZhciBkRyA9ICgoZGFya0NvbG9yID4+IDgpICYgMHhGRikgLyAyNTU7XHJcbiAgICAgICAgdmFyIGRCID0gKGRhcmtDb2xvciAmIDB4RkYpIC8gMjU1O1xyXG4gICAgICAgIHZhciBtYXRyaXggPSBbXHJcbiAgICAgICAgICAgIDAuMywgMC41OSwgMC4xMSwgMCwgMCxcclxuICAgICAgICAgICAgbFIsIGxHLCBsQiwgZGVzYXR1cmF0aW9uLCAwLFxyXG4gICAgICAgICAgICBkUiwgZEcsIGRCLCB0b25lZCwgMCxcclxuICAgICAgICAgICAgbFIgLSBkUiwgbEcgLSBkRywgbEIgLSBkQiwgMCwgMFxyXG4gICAgICAgIF07XHJcbiAgICAgICAgdGhpcy5fbG9hZE1hdHJpeChtYXRyaXgsIG11bHRpcGx5KTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogTmlnaHQgZWZmZWN0XHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGludGVuc2l0eSAtIFRoZSBpbnRlbnNpdHkgb2YgdGhlIG5pZ2h0IGVmZmVjdC5cclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gbXVsdGlwbHkgLSBpZiB0cnVlLCBjdXJyZW50IG1hdHJpeCBhbmQgbWF0cml4IGFyZSBtdWx0aXBsaWVkLiBJZiBmYWxzZSxcclxuICAgICAqICBqdXN0IHNldCB0aGUgY3VycmVudCBtYXRyaXggd2l0aCBAcGFyYW0gbWF0cml4XHJcbiAgICAgKi9cclxuICAgIG5pZ2h0KGludGVuc2l0eSwgbXVsdGlwbHkpIHtcclxuICAgICAgICBpbnRlbnNpdHkgPSBpbnRlbnNpdHkgfHwgMC4xO1xyXG4gICAgICAgIHZhciBtYXRyaXggPSBbXHJcbiAgICAgICAgICAgIGludGVuc2l0eSAqICgtMi4wKSwgLWludGVuc2l0eSwgMCwgMCwgMCxcclxuICAgICAgICAgICAgLWludGVuc2l0eSwgMCwgaW50ZW5zaXR5LCAwLCAwLFxyXG4gICAgICAgICAgICAwLCBpbnRlbnNpdHksIGludGVuc2l0eSAqIDIuMCwgMCwgMCxcclxuICAgICAgICAgICAgMCwgMCwgMCwgMSwgMFxyXG4gICAgICAgIF07XHJcbiAgICAgICAgdGhpcy5fbG9hZE1hdHJpeChtYXRyaXgsIG11bHRpcGx5KTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogUHJlZGF0b3IgZWZmZWN0XHJcbiAgICAgKlxyXG4gICAgICogRXJhc2UgdGhlIGN1cnJlbnQgbWF0cml4IGJ5IHNldHRpbmcgYSBuZXcgaW5kZXBlbnQgb25lXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGFtb3VudCAtIGhvdyBtdWNoIHRoZSBwcmVkYXRvciBmZWVscyBoaXMgZnV0dXJlIHZpY3RpbVxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBtdWx0aXBseSAtIGlmIHRydWUsIGN1cnJlbnQgbWF0cml4IGFuZCBtYXRyaXggYXJlIG11bHRpcGxpZWQuIElmIGZhbHNlLFxyXG4gICAgICogIGp1c3Qgc2V0IHRoZSBjdXJyZW50IG1hdHJpeCB3aXRoIEBwYXJhbSBtYXRyaXhcclxuICAgICAqL1xyXG4gICAgcHJlZGF0b3IoYW1vdW50LCBtdWx0aXBseSkge1xyXG4gICAgICAgIHZhciBtYXRyaXggPSBbXHJcbiAgICAgICAgICAgIC8vIHJvdyAxXHJcbiAgICAgICAgICAgIDExLjIyNDEzMDYzMDQ5MzE2NCAqIGFtb3VudCxcclxuICAgICAgICAgICAgLTQuNzk0NDg2OTk5NTExNzE5ICogYW1vdW50LFxyXG4gICAgICAgICAgICAtMi44NzQ2MTE4NTQ1NTMyMjI3ICogYW1vdW50LFxyXG4gICAgICAgICAgICAwICogYW1vdW50LFxyXG4gICAgICAgICAgICAwLjQwMzQyNDM4MjIwOTc3NzgzICogYW1vdW50LFxyXG4gICAgICAgICAgICAvLyByb3cgMlxyXG4gICAgICAgICAgICAtMy42MzMwNjk3NTM2NDY4NTA2ICogYW1vdW50LFxyXG4gICAgICAgICAgICA5LjE5MzE1NzE5NjA0NDkyMiAqIGFtb3VudCxcclxuICAgICAgICAgICAgLTIuOTUxODEwODM2NzkxOTkyICogYW1vdW50LFxyXG4gICAgICAgICAgICAwICogYW1vdW50LFxyXG4gICAgICAgICAgICAtMS4zMTYxMzUwNDg4NjYyNzIgKiBhbW91bnQsXHJcbiAgICAgICAgICAgIC8vIHJvdyAzXHJcbiAgICAgICAgICAgIC0zLjIxODQxOTc5MDI2Nzk0NDMgKiBhbW91bnQsXHJcbiAgICAgICAgICAgIC00LjIzNzUwMzA1MTc1NzgxMjUgKiBhbW91bnQsXHJcbiAgICAgICAgICAgIDcuNDc2NDQ4MDU5MDgyMDMxICogYW1vdW50LFxyXG4gICAgICAgICAgICAwICogYW1vdW50LFxyXG4gICAgICAgICAgICAwLjgwNDQ0NTkyMjM3NDcyNTMgKiBhbW91bnQsXHJcbiAgICAgICAgICAgIC8vIHJvdyA0XHJcbiAgICAgICAgICAgIDAsIDAsIDAsIDEsIDBcclxuICAgICAgICBdO1xyXG4gICAgICAgIHRoaXMuX2xvYWRNYXRyaXgobWF0cml4LCBtdWx0aXBseSk7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIExTRCBlZmZlY3RcclxuICAgICAqXHJcbiAgICAgKiBNdWx0aXBseSB0aGUgY3VycmVudCBtYXRyaXhcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IG11bHRpcGx5IC0gaWYgdHJ1ZSwgY3VycmVudCBtYXRyaXggYW5kIG1hdHJpeCBhcmUgbXVsdGlwbGllZC4gSWYgZmFsc2UsXHJcbiAgICAgKiAganVzdCBzZXQgdGhlIGN1cnJlbnQgbWF0cml4IHdpdGggQHBhcmFtIG1hdHJpeFxyXG4gICAgICovXHJcbiAgICBsc2QobXVsdGlwbHkpIHtcclxuICAgICAgICB2YXIgbWF0cml4ID0gW1xyXG4gICAgICAgICAgICAyLCAtMC40LCAwLjUsIDAsIDAsXHJcbiAgICAgICAgICAgIC0wLjUsIDIsIC0wLjQsIDAsIDAsXHJcbiAgICAgICAgICAgIC0wLjQsIC0wLjUsIDMsIDAsIDAsXHJcbiAgICAgICAgICAgIDAsIDAsIDAsIDEsIDBcclxuICAgICAgICBdO1xyXG4gICAgICAgIHRoaXMuX2xvYWRNYXRyaXgobWF0cml4LCBtdWx0aXBseSk7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIEVyYXNlIHRoZSBjdXJyZW50IG1hdHJpeCBieSBzZXR0aW5nIHRoZSBkZWZhdWx0IG9uZVxyXG4gICAgICpcclxuICAgICAqL1xyXG4gICAgcmVzZXQoKSB7XHJcbiAgICAgICAgdmFyIG1hdHJpeCA9IFtcclxuICAgICAgICAgICAgMSwgMCwgMCwgMCwgMCxcclxuICAgICAgICAgICAgMCwgMSwgMCwgMCwgMCxcclxuICAgICAgICAgICAgMCwgMCwgMSwgMCwgMCxcclxuICAgICAgICAgICAgMCwgMCwgMCwgMSwgMFxyXG4gICAgICAgIF07XHJcbiAgICAgICAgdGhpcy5fbG9hZE1hdHJpeChtYXRyaXgsIGZhbHNlKTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIG1hdHJpeCBvZiB0aGUgY29sb3IgbWF0cml4IGZpbHRlclxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge251bWJlcltdfVxyXG4gICAgICogQGRlZmF1bHQgWzEsIDAsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDAsIDEsIDBdXHJcbiAgICAgKi9cclxuICAgIGdldCBtYXRyaXgoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudW5pZm9ybXMubTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIHNldCBtYXRyaXgodmFsdWUpIHtcclxuICAgICAgICB0aGlzLnVuaWZvcm1zLm0gPSB2YWx1ZTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIG9wYWNpdHkgdmFsdWUgdG8gdXNlIHdoZW4gbWl4aW5nIHRoZSBvcmlnaW5hbCBhbmQgcmVzdWx0YW50IGNvbG9ycy5cclxuICAgICAqXHJcbiAgICAgKiBXaGVuIHRoZSB2YWx1ZSBpcyAwLCB0aGUgb3JpZ2luYWwgY29sb3IgaXMgdXNlZCB3aXRob3V0IG1vZGlmaWNhdGlvbi5cclxuICAgICAqIFdoZW4gdGhlIHZhbHVlIGlzIDEsIHRoZSByZXN1bHQgY29sb3IgaXMgdXNlZC5cclxuICAgICAqIFdoZW4gaW4gdGhlIHJhbmdlICgwLCAxKSB0aGUgY29sb3IgaXMgaW50ZXJwb2xhdGVkIGJldHdlZW4gdGhlIG9yaWdpbmFsIGFuZCByZXN1bHQgYnkgdGhpcyBhbW91bnQuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICogQGRlZmF1bHQgMVxyXG4gICAgICovXHJcbiAgICBnZXQgYWxwaGEoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudW5pZm9ybXMudUFscGhhO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgc2V0IGFscGhhKHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy51bmlmb3Jtcy51QWxwaGEgPSB2YWx1ZTtcclxuICAgIH1cclxuICAgIDtcclxufVxyXG4vKiFcclxuKiBAcGl4aS9maWx0ZXItY29sb3ItbWF0cml4IC0gdjUuMC4wLXJjLjNcclxuKiBDb21waWxlZCBXZWQsIDEwIEFwciAyMDE5IDAxOjIxOjE1IFVUQ1xyXG4qXHJcbiogQHBpeGkvZmlsdGVyLWNvbG9yLW1hdHJpeCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXHJcbiogaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZVxyXG4qL1xyXG5Db2xvck1hdHJpeEZpbHRlci5mcmFnbWVudCQ0ID0gXCJ2YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXHJcXG51bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjtcXHJcXG51bmlmb3JtIGZsb2F0IG1bMjBdO1xcclxcbnVuaWZvcm0gZmxvYXQgdUFscGhhO1xcclxcblxcclxcbnZvaWQgbWFpbih2b2lkKVxcclxcbntcXHJcXG4gICAgdmVjNCBjID0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2VGV4dHVyZUNvb3JkKTtcXHJcXG5cXHJcXG4gICAgaWYgKHVBbHBoYSA9PSAwLjApIHtcXHJcXG4gICAgICAgIGdsX0ZyYWdDb2xvciA9IGM7XFxyXFxuICAgICAgICByZXR1cm47XFxyXFxuICAgIH1cXHJcXG5cXHJcXG4gICAgLy8gVW4tcHJlbXVsdGlwbHkgYWxwaGEgYmVmb3JlIGFwcGx5aW5nIHRoZSBjb2xvciBtYXRyaXguIFNlZSBpc3N1ZSAjMzUzOS5cXHJcXG4gICAgaWYgKGMuYSA+IDAuMCkge1xcclxcbiAgICAgIGMucmdiIC89IGMuYTtcXHJcXG4gICAgfVxcclxcblxcclxcbiAgICB2ZWM0IHJlc3VsdDtcXHJcXG5cXHJcXG4gICAgcmVzdWx0LnIgPSAobVswXSAqIGMucik7XFxyXFxuICAgICAgICByZXN1bHQuciArPSAobVsxXSAqIGMuZyk7XFxyXFxuICAgICAgICByZXN1bHQuciArPSAobVsyXSAqIGMuYik7XFxyXFxuICAgICAgICByZXN1bHQuciArPSAobVszXSAqIGMuYSk7XFxyXFxuICAgICAgICByZXN1bHQuciArPSBtWzRdO1xcclxcblxcclxcbiAgICByZXN1bHQuZyA9IChtWzVdICogYy5yKTtcXHJcXG4gICAgICAgIHJlc3VsdC5nICs9IChtWzZdICogYy5nKTtcXHJcXG4gICAgICAgIHJlc3VsdC5nICs9IChtWzddICogYy5iKTtcXHJcXG4gICAgICAgIHJlc3VsdC5nICs9IChtWzhdICogYy5hKTtcXHJcXG4gICAgICAgIHJlc3VsdC5nICs9IG1bOV07XFxyXFxuXFxyXFxuICAgIHJlc3VsdC5iID0gKG1bMTBdICogYy5yKTtcXHJcXG4gICAgICAgcmVzdWx0LmIgKz0gKG1bMTFdICogYy5nKTtcXHJcXG4gICAgICAgcmVzdWx0LmIgKz0gKG1bMTJdICogYy5iKTtcXHJcXG4gICAgICAgcmVzdWx0LmIgKz0gKG1bMTNdICogYy5hKTtcXHJcXG4gICAgICAgcmVzdWx0LmIgKz0gbVsxNF07XFxyXFxuXFxyXFxuICAgIHJlc3VsdC5hID0gKG1bMTVdICogYy5yKTtcXHJcXG4gICAgICAgcmVzdWx0LmEgKz0gKG1bMTZdICogYy5nKTtcXHJcXG4gICAgICAgcmVzdWx0LmEgKz0gKG1bMTddICogYy5iKTtcXHJcXG4gICAgICAgcmVzdWx0LmEgKz0gKG1bMThdICogYy5hKTtcXHJcXG4gICAgICAgcmVzdWx0LmEgKz0gbVsxOV07XFxyXFxuXFxyXFxuICAgIHZlYzMgcmdiID0gbWl4KGMucmdiLCByZXN1bHQucmdiLCB1QWxwaGEpO1xcclxcblxcclxcbiAgICAvLyBQcmVtdWx0aXBseSBhbHBoYSBhZ2Fpbi5cXHJcXG4gICAgcmdiICo9IHJlc3VsdC5hO1xcclxcblxcclxcbiAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KHJnYiwgcmVzdWx0LmEpO1xcclxcbn1cXHJcXG5cIjtcclxuZXhwb3J0cy5Db2xvck1hdHJpeEZpbHRlciA9IENvbG9yTWF0cml4RmlsdGVyO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBNYXRoU2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL01hdGhTZXR0aW5nc1wiKTtcclxuY2xhc3MgQ29sb3JTZXR0aW5ncyB7XHJcbiAgICBzdGF0aWMgcHJlbXVsdGlwbHlUaW50KHRpbnQsIGFscGhhKSB7XHJcbiAgICAgICAgaWYgKGFscGhhID09PSAxLjApIHtcclxuICAgICAgICAgICAgcmV0dXJuIChhbHBoYSAqIDI1NSA8PCAyNCkgKyB0aW50O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYWxwaGEgPT09IDAuMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIFIgPSAoKHRpbnQgPj4gMTYpICYgMHhGRik7XHJcbiAgICAgICAgdmFyIEcgPSAoKHRpbnQgPj4gOCkgJiAweEZGKTtcclxuICAgICAgICB2YXIgQiA9ICh0aW50ICYgMHhGRik7XHJcbiAgICAgICAgUiA9ICgoUiAqIGFscGhhKSArIDAuNSkgfCAwO1xyXG4gICAgICAgIEcgPSAoKEcgKiBhbHBoYSkgKyAwLjUpIHwgMDtcclxuICAgICAgICBCID0gKChCICogYWxwaGEpICsgMC41KSB8IDA7XHJcbiAgICAgICAgcmV0dXJuIChhbHBoYSAqIDI1NSA8PCAyNCkgKyAoUiA8PCAxNikgKyAoRyA8PCA4KSArIEI7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgcHJlbXVsdGlwbHlUaW50VG9SZ2JhKHRpbnQsIGFscGhhLCBvdXQsIHByZW11bHRpcGx5KSB7XHJcbiAgICAgICAgb3V0ID0gb3V0IHx8IG5ldyBGbG9hdDMyQXJyYXkoNCk7XHJcbiAgICAgICAgb3V0WzBdID0gKCh0aW50ID4+IDE2KSAmIDB4RkYpIC8gMjU1LjA7XHJcbiAgICAgICAgb3V0WzFdID0gKCh0aW50ID4+IDgpICYgMHhGRikgLyAyNTUuMDtcclxuICAgICAgICBvdXRbMl0gPSAodGludCAmIDB4RkYpIC8gMjU1LjA7XHJcbiAgICAgICAgaWYgKHByZW11bHRpcGx5IHx8IHByZW11bHRpcGx5ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgb3V0WzBdICo9IGFscGhhO1xyXG4gICAgICAgICAgICBvdXRbMV0gKj0gYWxwaGE7XHJcbiAgICAgICAgICAgIG91dFsyXSAqPSBhbHBoYTtcclxuICAgICAgICB9XHJcbiAgICAgICAgb3V0WzNdID0gYWxwaGE7XHJcbiAgICAgICAgcmV0dXJuIG91dDtcclxuICAgIH1cclxuICAgIHN0YXRpYyBnZXRTaW5nbGVDb2xvcihjb2xvcikge1xyXG4gICAgICAgIGlmICh0eXBlb2YgY29sb3IgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBNYXRoU2V0dGluZ3NfMS5NYXRoU2V0dGluZ3MuaGV4MnN0cmluZyhjb2xvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBjb2xvciA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgaWYgKGNvbG9yLmluZGV4T2YoJzB4JykgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIGNvbG9yID0gY29sb3IucmVwbGFjZSgnMHgnLCAnIycpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjb2xvcjtcclxuICAgIH1cclxuICAgIHN0YXRpYyBnZXRDb2xvcihjb2xvcikge1xyXG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShjb2xvcikpIHtcclxuICAgICAgICAgICAgcmV0dXJuIENvbG9yU2V0dGluZ3MuZ2V0U2luZ2xlQ29sb3IoY29sb3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb2xvci5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgY29sb3JbaV0gPSBDb2xvclNldHRpbmdzLmdldFNpbmdsZUNvbG9yKGNvbG9yW2ldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gY29sb3I7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc3RhdGljIHByZW11bHRpcGx5UmdiYShyZ2IsIGFscGhhLCBvdXQsIHByZW11bHRpcGx5KSB7XHJcbiAgICAgICAgb3V0ID0gb3V0IHx8IG5ldyBGbG9hdDMyQXJyYXkoNCk7XHJcbiAgICAgICAgaWYgKHByZW11bHRpcGx5IHx8IHByZW11bHRpcGx5ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgb3V0WzBdID0gcmdiWzBdICogYWxwaGE7XHJcbiAgICAgICAgICAgIG91dFsxXSA9IHJnYlsxXSAqIGFscGhhO1xyXG4gICAgICAgICAgICBvdXRbMl0gPSByZ2JbMl0gKiBhbHBoYTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG91dFswXSA9IHJnYlswXTtcclxuICAgICAgICAgICAgb3V0WzFdID0gcmdiWzFdO1xyXG4gICAgICAgICAgICBvdXRbMl0gPSByZ2JbMl07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG91dFszXSA9IGFscGhhO1xyXG4gICAgICAgIHJldHVybiBvdXQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuKiBDb252ZXJ0cyBhIGhleGFkZWNpbWFsIGNvbG9yIG51bWJlciB0byBhbiBbUiwgRywgQl0gYXJyYXkgb2Ygbm9ybWFsaXplZCBmbG9hdHMgKG51bWJlcnMgZnJvbSAwLjAgdG8gMS4wKS5cclxuKlxyXG4qIEBleGFtcGxlXHJcbiogUElYSS51dGlscy5oZXgycmdiKDB4ZmZmZmZmKTsgLy8gcmV0dXJucyBbMSwgMSwgMV1cclxuKiBAbWVtYmVyb2YgUElYSS51dGlsc1xyXG4qIEBmdW5jdGlvbiBoZXgycmdiXHJcbiogQHBhcmFtIHtudW1iZXJ9IGhleCAtIFRoZSBoZXhhZGVjaW1hbCBudW1iZXIgdG8gY29udmVydFxyXG4qIEBwYXJhbSAge251bWJlcltdfSBbb3V0PVtdXSBJZiBzdXBwbGllZCwgdGhpcyBhcnJheSB3aWxsIGJlIHVzZWQgcmF0aGVyIHRoYW4gcmV0dXJuaW5nIGEgbmV3IG9uZVxyXG4qIEByZXR1cm4ge251bWJlcltdfSBBbiBhcnJheSByZXByZXNlbnRpbmcgdGhlIFtSLCBHLCBCXSBvZiB0aGUgY29sb3Igd2hlcmUgYWxsIHZhbHVlcyBhcmUgZmxvYXRzLlxyXG4qL1xyXG4gICAgc3RhdGljIGhleDJyZ2IoaGV4LCBvdXQgPSBudWxsKSB7XHJcbiAgICAgICAgb3V0ID0gb3V0IHx8IFtdO1xyXG4gICAgICAgIG91dFswXSA9ICgoaGV4ID4+IDE2KSAmIDB4RkYpIC8gMjU1O1xyXG4gICAgICAgIG91dFsxXSA9ICgoaGV4ID4+IDgpICYgMHhGRikgLyAyNTU7XHJcbiAgICAgICAgb3V0WzJdID0gKGhleCAmIDB4RkYpIC8gMjU1O1xyXG4gICAgICAgIHJldHVybiBvdXQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuKiBDb252ZXJ0cyBhIGNvbG9yIGFzIGFuIFtSLCBHLCBCXSBhcnJheSBvZiBub3JtYWxpemVkIGZsb2F0cyB0byBhIGhleGFkZWNpbWFsIG51bWJlci5cclxuKlxyXG4qIEBleGFtcGxlXHJcbiogUElYSS51dGlscy5yZ2IyaGV4KFsxLCAxLCAxXSk7IC8vIHJldHVybnMgMHhmZmZmZmZcclxuKiBAbWVtYmVyb2YgUElYSS51dGlsc1xyXG4qIEBmdW5jdGlvbiByZ2IyaGV4XHJcbiogQHBhcmFtIHtudW1iZXJbXX0gcmdiIC0gQXJyYXkgb2YgbnVtYmVycyB3aGVyZSBhbGwgdmFsdWVzIGFyZSBub3JtYWxpemVkIGZsb2F0cyBmcm9tIDAuMCB0byAxLjAuXHJcbiogQHJldHVybiB7bnVtYmVyfSBOdW1iZXIgaW4gaGV4YWRlY2ltYWwuXHJcbiovXHJcbiAgICBzdGF0aWMgcmdiMmhleChyZ2IpIHtcclxuICAgICAgICByZXR1cm4gKCgocmdiWzBdICogMjU1KSA8PCAxNikgKyAoKHJnYlsxXSAqIDI1NSkgPDwgOCkgKyAocmdiWzJdICogMjU1IHwgMCkpO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuQ29sb3JTZXR0aW5ncyA9IENvbG9yU2V0dGluZ3M7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IERpc3BsYXlPYmplY3RfMSA9IHJlcXVpcmUoXCIuL0Rpc3BsYXlPYmplY3RcIik7XHJcbmNvbnN0IEV2ZW50XzEgPSByZXF1aXJlKFwiLi9FdmVudFwiKTtcclxuY29uc3QgVXRpbHNTZXR0aW5nc18xID0gcmVxdWlyZShcIi4vVXRpbHNTZXR0aW5nc1wiKTtcclxuY29uc3QgRGlzcGxheVNldHRpbmdzXzEgPSByZXF1aXJlKFwiLi9EaXNwbGF5U2V0dGluZ3NcIik7XHJcbmNsYXNzIENvbnRhaW5lciBleHRlbmRzIERpc3BsYXlPYmplY3RfMS5EaXNwbGF5T2JqZWN0IHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5jb250YWluZXJVcGRhdGVUcmFuc2Zvcm0gPSB0aGlzLnVwZGF0ZVRyYW5zZm9ybTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgYXJyYXkgb2YgY2hpbGRyZW4gb2YgdGhpcyBjb250YWluZXIuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLkRpc3BsYXlPYmplY3RbXX1cclxuICAgICAgICAgKiBAcmVhZG9ubHlcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmNoaWxkcmVuID0gW107XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSWYgc2V0IHRvIHRydWUsIHRoZSBjb250YWluZXIgd2lsbCBzb3J0IGl0cyBjaGlsZHJlbiBieSB6SW5kZXggdmFsdWVcclxuICAgICAgICAgKiB3aGVuIHVwZGF0ZVRyYW5zZm9ybSgpIGlzIGNhbGxlZCwgb3IgbWFudWFsbHkgaWYgc29ydENoaWxkcmVuKCkgaXMgY2FsbGVkLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogVGhpcyBhY3R1YWxseSBjaGFuZ2VzIHRoZSBvcmRlciBvZiBlbGVtZW50cyBpbiB0aGUgYXJyYXksIHNvIHNob3VsZCBiZSB0cmVhdGVkXHJcbiAgICAgICAgICogYXMgYSBiYXNpYyBzb2x1dGlvbiB0aGF0IGlzIG5vdCBwZXJmb3JtYW50IGNvbXBhcmVkIHRvIG90aGVyIHNvbHV0aW9ucyxcclxuICAgICAgICAgKiBzdWNoIGFzIEBsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9waXhpanMvcGl4aS1kaXNwbGF5XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBBbHNvIGJlIGF3YXJlIG9mIHRoYXQgdGhpcyBtYXkgbm90IHdvcmsgbmljZWx5IHdpdGggdGhlIGFkZENoaWxkQXQoKSBmdW5jdGlvbixcclxuICAgICAgICAgKiBhcyB0aGUgekluZGV4IHNvcnRpbmcgbWF5IGNhdXNlIHRoZSBjaGlsZCB0byBhdXRvbWF0aWNhbGx5IHNvcnRlZCB0byBhbm90aGVyIHBvc2l0aW9uLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHNlZSBQSVhJLnNldHRpbmdzLlNPUlRBQkxFX0NISUxEUkVOXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAbWVtYmVyIHtib29sZWFufVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuc29ydGFibGVDaGlsZHJlbiA9IERpc3BsYXlTZXR0aW5nc18xLkRpc3BsYXlTZXR0aW5ncy5TT1JUQUJMRV9DSElMRFJFTjtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTaG91bGQgY2hpbGRyZW4gYmUgc29ydGVkIGJ5IHpJbmRleCBhdCB0aGUgbmV4dCB1cGRhdGVUcmFuc2Zvcm0gY2FsbC5cclxuICAgICAgICAgKiBXaWxsIGdldCBhdXRvbWF0aWNhbGx5IHNldCB0byB0cnVlIGlmIGEgbmV3IGNoaWxkIGlzIGFkZGVkLCBvciBpZiBhIGNoaWxkJ3MgekluZGV4IGNoYW5nZXMuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAbWVtYmVyIHtib29sZWFufVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuc29ydERpcnR5ID0gZmFsc2U7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRmlyZWQgd2hlbiBhIERpc3BsYXlPYmplY3QgaXMgYWRkZWQgdG8gdGhpcyBDb250YWluZXIuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAZXZlbnQgUElYSS5Db250YWluZXIjY2hpbGRBZGRlZFxyXG4gICAgICAgICAqIEBwYXJhbSB7UElYSS5EaXNwbGF5T2JqZWN0fSBjaGlsZCAtIFRoZSBjaGlsZCBhZGRlZCB0byB0aGUgQ29udGFpbmVyLlxyXG4gICAgICAgICAqIEBwYXJhbSB7UElYSS5Db250YWluZXJ9IGNvbnRhaW5lciAtIFRoZSBjb250YWluZXIgdGhhdCBhZGRlZCB0aGUgY2hpbGQuXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gVGhlIGNoaWxkcmVuJ3MgaW5kZXggb2YgdGhlIGFkZGVkIGNoaWxkLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEZpcmVkIHdoZW4gYSBEaXNwbGF5T2JqZWN0IGlzIHJlbW92ZWQgZnJvbSB0aGlzIENvbnRhaW5lci5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBldmVudCBQSVhJLkRpc3BsYXlPYmplY3QjcmVtb3ZlZEZyb21cclxuICAgICAgICAgKiBAcGFyYW0ge1BJWEkuRGlzcGxheU9iamVjdH0gY2hpbGQgLSBUaGUgY2hpbGQgcmVtb3ZlZCBmcm9tIHRoZSBDb250YWluZXIuXHJcbiAgICAgICAgICogQHBhcmFtIHtQSVhJLkNvbnRhaW5lcn0gY29udGFpbmVyIC0gVGhlIGNvbnRhaW5lciB0aGF0IHJlbW92ZWQgcmVtb3ZlZCB0aGUgY2hpbGQuXHJcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gVGhlIGZvcm1lciBjaGlsZHJlbidzIGluZGV4IG9mIHRoZSByZW1vdmVkIGNoaWxkXHJcbiAgICAgICAgICovXHJcbiAgICB9XHJcbiAgICAvKipcclxuICogUmV0dXJucyB0aGUgZGlzcGxheSBvYmplY3QgaW4gdGhlIGNvbnRhaW5lci5cclxuICpcclxuICogQG1ldGhvZCBnZXRDaGlsZEJ5TmFtZVxyXG4gKiBAbWVtYmVyb2YgUElYSS5Db250YWluZXIjXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gSW5zdGFuY2UgbmFtZS5cclxuICogQHJldHVybiB7UElYSS5EaXNwbGF5T2JqZWN0fSBUaGUgY2hpbGQgd2l0aCB0aGUgc3BlY2lmaWVkIG5hbWUuXHJcbiAqL1xyXG4gICAgZ2V0Q2hpbGRCeU5hbWUobmFtZSkge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5jaGlsZHJlbltpXS5uYW1lID09PSBuYW1lKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbltpXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogT3ZlcnJpZGFibGUgbWV0aG9kIHRoYXQgY2FuIGJlIHVzZWQgYnkgQ29udGFpbmVyIHN1YmNsYXNzZXMgd2hlbmV2ZXIgdGhlIGNoaWxkcmVuIGFycmF5IGlzIG1vZGlmaWVkXHJcbiAgICAgKlxyXG4gICAgICogQHByb3RlY3RlZFxyXG4gICAgICovXHJcbiAgICBvbkNoaWxkcmVuQ2hhbmdlKG9wdGlvbnMpIHtcclxuICAgICAgICAvKiBlbXB0eSAqL1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIG9uZSBvciBtb3JlIGNoaWxkcmVuIHRvIHRoZSBjb250YWluZXIuXHJcbiAgICAgKlxyXG4gICAgICogTXVsdGlwbGUgaXRlbXMgY2FuIGJlIGFkZGVkIGxpa2Ugc286IGBteUNvbnRhaW5lci5hZGRDaGlsZCh0aGluZ09uZSwgdGhpbmdUd28sIHRoaW5nVGhyZWUpYFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7Li4uUElYSS5EaXNwbGF5T2JqZWN0fSBjaGlsZCAtIFRoZSBEaXNwbGF5T2JqZWN0KHMpIHRvIGFkZCB0byB0aGUgY29udGFpbmVyXHJcbiAgICAgKiBAcmV0dXJuIHtQSVhJLkRpc3BsYXlPYmplY3R9IFRoZSBmaXJzdCBjaGlsZCB0aGF0IHdhcyBhZGRlZC5cclxuICAgICAqL1xyXG4gICAgYWRkQ2hpbGQoY2hpbGQpIHtcclxuICAgICAgICB2YXIgYXJndW1lbnRzJDEgPSBhcmd1bWVudHM7XHJcbiAgICAgICAgdmFyIGFyZ3VtZW50c0xlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XHJcbiAgICAgICAgLy8gaWYgdGhlcmUgaXMgb25seSBvbmUgYXJndW1lbnQgd2UgY2FuIGJ5cGFzcyBsb29waW5nIHRocm91Z2ggdGhlIHRoZW1cclxuICAgICAgICBpZiAoYXJndW1lbnRzTGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICAvLyBsb29wIHRocm91Z2ggdGhlIGFyZ3VtZW50cyBwcm9wZXJ0eSBhbmQgYWRkIGFsbCBjaGlsZHJlblxyXG4gICAgICAgICAgICAvLyB1c2UgaXQgdGhlIHJpZ2h0IHdheSAoLmxlbmd0aCBhbmQgW2ldKSBzbyB0aGF0IHRoaXMgZnVuY3Rpb24gY2FuIHN0aWxsIGJlIG9wdGltaXplZCBieSBKUyBydW50aW1lc1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50c0xlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFkZENoaWxkKGFyZ3VtZW50cyQxW2ldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gaWYgdGhlIGNoaWxkIGhhcyBhIHBhcmVudCB0aGVuIGxldHMgcmVtb3ZlIGl0IGFzIFBpeGlKUyBvYmplY3RzIGNhbiBvbmx5IGV4aXN0IGluIG9uZSBwbGFjZVxyXG4gICAgICAgICAgICBpZiAoY2hpbGQucGFyZW50KSB7XHJcbiAgICAgICAgICAgICAgICBjaGlsZC5wYXJlbnQucmVtb3ZlQ2hpbGQoY2hpbGQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNoaWxkLnBhcmVudCA9IHRoaXM7XHJcbiAgICAgICAgICAgIHRoaXMuc29ydERpcnR5ID0gdHJ1ZTtcclxuICAgICAgICAgICAgLy8gZW5zdXJlIGNoaWxkIHRyYW5zZm9ybSB3aWxsIGJlIHJlY2FsY3VsYXRlZFxyXG4gICAgICAgICAgICBjaGlsZC50cmFuc2Zvcm0uX3BhcmVudElEID0gLTE7XHJcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW4ucHVzaChjaGlsZCk7XHJcbiAgICAgICAgICAgIC8vIGVuc3VyZSBib3VuZHMgd2lsbCBiZSByZWNhbGN1bGF0ZWRcclxuICAgICAgICAgICAgdGhpcy5fYm91bmRzSUQrKztcclxuICAgICAgICAgICAgLy8gVE9ETyAtIGxldHMgZWl0aGVyIGRvIGFsbCBjYWxsYmFja3Mgb3IgYWxsIGV2ZW50cy4uIG5vdCBib3RoIVxyXG4gICAgICAgICAgICB0aGlzLm9uQ2hpbGRyZW5DaGFuZ2UodGhpcy5jaGlsZHJlbi5sZW5ndGggLSAxKTtcclxuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KEV2ZW50XzEuRXZlbnQuZ2V0RXZlbnQoXCJjaGlsZEFkZGVkXCIpKTtcclxuICAgICAgICAgICAgLy8gdGhpcy5lbWl0KCdjaGlsZEFkZGVkJywgY2hpbGQsIHRoaXMsIHRoaXMuY2hpbGRyZW4ubGVuZ3RoIC0gMSk7XHJcbiAgICAgICAgICAgIGNoaWxkLmRpc3BhdGNoRXZlbnQoRXZlbnRfMS5FdmVudC5nZXRFdmVudChcImFkZGVkXCIpKTtcclxuICAgICAgICAgICAgLy8gY2hpbGQuZW1pdCgnYWRkZWQnLCB0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNoaWxkO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGEgY2hpbGQgdG8gdGhlIGNvbnRhaW5lciBhdCBhIHNwZWNpZmllZCBpbmRleC4gSWYgdGhlIGluZGV4IGlzIG91dCBvZiBib3VuZHMgYW4gZXJyb3Igd2lsbCBiZSB0aHJvd25cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1BJWEkuRGlzcGxheU9iamVjdH0gY2hpbGQgLSBUaGUgY2hpbGQgdG8gYWRkXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggLSBUaGUgaW5kZXggdG8gcGxhY2UgdGhlIGNoaWxkIGluXHJcbiAgICAgKiBAcmV0dXJuIHtQSVhJLkRpc3BsYXlPYmplY3R9IFRoZSBjaGlsZCB0aGF0IHdhcyBhZGRlZC5cclxuICAgICAqL1xyXG4gICAgYWRkQ2hpbGRBdChjaGlsZCwgaW5kZXgpIHtcclxuICAgICAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID4gdGhpcy5jaGlsZHJlbi5sZW5ndGgpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKChjaGlsZCArIFwiYWRkQ2hpbGRBdDogVGhlIGluZGV4IFwiICsgaW5kZXggKyBcIiBzdXBwbGllZCBpcyBvdXQgb2YgYm91bmRzIFwiICsgKHRoaXMuY2hpbGRyZW4ubGVuZ3RoKSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY2hpbGQucGFyZW50KSB7XHJcbiAgICAgICAgICAgIGNoaWxkLnBhcmVudC5yZW1vdmVDaGlsZChjaGlsZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNoaWxkLnBhcmVudCA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5zb3J0RGlydHkgPSB0cnVlO1xyXG4gICAgICAgIC8vIGVuc3VyZSBjaGlsZCB0cmFuc2Zvcm0gd2lsbCBiZSByZWNhbGN1bGF0ZWRcclxuICAgICAgICBjaGlsZC50cmFuc2Zvcm0uX3BhcmVudElEID0gLTE7XHJcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5zcGxpY2UoaW5kZXgsIDAsIGNoaWxkKTtcclxuICAgICAgICAvLyBlbnN1cmUgYm91bmRzIHdpbGwgYmUgcmVjYWxjdWxhdGVkXHJcbiAgICAgICAgdGhpcy5fYm91bmRzSUQrKztcclxuICAgICAgICAvLyBUT0RPIC0gbGV0cyBlaXRoZXIgZG8gYWxsIGNhbGxiYWNrcyBvciBhbGwgZXZlbnRzLi4gbm90IGJvdGghXHJcbiAgICAgICAgdGhpcy5vbkNoaWxkcmVuQ2hhbmdlKGluZGV4KTtcclxuICAgICAgICAvLyBjaGlsZC5lbWl0KCdhZGRlZCcsIHRoaXMpO1xyXG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChFdmVudF8xLkV2ZW50LmdldEV2ZW50KFwiY2hpbGRBZGRlZFwiKSk7XHJcbiAgICAgICAgLy8gdGhpcy5lbWl0KCdjaGlsZEFkZGVkJywgY2hpbGQsIHRoaXMsIGluZGV4KTtcclxuICAgICAgICByZXR1cm4gY2hpbGQ7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFN3YXBzIHRoZSBwb3NpdGlvbiBvZiAyIERpc3BsYXkgT2JqZWN0cyB3aXRoaW4gdGhpcyBjb250YWluZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtQSVhJLkRpc3BsYXlPYmplY3R9IGNoaWxkIC0gRmlyc3QgZGlzcGxheSBvYmplY3QgdG8gc3dhcFxyXG4gICAgICogQHBhcmFtIHtQSVhJLkRpc3BsYXlPYmplY3R9IGNoaWxkMiAtIFNlY29uZCBkaXNwbGF5IG9iamVjdCB0byBzd2FwXHJcbiAgICAgKi9cclxuICAgIHN3YXBDaGlsZHJlbihjaGlsZCwgY2hpbGQyKSB7XHJcbiAgICAgICAgaWYgKGNoaWxkID09PSBjaGlsZDIpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgaW5kZXgxID0gdGhpcy5nZXRDaGlsZEluZGV4KGNoaWxkKTtcclxuICAgICAgICB2YXIgaW5kZXgyID0gdGhpcy5nZXRDaGlsZEluZGV4KGNoaWxkMik7XHJcbiAgICAgICAgdGhpcy5jaGlsZHJlbltpbmRleDFdID0gY2hpbGQyO1xyXG4gICAgICAgIHRoaXMuY2hpbGRyZW5baW5kZXgyXSA9IGNoaWxkO1xyXG4gICAgICAgIHRoaXMub25DaGlsZHJlbkNoYW5nZShpbmRleDEgPCBpbmRleDIgPyBpbmRleDEgOiBpbmRleDIpO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBpbmRleCBwb3NpdGlvbiBvZiBhIGNoaWxkIERpc3BsYXlPYmplY3QgaW5zdGFuY2VcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1BJWEkuRGlzcGxheU9iamVjdH0gY2hpbGQgLSBUaGUgRGlzcGxheU9iamVjdCBpbnN0YW5jZSB0byBpZGVudGlmeVxyXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgaW5kZXggcG9zaXRpb24gb2YgdGhlIGNoaWxkIGRpc3BsYXkgb2JqZWN0IHRvIGlkZW50aWZ5XHJcbiAgICAgKi9cclxuICAgIGdldENoaWxkSW5kZXgoY2hpbGQpIHtcclxuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmNoaWxkcmVuLmluZGV4T2YoY2hpbGQpO1xyXG4gICAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgc3VwcGxpZWQgRGlzcGxheU9iamVjdCBtdXN0IGJlIGEgY2hpbGQgb2YgdGhlIGNhbGxlcicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaW5kZXg7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIENoYW5nZXMgdGhlIHBvc2l0aW9uIG9mIGFuIGV4aXN0aW5nIGNoaWxkIGluIHRoZSBkaXNwbGF5IG9iamVjdCBjb250YWluZXJcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1BJWEkuRGlzcGxheU9iamVjdH0gY2hpbGQgLSBUaGUgY2hpbGQgRGlzcGxheU9iamVjdCBpbnN0YW5jZSBmb3Igd2hpY2ggeW91IHdhbnQgdG8gY2hhbmdlIHRoZSBpbmRleCBudW1iZXJcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIFRoZSByZXN1bHRpbmcgaW5kZXggbnVtYmVyIGZvciB0aGUgY2hpbGQgZGlzcGxheSBvYmplY3RcclxuICAgICAqL1xyXG4gICAgc2V0Q2hpbGRJbmRleChjaGlsZCwgaW5kZXgpIHtcclxuICAgICAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID49IHRoaXMuY2hpbGRyZW4ubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigoXCJUaGUgaW5kZXggXCIgKyBpbmRleCArIFwiIHN1cHBsaWVkIGlzIG91dCBvZiBib3VuZHMgXCIgKyAodGhpcy5jaGlsZHJlbi5sZW5ndGgpKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBjdXJyZW50SW5kZXggPSB0aGlzLmdldENoaWxkSW5kZXgoY2hpbGQpO1xyXG4gICAgICAgIFV0aWxzU2V0dGluZ3NfMS5VdGlsc1NldHRpbmdzLnJlbW92ZUl0ZW1zKHRoaXMuY2hpbGRyZW4sIGN1cnJlbnRJbmRleCwgMSk7IC8vIHJlbW92ZSBmcm9tIG9sZCBwb3NpdGlvblxyXG4gICAgICAgIHRoaXMuY2hpbGRyZW4uc3BsaWNlKGluZGV4LCAwLCBjaGlsZCk7IC8vIGFkZCBhdCBuZXcgcG9zaXRpb25cclxuICAgICAgICB0aGlzLm9uQ2hpbGRyZW5DaGFuZ2UoaW5kZXgpO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBjaGlsZCBhdCB0aGUgc3BlY2lmaWVkIGluZGV4XHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gVGhlIGluZGV4IHRvIGdldCB0aGUgY2hpbGQgYXRcclxuICAgICAqIEByZXR1cm4ge1BJWEkuRGlzcGxheU9iamVjdH0gVGhlIGNoaWxkIGF0IHRoZSBnaXZlbiBpbmRleCwgaWYgYW55LlxyXG4gICAgICovXHJcbiAgICBnZXRDaGlsZEF0KGluZGV4KSB7XHJcbiAgICAgICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSB0aGlzLmNoaWxkcmVuLmxlbmd0aCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKFwiZ2V0Q2hpbGRBdDogSW5kZXggKFwiICsgaW5kZXggKyBcIikgZG9lcyBub3QgZXhpc3QuXCIpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW5baW5kZXhdO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIG9uZSBvciBtb3JlIGNoaWxkcmVuIGZyb20gdGhlIGNvbnRhaW5lci5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gey4uLlBJWEkuRGlzcGxheU9iamVjdH0gY2hpbGQgLSBUaGUgRGlzcGxheU9iamVjdChzKSB0byByZW1vdmVcclxuICAgICAqIEByZXR1cm4ge1BJWEkuRGlzcGxheU9iamVjdH0gVGhlIGZpcnN0IGNoaWxkIHRoYXQgd2FzIHJlbW92ZWQuXHJcbiAgICAgKi9cclxuICAgIHJlbW92ZUNoaWxkKGNoaWxkKSB7XHJcbiAgICAgICAgdmFyIGFyZ3VtZW50cyQxID0gYXJndW1lbnRzO1xyXG4gICAgICAgIHZhciBhcmd1bWVudHNMZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xyXG4gICAgICAgIC8vIGlmIHRoZXJlIGlzIG9ubHkgb25lIGFyZ3VtZW50IHdlIGNhbiBieXBhc3MgbG9vcGluZyB0aHJvdWdoIHRoZSB0aGVtXHJcbiAgICAgICAgaWYgKGFyZ3VtZW50c0xlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgLy8gbG9vcCB0aHJvdWdoIHRoZSBhcmd1bWVudHMgcHJvcGVydHkgYW5kIGFkZCBhbGwgY2hpbGRyZW5cclxuICAgICAgICAgICAgLy8gdXNlIGl0IHRoZSByaWdodCB3YXkgKC5sZW5ndGggYW5kIFtpXSkgc28gdGhhdCB0aGlzIGZ1bmN0aW9uIGNhbiBzdGlsbCBiZSBvcHRpbWl6ZWQgYnkgSlMgcnVudGltZXNcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHNMZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVDaGlsZChhcmd1bWVudHMkMVtpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciBpbmRleCA9IHRoaXMuY2hpbGRyZW4uaW5kZXhPZihjaGlsZCk7XHJcbiAgICAgICAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNoaWxkLnBhcmVudCA9IG51bGw7XHJcbiAgICAgICAgICAgIC8vIGVuc3VyZSBjaGlsZCB0cmFuc2Zvcm0gd2lsbCBiZSByZWNhbGN1bGF0ZWRcclxuICAgICAgICAgICAgY2hpbGQudHJhbnNmb3JtLl9wYXJlbnRJRCA9IC0xO1xyXG4gICAgICAgICAgICBVdGlsc1NldHRpbmdzXzEuVXRpbHNTZXR0aW5ncy5yZW1vdmVJdGVtcyh0aGlzLmNoaWxkcmVuLCBpbmRleCwgMSk7XHJcbiAgICAgICAgICAgIC8vIGVuc3VyZSBib3VuZHMgd2lsbCBiZSByZWNhbGN1bGF0ZWRcclxuICAgICAgICAgICAgdGhpcy5fYm91bmRzSUQrKztcclxuICAgICAgICAgICAgLy8gVE9ETyAtIGxldHMgZWl0aGVyIGRvIGFsbCBjYWxsYmFja3Mgb3IgYWxsIGV2ZW50cy4uIG5vdCBib3RoIVxyXG4gICAgICAgICAgICB0aGlzLm9uQ2hpbGRyZW5DaGFuZ2UoaW5kZXgpO1xyXG4gICAgICAgICAgICAvLyBjaGlsZC5lbWl0KCdyZW1vdmVkJywgdGhpcyk7XHJcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChFdmVudF8xLkV2ZW50LmdldEV2ZW50KFwiY2hpbGRSZW1vdmVkXCIpKTtcclxuICAgICAgICAgICAgLy8gdGhpcy5lbWl0KCdjaGlsZFJlbW92ZWQnLCBjaGlsZCwgdGhpcywgaW5kZXgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY2hpbGQ7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgYSBjaGlsZCBmcm9tIHRoZSBzcGVjaWZpZWQgaW5kZXggcG9zaXRpb24uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gVGhlIGluZGV4IHRvIGdldCB0aGUgY2hpbGQgZnJvbVxyXG4gICAgICogQHJldHVybiB7UElYSS5EaXNwbGF5T2JqZWN0fSBUaGUgY2hpbGQgdGhhdCB3YXMgcmVtb3ZlZC5cclxuICAgICAqL1xyXG4gICAgcmVtb3ZlQ2hpbGRBdChpbmRleCkge1xyXG4gICAgICAgIHZhciBjaGlsZCA9IHRoaXMuZ2V0Q2hpbGRBdChpbmRleCk7XHJcbiAgICAgICAgLy8gZW5zdXJlIGNoaWxkIHRyYW5zZm9ybSB3aWxsIGJlIHJlY2FsY3VsYXRlZC4uXHJcbiAgICAgICAgY2hpbGQucGFyZW50ID0gbnVsbDtcclxuICAgICAgICBjaGlsZC50cmFuc2Zvcm0uX3BhcmVudElEID0gLTE7XHJcbiAgICAgICAgVXRpbHNTZXR0aW5nc18xLlV0aWxzU2V0dGluZ3MucmVtb3ZlSXRlbXModGhpcy5jaGlsZHJlbiwgaW5kZXgsIDEpO1xyXG4gICAgICAgIC8vIGVuc3VyZSBib3VuZHMgd2lsbCBiZSByZWNhbGN1bGF0ZWRcclxuICAgICAgICB0aGlzLl9ib3VuZHNJRCsrO1xyXG4gICAgICAgIC8vIFRPRE8gLSBsZXRzIGVpdGhlciBkbyBhbGwgY2FsbGJhY2tzIG9yIGFsbCBldmVudHMuLiBub3QgYm90aCFcclxuICAgICAgICB0aGlzLm9uQ2hpbGRyZW5DaGFuZ2UoaW5kZXgpO1xyXG4gICAgICAgIC8vIGNoaWxkLmVtaXQoJ3JlbW92ZWQnLCB0aGlzKTtcclxuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoRXZlbnRfMS5FdmVudC5nZXRFdmVudChcImNoaWxkUmVtb3ZlZFwiKSk7XHJcbiAgICAgICAgLy8gdGhpcy5lbWl0KCdjaGlsZFJlbW92ZWQnLCBjaGlsZCwgdGhpcywgaW5kZXgpO1xyXG4gICAgICAgIHJldHVybiBjaGlsZDtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyBhbGwgY2hpbGRyZW4gZnJvbSB0aGlzIGNvbnRhaW5lciB0aGF0IGFyZSB3aXRoaW4gdGhlIGJlZ2luIGFuZCBlbmQgaW5kZXhlcy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2JlZ2luSW5kZXg9MF0gLSBUaGUgYmVnaW5uaW5nIHBvc2l0aW9uLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtlbmRJbmRleD10aGlzLmNoaWxkcmVuLmxlbmd0aF0gLSBUaGUgZW5kaW5nIHBvc2l0aW9uLiBEZWZhdWx0IHZhbHVlIGlzIHNpemUgb2YgdGhlIGNvbnRhaW5lci5cclxuICAgICAqIEByZXR1cm5zIHtEaXNwbGF5T2JqZWN0W119IExpc3Qgb2YgcmVtb3ZlZCBjaGlsZHJlblxyXG4gICAgICovXHJcbiAgICByZW1vdmVDaGlsZHJlbihiZWdpbkluZGV4ID0gMCwgZW5kSW5kZXggPSBJbmZpbml0eSkge1xyXG4gICAgICAgIGlmIChiZWdpbkluZGV4ID09PSB2b2lkIDApIHtcclxuICAgICAgICAgICAgYmVnaW5JbmRleCA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBiZWdpbiA9IGJlZ2luSW5kZXg7XHJcbiAgICAgICAgdmFyIGVuZCA9IHR5cGVvZiBlbmRJbmRleCA9PT0gJ251bWJlcicgPyBlbmRJbmRleCA6IHRoaXMuY2hpbGRyZW4ubGVuZ3RoO1xyXG4gICAgICAgIHZhciByYW5nZSA9IGVuZCAtIGJlZ2luO1xyXG4gICAgICAgIHZhciByZW1vdmVkO1xyXG4gICAgICAgIGlmIChyYW5nZSA+IDAgJiYgcmFuZ2UgPD0gZW5kKSB7XHJcbiAgICAgICAgICAgIHJlbW92ZWQgPSB0aGlzLmNoaWxkcmVuLnNwbGljZShiZWdpbiwgcmFuZ2UpO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlbW92ZWQubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgICAgIHJlbW92ZWRbaV0ucGFyZW50ID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIGlmIChyZW1vdmVkW2ldLnRyYW5zZm9ybSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZWRbaV0udHJhbnNmb3JtLl9wYXJlbnRJRCA9IC0xO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX2JvdW5kc0lEKys7XHJcbiAgICAgICAgICAgIHRoaXMub25DaGlsZHJlbkNoYW5nZShiZWdpbkluZGV4KTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgcmVtb3ZlZC5sZW5ndGg7ICsraSQxKSB7XHJcbiAgICAgICAgICAgICAgICAvLyByZW1vdmVkW2kkMV0uZW1pdCgncmVtb3ZlZCcsIHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KEV2ZW50XzEuRXZlbnQuZ2V0RXZlbnQoXCJjaGlsZFJlbW92ZWRcIikpO1xyXG4gICAgICAgICAgICAgICAgLy8gdGhpcy5lbWl0KCdjaGlsZFJlbW92ZWQnLCByZW1vdmVkW2kkMV0sIHRoaXMsIGkkMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHJlbW92ZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHJhbmdlID09PSAwICYmIHRoaXMuY2hpbGRyZW4ubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3JlbW92ZUNoaWxkcmVuOiBudW1lcmljIHZhbHVlcyBhcmUgb3V0c2lkZSB0aGUgYWNjZXB0YWJsZSByYW5nZS4nKTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogU29ydHMgY2hpbGRyZW4gYnkgekluZGV4LiBQcmV2aW91cyBvcmRlciBpcyBtYW50YWluZWQgZm9yIDIgY2hpbGRyZW4gd2l0aCB0aGUgc2FtZSB6SW5kZXguXHJcbiAgICAgKi9cclxuICAgIHNvcnRDaGlsZHJlbigpIHtcclxuICAgICAgICB2YXIgc29ydFJlcXVpcmVkID0gZmFsc2U7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGogPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGo7ICsraSkge1xyXG4gICAgICAgICAgICB2YXIgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldO1xyXG4gICAgICAgICAgICBjaGlsZC5fbGFzdFNvcnRlZEluZGV4ID0gaTtcclxuICAgICAgICAgICAgaWYgKCFzb3J0UmVxdWlyZWQgJiYgY2hpbGQuekluZGV4ICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBzb3J0UmVxdWlyZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzb3J0UmVxdWlyZWQgJiYgdGhpcy5jaGlsZHJlbi5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW4uc29ydChDb250YWluZXIuc29ydENoaWxkcmVuKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zb3J0RGlydHkgPSBmYWxzZTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyB0aGUgdHJhbnNmb3JtIG9uIGFsbCBjaGlsZHJlbiBvZiB0aGlzIGNvbnRhaW5lciBmb3IgcmVuZGVyaW5nXHJcbiAgICAgKi9cclxuICAgIHVwZGF0ZVRyYW5zZm9ybSgpIHtcclxuICAgICAgICBpZiAodGhpcy5zb3J0YWJsZUNoaWxkcmVuICYmIHRoaXMuc29ydERpcnR5KSB7XHJcbiAgICAgICAgICAgIHRoaXMuc29ydENoaWxkcmVuKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2JvdW5kc0lEKys7XHJcbiAgICAgICAgdGhpcy50cmFuc2Zvcm0udXBkYXRlVHJhbnNmb3JtKHRoaXMucGFyZW50LnRyYW5zZm9ybSk7XHJcbiAgICAgICAgLy8gVE9ETzogY2hlY2sgcmVuZGVyIGZsYWdzLCBob3cgdG8gcHJvY2VzcyBzdHVmZiBoZXJlXHJcbiAgICAgICAgdGhpcy53b3JsZEFscGhhID0gdGhpcy5hbHBoYSAqIHRoaXMucGFyZW50LndvcmxkQWxwaGE7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGogPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGo7ICsraSkge1xyXG4gICAgICAgICAgICB2YXIgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldO1xyXG4gICAgICAgICAgICBpZiAoY2hpbGQudmlzaWJsZSkge1xyXG4gICAgICAgICAgICAgICAgY2hpbGQudXBkYXRlVHJhbnNmb3JtKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFJlY2FsY3VsYXRlcyB0aGUgYm91bmRzIG9mIHRoZSBjb250YWluZXIuXHJcbiAgICAgKlxyXG4gICAgICovXHJcbiAgICBjYWxjdWxhdGVCb3VuZHMoKSB7XHJcbiAgICAgICAgdGhpcy5fYm91bmRzLmNsZWFyKCk7XHJcbiAgICAgICAgdGhpcy5fY2FsY3VsYXRlQm91bmRzKCk7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV07XHJcbiAgICAgICAgICAgIGlmICghY2hpbGQudmlzaWJsZSB8fCAhY2hpbGQucmVuZGVyYWJsZSkge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2hpbGQuY2FsY3VsYXRlQm91bmRzKCk7XHJcbiAgICAgICAgICAgIC8vIFRPRE86IGZpbHRlcittYXNrLCBuZWVkIHRvIG1hc2sgYm90aCBzb21laG93XHJcbiAgICAgICAgICAgIGlmIChjaGlsZC5fbWFzaykge1xyXG4gICAgICAgICAgICAgICAgY2hpbGQuX21hc2suY2FsY3VsYXRlQm91bmRzKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9ib3VuZHMuYWRkQm91bmRzTWFzayhjaGlsZC5fYm91bmRzLCBjaGlsZC5fbWFzay5fYm91bmRzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjaGlsZC5maWx0ZXJBcmVhKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9ib3VuZHMuYWRkQm91bmRzQXJlYShjaGlsZC5fYm91bmRzLCBjaGlsZC5maWx0ZXJBcmVhKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2JvdW5kcy5hZGRCb3VuZHMoY2hpbGQuX2JvdW5kcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fbGFzdEJvdW5kc0lEID0gdGhpcy5fYm91bmRzSUQ7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFJlY2FsY3VsYXRlcyB0aGUgYm91bmRzIG9mIHRoZSBvYmplY3QuIE92ZXJyaWRlIHRoaXMgdG9cclxuICAgICAqIGNhbGN1bGF0ZSB0aGUgYm91bmRzIG9mIHRoZSBzcGVjaWZpYyBvYmplY3QgKG5vdCBpbmNsdWRpbmcgY2hpbGRyZW4pLlxyXG4gICAgICpcclxuICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAqL1xyXG4gICAgX2NhbGN1bGF0ZUJvdW5kcygpIHtcclxuICAgICAgICAvLyBGSUxMIElOLy9cclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogUmVuZGVycyB0aGUgb2JqZWN0IHVzaW5nIHRoZSBXZWJHTCByZW5kZXJlclxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7UElYSS5SZW5kZXJlcn0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXJcclxuICAgICAqL1xyXG4gICAgcmVuZGVyKHJlbmRlcmVyKSB7XHJcbiAgICAgICAgLy8gaWYgdGhlIG9iamVjdCBpcyBub3QgdmlzaWJsZSBvciB0aGUgYWxwaGEgaXMgMCB0aGVuIG5vIG5lZWQgdG8gcmVuZGVyIHRoaXMgZWxlbWVudFxyXG4gICAgICAgIGlmICghdGhpcy52aXNpYmxlIHx8IHRoaXMud29ybGRBbHBoYSA8PSAwIHx8ICF0aGlzLnJlbmRlcmFibGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBkbyBhIHF1aWNrIGNoZWNrIHRvIHNlZSBpZiB0aGlzIGVsZW1lbnQgaGFzIGEgbWFzayBvciBhIGZpbHRlci5cclxuICAgICAgICBpZiAodGhpcy5fbWFzayB8fCB0aGlzLmZpbHRlcnMpIHtcclxuICAgICAgICAgICAgdGhpcy5yZW5kZXJBZHZhbmNlZChyZW5kZXJlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLl9yZW5kZXIocmVuZGVyZXIpO1xyXG4gICAgICAgICAgICAvLyBzaW1wbGUgcmVuZGVyIGNoaWxkcmVuIVxyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaiA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgajsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNoaWxkcmVuW2ldLnJlbmRlcihyZW5kZXJlcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFJlbmRlciB0aGUgb2JqZWN0IHVzaW5nIHRoZSBXZWJHTCByZW5kZXJlciBhbmQgYWR2YW5jZWQgZmVhdHVyZXMuXHJcbiAgICAgKlxyXG4gICAgICogQHByb3RlY3RlZFxyXG4gICAgICogQHBhcmFtIHtQSVhJLlJlbmRlcmVyfSByZW5kZXJlciAtIFRoZSByZW5kZXJlclxyXG4gICAgICovXHJcbiAgICByZW5kZXJBZHZhbmNlZChyZW5kZXJlcikge1xyXG4gICAgICAgIHJlbmRlcmVyLmJhdGNoLmZsdXNoKCk7XHJcbiAgICAgICAgdmFyIGZpbHRlcnMgPSB0aGlzLmZpbHRlcnM7XHJcbiAgICAgICAgdmFyIG1hc2sgPSB0aGlzLl9tYXNrO1xyXG4gICAgICAgIC8vIHB1c2ggZmlsdGVyIGZpcnN0IGFzIHdlIG5lZWQgdG8gZW5zdXJlIHRoZSBzdGVuY2lsIGJ1ZmZlciBpcyBjb3JyZWN0IGZvciBhbnkgbWFza2luZ1xyXG4gICAgICAgIGlmIChmaWx0ZXJzKSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5fZW5hYmxlZEZpbHRlcnMpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2VuYWJsZWRGaWx0ZXJzID0gW107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fZW5hYmxlZEZpbHRlcnMubGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaWx0ZXJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZmlsdGVyc1tpXS5lbmFibGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZW5hYmxlZEZpbHRlcnMucHVzaChmaWx0ZXJzW2ldKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy5fZW5hYmxlZEZpbHRlcnMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICByZW5kZXJlci5maWx0ZXIucHVzaCh0aGlzLCB0aGlzLl9lbmFibGVkRmlsdGVycyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG1hc2spIHtcclxuICAgICAgICAgICAgcmVuZGVyZXIubWFzay5wdXNoKHRoaXMsIHRoaXMuX21hc2spO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBhZGQgdGhpcyBvYmplY3QgdG8gdGhlIGJhdGNoLCBvbmx5IHJlbmRlcmVkIGlmIGl0IGhhcyBhIHRleHR1cmUuXHJcbiAgICAgICAgdGhpcy5fcmVuZGVyKHJlbmRlcmVyKTtcclxuICAgICAgICAvLyBub3cgbG9vcCB0aHJvdWdoIHRoZSBjaGlsZHJlbiBhbmQgbWFrZSBzdXJlIHRoZXkgZ2V0IHJlbmRlcmVkXHJcbiAgICAgICAgZm9yICh2YXIgaSQxID0gMCwgaiA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpJDEgPCBqOyBpJDErKykge1xyXG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuW2kkMV0ucmVuZGVyKHJlbmRlcmVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVuZGVyZXIuYmF0Y2guZmx1c2goKTtcclxuICAgICAgICBpZiAobWFzaykge1xyXG4gICAgICAgICAgICByZW5kZXJlci5tYXNrLnBvcCh0aGlzLCB0aGlzLl9tYXNrKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGZpbHRlcnMgJiYgdGhpcy5fZW5hYmxlZEZpbHRlcnMgJiYgdGhpcy5fZW5hYmxlZEZpbHRlcnMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJlbmRlcmVyLmZpbHRlci5wb3AoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFRvIGJlIG92ZXJyaWRkZW4gYnkgdGhlIHN1YmNsYXNzZXMuXHJcbiAgICAgKlxyXG4gICAgICogQHByb3RlY3RlZFxyXG4gICAgICogQHBhcmFtIHtQSVhJLlJlbmRlcmVyfSByZW5kZXJlciAtIFRoZSByZW5kZXJlclxyXG4gICAgICovXHJcbiAgICBfcmVuZGVyKHJlbmRlcmVyKSB7XHJcbiAgICAgICAgLy8gdGhpcyBpcyB3aGVyZSBjb250ZW50IGl0c2VsZiBnZXRzIHJlbmRlcmVkLi4uXHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgYWxsIGludGVybmFsIHJlZmVyZW5jZXMgYW5kIGxpc3RlbmVycyBhcyB3ZWxsIGFzIHJlbW92ZXMgY2hpbGRyZW4gZnJvbSB0aGUgZGlzcGxheSBsaXN0LlxyXG4gICAgICogRG8gbm90IHVzZSBhIENvbnRhaW5lciBhZnRlciBjYWxsaW5nIGBkZXN0cm95YC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdHxib29sZWFufSBbb3B0aW9uc10gLSBPcHRpb25zIHBhcmFtZXRlci4gQSBib29sZWFuIHdpbGwgYWN0IGFzIGlmIGFsbCBvcHRpb25zXHJcbiAgICAgKiAgaGF2ZSBiZWVuIHNldCB0byB0aGF0IHZhbHVlXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmNoaWxkcmVuPWZhbHNlXSAtIGlmIHNldCB0byB0cnVlLCBhbGwgdGhlIGNoaWxkcmVuIHdpbGwgaGF2ZSB0aGVpciBkZXN0cm95XHJcbiAgICAgKiAgbWV0aG9kIGNhbGxlZCBhcyB3ZWxsLiAnb3B0aW9ucycgd2lsbCBiZSBwYXNzZWQgb24gdG8gdGhvc2UgY2FsbHMuXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRleHR1cmU9ZmFsc2VdIC0gT25seSB1c2VkIGZvciBjaGlsZCBTcHJpdGVzIGlmIG9wdGlvbnMuY2hpbGRyZW4gaXMgc2V0IHRvIHRydWVcclxuICAgICAqICBTaG91bGQgaXQgZGVzdHJveSB0aGUgdGV4dHVyZSBvZiB0aGUgY2hpbGQgc3ByaXRlXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmJhc2VUZXh0dXJlPWZhbHNlXSAtIE9ubHkgdXNlZCBmb3IgY2hpbGQgU3ByaXRlcyBpZiBvcHRpb25zLmNoaWxkcmVuIGlzIHNldCB0byB0cnVlXHJcbiAgICAgKiAgU2hvdWxkIGl0IGRlc3Ryb3kgdGhlIGJhc2UgdGV4dHVyZSBvZiB0aGUgY2hpbGQgc3ByaXRlXHJcbiAgICAgKi9cclxuICAgIGRlc3Ryb3kob3B0aW9ucykge1xyXG4gICAgICAgIHN1cGVyLmRlc3Ryb3kob3B0aW9ucyk7XHJcbiAgICAgICAgdGhpcy5zb3J0RGlydHkgPSBmYWxzZTtcclxuICAgICAgICB2YXIgZGVzdHJveUNoaWxkcmVuID0gdHlwZW9mIG9wdGlvbnMgPT09ICdib29sZWFuJyA/IG9wdGlvbnMgOiBvcHRpb25zICYmIG9wdGlvbnMuY2hpbGRyZW47XHJcbiAgICAgICAgdmFyIG9sZENoaWxkcmVuID0gdGhpcy5yZW1vdmVDaGlsZHJlbigwLCB0aGlzLmNoaWxkcmVuLmxlbmd0aCk7XHJcbiAgICAgICAgaWYgKGRlc3Ryb3lDaGlsZHJlbikge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9sZENoaWxkcmVuLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICBvbGRDaGlsZHJlbltpXS5kZXN0cm95KG9wdGlvbnMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgd2lkdGggb2YgdGhlIENvbnRhaW5lciwgc2V0dGluZyB0aGlzIHdpbGwgYWN0dWFsbHkgbW9kaWZ5IHRoZSBzY2FsZSB0byBhY2hpZXZlIHRoZSB2YWx1ZSBzZXRcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIGdldCB3aWR0aCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zY2FsZS54ICogdGhpcy5nZXRMb2NhbEJvdW5kcygpLndpZHRoO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgc2V0IHdpZHRoKHZhbHVlKSB7XHJcbiAgICAgICAgdmFyIHdpZHRoID0gdGhpcy5nZXRMb2NhbEJvdW5kcygpLndpZHRoO1xyXG4gICAgICAgIGlmICh3aWR0aCAhPT0gMCkge1xyXG4gICAgICAgICAgICB0aGlzLnNjYWxlLnggPSB2YWx1ZSAvIHdpZHRoO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5zY2FsZS54ID0gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fd2lkdGggPSB2YWx1ZTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGhlaWdodCBvZiB0aGUgQ29udGFpbmVyLCBzZXR0aW5nIHRoaXMgd2lsbCBhY3R1YWxseSBtb2RpZnkgdGhlIHNjYWxlIHRvIGFjaGlldmUgdGhlIHZhbHVlIHNldFxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgZ2V0IGhlaWdodCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zY2FsZS55ICogdGhpcy5nZXRMb2NhbEJvdW5kcygpLmhlaWdodDtcclxuICAgIH1cclxuICAgIDtcclxuICAgIHNldCBoZWlnaHQodmFsdWUpIHtcclxuICAgICAgICB2YXIgaGVpZ2h0ID0gdGhpcy5nZXRMb2NhbEJvdW5kcygpLmhlaWdodDtcclxuICAgICAgICBpZiAoaGVpZ2h0ICE9PSAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2NhbGUueSA9IHZhbHVlIC8gaGVpZ2h0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5zY2FsZS55ID0gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5faGVpZ2h0ID0gdmFsdWU7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICBzdGF0aWMgc29ydENoaWxkcmVuKGEsIGIpIHtcclxuICAgICAgICBpZiAoYS56SW5kZXggPT09IGIuekluZGV4KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhLl9sYXN0U29ydGVkSW5kZXggLSBiLl9sYXN0U29ydGVkSW5kZXg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhLnpJbmRleCAtIGIuekluZGV4O1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuQ29udGFpbmVyID0gQ29udGFpbmVyO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBTeXN0ZW1fMSA9IHJlcXVpcmUoXCIuL1N5c3RlbVwiKTtcclxuY29uc3QgRGlzcGxheVNldHRpbmdzXzEgPSByZXF1aXJlKFwiLi9EaXNwbGF5U2V0dGluZ3NcIik7XHJcbmNsYXNzIENvbnRleHRTeXN0ZW0gZXh0ZW5kcyBTeXN0ZW1fMS5TeXN0ZW0ge1xyXG4gICAgY29uc3RydWN0b3IocmVuZGVyZXIpIHtcclxuICAgICAgICBzdXBlcihyZW5kZXJlcik7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRWl0aGVyIDEgb3IgMiB0byByZWZsZWN0IHRoZSBXZWJHTCB2ZXJzaW9uIGJlaW5nIHVzZWRcclxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgICAgICogQHJlYWRvbmx5XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy53ZWJHTFZlcnNpb24gPSAxO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEV4dGVuc2lvbnMgYmVpbmcgdXNlZFxyXG4gICAgICAgICAqIEBtZW1iZXIge29iamVjdH1cclxuICAgICAgICAgKiBAcmVhZG9ubHlcclxuICAgICAgICAgKiBAcHJvcGVydHkge1dFQkdMX2RyYXdfYnVmZmVyc30gZHJhd0J1ZmZlcnMgLSBXZWJHTCB2MSBleHRlbnNpb25cclxuICAgICAgICAgKiBAcHJvcGVydHkge1dFQkdMX2RlcHRoX3RleHR1cmV9IGRlcHRoVGV4dHVyZSAtIFdlYkdMIHYxIGV4dGVuc2lvblxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7T0VTX3RleHR1cmVfZmxvYXR9IGZsb2F0VGV4dHVyZSAtIFdlYkdMIHYxIGV4dGVuc2lvblxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7V0VCR0xfbG9zZV9jb250ZXh0fSBsb3NlQ29udGV4dCAtIFdlYkdMIHYxIGV4dGVuc2lvblxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7T0VTX3ZlcnRleF9hcnJheV9vYmplY3R9IHZlcnRleEFycmF5T2JqZWN0IC0gV2ViR0wgdjEgZXh0ZW5zaW9uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5leHRlbnNpb25zID0ge307XHJcbiAgICAgICAgLy8gQmluZCBmdW5jdGlvbnNcclxuICAgICAgICB0aGlzLmhhbmRsZUNvbnRleHRMb3N0ID0gdGhpcy5oYW5kbGVDb250ZXh0TG9zdC5iaW5kKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuaGFuZGxlQ29udGV4dFJlc3RvcmVkID0gdGhpcy5oYW5kbGVDb250ZXh0UmVzdG9yZWQuYmluZCh0aGlzKTtcclxuICAgICAgICByZW5kZXJlci52aWV3LmFkZEV2ZW50TGlzdGVuZXIoJ3dlYmdsY29udGV4dGxvc3QnLCB0aGlzLmhhbmRsZUNvbnRleHRMb3N0LCBmYWxzZSk7XHJcbiAgICAgICAgcmVuZGVyZXIudmlldy5hZGRFdmVudExpc3RlbmVyKCd3ZWJnbGNvbnRleHRyZXN0b3JlZCcsIHRoaXMuaGFuZGxlQ29udGV4dFJlc3RvcmVkLCBmYWxzZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIGB0cnVlYCBpZiB0aGUgY29udGV4dCBpcyBsb3N0XHJcbiAgICAgKiBAbWVtYmVyIHtib29sZWFufVxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKi9cclxuICAgIGdldCBpc0xvc3QoKSB7XHJcbiAgICAgICAgcmV0dXJuICghdGhpcy5nbCB8fCB0aGlzLmdsLmlzQ29udGV4dExvc3QoKSk7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIEhhbmRsZSB0aGUgY29udGV4dCBjaGFuZ2UgZXZlbnRcclxuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCBuZXcgd2ViZ2wgY29udGV4dFxyXG4gICAgICovXHJcbiAgICBjb250ZXh0Q2hhbmdlKGdsKSB7XHJcbiAgICAgICAgdGhpcy5nbCA9IGdsO1xyXG4gICAgICAgIC8vIHJlc3RvcmUgYSBjb250ZXh0IGlmIGl0IHdhcyBwcmV2aW91c2x5IGxvc3RcclxuICAgICAgICBpZiAoZ2wuaXNDb250ZXh0TG9zdCgpICYmIGdsLmdldEV4dGVuc2lvbignV0VCR0xfbG9zZV9jb250ZXh0JykpIHtcclxuICAgICAgICAgICAgZ2wuZ2V0RXh0ZW5zaW9uKCdXRUJHTF9sb3NlX2NvbnRleHQnKS5yZXN0b3JlQ29udGV4dCgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogSW5pdGlhbGl6ZSB0aGUgY29udGV4dFxyXG4gICAgICpcclxuICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCAtIFdlYkdMIGNvbnRleHRcclxuICAgICAqL1xyXG4gICAgaW5pdEZyb21Db250ZXh0KGdsKSB7XHJcbiAgICAgICAgdGhpcy5nbCA9IGdsO1xyXG4gICAgICAgIHRoaXMudmFsaWRhdGVDb250ZXh0KGdsKTtcclxuICAgICAgICB0aGlzLnJlbmRlcmVyLmdsID0gZ2w7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJlci5DT05URVhUX1VJRCA9IENvbnRleHRTeXN0ZW0uQ09OVEVYVF9VSUQrKztcclxuICAgICAgICAvLyB0aGlzLmRpc3BhdGNoRXZlbnQoRXZlbnQuZ2V0RXZlbnQoXCJjb250ZXh0Y2hhbmdlXCIpKVxyXG4gICAgICAgIHRoaXMucmVuZGVyZXIucnVubmVycy5jb250ZXh0Q2hhbmdlLnJ1bihnbCk7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIEluaXRpYWxpemUgZnJvbSBjb250ZXh0IG9wdGlvbnNcclxuICAgICAqXHJcbiAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9IVE1MQ2FudmFzRWxlbWVudC9nZXRDb250ZXh0XHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyAtIGNvbnRleHQgYXR0cmlidXRlc1xyXG4gICAgICovXHJcbiAgICBpbml0RnJvbU9wdGlvbnMob3B0aW9ucykge1xyXG4gICAgICAgIHZhciBnbCA9IHRoaXMuY3JlYXRlQ29udGV4dCh0aGlzLnJlbmRlcmVyLnZpZXcsIG9wdGlvbnMpO1xyXG4gICAgICAgIHRoaXMuaW5pdEZyb21Db250ZXh0KGdsKTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogSGVscGVyIGNsYXNzIHRvIGNyZWF0ZSBhIFdlYkdMIENvbnRleHRcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY2FudmFzIHtIVE1MQ2FudmFzRWxlbWVudH0gdGhlIGNhbnZhcyBlbGVtZW50IHRoYXQgd2Ugd2lsbCBnZXQgdGhlIGNvbnRleHQgZnJvbVxyXG4gICAgICogQHBhcmFtIG9wdGlvbnMge29iamVjdH0gQW4gb3B0aW9ucyBvYmplY3QgdGhhdCBnZXRzIHBhc3NlZCBpbiB0byB0aGUgY2FudmFzIGVsZW1lbnQgY29udGFpbmluZyB0aGUgY29udGV4dCBhdHRyaWJ1dGVzXHJcbiAgICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0FQSS9IVE1MQ2FudmFzRWxlbWVudC9nZXRDb250ZXh0XHJcbiAgICAgKiBAcmV0dXJuIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IHRoZSBXZWJHTCBjb250ZXh0XHJcbiAgICAgKi9cclxuICAgIGNyZWF0ZUNvbnRleHQoY2FudmFzLCBvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIGdsO1xyXG4gICAgICAgIGlmIChEaXNwbGF5U2V0dGluZ3NfMS5EaXNwbGF5U2V0dGluZ3MuUFJFRkVSX0VOViA+PSBEaXNwbGF5U2V0dGluZ3NfMS5EaXNwbGF5U2V0dGluZ3MuRU5WLldFQkdMMikge1xyXG4gICAgICAgICAgICBnbCA9IGNhbnZhcy5nZXRDb250ZXh0KCd3ZWJnbDInLCBvcHRpb25zKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGdsKSB7XHJcbiAgICAgICAgICAgIHRoaXMud2ViR0xWZXJzaW9uID0gMjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMud2ViR0xWZXJzaW9uID0gMTtcclxuICAgICAgICAgICAgZ2wgPSBjYW52YXMuZ2V0Q29udGV4dCgnd2ViZ2wnLCBvcHRpb25zKVxyXG4gICAgICAgICAgICAgICAgfHwgY2FudmFzLmdldENvbnRleHQoJ2V4cGVyaW1lbnRhbC13ZWJnbCcsIG9wdGlvbnMpO1xyXG4gICAgICAgICAgICBpZiAoIWdsKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBmYWlsLCBub3QgYWJsZSB0byBnZXQgYSBjb250ZXh0XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IFdlYkdMLiBUcnkgdXNpbmcgdGhlIGNhbnZhcyByZW5kZXJlcicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZ2wgPSBnbDtcclxuICAgICAgICB0aGlzLmdldEV4dGVuc2lvbnMoKTtcclxuICAgICAgICByZXR1cm4gZ2w7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIEF1dG8tcG9wdWxhdGUgdGhlIGV4dGVuc2lvbnNcclxuICAgICAqXHJcbiAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgKi9cclxuICAgIGdldEV4dGVuc2lvbnMoKSB7XHJcbiAgICAgICAgLy8gdGltZSB0byBzZXQgdXAgZGVmYXVsdCBleHRlbnNpb25zIHRoYXQgUGl4aSB1c2VzLlxyXG4gICAgICAgIHZhciByZWYgPSB0aGlzO1xyXG4gICAgICAgIHZhciBnbCA9IHJlZi5nbDtcclxuICAgICAgICBpZiAodGhpcy53ZWJHTFZlcnNpb24gPT09IDEpIHtcclxuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLmV4dGVuc2lvbnMsIHtcclxuICAgICAgICAgICAgICAgIGRyYXdCdWZmZXJzOiBnbC5nZXRFeHRlbnNpb24oJ1dFQkdMX2RyYXdfYnVmZmVycycpLFxyXG4gICAgICAgICAgICAgICAgZGVwdGhUZXh0dXJlOiBnbC5nZXRFeHRlbnNpb24oJ1dFQktJVF9XRUJHTF9kZXB0aF90ZXh0dXJlJyksXHJcbiAgICAgICAgICAgICAgICBmbG9hdFRleHR1cmU6IGdsLmdldEV4dGVuc2lvbignT0VTX3RleHR1cmVfZmxvYXQnKSxcclxuICAgICAgICAgICAgICAgIGxvc2VDb250ZXh0OiBnbC5nZXRFeHRlbnNpb24oJ1dFQkdMX2xvc2VfY29udGV4dCcpLFxyXG4gICAgICAgICAgICAgICAgdmVydGV4QXJyYXlPYmplY3Q6IGdsLmdldEV4dGVuc2lvbignT0VTX3ZlcnRleF9hcnJheV9vYmplY3QnKVxyXG4gICAgICAgICAgICAgICAgICAgIHx8IGdsLmdldEV4dGVuc2lvbignTU9aX09FU192ZXJ0ZXhfYXJyYXlfb2JqZWN0JylcclxuICAgICAgICAgICAgICAgICAgICB8fCBnbC5nZXRFeHRlbnNpb24oJ1dFQktJVF9PRVNfdmVydGV4X2FycmF5X29iamVjdCcpLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gd2UgZG9uJ3QgdXNlIGFueSBzcGVjaWZpYyBXZWJHTCAyIG9uZXMgeWV0IVxyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBIYW5kbGVzIGEgbG9zdCB3ZWJnbCBjb250ZXh0XHJcbiAgICAgKlxyXG4gICAgICogQHByb3RlY3RlZFxyXG4gICAgICogQHBhcmFtIHtXZWJHTENvbnRleHRFdmVudH0gZXZlbnQgLSBUaGUgY29udGV4dCBsb3N0IGV2ZW50LlxyXG4gICAgICovXHJcbiAgICBoYW5kbGVDb250ZXh0TG9zdChldmVudCkge1xyXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIEhhbmRsZXMgYSByZXN0b3JlZCB3ZWJnbCBjb250ZXh0XHJcbiAgICAgKlxyXG4gICAgICogQHByb3RlY3RlZFxyXG4gICAgICovXHJcbiAgICBoYW5kbGVDb250ZXh0UmVzdG9yZWQoKSB7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJlci5ydW5uZXJzLmNvbnRleHRDaGFuZ2UucnVuKHRoaXMuZ2wpO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgZGVzdHJveSgpIHtcclxuICAgICAgICB2YXIgdmlldyA9IHRoaXMucmVuZGVyZXIudmlldztcclxuICAgICAgICAvLyByZW1vdmUgbGlzdGVuZXJzXHJcbiAgICAgICAgdmlldy5yZW1vdmVFdmVudExpc3RlbmVyKCd3ZWJnbGNvbnRleHRsb3N0JywgdGhpcy5oYW5kbGVDb250ZXh0TG9zdCk7XHJcbiAgICAgICAgdmlldy5yZW1vdmVFdmVudExpc3RlbmVyKCd3ZWJnbGNvbnRleHRyZXN0b3JlZCcsIHRoaXMuaGFuZGxlQ29udGV4dFJlc3RvcmVkKTtcclxuICAgICAgICB0aGlzLmdsLnVzZVByb2dyYW0obnVsbCk7XHJcbiAgICAgICAgaWYgKHRoaXMuZXh0ZW5zaW9ucy5sb3NlQ29udGV4dCkge1xyXG4gICAgICAgICAgICB0aGlzLmV4dGVuc2lvbnMubG9zZUNvbnRleHQubG9zZUNvbnRleHQoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIEhhbmRsZSB0aGUgcG9zdC1yZW5kZXIgcnVubmVyIGV2ZW50XHJcbiAgICAgKlxyXG4gICAgICogQHByb3RlY3RlZFxyXG4gICAgICovXHJcbiAgICBwb3N0cmVuZGVyKCkge1xyXG4gICAgICAgIHRoaXMuZ2wuZmx1c2goKTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogVmFsaWRhdGUgY29udGV4dFxyXG4gICAgICpcclxuICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCAtIFJlbmRlciBjb250ZXh0XHJcbiAgICAgKi9cclxuICAgIHZhbGlkYXRlQ29udGV4dChnbCkge1xyXG4gICAgICAgIHZhciBhdHRyaWJ1dGVzID0gZ2wuZ2V0Q29udGV4dEF0dHJpYnV0ZXMoKTtcclxuICAgICAgICAvLyB0aGlzIGlzIGdvaW5nIHRvIGJlIGZhaXJseSBzaW1wbGUgZm9yIG5vdy4uIGJ1dCBhdCBsZWFzdCB3ZSBoYXZlIHJvb20gdG8gZ3JvdyFcclxuICAgICAgICBpZiAoIWF0dHJpYnV0ZXMuc3RlbmNpbCkge1xyXG4gICAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXHJcbiAgICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWNvbnNvbGUgKi9cclxuICAgICAgICAgICAgY29uc29sZS53YXJuKCdQcm92aWRlZCBXZWJHTCBjb250ZXh0IGRvZXMgbm90IGhhdmUgYSBzdGVuY2lsIGJ1ZmZlciwgbWFza3MgbWF5IG5vdCByZW5kZXIgY29ycmVjdGx5Jyk7XHJcbiAgICAgICAgICAgIC8qIGVzbGludC1lbmFibGUgbm8tY29uc29sZSAqL1xyXG4gICAgICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4gKi9cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICA7XHJcbn1cclxuQ29udGV4dFN5c3RlbS5DT05URVhUX1VJRCA9IDA7XHJcbmV4cG9ydHMuQ29udGV4dFN5c3RlbSA9IENvbnRleHRTeXN0ZW07XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNsYXNzIENvdW50TGltaXRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihtYXhJdGVtc1BlckZyYW1lKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRoZSBtYXhpbXVtIG51bWJlciBvZiBpdGVtcyB0aGF0IGNhbiBiZSBwcmVwYXJlZCBlYWNoIGZyYW1lLlxyXG4gICAgICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLm1heEl0ZW1zUGVyRnJhbWUgPSBtYXhJdGVtc1BlckZyYW1lO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBudW1iZXIgb2YgaXRlbXMgdGhhdCBjYW4gYmUgcHJlcGFyZWQgaW4gdGhlIGN1cnJlbnQgZnJhbWUuXHJcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuaXRlbXNMZWZ0ID0gMDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVzZXRzIGFueSBjb3VudGluZyBwcm9wZXJ0aWVzIHRvIHN0YXJ0IGZyZXNoIG9uIGEgbmV3IGZyYW1lLlxyXG4gICAgICovXHJcbiAgICBiZWdpbkZyYW1lKCkge1xyXG4gICAgICAgIHRoaXMuaXRlbXNMZWZ0ID0gdGhpcy5tYXhJdGVtc1BlckZyYW1lO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVja3MgdG8gc2VlIGlmIGFub3RoZXIgaXRlbSBjYW4gYmUgdXBsb2FkZWQuIFRoaXMgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIG9uY2UgcGVyIGl0ZW0uXHJcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBJZiB0aGUgaXRlbSBpcyBhbGxvd2VkIHRvIGJlIHVwbG9hZGVkLlxyXG4gICAgICovXHJcbiAgICBhbGxvd2VkVG9VcGxvYWQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaXRlbXNMZWZ0LS0gPiAwO1xyXG4gICAgfVxyXG4gICAgO1xyXG59XHJcbmV4cG9ydHMuQ291bnRMaW1pdGVyID0gQ291bnRMaW1pdGVyO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBBcnJheVJlc291cmNlXzEgPSByZXF1aXJlKFwiLi9BcnJheVJlc291cmNlXCIpO1xyXG5jb25zdCBXZWJHTFNldHRpbmdzXzEgPSByZXF1aXJlKFwiLi9XZWJHTFNldHRpbmdzXCIpO1xyXG5jbGFzcyBDdWJlUmVzb3VyY2UgZXh0ZW5kcyBBcnJheVJlc291cmNlXzEuQXJyYXlSZXNvdXJjZSB7XHJcbiAgICBjb25zdHJ1Y3Rvcihzb3VyY2UsIG9wdGlvbnMpIHtcclxuICAgICAgICBzdXBlcihzb3VyY2UsIG9wdGlvbnMpO1xyXG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG4gICAgICAgIGlmICh0aGlzLmxlbmd0aCAhPT0gQ3ViZVJlc291cmNlLlNJREVTKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigoXCJJbnZhbGlkIGxlbmd0aC4gR290IFwiICsgKHRoaXMubGVuZ3RoKSArIFwiLCBleHBlY3RlZCA2XCIpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBDdWJlUmVzb3VyY2UuU0lERVM7IGkrKykge1xyXG4gICAgICAgICAgICB0aGlzLml0ZW1zW2ldLnRhcmdldCA9IFdlYkdMU2V0dGluZ3NfMS5XZWJHTFNldHRpbmdzLlRBUkdFVFMuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YICsgaTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG9wdGlvbnMuYXV0b0xvYWQgIT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIHRoaXMubG9hZCgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWRkIGJpbmRpbmdcclxuICAgICAqXHJcbiAgICAgKiBAb3ZlcnJpZGVcclxuICAgICAqIEBwYXJhbSB7UElYSS5CYXNlVGV4dHVyZX0gYmFzZVRleHR1cmUgLSBwYXJlbnQgYmFzZSB0ZXh0dXJlXHJcbiAgICAgKi9cclxuICAgIGJpbmQoYmFzZVRleHR1cmUpIHtcclxuICAgICAgICBzdXBlci5iaW5kKGJhc2VUZXh0dXJlKTtcclxuICAgICAgICBiYXNlVGV4dHVyZS50YXJnZXQgPSBXZWJHTFNldHRpbmdzXzEuV2ViR0xTZXR0aW5ncy5UQVJHRVRTLlRFWFRVUkVfQ1VCRV9NQVA7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFVwbG9hZCB0aGUgcmVzb3VyY2VcclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpcyBzdWNjZXNzXHJcbiAgICAgKi9cclxuICAgIHVwbG9hZChyZW5kZXJlciwgYmFzZVRleHR1cmUsIGdsVGV4dHVyZSkge1xyXG4gICAgICAgIHZhciBkaXJ0eSA9IHRoaXMuaXRlbURpcnR5SWRzO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgQ3ViZVJlc291cmNlLlNJREVTOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIHNpZGUgPSB0aGlzLml0ZW1zW2ldO1xyXG4gICAgICAgICAgICBpZiAoZGlydHlbaV0gPCBzaWRlLmRpcnR5SWQpIHtcclxuICAgICAgICAgICAgICAgIGRpcnR5W2ldID0gc2lkZS5kaXJ0eUlkO1xyXG4gICAgICAgICAgICAgICAgaWYgKHNpZGUudmFsaWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBzaWRlLnJlc291cmNlLnVwbG9hZChyZW5kZXJlciwgc2lkZSwgZ2xUZXh0dXJlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIDtcclxufVxyXG4vKipcclxuKiBOdW1iZXIgb2YgdGV4dHVyZSBzaWRlcyB0byBzdG9yZSBmb3IgQ3ViZVJlc291cmNlc1xyXG4qXHJcbiogQG5hbWUgUElYSS5yZXNvdXJjZXMuQ3ViZVJlc291cmNlLlNJREVTXHJcbiogQHN0YXRpY1xyXG4qIEBtZW1iZXIge251bWJlcn1cclxuKiBAZGVmYXVsdCA2XHJcbiovXHJcbkN1YmVSZXNvdXJjZS5TSURFUyA9IDY7XHJcbmV4cG9ydHMuQ3ViZVJlc291cmNlID0gQ3ViZVJlc291cmNlO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBCdWZmZXJSZXNvdXJjZV8xID0gcmVxdWlyZShcIi4vQnVmZmVyUmVzb3VyY2VcIik7XHJcbmNsYXNzIERlcHRoUmVzb3VyY2UgZXh0ZW5kcyBCdWZmZXJSZXNvdXJjZV8xLkJ1ZmZlclJlc291cmNlIHtcclxuICAgIGNvbnN0cnVjdG9yKHNvdXJjZSwgb3B0aW9ucykge1xyXG4gICAgICAgIHN1cGVyKHNvdXJjZSwgb3B0aW9ucyk7XHJcbiAgICB9XHJcbiAgICB1cGxvYWQocmVuZGVyZXIsIGJhc2VUZXh0dXJlLCBnbFRleHR1cmUpIHtcclxuICAgICAgICB2YXIgZ2wgPSByZW5kZXJlci5nbDtcclxuICAgICAgICBnbC5waXhlbFN0b3JlaShnbC5VTlBBQ0tfUFJFTVVMVElQTFlfQUxQSEFfV0VCR0wsIGJhc2VUZXh0dXJlLnByZW11bHRpcGx5QWxwaGEpO1xyXG4gICAgICAgIGlmIChnbFRleHR1cmUud2lkdGggPT09IGJhc2VUZXh0dXJlLndpZHRoICYmIGdsVGV4dHVyZS5oZWlnaHQgPT09IGJhc2VUZXh0dXJlLmhlaWdodCkge1xyXG4gICAgICAgICAgICBnbC50ZXhTdWJJbWFnZTJEKGJhc2VUZXh0dXJlLnRhcmdldCwgMCwgMCwgMCwgYmFzZVRleHR1cmUud2lkdGgsIGJhc2VUZXh0dXJlLmhlaWdodCwgYmFzZVRleHR1cmUuZm9ybWF0LCBiYXNlVGV4dHVyZS50eXBlLCB0aGlzLmRhdGEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZ2xUZXh0dXJlLndpZHRoID0gYmFzZVRleHR1cmUud2lkdGg7XHJcbiAgICAgICAgICAgIGdsVGV4dHVyZS5oZWlnaHQgPSBiYXNlVGV4dHVyZS5oZWlnaHQ7XHJcbiAgICAgICAgICAgIGdsLnRleEltYWdlMkQoYmFzZVRleHR1cmUudGFyZ2V0LCAwLCBnbC5ERVBUSF9DT01QT05FTlQxNiwgLy8gTmVlZGVkIGZvciBkZXB0aCB0byByZW5kZXIgcHJvcGVybHkgaW4gd2ViZ2wyLjBcclxuICAgICAgICAgICAgYmFzZVRleHR1cmUud2lkdGgsIGJhc2VUZXh0dXJlLmhlaWdodCwgMCwgYmFzZVRleHR1cmUuZm9ybWF0LCBiYXNlVGV4dHVyZS50eXBlLCB0aGlzLmRhdGEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIDtcclxufVxyXG5leHBvcnRzLkRlcHRoUmVzb3VyY2UgPSBEZXB0aFJlc291cmNlO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBGaWx0ZXJfMSA9IHJlcXVpcmUoXCIuL0ZpbHRlclwiKTtcclxuY29uc3QgTWF0cml4XzEgPSByZXF1aXJlKFwiLi9NYXRyaXhcIik7XHJcbmNvbnN0IFBvaW50XzEgPSByZXF1aXJlKFwiLi9Qb2ludFwiKTtcclxuY2xhc3MgRGlzcGxhY2VtZW50RmlsdGVyIGV4dGVuZHMgRmlsdGVyXzEuRmlsdGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKHNwcml0ZSwgc2NhbGUgPSAxKSB7XHJcbiAgICAgICAgdmFyIG1hc2tNYXRyaXggPSBuZXcgTWF0cml4XzEuTWF0cml4KCk7XHJcbiAgICAgICAgc3ByaXRlLnJlbmRlcmFibGUgPSBmYWxzZTtcclxuICAgICAgICBzdXBlcihEaXNwbGFjZW1lbnRGaWx0ZXIudmVydGV4JDQsIERpc3BsYWNlbWVudEZpbHRlci5mcmFnbWVudCQ1LCB7IG1hcFNhbXBsZXI6IHNwcml0ZS5fdGV4dHVyZSwgZmlsdGVyTWF0cml4OiBtYXNrTWF0cml4LCBzY2FsZTogeyB4OiAxLCB5OiAxIH0sIHJvdGF0aW9uOiBuZXcgRmxvYXQzMkFycmF5KFsxLCAwLCAwLCAxXSksIH0pO1xyXG4gICAgICAgIHRoaXMubWFza1Nwcml0ZSA9IHNwcml0ZTtcclxuICAgICAgICB0aGlzLm1hc2tNYXRyaXggPSBtYXNrTWF0cml4O1xyXG4gICAgICAgIGlmIChzY2FsZSA9PT0gbnVsbCB8fCBzY2FsZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHNjYWxlID0gMjA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIHNjYWxlWCwgc2NhbGVZIGZvciBkaXNwbGFjZW1lbnRzXHJcbiAgICAgICAgICogQG1lbWJlciB7UElYSS5Qb2ludH1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnNjYWxlID0gbmV3IFBvaW50XzEuUG9pbnQoc2NhbGUsIHNjYWxlKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQXBwbGllcyB0aGUgZmlsdGVyLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7UElYSS5zeXN0ZW1zLkZpbHRlclN5c3RlbX0gZmlsdGVyTWFuYWdlciAtIFRoZSBtYW5hZ2VyLlxyXG4gICAgICogQHBhcmFtIHtQSVhJLlJlbmRlclRleHR1cmV9IGlucHV0IC0gVGhlIGlucHV0IHRhcmdldC5cclxuICAgICAqIEBwYXJhbSB7UElYSS5SZW5kZXJUZXh0dXJlfSBvdXRwdXQgLSBUaGUgb3V0cHV0IHRhcmdldC5cclxuICAgICAqL1xyXG4gICAgYXBwbHkoZmlsdGVyTWFuYWdlciwgaW5wdXQsIG91dHB1dCkge1xyXG4gICAgICAgIHRoaXMudW5pZm9ybXMuZmlsdGVyTWF0cml4ID0gZmlsdGVyTWFuYWdlci5jYWxjdWxhdGVTcHJpdGVNYXRyaXgodGhpcy5tYXNrTWF0cml4LCB0aGlzLm1hc2tTcHJpdGUpO1xyXG4gICAgICAgIHRoaXMudW5pZm9ybXMuc2NhbGUueCA9IHRoaXMuc2NhbGUueDtcclxuICAgICAgICB0aGlzLnVuaWZvcm1zLnNjYWxlLnkgPSB0aGlzLnNjYWxlLnk7XHJcbiAgICAgICAgLy8gRXh0cmFjdCByb3RhdGlvbiBmcm9tIHdvcmxkIHRyYW5zZm9ybVxyXG4gICAgICAgIHZhciB3dCA9IHRoaXMubWFza1Nwcml0ZS50cmFuc2Zvcm0ud29ybGRUcmFuc2Zvcm07XHJcbiAgICAgICAgdmFyIGxlblggPSBNYXRoLnNxcnQoKHd0LmEgKiB3dC5hKSArICh3dC5iICogd3QuYikpO1xyXG4gICAgICAgIHZhciBsZW5ZID0gTWF0aC5zcXJ0KCh3dC5jICogd3QuYykgKyAod3QuZCAqIHd0LmQpKTtcclxuICAgICAgICBpZiAobGVuWCAhPT0gMCAmJiBsZW5ZICE9PSAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMudW5pZm9ybXMucm90YXRpb25bMF0gPSB3dC5hIC8gbGVuWDtcclxuICAgICAgICAgICAgdGhpcy51bmlmb3Jtcy5yb3RhdGlvblsxXSA9IHd0LmIgLyBsZW5YO1xyXG4gICAgICAgICAgICB0aGlzLnVuaWZvcm1zLnJvdGF0aW9uWzJdID0gd3QuYyAvIGxlblk7XHJcbiAgICAgICAgICAgIHRoaXMudW5pZm9ybXMucm90YXRpb25bM10gPSB3dC5kIC8gbGVuWTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gZHJhdyB0aGUgZmlsdGVyLi4uXHJcbiAgICAgICAgZmlsdGVyTWFuYWdlci5hcHBseUZpbHRlcih0aGlzLCBpbnB1dCwgb3V0cHV0KTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIHRleHR1cmUgdXNlZCBmb3IgdGhlIGRpc3BsYWNlbWVudCBtYXAuIE11c3QgYmUgcG93ZXIgb2YgMiBzaXplZCB0ZXh0dXJlLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge1BJWEkuVGV4dHVyZX1cclxuICAgICAqL1xyXG4gICAgZ2V0IG1hcCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5tYXBTYW1wbGVyO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgc2V0IG1hcCh2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMudW5pZm9ybXMubWFwU2FtcGxlciA9IHZhbHVlO1xyXG4gICAgfVxyXG4gICAgO1xyXG59XHJcbkRpc3BsYWNlbWVudEZpbHRlci5mcmFnbWVudCQ1ID0gXCJ2YXJ5aW5nIHZlYzIgdkZpbHRlckNvb3JkO1xcclxcbnZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xcclxcblxcclxcbnVuaWZvcm0gdmVjMiBzY2FsZTtcXHJcXG51bmlmb3JtIG1hdDIgcm90YXRpb247XFxyXFxudW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXI7XFxyXFxudW5pZm9ybSBzYW1wbGVyMkQgbWFwU2FtcGxlcjtcXHJcXG5cXHJcXG51bmlmb3JtIGhpZ2hwIHZlYzQgaW5wdXRTaXplO1xcclxcbnVuaWZvcm0gdmVjNCBpbnB1dENsYW1wO1xcclxcblxcclxcbnZvaWQgbWFpbih2b2lkKVxcclxcbntcXHJcXG4gIHZlYzQgbWFwID0gIHRleHR1cmUyRChtYXBTYW1wbGVyLCB2RmlsdGVyQ29vcmQpO1xcclxcblxcclxcbiAgbWFwIC09IDAuNTtcXHJcXG4gIG1hcC54eSA9IHNjYWxlICogaW5wdXRTaXplLnp3ICogKHJvdGF0aW9uICogbWFwLnh5KTtcXHJcXG5cXHJcXG4gIGdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCh1U2FtcGxlciwgY2xhbXAodmVjMih2VGV4dHVyZUNvb3JkLnggKyBtYXAueCwgdlRleHR1cmVDb29yZC55ICsgbWFwLnkpLCBpbnB1dENsYW1wLnh5LCBpbnB1dENsYW1wLnp3KSk7XFxyXFxufVxcclxcblwiO1xyXG5EaXNwbGFjZW1lbnRGaWx0ZXIudmVydGV4JDQgPSBcImF0dHJpYnV0ZSB2ZWMyIGFWZXJ0ZXhQb3NpdGlvbjtcXHJcXG5cXHJcXG51bmlmb3JtIG1hdDMgcHJvamVjdGlvbk1hdHJpeDtcXHJcXG51bmlmb3JtIG1hdDMgZmlsdGVyTWF0cml4O1xcclxcblxcclxcbnZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xcclxcbnZhcnlpbmcgdmVjMiB2RmlsdGVyQ29vcmQ7XFxyXFxuXFxyXFxudW5pZm9ybSB2ZWM0IGlucHV0U2l6ZTtcXHJcXG51bmlmb3JtIHZlYzQgb3V0cHV0RnJhbWU7XFxyXFxuXFxyXFxudmVjNCBmaWx0ZXJWZXJ0ZXhQb3NpdGlvbiggdm9pZCApXFxyXFxue1xcclxcbiAgICB2ZWMyIHBvc2l0aW9uID0gYVZlcnRleFBvc2l0aW9uICogbWF4KG91dHB1dEZyYW1lLnp3LCB2ZWMyKDAuKSkgKyBvdXRwdXRGcmFtZS54eTtcXHJcXG5cXHJcXG4gICAgcmV0dXJuIHZlYzQoKHByb2plY3Rpb25NYXRyaXggKiB2ZWMzKHBvc2l0aW9uLCAxLjApKS54eSwgMC4wLCAxLjApO1xcclxcbn1cXHJcXG5cXHJcXG52ZWMyIGZpbHRlclRleHR1cmVDb29yZCggdm9pZCApXFxyXFxue1xcclxcbiAgICByZXR1cm4gYVZlcnRleFBvc2l0aW9uICogKG91dHB1dEZyYW1lLnp3ICogaW5wdXRTaXplLnp3KTtcXHJcXG59XFxyXFxuXFxyXFxudm9pZCBtYWluKHZvaWQpXFxyXFxue1xcclxcblxcdGdsX1Bvc2l0aW9uID0gZmlsdGVyVmVydGV4UG9zaXRpb24oKTtcXHJcXG5cXHR2VGV4dHVyZUNvb3JkID0gZmlsdGVyVGV4dHVyZUNvb3JkKCk7XFxyXFxuXFx0dkZpbHRlckNvb3JkID0gKCBmaWx0ZXJNYXRyaXggKiB2ZWMzKCB2VGV4dHVyZUNvb3JkLCAxLjApICApLnh5O1xcclxcbn1cXHJcXG5cIjtcclxuZXhwb3J0cy5EaXNwbGFjZW1lbnRGaWx0ZXIgPSBEaXNwbGFjZW1lbnRGaWx0ZXI7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IEV2ZW50RGlzcGF0Y2hlcl8xID0gcmVxdWlyZShcIi4vRXZlbnREaXNwYXRjaGVyXCIpO1xyXG5jb25zdCBSZWN0YW5nbGVfMSA9IHJlcXVpcmUoXCIuL1JlY3RhbmdsZVwiKTtcclxuY29uc3QgTWF0cml4XzEgPSByZXF1aXJlKFwiLi9NYXRyaXhcIik7XHJcbmNvbnN0IFJlbmRlclRleHR1cmVfMSA9IHJlcXVpcmUoXCIuL1JlbmRlclRleHR1cmVcIik7XHJcbmNvbnN0IEJhc2VUZXh0dXJlXzEgPSByZXF1aXJlKFwiLi9CYXNlVGV4dHVyZVwiKTtcclxuY29uc3QgVGV4dHVyZV8xID0gcmVxdWlyZShcIi4vVGV4dHVyZVwiKTtcclxuY29uc3QgQm91bmRzXzEgPSByZXF1aXJlKFwiLi9Cb3VuZHNcIik7XHJcbmNvbnN0IFRyYW5zZm9ybV8xID0gcmVxdWlyZShcIi4vVHJhbnNmb3JtXCIpO1xyXG5jb25zdCBQb2ludF8xID0gcmVxdWlyZShcIi4vUG9pbnRcIik7XHJcbmNvbnN0IE1hdGhTZXR0aW5nc18xID0gcmVxdWlyZShcIi4vTWF0aFNldHRpbmdzXCIpO1xyXG5jb25zdCBEaXNwbGF5U2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL0Rpc3BsYXlTZXR0aW5nc1wiKTtcclxuY2xhc3MgRGlzcGxheU9iamVjdCBleHRlbmRzIEV2ZW50RGlzcGF0Y2hlcl8xLkV2ZW50RGlzcGF0Y2hlciB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIC8qIVxyXG4gKiBAcGl4aS9taXhpbi1nZXQtY2hpbGQtYnktbmFtZSAtIHY1LjAuMC1yYy4zXHJcbiAqIENvbXBpbGVkIFdlZCwgMTAgQXByIDIwMTkgMDE6MjE6MTUgVVRDXHJcbiAqXHJcbiAqIEBwaXhpL21peGluLWdldC1jaGlsZC1ieS1uYW1lIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuICogaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZVxyXG4gKi9cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgaW5zdGFuY2UgbmFtZSBvZiB0aGUgb2JqZWN0LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQG1lbWJlcm9mIFBJWEkuRGlzcGxheU9iamVjdCNcclxuICAgICAgICAgKiBAbWVtYmVyIHtzdHJpbmd9IG5hbWVcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLm5hbWUgPSBudWxsO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqICBGbGFnIGZvciBpZiB0aGUgb2JqZWN0IGlzIGFjY2Vzc2libGUuIElmIHRydWUgQWNjZXNzaWJpbGl0eU1hbmFnZXIgd2lsbCBvdmVybGF5IGFcclxuICAgICAgICAgKiAgIHNoYWRvdyBkaXYgd2l0aCBhdHRyaWJ1dGVzIHNldFxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQG1lbWJlciB7Ym9vbGVhbn1cclxuICAgICAgICAgKiBAbWVtYmVyb2YgUElYSS5EaXNwbGF5T2JqZWN0I1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuYWNjZXNzaWJsZSA9IGZhbHNlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNldHMgdGhlIHRpdGxlIGF0dHJpYnV0ZSBvZiB0aGUgc2hhZG93IGRpdlxyXG4gICAgICAgICAqIElmIGFjY2Vzc2libGVUaXRsZSBBTkQgYWNjZXNzaWJsZUhpbnQgaGFzIG5vdCBiZWVuIHRoaXMgd2lsbCBkZWZhdWx0IHRvICdkaXNwbGF5T2JqZWN0IFt0YWJJbmRleF0nXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAbWVtYmVyIHs/c3RyaW5nfVxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBQSVhJLkRpc3BsYXlPYmplY3QjXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5hY2Nlc3NpYmxlVGl0bGUgPSBudWxsO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNldHMgdGhlIGFyaWEtbGFiZWwgYXR0cmlidXRlIG9mIHRoZSBzaGFkb3cgZGl2XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAbWVtYmVyIHtzdHJpbmd9XHJcbiAgICAgICAgICogQG1lbWJlcm9mIFBJWEkuRGlzcGxheU9iamVjdCNcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmFjY2Vzc2libGVIaW50ID0gbnVsbDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgICAgICogQG1lbWJlcm9mIFBJWEkuRGlzcGxheU9iamVjdCNcclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqIEB0b2RvIE5lZWRzIGRvY3MuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy50YWJJbmRleCA9IDA7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQG1lbWJlciB7Ym9vbGVhbn1cclxuICAgICAgICAgKiBAbWVtYmVyb2YgUElYSS5EaXNwbGF5T2JqZWN0I1xyXG4gICAgICAgICAqIEB0b2RvIE5lZWRzIGRvY3MuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5fYWNjZXNzaWJsZUFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XHJcbiAgICAgICAgICogQG1lbWJlcm9mIFBJWEkuRGlzcGxheU9iamVjdCNcclxuICAgICAgICAgKiBAdG9kbyBOZWVkcyBkb2NzLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuX2FjY2Vzc2libGVEaXYgPSBmYWxzZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAqIEVuYWJsZSBpbnRlcmFjdGlvbiBldmVudHMgZm9yIHRoZSBEaXNwbGF5T2JqZWN0LiBUb3VjaCwgcG9pbnRlciBhbmQgbW91c2VcclxuICAgICAgICAqIGV2ZW50cyB3aWxsIG5vdCBiZSBlbWl0dGVkIHVubGVzcyBgaW50ZXJhY3RpdmVgIGlzIHNldCB0byBgdHJ1ZWAuXHJcbiAgICAgICAgKlxyXG4gICAgICAgICogQGV4YW1wbGVcclxuICAgICAgICAqIGNvbnN0IHNwcml0ZSA9IG5ldyBQSVhJLlNwcml0ZSh0ZXh0dXJlKTtcclxuICAgICAgICAqIHNwcml0ZS5pbnRlcmFjdGl2ZSA9IHRydWU7XHJcbiAgICAgICAgKiBzcHJpdGUub24oJ3RhcCcsIChldmVudCkgPT4ge1xyXG4gICAgICAgICogICAgLy9oYW5kbGUgZXZlbnRcclxuICAgICAgICAqIH0pO1xyXG4gICAgICAgICogQG1lbWJlciB7Ym9vbGVhbn1cclxuICAgICAgICAqIEBtZW1iZXJvZiBQSVhJLkRpc3BsYXlPYmplY3QjXHJcbiAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmludGVyYWN0aXZlID0gZmFsc2U7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRGV0ZXJtaW5lcyBpZiB0aGUgY2hpbGRyZW4gdG8gdGhlIGRpc3BsYXlPYmplY3QgY2FuIGJlIGNsaWNrZWQvdG91Y2hlZFxyXG4gICAgICAgICAqIFNldHRpbmcgdGhpcyB0byBmYWxzZSBhbGxvd3MgUGl4aUpTIHRvIGJ5cGFzcyBhIHJlY3Vyc2l2ZSBgaGl0VGVzdGAgZnVuY3Rpb25cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XHJcbiAgICAgICAgICogQG1lbWJlcm9mIFBJWEkuQ29udGFpbmVyI1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuaW50ZXJhY3RpdmVDaGlsZHJlbiA9IHRydWU7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSW50ZXJhY3Rpb24gc2hhcGUuIENoaWxkcmVuIHdpbGwgYmUgaGl0IGZpcnN0LCB0aGVuIHRoaXMgc2hhcGUgd2lsbCBiZSBjaGVja2VkLlxyXG4gICAgICAgICAqIFNldHRpbmcgdGhpcyB3aWxsIGNhdXNlIHRoaXMgc2hhcGUgdG8gYmUgY2hlY2tlZCBpbiBoaXQgdGVzdHMgcmF0aGVyIHRoYW4gdGhlIGRpc3BsYXlPYmplY3QncyBib3VuZHMuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICAqIGNvbnN0IHNwcml0ZSA9IG5ldyBQSVhJLlNwcml0ZSh0ZXh0dXJlKTtcclxuICAgICAgICAgKiBzcHJpdGUuaW50ZXJhY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgICAqIHNwcml0ZS5oaXRBcmVhID0gbmV3IFBJWEkuUmVjdGFuZ2xlKDAsIDAsIDEwMCwgMTAwKTtcclxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLlJlY3RhbmdsZXxQSVhJLkNpcmNsZXxQSVhJLkVsbGlwc2V8UElYSS5Qb2x5Z29ufFBJWEkuUm91bmRlZFJlY3RhbmdsZX1cclxuICAgICAgICAgKiBAbWVtYmVyb2YgUElYSS5EaXNwbGF5T2JqZWN0I1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuaGl0QXJlYSA9IG51bGw7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhpcyBkZWZpbmVzIHdoYXQgY3Vyc29yIG1vZGUgaXMgdXNlZCB3aGVuIHRoZSBtb3VzZSBjdXJzb3JcclxuICAgICAgICAgKiBpcyBob3ZlcmVkIG92ZXIgdGhlIGRpc3BsYXlPYmplY3QuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICAqIGNvbnN0IHNwcml0ZSA9IG5ldyBQSVhJLlNwcml0ZSh0ZXh0dXJlKTtcclxuICAgICAgICAgKiBzcHJpdGUuaW50ZXJhY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgICAqIHNwcml0ZS5jdXJzb3IgPSAnd2FpdCc7XHJcbiAgICAgICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9DU1MvY3Vyc29yXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAbWVtYmVyIHtzdHJpbmd9XHJcbiAgICAgICAgICogQG1lbWJlcm9mIFBJWEkuRGlzcGxheU9iamVjdCNcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmN1cnNvciA9IG51bGw7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogTWFwIG9mIGFsbCB0cmFja2VkIHBvaW50ZXJzLCBieSBpZGVudGlmaWVyLiBVc2UgdHJhY2tlZFBvaW50ZXJzIHRvIGFjY2Vzcy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICogQHR5cGUge01hcDxudW1iZXIsIEludGVyYWN0aW9uVHJhY2tpbmdEYXRhPn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLl90cmFja2VkUG9pbnRlcnMgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5fY2FjaGVBc0JpdG1hcCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX2NhY2hlRGF0YSA9IGZhbHNlO1xyXG4gICAgICAgIC8vIHBlcmZvcm1hbmNlIGluY3JlYXNlIHRvIGF2b2lkIHVzaW5nIGNhbGwuLiAoMTB4IGZhc3RlcilcclxuICAgICAgICB0aGlzLmRpc3BsYXlPYmplY3RVcGRhdGVUcmFuc2Zvcm0gPSB0aGlzLnVwZGF0ZVRyYW5zZm9ybTtcclxuICAgICAgICB0aGlzLnRlbXBEaXNwbGF5T2JqZWN0UGFyZW50ID0gbnVsbDtcclxuICAgICAgICAvLyBUT0RPOiBuZWVkIHRvIGNyZWF0ZSBUcmFuc2Zvcm0gZnJvbSBmYWN0b3J5XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogV29ybGQgdHJhbnNmb3JtIGFuZCBsb2NhbCB0cmFuc2Zvcm0gb2YgdGhpcyBvYmplY3QuXHJcbiAgICAgICAgICogVGhpcyB3aWxsIGJlY29tZSByZWFkLW9ubHkgbGF0ZXIsIHBsZWFzZSBkbyBub3QgYXNzaWduIGFueXRoaW5nIHRoZXJlIHVubGVzcyB5b3Uga25vdyB3aGF0IGFyZSB5b3UgZG9pbmcuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLlRyYW5zZm9ybX1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnRyYW5zZm9ybSA9IG5ldyBUcmFuc2Zvcm1fMS5UcmFuc2Zvcm0oKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgb3BhY2l0eSBvZiB0aGUgb2JqZWN0LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuYWxwaGEgPSAxO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSB2aXNpYmlsaXR5IG9mIHRoZSBvYmplY3QuIElmIGZhbHNlIHRoZSBvYmplY3Qgd2lsbCBub3QgYmUgZHJhd24sIGFuZFxyXG4gICAgICAgICAqIHRoZSB1cGRhdGVUcmFuc2Zvcm0gZnVuY3Rpb24gd2lsbCBub3QgYmUgY2FsbGVkLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogT25seSBhZmZlY3RzIHJlY3Vyc2l2ZSBjYWxscyBmcm9tIHBhcmVudC4gWW91IGNhbiBhc2sgZm9yIGJvdW5kcyBvciBjYWxsIHVwZGF0ZVRyYW5zZm9ybSBtYW51YWxseS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy52aXNpYmxlID0gdHJ1ZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDYW4gdGhpcyBvYmplY3QgYmUgcmVuZGVyZWQsIGlmIGZhbHNlIHRoZSBvYmplY3Qgd2lsbCBub3QgYmUgZHJhd24gYnV0IHRoZSB1cGRhdGVUcmFuc2Zvcm1cclxuICAgICAgICAgKiBtZXRob2RzIHdpbGwgc3RpbGwgYmUgY2FsbGVkLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogT25seSBhZmZlY3RzIHJlY3Vyc2l2ZSBjYWxscyBmcm9tIHBhcmVudC4gWW91IGNhbiBhc2sgZm9yIGJvdW5kcyBtYW51YWxseS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5yZW5kZXJhYmxlID0gdHJ1ZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgZGlzcGxheSBvYmplY3QgY29udGFpbmVyIHRoYXQgY29udGFpbnMgdGhpcyBkaXNwbGF5IG9iamVjdC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuQ29udGFpbmVyfVxyXG4gICAgICAgICAqIEByZWFkb25seVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMucGFyZW50ID0gbnVsbDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgbXVsdGlwbGllZCBhbHBoYSBvZiB0aGUgZGlzcGxheU9iamVjdC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAgICAgKiBAcmVhZG9ubHlcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLndvcmxkQWxwaGEgPSAxO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFdoaWNoIGluZGV4IGluIHRoZSBjaGlsZHJlbiBhcnJheSB0aGUgZGlzcGxheSBjb21wb25lbnQgd2FzIGJlZm9yZSB0aGUgcHJldmlvdXMgekluZGV4IHNvcnQuXHJcbiAgICAgICAgICogVXNlZCBieSBjb250YWluZXJzIHRvIGhlbHAgc29ydCBvYmplY3RzIHdpdGggdGhlIHNhbWUgekluZGV4LCBieSB1c2luZyBwcmV2aW91cyBhcnJheSBpbmRleCBhcyB0aGUgZGVjaWRlci5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5fbGFzdFNvcnRlZEluZGV4ID0gMDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgekluZGV4IG9mIHRoZSBkaXNwbGF5T2JqZWN0LlxyXG4gICAgICAgICAqIEEgaGlnaGVyIHZhbHVlIHdpbGwgbWVhbiBpdCB3aWxsIGJlIHJlbmRlcmVkIG9uIHRvcCBvZiBvdGhlciBkaXNwbGF5T2JqZWN0cyB3aXRoaW4gdGhlIHNhbWUgY29udGFpbmVyLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLl96SW5kZXggPSAwO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBhcmVhIHRoZSBmaWx0ZXIgaXMgYXBwbGllZCB0by4gVGhpcyBpcyB1c2VkIGFzIG1vcmUgb2YgYW4gb3B0aW1pemF0aW9uXHJcbiAgICAgICAgICogcmF0aGVyIHRoYW4gZmlndXJpbmcgb3V0IHRoZSBkaW1lbnNpb25zIG9mIHRoZSBkaXNwbGF5T2JqZWN0IGVhY2ggZnJhbWUgeW91IGNhbiBzZXQgdGhpcyByZWN0YW5nbGUuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBBbHNvIHdvcmtzIGFzIGFuIGludGVyYWN0aW9uIG1hc2suXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAbWVtYmVyIHs/UElYSS5SZWN0YW5nbGV9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5maWx0ZXJBcmVhID0gbnVsbDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTZXRzIHRoZSBmaWx0ZXJzIGZvciB0aGUgZGlzcGxheU9iamVjdC5cclxuICAgICAgICAgKiAqIElNUE9SVEFOVDogVGhpcyBpcyBhIFdlYkdMIG9ubHkgZmVhdHVyZSBhbmQgd2lsbCBiZSBpZ25vcmVkIGJ5IHRoZSBjYW52YXMgcmVuZGVyZXIuXHJcbiAgICAgICAgICogVG8gcmVtb3ZlIGZpbHRlcnMgc2ltcGx5IHNldCB0aGlzIHByb3BlcnR5IHRvIGAnbnVsbCdgLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQG1lbWJlciB7P1BJWEkuRmlsdGVyW119XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5maWx0ZXJzID0gbnVsbDtcclxuICAgICAgICB0aGlzLl9lbmFibGVkRmlsdGVycyA9IG51bGw7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGJvdW5kcyBvYmplY3QsIHRoaXMgaXMgdXNlZCB0byBjYWxjdWxhdGUgYW5kIHN0b3JlIHRoZSBib3VuZHMgb2YgdGhlIGRpc3BsYXlPYmplY3QuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLkJvdW5kc31cclxuICAgICAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5fYm91bmRzID0gbmV3IEJvdW5kc18xLkJvdW5kcygpO1xyXG4gICAgICAgIHRoaXMuX2JvdW5kc0lEID0gMDtcclxuICAgICAgICB0aGlzLl9sYXN0Qm91bmRzSUQgPSAtMTtcclxuICAgICAgICB0aGlzLl9ib3VuZHNSZWN0ID0gbnVsbDtcclxuICAgICAgICB0aGlzLl9sb2NhbEJvdW5kc1JlY3QgPSBudWxsO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBvcmlnaW5hbCwgY2FjaGVkIG1hc2sgb2YgdGhlIG9iamVjdC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuR3JhcGhpY3N8UElYSS5TcHJpdGV9XHJcbiAgICAgICAgICogQHByb3RlY3RlZFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuX21hc2sgPSBudWxsO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEZpcmVkIHdoZW4gdGhpcyBEaXNwbGF5T2JqZWN0IGlzIGFkZGVkIHRvIGEgQ29udGFpbmVyLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGV2ZW50IFBJWEkuRGlzcGxheU9iamVjdCNhZGRlZFxyXG4gICAgICAgICAqIEBwYXJhbSB7UElYSS5Db250YWluZXJ9IGNvbnRhaW5lciAtIFRoZSBjb250YWluZXIgYWRkZWQgdG8uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRmlyZWQgd2hlbiB0aGlzIERpc3BsYXlPYmplY3QgaXMgcmVtb3ZlZCBmcm9tIGEgQ29udGFpbmVyLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGV2ZW50IFBJWEkuRGlzcGxheU9iamVjdCNyZW1vdmVkXHJcbiAgICAgICAgICogQHBhcmFtIHtQSVhJLkNvbnRhaW5lcn0gY29udGFpbmVyIC0gVGhlIGNvbnRhaW5lciByZW1vdmVkIGZyb20uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSWYgdGhlIG9iamVjdCBoYXMgYmVlbiBkZXN0cm95ZWQgdmlhIGRlc3Ryb3koKS4gSWYgdHJ1ZSwgaXQgc2hvdWxkIG5vdCBiZSB1c2VkLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQG1lbWJlciB7Ym9vbGVhbn1cclxuICAgICAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5fZGVzdHJveWVkID0gZmFsc2U7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogdXNlZCB0byBmYXN0IGNoZWNrIGlmIGEgc3ByaXRlIGlzLi4gYSBzcHJpdGUhXHJcbiAgICAgICAgICogQG1lbWJlciB7Ym9vbGVhbn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmlzU3ByaXRlID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICogSW50ZXJuYWwgc2V0IG9mIGFsbCBhY3RpdmUgcG9pbnRlcnMsIGJ5IGlkZW50aWZpZXJcclxuICpcclxuICogQG1lbWJlciB7TWFwPG51bWJlciwgSW50ZXJhY3Rpb25UcmFja2luZ0RhdGE+fVxyXG4gKiBAbWVtYmVyb2YgUElYSS5EaXNwbGF5T2JqZWN0I1xyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuICAgIGdldCB0cmFja2VkUG9pbnRlcnMoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3RyYWNrZWRQb2ludGVycyA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3RyYWNrZWRQb2ludGVycyA9IHt9O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5fdHJhY2tlZFBvaW50ZXJzO1xyXG4gICAgfVxyXG4gICAgLyohXHJcbiAqIEBwaXhpL21peGluLWdldC1nbG9iYWwtcG9zaXRpb24gLSB2NS4wLjAtcmMuM1xyXG4gKiBDb21waWxlZCBXZWQsIDEwIEFwciAyMDE5IDAxOjIxOjE1IFVUQ1xyXG4gKlxyXG4gKiBAcGl4aS9taXhpbi1nZXQtZ2xvYmFsLXBvc2l0aW9uIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cclxuICogaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZVxyXG4gKi9cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgZ2xvYmFsIHBvc2l0aW9uIG9mIHRoZSBkaXNwbGF5T2JqZWN0LiBEb2VzIG5vdCBkZXBlbmQgb24gb2JqZWN0IHNjYWxlLCByb3RhdGlvbiBhbmQgcGl2b3QuXHJcbiAgICAgKlxyXG4gICAgICogQG1ldGhvZCBnZXRHbG9iYWxQb3NpdGlvblxyXG4gICAgICogQG1lbWJlcm9mIFBJWEkuRGlzcGxheU9iamVjdCNcclxuICAgICAqIEBwYXJhbSB7UG9pbnR9IHBvaW50IC0gVGhlIHBvaW50IHRvIHdyaXRlIHRoZSBnbG9iYWwgdmFsdWUgdG8uIElmIG51bGwgYSBuZXcgcG9pbnQgd2lsbCBiZSByZXR1cm5lZFxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBza2lwVXBkYXRlIC0gU2V0dGluZyB0byB0cnVlIHdpbGwgc3RvcCB0aGUgdHJhbnNmb3JtcyBvZiB0aGUgc2NlbmUgZ3JhcGggZnJvbVxyXG4gICAgICogIGJlaW5nIHVwZGF0ZWQuIFRoaXMgbWVhbnMgdGhlIGNhbGN1bGF0aW9uIHJldHVybmVkIE1BWSBiZSBvdXQgb2YgZGF0ZSBCVVQgd2lsbCBnaXZlIHlvdSBhXHJcbiAgICAgKiAgbmljZSBwZXJmb3JtYW5jZSBib29zdC5cclxuICAgICAqIEByZXR1cm4ge1BvaW50fSBUaGUgdXBkYXRlZCBwb2ludC5cclxuICAgICAqL1xyXG4gICAgZ2V0R2xvYmFsUG9zaXRpb24ocG9pbnQsIHNraXBVcGRhdGUpIHtcclxuICAgICAgICBpZiAocG9pbnQgPT09IHZvaWQgMCkge1xyXG4gICAgICAgICAgICBwb2ludCA9IG5ldyBQb2ludF8xLlBvaW50KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChza2lwVXBkYXRlID09PSB2b2lkIDApIHtcclxuICAgICAgICAgICAgc2tpcFVwZGF0ZSA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5wYXJlbnQpIHtcclxuICAgICAgICAgICAgdGhpcy5wYXJlbnQudG9HbG9iYWwodGhpcy5wb3NpdGlvbiwgcG9pbnQsIHNraXBVcGRhdGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcG9pbnQueCA9IHRoaXMucG9zaXRpb24ueDtcclxuICAgICAgICAgICAgcG9pbnQueSA9IHRoaXMucG9zaXRpb24ueTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHBvaW50O1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAqIElmIGVuYWJsZWQsIHRoZSBtb3VzZSBjdXJzb3IgdXNlIHRoZSBwb2ludGVyIGJlaGF2aW9yIHdoZW4gaG92ZXJlZCBvdmVyIHRoZSBkaXNwbGF5T2JqZWN0IGlmIGl0IGlzIGludGVyYWN0aXZlXHJcbiAqIFNldHRpbmcgdGhpcyBjaGFuZ2VzIHRoZSAnY3Vyc29yJyBwcm9wZXJ0eSB0byBgJ3BvaW50ZXInYC5cclxuICpcclxuICogQGV4YW1wbGVcclxuICogY29uc3Qgc3ByaXRlID0gbmV3IFBJWEkuU3ByaXRlKHRleHR1cmUpO1xyXG4gKiBzcHJpdGUuaW50ZXJhY3RpdmUgPSB0cnVlO1xyXG4gKiBzcHJpdGUuYnV0dG9uTW9kZSA9IHRydWU7XHJcbiAqIEBtZW1iZXIge2Jvb2xlYW59XHJcbiAqIEBtZW1iZXJvZiBQSVhJLkRpc3BsYXlPYmplY3QjXHJcbiAqL1xyXG4gICAgZ2V0IGJ1dHRvbk1vZGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY3Vyc29yID09PSAncG9pbnRlcic7XHJcbiAgICB9XHJcbiAgICBzZXQgYnV0dG9uTW9kZSh2YWx1ZSkge1xyXG4gICAgICAgIGlmICh2YWx1ZSkge1xyXG4gICAgICAgICAgICB0aGlzLmN1cnNvciA9ICdwb2ludGVyJztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5jdXJzb3IgPT09ICdwb2ludGVyJykge1xyXG4gICAgICAgICAgICB0aGlzLmN1cnNvciA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgKiBAbWVtYmVyIHtQSVhJLkRpc3BsYXlPYmplY3R9XHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBtaXhpbihzb3VyY2UpIHtcclxuICAgICAgICAvLyBpbiBFUzgvRVMyMDE3LCB0aGlzIHdvdWxkIGJlIHJlYWxseSBlYXN5OlxyXG4gICAgICAgIC8vIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7XHJcbiAgICAgICAgLy8gZ2V0IGFsbCB0aGUgZW51bWVyYWJsZSBwcm9wZXJ0eSBrZXlzXHJcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xyXG4gICAgICAgIC8vIGxvb3AgdGhyb3VnaCBwcm9wZXJ0aWVzXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgIHZhciBwcm9wZXJ0eU5hbWUgPSBrZXlzW2ldO1xyXG4gICAgICAgICAgICAvLyBTZXQgdGhlIHByb3BlcnR5IHVzaW5nIHRoZSBwcm9wZXJ0eSBkZXNjcmlwdG9yIC0gdGhpcyB3b3JrcyBmb3IgYWNjZXNzb3JzIGFuZCBub3JtYWwgdmFsdWUgcHJvcGVydGllc1xyXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRGlzcGxheU9iamVjdC5wcm90b3R5cGUsIHByb3BlcnR5TmFtZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIHByb3BlcnR5TmFtZSkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIDtcclxuICAgIGdldCBfdGVtcERpc3BsYXlPYmplY3RQYXJlbnQoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMudGVtcERpc3BsYXlPYmplY3RQYXJlbnQgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgdGhpcy50ZW1wRGlzcGxheU9iamVjdFBhcmVudCA9IG5ldyBEaXNwbGF5T2JqZWN0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLnRlbXBEaXNwbGF5T2JqZWN0UGFyZW50O1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGVzIHRoZSBvYmplY3QgdHJhbnNmb3JtIGZvciByZW5kZXJpbmcuXHJcbiAgICAgKlxyXG4gICAgICogVE9ETyAtIE9wdGltaXphdGlvbiBwYXNzIVxyXG4gICAgICovXHJcbiAgICB1cGRhdGVUcmFuc2Zvcm0oKSB7XHJcbiAgICAgICAgdGhpcy50cmFuc2Zvcm0udXBkYXRlVHJhbnNmb3JtKHRoaXMucGFyZW50LnRyYW5zZm9ybSk7XHJcbiAgICAgICAgLy8gbXVsdGlwbHkgdGhlIGFscGhhcy4uXHJcbiAgICAgICAgdGhpcy53b3JsZEFscGhhID0gdGhpcy5hbHBoYSAqIHRoaXMucGFyZW50LndvcmxkQWxwaGE7XHJcbiAgICAgICAgdGhpcy5fYm91bmRzLnVwZGF0ZUlEKys7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFJlY3Vyc2l2ZWx5IHVwZGF0ZXMgdHJhbnNmb3JtIG9mIGFsbCBvYmplY3RzIGZyb20gdGhlIHJvb3QgdG8gdGhpcyBvbmVcclxuICAgICAqIGludGVybmFsIGZ1bmN0aW9uIGZvciB0b0xvY2FsKClcclxuICAgICAqL1xyXG4gICAgX3JlY3Vyc2l2ZVBvc3RVcGRhdGVUcmFuc2Zvcm0oKSB7XHJcbiAgICAgICAgaWYgKHRoaXMucGFyZW50KSB7XHJcbiAgICAgICAgICAgIHRoaXMucGFyZW50Ll9yZWN1cnNpdmVQb3N0VXBkYXRlVHJhbnNmb3JtKCk7XHJcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtLnVwZGF0ZVRyYW5zZm9ybSh0aGlzLnBhcmVudC50cmFuc2Zvcm0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm0udXBkYXRlVHJhbnNmb3JtKHRoaXMuX3RlbXBEaXNwbGF5T2JqZWN0UGFyZW50LnRyYW5zZm9ybSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIGJvdW5kcyBvZiB0aGUgZGlzcGxheU9iamVjdCBhcyBhIHJlY3RhbmdsZSBvYmplY3QuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbc2tpcFVwZGF0ZV0gLSBTZXR0aW5nIHRvIGB0cnVlYCB3aWxsIHN0b3AgdGhlIHRyYW5zZm9ybXMgb2YgdGhlIHNjZW5lIGdyYXBoIGZyb21cclxuICAgICAqICBiZWluZyB1cGRhdGVkLiBUaGlzIG1lYW5zIHRoZSBjYWxjdWxhdGlvbiByZXR1cm5lZCBNQVkgYmUgb3V0IG9mIGRhdGUgQlVUIHdpbGwgZ2l2ZSB5b3UgYVxyXG4gICAgICogIG5pY2UgcGVyZm9ybWFuY2UgYm9vc3QuXHJcbiAgICAgKiBAcGFyYW0ge1BJWEkuUmVjdGFuZ2xlfSBbcmVjdF0gLSBPcHRpb25hbCByZWN0YW5nbGUgdG8gc3RvcmUgdGhlIHJlc3VsdCBvZiB0aGUgYm91bmRzIGNhbGN1bGF0aW9uLlxyXG4gICAgICogQHJldHVybiB7UElYSS5SZWN0YW5nbGV9IFRoZSByZWN0YW5ndWxhciBib3VuZGluZyBhcmVhLlxyXG4gICAgICovXHJcbiAgICBnZXRCb3VuZHMoc2tpcFVwZGF0ZSA9IHRydWUsIHJlY3QgPSBudWxsKSB7XHJcbiAgICAgICAgaWYgKCFza2lwVXBkYXRlKSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5wYXJlbnQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50ID0gdGhpcy5fdGVtcERpc3BsYXlPYmplY3RQYXJlbnQ7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVRyYW5zZm9ybSgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQgPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVjdXJzaXZlUG9zdFVwZGF0ZVRyYW5zZm9ybSgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVUcmFuc2Zvcm0oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5fYm91bmRzSUQgIT09IHRoaXMuX2xhc3RCb3VuZHNJRCkge1xyXG4gICAgICAgICAgICB0aGlzLmNhbGN1bGF0ZUJvdW5kcygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXJlY3QpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLl9ib3VuZHNSZWN0KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9ib3VuZHNSZWN0ID0gbmV3IFJlY3RhbmdsZV8xLlJlY3RhbmdsZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJlY3QgPSB0aGlzLl9ib3VuZHNSZWN0O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5fYm91bmRzLmdldFJlY3RhbmdsZShyZWN0KTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIGNhbGN1bGF0ZUJvdW5kcygpIHtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0cmlldmVzIHRoZSBsb2NhbCBib3VuZHMgb2YgdGhlIGRpc3BsYXlPYmplY3QgYXMgYSByZWN0YW5nbGUgb2JqZWN0LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7UElYSS5SZWN0YW5nbGV9IFtyZWN0XSAtIE9wdGlvbmFsIHJlY3RhbmdsZSB0byBzdG9yZSB0aGUgcmVzdWx0IG9mIHRoZSBib3VuZHMgY2FsY3VsYXRpb24uXHJcbiAgICAgKiBAcmV0dXJuIHtQSVhJLlJlY3RhbmdsZX0gVGhlIHJlY3Rhbmd1bGFyIGJvdW5kaW5nIGFyZWEuXHJcbiAgICAgKi9cclxuICAgIGdldExvY2FsQm91bmRzKHJlY3QgPSBudWxsKSB7XHJcbiAgICAgICAgdmFyIHRyYW5zZm9ybVJlZiA9IHRoaXMudHJhbnNmb3JtO1xyXG4gICAgICAgIHZhciBwYXJlbnRSZWYgPSB0aGlzLnBhcmVudDtcclxuICAgICAgICB0aGlzLnBhcmVudCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy50cmFuc2Zvcm0gPSB0aGlzLl90ZW1wRGlzcGxheU9iamVjdFBhcmVudC50cmFuc2Zvcm07XHJcbiAgICAgICAgaWYgKCFyZWN0KSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5fbG9jYWxCb3VuZHNSZWN0KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2NhbEJvdW5kc1JlY3QgPSBuZXcgUmVjdGFuZ2xlXzEuUmVjdGFuZ2xlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmVjdCA9IHRoaXMuX2xvY2FsQm91bmRzUmVjdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGJvdW5kcyA9IHRoaXMuZ2V0Qm91bmRzKGZhbHNlLCByZWN0KTtcclxuICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudFJlZjtcclxuICAgICAgICB0aGlzLnRyYW5zZm9ybSA9IHRyYW5zZm9ybVJlZjtcclxuICAgICAgICByZXR1cm4gYm91bmRzO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxjdWxhdGVzIHRoZSBnbG9iYWwgcG9zaXRpb24gb2YgdGhlIGRpc3BsYXkgb2JqZWN0LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7UElYSS5JUG9pbnR9IHBvc2l0aW9uIC0gVGhlIHdvcmxkIG9yaWdpbiB0byBjYWxjdWxhdGUgZnJvbS5cclxuICAgICAqIEBwYXJhbSB7UElYSS5JUG9pbnR9IFtwb2ludF0gLSBBIFBvaW50IG9iamVjdCBpbiB3aGljaCB0byBzdG9yZSB0aGUgdmFsdWUsIG9wdGlvbmFsXHJcbiAgICAgKiAgKG90aGVyd2lzZSB3aWxsIGNyZWF0ZSBhIG5ldyBQb2ludCkuXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtza2lwVXBkYXRlPWZhbHNlXSAtIFNob3VsZCB3ZSBza2lwIHRoZSB1cGRhdGUgdHJhbnNmb3JtLlxyXG4gICAgICogQHJldHVybiB7UElYSS5JUG9pbnR9IEEgcG9pbnQgb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgcG9zaXRpb24gb2YgdGhpcyBvYmplY3QuXHJcbiAgICAgKi9cclxuICAgIHRvR2xvYmFsKHBvc2l0aW9uLCBwb2ludCwgc2tpcFVwZGF0ZSkge1xyXG4gICAgICAgIGlmIChza2lwVXBkYXRlID09PSB2b2lkIDApIHtcclxuICAgICAgICAgICAgc2tpcFVwZGF0ZSA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXNraXBVcGRhdGUpIHtcclxuICAgICAgICAgICAgdGhpcy5fcmVjdXJzaXZlUG9zdFVwZGF0ZVRyYW5zZm9ybSgpO1xyXG4gICAgICAgICAgICAvLyB0aGlzIHBhcmVudCBjaGVjayBpcyBmb3IganVzdCBpbiBjYXNlIHRoZSBpdGVtIGlzIGEgcm9vdCBvYmplY3QuXHJcbiAgICAgICAgICAgIC8vIElmIGl0IGlzIHdlIG5lZWQgdG8gZ2l2ZSBpdCBhIHRlbXBvcmFyeSBwYXJlbnQgc28gdGhhdCBkaXNwbGF5T2JqZWN0VXBkYXRlVHJhbnNmb3JtIHdvcmtzIGNvcnJlY3RseVxyXG4gICAgICAgICAgICAvLyB0aGlzIGlzIG1haW5seSB0byBhdm9pZCBhIHBhcmVudCBjaGVjayBpbiB0aGUgbWFpbiBsb29wLiBFdmVyeSBsaXR0bGUgaGVscHMgZm9yIHBlcmZvcm1hbmNlIDopXHJcbiAgICAgICAgICAgIGlmICghdGhpcy5wYXJlbnQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50ID0gdGhpcy5fdGVtcERpc3BsYXlPYmplY3RQYXJlbnQ7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BsYXlPYmplY3RVcGRhdGVUcmFuc2Zvcm0oKTtcclxuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50ID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGxheU9iamVjdFVwZGF0ZVRyYW5zZm9ybSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGRvbid0IG5lZWQgdG8gdXBkYXRlIHRoZSBsb3RcclxuICAgICAgICByZXR1cm4gdGhpcy53b3JsZFRyYW5zZm9ybS5hcHBseShwb3NpdGlvbiwgcG9pbnQpO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxjdWxhdGVzIHRoZSBsb2NhbCBwb3NpdGlvbiBvZiB0aGUgZGlzcGxheSBvYmplY3QgcmVsYXRpdmUgdG8gYW5vdGhlciBwb2ludC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1BJWEkuSVBvaW50fSBwb3NpdGlvbiAtIFRoZSB3b3JsZCBvcmlnaW4gdG8gY2FsY3VsYXRlIGZyb20uXHJcbiAgICAgKiBAcGFyYW0ge1BJWEkuRGlzcGxheU9iamVjdH0gW2Zyb21dIC0gVGhlIERpc3BsYXlPYmplY3QgdG8gY2FsY3VsYXRlIHRoZSBnbG9iYWwgcG9zaXRpb24gZnJvbS5cclxuICAgICAqIEBwYXJhbSB7UElYSS5JUG9pbnR9IFtwb2ludF0gLSBBIFBvaW50IG9iamVjdCBpbiB3aGljaCB0byBzdG9yZSB0aGUgdmFsdWUsIG9wdGlvbmFsXHJcbiAgICAgKiAgKG90aGVyd2lzZSB3aWxsIGNyZWF0ZSBhIG5ldyBQb2ludCkuXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtza2lwVXBkYXRlPWZhbHNlXSAtIFNob3VsZCB3ZSBza2lwIHRoZSB1cGRhdGUgdHJhbnNmb3JtXHJcbiAgICAgKiBAcmV0dXJuIHtQSVhJLklQb2ludH0gQSBwb2ludCBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBwb3NpdGlvbiBvZiB0aGlzIG9iamVjdFxyXG4gICAgICovXHJcbiAgICB0b0xvY2FsKHBvc2l0aW9uLCBmcm9tLCBwb2ludCwgc2tpcFVwZGF0ZSkge1xyXG4gICAgICAgIGlmIChmcm9tKSB7XHJcbiAgICAgICAgICAgIHBvc2l0aW9uID0gZnJvbS50b0dsb2JhbChwb3NpdGlvbiwgcG9pbnQsIHNraXBVcGRhdGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXNraXBVcGRhdGUpIHtcclxuICAgICAgICAgICAgdGhpcy5fcmVjdXJzaXZlUG9zdFVwZGF0ZVRyYW5zZm9ybSgpO1xyXG4gICAgICAgICAgICAvLyB0aGlzIHBhcmVudCBjaGVjayBpcyBmb3IganVzdCBpbiBjYXNlIHRoZSBpdGVtIGlzIGEgcm9vdCBvYmplY3QuXHJcbiAgICAgICAgICAgIC8vIElmIGl0IGlzIHdlIG5lZWQgdG8gZ2l2ZSBpdCBhIHRlbXBvcmFyeSBwYXJlbnQgc28gdGhhdCBkaXNwbGF5T2JqZWN0VXBkYXRlVHJhbnNmb3JtIHdvcmtzIGNvcnJlY3RseVxyXG4gICAgICAgICAgICAvLyB0aGlzIGlzIG1haW5seSB0byBhdm9pZCBhIHBhcmVudCBjaGVjayBpbiB0aGUgbWFpbiBsb29wLiBFdmVyeSBsaXR0bGUgaGVscHMgZm9yIHBlcmZvcm1hbmNlIDopXHJcbiAgICAgICAgICAgIGlmICghdGhpcy5wYXJlbnQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50ID0gdGhpcy5fdGVtcERpc3BsYXlPYmplY3RQYXJlbnQ7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BsYXlPYmplY3RVcGRhdGVUcmFuc2Zvcm0oKTtcclxuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50ID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGxheU9iamVjdFVwZGF0ZVRyYW5zZm9ybSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHNpbXBseSBhcHBseSB0aGUgbWF0cml4Li5cclxuICAgICAgICByZXR1cm4gdGhpcy53b3JsZFRyYW5zZm9ybS5hcHBseUludmVyc2UocG9zaXRpb24sIHBvaW50KTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogUmVuZGVycyB0aGUgb2JqZWN0IHVzaW5nIHRoZSBXZWJHTCByZW5kZXJlci5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1BJWEkuUmVuZGVyZXJ9IHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyLlxyXG4gICAgICovXHJcbiAgICByZW5kZXIocmVuZGVyZXIpIHtcclxuICAgICAgICAvLyBPVkVSV1JJVEU7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFNldCB0aGUgcGFyZW50IENvbnRhaW5lciBvZiB0aGlzIERpc3BsYXlPYmplY3QuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtQSVhJLkNvbnRhaW5lcn0gY29udGFpbmVyIC0gVGhlIENvbnRhaW5lciB0byBhZGQgdGhpcyBEaXNwbGF5T2JqZWN0IHRvLlxyXG4gICAgICogQHJldHVybiB7UElYSS5Db250YWluZXJ9IFRoZSBDb250YWluZXIgdGhhdCB0aGlzIERpc3BsYXlPYmplY3Qgd2FzIGFkZGVkIHRvLlxyXG4gICAgICovXHJcbiAgICBzZXRQYXJlbnQoY29udGFpbmVyKSB7XHJcbiAgICAgICAgaWYgKCFjb250YWluZXIgfHwgIWNvbnRhaW5lci5hZGRDaGlsZCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFBhcmVudDogQXJndW1lbnQgbXVzdCBiZSBhIENvbnRhaW5lcicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb250YWluZXIuYWRkQ2hpbGQodGhpcyk7XHJcbiAgICAgICAgcmV0dXJuIGNvbnRhaW5lcjtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQ29udmVuaWVuY2UgZnVuY3Rpb24gdG8gc2V0IHRoZSBwb3NpdGlvbiwgc2NhbGUsIHNrZXcgYW5kIHBpdm90IGF0IG9uY2UuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt4PTBdIC0gVGhlIFggcG9zaXRpb25cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbeT0wXSAtIFRoZSBZIHBvc2l0aW9uXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3NjYWxlWD0xXSAtIFRoZSBYIHNjYWxlIHZhbHVlXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3NjYWxlWT0xXSAtIFRoZSBZIHNjYWxlIHZhbHVlXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3JvdGF0aW9uPTBdIC0gVGhlIHJvdGF0aW9uXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3NrZXdYPTBdIC0gVGhlIFggc2tldyB2YWx1ZVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtza2V3WT0wXSAtIFRoZSBZIHNrZXcgdmFsdWVcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcGl2b3RYPTBdIC0gVGhlIFggcGl2b3QgdmFsdWVcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcGl2b3RZPTBdIC0gVGhlIFkgcGl2b3QgdmFsdWVcclxuICAgICAqIEByZXR1cm4ge1BJWEkuRGlzcGxheU9iamVjdH0gVGhlIERpc3BsYXlPYmplY3QgaW5zdGFuY2VcclxuICAgICAqL1xyXG4gICAgc2V0VHJhbnNmb3JtKHgsIHksIHNjYWxlWCwgc2NhbGVZLCByb3RhdGlvbiwgc2tld1gsIHNrZXdZLCBwaXZvdFgsIHBpdm90WSkge1xyXG4gICAgICAgIGlmICh4ID09PSB2b2lkIDApIHtcclxuICAgICAgICAgICAgeCA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh5ID09PSB2b2lkIDApIHtcclxuICAgICAgICAgICAgeSA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzY2FsZVggPT09IHZvaWQgMCkge1xyXG4gICAgICAgICAgICBzY2FsZVggPSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc2NhbGVZID09PSB2b2lkIDApIHtcclxuICAgICAgICAgICAgc2NhbGVZID0gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJvdGF0aW9uID09PSB2b2lkIDApIHtcclxuICAgICAgICAgICAgcm90YXRpb24gPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc2tld1ggPT09IHZvaWQgMCkge1xyXG4gICAgICAgICAgICBza2V3WCA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChza2V3WSA9PT0gdm9pZCAwKSB7XHJcbiAgICAgICAgICAgIHNrZXdZID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHBpdm90WCA9PT0gdm9pZCAwKSB7XHJcbiAgICAgICAgICAgIHBpdm90WCA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwaXZvdFkgPT09IHZvaWQgMCkge1xyXG4gICAgICAgICAgICBwaXZvdFkgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnBvc2l0aW9uLnggPSB4O1xyXG4gICAgICAgIHRoaXMucG9zaXRpb24ueSA9IHk7XHJcbiAgICAgICAgdGhpcy5zY2FsZS54ID0gIXNjYWxlWCA/IDEgOiBzY2FsZVg7XHJcbiAgICAgICAgdGhpcy5zY2FsZS55ID0gIXNjYWxlWSA/IDEgOiBzY2FsZVk7XHJcbiAgICAgICAgdGhpcy5yb3RhdGlvbiA9IHJvdGF0aW9uO1xyXG4gICAgICAgIHRoaXMuc2tldy54ID0gc2tld1g7XHJcbiAgICAgICAgdGhpcy5za2V3LnkgPSBza2V3WTtcclxuICAgICAgICB0aGlzLnBpdm90LnggPSBwaXZvdFg7XHJcbiAgICAgICAgdGhpcy5waXZvdC55ID0gcGl2b3RZO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBCYXNlIGRlc3Ryb3kgbWV0aG9kIGZvciBnZW5lcmljIGRpc3BsYXkgb2JqZWN0cy4gVGhpcyB3aWxsIGF1dG9tYXRpY2FsbHlcclxuICAgICAqIHJlbW92ZSB0aGUgZGlzcGxheSBvYmplY3QgZnJvbSBpdHMgcGFyZW50IENvbnRhaW5lciBhcyB3ZWxsIGFzIHJlbW92ZVxyXG4gICAgICogYWxsIGN1cnJlbnQgZXZlbnQgbGlzdGVuZXJzIGFuZCBpbnRlcm5hbCByZWZlcmVuY2VzLiBEbyBub3QgdXNlIGEgRGlzcGxheU9iamVjdFxyXG4gICAgICogYWZ0ZXIgY2FsbGluZyBgZGVzdHJveSgpYC5cclxuICAgICAqXHJcbiAgICAgKi9cclxuICAgIGRlc3Ryb3kob3B0aW9ucyA9IG51bGwpIHtcclxuICAgICAgICAvLyB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xyXG4gICAgICAgIGlmICh0aGlzLnBhcmVudCkge1xyXG4gICAgICAgICAgICB0aGlzLnBhcmVudC5yZW1vdmVDaGlsZCh0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy50cmFuc2Zvcm0gPSBudWxsO1xyXG4gICAgICAgIHRoaXMucGFyZW50ID0gbnVsbDtcclxuICAgICAgICB0aGlzLl9ib3VuZHMgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuX2N1cnJlbnRCb3VuZHMgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuX21hc2sgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuZmlsdGVyQXJlYSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5pbnRlcmFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuaW50ZXJhY3RpdmVDaGlsZHJlbiA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX2Rlc3Ryb3llZCA9IHRydWU7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBwb3NpdGlvbiBvZiB0aGUgZGlzcGxheU9iamVjdCBvbiB0aGUgeCBheGlzIHJlbGF0aXZlIHRvIHRoZSBsb2NhbCBjb29yZGluYXRlcyBvZiB0aGUgcGFyZW50LlxyXG4gICAgICogQW4gYWxpYXMgdG8gcG9zaXRpb24ueFxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgZ2V0IHgoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucG9zaXRpb24ueDtcclxuICAgIH1cclxuICAgIDtcclxuICAgIHNldCB4KHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy50cmFuc2Zvcm0ucG9zaXRpb24ueCA9IHZhbHVlO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgcG9zaXRpb24gb2YgdGhlIGRpc3BsYXlPYmplY3Qgb24gdGhlIHkgYXhpcyByZWxhdGl2ZSB0byB0aGUgbG9jYWwgY29vcmRpbmF0ZXMgb2YgdGhlIHBhcmVudC5cclxuICAgICAqIEFuIGFsaWFzIHRvIHBvc2l0aW9uLnlcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIGdldCB5KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnBvc2l0aW9uLnk7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICBzZXQgeSh2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMudHJhbnNmb3JtLnBvc2l0aW9uLnkgPSB2YWx1ZTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQ3VycmVudCB0cmFuc2Zvcm0gb2YgdGhlIG9iamVjdCBiYXNlZCBvbiB3b3JsZCAocGFyZW50KSBmYWN0b3JzLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge1BJWEkuTWF0cml4fVxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKi9cclxuICAgIGdldCB3b3JsZFRyYW5zZm9ybSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0ud29ybGRUcmFuc2Zvcm07XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIEN1cnJlbnQgdHJhbnNmb3JtIG9mIHRoZSBvYmplY3QgYmFzZWQgb24gbG9jYWwgZmFjdG9yczogcG9zaXRpb24sIHNjYWxlLCBvdGhlciBzdHVmZi5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtQSVhJLk1hdHJpeH1cclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICovXHJcbiAgICBnZXQgbG9jYWxUcmFuc2Zvcm0oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtLmxvY2FsVHJhbnNmb3JtO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgY29vcmRpbmF0ZSBvZiB0aGUgb2JqZWN0IHJlbGF0aXZlIHRvIHRoZSBsb2NhbCBjb29yZGluYXRlcyBvZiB0aGUgcGFyZW50LlxyXG4gICAgICogQXNzaWdubWVudCBieSB2YWx1ZSBzaW5jZSBwaXhpLXY0LlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge1BJWEkuSVBvaW50fVxyXG4gICAgICovXHJcbiAgICBnZXQgcG9zaXRpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtLnBvc2l0aW9uO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgc2V0IHBvc2l0aW9uKHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy50cmFuc2Zvcm0ucG9zaXRpb24uY29weUZyb20odmFsdWUpO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgc2NhbGUgZmFjdG9yIG9mIHRoZSBvYmplY3QuXHJcbiAgICAgKiBBc3NpZ25tZW50IGJ5IHZhbHVlIHNpbmNlIHBpeGktdjQuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7UElYSS5JUG9pbnR9XHJcbiAgICAgKi9cclxuICAgIGdldCBzY2FsZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0uc2NhbGU7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICBzZXQgc2NhbGUodmFsdWUpIHtcclxuICAgICAgICB0aGlzLnRyYW5zZm9ybS5zY2FsZS5jb3B5RnJvbSh2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBwaXZvdCBwb2ludCBvZiB0aGUgZGlzcGxheU9iamVjdCB0aGF0IGl0IHJvdGF0ZXMgYXJvdW5kLlxyXG4gICAgICogQXNzaWdubWVudCBieSB2YWx1ZSBzaW5jZSBwaXhpLXY0LlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge1BJWEkuSVBvaW50fVxyXG4gICAgICovXHJcbiAgICBnZXQgcGl2b3QoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtLnBpdm90O1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgc2V0IHBpdm90KHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy50cmFuc2Zvcm0ucGl2b3QuY29weUZyb20odmFsdWUpO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgc2tldyBmYWN0b3IgZm9yIHRoZSBvYmplY3QgaW4gcmFkaWFucy5cclxuICAgICAqIEFzc2lnbm1lbnQgYnkgdmFsdWUgc2luY2UgcGl4aS12NC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtQSVhJLk9ic2VydmFibGVQb2ludH1cclxuICAgICAqL1xyXG4gICAgZ2V0IHNrZXcoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtLnNrZXc7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICBzZXQgc2tldyh2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMudHJhbnNmb3JtLnNrZXcuY29weUZyb20odmFsdWUpO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgcm90YXRpb24gb2YgdGhlIG9iamVjdCBpbiByYWRpYW5zLlxyXG4gICAgICogJ3JvdGF0aW9uJyBhbmQgJ2FuZ2xlJyBoYXZlIHRoZSBzYW1lIGVmZmVjdCBvbiBhIGRpc3BsYXkgb2JqZWN0OyByb3RhdGlvbiBpcyBpbiByYWRpYW5zLCBhbmdsZSBpcyBpbiBkZWdyZWVzLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgZ2V0IHJvdGF0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybS5yb3RhdGlvbjtcclxuICAgIH1cclxuICAgIDtcclxuICAgIHNldCByb3RhdGlvbih2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMudHJhbnNmb3JtLnJvdGF0aW9uID0gdmFsdWU7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBhbmdsZSBvZiB0aGUgb2JqZWN0IGluIGRlZ3JlZXMuXHJcbiAgICAgKiAncm90YXRpb24nIGFuZCAnYW5nbGUnIGhhdmUgdGhlIHNhbWUgZWZmZWN0IG9uIGEgZGlzcGxheSBvYmplY3Q7IHJvdGF0aW9uIGlzIGluIHJhZGlhbnMsIGFuZ2xlIGlzIGluIGRlZ3JlZXMuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICBnZXQgYW5nbGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtLnJvdGF0aW9uICogTWF0aFNldHRpbmdzXzEuTWF0aFNldHRpbmdzLlJBRF9UT19ERUc7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICBzZXQgYW5nbGUodmFsdWUpIHtcclxuICAgICAgICB0aGlzLnRyYW5zZm9ybS5yb3RhdGlvbiA9IHZhbHVlICogTWF0aFNldHRpbmdzXzEuTWF0aFNldHRpbmdzLkRFR19UT19SQUQ7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSB6SW5kZXggb2YgdGhlIGRpc3BsYXlPYmplY3QuXHJcbiAgICAgKiBJZiBhIGNvbnRhaW5lciBoYXMgdGhlIHNvcnRhYmxlQ2hpbGRyZW4gcHJvcGVydHkgc2V0IHRvIHRydWUsIGNoaWxkcmVuIHdpbGwgYmUgYXV0b21hdGljYWxseVxyXG4gICAgICogc29ydGVkIGJ5IHpJbmRleCB2YWx1ZTsgYSBoaWdoZXIgdmFsdWUgd2lsbCBtZWFuIGl0IHdpbGwgYmUgbW92ZWQgdG93YXJkcyB0aGUgZW5kIG9mIHRoZSBhcnJheSxcclxuICAgICAqIGFuZCB0aHVzIHJlbmRlcmVkIG9uIHRvcCBvZiBvdGhlciBkaXNwbGF5T2JqZWN0cyB3aXRoaW4gdGhlIHNhbWUgY29udGFpbmVyLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgZ2V0IHpJbmRleCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fekluZGV4O1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgc2V0IHpJbmRleCh2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuX3pJbmRleCA9IHZhbHVlO1xyXG4gICAgICAgIGlmICh0aGlzLnBhcmVudCkge1xyXG4gICAgICAgICAgICB0aGlzLnBhcmVudC5zb3J0RGlydHkgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogSW5kaWNhdGVzIGlmIHRoZSBvYmplY3QgaXMgZ2xvYmFsbHkgdmlzaWJsZS5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtib29sZWFufVxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKi9cclxuICAgIGdldCB3b3JsZFZpc2libGUoKSB7XHJcbiAgICAgICAgdmFyIGl0ZW0gPSB0aGlzO1xyXG4gICAgICAgIGRvIHtcclxuICAgICAgICAgICAgaWYgKCFpdGVtLnZpc2libGUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpdGVtID0gaXRlbS5wYXJlbnQ7XHJcbiAgICAgICAgfSB3aGlsZSAoaXRlbSk7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFNldHMgYSBtYXNrIGZvciB0aGUgZGlzcGxheU9iamVjdC4gQSBtYXNrIGlzIGFuIG9iamVjdCB0aGF0IGxpbWl0cyB0aGUgdmlzaWJpbGl0eSBvZiBhblxyXG4gICAgICogb2JqZWN0IHRvIHRoZSBzaGFwZSBvZiB0aGUgbWFzayBhcHBsaWVkIHRvIGl0LiBJbiBQaXhpSlMgYSByZWd1bGFyIG1hc2sgbXVzdCBiZSBhXHJcbiAgICAgKiB7QGxpbmsgUElYSS5HcmFwaGljc30gb3IgYSB7QGxpbmsgUElYSS5TcHJpdGV9IG9iamVjdC4gVGhpcyBhbGxvd3MgZm9yIG11Y2ggZmFzdGVyIG1hc2tpbmcgaW4gY2FudmFzIGFzIGl0XHJcbiAgICAgKiB1dGlsaXRpZXMgc2hhcGUgY2xpcHBpbmcuIFRvIHJlbW92ZSBhIG1hc2ssIHNldCB0aGlzIHByb3BlcnR5IHRvIGBudWxsYC5cclxuICAgICAqXHJcbiAgICAgKiBGb3Igc3ByaXRlIG1hc2sgYm90aCBhbHBoYSBhbmQgcmVkIGNoYW5uZWwgYXJlIHVzZWQuIEJsYWNrIG1hc2sgaXMgdGhlIHNhbWUgYXMgdHJhbnNwYXJlbnQgbWFzay5cclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKiBjb25zdCBncmFwaGljcyA9IG5ldyBQSVhJLkdyYXBoaWNzKCk7XHJcbiAgICAgKiBncmFwaGljcy5iZWdpbkZpbGwoMHhGRjMzMDApO1xyXG4gICAgICogZ3JhcGhpY3MuZHJhd1JlY3QoNTAsIDI1MCwgMTAwLCAxMDApO1xyXG4gICAgICogZ3JhcGhpY3MuZW5kRmlsbCgpO1xyXG4gICAgICpcclxuICAgICAqIGNvbnN0IHNwcml0ZSA9IG5ldyBQSVhJLlNwcml0ZSh0ZXh0dXJlKTtcclxuICAgICAqIHNwcml0ZS5tYXNrID0gZ3JhcGhpY3M7XHJcbiAgICAgKiBAdG9kbyBBdCB0aGUgbW9tZW50LCBQSVhJLkNhbnZhc1JlbmRlcmVyIGRvZXNuJ3Qgc3VwcG9ydCBQSVhJLlNwcml0ZSBhcyBtYXNrLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge1BJWEkuR3JhcGhpY3N8UElYSS5TcHJpdGV9XHJcbiAgICAgKi9cclxuICAgIGdldCBtYXNrKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9tYXNrO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgc2V0IG1hc2sodmFsdWUpIHtcclxuICAgICAgICBpZiAodGhpcy5fbWFzaykge1xyXG4gICAgICAgICAgICB0aGlzLl9tYXNrLnJlbmRlcmFibGUgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLl9tYXNrLmlzTWFzayA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9tYXNrID0gdmFsdWU7XHJcbiAgICAgICAgaWYgKHRoaXMuX21hc2spIHtcclxuICAgICAgICAgICAgdGhpcy5fbWFzay5yZW5kZXJhYmxlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuX21hc2suaXNNYXNrID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAgICAgICAgICogU2V0IHRoaXMgdG8gdHJ1ZSBpZiB5b3Ugd2FudCB0aGlzIGRpc3BsYXkgb2JqZWN0IHRvIGJlIGNhY2hlZCBhcyBhIGJpdG1hcC5cclxuICAgICAgICAgICAgICogVGhpcyBiYXNpY2FsbHkgdGFrZXMgYSBzbmFwIHNob3Qgb2YgdGhlIGRpc3BsYXkgb2JqZWN0IGFzIGl0IGlzIGF0IHRoYXQgbW9tZW50LiBJdCBjYW5cclxuICAgICAgICAgICAgICogcHJvdmlkZSBhIHBlcmZvcm1hbmNlIGJlbmVmaXQgZm9yIGNvbXBsZXggc3RhdGljIGRpc3BsYXlPYmplY3RzLlxyXG4gICAgICAgICAgICAgKiBUbyByZW1vdmUgc2ltcGx5IHNldCB0aGlzIHByb3BlcnR5IHRvIGBmYWxzZWBcclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogSU1QT1JUQU5UIEdPVENIQSAtIE1ha2Ugc3VyZSB0aGF0IGFsbCB5b3VyIHRleHR1cmVzIGFyZSBwcmVsb2FkZWQgQkVGT1JFIHNldHRpbmcgdGhpcyBwcm9wZXJ0eSB0byB0cnVlXHJcbiAgICAgICAgICAgICAqIGFzIGl0IHdpbGwgdGFrZSBhIHNuYXBzaG90IG9mIHdoYXQgaXMgY3VycmVudGx5IHRoZXJlLiBJZiB0aGUgdGV4dHVyZXMgaGF2ZSBub3QgbG9hZGVkIHRoZW4gdGhleSB3aWxsIG5vdCBhcHBlYXIuXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XHJcbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBQSVhJLkRpc3BsYXlPYmplY3QjXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgZ2V0IGNhY2hlQXNCaXRtYXAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhY2hlQXNCaXRtYXA7XHJcbiAgICB9XHJcbiAgICBzZXQgY2FjaGVBc0JpdG1hcCh2YWx1ZSkge1xyXG4gICAgICAgIGlmICh0aGlzLl9jYWNoZUFzQml0bWFwID09PSB2YWx1ZSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2NhY2hlQXNCaXRtYXAgPSB2YWx1ZTtcclxuICAgICAgICB2YXIgZGF0YTtcclxuICAgICAgICBpZiAodmFsdWUpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLl9jYWNoZURhdGEpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2NhY2hlRGF0YSA9IG5ldyBDYWNoZURhdGEoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBkYXRhID0gdGhpcy5fY2FjaGVEYXRhO1xyXG4gICAgICAgICAgICBkYXRhLm9yaWdpbmFsUmVuZGVyID0gdGhpcy5yZW5kZXI7XHJcbiAgICAgICAgICAgIGRhdGEub3JpZ2luYWxSZW5kZXJDYW52YXMgPSB0aGlzLnJlbmRlckNhbnZhcztcclxuICAgICAgICAgICAgZGF0YS5vcmlnaW5hbFVwZGF0ZVRyYW5zZm9ybSA9IHRoaXMudXBkYXRlVHJhbnNmb3JtO1xyXG4gICAgICAgICAgICBkYXRhLm9yaWdpbmFsQ2FsY3VsYXRlQm91bmRzID0gdGhpcy5jYWxjdWxhdGVCb3VuZHM7XHJcbiAgICAgICAgICAgIGRhdGEub3JpZ2luYWxHZXRMb2NhbEJvdW5kcyA9IHRoaXMuZ2V0TG9jYWxCb3VuZHM7XHJcbiAgICAgICAgICAgIGRhdGEub3JpZ2luYWxEZXN0cm95ID0gdGhpcy5kZXN0cm95O1xyXG4gICAgICAgICAgICBkYXRhLm9yaWdpbmFsQ29udGFpbnNQb2ludCA9IHRoaXMuY29udGFpbnNQb2ludDtcclxuICAgICAgICAgICAgZGF0YS5vcmlnaW5hbE1hc2sgPSB0aGlzLl9tYXNrO1xyXG4gICAgICAgICAgICBkYXRhLm9yaWdpbmFsRmlsdGVyQXJlYSA9IHRoaXMuZmlsdGVyQXJlYTtcclxuICAgICAgICAgICAgdGhpcy5yZW5kZXIgPSB0aGlzLl9yZW5kZXJDYWNoZWQ7XHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVyQ2FudmFzID0gdGhpcy5fcmVuZGVyQ2FjaGVkQ2FudmFzO1xyXG4gICAgICAgICAgICB0aGlzLmRlc3Ryb3kgPSB0aGlzLl9jYWNoZUFzQml0bWFwRGVzdHJveTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGRhdGEgPSB0aGlzLl9jYWNoZURhdGE7XHJcbiAgICAgICAgICAgIGlmIChkYXRhLnNwcml0ZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZGVzdHJveUNhY2hlZERpc3BsYXlPYmplY3QoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnJlbmRlciA9IGRhdGEub3JpZ2luYWxSZW5kZXI7XHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVyQ2FudmFzID0gZGF0YS5vcmlnaW5hbFJlbmRlckNhbnZhcztcclxuICAgICAgICAgICAgdGhpcy5jYWxjdWxhdGVCb3VuZHMgPSBkYXRhLm9yaWdpbmFsQ2FsY3VsYXRlQm91bmRzO1xyXG4gICAgICAgICAgICB0aGlzLmdldExvY2FsQm91bmRzID0gZGF0YS5vcmlnaW5hbEdldExvY2FsQm91bmRzO1xyXG4gICAgICAgICAgICB0aGlzLmRlc3Ryb3kgPSBkYXRhLm9yaWdpbmFsRGVzdHJveTtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVUcmFuc2Zvcm0gPSBkYXRhLm9yaWdpbmFsVXBkYXRlVHJhbnNmb3JtO1xyXG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5zUG9pbnQgPSBkYXRhLm9yaWdpbmFsQ29udGFpbnNQb2ludDtcclxuICAgICAgICAgICAgdGhpcy5fbWFzayA9IGRhdGEub3JpZ2luYWxNYXNrO1xyXG4gICAgICAgICAgICB0aGlzLmZpbHRlckFyZWEgPSBkYXRhLm9yaWdpbmFsRmlsdGVyQXJlYTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjb250YWluc1BvaW50KHBvaW50KSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW5kZXJzIGEgY2FjaGVkIHZlcnNpb24gb2YgdGhlIHNwcml0ZSB3aXRoIFdlYkdMXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBmdW5jdGlvbiBfcmVuZGVyQ2FjaGVkXHJcbiAgICAgKiBAbWVtYmVyb2YgUElYSS5EaXNwbGF5T2JqZWN0I1xyXG4gICAgICogQHBhcmFtIHtQSVhJLlJlbmRlcmVyfSByZW5kZXJlciAtIHRoZSBXZWJHTCByZW5kZXJlclxyXG4gICAgICovXHJcbiAgICBfcmVuZGVyQ2FjaGVkKHJlbmRlcmVyKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLnZpc2libGUgfHwgdGhpcy53b3JsZEFscGhhIDw9IDAgfHwgIXRoaXMucmVuZGVyYWJsZSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2luaXRDYWNoZWREaXNwbGF5T2JqZWN0KHJlbmRlcmVyKTtcclxuICAgICAgICB0aGlzLl9jYWNoZURhdGEuc3ByaXRlLnRyYW5zZm9ybS5fd29ybGRJRCA9IHRoaXMudHJhbnNmb3JtLl93b3JsZElEO1xyXG4gICAgICAgIHRoaXMuX2NhY2hlRGF0YS5zcHJpdGUud29ybGRBbHBoYSA9IHRoaXMud29ybGRBbHBoYTtcclxuICAgICAgICB0aGlzLl9jYWNoZURhdGEuc3ByaXRlLl9yZW5kZXIocmVuZGVyZXIpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBQcmVwYXJlcyB0aGUgV2ViR0wgcmVuZGVyZXIgdG8gY2FjaGUgdGhlIHNwcml0ZVxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAZnVuY3Rpb24gX2luaXRDYWNoZWREaXNwbGF5T2JqZWN0XHJcbiAgICAgKiBAbWVtYmVyb2YgUElYSS5EaXNwbGF5T2JqZWN0I1xyXG4gICAgICogQHBhcmFtIHtQSVhJLlJlbmRlcmVyfSByZW5kZXJlciAtIHRoZSBXZWJHTCByZW5kZXJlclxyXG4gICAgICovXHJcbiAgICBfaW5pdENhY2hlZERpc3BsYXlPYmplY3QocmVuZGVyZXIpIHtcclxuICAgICAgICBpZiAodGhpcy5fY2FjaGVEYXRhICYmIHRoaXMuX2NhY2hlRGF0YS5zcHJpdGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBtYWtlIHN1cmUgYWxwaGEgaXMgc2V0IHRvIDEgb3RoZXJ3aXNlIGl0IHdpbGwgZ2V0IHJlbmRlcmVkIGFzIGludmlzaWJsZSFcclxuICAgICAgICB2YXIgY2FjaGVBbHBoYSA9IHRoaXMuYWxwaGE7XHJcbiAgICAgICAgdGhpcy5hbHBoYSA9IDE7XHJcbiAgICAgICAgLy8gZmlyc3Qgd2UgZmx1c2ggYW55dGhpbmcgbGVmdCBpbiB0aGUgcmVuZGVyZXIgKG90aGVyd2lzZSBpdCB3b3VsZCBnZXQgcmVuZGVyZWQgdG8gdGhlIGNhY2hlZCB0ZXh0dXJlKVxyXG4gICAgICAgIHJlbmRlcmVyLmJhdGNoLmZsdXNoKCk7XHJcbiAgICAgICAgLy8gdGhpcy5maWx0ZXJzPSBbXTtcclxuICAgICAgICAvLyBuZXh0IHdlIGZpbmQgdGhlIGRpbWVuc2lvbnMgb2YgdGhlIHVudHJhbnNmb3JtZWQgb2JqZWN0XHJcbiAgICAgICAgLy8gdGhpcyBmdW5jdGlvbiBhbHNvIGNhbGxzIHVwZGF0ZXRyYW5zZm9ybSBvbiBhbGwgaXRzIGNoaWxkcmVuIGFzIHBhcnQgb2YgdGhlIG1lYXN1cmluZy5cclxuICAgICAgICAvLyBUaGlzIG1lYW5zIHdlIGRvbid0IG5lZWQgdG8gdXBkYXRlIHRoZSB0cmFuc2Zvcm0gYWdhaW4gaW4gdGhpcyBmdW5jdGlvblxyXG4gICAgICAgIC8vIFRPRE8gcGFzcyBhbiBvYmplY3QgdG8gY2xvbmUgdG9vPyBzYXZlcyBoYXZpbmcgdG8gY3JlYXRlIGEgbmV3IG9uZSBlYWNoIHRpbWUhXHJcbiAgICAgICAgdmFyIGJvdW5kcyA9IHRoaXMuZ2V0TG9jYWxCb3VuZHMoKS5jbG9uZSgpO1xyXG4gICAgICAgIC8vIGFkZCBzb21lIHBhZGRpbmchXHJcbiAgICAgICAgaWYgKHRoaXMuZmlsdGVycykge1xyXG4gICAgICAgICAgICB2YXIgcGFkZGluZyA9IHRoaXMuZmlsdGVyc1swXS5wYWRkaW5nO1xyXG4gICAgICAgICAgICBib3VuZHMucGFkKHBhZGRpbmcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBib3VuZHMuY2VpbChEaXNwbGF5U2V0dGluZ3NfMS5EaXNwbGF5U2V0dGluZ3MuUkVTT0xVVElPTik7XHJcbiAgICAgICAgLy8gZm9yIG5vdyB3ZSBjYWNoZSB0aGUgY3VycmVudCByZW5kZXJUYXJnZXQgdGhhdCB0aGUgV2ViR0wgcmVuZGVyZXIgaXMgY3VycmVudGx5IHVzaW5nLlxyXG4gICAgICAgIC8vIHRoaXMgY291bGQgYmUgbW9yZSBlbGVnYW50Li5cclxuICAgICAgICB2YXIgY2FjaGVkUmVuZGVyVGFyZ2V0ID0gcmVuZGVyZXIuX2FjdGl2ZVJlbmRlclRhcmdldDtcclxuICAgICAgICAvLyBXZSBhbHNvIHN0b3JlIHRoZSBmaWx0ZXIgc3RhY2sgLSBJIHdpbGwgZGVmaW5pdGVseSBsb29rIHRvIGNoYW5nZSBob3cgdGhpcyB3b3JrcyBhIGxpdHRsZSBsYXRlciBkb3duIHRoZSBsaW5lLlxyXG4gICAgICAgIC8vIGNvbnN0IHN0YWNrID0gcmVuZGVyZXIuZmlsdGVyTWFuYWdlci5maWx0ZXJTdGFjaztcclxuICAgICAgICAvLyB0aGlzIHJlbmRlclRleHR1cmUgd2lsbCBiZSB1c2VkIHRvIHN0b3JlIHRoZSBjYWNoZWQgRGlzcGxheU9iamVjdFxyXG4gICAgICAgIHZhciByZW5kZXJUZXh0dXJlID0gUmVuZGVyVGV4dHVyZV8xLlJlbmRlclRleHR1cmUuY3JlYXRlKGJvdW5kcy53aWR0aCwgYm91bmRzLmhlaWdodCk7XHJcbiAgICAgICAgdmFyIHRleHR1cmVDYWNoZUlkID0gXCJjYWNoZUFzQml0bWFwX1wiICsgKE1hdGhTZXR0aW5nc18xLk1hdGhTZXR0aW5ncy51aWQoKSk7XHJcbiAgICAgICAgdGhpcy5fY2FjaGVEYXRhLnRleHR1cmVDYWNoZUlkID0gdGV4dHVyZUNhY2hlSWQ7XHJcbiAgICAgICAgQmFzZVRleHR1cmVfMS5CYXNlVGV4dHVyZS5hZGRUb0NhY2hlKHJlbmRlclRleHR1cmUuYmFzZVRleHR1cmUsIHRleHR1cmVDYWNoZUlkKTtcclxuICAgICAgICBUZXh0dXJlXzEuVGV4dHVyZS5hZGRUb0NhY2hlKHJlbmRlclRleHR1cmUsIHRleHR1cmVDYWNoZUlkKTtcclxuICAgICAgICAvLyBuZWVkIHRvIHNldCAvL1xyXG4gICAgICAgIHZhciBtID0gRGlzcGxheU9iamVjdC5fdGVtcE1hdHJpeDtcclxuICAgICAgICBtLnR4ID0gLWJvdW5kcy54O1xyXG4gICAgICAgIG0udHkgPSAtYm91bmRzLnk7XHJcbiAgICAgICAgLy8gcmVzZXRcclxuICAgICAgICB0aGlzLnRyYW5zZm9ybS53b3JsZFRyYW5zZm9ybS5pZGVudGl0eSgpO1xyXG4gICAgICAgIC8vIHNldCBhbGwgcHJvcGVydGllcyB0byB0aGVyZSBvcmlnaW5hbCBzbyB3ZSBjYW4gcmVuZGVyIHRvIGEgdGV4dHVyZVxyXG4gICAgICAgIHRoaXMucmVuZGVyID0gdGhpcy5fY2FjaGVEYXRhLm9yaWdpbmFsUmVuZGVyO1xyXG4gICAgICAgIHJlbmRlcmVyLnJlbmRlcih0aGlzLCByZW5kZXJUZXh0dXJlLCB0cnVlLCBtLCB0cnVlKTtcclxuICAgICAgICAvLyBub3cgcmVzdG9yZSB0aGUgc3RhdGUgYmUgc2V0dGluZyB0aGUgbmV3IHByb3BlcnRpZXNcclxuICAgICAgICByZW5kZXJlci5yZW5kZXJUZXh0dXJlLmJpbmQoY2FjaGVkUmVuZGVyVGFyZ2V0KTtcclxuICAgICAgICAvLyByZW5kZXJlci5maWx0ZXJNYW5hZ2VyLmZpbHRlclN0YWNrID0gc3RhY2s7XHJcbiAgICAgICAgdGhpcy5yZW5kZXIgPSB0aGlzLl9yZW5kZXJDYWNoZWQ7XHJcbiAgICAgICAgLy8gdGhlIHJlc3QgaXMgdGhlIHNhbWUgYXMgZm9yIENhbnZhc1xyXG4gICAgICAgIHRoaXMudXBkYXRlVHJhbnNmb3JtID0gdGhpcy5kaXNwbGF5T2JqZWN0VXBkYXRlVHJhbnNmb3JtO1xyXG4gICAgICAgIHRoaXMuY2FsY3VsYXRlQm91bmRzID0gdGhpcy5fY2FsY3VsYXRlQ2FjaGVkQm91bmRzO1xyXG4gICAgICAgIHRoaXMuZ2V0TG9jYWxCb3VuZHMgPSB0aGlzLl9nZXRDYWNoZWRMb2NhbEJvdW5kcztcclxuICAgICAgICB0aGlzLl9tYXNrID0gbnVsbDtcclxuICAgICAgICB0aGlzLmZpbHRlckFyZWEgPSBudWxsO1xyXG4gICAgICAgIC8vIGNyZWF0ZSBvdXIgY2FjaGVkIHNwcml0ZVxyXG4gICAgICAgIHZhciBjYWNoZWRTcHJpdGU7IC8vID0gbmV3IFNwcml0ZShyZW5kZXJUZXh0dXJlKTtcclxuICAgICAgICBjYWNoZWRTcHJpdGUudHJhbnNmb3JtLndvcmxkVHJhbnNmb3JtID0gdGhpcy50cmFuc2Zvcm0ud29ybGRUcmFuc2Zvcm07XHJcbiAgICAgICAgY2FjaGVkU3ByaXRlLmFuY2hvci54ID0gLShib3VuZHMueCAvIGJvdW5kcy53aWR0aCk7XHJcbiAgICAgICAgY2FjaGVkU3ByaXRlLmFuY2hvci55ID0gLShib3VuZHMueSAvIGJvdW5kcy5oZWlnaHQpO1xyXG4gICAgICAgIGNhY2hlZFNwcml0ZS5hbHBoYSA9IGNhY2hlQWxwaGE7XHJcbiAgICAgICAgY2FjaGVkU3ByaXRlLl9ib3VuZHMgPSB0aGlzLl9ib3VuZHM7XHJcbiAgICAgICAgdGhpcy5fY2FjaGVEYXRhLnNwcml0ZSA9IGNhY2hlZFNwcml0ZTtcclxuICAgICAgICB0aGlzLnRyYW5zZm9ybS5fcGFyZW50SUQgPSAtMTtcclxuICAgICAgICAvLyByZXN0b3JlIHRoZSB0cmFuc2Zvcm0gb2YgdGhlIGNhY2hlZCBzcHJpdGUgdG8gYXZvaWQgdGhlIG5hc3R5IGZsaWNrZXIuLlxyXG4gICAgICAgIGlmICghdGhpcy5wYXJlbnQpIHtcclxuICAgICAgICAgICAgdGhpcy5wYXJlbnQgPSByZW5kZXJlci5fdGVtcERpc3BsYXlPYmplY3RQYXJlbnQ7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVHJhbnNmb3JtKCk7XHJcbiAgICAgICAgICAgIHRoaXMucGFyZW50ID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVHJhbnNmb3JtKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIG1hcCB0aGUgaGl0IHRlc3QuLlxyXG4gICAgICAgIHRoaXMuY29udGFpbnNQb2ludCA9IGNhY2hlZFNwcml0ZS5jb250YWluc1BvaW50LmJpbmQoY2FjaGVkU3ByaXRlKTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gKiBSZW5kZXJzIGEgY2FjaGVkIHZlcnNpb24gb2YgdGhlIHNwcml0ZSB3aXRoIGNhbnZhc1xyXG4gKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAZnVuY3Rpb24gX3JlbmRlckNhY2hlZENhbnZhc1xyXG4gKiBAbWVtYmVyb2YgUElYSS5EaXNwbGF5T2JqZWN0I1xyXG4gKiBAcGFyYW0ge1BJWEkuUmVuZGVyZXJ9IHJlbmRlcmVyIC0gdGhlIFdlYkdMIHJlbmRlcmVyXHJcbiAqL1xyXG4gICAgX3JlbmRlckNhY2hlZENhbnZhcyhyZW5kZXJlcikge1xyXG4gICAgICAgIGlmICghdGhpcy52aXNpYmxlIHx8IHRoaXMud29ybGRBbHBoYSA8PSAwIHx8ICF0aGlzLnJlbmRlcmFibGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9pbml0Q2FjaGVkRGlzcGxheU9iamVjdENhbnZhcyhyZW5kZXJlcik7XHJcbiAgICAgICAgdGhpcy5fY2FjaGVEYXRhLnNwcml0ZS53b3JsZEFscGhhID0gdGhpcy53b3JsZEFscGhhO1xyXG4gICAgICAgIHRoaXMuX2NhY2hlRGF0YS5zcHJpdGUuX3JlbmRlckNhbnZhcyhyZW5kZXJlcik7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvLyBUT0RPIHRoaXMgY2FuIGJlIHRoZSBzYW1lIGFzIHRoZSBXZWJHTCB2ZXJzaW9uLi4gd2lsbCBuZWVkIHRvIGRvIGEgbGl0dGxlIHR3ZWFraW5nIGZpcnN0IHRob3VnaC4uXHJcbiAgICAvKipcclxuICAgICAqIFByZXBhcmVzIHRoZSBDYW52YXMgcmVuZGVyZXIgdG8gY2FjaGUgdGhlIHNwcml0ZVxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAZnVuY3Rpb24gX2luaXRDYWNoZWREaXNwbGF5T2JqZWN0Q2FudmFzXHJcbiAgICAgKiBAbWVtYmVyb2YgUElYSS5EaXNwbGF5T2JqZWN0I1xyXG4gICAgICogQHBhcmFtIHtQSVhJLlJlbmRlcmVyfSByZW5kZXJlciAtIHRoZSBXZWJHTCByZW5kZXJlclxyXG4gICAgICovXHJcbiAgICBfaW5pdENhY2hlZERpc3BsYXlPYmplY3RDYW52YXMocmVuZGVyZXIpIHtcclxuICAgICAgICBpZiAodGhpcy5fY2FjaGVEYXRhICYmIHRoaXMuX2NhY2hlRGF0YS5zcHJpdGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBnZXQgYm91bmRzIGFjdHVhbGx5IHRyYW5zZm9ybXMgdGhlIG9iamVjdCBmb3IgdXMgYWxyZWFkeSFcclxuICAgICAgICB2YXIgYm91bmRzID0gdGhpcy5nZXRMb2NhbEJvdW5kcygpO1xyXG4gICAgICAgIHZhciBjYWNoZUFscGhhID0gdGhpcy5hbHBoYTtcclxuICAgICAgICB0aGlzLmFscGhhID0gMTtcclxuICAgICAgICB2YXIgY2FjaGVkUmVuZGVyVGFyZ2V0ID0gcmVuZGVyZXIuY29udGV4dDtcclxuICAgICAgICBib3VuZHMuY2VpbChEaXNwbGF5U2V0dGluZ3NfMS5EaXNwbGF5U2V0dGluZ3MuUkVTT0xVVElPTik7XHJcbiAgICAgICAgdmFyIHJlbmRlclRleHR1cmUgPSBSZW5kZXJUZXh0dXJlXzEuUmVuZGVyVGV4dHVyZS5jcmVhdGUoYm91bmRzLndpZHRoLCBib3VuZHMuaGVpZ2h0KTtcclxuICAgICAgICB2YXIgdGV4dHVyZUNhY2hlSWQgPSBcImNhY2hlQXNCaXRtYXBfXCIgKyAoTWF0aFNldHRpbmdzXzEuTWF0aFNldHRpbmdzLnVpZCgpKTtcclxuICAgICAgICB0aGlzLl9jYWNoZURhdGEudGV4dHVyZUNhY2hlSWQgPSB0ZXh0dXJlQ2FjaGVJZDtcclxuICAgICAgICBCYXNlVGV4dHVyZV8xLkJhc2VUZXh0dXJlLmFkZFRvQ2FjaGUocmVuZGVyVGV4dHVyZS5iYXNlVGV4dHVyZSwgdGV4dHVyZUNhY2hlSWQpO1xyXG4gICAgICAgIFRleHR1cmVfMS5UZXh0dXJlLmFkZFRvQ2FjaGUocmVuZGVyVGV4dHVyZSwgdGV4dHVyZUNhY2hlSWQpO1xyXG4gICAgICAgIC8vIG5lZWQgdG8gc2V0IC8vXHJcbiAgICAgICAgdmFyIG0gPSBEaXNwbGF5T2JqZWN0Ll90ZW1wTWF0cml4O1xyXG4gICAgICAgIHRoaXMudHJhbnNmb3JtLmxvY2FsVHJhbnNmb3JtLmNvcHlUbyhtKTtcclxuICAgICAgICBtLmludmVydCgpO1xyXG4gICAgICAgIG0udHggLT0gYm91bmRzLng7XHJcbiAgICAgICAgbS50eSAtPSBib3VuZHMueTtcclxuICAgICAgICAvLyBtLmFwcGVuZCh0aGlzLnRyYW5zZm9ybS53b3JsZFRyYW5zZm9ybS4pXHJcbiAgICAgICAgLy8gc2V0IGFsbCBwcm9wZXJ0aWVzIHRvIHRoZXJlIG9yaWdpbmFsIHNvIHdlIGNhbiByZW5kZXIgdG8gYSB0ZXh0dXJlXHJcbiAgICAgICAgdGhpcy5yZW5kZXJDYW52YXMgPSB0aGlzLl9jYWNoZURhdGEub3JpZ2luYWxSZW5kZXJDYW52YXM7XHJcbiAgICAgICAgLy8gcmVuZGVyVGV4dHVyZS5yZW5kZXIodGhpcywgbSwgdHJ1ZSk7XHJcbiAgICAgICAgcmVuZGVyZXIucmVuZGVyKHRoaXMsIHJlbmRlclRleHR1cmUsIHRydWUsIG0sIGZhbHNlKTtcclxuICAgICAgICAvLyBub3cgcmVzdG9yZSB0aGUgc3RhdGUgYmUgc2V0dGluZyB0aGUgbmV3IHByb3BlcnRpZXNcclxuICAgICAgICByZW5kZXJlci5jb250ZXh0ID0gY2FjaGVkUmVuZGVyVGFyZ2V0O1xyXG4gICAgICAgIHRoaXMucmVuZGVyQ2FudmFzID0gdGhpcy5fcmVuZGVyQ2FjaGVkQ2FudmFzO1xyXG4gICAgICAgIC8vIHRoZSByZXN0IGlzIHRoZSBzYW1lIGFzIGZvciBXZWJHTFxyXG4gICAgICAgIHRoaXMudXBkYXRlVHJhbnNmb3JtID0gdGhpcy5kaXNwbGF5T2JqZWN0VXBkYXRlVHJhbnNmb3JtO1xyXG4gICAgICAgIHRoaXMuY2FsY3VsYXRlQm91bmRzID0gdGhpcy5fY2FsY3VsYXRlQ2FjaGVkQm91bmRzO1xyXG4gICAgICAgIHRoaXMuZ2V0TG9jYWxCb3VuZHMgPSB0aGlzLl9nZXRDYWNoZWRMb2NhbEJvdW5kcztcclxuICAgICAgICB0aGlzLl9tYXNrID0gbnVsbDtcclxuICAgICAgICB0aGlzLmZpbHRlckFyZWEgPSBudWxsO1xyXG4gICAgICAgIC8vIGNyZWF0ZSBvdXIgY2FjaGVkIHNwcml0ZVxyXG4gICAgICAgIHZhciBjYWNoZWRTcHJpdGU7IC8vPSBuZXcgU3ByaXRlKHJlbmRlclRleHR1cmUpO1xyXG4gICAgICAgIGNhY2hlZFNwcml0ZS50cmFuc2Zvcm0ud29ybGRUcmFuc2Zvcm0gPSB0aGlzLnRyYW5zZm9ybS53b3JsZFRyYW5zZm9ybTtcclxuICAgICAgICBjYWNoZWRTcHJpdGUuYW5jaG9yLnggPSAtKGJvdW5kcy54IC8gYm91bmRzLndpZHRoKTtcclxuICAgICAgICBjYWNoZWRTcHJpdGUuYW5jaG9yLnkgPSAtKGJvdW5kcy55IC8gYm91bmRzLmhlaWdodCk7XHJcbiAgICAgICAgY2FjaGVkU3ByaXRlLmFscGhhID0gY2FjaGVBbHBoYTtcclxuICAgICAgICBjYWNoZWRTcHJpdGUuX2JvdW5kcyA9IHRoaXMuX2JvdW5kcztcclxuICAgICAgICB0aGlzLl9jYWNoZURhdGEuc3ByaXRlID0gY2FjaGVkU3ByaXRlO1xyXG4gICAgICAgIHRoaXMudHJhbnNmb3JtLl9wYXJlbnRJRCA9IC0xO1xyXG4gICAgICAgIC8vIHJlc3RvcmUgdGhlIHRyYW5zZm9ybSBvZiB0aGUgY2FjaGVkIHNwcml0ZSB0byBhdm9pZCB0aGUgbmFzdHkgZmxpY2tlci4uXHJcbiAgICAgICAgaWYgKCF0aGlzLnBhcmVudCkge1xyXG4gICAgICAgICAgICB0aGlzLnBhcmVudCA9IHJlbmRlcmVyLl90ZW1wRGlzcGxheU9iamVjdFBhcmVudDtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVUcmFuc2Zvcm0oKTtcclxuICAgICAgICAgICAgdGhpcy5wYXJlbnQgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVUcmFuc2Zvcm0oKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gbWFwIHRoZSBoaXQgdGVzdC4uXHJcbiAgICAgICAgdGhpcy5jb250YWluc1BvaW50ID0gY2FjaGVkU3ByaXRlLmNvbnRhaW5zUG9pbnQuYmluZChjYWNoZWRTcHJpdGUpO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgcmVuZGVyQ2FudmFzKHJlbmRlcmVyKSB7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENhbGN1bGF0ZXMgdGhlIGJvdW5kcyBvZiB0aGUgY2FjaGVkIHNwcml0ZVxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIF9jYWxjdWxhdGVDYWNoZWRCb3VuZHMoKSB7XHJcbiAgICAgICAgdGhpcy5fYm91bmRzLmNsZWFyKCk7XHJcbiAgICAgICAgdGhpcy5fY2FjaGVEYXRhLnNwcml0ZS50cmFuc2Zvcm0uX3dvcmxkSUQgPSB0aGlzLnRyYW5zZm9ybS5fd29ybGRJRDtcclxuICAgICAgICB0aGlzLl9jYWNoZURhdGEuc3ByaXRlLl9jYWxjdWxhdGVCb3VuZHMoKTtcclxuICAgICAgICB0aGlzLl9sYXN0Qm91bmRzSUQgPSB0aGlzLl9ib3VuZHNJRDtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgYm91bmRzIG9mIHRoZSBjYWNoZWQgc3ByaXRlLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcmV0dXJuIHtSZWN0YW5nbGV9IFRoZSBsb2NhbCBib3VuZHMuXHJcbiAgICAgKi9cclxuICAgIF9nZXRDYWNoZWRMb2NhbEJvdW5kcygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fY2FjaGVEYXRhLnNwcml0ZS5nZXRMb2NhbEJvdW5kcygpO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBEZXN0cm95cyB0aGUgY2FjaGVkIHNwcml0ZS5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBfZGVzdHJveUNhY2hlZERpc3BsYXlPYmplY3QoKSB7XHJcbiAgICAgICAgdGhpcy5fY2FjaGVEYXRhLnNwcml0ZS5fdGV4dHVyZS5kZXN0cm95KHRydWUpO1xyXG4gICAgICAgIHRoaXMuX2NhY2hlRGF0YS5zcHJpdGUgPSBudWxsO1xyXG4gICAgICAgIEJhc2VUZXh0dXJlXzEuQmFzZVRleHR1cmUucmVtb3ZlRnJvbUNhY2hlKHRoaXMuX2NhY2hlRGF0YS50ZXh0dXJlQ2FjaGVJZCk7XHJcbiAgICAgICAgVGV4dHVyZV8xLlRleHR1cmUucmVtb3ZlRnJvbUNhY2hlKHRoaXMuX2NhY2hlRGF0YS50ZXh0dXJlQ2FjaGVJZCk7XHJcbiAgICAgICAgdGhpcy5fY2FjaGVEYXRhLnRleHR1cmVDYWNoZUlkID0gbnVsbDtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gKiBEZXN0cm95cyB0aGUgY2FjaGVkIG9iamVjdC5cclxuICpcclxuICogQHByaXZhdGVcclxuICogQHBhcmFtIHtvYmplY3R8Ym9vbGVhbn0gW29wdGlvbnNdIC0gT3B0aW9ucyBwYXJhbWV0ZXIuIEEgYm9vbGVhbiB3aWxsIGFjdCBhcyBpZiBhbGwgb3B0aW9uc1xyXG4gKiAgaGF2ZSBiZWVuIHNldCB0byB0aGF0IHZhbHVlLlxyXG4gKiAgVXNlZCB3aGVuIGRlc3Ryb3lpbmcgY29udGFpbmVycywgc2VlIHRoZSBDb250YWluZXIuZGVzdHJveSBtZXRob2QuXHJcbiAqL1xyXG4gICAgX2NhY2hlQXNCaXRtYXBEZXN0cm95KG9wdGlvbnMpIHtcclxuICAgICAgICB0aGlzLmNhY2hlQXNCaXRtYXAgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmRlc3Ryb3kob3B0aW9ucyk7XHJcbiAgICB9XHJcbiAgICA7XHJcbn1cclxuRGlzcGxheU9iamVjdC5fdGVtcE1hdHJpeCA9IG5ldyBNYXRyaXhfMS5NYXRyaXgoKTtcclxuZXhwb3J0cy5EaXNwbGF5T2JqZWN0ID0gRGlzcGxheU9iamVjdDtcclxuLy8gZmlndXJlZCB0aGVyZXMgbm8gcG9pbnQgYWRkaW5nIEFMTCB0aGUgZXh0cmEgdmFyaWFibGVzIHRvIHByb3RvdHlwZS5cclxuLy8gdGhpcyBtb2RlbCBjYW4gaG9sZCB0aGUgaW5mb3JtYXRpb24gbmVlZGVkLiBUaGlzIGNhbiBhbHNvIGJlIGdlbmVyYXRlZCBvbiBkZW1hbmQgYXNcclxuLy8gbW9zdCBvYmplY3RzIGFyZSBub3QgY2FjaGVkIGFzIGJpdG1hcHMuXHJcbi8qKlxyXG4gKiBAY2xhc3NcclxuICogQGlnbm9yZVxyXG4gKi9cclxuY2xhc3MgQ2FjaGVEYXRhIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMudGV4dHVyZUNhY2hlSWQgPSBudWxsO1xyXG4gICAgICAgIHRoaXMub3JpZ2luYWxSZW5kZXIgPSBudWxsO1xyXG4gICAgICAgIHRoaXMub3JpZ2luYWxSZW5kZXJDYW52YXMgPSBudWxsO1xyXG4gICAgICAgIHRoaXMub3JpZ2luYWxDYWxjdWxhdGVCb3VuZHMgPSBudWxsO1xyXG4gICAgICAgIHRoaXMub3JpZ2luYWxHZXRMb2NhbEJvdW5kcyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5vcmlnaW5hbFVwZGF0ZVRyYW5zZm9ybSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5vcmlnaW5hbEhpdFRlc3QgPSBudWxsO1xyXG4gICAgICAgIHRoaXMub3JpZ2luYWxEZXN0cm95ID0gbnVsbDtcclxuICAgICAgICB0aGlzLm9yaWdpbmFsTWFzayA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5vcmlnaW5hbEZpbHRlckFyZWEgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuc3ByaXRlID0gbnVsbDtcclxuICAgIH1cclxufVxyXG47XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNsYXNzIERpc3BsYXlTZXR0aW5ncyB7XHJcbn1cclxuRGlzcGxheVNldHRpbmdzLlNPUlRBQkxFX0NISUxEUkVOID0gZmFsc2U7XHJcbkRpc3BsYXlTZXR0aW5ncy5DUkVBVEVfSU1BR0VfQklUTUFQID0gdHJ1ZTtcclxuRGlzcGxheVNldHRpbmdzLlJFTkRFUkVSX1RZUEUgPSB7XHJcbiAgICBVTktOT1dOOiAwLFxyXG4gICAgV0VCR0w6IDEsXHJcbiAgICBDQU5WQVM6IDIsXHJcbn07XHJcbkRpc3BsYXlTZXR0aW5ncy5FTlYgPSB7XHJcbiAgICBXRUJHTF9MRUdBQ1k6IDAsXHJcbiAgICBXRUJHTDogMSxcclxuICAgIFdFQkdMMjogMixcclxufTtcclxuRGlzcGxheVNldHRpbmdzLlJFU09MVVRJT04gPSAxO1xyXG5EaXNwbGF5U2V0dGluZ3MuU0NBTEVfTU9ERSA9IDE7XHJcbkRpc3BsYXlTZXR0aW5ncy5ST1VORF9QSVhFTFMgPSBmYWxzZTtcclxuRGlzcGxheVNldHRpbmdzLlBSRUZFUl9FTlYgPSBEaXNwbGF5U2V0dGluZ3MuRU5WLldFQkdMO1xyXG5leHBvcnRzLkRpc3BsYXlTZXR0aW5ncyA9IERpc3BsYXlTZXR0aW5ncztcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY2xhc3MgRHJhd01vZGVTZXR0aW5ncyB7XHJcbn1cclxuLyoqXHJcbiogVmFyaW91cyB3ZWJnbCBkcmF3IG1vZGVzLiBUaGVzZSBjYW4gYmUgdXNlZCB0byBzcGVjaWZ5IHdoaWNoIEdMIGRyYXdNb2RlIHRvIHVzZVxyXG4qIHVuZGVyIGNlcnRhaW4gc2l0dWF0aW9ucyBhbmQgcmVuZGVyZXJzLlxyXG4qXHJcbiogQG1lbWJlcm9mIFBJWElcclxuKiBAc3RhdGljXHJcbiogQG5hbWUgRFJBV19NT0RFU1xyXG4qIEBlbnVtIHtudW1iZXJ9XHJcbiogQHByb3BlcnR5IHtudW1iZXJ9IFBPSU5UU1xyXG4qIEBwcm9wZXJ0eSB7bnVtYmVyfSBMSU5FU1xyXG4qIEBwcm9wZXJ0eSB7bnVtYmVyfSBMSU5FX0xPT1BcclxuKiBAcHJvcGVydHkge251bWJlcn0gTElORV9TVFJJUFxyXG4qIEBwcm9wZXJ0eSB7bnVtYmVyfSBUUklBTkdMRVNcclxuKiBAcHJvcGVydHkge251bWJlcn0gVFJJQU5HTEVfU1RSSVBcclxuKiBAcHJvcGVydHkge251bWJlcn0gVFJJQU5HTEVfRkFOXHJcbiovXHJcbkRyYXdNb2RlU2V0dGluZ3MuRFJBV19NT0RFUyA9IHtcclxuICAgIFBPSU5UUzogMCxcclxuICAgIExJTkVTOiAxLFxyXG4gICAgTElORV9MT09QOiAyLFxyXG4gICAgTElORV9TVFJJUDogMyxcclxuICAgIFRSSUFOR0xFUzogNCxcclxuICAgIFRSSUFOR0xFX1NUUklQOiA1LFxyXG4gICAgVFJJQU5HTEVfRkFOOiA2LFxyXG59O1xyXG5leHBvcnRzLkRyYXdNb2RlU2V0dGluZ3MgPSBEcmF3TW9kZVNldHRpbmdzO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBSZWN0YW5nbGVfMSA9IHJlcXVpcmUoXCIuL1JlY3RhbmdsZVwiKTtcclxuY29uc3QgU2hhcGVTZXR0aW5nc18xID0gcmVxdWlyZShcIi4vU2hhcGVTZXR0aW5nc1wiKTtcclxuY2xhc3MgRWxsaXBzZSB7XHJcbiAgICBjb25zdHJ1Y3Rvcih4ID0gMCwgeSA9IDAsIGhhbGZXaWR0aCA9IDAsIGhhbGZIZWlnaHQgPSAwKSB7XHJcbiAgICAgICAgaWYgKHggPT09IHZvaWQgMCkge1xyXG4gICAgICAgICAgICB4ID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHkgPT09IHZvaWQgMCkge1xyXG4gICAgICAgICAgICB5ID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGhhbGZXaWR0aCA9PT0gdm9pZCAwKSB7XHJcbiAgICAgICAgICAgIGhhbGZXaWR0aCA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChoYWxmSGVpZ2h0ID09PSB2b2lkIDApIHtcclxuICAgICAgICAgICAgaGFsZkhlaWdodCA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAgICAgKiBAZGVmYXVsdCAwXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy54ID0geDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgICAgICogQGRlZmF1bHQgMFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMueSA9IHk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICAgICAqIEBkZWZhdWx0IDBcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLndpZHRoID0gaGFsZldpZHRoO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAgICAgKiBAZGVmYXVsdCAwXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoYWxmSGVpZ2h0O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSB0eXBlIG9mIHRoZSBvYmplY3QsIG1haW5seSB1c2VkIHRvIGF2b2lkIGBpbnN0YW5jZW9mYCBjaGVja3NcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAgICAgKiBAcmVhZE9ubHlcclxuICAgICAgICAgKiBAZGVmYXVsdCBQSVhJLlNIQVBFUy5FTElQXHJcbiAgICAgICAgICogQHNlZSBQSVhJLlNIQVBFU1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMudHlwZSA9IFNoYXBlU2V0dGluZ3NfMS5TaGFwZVNldHRpbmdzLlNIQVBFUy5FTElQO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgdGhpcyBFbGxpcHNlIGluc3RhbmNlXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiB7UElYSS5FbGxpcHNlfSBhIGNvcHkgb2YgdGhlIGVsbGlwc2VcclxuICAgICAqL1xyXG4gICAgY2xvbmUoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBFbGxpcHNlKHRoaXMueCwgdGhpcy55LCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSB4IGFuZCB5IGNvb3JkaW5hdGVzIGdpdmVuIGFyZSBjb250YWluZWQgd2l0aGluIHRoaXMgZWxsaXBzZVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQgdG8gdGVzdFxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgLSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBwb2ludCB0byB0ZXN0XHJcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSB4L3kgY29vcmRzIGFyZSB3aXRoaW4gdGhpcyBlbGxpcHNlXHJcbiAgICAgKi9cclxuICAgIGNvbnRhaW5zKHgsIHkpIHtcclxuICAgICAgICBpZiAodGhpcy53aWR0aCA8PSAwIHx8IHRoaXMuaGVpZ2h0IDw9IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBub3JtYWxpemUgdGhlIGNvb3JkcyB0byBhbiBlbGxpcHNlIHdpdGggY2VudGVyIDAsMFxyXG4gICAgICAgIHZhciBub3JteCA9ICgoeCAtIHRoaXMueCkgLyB0aGlzLndpZHRoKTtcclxuICAgICAgICB2YXIgbm9ybXkgPSAoKHkgLSB0aGlzLnkpIC8gdGhpcy5oZWlnaHQpO1xyXG4gICAgICAgIG5vcm14ICo9IG5vcm14O1xyXG4gICAgICAgIG5vcm15ICo9IG5vcm15O1xyXG4gICAgICAgIHJldHVybiAobm9ybXggKyBub3JteSA8PSAxKTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgZnJhbWluZyByZWN0YW5nbGUgb2YgdGhlIGVsbGlwc2UgYXMgYSBSZWN0YW5nbGUgb2JqZWN0XHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiB7UElYSS5SZWN0YW5nbGV9IHRoZSBmcmFtaW5nIHJlY3RhbmdsZVxyXG4gICAgICovXHJcbiAgICBnZXRCb3VuZHMoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBSZWN0YW5nbGVfMS5SZWN0YW5nbGUodGhpcy54IC0gdGhpcy53aWR0aCwgdGhpcy55IC0gdGhpcy5oZWlnaHQsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcclxuICAgIH1cclxuICAgIDtcclxufVxyXG5leHBvcnRzLkVsbGlwc2UgPSBFbGxpcHNlO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBGbGFzaEJhc2VPYmplY3RfMSA9IHJlcXVpcmUoXCIuL0ZsYXNoQmFzZU9iamVjdFwiKTtcclxuY2xhc3MgRXZlbnQgZXh0ZW5kcyBGbGFzaEJhc2VPYmplY3RfMS5GbGFzaEJhc2VPYmplY3Qge1xyXG4gICAgY29uc3RydWN0b3IodHlwZSwgYnViYmxlID0gdHJ1ZSwgY2FuY2VsYWJsZSA9IHRydWUpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMucmVzZXQodHlwZSwgYnViYmxlLCBjYW5jZWxhYmxlKTtcclxuICAgIH1cclxuICAgIGdldCBjdXJyZW50VGFyZ2V0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9jdXJyZW50VGFyZ2V0O1xyXG4gICAgfVxyXG4gICAgc2V0Q3VycmVudFRhcmdldCh2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuX2N1cnJlbnRUYXJnZXQgPSB2YWx1ZTtcclxuICAgIH1cclxuICAgIGdldCB0eXBlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl90eXBlO1xyXG4gICAgfVxyXG4gICAgZ2V0IGNhbmNlbGFibGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhbmNlbGFibGU7XHJcbiAgICB9XHJcbiAgICBnZXQgYnViYmxlcygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fYnViYmxlcztcclxuICAgIH1cclxuICAgIGdldCBldmVudFBoYXNlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9ldmVudFBoYXNlO1xyXG4gICAgfVxyXG4gICAgY2xvbmUoKSB7XHJcbiAgICAgICAgcmV0dXJuIEV2ZW50LmdldEV2ZW50KHRoaXMuX3R5cGUsIHRoaXMuX2J1YmJsZXMsIHRoaXMuX2NhbmNlbGFibGUpO1xyXG4gICAgfVxyXG4gICAgcmVzZXQodHlwZSwgYnViYmxlID0gdHJ1ZSwgY2FuY2VsYWJsZSA9IHRydWUpIHtcclxuICAgICAgICB0aGlzLl90eXBlID0gdHlwZTtcclxuICAgICAgICB0aGlzLl9idWJibGVzID0gYnViYmxlO1xyXG4gICAgICAgIHRoaXMuX2NhbmNlbGFibGUgPSBjYW5jZWxhYmxlO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGdldEV2ZW50KHR5cGUsIGJ1YmJsZSA9IHRydWUsIGNhbmNlbGFibGUgPSB0cnVlKSB7XHJcbiAgICAgICAgaWYgKEV2ZW50LkV2ZW50Q2FjaGUubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGxldCB0ZSA9IEV2ZW50LkV2ZW50Q2FjaGVbRXZlbnQuRXZlbnRDYWNoZS5sZW5ndGggLSAxXTtcclxuICAgICAgICAgICAgRXZlbnQuRXZlbnRDYWNoZS5sZW5ndGggLT0gMTtcclxuICAgICAgICAgICAgdGUucmVzZXQodHlwZSwgYnViYmxlLCBjYW5jZWxhYmxlKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IEV2ZW50KHR5cGUsIGJ1YmJsZSwgY2FuY2VsYWJsZSk7XHJcbiAgICB9XHJcbiAgICBkZXN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMuX2N1cnJlbnRUYXJnZXQgPSBudWxsO1xyXG4gICAgICAgIGxldCBpbmRleCA9IEV2ZW50LkV2ZW50Q2FjaGUuaW5kZXhPZih0aGlzKTtcclxuICAgICAgICBpZiAoaW5kZXggPCAwKSB7XHJcbiAgICAgICAgICAgIEV2ZW50LkV2ZW50Q2FjaGUucHVzaCh0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXQgaXNEaXNwb3NhYmxlKCkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgc3RvcFByb3BhZ2F0aW9uKCkge1xyXG4gICAgfVxyXG4gICAgc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCkge1xyXG4gICAgfVxyXG4gICAgcHJldmVudERlZmF1bHQoKSB7XHJcbiAgICB9XHJcbn1cclxuRXZlbnQuQURERURfVE9fU1RBR0UgPSBcImFkZGVkVG9TdGFnZVwiO1xyXG5FdmVudC5BRERFRCA9IFwiYWRkZWRcIjtcclxuRXZlbnQuRU5URVJfRlJBTUUgPSBcImVudGVyRnJhbWVcIjtcclxuRXZlbnQuRVhJVF9GUkFNRSA9IFwiZXhpdEZyYW1lXCI7XHJcbkV2ZW50LkZSQU1FX0NPTlNUUlVDVEVEID0gXCJmcmFtZUNvbnN0cnVjdGVkXCI7XHJcbkV2ZW50LlJFTU9WRUQgPSBcInJlbW92ZWRcIjtcclxuRXZlbnQuUkVNT1ZFRF9GUk9NX1NUQUdFID0gXCJyZW1vdmVkRnJvbVN0YWdlXCI7XHJcbkV2ZW50LlJFTkRFUiA9IFwicmVuZGVyXCI7XHJcbkV2ZW50LkNPTVBMRVRFID0gXCJjb21wbGV0ZVwiO1xyXG5FdmVudC5JTklUID0gXCJpbml0XCI7XHJcbkV2ZW50Lk9QRU4gPSBcIm9wZW5cIjtcclxuRXZlbnQuVU5MT0FEID0gXCJ1bmxvYWRcIjtcclxuRXZlbnQuQ0xFQVIgPSBcImNsZWFyXCI7XHJcbkV2ZW50LlNPVU5EX0NPTVBMRVRFID0gXCJzb3VuZENvbXBsZXRlXCI7XHJcbkV2ZW50LlNPVU5EX1NUQVJURUQgPSBcInNvdW5kU3RhcnRlZFwiO1xyXG5FdmVudC5BQ1RJVkFURSA9IFwiYWN0aXZhdGVcIjtcclxuRXZlbnQuREVBQ1RJVkFURSA9IFwiZGVzYWN0aXZhdGVcIjtcclxuRXZlbnQuUkVTSVpFID0gXCJyZXNpemVcIjtcclxuRXZlbnQuQ0hBTkdFID0gXCJjaGFuZ2VcIjtcclxuRXZlbnQuRXZlbnRDYWNoZSA9IFtdO1xyXG5leHBvcnRzLkV2ZW50ID0gRXZlbnQ7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IEZsYXNoQmFzZU9iamVjdF8xID0gcmVxdWlyZShcIi4vRmxhc2hCYXNlT2JqZWN0XCIpO1xyXG5jbGFzcyBFdmVudERpc3BhdGNoZXIgZXh0ZW5kcyBGbGFzaEJhc2VPYmplY3RfMS5GbGFzaEJhc2VPYmplY3Qge1xyXG4gICAgY29uc3RydWN0b3IodGFyZ2V0ID0gbnVsbCkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5yZWdpc3RlcmVkTGlzdGVuZXJzID0ge307XHJcbiAgICB9XHJcbiAgICByZW1vdmVMaXN0ZW5lcnMoKSB7XHJcbiAgICAgICAgZm9yICh2YXIgaSBpbiB0aGlzLnJlZ2lzdGVyZWRMaXN0ZW5lcnMpIHtcclxuICAgICAgICAgICAgdmFyIG1ldGhvZHMgPSB0aGlzLnJlZ2lzdGVyZWRMaXN0ZW5lcnNbaV07XHJcbiAgICAgICAgICAgIHdoaWxlIChtZXRob2RzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgbGV0IG1zID0gbWV0aG9kcy5zaGlmdCgpO1xyXG4gICAgICAgICAgICAgICAgbXMuZGVzdHJ1Y3RvcigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnJlZ2lzdGVyZWRMaXN0ZW5lcnNbaV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMucmVnaXN0ZXJlZExpc3RlbmVycyA9IHt9O1xyXG4gICAgfVxyXG4gICAgZGVzdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlci5kZXN0cnVjdG9yKCk7XHJcbiAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcnMoKTtcclxuICAgIH1cclxuICAgIHdpbGxUcmlnZ2VyKHR5cGUpIHtcclxuICAgICAgICBpZiAodGhpcy5yZWdpc3RlcmVkTGlzdGVuZXJzW3R5cGVdICE9IG51bGwpIHtcclxuICAgICAgICAgICAgdmFyIG1ldGhvZHMgPSB0aGlzLnJlZ2lzdGVyZWRMaXN0ZW5lcnNbdHlwZV07XHJcbiAgICAgICAgICAgIGlmIChtZXRob2RzICYmIG1ldGhvZHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIsIHVzZUNhcHR1cmUgPSBmYWxzZSkge1xyXG4gICAgICAgIGlmICh0aGlzLnJlZ2lzdGVyZWRMaXN0ZW5lcnNbdHlwZV0gIT0gbnVsbCkge1xyXG4gICAgICAgICAgICB2YXIgbWV0aG9kcyA9IHRoaXMucmVnaXN0ZXJlZExpc3RlbmVyc1t0eXBlXTtcclxuICAgICAgICAgICAgaWYgKG1ldGhvZHMgJiYgbWV0aG9kcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWV0aG9kcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChtZXRob2RzW2ldLm9iamVjdEZ1bmN0aW9uID09IGxpc3RlbmVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZHNbaV0uZGVzdHJ1Y3RvcigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRob2RzLnNwbGljZShpLCAxKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFtZXRob2RzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMucmVnaXN0ZXJlZExpc3RlbmVyc1t0eXBlXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGhhc0V2ZW50TGlzdGVuZXIodHlwZSkge1xyXG4gICAgICAgIGlmICh0aGlzLnJlZ2lzdGVyZWRMaXN0ZW5lcnNbdHlwZV0gIT0gbnVsbCkge1xyXG4gICAgICAgICAgICB2YXIgbWV0aG9kcyA9IHRoaXMucmVnaXN0ZXJlZExpc3RlbmVyc1t0eXBlXTtcclxuICAgICAgICAgICAgaWYgKG1ldGhvZHMgJiYgbWV0aG9kcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgZGlzcGF0Y2hFdmVudChldmVudCkge1xyXG4gICAgICAgIGlmICh0aGlzLnJlZ2lzdGVyZWRMaXN0ZW5lcnNbZXZlbnQudHlwZV0gIT0gbnVsbCkge1xyXG4gICAgICAgICAgICBldmVudC5zZXRDdXJyZW50VGFyZ2V0KHRoaXMpO1xyXG4gICAgICAgICAgICB2YXIgbWV0aG9kcyA9IHRoaXMucmVnaXN0ZXJlZExpc3RlbmVyc1tldmVudC50eXBlXTtcclxuICAgICAgICAgICAgaWYgKG1ldGhvZHMgJiYgbWV0aG9kcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIGxldCBtZXRob2Rjb3B5ID0gbWV0aG9kcy5jb25jYXQoKTtcclxuICAgICAgICAgICAgICAgIG1ldGhvZGNvcHkgPSBtZXRob2Rjb3B5LnNvcnQodGhpcy5nZXRNZXRob2RQcmlvcml0eSk7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAobWV0aG9kY29weS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgbWV0aG9kID0gbWV0aG9kY29weS5zaGlmdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChtZXRob2QuZXZlbnRUeXBlICE9IGV2ZW50LnR5cGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChtZXRob2QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyKG1ldGhvZCwgZXZlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZXZlbnQuaXNEaXNwb3NhYmxlKSB7XHJcbiAgICAgICAgICAgIGV2ZW50LmRlc3RydWN0b3IoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lciwgdXNlQ2FwdHVyZSA9IGZhbHNlLCBwcmlvcml0eSA9IDAsIHVzZVdlYWtSZWZlcmVuY2UgPSBmYWxzZSwgc2NvcGUgPSBudWxsKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNSZWdpc3RlcmVkKHR5cGUsIGxpc3RlbmVyKSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghdGhpcy5yZWdpc3RlcmVkTGlzdGVuZXJzW3R5cGVdKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVnaXN0ZXJlZExpc3RlbmVyc1t0eXBlXSA9IFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbWV0aG9kcyA9IHRoaXMucmVnaXN0ZXJlZExpc3RlbmVyc1t0eXBlXTtcclxuICAgICAgICB2YXIgbWV0aG9kU2NvcGUgPSBNZXRob2RTY29wZS5nZXRNZXRob2RTY29wZSgpO1xyXG4gICAgICAgIG1ldGhvZFNjb3BlLmV2ZW50VHlwZSA9IHR5cGU7XHJcbiAgICAgICAgbWV0aG9kU2NvcGUucGFyZW50RGlzcGF0Y2hlciA9IHRoaXM7XHJcbiAgICAgICAgbWV0aG9kU2NvcGUub2JqZWN0RnVuY3Rpb24gPSBsaXN0ZW5lcjtcclxuICAgICAgICBtZXRob2RTY29wZS5zY29wZSA9IHNjb3BlO1xyXG4gICAgICAgIG1ldGhvZFNjb3BlLnByaW9yaXR5ID0gcHJpb3JpdHk7XHJcbiAgICAgICAgbWV0aG9kcy5wdXNoKG1ldGhvZFNjb3BlKTtcclxuICAgIH1cclxuICAgIHRyaWdnZXIobWV0aG9kLCBldmVudCkge1xyXG4gICAgICAgIGlmIChtZXRob2Qub2JqZWN0RnVuY3Rpb24pIHtcclxuICAgICAgICAgICAgbWV0aG9kLm9iamVjdEZ1bmN0aW9uLmNhbGwobWV0aG9kLnNjb3BlLCBldmVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZ2V0TWV0aG9kUHJpb3JpdHkobWV0aG9kMSwgbWV0aG9kMikge1xyXG4gICAgICAgIGlmIChtZXRob2QxLnByaW9yaXR5ID4gbWV0aG9kMi5wcmlvcml0eSkge1xyXG4gICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgfVxyXG4gICAgaXNSZWdpc3RlcmVkKHR5cGUsIGxpc3RlbmVyKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLnJlZ2lzdGVyZWRMaXN0ZW5lcnNbdHlwZV0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbWV0aG9kcyA9IHRoaXMucmVnaXN0ZXJlZExpc3RlbmVyc1t0eXBlXTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1ldGhvZHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKG1ldGhvZHNbaV0ub2JqZWN0RnVuY3Rpb24gPT0gbGlzdGVuZXIpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLkV2ZW50RGlzcGF0Y2hlciA9IEV2ZW50RGlzcGF0Y2hlcjtcclxuY2xhc3MgTWV0aG9kU2NvcGUgZXh0ZW5kcyBGbGFzaEJhc2VPYmplY3RfMS5GbGFzaEJhc2VPYmplY3Qge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLnJlc2V0KCk7XHJcbiAgICB9XHJcbiAgICByZXNldCgpIHtcclxuICAgICAgICB0aGlzLm9iamVjdEZ1bmN0aW9uID0gbnVsbDtcclxuICAgICAgICB0aGlzLnNjb3BlID0gbnVsbDtcclxuICAgICAgICB0aGlzLnBhcmVudERpc3BhdGNoZXIgPSBudWxsO1xyXG4gICAgICAgIHRoaXMucHJpb3JpdHkgPSAwO1xyXG4gICAgICAgIHRoaXMuZXZlbnRUeXBlID0gbnVsbDtcclxuICAgIH1cclxuICAgIHN0YXRpYyBnZXRNZXRob2RTY29wZSgpIHtcclxuICAgICAgICBpZiAoTWV0aG9kU2NvcGUuTWV0aG9kU2NvcGVDYWNoZS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgbGV0IHRlID0gTWV0aG9kU2NvcGUuTWV0aG9kU2NvcGVDYWNoZVtNZXRob2RTY29wZS5NZXRob2RTY29wZUNhY2hlLmxlbmd0aCAtIDFdO1xyXG4gICAgICAgICAgICBNZXRob2RTY29wZS5NZXRob2RTY29wZUNhY2hlLmxlbmd0aCAtPSAxO1xyXG4gICAgICAgICAgICB0ZS5yZXNldCgpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgTWV0aG9kU2NvcGUoKTtcclxuICAgIH1cclxuICAgIGRlc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5vYmplY3RGdW5jdGlvbiA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5zY29wZSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5wYXJlbnREaXNwYXRjaGVyID0gbnVsbDtcclxuICAgICAgICBsZXQgaW5kZXggPSBNZXRob2RTY29wZS5NZXRob2RTY29wZUNhY2hlLmluZGV4T2YodGhpcyk7XHJcbiAgICAgICAgaWYgKGluZGV4IDwgMCkge1xyXG4gICAgICAgICAgICBNZXRob2RTY29wZS5NZXRob2RTY29wZUNhY2hlLnVuc2hpZnQodGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbk1ldGhvZFNjb3BlLk1ldGhvZFNjb3BlQ2FjaGUgPSBbXTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgUmVuZGVyVGV4dHVyZV8xID0gcmVxdWlyZShcIi4vUmVuZGVyVGV4dHVyZVwiKTtcclxuY29uc3QgUmVjdGFuZ2xlXzEgPSByZXF1aXJlKFwiLi9SZWN0YW5nbGVcIik7XHJcbmNvbnN0IENhbnZhc1JlbmRlclRhcmdldF8xID0gcmVxdWlyZShcIi4vQ2FudmFzUmVuZGVyVGFyZ2V0XCIpO1xyXG5jbGFzcyBFeHRyYWN0IHtcclxuICAgIGNvbnN0cnVjdG9yKHJlbmRlcmVyKSB7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbGxlY3Rpb24gb2YgbWV0aG9kcyBmb3IgZXh0cmFjdGluZyBkYXRhIChpbWFnZSwgcGl4ZWxzLCBldGMuKSBmcm9tIGEgZGlzcGxheSBvYmplY3Qgb3IgcmVuZGVyIHRleHR1cmVcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuZXh0cmFjdC5FeHRyYWN0fSBleHRyYWN0XHJcbiAgICAgICAgICogQG1lbWJlcm9mIFBJWEkuUmVuZGVyZXIjXHJcbiAgICAgICAgICogQHNlZSBQSVhJLmV4dHJhY3QuRXh0cmFjdFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHJlbmRlcmVyLmV4dHJhY3QgPSB0aGlzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBXaWxsIHJldHVybiBhIEhUTUwgSW1hZ2Ugb2YgdGhlIHRhcmdldFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7UElYSS5EaXNwbGF5T2JqZWN0fFBJWEkuUmVuZGVyVGV4dHVyZX0gdGFyZ2V0IC0gQSBkaXNwbGF5T2JqZWN0IG9yIHJlbmRlclRleHR1cmVcclxuICAgICAqICB0byBjb252ZXJ0LiBJZiBsZWZ0IGVtcHR5IHdpbGwgdXNlIHRoZSBtYWluIHJlbmRlcmVyXHJcbiAgICAgKiBAcmV0dXJuIHtIVE1MSW1hZ2VFbGVtZW50fSBIVE1MIEltYWdlIG9mIHRoZSB0YXJnZXRcclxuICAgICAqL1xyXG4gICAgaW1hZ2UodGFyZ2V0KSB7XHJcbiAgICAgICAgdmFyIGltYWdlID0gbmV3IEltYWdlKCk7XHJcbiAgICAgICAgaW1hZ2Uuc3JjID0gdGhpcy5iYXNlNjQodGFyZ2V0KTtcclxuICAgICAgICByZXR1cm4gaW1hZ2U7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFdpbGwgcmV0dXJuIGEgYSBiYXNlNjQgZW5jb2RlZCBzdHJpbmcgb2YgdGhpcyB0YXJnZXQuIEl0IHdvcmtzIGJ5IGNhbGxpbmdcclxuICAgICAqICBgRXh0cmFjdC5nZXRDYW52YXNgIGFuZCB0aGVuIHJ1bm5pbmcgdG9EYXRhVVJMIG9uIHRoYXQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtQSVhJLkRpc3BsYXlPYmplY3R8UElYSS5SZW5kZXJUZXh0dXJlfSB0YXJnZXQgLSBBIGRpc3BsYXlPYmplY3Qgb3IgcmVuZGVyVGV4dHVyZVxyXG4gICAgICogIHRvIGNvbnZlcnQuIElmIGxlZnQgZW1wdHkgd2lsbCB1c2UgdGhlIG1haW4gcmVuZGVyZXJcclxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gQSBiYXNlNjQgZW5jb2RlZCBzdHJpbmcgb2YgdGhlIHRleHR1cmUuXHJcbiAgICAgKi9cclxuICAgIGJhc2U2NCh0YXJnZXQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jYW52YXModGFyZ2V0KS50b0RhdGFVUkwoKTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIENhbnZhcyBlbGVtZW50LCByZW5kZXJzIHRoaXMgdGFyZ2V0IHRvIGl0IGFuZCB0aGVuIHJldHVybnMgaXQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtQSVhJLkRpc3BsYXlPYmplY3R8UElYSS5SZW5kZXJUZXh0dXJlfSB0YXJnZXQgLSBBIGRpc3BsYXlPYmplY3Qgb3IgcmVuZGVyVGV4dHVyZVxyXG4gICAgICogIHRvIGNvbnZlcnQuIElmIGxlZnQgZW1wdHkgd2lsbCB1c2UgdGhlIG1haW4gcmVuZGVyZXJcclxuICAgICAqIEByZXR1cm4ge0hUTUxDYW52YXNFbGVtZW50fSBBIENhbnZhcyBlbGVtZW50IHdpdGggdGhlIHRleHR1cmUgcmVuZGVyZWQgb24uXHJcbiAgICAgKi9cclxuICAgIGNhbnZhcyh0YXJnZXQpIHtcclxuICAgICAgICB2YXIgcmVuZGVyZXIgPSB0aGlzLnJlbmRlcmVyO1xyXG4gICAgICAgIHZhciByZXNvbHV0aW9uO1xyXG4gICAgICAgIHZhciBmcmFtZTtcclxuICAgICAgICB2YXIgZmxpcFkgPSBmYWxzZTtcclxuICAgICAgICB2YXIgcmVuZGVyVGV4dHVyZTtcclxuICAgICAgICB2YXIgZ2VuZXJhdGVkID0gZmFsc2U7XHJcbiAgICAgICAgaWYgKHRhcmdldCkge1xyXG4gICAgICAgICAgICBpZiAodGFyZ2V0IGluc3RhbmNlb2YgUmVuZGVyVGV4dHVyZV8xLlJlbmRlclRleHR1cmUpIHtcclxuICAgICAgICAgICAgICAgIHJlbmRlclRleHR1cmUgPSB0YXJnZXQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZW5kZXJUZXh0dXJlID0gdGhpcy5yZW5kZXJlci5nZW5lcmF0ZVRleHR1cmUodGFyZ2V0KTtcclxuICAgICAgICAgICAgICAgIGdlbmVyYXRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJlbmRlclRleHR1cmUpIHtcclxuICAgICAgICAgICAgcmVzb2x1dGlvbiA9IHJlbmRlclRleHR1cmUuYmFzZVRleHR1cmUucmVzb2x1dGlvbjtcclxuICAgICAgICAgICAgZnJhbWUgPSByZW5kZXJUZXh0dXJlLmZyYW1lO1xyXG4gICAgICAgICAgICBmbGlwWSA9IGZhbHNlO1xyXG4gICAgICAgICAgICByZW5kZXJlci5yZW5kZXJUZXh0dXJlLmJpbmQocmVuZGVyVGV4dHVyZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXNvbHV0aW9uID0gdGhpcy5yZW5kZXJlci5yZXNvbHV0aW9uO1xyXG4gICAgICAgICAgICBmbGlwWSA9IHRydWU7XHJcbiAgICAgICAgICAgIGZyYW1lID0gRXh0cmFjdC5URU1QX1JFQ1Q7XHJcbiAgICAgICAgICAgIGZyYW1lLndpZHRoID0gdGhpcy5yZW5kZXJlci53aWR0aDtcclxuICAgICAgICAgICAgZnJhbWUuaGVpZ2h0ID0gdGhpcy5yZW5kZXJlci5oZWlnaHQ7XHJcbiAgICAgICAgICAgIHJlbmRlcmVyLnJlbmRlclRleHR1cmUuYmluZChudWxsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHdpZHRoID0gZnJhbWUud2lkdGggKiByZXNvbHV0aW9uO1xyXG4gICAgICAgIHZhciBoZWlnaHQgPSBmcmFtZS5oZWlnaHQgKiByZXNvbHV0aW9uO1xyXG4gICAgICAgIHZhciBjYW52YXNCdWZmZXIgPSBuZXcgQ2FudmFzUmVuZGVyVGFyZ2V0XzEuQ2FudmFzUmVuZGVyVGFyZ2V0KHdpZHRoLCBoZWlnaHQsIDEpO1xyXG4gICAgICAgIHZhciB3ZWJnbFBpeGVscyA9IG5ldyBVaW50OEFycmF5KEV4dHJhY3QuQllURVNfUEVSX1BJWEVMICogd2lkdGggKiBoZWlnaHQpO1xyXG4gICAgICAgIC8vIHJlYWQgcGl4ZWxzIHRvIHRoZSBhcnJheVxyXG4gICAgICAgIHZhciBnbCA9IHJlbmRlcmVyLmdsO1xyXG4gICAgICAgIGdsLnJlYWRQaXhlbHMoZnJhbWUueCAqIHJlc29sdXRpb24sIGZyYW1lLnkgKiByZXNvbHV0aW9uLCB3aWR0aCwgaGVpZ2h0LCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCB3ZWJnbFBpeGVscyk7XHJcbiAgICAgICAgLy8gYWRkIHRoZSBwaXhlbHMgdG8gdGhlIGNhbnZhc1xyXG4gICAgICAgIHZhciBjYW52YXNEYXRhID0gY2FudmFzQnVmZmVyLmNvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgICAgIGNhbnZhc0RhdGEuZGF0YS5zZXQod2ViZ2xQaXhlbHMpO1xyXG4gICAgICAgIGNhbnZhc0J1ZmZlci5jb250ZXh0LnB1dEltYWdlRGF0YShjYW52YXNEYXRhLCAwLCAwKTtcclxuICAgICAgICAvLyBwdWxsaW5nIHBpeGVsc1xyXG4gICAgICAgIGlmIChmbGlwWSkge1xyXG4gICAgICAgICAgICBjYW52YXNCdWZmZXIuY29udGV4dC5zY2FsZSgxLCAtMSk7XHJcbiAgICAgICAgICAgIGNhbnZhc0J1ZmZlci5jb250ZXh0LmRyYXdJbWFnZShjYW52YXNCdWZmZXIuY2FudmFzLCAwLCAtaGVpZ2h0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGdlbmVyYXRlZCkge1xyXG4gICAgICAgICAgICByZW5kZXJUZXh0dXJlLmRlc3Ryb3kodHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHNlbmQgdGhlIGNhbnZhcyBiYWNrLi5cclxuICAgICAgICByZXR1cm4gY2FudmFzQnVmZmVyLmNhbnZhcztcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogV2lsbCByZXR1cm4gYSBvbmUtZGltZW5zaW9uYWwgYXJyYXkgY29udGFpbmluZyB0aGUgcGl4ZWwgZGF0YSBvZiB0aGUgZW50aXJlIHRleHR1cmUgaW4gUkdCQVxyXG4gICAgICogb3JkZXIsIHdpdGggaW50ZWdlciB2YWx1ZXMgYmV0d2VlbiAwIGFuZCAyNTUgKGluY2x1ZGVkKS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1BJWEkuRGlzcGxheU9iamVjdHxQSVhJLlJlbmRlclRleHR1cmV9IHRhcmdldCAtIEEgZGlzcGxheU9iamVjdCBvciByZW5kZXJUZXh0dXJlXHJcbiAgICAgKiAgdG8gY29udmVydC4gSWYgbGVmdCBlbXB0eSB3aWxsIHVzZSB0aGUgbWFpbiByZW5kZXJlclxyXG4gICAgICogQHJldHVybiB7VWludDhDbGFtcGVkQXJyYXl9IE9uZS1kaW1lbnNpb25hbCBhcnJheSBjb250YWluaW5nIHRoZSBwaXhlbCBkYXRhIG9mIHRoZSBlbnRpcmUgdGV4dHVyZVxyXG4gICAgICovXHJcbiAgICBwaXhlbHModGFyZ2V0KSB7XHJcbiAgICAgICAgdmFyIHJlbmRlcmVyID0gdGhpcy5yZW5kZXJlcjtcclxuICAgICAgICB2YXIgcmVzb2x1dGlvbjtcclxuICAgICAgICB2YXIgZnJhbWU7XHJcbiAgICAgICAgdmFyIHJlbmRlclRleHR1cmU7XHJcbiAgICAgICAgdmFyIGdlbmVyYXRlZCA9IGZhbHNlO1xyXG4gICAgICAgIGlmICh0YXJnZXQpIHtcclxuICAgICAgICAgICAgaWYgKHRhcmdldCBpbnN0YW5jZW9mIFJlbmRlclRleHR1cmVfMS5SZW5kZXJUZXh0dXJlKSB7XHJcbiAgICAgICAgICAgICAgICByZW5kZXJUZXh0dXJlID0gdGFyZ2V0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmVuZGVyVGV4dHVyZSA9IHRoaXMucmVuZGVyZXIuZ2VuZXJhdGVUZXh0dXJlKHRhcmdldCk7XHJcbiAgICAgICAgICAgICAgICBnZW5lcmF0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChyZW5kZXJUZXh0dXJlKSB7XHJcbiAgICAgICAgICAgIHJlc29sdXRpb24gPSByZW5kZXJUZXh0dXJlLmJhc2VUZXh0dXJlLnJlc29sdXRpb247XHJcbiAgICAgICAgICAgIGZyYW1lID0gcmVuZGVyVGV4dHVyZS5mcmFtZTtcclxuICAgICAgICAgICAgLy8gYmluZCB0aGUgYnVmZmVyXHJcbiAgICAgICAgICAgIHJlbmRlcmVyLnJlbmRlclRleHR1cmUuYmluZChyZW5kZXJUZXh0dXJlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJlc29sdXRpb24gPSByZW5kZXJlci5yZXNvbHV0aW9uO1xyXG4gICAgICAgICAgICBmcmFtZSA9IEV4dHJhY3QuVEVNUF9SRUNUO1xyXG4gICAgICAgICAgICBmcmFtZS53aWR0aCA9IHJlbmRlcmVyLndpZHRoO1xyXG4gICAgICAgICAgICBmcmFtZS5oZWlnaHQgPSByZW5kZXJlci5oZWlnaHQ7XHJcbiAgICAgICAgICAgIHJlbmRlcmVyLnJlbmRlclRleHR1cmUuYmluZChudWxsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHdpZHRoID0gZnJhbWUud2lkdGggKiByZXNvbHV0aW9uO1xyXG4gICAgICAgIHZhciBoZWlnaHQgPSBmcmFtZS5oZWlnaHQgKiByZXNvbHV0aW9uO1xyXG4gICAgICAgIHZhciB3ZWJnbFBpeGVscyA9IG5ldyBVaW50OEFycmF5KEV4dHJhY3QuQllURVNfUEVSX1BJWEVMICogd2lkdGggKiBoZWlnaHQpO1xyXG4gICAgICAgIC8vIHJlYWQgcGl4ZWxzIHRvIHRoZSBhcnJheVxyXG4gICAgICAgIHZhciBnbCA9IHJlbmRlcmVyLmdsO1xyXG4gICAgICAgIGdsLnJlYWRQaXhlbHMoZnJhbWUueCAqIHJlc29sdXRpb24sIGZyYW1lLnkgKiByZXNvbHV0aW9uLCB3aWR0aCwgaGVpZ2h0LCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCB3ZWJnbFBpeGVscyk7XHJcbiAgICAgICAgaWYgKGdlbmVyYXRlZCkge1xyXG4gICAgICAgICAgICByZW5kZXJUZXh0dXJlLmRlc3Ryb3kodHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB3ZWJnbFBpeGVscztcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogRGVzdHJveXMgdGhlIGV4dHJhY3RcclxuICAgICAqXHJcbiAgICAgKi9cclxuICAgIGRlc3Ryb3koKSB7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJlci5leHRyYWN0ID0gbnVsbDtcclxuICAgICAgICB0aGlzLnJlbmRlcmVyID0gbnVsbDtcclxuICAgIH1cclxuICAgIDtcclxufVxyXG5FeHRyYWN0LlRFTVBfUkVDVCA9IG5ldyBSZWN0YW5nbGVfMS5SZWN0YW5nbGUoKTtcclxuRXh0cmFjdC5CWVRFU19QRVJfUElYRUwgPSA0O1xyXG5leHBvcnRzLkV4dHJhY3QgPSBFeHRyYWN0O1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBUZXh0dXJlXzEgPSByZXF1aXJlKFwiLi9UZXh0dXJlXCIpO1xyXG5jb25zdCBGbGFzaEJhc2VPYmplY3RfMSA9IHJlcXVpcmUoXCIuL0ZsYXNoQmFzZU9iamVjdFwiKTtcclxuY2xhc3MgRmlsbFN0eWxlIGV4dGVuZHMgRmxhc2hCYXNlT2JqZWN0XzEuRmxhc2hCYXNlT2JqZWN0IHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5yZXNldCgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDbG9uZXMgdGhlIG9iamVjdFxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4ge1BJWEkuRmlsbFN0eWxlfVxyXG4gICAgICovXHJcbiAgICBjbG9uZSgpIHtcclxuICAgICAgICB2YXIgb2JqID0gbmV3IEZpbGxTdHlsZSgpO1xyXG4gICAgICAgIG9iai5jb2xvciA9IHRoaXMuY29sb3I7XHJcbiAgICAgICAgb2JqLmFscGhhID0gdGhpcy5hbHBoYTtcclxuICAgICAgICBvYmoudGV4dHVyZSA9IHRoaXMudGV4dHVyZTtcclxuICAgICAgICBvYmoubWF0cml4ID0gdGhpcy5tYXRyaXg7XHJcbiAgICAgICAgb2JqLnZpc2libGUgPSB0aGlzLnZpc2libGU7XHJcbiAgICAgICAgcmV0dXJuIG9iajtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogUmVzZXRcclxuICAgICAqL1xyXG4gICAgcmVzZXQoKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGhleCBjb2xvciB2YWx1ZSB1c2VkIHdoZW4gY29sb3JpbmcgdGhlIEdyYXBoaWNzIG9iamVjdC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAgICAgKiBAZGVmYXVsdCAxXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5jb2xvciA9IDB4RkZGRkZGO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBhbHBoYSB2YWx1ZSB1c2VkIHdoZW4gZmlsbGluZyB0aGUgR3JhcGhpY3Mgb2JqZWN0LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICAgICAqIEBkZWZhdWx0IDFcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmFscGhhID0gMTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgdGV4dHVyZSB0byBiZSB1c2VkIGZvciB0aGUgZmlsbC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBtZW1iZXIge3N0cmluZ31cclxuICAgICAgICAgKiBAZGVmYXVsdCAwXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy50ZXh0dXJlID0gVGV4dHVyZV8xLlRleHR1cmUuV0hJVEU7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIHRyYW5zZm9ybSBhcGxwaWVkIHRvIHRoZSB0ZXh0dXJlLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQG1lbWJlciB7c3RyaW5nfVxyXG4gICAgICAgICAqIEBkZWZhdWx0IDBcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLm1hdHJpeCA9IG51bGw7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSWYgdGhlIGN1cnJlbnQgZmlsbCBpcyB2aXNpYmxlLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQG1lbWJlciB7Ym9vbGVhbn1cclxuICAgICAgICAgKiBAZGVmYXVsdCBmYWxzZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMudmlzaWJsZSA9IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBEZXN0cm95IGFuZCBkb24ndCB1c2UgYWZ0ZXIgdGhpc1xyXG4gICAgICovXHJcbiAgICBkZXN0cm95KCkge1xyXG4gICAgICAgIHRoaXMudGV4dHVyZSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5tYXRyaXggPSBudWxsO1xyXG4gICAgfVxyXG4gICAgO1xyXG59XHJcbmV4cG9ydHMuRmlsbFN0eWxlID0gRmlsbFN0eWxlO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBTaGFkZXJfMSA9IHJlcXVpcmUoXCIuL1NoYWRlclwiKTtcclxuY29uc3QgUHJvZ3JhbV8xID0gcmVxdWlyZShcIi4vUHJvZ3JhbVwiKTtcclxuY29uc3Qgc2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL3NldHRpbmdzXCIpO1xyXG5jb25zdCBTdGF0ZV8xID0gcmVxdWlyZShcIi4vU3RhdGVcIik7XHJcbmNsYXNzIEZpbHRlciBleHRlbmRzIFNoYWRlcl8xLlNoYWRlciB7XHJcbiAgICBjb25zdHJ1Y3Rvcih2ZXJ0ZXhTcmMgPSBudWxsLCBmcmFnbWVudFNyYyA9IG51bGwsIHVuaWZvcm1zID0gbnVsbCkge1xyXG4gICAgICAgIHZhciBwcm9ncmFtID0gUHJvZ3JhbV8xLlByb2dyYW0uZnJvbSh2ZXJ0ZXhTcmMgfHwgRmlsdGVyLmRlZmF1bHRWZXJ0ZXhTcmMsIGZyYWdtZW50U3JjIHx8IEZpbHRlci5kZWZhdWx0RnJhZ21lbnRTcmMpO1xyXG4gICAgICAgIHN1cGVyKHByb2dyYW0sIHVuaWZvcm1zKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgcGFkZGluZyBvZiB0aGUgZmlsdGVyLiBTb21lIGZpbHRlcnMgcmVxdWlyZSBleHRyYSBzcGFjZSB0byBicmVhdGggc3VjaCBhcyBhIGJsdXIuXHJcbiAgICAgICAgICogSW5jcmVhc2luZyB0aGlzIHdpbGwgYWRkIGV4dHJhIHdpZHRoIGFuZCBoZWlnaHQgdG8gdGhlIGJvdW5kcyBvZiB0aGUgb2JqZWN0IHRoYXQgdGhlXHJcbiAgICAgICAgICogZmlsdGVyIGlzIGFwcGxpZWQgdG8uXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5wYWRkaW5nID0gMDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgcmVzb2x1dGlvbiBvZiB0aGUgZmlsdGVyLiBTZXR0aW5nIHRoaXMgdG8gYmUgbG93ZXIgd2lsbCBsb3dlciB0aGUgcXVhbGl0eSBidXRcclxuICAgICAgICAgKiBpbmNyZWFzZSB0aGUgcGVyZm9ybWFuY2Ugb2YgdGhlIGZpbHRlci5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnJlc29sdXRpb24gPSBzZXR0aW5nc18xLnNldHRpbmdzLkZJTFRFUl9SRVNPTFVUSU9OO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIElmIGVuYWJsZWQgaXMgdHJ1ZSB0aGUgZmlsdGVyIGlzIGFwcGxpZWQsIGlmIGZhbHNlIGl0IHdpbGwgbm90LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQG1lbWJlciB7Ym9vbGVhbn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmVuYWJsZWQgPSB0cnVlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIElmIGVuYWJsZWQsIFBpeGlKUyB3aWxsIGZpdCB0aGUgZmlsdGVyIGFyZWEgaW50byBib3VuZGFyaWVzIGZvciBiZXR0ZXIgcGVyZm9ybWFuY2UuXHJcbiAgICAgICAgICogU3dpdGNoIGl0IG9mZiBpZiBpdCBkb2VzIG5vdCB3b3JrIGZvciBzcGVjaWZpYyBzaGFkZXIuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAbWVtYmVyIHtib29sZWFufVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuYXV0b0ZpdCA9IHRydWU7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogTGVnYWN5IGZpbHRlcnMgdXNlIHBvc2l0aW9uIGFuZCB1dnMgZnJvbSBhdHRyaWJ1dGVzXHJcbiAgICAgICAgICogQG1lbWJlciB7Ym9vbGVhbn1cclxuICAgICAgICAgKiBAcmVhZG9ubHlcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmxlZ2FjeSA9ICEhdGhpcy5wcm9ncmFtLmF0dHJpYnV0ZURhdGEuYVRleHR1cmVDb29yZDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgV2ViR0wgc3RhdGUgdGhlIGZpbHRlciByZXF1aXJlcyB0byByZW5kZXJcclxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLlN0YXRlfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSBuZXcgU3RhdGVfMS5TdGF0ZSgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBsaWVzIHRoZSBmaWx0ZXJcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1BJWEkuc3lzdGVtcy5GaWx0ZXJTeXN0ZW19IGZpbHRlck1hbmFnZXIgLSBUaGUgcmVuZGVyZXIgdG8gcmV0cmlldmUgdGhlIGZpbHRlciBmcm9tXHJcbiAgICAgKiBAcGFyYW0ge1BJWEkuUmVuZGVyVGV4dHVyZX0gaW5wdXQgLSBUaGUgaW5wdXQgcmVuZGVyIHRhcmdldC5cclxuICAgICAqIEBwYXJhbSB7UElYSS5SZW5kZXJUZXh0dXJlfSBvdXRwdXQgLSBUaGUgdGFyZ2V0IHRvIG91dHB1dCB0by5cclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gY2xlYXIgLSBTaG91bGQgdGhlIG91dHB1dCBiZSBjbGVhcmVkIGJlZm9yZSByZW5kZXJpbmcgdG8gaXRcclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbY3VycmVudFN0YXRlXSAtIEl0J3MgY3VycmVudCBzdGF0ZSBvZiBmaWx0ZXIuXHJcbiAgICAgKiAgICAgICAgVGhlcmUgYXJlIHNvbWUgdXNlZnVsIHByb3BlcnRpZXMgaW4gdGhlIGN1cnJlbnRTdGF0ZSA6XHJcbiAgICAgKiAgICAgICAgdGFyZ2V0LCBmaWx0ZXJzLCBzb3VyY2VGcmFtZSwgZGVzdGluYXRpb25GcmFtZSwgcmVuZGVyVGFyZ2V0LCByZXNvbHV0aW9uXHJcbiAgICAgKi9cclxuICAgIGFwcGx5KGZpbHRlck1hbmFnZXIsIGlucHV0LCBvdXRwdXQsIGNsZWFyLCBjdXJyZW50U3RhdGUsIGRlcnApIHtcclxuICAgICAgICAvLyBkbyBhcyB5b3UgcGxlYXNlIVxyXG4gICAgICAgIGZpbHRlck1hbmFnZXIuYXBwbHlGaWx0ZXIodGhpcywgaW5wdXQsIG91dHB1dCwgY2xlYXIsIGN1cnJlbnRTdGF0ZSwgZGVycCk7XHJcbiAgICAgICAgLy8gb3IganVzdCBkbyBhIHJlZ3VsYXIgcmVuZGVyLi5cclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgYmxlbmRtb2RlIG9mIHRoZSBmaWx0ZXJcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgKiBAZGVmYXVsdCBQSVhJLkJMRU5EX01PREVTLk5PUk1BTFxyXG4gICAgICovXHJcbiAgICBnZXQgYmxlbmRNb2RlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLmJsZW5kTW9kZTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIHNldCBibGVuZE1vZGUodmFsdWUpIHtcclxuICAgICAgICB0aGlzLnN0YXRlLmJsZW5kTW9kZSA9IHZhbHVlO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgZGVmYXVsdCB2ZXJ0ZXggc2hhZGVyIHNvdXJjZVxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEB0eXBlIHtzdHJpbmd9XHJcbiAgICAgKiBAY29uc3RhbnRcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGdldCBkZWZhdWx0VmVydGV4U3JjKCkge1xyXG4gICAgICAgIHJldHVybiBGaWx0ZXIuZGVmYXVsdFZlcnRleCQxO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgZGVmYXVsdCBmcmFnbWVudCBzaGFkZXIgc291cmNlXHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQHR5cGUge3N0cmluZ31cclxuICAgICAqIEBjb25zdGFudFxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZ2V0IGRlZmF1bHRGcmFnbWVudFNyYygpIHtcclxuICAgICAgICByZXR1cm4gRmlsdGVyLmRlZmF1bHRGcmFnbWVudCQxO1xyXG4gICAgfVxyXG4gICAgO1xyXG59XHJcbi8qKlxyXG4gKiBVc2VkIGZvciBjYWNoaW5nIHNoYWRlciBJRHNcclxuICpcclxuICogQHN0YXRpY1xyXG4gKiBAdHlwZSB7b2JqZWN0fVxyXG4gKiBAcHJvdGVjdGVkXHJcbiAqL1xyXG5GaWx0ZXIuU09VUkNFX0tFWV9NQVAgPSB7fTtcclxuRmlsdGVyLmRlZmF1bHRWZXJ0ZXgkMSA9IFwiYXR0cmlidXRlIHZlYzIgYVZlcnRleFBvc2l0aW9uO1xcclxcblxcclxcbnVuaWZvcm0gbWF0MyBwcm9qZWN0aW9uTWF0cml4O1xcclxcblxcclxcbnZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xcclxcblxcclxcbnVuaWZvcm0gdmVjNCBpbnB1dFNpemU7XFxyXFxudW5pZm9ybSB2ZWM0IG91dHB1dEZyYW1lO1xcclxcblxcclxcbnZlYzQgZmlsdGVyVmVydGV4UG9zaXRpb24oIHZvaWQgKVxcclxcbntcXHJcXG4gICAgdmVjMiBwb3NpdGlvbiA9IGFWZXJ0ZXhQb3NpdGlvbiAqIG1heChvdXRwdXRGcmFtZS56dywgdmVjMigwLikpICsgb3V0cHV0RnJhbWUueHk7XFxyXFxuXFxyXFxuICAgIHJldHVybiB2ZWM0KChwcm9qZWN0aW9uTWF0cml4ICogdmVjMyhwb3NpdGlvbiwgMS4wKSkueHksIDAuMCwgMS4wKTtcXHJcXG59XFxyXFxuXFxyXFxudmVjMiBmaWx0ZXJUZXh0dXJlQ29vcmQoIHZvaWQgKVxcclxcbntcXHJcXG4gICAgcmV0dXJuIGFWZXJ0ZXhQb3NpdGlvbiAqIChvdXRwdXRGcmFtZS56dyAqIGlucHV0U2l6ZS56dyk7XFxyXFxufVxcclxcblxcclxcbnZvaWQgbWFpbih2b2lkKVxcclxcbntcXHJcXG4gICAgZ2xfUG9zaXRpb24gPSBmaWx0ZXJWZXJ0ZXhQb3NpdGlvbigpO1xcclxcbiAgICB2VGV4dHVyZUNvb3JkID0gZmlsdGVyVGV4dHVyZUNvb3JkKCk7XFxyXFxufVxcclxcblwiO1xyXG5GaWx0ZXIuZGVmYXVsdEZyYWdtZW50JDEgPSBcInZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xcclxcblxcclxcbnVuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyO1xcclxcblxcclxcbnZvaWQgbWFpbih2b2lkKXtcXHJcXG4gICBnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZUZXh0dXJlQ29vcmQpO1xcclxcbn1cXHJcXG5cIjtcclxuZXhwb3J0cy5GaWx0ZXIgPSBGaWx0ZXI7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IFJlY3RhbmdsZV8xID0gcmVxdWlyZShcIi4vUmVjdGFuZ2xlXCIpO1xyXG5jbGFzcyBGaWx0ZXJTdGF0ZSB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLnJlbmRlclRleHR1cmUgPSBudWxsO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRhcmdldCBvZiB0aGUgZmlsdGVyc1xyXG4gICAgICAgICAqIFdlIHN0b3JlIGZvciBjYXNlIHdoZW4gY3VzdG9tIGZpbHRlciB3YW50cyB0byBrbm93IHRoZSBlbGVtZW50IGl0IHdhcyBhcHBsaWVkIG9uXHJcbiAgICAgICAgICogQG1lbWJlciB7UElYSS5EaXNwbGF5T2JqZWN0fVxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy50YXJnZXQgPSBudWxsO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbXBhdGliaWxpdHkgd2l0aCBQaXhpSlMgdjQgZmlsdGVyc1xyXG4gICAgICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XHJcbiAgICAgICAgICogQGRlZmF1bHQgZmFsc2VcclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMubGVnYWN5ID0gZmFsc2U7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmVzb2x1dGlvbiBvZiBmaWx0ZXJzXHJcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICAgICAqIEBkZWZhdWx0IDFcclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMucmVzb2x1dGlvbiA9IDE7XHJcbiAgICAgICAgLy8gbmV4dCB0aHJlZSBmaWVsZHMgYXJlIGNyZWF0ZWQgb25seSBmb3Igcm9vdFxyXG4gICAgICAgIC8vIHJlLWFzc2lnbmVkIGZvciBldmVyeXRoaW5nIGVsc2VcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTb3VyY2UgZnJhbWVcclxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLlJlY3RhbmdsZX1cclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuc291cmNlRnJhbWUgPSBuZXcgUmVjdGFuZ2xlXzEuUmVjdGFuZ2xlKCk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRGVzdGluYXRpb24gZnJhbWVcclxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLlJlY3RhbmdsZX1cclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuZGVzdGluYXRpb25GcmFtZSA9IG5ldyBSZWN0YW5nbGVfMS5SZWN0YW5nbGUoKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb2xsZWN0aW9uIG9mIGZpbHRlcnNcclxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLkZpbHRlcltdfVxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5maWx0ZXJzID0gW107XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIGNsZWFycyB0aGUgc3RhdGVcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIGNsZWFyKCkge1xyXG4gICAgICAgIHRoaXMudGFyZ2V0ID0gbnVsbDtcclxuICAgICAgICB0aGlzLmZpbHRlcnMgPSBudWxsO1xyXG4gICAgICAgIHRoaXMucmVuZGVyVGV4dHVyZSA9IG51bGw7XHJcbiAgICB9XHJcbiAgICA7XHJcbn1cclxuZXhwb3J0cy5GaWx0ZXJTdGF0ZSA9IEZpbHRlclN0YXRlO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBTeXN0ZW1fMSA9IHJlcXVpcmUoXCIuL1N5c3RlbVwiKTtcclxuY29uc3QgUXVhZF8xID0gcmVxdWlyZShcIi4vUXVhZFwiKTtcclxuY29uc3QgUXVhZFV2XzEgPSByZXF1aXJlKFwiLi9RdWFkVXZcIik7XHJcbmNvbnN0IFJlY3RhbmdsZV8xID0gcmVxdWlyZShcIi4vUmVjdGFuZ2xlXCIpO1xyXG5jb25zdCBVbmlmb3JtR3JvdXBfMSA9IHJlcXVpcmUoXCIuL1VuaWZvcm1Hcm91cFwiKTtcclxuY29uc3QgUmVuZGVyVGV4dHVyZV8xID0gcmVxdWlyZShcIi4vUmVuZGVyVGV4dHVyZVwiKTtcclxuY29uc3QgTWF0cml4XzEgPSByZXF1aXJlKFwiLi9NYXRyaXhcIik7XHJcbmNvbnN0IEZpbHRlclN0YXRlXzEgPSByZXF1aXJlKFwiLi9GaWx0ZXJTdGF0ZVwiKTtcclxuY29uc3QgRHJhd01vZGVTZXR0aW5nc18xID0gcmVxdWlyZShcIi4vRHJhd01vZGVTZXR0aW5nc1wiKTtcclxuY29uc3QgTWF0aFNldHRpbmdzXzEgPSByZXF1aXJlKFwiLi9NYXRoU2V0dGluZ3NcIik7XHJcbmNsYXNzIEZpbHRlclN5c3RlbSBleHRlbmRzIFN5c3RlbV8xLlN5c3RlbSB7XHJcbiAgICBjb25zdHJ1Y3RvcihyZW5kZXJlcikge1xyXG4gICAgICAgIHN1cGVyKHJlbmRlcmVyKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBMaXN0IG9mIGZpbHRlcnMgZm9yIHRoZSBGaWx0ZXJTeXN0ZW1cclxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3RbXX1cclxuICAgICAgICAgKiBAcmVhZG9ubHlcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmRlZmF1bHRGaWx0ZXJTdGFjayA9IFt7fV07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogc3RvcmVzIGEgYnVuY2ggb2YgUE8yIHRleHR1cmVzIHVzZWQgZm9yIGZpbHRlcmluZ1xyXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnRleHR1cmVQb29sID0ge307XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogYSBwb29sIGZvciBzdG9yaW5nIGZpbHRlciBzdGF0ZXMsIHNhdmUgdXMgY3JlYXRpbmcgbmV3IG9uZXMgZWFjaCB0aWNrXHJcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0W119XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5zdGF0ZVBvb2wgPSBbXTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBIHZlcnkgc2ltcGxlIGdlb21ldHJ5IHVzZWQgd2hlbiBkcmF3aW5nIGEgZmlsdGVyIGVmZmVjdCB0byB0aGUgc2NyZWVuXHJcbiAgICAgICAgICogQG1lbWJlciB7UElYSS5RdWFkfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMucXVhZCA9IG5ldyBRdWFkXzEuUXVhZCgpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFF1YWQgVVZzXHJcbiAgICAgICAgICogQG1lbWJlciB7UElYSS5RdWFkVXZ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5xdWFkVXYgPSBuZXcgUXVhZFV2XzEuUXVhZFV2KCk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGVtcG9yYXJ5IHJlY3QgZm9yIG1hdGhzXHJcbiAgICAgICAgICogQHR5cGUge1BJWEkuUmVjdGFuZ2xlfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMudGVtcFJlY3QgPSBuZXcgUmVjdGFuZ2xlXzEuUmVjdGFuZ2xlKCk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQWN0aXZlIHN0YXRlXHJcbiAgICAgICAgICogQG1lbWJlciB7b2JqZWN0fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuYWN0aXZlU3RhdGUgPSB7fTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGlzIHVuaWZvcm0gZ3JvdXAgaXMgYXR0YWNoZWQgdG8gZmlsdGVyIHVuaWZvcm1zIHdoZW4gdXNlZFxyXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuVW5pZm9ybUdyb3VwfVxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7UElYSS5SZWN0YW5nbGV9IG91dHB1dEZyYW1lXHJcbiAgICAgICAgICogQHByb3BlcnR5IHtGbG9hdDMyQXJyYXl9IGlucHV0U2l6ZVxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7RmxvYXQzMkFycmF5fSBpbnB1dFBpeGVsXHJcbiAgICAgICAgICogQHByb3BlcnR5IHtGbG9hdDMyQXJyYXl9IGlucHV0Q2xhbXBcclxuICAgICAgICAgKiBAcHJvcGVydHkge051bWJlcn0gcmVzb2x1dGlvblxyXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7RmxvYXQzMkFycmF5fSBmaWx0ZXJBcmVhXHJcbiAgICAgICAgICogQHByb3BlcnR5IHtGbG9hZDMyQXJyYXl9IGZpbHRlckNsYW1wXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5nbG9iYWxVbmlmb3JtcyA9IG5ldyBVbmlmb3JtR3JvdXBfMS5Vbmlmb3JtR3JvdXAoe1xyXG4gICAgICAgICAgICBvdXRwdXRGcmFtZTogdGhpcy50ZW1wUmVjdCxcclxuICAgICAgICAgICAgaW5wdXRTaXplOiBuZXcgRmxvYXQzMkFycmF5KDQpLFxyXG4gICAgICAgICAgICBpbnB1dFBpeGVsOiBuZXcgRmxvYXQzMkFycmF5KDQpLFxyXG4gICAgICAgICAgICBpbnB1dENsYW1wOiBuZXcgRmxvYXQzMkFycmF5KDQpLFxyXG4gICAgICAgICAgICByZXNvbHV0aW9uOiAxLFxyXG4gICAgICAgICAgICAvLyBsZWdhY3kgdmFyaWFibGVzXHJcbiAgICAgICAgICAgIGZpbHRlckFyZWE6IG5ldyBGbG9hdDMyQXJyYXkoNCksXHJcbiAgICAgICAgICAgIGZpbHRlckNsYW1wOiBuZXcgRmxvYXQzMkFycmF5KDQpLFxyXG4gICAgICAgIH0sIHRydWUpO1xyXG4gICAgICAgIHRoaXMuX3BpeGVsc1dpZHRoID0gcmVuZGVyZXIudmlldy53aWR0aDtcclxuICAgICAgICB0aGlzLl9waXhlbHNIZWlnaHQgPSByZW5kZXJlci52aWV3LmhlaWdodDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhIG5ldyBmaWx0ZXIgdG8gdGhlIFN5c3RlbS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1BJWEkuRGlzcGxheU9iamVjdH0gdGFyZ2V0IC0gVGhlIHRhcmdldCBvZiB0aGUgZmlsdGVyIHRvIHJlbmRlci5cclxuICAgICAqIEBwYXJhbSB7UElYSS5GaWx0ZXJbXX0gZmlsdGVycyAtIFRoZSBmaWx0ZXJzIHRvIGFwcGx5LlxyXG4gICAgICovXHJcbiAgICBwdXNoKHRhcmdldCwgZmlsdGVycykge1xyXG4gICAgICAgIHZhciByZW5kZXJlciA9IHRoaXMucmVuZGVyZXI7XHJcbiAgICAgICAgdmFyIGZpbHRlclN0YWNrID0gdGhpcy5kZWZhdWx0RmlsdGVyU3RhY2s7XHJcbiAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5zdGF0ZVBvb2wucG9wKCkgfHwgbmV3IEZpbHRlclN0YXRlXzEuRmlsdGVyU3RhdGUoKTtcclxuICAgICAgICB2YXIgcmVzb2x1dGlvbiA9IGZpbHRlcnNbMF0ucmVzb2x1dGlvbjtcclxuICAgICAgICB2YXIgcGFkZGluZyA9IGZpbHRlcnNbMF0ucGFkZGluZztcclxuICAgICAgICB2YXIgYXV0b0ZpdCA9IGZpbHRlcnNbMF0uYXV0b0ZpdDtcclxuICAgICAgICB2YXIgbGVnYWN5ID0gZmlsdGVyc1swXS5sZWdhY3k7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBmaWx0ZXJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBmaWx0ZXIgPSBmaWx0ZXJzW2ldO1xyXG4gICAgICAgICAgICAvLyBsZXRzIHVzZSB0aGUgbG93ZXN0IHJlc29sdXRpb24uLlxyXG4gICAgICAgICAgICByZXNvbHV0aW9uID0gTWF0aC5taW4ocmVzb2x1dGlvbiwgZmlsdGVyLnJlc29sdXRpb24pO1xyXG4gICAgICAgICAgICAvLyBhbmQgdGhlIGxhcmdlc3QgYW1vdW50IG9mIHBhZGRpbmchXHJcbiAgICAgICAgICAgIHBhZGRpbmcgPSBNYXRoLm1heChwYWRkaW5nLCBmaWx0ZXIucGFkZGluZyk7XHJcbiAgICAgICAgICAgIC8vIG9ubHkgYXV0byBmaXQgaWYgYWxsIGZpbHRlcnMgYXJlIGF1dG9maXRcclxuICAgICAgICAgICAgYXV0b0ZpdCA9IGF1dG9GaXQgfHwgZmlsdGVyLmF1dG9GaXQ7XHJcbiAgICAgICAgICAgIGxlZ2FjeSA9IGxlZ2FjeSB8fCBmaWx0ZXIubGVnYWN5O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZmlsdGVyU3RhY2subGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGVmYXVsdEZpbHRlclN0YWNrWzBdLnJlbmRlclRleHR1cmUgPSByZW5kZXJlci5yZW5kZXJUZXh0dXJlLmN1cnJlbnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZpbHRlclN0YWNrLnB1c2goc3RhdGUpO1xyXG4gICAgICAgIHN0YXRlLnJlc29sdXRpb24gPSByZXNvbHV0aW9uO1xyXG4gICAgICAgIHN0YXRlLmxlZ2FjeSA9IGxlZ2FjeTtcclxuICAgICAgICBzdGF0ZS50YXJnZXQgPSB0YXJnZXQ7XHJcbiAgICAgICAgc3RhdGUuc291cmNlRnJhbWUuY29weUZyb20odGFyZ2V0LmZpbHRlckFyZWEgfHwgdGFyZ2V0LmdldEJvdW5kcyh0cnVlKSk7XHJcbiAgICAgICAgc3RhdGUuc291cmNlRnJhbWUucGFkKHBhZGRpbmcpO1xyXG4gICAgICAgIGlmIChhdXRvRml0KSB7XHJcbiAgICAgICAgICAgIHN0YXRlLnNvdXJjZUZyYW1lLmZpdCh0aGlzLnJlbmRlcmVyLnJlbmRlclRleHR1cmUuc291cmNlRnJhbWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyByb3VuZCB0byB3aG9sZSBudW1iZXIgYmFzZWQgb24gcmVzb2x1dGlvblxyXG4gICAgICAgIHN0YXRlLnNvdXJjZUZyYW1lLmNlaWwocmVzb2x1dGlvbik7XHJcbiAgICAgICAgc3RhdGUucmVuZGVyVGV4dHVyZSA9IHRoaXMuZ2V0T3B0aW1hbEZpbHRlclRleHR1cmUoc3RhdGUuc291cmNlRnJhbWUud2lkdGgsIHN0YXRlLnNvdXJjZUZyYW1lLmhlaWdodCwgcmVzb2x1dGlvbik7XHJcbiAgICAgICAgc3RhdGUuZmlsdGVycyA9IGZpbHRlcnM7XHJcbiAgICAgICAgc3RhdGUuZGVzdGluYXRpb25GcmFtZS53aWR0aCA9IHN0YXRlLnJlbmRlclRleHR1cmUud2lkdGg7XHJcbiAgICAgICAgc3RhdGUuZGVzdGluYXRpb25GcmFtZS5oZWlnaHQgPSBzdGF0ZS5yZW5kZXJUZXh0dXJlLmhlaWdodDtcclxuICAgICAgICBzdGF0ZS5yZW5kZXJUZXh0dXJlLmZpbHRlckZyYW1lID0gc3RhdGUuc291cmNlRnJhbWU7XHJcbiAgICAgICAgcmVuZGVyZXIucmVuZGVyVGV4dHVyZS5iaW5kKHN0YXRlLnJlbmRlclRleHR1cmUsIHN0YXRlLnNvdXJjZUZyYW1lKTsgLy8gLywgc3RhdGUuZGVzdGluYXRpb25GcmFtZSk7XHJcbiAgICAgICAgcmVuZGVyZXIucmVuZGVyVGV4dHVyZS5jbGVhcigpO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBQb3BzIG9mZiB0aGUgZmlsdGVyIGFuZCBhcHBsaWVzIGl0LlxyXG4gICAgICpcclxuICAgICAqL1xyXG4gICAgcG9wKCkge1xyXG4gICAgICAgIHZhciBmaWx0ZXJTdGFjayA9IHRoaXMuZGVmYXVsdEZpbHRlclN0YWNrO1xyXG4gICAgICAgIHZhciBzdGF0ZSA9IGZpbHRlclN0YWNrLnBvcCgpO1xyXG4gICAgICAgIHZhciBmaWx0ZXJzID0gc3RhdGUuZmlsdGVycztcclxuICAgICAgICB0aGlzLmFjdGl2ZVN0YXRlID0gc3RhdGU7XHJcbiAgICAgICAgdmFyIGdsb2JhbFVuaWZvcm1zID0gdGhpcy5nbG9iYWxVbmlmb3Jtcy51bmlmb3JtcztcclxuICAgICAgICBnbG9iYWxVbmlmb3Jtcy5vdXRwdXRGcmFtZSA9IHN0YXRlLnNvdXJjZUZyYW1lO1xyXG4gICAgICAgIGdsb2JhbFVuaWZvcm1zLnJlc29sdXRpb24gPSBzdGF0ZS5yZXNvbHV0aW9uO1xyXG4gICAgICAgIHZhciBpbnB1dFNpemUgPSBnbG9iYWxVbmlmb3Jtcy5pbnB1dFNpemU7XHJcbiAgICAgICAgdmFyIGlucHV0UGl4ZWwgPSBnbG9iYWxVbmlmb3Jtcy5pbnB1dFBpeGVsO1xyXG4gICAgICAgIHZhciBpbnB1dENsYW1wID0gZ2xvYmFsVW5pZm9ybXMuaW5wdXRDbGFtcDtcclxuICAgICAgICBpbnB1dFNpemVbMF0gPSBzdGF0ZS5kZXN0aW5hdGlvbkZyYW1lLndpZHRoO1xyXG4gICAgICAgIGlucHV0U2l6ZVsxXSA9IHN0YXRlLmRlc3RpbmF0aW9uRnJhbWUuaGVpZ2h0O1xyXG4gICAgICAgIGlucHV0U2l6ZVsyXSA9IDEuMCAvIGlucHV0U2l6ZVswXTtcclxuICAgICAgICBpbnB1dFNpemVbM10gPSAxLjAgLyBpbnB1dFNpemVbMV07XHJcbiAgICAgICAgaW5wdXRQaXhlbFswXSA9IGlucHV0U2l6ZVswXSAqIHN0YXRlLnJlc29sdXRpb247XHJcbiAgICAgICAgaW5wdXRQaXhlbFsxXSA9IGlucHV0U2l6ZVsxXSAqIHN0YXRlLnJlc29sdXRpb247XHJcbiAgICAgICAgaW5wdXRQaXhlbFsyXSA9IDEuMCAvIGlucHV0UGl4ZWxbMF07XHJcbiAgICAgICAgaW5wdXRQaXhlbFszXSA9IDEuMCAvIGlucHV0UGl4ZWxbMV07XHJcbiAgICAgICAgaW5wdXRDbGFtcFswXSA9IDAuNSAqIGlucHV0UGl4ZWxbMl07XHJcbiAgICAgICAgaW5wdXRDbGFtcFsxXSA9IDAuNSAqIGlucHV0UGl4ZWxbM107XHJcbiAgICAgICAgaW5wdXRDbGFtcFsyXSA9IChzdGF0ZS5zb3VyY2VGcmFtZS53aWR0aCAqIGlucHV0U2l6ZVsyXSkgLSAoMC41ICogaW5wdXRQaXhlbFsyXSk7XHJcbiAgICAgICAgaW5wdXRDbGFtcFszXSA9IChzdGF0ZS5zb3VyY2VGcmFtZS5oZWlnaHQgKiBpbnB1dFNpemVbM10pIC0gKDAuNSAqIGlucHV0UGl4ZWxbM10pO1xyXG4gICAgICAgIC8vIG9ubHkgdXBkYXRlIHRoZSByZWN0IGlmIGl0cyBsZWdhY3kuLlxyXG4gICAgICAgIGlmIChzdGF0ZS5sZWdhY3kpIHtcclxuICAgICAgICAgICAgdmFyIGZpbHRlckFyZWEgPSBnbG9iYWxVbmlmb3Jtcy5maWx0ZXJBcmVhO1xyXG4gICAgICAgICAgICBmaWx0ZXJBcmVhWzBdID0gc3RhdGUuZGVzdGluYXRpb25GcmFtZS53aWR0aDtcclxuICAgICAgICAgICAgZmlsdGVyQXJlYVsxXSA9IHN0YXRlLmRlc3RpbmF0aW9uRnJhbWUuaGVpZ2h0O1xyXG4gICAgICAgICAgICBmaWx0ZXJBcmVhWzJdID0gc3RhdGUuc291cmNlRnJhbWUueDtcclxuICAgICAgICAgICAgZmlsdGVyQXJlYVszXSA9IHN0YXRlLnNvdXJjZUZyYW1lLnk7XHJcbiAgICAgICAgICAgIGdsb2JhbFVuaWZvcm1zLmZpbHRlckNsYW1wID0gZ2xvYmFsVW5pZm9ybXMuaW5wdXRDbGFtcDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5nbG9iYWxVbmlmb3Jtcy51cGRhdGUoKTtcclxuICAgICAgICB2YXIgbGFzdFN0YXRlID0gZmlsdGVyU3RhY2tbZmlsdGVyU3RhY2subGVuZ3RoIC0gMV07XHJcbiAgICAgICAgaWYgKGZpbHRlcnMubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgICAgIGZpbHRlcnNbMF0uYXBwbHkodGhpcywgc3RhdGUucmVuZGVyVGV4dHVyZSwgbGFzdFN0YXRlLnJlbmRlclRleHR1cmUsIGZhbHNlLCBzdGF0ZSk7XHJcbiAgICAgICAgICAgIHRoaXMucmV0dXJuRmlsdGVyVGV4dHVyZShzdGF0ZS5yZW5kZXJUZXh0dXJlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciBmbGlwID0gc3RhdGUucmVuZGVyVGV4dHVyZTtcclxuICAgICAgICAgICAgdmFyIGZsb3AgPSB0aGlzLmdldE9wdGltYWxGaWx0ZXJUZXh0dXJlKGZsaXAud2lkdGgsIGZsaXAuaGVpZ2h0LCBzdGF0ZS5yZXNvbHV0aW9uKTtcclxuICAgICAgICAgICAgZmxvcC5maWx0ZXJGcmFtZSA9IGZsaXAuZmlsdGVyRnJhbWU7XHJcbiAgICAgICAgICAgIHZhciBpID0gMDtcclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGZpbHRlcnMubGVuZ3RoIC0gMTsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICBmaWx0ZXJzW2ldLmFwcGx5KHRoaXMsIGZsaXAsIGZsb3AsIHRydWUsIHN0YXRlKTtcclxuICAgICAgICAgICAgICAgIHZhciB0ID0gZmxpcDtcclxuICAgICAgICAgICAgICAgIGZsaXAgPSBmbG9wO1xyXG4gICAgICAgICAgICAgICAgZmxvcCA9IHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZmlsdGVyc1tpXS5hcHBseSh0aGlzLCBmbGlwLCBsYXN0U3RhdGUucmVuZGVyVGV4dHVyZSwgZmFsc2UsIHN0YXRlKTtcclxuICAgICAgICAgICAgdGhpcy5yZXR1cm5GaWx0ZXJUZXh0dXJlKGZsaXApO1xyXG4gICAgICAgICAgICB0aGlzLnJldHVybkZpbHRlclRleHR1cmUoZmxvcCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN0YXRlLmNsZWFyKCk7XHJcbiAgICAgICAgdGhpcy5zdGF0ZVBvb2wucHVzaChzdGF0ZSk7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIERyYXdzIGEgZmlsdGVyLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7UElYSS5GaWx0ZXJ9IGZpbHRlciAtIFRoZSBmaWx0ZXIgdG8gZHJhdy5cclxuICAgICAqIEBwYXJhbSB7UElYSS5SZW5kZXJUZXh0dXJlfSBpbnB1dCAtIFRoZSBpbnB1dCByZW5kZXIgdGFyZ2V0LlxyXG4gICAgICogQHBhcmFtIHtQSVhJLlJlbmRlclRleHR1cmV9IG91dHB1dCAtIFRoZSB0YXJnZXQgdG8gb3V0cHV0IHRvLlxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBjbGVhciAtIFNob3VsZCB0aGUgb3V0cHV0IGJlIGNsZWFyZWQgYmVmb3JlIHJlbmRlcmluZyB0byBpdFxyXG4gICAgICovXHJcbiAgICBhcHBseUZpbHRlcihmaWx0ZXIsIGlucHV0LCBvdXRwdXQsIGNsZWFyKSB7XHJcbiAgICAgICAgdmFyIHJlbmRlcmVyID0gdGhpcy5yZW5kZXJlcjtcclxuICAgICAgICByZW5kZXJlci5yZW5kZXJUZXh0dXJlLmJpbmQob3V0cHV0LCBvdXRwdXQgPyBvdXRwdXQuZmlsdGVyRnJhbWUgOiBudWxsKTtcclxuICAgICAgICBpZiAoY2xlYXIpIHtcclxuICAgICAgICAgICAgLy8gZ2wuZGlzYWJsZShnbC5TQ0lTU09SX1RFU1QpO1xyXG4gICAgICAgICAgICByZW5kZXJlci5yZW5kZXJUZXh0dXJlLmNsZWFyKCk7XHJcbiAgICAgICAgICAgIC8vIGdsLmVuYWJsZShnbC5TQ0lTU09SX1RFU1QpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBzZXQgdGhlIHVuaWZvcm1zLi5cclxuICAgICAgICBmaWx0ZXIudW5pZm9ybXMudVNhbXBsZXIgPSBpbnB1dDtcclxuICAgICAgICBmaWx0ZXIudW5pZm9ybXMuZmlsdGVyR2xvYmFscyA9IHRoaXMuZ2xvYmFsVW5pZm9ybXM7XHJcbiAgICAgICAgLy8gVE9ETyBtYWtlIGl0IHNvIHRoYXQgdGhlIG9yZGVyIG9mIHRoaXMgZG9lcyBub3QgbWF0dGVyLi5cclxuICAgICAgICAvLyBiZWNhdXNlIGl0IGRvZXMgYXQgdGhlIG1vbWVudCBjb3Mgb2YgZ2xvYmFsIHVuaWZvcm1zLlxyXG4gICAgICAgIC8vIHRoZXkgbmVlZCB0byBnZXQgcmVzeW5jZWRcclxuICAgICAgICByZW5kZXJlci5zdGF0ZS5zZXRTdGF0ZShmaWx0ZXIuc3RhdGUpO1xyXG4gICAgICAgIHJlbmRlcmVyLnNoYWRlci5iaW5kKGZpbHRlcik7XHJcbiAgICAgICAgaWYgKGZpbHRlci5sZWdhY3kpIHtcclxuICAgICAgICAgICAgdGhpcy5xdWFkVXYubWFwKGlucHV0Ll9mcmFtZSwgaW5wdXQuZmlsdGVyRnJhbWUpO1xyXG4gICAgICAgICAgICByZW5kZXJlci5nZW9tZXRyeS5iaW5kKHRoaXMucXVhZFV2KTtcclxuICAgICAgICAgICAgcmVuZGVyZXIuZ2VvbWV0cnkuZHJhdyhEcmF3TW9kZVNldHRpbmdzXzEuRHJhd01vZGVTZXR0aW5ncy5EUkFXX01PREVTLlRSSUFOR0xFUyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZW5kZXJlci5nZW9tZXRyeS5iaW5kKHRoaXMucXVhZCk7XHJcbiAgICAgICAgICAgIHJlbmRlcmVyLmdlb21ldHJ5LmRyYXcoRHJhd01vZGVTZXR0aW5nc18xLkRyYXdNb2RlU2V0dGluZ3MuRFJBV19NT0RFUy5UUklBTkdMRV9TVFJJUCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxjdWxhdGVzIHRoZSBtYXBwZWQgbWF0cml4LlxyXG4gICAgICpcclxuICAgICAqIFRPRE8gcGxheWluZyBhcm91bmQgaGVyZS4uIHRoaXMgaXMgdGVtcG9yYXJ5IC0gKHdpbGwgZW5kIHVwIGluIHRoZSBzaGFkZXIpXHJcbiAgICAgKiB0aGlzIHJldHVybnMgYSBtYXRyaXggdGhhdCB3aWxsIG5vcm1hbGl6ZSBtYXAgZmlsdGVyIGNvcmRzIGluIHRoZSBmaWx0ZXIgdG8gc2NyZWVuIHNwYWNlXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtQSVhJLk1hdHJpeH0gb3V0cHV0TWF0cml4IC0gdGhlIG1hdHJpeCB0byBvdXRwdXQgdG8uXHJcbiAgICAgKiBAcmV0dXJuIHtQSVhJLk1hdHJpeH0gVGhlIG1hcHBlZCBtYXRyaXguXHJcbiAgICAgKi9cclxuICAgIGNhbGN1bGF0ZVNjcmVlblNwYWNlTWF0cml4KG91dHB1dE1hdHJpeCkge1xyXG4gICAgICAgIHZhciBjdXJyZW50U3RhdGUgPSB0aGlzLmFjdGl2ZVN0YXRlO1xyXG4gICAgICAgIHJldHVybiBGaWx0ZXJTeXN0ZW0uY2FsY3VsYXRlU2NyZWVuU3BhY2VNYXRyaXgob3V0cHV0TWF0cml4LCBjdXJyZW50U3RhdGUuc291cmNlRnJhbWUsIGN1cnJlbnRTdGF0ZS5kZXN0aW5hdGlvbkZyYW1lKTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogVGhpcyB3aWxsIG1hcCB0aGUgZmlsdGVyIGNvb3JkIHNvIHRoYXQgYSB0ZXh0dXJlIGNhbiBiZSB1c2VkIGJhc2VkIG9uIHRoZSB0cmFuc2Zvcm0gb2YgYSBzcHJpdGVcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1BJWEkuTWF0cml4fSBvdXRwdXRNYXRyaXggLSBUaGUgbWF0cml4IHRvIG91dHB1dCB0by5cclxuICAgICAqIEBwYXJhbSB7UElYSS5TcHJpdGV9IHNwcml0ZSAtIFRoZSBzcHJpdGUgdG8gbWFwIHRvLlxyXG4gICAgICogQHJldHVybiB7UElYSS5NYXRyaXh9IFRoZSBtYXBwZWQgbWF0cml4LlxyXG4gICAgICovXHJcbiAgICBjYWxjdWxhdGVTcHJpdGVNYXRyaXgob3V0cHV0TWF0cml4LCBzcHJpdGUpIHtcclxuICAgICAgICB2YXIgY3VycmVudFN0YXRlID0gdGhpcy5hY3RpdmVTdGF0ZTtcclxuICAgICAgICByZXR1cm4gRmlsdGVyU3lzdGVtLmNhbGN1bGF0ZVNwcml0ZU1hdHJpeChvdXRwdXRNYXRyaXgsIGN1cnJlbnRTdGF0ZS5zb3VyY2VGcmFtZSwgY3VycmVudFN0YXRlLmRlc3RpbmF0aW9uRnJhbWUsIHNwcml0ZSk7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIERlc3Ryb3lzIHRoaXMgRmlsdGVyIFN5c3RlbS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtjb250ZXh0TG9zdD1mYWxzZV0gY29udGV4dCB3YXMgbG9zdCwgZG8gbm90IGZyZWUgc2hhZGVyc1xyXG4gICAgICpcclxuICAgICAqL1xyXG4gICAgZGVzdHJveShjb250ZXh0TG9zdCkge1xyXG4gICAgICAgIGlmIChjb250ZXh0TG9zdCA9PT0gdm9pZCAwKSB7XHJcbiAgICAgICAgICAgIGNvbnRleHRMb3N0ID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghY29udGV4dExvc3QpIHtcclxuICAgICAgICAgICAgdGhpcy5lbXB0eVBvb2woKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMudGV4dHVyZVBvb2wgPSB7fTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgYSBQb3dlci1vZi1Ud28gcmVuZGVyIHRleHR1cmUgb3IgZnVsbFNjcmVlbiB0ZXh0dXJlXHJcbiAgICAgKlxyXG4gICAgICogVE9ETyBtb3ZlIHRvIGEgc2VwYXJhdGUgY2xhc3MgY291bGQgYmUgb24gcmVuZGVyZXI/XHJcbiAgICAgKlxyXG4gICAgICogQHByb3RlY3RlZFxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1pbldpZHRoIC0gVGhlIG1pbmltdW0gd2lkdGggb2YgdGhlIHJlbmRlciB0ZXh0dXJlIGluIHJlYWwgcGl4ZWxzLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1pbkhlaWdodCAtIFRoZSBtaW5pbXVtIGhlaWdodCBvZiB0aGUgcmVuZGVyIHRleHR1cmUgaW4gcmVhbCBwaXhlbHMuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3Jlc29sdXRpb249MV0gLSBUaGUgcmVzb2x1dGlvbiBvZiB0aGUgcmVuZGVyIHRleHR1cmUuXHJcbiAgICAgKiBAcmV0dXJuIHtQSVhJLlJlbmRlclRleHR1cmV9IFRoZSBuZXcgcmVuZGVyIHRleHR1cmUuXHJcbiAgICAgKi9cclxuICAgIGdldE9wdGltYWxGaWx0ZXJUZXh0dXJlKG1pbldpZHRoLCBtaW5IZWlnaHQsIHJlc29sdXRpb24pIHtcclxuICAgICAgICBpZiAocmVzb2x1dGlvbiA9PT0gdm9pZCAwKSB7XHJcbiAgICAgICAgICAgIHJlc29sdXRpb24gPSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIga2V5ID0gRmlsdGVyU3lzdGVtLnNjcmVlbktleTtcclxuICAgICAgICBtaW5XaWR0aCAqPSByZXNvbHV0aW9uO1xyXG4gICAgICAgIG1pbkhlaWdodCAqPSByZXNvbHV0aW9uO1xyXG4gICAgICAgIGlmIChtaW5XaWR0aCAhPT0gdGhpcy5fcGl4ZWxzV2lkdGggfHwgbWluSGVpZ2h0ICE9PSB0aGlzLl9waXhlbHNIZWlnaHQpIHtcclxuICAgICAgICAgICAgbWluV2lkdGggPSBNYXRoU2V0dGluZ3NfMS5NYXRoU2V0dGluZ3MubmV4dFBvdzIobWluV2lkdGgpO1xyXG4gICAgICAgICAgICBtaW5IZWlnaHQgPSBNYXRoU2V0dGluZ3NfMS5NYXRoU2V0dGluZ3MubmV4dFBvdzIobWluSGVpZ2h0KTtcclxuICAgICAgICAgICAga2V5ID0gKChtaW5XaWR0aCAmIDB4RkZGRikgPDwgMTYpIHwgKG1pbkhlaWdodCAmIDB4RkZGRik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghdGhpcy50ZXh0dXJlUG9vbFtrZXldKSB7XHJcbiAgICAgICAgICAgIHRoaXMudGV4dHVyZVBvb2xba2V5XSA9IFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcmVuZGVyVGV4dHVyZSA9IHRoaXMudGV4dHVyZVBvb2xba2V5XS5wb3AoKTtcclxuICAgICAgICBpZiAoIXJlbmRlclRleHR1cmUpIHtcclxuICAgICAgICAgICAgLy8gdGVtcG9yYXJ5IGJ5cGFzcyBjYWNoZS4uXHJcbiAgICAgICAgICAgIC8vIGludGVybmFsbHkgLSB0aGlzIHdpbGwgY2F1c2UgYSB0ZXh0dXJlIHRvIGJlIGJvdW5kLi5cclxuICAgICAgICAgICAgcmVuZGVyVGV4dHVyZSA9IFJlbmRlclRleHR1cmVfMS5SZW5kZXJUZXh0dXJlLmNyZWF0ZSh7XHJcbiAgICAgICAgICAgICAgICB3aWR0aDogbWluV2lkdGggLyByZXNvbHV0aW9uLFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBtaW5IZWlnaHQgLyByZXNvbHV0aW9uLFxyXG4gICAgICAgICAgICAgICAgcmVzb2x1dGlvbjogcmVzb2x1dGlvbixcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlbmRlclRleHR1cmUuZmlsdGVyUG9vbEtleSA9IGtleTtcclxuICAgICAgICByZXR1cm4gcmVuZGVyVGV4dHVyZTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBleHRyYSByZW5kZXIgdGV4dHVyZSB0byB1c2UgaW5zaWRlIGN1cnJlbnQgZmlsdGVyXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJlc29sdXRpb24gcmVzb2x1dGlvbiBvZiB0aGUgcmVuZGVyVGV4dHVyZVxyXG4gICAgICogQHJldHVybnMge1BJWEkuUmVuZGVyVGV4dHVyZX1cclxuICAgICAqL1xyXG4gICAgZ2V0RmlsdGVyVGV4dHVyZShyZXNvbHV0aW9uKSB7XHJcbiAgICAgICAgdmFyIHJ0ID0gdGhpcy5hY3RpdmVTdGF0ZS5yZW5kZXJUZXh0dXJlO1xyXG4gICAgICAgIHZhciBmaWx0ZXJUZXh0dXJlID0gdGhpcy5nZXRPcHRpbWFsRmlsdGVyVGV4dHVyZShydC53aWR0aCwgcnQuaGVpZ2h0LCByZXNvbHV0aW9uIHx8IHJ0LmJhc2VUZXh0dXJlLnJlc29sdXRpb24pO1xyXG4gICAgICAgIGZpbHRlclRleHR1cmUuZmlsdGVyRnJhbWUgPSBydC5maWx0ZXJGcmFtZTtcclxuICAgICAgICByZXR1cm4gZmlsdGVyVGV4dHVyZTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogRnJlZXMgYSByZW5kZXIgdGV4dHVyZSBiYWNrIGludG8gdGhlIHBvb2wuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtQSVhJLlJlbmRlclRleHR1cmV9IHJlbmRlclRleHR1cmUgLSBUaGUgcmVuZGVyVGFyZ2V0IHRvIGZyZWVcclxuICAgICAqL1xyXG4gICAgcmV0dXJuRmlsdGVyVGV4dHVyZShyZW5kZXJUZXh0dXJlKSB7XHJcbiAgICAgICAgdmFyIGtleSA9IHJlbmRlclRleHR1cmUuZmlsdGVyUG9vbEtleTtcclxuICAgICAgICByZW5kZXJUZXh0dXJlLmZpbHRlckZyYW1lID0gbnVsbDtcclxuICAgICAgICB0aGlzLnRleHR1cmVQb29sW2tleV0ucHVzaChyZW5kZXJUZXh0dXJlKTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogRW1wdGllcyB0aGUgdGV4dHVyZSBwb29sLlxyXG4gICAgICpcclxuICAgICAqL1xyXG4gICAgZW1wdHlQb29sKCkge1xyXG4gICAgICAgIGZvciAodmFyIGkgaW4gdGhpcy50ZXh0dXJlUG9vbCkge1xyXG4gICAgICAgICAgICB2YXIgdGV4dHVyZXMgPSB0aGlzLnRleHR1cmVQb29sW2ldO1xyXG4gICAgICAgICAgICBpZiAodGV4dHVyZXMpIHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGV4dHVyZXMubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlc1tqXS5kZXN0cm95KHRydWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMudGV4dHVyZVBvb2wgPSB7fTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIHJlc2l6ZSgpIHtcclxuICAgICAgICB2YXIgdGV4dHVyZXMgPSB0aGlzLnRleHR1cmVQb29sW0ZpbHRlclN5c3RlbS5zY3JlZW5LZXldO1xyXG4gICAgICAgIGlmICh0ZXh0dXJlcykge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRleHR1cmVzLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICB0ZXh0dXJlc1tqXS5kZXN0cm95KHRydWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMudGV4dHVyZVBvb2xbRmlsdGVyU3lzdGVtLnNjcmVlbktleV0gPSBbXTtcclxuICAgICAgICB0aGlzLl9waXhlbHNXaWR0aCA9IHRoaXMucmVuZGVyZXIudmlldy53aWR0aDtcclxuICAgICAgICB0aGlzLl9waXhlbHNIZWlnaHQgPSB0aGlzLnJlbmRlcmVyLnZpZXcuaGVpZ2h0O1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLy8gdGhpcyB3aWxsIG1hcCB0aGUgZmlsdGVyIGNvb3JkIHNvIHRoYXQgYSB0ZXh0dXJlIGNhbiBiZSB1c2VkIGJhc2VkIG9uIHRoZSB0cmFuc2Zvcm0gb2YgYSBzcHJpdGVcclxuICAgIHN0YXRpYyBjYWxjdWxhdGVTcHJpdGVNYXRyaXgob3V0cHV0TWF0cml4LCBmaWx0ZXJBcmVhLCB0ZXh0dXJlU2l6ZSwgc3ByaXRlKSB7XHJcbiAgICAgICAgdmFyIG9yaWcgPSBzcHJpdGUuX3RleHR1cmUub3JpZztcclxuICAgICAgICB2YXIgbWFwcGVkTWF0cml4ID0gb3V0cHV0TWF0cml4LnNldCh0ZXh0dXJlU2l6ZS53aWR0aCwgMCwgMCwgdGV4dHVyZVNpemUuaGVpZ2h0LCBmaWx0ZXJBcmVhLngsIGZpbHRlckFyZWEueSk7XHJcbiAgICAgICAgdmFyIHdvcmxkVHJhbnNmb3JtID0gc3ByaXRlLndvcmxkVHJhbnNmb3JtLmNvcHlUbyhNYXRyaXhfMS5NYXRyaXguVEVNUF9NQVRSSVgpO1xyXG4gICAgICAgIHdvcmxkVHJhbnNmb3JtLmludmVydCgpO1xyXG4gICAgICAgIG1hcHBlZE1hdHJpeC5wcmVwZW5kKHdvcmxkVHJhbnNmb3JtKTtcclxuICAgICAgICBtYXBwZWRNYXRyaXguc2NhbGUoMS4wIC8gb3JpZy53aWR0aCwgMS4wIC8gb3JpZy5oZWlnaHQpO1xyXG4gICAgICAgIG1hcHBlZE1hdHJpeC50cmFuc2xhdGUoc3ByaXRlLmFuY2hvci54LCBzcHJpdGUuYW5jaG9yLnkpO1xyXG4gICAgICAgIHJldHVybiBtYXBwZWRNYXRyaXg7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICogQ2FsY3VsYXRlcyB0aGUgbWFwcGVkIG1hdHJpeFxyXG4gKiBAcGFyYW0ge1BJWEkuTWF0cml4fSBvdXRwdXRNYXRyaXggbWF0cml4IHRoYXQgd2lsbCBub3JtYWxpemUgbWFwIGZpbHRlciBjb3JkcyBpbiB0aGUgZmlsdGVyIHRvIHNjcmVlbiBzcGFjZVxyXG4gKiBAcGFyYW0ge1BJWEkuUmVjdGFuZ2xlfSBmaWx0ZXJBcmVhIGZpbHRlciBhcmVhXHJcbiAqIEBwYXJhbSB7UElYSS5SZWN0YW5nbGV9IHRleHR1cmVTaXplIHRleHR1cmUgc2l6ZVxyXG4gKiBAcmV0dXJucyB7UElYSS5NYXRyaXh9IHNhbWUgYXMgb3V0cHV0TWF0cml4XHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG4gICAgc3RhdGljIGNhbGN1bGF0ZVNjcmVlblNwYWNlTWF0cml4KG91dHB1dE1hdHJpeCwgZmlsdGVyQXJlYSwgdGV4dHVyZVNpemUpIHtcclxuICAgICAgICAvLyBUT0RPIHVud3JhcD9cclxuICAgICAgICB2YXIgbWFwcGVkTWF0cml4ID0gb3V0cHV0TWF0cml4LmlkZW50aXR5KCk7XHJcbiAgICAgICAgbWFwcGVkTWF0cml4LnRyYW5zbGF0ZShmaWx0ZXJBcmVhLnggLyB0ZXh0dXJlU2l6ZS53aWR0aCwgZmlsdGVyQXJlYS55IC8gdGV4dHVyZVNpemUuaGVpZ2h0KTtcclxuICAgICAgICBtYXBwZWRNYXRyaXguc2NhbGUodGV4dHVyZVNpemUud2lkdGgsIHRleHR1cmVTaXplLmhlaWdodCk7XHJcbiAgICAgICAgcmV0dXJuIG1hcHBlZE1hdHJpeDtcclxuICAgIH1cclxufVxyXG5GaWx0ZXJTeXN0ZW0uc2NyZWVuS2V5ID0gJ3NjcmVlbic7XHJcbmV4cG9ydHMuRmlsdGVyU3lzdGVtID0gRmlsdGVyU3lzdGVtO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jbGFzcyBGbGFzaEJhc2VPYmplY3Qge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgRmxhc2hCYXNlT2JqZWN0Lm5hbWVDb3VudCsrO1xyXG4gICAgICAgIHRoaXMuX25hbWUgPSBcImluc3RhbmNlLVwiICsgdGhpcy5jbGFzc05hbWUgKyBcIi1cIiArIEZsYXNoQmFzZU9iamVjdC5uYW1lQ291bnQ7XHJcbiAgICAgICAgdGhpcy5faW5zdGFuY2VOYW1lID0gXCJpbnN0YW5jZS1cIiArIHRoaXMuY2xhc3NOYW1lICsgXCItXCIgKyBGbGFzaEJhc2VPYmplY3QubmFtZUNvdW50O1xyXG4gICAgICAgIHRoaXMuX2hhc0NoYW5nZWQgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuX2NsYXNzTmFtZSA9IHRoaXMuY29uc3RydWN0b3JbJ25hbWUnXTtcclxuICAgIH1cclxuICAgIGdldCBjbGFzc05hbWUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3JbJ25hbWUnXTtcclxuICAgIH1cclxuICAgIGRlc3RydWN0b3IoKSB7XHJcbiAgICB9XHJcbiAgICBnZXQgaGFzQ2hhbmdlZCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5faGFzQ2hhbmdlZDtcclxuICAgIH1cclxuICAgIHNldCBoYXNDaGFuZ2VkKHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5faGFzQ2hhbmdlZCA9IHZhbHVlO1xyXG4gICAgfVxyXG4gICAgZ2V0IG5hbWUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX25hbWU7XHJcbiAgICB9XHJcbiAgICBzZXQgbmFtZSh2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuX25hbWUgPSB2YWx1ZTtcclxuICAgIH1cclxuICAgIGdldCBpbnN0YW5jZU5hbWUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luc3RhbmNlTmFtZTtcclxuICAgIH1cclxufVxyXG5GbGFzaEJhc2VPYmplY3QubmFtZUNvdW50ID0gMDtcclxuZXhwb3J0cy5GbGFzaEJhc2VPYmplY3QgPSBGbGFzaEJhc2VPYmplY3Q7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IEJhc2VUZXh0dXJlXzEgPSByZXF1aXJlKFwiLi9CYXNlVGV4dHVyZVwiKTtcclxuY29uc3QgRGVwdGhSZXNvdXJjZV8xID0gcmVxdWlyZShcIi4vRGVwdGhSZXNvdXJjZVwiKTtcclxuY29uc3QgV2ViR0xTZXR0aW5nc18xID0gcmVxdWlyZShcIi4vV2ViR0xTZXR0aW5nc1wiKTtcclxuY29uc3QgUnVubmVyXzEgPSByZXF1aXJlKFwiLi9SdW5uZXJcIik7XHJcbmNsYXNzIEZyYW1lYnVmZmVyIHtcclxuICAgIGNvbnN0cnVjdG9yKHdpZHRoLCBoZWlnaHQpIHtcclxuICAgICAgICB0aGlzLndpZHRoID0gTWF0aC5jZWlsKHdpZHRoIHx8IDEwMCk7XHJcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBNYXRoLmNlaWwoaGVpZ2h0IHx8IDEwMCk7XHJcbiAgICAgICAgdGhpcy5zdGVuY2lsID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5kZXB0aCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuZGlydHlJZCA9IDA7XHJcbiAgICAgICAgdGhpcy5kaXJ0eUZvcm1hdCA9IDA7XHJcbiAgICAgICAgdGhpcy5kaXJ0eVNpemUgPSAwO1xyXG4gICAgICAgIHRoaXMuZGVwdGhUZXh0dXJlID0gbnVsbDtcclxuICAgICAgICB0aGlzLmNvbG9yVGV4dHVyZXMgPSBbXTtcclxuICAgICAgICB0aGlzLmdsRnJhbWVidWZmZXJzID0ge307XHJcbiAgICAgICAgdGhpcy5kaXNwb3NlUnVubmVyID0gbmV3IFJ1bm5lcl8xLlJ1bm5lcignZGlzcG9zZUZyYW1lYnVmZmVyJywgMik7XHJcbiAgICAgICAgLy8gdGhpcy5kaXNwb3NlUnVubmVyID0gbmV3IFJ1bm5lcignZGlzcG9zZUZyYW1lYnVmZmVyJywgMik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlZmVyZW5jZSB0byB0aGUgY29sb3JUZXh0dXJlLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge1BJWEkuVGV4dHVyZVtdfVxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKi9cclxuICAgIGdldCBjb2xvclRleHR1cmUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29sb3JUZXh0dXJlc1swXTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQWRkIHRleHR1cmUgdG8gdGhlIGNvbG9yVGV4dHVyZSBhcnJheVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbaW5kZXg9MF0gLSBJbmRleCBvZiB0aGUgYXJyYXkgdG8gYWRkIHRoZSB0ZXh0dXJlIHRvXHJcbiAgICAgKiBAcGFyYW0ge1BJWEkuVGV4dHVyZX0gW3RleHR1cmVdIC0gVGV4dHVyZSB0byBhZGQgdG8gdGhlIGFycmF5XHJcbiAgICAgKi9cclxuICAgIGFkZENvbG9yVGV4dHVyZShpbmRleCwgdGV4dHVyZSkge1xyXG4gICAgICAgIGlmIChpbmRleCA9PT0gdm9pZCAwKSB7XHJcbiAgICAgICAgICAgIGluZGV4ID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gVE9ETyBhZGQgc29tZSB2YWxpZGF0aW9uIHRvIHRoZSB0ZXh0dXJlIC0gc2FtZSB3aWR0aCAvIGhlaWdodCBldGM/XHJcbiAgICAgICAgdGhpcy5jb2xvclRleHR1cmVzW2luZGV4XSA9IHRleHR1cmUgfHwgbmV3IEJhc2VUZXh0dXJlXzEuQmFzZVRleHR1cmUobnVsbCwgeyBzY2FsZU1vZGU6IDAsXHJcbiAgICAgICAgICAgIHJlc29sdXRpb246IDEsXHJcbiAgICAgICAgICAgIG1pcG1hcDogZmFsc2UsXHJcbiAgICAgICAgICAgIHdpZHRoOiB0aGlzLndpZHRoLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0IH0pOyAvLyB8fCBuZXcgVGV4dHVyZSgpO1xyXG4gICAgICAgIHRoaXMuZGlydHlJZCsrO1xyXG4gICAgICAgIHRoaXMuZGlydHlGb3JtYXQrKztcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQWRkIGEgZGVwdGggdGV4dHVyZSB0byB0aGUgZnJhbWUgYnVmZmVyXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtQSVhJLlRleHR1cmV9IFt0ZXh0dXJlXSAtIFRleHR1cmUgdG8gYWRkXHJcbiAgICAgKi9cclxuICAgIGFkZERlcHRoVGV4dHVyZSh0ZXh0dXJlKSB7XHJcbiAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xyXG4gICAgICAgIHRoaXMuZGVwdGhUZXh0dXJlID0gdGV4dHVyZSB8fCBuZXcgQmFzZVRleHR1cmVfMS5CYXNlVGV4dHVyZShuZXcgRGVwdGhSZXNvdXJjZV8xLkRlcHRoUmVzb3VyY2UobnVsbCwgeyB3aWR0aDogdGhpcy53aWR0aCwgaGVpZ2h0OiB0aGlzLmhlaWdodCB9KSwgeyBzY2FsZU1vZGU6IDAsXHJcbiAgICAgICAgICAgIHJlc29sdXRpb246IDEsXHJcbiAgICAgICAgICAgIHdpZHRoOiB0aGlzLndpZHRoLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0LFxyXG4gICAgICAgICAgICBtaXBtYXA6IGZhbHNlLFxyXG4gICAgICAgICAgICBmb3JtYXQ6IFdlYkdMU2V0dGluZ3NfMS5XZWJHTFNldHRpbmdzLkZPUk1BVFMuREVQVEhfQ09NUE9ORU5ULFxyXG4gICAgICAgICAgICB0eXBlOiBXZWJHTFNldHRpbmdzXzEuV2ViR0xTZXR0aW5ncy5UWVBFUy5VTlNJR05FRF9TSE9SVCB9KTsgLy8gVU5TSUdORURfU0hPUlQ7XHJcbiAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xyXG4gICAgICAgIHRoaXMuZGlydHlJZCsrO1xyXG4gICAgICAgIHRoaXMuZGlydHlGb3JtYXQrKztcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogRW5hYmxlIGRlcHRoIG9uIHRoZSBmcmFtZSBidWZmZXJcclxuICAgICAqL1xyXG4gICAgZW5hYmxlRGVwdGgoKSB7XHJcbiAgICAgICAgdGhpcy5kZXB0aCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5kaXJ0eUlkKys7XHJcbiAgICAgICAgdGhpcy5kaXJ0eUZvcm1hdCsrO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBFbmFibGUgc3RlbmNpbCBvbiB0aGUgZnJhbWUgYnVmZmVyXHJcbiAgICAgKi9cclxuICAgIGVuYWJsZVN0ZW5jaWwoKSB7XHJcbiAgICAgICAgdGhpcy5zdGVuY2lsID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmRpcnR5SWQrKztcclxuICAgICAgICB0aGlzLmRpcnR5Rm9ybWF0Kys7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFJlc2l6ZSB0aGUgZnJhbWUgYnVmZmVyXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIC0gV2lkdGggb2YgdGhlIGZyYW1lIGJ1ZmZlciB0byByZXNpemUgdG9cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgLSBIZWlnaHQgb2YgdGhlIGZyYW1lIGJ1ZmZlciB0byByZXNpemUgdG9cclxuICAgICAqL1xyXG4gICAgcmVzaXplKHdpZHRoLCBoZWlnaHQpIHtcclxuICAgICAgICB3aWR0aCA9IE1hdGguY2VpbCh3aWR0aCk7XHJcbiAgICAgICAgaGVpZ2h0ID0gTWF0aC5jZWlsKGhlaWdodCk7XHJcbiAgICAgICAgaWYgKHdpZHRoID09PSB0aGlzLndpZHRoICYmIGhlaWdodCA9PT0gdGhpcy5oZWlnaHQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLndpZHRoID0gd2lkdGg7XHJcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XHJcbiAgICAgICAgdGhpcy5kaXJ0eUlkKys7XHJcbiAgICAgICAgdGhpcy5kaXJ0eVNpemUrKztcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY29sb3JUZXh0dXJlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgdGV4dHVyZSA9IHRoaXMuY29sb3JUZXh0dXJlc1tpXTtcclxuICAgICAgICAgICAgdmFyIHJlc29sdXRpb24gPSB0ZXh0dXJlLnJlc29sdXRpb247XHJcbiAgICAgICAgICAgIC8vIHRha2UgaW50byBhY291bnQgdGhlIGZhY3QgdGhlIHRleHR1cmUgbWF5IGhhdmUgYSBkaWZmZXJlbnQgcmVzb2x1dGlvbi4uXHJcbiAgICAgICAgICAgIHRleHR1cmUuc2V0U2l6ZSh3aWR0aCAvIHJlc29sdXRpb24sIGhlaWdodCAvIHJlc29sdXRpb24pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5kZXB0aFRleHR1cmUpIHtcclxuICAgICAgICAgICAgdmFyIHJlc29sdXRpb24kMSA9IHRoaXMuZGVwdGhUZXh0dXJlLnJlc29sdXRpb247XHJcbiAgICAgICAgICAgIHRoaXMuZGVwdGhUZXh0dXJlLnNldFNpemUod2lkdGggLyByZXNvbHV0aW9uJDEsIGhlaWdodCAvIHJlc29sdXRpb24kMSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBkaXNwb3NlcyBXZWJHTCByZXNvdXJjZXMgdGhhdCBhcmUgY29ubmVjdGVkIHRvIHRoaXMgZ2VvbWV0cnlcclxuICAgICAqL1xyXG4gICAgZGlzcG9zZSgpIHtcclxuICAgICAgICAvLyB0aGlzLmRpc3Bvc2VSdW5uZXIucnVuKHRoaXMsIGZhbHNlKTtcclxuICAgICAgICB0aGlzLmRpc3Bvc2VSdW5uZXIucnVuKHRoaXMsIGZhbHNlKTtcclxuICAgIH1cclxuICAgIDtcclxufVxyXG5leHBvcnRzLkZyYW1lYnVmZmVyID0gRnJhbWVidWZmZXI7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IFN5c3RlbV8xID0gcmVxdWlyZShcIi4vU3lzdGVtXCIpO1xyXG5jb25zdCBGcmFtZWJ1ZmZlcl8xID0gcmVxdWlyZShcIi4vRnJhbWVidWZmZXJcIik7XHJcbmNvbnN0IFJlY3RhbmdsZV8xID0gcmVxdWlyZShcIi4vUmVjdGFuZ2xlXCIpO1xyXG5jb25zdCBEaXNwbGF5U2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL0Rpc3BsYXlTZXR0aW5nc1wiKTtcclxuY2xhc3MgRnJhbWVidWZmZXJTeXN0ZW0gZXh0ZW5kcyBTeXN0ZW1fMS5TeXN0ZW0ge1xyXG4gICAgY29uc3RydWN0b3IocmVuZGVyZXIpIHtcclxuICAgICAgICBzdXBlcihyZW5kZXJlcik7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQSBsaXN0IG9mIG1hbmFnZWQgZnJhbWVidWZmZXJzXHJcbiAgICAgICAgICogQG1lbWJlciB7UElYSS5GcmFtZWJ1ZmZlcltdfVxyXG4gICAgICAgICAqIEByZWFkb25seVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMubWFuYWdlZEZyYW1lYnVmZmVycyA9IFtdO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEZyYW1lYnVmZmVyIHZhbHVlIHRoYXQgc2hvd3MgdGhhdCB3ZSBkb24ndCBrbm93IHdoYXQgaXMgYm91bmRcclxuICAgICAgICAgKiBAbWVtYmVyIHtGcmFtZWJ1ZmZlcn1cclxuICAgICAgICAgKiBAcmVhZG9ubHlcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnVua25vd25GcmFtZWJ1ZmZlciA9IG5ldyBGcmFtZWJ1ZmZlcl8xLkZyYW1lYnVmZmVyKDEwLCAxMCk7XHJcbiAgICAgICAgdGhpcy52aWV3cG9ydCA9IG5ldyBSZWN0YW5nbGVfMS5SZWN0YW5nbGUoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB1cCB0aGUgcmVuZGVyZXIgY29udGV4dCBhbmQgbmVjZXNzYXJ5IGJ1ZmZlcnMuXHJcbiAgICAgKi9cclxuICAgIGNvbnRleHRDaGFuZ2UoZ2wpIHtcclxuICAgICAgICB2YXIgZ2wgPSB0aGlzLmdsID0gdGhpcy5yZW5kZXJlci5nbDtcclxuICAgICAgICB0aGlzLkNPTlRFWFRfVUlEID0gdGhpcy5yZW5kZXJlci5DT05URVhUX1VJRDtcclxuICAgICAgICB0aGlzLmN1cnJlbnQgPSB0aGlzLnVua25vd25GcmFtZWJ1ZmZlcjtcclxuICAgICAgICB0aGlzLnZpZXdwb3J0ID0gbmV3IFJlY3RhbmdsZV8xLlJlY3RhbmdsZSgpO1xyXG4gICAgICAgIHRoaXMuaGFzTVJUID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLndyaXRlRGVwdGhUZXh0dXJlID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmRpc3Bvc2VBbGwodHJ1ZSk7XHJcbiAgICAgICAgLy8gd2ViZ2wyXHJcbiAgICAgICAgaWYgKHRoaXMucmVuZGVyZXIuY29udGV4dC53ZWJHTFZlcnNpb24gPT09IDEpIHtcclxuICAgICAgICAgICAgLy8gd2ViZ2wgMSFcclxuICAgICAgICAgICAgdmFyIG5hdGl2ZURyYXdCdWZmZXJzRXh0ZW5zaW9uID0gdGhpcy5yZW5kZXJlci5jb250ZXh0LmV4dGVuc2lvbnMuZHJhd0J1ZmZlcnM7XHJcbiAgICAgICAgICAgIHZhciBuYXRpdmVEZXB0aFRleHR1cmVFeHRlbnNpb24gPSB0aGlzLnJlbmRlcmVyLmNvbnRleHQuZXh0ZW5zaW9ucy5kZXB0aFRleHR1cmU7XHJcbiAgICAgICAgICAgIGlmIChEaXNwbGF5U2V0dGluZ3NfMS5EaXNwbGF5U2V0dGluZ3MuUFJFRkVSX0VOViA9PT0gRGlzcGxheVNldHRpbmdzXzEuRGlzcGxheVNldHRpbmdzLkVOVi5XRUJHTF9MRUdBQ1kpIHtcclxuICAgICAgICAgICAgICAgIG5hdGl2ZURyYXdCdWZmZXJzRXh0ZW5zaW9uID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIG5hdGl2ZURlcHRoVGV4dHVyZUV4dGVuc2lvbiA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG5hdGl2ZURyYXdCdWZmZXJzRXh0ZW5zaW9uKSB7XHJcbiAgICAgICAgICAgICAgICBnbC5kcmF3QnVmZmVycyA9IGZ1bmN0aW9uIChhY3RpdmVUZXh0dXJlcykgeyByZXR1cm4gbmF0aXZlRHJhd0J1ZmZlcnNFeHRlbnNpb24uZHJhd0J1ZmZlcnNXRUJHTChhY3RpdmVUZXh0dXJlcyk7IH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmhhc01SVCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgZ2wuZHJhd0J1ZmZlcnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZW1wdHlcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFuYXRpdmVEZXB0aFRleHR1cmVFeHRlbnNpb24pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMud3JpdGVEZXB0aFRleHR1cmUgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICAgICAqIEJpbmQgYSBmcmFtZWJ1ZmZlclxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHBhcmFtIHtQSVhJLkZyYW1lYnVmZmVyfSBmcmFtZWJ1ZmZlclxyXG4gICAgICAgICAqIEBwYXJhbSB7UElYSS5SZWN0YW5nbGV9IFtmcmFtZV0gZnJhbWUsIGRlZmF1bHQgaXMgZnJhbWVidWZmZXIgc2l6ZVxyXG4gICAgICAgICAqL1xyXG4gICAgYmluZChmcmFtZWJ1ZmZlciA9IG51bGwsIGZyYW1lID0gbnVsbCkge1xyXG4gICAgICAgIHZhciByZWYgPSB0aGlzO1xyXG4gICAgICAgIHZhciBnbCA9IHJlZi5nbDtcclxuICAgICAgICBpZiAoZnJhbWVidWZmZXIpIHtcclxuICAgICAgICAgICAgLy8gVE9ETyBjYWNoaW5nIGxheWVyIVxyXG4gICAgICAgICAgICB2YXIgZmJvID0gZnJhbWVidWZmZXIuZ2xGcmFtZWJ1ZmZlcnNbdGhpcy5DT05URVhUX1VJRF0gfHwgdGhpcy5pbml0RnJhbWVidWZmZXIoZnJhbWVidWZmZXIpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50ICE9PSBmcmFtZWJ1ZmZlcikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50ID0gZnJhbWVidWZmZXI7XHJcbiAgICAgICAgICAgICAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIGZiby5mcmFtZWJ1ZmZlcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gbWFrZSBzdXJlIGFsbCB0ZXh0dXJlcyBhcmUgdW5ib3VuZC4uXHJcbiAgICAgICAgICAgIC8vIG5vdyBjaGVjayBmb3IgdXBkYXRlcy4uLlxyXG4gICAgICAgICAgICBpZiAoZmJvLmRpcnR5SWQgIT09IGZyYW1lYnVmZmVyLmRpcnR5SWQpIHtcclxuICAgICAgICAgICAgICAgIGZiby5kaXJ0eUlkID0gZnJhbWVidWZmZXIuZGlydHlJZDtcclxuICAgICAgICAgICAgICAgIGlmIChmYm8uZGlydHlGb3JtYXQgIT09IGZyYW1lYnVmZmVyLmRpcnR5Rm9ybWF0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmJvLmRpcnR5Rm9ybWF0ID0gZnJhbWVidWZmZXIuZGlydHlGb3JtYXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVGcmFtZWJ1ZmZlcihmcmFtZWJ1ZmZlcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChmYm8uZGlydHlTaXplICE9PSBmcmFtZWJ1ZmZlci5kaXJ0eVNpemUpIHtcclxuICAgICAgICAgICAgICAgICAgICBmYm8uZGlydHlTaXplID0gZnJhbWVidWZmZXIuZGlydHlTaXplO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVzaXplRnJhbWVidWZmZXIoZnJhbWVidWZmZXIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZnJhbWVidWZmZXIuY29sb3JUZXh0dXJlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGZyYW1lYnVmZmVyLmNvbG9yVGV4dHVyZXNbaV0udGV4dHVyZVBhcnQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnRleHR1cmUudW5iaW5kKGZyYW1lYnVmZmVyLmNvbG9yVGV4dHVyZXNbaV0udGV4dHVyZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnRleHR1cmUudW5iaW5kKGZyYW1lYnVmZmVyLmNvbG9yVGV4dHVyZXNbaV0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChmcmFtZWJ1ZmZlci5kZXB0aFRleHR1cmUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIudGV4dHVyZS51bmJpbmQoZnJhbWVidWZmZXIuZGVwdGhUZXh0dXJlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZnJhbWUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0Vmlld3BvcnQoZnJhbWUueCwgZnJhbWUueSwgZnJhbWUud2lkdGgsIGZyYW1lLmhlaWdodCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldFZpZXdwb3J0KDAsIDAsIGZyYW1lYnVmZmVyLndpZHRoLCBmcmFtZWJ1ZmZlci5oZWlnaHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBudWxsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZnJhbWUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0Vmlld3BvcnQoZnJhbWUueCwgZnJhbWUueSwgZnJhbWUud2lkdGgsIGZyYW1lLmhlaWdodCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldFZpZXdwb3J0KDAsIDAsIHRoaXMucmVuZGVyZXIud2lkdGgsIHRoaXMucmVuZGVyZXIuaGVpZ2h0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRoZSBXZWJHTFJlbmRlcmluZ0NvbnRleHQncyB2aWV3cG9ydC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geCAtIFggcG9zaXRpb24gb2Ygdmlld3BvcnRcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5IC0gWSBwb3NpdGlvbiBvZiB2aWV3cG9ydFxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoIC0gV2lkdGggb2Ygdmlld3BvcnRcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHQgLSBIZWlnaHQgb2Ygdmlld3BvcnRcclxuICAgICAqL1xyXG4gICAgc2V0Vmlld3BvcnQoeCwgeSwgd2lkdGgsIGhlaWdodCkge1xyXG4gICAgICAgIHZhciB2ID0gdGhpcy52aWV3cG9ydDtcclxuICAgICAgICBpZiAodi53aWR0aCAhPT0gd2lkdGggfHwgdi5oZWlnaHQgIT09IGhlaWdodCB8fCB2LnggIT09IHggfHwgdi55ICE9PSB5KSB7XHJcbiAgICAgICAgICAgIHYueCA9IHg7XHJcbiAgICAgICAgICAgIHYueSA9IHk7XHJcbiAgICAgICAgICAgIHYud2lkdGggPSB3aWR0aDtcclxuICAgICAgICAgICAgdi5oZWlnaHQgPSBoZWlnaHQ7XHJcbiAgICAgICAgICAgIHRoaXMuZ2wudmlld3BvcnQoeCwgeSwgd2lkdGgsIGhlaWdodCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIHNpemUgb2YgdGhlIGN1cnJlbnQgd2lkdGggYW5kIGhlaWdodC4gUmV0dXJucyBvYmplY3Qgd2l0aCBgd2lkdGhgIGFuZCBgaGVpZ2h0YCB2YWx1ZXMuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7b2JqZWN0fVxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKi9cclxuICAgIGdldCBzaXplKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnQpIHtcclxuICAgICAgICAgICAgLy8gVE9ETyBzdG9yZSB0ZW1wXHJcbiAgICAgICAgICAgIHJldHVybiB7IHg6IDAsIHk6IDAsIHdpZHRoOiB0aGlzLmN1cnJlbnQud2lkdGgsIGhlaWdodDogdGhpcy5jdXJyZW50LmhlaWdodCB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4geyB4OiAwLCB5OiAwLCB3aWR0aDogdGhpcy5yZW5kZXJlci53aWR0aCwgaGVpZ2h0OiB0aGlzLnJlbmRlcmVyLmhlaWdodCB9O1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDbGVhciB0aGUgY29sb3Igb2YgdGhlIGNvbnRleHRcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gciAtIFJlZCB2YWx1ZSBmcm9tIDAgdG8gMVxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGcgLSBHcmVlbiB2YWx1ZSBmcm9tIDAgdG8gMVxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGIgLSBCbHVlIHZhbHVlIGZyb20gMCB0byAxXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYSAtIEFscGhhIHZhbHVlIGZyb20gMCB0byAxXHJcbiAgICAgKi9cclxuICAgIGNsZWFyKHIgPSAwLCBnID0gMCwgYiA9IDAsIGEgPSAxKSB7XHJcbiAgICAgICAgdmFyIHJlZiA9IHRoaXM7XHJcbiAgICAgICAgdmFyIGdsID0gcmVmLmdsO1xyXG4gICAgICAgIC8vIFRPRE8gY2xlYXIgY29sb3IgY2FuIGJlIHNldCBvbmx5IG9uZSByaWdodD9cclxuICAgICAgICBnbC5jbGVhckNvbG9yKHIsIGcsIGIsIGEpO1xyXG4gICAgICAgIGdsLmNsZWFyKGdsLkNPTE9SX0JVRkZFUl9CSVQgfCBnbC5ERVBUSF9CVUZGRVJfQklUKTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gKiBJbml0aWFsaXplIGZyYW1lYnVmZmVyXHJcbiAqXHJcbiAqIEBwcm90ZWN0ZWRcclxuICogQHBhcmFtIHtQSVhJLkZyYW1lYnVmZmVyfSBmcmFtZWJ1ZmZlclxyXG4gKi9cclxuICAgIGluaXRGcmFtZWJ1ZmZlcihmcmFtZWJ1ZmZlcikge1xyXG4gICAgICAgIHZhciByZWYgPSB0aGlzO1xyXG4gICAgICAgIHZhciBnbCA9IHJlZi5nbDtcclxuICAgICAgICAvLyBUT0RPIC0gbWFrZSB0aGlzIGEgY2xhc3M/XHJcbiAgICAgICAgdmFyIGZibyA9IHtcclxuICAgICAgICAgICAgZnJhbWVidWZmZXI6IGdsLmNyZWF0ZUZyYW1lYnVmZmVyKCksXHJcbiAgICAgICAgICAgIHN0ZW5jaWw6IG51bGwsXHJcbiAgICAgICAgICAgIGRpcnR5SWQ6IDAsXHJcbiAgICAgICAgICAgIGRpcnR5Rm9ybWF0OiAwLFxyXG4gICAgICAgICAgICBkaXJ0eVNpemU6IDAsXHJcbiAgICAgICAgfTtcclxuICAgICAgICBmcmFtZWJ1ZmZlci5nbEZyYW1lYnVmZmVyc1t0aGlzLkNPTlRFWFRfVUlEXSA9IGZibztcclxuICAgICAgICB0aGlzLm1hbmFnZWRGcmFtZWJ1ZmZlcnMucHVzaChmcmFtZWJ1ZmZlcik7XHJcbiAgICAgICAgZnJhbWVidWZmZXIuZGlzcG9zZVJ1bm5lci5hZGQodGhpcyk7XHJcbiAgICAgICAgcmV0dXJuIGZibztcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogUmVzaXplIHRoZSBmcmFtZWJ1ZmZlclxyXG4gICAgICpcclxuICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAqIEBwYXJhbSB7UElYSS5GcmFtZWJ1ZmZlcn0gZnJhbWVidWZmZXJcclxuICAgICAqL1xyXG4gICAgcmVzaXplRnJhbWVidWZmZXIoZnJhbWVidWZmZXIpIHtcclxuICAgICAgICB2YXIgcmVmID0gdGhpcztcclxuICAgICAgICB2YXIgZ2wgPSByZWYuZ2w7XHJcbiAgICAgICAgdmFyIGZibyA9IGZyYW1lYnVmZmVyLmdsRnJhbWVidWZmZXJzW3RoaXMuQ09OVEVYVF9VSURdO1xyXG4gICAgICAgIGlmIChmYm8uc3RlbmNpbCkge1xyXG4gICAgICAgICAgICBnbC5iaW5kUmVuZGVyYnVmZmVyKGdsLlJFTkRFUkJVRkZFUiwgZmJvLnN0ZW5jaWwpO1xyXG4gICAgICAgICAgICBnbC5yZW5kZXJidWZmZXJTdG9yYWdlKGdsLlJFTkRFUkJVRkZFUiwgZ2wuREVQVEhfU1RFTkNJTCwgZnJhbWVidWZmZXIud2lkdGgsIGZyYW1lYnVmZmVyLmhlaWdodCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBjb2xvclRleHR1cmVzID0gZnJhbWVidWZmZXIuY29sb3JUZXh0dXJlcztcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbG9yVGV4dHVyZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci50ZXh0dXJlLmJpbmQoY29sb3JUZXh0dXJlc1tpXSwgMCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChmcmFtZWJ1ZmZlci5kZXB0aFRleHR1cmUpIHtcclxuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci50ZXh0dXJlLmJpbmQoZnJhbWVidWZmZXIuZGVwdGhUZXh0dXJlLCAwKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZSB0aGUgZnJhbWVidWZmZXJcclxuICAgICAqXHJcbiAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgKiBAcGFyYW0ge1BJWEkuRnJhbWVidWZmZXJ9IGZyYW1lYnVmZmVyXHJcbiAgICAgKi9cclxuICAgIHVwZGF0ZUZyYW1lYnVmZmVyKGZyYW1lYnVmZmVyKSB7XHJcbiAgICAgICAgdmFyIHJlZiA9IHRoaXM7XHJcbiAgICAgICAgdmFyIGdsID0gcmVmLmdsO1xyXG4gICAgICAgIHZhciBmYm8gPSBmcmFtZWJ1ZmZlci5nbEZyYW1lYnVmZmVyc1t0aGlzLkNPTlRFWFRfVUlEXTtcclxuICAgICAgICAvLyBiaW5kIHRoZSBjb2xvciB0ZXh0dXJlXHJcbiAgICAgICAgdmFyIGNvbG9yVGV4dHVyZXMgPSBmcmFtZWJ1ZmZlci5jb2xvclRleHR1cmVzO1xyXG4gICAgICAgIHZhciBjb3VudCA9IGNvbG9yVGV4dHVyZXMubGVuZ3RoO1xyXG4gICAgICAgIGlmICghZ2wuZHJhd0J1ZmZlcnMpIHtcclxuICAgICAgICAgICAgY291bnQgPSBNYXRoLm1pbihjb3VudCwgMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBhY3RpdmVUZXh0dXJlcyA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgdGV4dHVyZSA9IGZyYW1lYnVmZmVyLmNvbG9yVGV4dHVyZXNbaV07XHJcbiAgICAgICAgICAgIGlmICh0ZXh0dXJlLnRleHR1cmVQYXJ0KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnRleHR1cmUuYmluZCh0ZXh0dXJlLnRleHR1cmUsIDApO1xyXG4gICAgICAgICAgICAgICAgZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoZ2wuRlJBTUVCVUZGRVIsIGdsLkNPTE9SX0FUVEFDSE1FTlQwICsgaSwgZ2wuVEVYVFVSRV9DVUJFX01BUF9ORUdBVElWRV9YICsgdGV4dHVyZS5zaWRlLCB0ZXh0dXJlLnRleHR1cmUuX2dsVGV4dHVyZXNbdGhpcy5DT05URVhUX1VJRF0udGV4dHVyZSwgMCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnRleHR1cmUuYmluZCh0ZXh0dXJlLCAwKTtcclxuICAgICAgICAgICAgICAgIGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKGdsLkZSQU1FQlVGRkVSLCBnbC5DT0xPUl9BVFRBQ0hNRU5UMCArIGksIGdsLlRFWFRVUkVfMkQsIHRleHR1cmUuX2dsVGV4dHVyZXNbdGhpcy5DT05URVhUX1VJRF0udGV4dHVyZSwgMCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYWN0aXZlVGV4dHVyZXMucHVzaChnbC5DT0xPUl9BVFRBQ0hNRU5UMCArIGkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYWN0aXZlVGV4dHVyZXMubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICBnbC5kcmF3QnVmZmVycyhhY3RpdmVUZXh0dXJlcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChmcmFtZWJ1ZmZlci5kZXB0aFRleHR1cmUpIHtcclxuICAgICAgICAgICAgdmFyIHdyaXRlRGVwdGhUZXh0dXJlID0gdGhpcy53cml0ZURlcHRoVGV4dHVyZTtcclxuICAgICAgICAgICAgaWYgKHdyaXRlRGVwdGhUZXh0dXJlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZGVwdGhUZXh0dXJlID0gZnJhbWVidWZmZXIuZGVwdGhUZXh0dXJlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci50ZXh0dXJlLmJpbmQoZGVwdGhUZXh0dXJlLCAwKTtcclxuICAgICAgICAgICAgICAgIGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKGdsLkZSQU1FQlVGRkVSLCBnbC5ERVBUSF9BVFRBQ0hNRU5ULCBnbC5URVhUVVJFXzJELCBkZXB0aFRleHR1cmUuX2dsVGV4dHVyZXNbdGhpcy5DT05URVhUX1VJRF0udGV4dHVyZSwgMCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFmYm8uc3RlbmNpbCAmJiAoZnJhbWVidWZmZXIuc3RlbmNpbCB8fCBmcmFtZWJ1ZmZlci5kZXB0aCkpIHtcclxuICAgICAgICAgICAgZmJvLnN0ZW5jaWwgPSBnbC5jcmVhdGVSZW5kZXJidWZmZXIoKTtcclxuICAgICAgICAgICAgZ2wuYmluZFJlbmRlcmJ1ZmZlcihnbC5SRU5ERVJCVUZGRVIsIGZiby5zdGVuY2lsKTtcclxuICAgICAgICAgICAgLy8gVE9ETy4uIHRoaXMgaXMgZGVwdGggQU5EIHN0ZW5jaWw/XHJcbiAgICAgICAgICAgIGlmICghZnJhbWVidWZmZXIuZGVwdGhUZXh0dXJlKSB7IC8vIHlvdSBjYW4ndCBoYXZlIGJvdGgsIHNvIG9uZSBzaG91bGQgdGFrZSBwcmlvcml0eSBpZiBlbmFibGVkXHJcbiAgICAgICAgICAgICAgICBnbC5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgZ2wuREVQVEhfU1RFTkNJTF9BVFRBQ0hNRU5ULCBnbC5SRU5ERVJCVUZGRVIsIGZiby5zdGVuY2lsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBnbC5yZW5kZXJidWZmZXJTdG9yYWdlKGdsLlJFTkRFUkJVRkZFUiwgZ2wuREVQVEhfU1RFTkNJTCwgZnJhbWVidWZmZXIud2lkdGgsIGZyYW1lYnVmZmVyLmhlaWdodCk7XHJcbiAgICAgICAgICAgIC8vIGZiby5lbmFibGVTdGVuY2lsKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBEaXNwb3NlcyBmcmFtZWJ1ZmZlclxyXG4gICAgICogQHBhcmFtIHtQSVhJLkZyYW1lYnVmZmVyfSBmcmFtZWJ1ZmZlciBmcmFtZWJ1ZmZlciB0aGF0IGhhcyB0byBiZSBkaXNwb3NlZCBvZlxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbY29udGV4dExvc3Q9ZmFsc2VdIElmIGNvbnRleHQgd2FzIGxvc3QsIHdlIHN1cHByZXNzIGFsbCBkZWxldGUgZnVuY3Rpb24gY2FsbHNcclxuICAgICAqL1xyXG4gICAgZGlzcG9zZUZyYW1lYnVmZmVyKGZyYW1lYnVmZmVyLCBjb250ZXh0TG9zdCkge1xyXG4gICAgICAgIHZhciBmYm8gPSBmcmFtZWJ1ZmZlci5nbEZyYW1lYnVmZmVyc1t0aGlzLkNPTlRFWFRfVUlEXTtcclxuICAgICAgICB2YXIgZ2wgPSB0aGlzLmdsO1xyXG4gICAgICAgIGlmICghZmJvKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZGVsZXRlIGZyYW1lYnVmZmVyLmdsRnJhbWVidWZmZXJzW3RoaXMuQ09OVEVYVF9VSURdO1xyXG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMubWFuYWdlZEZyYW1lYnVmZmVycy5pbmRleE9mKGZyYW1lYnVmZmVyKTtcclxuICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xyXG4gICAgICAgICAgICB0aGlzLm1hbmFnZWRGcmFtZWJ1ZmZlcnMuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZnJhbWVidWZmZXIuZGlzcG9zZVJ1bm5lci5yZW1vdmUodGhpcyk7XHJcbiAgICAgICAgaWYgKCFjb250ZXh0TG9zdCkge1xyXG4gICAgICAgICAgICBnbC5kZWxldGVGcmFtZWJ1ZmZlcihmYm8uZnJhbWVidWZmZXIpO1xyXG4gICAgICAgICAgICBpZiAoZmJvLnN0ZW5jaWwpIHtcclxuICAgICAgICAgICAgICAgIGdsLmRlbGV0ZVJlbmRlcmJ1ZmZlcihmYm8uc3RlbmNpbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIERpc3Bvc2VzIGFsbCBmcmFtZWJ1ZmZlcnMsIGJ1dCBub3QgdGV4dHVyZXMgYm91bmQgdG8gdGhlbVxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbY29udGV4dExvc3Q9ZmFsc2VdIElmIGNvbnRleHQgd2FzIGxvc3QsIHdlIHN1cHByZXNzIGFsbCBkZWxldGUgZnVuY3Rpb24gY2FsbHNcclxuICAgICAqL1xyXG4gICAgZGlzcG9zZUFsbChjb250ZXh0TG9zdCkge1xyXG4gICAgICAgIHZhciBsaXN0ID0gdGhpcy5tYW5hZ2VkRnJhbWVidWZmZXJzO1xyXG4gICAgICAgIHRoaXMubWFuYWdlZEZyYW1lYnVmZmVycyA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5jb3VudDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGlzcG9zZUZyYW1lYnVmZmVyKGxpc3RbaV0sIGNvbnRleHRMb3N0KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIHJlc2V0cyBmcmFtZWJ1ZmZlciBzdG9yZWQgc3RhdGUsIGJpbmRzIHNjcmVlbiBmcmFtZWJ1ZmZlclxyXG4gICAgICpcclxuICAgICAqIHNob3VsZCBiZSBjYWxsZWQgYmVmb3JlIHJlbmRlclRleHR1cmUgcmVzZXQoKVxyXG4gICAgICovXHJcbiAgICByZXNldCgpIHtcclxuICAgICAgICB0aGlzLmN1cnJlbnQgPSB0aGlzLnVua25vd25GcmFtZWJ1ZmZlcjtcclxuICAgICAgICB0aGlzLnZpZXdwb3J0ID0gbmV3IFJlY3RhbmdsZV8xLlJlY3RhbmdsZSgpO1xyXG4gICAgfVxyXG4gICAgO1xyXG59XHJcbmV4cG9ydHMuRnJhbWVidWZmZXJTeXN0ZW0gPSBGcmFtZWJ1ZmZlclN5c3RlbTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY2xhc3MgR0xCdWZmZXIge1xyXG4gICAgY29uc3RydWN0b3IoYnVmZmVyKSB7XHJcbiAgICAgICAgdGhpcy5idWZmZXIgPSBidWZmZXI7XHJcbiAgICAgICAgdGhpcy51cGRhdGVJRCA9IC0xO1xyXG4gICAgICAgIHRoaXMuYnl0ZUxlbmd0aCA9IC0xO1xyXG4gICAgICAgIHRoaXMucmVmQ291bnQgPSAwO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuR0xCdWZmZXIgPSBHTEJ1ZmZlcjtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY2xhc3MgR0xQcm9ncmFtIHtcclxuICAgIGNvbnN0cnVjdG9yKHByb2dyYW0sIHVuaWZvcm1EYXRhKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBUaGUgc2hhZGVyIHByb2dyYW1cclxuICAgICAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAgICAgKiBAbWVtYmVyIHtXZWJHTFByb2dyYW19XHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnByb2dyYW0gPSBwcm9ncmFtO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIGhvbGRzIHRoZSB1bmlmb3JtIGRhdGEgd2hpY2ggY29udGFpbnMgdW5pZm9ybSBsb2NhdGlvbnNcclxuICAgICAgICAgKiBhbmQgY3VycmVudCB1bmlmb3JtIHZhbHVlcyB1c2VkIGZvciBjYWNoaW5nIGFuZCBwcmV2ZW50aW5nIHVubmVlZGVkIEdQVSBjb21tYW5kc1xyXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnVuaWZvcm1EYXRhID0gdW5pZm9ybURhdGE7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogdW5pZm9ybUdyb3VwcyBob2xkcyB0aGUgdmFyaW91cyB1cGxvYWQgZnVuY3Rpb25zIGZvciB0aGUgc2hhZGVyLiBFYWNoIHVuaWZvcm0gZ3JvdXBcclxuICAgICAgICAgKiBhbmQgcHJvZ3JhbSBoYXZlIGEgdW5pcXVlIHVwbG9hZCBmdW5jdGlvbiBnZW5lcmF0ZWQuXHJcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMudW5pZm9ybUdyb3VwcyA9IHt9O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBEZXN0cm95cyB0aGlzIHByb2dyYW1cclxuICAgICAqL1xyXG4gICAgZGVzdHJveSgpIHtcclxuICAgICAgICB0aGlzLnVuaWZvcm1EYXRhID0gbnVsbDtcclxuICAgICAgICB0aGlzLnVuaWZvcm1Hcm91cHMgPSBudWxsO1xyXG4gICAgICAgIHRoaXMucHJvZ3JhbSA9IG51bGw7XHJcbiAgICB9XHJcbiAgICA7XHJcbn1cclxuZXhwb3J0cy5HTFByb2dyYW0gPSBHTFByb2dyYW07XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNsYXNzIEdMVGV4dHVyZSB7XHJcbiAgICBjb25zdHJ1Y3Rvcih0ZXh0dXJlKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBUaGUgV2ViR0wgdGV4dHVyZVxyXG4gICAgICAgICAgICAgICAgICogQG1lbWJlciB7V2ViR0xUZXh0dXJlfVxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy50ZXh0dXJlID0gdGV4dHVyZTtcclxuICAgICAgICB0aGlzLndpZHRoID0gLTE7XHJcbiAgICAgICAgdGhpcy5oZWlnaHQgPSAtMTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUZXh0dXJlIGNvbnRlbnRzIGRpcnR5IGZsYWdcclxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5kaXJ0eUlkID0gLTE7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGV4dHVyZSBzdHlsZSBkaXJ0eSBmbGFnXHJcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuZGlydHlTdHlsZUlkID0gLTE7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogV2hldGhlciBtaXAgbGV2ZWxzIGhhcyB0byBiZSBnZW5lcmF0ZWRcclxuICAgICAgICAgKiBAbWVtYmVyIHtib29sZWFufVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMubWlwbWFwID0gZmFsc2U7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogV3JhcE1vZGUgY29waWVkIGZyb20gYmFzZVRleHR1cmVcclxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy53cmFwTW9kZSA9IDMzMDcxO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuR0xUZXh0dXJlID0gR0xUZXh0dXJlO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBBdHRyaWJ1dGVfMSA9IHJlcXVpcmUoXCIuL0F0dHJpYnV0ZVwiKTtcclxuY29uc3QgQnVmZmVyXzEgPSByZXF1aXJlKFwiLi9CdWZmZXJcIik7XHJcbmNvbnN0IFJ1bm5lcl8xID0gcmVxdWlyZShcIi4vUnVubmVyXCIpO1xyXG5jbGFzcyBHZW9tZXRyeSB7XHJcbiAgICBjb25zdHJ1Y3RvcihidWZmZXJzID0gW10sIGF0dHJpYnV0ZXMgPSB7fSkge1xyXG4gICAgICAgIHRoaXMuYnVmZmVycyA9IGJ1ZmZlcnM7XHJcbiAgICAgICAgdGhpcy5pbmRleEJ1ZmZlciA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5hdHRyaWJ1dGVzID0gYXR0cmlidXRlcztcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBIG1hcCBvZiByZW5kZXJlciBJRHMgdG8gd2ViZ2wgVkFPc1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHByb3RlY3RlZFxyXG4gICAgICAgICAqIEB0eXBlIHtvYmplY3R9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5nbFZlcnRleEFycmF5T2JqZWN0cyA9IHt9O1xyXG4gICAgICAgIHRoaXMuaWQgPSBHZW9tZXRyeS5VSUQkMSsrO1xyXG4gICAgICAgIHRoaXMuaW5zdGFuY2VkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5pbnN0YW5jZUNvdW50ID0gMTtcclxuICAgICAgICB0aGlzLl9zaXplID0gbnVsbDtcclxuICAgICAgICB0aGlzLmRpc3Bvc2VSdW5uZXIgPSBuZXcgUnVubmVyXzEuUnVubmVyKCdkaXNwb3NlR2VvbWV0cnknLCAyKTtcclxuICAgICAgICAvLyB0aGlzLmRpc3Bvc2VSdW5uZXIgPSBuZXcgUnVubmVyKCdkaXNwb3NlR2VvbWV0cnknLCAyKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb3VudCBvZiBleGlzdGluZyAobm90IGRlc3Ryb3llZCkgbWVzaGVzIHRoYXQgcmVmZXJlbmNlIHRoaXMgZ2VvbWV0cnlcclxuICAgICAgICAgKiBAbWVtYmVyIHtib29sZWFufVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMucmVmQ291bnQgPSAwO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAqXHJcbiAgICAqIEFkZHMgYW4gYXR0cmlidXRlIHRvIHRoZSBnZW9tZXRyeVxyXG4gICAgKlxyXG4gICAgKiBAcGFyYW0ge1N0cmluZ30gaWQgLSB0aGUgbmFtZSBvZiB0aGUgYXR0cmlidXRlIChtYXRjaGluZyB1cCB0byBhIHNoYWRlcilcclxuICAgICogQHBhcmFtIHtQSVhJLkJ1ZmZlcn0gW2J1ZmZlcl0gdGhlIGJ1ZmZlciB0aGF0IGhvbGRzIHRoZSBkYXRhIG9mIHRoZSBhdHRyaWJ1dGUgLiBZb3UgY2FuIGFsc28gcHJvdmlkZSBhbiBBcnJheSBhbmQgYSBidWZmZXIgd2lsbCBiZSBjcmVhdGVkIGZyb20gaXQuXHJcbiAgICAqIEBwYXJhbSB7TnVtYmVyfSBbc2l6ZT0wXSB0aGUgc2l6ZSBvZiB0aGUgYXR0cmlidXRlLiBJZiB5b3UgaGF2ZSAyIGZsb2F0cyBwZXIgdmVydGV4IChlZyBwb3NpdGlvbiB4IGFuZCB5KSB0aGlzIHdvdWxkIGJlIDJcclxuICAgICogQHBhcmFtIHtCb29sZWFufSBbbm9ybWFsaXplZD1mYWxzZV0gc2hvdWxkIHRoZSBkYXRhIGJlIG5vcm1hbGl6ZWQuXHJcbiAgICAqIEBwYXJhbSB7TnVtYmVyfSBbdHlwZT1QSVhJLlRZUEVTLkZMT0FUXSB3aGF0IHR5cGUgb2YgbnVtYmVyIGlzIHRoZSBhdHRyaWJ1dGUuIENoZWNrIHtQSVhJLlRZUEVTfSB0byBzZWUgdGhlIG9uZXMgYXZhaWxhYmxlXHJcbiAgICAqIEBwYXJhbSB7TnVtYmVyfSBbc3RyaWRlPTBdIEhvdyBmYXIgYXBhcnQgKGluIGZsb2F0cykgdGhlIHN0YXJ0IG9mIGVhY2ggdmFsdWUgaXMuICh1c2VkIGZvciBpbnRlcmxlYXZpbmcgZGF0YSlcclxuICAgICogQHBhcmFtIHtOdW1iZXJ9IFtzdGFydD0wXSBIb3cgZmFyIGludG8gdGhlIGFycmF5IHRvIHN0YXJ0IHJlYWRpbmcgdmFsdWVzICh1c2VkIGZvciBpbnRlcmxlYXZpbmcgZGF0YSlcclxuICAgICpcclxuICAgICogQHJldHVybiB7UElYSS5HZW9tZXRyeX0gcmV0dXJucyBzZWxmLCB1c2VmdWwgZm9yIGNoYWluaW5nLlxyXG4gICAgKi9cclxuICAgIGFkZEF0dHJpYnV0ZShpZCwgYnVmZmVyLCBzaXplID0gbnVsbCwgbm9ybWFsaXplZCA9IGZhbHNlLCB0eXBlID0gbnVsbCwgc3RyaWRlID0gdW5kZWZpbmVkLCBzdGFydCA9IHVuZGVmaW5lZCwgaW5zdGFuY2UgPSB1bmRlZmluZWQpIHtcclxuICAgICAgICBpZiAoIWJ1ZmZlcikge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBtdXN0IHBhc3MgYSBidWZmZXIgd2hlbiBjcmVhdGluZyBhbiBhdHRyaWJ1dGUnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gY2hlY2sgaWYgdGhpcyBpcyBhIGJ1ZmZlciFcclxuICAgICAgICBpZiAoIWJ1ZmZlci5kYXRhKSB7XHJcbiAgICAgICAgICAgIC8vIGl0cyBhbiBhcnJheSFcclxuICAgICAgICAgICAgaWYgKGJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5KSB7XHJcbiAgICAgICAgICAgICAgICBidWZmZXIgPSBuZXcgRmxvYXQzMkFycmF5KGJ1ZmZlcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYnVmZmVyID0gbmV3IEJ1ZmZlcl8xLkJ1ZmZlcihidWZmZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgaWRzID0gaWQuc3BsaXQoJ3wnKTtcclxuICAgICAgICBpZiAoaWRzLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpZHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYWRkQXR0cmlidXRlKGlkc1tpXSwgYnVmZmVyLCBzaXplLCBub3JtYWxpemVkLCB0eXBlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGJ1ZmZlckluZGV4ID0gdGhpcy5idWZmZXJzLmluZGV4T2YoYnVmZmVyKTtcclxuICAgICAgICBpZiAoYnVmZmVySW5kZXggPT09IC0xKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYnVmZmVycy5wdXNoKGJ1ZmZlcik7XHJcbiAgICAgICAgICAgIGJ1ZmZlckluZGV4ID0gdGhpcy5idWZmZXJzLmxlbmd0aCAtIDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuYXR0cmlidXRlc1tpZF0gPSBuZXcgQXR0cmlidXRlXzEuQXR0cmlidXRlKGJ1ZmZlckluZGV4LCBzaXplLCBub3JtYWxpemVkLCB0eXBlLCBzdHJpZGUsIHN0YXJ0LCBpbnN0YW5jZSk7XHJcbiAgICAgICAgLy8gYXNzdW1pbmcgdGhhdCBpZiB0aGVyZSBpcyBpbnN0YW5jZWQgZGF0YSB0aGVuIHRoaXMgd2lsbCBiZSBkcmF3biB3aXRoIGluc3RhbmNpbmchXHJcbiAgICAgICAgdGhpcy5pbnN0YW5jZWQgPSB0aGlzLmluc3RhbmNlZCB8fCBpbnN0YW5jZTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogcmV0dXJucyB0aGUgcmVxdWVzdGVkIGF0dHJpYnV0ZVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBpZCAgdGhlIG5hbWUgb2YgdGhlIGF0dHJpYnV0ZSByZXF1aXJlZFxyXG4gICAgICogQHJldHVybiB7UElYSS5BdHRyaWJ1dGV9IHRoZSBhdHRyaWJ1dGUgcmVxdWVzdGVkLlxyXG4gICAgICovXHJcbiAgICBnZXRBdHRyaWJ1dGUoaWQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5idWZmZXJzW3RoaXMuYXR0cmlidXRlc1tpZF0uYnVmZmVyXTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgKlxyXG4gICAgKiBBZGRzIGFuIGluZGV4IGJ1ZmZlciB0byB0aGUgZ2VvbWV0cnlcclxuICAgICogVGhlIGluZGV4IGJ1ZmZlciBjb250YWlucyBpbnRlZ2VycywgdGhyZWUgZm9yIGVhY2ggdHJpYW5nbGUgaW4gdGhlIGdlb21ldHJ5LCB3aGljaCByZWZlcmVuY2UgdGhlIHZhcmlvdXMgYXR0cmlidXRlIGJ1ZmZlcnMgKHBvc2l0aW9uLCBjb2xvdXIsIFVWIGNvb3JkaW5hdGVzLCBvdGhlciBVViBjb29yZGluYXRlcywgbm9ybWFsLCDigKYpLiBUaGVyZSBpcyBvbmx5IE9ORSBpbmRleCBidWZmZXIuXHJcbiAgICAqXHJcbiAgICAqIEBwYXJhbSB7UElYSS5CdWZmZXJ9IFtidWZmZXJdIHRoZSBidWZmZXIgdGhhdCBob2xkcyB0aGUgZGF0YSBvZiB0aGUgaW5kZXggYnVmZmVyLiBZb3UgY2FuIGFsc28gcHJvdmlkZSBhbiBBcnJheSBhbmQgYSBidWZmZXIgd2lsbCBiZSBjcmVhdGVkIGZyb20gaXQuXHJcbiAgICAqIEByZXR1cm4ge1BJWEkuR2VvbWV0cnl9IHJldHVybnMgc2VsZiwgdXNlZnVsIGZvciBjaGFpbmluZy5cclxuICAgICovXHJcbiAgICBhZGRJbmRleChidWZmZXIpIHtcclxuICAgICAgICBpZiAoIWJ1ZmZlci5kYXRhKSB7XHJcbiAgICAgICAgICAgIC8vIGl0cyBhbiBhcnJheSFcclxuICAgICAgICAgICAgaWYgKGJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5KSB7XHJcbiAgICAgICAgICAgICAgICBidWZmZXIgPSBuZXcgVWludDE2QXJyYXkoYnVmZmVyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBidWZmZXIgPSBuZXcgQnVmZmVyXzEuQnVmZmVyKGJ1ZmZlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJ1ZmZlci5pbmRleCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5pbmRleEJ1ZmZlciA9IGJ1ZmZlcjtcclxuICAgICAgICBpZiAodGhpcy5idWZmZXJzLmluZGV4T2YoYnVmZmVyKSA9PT0gLTEpIHtcclxuICAgICAgICAgICAgdGhpcy5idWZmZXJzLnB1c2goYnVmZmVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIHJldHVybnMgdGhlIGluZGV4IGJ1ZmZlclxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4ge1BJWEkuQnVmZmVyfSB0aGUgaW5kZXggYnVmZmVyLlxyXG4gICAgICovXHJcbiAgICBnZXRJbmRleCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5pbmRleEJ1ZmZlcjtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogdGhpcyBmdW5jdGlvbiBtb2RpZmllcyB0aGUgc3RydWN0dXJlIHNvIHRoYXQgYWxsIGN1cnJlbnQgYXR0cmlidXRlcyBiZWNvbWUgaW50ZXJsZWF2ZWQgaW50byBhIHNpbmdsZSBidWZmZXJcclxuICAgICAqIFRoaXMgY2FuIGJlIHVzZWZ1bCBpZiB5b3VyIG1vZGVsIHJlbWFpbnMgc3RhdGljIGFzIGl0IG9mZmVycyBhIGxpdHRsZSBwZXJmb3JtYW5jZSBib29zdFxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4ge1BJWEkuR2VvbWV0cnl9IHJldHVybnMgc2VsZiwgdXNlZnVsIGZvciBjaGFpbmluZy5cclxuICAgICAqL1xyXG4gICAgaW50ZXJsZWF2ZSgpIHtcclxuICAgICAgICAvLyBhIHNpbXBsZSBjaGVjayB0byBzZWUgaWYgYnVmZmVycyBhcmUgYWxyZWFkeSBpbnRlcmxlYXZlZC4uXHJcbiAgICAgICAgaWYgKHRoaXMuYnVmZmVycy5sZW5ndGggPT09IDEgfHwgKHRoaXMuYnVmZmVycy5sZW5ndGggPT09IDIgJiYgdGhpcy5pbmRleEJ1ZmZlcikpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGFzc3VtZSBhbHJlYWR5IHRoYXQgbm8gYnVmZmVycyBhcmUgaW50ZXJsZWF2ZWRcclxuICAgICAgICB2YXIgYXJyYXlzID0gW107XHJcbiAgICAgICAgdmFyIHNpemVzID0gW107XHJcbiAgICAgICAgdmFyIGludGVybGVhdmVkQnVmZmVyID0gbmV3IEJ1ZmZlcl8xLkJ1ZmZlcigpO1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIGZvciAoaSBpbiB0aGlzLmF0dHJpYnV0ZXMpIHtcclxuICAgICAgICAgICAgdmFyIGF0dHJpYnV0ZSA9IHRoaXMuYXR0cmlidXRlc1tpXTtcclxuICAgICAgICAgICAgdmFyIGJ1ZmZlciA9IHRoaXMuYnVmZmVyc1thdHRyaWJ1dGUuYnVmZmVyXTtcclxuICAgICAgICAgICAgYXJyYXlzLnB1c2goYnVmZmVyLmRhdGEpO1xyXG4gICAgICAgICAgICBzaXplcy5wdXNoKChhdHRyaWJ1dGUuc2l6ZSAqIEdlb21ldHJ5LmJ5dGVTaXplTWFwW2F0dHJpYnV0ZS50eXBlXSkgLyA0KTtcclxuICAgICAgICAgICAgYXR0cmlidXRlLmJ1ZmZlciA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGludGVybGVhdmVkQnVmZmVyLmRhdGEgPSBHZW9tZXRyeS5pbnRlcmxlYXZlVHlwZWRBcnJheXMoYXJyYXlzLCBzaXplcyk7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMuYnVmZmVycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5idWZmZXJzW2ldICE9PSB0aGlzLmluZGV4QnVmZmVyKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlcnNbaV0uZGVzdHJveSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuYnVmZmVycyA9IFtpbnRlcmxlYXZlZEJ1ZmZlcl07XHJcbiAgICAgICAgaWYgKHRoaXMuaW5kZXhCdWZmZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5idWZmZXJzLnB1c2godGhpcy5pbmRleEJ1ZmZlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgZ2V0U2l6ZSgpIHtcclxuICAgICAgICBmb3IgKHZhciBpIGluIHRoaXMuYXR0cmlidXRlcykge1xyXG4gICAgICAgICAgICB2YXIgYXR0cmlidXRlID0gdGhpcy5hdHRyaWJ1dGVzW2ldO1xyXG4gICAgICAgICAgICB2YXIgYnVmZmVyID0gdGhpcy5idWZmZXJzW2F0dHJpYnV0ZS5idWZmZXJdO1xyXG4gICAgICAgICAgICByZXR1cm4gYnVmZmVyLmRhdGEubGVuZ3RoIC8gKChhdHRyaWJ1dGUuc3RyaWRlIC8gNCkgfHwgYXR0cmlidXRlLnNpemUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gMDtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogZGlzcG9zZXMgV2ViR0wgcmVzb3VyY2VzIHRoYXQgYXJlIGNvbm5lY3RlZCB0byB0aGlzIGdlb21ldHJ5XHJcbiAgICAgKi9cclxuICAgIGRpc3Bvc2UoKSB7XHJcbiAgICAgICAgLy8gdGhpcy5kaXNwb3NlUnVubmVyLnJ1bih0aGlzLCBmYWxzZSk7XHJcbiAgICAgICAgdGhpcy5kaXNwb3NlUnVubmVyLnJ1bih0aGlzLCBmYWxzZSk7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIERlc3Ryb3lzIHRoZSBnZW9tZXRyeS5cclxuICAgICAqL1xyXG4gICAgZGVzdHJveShvcHRpb25zID0gbnVsbCkge1xyXG4gICAgICAgIHRoaXMuZGlzcG9zZSgpO1xyXG4gICAgICAgIHRoaXMuYnVmZmVycyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5pbmRleEJ1ZmZlci5kZXN0cm95KCk7XHJcbiAgICAgICAgdGhpcy5hdHRyaWJ1dGVzID0gbnVsbDtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogcmV0dXJucyBhIGNsb25lIG9mIHRoZSBnZW9tZXRyeVxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHtQSVhJLkdlb21ldHJ5fSBhIG5ldyBjbG9uZSBvZiB0aGlzIGdlb21ldHJ5XHJcbiAgICAgKi9cclxuICAgIGNsb25lKCkge1xyXG4gICAgICAgIHZhciBnZW9tZXRyeSA9IG5ldyBHZW9tZXRyeSgpO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5idWZmZXJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGdlb21ldHJ5LmJ1ZmZlcnNbaV0gPSBuZXcgQnVmZmVyXzEuQnVmZmVyKHRoaXMuYnVmZmVyc1tpXS5kYXRhLnNsaWNlKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKHZhciBpJDEgaW4gdGhpcy5hdHRyaWJ1dGVzKSB7XHJcbiAgICAgICAgICAgIHZhciBhdHRyaWIgPSB0aGlzLmF0dHJpYnV0ZXNbaSQxXTtcclxuICAgICAgICAgICAgZ2VvbWV0cnkuYXR0cmlidXRlc1tpJDFdID0gbmV3IEF0dHJpYnV0ZV8xLkF0dHJpYnV0ZShhdHRyaWIuYnVmZmVyLCBhdHRyaWIuc2l6ZSwgYXR0cmliLm5vcm1hbGl6ZWQsIGF0dHJpYi50eXBlLCBhdHRyaWIuc3RyaWRlLCBhdHRyaWIuc3RhcnQsIGF0dHJpYi5pbnN0YW5jZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmluZGV4QnVmZmVyKSB7XHJcbiAgICAgICAgICAgIGdlb21ldHJ5LmluZGV4QnVmZmVyID0gZ2VvbWV0cnkuYnVmZmVyc1t0aGlzLmJ1ZmZlcnMuaW5kZXhPZih0aGlzLmluZGV4QnVmZmVyKV07XHJcbiAgICAgICAgICAgIGdlb21ldHJ5LmluZGV4QnVmZmVyLmluZGV4ID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGdlb21ldHJ5O1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBtZXJnZXMgYW4gYXJyYXkgb2YgZ2VvbWV0cmllcyBpbnRvIGEgbmV3IHNpbmdsZSBvbmVcclxuICAgICAqIGdlb21ldHJ5IGF0dHJpYnV0ZSBzdHlsZXMgbXVzdCBtYXRjaCBmb3IgdGhpcyBvcGVyYXRpb24gdG8gd29ya1xyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7UElYSS5HZW9tZXRyeVtdfSBnZW9tZXRyaWVzIGFycmF5IG9mIGdlb21ldHJpZXMgdG8gbWVyZ2VcclxuICAgICAqIEByZXR1cm5zIHtQSVhJLkdlb21ldHJ5fSBzaGlueSBuZXcgZ2VvbWV0cnkhXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBtZXJnZShnZW9tZXRyaWVzKSB7XHJcbiAgICAgICAgLy8gdG9kbyBhZGQgYSBnZW9tZXRyeSBjaGVjayFcclxuICAgICAgICAvLyBhbHNvIGEgc2l6ZSBjaGVjay4uIGNhbnQgYmUgdG9vIGJpZyFdXHJcbiAgICAgICAgdmFyIGdlb21ldHJ5T3V0ID0gbmV3IEdlb21ldHJ5KCk7XHJcbiAgICAgICAgdmFyIGFycmF5cyA9IFtdO1xyXG4gICAgICAgIHZhciBzaXplcyA9IFtdO1xyXG4gICAgICAgIHZhciBvZmZzZXRzID0gW107XHJcbiAgICAgICAgdmFyIGdlb21ldHJ5O1xyXG4gICAgICAgIC8vIHBhc3Mgb25lLi4gZ2V0IHNpemVzLi5cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdlb21ldHJpZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgZ2VvbWV0cnkgPSBnZW9tZXRyaWVzW2ldO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGdlb21ldHJ5LmJ1ZmZlcnMubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgIHNpemVzW2pdID0gc2l6ZXNbal0gfHwgMDtcclxuICAgICAgICAgICAgICAgIHNpemVzW2pdICs9IGdlb21ldHJ5LmJ1ZmZlcnNbal0uZGF0YS5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBvZmZzZXRzW2pdID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBidWlsZCB0aGUgY29ycmVjdCBzaXplIGFycmF5cy4uXHJcbiAgICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgZ2VvbWV0cnkuYnVmZmVycy5sZW5ndGg7IGkkMSsrKSB7XHJcbiAgICAgICAgICAgIC8vIFRPRE8gdHlwZXMhXHJcbiAgICAgICAgICAgIGFycmF5c1tpJDFdID0gbmV3IEdlb21ldHJ5Lm1hcCQxW0dlb21ldHJ5LmdldEJ1ZmZlclR5cGUoZ2VvbWV0cnkuYnVmZmVyc1tpJDFdLmRhdGEpXShzaXplc1tpJDFdKTtcclxuICAgICAgICAgICAgZ2VvbWV0cnlPdXQuYnVmZmVyc1tpJDFdID0gbmV3IEJ1ZmZlcl8xLkJ1ZmZlcihhcnJheXNbaSQxXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHBhc3MgdG8gc2V0IGRhdGEuLlxyXG4gICAgICAgIGZvciAodmFyIGkkMiA9IDA7IGkkMiA8IGdlb21ldHJpZXMubGVuZ3RoOyBpJDIrKykge1xyXG4gICAgICAgICAgICBnZW9tZXRyeSA9IGdlb21ldHJpZXNbaSQyXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaiQxID0gMDsgaiQxIDwgZ2VvbWV0cnkuYnVmZmVycy5sZW5ndGg7IGokMSsrKSB7XHJcbiAgICAgICAgICAgICAgICBhcnJheXNbaiQxXS5zZXQoZ2VvbWV0cnkuYnVmZmVyc1tqJDFdLmRhdGEsIG9mZnNldHNbaiQxXSk7XHJcbiAgICAgICAgICAgICAgICBvZmZzZXRzW2okMV0gKz0gZ2VvbWV0cnkuYnVmZmVyc1tqJDFdLmRhdGEubGVuZ3RoO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGdlb21ldHJ5T3V0LmF0dHJpYnV0ZXMgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzO1xyXG4gICAgICAgIGlmIChnZW9tZXRyeS5pbmRleEJ1ZmZlcikge1xyXG4gICAgICAgICAgICBnZW9tZXRyeU91dC5pbmRleEJ1ZmZlciA9IGdlb21ldHJ5T3V0LmJ1ZmZlcnNbZ2VvbWV0cnkuYnVmZmVycy5pbmRleE9mKGdlb21ldHJ5LmluZGV4QnVmZmVyKV07XHJcbiAgICAgICAgICAgIGdlb21ldHJ5T3V0LmluZGV4QnVmZmVyLmluZGV4ID0gdHJ1ZTtcclxuICAgICAgICAgICAgdmFyIG9mZnNldCA9IDA7XHJcbiAgICAgICAgICAgIHZhciBzdHJpZGUgPSAwO1xyXG4gICAgICAgICAgICB2YXIgb2Zmc2V0MiA9IDA7XHJcbiAgICAgICAgICAgIHZhciBidWZmZXJJbmRleFRvQ291bnQgPSAwO1xyXG4gICAgICAgICAgICAvLyBnZXQgYSBidWZmZXJcclxuICAgICAgICAgICAgZm9yICh2YXIgaSQzID0gMDsgaSQzIDwgZ2VvbWV0cnkuYnVmZmVycy5sZW5ndGg7IGkkMysrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZ2VvbWV0cnkuYnVmZmVyc1tpJDNdICE9PSBnZW9tZXRyeS5pbmRleEJ1ZmZlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlckluZGV4VG9Db3VudCA9IGkkMztcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBmaWd1cmUgb3V0IHRoZSBzdHJpZGUgb2Ygb25lIGJ1ZmZlci4uXHJcbiAgICAgICAgICAgIGZvciAodmFyIGkkNCBpbiBnZW9tZXRyeS5hdHRyaWJ1dGVzKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYXR0cmlidXRlID0gZ2VvbWV0cnkuYXR0cmlidXRlc1tpJDRdO1xyXG4gICAgICAgICAgICAgICAgaWYgKChhdHRyaWJ1dGUuYnVmZmVyIHwgMCkgPT09IGJ1ZmZlckluZGV4VG9Db3VudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0cmlkZSArPSAoKGF0dHJpYnV0ZS5zaXplICogR2VvbWV0cnkuYnl0ZVNpemVNYXBbYXR0cmlidXRlLnR5cGVdKSAvIDQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHRpbWUgdG8gb2ZmIHNldCBhbGwgaW5kZXhlcy4uXHJcbiAgICAgICAgICAgIGZvciAodmFyIGkkNSA9IDA7IGkkNSA8IGdlb21ldHJpZXMubGVuZ3RoOyBpJDUrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGluZGV4QnVmZmVyRGF0YSA9IGdlb21ldHJpZXNbaSQ1XS5pbmRleEJ1ZmZlci5kYXRhO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiQyID0gMDsgaiQyIDwgaW5kZXhCdWZmZXJEYXRhLmxlbmd0aDsgaiQyKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBnZW9tZXRyeU91dC5pbmRleEJ1ZmZlci5kYXRhW2okMiArIG9mZnNldDJdICs9IG9mZnNldDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIG9mZnNldCArPSBnZW9tZXRyeS5idWZmZXJzW2J1ZmZlckluZGV4VG9Db3VudF0uZGF0YS5sZW5ndGggLyAoc3RyaWRlKTtcclxuICAgICAgICAgICAgICAgIG9mZnNldDIgKz0gaW5kZXhCdWZmZXJEYXRhLmxlbmd0aDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZ2VvbWV0cnlPdXQ7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICBzdGF0aWMgZ2V0QnVmZmVyVHlwZShhcnJheSkge1xyXG4gICAgICAgIGlmIChhcnJheS5CWVRFU19QRVJfRUxFTUVOVCA9PT0gNCkge1xyXG4gICAgICAgICAgICBpZiAoYXJyYXkgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAnRmxvYXQzMkFycmF5JztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChhcnJheSBpbnN0YW5jZW9mIFVpbnQzMkFycmF5KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJ1VpbnQzMkFycmF5JztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gJ0ludDMyQXJyYXknO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChhcnJheS5CWVRFU19QRVJfRUxFTUVOVCA9PT0gMikge1xyXG4gICAgICAgICAgICBpZiAoYXJyYXkgaW5zdGFuY2VvZiBVaW50MTZBcnJheSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICdVaW50MTZBcnJheSc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoYXJyYXkuQllURVNfUEVSX0VMRU1FTlQgPT09IDEpIHtcclxuICAgICAgICAgICAgaWYgKGFycmF5IGluc3RhbmNlb2YgVWludDhBcnJheSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICdVaW50OEFycmF5JztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBUT0RPIG1hcCBvdXQgdGhlIHJlc3Qgb2YgdGhlIGFycmF5IGVsZW1lbnRzIVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGludGVybGVhdmVUeXBlZEFycmF5cyhhcnJheXMsIHNpemVzKSB7XHJcbiAgICAgICAgdmFyIG91dFNpemUgPSAwO1xyXG4gICAgICAgIHZhciBzdHJpZGUgPSAwO1xyXG4gICAgICAgIHZhciB2aWV3cyA9IHt9O1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXlzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHN0cmlkZSArPSBzaXplc1tpXTtcclxuICAgICAgICAgICAgb3V0U2l6ZSArPSBhcnJheXNbaV0ubGVuZ3RoO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKG91dFNpemUgKiA0KTtcclxuICAgICAgICB2YXIgb3V0ID0gbnVsbDtcclxuICAgICAgICB2YXIgbGl0dGxlT2Zmc2V0ID0gMDtcclxuICAgICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBhcnJheXMubGVuZ3RoOyBpJDErKykge1xyXG4gICAgICAgICAgICB2YXIgc2l6ZSA9IHNpemVzW2kkMV07XHJcbiAgICAgICAgICAgIHZhciBhcnJheSA9IGFycmF5c1tpJDFdO1xyXG4gICAgICAgICAgICB2YXIgdHlwZSA9IEdlb21ldHJ5LmdldEJ1ZmZlclR5cGUoYXJyYXkpO1xyXG4gICAgICAgICAgICBpZiAoIXZpZXdzW3R5cGVdKSB7XHJcbiAgICAgICAgICAgICAgICB2aWV3c1t0eXBlXSA9IG5ldyBHZW9tZXRyeS5tYXBbdHlwZV0oYnVmZmVyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvdXQgPSB2aWV3c1t0eXBlXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBhcnJheS5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGluZGV4U3RhcnQgPSAoKGogLyBzaXplIHwgMCkgKiBzdHJpZGUpICsgbGl0dGxlT2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gaiAlIHNpemU7XHJcbiAgICAgICAgICAgICAgICBvdXRbaW5kZXhTdGFydCArIGluZGV4XSA9IGFycmF5W2pdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxpdHRsZU9mZnNldCArPSBzaXplO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IEZsb2F0MzJBcnJheShidWZmZXIpO1xyXG4gICAgfVxyXG59XHJcbi8qIGVzbGludC1kaXNhYmxlIG9iamVjdC1zaG9ydGhhbmQgKi9cclxuR2VvbWV0cnkubWFwID0ge1xyXG4gICAgRmxvYXQzMkFycmF5OiBGbG9hdDMyQXJyYXksXHJcbiAgICBVaW50MzJBcnJheTogVWludDMyQXJyYXksXHJcbiAgICBJbnQzMkFycmF5OiBJbnQzMkFycmF5LFxyXG4gICAgVWludDhBcnJheTogVWludDhBcnJheSxcclxufTtcclxuR2VvbWV0cnkuVUlEJDEgPSAwO1xyXG4vKiBlc2xpbnQtZGlzYWJsZSBvYmplY3Qtc2hvcnRoYW5kICovXHJcbkdlb21ldHJ5Lm1hcCQxID0ge1xyXG4gICAgRmxvYXQzMkFycmF5OiBGbG9hdDMyQXJyYXksXHJcbiAgICBVaW50MzJBcnJheTogVWludDMyQXJyYXksXHJcbiAgICBJbnQzMkFycmF5OiBJbnQzMkFycmF5LFxyXG4gICAgVWludDhBcnJheTogVWludDhBcnJheSxcclxuICAgIFVpbnQxNkFycmF5OiBVaW50MTZBcnJheSxcclxufTtcclxuR2VvbWV0cnkuYnl0ZVNpemVNYXAgPSB7IDUxMjY6IDQsIDUxMjM6IDIsIDUxMjE6IDEgfTtcclxuZXhwb3J0cy5HZW9tZXRyeSA9IEdlb21ldHJ5O1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBTeXN0ZW1fMSA9IHJlcXVpcmUoXCIuL1N5c3RlbVwiKTtcclxuY29uc3QgR0xCdWZmZXJfMSA9IHJlcXVpcmUoXCIuL0dMQnVmZmVyXCIpO1xyXG5jb25zdCBEaXNwbGF5U2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL0Rpc3BsYXlTZXR0aW5nc1wiKTtcclxuY2xhc3MgR2VvbWV0cnlTeXN0ZW0gZXh0ZW5kcyBTeXN0ZW1fMS5TeXN0ZW0ge1xyXG4gICAgY29uc3RydWN0b3IocmVuZGVyZXIpIHtcclxuICAgICAgICBzdXBlcihyZW5kZXJlcik7XHJcbiAgICAgICAgdGhpcy5fYWN0aXZlR2VvbWV0cnkgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuX2FjdGl2ZVZhbyA9IG51bGw7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogYHRydWVgIGlmIHdlIGhhcyBgKl92ZXJ0ZXhfYXJyYXlfb2JqZWN0YCBleHRlbnNpb25cclxuICAgICAgICAgKiBAbWVtYmVyIHtib29sZWFufVxyXG4gICAgICAgICAqIEByZWFkb25seVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuaGFzVmFvID0gdHJ1ZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBgdHJ1ZWAgaWYgaGFzIGBBTkdMRV9pbnN0YW5jZWRfYXJyYXlzYCBleHRlbnNpb25cclxuICAgICAgICAgKiBAbWVtYmVyIHtib29sZWFufVxyXG4gICAgICAgICAqIEByZWFkb25seVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuaGFzSW5zdGFuY2UgPSB0cnVlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEEgY2FjaGUgb2YgY3VycmVudGx5IGJvdW5kIGJ1ZmZlcixcclxuICAgICAgICAgKiBjb250YWlucyBvbmx5IHR3byBtZW1iZXJzIHdpdGgga2V5cyBBUlJBWV9CVUZGRVIgYW5kIEVMRU1FTlRfQVJSQVlfQlVGRkVSXHJcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0LjxudW1iZXIsIFBJWEkuQnVmZmVyPn1cclxuICAgICAgICAgKiBAcmVhZG9ubHlcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmJvdW5kQnVmZmVycyA9IHt9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENhY2hlIGZvciBhbGwgZ2VvbWV0cmllcyBieSBpZCwgdXNlZCBpbiBjYXNlIHJlbmRlcmVyIGdldHMgZGVzdHJveWVkIG9yIGZvciBwcm9maWxpbmdcclxuICAgICAgICAgKiBAbWVtYmVyIHtvYmplY3R9XHJcbiAgICAgICAgICogQHJlYWRvbmx5XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5tYW5hZ2VkR2VvbWV0cmllcyA9IHt9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENhY2hlIGZvciBhbGwgYnVmZmVycyBieSBpZCwgdXNlZCBpbiBjYXNlIHJlbmRlcmVyIGdldHMgZGVzdHJveWVkIG9yIGZvciBwcm9maWxpbmdcclxuICAgICAgICAgKiBAbWVtYmVyIHtvYmplY3R9XHJcbiAgICAgICAgICogQHJlYWRvbmx5XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5tYW5hZ2VkQnVmZmVycyA9IHt9O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHVwIHRoZSByZW5kZXJlciBjb250ZXh0IGFuZCBuZWNlc3NhcnkgYnVmZmVycy5cclxuICAgICAqL1xyXG4gICAgY29udGV4dENoYW5nZSgpIHtcclxuICAgICAgICB0aGlzLmRpc3Bvc2VBbGwodHJ1ZSk7XHJcbiAgICAgICAgdmFyIGdsID0gdGhpcy5nbCA9IHRoaXMucmVuZGVyZXIuZ2w7XHJcbiAgICAgICAgdGhpcy5DT05URVhUX1VJRCA9IHRoaXMucmVuZGVyZXIuQ09OVEVYVF9VSUQ7XHJcbiAgICAgICAgLy8gd2ViZ2wyXHJcbiAgICAgICAgaWYgKCFnbC5jcmVhdGVWZXJ0ZXhBcnJheSkge1xyXG4gICAgICAgICAgICAvLyB3ZWJnbCAxIVxyXG4gICAgICAgICAgICB2YXIgbmF0aXZlVmFvRXh0ZW5zaW9uID0gdGhpcy5yZW5kZXJlci5jb250ZXh0LmV4dGVuc2lvbnMudmVydGV4QXJyYXlPYmplY3Q7XHJcbiAgICAgICAgICAgIGlmIChEaXNwbGF5U2V0dGluZ3NfMS5EaXNwbGF5U2V0dGluZ3MuUFJFRkVSX0VOViA9PT0gRGlzcGxheVNldHRpbmdzXzEuRGlzcGxheVNldHRpbmdzLkVOVi5XRUJHTF9MRUdBQ1kpIHtcclxuICAgICAgICAgICAgICAgIG5hdGl2ZVZhb0V4dGVuc2lvbiA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG5hdGl2ZVZhb0V4dGVuc2lvbikge1xyXG4gICAgICAgICAgICAgICAgZ2wuY3JlYXRlVmVydGV4QXJyYXkgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBuYXRpdmVWYW9FeHRlbnNpb24uY3JlYXRlVmVydGV4QXJyYXlPRVMoKTsgfTtcclxuICAgICAgICAgICAgICAgIGdsLmJpbmRWZXJ0ZXhBcnJheSA9IGZ1bmN0aW9uICh2YW8pIHsgcmV0dXJuIG5hdGl2ZVZhb0V4dGVuc2lvbi5iaW5kVmVydGV4QXJyYXlPRVModmFvKTsgfTtcclxuICAgICAgICAgICAgICAgIGdsLmRlbGV0ZVZlcnRleEFycmF5ID0gZnVuY3Rpb24gKHZhbykgeyByZXR1cm4gbmF0aXZlVmFvRXh0ZW5zaW9uLmRlbGV0ZVZlcnRleEFycmF5T0VTKHZhbyk7IH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmhhc1ZhbyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgZ2wuY3JlYXRlVmVydGV4QXJyYXkgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZW1wdHlcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBnbC5iaW5kVmVydGV4QXJyYXkgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZW1wdHlcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBnbC5kZWxldGVWZXJ0ZXhBcnJheSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBlbXB0eVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWdsLnZlcnRleEF0dHJpYkRpdmlzb3IpIHtcclxuICAgICAgICAgICAgdmFyIGluc3RhbmNlRXh0ID0gZ2wuZ2V0RXh0ZW5zaW9uKCdBTkdMRV9pbnN0YW5jZWRfYXJyYXlzJyk7XHJcbiAgICAgICAgICAgIGlmIChpbnN0YW5jZUV4dCkge1xyXG4gICAgICAgICAgICAgICAgZ2wudmVydGV4QXR0cmliRGl2aXNvciA9IGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBpbnN0YW5jZUV4dC52ZXJ0ZXhBdHRyaWJEaXZpc29yQU5HTEUoYSwgYik7IH07XHJcbiAgICAgICAgICAgICAgICBnbC5kcmF3RWxlbWVudHNJbnN0YW5jZWQgPSBmdW5jdGlvbiAoYSwgYiwgYywgZCwgZSkgeyByZXR1cm4gaW5zdGFuY2VFeHQuZHJhd0VsZW1lbnRzSW5zdGFuY2VkQU5HTEUoYSwgYiwgYywgZCwgZSk7IH07XHJcbiAgICAgICAgICAgICAgICBnbC5kcmF3QXJyYXlzSW5zdGFuY2VkID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHsgcmV0dXJuIGluc3RhbmNlRXh0LmRyYXdBcnJheXNJbnN0YW5jZWRBTkdMRShhLCBiLCBjLCBkKTsgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaGFzSW5zdGFuY2UgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQmluZHMgZ2VvbWV0cnkgc28gdGhhdCBpcyBjYW4gYmUgZHJhd24uIENyZWF0aW5nIGEgVmFvIGlmIHJlcXVpcmVkXHJcbiAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgKiBAcGFyYW0ge1BJWEkuR2VvbWV0cnl9IGdlb21ldHJ5IGluc3RhbmNlIG9mIGdlb21ldHJ5IHRvIGJpbmRcclxuICAgICAqIEBwYXJhbSB7UElYSS5TaGFkZXJ9IHNoYWRlciBpbnN0YW5jZSBvZiBzaGFkZXIgdG8gYmluZFxyXG4gICAgICovXHJcbiAgICBiaW5kKGdlb21ldHJ5LCBzaGFkZXIgPSBudWxsKSB7XHJcbiAgICAgICAgc2hhZGVyID0gc2hhZGVyIHx8IHRoaXMucmVuZGVyZXIuc2hhZGVyLnNoYWRlcjtcclxuICAgICAgICB2YXIgcmVmID0gdGhpcztcclxuICAgICAgICB2YXIgZ2wgPSByZWYuZ2w7XHJcbiAgICAgICAgLy8gbm90IHN1cmUgdGhlIGJlc3Qgd2F5IHRvIGFkZHJlc3MgdGhpcy4uXHJcbiAgICAgICAgLy8gY3VycmVudGx5IGRpZmZlcmVudCBzaGFkZXJzIHJlcXVpcmUgZGlmZmVyZW50IFZBT3MgZm9yIHRoZSBzYW1lIGdlb21ldHJ5XHJcbiAgICAgICAgLy8gU3RpbGwgbXVsbGluZyBvdmVyIHRoZSBiZXN0IHdheSB0byBzb2x2ZSB0aGlzIG9uZS4uXHJcbiAgICAgICAgLy8gd2lsbCBsaWtlbHkgbmVlZCB0byBtb2RpZnkgdGhlIHNoYWRlciBhdHRyaWJ1dGUgbG9jYXRpb25zIGF0IHJ1biB0aW1lIVxyXG4gICAgICAgIHZhciB2YW9zID0gZ2VvbWV0cnkuZ2xWZXJ0ZXhBcnJheU9iamVjdHNbdGhpcy5DT05URVhUX1VJRF07XHJcbiAgICAgICAgaWYgKCF2YW9zKSB7XHJcbiAgICAgICAgICAgIHRoaXMubWFuYWdlZEdlb21ldHJpZXNbZ2VvbWV0cnkuaWRdID0gZ2VvbWV0cnk7XHJcbiAgICAgICAgICAgIC8vIGdlb21ldHJ5LmRpc3Bvc2VSdW5uZXIuYWRkKHRoaXMpO1xyXG4gICAgICAgICAgICBnZW9tZXRyeS5nbFZlcnRleEFycmF5T2JqZWN0c1t0aGlzLkNPTlRFWFRfVUlEXSA9IHZhb3MgPSB7fTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHZhbyA9IHZhb3Nbc2hhZGVyLnByb2dyYW0uaWRdIHx8IHRoaXMuaW5pdEdlb21ldHJ5VmFvKGdlb21ldHJ5LCBzaGFkZXIucHJvZ3JhbSk7XHJcbiAgICAgICAgdGhpcy5fYWN0aXZlR2VvbWV0cnkgPSBnZW9tZXRyeTtcclxuICAgICAgICBpZiAodGhpcy5fYWN0aXZlVmFvICE9PSB2YW8pIHtcclxuICAgICAgICAgICAgdGhpcy5fYWN0aXZlVmFvID0gdmFvO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5oYXNWYW8pIHtcclxuICAgICAgICAgICAgICAgIGdsLmJpbmRWZXJ0ZXhBcnJheSh2YW8pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hY3RpdmF0ZVZhbyhnZW9tZXRyeSwgc2hhZGVyLnByb2dyYW0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFRPRE8gLSBvcHRpbWlzZSBsYXRlciFcclxuICAgICAgICAvLyBkb24ndCBuZWVkIHRvIGxvb3AgdGhyb3VnaCBpZiBub3RoaW5nIGNoYW5nZWQhXHJcbiAgICAgICAgLy8gbWF5YmUgbG9vayB0byBhZGQgYW4gJ2F1dG91cGRhdGUnIHRvIGdlb21ldHJ5P1xyXG4gICAgICAgIHRoaXMudXBkYXRlQnVmZmVycygpO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXNldCBhbmQgdW5iaW5kIGFueSBhY3RpdmUgVkFPIGFuZCBnZW9tZXRyeVxyXG4gICAgICovXHJcbiAgICByZXNldCgpIHtcclxuICAgICAgICB0aGlzLnVuYmluZCgpO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGUgYnVmZmVyc1xyXG4gICAgICogQHByb3RlY3RlZFxyXG4gICAgICovXHJcbiAgICB1cGRhdGVCdWZmZXJzKCkge1xyXG4gICAgICAgIHZhciBnZW9tZXRyeSA9IHRoaXMuX2FjdGl2ZUdlb21ldHJ5O1xyXG4gICAgICAgIHZhciByZWYgPSB0aGlzO1xyXG4gICAgICAgIHZhciBnbCA9IHJlZi5nbDtcclxuICAgICAgICAvLyByZXZlYWwoZ2wpO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ2VvbWV0cnkuYnVmZmVycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgYnVmZmVyID0gZ2VvbWV0cnkuYnVmZmVyc1tpXTtcclxuICAgICAgICAgICAgdmFyIGdsQnVmZmVyID0gYnVmZmVyLl9nbEJ1ZmZlcnNbdGhpcy5DT05URVhUX1VJRF07XHJcbiAgICAgICAgICAgIGlmIChidWZmZXIuX3VwZGF0ZUlEICE9PSBnbEJ1ZmZlci51cGRhdGVJRCkge1xyXG4gICAgICAgICAgICAgICAgZ2xCdWZmZXIudXBkYXRlSUQgPSBidWZmZXIuX3VwZGF0ZUlEO1xyXG4gICAgICAgICAgICAgICAgLy8gVE9ETyBjYW4gY2FjaGUgdGhpcyBvbiBidWZmZXIhIG1heWJlIGFkZGVkIGEgZ2V0dGVyIC8gc2V0dGVyP1xyXG4gICAgICAgICAgICAgICAgdmFyIHR5cGUgPSBidWZmZXIuaW5kZXggPyBnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiA6IGdsLkFSUkFZX0JVRkZFUjtcclxuICAgICAgICAgICAgICAgIC8vIFRPRE8gdGhpcyBjb3VsZCBjaGFuZ2UgaWYgdGhlIFZBTyBjaGFuZ2VzLi4uXHJcbiAgICAgICAgICAgICAgICAvLyBuZWVkIHRvIGNvbWUgdXAgd2l0aCBhIGJldHRlciB3YXkgdG8gY2FjaGUuLlxyXG4gICAgICAgICAgICAgICAgLy8gaWYgKHRoaXMuYm91bmRCdWZmZXJzW3R5cGVdICE9PSBnbEJ1ZmZlcilcclxuICAgICAgICAgICAgICAgIC8vIHtcclxuICAgICAgICAgICAgICAgIC8vIHRoaXMuYm91bmRCdWZmZXJzW3R5cGVdID0gZ2xCdWZmZXI7XHJcbiAgICAgICAgICAgICAgICBnbC5iaW5kQnVmZmVyKHR5cGUsIGdsQnVmZmVyLmJ1ZmZlcik7XHJcbiAgICAgICAgICAgICAgICAvLyB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9ib3VuZEJ1ZmZlciA9IGdsQnVmZmVyO1xyXG4gICAgICAgICAgICAgICAgaWYgKGdsQnVmZmVyLmJ5dGVMZW5ndGggPj0gYnVmZmVyLmRhdGEuYnl0ZUxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIG9mZnNldCBpcyBhbHdheXMgemVybyBmb3Igbm93IVxyXG4gICAgICAgICAgICAgICAgICAgIGdsLmJ1ZmZlclN1YkRhdGEodHlwZSwgMCwgYnVmZmVyLmRhdGEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRyYXdUeXBlID0gYnVmZmVyLnN0YXRpYyA/IGdsLlNUQVRJQ19EUkFXIDogZ2wuRFlOQU1JQ19EUkFXO1xyXG4gICAgICAgICAgICAgICAgICAgIGdsQnVmZmVyLmJ5dGVMZW5ndGggPSBidWZmZXIuZGF0YS5ieXRlTGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgIGdsLmJ1ZmZlckRhdGEodHlwZSwgYnVmZmVyLmRhdGEsIGRyYXdUeXBlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2sgY29tcGFiaWxpdHkgYmV0d2VlbiBhIGdlb21ldHJ5IGFuZCBhIHByb2dyYW1cclxuICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAqIEBwYXJhbSB7UElYSS5HZW9tZXRyeX0gZ2VvbWV0cnkgLSBHZW9tZXRyeSBpbnN0YW5jZVxyXG4gICAgICogQHBhcmFtIHtQSVhJLlByb2dyYW19IHByb2dyYW0gLSBQcm9ncmFtIGluc3RhbmNlXHJcbiAgICAgKi9cclxuICAgIGNoZWNrQ29tcGF0aWJpbGl0eShnZW9tZXRyeSwgcHJvZ3JhbSkge1xyXG4gICAgICAgIC8vIGdlb21ldHJ5IG11c3QgaGF2ZSBhdCBsZWFzdCBhbGwgdGhlIGF0dHJpYnV0ZXMgdGhhdCB0aGUgc2hhZGVyIHJlcXVpcmVzLlxyXG4gICAgICAgIHZhciBnZW9tZXRyeUF0dHJpYnV0ZXMgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzO1xyXG4gICAgICAgIHZhciBzaGFkZXJBdHRyaWJ1dGVzID0gcHJvZ3JhbS5hdHRyaWJ1dGVEYXRhO1xyXG4gICAgICAgIGZvciAodmFyIGogaW4gc2hhZGVyQXR0cmlidXRlcykge1xyXG4gICAgICAgICAgICBpZiAoIWdlb21ldHJ5QXR0cmlidXRlc1tqXSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKChcInNoYWRlciBhbmQgZ2VvbWV0cnkgaW5jb21wYXRpYmxlLCBnZW9tZXRyeSBtaXNzaW5nIHRoZSBcXFwiXCIgKyBqICsgXCJcXFwiIGF0dHJpYnV0ZVwiKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFRha2VzIGEgZ2VvbWV0cnkgYW5kIHByb2dyYW0gYW5kIGdlbmVyYXRlcyBhIHVuaXF1ZSBzaWduYXR1cmUgZm9yIHRoZW0uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtQSVhJLkdlb21ldHJ5fSBnZW9tZXRyeSB0byBnZXQgc2lnbmF0dXJlIGZyb21cclxuICAgICAqIEBwYXJhbSB7UElYSS5Qcm9ncmFtfSBwcm9ncmFtIHRvIHRlc3QgZ2VvbWV0cnkgYWdhaW5zdFxyXG4gICAgICogQHJldHVybnMge1N0cmluZ30gVW5pcXVlIHNpZ25hdHVyZSBvZiB0aGUgZ2VvbWV0cnkgYW5kIHByb2dyYW1cclxuICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAqL1xyXG4gICAgZ2V0U2lnbmF0dXJlKGdlb21ldHJ5LCBwcm9ncmFtKSB7XHJcbiAgICAgICAgdmFyIGF0dHJpYnMgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzO1xyXG4gICAgICAgIHZhciBzaGFkZXJBdHRyaWJ1dGVzID0gcHJvZ3JhbS5hdHRyaWJ1dGVEYXRhO1xyXG4gICAgICAgIHZhciBzdHJpbmdzID0gWydnJywgZ2VvbWV0cnkuaWRdO1xyXG4gICAgICAgIGZvciAodmFyIGkgaW4gYXR0cmlicykge1xyXG4gICAgICAgICAgICBpZiAoc2hhZGVyQXR0cmlidXRlc1tpXSkge1xyXG4gICAgICAgICAgICAgICAgc3RyaW5ncy5wdXNoKGkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzdHJpbmdzLmpvaW4oJy0nKTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBvciBnZXRzIFZhbyB3aXRoIHRoZSBzYW1lIHN0cnVjdHVyZSBhcyB0aGUgZ2VvbWV0cnkgYW5kIHN0b3JlcyBpdCBvbiB0aGUgZ2VvbWV0cnkuXHJcbiAgICAgKiBJZiB2YW8gaXMgY3JlYXRlZCwgaXQgaXMgYm91bmQgYXV0b21hdGljYWxseS5cclxuICAgICAqXHJcbiAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgKiBAcGFyYW0ge1BJWEkuR2VvbWV0cnl9IGdlb21ldHJ5IC0gSW5zdGFuY2Ugb2YgZ2VvbWV0cnkgdG8gdG8gZ2VuZXJhdGUgVmFvIGZvclxyXG4gICAgICogQHBhcmFtIHtQSVhJLlByb2dyYW19IHByb2dyYW0gLSBJbnN0YW5jZSBvZiBwcm9ncmFtXHJcbiAgICAgKi9cclxuICAgIGluaXRHZW9tZXRyeVZhbyhnZW9tZXRyeSwgcHJvZ3JhbSkge1xyXG4gICAgICAgIHRoaXMuY2hlY2tDb21wYXRpYmlsaXR5KGdlb21ldHJ5LCBwcm9ncmFtKTtcclxuICAgICAgICB2YXIgZ2wgPSB0aGlzLmdsO1xyXG4gICAgICAgIHZhciBDT05URVhUX1VJRCA9IHRoaXMuQ09OVEVYVF9VSUQ7XHJcbiAgICAgICAgdmFyIHNpZ25hdHVyZSA9IHRoaXMuZ2V0U2lnbmF0dXJlKGdlb21ldHJ5LCBwcm9ncmFtKTtcclxuICAgICAgICB2YXIgdmFvT2JqZWN0SGFzaCA9IGdlb21ldHJ5LmdsVmVydGV4QXJyYXlPYmplY3RzW3RoaXMuQ09OVEVYVF9VSURdO1xyXG4gICAgICAgIHZhciB2YW8gPSB2YW9PYmplY3RIYXNoW3NpZ25hdHVyZV07XHJcbiAgICAgICAgaWYgKHZhbykge1xyXG4gICAgICAgICAgICAvLyB0aGlzIHdpbGwgZ2l2ZSB1cyBlYXN5IGFjY2VzcyB0byB0aGUgdmFvXHJcbiAgICAgICAgICAgIHZhb09iamVjdEhhc2hbcHJvZ3JhbS5pZF0gPSB2YW87XHJcbiAgICAgICAgICAgIHJldHVybiB2YW87XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBidWZmZXJzID0gZ2VvbWV0cnkuYnVmZmVycztcclxuICAgICAgICB2YXIgYXR0cmlidXRlcyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXM7XHJcbiAgICAgICAgdmFyIHRlbXBTdHJpZGUgPSB7fTtcclxuICAgICAgICB2YXIgdGVtcFN0YXJ0ID0ge307XHJcbiAgICAgICAgZm9yICh2YXIgaiBpbiBidWZmZXJzKSB7XHJcbiAgICAgICAgICAgIHRlbXBTdHJpZGVbal0gPSAwO1xyXG4gICAgICAgICAgICB0ZW1wU3RhcnRbal0gPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKHZhciBqJDEgaW4gYXR0cmlidXRlcykge1xyXG4gICAgICAgICAgICBpZiAoIWF0dHJpYnV0ZXNbaiQxXS5zaXplICYmIHByb2dyYW0uYXR0cmlidXRlRGF0YVtqJDFdKSB7XHJcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzW2okMV0uc2l6ZSA9IHByb2dyYW0uYXR0cmlidXRlRGF0YVtqJDFdLnNpemU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoIWF0dHJpYnV0ZXNbaiQxXS5zaXplKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oKFwiUElYSSBHZW9tZXRyeSBhdHRyaWJ1dGUgJ1wiICsgaiQxICsgXCInIHNpemUgY2Fubm90IGJlIGRldGVybWluZWQgKGxpa2VseSB0aGUgYm91bmQgc2hhZGVyIGRvZXMgbm90IGhhdmUgdGhlIGF0dHJpYnV0ZSlcIikpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGVtcFN0cmlkZVthdHRyaWJ1dGVzW2okMV0uYnVmZmVyXSArPSBhdHRyaWJ1dGVzW2okMV0uc2l6ZSAqIEdlb21ldHJ5U3lzdGVtLmJ5dGVTaXplTWFwJDFbYXR0cmlidXRlc1tqJDFdLnR5cGVdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKHZhciBqJDIgaW4gYXR0cmlidXRlcykge1xyXG4gICAgICAgICAgICB2YXIgYXR0cmlidXRlID0gYXR0cmlidXRlc1tqJDJdO1xyXG4gICAgICAgICAgICB2YXIgYXR0cmliU2l6ZSA9IGF0dHJpYnV0ZS5zaXplO1xyXG4gICAgICAgICAgICBpZiAoYXR0cmlidXRlLnN0cmlkZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGVtcFN0cmlkZVthdHRyaWJ1dGUuYnVmZmVyXSA9PT0gYXR0cmliU2l6ZSAqIEdlb21ldHJ5U3lzdGVtLmJ5dGVTaXplTWFwJDFbYXR0cmlidXRlLnR5cGVdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlLnN0cmlkZSA9IDA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGUuc3RyaWRlID0gdGVtcFN0cmlkZVthdHRyaWJ1dGUuYnVmZmVyXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoYXR0cmlidXRlLnN0YXJ0ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZS5zdGFydCA9IHRlbXBTdGFydFthdHRyaWJ1dGUuYnVmZmVyXTtcclxuICAgICAgICAgICAgICAgIHRlbXBTdGFydFthdHRyaWJ1dGUuYnVmZmVyXSArPSBhdHRyaWJTaXplICogR2VvbWV0cnlTeXN0ZW0uYnl0ZVNpemVNYXAkMVthdHRyaWJ1dGUudHlwZV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdmFvID0gZ2wuY3JlYXRlVmVydGV4QXJyYXkoKTtcclxuICAgICAgICBnbC5iaW5kVmVydGV4QXJyYXkodmFvKTtcclxuICAgICAgICAvLyBmaXJzdCB1cGRhdGUgLSBhbmQgY3JlYXRlIHRoZSBidWZmZXJzIVxyXG4gICAgICAgIC8vIG9ubHkgY3JlYXRlIGEgZ2wgYnVmZmVyIGlmIGl0IGFjdHVhbGx5IGdldHNcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ1ZmZlcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIGJ1ZmZlciA9IGJ1ZmZlcnNbaV07XHJcbiAgICAgICAgICAgIGlmICghYnVmZmVyLl9nbEJ1ZmZlcnNbQ09OVEVYVF9VSURdKSB7XHJcbiAgICAgICAgICAgICAgICBidWZmZXIuX2dsQnVmZmVyc1tDT05URVhUX1VJRF0gPSBuZXcgR0xCdWZmZXJfMS5HTEJ1ZmZlcihnbC5jcmVhdGVCdWZmZXIoKSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1hbmFnZWRCdWZmZXJzW2J1ZmZlci5pZF0gPSBidWZmZXI7XHJcbiAgICAgICAgICAgICAgICAvLyBidWZmZXIuZGlzcG9zZVJ1bm5lci5hZGQodGhpcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYnVmZmVyLl9nbEJ1ZmZlcnNbQ09OVEVYVF9VSURdLnJlZkNvdW50Kys7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFRPRE8gLSBtYXliZSBtYWtlIHRoaXMgYSBkYXRhIG9iamVjdD9cclxuICAgICAgICAvLyBsZXRzIHdhaXQgdG8gc2VlIGlmIHdlIG5lZWQgdG8gZmlyc3QhXHJcbiAgICAgICAgdGhpcy5hY3RpdmF0ZVZhbyhnZW9tZXRyeSwgcHJvZ3JhbSk7XHJcbiAgICAgICAgdGhpcy5fYWN0aXZlVmFvID0gdmFvO1xyXG4gICAgICAgIC8vIGFkZCBpdCB0byB0aGUgY2FjaGUhXHJcbiAgICAgICAgdmFvT2JqZWN0SGFzaFtwcm9ncmFtLmlkXSA9IHZhbztcclxuICAgICAgICB2YW9PYmplY3RIYXNoW3NpZ25hdHVyZV0gPSB2YW87XHJcbiAgICAgICAgcmV0dXJuIHZhbztcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogRGlzcG9zZXMgYnVmZmVyXHJcbiAgICAgKiBAcGFyYW0ge1BJWEkuQnVmZmVyfSBidWZmZXIgYnVmZmVyIHdpdGggZGF0YVxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbY29udGV4dExvc3Q9ZmFsc2VdIElmIGNvbnRleHQgd2FzIGxvc3QsIHdlIHN1cHByZXNzIGRlbGV0ZVZlcnRleEFycmF5XHJcbiAgICAgKi9cclxuICAgIGRpc3Bvc2VCdWZmZXIoYnVmZmVyLCBjb250ZXh0TG9zdCkge1xyXG4gICAgICAgIGlmICghdGhpcy5tYW5hZ2VkQnVmZmVyc1tidWZmZXIuaWRdKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZGVsZXRlIHRoaXMubWFuYWdlZEJ1ZmZlcnNbYnVmZmVyLmlkXTtcclxuICAgICAgICB2YXIgZ2xCdWZmZXIgPSBidWZmZXIuX2dsQnVmZmVyc1t0aGlzLkNPTlRFWFRfVUlEXTtcclxuICAgICAgICB2YXIgZ2wgPSB0aGlzLmdsO1xyXG4gICAgICAgIC8vIGJ1ZmZlci5kaXNwb3NlUnVubmVyLnJlbW92ZSh0aGlzKTtcclxuICAgICAgICBpZiAoIWdsQnVmZmVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFjb250ZXh0TG9zdCkge1xyXG4gICAgICAgICAgICBnbC5kZWxldGVCdWZmZXIoZ2xCdWZmZXIuYnVmZmVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZGVsZXRlIGJ1ZmZlci5fZ2xCdWZmZXJzW3RoaXMuQ09OVEVYVF9VSURdO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBEaXNwb3NlcyBnZW9tZXRyeVxyXG4gICAgICogQHBhcmFtIHtQSVhJLkdlb21ldHJ5fSBnZW9tZXRyeSBHZW9tZXRyeSB3aXRoIGJ1ZmZlcnMuIE9ubHkgVkFPIHdpbGwgYmUgZGlzcG9zZWRcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2NvbnRleHRMb3N0PWZhbHNlXSBJZiBjb250ZXh0IHdhcyBsb3N0LCB3ZSBzdXBwcmVzcyBkZWxldGVWZXJ0ZXhBcnJheVxyXG4gICAgICovXHJcbiAgICBkaXNwb3NlR2VvbWV0cnkoZ2VvbWV0cnksIGNvbnRleHRMb3N0KSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLm1hbmFnZWRHZW9tZXRyaWVzW2dlb21ldHJ5LmlkXSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRlbGV0ZSB0aGlzLm1hbmFnZWRHZW9tZXRyaWVzW2dlb21ldHJ5LmlkXTtcclxuICAgICAgICB2YXIgdmFvcyA9IGdlb21ldHJ5LmdsVmVydGV4QXJyYXlPYmplY3RzW3RoaXMuQ09OVEVYVF9VSURdO1xyXG4gICAgICAgIHZhciBnbCA9IHRoaXMuZ2w7XHJcbiAgICAgICAgdmFyIGJ1ZmZlcnMgPSBnZW9tZXRyeS5idWZmZXJzO1xyXG4gICAgICAgIGdlb21ldHJ5LmRpc3Bvc2VSdW5uZXIucmVtb3ZlKHRoaXMpO1xyXG4gICAgICAgIGlmICghdmFvcykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnVmZmVycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgYnVmID0gYnVmZmVyc1tpXS5fZ2xCdWZmZXJzW3RoaXMuQ09OVEVYVF9VSURdO1xyXG4gICAgICAgICAgICBidWYucmVmQ291bnQtLTtcclxuICAgICAgICAgICAgaWYgKGJ1Zi5yZWZDb3VudCA9PT0gMCAmJiAhY29udGV4dExvc3QpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGlzcG9zZUJ1ZmZlcihidWZmZXJzW2ldLCBjb250ZXh0TG9zdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFjb250ZXh0TG9zdCkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciB2YW9JZCBpbiB2YW9zKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBkZWxldGUgb25seSBzaWduYXR1cmVzLCBldmVyeXRoaW5nIGVsc2UgYXJlIGNvcGllc1xyXG4gICAgICAgICAgICAgICAgaWYgKHZhb0lkWzBdID09PSAnZycpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdmFvID0gdmFvc1t2YW9JZF07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2FjdGl2ZVZhbyA9PT0gdmFvKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudW5iaW5kKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGdsLmRlbGV0ZVZlcnRleEFycmF5KHZhbyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZGVsZXRlIGdlb21ldHJ5LmdsVmVydGV4QXJyYXlPYmplY3RzW3RoaXMuQ09OVEVYVF9VSURdO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBkaXNwb3NlIGFsbCBXZWJHTCByZXNvdXJjZXMgb2YgYWxsIG1hbmFnZWQgZ2VvbWV0cmllcyBhbmQgYnVmZmVyc1xyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbY29udGV4dExvc3Q9ZmFsc2VdIElmIGNvbnRleHQgd2FzIGxvc3QsIHdlIHN1cHByZXNzIGBnbC5kZWxldGVgIGNhbGxzXHJcbiAgICAgKi9cclxuICAgIGRpc3Bvc2VBbGwoY29udGV4dExvc3QpIHtcclxuICAgICAgICB2YXIgYWxsID0gT2JqZWN0LmtleXModGhpcy5tYW5hZ2VkR2VvbWV0cmllcyk7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbGwubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdGhpcy5kaXNwb3NlR2VvbWV0cnkodGhpcy5tYW5hZ2VkR2VvbWV0cmllc1thbGxbaV1dLCBjb250ZXh0TG9zdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGFsbCA9IE9iamVjdC5rZXlzKHRoaXMubWFuYWdlZEJ1ZmZlcnMpO1xyXG4gICAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGFsbC5sZW5ndGg7IGkkMSsrKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGlzcG9zZUJ1ZmZlcih0aGlzLm1hbmFnZWRCdWZmZXJzW2FsbFtpJDFdXSwgY29udGV4dExvc3QpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQWN0aXZhdGUgdmVydGV4IGFycmF5IG9iamVjdFxyXG4gICAgICpcclxuICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAqIEBwYXJhbSB7UElYSS5HZW9tZXRyeX0gZ2VvbWV0cnkgLSBHZW9tZXRyeSBpbnN0YW5jZVxyXG4gICAgICogQHBhcmFtIHtQSVhJLlByb2dyYW19IHByb2dyYW0gLSBTaGFkZXIgcHJvZ3JhbSBpbnN0YW5jZVxyXG4gICAgICovXHJcbiAgICBhY3RpdmF0ZVZhbyhnZW9tZXRyeSwgcHJvZ3JhbSkge1xyXG4gICAgICAgIHZhciBnbCA9IHRoaXMuZ2w7XHJcbiAgICAgICAgdmFyIENPTlRFWFRfVUlEID0gdGhpcy5DT05URVhUX1VJRDtcclxuICAgICAgICB2YXIgYnVmZmVycyA9IGdlb21ldHJ5LmJ1ZmZlcnM7XHJcbiAgICAgICAgdmFyIGF0dHJpYnV0ZXMgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzO1xyXG4gICAgICAgIGlmIChnZW9tZXRyeS5pbmRleEJ1ZmZlcikge1xyXG4gICAgICAgICAgICAvLyBmaXJzdCB1cGRhdGUgdGhlIGluZGV4IGJ1ZmZlciBpZiB3ZSBoYXZlIG9uZS4uXHJcbiAgICAgICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGdlb21ldHJ5LmluZGV4QnVmZmVyLl9nbEJ1ZmZlcnNbQ09OVEVYVF9VSURdLmJ1ZmZlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBsYXN0QnVmZmVyID0gbnVsbDtcclxuICAgICAgICAvLyBhZGQgYSBuZXcgb25lIVxyXG4gICAgICAgIGZvciAodmFyIGogaW4gYXR0cmlidXRlcykge1xyXG4gICAgICAgICAgICB2YXIgYXR0cmlidXRlID0gYXR0cmlidXRlc1tqXTtcclxuICAgICAgICAgICAgdmFyIGJ1ZmZlciA9IGJ1ZmZlcnNbYXR0cmlidXRlLmJ1ZmZlcl07XHJcbiAgICAgICAgICAgIHZhciBnbEJ1ZmZlciA9IGJ1ZmZlci5fZ2xCdWZmZXJzW0NPTlRFWFRfVUlEXTtcclxuICAgICAgICAgICAgaWYgKHByb2dyYW0uYXR0cmlidXRlRGF0YVtqXSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGxhc3RCdWZmZXIgIT09IGdsQnVmZmVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIGdsQnVmZmVyLmJ1ZmZlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgbGFzdEJ1ZmZlciA9IGdsQnVmZmVyO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIGxvY2F0aW9uID0gcHJvZ3JhbS5hdHRyaWJ1dGVEYXRhW2pdLmxvY2F0aW9uO1xyXG4gICAgICAgICAgICAgICAgLy8gVE9ETyBpbnRyb2R1Y2Ugc3RhdGUgYWdhaW5cclxuICAgICAgICAgICAgICAgIC8vIHdlIGNhbiBvcHRpbWlzZSB0aGlzIGZvciBvbGRlciBkZXZpY2VzIHRoYXQgaGF2ZSBubyBWQU9zXHJcbiAgICAgICAgICAgICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShsb2NhdGlvbik7XHJcbiAgICAgICAgICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKGxvY2F0aW9uLCBhdHRyaWJ1dGUuc2l6ZSwgYXR0cmlidXRlLnR5cGUgfHwgZ2wuRkxPQVQsIGF0dHJpYnV0ZS5ub3JtYWxpemVkLCBhdHRyaWJ1dGUuc3RyaWRlLCBhdHRyaWJ1dGUuc3RhcnQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGF0dHJpYnV0ZS5pbnN0YW5jZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gY2FsY3VsYXRlIGluc3RhbmNlIGNvdW50IGJhc2VkIG9mIHRoaXMuLi5cclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5oYXNJbnN0YW5jZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJEaXZpc29yKGxvY2F0aW9uLCAxKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZ2VvbWV0cnkgZXJyb3IsIEdQVSBJbnN0YW5jaW5nIGlzIG5vdCBzdXBwb3J0ZWQgb24gdGhpcyBkZXZpY2UnKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIERyYXcgdGhlIGdlb21ldHJ5XHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHR5cGUgLSB0aGUgdHlwZSBwcmltaXRpdmUgdG8gcmVuZGVyXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3NpemVdIC0gdGhlIG51bWJlciBvZiBlbGVtZW50cyB0byBiZSByZW5kZXJlZFxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtzdGFydF0gLSBTdGFydGluZyBpbmRleFxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtpbnN0YW5jZUNvdW50XSAtIHRoZSBudW1iZXIgb2YgaW5zdGFuY2VzIG9mIHRoZSBzZXQgb2YgZWxlbWVudHMgdG8gZXhlY3V0ZVxyXG4gICAgICovXHJcbiAgICBkcmF3KHR5cGUsIHNpemUgPSAtMSwgc3RhcnQgPSAwLCBpbnN0YW5jZUNvdW50ID0gMSkge1xyXG4gICAgICAgIHZhciByZWYgPSB0aGlzO1xyXG4gICAgICAgIHZhciBnbCA9IHJlZi5nbDtcclxuICAgICAgICB2YXIgZ2VvbWV0cnkgPSB0aGlzLl9hY3RpdmVHZW9tZXRyeTtcclxuICAgICAgICAvLyBUT0RPLi4gdGhpcyBzaG91bGQgbm90IGNoYW5nZSBzbyBtYXliZSBjYWNoZSB0aGUgZnVuY3Rpb24/XHJcbiAgICAgICAgaWYgKHNpemUgPCAwKSB7XHJcbiAgICAgICAgICAgIHNpemUgPSBnZW9tZXRyeS5pbmRleEJ1ZmZlci5kYXRhLmxlbmd0aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGdlb21ldHJ5LmluZGV4QnVmZmVyKSB7XHJcbiAgICAgICAgICAgIGlmIChnZW9tZXRyeS5pbnN0YW5jZWQpIHtcclxuICAgICAgICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4gKi9cclxuICAgICAgICAgICAgICAgIGdsLmRyYXdFbGVtZW50c0luc3RhbmNlZCh0eXBlLCBzaXplIHx8IGdlb21ldHJ5LmluZGV4QnVmZmVyLmRhdGEubGVuZ3RoLCBnbC5VTlNJR05FRF9TSE9SVCwgKHN0YXJ0IHx8IDApICogMiwgaW5zdGFuY2VDb3VudCB8fCAxKTtcclxuICAgICAgICAgICAgICAgIC8qIGVzbGludC1lbmFibGUgbWF4LWxlbiAqL1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZ2wuZHJhd0VsZW1lbnRzKHR5cGUsIHNpemUgfHwgZ2VvbWV0cnkuaW5kZXhCdWZmZXIuZGF0YS5sZW5ndGgsIGdsLlVOU0lHTkVEX1NIT1JULCAoc3RhcnQgfHwgMCkgKiAyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChnZW9tZXRyeS5pbnN0YW5jZWQpIHtcclxuICAgICAgICAgICAgLy8gVE9ETyBuZWVkIGEgYmV0dGVyIHdheSB0byBjYWxjdWxhdGUgc2l6ZS4uXHJcbiAgICAgICAgICAgIGdsLmRyYXdBcnJheXNJbnN0YW5jZWQodHlwZSwgc3RhcnQsIHNpemUgfHwgZ2VvbWV0cnkuZ2V0U2l6ZSgpLCBpbnN0YW5jZUNvdW50IHx8IDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZ2wuZHJhd0FycmF5cyh0eXBlLCBzdGFydCwgc2l6ZSB8fCBnZW9tZXRyeS5nZXRTaXplKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogVW5iaW5kL3Jlc2V0IGV2ZXJ5dGhpbmdcclxuICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAqL1xyXG4gICAgdW5iaW5kKCkge1xyXG4gICAgICAgIHRoaXMuZ2wuYmluZFZlcnRleEFycmF5KG51bGwpO1xyXG4gICAgICAgIHRoaXMuX2FjdGl2ZVZhbyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5fYWN0aXZlR2VvbWV0cnkgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgO1xyXG59XHJcbkdlb21ldHJ5U3lzdGVtLmJ5dGVTaXplTWFwJDEgPSB7IDUxMjY6IDQsIDUxMjM6IDIsIDUxMjE6IDEgfTtcclxuZXhwb3J0cy5HZW9tZXRyeVN5c3RlbSA9IEdlb21ldHJ5U3lzdGVtO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBDb250YWluZXJfMSA9IHJlcXVpcmUoXCIuL0NvbnRhaW5lclwiKTtcclxuY29uc3QgU3RhdGVfMSA9IHJlcXVpcmUoXCIuL1N0YXRlXCIpO1xyXG5jb25zdCBGaWxsU3R5bGVfMSA9IHJlcXVpcmUoXCIuL0ZpbGxTdHlsZVwiKTtcclxuLy8gaW1wb3J0IHsgc2V0dGluZ3MgfSBmcm9tIFwiLi9zZXR0aW5nc1wiO1xyXG5jb25zdCBUZXh0dXJlXzEgPSByZXF1aXJlKFwiLi9UZXh0dXJlXCIpO1xyXG5jb25zdCBSZWN0YW5nbGVfMSA9IHJlcXVpcmUoXCIuL1JlY3RhbmdsZVwiKTtcclxuY29uc3QgTWF0cml4XzEgPSByZXF1aXJlKFwiLi9NYXRyaXhcIik7XHJcbmNvbnN0IFVuaWZvcm1Hcm91cF8xID0gcmVxdWlyZShcIi4vVW5pZm9ybUdyb3VwXCIpO1xyXG5jb25zdCBTaGFkZXJfMSA9IHJlcXVpcmUoXCIuL1NoYWRlclwiKTtcclxuY29uc3QgUG9pbnRfMSA9IHJlcXVpcmUoXCIuL1BvaW50XCIpO1xyXG5jb25zdCBQb2x5Z29uXzEgPSByZXF1aXJlKFwiLi9Qb2x5Z29uXCIpO1xyXG5jb25zdCBFbGxpcHNlXzEgPSByZXF1aXJlKFwiLi9FbGxpcHNlXCIpO1xyXG5jb25zdCBDaXJjbGVfMSA9IHJlcXVpcmUoXCIuL0NpcmNsZVwiKTtcclxuY29uc3QgUm91bmRlZFJlY3RhbmdsZV8xID0gcmVxdWlyZShcIi4vUm91bmRlZFJlY3RhbmdsZVwiKTtcclxuY29uc3QgQXJjVXRpbHNfMSA9IHJlcXVpcmUoXCIuL0FyY1V0aWxzXCIpO1xyXG5jb25zdCBCZXppZXJVdGlsc18xID0gcmVxdWlyZShcIi4vQmV6aWVyVXRpbHNcIik7XHJcbmNvbnN0IFF1YWRyYXRpY1V0aWxzXzEgPSByZXF1aXJlKFwiLi9RdWFkcmF0aWNVdGlsc1wiKTtcclxuY29uc3QgTGluZVN0eWxlXzEgPSByZXF1aXJlKFwiLi9MaW5lU3R5bGVcIik7XHJcbmNvbnN0IEdyYXBoaWNzR2VvbWV0cnlfMSA9IHJlcXVpcmUoXCIuL0dyYXBoaWNzR2VvbWV0cnlcIik7XHJcbmNvbnN0IFN0YXJfMSA9IHJlcXVpcmUoXCIuL1N0YXJcIik7XHJcbmNvbnN0IE1hdGhTZXR0aW5nc18xID0gcmVxdWlyZShcIi4vTWF0aFNldHRpbmdzXCIpO1xyXG5jb25zdCBCbGVuZE1vZGVzU2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL0JsZW5kTW9kZXNTZXR0aW5nc1wiKTtcclxuY29uc3QgQ29sb3JTZXR0aW5nc18xID0gcmVxdWlyZShcIi4vQ29sb3JTZXR0aW5nc1wiKTtcclxuY2xhc3MgR3JhcGhpY3MgZXh0ZW5kcyBDb250YWluZXJfMS5Db250YWluZXIge1xyXG4gICAgY29uc3RydWN0b3IoZ2VvbWV0cnkgPSBudWxsKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICBpZiAoZ2VvbWV0cnkgPT09IHZvaWQgMCkge1xyXG4gICAgICAgICAgICBnZW9tZXRyeSA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEluY2x1ZGVzIHZlcnRleCBwb3NpdGlvbnMsIGZhY2UgaW5kaWNlcywgbm9ybWFscywgY29sb3JzLCBVVnMsIGFuZFxyXG4gICAgICAgICAqIGN1c3RvbSBhdHRyaWJ1dGVzIHdpdGhpbiBidWZmZXJzLCByZWR1Y2luZyB0aGUgY29zdCBvZiBwYXNzaW5nIGFsbFxyXG4gICAgICAgICAqIHRoaXMgZGF0YSB0byB0aGUgR1BVLiBDYW4gYmUgc2hhcmVkIGJldHdlZW4gbXVsdGlwbGUgTWVzaCBvciBHcmFwaGljcyBvYmplY3RzLlxyXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuR3JhcGhpY3NHZW9tZXRyeX1cclxuICAgICAgICAgKiBAcmVhZG9ubHlcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmdlb21ldHJ5ID0gZ2VvbWV0cnkgfHwgbmV3IEdyYXBoaWNzR2VvbWV0cnlfMS5HcmFwaGljc0dlb21ldHJ5KCk7XHJcbiAgICAgICAgdGhpcy5nZW9tZXRyeS5yZWZDb3VudCsrO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlcHJlc2VudHMgdGhlIHZlcnRleCBhbmQgZnJhZ21lbnQgc2hhZGVycyB0aGF0IHByb2Nlc3NlcyB0aGUgZ2VvbWV0cnkgYW5kIHJ1bnMgb24gdGhlIEdQVS5cclxuICAgICAgICAgKiBDYW4gYmUgc2hhcmVkIGJldHdlZW4gbXVsdGlwbGUgR3JhcGhpY3Mgb2JqZWN0cy5cclxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLlNoYWRlcn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnNoYWRlciA9IG51bGw7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmVwcmVzZW50cyB0aGUgV2ViR0wgc3RhdGUgdGhlIEdyYXBoaWNzIHJlcXVpcmVkIHRvIHJlbmRlciwgZXhjbHVkZXMgc2hhZGVyIGFuZCBnZW9tZXRyeS4gRS5nLixcclxuICAgICAgICAgKiBibGVuZCBtb2RlLCBjdWxsaW5nLCBkZXB0aCB0ZXN0aW5nLCBkaXJlY3Rpb24gb2YgcmVuZGVyaW5nIHRyaWFuZ2xlcywgYmFja2ZhY2UsIGV0Yy5cclxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLlN0YXRlfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSBTdGF0ZV8xLlN0YXRlLmZvcjJkKCk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ3VycmVudCBmaWxsIHN0eWxlXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLkZpbGxTdHlsZX1cclxuICAgICAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5fZmlsbFN0eWxlID0gbmV3IEZpbGxTdHlsZV8xLkZpbGxTdHlsZSgpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEN1cnJlbnQgbGluZSBzdHlsZVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQG1lbWJlciB7UElYSS5MaW5lU3R5bGV9XHJcbiAgICAgICAgICogQHByb3RlY3RlZFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuX2xpbmVTdHlsZSA9IG5ldyBMaW5lU3R5bGVfMS5MaW5lU3R5bGUoKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDdXJyZW50IHNoYXBlIHRyYW5zZm9ybSBtYXRyaXguXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLk1hdHJpeH1cclxuICAgICAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5fbWF0cml4ID0gbnVsbDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDdXJyZW50IGhvbGUgbW9kZSBpcyBlbmFibGVkLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQG1lbWJlciB7Ym9vbGVhbn1cclxuICAgICAgICAgKiBAZGVmYXVsdCBmYWxzZVxyXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLl9ob2xlTW9kZSA9IGZhbHNlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEN1cnJlbnQgcGF0aFxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQG1lbWJlciB7UElYSS5Qb2x5Z29ufVxyXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmN1cnJlbnRQYXRoID0gbnVsbDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBXaGVuIGNhY2hlQXNCaXRtYXAgaXMgc2V0IHRvIHRydWUgdGhlIGdyYXBoaWNzIG9iamVjdCB3aWxsIGJlIHJlbmRlcmVkIGFzIGlmIGl0IHdhcyBhIHNwcml0ZS5cclxuICAgICAgICAgKiBUaGlzIGlzIHVzZWZ1bCBpZiB5b3VyIGdyYXBoaWNzIGVsZW1lbnQgZG9lcyBub3QgY2hhbmdlIG9mdGVuLCBhcyBpdCB3aWxsIHNwZWVkIHVwIHRoZSByZW5kZXJpbmdcclxuICAgICAgICAgKiBvZiB0aGUgb2JqZWN0IGluIGV4Y2hhbmdlIGZvciB0YWtpbmcgdXAgdGV4dHVyZSBtZW1vcnkuIEl0IGlzIGFsc28gdXNlZnVsIGlmIHlvdSBuZWVkIHRoZSBncmFwaGljc1xyXG4gICAgICAgICAqIG9iamVjdCB0byBiZSBhbnRpLWFsaWFzZWQsIGJlY2F1c2UgaXQgd2lsbCBiZSByZW5kZXJlZCB1c2luZyBjYW52YXMuIFRoaXMgaXMgbm90IHJlY29tbWVuZGVkIGlmXHJcbiAgICAgICAgICogeW91IGFyZSBjb25zdGFudGx5IHJlZHJhd2luZyB0aGUgZ3JhcGhpY3MgZWxlbWVudC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBuYW1lIGNhY2hlQXNCaXRtYXBcclxuICAgICAgICAgKiBAbWVtYmVyIHtib29sZWFufVxyXG4gICAgICAgICAqIEBtZW1iZXJvZiBQSVhJLkdyYXBoaWNzI1xyXG4gICAgICAgICAqIEBkZWZhdWx0IGZhbHNlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQSBjb2xsZWN0aW9ucyBvZiBiYXRjaGVzISBUaGVzZSBjYW4gYmUgZHJhd24gYnkgdGhlIHJlbmRlcmVyIGJhdGNoIHN5c3RlbS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAgICAgKiBAbWVtYmVyIHtvYmplY3RbXX1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmJhdGNoZXMgPSBbXTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBVcGRhdGUgZGlydHkgZm9yIGxpbWl0aW5nIGNhbGN1bGF0aW5nIHRpbnRzIGZvciBiYXRjaGVzLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHByb3RlY3RlZFxyXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAgICAgKiBAZGVmYXVsdCAtMVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuYmF0Y2hUaW50ID0gLTE7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ29weSBvZiB0aGUgb2JqZWN0IHZlcnRleCBkYXRhLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHByb3RlY3RlZFxyXG4gICAgICAgICAqIEBtZW1iZXIge0Zsb2F0MzJBcnJheX1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnZlcnRleERhdGEgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuX3RyYW5zZm9ybUlEID0gLTE7XHJcbiAgICAgICAgdGhpcy5iYXRjaERpcnR5ID0gLTE7XHJcbiAgICAgICAgLy8gU2V0IGRlZmF1bHRcclxuICAgICAgICB0aGlzLnRpbnQgPSAweEZGRkZGRjtcclxuICAgICAgICB0aGlzLmJsZW5kTW9kZSA9IEJsZW5kTW9kZXNTZXR0aW5nc18xLkJsZW5kTW9kZXNTZXR0aW5ncy5CTEVORF9NT0RFUy5OT1JNQUw7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgR3JhcGhpY3Mgb2JqZWN0IHdpdGggdGhlIHNhbWUgdmFsdWVzIGFzIHRoaXMgb25lLlxyXG4gICAgICogTm90ZSB0aGF0IHRoZSBvbmx5IHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBvYmplY3QgYXJlIGNsb25lZCwgbm90IGl0cyB0cmFuc2Zvcm0gKHBvc2l0aW9uLHNjYWxlLGV0YylcclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIHtQSVhJLkdyYXBoaWNzfSBBIGNsb25lIG9mIHRoZSBncmFwaGljcyBvYmplY3RcclxuICAgICAqL1xyXG4gICAgY2xvbmUoKSB7XHJcbiAgICAgICAgdGhpcy5maW5pc2hQb2x5KCk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBHcmFwaGljcyh0aGlzLmdlb21ldHJ5KTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGJsZW5kIG1vZGUgdG8gYmUgYXBwbGllZCB0byB0aGUgZ3JhcGhpYyBzaGFwZS4gQXBwbHkgYSB2YWx1ZSBvZlxyXG4gICAgICogYFBJWEkuQkxFTkRfTU9ERVMuTk9STUFMYCB0byByZXNldCB0aGUgYmxlbmQgbW9kZS5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgKiBAZGVmYXVsdCBQSVhJLkJMRU5EX01PREVTLk5PUk1BTDtcclxuICAgICAqIEBzZWUgUElYSS5CTEVORF9NT0RFU1xyXG4gICAgICovXHJcbiAgICBzZXQgYmxlbmRNb2RlKHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5zdGF0ZS5ibGVuZE1vZGUgPSB2YWx1ZTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIGdldCBibGVuZE1vZGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUuYmxlbmRNb2RlO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgdGludCBhcHBsaWVkIHRvIHRoZSBncmFwaGljIHNoYXBlLiBUaGlzIGlzIGEgaGV4IHZhbHVlLiBBIHZhbHVlIG9mXHJcbiAgICAgKiAweEZGRkZGRiB3aWxsIHJlbW92ZSBhbnkgdGludCBlZmZlY3QuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICogQGRlZmF1bHQgMHhGRkZGRkZcclxuICAgICAqL1xyXG4gICAgZ2V0IHRpbnQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RpbnQ7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICBzZXQgdGludCh2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuX3RpbnQgPSB2YWx1ZTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGN1cnJlbnQgZmlsbCBzdHlsZS5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtQSVhJLkZpbGxTdHlsZX1cclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICovXHJcbiAgICBnZXQgZmlsbCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZmlsbFN0eWxlO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgY3VycmVudCBsaW5lIHN0eWxlLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge1BJWEkuTGluZVN0eWxlfVxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKi9cclxuICAgIGdldCBsaW5lKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9saW5lU3R5bGU7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFNwZWNpZmllcyB0aGUgbGluZSBzdHlsZSB1c2VkIGZvciBzdWJzZXF1ZW50IGNhbGxzIHRvIEdyYXBoaWNzIG1ldGhvZHMgc3VjaCBhcyB0aGUgbGluZVRvKClcclxuICAgICAqIG1ldGhvZCBvciB0aGUgZHJhd0NpcmNsZSgpIG1ldGhvZC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3dpZHRoPTBdIC0gd2lkdGggb2YgdGhlIGxpbmUgdG8gZHJhdywgd2lsbCB1cGRhdGUgdGhlIG9iamVjdHMgc3RvcmVkIHN0eWxlXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2NvbG9yPTBdIC0gY29sb3Igb2YgdGhlIGxpbmUgdG8gZHJhdywgd2lsbCB1cGRhdGUgdGhlIG9iamVjdHMgc3RvcmVkIHN0eWxlXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FscGhhPTFdIC0gYWxwaGEgb2YgdGhlIGxpbmUgdG8gZHJhdywgd2lsbCB1cGRhdGUgdGhlIG9iamVjdHMgc3RvcmVkIHN0eWxlXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FsaWdubWVudD0xXSAtIGFsaWdubWVudCBvZiB0aGUgbGluZSB0byBkcmF3LCAoMCA9IGlubmVyLCAwLjUgPSBtaWRkbGUsIDEgPSBvdXR0ZXIpXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtuYXRpdmU9ZmFsc2VdIC0gSWYgdHJ1ZSB0aGUgbGluZXMgd2lsbCBiZSBkcmF3IHVzaW5nIExJTkVTIGluc3RlYWQgb2YgVFJJQU5HTEVfU1RSSVBcclxuICAgICAqIEByZXR1cm4ge1BJWEkuR3JhcGhpY3N9IFRoaXMgR3JhcGhpY3Mgb2JqZWN0LiBHb29kIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHNcclxuICAgICAqL1xyXG4gICAgbGluZVN0eWxlKHdpZHRoLCBjb2xvciA9IDAsIGFscGhhID0gMSwgYWxpZ25tZW50ID0gMC41LCBuYXRpdmUgPSBmYWxzZSkge1xyXG4gICAgICAgIGlmICh3aWR0aCA9PT0gdm9pZCAwKSB7XHJcbiAgICAgICAgICAgIHdpZHRoID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNvbG9yID09PSB2b2lkIDApIHtcclxuICAgICAgICAgICAgY29sb3IgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYWxwaGEgPT09IHZvaWQgMCkge1xyXG4gICAgICAgICAgICBhbHBoYSA9IDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChhbGlnbm1lbnQgPT09IHZvaWQgMCkge1xyXG4gICAgICAgICAgICBhbGlnbm1lbnQgPSAwLjU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChuYXRpdmUgPT09IHZvaWQgMCkge1xyXG4gICAgICAgICAgICBuYXRpdmUgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5saW5lVGV4dHVyZVN0eWxlKHdpZHRoLCBUZXh0dXJlXzEuVGV4dHVyZS5XSElURSwgY29sb3IsIGFscGhhLCBudWxsLCBhbGlnbm1lbnQsIG5hdGl2ZSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIExpa2UgbGluZSBzdHlsZSBidXQgc3VwcG9ydCB0ZXh0dXJlIGZvciBsaW5lIGZpbGwuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt3aWR0aD0wXSAtIHdpZHRoIG9mIHRoZSBsaW5lIHRvIGRyYXcsIHdpbGwgdXBkYXRlIHRoZSBvYmplY3RzIHN0b3JlZCBzdHlsZVxyXG4gICAgICogQHBhcmFtIHtQSVhJLlRleHR1cmV9IFt0ZXh0dXJlPVBJWEkuVGV4dHVyZS5XSElURV0gLSBUZXh0dXJlIHRvIHVzZVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtjb2xvcj0wXSAtIGNvbG9yIG9mIHRoZSBsaW5lIHRvIGRyYXcsIHdpbGwgdXBkYXRlIHRoZSBvYmplY3RzIHN0b3JlZCBzdHlsZVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthbHBoYT0xXSAtIGFscGhhIG9mIHRoZSBsaW5lIHRvIGRyYXcsIHdpbGwgdXBkYXRlIHRoZSBvYmplY3RzIHN0b3JlZCBzdHlsZVxyXG4gICAgICogQHBhcmFtIHtQSVhJLk1hdHJpeH0gW21hdHJpeD1udWxsXSBUZXh0dXJlIG1hdHJpeCB0byB0cmFuc2Zvcm0gdGV4dHVyZVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthbGlnbm1lbnQ9MC41XSAtIGFsaWdubWVudCBvZiB0aGUgbGluZSB0byBkcmF3LCAoMCA9IGlubmVyLCAwLjUgPSBtaWRkbGUsIDEgPSBvdXR0ZXIpXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtuYXRpdmU9ZmFsc2VdIC0gSWYgdHJ1ZSB0aGUgbGluZXMgd2lsbCBiZSBkcmF3IHVzaW5nIExJTkVTIGluc3RlYWQgb2YgVFJJQU5HTEVfU1RSSVBcclxuICAgICAqIEByZXR1cm4ge1BJWEkuR3JhcGhpY3N9IFRoaXMgR3JhcGhpY3Mgb2JqZWN0LiBHb29kIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHNcclxuICAgICAqL1xyXG4gICAgbGluZVRleHR1cmVTdHlsZSh3aWR0aCA9IDAsIHRleHR1cmUgPSBUZXh0dXJlXzEuVGV4dHVyZS5XSElURSwgY29sb3IgPSAweEZGRkZGRiwgYWxwaGEgPSAxLCBtYXRyaXggPSBudWxsLCBhbGlnbm1lbnQgPSAwLjUsIG5hdGl2ZSA9IGZhbHNlKSB7XHJcbiAgICAgICAgaWYgKHdpZHRoID09PSB2b2lkIDApIHtcclxuICAgICAgICAgICAgd2lkdGggPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGV4dHVyZSA9PT0gdm9pZCAwKSB7XHJcbiAgICAgICAgICAgIHRleHR1cmUgPSBUZXh0dXJlXzEuVGV4dHVyZS5XSElURTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNvbG9yID09PSB2b2lkIDApIHtcclxuICAgICAgICAgICAgY29sb3IgPSAweEZGRkZGRjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGFscGhhID09PSB2b2lkIDApIHtcclxuICAgICAgICAgICAgYWxwaGEgPSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobWF0cml4ID09PSB2b2lkIDApIHtcclxuICAgICAgICAgICAgbWF0cml4ID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGFsaWdubWVudCA9PT0gdm9pZCAwKSB7XHJcbiAgICAgICAgICAgIGFsaWdubWVudCA9IDAuNTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG5hdGl2ZSA9PT0gdm9pZCAwKSB7XHJcbiAgICAgICAgICAgIG5hdGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5jdXJyZW50UGF0aCkge1xyXG4gICAgICAgICAgICB0aGlzLnN0YXJ0UG9seSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgdmlzaWJsZSA9IHdpZHRoID4gMCAmJiBhbHBoYSA+IDA7XHJcbiAgICAgICAgaWYgKCF2aXNpYmxlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2xpbmVTdHlsZS5yZXNldCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKG1hdHJpeCkge1xyXG4gICAgICAgICAgICAgICAgbWF0cml4ID0gbWF0cml4LmNsb25lKCk7XHJcbiAgICAgICAgICAgICAgICBtYXRyaXguaW52ZXJ0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLl9saW5lU3R5bGUsIHtcclxuICAgICAgICAgICAgICAgIGNvbG9yOiBjb2xvcixcclxuICAgICAgICAgICAgICAgIHdpZHRoOiB3aWR0aCxcclxuICAgICAgICAgICAgICAgIGFscGhhOiBhbHBoYSxcclxuICAgICAgICAgICAgICAgIG1hdHJpeDogbWF0cml4LFxyXG4gICAgICAgICAgICAgICAgdGV4dHVyZTogdGV4dHVyZSxcclxuICAgICAgICAgICAgICAgIGFsaWdubWVudDogYWxpZ25tZW50LFxyXG4gICAgICAgICAgICAgICAgbmF0aXZlOiBuYXRpdmUsXHJcbiAgICAgICAgICAgICAgICB2aXNpYmxlOiB2aXNpYmxlLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFN0YXJ0IGEgcG9seWdvbiBvYmplY3QgaW50ZXJuYWxseVxyXG4gICAgICogQHByb3RlY3RlZFxyXG4gICAgICovXHJcbiAgICBzdGFydFBvbHkoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFBhdGgpIHtcclxuICAgICAgICAgICAgdmFyIHBvaW50cyA9IHRoaXMuY3VycmVudFBhdGgucG9pbnRzO1xyXG4gICAgICAgICAgICB2YXIgbGVuID0gdGhpcy5jdXJyZW50UGF0aC5wb2ludHMubGVuZ3RoO1xyXG4gICAgICAgICAgICBpZiAobGVuID4gMikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kcmF3U2hhcGUodGhpcy5jdXJyZW50UGF0aCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRQYXRoID0gbmV3IFBvbHlnb25fMS5Qb2x5Z29uKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRQYXRoLmNsb3NlU3Ryb2tlID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRQYXRoLnBvaW50cy5wdXNoKHBvaW50c1tsZW4gLSAyXSwgcG9pbnRzW2xlbiAtIDFdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50UGF0aCA9IG5ldyBQb2x5Z29uXzEuUG9seWdvbigpO1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRQYXRoLmNsb3NlU3Ryb2tlID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBGaW5pc2ggdGhlIHBvbHlnb24gb2JqZWN0LlxyXG4gICAgICogQHByb3RlY3RlZFxyXG4gICAgICovXHJcbiAgICBmaW5pc2hQb2x5KCkge1xyXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRQYXRoKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRQYXRoLnBvaW50cy5sZW5ndGggPiAyKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRyYXdTaGFwZSh0aGlzLmN1cnJlbnRQYXRoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFBhdGggPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50UGF0aC5wb2ludHMubGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogTW92ZXMgdGhlIGN1cnJlbnQgZHJhd2luZyBwb3NpdGlvbiB0byB4LCB5LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gdGhlIFggY29vcmRpbmF0ZSB0byBtb3ZlIHRvXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSAtIHRoZSBZIGNvb3JkaW5hdGUgdG8gbW92ZSB0b1xyXG4gICAgICogQHJldHVybiB7UElYSS5HcmFwaGljc30gVGhpcyBHcmFwaGljcyBvYmplY3QuIEdvb2QgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxsc1xyXG4gICAgICovXHJcbiAgICBtb3ZlVG8oeCwgeSkge1xyXG4gICAgICAgIHRoaXMuc3RhcnRQb2x5KCk7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50UGF0aC5wb2ludHNbMF0gPSB4O1xyXG4gICAgICAgIHRoaXMuY3VycmVudFBhdGgucG9pbnRzWzFdID0geTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogRHJhd3MgYSBsaW5lIHVzaW5nIHRoZSBjdXJyZW50IGxpbmUgc3R5bGUgZnJvbSB0aGUgY3VycmVudCBkcmF3aW5nIHBvc2l0aW9uIHRvICh4LCB5KTtcclxuICAgICAqIFRoZSBjdXJyZW50IGRyYXdpbmcgcG9zaXRpb24gaXMgdGhlbiBzZXQgdG8gKHgsIHkpLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gdGhlIFggY29vcmRpbmF0ZSB0byBkcmF3IHRvXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSAtIHRoZSBZIGNvb3JkaW5hdGUgdG8gZHJhdyB0b1xyXG4gICAgICogQHJldHVybiB7UElYSS5HcmFwaGljc30gVGhpcyBHcmFwaGljcyBvYmplY3QuIEdvb2QgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxsc1xyXG4gICAgICovXHJcbiAgICBsaW5lVG8oeCwgeSkge1xyXG4gICAgICAgIGlmICghdGhpcy5jdXJyZW50UGF0aCkge1xyXG4gICAgICAgICAgICB0aGlzLm1vdmVUbygwLCAwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gcmVtb3ZlIGR1cGxpY2F0ZXMuLlxyXG4gICAgICAgIHZhciBwb2ludHMgPSB0aGlzLmN1cnJlbnRQYXRoLnBvaW50cztcclxuICAgICAgICB2YXIgZnJvbVggPSBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDJdO1xyXG4gICAgICAgIHZhciBmcm9tWSA9IHBvaW50c1twb2ludHMubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgaWYgKGZyb21YICE9PSB4IHx8IGZyb21ZICE9PSB5KSB7XHJcbiAgICAgICAgICAgIHBvaW50cy5wdXNoKHgsIHkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogSW5pdGlhbGl6ZSB0aGUgY3VydmVcclxuICAgICAqXHJcbiAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3g9MF1cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbeT0wXVxyXG4gICAgICovXHJcbiAgICBfaW5pdEN1cnZlKHggPSAwLCB5ID0gMCkge1xyXG4gICAgICAgIGlmICh4ID09PSB2b2lkIDApIHtcclxuICAgICAgICAgICAgeCA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh5ID09PSB2b2lkIDApIHtcclxuICAgICAgICAgICAgeSA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRQYXRoKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRQYXRoLnBvaW50cy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFBhdGgucG9pbnRzID0gW3gsIHldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLm1vdmVUbyh4LCB5KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIENhbGN1bGF0ZSB0aGUgcG9pbnRzIGZvciBhIHF1YWRyYXRpYyBiZXppZXIgY3VydmUgYW5kIHRoZW4gZHJhd3MgaXQuXHJcbiAgICAgKiBCYXNlZCBvbjogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNzg1MDk3L2hvdy1kby1pLWltcGxlbWVudC1hLWJlemllci1jdXJ2ZS1pbi1jXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNwWCAtIENvbnRyb2wgcG9pbnQgeFxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNwWSAtIENvbnRyb2wgcG9pbnQgeVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRvWCAtIERlc3RpbmF0aW9uIHBvaW50IHhcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0b1kgLSBEZXN0aW5hdGlvbiBwb2ludCB5XHJcbiAgICAgKiBAcmV0dXJuIHtQSVhJLkdyYXBoaWNzfSBUaGlzIEdyYXBoaWNzIG9iamVjdC4gR29vZCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzXHJcbiAgICAgKi9cclxuICAgIHF1YWRyYXRpY0N1cnZlVG8oY3BYLCBjcFksIHRvWCwgdG9ZKSB7XHJcbiAgICAgICAgdGhpcy5faW5pdEN1cnZlKCk7XHJcbiAgICAgICAgdmFyIHBvaW50cyA9IHRoaXMuY3VycmVudFBhdGgucG9pbnRzO1xyXG4gICAgICAgIGlmIChwb2ludHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMubW92ZVRvKDAsIDApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBRdWFkcmF0aWNVdGlsc18xLlF1YWRyYXRpY1V0aWxzLmN1cnZlVG8oY3BYLCBjcFksIHRvWCwgdG9ZLCBwb2ludHMpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxjdWxhdGUgdGhlIHBvaW50cyBmb3IgYSBiZXppZXIgY3VydmUgYW5kIHRoZW4gZHJhd3MgaXQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNwWCAtIENvbnRyb2wgcG9pbnQgeFxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNwWSAtIENvbnRyb2wgcG9pbnQgeVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNwWDIgLSBTZWNvbmQgQ29udHJvbCBwb2ludCB4XHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY3BZMiAtIFNlY29uZCBDb250cm9sIHBvaW50IHlcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0b1ggLSBEZXN0aW5hdGlvbiBwb2ludCB4XHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdG9ZIC0gRGVzdGluYXRpb24gcG9pbnQgeVxyXG4gICAgICogQHJldHVybiB7UElYSS5HcmFwaGljc30gVGhpcyBHcmFwaGljcyBvYmplY3QuIEdvb2QgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxsc1xyXG4gICAgICovXHJcbiAgICBiZXppZXJDdXJ2ZVRvKGNwWCwgY3BZLCBjcFgyLCBjcFkyLCB0b1gsIHRvWSkge1xyXG4gICAgICAgIHRoaXMuX2luaXRDdXJ2ZSgpO1xyXG4gICAgICAgIEJlemllclV0aWxzXzEuQmV6aWVyVXRpbHMuY3VydmVUbyhjcFgsIGNwWSwgY3BYMiwgY3BZMiwgdG9YLCB0b1ksIHRoaXMuY3VycmVudFBhdGgucG9pbnRzKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGFyY1RvKCkgbWV0aG9kIGNyZWF0ZXMgYW4gYXJjL2N1cnZlIGJldHdlZW4gdHdvIHRhbmdlbnRzIG9uIHRoZSBjYW52YXMuXHJcbiAgICAgKlxyXG4gICAgICogXCJib3Jyb3dlZFwiIGZyb20gaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9meGNhbnZhcy8gLSB0aGFua3MgZ29vZ2xlIVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4MSAtIFRoZSB4LWNvb3JkaW5hdGUgb2YgdGhlIGJlZ2lubmluZyBvZiB0aGUgYXJjXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geTEgLSBUaGUgeS1jb29yZGluYXRlIG9mIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGFyY1xyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHgyIC0gVGhlIHgtY29vcmRpbmF0ZSBvZiB0aGUgZW5kIG9mIHRoZSBhcmNcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5MiAtIFRoZSB5LWNvb3JkaW5hdGUgb2YgdGhlIGVuZCBvZiB0aGUgYXJjXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcmFkaXVzIC0gVGhlIHJhZGl1cyBvZiB0aGUgYXJjXHJcbiAgICAgKiBAcmV0dXJuIHtQSVhJLkdyYXBoaWNzfSBUaGlzIEdyYXBoaWNzIG9iamVjdC4gR29vZCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzXHJcbiAgICAgKi9cclxuICAgIGFyY1RvKHgxLCB5MSwgeDIsIHkyLCByYWRpdXMpIHtcclxuICAgICAgICB0aGlzLl9pbml0Q3VydmUoeDEsIHkxKTtcclxuICAgICAgICB2YXIgcG9pbnRzID0gdGhpcy5jdXJyZW50UGF0aC5wb2ludHM7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IEFyY1V0aWxzXzEuQXJjVXRpbHMuY3VydmVUbyh4MSwgeTEsIHgyLCB5MiwgcmFkaXVzLCBwb2ludHMpO1xyXG4gICAgICAgIGlmIChyZXN1bHQpIHtcclxuICAgICAgICAgICAgdmFyIGN4ID0gcmVzdWx0LmN4O1xyXG4gICAgICAgICAgICB2YXIgY3kgPSByZXN1bHQuY3k7XHJcbiAgICAgICAgICAgIHZhciByYWRpdXMkMSA9IHJlc3VsdC5yYWRpdXM7XHJcbiAgICAgICAgICAgIHZhciBzdGFydEFuZ2xlID0gcmVzdWx0LnN0YXJ0QW5nbGU7XHJcbiAgICAgICAgICAgIHZhciBlbmRBbmdsZSA9IHJlc3VsdC5lbmRBbmdsZTtcclxuICAgICAgICAgICAgdmFyIGFudGljbG9ja3dpc2UgPSByZXN1bHQuYW50aWNsb2Nrd2lzZTtcclxuICAgICAgICAgICAgdGhpcy5hcmMoY3gsIGN5LCByYWRpdXMkMSwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGFudGljbG9ja3dpc2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGFyYyBtZXRob2QgY3JlYXRlcyBhbiBhcmMvY3VydmUgKHVzZWQgdG8gY3JlYXRlIGNpcmNsZXMsIG9yIHBhcnRzIG9mIGNpcmNsZXMpLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjeCAtIFRoZSB4LWNvb3JkaW5hdGUgb2YgdGhlIGNlbnRlciBvZiB0aGUgY2lyY2xlXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY3kgLSBUaGUgeS1jb29yZGluYXRlIG9mIHRoZSBjZW50ZXIgb2YgdGhlIGNpcmNsZVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJhZGl1cyAtIFRoZSByYWRpdXMgb2YgdGhlIGNpcmNsZVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0QW5nbGUgLSBUaGUgc3RhcnRpbmcgYW5nbGUsIGluIHJhZGlhbnMgKDAgaXMgYXQgdGhlIDMgbydjbG9jayBwb3NpdGlvblxyXG4gICAgICogIG9mIHRoZSBhcmMncyBjaXJjbGUpXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZW5kQW5nbGUgLSBUaGUgZW5kaW5nIGFuZ2xlLCBpbiByYWRpYW5zXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFthbnRpY2xvY2t3aXNlPWZhbHNlXSAtIFNwZWNpZmllcyB3aGV0aGVyIHRoZSBkcmF3aW5nIHNob3VsZCBiZVxyXG4gICAgICogIGNvdW50ZXItY2xvY2t3aXNlIG9yIGNsb2Nrd2lzZS4gRmFsc2UgaXMgZGVmYXVsdCwgYW5kIGluZGljYXRlcyBjbG9ja3dpc2UsIHdoaWxlIHRydWVcclxuICAgICAqICBpbmRpY2F0ZXMgY291bnRlci1jbG9ja3dpc2UuXHJcbiAgICAgKiBAcmV0dXJuIHtQSVhJLkdyYXBoaWNzfSBUaGlzIEdyYXBoaWNzIG9iamVjdC4gR29vZCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzXHJcbiAgICAgKi9cclxuICAgIGFyYyhjeCwgY3ksIHJhZGl1cywgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGFudGljbG9ja3dpc2UgPSBmYWxzZSkge1xyXG4gICAgICAgIGlmIChhbnRpY2xvY2t3aXNlID09PSB2b2lkIDApIHtcclxuICAgICAgICAgICAgYW50aWNsb2Nrd2lzZSA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc3RhcnRBbmdsZSA9PT0gZW5kQW5nbGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghYW50aWNsb2Nrd2lzZSAmJiBlbmRBbmdsZSA8PSBzdGFydEFuZ2xlKSB7XHJcbiAgICAgICAgICAgIGVuZEFuZ2xlICs9IE1hdGhTZXR0aW5nc18xLk1hdGhTZXR0aW5ncy5QSV8yO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChhbnRpY2xvY2t3aXNlICYmIHN0YXJ0QW5nbGUgPD0gZW5kQW5nbGUpIHtcclxuICAgICAgICAgICAgc3RhcnRBbmdsZSArPSBNYXRoU2V0dGluZ3NfMS5NYXRoU2V0dGluZ3MuUElfMjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHN3ZWVwID0gZW5kQW5nbGUgLSBzdGFydEFuZ2xlO1xyXG4gICAgICAgIGlmIChzd2VlcCA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHN0YXJ0WCA9IGN4ICsgKE1hdGguY29zKHN0YXJ0QW5nbGUpICogcmFkaXVzKTtcclxuICAgICAgICB2YXIgc3RhcnRZID0gY3kgKyAoTWF0aC5zaW4oc3RhcnRBbmdsZSkgKiByYWRpdXMpO1xyXG4gICAgICAgIC8vIElmIHRoZSBjdXJyZW50UGF0aCBleGlzdHMsIHRha2UgaXRzIHBvaW50cy4gT3RoZXJ3aXNlIGNhbGwgYG1vdmVUb2AgdG8gc3RhcnQgYSBwYXRoLlxyXG4gICAgICAgIHZhciBwb2ludHMgPSB0aGlzLmN1cnJlbnRQYXRoID8gdGhpcy5jdXJyZW50UGF0aC5wb2ludHMgOiBudWxsO1xyXG4gICAgICAgIGlmIChwb2ludHMpIHtcclxuICAgICAgICAgICAgLy8gVE9ETzogbWFrZSBhIGJldHRlciBmaXguXHJcbiAgICAgICAgICAgIC8vIFdlIGNoZWNrIGhvdyBmYXIgb3VyIHN0YXJ0IGlzIGZyb20gdGhlIGxhc3QgZXhpc3RpbmcgcG9pbnRcclxuICAgICAgICAgICAgdmFyIHhEaWZmID0gTWF0aC5hYnMocG9pbnRzW3BvaW50cy5sZW5ndGggLSAyXSAtIHN0YXJ0WCk7XHJcbiAgICAgICAgICAgIHZhciB5RGlmZiA9IE1hdGguYWJzKHBvaW50c1twb2ludHMubGVuZ3RoIC0gMV0gLSBzdGFydFkpO1xyXG4gICAgICAgICAgICBpZiAoeERpZmYgPCAwLjAwMSAmJiB5RGlmZiA8IDAuMDAxKSB7XHJcbiAgICAgICAgICAgICAgICA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBwb2ludHMucHVzaChzdGFydFgsIHN0YXJ0WSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMubW92ZVRvKHN0YXJ0WCwgc3RhcnRZKTtcclxuICAgICAgICAgICAgcG9pbnRzID0gdGhpcy5jdXJyZW50UGF0aC5wb2ludHM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIEFyY1V0aWxzXzEuQXJjVXRpbHMuYXJjKHN0YXJ0WCwgc3RhcnRZLCBjeCwgY3ksIHJhZGl1cywgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGFudGljbG9ja3dpc2UsIHBvaW50cyk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFNwZWNpZmllcyBhIHNpbXBsZSBvbmUtY29sb3IgZmlsbCB0aGF0IHN1YnNlcXVlbnQgY2FsbHMgdG8gb3RoZXIgR3JhcGhpY3MgbWV0aG9kc1xyXG4gICAgICogKHN1Y2ggYXMgbGluZVRvKCkgb3IgZHJhd0NpcmNsZSgpKSB1c2Ugd2hlbiBkcmF3aW5nLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbY29sb3I9MF0gLSB0aGUgY29sb3Igb2YgdGhlIGZpbGxcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYWxwaGE9MV0gLSB0aGUgYWxwaGEgb2YgdGhlIGZpbGxcclxuICAgICAqIEByZXR1cm4ge1BJWEkuR3JhcGhpY3N9IFRoaXMgR3JhcGhpY3Mgb2JqZWN0LiBHb29kIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHNcclxuICAgICAqL1xyXG4gICAgYmVnaW5GaWxsKGNvbG9yID0gMCwgYWxwaGEgPSAxKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYmVnaW5UZXh0dXJlRmlsbChUZXh0dXJlXzEuVGV4dHVyZS5XSElURSwgY29sb3IsIGFscGhhKTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQmVnaW4gdGhlIHRleHR1cmUgZmlsbFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7UElYSS5UZXh0dXJlfSBbdGV4dHVyZT1QSVhJLlRleHR1cmUuV0hJVEVdIC0gVGV4dHVyZSB0byBmaWxsXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2NvbG9yPTB4ZmZmZmZmXSAtIEJhY2tncm91bmQgdG8gZmlsbCBiZWhpbmQgdGV4dHVyZVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthbHBoYT0xXSAtIEFscGhhIG9mIGZpbGxcclxuICAgICAqIEBwYXJhbSB7UElYSS5NYXRyaXh9IFttYXRyaXg9bnVsbF0gLSBUcmFuc2Zvcm0gbWF0cml4XHJcbiAgICAgKiBAcmV0dXJuIHtQSVhJLkdyYXBoaWNzfSBUaGlzIEdyYXBoaWNzIG9iamVjdC4gR29vZCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzXHJcbiAgICAgKi9cclxuICAgIGJlZ2luVGV4dHVyZUZpbGwodGV4dHVyZSwgY29sb3IsIGFscGhhLCBtYXRyaXggPSBudWxsKSB7XHJcbiAgICAgICAgaWYgKHRleHR1cmUgPT09IHZvaWQgMCkge1xyXG4gICAgICAgICAgICB0ZXh0dXJlID0gVGV4dHVyZV8xLlRleHR1cmUuV0hJVEU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjb2xvciA9PT0gdm9pZCAwKSB7XHJcbiAgICAgICAgICAgIGNvbG9yID0gMHhGRkZGRkY7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChhbHBoYSA9PT0gdm9pZCAwKSB7XHJcbiAgICAgICAgICAgIGFscGhhID0gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG1hdHJpeCA9PT0gdm9pZCAwKSB7XHJcbiAgICAgICAgICAgIG1hdHJpeCA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRQYXRoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhcnRQb2x5KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciB2aXNpYmxlID0gYWxwaGEgPiAwO1xyXG4gICAgICAgIGlmICghdmlzaWJsZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9maWxsU3R5bGUucmVzZXQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChtYXRyaXgpIHtcclxuICAgICAgICAgICAgICAgIG1hdHJpeCA9IG1hdHJpeC5jbG9uZSgpO1xyXG4gICAgICAgICAgICAgICAgbWF0cml4LmludmVydCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odGhpcy5fZmlsbFN0eWxlLCB7XHJcbiAgICAgICAgICAgICAgICBjb2xvcjogY29sb3IsXHJcbiAgICAgICAgICAgICAgICBhbHBoYTogYWxwaGEsXHJcbiAgICAgICAgICAgICAgICB0ZXh0dXJlOiB0ZXh0dXJlLFxyXG4gICAgICAgICAgICAgICAgbWF0cml4OiBtYXRyaXgsXHJcbiAgICAgICAgICAgICAgICB2aXNpYmxlOiB2aXNpYmxlLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIEFwcGxpZXMgYSBmaWxsIHRvIHRoZSBsaW5lcyBhbmQgc2hhcGVzIHRoYXQgd2VyZSBhZGRlZCBzaW5jZSB0aGUgbGFzdCBjYWxsIHRvIHRoZSBiZWdpbkZpbGwoKSBtZXRob2QuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiB7UElYSS5HcmFwaGljc30gVGhpcyBHcmFwaGljcyBvYmplY3QuIEdvb2QgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxsc1xyXG4gICAgICovXHJcbiAgICBlbmRGaWxsKCkge1xyXG4gICAgICAgIHRoaXMuZmluaXNoUG9seSgpO1xyXG4gICAgICAgIHRoaXMuX2ZpbGxTdHlsZS5yZXNldCgpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBEcmF3cyBhIHJlY3RhbmdsZSBzaGFwZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCAtIFRoZSBYIGNvb3JkIG9mIHRoZSB0b3AtbGVmdCBvZiB0aGUgcmVjdGFuZ2xlXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSAtIFRoZSBZIGNvb3JkIG9mIHRoZSB0b3AtbGVmdCBvZiB0aGUgcmVjdGFuZ2xlXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd2lkdGggLSBUaGUgd2lkdGggb2YgdGhlIHJlY3RhbmdsZVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCAtIFRoZSBoZWlnaHQgb2YgdGhlIHJlY3RhbmdsZVxyXG4gICAgICogQHJldHVybiB7UElYSS5HcmFwaGljc30gVGhpcyBHcmFwaGljcyBvYmplY3QuIEdvb2QgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxsc1xyXG4gICAgICovXHJcbiAgICBkcmF3UmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZHJhd1NoYXBlKG5ldyBSZWN0YW5nbGVfMS5SZWN0YW5nbGUoeCwgeSwgd2lkdGgsIGhlaWdodCkpO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBEcmF3IGEgcmVjdGFuZ2xlIHNoYXBlIHdpdGggcm91bmRlZC9iZXZlbGVkIGNvcm5lcnMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggLSBUaGUgWCBjb29yZCBvZiB0aGUgdG9wLWxlZnQgb2YgdGhlIHJlY3RhbmdsZVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgLSBUaGUgWSBjb29yZCBvZiB0aGUgdG9wLWxlZnQgb2YgdGhlIHJlY3RhbmdsZVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIC0gVGhlIHdpZHRoIG9mIHRoZSByZWN0YW5nbGVcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgLSBUaGUgaGVpZ2h0IG9mIHRoZSByZWN0YW5nbGVcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByYWRpdXMgLSBSYWRpdXMgb2YgdGhlIHJlY3RhbmdsZSBjb3JuZXJzXHJcbiAgICAgKiBAcmV0dXJuIHtQSVhJLkdyYXBoaWNzfSBUaGlzIEdyYXBoaWNzIG9iamVjdC4gR29vZCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzXHJcbiAgICAgKi9cclxuICAgIGRyYXdSb3VuZGVkUmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0LCByYWRpdXMpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5kcmF3U2hhcGUobmV3IFJvdW5kZWRSZWN0YW5nbGVfMS5Sb3VuZGVkUmVjdGFuZ2xlKHgsIHksIHdpZHRoLCBoZWlnaHQsIHJhZGl1cykpO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBEcmF3cyBhIGNpcmNsZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCAtIFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIGNlbnRlciBvZiB0aGUgY2lyY2xlXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSAtIFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIGNlbnRlciBvZiB0aGUgY2lyY2xlXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcmFkaXVzIC0gVGhlIHJhZGl1cyBvZiB0aGUgY2lyY2xlXHJcbiAgICAgKiBAcmV0dXJuIHtQSVhJLkdyYXBoaWNzfSBUaGlzIEdyYXBoaWNzIG9iamVjdC4gR29vZCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzXHJcbiAgICAgKi9cclxuICAgIGRyYXdDaXJjbGUoeCwgeSwgcmFkaXVzKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZHJhd1NoYXBlKG5ldyBDaXJjbGVfMS5DaXJjbGUoeCwgeSwgcmFkaXVzKSk7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIERyYXdzIGFuIGVsbGlwc2UuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggLSBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBjZW50ZXIgb2YgdGhlIGVsbGlwc2VcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgY2VudGVyIG9mIHRoZSBlbGxpcHNlXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd2lkdGggLSBUaGUgaGFsZiB3aWR0aCBvZiB0aGUgZWxsaXBzZVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCAtIFRoZSBoYWxmIGhlaWdodCBvZiB0aGUgZWxsaXBzZVxyXG4gICAgICogQHJldHVybiB7UElYSS5HcmFwaGljc30gVGhpcyBHcmFwaGljcyBvYmplY3QuIEdvb2QgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxsc1xyXG4gICAgICovXHJcbiAgICBkcmF3RWxsaXBzZSh4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZHJhd1NoYXBlKG5ldyBFbGxpcHNlXzEuRWxsaXBzZSh4LCB5LCB3aWR0aCwgaGVpZ2h0KSk7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIERyYXdzIGEgcG9seWdvbiB1c2luZyB0aGUgZ2l2ZW4gcGF0aC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcltdfFBJWEkuUG9pbnRbXXxQSVhJLlBvbHlnb259IHBhdGggLSBUaGUgcGF0aCBkYXRhIHVzZWQgdG8gY29uc3RydWN0IHRoZSBwb2x5Z29uLlxyXG4gICAgICogQHJldHVybiB7UElYSS5HcmFwaGljc30gVGhpcyBHcmFwaGljcyBvYmplY3QuIEdvb2QgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxsc1xyXG4gICAgICovXHJcbiAgICBkcmF3UG9seWdvbihwYXRoKSB7XHJcbiAgICAgICAgdmFyIGFyZ3VtZW50cyQxID0gYXJndW1lbnRzO1xyXG4gICAgICAgIC8vIHByZXZlbnRzIGFuIGFyZ3VtZW50IGFzc2lnbm1lbnQgZGVvcHRcclxuICAgICAgICAvLyBzZWUgc2VjdGlvbiAzLjE6IGh0dHBzOi8vZ2l0aHViLmNvbS9wZXRrYWFudG9ub3YvYmx1ZWJpcmQvd2lraS9PcHRpbWl6YXRpb24ta2lsbGVycyMzLW1hbmFnaW5nLWFyZ3VtZW50c1xyXG4gICAgICAgIHZhciBwb2ludHMgPSBwYXRoO1xyXG4gICAgICAgIHZhciBjbG9zZVN0cm9rZSA9IHRydWU7IC8vICEhdGhpcy5fZmlsbFN0eWxlO1xyXG4gICAgICAgIC8vIGNoZWNrIGlmIGRhdGEgaGFzIHBvaW50cy4uXHJcbiAgICAgICAgaWYgKHBvaW50cy5wb2ludHMpIHtcclxuICAgICAgICAgICAgY2xvc2VTdHJva2UgPSBwb2ludHMuY2xvc2VTdHJva2U7XHJcbiAgICAgICAgICAgIHBvaW50cyA9IHBvaW50cy5wb2ludHM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShwb2ludHMpKSB7XHJcbiAgICAgICAgICAgIC8vIHByZXZlbnRzIGFuIGFyZ3VtZW50IGxlYWsgZGVvcHRcclxuICAgICAgICAgICAgLy8gc2VlIHNlY3Rpb24gMy4yOiBodHRwczovL2dpdGh1Yi5jb20vcGV0a2FhbnRvbm92L2JsdWViaXJkL3dpa2kvT3B0aW1pemF0aW9uLWtpbGxlcnMjMy1tYW5hZ2luZy1hcmd1bWVudHNcclxuICAgICAgICAgICAgcG9pbnRzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgpO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgcG9pbnRzW2ldID0gYXJndW1lbnRzJDFbaV07IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgcHJlZmVyLXJlc3QtcGFyYW1zXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHNoYXBlID0gbmV3IFBvbHlnb25fMS5Qb2x5Z29uKHBvaW50cyk7XHJcbiAgICAgICAgc2hhcGUuY2xvc2VTdHJva2UgPSBjbG9zZVN0cm9rZTtcclxuICAgICAgICB0aGlzLmRyYXdTaGFwZShzaGFwZSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIERyYXcgYW55IHNoYXBlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7UElYSS5DaXJjbGV8UElYSS5FbGxpcHNlfFBJWEkuUG9seWdvbnxQSVhJLlJlY3RhbmdsZXxQSVhJLlJvdW5kZWRSZWN0YW5nbGV9IHNoYXBlIC0gU2hhcGUgdG8gZHJhd1xyXG4gICAgICogQHJldHVybiB7UElYSS5HcmFwaGljc30gVGhpcyBHcmFwaGljcyBvYmplY3QuIEdvb2QgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxsc1xyXG4gICAgICovXHJcbiAgICBkcmF3U2hhcGUoc2hhcGUpIHtcclxuICAgICAgICBpZiAoIXRoaXMuX2hvbGVNb2RlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZ2VvbWV0cnkuZHJhd1NoYXBlKHNoYXBlLCB0aGlzLl9maWxsU3R5bGUuY2xvbmUoKSwgdGhpcy5fbGluZVN0eWxlLmNsb25lKCksIHRoaXMuX21hdHJpeCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmdlb21ldHJ5LmRyYXdIb2xlKHNoYXBlLCB0aGlzLl9tYXRyaXgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogRHJhdyBhIHN0YXIgc2hhcGUgd2l0aCBhbiBhcmJpdHJhcnkgbnVtYmVyIG9mIHBvaW50cy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCAtIENlbnRlciBYIHBvc2l0aW9uIG9mIHRoZSBzdGFyXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSAtIENlbnRlciBZIHBvc2l0aW9uIG9mIHRoZSBzdGFyXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcG9pbnRzIC0gVGhlIG51bWJlciBvZiBwb2ludHMgb2YgdGhlIHN0YXIsIG11c3QgYmUgPiAxXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcmFkaXVzIC0gVGhlIG91dGVyIHJhZGl1cyBvZiB0aGUgc3RhclxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtpbm5lclJhZGl1c10gLSBUaGUgaW5uZXIgcmFkaXVzIGJldHdlZW4gcG9pbnRzLCBkZWZhdWx0IGhhbGYgYHJhZGl1c2BcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcm90YXRpb249MF0gLSBUaGUgcm90YXRpb24gb2YgdGhlIHN0YXIgaW4gcmFkaWFucywgd2hlcmUgMCBpcyB2ZXJ0aWNhbFxyXG4gICAgICogQHJldHVybiB7UElYSS5HcmFwaGljc30gVGhpcyBHcmFwaGljcyBvYmplY3QuIEdvb2QgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxsc1xyXG4gICAgICovXHJcbiAgICBkcmF3U3Rhcih4LCB5LCBwb2ludHMsIHJhZGl1cywgaW5uZXJSYWRpdXMgPSAwLCByb3RhdGlvbiA9IDApIHtcclxuICAgICAgICBpZiAocm90YXRpb24gPT09IHZvaWQgMCkge1xyXG4gICAgICAgICAgICByb3RhdGlvbiA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLmRyYXdQb2x5Z29uKG5ldyBTdGFyXzEuU3Rhcih4LCB5LCBwb2ludHMsIHJhZGl1cywgaW5uZXJSYWRpdXMsIHJvdGF0aW9uKSk7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIENsZWFycyB0aGUgZ3JhcGhpY3MgdGhhdCB3ZXJlIGRyYXduIHRvIHRoaXMgR3JhcGhpY3Mgb2JqZWN0LCBhbmQgcmVzZXRzIGZpbGwgYW5kIGxpbmUgc3R5bGUgc2V0dGluZ3MuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiB7UElYSS5HcmFwaGljc30gVGhpcyBHcmFwaGljcyBvYmplY3QuIEdvb2QgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxsc1xyXG4gICAgICovXHJcbiAgICBjbGVhcigpIHtcclxuICAgICAgICB0aGlzLmdlb21ldHJ5LmNsZWFyKCk7XHJcbiAgICAgICAgdGhpcy5fbWF0cml4ID0gbnVsbDtcclxuICAgICAgICB0aGlzLl9ob2xlTW9kZSA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuY3VycmVudFBhdGggPSBudWxsO1xyXG4gICAgICAgIHRoaXMuX3Nwcml0ZVJlY3QgPSBudWxsO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUcnVlIGlmIGdyYXBoaWNzIGNvbnNpc3RzIG9mIG9uZSByZWN0YW5nbGUsIGFuZCB0aHVzLCBjYW4gYmUgZHJhd24gbGlrZSBhIFNwcml0ZSBhbmRcclxuICAgICAqIG1hc2tlZCB3aXRoIGdsLnNjaXNzb3IuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgb25seSAxIHJlY3QuXHJcbiAgICAgKi9cclxuICAgIGlzRmFzdFJlY3QoKSB7XHJcbiAgICAgICAgLy8gd2lsbCBmaXggdGhpcyFcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgLy8gdGhpcy5ncmFwaGljc0RhdGEubGVuZ3RoID09PSAxXHJcbiAgICAgICAgLy8gICYmIHRoaXMuZ3JhcGhpY3NEYXRhWzBdLnNoYXBlLnR5cGUgPT09IFNIQVBFUy5SRUNUXHJcbiAgICAgICAgLy8gJiYgIXRoaXMuZ3JhcGhpY3NEYXRhWzBdLmxpbmVXaWR0aDtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogUmVuZGVycyB0aGUgb2JqZWN0IHVzaW5nIHRoZSBXZWJHTCByZW5kZXJlclxyXG4gICAgICpcclxuICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAqIEBwYXJhbSB7UElYSS5SZW5kZXJlcn0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXJcclxuICAgICAqL1xyXG4gICAgX3JlbmRlcihyZW5kZXJlcikge1xyXG4gICAgICAgIHRoaXMuZmluaXNoUG9seSgpO1xyXG4gICAgICAgIHZhciBnZW9tZXRyeSA9IHRoaXMuZ2VvbWV0cnk7XHJcbiAgICAgICAgLy8gYmF0Y2ggcGFydC4uXHJcbiAgICAgICAgLy8gYmF0Y2ggaXQhXHJcbiAgICAgICAgZ2VvbWV0cnkudXBkYXRlQmF0Y2hlcygpO1xyXG4gICAgICAgIGlmIChnZW9tZXRyeS5iYXRjaGFibGUpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuYmF0Y2hEaXJ0eSAhPT0gZ2VvbWV0cnkuYmF0Y2hEaXJ0eSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5iYXRjaGVzID0gW107XHJcbiAgICAgICAgICAgICAgICB0aGlzLmJhdGNoVGludCA9IC0xO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdHJhbnNmb3JtSUQgPSAtMTtcclxuICAgICAgICAgICAgICAgIHRoaXMuYmF0Y2hEaXJ0eSA9IGdlb21ldHJ5LmJhdGNoRGlydHk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnZlcnRleERhdGEgPSBuZXcgRmxvYXQzMkFycmF5KGdlb21ldHJ5LnBvaW50cyk7XHJcbiAgICAgICAgICAgICAgICB2YXIgYmxlbmRNb2RlID0gdGhpcy5ibGVuZE1vZGU7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdlb21ldHJ5LmJhdGNoZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZ0kgPSBnZW9tZXRyeS5iYXRjaGVzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb2xvciA9IGdJLnN0eWxlLmNvbG9yO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgICArIChhbHBoYSAqIDI1NSA8PCAyNCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZlcnRleERhdGEgPSBuZXcgRmxvYXQzMkFycmF5KHRoaXMudmVydGV4RGF0YS5idWZmZXIsIGdJLmF0dHJpYlN0YXJ0ICogNCAqIDIsIGdJLmF0dHJpYlNpemUgKiAyKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgdXZzID0gbmV3IEZsb2F0MzJBcnJheShnZW9tZXRyeS51dnNGbG9hdDMyLmJ1ZmZlciwgZ0kuYXR0cmliU3RhcnQgKiA0ICogMiwgZ0kuYXR0cmliU2l6ZSAqIDIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRpY2VzID0gbmV3IFVpbnQxNkFycmF5KGdlb21ldHJ5LmluZGljZXNVaW50MTYuYnVmZmVyLCBnSS5zdGFydCAqIDIsIGdJLnNpemUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBiYXRjaCA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmVydGV4RGF0YTogdmVydGV4RGF0YSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYmxlbmRNb2RlOiBibGVuZE1vZGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGljZXM6IGluZGljZXMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHV2czogdXZzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfYmF0Y2hSR0I6IENvbG9yU2V0dGluZ3NfMS5Db2xvclNldHRpbmdzLmhleDJyZ2IoY29sb3IpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGludFJHQjogY29sb3IsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90ZXh0dXJlOiBnSS5zdHlsZS50ZXh0dXJlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhbHBoYTogZ0kuc3R5bGUuYWxwaGEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdvcmxkQWxwaGE6IDFcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYmF0Y2hlc1tpXSA9IGJhdGNoO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJlbmRlcmVyLmJhdGNoLnNldE9iamVjdFJlbmRlcmVyKHJlbmRlcmVyLnBsdWdpbnMuYmF0Y2gpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5iYXRjaGVzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jYWxjdWxhdGVWZXJ0aWNlcygpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jYWxjdWxhdGVUaW50cygpO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgdGhpcy5iYXRjaGVzLmxlbmd0aDsgaSQxKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYmF0Y2gkMSA9IHRoaXMuYmF0Y2hlc1tpJDFdO1xyXG4gICAgICAgICAgICAgICAgICAgIGJhdGNoJDEud29ybGRBbHBoYSA9IHRoaXMud29ybGRBbHBoYSAqIGJhdGNoJDEuYWxwaGE7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyZXIucGx1Z2lucy5iYXRjaC5yZW5kZXIoYmF0Y2gkMSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIG5vIGJhdGNoaW5nLi4uXHJcbiAgICAgICAgICAgIHJlbmRlcmVyLmJhdGNoLmZsdXNoKCk7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5zaGFkZXIpIHtcclxuICAgICAgICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIG5vIHNoYWRlciBoZXJlLCB3ZSBjYW4gdXNlIHRoZSBkZWZhdWx0IHNoYWRlci5cclxuICAgICAgICAgICAgICAgIC8vIGFuZCB0aGF0IG9ubHkgZ2V0cyBjcmVhdGVkIGlmIHdlIGFjdHVhbGx5IG5lZWQgaXQuLlxyXG4gICAgICAgICAgICAgICAgaWYgKCFHcmFwaGljcy5kZWZhdWx0U2hhZGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNhbXBsZVZhbHVlcyA9IG5ldyBJbnQzMkFycmF5KDE2KTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpJDIgPSAwOyBpJDIgPCAxNjsgaSQyKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2FtcGxlVmFsdWVzW2kkMl0gPSBpJDI7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciB1bmlmb3JtcyA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGludDogbmV3IEZsb2F0MzJBcnJheShbMSwgMSwgMSwgMV0pLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2xhdGlvbk1hdHJpeDogbmV3IE1hdHJpeF8xLk1hdHJpeCgpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OiBVbmlmb3JtR3JvdXBfMS5Vbmlmb3JtR3JvdXAuZnJvbSh7IHVTYW1wbGVyczogc2FtcGxlVmFsdWVzIH0sIHRydWUpLFxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gd2UgY2FuIGJiYXNlIGRlZmF1bHQgc2hhZGVyIG9mIHRoZSBiYXRjaCByZW5kZXJlcnMgcHJvZ3JhbVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwcm9ncmFtID0gcmVuZGVyZXIucGx1Z2lucy5iYXRjaC5zaGFkZXIucHJvZ3JhbTtcclxuICAgICAgICAgICAgICAgICAgICBHcmFwaGljcy5kZWZhdWx0U2hhZGVyID0gbmV3IFNoYWRlcl8xLlNoYWRlcihwcm9ncmFtLCB1bmlmb3Jtcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNoYWRlciA9IEdyYXBoaWNzLmRlZmF1bHRTaGFkZXI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHVuaWZvcm1zJDEgPSB0aGlzLnNoYWRlci51bmlmb3JtcztcclxuICAgICAgICAgICAgLy8gbGV0cyBzZXQgdGhlIHRyYW5zZm9tclxyXG4gICAgICAgICAgICB1bmlmb3JtcyQxLnRyYW5zbGF0aW9uTWF0cml4ID0gdGhpcy50cmFuc2Zvcm0ud29ybGRUcmFuc2Zvcm07XHJcbiAgICAgICAgICAgIHZhciB0aW50ID0gdGhpcy50aW50O1xyXG4gICAgICAgICAgICB2YXIgd2EgPSB0aGlzLndvcmxkQWxwaGE7XHJcbiAgICAgICAgICAgIC8vIGFuZCB0aGVuIGxldHMgc2V0IHRoZSB0aW50Li5cclxuICAgICAgICAgICAgdW5pZm9ybXMkMS50aW50WzBdID0gKCgodGludCA+PiAxNikgJiAweEZGKSAvIDI1NSkgKiB3YTtcclxuICAgICAgICAgICAgdW5pZm9ybXMkMS50aW50WzFdID0gKCgodGludCA+PiA4KSAmIDB4RkYpIC8gMjU1KSAqIHdhO1xyXG4gICAgICAgICAgICB1bmlmb3JtcyQxLnRpbnRbMl0gPSAoKHRpbnQgJiAweEZGKSAvIDI1NSkgKiB3YTtcclxuICAgICAgICAgICAgdW5pZm9ybXMkMS50aW50WzNdID0gd2E7XHJcbiAgICAgICAgICAgIC8vIHRoZSBmaXJzdCBkcmF3IGNhbGwsIHdlIGNhbiBzZXQgdGhlIHVuaWZvcm1zIG9mIHRoZSBzaGFkZXIgZGlyZWN0bHkgaGVyZS5cclxuICAgICAgICAgICAgLy8gdGhpcyBtZWFucyB0aGF0IHdlIGNhbiB0YWNrIGFkdmFudGFnZSBvZiB0aGUgc3luYyBmdW5jdGlvbiBvZiBwaXhpIVxyXG4gICAgICAgICAgICAvLyBiaW5kIGFuZCBzeW5jIHVuaWZvcm1zLi5cclxuICAgICAgICAgICAgLy8gdGhlcmUgaXMgYSB3YXkgdG8gb3B0aW1pc2UgdGhpcy4uXHJcbiAgICAgICAgICAgIHJlbmRlcmVyLnNoYWRlci5iaW5kKHRoaXMuc2hhZGVyKTtcclxuICAgICAgICAgICAgLy8gdGhlbiByZW5kZXIgaXRcclxuICAgICAgICAgICAgcmVuZGVyZXIuZ2VvbWV0cnkuYmluZChnZW9tZXRyeSwgdGhpcy5zaGFkZXIpO1xyXG4gICAgICAgICAgICAvLyBzZXQgc3RhdGUuLlxyXG4gICAgICAgICAgICByZW5kZXJlci5zdGF0ZS5zZXRTdGF0ZSh0aGlzLnN0YXRlKTtcclxuICAgICAgICAgICAgLy8gdGhlbiByZW5kZXIgdGhlIHJlc3Qgb2YgdGhlbS4uLlxyXG4gICAgICAgICAgICBmb3IgKHZhciBpJDMgPSAwOyBpJDMgPCBnZW9tZXRyeS5kcmF3Q2FsbHMubGVuZ3RoOyBpJDMrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGRyYXdDYWxsID0gZ2VvbWV0cnkuZHJhd0NhbGxzW2kkM107XHJcbiAgICAgICAgICAgICAgICB2YXIgZ3JvdXBUZXh0dXJlQ291bnQgPSBkcmF3Q2FsbC50ZXh0dXJlQ291bnQ7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGdyb3VwVGV4dHVyZUNvdW50OyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICByZW5kZXJlci50ZXh0dXJlLmJpbmQoZHJhd0NhbGwudGV4dHVyZXNbal0sIGopO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gYmluZCB0aGUgZ2VvbWV0cnkuLi5cclxuICAgICAgICAgICAgICAgIHJlbmRlcmVyLmdlb21ldHJ5LmRyYXcoZHJhd0NhbGwudHlwZSwgZHJhd0NhbGwuc2l6ZSwgZHJhd0NhbGwuc3RhcnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIGJvdW5kcyBvZiB0aGUgZ3JhcGhpYyBzaGFwZSBhcyBhIHJlY3RhbmdsZSBvYmplY3RcclxuICAgICAqXHJcbiAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgKi9cclxuICAgIF9jYWxjdWxhdGVCb3VuZHMoKSB7XHJcbiAgICAgICAgdGhpcy5maW5pc2hQb2x5KCk7XHJcbiAgICAgICAgdmFyIGxiID0gdGhpcy5nZW9tZXRyeS5ib3VuZHM7XHJcbiAgICAgICAgdGhpcy5fYm91bmRzLmFkZEZyYW1lKHRoaXMudHJhbnNmb3JtLCBsYi5taW5YLCBsYi5taW5ZLCBsYi5tYXhYLCBsYi5tYXhZKTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogVGVzdHMgaWYgYSBwb2ludCBpcyBpbnNpZGUgdGhpcyBncmFwaGljcyBvYmplY3RcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1BJWEkuUG9pbnR9IHBvaW50IC0gdGhlIHBvaW50IHRvIHRlc3RcclxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IHRoZSByZXN1bHQgb2YgdGhlIHRlc3RcclxuICAgICAqL1xyXG4gICAgY29udGFpbnNQb2ludChwb2ludCkge1xyXG4gICAgICAgIHRoaXMud29ybGRUcmFuc2Zvcm0uYXBwbHlJbnZlcnNlKHBvaW50LCBHcmFwaGljcy5fVEVNUF9QT0lOVCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2VvbWV0cnkuY29udGFpbnNQb2ludChHcmFwaGljcy5fVEVNUF9QT0lOVCk7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFJlY2FsY3VhdGUgdGhlIHRpbnQgYnkgYXBwbHlpbmcgdGluIHRvIGJhdGNoZXMgdXNpbmcgR3JhcGhpY3MgdGludC5cclxuICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAqL1xyXG4gICAgY2FsY3VsYXRlVGludHMoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuYmF0Y2hUaW50ICE9PSB0aGlzLnRpbnQpIHtcclxuICAgICAgICAgICAgdGhpcy5iYXRjaFRpbnQgPSB0aGlzLnRpbnQ7XHJcbiAgICAgICAgICAgIHZhciB0aW50UkdCID0gQ29sb3JTZXR0aW5nc18xLkNvbG9yU2V0dGluZ3MuaGV4MnJnYih0aGlzLnRpbnQsIEdyYXBoaWNzLnRlbXApO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYmF0Y2hlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGJhdGNoID0gdGhpcy5iYXRjaGVzW2ldO1xyXG4gICAgICAgICAgICAgICAgdmFyIGJhdGNoVGludCA9IGJhdGNoLl9iYXRjaFJHQjtcclxuICAgICAgICAgICAgICAgIHZhciByID0gKHRpbnRSR0JbMF0gKiBiYXRjaFRpbnRbMF0pICogMjU1O1xyXG4gICAgICAgICAgICAgICAgdmFyIGcgPSAodGludFJHQlsxXSAqIGJhdGNoVGludFsxXSkgKiAyNTU7XHJcbiAgICAgICAgICAgICAgICB2YXIgYiA9ICh0aW50UkdCWzJdICogYmF0Y2hUaW50WzJdKSAqIDI1NTtcclxuICAgICAgICAgICAgICAgIC8vIFRPRE8gSXZhbiwgY2FuIHRoaXMgYmUgZG9uZSBpbiBvbmUgZ28/XHJcbiAgICAgICAgICAgICAgICB2YXIgY29sb3IgPSAociA8PCAxNikgKyAoZyA8PCA4KSArIChiIHwgMCk7XHJcbiAgICAgICAgICAgICAgICBiYXRjaC5fdGludFJHQiA9IChjb2xvciA+PiAxNilcclxuICAgICAgICAgICAgICAgICAgICArIChjb2xvciAmIDB4ZmYwMClcclxuICAgICAgICAgICAgICAgICAgICArICgoY29sb3IgJiAweGZmKSA8PCAxNik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIElmIHRoZXJlJ3MgYSB0cmFuc2Zvcm0gdXBkYXRlIG9yIGEgY2hhbmdlIHRvIHRoZSBzaGFwZSBvZiB0aGVcclxuICAgICAqIGdlb21ldHJ5LCByZWNhY3VsYXRlIHRoZSB2ZXJ0aWNlcy5cclxuICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAqL1xyXG4gICAgY2FsY3VsYXRlVmVydGljZXMoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3RyYW5zZm9ybUlEID09PSB0aGlzLnRyYW5zZm9ybS5fd29ybGRJRCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3RyYW5zZm9ybUlEID0gdGhpcy50cmFuc2Zvcm0uX3dvcmxkSUQ7XHJcbiAgICAgICAgdmFyIHd0ID0gdGhpcy50cmFuc2Zvcm0ud29ybGRUcmFuc2Zvcm07XHJcbiAgICAgICAgLy8gcmV2ZWFsKHd0KVxyXG4gICAgICAgIHZhciBhID0gd3QuYTtcclxuICAgICAgICB2YXIgYiA9IHd0LmI7XHJcbiAgICAgICAgdmFyIGMgPSB3dC5jO1xyXG4gICAgICAgIHZhciBkID0gd3QuZDtcclxuICAgICAgICB2YXIgdHggPSB3dC50eDtcclxuICAgICAgICB2YXIgdHkgPSB3dC50eTtcclxuICAgICAgICB2YXIgZGF0YSA9IHRoaXMuZ2VvbWV0cnkucG9pbnRzOyAvLyBiYXRjaC52ZXJ0ZXhEYXRhT3JpZ2luYWw7XHJcbiAgICAgICAgdmFyIHZlcnRleERhdGEgPSB0aGlzLnZlcnRleERhdGE7XHJcbiAgICAgICAgdmFyIGNvdW50ID0gMDtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpICs9IDIpIHtcclxuICAgICAgICAgICAgdmFyIHggPSBkYXRhW2ldO1xyXG4gICAgICAgICAgICB2YXIgeSA9IGRhdGFbaSArIDFdO1xyXG4gICAgICAgICAgICB2ZXJ0ZXhEYXRhW2NvdW50KytdID0gKGEgKiB4KSArIChjICogeSkgKyB0eDtcclxuICAgICAgICAgICAgdmVydGV4RGF0YVtjb3VudCsrXSA9IChkICogeSkgKyAoYiAqIHgpICsgdHk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDbG9zZXMgdGhlIGN1cnJlbnQgcGF0aC5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIHtQSVhJLkdyYXBoaWNzfSBSZXR1cm5zIGl0c2VsZi5cclxuICAgICAqL1xyXG4gICAgY2xvc2VQYXRoKCkge1xyXG4gICAgICAgIHZhciBjdXJyZW50UGF0aCA9IHRoaXMuY3VycmVudFBhdGg7XHJcbiAgICAgICAgaWYgKGN1cnJlbnRQYXRoKSB7XHJcbiAgICAgICAgICAgIC8vIHdlIGRvbid0IG5lZWQgdG8gYWRkIGV4dHJhIHBvaW50IGluIHRoZSBlbmQgYmVjYXVzZSBidWlsZExpbmUgd2lsbCB0YWtlIGNhcmUgb2YgdGhhdFxyXG4gICAgICAgICAgICBjdXJyZW50UGF0aC5jbG9zZVN0cm9rZSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBseSBhIG1hdHJpeCB0byB0aGUgcG9zaXRpb25hbCBkYXRhLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7UElYSS5NYXRyaXh9IG1hdHJpeCAtIE1hdHJpeCB0byB1c2UgZm9yIHRyYW5zZm9ybSBjdXJyZW50IHNoYXBlLlxyXG4gICAgICogQHJldHVybiB7UElYSS5HcmFwaGljc30gUmV0dXJucyBpdHNlbGYuXHJcbiAgICAgKi9cclxuICAgIHNldE1hdHJpeChtYXRyaXgpIHtcclxuICAgICAgICB0aGlzLl9tYXRyaXggPSBtYXRyaXg7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIEJlZ2luIGFkZGluZyBob2xlcyB0byB0aGUgbGFzdCBkcmF3IHNoYXBlXHJcbiAgICAgKiBJTVBPUlRBTlQ6IGhvbGVzIG11c3QgYmUgZnVsbHkgaW5zaWRlIGEgc2hhcGUgdG8gd29ya1xyXG4gICAgICogQWxzbyB3ZWlyZG5lc3MgZW5zdWVzIGlmIGhvbGVzIG92ZXJsYXAhXHJcbiAgICAgKiBFbGxpcHNlcywgQ2lyY2xlcywgUmVjdGFuZ2xlcyBhbmQgUm91bmRlZCBSZWN0YW5nbGVzIGNhbm5vdCBiZSBob2xlcyBvciBob3N0IGZvciBob2xlcyBpbiBDYW52YXNSZW5kZXJlcixcclxuICAgICAqIHBsZWFzZSB1c2UgYG1vdmVUb2AgYGxpbmVUb2AsIGBxdWFkcmF0aWNDdXJ2ZVRvYCBpZiB5b3UgcmVseSBvbiBwaXhpLWxlZ2FjeSBidW5kbGUuXHJcbiAgICAgKiBAcmV0dXJuIHtQSVhJLkdyYXBoaWNzfSBSZXR1cm5zIGl0c2VsZi5cclxuICAgICAqL1xyXG4gICAgYmVnaW5Ib2xlKCkge1xyXG4gICAgICAgIHRoaXMuZmluaXNoUG9seSgpO1xyXG4gICAgICAgIHRoaXMuX2hvbGVNb2RlID0gdHJ1ZTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogRW5kIGFkZGluZyBob2xlcyB0byB0aGUgbGFzdCBkcmF3IHNoYXBlXHJcbiAgICAgKiBAcmV0dXJuIHtQSVhJLkdyYXBoaWNzfSBSZXR1cm5zIGl0c2VsZi5cclxuICAgICAqL1xyXG4gICAgZW5kSG9sZSgpIHtcclxuICAgICAgICB0aGlzLmZpbmlzaFBvbHkoKTtcclxuICAgICAgICB0aGlzLl9ob2xlTW9kZSA9IGZhbHNlO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBEZXN0cm95cyB0aGUgR3JhcGhpY3Mgb2JqZWN0LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fGJvb2xlYW59IFtvcHRpb25zXSAtIE9wdGlvbnMgcGFyYW1ldGVyLiBBIGJvb2xlYW4gd2lsbCBhY3QgYXMgaWYgYWxsXHJcbiAgICAgKiAgb3B0aW9ucyBoYXZlIGJlZW4gc2V0IHRvIHRoYXQgdmFsdWVcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuY2hpbGRyZW49ZmFsc2VdIC0gaWYgc2V0IHRvIHRydWUsIGFsbCB0aGUgY2hpbGRyZW4gd2lsbCBoYXZlXHJcbiAgICAgKiAgdGhlaXIgZGVzdHJveSBtZXRob2QgY2FsbGVkIGFzIHdlbGwuICdvcHRpb25zJyB3aWxsIGJlIHBhc3NlZCBvbiB0byB0aG9zZSBjYWxscy5cclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudGV4dHVyZT1mYWxzZV0gLSBPbmx5IHVzZWQgZm9yIGNoaWxkIFNwcml0ZXMgaWYgb3B0aW9ucy5jaGlsZHJlbiBpcyBzZXQgdG8gdHJ1ZVxyXG4gICAgICogIFNob3VsZCBpdCBkZXN0cm95IHRoZSB0ZXh0dXJlIG9mIHRoZSBjaGlsZCBzcHJpdGVcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuYmFzZVRleHR1cmU9ZmFsc2VdIC0gT25seSB1c2VkIGZvciBjaGlsZCBTcHJpdGVzIGlmIG9wdGlvbnMuY2hpbGRyZW4gaXMgc2V0IHRvIHRydWVcclxuICAgICAqICBTaG91bGQgaXQgZGVzdHJveSB0aGUgYmFzZSB0ZXh0dXJlIG9mIHRoZSBjaGlsZCBzcHJpdGVcclxuICAgICAqL1xyXG4gICAgZGVzdHJveShvcHRpb25zKSB7XHJcbiAgICAgICAgc3VwZXIuZGVzdHJveShvcHRpb25zKTtcclxuICAgICAgICB0aGlzLmdlb21ldHJ5LnJlZkNvdW50LS07XHJcbiAgICAgICAgaWYgKHRoaXMuZ2VvbWV0cnkucmVmQ291bnQgPT09IDApIHtcclxuICAgICAgICAgICAgdGhpcy5nZW9tZXRyeS5kaXNwb3NlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX21hdHJpeCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50UGF0aCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5fbGluZVN0eWxlLmRlc3Ryb3koKTtcclxuICAgICAgICB0aGlzLl9saW5lU3R5bGUgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuX2ZpbGxTdHlsZS5kZXN0cm95KCk7XHJcbiAgICAgICAgdGhpcy5fZmlsbFN0eWxlID0gbnVsbDtcclxuICAgICAgICB0aGlzLmdlb21ldHJ5ID0gbnVsbDtcclxuICAgICAgICB0aGlzLnNoYWRlciA9IG51bGw7XHJcbiAgICAgICAgdGhpcy52ZXJ0ZXhEYXRhID0gbnVsbDtcclxuICAgICAgICB0aGlzLmJhdGNoZXMubGVuZ3RoID0gMDtcclxuICAgICAgICB0aGlzLmJhdGNoZXMgPSBudWxsO1xyXG4gICAgICAgIHN1cGVyLmRlc3Ryb3kob3B0aW9ucyk7XHJcbiAgICB9XHJcbiAgICA7XHJcbn1cclxuR3JhcGhpY3MudGVtcCA9IG5ldyBGbG9hdDMyQXJyYXkoWzEsIDEsIDFdKTtcclxuR3JhcGhpY3MuZGVmYXVsdFNoYWRlciA9IG51bGw7XHJcbi8qKlxyXG4qIFRlbXBvcmFyeSBwb2ludCB0byB1c2UgZm9yIGNvbnRhaW5zUG9pbnRcclxuKlxyXG4qIEBzdGF0aWNcclxuKiBAcHJpdmF0ZVxyXG4qIEBtZW1iZXIge1BJWEkuUG9pbnR9XHJcbiovXHJcbkdyYXBoaWNzLl9URU1QX1BPSU5UID0gbmV3IFBvaW50XzEuUG9pbnQoKTtcclxuZXhwb3J0cy5HcmFwaGljcyA9IEdyYXBoaWNzO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jbGFzcyBHcmFwaGljc0RhdGEge1xyXG4gICAgY29uc3RydWN0b3Ioc2hhcGUsIGZpbGxTdHlsZSA9IG51bGwsIGxpbmVTdHlsZSA9IG51bGwsIG1hdHJpeCA9IG51bGwpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgc2hhcGUgb2JqZWN0IHRvIGRyYXcuXHJcbiAgICAgICAgICogQG1lbWJlciB7UElYSS5DaXJjbGV8UElYSS5FbGxpcHNlfFBJWEkuUG9seWdvbnxQSVhJLlJlY3RhbmdsZXxQSVhJLlJvdW5kZWRSZWN0YW5nbGV9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5zaGFwZSA9IHNoYXBlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBzdHlsZSBvZiB0aGUgbGluZS5cclxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLkxpbmVTdHlsZX1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmxpbmVTdHlsZSA9IGxpbmVTdHlsZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgc3R5bGUgb2YgdGhlIGZpbGwuXHJcbiAgICAgICAgICogQG1lbWJlciB7UElYSS5GaWxsU3R5bGV9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5maWxsU3R5bGUgPSBmaWxsU3R5bGU7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIHRyYW5zZm9ybSBtYXRyaXguXHJcbiAgICAgICAgICogQG1lbWJlciB7UElYSS5NYXRyaXh9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5tYXRyaXggPSBtYXRyaXg7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIHR5cGUgb2YgdGhlIHNoYXBlLCBzZWUgdGhlIENvbnN0LlNoYXBlcyBmaWxlIGZvciBhbGwgdGhlIGV4aXN0aW5nIHR5cGVzLFxyXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnR5cGUgPSBzaGFwZS50eXBlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBjb2xsZWN0aW9uIG9mIHBvaW50cy5cclxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJbXX1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnBvaW50cyA9IFtdO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBjb2xsZWN0aW9uIG9mIGhvbGVzLlxyXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuR3JhcGhpY3NEYXRhW119XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5ob2xlcyA9IFtdO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IEdyYXBoaWNzRGF0YSBvYmplY3Qgd2l0aCB0aGUgc2FtZSB2YWx1ZXMgYXMgdGhpcyBvbmUuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiB7UElYSS5HcmFwaGljc0RhdGF9IENsb25lZCBHcmFwaGljc0RhdGEgb2JqZWN0XHJcbiAgICAgKi9cclxuICAgIGNsb25lKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgR3JhcGhpY3NEYXRhKHRoaXMuc2hhcGUsIHRoaXMuZmlsbFN0eWxlLCB0aGlzLmxpbmVTdHlsZSwgdGhpcy5tYXRyaXgpO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBEZXN0cm95cyB0aGUgR3JhcGhpY3MgZGF0YS5cclxuICAgICAqL1xyXG4gICAgZGVzdHJveSgpIHtcclxuICAgICAgICB0aGlzLnNoYXBlID0gbnVsbDtcclxuICAgICAgICB0aGlzLmhvbGVzLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgdGhpcy5ob2xlcyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5wb2ludHMubGVuZ3RoID0gMDtcclxuICAgICAgICB0aGlzLnBvaW50cyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5saW5lU3R5bGUgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuZmlsbFN0eWxlID0gbnVsbDtcclxuICAgIH1cclxuICAgIDtcclxufVxyXG5leHBvcnRzLkdyYXBoaWNzRGF0YSA9IEdyYXBoaWNzRGF0YTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgQmF0Y2hHZW9tZXRyeV8xID0gcmVxdWlyZShcIi4vQmF0Y2hHZW9tZXRyeVwiKTtcclxuY29uc3QgQm91bmRzXzEgPSByZXF1aXJlKFwiLi9Cb3VuZHNcIik7XHJcbmNvbnN0IEdyYXBoaWNzRGF0YV8xID0gcmVxdWlyZShcIi4vR3JhcGhpY3NEYXRhXCIpO1xyXG5jb25zdCBCYXNlVGV4dHVyZV8xID0gcmVxdWlyZShcIi4vQmFzZVRleHR1cmVcIik7XHJcbmNvbnN0IEJhdGNoRHJhd0NhbGxfMSA9IHJlcXVpcmUoXCIuL0JhdGNoRHJhd0NhbGxcIik7XHJcbmNvbnN0IFBvaW50XzEgPSByZXF1aXJlKFwiLi9Qb2ludFwiKTtcclxuY29uc3QgU2hhcGVTZXR0aW5nc18xID0gcmVxdWlyZShcIi4vU2hhcGVTZXR0aW5nc1wiKTtcclxuY29uc3QgRHJhd01vZGVTZXR0aW5nc18xID0gcmVxdWlyZShcIi4vRHJhd01vZGVTZXR0aW5nc1wiKTtcclxuY29uc3QgQ29sb3JTZXR0aW5nc18xID0gcmVxdWlyZShcIi4vQ29sb3JTZXR0aW5nc1wiKTtcclxuY2xhc3MgQmF0Y2hQYXJ0IHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMuc3R5bGUgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuc2l6ZSA9IDA7XHJcbiAgICAgICAgdGhpcy5zdGFydCA9IDA7XHJcbiAgICAgICAgdGhpcy5hdHRyaWJTdGFydCA9IDA7XHJcbiAgICAgICAgdGhpcy5hdHRyaWJTaXplID0gMDtcclxuICAgIH1cclxufVxyXG5jbGFzcyBHcmFwaGljc0dlb21ldHJ5IGV4dGVuZHMgQmF0Y2hHZW9tZXRyeV8xLkJhdGNoR2VvbWV0cnkge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBbiBhcnJheSBvZiBwb2ludHMgdG8gZHJhd1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQG1lbWJlciB7UElYSS5Qb2ludFtdfVxyXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnBvaW50cyA9IFtdO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBjb2xsZWN0aW9uIG9mIGNvbG9yc1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyW119XHJcbiAgICAgICAgICogQHByb3RlY3RlZFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuY29sb3JzID0gW107XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIFVWcyBjb2xsZWN0aW9uXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJbXX1cclxuICAgICAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy51dnMgPSBbXTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgaW5kaWNlcyBvZiB0aGUgdmVydGljZXNcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcltdfVxyXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmluZGljZXMgPSBbXTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZWZlcmVuY2UgdG8gdGhlIHRleHR1cmUgSURzLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyW119XHJcbiAgICAgICAgICogQHByb3RlY3RlZFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMudGV4dHVyZUlkcyA9IFtdO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBjb2xsZWN0aW9uIG9mIGRyYXduIHNoYXBlcy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuR3JhcGhpY3NEYXRhW119XHJcbiAgICAgICAgICogQHByb3RlY3RlZFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuZ3JhcGhpY3NEYXRhID0gW107XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVXNlZCB0byBkZXRlY3QgaWYgdGhlIGdyYXBoaWNzIG9iamVjdCBoYXMgY2hhbmdlZC4gSWYgdGhpcyBpcyBzZXQgdG8gdHJ1ZSB0aGVuIHRoZSBncmFwaGljc1xyXG4gICAgICAgICAqIG9iamVjdCB3aWxsIGJlIHJlY2FsY3VsYXRlZC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5kaXJ0eSA9IDA7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQmF0Y2hlcyBuZWVkIHRvIHJlZ2VuZXJhdGVkIGlmIHRoZSBnZW9tZXRyeSBpcyB1cGRhdGVkLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmJhdGNoRGlydHkgPSAtMTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBVc2VkIHRvIGNoZWNrIGlmIHRoZSBjYWNoZSBpcyBkaXJ0eS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5jYWNoZURpcnR5ID0gLTE7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVXNlZCB0byBkZXRlY3QgaWYgd2UgY2xlYXIgdGhlIGdyYXBoaWNzIFdlYkdMIGRhdGEuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgICAgICogQGRlZmF1bHQgMFxyXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmNsZWFyRGlydHkgPSAwO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIExpc3Qgb2YgY3VycmVudCBkcmF3IGNhbGxzIGRyaXZlZCBmcm9tIHRoZSBiYXRjaGVzLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQG1lbWJlciB7b2JqZWN0W119XHJcbiAgICAgICAgICogQHByb3RlY3RlZFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuZHJhd0NhbGxzID0gW107XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSW50ZXJtZWRpYXRlIGFic3RyYWN0IGZvcm1hdCBzZW50IHRvIGJhdGNoIHN5c3RlbS5cclxuICAgICAgICAgKiBDYW4gYmUgY29udmVydGVkIHRvIGRyYXdDYWxscyBvciB0byBiYXRjaGFibGUgb2JqZWN0cy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBtZW1iZXIge29iamVjdFtdfVxyXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmJhdGNoZXMgPSBbXTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJbmRleCBvZiB0aGUgY3VycmVudCBsYXN0IHNoYXBlIGluIHRoZSBzdGFjayBvZiBjYWxscy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5zaGFwZUluZGV4ID0gMDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDYWNoZWQgYm91bmRzLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQG1lbWJlciB7UElYSS5Cb3VuZHN9XHJcbiAgICAgICAgICogQHByb3RlY3RlZFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuX2JvdW5kcyA9IG5ldyBCb3VuZHNfMS5Cb3VuZHMoKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgYm91bmRzIGRpcnR5IGZsYWcuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgICAgICogQHByb3RlY3RlZFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuYm91bmRzRGlydHkgPSAtMTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBQYWRkaW5nIHRvIGFkZCB0byB0aGUgYm91bmRzLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICAgICAqIEBkZWZhdWx0IDBcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmJvdW5kc1BhZGRpbmcgPSAwO1xyXG4gICAgICAgIHRoaXMuYmF0Y2hhYmxlID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5pbmRpY2VzVWludDE2ID0gbnVsbDtcclxuICAgICAgICB0aGlzLnV2c0Zsb2F0MzIgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGdldEZpbGxDb21tYW5kKHR5cGUpIHtcclxuICAgICAgICBpZiAoIUdyYXBoaWNzR2VvbWV0cnkuZmlsbENvbW1hbmRzKSB7XHJcbiAgICAgICAgICAgIEdyYXBoaWNzR2VvbWV0cnkuZmlsbENvbW1hbmRzID0ge307XHJcbiAgICAgICAgICAgIEdyYXBoaWNzR2VvbWV0cnkuZmlsbENvbW1hbmRzW1NoYXBlU2V0dGluZ3NfMS5TaGFwZVNldHRpbmdzLlNIQVBFUy5QT0xZXSA9IEdyYXBoaWNzR2VvbWV0cnkuYnVpbGRQb2x5O1xyXG4gICAgICAgICAgICBHcmFwaGljc0dlb21ldHJ5LmZpbGxDb21tYW5kc1tTaGFwZVNldHRpbmdzXzEuU2hhcGVTZXR0aW5ncy5TSEFQRVMuQ0lSQ10gPSBHcmFwaGljc0dlb21ldHJ5LmJ1aWxkQ2lyY2xlO1xyXG4gICAgICAgICAgICBHcmFwaGljc0dlb21ldHJ5LmZpbGxDb21tYW5kc1tTaGFwZVNldHRpbmdzXzEuU2hhcGVTZXR0aW5ncy5TSEFQRVMuRUxJUF0gPSBHcmFwaGljc0dlb21ldHJ5LmJ1aWxkQ2lyY2xlO1xyXG4gICAgICAgICAgICBHcmFwaGljc0dlb21ldHJ5LmZpbGxDb21tYW5kc1tTaGFwZVNldHRpbmdzXzEuU2hhcGVTZXR0aW5ncy5TSEFQRVMuUkVDVF0gPSBHcmFwaGljc0dlb21ldHJ5LmJ1aWxkUmVjdGFuZ2xlO1xyXG4gICAgICAgICAgICBHcmFwaGljc0dlb21ldHJ5LmZpbGxDb21tYW5kc1tTaGFwZVNldHRpbmdzXzEuU2hhcGVTZXR0aW5ncy5TSEFQRVMuUlJFQ10gPSBHcmFwaGljc0dlb21ldHJ5LmJ1aWxkUm91bmRlZFJlY3RhbmdsZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIEdyYXBoaWNzR2VvbWV0cnkuZmlsbENvbW1hbmRzW3R5cGVdO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIGN1cnJlbnQgYm91bmRzIG9mIHRoZSBncmFwaGljIGdlb21ldHJ5LlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge1BJWEkuQm91bmRzfVxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKi9cclxuICAgIGdldCBib3VuZHMoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuYm91bmRzRGlydHkgIT09IHRoaXMuZGlydHkpIHtcclxuICAgICAgICAgICAgdGhpcy5ib3VuZHNEaXJ0eSA9IHRoaXMuZGlydHk7XHJcbiAgICAgICAgICAgIHRoaXMuY2FsY3VsYXRlQm91bmRzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLl9ib3VuZHM7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIENsZWFycyB0aGUgZ3JhcGhpY3MgdGhhdCB3ZXJlIGRyYXduIHRvIHRoaXMgR3JhcGhpY3Mgb2JqZWN0LCBhbmQgcmVzZXRzIGZpbGwgYW5kIGxpbmUgc3R5bGUgc2V0dGluZ3MuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiB7UElYSS5HcmFwaGljc0dlb21ldHJ5fSBUaGlzIEdyYXBoaWNzR2VvbWV0cnkgb2JqZWN0LiBHb29kIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHNcclxuICAgICAqL1xyXG4gICAgY2xlYXIoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZ3JhcGhpY3NEYXRhLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgdGhpcy5ib3VuZHNEaXJ0eSA9IC0xO1xyXG4gICAgICAgICAgICB0aGlzLmRpcnR5Kys7XHJcbiAgICAgICAgICAgIHRoaXMuY2xlYXJEaXJ0eSsrO1xyXG4gICAgICAgICAgICB0aGlzLmJhdGNoRGlydHkrKztcclxuICAgICAgICAgICAgdGhpcy5ncmFwaGljc0RhdGEubGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgdGhpcy5zaGFwZUluZGV4ID0gMDtcclxuICAgICAgICAgICAgdGhpcy5wb2ludHMubGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgdGhpcy5jb2xvcnMubGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgdGhpcy51dnMubGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgdGhpcy5pbmRpY2VzLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMudGV4dHVyZUlkcy5sZW5ndGggPSAwO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZHJhd0NhbGxzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRyYXdDYWxsc1tpXS50ZXh0dXJlcy5sZW5ndGggPSAwO1xyXG4gICAgICAgICAgICAgICAgR3JhcGhpY3NHZW9tZXRyeS5EUkFXX0NBTExfUE9PTC5wdXNoKHRoaXMuZHJhd0NhbGxzW2ldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmRyYXdDYWxscy5sZW5ndGggPSAwO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCB0aGlzLmJhdGNoZXMubGVuZ3RoOyBpJDErKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGJhdGNoID0gdGhpcy5iYXRjaGVzW2kkMV07XHJcbiAgICAgICAgICAgICAgICBiYXRjaC5zdGFydCA9IDA7XHJcbiAgICAgICAgICAgICAgICBiYXRjaC5hdHRyaWJTdGFydCA9IDA7XHJcbiAgICAgICAgICAgICAgICBiYXRjaC5zdHlsZSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICBHcmFwaGljc0dlb21ldHJ5LkJBVENIX1BPT0wucHVzaChiYXRjaCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5iYXRjaGVzLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBEcmF3cyB0aGUgZ2l2ZW4gc2hhcGUgdG8gdGhpcyBHcmFwaGljcyBvYmplY3QuIENhbiBiZSBhbnkgb2YgQ2lyY2xlLCBSZWN0YW5nbGUsIEVsbGlwc2UsIExpbmUgb3IgUG9seWdvbi5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1BJWEkuQ2lyY2xlfFBJWEkuRWxsaXBzZXxQSVhJLlBvbHlnb258UElYSS5SZWN0YW5nbGV8UElYSS5Sb3VuZGVkUmVjdGFuZ2xlfSBzaGFwZSAtIFRoZSBzaGFwZSBvYmplY3QgdG8gZHJhdy5cclxuICAgICAqIEBwYXJhbSB7UElYSS5GaWxsU3R5bGV9IGZpbGxTdHlsZSAtIERlZmluZXMgc3R5bGUgb2YgdGhlIGZpbGwuXHJcbiAgICAgKiBAcGFyYW0ge1BJWEkuTGluZVN0eWxlfSBsaW5lU3R5bGUgLSBEZWZpbmVzIHN0eWxlIG9mIHRoZSBsaW5lcy5cclxuICAgICAqIEBwYXJhbSB7UElYSS5NYXRyaXh9IG1hdHJpeCAtIFRyYW5zZm9ybSBhcHBsaWVkIHRvIHRoZSBwb2ludHMgb2YgdGhlIHNoYXBlLlxyXG4gICAgICogQHJldHVybiB7UElYSS5HcmFwaGljc0dlb21ldHJ5fSBSZXR1cm5zIGdlb21ldHJ5IGZvciBjaGFpbmluZy5cclxuICAgICAqL1xyXG4gICAgZHJhd1NoYXBlKHNoYXBlLCBmaWxsU3R5bGUsIGxpbmVTdHlsZSwgbWF0cml4KSB7XHJcbiAgICAgICAgdmFyIGRhdGEgPSBuZXcgR3JhcGhpY3NEYXRhXzEuR3JhcGhpY3NEYXRhKHNoYXBlLCBmaWxsU3R5bGUsIGxpbmVTdHlsZSwgbWF0cml4KTtcclxuICAgICAgICB0aGlzLmdyYXBoaWNzRGF0YS5wdXNoKGRhdGEpO1xyXG4gICAgICAgIHRoaXMuZGlydHkrKztcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogRHJhd3MgdGhlIGdpdmVuIHNoYXBlIHRvIHRoaXMgR3JhcGhpY3Mgb2JqZWN0LiBDYW4gYmUgYW55IG9mIENpcmNsZSwgUmVjdGFuZ2xlLCBFbGxpcHNlLCBMaW5lIG9yIFBvbHlnb24uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtQSVhJLkNpcmNsZXxQSVhJLkVsbGlwc2V8UElYSS5Qb2x5Z29ufFBJWEkuUmVjdGFuZ2xlfFBJWEkuUm91bmRlZFJlY3RhbmdsZX0gc2hhcGUgLSBUaGUgc2hhcGUgb2JqZWN0IHRvIGRyYXcuXHJcbiAgICAgKiBAcGFyYW0ge1BJWEkuTWF0cml4fSBtYXRyaXggLSBUcmFuc2Zvcm0gYXBwbGllZCB0byB0aGUgcG9pbnRzIG9mIHRoZSBzaGFwZS5cclxuICAgICAqIEByZXR1cm4ge1BJWEkuR3JhcGhpY3NHZW9tZXRyeX0gUmV0dXJucyBnZW9tZXRyeSBmb3IgY2hhaW5pbmcuXHJcbiAgICAgKi9cclxuICAgIGRyYXdIb2xlKHNoYXBlLCBtYXRyaXgpIHtcclxuICAgICAgICBpZiAoIXRoaXMuZ3JhcGhpY3NEYXRhLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGRhdGEgPSBuZXcgR3JhcGhpY3NEYXRhXzEuR3JhcGhpY3NEYXRhKHNoYXBlLCBudWxsLCBudWxsLCBtYXRyaXgpO1xyXG4gICAgICAgIHZhciBsYXN0U2hhcGUgPSB0aGlzLmdyYXBoaWNzRGF0YVt0aGlzLmdyYXBoaWNzRGF0YS5sZW5ndGggLSAxXTtcclxuICAgICAgICBkYXRhLmxpbmVTdHlsZSA9IGxhc3RTaGFwZS5saW5lU3R5bGU7XHJcbiAgICAgICAgbGFzdFNoYXBlLmhvbGVzLnB1c2goZGF0YSk7XHJcbiAgICAgICAgdGhpcy5kaXJ0eSsrO1xyXG4gICAgICAgIHJldHVybiBkYXRhO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBEZXN0cm95cyB0aGUgR3JhcGhpY3Mgb2JqZWN0LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fGJvb2xlYW59IFtvcHRpb25zXSAtIE9wdGlvbnMgcGFyYW1ldGVyLiBBIGJvb2xlYW4gd2lsbCBhY3QgYXMgaWYgYWxsXHJcbiAgICAgKiAgb3B0aW9ucyBoYXZlIGJlZW4gc2V0IHRvIHRoYXQgdmFsdWVcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuY2hpbGRyZW49ZmFsc2VdIC0gaWYgc2V0IHRvIHRydWUsIGFsbCB0aGUgY2hpbGRyZW4gd2lsbCBoYXZlXHJcbiAgICAgKiAgdGhlaXIgZGVzdHJveSBtZXRob2QgY2FsbGVkIGFzIHdlbGwuICdvcHRpb25zJyB3aWxsIGJlIHBhc3NlZCBvbiB0byB0aG9zZSBjYWxscy5cclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudGV4dHVyZT1mYWxzZV0gLSBPbmx5IHVzZWQgZm9yIGNoaWxkIFNwcml0ZXMgaWYgb3B0aW9ucy5jaGlsZHJlbiBpcyBzZXQgdG8gdHJ1ZVxyXG4gICAgICogIFNob3VsZCBpdCBkZXN0cm95IHRoZSB0ZXh0dXJlIG9mIHRoZSBjaGlsZCBzcHJpdGVcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuYmFzZVRleHR1cmU9ZmFsc2VdIC0gT25seSB1c2VkIGZvciBjaGlsZCBTcHJpdGVzIGlmIG9wdGlvbnMuY2hpbGRyZW4gaXMgc2V0IHRvIHRydWVcclxuICAgICAqICBTaG91bGQgaXQgZGVzdHJveSB0aGUgYmFzZSB0ZXh0dXJlIG9mIHRoZSBjaGlsZCBzcHJpdGVcclxuICAgICAqL1xyXG4gICAgZGVzdHJveShvcHRpb25zKSB7XHJcbiAgICAgICAgc3VwZXIuZGVzdHJveShvcHRpb25zKTtcclxuICAgICAgICAvLyBkZXN0cm95IGVhY2ggb2YgdGhlIEdyYXBoaWNzRGF0YSBvYmplY3RzXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmdyYXBoaWNzRGF0YS5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICB0aGlzLmdyYXBoaWNzRGF0YVtpXS5kZXN0cm95KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMucG9pbnRzLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgdGhpcy5wb2ludHMgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuY29sb3JzLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgdGhpcy5jb2xvcnMgPSBudWxsO1xyXG4gICAgICAgIHRoaXMudXZzLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgdGhpcy51dnMgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuaW5kaWNlcy5sZW5ndGggPSAwO1xyXG4gICAgICAgIHRoaXMuaW5kaWNlcyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5pbmRleEJ1ZmZlci5kZXN0cm95KCk7XHJcbiAgICAgICAgdGhpcy5pbmRleEJ1ZmZlciA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5ncmFwaGljc0RhdGEubGVuZ3RoID0gMDtcclxuICAgICAgICB0aGlzLmdyYXBoaWNzRGF0YSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5kcmF3Q2FsbHMubGVuZ3RoID0gMDtcclxuICAgICAgICB0aGlzLmRyYXdDYWxscyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5iYXRjaGVzLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgdGhpcy5iYXRjaGVzID0gbnVsbDtcclxuICAgICAgICB0aGlzLl9ib3VuZHMgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVjayB0byBzZWUgaWYgYSBwb2ludCBpcyBjb250YWluZWQgd2l0aGluIHRoaXMgZ2VvbWV0cnkuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtQSVhJLlBvaW50fSBwb2ludCAtIFBvaW50IHRvIGNoZWNrIGlmIGl0J3MgY29udGFpbmVkLlxyXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gYHRydWVgIGlmIHRoZSBwb2ludCBpcyBjb250YWluZWQgd2l0aGluIGdlb21ldHJ5LlxyXG4gICAgICovXHJcbiAgICBjb250YWluc1BvaW50KHBvaW50KSB7XHJcbiAgICAgICAgdmFyIGdyYXBoaWNzRGF0YSA9IHRoaXMuZ3JhcGhpY3NEYXRhO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ3JhcGhpY3NEYXRhLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgIHZhciBkYXRhID0gZ3JhcGhpY3NEYXRhW2ldO1xyXG4gICAgICAgICAgICBpZiAoIWRhdGEuZmlsbFN0eWxlLnZpc2libGUpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIG9ubHkgZGVhbCB3aXRoIGZpbGxzLi5cclxuICAgICAgICAgICAgaWYgKGRhdGEuc2hhcGUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChkYXRhLnNoYXBlLmNvbnRhaW5zKHBvaW50LngsIHBvaW50LnkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEuaG9sZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgZGF0YS5ob2xlcy5sZW5ndGg7IGkkMSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaG9sZSA9IGRhdGEuaG9sZXNbaSQxXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChob2xlLnNoYXBlLmNvbnRhaW5zKHBvaW50LngsIHBvaW50LnkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogR2VuZXJhdGVzIGludGVybWVkaWF0ZSBiYXRjaCBkYXRhLiBFaXRoZXIgZ2V0cyBjb252ZXJ0ZWQgdG8gZHJhd0NhbGxzXHJcbiAgICAgKiBvciB1c2VkIHRvIGNvbnZlcnQgdG8gYmF0Y2ggb2JqZWN0cyBkaXJlY3RseSBieSB0aGUgR3JhcGhpY3Mgb2JqZWN0LlxyXG4gICAgICogQHByb3RlY3RlZFxyXG4gICAgICovXHJcbiAgICB1cGRhdGVCYXRjaGVzKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmRpcnR5ID09PSB0aGlzLmNhY2hlRGlydHkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5ncmFwaGljc0RhdGEubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuZGlydHkgIT09IHRoaXMuY2FjaGVEaXJ0eSkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZ3JhcGhpY3NEYXRhLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuZ3JhcGhpY3NEYXRhW2ldO1xyXG4gICAgICAgICAgICAgICAgLy8gcmV2ZWFsKGRhdGEuZmlsbFN0eWxlLnRleHR1cmUuYmFzZVRleHR1cmUucmVzb3VyY2UpO1xyXG4gICAgICAgICAgICAgICAgLy8gcmV2ZWFsKGRhdGEubGluZVN0eWxlLnRleHR1cmUuYmFzZVRleHR1cmUucmVzb3VyY2UpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGRhdGEuZmlsbFN0eWxlICYmICFkYXRhLmZpbGxTdHlsZS50ZXh0dXJlLmJhc2VUZXh0dXJlLnZhbGlkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGRhdGEubGluZVN0eWxlICYmICFkYXRhLmxpbmVTdHlsZS50ZXh0dXJlLmJhc2VUZXh0dXJlLnZhbGlkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY2FjaGVEaXJ0eSA9IHRoaXMuZGlydHk7XHJcbiAgICAgICAgdmFyIHV2cyA9IHRoaXMudXZzO1xyXG4gICAgICAgIHZhciBiYXRjaFBhcnQgPSB0aGlzLmJhdGNoZXMucG9wKClcclxuICAgICAgICAgICAgfHwgR3JhcGhpY3NHZW9tZXRyeS5CQVRDSF9QT09MLnBvcCgpXHJcbiAgICAgICAgICAgIHx8IG5ldyBCYXRjaFBhcnQoKTtcclxuICAgICAgICBiYXRjaFBhcnQuc3R5bGUgPSBiYXRjaFBhcnQuc3R5bGVcclxuICAgICAgICAgICAgfHwgdGhpcy5ncmFwaGljc0RhdGFbMF0uZmlsbFN0eWxlXHJcbiAgICAgICAgICAgIHx8IHRoaXMuZ3JhcGhpY3NEYXRhWzBdLmxpbmVTdHlsZTtcclxuICAgICAgICB2YXIgY3VycmVudFRleHR1cmUgPSBiYXRjaFBhcnQuc3R5bGUudGV4dHVyZS5iYXNlVGV4dHVyZTtcclxuICAgICAgICAvLyByZXZlYWwoY3VycmVudFRleHR1cmUpO1xyXG4gICAgICAgIHZhciBjdXJyZW50Q29sb3IgPSBiYXRjaFBhcnQuc3R5bGUuY29sb3IgKyBiYXRjaFBhcnQuc3R5bGUuYWxwaGE7XHJcbiAgICAgICAgdGhpcy5iYXRjaGVzLnB1c2goYmF0Y2hQYXJ0KTtcclxuICAgICAgICAvLyByZXZlYWwodGhpcy5iYXRjaGVzKTtcclxuICAgICAgICAvLyBUT0RPIC0gdGhpcyBjYW4gYmUgc2ltcGxpZmllZFxyXG4gICAgICAgIGZvciAodmFyIGkkMSA9IHRoaXMuc2hhcGVJbmRleDsgaSQxIDwgdGhpcy5ncmFwaGljc0RhdGEubGVuZ3RoOyBpJDErKykge1xyXG4gICAgICAgICAgICB0aGlzLnNoYXBlSW5kZXgrKztcclxuICAgICAgICAgICAgdmFyIGRhdGEkMSA9IHRoaXMuZ3JhcGhpY3NEYXRhW2kkMV07XHJcbiAgICAgICAgICAgIC8vIHJldmVhbChkYXRhJDEpO1xyXG4gICAgICAgICAgICB2YXIgY29tbWFuZCA9IEdyYXBoaWNzR2VvbWV0cnkuZ2V0RmlsbENvbW1hbmQoZGF0YSQxLnR5cGUpO1xyXG4gICAgICAgICAgICAvLyByZXZlYWwoY29tbWFuZClcclxuICAgICAgICAgICAgdmFyIGZpbGxTdHlsZSA9IGRhdGEkMS5maWxsU3R5bGU7XHJcbiAgICAgICAgICAgIHZhciBsaW5lU3R5bGUgPSBkYXRhJDEubGluZVN0eWxlO1xyXG4gICAgICAgICAgICAvLyBidWlsZCBvdXQgdGhlIHNoYXBlcyBwb2ludHMuLlxyXG4gICAgICAgICAgICBjb21tYW5kLmJ1aWxkKGRhdGEkMSk7XHJcbiAgICAgICAgICAgIGlmIChkYXRhJDEubWF0cml4KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRyYW5zZm9ybVBvaW50cyhkYXRhJDEucG9pbnRzLCBkYXRhJDEubWF0cml4KTtcclxuICAgICAgICAgICAgICAgIC8vIHJldmVhbChkYXRhJDEucG9pbnRzKVxyXG4gICAgICAgICAgICAgICAgLy8gXHRyZXZlYWwoZGF0YSQxLm1hdHJpeClcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IDI7IGorKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHN0eWxlID0gKGogPT09IDApID8gZmlsbFN0eWxlIDogbGluZVN0eWxlO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFzdHlsZS52aXNpYmxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgbmV4dFRleHR1cmUgPSBzdHlsZS50ZXh0dXJlLmJhc2VUZXh0dXJlO1xyXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRUZXh0dXJlICE9PSBuZXh0VGV4dHVyZSB8fCAoc3R5bGUuY29sb3IgKyBzdHlsZS5hbHBoYSkgIT09IGN1cnJlbnRDb2xvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gdXNlIGEgY29uc3RcclxuICAgICAgICAgICAgICAgICAgICBuZXh0VGV4dHVyZS53cmFwTW9kZSA9IDEwNDk3O1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRUZXh0dXJlID0gbmV4dFRleHR1cmU7XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudENvbG9yID0gc3R5bGUuY29sb3IgKyBzdHlsZS5hbHBoYTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXgkMSA9IHRoaXMuaW5kaWNlcy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGF0dHJpYkluZGV4ID0gdGhpcy5wb2ludHMubGVuZ3RoIC8gMjtcclxuICAgICAgICAgICAgICAgICAgICBiYXRjaFBhcnQuc2l6ZSA9IGluZGV4JDEgLSBiYXRjaFBhcnQuc3RhcnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgYmF0Y2hQYXJ0LmF0dHJpYlNpemUgPSBhdHRyaWJJbmRleCAtIGJhdGNoUGFydC5hdHRyaWJTdGFydDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYmF0Y2hQYXJ0LnNpemUgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhdGNoUGFydCA9IEdyYXBoaWNzR2VvbWV0cnkuQkFUQ0hfUE9PTC5wb3AoKSB8fCBuZXcgQmF0Y2hQYXJ0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYmF0Y2hlcy5wdXNoKGJhdGNoUGFydCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJhdGNoUGFydC5zdHlsZSA9IHN0eWxlO1xyXG4gICAgICAgICAgICAgICAgICAgIGJhdGNoUGFydC5zdGFydCA9IGluZGV4JDE7XHJcbiAgICAgICAgICAgICAgICAgICAgYmF0Y2hQYXJ0LmF0dHJpYlN0YXJ0ID0gYXR0cmliSW5kZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyBhZGQgdGhpcyB0byB0aGUgcmVuZGVyIHBhcnQuLlxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5wb2ludHMubGVuZ3RoIC8gMjtcclxuICAgICAgICAgICAgICAgIGlmIChqID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEkMS5ob2xlcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzSG9sZXMoZGF0YSQxLmhvbGVzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgR3JhcGhpY3NHZW9tZXRyeS5idWlsZFBvbHkudHJpYW5ndWxhdGUoZGF0YSQxLCB0aGlzKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1hbmQudHJpYW5ndWxhdGUoZGF0YSQxLCB0aGlzKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBHcmFwaGljc0dlb21ldHJ5LmJ1aWxkTGluZShkYXRhJDEsIHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkkMiA9IDA7IGkkMiA8IGRhdGEkMS5ob2xlcy5sZW5ndGg7IGkkMisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIEdyYXBoaWNzR2VvbWV0cnkuYnVpbGRMaW5lKGRhdGEkMS5ob2xlc1tpJDJdLCB0aGlzKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgc2l6ZSA9ICh0aGlzLnBvaW50cy5sZW5ndGggLyAyKSAtIHN0YXJ0O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRVdnModGhpcy5wb2ludHMsIHV2cywgc3R5bGUudGV4dHVyZSwgc3RhcnQsIHNpemUsIHN0eWxlLm1hdHJpeCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5pbmRpY2VzLmxlbmd0aDtcclxuICAgICAgICB2YXIgYXR0cmliID0gdGhpcy5wb2ludHMubGVuZ3RoIC8gMjtcclxuICAgICAgICBiYXRjaFBhcnQuc2l6ZSA9IGluZGV4IC0gYmF0Y2hQYXJ0LnN0YXJ0O1xyXG4gICAgICAgIGJhdGNoUGFydC5hdHRyaWJTaXplID0gYXR0cmliIC0gYmF0Y2hQYXJ0LmF0dHJpYlN0YXJ0O1xyXG4gICAgICAgIHRoaXMuaW5kaWNlc1VpbnQxNiA9IG5ldyBVaW50MTZBcnJheSh0aGlzLmluZGljZXMpO1xyXG4gICAgICAgIC8vIFRPRE8gbWFrZSB0aGlzIGEgY29uc3QuLlxyXG4gICAgICAgIHRoaXMuYmF0Y2hhYmxlID0gdGhpcy5pc0JhdGNoYWJsZSgpO1xyXG4gICAgICAgIGlmICh0aGlzLmJhdGNoYWJsZSkge1xyXG4gICAgICAgICAgICB0aGlzLmJhdGNoRGlydHkrKztcclxuICAgICAgICAgICAgdGhpcy51dnNGbG9hdDMyID0gbmV3IEZsb2F0MzJBcnJheSh0aGlzLnV2cyk7XHJcbiAgICAgICAgICAgIC8vIG9mZnNldCB0aGUgaW5kaWNlcyBzbyB0aGF0IGl0IHdvcmtzIHdpdGggdGhlIGJhdGNoZXIuLi5cclxuICAgICAgICAgICAgZm9yICh2YXIgaSQzID0gMDsgaSQzIDwgdGhpcy5iYXRjaGVzLmxlbmd0aDsgaSQzKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBiYXRjaCA9IHRoaXMuYmF0Y2hlc1tpJDNdO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiQxID0gMDsgaiQxIDwgYmF0Y2guc2l6ZTsgaiQxKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXgkMiA9IGJhdGNoLnN0YXJ0ICsgaiQxO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5kaWNlc1VpbnQxNltpbmRleCQyXSA9IHRoaXMuaW5kaWNlc1VpbnQxNltpbmRleCQyXSAtIGJhdGNoLmF0dHJpYlN0YXJ0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmJ1aWxkRHJhd0NhbGxzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVja3MgdG8gc2VlIGlmIHRoaXMgZ3JhcGhpY3MgZ2VvbWV0cnkgY2FuIGJlIGJhdGNoZWQuXHJcbiAgICAgKiBDdXJyZW50bHkgaXQgbmVlZHMgdG8gYmUgc21hbGwgZW5vdWdoIGFuZCBub3QgY29udGFpbiBhbnkgbmF0aXZlIGxpbmVzLlxyXG4gICAgICogQHByb3RlY3RlZFxyXG4gICAgICovXHJcbiAgICBpc0JhdGNoYWJsZSgpIHtcclxuICAgICAgICB2YXIgYmF0Y2hlcyA9IHRoaXMuYmF0Y2hlcztcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJhdGNoZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGJhdGNoZXNbaV0uc3R5bGUubmF0aXZlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLnBvaW50cy5sZW5ndGggPCBHcmFwaGljc0dlb21ldHJ5LkJBVENIQUJMRV9TSVpFICogMik7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnRzIGludGVybWVkaWF0ZSBiYXRjaGVzIGRhdGEgdG8gZHJhd0NhbGxzLlxyXG4gICAgICogQHByb3RlY3RlZFxyXG4gICAgICovXHJcbiAgICBidWlsZERyYXdDYWxscygpIHtcclxuICAgICAgICB2YXIgVElDSyA9ICsrQmFzZVRleHR1cmVfMS5CYXNlVGV4dHVyZS5fZ2xvYmFsQmF0Y2g7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmRyYXdDYWxscy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB0aGlzLmRyYXdDYWxsc1tpXS50ZXh0dXJlcy5sZW5ndGggPSAwO1xyXG4gICAgICAgICAgICBHcmFwaGljc0dlb21ldHJ5LkRSQVdfQ0FMTF9QT09MLnB1c2godGhpcy5kcmF3Q2FsbHNbaV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmRyYXdDYWxscy5sZW5ndGggPSAwO1xyXG4gICAgICAgIHZhciB1dnMgPSB0aGlzLnV2cztcclxuICAgICAgICB2YXIgY29sb3JzID0gdGhpcy5jb2xvcnM7XHJcbiAgICAgICAgdmFyIHRleHR1cmVJZHMgPSB0aGlzLnRleHR1cmVJZHM7XHJcbiAgICAgICAgdmFyIGN1cnJlbnRHcm91cCA9IEdyYXBoaWNzR2VvbWV0cnkuRFJBV19DQUxMX1BPT0wucG9wKCkgfHwgbmV3IEJhdGNoRHJhd0NhbGxfMS5CYXRjaERyYXdDYWxsKCk7XHJcbiAgICAgICAgY3VycmVudEdyb3VwLnRleHR1cmVDb3VudCA9IDA7XHJcbiAgICAgICAgY3VycmVudEdyb3VwLnN0YXJ0ID0gMDtcclxuICAgICAgICBjdXJyZW50R3JvdXAuc2l6ZSA9IDA7XHJcbiAgICAgICAgY3VycmVudEdyb3VwLnR5cGUgPSBEcmF3TW9kZVNldHRpbmdzXzEuRHJhd01vZGVTZXR0aW5ncy5EUkFXX01PREVTLlRSSUFOR0xFUztcclxuICAgICAgICB2YXIgdGV4dHVyZUNvdW50ID0gMDtcclxuICAgICAgICB2YXIgY3VycmVudFRleHR1cmUgPSBudWxsO1xyXG4gICAgICAgIHZhciB0ZXh0dXJlSWQgPSAwO1xyXG4gICAgICAgIHZhciBuYXRpdmUgPSBmYWxzZTtcclxuICAgICAgICB2YXIgZHJhd01vZGUgPSBEcmF3TW9kZVNldHRpbmdzXzEuRHJhd01vZGVTZXR0aW5ncy5EUkFXX01PREVTLlRSSUFOR0xFUztcclxuICAgICAgICB2YXIgaW5kZXggPSAwO1xyXG4gICAgICAgIHRoaXMuZHJhd0NhbGxzLnB1c2goY3VycmVudEdyb3VwKTtcclxuICAgICAgICAvLyBUT0RPIC0gdGhpcyBjYW4gYmUgc2ltcGxpZmllZFxyXG4gICAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IHRoaXMuYmF0Y2hlcy5sZW5ndGg7IGkkMSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5iYXRjaGVzW2kkMV07XHJcbiAgICAgICAgICAgIC8vIFRPRE8gYWRkIHNvbWUgZnVsbCBvbiBNQVhfVEVYVFVSRSBDT0RFLi5cclxuICAgICAgICAgICAgdmFyIE1BWF9URVhUVVJFUyA9IDg7XHJcbiAgICAgICAgICAgIHZhciBzdHlsZSA9IGRhdGEuc3R5bGU7XHJcbiAgICAgICAgICAgIHZhciBuZXh0VGV4dHVyZSA9IHN0eWxlLnRleHR1cmUuYmFzZVRleHR1cmU7XHJcbiAgICAgICAgICAgIGlmIChuYXRpdmUgIT09IHN0eWxlLm5hdGl2ZSkge1xyXG4gICAgICAgICAgICAgICAgbmF0aXZlID0gc3R5bGUubmF0aXZlO1xyXG4gICAgICAgICAgICAgICAgZHJhd01vZGUgPSBuYXRpdmUgPyBEcmF3TW9kZVNldHRpbmdzXzEuRHJhd01vZGVTZXR0aW5ncy5EUkFXX01PREVTLkxJTkVTIDogRHJhd01vZGVTZXR0aW5nc18xLkRyYXdNb2RlU2V0dGluZ3MuRFJBV19NT0RFUy5UUklBTkdMRVM7XHJcbiAgICAgICAgICAgICAgICAvLyBmb3JjZSB0aGUgYmF0Y2ggdG8gYnJlYWshXHJcbiAgICAgICAgICAgICAgICBjdXJyZW50VGV4dHVyZSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB0ZXh0dXJlQ291bnQgPSBNQVhfVEVYVFVSRVM7XHJcbiAgICAgICAgICAgICAgICBUSUNLKys7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGN1cnJlbnRUZXh0dXJlICE9PSBuZXh0VGV4dHVyZSkge1xyXG4gICAgICAgICAgICAgICAgY3VycmVudFRleHR1cmUgPSBuZXh0VGV4dHVyZTtcclxuICAgICAgICAgICAgICAgIGlmIChuZXh0VGV4dHVyZS5fYmF0Y2hFbmFibGVkICE9PSBUSUNLKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRleHR1cmVDb3VudCA9PT0gTUFYX1RFWFRVUkVTKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFRJQ0srKztcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dHVyZUNvdW50ID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRHcm91cC5zaXplID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEdyb3VwID0gR3JhcGhpY3NHZW9tZXRyeS5EUkFXX0NBTExfUE9PTC5wb3AoKSB8fCBuZXcgQmF0Y2hEcmF3Q2FsbF8xLkJhdGNoRHJhd0NhbGwoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd0NhbGxzLnB1c2goY3VycmVudEdyb3VwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50R3JvdXAuc3RhcnQgPSBpbmRleDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEdyb3VwLnNpemUgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50R3JvdXAudGV4dHVyZUNvdW50ID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEdyb3VwLnR5cGUgPSBkcmF3TW9kZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyBhZGQgdGhpcyB0byB0aGUgcmVuZGVyIHBhcnQuLlxyXG4gICAgICAgICAgICAgICAgICAgIG5leHRUZXh0dXJlLnRvdWNoZWQgPSAxOyAvLyB0b3VjaDtcclxuICAgICAgICAgICAgICAgICAgICBuZXh0VGV4dHVyZS5fYmF0Y2hFbmFibGVkID0gVElDSztcclxuICAgICAgICAgICAgICAgICAgICBuZXh0VGV4dHVyZS5faWQgPSB0ZXh0dXJlQ291bnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV4dFRleHR1cmUud3JhcE1vZGUgPSAxMDQ5NztcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50R3JvdXAudGV4dHVyZXNbY3VycmVudEdyb3VwLnRleHR1cmVDb3VudCsrXSA9IG5leHRUZXh0dXJlO1xyXG4gICAgICAgICAgICAgICAgICAgIHRleHR1cmVDb3VudCsrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGN1cnJlbnRHcm91cC5zaXplICs9IGRhdGEuc2l6ZTtcclxuICAgICAgICAgICAgaW5kZXggKz0gZGF0YS5zaXplO1xyXG4gICAgICAgICAgICB0ZXh0dXJlSWQgPSBuZXh0VGV4dHVyZS5faWQ7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkQ29sb3JzKGNvbG9ycywgc3R5bGUuY29sb3IsIHN0eWxlLmFscGhhLCBkYXRhLmF0dHJpYlNpemUpO1xyXG4gICAgICAgICAgICB0aGlzLmFkZFRleHR1cmVJZHModGV4dHVyZUlkcywgdGV4dHVyZUlkLCBkYXRhLmF0dHJpYlNpemUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBCYXNlVGV4dHVyZV8xLkJhc2VUZXh0dXJlLl9nbG9iYWxCYXRjaCA9IFRJQ0s7XHJcbiAgICAgICAgLy8gdXBsb2FkLi5cclxuICAgICAgICAvLyBtZXJnZSBmb3Igbm93IVxyXG4gICAgICAgIHZhciB2ZXJ0cyA9IHRoaXMucG9pbnRzO1xyXG4gICAgICAgIC8vIHZlcnRzIGFyZSAyIHBvc2l0aW9ucy4uIHNvIHdlICogYnkgMyBhcyB0aGVyZSBhcmUgNiBwcm9wZXJ0aWVzLi4gdGhlbiA0IGNvcyBpdHMgYnl0ZXNcclxuICAgICAgICB2YXIgZ2xQb2ludHMgPSBuZXcgQXJyYXlCdWZmZXIodmVydHMubGVuZ3RoICogMyAqIDQpO1xyXG4gICAgICAgIHZhciBmMzIgPSBuZXcgRmxvYXQzMkFycmF5KGdsUG9pbnRzKTtcclxuICAgICAgICB2YXIgdTMyID0gbmV3IFVpbnQzMkFycmF5KGdsUG9pbnRzKTtcclxuICAgICAgICB2YXIgcCA9IDA7XHJcbiAgICAgICAgZm9yICh2YXIgaSQyID0gMDsgaSQyIDwgdmVydHMubGVuZ3RoIC8gMjsgaSQyKyspIHtcclxuICAgICAgICAgICAgZjMyW3ArK10gPSB2ZXJ0c1tpJDIgKiAyXTtcclxuICAgICAgICAgICAgZjMyW3ArK10gPSB2ZXJ0c1soaSQyICogMikgKyAxXTtcclxuICAgICAgICAgICAgZjMyW3ArK10gPSB1dnNbaSQyICogMl07XHJcbiAgICAgICAgICAgIGYzMltwKytdID0gdXZzWyhpJDIgKiAyKSArIDFdO1xyXG4gICAgICAgICAgICB1MzJbcCsrXSA9IGNvbG9yc1tpJDJdO1xyXG4gICAgICAgICAgICBmMzJbcCsrXSA9IHRleHR1cmVJZHNbaSQyXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fYnVmZmVyLnVwZGF0ZShnbFBvaW50cyk7XHJcbiAgICAgICAgdGhpcy5faW5kZXhCdWZmZXIudXBkYXRlKHRoaXMuaW5kaWNlc1VpbnQxNik7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFByb2Nlc3MgdGhlIGhvbGVzIGRhdGEuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtQSVhJLkdyYXBoaWNzRGF0YVtdfSBob2xlcyAtIEhvbGVzIHRvIHJlbmRlclxyXG4gICAgICogQHByb3RlY3RlZFxyXG4gICAgICovXHJcbiAgICBwcm9jZXNzSG9sZXMoaG9sZXMpIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhvbGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBob2xlID0gaG9sZXNbaV07XHJcbiAgICAgICAgICAgIHZhciBjb21tYW5kID0gR3JhcGhpY3NHZW9tZXRyeS5maWxsQ29tbWFuZHNbaG9sZS50eXBlXTtcclxuICAgICAgICAgICAgY29tbWFuZC5idWlsZChob2xlKTtcclxuICAgICAgICAgICAgaWYgKGhvbGUubWF0cml4KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRyYW5zZm9ybVBvaW50cyhob2xlLnBvaW50cywgaG9sZS5tYXRyaXgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGUgdGhlIGxvY2FsIGJvdW5kcyBvZiB0aGUgb2JqZWN0LiBFeHBlbnNpdmUgdG8gdXNlIHBlcmZvcm1hbmNlLXdpc2UuXHJcbiAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgKi9cclxuICAgIGNhbGN1bGF0ZUJvdW5kcygpIHtcclxuICAgICAgICB2YXIgbWluWCA9IEluZmluaXR5O1xyXG4gICAgICAgIHZhciBtYXhYID0gLUluZmluaXR5O1xyXG4gICAgICAgIHZhciBtaW5ZID0gSW5maW5pdHk7XHJcbiAgICAgICAgdmFyIG1heFkgPSAtSW5maW5pdHk7XHJcbiAgICAgICAgaWYgKHRoaXMuZ3JhcGhpY3NEYXRhLmxlbmd0aCkge1xyXG4gICAgICAgICAgICB2YXIgc2hhcGUgPSBudWxsO1xyXG4gICAgICAgICAgICB2YXIgeCA9IDA7XHJcbiAgICAgICAgICAgIHZhciB5ID0gMDtcclxuICAgICAgICAgICAgdmFyIHcgPSAwO1xyXG4gICAgICAgICAgICB2YXIgaCA9IDA7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5ncmFwaGljc0RhdGEubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5ncmFwaGljc0RhdGFbaV07XHJcbiAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IGRhdGEudHlwZTtcclxuICAgICAgICAgICAgICAgIHZhciBsaW5lV2lkdGggPSBkYXRhLmxpbmVTdHlsZSA/IGRhdGEubGluZVN0eWxlLndpZHRoIDogMDtcclxuICAgICAgICAgICAgICAgIHNoYXBlID0gZGF0YS5zaGFwZTtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSBTaGFwZVNldHRpbmdzXzEuU2hhcGVTZXR0aW5ncy5TSEFQRVMuUkVDVCB8fCB0eXBlID09PSBTaGFwZVNldHRpbmdzXzEuU2hhcGVTZXR0aW5ncy5TSEFQRVMuUlJFQykge1xyXG4gICAgICAgICAgICAgICAgICAgIHggPSBzaGFwZS54IC0gKGxpbmVXaWR0aCAvIDIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHkgPSBzaGFwZS55IC0gKGxpbmVXaWR0aCAvIDIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHcgPSBzaGFwZS53aWR0aCArIGxpbmVXaWR0aDtcclxuICAgICAgICAgICAgICAgICAgICBoID0gc2hhcGUuaGVpZ2h0ICsgbGluZVdpZHRoO1xyXG4gICAgICAgICAgICAgICAgICAgIG1pblggPSB4IDwgbWluWCA/IHggOiBtaW5YO1xyXG4gICAgICAgICAgICAgICAgICAgIG1heFggPSB4ICsgdyA+IG1heFggPyB4ICsgdyA6IG1heFg7XHJcbiAgICAgICAgICAgICAgICAgICAgbWluWSA9IHkgPCBtaW5ZID8geSA6IG1pblk7XHJcbiAgICAgICAgICAgICAgICAgICAgbWF4WSA9IHkgKyBoID4gbWF4WSA/IHkgKyBoIDogbWF4WTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT09IFNoYXBlU2V0dGluZ3NfMS5TaGFwZVNldHRpbmdzLlNIQVBFUy5DSVJDKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgeCA9IHNoYXBlLng7XHJcbiAgICAgICAgICAgICAgICAgICAgeSA9IHNoYXBlLnk7XHJcbiAgICAgICAgICAgICAgICAgICAgdyA9IHNoYXBlLnJhZGl1cyArIChsaW5lV2lkdGggLyAyKTtcclxuICAgICAgICAgICAgICAgICAgICBoID0gc2hhcGUucmFkaXVzICsgKGxpbmVXaWR0aCAvIDIpO1xyXG4gICAgICAgICAgICAgICAgICAgIG1pblggPSB4IC0gdyA8IG1pblggPyB4IC0gdyA6IG1pblg7XHJcbiAgICAgICAgICAgICAgICAgICAgbWF4WCA9IHggKyB3ID4gbWF4WCA/IHggKyB3IDogbWF4WDtcclxuICAgICAgICAgICAgICAgICAgICBtaW5ZID0geSAtIGggPCBtaW5ZID8geSAtIGggOiBtaW5ZO1xyXG4gICAgICAgICAgICAgICAgICAgIG1heFkgPSB5ICsgaCA+IG1heFkgPyB5ICsgaCA6IG1heFk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlID09PSBTaGFwZVNldHRpbmdzXzEuU2hhcGVTZXR0aW5ncy5TSEFQRVMuRUxJUCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHggPSBzaGFwZS54O1xyXG4gICAgICAgICAgICAgICAgICAgIHkgPSBzaGFwZS55O1xyXG4gICAgICAgICAgICAgICAgICAgIHcgPSBzaGFwZS53aWR0aCArIChsaW5lV2lkdGggLyAyKTtcclxuICAgICAgICAgICAgICAgICAgICBoID0gc2hhcGUuaGVpZ2h0ICsgKGxpbmVXaWR0aCAvIDIpO1xyXG4gICAgICAgICAgICAgICAgICAgIG1pblggPSB4IC0gdyA8IG1pblggPyB4IC0gdyA6IG1pblg7XHJcbiAgICAgICAgICAgICAgICAgICAgbWF4WCA9IHggKyB3ID4gbWF4WCA/IHggKyB3IDogbWF4WDtcclxuICAgICAgICAgICAgICAgICAgICBtaW5ZID0geSAtIGggPCBtaW5ZID8geSAtIGggOiBtaW5ZO1xyXG4gICAgICAgICAgICAgICAgICAgIG1heFkgPSB5ICsgaCA+IG1heFkgPyB5ICsgaCA6IG1heFk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBQT0xZXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBvaW50cyA9IHNoYXBlLnBvaW50cztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgeDIgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB5MiA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGR4ID0gMDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZHkgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBydyA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJoID0gMDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY3ggPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjeSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogKyAyIDwgcG9pbnRzLmxlbmd0aDsgaiArPSAyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHggPSBwb2ludHNbal07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHkgPSBwb2ludHNbaiArIDFdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB4MiA9IHBvaW50c1tqICsgMl07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHkyID0gcG9pbnRzW2ogKyAzXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZHggPSBNYXRoLmFicyh4MiAtIHgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkeSA9IE1hdGguYWJzKHkyIC0geSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGggPSBsaW5lV2lkdGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHcgPSBNYXRoLnNxcnQoKGR4ICogZHgpICsgKGR5ICogZHkpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHcgPCAxZS05KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBydyA9ICgoaCAvIHcgKiBkeSkgKyBkeCkgLyAyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByaCA9ICgoaCAvIHcgKiBkeCkgKyBkeSkgLyAyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjeCA9ICh4MiArIHgpIC8gMjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3kgPSAoeTIgKyB5KSAvIDI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pblggPSBjeCAtIHJ3IDwgbWluWCA/IGN4IC0gcncgOiBtaW5YO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhYID0gY3ggKyBydyA+IG1heFggPyBjeCArIHJ3IDogbWF4WDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWluWSA9IGN5IC0gcmggPCBtaW5ZID8gY3kgLSByaCA6IG1pblk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heFkgPSBjeSArIHJoID4gbWF4WSA/IGN5ICsgcmggOiBtYXhZO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbWluWCA9IDA7XHJcbiAgICAgICAgICAgIG1heFggPSAwO1xyXG4gICAgICAgICAgICBtaW5ZID0gMDtcclxuICAgICAgICAgICAgbWF4WSA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBwYWRkaW5nID0gdGhpcy5ib3VuZHNQYWRkaW5nO1xyXG4gICAgICAgIHRoaXMuX2JvdW5kcy5taW5YID0gbWluWCAtIHBhZGRpbmc7XHJcbiAgICAgICAgdGhpcy5fYm91bmRzLm1heFggPSBtYXhYICsgcGFkZGluZztcclxuICAgICAgICB0aGlzLl9ib3VuZHMubWluWSA9IG1pblkgLSBwYWRkaW5nO1xyXG4gICAgICAgIHRoaXMuX2JvdW5kcy5tYXhZID0gbWF4WSArIHBhZGRpbmc7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFRyYW5zZm9ybSBwb2ludHMgdXNpbmcgbWF0cml4LlxyXG4gICAgICpcclxuICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyW119IHBvaW50cyAtIFBvaW50cyB0byB0cmFuc2Zvcm1cclxuICAgICAqIEBwYXJhbSB7UElYSS5NYXRyaXh9IG1hdHJpeCAtIFRyYW5zZm9ybSBtYXRyaXhcclxuICAgICAqL1xyXG4gICAgdHJhbnNmb3JtUG9pbnRzKHBvaW50cywgbWF0cml4KSB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoIC8gMjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciB4ID0gcG9pbnRzWyhpICogMildO1xyXG4gICAgICAgICAgICB2YXIgeSA9IHBvaW50c1soaSAqIDIpICsgMV07XHJcbiAgICAgICAgICAgIHBvaW50c1soaSAqIDIpXSA9IChtYXRyaXguYSAqIHgpICsgKG1hdHJpeC5jICogeSkgKyBtYXRyaXgudHg7XHJcbiAgICAgICAgICAgIHBvaW50c1soaSAqIDIpICsgMV0gPSAobWF0cml4LmIgKiB4KSArIChtYXRyaXguZCAqIHkpICsgbWF0cml4LnR5O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQWRkIGNvbG9ycy5cclxuICAgICAqXHJcbiAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcltdfSBjb2xvcnMgLSBMaXN0IG9mIGNvbG9ycyB0byBhZGQgdG9cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb2xvciAtIENvbG9yIHRvIGFkZFxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGFscGhhIC0gQWxwaGEgdG8gdXNlXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2l6ZSAtIE51bWJlciBvZiBjb2xvcnMgdG8gYWRkXHJcbiAgICAgKi9cclxuICAgIGFkZENvbG9ycyhjb2xvcnMsIGNvbG9yLCBhbHBoYSwgc2l6ZSkge1xyXG4gICAgICAgIC8vIFRPRE8gdXNlIHRoZSBwcmVtdWx0aXBseSBiaXRzIEl2YW4gYWRkZWRcclxuICAgICAgICB2YXIgcmdiID0gKGNvbG9yID4+IDE2KSArIChjb2xvciAmIDB4ZmYwMCkgKyAoKGNvbG9yICYgMHhmZikgPDwgMTYpO1xyXG4gICAgICAgIHZhciByZ2JhID0gQ29sb3JTZXR0aW5nc18xLkNvbG9yU2V0dGluZ3MucHJlbXVsdGlwbHlUaW50KHJnYiwgYWxwaGEpO1xyXG4gICAgICAgIHdoaWxlIChzaXplLS0gPiAwKSB7XHJcbiAgICAgICAgICAgIGNvbG9ycy5wdXNoKHJnYmEpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQWRkIHRleHR1cmUgaWQgdGhhdCB0aGUgc2hhZGVyL2ZyYWdtZW50IHdhbnRzIHRvIHVzZS5cclxuICAgICAqXHJcbiAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcltdfSB0ZXh0dXJlSWRzXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaWRcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzaXplXHJcbiAgICAgKi9cclxuICAgIGFkZFRleHR1cmVJZHModGV4dHVyZUlkcywgaWQsIHNpemUpIHtcclxuICAgICAgICB3aGlsZSAoc2l6ZS0tID4gMCkge1xyXG4gICAgICAgICAgICB0ZXh0dXJlSWRzLnB1c2goaWQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogR2VuZXJhdGVzIHRoZSBVVnMgZm9yIGEgc2hhcGUuXHJcbiAgICAgKlxyXG4gICAgICogQHByb3RlY3RlZFxyXG4gICAgICogQHBhcmFtIHtudW1iZXJbXX0gdmVydHMgLSBWZXJ0aWNlc1xyXG4gICAgICogQHBhcmFtIHtudW1iZXJbXX0gdXZzIC0gVVZzXHJcbiAgICAgKiBAcGFyYW0ge1BJWEkuVGV4dHVyZX0gdGV4dHVyZSAtIFJlZmVyZW5jZSB0byBUZXh0dXJlXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgLSBJbmRleCBidWZmZXIgc3RhcnQgaW5kZXguXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2l6ZSAtIFRoZSBzaXplL2xlbmd0aCBmb3IgaW5kZXggYnVmZmVyLlxyXG4gICAgICogQHBhcmFtIHtQSVhJLk1hdHJpeH0gW21hdHJpeF0gLSBPcHRpb25hbCB0cmFuc2Zvcm0gZm9yIGFsbCBwb2ludHMuXHJcbiAgICAgKi9cclxuICAgIGFkZFV2cyh2ZXJ0cywgdXZzLCB0ZXh0dXJlLCBzdGFydCwgc2l6ZSwgbWF0cml4KSB7XHJcbiAgICAgICAgdmFyIGluZGV4ID0gMDtcclxuICAgICAgICB2YXIgdXZzU3RhcnQgPSB1dnMubGVuZ3RoO1xyXG4gICAgICAgIHZhciBmcmFtZSA9IHRleHR1cmUuZnJhbWU7XHJcbiAgICAgICAgd2hpbGUgKGluZGV4IDwgc2l6ZSkge1xyXG4gICAgICAgICAgICB2YXIgeCA9IHZlcnRzWyhzdGFydCArIGluZGV4KSAqIDJdO1xyXG4gICAgICAgICAgICB2YXIgeSA9IHZlcnRzWygoc3RhcnQgKyBpbmRleCkgKiAyKSArIDFdO1xyXG4gICAgICAgICAgICBpZiAobWF0cml4KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbnggPSAobWF0cml4LmEgKiB4KSArIChtYXRyaXguYyAqIHkpICsgbWF0cml4LnR4O1xyXG4gICAgICAgICAgICAgICAgeSA9IChtYXRyaXguYiAqIHgpICsgKG1hdHJpeC5kICogeSkgKyBtYXRyaXgudHk7XHJcbiAgICAgICAgICAgICAgICB4ID0gbng7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaW5kZXgrKztcclxuICAgICAgICAgICAgdXZzLnB1c2goeCAvIGZyYW1lLndpZHRoLCB5IC8gZnJhbWUuaGVpZ2h0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGJhc2VUZXh0dXJlID0gdGV4dHVyZS5iYXNlVGV4dHVyZTtcclxuICAgICAgICBpZiAoZnJhbWUud2lkdGggPCBiYXNlVGV4dHVyZS53aWR0aFxyXG4gICAgICAgICAgICB8fCBmcmFtZS5oZWlnaHQgPCBiYXNlVGV4dHVyZS5oZWlnaHQpIHtcclxuICAgICAgICAgICAgdGhpcy5hZGp1c3RVdnModXZzLCB0ZXh0dXJlLCB1dnNTdGFydCwgc2l6ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBNb2RpZnkgdXZzIGFycmF5IGFjY29yZGluZyB0byBwb3NpdGlvbiBvZiB0ZXh0dXJlIHJlZ2lvblxyXG4gICAgICogRG9lcyBub3Qgd29yayB3aXRoIHJvdGF0ZWQgb3IgdHJpbW1lZCB0ZXh0dXJlc1xyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHV2cyBhcnJheVxyXG4gICAgICogQHBhcmFtIHtQSVhJLlRleHR1cmV9IHRleHR1cmUgcmVnaW9uXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgc3RhcnRpbmcgaW5kZXggZm9yIHV2c1xyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNpemUgaG93IG1hbnkgcG9pbnRzIHRvIGFkanVzdFxyXG4gICAgICovXHJcbiAgICBhZGp1c3RVdnModXZzLCB0ZXh0dXJlLCBzdGFydCwgc2l6ZSkge1xyXG4gICAgICAgIHZhciBiYXNlVGV4dHVyZSA9IHRleHR1cmUuYmFzZVRleHR1cmU7XHJcbiAgICAgICAgdmFyIGVwcyA9IDFlLTY7XHJcbiAgICAgICAgdmFyIGZpbmlzaCA9IHN0YXJ0ICsgKHNpemUgKiAyKTtcclxuICAgICAgICB2YXIgZnJhbWUgPSB0ZXh0dXJlLmZyYW1lO1xyXG4gICAgICAgIHZhciBzY2FsZVggPSBmcmFtZS53aWR0aCAvIGJhc2VUZXh0dXJlLndpZHRoO1xyXG4gICAgICAgIHZhciBzY2FsZVkgPSBmcmFtZS5oZWlnaHQgLyBiYXNlVGV4dHVyZS5oZWlnaHQ7XHJcbiAgICAgICAgdmFyIG9mZnNldFggPSBmcmFtZS54IC8gZnJhbWUud2lkdGg7XHJcbiAgICAgICAgdmFyIG9mZnNldFkgPSBmcmFtZS55IC8gZnJhbWUud2lkdGg7XHJcbiAgICAgICAgdmFyIG1pblggPSBNYXRoLmZsb29yKHV2c1tzdGFydF0gKyBlcHMpO1xyXG4gICAgICAgIHZhciBtaW5ZID0gTWF0aC5mbG9vcih1dnNbc3RhcnQgKyAxXSArIGVwcyk7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0ICsgMjsgaSA8IGZpbmlzaDsgaSArPSAyKSB7XHJcbiAgICAgICAgICAgIG1pblggPSBNYXRoLm1pbihtaW5YLCBNYXRoLmZsb29yKHV2c1tpXSArIGVwcykpO1xyXG4gICAgICAgICAgICBtaW5ZID0gTWF0aC5taW4obWluWSwgTWF0aC5mbG9vcih1dnNbaSArIDFdICsgZXBzKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG9mZnNldFggLT0gbWluWDtcclxuICAgICAgICBvZmZzZXRZIC09IG1pblk7XHJcbiAgICAgICAgZm9yICh2YXIgaSQxID0gc3RhcnQ7IGkkMSA8IGZpbmlzaDsgaSQxICs9IDIpIHtcclxuICAgICAgICAgICAgdXZzW2kkMV0gPSAodXZzW2kkMV0gKyBvZmZzZXRYKSAqIHNjYWxlWDtcclxuICAgICAgICAgICAgdXZzW2kkMSArIDFdID0gKHV2c1tpJDEgKyAxXSArIG9mZnNldFkpICogc2NhbGVZO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gKiBCdWlsZHMgYSBsaW5lIHRvIGRyYXdcclxuICpcclxuICogSWdub3JlZCBmcm9tIGRvY3Mgc2luY2UgaXQgaXMgbm90IGRpcmVjdGx5IGV4cG9zZWQuXHJcbiAqXHJcbiAqIEBpZ25vcmVcclxuICogQHByaXZhdGVcclxuICogQHBhcmFtIHtQSVhJLkdyYXBoaWNzRGF0YX0gZ3JhcGhpY3NEYXRhIC0gVGhlIGdyYXBoaWNzIG9iamVjdCBjb250YWluaW5nIGFsbCB0aGUgbmVjZXNzYXJ5IHByb3BlcnRpZXNcclxuICogQHBhcmFtIHtQSVhJLkdyYXBoaWNzR2VvbWV0cnl9IGdyYXBoaWNzR2VvbWV0cnkgLSBHZW9tZXRyeSB3aGVyZSB0byBhcHBlbmQgb3V0cHV0XHJcbiAqL1xyXG4gICAgc3RhdGljIGJ1aWxkTGluZShncmFwaGljc0RhdGEsIGdyYXBoaWNzR2VvbWV0cnkpIHtcclxuICAgICAgICBpZiAoZ3JhcGhpY3NEYXRhLmxpbmVTdHlsZS5uYXRpdmUpIHtcclxuICAgICAgICAgICAgR3JhcGhpY3NHZW9tZXRyeS5idWlsZE5hdGl2ZUxpbmUoZ3JhcGhpY3NEYXRhLCBncmFwaGljc0dlb21ldHJ5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIEdyYXBoaWNzR2VvbWV0cnkuYnVpbGRMaW5lJDEoZ3JhcGhpY3NEYXRhLCBncmFwaGljc0dlb21ldHJ5KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICogQnVpbGRzIGEgbGluZSB0byBkcmF3IHVzaW5nIHRoZSBnbC5kcmF3QXJyYXlzKGdsLkxJTkVTKSBtZXRob2RcclxuICpcclxuICogSWdub3JlZCBmcm9tIGRvY3Mgc2luY2UgaXQgaXMgbm90IGRpcmVjdGx5IGV4cG9zZWQuXHJcbiAqXHJcbiAqIEBpZ25vcmVcclxuICogQHByaXZhdGVcclxuICogQHBhcmFtIHtQSVhJLkdyYXBoaWNzRGF0YX0gZ3JhcGhpY3NEYXRhIC0gVGhlIGdyYXBoaWNzIG9iamVjdCBjb250YWluaW5nIGFsbCB0aGUgbmVjZXNzYXJ5IHByb3BlcnRpZXNcclxuICogQHBhcmFtIHtQSVhJLkdyYXBoaWNzR2VvbWV0cnl9IGdyYXBoaWNzR2VvbWV0cnkgLSBHZW9tZXRyeSB3aGVyZSB0byBhcHBlbmQgb3V0cHV0XHJcbiAqL1xyXG4gICAgc3RhdGljIGJ1aWxkTmF0aXZlTGluZShncmFwaGljc0RhdGEsIGdyYXBoaWNzR2VvbWV0cnkpIHtcclxuICAgICAgICB2YXIgaSA9IDA7XHJcbiAgICAgICAgdmFyIHBvaW50cyA9IGdyYXBoaWNzRGF0YS5wb2ludHMgfHwgZ3JhcGhpY3NEYXRhLnNoYXBlLnBvaW50cztcclxuICAgICAgICBpZiAocG9pbnRzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciB2ZXJ0cyA9IGdyYXBoaWNzR2VvbWV0cnkucG9pbnRzO1xyXG4gICAgICAgIHZhciBpbmRpY2VzID0gZ3JhcGhpY3NHZW9tZXRyeS5pbmRpY2VzO1xyXG4gICAgICAgIHZhciBsZW5ndGggPSBwb2ludHMubGVuZ3RoIC8gMjtcclxuICAgICAgICB2YXIgaW5kZXhTdGFydCA9IHZlcnRzLmxlbmd0aCAvIDI7XHJcbiAgICAgICAgLy8gc29ydCBjb2xvclxyXG4gICAgICAgIGZvciAoaSA9IDE7IGkgPCBsZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgcDF4ID0gcG9pbnRzWyhpIC0gMSkgKiAyXTtcclxuICAgICAgICAgICAgdmFyIHAxeSA9IHBvaW50c1soKGkgLSAxKSAqIDIpICsgMV07XHJcbiAgICAgICAgICAgIHZhciBwMnggPSBwb2ludHNbaSAqIDJdO1xyXG4gICAgICAgICAgICB2YXIgcDJ5ID0gcG9pbnRzWyhpICogMikgKyAxXTtcclxuICAgICAgICAgICAgdmVydHMucHVzaChwMXgsIHAxeSk7XHJcbiAgICAgICAgICAgIHZlcnRzLnB1c2gocDJ4LCBwMnkpO1xyXG4gICAgICAgICAgICBpbmRpY2VzLnB1c2goaW5kZXhTdGFydCsrLCBpbmRleFN0YXJ0KyspO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gKiBCdWlsZHMgYSBsaW5lIHRvIGRyYXcgdXNpbmcgdGhlIHBvbHlnb24gbWV0aG9kLlxyXG4gKlxyXG4gKiBJZ25vcmVkIGZyb20gZG9jcyBzaW5jZSBpdCBpcyBub3QgZGlyZWN0bHkgZXhwb3NlZC5cclxuICpcclxuICogQGlnbm9yZVxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAcGFyYW0ge1BJWEkuR3JhcGhpY3NEYXRhfSBncmFwaGljc0RhdGEgLSBUaGUgZ3JhcGhpY3Mgb2JqZWN0IGNvbnRhaW5pbmcgYWxsIHRoZSBuZWNlc3NhcnkgcHJvcGVydGllc1xyXG4gKiBAcGFyYW0ge1BJWEkuR3JhcGhpY3NHZW9tZXRyeX0gZ3JhcGhpY3NHZW9tZXRyeSAtIEdlb21ldHJ5IHdoZXJlIHRvIGFwcGVuZCBvdXRwdXRcclxuICovXHJcbiAgICBzdGF0aWMgYnVpbGRMaW5lJDEoZ3JhcGhpY3NEYXRhLCBncmFwaGljc0dlb21ldHJ5KSB7XHJcbiAgICAgICAgdmFyIHNoYXBlID0gZ3JhcGhpY3NEYXRhLnNoYXBlO1xyXG4gICAgICAgIHZhciBwb2ludHMgPSBncmFwaGljc0RhdGEucG9pbnRzIHx8IHNoYXBlLnBvaW50cy5zbGljZSgpO1xyXG4gICAgICAgIGlmIChwb2ludHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gaWYgdGhlIGxpbmUgd2lkdGggaXMgYW4gb2RkIG51bWJlciBhZGQgMC41IHRvIGFsaWduIHRvIGEgd2hvbGUgcGl4ZWxcclxuICAgICAgICAvLyBjb21tZW50aW5nIHRoaXMgb3V0IGZpeGVzICM3MTEgYW5kICMxNjIwXHJcbiAgICAgICAgLy8gaWYgKGdyYXBoaWNzRGF0YS5saW5lV2lkdGglMilcclxuICAgICAgICAvLyB7XHJcbiAgICAgICAgLy8gICAgIGZvciAoaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgLy8gICAgIHtcclxuICAgICAgICAvLyAgICAgICAgIHBvaW50c1tpXSArPSAwLjU7XHJcbiAgICAgICAgLy8gICAgIH1cclxuICAgICAgICAvLyB9XHJcbiAgICAgICAgdmFyIHN0eWxlID0gZ3JhcGhpY3NEYXRhLmxpbmVTdHlsZTtcclxuICAgICAgICAvLyBnZXQgZmlyc3QgYW5kIGxhc3QgcG9pbnQuLiBmaWd1cmUgb3V0IHRoZSBtaWRkbGUhXHJcbiAgICAgICAgdmFyIGZpcnN0UG9pbnQgPSBuZXcgUG9pbnRfMS5Qb2ludChwb2ludHNbMF0sIHBvaW50c1sxXSk7XHJcbiAgICAgICAgdmFyIGxhc3RQb2ludCA9IG5ldyBQb2ludF8xLlBvaW50KHBvaW50c1twb2ludHMubGVuZ3RoIC0gMl0sIHBvaW50c1twb2ludHMubGVuZ3RoIC0gMV0pO1xyXG4gICAgICAgIHZhciBjbG9zZWRTaGFwZSA9IHNoYXBlLnR5cGUgIT09IFNoYXBlU2V0dGluZ3NfMS5TaGFwZVNldHRpbmdzLlNIQVBFUy5QT0xZIHx8IHNoYXBlLmNsb3NlU3Ryb2tlO1xyXG4gICAgICAgIHZhciBjbG9zZWRQYXRoID0gZmlyc3RQb2ludC54ID09PSBsYXN0UG9pbnQueCAmJiBmaXJzdFBvaW50LnkgPT09IGxhc3RQb2ludC55O1xyXG4gICAgICAgIC8vIGlmIHRoZSBmaXJzdCBwb2ludCBpcyB0aGUgbGFzdCBwb2ludCAtIGdvbm5hIGhhdmUgaXNzdWVzIDopXHJcbiAgICAgICAgaWYgKGNsb3NlZFNoYXBlKSB7XHJcbiAgICAgICAgICAgIC8vIG5lZWQgdG8gY2xvbmUgYXMgd2UgYXJlIGdvaW5nIHRvIHNsaWdodGx5IG1vZGlmeSB0aGUgc2hhcGUuLlxyXG4gICAgICAgICAgICBwb2ludHMgPSBwb2ludHMuc2xpY2UoKTtcclxuICAgICAgICAgICAgaWYgKGNsb3NlZFBhdGgpIHtcclxuICAgICAgICAgICAgICAgIHBvaW50cy5wb3AoKTtcclxuICAgICAgICAgICAgICAgIHBvaW50cy5wb3AoKTtcclxuICAgICAgICAgICAgICAgIGxhc3RQb2ludC5zZXQocG9pbnRzW3BvaW50cy5sZW5ndGggLSAyXSwgcG9pbnRzW3BvaW50cy5sZW5ndGggLSAxXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIG1pZFBvaW50WCA9IGxhc3RQb2ludC54ICsgKChmaXJzdFBvaW50LnggLSBsYXN0UG9pbnQueCkgKiAwLjUpO1xyXG4gICAgICAgICAgICB2YXIgbWlkUG9pbnRZID0gbGFzdFBvaW50LnkgKyAoKGZpcnN0UG9pbnQueSAtIGxhc3RQb2ludC55KSAqIDAuNSk7XHJcbiAgICAgICAgICAgIHBvaW50cy51bnNoaWZ0KG1pZFBvaW50WCwgbWlkUG9pbnRZKTtcclxuICAgICAgICAgICAgcG9pbnRzLnB1c2gobWlkUG9pbnRYLCBtaWRQb2ludFkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgdmVydHMgPSBncmFwaGljc0dlb21ldHJ5LnBvaW50cztcclxuICAgICAgICB2YXIgbGVuZ3RoID0gcG9pbnRzLmxlbmd0aCAvIDI7XHJcbiAgICAgICAgdmFyIGluZGV4Q291bnQgPSBwb2ludHMubGVuZ3RoO1xyXG4gICAgICAgIHZhciBpbmRleFN0YXJ0ID0gdmVydHMubGVuZ3RoIC8gMjtcclxuICAgICAgICAvLyBEUkFXIHRoZSBMaW5lXHJcbiAgICAgICAgdmFyIHdpZHRoID0gc3R5bGUud2lkdGggLyAyO1xyXG4gICAgICAgIC8vIHNvcnQgY29sb3JcclxuICAgICAgICB2YXIgcDF4ID0gcG9pbnRzWzBdO1xyXG4gICAgICAgIHZhciBwMXkgPSBwb2ludHNbMV07XHJcbiAgICAgICAgdmFyIHAyeCA9IHBvaW50c1syXTtcclxuICAgICAgICB2YXIgcDJ5ID0gcG9pbnRzWzNdO1xyXG4gICAgICAgIHZhciBwM3ggPSAwO1xyXG4gICAgICAgIHZhciBwM3kgPSAwO1xyXG4gICAgICAgIHZhciBwZXJweCA9IC0ocDF5IC0gcDJ5KTtcclxuICAgICAgICB2YXIgcGVycHkgPSBwMXggLSBwMng7XHJcbiAgICAgICAgdmFyIHBlcnAyeCA9IDA7XHJcbiAgICAgICAgdmFyIHBlcnAyeSA9IDA7XHJcbiAgICAgICAgdmFyIHBlcnAzeCA9IDA7XHJcbiAgICAgICAgdmFyIHBlcnAzeSA9IDA7XHJcbiAgICAgICAgdmFyIGRpc3QgPSBNYXRoLnNxcnQoKHBlcnB4ICogcGVycHgpICsgKHBlcnB5ICogcGVycHkpKTtcclxuICAgICAgICBwZXJweCAvPSBkaXN0O1xyXG4gICAgICAgIHBlcnB5IC89IGRpc3Q7XHJcbiAgICAgICAgcGVycHggKj0gd2lkdGg7XHJcbiAgICAgICAgcGVycHkgKj0gd2lkdGg7XHJcbiAgICAgICAgdmFyIHJhdGlvID0gc3R5bGUuYWxpZ25tZW50OyAvLyAwLjU7XHJcbiAgICAgICAgdmFyIHIxID0gKDEgLSByYXRpbykgKiAyO1xyXG4gICAgICAgIHZhciByMiA9IHJhdGlvICogMjtcclxuICAgICAgICAvLyBzdGFydFxyXG4gICAgICAgIHZlcnRzLnB1c2gocDF4IC0gKHBlcnB4ICogcjEpLCBwMXkgLSAocGVycHkgKiByMSkpO1xyXG4gICAgICAgIHZlcnRzLnB1c2gocDF4ICsgKHBlcnB4ICogcjIpLCBwMXkgKyAocGVycHkgKiByMikpO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgbGVuZ3RoIC0gMTsgKytpKSB7XHJcbiAgICAgICAgICAgIHAxeCA9IHBvaW50c1soaSAtIDEpICogMl07XHJcbiAgICAgICAgICAgIHAxeSA9IHBvaW50c1soKGkgLSAxKSAqIDIpICsgMV07XHJcbiAgICAgICAgICAgIHAyeCA9IHBvaW50c1tpICogMl07XHJcbiAgICAgICAgICAgIHAyeSA9IHBvaW50c1soaSAqIDIpICsgMV07XHJcbiAgICAgICAgICAgIHAzeCA9IHBvaW50c1soaSArIDEpICogMl07XHJcbiAgICAgICAgICAgIHAzeSA9IHBvaW50c1soKGkgKyAxKSAqIDIpICsgMV07XHJcbiAgICAgICAgICAgIHBlcnB4ID0gLShwMXkgLSBwMnkpO1xyXG4gICAgICAgICAgICBwZXJweSA9IHAxeCAtIHAyeDtcclxuICAgICAgICAgICAgZGlzdCA9IE1hdGguc3FydCgocGVycHggKiBwZXJweCkgKyAocGVycHkgKiBwZXJweSkpO1xyXG4gICAgICAgICAgICBwZXJweCAvPSBkaXN0O1xyXG4gICAgICAgICAgICBwZXJweSAvPSBkaXN0O1xyXG4gICAgICAgICAgICBwZXJweCAqPSB3aWR0aDtcclxuICAgICAgICAgICAgcGVycHkgKj0gd2lkdGg7XHJcbiAgICAgICAgICAgIHBlcnAyeCA9IC0ocDJ5IC0gcDN5KTtcclxuICAgICAgICAgICAgcGVycDJ5ID0gcDJ4IC0gcDN4O1xyXG4gICAgICAgICAgICBkaXN0ID0gTWF0aC5zcXJ0KChwZXJwMnggKiBwZXJwMngpICsgKHBlcnAyeSAqIHBlcnAyeSkpO1xyXG4gICAgICAgICAgICBwZXJwMnggLz0gZGlzdDtcclxuICAgICAgICAgICAgcGVycDJ5IC89IGRpc3Q7XHJcbiAgICAgICAgICAgIHBlcnAyeCAqPSB3aWR0aDtcclxuICAgICAgICAgICAgcGVycDJ5ICo9IHdpZHRoO1xyXG4gICAgICAgICAgICB2YXIgYTEgPSAoLXBlcnB5ICsgcDF5KSAtICgtcGVycHkgKyBwMnkpO1xyXG4gICAgICAgICAgICB2YXIgYjEgPSAoLXBlcnB4ICsgcDJ4KSAtICgtcGVycHggKyBwMXgpO1xyXG4gICAgICAgICAgICB2YXIgYzEgPSAoKC1wZXJweCArIHAxeCkgKiAoLXBlcnB5ICsgcDJ5KSkgLSAoKC1wZXJweCArIHAyeCkgKiAoLXBlcnB5ICsgcDF5KSk7XHJcbiAgICAgICAgICAgIHZhciBhMiA9ICgtcGVycDJ5ICsgcDN5KSAtICgtcGVycDJ5ICsgcDJ5KTtcclxuICAgICAgICAgICAgdmFyIGIyID0gKC1wZXJwMnggKyBwMngpIC0gKC1wZXJwMnggKyBwM3gpO1xyXG4gICAgICAgICAgICB2YXIgYzIgPSAoKC1wZXJwMnggKyBwM3gpICogKC1wZXJwMnkgKyBwMnkpKSAtICgoLXBlcnAyeCArIHAyeCkgKiAoLXBlcnAyeSArIHAzeSkpO1xyXG4gICAgICAgICAgICB2YXIgZGVub20gPSAoYTEgKiBiMikgLSAoYTIgKiBiMSk7XHJcbiAgICAgICAgICAgIGlmIChNYXRoLmFicyhkZW5vbSkgPCAwLjEpIHtcclxuICAgICAgICAgICAgICAgIGRlbm9tICs9IDEwLjE7XHJcbiAgICAgICAgICAgICAgICB2ZXJ0cy5wdXNoKHAyeCAtIChwZXJweCAqIHIxKSwgcDJ5IC0gKHBlcnB5ICogcjEpKTtcclxuICAgICAgICAgICAgICAgIHZlcnRzLnB1c2gocDJ4ICsgKHBlcnB4ICogcjIpLCBwMnkgKyAocGVycHkgKiByMikpO1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHB4ID0gKChiMSAqIGMyKSAtIChiMiAqIGMxKSkgLyBkZW5vbTtcclxuICAgICAgICAgICAgdmFyIHB5ID0gKChhMiAqIGMxKSAtIChhMSAqIGMyKSkgLyBkZW5vbTtcclxuICAgICAgICAgICAgdmFyIHBkaXN0ID0gKChweCAtIHAyeCkgKiAocHggLSBwMngpKSArICgocHkgLSBwMnkpICogKHB5IC0gcDJ5KSk7XHJcbiAgICAgICAgICAgIGlmIChwZGlzdCA+ICgxOTYgKiB3aWR0aCAqIHdpZHRoKSkge1xyXG4gICAgICAgICAgICAgICAgcGVycDN4ID0gcGVycHggLSBwZXJwMng7XHJcbiAgICAgICAgICAgICAgICBwZXJwM3kgPSBwZXJweSAtIHBlcnAyeTtcclxuICAgICAgICAgICAgICAgIGRpc3QgPSBNYXRoLnNxcnQoKHBlcnAzeCAqIHBlcnAzeCkgKyAocGVycDN5ICogcGVycDN5KSk7XHJcbiAgICAgICAgICAgICAgICBwZXJwM3ggLz0gZGlzdDtcclxuICAgICAgICAgICAgICAgIHBlcnAzeSAvPSBkaXN0O1xyXG4gICAgICAgICAgICAgICAgcGVycDN4ICo9IHdpZHRoO1xyXG4gICAgICAgICAgICAgICAgcGVycDN5ICo9IHdpZHRoO1xyXG4gICAgICAgICAgICAgICAgdmVydHMucHVzaChwMnggLSAocGVycDN4ICogcjEpLCBwMnkgLSAocGVycDN5ICogcjEpKTtcclxuICAgICAgICAgICAgICAgIHZlcnRzLnB1c2gocDJ4ICsgKHBlcnAzeCAqIHIyKSwgcDJ5ICsgKHBlcnAzeSAqIHIyKSk7XHJcbiAgICAgICAgICAgICAgICB2ZXJ0cy5wdXNoKHAyeCAtIChwZXJwM3ggKiByMiAqIHIxKSwgcDJ5IC0gKHBlcnAzeSAqIHIxKSk7XHJcbiAgICAgICAgICAgICAgICBpbmRleENvdW50Kys7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2ZXJ0cy5wdXNoKHAyeCArICgocHggLSBwMngpICogcjEpLCBwMnkgKyAoKHB5IC0gcDJ5KSAqIHIxKSk7XHJcbiAgICAgICAgICAgICAgICB2ZXJ0cy5wdXNoKHAyeCAtICgocHggLSBwMngpICogcjIpLCBwMnkgLSAoKHB5IC0gcDJ5KSAqIHIyKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcDF4ID0gcG9pbnRzWyhsZW5ndGggLSAyKSAqIDJdO1xyXG4gICAgICAgIHAxeSA9IHBvaW50c1soKGxlbmd0aCAtIDIpICogMikgKyAxXTtcclxuICAgICAgICBwMnggPSBwb2ludHNbKGxlbmd0aCAtIDEpICogMl07XHJcbiAgICAgICAgcDJ5ID0gcG9pbnRzWygobGVuZ3RoIC0gMSkgKiAyKSArIDFdO1xyXG4gICAgICAgIHBlcnB4ID0gLShwMXkgLSBwMnkpO1xyXG4gICAgICAgIHBlcnB5ID0gcDF4IC0gcDJ4O1xyXG4gICAgICAgIGRpc3QgPSBNYXRoLnNxcnQoKHBlcnB4ICogcGVycHgpICsgKHBlcnB5ICogcGVycHkpKTtcclxuICAgICAgICBwZXJweCAvPSBkaXN0O1xyXG4gICAgICAgIHBlcnB5IC89IGRpc3Q7XHJcbiAgICAgICAgcGVycHggKj0gd2lkdGg7XHJcbiAgICAgICAgcGVycHkgKj0gd2lkdGg7XHJcbiAgICAgICAgdmVydHMucHVzaChwMnggLSAocGVycHggKiByMSksIHAyeSAtIChwZXJweSAqIHIxKSk7XHJcbiAgICAgICAgdmVydHMucHVzaChwMnggKyAocGVycHggKiByMiksIHAyeSArIChwZXJweSAqIHIyKSk7XHJcbiAgICAgICAgdmFyIGluZGljZXMgPSBncmFwaGljc0dlb21ldHJ5LmluZGljZXM7XHJcbiAgICAgICAgLy8gaW5kaWNlcy5wdXNoKGluZGV4U3RhcnQpO1xyXG4gICAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGluZGV4Q291bnQgLSAyOyArK2kkMSkge1xyXG4gICAgICAgICAgICBpbmRpY2VzLnB1c2goaW5kZXhTdGFydCwgaW5kZXhTdGFydCArIDEsIGluZGV4U3RhcnQgKyAyKTtcclxuICAgICAgICAgICAgaW5kZXhTdGFydCsrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHN0YXRpYyBlYXJjdXQoZGF0YSwgaG9sZUluZGljZXMsIGRpbSkge1xyXG4gICAgICAgIGRpbSA9IGRpbSB8fCAyO1xyXG4gICAgICAgIHZhciBoYXNIb2xlcyA9IGhvbGVJbmRpY2VzICYmIGhvbGVJbmRpY2VzLmxlbmd0aCwgb3V0ZXJMZW4gPSBoYXNIb2xlcyA/IGhvbGVJbmRpY2VzWzBdICogZGltIDogZGF0YS5sZW5ndGgsIG91dGVyTm9kZSA9IEdyYXBoaWNzR2VvbWV0cnkubGlua2VkTGlzdChkYXRhLCAwLCBvdXRlckxlbiwgZGltLCB0cnVlKSwgdHJpYW5nbGVzID0gW107XHJcbiAgICAgICAgaWYgKCFvdXRlck5vZGUgfHwgb3V0ZXJOb2RlLm5leHQgPT09IG91dGVyTm9kZS5wcmV2KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cmlhbmdsZXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBtaW5YLCBtaW5ZLCBtYXhYLCBtYXhZLCB4LCB5LCBpbnZTaXplO1xyXG4gICAgICAgIGlmIChoYXNIb2xlcykge1xyXG4gICAgICAgICAgICBvdXRlck5vZGUgPSBHcmFwaGljc0dlb21ldHJ5LmVsaW1pbmF0ZUhvbGVzKGRhdGEsIGhvbGVJbmRpY2VzLCBvdXRlck5vZGUsIGRpbSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGlmIHRoZSBzaGFwZSBpcyBub3QgdG9vIHNpbXBsZSwgd2UnbGwgdXNlIHotb3JkZXIgY3VydmUgaGFzaCBsYXRlcjsgY2FsY3VsYXRlIHBvbHlnb24gYmJveFxyXG4gICAgICAgIGlmIChkYXRhLmxlbmd0aCA+IDgwICogZGltKSB7XHJcbiAgICAgICAgICAgIG1pblggPSBtYXhYID0gZGF0YVswXTtcclxuICAgICAgICAgICAgbWluWSA9IG1heFkgPSBkYXRhWzFdO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gZGltOyBpIDwgb3V0ZXJMZW47IGkgKz0gZGltKSB7XHJcbiAgICAgICAgICAgICAgICB4ID0gZGF0YVtpXTtcclxuICAgICAgICAgICAgICAgIHkgPSBkYXRhW2kgKyAxXTtcclxuICAgICAgICAgICAgICAgIGlmICh4IDwgbWluWCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG1pblggPSB4O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHkgPCBtaW5ZKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWluWSA9IHk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoeCA+IG1heFgpIHtcclxuICAgICAgICAgICAgICAgICAgICBtYXhYID0geDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh5ID4gbWF4WSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG1heFkgPSB5O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIG1pblgsIG1pblkgYW5kIGludlNpemUgYXJlIGxhdGVyIHVzZWQgdG8gdHJhbnNmb3JtIGNvb3JkcyBpbnRvIGludGVnZXJzIGZvciB6LW9yZGVyIGNhbGN1bGF0aW9uXHJcbiAgICAgICAgICAgIGludlNpemUgPSBNYXRoLm1heChtYXhYIC0gbWluWCwgbWF4WSAtIG1pblkpO1xyXG4gICAgICAgICAgICBpbnZTaXplID0gaW52U2l6ZSAhPT0gMCA/IDEgLyBpbnZTaXplIDogMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgR3JhcGhpY3NHZW9tZXRyeS5lYXJjdXRMaW5rZWQob3V0ZXJOb2RlLCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgaW52U2l6ZSk7XHJcbiAgICAgICAgcmV0dXJuIHRyaWFuZ2xlcztcclxuICAgIH1cclxuICAgIC8vIGNyZWF0ZSBhIGNpcmN1bGFyIGRvdWJseSBsaW5rZWQgbGlzdCBmcm9tIHBvbHlnb24gcG9pbnRzIGluIHRoZSBzcGVjaWZpZWQgd2luZGluZyBvcmRlclxyXG4gICAgc3RhdGljIGxpbmtlZExpc3QoZGF0YSwgc3RhcnQsIGVuZCwgZGltLCBjbG9ja3dpc2UpIHtcclxuICAgICAgICB2YXIgaSwgbGFzdDtcclxuICAgICAgICBpZiAoY2xvY2t3aXNlID09PSAoR3JhcGhpY3NHZW9tZXRyeS5zaWduZWRBcmVhKGRhdGEsIHN0YXJ0LCBlbmQsIGRpbSkgPiAwKSkge1xyXG4gICAgICAgICAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSBkaW0pIHtcclxuICAgICAgICAgICAgICAgIGxhc3QgPSBHcmFwaGljc0dlb21ldHJ5Lmluc2VydE5vZGUoaSwgZGF0YVtpXSwgZGF0YVtpICsgMV0sIGxhc3QpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBmb3IgKGkgPSBlbmQgLSBkaW07IGkgPj0gc3RhcnQ7IGkgLT0gZGltKSB7XHJcbiAgICAgICAgICAgICAgICBsYXN0ID0gR3JhcGhpY3NHZW9tZXRyeS5pbnNlcnROb2RlKGksIGRhdGFbaV0sIGRhdGFbaSArIDFdLCBsYXN0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobGFzdCAmJiBHcmFwaGljc0dlb21ldHJ5LmVxdWFscyhsYXN0LCBsYXN0Lm5leHQpKSB7XHJcbiAgICAgICAgICAgIEdyYXBoaWNzR2VvbWV0cnkucmVtb3ZlTm9kZShsYXN0KTtcclxuICAgICAgICAgICAgbGFzdCA9IGxhc3QubmV4dDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGxhc3Q7XHJcbiAgICB9XHJcbiAgICAvLyBsaW5rIGV2ZXJ5IGhvbGUgaW50byB0aGUgb3V0ZXIgbG9vcCwgcHJvZHVjaW5nIGEgc2luZ2xlLXJpbmcgcG9seWdvbiB3aXRob3V0IGhvbGVzXHJcbiAgICBzdGF0aWMgZWxpbWluYXRlSG9sZXMoZGF0YSwgaG9sZUluZGljZXMsIG91dGVyTm9kZSwgZGltKSB7XHJcbiAgICAgICAgdmFyIHF1ZXVlID0gW10sIGksIGxlbiwgc3RhcnQsIGVuZCwgbGlzdDtcclxuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBob2xlSW5kaWNlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICBzdGFydCA9IGhvbGVJbmRpY2VzW2ldICogZGltO1xyXG4gICAgICAgICAgICBlbmQgPSBpIDwgbGVuIC0gMSA/IGhvbGVJbmRpY2VzW2kgKyAxXSAqIGRpbSA6IGRhdGEubGVuZ3RoO1xyXG4gICAgICAgICAgICBsaXN0ID0gR3JhcGhpY3NHZW9tZXRyeS5saW5rZWRMaXN0KGRhdGEsIHN0YXJ0LCBlbmQsIGRpbSwgZmFsc2UpO1xyXG4gICAgICAgICAgICBpZiAobGlzdCA9PT0gbGlzdC5uZXh0KSB7XHJcbiAgICAgICAgICAgICAgICBsaXN0LnN0ZWluZXIgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHF1ZXVlLnB1c2goR3JhcGhpY3NHZW9tZXRyeS5nZXRMZWZ0bW9zdChsaXN0KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHF1ZXVlLnNvcnQoR3JhcGhpY3NHZW9tZXRyeS5jb21wYXJlWCk7XHJcbiAgICAgICAgLy8gcHJvY2VzcyBob2xlcyBmcm9tIGxlZnQgdG8gcmlnaHRcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgR3JhcGhpY3NHZW9tZXRyeS5lbGltaW5hdGVIb2xlKHF1ZXVlW2ldLCBvdXRlck5vZGUpO1xyXG4gICAgICAgICAgICBvdXRlck5vZGUgPSBHcmFwaGljc0dlb21ldHJ5LmZpbHRlclBvaW50cyhvdXRlck5vZGUsIG91dGVyTm9kZS5uZXh0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG91dGVyTm9kZTtcclxuICAgIH1cclxuICAgIC8vIG1haW4gZWFyIHNsaWNpbmcgbG9vcCB3aGljaCB0cmlhbmd1bGF0ZXMgYSBwb2x5Z29uIChnaXZlbiBhcyBhIGxpbmtlZCBsaXN0KVxyXG4gICAgc3RhdGljIGVhcmN1dExpbmtlZChlYXIsIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBpbnZTaXplLCBwYXNzID0gbnVsbCkge1xyXG4gICAgICAgIGlmICghZWFyKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gaW50ZXJsaW5rIHBvbHlnb24gbm9kZXMgaW4gei1vcmRlclxyXG4gICAgICAgIGlmICghcGFzcyAmJiBpbnZTaXplKSB7XHJcbiAgICAgICAgICAgIEdyYXBoaWNzR2VvbWV0cnkuaW5kZXhDdXJ2ZShlYXIsIG1pblgsIG1pblksIGludlNpemUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgc3RvcCA9IGVhciwgcHJldiwgbmV4dDtcclxuICAgICAgICAvLyBpdGVyYXRlIHRocm91Z2ggZWFycywgc2xpY2luZyB0aGVtIG9uZSBieSBvbmVcclxuICAgICAgICB3aGlsZSAoZWFyLnByZXYgIT09IGVhci5uZXh0KSB7XHJcbiAgICAgICAgICAgIHByZXYgPSBlYXIucHJldjtcclxuICAgICAgICAgICAgbmV4dCA9IGVhci5uZXh0O1xyXG4gICAgICAgICAgICBpZiAoaW52U2l6ZSA/IEdyYXBoaWNzR2VvbWV0cnkuaXNFYXJIYXNoZWQoZWFyLCBtaW5YLCBtaW5ZLCBpbnZTaXplKSA6IEdyYXBoaWNzR2VvbWV0cnkuaXNFYXIoZWFyKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gY3V0IG9mZiB0aGUgdHJpYW5nbGVcclxuICAgICAgICAgICAgICAgIHRyaWFuZ2xlcy5wdXNoKHByZXYuaSAvIGRpbSk7XHJcbiAgICAgICAgICAgICAgICB0cmlhbmdsZXMucHVzaChlYXIuaSAvIGRpbSk7XHJcbiAgICAgICAgICAgICAgICB0cmlhbmdsZXMucHVzaChuZXh0LmkgLyBkaW0pO1xyXG4gICAgICAgICAgICAgICAgR3JhcGhpY3NHZW9tZXRyeS5yZW1vdmVOb2RlKGVhcik7XHJcbiAgICAgICAgICAgICAgICAvLyBza2lwcGluZyB0aGUgbmV4dCB2ZXJ0ZXggbGVhZHMgdG8gbGVzcyBzbGl2ZXIgdHJpYW5nbGVzXHJcbiAgICAgICAgICAgICAgICBlYXIgPSBuZXh0Lm5leHQ7XHJcbiAgICAgICAgICAgICAgICBzdG9wID0gbmV4dC5uZXh0O1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWFyID0gbmV4dDtcclxuICAgICAgICAgICAgLy8gaWYgd2UgbG9vcGVkIHRocm91Z2ggdGhlIHdob2xlIHJlbWFpbmluZyBwb2x5Z29uIGFuZCBjYW4ndCBmaW5kIGFueSBtb3JlIGVhcnNcclxuICAgICAgICAgICAgaWYgKGVhciA9PT0gc3RvcCkge1xyXG4gICAgICAgICAgICAgICAgLy8gdHJ5IGZpbHRlcmluZyBwb2ludHMgYW5kIHNsaWNpbmcgYWdhaW5cclxuICAgICAgICAgICAgICAgIGlmICghcGFzcykge1xyXG4gICAgICAgICAgICAgICAgICAgIEdyYXBoaWNzR2VvbWV0cnkuZWFyY3V0TGlua2VkKEdyYXBoaWNzR2VvbWV0cnkuZmlsdGVyUG9pbnRzKGVhciksIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBpbnZTaXplLCAxKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGlzIGRpZG4ndCB3b3JrLCB0cnkgY3VyaW5nIGFsbCBzbWFsbCBzZWxmLWludGVyc2VjdGlvbnMgbG9jYWxseVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocGFzcyA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGVhciA9IEdyYXBoaWNzR2VvbWV0cnkuY3VyZUxvY2FsSW50ZXJzZWN0aW9ucyhlYXIsIHRyaWFuZ2xlcywgZGltKTtcclxuICAgICAgICAgICAgICAgICAgICBHcmFwaGljc0dlb21ldHJ5LmVhcmN1dExpbmtlZChlYXIsIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBpbnZTaXplLCAyKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBhcyBhIGxhc3QgcmVzb3J0LCB0cnkgc3BsaXR0aW5nIHRoZSByZW1haW5pbmcgcG9seWdvbiBpbnRvIHR3b1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocGFzcyA9PT0gMikge1xyXG4gICAgICAgICAgICAgICAgICAgIEdyYXBoaWNzR2VvbWV0cnkuc3BsaXRFYXJjdXQoZWFyLCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgaW52U2l6ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHN0YXRpYyBzaWduZWRBcmVhKGRhdGEsIHN0YXJ0LCBlbmQsIGRpbSkge1xyXG4gICAgICAgIHZhciBzdW0gPSAwO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSBzdGFydCwgaiA9IGVuZCAtIGRpbTsgaSA8IGVuZDsgaSArPSBkaW0pIHtcclxuICAgICAgICAgICAgc3VtICs9IChkYXRhW2pdIC0gZGF0YVtpXSkgKiAoZGF0YVtpICsgMV0gKyBkYXRhW2ogKyAxXSk7XHJcbiAgICAgICAgICAgIGogPSBpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc3VtO1xyXG4gICAgfVxyXG4gICAgLy8gY3JlYXRlIGEgbm9kZSBhbmQgb3B0aW9uYWxseSBsaW5rIGl0IHdpdGggcHJldmlvdXMgb25lIChpbiBhIGNpcmN1bGFyIGRvdWJseSBsaW5rZWQgbGlzdClcclxuICAgIHN0YXRpYyBpbnNlcnROb2RlKGksIHgsIHksIGxhc3QpIHtcclxuICAgICAgICB2YXIgcCA9IG5ldyBOb2RlKGksIHgsIHkpO1xyXG4gICAgICAgIGlmICghbGFzdCkge1xyXG4gICAgICAgICAgICBwLnByZXYgPSBwO1xyXG4gICAgICAgICAgICBwLm5leHQgPSBwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcC5uZXh0ID0gbGFzdC5uZXh0O1xyXG4gICAgICAgICAgICBwLnByZXYgPSBsYXN0O1xyXG4gICAgICAgICAgICBsYXN0Lm5leHQucHJldiA9IHA7XHJcbiAgICAgICAgICAgIGxhc3QubmV4dCA9IHA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwO1xyXG4gICAgfVxyXG4gICAgLy8gY2hlY2sgaWYgdHdvIHBvaW50cyBhcmUgZXF1YWxcclxuICAgIHN0YXRpYyBlcXVhbHMocDEsIHAyKSB7XHJcbiAgICAgICAgcmV0dXJuIHAxLnggPT09IHAyLnggJiYgcDEueSA9PT0gcDIueTtcclxuICAgIH1cclxuICAgIHN0YXRpYyByZW1vdmVOb2RlKHApIHtcclxuICAgICAgICBwLm5leHQucHJldiA9IHAucHJldjtcclxuICAgICAgICBwLnByZXYubmV4dCA9IHAubmV4dDtcclxuICAgICAgICBpZiAocC5wcmV2Wikge1xyXG4gICAgICAgICAgICBwLnByZXZaLm5leHRaID0gcC5uZXh0WjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHAubmV4dFopIHtcclxuICAgICAgICAgICAgcC5uZXh0Wi5wcmV2WiA9IHAucHJldlo7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gZmluZCB0aGUgbGVmdG1vc3Qgbm9kZSBvZiBhIHBvbHlnb24gcmluZ1xyXG4gICAgc3RhdGljIGdldExlZnRtb3N0KHN0YXJ0KSB7XHJcbiAgICAgICAgdmFyIHAgPSBzdGFydCwgbGVmdG1vc3QgPSBzdGFydDtcclxuICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgIGlmIChwLnggPCBsZWZ0bW9zdC54IHx8IChwLnggPT09IGxlZnRtb3N0LnggJiYgcC55IDwgbGVmdG1vc3QueSkpIHtcclxuICAgICAgICAgICAgICAgIGxlZnRtb3N0ID0gcDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBwID0gcC5uZXh0O1xyXG4gICAgICAgIH0gd2hpbGUgKHAgIT09IHN0YXJ0KTtcclxuICAgICAgICByZXR1cm4gbGVmdG1vc3Q7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgY29tcGFyZVgoYSwgYikge1xyXG4gICAgICAgIHJldHVybiBhLnggLSBiLng7XHJcbiAgICB9XHJcbiAgICAvLyBmaW5kIGEgYnJpZGdlIGJldHdlZW4gdmVydGljZXMgdGhhdCBjb25uZWN0cyBob2xlIHdpdGggYW4gb3V0ZXIgcmluZyBhbmQgYW5kIGxpbmsgaXRcclxuICAgIHN0YXRpYyBlbGltaW5hdGVIb2xlKGhvbGUsIG91dGVyTm9kZSkge1xyXG4gICAgICAgIG91dGVyTm9kZSA9IEdyYXBoaWNzR2VvbWV0cnkuZmluZEhvbGVCcmlkZ2UoaG9sZSwgb3V0ZXJOb2RlKTtcclxuICAgICAgICBpZiAob3V0ZXJOb2RlKSB7XHJcbiAgICAgICAgICAgIHZhciBiID0gR3JhcGhpY3NHZW9tZXRyeS5zcGxpdFBvbHlnb24ob3V0ZXJOb2RlLCBob2xlKTtcclxuICAgICAgICAgICAgR3JhcGhpY3NHZW9tZXRyeS5maWx0ZXJQb2ludHMoYiwgYi5uZXh0KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBlbGltaW5hdGUgY29saW5lYXIgb3IgZHVwbGljYXRlIHBvaW50c1xyXG4gICAgc3RhdGljIGZpbHRlclBvaW50cyhzdGFydCwgZW5kID0gbnVsbCkge1xyXG4gICAgICAgIGlmICghc3RhcnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHN0YXJ0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWVuZCkge1xyXG4gICAgICAgICAgICBlbmQgPSBzdGFydDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHAgPSBzdGFydCwgYWdhaW47XHJcbiAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICBhZ2FpbiA9IGZhbHNlO1xyXG4gICAgICAgICAgICBpZiAoIXAuc3RlaW5lciAmJiAoR3JhcGhpY3NHZW9tZXRyeS5lcXVhbHMocCwgcC5uZXh0KSB8fCBHcmFwaGljc0dlb21ldHJ5LmFyZWEocC5wcmV2LCBwLCBwLm5leHQpID09PSAwKSkge1xyXG4gICAgICAgICAgICAgICAgR3JhcGhpY3NHZW9tZXRyeS5yZW1vdmVOb2RlKHApO1xyXG4gICAgICAgICAgICAgICAgcCA9IGVuZCA9IHAucHJldjtcclxuICAgICAgICAgICAgICAgIGlmIChwID09PSBwLm5leHQpIHtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGFnYWluID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHAgPSBwLm5leHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9IHdoaWxlIChhZ2FpbiB8fCBwICE9PSBlbmQpO1xyXG4gICAgICAgIHJldHVybiBlbmQ7XHJcbiAgICB9XHJcbiAgICAvLyBzaWduZWQgYXJlYSBvZiBhIHRyaWFuZ2xlXHJcbiAgICBzdGF0aWMgYXJlYShwLCBxLCByKSB7XHJcbiAgICAgICAgcmV0dXJuIChxLnkgLSBwLnkpICogKHIueCAtIHEueCkgLSAocS54IC0gcC54KSAqIChyLnkgLSBxLnkpO1xyXG4gICAgfVxyXG4gICAgLy8gbGluayB0d28gcG9seWdvbiB2ZXJ0aWNlcyB3aXRoIGEgYnJpZGdlOyBpZiB0aGUgdmVydGljZXMgYmVsb25nIHRvIHRoZSBzYW1lIHJpbmcsIGl0IHNwbGl0cyBwb2x5Z29uIGludG8gdHdvO1xyXG4gICAgLy8gaWYgb25lIGJlbG9uZ3MgdG8gdGhlIG91dGVyIHJpbmcgYW5kIGFub3RoZXIgdG8gYSBob2xlLCBpdCBtZXJnZXMgaXQgaW50byBhIHNpbmdsZSByaW5nXHJcbiAgICBzdGF0aWMgc3BsaXRQb2x5Z29uKGEsIGIpIHtcclxuICAgICAgICB2YXIgYTIgPSBuZXcgTm9kZShhLmksIGEueCwgYS55KSwgYjIgPSBuZXcgTm9kZShiLmksIGIueCwgYi55KSwgYW4gPSBhLm5leHQsIGJwID0gYi5wcmV2O1xyXG4gICAgICAgIGEubmV4dCA9IGI7XHJcbiAgICAgICAgYi5wcmV2ID0gYTtcclxuICAgICAgICBhMi5uZXh0ID0gYW47XHJcbiAgICAgICAgYW4ucHJldiA9IGEyO1xyXG4gICAgICAgIGIyLm5leHQgPSBhMjtcclxuICAgICAgICBhMi5wcmV2ID0gYjI7XHJcbiAgICAgICAgYnAubmV4dCA9IGIyO1xyXG4gICAgICAgIGIyLnByZXYgPSBicDtcclxuICAgICAgICByZXR1cm4gYjI7XHJcbiAgICB9XHJcbiAgICAvLyBEYXZpZCBFYmVybHkncyBhbGdvcml0aG0gZm9yIGZpbmRpbmcgYSBicmlkZ2UgYmV0d2VlbiBob2xlIGFuZCBvdXRlciBwb2x5Z29uXHJcbiAgICBzdGF0aWMgZmluZEhvbGVCcmlkZ2UoaG9sZSwgb3V0ZXJOb2RlKSB7XHJcbiAgICAgICAgdmFyIHAgPSBvdXRlck5vZGUsIGh4ID0gaG9sZS54LCBoeSA9IGhvbGUueSwgcXggPSAtSW5maW5pdHksIG07XHJcbiAgICAgICAgLy8gZmluZCBhIHNlZ21lbnQgaW50ZXJzZWN0ZWQgYnkgYSByYXkgZnJvbSB0aGUgaG9sZSdzIGxlZnRtb3N0IHBvaW50IHRvIHRoZSBsZWZ0O1xyXG4gICAgICAgIC8vIHNlZ21lbnQncyBlbmRwb2ludCB3aXRoIGxlc3NlciB4IHdpbGwgYmUgcG90ZW50aWFsIGNvbm5lY3Rpb24gcG9pbnRcclxuICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgIGlmIChoeSA8PSBwLnkgJiYgaHkgPj0gcC5uZXh0LnkgJiYgcC5uZXh0LnkgIT09IHAueSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHggPSBwLnggKyAoaHkgLSBwLnkpICogKHAubmV4dC54IC0gcC54KSAvIChwLm5leHQueSAtIHAueSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoeCA8PSBoeCAmJiB4ID4gcXgpIHtcclxuICAgICAgICAgICAgICAgICAgICBxeCA9IHg7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHggPT09IGh4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoeSA9PT0gcC55KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaHkgPT09IHAubmV4dC55KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcC5uZXh0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIG0gPSBwLnggPCBwLm5leHQueCA/IHAgOiBwLm5leHQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcCA9IHAubmV4dDtcclxuICAgICAgICB9IHdoaWxlIChwICE9PSBvdXRlck5vZGUpO1xyXG4gICAgICAgIGlmICghbSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGh4ID09PSBxeCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbS5wcmV2O1xyXG4gICAgICAgIH0gLy8gaG9sZSB0b3VjaGVzIG91dGVyIHNlZ21lbnQ7IHBpY2sgbG93ZXIgZW5kcG9pbnRcclxuICAgICAgICAvLyBsb29rIGZvciBwb2ludHMgaW5zaWRlIHRoZSB0cmlhbmdsZSBvZiBob2xlIHBvaW50LCBzZWdtZW50IGludGVyc2VjdGlvbiBhbmQgZW5kcG9pbnQ7XHJcbiAgICAgICAgLy8gaWYgdGhlcmUgYXJlIG5vIHBvaW50cyBmb3VuZCwgd2UgaGF2ZSBhIHZhbGlkIGNvbm5lY3Rpb247XHJcbiAgICAgICAgLy8gb3RoZXJ3aXNlIGNob29zZSB0aGUgcG9pbnQgb2YgdGhlIG1pbmltdW0gYW5nbGUgd2l0aCB0aGUgcmF5IGFzIGNvbm5lY3Rpb24gcG9pbnRcclxuICAgICAgICB2YXIgc3RvcCA9IG0sIG14ID0gbS54LCBteSA9IG0ueSwgdGFuTWluID0gSW5maW5pdHksIHRhbjtcclxuICAgICAgICBwID0gbS5uZXh0O1xyXG4gICAgICAgIHdoaWxlIChwICE9PSBzdG9wKSB7XHJcbiAgICAgICAgICAgIGlmIChoeCA+PSBwLnggJiYgcC54ID49IG14ICYmIGh4ICE9PSBwLnggJiZcclxuICAgICAgICAgICAgICAgIEdyYXBoaWNzR2VvbWV0cnkucG9pbnRJblRyaWFuZ2xlKGh5IDwgbXkgPyBoeCA6IHF4LCBoeSwgbXgsIG15LCBoeSA8IG15ID8gcXggOiBoeCwgaHksIHAueCwgcC55KSkge1xyXG4gICAgICAgICAgICAgICAgdGFuID0gTWF0aC5hYnMoaHkgLSBwLnkpIC8gKGh4IC0gcC54KTsgLy8gdGFuZ2VudGlhbFxyXG4gICAgICAgICAgICAgICAgaWYgKCh0YW4gPCB0YW5NaW4gfHwgKHRhbiA9PT0gdGFuTWluICYmIHAueCA+IG0ueCkpICYmIEdyYXBoaWNzR2VvbWV0cnkubG9jYWxseUluc2lkZShwLCBob2xlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG0gPSBwO1xyXG4gICAgICAgICAgICAgICAgICAgIHRhbk1pbiA9IHRhbjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBwID0gcC5uZXh0O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbTtcclxuICAgIH1cclxuICAgIC8vIGNoZWNrIGlmIGEgcG9seWdvbiBkaWFnb25hbCBpcyBsb2NhbGx5IGluc2lkZSB0aGUgcG9seWdvblxyXG4gICAgc3RhdGljIGxvY2FsbHlJbnNpZGUoYSwgYikge1xyXG4gICAgICAgIHJldHVybiBHcmFwaGljc0dlb21ldHJ5LmFyZWEoYS5wcmV2LCBhLCBhLm5leHQpIDwgMCA/XHJcbiAgICAgICAgICAgIEdyYXBoaWNzR2VvbWV0cnkuYXJlYShhLCBiLCBhLm5leHQpID49IDAgJiYgR3JhcGhpY3NHZW9tZXRyeS5hcmVhKGEsIGEucHJldiwgYikgPj0gMCA6XHJcbiAgICAgICAgICAgIEdyYXBoaWNzR2VvbWV0cnkuYXJlYShhLCBiLCBhLnByZXYpIDwgMCB8fCBHcmFwaGljc0dlb21ldHJ5LmFyZWEoYSwgYS5uZXh0LCBiKSA8IDA7XHJcbiAgICB9XHJcbiAgICAvLyBjaGVjayBpZiBhIHBvaW50IGxpZXMgd2l0aGluIGEgY29udmV4IHRyaWFuZ2xlXHJcbiAgICBzdGF0aWMgcG9pbnRJblRyaWFuZ2xlKGF4LCBheSwgYngsIGJ5LCBjeCwgY3ksIHB4LCBweSkge1xyXG4gICAgICAgIHJldHVybiAoY3ggLSBweCkgKiAoYXkgLSBweSkgLSAoYXggLSBweCkgKiAoY3kgLSBweSkgPj0gMCAmJlxyXG4gICAgICAgICAgICAoYXggLSBweCkgKiAoYnkgLSBweSkgLSAoYnggLSBweCkgKiAoYXkgLSBweSkgPj0gMCAmJlxyXG4gICAgICAgICAgICAoYnggLSBweCkgKiAoY3kgLSBweSkgLSAoY3ggLSBweCkgKiAoYnkgLSBweSkgPj0gMDtcclxuICAgIH1cclxuICAgIC8vIHRyeSBzcGxpdHRpbmcgcG9seWdvbiBpbnRvIHR3byBhbmQgdHJpYW5ndWxhdGUgdGhlbSBpbmRlcGVuZGVudGx5XHJcbiAgICBzdGF0aWMgc3BsaXRFYXJjdXQoc3RhcnQsIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBpbnZTaXplKSB7XHJcbiAgICAgICAgLy8gbG9vayBmb3IgYSB2YWxpZCBkaWFnb25hbCB0aGF0IGRpdmlkZXMgdGhlIHBvbHlnb24gaW50byB0d29cclxuICAgICAgICB2YXIgYSA9IHN0YXJ0O1xyXG4gICAgICAgIGRvIHtcclxuICAgICAgICAgICAgdmFyIGIgPSBhLm5leHQubmV4dDtcclxuICAgICAgICAgICAgd2hpbGUgKGIgIT09IGEucHJldikge1xyXG4gICAgICAgICAgICAgICAgaWYgKGEuaSAhPT0gYi5pICYmIEdyYXBoaWNzR2VvbWV0cnkuaXNWYWxpZERpYWdvbmFsKGEsIGIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gc3BsaXQgdGhlIHBvbHlnb24gaW4gdHdvIGJ5IHRoZSBkaWFnb25hbFxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjID0gR3JhcGhpY3NHZW9tZXRyeS5zcGxpdFBvbHlnb24oYSwgYik7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZmlsdGVyIGNvbGluZWFyIHBvaW50cyBhcm91bmQgdGhlIGN1dHNcclxuICAgICAgICAgICAgICAgICAgICBhID0gR3JhcGhpY3NHZW9tZXRyeS5maWx0ZXJQb2ludHMoYSwgYS5uZXh0KTtcclxuICAgICAgICAgICAgICAgICAgICBjID0gR3JhcGhpY3NHZW9tZXRyeS5maWx0ZXJQb2ludHMoYywgYy5uZXh0KTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBydW4gZWFyY3V0IG9uIGVhY2ggaGFsZlxyXG4gICAgICAgICAgICAgICAgICAgIEdyYXBoaWNzR2VvbWV0cnkuZWFyY3V0TGlua2VkKGEsIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBpbnZTaXplKTtcclxuICAgICAgICAgICAgICAgICAgICBHcmFwaGljc0dlb21ldHJ5LmVhcmN1dExpbmtlZChjLCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgaW52U2l6ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYiA9IGIubmV4dDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBhID0gYS5uZXh0O1xyXG4gICAgICAgIH0gd2hpbGUgKGEgIT09IHN0YXJ0KTtcclxuICAgIH1cclxuICAgIC8vIGNoZWNrIGlmIGEgZGlhZ29uYWwgYmV0d2VlbiB0d28gcG9seWdvbiBub2RlcyBpcyB2YWxpZCAobGllcyBpbiBwb2x5Z29uIGludGVyaW9yKVxyXG4gICAgc3RhdGljIGlzVmFsaWREaWFnb25hbChhLCBiKSB7XHJcbiAgICAgICAgcmV0dXJuIGEubmV4dC5pICE9PSBiLmkgJiYgYS5wcmV2LmkgIT09IGIuaSAmJiAhR3JhcGhpY3NHZW9tZXRyeS5pbnRlcnNlY3RzUG9seWdvbihhLCBiKSAmJlxyXG4gICAgICAgICAgICBHcmFwaGljc0dlb21ldHJ5LmxvY2FsbHlJbnNpZGUoYSwgYikgJiYgR3JhcGhpY3NHZW9tZXRyeS5sb2NhbGx5SW5zaWRlKGIsIGEpICYmIEdyYXBoaWNzR2VvbWV0cnkubWlkZGxlSW5zaWRlKGEsIGIpO1xyXG4gICAgfVxyXG4gICAgLy8gY2hlY2sgaWYgdGhlIG1pZGRsZSBwb2ludCBvZiBhIHBvbHlnb24gZGlhZ29uYWwgaXMgaW5zaWRlIHRoZSBwb2x5Z29uXHJcbiAgICBzdGF0aWMgbWlkZGxlSW5zaWRlKGEsIGIpIHtcclxuICAgICAgICB2YXIgcCA9IGEsIGluc2lkZSA9IGZhbHNlLCBweCA9IChhLnggKyBiLngpIC8gMiwgcHkgPSAoYS55ICsgYi55KSAvIDI7XHJcbiAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICBpZiAoKChwLnkgPiBweSkgIT09IChwLm5leHQueSA+IHB5KSkgJiYgcC5uZXh0LnkgIT09IHAueSAmJlxyXG4gICAgICAgICAgICAgICAgKHB4IDwgKHAubmV4dC54IC0gcC54KSAqIChweSAtIHAueSkgLyAocC5uZXh0LnkgLSBwLnkpICsgcC54KSkge1xyXG4gICAgICAgICAgICAgICAgaW5zaWRlID0gIWluc2lkZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBwID0gcC5uZXh0O1xyXG4gICAgICAgIH0gd2hpbGUgKHAgIT09IGEpO1xyXG4gICAgICAgIHJldHVybiBpbnNpZGU7XHJcbiAgICB9XHJcbiAgICAvLyBjaGVjayBpZiBhIHBvbHlnb24gZGlhZ29uYWwgaW50ZXJzZWN0cyBhbnkgcG9seWdvbiBzZWdtZW50c1xyXG4gICAgc3RhdGljIGludGVyc2VjdHNQb2x5Z29uKGEsIGIpIHtcclxuICAgICAgICB2YXIgcCA9IGE7XHJcbiAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICBpZiAocC5pICE9PSBhLmkgJiYgcC5uZXh0LmkgIT09IGEuaSAmJiBwLmkgIT09IGIuaSAmJiBwLm5leHQuaSAhPT0gYi5pICYmXHJcbiAgICAgICAgICAgICAgICBHcmFwaGljc0dlb21ldHJ5LmludGVyc2VjdHMocCwgcC5uZXh0LCBhLCBiKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcCA9IHAubmV4dDtcclxuICAgICAgICB9IHdoaWxlIChwICE9PSBhKTtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICAvLyBjaGVjayBpZiB0d28gc2VnbWVudHMgaW50ZXJzZWN0XHJcbiAgICBzdGF0aWMgaW50ZXJzZWN0cyhwMSwgcTEsIHAyLCBxMikge1xyXG4gICAgICAgIGlmICgoR3JhcGhpY3NHZW9tZXRyeS5lcXVhbHMocDEsIHExKSAmJiBHcmFwaGljc0dlb21ldHJ5LmVxdWFscyhwMiwgcTIpKSB8fFxyXG4gICAgICAgICAgICAoR3JhcGhpY3NHZW9tZXRyeS5lcXVhbHMocDEsIHEyKSAmJiBHcmFwaGljc0dlb21ldHJ5LmVxdWFscyhwMiwgcTEpKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIEdyYXBoaWNzR2VvbWV0cnkuYXJlYShwMSwgcTEsIHAyKSA+IDAgIT09IEdyYXBoaWNzR2VvbWV0cnkuYXJlYShwMSwgcTEsIHEyKSA+IDAgJiZcclxuICAgICAgICAgICAgR3JhcGhpY3NHZW9tZXRyeS5hcmVhKHAyLCBxMiwgcDEpID4gMCAhPT0gR3JhcGhpY3NHZW9tZXRyeS5hcmVhKHAyLCBxMiwgcTEpID4gMDtcclxuICAgIH1cclxuICAgIC8vIGdvIHRocm91Z2ggYWxsIHBvbHlnb24gbm9kZXMgYW5kIGN1cmUgc21hbGwgbG9jYWwgc2VsZi1pbnRlcnNlY3Rpb25zXHJcbiAgICBzdGF0aWMgY3VyZUxvY2FsSW50ZXJzZWN0aW9ucyhzdGFydCwgdHJpYW5nbGVzLCBkaW0pIHtcclxuICAgICAgICB2YXIgcCA9IHN0YXJ0O1xyXG4gICAgICAgIGRvIHtcclxuICAgICAgICAgICAgdmFyIGEgPSBwLnByZXYsIGIgPSBwLm5leHQubmV4dDtcclxuICAgICAgICAgICAgaWYgKCFHcmFwaGljc0dlb21ldHJ5LmVxdWFscyhhLCBiKSAmJiBHcmFwaGljc0dlb21ldHJ5LmludGVyc2VjdHMoYSwgcCwgcC5uZXh0LCBiKSAmJiBHcmFwaGljc0dlb21ldHJ5LmxvY2FsbHlJbnNpZGUoYSwgYikgJiYgR3JhcGhpY3NHZW9tZXRyeS5sb2NhbGx5SW5zaWRlKGIsIGEpKSB7XHJcbiAgICAgICAgICAgICAgICB0cmlhbmdsZXMucHVzaChhLmkgLyBkaW0pO1xyXG4gICAgICAgICAgICAgICAgdHJpYW5nbGVzLnB1c2gocC5pIC8gZGltKTtcclxuICAgICAgICAgICAgICAgIHRyaWFuZ2xlcy5wdXNoKGIuaSAvIGRpbSk7XHJcbiAgICAgICAgICAgICAgICAvLyByZW1vdmUgdHdvIG5vZGVzIGludm9sdmVkXHJcbiAgICAgICAgICAgICAgICBHcmFwaGljc0dlb21ldHJ5LnJlbW92ZU5vZGUocCk7XHJcbiAgICAgICAgICAgICAgICBHcmFwaGljc0dlb21ldHJ5LnJlbW92ZU5vZGUocC5uZXh0KTtcclxuICAgICAgICAgICAgICAgIHAgPSBzdGFydCA9IGI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcCA9IHAubmV4dDtcclxuICAgICAgICB9IHdoaWxlIChwICE9PSBzdGFydCk7XHJcbiAgICAgICAgcmV0dXJuIHA7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgaXNFYXJIYXNoZWQoZWFyLCBtaW5YLCBtaW5ZLCBpbnZTaXplKSB7XHJcbiAgICAgICAgdmFyIGEgPSBlYXIucHJldiwgYiA9IGVhciwgYyA9IGVhci5uZXh0O1xyXG4gICAgICAgIGlmIChHcmFwaGljc0dlb21ldHJ5LmFyZWEoYSwgYiwgYykgPj0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfSAvLyByZWZsZXgsIGNhbid0IGJlIGFuIGVhclxyXG4gICAgICAgIC8vIHRyaWFuZ2xlIGJib3g7IG1pbiAmIG1heCBhcmUgY2FsY3VsYXRlZCBsaWtlIHRoaXMgZm9yIHNwZWVkXHJcbiAgICAgICAgdmFyIG1pblRYID0gYS54IDwgYi54ID8gKGEueCA8IGMueCA/IGEueCA6IGMueCkgOiAoYi54IDwgYy54ID8gYi54IDogYy54KSwgbWluVFkgPSBhLnkgPCBiLnkgPyAoYS55IDwgYy55ID8gYS55IDogYy55KSA6IChiLnkgPCBjLnkgPyBiLnkgOiBjLnkpLCBtYXhUWCA9IGEueCA+IGIueCA/IChhLnggPiBjLnggPyBhLnggOiBjLngpIDogKGIueCA+IGMueCA/IGIueCA6IGMueCksIG1heFRZID0gYS55ID4gYi55ID8gKGEueSA+IGMueSA/IGEueSA6IGMueSkgOiAoYi55ID4gYy55ID8gYi55IDogYy55KTtcclxuICAgICAgICAvLyB6LW9yZGVyIHJhbmdlIGZvciB0aGUgY3VycmVudCB0cmlhbmdsZSBiYm94O1xyXG4gICAgICAgIHZhciBtaW5aID0gR3JhcGhpY3NHZW9tZXRyeS56T3JkZXIobWluVFgsIG1pblRZLCBtaW5YLCBtaW5ZLCBpbnZTaXplKSwgbWF4WiA9IEdyYXBoaWNzR2VvbWV0cnkuek9yZGVyKG1heFRYLCBtYXhUWSwgbWluWCwgbWluWSwgaW52U2l6ZSk7XHJcbiAgICAgICAgdmFyIHAgPSBlYXIucHJldlosIG4gPSBlYXIubmV4dFo7XHJcbiAgICAgICAgLy8gbG9vayBmb3IgcG9pbnRzIGluc2lkZSB0aGUgdHJpYW5nbGUgaW4gYm90aCBkaXJlY3Rpb25zXHJcbiAgICAgICAgd2hpbGUgKHAgJiYgcC56ID49IG1pblogJiYgbiAmJiBuLnogPD0gbWF4Wikge1xyXG4gICAgICAgICAgICBpZiAocCAhPT0gZWFyLnByZXYgJiYgcCAhPT0gZWFyLm5leHQgJiZcclxuICAgICAgICAgICAgICAgIEdyYXBoaWNzR2VvbWV0cnkucG9pbnRJblRyaWFuZ2xlKGEueCwgYS55LCBiLngsIGIueSwgYy54LCBjLnksIHAueCwgcC55KSAmJlxyXG4gICAgICAgICAgICAgICAgR3JhcGhpY3NHZW9tZXRyeS5hcmVhKHAucHJldiwgcCwgcC5uZXh0KSA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcCA9IHAucHJldlo7XHJcbiAgICAgICAgICAgIGlmIChuICE9PSBlYXIucHJldiAmJiBuICE9PSBlYXIubmV4dCAmJlxyXG4gICAgICAgICAgICAgICAgR3JhcGhpY3NHZW9tZXRyeS5wb2ludEluVHJpYW5nbGUoYS54LCBhLnksIGIueCwgYi55LCBjLngsIGMueSwgbi54LCBuLnkpICYmXHJcbiAgICAgICAgICAgICAgICBHcmFwaGljc0dlb21ldHJ5LmFyZWEobi5wcmV2LCBuLCBuLm5leHQpID49IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBuID0gbi5uZXh0WjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gbG9vayBmb3IgcmVtYWluaW5nIHBvaW50cyBpbiBkZWNyZWFzaW5nIHotb3JkZXJcclxuICAgICAgICB3aGlsZSAocCAmJiBwLnogPj0gbWluWikge1xyXG4gICAgICAgICAgICBpZiAocCAhPT0gZWFyLnByZXYgJiYgcCAhPT0gZWFyLm5leHQgJiZcclxuICAgICAgICAgICAgICAgIEdyYXBoaWNzR2VvbWV0cnkucG9pbnRJblRyaWFuZ2xlKGEueCwgYS55LCBiLngsIGIueSwgYy54LCBjLnksIHAueCwgcC55KSAmJlxyXG4gICAgICAgICAgICAgICAgR3JhcGhpY3NHZW9tZXRyeS5hcmVhKHAucHJldiwgcCwgcC5uZXh0KSA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcCA9IHAucHJldlo7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGxvb2sgZm9yIHJlbWFpbmluZyBwb2ludHMgaW4gaW5jcmVhc2luZyB6LW9yZGVyXHJcbiAgICAgICAgd2hpbGUgKG4gJiYgbi56IDw9IG1heFopIHtcclxuICAgICAgICAgICAgaWYgKG4gIT09IGVhci5wcmV2ICYmIG4gIT09IGVhci5uZXh0ICYmXHJcbiAgICAgICAgICAgICAgICBHcmFwaGljc0dlb21ldHJ5LnBvaW50SW5UcmlhbmdsZShhLngsIGEueSwgYi54LCBiLnksIGMueCwgYy55LCBuLngsIG4ueSkgJiZcclxuICAgICAgICAgICAgICAgIEdyYXBoaWNzR2VvbWV0cnkuYXJlYShuLnByZXYsIG4sIG4ubmV4dCkgPj0gMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG4gPSBuLm5leHRaO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIC8vIHotb3JkZXIgb2YgYSBwb2ludCBnaXZlbiBjb29yZHMgYW5kIGludmVyc2Ugb2YgdGhlIGxvbmdlciBzaWRlIG9mIGRhdGEgYmJveFxyXG4gICAgc3RhdGljIHpPcmRlcih4LCB5LCBtaW5YLCBtaW5ZLCBpbnZTaXplKSB7XHJcbiAgICAgICAgLy8gY29vcmRzIGFyZSB0cmFuc2Zvcm1lZCBpbnRvIG5vbi1uZWdhdGl2ZSAxNS1iaXQgaW50ZWdlciByYW5nZVxyXG4gICAgICAgIHggPSAzMjc2NyAqICh4IC0gbWluWCkgKiBpbnZTaXplO1xyXG4gICAgICAgIHkgPSAzMjc2NyAqICh5IC0gbWluWSkgKiBpbnZTaXplO1xyXG4gICAgICAgIHggPSAoeCB8ICh4IDw8IDgpKSAmIDB4MDBGRjAwRkY7XHJcbiAgICAgICAgeCA9ICh4IHwgKHggPDwgNCkpICYgMHgwRjBGMEYwRjtcclxuICAgICAgICB4ID0gKHggfCAoeCA8PCAyKSkgJiAweDMzMzMzMzMzO1xyXG4gICAgICAgIHggPSAoeCB8ICh4IDw8IDEpKSAmIDB4NTU1NTU1NTU7XHJcbiAgICAgICAgeSA9ICh5IHwgKHkgPDwgOCkpICYgMHgwMEZGMDBGRjtcclxuICAgICAgICB5ID0gKHkgfCAoeSA8PCA0KSkgJiAweDBGMEYwRjBGO1xyXG4gICAgICAgIHkgPSAoeSB8ICh5IDw8IDIpKSAmIDB4MzMzMzMzMzM7XHJcbiAgICAgICAgeSA9ICh5IHwgKHkgPDwgMSkpICYgMHg1NTU1NTU1NTtcclxuICAgICAgICByZXR1cm4geCB8ICh5IDw8IDEpO1xyXG4gICAgfVxyXG4gICAgLy8gY2hlY2sgd2hldGhlciBhIHBvbHlnb24gbm9kZSBmb3JtcyBhIHZhbGlkIGVhciB3aXRoIGFkamFjZW50IG5vZGVzXHJcbiAgICBzdGF0aWMgaXNFYXIoZWFyKSB7XHJcbiAgICAgICAgdmFyIGEgPSBlYXIucHJldiwgYiA9IGVhciwgYyA9IGVhci5uZXh0O1xyXG4gICAgICAgIGlmIChHcmFwaGljc0dlb21ldHJ5LmFyZWEoYSwgYiwgYykgPj0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfSAvLyByZWZsZXgsIGNhbid0IGJlIGFuIGVhclxyXG4gICAgICAgIC8vIG5vdyBtYWtlIHN1cmUgd2UgZG9uJ3QgaGF2ZSBvdGhlciBwb2ludHMgaW5zaWRlIHRoZSBwb3RlbnRpYWwgZWFyXHJcbiAgICAgICAgdmFyIHAgPSBlYXIubmV4dC5uZXh0O1xyXG4gICAgICAgIHdoaWxlIChwICE9PSBlYXIucHJldikge1xyXG4gICAgICAgICAgICBpZiAoR3JhcGhpY3NHZW9tZXRyeS5wb2ludEluVHJpYW5nbGUoYS54LCBhLnksIGIueCwgYi55LCBjLngsIGMueSwgcC54LCBwLnkpICYmXHJcbiAgICAgICAgICAgICAgICBHcmFwaGljc0dlb21ldHJ5LmFyZWEocC5wcmV2LCBwLCBwLm5leHQpID49IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBwID0gcC5uZXh0O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIC8vIGludGVybGluayBwb2x5Z29uIG5vZGVzIGluIHotb3JkZXJcclxuICAgIHN0YXRpYyBpbmRleEN1cnZlKHN0YXJ0LCBtaW5YLCBtaW5ZLCBpbnZTaXplKSB7XHJcbiAgICAgICAgdmFyIHAgPSBzdGFydDtcclxuICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgIGlmIChwLnogPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHAueiA9IEdyYXBoaWNzR2VvbWV0cnkuek9yZGVyKHAueCwgcC55LCBtaW5YLCBtaW5ZLCBpbnZTaXplKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBwLnByZXZaID0gcC5wcmV2O1xyXG4gICAgICAgICAgICBwLm5leHRaID0gcC5uZXh0O1xyXG4gICAgICAgICAgICBwID0gcC5uZXh0O1xyXG4gICAgICAgIH0gd2hpbGUgKHAgIT09IHN0YXJ0KTtcclxuICAgICAgICBwLnByZXZaLm5leHRaID0gbnVsbDtcclxuICAgICAgICBwLnByZXZaID0gbnVsbDtcclxuICAgICAgICBHcmFwaGljc0dlb21ldHJ5LnNvcnRMaW5rZWQocCk7XHJcbiAgICB9XHJcbiAgICAvLyBTaW1vbiBUYXRoYW0ncyBsaW5rZWQgbGlzdCBtZXJnZSBzb3J0IGFsZ29yaXRobVxyXG4gICAgLy8gaHR0cDovL3d3dy5jaGlhcmsuZ3JlZW5lbmQub3JnLnVrL35zZ3RhdGhhbS9hbGdvcml0aG1zL2xpc3Rzb3J0Lmh0bWxcclxuICAgIHN0YXRpYyBzb3J0TGlua2VkKGxpc3QpIHtcclxuICAgICAgICB2YXIgaSwgcCwgcSwgZSwgdGFpbCwgbnVtTWVyZ2VzLCBwU2l6ZSwgcVNpemUsIGluU2l6ZSA9IDE7XHJcbiAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICBwID0gbGlzdDtcclxuICAgICAgICAgICAgbGlzdCA9IG51bGw7XHJcbiAgICAgICAgICAgIHRhaWwgPSBudWxsO1xyXG4gICAgICAgICAgICBudW1NZXJnZXMgPSAwO1xyXG4gICAgICAgICAgICB3aGlsZSAocCkge1xyXG4gICAgICAgICAgICAgICAgbnVtTWVyZ2VzKys7XHJcbiAgICAgICAgICAgICAgICBxID0gcDtcclxuICAgICAgICAgICAgICAgIHBTaXplID0gMDtcclxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBpblNpemU7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHBTaXplKys7XHJcbiAgICAgICAgICAgICAgICAgICAgcSA9IHEubmV4dFo7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHFTaXplID0gaW5TaXplO1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKHBTaXplID4gMCB8fCAocVNpemUgPiAwICYmIHEpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBTaXplICE9PSAwICYmIChxU2l6ZSA9PT0gMCB8fCAhcSB8fCBwLnogPD0gcS56KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlID0gcDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcCA9IHAubmV4dFo7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBTaXplLS07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlID0gcTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcSA9IHEubmV4dFo7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHFTaXplLS07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0YWlsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhaWwubmV4dFogPSBlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGlzdCA9IGU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGUucHJldlogPSB0YWlsO1xyXG4gICAgICAgICAgICAgICAgICAgIHRhaWwgPSBlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcCA9IHE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGFpbC5uZXh0WiA9IG51bGw7XHJcbiAgICAgICAgICAgIGluU2l6ZSAqPSAyO1xyXG4gICAgICAgIH0gd2hpbGUgKG51bU1lcmdlcyA+IDEpO1xyXG4gICAgICAgIHJldHVybiBsaXN0O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAqIENhbGN1bGF0ZSB0aGUgcG9pbnRzIGZvciBhIHF1YWRyYXRpYyBiZXppZXIgY3VydmUuIChoZWxwZXIgZnVuY3Rpb24uLilcclxuICogQmFzZWQgb246IGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzc4NTA5Ny9ob3ctZG8taS1pbXBsZW1lbnQtYS1iZXppZXItY3VydmUtaW4tY1xyXG4gKlxyXG4gKiBJZ25vcmVkIGZyb20gZG9jcyBzaW5jZSBpdCBpcyBub3QgZGlyZWN0bHkgZXhwb3NlZC5cclxuICpcclxuICogQGlnbm9yZVxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAcGFyYW0ge251bWJlcn0gZnJvbVggLSBPcmlnaW4gcG9pbnQgeFxyXG4gKiBAcGFyYW0ge251bWJlcn0gZnJvbVkgLSBPcmlnaW4gcG9pbnQgeFxyXG4gKiBAcGFyYW0ge251bWJlcn0gY3BYIC0gQ29udHJvbCBwb2ludCB4XHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBjcFkgLSBDb250cm9sIHBvaW50IHlcclxuICogQHBhcmFtIHtudW1iZXJ9IHRvWCAtIERlc3RpbmF0aW9uIHBvaW50IHhcclxuICogQHBhcmFtIHtudW1iZXJ9IHRvWSAtIERlc3RpbmF0aW9uIHBvaW50IHlcclxuICogQHBhcmFtIHtudW1iZXJbXX0gW291dD1bXV0gLSBUaGUgb3V0cHV0IGFycmF5IHRvIGFkZCBwb2ludHMgaW50by4gSWYgbm90IHBhc3NlZCwgYSBuZXcgYXJyYXkgaXMgY3JlYXRlZC5cclxuICogQHJldHVybiB7bnVtYmVyW119IGFuIGFycmF5IG9mIHBvaW50c1xyXG4gKi9cclxuICAgIHN0YXRpYyBxdWFkcmF0aWNCZXppZXJDdXJ2ZShmcm9tWCwgZnJvbVksIGNwWCwgY3BZLCB0b1gsIHRvWSwgb3V0KSB7XHJcbiAgICAgICAgaWYgKG91dCA9PT0gdm9pZCAwKSB7XHJcbiAgICAgICAgICAgIG91dCA9IFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbiA9IDIwO1xyXG4gICAgICAgIHZhciBwb2ludHMgPSBvdXQ7XHJcbiAgICAgICAgdmFyIHhhID0gMDtcclxuICAgICAgICB2YXIgeWEgPSAwO1xyXG4gICAgICAgIHZhciB4YiA9IDA7XHJcbiAgICAgICAgdmFyIHliID0gMDtcclxuICAgICAgICB2YXIgeCA9IDA7XHJcbiAgICAgICAgdmFyIHkgPSAwO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBqID0gMDsgaSA8PSBuOyArK2kpIHtcclxuICAgICAgICAgICAgaiA9IGkgLyBuO1xyXG4gICAgICAgICAgICAvLyBUaGUgR3JlZW4gTGluZVxyXG4gICAgICAgICAgICB4YSA9IEdyYXBoaWNzR2VvbWV0cnkuZ2V0UHQoZnJvbVgsIGNwWCwgaik7XHJcbiAgICAgICAgICAgIHlhID0gR3JhcGhpY3NHZW9tZXRyeS5nZXRQdChmcm9tWSwgY3BZLCBqKTtcclxuICAgICAgICAgICAgeGIgPSBHcmFwaGljc0dlb21ldHJ5LmdldFB0KGNwWCwgdG9YLCBqKTtcclxuICAgICAgICAgICAgeWIgPSBHcmFwaGljc0dlb21ldHJ5LmdldFB0KGNwWSwgdG9ZLCBqKTtcclxuICAgICAgICAgICAgLy8gVGhlIEJsYWNrIERvdFxyXG4gICAgICAgICAgICB4ID0gR3JhcGhpY3NHZW9tZXRyeS5nZXRQdCh4YSwgeGIsIGopO1xyXG4gICAgICAgICAgICB5ID0gR3JhcGhpY3NHZW9tZXRyeS5nZXRQdCh5YSwgeWIsIGopO1xyXG4gICAgICAgICAgICBwb2ludHMucHVzaCh4LCB5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHBvaW50cztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gKiBDYWxjdWxhdGUgYSBzaW5nbGUgcG9pbnQgZm9yIGEgcXVhZHJhdGljIGJlemllciBjdXJ2ZS5cclxuICogVXRpbGl0eSBmdW5jdGlvbiB1c2VkIGJ5IHF1YWRyYXRpY0JlemllckN1cnZlLlxyXG4gKiBJZ25vcmVkIGZyb20gZG9jcyBzaW5jZSBpdCBpcyBub3QgZGlyZWN0bHkgZXhwb3NlZC5cclxuICpcclxuICogQGlnbm9yZVxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBAcGFyYW0ge251bWJlcn0gbjEgLSBmaXJzdCBudW1iZXJcclxuICogQHBhcmFtIHtudW1iZXJ9IG4yIC0gc2Vjb25kIG51bWJlclxyXG4gKiBAcGFyYW0ge251bWJlcn0gcGVyYyAtIHBlcmNlbnRhZ2VcclxuICogQHJldHVybiB7bnVtYmVyfSB0aGUgcmVzdWx0XHJcbiAqXHJcbiAqL1xyXG4gICAgc3RhdGljIGdldFB0KG4xLCBuMiwgcGVyYykge1xyXG4gICAgICAgIHZhciBkaWZmID0gbjIgLSBuMTtcclxuICAgICAgICByZXR1cm4gbjEgKyAoZGlmZiAqIHBlcmMpO1xyXG4gICAgfVxyXG59XHJcbkdyYXBoaWNzR2VvbWV0cnkuQkFUQ0hfUE9PTCA9IFtdO1xyXG5HcmFwaGljc0dlb21ldHJ5LkRSQVdfQ0FMTF9QT09MID0gW107XHJcbi8qKlxyXG4qIFRoZSBtYXhpbXVtIG51bWJlciBvZiBwb2ludHMgdG8gY29uc2lkZXIgYW4gb2JqZWN0IFwiYmF0Y2hhYmxlXCIsXHJcbiogYWJsZSB0byBiZSBiYXRjaGVkIGJ5IHRoZSByZW5kZXJlcidzIGJhdGNoIHN5c3RlbS5cclxuKlxyXG4qIEBtZW1iZXJvZiBQSVhJLkdyYXBoaWNzR2VvbWV0cnlcclxuKiBAc3RhdGljXHJcbiogQG1lbWJlciB7bnVtYmVyfSBCQVRDSEFCTEVfU0laRVxyXG4qIEBkZWZhdWx0IDEwMFxyXG4qL1xyXG5HcmFwaGljc0dlb21ldHJ5LkJBVENIQUJMRV9TSVpFID0gMTAwO1xyXG4vKipcclxuKiBCdWlsZHMgYSBwb2x5Z29uIHRvIGRyYXdcclxuKlxyXG4qIElnbm9yZWQgZnJvbSBkb2NzIHNpbmNlIGl0IGlzIG5vdCBkaXJlY3RseSBleHBvc2VkLlxyXG4qXHJcbiogQGlnbm9yZVxyXG4qIEBwcml2YXRlXHJcbiogQHBhcmFtIHtQSVhJLldlYkdMR3JhcGhpY3NEYXRhfSBncmFwaGljc0RhdGEgLSBUaGUgZ3JhcGhpY3Mgb2JqZWN0IGNvbnRhaW5pbmcgYWxsIHRoZSBuZWNlc3NhcnkgcHJvcGVydGllc1xyXG4qIEBwYXJhbSB7b2JqZWN0fSB3ZWJHTERhdGEgLSBhbiBvYmplY3QgY29udGFpbmluZyBhbGwgdGhlIFdlYkdMLXNwZWNpZmljIGluZm9ybWF0aW9uIHRvIGNyZWF0ZSB0aGlzIHNoYXBlXHJcbiogQHBhcmFtIHtvYmplY3R9IHdlYkdMRGF0YU5hdGl2ZUxpbmVzIC0gYW4gb2JqZWN0IGNvbnRhaW5pbmcgYWxsIHRoZSBXZWJHTC1zcGVjaWZpYyBpbmZvcm1hdGlvbiB0byBjcmVhdGUgbmF0aXZlTGluZXNcclxuKi9cclxuR3JhcGhpY3NHZW9tZXRyeS5idWlsZFBvbHkgPSB7XHJcbiAgICBuYW1lOiBcImJ1aWxkUG9seVwiLFxyXG4gICAgYnVpbGQ6IGZ1bmN0aW9uIGJ1aWxkKGdyYXBoaWNzRGF0YSkge1xyXG4gICAgICAgIGdyYXBoaWNzRGF0YS5wb2ludHMgPSBncmFwaGljc0RhdGEuc2hhcGUucG9pbnRzLnNsaWNlKCk7XHJcbiAgICB9LFxyXG4gICAgdHJpYW5ndWxhdGU6IGZ1bmN0aW9uIHRyaWFuZ3VsYXRlKGdyYXBoaWNzRGF0YSwgZ3JhcGhpY3NHZW9tZXRyeSkge1xyXG4gICAgICAgIHZhciBwb2ludHMgPSBncmFwaGljc0RhdGEucG9pbnRzO1xyXG4gICAgICAgIHZhciBob2xlcyA9IGdyYXBoaWNzRGF0YS5ob2xlcztcclxuICAgICAgICB2YXIgdmVydHMgPSBncmFwaGljc0dlb21ldHJ5LnBvaW50cztcclxuICAgICAgICB2YXIgaW5kaWNlcyA9IGdyYXBoaWNzR2VvbWV0cnkuaW5kaWNlcztcclxuICAgICAgICBpZiAocG9pbnRzLmxlbmd0aCA+PSA2KSB7XHJcbiAgICAgICAgICAgIHZhciBob2xlQXJyYXkgPSBbXTtcclxuICAgICAgICAgICAgLy8gUHJvY2VzcyBob2xlcy4uXHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaG9sZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBob2xlID0gaG9sZXNbaV07XHJcbiAgICAgICAgICAgICAgICBob2xlQXJyYXkucHVzaChwb2ludHMubGVuZ3RoIC8gMik7XHJcbiAgICAgICAgICAgICAgICBwb2ludHMgPSBwb2ludHMuY29uY2F0KGhvbGUucG9pbnRzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBzb3J0IGNvbG9yXHJcbiAgICAgICAgICAgIHZhciB0cmlhbmdsZXMgPSBHcmFwaGljc0dlb21ldHJ5LmVhcmN1dChwb2ludHMsIGhvbGVBcnJheSwgMik7XHJcbiAgICAgICAgICAgIGlmICghdHJpYW5nbGVzKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHZlcnRQb3MgPSB2ZXJ0cy5sZW5ndGggLyAyO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCB0cmlhbmdsZXMubGVuZ3RoOyBpJDEgKz0gMykge1xyXG4gICAgICAgICAgICAgICAgaW5kaWNlcy5wdXNoKHRyaWFuZ2xlc1tpJDFdICsgdmVydFBvcyk7XHJcbiAgICAgICAgICAgICAgICBpbmRpY2VzLnB1c2godHJpYW5nbGVzW2kkMSArIDFdICsgdmVydFBvcyk7XHJcbiAgICAgICAgICAgICAgICBpbmRpY2VzLnB1c2godHJpYW5nbGVzW2kkMSArIDJdICsgdmVydFBvcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yICh2YXIgaSQyID0gMDsgaSQyIDwgcG9pbnRzLmxlbmd0aDsgaSQyKyspIHtcclxuICAgICAgICAgICAgICAgIHZlcnRzLnB1c2gocG9pbnRzW2kkMl0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxufTtcclxuLyoqXHJcbiogQnVpbGRzIGEgcmVjdGFuZ2xlIHRvIGRyYXdcclxuKlxyXG4qIElnbm9yZWQgZnJvbSBkb2NzIHNpbmNlIGl0IGlzIG5vdCBkaXJlY3RseSBleHBvc2VkLlxyXG4qXHJcbiogQGlnbm9yZVxyXG4qIEBwcml2YXRlXHJcbiogQHBhcmFtIHtQSVhJLldlYkdMR3JhcGhpY3NEYXRhfSBncmFwaGljc0RhdGEgLSBUaGUgZ3JhcGhpY3Mgb2JqZWN0IGNvbnRhaW5pbmcgYWxsIHRoZSBuZWNlc3NhcnkgcHJvcGVydGllc1xyXG4qIEBwYXJhbSB7b2JqZWN0fSB3ZWJHTERhdGEgLSBhbiBvYmplY3QgY29udGFpbmluZyBhbGwgdGhlIFdlYkdMLXNwZWNpZmljIGluZm9ybWF0aW9uIHRvIGNyZWF0ZSB0aGlzIHNoYXBlXHJcbiogQHBhcmFtIHtvYmplY3R9IHdlYkdMRGF0YU5hdGl2ZUxpbmVzIC0gYW4gb2JqZWN0IGNvbnRhaW5pbmcgYWxsIHRoZSBXZWJHTC1zcGVjaWZpYyBpbmZvcm1hdGlvbiB0byBjcmVhdGUgbmF0aXZlTGluZXNcclxuKi9cclxuR3JhcGhpY3NHZW9tZXRyeS5idWlsZFJlY3RhbmdsZSA9IHtcclxuICAgIG5hbWU6IFwiYnVpbGRSZWN0YW5nbGVcIixcclxuICAgIGJ1aWxkOiBmdW5jdGlvbiBidWlsZChncmFwaGljc0RhdGEpIHtcclxuICAgICAgICAvLyAtLS0gLy9cclxuICAgICAgICAvLyBuZWVkIHRvIGNvbnZlcnQgcG9pbnRzIHRvIGEgbmljZSByZWd1bGFyIGRhdGFcclxuICAgICAgICAvL1xyXG4gICAgICAgIHZhciByZWN0RGF0YSA9IGdyYXBoaWNzRGF0YS5zaGFwZTtcclxuICAgICAgICB2YXIgeCA9IHJlY3REYXRhLng7XHJcbiAgICAgICAgdmFyIHkgPSByZWN0RGF0YS55O1xyXG4gICAgICAgIHZhciB3aWR0aCA9IHJlY3REYXRhLndpZHRoO1xyXG4gICAgICAgIHZhciBoZWlnaHQgPSByZWN0RGF0YS5oZWlnaHQ7XHJcbiAgICAgICAgdmFyIHBvaW50cyA9IGdyYXBoaWNzRGF0YS5wb2ludHM7XHJcbiAgICAgICAgcG9pbnRzLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgcG9pbnRzLnB1c2goeCwgeSwgeCArIHdpZHRoLCB5LCB4ICsgd2lkdGgsIHkgKyBoZWlnaHQsIHgsIHkgKyBoZWlnaHQpO1xyXG4gICAgfSxcclxuICAgIHRyaWFuZ3VsYXRlOiBmdW5jdGlvbiB0cmlhbmd1bGF0ZShncmFwaGljc0RhdGEsIGdyYXBoaWNzR2VvbWV0cnkpIHtcclxuICAgICAgICB2YXIgcG9pbnRzID0gZ3JhcGhpY3NEYXRhLnBvaW50cztcclxuICAgICAgICB2YXIgdmVydHMgPSBncmFwaGljc0dlb21ldHJ5LnBvaW50cztcclxuICAgICAgICB2YXIgdmVydFBvcyA9IHZlcnRzLmxlbmd0aCAvIDI7XHJcbiAgICAgICAgdmVydHMucHVzaChwb2ludHNbMF0sIHBvaW50c1sxXSwgcG9pbnRzWzJdLCBwb2ludHNbM10sIHBvaW50c1s2XSwgcG9pbnRzWzddLCBwb2ludHNbNF0sIHBvaW50c1s1XSk7XHJcbiAgICAgICAgZ3JhcGhpY3NHZW9tZXRyeS5pbmRpY2VzLnB1c2godmVydFBvcywgdmVydFBvcyArIDEsIHZlcnRQb3MgKyAyLCB2ZXJ0UG9zICsgMSwgdmVydFBvcyArIDIsIHZlcnRQb3MgKyAzKTtcclxuICAgIH0sXHJcbn07XHJcbi8qKlxyXG4qIEJ1aWxkcyBhIHJvdW5kZWQgcmVjdGFuZ2xlIHRvIGRyYXdcclxuKlxyXG4qIElnbm9yZWQgZnJvbSBkb2NzIHNpbmNlIGl0IGlzIG5vdCBkaXJlY3RseSBleHBvc2VkLlxyXG4qXHJcbiogQGlnbm9yZVxyXG4qIEBwcml2YXRlXHJcbiogQHBhcmFtIHtQSVhJLldlYkdMR3JhcGhpY3NEYXRhfSBncmFwaGljc0RhdGEgLSBUaGUgZ3JhcGhpY3Mgb2JqZWN0IGNvbnRhaW5pbmcgYWxsIHRoZSBuZWNlc3NhcnkgcHJvcGVydGllc1xyXG4qIEBwYXJhbSB7b2JqZWN0fSB3ZWJHTERhdGEgLSBhbiBvYmplY3QgY29udGFpbmluZyBhbGwgdGhlIFdlYkdMLXNwZWNpZmljIGluZm9ybWF0aW9uIHRvIGNyZWF0ZSB0aGlzIHNoYXBlXHJcbiogQHBhcmFtIHtvYmplY3R9IHdlYkdMRGF0YU5hdGl2ZUxpbmVzIC0gYW4gb2JqZWN0IGNvbnRhaW5pbmcgYWxsIHRoZSBXZWJHTC1zcGVjaWZpYyBpbmZvcm1hdGlvbiB0byBjcmVhdGUgbmF0aXZlTGluZXNcclxuKi9cclxuR3JhcGhpY3NHZW9tZXRyeS5idWlsZFJvdW5kZWRSZWN0YW5nbGUgPSB7XHJcbiAgICBuYW1lOiBcImJ1aWxkUm91bmRlZFJlY3RhbmdsZVwiLFxyXG4gICAgYnVpbGQ6IGZ1bmN0aW9uIGJ1aWxkKGdyYXBoaWNzRGF0YSkge1xyXG4gICAgICAgIHZhciBycmVjdERhdGEgPSBncmFwaGljc0RhdGEuc2hhcGU7XHJcbiAgICAgICAgdmFyIHBvaW50cyA9IGdyYXBoaWNzRGF0YS5wb2ludHM7XHJcbiAgICAgICAgdmFyIHggPSBycmVjdERhdGEueDtcclxuICAgICAgICB2YXIgeSA9IHJyZWN0RGF0YS55O1xyXG4gICAgICAgIHZhciB3aWR0aCA9IHJyZWN0RGF0YS53aWR0aDtcclxuICAgICAgICB2YXIgaGVpZ2h0ID0gcnJlY3REYXRhLmhlaWdodDtcclxuICAgICAgICB2YXIgcmFkaXVzID0gcnJlY3REYXRhLnJhZGl1cztcclxuICAgICAgICBwb2ludHMubGVuZ3RoID0gMDtcclxuICAgICAgICBHcmFwaGljc0dlb21ldHJ5LnF1YWRyYXRpY0JlemllckN1cnZlKHgsIHkgKyByYWRpdXMsIHgsIHksIHggKyByYWRpdXMsIHksIHBvaW50cyk7XHJcbiAgICAgICAgR3JhcGhpY3NHZW9tZXRyeS5xdWFkcmF0aWNCZXppZXJDdXJ2ZSh4ICsgd2lkdGggLSByYWRpdXMsIHksIHggKyB3aWR0aCwgeSwgeCArIHdpZHRoLCB5ICsgcmFkaXVzLCBwb2ludHMpO1xyXG4gICAgICAgIEdyYXBoaWNzR2VvbWV0cnkucXVhZHJhdGljQmV6aWVyQ3VydmUoeCArIHdpZHRoLCB5ICsgaGVpZ2h0IC0gcmFkaXVzLCB4ICsgd2lkdGgsIHkgKyBoZWlnaHQsIHggKyB3aWR0aCAtIHJhZGl1cywgeSArIGhlaWdodCwgcG9pbnRzKTtcclxuICAgICAgICBHcmFwaGljc0dlb21ldHJ5LnF1YWRyYXRpY0JlemllckN1cnZlKHggKyByYWRpdXMsIHkgKyBoZWlnaHQsIHgsIHkgKyBoZWlnaHQsIHgsIHkgKyBoZWlnaHQgLSByYWRpdXMsIHBvaW50cyk7XHJcbiAgICAgICAgLy8gdGhpcyB0aW55IG51bWJlciBkZWFscyB3aXRoIHRoZSBpc3N1ZSB0aGF0IG9jY3VycyB3aGVuIHBvaW50cyBvdmVybGFwIGFuZCBlYXJjdXQgZmFpbHMgdG8gdHJpYW5ndWxhdGUgdGhlIGl0ZW0uXHJcbiAgICAgICAgLy8gVE9ETyAtIGZpeCB0aGlzIHByb3Blcmx5LCB0aGlzIGlzIG5vdCB2ZXJ5IGVsZWdhbnQuLiBidXQgaXQgd29ya3MgZm9yIG5vdy5cclxuICAgIH0sXHJcbiAgICB0cmlhbmd1bGF0ZTogZnVuY3Rpb24gdHJpYW5ndWxhdGUoZ3JhcGhpY3NEYXRhLCBncmFwaGljc0dlb21ldHJ5KSB7XHJcbiAgICAgICAgdmFyIHBvaW50cyA9IGdyYXBoaWNzRGF0YS5wb2ludHM7XHJcbiAgICAgICAgdmFyIHZlcnRzID0gZ3JhcGhpY3NHZW9tZXRyeS5wb2ludHM7XHJcbiAgICAgICAgdmFyIGluZGljZXMgPSBncmFwaGljc0dlb21ldHJ5LmluZGljZXM7XHJcbiAgICAgICAgdmFyIHZlY1BvcyA9IHZlcnRzLmxlbmd0aCAvIDI7XHJcbiAgICAgICAgdmFyIHRyaWFuZ2xlcyA9IEdyYXBoaWNzR2VvbWV0cnkuZWFyY3V0KHBvaW50cywgbnVsbCwgMik7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGogPSB0cmlhbmdsZXMubGVuZ3RoOyBpIDwgajsgaSArPSAzKSB7XHJcbiAgICAgICAgICAgIGluZGljZXMucHVzaCh0cmlhbmdsZXNbaV0gKyB2ZWNQb3MpO1xyXG4gICAgICAgICAgICAvLyAgICAgaW5kaWNlcy5wdXNoKHRyaWFuZ2xlc1tpXSArIHZlY1Bvcyk7XHJcbiAgICAgICAgICAgIGluZGljZXMucHVzaCh0cmlhbmdsZXNbaSArIDFdICsgdmVjUG9zKTtcclxuICAgICAgICAgICAgLy8gICBpbmRpY2VzLnB1c2godHJpYW5nbGVzW2kgKyAyXSArIHZlY1Bvcyk7XHJcbiAgICAgICAgICAgIGluZGljZXMucHVzaCh0cmlhbmdsZXNbaSArIDJdICsgdmVjUG9zKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yICh2YXIgaSQxID0gMCwgaiQxID0gcG9pbnRzLmxlbmd0aDsgaSQxIDwgaiQxOyBpJDErKykge1xyXG4gICAgICAgICAgICB2ZXJ0cy5wdXNoKHBvaW50c1tpJDFdLCBwb2ludHNbKytpJDFdKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG59O1xyXG4vKipcclxuKiBCdWlsZHMgYSBjaXJjbGUgdG8gZHJhd1xyXG4qXHJcbiogSWdub3JlZCBmcm9tIGRvY3Mgc2luY2UgaXQgaXMgbm90IGRpcmVjdGx5IGV4cG9zZWQuXHJcbipcclxuKiBAaWdub3JlXHJcbiogQHByaXZhdGVcclxuKiBAcGFyYW0ge1BJWEkuV2ViR0xHcmFwaGljc0RhdGF9IGdyYXBoaWNzRGF0YSAtIFRoZSBncmFwaGljcyBvYmplY3QgdG8gZHJhd1xyXG4qIEBwYXJhbSB7b2JqZWN0fSB3ZWJHTERhdGEgLSBhbiBvYmplY3QgY29udGFpbmluZyBhbGwgdGhlIFdlYkdMLXNwZWNpZmljIGluZm9ybWF0aW9uIHRvIGNyZWF0ZSB0aGlzIHNoYXBlXHJcbiogQHBhcmFtIHtvYmplY3R9IHdlYkdMRGF0YU5hdGl2ZUxpbmVzIC0gYW4gb2JqZWN0IGNvbnRhaW5pbmcgYWxsIHRoZSBXZWJHTC1zcGVjaWZpYyBpbmZvcm1hdGlvbiB0byBjcmVhdGUgbmF0aXZlTGluZXNcclxuKi9cclxuR3JhcGhpY3NHZW9tZXRyeS5idWlsZENpcmNsZSA9IHtcclxuICAgIG5hbWU6IFwiYnVpbGRDaXJjbGVcIixcclxuICAgIGJ1aWxkOiBmdW5jdGlvbiBidWlsZChncmFwaGljc0RhdGEpIHtcclxuICAgICAgICAvLyBuZWVkIHRvIGNvbnZlcnQgcG9pbnRzIHRvIGEgbmljZSByZWd1bGFyIGRhdGFcclxuICAgICAgICB2YXIgY2lyY2xlRGF0YSA9IGdyYXBoaWNzRGF0YS5zaGFwZTtcclxuICAgICAgICB2YXIgcG9pbnRzID0gZ3JhcGhpY3NEYXRhLnBvaW50cztcclxuICAgICAgICB2YXIgeCA9IGNpcmNsZURhdGEueDtcclxuICAgICAgICB2YXIgeSA9IGNpcmNsZURhdGEueTtcclxuICAgICAgICB2YXIgd2lkdGg7XHJcbiAgICAgICAgdmFyIGhlaWdodDtcclxuICAgICAgICBwb2ludHMubGVuZ3RoID0gMDtcclxuICAgICAgICAvLyBUT0RPIC0gYml0IGhhY2t5Pz9cclxuICAgICAgICBpZiAoZ3JhcGhpY3NEYXRhLnR5cGUgPT09IFNoYXBlU2V0dGluZ3NfMS5TaGFwZVNldHRpbmdzLlNIQVBFUy5DSVJDKSB7XHJcbiAgICAgICAgICAgIHdpZHRoID0gY2lyY2xlRGF0YS5yYWRpdXM7XHJcbiAgICAgICAgICAgIGhlaWdodCA9IGNpcmNsZURhdGEucmFkaXVzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgd2lkdGggPSBjaXJjbGVEYXRhLndpZHRoO1xyXG4gICAgICAgICAgICBoZWlnaHQgPSBjaXJjbGVEYXRhLmhlaWdodDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHdpZHRoID09PSAwIHx8IGhlaWdodCA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciB0b3RhbFNlZ3MgPSBNYXRoLmZsb29yKDMwICogTWF0aC5zcXJ0KGNpcmNsZURhdGEucmFkaXVzKSlcclxuICAgICAgICAgICAgfHwgTWF0aC5mbG9vcigxNSAqIE1hdGguc3FydChjaXJjbGVEYXRhLndpZHRoICsgY2lyY2xlRGF0YS5oZWlnaHQpKTtcclxuICAgICAgICB0b3RhbFNlZ3MgLz0gMi4zO1xyXG4gICAgICAgIHZhciBzZWcgPSAoTWF0aC5QSSAqIDIpIC8gdG90YWxTZWdzO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG90YWxTZWdzOyBpKyspIHtcclxuICAgICAgICAgICAgcG9pbnRzLnB1c2goeCArIChNYXRoLnNpbigtc2VnICogaSkgKiB3aWR0aCksIHkgKyAoTWF0aC5jb3MoLXNlZyAqIGkpICogaGVpZ2h0KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHBvaW50cy5wdXNoKHBvaW50c1swXSwgcG9pbnRzWzFdKTtcclxuICAgIH0sXHJcbiAgICB0cmlhbmd1bGF0ZTogZnVuY3Rpb24gdHJpYW5ndWxhdGUoZ3JhcGhpY3NEYXRhLCBncmFwaGljc0dlb21ldHJ5KSB7XHJcbiAgICAgICAgdmFyIHBvaW50cyA9IGdyYXBoaWNzRGF0YS5wb2ludHM7XHJcbiAgICAgICAgdmFyIHZlcnRzID0gZ3JhcGhpY3NHZW9tZXRyeS5wb2ludHM7XHJcbiAgICAgICAgdmFyIGluZGljZXMgPSBncmFwaGljc0dlb21ldHJ5LmluZGljZXM7XHJcbiAgICAgICAgdmFyIHZlcnRQb3MgPSB2ZXJ0cy5sZW5ndGggLyAyO1xyXG4gICAgICAgIHZhciBjZW50ZXIgPSB2ZXJ0UG9zO1xyXG4gICAgICAgIHZlcnRzLnB1c2goZ3JhcGhpY3NEYXRhLnNoYXBlLngsIGdyYXBoaWNzRGF0YS5zaGFwZS55KTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkgKz0gMikge1xyXG4gICAgICAgICAgICB2ZXJ0cy5wdXNoKHBvaW50c1tpXSwgcG9pbnRzW2kgKyAxXSk7XHJcbiAgICAgICAgICAgIC8vIGFkZCBzb21lIHV2c1xyXG4gICAgICAgICAgICBpbmRpY2VzLnB1c2godmVydFBvcysrLCBjZW50ZXIsIHZlcnRQb3MpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbn07XHJcbmV4cG9ydHMuR3JhcGhpY3NHZW9tZXRyeSA9IEdyYXBoaWNzR2VvbWV0cnk7XHJcbmNsYXNzIE5vZGUge1xyXG4gICAgY29uc3RydWN0b3IoaSwgeCwgeSkge1xyXG4gICAgICAgIC8vIHZlcnRleCBpbmRleCBpbiBjb29yZGluYXRlcyBhcnJheVxyXG4gICAgICAgIHRoaXMuaSA9IGk7XHJcbiAgICAgICAgLy8gdmVydGV4IGNvb3JkaW5hdGVzXHJcbiAgICAgICAgdGhpcy54ID0geDtcclxuICAgICAgICB0aGlzLnkgPSB5O1xyXG4gICAgICAgIC8vIHByZXZpb3VzIGFuZCBuZXh0IHZlcnRleCBub2RlcyBpbiBhIHBvbHlnb24gcmluZ1xyXG4gICAgICAgIHRoaXMucHJldiA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5uZXh0ID0gbnVsbDtcclxuICAgICAgICAvLyB6LW9yZGVyIGN1cnZlIHZhbHVlXHJcbiAgICAgICAgdGhpcy56ID0gbnVsbDtcclxuICAgICAgICAvLyBwcmV2aW91cyBhbmQgbmV4dCBub2RlcyBpbiB6LW9yZGVyXHJcbiAgICAgICAgdGhpcy5wcmV2WiA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5uZXh0WiA9IG51bGw7XHJcbiAgICAgICAgLy8gaW5kaWNhdGVzIHdoZXRoZXIgdGhpcyBpcyBhIHN0ZWluZXIgcG9pbnRcclxuICAgICAgICB0aGlzLnN0ZWluZXIgPSBmYWxzZTtcclxuICAgIH1cclxufVxyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBNYXRyaXhfMSA9IHJlcXVpcmUoXCIuL01hdHJpeFwiKTtcclxuY2xhc3MgR3JvdXBEOCB7XHJcbiAgICBzdGF0aWMgdVgoaW5kKSB7XHJcbiAgICAgICAgR3JvdXBEOC5pbml0KCk7XHJcbiAgICAgICAgcmV0dXJuIEdyb3VwRDgudXhbaW5kXTtcclxuICAgIH1cclxuICAgIHN0YXRpYyB1WShpbmQpIHtcclxuICAgICAgICBHcm91cEQ4LmluaXQoKTtcclxuICAgICAgICByZXR1cm4gR3JvdXBEOC51eVtpbmRdO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIHZYKGluZCkge1xyXG4gICAgICAgIEdyb3VwRDguaW5pdCgpO1xyXG4gICAgICAgIHJldHVybiBHcm91cEQ4LnZ4W2luZF07XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgdlkoaW5kKSB7XHJcbiAgICAgICAgR3JvdXBEOC5pbml0KCk7XHJcbiAgICAgICAgcmV0dXJuIEdyb3VwRDgudnlbaW5kXTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBpbnYocm90YXRpb24pIHtcclxuICAgICAgICBpZiAocm90YXRpb24gJiA4KSB7XHJcbiAgICAgICAgICAgIHJldHVybiByb3RhdGlvbiAmIDE1O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gKC1yb3RhdGlvbikgJiA3O1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGFkZChyb3RhdGlvblNlY29uZCwgcm90YXRpb25GaXJzdCkge1xyXG4gICAgICAgIEdyb3VwRDguaW5pdCgpO1xyXG4gICAgICAgIHJldHVybiBHcm91cEQ4Lm11bFtyb3RhdGlvblNlY29uZF1bcm90YXRpb25GaXJzdF07XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgc3ViKHJvdGF0aW9uU2Vjb25kLCByb3RhdGlvbkZpcnN0KSB7XHJcbiAgICAgICAgR3JvdXBEOC5pbml0KCk7XHJcbiAgICAgICAgcmV0dXJuIEdyb3VwRDgubXVsW3JvdGF0aW9uU2Vjb25kXVtHcm91cEQ4Lmludihyb3RhdGlvbkZpcnN0KV07XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgcm90YXRlMTgwKHJvdGF0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIHJvdGF0aW9uIF4gNDtcclxuICAgIH1cclxuICAgIHN0YXRpYyBpc1ZlcnRpY2FsKHJvdGF0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIChyb3RhdGlvbiAmIDMpID09PSAyO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGJ5RGlyZWN0aW9uKGR4LCBkeSkge1xyXG4gICAgICAgIEdyb3VwRDguaW5pdCgpO1xyXG4gICAgICAgIGlmIChNYXRoLmFicyhkeCkgKiAyIDw9IE1hdGguYWJzKGR5KSkge1xyXG4gICAgICAgICAgICBpZiAoZHkgPj0gMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIEdyb3VwRDguUztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gR3JvdXBEOC5OO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChNYXRoLmFicyhkeSkgKiAyIDw9IE1hdGguYWJzKGR4KSkge1xyXG4gICAgICAgICAgICBpZiAoZHggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gR3JvdXBEOC5FO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBHcm91cEQ4Llc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGR5ID4gMCkge1xyXG4gICAgICAgICAgICBpZiAoZHggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gR3JvdXBEOC5TRTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gR3JvdXBEOC5TVztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoZHggPiAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBHcm91cEQ4Lk5FO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gR3JvdXBEOC5OVztcclxuICAgIH1cclxuICAgIHN0YXRpYyBtYXRyaXhBcHBlbmRSb3RhdGlvbkludihtYXRyaXgsIHJvdGF0aW9uLCB0eCA9IDAsIHR5ID0gMCkge1xyXG4gICAgICAgIEdyb3VwRDguaW5pdCgpO1xyXG4gICAgICAgIGxldCBtYXQgPSBHcm91cEQ4LnRlbXBNYXRyaWNlc1tHcm91cEQ4Lmludihyb3RhdGlvbildO1xyXG4gICAgICAgIG1hdC50eCA9IHR4O1xyXG4gICAgICAgIG1hdC50eSA9IHR5O1xyXG4gICAgICAgIG1hdHJpeC5hcHBlbmQobWF0KTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBzaWdudW0oeCkge1xyXG4gICAgICAgIGlmICh4IDwgMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh4ID4gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgaW5pdCgpIHtcclxuICAgICAgICBpZiAoR3JvdXBEOC5pc0luaXQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBHcm91cEQ4LmlzSW5pdCA9IHRydWU7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAxNjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciByb3cgPSBbXTtcclxuICAgICAgICAgICAgR3JvdXBEOC5tdWwucHVzaChyb3cpO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IDE2OyBqKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBfdXggPSBHcm91cEQ4LnNpZ251bSgoR3JvdXBEOC51eFtpXSAqIEdyb3VwRDgudXhbal0pICsgKEdyb3VwRDgudnhbaV0gKiBHcm91cEQ4LnV5W2pdKSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgX3V5ID0gR3JvdXBEOC5zaWdudW0oKEdyb3VwRDgudXlbaV0gKiBHcm91cEQ4LnV4W2pdKSArIChHcm91cEQ4LnZ5W2ldICogR3JvdXBEOC51eVtqXSkpO1xyXG4gICAgICAgICAgICAgICAgdmFyIF92eCA9IEdyb3VwRDguc2lnbnVtKChHcm91cEQ4LnV4W2ldICogR3JvdXBEOC52eFtqXSkgKyAoR3JvdXBEOC52eFtpXSAqIEdyb3VwRDgudnlbal0pKTtcclxuICAgICAgICAgICAgICAgIHZhciBfdnkgPSBHcm91cEQ4LnNpZ251bSgoR3JvdXBEOC51eVtpXSAqIEdyb3VwRDgudnhbal0pICsgKEdyb3VwRDgudnlbaV0gKiBHcm91cEQ4LnZ5W2pdKSk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IDE2OyBrKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoR3JvdXBEOC51eFtrXSA9PT0gX3V4ICYmIEdyb3VwRDgudXlba10gPT09IF91eSAmJiBHcm91cEQ4LnZ4W2tdID09PSBfdnggJiYgR3JvdXBEOC52eVtrXSA9PT0gX3Z5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdy5wdXNoKGspO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgMTY7IGkkMSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBtYXQgPSBuZXcgTWF0cml4XzEuTWF0cml4KCk7XHJcbiAgICAgICAgICAgIG1hdC5zZXQoR3JvdXBEOC51eFtpJDFdLCBHcm91cEQ4LnV5W2kkMV0sIEdyb3VwRDgudnhbaSQxXSwgR3JvdXBEOC52eVtpJDFdLCAwLCAwKTtcclxuICAgICAgICAgICAgR3JvdXBEOC50ZW1wTWF0cmljZXMucHVzaChtYXQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5Hcm91cEQ4LmlzSW5pdCA9IGZhbHNlO1xyXG5Hcm91cEQ4LkUgPSAwO1xyXG5Hcm91cEQ4LlNFID0gMTtcclxuR3JvdXBEOC5TID0gMjtcclxuR3JvdXBEOC5TVyA9IDM7XHJcbkdyb3VwRDguVyA9IDQ7XHJcbkdyb3VwRDguTlcgPSA1O1xyXG5Hcm91cEQ4Lk4gPSA2O1xyXG5Hcm91cEQ4Lk5FID0gNztcclxuR3JvdXBEOC5NSVJST1JfVkVSVElDQUwgPSA4O1xyXG5Hcm91cEQ4Lk1JUlJPUl9IT1JJWk9OVEFMID0gMTI7XHJcbkdyb3VwRDgudXggPSBbMSwgMSwgMCwgLTEsIC0xLCAtMSwgMCwgMSwgMSwgMSwgMCwgLTEsIC0xLCAtMSwgMCwgMV07XHJcbkdyb3VwRDgudXkgPSBbMCwgMSwgMSwgMSwgMCwgLTEsIC0xLCAtMSwgMCwgMSwgMSwgMSwgMCwgLTEsIC0xLCAtMV07XHJcbkdyb3VwRDgudnggPSBbMCwgLTEsIC0xLCAtMSwgMCwgMSwgMSwgMSwgMCwgMSwgMSwgMSwgMCwgLTEsIC0xLCAtMV07XHJcbkdyb3VwRDgudnkgPSBbMSwgMSwgMCwgLTEsIC0xLCAtMSwgMCwgMSwgLTEsIC0xLCAwLCAxLCAxLCAxLCAwLCAtMV07XHJcbkdyb3VwRDgudGVtcE1hdHJpY2VzID0gW107XHJcbkdyb3VwRDgubXVsID0gW107XHJcbmV4cG9ydHMuR3JvdXBEOCA9IEdyb3VwRDg7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IEV2ZW50XzEgPSByZXF1aXJlKFwiLi9FdmVudFwiKTtcclxuY2xhc3MgSU9FcnJvckV2ZW50IGV4dGVuZHMgRXZlbnRfMS5FdmVudCB7XHJcbiAgICBjb25zdHJ1Y3Rvcih0eXBlLCBidWJibGUgPSB0cnVlLCBjYW5jZWxhYmxlID0gdHJ1ZSkge1xyXG4gICAgICAgIHN1cGVyKHR5cGUsIGJ1YmJsZSwgY2FuY2VsYWJsZSk7XHJcbiAgICAgICAgdGhpcy5lcnJvcklkID0gMDtcclxuICAgIH1cclxuICAgIGNsb25lKCkge1xyXG4gICAgICAgIHZhciBldmVudCA9IG5ldyBJT0Vycm9yRXZlbnQodGhpcy50eXBlLCB0aGlzLmJ1YmJsZXMsIHRoaXMuY2FuY2VsYWJsZSk7XHJcbiAgICAgICAgZXZlbnQudGV4dCA9IHRoaXMudGV4dDtcclxuICAgICAgICBldmVudC5lcnJvcklkID0gdGhpcy5lcnJvcklkO1xyXG4gICAgICAgIHJldHVybiBldmVudDtcclxuICAgIH1cclxuICAgIGdldCBpc0Rpc3Bvc2FibGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG59XHJcbklPRXJyb3JFdmVudC5JT19FUlJPUiA9IFwiaW9FcnJvclwiO1xyXG5leHBvcnRzLklPRXJyb3JFdmVudCA9IElPRXJyb3JFdmVudDtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgQmFzZUltYWdlUmVzb3VyY2VfMSA9IHJlcXVpcmUoXCIuL0Jhc2VJbWFnZVJlc291cmNlXCIpO1xyXG5jb25zdCBEaXNwbGF5U2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL0Rpc3BsYXlTZXR0aW5nc1wiKTtcclxuY29uc3QgTG9nZ2VyXzEgPSByZXF1aXJlKFwiLi9Mb2dnZXJcIik7XHJcbmNsYXNzIEltYWdlUmVzb3VyY2UgZXh0ZW5kcyBCYXNlSW1hZ2VSZXNvdXJjZV8xLkJhc2VJbWFnZVJlc291cmNlIHtcclxuICAgIGNvbnN0cnVjdG9yKHNvdXJjZSwgb3B0aW9ucyA9IHt9KSB7XHJcbiAgICAgICAgc3VwZXIoc291cmNlKTtcclxuICAgICAgICBpZiAoIShzb3VyY2UgaW5zdGFuY2VvZiBIVE1MSW1hZ2VFbGVtZW50KSkge1xyXG4gICAgICAgICAgICB2YXIgaW1hZ2VFbGVtZW50ID0gbmV3IEltYWdlKCk7XHJcbiAgICAgICAgICAgIC8vIEJhc2VJbWFnZVJlc291cmNlLmNyb3NzT3JpZ2luKGltYWdlRWxlbWVudCwgc291cmNlLCBvcHRpb25zLmNyb3Nzb3JpZ2luKTtcclxuICAgICAgICAgICAgaW1hZ2VFbGVtZW50LnNyYyA9IHNvdXJjZTtcclxuICAgICAgICAgICAgc291cmNlID0gaW1hZ2VFbGVtZW50O1xyXG4gICAgICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVVJMIG9mIHRoZSBpbWFnZSBzb3VyY2VcclxuICAgICAgICAgKiBAbWVtYmVyIHtzdHJpbmd9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy51cmwgPSBzb3VyY2Uuc3JjO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFdoZW4gcHJvY2VzcyBpcyBjb21wbGV0ZWRcclxuICAgICAgICAgKiBAbWVtYmVyIHtQcm9taXNlPHZvaWQ+fVxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5fcHJvY2VzcyA9IG51bGw7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSWYgdGhlIGltYWdlIHNob3VsZCBiZSBkaXNwb3NlZCBhZnRlciB1cGxvYWRcclxuICAgICAgICAgKiBAbWVtYmVyIHtib29sZWFufVxyXG4gICAgICAgICAqIEBkZWZhdWx0IGZhbHNlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5wcmVzZXJ2ZUJpdG1hcCA9IGZhbHNlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIElmIGNhcGFibGUsIGNvbnZlcnQgdGhlIGltYWdlIHVzaW5nIGNyZWF0ZUltYWdlQml0bWFwIEFQSVxyXG4gICAgICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XHJcbiAgICAgICAgICogQGRlZmF1bHQgUElYSS5zZXR0aW5ncy5DUkVBVEVfSU1BR0VfQklUTUFQXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5jcmVhdGVCaXRtYXAgPSBvcHRpb25zLmNyZWF0ZUJpdG1hcCAhPT0gZmFsc2UgJiYgRGlzcGxheVNldHRpbmdzXzEuRGlzcGxheVNldHRpbmdzLkNSRUFURV9JTUFHRV9CSVRNQVAgJiYgISF3aW5kb3cuY3JlYXRlSW1hZ2VCaXRtYXA7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ29udHJvbHMgdGV4dHVyZSBwcmVtdWx0aXBseUFscGhhIGZpZWxkXHJcbiAgICAgICAgICogQ29waWVzIGZyb20gb3B0aW9uc1xyXG4gICAgICAgICAqIEBtZW1iZXIge2Jvb2xlYW58bnVsbH1cclxuICAgICAgICAgKiBAcmVhZG9ubHlcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnByZW11bHRpcGx5QWxwaGEgPSBvcHRpb25zLnByZW11bHRpcGx5QWxwaGEgIT09IGZhbHNlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBJbWFnZUJpdG1hcCBlbGVtZW50IGNyZWF0ZWQgZm9yIEhUTUxJbWFnZUVsZW1lbnRcclxuICAgICAgICAgKiBAbWVtYmVyIHtJbWFnZUJpdG1hcH1cclxuICAgICAgICAgKiBAZGVmYXVsdCBudWxsXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5iaXRtYXAgPSBudWxsO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFByb21pc2Ugd2hlbiBsb2FkaW5nXHJcbiAgICAgICAgICogQG1lbWJlciB7UHJvbWlzZTx2b2lkPn1cclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqIEBkZWZhdWx0IG51bGxcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLl9sb2FkID0gbnVsbDtcclxuICAgICAgICBpZiAob3B0aW9ucy5hdXRvTG9hZCAhPT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgdGhpcy5sb2FkKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiByZXR1cm5zIGEgcHJvbWlzZSB3aGVuIGltYWdlIHdpbGwgYmUgbG9hZGVkIGFuZCBwcm9jZXNzZWRcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtjcmVhdGVCaXRtYXA9dHJ1ZV0gd2hldGhlciBwcm9jZXNzIGltYWdlIGludG8gYml0bWFwXHJcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cclxuICAgICAqL1xyXG4gICAgbG9hZChjcmVhdGVCaXRtYXAgPSB1bmRlZmluZWQpIHtcclxuICAgICAgICBpZiAoY3JlYXRlQml0bWFwICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5jcmVhdGVCaXRtYXAgPSBjcmVhdGVCaXRtYXA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLl9sb2FkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9sb2FkO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9sb2FkID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcclxuICAgICAgICAgICAgTG9nZ2VyXzEudHJhY2UoXCJzb3VyY2UgXCIgKyB0aGlzLnNvdXJjZSk7XHJcbiAgICAgICAgICAgIHRoaXMudXJsID0gdGhpcy5zb3VyY2Uuc3JjO1xyXG4gICAgICAgICAgICB2YXIgcmVmID0gdGhpcztcclxuICAgICAgICAgICAgdmFyIHNvdXJjZSA9IHJlZi5zb3VyY2U7XHJcbiAgICAgICAgICAgIHZhciBjb21wbGV0ZWQgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBzb3VyY2Uub25sb2FkID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIHNvdXJjZS5vbmVycm9yID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVzaXplKHNvdXJjZS53aWR0aCwgc291cmNlLmhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2FkID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNyZWF0ZUJpdG1hcCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUodGhpcy5wcm9jZXNzKCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh0aGlzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgaWYgKHNvdXJjZS5jb21wbGV0ZSAmJiBzb3VyY2Uuc3JjKSB7XHJcbiAgICAgICAgICAgICAgICBjb21wbGV0ZWQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHNvdXJjZS5vbmxvYWQgPSBjb21wbGV0ZWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbG9hZDtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgKiBDYWxsZWQgd2hlbiB3ZSBuZWVkIHRvIGNvbnZlcnQgaW1hZ2UgaW50byBCaXRtYXBJbWFnZS5cclxuICAgICogQ2FuIGJlIGNhbGxlZCBtdWx0aXBsZSB0aW1lcywgcmVhbCBwcm9taXNlIGlzIGNhY2hlZCBpbnNpZGUuXHJcbiAgICAqXHJcbiAgICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fSBjYWNoZWQgcHJvbWlzZSB0byBmaWxsIHRoYXQgYml0bWFwXHJcbiAgICAqL1xyXG4gICAgcHJvY2VzcygpIHtcclxuICAgICAgICBpZiAodGhpcy5fcHJvY2VzcyAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcHJvY2VzcztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuYml0bWFwICE9PSBudWxsIHx8ICF3aW5kb3cuY3JlYXRlSW1hZ2VCaXRtYXApIHtcclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fcHJvY2VzcyA9IHdpbmRvdy5jcmVhdGVJbWFnZUJpdG1hcCh0aGlzLnNvdXJjZSwgMCwgMCwgdGhpcy5zb3VyY2Uud2lkdGgsIHRoaXMuc291cmNlLmhlaWdodClcclxuICAgICAgICAgICAgLnRoZW4oKGJpdG1hcCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChcIlwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmJpdG1hcCA9IGJpdG1hcDtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGUoMCk7XHJcbiAgICAgICAgICAgIHRoaXMuX3Byb2Nlc3MgPSBudWxsO1xyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9wcm9jZXNzO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAqIFVwbG9hZCB0aGUgaW1hZ2UgcmVzb3VyY2UgdG8gR1BVLlxyXG4gICAgKlxyXG4gICAgKiBAcGFyYW0ge1BJWEkuUmVuZGVyZXJ9IHJlbmRlcmVyIC0gUmVuZGVyZXIgdG8gdXBsb2FkIHRvXHJcbiAgICAqIEBwYXJhbSB7UElYSS5CYXNlVGV4dHVyZX0gYmFzZVRleHR1cmUgLSBCYXNlVGV4dHVyZSBmb3IgdGhpcyByZXNvdXJjZVxyXG4gICAgKiBAcGFyYW0ge1BJWEkuR0xUZXh0dXJlfSBnbFRleHR1cmUgLSBHTFRleHR1cmUgdG8gdXNlXHJcbiAgICAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlzIHN1Y2Nlc3NcclxuICAgICovXHJcbiAgICB1cGxvYWQocmVuZGVyZXIsIGJhc2VUZXh0dXJlLCBnbFRleHR1cmUpIHtcclxuICAgICAgICBiYXNlVGV4dHVyZS5wcmVtdWx0aXBseUFscGhhID0gdGhpcy5wcmVtdWx0aXBseUFscGhhO1xyXG4gICAgICAgIC8vIHJldmVhbCh0aGlzLmJpdG1hcClcclxuICAgICAgICBpZiAoIXRoaXMuY3JlYXRlQml0bWFwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzdXBlci51cGxvYWQocmVuZGVyZXIsIGJhc2VUZXh0dXJlLCBnbFRleHR1cmUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXRoaXMuYml0bWFwKSB7XHJcbiAgICAgICAgICAgIC8vIHllYWgsIGlnbm9yZSB0aGUgb3V0cHV0XHJcbiAgICAgICAgICAgIHRoaXMucHJvY2VzcygpO1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuYml0bWFwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgTG9nZ2VyXzEudHJhY2UoXCJ1cGxvYWRpbmdcIik7XHJcbiAgICAgICAgc3VwZXIudXBsb2FkKHJlbmRlcmVyLCBiYXNlVGV4dHVyZSwgZ2xUZXh0dXJlLCB0aGlzLmJpdG1hcCk7XHJcbiAgICAgICAgaWYgKCF0aGlzLnByZXNlcnZlQml0bWFwKSB7XHJcbiAgICAgICAgICAgIC8vIGNoZWNrcyBpZiB0aGVyZSBhcmUgb3RoZXIgcmVuZGVyZXJzIHRoYXQgcG9zc2libHkgbmVlZCB0aGlzIGJpdG1hcFxyXG4gICAgICAgICAgICB2YXIgZmxhZyA9IHRydWU7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBiYXNlVGV4dHVyZS5fZ2xUZXh0dXJlcykge1xyXG4gICAgICAgICAgICAgICAgdmFyIG90aGVyVGV4ID0gYmFzZVRleHR1cmUuX2dsVGV4dHVyZXNba2V5XTtcclxuICAgICAgICAgICAgICAgIGlmIChvdGhlclRleCAhPT0gZ2xUZXh0dXJlICYmIG90aGVyVGV4LmRpcnR5SWQgIT09IGJhc2VUZXh0dXJlLmRpcnR5SWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBmbGFnID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGZsYWcpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmJpdG1hcC5jbG9zZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYml0bWFwLmNsb3NlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBMb2dnZXJfMS50cmFjZShcImJpdG1hcCBmbGFnZ2VkXCIpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5iaXRtYXAgPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAqIERlc3Ryb3lzIHRoaXMgdGV4dHVyZVxyXG4gICAgKiBAb3ZlcnJpZGVcclxuICAgICovXHJcbiAgICBkaXNwb3NlKCkge1xyXG4gICAgICAgIHN1cGVyLmRpc3Bvc2UoKTtcclxuICAgICAgICBpZiAodGhpcy5iaXRtYXApIHtcclxuICAgICAgICAgICAgdGhpcy5iaXRtYXAuY2xvc2UoKTtcclxuICAgICAgICAgICAgdGhpcy5iaXRtYXAgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9wcm9jZXNzID0gbnVsbDtcclxuICAgICAgICB0aGlzLl9sb2FkID0gbnVsbDtcclxuICAgIH1cclxuICAgIDtcclxufVxyXG5leHBvcnRzLkltYWdlUmVzb3VyY2UgPSBJbWFnZVJlc291cmNlO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBQb2ludF8xID0gcmVxdWlyZShcIi4vUG9pbnRcIik7XHJcbmNsYXNzIEludGVyYWN0aW9uRGF0YSB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLmdsb2JhbCA9IG5ldyBQb2ludF8xLlBvaW50KCk7XHJcbiAgICAgICAgdGhpcy50YXJnZXQgPSBudWxsO1xyXG4gICAgICAgIHRoaXMub3JpZ2luYWxFdmVudCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5pZGVudGlmaWVyID0gbnVsbDtcclxuICAgICAgICB0aGlzLmlzUHJpbWFyeSA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuYnV0dG9uID0gMDtcclxuICAgICAgICB0aGlzLmJ1dHRvbnMgPSAwO1xyXG4gICAgICAgIHRoaXMud2lkdGggPSAwO1xyXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gMDtcclxuICAgICAgICB0aGlzLnRpbHRYID0gMDtcclxuICAgICAgICB0aGlzLnRpbHRZID0gMDtcclxuICAgICAgICB0aGlzLnBvaW50ZXJUeXBlID0gbnVsbDtcclxuICAgICAgICB0aGlzLnByZXNzdXJlID0gMDtcclxuICAgICAgICB0aGlzLnJvdGF0aW9uQW5nbGUgPSAwO1xyXG4gICAgICAgIHRoaXMudHdpc3QgPSAwO1xyXG4gICAgICAgIHRoaXMudGFuZ2VudGlhbFByZXNzdXJlID0gMDtcclxuICAgICAgICB0aGlzLndoaWNoID0gMDtcclxuICAgIH1cclxuICAgIGdldExvY2FsUG9zaXRpb24oZGlzcGxheU9iamVjdCwgcG9pbnQgPSBudWxsLCBnbG9iYWxQb3MgPSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIGRpc3BsYXlPYmplY3Qud29ybGRUcmFuc2Zvcm0uYXBwbHlJbnZlcnNlKGdsb2JhbFBvcyB8fCB0aGlzLmdsb2JhbCwgcG9pbnQpO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgY29weUV2ZW50KGV2ZW50KSB7XHJcbiAgICAgICAgaWYgKGV2ZW50LmlzUHJpbWFyeSkge1xyXG4gICAgICAgICAgICB0aGlzLmlzUHJpbWFyeSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuYnV0dG9uID0gZXZlbnQuYnV0dG9uO1xyXG4gICAgICAgIHRoaXMuYnV0dG9ucyA9IE51bWJlci5pc0ludGVnZXIoZXZlbnQuYnV0dG9ucykgPyBldmVudC5idXR0b25zIDogZXZlbnQud2hpY2g7XHJcbiAgICAgICAgdGhpcy53aWR0aCA9IGV2ZW50LndpZHRoO1xyXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gZXZlbnQuaGVpZ2h0O1xyXG4gICAgICAgIHRoaXMudGlsdFggPSBldmVudC50aWx0WDtcclxuICAgICAgICB0aGlzLnRpbHRZID0gZXZlbnQudGlsdFk7XHJcbiAgICAgICAgdGhpcy5wb2ludGVyVHlwZSA9IGV2ZW50LnBvaW50ZXJUeXBlO1xyXG4gICAgICAgIHRoaXMucHJlc3N1cmUgPSBldmVudC5wcmVzc3VyZTtcclxuICAgICAgICB0aGlzLnJvdGF0aW9uQW5nbGUgPSBldmVudC5yb3RhdGlvbkFuZ2xlO1xyXG4gICAgICAgIHRoaXMudHdpc3QgPSBldmVudC50d2lzdCB8fCAwO1xyXG4gICAgICAgIHRoaXMudGFuZ2VudGlhbFByZXNzdXJlID0gZXZlbnQudGFuZ2VudGlhbFByZXNzdXJlIHx8IDA7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICBnZXQgcG9pbnRlcklkKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmlkZW50aWZpZXI7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICByZXNldCgpIHtcclxuICAgICAgICB0aGlzLmlzUHJpbWFyeSA9IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgO1xyXG59XHJcbmV4cG9ydHMuSW50ZXJhY3Rpb25EYXRhID0gSW50ZXJhY3Rpb25EYXRhO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBFdmVudF8xID0gcmVxdWlyZShcIi4vRXZlbnRcIik7XHJcbmNsYXNzIEludGVyYWN0aW9uRXZlbnQgZXh0ZW5kcyBFdmVudF8xLkV2ZW50IHtcclxuICAgIGNvbnN0cnVjdG9yKHR5cGUsIGJ1YmJsZSA9IHRydWUsIGNhbmNlbGFibGUgPSB0cnVlKSB7XHJcbiAgICAgICAgc3VwZXIodHlwZSwgYnViYmxlLCBjYW5jZWxhYmxlKTtcclxuICAgICAgICB0aGlzLnRhcmdldCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5zdG9wcGVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fY3VycmVudFRhcmdldCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5fdHlwZSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5kYXRhID0gbnVsbDtcclxuICAgIH1cclxuICAgIHJlc2V0KCkge1xyXG4gICAgICAgIHRoaXMuc3RvcHBlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX2N1cnJlbnRUYXJnZXQgPSBudWxsO1xyXG4gICAgICAgIHRoaXMudGFyZ2V0ID0gbnVsbDtcclxuICAgIH1cclxuICAgIDtcclxuICAgIHN0b3BQcm9wYWdhdGlvbigpIHtcclxuICAgICAgICB0aGlzLnN0b3BwZWQgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgO1xyXG59XHJcbmV4cG9ydHMuSW50ZXJhY3Rpb25FdmVudCA9IEludGVyYWN0aW9uRXZlbnQ7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IEludGVyYWN0aW9uRGF0YV8xID0gcmVxdWlyZShcIi4vSW50ZXJhY3Rpb25EYXRhXCIpO1xyXG5jb25zdCBJbnRlcmFjdGlvbkV2ZW50XzEgPSByZXF1aXJlKFwiLi9JbnRlcmFjdGlvbkV2ZW50XCIpO1xyXG5jb25zdCBNb3VzZUV2ZW50XzEgPSByZXF1aXJlKFwiLi9Nb3VzZUV2ZW50XCIpO1xyXG5jb25zdCBJbnRlcmFjdGlvblRyYWNraW5nRGF0YV8xID0gcmVxdWlyZShcIi4vSW50ZXJhY3Rpb25UcmFja2luZ0RhdGFcIik7XHJcbmNvbnN0IFRpY2tlcl8xID0gcmVxdWlyZShcIi4vVGlja2VyXCIpO1xyXG5jb25zdCBQb2ludF8xID0gcmVxdWlyZShcIi4vUG9pbnRcIik7XHJcbmNvbnN0IENvbnRhaW5lcl8xID0gcmVxdWlyZShcIi4vQ29udGFpbmVyXCIpO1xyXG5jb25zdCBSZWN0YW5nbGVfMSA9IHJlcXVpcmUoXCIuL1JlY3RhbmdsZVwiKTtcclxuY29uc3QgRXZlbnREaXNwYXRjaGVyXzEgPSByZXF1aXJlKFwiLi9FdmVudERpc3BhdGNoZXJcIik7XHJcbmNsYXNzIEludGVyYWN0aW9uTWFuYWdlciBleHRlbmRzIEV2ZW50RGlzcGF0Y2hlcl8xLkV2ZW50RGlzcGF0Y2hlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihyZW5kZXJlcikge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy51cGRhdGUgPSAoZGVsdGFUaW1lKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuX2RlbHRhVGltZSArPSBkZWx0YVRpbWU7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9kZWx0YVRpbWUgPCB0aGlzLmludGVyYWN0aW9uRnJlcXVlbmN5KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fZGVsdGFUaW1lID0gMDtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmludGVyYWN0aW9uRE9NRWxlbWVudCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmRpZE1vdmUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGlkTW92ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuY3Vyc29yID0gbnVsbDtcclxuICAgICAgICAgICAgZm9yIChsZXQgayBpbiB0aGlzLmFjdGl2ZUludGVyYWN0aW9uRGF0YSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYWN0aXZlSW50ZXJhY3Rpb25EYXRhLmhhc093blByb3BlcnR5KGspKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGludGVyYWN0aW9uRGF0YSA9IHRoaXMuYWN0aXZlSW50ZXJhY3Rpb25EYXRhW2tdO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnRlcmFjdGlvbkRhdGEub3JpZ2luYWxFdmVudCAmJiBpbnRlcmFjdGlvbkRhdGEucG9pbnRlclR5cGUgIT09ICd0b3VjaCcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGludGVyYWN0aW9uRXZlbnQgPSB0aGlzLmNvbmZpZ3VyZUludGVyYWN0aW9uRXZlbnRGb3JET01FdmVudCh0aGlzLmV2ZW50RGF0YSwgaW50ZXJhY3Rpb25EYXRhLm9yaWdpbmFsRXZlbnQsIGludGVyYWN0aW9uRGF0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHJvY2Vzc0ludGVyYWN0aXZlKGludGVyYWN0aW9uRXZlbnQsIHRoaXMucmVuZGVyZXIuX2xhc3RPYmplY3RSZW5kZXJlZCwgdGhpcy5wcm9jZXNzUG9pbnRlck92ZXJPdXQsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnNldEN1cnNvck1vZGUodGhpcy5jdXJzb3IpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5vblBvaW50ZXJVcCA9IChldmVudCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5zdXBwb3J0c1RvdWNoRXZlbnRzICYmIGV2ZW50LnBvaW50ZXJUeXBlID09PSAndG91Y2gnKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5vblBvaW50ZXJDb21wbGV0ZShldmVudCwgZmFsc2UsIHRoaXMucHJvY2Vzc1BvaW50ZXJVcCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLm9uUG9pbnRlckNhbmNlbCA9IChldmVudCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5zdXBwb3J0c1RvdWNoRXZlbnRzICYmIGV2ZW50LnBvaW50ZXJUeXBlID09PSAndG91Y2gnKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5vblBvaW50ZXJDb21wbGV0ZShldmVudCwgdHJ1ZSwgdGhpcy5wcm9jZXNzUG9pbnRlckNhbmNlbCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLm9uUG9pbnRlck92ZXIgPSAob3JpZ2luYWxFdmVudCkgPT4ge1xyXG4gICAgICAgICAgICBsZXQgZXZlbnRzID0gdGhpcy5ub3JtYWxpemVUb1BvaW50ZXJEYXRhKG9yaWdpbmFsRXZlbnQpO1xyXG4gICAgICAgICAgICBsZXQgZXZlbnQgPSBldmVudHNbMF07XHJcbiAgICAgICAgICAgIGxldCBpbnRlcmFjdGlvbkRhdGEgPSB0aGlzLmdldEludGVyYWN0aW9uRGF0YUZvclBvaW50ZXJJZChldmVudCk7XHJcbiAgICAgICAgICAgIGxldCBpbnRlcmFjdGlvbkV2ZW50ID0gdGhpcy5jb25maWd1cmVJbnRlcmFjdGlvbkV2ZW50Rm9yRE9NRXZlbnQodGhpcy5ldmVudERhdGEsIGV2ZW50LCBpbnRlcmFjdGlvbkRhdGEpO1xyXG4gICAgICAgICAgICBpbnRlcmFjdGlvbkV2ZW50LmRhdGEub3JpZ2luYWxFdmVudCA9IGV2ZW50O1xyXG4gICAgICAgICAgICBpZiAoZXZlbnQucG9pbnRlclR5cGUgPT09ICdtb3VzZScpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubW91c2VPdmVyUmVuZGVyZXIgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxldCBwb2ludGVyID0gbmV3IE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50KE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50LlBPSU5URVJfT1ZFUik7XHJcbiAgICAgICAgICAgIHBvaW50ZXIuZGF0YSA9IGludGVyYWN0aW9uRGF0YTtcclxuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KHBvaW50ZXIpO1xyXG4gICAgICAgICAgICBpZiAoZXZlbnQucG9pbnRlclR5cGUgPT09ICdtb3VzZScgfHwgZXZlbnQucG9pbnRlclR5cGUgPT09ICdwZW4nKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgcG9pbnRlciA9IG5ldyBNb3VzZUV2ZW50XzEuTW91c2VFdmVudChNb3VzZUV2ZW50XzEuTW91c2VFdmVudC5NT1VTRV9PVkVSKTtcclxuICAgICAgICAgICAgICAgIHBvaW50ZXIuZGF0YSA9IGludGVyYWN0aW9uRGF0YTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChwb2ludGVyKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChwb2ludGVyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5vblBvaW50ZXJPdXQgPSAob3JpZ2luYWxFdmVudCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5zdXBwb3J0c1RvdWNoRXZlbnRzICYmIG9yaWdpbmFsRXZlbnQucG9pbnRlclR5cGUgPT09ICd0b3VjaCcpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXQgZXZlbnRzID0gdGhpcy5ub3JtYWxpemVUb1BvaW50ZXJEYXRhKG9yaWdpbmFsRXZlbnQpO1xyXG4gICAgICAgICAgICBsZXQgZXZlbnQgPSBldmVudHNbMF07XHJcbiAgICAgICAgICAgIGlmIChldmVudC5wb2ludGVyVHlwZSA9PT0gJ21vdXNlJykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tb3VzZU92ZXJSZW5kZXJlciA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRDdXJzb3JNb2RlKG51bGwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxldCBpbnRlcmFjdGlvbkRhdGEgPSB0aGlzLmdldEludGVyYWN0aW9uRGF0YUZvclBvaW50ZXJJZChldmVudCk7XHJcbiAgICAgICAgICAgIGxldCBpbnRlcmFjdGlvbkV2ZW50ID0gdGhpcy5jb25maWd1cmVJbnRlcmFjdGlvbkV2ZW50Rm9yRE9NRXZlbnQodGhpcy5ldmVudERhdGEsIGV2ZW50LCBpbnRlcmFjdGlvbkRhdGEpO1xyXG4gICAgICAgICAgICBpbnRlcmFjdGlvbkV2ZW50LmRhdGEub3JpZ2luYWxFdmVudCA9IGV2ZW50O1xyXG4gICAgICAgICAgICB0aGlzLnByb2Nlc3NJbnRlcmFjdGl2ZShpbnRlcmFjdGlvbkV2ZW50LCB0aGlzLnJlbmRlcmVyLl9sYXN0T2JqZWN0UmVuZGVyZWQsIHRoaXMucHJvY2Vzc1BvaW50ZXJPdmVyT3V0LCBmYWxzZSk7XHJcbiAgICAgICAgICAgIGxldCBwb2ludGVyID0gbmV3IE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50KE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50LlBPSU5URVJfT1VUKTtcclxuICAgICAgICAgICAgcG9pbnRlci5kYXRhID0gaW50ZXJhY3Rpb25EYXRhO1xyXG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQocG9pbnRlcik7XHJcbiAgICAgICAgICAgIGlmIChldmVudC5wb2ludGVyVHlwZSA9PT0gJ21vdXNlJyB8fCBldmVudC5wb2ludGVyVHlwZSA9PT0gJ3BlbicpIHtcclxuICAgICAgICAgICAgICAgIGxldCBwb2ludGVyID0gbmV3IE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50KE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50Lk1PVVNFX09VVCk7XHJcbiAgICAgICAgICAgICAgICBwb2ludGVyLmRhdGEgPSBpbnRlcmFjdGlvbkRhdGE7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQocG9pbnRlcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlbGVhc2VJbnRlcmFjdGlvbkRhdGFGb3JQb2ludGVySWQoaW50ZXJhY3Rpb25EYXRhLmlkZW50aWZpZXIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLm9uUG9pbnRlckRvd24gPSAob3JpZ2luYWxFdmVudCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5zdXBwb3J0c1RvdWNoRXZlbnRzICYmIG9yaWdpbmFsRXZlbnQucG9pbnRlclR5cGUgPT09ICd0b3VjaCcpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXQgZXZlbnRzID0gdGhpcy5ub3JtYWxpemVUb1BvaW50ZXJEYXRhKG9yaWdpbmFsRXZlbnQpO1xyXG4gICAgICAgICAgICBsZXQgZXZlbnQgPSBldmVudHNbMF07XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmF1dG9QcmV2ZW50RGVmYXVsdCAmJiBldmVudC5pc05vcm1hbGl6ZWQpIHtcclxuICAgICAgICAgICAgICAgIGxldCBjYW5jZWxhYmxlID0gb3JpZ2luYWxFdmVudC5jYW5jZWxhYmxlIHx8ICEoJ2NhbmNlbGFibGUnIGluIG9yaWdpbmFsRXZlbnQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNhbmNlbGFibGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbEV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IGV2ZW50TGVuID0gZXZlbnRzLmxlbmd0aDtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBldmVudExlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgZXZlbnQgPSBldmVudHNbaV07XHJcbiAgICAgICAgICAgICAgICBsZXQgaW50ZXJhY3Rpb25EYXRhID0gdGhpcy5nZXRJbnRlcmFjdGlvbkRhdGFGb3JQb2ludGVySWQoZXZlbnQpO1xyXG4gICAgICAgICAgICAgICAgbGV0IGludGVyYWN0aW9uRXZlbnQgPSB0aGlzLmNvbmZpZ3VyZUludGVyYWN0aW9uRXZlbnRGb3JET01FdmVudCh0aGlzLmV2ZW50RGF0YSwgZXZlbnQsIGludGVyYWN0aW9uRGF0YSk7XHJcbiAgICAgICAgICAgICAgICBpbnRlcmFjdGlvbkV2ZW50LmRhdGEub3JpZ2luYWxFdmVudCA9IG9yaWdpbmFsRXZlbnQ7XHJcbiAgICAgICAgICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy5wcm9jZXNzSW50ZXJhY3RpdmUoaW50ZXJhY3Rpb25FdmVudCwgdGhpcy5yZW5kZXJlci5fbGFzdE9iamVjdFJlbmRlcmVkLCB0aGlzLnByb2Nlc3NQb2ludGVyRG93biwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICBsZXQgcG9pbnRlciA9IG5ldyBNb3VzZUV2ZW50XzEuTW91c2VFdmVudChNb3VzZUV2ZW50XzEuTW91c2VFdmVudC5QT0lOVEVSX0RPV04pO1xyXG4gICAgICAgICAgICAgICAgcG9pbnRlci5kYXRhID0gaW50ZXJhY3Rpb25EYXRhO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KHBvaW50ZXIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50LnBvaW50ZXJUeXBlID09PSAndG91Y2gnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBvaW50ZXIgPSBuZXcgTW91c2VFdmVudF8xLk1vdXNlRXZlbnQoTW91c2VFdmVudF8xLk1vdXNlRXZlbnQuVE9VQ0hfU1RBUlQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHBvaW50ZXIuZGF0YSA9IGludGVyYWN0aW9uRGF0YTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQocG9pbnRlcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChldmVudC5wb2ludGVyVHlwZSA9PT0gJ21vdXNlJyB8fCBldmVudC5wb2ludGVyVHlwZSA9PT0gJ3BlbicpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgaXNSaWdodEJ1dHRvbiA9IGV2ZW50LmJ1dHRvbiA9PT0gMjtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgcG9pbnRlciA9IG5ldyBNb3VzZUV2ZW50XzEuTW91c2VFdmVudChpc1JpZ2h0QnV0dG9uID8gTW91c2VFdmVudF8xLk1vdXNlRXZlbnQuUklHSFRfTU9VU0VfRE9XTiA6IE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50Lk1PVVNFX0RPV04pO1xyXG4gICAgICAgICAgICAgICAgICAgIHBvaW50ZXIuZGF0YSA9IGludGVyYWN0aW9uRGF0YTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQocG9pbnRlcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMub25Qb2ludGVyTW92ZSA9IChvcmlnaW5hbEV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnN1cHBvcnRzVG91Y2hFdmVudHMgJiYgb3JpZ2luYWxFdmVudC5wb2ludGVyVHlwZSA9PT0gJ3RvdWNoJykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxldCBldmVudHMgPSB0aGlzLm5vcm1hbGl6ZVRvUG9pbnRlckRhdGEob3JpZ2luYWxFdmVudCk7XHJcbiAgICAgICAgICAgIGlmIChldmVudHNbMF0ucG9pbnRlclR5cGUgPT09ICdtb3VzZScgfHwgZXZlbnRzWzBdLnBvaW50ZXJUeXBlID09PSAncGVuJykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kaWRNb3ZlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY3Vyc29yID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXQgZXZlbnRMZW4gPSBldmVudHMubGVuZ3RoO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV2ZW50TGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGxldCBldmVudCA9IGV2ZW50c1tpXTtcclxuICAgICAgICAgICAgICAgIGxldCBpbnRlcmFjdGlvbkRhdGEgPSB0aGlzLmdldEludGVyYWN0aW9uRGF0YUZvclBvaW50ZXJJZChldmVudCk7XHJcbiAgICAgICAgICAgICAgICBsZXQgaW50ZXJhY3Rpb25FdmVudCA9IHRoaXMuY29uZmlndXJlSW50ZXJhY3Rpb25FdmVudEZvckRPTUV2ZW50KHRoaXMuZXZlbnREYXRhLCBldmVudCwgaW50ZXJhY3Rpb25EYXRhKTtcclxuICAgICAgICAgICAgICAgIGludGVyYWN0aW9uRXZlbnQuZGF0YS5vcmlnaW5hbEV2ZW50ID0gb3JpZ2luYWxFdmVudDtcclxuICAgICAgICAgICAgICAgIGxldCBpbnRlcmFjdGl2ZSA9IGV2ZW50LnBvaW50ZXJUeXBlID09PSAndG91Y2gnID8gdGhpcy5tb3ZlV2hlbkluc2lkZSA6IHRydWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3NJbnRlcmFjdGl2ZShpbnRlcmFjdGlvbkV2ZW50LCB0aGlzLnJlbmRlcmVyLl9sYXN0T2JqZWN0UmVuZGVyZWQsIHRoaXMucHJvY2Vzc1BvaW50ZXJNb3ZlLCBpbnRlcmFjdGl2ZSk7XHJcbiAgICAgICAgICAgICAgICBsZXQgcG9pbnRlciA9IG5ldyBNb3VzZUV2ZW50XzEuTW91c2VFdmVudChNb3VzZUV2ZW50XzEuTW91c2VFdmVudC5QT0lOVEVSX01PVkUpO1xyXG4gICAgICAgICAgICAgICAgcG9pbnRlci5kYXRhID0gaW50ZXJhY3Rpb25EYXRhO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KHBvaW50ZXIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50LnBvaW50ZXJUeXBlID09PSAndG91Y2gnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBvaW50ZXIgPSBuZXcgTW91c2VFdmVudF8xLk1vdXNlRXZlbnQoTW91c2VFdmVudF8xLk1vdXNlRXZlbnQuVE9VQ0hfTU9WRSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRlci5kYXRhID0gaW50ZXJhY3Rpb25EYXRhO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChwb2ludGVyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChldmVudC5wb2ludGVyVHlwZSA9PT0gJ21vdXNlJyB8fCBldmVudC5wb2ludGVyVHlwZSA9PT0gJ3BlbicpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgcG9pbnRlciA9IG5ldyBNb3VzZUV2ZW50XzEuTW91c2VFdmVudChNb3VzZUV2ZW50XzEuTW91c2VFdmVudC5NT1VTRV9NT1ZFKTtcclxuICAgICAgICAgICAgICAgICAgICBwb2ludGVyLmRhdGEgPSBpbnRlcmFjdGlvbkRhdGE7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KHBvaW50ZXIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChldmVudHNbMF0ucG9pbnRlclR5cGUgPT09ICdtb3VzZScpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2V0Q3Vyc29yTW9kZSh0aGlzLmN1cnNvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMucHJvY2Vzc1BvaW50ZXJEb3duID0gKGludGVyYWN0aW9uRXZlbnQsIGRpc3BsYXlPYmplY3QsIGhpdCkgPT4ge1xyXG4gICAgICAgICAgICBsZXQgZGF0YSA9IGludGVyYWN0aW9uRXZlbnQuZGF0YTtcclxuICAgICAgICAgICAgbGV0IGlkID0gaW50ZXJhY3Rpb25FdmVudC5kYXRhLmlkZW50aWZpZXI7XHJcbiAgICAgICAgICAgIGlmIChoaXQpIHtcclxuICAgICAgICAgICAgICAgIGlmICghZGlzcGxheU9iamVjdC50cmFja2VkUG9pbnRlcnNbaWRdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheU9iamVjdC50cmFja2VkUG9pbnRlcnNbaWRdID0gbmV3IEludGVyYWN0aW9uVHJhY2tpbmdEYXRhXzEuSW50ZXJhY3Rpb25UcmFja2luZ0RhdGEoaWQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbGV0IHBvaW50ZXIgPSBuZXcgTW91c2VFdmVudF8xLk1vdXNlRXZlbnQoTW91c2VFdmVudF8xLk1vdXNlRXZlbnQuUE9JTlRFUl9ET1dOKTtcclxuICAgICAgICAgICAgICAgIHBvaW50ZXIuZGF0YSA9IGRhdGE7XHJcbiAgICAgICAgICAgICAgICBkaXNwbGF5T2JqZWN0LmRpc3BhdGNoRXZlbnQocG9pbnRlcik7XHJcbiAgICAgICAgICAgICAgICBpZiAoZGF0YS5wb2ludGVyVHlwZSA9PT0gJ3RvdWNoJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBwb2ludGVyID0gbmV3IE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50KE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50LlRPVUNIX1NUQVJUKTtcclxuICAgICAgICAgICAgICAgICAgICBwb2ludGVyLmRhdGEgPSBkYXRhO1xyXG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXlPYmplY3QuZGlzcGF0Y2hFdmVudChwb2ludGVyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGRhdGEucG9pbnRlclR5cGUgPT09ICdtb3VzZScgfHwgZGF0YS5wb2ludGVyVHlwZSA9PT0gJ3BlbicpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgaXNSaWdodEJ1dHRvbiA9IGRhdGEuYnV0dG9uID09PSAyO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1JpZ2h0QnV0dG9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXlPYmplY3QudHJhY2tlZFBvaW50ZXJzW2lkXS5yaWdodERvd24gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheU9iamVjdC50cmFja2VkUG9pbnRlcnNbaWRdLmxlZnREb3duID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBvaW50ZXIgPSBuZXcgTW91c2VFdmVudF8xLk1vdXNlRXZlbnQoaXNSaWdodEJ1dHRvbiA/IE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50LlJJR0hUX01PVVNFX0RPV04gOiBNb3VzZUV2ZW50XzEuTW91c2VFdmVudC5NT1VTRV9ET1dOKTtcclxuICAgICAgICAgICAgICAgICAgICBwb2ludGVyLmRhdGEgPSBkYXRhO1xyXG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXlPYmplY3QuZGlzcGF0Y2hFdmVudChwb2ludGVyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5wcm9jZXNzUG9pbnRlclVwID0gKGludGVyYWN0aW9uRXZlbnQsIGRpc3BsYXlPYmplY3QsIGhpdCkgPT4ge1xyXG4gICAgICAgICAgICBsZXQgZGF0YSA9IGludGVyYWN0aW9uRXZlbnQuZGF0YTtcclxuICAgICAgICAgICAgbGV0IGlkID0gaW50ZXJhY3Rpb25FdmVudC5kYXRhLmlkZW50aWZpZXI7XHJcbiAgICAgICAgICAgIGxldCB0cmFja2luZ0RhdGEgPSBkaXNwbGF5T2JqZWN0LnRyYWNrZWRQb2ludGVyc1tpZF07XHJcbiAgICAgICAgICAgIGxldCBpc1RvdWNoID0gZGF0YS5wb2ludGVyVHlwZSA9PT0gJ3RvdWNoJztcclxuICAgICAgICAgICAgbGV0IGlzTW91c2UgPSAoZGF0YS5wb2ludGVyVHlwZSA9PT0gJ21vdXNlJyB8fCBkYXRhLnBvaW50ZXJUeXBlID09PSAncGVuJyk7XHJcbiAgICAgICAgICAgIGxldCBpc01vdXNlVGFwID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGlmIChpc01vdXNlKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgaXNSaWdodEJ1dHRvbiA9IGRhdGEuYnV0dG9uID09PSAyO1xyXG4gICAgICAgICAgICAgICAgbGV0IGZsYWdzID0gSW50ZXJhY3Rpb25UcmFja2luZ0RhdGFfMS5JbnRlcmFjdGlvblRyYWNraW5nRGF0YS5GTEFHUztcclxuICAgICAgICAgICAgICAgIGxldCB0ZXN0ID0gaXNSaWdodEJ1dHRvbiA/IGZsYWdzLlJJR0hUX0RPV04gOiBmbGFncy5MRUZUX0RPV047XHJcbiAgICAgICAgICAgICAgICBsZXQgaXNEb3duID0gdHJhY2tpbmdEYXRhICE9PSB1bmRlZmluZWQgJiYgKHRyYWNraW5nRGF0YS5mbGFncyAmIHRlc3QpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGhpdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBwb2ludGVyID0gbmV3IE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50KGlzUmlnaHRCdXR0b24gPyBNb3VzZUV2ZW50XzEuTW91c2VFdmVudC5SSUdIVF9NT1VTRV9VUCA6IE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50Lk1PVVNFX1VQKTtcclxuICAgICAgICAgICAgICAgICAgICBwb2ludGVyLmRhdGEgPSBkYXRhO1xyXG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXlPYmplY3QuZGlzcGF0Y2hFdmVudChwb2ludGVyKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNEb3duKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBwb2ludGVyID0gbmV3IE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50KGlzUmlnaHRCdXR0b24gPyBNb3VzZUV2ZW50XzEuTW91c2VFdmVudC5SSUdIVF9DTElDSyA6IE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50LkNMSUNLKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRlci5kYXRhID0gZGF0YTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheU9iamVjdC5kaXNwYXRjaEV2ZW50KHBvaW50ZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpc01vdXNlVGFwID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc0Rvd24pIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgcG9pbnRlciA9IG5ldyBNb3VzZUV2ZW50XzEuTW91c2VFdmVudChpc1JpZ2h0QnV0dG9uID8gTW91c2VFdmVudF8xLk1vdXNlRXZlbnQuUklHSFRfTU9VU0VfVVBfT1VUU0lERSA6IE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50Lk1PVVNFX1VQX09VVFNJREUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHBvaW50ZXIuZGF0YSA9IGRhdGE7XHJcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheU9iamVjdC5kaXNwYXRjaEV2ZW50KHBvaW50ZXIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHRyYWNraW5nRGF0YSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1JpZ2h0QnV0dG9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYWNraW5nRGF0YS5yaWdodERvd24gPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYWNraW5nRGF0YS5sZWZ0RG93biA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoaGl0KSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgcG9pbnRlciA9IG5ldyBNb3VzZUV2ZW50XzEuTW91c2VFdmVudChNb3VzZUV2ZW50XzEuTW91c2VFdmVudC5QT0lOVEVSX1VQKTtcclxuICAgICAgICAgICAgICAgIHBvaW50ZXIuZGF0YSA9IGRhdGE7XHJcbiAgICAgICAgICAgICAgICBkaXNwbGF5T2JqZWN0LmRpc3BhdGNoRXZlbnQocG9pbnRlcik7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNUb3VjaCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBwb2ludGVyID0gbmV3IE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50KE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50LlRPVUNIX0VORCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRlci5kYXRhID0gZGF0YTtcclxuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5T2JqZWN0LmRpc3BhdGNoRXZlbnQocG9pbnRlcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAodHJhY2tpbmdEYXRhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc01vdXNlIHx8IGlzTW91c2VUYXApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHBvaW50ZXIgPSBuZXcgTW91c2VFdmVudF8xLk1vdXNlRXZlbnQoTW91c2VFdmVudF8xLk1vdXNlRXZlbnQuUE9JTlRFUl9UQVApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludGVyLmRhdGEgPSBkYXRhO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5T2JqZWN0LmRpc3BhdGNoRXZlbnQocG9pbnRlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1RvdWNoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBwb2ludGVyID0gbmV3IE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50KE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50LlRPVUNIX1RBUCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50ZXIuZGF0YSA9IGRhdGE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXlPYmplY3QuZGlzcGF0Y2hFdmVudChwb2ludGVyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhY2tpbmdEYXRhLm92ZXIgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodHJhY2tpbmdEYXRhKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgcG9pbnRlciA9IG5ldyBNb3VzZUV2ZW50XzEuTW91c2VFdmVudChNb3VzZUV2ZW50XzEuTW91c2VFdmVudC5QT0lOVEVSX1VQX09VVFNJREUpO1xyXG4gICAgICAgICAgICAgICAgcG9pbnRlci5kYXRhID0gZGF0YTtcclxuICAgICAgICAgICAgICAgIGRpc3BsYXlPYmplY3QuZGlzcGF0Y2hFdmVudChwb2ludGVyKTtcclxuICAgICAgICAgICAgICAgIGlmIChpc1RvdWNoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBvaW50ZXIgPSBuZXcgTW91c2VFdmVudF8xLk1vdXNlRXZlbnQoTW91c2VFdmVudF8xLk1vdXNlRXZlbnQuVE9VQ0hfRU5EX09VVFNJREUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHBvaW50ZXIuZGF0YSA9IGRhdGE7XHJcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheU9iamVjdC5kaXNwYXRjaEV2ZW50KHBvaW50ZXIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0cmFja2luZ0RhdGEgJiYgdHJhY2tpbmdEYXRhLm5vbmUpIHtcclxuICAgICAgICAgICAgICAgIGRlbGV0ZSBkaXNwbGF5T2JqZWN0LnRyYWNrZWRQb2ludGVyc1tpZF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMucHJvY2Vzc1BvaW50ZXJNb3ZlID0gKGludGVyYWN0aW9uRXZlbnQsIGRpc3BsYXlPYmplY3QsIGhpdCkgPT4ge1xyXG4gICAgICAgICAgICBsZXQgZGF0YSA9IGludGVyYWN0aW9uRXZlbnQuZGF0YTtcclxuICAgICAgICAgICAgbGV0IGlzVG91Y2ggPSBkYXRhLnBvaW50ZXJUeXBlID09PSAndG91Y2gnO1xyXG4gICAgICAgICAgICBsZXQgaXNNb3VzZSA9IChkYXRhLnBvaW50ZXJUeXBlID09PSAnbW91c2UnIHx8IGRhdGEucG9pbnRlclR5cGUgPT09ICdwZW4nKTtcclxuICAgICAgICAgICAgaWYgKGlzTW91c2UpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucHJvY2Vzc1BvaW50ZXJPdmVyT3V0KGludGVyYWN0aW9uRXZlbnQsIGRpc3BsYXlPYmplY3QsIGhpdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCF0aGlzLm1vdmVXaGVuSW5zaWRlIHx8IGhpdCkge1xyXG4gICAgICAgICAgICAgICAgbGV0IHBvaW50ZXIgPSBuZXcgTW91c2VFdmVudF8xLk1vdXNlRXZlbnQoTW91c2VFdmVudF8xLk1vdXNlRXZlbnQuUE9JTlRFUl9NT1ZFKTtcclxuICAgICAgICAgICAgICAgIHBvaW50ZXIuZGF0YSA9IGRhdGE7XHJcbiAgICAgICAgICAgICAgICBkaXNwbGF5T2JqZWN0LmRpc3BhdGNoRXZlbnQocG9pbnRlcik7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNUb3VjaCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBwb2ludGVyID0gbmV3IE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50KE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50LlRPVUNIX01PVkUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHBvaW50ZXIuZGF0YSA9IGRhdGE7XHJcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheU9iamVjdC5kaXNwYXRjaEV2ZW50KHBvaW50ZXIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGlzTW91c2UpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgcG9pbnRlciA9IG5ldyBNb3VzZUV2ZW50XzEuTW91c2VFdmVudChNb3VzZUV2ZW50XzEuTW91c2VFdmVudC5NT1VTRV9NT1ZFKTtcclxuICAgICAgICAgICAgICAgICAgICBwb2ludGVyLmRhdGEgPSBkYXRhO1xyXG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXlPYmplY3QuZGlzcGF0Y2hFdmVudChwb2ludGVyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5wcm9jZXNzUG9pbnRlck92ZXJPdXQgPSAoaW50ZXJhY3Rpb25FdmVudCwgZGlzcGxheU9iamVjdCwgaGl0KSA9PiB7XHJcbiAgICAgICAgICAgIGxldCBkYXRhID0gaW50ZXJhY3Rpb25FdmVudC5kYXRhO1xyXG4gICAgICAgICAgICBsZXQgaWQgPSBpbnRlcmFjdGlvbkV2ZW50LmRhdGEuaWRlbnRpZmllcjtcclxuICAgICAgICAgICAgbGV0IGlzTW91c2UgPSAoZGF0YS5wb2ludGVyVHlwZSA9PT0gJ21vdXNlJyB8fCBkYXRhLnBvaW50ZXJUeXBlID09PSAncGVuJyk7XHJcbiAgICAgICAgICAgIGxldCB0cmFja2luZ0RhdGEgPSBkaXNwbGF5T2JqZWN0LnRyYWNrZWRQb2ludGVyc1tpZF07XHJcbiAgICAgICAgICAgIGlmIChoaXQgJiYgIXRyYWNraW5nRGF0YSkge1xyXG4gICAgICAgICAgICAgICAgdHJhY2tpbmdEYXRhID0gZGlzcGxheU9iamVjdC50cmFja2VkUG9pbnRlcnNbaWRdID0gbmV3IEludGVyYWN0aW9uVHJhY2tpbmdEYXRhXzEuSW50ZXJhY3Rpb25UcmFja2luZ0RhdGEoaWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0cmFja2luZ0RhdGEgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChoaXQgJiYgdGhpcy5tb3VzZU92ZXJSZW5kZXJlcikge1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0cmFja2luZ0RhdGEub3Zlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHRyYWNraW5nRGF0YS5vdmVyID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgcG9pbnRlciA9IG5ldyBNb3VzZUV2ZW50XzEuTW91c2VFdmVudChNb3VzZUV2ZW50XzEuTW91c2VFdmVudC5QT0lOVEVSX09WRVIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHBvaW50ZXIuZGF0YSA9IGRhdGE7XHJcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheU9iamVjdC5kaXNwYXRjaEV2ZW50KHBvaW50ZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc01vdXNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBwb2ludGVyID0gbmV3IE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50KE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50Lk1PVVNFX09WRVIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludGVyLmRhdGEgPSBkYXRhO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5T2JqZWN0LmRpc3BhdGNoRXZlbnQocG9pbnRlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGlzTW91c2UgJiYgdGhpcy5jdXJzb3IgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnNvciA9IGRpc3BsYXlPYmplY3QuY3Vyc29yO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHRyYWNraW5nRGF0YS5vdmVyKSB7XHJcbiAgICAgICAgICAgICAgICB0cmFja2luZ0RhdGEub3ZlciA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgbGV0IHBvaW50ZXIgPSBuZXcgTW91c2VFdmVudF8xLk1vdXNlRXZlbnQoTW91c2VFdmVudF8xLk1vdXNlRXZlbnQuUE9JTlRFUl9PVVQpO1xyXG4gICAgICAgICAgICAgICAgcG9pbnRlci5kYXRhID0gZGF0YTtcclxuICAgICAgICAgICAgICAgIGRpc3BsYXlPYmplY3QuZGlzcGF0Y2hFdmVudChwb2ludGVyKTtcclxuICAgICAgICAgICAgICAgIGlmIChpc01vdXNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBvaW50ZXIgPSBuZXcgTW91c2VFdmVudF8xLk1vdXNlRXZlbnQoTW91c2VFdmVudF8xLk1vdXNlRXZlbnQuTU9VU0VfT1VUKTtcclxuICAgICAgICAgICAgICAgICAgICBwb2ludGVyLmRhdGEgPSBkYXRhO1xyXG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXlPYmplY3QuZGlzcGF0Y2hFdmVudChwb2ludGVyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh0cmFja2luZ0RhdGEubm9uZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBkaXNwbGF5T2JqZWN0LnRyYWNrZWRQb2ludGVyc1tpZF07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuaGl0VGVzdEV2ZW50ID0gbmV3IEludGVyYWN0aW9uRXZlbnRfMS5JbnRlcmFjdGlvbkV2ZW50KG51bGwsIG51bGwsIG51bGwpO1xyXG4gICAgICAgIHRoaXMuaGl0VGVzdEV2ZW50LnRhcmdldCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xyXG4gICAgICAgIHRoaXMuYXV0b1ByZXZlbnREZWZhdWx0ID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmludGVyYWN0aW9uRnJlcXVlbmN5ID0gMTA7XHJcbiAgICAgICAgdGhpcy5tb3VzZSA9IG5ldyBJbnRlcmFjdGlvbkRhdGFfMS5JbnRlcmFjdGlvbkRhdGEoKTtcclxuICAgICAgICB0aGlzLm1vdXNlLmlkZW50aWZpZXIgPSBJbnRlcmFjdGlvbk1hbmFnZXIuTU9VU0VfUE9JTlRFUl9JRDtcclxuICAgICAgICB0aGlzLm1vdXNlLmdsb2JhbC5zZXQoLTk5OTk5OSk7XHJcbiAgICAgICAgdGhpcy5hY3RpdmVJbnRlcmFjdGlvbkRhdGEgPSB7fTtcclxuICAgICAgICB0aGlzLmFjdGl2ZUludGVyYWN0aW9uRGF0YVtJbnRlcmFjdGlvbk1hbmFnZXIuTU9VU0VfUE9JTlRFUl9JRF0gPSB0aGlzLm1vdXNlO1xyXG4gICAgICAgIHRoaXMuaW50ZXJhY3Rpb25EYXRhUG9vbCA9IFtdO1xyXG4gICAgICAgIHRoaXMuZXZlbnREYXRhID0gbmV3IEludGVyYWN0aW9uRXZlbnRfMS5JbnRlcmFjdGlvbkV2ZW50KFwiaW50ZXJhY3Rpb25cIik7XHJcbiAgICAgICAgdGhpcy5pbnRlcmFjdGlvbkRPTUVsZW1lbnQgPSBudWxsO1xyXG4gICAgICAgIHRoaXMubW92ZVdoZW5JbnNpZGUgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmV2ZW50c0FkZGVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5tb3VzZU92ZXJSZW5kZXJlciA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuc3VwcG9ydHNUb3VjaEV2ZW50cyA9ICdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdztcclxuICAgICAgICB0aGlzLnN1cHBvcnRzUG9pbnRlckV2ZW50cyA9ICEhd2luZG93WydQb2ludGVyRXZlbnQnXTtcclxuICAgICAgICB0aGlzLmN1cnNvclN0eWxlcyA9IHtcclxuICAgICAgICAgICAgZGVmYXVsdDogJ2luaGVyaXQnLFxyXG4gICAgICAgICAgICBwb2ludGVyOiAncG9pbnRlcidcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuY3VycmVudEN1cnNvck1vZGUgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuY3Vyc29yID0gbnVsbDtcclxuICAgICAgICB0aGlzLl90ZW1wUG9pbnQgPSBuZXcgUG9pbnRfMS5Qb2ludCgpO1xyXG4gICAgICAgIHRoaXMucmVzb2x1dGlvbiA9IDE7XHJcbiAgICAgICAgdGhpcy5zZXRUYXJnZXRFbGVtZW50KHRoaXMucmVuZGVyZXIudmlldywgdGhpcy5yZW5kZXJlci5yZXNvbHV0aW9uKTtcclxuICAgIH1cclxuICAgIHNldFRhcmdldEVsZW1lbnQoZWxlbWVudCwgcmVzb2x1dGlvbiA9IDEpIHtcclxuICAgICAgICB0aGlzLnJlbW92ZUV2ZW50cygpO1xyXG4gICAgICAgIHRoaXMuaW50ZXJhY3Rpb25ET01FbGVtZW50ID0gZWxlbWVudDtcclxuICAgICAgICB0aGlzLnJlc29sdXRpb24gPSByZXNvbHV0aW9uO1xyXG4gICAgICAgIHRoaXMuYWRkRXZlbnRzKCk7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICByZW1vdmVFdmVudHMoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmludGVyYWN0aW9uRE9NRWxlbWVudCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFRpY2tlcl8xLlRpY2tlci5zeXN0ZW0ucmVtb3ZlKHRoaXMudXBkYXRlKTtcclxuICAgICAgICBpZiAod2luZG93Lm5hdmlnYXRvci5tc1BvaW50ZXJFbmFibGVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaW50ZXJhY3Rpb25ET01FbGVtZW50LnN0eWxlWyctbXMtY29udGVudC16b29taW5nJ10gPSAnJztcclxuICAgICAgICAgICAgdGhpcy5pbnRlcmFjdGlvbkRPTUVsZW1lbnQuc3R5bGVbJy1tcy10b3VjaC1hY3Rpb24nXSA9ICcnO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLnN1cHBvcnRzUG9pbnRlckV2ZW50cykge1xyXG4gICAgICAgICAgICB0aGlzLmludGVyYWN0aW9uRE9NRWxlbWVudC5zdHlsZVsndG91Y2gtYWN0aW9uJ10gPSAnJztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuc3VwcG9ydHNQb2ludGVyRXZlbnRzKSB7XHJcbiAgICAgICAgICAgIHdpbmRvdy5kb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdwb2ludGVybW92ZScsIHRoaXMub25Qb2ludGVyTW92ZSk7XHJcbiAgICAgICAgICAgIHRoaXMuaW50ZXJhY3Rpb25ET01FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJkb3duJywgdGhpcy5vblBvaW50ZXJEb3duKTtcclxuICAgICAgICAgICAgdGhpcy5pbnRlcmFjdGlvbkRPTUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigncG9pbnRlcmxlYXZlJywgdGhpcy5vblBvaW50ZXJPdXQpO1xyXG4gICAgICAgICAgICB0aGlzLmludGVyYWN0aW9uRE9NRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdwb2ludGVyb3ZlcicsIHRoaXMub25Qb2ludGVyT3Zlcik7XHJcbiAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdwb2ludGVyY2FuY2VsJywgdGhpcy5vblBvaW50ZXJDYW5jZWwpO1xyXG4gICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncG9pbnRlcnVwJywgdGhpcy5vblBvaW50ZXJVcCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB3aW5kb3cuZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5vblBvaW50ZXJNb3ZlKTtcclxuICAgICAgICAgICAgdGhpcy5pbnRlcmFjdGlvbkRPTUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5vblBvaW50ZXJEb3duKTtcclxuICAgICAgICAgICAgdGhpcy5pbnRlcmFjdGlvbkRPTUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2VvdXQnLCB0aGlzLm9uUG9pbnRlck91dCk7XHJcbiAgICAgICAgICAgIHRoaXMuaW50ZXJhY3Rpb25ET01FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlb3ZlcicsIHRoaXMub25Qb2ludGVyT3Zlcik7XHJcbiAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5vblBvaW50ZXJVcCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLnN1cHBvcnRzVG91Y2hFdmVudHMpIHtcclxuICAgICAgICAgICAgdGhpcy5pbnRlcmFjdGlvbkRPTUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRoaXMub25Qb2ludGVyRG93bik7XHJcbiAgICAgICAgICAgIHRoaXMuaW50ZXJhY3Rpb25ET01FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoY2FuY2VsJywgdGhpcy5vblBvaW50ZXJDYW5jZWwpO1xyXG4gICAgICAgICAgICB0aGlzLmludGVyYWN0aW9uRE9NRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMub25Qb2ludGVyVXApO1xyXG4gICAgICAgICAgICB0aGlzLmludGVyYWN0aW9uRE9NRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLm9uUG9pbnRlck1vdmUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmludGVyYWN0aW9uRE9NRWxlbWVudCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5ldmVudHNBZGRlZCA9IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgbWFwUG9zaXRpb25Ub1BvaW50KHBvaW50LCB4LCB5KSB7XHJcbiAgICAgICAgbGV0IHJlY3Q7XHJcbiAgICAgICAgaWYgKCF0aGlzLmludGVyYWN0aW9uRE9NRWxlbWVudC5wYXJlbnRFbGVtZW50KSB7XHJcbiAgICAgICAgICAgIHJlY3QgPSBuZXcgUmVjdGFuZ2xlXzEuUmVjdGFuZ2xlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZWN0ID0gdGhpcy5pbnRlcmFjdGlvbkRPTUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCByZXNvbHV0aW9uTXVsdGlwbGllciA9IDEuMCAvIHRoaXMucmVzb2x1dGlvbjtcclxuICAgICAgICBwb2ludC54ID0gKCh4IC0gcmVjdC5sZWZ0KSAqICh0aGlzLmludGVyYWN0aW9uRE9NRWxlbWVudC53aWR0aCAvIHJlY3Qud2lkdGgpKSAqIHJlc29sdXRpb25NdWx0aXBsaWVyO1xyXG4gICAgICAgIHBvaW50LnkgPSAoKHkgLSByZWN0LnRvcCkgKiAodGhpcy5pbnRlcmFjdGlvbkRPTUVsZW1lbnQuaGVpZ2h0IC8gcmVjdC5oZWlnaHQpKSAqIHJlc29sdXRpb25NdWx0aXBsaWVyO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgY29uZmlndXJlSW50ZXJhY3Rpb25FdmVudEZvckRPTUV2ZW50KGludGVyYWN0aW9uRXZlbnQsIHBvaW50ZXJFdmVudCwgaW50ZXJhY3Rpb25EYXRhKSB7XHJcbiAgICAgICAgaW50ZXJhY3Rpb25FdmVudC5kYXRhID0gaW50ZXJhY3Rpb25EYXRhO1xyXG4gICAgICAgIHRoaXMubWFwUG9zaXRpb25Ub1BvaW50KGludGVyYWN0aW9uRGF0YS5nbG9iYWwsIHBvaW50ZXJFdmVudC5jbGllbnRYLCBwb2ludGVyRXZlbnQuY2xpZW50WSk7XHJcbiAgICAgICAgaWYgKHBvaW50ZXJFdmVudC5wb2ludGVyVHlwZSA9PT0gJ3RvdWNoJykge1xyXG4gICAgICAgICAgICBwb2ludGVyRXZlbnQuZ2xvYmFsWCA9IGludGVyYWN0aW9uRGF0YS5nbG9iYWwueDtcclxuICAgICAgICAgICAgcG9pbnRlckV2ZW50Lmdsb2JhbFkgPSBpbnRlcmFjdGlvbkRhdGEuZ2xvYmFsLnk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGludGVyYWN0aW9uRGF0YS5vcmlnaW5hbEV2ZW50ID0gcG9pbnRlckV2ZW50O1xyXG4gICAgICAgIGludGVyYWN0aW9uRXZlbnQucmVzZXQoKTtcclxuICAgICAgICByZXR1cm4gaW50ZXJhY3Rpb25FdmVudDtcclxuICAgIH1cclxuICAgIDtcclxuICAgIGFkZEV2ZW50cygpIHtcclxuICAgICAgICBpZiAoIXRoaXMuaW50ZXJhY3Rpb25ET01FbGVtZW50KSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgVGlja2VyXzEuVGlja2VyLnN5c3RlbS5hZGQodGhpcy51cGRhdGUsIHRoaXMsIFRpY2tlcl8xLlRpY2tlci5VUERBVEVfUFJJT1JJVFkuSU5URVJBQ1RJT04pO1xyXG4gICAgICAgIGlmICh3aW5kb3cubmF2aWdhdG9yLm1zUG9pbnRlckVuYWJsZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5pbnRlcmFjdGlvbkRPTUVsZW1lbnQuc3R5bGVbJy1tcy1jb250ZW50LXpvb21pbmcnXSA9ICdub25lJztcclxuICAgICAgICAgICAgdGhpcy5pbnRlcmFjdGlvbkRPTUVsZW1lbnQuc3R5bGVbJy1tcy10b3VjaC1hY3Rpb24nXSA9ICdub25lJztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5zdXBwb3J0c1BvaW50ZXJFdmVudHMpIHtcclxuICAgICAgICAgICAgdGhpcy5pbnRlcmFjdGlvbkRPTUVsZW1lbnQuc3R5bGVbJ3RvdWNoLWFjdGlvbiddID0gJ25vbmUnO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5zdXBwb3J0c1BvaW50ZXJFdmVudHMpIHtcclxuICAgICAgICAgICAgd2luZG93LmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJtb3ZlJywgdGhpcy5vblBvaW50ZXJNb3ZlKTtcclxuICAgICAgICAgICAgdGhpcy5pbnRlcmFjdGlvbkRPTUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcmRvd24nLCB0aGlzLm9uUG9pbnRlckRvd24pO1xyXG4gICAgICAgICAgICB0aGlzLmludGVyYWN0aW9uRE9NRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVybGVhdmUnLCB0aGlzLm9uUG9pbnRlck91dCk7XHJcbiAgICAgICAgICAgIHRoaXMuaW50ZXJhY3Rpb25ET01FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJvdmVyJywgdGhpcy5vblBvaW50ZXJPdmVyKTtcclxuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJjYW5jZWwnLCB0aGlzLm9uUG9pbnRlckNhbmNlbCk7XHJcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVydXAnLCB0aGlzLm9uUG9pbnRlclVwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHdpbmRvdy5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLm9uUG9pbnRlck1vdmUpO1xyXG4gICAgICAgICAgICB0aGlzLmludGVyYWN0aW9uRE9NRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLm9uUG9pbnRlckRvd24pO1xyXG4gICAgICAgICAgICB0aGlzLmludGVyYWN0aW9uRE9NRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW91dCcsIHRoaXMub25Qb2ludGVyT3V0KTtcclxuICAgICAgICAgICAgdGhpcy5pbnRlcmFjdGlvbkRPTUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VvdmVyJywgdGhpcy5vblBvaW50ZXJPdmVyKTtcclxuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLm9uUG9pbnRlclVwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuc3VwcG9ydHNUb3VjaEV2ZW50cykge1xyXG4gICAgICAgICAgICB0aGlzLmludGVyYWN0aW9uRE9NRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdGhpcy5vblBvaW50ZXJEb3duKTtcclxuICAgICAgICAgICAgdGhpcy5pbnRlcmFjdGlvbkRPTUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hjYW5jZWwnLCB0aGlzLm9uUG9pbnRlckNhbmNlbCk7XHJcbiAgICAgICAgICAgIHRoaXMuaW50ZXJhY3Rpb25ET01FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy5vblBvaW50ZXJVcCk7XHJcbiAgICAgICAgICAgIHRoaXMuaW50ZXJhY3Rpb25ET01FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXMub25Qb2ludGVyTW92ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZXZlbnRzQWRkZWQgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgcHJvY2Vzc0ludGVyYWN0aXZlKGludGVyYWN0aW9uRXZlbnQsIGRpc3BsYXlPYmplY3QsIGZ1bmMsIGhpdFRlc3QsIGludGVyYWN0aXZlID0gdHJ1ZSkge1xyXG4gICAgICAgIGlmICghZGlzcGxheU9iamVjdCB8fCAhZGlzcGxheU9iamVjdC52aXNpYmxlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHBvaW50ID0gaW50ZXJhY3Rpb25FdmVudC5kYXRhLmdsb2JhbDtcclxuICAgICAgICBpbnRlcmFjdGl2ZSA9IGRpc3BsYXlPYmplY3QuaW50ZXJhY3RpdmUgfHwgaW50ZXJhY3RpdmU7XHJcbiAgICAgICAgbGV0IGhpdCA9IGZhbHNlO1xyXG4gICAgICAgIGxldCBpbnRlcmFjdGl2ZVBhcmVudCA9IGludGVyYWN0aXZlO1xyXG4gICAgICAgIGxldCBoaXRUZXN0Q2hpbGRyZW4gPSB0cnVlO1xyXG4gICAgICAgIGlmIChkaXNwbGF5T2JqZWN0LmhpdEFyZWEpIHtcclxuICAgICAgICAgICAgaWYgKGhpdFRlc3QpIHtcclxuICAgICAgICAgICAgICAgIGRpc3BsYXlPYmplY3Qud29ybGRUcmFuc2Zvcm0uYXBwbHlJbnZlcnNlKHBvaW50LCB0aGlzLl90ZW1wUG9pbnQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFkaXNwbGF5T2JqZWN0LmhpdEFyZWEuY29udGFpbnModGhpcy5fdGVtcFBvaW50LngsIHRoaXMuX3RlbXBQb2ludC55KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGhpdFRlc3QgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICBoaXRUZXN0Q2hpbGRyZW4gPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGhpdCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaW50ZXJhY3RpdmVQYXJlbnQgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoZGlzcGxheU9iamVjdC5fbWFzaykge1xyXG4gICAgICAgICAgICBpZiAoaGl0VGVzdCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCEoZGlzcGxheU9iamVjdC5fbWFzay5jb250YWluc1BvaW50ICYmIGRpc3BsYXlPYmplY3QuX21hc2suY29udGFpbnNQb2ludChwb2ludCkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGl0VGVzdCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIGhpdFRlc3RDaGlsZHJlbiA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChkaXNwbGF5T2JqZWN0IGluc3RhbmNlb2YgQ29udGFpbmVyXzEuQ29udGFpbmVyKSB7XHJcbiAgICAgICAgICAgIGlmIChoaXRUZXN0Q2hpbGRyZW4gJiYgZGlzcGxheU9iamVjdC5pbnRlcmFjdGl2ZUNoaWxkcmVuICYmIGRpc3BsYXlPYmplY3QuY2hpbGRyZW4pIHtcclxuICAgICAgICAgICAgICAgIGxldCBjaGlsZHJlbiA9IGRpc3BsYXlPYmplY3QuY2hpbGRyZW47XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gY2hpbGRyZW4ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgY2hpbGQgPSBjaGlsZHJlbltpXTtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgY2hpbGRIaXQgPSB0aGlzLnByb2Nlc3NJbnRlcmFjdGl2ZShpbnRlcmFjdGlvbkV2ZW50LCBjaGlsZCwgZnVuYywgaGl0VGVzdCwgaW50ZXJhY3RpdmVQYXJlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZEhpdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNoaWxkLnBhcmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJhY3RpdmVQYXJlbnQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkSGl0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW50ZXJhY3Rpb25FdmVudC50YXJnZXQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoaXRUZXN0ID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoaXQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpbnRlcmFjdGl2ZSkge1xyXG4gICAgICAgICAgICBpZiAoaGl0VGVzdCAmJiAhaW50ZXJhY3Rpb25FdmVudC50YXJnZXQpIHtcclxuICAgICAgICAgICAgICAgIGlmICghZGlzcGxheU9iamVjdC5oaXRBcmVhICYmIGRpc3BsYXlPYmplY3QuY29udGFpbnNQb2ludCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChkaXNwbGF5T2JqZWN0LmNvbnRhaW5zUG9pbnQocG9pbnQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhpdCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChkaXNwbGF5T2JqZWN0LmludGVyYWN0aXZlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaGl0ICYmICFpbnRlcmFjdGlvbkV2ZW50LnRhcmdldCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGludGVyYWN0aW9uRXZlbnQudGFyZ2V0ID0gZGlzcGxheU9iamVjdDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChmdW5jKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZnVuYyhpbnRlcmFjdGlvbkV2ZW50LCBkaXNwbGF5T2JqZWN0LCAhIWhpdCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGhpdDtcclxuICAgIH1cclxuICAgIDtcclxuICAgIHNldEN1cnNvck1vZGUobW9kZSA9IFwiZGVmYXVsdFwiKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudEN1cnNvck1vZGUgPT09IG1vZGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmN1cnJlbnRDdXJzb3JNb2RlID0gbW9kZTtcclxuICAgICAgICBsZXQgc3R5bGUgPSB0aGlzLmN1cnNvclN0eWxlc1ttb2RlXTtcclxuICAgICAgICBpZiAoc3R5bGUpIHtcclxuICAgICAgICAgICAgc3dpdGNoICh0eXBlb2Ygc3R5bGUpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnRlcmFjdGlvbkRPTUVsZW1lbnQuc3R5bGUuY3Vyc29yID0gc3R5bGU7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdmdW5jdGlvbic6XHJcbiAgICAgICAgICAgICAgICAgICAgc3R5bGUobW9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdvYmplY3QnOlxyXG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odGhpcy5pbnRlcmFjdGlvbkRPTUVsZW1lbnQuc3R5bGUsIHN0eWxlKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgbW9kZSA9PT0gJ3N0cmluZycgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmN1cnNvclN0eWxlcywgbW9kZSkpIHtcclxuICAgICAgICAgICAgdGhpcy5pbnRlcmFjdGlvbkRPTUVsZW1lbnQuc3R5bGUuY3Vyc29yID0gbW9kZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICBoaXRUZXN0KGdsb2JhbFBvaW50LCByb290KSB7XHJcbiAgICAgICAgdGhpcy5oaXRUZXN0RXZlbnQudGFyZ2V0ID0gbnVsbDtcclxuICAgICAgICB0aGlzLmhpdFRlc3RFdmVudC5kYXRhLmdsb2JhbCA9IGdsb2JhbFBvaW50O1xyXG4gICAgICAgIGxldCBjdXJyZW50ZGlzcGxheTtcclxuICAgICAgICBpZiAocm9vdCkge1xyXG4gICAgICAgICAgICBjdXJyZW50ZGlzcGxheSA9IHJvb3Q7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjdXJyZW50ZGlzcGxheSA9IHRoaXMucmVuZGVyZXIuX2xhc3RPYmplY3RSZW5kZXJlZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5wcm9jZXNzSW50ZXJhY3RpdmUodGhpcy5oaXRUZXN0RXZlbnQsIGN1cnJlbnRkaXNwbGF5LCBudWxsLCB0cnVlKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5oaXRUZXN0RXZlbnQudGFyZ2V0O1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgbm9ybWFsaXplVG9Qb2ludGVyRGF0YShldmVudCkge1xyXG4gICAgICAgIGxldCBub3JtYWxpemVkRXZlbnRzID0gW107XHJcbiAgICAgICAgaWYgKHRoaXMuc3VwcG9ydHNUb3VjaEV2ZW50cyAmJiBldmVudCBpbnN0YW5jZW9mIFRvdWNoRXZlbnQpIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxpID0gZXZlbnQuY2hhbmdlZFRvdWNoZXMubGVuZ3RoOyBpIDwgbGk7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgbGV0IHRvdWNoID0gZXZlbnQuY2hhbmdlZFRvdWNoZXNbaV07XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRvdWNoLmJ1dHRvbiA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgICAgICAgICB0b3VjaC5idXR0b24gPSBldmVudC50b3VjaGVzLmxlbmd0aCA/IDEgOiAwO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0b3VjaC5idXR0b25zID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRvdWNoLmJ1dHRvbnMgPSBldmVudC50b3VjaGVzLmxlbmd0aCA/IDEgOiAwO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0b3VjaC5pc1ByaW1hcnkgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdG91Y2guaXNQcmltYXJ5ID0gZXZlbnQudG91Y2hlcy5sZW5ndGggPT09IDEgJiYgZXZlbnQudHlwZSA9PT0gJ3RvdWNoc3RhcnQnO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0b3VjaC53aWR0aCA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgICAgICAgICB0b3VjaC53aWR0aCA9IHRvdWNoLnJhZGl1c1ggfHwgMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdG91Y2guaGVpZ2h0ID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRvdWNoLmhlaWdodCA9IHRvdWNoLnJhZGl1c1kgfHwgMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdG91Y2gudGlsdFggPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdG91Y2gudGlsdFggPSAwO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0b3VjaC50aWx0WSA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgICAgICAgICB0b3VjaC50aWx0WSA9IDA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRvdWNoLnBvaW50ZXJUeXBlID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRvdWNoLnBvaW50ZXJUeXBlID0gJ3RvdWNoJztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdG91Y2gucG9pbnRlcklkID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRvdWNoLnBvaW50ZXJJZCA9IHRvdWNoLmlkZW50aWZpZXIgfHwgMDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdG91Y2gucHJlc3N1cmUgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdG91Y2gucHJlc3N1cmUgPSB0b3VjaC5mb3JjZSB8fCAwLjU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRvdWNoLnR3aXN0ID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRvdWNoLnR3aXN0ID0gMDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdG91Y2gudGFuZ2VudGlhbFByZXNzdXJlID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRvdWNoLnRhbmdlbnRpYWxQcmVzc3VyZSA9IDA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRvdWNoLmxheWVyWCA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgICAgICAgICB0b3VjaC5sYXllclggPSB0b3VjaC5vZmZzZXRYID0gdG91Y2guY2xpZW50WDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdG91Y2gubGF5ZXJZID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRvdWNoLmxheWVyWSA9IHRvdWNoLm9mZnNldFkgPSB0b3VjaC5jbGllbnRZO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdG91Y2guaXNOb3JtYWxpemVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWRFdmVudHMucHVzaCh0b3VjaCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoZXZlbnQgaW5zdGFuY2VvZiBNb3VzZUV2ZW50XzEuTW91c2VFdmVudCAmJiAoIXRoaXMuc3VwcG9ydHNQb2ludGVyRXZlbnRzIHx8ICEoZXZlbnQgaW5zdGFuY2VvZiB3aW5kb3dbJ1BvaW50ZXJFdmVudCddKSkpIHtcclxuICAgICAgICAgICAgbGV0IG9yaWdpbmV2ZW50ID0gZXZlbnQ7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3JpZ2luZXZlbnQuaXNQcmltYXJ5ID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAgICAgb3JpZ2luZXZlbnQuaXNQcmltYXJ5ID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIG9yaWdpbmV2ZW50LndpZHRoID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAgICAgb3JpZ2luZXZlbnQud2lkdGggPSAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3JpZ2luZXZlbnQuaGVpZ2h0ID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAgICAgb3JpZ2luZXZlbnQuaGVpZ2h0ID0gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIG9yaWdpbmV2ZW50LnRpbHRYID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAgICAgb3JpZ2luZXZlbnQudGlsdFggPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3JpZ2luZXZlbnQudGlsdFkgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgICAgICBvcmlnaW5ldmVudC50aWx0WSA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcmlnaW5ldmVudC5wb2ludGVyVHlwZSA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgICAgIG9yaWdpbmV2ZW50LnBvaW50ZXJUeXBlID0gJ21vdXNlJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIG9yaWdpbmV2ZW50LnBvaW50ZXJJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgICAgIG9yaWdpbmV2ZW50LnBvaW50ZXJJZCA9IEludGVyYWN0aW9uTWFuYWdlci5NT1VTRV9QT0lOVEVSX0lEO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3JpZ2luZXZlbnQucHJlc3N1cmUgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgICAgICBvcmlnaW5ldmVudC5wcmVzc3VyZSA9IDAuNTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIG9yaWdpbmV2ZW50LnR3aXN0ID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAgICAgb3JpZ2luZXZlbnQudHdpc3QgPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3JpZ2luZXZlbnQudGFuZ2VudGlhbFByZXNzdXJlID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAgICAgb3JpZ2luZXZlbnQudGFuZ2VudGlhbFByZXNzdXJlID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvcmlnaW5ldmVudC5pc05vcm1hbGl6ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICBub3JtYWxpemVkRXZlbnRzLnB1c2goZXZlbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbm9ybWFsaXplZEV2ZW50cy5wdXNoKGV2ZW50KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZWRFdmVudHM7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICBnZXRJbnRlcmFjdGlvbkRhdGFGb3JQb2ludGVySWQoZXZlbnQpIHtcclxuICAgICAgICBsZXQgcG9pbnRlcklkID0gZXZlbnQucG9pbnRlcklkO1xyXG4gICAgICAgIGxldCBpbnRlcmFjdGlvbkRhdGE7XHJcbiAgICAgICAgaWYgKHBvaW50ZXJJZCA9PT0gSW50ZXJhY3Rpb25NYW5hZ2VyLk1PVVNFX1BPSU5URVJfSUQgfHwgZXZlbnQucG9pbnRlclR5cGUgPT09ICdtb3VzZScpIHtcclxuICAgICAgICAgICAgaW50ZXJhY3Rpb25EYXRhID0gdGhpcy5tb3VzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5hY3RpdmVJbnRlcmFjdGlvbkRhdGFbcG9pbnRlcklkXSkge1xyXG4gICAgICAgICAgICBpbnRlcmFjdGlvbkRhdGEgPSB0aGlzLmFjdGl2ZUludGVyYWN0aW9uRGF0YVtwb2ludGVySWRdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaW50ZXJhY3Rpb25EYXRhID0gdGhpcy5pbnRlcmFjdGlvbkRhdGFQb29sLnBvcCgpIHx8IG5ldyBJbnRlcmFjdGlvbkRhdGFfMS5JbnRlcmFjdGlvbkRhdGEoKTtcclxuICAgICAgICAgICAgaW50ZXJhY3Rpb25EYXRhLmlkZW50aWZpZXIgPSBwb2ludGVySWQ7XHJcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlSW50ZXJhY3Rpb25EYXRhW3BvaW50ZXJJZF0gPSBpbnRlcmFjdGlvbkRhdGE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGludGVyYWN0aW9uRGF0YS5jb3B5RXZlbnQoZXZlbnQpO1xyXG4gICAgICAgIHJldHVybiBpbnRlcmFjdGlvbkRhdGE7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICBvblBvaW50ZXJDb21wbGV0ZShvcmlnaW5hbEV2ZW50LCBjYW5jZWxsZWQsIGZ1bmMpIHtcclxuICAgICAgICBsZXQgZXZlbnRzID0gdGhpcy5ub3JtYWxpemVUb1BvaW50ZXJEYXRhKG9yaWdpbmFsRXZlbnQpO1xyXG4gICAgICAgIGxldCBldmVudExlbiA9IGV2ZW50cy5sZW5ndGg7XHJcbiAgICAgICAgbGV0IGV2ZW50QXBwZW5kID0gb3JpZ2luYWxFdmVudC50YXJnZXQgIT09IHRoaXMuaW50ZXJhY3Rpb25ET01FbGVtZW50ID8gJ291dHNpZGUnIDogJyc7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBldmVudExlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIGxldCBldmVudCA9IGV2ZW50c1tpXTtcclxuICAgICAgICAgICAgbGV0IGludGVyYWN0aW9uRGF0YSA9IHRoaXMuZ2V0SW50ZXJhY3Rpb25EYXRhRm9yUG9pbnRlcklkKGV2ZW50KTtcclxuICAgICAgICAgICAgbGV0IGludGVyYWN0aW9uRXZlbnQgPSB0aGlzLmNvbmZpZ3VyZUludGVyYWN0aW9uRXZlbnRGb3JET01FdmVudCh0aGlzLmV2ZW50RGF0YSwgZXZlbnQsIGludGVyYWN0aW9uRGF0YSk7XHJcbiAgICAgICAgICAgIGludGVyYWN0aW9uRXZlbnQuZGF0YS5vcmlnaW5hbEV2ZW50ID0gb3JpZ2luYWxFdmVudDtcclxuICAgICAgICAgICAgdGhpcy5wcm9jZXNzSW50ZXJhY3RpdmUoaW50ZXJhY3Rpb25FdmVudCwgdGhpcy5yZW5kZXJlci5fbGFzdE9iamVjdFJlbmRlcmVkLCBmdW5jLCBjYW5jZWxsZWQgfHwgIWV2ZW50QXBwZW5kKTtcclxuICAgICAgICAgICAgbGV0IHBvaW50ZXIgPSBuZXcgTW91c2VFdmVudF8xLk1vdXNlRXZlbnQoY2FuY2VsbGVkID8gTW91c2VFdmVudF8xLk1vdXNlRXZlbnQuUE9JTlRFUl9DQU5DRUwgOiAoTW91c2VFdmVudF8xLk1vdXNlRXZlbnQuUE9JTlRFUl9VUCkpO1xyXG4gICAgICAgICAgICBwb2ludGVyLmRhdGEgPSBpbnRlcmFjdGlvbkRhdGE7XHJcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChwb2ludGVyKTtcclxuICAgICAgICAgICAgaWYgKGV2ZW50LnBvaW50ZXJUeXBlID09PSAnbW91c2UnIHx8IGV2ZW50LnBvaW50ZXJUeXBlID09PSAncGVuJykge1xyXG4gICAgICAgICAgICAgICAgbGV0IGlzUmlnaHRCdXR0b24gPSBldmVudC5idXR0b24gPT09IDI7XHJcbiAgICAgICAgICAgICAgICBsZXQgcG9pbnRlciA9IG5ldyBNb3VzZUV2ZW50XzEuTW91c2VFdmVudChpc1JpZ2h0QnV0dG9uID8gKE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50LlJJR0hUX01PVVNFX1VQKSA6IChNb3VzZUV2ZW50XzEuTW91c2VFdmVudC5NT1VTRV9VUCkpO1xyXG4gICAgICAgICAgICAgICAgcG9pbnRlci5kYXRhID0gaW50ZXJhY3Rpb25EYXRhO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KHBvaW50ZXIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGV2ZW50LnBvaW50ZXJUeXBlID09PSAndG91Y2gnKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgcG9pbnRlciA9IG5ldyBNb3VzZUV2ZW50XzEuTW91c2VFdmVudChjYW5jZWxsZWQgPyBNb3VzZUV2ZW50XzEuTW91c2VFdmVudC5UT1VDSF9DQU5DRUwgOiAoTW91c2VFdmVudF8xLk1vdXNlRXZlbnQuVE9VQ0hfRU5EKSk7XHJcbiAgICAgICAgICAgICAgICBwb2ludGVyLmRhdGEgPSBpbnRlcmFjdGlvbkRhdGE7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQocG9pbnRlcik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlbGVhc2VJbnRlcmFjdGlvbkRhdGFGb3JQb2ludGVySWQoZXZlbnQucG9pbnRlcklkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIDtcclxuICAgIHJlbGVhc2VJbnRlcmFjdGlvbkRhdGFGb3JQb2ludGVySWQocG9pbnRlcklkKSB7XHJcbiAgICAgICAgbGV0IGludGVyYWN0aW9uRGF0YSA9IHRoaXMuYWN0aXZlSW50ZXJhY3Rpb25EYXRhW3BvaW50ZXJJZF07XHJcbiAgICAgICAgaWYgKGludGVyYWN0aW9uRGF0YSkge1xyXG4gICAgICAgICAgICBkZWxldGUgdGhpcy5hY3RpdmVJbnRlcmFjdGlvbkRhdGFbcG9pbnRlcklkXTtcclxuICAgICAgICAgICAgaW50ZXJhY3Rpb25EYXRhLnJlc2V0KCk7XHJcbiAgICAgICAgICAgIHRoaXMuaW50ZXJhY3Rpb25EYXRhUG9vbC5wdXNoKGludGVyYWN0aW9uRGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgcHJvY2Vzc1BvaW50ZXJDYW5jZWwoaW50ZXJhY3Rpb25FdmVudCwgZGlzcGxheU9iamVjdCkge1xyXG4gICAgICAgIGxldCBkYXRhID0gaW50ZXJhY3Rpb25FdmVudC5kYXRhO1xyXG4gICAgICAgIGxldCBpZCA9IGludGVyYWN0aW9uRXZlbnQuZGF0YS5pZGVudGlmaWVyO1xyXG4gICAgICAgIGlmIChkaXNwbGF5T2JqZWN0LnRyYWNrZWRQb2ludGVyc1tpZF0gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBkZWxldGUgZGlzcGxheU9iamVjdC50cmFja2VkUG9pbnRlcnNbaWRdO1xyXG4gICAgICAgICAgICBsZXQgcG9pbnRlciA9IG5ldyBNb3VzZUV2ZW50XzEuTW91c2VFdmVudChNb3VzZUV2ZW50XzEuTW91c2VFdmVudC5QT0lOVEVSX0NBTkNFTCk7XHJcbiAgICAgICAgICAgIHBvaW50ZXIuZGF0YSA9IGRhdGE7XHJcbiAgICAgICAgICAgIGRpc3BsYXlPYmplY3QuZGlzcGF0Y2hFdmVudChwb2ludGVyKTtcclxuICAgICAgICAgICAgaWYgKGRhdGEucG9pbnRlclR5cGUgPT09ICd0b3VjaCcpIHtcclxuICAgICAgICAgICAgICAgIGxldCBwb2ludGVyID0gbmV3IE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50KE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50LlRPVUNIX0NBTkNFTCk7XHJcbiAgICAgICAgICAgICAgICBwb2ludGVyLmRhdGEgPSBkYXRhO1xyXG4gICAgICAgICAgICAgICAgZGlzcGxheU9iamVjdC5kaXNwYXRjaEV2ZW50KHBvaW50ZXIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgZGVzdHJveShvcHRpb25zID0gbnVsbCkge1xyXG4gICAgICAgIHRoaXMucmVtb3ZlRXZlbnRzKCk7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5tb3VzZSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5ldmVudERhdGEgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuaW50ZXJhY3Rpb25ET01FbGVtZW50ID0gbnVsbDtcclxuICAgICAgICB0aGlzLm9uUG9pbnRlckRvd24gPSBudWxsO1xyXG4gICAgICAgIHRoaXMucHJvY2Vzc1BvaW50ZXJEb3duID0gbnVsbDtcclxuICAgICAgICB0aGlzLm9uUG9pbnRlclVwID0gbnVsbDtcclxuICAgICAgICB0aGlzLnByb2Nlc3NQb2ludGVyVXAgPSBudWxsO1xyXG4gICAgICAgIHRoaXMub25Qb2ludGVyQ2FuY2VsID0gbnVsbDtcclxuICAgICAgICB0aGlzLnByb2Nlc3NQb2ludGVyQ2FuY2VsID0gbnVsbDtcclxuICAgICAgICB0aGlzLm9uUG9pbnRlck1vdmUgPSBudWxsO1xyXG4gICAgICAgIHRoaXMucHJvY2Vzc1BvaW50ZXJNb3ZlID0gbnVsbDtcclxuICAgICAgICB0aGlzLm9uUG9pbnRlck91dCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5wcm9jZXNzUG9pbnRlck92ZXJPdXQgPSBudWxsO1xyXG4gICAgICAgIHRoaXMub25Qb2ludGVyT3ZlciA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5fdGVtcFBvaW50ID0gbnVsbDtcclxuICAgIH1cclxuICAgIDtcclxufVxyXG5JbnRlcmFjdGlvbk1hbmFnZXIuTU9VU0VfUE9JTlRFUl9JRCA9IDE7XHJcbmV4cG9ydHMuSW50ZXJhY3Rpb25NYW5hZ2VyID0gSW50ZXJhY3Rpb25NYW5hZ2VyO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jbGFzcyBJbnRlcmFjdGlvblRyYWNraW5nRGF0YSB7XHJcbiAgICBjb25zdHJ1Y3Rvcihwb2ludGVySWQpIHtcclxuICAgICAgICB0aGlzLl9wb2ludGVySWQgPSBwb2ludGVySWQ7XHJcbiAgICAgICAgdGhpcy5fZmxhZ3MgPSBJbnRlcmFjdGlvblRyYWNraW5nRGF0YS5GTEFHUy5OT05FO1xyXG4gICAgfVxyXG4gICAgX2RvU2V0KGZsYWcsIHluKSB7XHJcbiAgICAgICAgaWYgKHluKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2ZsYWdzID0gdGhpcy5fZmxhZ3MgfCBmbGFnO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5fZmxhZ3MgPSB0aGlzLl9mbGFncyAmICh+ZmxhZyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgZ2V0IHBvaW50ZXJJZCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcG9pbnRlcklkO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgZ2V0IGZsYWdzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9mbGFncztcclxuICAgIH1cclxuICAgIDtcclxuICAgIHNldCBmbGFncyhmbGFncykge1xyXG4gICAgICAgIHRoaXMuX2ZsYWdzID0gZmxhZ3M7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICBnZXQgbm9uZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZmxhZ3MgPT09IEludGVyYWN0aW9uVHJhY2tpbmdEYXRhLkZMQUdTLk5PTkU7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICBnZXQgb3ZlcigpIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMuX2ZsYWdzICYgSW50ZXJhY3Rpb25UcmFja2luZ0RhdGEuRkxBR1MuT1ZFUikgIT09IDA7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICBzZXQgb3Zlcih5bikge1xyXG4gICAgICAgIHRoaXMuX2RvU2V0KEludGVyYWN0aW9uVHJhY2tpbmdEYXRhLkZMQUdTLk9WRVIsIHluKTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIGdldCByaWdodERvd24oKSB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLl9mbGFncyAmIEludGVyYWN0aW9uVHJhY2tpbmdEYXRhLkZMQUdTLlJJR0hUX0RPV04pICE9PSAwO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgc2V0IHJpZ2h0RG93bih5bikge1xyXG4gICAgICAgIHRoaXMuX2RvU2V0KEludGVyYWN0aW9uVHJhY2tpbmdEYXRhLkZMQUdTLlJJR0hUX0RPV04sIHluKTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIGdldCBsZWZ0RG93bigpIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMuX2ZsYWdzICYgSW50ZXJhY3Rpb25UcmFja2luZ0RhdGEuRkxBR1MuTEVGVF9ET1dOKSAhPT0gMDtcclxuICAgIH1cclxuICAgIDtcclxuICAgIHNldCBsZWZ0RG93bih5bikge1xyXG4gICAgICAgIHRoaXMuX2RvU2V0KEludGVyYWN0aW9uVHJhY2tpbmdEYXRhLkZMQUdTLkxFRlRfRE9XTiwgeW4pO1xyXG4gICAgfVxyXG4gICAgO1xyXG59XHJcbkludGVyYWN0aW9uVHJhY2tpbmdEYXRhLkZMQUdTID0ge1xyXG4gICAgTk9ORTogMCxcclxuICAgIE9WRVI6IDEgPDwgMCxcclxuICAgIExFRlRfRE9XTjogMSA8PCAxLFxyXG4gICAgUklHSFRfRE9XTjogMSA8PCAyLFxyXG59O1xyXG5leHBvcnRzLkludGVyYWN0aW9uVHJhY2tpbmdEYXRhID0gSW50ZXJhY3Rpb25UcmFja2luZ0RhdGE7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IEZpbGxTdHlsZV8xID0gcmVxdWlyZShcIi4vRmlsbFN0eWxlXCIpO1xyXG5jbGFzcyBMaW5lU3R5bGUgZXh0ZW5kcyBGaWxsU3R5bGVfMS5GaWxsU3R5bGUge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgIH1cclxuICAgIGNsb25lKCkge1xyXG4gICAgICAgIHZhciBvYmogPSBuZXcgTGluZVN0eWxlKCk7XHJcbiAgICAgICAgb2JqLmNvbG9yID0gdGhpcy5jb2xvcjtcclxuICAgICAgICBvYmouYWxwaGEgPSB0aGlzLmFscGhhO1xyXG4gICAgICAgIG9iai50ZXh0dXJlID0gdGhpcy50ZXh0dXJlO1xyXG4gICAgICAgIG9iai5tYXRyaXggPSB0aGlzLm1hdHJpeDtcclxuICAgICAgICBvYmoudmlzaWJsZSA9IHRoaXMudmlzaWJsZTtcclxuICAgICAgICBvYmoud2lkdGggPSB0aGlzLndpZHRoO1xyXG4gICAgICAgIG9iai5hbGlnbm1lbnQgPSB0aGlzLmFsaWdubWVudDtcclxuICAgICAgICBvYmoubmF0aXZlID0gdGhpcy5uYXRpdmU7XHJcbiAgICAgICAgcmV0dXJuIG9iajtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogUmVzZXQgdGhlIGxpbmUgc3R5bGUgdG8gZGVmYXVsdC5cclxuICAgICAqL1xyXG4gICAgcmVzZXQoKSB7XHJcbiAgICAgICAgc3VwZXIucmVzZXQoKTtcclxuICAgICAgICAvLyBPdmVycmlkZSBkZWZhdWx0IGxpbmUgc3R5bGUgY29sb3JcclxuICAgICAgICB0aGlzLmNvbG9yID0gMHgwO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSB3aWR0aCAodGhpY2tuZXNzKSBvZiBhbnkgbGluZXMgZHJhd24uXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgICAgICogQGRlZmF1bHQgMFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMud2lkdGggPSAwO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBhbGlnbm1lbnQgb2YgYW55IGxpbmVzIGRyYXduICgwLjUgPSBtaWRkbGUsIDEgPSBvdXR0ZXIsIDAgPSBpbm5lcikuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgICAgICogQGRlZmF1bHQgMFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuYWxpZ25tZW50ID0gMC41O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIElmIHRydWUgdGhlIGxpbmVzIHdpbGwgYmUgZHJhdyB1c2luZyBMSU5FUyBpbnN0ZWFkIG9mIFRSSUFOR0xFX1NUUklQXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAbWVtYmVyIHtib29sZWFufVxyXG4gICAgICAgICAqIEBkZWZhdWx0IGZhbHNlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5uYXRpdmUgPSBmYWxzZTtcclxuICAgIH1cclxuICAgIDtcclxufVxyXG5leHBvcnRzLkxpbmVTdHlsZSA9IExpbmVTdHlsZTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy5PVVRQVVRfVE9fQ09OU09MRSA9IHRydWU7XHJcbmV4cG9ydHMudHJhY2UgPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgaWYgKCF2YWx1ZSkge1xyXG4gICAgICAgICAgICBpZiAoaXNOYU4odmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gXCJzaG93OiBudWxsXCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gXCJzaG93OiAwXCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBcInNob3c6IFwiICsgdmFsdWUudG9TdHJpbmcoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGV4cG9ydHMuT1VUUFVUX1RPX0NPTlNPTEUpIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2cocmVzdWx0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIGNhdGNoIChlKSB7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbDtcclxufTtcclxuZXhwb3J0cy5yZXZlYWxNZXRob2RzID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGlmICghdmFsdWUpIHtcclxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFwicmV2ZWFsIG1ldGhvZHM6IG51bGxcIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBcInJldmVhbCBtZXRob2RzOiBcIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHZhciBpbnN0YW5jZUl0ZW0gPSB2YWx1ZVtrZXldO1xyXG4gICAgICAgICAgICBpZiAoaW5zdGFuY2VJdGVtIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnbWV0aG9kOiAnICsga2V5ICsgJyA6ICcgKyB2YWx1ZVtrZXldICsgXCJcXG5cIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZXhwb3J0cy5PVVRQVVRfVE9fQ09OU09MRSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhyZXN1bHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGUpIHtcclxuICAgIH1cclxuICAgIHJldHVybiBudWxsO1xyXG59O1xyXG5leHBvcnRzLnJldmVhbCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgaWYgKCF2YWx1ZSkge1xyXG4gICAgICAgIHZhciByZXN1bHQgPSBcInJldmVhbDogbnVsbFwiO1xyXG4gICAgICAgIGlmIChleHBvcnRzLk9VVFBVVF9UT19DT05TT0xFKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHJlc3VsdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IFwicmV2ZWFsOiB1bmRlZmluZWRcIjtcclxuICAgICAgICBpZiAoZXhwb3J0cy5PVVRQVVRfVE9fQ09OU09MRSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhyZXN1bHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICB2YXIgcmVzdWx0ID0gXCJyZXZlYWw6IFwiO1xyXG4gICAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XHJcbiAgICAgICAgdmFyIGluc3RhbmNlSXRlbSA9IGdldFZhbHVlKGtleSwgdmFsdWUpO1xyXG4gICAgICAgIGlmIChpbnN0YW5jZUl0ZW0pIHtcclxuICAgICAgICAgICAgaWYgKGluc3RhbmNlSXRlbSBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gJ21ldGhvZDogJyArIGtleSArIFwiXFxuXCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSBrZXkgKyAnIDogJyArIGluc3RhbmNlSXRlbSArIFwiXFxuXCI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKGV4cG9ydHMuT1VUUFVUX1RPX0NPTlNPTEUpIHtcclxuICAgICAgICBjb25zb2xlLmxvZyhyZXN1bHQpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufTtcclxuY29uc3QgZ2V0VmFsdWUgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xyXG4gICAgdmFyIHZhbHVlUmVzdWx0ID0gbnVsbDtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgdmFsdWVSZXN1bHQgPSB2YWx1ZVtrZXldO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGUpIHtcclxuICAgIH1cclxuICAgIHJldHVybiB2YWx1ZVJlc3VsdDtcclxufTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgU3lzdGVtXzEgPSByZXF1aXJlKFwiLi9TeXN0ZW1cIik7XHJcbmNvbnN0IFNwcml0ZU1hc2tGaWx0ZXJfMSA9IHJlcXVpcmUoXCIuL1Nwcml0ZU1hc2tGaWx0ZXJcIik7XHJcbmNsYXNzIE1hc2tTeXN0ZW0gZXh0ZW5kcyBTeXN0ZW1fMS5TeXN0ZW0ge1xyXG4gICAgY29uc3RydWN0b3IocmVuZGVyZXIpIHtcclxuICAgICAgICBzdXBlcihyZW5kZXJlcik7XHJcbiAgICAgICAgLy8gVE9ETyAtIHdlIGRvbid0IG5lZWQgYm90aCFcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBgdHJ1ZWAgaWYgY3VycmVudCBwdXNoZWQgbWFza2VkIGlzIHNjaXNzb3JcclxuICAgICAgICAgKiBAbWVtYmVyIHtib29sZWFufVxyXG4gICAgICAgICAqIEByZWFkb25seVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuc2Npc3NvciA9IGZhbHNlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIE1hc2sgZGF0YVxyXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuR3JhcGhpY3N9XHJcbiAgICAgICAgICogQHJlYWRvbmx5XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5zY2lzc29yRGF0YSA9IG51bGw7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGFyZ2V0IHRvIG1hc2tcclxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLkRpc3BsYXlPYmplY3R9XHJcbiAgICAgICAgICogQHJlYWRvbmx5XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5zY2lzc29yUmVuZGVyVGFyZ2V0ID0gbnVsbDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBFbmFibGUgc2Npc3NvclxyXG4gICAgICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XHJcbiAgICAgICAgICogQHJlYWRvbmx5XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5lbmFibGVTY2lzc29yID0gZmFsc2U7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUG9vbCBvZiB1c2VkIHNwcml0ZSBtYXNrIGZpbHRlcnNcclxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLlNwcml0ZU1hc2tGaWx0ZXJbXX1cclxuICAgICAgICAgKiBAcmVhZG9ubHlcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmFscGhhTWFza1Bvb2wgPSBbXTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDdXJyZW50IGluZGV4IG9mIGFscGhhIG1hc2sgcG9vbFxyXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAgICAgKiBAZGVmYXVsdCAwXHJcbiAgICAgICAgICogQHJlYWRvbmx5XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5hbHBoYU1hc2tJbmRleCA9IDA7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFwcGxpZXMgdGhlIE1hc2sgYW5kIGFkZHMgaXQgdG8gdGhlIGN1cnJlbnQgZmlsdGVyIHN0YWNrLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7UElYSS5EaXNwbGF5T2JqZWN0fSB0YXJnZXQgLSBEaXNwbGF5IE9iamVjdCB0byBwdXNoIHRoZSBtYXNrIHRvXHJcbiAgICAgKiBAcGFyYW0ge1BJWEkuU3ByaXRlfFBJWEkuR3JhcGhpY3N9IG1hc2tEYXRhIC0gVGhlIG1hc2tpbmcgZGF0YS5cclxuICAgICAqL1xyXG4gICAgcHVzaCh0YXJnZXQsIG1hc2tEYXRhKSB7XHJcbiAgICAgICAgLy8gVE9ETyB0aGUgcm9vdCBjaGVjayBtZWFucyBzY2lzc29yIHJlY3Qgd2lsbCBub3RcclxuICAgICAgICAvLyBiZSB1c2VkIG9uIHJlbmRlciB0ZXh0dXJlcyBtb3JlIGluZm8gaGVyZTpcclxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vcGl4aWpzL3BpeGkuanMvcHVsbC8zNTQ1XHJcbiAgICAgICAgaWYgKG1hc2tEYXRhLmlzU3ByaXRlKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHVzaFNwcml0ZU1hc2sodGFyZ2V0LCBtYXNrRGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMuZW5hYmxlU2Npc3NvclxyXG4gICAgICAgICAgICAmJiAhdGhpcy5zY2lzc29yXHJcbiAgICAgICAgICAgICYmIHRoaXMucmVuZGVyZXIuX2FjdGl2ZVJlbmRlclRhcmdldC5yb290XHJcbiAgICAgICAgICAgICYmICF0aGlzLnJlbmRlcmVyLnN0ZW5jaWwuc3RlbmNpbE1hc2tTdGFjay5sZW5ndGhcclxuICAgICAgICAgICAgJiYgbWFza0RhdGEuaXNGYXN0UmVjdCgpKSB7XHJcbiAgICAgICAgICAgIHZhciBtYXRyaXggPSBtYXNrRGF0YS53b3JsZFRyYW5zZm9ybTtcclxuICAgICAgICAgICAgdmFyIHJvdCA9IE1hdGguYXRhbjIobWF0cml4LmIsIG1hdHJpeC5hKTtcclxuICAgICAgICAgICAgLy8gdXNlIHRoZSBuZWFyZXN0IGRlZ3JlZSFcclxuICAgICAgICAgICAgcm90ID0gTWF0aC5yb3VuZChyb3QgKiAoMTgwIC8gTWF0aC5QSSkpO1xyXG4gICAgICAgICAgICBpZiAocm90ICUgOTApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucHVzaFN0ZW5jaWxNYXNrKG1hc2tEYXRhKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucHVzaFNjaXNzb3JNYXNrKHRhcmdldCwgbWFza0RhdGEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnB1c2hTdGVuY2lsTWFzayhtYXNrRGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIHRoZSBsYXN0IG1hc2sgZnJvbSB0aGUgbWFzayBzdGFjayBhbmQgZG9lc24ndCByZXR1cm4gaXQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtQSVhJLkRpc3BsYXlPYmplY3R9IHRhcmdldCAtIERpc3BsYXkgT2JqZWN0IHRvIHBvcCB0aGUgbWFzayBmcm9tXHJcbiAgICAgKiBAcGFyYW0ge1BJWEkuU3ByaXRlfFBJWEkuR3JhcGhpY3N9IG1hc2tEYXRhIC0gVGhlIG1hc2tpbmcgZGF0YS5cclxuICAgICAqL1xyXG4gICAgcG9wKHRhcmdldCwgbWFza0RhdGEpIHtcclxuICAgICAgICBpZiAobWFza0RhdGEuaXNTcHJpdGUpIHtcclxuICAgICAgICAgICAgdGhpcy5wb3BTcHJpdGVNYXNrKHRhcmdldCwgbWFza0RhdGEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLmVuYWJsZVNjaXNzb3IgJiYgIXRoaXMucmVuZGVyZXIuc3RlbmNpbC5zdGVuY2lsTWFza1N0YWNrLmxlbmd0aCkge1xyXG4gICAgICAgICAgICB0aGlzLnBvcFNjaXNzb3JNYXNrKHRhcmdldCwgbWFza0RhdGEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5wb3BTdGVuY2lsTWFzayh0YXJnZXQsIG1hc2tEYXRhKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIEFwcGxpZXMgdGhlIE1hc2sgYW5kIGFkZHMgaXQgdG8gdGhlIGN1cnJlbnQgZmlsdGVyIHN0YWNrLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7UElYSS5SZW5kZXJUZXh0dXJlfSB0YXJnZXQgLSBEaXNwbGF5IE9iamVjdCB0byBwdXNoIHRoZSBzcHJpdGUgbWFzayB0b1xyXG4gICAgICogQHBhcmFtIHtQSVhJLlNwcml0ZX0gbWFza0RhdGEgLSBTcHJpdGUgdG8gYmUgdXNlZCBhcyB0aGUgbWFza1xyXG4gICAgICovXHJcbiAgICBwdXNoU3ByaXRlTWFzayh0YXJnZXQsIG1hc2tEYXRhKSB7XHJcbiAgICAgICAgdmFyIGFscGhhTWFza0ZpbHRlciA9IHRoaXMuYWxwaGFNYXNrUG9vbFt0aGlzLmFscGhhTWFza0luZGV4XTtcclxuICAgICAgICBpZiAoIWFscGhhTWFza0ZpbHRlcikge1xyXG4gICAgICAgICAgICBhbHBoYU1hc2tGaWx0ZXIgPSB0aGlzLmFscGhhTWFza1Bvb2xbdGhpcy5hbHBoYU1hc2tJbmRleF0gPSBbbmV3IFNwcml0ZU1hc2tGaWx0ZXJfMS5TcHJpdGVNYXNrRmlsdGVyKG1hc2tEYXRhKV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGFscGhhTWFza0ZpbHRlclswXS5yZXNvbHV0aW9uID0gdGhpcy5yZW5kZXJlci5yZXNvbHV0aW9uO1xyXG4gICAgICAgIGFscGhhTWFza0ZpbHRlclswXS5tYXNrU3ByaXRlID0gbWFza0RhdGE7XHJcbiAgICAgICAgdmFyIHN0YXNoRmlsdGVyQXJlYSA9IHRhcmdldC5maWx0ZXJBcmVhO1xyXG4gICAgICAgIHRhcmdldC5maWx0ZXJBcmVhID0gbWFza0RhdGEuZ2V0Qm91bmRzKHRydWUpO1xyXG4gICAgICAgIHRoaXMucmVuZGVyZXIuZmlsdGVyLnB1c2godGFyZ2V0LCBhbHBoYU1hc2tGaWx0ZXIpO1xyXG4gICAgICAgIHRhcmdldC5maWx0ZXJBcmVhID0gc3Rhc2hGaWx0ZXJBcmVhO1xyXG4gICAgICAgIHRoaXMuYWxwaGFNYXNrSW5kZXgrKztcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyB0aGUgbGFzdCBmaWx0ZXIgZnJvbSB0aGUgZmlsdGVyIHN0YWNrIGFuZCBkb2Vzbid0IHJldHVybiBpdC5cclxuICAgICAqXHJcbiAgICAgKi9cclxuICAgIHBvcFNwcml0ZU1hc2soYSwgYikge1xyXG4gICAgICAgIHRoaXMucmVuZGVyZXIuZmlsdGVyLnBvcCgpO1xyXG4gICAgICAgIHRoaXMuYWxwaGFNYXNrSW5kZXgtLTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQXBwbGllcyB0aGUgTWFzayBhbmQgYWRkcyBpdCB0byB0aGUgY3VycmVudCBmaWx0ZXIgc3RhY2suXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtQSVhJLlNwcml0ZXxQSVhJLkdyYXBoaWNzfSBtYXNrRGF0YSAtIFRoZSBtYXNraW5nIGRhdGEuXHJcbiAgICAgKi9cclxuICAgIHB1c2hTdGVuY2lsTWFzayhtYXNrRGF0YSkge1xyXG4gICAgICAgIHRoaXMucmVuZGVyZXIuYmF0Y2guZmx1c2goKTtcclxuICAgICAgICB0aGlzLnJlbmRlcmVyLnN0ZW5jaWwucHVzaFN0ZW5jaWwobWFza0RhdGEpO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIHRoZSBsYXN0IGZpbHRlciBmcm9tIHRoZSBmaWx0ZXIgc3RhY2sgYW5kIGRvZXNuJ3QgcmV0dXJuIGl0LlxyXG4gICAgICpcclxuICAgICAqL1xyXG4gICAgcG9wU3RlbmNpbE1hc2soYSwgYikge1xyXG4gICAgICAgIC8vIHRoaXMucmVuZGVyZXIuY3VycmVudFJlbmRlcmVyLnN0b3AoKTtcclxuICAgICAgICB0aGlzLnJlbmRlcmVyLnN0ZW5jaWwucG9wU3RlbmNpbCgpO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtQSVhJLkRpc3BsYXlPYmplY3R9IHRhcmdldCAtIERpc3BsYXkgT2JqZWN0IHRvIHB1c2ggdGhlIG1hc2sgdG9cclxuICAgICAqIEBwYXJhbSB7UElYSS5HcmFwaGljc30gbWFza0RhdGEgLSBUaGUgbWFza2luZyBkYXRhLlxyXG4gICAgICovXHJcbiAgICBwdXNoU2Npc3Nvck1hc2sodGFyZ2V0LCBtYXNrRGF0YSkge1xyXG4gICAgICAgIG1hc2tEYXRhLnJlbmRlcmFibGUgPSB0cnVlO1xyXG4gICAgICAgIHZhciByZW5kZXJUYXJnZXQgPSB0aGlzLnJlbmRlcmVyLl9hY3RpdmVSZW5kZXJUYXJnZXQ7XHJcbiAgICAgICAgdmFyIGJvdW5kcyA9IG1hc2tEYXRhLmdldEJvdW5kcygpO1xyXG4gICAgICAgIGJvdW5kcy5maXQocmVuZGVyVGFyZ2V0LnNpemUpO1xyXG4gICAgICAgIG1hc2tEYXRhLnJlbmRlcmFibGUgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnJlbmRlcmVyLmdsLmVuYWJsZSh0aGlzLnJlbmRlcmVyLmdsLlNDSVNTT1JfVEVTVCk7XHJcbiAgICAgICAgdmFyIHJlc29sdXRpb24gPSB0aGlzLnJlbmRlcmVyLnJlc29sdXRpb247XHJcbiAgICAgICAgdGhpcy5yZW5kZXJlci5nbC5zY2lzc29yKGJvdW5kcy54ICogcmVzb2x1dGlvbiwgKHJlbmRlclRhcmdldC5yb290ID8gcmVuZGVyVGFyZ2V0LnNpemUuaGVpZ2h0IC0gYm91bmRzLnkgLSBib3VuZHMuaGVpZ2h0IDogYm91bmRzLnkpICogcmVzb2x1dGlvbiwgYm91bmRzLndpZHRoICogcmVzb2x1dGlvbiwgYm91bmRzLmhlaWdodCAqIHJlc29sdXRpb24pO1xyXG4gICAgICAgIHRoaXMuc2Npc3NvclJlbmRlclRhcmdldCA9IHJlbmRlclRhcmdldDtcclxuICAgICAgICB0aGlzLnNjaXNzb3JEYXRhID0gbWFza0RhdGE7XHJcbiAgICAgICAgdGhpcy5zY2lzc29yID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogUG9wIHNjaXNzb3IgbWFza1xyXG4gICAgICpcclxuICAgICAqL1xyXG4gICAgcG9wU2Npc3Nvck1hc2soYSwgYikge1xyXG4gICAgICAgIHRoaXMuc2Npc3NvclJlbmRlclRhcmdldCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5zY2lzc29yRGF0YSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5zY2lzc29yID0gZmFsc2U7XHJcbiAgICAgICAgLy8gbXVzdCBiZSBzY2lzc29yIVxyXG4gICAgICAgIHZhciByZWYgPSB0aGlzLnJlbmRlcmVyO1xyXG4gICAgICAgIHZhciBnbCA9IHJlZi5nbDtcclxuICAgICAgICBnbC5kaXNhYmxlKGdsLlNDSVNTT1JfVEVTVCk7XHJcbiAgICB9XHJcbiAgICA7XHJcbn1cclxuZXhwb3J0cy5NYXNrU3lzdGVtID0gTWFza1N5c3RlbTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY2xhc3MgTWF0aFNldHRpbmdzIHtcclxuICAgIHN0YXRpYyB1aWQoKSB7XHJcbiAgICAgICAgcmV0dXJuICsrTWF0aFNldHRpbmdzLm5leHRVaWQ7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgc2lnbihuKSB7XHJcbiAgICAgICAgaWYgKG4gPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuIDwgMCA/IC0xIDogMTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBzdHJpbmcyaGV4KHN0cmluZykge1xyXG4gICAgICAgIGlmICh0eXBlb2Ygc3RyaW5nID09PSAnc3RyaW5nJyAmJiBzdHJpbmdbMF0gPT09ICcjJykge1xyXG4gICAgICAgICAgICBzdHJpbmcgPSBzdHJpbmcuc3Vic3RyKDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcGFyc2VJbnQoc3RyaW5nLCAxNik7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgaGV4MnN0cmluZyhoZXgpIHtcclxuICAgICAgICBoZXggPSBoZXgudG9TdHJpbmcoMTYpO1xyXG4gICAgICAgIGhleCA9ICcwMDAwMDAnLnN1YnN0cigwLCA2IC0gaGV4Lmxlbmd0aCkgKyBoZXg7XHJcbiAgICAgICAgcmV0dXJuIChcIiNcIiArIGhleCk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgbG9nMih2KSB7XHJcbiAgICAgICAgdmFyIHIgPSAodiA+IDB4RkZGRikgPDwgNDtcclxuICAgICAgICB2ID4+Pj0gcjtcclxuICAgICAgICB2YXIgc2hpZnQgPSAodiA+IDB4RkYpIDw8IDM7XHJcbiAgICAgICAgdiA+Pj49IHNoaWZ0O1xyXG4gICAgICAgIHIgfD0gc2hpZnQ7XHJcbiAgICAgICAgc2hpZnQgPSAodiA+IDB4RikgPDwgMjtcclxuICAgICAgICB2ID4+Pj0gc2hpZnQ7XHJcbiAgICAgICAgciB8PSBzaGlmdDtcclxuICAgICAgICBzaGlmdCA9ICh2ID4gMHgzKSA8PCAxO1xyXG4gICAgICAgIHYgPj4+PSBzaGlmdDtcclxuICAgICAgICByIHw9IHNoaWZ0O1xyXG4gICAgICAgIHJldHVybiByIHwgKHYgPj4gMSk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgbmV4dFBvdzIodikge1xyXG4gICAgICAgIHYgKz0gdiA9PT0gMDtcclxuICAgICAgICAtLXY7XHJcbiAgICAgICAgdiB8PSB2ID4+PiAxO1xyXG4gICAgICAgIHYgfD0gdiA+Pj4gMjtcclxuICAgICAgICB2IHw9IHYgPj4+IDQ7XHJcbiAgICAgICAgdiB8PSB2ID4+PiA4O1xyXG4gICAgICAgIHYgfD0gdiA+Pj4gMTY7XHJcbiAgICAgICAgcmV0dXJuIHYgKyAxO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGlzUG93Mih2KSB7XHJcbiAgICAgICAgcmV0dXJuICEodiAmICh2IC0gMSkpICYmICghIXYpO1xyXG4gICAgfVxyXG59XHJcbk1hdGhTZXR0aW5ncy5uZXh0VWlkID0gMDtcclxuTWF0aFNldHRpbmdzLlBJXzIgPSBNYXRoLlBJICogMjtcclxuTWF0aFNldHRpbmdzLlJBRF9UT19ERUcgPSAxODAgLyBNYXRoLlBJO1xyXG5NYXRoU2V0dGluZ3MuREVHX1RPX1JBRCA9IE1hdGguUEkgLyAxODA7XHJcbmV4cG9ydHMuTWF0aFNldHRpbmdzID0gTWF0aFNldHRpbmdzO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBQb2ludF8xID0gcmVxdWlyZShcIi4vUG9pbnRcIik7XHJcbmNvbnN0IE1hdGhTZXR0aW5nc18xID0gcmVxdWlyZShcIi4vTWF0aFNldHRpbmdzXCIpO1xyXG5jbGFzcyBNYXRyaXgge1xyXG4gICAgY29uc3RydWN0b3IoYSA9IDEsIGIgPSAwLCBjID0gMCwgZCA9IDEsIHR4ID0gMCwgdHkgPSAwKSB7XHJcbiAgICAgICAgaWYgKGEgPT09IHZvaWQgMCkge1xyXG4gICAgICAgICAgICBhID0gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGIgPT09IHZvaWQgMCkge1xyXG4gICAgICAgICAgICBiID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGMgPT09IHZvaWQgMCkge1xyXG4gICAgICAgICAgICBjID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGQgPT09IHZvaWQgMCkge1xyXG4gICAgICAgICAgICBkID0gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR4ID09PSB2b2lkIDApIHtcclxuICAgICAgICAgICAgdHggPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHkgPT09IHZvaWQgMCkge1xyXG4gICAgICAgICAgICB0eSA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAgICAgKiBAZGVmYXVsdCAxXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5hID0gYTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgICAgICogQGRlZmF1bHQgMFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuYiA9IGI7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICAgICAqIEBkZWZhdWx0IDBcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmMgPSBjO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAgICAgKiBAZGVmYXVsdCAxXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5kID0gZDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgICAgICogQGRlZmF1bHQgMFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMudHggPSB0eDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgICAgICogQGRlZmF1bHQgMFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMudHkgPSB0eTtcclxuICAgICAgICB0aGlzLmFycmF5ID0gbnVsbDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIE1hdHJpeCBvYmplY3QgYmFzZWQgb24gdGhlIGdpdmVuIGFycmF5LiBUaGUgRWxlbWVudCB0byBNYXRyaXggbWFwcGluZyBvcmRlciBpcyBhcyBmb2xsb3dzOlxyXG4gICAgICpcclxuICAgICAqIGEgPSBhcnJheVswXVxyXG4gICAgICogYiA9IGFycmF5WzFdXHJcbiAgICAgKiBjID0gYXJyYXlbM11cclxuICAgICAqIGQgPSBhcnJheVs0XVxyXG4gICAgICogdHggPSBhcnJheVsyXVxyXG4gICAgICogdHkgPSBhcnJheVs1XVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyW119IGFycmF5IC0gVGhlIGFycmF5IHRoYXQgdGhlIG1hdHJpeCB3aWxsIGJlIHBvcHVsYXRlZCBmcm9tLlxyXG4gICAgICovXHJcbiAgICBmcm9tQXJyYXkoYXJyYXkpIHtcclxuICAgICAgICB0aGlzLmEgPSBhcnJheVswXTtcclxuICAgICAgICB0aGlzLmIgPSBhcnJheVsxXTtcclxuICAgICAgICB0aGlzLmMgPSBhcnJheVszXTtcclxuICAgICAgICB0aGlzLmQgPSBhcnJheVs0XTtcclxuICAgICAgICB0aGlzLnR4ID0gYXJyYXlbMl07XHJcbiAgICAgICAgdGhpcy50eSA9IGFycmF5WzVdO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBzZXRzIHRoZSBtYXRyaXggcHJvcGVydGllc1xyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhIC0gTWF0cml4IGNvbXBvbmVudFxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGIgLSBNYXRyaXggY29tcG9uZW50XHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYyAtIE1hdHJpeCBjb21wb25lbnRcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkIC0gTWF0cml4IGNvbXBvbmVudFxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHR4IC0gTWF0cml4IGNvbXBvbmVudFxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHR5IC0gTWF0cml4IGNvbXBvbmVudFxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4ge1BJWEkuTWF0cml4fSBUaGlzIG1hdHJpeC4gR29vZCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzLlxyXG4gICAgICovXHJcbiAgICBzZXQoYSwgYiwgYywgZCwgdHgsIHR5KSB7XHJcbiAgICAgICAgdGhpcy5hID0gYTtcclxuICAgICAgICB0aGlzLmIgPSBiO1xyXG4gICAgICAgIHRoaXMuYyA9IGM7XHJcbiAgICAgICAgdGhpcy5kID0gZDtcclxuICAgICAgICB0aGlzLnR4ID0gdHg7XHJcbiAgICAgICAgdGhpcy50eSA9IHR5O1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IGZyb20gdGhlIGN1cnJlbnQgTWF0cml4IG9iamVjdC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHRyYW5zcG9zZSAtIFdoZXRoZXIgd2UgbmVlZCB0byB0cmFuc3Bvc2UgdGhlIG1hdHJpeCBvciBub3RcclxuICAgICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fSBbb3V0PW5ldyBGbG9hdDMyQXJyYXkoOSldIC0gSWYgcHJvdmlkZWQgdGhlIGFycmF5IHdpbGwgYmUgYXNzaWduZWQgdG8gb3V0XHJcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJbXX0gdGhlIG5ld2x5IGNyZWF0ZWQgYXJyYXkgd2hpY2ggY29udGFpbnMgdGhlIG1hdHJpeFxyXG4gICAgICovXHJcbiAgICB0b0FycmF5KHRyYW5zcG9zZSwgb3V0ID0gbnVsbCkge1xyXG4gICAgICAgIGlmICghdGhpcy5hcnJheSkge1xyXG4gICAgICAgICAgICB0aGlzLmFycmF5ID0gbmV3IEZsb2F0MzJBcnJheSg5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGFycmF5ID0gb3V0IHx8IHRoaXMuYXJyYXk7XHJcbiAgICAgICAgaWYgKHRyYW5zcG9zZSkge1xyXG4gICAgICAgICAgICBhcnJheVswXSA9IHRoaXMuYTtcclxuICAgICAgICAgICAgYXJyYXlbMV0gPSB0aGlzLmI7XHJcbiAgICAgICAgICAgIGFycmF5WzJdID0gMDtcclxuICAgICAgICAgICAgYXJyYXlbM10gPSB0aGlzLmM7XHJcbiAgICAgICAgICAgIGFycmF5WzRdID0gdGhpcy5kO1xyXG4gICAgICAgICAgICBhcnJheVs1XSA9IDA7XHJcbiAgICAgICAgICAgIGFycmF5WzZdID0gdGhpcy50eDtcclxuICAgICAgICAgICAgYXJyYXlbN10gPSB0aGlzLnR5O1xyXG4gICAgICAgICAgICBhcnJheVs4XSA9IDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBhcnJheVswXSA9IHRoaXMuYTtcclxuICAgICAgICAgICAgYXJyYXlbMV0gPSB0aGlzLmM7XHJcbiAgICAgICAgICAgIGFycmF5WzJdID0gdGhpcy50eDtcclxuICAgICAgICAgICAgYXJyYXlbM10gPSB0aGlzLmI7XHJcbiAgICAgICAgICAgIGFycmF5WzRdID0gdGhpcy5kO1xyXG4gICAgICAgICAgICBhcnJheVs1XSA9IHRoaXMudHk7XHJcbiAgICAgICAgICAgIGFycmF5WzZdID0gMDtcclxuICAgICAgICAgICAgYXJyYXlbN10gPSAwO1xyXG4gICAgICAgICAgICBhcnJheVs4XSA9IDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhcnJheTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogR2V0IGEgbmV3IHBvc2l0aW9uIHdpdGggdGhlIGN1cnJlbnQgdHJhbnNmb3JtYXRpb24gYXBwbGllZC5cclxuICAgICAqIENhbiBiZSB1c2VkIHRvIGdvIGZyb20gYSBjaGlsZCdzIGNvb3JkaW5hdGUgc3BhY2UgdG8gdGhlIHdvcmxkIGNvb3JkaW5hdGUgc3BhY2UuIChlLmcuIHJlbmRlcmluZylcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1BJWEkuUG9pbnR9IHBvcyAtIFRoZSBvcmlnaW5cclxuICAgICAqIEBwYXJhbSB7UElYSS5Qb2ludH0gW25ld1Bvc10gLSBUaGUgcG9pbnQgdGhhdCB0aGUgbmV3IHBvc2l0aW9uIGlzIGFzc2lnbmVkIHRvIChhbGxvd2VkIHRvIGJlIHNhbWUgYXMgaW5wdXQpXHJcbiAgICAgKiBAcmV0dXJuIHtQSVhJLlBvaW50fSBUaGUgbmV3IHBvaW50LCB0cmFuc2Zvcm1lZCB0aHJvdWdoIHRoaXMgbWF0cml4XHJcbiAgICAgKi9cclxuICAgIGFwcGx5KHBvcywgbmV3UG9zKSB7XHJcbiAgICAgICAgbmV3UG9zID0gbmV3UG9zIHx8IG5ldyBQb2ludF8xLlBvaW50KCk7XHJcbiAgICAgICAgdmFyIHggPSBwb3MueDtcclxuICAgICAgICB2YXIgeSA9IHBvcy55O1xyXG4gICAgICAgIG5ld1Bvcy54ID0gKHRoaXMuYSAqIHgpICsgKHRoaXMuYyAqIHkpICsgdGhpcy50eDtcclxuICAgICAgICBuZXdQb3MueSA9ICh0aGlzLmIgKiB4KSArICh0aGlzLmQgKiB5KSArIHRoaXMudHk7XHJcbiAgICAgICAgcmV0dXJuIG5ld1BvcztcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogR2V0IGEgbmV3IHBvc2l0aW9uIHdpdGggdGhlIGludmVyc2Ugb2YgdGhlIGN1cnJlbnQgdHJhbnNmb3JtYXRpb24gYXBwbGllZC5cclxuICAgICAqIENhbiBiZSB1c2VkIHRvIGdvIGZyb20gdGhlIHdvcmxkIGNvb3JkaW5hdGUgc3BhY2UgdG8gYSBjaGlsZCdzIGNvb3JkaW5hdGUgc3BhY2UuIChlLmcuIGlucHV0KVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7UElYSS5Qb2ludH0gcG9zIC0gVGhlIG9yaWdpblxyXG4gICAgICogQHBhcmFtIHtQSVhJLlBvaW50fSBbbmV3UG9zXSAtIFRoZSBwb2ludCB0aGF0IHRoZSBuZXcgcG9zaXRpb24gaXMgYXNzaWduZWQgdG8gKGFsbG93ZWQgdG8gYmUgc2FtZSBhcyBpbnB1dClcclxuICAgICAqIEByZXR1cm4ge1BJWEkuUG9pbnR9IFRoZSBuZXcgcG9pbnQsIGludmVyc2UtdHJhbnNmb3JtZWQgdGhyb3VnaCB0aGlzIG1hdHJpeFxyXG4gICAgICovXHJcbiAgICBhcHBseUludmVyc2UocG9zLCBuZXdQb3MpIHtcclxuICAgICAgICBuZXdQb3MgPSBuZXdQb3MgfHwgbmV3IFBvaW50XzEuUG9pbnQoKTtcclxuICAgICAgICB2YXIgaWQgPSAxIC8gKCh0aGlzLmEgKiB0aGlzLmQpICsgKHRoaXMuYyAqIC10aGlzLmIpKTtcclxuICAgICAgICB2YXIgeCA9IHBvcy54O1xyXG4gICAgICAgIHZhciB5ID0gcG9zLnk7XHJcbiAgICAgICAgbmV3UG9zLnggPSAodGhpcy5kICogaWQgKiB4KSArICgtdGhpcy5jICogaWQgKiB5KSArICgoKHRoaXMudHkgKiB0aGlzLmMpIC0gKHRoaXMudHggKiB0aGlzLmQpKSAqIGlkKTtcclxuICAgICAgICBuZXdQb3MueSA9ICh0aGlzLmEgKiBpZCAqIHkpICsgKC10aGlzLmIgKiBpZCAqIHgpICsgKCgoLXRoaXMudHkgKiB0aGlzLmEpICsgKHRoaXMudHggKiB0aGlzLmIpKSAqIGlkKTtcclxuICAgICAgICByZXR1cm4gbmV3UG9zO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUcmFuc2xhdGVzIHRoZSBtYXRyaXggb24gdGhlIHggYW5kIHkuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggSG93IG11Y2ggdG8gdHJhbnNsYXRlIHggYnlcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IEhvdyBtdWNoIHRvIHRyYW5zbGF0ZSB5IGJ5XHJcbiAgICAgKiBAcmV0dXJuIHtQSVhJLk1hdHJpeH0gVGhpcyBtYXRyaXguIEdvb2QgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxscy5cclxuICAgICAqL1xyXG4gICAgdHJhbnNsYXRlKHgsIHkpIHtcclxuICAgICAgICB0aGlzLnR4ICs9IHg7XHJcbiAgICAgICAgdGhpcy50eSArPSB5O1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBsaWVzIGEgc2NhbGUgdHJhbnNmb3JtYXRpb24gdG8gdGhlIG1hdHJpeC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCBUaGUgYW1vdW50IHRvIHNjYWxlIGhvcml6b250YWxseVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgVGhlIGFtb3VudCB0byBzY2FsZSB2ZXJ0aWNhbGx5XHJcbiAgICAgKiBAcmV0dXJuIHtQSVhJLk1hdHJpeH0gVGhpcyBtYXRyaXguIEdvb2QgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxscy5cclxuICAgICAqL1xyXG4gICAgc2NhbGUoeCwgeSkge1xyXG4gICAgICAgIHRoaXMuYSAqPSB4O1xyXG4gICAgICAgIHRoaXMuZCAqPSB5O1xyXG4gICAgICAgIHRoaXMuYyAqPSB4O1xyXG4gICAgICAgIHRoaXMuYiAqPSB5O1xyXG4gICAgICAgIHRoaXMudHggKj0geDtcclxuICAgICAgICB0aGlzLnR5ICo9IHk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIEFwcGxpZXMgYSByb3RhdGlvbiB0cmFuc2Zvcm1hdGlvbiB0byB0aGUgbWF0cml4LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZSAtIFRoZSBhbmdsZSBpbiByYWRpYW5zLlxyXG4gICAgICogQHJldHVybiB7UElYSS5NYXRyaXh9IFRoaXMgbWF0cml4LiBHb29kIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHMuXHJcbiAgICAgKi9cclxuICAgIHJvdGF0ZShhbmdsZSkge1xyXG4gICAgICAgIHZhciBjb3MgPSBNYXRoLmNvcyhhbmdsZSk7XHJcbiAgICAgICAgdmFyIHNpbiA9IE1hdGguc2luKGFuZ2xlKTtcclxuICAgICAgICB2YXIgYTEgPSB0aGlzLmE7XHJcbiAgICAgICAgdmFyIGMxID0gdGhpcy5jO1xyXG4gICAgICAgIHZhciB0eDEgPSB0aGlzLnR4O1xyXG4gICAgICAgIHRoaXMuYSA9IChhMSAqIGNvcykgLSAodGhpcy5iICogc2luKTtcclxuICAgICAgICB0aGlzLmIgPSAoYTEgKiBzaW4pICsgKHRoaXMuYiAqIGNvcyk7XHJcbiAgICAgICAgdGhpcy5jID0gKGMxICogY29zKSAtICh0aGlzLmQgKiBzaW4pO1xyXG4gICAgICAgIHRoaXMuZCA9IChjMSAqIHNpbikgKyAodGhpcy5kICogY29zKTtcclxuICAgICAgICB0aGlzLnR4ID0gKHR4MSAqIGNvcykgLSAodGhpcy50eSAqIHNpbik7XHJcbiAgICAgICAgdGhpcy50eSA9ICh0eDEgKiBzaW4pICsgKHRoaXMudHkgKiBjb3MpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBlbmRzIHRoZSBnaXZlbiBNYXRyaXggdG8gdGhpcyBNYXRyaXguXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtQSVhJLk1hdHJpeH0gbWF0cml4IC0gVGhlIG1hdHJpeCB0byBhcHBlbmQuXHJcbiAgICAgKiBAcmV0dXJuIHtQSVhJLk1hdHJpeH0gVGhpcyBtYXRyaXguIEdvb2QgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxscy5cclxuICAgICAqL1xyXG4gICAgYXBwZW5kKG1hdHJpeCkge1xyXG4gICAgICAgIHZhciBhMSA9IHRoaXMuYTtcclxuICAgICAgICB2YXIgYjEgPSB0aGlzLmI7XHJcbiAgICAgICAgdmFyIGMxID0gdGhpcy5jO1xyXG4gICAgICAgIHZhciBkMSA9IHRoaXMuZDtcclxuICAgICAgICB0aGlzLmEgPSAobWF0cml4LmEgKiBhMSkgKyAobWF0cml4LmIgKiBjMSk7XHJcbiAgICAgICAgdGhpcy5iID0gKG1hdHJpeC5hICogYjEpICsgKG1hdHJpeC5iICogZDEpO1xyXG4gICAgICAgIHRoaXMuYyA9IChtYXRyaXguYyAqIGExKSArIChtYXRyaXguZCAqIGMxKTtcclxuICAgICAgICB0aGlzLmQgPSAobWF0cml4LmMgKiBiMSkgKyAobWF0cml4LmQgKiBkMSk7XHJcbiAgICAgICAgdGhpcy50eCA9IChtYXRyaXgudHggKiBhMSkgKyAobWF0cml4LnR5ICogYzEpICsgdGhpcy50eDtcclxuICAgICAgICB0aGlzLnR5ID0gKG1hdHJpeC50eCAqIGIxKSArIChtYXRyaXgudHkgKiBkMSkgKyB0aGlzLnR5O1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBtYXRyaXggYmFzZWQgb24gYWxsIHRoZSBhdmFpbGFibGUgcHJvcGVydGllc1xyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gUG9zaXRpb24gb24gdGhlIHggYXhpc1xyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgLSBQb3NpdGlvbiBvbiB0aGUgeSBheGlzXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcGl2b3RYIC0gUGl2b3Qgb24gdGhlIHggYXhpc1xyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBpdm90WSAtIFBpdm90IG9uIHRoZSB5IGF4aXNcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzY2FsZVggLSBTY2FsZSBvbiB0aGUgeCBheGlzXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2NhbGVZIC0gU2NhbGUgb24gdGhlIHkgYXhpc1xyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJvdGF0aW9uIC0gUm90YXRpb24gaW4gcmFkaWFuc1xyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNrZXdYIC0gU2tldyBvbiB0aGUgeCBheGlzXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2tld1kgLSBTa2V3IG9uIHRoZSB5IGF4aXNcclxuICAgICAqIEByZXR1cm4ge1BJWEkuTWF0cml4fSBUaGlzIG1hdHJpeC4gR29vZCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzLlxyXG4gICAgICovXHJcbiAgICBzZXRUcmFuc2Zvcm0oeCwgeSwgcGl2b3RYLCBwaXZvdFksIHNjYWxlWCwgc2NhbGVZLCByb3RhdGlvbiwgc2tld1gsIHNrZXdZKSB7XHJcbiAgICAgICAgdGhpcy5hID0gTWF0aC5jb3Mocm90YXRpb24gKyBza2V3WSkgKiBzY2FsZVg7XHJcbiAgICAgICAgdGhpcy5iID0gTWF0aC5zaW4ocm90YXRpb24gKyBza2V3WSkgKiBzY2FsZVg7XHJcbiAgICAgICAgdGhpcy5jID0gLU1hdGguc2luKHJvdGF0aW9uIC0gc2tld1gpICogc2NhbGVZO1xyXG4gICAgICAgIHRoaXMuZCA9IE1hdGguY29zKHJvdGF0aW9uIC0gc2tld1gpICogc2NhbGVZO1xyXG4gICAgICAgIHRoaXMudHggPSB4IC0gKChwaXZvdFggKiB0aGlzLmEpICsgKHBpdm90WSAqIHRoaXMuYykpO1xyXG4gICAgICAgIHRoaXMudHkgPSB5IC0gKChwaXZvdFggKiB0aGlzLmIpICsgKHBpdm90WSAqIHRoaXMuZCkpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBQcmVwZW5kcyB0aGUgZ2l2ZW4gTWF0cml4IHRvIHRoaXMgTWF0cml4LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7UElYSS5NYXRyaXh9IG1hdHJpeCAtIFRoZSBtYXRyaXggdG8gcHJlcGVuZFxyXG4gICAgICogQHJldHVybiB7UElYSS5NYXRyaXh9IFRoaXMgbWF0cml4LiBHb29kIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHMuXHJcbiAgICAgKi9cclxuICAgIHByZXBlbmQobWF0cml4KSB7XHJcbiAgICAgICAgdmFyIHR4MSA9IHRoaXMudHg7XHJcbiAgICAgICAgaWYgKG1hdHJpeC5hICE9PSAxIHx8IG1hdHJpeC5iICE9PSAwIHx8IG1hdHJpeC5jICE9PSAwIHx8IG1hdHJpeC5kICE9PSAxKSB7XHJcbiAgICAgICAgICAgIHZhciBhMSA9IHRoaXMuYTtcclxuICAgICAgICAgICAgdmFyIGMxID0gdGhpcy5jO1xyXG4gICAgICAgICAgICB0aGlzLmEgPSAoYTEgKiBtYXRyaXguYSkgKyAodGhpcy5iICogbWF0cml4LmMpO1xyXG4gICAgICAgICAgICB0aGlzLmIgPSAoYTEgKiBtYXRyaXguYikgKyAodGhpcy5iICogbWF0cml4LmQpO1xyXG4gICAgICAgICAgICB0aGlzLmMgPSAoYzEgKiBtYXRyaXguYSkgKyAodGhpcy5kICogbWF0cml4LmMpO1xyXG4gICAgICAgICAgICB0aGlzLmQgPSAoYzEgKiBtYXRyaXguYikgKyAodGhpcy5kICogbWF0cml4LmQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnR4ID0gKHR4MSAqIG1hdHJpeC5hKSArICh0aGlzLnR5ICogbWF0cml4LmMpICsgbWF0cml4LnR4O1xyXG4gICAgICAgIHRoaXMudHkgPSAodHgxICogbWF0cml4LmIpICsgKHRoaXMudHkgKiBtYXRyaXguZCkgKyBtYXRyaXgudHk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIERlY29tcG9zZXMgdGhlIG1hdHJpeCAoeCwgeSwgc2NhbGVYLCBzY2FsZVksIGFuZCByb3RhdGlvbikgYW5kIHNldHMgdGhlIHByb3BlcnRpZXMgb24gdG8gYSB0cmFuc2Zvcm0uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtQSVhJLlRyYW5zZm9ybX0gdHJhbnNmb3JtIC0gVGhlIHRyYW5zZm9ybSB0byBhcHBseSB0aGUgcHJvcGVydGllcyB0by5cclxuICAgICAqIEByZXR1cm4ge1BJWEkuVHJhbnNmb3JtfSBUaGUgdHJhbnNmb3JtIHdpdGggdGhlIG5ld2x5IGFwcGxpZWQgcHJvcGVydGllc1xyXG4gICAgICovXHJcbiAgICBkZWNvbXBvc2UodHJhbnNmb3JtKSB7XHJcbiAgICAgICAgLy8gc29ydCBvdXQgcm90YXRpb24gLyBza2V3Li5cclxuICAgICAgICB2YXIgYSA9IHRoaXMuYTtcclxuICAgICAgICB2YXIgYiA9IHRoaXMuYjtcclxuICAgICAgICB2YXIgYyA9IHRoaXMuYztcclxuICAgICAgICB2YXIgZCA9IHRoaXMuZDtcclxuICAgICAgICB2YXIgc2tld1ggPSAtTWF0aC5hdGFuMigtYywgZCk7XHJcbiAgICAgICAgdmFyIHNrZXdZID0gTWF0aC5hdGFuMihiLCBhKTtcclxuICAgICAgICB2YXIgZGVsdGEgPSBNYXRoLmFicyhza2V3WCArIHNrZXdZKTtcclxuICAgICAgICBpZiAoZGVsdGEgPCAwLjAwMDAxIHx8IE1hdGguYWJzKE1hdGhTZXR0aW5nc18xLk1hdGhTZXR0aW5ncy5QSV8yIC0gZGVsdGEpIDwgMC4wMDAwMSkge1xyXG4gICAgICAgICAgICB0cmFuc2Zvcm0ucm90YXRpb24gPSBza2V3WTtcclxuICAgICAgICAgICAgdHJhbnNmb3JtLnNrZXcueCA9IHRyYW5zZm9ybS5za2V3LnkgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdHJhbnNmb3JtLnJvdGF0aW9uID0gMDtcclxuICAgICAgICAgICAgdHJhbnNmb3JtLnNrZXcueCA9IHNrZXdYO1xyXG4gICAgICAgICAgICB0cmFuc2Zvcm0uc2tldy55ID0gc2tld1k7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIG5leHQgc2V0IHNjYWxlXHJcbiAgICAgICAgdHJhbnNmb3JtLnNjYWxlLnggPSBNYXRoLnNxcnQoKGEgKiBhKSArIChiICogYikpO1xyXG4gICAgICAgIHRyYW5zZm9ybS5zY2FsZS55ID0gTWF0aC5zcXJ0KChjICogYykgKyAoZCAqIGQpKTtcclxuICAgICAgICAvLyBuZXh0IHNldCBwb3NpdGlvblxyXG4gICAgICAgIHRyYW5zZm9ybS5wb3NpdGlvbi54ID0gdGhpcy50eDtcclxuICAgICAgICB0cmFuc2Zvcm0ucG9zaXRpb24ueSA9IHRoaXMudHk7XHJcbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogSW52ZXJ0cyB0aGlzIG1hdHJpeFxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4ge1BJWEkuTWF0cml4fSBUaGlzIG1hdHJpeC4gR29vZCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzLlxyXG4gICAgICovXHJcbiAgICBpbnZlcnQoKSB7XHJcbiAgICAgICAgdmFyIGExID0gdGhpcy5hO1xyXG4gICAgICAgIHZhciBiMSA9IHRoaXMuYjtcclxuICAgICAgICB2YXIgYzEgPSB0aGlzLmM7XHJcbiAgICAgICAgdmFyIGQxID0gdGhpcy5kO1xyXG4gICAgICAgIHZhciB0eDEgPSB0aGlzLnR4O1xyXG4gICAgICAgIHZhciBuID0gKGExICogZDEpIC0gKGIxICogYzEpO1xyXG4gICAgICAgIHRoaXMuYSA9IGQxIC8gbjtcclxuICAgICAgICB0aGlzLmIgPSAtYjEgLyBuO1xyXG4gICAgICAgIHRoaXMuYyA9IC1jMSAvIG47XHJcbiAgICAgICAgdGhpcy5kID0gYTEgLyBuO1xyXG4gICAgICAgIHRoaXMudHggPSAoKGMxICogdGhpcy50eSkgLSAoZDEgKiB0eDEpKSAvIG47XHJcbiAgICAgICAgdGhpcy50eSA9IC0oKGExICogdGhpcy50eSkgLSAoYjEgKiB0eDEpKSAvIG47XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFJlc2V0cyB0aGlzIE1hdHJpeCB0byBhbiBpZGVudGl0eSAoZGVmYXVsdCkgbWF0cml4LlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4ge1BJWEkuTWF0cml4fSBUaGlzIG1hdHJpeC4gR29vZCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzLlxyXG4gICAgICovXHJcbiAgICBpZGVudGl0eSgpIHtcclxuICAgICAgICB0aGlzLmEgPSAxO1xyXG4gICAgICAgIHRoaXMuYiA9IDA7XHJcbiAgICAgICAgdGhpcy5jID0gMDtcclxuICAgICAgICB0aGlzLmQgPSAxO1xyXG4gICAgICAgIHRoaXMudHggPSAwO1xyXG4gICAgICAgIHRoaXMudHkgPSAwO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IE1hdHJpeCBvYmplY3Qgd2l0aCB0aGUgc2FtZSB2YWx1ZXMgYXMgdGhpcyBvbmUuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiB7UElYSS5NYXRyaXh9IEEgY29weSBvZiB0aGlzIG1hdHJpeC4gR29vZCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzLlxyXG4gICAgICovXHJcbiAgICBjbG9uZSgpIHtcclxuICAgICAgICB2YXIgbWF0cml4ID0gbmV3IE1hdHJpeCgpO1xyXG4gICAgICAgIG1hdHJpeC5hID0gdGhpcy5hO1xyXG4gICAgICAgIG1hdHJpeC5iID0gdGhpcy5iO1xyXG4gICAgICAgIG1hdHJpeC5jID0gdGhpcy5jO1xyXG4gICAgICAgIG1hdHJpeC5kID0gdGhpcy5kO1xyXG4gICAgICAgIG1hdHJpeC50eCA9IHRoaXMudHg7XHJcbiAgICAgICAgbWF0cml4LnR5ID0gdGhpcy50eTtcclxuICAgICAgICByZXR1cm4gbWF0cml4O1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDaGFuZ2VzIHRoZSB2YWx1ZXMgb2YgdGhlIGdpdmVuIG1hdHJpeCB0byBiZSB0aGUgc2FtZSBhcyB0aGUgb25lcyBpbiB0aGlzIG1hdHJpeFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7UElYSS5NYXRyaXh9IG1hdHJpeCAtIFRoZSBtYXRyaXggdG8gY29weSB0by5cclxuICAgICAqIEByZXR1cm4ge1BJWEkuTWF0cml4fSBUaGUgbWF0cml4IGdpdmVuIGluIHBhcmFtZXRlciB3aXRoIGl0cyB2YWx1ZXMgdXBkYXRlZC5cclxuICAgICAqL1xyXG4gICAgY29weVRvKG1hdHJpeCkge1xyXG4gICAgICAgIG1hdHJpeC5hID0gdGhpcy5hO1xyXG4gICAgICAgIG1hdHJpeC5iID0gdGhpcy5iO1xyXG4gICAgICAgIG1hdHJpeC5jID0gdGhpcy5jO1xyXG4gICAgICAgIG1hdHJpeC5kID0gdGhpcy5kO1xyXG4gICAgICAgIG1hdHJpeC50eCA9IHRoaXMudHg7XHJcbiAgICAgICAgbWF0cml4LnR5ID0gdGhpcy50eTtcclxuICAgICAgICByZXR1cm4gbWF0cml4O1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDaGFuZ2VzIHRoZSB2YWx1ZXMgb2YgdGhlIG1hdHJpeCB0byBiZSB0aGUgc2FtZSBhcyB0aGUgb25lcyBpbiBnaXZlbiBtYXRyaXhcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1BJWEkuTWF0cml4fSBtYXRyaXggLSBUaGUgbWF0cml4IHRvIGNvcHkgZnJvbS5cclxuICAgICAqIEByZXR1cm4ge1BJWEkuTWF0cml4fSB0aGlzXHJcbiAgICAgKi9cclxuICAgIGNvcHlGcm9tKG1hdHJpeCkge1xyXG4gICAgICAgIHRoaXMuYSA9IG1hdHJpeC5hO1xyXG4gICAgICAgIHRoaXMuYiA9IG1hdHJpeC5iO1xyXG4gICAgICAgIHRoaXMuYyA9IG1hdHJpeC5jO1xyXG4gICAgICAgIHRoaXMuZCA9IG1hdHJpeC5kO1xyXG4gICAgICAgIHRoaXMudHggPSBtYXRyaXgudHg7XHJcbiAgICAgICAgdGhpcy50eSA9IG1hdHJpeC50eTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQSBkZWZhdWx0IChpZGVudGl0eSkgbWF0cml4XHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQGNvbnN0XHJcbiAgICAgKiBAbWVtYmVyIHtQSVhJLk1hdHJpeH1cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGdldCBJREVOVElUWSgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IE1hdHJpeCgpO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBIHRlbXAgbWF0cml4XHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQGNvbnN0XHJcbiAgICAgKiBAbWVtYmVyIHtQSVhJLk1hdHJpeH1cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGdldCBURU1QX01BVFJJWCgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IE1hdHJpeCgpO1xyXG4gICAgfVxyXG4gICAgO1xyXG59XHJcbmV4cG9ydHMuTWF0cml4ID0gTWF0cml4O1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBDb250YWluZXJfMSA9IHJlcXVpcmUoXCIuL0NvbnRhaW5lclwiKTtcclxuY29uc3QgU3RhdGVfMSA9IHJlcXVpcmUoXCIuL1N0YXRlXCIpO1xyXG5jb25zdCBQb2x5Z29uXzEgPSByZXF1aXJlKFwiLi9Qb2x5Z29uXCIpO1xyXG5jb25zdCBNZXNoQmF0Y2hVdnNfMSA9IHJlcXVpcmUoXCIuL01lc2hCYXRjaFV2c1wiKTtcclxuY29uc3QgUG9pbnRfMSA9IHJlcXVpcmUoXCIuL1BvaW50XCIpO1xyXG5jb25zdCBEcmF3TW9kZVNldHRpbmdzXzEgPSByZXF1aXJlKFwiLi9EcmF3TW9kZVNldHRpbmdzXCIpO1xyXG5jb25zdCBCbGVuZE1vZGVzU2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL0JsZW5kTW9kZXNTZXR0aW5nc1wiKTtcclxuY29uc3QgRGlzcGxheVNldHRpbmdzXzEgPSByZXF1aXJlKFwiLi9EaXNwbGF5U2V0dGluZ3NcIik7XHJcbmNsYXNzIE1lc2ggZXh0ZW5kcyBDb250YWluZXJfMS5Db250YWluZXIge1xyXG4gICAgY29uc3RydWN0b3IoZ2VvbWV0cnksIHNoYWRlciwgc3RhdGUgPSBudWxsLCBkcmF3TW9kZSA9IERyYXdNb2RlU2V0dGluZ3NfMS5EcmF3TW9kZVNldHRpbmdzLkRSQVdfTU9ERVMuVFJJQU5HTEVTKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLmludGVyYWN0aXZlID0gZmFsc2U7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSW5jbHVkZXMgdmVydGV4IHBvc2l0aW9ucywgZmFjZSBpbmRpY2VzLCBub3JtYWxzLCBjb2xvcnMsIFVWcywgYW5kXHJcbiAgICAgICAgICogY3VzdG9tIGF0dHJpYnV0ZXMgd2l0aGluIGJ1ZmZlcnMsIHJlZHVjaW5nIHRoZSBjb3N0IG9mIHBhc3NpbmcgYWxsXHJcbiAgICAgICAgICogdGhpcyBkYXRhIHRvIHRoZSBHUFUuIENhbiBiZSBzaGFyZWQgYmV0d2VlbiBtdWx0aXBsZSBNZXNoIG9iamVjdHMuXHJcbiAgICAgICAgICogQG1lbWJlciB7UElYSS5HZW9tZXRyeX1cclxuICAgICAgICAgKiBAcmVhZG9ubHlcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmdlb21ldHJ5ID0gZ2VvbWV0cnk7XHJcbiAgICAgICAgZ2VvbWV0cnkucmVmQ291bnQrKztcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXByZXNlbnRzIHRoZSB2ZXJ0ZXggYW5kIGZyYWdtZW50IHNoYWRlcnMgdGhhdCBwcm9jZXNzZXMgdGhlIGdlb21ldHJ5IGFuZCBydW5zIG9uIHRoZSBHUFUuXHJcbiAgICAgICAgICogQ2FuIGJlIHNoYXJlZCBiZXR3ZWVuIG11bHRpcGxlIE1lc2ggb2JqZWN0cy5cclxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLlNoYWRlcnxQSVhJLk1lc2hNYXRlcmlhbH1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnNoYWRlciA9IHNoYWRlcjtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZXByZXNlbnRzIHRoZSBXZWJHTCBzdGF0ZSB0aGUgTWVzaCByZXF1aXJlZCB0byByZW5kZXIsIGV4Y2x1ZGVzIHNoYWRlciBhbmQgZ2VvbWV0cnkuIEUuZy4sXHJcbiAgICAgICAgICogYmxlbmQgbW9kZSwgY3VsbGluZywgZGVwdGggdGVzdGluZywgZGlyZWN0aW9uIG9mIHJlbmRlcmluZyB0cmlhbmdsZXMsIGJhY2tmYWNlLCBldGMuXHJcbiAgICAgICAgICogQG1lbWJlciB7UElYSS5TdGF0ZX1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnN0YXRlID0gc3RhdGUgfHwgU3RhdGVfMS5TdGF0ZS5mb3IyZCgpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSB3YXkgdGhlIE1lc2ggc2hvdWxkIGJlIGRyYXduLCBjYW4gYmUgYW55IG9mIHRoZSB7QGxpbmsgUElYSS5EUkFXX01PREVTfSBjb25zdGFudHMuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgICAgICogQHNlZSBQSVhJLkRSQVdfTU9ERVNcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmRyYXdNb2RlID0gZHJhd01vZGU7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVHlwaWNhbGx5IHRoZSBpbmRleCBvZiB0aGUgSW5kZXhCdWZmZXIgd2hlcmUgdG8gc3RhcnQgZHJhd2luZy5cclxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgICAgICogQGRlZmF1bHQgMFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuc3RhcnQgPSAwO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEhvdyBtdWNoIG9mIHRoZSBnZW9tZXRyeSB0byBkcmF3LCBieSBkZWZhdWx0IGAwYCByZW5kZXJzIGV2ZXJ5dGhpbmcuXHJcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICAgICAqIEBkZWZhdWx0IDBcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnNpemUgPSAwO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIHRoZWFzZSBhcmUgdXNlZCBhcyBlYXN5IGFjY2VzcyBmb3IgYmF0Y2hpbmdcclxuICAgICAgICAgKiBAbWVtYmVyIHtGbG9hdDMyQXJyYXl9XHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnV2cyA9IG51bGw7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogdGhlYXNlIGFyZSB1c2VkIGFzIGVhc3kgYWNjZXNzIGZvciBiYXRjaGluZ1xyXG4gICAgICAgICAqIEBtZW1iZXIge1VpbnQxNkFycmF5fVxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5pbmRpY2VzID0gbnVsbDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiB0aGlzIGlzIHRoZSBjYWNoaW5nIGxheWVyIHVzZWQgYnkgdGhlIGJhdGNoZXJcclxuICAgICAgICAgKiBAbWVtYmVyIHtGbG9hdDMyQXJyYXl9XHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnZlcnRleERhdGEgPSBuZXcgRmxvYXQzMkFycmF5KDEpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIElmIGdlb21ldHJ5IGlzIGNoYW5nZWQgdXNlZCB0byBkZWNpZGUgdG8gcmUtdHJhbnNmb3JtXHJcbiAgICAgICAgICogdGhlIHZlcnRleERhdGEuXHJcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy52ZXJ0ZXhEaXJ0eSA9IDA7XHJcbiAgICAgICAgdGhpcy5fdHJhbnNmb3JtSUQgPSAtMTtcclxuICAgICAgICAvLyBJbmhlcml0ZWQgZnJvbSBEaXNwbGF5TW9kZSwgc2V0IGRlZmF1bHRzXHJcbiAgICAgICAgdGhpcy50aW50ID0gMHhGRkZGRkY7XHJcbiAgICAgICAgdGhpcy5ibGVuZE1vZGUgPSBCbGVuZE1vZGVzU2V0dGluZ3NfMS5CbGVuZE1vZGVzU2V0dGluZ3MuQkxFTkRfTU9ERVMuTk9STUFMO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEludGVybmFsIHJvdW5kUGl4ZWxzIGZpZWxkXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAbWVtYmVyIHtib29sZWFufVxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5fcm91bmRQaXhlbHMgPSBEaXNwbGF5U2V0dGluZ3NfMS5EaXNwbGF5U2V0dGluZ3MuUk9VTkRfUElYRUxTO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEJhdGNoZWQgVVYncyBhcmUgY2FjaGVkIGZvciBhdGxhcyB0ZXh0dXJlc1xyXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuTWVzaEJhdGNoVXZzfVxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5iYXRjaFV2cyA9IG51bGw7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRvIGNoYW5nZSBtZXNoIHV2J3MsIGNoYW5nZSBpdHMgdXZCdWZmZXIgZGF0YSBhbmQgaW5jcmVtZW50IGl0cyBfdXBkYXRlSUQuXHJcbiAgICAgKiBAbWVtYmVyIHtQSVhJLkJ1ZmZlcn1cclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICovXHJcbiAgICBnZXQgdXZCdWZmZXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2VvbWV0cnkuYnVmZmVyc1sxXS5kYXRhO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUbyBjaGFuZ2UgbWVzaCB2ZXJ0aWNlcywgY2hhbmdlIGl0cyB1dkJ1ZmZlciBkYXRhIGFuZCBpbmNyZW1lbnQgaXRzIF91cGRhdGVJRC5cclxuICAgICAqIEluY3JlbWVudGluZyBfdXBkYXRlSUQgaXMgb3B0aW9uYWwgYmVjYXVzZSBtb3N0IG9mIE1lc2ggb2JqZWN0cyBkbyBpdCBhbnl3YXkuXHJcbiAgICAgKiBAbWVtYmVyIHtQSVhJLkJ1ZmZlcn1cclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICovXHJcbiAgICBnZXQgdmVydGljZXNCdWZmZXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2VvbWV0cnkuYnVmZmVyc1swXS5kYXRhO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBbGlhcyBmb3Ige0BsaW5rIFBJWEkuTWVzaCNzaGFkZXJ9LlxyXG4gICAgICogQG1lbWJlciB7UElYSS5TaGFkZXJ8UElYSS5NZXNoTWF0ZXJpYWx9XHJcbiAgICAgKi9cclxuICAgIHNldCBtYXRlcmlhbCh2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuc2hhZGVyID0gdmFsdWU7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICBnZXQgbWF0ZXJpYWwoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2hhZGVyO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgYmxlbmQgbW9kZSB0byBiZSBhcHBsaWVkIHRvIHRoZSBNZXNoLiBBcHBseSBhIHZhbHVlIG9mXHJcbiAgICAgKiBgUElYSS5CTEVORF9NT0RFUy5OT1JNQUxgIHRvIHJlc2V0IHRoZSBibGVuZCBtb2RlLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAqIEBkZWZhdWx0IFBJWEkuQkxFTkRfTU9ERVMuTk9STUFMO1xyXG4gICAgICogQHNlZSBQSVhJLkJMRU5EX01PREVTXHJcbiAgICAgKi9cclxuICAgIHNldCBibGVuZE1vZGUodmFsdWUpIHtcclxuICAgICAgICB0aGlzLnN0YXRlLmJsZW5kTW9kZSA9IHZhbHVlO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgZ2V0IGJsZW5kTW9kZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5ibGVuZE1vZGU7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIElmIHRydWUgUGl4aUpTIHdpbGwgTWF0aC5mbG9vcigpIHgveSB2YWx1ZXMgd2hlbiByZW5kZXJpbmcsIHN0b3BwaW5nIHBpeGVsIGludGVycG9sYXRpb24uXHJcbiAgICAgKiBBZHZhbnRhZ2VzIGNhbiBpbmNsdWRlIHNoYXJwZXIgaW1hZ2UgcXVhbGl0eSAobGlrZSB0ZXh0KSBhbmQgZmFzdGVyIHJlbmRlcmluZyBvbiBjYW52YXMuXHJcbiAgICAgKiBUaGUgbWFpbiBkaXNhZHZhbnRhZ2UgaXMgbW92ZW1lbnQgb2Ygb2JqZWN0cyBtYXkgYXBwZWFyIGxlc3Mgc21vb3RoLlxyXG4gICAgICogVG8gc2V0IHRoZSBnbG9iYWwgZGVmYXVsdCwgY2hhbmdlIHtAbGluayBQSVhJLnNldHRpbmdzLlJPVU5EX1BJWEVMU31cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtib29sZWFufVxyXG4gICAgICogQGRlZmF1bHQgZmFsc2VcclxuICAgICAqL1xyXG4gICAgc2V0IHJvdW5kUGl4ZWxzKHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3JvdW5kUGl4ZWxzICE9PSB2YWx1ZSkge1xyXG4gICAgICAgICAgICB0aGlzLl90cmFuc2Zvcm1JRCA9IC0xO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9yb3VuZFBpeGVscyA9IHZhbHVlO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgZ2V0IHJvdW5kUGl4ZWxzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9yb3VuZFBpeGVscztcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIG11bHRpcGx5IHRpbnQgYXBwbGllZCB0byB0aGUgTWVzaC4gVGhpcyBpcyBhIGhleCB2YWx1ZS4gQSB2YWx1ZSBvZlxyXG4gICAgICogYDB4RkZGRkZGYCB3aWxsIHJlbW92ZSBhbnkgdGludCBlZmZlY3QuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICogQGRlZmF1bHQgMHhGRkZGRkZcclxuICAgICAqL1xyXG4gICAgZ2V0IHRpbnQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2hhZGVyLnRpbnQ7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICBzZXQgdGludCh2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuc2hhZGVyLnRpbnQgPSB2YWx1ZTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIHRleHR1cmUgdGhhdCB0aGUgTWVzaCB1c2VzLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge1BJWEkuVGV4dHVyZX1cclxuICAgICAqL1xyXG4gICAgZ2V0IHRleHR1cmUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2hhZGVyLnRleHR1cmU7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICBzZXQgdGV4dHVyZSh2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuc2hhZGVyLnRleHR1cmUgPSB2YWx1ZTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogU3RhbmRhcmQgcmVuZGVyZXIgZHJhdy5cclxuICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAqL1xyXG4gICAgX3JlbmRlcihyZW5kZXJlcikge1xyXG4gICAgICAgIC8vIHNldCBwcm9wZXJ0aWVzIGZvciBiYXRjaGluZy4uXHJcbiAgICAgICAgLy8gVE9ETyBjb3VsZCB1c2UgYSBkaWZmZXJlbnQgd2F5IHRvIGdyYWIgdmVydHM/XHJcbiAgICAgICAgdmFyIHZlcnRpY2VzID0gdGhpcy5nZW9tZXRyeS5idWZmZXJzWzBdLmRhdGE7XHJcbiAgICAgICAgLy8gVE9ETyBiZW5jaG1hcmsgY2hlY2sgZm9yIGF0dHJpYnV0ZSBzaXplLi5cclxuICAgICAgICBpZiAodGhpcy5zaGFkZXIuYmF0Y2hhYmxlICYmIHRoaXMuZHJhd01vZGUgPT09IERyYXdNb2RlU2V0dGluZ3NfMS5EcmF3TW9kZVNldHRpbmdzLkRSQVdfTU9ERVMuVFJJQU5HTEVTICYmIHZlcnRpY2VzLmxlbmd0aCA8IE1lc2guQkFUQ0hBQkxFX1NJWkUgKiAyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlclRvQmF0Y2gocmVuZGVyZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5fcmVuZGVyRGVmYXVsdChyZW5kZXJlcik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBTdGFuZGFyZCBub24tYmF0Y2hpbmcgd2F5IG9mIHJlbmRlcmluZy5cclxuICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAqIEBwYXJhbSB7UElYSS5SZW5kZXJlcn0gcmVuZGVyZXIgLSBJbnN0YW5jZSB0byByZW5kZXJlci5cclxuICAgICAqL1xyXG4gICAgX3JlbmRlckRlZmF1bHQocmVuZGVyZXIpIHtcclxuICAgICAgICB2YXIgc2hhZGVyID0gdGhpcy5zaGFkZXI7XHJcbiAgICAgICAgc2hhZGVyLmFscGhhID0gdGhpcy53b3JsZEFscGhhO1xyXG4gICAgICAgIGlmIChzaGFkZXIudXBkYXRlKSB7XHJcbiAgICAgICAgICAgIHNoYWRlci51cGRhdGUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVuZGVyZXIuYmF0Y2guZmx1c2goKTtcclxuICAgICAgICBpZiAoc2hhZGVyLnByb2dyYW0udW5pZm9ybURhdGEudHJhbnNsYXRpb25NYXRyaXgpIHtcclxuICAgICAgICAgICAgc2hhZGVyLnVuaWZvcm1zLnRyYW5zbGF0aW9uTWF0cml4ID0gdGhpcy50cmFuc2Zvcm0ud29ybGRUcmFuc2Zvcm0udG9BcnJheSh0cnVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gYmluZCBhbmQgc3luYyB1bmlmb3Jtcy4uXHJcbiAgICAgICAgcmVuZGVyZXIuc2hhZGVyLmJpbmQoc2hhZGVyKTtcclxuICAgICAgICAvLyBzZXQgc3RhdGUuLlxyXG4gICAgICAgIHJlbmRlcmVyLnN0YXRlLnNldFN0YXRlKHRoaXMuc3RhdGUpO1xyXG4gICAgICAgIC8vIGJpbmQgdGhlIGdlb21ldHJ5Li4uXHJcbiAgICAgICAgcmVuZGVyZXIuZ2VvbWV0cnkuYmluZCh0aGlzLmdlb21ldHJ5LCBzaGFkZXIpO1xyXG4gICAgICAgIC8vIHRoZW4gcmVuZGVyIGl0XHJcbiAgICAgICAgcmVuZGVyZXIuZ2VvbWV0cnkuZHJhdyh0aGlzLmRyYXdNb2RlLCB0aGlzLnNpemUsIHRoaXMuc3RhcnQsIHRoaXMuZ2VvbWV0cnkuaW5zdGFuY2VDb3VudCk7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFJlbmRlcmluZyBieSB1c2luZyB0aGUgQmF0Y2ggc3lzdGVtLlxyXG4gICAgICogQHByb3RlY3RlZFxyXG4gICAgICogQHBhcmFtIHtQSVhJLlJlbmRlcmVyfSByZW5kZXJlciAtIEluc3RhbmNlIHRvIHJlbmRlcmVyLlxyXG4gICAgICovXHJcbiAgICBfcmVuZGVyVG9CYXRjaChyZW5kZXJlcikge1xyXG4gICAgICAgIHZhciBnZW9tZXRyeSA9IHRoaXMuZ2VvbWV0cnk7XHJcbiAgICAgICAgaWYgKHRoaXMuc2hhZGVyLnV2TWF0cml4KSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2hhZGVyLnV2TWF0cml4LnVwZGF0ZSgpO1xyXG4gICAgICAgICAgICB0aGlzLmNhbGN1bGF0ZVV2cygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBzZXQgcHJvcGVydGllcyBmb3IgYmF0Y2hpbmcuLlxyXG4gICAgICAgIHRoaXMuY2FsY3VsYXRlVmVydGljZXMoKTtcclxuICAgICAgICB0aGlzLmluZGljZXMgPSBnZW9tZXRyeS5pbmRleEJ1ZmZlci5kYXRhO1xyXG4gICAgICAgIHRoaXMuX3RpbnRSR0IgPSB0aGlzLnNoYWRlci5fdGludFJHQjtcclxuICAgICAgICB0aGlzLl90ZXh0dXJlID0gdGhpcy5zaGFkZXIudGV4dHVyZTtcclxuICAgICAgICB2YXIgcGx1Z2luTmFtZSA9IHRoaXMubWF0ZXJpYWwucGx1Z2luTmFtZTtcclxuICAgICAgICByZW5kZXJlci5iYXRjaC5zZXRPYmplY3RSZW5kZXJlcihyZW5kZXJlci5wbHVnaW5zW3BsdWdpbk5hbWVdKTtcclxuICAgICAgICByZW5kZXJlci5wbHVnaW5zW3BsdWdpbk5hbWVdLnJlbmRlcih0aGlzKTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyB2ZXJ0ZXhEYXRhIGZpZWxkIGJhc2VkIG9uIHRyYW5zZm9ybSBhbmQgdmVydGljZXNcclxuICAgICAqL1xyXG4gICAgY2FsY3VsYXRlVmVydGljZXMoKSB7XHJcbiAgICAgICAgdmFyIGdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeTtcclxuICAgICAgICB2YXIgdmVydGljZXMgPSBnZW9tZXRyeS5idWZmZXJzWzBdLmRhdGE7XHJcbiAgICAgICAgaWYgKGdlb21ldHJ5LnZlcnRleERpcnR5SWQgPT09IHRoaXMudmVydGV4RGlydHkgJiYgdGhpcy5fdHJhbnNmb3JtSUQgPT09IHRoaXMudHJhbnNmb3JtLl93b3JsZElEKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fdHJhbnNmb3JtSUQgPSB0aGlzLnRyYW5zZm9ybS5fd29ybGRJRDtcclxuICAgICAgICBpZiAodGhpcy52ZXJ0ZXhEYXRhLmxlbmd0aCAhPT0gdmVydGljZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHRoaXMudmVydGV4RGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkodmVydGljZXMubGVuZ3RoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHd0ID0gdGhpcy50cmFuc2Zvcm0ud29ybGRUcmFuc2Zvcm07XHJcbiAgICAgICAgdmFyIGEgPSB3dC5hO1xyXG4gICAgICAgIHZhciBiID0gd3QuYjtcclxuICAgICAgICB2YXIgYyA9IHd0LmM7XHJcbiAgICAgICAgdmFyIGQgPSB3dC5kO1xyXG4gICAgICAgIHZhciB0eCA9IHd0LnR4O1xyXG4gICAgICAgIHZhciB0eSA9IHd0LnR5O1xyXG4gICAgICAgIHZhciB2ZXJ0ZXhEYXRhID0gdGhpcy52ZXJ0ZXhEYXRhO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmVydGV4RGF0YS5sZW5ndGggLyAyOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIHggPSB2ZXJ0aWNlc1soaSAqIDIpXTtcclxuICAgICAgICAgICAgdmFyIHkgPSB2ZXJ0aWNlc1soaSAqIDIpICsgMV07XHJcbiAgICAgICAgICAgIHZlcnRleERhdGFbKGkgKiAyKV0gPSAoYSAqIHgpICsgKGMgKiB5KSArIHR4O1xyXG4gICAgICAgICAgICB2ZXJ0ZXhEYXRhWyhpICogMikgKyAxXSA9IChiICogeCkgKyAoZCAqIHkpICsgdHk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLl9yb3VuZFBpeGVscykge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCB2ZXJ0ZXhEYXRhLmxlbmd0aDsgaSQxKyspIHtcclxuICAgICAgICAgICAgICAgIHZlcnRleERhdGFbaSQxXSA9IE1hdGgucm91bmQodmVydGV4RGF0YVtpJDFdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnZlcnRleERpcnR5ID0gZ2VvbWV0cnkudmVydGV4RGlydHlJZDtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyB1diBmaWVsZCBiYXNlZCBvbiBmcm9tIGdlb21ldHJ5IHV2J3Mgb3IgYmF0Y2hVdnNcclxuICAgICAqL1xyXG4gICAgY2FsY3VsYXRlVXZzKCkge1xyXG4gICAgICAgIHZhciBnZW9tVXZzID0gdGhpcy5nZW9tZXRyeS5idWZmZXJzWzFdO1xyXG4gICAgICAgIGlmICghdGhpcy5zaGFkZXIudXZNYXRyaXguaXNTaW1wbGUpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmJhdGNoVXZzKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmJhdGNoVXZzID0gbmV3IE1lc2hCYXRjaFV2c18xLk1lc2hCYXRjaFV2cyhnZW9tVXZzLCB0aGlzLnNoYWRlci51dk1hdHJpeCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5iYXRjaFV2cy51cGRhdGUoKTtcclxuICAgICAgICAgICAgdGhpcy51dnMgPSB0aGlzLmJhdGNoVXZzLmRhdGE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnV2cyA9IGdlb21VdnMuZGF0YTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgdGhlIGJvdW5kcyBvZiB0aGUgbWVzaCBhcyBhIHJlY3RhbmdsZS4gVGhlIGJvdW5kcyBjYWxjdWxhdGlvbiB0YWtlcyB0aGUgd29ybGRUcmFuc2Zvcm0gaW50byBhY2NvdW50LlxyXG4gICAgICogdGhlcmUgbXVzdCBiZSBhIGFWZXJ0ZXhQb3NpdGlvbiBhdHRyaWJ1dGUgcHJlc2VudCBpbiB0aGUgZ2VvbWV0cnkgZm9yIGJvdW5kcyB0byBiZSBjYWxjdWxhdGVkIGNvcnJlY3RseS5cclxuICAgICAqXHJcbiAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgKi9cclxuICAgIF9jYWxjdWxhdGVCb3VuZHMoKSB7XHJcbiAgICAgICAgdGhpcy5jYWxjdWxhdGVWZXJ0aWNlcygpO1xyXG4gICAgICAgIHRoaXMuX2JvdW5kcy5hZGRWZXJ0ZXhEYXRhKHRoaXMudmVydGV4RGF0YSwgMCwgdGhpcy52ZXJ0ZXhEYXRhLmxlbmd0aCk7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFRlc3RzIGlmIGEgcG9pbnQgaXMgaW5zaWRlIHRoaXMgbWVzaC4gV29ya3Mgb25seSBmb3IgUElYSS5EUkFXX01PREVTLlRSSUFOR0xFUy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1BJWEkuUG9pbnR9IHBvaW50IHRoZSBwb2ludCB0byB0ZXN0XHJcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSB0aGUgcmVzdWx0IG9mIHRoZSB0ZXN0XHJcbiAgICAgKi9cclxuICAgIGNvbnRhaW5zUG9pbnQocG9pbnQpIHtcclxuICAgICAgICBpZiAoIXRoaXMuaW50ZXJhY3RpdmUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXRoaXMuZ2V0Qm91bmRzKCkuY29udGFpbnMocG9pbnQueCwgcG9pbnQueSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLndvcmxkVHJhbnNmb3JtLmFwcGx5SW52ZXJzZShwb2ludCwgTWVzaC50ZW1wUG9pbnQkMik7XHJcbiAgICAgICAgdmFyIHZlcnRpY2VzID0gdGhpcy5nZW9tZXRyeS5nZXRBdHRyaWJ1dGUoJ2FWZXJ0ZXhQb3NpdGlvbicpLmRhdGE7XHJcbiAgICAgICAgdmFyIHBvaW50cyA9IE1lc2gudGVtcFBvbHlnb24ucG9pbnRzO1xyXG4gICAgICAgIHZhciBpbmRpY2VzID0gdGhpcy5nZW9tZXRyeS5nZXRJbmRleCgpLmRhdGE7XHJcbiAgICAgICAgdmFyIGxlbiA9IGluZGljZXMubGVuZ3RoO1xyXG4gICAgICAgIHZhciBzdGVwID0gdGhpcy5kcmF3TW9kZSA9PT0gNCA/IDMgOiAxO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpICsgMiA8IGxlbjsgaSArPSBzdGVwKSB7XHJcbiAgICAgICAgICAgIHZhciBpbmQwID0gaW5kaWNlc1tpXSAqIDI7XHJcbiAgICAgICAgICAgIHZhciBpbmQxID0gaW5kaWNlc1tpICsgMV0gKiAyO1xyXG4gICAgICAgICAgICB2YXIgaW5kMiA9IGluZGljZXNbaSArIDJdICogMjtcclxuICAgICAgICAgICAgcG9pbnRzWzBdID0gdmVydGljZXNbaW5kMF07XHJcbiAgICAgICAgICAgIHBvaW50c1sxXSA9IHZlcnRpY2VzW2luZDAgKyAxXTtcclxuICAgICAgICAgICAgcG9pbnRzWzJdID0gdmVydGljZXNbaW5kMV07XHJcbiAgICAgICAgICAgIHBvaW50c1szXSA9IHZlcnRpY2VzW2luZDEgKyAxXTtcclxuICAgICAgICAgICAgcG9pbnRzWzRdID0gdmVydGljZXNbaW5kMl07XHJcbiAgICAgICAgICAgIHBvaW50c1s1XSA9IHZlcnRpY2VzW2luZDIgKyAxXTtcclxuICAgICAgICAgICAgaWYgKE1lc2gudGVtcFBvbHlnb24uY29udGFpbnMoTWVzaC50ZW1wUG9pbnQkMi54LCBNZXNoLnRlbXBQb2ludCQyLnkpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIERlc3Ryb3lzIHRoZSBNZXNoIG9iamVjdC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdHxib29sZWFufSBbb3B0aW9uc10gLSBPcHRpb25zIHBhcmFtZXRlci4gQSBib29sZWFuIHdpbGwgYWN0IGFzIGlmIGFsbFxyXG4gICAgICogIG9wdGlvbnMgaGF2ZSBiZWVuIHNldCB0byB0aGF0IHZhbHVlXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmNoaWxkcmVuPWZhbHNlXSAtIGlmIHNldCB0byB0cnVlLCBhbGwgdGhlIGNoaWxkcmVuIHdpbGwgaGF2ZVxyXG4gICAgICogIHRoZWlyIGRlc3Ryb3kgbWV0aG9kIGNhbGxlZCBhcyB3ZWxsLiAnb3B0aW9ucycgd2lsbCBiZSBwYXNzZWQgb24gdG8gdGhvc2UgY2FsbHMuXHJcbiAgICAgKi9cclxuICAgIGRlc3Ryb3kob3B0aW9ucykge1xyXG4gICAgICAgIHN1cGVyLmRlc3Ryb3kob3B0aW9ucyk7XHJcbiAgICAgICAgdGhpcy5nZW9tZXRyeS5yZWZDb3VudC0tO1xyXG4gICAgICAgIGlmICh0aGlzLmdlb21ldHJ5LnJlZkNvdW50ID09PSAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZ2VvbWV0cnkuZGlzcG9zZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmdlb21ldHJ5ID0gbnVsbDtcclxuICAgICAgICB0aGlzLnNoYWRlciA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5zdGF0ZSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy51dnMgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuaW5kaWNlcyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy52ZXJ0ZXhEYXRhID0gbnVsbDtcclxuICAgIH1cclxuICAgIDtcclxufVxyXG5NZXNoLnRlbXBQb2x5Z29uID0gbmV3IFBvbHlnb25fMS5Qb2x5Z29uKCk7XHJcbk1lc2gudGVtcFBvaW50JDIgPSBuZXcgUG9pbnRfMS5Qb2ludCgpO1xyXG4vKipcclxuICogVGhlIG1heGltdW0gbnVtYmVyIG9mIHZlcnRpY2VzIHRvIGNvbnNpZGVyIGJhdGNoYWJsZS4gR2VuZXJhbGx5LCB0aGUgY29tcGxleGl0eVxyXG4gKiBvZiB0aGUgZ2VvbWV0cnkuXHJcbiAqIEBtZW1iZXJvZiBQSVhJLk1lc2hcclxuICogQHN0YXRpY1xyXG4gKiBAbWVtYmVyIHtudW1iZXJ9IEJBVENIQUJMRV9TSVpFXHJcbiAqL1xyXG5NZXNoLkJBVENIQUJMRV9TSVpFID0gMTAwO1xyXG5leHBvcnRzLk1lc2ggPSBNZXNoO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jbGFzcyBNZXNoQmF0Y2hVdnMge1xyXG4gICAgY29uc3RydWN0b3IodXZCdWZmZXIsIHV2TWF0cml4KSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBCdWZmZXIgd2l0aCBub3JtYWxpemVkIFVWJ3NcclxuICAgICAgICAgICAgICAgICAqIEBtZW1iZXIge1BJWEkuQnVmZmVyfVxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy51dkJ1ZmZlciA9IHV2QnVmZmVyO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIE1hdGVyaWFsIFVWIG1hdHJpeFxyXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuVGV4dHVyZU1hdHJpeH1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnV2TWF0cml4ID0gdXZNYXRyaXg7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVVYgQnVmZmVyIGRhdGFcclxuICAgICAgICAgKiBAbWVtYmVyIHtGbG9hdDMyQXJyYXl9XHJcbiAgICAgICAgICogQHJlYWRvbmx5XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5kYXRhID0gbnVsbDtcclxuICAgICAgICB0aGlzLl9idWZmZXJVcGRhdGVJZCA9IC0xO1xyXG4gICAgICAgIHRoaXMuX3RleHR1cmVVcGRhdGVJZCA9IC0xO1xyXG4gICAgICAgIHRoaXMuX3VwZGF0ZUlEID0gMDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogdXBkYXRlc1xyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZm9yY2VVcGRhdGUgLSBmb3JjZSB0aGUgdXBkYXRlXHJcbiAgICAgKi9cclxuICAgIHVwZGF0ZShmb3JjZVVwZGF0ZSkge1xyXG4gICAgICAgIGlmICghZm9yY2VVcGRhdGVcclxuICAgICAgICAgICAgJiYgdGhpcy5fYnVmZmVyVXBkYXRlSWQgPT09IHRoaXMudXZCdWZmZXIuX3VwZGF0ZUlEXHJcbiAgICAgICAgICAgICYmIHRoaXMuX3RleHR1cmVVcGRhdGVJZCA9PT0gdGhpcy51dk1hdHJpeC5fdXBkYXRlSUQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9idWZmZXJVcGRhdGVJZCA9IHRoaXMudXZCdWZmZXIuX3VwZGF0ZUlEO1xyXG4gICAgICAgIHRoaXMuX3RleHR1cmVVcGRhdGVJZCA9IHRoaXMudXZNYXRyaXguX3VwZGF0ZUlEO1xyXG4gICAgICAgIHZhciBkYXRhID0gdGhpcy51dkJ1ZmZlci5kYXRhO1xyXG4gICAgICAgIGlmICghdGhpcy5kYXRhIHx8IHRoaXMuZGF0YS5sZW5ndGggIT09IGRhdGEubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoZGF0YS5sZW5ndGgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnV2TWF0cml4Lm11bHRpcGx5VXZzKGRhdGEsIHRoaXMuZGF0YSk7XHJcbiAgICAgICAgdGhpcy5fdXBkYXRlSUQrKztcclxuICAgIH1cclxuICAgIDtcclxufVxyXG5leHBvcnRzLk1lc2hCYXRjaFV2cyA9IE1lc2hCYXRjaFV2cztcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgR2VvbWV0cnlfMSA9IHJlcXVpcmUoXCIuL0dlb21ldHJ5XCIpO1xyXG5jb25zdCBCdWZmZXJfMSA9IHJlcXVpcmUoXCIuL0J1ZmZlclwiKTtcclxuY29uc3QgV2ViR0xTZXR0aW5nc18xID0gcmVxdWlyZShcIi4vV2ViR0xTZXR0aW5nc1wiKTtcclxuY2xhc3MgTWVzaEdlb21ldHJ5IGV4dGVuZHMgR2VvbWV0cnlfMS5HZW9tZXRyeSB7XHJcbiAgICBjb25zdHJ1Y3Rvcih2ZXJ0aWNlcyA9IG51bGwsIHV2cyA9IG51bGwsIGluZGV4ID0gbnVsbCkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdmFyIHZlcnRpY2VzQnVmZmVyID0gbmV3IEJ1ZmZlcl8xLkJ1ZmZlcih2ZXJ0aWNlcyk7XHJcbiAgICAgICAgdmFyIHV2c0J1ZmZlciA9IG5ldyBCdWZmZXJfMS5CdWZmZXIodXZzLCB0cnVlKTtcclxuICAgICAgICB2YXIgaW5kZXhCdWZmZXIgPSBuZXcgQnVmZmVyXzEuQnVmZmVyKGluZGV4LCB0cnVlLCB0cnVlKTtcclxuICAgICAgICB0aGlzLmFkZEF0dHJpYnV0ZSgnYVZlcnRleFBvc2l0aW9uJywgdmVydGljZXNCdWZmZXIsIDIsIGZhbHNlLCBXZWJHTFNldHRpbmdzXzEuV2ViR0xTZXR0aW5ncy5UWVBFUy5GTE9BVClcclxuICAgICAgICAgICAgLmFkZEF0dHJpYnV0ZSgnYVRleHR1cmVDb29yZCcsIHV2c0J1ZmZlciwgMiwgZmFsc2UsIFdlYkdMU2V0dGluZ3NfMS5XZWJHTFNldHRpbmdzLlRZUEVTLkZMT0FUKVxyXG4gICAgICAgICAgICAuYWRkSW5kZXgoaW5kZXhCdWZmZXIpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIERpcnR5IGZsYWcgdG8gbGltaXQgdXBkYXRlIGNhbGxzIG9uIE1lc2guIEZvciBleGFtcGxlLFxyXG4gICAgICAgICAqIGxpbWl0aW5nIHVwZGF0ZXMgb24gYSBzaW5nbGUgTWVzaCBpbnN0YW5jZSB3aXRoIGEgc2hhcmVkIEdlb21ldHJ5XHJcbiAgICAgICAgICogd2l0aGluIHRoZSByZW5kZXIgbG9vcC5cclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAgICAgKiBAZGVmYXVsdCAtMVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuX3VwZGF0ZUlkID0gLTE7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIElmIHRoZSB2ZXJ0ZXggcG9zaXRpb24gaXMgdXBkYXRlZC5cclxuICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgZ2V0IHZlcnRleERpcnR5SWQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyc1swXS5fdXBkYXRlSUQ7XHJcbiAgICB9XHJcbiAgICA7XHJcbn1cclxuZXhwb3J0cy5NZXNoR2VvbWV0cnkgPSBNZXNoR2VvbWV0cnk7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IFNoYWRlcl8xID0gcmVxdWlyZShcIi4vU2hhZGVyXCIpO1xyXG5jb25zdCBNYXRyaXhfMSA9IHJlcXVpcmUoXCIuL01hdHJpeFwiKTtcclxuY29uc3QgUHJvZ3JhbV8xID0gcmVxdWlyZShcIi4vUHJvZ3JhbVwiKTtcclxuY29uc3QgVGV4dHVyZU1hdHJpeF8xID0gcmVxdWlyZShcIi4vVGV4dHVyZU1hdHJpeFwiKTtcclxuY29uc3QgQ29sb3JTZXR0aW5nc18xID0gcmVxdWlyZShcIi4vQ29sb3JTZXR0aW5nc1wiKTtcclxuY2xhc3MgTWVzaE1hdGVyaWFsIGV4dGVuZHMgU2hhZGVyXzEuU2hhZGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKHVTYW1wbGVyLCBvcHRpb25zID0gbnVsbCkge1xyXG4gICAgICAgIHZhciB1bmlmb3JtcyA9IHtcclxuICAgICAgICAgICAgdVNhbXBsZXI6IHVTYW1wbGVyLFxyXG4gICAgICAgICAgICBhbHBoYTogMSxcclxuICAgICAgICAgICAgdVRleHR1cmVNYXRyaXg6IE1hdHJpeF8xLk1hdHJpeC5JREVOVElUWSxcclxuICAgICAgICAgICAgdUNvbG9yOiBuZXcgRmxvYXQzMkFycmF5KFsxLCAxLCAxLCAxXSksXHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyBTZXQgZGVmYXVsdHNcclxuICAgICAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7XHJcbiAgICAgICAgICAgIHRpbnQ6IDB4RkZGRkZGLFxyXG4gICAgICAgICAgICBhbHBoYTogMSxcclxuICAgICAgICAgICAgcGx1Z2luTmFtZTogJ2JhdGNoJyxcclxuICAgICAgICB9LCBvcHRpb25zKTtcclxuICAgICAgICBpZiAob3B0aW9ucy51bmlmb3Jtcykge1xyXG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHVuaWZvcm1zLCBvcHRpb25zLnVuaWZvcm1zKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc3VwZXIob3B0aW9ucy5wcm9ncmFtIHx8IFByb2dyYW1fMS5Qcm9ncmFtLmZyb20oTWVzaE1hdGVyaWFsLnZlcnRleCQ2LCBNZXNoTWF0ZXJpYWwuZnJhZ21lbnQkOCksIHVuaWZvcm1zKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBPbmx5IGRvIHVwZGF0ZSBpZiB0aW50IG9yIGFscGhhIGNoYW5nZXMuXHJcbiAgICAgICAgICogQG1lbWJlciB7Ym9vbGVhbn1cclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqIEBkZWZhdWx0IGZhbHNlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5fY29sb3JEaXJ0eSA9IGZhbHNlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRleHR1cmVNYXRyaXggaW5zdGFuY2UgZm9yIHRoaXMgTWVzaCwgdXNlZCB0byB0cmFjayBUZXh0dXJlIGNoYW5nZXNcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuVGV4dHVyZU1hdHJpeH1cclxuICAgICAgICAgKiBAcmVhZG9ubHlcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnV2TWF0cml4ID0gbmV3IFRleHR1cmVNYXRyaXhfMS5UZXh0dXJlTWF0cml4KHVTYW1wbGVyKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBgdHJ1ZWAgaWYgc2hhZGVyIGNhbiBiZSBiYXRjaCB3aXRoIHRoZSByZW5kZXJlcidzIGJhdGNoIHN5c3RlbS5cclxuICAgICAgICAgKiBAbWVtYmVyIHtib29sZWFufVxyXG4gICAgICAgICAqIEBkZWZhdWx0IHRydWVcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmJhdGNoYWJsZSA9IG9wdGlvbnMucHJvZ3JhbSA9PT0gdW5kZWZpbmVkO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlbmRlcmVyIHBsdWdpbiBmb3IgYmF0Y2hpbmdcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBtZW1iZXIge3N0cmluZ31cclxuICAgICAgICAgKiBAZGVmYXVsdCAnYmF0Y2gnXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5wbHVnaW5OYW1lID0gb3B0aW9ucy5wbHVnaW5OYW1lO1xyXG4gICAgICAgIHRoaXMudGludCA9IG9wdGlvbnMudGludDtcclxuICAgICAgICB0aGlzLmFscGhhID0gb3B0aW9ucy5hbHBoYTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVmZXJlbmNlIHRvIHRoZSB0ZXh0dXJlIGJlaW5nIHJlbmRlcmVkLlxyXG4gICAgICogQG1lbWJlciB7UElYSS5UZXh0dXJlfVxyXG4gICAgICovXHJcbiAgICBnZXQgdGV4dHVyZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy51U2FtcGxlcjtcclxuICAgIH1cclxuICAgIDtcclxuICAgIHNldCB0ZXh0dXJlKHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKHRoaXMudW5pZm9ybXMudVNhbXBsZXIgIT09IHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHRoaXMudW5pZm9ybXMudVNhbXBsZXIgPSB2YWx1ZTtcclxuICAgICAgICAgICAgdGhpcy51dk1hdHJpeC50ZXh0dXJlID0gdmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIGdldHMgYXV0b21hdGljYWxseSBzZXQgYnkgdGhlIG9iamVjdCB1c2luZyB0aGlzLlxyXG4gICAgICpcclxuICAgICAqIEBkZWZhdWx0IDFcclxuICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgc2V0IGFscGhhKHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKHZhbHVlID09PSB0aGlzLl9hbHBoYSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2FscGhhID0gdmFsdWU7XHJcbiAgICAgICAgdGhpcy5fY29sb3JEaXJ0eSA9IHRydWU7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICBnZXQgYWxwaGEoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FscGhhO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBNdWx0aXBseSB0aW50IGZvciB0aGUgbWF0ZXJpYWwuXHJcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgKiBAZGVmYXVsdCAweEZGRkZGRlxyXG4gICAgICovXHJcbiAgICBzZXQgdGludCh2YWx1ZSkge1xyXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdGhpcy5fdGludCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3RpbnQgPSB2YWx1ZTtcclxuICAgICAgICB0aGlzLl90aW50UkdCID0gKHZhbHVlID4+IDE2KSArICh2YWx1ZSAmIDB4ZmYwMCkgKyAoKHZhbHVlICYgMHhmZikgPDwgMTYpO1xyXG4gICAgICAgIHRoaXMuX2NvbG9yRGlydHkgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgZ2V0IHRpbnQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RpbnQ7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgY2FsbGVkIGF1dG9tYXRpY2FsbHkgYnkgdGhlIE1lc2guIEludGVuZGVkIHRvIGJlIG92ZXJyaWRkZW4gZm9yIGN1c3RvbVxyXG4gICAgICogTWVzaE1hdGVyaWFsIG9iamVjdHMuXHJcbiAgICAgKi9cclxuICAgIHVwZGF0ZSgpIHtcclxuICAgICAgICBpZiAodGhpcy5fY29sb3JEaXJ0eSkge1xyXG4gICAgICAgICAgICB0aGlzLl9jb2xvckRpcnR5ID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHZhciBiYXNlVGV4dHVyZSA9IHRoaXMudGV4dHVyZS5iYXNlVGV4dHVyZTtcclxuICAgICAgICAgICAgQ29sb3JTZXR0aW5nc18xLkNvbG9yU2V0dGluZ3MucHJlbXVsdGlwbHlUaW50VG9SZ2JhKHRoaXMuX3RpbnQsIHRoaXMuX2FscGhhLCB0aGlzLnVuaWZvcm1zLnVDb2xvciwgYmFzZVRleHR1cmUucHJlbXVsdGlwbHlBbHBoYSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLnV2TWF0cml4LnVwZGF0ZSgpKSB7XHJcbiAgICAgICAgICAgIHRoaXMudW5pZm9ybXMudVRleHR1cmVNYXRyaXggPSB0aGlzLnV2TWF0cml4Lm1hcENvb3JkO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIDtcclxufVxyXG5NZXNoTWF0ZXJpYWwudmVydGV4JDYgPSBcImF0dHJpYnV0ZSB2ZWMyIGFWZXJ0ZXhQb3NpdGlvbjtcXHJcXG5hdHRyaWJ1dGUgdmVjMiBhVGV4dHVyZUNvb3JkO1xcclxcblxcclxcbnVuaWZvcm0gbWF0MyBwcm9qZWN0aW9uTWF0cml4O1xcclxcbnVuaWZvcm0gbWF0MyB0cmFuc2xhdGlvbk1hdHJpeDtcXHJcXG51bmlmb3JtIG1hdDMgdVRleHR1cmVNYXRyaXg7XFxyXFxuXFxyXFxudmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XFxyXFxuXFxyXFxudm9pZCBtYWluKHZvaWQpXFxyXFxue1xcclxcbiAgICBnbF9Qb3NpdGlvbiA9IHZlYzQoKHByb2plY3Rpb25NYXRyaXggKiB0cmFuc2xhdGlvbk1hdHJpeCAqIHZlYzMoYVZlcnRleFBvc2l0aW9uLCAxLjApKS54eSwgMC4wLCAxLjApO1xcclxcblxcclxcbiAgICB2VGV4dHVyZUNvb3JkID0gKHVUZXh0dXJlTWF0cml4ICogdmVjMyhhVGV4dHVyZUNvb3JkLCAxLjApKS54eTtcXHJcXG59XFxyXFxuXCI7XHJcbk1lc2hNYXRlcmlhbC5mcmFnbWVudCQ4ID0gXCJ2YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXHJcXG51bmlmb3JtIHZlYzQgdUNvbG9yO1xcclxcblxcclxcbnVuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyO1xcclxcblxcclxcbnZvaWQgbWFpbih2b2lkKVxcclxcbntcXHJcXG4gICAgZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2VGV4dHVyZUNvb3JkKSAqIHVDb2xvcjtcXHJcXG59XFxyXFxuXCI7XHJcbmV4cG9ydHMuTWVzaE1hdGVyaWFsID0gTWVzaE1hdGVyaWFsO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBFdmVudF8xID0gcmVxdWlyZShcIi4vRXZlbnRcIik7XHJcbmNsYXNzIE1vdXNlRXZlbnQgZXh0ZW5kcyBFdmVudF8xLkV2ZW50IHtcclxuICAgIGNvbnN0cnVjdG9yKHR5cGUsIGJ1YmJsZXMgPSBmYWxzZSkge1xyXG4gICAgICAgIHN1cGVyKHR5cGUsIGJ1YmJsZXMpO1xyXG4gICAgICAgIHRoaXMubW92ZW1lbnRYID0gMDtcclxuICAgICAgICB0aGlzLm1vdmVtZW50WSA9IDA7XHJcbiAgICB9XHJcbn1cclxuTW91c2VFdmVudC5DTElDSyA9IFwiY2xpY2tcIjtcclxuTW91c2VFdmVudC5NT1VTRV9ET1dOID0gXCJtb3VzZURvd25cIjtcclxuTW91c2VFdmVudC5NT1VTRV9VUCA9IFwibW91c2VVcFwiO1xyXG5Nb3VzZUV2ZW50Lk1JRERMRV9DTElDSyA9IFwibWlkZGxlQ2xpY2tcIjtcclxuTW91c2VFdmVudC5NSURETEVfTU9VU0VfRE9XTiA9IFwibWlkZGxlTW91c2VEb3duXCI7XHJcbk1vdXNlRXZlbnQuTUlERExFX01PVVNFX1VQID0gXCJtaWRkbGVNb3VzZVVwXCI7XHJcbk1vdXNlRXZlbnQuUklHSFRfQ0xJQ0sgPSBcInJpZ2h0Q2xpY2tcIjtcclxuTW91c2VFdmVudC5SSUdIVF9NT1VTRV9ET1dOID0gXCJyaWdodE1vdXNlRG93blwiO1xyXG5Nb3VzZUV2ZW50LlJJR0hUX01PVVNFX1VQID0gXCJyaWdodE1vdXNlVXBcIjtcclxuTW91c2VFdmVudC5NT1VTRV9NT1ZFID0gXCJtb3VzZU1vdmVcIjtcclxuTW91c2VFdmVudC5NT1VTRV9PVkVSID0gXCJtb3VzZU92ZXJcIjtcclxuTW91c2VFdmVudC5NT1VTRV9PVVQgPSBcIm1vdXNlT3V0XCI7XHJcbk1vdXNlRXZlbnQuUklHSFRfTU9VU0VfVVBfT1VUU0lERSA9IFwicmlnaHR1cG91dHNpZGVcIjtcclxuTW91c2VFdmVudC5NT1VTRV9VUF9PVVRTSURFID0gXCJtb3VzZXVwb3V0c2lkZVwiO1xyXG5Nb3VzZUV2ZW50LlBPSU5URVJfT1ZFUiA9IFwicG9pbnRlcm92ZXJcIjtcclxuTW91c2VFdmVudC5QT0lOVEVSX0VOVEVSID0gXCJwb2ludGVyZW50ZXJcIjtcclxuTW91c2VFdmVudC5QT0lOVEVSX0RPV04gPSBcInBvaW50ZXJkb3duXCI7XHJcbk1vdXNlRXZlbnQuUE9JTlRFUl9NT1ZFID0gXCJwb2ludGVybW92ZVwiO1xyXG5Nb3VzZUV2ZW50LlBPSU5URVJfVVAgPSBcInBvaW50ZXJ1cFwiO1xyXG5Nb3VzZUV2ZW50LlBPSU5URVJfQ0FOQ0VMID0gXCJwb2ludGVyY2FuY2VsXCI7XHJcbk1vdXNlRXZlbnQuUE9JTlRFUl9PVVQgPSBcInBvaW50ZXJvdXRcIjtcclxuTW91c2VFdmVudC5QT0lOVEVSX0xFQVZFID0gXCJwb2ludGVybGVhdmVcIjtcclxuTW91c2VFdmVudC5QT0lOVEVSX0NBUFRVUkUgPSBcImdvdHBvaW50ZXJjYXB0dXJlXCI7XHJcbk1vdXNlRXZlbnQuUE9JTlRFUl9MT1NUID0gXCJsb3N0cG9pbnRlcmNhcHR1cmVcIjtcclxuTW91c2VFdmVudC5QT0lOVEVSX1VQX09VVFNJREUgPSBcInBvaW50ZXJ1cG91dHNpZGVcIjtcclxuTW91c2VFdmVudC5QT0lOVEVSX1RBUCA9IFwicG9pbnRlcnRhcFwiO1xyXG5Nb3VzZUV2ZW50LlRPVUNIX1NUQVJUID0gXCJ0b3VjaHN0YXJ0XCI7XHJcbk1vdXNlRXZlbnQuVE9VQ0hfRU5EID0gXCJ0b3VjaGVuZFwiO1xyXG5Nb3VzZUV2ZW50LlRPVUNIX0VORF9PVVRTSURFID0gXCJ0b3VjaGVuZG91dHNpZGVcIjtcclxuTW91c2VFdmVudC5UT1VDSF9NT1ZFID0gXCJ0b3VjaG1vdmVcIjtcclxuTW91c2VFdmVudC5UT1VDSF9DQU5DRUwgPSBcInRvdWNoY2FuY2VsXCI7XHJcbk1vdXNlRXZlbnQuVE9VQ0hfVEFQID0gXCJ0YXBcIjtcclxuZXhwb3J0cy5Nb3VzZUV2ZW50ID0gTW91c2VFdmVudDtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgVXJsXzEgPSByZXF1aXJlKFwiLi9VcmxcIik7XHJcbmNsYXNzIE5ldHdvcmtTZXR0aW5ncyB7XHJcbiAgICBzdGF0aWMgZ2V0UmVzb2x1dGlvbk9mVXJsKHVybCwgZGVmYXVsdFZhbHVlID0gbnVsbCkge1xyXG4gICAgICAgIHZhciByZXNvbHV0aW9uID0gTmV0d29ya1NldHRpbmdzLlJFVElOQV9QUkVGSVguZXhlYyh1cmwpO1xyXG4gICAgICAgIGlmIChyZXNvbHV0aW9uKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUZsb2F0KHJlc29sdXRpb25bMV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZGVmYXVsdFZhbHVlICE9PSB1bmRlZmluZWQgPyBkZWZhdWx0VmFsdWUgOiAxO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGRldGVybWluZUNyb3NzT3JpZ2luKHVybCQxLCBsb2MgPSBudWxsKSB7XHJcbiAgICAgICAgaWYgKGxvYyA9PT0gdm9pZCAwKSB7XHJcbiAgICAgICAgICAgIGxvYyA9IHdpbmRvdy5sb2NhdGlvbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHVybCQxLmluZGV4T2YoJ2RhdGE6JykgPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsb2MgPSBsb2MgfHwgd2luZG93LmxvY2F0aW9uO1xyXG4gICAgICAgIGlmICghTmV0d29ya1NldHRpbmdzLnRlbXBBbmNob3IpIHtcclxuICAgICAgICAgICAgTmV0d29ya1NldHRpbmdzLnRlbXBBbmNob3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIE5ldHdvcmtTZXR0aW5ncy50ZW1wQW5jaG9yLmhyZWYgPSB1cmwkMTtcclxuICAgICAgICB1cmwkMSA9IE5ldHdvcmtTZXR0aW5ncy51cmwucGFyc2UoTmV0d29ya1NldHRpbmdzLnRlbXBBbmNob3IuaHJlZik7XHJcbiAgICAgICAgdmFyIHNhbWVQb3J0ID0gKCF1cmwkMS5wb3J0ICYmIGxvYy5wb3J0ID09PSAnJykgfHwgKHVybCQxLnBvcnQgPT09IGxvYy5wb3J0KTtcclxuICAgICAgICBpZiAodXJsJDEuaG9zdG5hbWUgIT09IGxvYy5ob3N0bmFtZSB8fCAhc2FtZVBvcnQgfHwgdXJsJDEucHJvdG9jb2wgIT09IGxvYy5wcm90b2NvbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gJ2Fub255bW91cyc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAnJztcclxuICAgIH1cclxufVxyXG5OZXR3b3JrU2V0dGluZ3MuUkVUSU5BX1BSRUZJWCA9IC9AKFswLTlcXC5dKyl4LztcclxuTmV0d29ya1NldHRpbmdzLnVybCA9IHtcclxuICAgIHBhcnNlOiBVcmxfMS5VcmwudXJsUGFyc2UsXHJcbiAgICByZXNvbHZlOiBVcmxfMS5VcmwudXJsUmVzb2x2ZSxcclxuICAgIHJlc29sdmVPYmplY3Q6IFVybF8xLlVybC51cmxSZXNvbHZlT2JqZWN0LFxyXG4gICAgZm9ybWF0OiBVcmxfMS5VcmwudXJsRm9ybWF0LFxyXG4gICAgVXJsOiBVcmxfMS5VcmxcclxufTtcclxuZXhwb3J0cy5OZXR3b3JrU2V0dGluZ3MgPSBOZXR3b3JrU2V0dGluZ3M7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IFN5c3RlbV8xID0gcmVxdWlyZShcIi4vU3lzdGVtXCIpO1xyXG5jbGFzcyBPYmplY3RSZW5kZXJlciBleHRlbmRzIFN5c3RlbV8xLlN5c3RlbSB7XHJcbiAgICBjb25zdHJ1Y3RvcihyZW5kZXJlcikge1xyXG4gICAgICAgIHN1cGVyKHJlbmRlcmVyKTtcclxuICAgIH1cclxuICAgIHN0YXJ0KCkge1xyXG4gICAgICAgIC8vIHNldCB0aGUgc2hhZGVyLi5cclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogU3RvcHMgdGhlIHJlbmRlcmVyXHJcbiAgICAgKlxyXG4gICAgICovXHJcbiAgICBzdG9wKCkge1xyXG4gICAgICAgIHRoaXMuZmx1c2goKTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogU3R1YiBtZXRob2QgZm9yIHJlbmRlcmluZyBjb250ZW50IGFuZCBlbXB0eWluZyB0aGUgY3VycmVudCBiYXRjaC5cclxuICAgICAqXHJcbiAgICAgKi9cclxuICAgIGZsdXNoKCkge1xyXG4gICAgICAgIC8vIGZsdXNoIVxyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZW5kZXJzIGFuIG9iamVjdFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7UElYSS5EaXNwbGF5T2JqZWN0fSBvYmplY3QgLSBUaGUgb2JqZWN0IHRvIHJlbmRlci5cclxuICAgICAqL1xyXG4gICAgcmVuZGVyKG9iamVjdCkge1xyXG4gICAgICAgIC8vIHJlbmRlciB0aGUgb2JqZWN0XHJcbiAgICB9XHJcbiAgICA7XHJcbn1cclxuZXhwb3J0cy5PYmplY3RSZW5kZXJlciA9IE9iamVjdFJlbmRlcmVyO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jbGFzcyBPYnNlcnZhYmxlUG9pbnQge1xyXG4gICAgY29uc3RydWN0b3IoY2IsIHNjb3BlLCB4ID0gMCwgeSA9IDApIHtcclxuICAgICAgICBpZiAoeCA9PT0gdm9pZCAwKSB7XHJcbiAgICAgICAgICAgIHggPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoeSA9PT0gdm9pZCAwKSB7XHJcbiAgICAgICAgICAgIHkgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl94ID0geDtcclxuICAgICAgICB0aGlzLl95ID0geTtcclxuICAgICAgICB0aGlzLmNiID0gY2I7XHJcbiAgICAgICAgdGhpcy5zY29wZSA9IHNjb3BlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgdGhpcyBwb2ludC5cclxuICAgICAqIFRoZSBjYWxsYmFjayBhbmQgc2NvcGUgcGFyYW1zIGNhbiBiZSBvdmVyaWRkZW4gb3RoZXJ3aXNlIHRoZXkgd2lsbCBkZWZhdWx0XHJcbiAgICAgKiB0byB0aGUgY2xvbmUgb2JqZWN0J3MgdmFsdWVzLlxyXG4gICAgICpcclxuICAgICAqIEBvdmVycmlkZVxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiPW51bGxdIC0gY2FsbGJhY2sgd2hlbiBjaGFuZ2VkXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW3Njb3BlPW51bGxdIC0gb3duZXIgb2YgY2FsbGJhY2tcclxuICAgICAqIEByZXR1cm4ge1BJWEkuT2JzZXJ2YWJsZVBvaW50fSBhIGNvcHkgb2YgdGhlIHBvaW50XHJcbiAgICAgKi9cclxuICAgIGNsb25lKGNiLCBzY29wZSkge1xyXG4gICAgICAgIGlmIChjYiA9PT0gdm9pZCAwKSB7XHJcbiAgICAgICAgICAgIGNiID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHNjb3BlID09PSB2b2lkIDApIHtcclxuICAgICAgICAgICAgc2NvcGUgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgX2NiID0gY2IgfHwgdGhpcy5jYjtcclxuICAgICAgICB2YXIgX3Njb3BlID0gc2NvcGUgfHwgdGhpcy5zY29wZTtcclxuICAgICAgICByZXR1cm4gbmV3IE9ic2VydmFibGVQb2ludChfY2IsIF9zY29wZSwgdGhpcy5feCwgdGhpcy5feSk7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIHBvaW50IHRvIGEgbmV3IHggYW5kIHkgcG9zaXRpb24uXHJcbiAgICAgKiBJZiB5IGlzIG9taXR0ZWQsIGJvdGggeCBhbmQgeSB3aWxsIGJlIHNldCB0byB4LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbeD0wXSAtIHBvc2l0aW9uIG9mIHRoZSBwb2ludCBvbiB0aGUgeCBheGlzXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3k9MF0gLSBwb3NpdGlvbiBvZiB0aGUgcG9pbnQgb24gdGhlIHkgYXhpc1xyXG4gICAgICovXHJcbiAgICBzZXQoeCwgeSkge1xyXG4gICAgICAgIHZhciBfeCA9IHggfHwgMDtcclxuICAgICAgICB2YXIgX3kgPSB5IHx8ICgoeSAhPT0gMCkgPyBfeCA6IDApO1xyXG4gICAgICAgIGlmICh0aGlzLl94ICE9PSBfeCB8fCB0aGlzLl95ICE9PSBfeSkge1xyXG4gICAgICAgICAgICB0aGlzLl94ID0gX3g7XHJcbiAgICAgICAgICAgIHRoaXMuX3kgPSBfeTtcclxuICAgICAgICAgICAgdGhpcy5jYi5jYWxsKHRoaXMuc2NvcGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQ29waWVzIHggYW5kIHkgZnJvbSB0aGUgZ2l2ZW4gcG9pbnRcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1BJWEkuSVBvaW50fSBwIC0gVGhlIHBvaW50IHRvIGNvcHkgZnJvbS5cclxuICAgICAqIEByZXR1cm5zIHtQSVhJLklQb2ludH0gUmV0dXJucyBpdHNlbGYuXHJcbiAgICAgKi9cclxuICAgIGNvcHlGcm9tKHApIHtcclxuICAgICAgICBpZiAodGhpcy5feCAhPT0gcC54IHx8IHRoaXMuX3kgIT09IHAueSkge1xyXG4gICAgICAgICAgICB0aGlzLl94ID0gcC54O1xyXG4gICAgICAgICAgICB0aGlzLl95ID0gcC55O1xyXG4gICAgICAgICAgICB0aGlzLmNiLmNhbGwodGhpcy5zY29wZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDb3BpZXMgeCBhbmQgeSBpbnRvIHRoZSBnaXZlbiBwb2ludFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7UElYSS5JUG9pbnR9IHAgLSBUaGUgcG9pbnQgdG8gY29weS5cclxuICAgICAqIEByZXR1cm5zIHtQSVhJLklQb2ludH0gR2l2ZW4gcG9pbnQgd2l0aCB2YWx1ZXMgdXBkYXRlZFxyXG4gICAgICovXHJcbiAgICBjb3B5VG8ocCkge1xyXG4gICAgICAgIHAuc2V0KHRoaXMuX3gsIHRoaXMuX3kpO1xyXG4gICAgICAgIHJldHVybiBwO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHBvaW50IGlzIGVxdWFsIHRvIHRoaXMgcG9pbnRcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1BJWEkuSVBvaW50fSBwIC0gVGhlIHBvaW50IHRvIGNoZWNrXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gV2hldGhlciB0aGUgZ2l2ZW4gcG9pbnQgZXF1YWwgdG8gdGhpcyBwb2ludFxyXG4gICAgICovXHJcbiAgICBlcXVhbHMocCkge1xyXG4gICAgICAgIHJldHVybiAocC54ID09PSB0aGlzLl94KSAmJiAocC55ID09PSB0aGlzLl95KTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIHBvc2l0aW9uIG9mIHRoZSBkaXNwbGF5T2JqZWN0IG9uIHRoZSB4IGF4aXMgcmVsYXRpdmUgdG8gdGhlIGxvY2FsIGNvb3JkaW5hdGVzIG9mIHRoZSBwYXJlbnQuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICBnZXQgeCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5feDtcclxuICAgIH1cclxuICAgIDtcclxuICAgIHNldCB4KHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3ggIT09IHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3ggPSB2YWx1ZTtcclxuICAgICAgICAgICAgdGhpcy5jYi5jYWxsKHRoaXMuc2NvcGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIHBvc2l0aW9uIG9mIHRoZSBkaXNwbGF5T2JqZWN0IG9uIHRoZSB4IGF4aXMgcmVsYXRpdmUgdG8gdGhlIGxvY2FsIGNvb3JkaW5hdGVzIG9mIHRoZSBwYXJlbnQuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICBnZXQgeSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5feTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIHNldCB5KHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3kgIT09IHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3kgPSB2YWx1ZTtcclxuICAgICAgICAgICAgdGhpcy5jYi5jYWxsKHRoaXMuc2NvcGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIDtcclxufVxyXG5leHBvcnRzLk9ic2VydmFibGVQb2ludCA9IE9ic2VydmFibGVQb2ludDtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgR2VvbWV0cnlfMSA9IHJlcXVpcmUoXCIuL0dlb21ldHJ5XCIpO1xyXG5jb25zdCBCdWZmZXJfMSA9IHJlcXVpcmUoXCIuL0J1ZmZlclwiKTtcclxuY29uc3QgV2ViR0xTZXR0aW5nc18xID0gcmVxdWlyZShcIi4vV2ViR0xTZXR0aW5nc1wiKTtcclxuY2xhc3MgUGFydGljbGVCdWZmZXIge1xyXG4gICAgY29uc3RydWN0b3IocHJvcGVydGllcywgZHluYW1pY1Byb3BlcnR5RmxhZ3MsIHNpemUpIHtcclxuICAgICAgICB0aGlzLmdlb21ldHJ5ID0gbmV3IEdlb21ldHJ5XzEuR2VvbWV0cnkoKTtcclxuICAgICAgICB0aGlzLmluZGV4QnVmZmVyID0gbnVsbDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgbnVtYmVyIG9mIHBhcnRpY2xlcyB0aGUgYnVmZmVyIGNhbiBob2xkXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnNpemUgPSBzaXplO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEEgbGlzdCBvZiB0aGUgcHJvcGVydGllcyB0aGF0IGFyZSBkeW5hbWljLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKiBAbWVtYmVyIHtvYmplY3RbXX1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmR5bmFtaWNQcm9wZXJ0aWVzID0gW107XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQSBsaXN0IG9mIHRoZSBwcm9wZXJ0aWVzIHRoYXQgYXJlIHN0YXRpYy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICogQG1lbWJlciB7b2JqZWN0W119XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5zdGF0aWNQcm9wZXJ0aWVzID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wZXJ0aWVzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgIHZhciBwcm9wZXJ0eSA9IHByb3BlcnRpZXNbaV07XHJcbiAgICAgICAgICAgIC8vIE1ha2UgY29weSBvZiBwcm9wZXJ0aWVzIG9iamVjdCBzbyB0aGF0IHdoZW4gd2UgZWRpdCB0aGUgb2Zmc2V0IGl0IGRvZXNuJ3RcclxuICAgICAgICAgICAgLy8gY2hhbmdlIGFsbCBvdGhlciBpbnN0YW5jZXMgb2YgdGhlIG9iamVjdCBsaXRlcmFsXHJcbiAgICAgICAgICAgIHByb3BlcnR5ID0ge1xyXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlTmFtZTogcHJvcGVydHkuYXR0cmlidXRlTmFtZSxcclxuICAgICAgICAgICAgICAgIHNpemU6IHByb3BlcnR5LnNpemUsXHJcbiAgICAgICAgICAgICAgICB1cGxvYWRGdW5jdGlvbjogcHJvcGVydHkudXBsb2FkRnVuY3Rpb24sXHJcbiAgICAgICAgICAgICAgICB0eXBlOiBwcm9wZXJ0eS50eXBlIHx8IFdlYkdMU2V0dGluZ3NfMS5XZWJHTFNldHRpbmdzLlRZUEVTLkZMT0FULFxyXG4gICAgICAgICAgICAgICAgb2Zmc2V0OiBwcm9wZXJ0eS5vZmZzZXQsXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGlmIChkeW5hbWljUHJvcGVydHlGbGFnc1tpXSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5keW5hbWljUHJvcGVydGllcy5wdXNoKHByb3BlcnR5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGljUHJvcGVydGllcy5wdXNoKHByb3BlcnR5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnN0YXRpY1N0cmlkZSA9IDA7XHJcbiAgICAgICAgdGhpcy5zdGF0aWNCdWZmZXIgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuc3RhdGljRGF0YSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5zdGF0aWNEYXRhVWludDMyID0gbnVsbDtcclxuICAgICAgICB0aGlzLmR5bmFtaWNTdHJpZGUgPSAwO1xyXG4gICAgICAgIHRoaXMuZHluYW1pY0J1ZmZlciA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5keW5hbWljRGF0YSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5keW5hbWljRGF0YVVpbnQzMiA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5fdXBkYXRlSUQgPSAwO1xyXG4gICAgICAgIHRoaXMuaW5pdEJ1ZmZlcnMoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB1cCB0aGUgcmVuZGVyZXIgY29udGV4dCBhbmQgbmVjZXNzYXJ5IGJ1ZmZlcnMuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgaW5pdEJ1ZmZlcnMoKSB7XHJcbiAgICAgICAgdmFyIGdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeTtcclxuICAgICAgICB2YXIgZHluYW1pY09mZnNldCA9IDA7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSG9sZHMgdGhlIGluZGljZXMgb2YgdGhlIGdlb21ldHJ5IChxdWFkcykgdG8gZHJhd1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQG1lbWJlciB7VWludDE2QXJyYXl9XHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmluZGV4QnVmZmVyID0gbmV3IEJ1ZmZlcl8xLkJ1ZmZlcihXZWJHTFNldHRpbmdzXzEuV2ViR0xTZXR0aW5ncy5jcmVhdGVJbmRpY2VzRm9yUXVhZHModGhpcy5zaXplKSwgdHJ1ZSwgdHJ1ZSk7XHJcbiAgICAgICAgZ2VvbWV0cnkuYWRkSW5kZXgodGhpcy5pbmRleEJ1ZmZlcik7XHJcbiAgICAgICAgdGhpcy5keW5hbWljU3RyaWRlID0gMDtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZHluYW1pY1Byb3BlcnRpZXMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgdmFyIHByb3BlcnR5ID0gdGhpcy5keW5hbWljUHJvcGVydGllc1tpXTtcclxuICAgICAgICAgICAgcHJvcGVydHkub2Zmc2V0ID0gZHluYW1pY09mZnNldDtcclxuICAgICAgICAgICAgZHluYW1pY09mZnNldCArPSBwcm9wZXJ0eS5zaXplO1xyXG4gICAgICAgICAgICB0aGlzLmR5bmFtaWNTdHJpZGUgKz0gcHJvcGVydHkuc2l6ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGR5bkJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcih0aGlzLnNpemUgKiB0aGlzLmR5bmFtaWNTdHJpZGUgKiA0ICogNCk7XHJcbiAgICAgICAgdGhpcy5keW5hbWljRGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoZHluQnVmZmVyKTtcclxuICAgICAgICB0aGlzLmR5bmFtaWNEYXRhVWludDMyID0gbmV3IFVpbnQzMkFycmF5KGR5bkJ1ZmZlcik7XHJcbiAgICAgICAgdGhpcy5keW5hbWljQnVmZmVyID0gbmV3IEJ1ZmZlcl8xLkJ1ZmZlcih0aGlzLmR5bmFtaWNEYXRhLCBmYWxzZSwgZmFsc2UpO1xyXG4gICAgICAgIC8vIHN0YXRpYyAvL1xyXG4gICAgICAgIHZhciBzdGF0aWNPZmZzZXQgPSAwO1xyXG4gICAgICAgIHRoaXMuc3RhdGljU3RyaWRlID0gMDtcclxuICAgICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCB0aGlzLnN0YXRpY1Byb3BlcnRpZXMubGVuZ3RoOyArK2kkMSkge1xyXG4gICAgICAgICAgICB2YXIgcHJvcGVydHkkMSA9IHRoaXMuc3RhdGljUHJvcGVydGllc1tpJDFdO1xyXG4gICAgICAgICAgICBwcm9wZXJ0eSQxLm9mZnNldCA9IHN0YXRpY09mZnNldDtcclxuICAgICAgICAgICAgc3RhdGljT2Zmc2V0ICs9IHByb3BlcnR5JDEuc2l6ZTtcclxuICAgICAgICAgICAgdGhpcy5zdGF0aWNTdHJpZGUgKz0gcHJvcGVydHkkMS5zaXplO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgc3RhdEJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcih0aGlzLnNpemUgKiB0aGlzLnN0YXRpY1N0cmlkZSAqIDQgKiA0KTtcclxuICAgICAgICB0aGlzLnN0YXRpY0RhdGEgPSBuZXcgRmxvYXQzMkFycmF5KHN0YXRCdWZmZXIpO1xyXG4gICAgICAgIHRoaXMuc3RhdGljRGF0YVVpbnQzMiA9IG5ldyBVaW50MzJBcnJheShzdGF0QnVmZmVyKTtcclxuICAgICAgICB0aGlzLnN0YXRpY0J1ZmZlciA9IG5ldyBCdWZmZXJfMS5CdWZmZXIodGhpcy5zdGF0aWNEYXRhLCB0cnVlLCBmYWxzZSk7XHJcbiAgICAgICAgZm9yICh2YXIgaSQyID0gMDsgaSQyIDwgdGhpcy5keW5hbWljUHJvcGVydGllcy5sZW5ndGg7ICsraSQyKSB7XHJcbiAgICAgICAgICAgIHZhciBwcm9wZXJ0eSQyID0gdGhpcy5keW5hbWljUHJvcGVydGllc1tpJDJdO1xyXG4gICAgICAgICAgICBnZW9tZXRyeS5hZGRBdHRyaWJ1dGUocHJvcGVydHkkMi5hdHRyaWJ1dGVOYW1lLCB0aGlzLmR5bmFtaWNCdWZmZXIsIDAsIHByb3BlcnR5JDIudHlwZSA9PT0gV2ViR0xTZXR0aW5nc18xLldlYkdMU2V0dGluZ3MuVFlQRVMuVU5TSUdORURfQllURSwgcHJvcGVydHkkMi50eXBlLCB0aGlzLmR5bmFtaWNTdHJpZGUgKiA0LCBwcm9wZXJ0eSQyLm9mZnNldCAqIDQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKHZhciBpJDMgPSAwOyBpJDMgPCB0aGlzLnN0YXRpY1Byb3BlcnRpZXMubGVuZ3RoOyArK2kkMykge1xyXG4gICAgICAgICAgICB2YXIgcHJvcGVydHkkMyA9IHRoaXMuc3RhdGljUHJvcGVydGllc1tpJDNdO1xyXG4gICAgICAgICAgICBnZW9tZXRyeS5hZGRBdHRyaWJ1dGUocHJvcGVydHkkMy5hdHRyaWJ1dGVOYW1lLCB0aGlzLnN0YXRpY0J1ZmZlciwgMCwgcHJvcGVydHkkMy50eXBlID09PSBXZWJHTFNldHRpbmdzXzEuV2ViR0xTZXR0aW5ncy5UWVBFUy5VTlNJR05FRF9CWVRFLCBwcm9wZXJ0eSQzLnR5cGUsIHRoaXMuc3RhdGljU3RyaWRlICogNCwgcHJvcGVydHkkMy5vZmZzZXQgKiA0KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFVwbG9hZHMgdGhlIGR5bmFtaWMgcHJvcGVydGllcy5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtQSVhJLkRpc3BsYXlPYmplY3RbXX0gY2hpbGRyZW4gLSBUaGUgY2hpbGRyZW4gdG8gdXBsb2FkLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0SW5kZXggLSBUaGUgaW5kZXggdG8gc3RhcnQgYXQuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYW1vdW50IC0gVGhlIG51bWJlciB0byB1cGxvYWQuXHJcbiAgICAgKi9cclxuICAgIHVwbG9hZER5bmFtaWMoY2hpbGRyZW4sIHN0YXJ0SW5kZXgsIGFtb3VudCkge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5keW5hbWljUHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgcHJvcGVydHkgPSB0aGlzLmR5bmFtaWNQcm9wZXJ0aWVzW2ldO1xyXG4gICAgICAgICAgICBwcm9wZXJ0eS51cGxvYWRGdW5jdGlvbihjaGlsZHJlbiwgc3RhcnRJbmRleCwgYW1vdW50LCBwcm9wZXJ0eS50eXBlID09PSBXZWJHTFNldHRpbmdzXzEuV2ViR0xTZXR0aW5ncy5UWVBFUy5VTlNJR05FRF9CWVRFID8gdGhpcy5keW5hbWljRGF0YVVpbnQzMiA6IHRoaXMuZHluYW1pY0RhdGEsIHRoaXMuZHluYW1pY1N0cmlkZSwgcHJvcGVydHkub2Zmc2V0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5keW5hbWljQnVmZmVyLl91cGRhdGVJRCsrO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBVcGxvYWRzIHRoZSBzdGF0aWMgcHJvcGVydGllcy5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtQSVhJLkRpc3BsYXlPYmplY3RbXX0gY2hpbGRyZW4gLSBUaGUgY2hpbGRyZW4gdG8gdXBsb2FkLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0SW5kZXggLSBUaGUgaW5kZXggdG8gc3RhcnQgYXQuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYW1vdW50IC0gVGhlIG51bWJlciB0byB1cGxvYWQuXHJcbiAgICAgKi9cclxuICAgIHVwbG9hZFN0YXRpYyhjaGlsZHJlbiwgc3RhcnRJbmRleCwgYW1vdW50KSB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnN0YXRpY1Byb3BlcnRpZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIHByb3BlcnR5ID0gdGhpcy5zdGF0aWNQcm9wZXJ0aWVzW2ldO1xyXG4gICAgICAgICAgICBwcm9wZXJ0eS51cGxvYWRGdW5jdGlvbihjaGlsZHJlbiwgc3RhcnRJbmRleCwgYW1vdW50LCBwcm9wZXJ0eS50eXBlID09PSBXZWJHTFNldHRpbmdzXzEuV2ViR0xTZXR0aW5ncy5UWVBFUy5VTlNJR05FRF9CWVRFID8gdGhpcy5zdGF0aWNEYXRhVWludDMyIDogdGhpcy5zdGF0aWNEYXRhLCB0aGlzLnN0YXRpY1N0cmlkZSwgcHJvcGVydHkub2Zmc2V0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zdGF0aWNCdWZmZXIuX3VwZGF0ZUlEKys7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIERlc3Ryb3lzIHRoZSBQYXJ0aWNsZUJ1ZmZlci5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBkZXN0cm95KCkge1xyXG4gICAgICAgIHRoaXMuaW5kZXhCdWZmZXIgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuZHluYW1pY1Byb3BlcnRpZXMgPSBudWxsO1xyXG4gICAgICAgIC8vIHRoaXMuZHluYW1pY0J1ZmZlci5kZXN0cm95KCk7XHJcbiAgICAgICAgdGhpcy5keW5hbWljQnVmZmVyID0gbnVsbDtcclxuICAgICAgICB0aGlzLmR5bmFtaWNEYXRhID0gbnVsbDtcclxuICAgICAgICB0aGlzLmR5bmFtaWNEYXRhVWludDMyID0gbnVsbDtcclxuICAgICAgICB0aGlzLnN0YXRpY1Byb3BlcnRpZXMgPSBudWxsO1xyXG4gICAgICAgIC8vIHRoaXMuc3RhdGljQnVmZmVyLmRlc3Ryb3koKTtcclxuICAgICAgICB0aGlzLnN0YXRpY0J1ZmZlciA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5zdGF0aWNEYXRhID0gbnVsbDtcclxuICAgICAgICB0aGlzLnN0YXRpY0RhdGFVaW50MzIgPSBudWxsO1xyXG4gICAgICAgIC8vIGFsbCBidWZmZXJzIGFyZSBkZXN0cm95ZWQgaW5zaWRlIGdlb21ldHJ5XHJcbiAgICAgICAgdGhpcy5nZW9tZXRyeS5kZXN0cm95KCk7XHJcbiAgICB9XHJcbiAgICA7XHJcbn1cclxuZXhwb3J0cy5QYXJ0aWNsZUJ1ZmZlciA9IFBhcnRpY2xlQnVmZmVyO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBPYmplY3RSZW5kZXJlcl8xID0gcmVxdWlyZShcIi4vT2JqZWN0UmVuZGVyZXJcIik7XHJcbmNvbnN0IE1hdHJpeF8xID0gcmVxdWlyZShcIi4vTWF0cml4XCIpO1xyXG5jb25zdCBTaGFkZXJfMSA9IHJlcXVpcmUoXCIuL1NoYWRlclwiKTtcclxuY29uc3QgUGFydGljbGVCdWZmZXJfMSA9IHJlcXVpcmUoXCIuL1BhcnRpY2xlQnVmZmVyXCIpO1xyXG5jb25zdCBDb2xvclNldHRpbmdzXzEgPSByZXF1aXJlKFwiLi9Db2xvclNldHRpbmdzXCIpO1xyXG5jb25zdCBCbGVuZE1vZGVzU2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL0JsZW5kTW9kZXNTZXR0aW5nc1wiKTtcclxuY29uc3QgV2ViR0xTZXR0aW5nc18xID0gcmVxdWlyZShcIi4vV2ViR0xTZXR0aW5nc1wiKTtcclxuY2xhc3MgUGFydGljbGVSZW5kZXJlciBleHRlbmRzIE9iamVjdFJlbmRlcmVyXzEuT2JqZWN0UmVuZGVyZXIge1xyXG4gICAgY29uc3RydWN0b3IocmVuZGVyZXIpIHtcclxuICAgICAgICBzdXBlcihyZW5kZXJlcik7XHJcbiAgICAgICAgLy8gNjU1MzUgaXMgbWF4IHZlcnRleCBpbmRleCBpbiB0aGUgaW5kZXggYnVmZmVyIChzZWUgUGFydGljbGVSZW5kZXJlcilcclxuICAgICAgICAvLyBzbyBtYXggbnVtYmVyIG9mIHBhcnRpY2xlcyBpcyA2NTUzNiAvIDQgPSAxNjM4NFxyXG4gICAgICAgIC8vIGFuZCBtYXggbnVtYmVyIG9mIGVsZW1lbnQgaW4gdGhlIGluZGV4IGJ1ZmZlciBpcyAxNjM4NCAqIDYgPSA5ODMwNFxyXG4gICAgICAgIC8vIENyZWF0aW5nIGEgZnVsbCBpbmRleCBidWZmZXIsIG92ZXJoZWFkIGlzIDk4MzA0ICogMiA9IDE5NktvXHJcbiAgICAgICAgLy8gbGV0IG51bUluZGljZXMgPSA5ODMwNDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgZGVmYXVsdCBzaGFkZXIgdGhhdCBpcyB1c2VkIGlmIGEgc3ByaXRlIGRvZXNuJ3QgaGF2ZSBhIG1vcmUgc3BlY2lmaWMgb25lLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQG1lbWJlciB7UElYSS5TaGFkZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5zaGFkZXIgPSBudWxsO1xyXG4gICAgICAgIHRoaXMucHJvcGVydGllcyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy50ZW1wTWF0cml4ID0gbmV3IE1hdHJpeF8xLk1hdHJpeCgpO1xyXG4gICAgICAgIHRoaXMucHJvcGVydGllcyA9IFtcclxuICAgICAgICAgICAgLy8gdmVydGljZXNEYXRhXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZU5hbWU6ICdhVmVydGV4UG9zaXRpb24nLFxyXG4gICAgICAgICAgICAgICAgc2l6ZTogMixcclxuICAgICAgICAgICAgICAgIHVwbG9hZEZ1bmN0aW9uOiB0aGlzLnVwbG9hZFZlcnRpY2VzLFxyXG4gICAgICAgICAgICAgICAgb2Zmc2V0OiAwLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAvLyBwb3NpdGlvbkRhdGFcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlTmFtZTogJ2FQb3NpdGlvbkNvb3JkJyxcclxuICAgICAgICAgICAgICAgIHNpemU6IDIsXHJcbiAgICAgICAgICAgICAgICB1cGxvYWRGdW5jdGlvbjogdGhpcy51cGxvYWRQb3NpdGlvbixcclxuICAgICAgICAgICAgICAgIG9mZnNldDogMCxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgLy8gcm90YXRpb25EYXRhXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZU5hbWU6ICdhUm90YXRpb24nLFxyXG4gICAgICAgICAgICAgICAgc2l6ZTogMSxcclxuICAgICAgICAgICAgICAgIHVwbG9hZEZ1bmN0aW9uOiB0aGlzLnVwbG9hZFJvdGF0aW9uLFxyXG4gICAgICAgICAgICAgICAgb2Zmc2V0OiAwLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAvLyB1dnNEYXRhXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZU5hbWU6ICdhVGV4dHVyZUNvb3JkJyxcclxuICAgICAgICAgICAgICAgIHNpemU6IDIsXHJcbiAgICAgICAgICAgICAgICB1cGxvYWRGdW5jdGlvbjogdGhpcy51cGxvYWRVdnMsXHJcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IDAsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIC8vIHRpbnREYXRhXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZU5hbWU6ICdhQ29sb3InLFxyXG4gICAgICAgICAgICAgICAgc2l6ZTogMSxcclxuICAgICAgICAgICAgICAgIHR5cGU6IFdlYkdMU2V0dGluZ3NfMS5XZWJHTFNldHRpbmdzLlRZUEVTLlVOU0lHTkVEX0JZVEUsXHJcbiAgICAgICAgICAgICAgICB1cGxvYWRGdW5jdGlvbjogdGhpcy51cGxvYWRUaW50LFxyXG4gICAgICAgICAgICAgICAgb2Zmc2V0OiAwLFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgXTtcclxuICAgICAgICB0aGlzLnNoYWRlciA9IFNoYWRlcl8xLlNoYWRlci5mcm9tKFBhcnRpY2xlUmVuZGVyZXIudmVydGV4JDIsIFBhcnRpY2xlUmVuZGVyZXIuZnJhZ21lbnQkMSwge30pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW5kZXJzIHRoZSBwYXJ0aWNsZSBjb250YWluZXIgb2JqZWN0LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7UElYSS5QYXJ0aWNsZUNvbnRhaW5lcn0gY29udGFpbmVyIC0gVGhlIGNvbnRhaW5lciB0byByZW5kZXIgdXNpbmcgdGhpcyBQYXJ0aWNsZVJlbmRlcmVyXHJcbiAgICAgKi9cclxuICAgIHJlbmRlcihjb250YWluZXIpIHtcclxuICAgICAgICB2YXIgY2hpbGRyZW4gPSBjb250YWluZXIuY2hpbGRyZW47XHJcbiAgICAgICAgdmFyIG1heFNpemUgPSBjb250YWluZXIuX21heFNpemU7XHJcbiAgICAgICAgdmFyIGJhdGNoU2l6ZSA9IGNvbnRhaW5lci5fYmF0Y2hTaXplO1xyXG4gICAgICAgIHZhciByZW5kZXJlciA9IHRoaXMucmVuZGVyZXI7XHJcbiAgICAgICAgdmFyIHRvdGFsQ2hpbGRyZW4gPSBjaGlsZHJlbi5sZW5ndGg7XHJcbiAgICAgICAgaWYgKHRvdGFsQ2hpbGRyZW4gPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0b3RhbENoaWxkcmVuID4gbWF4U2l6ZSkge1xyXG4gICAgICAgICAgICB0b3RhbENoaWxkcmVuID0gbWF4U2l6ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGJ1ZmZlcnMgPSBjb250YWluZXIuX2J1ZmZlcnM7XHJcbiAgICAgICAgaWYgKCFidWZmZXJzKSB7XHJcbiAgICAgICAgICAgIGJ1ZmZlcnMgPSBjb250YWluZXIuX2J1ZmZlcnMgPSB0aGlzLmdlbmVyYXRlQnVmZmVycyhjb250YWluZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgYmFzZVRleHR1cmUgPSBjaGlsZHJlblswXS5fdGV4dHVyZS5iYXNlVGV4dHVyZTtcclxuICAgICAgICAvLyBpZiB0aGUgdXZzIGhhdmUgbm90IHVwZGF0ZWQgdGhlbiBubyBwb2ludCByZW5kZXJpbmcganVzdCB5ZXQhXHJcbiAgICAgICAgdGhpcy5yZW5kZXJlci5zdGF0ZS5zZXRCbGVuZE1vZGUoQmxlbmRNb2Rlc1NldHRpbmdzXzEuQmxlbmRNb2Rlc1NldHRpbmdzLmNvcnJlY3RCbGVuZE1vZGUoY29udGFpbmVyLmJsZW5kTW9kZSwgYmFzZVRleHR1cmUucHJlbXVsdGlwbHlBbHBoYSkpO1xyXG4gICAgICAgIHZhciBnbCA9IHJlbmRlcmVyLmdsO1xyXG4gICAgICAgIHZhciBtID0gY29udGFpbmVyLndvcmxkVHJhbnNmb3JtLmNvcHlUbyh0aGlzLnRlbXBNYXRyaXgpO1xyXG4gICAgICAgIG0ucHJlcGVuZChyZW5kZXJlci5nbG9iYWxVbmlmb3Jtcy51bmlmb3Jtcy5wcm9qZWN0aW9uTWF0cml4KTtcclxuICAgICAgICB0aGlzLnNoYWRlci51bmlmb3Jtcy50cmFuc2xhdGlvbk1hdHJpeCA9IG0udG9BcnJheSh0cnVlKTtcclxuICAgICAgICB0aGlzLnNoYWRlci51bmlmb3Jtcy51Q29sb3IgPSBDb2xvclNldHRpbmdzXzEuQ29sb3JTZXR0aW5ncy5wcmVtdWx0aXBseVJnYmEoY29udGFpbmVyLnRpbnRSZ2IsIGNvbnRhaW5lci53b3JsZEFscGhhLCB0aGlzLnNoYWRlci51bmlmb3Jtcy51Q29sb3IsIGJhc2VUZXh0dXJlLnByZW11bHRpcGx5QWxwaGEpO1xyXG4gICAgICAgIHRoaXMuc2hhZGVyLnVuaWZvcm1zLnVTYW1wbGVyID0gYmFzZVRleHR1cmU7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJlci5zaGFkZXIuYmluZCh0aGlzLnNoYWRlcik7XHJcbiAgICAgICAgdmFyIHVwZGF0ZVN0YXRpYyA9IGZhbHNlO1xyXG4gICAgICAgIC8vIG5vdyBsZXRzIHVwbG9hZCBhbmQgcmVuZGVyIHRoZSBidWZmZXJzLi5cclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgaiA9IDA7IGkgPCB0b3RhbENoaWxkcmVuOyBpICs9IGJhdGNoU2l6ZSwgaiArPSAxKSB7XHJcbiAgICAgICAgICAgIHZhciBhbW91bnQgPSAodG90YWxDaGlsZHJlbiAtIGkpO1xyXG4gICAgICAgICAgICBpZiAoYW1vdW50ID4gYmF0Y2hTaXplKSB7XHJcbiAgICAgICAgICAgICAgICBhbW91bnQgPSBiYXRjaFNpemU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGogPj0gYnVmZmVycy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIGlmICghY29udGFpbmVyLmF1dG9SZXNpemUpIHtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJ1ZmZlcnMucHVzaCh0aGlzLl9nZW5lcmF0ZU9uZU1vcmVCdWZmZXIoY29udGFpbmVyKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGJ1ZmZlciA9IGJ1ZmZlcnNbal07XHJcbiAgICAgICAgICAgIC8vIHdlIGFsd2F5cyB1cGxvYWQgdGhlIGR5bmFtaWNcclxuICAgICAgICAgICAgYnVmZmVyLnVwbG9hZER5bmFtaWMoY2hpbGRyZW4sIGksIGFtb3VudCk7XHJcbiAgICAgICAgICAgIHZhciBiaWQgPSBjb250YWluZXIuX2J1ZmZlclVwZGF0ZUlEc1tqXSB8fCAwO1xyXG4gICAgICAgICAgICB1cGRhdGVTdGF0aWMgPSB1cGRhdGVTdGF0aWMgfHwgKGJ1ZmZlci5fdXBkYXRlSUQgPCBiaWQpO1xyXG4gICAgICAgICAgICAvLyB3ZSBvbmx5IHVwbG9hZCB0aGUgc3RhdGljIGNvbnRlbnQgd2hlbiB3ZSBoYXZlIHRvIVxyXG4gICAgICAgICAgICBpZiAodXBkYXRlU3RhdGljKSB7XHJcbiAgICAgICAgICAgICAgICBidWZmZXIuX3VwZGF0ZUlEID0gY29udGFpbmVyLl91cGRhdGVJRDtcclxuICAgICAgICAgICAgICAgIGJ1ZmZlci51cGxvYWRTdGF0aWMoY2hpbGRyZW4sIGksIGFtb3VudCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gYmluZCB0aGUgYnVmZmVyXHJcbiAgICAgICAgICAgIHJlbmRlcmVyLmdlb21ldHJ5LmJpbmQoYnVmZmVyLmdlb21ldHJ5KTtcclxuICAgICAgICAgICAgZ2wuZHJhd0VsZW1lbnRzKGdsLlRSSUFOR0xFUywgYW1vdW50ICogNiwgZ2wuVU5TSUdORURfU0hPUlQsIDApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBvbmUgcGFydGljbGUgYnVmZmVyIGZvciBlYWNoIGNoaWxkIGluIHRoZSBjb250YWluZXIgd2Ugd2FudCB0byByZW5kZXIgYW5kIHVwZGF0ZXMgaW50ZXJuYWwgcHJvcGVydGllc1xyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7UElYSS5QYXJ0aWNsZUNvbnRhaW5lcn0gY29udGFpbmVyIC0gVGhlIGNvbnRhaW5lciB0byByZW5kZXIgdXNpbmcgdGhpcyBQYXJ0aWNsZVJlbmRlcmVyXHJcbiAgICAgKiBAcmV0dXJuIHtQSVhJLlBhcnRpY2xlQnVmZmVyW119IFRoZSBidWZmZXJzXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBnZW5lcmF0ZUJ1ZmZlcnMoY29udGFpbmVyKSB7XHJcbiAgICAgICAgdmFyIGJ1ZmZlcnMgPSBbXTtcclxuICAgICAgICB2YXIgc2l6ZSA9IGNvbnRhaW5lci5fbWF4U2l6ZTtcclxuICAgICAgICB2YXIgYmF0Y2hTaXplID0gY29udGFpbmVyLl9iYXRjaFNpemU7XHJcbiAgICAgICAgdmFyIGR5bmFtaWNQcm9wZXJ0eUZsYWdzID0gY29udGFpbmVyLl9wcm9wZXJ0aWVzO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSArPSBiYXRjaFNpemUpIHtcclxuICAgICAgICAgICAgYnVmZmVycy5wdXNoKG5ldyBQYXJ0aWNsZUJ1ZmZlcl8xLlBhcnRpY2xlQnVmZmVyKHRoaXMucHJvcGVydGllcywgZHluYW1pY1Byb3BlcnR5RmxhZ3MsIGJhdGNoU2l6ZSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYnVmZmVycztcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBvbmUgbW9yZSBwYXJ0aWNsZSBidWZmZXIsIGJlY2F1c2UgY29udGFpbmVyIGhhcyBhdXRvUmVzaXplIGZlYXR1cmVcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1BJWEkuUGFydGljbGVDb250YWluZXJ9IGNvbnRhaW5lciAtIFRoZSBjb250YWluZXIgdG8gcmVuZGVyIHVzaW5nIHRoaXMgUGFydGljbGVSZW5kZXJlclxyXG4gICAgICogQHJldHVybiB7UElYSS5QYXJ0aWNsZUJ1ZmZlcn0gZ2VuZXJhdGVkIGJ1ZmZlclxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgX2dlbmVyYXRlT25lTW9yZUJ1ZmZlcihjb250YWluZXIpIHtcclxuICAgICAgICB2YXIgYmF0Y2hTaXplID0gY29udGFpbmVyLl9iYXRjaFNpemU7XHJcbiAgICAgICAgdmFyIGR5bmFtaWNQcm9wZXJ0eUZsYWdzID0gY29udGFpbmVyLl9wcm9wZXJ0aWVzO1xyXG4gICAgICAgIHJldHVybiBuZXcgUGFydGljbGVCdWZmZXJfMS5QYXJ0aWNsZUJ1ZmZlcih0aGlzLnByb3BlcnRpZXMsIGR5bmFtaWNQcm9wZXJ0eUZsYWdzLCBiYXRjaFNpemUpO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBVcGxvYWRzIHRoZSB2ZXJ0aWNlcy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1BJWEkuRGlzcGxheU9iamVjdFtdfSBjaGlsZHJlbiAtIHRoZSBhcnJheSBvZiBkaXNwbGF5IG9iamVjdHMgdG8gcmVuZGVyXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnRJbmRleCAtIHRoZSBpbmRleCB0byBzdGFydCBmcm9tIGluIHRoZSBjaGlsZHJlbiBhcnJheVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGFtb3VudCAtIHRoZSBhbW91bnQgb2YgY2hpbGRyZW4gdGhhdCB3aWxsIGhhdmUgdGhlaXIgdmVydGljZXMgdXBsb2FkZWRcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyW119IGFycmF5IC0gVGhlIHZlcnRpY2VzIHRvIHVwbG9hZC5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgLSBTdHJpZGUgdG8gdXNlIGZvciBpdGVyYXRpb24uXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IC0gT2Zmc2V0IHRvIHN0YXJ0IGF0LlxyXG4gICAgICovXHJcbiAgICB1cGxvYWRWZXJ0aWNlcyhjaGlsZHJlbiwgc3RhcnRJbmRleCwgYW1vdW50LCBhcnJheSwgc3RyaWRlLCBvZmZzZXQpIHtcclxuICAgICAgICB2YXIgdzAgPSAwO1xyXG4gICAgICAgIHZhciB3MSA9IDA7XHJcbiAgICAgICAgdmFyIGgwID0gMDtcclxuICAgICAgICB2YXIgaDEgPSAwO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYW1vdW50OyArK2kpIHtcclxuICAgICAgICAgICAgdmFyIHNwcml0ZSA9IGNoaWxkcmVuW3N0YXJ0SW5kZXggKyBpXTtcclxuICAgICAgICAgICAgdmFyIHRleHR1cmUgPSBzcHJpdGUuX3RleHR1cmU7XHJcbiAgICAgICAgICAgIHZhciBzeCA9IHNwcml0ZS5zY2FsZS54O1xyXG4gICAgICAgICAgICB2YXIgc3kgPSBzcHJpdGUuc2NhbGUueTtcclxuICAgICAgICAgICAgdmFyIHRyaW0gPSB0ZXh0dXJlLnRyaW07XHJcbiAgICAgICAgICAgIHZhciBvcmlnID0gdGV4dHVyZS5vcmlnO1xyXG4gICAgICAgICAgICBpZiAodHJpbSkge1xyXG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlIHNwcml0ZSBpcyB0cmltbWVkIGFuZCBpcyBub3QgYSB0aWxpbmdzcHJpdGUgdGhlbiB3ZSBuZWVkIHRvIGFkZCB0aGVcclxuICAgICAgICAgICAgICAgIC8vIGV4dHJhIHNwYWNlIGJlZm9yZSB0cmFuc2Zvcm1pbmcgdGhlIHNwcml0ZSBjb29yZHMuLlxyXG4gICAgICAgICAgICAgICAgdzEgPSB0cmltLnggLSAoc3ByaXRlLmFuY2hvci54ICogb3JpZy53aWR0aCk7XHJcbiAgICAgICAgICAgICAgICB3MCA9IHcxICsgdHJpbS53aWR0aDtcclxuICAgICAgICAgICAgICAgIGgxID0gdHJpbS55IC0gKHNwcml0ZS5hbmNob3IueSAqIG9yaWcuaGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgIGgwID0gaDEgKyB0cmltLmhlaWdodDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHcwID0gKG9yaWcud2lkdGgpICogKDEgLSBzcHJpdGUuYW5jaG9yLngpO1xyXG4gICAgICAgICAgICAgICAgdzEgPSAob3JpZy53aWR0aCkgKiAtc3ByaXRlLmFuY2hvci54O1xyXG4gICAgICAgICAgICAgICAgaDAgPSBvcmlnLmhlaWdodCAqICgxIC0gc3ByaXRlLmFuY2hvci55KTtcclxuICAgICAgICAgICAgICAgIGgxID0gb3JpZy5oZWlnaHQgKiAtc3ByaXRlLmFuY2hvci55O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGFycmF5W29mZnNldF0gPSB3MSAqIHN4O1xyXG4gICAgICAgICAgICBhcnJheVtvZmZzZXQgKyAxXSA9IGgxICogc3k7XHJcbiAgICAgICAgICAgIGFycmF5W29mZnNldCArIHN0cmlkZV0gPSB3MCAqIHN4O1xyXG4gICAgICAgICAgICBhcnJheVtvZmZzZXQgKyBzdHJpZGUgKyAxXSA9IGgxICogc3k7XHJcbiAgICAgICAgICAgIGFycmF5W29mZnNldCArIChzdHJpZGUgKiAyKV0gPSB3MCAqIHN4O1xyXG4gICAgICAgICAgICBhcnJheVtvZmZzZXQgKyAoc3RyaWRlICogMikgKyAxXSA9IGgwICogc3k7XHJcbiAgICAgICAgICAgIGFycmF5W29mZnNldCArIChzdHJpZGUgKiAzKV0gPSB3MSAqIHN4O1xyXG4gICAgICAgICAgICBhcnJheVtvZmZzZXQgKyAoc3RyaWRlICogMykgKyAxXSA9IGgwICogc3k7XHJcbiAgICAgICAgICAgIG9mZnNldCArPSBzdHJpZGUgKiA0O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogVXBsb2FkcyB0aGUgcG9zaXRpb24uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtQSVhJLkRpc3BsYXlPYmplY3RbXX0gY2hpbGRyZW4gLSB0aGUgYXJyYXkgb2YgZGlzcGxheSBvYmplY3RzIHRvIHJlbmRlclxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0SW5kZXggLSB0aGUgaW5kZXggdG8gc3RhcnQgZnJvbSBpbiB0aGUgY2hpbGRyZW4gYXJyYXlcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhbW91bnQgLSB0aGUgYW1vdW50IG9mIGNoaWxkcmVuIHRoYXQgd2lsbCBoYXZlIHRoZWlyIHBvc2l0aW9ucyB1cGxvYWRlZFxyXG4gICAgICogQHBhcmFtIHtudW1iZXJbXX0gYXJyYXkgLSBUaGUgdmVydGljZXMgdG8gdXBsb2FkLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSAtIFN0cmlkZSB0byB1c2UgZm9yIGl0ZXJhdGlvbi5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgLSBPZmZzZXQgdG8gc3RhcnQgYXQuXHJcbiAgICAgKi9cclxuICAgIHVwbG9hZFBvc2l0aW9uKGNoaWxkcmVuLCBzdGFydEluZGV4LCBhbW91bnQsIGFycmF5LCBzdHJpZGUsIG9mZnNldCkge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYW1vdW50OyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIHNwcml0ZVBvc2l0aW9uID0gY2hpbGRyZW5bc3RhcnRJbmRleCArIGldLnBvc2l0aW9uO1xyXG4gICAgICAgICAgICBhcnJheVtvZmZzZXRdID0gc3ByaXRlUG9zaXRpb24ueDtcclxuICAgICAgICAgICAgYXJyYXlbb2Zmc2V0ICsgMV0gPSBzcHJpdGVQb3NpdGlvbi55O1xyXG4gICAgICAgICAgICBhcnJheVtvZmZzZXQgKyBzdHJpZGVdID0gc3ByaXRlUG9zaXRpb24ueDtcclxuICAgICAgICAgICAgYXJyYXlbb2Zmc2V0ICsgc3RyaWRlICsgMV0gPSBzcHJpdGVQb3NpdGlvbi55O1xyXG4gICAgICAgICAgICBhcnJheVtvZmZzZXQgKyAoc3RyaWRlICogMildID0gc3ByaXRlUG9zaXRpb24ueDtcclxuICAgICAgICAgICAgYXJyYXlbb2Zmc2V0ICsgKHN0cmlkZSAqIDIpICsgMV0gPSBzcHJpdGVQb3NpdGlvbi55O1xyXG4gICAgICAgICAgICBhcnJheVtvZmZzZXQgKyAoc3RyaWRlICogMyldID0gc3ByaXRlUG9zaXRpb24ueDtcclxuICAgICAgICAgICAgYXJyYXlbb2Zmc2V0ICsgKHN0cmlkZSAqIDMpICsgMV0gPSBzcHJpdGVQb3NpdGlvbi55O1xyXG4gICAgICAgICAgICBvZmZzZXQgKz0gc3RyaWRlICogNDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFVwbG9hZHMgdGhlIHJvdGlhdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1BJWEkuRGlzcGxheU9iamVjdFtdfSBjaGlsZHJlbiAtIHRoZSBhcnJheSBvZiBkaXNwbGF5IG9iamVjdHMgdG8gcmVuZGVyXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnRJbmRleCAtIHRoZSBpbmRleCB0byBzdGFydCBmcm9tIGluIHRoZSBjaGlsZHJlbiBhcnJheVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGFtb3VudCAtIHRoZSBhbW91bnQgb2YgY2hpbGRyZW4gdGhhdCB3aWxsIGhhdmUgdGhlaXIgcm90YXRpb24gdXBsb2FkZWRcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyW119IGFycmF5IC0gVGhlIHZlcnRpY2VzIHRvIHVwbG9hZC5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgLSBTdHJpZGUgdG8gdXNlIGZvciBpdGVyYXRpb24uXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IC0gT2Zmc2V0IHRvIHN0YXJ0IGF0LlxyXG4gICAgICovXHJcbiAgICB1cGxvYWRSb3RhdGlvbihjaGlsZHJlbiwgc3RhcnRJbmRleCwgYW1vdW50LCBhcnJheSwgc3RyaWRlLCBvZmZzZXQpIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFtb3VudDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBzcHJpdGVSb3RhdGlvbiA9IGNoaWxkcmVuW3N0YXJ0SW5kZXggKyBpXS5yb3RhdGlvbjtcclxuICAgICAgICAgICAgYXJyYXlbb2Zmc2V0XSA9IHNwcml0ZVJvdGF0aW9uO1xyXG4gICAgICAgICAgICBhcnJheVtvZmZzZXQgKyBzdHJpZGVdID0gc3ByaXRlUm90YXRpb247XHJcbiAgICAgICAgICAgIGFycmF5W29mZnNldCArIChzdHJpZGUgKiAyKV0gPSBzcHJpdGVSb3RhdGlvbjtcclxuICAgICAgICAgICAgYXJyYXlbb2Zmc2V0ICsgKHN0cmlkZSAqIDMpXSA9IHNwcml0ZVJvdGF0aW9uO1xyXG4gICAgICAgICAgICBvZmZzZXQgKz0gc3RyaWRlICogNDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFVwbG9hZHMgdGhlIFV2c1xyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7UElYSS5EaXNwbGF5T2JqZWN0W119IGNoaWxkcmVuIC0gdGhlIGFycmF5IG9mIGRpc3BsYXkgb2JqZWN0cyB0byByZW5kZXJcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydEluZGV4IC0gdGhlIGluZGV4IHRvIHN0YXJ0IGZyb20gaW4gdGhlIGNoaWxkcmVuIGFycmF5XHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYW1vdW50IC0gdGhlIGFtb3VudCBvZiBjaGlsZHJlbiB0aGF0IHdpbGwgaGF2ZSB0aGVpciByb3RhdGlvbiB1cGxvYWRlZFxyXG4gICAgICogQHBhcmFtIHtudW1iZXJbXX0gYXJyYXkgLSBUaGUgdmVydGljZXMgdG8gdXBsb2FkLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSAtIFN0cmlkZSB0byB1c2UgZm9yIGl0ZXJhdGlvbi5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgLSBPZmZzZXQgdG8gc3RhcnQgYXQuXHJcbiAgICAgKi9cclxuICAgIHVwbG9hZFV2cyhjaGlsZHJlbiwgc3RhcnRJbmRleCwgYW1vdW50LCBhcnJheSwgc3RyaWRlLCBvZmZzZXQpIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFtb3VudDsgKytpKSB7XHJcbiAgICAgICAgICAgIHZhciB0ZXh0dXJlVXZzID0gY2hpbGRyZW5bc3RhcnRJbmRleCArIGldLl90ZXh0dXJlLl91dnM7XHJcbiAgICAgICAgICAgIGlmICh0ZXh0dXJlVXZzKSB7XHJcbiAgICAgICAgICAgICAgICBhcnJheVtvZmZzZXRdID0gdGV4dHVyZVV2cy54MDtcclxuICAgICAgICAgICAgICAgIGFycmF5W29mZnNldCArIDFdID0gdGV4dHVyZVV2cy55MDtcclxuICAgICAgICAgICAgICAgIGFycmF5W29mZnNldCArIHN0cmlkZV0gPSB0ZXh0dXJlVXZzLngxO1xyXG4gICAgICAgICAgICAgICAgYXJyYXlbb2Zmc2V0ICsgc3RyaWRlICsgMV0gPSB0ZXh0dXJlVXZzLnkxO1xyXG4gICAgICAgICAgICAgICAgYXJyYXlbb2Zmc2V0ICsgKHN0cmlkZSAqIDIpXSA9IHRleHR1cmVVdnMueDI7XHJcbiAgICAgICAgICAgICAgICBhcnJheVtvZmZzZXQgKyAoc3RyaWRlICogMikgKyAxXSA9IHRleHR1cmVVdnMueTI7XHJcbiAgICAgICAgICAgICAgICBhcnJheVtvZmZzZXQgKyAoc3RyaWRlICogMyldID0gdGV4dHVyZVV2cy54MztcclxuICAgICAgICAgICAgICAgIGFycmF5W29mZnNldCArIChzdHJpZGUgKiAzKSArIDFdID0gdGV4dHVyZVV2cy55MztcclxuICAgICAgICAgICAgICAgIG9mZnNldCArPSBzdHJpZGUgKiA0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gVE9ETyB5b3Uga25vdyB0aGlzIGNhbiBiZSBlYXNpZXIhXHJcbiAgICAgICAgICAgICAgICBhcnJheVtvZmZzZXRdID0gMDtcclxuICAgICAgICAgICAgICAgIGFycmF5W29mZnNldCArIDFdID0gMDtcclxuICAgICAgICAgICAgICAgIGFycmF5W29mZnNldCArIHN0cmlkZV0gPSAwO1xyXG4gICAgICAgICAgICAgICAgYXJyYXlbb2Zmc2V0ICsgc3RyaWRlICsgMV0gPSAwO1xyXG4gICAgICAgICAgICAgICAgYXJyYXlbb2Zmc2V0ICsgKHN0cmlkZSAqIDIpXSA9IDA7XHJcbiAgICAgICAgICAgICAgICBhcnJheVtvZmZzZXQgKyAoc3RyaWRlICogMikgKyAxXSA9IDA7XHJcbiAgICAgICAgICAgICAgICBhcnJheVtvZmZzZXQgKyAoc3RyaWRlICogMyldID0gMDtcclxuICAgICAgICAgICAgICAgIGFycmF5W29mZnNldCArIChzdHJpZGUgKiAzKSArIDFdID0gMDtcclxuICAgICAgICAgICAgICAgIG9mZnNldCArPSBzdHJpZGUgKiA0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBVcGxvYWRzIHRoZSB0aW50LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7UElYSS5EaXNwbGF5T2JqZWN0W119IGNoaWxkcmVuIC0gdGhlIGFycmF5IG9mIGRpc3BsYXkgb2JqZWN0cyB0byByZW5kZXJcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydEluZGV4IC0gdGhlIGluZGV4IHRvIHN0YXJ0IGZyb20gaW4gdGhlIGNoaWxkcmVuIGFycmF5XHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYW1vdW50IC0gdGhlIGFtb3VudCBvZiBjaGlsZHJlbiB0aGF0IHdpbGwgaGF2ZSB0aGVpciByb3RhdGlvbiB1cGxvYWRlZFxyXG4gICAgICogQHBhcmFtIHtudW1iZXJbXX0gYXJyYXkgLSBUaGUgdmVydGljZXMgdG8gdXBsb2FkLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSAtIFN0cmlkZSB0byB1c2UgZm9yIGl0ZXJhdGlvbi5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgLSBPZmZzZXQgdG8gc3RhcnQgYXQuXHJcbiAgICAgKi9cclxuICAgIHVwbG9hZFRpbnQoY2hpbGRyZW4sIHN0YXJ0SW5kZXgsIGFtb3VudCwgYXJyYXksIHN0cmlkZSwgb2Zmc2V0KSB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbW91bnQ7ICsraSkge1xyXG4gICAgICAgICAgICB2YXIgc3ByaXRlID0gY2hpbGRyZW5bc3RhcnRJbmRleCArIGldO1xyXG4gICAgICAgICAgICB2YXIgcHJlbXVsdGlwbGllZCA9IHNwcml0ZS5fdGV4dHVyZS5iYXNlVGV4dHVyZS5wcmVtdWx0aXBseUFscGhhO1xyXG4gICAgICAgICAgICB2YXIgYWxwaGEgPSBzcHJpdGUuYWxwaGE7XHJcbiAgICAgICAgICAgIC8vIHdlIGRvbnQgY2FsbCBleHRyYSBmdW5jdGlvbiBpZiBhbHBoYSBpcyAxLjAsIHRoYXQncyBmYXN0ZXJcclxuICAgICAgICAgICAgdmFyIGFyZ2IgPSBhbHBoYSA8IDEuMCAmJiBwcmVtdWx0aXBsaWVkID8gQ29sb3JTZXR0aW5nc18xLkNvbG9yU2V0dGluZ3MucHJlbXVsdGlwbHlUaW50KHNwcml0ZS5fdGludFJHQiwgYWxwaGEpXHJcbiAgICAgICAgICAgICAgICA6IHNwcml0ZS5fdGludFJHQiArIChhbHBoYSAqIDI1NSA8PCAyNCk7XHJcbiAgICAgICAgICAgIGFycmF5W29mZnNldF0gPSBhcmdiO1xyXG4gICAgICAgICAgICBhcnJheVtvZmZzZXQgKyBzdHJpZGVdID0gYXJnYjtcclxuICAgICAgICAgICAgYXJyYXlbb2Zmc2V0ICsgKHN0cmlkZSAqIDIpXSA9IGFyZ2I7XHJcbiAgICAgICAgICAgIGFycmF5W29mZnNldCArIChzdHJpZGUgKiAzKV0gPSBhcmdiO1xyXG4gICAgICAgICAgICBvZmZzZXQgKz0gc3RyaWRlICogNDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIERlc3Ryb3lzIHRoZSBQYXJ0aWNsZVJlbmRlcmVyLlxyXG4gICAgICovXHJcbiAgICBkZXN0cm95KCkge1xyXG4gICAgICAgIHN1cGVyLmRlc3Ryb3koKTtcclxuICAgICAgICBpZiAodGhpcy5zaGFkZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5zaGFkZXIuZGVzdHJveSgpO1xyXG4gICAgICAgICAgICB0aGlzLnNoYWRlciA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMudGVtcE1hdHJpeCA9IG51bGw7XHJcbiAgICB9XHJcbiAgICA7XHJcbn1cclxuUGFydGljbGVSZW5kZXJlci52ZXJ0ZXgkMiA9IFwiYXR0cmlidXRlIHZlYzIgYVZlcnRleFBvc2l0aW9uO1xcclxcbmF0dHJpYnV0ZSB2ZWMyIGFUZXh0dXJlQ29vcmQ7XFxyXFxuYXR0cmlidXRlIHZlYzQgYUNvbG9yO1xcclxcblxcclxcbmF0dHJpYnV0ZSB2ZWMyIGFQb3NpdGlvbkNvb3JkO1xcclxcbmF0dHJpYnV0ZSBmbG9hdCBhUm90YXRpb247XFxyXFxuXFxyXFxudW5pZm9ybSBtYXQzIHRyYW5zbGF0aW9uTWF0cml4O1xcclxcbnVuaWZvcm0gdmVjNCB1Q29sb3I7XFxyXFxuXFxyXFxudmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XFxyXFxudmFyeWluZyB2ZWM0IHZDb2xvcjtcXHJcXG5cXHJcXG52b2lkIG1haW4odm9pZCl7XFxyXFxuICAgIGZsb2F0IHggPSAoYVZlcnRleFBvc2l0aW9uLngpICogY29zKGFSb3RhdGlvbikgLSAoYVZlcnRleFBvc2l0aW9uLnkpICogc2luKGFSb3RhdGlvbik7XFxyXFxuICAgIGZsb2F0IHkgPSAoYVZlcnRleFBvc2l0aW9uLngpICogc2luKGFSb3RhdGlvbikgKyAoYVZlcnRleFBvc2l0aW9uLnkpICogY29zKGFSb3RhdGlvbik7XFxyXFxuXFxyXFxuICAgIHZlYzIgdiA9IHZlYzIoeCwgeSk7XFxyXFxuICAgIHYgPSB2ICsgYVBvc2l0aW9uQ29vcmQ7XFxyXFxuXFxyXFxuICAgIGdsX1Bvc2l0aW9uID0gdmVjNCgodHJhbnNsYXRpb25NYXRyaXggKiB2ZWMzKHYsIDEuMCkpLnh5LCAwLjAsIDEuMCk7XFxyXFxuXFxyXFxuICAgIHZUZXh0dXJlQ29vcmQgPSBhVGV4dHVyZUNvb3JkO1xcclxcbiAgICB2Q29sb3IgPSBhQ29sb3IgKiB1Q29sb3I7XFxyXFxufVxcclxcblwiO1xyXG5QYXJ0aWNsZVJlbmRlcmVyLmZyYWdtZW50JDEgPSBcInZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xcclxcbnZhcnlpbmcgdmVjNCB2Q29sb3I7XFxyXFxuXFxyXFxudW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXI7XFxyXFxuXFxyXFxudm9pZCBtYWluKHZvaWQpe1xcclxcbiAgICB2ZWM0IGNvbG9yID0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2VGV4dHVyZUNvb3JkKSAqIHZDb2xvcjtcXHJcXG4gICAgZ2xfRnJhZ0NvbG9yID0gY29sb3I7XFxyXFxufVwiO1xyXG5leHBvcnRzLlBhcnRpY2xlUmVuZGVyZXIgPSBQYXJ0aWNsZVJlbmRlcmVyO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jbGFzcyBQb2ludCB7XHJcbiAgICBjb25zdHJ1Y3Rvcih4ID0gMCwgeSA9IDApIHtcclxuICAgICAgICBpZiAoeCA9PT0gdm9pZCAwKSB7XHJcbiAgICAgICAgICAgIHggPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoeSA9PT0gdm9pZCAwKSB7XHJcbiAgICAgICAgICAgIHkgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgICAgICogQGRlZmF1bHQgMFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMueCA9IHg7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICAgICAqIEBkZWZhdWx0IDBcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnkgPSB5O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBwb2ludCB0byBhIG5ldyB4IGFuZCB5IHBvc2l0aW9uLlxyXG4gICAgICogSWYgeSBpcyBvbWl0dGVkLCBib3RoIHggYW5kIHkgd2lsbCBiZSBzZXQgdG8geC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3g9MF0gLSBwb3NpdGlvbiBvZiB0aGUgcG9pbnQgb24gdGhlIHggYXhpc1xyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt5PTBdIC0gcG9zaXRpb24gb2YgdGhlIHBvaW50IG9uIHRoZSB5IGF4aXNcclxuICAgICAqL1xyXG4gICAgc2V0KHggPSAwLCB5ID0gMCkge1xyXG4gICAgICAgIHRoaXMueCA9IHggfHwgMDtcclxuICAgICAgICB0aGlzLnkgPSB5IHx8ICgoeSAhPT0gMCkgPyB0aGlzLnggOiAwKTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBwb2ludCBpcyBlcXVhbCB0byB0aGlzIHBvaW50XHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtQSVhJLklQb2ludH0gcCAtIFRoZSBwb2ludCB0byBjaGVja1xyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFdoZXRoZXIgdGhlIGdpdmVuIHBvaW50IGVxdWFsIHRvIHRoaXMgcG9pbnRcclxuICAgICAqL1xyXG4gICAgZXF1YWxzKHApIHtcclxuICAgICAgICByZXR1cm4gKHAueCA9PT0gdGhpcy54KSAmJiAocC55ID09PSB0aGlzLnkpO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDb3BpZXMgeCBhbmQgeSBpbnRvIHRoZSBnaXZlbiBwb2ludFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7UElYSS5JUG9pbnR9IHAgLSBUaGUgcG9pbnQgdG8gY29weS5cclxuICAgICAqIEByZXR1cm5zIHtQSVhJLklQb2ludH0gR2l2ZW4gcG9pbnQgd2l0aCB2YWx1ZXMgdXBkYXRlZFxyXG4gICAgICovXHJcbiAgICBjb3B5VG8ocCkge1xyXG4gICAgICAgIHAuc2V0KHRoaXMueCwgdGhpcy55KTtcclxuICAgICAgICByZXR1cm4gcDtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQ29waWVzIHggYW5kIHkgZnJvbSB0aGUgZ2l2ZW4gcG9pbnRcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1BJWEkuSVBvaW50fSBwIC0gVGhlIHBvaW50IHRvIGNvcHkgZnJvbVxyXG4gICAgICogQHJldHVybnMge1BJWEkuSVBvaW50fSBSZXR1cm5zIGl0c2VsZi5cclxuICAgICAqL1xyXG4gICAgY29weUZyb20ocCkge1xyXG4gICAgICAgIHRoaXMuc2V0KHAueCwgcC55KTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIGNsb25lIG9mIHRoaXMgcG9pbnRcclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIHtQSVhJLlBvaW50fSBhIGNvcHkgb2YgdGhlIHBvaW50XHJcbiAgICAgKi9cclxuICAgIGNsb25lKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgUG9pbnQodGhpcy54LCB0aGlzLnkpO1xyXG4gICAgfVxyXG4gICAgO1xyXG59XHJcbmV4cG9ydHMuUG9pbnQgPSBQb2ludDtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgUG9pbnRfMSA9IHJlcXVpcmUoXCIuL1BvaW50XCIpO1xyXG5jb25zdCBTaGFwZVNldHRpbmdzXzEgPSByZXF1aXJlKFwiLi9TaGFwZVNldHRpbmdzXCIpO1xyXG5jbGFzcyBQb2x5Z29uIHtcclxuICAgIGNvbnN0cnVjdG9yKGFyZyA9IG51bGwpIHtcclxuICAgICAgICB2YXIgYXJndW1lbnRzJDEgPSBhcmd1bWVudHM7XHJcbiAgICAgICAgdmFyIHBvaW50cyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xyXG4gICAgICAgIHdoaWxlIChsZW4tLSkge1xyXG4gICAgICAgICAgICBwb2ludHNbbGVuXSA9IGFyZ3VtZW50cyQxW2xlbl07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHBvaW50c1swXSkpIHtcclxuICAgICAgICAgICAgcG9pbnRzID0gcG9pbnRzWzBdO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBpZiB0aGlzIGlzIGFuIGFycmF5IG9mIHBvaW50cywgY29udmVydCBpdCB0byBhIGZsYXQgYXJyYXkgb2YgbnVtYmVyc1xyXG4gICAgICAgIGlmIChwb2ludHNbMF0gaW5zdGFuY2VvZiBQb2ludF8xLlBvaW50KSB7XHJcbiAgICAgICAgICAgIHZhciBwID0gW107XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBpbCA9IHBvaW50cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBwLnB1c2gocG9pbnRzW2ldLngsIHBvaW50c1tpXS55KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBwb2ludHMgPSBwO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBbiBhcnJheSBvZiB0aGUgcG9pbnRzIG9mIHRoaXMgcG9seWdvblxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyW119XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5wb2ludHMgPSBwb2ludHM7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIHR5cGUgb2YgdGhlIG9iamVjdCwgbWFpbmx5IHVzZWQgdG8gYXZvaWQgYGluc3RhbmNlb2ZgIGNoZWNrc1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICAgICAqIEByZWFkT25seVxyXG4gICAgICAgICAqIEBkZWZhdWx0IFBJWEkuU0hBUEVTLlBPTFlcclxuICAgICAgICAgKiBAc2VlIFBJWEkuU0hBUEVTXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy50eXBlID0gU2hhcGVTZXR0aW5nc18xLlNoYXBlU2V0dGluZ3MuU0hBUEVTLlBPTFk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogYGZhbHNlYCBhZnRlciBtb3ZlVG8sIGB0cnVlYCBhZnRlciBgY2xvc2VQYXRoYC4gSW4gYWxsIG90aGVyIGNhc2VzIGl0IGlzIGB0cnVlYC5cclxuICAgICAgICAgKiBAbWVtYmVyIHtib29sZWFufVxyXG4gICAgICAgICAqIEBkZWZhdWx0IHRydWVcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmNsb3NlU3Ryb2tlID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIGNsb25lIG9mIHRoaXMgcG9seWdvblxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4ge1BJWEkuUG9seWdvbn0gYSBjb3B5IG9mIHRoZSBwb2x5Z29uXHJcbiAgICAgKi9cclxuICAgIGNsb25lKCkge1xyXG4gICAgICAgIHZhciBwb2x5Z29uID0gbmV3IFBvbHlnb24odGhpcy5wb2ludHMuc2xpY2UoKSk7XHJcbiAgICAgICAgcG9seWdvbi5jbG9zZVN0cm9rZSA9IHRoaXMuY2xvc2VTdHJva2U7XHJcbiAgICAgICAgcmV0dXJuIHBvbHlnb247XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSB4IGFuZCB5IGNvb3JkaW5hdGVzIHBhc3NlZCB0byB0aGlzIGZ1bmN0aW9uIGFyZSBjb250YWluZWQgd2l0aGluIHRoaXMgcG9seWdvblxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQgdG8gdGVzdFxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgLSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBwb2ludCB0byB0ZXN0XHJcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSB4L3kgY29vcmRpbmF0ZXMgYXJlIHdpdGhpbiB0aGlzIHBvbHlnb25cclxuICAgICAqL1xyXG4gICAgY29udGFpbnMoeCwgeSkge1xyXG4gICAgICAgIHZhciBpbnNpZGUgPSBmYWxzZTtcclxuICAgICAgICAvLyB1c2Ugc29tZSByYXljYXN0aW5nIHRvIHRlc3QgaGl0c1xyXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9zdWJzdGFjay9wb2ludC1pbi1wb2x5Z29uL2Jsb2IvbWFzdGVyL2luZGV4LmpzXHJcbiAgICAgICAgdmFyIGxlbmd0aCA9IHRoaXMucG9pbnRzLmxlbmd0aCAvIDI7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGogPSBsZW5ndGggLSAxOyBpIDwgbGVuZ3RoOyBqID0gaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciB4aSA9IHRoaXMucG9pbnRzW2kgKiAyXTtcclxuICAgICAgICAgICAgdmFyIHlpID0gdGhpcy5wb2ludHNbKGkgKiAyKSArIDFdO1xyXG4gICAgICAgICAgICB2YXIgeGogPSB0aGlzLnBvaW50c1tqICogMl07XHJcbiAgICAgICAgICAgIHZhciB5aiA9IHRoaXMucG9pbnRzWyhqICogMikgKyAxXTtcclxuICAgICAgICAgICAgdmFyIGludGVyc2VjdCA9ICgoeWkgPiB5KSAhPT0gKHlqID4geSkpICYmICh4IDwgKCh4aiAtIHhpKSAqICgoeSAtIHlpKSAvICh5aiAtIHlpKSkpICsgeGkpO1xyXG4gICAgICAgICAgICBpZiAoaW50ZXJzZWN0KSB7XHJcbiAgICAgICAgICAgICAgICBpbnNpZGUgPSAhaW5zaWRlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBpbnNpZGU7XHJcbiAgICB9XHJcbiAgICA7XHJcbn1cclxuZXhwb3J0cy5Qb2x5Z29uID0gUG9seWdvbjtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgQmFzZVByZXBhcmVfMSA9IHJlcXVpcmUoXCIuL0Jhc2VQcmVwYXJlXCIpO1xyXG4vLyBpbXBvcnQgeyBzZXR0aW5ncyB9IGZyb20gXCIuL3NldHRpbmdzXCI7XHJcbmNvbnN0IEdyYXBoaWNzXzEgPSByZXF1aXJlKFwiLi9HcmFwaGljc1wiKTtcclxuY29uc3QgQmFzZVRleHR1cmVfMSA9IHJlcXVpcmUoXCIuL0Jhc2VUZXh0dXJlXCIpO1xyXG5jbGFzcyBQcmVwYXJlIGV4dGVuZHMgQmFzZVByZXBhcmVfMS5CYXNlUHJlcGFyZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihyZW5kZXJlcikge1xyXG4gICAgICAgIHN1cGVyKHJlbmRlcmVyKTtcclxuICAgICAgICB0aGlzLnVwbG9hZEhvb2tIZWxwZXIgPSB0aGlzLnJlbmRlcmVyO1xyXG4gICAgICAgIC8vIEFkZCB0ZXh0dXJlcyBhbmQgZ3JhcGhpY3MgdG8gdXBsb2FkXHJcbiAgICAgICAgdGhpcy5yZWdpc3RlckZpbmRIb29rKFByZXBhcmUuZmluZEdyYXBoaWNzKTtcclxuICAgICAgICB0aGlzLnJlZ2lzdGVyVXBsb2FkSG9vayhQcmVwYXJlLnVwbG9hZEJhc2VUZXh0dXJlcyk7XHJcbiAgICAgICAgdGhpcy5yZWdpc3RlclVwbG9hZEhvb2soUHJlcGFyZS51cGxvYWRHcmFwaGljcyk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZmluZEdyYXBoaWNzKGl0ZW0sIHF1ZXVlKSB7XHJcbiAgICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBHcmFwaGljc18xLkdyYXBoaWNzKSB7XHJcbiAgICAgICAgICAgIHF1ZXVlLnB1c2goaXRlbSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgdXBsb2FkQmFzZVRleHR1cmVzKHJlbmRlcmVyLCBpdGVtKSB7XHJcbiAgICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBCYXNlVGV4dHVyZV8xLkJhc2VUZXh0dXJlKSB7XHJcbiAgICAgICAgICAgIGlmICghaXRlbS5fZ2xUZXh0dXJlc1tyZW5kZXJlci5DT05URVhUX1VJRF0pIHtcclxuICAgICAgICAgICAgICAgIHJlbmRlcmVyLnRleHR1cmVNYW5hZ2VyLnVwZGF0ZVRleHR1cmUoaXRlbSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIHN0YXRpYyB1cGxvYWRHcmFwaGljcyhyZW5kZXJlciwgaXRlbSkge1xyXG4gICAgICAgIGlmIChpdGVtIGluc3RhbmNlb2YgR3JhcGhpY3NfMS5HcmFwaGljcykge1xyXG4gICAgICAgICAgICBpZiAoaXRlbS5kaXJ0eSB8fCBpdGVtLmNsZWFyRGlydHkgfHwgIWl0ZW0uX3dlYkdMW3JlbmRlcmVyLnBsdWdpbnMuZ3JhcGhpY3MuQ09OVEVYVF9VSURdKSB7XHJcbiAgICAgICAgICAgICAgICByZW5kZXJlci5wbHVnaW5zLmdyYXBoaWNzLnVwZGF0ZUdyYXBoaWNzKGl0ZW0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5QcmVwYXJlID0gUHJlcGFyZTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgU2hhZGVyXzEgPSByZXF1aXJlKFwiLi9TaGFkZXJcIik7XHJcbmNvbnN0IENhY2hlU2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL0NhY2hlU2V0dGluZ3NcIik7XHJcbmNvbnN0IFdlYkdMU2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL1dlYkdMU2V0dGluZ3NcIik7XHJcbmNsYXNzIFByb2dyYW0ge1xyXG4gICAgY29uc3RydWN0b3IodmVydGV4U3JjLCBmcmFnbWVudFNyYywgbmFtZSA9ICdwaXhpLXNoYWRlcicpIHtcclxuICAgICAgICB0aGlzLmlkID0gUHJvZ3JhbS5VSUQkMysrO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSB2ZXJ0ZXggc2hhZGVyLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQG1lbWJlciB7c3RyaW5nfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMudmVydGV4U3JjID0gdmVydGV4U3JjIHx8IFByb2dyYW0uZGVmYXVsdFZlcnRleFNyYztcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgZnJhZ21lbnQgc2hhZGVyLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQG1lbWJlciB7c3RyaW5nfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuZnJhZ21lbnRTcmMgPSBmcmFnbWVudFNyYyB8fCBQcm9ncmFtLmRlZmF1bHRGcmFnbWVudFNyYztcclxuICAgICAgICB0aGlzLnZlcnRleFNyYyA9IHRoaXMudmVydGV4U3JjLnRyaW0oKTtcclxuICAgICAgICB0aGlzLmZyYWdtZW50U3JjID0gdGhpcy5mcmFnbWVudFNyYy50cmltKCk7XHJcbiAgICAgICAgaWYgKHRoaXMudmVydGV4U3JjLnN1YnN0cmluZygwLCA4KSAhPT0gJyN2ZXJzaW9uJykge1xyXG4gICAgICAgICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKC9cXHMrL2csICctJyk7XHJcbiAgICAgICAgICAgIGlmIChDYWNoZVNldHRpbmdzXzEuQ2FjaGVTZXR0aW5ncy5uYW1lQ2FjaGVbbmFtZV0pIHtcclxuICAgICAgICAgICAgICAgIENhY2hlU2V0dGluZ3NfMS5DYWNoZVNldHRpbmdzLm5hbWVDYWNoZVtuYW1lXSsrO1xyXG4gICAgICAgICAgICAgICAgbmFtZSArPSBcIi1cIiArIChDYWNoZVNldHRpbmdzXzEuQ2FjaGVTZXR0aW5ncy5uYW1lQ2FjaGVbbmFtZV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgQ2FjaGVTZXR0aW5nc18xLkNhY2hlU2V0dGluZ3MubmFtZUNhY2hlW25hbWVdID0gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnZlcnRleFNyYyA9IFwiI2RlZmluZSBTSEFERVJfTkFNRSBcIiArIG5hbWUgKyBcIlxcblwiICsgKHRoaXMudmVydGV4U3JjKTtcclxuICAgICAgICAgICAgdGhpcy5mcmFnbWVudFNyYyA9IFwiI2RlZmluZSBTSEFERVJfTkFNRSBcIiArIG5hbWUgKyBcIlxcblwiICsgKHRoaXMuZnJhZ21lbnRTcmMpO1xyXG4gICAgICAgICAgICB0aGlzLnZlcnRleFNyYyA9IFdlYkdMU2V0dGluZ3NfMS5XZWJHTFNldHRpbmdzLnNldFByZWNpc2lvbih0aGlzLnZlcnRleFNyYywgV2ViR0xTZXR0aW5nc18xLldlYkdMU2V0dGluZ3MuUFJFQ0lTSU9OX1ZFUlRFWCk7XHJcbiAgICAgICAgICAgIHRoaXMuZnJhZ21lbnRTcmMgPSBXZWJHTFNldHRpbmdzXzEuV2ViR0xTZXR0aW5ncy5zZXRQcmVjaXNpb24odGhpcy5mcmFnbWVudFNyYywgV2ViR0xTZXR0aW5nc18xLldlYkdMU2V0dGluZ3MuUFJFQ0lTSU9OX0ZSQUdNRU5UKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG5hbWUgPT0gXCJwaXhpLXNoYWRlci00XCIpIHtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gY3VycmVudGx5IHRoaXMgZG9lcyBub3QgZXh0cmFjdCBzdHJ1Y3RzIG9ubHkgZGVmYXVsdCB0eXBlc1xyXG4gICAgICAgIHRoaXMuZXh0cmFjdERhdGEodGhpcy52ZXJ0ZXhTcmMsIHRoaXMuZnJhZ21lbnRTcmMpO1xyXG4gICAgICAgIC8vIHRoaXMgaXMgd2hlcmUgd2Ugc3RvcmUgc2hhZGVyIHJlZmVyZW5jZXMuLlxyXG4gICAgICAgIHRoaXMuZ2xQcm9ncmFtcyA9IHt9O1xyXG4gICAgICAgIHRoaXMuc3luY1VuaWZvcm1zID0gbnVsbDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRXh0cmFjdHMgdGhlIGRhdGEgZm9yIGEgYnV5IGNyZWF0aW5nIGEgc21hbGwgdGVzdCBwcm9ncmFtXHJcbiAgICAgKiBvciByZWFkaW5nIHRoZSBzcmMgZGlyZWN0bHkuXHJcbiAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFt2ZXJ0ZXhTcmNdIC0gVGhlIHNvdXJjZSBvZiB0aGUgdmVydGV4IHNoYWRlci5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbZnJhZ21lbnRTcmNdIC0gVGhlIHNvdXJjZSBvZiB0aGUgZnJhZ21lbnQgc2hhZGVyLlxyXG4gICAgICovXHJcbiAgICBleHRyYWN0RGF0YSh2ZXJ0ZXhTcmMsIGZyYWdtZW50U3JjKSB7XHJcbiAgICAgICAgdmFyIGdsID0gV2ViR0xTZXR0aW5nc18xLldlYkdMU2V0dGluZ3MuZ2V0VGVzdENvbnRleHQoKTtcclxuICAgICAgICBpZiAoZ2wpIHtcclxuICAgICAgICAgICAgdmFyIHByb2dyYW0gPSBQcm9ncmFtLmNvbXBpbGVQcm9ncmFtKGdsLCB2ZXJ0ZXhTcmMsIGZyYWdtZW50U3JjKTtcclxuICAgICAgICAgICAgdGhpcy5hdHRyaWJ1dGVEYXRhID0gdGhpcy5nZXRBdHRyaWJ1dGVEYXRhKHByb2dyYW0sIGdsKTtcclxuICAgICAgICAgICAgdGhpcy51bmlmb3JtRGF0YSA9IHRoaXMuZ2V0VW5pZm9ybURhdGEocHJvZ3JhbSwgZ2wpO1xyXG4gICAgICAgICAgICBnbC5kZWxldGVQcm9ncmFtKHByb2dyYW0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy51bmlmb3JtRGF0YSA9IHt9O1xyXG4gICAgICAgICAgICB0aGlzLmF0dHJpYnV0ZURhdGEgPSB7fTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIHJldHVybnMgdGhlIGF0dHJpYnV0ZSBkYXRhIGZyb20gdGhlIHByb2dyYW1cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtXZWJHTFByb2dyYW19IFtwcm9ncmFtXSAtIHRoZSBXZWJHTCBwcm9ncmFtXHJcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gW2dsXSAtIHRoZSBXZWJHTCBjb250ZXh0XHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge29iamVjdH0gdGhlIGF0dHJpYnV0ZSBkYXRhIGZvciB0aGlzIHByb2dyYW1cclxuICAgICAqL1xyXG4gICAgZ2V0QXR0cmlidXRlRGF0YShwcm9ncmFtLCBnbCkge1xyXG4gICAgICAgIHZhciBhdHRyaWJ1dGVzID0ge307XHJcbiAgICAgICAgdmFyIGF0dHJpYnV0ZXNBcnJheSA9IFtdO1xyXG4gICAgICAgIHZhciB0b3RhbEF0dHJpYnV0ZXMgPSBnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKHByb2dyYW0sIGdsLkFDVElWRV9BVFRSSUJVVEVTKTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRvdGFsQXR0cmlidXRlczsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBhdHRyaWJEYXRhID0gZ2wuZ2V0QWN0aXZlQXR0cmliKHByb2dyYW0sIGkpO1xyXG4gICAgICAgICAgICB2YXIgdHlwZSA9IFdlYkdMU2V0dGluZ3NfMS5XZWJHTFNldHRpbmdzLm1hcFR5cGUoZ2wsIGF0dHJpYkRhdGEudHlwZSk7XHJcbiAgICAgICAgICAgIC8qZXNsaW50LWRpc2FibGUgKi9cclxuICAgICAgICAgICAgdmFyIGRhdGEgPSB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiB0eXBlLFxyXG4gICAgICAgICAgICAgICAgbmFtZTogYXR0cmliRGF0YS5uYW1lLFxyXG4gICAgICAgICAgICAgICAgc2l6ZTogV2ViR0xTZXR0aW5nc18xLldlYkdMU2V0dGluZ3MubWFwU2l6ZSh0eXBlKSxcclxuICAgICAgICAgICAgICAgIGxvY2F0aW9uOiAwLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKiBlc2xpbnQtZW5hYmxlICovXHJcbiAgICAgICAgICAgIGF0dHJpYnV0ZXNbYXR0cmliRGF0YS5uYW1lXSA9IGRhdGE7XHJcbiAgICAgICAgICAgIGF0dHJpYnV0ZXNBcnJheS5wdXNoKGRhdGEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBhdHRyaWJ1dGVzQXJyYXkuc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gKGEubmFtZSA+IGIubmFtZSkgPyAxIDogLTE7IH0pOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbmZ1c2luZy1hcnJvd1xyXG4gICAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGF0dHJpYnV0ZXNBcnJheS5sZW5ndGg7IGkkMSsrKSB7XHJcbiAgICAgICAgICAgIGF0dHJpYnV0ZXNBcnJheVtpJDFdLmxvY2F0aW9uID0gaSQxO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYXR0cmlidXRlcztcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogcmV0dXJucyB0aGUgdW5pZm9ybSBkYXRhIGZyb20gdGhlIHByb2dyYW1cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHt3ZWJHTC1wcm9ncmFtfSBbcHJvZ3JhbV0gLSB0aGUgd2ViZ2wgcHJvZ3JhbVxyXG4gICAgICogQHBhcmFtIHtjb250ZXh0fSBbZ2xdIC0gdGhlIFdlYkdMIGNvbnRleHRcclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSB0aGUgdW5pZm9ybSBkYXRhIGZvciB0aGlzIHByb2dyYW1cclxuICAgICAqL1xyXG4gICAgZ2V0VW5pZm9ybURhdGEocHJvZ3JhbSwgZ2wpIHtcclxuICAgICAgICB2YXIgdW5pZm9ybXMgPSB7fTtcclxuICAgICAgICB2YXIgdG90YWxVbmlmb3JtcyA9IGdsLmdldFByb2dyYW1QYXJhbWV0ZXIocHJvZ3JhbSwgZ2wuQUNUSVZFX1VOSUZPUk1TKTtcclxuICAgICAgICAvLyBUT0RPIGV4cG9zZSB0aGlzIGFzIGEgcHJvcD9cclxuICAgICAgICAvLyBjb25zdCBtYXNrUmVnZXggPSBuZXcgUmVnRXhwKCdeKHByb2plY3Rpb25NYXRyaXh8dVNhbXBsZXJ8dHJhbnNsYXRpb25NYXRyaXgpJCcpO1xyXG4gICAgICAgIC8vIGNvbnN0IG1hc2tSZWdleCA9IG5ldyBSZWdFeHAoJ14ocHJvamVjdGlvbk1hdHJpeHx1U2FtcGxlcnx0cmFuc2xhdGlvbk1hdHJpeCkkJyk7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b3RhbFVuaWZvcm1zOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIHVuaWZvcm1EYXRhID0gZ2wuZ2V0QWN0aXZlVW5pZm9ybShwcm9ncmFtLCBpKTtcclxuICAgICAgICAgICAgdmFyIG5hbWUgPSB1bmlmb3JtRGF0YS5uYW1lLnJlcGxhY2UoL1xcWy4qP1xcXS8sICcnKTtcclxuICAgICAgICAgICAgdmFyIGlzQXJyYXkgPSB1bmlmb3JtRGF0YS5uYW1lLm1hdGNoKC9cXFsuKj9cXF0vLCAnJyk7XHJcbiAgICAgICAgICAgIHZhciB0eXBlID0gV2ViR0xTZXR0aW5nc18xLldlYkdMU2V0dGluZ3MubWFwVHlwZShnbCwgdW5pZm9ybURhdGEudHlwZSk7XHJcbiAgICAgICAgICAgIC8qZXNsaW50LWRpc2FibGUgKi9cclxuICAgICAgICAgICAgdW5pZm9ybXNbbmFtZV0gPSB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiB0eXBlLFxyXG4gICAgICAgICAgICAgICAgc2l6ZTogdW5pZm9ybURhdGEuc2l6ZSxcclxuICAgICAgICAgICAgICAgIGlzQXJyYXk6IGlzQXJyYXksXHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogV2ViR0xTZXR0aW5nc18xLldlYkdMU2V0dGluZ3MuZGVmYXVsdFZhbHVlKHR5cGUsIHVuaWZvcm1EYXRhLnNpemUpLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAvKiBlc2xpbnQtZW5hYmxlICovXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB1bmlmb3JtcztcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGRlZmF1bHQgdmVydGV4IHNoYWRlciBzb3VyY2VcclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAY29uc3RhbnRcclxuICAgICAqIEBtZW1iZXIge3N0cmluZ31cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGdldCBkZWZhdWx0VmVydGV4U3JjKCkge1xyXG4gICAgICAgIHJldHVybiBQcm9ncmFtLmRlZmF1bHRWZXJ0ZXg7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBkZWZhdWx0IGZyYWdtZW50IHNoYWRlciBzb3VyY2VcclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAY29uc3RhbnRcclxuICAgICAqIEBtZW1iZXIge3N0cmluZ31cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGdldCBkZWZhdWx0RnJhZ21lbnRTcmMoKSB7XHJcbiAgICAgICAgcmV0dXJuIFByb2dyYW0uZGVmYXVsdEZyYWdtZW50O1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBIHNob3J0IGhhbmQgZnVuY3Rpb24gdG8gY3JlYXRlIGEgcHJvZ3JhbSBiYXNlZCBvZiBhIHZlcnRleCBhbmQgZnJhZ21lbnQgc2hhZGVyXHJcbiAgICAgKiB0aGlzIG1ldGhvZCB3aWxsIGFsc28gY2hlY2sgdG8gc2VlIGlmIHRoZXJlIGlzIGEgY2FjaGVkIHByb2dyYW0uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFt2ZXJ0ZXhTcmNdIC0gVGhlIHNvdXJjZSBvZiB0aGUgdmVydGV4IHNoYWRlci5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbZnJhZ21lbnRTcmNdIC0gVGhlIHNvdXJjZSBvZiB0aGUgZnJhZ21lbnQgc2hhZGVyLlxyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFt1bmlmb3Jtc10gLSBDdXN0b20gdW5pZm9ybXMgdG8gdXNlIHRvIGF1Z21lbnQgdGhlIGJ1aWx0LWluIG9uZXMuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge1BJWEkuUHJvZ3JhbX0gYW4gc2hpbnkgbmV3IFBpeGkgc2hhZGVyIVxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZnJvbSh2ZXJ0ZXhTcmMsIGZyYWdtZW50U3JjLCBuYW1lID0gXCJwaXhpLXNoYWRlclwiKSB7XHJcbiAgICAgICAgdmFyIGtleSA9IHZlcnRleFNyYyArIGZyYWdtZW50U3JjO1xyXG4gICAgICAgIHZhciBwcm9ncmFtID0gQ2FjaGVTZXR0aW5nc18xLkNhY2hlU2V0dGluZ3MuUHJvZ3JhbUNhY2hlW2tleV07XHJcbiAgICAgICAgaWYgKCFwcm9ncmFtKSB7XHJcbiAgICAgICAgICAgIENhY2hlU2V0dGluZ3NfMS5DYWNoZVNldHRpbmdzLlByb2dyYW1DYWNoZVtrZXldID0gcHJvZ3JhbSA9IG5ldyBQcm9ncmFtKHZlcnRleFNyYywgZnJhZ21lbnRTcmMsIG5hbWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcHJvZ3JhbTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gKiBAbWV0aG9kIGNvbXBpbGVQcm9ncmFtXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBtZW1iZXJvZiBQSVhJLmdsQ29yZS5zaGFkZXJcclxuICogQHBhcmFtIGdsIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IFRoZSBjdXJyZW50IFdlYkdMIGNvbnRleHQge1dlYkdMUHJvZ3JhbX1cclxuICogQHBhcmFtIHZlcnRleFNyYyB7c3RyaW5nfHN0cmluZ1tdfSBUaGUgdmVydGV4IHNoYWRlciBzb3VyY2UgYXMgYW4gYXJyYXkgb2Ygc3RyaW5ncy5cclxuICogQHBhcmFtIGZyYWdtZW50U3JjIHtzdHJpbmd8c3RyaW5nW119IFRoZSBmcmFnbWVudCBzaGFkZXIgc291cmNlIGFzIGFuIGFycmF5IG9mIHN0cmluZ3MuXHJcbiAqIEBwYXJhbSBhdHRyaWJ1dGVMb2NhdGlvbnMge09iamVjdH0gQW4gYXR0cmlidXRlIGxvY2F0aW9uIG1hcCB0aGF0IGxldHMgeW91IG1hbnVhbGx5IHNldCB0aGUgYXR0cmlidXRlIGxvY2F0aW9uc1xyXG4gKiBAcmV0dXJuIHtXZWJHTFByb2dyYW19IHRoZSBzaGFkZXIgcHJvZ3JhbVxyXG4gKi9cclxuICAgIHN0YXRpYyBjb21waWxlUHJvZ3JhbShnbCwgdmVydGV4U3JjLCBmcmFnbWVudFNyYywgYXR0cmlidXRlTG9jYXRpb25zID0gbnVsbCkge1xyXG4gICAgICAgIHZhciBnbFZlcnRTaGFkZXIgPSBTaGFkZXJfMS5TaGFkZXIuY29tcGlsZVNoYWRlcihnbCwgZ2wuVkVSVEVYX1NIQURFUiwgdmVydGV4U3JjKTtcclxuICAgICAgICB2YXIgZ2xGcmFnU2hhZGVyID0gU2hhZGVyXzEuU2hhZGVyLmNvbXBpbGVTaGFkZXIoZ2wsIGdsLkZSQUdNRU5UX1NIQURFUiwgZnJhZ21lbnRTcmMpO1xyXG4gICAgICAgIHZhciBwcm9ncmFtID0gZ2wuY3JlYXRlUHJvZ3JhbSgpO1xyXG4gICAgICAgIGdsLmF0dGFjaFNoYWRlcihwcm9ncmFtLCBnbFZlcnRTaGFkZXIpO1xyXG4gICAgICAgIGdsLmF0dGFjaFNoYWRlcihwcm9ncmFtLCBnbEZyYWdTaGFkZXIpO1xyXG4gICAgICAgIC8vIG9wdGlvbmFsbHksIHNldCB0aGUgYXR0cmlidXRlcyBtYW51YWxseSBmb3IgdGhlIHByb2dyYW0gcmF0aGVyIHRoYW4gbGV0dGluZyBXZWJHTCBkZWNpZGUuLlxyXG4gICAgICAgIGlmIChhdHRyaWJ1dGVMb2NhdGlvbnMpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSBpbiBhdHRyaWJ1dGVMb2NhdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgIGdsLmJpbmRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCBhdHRyaWJ1dGVMb2NhdGlvbnNbaV0sIGkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGdsLmxpbmtQcm9ncmFtKHByb2dyYW0pO1xyXG4gICAgICAgIC8vIGlmIGxpbmtpbmcgZmFpbHMsIHRoZW4gbG9nIGFuZCBjbGVhbnVwXHJcbiAgICAgICAgaWYgKCFnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKHByb2dyYW0sIGdsLkxJTktfU1RBVFVTKSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdQaXhpLmpzIEVycm9yOiBDb3VsZCBub3QgaW5pdGlhbGl6ZSBzaGFkZXIuJyk7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ2dsLlZBTElEQVRFX1NUQVRVUycsIGdsLmdldFByb2dyYW1QYXJhbWV0ZXIocHJvZ3JhbSwgZ2wuVkFMSURBVEVfU1RBVFVTKSk7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ2dsLmdldEVycm9yKCknLCBnbC5nZXRFcnJvcigpKTtcclxuICAgICAgICAgICAgLy8gaWYgdGhlcmUgaXMgYSBwcm9ncmFtIGluZm8gbG9nLCBsb2cgaXRcclxuICAgICAgICAgICAgaWYgKGdsLmdldFByb2dyYW1JbmZvTG9nKHByb2dyYW0pICE9PSAnJykge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdQaXhpLmpzIFdhcm5pbmc6IGdsLmdldFByb2dyYW1JbmZvTG9nKCknLCBnbC5nZXRQcm9ncmFtSW5mb0xvZyhwcm9ncmFtKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZ2wuZGVsZXRlUHJvZ3JhbShwcm9ncmFtKTtcclxuICAgICAgICAgICAgcHJvZ3JhbSA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGNsZWFuIHVwIHNvbWUgc2hhZGVyc1xyXG4gICAgICAgIGdsLmRlbGV0ZVNoYWRlcihnbFZlcnRTaGFkZXIpO1xyXG4gICAgICAgIGdsLmRlbGV0ZVNoYWRlcihnbEZyYWdTaGFkZXIpO1xyXG4gICAgICAgIHJldHVybiBwcm9ncmFtO1xyXG4gICAgfVxyXG59XHJcblByb2dyYW0uVUlEJDMgPSAwO1xyXG5Qcm9ncmFtLmRlZmF1bHRGcmFnbWVudCA9IFwidmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XFxyXFxuXFxyXFxudW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXI7XFxyXFxuXFxyXFxudm9pZCBtYWluKHZvaWQpe1xcclxcbiAgIGdsX0ZyYWdDb2xvciAqPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZUZXh0dXJlQ29vcmQpO1xcclxcbn1cIjtcclxuUHJvZ3JhbS5kZWZhdWx0VmVydGV4ID0gXCJhdHRyaWJ1dGUgdmVjMiBhVmVydGV4UG9zaXRpb247XFxyXFxuYXR0cmlidXRlIHZlYzIgYVRleHR1cmVDb29yZDtcXHJcXG5cXHJcXG51bmlmb3JtIG1hdDMgcHJvamVjdGlvbk1hdHJpeDtcXHJcXG5cXHJcXG52YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXHJcXG5cXHJcXG52b2lkIG1haW4odm9pZCl7XFxyXFxuICAgZ2xfUG9zaXRpb24gPSB2ZWM0KChwcm9qZWN0aW9uTWF0cml4ICogdmVjMyhhVmVydGV4UG9zaXRpb24sIDEuMCkpLnh5LCAwLjAsIDEuMCk7XFxyXFxuICAgdlRleHR1cmVDb29yZCA9IGFUZXh0dXJlQ29vcmQ7XFxyXFxufVxcclxcblwiO1xyXG5leHBvcnRzLlByb2dyYW0gPSBQcm9ncmFtO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBFdmVudF8xID0gcmVxdWlyZShcIi4vRXZlbnRcIik7XHJcbmNsYXNzIFByb2dyZXNzRXZlbnQgZXh0ZW5kcyBFdmVudF8xLkV2ZW50IHtcclxuICAgIGNvbnN0cnVjdG9yKHR5cGUsIGJ1YmJsZXMgPSBmYWxzZSwgY2FuY2VsYWJsZSA9IGZhbHNlKSB7XHJcbiAgICAgICAgc3VwZXIodHlwZSwgYnViYmxlcywgY2FuY2VsYWJsZSk7XHJcbiAgICB9XHJcbiAgICBjbG9uZSgpIHtcclxuICAgICAgICB2YXIgZXZlbnQgPSBQcm9ncmVzc0V2ZW50LmdldFByb2dyZXNzRXZlbnQodGhpcy50eXBlLCB0aGlzLmJ1YmJsZXMsIHRoaXMuY2FuY2VsYWJsZSk7XHJcbiAgICAgICAgZXZlbnQuYnl0ZXNMb2FkZWQgPSB0aGlzLmJ5dGVzTG9hZGVkO1xyXG4gICAgICAgIGV2ZW50LmJ5dGVzVG90YWwgPSB0aGlzLmJ5dGVzVG90YWw7XHJcbiAgICAgICAgZXZlbnQucGVyY2VudCA9IHRoaXMucGVyY2VudDtcclxuICAgICAgICByZXR1cm4gZXZlbnQ7XHJcbiAgICB9XHJcbiAgICBnZXQgaXNEaXNwb3NhYmxlKCkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGdldFByb2dyZXNzRXZlbnQodHlwZSwgYnViYmxlID0gdHJ1ZSwgY2FuY2VsYWJsZSA9IHRydWUpIHtcclxuICAgICAgICBpZiAoUHJvZ3Jlc3NFdmVudC5Qcm9ncmVzc0V2ZW50Q2FjaGUubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGxldCB0ZSA9IFByb2dyZXNzRXZlbnQuUHJvZ3Jlc3NFdmVudENhY2hlW1Byb2dyZXNzRXZlbnQuUHJvZ3Jlc3NFdmVudENhY2hlLmxlbmd0aCAtIDFdO1xyXG4gICAgICAgICAgICBQcm9ncmVzc0V2ZW50LlByb2dyZXNzRXZlbnRDYWNoZS5sZW5ndGggLT0gMTtcclxuICAgICAgICAgICAgdGUucmVzZXQodHlwZSwgYnViYmxlLCBjYW5jZWxhYmxlKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IFByb2dyZXNzRXZlbnQodHlwZSwgYnViYmxlLCBjYW5jZWxhYmxlKTtcclxuICAgIH1cclxuICAgIGRlc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5fY3VycmVudFRhcmdldCA9IG51bGw7XHJcbiAgICAgICAgLy8gdGhpcy5fbGVnYWN5VGFyZ2V0ID0gbnVsbDtcclxuICAgICAgICBsZXQgaW5kZXggPSBQcm9ncmVzc0V2ZW50LlByb2dyZXNzRXZlbnRDYWNoZS5pbmRleE9mKHRoaXMpO1xyXG4gICAgICAgIGlmIChpbmRleCA8IDApIHtcclxuICAgICAgICAgICAgUHJvZ3Jlc3NFdmVudC5Qcm9ncmVzc0V2ZW50Q2FjaGUucHVzaCh0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuUHJvZ3Jlc3NFdmVudC5Qcm9ncmVzc0V2ZW50Q2FjaGUgPSBbXTtcclxuUHJvZ3Jlc3NFdmVudC5QUk9HUkVTUyA9IFwicHJvZ3Jlc3NcIjtcclxuZXhwb3J0cy5Qcm9ncmVzc0V2ZW50ID0gUHJvZ3Jlc3NFdmVudDtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgU3lzdGVtXzEgPSByZXF1aXJlKFwiLi9TeXN0ZW1cIik7XHJcbmNvbnN0IE1hdHJpeF8xID0gcmVxdWlyZShcIi4vTWF0cml4XCIpO1xyXG5jbGFzcyBQcm9qZWN0aW9uU3lzdGVtIGV4dGVuZHMgU3lzdGVtXzEuU3lzdGVtIHtcclxuICAgIGNvbnN0cnVjdG9yKHJlbmRlcmVyKSB7XHJcbiAgICAgICAgc3VwZXIocmVuZGVyZXIpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIERlc3RpbmF0aW9uIGZyYW1lXHJcbiAgICAgICAgICogQG1lbWJlciB7UElYSS5SZWN0YW5nbGV9XHJcbiAgICAgICAgICogQHJlYWRvbmx5XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbkZyYW1lID0gbnVsbDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTb3VyY2UgZnJhbWVcclxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLlJlY3RhbmdsZX1cclxuICAgICAgICAgKiBAcmVhZG9ubHlcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnNvdXJjZUZyYW1lID0gbnVsbDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBEZWZhdWx0IGRlc3RpbmF0aW9uIGZyYW1lXHJcbiAgICAgICAgICogQG1lbWJlciB7UElYSS5SZWN0YW5nbGV9XHJcbiAgICAgICAgICogQHJlYWRvbmx5XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5kZWZhdWx0RnJhbWUgPSBudWxsO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFByb2plY3QgbWF0cml4XHJcbiAgICAgICAgICogQG1lbWJlciB7UElYSS5NYXRyaXh9XHJcbiAgICAgICAgICogQHJlYWRvbmx5XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5wcm9qZWN0aW9uTWF0cml4ID0gbmV3IE1hdHJpeF8xLk1hdHJpeCgpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEEgdHJhbnNmb3JtIHRoYXQgd2lsbCBiZSBhcHBlbmRlZCB0byB0aGUgcHJvamVjdGlvbiBtYXRyaXhcclxuICAgICAgICAgKiBpZiBudWxsLCBub3RoaW5nIHdpbGwgYmUgYXBwbGllZFxyXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuTWF0cml4fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMudHJhbnNmb3JtID0gbnVsbDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyB0aGUgcHJvamVjdGlvbiBtYXRyaXggYmFzZWQgb24gYSBwcm9qZWN0aW9uIGZyYW1lICh3aGljaCBpcyBhIHJlY3RhbmdsZSlcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1BJWEkuUmVjdGFuZ2xlfSBkZXN0aW5hdGlvbkZyYW1lIC0gVGhlIGRlc3RpbmF0aW9uIGZyYW1lLlxyXG4gICAgICogQHBhcmFtIHtQSVhJLlJlY3RhbmdsZX0gc291cmNlRnJhbWUgLSBUaGUgc291cmNlIGZyYW1lLlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHJlc29sdXRpb24gLSBSZXNvbHV0aW9uXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHJvb3QgLSBJZiBpcyByb290XHJcbiAgICAgKi9cclxuICAgIHVwZGF0ZShkZXN0aW5hdGlvbkZyYW1lLCBzb3VyY2VGcmFtZSwgcmVzb2x1dGlvbiwgcm9vdCkge1xyXG4gICAgICAgIHRoaXMuZGVzdGluYXRpb25GcmFtZSA9IGRlc3RpbmF0aW9uRnJhbWUgfHwgdGhpcy5kZXN0aW5hdGlvbkZyYW1lIHx8IHRoaXMuZGVmYXVsdEZyYW1lO1xyXG4gICAgICAgIHRoaXMuc291cmNlRnJhbWUgPSBzb3VyY2VGcmFtZSB8fCB0aGlzLnNvdXJjZUZyYW1lIHx8IGRlc3RpbmF0aW9uRnJhbWU7XHJcbiAgICAgICAgdGhpcy5jYWxjdWxhdGVQcm9qZWN0aW9uKHRoaXMuZGVzdGluYXRpb25GcmFtZSwgdGhpcy5zb3VyY2VGcmFtZSwgcmVzb2x1dGlvbiwgcm9vdCk7XHJcbiAgICAgICAgaWYgKHRoaXMudHJhbnNmb3JtKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHJvamVjdGlvbk1hdHJpeC5hcHBlbmQodGhpcy50cmFuc2Zvcm0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcmVuZGVyZXIgPSB0aGlzLnJlbmRlcmVyO1xyXG4gICAgICAgIHJlbmRlcmVyLmdsb2JhbFVuaWZvcm1zLnVuaWZvcm1zLnByb2plY3Rpb25NYXRyaXggPSB0aGlzLnByb2plY3Rpb25NYXRyaXg7XHJcbiAgICAgICAgcmVuZGVyZXIuZ2xvYmFsVW5pZm9ybXMudXBkYXRlKCk7XHJcbiAgICAgICAgLy8gdGhpcyB3aWxsIHdvcmsgZm9yIG5vd1xyXG4gICAgICAgIC8vIGJ1dCB3b3VsZCBiZSBzd2VldCB0byBzdGljayBhbmQgZXZlbiBvbiB0aGUgZ2xvYmFsIHVuaWZvcm1zLi5cclxuICAgICAgICBpZiAocmVuZGVyZXIuc2hhZGVyLnNoYWRlcikge1xyXG4gICAgICAgICAgICByZW5kZXJlci5zaGFkZXIuc3luY1VuaWZvcm1Hcm91cChyZW5kZXJlci5zaGFkZXIuc2hhZGVyLnVuaWZvcm1zLmdsb2JhbHMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyB0aGUgcHJvamVjdGlvbiBtYXRyaXggYmFzZWQgb24gYSBwcm9qZWN0aW9uIGZyYW1lICh3aGljaCBpcyBhIHJlY3RhbmdsZSlcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1BJWEkuUmVjdGFuZ2xlfSBkZXN0aW5hdGlvbkZyYW1lIC0gVGhlIGRlc3RpbmF0aW9uIGZyYW1lLlxyXG4gICAgICogQHBhcmFtIHtQSVhJLlJlY3RhbmdsZX0gc291cmNlRnJhbWUgLSBUaGUgc291cmNlIGZyYW1lLlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHJlc29sdXRpb24gLSBSZXNvbHV0aW9uXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHJvb3QgLSBJZiBpcyByb290XHJcbiAgICAgKi9cclxuICAgIGNhbGN1bGF0ZVByb2plY3Rpb24oZGVzdGluYXRpb25GcmFtZSwgc291cmNlRnJhbWUsIHJlc29sdXRpb24sIHJvb3QpIHtcclxuICAgICAgICB2YXIgcG0gPSB0aGlzLnByb2plY3Rpb25NYXRyaXg7XHJcbiAgICAgICAgLy8gSSBkb24ndCB0aGluayB3ZSB3aWxsIG5lZWQgdGhpcyBsaW5lLi5cclxuICAgICAgICAvLyBwbS5pZGVudGl0eSgpO1xyXG4gICAgICAgIGlmICghcm9vdCkge1xyXG4gICAgICAgICAgICBwbS5hID0gKDEgLyBkZXN0aW5hdGlvbkZyYW1lLndpZHRoICogMikgKiByZXNvbHV0aW9uO1xyXG4gICAgICAgICAgICBwbS5kID0gKDEgLyBkZXN0aW5hdGlvbkZyYW1lLmhlaWdodCAqIDIpICogcmVzb2x1dGlvbjtcclxuICAgICAgICAgICAgcG0udHggPSAtMSAtIChzb3VyY2VGcmFtZS54ICogcG0uYSk7XHJcbiAgICAgICAgICAgIHBtLnR5ID0gLTEgLSAoc291cmNlRnJhbWUueSAqIHBtLmQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcG0uYSA9ICgxIC8gZGVzdGluYXRpb25GcmFtZS53aWR0aCAqIDIpICogcmVzb2x1dGlvbjtcclxuICAgICAgICAgICAgcG0uZCA9ICgtMSAvIGRlc3RpbmF0aW9uRnJhbWUuaGVpZ2h0ICogMikgKiByZXNvbHV0aW9uO1xyXG4gICAgICAgICAgICBwbS50eCA9IC0xIC0gKHNvdXJjZUZyYW1lLnggKiBwbS5hKTtcclxuICAgICAgICAgICAgcG0udHkgPSAxIC0gKHNvdXJjZUZyYW1lLnkgKiBwbS5kKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIHRyYW5zZm9ybSBvZiB0aGUgYWN0aXZlIHJlbmRlciB0YXJnZXQgdG8gdGhlIGdpdmVuIG1hdHJpeFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7UElYSS5NYXRyaXh9IG1hdHJpeCAtIFRoZSB0cmFuc2Zvcm1hdGlvbiBtYXRyaXhcclxuICAgICAqL1xyXG4gICAgc2V0VHJhbnNmb3JtKCkge1xyXG4gICAgICAgIC8vIHRoaXMuX2FjdGl2ZVJlbmRlclRhcmdldC50cmFuc2Zvcm0gPSBtYXRyaXg7XHJcbiAgICB9XHJcbiAgICA7XHJcbn1cclxuZXhwb3J0cy5Qcm9qZWN0aW9uU3lzdGVtID0gUHJvamVjdGlvblN5c3RlbTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgR2VvbWV0cnlfMSA9IHJlcXVpcmUoXCIuL0dlb21ldHJ5XCIpO1xyXG5jbGFzcyBRdWFkIGV4dGVuZHMgR2VvbWV0cnlfMS5HZW9tZXRyeSB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuYWRkQXR0cmlidXRlKCdhVmVydGV4UG9zaXRpb24nLCBbMCwgMCwgMSwgMCwgMSwgMSwgMCwgMV0pLmFkZEluZGV4KFswLCAxLCAzLCAyXSk7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5RdWFkID0gUXVhZDtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgR2VvbWV0cnlfMSA9IHJlcXVpcmUoXCIuL0dlb21ldHJ5XCIpO1xyXG5jb25zdCBCdWZmZXJfMSA9IHJlcXVpcmUoXCIuL0J1ZmZlclwiKTtcclxuY2xhc3MgUXVhZFV2IGV4dGVuZHMgR2VvbWV0cnlfMS5HZW9tZXRyeSB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFuIGFycmF5IG9mIHZlcnRpY2VzXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAbWVtYmVyIHtGbG9hdDMyQXJyYXl9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy52ZXJ0aWNlcyA9IG5ldyBGbG9hdDMyQXJyYXkoW1xyXG4gICAgICAgICAgICAtMSwgLTEsXHJcbiAgICAgICAgICAgIDEsIC0xLFxyXG4gICAgICAgICAgICAxLCAxLFxyXG4gICAgICAgICAgICAtMSwgMVxyXG4gICAgICAgIF0pO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBVdnMgb2YgdGhlIHF1YWRcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBtZW1iZXIge0Zsb2F0MzJBcnJheX1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnV2cyA9IG5ldyBGbG9hdDMyQXJyYXkoW1xyXG4gICAgICAgICAgICAwLCAwLFxyXG4gICAgICAgICAgICAxLCAwLFxyXG4gICAgICAgICAgICAxLCAxLFxyXG4gICAgICAgICAgICAwLCAxXHJcbiAgICAgICAgXSk7XHJcbiAgICAgICAgdGhpcy52ZXJ0ZXhCdWZmZXIgPSBuZXcgQnVmZmVyXzEuQnVmZmVyKHRoaXMudmVydGljZXMpO1xyXG4gICAgICAgIHRoaXMudXZCdWZmZXIgPSBuZXcgQnVmZmVyXzEuQnVmZmVyKHRoaXMudXZzKTtcclxuICAgICAgICB0aGlzLmFkZEF0dHJpYnV0ZSgnYVZlcnRleFBvc2l0aW9uJywgdGhpcy52ZXJ0ZXhCdWZmZXIpXHJcbiAgICAgICAgICAgIC5hZGRBdHRyaWJ1dGUoJ2FUZXh0dXJlQ29vcmQnLCB0aGlzLnV2QnVmZmVyKVxyXG4gICAgICAgICAgICAuYWRkSW5kZXgoWzAsIDEsIDIsIDAsIDIsIDNdKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogTWFwcyB0d28gUmVjdGFuZ2xlIHRvIHRoZSBxdWFkLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7UElYSS5SZWN0YW5nbGV9IHRhcmdldFRleHR1cmVGcmFtZSAtIHRoZSBmaXJzdCByZWN0YW5nbGVcclxuICAgICAqIEBwYXJhbSB7UElYSS5SZWN0YW5nbGV9IGRlc3RpbmF0aW9uRnJhbWUgLSB0aGUgc2Vjb25kIHJlY3RhbmdsZVxyXG4gICAgICogQHJldHVybiB7UElYSS5RdWFkfSBSZXR1cm5zIGl0c2VsZi5cclxuICAgICAqL1xyXG4gICAgbWFwKHRhcmdldFRleHR1cmVGcmFtZSwgZGVzdGluYXRpb25GcmFtZSkge1xyXG4gICAgICAgIHZhciB4ID0gMDsgLy8gZGVzdGluYXRpb25GcmFtZS54IC8gdGFyZ2V0VGV4dHVyZUZyYW1lLndpZHRoO1xyXG4gICAgICAgIHZhciB5ID0gMDsgLy8gZGVzdGluYXRpb25GcmFtZS55IC8gdGFyZ2V0VGV4dHVyZUZyYW1lLmhlaWdodDtcclxuICAgICAgICB0aGlzLnV2c1swXSA9IHg7XHJcbiAgICAgICAgdGhpcy51dnNbMV0gPSB5O1xyXG4gICAgICAgIHRoaXMudXZzWzJdID0geCArIChkZXN0aW5hdGlvbkZyYW1lLndpZHRoIC8gdGFyZ2V0VGV4dHVyZUZyYW1lLndpZHRoKTtcclxuICAgICAgICB0aGlzLnV2c1szXSA9IHk7XHJcbiAgICAgICAgdGhpcy51dnNbNF0gPSB4ICsgKGRlc3RpbmF0aW9uRnJhbWUud2lkdGggLyB0YXJnZXRUZXh0dXJlRnJhbWUud2lkdGgpO1xyXG4gICAgICAgIHRoaXMudXZzWzVdID0geSArIChkZXN0aW5hdGlvbkZyYW1lLmhlaWdodCAvIHRhcmdldFRleHR1cmVGcmFtZS5oZWlnaHQpO1xyXG4gICAgICAgIHRoaXMudXZzWzZdID0geDtcclxuICAgICAgICB0aGlzLnV2c1s3XSA9IHkgKyAoZGVzdGluYXRpb25GcmFtZS5oZWlnaHQgLyB0YXJnZXRUZXh0dXJlRnJhbWUuaGVpZ2h0KTtcclxuICAgICAgICB4ID0gZGVzdGluYXRpb25GcmFtZS54O1xyXG4gICAgICAgIHkgPSBkZXN0aW5hdGlvbkZyYW1lLnk7XHJcbiAgICAgICAgdGhpcy52ZXJ0aWNlc1swXSA9IHg7XHJcbiAgICAgICAgdGhpcy52ZXJ0aWNlc1sxXSA9IHk7XHJcbiAgICAgICAgdGhpcy52ZXJ0aWNlc1syXSA9IHggKyBkZXN0aW5hdGlvbkZyYW1lLndpZHRoO1xyXG4gICAgICAgIHRoaXMudmVydGljZXNbM10gPSB5O1xyXG4gICAgICAgIHRoaXMudmVydGljZXNbNF0gPSB4ICsgZGVzdGluYXRpb25GcmFtZS53aWR0aDtcclxuICAgICAgICB0aGlzLnZlcnRpY2VzWzVdID0geSArIGRlc3RpbmF0aW9uRnJhbWUuaGVpZ2h0O1xyXG4gICAgICAgIHRoaXMudmVydGljZXNbNl0gPSB4O1xyXG4gICAgICAgIHRoaXMudmVydGljZXNbN10gPSB5ICsgZGVzdGluYXRpb25GcmFtZS5oZWlnaHQ7XHJcbiAgICAgICAgdGhpcy5pbnZhbGlkYXRlKCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIGxlZ2FjeSB1cGxvYWQgbWV0aG9kLCBqdXN0IG1hcmtzIGJ1ZmZlcnMgZGlydHlcclxuICAgICAqIEByZXR1cm5zIHtQSVhJLlF1YWRVdn0gUmV0dXJucyBpdHNlbGYuXHJcbiAgICAgKi9cclxuICAgIGludmFsaWRhdGUoKSB7XHJcbiAgICAgICAgdGhpcy52ZXJ0ZXhCdWZmZXIuX3VwZGF0ZUlEKys7XHJcbiAgICAgICAgdGhpcy51dkJ1ZmZlci5fdXBkYXRlSUQrKztcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIDtcclxufVxyXG5leHBvcnRzLlF1YWRVdiA9IFF1YWRVdjtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3Qgc2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL3NldHRpbmdzXCIpO1xyXG5jbGFzcyBRdWFkcmF0aWNVdGlscyB7XHJcbiAgICBzdGF0aWMgY3VydmVMZW5ndGgoZnJvbVgsIGZyb21ZLCBjcFgsIGNwWSwgdG9YLCB0b1kpIHtcclxuICAgICAgICB2YXIgYXggPSBmcm9tWCAtICgyLjAgKiBjcFgpICsgdG9YO1xyXG4gICAgICAgIHZhciBheSA9IGZyb21ZIC0gKDIuMCAqIGNwWSkgKyB0b1k7XHJcbiAgICAgICAgdmFyIGJ4ID0gKDIuMCAqIGNwWCkgLSAoMi4wICogZnJvbVgpO1xyXG4gICAgICAgIHZhciBieSA9ICgyLjAgKiBjcFkpIC0gKDIuMCAqIGZyb21ZKTtcclxuICAgICAgICB2YXIgYSA9IDQuMCAqICgoYXggKiBheCkgKyAoYXkgKiBheSkpO1xyXG4gICAgICAgIHZhciBiID0gNC4wICogKChheCAqIGJ4KSArIChheSAqIGJ5KSk7XHJcbiAgICAgICAgdmFyIGMgPSAoYnggKiBieCkgKyAoYnkgKiBieSk7XHJcbiAgICAgICAgdmFyIHMgPSAyLjAgKiBNYXRoLnNxcnQoYSArIGIgKyBjKTtcclxuICAgICAgICB2YXIgYTIgPSBNYXRoLnNxcnQoYSk7XHJcbiAgICAgICAgdmFyIGEzMiA9IDIuMCAqIGEgKiBhMjtcclxuICAgICAgICB2YXIgYzIgPSAyLjAgKiBNYXRoLnNxcnQoYyk7XHJcbiAgICAgICAgdmFyIGJhID0gYiAvIGEyO1xyXG4gICAgICAgIHJldHVybiAoKGEzMiAqIHMpXHJcbiAgICAgICAgICAgICsgKGEyICogYiAqIChzIC0gYzIpKVxyXG4gICAgICAgICAgICArICgoKDQuMCAqIGMgKiBhKSAtIChiICogYikpXHJcbiAgICAgICAgICAgICAgICAqIE1hdGgubG9nKCgoMi4wICogYTIpICsgYmEgKyBzKSAvIChiYSArIGMyKSkpKSAvICg0LjAgKiBhMzIpO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxjdWxhdGUgdGhlIHBvaW50cyBmb3IgYSBxdWFkcmF0aWMgYmV6aWVyIGN1cnZlIGFuZCB0aGVuIGRyYXdzIGl0LlxyXG4gICAgICogQmFzZWQgb246IGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzc4NTA5Ny9ob3ctZG8taS1pbXBsZW1lbnQtYS1iZXppZXItY3VydmUtaW4tY1xyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY3BYIC0gQ29udHJvbCBwb2ludCB4XHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY3BZIC0gQ29udHJvbCBwb2ludCB5XHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdG9YIC0gRGVzdGluYXRpb24gcG9pbnQgeFxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRvWSAtIERlc3RpbmF0aW9uIHBvaW50IHlcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyW119IHBvaW50cyAtIFBvaW50cyB0byBhZGQgc2VnbWVudHMgdG8uXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBjdXJ2ZVRvKGNwWCwgY3BZLCB0b1gsIHRvWSwgcG9pbnRzKSB7XHJcbiAgICAgICAgdmFyIGZyb21YID0gcG9pbnRzW3BvaW50cy5sZW5ndGggLSAyXTtcclxuICAgICAgICB2YXIgZnJvbVkgPSBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDFdO1xyXG4gICAgICAgIHZhciBuID0gc2V0dGluZ3NfMS5zZXR0aW5ncy5HUkFQSElDU19DVVJWRVMuX3NlZ21lbnRzQ291bnQoUXVhZHJhdGljVXRpbHMuY3VydmVMZW5ndGgoZnJvbVgsIGZyb21ZLCBjcFgsIGNwWSwgdG9YLCB0b1kpKTtcclxuICAgICAgICB2YXIgeGEgPSAwO1xyXG4gICAgICAgIHZhciB5YSA9IDA7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPD0gbjsgKytpKSB7XHJcbiAgICAgICAgICAgIHZhciBqID0gaSAvIG47XHJcbiAgICAgICAgICAgIHhhID0gZnJvbVggKyAoKGNwWCAtIGZyb21YKSAqIGopO1xyXG4gICAgICAgICAgICB5YSA9IGZyb21ZICsgKChjcFkgLSBmcm9tWSkgKiBqKTtcclxuICAgICAgICAgICAgcG9pbnRzLnB1c2goeGEgKyAoKChjcFggKyAoKHRvWCAtIGNwWCkgKiBqKSkgLSB4YSkgKiBqKSwgeWEgKyAoKChjcFkgKyAoKHRvWSAtIGNwWSkgKiBqKSkgLSB5YSkgKiBqKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgO1xyXG59XHJcbmV4cG9ydHMuUXVhZHJhdGljVXRpbHMgPSBRdWFkcmF0aWNVdGlscztcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgU2hhcGVTZXR0aW5nc18xID0gcmVxdWlyZShcIi4vU2hhcGVTZXR0aW5nc1wiKTtcclxuY2xhc3MgUmVjdGFuZ2xlIHtcclxuICAgIGNvbnN0cnVjdG9yKHggPSAwLCB5ID0gMCwgd2lkdGggPSAwLCBoZWlnaHQgPSAwKSB7XHJcbiAgICAgICAgaWYgKHggPT09IHZvaWQgMCkge1xyXG4gICAgICAgICAgICB4ID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHkgPT09IHZvaWQgMCkge1xyXG4gICAgICAgICAgICB5ID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHdpZHRoID09PSB2b2lkIDApIHtcclxuICAgICAgICAgICAgd2lkdGggPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaGVpZ2h0ID09PSB2b2lkIDApIHtcclxuICAgICAgICAgICAgaGVpZ2h0ID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICAgICAqIEBkZWZhdWx0IDBcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnggPSBOdW1iZXIoeCk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICAgICAqIEBkZWZhdWx0IDBcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnkgPSBOdW1iZXIoeSk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICAgICAqIEBkZWZhdWx0IDBcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLndpZHRoID0gTnVtYmVyKHdpZHRoKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgICAgICogQGRlZmF1bHQgMFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gTnVtYmVyKGhlaWdodCk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIHR5cGUgb2YgdGhlIG9iamVjdCwgbWFpbmx5IHVzZWQgdG8gYXZvaWQgYGluc3RhbmNlb2ZgIGNoZWNrc1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICAgICAqIEByZWFkT25seVxyXG4gICAgICAgICAqIEBkZWZhdWx0IFBJWEkuU0hBUEVTLlJFQ1RcclxuICAgICAgICAgKiBAc2VlIFBJWEkuU0hBUEVTXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy50eXBlID0gU2hhcGVTZXR0aW5nc18xLlNoYXBlU2V0dGluZ3MuU0hBUEVTLlJFQ1Q7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIHJldHVybnMgdGhlIGxlZnQgZWRnZSBvZiB0aGUgcmVjdGFuZ2xlXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICBnZXQgbGVmdCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy54O1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiByZXR1cm5zIHRoZSByaWdodCBlZGdlIG9mIHRoZSByZWN0YW5nbGVcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIGdldCByaWdodCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy54ICsgdGhpcy53aWR0aDtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogcmV0dXJucyB0aGUgdG9wIGVkZ2Ugb2YgdGhlIHJlY3RhbmdsZVxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgZ2V0IHRvcCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy55O1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiByZXR1cm5zIHRoZSBib3R0b20gZWRnZSBvZiB0aGUgcmVjdGFuZ2xlXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICBnZXQgYm90dG9tKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnkgKyB0aGlzLmhlaWdodDtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQSBjb25zdGFudCBlbXB0eSByZWN0YW5nbGUuXHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQGNvbnN0YW50XHJcbiAgICAgKiBAbWVtYmVyIHtQSVhJLlJlY3RhbmdsZX1cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGdldCBFTVBUWSgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFJlY3RhbmdsZSgwLCAwLCAwLCAwKTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIGNsb25lIG9mIHRoaXMgUmVjdGFuZ2xlXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiB7UElYSS5SZWN0YW5nbGV9IGEgY29weSBvZiB0aGUgcmVjdGFuZ2xlXHJcbiAgICAgKi9cclxuICAgIGNsb25lKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgUmVjdGFuZ2xlKHRoaXMueCwgdGhpcy55LCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIENvcGllcyBhbm90aGVyIHJlY3RhbmdsZSB0byB0aGlzIG9uZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1BJWEkuUmVjdGFuZ2xlfSByZWN0YW5nbGUgLSBUaGUgcmVjdGFuZ2xlIHRvIGNvcHkgZnJvbS5cclxuICAgICAqIEByZXR1cm4ge1BJWEkuUmVjdGFuZ2xlfSBSZXR1cm5zIGl0c2VsZi5cclxuICAgICAqL1xyXG4gICAgY29weUZyb20ocmVjdGFuZ2xlKSB7XHJcbiAgICAgICAgdGhpcy54ID0gcmVjdGFuZ2xlLng7XHJcbiAgICAgICAgdGhpcy55ID0gcmVjdGFuZ2xlLnk7XHJcbiAgICAgICAgdGhpcy53aWR0aCA9IHJlY3RhbmdsZS53aWR0aDtcclxuICAgICAgICB0aGlzLmhlaWdodCA9IHJlY3RhbmdsZS5oZWlnaHQ7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIENvcGllcyB0aGlzIHJlY3RhbmdsZSB0byBhbm90aGVyIG9uZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1BJWEkuUmVjdGFuZ2xlfSByZWN0YW5nbGUgLSBUaGUgcmVjdGFuZ2xlIHRvIGNvcHkgdG8uXHJcbiAgICAgKiBAcmV0dXJuIHtQSVhJLlJlY3RhbmdsZX0gUmV0dXJucyBnaXZlbiBwYXJhbWV0ZXIuXHJcbiAgICAgKi9cclxuICAgIGNvcHlUbyhyZWN0YW5nbGUpIHtcclxuICAgICAgICByZWN0YW5nbGUueCA9IHRoaXMueDtcclxuICAgICAgICByZWN0YW5nbGUueSA9IHRoaXMueTtcclxuICAgICAgICByZWN0YW5nbGUud2lkdGggPSB0aGlzLndpZHRoO1xyXG4gICAgICAgIHJlY3RhbmdsZS5oZWlnaHQgPSB0aGlzLmhlaWdodDtcclxuICAgICAgICByZXR1cm4gcmVjdGFuZ2xlO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgeCBhbmQgeSBjb29yZGluYXRlcyBnaXZlbiBhcmUgY29udGFpbmVkIHdpdGhpbiB0aGlzIFJlY3RhbmdsZVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQgdG8gdGVzdFxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgLSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBwb2ludCB0byB0ZXN0XHJcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSB4L3kgY29vcmRpbmF0ZXMgYXJlIHdpdGhpbiB0aGlzIFJlY3RhbmdsZVxyXG4gICAgICovXHJcbiAgICBjb250YWlucyh4LCB5KSB7XHJcbiAgICAgICAgaWYgKHRoaXMud2lkdGggPD0gMCB8fCB0aGlzLmhlaWdodCA8PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHggPj0gdGhpcy54ICYmIHggPCB0aGlzLnggKyB0aGlzLndpZHRoKSB7XHJcbiAgICAgICAgICAgIGlmICh5ID49IHRoaXMueSAmJiB5IDwgdGhpcy55ICsgdGhpcy5oZWlnaHQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogUGFkcyB0aGUgcmVjdGFuZ2xlIG1ha2luZyBpdCBncm93IGluIGFsbCBkaXJlY3Rpb25zLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwYWRkaW5nWCAtIFRoZSBob3Jpem9udGFsIHBhZGRpbmcgYW1vdW50LlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBhZGRpbmdZIC0gVGhlIHZlcnRpY2FsIHBhZGRpbmcgYW1vdW50LlxyXG4gICAgICovXHJcbiAgICBwYWQocGFkZGluZ1gsIHBhZGRpbmdZKSB7XHJcbiAgICAgICAgcGFkZGluZ1ggPSBwYWRkaW5nWCB8fCAwO1xyXG4gICAgICAgIHBhZGRpbmdZID0gcGFkZGluZ1kgfHwgKChwYWRkaW5nWSAhPT0gMCkgPyBwYWRkaW5nWCA6IDApO1xyXG4gICAgICAgIHRoaXMueCAtPSBwYWRkaW5nWDtcclxuICAgICAgICB0aGlzLnkgLT0gcGFkZGluZ1k7XHJcbiAgICAgICAgdGhpcy53aWR0aCArPSBwYWRkaW5nWCAqIDI7XHJcbiAgICAgICAgdGhpcy5oZWlnaHQgKz0gcGFkZGluZ1kgKiAyO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBGaXRzIHRoaXMgcmVjdGFuZ2xlIGFyb3VuZCB0aGUgcGFzc2VkIG9uZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1BJWEkuUmVjdGFuZ2xlfSByZWN0YW5nbGUgLSBUaGUgcmVjdGFuZ2xlIHRvIGZpdC5cclxuICAgICAqL1xyXG4gICAgZml0KHJlY3RhbmdsZSkge1xyXG4gICAgICAgIHZhciB4MSA9IE1hdGgubWF4KHRoaXMueCwgcmVjdGFuZ2xlLngpO1xyXG4gICAgICAgIHZhciB4MiA9IE1hdGgubWluKHRoaXMueCArIHRoaXMud2lkdGgsIHJlY3RhbmdsZS54ICsgcmVjdGFuZ2xlLndpZHRoKTtcclxuICAgICAgICB2YXIgeTEgPSBNYXRoLm1heCh0aGlzLnksIHJlY3RhbmdsZS55KTtcclxuICAgICAgICB2YXIgeTIgPSBNYXRoLm1pbih0aGlzLnkgKyB0aGlzLmhlaWdodCwgcmVjdGFuZ2xlLnkgKyByZWN0YW5nbGUuaGVpZ2h0KTtcclxuICAgICAgICB0aGlzLnggPSB4MTtcclxuICAgICAgICB0aGlzLndpZHRoID0gTWF0aC5tYXgoeDIgLSB4MSwgMCk7XHJcbiAgICAgICAgdGhpcy55ID0geTE7XHJcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBNYXRoLm1heCh5MiAtIHkxLCAwKTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogRW5sYXJnZXMgcmVjdGFuZ2xlIHRoYXQgd2F5IGl0cyBjb3JuZXJzIGxpZSBvbiBncmlkXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtyZXNvbHV0aW9uPTFdIHJlc29sdXRpb25cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZXBzPTAuMDAxXSBwcmVjaXNpb25cclxuICAgICAqL1xyXG4gICAgY2VpbChyZXNvbHV0aW9uLCBlcHMpIHtcclxuICAgICAgICBpZiAocmVzb2x1dGlvbiA9PT0gdm9pZCAwKSB7XHJcbiAgICAgICAgICAgIHJlc29sdXRpb24gPSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZXBzID09PSB2b2lkIDApIHtcclxuICAgICAgICAgICAgZXBzID0gMC4wMDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciB4MiA9IE1hdGguY2VpbCgodGhpcy54ICsgdGhpcy53aWR0aCAtIGVwcykgKiByZXNvbHV0aW9uKSAvIHJlc29sdXRpb247XHJcbiAgICAgICAgdmFyIHkyID0gTWF0aC5jZWlsKCh0aGlzLnkgKyB0aGlzLmhlaWdodCAtIGVwcykgKiByZXNvbHV0aW9uKSAvIHJlc29sdXRpb247XHJcbiAgICAgICAgdGhpcy54ID0gTWF0aC5mbG9vcigodGhpcy54ICsgZXBzKSAqIHJlc29sdXRpb24pIC8gcmVzb2x1dGlvbjtcclxuICAgICAgICB0aGlzLnkgPSBNYXRoLmZsb29yKCh0aGlzLnkgKyBlcHMpICogcmVzb2x1dGlvbikgLyByZXNvbHV0aW9uO1xyXG4gICAgICAgIHRoaXMud2lkdGggPSB4MiAtIHRoaXMueDtcclxuICAgICAgICB0aGlzLmhlaWdodCA9IHkyIC0gdGhpcy55O1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBFbmxhcmdlcyB0aGlzIHJlY3RhbmdsZSB0byBpbmNsdWRlIHRoZSBwYXNzZWQgcmVjdGFuZ2xlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7UElYSS5SZWN0YW5nbGV9IHJlY3RhbmdsZSAtIFRoZSByZWN0YW5nbGUgdG8gaW5jbHVkZS5cclxuICAgICAqL1xyXG4gICAgZW5sYXJnZShyZWN0YW5nbGUpIHtcclxuICAgICAgICB2YXIgeDEgPSBNYXRoLm1pbih0aGlzLngsIHJlY3RhbmdsZS54KTtcclxuICAgICAgICB2YXIgeDIgPSBNYXRoLm1heCh0aGlzLnggKyB0aGlzLndpZHRoLCByZWN0YW5nbGUueCArIHJlY3RhbmdsZS53aWR0aCk7XHJcbiAgICAgICAgdmFyIHkxID0gTWF0aC5taW4odGhpcy55LCByZWN0YW5nbGUueSk7XHJcbiAgICAgICAgdmFyIHkyID0gTWF0aC5tYXgodGhpcy55ICsgdGhpcy5oZWlnaHQsIHJlY3RhbmdsZS55ICsgcmVjdGFuZ2xlLmhlaWdodCk7XHJcbiAgICAgICAgdGhpcy54ID0geDE7XHJcbiAgICAgICAgdGhpcy53aWR0aCA9IHgyIC0geDE7XHJcbiAgICAgICAgdGhpcy55ID0geTE7XHJcbiAgICAgICAgdGhpcy5oZWlnaHQgPSB5MiAtIHkxO1xyXG4gICAgfVxyXG4gICAgO1xyXG59XHJcbmV4cG9ydHMuUmVjdGFuZ2xlID0gUmVjdGFuZ2xlO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBUZXh0dXJlXzEgPSByZXF1aXJlKFwiLi9UZXh0dXJlXCIpO1xyXG5jb25zdCBCYXNlUmVuZGVyVGV4dHVyZV8xID0gcmVxdWlyZShcIi4vQmFzZVJlbmRlclRleHR1cmVcIik7XHJcbmNsYXNzIFJlbmRlclRleHR1cmUgZXh0ZW5kcyBUZXh0dXJlXzEuVGV4dHVyZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihiYXNlUmVuZGVyVGV4dHVyZSA9IG51bGwsIGZyYW1lID0gbnVsbCkge1xyXG4gICAgICAgIHN1cGVyKGJhc2VSZW5kZXJUZXh0dXJlLCBmcmFtZSk7XHJcbiAgICAgICAgdmFyIF9sZWdhY3lSZW5kZXJlciA9IG51bGw7XHJcbiAgICAgICAgaWYgKCEoYmFzZVJlbmRlclRleHR1cmUgaW5zdGFuY2VvZiBCYXNlUmVuZGVyVGV4dHVyZV8xLkJhc2VSZW5kZXJUZXh0dXJlKSkge1xyXG4gICAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBwcmVmZXItcmVzdC1wYXJhbXMsIG5vLWNvbnNvbGUgKi9cclxuICAgICAgICAgICAgdmFyIHdpZHRoID0gYXJndW1lbnRzWzFdO1xyXG4gICAgICAgICAgICB2YXIgaGVpZ2h0ID0gYXJndW1lbnRzWzJdO1xyXG4gICAgICAgICAgICB2YXIgc2NhbGVNb2RlID0gYXJndW1lbnRzWzNdO1xyXG4gICAgICAgICAgICB2YXIgcmVzb2x1dGlvbiA9IGFyZ3VtZW50c1s0XTtcclxuICAgICAgICAgICAgLy8gd2UgaGF2ZSBhbiBvbGQgcmVuZGVyIHRleHR1cmUuLlxyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oKFwiUGxlYXNlIHVzZSBSZW5kZXJUZXh0dXJlLmNyZWF0ZShcIiArIHdpZHRoICsgXCIsIFwiICsgaGVpZ2h0ICsgXCIpIGluc3RlYWQgb2YgdGhlIGN0b3IgZGlyZWN0bHkuXCIpKTtcclxuICAgICAgICAgICAgX2xlZ2FjeVJlbmRlcmVyID0gYXJndW1lbnRzWzBdO1xyXG4gICAgICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIHByZWZlci1yZXN0LXBhcmFtcywgbm8tY29uc29sZSAqL1xyXG4gICAgICAgICAgICBmcmFtZSA9IG51bGw7XHJcbiAgICAgICAgICAgIGJhc2VSZW5kZXJUZXh0dXJlID0gbmV3IEJhc2VSZW5kZXJUZXh0dXJlXzEuQmFzZVJlbmRlclRleHR1cmUoe1xyXG4gICAgICAgICAgICAgICAgd2lkdGg6IHdpZHRoLFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHQsXHJcbiAgICAgICAgICAgICAgICBzY2FsZU1vZGU6IHNjYWxlTW9kZSxcclxuICAgICAgICAgICAgICAgIHJlc29sdXRpb246IHJlc29sdXRpb24sXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmxlZ2FjeVJlbmRlcmVyID0gX2xlZ2FjeVJlbmRlcmVyO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoaXMgd2lsbCBsZXQgdGhlIHJlbmRlcmVyIGtub3cgaWYgdGhlIHRleHR1cmUgaXMgdmFsaWQuIElmIGl0J3Mgbm90IHRoZW4gaXQgY2Fubm90IGJlIHJlbmRlcmVkLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQG1lbWJlciB7Ym9vbGVhbn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnZhbGlkID0gdHJ1ZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBGaWx0ZXJTeXN0ZW0gdGVtcG9yYXJ5IHN0b3JhZ2VcclxuICAgICAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgICAgICogQG1lbWJlciB7UElYSS5SZWN0YW5nbGV9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5maWx0ZXJGcmFtZSA9IG51bGw7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgKiBUaGUga2V5IGZvciBwb29sZWQgdGV4dHVyZSBvZiBGaWx0ZXJTeXN0ZW1cclxuICAgICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAgICAqIEBtZW1iZXIge3N0cmluZ31cclxuICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuZmlsdGVyUG9vbEtleSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy51cGRhdGVVdnMoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgKiBSZXNpemVzIHRoZSBSZW5kZXJUZXh0dXJlLlxyXG4gICAgKlxyXG4gICAgKiBAcGFyYW0ge251bWJlcn0gd2lkdGggLSBUaGUgd2lkdGggdG8gcmVzaXplIHRvLlxyXG4gICAgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IC0gVGhlIGhlaWdodCB0byByZXNpemUgdG8uXHJcbiAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3Jlc2l6ZUJhc2VUZXh0dXJlPXRydWVdIC0gU2hvdWxkIHRoZSBiYXNlVGV4dHVyZS53aWR0aCBhbmQgaGVpZ2h0IHZhbHVlcyBiZSByZXNpemVkIGFzIHdlbGw/XHJcbiAgICAqL1xyXG4gICAgcmVzaXplKHdpZHRoLCBoZWlnaHQsIHJlc2l6ZUJhc2VUZXh0dXJlKSB7XHJcbiAgICAgICAgaWYgKHJlc2l6ZUJhc2VUZXh0dXJlID09PSB2b2lkIDApIHtcclxuICAgICAgICAgICAgcmVzaXplQmFzZVRleHR1cmUgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB3aWR0aCA9IE1hdGguY2VpbCh3aWR0aCk7XHJcbiAgICAgICAgaGVpZ2h0ID0gTWF0aC5jZWlsKGhlaWdodCk7XHJcbiAgICAgICAgLy8gVE9ETyAtIGNvdWxkIGJlIG5vdCByZXF1aXJlZC4uXHJcbiAgICAgICAgdGhpcy52YWxpZCA9ICh3aWR0aCA+IDAgJiYgaGVpZ2h0ID4gMCk7XHJcbiAgICAgICAgdGhpcy5fZnJhbWUud2lkdGggPSB0aGlzLm9yaWcud2lkdGggPSB3aWR0aDtcclxuICAgICAgICB0aGlzLl9mcmFtZS5oZWlnaHQgPSB0aGlzLm9yaWcuaGVpZ2h0ID0gaGVpZ2h0O1xyXG4gICAgICAgIGlmIChyZXNpemVCYXNlVGV4dHVyZSkge1xyXG4gICAgICAgICAgICB0aGlzLmJhc2VUZXh0dXJlLnJlc2l6ZSh3aWR0aCwgaGVpZ2h0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy51cGRhdGVVdnMoKTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQSBzaG9ydCBoYW5kIHdheSBvZiBjcmVhdGluZyBhIHJlbmRlciB0ZXh0dXJlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gLSBPcHRpb25zXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMud2lkdGg9MTAwXSAtIFRoZSB3aWR0aCBvZiB0aGUgcmVuZGVyIHRleHR1cmVcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5oZWlnaHQ9MTAwXSAtIFRoZSBoZWlnaHQgb2YgdGhlIHJlbmRlciB0ZXh0dXJlXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuc2NhbGVNb2RlPVBJWEkuc2V0dGluZ3MuU0NBTEVfTU9ERV0gLSBTZWUge0BsaW5rIFBJWEkuU0NBTEVfTU9ERVN9IGZvciBwb3NzaWJsZSB2YWx1ZXNcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5yZXNvbHV0aW9uPTFdIC0gVGhlIHJlc29sdXRpb24gLyBkZXZpY2UgcGl4ZWwgcmF0aW8gb2YgdGhlIHRleHR1cmUgYmVpbmcgZ2VuZXJhdGVkXHJcbiAgICAgKiBAcmV0dXJuIHtQSVhJLlJlbmRlclRleHR1cmV9IFRoZSBuZXcgcmVuZGVyIHRleHR1cmVcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGNyZWF0ZShvcHRpb25zLCBoZWlnaHQgPSBudWxsLCBzY2FsZU1vZGUgPSBudWxsLCByZXNvbHV0aW9uID0gbnVsbCkge1xyXG4gICAgICAgIC8vIGZhbGxiYWNrLCBvbGQtc3R5bGU6IGNyZWF0ZSh3aWR0aCwgaGVpZ2h0LCBzY2FsZU1vZGUsIHJlc29sdXRpb24pXHJcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBwcmVmZXItcmVzdC1wYXJhbXMgKi9cclxuICAgICAgICAgICAgb3B0aW9ucyA9IHtcclxuICAgICAgICAgICAgICAgIHdpZHRoOiBvcHRpb25zLFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBhcmd1bWVudHNbMV0sXHJcbiAgICAgICAgICAgICAgICBzY2FsZU1vZGU6IGFyZ3VtZW50c1syXSxcclxuICAgICAgICAgICAgICAgIHJlc29sdXRpb246IGFyZ3VtZW50c1szXSxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLyogZXNsaW50LWVuYWJsZSBwcmVmZXItcmVzdC1wYXJhbXMgKi9cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBSZW5kZXJUZXh0dXJlKG5ldyBCYXNlUmVuZGVyVGV4dHVyZV8xLkJhc2VSZW5kZXJUZXh0dXJlKG9wdGlvbnMpKTtcclxuICAgIH1cclxuICAgIDtcclxufVxyXG5leHBvcnRzLlJlbmRlclRleHR1cmUgPSBSZW5kZXJUZXh0dXJlO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBTeXN0ZW1fMSA9IHJlcXVpcmUoXCIuL1N5c3RlbVwiKTtcclxuY29uc3QgUmVjdGFuZ2xlXzEgPSByZXF1aXJlKFwiLi9SZWN0YW5nbGVcIik7XHJcbmNsYXNzIFJlbmRlclRleHR1cmVTeXN0ZW0gZXh0ZW5kcyBTeXN0ZW1fMS5TeXN0ZW0ge1xyXG4gICAgY29uc3RydWN0b3IocmVuZGVyZXIpIHtcclxuICAgICAgICBzdXBlcihyZW5kZXJlcik7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGNsZWFyIGJhY2tncm91bmQgY29sb3IgYXMgcmdiYVxyXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcltdfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuY2xlYXJDb2xvciA9IHJlbmRlcmVyLl9iYWNrZ3JvdW5kQ29sb3JSZ2JhO1xyXG4gICAgICAgIC8vIFRPRE8gbW92ZSB0aGlzIHByb3BlcnR5IHNvbWV3aGVyZSBlbHNlIVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIExpc3Qgb2YgbWFza3MgZm9yIHRoZSBTdGVuY2lsU3lzdGVtXHJcbiAgICAgICAgICogQG1lbWJlciB7UElYSS5HcmFwaGljc1tdfVxyXG4gICAgICAgICAqIEByZWFkb25seVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuZGVmYXVsdE1hc2tTdGFjayA9IFtdO1xyXG4gICAgICAgIC8vIGVtcHR5IHJlbmRlciB0ZXh0dXJlP1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlbmRlciB0ZXh0dXJlXHJcbiAgICAgICAgICogQG1lbWJlciB7UElYSS5SZW5kZXJUZXh0dXJlfVxyXG4gICAgICAgICAqIEByZWFkb25seVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuY3VycmVudCA9IG51bGw7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU291cmNlIGZyYW1lXHJcbiAgICAgICAgICogQG1lbWJlciB7UElYSS5SZWN0YW5nbGV9XHJcbiAgICAgICAgICogQHJlYWRvbmx5XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5zb3VyY2VGcmFtZSA9IG5ldyBSZWN0YW5nbGVfMS5SZWN0YW5nbGUoKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBEZXN0aW5hdGlvbiBmcmFtZVxyXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuUmVjdGFuZ2xlfVxyXG4gICAgICAgICAqIEByZWFkb25seVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuZGVzdGluYXRpb25GcmFtZSA9IG5ldyBSZWN0YW5nbGVfMS5SZWN0YW5nbGUoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQmluZCB0aGUgY3VycmVudCByZW5kZXIgdGV4dHVyZVxyXG4gICAgICogQHBhcmFtIHtQSVhJLlJlbmRlclRleHR1cmV9IHJlbmRlclRleHR1cmVcclxuICAgICAqIEBwYXJhbSB7UElYSS5SZWN0YW5nbGV9IHNvdXJjZUZyYW1lXHJcbiAgICAgKiBAcGFyYW0ge1BJWEkuUmVjdGFuZ2xlfSBkZXN0aW5hdGlvbkZyYW1lXHJcbiAgICAgKi9cclxuICAgIGJpbmQocmVuZGVyVGV4dHVyZSwgc291cmNlRnJhbWUgPSBudWxsLCBkZXN0aW5hdGlvbkZyYW1lID0gbnVsbCkge1xyXG4gICAgICAgIGlmIChyZW5kZXJUZXh0dXJlID09PSB2b2lkIDApIHtcclxuICAgICAgICAgICAgcmVuZGVyVGV4dHVyZSA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY3VycmVudCA9IHJlbmRlclRleHR1cmU7XHJcbiAgICAgICAgdmFyIHJlbmRlcmVyID0gdGhpcy5yZW5kZXJlcjtcclxuICAgICAgICB2YXIgcmVzb2x1dGlvbjtcclxuICAgICAgICBpZiAocmVuZGVyVGV4dHVyZSkge1xyXG4gICAgICAgICAgICB2YXIgYmFzZVRleHR1cmUgPSByZW5kZXJUZXh0dXJlLmJhc2VUZXh0dXJlO1xyXG4gICAgICAgICAgICByZXNvbHV0aW9uID0gYmFzZVRleHR1cmUucmVzb2x1dGlvbjtcclxuICAgICAgICAgICAgaWYgKCFkZXN0aW5hdGlvbkZyYW1lKSB7XHJcbiAgICAgICAgICAgICAgICBSZW5kZXJUZXh0dXJlU3lzdGVtLnRlbXBSZWN0LndpZHRoID0gYmFzZVRleHR1cmUucmVhbFdpZHRoO1xyXG4gICAgICAgICAgICAgICAgUmVuZGVyVGV4dHVyZVN5c3RlbS50ZW1wUmVjdC5oZWlnaHQgPSBiYXNlVGV4dHVyZS5yZWFsSGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgZGVzdGluYXRpb25GcmFtZSA9IFJlbmRlclRleHR1cmVTeXN0ZW0udGVtcFJlY3Q7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFzb3VyY2VGcmFtZSkge1xyXG4gICAgICAgICAgICAgICAgc291cmNlRnJhbWUgPSBkZXN0aW5hdGlvbkZyYW1lO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuZnJhbWVidWZmZXIuYmluZChiYXNlVGV4dHVyZS5mcmFtZWJ1ZmZlciwgZGVzdGluYXRpb25GcmFtZSk7XHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIucHJvamVjdGlvbi51cGRhdGUoZGVzdGluYXRpb25GcmFtZSwgc291cmNlRnJhbWUsIHJlc29sdXRpb24sIGZhbHNlKTtcclxuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5zdGVuY2lsLnNldE1hc2tTdGFjayhiYXNlVGV4dHVyZS5zdGVuY2lsTWFza1N0YWNrKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJlc29sdXRpb24gPSB0aGlzLnJlbmRlcmVyLnJlc29sdXRpb247XHJcbiAgICAgICAgICAgIC8vIFRPRE8gdGhlc2UgdmFsaWRhdGlvbiBjaGVja3MgaGFwcGVuIGRlZXBlciBkb3duLi5cclxuICAgICAgICAgICAgLy8gdGhpbmcgdGhleSBjYW4gYmUgYXZvaWRlZC4uXHJcbiAgICAgICAgICAgIGlmICghZGVzdGluYXRpb25GcmFtZSkge1xyXG4gICAgICAgICAgICAgICAgUmVuZGVyVGV4dHVyZVN5c3RlbS50ZW1wUmVjdC53aWR0aCA9IHJlbmRlcmVyLndpZHRoO1xyXG4gICAgICAgICAgICAgICAgUmVuZGVyVGV4dHVyZVN5c3RlbS50ZW1wUmVjdC5oZWlnaHQgPSByZW5kZXJlci5oZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbkZyYW1lID0gUmVuZGVyVGV4dHVyZVN5c3RlbS50ZW1wUmVjdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIXNvdXJjZUZyYW1lKSB7XHJcbiAgICAgICAgICAgICAgICBzb3VyY2VGcmFtZSA9IGRlc3RpbmF0aW9uRnJhbWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmVuZGVyZXIuZnJhbWVidWZmZXIuYmluZChudWxsLCBkZXN0aW5hdGlvbkZyYW1lKTtcclxuICAgICAgICAgICAgLy8gVE9ETyBzdG9yZSB0aGlzLi5cclxuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5wcm9qZWN0aW9uLnVwZGF0ZShkZXN0aW5hdGlvbkZyYW1lLCBzb3VyY2VGcmFtZSwgcmVzb2x1dGlvbiwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuc3RlbmNpbC5zZXRNYXNrU3RhY2sodGhpcy5kZWZhdWx0TWFza1N0YWNrKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zb3VyY2VGcmFtZS5jb3B5RnJvbShzb3VyY2VGcmFtZSk7XHJcbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbkZyYW1lLnggPSBkZXN0aW5hdGlvbkZyYW1lLnggLyByZXNvbHV0aW9uO1xyXG4gICAgICAgIHRoaXMuZGVzdGluYXRpb25GcmFtZS55ID0gZGVzdGluYXRpb25GcmFtZS55IC8gcmVzb2x1dGlvbjtcclxuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uRnJhbWUud2lkdGggPSBkZXN0aW5hdGlvbkZyYW1lLndpZHRoIC8gcmVzb2x1dGlvbjtcclxuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uRnJhbWUuaGVpZ2h0ID0gZGVzdGluYXRpb25GcmFtZS5oZWlnaHQgLyByZXNvbHV0aW9uO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBFcmFzZXMgdGhlIHJlbmRlciB0ZXh0dXJlIGFuZCBmaWxscyB0aGUgZHJhd2luZyBhcmVhIHdpdGggYSBjb2xvdXJcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcltdfSBbY2xlYXJDb2xvcl0gLSBUaGUgY29sb3IgYXMgcmdiYSwgZGVmYXVsdCB0byB1c2UgdGhlIHJlbmRlcmVyIGJhY2tncm91bmRDb2xvclxyXG4gICAgICogQHJldHVybiB7UElYSS5SZW5kZXJlcn0gUmV0dXJucyBpdHNlbGYuXHJcbiAgICAgKi9cclxuICAgIGNsZWFyKGNsZWFyQ29sb3IgPSBudWxsKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudCkge1xyXG4gICAgICAgICAgICBjbGVhckNvbG9yID0gY2xlYXJDb2xvciB8fCB0aGlzLmN1cnJlbnQuYmFzZVRleHR1cmUuY2xlYXJDb2xvcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNsZWFyQ29sb3IgPSBjbGVhckNvbG9yIHx8IHRoaXMuY2xlYXJDb2xvcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5yZW5kZXJlci5mcmFtZWJ1ZmZlci5jbGVhcihjbGVhckNvbG9yWzBdLCBjbGVhckNvbG9yWzFdLCBjbGVhckNvbG9yWzJdLCBjbGVhckNvbG9yWzNdKTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIHJlc2l6ZSgpIHtcclxuICAgICAgICAvLyByZXNpemUgdGhlIHJvb3Qgb25seSFcclxuICAgICAgICB0aGlzLmJpbmQobnVsbCk7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFJlc2V0cyByZW5kZXJUZXh0dXJlIHN0YXRlXHJcbiAgICAgKi9cclxuICAgIHJlc2V0KCkge1xyXG4gICAgICAgIHRoaXMuYmluZChudWxsKTtcclxuICAgIH1cclxuICAgIDtcclxufVxyXG5SZW5kZXJUZXh0dXJlU3lzdGVtLnRlbXBSZWN0ID0gbmV3IFJlY3RhbmdsZV8xLlJlY3RhbmdsZSgpO1xyXG5leHBvcnRzLlJlbmRlclRleHR1cmVTeXN0ZW0gPSBSZW5kZXJUZXh0dXJlU3lzdGVtO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBBYnN0cmFjdFJlbmRlcmVyXzEgPSByZXF1aXJlKFwiLi9BYnN0cmFjdFJlbmRlcmVyXCIpO1xyXG5jb25zdCBVbmlmb3JtR3JvdXBfMSA9IHJlcXVpcmUoXCIuL1VuaWZvcm1Hcm91cFwiKTtcclxuY29uc3QgTWF0cml4XzEgPSByZXF1aXJlKFwiLi9NYXRyaXhcIik7XHJcbmNvbnN0IEV2ZW50XzEgPSByZXF1aXJlKFwiLi9FdmVudFwiKTtcclxuY29uc3QgQmF0Y2hSZW5kZXJlcl8xID0gcmVxdWlyZShcIi4vQmF0Y2hSZW5kZXJlclwiKTtcclxuY29uc3QgQmF0Y2hTeXN0ZW1fMSA9IHJlcXVpcmUoXCIuL0JhdGNoU3lzdGVtXCIpO1xyXG5jb25zdCBSZW5kZXJUZXh0dXJlU3lzdGVtXzEgPSByZXF1aXJlKFwiLi9SZW5kZXJUZXh0dXJlU3lzdGVtXCIpO1xyXG5jb25zdCBGaWx0ZXJTeXN0ZW1fMSA9IHJlcXVpcmUoXCIuL0ZpbHRlclN5c3RlbVwiKTtcclxuY29uc3QgVGV4dHVyZUdDU3lzdGVtXzEgPSByZXF1aXJlKFwiLi9UZXh0dXJlR0NTeXN0ZW1cIik7XHJcbmNvbnN0IFByb2plY3Rpb25TeXN0ZW1fMSA9IHJlcXVpcmUoXCIuL1Byb2plY3Rpb25TeXN0ZW1cIik7XHJcbmNvbnN0IFN0ZW5jaWxTeXN0ZW1fMSA9IHJlcXVpcmUoXCIuL1N0ZW5jaWxTeXN0ZW1cIik7XHJcbmNvbnN0IEZyYW1lYnVmZmVyU3lzdGVtXzEgPSByZXF1aXJlKFwiLi9GcmFtZWJ1ZmZlclN5c3RlbVwiKTtcclxuY29uc3QgR2VvbWV0cnlTeXN0ZW1fMSA9IHJlcXVpcmUoXCIuL0dlb21ldHJ5U3lzdGVtXCIpO1xyXG5jb25zdCBUZXh0dXJlU3lzdGVtXzEgPSByZXF1aXJlKFwiLi9UZXh0dXJlU3lzdGVtXCIpO1xyXG5jb25zdCBTaGFkZXJTeXN0ZW1fMSA9IHJlcXVpcmUoXCIuL1NoYWRlclN5c3RlbVwiKTtcclxuY29uc3QgU3RhdGVTeXN0ZW1fMSA9IHJlcXVpcmUoXCIuL1N0YXRlU3lzdGVtXCIpO1xyXG5jb25zdCBDb250ZXh0U3lzdGVtXzEgPSByZXF1aXJlKFwiLi9Db250ZXh0U3lzdGVtXCIpO1xyXG5jb25zdCBNYXNrU3lzdGVtXzEgPSByZXF1aXJlKFwiLi9NYXNrU3lzdGVtXCIpO1xyXG5jb25zdCBEaXNwbGF5U2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL0Rpc3BsYXlTZXR0aW5nc1wiKTtcclxuY29uc3QgVGlsaW5nU3ByaXRlUmVuZGVyZXJfMSA9IHJlcXVpcmUoXCIuL1RpbGluZ1Nwcml0ZVJlbmRlcmVyXCIpO1xyXG5jb25zdCBBY2Nlc3NpYmlsaXR5TWFuYWdlcl8xID0gcmVxdWlyZShcIi4vQWNjZXNzaWJpbGl0eU1hbmFnZXJcIik7XHJcbmNvbnN0IEV4dHJhY3RfMSA9IHJlcXVpcmUoXCIuL0V4dHJhY3RcIik7XHJcbmNvbnN0IEludGVyYWN0aW9uTWFuYWdlcl8xID0gcmVxdWlyZShcIi4vSW50ZXJhY3Rpb25NYW5hZ2VyXCIpO1xyXG5jb25zdCBQYXJ0aWNsZVJlbmRlcmVyXzEgPSByZXF1aXJlKFwiLi9QYXJ0aWNsZVJlbmRlcmVyXCIpO1xyXG5jb25zdCBQcmVwYXJlXzEgPSByZXF1aXJlKFwiLi9QcmVwYXJlXCIpO1xyXG5jb25zdCBSdW5uZXJfMSA9IHJlcXVpcmUoXCIuL1J1bm5lclwiKTtcclxuY2xhc3MgUmVuZGVyZXIgZXh0ZW5kcyBBYnN0cmFjdFJlbmRlcmVyXzEuQWJzdHJhY3RSZW5kZXJlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XHJcbiAgICAgICAgc3VwZXIoJ1dlYkdMJywgb3B0aW9ucyk7XHJcbiAgICAgICAgdGhpcy5wbHVnaW5zID0ge307XHJcbiAgICAgICAgdGhpcy50eXBlID0gRGlzcGxheVNldHRpbmdzXzEuRGlzcGxheVNldHRpbmdzLlJFTkRFUkVSX1RZUEUuV0VCR0w7XHJcbiAgICAgICAgdGhpcy5nbCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5DT05URVhUX1VJRCA9IDA7XHJcbiAgICAgICAgdGhpcy5ydW5uZXJzID0ge1xyXG4gICAgICAgICAgICBkZXN0cm95OiBuZXcgUnVubmVyXzEuUnVubmVyKCdkZXN0cm95JyksXHJcbiAgICAgICAgICAgIGNvbnRleHRDaGFuZ2U6IG5ldyBSdW5uZXJfMS5SdW5uZXIoJ2NvbnRleHRDaGFuZ2UnLCAxKSxcclxuICAgICAgICAgICAgcmVzZXQ6IG5ldyBSdW5uZXJfMS5SdW5uZXIoJ3Jlc2V0JyksXHJcbiAgICAgICAgICAgIHVwZGF0ZTogbmV3IFJ1bm5lcl8xLlJ1bm5lcigndXBkYXRlJyksXHJcbiAgICAgICAgICAgIHBvc3RyZW5kZXI6IG5ldyBSdW5uZXJfMS5SdW5uZXIoJ3Bvc3RyZW5kZXInKSxcclxuICAgICAgICAgICAgcHJlcmVuZGVyOiBuZXcgUnVubmVyXzEuUnVubmVyKCdwcmVyZW5kZXInKSxcclxuICAgICAgICAgICAgcmVzaXplOiBuZXcgUnVubmVyXzEuUnVubmVyKCdyZXNpemUnLCAyKSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuZ2xvYmFsVW5pZm9ybXMgPSBuZXcgVW5pZm9ybUdyb3VwXzEuVW5pZm9ybUdyb3VwKHtcclxuICAgICAgICAgICAgcHJvamVjdGlvbk1hdHJpeDogbmV3IE1hdHJpeF8xLk1hdHJpeCgpLFxyXG4gICAgICAgIH0sIHRydWUpO1xyXG4gICAgICAgIHRoaXMuYWRkU3lzdGVtKE1hc2tTeXN0ZW1fMS5NYXNrU3lzdGVtLCAnbWFzaycpXHJcbiAgICAgICAgICAgIC5hZGRTeXN0ZW0oQ29udGV4dFN5c3RlbV8xLkNvbnRleHRTeXN0ZW0sICdjb250ZXh0JylcclxuICAgICAgICAgICAgLmFkZFN5c3RlbShTdGF0ZVN5c3RlbV8xLlN0YXRlU3lzdGVtLCAnc3RhdGUnKVxyXG4gICAgICAgICAgICAuYWRkU3lzdGVtKFNoYWRlclN5c3RlbV8xLlNoYWRlclN5c3RlbSwgJ3NoYWRlcicpXHJcbiAgICAgICAgICAgIC5hZGRTeXN0ZW0oVGV4dHVyZVN5c3RlbV8xLlRleHR1cmVTeXN0ZW0sICd0ZXh0dXJlJylcclxuICAgICAgICAgICAgLmFkZFN5c3RlbShHZW9tZXRyeVN5c3RlbV8xLkdlb21ldHJ5U3lzdGVtLCAnZ2VvbWV0cnknKVxyXG4gICAgICAgICAgICAuYWRkU3lzdGVtKEZyYW1lYnVmZmVyU3lzdGVtXzEuRnJhbWVidWZmZXJTeXN0ZW0sICdmcmFtZWJ1ZmZlcicpXHJcbiAgICAgICAgICAgIC5hZGRTeXN0ZW0oU3RlbmNpbFN5c3RlbV8xLlN0ZW5jaWxTeXN0ZW0sICdzdGVuY2lsJylcclxuICAgICAgICAgICAgLmFkZFN5c3RlbShQcm9qZWN0aW9uU3lzdGVtXzEuUHJvamVjdGlvblN5c3RlbSwgJ3Byb2plY3Rpb24nKVxyXG4gICAgICAgICAgICAuYWRkU3lzdGVtKFRleHR1cmVHQ1N5c3RlbV8xLlRleHR1cmVHQ1N5c3RlbSwgJ3RleHR1cmVHQycpXHJcbiAgICAgICAgICAgIC5hZGRTeXN0ZW0oRmlsdGVyU3lzdGVtXzEuRmlsdGVyU3lzdGVtLCAnZmlsdGVyJylcclxuICAgICAgICAgICAgLmFkZFN5c3RlbShSZW5kZXJUZXh0dXJlU3lzdGVtXzEuUmVuZGVyVGV4dHVyZVN5c3RlbSwgJ3JlbmRlclRleHR1cmUnKVxyXG4gICAgICAgICAgICAuYWRkU3lzdGVtKEJhdGNoU3lzdGVtXzEuQmF0Y2hTeXN0ZW0sICdiYXRjaCcpO1xyXG4gICAgICAgIHRoaXMuaW5pdFBsdWdpbnMoUmVuZGVyZXIuX19wbHVnaW5zKTtcclxuICAgICAgICBpZiAob3B0aW9ucy5jb250ZXh0KSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5pbml0RnJvbUNvbnRleHQob3B0aW9ucy5jb250ZXh0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5pbml0RnJvbU9wdGlvbnMoe1xyXG4gICAgICAgICAgICAgICAgYWxwaGE6IHRoaXMudHJhbnNwYXJlbnQsXHJcbiAgICAgICAgICAgICAgICBhbnRpYWxpYXM6IG9wdGlvbnMuYW50aWFsaWFzLFxyXG4gICAgICAgICAgICAgICAgcHJlbXVsdGlwbGllZEFscGhhOiB0aGlzLnRyYW5zcGFyZW50LFxyXG4gICAgICAgICAgICAgICAgc3RlbmNpbDogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIHByZXNlcnZlRHJhd2luZ0J1ZmZlcjogb3B0aW9ucy5wcmVzZXJ2ZURyYXdpbmdCdWZmZXIsXHJcbiAgICAgICAgICAgICAgICBwb3dlclByZWZlcmVuY2U6IHRoaXMub3B0aW9ucy5wb3dlclByZWZlcmVuY2UsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnJlbmRlcmluZ1RvU2NyZWVuID0gdHJ1ZTtcclxuICAgICAgICAvLyAgICAgc2F5SGVsbG8odGhpcy5jb250ZXh0LndlYkdMVmVyc2lvbiA9PT0gMiA/ICdXZWJHTCAyJyA6ICdXZWJHTCAxJyk7XHJcbiAgICAgICAgdGhpcy5yZXNpemUodGhpcy5vcHRpb25zLndpZHRoLCB0aGlzLm9wdGlvbnMuaGVpZ2h0KTtcclxuICAgIH1cclxuICAgIHN0YXRpYyByZWdpc3RlclBsdWdpbihwbHVnaW5OYW1lLCBjdG9yKSB7XHJcbiAgICAgICAgUmVuZGVyZXIuX19wbHVnaW5zID0gUmVuZGVyZXIuX19wbHVnaW5zIHx8IHt9O1xyXG4gICAgICAgIFJlbmRlcmVyLl9fcGx1Z2luc1twbHVnaW5OYW1lXSA9IGN0b3I7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICBpbml0UGx1Z2lucyhzdGF0aWNNYXApIHtcclxuICAgICAgICBmb3IgKHZhciBvIGluIHN0YXRpY01hcCkge1xyXG4gICAgICAgICAgICB0aGlzLnBsdWdpbnNbb10gPSBuZXcgKHN0YXRpY01hcFtvXSkodGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgYWRkU3lzdGVtKENsYXNzUmVmLCBuYW1lKSB7XHJcbiAgICAgICAgaWYgKCFuYW1lKSB7XHJcbiAgICAgICAgICAgIG5hbWUgPSBDbGFzc1JlZi5uYW1lO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgc3lzdGVtID0gbmV3IENsYXNzUmVmKHRoaXMpO1xyXG4gICAgICAgIGlmICh0aGlzW25hbWVdKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigoXCJXaG9vcHMhIFRoZSBuYW1lIFxcXCJcIiArIG5hbWUgKyBcIlxcXCIgaXMgYWxyZWFkeSBpbiB1c2VcIikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzW25hbWVdID0gc3lzdGVtO1xyXG4gICAgICAgIGZvciAodmFyIGkgaW4gdGhpcy5ydW5uZXJzKSB7XHJcbiAgICAgICAgICAgIHRoaXMucnVubmVyc1tpXS5hZGQoc3lzdGVtKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRmlyZWQgYWZ0ZXIgcmVuZGVyaW5nIGZpbmlzaGVzLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGV2ZW50IFBJWEkuUmVuZGVyZXIjcG9zdHJlbmRlclxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEZpcmVkIGJlZm9yZSByZW5kZXJpbmcgc3RhcnRzLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQGV2ZW50IFBJWEkuUmVuZGVyZXIjcHJlcmVuZGVyXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRmlyZWQgd2hlbiB0aGUgV2ViR0wgY29udGV4dCBpcyBzZXQuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAZXZlbnQgUElYSS5SZW5kZXJlciNjb250ZXh0XHJcbiAgICAgICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIC0gV2ViR0wgY29udGV4dC5cclxuICAgICAgICAgKi9cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8vIHByb3RlY3RlZCBoYW5kbGVDb250ZXh0Q2hhbmdlID0gKGV2ZW50OkV2ZW50KT0+XHJcbiAgICAvLyB7XHJcbiAgICAvLyBcdHRoaXMucGx1Z2lucy5wYXJ0aWNsZS5jb250ZXh0Q2hhbmdlKHRoaXMuY29udGV4dC5nbClcclxuICAgIC8vIFx0dGhpcy5mcmFtZWJ1ZmZlci5jb250ZXh0Q2hhbmdlKHRoaXMuY29udGV4dC5nbClcdFx0XHJcbiAgICAvLyBcdHRoaXMuc2hhZGVyLmNvbnRleHRDaGFuZ2UodGhpcy5jb250ZXh0LmdsKVxyXG4gICAgLy8gXHR0aGlzLmdlb21ldHJ5LmNvbnRleHRDaGFuZ2UoKTtcclxuICAgIC8vIFx0dGhpcy5zdGF0ZS5jb250ZXh0Q2hhbmdlKHRoaXMuY29udGV4dC5nbClcclxuICAgIC8vIFx0dGhpcy50ZXh0dXJlLmNvbnRleHRDaGFuZ2UoKTtcclxuICAgIC8vIFx0dGhpcy5mcmFtZWJ1ZmZlci5jb250ZXh0Q2hhbmdlKHRoaXMuY29udGV4dC5nbClcclxuICAgIC8vIFx0dGhpcy5zdGVuY2lsLmNvbnRleHRDaGFuZ2UodGhpcy5jb250ZXh0LmdsKVxyXG4gICAgLy8gXHR0aGlzLnByb2plY3Rpb24uY29udGV4dENoYW5nZSh0aGlzLmNvbnRleHQuZ2wpXHJcbiAgICAvLyBcdHRoaXMudGV4dHVyZUdDLmNvbnRleHRDaGFuZ2UodGhpcy5jb250ZXh0LmdsKVxyXG4gICAgLy8gXHR0aGlzLmZpbHRlci5jb250ZXh0Q2hhbmdlKHRoaXMuY29udGV4dC5nbClcclxuICAgIC8vIFx0dGhpcy5yZW5kZXJUZXh0dXJlLmNvbnRleHRDaGFuZ2UodGhpcy5jb250ZXh0LmdsKVxyXG4gICAgLy8gXHR0aGlzLmJhdGNoLmNvbnRleHRDaGFuZ2UodGhpcy5jb250ZXh0LmdsKVxyXG4gICAgLy8gXHR0aGlzLm1hc2suY29udGV4dENoYW5nZSh0aGlzLmNvbnRleHQuZ2wpO1xyXG4gICAgLy8gXHR0aGlzLnBsdWdpbnMuYmF0Y2guY29udGV4dENoYW5nZSgpO1x0XHRcclxuICAgIC8vIFx0dGhpcy5wbHVnaW5zLnRpbGluZ1Nwcml0ZS5jb250ZXh0Q2hhbmdlKHRoaXMuY29udGV4dC5nbClcdFx0XHJcbiAgICAvLyB9XHJcbiAgICByZW5kZXIoZGlzcGxheU9iamVjdCwgcmVuZGVyVGV4dHVyZSA9IG51bGwsIGNsZWFyID0gdHJ1ZSwgdHJhbnNmb3JtID0gbnVsbCwgc2tpcFVwZGF0ZVRyYW5zZm9ybSA9IGZhbHNlKSB7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJpbmdUb1NjcmVlbiA9ICFyZW5kZXJUZXh0dXJlO1xyXG4gICAgICAgIHRoaXMucnVubmVycy5wcmVyZW5kZXIucnVuKCk7XHJcbiAgICAgICAgLy8gdGhpcy5lbWl0KCdwcmVyZW5kZXInKTtcclxuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoRXZlbnRfMS5FdmVudC5nZXRFdmVudChcInByZXJlbmRlclwiKSk7XHJcbiAgICAgICAgaWYgKHRoaXMuY29udGV4dC5pc0xvc3QpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXJlbmRlclRleHR1cmUpIHtcclxuICAgICAgICAgICAgdGhpcy5fbGFzdE9iamVjdFJlbmRlcmVkID0gZGlzcGxheU9iamVjdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFza2lwVXBkYXRlVHJhbnNmb3JtKSB7XHJcbiAgICAgICAgICAgIGxldCBjYWNoZVBhcmVudCA9IGRpc3BsYXlPYmplY3QucGFyZW50O1xyXG4gICAgICAgICAgICBkaXNwbGF5T2JqZWN0LnBhcmVudCA9IHRoaXMuX3RlbXBEaXNwbGF5T2JqZWN0UGFyZW50O1xyXG4gICAgICAgICAgICBkaXNwbGF5T2JqZWN0LnVwZGF0ZVRyYW5zZm9ybSgpO1xyXG4gICAgICAgICAgICBkaXNwbGF5T2JqZWN0LnBhcmVudCA9IGNhY2hlUGFyZW50O1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnJlbmRlclRleHR1cmUuYmluZChyZW5kZXJUZXh0dXJlKTtcclxuICAgICAgICB0aGlzLmJhdGNoLmN1cnJlbnRSZW5kZXJlci5zdGFydCgpO1xyXG4gICAgICAgIGlmIChjbGVhciAhPT0gdW5kZWZpbmVkID8gY2xlYXIgOiB0aGlzLmNsZWFyQmVmb3JlUmVuZGVyKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVyVGV4dHVyZS5jbGVhcigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkaXNwbGF5T2JqZWN0LnJlbmRlcih0aGlzKTtcclxuICAgICAgICB0aGlzLmJhdGNoLmN1cnJlbnRSZW5kZXJlci5mbHVzaCgpO1xyXG4gICAgICAgIGlmIChyZW5kZXJUZXh0dXJlKSB7XHJcbiAgICAgICAgICAgIHJlbmRlclRleHR1cmUuYmFzZVRleHR1cmUudXBkYXRlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMucnVubmVycy5wb3N0cmVuZGVyLnJ1bigpO1xyXG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChFdmVudF8xLkV2ZW50LmdldEV2ZW50KFwicG9zdHJlbmRlclwiKSk7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICByZXNpemUoc2NyZWVuV2lkdGgsIHNjcmVlbkhlaWdodCkge1xyXG4gICAgICAgIHN1cGVyLnJlc2l6ZShzY3JlZW5XaWR0aCwgc2NyZWVuSGVpZ2h0KTtcclxuICAgICAgICB0aGlzLnJ1bm5lcnMucmVzaXplLnJ1bihzY3JlZW5XaWR0aCwgc2NyZWVuSGVpZ2h0KTtcclxuICAgICAgICAvLyB0aGlzLmRpc3BhdGNoRXZlbnQoRXZlbnQuZ2V0RXZlbnQoXCJyZXNpemVcIikpO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgcmVzZXQoKSB7XHJcbiAgICAgICAgdGhpcy5ydW5uZXJzLnJlc2V0LnJ1bigpO1xyXG4gICAgICAgIC8vIHRoaXMuZGlzcGF0Y2hFdmVudChFdmVudC5nZXRFdmVudChcInJlc2V0XCIpKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIDtcclxuICAgIGNsZWFyKCkge1xyXG4gICAgICAgIHRoaXMuZnJhbWVidWZmZXIuYmluZCgpO1xyXG4gICAgICAgIHRoaXMuZnJhbWVidWZmZXIuY2xlYXIoKTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIGRlc3Ryb3kob3B0aW9ucyA9IG51bGwpIHtcclxuICAgICAgICB0aGlzLnJ1bm5lcnMuZGVzdHJveS5ydW4oKTtcclxuICAgICAgICAvLyB0aGlzLmRpc3BhdGNoRXZlbnQoRXZlbnQuZ2V0RXZlbnQoXCJkZXN0cm95XCIpKTtcclxuICAgICAgICBzdXBlci5kZXN0cm95KG9wdGlvbnMpO1xyXG4gICAgICAgIHRoaXMuZ2wgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgO1xyXG59XHJcblJlbmRlcmVyLl9fcGx1Z2lucyA9IHt9O1xyXG5leHBvcnRzLlJlbmRlcmVyID0gUmVuZGVyZXI7XHJcbmNsYXNzIFJlbmRlcmVyUGx1Z2lucyB7XHJcbiAgICBjb25zdHJ1Y3RvcihyZW5kZXJlcikge1xyXG4gICAgICAgIHRoaXMucGFydGljbGUgPSBuZXcgUGFydGljbGVSZW5kZXJlcl8xLlBhcnRpY2xlUmVuZGVyZXIocmVuZGVyZXIpO1xyXG4gICAgICAgIHRoaXMudGlsaW5nU3ByaXRlID0gbmV3IFRpbGluZ1Nwcml0ZVJlbmRlcmVyXzEuVGlsaW5nU3ByaXRlUmVuZGVyZXIocmVuZGVyZXIpO1xyXG4gICAgICAgIHRoaXMuYWNjZXNzaWJpbGl0eSA9IG5ldyBBY2Nlc3NpYmlsaXR5TWFuYWdlcl8xLkFjY2Vzc2liaWxpdHlNYW5hZ2VyKHJlbmRlcmVyKTtcclxuICAgICAgICB0aGlzLmV4dHJhY3QgPSBuZXcgRXh0cmFjdF8xLkV4dHJhY3QocmVuZGVyZXIpO1xyXG4gICAgICAgIHRoaXMuaW50ZXJhY3Rpb24gPSBuZXcgSW50ZXJhY3Rpb25NYW5hZ2VyXzEuSW50ZXJhY3Rpb25NYW5hZ2VyKHJlbmRlcmVyKTtcclxuICAgICAgICB0aGlzLnByZXBhcmUgPSBuZXcgUHJlcGFyZV8xLlByZXBhcmUocmVuZGVyZXIpO1xyXG4gICAgICAgIHRoaXMuYmF0Y2ggPSBuZXcgQmF0Y2hSZW5kZXJlcl8xLkJhdGNoUmVuZGVyZXIocmVuZGVyZXIpO1xyXG4gICAgICAgIC8vIExvYWRlciQyLnJlZ2lzdGVyUGx1Z2luKEJpdG1hcEZvbnRMb2FkZXIpO1xyXG4gICAgICAgIC8vIExvYWRlciQyLnJlZ2lzdGVyUGx1Z2luKFNwcml0ZXNoZWV0TG9hZGVyKTtcdFxyXG4gICAgfVxyXG59XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IEV2ZW50XzEgPSByZXF1aXJlKFwiLi9FdmVudFwiKTtcclxuY29uc3QgRXZlbnREaXNwYXRjaGVyXzEgPSByZXF1aXJlKFwiLi9FdmVudERpc3BhdGNoZXJcIik7XHJcbmNvbnN0IFJ1bm5lcl8xID0gcmVxdWlyZShcIi4vUnVubmVyXCIpO1xyXG5jbGFzcyBSZXNvdXJjZSBleHRlbmRzIEV2ZW50RGlzcGF0Y2hlcl8xLkV2ZW50RGlzcGF0Y2hlciB7XHJcbiAgICBjb25zdHJ1Y3Rvcih3aWR0aCA9IDAsIGhlaWdodCA9IDApIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEludGVybmFsIHdpZHRoIG9mIHRoZSByZXNvdXJjZVxyXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5fd2lkdGggPSB3aWR0aDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJbnRlcm5hbCBoZWlnaHQgb2YgdGhlIHJlc291cmNlXHJcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLl9oZWlnaHQgPSBoZWlnaHQ7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSWYgcmVzb3VyY2UgaGFzIGJlZW4gZGVzdHJveWVkXHJcbiAgICAgICAgICogQG1lbWJlciB7Ym9vbGVhbn1cclxuICAgICAgICAgKiBAcmVhZG9ubHlcclxuICAgICAgICAgKiBAZGVmYXVsdCBmYWxzZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogYHRydWVgIGlmIHJlc291cmNlIGlzIGNyZWF0ZWQgYnkgQmFzZVRleHR1cmVcclxuICAgICAgICAgKiB1c2VmdWwgZm9yIGRvaW5nIGNsZWFudXAgd2l0aCBCYXNlVGV4dHVyZSBkZXN0cm95XHJcbiAgICAgICAgICogYW5kIG5vdCBjbGVhbmluZyB1cCByZXNvdXJjZXMgdGhhdCB3ZXJlIGNyZWF0ZWRcclxuICAgICAgICAgKiBleHRlcm5hbGx5LlxyXG4gICAgICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XHJcbiAgICAgICAgICogQHByb3RlY3RlZFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuaW50ZXJuYWwgPSBmYWxzZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBNaW5pLXJ1bm5lciBmb3IgaGFuZGxpbmcgcmVzaXplIGV2ZW50c1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQG1lbWJlciB7UnVubmVyfVxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgLy8gdGhpcy5vblJlc2l6ZSA9IEV2ZW50LmdldEV2ZW50KFwic2V0UmVhbFNpemVcIilcclxuICAgICAgICAvLyBSdW5uZXIoJ3NldFJlYWxTaXplJywgMik7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogTWluaS1ydW5uZXIgZm9yIGhhbmRsaW5nIHVwZGF0ZSBldmVudHNcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBtZW1iZXIge1J1bm5lcn1cclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIC8vIHRoaXMub25VcGRhdGUgPSBFdmVudC5nZXRFdmVudChcInVwZGF0ZVwiKVxyXG4gICAgICAgIC8vIG5ldyBSdW5uZXIoJ3VwZGF0ZScpO1xyXG4gICAgICAgIHRoaXMub25SZXNpemUgPSBuZXcgUnVubmVyXzEuUnVubmVyKCdzZXRSZWFsU2l6ZScsIDIpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIE1pbmktcnVubmVyIGZvciBoYW5kbGluZyB1cGRhdGUgZXZlbnRzXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAbWVtYmVyIHtSdW5uZXJ9XHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLm9uVXBkYXRlID0gbmV3IFJ1bm5lcl8xLlJ1bm5lcigndXBkYXRlJyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEJpbmQgdG8gYSBwYXJlbnQgQmFzZVRleHR1cmVcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1BJWEkuQmFzZVRleHR1cmV9IGJhc2VUZXh0dXJlIC0gUGFyZW50IHRleHR1cmVcclxuICAgICAqL1xyXG4gICAgYmluZChiYXNlVGV4dHVyZSkge1xyXG4gICAgICAgIHRoaXMub25SZXNpemUuYWRkKGJhc2VUZXh0dXJlKTtcclxuICAgICAgICB0aGlzLm9uVXBkYXRlLmFkZChiYXNlVGV4dHVyZSk7XHJcbiAgICAgICAgLy8gQ2FsbCBhIHJlc2l6ZSBpbW1lZGlhdGUgaWYgd2UgYWxyZWFkeVxyXG4gICAgICAgIC8vIGhhdmUgdGhlIHdpZHRoIGFuZCBoZWlnaHQgb2YgdGhlIHJlc291cmNlXHJcbiAgICAgICAgaWYgKHRoaXMuX3dpZHRoIHx8IHRoaXMuX2hlaWdodCkge1xyXG4gICAgICAgICAgICB0aGlzLm9uUmVzaXplLnJ1bih0aGlzLl93aWR0aCwgdGhpcy5faGVpZ2h0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gdGhpcy5vblJlc2l6ZS5hZGQoYmFzZVRleHR1cmUpO1xyXG4gICAgICAgIC8vIHRoaXMub25VcGRhdGUuYWRkKGJhc2VUZXh0dXJlKTtcclxuICAgICAgICAvLyBDYWxsIGEgcmVzaXplIGltbWVkaWF0ZSBpZiB3ZSBhbHJlYWR5XHJcbiAgICAgICAgLy8gaGF2ZSB0aGUgd2lkdGggYW5kIGhlaWdodCBvZiB0aGUgcmVzb3VyY2VcclxuICAgICAgICAvLyBpZiAodGhpcy5fd2lkdGggfHwgdGhpcy5faGVpZ2h0KVxyXG4gICAgICAgIC8vIHtcclxuICAgICAgICAvLyBcdHRoaXMuZGlzcGF0Y2hFdmVudChFdmVudC5nZXRFdmVudChcInNldFJlYWxTaXplXCIpKVxyXG4gICAgICAgIC8vICAgICAvLyB0aGlzLm9uUmVzaXplLnJ1bih0aGlzLl93aWR0aCwgdGhpcy5faGVpZ2h0KTtcclxuICAgICAgICAvLyB9XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFVuYmluZCB0byBhIHBhcmVudCBCYXNlVGV4dHVyZVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7UElYSS5CYXNlVGV4dHVyZX0gYmFzZVRleHR1cmUgLSBQYXJlbnQgdGV4dHVyZVxyXG4gICAgICovXHJcbiAgICB1bmJpbmQoYmFzZVRleHR1cmUpIHtcclxuICAgICAgICB0aGlzLm9uUmVzaXplLnJlbW92ZShiYXNlVGV4dHVyZSk7XHJcbiAgICAgICAgdGhpcy5vblVwZGF0ZS5yZW1vdmUoYmFzZVRleHR1cmUpO1xyXG4gICAgICAgIC8vIHRoaXMub25SZXNpemUucmVtb3ZlKGJhc2VUZXh0dXJlKTtcclxuICAgICAgICAvLyB0aGlzLm9uVXBkYXRlLnJlbW92ZShiYXNlVGV4dHVyZSk7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFRyaWdnZXIgYSByZXNpemUgZXZlbnRcclxuICAgICAqL1xyXG4gICAgcmVzaXplKHdpZHRoLCBoZWlnaHQpIHtcclxuICAgICAgICBpZiAod2lkdGggIT09IHRoaXMuX3dpZHRoIHx8IGhlaWdodCAhPT0gdGhpcy5faGVpZ2h0KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3dpZHRoID0gd2lkdGg7XHJcbiAgICAgICAgICAgIHRoaXMuX2hlaWdodCA9IGhlaWdodDtcclxuICAgICAgICAgICAgdGhpcy5vblJlc2l6ZS5ydW4od2lkdGgsIGhlaWdodCk7XHJcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChFdmVudF8xLkV2ZW50LmdldEV2ZW50KFwic2V0UmVhbFNpemVcIikpO1xyXG4gICAgICAgICAgICAvLyBFdmVudC5nZXRFdmVudChcInNldFJlYWxTaXplXCIpXHJcbiAgICAgICAgICAgIC8vIHRoaXMub25SZXNpemUucnVuKHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogSGFzIGJlZW4gdmFsaWRhdGVkXHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIGdldCB2YWxpZCgpIHtcclxuICAgICAgICByZXR1cm4gISF0aGlzLl93aWR0aCAmJiAhIXRoaXMuX2hlaWdodDtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogSGFzIGJlZW4gdXBkYXRlZCB0cmlnZ2VyIGV2ZW50XHJcbiAgICAgKi9cclxuICAgIHVwZGF0ZShkZWx0YVRpbWUpIHtcclxuICAgICAgICBpZiAoIXRoaXMuZGVzdHJveWVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChFdmVudF8xLkV2ZW50LmdldEV2ZW50KFwidXBkYXRlXCIpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgY2FuIGJlIG92ZXJyaWRkZW4gdG8gc3RhcnQgcHJlbG9hZGluZyBhIHJlc291cmNlXHJcbiAgICAgKiBvciBkbyBhbnkgb3RoZXIgcHJlcGFyZSBzdGVwLlxyXG4gICAgICogQHByb3RlY3RlZFxyXG4gICAgICogQHJldHVybiB7UHJvbWlzZTx2b2lkPn0gSGFuZGxlIHRoZSB2YWxpZGF0ZSBldmVudFxyXG4gICAgICovXHJcbiAgICBsb2FkKCkge1xyXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIHdpZHRoIG9mIHRoZSByZXNvdXJjZS5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqL1xyXG4gICAgZ2V0IHdpZHRoKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl93aWR0aDtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGhlaWdodCBvZiB0aGUgcmVzb3VyY2UuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICogQHJlYWRvbmx5XHJcbiAgICAgKi9cclxuICAgIGdldCBoZWlnaHQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hlaWdodDtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogVXBsb2FkcyB0aGUgdGV4dHVyZSBvciByZXR1cm5zIGZhbHNlIGlmIGl0IGNhbnQgZm9yIHNvbWUgcmVhc29uLiBPdmVycmlkZSB0aGlzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7UElYSS5SZW5kZXJlcn0gcmVuZGVyZXIgLSB5ZWFoLCByZW5kZXJlciFcclxuICAgICAqIEBwYXJhbSB7UElYSS5CYXNlVGV4dHVyZX0gYmFzZVRleHR1cmUgLSB0aGUgdGV4dHVyZVxyXG4gICAgICogQHBhcmFtIHtQSVhJLkdMVGV4dHVyZX0gZ2xUZXh0dXJlIC0gdGV4dHVyZSBpbnN0YW5jZSBmb3IgdGhpcyB3ZWJnbCBjb250ZXh0XHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpcyBzdWNjZXNzXHJcbiAgICAgKi9cclxuICAgIHVwbG9hZChyZW5kZXJlciwgYmFzZVRleHR1cmUsIGdsVGV4dHVyZSwgc291cmNlKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhlIHN0eWxlLCBvcHRpb25hbCB0byBvdmVycmlkZVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7UElYSS5SZW5kZXJlcn0gcmVuZGVyZXIgLSB5ZWFoLCByZW5kZXJlciFcclxuICAgICAqIEBwYXJhbSB7UElYSS5CYXNlVGV4dHVyZX0gYmFzZVRleHR1cmUgLSB0aGUgdGV4dHVyZVxyXG4gICAgICogQHBhcmFtIHtQSVhJLkdMVGV4dHVyZX0gZ2xUZXh0dXJlIC0gdGV4dHVyZSBpbnN0YW5jZSBmb3IgdGhpcyB3ZWJnbCBjb250ZXh0XHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlzIHN1Y2Nlc3NcclxuICAgICAqL1xyXG4gICAgc3R5bGUocmVuZGVyZXIsIGJhc2VUZXh0dXJlLCBnbFRleHR1cmUpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIENsZWFuIHVwIGFueXRoaW5nLCB0aGlzIGhhcHBlbnMgd2hlbiBkZXN0cm95aW5nIGlzIHJlYWR5LlxyXG4gICAgICpcclxuICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAqL1xyXG4gICAgZGlzcG9zZSgpIHtcclxuICAgICAgICAvLyBvdmVycmlkZVxyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxsIHdoZW4gZGVzdHJveWluZyByZXNvdXJjZSwgdW5iaW5kIGFueSBCYXNlVGV4dHVyZSBvYmplY3RcclxuICAgICAqIGJlZm9yZSBjYWxsaW5nIHRoaXMgbWV0aG9kLCBhcyByZWZlcmVuY2UgY291bnRzIGFyZSBtYWludGFpbmVkXHJcbiAgICAgKiBpbnRlcm5hbGx5LlxyXG4gICAgICovXHJcbiAgICBkZXN0cm95KCkge1xyXG4gICAgICAgIGlmICghdGhpcy5kZXN0cm95ZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5vblJlc2l6ZS5yZW1vdmVBbGwoKTtcclxuICAgICAgICAgICAgdGhpcy5vblJlc2l6ZSA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMub25VcGRhdGUucmVtb3ZlQWxsKCk7XHJcbiAgICAgICAgICAgIHRoaXMub25VcGRhdGUgPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuZGlzcG9zZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIDtcclxufVxyXG5leHBvcnRzLlJlc291cmNlID0gUmVzb3VyY2U7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IEV2ZW50RGlzcGF0Y2hlcl8xID0gcmVxdWlyZShcIi4vRXZlbnREaXNwYXRjaGVyXCIpO1xyXG5jb25zdCBFdmVudF8xID0gcmVxdWlyZShcIi4vRXZlbnRcIik7XHJcbmNvbnN0IFByb2dyZXNzRXZlbnRfMSA9IHJlcXVpcmUoXCIuL1Byb2dyZXNzRXZlbnRcIik7XHJcbmNvbnN0IExvZ2dlcl8xID0gcmVxdWlyZShcIi4vTG9nZ2VyXCIpO1xyXG5jbGFzcyBSZXNvdXJjZUxvYWRlciBleHRlbmRzIEV2ZW50RGlzcGF0Y2hlcl8xLkV2ZW50RGlzcGF0Y2hlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihyZXF1ZXN0KSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLmNvbXBsZXRlID0gKGV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgIExvZ2dlcl8xLnRyYWNlKFwiY29tcGxldGVcIik7XHJcbiAgICAgICAgICAgIGxldCBwcm9taXNlID0gd2luZG93LmNyZWF0ZUltYWdlQml0bWFwKHRoaXMuX2ltYWdlRWxlbWVudCwgMCwgMCwgdGhpcy5faW1hZ2VFbGVtZW50LndpZHRoLCB0aGlzLl9pbWFnZUVsZW1lbnQuaGVpZ2h0KTtcclxuICAgICAgICAgICAgcHJvbWlzZS50aGVuKHRoaXMub25JbWFnZUJpdG1hcENyZWF0ZWQpLmNhdGNoKCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLm9uSW1hZ2VCaXRtYXBDcmVhdGVkID0gKGltYWdlKSA9PiB7XHJcbiAgICAgICAgICAgIExvZ2dlcl8xLnRyYWNlKFwib25JbWFnZUJpdG1hcENyZWF0ZWRcIik7XHJcbiAgICAgICAgICAgIHRoaXMuX2ltYWdlRGF0YSA9IGltYWdlO1xyXG4gICAgICAgICAgICB0aGlzLl9jbGVhckV2ZW50cygpO1xyXG4gICAgICAgICAgICB0aGlzLl9maW5pc2goKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuX29uVGltZW91dCA9ICgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5hYm9ydCgnTG9hZCB0aW1lZCBvdXQuJyk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLl9vblByb2dyZXNzID0gKGV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChldmVudCAmJiBldmVudC5sZW5ndGhDb21wdXRhYmxlKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgcGUgPSBQcm9ncmVzc0V2ZW50XzEuUHJvZ3Jlc3NFdmVudC5nZXRQcm9ncmVzc0V2ZW50KFByb2dyZXNzRXZlbnRfMS5Qcm9ncmVzc0V2ZW50LlBST0dSRVNTKTtcclxuICAgICAgICAgICAgICAgIHBlLmJ5dGVzTG9hZGVkID0gZXZlbnQubG9hZGVkO1xyXG4gICAgICAgICAgICAgICAgcGUuYnl0ZXNUb3RhbCA9IGV2ZW50LnRvdGFsO1xyXG4gICAgICAgICAgICAgICAgcGUucGVyY2VudCA9IGV2ZW50LmxvYWRlZCAvIGV2ZW50LnRvdGFsO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KHBlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5fb25FcnJvciA9IChldmVudCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLmFib3J0KCdGYWlsZWQgdG8gbG9hZCBlbGVtZW50IHVzaW5nOiAnICsgZXZlbnQudGFyZ2V0Lm5vZGVOYW1lKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuX3JlcXVlc3QgPSByZXF1ZXN0O1xyXG4gICAgICAgIHRoaXMuX2ZsYWdzID0gMDtcclxuICAgICAgICB0aGlzLl9zZXRGbGFnKFJlc291cmNlTG9hZGVyLlNUQVRVU19GTEFHUy5EQVRBX1VSTCwgdGhpcy5fcmVxdWVzdC51cmwuaW5kZXhPZignZGF0YTonKSA9PT0gMCk7XHJcbiAgICAgICAgdGhpcy5leHRlbnNpb24gPSB0aGlzLl9nZXRFeHRlbnNpb24oKTtcclxuICAgICAgICB0aGlzLmRhdGEgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuY3Jvc3NPcmlnaW4gPSByZXF1ZXN0LmNyb3NzT3JpZ2luID09PSB0cnVlID8gJ2Fub255bW91cycgOiBcIlwiO1xyXG4gICAgICAgIHRoaXMudGltZW91dCA9IHJlcXVlc3QudGltZW91dCB8fCAwO1xyXG4gICAgICAgIHRoaXMubG9hZFR5cGUgPSB0aGlzLl9kZXRlcm1pbmVMb2FkVHlwZSgpO1xyXG4gICAgICAgIHRoaXMuZXJyb3IgPSBudWxsO1xyXG4gICAgICAgIHRoaXMueGhyID0gbnVsbDtcclxuICAgICAgICB0aGlzLnR5cGUgPSBSZXNvdXJjZUxvYWRlci5UWVBFLlVOS05PV047XHJcbiAgICAgICAgdGhpcy5wcm9ncmVzc0NodW5rID0gMDtcclxuICAgICAgICB0aGlzLl9lbGVtZW50VGltZXIgPSAwO1xyXG4gICAgICAgIHRoaXMubWV0YWRhdGEgPSByZXF1ZXN0LnJlcXVlc3RNZXRhRGF0YTtcclxuICAgICAgICB0aGlzLnhoclR5cGUgPSBudWxsO1xyXG4gICAgICAgIC8vIHRoaXMuY2hpbGRyZW4gPSBbXTtcclxuICAgICAgICAvLyB0aGlzLl9kZXF1ZXVlID0gUmVzb3VyY2VMb2FkZXIuX25vb3A7XHJcbiAgICAgICAgLy8gdGhpcy5fb25Mb2FkQmluZGluZyA9IG51bGw7XHJcbiAgICB9XHJcbiAgICBsb2FkKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmlzTG9hZGluZykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmlzQ29tcGxldGUpIHtcclxuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KEV2ZW50XzEuRXZlbnQuZ2V0RXZlbnQoRXZlbnRfMS5FdmVudC5DT01QTEVURSkpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3NldEZsYWcoUmVzb3VyY2VMb2FkZXIuU1RBVFVTX0ZMQUdTLkxPQURJTkcsIHRydWUpO1xyXG4gICAgICAgIGlmICghdGhpcy5jcm9zc09yaWdpbikge1xyXG4gICAgICAgICAgICB0aGlzLmNyb3NzT3JpZ2luID0gdGhpcy5fZGV0ZXJtaW5lQ3Jvc3NPcmlnaW4odGhpcy5fcmVxdWVzdC51cmwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzd2l0Y2ggKHRoaXMubG9hZFR5cGUpIHtcclxuICAgICAgICAgICAgY2FzZSBSZXNvdXJjZUxvYWRlci5MT0FEX1RZUEUuSU1BR0U6XHJcbiAgICAgICAgICAgICAgICB0aGlzLnR5cGUgPSBSZXNvdXJjZUxvYWRlci5UWVBFLklNQUdFO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbG9hZEVsZW1lbnQoJ2ltYWdlJyk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBSZXNvdXJjZUxvYWRlci5MT0FEX1RZUEUuQVVESU86XHJcbiAgICAgICAgICAgICAgICB0aGlzLnR5cGUgPSBSZXNvdXJjZUxvYWRlci5UWVBFLkFVRElPO1xyXG4gICAgICAgICAgICAgICAgLy8gdGhpcy5fbG9hZFNvdXJjZUVsZW1lbnQoJ2F1ZGlvJyk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBSZXNvdXJjZUxvYWRlci5MT0FEX1RZUEUuVklERU86XHJcbiAgICAgICAgICAgICAgICB0aGlzLnR5cGUgPSBSZXNvdXJjZUxvYWRlci5UWVBFLlZJREVPO1xyXG4gICAgICAgICAgICAgICAgLy8gdGhpcy5fbG9hZFNvdXJjZUVsZW1lbnQoJ3ZpZGVvJyk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBSZXNvdXJjZUxvYWRlci5MT0FEX1RZUEUuWEhSOlxyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgaWYgKFJlc291cmNlTG9hZGVyLnVzZVhkciAmJiB0aGlzLmNyb3NzT3JpZ2luKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbG9hZFhkcigpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbG9hZFhocigpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIF9sb2FkU291cmNlRWxlbWVudFxyXG4gICAgICAgIC8vIF9sb2FkWGRyXHJcbiAgICAgICAgLy8gX2xvYWRYaHJcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogTG9hZHMgdGhpcyByZXNvdXJjZXMgdXNpbmcgYW4gZWxlbWVudCB0aGF0IGhhcyBtdWx0aXBsZSBzb3VyY2VzLFxyXG4gICAgICogbGlrZSBhbiBIVE1MQXVkaW9FbGVtZW50IG9yIEhUTUxWaWRlb0VsZW1lbnQuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIC0gVGhlIHR5cGUgb2YgZWxlbWVudCB0byB1c2UuXHJcbiAgICAgKi9cclxuICAgIC8vIHByb3RlY3RlZCBfbG9hZFNvdXJjZUVsZW1lbnQodHlwZSk6dm9pZFxyXG4gICAgLy8ge1xyXG4gICAgLy8gICAgIGlmICh0aGlzLm1ldGFkYXRhLmxvYWRFbGVtZW50KSBcclxuICAgIC8vICAgICB7XHJcbiAgICAvLyAgICAgICAgIHRoaXMuZGF0YSA9IHRoaXMubWV0YWRhdGEubG9hZEVsZW1lbnQ7XHJcbiAgICAvLyAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnYXVkaW8nICYmIHR5cGVvZiB3aW5kb3dbJ0F1ZGlvJ10gIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAvLyAgICAgICAgIHRoaXMuZGF0YSA9IG5ldyBBdWRpbygpO1xyXG4gICAgLy8gICAgIH0gZWxzZSB7XHJcbiAgICAvLyAgICAgICAgIHRoaXMuZGF0YSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodHlwZSk7XHJcbiAgICAvLyAgICAgfVxyXG4gICAgLy8gICAgIGlmICh0aGlzLmRhdGEgPT09IG51bGwpIHtcclxuICAgIC8vICAgICAgICAgdGhpcy5hYm9ydCgnVW5zdXBwb3J0ZWQgZWxlbWVudDogJyArIHR5cGUpO1xyXG4gICAgLy8gICAgICAgICByZXR1cm47XHJcbiAgICAvLyAgICAgfVxyXG4gICAgLy8gICAgIGlmICh0aGlzLmNyb3NzT3JpZ2luKSB7XHJcbiAgICAvLyAgICAgICAgIHRoaXMuZGF0YS5jcm9zc09yaWdpbiA9IHRoaXMuY3Jvc3NPcmlnaW47XHJcbiAgICAvLyAgICAgfVxyXG4gICAgLy8gICAgIGlmICghdGhpcy5tZXRhZGF0YS5za2lwU291cmNlKSB7XHJcbiAgICAvLyAgICAgICAgIC8vIHN1cHBvcnQgZm9yIENvY29vbkpTIENhbnZhcysgcnVudGltZSwgbGFja3MgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc291cmNlJylcclxuICAgIC8vICAgICAgICAgaWYgKG5hdmlnYXRvclsnaXNDb2Nvb25KUyddKSB7XHJcbiAgICAvLyAgICAgICAgICAgICB0aGlzLmRhdGEuc3JjID0gQXJyYXkuaXNBcnJheSh0aGlzLl9yZXF1ZXN0LnVybCkgPyB0aGlzLl9yZXF1ZXN0LnVybFswXSA6IHRoaXMuX3JlcXVlc3QudXJsO1xyXG4gICAgLy8gICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodGhpcy5fcmVxdWVzdC51cmwpKSB7XHJcbiAgICAvLyAgICAgICAgICAgICB2YXIgbWltZVR5cGVzID0gdGhpcy5tZXRhZGF0YS5taW1lVHlwZTtcclxuICAgIC8vICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fcmVxdWVzdC51cmwubGVuZ3RoOyArK2kpIHtcclxuICAgIC8vICAgICAgICAgICAgICAgICB0aGlzLmRhdGEuYXBwZW5kQ2hpbGQodGhpcy5fY3JlYXRlU291cmNlKHR5cGUsIHRoaXMuX3JlcXVlc3QudXJsW2ldLCBBcnJheS5pc0FycmF5KG1pbWVUeXBlcykgPyBtaW1lVHlwZXNbaV0gOiBtaW1lVHlwZXMpKTtcclxuICAgIC8vICAgICAgICAgICAgIH1cclxuICAgIC8vICAgICAgICAgfSBlbHNlIHtcclxuICAgIC8vICAgICAgICAgICAgIHZhciBfbWltZVR5cGVzID0gdGhpcy5tZXRhZGF0YS5taW1lVHlwZTtcclxuICAgIC8vICAgICAgICAgICAgIHRoaXMuZGF0YS5hcHBlbmRDaGlsZCh0aGlzLl9jcmVhdGVTb3VyY2UodHlwZSwgdGhpcy5fcmVxdWVzdC51cmwsIEFycmF5LmlzQXJyYXkoX21pbWVUeXBlcykgPyBfbWltZVR5cGVzWzBdIDogX21pbWVUeXBlcykpO1xyXG4gICAgLy8gICAgICAgICB9XHJcbiAgICAvLyAgICAgfVxyXG4gICAgLy8gICAgIHRoaXMuZGF0YS5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIHRoaXMuX2JvdW5kT25FcnJvciwgZmFsc2UpO1xyXG4gICAgLy8gICAgIHRoaXMuZGF0YS5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgdGhpcy5fYm91bmRDb21wbGV0ZSwgZmFsc2UpO1xyXG4gICAgLy8gICAgIHRoaXMuZGF0YS5hZGRFdmVudExpc3RlbmVyKCdwcm9ncmVzcycsIHRoaXMuX2JvdW5kT25Qcm9ncmVzcywgZmFsc2UpO1xyXG4gICAgLy8gICAgIHRoaXMuZGF0YS5hZGRFdmVudExpc3RlbmVyKCdjYW5wbGF5dGhyb3VnaCcsIHRoaXMuX2JvdW5kQ29tcGxldGUsIGZhbHNlKTtcclxuICAgIC8vICAgICB0aGlzLmRhdGEubG9hZCgpO1xyXG4gICAgLy8gICAgIGlmICh0aGlzLnRpbWVvdXQpIHtcclxuICAgIC8vICAgICAgICAgdGhpcy5fZWxlbWVudFRpbWVyID0gc2V0VGltZW91dCh0aGlzLl9ib3VuZE9uVGltZW91dCwgdGhpcy50aW1lb3V0KTtcclxuICAgIC8vICAgICB9XHJcbiAgICAvLyB9O1xyXG4gICAgX2NsZWFyRXZlbnRzKCkge1xyXG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9lbGVtZW50VGltZXIpO1xyXG4gICAgICAgIGlmICh0aGlzLl9pbWFnZUVsZW1lbnQgJiYgdGhpcy5faW1hZ2VFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5faW1hZ2VFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgdGhpcy5fb25FcnJvcik7XHJcbiAgICAgICAgICAgIHRoaXMuX2ltYWdlRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdsb2FkJywgdGhpcy5jb21wbGV0ZSk7XHJcbiAgICAgICAgICAgIHRoaXMuX2ltYWdlRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdwcm9ncmVzcycsIHRoaXMuX29uUHJvZ3Jlc3MpO1xyXG4gICAgICAgICAgICB0aGlzLl9pbWFnZUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2FucGxheXRocm91Z2gnLCB0aGlzLmNvbXBsZXRlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMueGhyKSB7XHJcbiAgICAgICAgICAgIC8vIGlmICh0aGlzLnhoci5yZW1vdmVFdmVudExpc3RlbmVyKSB7XHJcbiAgICAgICAgICAgIC8vICAgICB0aGlzLnhoci5yZW1vdmVFdmVudExpc3RlbmVyKCdlcnJvcicsIHRoaXMuX2JvdW5kWGhyT25FcnJvciwgZmFsc2UpO1xyXG4gICAgICAgICAgICAvLyAgICAgdGhpcy54aHIucmVtb3ZlRXZlbnRMaXN0ZW5lcigndGltZW91dCcsIHRoaXMuX2JvdW5kWGhyT25UaW1lb3V0LCBmYWxzZSk7XHJcbiAgICAgICAgICAgIC8vICAgICB0aGlzLnhoci5yZW1vdmVFdmVudExpc3RlbmVyKCdhYm9ydCcsIHRoaXMuX2JvdW5kWGhyT25BYm9ydCwgZmFsc2UpO1xyXG4gICAgICAgICAgICAvLyAgICAgdGhpcy54aHIucmVtb3ZlRXZlbnRMaXN0ZW5lcigncHJvZ3Jlc3MnLCB0aGlzLl9ib3VuZE9uUHJvZ3Jlc3MsIGZhbHNlKTtcclxuICAgICAgICAgICAgLy8gICAgIHRoaXMueGhyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2xvYWQnLCB0aGlzLl9ib3VuZFhock9uTG9hZCwgZmFsc2UpO1xyXG4gICAgICAgICAgICAvLyB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyAgICAgdGhpcy54aHIub25lcnJvciA9IG51bGw7XHJcbiAgICAgICAgICAgIC8vICAgICB0aGlzLnhoci5vbnRpbWVvdXQgPSBudWxsO1xyXG4gICAgICAgICAgICAvLyAgICAgdGhpcy54aHIub25wcm9ncmVzcyA9IG51bGw7XHJcbiAgICAgICAgICAgIC8vICAgICB0aGlzLnhoci5vbmxvYWQgPSBudWxsO1xyXG4gICAgICAgICAgICAvLyB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgX2xvYWRFbGVtZW50KHR5cGUpIHtcclxuICAgICAgICBMb2dnZXJfMS50cmFjZShcIl9sb2FkRWxlbWVudCBcIiArIHR5cGUpO1xyXG4gICAgICAgIHRoaXMuX2ltYWdlRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbWdcIik7XHJcbiAgICAgICAgaWYgKHRoaXMuY3Jvc3NPcmlnaW4pIHtcclxuICAgICAgICAgICAgdGhpcy5faW1hZ2VFbGVtZW50LmNyb3NzT3JpZ2luID0gdGhpcy5jcm9zc09yaWdpbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5faW1hZ2VFbGVtZW50LnNyYyA9IHRoaXMuX3JlcXVlc3QudXJsO1xyXG4gICAgICAgIHRoaXMuX2ltYWdlRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIHRoaXMuX29uRXJyb3IpO1xyXG4gICAgICAgIHRoaXMuX2ltYWdlRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgdGhpcy5jb21wbGV0ZSk7XHJcbiAgICAgICAgdGhpcy5faW1hZ2VFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Byb2dyZXNzJywgdGhpcy5fb25Qcm9ncmVzcyk7XHJcbiAgICAgICAgLy8gaWYgKHRoaXMudGltZW91dCA+IDApIFxyXG4gICAgICAgIC8vIHtcclxuICAgICAgICAvLyAgICAgdGhpcy5fZWxlbWVudFRpbWVyID0gc2V0VGltZW91dCh0aGlzLl9vblRpbWVvdXQsIHRoaXMudGltZW91dCk7XHJcbiAgICAgICAgLy8gfVxyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgZ2V0IGltYWdlRGF0YSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5faW1hZ2VEYXRhO1xyXG4gICAgfVxyXG4gICAgYWJvcnQobWVzc2FnZSkge1xyXG4gICAgICAgIGlmICh0aGlzLmVycm9yKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5lcnJvciA9IG5ldyBFcnJvcihtZXNzYWdlKTtcclxuICAgICAgICB0aGlzLl9jbGVhckV2ZW50cygpO1xyXG4gICAgICAgIGlmICh0aGlzLnhocikge1xyXG4gICAgICAgICAgICB0aGlzLnhoci5hYm9ydCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLnhkcikge1xyXG4gICAgICAgICAgICB0aGlzLnhkci5hYm9ydCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLmRhdGEpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuZGF0YS5zcmMpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGF0YS5zcmMgPSBSZXNvdXJjZUxvYWRlci5FTVBUWV9HSUY7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAodGhpcy5kYXRhLmZpcnN0Q2hpbGQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRhdGEucmVtb3ZlQ2hpbGQodGhpcy5kYXRhLmZpcnN0Q2hpbGQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2ZpbmlzaCgpO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgX2ZpbmlzaCgpIHtcclxuICAgICAgICBpZiAodGhpcy5pc0NvbXBsZXRlKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fc2V0RmxhZyhSZXNvdXJjZUxvYWRlci5TVEFUVVNfRkxBR1MuQ09NUExFVEUsIHRydWUpO1xyXG4gICAgICAgIHRoaXMuX3NldEZsYWcoUmVzb3VyY2VMb2FkZXIuU1RBVFVTX0ZMQUdTLkxPQURJTkcsIGZhbHNlKTtcclxuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoRXZlbnRfMS5FdmVudC5nZXRFdmVudChFdmVudF8xLkV2ZW50LkNPTVBMRVRFKSk7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICBfZGV0ZXJtaW5lQ3Jvc3NPcmlnaW4odXJsLCBsb2MgPSBudWxsKSB7XHJcbiAgICAgICAgaWYgKHVybC5pbmRleE9mKCdkYXRhOicpID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnJztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHdpbmRvd1snb3JpZ2luJ10gIT09IHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4pIHtcclxuICAgICAgICAgICAgcmV0dXJuICdhbm9ueW1vdXMnO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsb2MgPSBsb2MgfHwgd2luZG93LmxvY2F0aW9uO1xyXG4gICAgICAgIGlmICghUmVzb3VyY2VMb2FkZXIudGVtcEFuY2hvcikge1xyXG4gICAgICAgICAgICBSZXNvdXJjZUxvYWRlci50ZW1wQW5jaG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBSZXNvdXJjZUxvYWRlci50ZW1wQW5jaG9yLmhyZWYgPSB1cmw7XHJcbiAgICAgICAgbGV0IHVyaSA9IFJlc291cmNlTG9hZGVyLnBhcnNlVXJpKFJlc291cmNlTG9hZGVyLnRlbXBBbmNob3IuaHJlZiwgdHJ1ZSk7XHJcbiAgICAgICAgbGV0IHNhbWVQb3J0ID0gIXVyaS5wb3J0ICYmIGxvYy5wb3J0ID09PSAnJyB8fCB1cmkucG9ydCA9PT0gbG9jLnBvcnQ7XHJcbiAgICAgICAgbGV0IHByb3RvY29sID0gdXJpLnByb3RvY29sID8gdXJpLnByb3RvY29sICsgJzonIDogJyc7XHJcbiAgICAgICAgaWYgKHVyaS5ob3N0ICE9PSBsb2MuaG9zdG5hbWUgfHwgIXNhbWVQb3J0IHx8IHByb3RvY29sICE9PSBsb2MucHJvdG9jb2wpIHtcclxuICAgICAgICAgICAgcmV0dXJuICdhbm9ueW1vdXMnO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gJyc7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICBzdGF0aWMgcGFyc2VVcmkoc3RyLCBzdHJpY3QgPSB0cnVlKSB7XHJcbiAgICAgICAgbGV0IG8gPSB7XHJcbiAgICAgICAgICAgIGtleTogWydzb3VyY2UnLCAncHJvdG9jb2wnLCAnYXV0aG9yaXR5JywgJ3VzZXJJbmZvJywgJ3VzZXInLCAncGFzc3dvcmQnLCAnaG9zdCcsICdwb3J0JywgJ3JlbGF0aXZlJywgJ3BhdGgnLCAnZGlyZWN0b3J5JywgJ2ZpbGUnLCAncXVlcnknLCAnYW5jaG9yJ10sXHJcbiAgICAgICAgICAgIHE6IHtcclxuICAgICAgICAgICAgICAgIG5hbWU6ICdxdWVyeUtleScsXHJcbiAgICAgICAgICAgICAgICBwYXJzZXI6IC8oPzpefCYpKFteJj1dKik9PyhbXiZdKikvZ1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBwYXJzZXI6IHtcclxuICAgICAgICAgICAgICAgIHN0cmljdDogL14oPzooW146XFwvPyNdKyk6KT8oPzpcXC9cXC8oKD86KChbXjpAXSopKD86OihbXjpAXSopKT8pP0ApPyhbXjpcXC8/I10qKSg/OjooXFxkKikpPykpPygoKCg/OltePyNcXC9dKlxcLykqKShbXj8jXSopKSg/OlxcPyhbXiNdKikpPyg/OiMoLiopKT8pLyxcclxuICAgICAgICAgICAgICAgIGxvb3NlOiAvXig/Oig/IVteOkBdKzpbXjpAXFwvXSpAKShbXjpcXC8/Iy5dKyk6KT8oPzpcXC9cXC8pPygoPzooKFteOkBdKikoPzo6KFteOkBdKikpPyk/QCk/KFteOlxcLz8jXSopKD86OihcXGQqKSk/KSgoKFxcLyg/OltePyNdKD8hW14/I1xcL10qXFwuW14/I1xcLy5dKyg/Ols/I118JCkpKSpcXC8/KT8oW14/I1xcL10qKSkoPzpcXD8oW14jXSopKT8oPzojKC4qKSk/KS9cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgbGV0IG0gPSBvLnBhcnNlcltzdHJpY3QgPyAnc3RyaWN0JyA6ICdsb29zZSddLmV4ZWMoc3RyKTtcclxuICAgICAgICBsZXQgdXJpID0gbmV3IFVSSURhdGEoKTtcclxuICAgICAgICB1cmkuc291cmNlID0gbVtcInNvdXJjZVwiXSB8fCAnJztcclxuICAgICAgICB1cmkucHJvdG9jb2wgPSBtW1wicHJvdG9jb2xcIl0gfHwgJyc7XHJcbiAgICAgICAgdXJpLmF1dGhvcml0eSA9IG1bXCJhdXRob3JpdHlcIl0gfHwgJyc7XHJcbiAgICAgICAgdXJpLnVzZXJJbmZvID0gbVtcInVzZXJJbmZvXCJdIHx8ICcnO1xyXG4gICAgICAgIHVyaS51c2VyID0gbVtcInVzZXJcIl0gfHwgJyc7XHJcbiAgICAgICAgdXJpLnBhc3N3b3JkID0gbVtcInBhc3N3b3JkXCJdIHx8ICcnO1xyXG4gICAgICAgIHVyaS5ob3N0ID0gbVtcImhvc3RcIl0gfHwgJyc7XHJcbiAgICAgICAgdXJpLnBvcnQgPSBtW1wicG9ydFwiXSB8fCAnJztcclxuICAgICAgICB1cmkucmVsYXRpdmUgPSBtW1wicmVsYXRpdmVcIl0gfHwgJyc7XHJcbiAgICAgICAgdXJpLnBhdGggPSBtW1wicGF0aFwiXSB8fCAnJztcclxuICAgICAgICB1cmkuZGlyZWN0b3J5ID0gbVtcImRpcmVjdG9yeVwiXSB8fCAnJztcclxuICAgICAgICB1cmkuZmlsZSA9IG1bXCJmaWxlXCJdIHx8ICcnO1xyXG4gICAgICAgIHVyaS5xdWVyeSA9IG1bXCJxdWVyeVwiXSB8fCAnJztcclxuICAgICAgICB1cmkuYW5jaG9yID0gbVtcImFuY2hvclwiXSB8fCAnJztcclxuICAgICAgICB1cmlbby5xLm5hbWVdID0ge307XHJcbiAgICAgICAgdXJpW28ua2V5WzEyXV0ucmVwbGFjZShvLnEucGFyc2VyLCBmdW5jdGlvbiAoJDAsICQxLCAkMikge1xyXG4gICAgICAgICAgICBpZiAoJDEpIHtcclxuICAgICAgICAgICAgICAgIHVyaVtvLnEubmFtZV1bJDFdID0gJDI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gdXJpO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgX2RldGVybWluZUxvYWRUeXBlKCkge1xyXG4gICAgICAgIHJldHVybiBSZXNvdXJjZUxvYWRlci5fbG9hZFR5cGVNYXBbdGhpcy5leHRlbnNpb25dIHx8IFJlc291cmNlTG9hZGVyLkxPQURfVFlQRS5YSFI7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICBfZ2V0RXh0ZW5zaW9uKCkge1xyXG4gICAgICAgIGxldCB1cmwgPSB0aGlzLl9yZXF1ZXN0LnVybDtcclxuICAgICAgICBsZXQgZXh0ID0gJyc7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNEYXRhVXJsKSB7XHJcbiAgICAgICAgICAgIGxldCBzbGFzaEluZGV4ID0gdXJsLmluZGV4T2YoJy8nKTtcclxuICAgICAgICAgICAgZXh0ID0gdXJsLnN1YnN0cmluZyhzbGFzaEluZGV4ICsgMSwgdXJsLmluZGV4T2YoJzsnLCBzbGFzaEluZGV4KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBsZXQgcXVlcnlTdGFydCA9IHVybC5pbmRleE9mKCc/Jyk7XHJcbiAgICAgICAgICAgIGxldCBoYXNoU3RhcnQgPSB1cmwuaW5kZXhPZignIycpO1xyXG4gICAgICAgICAgICBsZXQgaW5kZXggPSBNYXRoLm1pbihxdWVyeVN0YXJ0ID4gLTEgPyBxdWVyeVN0YXJ0IDogdXJsLmxlbmd0aCwgaGFzaFN0YXJ0ID4gLTEgPyBoYXNoU3RhcnQgOiB1cmwubGVuZ3RoKTtcclxuICAgICAgICAgICAgdXJsID0gdXJsLnN1YnN0cmluZygwLCBpbmRleCk7XHJcbiAgICAgICAgICAgIGV4dCA9IHVybC5zdWJzdHJpbmcodXJsLmxhc3RJbmRleE9mKCcuJykgKyAxKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGV4dC50b0xvd2VyQ2FzZSgpO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgX2hhc0ZsYWcoZmxhZykge1xyXG4gICAgICAgIHJldHVybiAodGhpcy5fZmxhZ3MgJiBmbGFnKSAhPT0gMDtcclxuICAgIH1cclxuICAgIDtcclxuICAgIF9zZXRGbGFnKGZsYWcsIHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5fZmxhZ3MgPSB2YWx1ZSA/IHRoaXMuX2ZsYWdzIHwgZmxhZyA6IHRoaXMuX2ZsYWdzICYgfmZsYWc7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICBzdGF0aWMgc2V0RXh0TWFwKG1hcCwgZXh0bmFtZSwgdmFsKSB7XHJcbiAgICAgICAgaWYgKGV4dG5hbWUgJiYgZXh0bmFtZS5pbmRleE9mKCcuJykgPT09IDApIHtcclxuICAgICAgICAgICAgZXh0bmFtZSA9IGV4dG5hbWUuc3Vic3RyaW5nKDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWV4dG5hbWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBtYXBbZXh0bmFtZV0gPSB2YWw7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgc2V0RXh0ZW5zaW9uTG9hZFR5cGUoZXh0bmFtZSwgbG9hZFR5cGUpIHtcclxuICAgICAgICBSZXNvdXJjZUxvYWRlci5zZXRFeHRNYXAoUmVzb3VyY2VMb2FkZXIuX2xvYWRUeXBlTWFwLCBleHRuYW1lLCBsb2FkVHlwZSk7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICBzdGF0aWMgc2V0RXh0ZW5zaW9uWGhyVHlwZShleHRuYW1lLCB4aHJUeXBlKSB7XHJcbiAgICAgICAgUmVzb3VyY2VMb2FkZXIuc2V0RXh0TWFwKFJlc291cmNlTG9hZGVyLl94aHJUeXBlTWFwLCBleHRuYW1lLCB4aHJUeXBlKTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogUXVpY2sgaGVscGVyIHRvIGdldCBzdHJpbmcgeGhyIHR5cGUuXHJcbiAgICAgKlxyXG4gICAgICogQGlnbm9yZVxyXG4gICAgICogQHBhcmFtIHtYTUxIdHRwUmVxdWVzdHxYRG9tYWluUmVxdWVzdH0geGhyIC0gVGhlIHJlcXVlc3QgdG8gY2hlY2suXHJcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSB0eXBlLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgcmVxVHlwZSh4aHIpIHtcclxuICAgICAgICByZXR1cm4geGhyLnRvU3RyaW5nKCkucmVwbGFjZSgnb2JqZWN0ICcsICcnKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogTG9hZHMgdGhpcyByZXNvdXJjZXMgdXNpbmcgYW4gWE1MSHR0cFJlcXVlc3QuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgX2xvYWRYaHIoKSB7XHJcbiAgICAgICAgLy8gLy8gaWYgdW5zZXQsIGRldGVybWluZSB0aGUgdmFsdWVcclxuICAgICAgICAvLyBpZiAodHlwZW9mIHRoaXMueGhyVHlwZSAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgICAvLyAgICAgdGhpcy54aHJUeXBlID0gdGhpcy5fZGV0ZXJtaW5lWGhyVHlwZSgpO1xyXG4gICAgICAgIC8vIH1cclxuICAgICAgICAvLyB2YXIgeGhyID0gdGhpcy54aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcclxuICAgICAgICAvLyAvLyBzZXQgdGhlIHJlcXVlc3QgdHlwZSBhbmQgdXJsXHJcbiAgICAgICAgLy8geGhyLm9wZW4oJ0dFVCcsIHRoaXMuX3JlcXVlc3QudXJsLCB0cnVlKTtcclxuICAgICAgICAvLyB4aHIudGltZW91dCA9IHRoaXMudGltZW91dDtcclxuICAgICAgICAvLyAvLyBsb2FkIGpzb24gYXMgdGV4dCBhbmQgcGFyc2UgaXQgb3Vyc2VsdmVzLiBXZSBkbyB0aGlzIGJlY2F1c2Ugc29tZSBicm93c2Vyc1xyXG4gICAgICAgIC8vIC8vICpjb3VnaCogc2FmYXJpICpjb3VnaCogY2FuJ3QgZGVhbCB3aXRoIGl0LlxyXG4gICAgICAgIC8vIGlmICh0aGlzLnhoclR5cGUgPT09IFJlc291cmNlTG9hZGVyLlhIUl9SRVNQT05TRV9UWVBFLkpTT04gfHwgdGhpcy54aHJUeXBlID09PSBSZXNvdXJjZUxvYWRlci5YSFJfUkVTUE9OU0VfVFlQRS5ET0NVTUVOVCkge1xyXG4gICAgICAgIC8vICAgICB4aHIucmVzcG9uc2VUeXBlID0gPGFueT5SZXNvdXJjZUxvYWRlci5YSFJfUkVTUE9OU0VfVFlQRS5URVhUO1xyXG4gICAgICAgIC8vIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gICAgIHhoci5yZXNwb25zZVR5cGUgPSB0aGlzLnhoclR5cGU7XHJcbiAgICAgICAgLy8gfVxyXG4gICAgICAgIC8vIHhoci5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIHRoaXMuX2JvdW5kWGhyT25FcnJvciwgZmFsc2UpO1xyXG4gICAgICAgIC8vIHhoci5hZGRFdmVudExpc3RlbmVyKCd0aW1lb3V0JywgdGhpcy5fYm91bmRYaHJPblRpbWVvdXQsIGZhbHNlKTtcclxuICAgICAgICAvLyB4aHIuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCB0aGlzLl9ib3VuZFhock9uQWJvcnQsIGZhbHNlKTtcclxuICAgICAgICAvLyB4aHIuYWRkRXZlbnRMaXN0ZW5lcigncHJvZ3Jlc3MnLCB0aGlzLl9ib3VuZE9uUHJvZ3Jlc3MsIGZhbHNlKTtcclxuICAgICAgICAvLyB4aHIuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIHRoaXMuX2JvdW5kWGhyT25Mb2FkLCBmYWxzZSk7XHJcbiAgICAgICAgLy8geGhyLnNlbmQoKTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogTG9hZHMgdGhpcyByZXNvdXJjZXMgdXNpbmcgYW4gWERvbWFpblJlcXVlc3QuIFRoaXMgaXMgaGVyZSBiZWNhdXNlIHdlIG5lZWQgdG8gc3VwcG9ydCBJRTkgKGdyb3NzKS5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBfbG9hZFhkcigpIHtcclxuICAgICAgICAvLyAvLyBpZiB1bnNldCwgZGV0ZXJtaW5lIHRoZSB2YWx1ZVxyXG4gICAgICAgIC8vIGlmICh0eXBlb2YgdGhpcy54aHJUeXBlICE9PSAnc3RyaW5nJykge1xyXG4gICAgICAgIC8vICAgICB0aGlzLnhoclR5cGUgPSB0aGlzLl9kZXRlcm1pbmVYaHJUeXBlKCk7XHJcbiAgICAgICAgLy8gfVxyXG4gICAgICAgIC8vIHZhciB4ZHIgPSB0aGlzLnhociA9IG5ldyB3aW5kb3dbJ1hEb21haW5SZXF1ZXN0J10oKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxyXG4gICAgICAgIC8vIC8vIFhEb21haW5SZXF1ZXN0IGhhcyBhIGZldyBxdWlya3MuIE9jY2FzaW9uYWxseSBpdCB3aWxsIGFib3J0IHJlcXVlc3RzXHJcbiAgICAgICAgLy8gLy8gQSB3YXkgdG8gYXZvaWQgdGhpcyBpcyB0byBtYWtlIHN1cmUgQUxMIGNhbGxiYWNrcyBhcmUgc2V0IGV2ZW4gaWYgbm90IHVzZWRcclxuICAgICAgICAvLyAvLyBNb3JlIGluZm8gaGVyZTogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xNTc4Njk2Ni94ZG9tYWlucmVxdWVzdC1hYm9ydHMtcG9zdC1vbi1pZS05XHJcbiAgICAgICAgLy8geGRyLnRpbWVvdXQgPSB0aGlzLnRpbWVvdXQgfHwgNTAwMDsgLy8gWERSIG5lZWRzIGEgdGltZW91dCB2YWx1ZSBvciBpdCBicmVha3MgaW4gSUU5XHJcbiAgICAgICAgLy8geGRyLm9uZXJyb3IgPSB0aGlzLl9ib3VuZFhock9uRXJyb3I7XHJcbiAgICAgICAgLy8geGRyLm9udGltZW91dCA9IHRoaXMuX2JvdW5kWGhyT25UaW1lb3V0O1xyXG4gICAgICAgIC8vIHhkci5vbnByb2dyZXNzID0gdGhpcy5fYm91bmRPblByb2dyZXNzO1xyXG4gICAgICAgIC8vIHhkci5vbmxvYWQgPSB0aGlzLl9ib3VuZFhock9uTG9hZDtcclxuICAgICAgICAvLyB4ZHIub3BlbignR0VUJywgdGhpcy5fcmVxdWVzdC51cmwsIHRydWUpO1xyXG4gICAgICAgIC8vIC8vIE5vdGU6IFRoZSB4ZHIuc2VuZCgpIGNhbGwgaXMgd3JhcHBlZCBpbiBhIHRpbWVvdXQgdG8gcHJldmVudCBhblxyXG4gICAgICAgIC8vIC8vIGlzc3VlIHdpdGggdGhlIGludGVyZmFjZSB3aGVyZSBzb21lIHJlcXVlc3RzIGFyZSBsb3N0IGlmIG11bHRpcGxlXHJcbiAgICAgICAgLy8gLy8gWERvbWFpblJlcXVlc3RzIGFyZSBiZWluZyBzZW50IGF0IHRoZSBzYW1lIHRpbWUuXHJcbiAgICAgICAgLy8gLy8gU29tZSBpbmZvIGhlcmU6IGh0dHBzOi8vZ2l0aHViLmNvbS9waG90b25zdG9ybS9waGFzZXIvaXNzdWVzLzEyNDhcclxuICAgICAgICAvLyBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyAgICAgcmV0dXJuIHhkci5zZW5kKCk7XHJcbiAgICAgICAgLy8gfSwgMSk7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBzb3VyY2UgdXNlZCBpbiBsb2FkaW5nIHZpYSBhbiBlbGVtZW50LlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSAtIFRoZSBlbGVtZW50IHR5cGUgKHZpZGVvIG9yIGF1ZGlvKS5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgLSBUaGUgc291cmNlIFVSTCB0byBsb2FkIGZyb20uXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW21pbWVdIC0gVGhlIG1pbWUgdHlwZSBvZiB0aGUgdmlkZW9cclxuICAgICAqIEByZXR1cm4ge0hUTUxTb3VyY2VFbGVtZW50fSBUaGUgc291cmNlIGVsZW1lbnQuXHJcbiAgICAgKi9cclxuICAgIF9jcmVhdGVTb3VyY2UodHlwZSwgdXJsLCBtaW1lKSB7XHJcbiAgICAgICAgLy8gaWYgKCFtaW1lKSB7XHJcbiAgICAgICAgLy8gICAgIG1pbWUgPSB0eXBlICsgJy8nICsgdGhpcy5fZ2V0RXh0ZW5zaW9uKHVybCk7XHJcbiAgICAgICAgLy8gfVxyXG4gICAgICAgIC8vIHZhciBzb3VyY2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzb3VyY2UnKTtcclxuICAgICAgICAvLyBzb3VyY2Uuc3JjID0gdXJsO1xyXG4gICAgICAgIC8vIHNvdXJjZS50eXBlID0gbWltZTtcclxuICAgICAgICAvLyByZXR1cm4gc291cmNlO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxsZWQgaWYgYW4gZXJyb3IgZXZlbnQgZmlyZXMgZm9yIHhoci94ZHIuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgX3hock9uRXJyb3IoKSB7XHJcbiAgICAgICAgdmFyIHhociA9IHRoaXMueGhyO1xyXG4gICAgICAgIHRoaXMuYWJvcnQoUmVzb3VyY2VMb2FkZXIucmVxVHlwZSh4aHIpICsgJyBSZXF1ZXN0IGZhaWxlZC4gU3RhdHVzOiAnICsgeGhyLnN0YXR1cyArICcsIHRleHQ6IFwiJyArIHhoci5zdGF0dXNUZXh0ICsgJ1wiJyk7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIENhbGxlZCBpZiBhbiBlcnJvciBldmVudCBmaXJlcyBmb3IgeGhyL3hkci5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBfeGhyT25UaW1lb3V0KCkge1xyXG4gICAgICAgIHZhciB4aHIgPSB0aGlzLnhocjtcclxuICAgICAgICB0aGlzLmFib3J0KFJlc291cmNlTG9hZGVyLnJlcVR5cGUoeGhyKSArICcgUmVxdWVzdCB0aW1lZCBvdXQuJyk7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIENhbGxlZCBpZiBhbiBhYm9ydCBldmVudCBmaXJlcyBmb3IgeGhyL3hkci5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBfeGhyT25BYm9ydCgpIHtcclxuICAgICAgICB2YXIgeGhyID0gdGhpcy54aHI7XHJcbiAgICAgICAgdGhpcy5hYm9ydChSZXNvdXJjZUxvYWRlci5yZXFUeXBlKHhocikgKyAnIFJlcXVlc3Qgd2FzIGFib3J0ZWQgYnkgdGhlIHVzZXIuJyk7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIENhbGxlZCB3aGVuIGRhdGEgc3VjY2Vzc2Z1bGx5IGxvYWRzIGZyb20gYW4geGhyL3hkciByZXF1ZXN0LlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge1hNTEh0dHBSZXF1ZXN0TG9hZEV2ZW50fEV2ZW50fSBldmVudCAtIExvYWQgZXZlbnRcclxuICAgICAqL1xyXG4gICAgX3hock9uTG9hZCgpIHtcclxuICAgICAgICAvLyB2YXIgeGhyID0gdGhpcy54aHI7XHJcbiAgICAgICAgLy8gdmFyIHRleHQgPSAnJztcclxuICAgICAgICAvLyB2YXIgc3RhdHVzID0gdHlwZW9mIHhoci5zdGF0dXMgPT09ICd1bmRlZmluZWQnID8gUmVzb3VyY2VMb2FkZXIuU1RBVFVTX09LIDogeGhyLnN0YXR1czsgLy8gWERSIGhhcyBubyBgLnN0YXR1c2AsIGFzc3VtZSAyMDAuXHJcbiAgICAgICAgLy8gLy8gcmVzcG9uc2VUZXh0IGlzIGFjY2Vzc2libGUgb25seSBpZiByZXNwb25zZVR5cGUgaXMgJycgb3IgJ3RleHQnIGFuZCBvbiBvbGRlciBicm93c2Vyc1xyXG4gICAgICAgIC8vIGlmICh4aHIucmVzcG9uc2VUeXBlID09PSAnJyB8fCB4aHIucmVzcG9uc2VUeXBlID09PSAndGV4dCcgfHwgdHlwZW9mIHhoci5yZXNwb25zZVR5cGUgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgLy8gICAgIHRleHQgPSB4aHIucmVzcG9uc2VUZXh0O1xyXG4gICAgICAgIC8vIH1cclxuICAgICAgICAvLyAvLyBzdGF0dXMgY2FuIGJlIDAgd2hlbiB1c2luZyB0aGUgYGZpbGU6Ly9gIHByb3RvY29sIHNvIHdlIGFsc28gY2hlY2sgaWYgYSByZXNwb25zZSBpcyBzZXQuXHJcbiAgICAgICAgLy8gLy8gSWYgaXQgaGFzIGEgcmVzcG9uc2UsIHdlIGFzc3VtZSAyMDA7IG90aGVyd2lzZSBhIDAgc3RhdHVzIGNvZGUgd2l0aCBubyBjb250ZW50cyBpcyBhbiBhYm9ydGVkIHJlcXVlc3QuXHJcbiAgICAgICAgLy8gaWYgKHN0YXR1cyA9PT0gUmVzb3VyY2VMb2FkZXIuU1RBVFVTX05PTkUgJiYgKHRleHQubGVuZ3RoID4gMCB8fCB4aHIucmVzcG9uc2VUeXBlID09PSBSZXNvdXJjZUxvYWRlci5YSFJfUkVTUE9OU0VfVFlQRS5CVUZGRVIpKSB7XHJcbiAgICAgICAgLy8gICAgIHN0YXR1cyA9IFJlc291cmNlTG9hZGVyLlNUQVRVU19PSztcclxuICAgICAgICAvLyB9XHJcbiAgICAgICAgLy8gLy8gaGFuZGxlIElFOSBidWc6IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTAwNDY5NzIvbXNpZS1yZXR1cm5zLXN0YXR1cy1jb2RlLW9mLTEyMjMtZm9yLWFqYXgtcmVxdWVzdFxyXG4gICAgICAgIC8vIGVsc2UgaWYgKHN0YXR1cyA9PT0gUmVzb3VyY2VMb2FkZXIuU1RBVFVTX0lFX0JVR19FTVBUWSkge1xyXG4gICAgICAgIC8vICAgICAgICAgc3RhdHVzID0gUmVzb3VyY2VMb2FkZXIuU1RBVFVTX0VNUFRZO1xyXG4gICAgICAgIC8vICAgICB9XHJcbiAgICAgICAgLy8gdmFyIHN0YXR1c1R5cGUgPSBzdGF0dXMgLyAxMDAgfCAwO1xyXG4gICAgICAgIC8vIGlmIChzdGF0dXNUeXBlID09PSBSZXNvdXJjZUxvYWRlci5TVEFUVVNfVFlQRV9PSykge1xyXG4gICAgICAgIC8vICAgICAvLyBpZiB0ZXh0LCBqdXN0IHJldHVybiBpdFxyXG4gICAgICAgIC8vICAgICBpZiAodGhpcy54aHJUeXBlID09PSBSZXNvdXJjZUxvYWRlci5YSFJfUkVTUE9OU0VfVFlQRS5URVhUKSB7XHJcbiAgICAgICAgLy8gICAgICAgICB0aGlzLmRhdGEgPSB0ZXh0O1xyXG4gICAgICAgIC8vICAgICAgICAgdGhpcy50eXBlID0gUmVzb3VyY2VMb2FkZXIuVFlQRS5URVhUO1xyXG4gICAgICAgIC8vICAgICB9XHJcbiAgICAgICAgLy8gICAgIC8vIGlmIGpzb24sIHBhcnNlIGludG8ganNvbiBvYmplY3RcclxuICAgICAgICAvLyAgICAgZWxzZSBpZiAodGhpcy54aHJUeXBlID09PSBSZXNvdXJjZUxvYWRlci5YSFJfUkVTUE9OU0VfVFlQRS5KU09OKSB7XHJcbiAgICAgICAgLy8gICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgdGhpcy5kYXRhID0gSlNPTi5wYXJzZSh0ZXh0KTtcclxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgdGhpcy50eXBlID0gUmVzb3VyY2VMb2FkZXIuVFlQRS5KU09OO1xyXG4gICAgICAgIC8vICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgdGhpcy5hYm9ydCgnRXJyb3IgdHJ5aW5nIHRvIHBhcnNlIGxvYWRlZCBqc29uOiAnICsgZSk7XHJcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAvLyAgICAgICAgICAgICB9XHJcbiAgICAgICAgLy8gICAgICAgICB9XHJcbiAgICAgICAgLy8gICAgICAgICAvLyBpZiB4bWwsIHBhcnNlIGludG8gYW4geG1sIGRvY3VtZW50IG9yIGRpdiBlbGVtZW50XHJcbiAgICAgICAgLy8gICAgICAgICBlbHNlIGlmICh0aGlzLnhoclR5cGUgPT09IFJlc291cmNlTG9hZGVyLlhIUl9SRVNQT05TRV9UWVBFLkRPQ1VNRU5UKSB7XHJcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICBpZiAod2luZG93WydET01QYXJzZXInXSkge1xyXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkb21wYXJzZXIgPSBuZXcgRE9NUGFyc2VyKCk7XHJcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kYXRhID0gZG9tcGFyc2VyLnBhcnNlRnJvbVN0cmluZyh0ZXh0LCAndGV4dC94bWwnKTtcclxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgIGRpdi5pbm5lckhUTUwgPSB0ZXh0O1xyXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGF0YSA9IGRpdjtcclxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgIHRoaXMudHlwZSA9IFJlc291cmNlTG9hZGVyLlRZUEUuWE1MO1xyXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICB0aGlzLmFib3J0KCdFcnJvciB0cnlpbmcgdG8gcGFyc2UgbG9hZGVkIHhtbDogJyArIGUpO1xyXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgLy8gICAgICAgICAgICAgfVxyXG4gICAgICAgIC8vICAgICAgICAgICAgIC8vIG90aGVyIHR5cGVzIGp1c3QgcmV0dXJuIHRoZSByZXNwb25zZVxyXG4gICAgICAgIC8vICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgdGhpcy5kYXRhID0geGhyLnJlc3BvbnNlIHx8IHRleHQ7XHJcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAvLyB9IGVsc2Uge1xyXG4gICAgICAgIC8vICAgICB0aGlzLmFib3J0KCdbJyArIHhoci5zdGF0dXMgKyAnXSAnICsgeGhyLnN0YXR1c1RleHQgKyAnOiAnICsgeGhyLnJlc3BvbnNlVVJMKTtcclxuICAgICAgICAvLyAgICAgcmV0dXJuO1xyXG4gICAgICAgIC8vIH1cclxuICAgICAgICAvLyB0aGlzLmNvbXBsZXRlKCk7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIERldGVybWluZXMgdGhlIHJlc3BvbnNlVHlwZSBvZiBhbiBYSFIgcmVxdWVzdCBiYXNlZCBvbiB0aGUgZXh0ZW5zaW9uIG9mIHRoZVxyXG4gICAgICogcmVzb3VyY2UgYmVpbmcgbG9hZGVkLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcmV0dXJuIHtSZXNvdXJjZS5YSFJfUkVTUE9OU0VfVFlQRX0gVGhlIHJlc3BvbnNlVHlwZSB0byB1c2UuXHJcbiAgICAgKi9cclxuICAgIF9kZXRlcm1pbmVYaHJUeXBlKCkge1xyXG4gICAgICAgIHJldHVybiBSZXNvdXJjZUxvYWRlci5feGhyVHlwZU1hcFt0aGlzLmV4dGVuc2lvbl0gfHwgUmVzb3VyY2VMb2FkZXIuWEhSX1JFU1BPTlNFX1RZUEUuVEVYVDtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogRGV0ZXJtaW5lcyB0aGUgbG9hZFR5cGUgb2YgYSByZXNvdXJjZSBiYXNlZCBvbiB0aGUgZXh0ZW5zaW9uIG9mIHRoZVxyXG4gICAgICogcmVzb3VyY2UgYmVpbmcgbG9hZGVkLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcmV0dXJuIHtSZXNvdXJjZS5MT0FEX1RZUEV9IFRoZSBsb2FkVHlwZSB0byB1c2UuXHJcbiAgICAgKi9cclxuICAgIC8qKlxyXG4gICAgICogRGV0ZXJtaW5lcyB0aGUgbWltZSB0eXBlIG9mIGFuIFhIUiByZXF1ZXN0IGJhc2VkIG9uIHRoZSByZXNwb25zZVR5cGUgb2ZcclxuICAgICAqIHJlc291cmNlIGJlaW5nIGxvYWRlZC5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtSZXNvdXJjZS5YSFJfUkVTUE9OU0VfVFlQRX0gdHlwZSAtIFRoZSB0eXBlIHRvIGdldCBhIG1pbWUgdHlwZSBmb3IuXHJcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBtaW1lIHR5cGUgdG8gdXNlLlxyXG4gICAgICovXHJcbiAgICBfZ2V0TWltZUZyb21YaHJUeXBlKHR5cGUpIHtcclxuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcclxuICAgICAgICAgICAgY2FzZSBSZXNvdXJjZUxvYWRlci5YSFJfUkVTUE9OU0VfVFlQRS5CVUZGRVI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2FwcGxpY2F0aW9uL29jdGV0LWJpbmFyeSc7XHJcbiAgICAgICAgICAgIGNhc2UgUmVzb3VyY2VMb2FkZXIuWEhSX1JFU1BPTlNFX1RZUEUuQkxPQjpcclxuICAgICAgICAgICAgICAgIHJldHVybiAnYXBwbGljYXRpb24vYmxvYic7XHJcbiAgICAgICAgICAgIGNhc2UgUmVzb3VyY2VMb2FkZXIuWEhSX1JFU1BPTlNFX1RZUEUuRE9DVU1FTlQ6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2FwcGxpY2F0aW9uL3htbCc7XHJcbiAgICAgICAgICAgIGNhc2UgUmVzb3VyY2VMb2FkZXIuWEhSX1JFU1BPTlNFX1RZUEUuSlNPTjpcclxuICAgICAgICAgICAgICAgIHJldHVybiAnYXBwbGljYXRpb24vanNvbic7XHJcbiAgICAgICAgICAgIGNhc2UgUmVzb3VyY2VMb2FkZXIuWEhSX1JFU1BPTlNFX1RZUEUuREVGQVVMVDpcclxuICAgICAgICAgICAgY2FzZSBSZXNvdXJjZUxvYWRlci5YSFJfUkVTUE9OU0VfVFlQRS5URVhUOlxyXG4gICAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3RleHQvcGxhaW4nO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIDtcclxuICAgIGdldCBpc0RhdGFVcmwoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hhc0ZsYWcoUmVzb3VyY2VMb2FkZXIuU1RBVFVTX0ZMQUdTLkRBVEFfVVJMKTtcclxuICAgIH1cclxuICAgIGdldCBpc0NvbXBsZXRlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9oYXNGbGFnKFJlc291cmNlTG9hZGVyLlNUQVRVU19GTEFHUy5DT01QTEVURSk7XHJcbiAgICB9XHJcbiAgICBnZXQgaXNMb2FkaW5nKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9oYXNGbGFnKFJlc291cmNlTG9hZGVyLlNUQVRVU19GTEFHUy5MT0FESU5HKTtcclxuICAgIH1cclxufVxyXG5SZXNvdXJjZUxvYWRlci5TVEFUVVNfTk9ORSA9IDA7XHJcblJlc291cmNlTG9hZGVyLlNUQVRVU19PSyA9IDIwMDtcclxuUmVzb3VyY2VMb2FkZXIuU1RBVFVTX0VNUFRZID0gMjA0O1xyXG5SZXNvdXJjZUxvYWRlci5TVEFUVVNfSUVfQlVHX0VNUFRZID0gMTIyMztcclxuUmVzb3VyY2VMb2FkZXIuU1RBVFVTX1RZUEVfT0sgPSAyO1xyXG5SZXNvdXJjZUxvYWRlci51c2VYZHIgPSAhISh3aW5kb3dbJ1hEb21haW5SZXF1ZXN0J10gJiYgISgnd2l0aENyZWRlbnRpYWxzJyBpbiBuZXcgWE1MSHR0cFJlcXVlc3QoKSkpO1xyXG5SZXNvdXJjZUxvYWRlci5FTVBUWV9HSUYgPSAnZGF0YTppbWFnZS9naWY7YmFzZTY0LFIwbEdPRGxoQVFBQkFJQUFBUC8vL3dBQUFDSDVCQUVBQUFBQUxBQUFBQUFCQUFFQUFBSUNSQUVBT3c9PSc7XHJcblJlc291cmNlTG9hZGVyLkxPQURfVFlQRSA9IHtcclxuICAgIFhIUjogMSxcclxuICAgIElNQUdFOiAyLFxyXG4gICAgQVVESU86IDMsXHJcbiAgICBWSURFTzogNFxyXG59O1xyXG5SZXNvdXJjZUxvYWRlci5YSFJfUkVTUE9OU0VfVFlQRSA9IHtcclxuICAgIERFRkFVTFQ6ICd0ZXh0JyxcclxuICAgIEJVRkZFUjogJ2FycmF5YnVmZmVyJyxcclxuICAgIEJMT0I6ICdibG9iJyxcclxuICAgIERPQ1VNRU5UOiAnZG9jdW1lbnQnLFxyXG4gICAgSlNPTjogJ2pzb24nLFxyXG4gICAgVEVYVDogJ3RleHQnXHJcbn07XHJcblJlc291cmNlTG9hZGVyLl94aHJUeXBlTWFwID0ge1xyXG4gICAgeGh0bWw6IFJlc291cmNlTG9hZGVyLlhIUl9SRVNQT05TRV9UWVBFLkRPQ1VNRU5ULFxyXG4gICAgaHRtbDogUmVzb3VyY2VMb2FkZXIuWEhSX1JFU1BPTlNFX1RZUEUuRE9DVU1FTlQsXHJcbiAgICBodG06IFJlc291cmNlTG9hZGVyLlhIUl9SRVNQT05TRV9UWVBFLkRPQ1VNRU5ULFxyXG4gICAgeG1sOiBSZXNvdXJjZUxvYWRlci5YSFJfUkVTUE9OU0VfVFlQRS5ET0NVTUVOVCxcclxuICAgIHRteDogUmVzb3VyY2VMb2FkZXIuWEhSX1JFU1BPTlNFX1RZUEUuRE9DVU1FTlQsXHJcbiAgICBzdmc6IFJlc291cmNlTG9hZGVyLlhIUl9SRVNQT05TRV9UWVBFLkRPQ1VNRU5ULFxyXG4gICAgdHN4OiBSZXNvdXJjZUxvYWRlci5YSFJfUkVTUE9OU0VfVFlQRS5ET0NVTUVOVCxcclxuICAgIGdpZjogUmVzb3VyY2VMb2FkZXIuWEhSX1JFU1BPTlNFX1RZUEUuQkxPQixcclxuICAgIHBuZzogUmVzb3VyY2VMb2FkZXIuWEhSX1JFU1BPTlNFX1RZUEUuQkxPQixcclxuICAgIGJtcDogUmVzb3VyY2VMb2FkZXIuWEhSX1JFU1BPTlNFX1RZUEUuQkxPQixcclxuICAgIGpwZzogUmVzb3VyY2VMb2FkZXIuWEhSX1JFU1BPTlNFX1RZUEUuQkxPQixcclxuICAgIGpwZWc6IFJlc291cmNlTG9hZGVyLlhIUl9SRVNQT05TRV9UWVBFLkJMT0IsXHJcbiAgICB0aWY6IFJlc291cmNlTG9hZGVyLlhIUl9SRVNQT05TRV9UWVBFLkJMT0IsXHJcbiAgICB0aWZmOiBSZXNvdXJjZUxvYWRlci5YSFJfUkVTUE9OU0VfVFlQRS5CTE9CLFxyXG4gICAgd2VicDogUmVzb3VyY2VMb2FkZXIuWEhSX1JFU1BPTlNFX1RZUEUuQkxPQixcclxuICAgIHRnYTogUmVzb3VyY2VMb2FkZXIuWEhSX1JFU1BPTlNFX1RZUEUuQkxPQixcclxuICAgIGpzb246IFJlc291cmNlTG9hZGVyLlhIUl9SRVNQT05TRV9UWVBFLkpTT04sXHJcbiAgICB0ZXh0OiBSZXNvdXJjZUxvYWRlci5YSFJfUkVTUE9OU0VfVFlQRS5URVhULFxyXG4gICAgdHh0OiBSZXNvdXJjZUxvYWRlci5YSFJfUkVTUE9OU0VfVFlQRS5URVhULFxyXG4gICAgdHRmOiBSZXNvdXJjZUxvYWRlci5YSFJfUkVTUE9OU0VfVFlQRS5CVUZGRVIsXHJcbiAgICBvdGY6IFJlc291cmNlTG9hZGVyLlhIUl9SRVNQT05TRV9UWVBFLkJVRkZFUlxyXG59O1xyXG5SZXNvdXJjZUxvYWRlci5fbG9hZFR5cGVNYXAgPSB7XHJcbiAgICBnaWY6IFJlc291cmNlTG9hZGVyLkxPQURfVFlQRS5JTUFHRSxcclxuICAgIHBuZzogUmVzb3VyY2VMb2FkZXIuTE9BRF9UWVBFLklNQUdFLFxyXG4gICAgYm1wOiBSZXNvdXJjZUxvYWRlci5MT0FEX1RZUEUuSU1BR0UsXHJcbiAgICBqcGc6IFJlc291cmNlTG9hZGVyLkxPQURfVFlQRS5JTUFHRSxcclxuICAgIGpwZWc6IFJlc291cmNlTG9hZGVyLkxPQURfVFlQRS5JTUFHRSxcclxuICAgIHRpZjogUmVzb3VyY2VMb2FkZXIuTE9BRF9UWVBFLklNQUdFLFxyXG4gICAgdGlmZjogUmVzb3VyY2VMb2FkZXIuTE9BRF9UWVBFLklNQUdFLFxyXG4gICAgd2VicDogUmVzb3VyY2VMb2FkZXIuTE9BRF9UWVBFLklNQUdFLFxyXG4gICAgdGdhOiBSZXNvdXJjZUxvYWRlci5MT0FEX1RZUEUuSU1BR0UsXHJcbiAgICBzdmc6IFJlc291cmNlTG9hZGVyLkxPQURfVFlQRS5JTUFHRSxcclxuICAgICdzdmcreG1sJzogUmVzb3VyY2VMb2FkZXIuTE9BRF9UWVBFLklNQUdFLFxyXG4gICAgbXAzOiBSZXNvdXJjZUxvYWRlci5MT0FEX1RZUEUuQVVESU8sXHJcbiAgICBvZ2c6IFJlc291cmNlTG9hZGVyLkxPQURfVFlQRS5BVURJTyxcclxuICAgIHdhdjogUmVzb3VyY2VMb2FkZXIuTE9BRF9UWVBFLkFVRElPLFxyXG4gICAgbXA0OiBSZXNvdXJjZUxvYWRlci5MT0FEX1RZUEUuVklERU8sXHJcbiAgICB3ZWJtOiBSZXNvdXJjZUxvYWRlci5MT0FEX1RZUEUuVklERU9cclxufTtcclxuUmVzb3VyY2VMb2FkZXIuVFlQRSA9IHtcclxuICAgIFVOS05PV046IDAsXHJcbiAgICBKU09OOiAxLFxyXG4gICAgWE1MOiAyLFxyXG4gICAgSU1BR0U6IDMsXHJcbiAgICBBVURJTzogNCxcclxuICAgIFZJREVPOiA1LFxyXG4gICAgVEVYVDogNlxyXG59O1xyXG5SZXNvdXJjZUxvYWRlci5TVEFUVVNfRkxBR1MgPSB7XHJcbiAgICBOT05FOiAwLFxyXG4gICAgREFUQV9VUkw6IDEgPDwgMCxcclxuICAgIENPTVBMRVRFOiAxIDw8IDEsXHJcbiAgICBMT0FESU5HOiAxIDw8IDJcclxufTtcclxuZXhwb3J0cy5SZXNvdXJjZUxvYWRlciA9IFJlc291cmNlTG9hZGVyO1xyXG5jbGFzcyBVUklEYXRhIHtcclxufVxyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBJbWFnZVJlc291cmNlXzEgPSByZXF1aXJlKFwiLi9JbWFnZVJlc291cmNlXCIpO1xyXG5jb25zdCBDYW52YXNSZXNvdXJjZV8xID0gcmVxdWlyZShcIi4vQ2FudmFzUmVzb3VyY2VcIik7XHJcbmNvbnN0IFZpZGVvUmVzb3VyY2VfMSA9IHJlcXVpcmUoXCIuL1ZpZGVvUmVzb3VyY2VcIik7XHJcbmNvbnN0IFNWR1Jlc291cmNlXzEgPSByZXF1aXJlKFwiLi9TVkdSZXNvdXJjZVwiKTtcclxuY29uc3QgQnVmZmVyUmVzb3VyY2VfMSA9IHJlcXVpcmUoXCIuL0J1ZmZlclJlc291cmNlXCIpO1xyXG5jb25zdCBDdWJlUmVzb3VyY2VfMSA9IHJlcXVpcmUoXCIuL0N1YmVSZXNvdXJjZVwiKTtcclxuY29uc3QgQXJyYXlSZXNvdXJjZV8xID0gcmVxdWlyZShcIi4vQXJyYXlSZXNvdXJjZVwiKTtcclxuY2xhc3MgUmVzb3VyY2VTZXR0aW5ncyB7XHJcbiAgICBzdGF0aWMgYXV0b0RldGVjdFJlc291cmNlKHNvdXJjZSwgb3B0aW9ucykge1xyXG4gICAgICAgIGlmICghc291cmNlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgZXh0ZW5zaW9uID0gJyc7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBzb3VyY2UgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSAoL1xcLihcXHd7Myw0fSkoPzokfFxcP3wjKS9pKS5leGVjKHNvdXJjZSk7XHJcbiAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcclxuICAgICAgICAgICAgICAgIGV4dGVuc2lvbiA9IHJlc3VsdFsxXS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAodmFyIGkgPSBSZXNvdXJjZVNldHRpbmdzLklOU1RBTExFRC5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xyXG4gICAgICAgICAgICB2YXIgUmVzb3VyY2VQbHVnaW4gPSBSZXNvdXJjZVNldHRpbmdzLklOU1RBTExFRFtpXTtcclxuICAgICAgICAgICAgaWYgKFJlc291cmNlUGx1Z2luLnRlc3QgJiYgUmVzb3VyY2VQbHVnaW4udGVzdChzb3VyY2UsIGV4dGVuc2lvbikpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUmVzb3VyY2VQbHVnaW4oc291cmNlLCBvcHRpb25zKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IEltYWdlUmVzb3VyY2VfMS5JbWFnZVJlc291cmNlKHNvdXJjZSwgb3B0aW9ucyk7XHJcbiAgICB9XHJcbn1cclxuUmVzb3VyY2VTZXR0aW5ncy5JTlNUQUxMRUQgPSBbXHJcbiAgICBJbWFnZVJlc291cmNlXzEuSW1hZ2VSZXNvdXJjZSxcclxuICAgIENhbnZhc1Jlc291cmNlXzEuQ2FudmFzUmVzb3VyY2UsXHJcbiAgICBWaWRlb1Jlc291cmNlXzEuVmlkZW9SZXNvdXJjZSxcclxuICAgIFNWR1Jlc291cmNlXzEuU1ZHUmVzb3VyY2UsXHJcbiAgICBCdWZmZXJSZXNvdXJjZV8xLkJ1ZmZlclJlc291cmNlLFxyXG4gICAgQ3ViZVJlc291cmNlXzEuQ3ViZVJlc291cmNlLFxyXG4gICAgQXJyYXlSZXNvdXJjZV8xLkFycmF5UmVzb3VyY2VcclxuXTtcclxuZXhwb3J0cy5SZXNvdXJjZVNldHRpbmdzID0gUmVzb3VyY2VTZXR0aW5ncztcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgTWVzaEdlb21ldHJ5XzEgPSByZXF1aXJlKFwiLi9NZXNoR2VvbWV0cnlcIik7XHJcbmNsYXNzIFJvcGVHZW9tZXRyeSBleHRlbmRzIE1lc2hHZW9tZXRyeV8xLk1lc2hHZW9tZXRyeSB7XHJcbiAgICBjb25zdHJ1Y3Rvcih3aWR0aCA9IDIwMCwgcG9pbnRzID0gbnVsbCkge1xyXG4gICAgICAgIGlmICh3aWR0aCA9PT0gdm9pZCAwKSB7XHJcbiAgICAgICAgICAgIHdpZHRoID0gMjAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzdXBlcihuZXcgRmxvYXQzMkFycmF5KHBvaW50cy5sZW5ndGggKiA0KSwgbmV3IEZsb2F0MzJBcnJheShwb2ludHMubGVuZ3RoICogNCksIG5ldyBVaW50MTZBcnJheSgocG9pbnRzLmxlbmd0aCAtIDEpICogNikpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICogQW4gYXJyYXkgb2YgcG9pbnRzIHRoYXQgZGV0ZXJtaW5lIHRoZSByb3BlXHJcbiAgICAgICAgKiBAbWVtYmVyIHtQSVhJLlBvaW50W119XHJcbiAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnBvaW50cyA9IHBvaW50cztcclxuICAgICAgICAvKipcclxuICAgICAgICAqIFRoZSB3aWR0aCAoaS5lLiwgdGhpY2tuZXNzKSBvZiB0aGUgcm9wZS5cclxuICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAgICAqIEByZWFkT25seVxyXG4gICAgICAgICovXHJcbiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xyXG4gICAgICAgIHRoaXMuYnVpbGQoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgKiBSZWZyZXNoZXMgUm9wZSBpbmRpY2VzIGFuZCB1dnNcclxuICAgICogQHByaXZhdGVcclxuICAgICovXHJcbiAgICBidWlsZCgpIHtcclxuICAgICAgICB2YXIgcG9pbnRzID0gdGhpcy5wb2ludHM7XHJcbiAgICAgICAgaWYgKCFwb2ludHMpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgdmVydGV4QnVmZmVyID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2FWZXJ0ZXhQb3NpdGlvbicpO1xyXG4gICAgICAgIHZhciB1dkJ1ZmZlciA9IHRoaXMuZ2V0QXR0cmlidXRlKCdhVGV4dHVyZUNvb3JkJyk7XHJcbiAgICAgICAgdmFyIGluZGV4QnVmZmVyID0gdGhpcy5nZXRJbmRleCgpO1xyXG4gICAgICAgIC8vIGlmIHRvbyBsaXR0bGUgcG9pbnRzLCBvciB0ZXh0dXJlIGhhc24ndCBnb3QgVVZzIHNldCB5ZXQganVzdCBtb3ZlIG9uLlxyXG4gICAgICAgIGlmIChwb2ludHMubGVuZ3RoIDwgMSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGlmIHRoZSBudW1iZXIgb2YgcG9pbnRzIGhhcyBjaGFuZ2VkIHdlIHdpbGwgbmVlZCB0byByZWNyZWF0ZSB0aGUgYXJyYXlidWZmZXJzXHJcbiAgICAgICAgaWYgKHZlcnRleEJ1ZmZlci5kYXRhLmxlbmd0aCAvIDQgIT09IHBvaW50cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgdmVydGV4QnVmZmVyLmRhdGEgPSBuZXcgRmxvYXQzMkFycmF5KHBvaW50cy5sZW5ndGggKiA0KTtcclxuICAgICAgICAgICAgdXZCdWZmZXIuZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkocG9pbnRzLmxlbmd0aCAqIDQpO1xyXG4gICAgICAgICAgICBpbmRleEJ1ZmZlci5kYXRhID0gbmV3IFVpbnQxNkFycmF5KChwb2ludHMubGVuZ3RoIC0gMSkgKiA2KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHV2cyA9IHV2QnVmZmVyLmRhdGE7XHJcbiAgICAgICAgdmFyIGluZGljZXMgPSBpbmRleEJ1ZmZlci5kYXRhO1xyXG4gICAgICAgIHV2c1swXSA9IDA7XHJcbiAgICAgICAgdXZzWzFdID0gMDtcclxuICAgICAgICB1dnNbMl0gPSAwO1xyXG4gICAgICAgIHV2c1szXSA9IDE7XHJcbiAgICAgICAgLy8gaW5kaWNlc1swXSA9IDA7XHJcbiAgICAgICAgLy8gaW5kaWNlc1sxXSA9IDE7XHJcbiAgICAgICAgdmFyIHRvdGFsID0gcG9pbnRzLmxlbmd0aDsgLy8gLSAxO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG90YWw7IGkrKykge1xyXG4gICAgICAgICAgICAvLyB0aW1lIHRvIGRvIHNvbWUgc21hcnQgZHJhd2luZyFcclxuICAgICAgICAgICAgdmFyIGluZGV4ID0gaSAqIDQ7XHJcbiAgICAgICAgICAgIHZhciBhbW91bnQgPSBpIC8gKHRvdGFsIC0gMSk7XHJcbiAgICAgICAgICAgIHV2c1tpbmRleF0gPSBhbW91bnQ7XHJcbiAgICAgICAgICAgIHV2c1tpbmRleCArIDFdID0gMDtcclxuICAgICAgICAgICAgdXZzW2luZGV4ICsgMl0gPSBhbW91bnQ7XHJcbiAgICAgICAgICAgIHV2c1tpbmRleCArIDNdID0gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGluZGV4Q291bnQgPSAwO1xyXG4gICAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IHRvdGFsIC0gMTsgaSQxKyspIHtcclxuICAgICAgICAgICAgdmFyIGluZGV4JDEgPSBpJDEgKiAyO1xyXG4gICAgICAgICAgICBpbmRpY2VzW2luZGV4Q291bnQrK10gPSBpbmRleCQxO1xyXG4gICAgICAgICAgICBpbmRpY2VzW2luZGV4Q291bnQrK10gPSBpbmRleCQxICsgMTtcclxuICAgICAgICAgICAgaW5kaWNlc1tpbmRleENvdW50KytdID0gaW5kZXgkMSArIDI7XHJcbiAgICAgICAgICAgIGluZGljZXNbaW5kZXhDb3VudCsrXSA9IGluZGV4JDEgKyAyO1xyXG4gICAgICAgICAgICBpbmRpY2VzW2luZGV4Q291bnQrK10gPSBpbmRleCQxICsgMTtcclxuICAgICAgICAgICAgaW5kaWNlc1tpbmRleENvdW50KytdID0gaW5kZXgkMSArIDM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGVuc3VyZSB0aGF0IHRoZSBjaGFuZ2VzIGFyZSB1cGxvYWRlZFxyXG4gICAgICAgIHV2QnVmZmVyLnVwZGF0ZSgpO1xyXG4gICAgICAgIGluZGV4QnVmZmVyLnVwZGF0ZSgpO1xyXG4gICAgICAgIHRoaXMudXBkYXRlVmVydGljZXMoKTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgKiByZWZyZXNoZXMgdmVydGljZXMgb2YgUm9wZSBtZXNoXHJcbiAgICAqL1xyXG4gICAgdXBkYXRlVmVydGljZXMoKSB7XHJcbiAgICAgICAgdmFyIHBvaW50cyA9IHRoaXMucG9pbnRzO1xyXG4gICAgICAgIGlmIChwb2ludHMubGVuZ3RoIDwgMSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBsYXN0UG9pbnQgPSBwb2ludHNbMF07XHJcbiAgICAgICAgdmFyIG5leHRQb2ludDtcclxuICAgICAgICB2YXIgcGVycFggPSAwO1xyXG4gICAgICAgIHZhciBwZXJwWSA9IDA7XHJcbiAgICAgICAgLy8gdGhpcy5jb3VudCAtPSAwLjI7XHJcbiAgICAgICAgdmFyIHZlcnRpY2VzID0gdGhpcy5idWZmZXJzWzBdLmRhdGE7XHJcbiAgICAgICAgdmFyIHRvdGFsID0gcG9pbnRzLmxlbmd0aDtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRvdGFsOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIHBvaW50ID0gcG9pbnRzW2ldO1xyXG4gICAgICAgICAgICB2YXIgaW5kZXggPSBpICogNDtcclxuICAgICAgICAgICAgaWYgKGkgPCBwb2ludHMubGVuZ3RoIC0gMSkge1xyXG4gICAgICAgICAgICAgICAgbmV4dFBvaW50ID0gcG9pbnRzW2kgKyAxXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG5leHRQb2ludCA9IHBvaW50O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHBlcnBZID0gLShuZXh0UG9pbnQueCAtIGxhc3RQb2ludC54KTtcclxuICAgICAgICAgICAgcGVycFggPSBuZXh0UG9pbnQueSAtIGxhc3RQb2ludC55O1xyXG4gICAgICAgICAgICB2YXIgcGVycExlbmd0aCA9IE1hdGguc3FydCgocGVycFggKiBwZXJwWCkgKyAocGVycFkgKiBwZXJwWSkpO1xyXG4gICAgICAgICAgICB2YXIgbnVtID0gdGhpcy53aWR0aCAvIDI7IC8vICgyMCArIE1hdGguYWJzKE1hdGguc2luKChpICsgdGhpcy5jb3VudCkgKiAwLjMpICogNTApICkqIHJhdGlvO1xyXG4gICAgICAgICAgICBwZXJwWCAvPSBwZXJwTGVuZ3RoO1xyXG4gICAgICAgICAgICBwZXJwWSAvPSBwZXJwTGVuZ3RoO1xyXG4gICAgICAgICAgICBwZXJwWCAqPSBudW07XHJcbiAgICAgICAgICAgIHBlcnBZICo9IG51bTtcclxuICAgICAgICAgICAgdmVydGljZXNbaW5kZXhdID0gcG9pbnQueCArIHBlcnBYO1xyXG4gICAgICAgICAgICB2ZXJ0aWNlc1tpbmRleCArIDFdID0gcG9pbnQueSArIHBlcnBZO1xyXG4gICAgICAgICAgICB2ZXJ0aWNlc1tpbmRleCArIDJdID0gcG9pbnQueCAtIHBlcnBYO1xyXG4gICAgICAgICAgICB2ZXJ0aWNlc1tpbmRleCArIDNdID0gcG9pbnQueSAtIHBlcnBZO1xyXG4gICAgICAgICAgICBsYXN0UG9pbnQgPSBwb2ludDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5idWZmZXJzWzBdLnVwZGF0ZSgpO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgdXBkYXRlKCkge1xyXG4gICAgICAgIHRoaXMudXBkYXRlVmVydGljZXMoKTtcclxuICAgIH1cclxuICAgIDtcclxufVxyXG5leHBvcnRzLlJvcGVHZW9tZXRyeSA9IFJvcGVHZW9tZXRyeTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgU2hhcGVTZXR0aW5nc18xID0gcmVxdWlyZShcIi4vU2hhcGVTZXR0aW5nc1wiKTtcclxuY2xhc3MgUm91bmRlZFJlY3RhbmdsZSB7XHJcbiAgICBjb25zdHJ1Y3Rvcih4ID0gMCwgeSA9IDAsIHdpZHRoID0gMCwgaGVpZ2h0ID0gMCwgcmFkaXVzID0gMjApIHtcclxuICAgICAgICBpZiAoeCA9PT0gdm9pZCAwKSB7XHJcbiAgICAgICAgICAgIHggPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoeSA9PT0gdm9pZCAwKSB7XHJcbiAgICAgICAgICAgIHkgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAod2lkdGggPT09IHZvaWQgMCkge1xyXG4gICAgICAgICAgICB3aWR0aCA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChoZWlnaHQgPT09IHZvaWQgMCkge1xyXG4gICAgICAgICAgICBoZWlnaHQgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocmFkaXVzID09PSB2b2lkIDApIHtcclxuICAgICAgICAgICAgcmFkaXVzID0gMjA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAgICAgKiBAZGVmYXVsdCAwXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy54ID0geDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgICAgICogQGRlZmF1bHQgMFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMueSA9IHk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICAgICAqIEBkZWZhdWx0IDBcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLndpZHRoID0gd2lkdGg7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICAgICAqIEBkZWZhdWx0IDBcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgICAgICogQGRlZmF1bHQgMjBcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnJhZGl1cyA9IHJhZGl1cztcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgdHlwZSBvZiB0aGUgb2JqZWN0LCBtYWlubHkgdXNlZCB0byBhdm9pZCBgaW5zdGFuY2VvZmAgY2hlY2tzXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgICAgICogQHJlYWRvbmx5XHJcbiAgICAgICAgICogQGRlZmF1bHQgUElYSS5TSEFQRVMuUlJFQ1xyXG4gICAgICAgICAqIEBzZWUgUElYSS5TSEFQRVNcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnR5cGUgPSBTaGFwZVNldHRpbmdzXzEuU2hhcGVTZXR0aW5ncy5TSEFQRVMuUlJFQztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIGNsb25lIG9mIHRoaXMgUm91bmRlZCBSZWN0YW5nbGVcclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIHtQSVhJLlJvdW5kZWRSZWN0YW5nbGV9IGEgY29weSBvZiB0aGUgcm91bmRlZCByZWN0YW5nbGVcclxuICAgICAqL1xyXG4gICAgY2xvbmUoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBSb3VuZGVkUmVjdGFuZ2xlKHRoaXMueCwgdGhpcy55LCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgdGhpcy5yYWRpdXMpO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgeCBhbmQgeSBjb29yZGluYXRlcyBnaXZlbiBhcmUgY29udGFpbmVkIHdpdGhpbiB0aGlzIFJvdW5kZWQgUmVjdGFuZ2xlXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggLSBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBwb2ludCB0byB0ZXN0XHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSAtIFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50IHRvIHRlc3RcclxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIHgveSBjb29yZGluYXRlcyBhcmUgd2l0aGluIHRoaXMgUm91bmRlZCBSZWN0YW5nbGVcclxuICAgICAqL1xyXG4gICAgY29udGFpbnMoeCwgeSkge1xyXG4gICAgICAgIGlmICh0aGlzLndpZHRoIDw9IDAgfHwgdGhpcy5oZWlnaHQgPD0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh4ID49IHRoaXMueCAmJiB4IDw9IHRoaXMueCArIHRoaXMud2lkdGgpIHtcclxuICAgICAgICAgICAgaWYgKHkgPj0gdGhpcy55ICYmIHkgPD0gdGhpcy55ICsgdGhpcy5oZWlnaHQpIHtcclxuICAgICAgICAgICAgICAgIGlmICgoeSA+PSB0aGlzLnkgKyB0aGlzLnJhZGl1cyAmJiB5IDw9IHRoaXMueSArIHRoaXMuaGVpZ2h0IC0gdGhpcy5yYWRpdXMpXHJcbiAgICAgICAgICAgICAgICAgICAgfHwgKHggPj0gdGhpcy54ICsgdGhpcy5yYWRpdXMgJiYgeCA8PSB0aGlzLnggKyB0aGlzLndpZHRoIC0gdGhpcy5yYWRpdXMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgZHggPSB4IC0gKHRoaXMueCArIHRoaXMucmFkaXVzKTtcclxuICAgICAgICAgICAgICAgIHZhciBkeSA9IHkgLSAodGhpcy55ICsgdGhpcy5yYWRpdXMpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHJhZGl1czIgPSB0aGlzLnJhZGl1cyAqIHRoaXMucmFkaXVzO1xyXG4gICAgICAgICAgICAgICAgaWYgKChkeCAqIGR4KSArIChkeSAqIGR5KSA8PSByYWRpdXMyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBkeCA9IHggLSAodGhpcy54ICsgdGhpcy53aWR0aCAtIHRoaXMucmFkaXVzKTtcclxuICAgICAgICAgICAgICAgIGlmICgoZHggKiBkeCkgKyAoZHkgKiBkeSkgPD0gcmFkaXVzMikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZHkgPSB5IC0gKHRoaXMueSArIHRoaXMuaGVpZ2h0IC0gdGhpcy5yYWRpdXMpO1xyXG4gICAgICAgICAgICAgICAgaWYgKChkeCAqIGR4KSArIChkeSAqIGR5KSA8PSByYWRpdXMyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBkeCA9IHggLSAodGhpcy54ICsgdGhpcy5yYWRpdXMpO1xyXG4gICAgICAgICAgICAgICAgaWYgKChkeCAqIGR4KSArIChkeSAqIGR5KSA8PSByYWRpdXMyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgO1xyXG59XHJcbmV4cG9ydHMuUm91bmRlZFJlY3RhbmdsZSA9IFJvdW5kZWRSZWN0YW5nbGU7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNsYXNzIFJ1bm5lciB7XHJcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCBwcmlvcml0eSA9IDApIHtcclxuICAgICAgICB0aGlzLml0ZW1zID0gW107XHJcbiAgICAgICAgdGhpcy5fbmFtZSA9IG5hbWU7XHJcbiAgICAgICAgdGhpcy5kaXNwYXRjaCA9IHRoaXMuZW1pdDtcclxuICAgICAgICB0aGlzLnJ1biA9IHRoaXMuZW1pdDtcclxuICAgIH1cclxuICAgIGVtaXQoYTAsIGExLCBhMiwgYTMsIGE0LCBhNSwgYTYsIGE3KSB7XHJcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiA4KSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbWF4IGFyZ3VtZW50cyByZWFjaGVkJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciByZWYgPSB0aGlzO1xyXG4gICAgICAgIHZhciBuYW1lID0gcmVmLm5hbWU7XHJcbiAgICAgICAgdmFyIGl0ZW1zID0gcmVmLml0ZW1zO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBpdGVtcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICBpdGVtc1tpXVtuYW1lXShhMCwgYTEsIGEyLCBhMywgYTQsIGE1LCBhNiwgYTcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQWRkIGEgbGlzdGVuZXIgdG8gdGhlIFJ1bm5lclxyXG4gICAgICpcclxuICAgICAqIFJ1bm5lcnMgZG8gbm90IG5lZWQgdG8gaGF2ZSBzY29wZSBvciBmdW5jdGlvbnMgcGFzc2VkIHRvIHRoZW0uXHJcbiAgICAgKiBBbGwgdGhhdCBpcyByZXF1aXJlZCBpcyB0byBwYXNzIHRoZSBsaXN0ZW5pbmcgb2JqZWN0IGFuZCBlbnN1cmUgdGhhdCBpdCBoYXMgY29udGFpbnMgYSBmdW5jdGlvbiB0aGF0IGhhcyB0aGUgc2FtZSBuYW1lXHJcbiAgICAgKiBhcyB0aGUgbmFtZSBwcm92aWRlZCB0byB0aGUgUnVubmVyIHdoZW4gaXQgd2FzIGNyZWF0ZWQuXHJcbiAgICAgKlxyXG4gICAgICogRWcgQSBsaXN0ZW5lciBwYXNzZWQgdG8gdGhpcyBSdW5uZXIgd2lsbCByZXF1aXJlIGEgJ2NvbXBsZXRlJyBmdW5jdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBgYGBcclxuICAgICAqIGNvbnN0IGNvbXBsZXRlID0gbmV3IFBJWEkuUnVubmVyKCdjb21wbGV0ZScpO1xyXG4gICAgICogYGBgXHJcbiAgICAgKlxyXG4gICAgICogVGhlIHNjb3BlIHVzZWQgd2lsbCBiZSB0aGUgb2JqZWN0IGl0c2VsZi5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge2FueX0gaXRlbSAtIFRoZSBvYmplY3QgdGhhdCB3aWxsIGJlIGxpc3RlbmluZy5cclxuICAgICAqL1xyXG4gICAgYWRkKGl0ZW0pIHtcclxuICAgICAgICBpZiAoaXRlbVt0aGlzLl9uYW1lXSkge1xyXG4gICAgICAgICAgICB0aGlzLnJlbW92ZShpdGVtKTtcclxuICAgICAgICAgICAgdGhpcy5pdGVtcy5wdXNoKGl0ZW0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlIGEgc2luZ2xlIGxpc3RlbmVyIGZyb20gdGhlIGRpc3BhdGNoIHF1ZXVlLlxyXG4gICAgICogQHBhcmFtIHthbnl9IGl0ZW0gLSBUaGUgbGlzdGVuciB0aGF0IHlvdSB3b3VsZCBsaWtlIHRvIHJlbW92ZS5cclxuICAgICAqL1xyXG4gICAgcmVtb3ZlKGl0ZW0pIHtcclxuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLml0ZW1zLmluZGV4T2YoaXRlbSk7XHJcbiAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xyXG4gICAgICAgICAgICB0aGlzLml0ZW1zLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVjayB0byBzZWUgaWYgdGhlIGxpc3RlbmVyIGlzIGFscmVhZHkgaW4gdGhlIFJ1bm5lclxyXG4gICAgICogQHBhcmFtIHthbnl9IGl0ZW0gLSBUaGUgbGlzdGVuZXIgdGhhdCB5b3Ugd291bGQgbGlrZSB0byBjaGVjay5cclxuICAgICAqL1xyXG4gICAgY29udGFpbnMoaXRlbSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLml0ZW1zLmluZGV4T2YoaXRlbSkgIT09IC0xO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmUgYWxsIGxpc3RlbmVycyBmcm9tIHRoZSBSdW5uZXJcclxuICAgICAqL1xyXG4gICAgcmVtb3ZlQWxsKCkge1xyXG4gICAgICAgIHRoaXMuaXRlbXMubGVuZ3RoID0gMDtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlIGFsbCByZWZlcmVuY2VzLCBkb24ndCB1c2UgYWZ0ZXIgdGhpcy5cclxuICAgICAqL1xyXG4gICAgZGVzdHJveSgpIHtcclxuICAgICAgICB0aGlzLnJlbW92ZUFsbCgpO1xyXG4gICAgICAgIHRoaXMuaXRlbXMgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuX25hbWUgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBgdHJ1ZWAgaWYgdGhlcmUgYXJlIG5vIHRoaXMgUnVubmVyIGNvbnRhaW5zIG5vIGxpc3RlbmVyc1xyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqL1xyXG4gICAgZ2V0IGVtcHR5KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLml0ZW1zLmxlbmd0aCA9PT0gMDtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIG5hbWUgb2YgdGhlIHJ1bm5lci5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtzdHJpbmd9XHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqL1xyXG4gICAgZ2V0IG5hbWUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX25hbWU7XHJcbiAgICB9XHJcbiAgICA7XHJcbn1cclxuZXhwb3J0cy5SdW5uZXIgPSBSdW5uZXI7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IEJhc2VJbWFnZVJlc291cmNlXzEgPSByZXF1aXJlKFwiLi9CYXNlSW1hZ2VSZXNvdXJjZVwiKTtcclxuY29uc3Qgc2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL3NldHRpbmdzXCIpO1xyXG5jb25zdCBNYXRoU2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL01hdGhTZXR0aW5nc1wiKTtcclxuY2xhc3MgU1ZHUmVzb3VyY2UgZXh0ZW5kcyBCYXNlSW1hZ2VSZXNvdXJjZV8xLkJhc2VJbWFnZVJlc291cmNlIHtcclxuICAgIGNvbnN0cnVjdG9yKHNvdXJjZSwgb3B0aW9ucykge1xyXG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG4gICAgICAgIHN1cGVyKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBCYXNlNjQgZW5jb2RlZCBTVkcgZWxlbWVudCBvciBVUkwgZm9yIFNWRyBmaWxlXHJcbiAgICAgICAgICogQHJlYWRvbmx5XHJcbiAgICAgICAgICogQG1lbWJlciB7c3RyaW5nfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuc3ZnID0gc291cmNlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBzb3VyY2Ugc2NhbGUgdG8gYXBwbHkgdG8gcmVuZGVyXHJcbiAgICAgICAgICogQHJlYWRvbmx5XHJcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuc2NhbGUgPSBvcHRpb25zLnNjYWxlIHx8IDE7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2FsbCB3aGVuIGNvbXBsZXRlbHkgbG9hZGVkXHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKiBAbWVtYmVyIHtmdW5jdGlvbn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLl9yZXNvbHZlID0gbnVsbDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBQcm9taXNlIHdoZW4gbG9hZGluZ1xyXG4gICAgICAgICAqIEBtZW1iZXIge1Byb21pc2U8dm9pZD59XHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKiBAZGVmYXVsdCBudWxsXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5fbG9hZCA9IG51bGw7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMuYXV0b0xvYWQgIT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIHRoaXMubG9hZCgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGxvYWQoKSB7XHJcbiAgICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XHJcbiAgICAgICAgaWYgKHRoaXMuX2xvYWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xvYWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2xvYWQgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xyXG4gICAgICAgICAgICAvLyBTYXZlIHRoaXMgdW50aWwgYWZ0ZXIgbG9hZCBpcyBmaW5pc2hlZFxyXG4gICAgICAgICAgICB0aGlzJDEuX3Jlc29sdmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzJDEucmVzaXplKHRoaXMkMS5zb3VyY2Uud2lkdGgsIHRoaXMkMS5zb3VyY2UuaGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgIHJlc29sdmUodGhpcyQxKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgLy8gQ29udmVydCBTVkcgaW5saW5lIHN0cmluZyB0byBkYXRhLXVyaVxyXG4gICAgICAgICAgICBpZiAoKC9eXFw8c3ZnLykudGVzdCh0aGlzJDEuc3ZnLnRyaW0oKSkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMkMS5zdmcgPSBcImRhdGE6aW1hZ2Uvc3ZnK3htbDt1dGY4LFwiICsgKHRoaXMkMS5zdmcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIENoZWNrcyBpZiBgc291cmNlYCBpcyBhbiBTVkcgaW1hZ2UgYW5kIHdoZXRoZXIgaXQnc1xyXG4gICAgICAgICAgICAvLyBsb2FkZWQgdmlhIGEgVVJMIG9yIGEgZGF0YSBVUkkuIFRoZW4gY2FsbHNcclxuICAgICAgICAgICAgLy8gYF9sb2FkRGF0YVVyaWAgb3IgYF9sb2FkWGhyYC5cclxuICAgICAgICAgICAgdmFyIGRhdGFVcmkgPSBzZXR0aW5nc18xLnNldHRpbmdzLmRlY29tcG9zZURhdGFVcmkodGhpcyQxLnN2Zyk7XHJcbiAgICAgICAgICAgIGlmIChkYXRhVXJpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzJDEuX2xvYWREYXRhVXJpKGRhdGFVcmkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gV2UgZ290IGFuIFVSTCwgc28gd2UgbmVlZCB0byBkbyBhbiBYSFIgdG8gY2hlY2sgdGhlIHN2ZyBzaXplXHJcbiAgICAgICAgICAgICAgICB0aGlzJDEuX2xvYWRYaHIoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9sb2FkO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZWFkcyBhbiBTVkcgc3RyaW5nIGZyb20gZGF0YSBVUkkgYW5kIHRoZW4gY2FsbHMgYF9sb2FkU3RyaW5nYC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZGF0YVVyaSAtIFRoZSBkYXRhIHVyaSB0byBsb2FkIGZyb20uXHJcbiAgICAgKi9cclxuICAgIF9sb2FkRGF0YVVyaShkYXRhVXJpKSB7XHJcbiAgICAgICAgdmFyIHN2Z1N0cmluZztcclxuICAgICAgICBpZiAoZGF0YVVyaS5lbmNvZGluZyA9PT0gJ2Jhc2U2NCcpIHtcclxuICAgICAgICAgICAgaWYgKCFhdG9iKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdXIgYnJvd3NlciBkb2VzblxcJ3Qgc3VwcG9ydCBiYXNlNjQgY29udmVyc2lvbnMuJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc3ZnU3RyaW5nID0gYXRvYihkYXRhVXJpLmRhdGEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgc3ZnU3RyaW5nID0gZGF0YVVyaS5kYXRhO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9sb2FkU3RyaW5nKHN2Z1N0cmluZyk7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIExvYWRzIGFuIFNWRyBzdHJpbmcgZnJvbSBgaW1hZ2VVcmxgIHVzaW5nIFhIUiBhbmQgdGhlbiBjYWxscyBgX2xvYWRTdHJpbmdgLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIF9sb2FkWGhyKCkge1xyXG4gICAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xyXG4gICAgICAgIHZhciBzdmdYaHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcclxuICAgICAgICAvLyBUaGlzIHRocm93cyBlcnJvciBvbiBJRSwgc28gU1ZHIERvY3VtZW50IGNhbid0IGJlIHVzZWRcclxuICAgICAgICAvLyBzdmdYaHIucmVzcG9uc2VUeXBlID0gJ2RvY3VtZW50JztcclxuICAgICAgICAvLyBUaGlzIGlzIG5vdCBuZWVkZWQgc2luY2Ugd2UgbG9hZCB0aGUgc3ZnIGFzIHN0cmluZyAoYnJlYWtzIElFIHRvbylcclxuICAgICAgICAvLyBidXQgb3ZlcnJpZGVNaW1lVHlwZSgpIGNhbiBiZSB1c2VkIHRvIGZvcmNlIHRoZSByZXNwb25zZSB0byBiZSBwYXJzZWQgYXMgWE1MXHJcbiAgICAgICAgLy8gc3ZnWGhyLm92ZXJyaWRlTWltZVR5cGUoJ2ltYWdlL3N2Zyt4bWwnKTtcclxuICAgICAgICBzdmdYaHIub25sb2FkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAoc3ZnWGhyLnJlYWR5U3RhdGUgIT09IHN2Z1hoci5ET05FIHx8IHN2Z1hoci5zdGF0dXMgIT09IDIwMCkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gbG9hZCBTVkcgdXNpbmcgWEhSLicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMkMS5fbG9hZFN0cmluZyhzdmdYaHIucmVzcG9uc2UpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gc3ZnWGhyLm9uZXJyb3IgPSAoKSA9PiB0aGlzLmVtaXQoJ2Vycm9yJywgdGhpcyk7XHJcbiAgICAgICAgc3ZnWGhyLm9wZW4oJ0dFVCcsIHRoaXMuc3ZnLCB0cnVlKTtcclxuICAgICAgICBzdmdYaHIuc2VuZCgpO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBMb2FkcyB0ZXh0dXJlIHVzaW5nIGFuIFNWRyBzdHJpbmcuIFRoZSBvcmlnaW5hbCBTVkcgSW1hZ2UgaXMgc3RvcmVkIGFzIGBvcmlnU291cmNlYCBhbmQgdGhlXHJcbiAgICAgKiBjcmVhdGVkIGNhbnZhcyBpcyB0aGUgbmV3IGBzb3VyY2VgLiBUaGUgU1ZHIGlzIHNjYWxlZCB1c2luZyBgc291cmNlU2NhbGVgLiBDYWxsZWQgYnlcclxuICAgICAqIGBfbG9hZFhocmAgb3IgYF9sb2FkRGF0YVVyaWAuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSAge3N0cmluZ30gc3ZnU3RyaW5nIFNWRyBzb3VyY2UgYXMgc3RyaW5nXHJcbiAgICAgKlxyXG4gICAgICogQGZpcmVzIGxvYWRlZFxyXG4gICAgICovXHJcbiAgICBfbG9hZFN0cmluZyhzdmdTdHJpbmcpIHtcclxuICAgICAgICB2YXIgc3ZnU2l6ZSA9IFNWR1Jlc291cmNlLmdldFNpemUoc3ZnU3RyaW5nKTtcclxuICAgICAgICAvLyBUT0RPIGRvIHdlIG5lZWQgdG8gd2FpdCBmb3IgdGhpcyB0byBsb2FkP1xyXG4gICAgICAgIC8vIHNlZW1zIGluc3RhbnQhXHJcbiAgICAgICAgLy9cclxuICAgICAgICB2YXIgdGVtcEltYWdlID0gbmV3IEltYWdlKCk7XHJcbiAgICAgICAgdGVtcEltYWdlLnNyYyA9IFwiZGF0YTppbWFnZS9zdmcreG1sLFwiICsgc3ZnU3RyaW5nO1xyXG4gICAgICAgIHZhciBzdmdXaWR0aCA9IHN2Z1NpemUud2lkdGg7XHJcbiAgICAgICAgdmFyIHN2Z0hlaWdodCA9IHN2Z1NpemUuaGVpZ2h0O1xyXG4gICAgICAgIGlmICghc3ZnV2lkdGggfHwgIXN2Z0hlaWdodCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBTVkcgaW1hZ2UgbXVzdCBoYXZlIHdpZHRoIGFuZCBoZWlnaHQgZGVmaW5lZCAoaW4gcGl4ZWxzKSwgY2FudmFzIEFQSSBuZWVkcyB0aGVtLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBTY2FsZSByZWFsV2lkdGggYW5kIHJlYWxIZWlnaHRcclxuICAgICAgICB0aGlzLl93aWR0aCA9IE1hdGgucm91bmQoc3ZnV2lkdGggKiB0aGlzLnNjYWxlKTtcclxuICAgICAgICB0aGlzLl9oZWlnaHQgPSBNYXRoLnJvdW5kKHN2Z0hlaWdodCAqIHRoaXMuc2NhbGUpO1xyXG4gICAgICAgIC8vIENyZWF0ZSBhIGNhbnZhcyBlbGVtZW50XHJcbiAgICAgICAgdmFyIGNhbnZhcyA9IHRoaXMuc291cmNlO1xyXG4gICAgICAgIGNhbnZhcy53aWR0aCA9IHRoaXMuX3dpZHRoO1xyXG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSB0aGlzLl9oZWlnaHQ7XHJcbiAgICAgICAgY2FudmFzLl9waXhpSWQgPSBcImNhbnZhc19cIiArIChNYXRoU2V0dGluZ3NfMS5NYXRoU2V0dGluZ3MudWlkKCkpO1xyXG4gICAgICAgIC8vIERyYXcgdGhlIFN2ZyB0byB0aGUgY2FudmFzXHJcbiAgICAgICAgY2FudmFzXHJcbiAgICAgICAgICAgIC5nZXRDb250ZXh0KCcyZCcpXHJcbiAgICAgICAgICAgIC5kcmF3SW1hZ2UodGVtcEltYWdlLCAwLCAwLCBzdmdXaWR0aCwgc3ZnSGVpZ2h0LCAwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XHJcbiAgICAgICAgdGhpcy5fcmVzb2x2ZSgpO1xyXG4gICAgICAgIHRoaXMuX3Jlc29sdmUgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUeXBlZGVmIGZvciBTaXplIG9iamVjdC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyb2YgUElYSS5yZXNvdXJjZXMuU1ZHUmVzb3VyY2VcclxuICAgICAqIEB0eXBlZGVmIHtvYmplY3R9IFNpemVcclxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB3aWR0aCAtIFdpZHRoIGNvbXBvbmVudFxyXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGhlaWdodCAtIEhlaWdodCBjb21wb25lbnRcclxuICAgICAqL1xyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgc2l6ZSBmcm9tIGFuIHN2ZyBzdHJpbmcgdXNpbmcgcmVnZXhwLlxyXG4gICAgICpcclxuICAgICAqIEBtZXRob2RcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdmdTdHJpbmcgLSBhIHNlcmlhbGl6ZWQgc3ZnIGVsZW1lbnRcclxuICAgICAqIEByZXR1cm4ge1BJWEkucmVzb3VyY2VzLlNWR1Jlc291cmNlLlNpemV9IGltYWdlIGV4dGVuc2lvblxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZ2V0U2l6ZShzdmdTdHJpbmcpIHtcclxuICAgICAgICB2YXIgc2l6ZU1hdGNoID0gU1ZHUmVzb3VyY2UuU1ZHX1NJWkUuZXhlYyhzdmdTdHJpbmcpO1xyXG4gICAgICAgIHZhciBzaXplID0ge307XHJcbiAgICAgICAgaWYgKHNpemVNYXRjaCkge1xyXG4gICAgICAgICAgICBzaXplW3NpemVNYXRjaFsxXV0gPSBNYXRoLnJvdW5kKHBhcnNlRmxvYXQoc2l6ZU1hdGNoWzNdKSk7XHJcbiAgICAgICAgICAgIHNpemVbc2l6ZU1hdGNoWzVdXSA9IE1hdGgucm91bmQocGFyc2VGbG9hdChzaXplTWF0Y2hbN10pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHNpemU7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIERlc3Ryb3lzIHRoaXMgdGV4dHVyZVxyXG4gICAgICogQG92ZXJyaWRlXHJcbiAgICAgKi9cclxuICAgIGRpc3Bvc2UoKSB7XHJcbiAgICAgICAgQmFzZUltYWdlUmVzb3VyY2VfMS5CYXNlSW1hZ2VSZXNvdXJjZS5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuX3Jlc29sdmUgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBVc2VkIHRvIGF1dG8tZGV0ZWN0IHRoZSB0eXBlIG9mIHJlc291cmNlLlxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBwYXJhbSB7Kn0gc291cmNlIC0gVGhlIHNvdXJjZSBvYmplY3RcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBleHRlbnNpb24gLSBUaGUgZXh0ZW5zaW9uIG9mIHNvdXJjZSwgaWYgc2V0XHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyB0ZXN0KHNvdXJjZSwgZXh0ZW5zaW9uKSB7XHJcbiAgICAgICAgLy8gdXJsIGZpbGUgZXh0ZW5zaW9uIGlzIFNWR1xyXG4gICAgICAgIHJldHVybiBleHRlbnNpb24gPT09ICdzdmcnXHJcbiAgICAgICAgICAgIC8vIHNvdXJjZSBpcyBTVkcgZGF0YS11cmlcclxuICAgICAgICAgICAgfHwgKHR5cGVvZiBzb3VyY2UgPT09ICdzdHJpbmcnICYmIHNvdXJjZS5pbmRleE9mKCdkYXRhOmltYWdlL3N2Zyt4bWwnKSA9PT0gMCk7XHJcbiAgICB9XHJcbiAgICA7XHJcbn1cclxuLyoqXHJcbiogUmVnRXhwIGZvciBTVkcgc2l6ZS5cclxuKlxyXG4qIEBzdGF0aWNcclxuKiBAY29uc3RhbnQge1JlZ0V4cHxzdHJpbmd9IFNWR19TSVpFXHJcbiogQG1lbWJlcm9mIFBJWEkucmVzb3VyY2VzLlNWR1Jlc291cmNlXHJcbiogQGV4YW1wbGUgJmx0O3N2ZyB3aWR0aD1cIjEwMFwiIGhlaWdodD1cIjEwMFwiJmd0OyZsdDsvc3ZnJmd0O1xyXG4qL1xyXG5TVkdSZXNvdXJjZS5TVkdfU0laRSA9IC88c3ZnW14+XSooPzpcXHMod2lkdGh8aGVpZ2h0KT0oJ3xcIikoXFxkKig/OlxcLlxcZCspPykoPzpweCk/KCd8XCIpKVtePl0qKD86XFxzKHdpZHRofGhlaWdodCk9KCd8XCIpKFxcZCooPzpcXC5cXGQrKT8pKD86cHgpPygnfFwiKSlbXj5dKj4vaTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBtYXgtbGVuXHJcbmV4cG9ydHMuU1ZHUmVzb3VyY2UgPSBTVkdSZXNvdXJjZTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgVW5pZm9ybUdyb3VwXzEgPSByZXF1aXJlKFwiLi9Vbmlmb3JtR3JvdXBcIik7XHJcbmNvbnN0IFByb2dyYW1fMSA9IHJlcXVpcmUoXCIuL1Byb2dyYW1cIik7XHJcbmNsYXNzIFNoYWRlciB7XHJcbiAgICBjb25zdHJ1Y3Rvcihwcm9ncmFtLCB1bmlmb3Jtcykge1xyXG4gICAgICAgIHRoaXMucHJvZ3JhbSA9IHByb2dyYW07XHJcbiAgICAgICAgLy8gbGV0cyBzZWUgd2hhdHMgYmVlbiBwYXNzZWQgaW5cclxuICAgICAgICAvLyB1bmlmb3JtcyBzaG91bGQgYmUgY29udmVydGVkIHRvIGEgdW5pZm9ybSBncm91cFxyXG4gICAgICAgIGlmICh1bmlmb3Jtcykge1xyXG4gICAgICAgICAgICBpZiAodW5pZm9ybXMgaW5zdGFuY2VvZiBVbmlmb3JtR3JvdXBfMS5Vbmlmb3JtR3JvdXApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudW5pZm9ybUdyb3VwID0gdW5pZm9ybXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnVuaWZvcm1Hcm91cCA9IG5ldyBVbmlmb3JtR3JvdXBfMS5Vbmlmb3JtR3JvdXAodW5pZm9ybXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnVuaWZvcm1Hcm91cCA9IG5ldyBVbmlmb3JtR3JvdXBfMS5Vbmlmb3JtR3JvdXAoe30pO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyB0aW1lIHRvIGJ1aWxkIHNvbWUgZ2V0dGVycyBhbmQgc2V0dGVycyFcclxuICAgICAgICAvLyBJIGd1ZXNzIGRvd24gdGhlIGxpbmUgdGhpcyBjb3VsZCBzb3J0IG9mIGdlbmVyYXRlIGFuIGluc3RydWN0aW9uIGxpc3QgcmF0aGVyIHRoYW4gdXNlIGRpcnR5IGlkcz9cclxuICAgICAgICAvLyBkb2VzIHRoZSB0cmljayBmb3Igbm93IHRob3VnaCFcclxuICAgICAgICBmb3IgKHZhciBpIGluIHByb2dyYW0udW5pZm9ybURhdGEpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMudW5pZm9ybUdyb3VwLnVuaWZvcm1zW2ldIGluc3RhbmNlb2YgQXJyYXkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudW5pZm9ybUdyb3VwLnVuaWZvcm1zW2ldID0gbmV3IEZsb2F0MzJBcnJheSh0aGlzLnVuaWZvcm1Hcm91cC51bmlmb3Jtc1tpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBUT0RPIG1vdmUgdG8gc2hhZGVyIHN5c3RlbS4uXHJcbiAgICBjaGVja1VuaWZvcm1FeGlzdHMobmFtZSwgZ3JvdXApIHtcclxuICAgICAgICBpZiAoZ3JvdXAudW5pZm9ybXNbbmFtZV0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAodmFyIGkgaW4gZ3JvdXAudW5pZm9ybXMpIHtcclxuICAgICAgICAgICAgdmFyIHVuaWZvcm0gPSBncm91cC51bmlmb3Jtc1tpXTtcclxuICAgICAgICAgICAgaWYgKHVuaWZvcm0uZ3JvdXApIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNoZWNrVW5pZm9ybUV4aXN0cyhuYW1lLCB1bmlmb3JtKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIGRlc3Ryb3koKSB7XHJcbiAgICAgICAgLy8gdXNhZ2UgY291bnQgb24gcHJvZ3JhbXM/XHJcbiAgICAgICAgLy8gcmVtb3ZlIGlmIG5vdCB1c2VkIVxyXG4gICAgICAgIHRoaXMudW5pZm9ybUdyb3VwID0gbnVsbDtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogU2hhZGVyIHVuaWZvcm0gdmFsdWVzLCBzaG9ydGN1dCBmb3IgYHVuaWZvcm1Hcm91cC51bmlmb3Jtc2BcclxuICAgICAqIEByZWFkb25seVxyXG4gICAgICogQG1lbWJlciB7b2JqZWN0fVxyXG4gICAgICovXHJcbiAgICBnZXQgdW5pZm9ybXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudW5pZm9ybUdyb3VwLnVuaWZvcm1zO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBIHNob3J0IGhhbmQgZnVuY3Rpb24gdG8gY3JlYXRlIGEgc2hhZGVyIGJhc2VkIG9mIGEgdmVydGV4IGFuZCBmcmFnbWVudCBzaGFkZXJcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3ZlcnRleFNyY10gLSBUaGUgc291cmNlIG9mIHRoZSB2ZXJ0ZXggc2hhZGVyLlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtmcmFnbWVudFNyY10gLSBUaGUgc291cmNlIG9mIHRoZSBmcmFnbWVudCBzaGFkZXIuXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW3VuaWZvcm1zXSAtIEN1c3RvbSB1bmlmb3JtcyB0byB1c2UgdG8gYXVnbWVudCB0aGUgYnVpbHQtaW4gb25lcy5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7UElYSS5TaGFkZXJ9IGFuIHNoaW55IG5ldyBQaXhpIHNoYWRlciFcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGZyb20odmVydGV4U3JjLCBmcmFnbWVudFNyYywgdW5pZm9ybXMpIHtcclxuICAgICAgICB2YXIgcHJvZ3JhbSA9IFByb2dyYW1fMS5Qcm9ncmFtLmZyb20odmVydGV4U3JjLCBmcmFnbWVudFNyYyk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBTaGFkZXIocHJvZ3JhbSwgdW5pZm9ybXMpO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEBwYXJhbSBnbCB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBUaGUgY3VycmVudCBXZWJHTCBjb250ZXh0IHtXZWJHTFByb2dyYW19XHJcbiAqIEBwYXJhbSB0eXBlIHtOdW1iZXJ9IHRoZSB0eXBlLCBjYW4gYmUgZWl0aGVyIFZFUlRFWF9TSEFERVIgb3IgRlJBR01FTlRfU0hBREVSXHJcbiAqIEBwYXJhbSB2ZXJ0ZXhTcmMge3N0cmluZ3xzdHJpbmdbXX0gVGhlIHZlcnRleCBzaGFkZXIgc291cmNlIGFzIGFuIGFycmF5IG9mIHN0cmluZ3MuXHJcbiAqIEByZXR1cm4ge1dlYkdMU2hhZGVyfSB0aGUgc2hhZGVyXHJcbiAqL1xyXG4gICAgc3RhdGljIGNvbXBpbGVTaGFkZXIoZ2wsIHR5cGUsIHNyYykge1xyXG4gICAgICAgIHZhciBzaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIodHlwZSk7XHJcbiAgICAgICAgZ2wuc2hhZGVyU291cmNlKHNoYWRlciwgc3JjKTtcclxuICAgICAgICBnbC5jb21waWxlU2hhZGVyKHNoYWRlcik7XHJcbiAgICAgICAgaWYgKCFnbC5nZXRTaGFkZXJQYXJhbWV0ZXIoc2hhZGVyLCBnbC5DT01QSUxFX1NUQVRVUykpIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKHNyYyk7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZ2wuZ2V0U2hhZGVySW5mb0xvZyhzaGFkZXIpKTtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzaGFkZXI7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5TaGFkZXIgPSBTaGFkZXI7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IFN5c3RlbV8xID0gcmVxdWlyZShcIi4vU3lzdGVtXCIpO1xyXG5jb25zdCBQcm9ncmFtXzEgPSByZXF1aXJlKFwiLi9Qcm9ncmFtXCIpO1xyXG5jb25zdCBHTFByb2dyYW1fMSA9IHJlcXVpcmUoXCIuL0dMUHJvZ3JhbVwiKTtcclxuY29uc3QgU3RhdGVTeXN0ZW1fMSA9IHJlcXVpcmUoXCIuL1N0YXRlU3lzdGVtXCIpO1xyXG5jb25zdCBVdGlsc1NldHRpbmdzXzEgPSByZXF1aXJlKFwiLi9VdGlsc1NldHRpbmdzXCIpO1xyXG5jb25zdCBXZWJHTFNldHRpbmdzXzEgPSByZXF1aXJlKFwiLi9XZWJHTFNldHRpbmdzXCIpO1xyXG5jbGFzcyBTaGFkZXJTeXN0ZW0gZXh0ZW5kcyBTeXN0ZW1fMS5TeXN0ZW0ge1xyXG4gICAgY29uc3RydWN0b3IocmVuZGVyZXIpIHtcclxuICAgICAgICBzdXBlcihyZW5kZXJlcik7XHJcbiAgICAgICAgLy8gVmFsaWRhdGlvbiBjaGVjayB0aGF0IHRoaXMgZW52aXJvbm1lbnQgc3VwcG9ydCBgbmV3IEZ1bmN0aW9uYFxyXG4gICAgICAgIHRoaXMuc3lzdGVtQ2hlY2soKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgY3VycmVudCBXZWJHTCByZW5kZXJpbmcgY29udGV4dFxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQG1lbWJlciB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuZ2wgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuc2hhZGVyID0gbnVsbDtcclxuICAgICAgICB0aGlzLnByb2dyYW0gPSBudWxsO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENhY2hlIHRvIGhvbGRzIHRoZSBnZW5lcmF0ZWQgZnVuY3Rpb25zLiBTdG9yZWQgYWdhaW5zdCBVbmlmb3JtT2JqZWN0cyB1bmlxdWUgc2lnbmF0dXJlXHJcbiAgICAgICAgICogQHR5cGUge09iamVjdH1cclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuY2FjaGUgPSB7fTtcclxuICAgICAgICB0aGlzLmlkID0gU3RhdGVTeXN0ZW1fMS5TdGF0ZVN5c3RlbS5VSUQkNCsrO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBPdmVycmlkZWFibGUgZnVuY3Rpb24gYnkgYEBwaXhpL3Vuc2FmZS1ldmFsYCB0byBzaWxlbmNlXHJcbiAgICAgKiB0aHJvd2luZyBhbiBlcnJvciBpZiBwbGF0Zm9ybSBkb2Vzbid0IHN1cHBvcnQgdW5zYWZlLWV2YWxzLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHN5c3RlbUNoZWNrKCkge1xyXG4gICAgICAgIGlmICghVXRpbHNTZXR0aW5nc18xLlV0aWxzU2V0dGluZ3MudW5zYWZlRXZhbFN1cHBvcnRlZCgpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ3VycmVudCBlbnZpcm9ubWVudCBkb2VzIG5vdCBhbGxvdyB1bnNhZmUtZXZhbCwgJ1xyXG4gICAgICAgICAgICAgICAgKyAncGxlYXNlIHVzZSBAcGl4aS91bnNhZmUtZXZhbCBtb2R1bGUgdG8gZW5hYmxlIHN1cHBvcnQuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgY29udGV4dENoYW5nZShnbCkge1xyXG4gICAgICAgIHRoaXMuZ2wgPSBnbDtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQ2hhbmdlcyB0aGUgY3VycmVudCBzaGFkZXIgdG8gdGhlIG9uZSBnaXZlbiBpbiBwYXJhbWV0ZXJcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1BJWEkuU2hhZGVyfSBzaGFkZXIgLSB0aGUgbmV3IHNoYWRlclxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBkb250U3luYyAtIGZhbHNlIGlmIHRoZSBzaGFkZXIgc2hvdWxkIGF1dG9tYXRpY2FsbHkgc3luYyBpdHMgdW5pZm9ybXMuXHJcbiAgICAgKiBAcmV0dXJucyB7UElYSS5HTFByb2dyYW19IHRoZSBnbFByb2dyYW0gdGhhdCBiZWxvbmdzIHRvIHRoZSBzaGFkZXIuXHJcbiAgICAgKi9cclxuICAgIGJpbmQoc2hhZGVyLCBkb250U3luYyA9IGZhbHNlKSB7XHJcbiAgICAgICAgc2hhZGVyLnVuaWZvcm1zLmdsb2JhbHMgPSB0aGlzLnJlbmRlcmVyLmdsb2JhbFVuaWZvcm1zO1xyXG4gICAgICAgIHZhciBwcm9ncmFtID0gc2hhZGVyLnByb2dyYW07XHJcbiAgICAgICAgdmFyIGdsUHJvZ3JhbSA9IHByb2dyYW0uZ2xQcm9ncmFtc1t0aGlzLnJlbmRlcmVyLkNPTlRFWFRfVUlEXSB8fCB0aGlzLmdlbmVyYXRlU2hhZGVyKHNoYWRlcik7XHJcbiAgICAgICAgdGhpcy5zaGFkZXIgPSBzaGFkZXI7XHJcbiAgICAgICAgLy8gVE9ETyAtIHNvbWUgY3VycmVudCBQaXhpIHBsdWdpbnMgYnlwYXNzIHRoaXMuLiBzbyBpdCBub3Qgc2FmZSB0byB1c2UgeWV0Li5cclxuICAgICAgICBpZiAodGhpcy5wcm9ncmFtICE9PSBwcm9ncmFtKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHJvZ3JhbSA9IHByb2dyYW07XHJcbiAgICAgICAgICAgIHRoaXMuZ2wudXNlUHJvZ3JhbShnbFByb2dyYW0ucHJvZ3JhbSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghZG9udFN5bmMpIHtcclxuICAgICAgICAgICAgdGhpcy5zeW5jVW5pZm9ybUdyb3VwKHNoYWRlci51bmlmb3JtR3JvdXApO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZ2xQcm9ncmFtO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBVcGxvYWRzIHRoZSB1bmlmb3JtcyB2YWx1ZXMgdG8gdGhlIGN1cnJlbnRseSBib3VuZCBzaGFkZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHVuaWZvcm1zIC0gdGhlIHVuaWZvcm1zIHZhbHVlcyB0aGF0IGJlIGFwcGxpZWQgdG8gdGhlIGN1cnJlbnQgc2hhZGVyXHJcbiAgICAgKi9cclxuICAgIHNldFVuaWZvcm1zKHVuaWZvcm1zKSB7XHJcbiAgICAgICAgdmFyIHNoYWRlciA9IHRoaXMuc2hhZGVyLnByb2dyYW07XHJcbiAgICAgICAgdmFyIGdsUHJvZ3JhbSA9IHNoYWRlci5nbFByb2dyYW1zW3RoaXMucmVuZGVyZXIuQ09OVEVYVF9VSURdO1xyXG4gICAgICAgIHNoYWRlci5zeW5jVW5pZm9ybXMoZ2xQcm9ncmFtLnVuaWZvcm1EYXRhLCB1bmlmb3JtcywgdGhpcy5yZW5kZXJlcik7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICBzeW5jVW5pZm9ybUdyb3VwKGdyb3VwKSB7XHJcbiAgICAgICAgdmFyIGdsUHJvZ3JhbSA9IHRoaXMuZ2V0Z2xQcm9ncmFtKCk7XHJcbiAgICAgICAgaWYgKCFncm91cC5zdGF0aWMgfHwgZ3JvdXAuZGlydHlJZCAhPT0gZ2xQcm9ncmFtLnVuaWZvcm1Hcm91cHNbZ3JvdXAuaWRdKSB7XHJcbiAgICAgICAgICAgIGdsUHJvZ3JhbS51bmlmb3JtR3JvdXBzW2dyb3VwLmlkXSA9IGdyb3VwLmRpcnR5SWQ7XHJcbiAgICAgICAgICAgIHRoaXMuc3luY1VuaWZvcm1zKGdyb3VwLCBnbFByb2dyYW0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogT3ZlcnJpZGVhYmxlIGJ5IHRoZSBAcGl4aS91bnNhZmUtZXZhbCBwYWNrYWdlIHRvIHVzZSBzdGF0aWNcclxuICAgICAqIHN5bmNVbmZvcm1zIGluc3RlYWQuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgc3luY1VuaWZvcm1zKGdyb3VwLCBnbFByb2dyYW0pIHtcclxuICAgICAgICB2YXIgc3luY0Z1bmMgPSBncm91cC5zeW5jVW5pZm9ybXNbdGhpcy5zaGFkZXIucHJvZ3JhbS5pZF0gfHwgdGhpcy5jcmVhdGVTeW5jR3JvdXBzKGdyb3VwKTtcclxuICAgICAgICBzeW5jRnVuYyhnbFByb2dyYW0udW5pZm9ybURhdGEsIGdyb3VwLnVuaWZvcm1zLCB0aGlzLnJlbmRlcmVyKTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIGNyZWF0ZVN5bmNHcm91cHMoZ3JvdXApIHtcclxuICAgICAgICB2YXIgaWQgPSB0aGlzLmdldFNpZ25hdHVyZShncm91cCwgdGhpcy5zaGFkZXIucHJvZ3JhbS51bmlmb3JtRGF0YSk7XHJcbiAgICAgICAgaWYgKCF0aGlzLmNhY2hlW2lkXSkge1xyXG4gICAgICAgICAgICB0aGlzLmNhY2hlW2lkXSA9IFdlYkdMU2V0dGluZ3NfMS5XZWJHTFNldHRpbmdzLmdlbmVyYXRlVW5pZm9ybXNTeW5jKGdyb3VwLCB0aGlzLnNoYWRlci5wcm9ncmFtLnVuaWZvcm1EYXRhKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZ3JvdXAuc3luY1VuaWZvcm1zW3RoaXMuc2hhZGVyLnByb2dyYW0uaWRdID0gdGhpcy5jYWNoZVtpZF07XHJcbiAgICAgICAgcmV0dXJuIGdyb3VwLnN5bmNVbmlmb3Jtc1t0aGlzLnNoYWRlci5wcm9ncmFtLmlkXTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogVGFrZXMgYSB1bmlmb3JtIGdyb3VwIGFuZCBkYXRhIGFuZCBnZW5lcmF0ZXMgYSB1bmlxdWUgc2lnbmF0dXJlIGZvciB0aGVtLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7UElYSS5Vbmlmb3JtR3JvdXB9IGdyb3VwIHRoZSB1bmlmb3JtIGdyb3VwIHRvIGdldCBzaWduYXR1cmUgb2ZcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB1bmlmb3JtRGF0YSB1bmlmb3JtIGluZm9ybWF0aW9uIGdlbmVyYXRlZCBieSB0aGUgc2hhZGVyXHJcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBVbmlxdWUgc2lnbmF0dXJlIG9mIHRoZSB1bmlmb3JtIGdyb3VwXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBnZXRTaWduYXR1cmUoZ3JvdXAsIHVuaWZvcm1EYXRhKSB7XHJcbiAgICAgICAgdmFyIHVuaWZvcm1zID0gZ3JvdXAudW5pZm9ybXM7XHJcbiAgICAgICAgdmFyIHN0cmluZ3MgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBpIGluIHVuaWZvcm1zKSB7XHJcbiAgICAgICAgICAgIHN0cmluZ3MucHVzaChpKTtcclxuICAgICAgICAgICAgaWYgKHVuaWZvcm1EYXRhW2ldKSB7XHJcbiAgICAgICAgICAgICAgICBzdHJpbmdzLnB1c2godW5pZm9ybURhdGFbaV0udHlwZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHN0cmluZ3Muam9pbignLScpO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSB1bmRlcmx5aW5nIEdMU2hhZGUgcm9mIHRoZSBjdXJyZW50bHkgYm91bmQgc2hhZGVyLlxyXG4gICAgICogVGhpcyBjYW4gYmUgaGFuZHkgZm9yIHdoZW4geW91IHRvIGhhdmUgYSBsaXR0bGUgbW9yZSBjb250cm9sIG92ZXIgdGhlIHNldHRpbmcgb2YgeW91ciB1bmlmb3Jtcy5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIHtQSVhJLkdMUHJvZ3JhbX0gdGhlIGdsUHJvZ3JhbSBmb3IgdGhlIGN1cnJlbnRseSBib3VuZCBTaGFkZXIgZm9yIHRoaXMgY29udGV4dFxyXG4gICAgICovXHJcbiAgICBnZXRnbFByb2dyYW0oKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuc2hhZGVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNoYWRlci5wcm9ncmFtLmdsUHJvZ3JhbXNbdGhpcy5yZW5kZXJlci5DT05URVhUX1VJRF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBHZW5lcmF0ZXMgYSBnbFByb2dyYW0gdmVyc2lvbiBvZiB0aGUgU2hhZGVyIHByb3ZpZGVkLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge1BJWEkuU2hhZGVyfSBzaGFkZXIgdGhlIHNoYWRlciB0aGF0IHRoZSBnbFByb2dyYW0gd2lsbCBiZSBiYXNlZCBvbi5cclxuICAgICAqIEByZXR1cm4ge1BJWEkuR0xQcm9ncmFtfSBBIHNoaW55IG5ldyBnbFByb2dyYW0hXHJcbiAgICAgKi9cclxuICAgIGdlbmVyYXRlU2hhZGVyKHNoYWRlcikge1xyXG4gICAgICAgIHZhciBnbCA9IHRoaXMuZ2w7XHJcbiAgICAgICAgdmFyIHByb2dyYW0gPSBzaGFkZXIucHJvZ3JhbTtcclxuICAgICAgICB2YXIgYXR0cmliTWFwID0ge307XHJcbiAgICAgICAgZm9yICh2YXIgaSBpbiBwcm9ncmFtLmF0dHJpYnV0ZURhdGEpIHtcclxuICAgICAgICAgICAgYXR0cmliTWFwW2ldID0gcHJvZ3JhbS5hdHRyaWJ1dGVEYXRhW2ldLmxvY2F0aW9uO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgc2hhZGVyUHJvZ3JhbSA9IFByb2dyYW1fMS5Qcm9ncmFtLmNvbXBpbGVQcm9ncmFtKGdsLCBwcm9ncmFtLnZlcnRleFNyYywgcHJvZ3JhbS5mcmFnbWVudFNyYywgYXR0cmliTWFwKTtcclxuICAgICAgICB2YXIgdW5pZm9ybURhdGEgPSB7fTtcclxuICAgICAgICBmb3IgKHZhciBpJDEgaW4gcHJvZ3JhbS51bmlmb3JtRGF0YSkge1xyXG4gICAgICAgICAgICB2YXIgZGF0YSA9IHByb2dyYW0udW5pZm9ybURhdGFbaSQxXTtcclxuICAgICAgICAgICAgdW5pZm9ybURhdGFbaSQxXSA9IHtcclxuICAgICAgICAgICAgICAgIGxvY2F0aW9uOiBnbC5nZXRVbmlmb3JtTG9jYXRpb24oc2hhZGVyUHJvZ3JhbSwgaSQxKSxcclxuICAgICAgICAgICAgICAgIHZhbHVlOiBXZWJHTFNldHRpbmdzXzEuV2ViR0xTZXR0aW5ncy5kZWZhdWx0VmFsdWUoZGF0YS50eXBlLCBkYXRhLnNpemUpLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgZ2xQcm9ncmFtID0gbmV3IEdMUHJvZ3JhbV8xLkdMUHJvZ3JhbShzaGFkZXJQcm9ncmFtLCB1bmlmb3JtRGF0YSk7XHJcbiAgICAgICAgcHJvZ3JhbS5nbFByb2dyYW1zW3RoaXMucmVuZGVyZXIuQ09OVEVYVF9VSURdID0gZ2xQcm9ncmFtO1xyXG4gICAgICAgIHJldHVybiBnbFByb2dyYW07XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFJlc2V0cyBTaGFkZXJTeXN0ZW0gc3RhdGUsIGRvZXMgbm90IGFmZmVjdCBXZWJHTCBzdGF0ZVxyXG4gICAgICovXHJcbiAgICByZXNldCgpIHtcclxuICAgICAgICB0aGlzLnByb2dyYW0gPSBudWxsO1xyXG4gICAgICAgIHRoaXMuc2hhZGVyID0gbnVsbDtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogRGVzdHJveXMgdGhpcyBTeXN0ZW0gYW5kIHJlbW92ZXMgYWxsIGl0cyB0ZXh0dXJlc1xyXG4gICAgICovXHJcbiAgICBkZXN0cm95KCkge1xyXG4gICAgICAgIC8vIFRPRE8gaW1wbGVtZW50IGRlc3Ryb3kgbWV0aG9kIGZvciBTaGFkZXJTeXN0ZW1cclxuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IHRydWU7XHJcbiAgICB9XHJcbiAgICA7XHJcbn1cclxuZXhwb3J0cy5TaGFkZXJTeXN0ZW0gPSBTaGFkZXJTeXN0ZW07XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNsYXNzIFNoYXBlU2V0dGluZ3Mge1xyXG59XHJcbi8qKlxyXG4qIENvbnN0YW50cyB0aGF0IGlkZW50aWZ5IHNoYXBlcywgbWFpbmx5IHRvIHByZXZlbnQgYGluc3RhbmNlb2ZgIGNhbGxzLlxyXG4qXHJcbiogQHN0YXRpY1xyXG4qIEBjb25zdGFudFxyXG4qIEBuYW1lIFNIQVBFU1xyXG4qIEBtZW1iZXJvZiBQSVhJXHJcbiogQHR5cGUge29iamVjdH1cclxuKiBAcHJvcGVydHkge251bWJlcn0gUE9MWSBQb2x5Z29uXHJcbiogQHByb3BlcnR5IHtudW1iZXJ9IFJFQ1QgUmVjdGFuZ2xlXHJcbiogQHByb3BlcnR5IHtudW1iZXJ9IENJUkMgQ2lyY2xlXHJcbiogQHByb3BlcnR5IHtudW1iZXJ9IEVMSVAgRWxsaXBzZVxyXG4qIEBwcm9wZXJ0eSB7bnVtYmVyfSBSUkVDIFJvdW5kZWQgUmVjdGFuZ2xlXHJcbiovXHJcblNoYXBlU2V0dGluZ3MuU0hBUEVTID0ge1xyXG4gICAgUE9MWTogMCxcclxuICAgIFJFQ1Q6IDEsXHJcbiAgICBDSVJDOiAyLFxyXG4gICAgRUxJUDogMyxcclxuICAgIFJSRUM6IDQsXHJcbn07XHJcbmV4cG9ydHMuU2hhcGVTZXR0aW5ncyA9IFNoYXBlU2V0dGluZ3M7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IE1lc2hfMSA9IHJlcXVpcmUoXCIuL01lc2hcIik7XHJcbmNvbnN0IFJvcGVHZW9tZXRyeV8xID0gcmVxdWlyZShcIi4vUm9wZUdlb21ldHJ5XCIpO1xyXG5jb25zdCBNZXNoTWF0ZXJpYWxfMSA9IHJlcXVpcmUoXCIuL01lc2hNYXRlcmlhbFwiKTtcclxuY2xhc3MgU2ltcGxlUm9wZSBleHRlbmRzIE1lc2hfMS5NZXNoIHtcclxuICAgIGNvbnN0cnVjdG9yKHRleHR1cmUsIHBvaW50cykge1xyXG4gICAgICAgIHZhciByb3BlR2VvbWV0cnkgPSBuZXcgUm9wZUdlb21ldHJ5XzEuUm9wZUdlb21ldHJ5KHRleHR1cmUuaGVpZ2h0LCBwb2ludHMpO1xyXG4gICAgICAgIHZhciBtZXNoTWF0ZXJpYWwgPSBuZXcgTWVzaE1hdGVyaWFsXzEuTWVzaE1hdGVyaWFsKHRleHR1cmUpO1xyXG4gICAgICAgIHN1cGVyKHJvcGVHZW9tZXRyeSwgbWVzaE1hdGVyaWFsKTtcclxuICAgICAgICB0aGlzLmF1dG9VcGRhdGUgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgX3JlbmRlcihyZW5kZXJlcikge1xyXG4gICAgICAgIGlmICh0aGlzLmF1dG9VcGRhdGVcclxuICAgICAgICAgICAgfHwgdGhpcy5nZW9tZXRyeS53aWR0aCAhPT0gdGhpcy5zaGFkZXIudGV4dHVyZS5oZWlnaHQpIHtcclxuICAgICAgICAgICAgdGhpcy5nZW9tZXRyeS53aWR0aCA9IHRoaXMuc2hhZGVyLnRleHR1cmUuaGVpZ2h0O1xyXG4gICAgICAgICAgICB0aGlzLmdlb21ldHJ5LnVwZGF0ZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzdXBlci5fcmVuZGVyKHJlbmRlcmVyKTtcclxuICAgIH1cclxuICAgIDtcclxufVxyXG5leHBvcnRzLlNpbXBsZVJvcGUgPSBTaW1wbGVSb3BlO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBDb250YWluZXJfMSA9IHJlcXVpcmUoXCIuL0NvbnRhaW5lclwiKTtcclxuY29uc3QgT2JzZXJ2YWJsZVBvaW50XzEgPSByZXF1aXJlKFwiLi9PYnNlcnZhYmxlUG9pbnRcIik7XHJcbmNvbnN0IFRleHR1cmVfMSA9IHJlcXVpcmUoXCIuL1RleHR1cmVcIik7XHJcbmNvbnN0IFJlY3RhbmdsZV8xID0gcmVxdWlyZShcIi4vUmVjdGFuZ2xlXCIpO1xyXG5jb25zdCBQb2ludF8xID0gcmVxdWlyZShcIi4vUG9pbnRcIik7XHJcbmNvbnN0IEJsZW5kTW9kZXNTZXR0aW5nc18xID0gcmVxdWlyZShcIi4vQmxlbmRNb2Rlc1NldHRpbmdzXCIpO1xyXG5jb25zdCBEaXNwbGF5U2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL0Rpc3BsYXlTZXR0aW5nc1wiKTtcclxuY29uc3QgTWF0aFNldHRpbmdzXzEgPSByZXF1aXJlKFwiLi9NYXRoU2V0dGluZ3NcIik7XHJcbmNvbnN0IExvZ2dlcl8xID0gcmVxdWlyZShcIi4vTG9nZ2VyXCIpO1xyXG5jbGFzcyBTcHJpdGUgZXh0ZW5kcyBDb250YWluZXJfMS5Db250YWluZXIge1xyXG4gICAgY29uc3RydWN0b3IodGV4dHVyZSkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogV2hlbiB0aGUgdGV4dHVyZSBpcyB1cGRhdGVkLCB0aGlzIGV2ZW50IHdpbGwgZmlyZSB0byB1cGRhdGUgdGhlIHNjYWxlIGFuZCBmcmFtZVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLl9vblRleHR1cmVVcGRhdGUgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIExvZ2dlcl8xLnRyYWNlKFwiU3ByaXRlIHVwZGF0ZVwiKTtcclxuICAgICAgICAgICAgdGhpcy5fdGV4dHVyZUlEID0gLTE7XHJcbiAgICAgICAgICAgIHRoaXMuX3RleHR1cmVUcmltbWVkSUQgPSAtMTtcclxuICAgICAgICAgICAgdGhpcy5jYWNoZWRUaW50ID0gMHhGRkZGRkY7XHJcbiAgICAgICAgICAgIC8vIHJldmVhbCh0aGlzLl90ZXh0dXJlKVxyXG4gICAgICAgICAgICB0aGlzLnV2cyA9IHRoaXMuX3RleHR1cmUuX3V2cy51dnNGbG9hdDMyO1xyXG4gICAgICAgICAgICAvLyBzbyBpZiBfd2lkdGggaXMgMCB0aGVuIHdpZHRoIHdhcyBub3Qgc2V0Li5cclxuICAgICAgICAgICAgaWYgKHRoaXMuX3dpZHRoKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNjYWxlLnggPSBNYXRoU2V0dGluZ3NfMS5NYXRoU2V0dGluZ3Muc2lnbih0aGlzLnNjYWxlLngpICogdGhpcy5fd2lkdGggLyB0aGlzLl90ZXh0dXJlLm9yaWcud2lkdGg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuX2hlaWdodCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zY2FsZS55ID0gTWF0aFNldHRpbmdzXzEuTWF0aFNldHRpbmdzLnNpZ24odGhpcy5zY2FsZS55KSAqIHRoaXMuX2hlaWdodCAvIHRoaXMuX3RleHR1cmUub3JpZy5oZWlnaHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBhbmNob3Igc2V0cyB0aGUgb3JpZ2luIHBvaW50IG9mIHRoZSB0ZXh0dXJlLlxyXG4gICAgICAgICAqIFRoZSBkZWZhdWx0IGlzIDAsMCBvciB0YWtlbiBmcm9tIHRoZSB7QGxpbmsgUElYSS5UZXh0dXJlI2RlZmF1bHRBbmNob3J8VGV4dHVyZX1cclxuICAgICAgICAgKiBwYXNzZWQgdG8gdGhlIGNvbnN0cnVjdG9yLiBBIHZhbHVlIG9mIDAsMCBtZWFucyB0aGUgdGV4dHVyZSdzIG9yaWdpbiBpcyB0aGUgdG9wIGxlZnQuXHJcbiAgICAgICAgICogU2V0dGluZyB0aGUgYW5jaG9yIHRvIDAuNSwwLjUgbWVhbnMgdGhlIHRleHR1cmUncyBvcmlnaW4gaXMgY2VudGVyZWQuXHJcbiAgICAgICAgICogU2V0dGluZyB0aGUgYW5jaG9yIHRvIDEsMSB3b3VsZCBtZWFuIHRoZSB0ZXh0dXJlJ3Mgb3JpZ2luIHBvaW50IHdpbGwgYmUgdGhlIGJvdHRvbSByaWdodCBjb3JuZXIuXHJcbiAgICAgICAgICogTm90ZTogVXBkYXRpbmcgdGhlIHtAbGluayBQSVhJLlRleHR1cmUjZGVmYXVsdEFuY2hvcn0gYWZ0ZXIgYSBUZXh0dXJlIGlzXHJcbiAgICAgICAgICogY3JlYXRlZCBkb2VzIF9ub3RfIHVwZGF0ZSB0aGUgU3ByaXRlJ3MgYW5jaG9yIHZhbHVlcy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuT2JzZXJ2YWJsZVBvaW50fVxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5fYW5jaG9yID0gbmV3IE9ic2VydmFibGVQb2ludF8xLk9ic2VydmFibGVQb2ludCh0aGlzLl9vbkFuY2hvclVwZGF0ZSwgdGhpcywgKHRleHR1cmUgPyB0ZXh0dXJlLmRlZmF1bHRBbmNob3IueCA6IDApLCAodGV4dHVyZSA/IHRleHR1cmUuZGVmYXVsdEFuY2hvci55IDogMCkpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSB0ZXh0dXJlIHRoYXQgdGhlIHNwcml0ZSBpcyB1c2luZ1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLlRleHR1cmV9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5fdGV4dHVyZSA9IG51bGw7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIHdpZHRoIG9mIHRoZSBzcHJpdGUgKHRoaXMgaXMgaW5pdGlhbGx5IHNldCBieSB0aGUgdGV4dHVyZSlcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuX3dpZHRoID0gMDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgaGVpZ2h0IG9mIHRoZSBzcHJpdGUgKHRoaXMgaXMgaW5pdGlhbGx5IHNldCBieSB0aGUgdGV4dHVyZSlcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuX2hlaWdodCA9IDA7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIHRpbnQgYXBwbGllZCB0byB0aGUgc3ByaXRlLiBUaGlzIGlzIGEgaGV4IHZhbHVlLiBBIHZhbHVlIG9mIDB4RkZGRkZGIHdpbGwgcmVtb3ZlIGFueSB0aW50IGVmZmVjdC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICAgICAqIEBkZWZhdWx0IDB4RkZGRkZGXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5fdGludCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5fdGludFJHQiA9IG51bGw7XHJcbiAgICAgICAgdGhpcy50aW50ID0gMHhGRkZGRkY7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGJsZW5kIG1vZGUgdG8gYmUgYXBwbGllZCB0byB0aGUgc3ByaXRlLiBBcHBseSBhIHZhbHVlIG9mIGBQSVhJLkJMRU5EX01PREVTLk5PUk1BTGAgdG8gcmVzZXQgdGhlIGJsZW5kIG1vZGUuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgICAgICogQGRlZmF1bHQgUElYSS5CTEVORF9NT0RFUy5OT1JNQUxcclxuICAgICAgICAgKiBAc2VlIFBJWEkuQkxFTkRfTU9ERVNcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmJsZW5kTW9kZSA9IEJsZW5kTW9kZXNTZXR0aW5nc18xLkJsZW5kTW9kZXNTZXR0aW5ncy5CTEVORF9NT0RFUy5OT1JNQUw7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIHNoYWRlciB0aGF0IHdpbGwgYmUgdXNlZCB0byByZW5kZXIgdGhlIHNwcml0ZS4gU2V0IHRvIG51bGwgdG8gcmVtb3ZlIGEgY3VycmVudCBzaGFkZXIuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLkZpbHRlcnxQSVhJLlNoYWRlcn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnNoYWRlciA9IG51bGw7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQW4gaW50ZXJuYWwgY2FjaGVkIHZhbHVlIG9mIHRoZSB0aW50LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgICAgICogQGRlZmF1bHQgMHhGRkZGRkZcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmNhY2hlZFRpbnQgPSAweEZGRkZGRjtcclxuICAgICAgICB0aGlzLnV2cyA9IG51bGw7XHJcbiAgICAgICAgLy8gY2FsbCB0ZXh0dXJlIHNldHRlclxyXG4gICAgICAgIHRoaXMudGV4dHVyZSA9IHRleHR1cmUgfHwgVGV4dHVyZV8xLlRleHR1cmUuRU1QVFk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogdGhpcyBpcyB1c2VkIHRvIHN0b3JlIHRoZSB2ZXJ0ZXggZGF0YSBvZiB0aGUgc3ByaXRlIChiYXNpY2FsbHkgYSBxdWFkKVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKiBAbWVtYmVyIHtGbG9hdDMyQXJyYXl9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy52ZXJ0ZXhEYXRhID0gbmV3IEZsb2F0MzJBcnJheSg4KTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGlzIGlzIHVzZWQgdG8gY2FsY3VsYXRlIHRoZSBib3VuZHMgb2YgdGhlIG9iamVjdCBJRiBpdCBpcyBhIHRyaW1tZWQgc3ByaXRlXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqIEBtZW1iZXIge0Zsb2F0MzJBcnJheX1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnZlcnRleFRyaW1tZWREYXRhID0gbnVsbDtcclxuICAgICAgICB0aGlzLl90cmFuc2Zvcm1JRCA9IC0xO1xyXG4gICAgICAgIHRoaXMuX3RleHR1cmVJRCA9IC0xO1xyXG4gICAgICAgIHRoaXMuX3RyYW5zZm9ybVRyaW1tZWRJRCA9IC0xO1xyXG4gICAgICAgIHRoaXMuX3RleHR1cmVUcmltbWVkSUQgPSAtMTtcclxuICAgICAgICAvLyBCYXRjaGFibGUgc3R1ZmYuLlxyXG4gICAgICAgIC8vIFRPRE8gY291bGQgbWFrZSB0aGlzIGEgbWl4aW4/XHJcbiAgICAgICAgdGhpcy5pbmRpY2VzID0gU3ByaXRlLmluZGljZXM7XHJcbiAgICAgICAgdGhpcy5zaXplID0gNDtcclxuICAgICAgICB0aGlzLnN0YXJ0ID0gMDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBQbHVnaW4gdGhhdCBpcyByZXNwb25zaWJsZSBmb3IgcmVuZGVyaW5nIHRoaXMgZWxlbWVudC5cclxuICAgICAgICAgKiBBbGxvd3MgdG8gY3VzdG9taXplIHRoZSByZW5kZXJpbmcgcHJvY2VzcyB3aXRob3V0IG92ZXJyaWRpbmcgJ19yZW5kZXInICYgJ19yZW5kZXJDYW52YXMnIG1ldGhvZHMuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAbWVtYmVyIHtzdHJpbmd9XHJcbiAgICAgICAgICogQGRlZmF1bHQgJ3Nwcml0ZSdcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnBsdWdpbk5hbWUgPSAnYmF0Y2gnO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIHVzZWQgdG8gZmFzdCBjaGVjayBpZiBhIHNwcml0ZSBpcy4uIGEgc3ByaXRlIVxyXG4gICAgICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5pc1Nwcml0ZSA9IHRydWU7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSW50ZXJuYWwgcm91bmRQaXhlbHMgZmllbGRcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLl9yb3VuZFBpeGVscyA9IERpc3BsYXlTZXR0aW5nc18xLkRpc3BsYXlTZXR0aW5ncy5ST1VORF9QSVhFTFM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENhbGxlZCB3aGVuIHRoZSBhbmNob3IgcG9zaXRpb24gdXBkYXRlcy5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBfb25BbmNob3JVcGRhdGUoKSB7XHJcbiAgICAgICAgdGhpcy5fdHJhbnNmb3JtSUQgPSAtMTtcclxuICAgICAgICB0aGlzLl90cmFuc2Zvcm1UcmltbWVkSUQgPSAtMTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogY2FsY3VsYXRlcyB3b3JsZFRyYW5zZm9ybSAqIHZlcnRpY2VzLCBzdG9yZSBpdCBpbiB2ZXJ0ZXhEYXRhXHJcbiAgICAgKi9cclxuICAgIGNhbGN1bGF0ZVZlcnRpY2VzKCkge1xyXG4gICAgICAgIHZhciB0ZXh0dXJlID0gdGhpcy5fdGV4dHVyZTtcclxuICAgICAgICBpZiAodGhpcy5fdHJhbnNmb3JtSUQgPT09IHRoaXMudHJhbnNmb3JtLl93b3JsZElEICYmIHRoaXMuX3RleHR1cmVJRCA9PT0gdGV4dHVyZS5fdXBkYXRlSUQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl90cmFuc2Zvcm1JRCA9IHRoaXMudHJhbnNmb3JtLl93b3JsZElEO1xyXG4gICAgICAgIHRoaXMuX3RleHR1cmVJRCA9IHRleHR1cmUuX3VwZGF0ZUlEO1xyXG4gICAgICAgIC8vIHNldCB0aGUgdmVydGV4IGRhdGFcclxuICAgICAgICB2YXIgd3QgPSB0aGlzLnRyYW5zZm9ybS53b3JsZFRyYW5zZm9ybTtcclxuICAgICAgICB2YXIgYSA9IHd0LmE7XHJcbiAgICAgICAgdmFyIGIgPSB3dC5iO1xyXG4gICAgICAgIHZhciBjID0gd3QuYztcclxuICAgICAgICB2YXIgZCA9IHd0LmQ7XHJcbiAgICAgICAgdmFyIHR4ID0gd3QudHg7XHJcbiAgICAgICAgdmFyIHR5ID0gd3QudHk7XHJcbiAgICAgICAgdmFyIHZlcnRleERhdGEgPSB0aGlzLnZlcnRleERhdGE7XHJcbiAgICAgICAgdmFyIHRyaW0gPSB0ZXh0dXJlLnRyaW07XHJcbiAgICAgICAgdmFyIG9yaWcgPSB0ZXh0dXJlLm9yaWc7XHJcbiAgICAgICAgdmFyIGFuY2hvciA9IHRoaXMuX2FuY2hvcjtcclxuICAgICAgICB2YXIgdzAgPSAwO1xyXG4gICAgICAgIHZhciB3MSA9IDA7XHJcbiAgICAgICAgdmFyIGgwID0gMDtcclxuICAgICAgICB2YXIgaDEgPSAwO1xyXG4gICAgICAgIGlmICh0cmltKSB7XHJcbiAgICAgICAgICAgIC8vIGlmIHRoZSBzcHJpdGUgaXMgdHJpbW1lZCBhbmQgaXMgbm90IGEgdGlsaW5nc3ByaXRlIHRoZW4gd2UgbmVlZCB0byBhZGQgdGhlIGV4dHJhXHJcbiAgICAgICAgICAgIC8vIHNwYWNlIGJlZm9yZSB0cmFuc2Zvcm1pbmcgdGhlIHNwcml0ZSBjb29yZHMuXHJcbiAgICAgICAgICAgIHcxID0gdHJpbS54IC0gKGFuY2hvci5feCAqIG9yaWcud2lkdGgpO1xyXG4gICAgICAgICAgICB3MCA9IHcxICsgdHJpbS53aWR0aDtcclxuICAgICAgICAgICAgaDEgPSB0cmltLnkgLSAoYW5jaG9yLl95ICogb3JpZy5oZWlnaHQpO1xyXG4gICAgICAgICAgICBoMCA9IGgxICsgdHJpbS5oZWlnaHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB3MSA9IC1hbmNob3IuX3ggKiBvcmlnLndpZHRoO1xyXG4gICAgICAgICAgICB3MCA9IHcxICsgb3JpZy53aWR0aDtcclxuICAgICAgICAgICAgaDEgPSAtYW5jaG9yLl95ICogb3JpZy5oZWlnaHQ7XHJcbiAgICAgICAgICAgIGgwID0gaDEgKyBvcmlnLmhlaWdodDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8geHlcclxuICAgICAgICB2ZXJ0ZXhEYXRhWzBdID0gKGEgKiB3MSkgKyAoYyAqIGgxKSArIHR4O1xyXG4gICAgICAgIHZlcnRleERhdGFbMV0gPSAoZCAqIGgxKSArIChiICogdzEpICsgdHk7XHJcbiAgICAgICAgLy8geHlcclxuICAgICAgICB2ZXJ0ZXhEYXRhWzJdID0gKGEgKiB3MCkgKyAoYyAqIGgxKSArIHR4O1xyXG4gICAgICAgIHZlcnRleERhdGFbM10gPSAoZCAqIGgxKSArIChiICogdzApICsgdHk7XHJcbiAgICAgICAgLy8geHlcclxuICAgICAgICB2ZXJ0ZXhEYXRhWzRdID0gKGEgKiB3MCkgKyAoYyAqIGgwKSArIHR4O1xyXG4gICAgICAgIHZlcnRleERhdGFbNV0gPSAoZCAqIGgwKSArIChiICogdzApICsgdHk7XHJcbiAgICAgICAgLy8geHlcclxuICAgICAgICB2ZXJ0ZXhEYXRhWzZdID0gKGEgKiB3MSkgKyAoYyAqIGgwKSArIHR4O1xyXG4gICAgICAgIHZlcnRleERhdGFbN10gPSAoZCAqIGgwKSArIChiICogdzEpICsgdHk7XHJcbiAgICAgICAgaWYgKHRoaXMuX3JvdW5kUGl4ZWxzKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgODsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhEYXRhW2ldID0gTWF0aC5yb3VuZCh2ZXJ0ZXhEYXRhW2ldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogY2FsY3VsYXRlcyB3b3JsZFRyYW5zZm9ybSAqIHZlcnRpY2VzIGZvciBhIG5vbiB0ZXh0dXJlIHdpdGggYSB0cmltLiBzdG9yZSBpdCBpbiB2ZXJ0ZXhUcmltbWVkRGF0YVxyXG4gICAgICogVGhpcyBpcyB1c2VkIHRvIGVuc3VyZSB0aGF0IHRoZSB0cnVlIHdpZHRoIGFuZCBoZWlnaHQgb2YgYSB0cmltbWVkIHRleHR1cmUgaXMgcmVzcGVjdGVkXHJcbiAgICAgKi9cclxuICAgIGNhbGN1bGF0ZVRyaW1tZWRWZXJ0aWNlcygpIHtcclxuICAgICAgICBpZiAoIXRoaXMudmVydGV4VHJpbW1lZERhdGEpIHtcclxuICAgICAgICAgICAgdGhpcy52ZXJ0ZXhUcmltbWVkRGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoOCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX3RyYW5zZm9ybVRyaW1tZWRJRCA9PT0gdGhpcy50cmFuc2Zvcm0uX3dvcmxkSUQgJiYgdGhpcy5fdGV4dHVyZVRyaW1tZWRJRCA9PT0gdGhpcy5fdGV4dHVyZS5fdXBkYXRlSUQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl90cmFuc2Zvcm1UcmltbWVkSUQgPSB0aGlzLnRyYW5zZm9ybS5fd29ybGRJRDtcclxuICAgICAgICB0aGlzLl90ZXh0dXJlVHJpbW1lZElEID0gdGhpcy5fdGV4dHVyZS5fdXBkYXRlSUQ7XHJcbiAgICAgICAgLy8gbGV0cyBkbyBzb21lIHNwZWNpYWwgdHJpbSBjb2RlIVxyXG4gICAgICAgIHZhciB0ZXh0dXJlID0gdGhpcy5fdGV4dHVyZTtcclxuICAgICAgICB2YXIgdmVydGV4RGF0YSA9IHRoaXMudmVydGV4VHJpbW1lZERhdGE7XHJcbiAgICAgICAgdmFyIG9yaWcgPSB0ZXh0dXJlLm9yaWc7XHJcbiAgICAgICAgdmFyIGFuY2hvciA9IHRoaXMuX2FuY2hvcjtcclxuICAgICAgICAvLyBsZXRzIGNhbGN1bGF0ZSB0aGUgbmV3IHVudHJpbW1lZCBib3VuZHMuLlxyXG4gICAgICAgIHZhciB3dCA9IHRoaXMudHJhbnNmb3JtLndvcmxkVHJhbnNmb3JtO1xyXG4gICAgICAgIHZhciBhID0gd3QuYTtcclxuICAgICAgICB2YXIgYiA9IHd0LmI7XHJcbiAgICAgICAgdmFyIGMgPSB3dC5jO1xyXG4gICAgICAgIHZhciBkID0gd3QuZDtcclxuICAgICAgICB2YXIgdHggPSB3dC50eDtcclxuICAgICAgICB2YXIgdHkgPSB3dC50eTtcclxuICAgICAgICB2YXIgdzEgPSAtYW5jaG9yLl94ICogb3JpZy53aWR0aDtcclxuICAgICAgICB2YXIgdzAgPSB3MSArIG9yaWcud2lkdGg7XHJcbiAgICAgICAgdmFyIGgxID0gLWFuY2hvci5feSAqIG9yaWcuaGVpZ2h0O1xyXG4gICAgICAgIHZhciBoMCA9IGgxICsgb3JpZy5oZWlnaHQ7XHJcbiAgICAgICAgLy8geHlcclxuICAgICAgICB2ZXJ0ZXhEYXRhWzBdID0gKGEgKiB3MSkgKyAoYyAqIGgxKSArIHR4O1xyXG4gICAgICAgIHZlcnRleERhdGFbMV0gPSAoZCAqIGgxKSArIChiICogdzEpICsgdHk7XHJcbiAgICAgICAgLy8geHlcclxuICAgICAgICB2ZXJ0ZXhEYXRhWzJdID0gKGEgKiB3MCkgKyAoYyAqIGgxKSArIHR4O1xyXG4gICAgICAgIHZlcnRleERhdGFbM10gPSAoZCAqIGgxKSArIChiICogdzApICsgdHk7XHJcbiAgICAgICAgLy8geHlcclxuICAgICAgICB2ZXJ0ZXhEYXRhWzRdID0gKGEgKiB3MCkgKyAoYyAqIGgwKSArIHR4O1xyXG4gICAgICAgIHZlcnRleERhdGFbNV0gPSAoZCAqIGgwKSArIChiICogdzApICsgdHk7XHJcbiAgICAgICAgLy8geHlcclxuICAgICAgICB2ZXJ0ZXhEYXRhWzZdID0gKGEgKiB3MSkgKyAoYyAqIGgwKSArIHR4O1xyXG4gICAgICAgIHZlcnRleERhdGFbN10gPSAoZCAqIGgwKSArIChiICogdzEpICsgdHk7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICpcclxuICAgICogUmVuZGVycyB0aGUgb2JqZWN0IHVzaW5nIHRoZSBXZWJHTCByZW5kZXJlclxyXG4gICAgKlxyXG4gICAgKiBAcHJvdGVjdGVkXHJcbiAgICAqIEBwYXJhbSB7UElYSS5SZW5kZXJlcn0gcmVuZGVyZXIgLSBUaGUgd2ViZ2wgcmVuZGVyZXIgdG8gdXNlLlxyXG4gICAgKi9cclxuICAgIF9yZW5kZXIocmVuZGVyZXIpIHtcclxuICAgICAgICB0aGlzLmNhbGN1bGF0ZVZlcnRpY2VzKCk7XHJcbiAgICAgICAgcmVuZGVyZXIuYmF0Y2guc2V0T2JqZWN0UmVuZGVyZXIocmVuZGVyZXIucGx1Z2luc1t0aGlzLnBsdWdpbk5hbWVdKTtcclxuICAgICAgICByZW5kZXJlci5wbHVnaW5zW3RoaXMucGx1Z2luTmFtZV0ucmVuZGVyKHRoaXMpO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGVzIHRoZSBib3VuZHMgb2YgdGhlIHNwcml0ZS5cclxuICAgICAqXHJcbiAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgKi9cclxuICAgIF9jYWxjdWxhdGVCb3VuZHMoKSB7XHJcbiAgICAgICAgdmFyIHRyaW0gPSB0aGlzLl90ZXh0dXJlLnRyaW07XHJcbiAgICAgICAgdmFyIG9yaWcgPSB0aGlzLl90ZXh0dXJlLm9yaWc7XHJcbiAgICAgICAgLy8gRmlyc3QgbGV0cyBjaGVjayB0byBzZWUgaWYgdGhlIGN1cnJlbnQgdGV4dHVyZSBoYXMgYSB0cmltLi5cclxuICAgICAgICBpZiAoIXRyaW0gfHwgKHRyaW0ud2lkdGggPT09IG9yaWcud2lkdGggJiYgdHJpbS5oZWlnaHQgPT09IG9yaWcuaGVpZ2h0KSkge1xyXG4gICAgICAgICAgICAvLyBubyB0cmltISBsZXRzIHVzZSB0aGUgdXN1YWwgY2FsY3VsYXRpb25zLi5cclxuICAgICAgICAgICAgdGhpcy5jYWxjdWxhdGVWZXJ0aWNlcygpO1xyXG4gICAgICAgICAgICB0aGlzLl9ib3VuZHMuYWRkUXVhZCh0aGlzLnZlcnRleERhdGEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gbGV0cyBjYWxjdWxhdGUgYSBzcGVjaWFsIHRyaW1tZWQgYm91bmRzLi4uXHJcbiAgICAgICAgICAgIHRoaXMuY2FsY3VsYXRlVHJpbW1lZFZlcnRpY2VzKCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2JvdW5kcy5hZGRRdWFkKHRoaXMudmVydGV4VHJpbW1lZERhdGEpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgbG9jYWwgYm91bmRzIG9mIHRoZSBzcHJpdGUgb2JqZWN0LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7UElYSS5SZWN0YW5nbGV9IHJlY3QgLSBUaGUgb3V0cHV0IHJlY3RhbmdsZS5cclxuICAgICAqIEByZXR1cm4ge1BJWEkuUmVjdGFuZ2xlfSBUaGUgYm91bmRzLlxyXG4gICAgICovXHJcbiAgICBnZXRMb2NhbEJvdW5kcyhyZWN0KSB7XHJcbiAgICAgICAgLy8gd2UgY2FuIGRvIGEgZmFzdCBsb2NhbCBib3VuZHMgaWYgdGhlIHNwcml0ZSBoYXMgbm8gY2hpbGRyZW4hXHJcbiAgICAgICAgaWYgKHRoaXMuY2hpbGRyZW4ubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2JvdW5kcy5taW5YID0gdGhpcy5fdGV4dHVyZS5vcmlnLndpZHRoICogLXRoaXMuX2FuY2hvci5feDtcclxuICAgICAgICAgICAgdGhpcy5fYm91bmRzLm1pblkgPSB0aGlzLl90ZXh0dXJlLm9yaWcuaGVpZ2h0ICogLXRoaXMuX2FuY2hvci5feTtcclxuICAgICAgICAgICAgdGhpcy5fYm91bmRzLm1heFggPSB0aGlzLl90ZXh0dXJlLm9yaWcud2lkdGggKiAoMSAtIHRoaXMuX2FuY2hvci5feCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2JvdW5kcy5tYXhZID0gdGhpcy5fdGV4dHVyZS5vcmlnLmhlaWdodCAqICgxIC0gdGhpcy5fYW5jaG9yLl95KTtcclxuICAgICAgICAgICAgaWYgKCFyZWN0KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2xvY2FsQm91bmRzUmVjdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xvY2FsQm91bmRzUmVjdCA9IG5ldyBSZWN0YW5nbGVfMS5SZWN0YW5nbGUoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJlY3QgPSB0aGlzLl9sb2NhbEJvdW5kc1JlY3Q7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2JvdW5kcy5nZXRSZWN0YW5nbGUocmVjdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBDb250YWluZXJfMS5Db250YWluZXIucHJvdG90eXBlLmdldExvY2FsQm91bmRzLmNhbGwodGhpcywgcmVjdCk7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFRlc3RzIGlmIGEgcG9pbnQgaXMgaW5zaWRlIHRoaXMgc3ByaXRlXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtQSVhJLlBvaW50fSBwb2ludCAtIHRoZSBwb2ludCB0byB0ZXN0XHJcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSB0aGUgcmVzdWx0IG9mIHRoZSB0ZXN0XHJcbiAgICAgKi9cclxuICAgIGNvbnRhaW5zUG9pbnQocG9pbnQpIHtcclxuICAgICAgICB0aGlzLndvcmxkVHJhbnNmb3JtLmFwcGx5SW52ZXJzZShwb2ludCwgU3ByaXRlLnRlbXBQb2ludCk7XHJcbiAgICAgICAgdmFyIHdpZHRoID0gdGhpcy5fdGV4dHVyZS5vcmlnLndpZHRoO1xyXG4gICAgICAgIHZhciBoZWlnaHQgPSB0aGlzLl90ZXh0dXJlLm9yaWcuaGVpZ2h0O1xyXG4gICAgICAgIHZhciB4MSA9IC13aWR0aCAqIHRoaXMuYW5jaG9yLng7XHJcbiAgICAgICAgdmFyIHkxID0gMDtcclxuICAgICAgICBpZiAoU3ByaXRlLnRlbXBQb2ludC54ID49IHgxICYmIFNwcml0ZS50ZW1wUG9pbnQueCA8IHgxICsgd2lkdGgpIHtcclxuICAgICAgICAgICAgeTEgPSAtaGVpZ2h0ICogdGhpcy5hbmNob3IueTtcclxuICAgICAgICAgICAgaWYgKFNwcml0ZS50ZW1wUG9pbnQueSA+PSB5MSAmJiBTcHJpdGUudGVtcFBvaW50LnkgPCB5MSArIGhlaWdodCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBEZXN0cm95cyB0aGlzIHNwcml0ZSBhbmQgb3B0aW9uYWxseSBpdHMgdGV4dHVyZSBhbmQgY2hpbGRyZW5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdHxib29sZWFufSBbb3B0aW9uc10gLSBPcHRpb25zIHBhcmFtZXRlci4gQSBib29sZWFuIHdpbGwgYWN0IGFzIGlmIGFsbCBvcHRpb25zXHJcbiAgICAgKiAgaGF2ZSBiZWVuIHNldCB0byB0aGF0IHZhbHVlXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmNoaWxkcmVuPWZhbHNlXSAtIGlmIHNldCB0byB0cnVlLCBhbGwgdGhlIGNoaWxkcmVuIHdpbGwgaGF2ZSB0aGVpciBkZXN0cm95XHJcbiAgICAgKiAgICAgIG1ldGhvZCBjYWxsZWQgYXMgd2VsbC4gJ29wdGlvbnMnIHdpbGwgYmUgcGFzc2VkIG9uIHRvIHRob3NlIGNhbGxzLlxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50ZXh0dXJlPWZhbHNlXSAtIFNob3VsZCBpdCBkZXN0cm95IHRoZSBjdXJyZW50IHRleHR1cmUgb2YgdGhlIHNwcml0ZSBhcyB3ZWxsXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmJhc2VUZXh0dXJlPWZhbHNlXSAtIFNob3VsZCBpdCBkZXN0cm95IHRoZSBiYXNlIHRleHR1cmUgb2YgdGhlIHNwcml0ZSBhcyB3ZWxsXHJcbiAgICAgKi9cclxuICAgIGRlc3Ryb3kob3B0aW9ucykge1xyXG4gICAgICAgIHN1cGVyLmRlc3Ryb3kob3B0aW9ucyk7XHJcbiAgICAgICAgLy8gdGhpcy5fdGV4dHVyZS5vZmYoJ3VwZGF0ZScsIHRoaXMuX29uVGV4dHVyZVVwZGF0ZSwgdGhpcyk7XHJcbiAgICAgICAgdGhpcy5fYW5jaG9yID0gbnVsbDtcclxuICAgICAgICB2YXIgZGVzdHJveVRleHR1cmUgPSB0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Jvb2xlYW4nID8gb3B0aW9ucyA6IG9wdGlvbnMgJiYgb3B0aW9ucy50ZXh0dXJlO1xyXG4gICAgICAgIGlmIChkZXN0cm95VGV4dHVyZSkge1xyXG4gICAgICAgICAgICB2YXIgZGVzdHJveUJhc2VUZXh0dXJlID0gdHlwZW9mIG9wdGlvbnMgPT09ICdib29sZWFuJyA/IG9wdGlvbnMgOiBvcHRpb25zICYmIG9wdGlvbnMuYmFzZVRleHR1cmU7XHJcbiAgICAgICAgICAgIHRoaXMuX3RleHR1cmUuZGVzdHJveSghIWRlc3Ryb3lCYXNlVGV4dHVyZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3RleHR1cmUgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuc2hhZGVyID0gbnVsbDtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogSWYgdHJ1ZSBQaXhpSlMgd2lsbCBNYXRoLmZsb29yKCkgeC95IHZhbHVlcyB3aGVuIHJlbmRlcmluZywgc3RvcHBpbmcgcGl4ZWwgaW50ZXJwb2xhdGlvbi5cclxuICAgICAqIEFkdmFudGFnZXMgY2FuIGluY2x1ZGUgc2hhcnBlciBpbWFnZSBxdWFsaXR5IChsaWtlIHRleHQpIGFuZCBmYXN0ZXIgcmVuZGVyaW5nIG9uIGNhbnZhcy5cclxuICAgICAqIFRoZSBtYWluIGRpc2FkdmFudGFnZSBpcyBtb3ZlbWVudCBvZiBvYmplY3RzIG1heSBhcHBlYXIgbGVzcyBzbW9vdGguXHJcbiAgICAgKiBUbyBzZXQgdGhlIGdsb2JhbCBkZWZhdWx0LCBjaGFuZ2Uge0BsaW5rIFBJWEkuc2V0dGluZ3MuUk9VTkRfUElYRUxTfVxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XHJcbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxyXG4gICAgICovXHJcbiAgICBzZXQgcm91bmRQaXhlbHModmFsdWUpIHtcclxuICAgICAgICBpZiAodGhpcy5fcm91bmRQaXhlbHMgIT09IHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3RyYW5zZm9ybUlEID0gLTE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3JvdW5kUGl4ZWxzID0gdmFsdWU7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICBnZXQgcm91bmRQaXhlbHMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JvdW5kUGl4ZWxzO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgd2lkdGggb2YgdGhlIHNwcml0ZSwgc2V0dGluZyB0aGlzIHdpbGwgYWN0dWFsbHkgbW9kaWZ5IHRoZSBzY2FsZSB0byBhY2hpZXZlIHRoZSB2YWx1ZSBzZXRcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIGdldCB3aWR0aCgpIHtcclxuICAgICAgICByZXR1cm4gTWF0aC5hYnModGhpcy5zY2FsZS54KSAqIHRoaXMuX3RleHR1cmUub3JpZy53aWR0aDtcclxuICAgIH1cclxuICAgIDtcclxuICAgIHNldCB3aWR0aCh2YWx1ZSkge1xyXG4gICAgICAgIHZhciBzID0gTWF0aFNldHRpbmdzXzEuTWF0aFNldHRpbmdzLnNpZ24odGhpcy5zY2FsZS54KSB8fCAxO1xyXG4gICAgICAgIHRoaXMuc2NhbGUueCA9IHMgKiB2YWx1ZSAvIHRoaXMuX3RleHR1cmUub3JpZy53aWR0aDtcclxuICAgICAgICB0aGlzLl93aWR0aCA9IHZhbHVlO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgaGVpZ2h0IG9mIHRoZSBzcHJpdGUsIHNldHRpbmcgdGhpcyB3aWxsIGFjdHVhbGx5IG1vZGlmeSB0aGUgc2NhbGUgdG8gYWNoaWV2ZSB0aGUgdmFsdWUgc2V0XHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICBnZXQgaGVpZ2h0KCkge1xyXG4gICAgICAgIHJldHVybiBNYXRoLmFicyh0aGlzLnNjYWxlLnkpICogdGhpcy5fdGV4dHVyZS5vcmlnLmhlaWdodDtcclxuICAgIH1cclxuICAgIDtcclxuICAgIHNldCBoZWlnaHQodmFsdWUpIHtcclxuICAgICAgICB2YXIgcyA9IE1hdGhTZXR0aW5nc18xLk1hdGhTZXR0aW5ncy5zaWduKHRoaXMuc2NhbGUueSkgfHwgMTtcclxuICAgICAgICB0aGlzLnNjYWxlLnkgPSBzICogdmFsdWUgLyB0aGlzLl90ZXh0dXJlLm9yaWcuaGVpZ2h0O1xyXG4gICAgICAgIHRoaXMuX2hlaWdodCA9IHZhbHVlO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgYW5jaG9yIHNldHMgdGhlIG9yaWdpbiBwb2ludCBvZiB0aGUgdGV4dC4gVGhlIGRlZmF1bHQgdmFsdWUgaXMgdGFrZW4gZnJvbSB0aGUge0BsaW5rIFBJWEkuVGV4dHVyZXxUZXh0dXJlfVxyXG4gICAgICogYW5kIHBhc3NlZCB0byB0aGUgY29uc3RydWN0b3IuXHJcbiAgICAgKlxyXG4gICAgICogVGhlIGRlZmF1bHQgaXMgYCgwLDApYCwgdGhpcyBtZWFucyB0aGUgdGV4dCdzIG9yaWdpbiBpcyB0aGUgdG9wIGxlZnQuXHJcbiAgICAgKlxyXG4gICAgICogU2V0dGluZyB0aGUgYW5jaG9yIHRvIGAoMC41LDAuNSlgIG1lYW5zIHRoZSB0ZXh0J3Mgb3JpZ2luIGlzIGNlbnRlcmVkLlxyXG4gICAgICpcclxuICAgICAqIFNldHRpbmcgdGhlIGFuY2hvciB0byBgKDEsMSlgIHdvdWxkIG1lYW4gdGhlIHRleHQncyBvcmlnaW4gcG9pbnQgd2lsbCBiZSB0aGUgYm90dG9tIHJpZ2h0IGNvcm5lci5cclxuICAgICAqXHJcbiAgICAgKiBJZiB5b3UgcGFzcyBvbmx5IHNpbmdsZSBwYXJhbWV0ZXIsIGl0IHdpbGwgc2V0IGJvdGggeCBhbmQgeSB0byB0aGUgc2FtZSB2YWx1ZSBhcyBzaG93biBpbiB0aGUgZXhhbXBsZSBiZWxvdy5cclxuICAgICAqXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICogY29uc3Qgc3ByaXRlID0gbmV3IFBJWEkuU3ByaXRlKHRleHR1cmUpO1xyXG4gICAgICogc3ByaXRlLmFuY2hvci5zZXQoMC41KTsgLy8gVGhpcyB3aWxsIHNldCB0aGUgb3JpZ2luIHRvIGNlbnRlci4gKDAuNSkgaXMgc2FtZSBhcyAoMC41LCAwLjUpLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge1BJWEkuT2JzZXJ2YWJsZVBvaW50fVxyXG4gICAgICovXHJcbiAgICBnZXQgYW5jaG9yKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9hbmNob3I7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICBzZXQgYW5jaG9yKHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5fYW5jaG9yLmNvcHlGcm9tKHZhbHVlKTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIHRpbnQgYXBwbGllZCB0byB0aGUgc3ByaXRlLiBUaGlzIGlzIGEgaGV4IHZhbHVlLlxyXG4gICAgICogQSB2YWx1ZSBvZiAweEZGRkZGRiB3aWxsIHJlbW92ZSBhbnkgdGludCBlZmZlY3QuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICogQGRlZmF1bHQgMHhGRkZGRkZcclxuICAgICAqL1xyXG4gICAgZ2V0IHRpbnQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RpbnQ7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICBzZXQgdGludCh2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuX3RpbnQgPSB2YWx1ZTtcclxuICAgICAgICB0aGlzLl90aW50UkdCID0gKHZhbHVlID4+IDE2KSArICh2YWx1ZSAmIDB4ZmYwMCkgKyAoKHZhbHVlICYgMHhmZikgPDwgMTYpO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgdGV4dHVyZSB0aGF0IHRoZSBzcHJpdGUgaXMgdXNpbmdcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtQSVhJLlRleHR1cmV9XHJcbiAgICAgKi9cclxuICAgIGdldCB0ZXh0dXJlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl90ZXh0dXJlO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgc2V0IHRleHR1cmUodmFsdWUpIHtcclxuICAgICAgICBpZiAodGhpcy5fdGV4dHVyZSA9PT0gdmFsdWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl90ZXh0dXJlID0gdmFsdWUgfHwgVGV4dHVyZV8xLlRleHR1cmUuRU1QVFk7XHJcbiAgICAgICAgdGhpcy5jYWNoZWRUaW50ID0gMHhGRkZGRkY7XHJcbiAgICAgICAgdGhpcy5fdGV4dHVyZUlEID0gLTE7XHJcbiAgICAgICAgdGhpcy5fdGV4dHVyZVRyaW1tZWRJRCA9IC0xO1xyXG4gICAgICAgIGlmICh2YWx1ZSkge1xyXG4gICAgICAgICAgICAvLyB3YWl0IGZvciB0aGUgdGV4dHVyZSB0byBsb2FkXHJcbiAgICAgICAgICAgIGlmICh2YWx1ZS5iYXNlVGV4dHVyZS52YWxpZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fb25UZXh0dXJlVXBkYXRlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZS5hZGRFdmVudExpc3RlbmVyKCd1cGRhdGUnLCB0aGlzLl9vblRleHR1cmVVcGRhdGUpO1xyXG4gICAgICAgICAgICAgICAgLy8gdmFsdWUub25jZSgndXBkYXRlJywgdGhpcy5fb25UZXh0dXJlVXBkYXRlLCB0aGlzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIDtcclxufVxyXG5TcHJpdGUudGVtcFBvaW50ID0gbmV3IFBvaW50XzEuUG9pbnQoKTtcclxuU3ByaXRlLmluZGljZXMgPSBuZXcgVWludDE2QXJyYXkoWzAsIDEsIDIsIDAsIDIsIDNdKTtcclxuLy8gc29tZSBoZWxwZXIgZnVuY3Rpb25zLi5cclxuLyoqXHJcbiAqIEhlbHBlciBmdW5jdGlvbiB0aGF0IGNyZWF0ZXMgYSBuZXcgc3ByaXRlIGJhc2VkIG9uIHRoZSBzb3VyY2UgeW91IHByb3ZpZGUuXHJcbiAqIFRoZSBzb3VyY2UgY2FuIGJlIC0gZnJhbWUgaWQsIGltYWdlIHVybCwgdmlkZW8gdXJsLCBjYW52YXMgZWxlbWVudCwgdmlkZW8gZWxlbWVudCwgYmFzZSB0ZXh0dXJlXHJcbiAqXHJcbiAqIEBzdGF0aWNcclxuICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfFBJWEkuVGV4dHVyZXxIVE1MQ2FudmFzRWxlbWVudHxIVE1MVmlkZW9FbGVtZW50fSBzb3VyY2UgU291cmNlIHRvIGNyZWF0ZSB0ZXh0dXJlIGZyb21cclxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSBTZWUge0BsaW5rIFBJWEkuQmFzZVRleHR1cmV9J3MgY29uc3RydWN0b3IgZm9yIG9wdGlvbnMuXHJcbiAqIEByZXR1cm4ge1BJWEkuU3ByaXRlfSBUaGUgbmV3bHkgY3JlYXRlZCBzcHJpdGVcclxuICovXHJcblNwcml0ZS5mcm9tID0gZnVuY3Rpb24gZnJvbShzb3VyY2UsIG9wdGlvbnMgPSB7fSkge1xyXG4gICAgaWYgKG9wdGlvbnMgPT0gbnVsbCkge1xyXG4gICAgICAgIG9wdGlvbnMgPSB7fTtcclxuICAgIH1cclxuICAgIHZhciB0ZXh0dXJlID0gKHNvdXJjZSBpbnN0YW5jZW9mIFRleHR1cmVfMS5UZXh0dXJlKVxyXG4gICAgICAgID8gc291cmNlXHJcbiAgICAgICAgOiBUZXh0dXJlXzEuVGV4dHVyZS5mcm9tKHNvdXJjZSwgb3B0aW9ucyk7XHJcbiAgICByZXR1cm4gbmV3IFNwcml0ZSh0ZXh0dXJlKTtcclxufTtcclxuZXhwb3J0cy5TcHJpdGUgPSBTcHJpdGU7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IEZpbHRlcl8xID0gcmVxdWlyZShcIi4vRmlsdGVyXCIpO1xyXG5jb25zdCBNYXRyaXhfMSA9IHJlcXVpcmUoXCIuL01hdHJpeFwiKTtcclxuY29uc3QgVGV4dHVyZU1hdHJpeF8xID0gcmVxdWlyZShcIi4vVGV4dHVyZU1hdHJpeFwiKTtcclxuY2xhc3MgU3ByaXRlTWFza0ZpbHRlciBleHRlbmRzIEZpbHRlcl8xLkZpbHRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihzcHJpdGUpIHtcclxuICAgICAgICB2YXIgbWFza01hdHJpeCA9IG5ldyBNYXRyaXhfMS5NYXRyaXgoKTtcclxuICAgICAgICBzdXBlcihTcHJpdGVNYXNrRmlsdGVyLnZlcnRleCwgU3ByaXRlTWFza0ZpbHRlci5mcmFnbWVudCk7XHJcbiAgICAgICAgc3ByaXRlLnJlbmRlcmFibGUgPSBmYWxzZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTcHJpdGUgbWFza1xyXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuU3ByaXRlfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMubWFza1Nwcml0ZSA9IHNwcml0ZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBNYXNrIG1hdHJpeFxyXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuTWF0cml4fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMubWFza01hdHJpeCA9IG1hc2tNYXRyaXg7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFwcGxpZXMgdGhlIGZpbHRlclxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7UElYSS5zeXN0ZW1zLkZpbHRlclN5c3RlbX0gZmlsdGVyTWFuYWdlciAtIFRoZSByZW5kZXJlciB0byByZXRyaWV2ZSB0aGUgZmlsdGVyIGZyb21cclxuICAgICAqIEBwYXJhbSB7UElYSS5SZW5kZXJUZXh0dXJlfSBpbnB1dCAtIFRoZSBpbnB1dCByZW5kZXIgdGFyZ2V0LlxyXG4gICAgICogQHBhcmFtIHtQSVhJLlJlbmRlclRleHR1cmV9IG91dHB1dCAtIFRoZSB0YXJnZXQgdG8gb3V0cHV0IHRvLlxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBjbGVhciAtIFNob3VsZCB0aGUgb3V0cHV0IGJlIGNsZWFyZWQgYmVmb3JlIHJlbmRlcmluZyB0byBpdC5cclxuICAgICAqL1xyXG4gICAgYXBwbHkoZmlsdGVyTWFuYWdlciwgaW5wdXQsIG91dHB1dCwgY2xlYXIpIHtcclxuICAgICAgICB2YXIgbWFza1Nwcml0ZSA9IHRoaXMubWFza1Nwcml0ZTtcclxuICAgICAgICB2YXIgdGV4ID0gdGhpcy5tYXNrU3ByaXRlLnRleHR1cmU7XHJcbiAgICAgICAgaWYgKCF0ZXgudmFsaWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXRleC50cmFuc2Zvcm0pIHtcclxuICAgICAgICAgICAgLy8gbWFyZ2luID0gMC4wLCBsZXQgaXQgYmxlZWQgYSBiaXQsIHNoYWRlciBjb2RlIGJlY29tZXMgZWFzaWVyXHJcbiAgICAgICAgICAgIC8vIGFzc3VtaW5nIHRoYXQgYXRsYXMgdGV4dHVyZXMgd2VyZSBtYWRlIHdpdGggMS1waXhlbCBwYWRkaW5nXHJcbiAgICAgICAgICAgIHRleC50cmFuc2Zvcm0gPSBuZXcgVGV4dHVyZU1hdHJpeF8xLlRleHR1cmVNYXRyaXgodGV4LCAwLjApO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0ZXgudHJhbnNmb3JtLnVwZGF0ZSgpO1xyXG4gICAgICAgIHRoaXMudW5pZm9ybXMubnBtQWxwaGEgPSB0ZXguYmFzZVRleHR1cmUucHJlbXVsdGlwbHlBbHBoYSA/IDAuMCA6IDEuMDtcclxuICAgICAgICB0aGlzLnVuaWZvcm1zLm1hc2sgPSB0ZXg7XHJcbiAgICAgICAgdGhpcy51bmlmb3Jtcy5vdGhlck1hdHJpeCA9IGZpbHRlck1hbmFnZXIuY2FsY3VsYXRlU3ByaXRlTWF0cml4KHRoaXMubWFza01hdHJpeCwgbWFza1Nwcml0ZSlcclxuICAgICAgICAgICAgLnByZXBlbmQodGV4LnRyYW5zZm9ybS5tYXBDb29yZCk7XHJcbiAgICAgICAgdGhpcy51bmlmb3Jtcy5hbHBoYSA9IG1hc2tTcHJpdGUud29ybGRBbHBoYTtcclxuICAgICAgICB0aGlzLnVuaWZvcm1zLm1hc2tDbGFtcCA9IHRleC50cmFuc2Zvcm0udUNsYW1wRnJhbWU7XHJcbiAgICAgICAgZmlsdGVyTWFuYWdlci5hcHBseUZpbHRlcih0aGlzLCBpbnB1dCwgb3V0cHV0LCBjbGVhcik7XHJcbiAgICB9XHJcbiAgICA7XHJcbn1cclxuU3ByaXRlTWFza0ZpbHRlci52ZXJ0ZXggPSBcImF0dHJpYnV0ZSB2ZWMyIGFWZXJ0ZXhQb3NpdGlvbjtcXHJcXG5hdHRyaWJ1dGUgdmVjMiBhVGV4dHVyZUNvb3JkO1xcclxcblxcclxcbnVuaWZvcm0gbWF0MyBwcm9qZWN0aW9uTWF0cml4O1xcclxcbnVuaWZvcm0gbWF0MyBvdGhlck1hdHJpeDtcXHJcXG5cXHJcXG52YXJ5aW5nIHZlYzIgdk1hc2tDb29yZDtcXHJcXG52YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXHJcXG5cXHJcXG52b2lkIG1haW4odm9pZClcXHJcXG57XFxyXFxuICAgIGdsX1Bvc2l0aW9uID0gdmVjNCgocHJvamVjdGlvbk1hdHJpeCAqIHZlYzMoYVZlcnRleFBvc2l0aW9uLCAxLjApKS54eSwgMC4wLCAxLjApO1xcclxcblxcclxcbiAgICB2VGV4dHVyZUNvb3JkID0gYVRleHR1cmVDb29yZDtcXHJcXG4gICAgdk1hc2tDb29yZCA9ICggb3RoZXJNYXRyaXggKiB2ZWMzKCBhVGV4dHVyZUNvb3JkLCAxLjApICApLnh5O1xcclxcbn1cXHJcXG5cIjtcclxuU3ByaXRlTWFza0ZpbHRlci5mcmFnbWVudCA9IFwidmFyeWluZyB2ZWMyIHZNYXNrQ29vcmQ7XFxyXFxudmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XFxyXFxuXFxyXFxudW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXI7XFxyXFxudW5pZm9ybSBzYW1wbGVyMkQgbWFzaztcXHJcXG51bmlmb3JtIGZsb2F0IGFscGhhO1xcclxcbnVuaWZvcm0gZmxvYXQgbnBtQWxwaGE7XFxyXFxudW5pZm9ybSB2ZWM0IG1hc2tDbGFtcDtcXHJcXG5cXHJcXG52b2lkIG1haW4odm9pZClcXHJcXG57XFxyXFxuICAgIGZsb2F0IGNsaXAgPSBzdGVwKDMuNSxcXHJcXG4gICAgICAgIHN0ZXAobWFza0NsYW1wLngsIHZNYXNrQ29vcmQueCkgK1xcclxcbiAgICAgICAgc3RlcChtYXNrQ2xhbXAueSwgdk1hc2tDb29yZC55KSArXFxyXFxuICAgICAgICBzdGVwKHZNYXNrQ29vcmQueCwgbWFza0NsYW1wLnopICtcXHJcXG4gICAgICAgIHN0ZXAodk1hc2tDb29yZC55LCBtYXNrQ2xhbXAudykpO1xcclxcblxcclxcbiAgICB2ZWM0IG9yaWdpbmFsID0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2VGV4dHVyZUNvb3JkKTtcXHJcXG4gICAgdmVjNCBtYXNreSA9IHRleHR1cmUyRChtYXNrLCB2TWFza0Nvb3JkKTtcXHJcXG4gICAgZmxvYXQgYWxwaGFNdWwgPSAxLjAgLSBucG1BbHBoYSAqICgxLjAgLSBtYXNreS5hKTtcXHJcXG5cXHJcXG4gICAgb3JpZ2luYWwgKj0gKGFscGhhTXVsICogbWFza3kuciAqIGFscGhhICogY2xpcCk7XFxyXFxuXFxyXFxuICAgIGdsX0ZyYWdDb2xvciA9IG9yaWdpbmFsO1xcclxcbn1cXHJcXG5cIjtcclxuZXhwb3J0cy5TcHJpdGVNYXNrRmlsdGVyID0gU3ByaXRlTWFza0ZpbHRlcjtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgUmVjdGFuZ2xlXzEgPSByZXF1aXJlKFwiLi9SZWN0YW5nbGVcIik7XHJcbmNvbnN0IFRleHR1cmVfMSA9IHJlcXVpcmUoXCIuL1RleHR1cmVcIik7XHJcbmNvbnN0IE5ldHdvcmtTZXR0aW5nc18xID0gcmVxdWlyZShcIi4vTmV0d29ya1NldHRpbmdzXCIpO1xyXG5jbGFzcyBTcHJpdGVzaGVldCB7XHJcbiAgICBjb25zdHJ1Y3RvcihiYXNlVGV4dHVyZSwgZGF0YSwgcmVzb2x1dGlvbkZpbGVuYW1lID0gbnVsbCkge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlZmVyZW5jZSB0byB0aHMgc291cmNlIHRleHR1cmVcclxuICAgICAgICAgKiBAdHlwZSB7UElYSS5CYXNlVGV4dHVyZX1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmJhc2VUZXh0dXJlID0gYmFzZVRleHR1cmU7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQSBtYXAgY29udGFpbmluZyBhbGwgdGV4dHVyZXMgb2YgdGhlIHNwcml0ZSBzaGVldC5cclxuICAgICAgICAgKiBDYW4gYmUgdXNlZCB0byBjcmVhdGUgYSB7QGxpbmsgUElYSS5TcHJpdGV8U3ByaXRlfTpcclxuICAgICAgICAgKiBgYGBqc1xyXG4gICAgICAgICAqIG5ldyBQSVhJLlNwcml0ZShzaGVldC50ZXh0dXJlc1tcImltYWdlLnBuZ1wiXSk7XHJcbiAgICAgICAgICogYGBgXHJcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMudGV4dHVyZXMgPSB7fTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBIG1hcCBjb250YWluaW5nIHRoZSB0ZXh0dXJlcyBmb3IgZWFjaCBhbmltYXRpb24uXHJcbiAgICAgICAgICogQ2FuIGJlIHVzZWQgdG8gY3JlYXRlIGFuIHtAbGluayBQSVhJLkFuaW1hdGVkU3ByaXRlfEFuaW1hdGVkU3ByaXRlfTpcclxuICAgICAgICAgKiBgYGBqc1xyXG4gICAgICAgICAqIG5ldyBQSVhJLkFuaW1hdGVkU3ByaXRlKHNoZWV0LmFuaW1hdGlvbnNbXCJhbmltX25hbWVcIl0pXHJcbiAgICAgICAgICogYGBgXHJcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuYW5pbWF0aW9ucyA9IHt9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlZmVyZW5jZSB0byB0aGUgb3JpZ2luYWwgSlNPTiBkYXRhLlxyXG4gICAgICAgICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgcmVzb2x1dGlvbiBvZiB0aGUgc3ByaXRlc2hlZXQuXHJcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnJlc29sdXRpb24gPSB0aGlzLl91cGRhdGVSZXNvbHV0aW9uKHJlc29sdXRpb25GaWxlbmFtZVxyXG4gICAgICAgICAgICB8fCAodGhpcy5iYXNlVGV4dHVyZS5yZXNvdXJjZSA/IHRoaXMuYmFzZVRleHR1cmUucmVzb3VyY2UudXJsIDogbnVsbCkpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIE1hcCBvZiBzcHJpdGVzaGVldCBmcmFtZXMuXHJcbiAgICAgICAgICogQHR5cGUge09iamVjdH1cclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuX2ZyYW1lcyA9IHRoaXMuZGF0YS5mcmFtZXM7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ29sbGVjdGlvbiBvZiBmcmFtZSBuYW1lcy5cclxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nW119XHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLl9mcmFtZUtleXMgPSBPYmplY3Qua2V5cyh0aGlzLl9mcmFtZXMpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEN1cnJlbnQgYmF0Y2ggaW5kZXggYmVpbmcgcHJvY2Vzc2VkLlxyXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLl9iYXRjaEluZGV4ID0gMDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDYWxsYmFjayB3aGVuIHBhcnNlIGlzIGNvbXBsZXRlZC5cclxuICAgICAgICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLl9jYWxsYmFjayA9IG51bGw7XHJcbiAgICB9XHJcbiAgICBfdXBkYXRlUmVzb2x1dGlvbihyZXNvbHV0aW9uRmlsZW5hbWUpIHtcclxuICAgICAgICB2YXIgc2NhbGUgPSB0aGlzLmRhdGEubWV0YS5zY2FsZTtcclxuICAgICAgICAvLyBVc2UgYSBkZWZhdWx0VmFsdWUgb2YgYG51bGxgIHRvIGNoZWNrIGlmIGEgdXJsLWJhc2VkIHJlc29sdXRpb24gaXMgc2V0XHJcbiAgICAgICAgdmFyIHJlc29sdXRpb24gPSBOZXR3b3JrU2V0dGluZ3NfMS5OZXR3b3JrU2V0dGluZ3MuZ2V0UmVzb2x1dGlvbk9mVXJsKHJlc29sdXRpb25GaWxlbmFtZSwgbnVsbCk7XHJcbiAgICAgICAgLy8gTm8gcmVzb2x1dGlvbiBmb3VuZCB2aWEgVVJMXHJcbiAgICAgICAgaWYgKHJlc29sdXRpb24gPT09IG51bGwpIHtcclxuICAgICAgICAgICAgLy8gVXNlIHRoZSBzY2FsZSB2YWx1ZSBvciBkZWZhdWx0IHRvIDFcclxuICAgICAgICAgICAgcmVzb2x1dGlvbiA9IHNjYWxlICE9PSB1bmRlZmluZWQgPyBwYXJzZUZsb2F0KHNjYWxlKSA6IDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEZvciBub24tMSByZXNvbHV0aW9ucywgdXBkYXRlIGJhc2VUZXh0dXJlXHJcbiAgICAgICAgaWYgKHJlc29sdXRpb24gIT09IDEpIHtcclxuICAgICAgICAgICAgdGhpcy5iYXNlVGV4dHVyZS5zZXRSZXNvbHV0aW9uKHJlc29sdXRpb24pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzb2x1dGlvbjtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogR2VuZXJhdGUgdGhlIHJlc29sdXRpb24gZnJvbSB0aGUgZmlsZW5hbWUgb3IgZmFsbGJhY2tcclxuICAgICAqIHRvIHRoZSBtZXRhLnNjYWxlIGZpZWxkIG9mIHRoZSBKU09OIGRhdGEuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSByZXNvbHV0aW9uRmlsZW5hbWUgLSBUaGUgZmlsZW5hbWUgdG8gdXNlIGZvciByZXNvbHZpbmdcclxuICAgICAqICAgIHRoZSBkZWZhdWx0IHJlc29sdXRpb24uXHJcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IFJlc29sdXRpb24gdG8gdXNlIGZvciBzcHJpdGVzaGVldC5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGdldCBCQVRDSF9TSVpFKCkge1xyXG4gICAgICAgIHJldHVybiAxMDAwO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBQYXJzZXIgc3ByaXRlc2hlZXQgZnJvbSBsb2FkZWQgZGF0YS4gVGhpcyBpcyBkb25lIGFzeW5jaHJvbm91c2x5XHJcbiAgICAgKiB0byBwcmV2ZW50IGNyZWF0aW5nIHRvbyBtYW55IFRleHR1cmUgd2l0aGluIGEgc2luZ2xlIHByb2Nlc3MuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBDYWxsYmFjayB3aGVuIGNvbXBsZXRlIHJldHVybnNcclxuICAgICAqICAgIGEgbWFwIG9mIHRoZSBUZXh0dXJlcyBmb3IgdGhpcyBzcHJpdGVzaGVldC5cclxuICAgICAqL1xyXG4gICAgcGFyc2UoY2FsbGJhY2spIHtcclxuICAgICAgICB0aGlzLl9iYXRjaEluZGV4ID0gMDtcclxuICAgICAgICB0aGlzLl9jYWxsYmFjayA9IGNhbGxiYWNrO1xyXG4gICAgICAgIGlmICh0aGlzLl9mcmFtZUtleXMubGVuZ3RoIDw9IFNwcml0ZXNoZWV0LkJBVENIX1NJWkUpIHtcclxuICAgICAgICAgICAgdGhpcy5fcHJvY2Vzc0ZyYW1lcygwKTtcclxuICAgICAgICAgICAgdGhpcy5fcHJvY2Vzc0FuaW1hdGlvbnMoKTtcclxuICAgICAgICAgICAgdGhpcy5fcGFyc2VDb21wbGV0ZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5fbmV4dEJhdGNoKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBQcm9jZXNzIGEgYmF0Y2ggb2YgZnJhbWVzXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbml0aWFsRnJhbWVJbmRleCAtIFRoZSBpbmRleCBvZiBmcmFtZSB0byBzdGFydC5cclxuICAgICAqL1xyXG4gICAgX3Byb2Nlc3NGcmFtZXMoaW5pdGlhbEZyYW1lSW5kZXgpIHtcclxuICAgICAgICB2YXIgZnJhbWVJbmRleCA9IGluaXRpYWxGcmFtZUluZGV4O1xyXG4gICAgICAgIHZhciBtYXhGcmFtZXMgPSBTcHJpdGVzaGVldC5CQVRDSF9TSVpFO1xyXG4gICAgICAgIHdoaWxlIChmcmFtZUluZGV4IC0gaW5pdGlhbEZyYW1lSW5kZXggPCBtYXhGcmFtZXMgJiYgZnJhbWVJbmRleCA8IHRoaXMuX2ZyYW1lS2V5cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgdmFyIGkgPSB0aGlzLl9mcmFtZUtleXNbZnJhbWVJbmRleF07XHJcbiAgICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5fZnJhbWVzW2ldO1xyXG4gICAgICAgICAgICB2YXIgcmVjdCA9IGRhdGEuZnJhbWU7XHJcbiAgICAgICAgICAgIGlmIChyZWN0KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZnJhbWUgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgdmFyIHRyaW0gPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgdmFyIHNvdXJjZVNpemUgPSBkYXRhLnRyaW1tZWQgIT09IGZhbHNlICYmIGRhdGEuc291cmNlU2l6ZVxyXG4gICAgICAgICAgICAgICAgICAgID8gZGF0YS5zb3VyY2VTaXplIDogZGF0YS5mcmFtZTtcclxuICAgICAgICAgICAgICAgIHZhciBvcmlnID0gbmV3IFJlY3RhbmdsZV8xLlJlY3RhbmdsZSgwLCAwLCBNYXRoLmZsb29yKHNvdXJjZVNpemUudykgLyB0aGlzLnJlc29sdXRpb24sIE1hdGguZmxvb3Ioc291cmNlU2l6ZS5oKSAvIHRoaXMucmVzb2x1dGlvbik7XHJcbiAgICAgICAgICAgICAgICBpZiAoZGF0YS5yb3RhdGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZnJhbWUgPSBuZXcgUmVjdGFuZ2xlXzEuUmVjdGFuZ2xlKE1hdGguZmxvb3IocmVjdC54KSAvIHRoaXMucmVzb2x1dGlvbiwgTWF0aC5mbG9vcihyZWN0LnkpIC8gdGhpcy5yZXNvbHV0aW9uLCBNYXRoLmZsb29yKHJlY3QuaCkgLyB0aGlzLnJlc29sdXRpb24sIE1hdGguZmxvb3IocmVjdC53KSAvIHRoaXMucmVzb2x1dGlvbik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBmcmFtZSA9IG5ldyBSZWN0YW5nbGVfMS5SZWN0YW5nbGUoTWF0aC5mbG9vcihyZWN0LngpIC8gdGhpcy5yZXNvbHV0aW9uLCBNYXRoLmZsb29yKHJlY3QueSkgLyB0aGlzLnJlc29sdXRpb24sIE1hdGguZmxvb3IocmVjdC53KSAvIHRoaXMucmVzb2x1dGlvbiwgTWF0aC5mbG9vcihyZWN0LmgpIC8gdGhpcy5yZXNvbHV0aW9uKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vICBDaGVjayB0byBzZWUgaWYgdGhlIHNwcml0ZSBpcyB0cmltbWVkXHJcbiAgICAgICAgICAgICAgICBpZiAoZGF0YS50cmltbWVkICE9PSBmYWxzZSAmJiBkYXRhLnNwcml0ZVNvdXJjZVNpemUpIHtcclxuICAgICAgICAgICAgICAgICAgICB0cmltID0gbmV3IFJlY3RhbmdsZV8xLlJlY3RhbmdsZShNYXRoLmZsb29yKGRhdGEuc3ByaXRlU291cmNlU2l6ZS54KSAvIHRoaXMucmVzb2x1dGlvbiwgTWF0aC5mbG9vcihkYXRhLnNwcml0ZVNvdXJjZVNpemUueSkgLyB0aGlzLnJlc29sdXRpb24sIE1hdGguZmxvb3IocmVjdC53KSAvIHRoaXMucmVzb2x1dGlvbiwgTWF0aC5mbG9vcihyZWN0LmgpIC8gdGhpcy5yZXNvbHV0aW9uKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMudGV4dHVyZXNbaV0gPSBuZXcgVGV4dHVyZV8xLlRleHR1cmUodGhpcy5iYXNlVGV4dHVyZSwgZnJhbWUsIG9yaWcsIHRyaW0sIGRhdGEucm90YXRlZCA/IDIgOiAwLCBkYXRhLmFuY2hvcik7XHJcbiAgICAgICAgICAgICAgICAvLyBsZXRzIGFsc28gYWRkIHRoZSBmcmFtZSB0byBwaXhpJ3MgZ2xvYmFsIGNhY2hlIGZvciBmcm9tRnJhbWUgYW5kIGZyb21JbWFnZSBmdW5jdGlvbnNcclxuICAgICAgICAgICAgICAgIFRleHR1cmVfMS5UZXh0dXJlLmFkZFRvQ2FjaGUodGhpcy50ZXh0dXJlc1tpXSwgaSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZnJhbWVJbmRleCsrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogUGFyc2UgYW5pbWF0aW9ucyBjb25maWdcclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBfcHJvY2Vzc0FuaW1hdGlvbnMoKSB7XHJcbiAgICAgICAgdmFyIGFuaW1hdGlvbnMgPSB0aGlzLmRhdGEuYW5pbWF0aW9ucyB8fCB7fTtcclxuICAgICAgICBmb3IgKHZhciBhbmltTmFtZSBpbiBhbmltYXRpb25zKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9uc1thbmltTmFtZV0gPSBbXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbmltYXRpb25zW2FuaW1OYW1lXS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGZyYW1lTmFtZSA9IGFuaW1hdGlvbnNbYW5pbU5hbWVdW2ldO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hbmltYXRpb25zW2FuaW1OYW1lXS5wdXNoKHRoaXMudGV4dHVyZXNbZnJhbWVOYW1lXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBwYXJzZSBoYXMgY29tcGxldGVkLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIF9wYXJzZUNvbXBsZXRlKCkge1xyXG4gICAgICAgIHZhciBjYWxsYmFjayA9IHRoaXMuX2NhbGxiYWNrO1xyXG4gICAgICAgIHRoaXMuX2NhbGxiYWNrID0gbnVsbDtcclxuICAgICAgICB0aGlzLl9iYXRjaEluZGV4ID0gMDtcclxuICAgICAgICBjYWxsYmFjay5jYWxsKHRoaXMsIHRoaXMudGV4dHVyZXMpO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBCZWdpbiB0aGUgbmV4dCBiYXRjaCBvZiB0ZXh0dXJlcy5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBfbmV4dEJhdGNoKCkge1xyXG4gICAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMuX3Byb2Nlc3NGcmFtZXModGhpcy5fYmF0Y2hJbmRleCAqIFNwcml0ZXNoZWV0LkJBVENIX1NJWkUpO1xyXG4gICAgICAgIHRoaXMuX2JhdGNoSW5kZXgrKztcclxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMkMS5fYmF0Y2hJbmRleCAqIFNwcml0ZXNoZWV0LkJBVENIX1NJWkUgPCB0aGlzJDEuX2ZyYW1lS2V5cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMkMS5fbmV4dEJhdGNoKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzJDEuX3Byb2Nlc3NBbmltYXRpb25zKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzJDEuX3BhcnNlQ29tcGxldGUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sIDApO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBEZXN0cm95IFNwcml0ZXNoZWV0IGFuZCBkb24ndCB1c2UgYWZ0ZXIgdGhpcy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtkZXN0cm95QmFzZT1mYWxzZV0gV2hldGhlciB0byBkZXN0cm95IHRoZSBiYXNlIHRleHR1cmUgYXMgd2VsbFxyXG4gICAgICovXHJcbiAgICBkZXN0cm95KGRlc3Ryb3lCYXNlKSB7XHJcbiAgICAgICAgaWYgKGRlc3Ryb3lCYXNlID09PSB2b2lkIDApIHtcclxuICAgICAgICAgICAgZGVzdHJveUJhc2UgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yICh2YXIgaSBpbiB0aGlzLnRleHR1cmVzKSB7XHJcbiAgICAgICAgICAgIHRoaXMudGV4dHVyZXNbaV0uZGVzdHJveSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9mcmFtZXMgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuX2ZyYW1lS2V5cyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5kYXRhID0gbnVsbDtcclxuICAgICAgICB0aGlzLnRleHR1cmVzID0gbnVsbDtcclxuICAgICAgICBpZiAoZGVzdHJveUJhc2UpIHtcclxuICAgICAgICAgICAgdGhpcy5iYXNlVGV4dHVyZS5kZXN0cm95KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuYmFzZVRleHR1cmUgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgO1xyXG59XHJcbmV4cG9ydHMuU3ByaXRlc2hlZXQgPSBTcHJpdGVzaGVldDtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY2xhc3MgU3RhZ2VPcHRpb25zIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMuc2hhcmVkTG9hZGVyID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5mb3JjZUNhbnZhcyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMudmlldyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5hbnRpYWxpYXMgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmZvcmNlRlhBQSA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuYXV0b0RlbnNpdHkgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuYXV0b1Jlc2l6ZSA9IHRydWU7XHJcbiAgICAgICAgdGhpcy50cmFuc3BhcmVudCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuYmFja2dyb3VuZENvbG9yID0gMHgwMDAwMDA7XHJcbiAgICAgICAgdGhpcy5jbGVhckJlZm9yZVJlbmRlciA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5hdXRvU3RhcnQgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMucHJlc2VydmVEcmF3aW5nQnVmZmVyID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy53aWR0aCA9IDEwMjQ7XHJcbiAgICAgICAgdGhpcy5oZWlnaHQgPSA3Njg7XHJcbiAgICAgICAgdGhpcy5yZXNvbHV0aW9uID0gMTtcclxuICAgICAgICB0aGlzLmxlZ2FjeSA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMucm91bmRQaXhlbHMgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnNoYXJlZFRpY2tlciA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuY29udGV4dCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5yZXNpemVUbyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5wb3dlclByZWZlcmVuY2UgPSBcImhpZ2gtcGVyZm9ybWFuY2VcIjtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLlN0YWdlT3B0aW9ucyA9IFN0YWdlT3B0aW9ucztcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgUG9seWdvbl8xID0gcmVxdWlyZShcIi4vUG9seWdvblwiKTtcclxuY29uc3QgTWF0aFNldHRpbmdzXzEgPSByZXF1aXJlKFwiLi9NYXRoU2V0dGluZ3NcIik7XHJcbmNsYXNzIFN0YXIgZXh0ZW5kcyBQb2x5Z29uXzEuUG9seWdvbiB7XHJcbiAgICBjb25zdHJ1Y3Rvcih4LCB5LCBwb2ludHMsIHJhZGl1cywgaW5uZXJSYWRpdXMsIHJvdGF0aW9uKSB7XHJcbiAgICAgICAgaW5uZXJSYWRpdXMgPSBpbm5lclJhZGl1cyB8fCByYWRpdXMgLyAyO1xyXG4gICAgICAgIHZhciBzdGFydEFuZ2xlID0gKC0xICogTWF0aC5QSSAvIDIpICsgcm90YXRpb247XHJcbiAgICAgICAgdmFyIGxlbiA9IHBvaW50cyAqIDI7XHJcbiAgICAgICAgdmFyIGRlbHRhID0gTWF0aFNldHRpbmdzXzEuTWF0aFNldHRpbmdzLlBJXzIgLyBsZW47XHJcbiAgICAgICAgdmFyIHBvbHlnb24gPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciByID0gaSAlIDIgPyBpbm5lclJhZGl1cyA6IHJhZGl1cztcclxuICAgICAgICAgICAgdmFyIGFuZ2xlID0gKGkgKiBkZWx0YSkgKyBzdGFydEFuZ2xlO1xyXG4gICAgICAgICAgICBwb2x5Z29uLnB1c2goeCArIChyICogTWF0aC5jb3MoYW5nbGUpKSwgeSArIChyICogTWF0aC5zaW4oYW5nbGUpKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN1cGVyKHBvbHlnb24pO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuU3RhciA9IFN0YXI7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IEJsZW5kTW9kZXNTZXR0aW5nc18xID0gcmVxdWlyZShcIi4vQmxlbmRNb2Rlc1NldHRpbmdzXCIpO1xyXG5jbGFzcyBTdGF0ZSB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLmRhdGEgPSAwO1xyXG4gICAgICAgIHRoaXMuYmxlbmRNb2RlID0gQmxlbmRNb2Rlc1NldHRpbmdzXzEuQmxlbmRNb2Rlc1NldHRpbmdzLkJMRU5EX01PREVTLk5PUk1BTDtcclxuICAgICAgICB0aGlzLnBvbHlnb25PZmZzZXQgPSAwO1xyXG4gICAgICAgIHRoaXMuYmxlbmQgPSB0cnVlO1xyXG4gICAgICAgIC8vICB0aGlzLmRlcHRoVGVzdCA9IHRydWU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFjdGl2YXRlcyBibGVuZGluZyBvZiB0aGUgY29tcHV0ZWQgZnJhZ21lbnQgY29sb3IgdmFsdWVzXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgZ2V0IGJsZW5kKCkge1xyXG4gICAgICAgIHJldHVybiAhISh0aGlzLmRhdGEgJiAoMSA8PCBTdGF0ZS5CTEVORCkpO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgc2V0IGJsZW5kKHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKCEhKHRoaXMuZGF0YSAmICgxIDw8IFN0YXRlLkJMRU5EKSkgIT09IHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGF0YSBePSAoMSA8PCBTdGF0ZS5CTEVORCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBY3RpdmF0ZXMgYWRkaW5nIGFuIG9mZnNldCB0byBkZXB0aCB2YWx1ZXMgb2YgcG9seWdvbidzIGZyYWdtZW50c1xyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XHJcbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxyXG4gICAgICovXHJcbiAgICBnZXQgb2Zmc2V0cygpIHtcclxuICAgICAgICByZXR1cm4gISEodGhpcy5kYXRhICYgKDEgPDwgU3RhdGUuT0ZGU0VUKSk7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICBzZXQgb2Zmc2V0cyh2YWx1ZSkge1xyXG4gICAgICAgIGlmICghISh0aGlzLmRhdGEgJiAoMSA8PCBTdGF0ZS5PRkZTRVQpKSAhPT0gdmFsdWUpIHtcclxuICAgICAgICAgICAgdGhpcy5kYXRhIF49ICgxIDw8IFN0YXRlLk9GRlNFVCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBY3RpdmF0ZXMgY3VsbGluZyBvZiBwb2x5Z29ucy5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtib29sZWFufVxyXG4gICAgICogQGRlZmF1bHQgZmFsc2VcclxuICAgICAqL1xyXG4gICAgZ2V0IGN1bGxpbmcoKSB7XHJcbiAgICAgICAgcmV0dXJuICEhKHRoaXMuZGF0YSAmICgxIDw8IFN0YXRlLkNVTExJTkcpKTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIHNldCBjdWxsaW5nKHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKCEhKHRoaXMuZGF0YSAmICgxIDw8IFN0YXRlLkNVTExJTkcpKSAhPT0gdmFsdWUpIHtcclxuICAgICAgICAgICAgdGhpcy5kYXRhIF49ICgxIDw8IFN0YXRlLkNVTExJTkcpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQWN0aXZhdGVzIGRlcHRoIGNvbXBhcmlzb25zIGFuZCB1cGRhdGVzIHRvIHRoZSBkZXB0aCBidWZmZXIuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7Ym9vbGVhbn1cclxuICAgICAqIEBkZWZhdWx0IGZhbHNlXHJcbiAgICAgKi9cclxuICAgIGdldCBkZXB0aFRlc3QoKSB7XHJcbiAgICAgICAgcmV0dXJuICEhKHRoaXMuZGF0YSAmICgxIDw8IFN0YXRlLkRFUFRIX1RFU1QpKTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIHNldCBkZXB0aFRlc3QodmFsdWUpIHtcclxuICAgICAgICBpZiAoISEodGhpcy5kYXRhICYgKDEgPDwgU3RhdGUuREVQVEhfVEVTVCkpICE9PSB2YWx1ZSkge1xyXG4gICAgICAgICAgICB0aGlzLmRhdGEgXj0gKDEgPDwgU3RhdGUuREVQVEhfVEVTVCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgZnJvbnQgb3IgYmFjay1mYWNpbmcgcG9seWdvbnMgY2FuIGJlIGN1bGxlZC5cclxuICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XHJcbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxyXG4gICAgICovXHJcbiAgICBnZXQgY2xvY2t3aXNlRnJvbnRGYWNlKCkge1xyXG4gICAgICAgIHJldHVybiAhISh0aGlzLmRhdGEgJiAoMSA8PCBTdGF0ZS5XSU5ESU5HKSk7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICBzZXQgY2xvY2t3aXNlRnJvbnRGYWNlKHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKCEhKHRoaXMuZGF0YSAmICgxIDw8IFN0YXRlLldJTkRJTkcpKSAhPT0gdmFsdWUpIHtcclxuICAgICAgICAgICAgdGhpcy5kYXRhIF49ICgxIDw8IFN0YXRlLldJTkRJTkcpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGJsZW5kIG1vZGUgdG8gYmUgYXBwbGllZCB3aGVuIHRoaXMgc3RhdGUgaXMgc2V0LiBBcHBseSBhIHZhbHVlIG9mIGBQSVhJLkJMRU5EX01PREVTLk5PUk1BTGAgdG8gcmVzZXQgdGhlIGJsZW5kIG1vZGUuXHJcbiAgICAgKiBTZXR0aW5nIHRoaXMgbW9kZSB0byBhbnl0aGluZyBvdGhlciB0aGFuIE5PX0JMRU5EIHdpbGwgYXV0b21hdGljYWxseSBzd2l0Y2ggYmxlbmRpbmcgb24uXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7Ym9vbGVhbn1cclxuICAgICAqIEBkZWZhdWx0IFBJWEkuQkxFTkRfTU9ERVMuTk9STUFMXHJcbiAgICAgKiBAc2VlIFBJWEkuQkxFTkRfTU9ERVNcclxuICAgICAqL1xyXG4gICAgZ2V0IGJsZW5kTW9kZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fYmxlbmRNb2RlO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgc2V0IGJsZW5kTW9kZSh2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuYmxlbmQgPSAodmFsdWUgIT09IEJsZW5kTW9kZXNTZXR0aW5nc18xLkJsZW5kTW9kZXNTZXR0aW5ncy5CTEVORF9NT0RFUy5OT05FKTtcclxuICAgICAgICB0aGlzLl9ibGVuZE1vZGUgPSB2YWx1ZTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIHBvbHlnb24gb2Zmc2V0LiBTZXR0aW5nIHRoaXMgcHJvcGVydHkgdG8gYW55dGhpbmcgb3RoZXIgdGhhbiAwIHdpbGwgYXV0b21hdGljYWxseSBlbmFibGUgcG9seWdvbiBvZmZzZXQgZmlsbC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgKiBAZGVmYXVsdCAwXHJcbiAgICAgKi9cclxuICAgIGdldCBwb2x5Z29uT2Zmc2V0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9wb2x5Z29uT2Zmc2V0O1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgc2V0IHBvbHlnb25PZmZzZXQodmFsdWUpIHtcclxuICAgICAgICB0aGlzLm9mZnNldHMgPSAhIXZhbHVlO1xyXG4gICAgICAgIHRoaXMuX3BvbHlnb25PZmZzZXQgPSB2YWx1ZTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIHN0YXRpYyBmb3IyZCgpIHtcclxuICAgICAgICB2YXIgc3RhdGUgPSBuZXcgU3RhdGUoKTtcclxuICAgICAgICBzdGF0ZS5kZXB0aFRlc3QgPSBmYWxzZTtcclxuICAgICAgICBzdGF0ZS5ibGVuZCA9IHRydWU7XHJcbiAgICAgICAgcmV0dXJuIHN0YXRlO1xyXG4gICAgfVxyXG4gICAgO1xyXG59XHJcblN0YXRlLkJMRU5EID0gMDtcclxuU3RhdGUuT0ZGU0VUID0gMTtcclxuU3RhdGUuQ1VMTElORyA9IDI7XHJcblN0YXRlLkRFUFRIX1RFU1QgPSAzO1xyXG5TdGF0ZS5XSU5ESU5HID0gNDtcclxuZXhwb3J0cy5TdGF0ZSA9IFN0YXRlO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBTeXN0ZW1fMSA9IHJlcXVpcmUoXCIuL1N5c3RlbVwiKTtcclxuY29uc3QgU3RhdGVfMSA9IHJlcXVpcmUoXCIuL1N0YXRlXCIpO1xyXG5jb25zdCBCbGVuZE1vZGVzU2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL0JsZW5kTW9kZXNTZXR0aW5nc1wiKTtcclxuY2xhc3MgU3RhdGVTeXN0ZW0gZXh0ZW5kcyBTeXN0ZW1fMS5TeXN0ZW0ge1xyXG4gICAgY29uc3RydWN0b3IocmVuZGVyZXIpIHtcclxuICAgICAgICBzdXBlcihyZW5kZXJlcik7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR0wgY29udGV4dFxyXG4gICAgICAgICAqIEBtZW1iZXIge1dlYkdMUmVuZGVyaW5nQ29udGV4dH1cclxuICAgICAgICAgKiBAcmVhZG9ubHlcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmdsID0gbnVsbDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTdGF0ZSBJRFxyXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAgICAgKiBAcmVhZG9ubHlcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnN0YXRlSWQgPSAwO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFBvbHlnb24gb2Zmc2V0XHJcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICAgICAqIEByZWFkb25seVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMucG9seWdvbk9mZnNldCA9IDA7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQmxlbmQgbW9kZVxyXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAgICAgKiBAZGVmYXVsdCBQSVhJLkJMRU5EX01PREVTLk5PTkVcclxuICAgICAgICAgKiBAcmVhZG9ubHlcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmJsZW5kTW9kZSA9IEJsZW5kTW9kZXNTZXR0aW5nc18xLkJsZW5kTW9kZXNTZXR0aW5ncy5CTEVORF9NT0RFUy5OT05FO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFdoZXRoZXIgY3VycmVudCBibGVuZCBlcXVhdGlvbiBpcyBkaWZmZXJlbnRcclxuICAgICAgICAgKiBAbWVtYmVyIHtib29sZWFufVxyXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLl9ibGVuZEVxID0gZmFsc2U7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ29sbGVjdGlvbiBvZiBjYWxsc1xyXG4gICAgICAgICAqIEBtZW1iZXIge2Z1bmN0aW9uW119XHJcbiAgICAgICAgICogQHJlYWRvbmx5XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5tYXAgPSBbXTtcclxuICAgICAgICAvLyBtYXAgZnVuY3Rpb25zIGZvciB3aGVuIHdlIHNldCBzdGF0ZS4uXHJcbiAgICAgICAgdGhpcy5tYXBbU3RhdGVTeXN0ZW0uQkxFTkQkMV0gPSB0aGlzLnNldEJsZW5kO1xyXG4gICAgICAgIHRoaXMubWFwW1N0YXRlU3lzdGVtLk9GRlNFVCQxXSA9IHRoaXMuc2V0T2Zmc2V0O1xyXG4gICAgICAgIHRoaXMubWFwW1N0YXRlU3lzdGVtLkNVTExJTkckMV0gPSB0aGlzLnNldEN1bGxGYWNlO1xyXG4gICAgICAgIHRoaXMubWFwW1N0YXRlU3lzdGVtLkRFUFRIX1RFU1QkMV0gPSB0aGlzLnNldERlcHRoVGVzdDtcclxuICAgICAgICB0aGlzLm1hcFtTdGF0ZVN5c3RlbS5XSU5ESU5HJDFdID0gdGhpcy5zZXRGcm9udEZhY2U7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ29sbGVjdGlvbiBvZiBjaGVjayBjYWxsc1xyXG4gICAgICAgICAqIEBtZW1iZXIge2Z1bmN0aW9uW119XHJcbiAgICAgICAgICogQHJlYWRvbmx5XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5jaGVja3MgPSBbXTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBEZWZhdWx0IFdlYkdMIFN0YXRlXHJcbiAgICAgICAgICogQG1lbWJlciB7UElYSS5TdGF0ZX1cclxuICAgICAgICAgKiBAcmVhZG9ubHlcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmRlZmF1bHRTdGF0ZSA9IG5ldyBTdGF0ZV8xLlN0YXRlKCk7XHJcbiAgICAgICAgdGhpcy5kZWZhdWx0U3RhdGUuYmxlbmQgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuZGVmYXVsdFN0YXRlLmRlcHRoID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIGNvbnRleHRDaGFuZ2UoZ2wpIHtcclxuICAgICAgICB0aGlzLmdsID0gZ2w7XHJcbiAgICAgICAgdGhpcy5ibGVuZE1vZGVzID0gQmxlbmRNb2Rlc1NldHRpbmdzXzEuQmxlbmRNb2Rlc1NldHRpbmdzLm1hcFdlYkdMQmxlbmRNb2Rlc1RvUGl4aShnbCk7XHJcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh0aGlzLmRlZmF1bHRTdGF0ZSk7XHJcbiAgICAgICAgdGhpcy5yZXNldCgpO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBjdXJyZW50IHN0YXRlXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHsqfSBzdGF0ZSAtIFRoZSBzdGF0ZSB0byBzZXQuXHJcbiAgICAgKi9cclxuICAgIHNldFN0YXRlKHN0YXRlKSB7XHJcbiAgICAgICAgc3RhdGUgPSBzdGF0ZSB8fCB0aGlzLmRlZmF1bHRTdGF0ZTtcclxuICAgICAgICAvLyBUT0RPIG1heWJlIHRvIGFuIG9iamVjdCBjaGVjaz8gKCB0aGlzLnN0YXRlID09PSBzdGF0ZSApP1xyXG4gICAgICAgIGlmICh0aGlzLnN0YXRlSWQgIT09IHN0YXRlLmRhdGEpIHtcclxuICAgICAgICAgICAgdmFyIGRpZmYgPSB0aGlzLnN0YXRlSWQgXiBzdGF0ZS5kYXRhO1xyXG4gICAgICAgICAgICB2YXIgaSA9IDA7XHJcbiAgICAgICAgICAgIC8vIG9yZGVyIGZyb20gbGVhc3QgdG8gbW9zdCBjb21tb25cclxuICAgICAgICAgICAgd2hpbGUgKGRpZmYpIHtcclxuICAgICAgICAgICAgICAgIGlmIChkaWZmICYgMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHN0YXRlIGNoYW5nZSFcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hcFtpXS5jYWxsKHRoaXMsICEhKHN0YXRlLmRhdGEgJiAoMSA8PCBpKSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZGlmZiA9IGRpZmYgPj4gMTtcclxuICAgICAgICAgICAgICAgIGkrKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnN0YXRlSWQgPSBzdGF0ZS5kYXRhO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBiYXNlZCBvbiB0aGUgYWJvdmUgc2V0dGluZ3Mgd2UgY2hlY2sgZm9yIHNwZWNpZmljIG1vZGVzLi5cclxuICAgICAgICAvLyBmb3IgZXhhbXBsZSBpZiBibGVuZCBpcyBhY3RpdmUgd2UgY2hlY2sgYW5kIHNldCB0aGUgYmxlbmQgbW9kZXNcclxuICAgICAgICAvLyBvciBvZiBwb2x5Z29uIG9mZnNldCBpcyBhY3RpdmUgd2UgY2hlY2sgdGhlIHBvbHkgZGVwdGguXHJcbiAgICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgdGhpcy5jaGVja3MubGVuZ3RoOyBpJDErKykge1xyXG4gICAgICAgICAgICB0aGlzLmNoZWNrc1tpJDFdKHRoaXMsIHN0YXRlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIHN0YXRlLCB3aGVuIHByZXZpb3VzIHN0YXRlIGlzIHVua25vd25cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0geyp9IHN0YXRlIC0gVGhlIHN0YXRlIHRvIHNldFxyXG4gICAgICovXHJcbiAgICBmb3JjZVN0YXRlKHN0YXRlKSB7XHJcbiAgICAgICAgc3RhdGUgPSBzdGF0ZSB8fCB0aGlzLmRlZmF1bHRTdGF0ZTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubWFwLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHRoaXMubWFwW2ldLmNhbGwodGhpcywgISEoc3RhdGUuZGF0YSAmICgxIDw8IGkpKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IHRoaXMuY2hlY2tzLmxlbmd0aDsgaSQxKyspIHtcclxuICAgICAgICAgICAgdGhpcy5jaGVja3NbaSQxXSh0aGlzLCBzdGF0ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuc3RhdGVJZCA9IHN0YXRlLmRhdGE7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIEVuYWJsZXMgb3IgZGlzYWJsZWQgYmxlbmRpbmcuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSB2YWx1ZSAtIFR1cm4gb24gb3Igb2ZmIHdlYmdsIGJsZW5kaW5nLlxyXG4gICAgICovXHJcbiAgICBzZXRCbGVuZCh2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMudXBkYXRlQ2hlY2soU3RhdGVTeXN0ZW0uY2hlY2tCbGVuZE1vZGUsIHZhbHVlKTtcclxuICAgICAgICB0aGlzLmdsW3ZhbHVlID8gJ2VuYWJsZScgOiAnZGlzYWJsZSddKHRoaXMuZ2wuQkxFTkQpO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBFbmFibGVzIG9yIGRpc2FibGUgcG9seWdvbiBvZmZzZXQgZmlsbFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gdmFsdWUgLSBUdXJuIG9uIG9yIG9mZiB3ZWJnbCBwb2x5Z29uIG9mZnNldCB0ZXN0aW5nLlxyXG4gICAgICovXHJcbiAgICBzZXRPZmZzZXQodmFsdWUpIHtcclxuICAgICAgICB0aGlzLmdsW3ZhbHVlID8gJ2VuYWJsZScgOiAnZGlzYWJsZSddKHRoaXMuZ2wuUE9MWUdPTl9PRkZTRVRfRklMTCk7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFNldHMgd2hldGhlciB0byBlbmFibGUgb3IgZGlzYWJsZSBkZXB0aCB0ZXN0LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gdmFsdWUgLSBUdXJuIG9uIG9yIG9mZiB3ZWJnbCBkZXB0aCB0ZXN0aW5nLlxyXG4gICAgICovXHJcbiAgICBzZXREZXB0aFRlc3QodmFsdWUpIHtcclxuICAgICAgICB0aGlzLmdsW3ZhbHVlID8gJ2VuYWJsZScgOiAnZGlzYWJsZSddKHRoaXMuZ2wuREVQVEhfVEVTVCk7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFNldHMgd2hldGhlciB0byBlbmFibGUgb3IgZGlzYWJsZSBjdWxsIGZhY2UuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSB2YWx1ZSAtIFR1cm4gb24gb3Igb2ZmIHdlYmdsIGN1bGwgZmFjZS5cclxuICAgICAqL1xyXG4gICAgc2V0Q3VsbEZhY2UodmFsdWUpIHtcclxuICAgICAgICB0aGlzLmdsW3ZhbHVlID8gJ2VuYWJsZScgOiAnZGlzYWJsZSddKHRoaXMuZ2wuQ1VMTF9GQUNFKTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgZ2wgZnJvbnQgZmFjZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHZhbHVlIC0gdHJ1ZSBpcyBjbG9ja3dpc2UgYW5kIGZhbHNlIGlzIGNvdW50ZXItY2xvY2t3aXNlXHJcbiAgICAgKi9cclxuICAgIHNldEZyb250RmFjZSh2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuZ2wuZnJvbnRGYWNlKHRoaXMuZ2xbdmFsdWUgPyAnQ1cnIDogJ0NDVyddKTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgYmxlbmQgbW9kZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgLSBUaGUgYmxlbmQgbW9kZSB0byBzZXQgdG8uXHJcbiAgICAgKi9cclxuICAgIHNldEJsZW5kTW9kZSh2YWx1ZSkge1xyXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdGhpcy5ibGVuZE1vZGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmJsZW5kTW9kZSA9IHZhbHVlO1xyXG4gICAgICAgIHZhciBtb2RlID0gdGhpcy5ibGVuZE1vZGVzW3ZhbHVlXTtcclxuICAgICAgICB2YXIgZ2wgPSB0aGlzLmdsO1xyXG4gICAgICAgIGlmIChtb2RlLmxlbmd0aCA9PT0gMikge1xyXG4gICAgICAgICAgICBnbC5ibGVuZEZ1bmMobW9kZVswXSwgbW9kZVsxXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBnbC5ibGVuZEZ1bmNTZXBhcmF0ZShtb2RlWzBdLCBtb2RlWzFdLCBtb2RlWzJdLCBtb2RlWzNdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG1vZGUubGVuZ3RoID09PSA2KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2JsZW5kRXEgPSB0cnVlO1xyXG4gICAgICAgICAgICBnbC5ibGVuZEVxdWF0aW9uU2VwYXJhdGUobW9kZVs0XSwgbW9kZVs1XSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX2JsZW5kRXEpIHtcclxuICAgICAgICAgICAgdGhpcy5fYmxlbmRFcSA9IGZhbHNlO1xyXG4gICAgICAgICAgICBnbC5ibGVuZEVxdWF0aW9uU2VwYXJhdGUoZ2wuRlVOQ19BREQsIGdsLkZVTkNfQUREKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIHBvbHlnb24gb2Zmc2V0LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSAtIHRoZSBwb2x5Z29uIG9mZnNldFxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNjYWxlIC0gdGhlIHBvbHlnb24gb2Zmc2V0IHNjYWxlXHJcbiAgICAgKi9cclxuICAgIHNldFBvbHlnb25PZmZzZXQodmFsdWUsIHNjYWxlKSB7XHJcbiAgICAgICAgdGhpcy5nbC5wb2x5Z29uT2Zmc2V0KHZhbHVlLCBzY2FsZSk7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvLyB1c2VkXHJcbiAgICAvKipcclxuICAgICAqIFJlc2V0cyBhbGwgdGhlIGxvZ2ljIGFuZCBkaXNhYmxlcyB0aGUgdmFvc1xyXG4gICAgICovXHJcbiAgICByZXNldCgpIHtcclxuICAgICAgICB0aGlzLmdsLnBpeGVsU3RvcmVpKHRoaXMuZ2wuVU5QQUNLX0ZMSVBfWV9XRUJHTCwgZmFsc2UpO1xyXG4gICAgICAgIHRoaXMuZm9yY2VTdGF0ZSgwKTtcclxuICAgICAgICB0aGlzLl9ibGVuZEVxID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmJsZW5kTW9kZSA9IC0xO1xyXG4gICAgICAgIHRoaXMuc2V0QmxlbmRNb2RlKDApO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBjaGVja3MgdG8gc2VlIHdoaWNoIHVwZGF0ZXMgc2hvdWxkIGJlIGNoZWNrZWQgYmFzZWQgb24gd2hpY2ggc2V0dGluZ3MgaGF2ZSBiZWVuIGFjdGl2YXRlZC5cclxuICAgICAqIEZvciBleGFtcGxlLCBpZiBibGVuZCBpcyBlbmFibGVkIHRoZW4gd2Ugc2hvdWxkIGNoZWNrIHRoZSBibGVuZCBtb2RlcyBlYWNoIHRpbWUgdGhlIHN0YXRlIGlzIGNoYW5nZWRcclxuICAgICAqIG9yIGlmIHBvbHlnb24gZmlsbCBpcyBhY3RpdmF0ZWQgdGhlbiB3ZSBuZWVkIHRvIGNoZWNrIGlmIHRoZSBwb2x5Z29uIG9mZnNldCBjaGFuZ2VzLlxyXG4gICAgICogVGhlIGlkZWEgaXMgdGhhdCB3ZSBvbmx5IGNoZWNrIHdoYXQgd2UgaGF2ZSB0b28uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyAgdGhlIGNoZWNraW5nIGZ1bmN0aW9uIHRvIGFkZCBvciByZW1vdmVcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gdmFsdWUgIHNob3VsZCB0aGUgY2hlY2sgZnVuY3Rpb24gYmUgYWRkZWQgb3IgcmVtb3ZlZC5cclxuICAgICAqL1xyXG4gICAgdXBkYXRlQ2hlY2soZnVuYywgdmFsdWUpIHtcclxuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmNoZWNrcy5pbmRleE9mKGZ1bmMpO1xyXG4gICAgICAgIGlmICh2YWx1ZSAmJiBpbmRleCA9PT0gLTEpIHtcclxuICAgICAgICAgICAgdGhpcy5jaGVja3MucHVzaChmdW5jKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoIXZhbHVlICYmIGluZGV4ICE9PSAtMSkge1xyXG4gICAgICAgICAgICB0aGlzLmNoZWNrcy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQSBwcml2YXRlIGxpdHRsZSB3cmFwcGVyIGZ1bmN0aW9uIHRoYXQgd2UgY2FsbCB0byBjaGVjayB0aGUgYmxlbmQgbW9kZS5cclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtQSVhJLlN0YXRlU3lzdGVtfSBTeXN0ZW0gIHRoZSBTeXN0ZW0gdG8gcGVyZm9ybSB0aGUgc3RhdGUgY2hlY2sgb25cclxuICAgICAqIEBwYXJhbSB7UElYSS5TdGF0ZX0gc3RhdGUgIHRoZSBzdGF0ZSB0aGF0IHRoZSBibGVuZE1vZGUgd2lsbCBwdWxsZWQgZnJvbVxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgY2hlY2tCbGVuZE1vZGUoc3lzdGVtLCBzdGF0ZSkge1xyXG4gICAgICAgIHN5c3RlbS5zZXRCbGVuZE1vZGUoc3RhdGUuYmxlbmRNb2RlKTtcclxuICAgIH1cclxuICAgIDtcclxufVxyXG5TdGF0ZVN5c3RlbS5VSUQkNCA9IDA7XHJcblN0YXRlU3lzdGVtLkJMRU5EJDEgPSAwO1xyXG5TdGF0ZVN5c3RlbS5PRkZTRVQkMSA9IDE7XHJcblN0YXRlU3lzdGVtLkNVTExJTkckMSA9IDI7XHJcblN0YXRlU3lzdGVtLkRFUFRIX1RFU1QkMSA9IDM7XHJcblN0YXRlU3lzdGVtLldJTkRJTkckMSA9IDQ7XHJcbmV4cG9ydHMuU3RhdGVTeXN0ZW0gPSBTdGF0ZVN5c3RlbTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgU3lzdGVtXzEgPSByZXF1aXJlKFwiLi9TeXN0ZW1cIik7XHJcbmNsYXNzIFN0ZW5jaWxTeXN0ZW0gZXh0ZW5kcyBTeXN0ZW1fMS5TeXN0ZW0ge1xyXG4gICAgY29uc3RydWN0b3IocmVuZGVyZXIpIHtcclxuICAgICAgICBzdXBlcihyZW5kZXJlcik7XHJcbiAgICAgICAgdGhpcy5zdGVuY2lsTWFza1N0YWNrID0gW107XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENoYW5nZXMgdGhlIG1hc2sgc3RhY2sgdGhhdCBpcyB1c2VkIGJ5IHRoaXMgU3lzdGVtLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7UElYSS5HcmFwaGljc1tdfSBzdGVuY2lsTWFza1N0YWNrIC0gVGhlIG1hc2sgc3RhY2tcclxuICAgICAqL1xyXG4gICAgc2V0TWFza1N0YWNrKHN0ZW5jaWxNYXNrU3RhY2spIHtcclxuICAgICAgICB2YXIgZ2wgPSB0aGlzLnJlbmRlcmVyLmdsO1xyXG4gICAgICAgIGlmIChzdGVuY2lsTWFza1N0YWNrLmxlbmd0aCAhPT0gdGhpcy5zdGVuY2lsTWFza1N0YWNrLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBpZiAoc3RlbmNpbE1hc2tTdGFjay5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgIGdsLmRpc2FibGUoZ2wuU1RFTkNJTF9URVNUKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGdsLmVuYWJsZShnbC5TVEVOQ0lMX1RFU1QpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuc3RlbmNpbE1hc2tTdGFjayA9IHN0ZW5jaWxNYXNrU3RhY2s7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIEFwcGxpZXMgdGhlIE1hc2sgYW5kIGFkZHMgaXQgdG8gdGhlIGN1cnJlbnQgc3RlbmNpbCBzdGFjay4gQGFsdmluXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtQSVhJLkdyYXBoaWNzfSBncmFwaGljcyAtIFRoZSBtYXNrXHJcbiAgICAgKi9cclxuICAgIHB1c2hTdGVuY2lsKGdyYXBoaWNzKSB7XHJcbiAgICAgICAgdmFyIGdsID0gdGhpcy5yZW5kZXJlci5nbDtcclxuICAgICAgICB2YXIgcHJldk1hc2tDb3VudCA9IHRoaXMuc3RlbmNpbE1hc2tTdGFjay5sZW5ndGg7XHJcbiAgICAgICAgaWYgKHByZXZNYXNrQ291bnQgPT09IDApIHtcclxuICAgICAgICAgICAgZ2wuZW5hYmxlKGdsLlNURU5DSUxfVEVTVCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuc3RlbmNpbE1hc2tTdGFjay5wdXNoKGdyYXBoaWNzKTtcclxuICAgICAgICAvLyBJbmNyZW1lbnQgdGhlIHJlZmVyZW5jZSBzdGVuY2lsIHZhbHVlIHdoZXJlIHRoZSBuZXcgbWFzayBvdmVybGFwcyB3aXRoIHRoZSBvbGQgb25lcy5cclxuICAgICAgICBnbC5jb2xvck1hc2soZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2UpO1xyXG4gICAgICAgIGdsLnN0ZW5jaWxGdW5jKGdsLkVRVUFMLCBwcmV2TWFza0NvdW50LCB0aGlzLl9nZXRCaXR3aXNlTWFzaygpKTtcclxuICAgICAgICBnbC5zdGVuY2lsT3AoZ2wuS0VFUCwgZ2wuS0VFUCwgZ2wuSU5DUik7XHJcbiAgICAgICAgZ3JhcGhpY3MucmVuZGVyYWJsZSA9IHRydWU7XHJcbiAgICAgICAgZ3JhcGhpY3MucmVuZGVyKHRoaXMucmVuZGVyZXIpO1xyXG4gICAgICAgIHRoaXMucmVuZGVyZXIuYmF0Y2guZmx1c2goKTtcclxuICAgICAgICBncmFwaGljcy5yZW5kZXJhYmxlID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fdXNlQ3VycmVudCgpO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIHRoZSBsYXN0IG1hc2sgZnJvbSB0aGUgc3RlbmNpbCBzdGFjay4gQGFsdmluXHJcbiAgICAgKi9cclxuICAgIHBvcFN0ZW5jaWwoKSB7XHJcbiAgICAgICAgdmFyIGdsID0gdGhpcy5yZW5kZXJlci5nbDtcclxuICAgICAgICB2YXIgZ3JhcGhpY3MgPSB0aGlzLnN0ZW5jaWxNYXNrU3RhY2sucG9wKCk7XHJcbiAgICAgICAgaWYgKHRoaXMuc3RlbmNpbE1hc2tTdGFjay5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgLy8gdGhlIHN0YWNrIGlzIGVtcHR5IVxyXG4gICAgICAgICAgICBnbC5kaXNhYmxlKGdsLlNURU5DSUxfVEVTVCk7XHJcbiAgICAgICAgICAgIGdsLmNsZWFyKGdsLlNURU5DSUxfQlVGRkVSX0JJVCk7XHJcbiAgICAgICAgICAgIGdsLmNsZWFyU3RlbmNpbCgwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIERlY3JlbWVudCB0aGUgcmVmZXJlbmNlIHN0ZW5jaWwgdmFsdWUgd2hlcmUgdGhlIHBvcHBlZCBtYXNrIG92ZXJsYXBzIHdpdGggdGhlIG90aGVyIG9uZXNcclxuICAgICAgICAgICAgZ2wuY29sb3JNYXNrKGZhbHNlLCBmYWxzZSwgZmFsc2UsIGZhbHNlKTtcclxuICAgICAgICAgICAgZ2wuc3RlbmNpbE9wKGdsLktFRVAsIGdsLktFRVAsIGdsLkRFQ1IpO1xyXG4gICAgICAgICAgICBncmFwaGljcy5yZW5kZXJhYmxlID0gdHJ1ZTtcclxuICAgICAgICAgICAgZ3JhcGhpY3MucmVuZGVyKHRoaXMucmVuZGVyZXIpO1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLmJhdGNoLmZsdXNoKCk7XHJcbiAgICAgICAgICAgIGdyYXBoaWNzLnJlbmRlcmFibGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5fdXNlQ3VycmVudCgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogU2V0dXAgcmVuZGVyZXIgdG8gdXNlIHRoZSBjdXJyZW50IHN0ZW5jaWwgZGF0YS5cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIF91c2VDdXJyZW50KCkge1xyXG4gICAgICAgIHZhciBnbCA9IHRoaXMucmVuZGVyZXIuZ2w7XHJcbiAgICAgICAgZ2wuY29sb3JNYXNrKHRydWUsIHRydWUsIHRydWUsIHRydWUpO1xyXG4gICAgICAgIGdsLnN0ZW5jaWxGdW5jKGdsLkVRVUFMLCB0aGlzLnN0ZW5jaWxNYXNrU3RhY2subGVuZ3RoLCB0aGlzLl9nZXRCaXR3aXNlTWFzaygpKTtcclxuICAgICAgICBnbC5zdGVuY2lsT3AoZ2wuS0VFUCwgZ2wuS0VFUCwgZ2wuS0VFUCk7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIEZpbGwgMXMgZXF1YWwgdG8gdGhlIG51bWJlciBvZiBhY2l0dmUgc3RlbmNpbCBtYXNrcy5cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBiaXR3aXNlIG1hc2suXHJcbiAgICAgKi9cclxuICAgIF9nZXRCaXR3aXNlTWFzaygpIHtcclxuICAgICAgICByZXR1cm4gKDEgPDwgdGhpcy5zdGVuY2lsTWFza1N0YWNrLmxlbmd0aCkgLSAxO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBEZXN0cm95cyB0aGUgbWFzayBzdGFjay5cclxuICAgICAqXHJcbiAgICAgKi9cclxuICAgIGRlc3Ryb3koKSB7XHJcbiAgICAgICAgc3VwZXIuZGVzdHJveSgpO1xyXG4gICAgICAgIHRoaXMuc3RlbmNpbE1hc2tTdGFjayA9IG51bGw7XHJcbiAgICB9XHJcbiAgICA7XHJcbn1cclxuZXhwb3J0cy5TdGVuY2lsU3lzdGVtID0gU3RlbmNpbFN5c3RlbTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgRXZlbnREaXNwYXRjaGVyXzEgPSByZXF1aXJlKFwiLi9FdmVudERpc3BhdGNoZXJcIik7XHJcbmNsYXNzIFN5c3RlbSBleHRlbmRzIEV2ZW50RGlzcGF0Y2hlcl8xLkV2ZW50RGlzcGF0Y2hlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihyZW5kZXJlciA9IG51bGwpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcclxuICAgICAgICB0aGlzLnJlbmRlcmVyLnJ1bm5lcnMuY29udGV4dENoYW5nZS5hZGQodGhpcyk7XHJcbiAgICB9XHJcbiAgICBjb250ZXh0Q2hhbmdlKGdsKSB7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICBkZXN0cm95KG9wdGlvbnMgPSBudWxsKSB7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJlci5ydW5uZXJzLmNvbnRleHRDaGFuZ2UucmVtb3ZlKHRoaXMpO1xyXG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgO1xyXG59XHJcbmV4cG9ydHMuU3lzdGVtID0gU3lzdGVtO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBTcHJpdGVfMSA9IHJlcXVpcmUoXCIuL1Nwcml0ZVwiKTtcclxuY29uc3QgVGV4dHVyZV8xID0gcmVxdWlyZShcIi4vVGV4dHVyZVwiKTtcclxuY29uc3QgUmVjdGFuZ2xlXzEgPSByZXF1aXJlKFwiLi9SZWN0YW5nbGVcIik7XHJcbmNvbnN0IFRleHRNZXRyaWNzXzEgPSByZXF1aXJlKFwiLi9UZXh0TWV0cmljc1wiKTtcclxuY29uc3QgVGV4dFN0eWxlXzEgPSByZXF1aXJlKFwiLi9UZXh0U3R5bGVcIik7XHJcbmNvbnN0IERpc3BsYXlTZXR0aW5nc18xID0gcmVxdWlyZShcIi4vRGlzcGxheVNldHRpbmdzXCIpO1xyXG5jb25zdCBNYXRoU2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL01hdGhTZXR0aW5nc1wiKTtcclxuY29uc3QgQ2FudmFzU2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL0NhbnZhc1NldHRpbmdzXCIpO1xyXG5jb25zdCBUZXh0U2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL1RleHRTZXR0aW5nc1wiKTtcclxuY29uc3QgQ2xlYW5VcFNldHRpbmdzXzEgPSByZXF1aXJlKFwiLi9DbGVhblVwU2V0dGluZ3NcIik7XHJcbmNvbnN0IENvbG9yU2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL0NvbG9yU2V0dGluZ3NcIik7XHJcbmNsYXNzIFRleHQgZXh0ZW5kcyBTcHJpdGVfMS5TcHJpdGUge1xyXG4gICAgY29uc3RydWN0b3IodGV4dCwgc3R5bGUgPSBudWxsLCBjYW52YXMgPSBudWxsKSB7XHJcbiAgICAgICAgY2FudmFzID0gY2FudmFzIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xyXG4gICAgICAgIGNhbnZhcy53aWR0aCA9IDM7XHJcbiAgICAgICAgY2FudmFzLmhlaWdodCA9IDM7XHJcbiAgICAgICAgdmFyIHRleHR1cmUgPSBUZXh0dXJlXzEuVGV4dHVyZS5mcm9tKGNhbnZhcyk7XHJcbiAgICAgICAgdGV4dHVyZS5vcmlnID0gbmV3IFJlY3RhbmdsZV8xLlJlY3RhbmdsZSgpO1xyXG4gICAgICAgIHRleHR1cmUudHJpbSA9IG5ldyBSZWN0YW5nbGVfMS5SZWN0YW5nbGUoKTtcclxuICAgICAgICBzdXBlcih0ZXh0dXJlKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgY2FudmFzIGVsZW1lbnQgdGhhdCBldmVyeXRoaW5nIGlzIGRyYXduIHRvXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAbWVtYmVyIHtIVE1MQ2FudmFzRWxlbWVudH1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmNhbnZhcyA9IGNhbnZhcztcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgY2FudmFzIDJkIGNvbnRleHQgdGhhdCBldmVyeXRoaW5nIGlzIGRyYXduIHdpdGhcclxuICAgICAgICAgKiBAbWVtYmVyIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gdGhpcy5jYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgcmVzb2x1dGlvbiAvIGRldmljZSBwaXhlbCByYXRpbyBvZiB0aGUgY2FudmFzLlxyXG4gICAgICAgICAqIFRoaXMgaXMgc2V0IHRvIGF1dG9tYXRpY2FsbHkgbWF0Y2ggdGhlIHJlbmRlcmVyIHJlc29sdXRpb24gYnkgZGVmYXVsdCwgYnV0IGNhbiBiZSBvdmVycmlkZGVuIGJ5IHNldHRpbmcgbWFudWFsbHkuXHJcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICAgICAqIEBkZWZhdWx0IDFcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLl9yZXNvbHV0aW9uID0gRGlzcGxheVNldHRpbmdzXzEuRGlzcGxheVNldHRpbmdzLlJFU09MVVRJT047XHJcbiAgICAgICAgdGhpcy5fYXV0b1Jlc29sdXRpb24gPSB0cnVlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFByaXZhdGUgdHJhY2tlciBmb3IgdGhlIGN1cnJlbnQgdGV4dC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBtZW1iZXIge3N0cmluZ31cclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuX3RleHQgPSBudWxsO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFByaXZhdGUgdHJhY2tlciBmb3IgdGhlIGN1cnJlbnQgc3R5bGUuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAbWVtYmVyIHtvYmplY3R9XHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLl9zdHlsZSA9IG51bGw7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUHJpdmF0ZSBsaXN0ZW5lciB0byB0cmFjayBzdHlsZSBjaGFuZ2VzLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQG1lbWJlciB7RnVuY3Rpb259XHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLl9zdHlsZUxpc3RlbmVyID0gbnVsbDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBQcml2YXRlIHRyYWNrZXIgZm9yIHRoZSBjdXJyZW50IGZvbnQuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAbWVtYmVyIHtzdHJpbmd9XHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLl9mb250ID0gJyc7XHJcbiAgICAgICAgdGhpcy50ZXh0ID0gdGV4dDtcclxuICAgICAgICB0aGlzLnN0eWxlID0gc3R5bGU7XHJcbiAgICAgICAgdGhpcy5sb2NhbFN0eWxlSUQgPSAtMTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVuZGVycyB0ZXh0IGFuZCB1cGRhdGVzIGl0IHdoZW4gbmVlZGVkLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHJlc3BlY3REaXJ0eSAtIFdoZXRoZXIgdG8gYWJvcnQgdXBkYXRpbmcgdGhlIHRleHQgaWYgdGhlIFRleHQgaXNuJ3QgZGlydHkgYW5kIHRoZSBmdW5jdGlvbiBpcyBjYWxsZWQuXHJcbiAgICAgKi9cclxuICAgIHVwZGF0ZVRleHQocmVzcGVjdERpcnR5KSB7XHJcbiAgICAgICAgdmFyIHN0eWxlID0gdGhpcy5fc3R5bGU7XHJcbiAgICAgICAgLy8gY2hlY2sgaWYgc3R5bGUgaGFzIGNoYW5nZWQuLlxyXG4gICAgICAgIGlmICh0aGlzLmxvY2FsU3R5bGVJRCAhPT0gc3R5bGUuc3R5bGVJRCkge1xyXG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5sb2NhbFN0eWxlSUQgPSBzdHlsZS5zdHlsZUlEO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXRoaXMuZGlydHkgJiYgcmVzcGVjdERpcnR5KSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fZm9udCA9IHRoaXMuX3N0eWxlLnRvRm9udFN0cmluZygpO1xyXG4gICAgICAgIHZhciBjb250ZXh0ID0gdGhpcy5jb250ZXh0O1xyXG4gICAgICAgIFRleHRNZXRyaWNzXzEuVGV4dE1ldHJpY3MuaW5pdCgpO1xyXG4gICAgICAgIHZhciBtZWFzdXJlZCA9IFRleHRNZXRyaWNzXzEuVGV4dE1ldHJpY3MubWVhc3VyZVRleHQodGhpcy5fdGV4dCB8fCAnICcsIHRoaXMuX3N0eWxlLCB0aGlzLl9zdHlsZS53b3JkV3JhcCwgdGhpcy5jYW52YXMpO1xyXG4gICAgICAgIHZhciB3aWR0aCA9IG1lYXN1cmVkLndpZHRoO1xyXG4gICAgICAgIHZhciBoZWlnaHQgPSBtZWFzdXJlZC5oZWlnaHQ7XHJcbiAgICAgICAgdmFyIGxpbmVzID0gbWVhc3VyZWQubGluZXM7XHJcbiAgICAgICAgdmFyIGxpbmVIZWlnaHQgPSBtZWFzdXJlZC5saW5lSGVpZ2h0O1xyXG4gICAgICAgIHZhciBsaW5lV2lkdGhzID0gbWVhc3VyZWQubGluZVdpZHRocztcclxuICAgICAgICB2YXIgbWF4TGluZVdpZHRoID0gbWVhc3VyZWQubWF4TGluZVdpZHRoO1xyXG4gICAgICAgIHZhciBmb250UHJvcGVydGllcyA9IG1lYXN1cmVkLmZvbnRQcm9wZXJ0aWVzO1xyXG4gICAgICAgIHRoaXMuY2FudmFzLndpZHRoID0gTWF0aC5jZWlsKChNYXRoLm1heCgxLCB3aWR0aCkgKyAoc3R5bGUucGFkZGluZyAqIDIpKSAqIHRoaXMuX3Jlc29sdXRpb24pO1xyXG4gICAgICAgIHRoaXMuY2FudmFzLmhlaWdodCA9IE1hdGguY2VpbCgoTWF0aC5tYXgoMSwgaGVpZ2h0KSArIChzdHlsZS5wYWRkaW5nICogMikpICogdGhpcy5fcmVzb2x1dGlvbik7XHJcbiAgICAgICAgY29udGV4dC5zY2FsZSh0aGlzLl9yZXNvbHV0aW9uLCB0aGlzLl9yZXNvbHV0aW9uKTtcclxuICAgICAgICBjb250ZXh0LmNsZWFyUmVjdCgwLCAwLCB0aGlzLmNhbnZhcy53aWR0aCwgdGhpcy5jYW52YXMuaGVpZ2h0KTtcclxuICAgICAgICBjb250ZXh0LmZvbnQgPSB0aGlzLl9mb250O1xyXG4gICAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBzdHlsZS5zdHJva2U7XHJcbiAgICAgICAgY29udGV4dC5saW5lV2lkdGggPSBzdHlsZS5zdHJva2VUaGlja25lc3M7XHJcbiAgICAgICAgY29udGV4dC50ZXh0QmFzZWxpbmUgPSBzdHlsZS50ZXh0QmFzZWxpbmU7XHJcbiAgICAgICAgY29udGV4dC5saW5lSm9pbiA9IHN0eWxlLmxpbmVKb2luO1xyXG4gICAgICAgIGNvbnRleHQubWl0ZXJMaW1pdCA9IHN0eWxlLm1pdGVyTGltaXQ7XHJcbiAgICAgICAgdmFyIGxpbmVQb3NpdGlvblg7XHJcbiAgICAgICAgdmFyIGxpbmVQb3NpdGlvblk7XHJcbiAgICAgICAgaWYgKHN0eWxlLmRyb3BTaGFkb3cpIHtcclxuICAgICAgICAgICAgdmFyIGRyb3BTaGFkb3dDb2xvciA9IHN0eWxlLmRyb3BTaGFkb3dDb2xvcjtcclxuICAgICAgICAgICAgdmFyIHJnYiA9IENvbG9yU2V0dGluZ3NfMS5Db2xvclNldHRpbmdzLmhleDJyZ2IodHlwZW9mIGRyb3BTaGFkb3dDb2xvciA9PT0gJ251bWJlcicgPyBkcm9wU2hhZG93Q29sb3IgOiBNYXRoU2V0dGluZ3NfMS5NYXRoU2V0dGluZ3Muc3RyaW5nMmhleChkcm9wU2hhZG93Q29sb3IpKTtcclxuICAgICAgICAgICAgY29udGV4dC5zaGFkb3dDb2xvciA9IFwicmdiYShcIiArIChyZ2JbMF0gKiAyNTUpICsgXCIsXCIgKyAocmdiWzFdICogMjU1KSArIFwiLFwiICsgKHJnYlsyXSAqIDI1NSkgKyBcIixcIiArIChzdHlsZS5kcm9wU2hhZG93QWxwaGEpICsgXCIpXCI7XHJcbiAgICAgICAgICAgIGNvbnRleHQuc2hhZG93Qmx1ciA9IHN0eWxlLmRyb3BTaGFkb3dCbHVyO1xyXG4gICAgICAgICAgICBjb250ZXh0LnNoYWRvd09mZnNldFggPSBNYXRoLmNvcyhzdHlsZS5kcm9wU2hhZG93QW5nbGUpICogc3R5bGUuZHJvcFNoYWRvd0Rpc3RhbmNlO1xyXG4gICAgICAgICAgICBjb250ZXh0LnNoYWRvd09mZnNldFkgPSBNYXRoLnNpbihzdHlsZS5kcm9wU2hhZG93QW5nbGUpICogc3R5bGUuZHJvcFNoYWRvd0Rpc3RhbmNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29udGV4dC5zaGFkb3dDb2xvciA9IDA7XHJcbiAgICAgICAgICAgIGNvbnRleHQuc2hhZG93Qmx1ciA9IDA7XHJcbiAgICAgICAgICAgIGNvbnRleHQuc2hhZG93T2Zmc2V0WCA9IDA7XHJcbiAgICAgICAgICAgIGNvbnRleHQuc2hhZG93T2Zmc2V0WSA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHNldCBjYW52YXMgdGV4dCBzdHlsZXNcclxuICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IHRoaXMuX2dlbmVyYXRlRmlsbFN0eWxlKHN0eWxlLCBsaW5lcyk7XHJcbiAgICAgICAgLy8gZHJhdyBsaW5lcyBsaW5lIGJ5IGxpbmVcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGxpbmVQb3NpdGlvblggPSBzdHlsZS5zdHJva2VUaGlja25lc3MgLyAyO1xyXG4gICAgICAgICAgICBsaW5lUG9zaXRpb25ZID0gKChzdHlsZS5zdHJva2VUaGlja25lc3MgLyAyKSArIChpICogbGluZUhlaWdodCkpICsgZm9udFByb3BlcnRpZXMuYXNjZW50O1xyXG4gICAgICAgICAgICBpZiAoc3R5bGUuYWxpZ24gPT09ICdyaWdodCcpIHtcclxuICAgICAgICAgICAgICAgIGxpbmVQb3NpdGlvblggKz0gbWF4TGluZVdpZHRoIC0gbGluZVdpZHRoc1tpXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChzdHlsZS5hbGlnbiA9PT0gJ2NlbnRlcicpIHtcclxuICAgICAgICAgICAgICAgIGxpbmVQb3NpdGlvblggKz0gKG1heExpbmVXaWR0aCAtIGxpbmVXaWR0aHNbaV0pIC8gMjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoc3R5bGUuc3Ryb2tlICYmIHN0eWxlLnN0cm9rZVRoaWNrbmVzcykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kcmF3TGV0dGVyU3BhY2luZyhsaW5lc1tpXSwgbGluZVBvc2l0aW9uWCArIHN0eWxlLnBhZGRpbmcsIGxpbmVQb3NpdGlvblkgKyBzdHlsZS5wYWRkaW5nLCB0cnVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoc3R5bGUuZmlsbCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kcmF3TGV0dGVyU3BhY2luZyhsaW5lc1tpXSwgbGluZVBvc2l0aW9uWCArIHN0eWxlLnBhZGRpbmcsIGxpbmVQb3NpdGlvblkgKyBzdHlsZS5wYWRkaW5nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnVwZGF0ZVRleHR1cmUoKTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogUmVuZGVyIHRoZSB0ZXh0IHdpdGggbGV0dGVyLXNwYWNpbmcuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCAtIFRoZSB0ZXh0IHRvIGRyYXdcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gSG9yaXpvbnRhbCBwb3NpdGlvbiB0byBkcmF3IHRoZSB0ZXh0XHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSAtIFZlcnRpY2FsIHBvc2l0aW9uIHRvIGRyYXcgdGhlIHRleHRcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzU3Ryb2tlPWZhbHNlXSAtIElzIHRoaXMgZHJhd2luZyBmb3IgdGhlIG91dHNpZGUgc3Ryb2tlIG9mIHRoZVxyXG4gICAgICogIHRleHQ/IElmIG5vdCwgaXQncyBmb3IgdGhlIGluc2lkZSBmaWxsXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBkcmF3TGV0dGVyU3BhY2luZyh0ZXh0LCB4LCB5LCBpc1N0cm9rZSA9IGZhbHNlKSB7XHJcbiAgICAgICAgaWYgKGlzU3Ryb2tlID09PSB2b2lkIDApIHtcclxuICAgICAgICAgICAgaXNTdHJva2UgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHN0eWxlID0gdGhpcy5fc3R5bGU7XHJcbiAgICAgICAgLy8gbGV0dGVyU3BhY2luZyBvZiAwIG1lYW5zIG5vcm1hbFxyXG4gICAgICAgIHZhciBsZXR0ZXJTcGFjaW5nID0gc3R5bGUubGV0dGVyU3BhY2luZztcclxuICAgICAgICBpZiAobGV0dGVyU3BhY2luZyA9PT0gMCkge1xyXG4gICAgICAgICAgICBpZiAoaXNTdHJva2UpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5zdHJva2VUZXh0KHRleHQsIHgsIHkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmZpbGxUZXh0KHRleHQsIHgsIHkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGNoYXJhY3RlcnMgPSBTdHJpbmcucHJvdG90eXBlLnNwbGl0LmNhbGwodGV4dCwgJycpO1xyXG4gICAgICAgIHZhciBjdXJyZW50UG9zaXRpb24gPSB4O1xyXG4gICAgICAgIHZhciBpbmRleCA9IDA7XHJcbiAgICAgICAgdmFyIGN1cnJlbnQgPSAnJztcclxuICAgICAgICB3aGlsZSAoaW5kZXggPCB0ZXh0Lmxlbmd0aCkge1xyXG4gICAgICAgICAgICBjdXJyZW50ID0gY2hhcmFjdGVyc1tpbmRleCsrXTtcclxuICAgICAgICAgICAgaWYgKGlzU3Ryb2tlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuc3Ryb2tlVGV4dChjdXJyZW50LCBjdXJyZW50UG9zaXRpb24sIHkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmZpbGxUZXh0KGN1cnJlbnQsIGN1cnJlbnRQb3NpdGlvbiwgeSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY3VycmVudFBvc2l0aW9uICs9IHRoaXMuY29udGV4dC5tZWFzdXJlVGV4dChjdXJyZW50KS53aWR0aCArIGxldHRlclNwYWNpbmc7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGVzIHRleHR1cmUgc2l6ZSBiYXNlZCBvbiBjYW52YXMgc2l6ZVxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIHVwZGF0ZVRleHR1cmUoKSB7XHJcbiAgICAgICAgdmFyIGNhbnZhcyA9IHRoaXMuY2FudmFzO1xyXG4gICAgICAgIGlmICh0aGlzLl9zdHlsZS50cmltKSB7XHJcbiAgICAgICAgICAgIHZhciB0cmltbWVkID0gQ2FudmFzU2V0dGluZ3NfMS5DYW52YXNTZXR0aW5ncy50cmltQ2FudmFzKGNhbnZhcyk7XHJcbiAgICAgICAgICAgIGlmICh0cmltbWVkLmRhdGEpIHtcclxuICAgICAgICAgICAgICAgIGNhbnZhcy53aWR0aCA9IHRyaW1tZWQud2lkdGg7XHJcbiAgICAgICAgICAgICAgICBjYW52YXMuaGVpZ2h0ID0gdHJpbW1lZC5oZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQucHV0SW1hZ2VEYXRhKHRyaW1tZWQuZGF0YSwgMCwgMCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHRleHR1cmUgPSB0aGlzLl90ZXh0dXJlO1xyXG4gICAgICAgIHZhciBzdHlsZSA9IHRoaXMuX3N0eWxlO1xyXG4gICAgICAgIHZhciBwYWRkaW5nID0gc3R5bGUudHJpbSA/IDAgOiBzdHlsZS5wYWRkaW5nO1xyXG4gICAgICAgIHZhciBiYXNlVGV4dHVyZSA9IHRleHR1cmUuYmFzZVRleHR1cmU7XHJcbiAgICAgICAgdGV4dHVyZS50cmltLndpZHRoID0gdGV4dHVyZS5fZnJhbWUud2lkdGggPSBjYW52YXMud2lkdGggLyB0aGlzLl9yZXNvbHV0aW9uO1xyXG4gICAgICAgIHRleHR1cmUudHJpbS5oZWlnaHQgPSB0ZXh0dXJlLl9mcmFtZS5oZWlnaHQgPSBjYW52YXMuaGVpZ2h0IC8gdGhpcy5fcmVzb2x1dGlvbjtcclxuICAgICAgICB0ZXh0dXJlLnRyaW0ueCA9IC1wYWRkaW5nO1xyXG4gICAgICAgIHRleHR1cmUudHJpbS55ID0gLXBhZGRpbmc7XHJcbiAgICAgICAgdGV4dHVyZS5vcmlnLndpZHRoID0gdGV4dHVyZS5fZnJhbWUud2lkdGggLSAocGFkZGluZyAqIDIpO1xyXG4gICAgICAgIHRleHR1cmUub3JpZy5oZWlnaHQgPSB0ZXh0dXJlLl9mcmFtZS5oZWlnaHQgLSAocGFkZGluZyAqIDIpO1xyXG4gICAgICAgIC8vIGNhbGwgc3ByaXRlIG9uVGV4dHVyZVVwZGF0ZSB0byB1cGRhdGUgc2NhbGUgaWYgX3dpZHRoIG9yIF9oZWlnaHQgd2VyZSBzZXRcclxuICAgICAgICB0aGlzLl9vblRleHR1cmVVcGRhdGUoKTtcclxuICAgICAgICBiYXNlVGV4dHVyZS5zZXRSZWFsU2l6ZShjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQsIHRoaXMuX3Jlc29sdXRpb24pO1xyXG4gICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogUmVuZGVycyB0aGUgb2JqZWN0IHVzaW5nIHRoZSBXZWJHTCByZW5kZXJlclxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7UElYSS5SZW5kZXJlcn0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXJcclxuICAgICAqL1xyXG4gICAgcmVuZGVyKHJlbmRlcmVyKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2F1dG9SZXNvbHV0aW9uICYmIHRoaXMuX3Jlc29sdXRpb24gIT09IHJlbmRlcmVyLnJlc29sdXRpb24pIHtcclxuICAgICAgICAgICAgdGhpcy5fcmVzb2x1dGlvbiA9IHJlbmRlcmVyLnJlc29sdXRpb247XHJcbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnVwZGF0ZVRleHQodHJ1ZSk7XHJcbiAgICAgICAgc3VwZXIucmVuZGVyKHJlbmRlcmVyKTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogUmVuZGVycyB0aGUgb2JqZWN0IHVzaW5nIHRoZSBDYW52YXMgcmVuZGVyZXJcclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtQSVhJLkNhbnZhc1JlbmRlcmVyfSByZW5kZXJlciAtIFRoZSByZW5kZXJlclxyXG4gICAgICovXHJcbiAgICBfcmVuZGVyQ2FudmFzKHJlbmRlcmVyKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2F1dG9SZXNvbHV0aW9uICYmIHRoaXMuX3Jlc29sdXRpb24gIT09IHJlbmRlcmVyLnJlc29sdXRpb24pIHtcclxuICAgICAgICAgICAgdGhpcy5fcmVzb2x1dGlvbiA9IHJlbmRlcmVyLnJlc29sdXRpb247XHJcbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnVwZGF0ZVRleHQodHJ1ZSk7XHJcbiAgICAgICAgLy8gc3VwZXIuX3JlbmRlckNhbnZhcyhyZW5kZXJlcik7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIGxvY2FsIGJvdW5kcyBvZiB0aGUgdGV4dCBvYmplY3QuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtSZWN0YW5nbGV9IHJlY3QgLSBUaGUgb3V0cHV0IHJlY3RhbmdsZS5cclxuICAgICAqIEByZXR1cm4ge1JlY3RhbmdsZX0gVGhlIGJvdW5kcy5cclxuICAgICAqL1xyXG4gICAgZ2V0TG9jYWxCb3VuZHMocmVjdCkge1xyXG4gICAgICAgIHRoaXMudXBkYXRlVGV4dCh0cnVlKTtcclxuICAgICAgICByZXR1cm4gc3VwZXIuZ2V0TG9jYWxCb3VuZHMocmVjdCk7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIGNhbGN1bGF0ZXMgdGhlIGJvdW5kcyBvZiB0aGUgVGV4dCBhcyBhIHJlY3RhbmdsZS4gVGhlIGJvdW5kcyBjYWxjdWxhdGlvbiB0YWtlcyB0aGUgd29ybGRUcmFuc2Zvcm0gaW50byBhY2NvdW50LlxyXG4gICAgICogQHByb3RlY3RlZFxyXG4gICAgICovXHJcbiAgICBfY2FsY3VsYXRlQm91bmRzKCkge1xyXG4gICAgICAgIHRoaXMudXBkYXRlVGV4dCh0cnVlKTtcclxuICAgICAgICB0aGlzLmNhbGN1bGF0ZVZlcnRpY2VzKCk7XHJcbiAgICAgICAgLy8gaWYgd2UgaGF2ZSBhbHJlYWR5IGRvbmUgdGhpcyBvbiBUSElTIGZyYW1lLlxyXG4gICAgICAgIHRoaXMuX2JvdW5kcy5hZGRRdWFkKHRoaXMudmVydGV4RGF0YSk7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIE1ldGhvZCB0byBiZSBjYWxsZWQgdXBvbiBhIFRleHRTdHlsZSBjaGFuZ2UuXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBfb25TdHlsZUNoYW5nZSgpIHtcclxuICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogR2VuZXJhdGVzIHRoZSBmaWxsIHN0eWxlLiBDYW4gYXV0b21hdGljYWxseSBnZW5lcmF0ZSBhIGdyYWRpZW50IGJhc2VkIG9uIHRoZSBmaWxsIHN0eWxlIGJlaW5nIGFuIGFycmF5XHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzdHlsZSAtIFRoZSBzdHlsZS5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IGxpbmVzIC0gVGhlIGxpbmVzIG9mIHRleHQuXHJcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd8bnVtYmVyfENhbnZhc0dyYWRpZW50fSBUaGUgZmlsbCBzdHlsZVxyXG4gICAgICovXHJcbiAgICBfZ2VuZXJhdGVGaWxsU3R5bGUoc3R5bGUsIGxpbmVzKSB7XHJcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHN0eWxlLmZpbGwpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzdHlsZS5maWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyB0aGUgZ3JhZGllbnQgd2lsbCBiZSBldmVubHkgc3BhY2VkIG91dCBhY2NvcmRpbmcgdG8gaG93IGxhcmdlIHRoZSBhcnJheSBpcy5cclxuICAgICAgICAvLyBbJyNGRjAwMDAnLCAnIzAwRkYwMCcsICcjMDAwMEZGJ10gd291bGQgY3JlYXRlZCBzdG9wcyBhdCAwLjI1LCAwLjUgYW5kIDAuNzVcclxuICAgICAgICB2YXIgZ3JhZGllbnQ7XHJcbiAgICAgICAgdmFyIHRvdGFsSXRlcmF0aW9ucztcclxuICAgICAgICB2YXIgY3VycmVudEl0ZXJhdGlvbjtcclxuICAgICAgICB2YXIgc3RvcDtcclxuICAgICAgICB2YXIgd2lkdGggPSB0aGlzLmNhbnZhcy53aWR0aCAvIHRoaXMuX3Jlc29sdXRpb247XHJcbiAgICAgICAgdmFyIGhlaWdodCA9IHRoaXMuY2FudmFzLmhlaWdodCAvIHRoaXMuX3Jlc29sdXRpb247XHJcbiAgICAgICAgLy8gbWFrZSBhIGNvcHkgb2YgdGhlIHN0eWxlIHNldHRpbmdzLCBzbyB3ZSBjYW4gbWFuaXB1bGF0ZSB0aGVtIGxhdGVyXHJcbiAgICAgICAgdmFyIGZpbGwgPSBzdHlsZS5maWxsLnNsaWNlKCk7XHJcbiAgICAgICAgdmFyIGZpbGxHcmFkaWVudFN0b3BzID0gc3R5bGUuZmlsbEdyYWRpZW50U3RvcHMuc2xpY2UoKTtcclxuICAgICAgICAvLyB3YW50aW5nIHRvIGV2ZW5seSBkaXN0cmlidXRlIHRoZSBmaWxscy4gU28gYW4gYXJyYXkgb2YgNCBjb2xvdXJzIHNob3VsZCBnaXZlIGZpbGxzIG9mIDAuMjUsIDAuNSBhbmQgMC43NVxyXG4gICAgICAgIGlmICghZmlsbEdyYWRpZW50U3RvcHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHZhciBsZW5ndGhQbHVzMSA9IGZpbGwubGVuZ3RoICsgMTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBsZW5ndGhQbHVzMTsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICBmaWxsR3JhZGllbnRTdG9wcy5wdXNoKGkgLyBsZW5ndGhQbHVzMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gc3RvcCB0aGUgYmxlZWRpbmcgb2YgdGhlIGxhc3QgZ3JhZGllbnQgb24gdGhlIGxpbmUgYWJvdmUgdG8gdGhlIHRvcCBncmFkaWVudCBvZiB0aGUgdGhpcyBsaW5lXHJcbiAgICAgICAgLy8gYnkgaGFyZCBkZWZpbmluZyB0aGUgZmlyc3QgZ3JhZGllbnQgY29sb3VyIGF0IHBvaW50IDAsIGFuZCBsYXN0IGdyYWRpZW50IGNvbG91ciBhdCBwb2ludCAxXHJcbiAgICAgICAgZmlsbC51bnNoaWZ0KHN0eWxlLmZpbGxbMF0pO1xyXG4gICAgICAgIGZpbGxHcmFkaWVudFN0b3BzLnVuc2hpZnQoMCk7XHJcbiAgICAgICAgZmlsbC5wdXNoKHN0eWxlLmZpbGxbc3R5bGUuZmlsbC5sZW5ndGggLSAxXSk7XHJcbiAgICAgICAgZmlsbEdyYWRpZW50U3RvcHMucHVzaCgxKTtcclxuICAgICAgICBpZiAoc3R5bGUuZmlsbEdyYWRpZW50VHlwZSA9PT0gVGV4dFNldHRpbmdzXzEuVGV4dFNldHRpbmdzLlRFWFRfR1JBRElFTlQuTElORUFSX1ZFUlRJQ0FMKSB7XHJcbiAgICAgICAgICAgIC8vIHN0YXJ0IHRoZSBncmFkaWVudCBhdCB0aGUgdG9wIGNlbnRlciBvZiB0aGUgY2FudmFzLCBhbmQgZW5kIGF0IHRoZSBib3R0b20gbWlkZGxlIG9mIHRoZSBjYW52YXNcclxuICAgICAgICAgICAgZ3JhZGllbnQgPSB0aGlzLmNvbnRleHQuY3JlYXRlTGluZWFyR3JhZGllbnQod2lkdGggLyAyLCAwLCB3aWR0aCAvIDIsIGhlaWdodCk7XHJcbiAgICAgICAgICAgIC8vIHdlIG5lZWQgdG8gcmVwZWF0IHRoZSBncmFkaWVudCBzbyB0aGF0IGVhY2ggaW5kaXZpZHVhbCBsaW5lIG9mIHRleHQgaGFzIHRoZSBzYW1lIHZlcnRpY2FsIGdyYWRpZW50IGVmZmVjdFxyXG4gICAgICAgICAgICAvLyBbJyNGRjAwMDAnLCAnIzAwRkYwMCcsICcjMDAwMEZGJ10gb3ZlciAyIGxpbmVzIHdvdWxkIGNyZWF0ZSBzdG9wcyBhdCAwLjEyNSwgMC4yNSwgMC4zNzUsIDAuNjI1LCAwLjc1LCAwLjg3NVxyXG4gICAgICAgICAgICB0b3RhbEl0ZXJhdGlvbnMgPSAoZmlsbC5sZW5ndGggKyAxKSAqIGxpbmVzLmxlbmd0aDtcclxuICAgICAgICAgICAgY3VycmVudEl0ZXJhdGlvbiA9IDA7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGxpbmVzLmxlbmd0aDsgaSQxKyspIHtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRJdGVyYXRpb24gKz0gMTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZmlsbC5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZmlsbEdyYWRpZW50U3RvcHNbal0gPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0b3AgPSAoZmlsbEdyYWRpZW50U3RvcHNbal0gLyBsaW5lcy5sZW5ndGgpICsgKGkkMSAvIGxpbmVzLmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdG9wID0gY3VycmVudEl0ZXJhdGlvbiAvIHRvdGFsSXRlcmF0aW9ucztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZ3JhZGllbnQuYWRkQ29sb3JTdG9wKHN0b3AsIGZpbGxbal0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRJdGVyYXRpb24rKztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gc3RhcnQgdGhlIGdyYWRpZW50IGF0IHRoZSBjZW50ZXIgbGVmdCBvZiB0aGUgY2FudmFzLCBhbmQgZW5kIGF0IHRoZSBjZW50ZXIgcmlnaHQgb2YgdGhlIGNhbnZhc1xyXG4gICAgICAgICAgICBncmFkaWVudCA9IHRoaXMuY29udGV4dC5jcmVhdGVMaW5lYXJHcmFkaWVudCgwLCBoZWlnaHQgLyAyLCB3aWR0aCwgaGVpZ2h0IC8gMik7XHJcbiAgICAgICAgICAgIC8vIGNhbiBqdXN0IGV2ZW5seSBzcGFjZSBvdXQgdGhlIGdyYWRpZW50cyBpbiB0aGlzIGNhc2UsIGFzIG11bHRpcGxlIGxpbmVzIG1ha2VzIG5vIGRpZmZlcmVuY2VcclxuICAgICAgICAgICAgLy8gdG8gYW4gZXZlbiBsZWZ0IHRvIHJpZ2h0IGdyYWRpZW50XHJcbiAgICAgICAgICAgIHRvdGFsSXRlcmF0aW9ucyA9IGZpbGwubGVuZ3RoICsgMTtcclxuICAgICAgICAgICAgY3VycmVudEl0ZXJhdGlvbiA9IDE7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkkMiA9IDA7IGkkMiA8IGZpbGwubGVuZ3RoOyBpJDIrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmaWxsR3JhZGllbnRTdG9wc1tpJDJdID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0b3AgPSBmaWxsR3JhZGllbnRTdG9wc1tpJDJdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RvcCA9IGN1cnJlbnRJdGVyYXRpb24gLyB0b3RhbEl0ZXJhdGlvbnM7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBncmFkaWVudC5hZGRDb2xvclN0b3Aoc3RvcCwgZmlsbFtpJDJdKTtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRJdGVyYXRpb24rKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZ3JhZGllbnQ7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIERlc3Ryb3lzIHRoaXMgdGV4dCBvYmplY3QuXHJcbiAgICAgKiBOb3RlKiBVbmxpa2UgYSBTcHJpdGUsIGEgVGV4dCBvYmplY3Qgd2lsbCBhdXRvbWF0aWNhbGx5IGRlc3Ryb3kgaXRzIGJhc2VUZXh0dXJlIGFuZCB0ZXh0dXJlIGFzXHJcbiAgICAgKiB0aGUgbWFqb3JpdHkgb2YgdGhlIHRpbWUgdGhlIHRleHR1cmUgd2lsbCBub3QgYmUgc2hhcmVkIHdpdGggYW55IG90aGVyIFNwcml0ZXMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtvYmplY3R8Ym9vbGVhbn0gW29wdGlvbnNdIC0gT3B0aW9ucyBwYXJhbWV0ZXIuIEEgYm9vbGVhbiB3aWxsIGFjdCBhcyBpZiBhbGwgb3B0aW9uc1xyXG4gICAgICogIGhhdmUgYmVlbiBzZXQgdG8gdGhhdCB2YWx1ZVxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jaGlsZHJlbj1mYWxzZV0gLSBpZiBzZXQgdG8gdHJ1ZSwgYWxsIHRoZSBjaGlsZHJlbiB3aWxsIGhhdmUgdGhlaXJcclxuICAgICAqICBkZXN0cm95IG1ldGhvZCBjYWxsZWQgYXMgd2VsbC4gJ29wdGlvbnMnIHdpbGwgYmUgcGFzc2VkIG9uIHRvIHRob3NlIGNhbGxzLlxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50ZXh0dXJlPXRydWVdIC0gU2hvdWxkIGl0IGRlc3Ryb3kgdGhlIGN1cnJlbnQgdGV4dHVyZSBvZiB0aGUgc3ByaXRlIGFzIHdlbGxcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuYmFzZVRleHR1cmU9dHJ1ZV0gLSBTaG91bGQgaXQgZGVzdHJveSB0aGUgYmFzZSB0ZXh0dXJlIG9mIHRoZSBzcHJpdGUgYXMgd2VsbFxyXG4gICAgICovXHJcbiAgICBkZXN0cm95KG9wdGlvbnMpIHtcclxuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdib29sZWFuJykge1xyXG4gICAgICAgICAgICBvcHRpb25zID0geyBjaGlsZHJlbjogb3B0aW9ucyB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgQ2xlYW5VcFNldHRpbmdzXzEuQ2xlYW5VcFNldHRpbmdzLmRlZmF1bHREZXN0cm95T3B0aW9ucywgb3B0aW9ucyk7XHJcbiAgICAgICAgc3VwZXIuZGVzdHJveShvcHRpb25zKTtcclxuICAgICAgICAvLyBtYWtlIHN1cmUgdG8gcmVzZXQgdGhlIHRoZSBjb250ZXh0IGFuZCBjYW52YXMuLiBkb250IHdhbnQgdGhpcyBoYW5naW5nIGFyb3VuZCBpbiBtZW1vcnkhXHJcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gbnVsbDtcclxuICAgICAgICB0aGlzLmNhbnZhcyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5fc3R5bGUgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgd2lkdGggb2YgdGhlIFRleHQsIHNldHRpbmcgdGhpcyB3aWxsIGFjdHVhbGx5IG1vZGlmeSB0aGUgc2NhbGUgdG8gYWNoaWV2ZSB0aGUgdmFsdWUgc2V0XHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICBnZXQgd2lkdGgoKSB7XHJcbiAgICAgICAgdGhpcy51cGRhdGVUZXh0KHRydWUpO1xyXG4gICAgICAgIHJldHVybiBNYXRoLmFicyh0aGlzLnNjYWxlLngpICogdGhpcy5fdGV4dHVyZS5vcmlnLndpZHRoO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgc2V0IHdpZHRoKHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy51cGRhdGVUZXh0KHRydWUpO1xyXG4gICAgICAgIHZhciBzID0gTWF0aFNldHRpbmdzXzEuTWF0aFNldHRpbmdzLnNpZ24odGhpcy5zY2FsZS54KSB8fCAxO1xyXG4gICAgICAgIHRoaXMuc2NhbGUueCA9IHMgKiB2YWx1ZSAvIHRoaXMuX3RleHR1cmUub3JpZy53aWR0aDtcclxuICAgICAgICB0aGlzLl93aWR0aCA9IHZhbHVlO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgaGVpZ2h0IG9mIHRoZSBUZXh0LCBzZXR0aW5nIHRoaXMgd2lsbCBhY3R1YWxseSBtb2RpZnkgdGhlIHNjYWxlIHRvIGFjaGlldmUgdGhlIHZhbHVlIHNldFxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgZ2V0IGhlaWdodCgpIHtcclxuICAgICAgICB0aGlzLnVwZGF0ZVRleHQodHJ1ZSk7XHJcbiAgICAgICAgcmV0dXJuIE1hdGguYWJzKHRoaXMuc2NhbGUueSkgKiB0aGlzLl90ZXh0dXJlLm9yaWcuaGVpZ2h0O1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgc2V0IGhlaWdodCh2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMudXBkYXRlVGV4dCh0cnVlKTtcclxuICAgICAgICB2YXIgcyA9IE1hdGhTZXR0aW5nc18xLk1hdGhTZXR0aW5ncy5zaWduKHRoaXMuc2NhbGUueSkgfHwgMTtcclxuICAgICAgICB0aGlzLnNjYWxlLnkgPSBzICogdmFsdWUgLyB0aGlzLl90ZXh0dXJlLm9yaWcuaGVpZ2h0O1xyXG4gICAgICAgIHRoaXMuX2hlaWdodCA9IHZhbHVlO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhlIHN0eWxlIG9mIHRoZSB0ZXh0LiBTZXQgdXAgYW4gZXZlbnQgbGlzdGVuZXIgdG8gbGlzdGVuIGZvciBjaGFuZ2VzIG9uIHRoZSBzdHlsZVxyXG4gICAgICogb2JqZWN0IGFuZCBtYXJrIHRoZSB0ZXh0IGFzIGRpcnR5LlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge29iamVjdHxQSVhJLlRleHRTdHlsZX1cclxuICAgICAqL1xyXG4gICAgZ2V0IHN0eWxlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9zdHlsZTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIHNldCBzdHlsZShzdHlsZSkge1xyXG4gICAgICAgIHN0eWxlID0gc3R5bGUgfHwge307XHJcbiAgICAgICAgaWYgKHN0eWxlIGluc3RhbmNlb2YgVGV4dFN0eWxlXzEuVGV4dFN0eWxlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0eWxlID0gc3R5bGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLl9zdHlsZSA9IG5ldyBUZXh0U3R5bGVfMS5UZXh0U3R5bGUoc3R5bGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmxvY2FsU3R5bGVJRCA9IC0xO1xyXG4gICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhlIGNvcHkgZm9yIHRoZSB0ZXh0IG9iamVjdC4gVG8gc3BsaXQgYSBsaW5lIHlvdSBjYW4gdXNlICdcXG4nLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge3N0cmluZ31cclxuICAgICAqL1xyXG4gICAgZ2V0IHRleHQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RleHQ7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICBzZXQgdGV4dCh0ZXh0KSB7XHJcbiAgICAgICAgdGV4dCA9IFN0cmluZyh0ZXh0ID09PSBudWxsIHx8IHRleHQgPT09IHVuZGVmaW5lZCA/ICcnIDogdGV4dCk7XHJcbiAgICAgICAgaWYgKHRoaXMuX3RleHQgPT09IHRleHQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl90ZXh0ID0gdGV4dDtcclxuICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIHJlc29sdXRpb24gLyBkZXZpY2UgcGl4ZWwgcmF0aW8gb2YgdGhlIGNhbnZhcy5cclxuICAgICAqIFRoaXMgaXMgc2V0IHRvIGF1dG9tYXRpY2FsbHkgbWF0Y2ggdGhlIHJlbmRlcmVyIHJlc29sdXRpb24gYnkgZGVmYXVsdCwgYnV0IGNhbiBiZSBvdmVycmlkZGVuIGJ5IHNldHRpbmcgbWFudWFsbHkuXHJcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgKiBAZGVmYXVsdCAxXHJcbiAgICAgKi9cclxuICAgIGdldCByZXNvbHV0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9yZXNvbHV0aW9uO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgc2V0IHJlc29sdXRpb24odmFsdWUpIHtcclxuICAgICAgICB0aGlzLl9hdXRvUmVzb2x1dGlvbiA9IGZhbHNlO1xyXG4gICAgICAgIGlmICh0aGlzLl9yZXNvbHV0aW9uID09PSB2YWx1ZSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3Jlc29sdXRpb24gPSB2YWx1ZTtcclxuICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIDtcclxufVxyXG5leHBvcnRzLlRleHQgPSBUZXh0O1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jbGFzcyBUZXh0TWV0cmljcyB7XHJcbiAgICBjb25zdHJ1Y3Rvcih0ZXh0LCBzdHlsZSwgd2lkdGgsIGhlaWdodCwgbGluZXMsIGxpbmVXaWR0aHMsIGxpbmVIZWlnaHQsIG1heExpbmVXaWR0aCwgZm9udFByb3BlcnRpZXMpIHtcclxuICAgICAgICBpZiAoIVRleHRNZXRyaWNzLmNhbnZhcykge1xyXG4gICAgICAgICAgICBUZXh0TWV0cmljcy5jYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcclxuICAgICAgICAgICAgVGV4dE1ldHJpY3MuY2FudmFzLndpZHRoID0gVGV4dE1ldHJpY3MuY2FudmFzLmhlaWdodCA9IDEwO1xyXG4gICAgICAgICAgICBUZXh0TWV0cmljcy5fY2FudmFzID0gVGV4dE1ldHJpY3MuY2FudmFzO1xyXG4gICAgICAgICAgICBUZXh0TWV0cmljcy5fY29udGV4dCA9IFRleHRNZXRyaWNzLmNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnRleHQgPSB0ZXh0O1xyXG4gICAgICAgIHRoaXMuc3R5bGUgPSBzdHlsZTtcclxuICAgICAgICB0aGlzLndpZHRoID0gd2lkdGg7XHJcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XHJcbiAgICAgICAgdGhpcy5saW5lcyA9IGxpbmVzO1xyXG4gICAgICAgIHRoaXMubGluZVdpZHRocyA9IGxpbmVXaWR0aHM7XHJcbiAgICAgICAgdGhpcy5saW5lSGVpZ2h0ID0gbGluZUhlaWdodDtcclxuICAgICAgICB0aGlzLm1heExpbmVXaWR0aCA9IG1heExpbmVXaWR0aDtcclxuICAgICAgICB0aGlzLmZvbnRQcm9wZXJ0aWVzID0gZm9udFByb3BlcnRpZXM7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgaW5pdCgpIHtcclxuICAgICAgICBpZiAoIVRleHRNZXRyaWNzLmNhbnZhcykge1xyXG4gICAgICAgICAgICBUZXh0TWV0cmljcy5jYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcclxuICAgICAgICAgICAgVGV4dE1ldHJpY3MuY2FudmFzLndpZHRoID0gVGV4dE1ldHJpY3MuY2FudmFzLmhlaWdodCA9IDEwO1xyXG4gICAgICAgICAgICBUZXh0TWV0cmljcy5fY2FudmFzID0gVGV4dE1ldHJpY3MuY2FudmFzO1xyXG4gICAgICAgICAgICBUZXh0TWV0cmljcy5fY29udGV4dCA9IFRleHRNZXRyaWNzLmNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogTWVhc3VyZXMgdGhlIHN1cHBsaWVkIHN0cmluZyBvZiB0ZXh0IGFuZCByZXR1cm5zIGEgUmVjdGFuZ2xlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IC0gdGhlIHRleHQgdG8gbWVhc3VyZS5cclxuICAgICAqIEBwYXJhbSB7UElYSS5UZXh0U3R5bGV9IHN0eWxlIC0gdGhlIHRleHQgc3R5bGUgdG8gdXNlIGZvciBtZWFzdXJpbmdcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3dvcmRXcmFwXSAtIG9wdGlvbmFsIG92ZXJyaWRlIGZvciBpZiB3b3JkLXdyYXAgc2hvdWxkIGJlIGFwcGxpZWQgdG8gdGhlIHRleHQuXHJcbiAgICAgKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50fSBbY2FudmFzXSAtIG9wdGlvbmFsIHNwZWNpZmljYXRpb24gb2YgdGhlIGNhbnZhcyB0byB1c2UgZm9yIG1lYXN1cmluZy5cclxuICAgICAqIEByZXR1cm4ge1BJWEkuVGV4dE1ldHJpY3N9IG1lYXN1cmVkIHdpZHRoIGFuZCBoZWlnaHQgb2YgdGhlIHRleHQuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBtZWFzdXJlVGV4dCh0ZXh0LCBzdHlsZSwgd29yZFdyYXAsIGNhbnZhcyA9IFRleHRNZXRyaWNzLl9jYW52YXMpIHtcclxuICAgICAgICB3b3JkV3JhcCA9ICh3b3JkV3JhcCA9PT0gdW5kZWZpbmVkIHx8IHdvcmRXcmFwID09PSBudWxsKSA/IHN0eWxlLndvcmRXcmFwIDogd29yZFdyYXA7XHJcbiAgICAgICAgdmFyIGZvbnQgPSBzdHlsZS50b0ZvbnRTdHJpbmcoKTtcclxuICAgICAgICB2YXIgZm9udFByb3BlcnRpZXMgPSBUZXh0TWV0cmljcy5tZWFzdXJlRm9udChmb250KTtcclxuICAgICAgICAvLyBmYWxsYmFjayBpbiBjYXNlIFVBIGRpc2FsbG93IGNhbnZhcyBkYXRhIGV4dHJhY3Rpb25cclxuICAgICAgICAvLyAodG9EYXRhVVJJLCBnZXRJbWFnZURhdGEgZnVuY3Rpb25zKVxyXG4gICAgICAgIGlmIChmb250UHJvcGVydGllcy5mb250U2l6ZSA9PT0gMCkge1xyXG4gICAgICAgICAgICBmb250UHJvcGVydGllcy5mb250U2l6ZSA9IHN0eWxlLmZvbnRTaXplO1xyXG4gICAgICAgICAgICBmb250UHJvcGVydGllcy5hc2NlbnQgPSBzdHlsZS5mb250U2l6ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcclxuICAgICAgICBjb250ZXh0LmZvbnQgPSBmb250O1xyXG4gICAgICAgIHZhciBvdXRwdXRUZXh0ID0gd29yZFdyYXAgPyBUZXh0TWV0cmljcy53b3JkV3JhcCh0ZXh0LCBzdHlsZSwgY2FudmFzKSA6IHRleHQ7XHJcbiAgICAgICAgdmFyIGxpbmVzID0gb3V0cHV0VGV4dC5zcGxpdCgvKD86XFxyXFxufFxccnxcXG4pLyk7XHJcbiAgICAgICAgdmFyIGxpbmVXaWR0aHMgPSBuZXcgQXJyYXkobGluZXMubGVuZ3RoKTtcclxuICAgICAgICB2YXIgbWF4TGluZVdpZHRoID0gMDtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBsaW5lV2lkdGggPSBjb250ZXh0Lm1lYXN1cmVUZXh0KGxpbmVzW2ldKS53aWR0aCArICgobGluZXNbaV0ubGVuZ3RoIC0gMSkgKiBzdHlsZS5sZXR0ZXJTcGFjaW5nKTtcclxuICAgICAgICAgICAgbGluZVdpZHRoc1tpXSA9IGxpbmVXaWR0aDtcclxuICAgICAgICAgICAgbWF4TGluZVdpZHRoID0gTWF0aC5tYXgobWF4TGluZVdpZHRoLCBsaW5lV2lkdGgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgd2lkdGggPSBtYXhMaW5lV2lkdGggKyBzdHlsZS5zdHJva2VUaGlja25lc3M7XHJcbiAgICAgICAgaWYgKHN0eWxlLmRyb3BTaGFkb3cpIHtcclxuICAgICAgICAgICAgd2lkdGggKz0gc3R5bGUuZHJvcFNoYWRvd0Rpc3RhbmNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbGluZUhlaWdodCA9IHN0eWxlLmxpbmVIZWlnaHQgfHwgZm9udFByb3BlcnRpZXMuZm9udFNpemUgKyBzdHlsZS5zdHJva2VUaGlja25lc3M7XHJcbiAgICAgICAgdmFyIGhlaWdodCA9IE1hdGgubWF4KGxpbmVIZWlnaHQsIGZvbnRQcm9wZXJ0aWVzLmZvbnRTaXplICsgc3R5bGUuc3Ryb2tlVGhpY2tuZXNzKVxyXG4gICAgICAgICAgICArICgobGluZXMubGVuZ3RoIC0gMSkgKiAobGluZUhlaWdodCArIHN0eWxlLmxlYWRpbmcpKTtcclxuICAgICAgICBpZiAoc3R5bGUuZHJvcFNoYWRvdykge1xyXG4gICAgICAgICAgICBoZWlnaHQgKz0gc3R5bGUuZHJvcFNoYWRvd0Rpc3RhbmNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IFRleHRNZXRyaWNzKHRleHQsIHN0eWxlLCB3aWR0aCwgaGVpZ2h0LCBsaW5lcywgbGluZVdpZHRocywgbGluZUhlaWdodCArIHN0eWxlLmxlYWRpbmcsIG1heExpbmVXaWR0aCwgZm9udFByb3BlcnRpZXMpO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBsaWVzIG5ld2xpbmVzIHRvIGEgc3RyaW5nIHRvIGhhdmUgaXQgb3B0aW1hbGx5IGZpdCBpbnRvIHRoZSBob3Jpem9udGFsXHJcbiAgICAgKiBib3VuZHMgc2V0IGJ5IHRoZSBUZXh0IG9iamVjdCdzIHdvcmRXcmFwV2lkdGggcHJvcGVydHkuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IC0gU3RyaW5nIHRvIGFwcGx5IHdvcmQgd3JhcHBpbmcgdG9cclxuICAgICAqIEBwYXJhbSB7UElYSS5UZXh0U3R5bGV9IHN0eWxlIC0gdGhlIHN0eWxlIHRvIHVzZSB3aGVuIHdyYXBwaW5nXHJcbiAgICAgKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50fSBbY2FudmFzXSAtIG9wdGlvbmFsIHNwZWNpZmljYXRpb24gb2YgdGhlIGNhbnZhcyB0byB1c2UgZm9yIG1lYXN1cmluZy5cclxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gTmV3IHN0cmluZyB3aXRoIG5ldyBsaW5lcyBhcHBsaWVkIHdoZXJlIHJlcXVpcmVkXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyB3b3JkV3JhcCh0ZXh0LCBzdHlsZSwgY2FudmFzKSB7XHJcbiAgICAgICAgaWYgKGNhbnZhcyA9PT0gdm9pZCAwKSB7XHJcbiAgICAgICAgICAgIGNhbnZhcyA9IFRleHRNZXRyaWNzLl9jYW52YXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XHJcbiAgICAgICAgdmFyIHdpZHRoID0gMDtcclxuICAgICAgICB2YXIgbGluZSA9ICcnO1xyXG4gICAgICAgIHZhciBsaW5lcyA9ICcnO1xyXG4gICAgICAgIHZhciBjYWNoZSA9IHt9O1xyXG4gICAgICAgIHZhciBsZXR0ZXJTcGFjaW5nID0gc3R5bGUubGV0dGVyU3BhY2luZztcclxuICAgICAgICB2YXIgd2hpdGVTcGFjZSA9IHN0eWxlLndoaXRlU3BhY2U7XHJcbiAgICAgICAgLy8gSG93IHRvIGhhbmRsZSB3aGl0ZXNwYWNlc1xyXG4gICAgICAgIHZhciBjb2xsYXBzZVNwYWNlcyA9IFRleHRNZXRyaWNzLmNvbGxhcHNlU3BhY2VzKHdoaXRlU3BhY2UpO1xyXG4gICAgICAgIHZhciBjb2xsYXBzZU5ld2xpbmVzID0gVGV4dE1ldHJpY3MuY29sbGFwc2VOZXdsaW5lcyh3aGl0ZVNwYWNlKTtcclxuICAgICAgICAvLyB3aGV0aGVyIG9yIG5vdCBzcGFjZXMgbWF5IGJlIGFkZGVkIHRvIHRoZSBiZWdpbm5pbmcgb2YgbGluZXNcclxuICAgICAgICB2YXIgY2FuUHJlcGVuZFNwYWNlcyA9ICFjb2xsYXBzZVNwYWNlcztcclxuICAgICAgICAvLyBUaGVyZSBpcyBsZXR0ZXJTcGFjaW5nIGFmdGVyIGV2ZXJ5IGNoYXIgZXhjZXB0IHRoZSBsYXN0IG9uZVxyXG4gICAgICAgIC8vIHRfaF9pX3NfJyAnX2lfc18nICdfYV9uXycgJ19lX3hfYV9tX3BfbF9lXycgJ18hXHJcbiAgICAgICAgLy8gc28gZm9yIGNvbnZlbmllbmNlIHRoZSBhYm92ZSBuZWVkcyB0byBiZSBjb21wYXJlZCB0byB3aWR0aCArIDEgZXh0cmEgbGV0dGVyU3BhY2VcclxuICAgICAgICAvLyB0X2hfaV9zXycgJ19pX3NfJyAnX2Ffbl8nICdfZV94X2FfbV9wX2xfZV8nICdfIV9cclxuICAgICAgICAvLyBfX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19cclxuICAgICAgICAvLyBBbmQgdGhlbiB0aGUgZmluYWwgc3BhY2UgaXMgc2ltcGx5IG5vIGFwcGVuZGVkIHRvIGVhY2ggbGluZVxyXG4gICAgICAgIHZhciB3b3JkV3JhcFdpZHRoID0gc3R5bGUud29yZFdyYXBXaWR0aCArIGxldHRlclNwYWNpbmc7XHJcbiAgICAgICAgLy8gYnJlYWsgdGV4dCBpbnRvIHdvcmRzLCBzcGFjZXMgYW5kIG5ld2xpbmUgY2hhcnNcclxuICAgICAgICB2YXIgdG9rZW5zID0gVGV4dE1ldHJpY3MudG9rZW5pemUodGV4dCk7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgLy8gZ2V0IHRoZSB3b3JkLCBzcGFjZSBvciBuZXdsaW5lQ2hhclxyXG4gICAgICAgICAgICB2YXIgdG9rZW4gPSB0b2tlbnNbaV07XHJcbiAgICAgICAgICAgIC8vIGlmIHdvcmQgaXMgYSBuZXcgbGluZVxyXG4gICAgICAgICAgICBpZiAoVGV4dE1ldHJpY3MuaXNOZXdsaW5lKHRva2VuKSkge1xyXG4gICAgICAgICAgICAgICAgLy8ga2VlcCB0aGUgbmV3IGxpbmVcclxuICAgICAgICAgICAgICAgIGlmICghY29sbGFwc2VOZXdsaW5lcykge1xyXG4gICAgICAgICAgICAgICAgICAgIGxpbmVzICs9IFRleHRNZXRyaWNzLmFkZExpbmUobGluZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FuUHJlcGVuZFNwYWNlcyA9ICFjb2xsYXBzZVNwYWNlcztcclxuICAgICAgICAgICAgICAgICAgICBsaW5lID0gJyc7XHJcbiAgICAgICAgICAgICAgICAgICAgd2lkdGggPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gaWYgd2Ugc2hvdWxkIGNvbGxhcHNlIG5ldyBsaW5lc1xyXG4gICAgICAgICAgICAgICAgLy8gd2Ugc2ltcGx5IGNvbnZlcnQgaXQgaW50byBhIHNwYWNlXHJcbiAgICAgICAgICAgICAgICB0b2tlbiA9ICcgJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBpZiB3ZSBzaG91bGQgY29sbGFwc2UgcmVwZWF0ZWQgd2hpdGVzcGFjZXNcclxuICAgICAgICAgICAgaWYgKGNvbGxhcHNlU3BhY2VzKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBjaGVjayBib3RoIHRoaXMgYW5kIHRoZSBsYXN0IHRva2VucyBmb3Igc3BhY2VzXHJcbiAgICAgICAgICAgICAgICB2YXIgY3VycklzQnJlYWtpbmdTcGFjZSA9IFRleHRNZXRyaWNzLmlzQnJlYWtpbmdTcGFjZSh0b2tlbik7XHJcbiAgICAgICAgICAgICAgICB2YXIgbGFzdElzQnJlYWtpbmdTcGFjZSA9IFRleHRNZXRyaWNzLmlzQnJlYWtpbmdTcGFjZShsaW5lW2xpbmUubGVuZ3RoIC0gMV0pO1xyXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJJc0JyZWFraW5nU3BhY2UgJiYgbGFzdElzQnJlYWtpbmdTcGFjZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGdldCB3b3JkIHdpZHRoIGZyb20gY2FjaGUgaWYgcG9zc2libGVcclxuICAgICAgICAgICAgdmFyIHRva2VuV2lkdGggPSBUZXh0TWV0cmljcy5nZXRGcm9tQ2FjaGUodG9rZW4sIGxldHRlclNwYWNpbmcsIGNhY2hlLCBjb250ZXh0KTtcclxuICAgICAgICAgICAgLy8gd29yZCBpcyBsb25nZXIgdGhhbiBkZXNpcmVkIGJvdW5kc1xyXG4gICAgICAgICAgICBpZiAodG9rZW5XaWR0aCA+IHdvcmRXcmFwV2lkdGgpIHtcclxuICAgICAgICAgICAgICAgIC8vIGlmIHdlIGFyZSBub3QgYWxyZWFkeSBhdCB0aGUgYmVnaW5uaW5nIG9mIGEgbGluZVxyXG4gICAgICAgICAgICAgICAgaWYgKGxpbmUgIT09ICcnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gc3RhcnQgbmV3bGluZXMgZm9yIG92ZXJmbG93IHdvcmRzXHJcbiAgICAgICAgICAgICAgICAgICAgbGluZXMgKz0gVGV4dE1ldHJpY3MuYWRkTGluZShsaW5lKTtcclxuICAgICAgICAgICAgICAgICAgICBsaW5lID0gJyc7XHJcbiAgICAgICAgICAgICAgICAgICAgd2lkdGggPSAwO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gYnJlYWsgbGFyZ2Ugd29yZCBvdmVyIG11bHRpcGxlIGxpbmVzXHJcbiAgICAgICAgICAgICAgICBpZiAoVGV4dE1ldHJpY3MuY2FuQnJlYWtXb3Jkcyh0b2tlbiwgc3R5bGUuYnJlYWtXb3JkcykpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBicmVhayB3b3JkIGludG8gY2hhcmFjdGVyc1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjaGFyYWN0ZXJzID0gdG9rZW4uc3BsaXQoJycpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGxvb3AgdGhlIGNoYXJhY3RlcnNcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNoYXJhY3RlcnMubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNoYXIgPSBjaGFyYWN0ZXJzW2pdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgayA9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIGFyZSBub3QgYXQgdGhlIGVuZCBvZiB0aGUgdG9rZW5cclxuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGNoYXJhY3RlcnNbaiArIGtdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmV4dENoYXIgPSBjaGFyYWN0ZXJzW2ogKyBrXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsYXN0Q2hhciA9IGNoYXJbY2hhci5sZW5ndGggLSAxXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNob3VsZCBub3Qgc3BsaXQgY2hhcnNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghVGV4dE1ldHJpY3MuY2FuQnJlYWtDaGFycyhsYXN0Q2hhciwgbmV4dENoYXIsIHRva2VuLCBqLCBzdHlsZS5icmVha1dvcmRzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbWJpbmUgY2hhcnMgJiBtb3ZlIGZvcndhcmQgb25lXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhciArPSBuZXh0Q2hhcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaysrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGogKz0gY2hhci5sZW5ndGggLSAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2hhcmFjdGVyV2lkdGggPSBUZXh0TWV0cmljcy5nZXRGcm9tQ2FjaGUoY2hhciwgbGV0dGVyU3BhY2luZywgY2FjaGUsIGNvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hhcmFjdGVyV2lkdGggKyB3aWR0aCA+IHdvcmRXcmFwV2lkdGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVzICs9IFRleHRNZXRyaWNzLmFkZExpbmUobGluZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW5QcmVwZW5kU3BhY2VzID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lID0gJyc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgbGluZSArPSBjaGFyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aCArPSBjaGFyYWN0ZXJXaWR0aDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBydW4gd29yZCBvdXQgb2YgdGhlIGJvdW5kc1xyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlcmUgYXJlIHdvcmRzIGluIHRoaXMgbGluZSBhbHJlYWR5XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZmluaXNoIHRoYXQgbGluZSBhbmQgc3RhcnQgYSBuZXcgb25lXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxpbmUubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lcyArPSBUZXh0TWV0cmljcy5hZGRMaW5lKGxpbmUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lID0gJyc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoID0gMDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlzTGFzdFRva2VuID0gaSA9PT0gdG9rZW5zLmxlbmd0aCAtIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZ2l2ZSBpdCBpdHMgb3duIGxpbmUgaWYgaXQncyBub3QgdGhlIGVuZFxyXG4gICAgICAgICAgICAgICAgICAgIGxpbmVzICs9IFRleHRNZXRyaWNzLmFkZExpbmUodG9rZW4sICFpc0xhc3RUb2tlbik7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FuUHJlcGVuZFNwYWNlcyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIGxpbmUgPSAnJztcclxuICAgICAgICAgICAgICAgICAgICB3aWR0aCA9IDA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gd29yZCBjb3VsZCBmaXRcclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyB3b3JkIHdvbid0IGZpdCBiZWNhdXNlIG9mIGV4aXN0aW5nIHdvcmRzXHJcbiAgICAgICAgICAgICAgICAvLyBzdGFydCBhIG5ldyBsaW5lXHJcbiAgICAgICAgICAgICAgICBpZiAodG9rZW5XaWR0aCArIHdpZHRoID4gd29yZFdyYXBXaWR0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIGl0cyBhIHNwYWNlIHdlIGRvbid0IHdhbnQgaXRcclxuICAgICAgICAgICAgICAgICAgICBjYW5QcmVwZW5kU3BhY2VzID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYWRkIGEgbmV3IGxpbmVcclxuICAgICAgICAgICAgICAgICAgICBsaW5lcyArPSBUZXh0TWV0cmljcy5hZGRMaW5lKGxpbmUpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHN0YXJ0IGEgbmV3IGxpbmVcclxuICAgICAgICAgICAgICAgICAgICBsaW5lID0gJyc7XHJcbiAgICAgICAgICAgICAgICAgICAgd2lkdGggPSAwO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gZG9uJ3QgYWRkIHNwYWNlcyB0byB0aGUgYmVnaW5uaW5nIG9mIGxpbmVzXHJcbiAgICAgICAgICAgICAgICBpZiAobGluZS5sZW5ndGggPiAwIHx8ICFUZXh0TWV0cmljcy5pc0JyZWFraW5nU3BhY2UodG9rZW4pIHx8IGNhblByZXBlbmRTcGFjZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBhZGQgdGhlIHdvcmQgdG8gdGhlIGN1cnJlbnQgbGluZVxyXG4gICAgICAgICAgICAgICAgICAgIGxpbmUgKz0gdG9rZW47XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdXBkYXRlIHdpZHRoIGNvdW50ZXJcclxuICAgICAgICAgICAgICAgICAgICB3aWR0aCArPSB0b2tlbldpZHRoO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxpbmVzICs9IFRleHRNZXRyaWNzLmFkZExpbmUobGluZSwgZmFsc2UpO1xyXG4gICAgICAgIHJldHVybiBsaW5lcztcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQ29udmllbmllbmNlIGZ1bmN0aW9uIGZvciBsb2dnaW5nIGVhY2ggbGluZSBhZGRlZCBkdXJpbmcgdGhlIHdvcmRXcmFwXHJcbiAgICAgKiBtZXRob2RcclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSAgIGxpbmUgICAgLSBUaGUgbGluZSBvZiB0ZXh0IHRvIGFkZFxyXG4gICAgICogQHBhcmFtICB7Ym9vbGVhbn0gIG5ld0xpbmUgLSBBZGQgbmV3IGxpbmUgY2hhcmFjdGVyIHRvIGVuZFxyXG4gICAgICogQHJldHVybiB7c3RyaW5nfSAgIEEgZm9ybWF0dGVkIGxpbmVcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGFkZExpbmUobGluZSwgbmV3TGluZSA9IHRydWUpIHtcclxuICAgICAgICBpZiAobmV3TGluZSA9PT0gdm9pZCAwKSB7XHJcbiAgICAgICAgICAgIG5ld0xpbmUgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsaW5lID0gVGV4dE1ldHJpY3MudHJpbVJpZ2h0KGxpbmUpO1xyXG4gICAgICAgIGxpbmUgPSAobmV3TGluZSkgPyAobGluZSArIFwiXFxuXCIpIDogbGluZTtcclxuICAgICAgICByZXR1cm4gbGluZTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogR2V0cyAmIHNldHMgdGhlIHdpZHRocyBvZiBjYWxjdWxhdGVkIGNoYXJhY3RlcnMgaW4gYSBjYWNoZSBvYmplY3RcclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSAgICAgICAgICAgICAgICBrZXkgICAgICAgIFRoZSBrZXlcclxuICAgICAqIEBwYXJhbSAge251bWJlcn0gICAgICAgICAgICAgICAgbGV0dGVyU3BhY2luZyAgVGhlIGxldHRlciBzcGFjaW5nXHJcbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgIGNhY2hlICAgICAgVGhlIGNhY2hlXHJcbiAgICAgKiBAcGFyYW0gIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9ICBjb250ZXh0ICAgIFRoZSBjYW52YXMgY29udGV4dFxyXG4gICAgICogQHJldHVybiB7bnVtYmVyfSAgICAgICAgICAgICAgICBUaGUgZnJvbSBjYWNoZS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGdldEZyb21DYWNoZShrZXksIGxldHRlclNwYWNpbmcsIGNhY2hlLCBjb250ZXh0KSB7XHJcbiAgICAgICAgdmFyIHdpZHRoID0gY2FjaGVba2V5XTtcclxuICAgICAgICBpZiAod2lkdGggPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB2YXIgc3BhY2luZyA9ICgoa2V5Lmxlbmd0aCkgKiBsZXR0ZXJTcGFjaW5nKTtcclxuICAgICAgICAgICAgd2lkdGggPSBjb250ZXh0Lm1lYXN1cmVUZXh0KGtleSkud2lkdGggKyBzcGFjaW5nO1xyXG4gICAgICAgICAgICBjYWNoZVtrZXldID0gd2lkdGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB3aWR0aDtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIHdlIHNob3VsZCBjb2xsYXBzZSBicmVha2luZyBzcGFjZXNcclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSAgIHdoaXRlU3BhY2UgIFRoZSBUZXh0U3R5bGUgcHJvcGVydHkgd2hpdGVTcGFjZVxyXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gIHNob3VsZCBjb2xsYXBzZVxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgY29sbGFwc2VTcGFjZXMod2hpdGVTcGFjZSkge1xyXG4gICAgICAgIHJldHVybiAod2hpdGVTcGFjZSA9PT0gJ25vcm1hbCcgfHwgd2hpdGVTcGFjZSA9PT0gJ3ByZS1saW5lJyk7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIERldGVybWluZXMgd2hldGhlciB3ZSBzaG91bGQgY29sbGFwc2UgbmV3TGluZSBjaGFyc1xyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9ICAgd2hpdGVTcGFjZSAgVGhlIHdoaXRlIHNwYWNlXHJcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSAgc2hvdWxkIGNvbGxhcHNlXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBjb2xsYXBzZU5ld2xpbmVzKHdoaXRlU3BhY2UpIHtcclxuICAgICAgICByZXR1cm4gKHdoaXRlU3BhY2UgPT09ICdub3JtYWwnKTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogdHJpbXMgYnJlYWtpbmcgd2hpdGVzcGFjZXMgZnJvbSBzdHJpbmdcclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSAgdGV4dCAgVGhlIHRleHRcclxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gIHRyaW1tZWQgc3RyaW5nXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyB0cmltUmlnaHQodGV4dCkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgdGV4dCAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKHZhciBpID0gdGV4dC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgICAgICB2YXIgY2hhciA9IHRleHRbaV07XHJcbiAgICAgICAgICAgIGlmICghVGV4dE1ldHJpY3MuaXNCcmVha2luZ1NwYWNlKGNoYXIpKSB7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0ZXh0ID0gdGV4dC5zbGljZSgwLCAtMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0ZXh0O1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBEZXRlcm1pbmVzIGlmIGNoYXIgaXMgYSBuZXdsaW5lLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9ICBjaGFyICBUaGUgY2hhcmFjdGVyXHJcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSAgVHJ1ZSBpZiBuZXdsaW5lLCBGYWxzZSBvdGhlcndpc2UuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBpc05ld2xpbmUoY2hhcikge1xyXG4gICAgICAgIGlmICh0eXBlb2YgY2hhciAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gKFRleHRNZXRyaWNzLl9uZXdsaW5lcy5pbmRleE9mKGNoYXIuY2hhckNvZGVBdCgwKSkgPj0gMCk7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIERldGVybWluZXMgaWYgY2hhciBpcyBhIGJyZWFraW5nIHdoaXRlc3BhY2UuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSAge3N0cmluZ30gIGNoYXIgIFRoZSBjaGFyYWN0ZXJcclxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59ICBUcnVlIGlmIHdoaXRlc3BhY2UsIEZhbHNlIG90aGVyd2lzZS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGlzQnJlYWtpbmdTcGFjZShjaGFyKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBjaGFyICE9PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAoVGV4dE1ldHJpY3MuX2JyZWFraW5nU3BhY2VzLmluZGV4T2YoY2hhci5jaGFyQ29kZUF0KDApKSA+PSAwKTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogU3BsaXRzIGEgc3RyaW5nIGludG8gd29yZHMsIGJyZWFraW5nLXNwYWNlcyBhbmQgbmV3TGluZSBjaGFyYWN0ZXJzXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSAge3N0cmluZ30gIHRleHQgICBUaGUgdGV4dFxyXG4gICAgICogQHJldHVybiB7c3RyaW5nW119ICBBIHRva2VuaXplZCBhcnJheVxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgdG9rZW5pemUodGV4dCkge1xyXG4gICAgICAgIHZhciB0b2tlbnMgPSBbXTtcclxuICAgICAgICB2YXIgdG9rZW4gPSAnJztcclxuICAgICAgICBpZiAodHlwZW9mIHRleHQgIT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0b2tlbnM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGV4dC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgY2hhciA9IHRleHRbaV07XHJcbiAgICAgICAgICAgIGlmIChUZXh0TWV0cmljcy5pc0JyZWFraW5nU3BhY2UoY2hhcikgfHwgVGV4dE1ldHJpY3MuaXNOZXdsaW5lKGNoYXIpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodG9rZW4gIT09ICcnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgIHRva2VuID0gJyc7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0b2tlbnMucHVzaChjaGFyKTtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRva2VuICs9IGNoYXI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0b2tlbiAhPT0gJycpIHtcclxuICAgICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdG9rZW5zO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIG1ldGhvZCBleGlzdHMgdG8gYmUgZWFzaWx5IG92ZXJyaWRkZW5cclxuICAgICAqIEl0IGFsbG93cyBvbmUgdG8gY3VzdG9taXNlIHdoaWNoIHdvcmRzIHNob3VsZCBicmVha1xyXG4gICAgICogRXhhbXBsZXMgYXJlIGlmIHRoZSB0b2tlbiBpcyBDSksgb3IgbnVtYmVycy5cclxuICAgICAqIEl0IG11c3QgcmV0dXJuIGEgYm9vbGVhbi5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSAgdG9rZW4gICBUaGUgdG9rZW5cclxuICAgICAqIEBwYXJhbSAge2Jvb2xlYW59ICBicmVha1dvcmRzICBUaGUgc3R5bGUgYXR0ciBicmVhayB3b3Jkc1xyXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gd2hldGhlciB0byBicmVhayB3b3JkIG9yIG5vdFxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgY2FuQnJlYWtXb3Jkcyh0b2tlbiwgYnJlYWtXb3Jkcykge1xyXG4gICAgICAgIHJldHVybiBicmVha1dvcmRzO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIG1ldGhvZCBleGlzdHMgdG8gYmUgZWFzaWx5IG92ZXJyaWRkZW5cclxuICAgICAqIEl0IGFsbG93cyBvbmUgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgYSBwYWlyIG9mIGNoYXJhY3RlcnNcclxuICAgICAqIHNob3VsZCBiZSBicm9rZW4gYnkgbmV3bGluZXNcclxuICAgICAqIEZvciBleGFtcGxlIGNlcnRhaW4gY2hhcmFjdGVycyBpbiBDSksgbGFuZ3Mgb3IgbnVtYmVycy5cclxuICAgICAqIEl0IG11c3QgcmV0dXJuIGEgYm9vbGVhbi5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSAgY2hhciAgVGhlIGNoYXJhY3RlclxyXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSAgbmV4dENoYXIgIFRoZSBuZXh0IGNoYXJhY3RlclxyXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSAgdG9rZW4gVGhlIHRva2VuL3dvcmQgdGhlIGNoYXJhY3RlcnMgYXJlIGZyb21cclxuICAgICAqIEBwYXJhbSAge251bWJlcn0gIGluZGV4IFRoZSBpbmRleCBpbiB0aGUgdG9rZW4gb2YgdGhlIGNoYXJcclxuICAgICAqIEBwYXJhbSAge2Jvb2xlYW59ICBicmVha1dvcmRzICBUaGUgc3R5bGUgYXR0ciBicmVhayB3b3Jkc1xyXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gd2hldGhlciB0byBicmVhayB3b3JkIG9yIG5vdFxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgY2FuQnJlYWtDaGFycyhjaGFyLCBuZXh0Q2hhciwgdG9rZW4sIGluZGV4LCBicmVha1dvcmRzKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIENhbGN1bGF0ZXMgdGhlIGFzY2VudCwgZGVzY2VudCBhbmQgZm9udFNpemUgb2YgYSBnaXZlbiBmb250LXN0eWxlXHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZvbnQgLSBTdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBzdHlsZSBvZiB0aGUgZm9udFxyXG4gICAgICogQHJldHVybiB7UElYSS5JRm9udE1ldHJpY3N9IEZvbnQgcHJvcGVydGllcyBvYmplY3RcclxuICAgICAqL1xyXG4gICAgc3RhdGljIG1lYXN1cmVGb250KGZvbnQpIHtcclxuICAgICAgICAvLyBhcyB0aGlzIG1ldGhvZCBpcyB1c2VkIGZvciBwcmVwYXJpbmcgYXNzZXRzLCBkb24ndCByZWNhbGN1bGF0ZSB0aGluZ3MgaWYgd2UgZG9uJ3QgbmVlZCB0b1xyXG4gICAgICAgIGlmIChUZXh0TWV0cmljcy5fZm9udHNbZm9udF0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIFRleHRNZXRyaWNzLl9mb250c1tmb250XTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHByb3BlcnRpZXMgPSB7fTtcclxuICAgICAgICB2YXIgY2FudmFzID0gVGV4dE1ldHJpY3MuX2NhbnZhcztcclxuICAgICAgICB2YXIgY29udGV4dCA9IFRleHRNZXRyaWNzLl9jb250ZXh0O1xyXG4gICAgICAgIGNvbnRleHQuZm9udCA9IGZvbnQ7XHJcbiAgICAgICAgdmFyIG1ldHJpY3NTdHJpbmcgPSBUZXh0TWV0cmljcy5NRVRSSUNTX1NUUklORyArIFRleHRNZXRyaWNzLkJBU0VMSU5FX1NZTUJPTDtcclxuICAgICAgICB2YXIgd2lkdGggPSBNYXRoLmNlaWwoY29udGV4dC5tZWFzdXJlVGV4dChtZXRyaWNzU3RyaW5nKS53aWR0aCk7XHJcbiAgICAgICAgdmFyIGJhc2VsaW5lID0gTWF0aC5jZWlsKGNvbnRleHQubWVhc3VyZVRleHQoVGV4dE1ldHJpY3MuQkFTRUxJTkVfU1lNQk9MKS53aWR0aCk7XHJcbiAgICAgICAgdmFyIGhlaWdodCA9IDIgKiBiYXNlbGluZTtcclxuICAgICAgICBiYXNlbGluZSA9IGJhc2VsaW5lICogVGV4dE1ldHJpY3MuQkFTRUxJTkVfTVVMVElQTElFUiB8IDA7XHJcbiAgICAgICAgY2FudmFzLndpZHRoID0gd2lkdGg7XHJcbiAgICAgICAgY2FudmFzLmhlaWdodCA9IGhlaWdodDtcclxuICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9ICcjZjAwJztcclxuICAgICAgICBjb250ZXh0LmZpbGxSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgICAgIGNvbnRleHQuZm9udCA9IGZvbnQ7XHJcbiAgICAgICAgY29udGV4dC50ZXh0QmFzZWxpbmUgPSAnYWxwaGFiZXRpYyc7XHJcbiAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSAnIzAwMCc7XHJcbiAgICAgICAgY29udGV4dC5maWxsVGV4dChtZXRyaWNzU3RyaW5nLCAwLCBiYXNlbGluZSk7XHJcbiAgICAgICAgdmFyIGltYWdlZGF0YSA9IGNvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIHdpZHRoLCBoZWlnaHQpLmRhdGE7XHJcbiAgICAgICAgdmFyIHBpeGVscyA9IGltYWdlZGF0YS5sZW5ndGg7XHJcbiAgICAgICAgdmFyIGxpbmUgPSB3aWR0aCAqIDQ7XHJcbiAgICAgICAgdmFyIGkgPSAwO1xyXG4gICAgICAgIHZhciBpZHggPSAwO1xyXG4gICAgICAgIHZhciBzdG9wID0gZmFsc2U7XHJcbiAgICAgICAgLy8gYXNjZW50LiBzY2FuIGZyb20gdG9wIHRvIGJvdHRvbSB1bnRpbCB3ZSBmaW5kIGEgbm9uIHJlZCBwaXhlbFxyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBiYXNlbGluZTsgKytpKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGluZTsgaiArPSA0KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaW1hZ2VkYXRhW2lkeCArIGpdICE9PSAyNTUpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdG9wID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIXN0b3ApIHtcclxuICAgICAgICAgICAgICAgIGlkeCArPSBsaW5lO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcHJvcGVydGllcy5hc2NlbnQgPSBiYXNlbGluZSAtIGk7XHJcbiAgICAgICAgaWR4ID0gcGl4ZWxzIC0gbGluZTtcclxuICAgICAgICBzdG9wID0gZmFsc2U7XHJcbiAgICAgICAgLy8gZGVzY2VudC4gc2NhbiBmcm9tIGJvdHRvbSB0byB0b3AgdW50aWwgd2UgZmluZCBhIG5vbiByZWQgcGl4ZWxcclxuICAgICAgICBmb3IgKGkgPSBoZWlnaHQ7IGkgPiBiYXNlbGluZTsgLS1pKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGokMSA9IDA7IGokMSA8IGxpbmU7IGokMSArPSA0KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaW1hZ2VkYXRhW2lkeCArIGokMV0gIT09IDI1NSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0b3AgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghc3RvcCkge1xyXG4gICAgICAgICAgICAgICAgaWR4IC09IGxpbmU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBwcm9wZXJ0aWVzLmRlc2NlbnQgPSBpIC0gYmFzZWxpbmU7XHJcbiAgICAgICAgcHJvcGVydGllcy5mb250U2l6ZSA9IHByb3BlcnRpZXMuYXNjZW50ICsgcHJvcGVydGllcy5kZXNjZW50O1xyXG4gICAgICAgIFRleHRNZXRyaWNzLl9mb250c1tmb250XSA9IHByb3BlcnRpZXM7XHJcbiAgICAgICAgcmV0dXJuIHByb3BlcnRpZXM7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIENsZWFyIGZvbnQgbWV0cmljcyBpbiBtZXRyaWNzIGNhY2hlLlxyXG4gICAgICpcclxuICAgICAqIEBzdGF0aWNcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbZm9udF0gLSBmb250IG5hbWUuIElmIGZvbnQgbmFtZSBub3Qgc2V0IHRoZW4gY2xlYXIgY2FjaGUgZm9yIGFsbCBmb250cy5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGNsZWFyTWV0cmljcyhmb250KSB7XHJcbiAgICAgICAgaWYgKGZvbnQgPT09IHZvaWQgMCkge1xyXG4gICAgICAgICAgICBmb250ID0gJyc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChmb250KSB7XHJcbiAgICAgICAgICAgIGRlbGV0ZSBUZXh0TWV0cmljcy5fZm9udHNbZm9udF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBUZXh0TWV0cmljcy5fZm9udHMgPSB7fTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICA7XHJcbn1cclxuLyoqXHJcbiAqIEludGVybmFsIHJldHVybiBvYmplY3QgZm9yIHtAbGluayBQSVhJLlRleHRNZXRyaWNzLm1lYXN1cmVGb250IGBUZXh0TWV0cmljcy5tZWFzdXJlRm9udGB9LlxyXG4gKlxyXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBGb250TWV0cmljc1xyXG4gKiBAcHJvcGVydHkge251bWJlcn0gYXNjZW50IC0gVGhlIGFzY2VudCBkaXN0YW5jZVxyXG4gKiBAcHJvcGVydHkge251bWJlcn0gZGVzY2VudCAtIFRoZSBkZXNjZW50IGRpc3RhbmNlXHJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBmb250U2l6ZSAtIEZvbnQgc2l6ZSBmcm9tIGFzY2VudCB0byBkZXNjZW50XHJcbiAqIEBtZW1iZXJvZiBQSVhJLlRleHRNZXRyaWNzXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG4vKipcclxuICogQ2FjaGUgb2Yge0BzZWUgUElYSS5UZXh0TWV0cmljcy5Gb250TWV0cmljc30gb2JqZWN0cy5cclxuICogQG1lbWJlcm9mIFBJWEkuVGV4dE1ldHJpY3NcclxuICogQHR5cGUge09iamVjdH1cclxuICogQHByaXZhdGVcclxuICovXHJcblRleHRNZXRyaWNzLl9mb250cyA9IHt9O1xyXG4vKipcclxuICogU3RyaW5nIHVzZWQgZm9yIGNhbGN1bGF0ZSBmb250IG1ldHJpY3MuXHJcbiAqIEBzdGF0aWNcclxuICogQG1lbWJlcm9mIFBJWEkuVGV4dE1ldHJpY3NcclxuICogQG5hbWUgTUVUUklDU19TVFJJTkdcclxuICogQHR5cGUge3N0cmluZ31cclxuICogQGRlZmF1bHQgfMOJcVxyXG4gKi9cclxuVGV4dE1ldHJpY3MuTUVUUklDU19TVFJJTkcgPSAnfMOJcSc7XHJcbi8qKlxyXG4gKiBCYXNlbGluZSBzeW1ib2wgZm9yIGNhbGN1bGF0ZSBmb250IG1ldHJpY3MuXHJcbiAqIEBzdGF0aWNcclxuICogQG1lbWJlcm9mIFBJWEkuVGV4dE1ldHJpY3NcclxuICogQG5hbWUgQkFTRUxJTkVfU1lNQk9MXHJcbiAqIEB0eXBlIHtzdHJpbmd9XHJcbiAqIEBkZWZhdWx0IE1cclxuICovXHJcblRleHRNZXRyaWNzLkJBU0VMSU5FX1NZTUJPTCA9ICdNJztcclxuLyoqXHJcbiAqIEJhc2VsaW5lIG11bHRpcGxpZXIgZm9yIGNhbGN1bGF0ZSBmb250IG1ldHJpY3MuXHJcbiAqIEBzdGF0aWNcclxuICogQG1lbWJlcm9mIFBJWEkuVGV4dE1ldHJpY3NcclxuICogQG5hbWUgQkFTRUxJTkVfTVVMVElQTElFUlxyXG4gKiBAdHlwZSB7bnVtYmVyfVxyXG4gKiBAZGVmYXVsdCAxLjRcclxuICovXHJcblRleHRNZXRyaWNzLkJBU0VMSU5FX01VTFRJUExJRVIgPSAxLjQ7XHJcbi8qKlxyXG4gKiBDYWNoZSBvZiBuZXcgbGluZSBjaGFycy5cclxuICogQG1lbWJlcm9mIFBJWEkuVGV4dE1ldHJpY3NcclxuICogQHR5cGUge251bWJlcltdfVxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuVGV4dE1ldHJpY3MuX25ld2xpbmVzID0gW1xyXG4gICAgMHgwMDBBLFxyXG4gICAgMHgwMDBEXHJcbl07XHJcbi8qKlxyXG4gKiBDYWNoZSBvZiBicmVha2luZyBzcGFjZXMuXHJcbiAqIEBtZW1iZXJvZiBQSVhJLlRleHRNZXRyaWNzXHJcbiAqIEB0eXBlIHtudW1iZXJbXX1cclxuICogQHByaXZhdGVcclxuICovXHJcblRleHRNZXRyaWNzLl9icmVha2luZ1NwYWNlcyA9IFtcclxuICAgIDB4MDAwOSxcclxuICAgIDB4MDAyMCxcclxuICAgIDB4MjAwMCxcclxuICAgIDB4MjAwMSxcclxuICAgIDB4MjAwMixcclxuICAgIDB4MjAwMyxcclxuICAgIDB4MjAwNCxcclxuICAgIDB4MjAwNSxcclxuICAgIDB4MjAwNixcclxuICAgIDB4MjAwOCxcclxuICAgIDB4MjAwOSxcclxuICAgIDB4MjAwQSxcclxuICAgIDB4MjA1RixcclxuICAgIDB4MzAwMFxyXG5dO1xyXG5leHBvcnRzLlRleHRNZXRyaWNzID0gVGV4dE1ldHJpY3M7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNsYXNzIFRleHRTZXR0aW5ncyB7XHJcbn1cclxuVGV4dFNldHRpbmdzLlRFWFRfR1JBRElFTlQgPSB7XHJcbiAgICBMSU5FQVJfVkVSVElDQUw6IDAsXHJcbiAgICBMSU5FQVJfSE9SSVpPTlRBTDogMSxcclxufTtcclxuVGV4dFNldHRpbmdzLmRlZmF1bHRTdHlsZSA9IHtcclxuICAgIGFsaWduOiAnbGVmdCcsXHJcbiAgICBicmVha1dvcmRzOiBmYWxzZSxcclxuICAgIGRyb3BTaGFkb3c6IGZhbHNlLFxyXG4gICAgZHJvcFNoYWRvd0FscGhhOiAxLFxyXG4gICAgZHJvcFNoYWRvd0FuZ2xlOiBNYXRoLlBJIC8gNixcclxuICAgIGRyb3BTaGFkb3dCbHVyOiAwLFxyXG4gICAgZHJvcFNoYWRvd0NvbG9yOiAnYmxhY2snLFxyXG4gICAgZHJvcFNoYWRvd0Rpc3RhbmNlOiA1LFxyXG4gICAgZmlsbDogJ2JsYWNrJyxcclxuICAgIGZpbGxHcmFkaWVudFR5cGU6IFRleHRTZXR0aW5ncy5URVhUX0dSQURJRU5ULkxJTkVBUl9WRVJUSUNBTCxcclxuICAgIGZpbGxHcmFkaWVudFN0b3BzOiBbXSxcclxuICAgIGZvbnRGYW1pbHk6ICdBcmlhbCcsXHJcbiAgICBmb250U2l6ZTogMjYsXHJcbiAgICBmb250U3R5bGU6ICdub3JtYWwnLFxyXG4gICAgZm9udFZhcmlhbnQ6ICdub3JtYWwnLFxyXG4gICAgZm9udFdlaWdodDogJ25vcm1hbCcsXHJcbiAgICBsZXR0ZXJTcGFjaW5nOiAwLFxyXG4gICAgbGluZUhlaWdodDogMCxcclxuICAgIGxpbmVKb2luOiAnbWl0ZXInLFxyXG4gICAgbWl0ZXJMaW1pdDogMTAsXHJcbiAgICBwYWRkaW5nOiAwLFxyXG4gICAgc3Ryb2tlOiAnYmxhY2snLFxyXG4gICAgc3Ryb2tlVGhpY2tuZXNzOiAwLFxyXG4gICAgdGV4dEJhc2VsaW5lOiAnYWxwaGFiZXRpYycsXHJcbiAgICB0cmltOiBmYWxzZSxcclxuICAgIHdoaXRlU3BhY2U6ICdwcmUnLFxyXG4gICAgd29yZFdyYXA6IGZhbHNlLFxyXG4gICAgd29yZFdyYXBXaWR0aDogMTAwLFxyXG4gICAgbGVhZGluZzogMCxcclxufTtcclxuZXhwb3J0cy5UZXh0U2V0dGluZ3MgPSBUZXh0U2V0dGluZ3M7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IFRleHRTZXR0aW5nc18xID0gcmVxdWlyZShcIi4vVGV4dFNldHRpbmdzXCIpO1xyXG5jb25zdCBDb2xvclNldHRpbmdzXzEgPSByZXF1aXJlKFwiLi9Db2xvclNldHRpbmdzXCIpO1xyXG5jb25zdCBVdGlsc1NldHRpbmdzXzEgPSByZXF1aXJlKFwiLi9VdGlsc1NldHRpbmdzXCIpO1xyXG5jbGFzcyBUZXh0U3R5bGUge1xyXG4gICAgY29uc3RydWN0b3Ioc3R5bGUpIHtcclxuICAgICAgICB0aGlzLnN0eWxlSUQgPSAwO1xyXG4gICAgICAgIHRoaXMucmVzZXQoKTtcclxuICAgICAgICBVdGlsc1NldHRpbmdzXzEuVXRpbHNTZXR0aW5ncy5kZWVwQ29weVByb3BlcnRpZXModGhpcywgc3R5bGUsIHN0eWxlKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBUZXh0U3R5bGUgb2JqZWN0IHdpdGggdGhlIHNhbWUgdmFsdWVzIGFzIHRoaXMgb25lLlxyXG4gICAgICogTm90ZSB0aGF0IHRoZSBvbmx5IHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBvYmplY3QgYXJlIGNsb25lZC5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIHtQSVhJLlRleHRTdHlsZX0gTmV3IGNsb25lZCBUZXh0U3R5bGUgb2JqZWN0XHJcbiAgICAgKi9cclxuICAgIGNsb25lKCkge1xyXG4gICAgICAgIHZhciBjbG9uZWRQcm9wZXJ0aWVzID0ge307XHJcbiAgICAgICAgVXRpbHNTZXR0aW5nc18xLlV0aWxzU2V0dGluZ3MuZGVlcENvcHlQcm9wZXJ0aWVzKGNsb25lZFByb3BlcnRpZXMsIHRoaXMsIFRleHRTZXR0aW5nc18xLlRleHRTZXR0aW5ncy5kZWZhdWx0U3R5bGUpO1xyXG4gICAgICAgIHJldHVybiBuZXcgVGV4dFN0eWxlKGNsb25lZFByb3BlcnRpZXMpO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXNldHMgYWxsIHByb3BlcnRpZXMgdG8gdGhlIGRlZmF1bHRzIHNwZWNpZmllZCBpbiBUZXh0U3R5bGUucHJvdG90eXBlLl9kZWZhdWx0XHJcbiAgICAgKi9cclxuICAgIHJlc2V0KCkge1xyXG4gICAgICAgIFV0aWxzU2V0dGluZ3NfMS5VdGlsc1NldHRpbmdzLmRlZXBDb3B5UHJvcGVydGllcyh0aGlzLCBUZXh0U2V0dGluZ3NfMS5UZXh0U2V0dGluZ3MuZGVmYXVsdFN0eWxlLCBUZXh0U2V0dGluZ3NfMS5UZXh0U2V0dGluZ3MuZGVmYXVsdFN0eWxlKTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQWxpZ25tZW50IGZvciBtdWx0aWxpbmUgdGV4dCAoJ2xlZnQnLCAnY2VudGVyJyBvciAncmlnaHQnKSwgZG9lcyBub3QgYWZmZWN0IHNpbmdsZSBsaW5lIHRleHRcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtzdHJpbmd9XHJcbiAgICAgKi9cclxuICAgIGdldCBhbGlnbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fYWxpZ247XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICBzZXQgYWxpZ24oYWxpZ24pIHtcclxuICAgICAgICBpZiAodGhpcy5fYWxpZ24gIT09IGFsaWduKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2FsaWduID0gYWxpZ247XHJcbiAgICAgICAgICAgIHRoaXMuc3R5bGVJRCsrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogSW5kaWNhdGVzIGlmIGxpbmVzIGNhbiBiZSB3cmFwcGVkIHdpdGhpbiB3b3JkcywgaXQgbmVlZHMgd29yZFdyYXAgdG8gYmUgc2V0IHRvIHRydWVcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICBnZXQgYnJlYWtXb3JkcygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fYnJlYWtXb3JkcztcclxuICAgIH1cclxuICAgIDtcclxuICAgIHNldCBicmVha1dvcmRzKGJyZWFrV29yZHMpIHtcclxuICAgICAgICBpZiAodGhpcy5fYnJlYWtXb3JkcyAhPT0gYnJlYWtXb3Jkcykge1xyXG4gICAgICAgICAgICB0aGlzLl9icmVha1dvcmRzID0gYnJlYWtXb3JkcztcclxuICAgICAgICAgICAgdGhpcy5zdHlsZUlEKys7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgYSBkcm9wIHNoYWRvdyBmb3IgdGhlIHRleHRcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICBnZXQgZHJvcFNoYWRvdygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZHJvcFNoYWRvdztcclxuICAgIH1cclxuICAgIDtcclxuICAgIHNldCBkcm9wU2hhZG93KGRyb3BTaGFkb3cpIHtcclxuICAgICAgICBpZiAodGhpcy5fZHJvcFNoYWRvdyAhPT0gZHJvcFNoYWRvdykge1xyXG4gICAgICAgICAgICB0aGlzLl9kcm9wU2hhZG93ID0gZHJvcFNoYWRvdztcclxuICAgICAgICAgICAgdGhpcy5zdHlsZUlEKys7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgYWxwaGEgZm9yIHRoZSBkcm9wIHNoYWRvd1xyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgZ2V0IGRyb3BTaGFkb3dBbHBoYSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZHJvcFNoYWRvd0FscGhhO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgc2V0IGRyb3BTaGFkb3dBbHBoYShkcm9wU2hhZG93QWxwaGEpIHtcclxuICAgICAgICBpZiAodGhpcy5fZHJvcFNoYWRvd0FscGhhICE9PSBkcm9wU2hhZG93QWxwaGEpIHtcclxuICAgICAgICAgICAgdGhpcy5fZHJvcFNoYWRvd0FscGhhID0gZHJvcFNoYWRvd0FscGhhO1xyXG4gICAgICAgICAgICB0aGlzLnN0eWxlSUQrKztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFNldCBhIGFuZ2xlIG9mIHRoZSBkcm9wIHNoYWRvd1xyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgZ2V0IGRyb3BTaGFkb3dBbmdsZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZHJvcFNoYWRvd0FuZ2xlO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgc2V0IGRyb3BTaGFkb3dBbmdsZShkcm9wU2hhZG93QW5nbGUpIHtcclxuICAgICAgICBpZiAodGhpcy5fZHJvcFNoYWRvd0FuZ2xlICE9PSBkcm9wU2hhZG93QW5nbGUpIHtcclxuICAgICAgICAgICAgdGhpcy5fZHJvcFNoYWRvd0FuZ2xlID0gZHJvcFNoYWRvd0FuZ2xlO1xyXG4gICAgICAgICAgICB0aGlzLnN0eWxlSUQrKztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFNldCBhIHNoYWRvdyBibHVyIHJhZGl1c1xyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgZ2V0IGRyb3BTaGFkb3dCbHVyKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9kcm9wU2hhZG93Qmx1cjtcclxuICAgIH1cclxuICAgIDtcclxuICAgIHNldCBkcm9wU2hhZG93Qmx1cihkcm9wU2hhZG93Qmx1cikge1xyXG4gICAgICAgIGlmICh0aGlzLl9kcm9wU2hhZG93Qmx1ciAhPT0gZHJvcFNoYWRvd0JsdXIpIHtcclxuICAgICAgICAgICAgdGhpcy5fZHJvcFNoYWRvd0JsdXIgPSBkcm9wU2hhZG93Qmx1cjtcclxuICAgICAgICAgICAgdGhpcy5zdHlsZUlEKys7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBIGZpbGwgc3R5bGUgdG8gYmUgdXNlZCBvbiB0aGUgZHJvcHNoYWRvdyBlLmcgJ3JlZCcsICcjMDBGRjAwJ1xyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge3N0cmluZ3xudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIGdldCBkcm9wU2hhZG93Q29sb3IoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Ryb3BTaGFkb3dDb2xvcjtcclxuICAgIH1cclxuICAgIDtcclxuICAgIHNldCBkcm9wU2hhZG93Q29sb3IoZHJvcFNoYWRvd0NvbG9yKSB7XHJcbiAgICAgICAgdmFyIG91dHB1dENvbG9yID0gQ29sb3JTZXR0aW5nc18xLkNvbG9yU2V0dGluZ3MuZ2V0Q29sb3IoZHJvcFNoYWRvd0NvbG9yKTtcclxuICAgICAgICBpZiAodGhpcy5fZHJvcFNoYWRvd0NvbG9yICE9PSBvdXRwdXRDb2xvcikge1xyXG4gICAgICAgICAgICB0aGlzLl9kcm9wU2hhZG93Q29sb3IgPSBvdXRwdXRDb2xvcjtcclxuICAgICAgICAgICAgdGhpcy5zdHlsZUlEKys7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgYSBkaXN0YW5jZSBvZiB0aGUgZHJvcCBzaGFkb3dcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIGdldCBkcm9wU2hhZG93RGlzdGFuY2UoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Ryb3BTaGFkb3dEaXN0YW5jZTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIHNldCBkcm9wU2hhZG93RGlzdGFuY2UoZHJvcFNoYWRvd0Rpc3RhbmNlKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2Ryb3BTaGFkb3dEaXN0YW5jZSAhPT0gZHJvcFNoYWRvd0Rpc3RhbmNlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2Ryb3BTaGFkb3dEaXN0YW5jZSA9IGRyb3BTaGFkb3dEaXN0YW5jZTtcclxuICAgICAgICAgICAgdGhpcy5zdHlsZUlEKys7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBIGNhbnZhcyBmaWxsc3R5bGUgdGhhdCB3aWxsIGJlIHVzZWQgb24gdGhlIHRleHQgZS5nICdyZWQnLCAnIzAwRkYwMCcuXHJcbiAgICAgKiBDYW4gYmUgYW4gYXJyYXkgdG8gY3JlYXRlIGEgZ3JhZGllbnQgZWcgWycjMDAwMDAwJywnI0ZGRkZGRiddXHJcbiAgICAgKiB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC9maWxsU3R5bGV8TUROfVxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge3N0cmluZ3xzdHJpbmdbXXxudW1iZXJ8bnVtYmVyW118Q2FudmFzR3JhZGllbnR8Q2FudmFzUGF0dGVybn1cclxuICAgICAqL1xyXG4gICAgZ2V0IGZpbGwoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZpbGw7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICBzZXQgZmlsbChmaWxsKSB7XHJcbiAgICAgICAgdmFyIG91dHB1dENvbG9yID0gQ29sb3JTZXR0aW5nc18xLkNvbG9yU2V0dGluZ3MuZ2V0Q29sb3IoZmlsbCk7XHJcbiAgICAgICAgaWYgKHRoaXMuX2ZpbGwgIT09IG91dHB1dENvbG9yKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2ZpbGwgPSBvdXRwdXRDb2xvcjtcclxuICAgICAgICAgICAgdGhpcy5zdHlsZUlEKys7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBJZiBmaWxsIGlzIGFuIGFycmF5IG9mIGNvbG91cnMgdG8gY3JlYXRlIGEgZ3JhZGllbnQsIHRoaXMgY2FuIGNoYW5nZSB0aGUgdHlwZS9kaXJlY3Rpb24gb2YgdGhlIGdyYWRpZW50LlxyXG4gICAgICogU2VlIHtAbGluayBQSVhJLlRFWFRfR1JBRElFTlR9XHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICBnZXQgZmlsbEdyYWRpZW50VHlwZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZmlsbEdyYWRpZW50VHlwZTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIHNldCBmaWxsR3JhZGllbnRUeXBlKGZpbGxHcmFkaWVudFR5cGUpIHtcclxuICAgICAgICBpZiAodGhpcy5fZmlsbEdyYWRpZW50VHlwZSAhPT0gZmlsbEdyYWRpZW50VHlwZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9maWxsR3JhZGllbnRUeXBlID0gZmlsbEdyYWRpZW50VHlwZTtcclxuICAgICAgICAgICAgdGhpcy5zdHlsZUlEKys7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBJZiBmaWxsIGlzIGFuIGFycmF5IG9mIGNvbG91cnMgdG8gY3JlYXRlIGEgZ3JhZGllbnQsIHRoaXMgYXJyYXkgY2FuIHNldCB0aGUgc3RvcCBwb2ludHNcclxuICAgICAqIChudW1iZXJzIGJldHdlZW4gMCBhbmQgMSkgZm9yIHRoZSBjb2xvciwgb3ZlcnJpZGluZyB0aGUgZGVmYXVsdCBiZWhhdmlvdXIgb2YgZXZlbmx5IHNwYWNpbmcgdGhlbS5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJbXX1cclxuICAgICAqL1xyXG4gICAgZ2V0IGZpbGxHcmFkaWVudFN0b3BzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9maWxsR3JhZGllbnRTdG9wcztcclxuICAgIH1cclxuICAgIDtcclxuICAgIHNldCBmaWxsR3JhZGllbnRTdG9wcyhmaWxsR3JhZGllbnRTdG9wcykge1xyXG4gICAgICAgIGlmICghVXRpbHNTZXR0aW5nc18xLlV0aWxzU2V0dGluZ3MuYXJlQXJyYXlzRXF1YWwodGhpcy5fZmlsbEdyYWRpZW50U3RvcHMsIGZpbGxHcmFkaWVudFN0b3BzKSkge1xyXG4gICAgICAgICAgICB0aGlzLl9maWxsR3JhZGllbnRTdG9wcyA9IGZpbGxHcmFkaWVudFN0b3BzO1xyXG4gICAgICAgICAgICB0aGlzLnN0eWxlSUQrKztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBmb250IGZhbWlseVxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge3N0cmluZ3xzdHJpbmdbXX1cclxuICAgICAqL1xyXG4gICAgZ2V0IGZvbnRGYW1pbHkoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZvbnRGYW1pbHk7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICBzZXQgZm9udEZhbWlseShmb250RmFtaWx5KSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZm9udEZhbWlseSAhPT0gZm9udEZhbWlseSkge1xyXG4gICAgICAgICAgICB0aGlzLl9mb250RmFtaWx5ID0gZm9udEZhbWlseTtcclxuICAgICAgICAgICAgdGhpcy5zdHlsZUlEKys7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgZm9udCBzaXplXHJcbiAgICAgKiAoYXMgYSBudW1iZXIgaXQgY29udmVydHMgdG8gcHgsIGJ1dCBhcyBhIHN0cmluZywgZXF1aXZhbGVudHMgYXJlICcyNnB4JywnMjBwdCcsJzE2MCUnIG9yICcxLjZlbScpXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7bnVtYmVyfHN0cmluZ31cclxuICAgICAqL1xyXG4gICAgZ2V0IGZvbnRTaXplKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9mb250U2l6ZTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIHNldCBmb250U2l6ZShmb250U2l6ZSkge1xyXG4gICAgICAgIGlmICh0aGlzLl9mb250U2l6ZSAhPT0gZm9udFNpemUpIHtcclxuICAgICAgICAgICAgdGhpcy5fZm9udFNpemUgPSBmb250U2l6ZTtcclxuICAgICAgICAgICAgdGhpcy5zdHlsZUlEKys7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgZm9udCBzdHlsZVxyXG4gICAgICogKCdub3JtYWwnLCAnaXRhbGljJyBvciAnb2JsaXF1ZScpXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7c3RyaW5nfVxyXG4gICAgICovXHJcbiAgICBnZXQgZm9udFN0eWxlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9mb250U3R5bGU7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICBzZXQgZm9udFN0eWxlKGZvbnRTdHlsZSkge1xyXG4gICAgICAgIGlmICh0aGlzLl9mb250U3R5bGUgIT09IGZvbnRTdHlsZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9mb250U3R5bGUgPSBmb250U3R5bGU7XHJcbiAgICAgICAgICAgIHRoaXMuc3R5bGVJRCsrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGZvbnQgdmFyaWFudFxyXG4gICAgICogKCdub3JtYWwnIG9yICdzbWFsbC1jYXBzJylcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtzdHJpbmd9XHJcbiAgICAgKi9cclxuICAgIGdldCBmb250VmFyaWFudCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZm9udFZhcmlhbnQ7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICBzZXQgZm9udFZhcmlhbnQoZm9udFZhcmlhbnQpIHtcclxuICAgICAgICBpZiAodGhpcy5fZm9udFZhcmlhbnQgIT09IGZvbnRWYXJpYW50KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2ZvbnRWYXJpYW50ID0gZm9udFZhcmlhbnQ7XHJcbiAgICAgICAgICAgIHRoaXMuc3R5bGVJRCsrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGZvbnQgd2VpZ2h0XHJcbiAgICAgKiAoJ25vcm1hbCcsICdib2xkJywgJ2JvbGRlcicsICdsaWdodGVyJyBhbmQgJzEwMCcsICcyMDAnLCAnMzAwJywgJzQwMCcsICc1MDAnLCAnNjAwJywgJzcwMCcsIDgwMCcgb3IgJzkwMCcpXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7c3RyaW5nfVxyXG4gICAgICovXHJcbiAgICBnZXQgZm9udFdlaWdodCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZm9udFdlaWdodDtcclxuICAgIH1cclxuICAgIDtcclxuICAgIHNldCBmb250V2VpZ2h0KGZvbnRXZWlnaHQpIHtcclxuICAgICAgICBpZiAodGhpcy5fZm9udFdlaWdodCAhPT0gZm9udFdlaWdodCkge1xyXG4gICAgICAgICAgICB0aGlzLl9mb250V2VpZ2h0ID0gZm9udFdlaWdodDtcclxuICAgICAgICAgICAgdGhpcy5zdHlsZUlEKys7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgYW1vdW50IG9mIHNwYWNpbmcgYmV0d2VlbiBsZXR0ZXJzLCBkZWZhdWx0IGlzIDBcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIGdldCBsZXR0ZXJTcGFjaW5nKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9sZXR0ZXJTcGFjaW5nO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgc2V0IGxldHRlclNwYWNpbmcobGV0dGVyU3BhY2luZykge1xyXG4gICAgICAgIGlmICh0aGlzLl9sZXR0ZXJTcGFjaW5nICE9PSBsZXR0ZXJTcGFjaW5nKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2xldHRlclNwYWNpbmcgPSBsZXR0ZXJTcGFjaW5nO1xyXG4gICAgICAgICAgICB0aGlzLnN0eWxlSUQrKztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBsaW5lIGhlaWdodCwgYSBudW1iZXIgdGhhdCByZXByZXNlbnRzIHRoZSB2ZXJ0aWNhbCBzcGFjZSB0aGF0IGEgbGV0dGVyIHVzZXNcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIGdldCBsaW5lSGVpZ2h0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9saW5lSGVpZ2h0O1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgc2V0IGxpbmVIZWlnaHQobGluZUhlaWdodCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9saW5lSGVpZ2h0ICE9PSBsaW5lSGVpZ2h0KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2xpbmVIZWlnaHQgPSBsaW5lSGVpZ2h0O1xyXG4gICAgICAgICAgICB0aGlzLnN0eWxlSUQrKztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBzcGFjZSBiZXR3ZWVuIGxpbmVzXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICBnZXQgbGVhZGluZygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbGVhZGluZztcclxuICAgIH1cclxuICAgIDtcclxuICAgIHNldCBsZWFkaW5nKGxlYWRpbmcpIHtcclxuICAgICAgICBpZiAodGhpcy5fbGVhZGluZyAhPT0gbGVhZGluZykge1xyXG4gICAgICAgICAgICB0aGlzLl9sZWFkaW5nID0gbGVhZGluZztcclxuICAgICAgICAgICAgdGhpcy5zdHlsZUlEKys7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbGluZUpvaW4gcHJvcGVydHkgc2V0cyB0aGUgdHlwZSBvZiBjb3JuZXIgY3JlYXRlZCwgaXQgY2FuIHJlc29sdmUgc3Bpa2VkIHRleHQgaXNzdWVzLlxyXG4gICAgICogRGVmYXVsdCBpcyAnbWl0ZXInIChjcmVhdGVzIGEgc2hhcnAgY29ybmVyKS5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtzdHJpbmd9XHJcbiAgICAgKi9cclxuICAgIGdldCBsaW5lSm9pbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbGluZUpvaW47XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICBzZXQgbGluZUpvaW4obGluZUpvaW4pIHtcclxuICAgICAgICBpZiAodGhpcy5fbGluZUpvaW4gIT09IGxpbmVKb2luKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2xpbmVKb2luID0gbGluZUpvaW47XHJcbiAgICAgICAgICAgIHRoaXMuc3R5bGVJRCsrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIG1pdGVyIGxpbWl0IHRvIHVzZSB3aGVuIHVzaW5nIHRoZSAnbWl0ZXInIGxpbmVKb2luIG1vZGVcclxuICAgICAqIFRoaXMgY2FuIHJlZHVjZSBvciBpbmNyZWFzZSB0aGUgc3Bpa2luZXNzIG9mIHJlbmRlcmVkIHRleHQuXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICBnZXQgbWl0ZXJMaW1pdCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbWl0ZXJMaW1pdDtcclxuICAgIH1cclxuICAgIDtcclxuICAgIHNldCBtaXRlckxpbWl0KG1pdGVyTGltaXQpIHtcclxuICAgICAgICBpZiAodGhpcy5fbWl0ZXJMaW1pdCAhPT0gbWl0ZXJMaW1pdCkge1xyXG4gICAgICAgICAgICB0aGlzLl9taXRlckxpbWl0ID0gbWl0ZXJMaW1pdDtcclxuICAgICAgICAgICAgdGhpcy5zdHlsZUlEKys7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBPY2Nhc2lvbmFsbHkgc29tZSBmb250cyBhcmUgY3JvcHBlZC4gQWRkaW5nIHNvbWUgcGFkZGluZyB3aWxsIHByZXZlbnQgdGhpcyBmcm9tIGhhcHBlbmluZ1xyXG4gICAgICogYnkgYWRkaW5nIHBhZGRpbmcgdG8gYWxsIHNpZGVzIG9mIHRoZSB0ZXh0LlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgZ2V0IHBhZGRpbmcoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhZGRpbmc7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICBzZXQgcGFkZGluZyhwYWRkaW5nKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3BhZGRpbmcgIT09IHBhZGRpbmcpIHtcclxuICAgICAgICAgICAgdGhpcy5fcGFkZGluZyA9IHBhZGRpbmc7XHJcbiAgICAgICAgICAgIHRoaXMuc3R5bGVJRCsrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQSBjYW52YXMgZmlsbHN0eWxlIHRoYXQgd2lsbCBiZSB1c2VkIG9uIHRoZSB0ZXh0IHN0cm9rZVxyXG4gICAgICogZS5nICdibHVlJywgJyNGQ0ZGMDAnXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7c3RyaW5nfG51bWJlcn1cclxuICAgICAqL1xyXG4gICAgZ2V0IHN0cm9rZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fc3Ryb2tlO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgc2V0IHN0cm9rZShzdHJva2UpIHtcclxuICAgICAgICB2YXIgb3V0cHV0Q29sb3IgPSBDb2xvclNldHRpbmdzXzEuQ29sb3JTZXR0aW5ncy5nZXRDb2xvcihzdHJva2UpO1xyXG4gICAgICAgIGlmICh0aGlzLl9zdHJva2UgIT09IG91dHB1dENvbG9yKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0cm9rZSA9IG91dHB1dENvbG9yO1xyXG4gICAgICAgICAgICB0aGlzLnN0eWxlSUQrKztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIEEgbnVtYmVyIHRoYXQgcmVwcmVzZW50cyB0aGUgdGhpY2tuZXNzIG9mIHRoZSBzdHJva2UuXHJcbiAgICAgKiBEZWZhdWx0IGlzIDAgKG5vIHN0cm9rZSlcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIGdldCBzdHJva2VUaGlja25lc3MoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0cm9rZVRoaWNrbmVzcztcclxuICAgIH1cclxuICAgIDtcclxuICAgIHNldCBzdHJva2VUaGlja25lc3Moc3Ryb2tlVGhpY2tuZXNzKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3N0cm9rZVRoaWNrbmVzcyAhPT0gc3Ryb2tlVGhpY2tuZXNzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0cm9rZVRoaWNrbmVzcyA9IHN0cm9rZVRoaWNrbmVzcztcclxuICAgICAgICAgICAgdGhpcy5zdHlsZUlEKys7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgYmFzZWxpbmUgb2YgdGhlIHRleHQgdGhhdCBpcyByZW5kZXJlZC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtzdHJpbmd9XHJcbiAgICAgKi9cclxuICAgIGdldCB0ZXh0QmFzZWxpbmUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RleHRCYXNlbGluZTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIHNldCB0ZXh0QmFzZWxpbmUodGV4dEJhc2VsaW5lKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3RleHRCYXNlbGluZSAhPT0gdGV4dEJhc2VsaW5lKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3RleHRCYXNlbGluZSA9IHRleHRCYXNlbGluZTtcclxuICAgICAgICAgICAgdGhpcy5zdHlsZUlEKys7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUcmltIHRyYW5zcGFyZW50IGJvcmRlcnNcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICBnZXQgdHJpbSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fdHJpbTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIHNldCB0cmltKHRyaW0pIHtcclxuICAgICAgICBpZiAodGhpcy5fdHJpbSAhPT0gdHJpbSkge1xyXG4gICAgICAgICAgICB0aGlzLl90cmltID0gdHJpbTtcclxuICAgICAgICAgICAgdGhpcy5zdHlsZUlEKys7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBIb3cgbmV3bGluZXMgYW5kIHNwYWNlcyBzaG91bGQgYmUgaGFuZGxlZC5cclxuICAgICAqIERlZmF1bHQgaXMgJ3ByZScgKHByZXNlcnZlLCBwcmVzZXJ2ZSkuXHJcbiAgICAgKlxyXG4gICAgICogIHZhbHVlICAgfCBOZXcgbGluZXMgfCAgIFNwYWNlc1xyXG4gICAgICogIC0tLSAgICAgfCAtLS0gICAgICAgfCAgIC0tLVxyXG4gICAgICogJ25vcm1hbCcgfCBDb2xsYXBzZSAgfCAgIENvbGxhcHNlXHJcbiAgICAgKiAncHJlJyAgICB8IFByZXNlcnZlICB8ICAgUHJlc2VydmVcclxuICAgICAqICdwcmUtbGluZScgICB8IFByZXNlcnZlICB8ICAgQ29sbGFwc2VcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtzdHJpbmd9XHJcbiAgICAgKi9cclxuICAgIGdldCB3aGl0ZVNwYWNlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl93aGl0ZVNwYWNlO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgc2V0IHdoaXRlU3BhY2Uod2hpdGVTcGFjZSkge1xyXG4gICAgICAgIGlmICh0aGlzLl93aGl0ZVNwYWNlICE9PSB3aGl0ZVNwYWNlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3doaXRlU3BhY2UgPSB3aGl0ZVNwYWNlO1xyXG4gICAgICAgICAgICB0aGlzLnN0eWxlSUQrKztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIEluZGljYXRlcyBpZiB3b3JkIHdyYXAgc2hvdWxkIGJlIHVzZWRcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICBnZXQgd29yZFdyYXAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dvcmRXcmFwO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgc2V0IHdvcmRXcmFwKHdvcmRXcmFwKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3dvcmRXcmFwICE9PSB3b3JkV3JhcCkge1xyXG4gICAgICAgICAgICB0aGlzLl93b3JkV3JhcCA9IHdvcmRXcmFwO1xyXG4gICAgICAgICAgICB0aGlzLnN0eWxlSUQrKztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSB3aWR0aCBhdCB3aGljaCB0ZXh0IHdpbGwgd3JhcCwgaXQgbmVlZHMgd29yZFdyYXAgdG8gYmUgc2V0IHRvIHRydWVcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIGdldCB3b3JkV3JhcFdpZHRoKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl93b3JkV3JhcFdpZHRoO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgc2V0IHdvcmRXcmFwV2lkdGgod29yZFdyYXBXaWR0aCkge1xyXG4gICAgICAgIGlmICh0aGlzLl93b3JkV3JhcFdpZHRoICE9PSB3b3JkV3JhcFdpZHRoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3dvcmRXcmFwV2lkdGggPSB3b3JkV3JhcFdpZHRoO1xyXG4gICAgICAgICAgICB0aGlzLnN0eWxlSUQrKztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIEdlbmVyYXRlcyBhIGZvbnQgc3R5bGUgc3RyaW5nIHRvIHVzZSBmb3IgYFRleHRNZXRyaWNzLm1lYXN1cmVGb250KClgLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gRm9udCBzdHlsZSBzdHJpbmcsIGZvciBwYXNzaW5nIHRvIGBUZXh0TWV0cmljcy5tZWFzdXJlRm9udCgpYFxyXG4gICAgICovXHJcbiAgICB0b0ZvbnRTdHJpbmcoKSB7XHJcbiAgICAgICAgLy8gYnVpbGQgY2FudmFzIGFwaSBmb250IHNldHRpbmcgZnJvbSBpbmRpdmlkdWFsIGNvbXBvbmVudHMuIENvbnZlcnQgYSBudW1lcmljIHRoaXMuZm9udFNpemUgdG8gcHhcclxuICAgICAgICB2YXIgZm9udFNpemVTdHJpbmcgPSAodHlwZW9mIHRoaXMuZm9udFNpemUgPT09ICdudW1iZXInKSA/ICgodGhpcy5mb250U2l6ZSkgKyBcInB4XCIpIDogdGhpcy5mb250U2l6ZTtcclxuICAgICAgICAvLyBDbGVhbi11cCBmb250RmFtaWx5IHByb3BlcnR5IGJ5IHF1b3RpbmcgZWFjaCBmb250IG5hbWVcclxuICAgICAgICAvLyB0aGlzIHdpbGwgc3VwcG9ydCBmb250IG5hbWVzIHdpdGggc3BhY2VzXHJcbiAgICAgICAgdmFyIGZvbnRGYW1pbGllcyA9IHRoaXMuZm9udEZhbWlseTtcclxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodGhpcy5mb250RmFtaWx5KSkge1xyXG4gICAgICAgICAgICBmb250RmFtaWxpZXMgPSB0aGlzLmZvbnRGYW1pbHkuc3BsaXQoJywnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IGZvbnRGYW1pbGllcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgICAgICAvLyBUcmltIGFueSBleHRyYSB3aGl0ZS1zcGFjZVxyXG4gICAgICAgICAgICB2YXIgZm9udEZhbWlseSA9IGZvbnRGYW1pbGllc1tpXS50cmltKCk7XHJcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIGZvbnQgYWxyZWFkeSBjb250YWlucyBzdHJpbmdzXHJcbiAgICAgICAgICAgIGlmICghKC8oW1xcXCJcXCddKVteXFwnXFxcIl0rXFwxLykudGVzdChmb250RmFtaWx5KSkge1xyXG4gICAgICAgICAgICAgICAgZm9udEZhbWlseSA9IFwiXFxcIlwiICsgZm9udEZhbWlseSArIFwiXFxcIlwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvbnRGYW1pbGllc1tpXSA9IGZvbnRGYW1pbHk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAoKHRoaXMuZm9udFN0eWxlKSArIFwiIFwiICsgKHRoaXMuZm9udFZhcmlhbnQpICsgXCIgXCIgKyAodGhpcy5mb250V2VpZ2h0KSArIFwiIFwiICsgZm9udFNpemVTdHJpbmcgKyBcIiBcIiArIChmb250RmFtaWxpZXMuam9pbignLCcpKSk7XHJcbiAgICB9XHJcbiAgICA7XHJcbn1cclxuZXhwb3J0cy5UZXh0U3R5bGUgPSBUZXh0U3R5bGU7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IEV2ZW50RGlzcGF0Y2hlcl8xID0gcmVxdWlyZShcIi4vRXZlbnREaXNwYXRjaGVyXCIpO1xyXG5jb25zdCBSZWN0YW5nbGVfMSA9IHJlcXVpcmUoXCIuL1JlY3RhbmdsZVwiKTtcclxuY29uc3QgUG9pbnRfMSA9IHJlcXVpcmUoXCIuL1BvaW50XCIpO1xyXG5jb25zdCBFdmVudF8xID0gcmVxdWlyZShcIi4vRXZlbnRcIik7XHJcbmNvbnN0IFRleHR1cmVVdnNfMSA9IHJlcXVpcmUoXCIuL1RleHR1cmVVdnNcIik7XHJcbmNvbnN0IEJhc2VUZXh0dXJlXzEgPSByZXF1aXJlKFwiLi9CYXNlVGV4dHVyZVwiKTtcclxuY29uc3QgSW1hZ2VSZXNvdXJjZV8xID0gcmVxdWlyZShcIi4vSW1hZ2VSZXNvdXJjZVwiKTtcclxuY29uc3QgQ2FudmFzUmVzb3VyY2VfMSA9IHJlcXVpcmUoXCIuL0NhbnZhc1Jlc291cmNlXCIpO1xyXG5jb25zdCBNYXRoU2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL01hdGhTZXR0aW5nc1wiKTtcclxuY29uc3QgQ2FjaGVTZXR0aW5nc18xID0gcmVxdWlyZShcIi4vQ2FjaGVTZXR0aW5nc1wiKTtcclxuY29uc3QgRGlzcGxheVNldHRpbmdzXzEgPSByZXF1aXJlKFwiLi9EaXNwbGF5U2V0dGluZ3NcIik7XHJcbmNvbnN0IE5ldHdvcmtTZXR0aW5nc18xID0gcmVxdWlyZShcIi4vTmV0d29ya1NldHRpbmdzXCIpO1xyXG5jb25zdCBMb2dnZXJfMSA9IHJlcXVpcmUoXCIuL0xvZ2dlclwiKTtcclxuY2xhc3MgVGV4dHVyZSBleHRlbmRzIEV2ZW50RGlzcGF0Y2hlcl8xLkV2ZW50RGlzcGF0Y2hlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihiYXNlVGV4dHVyZSwgZnJhbWUgPSBudWxsLCBvcmlnID0gbnVsbCwgdHJpbSA9IG51bGwsIHJvdGF0ZSA9IG51bGwsIGFuY2hvciA9IG51bGwpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENhbGxlZCB3aGVuIHRoZSBiYXNlIHRleHR1cmUgaXMgdXBkYXRlZFxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHByb3RlY3RlZFxyXG4gICAgICAgICAqIEBwYXJhbSB7UElYSS5CYXNlVGV4dHVyZX0gYmFzZVRleHR1cmUgLSBUaGUgYmFzZSB0ZXh0dXJlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMub25CYXNlVGV4dHVyZVVwZGF0ZWQgPSAoYmFzZVRleHR1cmUpID0+IHtcclxuICAgICAgICAgICAgTG9nZ2VyXzEudHJhY2UoXCJvbkJhc2VUZXh0dXJlVXBkYXRlZFwiKTtcclxuICAgICAgICAgICAgdGhpcy5fdXBkYXRlSUQrKztcclxuICAgICAgICAgICAgLy8gVE9ETyB0aGlzIGNvZGUgbG9va3MgY29uZnVzaW5nLi4gYm9vIHRvIGFidXNpbmcgZ2V0dGVycyBhbmQgc2V0dGVycyFcclxuICAgICAgICAgICAgaWYgKHRoaXMubm9GcmFtZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5mcmFtZSA9IG5ldyBSZWN0YW5nbGVfMS5SZWN0YW5nbGUoMCwgMCwgYmFzZVRleHR1cmUud2lkdGgsIGJhc2VUZXh0dXJlLmhlaWdodCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmZyYW1lID0gdGhpcy5fZnJhbWU7XHJcbiAgICAgICAgICAgICAgICAvLyBUT0RPIG1heWJlIHdhdGNoIG91dCBmb3IgdGhlIG5vIGZyYW1lIG9wdGlvblxyXG4gICAgICAgICAgICAgICAgLy8gdXBkYXRpbmcgdGhlIHRleHR1cmUgd2lsbCBzaG91bGQgdXBkYXRlIHRoZSBmcmFtZSBpZiBpdCB3YXMgc2V0IHRvIG5vIGZyYW1lLi5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnZhbGlkID0gdGhpcy5iYXNlVGV4dHVyZS52YWxpZDtcclxuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KEV2ZW50XzEuRXZlbnQuZ2V0RXZlbnQoXCJ1cGRhdGVcIikpO1xyXG4gICAgICAgICAgICAvLyB0aGlzLmVtaXQoJ3VwZGF0ZScsIHRoaXMpO1xyXG4gICAgICAgICAgICAvLyB0aGlzLmJhc2VUZXh0dXJlLmFkZEV2ZW50TGlzdGVuZXIoXCJ1cGRhdGVcIiwgdGhpcy5vbkJhc2VUZXh0dXJlVXBkYXRlZClcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMubm9GcmFtZSA9IGZhbHNlO1xyXG4gICAgICAgIGlmICghZnJhbWUpIHtcclxuICAgICAgICAgICAgdGhpcy5ub0ZyYW1lID0gdHJ1ZTtcclxuICAgICAgICAgICAgZnJhbWUgPSBuZXcgUmVjdGFuZ2xlXzEuUmVjdGFuZ2xlKDAsIDAsIDEsIDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYmFzZVRleHR1cmUgaW5zdGFuY2VvZiBUZXh0dXJlKSB7XHJcbiAgICAgICAgICAgIGJhc2VUZXh0dXJlID0gYmFzZVRleHR1cmUuYmFzZVRleHR1cmU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBiYXNlIHRleHR1cmUgdGhhdCB0aGlzIHRleHR1cmUgdXNlcy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuQmFzZVRleHR1cmV9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5iYXNlVGV4dHVyZSA9IGJhc2VUZXh0dXJlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoaXMgaXMgdGhlIGFyZWEgb2YgdGhlIEJhc2VUZXh0dXJlIGltYWdlIHRvIGFjdHVhbGx5IGNvcHkgdG8gdGhlIENhbnZhcyAvIFdlYkdMIHdoZW4gcmVuZGVyaW5nLFxyXG4gICAgICAgICAqIGlycmVzcGVjdGl2ZSBvZiB0aGUgYWN0dWFsIGZyYW1lIHNpemUgb3IgcGxhY2VtZW50ICh3aGljaCBjYW4gYmUgaW5mbHVlbmNlZCBieSB0cmltbWVkIHRleHR1cmUgYXRsYXNlcylcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuUmVjdGFuZ2xlfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuX2ZyYW1lID0gZnJhbWU7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhpcyBpcyB0aGUgdHJpbW1lZCBhcmVhIG9mIG9yaWdpbmFsIHRleHR1cmUsIGJlZm9yZSBpdCB3YXMgcHV0IGluIGF0bGFzXHJcbiAgICAgICAgICogUGxlYXNlIGNhbGwgYHVwZGF0ZVV2cygpYCBhZnRlciB5b3UgY2hhbmdlIGNvb3JkaW5hdGVzIG9mIGB0cmltYCBtYW51YWxseS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuUmVjdGFuZ2xlfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMudHJpbSA9IHRyaW07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhpcyB3aWxsIGxldCB0aGUgcmVuZGVyZXIga25vdyBpZiB0aGUgdGV4dHVyZSBpcyB2YWxpZC4gSWYgaXQncyBub3QgdGhlbiBpdCBjYW5ub3QgYmUgcmVuZGVyZWQuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAbWVtYmVyIHtib29sZWFufVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMudmFsaWQgPSBmYWxzZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGlzIHdpbGwgbGV0IGEgcmVuZGVyZXIga25vdyB0aGF0IGEgdGV4dHVyZSBoYXMgYmVlbiB1cGRhdGVkICh1c2VkIG1haW5seSBmb3IgV2ViR0wgdXYgdXBkYXRlcylcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5yZXF1aXJlc1VwZGF0ZSA9IGZhbHNlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBXZWJHTCBVViBkYXRhIGNhY2hlLiBDYW4gYmUgdXNlZCBhcyBxdWFkIFVWXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLlRleHR1cmVVdnN9XHJcbiAgICAgICAgICogQHByb3RlY3RlZFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuX3V2cyA9IFRleHR1cmUuREVGQVVMVF9VVlM7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRGVmYXVsdCBUZXh0dXJlTWF0cml4IGluc3RhbmNlIGZvciB0aGlzIHRleHR1cmVcclxuICAgICAgICAgKiBCeSBkZWZhdWx0IHRoYXQgb2JqZWN0IGlzIG5vdCBjcmVhdGVkIGJlY2F1c2UgaXRzIGhlYXZ5XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLlRleHR1cmVNYXRyaXh9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy51dk1hdHJpeCA9IG51bGw7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhpcyBpcyB0aGUgYXJlYSBvZiBvcmlnaW5hbCB0ZXh0dXJlLCBiZWZvcmUgaXQgd2FzIHB1dCBpbiBhdGxhc1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQG1lbWJlciB7UElYSS5SZWN0YW5nbGV9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5vcmlnID0gb3JpZyB8fCBmcmFtZTsgLy8gbmV3IFJlY3RhbmdsZSgwLCAwLCAxLCAxKTtcclxuICAgICAgICB0aGlzLl9yb3RhdGUgPSBOdW1iZXIocm90YXRlIHx8IDApO1xyXG4gICAgICAgIGlmIChyb3RhdGUgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgLy8gdGhpcyBpcyBvbGQgdGV4dHVyZXBhY2tlciBsZWdhY3ksIHNvbWUgZ2FtZXMvbGlicmFyaWVzIGFyZSBwYXNzaW5nIFwidHJ1ZVwiIGZvciByb3RhdGVkIHRleHR1cmVzXHJcbiAgICAgICAgICAgIHRoaXMuX3JvdGF0ZSA9IDI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX3JvdGF0ZSAlIDIgIT09IDApIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhdHRlbXB0IHRvIHVzZSBkaWFtb25kLXNoYXBlZCBVVnMuIElmIHlvdSBhcmUgc3VyZSwgc2V0IHJvdGF0aW9uIG1hbnVhbGx5Jyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChiYXNlVGV4dHVyZS52YWxpZCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5ub0ZyYW1lKSB7XHJcbiAgICAgICAgICAgICAgICBmcmFtZSA9IG5ldyBSZWN0YW5nbGVfMS5SZWN0YW5nbGUoMCwgMCwgYmFzZVRleHR1cmUud2lkdGgsIGJhc2VUZXh0dXJlLmhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGVyZSBpcyBubyBmcmFtZSB3ZSBzaG91bGQgbW9uaXRvciBmb3IgYW55IGJhc2UgdGV4dHVyZSBjaGFuZ2VzLi5cclxuICAgICAgICAgICAgICAgIGJhc2VUZXh0dXJlLmFkZEV2ZW50TGlzdGVuZXIoXCJ1cGRhdGVcIiwgdGhpcy5vbkJhc2VUZXh0dXJlVXBkYXRlZCk7XHJcbiAgICAgICAgICAgICAgICAvLyBiYXNlVGV4dHVyZS5vbigndXBkYXRlJywgdGhpcy5vbkJhc2VUZXh0dXJlVXBkYXRlZCwgdGhpcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5mcmFtZSA9IGZyYW1lO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgYmFzZVRleHR1cmUuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRlZFwiLCB0aGlzLm9uQmFzZVRleHR1cmVVcGRhdGVkKTtcclxuICAgICAgICAgICAgLy8gYmFzZVRleHR1cmUub25jZSgnbG9hZGVkJywgdGhpcy5vbkJhc2VUZXh0dXJlVXBkYXRlZCwgdGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFuY2hvciBwb2ludCB0aGF0IGlzIHVzZWQgYXMgZGVmYXVsdCBpZiBzcHJpdGUgaXMgY3JlYXRlZCB3aXRoIHRoaXMgdGV4dHVyZS5cclxuICAgICAgICAgKiBDaGFuZ2luZyB0aGUgYGRlZmF1bHRBbmNob3JgIGF0IGEgbGF0ZXIgcG9pbnQgb2YgdGltZSB3aWxsIG5vdCB1cGRhdGUgU3ByaXRlJ3MgYW5jaG9yIHBvaW50LlxyXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuUG9pbnR9XHJcbiAgICAgICAgICogQGRlZmF1bHQgezAsMH1cclxuICAgICAgICAgKi9cclxuICAgICAgICBpZiAoYW5jaG9yKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGVmYXVsdEFuY2hvciA9IG5ldyBQb2ludF8xLlBvaW50KGFuY2hvci54LCBhbmNob3IueSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmRlZmF1bHRBbmNob3IgPSBuZXcgUG9pbnRfMS5Qb2ludCgwLCAwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVXBkYXRlIElEIGlzIG9ic2VydmVkIGJ5IHNwcml0ZXMgYW5kIFRleHR1cmVNYXRyaXggaW5zdGFuY2VzLlxyXG4gICAgICAgICAqIENhbGwgdXBkYXRlVXZzKCkgdG8gaW5jcmVtZW50IGl0LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLl91cGRhdGVJRCA9IDA7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGlkcyB1bmRlciB3aGljaCB0aGlzIFRleHR1cmUgaGFzIGJlZW4gYWRkZWQgdG8gdGhlIHRleHR1cmUgY2FjaGUuIFRoaXMgaXNcclxuICAgICAgICAgKiBhdXRvbWF0aWNhbGx5IHNldCBhcyBsb25nIGFzIFRleHR1cmUuYWRkVG9DYWNoZSBpcyB1c2VkLCBidXQgbWF5IG5vdCBiZSBzZXQgaWYgYVxyXG4gICAgICAgICAqIFRleHR1cmUgaXMgYWRkZWQgZGlyZWN0bHkgdG8gdGhlIFRleHR1cmVDYWNoZSBhcnJheS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBtZW1iZXIge3N0cmluZ1tdfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMudGV4dHVyZUNhY2hlSWRzID0gW107XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgdGhpcyB0ZXh0dXJlIG9uIHRoZSBncHUuXHJcbiAgICAgKlxyXG4gICAgICovXHJcbiAgICB1cGRhdGUoKSB7XHJcbiAgICAgICAgdGhpcy5iYXNlVGV4dHVyZS51cGRhdGUoKTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogRGVzdHJveXMgdGhpcyB0ZXh0dXJlXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZGVzdHJveUJhc2U9ZmFsc2VdIFdoZXRoZXIgdG8gZGVzdHJveSB0aGUgYmFzZSB0ZXh0dXJlIGFzIHdlbGxcclxuICAgICAqL1xyXG4gICAgZGVzdHJveShkZXN0cm95QmFzZSkge1xyXG4gICAgICAgIGlmICh0aGlzLmJhc2VUZXh0dXJlKSB7XHJcbiAgICAgICAgICAgIGlmIChkZXN0cm95QmFzZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gZGVsZXRlIHRoZSB0ZXh0dXJlIGlmIGl0IGV4aXN0cyBpbiB0aGUgdGV4dHVyZSBjYWNoZS4uXHJcbiAgICAgICAgICAgICAgICAvLyB0aGlzIG9ubHkgbmVlZHMgdG8gYmUgcmVtb3ZlZCBpZiB0aGUgYmFzZSB0ZXh0dXJlIGlzIGFjdHVhbGx5IGRlc3Ryb3llZCB0b28uLlxyXG4gICAgICAgICAgICAgICAgaWYgKENhY2hlU2V0dGluZ3NfMS5DYWNoZVNldHRpbmdzLlRleHR1cmVDYWNoZVt0aGlzLmJhc2VUZXh0dXJlLmltYWdlVXJsXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIFRleHR1cmUucmVtb3ZlRnJvbUNhY2hlKHRoaXMuYmFzZVRleHR1cmUuaW1hZ2VVcmwpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5iYXNlVGV4dHVyZS5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gdGhpcy5iYXNlVGV4dHVyZS5yZW1vKCd1cGRhdGUnLCB0aGlzLm9uQmFzZVRleHR1cmVVcGRhdGVkLCB0aGlzKTtcclxuICAgICAgICAgICAgdGhpcy5iYXNlVGV4dHVyZSA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2ZyYW1lID0gbnVsbDtcclxuICAgICAgICB0aGlzLl91dnMgPSBudWxsO1xyXG4gICAgICAgIHRoaXMudHJpbSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5vcmlnID0gbnVsbDtcclxuICAgICAgICB0aGlzLnZhbGlkID0gZmFsc2U7XHJcbiAgICAgICAgVGV4dHVyZS5yZW1vdmVGcm9tQ2FjaGUodGhpcyk7XHJcbiAgICAgICAgdGhpcy50ZXh0dXJlQ2FjaGVJZHMgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IHRleHR1cmUgb2JqZWN0IHRoYXQgYWN0cyB0aGUgc2FtZSBhcyB0aGlzIG9uZS5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJuIHtQSVhJLlRleHR1cmV9IFRoZSBuZXcgdGV4dHVyZVxyXG4gICAgICovXHJcbiAgICBjbG9uZSgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFRleHR1cmUodGhpcy5iYXNlVGV4dHVyZSwgdGhpcy5mcmFtZSwgdGhpcy5vcmlnLCB0aGlzLnRyaW0sIHRoaXMucm90YXRlLCB0aGlzLmRlZmF1bHRBbmNob3IpO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGVzIHRoZSBpbnRlcm5hbCBXZWJHTCBVViBjYWNoZS4gVXNlIGl0IGFmdGVyIHlvdSBjaGFuZ2UgYGZyYW1lYCBvciBgdHJpbWAgb2YgdGhlIHRleHR1cmUuXHJcbiAgICAgKiBDYWxsIGl0IGFmdGVyIGNoYW5naW5nIHRoZSBmcmFtZVxyXG4gICAgICovXHJcbiAgICB1cGRhdGVVdnMoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3V2cyA9PT0gVGV4dHVyZS5ERUZBVUxUX1VWUykge1xyXG4gICAgICAgICAgICB0aGlzLl91dnMgPSBuZXcgVGV4dHVyZVV2c18xLlRleHR1cmVVdnMoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fdXZzLnNldCh0aGlzLl9mcmFtZSwgdGhpcy5iYXNlVGV4dHVyZSwgdGhpcy5yb3RhdGUpO1xyXG4gICAgICAgIHRoaXMuX3VwZGF0ZUlEKys7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIEhlbHBlciBmdW5jdGlvbiB0aGF0IGNyZWF0ZXMgYSBuZXcgVGV4dHVyZSBiYXNlZCBvbiB0aGUgc291cmNlIHlvdSBwcm92aWRlLlxyXG4gICAgICogVGhlIHNvdXJjZSBjYW4gYmUgLSBmcmFtZSBpZCwgaW1hZ2UgdXJsLCB2aWRlbyB1cmwsIGNhbnZhcyBlbGVtZW50LCB2aWRlbyBlbGVtZW50LCBiYXNlIHRleHR1cmVcclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcnxzdHJpbmd8SFRNTEltYWdlRWxlbWVudHxIVE1MQ2FudmFzRWxlbWVudHxIVE1MVmlkZW9FbGVtZW50fFBJWEkuQmFzZVRleHR1cmV9IHNvdXJjZVxyXG4gICAgICogICAgICAgIFNvdXJjZSB0byBjcmVhdGUgdGV4dHVyZSBmcm9tXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIFNlZSB7QGxpbmsgUElYSS5CYXNlVGV4dHVyZX0ncyBjb25zdHJ1Y3RvciBmb3Igb3B0aW9ucy5cclxuICAgICAqIEByZXR1cm4ge1BJWEkuVGV4dHVyZX0gVGhlIG5ld2x5IGNyZWF0ZWQgdGV4dHVyZVxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZnJvbShzb3VyY2UsIG9wdGlvbnMgPSB7fSkge1xyXG4gICAgICAgIHZhciBjYWNoZUlkID0gbnVsbDtcclxuICAgICAgICBpZiAodHlwZW9mIHNvdXJjZSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgY2FjaGVJZCA9IHNvdXJjZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmICghc291cmNlLl9waXhpSWQpIHtcclxuICAgICAgICAgICAgICAgIHNvdXJjZS5fcGl4aUlkID0gXCJwaXhpaWRfXCIgKyAoTWF0aFNldHRpbmdzXzEuTWF0aFNldHRpbmdzLnVpZCgpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYWNoZUlkID0gc291cmNlLl9waXhpSWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciB0ZXh0dXJlID0gQ2FjaGVTZXR0aW5nc18xLkNhY2hlU2V0dGluZ3MuVGV4dHVyZUNhY2hlW2NhY2hlSWRdO1xyXG4gICAgICAgIGlmICghdGV4dHVyZSkge1xyXG4gICAgICAgICAgICBpZiAob3B0aW9uc1sncmVzb2x1dGlvbiddID09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5yZXNvbHV0aW9uID0gTmV0d29ya1NldHRpbmdzXzEuTmV0d29ya1NldHRpbmdzLmdldFJlc29sdXRpb25PZlVybChzb3VyY2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRleHR1cmUgPSBuZXcgVGV4dHVyZShuZXcgQmFzZVRleHR1cmVfMS5CYXNlVGV4dHVyZShzb3VyY2UsIG9wdGlvbnMpKTtcclxuICAgICAgICAgICAgdGV4dHVyZS5iYXNlVGV4dHVyZS5jYWNoZUlkID0gY2FjaGVJZDtcclxuICAgICAgICAgICAgQmFzZVRleHR1cmVfMS5CYXNlVGV4dHVyZS5hZGRUb0NhY2hlKHRleHR1cmUuYmFzZVRleHR1cmUsIGNhY2hlSWQpO1xyXG4gICAgICAgICAgICBUZXh0dXJlLmFkZFRvQ2FjaGUodGV4dHVyZSwgY2FjaGVJZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGxldHMgYXNzdW1lIGl0cyBhIGJhc2UgdGV4dHVyZSFcclxuICAgICAgICByZXR1cm4gdGV4dHVyZTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhIFRleHR1cmUgdG8gdGhlIGdsb2JhbCBUZXh0dXJlQ2FjaGUuIFRoaXMgY2FjaGUgaXMgc2hhcmVkIGFjcm9zcyB0aGUgd2hvbGUgUElYSSBvYmplY3QuXHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQHBhcmFtIHtQSVhJLlRleHR1cmV9IHRleHR1cmUgLSBUaGUgVGV4dHVyZSB0byBhZGQgdG8gdGhlIGNhY2hlLlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlkIC0gVGhlIGlkIHRoYXQgdGhlIFRleHR1cmUgd2lsbCBiZSBzdG9yZWQgYWdhaW5zdC5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGFkZFRvQ2FjaGUodGV4dHVyZSwgaWQpIHtcclxuICAgICAgICBpZiAoaWQpIHtcclxuICAgICAgICAgICAgaWYgKHRleHR1cmUudGV4dHVyZUNhY2hlSWRzLmluZGV4T2YoaWQpID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgdGV4dHVyZS50ZXh0dXJlQ2FjaGVJZHMucHVzaChpZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKENhY2hlU2V0dGluZ3NfMS5DYWNoZVNldHRpbmdzLlRleHR1cmVDYWNoZVtpZF0pIHtcclxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oKFwiVGV4dHVyZSBhZGRlZCB0byB0aGUgY2FjaGUgd2l0aCBhbiBpZCBbXCIgKyBpZCArIFwiXSB0aGF0IGFscmVhZHkgaGFkIGFuIGVudHJ5XCIpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBDYWNoZVNldHRpbmdzXzEuQ2FjaGVTZXR0aW5ncy5UZXh0dXJlQ2FjaGVbaWRdID0gdGV4dHVyZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZSBhIFRleHR1cmUgZnJvbSB0aGUgZ2xvYmFsIFRleHR1cmVDYWNoZS5cclxuICAgICAqXHJcbiAgICAgKiBAc3RhdGljXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xQSVhJLlRleHR1cmV9IHRleHR1cmUgLSBpZCBvZiBhIFRleHR1cmUgdG8gYmUgcmVtb3ZlZCwgb3IgYSBUZXh0dXJlIGluc3RhbmNlIGl0c2VsZlxyXG4gICAgICogQHJldHVybiB7UElYSS5UZXh0dXJlfG51bGx9IFRoZSBUZXh0dXJlIHRoYXQgd2FzIHJlbW92ZWRcclxuICAgICAqL1xyXG4gICAgc3RhdGljIHJlbW92ZUZyb21DYWNoZSh0ZXh0dXJlKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiB0ZXh0dXJlID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICB2YXIgdGV4dHVyZUZyb21DYWNoZSA9IENhY2hlU2V0dGluZ3NfMS5DYWNoZVNldHRpbmdzLlRleHR1cmVDYWNoZVt0ZXh0dXJlXTtcclxuICAgICAgICAgICAgaWYgKHRleHR1cmVGcm9tQ2FjaGUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IHRleHR1cmVGcm9tQ2FjaGUudGV4dHVyZUNhY2hlSWRzLmluZGV4T2YodGV4dHVyZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRleHR1cmVGcm9tQ2FjaGUudGV4dHVyZUNhY2hlSWRzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBkZWxldGUgQ2FjaGVTZXR0aW5nc18xLkNhY2hlU2V0dGluZ3MuVGV4dHVyZUNhY2hlW3RleHR1cmVdO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRleHR1cmVGcm9tQ2FjaGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGV4dHVyZSAmJiB0ZXh0dXJlLnRleHR1cmVDYWNoZUlkcykge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRleHR1cmUudGV4dHVyZUNhY2hlSWRzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBDaGVjayB0aGF0IHRleHR1cmUgbWF0Y2hlcyB0aGUgb25lIGJlaW5nIHBhc3NlZCBpbiBiZWZvcmUgZGVsZXRpbmcgaXQgZnJvbSB0aGUgY2FjaGUuXHJcbiAgICAgICAgICAgICAgICBpZiAoQ2FjaGVTZXR0aW5nc18xLkNhY2hlU2V0dGluZ3MuVGV4dHVyZUNhY2hlW3RleHR1cmUudGV4dHVyZUNhY2hlSWRzW2ldXSA9PT0gdGV4dHVyZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBDYWNoZVNldHRpbmdzXzEuQ2FjaGVTZXR0aW5ncy5UZXh0dXJlQ2FjaGVbdGV4dHVyZS50ZXh0dXJlQ2FjaGVJZHNbaV1dO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRleHR1cmUudGV4dHVyZUNhY2hlSWRzLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgIHJldHVybiB0ZXh0dXJlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGZyYW1lIHNwZWNpZmllcyB0aGUgcmVnaW9uIG9mIHRoZSBiYXNlIHRleHR1cmUgdGhhdCB0aGlzIHRleHR1cmUgdXNlcy5cclxuICAgICAqIFBsZWFzZSBjYWxsIGB1cGRhdGVVdnMoKWAgYWZ0ZXIgeW91IGNoYW5nZSBjb29yZGluYXRlcyBvZiBgZnJhbWVgIG1hbnVhbGx5LlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge1BJWEkuUmVjdGFuZ2xlfVxyXG4gICAgICovXHJcbiAgICBnZXQgZnJhbWUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZyYW1lO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgc2V0IGZyYW1lKGZyYW1lKSB7XHJcbiAgICAgICAgdGhpcy5fZnJhbWUgPSBmcmFtZTtcclxuICAgICAgICB0aGlzLm5vRnJhbWUgPSBmYWxzZTtcclxuICAgICAgICB2YXIgeCA9IGZyYW1lLng7XHJcbiAgICAgICAgdmFyIHkgPSBmcmFtZS55O1xyXG4gICAgICAgIHZhciB3aWR0aCA9IGZyYW1lLndpZHRoO1xyXG4gICAgICAgIHZhciBoZWlnaHQgPSBmcmFtZS5oZWlnaHQ7XHJcbiAgICAgICAgdmFyIHhOb3RGaXQgPSB4ICsgd2lkdGggPiB0aGlzLmJhc2VUZXh0dXJlLndpZHRoO1xyXG4gICAgICAgIHZhciB5Tm90Rml0ID0geSArIGhlaWdodCA+IHRoaXMuYmFzZVRleHR1cmUuaGVpZ2h0O1xyXG4gICAgICAgIGlmICh4Tm90Rml0IHx8IHlOb3RGaXQpIHtcclxuICAgICAgICAgICAgdmFyIHJlbGF0aW9uc2hpcCA9IHhOb3RGaXQgJiYgeU5vdEZpdCA/ICdhbmQnIDogJ29yJztcclxuICAgICAgICAgICAgdmFyIGVycm9yWCA9IFwiWDogXCIgKyB4ICsgXCIgKyBcIiArIHdpZHRoICsgXCIgPSBcIiArICh4ICsgd2lkdGgpICsgXCIgPiBcIiArICh0aGlzLmJhc2VUZXh0dXJlLndpZHRoKTtcclxuICAgICAgICAgICAgdmFyIGVycm9yWSA9IFwiWTogXCIgKyB5ICsgXCIgKyBcIiArIGhlaWdodCArIFwiID0gXCIgKyAoeSArIGhlaWdodCkgKyBcIiA+IFwiICsgKHRoaXMuYmFzZVRleHR1cmUuaGVpZ2h0KTtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUZXh0dXJlIEVycm9yOiBmcmFtZSBkb2VzIG5vdCBmaXQgaW5zaWRlIHRoZSBiYXNlIFRleHR1cmUgZGltZW5zaW9uczogJ1xyXG4gICAgICAgICAgICAgICAgKyBlcnJvclggKyBcIiBcIiArIHJlbGF0aW9uc2hpcCArIFwiIFwiICsgZXJyb3JZKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy52YWxpZCA9IHdpZHRoICYmIGhlaWdodCAmJiB0aGlzLmJhc2VUZXh0dXJlLnZhbGlkO1xyXG4gICAgICAgIGlmICghdGhpcy50cmltICYmICF0aGlzLnJvdGF0ZSkge1xyXG4gICAgICAgICAgICB0aGlzLm9yaWcgPSBmcmFtZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMudmFsaWQpIHtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVVdnMoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSB0ZXh0dXJlIGlzIHJvdGF0ZWQgaW5zaWRlIHRoZSBhdGxhc1xyXG4gICAgICogc2V0IHRvIDIgdG8gY29tcGVuc2F0ZSBmb3IgdGV4dHVyZSBwYWNrZXIgcm90YXRpb25cclxuICAgICAqIHNldCB0byA2IHRvIGNvbXBlbnNhdGUgZm9yIHNwaW5lIHBhY2tlciByb3RhdGlvblxyXG4gICAgICogY2FuIGJlIHVzZWQgdG8gcm90YXRlIG9yIG1pcnJvciBzcHJpdGVzXHJcbiAgICAgKiBTZWUge0BsaW5rIFBJWEkuR3JvdXBEOH0gZm9yIGV4cGxhbmF0aW9uXHJcbiAgICAgKlxyXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICBnZXQgcm90YXRlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9yb3RhdGU7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICBzZXQgcm90YXRlKHJvdGF0ZSkge1xyXG4gICAgICAgIHRoaXMuX3JvdGF0ZSA9IHJvdGF0ZTtcclxuICAgICAgICBpZiAodGhpcy52YWxpZCkge1xyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVV2cygpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIHdpZHRoIG9mIHRoZSBUZXh0dXJlIGluIHBpeGVscy5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIGdldCB3aWR0aCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5vcmlnLndpZHRoO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgaGVpZ2h0IG9mIHRoZSBUZXh0dXJlIGluIHBpeGVscy5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIGdldCBoZWlnaHQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMub3JpZy5oZWlnaHQ7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIEFuIGVtcHR5IHRleHR1cmUsIHVzZWQgb2Z0ZW4gdG8gbm90IGhhdmUgdG8gY3JlYXRlIG11bHRpcGxlIGVtcHR5IHRleHR1cmVzLlxyXG4gICAgICogQ2FuIG5vdCBiZSBkZXN0cm95ZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQGNvbnN0YW50XHJcbiAgICAgKiBAbWVtYmVyIHtQSVhJLlRleHR1cmV9XHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBnZXQgRU1QVFkoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBUZXh0dXJlKG5ldyBCYXNlVGV4dHVyZV8xLkJhc2VUZXh0dXJlKCkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAqIEEgd2hpdGUgdGV4dHVyZSBvZiAxMHgxMCBzaXplLCB1c2VkIGZvciBncmFwaGljcyBhbmQgb3RoZXIgdGhpbmdzXHJcbiAqIENhbiBub3QgYmUgZGVzdHJveWVkLlxyXG4gKlxyXG4gKiBAc3RhdGljXHJcbiAqIEBjb25zdGFudFxyXG4gKiBAbWVtYmVyIHtQSVhJLlRleHR1cmV9XHJcbiAqL1xyXG4gICAgc3RhdGljIGdldCBXSElURSgpIHtcclxuICAgICAgICByZXR1cm4gVGV4dHVyZS5jcmVhdGVXaGl0ZVRleHR1cmUoKTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBjcmVhdGVXaGl0ZVRleHR1cmUoKSB7XHJcbiAgICAgICAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xyXG4gICAgICAgIGNhbnZhcy53aWR0aCA9IDE2O1xyXG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSAxNjtcclxuICAgICAgICB2YXIgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xyXG4gICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gJ3doaXRlJztcclxuICAgICAgICBjb250ZXh0LmZpbGxSZWN0KDAsIDAsIDE2LCAxNik7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBUZXh0dXJlKG5ldyBCYXNlVGV4dHVyZV8xLkJhc2VUZXh0dXJlKG5ldyBDYW52YXNSZXNvdXJjZV8xLkNhbnZhc1Jlc291cmNlKGNhbnZhcykpKTtcclxuICAgIH1cclxufVxyXG5UZXh0dXJlLkRFRkFVTFRfVVZTID0gbmV3IFRleHR1cmVVdnNfMS5UZXh0dXJlVXZzKCk7XHJcbi8qKlxyXG4gKiBDcmVhdGUgYSBuZXcgVGV4dHVyZSB3aXRoIGEgQnVmZmVyUmVzb3VyY2UgZnJvbSBhIEZsb2F0MzJBcnJheS5cclxuICogUkdCQSB2YWx1ZXMgYXJlIGZsb2F0cyBmcm9tIDAgdG8gMS5cclxuICogQHN0YXRpY1xyXG4gKiBAcGFyYW0ge0Zsb2F0MzJBcnJheXxVaW50OEFycmF5fSBidWZmZXIgVGhlIG9wdGlvbmFsIGFycmF5IHRvIHVzZSwgaWYgbm8gZGF0YVxyXG4gKiAgICAgICAgaXMgcHJvdmlkZWQsIGEgbmV3IEZsb2F0MzJBcnJheSBpcyBjcmVhdGVkLlxyXG4gKiBAcGFyYW0ge251bWJlcn0gd2lkdGggLSBXaWR0aCBvZiB0aGUgcmVzb3VyY2VcclxuICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCAtIEhlaWdodCBvZiB0aGUgcmVzb3VyY2VcclxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSBTZWUge0BsaW5rIFBJWEkuQmFzZVRleHR1cmV9J3MgY29uc3RydWN0b3IgZm9yIG9wdGlvbnMuXHJcbiAqIEByZXR1cm4ge1BJWEkuVGV4dHVyZX0gVGhlIHJlc3VsdGluZyBuZXcgQmFzZVRleHR1cmVcclxuICovXHJcblRleHR1cmUuZnJvbUJ1ZmZlciA9IGZ1bmN0aW9uIGZyb21CdWZmZXIoYnVmZmVyLCB3aWR0aCwgaGVpZ2h0LCBvcHRpb25zKSB7XHJcbiAgICByZXR1cm4gbmV3IFRleHR1cmUoQmFzZVRleHR1cmVfMS5CYXNlVGV4dHVyZS5mcm9tQnVmZmVyKGJ1ZmZlciwgd2lkdGgsIGhlaWdodCwgb3B0aW9ucykpO1xyXG59O1xyXG4vKipcclxuICogQ3JlYXRlIGEgdGV4dHVyZSBmcm9tIGEgc291cmNlIGFuZCBhZGQgdG8gdGhlIGNhY2hlLlxyXG4gKlxyXG4gKiBAc3RhdGljXHJcbiAqIEBwYXJhbSB7SFRNTEltYWdlRWxlbWVudHxIVE1MQ2FudmFzRWxlbWVudH0gc291cmNlIC0gVGhlIGlucHV0IHNvdXJjZS5cclxuICogQHBhcmFtIHtTdHJpbmd9IGltYWdlVXJsIC0gRmlsZSBuYW1lIG9mIHRleHR1cmUsIGZvciBjYWNoZSBhbmQgcmVzb2x2aW5nIHJlc29sdXRpb24uXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBbbmFtZV0gLSBIdW1hbiByZWFkYWJsZSBuYW1lIGZvciB0aGUgdGV4dHVyZSBjYWNoZS4gSWYgbm8gbmFtZSBpc1xyXG4gKiAgICAgICAgc3BlY2lmaWVkLCBvbmx5IGBpbWFnZVVybGAgd2lsbCBiZSB1c2VkIGFzIHRoZSBjYWNoZSBJRC5cclxuICogQHJldHVybiB7UElYSS5UZXh0dXJlfSBPdXRwdXQgdGV4dHVyZVxyXG4gKi9cclxuVGV4dHVyZS5mcm9tTG9hZGVyID0gZnVuY3Rpb24gZnJvbUxvYWRlcihzb3VyY2UsIGltYWdlVXJsLCBuYW1lKSB7XHJcbiAgICB2YXIgcmVzb3VyY2UgPSBuZXcgSW1hZ2VSZXNvdXJjZV8xLkltYWdlUmVzb3VyY2Uoc291cmNlKTtcclxuICAgIHJlc291cmNlLnVybCA9IGltYWdlVXJsO1xyXG4gICAgdmFyIGJhc2VUZXh0dXJlID0gbmV3IEJhc2VUZXh0dXJlXzEuQmFzZVRleHR1cmUocmVzb3VyY2UsIHtcclxuICAgICAgICBzY2FsZU1vZGU6IERpc3BsYXlTZXR0aW5nc18xLkRpc3BsYXlTZXR0aW5ncy5TQ0FMRV9NT0RFLFxyXG4gICAgICAgIHJlc29sdXRpb246IE5ldHdvcmtTZXR0aW5nc18xLk5ldHdvcmtTZXR0aW5ncy5nZXRSZXNvbHV0aW9uT2ZVcmwoaW1hZ2VVcmwpLFxyXG4gICAgfSk7XHJcbiAgICB2YXIgdGV4dHVyZSA9IG5ldyBUZXh0dXJlKGJhc2VUZXh0dXJlKTtcclxuICAgIC8vIE5vIG5hbWUsIHVzZSBpbWFnZVVybCBpbnN0ZWFkXHJcbiAgICBpZiAoIW5hbWUpIHtcclxuICAgICAgICBuYW1lID0gaW1hZ2VVcmw7XHJcbiAgICB9XHJcbiAgICAvLyBsZXRzIGFsc28gYWRkIHRoZSBmcmFtZSB0byBwaXhpJ3MgZ2xvYmFsIGNhY2hlIGZvciBmcm9tRnJhbWUgYW5kIGZyb21JbWFnZSBmdW5jdGlvbnNcclxuICAgIEJhc2VUZXh0dXJlXzEuQmFzZVRleHR1cmUuYWRkVG9DYWNoZSh0ZXh0dXJlLmJhc2VUZXh0dXJlLCBuYW1lKTtcclxuICAgIFRleHR1cmUuYWRkVG9DYWNoZSh0ZXh0dXJlLCBuYW1lKTtcclxuICAgIC8vIGFsc28gYWRkIHJlZmVyZW5jZXMgYnkgdXJsIGlmIHRoZXkgYXJlIGRpZmZlcmVudC5cclxuICAgIGlmIChuYW1lICE9PSBpbWFnZVVybCkge1xyXG4gICAgICAgIEJhc2VUZXh0dXJlXzEuQmFzZVRleHR1cmUuYWRkVG9DYWNoZSh0ZXh0dXJlLmJhc2VUZXh0dXJlLCBpbWFnZVVybCk7XHJcbiAgICAgICAgVGV4dHVyZS5hZGRUb0NhY2hlKHRleHR1cmUsIGltYWdlVXJsKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0ZXh0dXJlO1xyXG59O1xyXG5leHBvcnRzLlRleHR1cmUgPSBUZXh0dXJlO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBTeXN0ZW1fMSA9IHJlcXVpcmUoXCIuL1N5c3RlbVwiKTtcclxuY29uc3Qgc2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL3NldHRpbmdzXCIpO1xyXG5jbGFzcyBUZXh0dXJlR0NTeXN0ZW0gZXh0ZW5kcyBTeXN0ZW1fMS5TeXN0ZW0ge1xyXG4gICAgY29uc3RydWN0b3IocmVuZGVyZXIpIHtcclxuICAgICAgICBzdXBlcihyZW5kZXJlcik7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ291bnRcclxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgICAgICogQHJlYWRvbmx5XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5jb3VudCA9IDA7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2hlY2sgY291bnRcclxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgICAgICogQHJlYWRvbmx5XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5jaGVja0NvdW50ID0gMDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBNYXhpbXVtIGlkbGUgdGltZSwgaW4gc2Vjb25kc1xyXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAgICAgKiBAc2VlIFBJWEkuc2V0dGluZ3MuR0NfTUFYX0lETEVcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLm1heElkbGUgPSBzZXR0aW5nc18xLnNldHRpbmdzLkdDX01BWF9JRExFO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIE1heGltdW0gbnVtYmVyIG9mIGl0ZXNtIHRvIGNoZWNrXHJcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICAgICAqIEBzZWUgUElYSS5zZXR0aW5ncy5HQ19NQVhfQ0hFQ0tfQ09VTlRcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmNoZWNrQ291bnRNYXggPSBzZXR0aW5nc18xLnNldHRpbmdzLkdDX01BWF9DSEVDS19DT1VOVDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDdXJyZW50IGdhcmFiYWdlIGNvbGxlY3Rpb24gbW9kZVxyXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuR0NfTU9ERVN9XHJcbiAgICAgICAgICogQHNlZSBQSVhJLnNldHRpbmdzLkdDX01PREVcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLm1vZGUgPSBzZXR0aW5nc18xLnNldHRpbmdzLkdDX01PREU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENoZWNrcyB0byBzZWUgd2hlbiB0aGUgbGFzdCB0aW1lIGEgdGV4dHVyZSB3YXMgdXNlZFxyXG4gICAgICogaWYgdGhlIHRleHR1cmUgaGFzIG5vdCBiZWVuIHVzZWQgZm9yIGEgc3BlY2lmaWVkIGFtb3VudCBvZiB0aW1lIGl0IHdpbGwgYmUgcmVtb3ZlZCBmcm9tIHRoZSBHUFVcclxuICAgICAqL1xyXG4gICAgcG9zdHJlbmRlcigpIHtcclxuICAgICAgICB0aGlzLmNvdW50Kys7XHJcbiAgICAgICAgaWYgKHRoaXMubW9kZSA9PT0gc2V0dGluZ3NfMS5zZXR0aW5ncy5HQ19NT0RFUy5NQU5VQUwpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmNoZWNrQ291bnQrKztcclxuICAgICAgICBpZiAodGhpcy5jaGVja0NvdW50ID4gdGhpcy5jaGVja0NvdW50TWF4KSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2hlY2tDb3VudCA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMucnVuKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVja3MgdG8gc2VlIHdoZW4gdGhlIGxhc3QgdGltZSBhIHRleHR1cmUgd2FzIHVzZWRcclxuICAgICAqIGlmIHRoZSB0ZXh0dXJlIGhhcyBub3QgYmVlbiB1c2VkIGZvciBhIHNwZWNpZmllZCBhbW91bnQgb2YgdGltZSBpdCB3aWxsIGJlIHJlbW92ZWQgZnJvbSB0aGUgR1BVXHJcbiAgICAgKi9cclxuICAgIHJ1bigpIHtcclxuICAgICAgICB2YXIgdG0gPSB0aGlzLnJlbmRlcmVyLnRleHR1cmU7XHJcbiAgICAgICAgdmFyIG1hbmFnZWRUZXh0dXJlcyA9IHRtLm1hbmFnZWRUZXh0dXJlcztcclxuICAgICAgICB2YXIgd2FzUmVtb3ZlZCA9IGZhbHNlO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWFuYWdlZFRleHR1cmVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciB0ZXh0dXJlID0gbWFuYWdlZFRleHR1cmVzW2ldO1xyXG4gICAgICAgICAgICAvLyBvbmx5IHN1cHBvcnRzIG5vbiBnZW5lcmF0ZWQgdGV4dHVyZXMgYXQgdGhlIG1vbWVudCFcclxuICAgICAgICAgICAgaWYgKCF0ZXh0dXJlLmZyYW1lYnVmZmVyICYmIHRoaXMuY291bnQgLSB0ZXh0dXJlLnRvdWNoZWQgPiB0aGlzLm1heElkbGUpIHtcclxuICAgICAgICAgICAgICAgIHRtLmRlc3Ryb3lUZXh0dXJlKHRleHR1cmUsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgbWFuYWdlZFRleHR1cmVzW2ldID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIHdhc1JlbW92ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh3YXNSZW1vdmVkKSB7XHJcbiAgICAgICAgICAgIHZhciBqID0gMDtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgbWFuYWdlZFRleHR1cmVzLmxlbmd0aDsgaSQxKyspIHtcclxuICAgICAgICAgICAgICAgIGlmIChtYW5hZ2VkVGV4dHVyZXNbaSQxXSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG1hbmFnZWRUZXh0dXJlc1tqKytdID0gbWFuYWdlZFRleHR1cmVzW2kkMV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbWFuYWdlZFRleHR1cmVzLmxlbmd0aCA9IGo7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIGFsbCB0aGUgdGV4dHVyZXMgd2l0aGluIHRoZSBzcGVjaWZpZWQgZGlzcGxheU9iamVjdCBhbmQgaXRzIGNoaWxkcmVuIGZyb20gdGhlIEdQVVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7UElYSS5EaXNwbGF5T2JqZWN0fSBkaXNwbGF5T2JqZWN0IC0gdGhlIGRpc3BsYXlPYmplY3QgdG8gcmVtb3ZlIHRoZSB0ZXh0dXJlcyBmcm9tLlxyXG4gICAgICovXHJcbiAgICB1bmxvYWQoZGlzcGxheU9iamVjdCkge1xyXG4gICAgICAgIC8vIHZhciB0bSA9IHRoaXMucmVuZGVyZXIudGV4dHVyZVN5c3RlbTtcclxuICAgICAgICB2YXIgdG0gPSB0aGlzLnJlbmRlcmVyLnRleHR1cmU7XHJcbiAgICAgICAgLy8gb25seSBkZXN0cm95IG5vbiBnZW5lcmF0ZWQgdGV4dHVyZXNcclxuICAgICAgICBpZiAoZGlzcGxheU9iamVjdC5fdGV4dHVyZSAmJiBkaXNwbGF5T2JqZWN0Ll90ZXh0dXJlLl9nbFJlbmRlclRhcmdldHMpIHtcclxuICAgICAgICAgICAgdG0uZGVzdHJveVRleHR1cmUoZGlzcGxheU9iamVjdC5fdGV4dHVyZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAodmFyIGkgPSBkaXNwbGF5T2JqZWN0LmNoaWxkcmVuLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgICAgIHRoaXMudW5sb2FkKGRpc3BsYXlPYmplY3QuY2hpbGRyZW5baV0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIDtcclxufVxyXG5leHBvcnRzLlRleHR1cmVHQ1N5c3RlbSA9IFRleHR1cmVHQ1N5c3RlbTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgTWF0cml4XzEgPSByZXF1aXJlKFwiLi9NYXRyaXhcIik7XHJcbmNsYXNzIFRleHR1cmVNYXRyaXgge1xyXG4gICAgY29uc3RydWN0b3IodGV4dHVyZSwgY2xhbXBNYXJnaW4gPSBudWxsKSB7XHJcbiAgICAgICAgdGhpcy5fdGV4dHVyZSA9IHRleHR1cmU7XHJcbiAgICAgICAgdGhpcy5tYXBDb29yZCA9IG5ldyBNYXRyaXhfMS5NYXRyaXgoKTtcclxuICAgICAgICB0aGlzLnVDbGFtcEZyYW1lID0gbmV3IEZsb2F0MzJBcnJheSg0KTtcclxuICAgICAgICB0aGlzLnVDbGFtcE9mZnNldCA9IG5ldyBGbG9hdDMyQXJyYXkoMik7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVHJhY2tzIFRleHR1cmUgZnJhbWUgY2hhbmdlc1xyXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAgICAgKiBAcHJvdGVjdGVkXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5fdXBkYXRlSUQgPSAtMTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDaGFuZ2VzIGZyYW1lIGNsYW1waW5nXHJcbiAgICAgICAgICogV29ya3Mgd2l0aCBUaWxpbmdTcHJpdGUgYW5kIE1lc2hcclxuICAgICAgICAgKiBDaGFuZ2UgdG8gMS41IGlmIHlvdSB0ZXh0dXJlIGhhcyByZXBlYXRlZCByaWdodCBhbmQgYm90dG9tIGxpbmVzLCB0aGF0IGxlYWRzIHRvIHNtb290aGVyIGJvcmRlcnNcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBkZWZhdWx0IDBcclxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5jbGFtcE9mZnNldCA9IDA7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2hhbmdlcyBmcmFtZSBjbGFtcGluZ1xyXG4gICAgICAgICAqIFdvcmtzIHdpdGggVGlsaW5nU3ByaXRlIGFuZCBNZXNoXHJcbiAgICAgICAgICogQ2hhbmdlIHRvIC0wLjUgdG8gYWRkIGEgcGl4ZWwgdG8gdGhlIGVkZ2UsIHJlY29tbWVuZGVkIGZvciB0cmFuc3BhcmVudCB0cmltbWVkIHRleHR1cmVzIGluIGF0bGFzXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAZGVmYXVsdCAwLjVcclxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5jbGFtcE1hcmdpbiA9ICh0eXBlb2YgY2xhbXBNYXJnaW4gPT09ICd1bmRlZmluZWQnKSA/IDAuNSA6IGNsYW1wTWFyZ2luO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIElmIHRleHR1cmUgc2l6ZSBpcyB0aGUgc2FtZSBhcyBiYXNlVGV4dHVyZVxyXG4gICAgICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XHJcbiAgICAgICAgICogQGRlZmF1bHQgZmFsc2VcclxuICAgICAgICAgKiBAcmVhZG9ubHlcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmlzU2ltcGxlID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIHRleHR1cmUgcHJvcGVydHlcclxuICAgICAqIEBtZW1iZXIge1BJWEkuVGV4dHVyZX1cclxuICAgICAqL1xyXG4gICAgZ2V0IHRleHR1cmUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RleHR1cmU7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICBzZXQgdGV4dHVyZSh2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuX3RleHR1cmUgPSB2YWx1ZTtcclxuICAgICAgICB0aGlzLl91cGRhdGVJRCA9IC0xO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBNdWx0aXBsaWVzIHV2cyBhcnJheSB0byB0cmFuc2Zvcm1cclxuICAgICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fSB1dnMgbWVzaCB1dnNcclxuICAgICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fSBbb3V0PXV2c10gb3V0cHV0XHJcbiAgICAgKiBAcmV0dXJucyB7RmxvYXQzMkFycmF5fSBvdXRwdXRcclxuICAgICAqL1xyXG4gICAgbXVsdGlwbHlVdnModXZzLCBvdXQpIHtcclxuICAgICAgICBpZiAob3V0ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgb3V0ID0gdXZzO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgbWF0ID0gdGhpcy5tYXBDb29yZDtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHV2cy5sZW5ndGg7IGkgKz0gMikge1xyXG4gICAgICAgICAgICB2YXIgeCA9IHV2c1tpXTtcclxuICAgICAgICAgICAgdmFyIHkgPSB1dnNbaSArIDFdO1xyXG4gICAgICAgICAgICBvdXRbaV0gPSAoeCAqIG1hdC5hKSArICh5ICogbWF0LmMpICsgbWF0LnR4O1xyXG4gICAgICAgICAgICBvdXRbaSArIDFdID0gKHggKiBtYXQuYikgKyAoeSAqIG1hdC5kKSArIG1hdC50eTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG91dDtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogdXBkYXRlcyBtYXRyaWNlcyBpZiB0ZXh0dXJlIHdhcyBjaGFuZ2VkXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGZvcmNlVXBkYXRlIGlmIHRydWUsIG1hdHJpY2VzIHdpbGwgYmUgdXBkYXRlZCBhbnkgY2FzZVxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IHdoZXRoZXIgb3Igbm90IGl0IHdhcyB1cGRhdGVkXHJcbiAgICAgKi9cclxuICAgIHVwZGF0ZShmb3JjZVVwZGF0ZSkge1xyXG4gICAgICAgIHZhciB0ZXggPSB0aGlzLl90ZXh0dXJlO1xyXG4gICAgICAgIGlmICghdGV4IHx8ICF0ZXgudmFsaWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWZvcmNlVXBkYXRlXHJcbiAgICAgICAgICAgICYmIHRoaXMuX3VwZGF0ZUlEID09PSB0ZXguX3VwZGF0ZUlEKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fdXBkYXRlSUQgPSB0ZXguX3VwZGF0ZUlEO1xyXG4gICAgICAgIHZhciB1dnMgPSB0ZXguX3V2cztcclxuICAgICAgICB0aGlzLm1hcENvb3JkLnNldCh1dnMueDEgLSB1dnMueDAsIHV2cy55MSAtIHV2cy55MCwgdXZzLngzIC0gdXZzLngwLCB1dnMueTMgLSB1dnMueTAsIHV2cy54MCwgdXZzLnkwKTtcclxuICAgICAgICB2YXIgb3JpZyA9IHRleC5vcmlnO1xyXG4gICAgICAgIHZhciB0cmltID0gdGV4LnRyaW07XHJcbiAgICAgICAgaWYgKHRyaW0pIHtcclxuICAgICAgICAgICAgVGV4dHVyZU1hdHJpeC50ZW1wTWF0LnNldChvcmlnLndpZHRoIC8gdHJpbS53aWR0aCwgMCwgMCwgb3JpZy5oZWlnaHQgLyB0cmltLmhlaWdodCwgLXRyaW0ueCAvIHRyaW0ud2lkdGgsIC10cmltLnkgLyB0cmltLmhlaWdodCk7XHJcbiAgICAgICAgICAgIHRoaXMubWFwQ29vcmQuYXBwZW5kKFRleHR1cmVNYXRyaXgudGVtcE1hdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciB0ZXhCYXNlID0gdGV4LmJhc2VUZXh0dXJlO1xyXG4gICAgICAgIHZhciBmcmFtZSA9IHRoaXMudUNsYW1wRnJhbWU7XHJcbiAgICAgICAgdmFyIG1hcmdpbiA9IHRoaXMuY2xhbXBNYXJnaW4gLyB0ZXhCYXNlLnJlc29sdXRpb247XHJcbiAgICAgICAgdmFyIG9mZnNldCA9IHRoaXMuY2xhbXBPZmZzZXQ7XHJcbiAgICAgICAgZnJhbWVbMF0gPSAodGV4Ll9mcmFtZS54ICsgbWFyZ2luICsgb2Zmc2V0KSAvIHRleEJhc2Uud2lkdGg7XHJcbiAgICAgICAgZnJhbWVbMV0gPSAodGV4Ll9mcmFtZS55ICsgbWFyZ2luICsgb2Zmc2V0KSAvIHRleEJhc2UuaGVpZ2h0O1xyXG4gICAgICAgIGZyYW1lWzJdID0gKHRleC5fZnJhbWUueCArIHRleC5fZnJhbWUud2lkdGggLSBtYXJnaW4gKyBvZmZzZXQpIC8gdGV4QmFzZS53aWR0aDtcclxuICAgICAgICBmcmFtZVszXSA9ICh0ZXguX2ZyYW1lLnkgKyB0ZXguX2ZyYW1lLmhlaWdodCAtIG1hcmdpbiArIG9mZnNldCkgLyB0ZXhCYXNlLmhlaWdodDtcclxuICAgICAgICB0aGlzLnVDbGFtcE9mZnNldFswXSA9IG9mZnNldCAvIHRleEJhc2UucmVhbFdpZHRoO1xyXG4gICAgICAgIHRoaXMudUNsYW1wT2Zmc2V0WzFdID0gb2Zmc2V0IC8gdGV4QmFzZS5yZWFsSGVpZ2h0O1xyXG4gICAgICAgIHRoaXMuaXNTaW1wbGUgPSB0ZXguX2ZyYW1lLndpZHRoID09PSB0ZXhCYXNlLndpZHRoXHJcbiAgICAgICAgICAgICYmIHRleC5fZnJhbWUuaGVpZ2h0ID09PSB0ZXhCYXNlLmhlaWdodFxyXG4gICAgICAgICAgICAmJiB0ZXgucm90YXRlID09PSAwO1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgO1xyXG59XHJcblRleHR1cmVNYXRyaXgudGVtcE1hdCA9IG5ldyBNYXRyaXhfMS5NYXRyaXgoKTtcclxuZXhwb3J0cy5UZXh0dXJlTWF0cml4ID0gVGV4dHVyZU1hdHJpeDtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgU3lzdGVtXzEgPSByZXF1aXJlKFwiLi9TeXN0ZW1cIik7XHJcbmNvbnN0IEJhc2VUZXh0dXJlXzEgPSByZXF1aXJlKFwiLi9CYXNlVGV4dHVyZVwiKTtcclxuY29uc3QgR0xUZXh0dXJlXzEgPSByZXF1aXJlKFwiLi9HTFRleHR1cmVcIik7XHJcbmNvbnN0IFV0aWxzU2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL1V0aWxzU2V0dGluZ3NcIik7XHJcbmNvbnN0IFdlYkdMU2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL1dlYkdMU2V0dGluZ3NcIik7XHJcbmNvbnN0IExvZ2dlcl8xID0gcmVxdWlyZShcIi4vTG9nZ2VyXCIpO1xyXG5jbGFzcyBUZXh0dXJlU3lzdGVtIGV4dGVuZHMgU3lzdGVtXzEuU3lzdGVtIHtcclxuICAgIGNvbnN0cnVjdG9yKHJlbmRlcmVyKSB7XHJcbiAgICAgICAgc3VwZXIocmVuZGVyZXIpO1xyXG4gICAgICAgIC8vIFRPRE8gc2V0IHRvIG1heCB0ZXh0dXJlcy4uLlxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEJvdW5kIHRleHR1cmVzXHJcbiAgICAgICAgICogQG1lbWJlciB7UElYSS5CYXNlVGV4dHVyZVtdfVxyXG4gICAgICAgICAqIEByZWFkb25seVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuYm91bmRUZXh0dXJlcyA9IFtdO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEN1cnJlbnQgbG9jYXRpb25cclxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgICAgICogQHJlYWRvbmx5XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5jdXJyZW50TG9jYXRpb24gPSAtMTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBMaXN0IG9mIG1hbmFnZWQgdGV4dHVyZXNcclxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLkJhc2VUZXh0dXJlW119XHJcbiAgICAgICAgICogQHJlYWRvbmx5XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5tYW5hZ2VkVGV4dHVyZXMgPSBbXTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBEaWQgc29tZW9uZSB0ZW1wZXIgd2l0aCB0ZXh0dXJlcyBzdGF0ZT8gV2UnbGwgb3ZlcndyaXRlIHRoZW0gd2hlbiB3ZSBuZWVkIHRvIHVuYmluZCBzb21ldGhpbmcuXHJcbiAgICAgICAgICogQG1lbWJlciB7Ym9vbGVhbn1cclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuX3Vua25vd25Cb3VuZFRleHR1cmVzID0gZmFsc2U7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQmFzZVRleHR1cmUgdmFsdWUgdGhhdCBzaG93cyB0aGF0IHdlIGRvbid0IGtub3cgd2hhdCBpcyBib3VuZFxyXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuQmFzZVRleHR1cmV9XHJcbiAgICAgICAgICogQHJlYWRvbmx5XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy51bmtub3duVGV4dHVyZSA9IG5ldyBCYXNlVGV4dHVyZV8xLkJhc2VUZXh0dXJlKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdXAgdGhlIHJlbmRlcmVyIGNvbnRleHQgYW5kIG5lY2Vzc2FyeSBidWZmZXJzLlxyXG4gICAgICovXHJcbiAgICBjb250ZXh0Q2hhbmdlKCkge1xyXG4gICAgICAgIHZhciBnbCA9IHRoaXMuZ2wgPSB0aGlzLnJlbmRlcmVyLmdsO1xyXG4gICAgICAgIHRoaXMuQ09OVEVYVF9VSUQgPSB0aGlzLnJlbmRlcmVyLkNPTlRFWFRfVUlEO1xyXG4gICAgICAgIHRoaXMud2ViR0xWZXJzaW9uID0gdGhpcy5yZW5kZXJlci5jb250ZXh0LndlYkdMVmVyc2lvbjtcclxuICAgICAgICB2YXIgbWF4VGV4dHVyZXMgPSBnbC5nZXRQYXJhbWV0ZXIoZ2wuTUFYX1RFWFRVUkVfSU1BR0VfVU5JVFMpO1xyXG4gICAgICAgIHRoaXMuYm91bmRUZXh0dXJlcy5sZW5ndGggPSBtYXhUZXh0dXJlcztcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1heFRleHR1cmVzOyBpKyspIHtcclxuICAgICAgICAgICAgdGhpcy5ib3VuZFRleHR1cmVzW2ldID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gVE9ETyBtb3ZlIHRoaXMuLiB0byBhIG5pY2UgbWFrZSBlbXB0eSB0ZXh0dXJlcyBjbGFzcy4uXHJcbiAgICAgICAgdGhpcy5lbXB0eVRleHR1cmVzID0ge307XHJcbiAgICAgICAgdmFyIGVtcHR5VGV4dHVyZTJEID0gbmV3IEdMVGV4dHVyZV8xLkdMVGV4dHVyZShnbC5jcmVhdGVUZXh0dXJlKCkpO1xyXG4gICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIGVtcHR5VGV4dHVyZTJELnRleHR1cmUpO1xyXG4gICAgICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgMSwgMSwgMCwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgbmV3IFVpbnQ4QXJyYXkoNCkpO1xyXG4gICAgICAgIHRoaXMuZW1wdHlUZXh0dXJlc1tnbC5URVhUVVJFXzJEXSA9IGVtcHR5VGV4dHVyZTJEO1xyXG4gICAgICAgIHRoaXMuZW1wdHlUZXh0dXJlc1tnbC5URVhUVVJFX0NVQkVfTUFQXSA9IG5ldyBHTFRleHR1cmVfMS5HTFRleHR1cmUoZ2wuY3JlYXRlVGV4dHVyZSgpKTtcclxuICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFX0NVQkVfTUFQLCB0aGlzLmVtcHR5VGV4dHVyZXNbZ2wuVEVYVFVSRV9DVUJFX01BUF0udGV4dHVyZSk7XHJcbiAgICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgNjsgaSQxKyspIHtcclxuICAgICAgICAgICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1ggKyBpJDEsIDAsIGdsLlJHQkEsIDEsIDEsIDAsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIG51bGwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfQ1VCRV9NQVAsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZ2wuTElORUFSKTtcclxuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfQ1VCRV9NQVAsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2wuTElORUFSKTtcclxuICAgICAgICBmb3IgKHZhciBpJDIgPSAwOyBpJDIgPCB0aGlzLmJvdW5kVGV4dHVyZXMubGVuZ3RoOyBpJDIrKykge1xyXG4gICAgICAgICAgICB0aGlzLmJpbmQobnVsbCwgaSQyKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIEJpbmQgYSB0ZXh0dXJlIHRvIGEgc3BlY2lmaWMgbG9jYXRpb25cclxuICAgICAqXHJcbiAgICAgKiBJZiB5b3Ugd2FudCB0byB1bmJpbmQgc29tZXRoaW5nLCBwbGVhc2UgdXNlIGB1bmJpbmQodGV4dHVyZSlgIGluc3RlYWQgb2YgYGJpbmQobnVsbCwgdGV4dHVyZUxvY2F0aW9uKWBcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1BJWEkuVGV4dHVyZXxQSVhJLkJhc2VUZXh0dXJlfSB0ZXh0dXJlIC0gVGV4dHVyZSB0byBiaW5kXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xvY2F0aW9uPTBdIC0gTG9jYXRpb24gdG8gYmluZCBhdFxyXG4gICAgICovXHJcbiAgICBiaW5kKHRleHR1cmUsIGxvY2F0aW9uID0gMCkge1xyXG4gICAgICAgIHZhciByZWYgPSB0aGlzO1xyXG4gICAgICAgIHZhciBnbCA9IHJlZi5nbDtcclxuICAgICAgICBpZiAodGV4dHVyZSkge1xyXG4gICAgICAgICAgICB0ZXh0dXJlID0gdGV4dHVyZS5iYXNlVGV4dHVyZSB8fCB0ZXh0dXJlO1xyXG4gICAgICAgICAgICBpZiAodGV4dHVyZS52YWxpZCkge1xyXG4gICAgICAgICAgICAgICAgdGV4dHVyZS50b3VjaGVkID0gdGhpcy5yZW5kZXJlci50ZXh0dXJlR0MuY291bnQ7XHJcbiAgICAgICAgICAgICAgICB2YXIgZ2xUZXh0dXJlID0gdGV4dHVyZS5fZ2xUZXh0dXJlc1t0aGlzLkNPTlRFWFRfVUlEXSB8fCB0aGlzLmluaXRUZXh0dXJlKHRleHR1cmUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudExvY2F0aW9uICE9PSBsb2NhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudExvY2F0aW9uID0gbG9jYXRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCArIGxvY2F0aW9uKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmJvdW5kVGV4dHVyZXNbbG9jYXRpb25dICE9PSB0ZXh0dXJlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZ2wuYmluZFRleHR1cmUodGV4dHVyZS50YXJnZXQsIGdsVGV4dHVyZS50ZXh0dXJlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChnbFRleHR1cmUuZGlydHlJZCAhPT0gdGV4dHVyZS5kaXJ0eUlkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVUZXh0dXJlKHRleHR1cmUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5ib3VuZFRleHR1cmVzW2xvY2F0aW9uXSA9IHRleHR1cmU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRMb2NhdGlvbiAhPT0gbG9jYXRpb24pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudExvY2F0aW9uID0gbG9jYXRpb247XHJcbiAgICAgICAgICAgICAgICBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwICsgbG9jYXRpb24pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRoaXMuZW1wdHlUZXh0dXJlc1tnbC5URVhUVVJFXzJEXS50ZXh0dXJlKTtcclxuICAgICAgICAgICAgdGhpcy5ib3VuZFRleHR1cmVzW2xvY2F0aW9uXSA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXNldHMgdGV4dHVyZSBsb2NhdGlvbiBhbmQgYm91bmQgdGV4dHVyZXNcclxuICAgICAqXHJcbiAgICAgKiBBY3R1YWwgYGJpbmQobnVsbCwgaSlgIGNhbGxzIHdpbGwgYmUgcGVyZm9ybWVkIGF0IG5leHQgYHVuYmluZCgpYCBjYWxsXHJcbiAgICAgKi9cclxuICAgIHJlc2V0KCkge1xyXG4gICAgICAgIHRoaXMuX3Vua25vd25Cb3VuZFRleHR1cmVzID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmN1cnJlbnRMb2NhdGlvbiA9IC0xO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5ib3VuZFRleHR1cmVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYm91bmRUZXh0dXJlc1tpXSA9IHRoaXMudW5rbm93blRleHR1cmU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBVbmJpbmQgYSB0ZXh0dXJlXHJcbiAgICAgKiBAcGFyYW0ge1BJWEkuVGV4dHVyZXxQSVhJLkJhc2VUZXh0dXJlfSB0ZXh0dXJlIC0gVGV4dHVyZSB0byBiaW5kXHJcbiAgICAgKi9cclxuICAgIHVuYmluZCh0ZXh0dXJlKSB7XHJcbiAgICAgICAgdmFyIHJlZiA9IHRoaXM7XHJcbiAgICAgICAgdmFyIGdsID0gcmVmLmdsO1xyXG4gICAgICAgIHZhciBib3VuZFRleHR1cmVzID0gcmVmLmJvdW5kVGV4dHVyZXM7XHJcbiAgICAgICAgaWYgKHRoaXMuX3Vua25vd25Cb3VuZFRleHR1cmVzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3Vua25vd25Cb3VuZFRleHR1cmVzID0gZmFsc2U7XHJcbiAgICAgICAgICAgIC8vIHNvbWVvbmUgY2hhbmdlZCB3ZWJHTCBzdGF0ZSxcclxuICAgICAgICAgICAgLy8gd2UgaGF2ZSB0byBiZSBzdXJlIHRoYXQgb3VyIHRleHR1cmUgZG9lcyBub3QgYXBwZWFyIGluIG11bHRpLXRleHR1cmUgcmVuZGVyZXIgc2FtcGxlcnNcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBib3VuZFRleHR1cmVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYm91bmRUZXh0dXJlc1tpXSA9PT0gdGhpcy51bmtub3duVGV4dHVyZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYmluZChudWxsLCBpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBib3VuZFRleHR1cmVzLmxlbmd0aDsgaSQxKyspIHtcclxuICAgICAgICAgICAgaWYgKGJvdW5kVGV4dHVyZXNbaSQxXSA9PT0gdGV4dHVyZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudExvY2F0aW9uICE9PSBpJDEpIHtcclxuICAgICAgICAgICAgICAgICAgICBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwICsgaSQxKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRMb2NhdGlvbiA9IGkkMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRoaXMuZW1wdHlUZXh0dXJlc1t0ZXh0dXJlLnRhcmdldF0udGV4dHVyZSk7XHJcbiAgICAgICAgICAgICAgICBib3VuZFRleHR1cmVzW2kkMV0gPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBJbml0aWFsaXplIGEgdGV4dHVyZVxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge1BJWEkuQmFzZVRleHR1cmV9IHRleHR1cmUgLSBUZXh0dXJlIHRvIGluaXRpYWxpemVcclxuICAgICAqL1xyXG4gICAgaW5pdFRleHR1cmUodGV4dHVyZSkge1xyXG4gICAgICAgIHZhciBnbFRleHR1cmUgPSBuZXcgR0xUZXh0dXJlXzEuR0xUZXh0dXJlKHRoaXMuZ2wuY3JlYXRlVGV4dHVyZSgpKTtcclxuICAgICAgICAvLyBndWFyYW50ZWUgYW4gdXBkYXRlLi5cclxuICAgICAgICBnbFRleHR1cmUuZGlydHlJZCA9IC0xO1xyXG4gICAgICAgIHRleHR1cmUuX2dsVGV4dHVyZXNbdGhpcy5DT05URVhUX1VJRF0gPSBnbFRleHR1cmU7XHJcbiAgICAgICAgdGhpcy5tYW5hZ2VkVGV4dHVyZXMucHVzaCh0ZXh0dXJlKTtcclxuICAgICAgICAvLyB0ZXh0dXJlLm9uKCdkaXNwb3NlJywgdGhpcy5kZXN0cm95VGV4dHVyZSwgdGhpcyk7XHJcbiAgICAgICAgcmV0dXJuIGdsVGV4dHVyZTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlIGEgdGV4dHVyZVxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge1BJWEkuQmFzZVRleHR1cmV9IHRleHR1cmUgLSBUZXh0dXJlIHRvIGluaXRpYWxpemVcclxuICAgICAqL1xyXG4gICAgdXBkYXRlVGV4dHVyZSh0ZXh0dXJlKSB7XHJcbiAgICAgICAgdmFyIGdsVGV4dHVyZSA9IHRleHR1cmUuX2dsVGV4dHVyZXNbdGhpcy5DT05URVhUX1VJRF07XHJcbiAgICAgICAgdmFyIHJlbmRlcmVyID0gdGhpcy5yZW5kZXJlcjtcclxuICAgICAgICBpZiAodGV4dHVyZS5yZXNvdXJjZSAmJiB0ZXh0dXJlLnJlc291cmNlLmNhblVwbG9hZCkge1xyXG4gICAgICAgICAgICB0ZXh0dXJlLnJlc291cmNlLnVwbG9hZChyZW5kZXJlciwgdGV4dHVyZSwgZ2xUZXh0dXJlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gaWYgKHRleHR1cmUucmVzb3VyY2UgJiYgdGV4dHVyZS5yZXNvdXJjZS51cGxvYWQocmVuZGVyZXIsIHRleHR1cmUsIGdsVGV4dHVyZSkpXHJcbiAgICAgICAgZWxzZSBpZiAodGV4dHVyZS5yZXNvdXJjZSAmJiB0aGlzLnVwbG9hZFRleHR1cmUocmVuZGVyZXIsIHRleHR1cmUsIGdsVGV4dHVyZSwgdGV4dHVyZS5yZXNvdXJjZSkpIHtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIGRlZmF1bHQsIHJlbmRlclRleHR1cmUtbGlrZSBsb2dpY1xyXG4gICAgICAgICAgICB2YXIgd2lkdGggPSB0ZXh0dXJlLnJlYWxXaWR0aDtcclxuICAgICAgICAgICAgdmFyIGhlaWdodCA9IHRleHR1cmUucmVhbEhlaWdodDtcclxuICAgICAgICAgICAgdmFyIGdsID0gcmVuZGVyZXIuZ2w7XHJcbiAgICAgICAgICAgIGlmIChnbFRleHR1cmUud2lkdGggIT09IHdpZHRoXHJcbiAgICAgICAgICAgICAgICB8fCBnbFRleHR1cmUuaGVpZ2h0ICE9PSBoZWlnaHRcclxuICAgICAgICAgICAgICAgIHx8IGdsVGV4dHVyZS5kaXJ0eUlkIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgZ2xUZXh0dXJlLndpZHRoID0gd2lkdGg7XHJcbiAgICAgICAgICAgICAgICBnbFRleHR1cmUuaGVpZ2h0ID0gaGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgZ2wudGV4SW1hZ2UyRCh0ZXh0dXJlLnRhcmdldCwgMCwgdGV4dHVyZS5mb3JtYXQsIHdpZHRoLCBoZWlnaHQsIDAsIHRleHR1cmUuZm9ybWF0LCB0ZXh0dXJlLnR5cGUsIG51bGwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGxldHMgb25seSB1cGRhdGUgd2hhdCBjaGFuZ2VzLi5cclxuICAgICAgICBpZiAodGV4dHVyZS5kaXJ0eVN0eWxlSWQgIT09IGdsVGV4dHVyZS5kaXJ0eVN0eWxlSWQpIHtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVUZXh0dXJlU3R5bGUodGV4dHVyZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGdsVGV4dHVyZS5kaXJ0eUlkID0gdGV4dHVyZS5kaXJ0eUlkO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgdXBsb2FkVGV4dHVyZShyZW5kZXJlciwgYmFzZVRleHR1cmUsIGdsVGV4dHVyZSwgc291cmNlKSB7XHJcbiAgICAgICAgdmFyIGdsID0gcmVuZGVyZXIuZ2w7XHJcbiAgICAgICAgdmFyIHdpZHRoID0gYmFzZVRleHR1cmUucmVhbFdpZHRoO1xyXG4gICAgICAgIHZhciBoZWlnaHQgPSBiYXNlVGV4dHVyZS5yZWFsSGVpZ2h0O1xyXG4gICAgICAgIC8vIHNvdXJjZSA9IHNvdXJjZSB8fCB0aGlzLnNvdXJjZTtcclxuICAgICAgICBpZiAoc291cmNlLmNvbnN0cnVjdG9yWyduYW1lJ10gPT0gXCJDYW52YXNSZXNvdXJjZVwiKSB7XHJcbiAgICAgICAgICAgIHNvdXJjZSA9IHNvdXJjZS5zb3VyY2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHNvdXJjZS5jb25zdHJ1Y3RvclsnbmFtZSddID09IFwiSW1hZ2VSZXNvdXJjZVwiKSB7XHJcbiAgICAgICAgICAgIHNvdXJjZSA9IHNvdXJjZS5zb3VyY2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHNvdXJjZS5jb25zdHJ1Y3RvclsnbmFtZSddID09IFwiVmlkZW9SZXNvdXJjZVwiKSB7XHJcbiAgICAgICAgICAgIHNvdXJjZSA9IHNvdXJjZS5zb3VyY2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGVsc2UgaWYoc291cmNlLmNvbnN0cnVjdG9yWyduYW1lJ10gPT0gXCJHcmFkaWVudFJlc291cmNlXCIpXHJcbiAgICAgICAgLy8ge1xyXG4gICAgICAgIC8vICAgICBpZighc291cmNlLnNvdXJjZSlcclxuICAgICAgICAvLyAgICAge1xyXG4gICAgICAgIC8vICAgICAgICAgcmV0dXJuXHJcbiAgICAgICAgLy8gICAgIH1cclxuICAgICAgICAvLyAgICAgc291cmNlID0gc291cmNlLnNvdXJjZVxyXG4gICAgICAgIC8vICAgICByZXZlYWwoc291cmNlKVxyXG4gICAgICAgIC8vIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgTG9nZ2VyXzEucmV2ZWFsKHNvdXJjZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGdsLnBpeGVsU3RvcmVpKGdsLlVOUEFDS19QUkVNVUxUSVBMWV9BTFBIQV9XRUJHTCwgYmFzZVRleHR1cmUucHJlbXVsdGlwbHlBbHBoYSk7XHJcbiAgICAgICAgaWYgKGJhc2VUZXh0dXJlLnRhcmdldCA9PT0gZ2wuVEVYVFVSRV8yRCAmJiBnbFRleHR1cmUud2lkdGggPT09IHdpZHRoICYmIGdsVGV4dHVyZS5oZWlnaHQgPT09IGhlaWdodCkge1xyXG4gICAgICAgICAgICBnbC50ZXhTdWJJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIDAsIDAsIGJhc2VUZXh0dXJlLmZvcm1hdCwgYmFzZVRleHR1cmUudHlwZSwgc291cmNlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGdsVGV4dHVyZS53aWR0aCA9IHdpZHRoO1xyXG4gICAgICAgICAgICBnbFRleHR1cmUuaGVpZ2h0ID0gaGVpZ2h0O1xyXG4gICAgICAgICAgICBnbC50ZXhJbWFnZTJEKGJhc2VUZXh0dXJlLnRhcmdldCwgMCwgYmFzZVRleHR1cmUuZm9ybWF0LCBiYXNlVGV4dHVyZS5mb3JtYXQsIGJhc2VUZXh0dXJlLnR5cGUsIHNvdXJjZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBEZWxldGVzIHRoZSB0ZXh0dXJlIGZyb20gV2ViR0xcclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtQSVhJLkJhc2VUZXh0dXJlfFBJWEkuVGV4dHVyZX0gdGV4dHVyZSAtIHRoZSB0ZXh0dXJlIHRvIGRlc3Ryb3lcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3NraXBSZW1vdmU9ZmFsc2VdIC0gV2hldGhlciB0byBza2lwIHJlbW92aW5nIHRoZSB0ZXh0dXJlIGZyb20gdGhlIFRleHR1cmVNYW5hZ2VyLlxyXG4gICAgICovXHJcbiAgICBkZXN0cm95VGV4dHVyZSh0ZXh0dXJlLCBza2lwUmVtb3ZlID0gZmFsc2UpIHtcclxuICAgICAgICB2YXIgcmVmID0gdGhpcztcclxuICAgICAgICB2YXIgZ2wgPSByZWYuZ2w7XHJcbiAgICAgICAgdGV4dHVyZSA9IHRleHR1cmUuYmFzZVRleHR1cmUgfHwgdGV4dHVyZTtcclxuICAgICAgICBpZiAodGV4dHVyZS5fZ2xUZXh0dXJlc1t0aGlzLnJlbmRlcmVyLkNPTlRFWFRfVUlEXSkge1xyXG4gICAgICAgICAgICB0aGlzLnVuYmluZCh0ZXh0dXJlKTtcclxuICAgICAgICAgICAgZ2wuZGVsZXRlVGV4dHVyZSh0ZXh0dXJlLl9nbFRleHR1cmVzW3RoaXMucmVuZGVyZXIuQ09OVEVYVF9VSURdLnRleHR1cmUpO1xyXG4gICAgICAgICAgICAvLyB0ZXh0dXJlLm9mZignZGlzcG9zZScsIHRoaXMuZGVzdHJveVRleHR1cmUsIHRoaXMpO1xyXG4gICAgICAgICAgICBkZWxldGUgdGV4dHVyZS5fZ2xUZXh0dXJlc1t0aGlzLnJlbmRlcmVyLkNPTlRFWFRfVUlEXTtcclxuICAgICAgICAgICAgaWYgKCFza2lwUmVtb3ZlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaSA9IHRoaXMubWFuYWdlZFRleHR1cmVzLmluZGV4T2YodGV4dHVyZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaSAhPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICBVdGlsc1NldHRpbmdzXzEuVXRpbHNTZXR0aW5ncy5yZW1vdmVJdGVtcyh0aGlzLm1hbmFnZWRUZXh0dXJlcywgaSwgMSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZSB0ZXh0dXJlIHN0eWxlIHN1Y2ggYXMgbWlwbWFwIGZsYWdcclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHBhcmFtIHtQSVhJLkJhc2VUZXh0dXJlfSB0ZXh0dXJlIC0gVGV4dHVyZSB0byB1cGRhdGVcclxuICAgICAqL1xyXG4gICAgdXBkYXRlVGV4dHVyZVN0eWxlKHRleHR1cmUpIHtcclxuICAgICAgICB2YXIgZ2xUZXh0dXJlID0gdGV4dHVyZS5fZ2xUZXh0dXJlc1t0aGlzLkNPTlRFWFRfVUlEXTtcclxuICAgICAgICBpZiAoIWdsVGV4dHVyZSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICgodGV4dHVyZS5taXBtYXAgPT09IFdlYkdMU2V0dGluZ3NfMS5XZWJHTFNldHRpbmdzLk1JUE1BUF9NT0RFUy5QT1cyIHx8IHRoaXMud2ViR0xWZXJzaW9uICE9PSAyKSAmJiAhdGV4dHVyZS5pc1Bvd2VyT2ZUd28pIHtcclxuICAgICAgICAgICAgZ2xUZXh0dXJlLm1pcG1hcCA9IDA7XHJcbiAgICAgICAgICAgIGdsVGV4dHVyZS53cmFwTW9kZSA9IFdlYkdMU2V0dGluZ3NfMS5XZWJHTFNldHRpbmdzLldSQVBfTU9ERVMuQ0xBTVA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBnbFRleHR1cmUubWlwbWFwID0gdGV4dHVyZS5taXBtYXAgPj0gMTtcclxuICAgICAgICAgICAgZ2xUZXh0dXJlLndyYXBNb2RlID0gdGV4dHVyZS53cmFwTW9kZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gaWYgKHRleHR1cmUucmVzb3VyY2UgJiYgdGV4dHVyZS5yZXNvdXJjZS5zdHlsZSh0aGlzLnJlbmRlcmVyLCB0ZXh0dXJlLCBnbFRleHR1cmUpKVxyXG4gICAgICAgIC8vIHsgOyB9XHJcbiAgICAgICAgLy8gZWxzZVxyXG4gICAgICAgIC8vIHtcclxuICAgICAgICB0aGlzLnNldFN0eWxlKHRleHR1cmUsIGdsVGV4dHVyZSk7XHJcbiAgICAgICAgLy8gfVxyXG4gICAgICAgIGdsVGV4dHVyZS5kaXJ0eVN0eWxlSWQgPSB0ZXh0dXJlLmRpcnR5U3R5bGVJZDtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogU2V0IHN0eWxlIGZvciB0ZXh0dXJlXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7UElYSS5CYXNlVGV4dHVyZX0gdGV4dHVyZSAtIFRleHR1cmUgdG8gdXBkYXRlXHJcbiAgICAgKiBAcGFyYW0ge2dsVGV4dHVyZX0gZ2xUZXh0dXJlXHJcbiAgICAgKi9cclxuICAgIHNldFN0eWxlKHRleHR1cmUsIGdsVGV4dHVyZSkge1xyXG4gICAgICAgIHZhciBnbCA9IHRoaXMuZ2w7XHJcbiAgICAgICAgaWYgKGdsVGV4dHVyZS5taXBtYXApIHtcclxuICAgICAgICAgICAgZ2wuZ2VuZXJhdGVNaXBtYXAodGV4dHVyZS50YXJnZXQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKHRleHR1cmUudGFyZ2V0LCBnbC5URVhUVVJFX1dSQVBfUywgZ2xUZXh0dXJlLndyYXBNb2RlKTtcclxuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKHRleHR1cmUudGFyZ2V0LCBnbC5URVhUVVJFX1dSQVBfVCwgZ2xUZXh0dXJlLndyYXBNb2RlKTtcclxuICAgICAgICBpZiAoZ2xUZXh0dXJlLm1pcG1hcCkge1xyXG4gICAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXHJcbiAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkodGV4dHVyZS50YXJnZXQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgdGV4dHVyZS5zY2FsZU1vZGUgPyBnbC5MSU5FQVJfTUlQTUFQX0xJTkVBUiA6IGdsLk5FQVJFU1RfTUlQTUFQX05FQVJFU1QpO1xyXG4gICAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKHRleHR1cmUudGFyZ2V0LCBnbC5URVhUVVJFX01JTl9GSUxURVIsIHRleHR1cmUuc2NhbGVNb2RlID8gZ2wuTElORUFSIDogZ2wuTkVBUkVTVCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkodGV4dHVyZS50YXJnZXQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgdGV4dHVyZS5zY2FsZU1vZGUgPyBnbC5MSU5FQVIgOiBnbC5ORUFSRVNUKTtcclxuICAgIH1cclxuICAgIDtcclxufVxyXG5leHBvcnRzLlRleHR1cmVTeXN0ZW0gPSBUZXh0dXJlU3lzdGVtO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBHcm91cEQ4XzEgPSByZXF1aXJlKFwiLi9Hcm91cEQ4XCIpO1xyXG5jbGFzcyBUZXh0dXJlVXZzIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMueDAgPSAwO1xyXG4gICAgICAgIHRoaXMueTAgPSAwO1xyXG4gICAgICAgIHRoaXMueDEgPSAxO1xyXG4gICAgICAgIHRoaXMueTEgPSAwO1xyXG4gICAgICAgIHRoaXMueDIgPSAxO1xyXG4gICAgICAgIHRoaXMueTIgPSAxO1xyXG4gICAgICAgIHRoaXMueDMgPSAwO1xyXG4gICAgICAgIHRoaXMueTMgPSAxO1xyXG4gICAgICAgIHRoaXMudXZzRmxvYXQzMiA9IG5ldyBGbG9hdDMyQXJyYXkoOCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICogU2V0cyB0aGUgdGV4dHVyZSBVdnMgYmFzZWQgb24gdGhlIGdpdmVuIGZyYW1lIGluZm9ybWF0aW9uLlxyXG4gKlxyXG4gKiBAcHJvdGVjdGVkXHJcbiAqIEBwYXJhbSB7UElYSS5SZWN0YW5nbGV9IGZyYW1lIC0gVGhlIGZyYW1lIG9mIHRoZSB0ZXh0dXJlXHJcbiAqIEBwYXJhbSB7UElYSS5SZWN0YW5nbGV9IGJhc2VGcmFtZSAtIFRoZSBiYXNlIGZyYW1lIG9mIHRoZSB0ZXh0dXJlXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSByb3RhdGUgLSBSb3RhdGlvbiBvZiBmcmFtZSwgc2VlIHtAbGluayBQSVhJLkdyb3VwRDh9XHJcbiAqL1xyXG4gICAgc2V0KGZyYW1lLCBiYXNlRnJhbWUsIHJvdGF0ZSkge1xyXG4gICAgICAgIHZhciB0dyA9IGJhc2VGcmFtZS53aWR0aDtcclxuICAgICAgICB2YXIgdGggPSBiYXNlRnJhbWUuaGVpZ2h0O1xyXG4gICAgICAgIGlmIChyb3RhdGUpIHtcclxuICAgICAgICAgICAgLy8gd2lkdGggYW5kIGhlaWdodCBkaXYgMiBkaXYgYmFzZUZyYW1lIHNpemVcclxuICAgICAgICAgICAgdmFyIHcyID0gZnJhbWUud2lkdGggLyAyIC8gdHc7XHJcbiAgICAgICAgICAgIHZhciBoMiA9IGZyYW1lLmhlaWdodCAvIDIgLyB0aDtcclxuICAgICAgICAgICAgLy8gY29vcmRpbmF0ZXMgb2YgY2VudGVyXHJcbiAgICAgICAgICAgIHZhciBjWCA9IChmcmFtZS54IC8gdHcpICsgdzI7XHJcbiAgICAgICAgICAgIHZhciBjWSA9IChmcmFtZS55IC8gdGgpICsgaDI7XHJcbiAgICAgICAgICAgIHJvdGF0ZSA9IEdyb3VwRDhfMS5Hcm91cEQ4LmFkZChyb3RhdGUsIEdyb3VwRDhfMS5Hcm91cEQ4Lk5XKTsgLy8gTlcgaXMgdG9wLWxlZnQgY29ybmVyXHJcbiAgICAgICAgICAgIHRoaXMueDAgPSBjWCArICh3MiAqIEdyb3VwRDhfMS5Hcm91cEQ4LnVYKHJvdGF0ZSkpO1xyXG4gICAgICAgICAgICB0aGlzLnkwID0gY1kgKyAoaDIgKiBHcm91cEQ4XzEuR3JvdXBEOC51WShyb3RhdGUpKTtcclxuICAgICAgICAgICAgcm90YXRlID0gR3JvdXBEOF8xLkdyb3VwRDguYWRkKHJvdGF0ZSwgMik7IC8vIHJvdGF0ZSA5MCBkZWdyZWVzIGNsb2Nrd2lzZVxyXG4gICAgICAgICAgICB0aGlzLngxID0gY1ggKyAodzIgKiBHcm91cEQ4XzEuR3JvdXBEOC51WChyb3RhdGUpKTtcclxuICAgICAgICAgICAgdGhpcy55MSA9IGNZICsgKGgyICogR3JvdXBEOF8xLkdyb3VwRDgudVkocm90YXRlKSk7XHJcbiAgICAgICAgICAgIHJvdGF0ZSA9IEdyb3VwRDhfMS5Hcm91cEQ4LmFkZChyb3RhdGUsIDIpO1xyXG4gICAgICAgICAgICB0aGlzLngyID0gY1ggKyAodzIgKiBHcm91cEQ4XzEuR3JvdXBEOC51WChyb3RhdGUpKTtcclxuICAgICAgICAgICAgdGhpcy55MiA9IGNZICsgKGgyICogR3JvdXBEOF8xLkdyb3VwRDgudVkocm90YXRlKSk7XHJcbiAgICAgICAgICAgIHJvdGF0ZSA9IEdyb3VwRDhfMS5Hcm91cEQ4LmFkZChyb3RhdGUsIDIpO1xyXG4gICAgICAgICAgICB0aGlzLngzID0gY1ggKyAodzIgKiBHcm91cEQ4XzEuR3JvdXBEOC51WChyb3RhdGUpKTtcclxuICAgICAgICAgICAgdGhpcy55MyA9IGNZICsgKGgyICogR3JvdXBEOF8xLkdyb3VwRDgudVkocm90YXRlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLngwID0gZnJhbWUueCAvIHR3O1xyXG4gICAgICAgICAgICB0aGlzLnkwID0gZnJhbWUueSAvIHRoO1xyXG4gICAgICAgICAgICB0aGlzLngxID0gKGZyYW1lLnggKyBmcmFtZS53aWR0aCkgLyB0dztcclxuICAgICAgICAgICAgdGhpcy55MSA9IGZyYW1lLnkgLyB0aDtcclxuICAgICAgICAgICAgdGhpcy54MiA9IChmcmFtZS54ICsgZnJhbWUud2lkdGgpIC8gdHc7XHJcbiAgICAgICAgICAgIHRoaXMueTIgPSAoZnJhbWUueSArIGZyYW1lLmhlaWdodCkgLyB0aDtcclxuICAgICAgICAgICAgdGhpcy54MyA9IGZyYW1lLnggLyB0dztcclxuICAgICAgICAgICAgdGhpcy55MyA9IChmcmFtZS55ICsgZnJhbWUuaGVpZ2h0KSAvIHRoO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnV2c0Zsb2F0MzJbMF0gPSB0aGlzLngwO1xyXG4gICAgICAgIHRoaXMudXZzRmxvYXQzMlsxXSA9IHRoaXMueTA7XHJcbiAgICAgICAgdGhpcy51dnNGbG9hdDMyWzJdID0gdGhpcy54MTtcclxuICAgICAgICB0aGlzLnV2c0Zsb2F0MzJbM10gPSB0aGlzLnkxO1xyXG4gICAgICAgIHRoaXMudXZzRmxvYXQzMls0XSA9IHRoaXMueDI7XHJcbiAgICAgICAgdGhpcy51dnNGbG9hdDMyWzVdID0gdGhpcy55MjtcclxuICAgICAgICB0aGlzLnV2c0Zsb2F0MzJbNl0gPSB0aGlzLngzO1xyXG4gICAgICAgIHRoaXMudXZzRmxvYXQzMls3XSA9IHRoaXMueTM7XHJcbiAgICB9XHJcbiAgICA7XHJcbn1cclxuZXhwb3J0cy5UZXh0dXJlVXZzID0gVGV4dHVyZVV2cztcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgRXZlbnREaXNwYXRjaGVyXzEgPSByZXF1aXJlKFwiLi9FdmVudERpc3BhdGNoZXJcIik7XHJcbmNvbnN0IFRpY2tlckxpc3RlbmVyXzEgPSByZXF1aXJlKFwiLi9UaWNrZXJMaXN0ZW5lclwiKTtcclxuY29uc3Qgc2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL3NldHRpbmdzXCIpO1xyXG5jbGFzcyBUaWNrZXIgZXh0ZW5kcyBFdmVudERpc3BhdGNoZXJfMS5FdmVudERpc3BhdGNoZXIge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB2YXIgdGhpcyQxID0gdGhpcztcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgZmlyc3QgbGlzdGVuZXIuIEFsbCBuZXcgbGlzdGVuZXJzIGFkZGVkIGFyZSBjaGFpbmVkIG9uIHRoaXMuXHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKiBAdHlwZSB7VGlja2VyTGlzdGVuZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5faGVhZCA9IG5ldyBUaWNrZXJMaXN0ZW5lcl8xLlRpY2tlckxpc3RlbmVyKG51bGwsIG51bGwsIEluZmluaXR5KTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJbnRlcm5hbCBjdXJyZW50IGZyYW1lIHJlcXVlc3QgSURcclxuICAgICAgICAgKiBAdHlwZSB7P251bWJlcn1cclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuX3JlcXVlc3RJZCA9IG51bGw7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSW50ZXJuYWwgdmFsdWUgbWFuYWdlZCBieSBtaW5GUFMgcHJvcGVydHkgc2V0dGVyIGFuZCBnZXR0ZXIuXHJcbiAgICAgICAgICogVGhpcyBpcyB0aGUgbWF4aW11bSBhbGxvd2VkIG1pbGxpc2Vjb25kcyBiZXR3ZWVuIHVwZGF0ZXMuXHJcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuX21heEVsYXBzZWRNUyA9IDEwMDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJbnRlcm5hbCB2YWx1ZSBtYW5hZ2VkIGJ5IG1heEZQUyBwcm9wZXJ0eSBzZXR0ZXIgYW5kIGdldHRlci5cclxuICAgICAgICAgKiBUaGlzIGlzIHRoZSBtaW5pbXVtIGFsbG93ZWQgbWlsbGlzZWNvbmRzIGJldHdlZW4gdXBkYXRlcy5cclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuX21pbkVsYXBzZWRNUyA9IDA7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogV2hldGhlciBvciBub3QgdGhpcyB0aWNrZXIgc2hvdWxkIGludm9rZSB0aGUgbWV0aG9kXHJcbiAgICAgICAgICoge0BsaW5rIFBJWEkuVGlja2VyI3N0YXJ0fSBhdXRvbWF0aWNhbGx5XHJcbiAgICAgICAgICogd2hlbiBhIGxpc3RlbmVyIGlzIGFkZGVkLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQG1lbWJlciB7Ym9vbGVhbn1cclxuICAgICAgICAgKiBAZGVmYXVsdCBmYWxzZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuYXV0b1N0YXJ0ID0gZmFsc2U7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2NhbGFyIHRpbWUgdmFsdWUgZnJvbSBsYXN0IGZyYW1lIHRvIHRoaXMgZnJhbWUuXHJcbiAgICAgICAgICogVGhpcyB2YWx1ZSBpcyBjYXBwZWQgYnkgc2V0dGluZyB7QGxpbmsgUElYSS5UaWNrZXIjbWluRlBTfVxyXG4gICAgICAgICAqIGFuZCBpcyBzY2FsZWQgd2l0aCB7QGxpbmsgUElYSS5UaWNrZXIjc3BlZWR9LlxyXG4gICAgICAgICAqICoqTm90ZToqKiBUaGUgY2FwIG1heSBiZSBleGNlZWRlZCBieSBzY2FsaW5nLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICAgICAqIEBkZWZhdWx0IDFcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmRlbHRhVGltZSA9IDE7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2NhbGVyIHRpbWUgZWxhcHNlZCBpbiBtaWxsaXNlY29uZHMgZnJvbSBsYXN0IGZyYW1lIHRvIHRoaXMgZnJhbWUuXHJcbiAgICAgICAgICogVGhpcyB2YWx1ZSBpcyBjYXBwZWQgYnkgc2V0dGluZyB7QGxpbmsgUElYSS5UaWNrZXIjbWluRlBTfVxyXG4gICAgICAgICAqIGFuZCBpcyBzY2FsZWQgd2l0aCB7QGxpbmsgUElYSS5UaWNrZXIjc3BlZWR9LlxyXG4gICAgICAgICAqICoqTm90ZToqKiBUaGUgY2FwIG1heSBiZSBleGNlZWRlZCBieSBzY2FsaW5nLlxyXG4gICAgICAgICAqIElmIHRoZSBwbGF0Zm9ybSBzdXBwb3J0cyBET01IaWdoUmVzVGltZVN0YW1wLFxyXG4gICAgICAgICAqIHRoaXMgdmFsdWUgd2lsbCBoYXZlIGEgcHJlY2lzaW9uIG9mIDEgwrVzLlxyXG4gICAgICAgICAqIERlZmF1bHRzIHRvIHRhcmdldCBmcmFtZSB0aW1lXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgICAgICogQGRlZmF1bHQgMTYuNjZcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmRlbHRhTVMgPSAxIC8gc2V0dGluZ3NfMS5zZXR0aW5ncy5UQVJHRVRfRlBNUztcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaW1lIGVsYXBzZWQgaW4gbWlsbGlzZWNvbmRzIGZyb20gbGFzdCBmcmFtZSB0byB0aGlzIGZyYW1lLlxyXG4gICAgICAgICAqIE9wcG9zZWQgdG8gd2hhdCB0aGUgc2NhbGFyIHtAbGluayBQSVhJLlRpY2tlciNkZWx0YVRpbWV9XHJcbiAgICAgICAgICogaXMgYmFzZWQsIHRoaXMgdmFsdWUgaXMgbmVpdGhlciBjYXBwZWQgbm9yIHNjYWxlZC5cclxuICAgICAgICAgKiBJZiB0aGUgcGxhdGZvcm0gc3VwcG9ydHMgRE9NSGlnaFJlc1RpbWVTdGFtcCxcclxuICAgICAgICAgKiB0aGlzIHZhbHVlIHdpbGwgaGF2ZSBhIHByZWNpc2lvbiBvZiAxIMK1cy5cclxuICAgICAgICAgKiBEZWZhdWx0cyB0byB0YXJnZXQgZnJhbWUgdGltZVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICAgICAqIEBkZWZhdWx0IDE2LjY2XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5lbGFwc2VkTVMgPSAxIC8gc2V0dGluZ3NfMS5zZXR0aW5ncy5UQVJHRVRfRlBNUztcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgbGFzdCB0aW1lIHtAbGluayBQSVhJLlRpY2tlciN1cGRhdGV9IHdhcyBpbnZva2VkLlxyXG4gICAgICAgICAqIFRoaXMgdmFsdWUgaXMgYWxzbyByZXNldCBpbnRlcm5hbGx5IG91dHNpZGUgb2YgaW52b2tpbmdcclxuICAgICAgICAgKiB1cGRhdGUsIGJ1dCBvbmx5IHdoZW4gYSBuZXcgYW5pbWF0aW9uIGZyYW1lIGlzIHJlcXVlc3RlZC5cclxuICAgICAgICAgKiBJZiB0aGUgcGxhdGZvcm0gc3VwcG9ydHMgRE9NSGlnaFJlc1RpbWVTdGFtcCxcclxuICAgICAgICAgKiB0aGlzIHZhbHVlIHdpbGwgaGF2ZSBhIHByZWNpc2lvbiBvZiAxIMK1cy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAgICAgKiBAZGVmYXVsdCAtMVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMubGFzdFRpbWUgPSAtMTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBGYWN0b3Igb2YgY3VycmVudCB7QGxpbmsgUElYSS5UaWNrZXIjZGVsdGFUaW1lfS5cclxuICAgICAgICAgKiBAZXhhbXBsZVxyXG4gICAgICAgICAqIC8vIFNjYWxlcyB0aWNrZXIuZGVsdGFUaW1lIHRvIHdoYXQgd291bGQgYmVcclxuICAgICAgICAgKiAvLyB0aGUgZXF1aXZhbGVudCBvZiBhcHByb3hpbWF0ZWx5IDEyMCBGUFNcclxuICAgICAgICAgKiB0aWNrZXIuc3BlZWQgPSAyO1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxyXG4gICAgICAgICAqIEBkZWZhdWx0IDFcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnNwZWVkID0gMTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBXaGV0aGVyIG9yIG5vdCB0aGlzIHRpY2tlciBoYXMgYmVlbiBzdGFydGVkLlxyXG4gICAgICAgICAqIGB0cnVlYCBpZiB7QGxpbmsgUElYSS5UaWNrZXIjc3RhcnR9IGhhcyBiZWVuIGNhbGxlZC5cclxuICAgICAgICAgKiBgZmFsc2VgIGlmIHtAbGluayBQSVhJLlRpY2tlciNzdG9wfSBoYXMgYmVlbiBjYWxsZWQuXHJcbiAgICAgICAgICogV2hpbGUgYGZhbHNlYCwgdGhpcyB2YWx1ZSBtYXkgY2hhbmdlIHRvIGB0cnVlYCBpbiB0aGVcclxuICAgICAgICAgKiBldmVudCBvZiB7QGxpbmsgUElYSS5UaWNrZXIjYXV0b1N0YXJ0fSBiZWluZyBgdHJ1ZWBcclxuICAgICAgICAgKiBhbmQgYSBsaXN0ZW5lciBpcyBhZGRlZC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XHJcbiAgICAgICAgICogQGRlZmF1bHQgZmFsc2VcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnN0YXJ0ZWQgPSBmYWxzZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJZiBlbmFibGVkLCBkZWxldGluZyBpcyBkaXNhYmxlZC5cclxuICAgICAgICAgKiBAbWVtYmVyIHtib29sZWFufVxyXG4gICAgICAgICAqIEBkZWZhdWx0IGZhbHNlXHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLl9wcm90ZWN0ZWQgPSBmYWxzZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJbnRlcm5hbCB0aWNrIG1ldGhvZCBib3VuZCB0byB0aWNrZXIgaW5zdGFuY2UuXHJcbiAgICAgICAgICogVGhpcyBpcyBiZWNhdXNlIGluIGVhcmx5IDIwMTUsIEZ1bmN0aW9uLmJpbmRcclxuICAgICAgICAgKiBpcyBzdGlsbCA2MCUgc2xvd2VyIGluIGhpZ2ggcGVyZm9ybWFuY2Ugc2NlbmFyaW9zLlxyXG4gICAgICAgICAqIEFsc28gc2VwYXJhdGluZyBmcmFtZSByZXF1ZXN0cyBmcm9tIHVwZGF0ZSBtZXRob2RcclxuICAgICAgICAgKiBzbyBsaXN0ZW5lcnMgbWF5IGJlIGNhbGxlZCBhdCBhbnkgdGltZSBhbmQgd2l0aFxyXG4gICAgICAgICAqIGFueSBhbmltYXRpb24gQVBJLCBqdXN0IGludm9rZSB0aWNrZXIudXBkYXRlKHRpbWUpLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gdGltZSAtIFRpbWUgc2luY2UgbGFzdCB0aWNrLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuX3RpY2sgPSBmdW5jdGlvbiAodGltZSkge1xyXG4gICAgICAgICAgICB0aGlzJDEuX3JlcXVlc3RJZCA9IG51bGw7XHJcbiAgICAgICAgICAgIGlmICh0aGlzJDEuc3RhcnRlZCkge1xyXG4gICAgICAgICAgICAgICAgLy8gSW52b2tlIGxpc3RlbmVycyBub3dcclxuICAgICAgICAgICAgICAgIHRoaXMkMS51cGRhdGUodGltZSk7XHJcbiAgICAgICAgICAgICAgICAvLyBMaXN0ZW5lciBzaWRlIGVmZmVjdHMgbWF5IGhhdmUgbW9kaWZpZWQgdGlja2VyIHN0YXRlLlxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMkMS5zdGFydGVkICYmIHRoaXMkMS5fcmVxdWVzdElkID09PSBudWxsICYmIHRoaXMkMS5faGVhZC5uZXh0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcyQxLl9yZXF1ZXN0SWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcyQxLl90aWNrKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEludGVybmFsbHkgYWRkcyB0aGUgZXZlbnQgaGFuZGxlciBzbyB0aGF0IGl0IGNhbiBiZSBzb3J0ZWQgYnkgcHJpb3JpdHkuXHJcbiAgICAgKiBQcmlvcml0eSBhbGxvd3MgY2VydGFpbiBoYW5kbGVyICh1c2VyLCBBbmltYXRlZFNwcml0ZSwgSW50ZXJhY3Rpb24pIHRvIGJlIHJ1blxyXG4gICAgICogYmVmb3JlIHRoZSByZW5kZXJpbmcuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7VGlja2VyTGlzdGVuZXJ9IGxpc3RlbmVyIC0gQ3VycmVudCBsaXN0ZW5lciBiZWluZyBhZGRlZC5cclxuICAgICAqIEByZXR1cm5zIHtQSVhJLlRpY2tlcn0gVGhpcyBpbnN0YW5jZSBvZiBhIHRpY2tlclxyXG4gICAgICovXHJcbiAgICBfYWRkTGlzdGVuZXIobGlzdGVuZXIpIHtcclxuICAgICAgICAvLyBGb3IgYXR0YWNoaW5nIHRvIGhlYWRcclxuICAgICAgICB2YXIgY3VycmVudCA9IHRoaXMuX2hlYWQubmV4dDtcclxuICAgICAgICB2YXIgcHJldmlvdXMgPSB0aGlzLl9oZWFkO1xyXG4gICAgICAgIC8vIEFkZCB0aGUgZmlyc3QgaXRlbVxyXG4gICAgICAgIGlmICghY3VycmVudCkge1xyXG4gICAgICAgICAgICBsaXN0ZW5lci5jb25uZWN0KHByZXZpb3VzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIEdvIGZyb20gaGlnaGVzdCB0byBsb3dlc3QgcHJpb3JpdHlcclxuICAgICAgICAgICAgd2hpbGUgKGN1cnJlbnQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChsaXN0ZW5lci5wcmlvcml0eSA+IGN1cnJlbnQucHJpb3JpdHkpIHtcclxuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lci5jb25uZWN0KHByZXZpb3VzKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHByZXZpb3VzID0gY3VycmVudDtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gTm90IHlldCBjb25uZWN0ZWRcclxuICAgICAgICAgICAgaWYgKCFsaXN0ZW5lci5wcmV2aW91cykge1xyXG4gICAgICAgICAgICAgICAgbGlzdGVuZXIuY29ubmVjdChwcmV2aW91cyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fc3RhcnRJZlBvc3NpYmxlKCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFRyaWdnZXJzIGFuIHVwZGF0ZS4gQW4gdXBkYXRlIGVudGFpbHMgc2V0dGluZyB0aGVcclxuICAgICAqIGN1cnJlbnQge0BsaW5rIFBJWEkuVGlja2VyI2VsYXBzZWRNU30sXHJcbiAgICAgKiB0aGUgY3VycmVudCB7QGxpbmsgUElYSS5UaWNrZXIjZGVsdGFUaW1lfSxcclxuICAgICAqIGludm9raW5nIGFsbCBsaXN0ZW5lcnMgd2l0aCBjdXJyZW50IGRlbHRhVGltZSxcclxuICAgICAqIGFuZCB0aGVuIGZpbmFsbHkgc2V0dGluZyB7QGxpbmsgUElYSS5UaWNrZXIjbGFzdFRpbWV9XHJcbiAgICAgKiB3aXRoIHRoZSB2YWx1ZSBvZiBjdXJyZW50VGltZSB0aGF0IHdhcyBwcm92aWRlZC5cclxuICAgICAqIFRoaXMgbWV0aG9kIHdpbGwgYmUgY2FsbGVkIGF1dG9tYXRpY2FsbHkgYnkgYW5pbWF0aW9uXHJcbiAgICAgKiBmcmFtZSBjYWxsYmFja3MgaWYgdGhlIHRpY2tlciBpbnN0YW5jZSBoYXMgYmVlbiBzdGFydGVkXHJcbiAgICAgKiBhbmQgbGlzdGVuZXJzIGFyZSBhZGRlZC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2N1cnJlbnRUaW1lPXBlcmZvcm1hbmNlLm5vdygpXSAtIHRoZSBjdXJyZW50IHRpbWUgb2YgZXhlY3V0aW9uXHJcbiAgICAgKi9cclxuICAgIHVwZGF0ZShjdXJyZW50VGltZSkge1xyXG4gICAgICAgIGlmIChjdXJyZW50VGltZSA9PT0gdm9pZCAwKSB7XHJcbiAgICAgICAgICAgIGN1cnJlbnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBlbGFwc2VkTVM7XHJcbiAgICAgICAgLy8gSWYgdGhlIGRpZmZlcmVuY2UgaW4gdGltZSBpcyB6ZXJvIG9yIG5lZ2F0aXZlLCB3ZSBpZ25vcmUgbW9zdCBvZiB0aGUgd29yayBkb25lIGhlcmUuXHJcbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gdmFsaWQgZGlmZmVyZW5jZSwgdGhlbiBzaG91bGQgYmUgbm8gcmVhc29uIHRvIGxldCBhbnlvbmUga25vdyBhYm91dCBpdC5cclxuICAgICAgICAvLyBBIHplcm8gZGVsdGEsIGlzIGV4YWN0bHkgdGhhdCwgbm90aGluZyBzaG91bGQgdXBkYXRlLlxyXG4gICAgICAgIC8vXHJcbiAgICAgICAgLy8gVGhlIGRpZmZlcmVuY2UgaW4gdGltZSBjYW4gYmUgbmVnYXRpdmUsIGFuZCBubyB0aGlzIGRvZXMgbm90IG1lYW4gdGltZSB0cmF2ZWxpbmcuXHJcbiAgICAgICAgLy8gVGhpcyBjYW4gYmUgdGhlIHJlc3VsdCBvZiBhIHJhY2UgY29uZGl0aW9uIGJldHdlZW4gd2hlbiBhbiBhbmltYXRpb24gZnJhbWUgaXMgcmVxdWVzdGVkXHJcbiAgICAgICAgLy8gb24gdGhlIGN1cnJlbnQgSmF2YVNjcmlwdCBlbmdpbmUgZXZlbnQgbG9vcCwgYW5kIHdoZW4gdGhlIHRpY2tlcidzIHN0YXJ0IG1ldGhvZCBpcyBpbnZva2VkXHJcbiAgICAgICAgLy8gKHdoaWNoIGludm9rZXMgdGhlIGludGVybmFsIF9yZXF1ZXN0SWZOZWVkZWQgbWV0aG9kKS4gSWYgYSBmcmFtZSBpcyByZXF1ZXN0ZWQgYmVmb3JlXHJcbiAgICAgICAgLy8gX3JlcXVlc3RJZk5lZWRlZCBpcyBpbnZva2VkLCB0aGVuIHRoZSBjYWxsYmFjayBmb3IgdGhlIGFuaW1hdGlvbiBmcmFtZSB0aGUgdGlja2VyIHJlcXVlc3RzLFxyXG4gICAgICAgIC8vIGNhbiByZWNlaXZlIGEgdGltZSBhcmd1bWVudCB0aGF0IGNhbiBiZSBsZXNzIHRoYW4gdGhlIGxhc3RUaW1lIHZhbHVlIHRoYXQgd2FzIHNldCB3aXRoaW5cclxuICAgICAgICAvLyBfcmVxdWVzdElmTmVlZGVkLiBUaGlzIGRpZmZlcmVuY2UgaXMgaW4gbWljcm9zZWNvbmRzLCBidXQgdGhpcyBpcyBlbm91Z2ggdG8gY2F1c2UgcHJvYmxlbXMuXHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyBUaGlzIGNoZWNrIGNvdmVycyB0aGlzIGJyb3dzZXIgZW5naW5lIHRpbWluZyBpc3N1ZSwgYXMgd2VsbCBhcyBpZiBjb25zdW1lcnMgcGFzcyBhbiBpbnZhbGlkXHJcbiAgICAgICAgLy8gY3VycmVudFRpbWUgdmFsdWUuIFRoaXMgbWF5IGhhcHBlbiBpZiBjb25zdW1lcnMgb3B0LW91dCBvZiB0aGUgYXV0b1N0YXJ0LCBhbmQgdXBkYXRlIHRoZW1zZWx2ZXMuXHJcbiAgICAgICAgaWYgKGN1cnJlbnRUaW1lID4gdGhpcy5sYXN0VGltZSkge1xyXG4gICAgICAgICAgICAvLyBTYXZlIHVuY2FwcGVkIGVsYXBzZWRNUyBmb3IgbWVhc3VyZW1lbnRcclxuICAgICAgICAgICAgZWxhcHNlZE1TID0gdGhpcy5lbGFwc2VkTVMgPSBjdXJyZW50VGltZSAtIHRoaXMubGFzdFRpbWU7XHJcbiAgICAgICAgICAgIC8vIGNhcCB0aGUgbWlsbGlzZWNvbmRzIGVsYXBzZWQgdXNlZCBmb3IgZGVsdGFUaW1lXHJcbiAgICAgICAgICAgIGlmIChlbGFwc2VkTVMgPiB0aGlzLl9tYXhFbGFwc2VkTVMpIHtcclxuICAgICAgICAgICAgICAgIGVsYXBzZWRNUyA9IHRoaXMuX21heEVsYXBzZWRNUztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbGFwc2VkTVMgKj0gdGhpcy5zcGVlZDtcclxuICAgICAgICAgICAgLy8gaWYgbm90IGVub3VnaCB0aW1lIGhhcyBwYXNzZWQsIGV4aXQgdGhlIGZ1bmN0aW9uLlxyXG4gICAgICAgICAgICAvLyBXZSBnaXZlIGFuIGV4dHJhIG1zIHRvIGVsYXBzZWRNUyBmb3IgdGhpcyBjaGVjaywgYmVjYXVzZSB0aGUgbmF0dXJlIG9mXHJcbiAgICAgICAgICAgIC8vIHJlcXVlc3QgYW5pbWF0aW9uIGZyYW1lIG1lYW5zIHRoYXQgbm90IGFsbCBicm93c2VycyB3aWxsIHJldHVybiBwcmVjaXNlIHZhbHVlcy5cclxuICAgICAgICAgICAgLy8gSG93ZXZlciwgYmVjYXVzZSByQUYgd29ya3MgYmFzZWQgb24gdi1zeW5jLCBpdCdzIHdvbid0IGNoYW5nZSB0aGUgZWZmZWN0aXZlIEZQUy5cclxuICAgICAgICAgICAgaWYgKHRoaXMuX21pbkVsYXBzZWRNUyAmJiBlbGFwc2VkTVMgKyAxIDwgdGhpcy5fbWluRWxhcHNlZE1TKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5kZWx0YU1TID0gZWxhcHNlZE1TO1xyXG4gICAgICAgICAgICB0aGlzLmRlbHRhVGltZSA9IHRoaXMuZGVsdGFNUyAqIHNldHRpbmdzXzEuc2V0dGluZ3MuVEFSR0VUX0ZQTVM7XHJcbiAgICAgICAgICAgIC8vIENhY2hlIGEgbG9jYWwgcmVmZXJlbmNlLCBpbi1jYXNlIHRpY2tlciBpcyBkZXN0cm95ZWRcclxuICAgICAgICAgICAgLy8gZHVyaW5nIHRoZSBlbWl0LCB3ZSBjYW4gc3RpbGwgY2hlY2sgZm9yIGhlYWQubmV4dFxyXG4gICAgICAgICAgICB2YXIgaGVhZCA9IHRoaXMuX2hlYWQ7XHJcbiAgICAgICAgICAgIC8vIEludm9rZSBsaXN0ZW5lcnMgYWRkZWQgdG8gaW50ZXJuYWwgZW1pdHRlclxyXG4gICAgICAgICAgICB2YXIgbGlzdGVuZXIgPSBoZWFkLm5leHQ7XHJcbiAgICAgICAgICAgIHdoaWxlIChsaXN0ZW5lcikge1xyXG4gICAgICAgICAgICAgICAgbGlzdGVuZXIgPSBsaXN0ZW5lci5lbWl0KHRoaXMuZGVsdGFUaW1lKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIWhlYWQubmV4dCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fY2FuY2VsSWZOZWVkZWQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5kZWx0YVRpbWUgPSB0aGlzLmRlbHRhTVMgPSB0aGlzLmVsYXBzZWRNUyA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubGFzdFRpbWUgPSBjdXJyZW50VGltZTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogRGVzdHJveSB0aGUgdGlja2VyIGFuZCBkb24ndCB1c2UgYWZ0ZXIgdGhpcy4gQ2FsbGluZ1xyXG4gICAgICogdGhpcyBtZXRob2QgcmVtb3ZlcyBhbGwgcmVmZXJlbmNlcyB0byBpbnRlcm5hbCBldmVudHMuXHJcbiAgICAgKi9cclxuICAgIGRlc3Ryb3koKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9wcm90ZWN0ZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5zdG9wKCk7XHJcbiAgICAgICAgICAgIHZhciBsaXN0ZW5lciA9IHRoaXMuX2hlYWQubmV4dDtcclxuICAgICAgICAgICAgd2hpbGUgKGxpc3RlbmVyKSB7XHJcbiAgICAgICAgICAgICAgICBsaXN0ZW5lciA9IGxpc3RlbmVyLmRlc3Ryb3kodHJ1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5faGVhZC5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2hlYWQgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogU3RvcHMgdGhlIHRpY2tlci4gSWYgdGhlIHRpY2tlciBoYXMgcmVxdWVzdGVkXHJcbiAgICAgKiBhbiBhbmltYXRpb24gZnJhbWUgaXQgaXMgY2FuY2VsZWQgYXQgdGhpcyBwb2ludC5cclxuICAgICAqL1xyXG4gICAgc3RvcCgpIHtcclxuICAgICAgICBpZiAodGhpcy5zdGFydGVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhcnRlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLl9jYW5jZWxJZk5lZWRlZCgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogU3RhcnRzIHRoZSB0aWNrZXIuIElmIHRoZSB0aWNrZXIgaGFzIGxpc3RlbmVyc1xyXG4gICAgICogYSBuZXcgYW5pbWF0aW9uIGZyYW1lIGlzIHJlcXVlc3RlZCBhdCB0aGlzIHBvaW50LlxyXG4gICAgICovXHJcbiAgICBzdGFydCgpIHtcclxuICAgICAgICBpZiAoIXRoaXMuc3RhcnRlZCkge1xyXG4gICAgICAgICAgICB0aGlzLnN0YXJ0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLl9yZXF1ZXN0SWZOZWVkZWQoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgYW55IGhhbmRsZXJzIG1hdGNoaW5nIHRoZSBmdW5jdGlvbiBhbmQgY29udGV4dCBwYXJhbWV0ZXJzLlxyXG4gICAgICogSWYgbm8gaGFuZGxlcnMgYXJlIGxlZnQgYWZ0ZXIgcmVtb3ZpbmcsIHRoZW4gaXQgY2FuY2VscyB0aGUgYW5pbWF0aW9uIGZyYW1lLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIC0gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uIHRvIGJlIHJlbW92ZWRcclxuICAgICAqIEBwYXJhbSB7Kn0gW2NvbnRleHRdIC0gVGhlIGxpc3RlbmVyIGNvbnRleHQgdG8gYmUgcmVtb3ZlZFxyXG4gICAgICogQHJldHVybnMge1BJWEkuVGlja2VyfSBUaGlzIGluc3RhbmNlIG9mIGEgdGlja2VyXHJcbiAgICAgKi9cclxuICAgIHJlbW92ZShmbiwgY29udGV4dCkge1xyXG4gICAgICAgIHZhciBsaXN0ZW5lciA9IHRoaXMuX2hlYWQubmV4dDtcclxuICAgICAgICB3aGlsZSAobGlzdGVuZXIpIHtcclxuICAgICAgICAgICAgLy8gV2UgZm91bmQgYSBtYXRjaCwgbGV0cyByZW1vdmUgaXRcclxuICAgICAgICAgICAgLy8gbm8gYnJlYWsgdG8gZGVsZXRlIGFsbCBwb3NzaWJsZSBtYXRjaGVzXHJcbiAgICAgICAgICAgIC8vIGluY2FzZSBhIGxpc3RlbmVyIHdhcyBhZGRlZCAyKyB0aW1lc1xyXG4gICAgICAgICAgICBpZiAobGlzdGVuZXIubWF0Y2goZm4sIGNvbnRleHQpKSB7XHJcbiAgICAgICAgICAgICAgICBsaXN0ZW5lciA9IGxpc3RlbmVyLmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGxpc3RlbmVyID0gbGlzdGVuZXIubmV4dDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXRoaXMuX2hlYWQubmV4dCkge1xyXG4gICAgICAgICAgICB0aGlzLl9jYW5jZWxJZk5lZWRlZCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogQWRkIGEgaGFuZGxlciBmb3IgdGhlIHRpY2sgZXZlbnQgd2hpY2ggaXMgb25seSBleGVjdXRlIG9uY2UuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gLSBUaGUgbGlzdGVuZXIgZnVuY3Rpb24gdG8gYmUgYWRkZWQgZm9yIG9uZSB1cGRhdGVcclxuICAgICAqIEBwYXJhbSB7Kn0gW2NvbnRleHRdIC0gVGhlIGxpc3RlbmVyIGNvbnRleHRcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcHJpb3JpdHk9UElYSS5VUERBVEVfUFJJT1JJVFkuTk9STUFMXSAtIFRoZSBwcmlvcml0eSBmb3IgZW1pdHRpbmdcclxuICAgICAqIEByZXR1cm5zIHtQSVhJLlRpY2tlcn0gVGhpcyBpbnN0YW5jZSBvZiBhIHRpY2tlclxyXG4gICAgICovXHJcbiAgICBhZGRPbmNlKGZuLCBjb250ZXh0LCBwcmlvcml0eSkge1xyXG4gICAgICAgIGlmIChwcmlvcml0eSA9PT0gdm9pZCAwKSB7XHJcbiAgICAgICAgICAgIHByaW9yaXR5ID0gVGlja2VyLlVQREFURV9QUklPUklUWS5OT1JNQUw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRMaXN0ZW5lcihuZXcgVGlja2VyTGlzdGVuZXJfMS5UaWNrZXJMaXN0ZW5lcihmbiwgY29udGV4dCwgcHJpb3JpdHksIHRydWUpKTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogUmVnaXN0ZXIgYSBoYW5kbGVyIGZvciB0aWNrIGV2ZW50cy4gQ2FsbHMgY29udGludW91c2x5IHVubGVzc1xyXG4gICAgICogaXQgaXMgcmVtb3ZlZCBvciB0aGUgdGlja2VyIGlzIHN0b3BwZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gLSBUaGUgbGlzdGVuZXIgZnVuY3Rpb24gdG8gYmUgYWRkZWQgZm9yIHVwZGF0ZXNcclxuICAgICAqIEBwYXJhbSB7Kn0gW2NvbnRleHRdIC0gVGhlIGxpc3RlbmVyIGNvbnRleHRcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcHJpb3JpdHk9UElYSS5VUERBVEVfUFJJT1JJVFkuTk9STUFMXSAtIFRoZSBwcmlvcml0eSBmb3IgZW1pdHRpbmdcclxuICAgICAqIEByZXR1cm5zIHtQSVhJLlRpY2tlcn0gVGhpcyBpbnN0YW5jZSBvZiBhIHRpY2tlclxyXG4gICAgICovXHJcbiAgICBhZGQoZm4sIGNvbnRleHQgPSBudWxsLCBwcmlvcml0eSA9IG51bGwpIHtcclxuICAgICAgICBpZiAocHJpb3JpdHkgPT09IHZvaWQgMCkge1xyXG4gICAgICAgICAgICBwcmlvcml0eSA9IFRpY2tlci5VUERBVEVfUFJJT1JJVFkuTk9STUFMO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5fYWRkTGlzdGVuZXIobmV3IFRpY2tlckxpc3RlbmVyXzEuVGlja2VyTGlzdGVuZXIoZm4sIGNvbnRleHQsIHByaW9yaXR5KSk7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIENvbmRpdGlvbmFsbHkgcmVxdWVzdHMgYSBuZXcgYW5pbWF0aW9uIGZyYW1lLlxyXG4gICAgICogSWYgdGhlIHRpY2tlciBoYXMgYmVlbiBzdGFydGVkIGl0IGNoZWNrcyBpZiBhIGZyYW1lIGhhcyBub3QgYWxyZWFkeVxyXG4gICAgICogYmVlbiByZXF1ZXN0ZWQsIGFuZCBpZiB0aGUgaW50ZXJuYWwgZW1pdHRlciBoYXMgbGlzdGVuZXJzLiBJZiB0aGVzZVxyXG4gICAgICogY29uZGl0aW9ucyBhcmUgbWV0LCBhIG5ldyBmcmFtZSBpcyByZXF1ZXN0ZWQuIElmIHRoZSB0aWNrZXIgaGFzIG5vdFxyXG4gICAgICogYmVlbiBzdGFydGVkLCBidXQgYXV0b1N0YXJ0IGlzIGB0cnVlYCwgdGhlbiB0aGUgdGlja2VyIHN0YXJ0cyBub3csXHJcbiAgICAgKiBhbmQgY29udGludWVzIHdpdGggdGhlIHByZXZpb3VzIGNvbmRpdGlvbnMgdG8gcmVxdWVzdCBhIG5ldyBmcmFtZS5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBfc3RhcnRJZlBvc3NpYmxlKCkge1xyXG4gICAgICAgIGlmICh0aGlzLnN0YXJ0ZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5fcmVxdWVzdElmTmVlZGVkKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMuYXV0b1N0YXJ0KSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhcnQoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIENvbmRpdGlvbmFsbHkgY2FuY2VscyBhIHBlbmRpbmcgYW5pbWF0aW9uIGZyYW1lLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIF9jYW5jZWxJZk5lZWRlZCgpIHtcclxuICAgICAgICBpZiAodGhpcy5fcmVxdWVzdElkICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuX3JlcXVlc3RJZCk7XHJcbiAgICAgICAgICAgIHRoaXMuX3JlcXVlc3RJZCA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAqIENvbmRpdGlvbmFsbHkgcmVxdWVzdHMgYSBuZXcgYW5pbWF0aW9uIGZyYW1lLlxyXG4gKiBJZiBhIGZyYW1lIGhhcyBub3QgYWxyZWFkeSBiZWVuIHJlcXVlc3RlZCwgYW5kIGlmIHRoZSBpbnRlcm5hbFxyXG4gKiBlbWl0dGVyIGhhcyBsaXN0ZW5lcnMsIGEgbmV3IGZyYW1lIGlzIHJlcXVlc3RlZC5cclxuICpcclxuICogQHByaXZhdGVcclxuICovXHJcbiAgICBfcmVxdWVzdElmTmVlZGVkKCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9yZXF1ZXN0SWQgPT09IG51bGwgJiYgdGhpcy5faGVhZC5uZXh0KSB7XHJcbiAgICAgICAgICAgIC8vIGVuc3VyZSBjYWxsYmFja3MgZ2V0IGNvcnJlY3QgZGVsdGFcclxuICAgICAgICAgICAgdGhpcy5sYXN0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xyXG4gICAgICAgICAgICB0aGlzLl9yZXF1ZXN0SWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5fdGljayk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgZnJhbWVzIHBlciBzZWNvbmQgYXQgd2hpY2ggdGhpcyB0aWNrZXIgaXMgcnVubmluZy5cclxuICAgICAqIFRoZSBkZWZhdWx0IGlzIGFwcHJveGltYXRlbHkgNjAgaW4gbW9zdCBtb2Rlcm4gYnJvd3NlcnMuXHJcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBkb2VzIG5vdCBmYWN0b3IgaW4gdGhlIHZhbHVlIG9mXHJcbiAgICAgKiB7QGxpbmsgUElYSS5UaWNrZXIjc3BlZWR9LCB3aGljaCBpcyBzcGVjaWZpY1xyXG4gICAgICogdG8gc2NhbGluZyB7QGxpbmsgUElYSS5UaWNrZXIjZGVsdGFUaW1lfS5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgKiBAcmVhZG9ubHlcclxuICAgICAqL1xyXG4gICAgZ2V0IEZQUygpIHtcclxuICAgICAgICByZXR1cm4gMTAwMCAvIHRoaXMuZWxhcHNlZE1TO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBNYW5hZ2VzIHRoZSBtYXhpbXVtIGFtb3VudCBvZiBtaWxsaXNlY29uZHMgYWxsb3dlZCB0b1xyXG4gICAgICogZWxhcHNlIGJldHdlZW4gaW52b2tpbmcge0BsaW5rIFBJWEkuVGlja2VyI3VwZGF0ZX0uXHJcbiAgICAgKiBUaGlzIHZhbHVlIGlzIHVzZWQgdG8gY2FwIHtAbGluayBQSVhJLlRpY2tlciNkZWx0YVRpbWV9LFxyXG4gICAgICogYnV0IGRvZXMgbm90IGVmZmVjdCB0aGUgbWVhc3VyZWQgdmFsdWUgb2Yge0BsaW5rIFBJWEkuVGlja2VyI0ZQU30uXHJcbiAgICAgKiBXaGVuIHNldHRpbmcgdGhpcyBwcm9wZXJ0eSBpdCBpcyBjbGFtcGVkIHRvIGEgdmFsdWUgYmV0d2VlblxyXG4gICAgICogYDBgIGFuZCBgUElYSS5zZXR0aW5ncy5UQVJHRVRfRlBNUyAqIDEwMDBgLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAqIEBkZWZhdWx0IDEwXHJcbiAgICAgKi9cclxuICAgIGdldCBtaW5GUFMoKSB7XHJcbiAgICAgICAgcmV0dXJuIDEwMDAgLyB0aGlzLl9tYXhFbGFwc2VkTVM7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICBzZXQgbWluRlBTKGZwcykge1xyXG4gICAgICAgIC8vIE1pbmltdW0gbXVzdCBiZSBiZWxvdyB0aGUgbWF4RlBTXHJcbiAgICAgICAgdmFyIG1pbkZQUyA9IE1hdGgubWluKHRoaXMubWF4RlBTLCBmcHMpO1xyXG4gICAgICAgIC8vIE11c3QgYmUgYXQgbGVhc3QgMCwgYnV0IGJlbG93IDEgLyBzZXR0aW5ncy5UQVJHRVRfRlBNU1xyXG4gICAgICAgIHZhciBtaW5GUE1TID0gTWF0aC5taW4oTWF0aC5tYXgoMCwgbWluRlBTKSAvIDEwMDAsIHNldHRpbmdzXzEuc2V0dGluZ3MuVEFSR0VUX0ZQTVMpO1xyXG4gICAgICAgIHRoaXMuX21heEVsYXBzZWRNUyA9IDEgLyBtaW5GUE1TO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgc2V0IG1heEZQUyhmcHMpIHtcclxuICAgICAgICBpZiAoZnBzIC8gMTAwMCA+PSBzZXR0aW5nc18xLnNldHRpbmdzLlRBUkdFVF9GUE1TKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX21pbkVsYXBzZWRNUyA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBNYXggbXVzdCBiZSBhdCBsZWFzdCB0aGUgbWluRlBTXHJcbiAgICAgICAgICAgIHZhciBtYXhGUFMgPSBNYXRoLm1heCh0aGlzLm1pbkZQUywgZnBzKTtcclxuICAgICAgICAgICAgLy8gTXVzdCBiZSBhdCBsZWFzdCAxLCBidXQgYmVsb3cgMSAvIHNldHRpbmdzLlRBUkdFVF9GUE1TXHJcbiAgICAgICAgICAgIHZhciBtYXhGUE1TID0gTWF0aC5taW4oTWF0aC5tYXgoMSwgbWF4RlBTKSAvIDEwMDAsIHNldHRpbmdzXzEuc2V0dGluZ3MuVEFSR0VUX0ZQTVMpO1xyXG4gICAgICAgICAgICB0aGlzLl9taW5FbGFwc2VkTVMgPSAxIC8gbWF4RlBNUztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICogVGhlIHNoYXJlZCB0aWNrZXIgaW5zdGFuY2UgdXNlZCBieSB7QGxpbmsgUElYSS5BbmltYXRlZFNwcml0ZX0gYW5kIGJ5XHJcbiAqIHtAbGluayBQSVhJLlZpZGVvUmVzb3VyY2V9IHRvIHVwZGF0ZSBhbmltYXRpb24gZnJhbWVzIC8gdmlkZW8gdGV4dHVyZXMuXHJcbiAqXHJcbiAqIEl0IG1heSBhbHNvIGJlIHVzZWQgYnkge0BsaW5rIFBJWEkuQXBwbGljYXRpb259IGlmIGNyZWF0ZWQgd2l0aCB0aGUgYHNoYXJlZFRpY2tlcmAgb3B0aW9uIHByb3BlcnR5IHNldCB0byB0cnVlLlxyXG4gKlxyXG4gKiBUaGUgcHJvcGVydHkge0BsaW5rIFBJWEkuVGlja2VyI2F1dG9TdGFydH0gaXMgc2V0IHRvIGB0cnVlYCBmb3IgdGhpcyBpbnN0YW5jZS5cclxuICogUGxlYXNlIGZvbGxvdyB0aGUgZXhhbXBsZXMgZm9yIHVzYWdlLCBpbmNsdWRpbmcgaG93IHRvIG9wdC1vdXQgb2YgYXV0by1zdGFydGluZyB0aGUgc2hhcmVkIHRpY2tlci5cclxuICpcclxuICogQGV4YW1wbGVcclxuICogbGV0IHRpY2tlciA9IFBJWEkuVGlja2VyLnNoYXJlZDtcclxuICogLy8gU2V0IHRoaXMgdG8gcHJldmVudCBzdGFydGluZyB0aGlzIHRpY2tlciB3aGVuIGxpc3RlbmVycyBhcmUgYWRkZWQuXHJcbiAqIC8vIEJ5IGRlZmF1bHQgdGhpcyBpcyB0cnVlIG9ubHkgZm9yIHRoZSBQSVhJLlRpY2tlci5zaGFyZWQgaW5zdGFuY2UuXHJcbiAqIHRpY2tlci5hdXRvU3RhcnQgPSBmYWxzZTtcclxuICogLy8gRllJLCBjYWxsIHRoaXMgdG8gZW5zdXJlIHRoZSB0aWNrZXIgaXMgc3RvcHBlZC4gSXQgc2hvdWxkIGJlIHN0b3BwZWRcclxuICogLy8gaWYgeW91IGhhdmUgbm90IGF0dGVtcHRlZCB0byByZW5kZXIgYW55dGhpbmcgeWV0LlxyXG4gKiB0aWNrZXIuc3RvcCgpO1xyXG4gKiAvLyBDYWxsIHRoaXMgd2hlbiB5b3UgYXJlIHJlYWR5IGZvciBhIHJ1bm5pbmcgc2hhcmVkIHRpY2tlci5cclxuICogdGlja2VyLnN0YXJ0KCk7XHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIC8vIFlvdSBtYXkgdXNlIHRoZSBzaGFyZWQgdGlja2VyIHRvIHJlbmRlci4uLlxyXG4gKiBsZXQgcmVuZGVyZXIgPSBQSVhJLmF1dG9EZXRlY3RSZW5kZXJlcigpO1xyXG4gKiBsZXQgc3RhZ2UgPSBuZXcgUElYSS5Db250YWluZXIoKTtcclxuICogZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChyZW5kZXJlci52aWV3KTtcclxuICogdGlja2VyLmFkZChmdW5jdGlvbiAodGltZSkge1xyXG4gKiByZW5kZXJlci5yZW5kZXIoc3RhZ2UpO1xyXG4gKiB9KTtcclxuICpcclxuICogQGV4YW1wbGVcclxuICogLy8gT3IgeW91IGNhbiBqdXN0IHVwZGF0ZSBpdCBtYW51YWxseS5cclxuICogdGlja2VyLmF1dG9TdGFydCA9IGZhbHNlO1xyXG4gKiB0aWNrZXIuc3RvcCgpO1xyXG4gKiBmdW5jdGlvbiBhbmltYXRlKHRpbWUpIHtcclxuICogdGlja2VyLnVwZGF0ZSh0aW1lKTtcclxuICogcmVuZGVyZXIucmVuZGVyKHN0YWdlKTtcclxuICogcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGUpO1xyXG4gKiB9XHJcbiAqIGFuaW1hdGUocGVyZm9ybWFuY2Uubm93KCkpO1xyXG4gKlxyXG4gKiBAbWVtYmVyIHtQSVhJLlRpY2tlcn1cclxuICogQHN0YXRpY1xyXG4gKi9cclxuICAgIHN0YXRpYyBnZXQgc2hhcmVkKCkge1xyXG4gICAgICAgIGlmICghVGlja2VyLl9zaGFyZWQpIHtcclxuICAgICAgICAgICAgdmFyIHNoYXJlZCA9IFRpY2tlci5fc2hhcmVkID0gbmV3IFRpY2tlcigpO1xyXG4gICAgICAgICAgICBzaGFyZWQuYXV0b1N0YXJ0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgc2hhcmVkLl9wcm90ZWN0ZWQgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gVGlja2VyLl9zaGFyZWQ7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBzeXN0ZW0gdGlja2VyIGluc3RhbmNlIHVzZWQgYnkge0BsaW5rIFBJWEkuaW50ZXJhY3Rpb24uSW50ZXJhY3Rpb25NYW5hZ2VyfSBhbmQgYnlcclxuICAgICAqIHtAbGluayBQSVhJLkJhc2VQcmVwYXJlfSBmb3IgY29yZSB0aW1pbmcgZnVuY3Rpb25hbGl0eSB0aGF0IHNob3VsZG4ndCB1c3VhbGx5IG5lZWQgdG8gYmUgcGF1c2VkLFxyXG4gICAgICogdW5saWtlIHRoZSBgc2hhcmVkYCB0aWNrZXIgd2hpY2ggZHJpdmVzIHZpc3VhbCBhbmltYXRpb25zIGFuZCByZW5kZXJpbmcgd2hpY2ggbWF5IHdhbnQgdG8gYmUgcGF1c2VkLlxyXG4gICAgICpcclxuICAgICAqIFRoZSBwcm9wZXJ0eSB7QGxpbmsgUElYSS5UaWNrZXIjYXV0b1N0YXJ0fSBpcyBzZXQgdG8gYHRydWVgIGZvciB0aGlzIGluc3RhbmNlLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge1BJWEkuVGlja2VyfVxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZ2V0IHN5c3RlbSgpIHtcclxuICAgICAgICBpZiAoIVRpY2tlci5fc3lzdGVtKSB7XHJcbiAgICAgICAgICAgIHZhciBzeXN0ZW0gPSBUaWNrZXIuX3N5c3RlbSA9IG5ldyBUaWNrZXIoKTtcclxuICAgICAgICAgICAgc3lzdGVtLmF1dG9TdGFydCA9IHRydWU7XHJcbiAgICAgICAgICAgIHN5c3RlbS5fcHJvdGVjdGVkID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFRpY2tlci5fc3lzdGVtO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBNYW5hZ2VzIHRoZSBtaW5pbXVtIGFtb3VudCBvZiBtaWxsaXNlY29uZHMgYWxsb3dlZCB0b1xyXG4gICAgICogZWxhcHNlIGJldHdlZW4gaW52b2tpbmcge0BsaW5rIFBJWEkuVGlja2VyI3VwZGF0ZX0uXHJcbiAgICAgKiBUaGlzIHdpbGwgZWZmZWN0IHRoZSBtZWFzdXJlZCB2YWx1ZSBvZiB7QGxpbmsgUElYSS50aWNrZXIuVGlja2VyI0ZQU30uXHJcbiAgICAgKiBXaGVuIHNldHRpbmcgdGhpcyBwcm9wZXJ0eSBpdCBpcyBjbGFtcGVkIHRvIGEgdmFsdWUgYmV0d2VlblxyXG4gICAgICogYDFgIGFuZCBgVEFSR0VUX0ZQTVMgKiAxMDAwYC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgKiBAZGVmYXVsdCA2MFxyXG4gICAgICovXHJcbiAgICBnZXQgbWF4RlBTKCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9taW5FbGFwc2VkTVMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIDEwMDAgLyB0aGlzLl9taW5FbGFwc2VkTVM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzZXR0aW5nc18xLnNldHRpbmdzLlRBUkdFVF9GUE1TICogMTAwMDtcclxuICAgIH1cclxuICAgIDtcclxufVxyXG4vKipcclxuICogUmVwcmVzZW50cyB0aGUgdXBkYXRlIHByaW9yaXRpZXMgdXNlZCBieSBpbnRlcm5hbCBQSVhJIGNsYXNzZXMgd2hlbiByZWdpc3RlcmVkIHdpdGhcclxuICogdGhlIHtAbGluayBQSVhJLlRpY2tlcn0gb2JqZWN0LiBIaWdoZXIgcHJpb3JpdHkgaXRlbXMgYXJlIHVwZGF0ZWQgZmlyc3QgYW5kIGxvd2VyXHJcbiAqIHByaW9yaXR5IGl0ZW1zLCBzdWNoIGFzIHJlbmRlciwgc2hvdWxkIGdvIGxhdGVyLlxyXG4gKlxyXG4gKiBAc3RhdGljXHJcbiAqIEBjb25zdGFudFxyXG4gKiBAbmFtZSBVUERBVEVfUFJJT1JJVFlcclxuICogQG1lbWJlcm9mIFBJWElcclxuICogQHR5cGUge29iamVjdH1cclxuICogQHByb3BlcnR5IHtudW1iZXJ9IElOVEVSQUNUSU9OPTUwIEhpZ2hlc3QgcHJpb3JpdHksIHVzZWQgZm9yIHtAbGluayBQSVhJLmludGVyYWN0aW9uLkludGVyYWN0aW9uTWFuYWdlcn1cclxuICogQHByb3BlcnR5IHtudW1iZXJ9IEhJR0g9MjUgSGlnaCBwcmlvcml0eSB1cGRhdGluZywge0BsaW5rIFBJWEkuVmlkZW9CYXNlVGV4dHVyZX0gYW5kIHtAbGluayBQSVhJLkFuaW1hdGVkU3ByaXRlfVxyXG4gKiBAcHJvcGVydHkge251bWJlcn0gTk9STUFMPTAgRGVmYXVsdCBwcmlvcml0eSBmb3IgdGlja2VyIGV2ZW50cywgc2VlIHtAbGluayBQSVhJLlRpY2tlciNhZGR9LlxyXG4gKiBAcHJvcGVydHkge251bWJlcn0gTE9XPS0yNSBMb3cgcHJpb3JpdHkgdXNlZCBmb3Ige0BsaW5rIFBJWEkuQXBwbGljYXRpb259IHJlbmRlcmluZy5cclxuICogQHByb3BlcnR5IHtudW1iZXJ9IFVUSUxJVFk9LTUwIExvd2VzdCBwcmlvcml0eSB1c2VkIGZvciB7QGxpbmsgUElYSS5wcmVwYXJlLkJhc2VQcmVwYXJlfSB1dGlsaXR5LlxyXG4gKi9cclxuVGlja2VyLlVQREFURV9QUklPUklUWSA9IHtcclxuICAgIElOVEVSQUNUSU9OOiA1MCxcclxuICAgIEhJR0g6IDI1LFxyXG4gICAgTk9STUFMOiAwLFxyXG4gICAgTE9XOiAtMjUsXHJcbiAgICBVVElMSVRZOiAtNTAsXHJcbn07XHJcbmV4cG9ydHMuVGlja2VyID0gVGlja2VyO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jbGFzcyBUaWNrZXJMaXN0ZW5lciB7XHJcbiAgICBjb25zdHJ1Y3RvcihmbiwgY29udGV4dCwgcHJpb3JpdHksIG9uY2UgPSBmYWxzZSkge1xyXG4gICAgICAgIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHtcclxuICAgICAgICAgICAgY29udGV4dCA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwcmlvcml0eSA9PT0gdm9pZCAwKSB7XHJcbiAgICAgICAgICAgIHByaW9yaXR5ID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG9uY2UgPT09IHZvaWQgMCkge1xyXG4gICAgICAgICAgICBvbmNlID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBoYW5kbGVyIGZ1bmN0aW9uIHRvIGV4ZWN1dGUuXHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKiBAbWVtYmVyIHtGdW5jdGlvbn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmZuID0gZm47XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGNhbGxpbmcgdG8gZXhlY3V0ZS5cclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqIEBtZW1iZXIgeyp9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgY3VycmVudCBwcmlvcml0eS5cclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnByaW9yaXR5ID0gcHJpb3JpdHk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSWYgdGhpcyBzaG91bGQgb25seSBleGVjdXRlIG9uY2UuXHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKiBAbWVtYmVyIHtib29sZWFufVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMub25jZSA9IG9uY2U7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIG5leHQgaXRlbSBpbiBjaGFpbi5cclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqIEBtZW1iZXIge1RpY2tlckxpc3RlbmVyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMubmV4dCA9IG51bGw7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIHByZXZpb3VzIGl0ZW0gaW4gY2hhaW4uXHJcbiAgICAgICAgICogQHByaXZhdGVcclxuICAgICAgICAgKiBAbWVtYmVyIHtUaWNrZXJMaXN0ZW5lcn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnByZXZpb3VzID0gbnVsbDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBgdHJ1ZWAgaWYgdGhpcyBsaXN0ZW5lciBoYXMgYmVlbiBkZXN0cm95ZWQgYWxyZWFkeS5cclxuICAgICAgICAgKiBAbWVtYmVyIHtib29sZWFufVxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5fZGVzdHJveWVkID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEVtaXQgYnkgY2FsbGluZyB0aGUgY3VycmVudCBmdW5jdGlvbi5cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZGVsdGFUaW1lIC0gdGltZSBzaW5jZSB0aGUgbGFzdCBlbWl0LlxyXG4gICAgICogQHJldHVybiB7VGlja2VyTGlzdGVuZXJ9IE5leHQgdGlja2VyXHJcbiAgICAgKi9cclxuICAgIGVtaXQoZGVsdGFUaW1lKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZm4pIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuY29udGV4dCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5mbi5jYWxsKHRoaXMuY29udGV4dCwgZGVsdGFUaW1lKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZm4oZGVsdGFUaW1lKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcmVkaXJlY3QgPSB0aGlzLm5leHQ7XHJcbiAgICAgICAgaWYgKHRoaXMub25jZSkge1xyXG4gICAgICAgICAgICB0aGlzLmRlc3Ryb3kodHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFNvZnQtZGVzdHJveWluZyBzaG91bGQgcmVtb3ZlXHJcbiAgICAgICAgLy8gdGhlIG5leHQgcmVmZXJlbmNlXHJcbiAgICAgICAgaWYgKHRoaXMuX2Rlc3Ryb3llZCkge1xyXG4gICAgICAgICAgICB0aGlzLm5leHQgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVkaXJlY3Q7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIERlc3Ryb3kgYW5kIGRvbid0IHVzZSBhZnRlciB0aGlzLlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2hhcmQgPSBmYWxzZV0gYHRydWVgIHRvIHJlbW92ZSB0aGUgYG5leHRgIHJlZmVyZW5jZSwgdGhpc1xyXG4gICAgICogICAgaXMgY29uc2lkZXJlZCBhIGhhcmQgZGVzdHJveS4gU29mdCBkZXN0cm95IG1haW50YWlucyB0aGUgbmV4dCByZWZlcmVuY2UuXHJcbiAgICAgKiBAcmV0dXJuIHtUaWNrZXJMaXN0ZW5lcn0gVGhlIGxpc3RlbmVyIHRvIHJlZGlyZWN0IHdoaWxlIGVtaXR0aW5nIG9yIHJlbW92aW5nLlxyXG4gICAgICovXHJcbiAgICBkZXN0cm95KGhhcmQpIHtcclxuICAgICAgICBpZiAoaGFyZCA9PT0gdm9pZCAwKSB7XHJcbiAgICAgICAgICAgIGhhcmQgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fZGVzdHJveWVkID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmZuID0gbnVsbDtcclxuICAgICAgICB0aGlzLmNvbnRleHQgPSBudWxsO1xyXG4gICAgICAgIC8vIERpc2Nvbm5lY3QsIGhvb2sgdXAgbmV4dCBhbmQgcHJldmlvdXNcclxuICAgICAgICBpZiAodGhpcy5wcmV2aW91cykge1xyXG4gICAgICAgICAgICB0aGlzLnByZXZpb3VzLm5leHQgPSB0aGlzLm5leHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLm5leHQpIHtcclxuICAgICAgICAgICAgdGhpcy5uZXh0LnByZXZpb3VzID0gdGhpcy5wcmV2aW91cztcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gUmVkaXJlY3QgdG8gdGhlIG5leHQgaXRlbVxyXG4gICAgICAgIHZhciByZWRpcmVjdCA9IHRoaXMubmV4dDtcclxuICAgICAgICAvLyBSZW1vdmUgcmVmZXJlbmNlc1xyXG4gICAgICAgIHRoaXMubmV4dCA9IGhhcmQgPyBudWxsIDogcmVkaXJlY3Q7XHJcbiAgICAgICAgdGhpcy5wcmV2aW91cyA9IG51bGw7XHJcbiAgICAgICAgcmV0dXJuIHJlZGlyZWN0O1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDb25uZWN0IHRvIHRoZSBsaXN0LlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7VGlja2VyTGlzdGVuZXJ9IHByZXZpb3VzIC0gSW5wdXQgbm9kZSwgcHJldmlvdXMgbGlzdGVuZXJcclxuICAgICAqL1xyXG4gICAgY29ubmVjdChwcmV2aW91cykge1xyXG4gICAgICAgIHRoaXMucHJldmlvdXMgPSBwcmV2aW91cztcclxuICAgICAgICBpZiAocHJldmlvdXMubmV4dCkge1xyXG4gICAgICAgICAgICBwcmV2aW91cy5uZXh0LnByZXZpb3VzID0gdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5uZXh0ID0gcHJldmlvdXMubmV4dDtcclxuICAgICAgICBwcmV2aW91cy5uZXh0ID0gdGhpcztcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogU2ltcGxlIGNvbXBhcmUgZnVuY3Rpb24gdG8gZmlndXJlIG91dCBpZiBhIGZ1bmN0aW9uIGFuZCBjb250ZXh0IG1hdGNoLlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIC0gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uIHRvIGJlIGFkZGVkIGZvciBvbmUgdXBkYXRlXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb250ZXh0IC0gVGhlIGxpc3RlbmVyIGNvbnRleHRcclxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgbGlzdGVuZXIgbWF0Y2ggdGhlIGFyZ3VtZW50c1xyXG4gICAgICovXHJcbiAgICBtYXRjaChmbiwgY29udGV4dCkge1xyXG4gICAgICAgIGNvbnRleHQgPSBjb250ZXh0IHx8IG51bGw7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZm4gPT09IGZuICYmIHRoaXMuY29udGV4dCA9PT0gY29udGV4dDtcclxuICAgIH1cclxuICAgIDtcclxufVxyXG5leHBvcnRzLlRpY2tlckxpc3RlbmVyID0gVGlja2VyTGlzdGVuZXI7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IE9iamVjdFJlbmRlcmVyXzEgPSByZXF1aXJlKFwiLi9PYmplY3RSZW5kZXJlclwiKTtcclxuY29uc3QgU2hhZGVyXzEgPSByZXF1aXJlKFwiLi9TaGFkZXJcIik7XHJcbmNvbnN0IFF1YWRVdl8xID0gcmVxdWlyZShcIi4vUXVhZFV2XCIpO1xyXG5jb25zdCBNYXRyaXhfMSA9IHJlcXVpcmUoXCIuL01hdHJpeFwiKTtcclxuY29uc3QgV2ViR0xTZXR0aW5nc18xID0gcmVxdWlyZShcIi4vV2ViR0xTZXR0aW5nc1wiKTtcclxuY29uc3QgQ29sb3JTZXR0aW5nc18xID0gcmVxdWlyZShcIi4vQ29sb3JTZXR0aW5nc1wiKTtcclxuY29uc3QgQmxlbmRNb2Rlc1NldHRpbmdzXzEgPSByZXF1aXJlKFwiLi9CbGVuZE1vZGVzU2V0dGluZ3NcIik7XHJcbmNsYXNzIFRpbGluZ1Nwcml0ZVJlbmRlcmVyIGV4dGVuZHMgT2JqZWN0UmVuZGVyZXJfMS5PYmplY3RSZW5kZXJlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihyZW5kZXJlcikge1xyXG4gICAgICAgIHN1cGVyKHJlbmRlcmVyKTtcclxuICAgICAgICB2YXIgdW5pZm9ybXMgPSB7IGdsb2JhbHM6IHRoaXMucmVuZGVyZXIuZ2xvYmFsVW5pZm9ybXMgfTtcclxuICAgICAgICB0aGlzLnNoYWRlciA9IFNoYWRlcl8xLlNoYWRlci5mcm9tKFRpbGluZ1Nwcml0ZVJlbmRlcmVyLnZlcnRleCQzLCBUaWxpbmdTcHJpdGVSZW5kZXJlci5mcmFnbWVudCQyLCB1bmlmb3Jtcyk7XHJcbiAgICAgICAgdGhpcy5zaW1wbGVTaGFkZXIgPSBTaGFkZXJfMS5TaGFkZXIuZnJvbShUaWxpbmdTcHJpdGVSZW5kZXJlci52ZXJ0ZXgkMywgVGlsaW5nU3ByaXRlUmVuZGVyZXIuZnJhZ21lbnRTaW1wbGUsIHVuaWZvcm1zKTtcclxuICAgICAgICB0aGlzLnF1YWQgPSBuZXcgUXVhZFV2XzEuUXVhZFV2KCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1BJWEkuVGlsaW5nU3ByaXRlfSB0cyB0aWxpbmdTcHJpdGUgdG8gYmUgcmVuZGVyZWRcclxuICAgICAqL1xyXG4gICAgcmVuZGVyKHRzKSB7XHJcbiAgICAgICAgdmFyIHJlbmRlcmVyID0gdGhpcy5yZW5kZXJlcjtcclxuICAgICAgICB2YXIgcXVhZCA9IHRoaXMucXVhZDtcclxuICAgICAgICB2YXIgdmVydGljZXMgPSBxdWFkLnZlcnRpY2VzO1xyXG4gICAgICAgIHZlcnRpY2VzWzBdID0gdmVydGljZXNbNl0gPSAodHMuX3dpZHRoKSAqIC10cy5hbmNob3IueDtcclxuICAgICAgICB2ZXJ0aWNlc1sxXSA9IHZlcnRpY2VzWzNdID0gdHMuX2hlaWdodCAqIC10cy5hbmNob3IueTtcclxuICAgICAgICB2ZXJ0aWNlc1syXSA9IHZlcnRpY2VzWzRdID0gKHRzLl93aWR0aCkgKiAoMS4wIC0gdHMuYW5jaG9yLngpO1xyXG4gICAgICAgIHZlcnRpY2VzWzVdID0gdmVydGljZXNbN10gPSB0cy5faGVpZ2h0ICogKDEuMCAtIHRzLmFuY2hvci55KTtcclxuICAgICAgICBpZiAodHMudXZSZXNwZWN0QW5jaG9yKSB7XHJcbiAgICAgICAgICAgIHZlcnRpY2VzID0gcXVhZC51dnM7XHJcbiAgICAgICAgICAgIHZlcnRpY2VzWzBdID0gdmVydGljZXNbNl0gPSAtdHMuYW5jaG9yLng7XHJcbiAgICAgICAgICAgIHZlcnRpY2VzWzFdID0gdmVydGljZXNbM10gPSAtdHMuYW5jaG9yLnk7XHJcbiAgICAgICAgICAgIHZlcnRpY2VzWzJdID0gdmVydGljZXNbNF0gPSAxLjAgLSB0cy5hbmNob3IueDtcclxuICAgICAgICAgICAgdmVydGljZXNbNV0gPSB2ZXJ0aWNlc1s3XSA9IDEuMCAtIHRzLmFuY2hvci55O1xyXG4gICAgICAgIH1cclxuICAgICAgICBxdWFkLmludmFsaWRhdGUoKTtcclxuICAgICAgICB2YXIgdGV4ID0gdHMuX3RleHR1cmU7XHJcbiAgICAgICAgdmFyIGJhc2VUZXggPSB0ZXguYmFzZVRleHR1cmU7XHJcbiAgICAgICAgdmFyIGx0ID0gdHMudGlsZVRyYW5zZm9ybS5sb2NhbFRyYW5zZm9ybTtcclxuICAgICAgICB2YXIgdXYgPSB0cy51dk1hdHJpeDtcclxuICAgICAgICB2YXIgaXNTaW1wbGUgPSBiYXNlVGV4LmlzUG93ZXJPZlR3b1xyXG4gICAgICAgICAgICAmJiB0ZXguZnJhbWUud2lkdGggPT09IGJhc2VUZXgud2lkdGggJiYgdGV4LmZyYW1lLmhlaWdodCA9PT0gYmFzZVRleC5oZWlnaHQ7XHJcbiAgICAgICAgLy8gYXV0bywgZm9yY2UgcmVwZWF0IHdyYXBNb2RlIGZvciBiaWcgdGlsaW5nIHRleHR1cmVzXHJcbiAgICAgICAgaWYgKGlzU2ltcGxlKSB7XHJcbiAgICAgICAgICAgIGlmICghYmFzZVRleC5fZ2xUZXh0dXJlc1tyZW5kZXJlci5DT05URVhUX1VJRF0pIHtcclxuICAgICAgICAgICAgICAgIGlmIChiYXNlVGV4LndyYXBNb2RlID09PSBXZWJHTFNldHRpbmdzXzEuV2ViR0xTZXR0aW5ncy5XUkFQX01PREVTLkNMQU1QKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYmFzZVRleC53cmFwTW9kZSA9IFdlYkdMU2V0dGluZ3NfMS5XZWJHTFNldHRpbmdzLldSQVBfTU9ERVMuUkVQRUFUO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaXNTaW1wbGUgPSBiYXNlVGV4LndyYXBNb2RlICE9PSBXZWJHTFNldHRpbmdzXzEuV2ViR0xTZXR0aW5ncy5XUkFQX01PREVTLkNMQU1QO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBzaGFkZXIgPSBpc1NpbXBsZSA/IHRoaXMuc2ltcGxlU2hhZGVyIDogdGhpcy5zaGFkZXI7XHJcbiAgICAgICAgdmFyIHcgPSB0ZXgud2lkdGg7XHJcbiAgICAgICAgdmFyIGggPSB0ZXguaGVpZ2h0O1xyXG4gICAgICAgIHZhciBXID0gdHMuX3dpZHRoO1xyXG4gICAgICAgIHZhciBIID0gdHMuX2hlaWdodDtcclxuICAgICAgICBUaWxpbmdTcHJpdGVSZW5kZXJlci50ZW1wTWF0JDEuc2V0KGx0LmEgKiB3IC8gVywgbHQuYiAqIHcgLyBILCBsdC5jICogaCAvIFcsIGx0LmQgKiBoIC8gSCwgbHQudHggLyBXLCBsdC50eSAvIEgpO1xyXG4gICAgICAgIC8vIHRoYXQgcGFydCBpcyB0aGUgc2FtZSBhcyBhYm92ZTpcclxuICAgICAgICAvLyB0ZW1wTWF0LmlkZW50aXR5KCk7XHJcbiAgICAgICAgLy8gdGVtcE1hdC5zY2FsZSh0ZXgud2lkdGgsIHRleC5oZWlnaHQpO1xyXG4gICAgICAgIC8vIHRlbXBNYXQucHJlcGVuZChsdCk7XHJcbiAgICAgICAgLy8gdGVtcE1hdC5zY2FsZSgxLjAgLyB0cy5fd2lkdGgsIDEuMCAvIHRzLl9oZWlnaHQpO1xyXG4gICAgICAgIFRpbGluZ1Nwcml0ZVJlbmRlcmVyLnRlbXBNYXQkMS5pbnZlcnQoKTtcclxuICAgICAgICBpZiAoaXNTaW1wbGUpIHtcclxuICAgICAgICAgICAgVGlsaW5nU3ByaXRlUmVuZGVyZXIudGVtcE1hdCQxLnByZXBlbmQodXYubWFwQ29vcmQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgc2hhZGVyLnVuaWZvcm1zLnVNYXBDb29yZCA9IHV2Lm1hcENvb3JkLnRvQXJyYXkodHJ1ZSk7XHJcbiAgICAgICAgICAgIHNoYWRlci51bmlmb3Jtcy51Q2xhbXBGcmFtZSA9IHV2LnVDbGFtcEZyYW1lO1xyXG4gICAgICAgICAgICBzaGFkZXIudW5pZm9ybXMudUNsYW1wT2Zmc2V0ID0gdXYudUNsYW1wT2Zmc2V0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBzaGFkZXIudW5pZm9ybXMudVRyYW5zZm9ybSA9IFRpbGluZ1Nwcml0ZVJlbmRlcmVyLnRlbXBNYXQkMS50b0FycmF5KHRydWUpO1xyXG4gICAgICAgIHNoYWRlci51bmlmb3Jtcy51Q29sb3IgPSBDb2xvclNldHRpbmdzXzEuQ29sb3JTZXR0aW5ncy5wcmVtdWx0aXBseVRpbnRUb1JnYmEodHMudGludCwgdHMud29ybGRBbHBoYSwgc2hhZGVyLnVuaWZvcm1zLnVDb2xvciwgYmFzZVRleC5wcmVtdWx0aXBseUFscGhhKTtcclxuICAgICAgICBzaGFkZXIudW5pZm9ybXMudHJhbnNsYXRpb25NYXRyaXggPSB0cy50cmFuc2Zvcm0ud29ybGRUcmFuc2Zvcm0udG9BcnJheSh0cnVlKTtcclxuICAgICAgICBzaGFkZXIudW5pZm9ybXMudVNhbXBsZXIgPSB0ZXg7XHJcbiAgICAgICAgcmVuZGVyZXIuc2hhZGVyLmJpbmQoc2hhZGVyKTtcclxuICAgICAgICByZW5kZXJlci5nZW9tZXRyeS5iaW5kKHF1YWQpOyAvLyAsIHJlbmRlcmVyLnNoYWRlci5nZXRHTFNoYWRlcigpKTtcclxuICAgICAgICByZW5kZXJlci5zdGF0ZS5zZXRCbGVuZE1vZGUoQmxlbmRNb2Rlc1NldHRpbmdzXzEuQmxlbmRNb2Rlc1NldHRpbmdzLmNvcnJlY3RCbGVuZE1vZGUodHMuYmxlbmRNb2RlLCBiYXNlVGV4LnByZW11bHRpcGx5QWxwaGEpKTtcclxuICAgICAgICByZW5kZXJlci5nZW9tZXRyeS5kcmF3KHRoaXMucmVuZGVyZXIuZ2wuVFJJQU5HTEVTLCA2LCAwKTtcclxuICAgIH1cclxuICAgIDtcclxufVxyXG5UaWxpbmdTcHJpdGVSZW5kZXJlci5mcmFnbWVudFNpbXBsZSA9IFwidmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XFxyXFxuXFxyXFxudW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXI7XFxyXFxudW5pZm9ybSB2ZWM0IHVDb2xvcjtcXHJcXG5cXHJcXG52b2lkIG1haW4odm9pZClcXHJcXG57XFxyXFxuICAgIHZlYzQgc2FtcGxlID0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2VGV4dHVyZUNvb3JkKTtcXHJcXG4gICAgZ2xfRnJhZ0NvbG9yID0gc2FtcGxlICogdUNvbG9yO1xcclxcbn1cXHJcXG5cIjtcclxuVGlsaW5nU3ByaXRlUmVuZGVyZXIuZnJhZ21lbnQkMiA9IFwidmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XFxyXFxuXFxyXFxudW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXI7XFxyXFxudW5pZm9ybSB2ZWM0IHVDb2xvcjtcXHJcXG51bmlmb3JtIG1hdDMgdU1hcENvb3JkO1xcclxcbnVuaWZvcm0gdmVjNCB1Q2xhbXBGcmFtZTtcXHJcXG51bmlmb3JtIHZlYzIgdUNsYW1wT2Zmc2V0O1xcclxcblxcclxcbnZvaWQgbWFpbih2b2lkKVxcclxcbntcXHJcXG4gICAgdmVjMiBjb29yZCA9IG1vZCh2VGV4dHVyZUNvb3JkIC0gdUNsYW1wT2Zmc2V0LCB2ZWMyKDEuMCwgMS4wKSkgKyB1Q2xhbXBPZmZzZXQ7XFxyXFxuICAgIGNvb3JkID0gKHVNYXBDb29yZCAqIHZlYzMoY29vcmQsIDEuMCkpLnh5O1xcclxcbiAgICBjb29yZCA9IGNsYW1wKGNvb3JkLCB1Q2xhbXBGcmFtZS54eSwgdUNsYW1wRnJhbWUuencpO1xcclxcblxcclxcbiAgICB2ZWM0IHNhbXBsZSA9IHRleHR1cmUyRCh1U2FtcGxlciwgY29vcmQpO1xcclxcbiAgICBnbF9GcmFnQ29sb3IgPSBzYW1wbGUgKiB1Q29sb3I7XFxyXFxufVxcclxcblwiO1xyXG5UaWxpbmdTcHJpdGVSZW5kZXJlci52ZXJ0ZXgkMyA9IFwiYXR0cmlidXRlIHZlYzIgYVZlcnRleFBvc2l0aW9uO1xcclxcbmF0dHJpYnV0ZSB2ZWMyIGFUZXh0dXJlQ29vcmQ7XFxyXFxuXFxyXFxudW5pZm9ybSBtYXQzIHByb2plY3Rpb25NYXRyaXg7XFxyXFxudW5pZm9ybSBtYXQzIHRyYW5zbGF0aW9uTWF0cml4O1xcclxcbnVuaWZvcm0gbWF0MyB1VHJhbnNmb3JtO1xcclxcblxcclxcbnZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xcclxcblxcclxcbnZvaWQgbWFpbih2b2lkKVxcclxcbntcXHJcXG4gICAgZ2xfUG9zaXRpb24gPSB2ZWM0KChwcm9qZWN0aW9uTWF0cml4ICogdHJhbnNsYXRpb25NYXRyaXggKiB2ZWMzKGFWZXJ0ZXhQb3NpdGlvbiwgMS4wKSkueHksIDAuMCwgMS4wKTtcXHJcXG5cXHJcXG4gICAgdlRleHR1cmVDb29yZCA9ICh1VHJhbnNmb3JtICogdmVjMyhhVGV4dHVyZUNvb3JkLCAxLjApKS54eTtcXHJcXG59XFxyXFxuXCI7XHJcblRpbGluZ1Nwcml0ZVJlbmRlcmVyLnRlbXBNYXQkMSA9IG5ldyBNYXRyaXhfMS5NYXRyaXgoKTtcclxuZXhwb3J0cy5UaWxpbmdTcHJpdGVSZW5kZXJlciA9IFRpbGluZ1Nwcml0ZVJlbmRlcmVyO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBNYXRyaXhfMSA9IHJlcXVpcmUoXCIuL01hdHJpeFwiKTtcclxuY29uc3QgT2JzZXJ2YWJsZVBvaW50XzEgPSByZXF1aXJlKFwiLi9PYnNlcnZhYmxlUG9pbnRcIik7XHJcbmNsYXNzIFRyYW5zZm9ybSB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFRoZSBnbG9iYWwgbWF0cml4IHRyYW5zZm9ybS4gSXQgY2FuIGJlIHN3YXBwZWQgdGVtcG9yYXJpbHkgYnkgc29tZSBmdW5jdGlvbnMgbGlrZSBnZXRMb2NhbEJvdW5kcygpXHJcbiAgICAgICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgICAgICogQG1lbWJlciB7UElYSS5NYXRyaXh9XHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLndvcmxkVHJhbnNmb3JtID0gbmV3IE1hdHJpeF8xLk1hdHJpeCgpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBsb2NhbCBtYXRyaXggdHJhbnNmb3JtXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLk1hdHJpeH1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmxvY2FsVHJhbnNmb3JtID0gbmV3IE1hdHJpeF8xLk1hdHJpeCgpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBjb29yZGluYXRlIG9mIHRoZSBvYmplY3QgcmVsYXRpdmUgdG8gdGhlIGxvY2FsIGNvb3JkaW5hdGVzIG9mIHRoZSBwYXJlbnQuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLk9ic2VydmFibGVQb2ludH1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnBvc2l0aW9uID0gbmV3IE9ic2VydmFibGVQb2ludF8xLk9ic2VydmFibGVQb2ludCh0aGlzLm9uQ2hhbmdlLCB0aGlzLCAwLCAwKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgc2NhbGUgZmFjdG9yIG9mIHRoZSBvYmplY3QuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLk9ic2VydmFibGVQb2ludH1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnNjYWxlID0gbmV3IE9ic2VydmFibGVQb2ludF8xLk9ic2VydmFibGVQb2ludCh0aGlzLm9uQ2hhbmdlLCB0aGlzLCAxLCAxKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgcGl2b3QgcG9pbnQgb2YgdGhlIGRpc3BsYXlPYmplY3QgdGhhdCBpdCByb3RhdGVzIGFyb3VuZC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuT2JzZXJ2YWJsZVBvaW50fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMucGl2b3QgPSBuZXcgT2JzZXJ2YWJsZVBvaW50XzEuT2JzZXJ2YWJsZVBvaW50KHRoaXMub25DaGFuZ2UsIHRoaXMsIDAsIDApO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBza2V3IGFtb3VudCwgb24gdGhlIHggYW5kIHkgYXhpcy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuT2JzZXJ2YWJsZVBvaW50fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuc2tldyA9IG5ldyBPYnNlcnZhYmxlUG9pbnRfMS5PYnNlcnZhYmxlUG9pbnQodGhpcy51cGRhdGVTa2V3LCB0aGlzLCAwLCAwKTtcclxuICAgICAgICB0aGlzLl9yb3RhdGlvbiA9IDA7XHJcbiAgICAgICAgdGhpcy5fY3ggPSAxOyAvLyBjb3Mgcm90YXRpb24gKyBza2V3WTtcclxuICAgICAgICB0aGlzLl9zeCA9IDA7IC8vIHNpbiByb3RhdGlvbiArIHNrZXdZO1xyXG4gICAgICAgIHRoaXMuX2N5ID0gMDsgLy8gY29zIHJvdGF0aW9uICsgTWF0aC5QSS8yIC0gc2tld1g7XHJcbiAgICAgICAgdGhpcy5fc3kgPSAxOyAvLyBzaW4gcm90YXRpb24gKyBNYXRoLlBJLzIgLSBza2V3WDtcclxuICAgICAgICB0aGlzLl9sb2NhbElEID0gMDtcclxuICAgICAgICB0aGlzLl9jdXJyZW50TG9jYWxJRCA9IDA7XHJcbiAgICAgICAgdGhpcy5fd29ybGRJRCA9IDA7XHJcbiAgICAgICAgdGhpcy5fcGFyZW50SUQgPSAwO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxsZWQgd2hlbiBhIHZhbHVlIGNoYW5nZXMuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xyXG4gICAgb25DaGFuZ2UoKSB7XHJcbiAgICAgICAgdGhpcy5fbG9jYWxJRCsrO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxsZWQgd2hlbiBza2V3IG9yIHJvdGF0aW9uIGNoYW5nZXNcclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICB1cGRhdGVTa2V3KCkge1xyXG4gICAgICAgIHRoaXMuX2N4ID0gTWF0aC5jb3ModGhpcy5fcm90YXRpb24gKyB0aGlzLnNrZXcuX3kpO1xyXG4gICAgICAgIHRoaXMuX3N4ID0gTWF0aC5zaW4odGhpcy5fcm90YXRpb24gKyB0aGlzLnNrZXcuX3kpO1xyXG4gICAgICAgIHRoaXMuX2N5ID0gLU1hdGguc2luKHRoaXMuX3JvdGF0aW9uIC0gdGhpcy5za2V3Ll94KTsgLy8gY29zLCBhZGRlZCBQSS8yXHJcbiAgICAgICAgdGhpcy5fc3kgPSBNYXRoLmNvcyh0aGlzLl9yb3RhdGlvbiAtIHRoaXMuc2tldy5feCk7IC8vIHNpbiwgYWRkZWQgUEkvMlxyXG4gICAgICAgIHRoaXMuX2xvY2FsSUQrKztcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyBvbmx5IGxvY2FsIG1hdHJpeFxyXG4gICAgICovXHJcbiAgICB1cGRhdGVMb2NhbFRyYW5zZm9ybSgpIHtcclxuICAgICAgICB2YXIgbHQgPSB0aGlzLmxvY2FsVHJhbnNmb3JtO1xyXG4gICAgICAgIGlmICh0aGlzLl9sb2NhbElEICE9PSB0aGlzLl9jdXJyZW50TG9jYWxJRCkge1xyXG4gICAgICAgICAgICAvLyBnZXQgdGhlIG1hdHJpeCB2YWx1ZXMgb2YgdGhlIGRpc3BsYXlvYmplY3QgYmFzZWQgb24gaXRzIHRyYW5zZm9ybSBwcm9wZXJ0aWVzLi5cclxuICAgICAgICAgICAgbHQuYSA9IHRoaXMuX2N4ICogdGhpcy5zY2FsZS5feDtcclxuICAgICAgICAgICAgbHQuYiA9IHRoaXMuX3N4ICogdGhpcy5zY2FsZS5feDtcclxuICAgICAgICAgICAgbHQuYyA9IHRoaXMuX2N5ICogdGhpcy5zY2FsZS5feTtcclxuICAgICAgICAgICAgbHQuZCA9IHRoaXMuX3N5ICogdGhpcy5zY2FsZS5feTtcclxuICAgICAgICAgICAgbHQudHggPSB0aGlzLnBvc2l0aW9uLl94IC0gKCh0aGlzLnBpdm90Ll94ICogbHQuYSkgKyAodGhpcy5waXZvdC5feSAqIGx0LmMpKTtcclxuICAgICAgICAgICAgbHQudHkgPSB0aGlzLnBvc2l0aW9uLl95IC0gKCh0aGlzLnBpdm90Ll94ICogbHQuYikgKyAodGhpcy5waXZvdC5feSAqIGx0LmQpKTtcclxuICAgICAgICAgICAgdGhpcy5fY3VycmVudExvY2FsSUQgPSB0aGlzLl9sb2NhbElEO1xyXG4gICAgICAgICAgICAvLyBmb3JjZSBhbiB1cGRhdGUuLlxyXG4gICAgICAgICAgICB0aGlzLl9wYXJlbnRJRCA9IC0xO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyB0aGUgdmFsdWVzIG9mIHRoZSBvYmplY3QgYW5kIGFwcGxpZXMgdGhlIHBhcmVudCdzIHRyYW5zZm9ybS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1BJWEkuVHJhbnNmb3JtfSBwYXJlbnRUcmFuc2Zvcm0gLSBUaGUgdHJhbnNmb3JtIG9mIHRoZSBwYXJlbnQgb2YgdGhpcyBvYmplY3RcclxuICAgICAqL1xyXG4gICAgdXBkYXRlVHJhbnNmb3JtKHBhcmVudFRyYW5zZm9ybSkge1xyXG4gICAgICAgIHZhciBsdCA9IHRoaXMubG9jYWxUcmFuc2Zvcm07XHJcbiAgICAgICAgaWYgKHRoaXMuX2xvY2FsSUQgIT09IHRoaXMuX2N1cnJlbnRMb2NhbElEKSB7XHJcbiAgICAgICAgICAgIC8vIGdldCB0aGUgbWF0cml4IHZhbHVlcyBvZiB0aGUgZGlzcGxheW9iamVjdCBiYXNlZCBvbiBpdHMgdHJhbnNmb3JtIHByb3BlcnRpZXMuLlxyXG4gICAgICAgICAgICBsdC5hID0gdGhpcy5fY3ggKiB0aGlzLnNjYWxlLl94O1xyXG4gICAgICAgICAgICBsdC5iID0gdGhpcy5fc3ggKiB0aGlzLnNjYWxlLl94O1xyXG4gICAgICAgICAgICBsdC5jID0gdGhpcy5fY3kgKiB0aGlzLnNjYWxlLl95O1xyXG4gICAgICAgICAgICBsdC5kID0gdGhpcy5fc3kgKiB0aGlzLnNjYWxlLl95O1xyXG4gICAgICAgICAgICBsdC50eCA9IHRoaXMucG9zaXRpb24uX3ggLSAoKHRoaXMucGl2b3QuX3ggKiBsdC5hKSArICh0aGlzLnBpdm90Ll95ICogbHQuYykpO1xyXG4gICAgICAgICAgICBsdC50eSA9IHRoaXMucG9zaXRpb24uX3kgLSAoKHRoaXMucGl2b3QuX3ggKiBsdC5iKSArICh0aGlzLnBpdm90Ll95ICogbHQuZCkpO1xyXG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50TG9jYWxJRCA9IHRoaXMuX2xvY2FsSUQ7XHJcbiAgICAgICAgICAgIC8vIGZvcmNlIGFuIHVwZGF0ZS4uXHJcbiAgICAgICAgICAgIHRoaXMuX3BhcmVudElEID0gLTE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLl9wYXJlbnRJRCAhPT0gcGFyZW50VHJhbnNmb3JtLl93b3JsZElEKSB7XHJcbiAgICAgICAgICAgIC8vIGNvbmNhdCB0aGUgcGFyZW50IG1hdHJpeCB3aXRoIHRoZSBvYmplY3RzIHRyYW5zZm9ybS5cclxuICAgICAgICAgICAgdmFyIHB0ID0gcGFyZW50VHJhbnNmb3JtLndvcmxkVHJhbnNmb3JtO1xyXG4gICAgICAgICAgICB2YXIgd3QgPSB0aGlzLndvcmxkVHJhbnNmb3JtO1xyXG4gICAgICAgICAgICB3dC5hID0gKGx0LmEgKiBwdC5hKSArIChsdC5iICogcHQuYyk7XHJcbiAgICAgICAgICAgIHd0LmIgPSAobHQuYSAqIHB0LmIpICsgKGx0LmIgKiBwdC5kKTtcclxuICAgICAgICAgICAgd3QuYyA9IChsdC5jICogcHQuYSkgKyAobHQuZCAqIHB0LmMpO1xyXG4gICAgICAgICAgICB3dC5kID0gKGx0LmMgKiBwdC5iKSArIChsdC5kICogcHQuZCk7XHJcbiAgICAgICAgICAgIHd0LnR4ID0gKGx0LnR4ICogcHQuYSkgKyAobHQudHkgKiBwdC5jKSArIHB0LnR4O1xyXG4gICAgICAgICAgICB3dC50eSA9IChsdC50eCAqIHB0LmIpICsgKGx0LnR5ICogcHQuZCkgKyBwdC50eTtcclxuICAgICAgICAgICAgdGhpcy5fcGFyZW50SUQgPSBwYXJlbnRUcmFuc2Zvcm0uX3dvcmxkSUQ7XHJcbiAgICAgICAgICAgIC8vIHVwZGF0ZSB0aGUgaWQgb2YgdGhlIHRyYW5zZm9ybS4uXHJcbiAgICAgICAgICAgIHRoaXMuX3dvcmxkSUQrKztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIERlY29tcG9zZXMgYSBtYXRyaXggYW5kIHNldHMgdGhlIHRyYW5zZm9ybXMgcHJvcGVydGllcyBiYXNlZCBvbiBpdC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1BJWEkuTWF0cml4fSBtYXRyaXggLSBUaGUgbWF0cml4IHRvIGRlY29tcG9zZVxyXG4gICAgICovXHJcbiAgICBzZXRGcm9tTWF0cml4KG1hdHJpeCkge1xyXG4gICAgICAgIG1hdHJpeC5kZWNvbXBvc2UodGhpcyk7XHJcbiAgICAgICAgdGhpcy5fbG9jYWxJRCsrO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgcm90YXRpb24gb2YgdGhlIG9iamVjdCBpbiByYWRpYW5zLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgZ2V0IHJvdGF0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9yb3RhdGlvbjtcclxuICAgIH1cclxuICAgIDtcclxuICAgIHNldCByb3RhdGlvbih2YWx1ZSkge1xyXG4gICAgICAgIGlmICh0aGlzLl9yb3RhdGlvbiAhPT0gdmFsdWUpIHtcclxuICAgICAgICAgICAgdGhpcy5fcm90YXRpb24gPSB2YWx1ZTtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVTa2V3KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgO1xyXG59XHJcblRyYW5zZm9ybS5JREVOVElUWSA9IG5ldyBUcmFuc2Zvcm0oKTtcclxuZXhwb3J0cy5UcmFuc2Zvcm0gPSBUcmFuc2Zvcm07XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IElPRXJyb3JFdmVudF8xID0gcmVxdWlyZShcIi4vSU9FcnJvckV2ZW50XCIpO1xyXG5jb25zdCBFdmVudERpc3BhdGNoZXJfMSA9IHJlcXVpcmUoXCIuL0V2ZW50RGlzcGF0Y2hlclwiKTtcclxuY29uc3QgRXZlbnRfMSA9IHJlcXVpcmUoXCIuL0V2ZW50XCIpO1xyXG5jbGFzcyBVUkxMb2FkZXIgZXh0ZW5kcyBFdmVudERpc3BhdGNoZXJfMS5FdmVudERpc3BhdGNoZXIge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLm9uSHR0cFJlc3BvbnNlID0gKCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAodGhpcy54bWxodHRwLnJlYWR5U3RhdGUgPT0gNCAmJiB0aGlzLnhtbGh0dHAuc3RhdHVzID09IDIwMCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZGF0YSA9IHRoaXMueG1saHR0cC5yZXNwb25zZVRleHQ7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoRXZlbnRfMS5FdmVudC5nZXRFdmVudChFdmVudF8xLkV2ZW50LkNPTVBMRVRFKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy54bWxodHRwLnJlYWR5U3RhdGUgPT0gNCAmJiB0aGlzLnhtbGh0dHAuc3RhdHVzID09IDAgJiYgdGhpcy54bWxodHRwLnJlc3BvbnNlVGV4dCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZGF0YSA9IHRoaXMueG1saHR0cC5yZXNwb25zZVRleHQ7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoRXZlbnRfMS5FdmVudC5nZXRFdmVudChFdmVudF8xLkV2ZW50LkNPTVBMRVRFKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy54bWxodHRwLnJlYWR5U3RhdGUgPT0gNCAmJiB0aGlzLnhtbGh0dHAuc3RhdHVzID09IDQwNCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGVycm9yZXZlbnQgPSBuZXcgSU9FcnJvckV2ZW50XzEuSU9FcnJvckV2ZW50KElPRXJyb3JFdmVudF8xLklPRXJyb3JFdmVudC5JT19FUlJPUik7XHJcbiAgICAgICAgICAgICAgICBlcnJvcmV2ZW50LnRleHQgPSBcIkNvdWxkIG5vdCBmaW5kIGZpbGUgXCIgKyB0aGlzLnJlcXVlc3QudXJsO1xyXG4gICAgICAgICAgICAgICAgZXJyb3JldmVudC5lcnJvcklkID0gNDA0O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGVycm9yZXZlbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMueG1saHR0cC5yZWFkeVN0YXRlID09IDQgJiYgdGhpcy54bWxodHRwLnN0YXR1cyA9PSA0MDMpIHtcclxuICAgICAgICAgICAgICAgIHZhciBlcnJvcmV2ZW50ID0gbmV3IElPRXJyb3JFdmVudF8xLklPRXJyb3JFdmVudChJT0Vycm9yRXZlbnRfMS5JT0Vycm9yRXZlbnQuSU9fRVJST1IpO1xyXG4gICAgICAgICAgICAgICAgZXJyb3JldmVudC50ZXh0ID0gXCJDcm9zcyBPcmlnaW4gRXJyb3IgXCIgKyB0aGlzLnJlcXVlc3QudXJsO1xyXG4gICAgICAgICAgICAgICAgZXJyb3JldmVudC5lcnJvcklkID0gNDAzO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGVycm9yZXZlbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMueG1saHR0cC5yZWFkeVN0YXRlID09IDQgJiYgdGhpcy54bWxodHRwLnN0YXR1cyAhPSAyMDApIHtcclxuICAgICAgICAgICAgICAgIHZhciBlcnJvcmV2ZW50ID0gbmV3IElPRXJyb3JFdmVudF8xLklPRXJyb3JFdmVudChJT0Vycm9yRXZlbnRfMS5JT0Vycm9yRXZlbnQuSU9fRVJST1IpO1xyXG4gICAgICAgICAgICAgICAgZXJyb3JldmVudC50ZXh0ID0gXCJVbmtvd24gRXJyb3IgXCIgKyB0aGlzLnJlcXVlc3QudXJsO1xyXG4gICAgICAgICAgICAgICAgZXJyb3JldmVudC5lcnJvcklkID0gdGhpcy54bWxodHRwLnN0YXR1cztcclxuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChlcnJvcmV2ZW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy54bWxodHRwID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XHJcbiAgICB9XHJcbiAgICBkZXN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyLmRlc3RydWN0b3IoKTtcclxuICAgICAgICBpZiAodGhpcy54bWxodHRwKSB7XHJcbiAgICAgICAgICAgIHRoaXMueG1saHR0cC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnhtbGh0dHAgPSBudWxsO1xyXG4gICAgICAgIGlmICh0aGlzLnJlcXVlc3QpIHtcclxuICAgICAgICAgICAgdGhpcy5yZXF1ZXN0LmRlc3RydWN0b3IoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5yZXF1ZXN0ID0gbnVsbDtcclxuICAgICAgICB0aGlzLl9kYXRhID0gbnVsbDtcclxuICAgIH1cclxuICAgIGdldCB1cmwoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMucmVxdWVzdCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0LnVybDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICBnZXQgZGF0YSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZGF0YTtcclxuICAgIH1cclxuICAgIHNldCBkYXRhKHZhbHVlKSB7XHJcbiAgICB9XHJcbiAgICBjbG9zZSgpIHtcclxuICAgIH1cclxuICAgIGxvYWQodmFsdWUpIHtcclxuICAgICAgICB0aGlzLnJlcXVlc3QgPSB2YWx1ZTtcclxuICAgICAgICB2YXIgcGF0aCA9IHRoaXMucmVxdWVzdC51cmw7XHJcbiAgICAgICAgaWYgKCFwYXRoKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMucmVxdWVzdC5kYXRhKSB7XHJcbiAgICAgICAgICAgIHZhciBwYXJhbXMgPSAnJztcclxuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIHRoaXMucmVxdWVzdC5kYXRhKSB7XHJcbiAgICAgICAgICAgICAgICBwYXJhbXMgKz0ga2V5ICsgXCI9XCIgKyB0aGlzLnJlcXVlc3QuZGF0YVtrZXldICsgXCImXCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcGFyYW1zID0gcGFyYW1zLnN1YnN0cigwLCBwYXJhbXMubGVuZ3RoIC0gMSk7XHJcbiAgICAgICAgICAgIHBhdGggKz0gXCI/XCIgKyBwYXJhbXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMueG1saHR0cC5vcGVuKHRoaXMucmVxdWVzdC5tZXRob2QsIHBhdGgsIHRydWUpO1xyXG4gICAgICAgIHRoaXMueG1saHR0cC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSB0aGlzLm9uSHR0cFJlc3BvbnNlO1xyXG4gICAgICAgIGlmIChwYXRoLmluZGV4T2YoXCIuanNvblwiKSA8IDApIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMucmVxdWVzdC5jb250ZW50VHlwZSAhPSAnanNvbicpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMueG1saHR0cC5zZXRSZXF1ZXN0SGVhZGVyKCdDb250ZW50LVR5cGUnLCAndGV4dC94bWwnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5yZXF1ZXN0LmVudmVsb3ApIHtcclxuICAgICAgICAgICAgdGhpcy54bWxodHRwLnNlbmQodGhpcy5yZXF1ZXN0LmVudmVsb3ApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy54bWxodHRwLnNlbmQoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXQgZGF0YUZvcm1hdCgpIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIHNldCBkYXRhRm9ybWF0KHZhbHVlKSB7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5VUkxMb2FkZXIgPSBVUkxMb2FkZXI7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IFVSTFJlcXVlc3RNZXRob2RfMSA9IHJlcXVpcmUoXCIuL1VSTFJlcXVlc3RNZXRob2RcIik7XHJcbmNvbnN0IEZsYXNoQmFzZU9iamVjdF8xID0gcmVxdWlyZShcIi4vRmxhc2hCYXNlT2JqZWN0XCIpO1xyXG5jbGFzcyBVUkxSZXF1ZXN0IGV4dGVuZHMgRmxhc2hCYXNlT2JqZWN0XzEuRmxhc2hCYXNlT2JqZWN0IHtcclxuICAgIGNvbnN0cnVjdG9yKHBhdGggPSBudWxsKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLl9yZXF1ZXN0TWV0YURhdGEgPSBuZXcgUmVxdWVzdE1ldGFEYXRhKCk7XHJcbiAgICAgICAgdGhpcy5fdGltZW91dCA9IDA7XHJcbiAgICAgICAgdGhpcy5fY3Jvc3NPcmlnaW4gPSB0cnVlO1xyXG4gICAgICAgIHRoaXMucmVzZXQocGF0aCk7XHJcbiAgICB9XHJcbiAgICBkZXN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMuX3VybCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5fbWV0aG9kID0gVVJMUmVxdWVzdE1ldGhvZF8xLlVSTFJlcXVlc3RNZXRob2QuUE9TVDtcclxuICAgICAgICBsZXQgaW5kZXggPSBVUkxSZXF1ZXN0LlVSTFJlcXVlc3RDYWNoZS5pbmRleE9mKHRoaXMpO1xyXG4gICAgICAgIGlmIChpbmRleCA8IDApIHtcclxuICAgICAgICAgICAgVVJMUmVxdWVzdC5VUkxSZXF1ZXN0Q2FjaGUucHVzaCh0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXNldChwYXRoID0gbnVsbCkge1xyXG4gICAgICAgIHRoaXMuX3VybCA9IHBhdGg7XHJcbiAgICAgICAgdGhpcy5fbWV0aG9kID0gVVJMUmVxdWVzdE1ldGhvZF8xLlVSTFJlcXVlc3RNZXRob2QuUE9TVDtcclxuICAgICAgICB0aGlzLl9jb250ZW50VHlwZSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5fZW52ZWxvcCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5fZGF0YSA9IG51bGw7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZ2V0VVJMUmVxdWVzdChwYXRoID0gbnVsbCkge1xyXG4gICAgICAgIGlmIChVUkxSZXF1ZXN0LlVSTFJlcXVlc3RDYWNoZS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgbGV0IHVyID0gVVJMUmVxdWVzdC5VUkxSZXF1ZXN0Q2FjaGVbVVJMUmVxdWVzdC5VUkxSZXF1ZXN0Q2FjaGUubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgICAgIFVSTFJlcXVlc3QuVVJMUmVxdWVzdENhY2hlLmxlbmd0aCAtPSAxO1xyXG4gICAgICAgICAgICB1ci5yZXNldChwYXRoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHVyO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IFVSTFJlcXVlc3QocGF0aCk7XHJcbiAgICB9XHJcbiAgICBzZXQgcmVxdWVzdE1ldGFEYXRhKHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5fcmVxdWVzdE1ldGFEYXRhID0gdmFsdWU7XHJcbiAgICB9XHJcbiAgICBnZXQgcmVxdWVzdE1ldGFEYXRhKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0TWV0YURhdGE7XHJcbiAgICB9XHJcbiAgICBzZXQgdGltZW91dCh2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuX3RpbWVvdXQgPSB2YWx1ZTtcclxuICAgIH1cclxuICAgIGdldCB0aW1lb3V0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl90aW1lb3V0O1xyXG4gICAgfVxyXG4gICAgc2V0IGNyb3NzT3JpZ2luKHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5fY3Jvc3NPcmlnaW4gPSB2YWx1ZTtcclxuICAgIH1cclxuICAgIGdldCBjcm9zc09yaWdpbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fY3Jvc3NPcmlnaW47XHJcbiAgICB9XHJcbiAgICBzZXQgZW52ZWxvcCh2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuX2VudmVsb3AgPSB2YWx1ZTtcclxuICAgIH1cclxuICAgIGdldCBlbnZlbG9wKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9lbnZlbG9wO1xyXG4gICAgfVxyXG4gICAgZ2V0IHJlcXVlc3RIZWFkZXJzKCkge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgc2V0IHJlcXVlc3RIZWFkZXJzKHZhbHVlKSB7XHJcbiAgICB9XHJcbiAgICBnZXQgY29udGVudFR5cGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRlbnRUeXBlO1xyXG4gICAgfVxyXG4gICAgc2V0IGNvbnRlbnRUeXBlKHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5fY29udGVudFR5cGUgPSB2YWx1ZTtcclxuICAgIH1cclxuICAgIGdldCB1cmwoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3VybDtcclxuICAgIH1cclxuICAgIHNldCB1cmwodmFsdWUpIHtcclxuICAgICAgICB0aGlzLl91cmwgPSB2YWx1ZTtcclxuICAgIH1cclxuICAgIHNldCBkYXRhKHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5fZGF0YSA9IHZhbHVlO1xyXG4gICAgfVxyXG4gICAgZ2V0IGRhdGEoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGE7XHJcbiAgICB9XHJcbiAgICBnZXQgbWV0aG9kKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9tZXRob2Q7XHJcbiAgICB9XHJcbiAgICBzZXQgbWV0aG9kKHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5fbWV0aG9kID0gdmFsdWU7XHJcbiAgICB9XHJcbn1cclxuVVJMUmVxdWVzdC5VUkxSZXF1ZXN0Q2FjaGUgPSBbXTtcclxuZXhwb3J0cy5VUkxSZXF1ZXN0ID0gVVJMUmVxdWVzdDtcclxuY2xhc3MgUmVxdWVzdE1ldGFEYXRhIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMubWltZVR5cGUgPSAnJztcclxuICAgICAgICB0aGlzLnNraXBTb3VyY2UgPSBmYWxzZTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLlJlcXVlc3RNZXRhRGF0YSA9IFJlcXVlc3RNZXRhRGF0YTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY2xhc3MgVVJMUmVxdWVzdE1ldGhvZCB7XHJcbn1cclxuVVJMUmVxdWVzdE1ldGhvZC5HRVQgPSBcIkdFVFwiO1xyXG5VUkxSZXF1ZXN0TWV0aG9kLlBPU1QgPSBcIlBPU1RcIjtcclxuZXhwb3J0cy5VUkxSZXF1ZXN0TWV0aG9kID0gVVJMUmVxdWVzdE1ldGhvZDtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY2xhc3MgVW5pZm9ybUdyb3VwIHtcclxuICAgIGNvbnN0cnVjdG9yKHVuaWZvcm1zID0gbnVsbCwgX3N0YXRpYyA9IG51bGwpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIHVuaWZvcm0gdmFsdWVzXHJcbiAgICAgICAgICAgICAgICAgKiBAbWVtYmVyIHtvYmplY3R9XHJcbiAgICAgICAgICAgICAgICAgKiBAcmVhZG9ubHlcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMudW5pZm9ybXMgPSB1bmlmb3JtcztcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJdHMgYSBncm91cCBhbmQgbm90IGEgc2luZ2xlIHVuaWZvcm1zXHJcbiAgICAgICAgICogQG1lbWJlciB7Ym9vbGVhbn1cclxuICAgICAgICAgKiBAcmVhZG9ubHlcclxuICAgICAgICAgKiBAZGVmYXVsdCB0cnVlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5ncm91cCA9IHRydWU7XHJcbiAgICAgICAgLy8gbGV0cyBnZW5lcmF0ZSB0aGlzIHdoZW4gdGhlIHNoYWRlciA/XHJcbiAgICAgICAgdGhpcy5zeW5jVW5pZm9ybXMgPSB7fTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBkaXJ0eSB2ZXJzaW9uXHJcbiAgICAgICAgICogQHByb3RlY3RlZFxyXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmRpcnR5SWQgPSAwO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIHVuaXF1ZSBpZFxyXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5pZCA9IFVuaWZvcm1Hcm91cC5VSUQkMisrO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFVuaWZvcm1zIHdvbnQgYmUgY2hhbmdlZCBhZnRlciBjcmVhdGlvblxyXG4gICAgICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5zdGF0aWMgPSAhIV9zdGF0aWM7XHJcbiAgICB9XHJcbiAgICB1cGRhdGUoKSB7XHJcbiAgICAgICAgdGhpcy5kaXJ0eUlkKys7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICBhZGQobmFtZSwgdW5pZm9ybXMsIF9zdGF0aWMpIHtcclxuICAgICAgICB0aGlzLnVuaWZvcm1zW25hbWVdID0gbmV3IFVuaWZvcm1Hcm91cCh1bmlmb3JtcywgX3N0YXRpYyk7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICBzdGF0aWMgZnJvbSh1bmlmb3JtcywgX3N0YXRpYykge1xyXG4gICAgICAgIHJldHVybiBuZXcgVW5pZm9ybUdyb3VwKHVuaWZvcm1zLCBfc3RhdGljKTtcclxuICAgIH1cclxuICAgIDtcclxufVxyXG5Vbmlmb3JtR3JvdXAuVUlEJDIgPSAwO1xyXG5leHBvcnRzLlVuaWZvcm1Hcm91cCA9IFVuaWZvcm1Hcm91cDtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY29uc3QgVXRpbHNTZXR0aW5nc18xID0gcmVxdWlyZShcIi4vVXRpbHNTZXR0aW5nc1wiKTtcclxuY2xhc3MgVXJsIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMucHJvdG9jb2wgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuc2xhc2hlcyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5hdXRoID0gbnVsbDtcclxuICAgICAgICB0aGlzLmhvc3QgPSBudWxsO1xyXG4gICAgICAgIHRoaXMucG9ydCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5ob3N0bmFtZSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5oYXNoID0gbnVsbDtcclxuICAgICAgICB0aGlzLnNlYXJjaCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5xdWVyeSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5wYXRobmFtZSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5wYXRoID0gbnVsbDtcclxuICAgICAgICB0aGlzLmhyZWYgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgLy8gZm9ybWF0IGEgcGFyc2VkIG9iamVjdCBpbnRvIGEgdXJsIHN0cmluZ1xyXG4gICAgc3RhdGljIHVybEZvcm1hdChvYmopIHtcclxuICAgICAgICAvLyBlbnN1cmUgaXQncyBhbiBvYmplY3QsIGFuZCBub3QgYSBzdHJpbmcgdXJsLlxyXG4gICAgICAgIC8vIElmIGl0J3MgYW4gb2JqLCB0aGlzIGlzIGEgbm8tb3AuXHJcbiAgICAgICAgLy8gdGhpcyB3YXksIHlvdSBjYW4gY2FsbCB1cmxfZm9ybWF0KCkgb24gc3RyaW5nc1xyXG4gICAgICAgIC8vIHRvIGNsZWFuIHVwIHBvdGVudGlhbGx5IHdvbmt5IHVybHMuXHJcbiAgICAgICAgaWYgKFV0aWxzU2V0dGluZ3NfMS5VdGlsc1NldHRpbmdzLnV0aWwuaXNTdHJpbmcob2JqKSkge1xyXG4gICAgICAgICAgICBvYmogPSBVcmwudXJsUGFyc2Uob2JqKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCEob2JqIGluc3RhbmNlb2YgVXJsKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gVXJsLnByb3RvdHlwZS5mb3JtYXQuY2FsbChvYmopO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gb2JqLmZvcm1hdCgpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIHVybFJlc29sdmVPYmplY3Qoc291cmNlLCByZWxhdGl2ZSkge1xyXG4gICAgICAgIGlmICghc291cmNlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiByZWxhdGl2ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFVybC51cmxQYXJzZShzb3VyY2UsIGZhbHNlLCB0cnVlKS5yZXNvbHZlT2JqZWN0KHJlbGF0aXZlKTtcclxuICAgIH1cclxuICAgIHN0YXRpYyB1cmxSZXNvbHZlKHNvdXJjZSwgcmVsYXRpdmUpIHtcclxuICAgICAgICByZXR1cm4gVXJsLnVybFBhcnNlKHNvdXJjZSwgZmFsc2UsIHRydWUpLnJlc29sdmUocmVsYXRpdmUpO1xyXG4gICAgfVxyXG4gICAgcmVzb2x2ZU9iamVjdChyZWxhdGl2ZSkge1xyXG4gICAgICAgIGlmIChVdGlsc1NldHRpbmdzXzEuVXRpbHNTZXR0aW5ncy51dGlsLmlzU3RyaW5nKHJlbGF0aXZlKSkge1xyXG4gICAgICAgICAgICB2YXIgcmVsID0gbmV3IFVybCgpO1xyXG4gICAgICAgICAgICByZWwucGFyc2UocmVsYXRpdmUsIGZhbHNlLCB0cnVlKTtcclxuICAgICAgICAgICAgcmVsYXRpdmUgPSByZWw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciByZXN1bHQgPSBuZXcgVXJsKCk7XHJcbiAgICAgICAgdmFyIHRrZXlzID0gT2JqZWN0LmtleXModGhpcyk7XHJcbiAgICAgICAgZm9yICh2YXIgdGsgPSAwOyB0ayA8IHRrZXlzLmxlbmd0aDsgdGsrKykge1xyXG4gICAgICAgICAgICB2YXIgdGtleSA9IHRrZXlzW3RrXTtcclxuICAgICAgICAgICAgcmVzdWx0W3RrZXldID0gdGhpc1t0a2V5XTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gaGFzaCBpcyBhbHdheXMgb3ZlcnJpZGRlbiwgbm8gbWF0dGVyIHdoYXQuXHJcbiAgICAgICAgLy8gZXZlbiBocmVmPVwiXCIgd2lsbCByZW1vdmUgaXQuXHJcbiAgICAgICAgcmVzdWx0Lmhhc2ggPSByZWxhdGl2ZS5oYXNoO1xyXG4gICAgICAgIC8vIGlmIHRoZSByZWxhdGl2ZSB1cmwgaXMgZW1wdHksIHRoZW4gdGhlcmUncyBub3RoaW5nIGxlZnQgdG8gZG8gaGVyZS5cclxuICAgICAgICBpZiAocmVsYXRpdmUuaHJlZiA9PT0gJycpIHtcclxuICAgICAgICAgICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGhyZWZzIGxpa2UgLy9mb28vYmFyIGFsd2F5cyBjdXQgdG8gdGhlIHByb3RvY29sLlxyXG4gICAgICAgIGlmIChyZWxhdGl2ZS5zbGFzaGVzICYmICFyZWxhdGl2ZS5wcm90b2NvbCkge1xyXG4gICAgICAgICAgICAvLyB0YWtlIGV2ZXJ5dGhpbmcgZXhjZXB0IHRoZSBwcm90b2NvbCBmcm9tIHJlbGF0aXZlXHJcbiAgICAgICAgICAgIHZhciBya2V5cyA9IE9iamVjdC5rZXlzKHJlbGF0aXZlKTtcclxuICAgICAgICAgICAgZm9yICh2YXIgcmsgPSAwOyByayA8IHJrZXlzLmxlbmd0aDsgcmsrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHJrZXkgPSBya2V5c1tya107XHJcbiAgICAgICAgICAgICAgICBpZiAocmtleSAhPT0gJ3Byb3RvY29sJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtya2V5XSA9IHJlbGF0aXZlW3JrZXldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vdXJsUGFyc2UgYXBwZW5kcyB0cmFpbGluZyAvIHRvIHVybHMgbGlrZSBodHRwOi8vd3d3LmV4YW1wbGUuY29tXHJcbiAgICAgICAgICAgIGlmIChVcmwuc2xhc2hlZFByb3RvY29sW3Jlc3VsdC5wcm90b2NvbF0gJiZcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5ob3N0bmFtZSAmJiAhcmVzdWx0LnBhdGhuYW1lKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQucGF0aCA9IHJlc3VsdC5wYXRobmFtZSA9ICcvJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJlbGF0aXZlLnByb3RvY29sICYmIHJlbGF0aXZlLnByb3RvY29sICE9PSByZXN1bHQucHJvdG9jb2wpIHtcclxuICAgICAgICAgICAgLy8gaWYgaXQncyBhIGtub3duIHVybCBwcm90b2NvbCwgdGhlbiBjaGFuZ2luZ1xyXG4gICAgICAgICAgICAvLyB0aGUgcHJvdG9jb2wgZG9lcyB3ZWlyZCB0aGluZ3NcclxuICAgICAgICAgICAgLy8gZmlyc3QsIGlmIGl0J3Mgbm90IGZpbGU6LCB0aGVuIHdlIE1VU1QgaGF2ZSBhIGhvc3QsXHJcbiAgICAgICAgICAgIC8vIGFuZCBpZiB0aGVyZSB3YXMgYSBwYXRoXHJcbiAgICAgICAgICAgIC8vIHRvIGJlZ2luIHdpdGgsIHRoZW4gd2UgTVVTVCBoYXZlIGEgcGF0aC5cclxuICAgICAgICAgICAgLy8gaWYgaXQgaXMgZmlsZTosIHRoZW4gdGhlIGhvc3QgaXMgZHJvcHBlZCxcclxuICAgICAgICAgICAgLy8gYmVjYXVzZSB0aGF0J3Mga25vd24gdG8gYmUgaG9zdGxlc3MuXHJcbiAgICAgICAgICAgIC8vIGFueXRoaW5nIGVsc2UgaXMgYXNzdW1lZCB0byBiZSBhYnNvbHV0ZS5cclxuICAgICAgICAgICAgaWYgKCFVcmwuc2xhc2hlZFByb3RvY29sW3JlbGF0aXZlLnByb3RvY29sXSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhyZWxhdGl2ZSk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciB2ID0gMDsgdiA8IGtleXMubGVuZ3RoOyB2KyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgayA9IGtleXNbdl07XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2tdID0gcmVsYXRpdmVba107XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmVzdWx0LnByb3RvY29sID0gcmVsYXRpdmUucHJvdG9jb2w7XHJcbiAgICAgICAgICAgIGlmICghcmVsYXRpdmUuaG9zdCAmJiAhVXJsLmhvc3RsZXNzUHJvdG9jb2xbcmVsYXRpdmUucHJvdG9jb2xdKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVsUGF0aCA9IChyZWxhdGl2ZS5wYXRobmFtZSB8fCAnJykuc3BsaXQoJy8nKTtcclxuICAgICAgICAgICAgICAgIHdoaWxlIChyZWxQYXRoLmxlbmd0aCAmJiAhKHJlbGF0aXZlLmhvc3QgPSByZWxQYXRoLnNoaWZ0KCkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCFyZWxhdGl2ZS5ob3N0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVsYXRpdmUuaG9zdCA9ICcnO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCFyZWxhdGl2ZS5ob3N0bmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbGF0aXZlLmhvc3RuYW1lID0gJyc7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAocmVsUGF0aFswXSAhPT0gJycpIHtcclxuICAgICAgICAgICAgICAgICAgICByZWxQYXRoLnVuc2hpZnQoJycpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHJlbFBhdGgubGVuZ3RoIDwgMikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbFBhdGgudW5zaGlmdCgnJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXN1bHQucGF0aG5hbWUgPSByZWxQYXRoLmpvaW4oJy8nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5wYXRobmFtZSA9IHJlbGF0aXZlLnBhdGhuYW1lO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XHJcbiAgICAgICAgICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xyXG4gICAgICAgICAgICByZXN1bHQuaG9zdCA9IHJlbGF0aXZlLmhvc3QgfHwgJyc7XHJcbiAgICAgICAgICAgIHJlc3VsdC5hdXRoID0gcmVsYXRpdmUuYXV0aDtcclxuICAgICAgICAgICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVsYXRpdmUuaG9zdG5hbWUgfHwgcmVsYXRpdmUuaG9zdDtcclxuICAgICAgICAgICAgcmVzdWx0LnBvcnQgPSByZWxhdGl2ZS5wb3J0O1xyXG4gICAgICAgICAgICAvLyB0byBzdXBwb3J0IGh0dHAucmVxdWVzdFxyXG4gICAgICAgICAgICBpZiAocmVzdWx0LnBhdGhuYW1lIHx8IHJlc3VsdC5zZWFyY2gpIHtcclxuICAgICAgICAgICAgICAgIHZhciBwID0gcmVzdWx0LnBhdGhuYW1lIHx8ICcnO1xyXG4gICAgICAgICAgICAgICAgdmFyIHMgPSByZXN1bHQuc2VhcmNoIHx8ICcnO1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LnBhdGggPSBwICsgcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXN1bHQuc2xhc2hlcyA9IHJlc3VsdC5zbGFzaGVzIHx8IHJlbGF0aXZlLnNsYXNoZXM7XHJcbiAgICAgICAgICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgaXNTb3VyY2VBYnMgPSAocmVzdWx0LnBhdGhuYW1lICYmIHJlc3VsdC5wYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJyksIGlzUmVsQWJzID0gKHJlbGF0aXZlLmhvc3QgfHxcclxuICAgICAgICAgICAgcmVsYXRpdmUucGF0aG5hbWUgJiYgcmVsYXRpdmUucGF0aG5hbWUuY2hhckF0KDApID09PSAnLycpLCBtdXN0RW5kQWJzID0gKGlzUmVsQWJzIHx8IGlzU291cmNlQWJzIHx8XHJcbiAgICAgICAgICAgIChyZXN1bHQuaG9zdCAmJiByZWxhdGl2ZS5wYXRobmFtZSkpLCByZW1vdmVBbGxEb3RzID0gbXVzdEVuZEFicywgc3JjUGF0aCA9IHJlc3VsdC5wYXRobmFtZSAmJiByZXN1bHQucGF0aG5hbWUuc3BsaXQoJy8nKSB8fCBbXSwgcmVsUGF0aCA9IHJlbGF0aXZlLnBhdGhuYW1lICYmIHJlbGF0aXZlLnBhdGhuYW1lLnNwbGl0KCcvJykgfHwgW10sIHBzeWNob3RpYyA9IHJlc3VsdC5wcm90b2NvbCAmJiAhVXJsLnNsYXNoZWRQcm90b2NvbFtyZXN1bHQucHJvdG9jb2xdO1xyXG4gICAgICAgIC8vIGlmIHRoZSB1cmwgaXMgYSBub24tc2xhc2hlZCB1cmwsIHRoZW4gcmVsYXRpdmVcclxuICAgICAgICAvLyBsaW5rcyBsaWtlIC4uLy4uIHNob3VsZCBiZSBhYmxlXHJcbiAgICAgICAgLy8gdG8gY3Jhd2wgdXAgdG8gdGhlIGhvc3RuYW1lLCBhcyB3ZWxsLiAgVGhpcyBpcyBzdHJhbmdlLlxyXG4gICAgICAgIC8vIHJlc3VsdC5wcm90b2NvbCBoYXMgYWxyZWFkeSBiZWVuIHNldCBieSBub3cuXHJcbiAgICAgICAgLy8gTGF0ZXIgb24sIHB1dCB0aGUgZmlyc3QgcGF0aCBwYXJ0IGludG8gdGhlIGhvc3QgZmllbGQuXHJcbiAgICAgICAgaWYgKHBzeWNob3RpYykge1xyXG4gICAgICAgICAgICByZXN1bHQuaG9zdG5hbWUgPSAnJztcclxuICAgICAgICAgICAgcmVzdWx0LnBvcnQgPSBudWxsO1xyXG4gICAgICAgICAgICBpZiAocmVzdWx0Lmhvc3QpIHtcclxuICAgICAgICAgICAgICAgIGlmIChzcmNQYXRoWzBdID09PSAnJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHNyY1BhdGhbMF0gPSByZXN1bHQuaG9zdDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHNyY1BhdGgudW5zaGlmdChyZXN1bHQuaG9zdCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmVzdWx0Lmhvc3QgPSAnJztcclxuICAgICAgICAgICAgaWYgKHJlbGF0aXZlLnByb3RvY29sKSB7XHJcbiAgICAgICAgICAgICAgICByZWxhdGl2ZS5ob3N0bmFtZSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICByZWxhdGl2ZS5wb3J0ID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIGlmIChyZWxhdGl2ZS5ob3N0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlbFBhdGhbMF0gPT09ICcnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbFBhdGhbMF0gPSByZWxhdGl2ZS5ob3N0O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVsUGF0aC51bnNoaWZ0KHJlbGF0aXZlLmhvc3QpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJlbGF0aXZlLmhvc3QgPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG11c3RFbmRBYnMgPSBtdXN0RW5kQWJzICYmIChyZWxQYXRoWzBdID09PSAnJyB8fCBzcmNQYXRoWzBdID09PSAnJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc1JlbEFicykge1xyXG4gICAgICAgICAgICAvLyBpdCdzIGFic29sdXRlLlxyXG4gICAgICAgICAgICByZXN1bHQuaG9zdCA9IChyZWxhdGl2ZS5ob3N0IHx8IHJlbGF0aXZlLmhvc3QgPT09ICcnKSA/XHJcbiAgICAgICAgICAgICAgICByZWxhdGl2ZS5ob3N0IDogcmVzdWx0Lmhvc3Q7XHJcbiAgICAgICAgICAgIHJlc3VsdC5ob3N0bmFtZSA9IChyZWxhdGl2ZS5ob3N0bmFtZSB8fCByZWxhdGl2ZS5ob3N0bmFtZSA9PT0gJycpID9cclxuICAgICAgICAgICAgICAgIHJlbGF0aXZlLmhvc3RuYW1lIDogcmVzdWx0Lmhvc3RuYW1lO1xyXG4gICAgICAgICAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xyXG4gICAgICAgICAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcclxuICAgICAgICAgICAgc3JjUGF0aCA9IHJlbFBhdGg7XHJcbiAgICAgICAgICAgIC8vIGZhbGwgdGhyb3VnaCB0byB0aGUgZG90LWhhbmRsaW5nIGJlbG93LlxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChyZWxQYXRoLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAvLyBpdCdzIHJlbGF0aXZlXHJcbiAgICAgICAgICAgIC8vIHRocm93IGF3YXkgdGhlIGV4aXN0aW5nIGZpbGUsIGFuZCB0YWtlIHRoZSBuZXcgcGF0aCBpbnN0ZWFkLlxyXG4gICAgICAgICAgICBpZiAoIXNyY1BhdGgpIHtcclxuICAgICAgICAgICAgICAgIHNyY1BhdGggPSBbXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzcmNQYXRoLnBvcCgpO1xyXG4gICAgICAgICAgICBzcmNQYXRoID0gc3JjUGF0aC5jb25jYXQocmVsUGF0aCk7XHJcbiAgICAgICAgICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XHJcbiAgICAgICAgICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICghVXRpbHNTZXR0aW5nc18xLlV0aWxzU2V0dGluZ3MudXRpbC5pc051bGxPclVuZGVmaW5lZChyZWxhdGl2ZS5zZWFyY2gpKSB7XHJcbiAgICAgICAgICAgIC8vIGp1c3QgcHVsbCBvdXQgdGhlIHNlYXJjaC5cclxuICAgICAgICAgICAgLy8gbGlrZSBocmVmPSc/Zm9vJy5cclxuICAgICAgICAgICAgLy8gUHV0IHRoaXMgYWZ0ZXIgdGhlIG90aGVyIHR3byBjYXNlcyBiZWNhdXNlIGl0IHNpbXBsaWZpZXMgdGhlIGJvb2xlYW5zXHJcbiAgICAgICAgICAgIGlmIChwc3ljaG90aWMpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlc3VsdC5ob3N0ID0gc3JjUGF0aC5zaGlmdCgpO1xyXG4gICAgICAgICAgICAgICAgLy9vY2NhdGlvbmFseSB0aGUgYXV0aCBjYW4gZ2V0IHN0dWNrIG9ubHkgaW4gaG9zdFxyXG4gICAgICAgICAgICAgICAgLy90aGlzIGVzcGVjaWFsbHkgaGFwcGVucyBpbiBjYXNlcyBsaWtlXHJcbiAgICAgICAgICAgICAgICAvL3VybC5yZXNvbHZlT2JqZWN0KCdtYWlsdG86bG9jYWwxQGRvbWFpbjEnLCAnbG9jYWwyQGRvbWFpbjInKVxyXG4gICAgICAgICAgICAgICAgdmFyIGF1dGhJbkhvc3QgPSByZXN1bHQuaG9zdCAmJiByZXN1bHQuaG9zdC5pbmRleE9mKCdAJykgPiAwID9cclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQuaG9zdC5zcGxpdCgnQCcpIDogZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBpZiAoYXV0aEluSG9zdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hdXRoID0gYXV0aEluSG9zdC5zaGlmdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5ob3N0ID0gcmVzdWx0Lmhvc3RuYW1lID0gYXV0aEluSG9zdC5zaGlmdCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XHJcbiAgICAgICAgICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xyXG4gICAgICAgICAgICAvL3RvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XHJcbiAgICAgICAgICAgIGlmICghVXRpbHNTZXR0aW5nc18xLlV0aWxzU2V0dGluZ3MudXRpbC5pc051bGwocmVzdWx0LnBhdGhuYW1lKSB8fCAhVXRpbHNTZXR0aW5nc18xLlV0aWxzU2V0dGluZ3MudXRpbC5pc051bGwocmVzdWx0LnNlYXJjaCkpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5wYXRoID0gKHJlc3VsdC5wYXRobmFtZSA/IHJlc3VsdC5wYXRobmFtZSA6ICcnKSArXHJcbiAgICAgICAgICAgICAgICAgICAgKHJlc3VsdC5zZWFyY2ggPyByZXN1bHQuc2VhcmNoIDogJycpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXNyY1BhdGgubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIC8vIG5vIHBhdGggYXQgYWxsLiAgZWFzeS5cclxuICAgICAgICAgICAgLy8gd2UndmUgYWxyZWFkeSBoYW5kbGVkIHRoZSBvdGhlciBzdHVmZiBhYm92ZS5cclxuICAgICAgICAgICAgcmVzdWx0LnBhdGhuYW1lID0gbnVsbDtcclxuICAgICAgICAgICAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxyXG4gICAgICAgICAgICBpZiAocmVzdWx0LnNlYXJjaCkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LnBhdGggPSAnLycgKyByZXN1bHQuc2VhcmNoO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LnBhdGggPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBpZiBhIHVybCBFTkRzIGluIC4gb3IgLi4sIHRoZW4gaXQgbXVzdCBnZXQgYSB0cmFpbGluZyBzbGFzaC5cclxuICAgICAgICAvLyBob3dldmVyLCBpZiBpdCBlbmRzIGluIGFueXRoaW5nIGVsc2Ugbm9uLXNsYXNoeSxcclxuICAgICAgICAvLyB0aGVuIGl0IG11c3QgTk9UIGdldCBhIHRyYWlsaW5nIHNsYXNoLlxyXG4gICAgICAgIHZhciBsYXN0ID0gc3JjUGF0aC5zbGljZSgtMSlbMF07XHJcbiAgICAgICAgdmFyIGhhc1RyYWlsaW5nU2xhc2ggPSAoKHJlc3VsdC5ob3N0IHx8IHJlbGF0aXZlLmhvc3QgfHwgc3JjUGF0aC5sZW5ndGggPiAxKSAmJlxyXG4gICAgICAgICAgICAobGFzdCA9PT0gJy4nIHx8IGxhc3QgPT09ICcuLicpIHx8IGxhc3QgPT09ICcnKTtcclxuICAgICAgICAvLyBzdHJpcCBzaW5nbGUgZG90cywgcmVzb2x2ZSBkb3VibGUgZG90cyB0byBwYXJlbnQgZGlyXHJcbiAgICAgICAgLy8gaWYgdGhlIHBhdGggdHJpZXMgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIGB1cGAgZW5kcyB1cCA+IDBcclxuICAgICAgICB2YXIgdXAgPSAwO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSBzcmNQYXRoLmxlbmd0aDsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICAgICAgbGFzdCA9IHNyY1BhdGhbaV07XHJcbiAgICAgICAgICAgIGlmIChsYXN0ID09PSAnLicpIHtcclxuICAgICAgICAgICAgICAgIHNyY1BhdGguc3BsaWNlKGksIDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGxhc3QgPT09ICcuLicpIHtcclxuICAgICAgICAgICAgICAgIHNyY1BhdGguc3BsaWNlKGksIDEpO1xyXG4gICAgICAgICAgICAgICAgdXArKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh1cCkge1xyXG4gICAgICAgICAgICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSk7XHJcbiAgICAgICAgICAgICAgICB1cC0tO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGlmIHRoZSBwYXRoIGlzIGFsbG93ZWQgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIHJlc3RvcmUgbGVhZGluZyAuLnNcclxuICAgICAgICBpZiAoIW11c3RFbmRBYnMgJiYgIXJlbW92ZUFsbERvdHMpIHtcclxuICAgICAgICAgICAgZm9yICg7IHVwLS07IHVwKSB7XHJcbiAgICAgICAgICAgICAgICBzcmNQYXRoLnVuc2hpZnQoJy4uJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG11c3RFbmRBYnMgJiYgc3JjUGF0aFswXSAhPT0gJycgJiZcclxuICAgICAgICAgICAgKCFzcmNQYXRoWzBdIHx8IHNyY1BhdGhbMF0uY2hhckF0KDApICE9PSAnLycpKSB7XHJcbiAgICAgICAgICAgIHNyY1BhdGgudW5zaGlmdCgnJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChoYXNUcmFpbGluZ1NsYXNoICYmIChzcmNQYXRoLmpvaW4oJy8nKS5zdWJzdHIoLTEpICE9PSAnLycpKSB7XHJcbiAgICAgICAgICAgIHNyY1BhdGgucHVzaCgnJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBpc0Fic29sdXRlID0gc3JjUGF0aFswXSA9PT0gJycgfHxcclxuICAgICAgICAgICAgKHNyY1BhdGhbMF0gJiYgc3JjUGF0aFswXS5jaGFyQXQoMCkgPT09ICcvJyk7XHJcbiAgICAgICAgLy8gcHV0IHRoZSBob3N0IGJhY2tcclxuICAgICAgICBpZiAocHN5Y2hvdGljKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlc3VsdC5ob3N0ID0gaXNBYnNvbHV0ZSA/ICcnIDpcclxuICAgICAgICAgICAgICAgIHNyY1BhdGgubGVuZ3RoID8gc3JjUGF0aC5zaGlmdCgpIDogJyc7XHJcbiAgICAgICAgICAgIC8vb2NjYXRpb25hbHkgdGhlIGF1dGggY2FuIGdldCBzdHVjayBvbmx5IGluIGhvc3RcclxuICAgICAgICAgICAgLy90aGlzIGVzcGVjaWFsbHkgaGFwcGVucyBpbiBjYXNlcyBsaWtlXHJcbiAgICAgICAgICAgIC8vdXJsLnJlc29sdmVPYmplY3QoJ21haWx0bzpsb2NhbDFAZG9tYWluMScsICdsb2NhbDJAZG9tYWluMicpXHJcbiAgICAgICAgICAgIHZhciBhdXRoSW5Ib3N0ID0gcmVzdWx0Lmhvc3QgJiYgcmVzdWx0Lmhvc3QuaW5kZXhPZignQCcpID4gMCA/XHJcbiAgICAgICAgICAgICAgICByZXN1bHQuaG9zdC5zcGxpdCgnQCcpIDogZmFsc2U7XHJcbiAgICAgICAgICAgIGlmIChhdXRoSW5Ib3N0KSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQuYXV0aCA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcclxuICAgICAgICAgICAgICAgIHJlc3VsdC5ob3N0ID0gcmVzdWx0Lmhvc3RuYW1lID0gYXV0aEluSG9zdC5zaGlmdCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG11c3RFbmRBYnMgPSBtdXN0RW5kQWJzIHx8IChyZXN1bHQuaG9zdCAmJiBzcmNQYXRoLmxlbmd0aCk7XHJcbiAgICAgICAgaWYgKG11c3RFbmRBYnMgJiYgIWlzQWJzb2x1dGUpIHtcclxuICAgICAgICAgICAgc3JjUGF0aC51bnNoaWZ0KCcnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFzcmNQYXRoLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXN1bHQucGF0aG5hbWUgPSBudWxsO1xyXG4gICAgICAgICAgICByZXN1bHQucGF0aCA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXN1bHQucGF0aG5hbWUgPSBzcmNQYXRoLmpvaW4oJy8nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy90byBzdXBwb3J0IHJlcXVlc3QuaHR0cFxyXG4gICAgICAgIGlmICghVXRpbHNTZXR0aW5nc18xLlV0aWxzU2V0dGluZ3MudXRpbC5pc051bGwocmVzdWx0LnBhdGhuYW1lKSB8fCAhVXRpbHNTZXR0aW5nc18xLlV0aWxzU2V0dGluZ3MudXRpbC5pc051bGwocmVzdWx0LnNlYXJjaCkpIHtcclxuICAgICAgICAgICAgcmVzdWx0LnBhdGggPSAocmVzdWx0LnBhdGhuYW1lID8gcmVzdWx0LnBhdGhuYW1lIDogJycpICtcclxuICAgICAgICAgICAgICAgIChyZXN1bHQuc2VhcmNoID8gcmVzdWx0LnNlYXJjaCA6ICcnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVzdWx0LmF1dGggPSByZWxhdGl2ZS5hdXRoIHx8IHJlc3VsdC5hdXRoO1xyXG4gICAgICAgIHJlc3VsdC5zbGFzaGVzID0gcmVzdWx0LnNsYXNoZXMgfHwgcmVsYXRpdmUuc2xhc2hlcztcclxuICAgICAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgc3RhdGljIHVybFBhcnNlKHVybCwgcGFyc2VRdWVyeVN0cmluZyA9IG51bGwsIHNsYXNoZXNEZW5vdGVIb3N0ID0gbnVsbCkge1xyXG4gICAgICAgIGlmICh1cmwgJiYgVXRpbHNTZXR0aW5nc18xLlV0aWxzU2V0dGluZ3MudXRpbC5pc09iamVjdCh1cmwpICYmIHVybCBpbnN0YW5jZW9mIFVybCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdXJsO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgdSA9IG5ldyBVcmw7XHJcbiAgICAgICAgdS5wYXJzZSh1cmwsIHBhcnNlUXVlcnlTdHJpbmcsIHNsYXNoZXNEZW5vdGVIb3N0KTtcclxuICAgICAgICByZXR1cm4gdTtcclxuICAgIH1cclxuICAgIHJlc29sdmUocmVsYXRpdmUpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yZXNvbHZlT2JqZWN0KFVybC51cmxQYXJzZShyZWxhdGl2ZSwgZmFsc2UsIHRydWUpKS5mb3JtYXQoKTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIHBhcnNlSG9zdCgpIHtcclxuICAgICAgICB2YXIgaG9zdCA9IHRoaXMuaG9zdDtcclxuICAgICAgICB2YXIgcG9ydCA9IFVybC5wb3J0UGF0dGVybi5leGVjKGhvc3QpO1xyXG4gICAgICAgIGlmIChwb3J0KSB7XHJcbiAgICAgICAgICAgIHBvcnQgPSBwb3J0WzBdO1xyXG4gICAgICAgICAgICBpZiAocG9ydCAhPT0gJzonKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBvcnQgPSBwb3J0LnN1YnN0cigxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBob3N0ID0gaG9zdC5zdWJzdHIoMCwgaG9zdC5sZW5ndGggLSBwb3J0Lmxlbmd0aCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChob3N0KSB7XHJcbiAgICAgICAgICAgIHRoaXMuaG9zdG5hbWUgPSBob3N0O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIDtcclxuICAgIHBhcnNlKHVybCwgcGFyc2VRdWVyeVN0cmluZyA9IG51bGwsIHNsYXNoZXNEZW5vdGVIb3N0ID0gbnVsbCkge1xyXG4gICAgICAgIGlmICghVXRpbHNTZXR0aW5nc18xLlV0aWxzU2V0dGluZ3MudXRpbC5pc1N0cmluZyh1cmwpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQYXJhbWV0ZXIgJ3VybCcgbXVzdCBiZSBhIHN0cmluZywgbm90IFwiICsgdHlwZW9mIHVybCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIENvcHkgY2hyb21lLCBJRSwgb3BlcmEgYmFja3NsYXNoLWhhbmRsaW5nIGJlaGF2aW9yLlxyXG4gICAgICAgIC8vIEJhY2sgc2xhc2hlcyBiZWZvcmUgdGhlIHF1ZXJ5IHN0cmluZyBnZXQgY29udmVydGVkIHRvIGZvcndhcmQgc2xhc2hlc1xyXG4gICAgICAgIC8vIFNlZTogaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTI1OTE2XHJcbiAgICAgICAgdmFyIHF1ZXJ5SW5kZXggPSB1cmwuaW5kZXhPZignPycpLCBzcGxpdHRlciA9IChxdWVyeUluZGV4ICE9PSAtMSAmJiBxdWVyeUluZGV4IDwgdXJsLmluZGV4T2YoJyMnKSkgPyAnPycgOiAnIycsIHVTcGxpdCA9IHVybC5zcGxpdChzcGxpdHRlciksIHNsYXNoUmVnZXggPSAvXFxcXC9nO1xyXG4gICAgICAgIHVTcGxpdFswXSA9IHVTcGxpdFswXS5yZXBsYWNlKHNsYXNoUmVnZXgsICcvJyk7XHJcbiAgICAgICAgdXJsID0gdVNwbGl0LmpvaW4oc3BsaXR0ZXIpO1xyXG4gICAgICAgIHZhciByZXN0ID0gdXJsO1xyXG4gICAgICAgIC8vIHRyaW0gYmVmb3JlIHByb2NlZWRpbmcuXHJcbiAgICAgICAgLy8gVGhpcyBpcyB0byBzdXBwb3J0IHBhcnNlIHN0dWZmIGxpa2UgXCIgIGh0dHA6Ly9mb28uY29tICBcXG5cIlxyXG4gICAgICAgIHJlc3QgPSByZXN0LnRyaW0oKTtcclxuICAgICAgICBpZiAoIXNsYXNoZXNEZW5vdGVIb3N0ICYmIHVybC5zcGxpdCgnIycpLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgICAgICAvLyBUcnkgZmFzdCBwYXRoIHJlZ2V4cFxyXG4gICAgICAgICAgICB2YXIgc2ltcGxlUGF0aCA9IFVybC5zaW1wbGVQYXRoUGF0dGVybi5leGVjKHJlc3QpO1xyXG4gICAgICAgICAgICBpZiAoc2ltcGxlUGF0aCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wYXRoID0gcmVzdDtcclxuICAgICAgICAgICAgICAgIHRoaXMuaHJlZiA9IHJlc3Q7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBhdGhuYW1lID0gc2ltcGxlUGF0aFsxXTtcclxuICAgICAgICAgICAgICAgIGlmIChzaW1wbGVQYXRoWzJdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWFyY2ggPSBzaW1wbGVQYXRoWzJdO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucXVlcnkgPSB0aGlzLnBhcnNlKHRoaXMuc2VhcmNoLnN1YnN0cigxKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnF1ZXJ5ID0gdGhpcy5zZWFyY2guc3Vic3RyKDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlYXJjaCA9ICcnO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucXVlcnkgPSB7fTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBwcm90byA9IFVybC5wcm90b2NvbFBhdHRlcm4uZXhlYyhyZXN0KTtcclxuICAgICAgICBpZiAocHJvdG8pIHtcclxuICAgICAgICAgICAgcHJvdG8gPSBwcm90b1swXTtcclxuICAgICAgICAgICAgdmFyIGxvd2VyUHJvdG8gPSBwcm90by50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgICAgICB0aGlzLnByb3RvY29sID0gbG93ZXJQcm90bztcclxuICAgICAgICAgICAgcmVzdCA9IHJlc3Quc3Vic3RyKHByb3RvLmxlbmd0aCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGZpZ3VyZSBvdXQgaWYgaXQncyBnb3QgYSBob3N0XHJcbiAgICAgICAgLy8gdXNlckBzZXJ2ZXIgaXMgKmFsd2F5cyogaW50ZXJwcmV0ZWQgYXMgYSBob3N0bmFtZSwgYW5kIHVybFxyXG4gICAgICAgIC8vIHJlc29sdXRpb24gd2lsbCB0cmVhdCAvL2Zvby9iYXIgYXMgaG9zdD1mb28scGF0aD1iYXIgYmVjYXVzZSB0aGF0J3NcclxuICAgICAgICAvLyBob3cgdGhlIGJyb3dzZXIgcmVzb2x2ZXMgcmVsYXRpdmUgVVJMcy5cclxuICAgICAgICBpZiAoc2xhc2hlc0Rlbm90ZUhvc3QgfHwgcHJvdG8gfHwgcmVzdC5tYXRjaCgvXlxcL1xcL1teQFxcL10rQFteQFxcL10rLykpIHtcclxuICAgICAgICAgICAgdmFyIHNsYXNoZXMgPSByZXN0LnN1YnN0cigwLCAyKSA9PT0gJy8vJztcclxuICAgICAgICAgICAgaWYgKHNsYXNoZXMgJiYgIShwcm90byAmJiBVcmwuaG9zdGxlc3NQcm90b2NvbFtwcm90b10pKSB7XHJcbiAgICAgICAgICAgICAgICByZXN0ID0gcmVzdC5zdWJzdHIoMik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNsYXNoZXMgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghVXJsLmhvc3RsZXNzUHJvdG9jb2xbcHJvdG9dICYmXHJcbiAgICAgICAgICAgIChzbGFzaGVzIHx8IChwcm90byAmJiAhVXJsLnNsYXNoZWRQcm90b2NvbFtwcm90b10pKSkge1xyXG4gICAgICAgICAgICAvLyB0aGVyZSdzIGEgaG9zdG5hbWUuXHJcbiAgICAgICAgICAgIC8vIHRoZSBmaXJzdCBpbnN0YW5jZSBvZiAvLCA/LCA7LCBvciAjIGVuZHMgdGhlIGhvc3QuXHJcbiAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIGFuIEAgaW4gdGhlIGhvc3RuYW1lLCB0aGVuIG5vbi1ob3N0IGNoYXJzICphcmUqIGFsbG93ZWRcclxuICAgICAgICAgICAgLy8gdG8gdGhlIGxlZnQgb2YgdGhlIGxhc3QgQCBzaWduLCB1bmxlc3Mgc29tZSBob3N0LWVuZGluZyBjaGFyYWN0ZXJcclxuICAgICAgICAgICAgLy8gY29tZXMgKmJlZm9yZSogdGhlIEAtc2lnbi5cclxuICAgICAgICAgICAgLy8gVVJMcyBhcmUgb2Jub3hpb3VzLlxyXG4gICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAvLyBleDpcclxuICAgICAgICAgICAgLy8gaHR0cDovL2FAYkBjLyA9PiB1c2VyOmFAYiBob3N0OmNcclxuICAgICAgICAgICAgLy8gaHR0cDovL2FAYj9AYyA9PiB1c2VyOmEgaG9zdDpjIHBhdGg6Lz9AY1xyXG4gICAgICAgICAgICAvLyB2MC4xMiBUT0RPKGlzYWFjcyk6IFRoaXMgaXMgbm90IHF1aXRlIGhvdyBDaHJvbWUgZG9lcyB0aGluZ3MuXHJcbiAgICAgICAgICAgIC8vIFJldmlldyBvdXIgdGVzdCBjYXNlIGFnYWluc3QgYnJvd3NlcnMgbW9yZSBjb21wcmVoZW5zaXZlbHkuXHJcbiAgICAgICAgICAgIC8vIGZpbmQgdGhlIGZpcnN0IGluc3RhbmNlIG9mIGFueSBob3N0RW5kaW5nQ2hhcnNcclxuICAgICAgICAgICAgdmFyIGhvc3RFbmQgPSAtMTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBVcmwuaG9zdEVuZGluZ0NoYXJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaGVjID0gcmVzdC5pbmRleE9mKFVybC5ob3N0RW5kaW5nQ2hhcnNbaV0pO1xyXG4gICAgICAgICAgICAgICAgaWYgKGhlYyAhPT0gLTEgJiYgKGhvc3RFbmQgPT09IC0xIHx8IGhlYyA8IGhvc3RFbmQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaG9zdEVuZCA9IGhlYztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBhdCB0aGlzIHBvaW50LCBlaXRoZXIgd2UgaGF2ZSBhbiBleHBsaWNpdCBwb2ludCB3aGVyZSB0aGVcclxuICAgICAgICAgICAgLy8gYXV0aCBwb3J0aW9uIGNhbm5vdCBnbyBwYXN0LCBvciB0aGUgbGFzdCBAIGNoYXIgaXMgdGhlIGRlY2lkZXIuXHJcbiAgICAgICAgICAgIHZhciBhdXRoLCBhdFNpZ247XHJcbiAgICAgICAgICAgIGlmIChob3N0RW5kID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgLy8gYXRTaWduIGNhbiBiZSBhbnl3aGVyZS5cclxuICAgICAgICAgICAgICAgIGF0U2lnbiA9IHJlc3QubGFzdEluZGV4T2YoJ0AnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIGF0U2lnbiBtdXN0IGJlIGluIGF1dGggcG9ydGlvbi5cclxuICAgICAgICAgICAgICAgIC8vIGh0dHA6Ly9hQGIvY0BkID0+IGhvc3Q6YiBhdXRoOmEgcGF0aDovY0BkXHJcbiAgICAgICAgICAgICAgICBhdFNpZ24gPSByZXN0Lmxhc3RJbmRleE9mKCdAJywgaG9zdEVuZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gTm93IHdlIGhhdmUgYSBwb3J0aW9uIHdoaWNoIGlzIGRlZmluaXRlbHkgdGhlIGF1dGguXHJcbiAgICAgICAgICAgIC8vIFB1bGwgdGhhdCBvZmYuXHJcbiAgICAgICAgICAgIGlmIChhdFNpZ24gIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICBhdXRoID0gcmVzdC5zbGljZSgwLCBhdFNpZ24pO1xyXG4gICAgICAgICAgICAgICAgcmVzdCA9IHJlc3Quc2xpY2UoYXRTaWduICsgMSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmF1dGggPSBkZWNvZGVVUklDb21wb25lbnQoYXV0aCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gdGhlIGhvc3QgaXMgdGhlIHJlbWFpbmluZyB0byB0aGUgbGVmdCBvZiB0aGUgZmlyc3Qgbm9uLWhvc3QgY2hhclxyXG4gICAgICAgICAgICBob3N0RW5kID0gLTE7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgVXJsLm5vbkhvc3RDaGFycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGhlYyA9IHJlc3QuaW5kZXhPZihVcmwubm9uSG9zdENoYXJzW2ldKTtcclxuICAgICAgICAgICAgICAgIGlmIChoZWMgIT09IC0xICYmIChob3N0RW5kID09PSAtMSB8fCBoZWMgPCBob3N0RW5kKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGhvc3RFbmQgPSBoZWM7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gaWYgd2Ugc3RpbGwgaGF2ZSBub3QgaGl0IGl0LCB0aGVuIHRoZSBlbnRpcmUgdGhpbmcgaXMgYSBob3N0LlxyXG4gICAgICAgICAgICBpZiAoaG9zdEVuZCA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIGhvc3RFbmQgPSByZXN0Lmxlbmd0aDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmhvc3QgPSByZXN0LnNsaWNlKDAsIGhvc3RFbmQpO1xyXG4gICAgICAgICAgICByZXN0ID0gcmVzdC5zbGljZShob3N0RW5kKTtcclxuICAgICAgICAgICAgLy8gcHVsbCBvdXQgcG9ydC5cclxuICAgICAgICAgICAgdGhpcy5wYXJzZUhvc3QoKTtcclxuICAgICAgICAgICAgLy8gd2UndmUgaW5kaWNhdGVkIHRoYXQgdGhlcmUgaXMgYSBob3N0bmFtZSxcclxuICAgICAgICAgICAgLy8gc28gZXZlbiBpZiBpdCdzIGVtcHR5LCBpdCBoYXMgdG8gYmUgcHJlc2VudC5cclxuICAgICAgICAgICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUgfHwgJyc7XHJcbiAgICAgICAgICAgIC8vIGlmIGhvc3RuYW1lIGJlZ2lucyB3aXRoIFsgYW5kIGVuZHMgd2l0aCBdXHJcbiAgICAgICAgICAgIC8vIGFzc3VtZSB0aGF0IGl0J3MgYW4gSVB2NiBhZGRyZXNzLlxyXG4gICAgICAgICAgICB2YXIgaXB2Nkhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZVswXSA9PT0gJ1snICYmXHJcbiAgICAgICAgICAgICAgICB0aGlzLmhvc3RuYW1lW3RoaXMuaG9zdG5hbWUubGVuZ3RoIC0gMV0gPT09ICddJztcclxuICAgICAgICAgICAgLy8gdmFsaWRhdGUgYSBsaXR0bGUuXHJcbiAgICAgICAgICAgIGlmICghaXB2Nkhvc3RuYW1lKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaG9zdHBhcnRzID0gdGhpcy5ob3N0bmFtZS5zcGxpdCgvXFwuLyk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGhvc3RwYXJ0cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcGFydCA9IGhvc3RwYXJ0c1tpXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXBhcnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghcGFydC5tYXRjaChVcmwuaG9zdG5hbWVQYXJ0UGF0dGVybikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5ld3BhcnQgPSAnJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDAsIGsgPSBwYXJ0Lmxlbmd0aDsgaiA8IGs7IGorKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnQuY2hhckNvZGVBdChqKSA+IDEyNykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIHJlcGxhY2Ugbm9uLUFTQ0lJIGNoYXIgd2l0aCBhIHRlbXBvcmFyeSBwbGFjZWhvbGRlclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIG5lZWQgdGhpcyB0byBtYWtlIHN1cmUgc2l6ZSBvZiBob3N0bmFtZSBpcyBub3RcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBicm9rZW4gYnkgcmVwbGFjaW5nIG5vbi1BU0NJSSBieSBub3RoaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3cGFydCArPSAneCc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdwYXJ0ICs9IHBhcnRbal07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UgdGVzdCBhZ2FpbiB3aXRoIEFTQ0lJIGNoYXIgb25seVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW5ld3BhcnQubWF0Y2goVXJsLmhvc3RuYW1lUGFydFBhdHRlcm4pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsaWRQYXJ0cyA9IGhvc3RwYXJ0cy5zbGljZSgwLCBpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBub3RIb3N0ID0gaG9zdHBhcnRzLnNsaWNlKGkgKyAxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBiaXQgPSBwYXJ0Lm1hdGNoKFVybC5ob3N0bmFtZVBhcnRTdGFydCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYml0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRQYXJ0cy5wdXNoKGJpdFsxXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm90SG9zdC51bnNoaWZ0KGJpdFsyXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobm90SG9zdC5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN0ID0gJy8nICsgbm90SG9zdC5qb2luKCcuJykgKyByZXN0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ob3N0bmFtZSA9IHZhbGlkUGFydHMuam9pbignLicpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuaG9zdG5hbWUubGVuZ3RoID4gVXJsLmhvc3RuYW1lTWF4TGVuKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmhvc3RuYW1lID0gJyc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBob3N0bmFtZXMgYXJlIGFsd2F5cyBsb3dlciBjYXNlLlxyXG4gICAgICAgICAgICAgICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIWlwdjZIb3N0bmFtZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gSUROQSBTdXBwb3J0OiBSZXR1cm5zIGEgcHVueWNvZGVkIHJlcHJlc2VudGF0aW9uIG9mIFwiZG9tYWluXCIuXHJcbiAgICAgICAgICAgICAgICAvLyBJdCBvbmx5IGNvbnZlcnRzIHBhcnRzIG9mIHRoZSBkb21haW4gbmFtZSB0aGF0XHJcbiAgICAgICAgICAgICAgICAvLyBoYXZlIG5vbi1BU0NJSSBjaGFyYWN0ZXJzLCBpLmUuIGl0IGRvZXNuJ3QgbWF0dGVyIGlmXHJcbiAgICAgICAgICAgICAgICAvLyB5b3UgY2FsbCBpdCB3aXRoIGEgZG9tYWluIHRoYXQgYWxyZWFkeSBpcyBBU0NJSS1vbmx5LlxyXG4gICAgICAgICAgICAgICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMudG9BU0NJSSh0aGlzLmhvc3RuYW1lKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgcCA9IHRoaXMucG9ydCA/ICc6JyArIHRoaXMucG9ydCA6ICcnO1xyXG4gICAgICAgICAgICB2YXIgaCA9IHRoaXMuaG9zdG5hbWUgfHwgJyc7XHJcbiAgICAgICAgICAgIHRoaXMuaG9zdCA9IGggKyBwO1xyXG4gICAgICAgICAgICB0aGlzLmhyZWYgKz0gdGhpcy5ob3N0O1xyXG4gICAgICAgICAgICAvLyBzdHJpcCBbIGFuZCBdIGZyb20gdGhlIGhvc3RuYW1lXHJcbiAgICAgICAgICAgIC8vIHRoZSBob3N0IGZpZWxkIHN0aWxsIHJldGFpbnMgdGhlbSwgdGhvdWdoXHJcbiAgICAgICAgICAgIGlmIChpcHY2SG9zdG5hbWUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lLnN1YnN0cigxLCB0aGlzLmhvc3RuYW1lLmxlbmd0aCAtIDIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlc3RbMF0gIT09ICcvJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3QgPSAnLycgKyByZXN0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIG5vdyByZXN0IGlzIHNldCB0byB0aGUgcG9zdC1ob3N0IHN0dWZmLlxyXG4gICAgICAgIC8vIGNob3Agb2ZmIGFueSBkZWxpbSBjaGFycy5cclxuICAgICAgICBpZiAoIVVybC51bnNhZmVQcm90b2NvbFtsb3dlclByb3RvXSkge1xyXG4gICAgICAgICAgICAvLyBGaXJzdCwgbWFrZSAxMDAlIHN1cmUgdGhhdCBhbnkgXCJhdXRvRXNjYXBlXCIgY2hhcnMgZ2V0XHJcbiAgICAgICAgICAgIC8vIGVzY2FwZWQsIGV2ZW4gaWYgZW5jb2RlVVJJQ29tcG9uZW50IGRvZXNuJ3QgdGhpbmsgdGhleVxyXG4gICAgICAgICAgICAvLyBuZWVkIHRvIGJlLlxyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IFVybC5hdXRvRXNjYXBlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGFlID0gVXJsLmF1dG9Fc2NhcGVbaV07XHJcbiAgICAgICAgICAgICAgICBpZiAocmVzdC5pbmRleE9mKGFlKSA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciBlc2MgPSBlbmNvZGVVUklDb21wb25lbnQoYWUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGVzYyA9PT0gYWUpIHtcclxuICAgICAgICAgICAgICAgICAgICBlc2MgPSBlc2NhcGUoYWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmVzdCA9IHJlc3Quc3BsaXQoYWUpLmpvaW4oZXNjKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBjaG9wIG9mZiBmcm9tIHRoZSB0YWlsIGZpcnN0LlxyXG4gICAgICAgIHZhciBoYXNoID0gcmVzdC5pbmRleE9mKCcjJyk7XHJcbiAgICAgICAgaWYgKGhhc2ggIT09IC0xKSB7XHJcbiAgICAgICAgICAgIC8vIGdvdCBhIGZyYWdtZW50IHN0cmluZy5cclxuICAgICAgICAgICAgdGhpcy5oYXNoID0gcmVzdC5zdWJzdHIoaGFzaCk7XHJcbiAgICAgICAgICAgIHJlc3QgPSByZXN0LnNsaWNlKDAsIGhhc2gpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcW0gPSByZXN0LmluZGV4T2YoJz8nKTtcclxuICAgICAgICBpZiAocW0gIT09IC0xKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2VhcmNoID0gcmVzdC5zdWJzdHIocW0pO1xyXG4gICAgICAgICAgICB0aGlzLnF1ZXJ5ID0gcmVzdC5zdWJzdHIocW0gKyAxKTtcclxuICAgICAgICAgICAgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucXVlcnkgPSB0aGlzLnBhcnNlKHRoaXMucXVlcnkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJlc3QgPSByZXN0LnNsaWNlKDAsIHFtKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAocGFyc2VRdWVyeVN0cmluZykge1xyXG4gICAgICAgICAgICAvLyBubyBxdWVyeSBzdHJpbmcsIGJ1dCBwYXJzZVF1ZXJ5U3RyaW5nIHN0aWxsIHJlcXVlc3RlZFxyXG4gICAgICAgICAgICB0aGlzLnNlYXJjaCA9ICcnO1xyXG4gICAgICAgICAgICB0aGlzLnF1ZXJ5ID0ge307XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChyZXN0KSB7XHJcbiAgICAgICAgICAgIHRoaXMucGF0aG5hbWUgPSByZXN0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoVXJsLnNsYXNoZWRQcm90b2NvbFtsb3dlclByb3RvXSAmJlxyXG4gICAgICAgICAgICB0aGlzLmhvc3RuYW1lICYmICF0aGlzLnBhdGhuYW1lKSB7XHJcbiAgICAgICAgICAgIHRoaXMucGF0aG5hbWUgPSAnLyc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcclxuICAgICAgICBpZiAodGhpcy5wYXRobmFtZSB8fCB0aGlzLnNlYXJjaCkge1xyXG4gICAgICAgICAgICB2YXIgcCA9IHRoaXMucGF0aG5hbWUgfHwgJyc7XHJcbiAgICAgICAgICAgIHZhciBzID0gdGhpcy5zZWFyY2ggfHwgJyc7XHJcbiAgICAgICAgICAgIHRoaXMucGF0aCA9IHAgKyBzO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBmaW5hbGx5LCByZWNvbnN0cnVjdCB0aGUgaHJlZiBiYXNlZCBvbiB3aGF0IGhhcyBiZWVuIHZhbGlkYXRlZC5cclxuICAgICAgICB0aGlzLmhyZWYgPSB0aGlzLmZvcm1hdCgpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAqIENvbnZlcnRzIGEgVW5pY29kZSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgZG9tYWluIG5hbWUgb3IgYW4gZW1haWwgYWRkcmVzcyB0b1xyXG4gKiBQdW55Y29kZS4gT25seSB0aGUgbm9uLUFTQ0lJIHBhcnRzIG9mIHRoZSBkb21haW4gbmFtZSB3aWxsIGJlIGNvbnZlcnRlZCxcclxuICogaS5lLiBpdCBkb2Vzbid0IG1hdHRlciBpZiB5b3UgY2FsbCBpdCB3aXRoIGEgZG9tYWluIHRoYXQncyBhbHJlYWR5IGluXHJcbiAqIEFTQ0lJLlxyXG4gKiBAbWVtYmVyT2YgcHVueWNvZGVcclxuICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzIHRvIGNvbnZlcnQsIGFzIGFcclxuICogVW5pY29kZSBzdHJpbmcuXHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBQdW55Y29kZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gZG9tYWluIG5hbWUgb3JcclxuICogZW1haWwgYWRkcmVzcy5cclxuICovXHJcbiAgICB0b0FTQ0lJKGlucHV0KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubWFwRG9tYWluKGlucHV0LCBmdW5jdGlvbiAoc3RyaW5nKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBVcmwucmVnZXhOb25BU0NJSS50ZXN0KHN0cmluZylcclxuICAgICAgICAgICAgICAgID8gJ3huLS0nICsgdGhpcy5lbmNvZGUoc3RyaW5nKVxyXG4gICAgICAgICAgICAgICAgOiBzdHJpbmc7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBzdHJpbmdpZnlQcmltaXRpdmUodikge1xyXG4gICAgICAgIHN3aXRjaCAodHlwZW9mIHYpIHtcclxuICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcclxuICAgICAgICAgICAgICAgIHJldHVybiB2O1xyXG4gICAgICAgICAgICBjYXNlICdib29sZWFuJzpcclxuICAgICAgICAgICAgICAgIHJldHVybiB2ID8gJ3RydWUnIDogJ2ZhbHNlJztcclxuICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcclxuICAgICAgICAgICAgICAgIHJldHVybiBpc0Zpbml0ZSh2KSA/IHYgOiAnJztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHJldHVybiAnJztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICBlbmNvZGUob2JqLCBzZXAgPSBudWxsLCBlcSA9IG51bGwsIG5hbWUgPSBudWxsKSB7XHJcbiAgICAgICAgc2VwID0gc2VwIHx8ICcmJztcclxuICAgICAgICBlcSA9IGVxIHx8ICc9JztcclxuICAgICAgICBpZiAob2JqID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIG9iaiA9IHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhvYmopLm1hcChmdW5jdGlvbiAoaykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGtzID0gZW5jb2RlVVJJQ29tcG9uZW50KHRoaXMuc3RyaW5naWZ5UHJpbWl0aXZlKGspKSArIGVxO1xyXG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqW2tdKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvYmpba10ubWFwKGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBrcyArIGVuY29kZVVSSUNvbXBvbmVudCh0aGlzLnN0cmluZ2lmeVByaW1pdGl2ZSh2KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSkuam9pbihzZXApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGtzICsgZW5jb2RlVVJJQ29tcG9uZW50KHRoaXMuc3RyaW5naWZ5UHJpbWl0aXZlKG9ialtrXSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KS5qb2luKHNlcCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghbmFtZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gJyc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQodGhpcy5zdHJpbmdpZnlQcmltaXRpdmUobmFtZSkpICsgZXEgK1xyXG4gICAgICAgICAgICBlbmNvZGVVUklDb21wb25lbnQodGhpcy5zdHJpbmdpZnlQcmltaXRpdmUob2JqKSk7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIEEgc2ltcGxlIGBBcnJheSNtYXBgLWxpa2Ugd3JhcHBlciB0byB3b3JrIHdpdGggZG9tYWluIG5hbWUgc3RyaW5ncyBvciBlbWFpbFxyXG4gICAgICogYWRkcmVzc2VzLlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkb21haW4gVGhlIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MuXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCBmb3IgZXZlcnlcclxuICAgICAqIGNoYXJhY3Rlci5cclxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gQSBuZXcgc3RyaW5nIG9mIGNoYXJhY3RlcnMgcmV0dXJuZWQgYnkgdGhlIGNhbGxiYWNrXHJcbiAgICAgKiBmdW5jdGlvbi5cclxuICAgICAqL1xyXG4gICAgbWFwRG9tYWluKHN0cmluZywgZm4pIHtcclxuICAgICAgICB2YXIgcGFydHMgPSBzdHJpbmcuc3BsaXQoJ0AnKTtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gJyc7XHJcbiAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgLy8gSW4gZW1haWwgYWRkcmVzc2VzLCBvbmx5IHRoZSBkb21haW4gbmFtZSBzaG91bGQgYmUgcHVueWNvZGVkLiBMZWF2ZVxyXG4gICAgICAgICAgICAvLyB0aGUgbG9jYWwgcGFydCAoaS5lLiBldmVyeXRoaW5nIHVwIHRvIGBAYCkgaW50YWN0LlxyXG4gICAgICAgICAgICByZXN1bHQgPSBwYXJ0c1swXSArICdAJztcclxuICAgICAgICAgICAgc3RyaW5nID0gcGFydHNbMV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEF2b2lkIGBzcGxpdChyZWdleClgIGZvciBJRTggY29tcGF0aWJpbGl0eS4gU2VlICMxNy5cclxuICAgICAgICBzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShVcmwucmVnZXhTZXBhcmF0b3JzLCAnXFx4MkUnKTtcclxuICAgICAgICB2YXIgbGFiZWxzID0gc3RyaW5nLnNwbGl0KCcuJyk7XHJcbiAgICAgICAgdmFyIGVuY29kZWQgPSB0aGlzLm1hcChsYWJlbHMsIGZuKS5qb2luKCcuJyk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdCArIGVuY29kZWQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEEgZ2VuZXJpYyBgQXJyYXkjbWFwYCB1dGlsaXR5IGZ1bmN0aW9uLlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCBmb3IgZXZlcnkgYXJyYXlcclxuICAgICAqIGl0ZW0uXHJcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IEEgbmV3IGFycmF5IG9mIHZhbHVlcyByZXR1cm5lZCBieSB0aGUgY2FsbGJhY2sgZnVuY3Rpb24uXHJcbiAgICAgKi9cclxuICAgIG1hcChhcnJheSwgZm4pIHtcclxuICAgICAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xyXG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcclxuICAgICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcclxuICAgICAgICAgICAgcmVzdWx0W2xlbmd0aF0gPSBmbihhcnJheVtsZW5ndGhdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIGZvcm1hdCgpIHtcclxuICAgICAgICB2YXIgYXV0aCA9IHRoaXMuYXV0aCB8fCAnJztcclxuICAgICAgICBpZiAoYXV0aCkge1xyXG4gICAgICAgICAgICBhdXRoID0gZW5jb2RlVVJJQ29tcG9uZW50KGF1dGgpO1xyXG4gICAgICAgICAgICBhdXRoID0gYXV0aC5yZXBsYWNlKC8lM0EvaSwgJzonKTtcclxuICAgICAgICAgICAgYXV0aCArPSAnQCc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBwcm90b2NvbCA9IHRoaXMucHJvdG9jb2wgfHwgJycsIHBhdGhuYW1lID0gdGhpcy5wYXRobmFtZSB8fCAnJywgaGFzaCA9IHRoaXMuaGFzaCB8fCAnJywgaG9zdCA9IGZhbHNlLCBxdWVyeSA9ICcnO1xyXG4gICAgICAgIGlmICh0aGlzLmhvc3QpIHtcclxuICAgICAgICAgICAgaG9zdCA9IGF1dGggKyB0aGlzLmhvc3Q7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMuaG9zdG5hbWUpIHtcclxuICAgICAgICAgICAgaG9zdCA9IGF1dGggKyAodGhpcy5ob3N0bmFtZS5pbmRleE9mKCc6JykgPT09IC0xID9cclxuICAgICAgICAgICAgICAgIHRoaXMuaG9zdG5hbWUgOlxyXG4gICAgICAgICAgICAgICAgJ1snICsgdGhpcy5ob3N0bmFtZSArICddJyk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnBvcnQpIHtcclxuICAgICAgICAgICAgICAgIGhvc3QgKz0gJzonICsgdGhpcy5wb3J0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLnF1ZXJ5ICYmXHJcbiAgICAgICAgICAgIFV0aWxzU2V0dGluZ3NfMS5VdGlsc1NldHRpbmdzLnV0aWwuaXNPYmplY3QodGhpcy5xdWVyeSkgJiZcclxuICAgICAgICAgICAgT2JqZWN0LmtleXModGhpcy5xdWVyeSkubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHF1ZXJ5ID0gdGhpcy5lbmNvZGUodGhpcy5xdWVyeSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBzZWFyY2ggPSB0aGlzLnNlYXJjaCB8fCAocXVlcnkgJiYgKCc/JyArIHF1ZXJ5KSkgfHwgJyc7XHJcbiAgICAgICAgaWYgKHByb3RvY29sICYmIHByb3RvY29sLnN1YnN0cigtMSkgIT09ICc6Jykge1xyXG4gICAgICAgICAgICBwcm90b2NvbCArPSAnOic7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIG9ubHkgdGhlIHNsYXNoZWRQcm90b2NvbHMgZ2V0IHRoZSAvLy4gIE5vdCBtYWlsdG86LCB4bXBwOiwgZXRjLlxyXG4gICAgICAgIC8vIHVubGVzcyB0aGV5IGhhZCB0aGVtIHRvIGJlZ2luIHdpdGguXHJcbiAgICAgICAgaWYgKHRoaXMuc2xhc2hlcyB8fFxyXG4gICAgICAgICAgICAoIXByb3RvY29sIHx8IFVybC5zbGFzaGVkUHJvdG9jb2xbcHJvdG9jb2xdKSAmJiBob3N0ICE9PSBmYWxzZSkge1xyXG4gICAgICAgICAgICBob3N0ID0gJy8vJyArIChob3N0IHx8ICcnKTtcclxuICAgICAgICAgICAgaWYgKHBhdGhuYW1lICYmIHBhdGhuYW1lLmNoYXJBdCgwKSAhPT0gJy8nKSB7XHJcbiAgICAgICAgICAgICAgICBwYXRobmFtZSA9ICcvJyArIHBhdGhuYW1lO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKCFob3N0KSB7XHJcbiAgICAgICAgICAgIGhvc3QgPSAnJztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGhhc2ggJiYgaGFzaC5jaGFyQXQoMCkgIT09ICcjJykge1xyXG4gICAgICAgICAgICBoYXNoID0gJyMnICsgaGFzaDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHNlYXJjaCAmJiBzZWFyY2guY2hhckF0KDApICE9PSAnPycpIHtcclxuICAgICAgICAgICAgc2VhcmNoID0gJz8nICsgc2VhcmNoO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwYXRobmFtZSA9IHBhdGhuYW1lLnJlcGxhY2UoL1s/I10vZywgZnVuY3Rpb24gKG1hdGNoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQobWF0Y2gpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHNlYXJjaCA9IHNlYXJjaC5yZXBsYWNlKCcjJywgJyUyMycpO1xyXG4gICAgICAgIHJldHVybiBwcm90b2NvbCArIGhvc3QgKyBwYXRobmFtZSArIHNlYXJjaCArIGhhc2g7XHJcbiAgICB9XHJcbiAgICA7XHJcbn1cclxuVXJsLnJlZ2V4U2VwYXJhdG9ycyA9IC9bXFx4MkVcXHUzMDAyXFx1RkYwRVxcdUZGNjFdL2c7XHJcblVybC5wb3J0UGF0dGVybiA9IC86WzAtOV0qJC87XHJcblVybC5zaW1wbGVQYXRoUGF0dGVybiA9IC9eKFxcL1xcLz8oPyFcXC8pW15cXD9cXHNdKikoXFw/W15cXHNdKik/JC87XHJcblVybC5wcm90b2NvbFBhdHRlcm4gPSAvXihbYS16MC05ListXSs6KS9pO1xyXG5VcmwucmVnZXhOb25BU0NJSSA9IC9bXlxceDIwLVxceDdFXS87XHJcblVybC5ob3N0bGVzc1Byb3RvY29sID0ge1xyXG4gICAgJ2phdmFzY3JpcHQnOiB0cnVlLFxyXG4gICAgJ2phdmFzY3JpcHQ6JzogdHJ1ZVxyXG59O1xyXG5Vcmwuc2xhc2hlZFByb3RvY29sID0ge1xyXG4gICAgJ2h0dHAnOiB0cnVlLFxyXG4gICAgJ2h0dHBzJzogdHJ1ZSxcclxuICAgICdmdHAnOiB0cnVlLFxyXG4gICAgJ2dvcGhlcic6IHRydWUsXHJcbiAgICAnZmlsZSc6IHRydWUsXHJcbiAgICAnaHR0cDonOiB0cnVlLFxyXG4gICAgJ2h0dHBzOic6IHRydWUsXHJcbiAgICAnZnRwOic6IHRydWUsXHJcbiAgICAnZ29waGVyOic6IHRydWUsXHJcbiAgICAnZmlsZTonOiB0cnVlXHJcbn07XHJcblVybC5ob3N0RW5kaW5nQ2hhcnMgPSBbJy8nLCAnPycsICcjJ107XHJcblVybC5kZWxpbXMgPSBbJzwnLCAnPicsICdcIicsICdgJywgJyAnLCAnXFxyJywgJ1xcbicsICdcXHQnXTtcclxuVXJsLnVud2lzZSA9IFsneycsICd9JywgJ3wnLCAnXFxcXCcsICdeJywgJ2AnXS5jb25jYXQoVXJsLmRlbGltcyk7XHJcblVybC5hdXRvRXNjYXBlID0gWydcXCcnXS5jb25jYXQoVXJsLnVud2lzZSk7XHJcblVybC5ub25Ib3N0Q2hhcnMgPSBbJyUnLCAnLycsICc/JywgJzsnLCAnIyddLmNvbmNhdChVcmwuYXV0b0VzY2FwZSk7XHJcblVybC5ob3N0bmFtZVBhcnRQYXR0ZXJuID0gL15bK2EtejAtOUEtWl8tXXswLDYzfSQvO1xyXG5VcmwuaG9zdG5hbWVQYXJ0U3RhcnQgPSAvXihbK2EtejAtOUEtWl8tXXswLDYzfSkoLiopJC87XHJcblVybC5ob3N0bmFtZU1heExlbiA9IDI1NTtcclxuVXJsLnVuc2FmZVByb3RvY29sID0ge1xyXG4gICAgJ2phdmFzY3JpcHQnOiB0cnVlLFxyXG4gICAgJ2phdmFzY3JpcHQ6JzogdHJ1ZVxyXG59O1xyXG5leHBvcnRzLlVybCA9IFVybDtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuY2xhc3MgVXRpbHNTZXR0aW5ncyB7XHJcbiAgICBzdGF0aWMgcmVtb3ZlSXRlbXMoYXJyLCBzdGFydElkeCwgcmVtb3ZlQ291bnQpIHtcclxuICAgICAgICB2YXIgbGVuZ3RoID0gYXJyLmxlbmd0aDtcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICBpZiAoc3RhcnRJZHggPj0gbGVuZ3RoIHx8IHJlbW92ZUNvdW50ID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVtb3ZlQ291bnQgPSAoc3RhcnRJZHggKyByZW1vdmVDb3VudCA+IGxlbmd0aCA/IGxlbmd0aCAtIHN0YXJ0SWR4IDogcmVtb3ZlQ291bnQpO1xyXG4gICAgICAgIHZhciBsZW4gPSBsZW5ndGggLSByZW1vdmVDb3VudDtcclxuICAgICAgICBmb3IgKGkgPSBzdGFydElkeDsgaSA8IGxlbjsgKytpKSB7XHJcbiAgICAgICAgICAgIGFycltpXSA9IGFycltpICsgcmVtb3ZlQ291bnRdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBhcnIubGVuZ3RoID0gbGVuO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGRlZXBDb3B5UHJvcGVydGllcyh0YXJnZXQsIHNvdXJjZSwgcHJvcGVydHlPYmopIHtcclxuICAgICAgICBmb3IgKHZhciBwcm9wIGluIHByb3BlcnR5T2JqKSB7XHJcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHNvdXJjZVtwcm9wXSkpIHtcclxuICAgICAgICAgICAgICAgIHRhcmdldFtwcm9wXSA9IHNvdXJjZVtwcm9wXS5zbGljZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0W3Byb3BdID0gc291cmNlW3Byb3BdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc3RhdGljIGFyZUFycmF5c0VxdWFsKGFycmF5MSwgYXJyYXkyKSB7XHJcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGFycmF5MSkgfHwgIUFycmF5LmlzQXJyYXkoYXJyYXkyKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChhcnJheTEubGVuZ3RoICE9PSBhcnJheTIubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheTEubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICAgICAgaWYgKGFycmF5MVtpXSAhPT0gYXJyYXkyW2ldKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgdW5zYWZlRXZhbFN1cHBvcnRlZCgpIHtcclxuICAgICAgICBpZiAodHlwZW9mIFV0aWxzU2V0dGluZ3MudW5zYWZlRXZhbCA9PT0gJ2Jvb2xlYW4nKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBVdGlsc1NldHRpbmdzLnVuc2FmZUV2YWw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHZhciBmdW5jID0gbmV3IEZ1bmN0aW9uKCdwYXJhbTEnLCAncGFyYW0yJywgJ3BhcmFtMycsICdyZXR1cm4gcGFyYW0xW3BhcmFtMl0gPT09IHBhcmFtMzsnKTtcclxuICAgICAgICAgICAgVXRpbHNTZXR0aW5ncy51bnNhZmVFdmFsID0gZnVuYyh7IGE6ICdiJyB9LCAnYScsICdiJykgPT09IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIFV0aWxzU2V0dGluZ3MudW5zYWZlRXZhbCA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gVXRpbHNTZXR0aW5ncy51bnNhZmVFdmFsO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGlzV2ViR0xTdXBwb3J0ZWQoKSB7XHJcbiAgICAgICAgdmFyIGNvbnRleHRPcHRpb25zID0geyBzdGVuY2lsOiB0cnVlLCBmYWlsSWZNYWpvclBlcmZvcm1hbmNlQ2F2ZWF0OiB0cnVlIH07XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKCF3aW5kb3dbJ1dlYkdMUmVuZGVyaW5nQ29udGV4dCddKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xyXG4gICAgICAgICAgICB2YXIgZ2wgPSBjYW52YXMuZ2V0Q29udGV4dCgnd2ViZ2wnLCBjb250ZXh0T3B0aW9ucykgfHwgY2FudmFzLmdldENvbnRleHQoJ2V4cGVyaW1lbnRhbC13ZWJnbCcsIGNvbnRleHRPcHRpb25zKTtcclxuICAgICAgICAgICAgdmFyIHN1Y2Nlc3MgPSAhIShnbCAmJiBnbC5nZXRDb250ZXh0QXR0cmlidXRlcygpLnN0ZW5jaWwpO1xyXG4gICAgICAgICAgICBpZiAoZ2wpIHtcclxuICAgICAgICAgICAgICAgIHZhciBsb3NlQ29udGV4dCA9IGdsLmdldEV4dGVuc2lvbignV0VCR0xfbG9zZV9jb250ZXh0Jyk7XHJcbiAgICAgICAgICAgICAgICBpZiAobG9zZUNvbnRleHQpIHtcclxuICAgICAgICAgICAgICAgICAgICBsb3NlQ29udGV4dC5sb3NlQ29udGV4dCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGdsID0gbnVsbDtcclxuICAgICAgICAgICAgcmV0dXJuIHN1Y2Nlc3M7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuVXRpbHNTZXR0aW5ncy51dGlsID0ge1xyXG4gICAgaXNTdHJpbmc6IGZ1bmN0aW9uIChhcmcpIHtcclxuICAgICAgICByZXR1cm4gdHlwZW9mIChhcmcpID09PSAnc3RyaW5nJztcclxuICAgIH0sXHJcbiAgICBpc09iamVjdDogZnVuY3Rpb24gKGFyZykge1xyXG4gICAgICAgIHJldHVybiB0eXBlb2YgKGFyZykgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcclxuICAgIH0sXHJcbiAgICBpc051bGw6IGZ1bmN0aW9uIChhcmcpIHtcclxuICAgICAgICByZXR1cm4gYXJnID09PSBudWxsO1xyXG4gICAgfSxcclxuICAgIGlzTnVsbE9yVW5kZWZpbmVkOiBmdW5jdGlvbiAoYXJnKSB7XHJcbiAgICAgICAgcmV0dXJuIGFyZyA9PSBudWxsO1xyXG4gICAgfVxyXG59O1xyXG5leHBvcnRzLlV0aWxzU2V0dGluZ3MgPSBVdGlsc1NldHRpbmdzO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCBCYXNlSW1hZ2VSZXNvdXJjZV8xID0gcmVxdWlyZShcIi4vQmFzZUltYWdlUmVzb3VyY2VcIik7XHJcbmNvbnN0IFRpY2tlcl8xID0gcmVxdWlyZShcIi4vVGlja2VyXCIpO1xyXG5jb25zdCBMb2dnZXJfMSA9IHJlcXVpcmUoXCIuL0xvZ2dlclwiKTtcclxuY2xhc3MgVmlkZW9SZXNvdXJjZSBleHRlbmRzIEJhc2VJbWFnZVJlc291cmNlXzEuQmFzZUltYWdlUmVzb3VyY2Uge1xyXG4gICAgY29uc3RydWN0b3Ioc291cmNlLCBvcHRpb25zKSB7XHJcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcbiAgICAgICAgLy8gdGhyb3cgXCJzdG9wXCJcclxuICAgICAgICBpZiAoIShzb3VyY2UgaW5zdGFuY2VvZiBIVE1MVmlkZW9FbGVtZW50KSkge1xyXG4gICAgICAgICAgICB2YXIgdmlkZW9FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndmlkZW8nKTtcclxuICAgICAgICAgICAgdmlkZW9FbGVtZW50LnNldEF0dHJpYnV0ZSgnd2Via2l0LXBsYXlzaW5saW5lJywgJycpO1xyXG4gICAgICAgICAgICB2aWRlb0VsZW1lbnQuc2V0QXR0cmlidXRlKCdwbGF5c2lubGluZScsICcnKTtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBzb3VyY2UgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICBzb3VyY2UgPSBbc291cmNlXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBCYXNlSW1hZ2VSZXNvdXJjZV8xLkJhc2VJbWFnZVJlc291cmNlLmNyb3NzT3JpZ2luKHZpZGVvRWxlbWVudCwgKHNvdXJjZVswXS5zcmMgfHwgc291cmNlWzBdKSwgb3B0aW9ucy5jcm9zc29yaWdpbik7XHJcbiAgICAgICAgICAgIC8vIGFycmF5IG9mIG9iamVjdHMgb3Igc3RyaW5nc1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNvdXJjZS5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHNvdXJjZUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzb3VyY2UnKTtcclxuICAgICAgICAgICAgICAgIHZhciByZWYgPSBzb3VyY2VbaV07XHJcbiAgICAgICAgICAgICAgICB2YXIgc3JjID0gcmVmLnNyYztcclxuICAgICAgICAgICAgICAgIHZhciBtaW1lID0gcmVmLm1pbWU7XHJcbiAgICAgICAgICAgICAgICBzcmMgPSBzcmMgfHwgc291cmNlW2ldO1xyXG4gICAgICAgICAgICAgICAgdmFyIGJhc2VTcmMgPSBzcmMuc3BsaXQoJz8nKS5zaGlmdCgpLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgZXh0ID0gYmFzZVNyYy5zdWJzdHIoYmFzZVNyYy5sYXN0SW5kZXhPZignLicpICsgMSk7XHJcbiAgICAgICAgICAgICAgICBtaW1lID0gbWltZSB8fCAoXCJ2aWRlby9cIiArIGV4dCk7XHJcbiAgICAgICAgICAgICAgICBzb3VyY2VFbGVtZW50LnNyYyA9IHNyYztcclxuICAgICAgICAgICAgICAgIHNvdXJjZUVsZW1lbnQudHlwZSA9IG1pbWU7XHJcbiAgICAgICAgICAgICAgICB2aWRlb0VsZW1lbnQuYXBwZW5kQ2hpbGQoc291cmNlRWxlbWVudCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gT3ZlcnJpZGUgdGhlIHNvdXJjZVxyXG4gICAgICAgICAgICBzb3VyY2UgPSB2aWRlb0VsZW1lbnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN1cGVyKHNvdXJjZSk7XHJcbiAgICAgICAgdGhpcy5jYW5VcGxvYWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9hdXRvVXBkYXRlID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLl9pc0F1dG9VcGRhdGluZyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX3VwZGF0ZUZQUyA9IG9wdGlvbnMudXBkYXRlRlBTIHx8IDA7XHJcbiAgICAgICAgdGhpcy5fbXNUb05leHRVcGRhdGUgPSAwO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFdoZW4gc2V0IHRvIHRydWUgd2lsbCBhdXRvbWF0aWNhbGx5IHBsYXkgdmlkZW9zIHVzZWQgYnkgdGhpcyB0ZXh0dXJlIG9uY2VcclxuICAgICAgICAgKiB0aGV5IGFyZSBsb2FkZWQuIElmIGZhbHNlLCBpdCB3aWxsIG5vdCBtb2RpZnkgdGhlIHBsYXlpbmcgc3RhdGUuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAbWVtYmVyIHtib29sZWFufVxyXG4gICAgICAgICAqIEBkZWZhdWx0IHRydWVcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmF1dG9QbGF5ID0gb3B0aW9ucy5hdXRvUGxheSAhPT0gZmFsc2U7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUHJvbWlzZSB3aGVuIGxvYWRpbmdcclxuICAgICAgICAgKiBAbWVtYmVyIHtQcm9taXNlPHZvaWQ+fVxyXG4gICAgICAgICAqIEBwcml2YXRlXHJcbiAgICAgICAgICogQGRlZmF1bHQgbnVsbFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuX2xvYWQgPSBudWxsO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENhbGxiYWNrIHdoZW4gY29tcGxldGVkIHdpdGggbG9hZC5cclxuICAgICAgICAgKiBAbWVtYmVyIHtmdW5jdGlvbn1cclxuICAgICAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuX3Jlc29sdmUgPSBudWxsO1xyXG4gICAgICAgIC8vIEJpbmQgZm9yIGxpc3RlbmVyc1xyXG4gICAgICAgIHRoaXMuX29uQ2FuUGxheSA9IHRoaXMuX29uQ2FuUGxheS5iaW5kKHRoaXMpO1xyXG4gICAgICAgIGlmIChvcHRpb25zLmF1dG9Mb2FkICE9PSBmYWxzZSkge1xyXG4gICAgICAgICAgICB0aGlzLmxvYWQoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRyaWdnZXIgdXBkYXRpbmcgb2YgdGhlIHRleHR1cmVcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2RlbHRhVGltZT0wXSAtIHRpbWUgZGVsdGEgc2luY2UgbGFzdCB0aWNrXHJcbiAgICAgKi9cclxuICAgIHVwZGF0ZShkZWx0YVRpbWUgPSAwKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmRlc3Ryb3llZCkge1xyXG4gICAgICAgICAgICAvLyBhY2NvdW50IGZvciBpZiB2aWRlbyBoYXMgaGFkIGl0cyBwbGF5YmFja1JhdGUgY2hhbmdlZFxyXG4gICAgICAgICAgICB2YXIgZWxhcHNlZE1TID0gVGlja2VyXzEuVGlja2VyLnNoYXJlZC5lbGFwc2VkTVMgKiB0aGlzLnNvdXJjZS5wbGF5YmFja1JhdGU7XHJcbiAgICAgICAgICAgIC8vIHRyYWNlKFwiZWxhcHNlZDogXCIgKyBlbGFwc2VkTVMpXHJcbiAgICAgICAgICAgIHRoaXMuX21zVG9OZXh0VXBkYXRlID0gTWF0aC5mbG9vcih0aGlzLl9tc1RvTmV4dFVwZGF0ZSAtIGVsYXBzZWRNUyk7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5fdXBkYXRlRlBTIHx8IHRoaXMuX21zVG9OZXh0VXBkYXRlIDw9IDApIHtcclxuICAgICAgICAgICAgICAgIC8vIHRyYWNlKFwic3VwZXIgdXBkYXRlOiBcIiArIGRlbHRhVGltZSlcclxuICAgICAgICAgICAgICAgIHN1cGVyLnVwZGF0ZShkZWx0YVRpbWUpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbXNUb05leHRVcGRhdGUgPSB0aGlzLl91cGRhdGVGUFMgPyBNYXRoLmZsb29yKDEwMDAgLyB0aGlzLl91cGRhdGVGUFMpIDogMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogU3RhcnQgcHJlbG9hZGluZyB0aGUgdmlkZW8gcmVzb3VyY2UuXHJcbiAgICAgKlxyXG4gICAgICogQHByb3RlY3RlZFxyXG4gICAgICogQHJldHVybiB7UHJvbWlzZTx2b2lkPn0gSGFuZGxlIHRoZSB2YWxpZGF0ZSBldmVudFxyXG4gICAgICovXHJcbiAgICBsb2FkKCkge1xyXG4gICAgICAgIExvZ2dlcl8xLnRyYWNlKFwibG9hZGluZyB2aWRlb1wiKTtcclxuICAgICAgICB2YXIgdGhpcyQxID0gdGhpcztcclxuICAgICAgICBpZiAodGhpcy5fbG9hZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbG9hZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHNvdXJjZSA9IHRoaXMuc291cmNlO1xyXG4gICAgICAgIGlmICgoc291cmNlLnJlYWR5U3RhdGUgPT09IHNvdXJjZS5IQVZFX0VOT1VHSF9EQVRBIHx8IHNvdXJjZS5yZWFkeVN0YXRlID09PSBzb3VyY2UuSEFWRV9GVVRVUkVfREFUQSlcclxuICAgICAgICAgICAgJiYgc291cmNlLndpZHRoICYmIHNvdXJjZS5oZWlnaHQpIHtcclxuICAgICAgICAgICAgc291cmNlLmNvbXBsZXRlID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc291cmNlLmFkZEV2ZW50TGlzdGVuZXIoJ3BsYXknLCB0aGlzLl9vblBsYXlTdGFydC5iaW5kKHRoaXMpKTtcclxuICAgICAgICBzb3VyY2UuYWRkRXZlbnRMaXN0ZW5lcigncGF1c2UnLCB0aGlzLl9vblBsYXlTdG9wLmJpbmQodGhpcykpO1xyXG4gICAgICAgIGlmICghdGhpcy5faXNTb3VyY2VSZWFkeSgpKSB7XHJcbiAgICAgICAgICAgIHNvdXJjZS5hZGRFdmVudExpc3RlbmVyKCdjYW5wbGF5JywgdGhpcy5fb25DYW5QbGF5KTtcclxuICAgICAgICAgICAgc291cmNlLmFkZEV2ZW50TGlzdGVuZXIoJ2NhbnBsYXl0aHJvdWdoJywgdGhpcy5fb25DYW5QbGF5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuX29uQ2FuUGxheSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9sb2FkID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMkMS52YWxpZCkge1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZSh0aGlzJDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcyQxLl9yZXNvbHZlID0gcmVzb2x2ZTtcclxuICAgICAgICAgICAgICAgIHNvdXJjZS5sb2FkKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbG9hZDtcclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSB1bmRlcmx5aW5nIHNvdXJjZSBpcyBwbGF5aW5nLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHBsYXlpbmcuXHJcbiAgICAgKi9cclxuICAgIF9pc1NvdXJjZVBsYXlpbmcoKSB7XHJcbiAgICAgICAgdmFyIHNvdXJjZSA9IHRoaXMuc291cmNlO1xyXG4gICAgICAgIHJldHVybiAoc291cmNlLmN1cnJlbnRUaW1lID4gMCAmJiBzb3VyY2UucGF1c2VkID09PSBmYWxzZSAmJiBzb3VyY2UuZW5kZWQgPT09IGZhbHNlICYmIHNvdXJjZS5yZWFkeVN0YXRlID4gMik7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgdW5kZXJseWluZyBzb3VyY2UgaXMgcmVhZHkgZm9yIHBsYXlpbmcuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgcmVhZHkuXHJcbiAgICAgKi9cclxuICAgIF9pc1NvdXJjZVJlYWR5KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNvdXJjZS5yZWFkeVN0YXRlID09PSAzIHx8IHRoaXMuc291cmNlLnJlYWR5U3RhdGUgPT09IDQ7XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFJ1bnMgdGhlIHVwZGF0ZSBsb29wIHdoZW4gdGhlIHZpZGVvIGlzIHJlYWR5IHRvIHBsYXlcclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBfb25QbGF5U3RhcnQoKSB7XHJcbiAgICAgICAgLy8gSnVzdCBpbiBjYXNlIHRoZSB2aWRlbyBoYXMgbm90IHJlY2VpdmVkIGl0cyBjYW4gcGxheSBldmVuIHlldC4uXHJcbiAgICAgICAgaWYgKCF0aGlzLnZhbGlkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX29uQ2FuUGxheSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXRoaXMuX2lzQXV0b1VwZGF0aW5nICYmIHRoaXMuYXV0b1VwZGF0ZSkge1xyXG4gICAgICAgICAgICBUaWNrZXJfMS5UaWNrZXIuc2hhcmVkLmFkZCh0aGlzLnVwZGF0ZSwgdGhpcyk7XHJcbiAgICAgICAgICAgIHRoaXMuX2lzQXV0b1VwZGF0aW5nID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIEZpcmVkIHdoZW4gYSBwYXVzZSBldmVudCBpcyB0cmlnZ2VyZWQsIHN0b3BzIHRoZSB1cGRhdGUgbG9vcFxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIF9vblBsYXlTdG9wKCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9pc0F1dG9VcGRhdGluZykge1xyXG4gICAgICAgICAgICBUaWNrZXJfMS5UaWNrZXIuc2hhcmVkLnJlbW92ZSh0aGlzLnVwZGF0ZSwgdGhpcyk7XHJcbiAgICAgICAgICAgIHRoaXMuX2lzQXV0b1VwZGF0aW5nID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBGaXJlZCB3aGVuIHRoZSB2aWRlbyBpcyBsb2FkZWQgYW5kIHJlYWR5IHRvIHBsYXlcclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICBfb25DYW5QbGF5KCkge1xyXG4gICAgICAgIHZhciByZWYgPSB0aGlzO1xyXG4gICAgICAgIHZhciBzb3VyY2UgPSByZWYuc291cmNlO1xyXG4gICAgICAgIHNvdXJjZS5yZW1vdmVFdmVudExpc3RlbmVyKCdjYW5wbGF5JywgdGhpcy5fb25DYW5QbGF5KTtcclxuICAgICAgICBzb3VyY2UucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2FucGxheXRocm91Z2gnLCB0aGlzLl9vbkNhblBsYXkpO1xyXG4gICAgICAgIHZhciB2YWxpZCA9IHRoaXMudmFsaWQ7XHJcbiAgICAgICAgdGhpcy5yZXNpemUoc291cmNlLnZpZGVvV2lkdGgsIHNvdXJjZS52aWRlb0hlaWdodCk7XHJcbiAgICAgICAgLy8gcHJldmVudCBtdWx0aXBsZSBsb2FkZWQgZGlzcGF0Y2hlcy4uXHJcbiAgICAgICAgaWYgKCF2YWxpZCAmJiB0aGlzLl9yZXNvbHZlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3Jlc29sdmUodGhpcyk7XHJcbiAgICAgICAgICAgIHRoaXMuX3Jlc29sdmUgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5faXNTb3VyY2VQbGF5aW5nKCkpIHtcclxuICAgICAgICAgICAgdGhpcy5fb25QbGF5U3RhcnQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5hdXRvUGxheSkge1xyXG4gICAgICAgICAgICBzb3VyY2UucGxheSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIDtcclxuICAgIC8qKlxyXG4gICAgICogRGVzdHJveXMgdGhpcyB0ZXh0dXJlXHJcbiAgICAgKiBAb3ZlcnJpZGVcclxuICAgICAqL1xyXG4gICAgZGlzcG9zZSgpIHtcclxuICAgICAgICBpZiAodGhpcy5faXNBdXRvVXBkYXRpbmcpIHtcclxuICAgICAgICAgICAgVGlja2VyXzEuVGlja2VyLnNoYXJlZC5yZW1vdmUodGhpcy51cGRhdGUsIHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5zb3VyY2UpIHtcclxuICAgICAgICAgICAgdGhpcy5zb3VyY2UucGF1c2UoKTtcclxuICAgICAgICAgICAgdGhpcy5zb3VyY2Uuc3JjID0gJyc7XHJcbiAgICAgICAgICAgIHRoaXMuc291cmNlLmxvYWQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgQmFzZUltYWdlUmVzb3VyY2VfMS5CYXNlSW1hZ2VSZXNvdXJjZS5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xyXG4gICAgfVxyXG4gICAgO1xyXG4gICAgLyoqXHJcbiAgICAgKiBTaG91bGQgdGhlIGJhc2UgdGV4dHVyZSBhdXRvbWF0aWNhbGx5IHVwZGF0ZSBpdHNlbGYsIHNldCB0byB0cnVlIGJ5IGRlZmF1bHRcclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtib29sZWFufVxyXG4gICAgICovXHJcbiAgICBnZXQgYXV0b1VwZGF0ZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fYXV0b1VwZGF0ZTtcclxuICAgIH1cclxuICAgIDtcclxuICAgIHNldCBhdXRvVXBkYXRlKHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKHZhbHVlICE9PSB0aGlzLl9hdXRvVXBkYXRlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2F1dG9VcGRhdGUgPSB2YWx1ZTtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLl9hdXRvVXBkYXRlICYmIHRoaXMuX2lzQXV0b1VwZGF0aW5nKSB7XHJcbiAgICAgICAgICAgICAgICBUaWNrZXJfMS5UaWNrZXIuc2hhcmVkLnJlbW92ZSh0aGlzLnVwZGF0ZSwgdGhpcyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9pc0F1dG9VcGRhdGluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX2F1dG9VcGRhdGUgJiYgIXRoaXMuX2lzQXV0b1VwZGF0aW5nKSB7XHJcbiAgICAgICAgICAgICAgICBUaWNrZXJfMS5UaWNrZXIuc2hhcmVkLmFkZCh0aGlzLnVwZGF0ZSwgdGhpcyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9pc0F1dG9VcGRhdGluZyA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIEhvdyBtYW55IHRpbWVzIGEgc2Vjb25kIHRvIHVwZGF0ZSB0aGUgdGV4dHVyZSBmcm9tIHRoZSB2aWRlby4gTGVhdmUgYXQgMCB0byB1cGRhdGUgYXQgZXZlcnkgcmVuZGVyLlxyXG4gICAgICogQSBsb3dlciBmcHMgY2FuIGhlbHAgcGVyZm9ybWFuY2UsIGFzIHVwZGF0aW5nIHRoZSB0ZXh0dXJlIGF0IDYwZnBzIG9uIGEgMzBwcyB2aWRlbyBtYXkgbm90IGJlIGVmZmljaWVudC5cclxuICAgICAqXHJcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIGdldCB1cGRhdGVGUFMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3VwZGF0ZUZQUztcclxuICAgIH1cclxuICAgIDtcclxuICAgIHNldCB1cGRhdGVGUFModmFsdWUpIHtcclxuICAgICAgICBpZiAodmFsdWUgIT09IHRoaXMuX3VwZGF0ZUZQUykge1xyXG4gICAgICAgICAgICB0aGlzLl91cGRhdGVGUFMgPSB2YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICA7XHJcbiAgICAvKipcclxuICAgICAqIFVzZWQgdG8gYXV0by1kZXRlY3QgdGhlIHR5cGUgb2YgcmVzb3VyY2UuXHJcbiAgICAgKlxyXG4gICAgICogQHN0YXRpY1xyXG4gICAgICogQHBhcmFtIHsqfSBzb3VyY2UgLSBUaGUgc291cmNlIG9iamVjdFxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV4dGVuc2lvbiAtIFRoZSBleHRlbnNpb24gb2Ygc291cmNlLCBpZiBzZXRcclxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IGB0cnVlYCBpZiB2aWRlbyBzb3VyY2VcclxuICAgICAqL1xyXG4gICAgc3RhdGljIHRlc3Qoc291cmNlLCBleHRlbnNpb24pIHtcclxuICAgICAgICByZXR1cm4gKHNvdXJjZSBpbnN0YW5jZW9mIEhUTUxWaWRlb0VsZW1lbnQpXHJcbiAgICAgICAgICAgIHx8IFZpZGVvUmVzb3VyY2UuVFlQRVMuaW5kZXhPZihleHRlbnNpb24pID4gLTE7XHJcbiAgICB9XHJcbiAgICA7XHJcbn1cclxuVmlkZW9SZXNvdXJjZS5UWVBFUyA9IFsnbXA0JywgJ200dicsICd3ZWJtJywgJ29nZycsICdvZ3YnLCAnaDI2NCcsICdhdmknLCAnbW92J107XHJcbmV4cG9ydHMuVmlkZW9SZXNvdXJjZSA9IFZpZGVvUmVzb3VyY2U7XHJcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmNvbnN0IFByb2dyYW1fMSA9IHJlcXVpcmUoXCIuL1Byb2dyYW1cIik7XHJcbmNvbnN0IE1hdHJpeF8xID0gcmVxdWlyZShcIi4vTWF0cml4XCIpO1xyXG5jb25zdCBTaGFkZXJfMSA9IHJlcXVpcmUoXCIuL1NoYWRlclwiKTtcclxuY29uc3QgQ2FjaGVTZXR0aW5nc18xID0gcmVxdWlyZShcIi4vQ2FjaGVTZXR0aW5nc1wiKTtcclxuY29uc3QgVW5pZm9ybUdyb3VwXzEgPSByZXF1aXJlKFwiLi9Vbmlmb3JtR3JvdXBcIik7XHJcbmNvbnN0IERpc3BsYXlTZXR0aW5nc18xID0gcmVxdWlyZShcIi4vRGlzcGxheVNldHRpbmdzXCIpO1xyXG5jbGFzcyBXZWJHTFNldHRpbmdzIHtcclxuICAgIHN0YXRpYyBjcmVhdGVJbmRpY2VzRm9yUXVhZHMoc2l6ZSkge1xyXG4gICAgICAgIHZhciB0b3RhbEluZGljZXMgPSBzaXplICogNjtcclxuICAgICAgICB2YXIgaW5kaWNlcyA9IG5ldyBVaW50MTZBcnJheSh0b3RhbEluZGljZXMpO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBqID0gMDsgaSA8IHRvdGFsSW5kaWNlczsgaSArPSA2LCBqICs9IDQpIHtcclxuICAgICAgICAgICAgaW5kaWNlc1tpICsgMF0gPSBqICsgMDtcclxuICAgICAgICAgICAgaW5kaWNlc1tpICsgMV0gPSBqICsgMTtcclxuICAgICAgICAgICAgaW5kaWNlc1tpICsgMl0gPSBqICsgMjtcclxuICAgICAgICAgICAgaW5kaWNlc1tpICsgM10gPSBqICsgMDtcclxuICAgICAgICAgICAgaW5kaWNlc1tpICsgNF0gPSBqICsgMjtcclxuICAgICAgICAgICAgaW5kaWNlc1tpICsgNV0gPSBqICsgMztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGluZGljZXM7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgY2FuVXBsb2FkU2FtZUJ1ZmZlcigpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBnZW5lcmF0ZU11bHRpVGV4dHVyZVNoYWRlcihnbCwgbWF4VGV4dHVyZXMpIHtcclxuICAgICAgICBpZiAoIUNhY2hlU2V0dGluZ3NfMS5DYWNoZVNldHRpbmdzLnByb2dyYW1DYWNoZVttYXhUZXh0dXJlc10pIHtcclxuICAgICAgICAgICAgdmFyIHNhbXBsZVZhbHVlcyA9IG5ldyBJbnQzMkFycmF5KG1heFRleHR1cmVzKTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXhUZXh0dXJlczsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBzYW1wbGVWYWx1ZXNbaV0gPSBpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIENhY2hlU2V0dGluZ3NfMS5DYWNoZVNldHRpbmdzLmRlZmF1bHRHcm91cENhY2hlW21heFRleHR1cmVzXSA9IFVuaWZvcm1Hcm91cF8xLlVuaWZvcm1Hcm91cC5mcm9tKHsgdVNhbXBsZXJzOiBzYW1wbGVWYWx1ZXMgfSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIHZhciBmcmFnbWVudFNyYyA9IFdlYkdMU2V0dGluZ3MuZnJhZ1RlbXBsYXRlJDE7XHJcbiAgICAgICAgICAgIGZyYWdtZW50U3JjID0gZnJhZ21lbnRTcmMucmVwbGFjZSgvJWNvdW50JS9naSwgbWF4VGV4dHVyZXMpO1xyXG4gICAgICAgICAgICBmcmFnbWVudFNyYyA9IGZyYWdtZW50U3JjLnJlcGxhY2UoLyVmb3Jsb29wJS9naSwgV2ViR0xTZXR0aW5ncy5nZW5lcmF0ZVNhbXBsZVNyYyhtYXhUZXh0dXJlcykpO1xyXG4gICAgICAgICAgICBDYWNoZVNldHRpbmdzXzEuQ2FjaGVTZXR0aW5ncy5wcm9ncmFtQ2FjaGVbbWF4VGV4dHVyZXNdID0gbmV3IFByb2dyYW1fMS5Qcm9ncmFtKFdlYkdMU2V0dGluZ3MudmVydGV4JDEsIGZyYWdtZW50U3JjKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHVuaWZvcm1zID0ge1xyXG4gICAgICAgICAgICB0aW50OiBuZXcgRmxvYXQzMkFycmF5KFsxLCAxLCAxLCAxXSksXHJcbiAgICAgICAgICAgIHRyYW5zbGF0aW9uTWF0cml4OiBuZXcgTWF0cml4XzEuTWF0cml4KCksXHJcbiAgICAgICAgICAgIGRlZmF1bHQ6IENhY2hlU2V0dGluZ3NfMS5DYWNoZVNldHRpbmdzLmRlZmF1bHRHcm91cENhY2hlW21heFRleHR1cmVzXSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIHZhciBzaGFkZXIgPSBuZXcgU2hhZGVyXzEuU2hhZGVyKENhY2hlU2V0dGluZ3NfMS5DYWNoZVNldHRpbmdzLnByb2dyYW1DYWNoZVttYXhUZXh0dXJlc10sIHVuaWZvcm1zKTtcclxuICAgICAgICByZXR1cm4gc2hhZGVyO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGdlbmVyYXRlU2FtcGxlU3JjKG1heFRleHR1cmVzKSB7XHJcbiAgICAgICAgdmFyIHNyYyA9ICcnO1xyXG4gICAgICAgIHNyYyArPSAnXFxuJztcclxuICAgICAgICBzcmMgKz0gJ1xcbic7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXhUZXh0dXJlczsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChpID4gMCkge1xyXG4gICAgICAgICAgICAgICAgc3JjICs9ICdcXG5lbHNlICc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGkgPCBtYXhUZXh0dXJlcyAtIDEpIHtcclxuICAgICAgICAgICAgICAgIHNyYyArPSBcImlmKHZUZXh0dXJlSWQgPCBcIiArIGkgKyBcIi41KVwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHNyYyArPSAnXFxueyc7XHJcbiAgICAgICAgICAgIHNyYyArPSBcIlxcblxcdGNvbG9yID0gdGV4dHVyZTJEKHVTYW1wbGVyc1tcIiArIGkgKyBcIl0sIHZUZXh0dXJlQ29vcmQpO1wiO1xyXG4gICAgICAgICAgICBzcmMgKz0gJ1xcbn0nO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzcmMgKz0gJ1xcbic7XHJcbiAgICAgICAgc3JjICs9ICdcXG4nO1xyXG4gICAgICAgIHJldHVybiBzcmM7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgY2hlY2tNYXhJZlN0YXRlbWVudHNJblNoYWRlcihtYXhJZnMsIGdsKSB7XHJcbiAgICAgICAgaWYgKG1heElmcyA9PT0gMCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdmFsdWUgb2YgYDBgIHBhc3NlZCB0byBgY2hlY2tNYXhJZlN0YXRlbWVudHNJblNoYWRlcmAnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHNoYWRlciA9IGdsLmNyZWF0ZVNoYWRlcihnbC5GUkFHTUVOVF9TSEFERVIpO1xyXG4gICAgICAgIHdoaWxlICh0cnVlKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnN0YW50LWNvbmRpdGlvblxyXG4gICAgICAgICB7XHJcbiAgICAgICAgICAgIHZhciBmcmFnbWVudFNyYyA9IFdlYkdMU2V0dGluZ3MuZnJhZ1RlbXBsYXRlLnJlcGxhY2UoLyVmb3Jsb29wJS9naSwgV2ViR0xTZXR0aW5ncy5nZW5lcmF0ZUlmVGVzdFNyYyhtYXhJZnMpKTtcclxuICAgICAgICAgICAgZ2wuc2hhZGVyU291cmNlKHNoYWRlciwgZnJhZ21lbnRTcmMpO1xyXG4gICAgICAgICAgICBnbC5jb21waWxlU2hhZGVyKHNoYWRlcik7XHJcbiAgICAgICAgICAgIGlmICghZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKHNoYWRlciwgZ2wuQ09NUElMRV9TVEFUVVMpKSB7XHJcbiAgICAgICAgICAgICAgICBtYXhJZnMgPSAobWF4SWZzIC8gMikgfCAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gdmFsaWQhXHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbWF4SWZzO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGdlbmVyYXRlSWZUZXN0U3JjKG1heElmcykge1xyXG4gICAgICAgIHZhciBzcmMgPSAnJztcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1heElmczsgKytpKSB7XHJcbiAgICAgICAgICAgIGlmIChpID4gMCkge1xyXG4gICAgICAgICAgICAgICAgc3JjICs9ICdcXG5lbHNlICc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGkgPCBtYXhJZnMgLSAxKSB7XHJcbiAgICAgICAgICAgICAgICBzcmMgKz0gXCJpZih0ZXN0ID09IFwiICsgaSArIFwiLjApe31cIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc3JjO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIG1heFJlY29tbWVuZGVkVGV4dHVyZXMobWF4KSB7XHJcbiAgICAgICAgdmFyIGFsbG93TWF4ID0gdHJ1ZTtcclxuICAgICAgICB2YXIgbWF0Y2ggPSAobmF2aWdhdG9yLnVzZXJBZ2VudCkubWF0Y2goL09TIChcXGQrKV8oXFxkKyk/Lyk7XHJcbiAgICAgICAgaWYgKG1hdGNoKSB7XHJcbiAgICAgICAgICAgIHZhciBtYWpvclZlcnNpb24gPSBwYXJzZUludChtYXRjaFsxXSwgMTApO1xyXG4gICAgICAgICAgICBpZiAobWFqb3JWZXJzaW9uID49IDExKSB7XHJcbiAgICAgICAgICAgICAgICBhbGxvd01heCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIG1hdGNoJDEgPSAobmF2aWdhdG9yLnVzZXJBZ2VudCkubWF0Y2goL0FuZHJvaWRcXHMoWzAtOS5dKikvKTtcclxuICAgICAgICBpZiAobWF0Y2gkMSkge1xyXG4gICAgICAgICAgICB2YXIgbWFqb3JWZXJzaW9uJDEgPSBwYXJzZUludChtYXRjaCQxWzFdLCAxMCk7XHJcbiAgICAgICAgICAgIGlmIChtYWpvclZlcnNpb24kMSA+PSA3KSB7XHJcbiAgICAgICAgICAgICAgICBhbGxvd01heCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGFsbG93TWF4ID8gbWF4IDogNDtcclxuICAgIH1cclxuICAgIHN0YXRpYyBzZXRQcmVjaXNpb24oc3JjLCBwcmVjaXNpb24pIHtcclxuICAgICAgICBpZiAoc3JjLnN1YnN0cmluZygwLCA5KSAhPT0gJ3ByZWNpc2lvbicpIC8vICYmIHNyYy5zdWJzdHJpbmcoMCwgMSkgIT09ICcjJylcclxuICAgICAgICAge1xyXG4gICAgICAgICAgICByZXR1cm4gKFwicHJlY2lzaW9uIFwiICsgcHJlY2lzaW9uICsgXCIgZmxvYXQ7XFxuXCIgKyBzcmMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc3JjO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGdldFRlc3RDb250ZXh0KCkge1xyXG4gICAgICAgIGlmICghV2ViR0xTZXR0aW5ncy5jb250ZXh0KSB7XHJcbiAgICAgICAgICAgIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcclxuICAgICAgICAgICAgdmFyIGdsO1xyXG4gICAgICAgICAgICBpZiAoRGlzcGxheVNldHRpbmdzXzEuRGlzcGxheVNldHRpbmdzLlBSRUZFUl9FTlYgPj0gRGlzcGxheVNldHRpbmdzXzEuRGlzcGxheVNldHRpbmdzLkVOVi5XRUJHTDIpIHtcclxuICAgICAgICAgICAgICAgIGdsID0gY2FudmFzLmdldENvbnRleHQoJ3dlYmdsMicsIHt9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIWdsKSB7XHJcbiAgICAgICAgICAgICAgICBnbCA9IGNhbnZhcy5nZXRDb250ZXh0KCd3ZWJnbCcsIHt9KVxyXG4gICAgICAgICAgICAgICAgICAgIHx8IGNhbnZhcy5nZXRDb250ZXh0KCdleHBlcmltZW50YWwtd2ViZ2wnLCB7fSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWdsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZmFpbCwgbm90IGFibGUgdG8gZ2V0IGEgY29udGV4dFxyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgV2ViR0wuIFRyeSB1c2luZyB0aGUgY2FudmFzIHJlbmRlcmVyJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBmb3Igc2hhZGVyIHRlc3RpbmcuLlxyXG4gICAgICAgICAgICAgICAgICAgIGdsLmdldEV4dGVuc2lvbignV0VCR0xfZHJhd19idWZmZXJzJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgV2ViR0xTZXR0aW5ncy5jb250ZXh0ID0gZ2w7XHJcbiAgICAgICAgICAgIHJldHVybiBnbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFdlYkdMU2V0dGluZ3MuY29udGV4dDtcclxuICAgIH1cclxuICAgIHN0YXRpYyBkZWZhdWx0VmFsdWUodHlwZSwgc2l6ZSkge1xyXG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xyXG4gICAgICAgICAgICBjYXNlICdmbG9hdCc6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICAgICAgY2FzZSAndmVjMic6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEZsb2F0MzJBcnJheSgyICogc2l6ZSk7XHJcbiAgICAgICAgICAgIGNhc2UgJ3ZlYzMnOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoMyAqIHNpemUpO1xyXG4gICAgICAgICAgICBjYXNlICd2ZWM0JzpcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRmxvYXQzMkFycmF5KDQgKiBzaXplKTtcclxuICAgICAgICAgICAgY2FzZSAnaW50JzpcclxuICAgICAgICAgICAgY2FzZSAnc2FtcGxlcjJEJzpcclxuICAgICAgICAgICAgY2FzZSAnc2FtcGxlcjJEQXJyYXknOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgICAgIGNhc2UgJ2l2ZWMyJzpcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgSW50MzJBcnJheSgyICogc2l6ZSk7XHJcbiAgICAgICAgICAgIGNhc2UgJ2l2ZWMzJzpcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgSW50MzJBcnJheSgzICogc2l6ZSk7XHJcbiAgICAgICAgICAgIGNhc2UgJ2l2ZWM0JzpcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgSW50MzJBcnJheSg0ICogc2l6ZSk7XHJcbiAgICAgICAgICAgIGNhc2UgJ2Jvb2wnOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICBjYXNlICdidmVjMic6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gV2ViR0xTZXR0aW5ncy5ib29sZWFuQXJyYXkoMiAqIHNpemUpO1xyXG4gICAgICAgICAgICBjYXNlICdidmVjMyc6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gV2ViR0xTZXR0aW5ncy5ib29sZWFuQXJyYXkoMyAqIHNpemUpO1xyXG4gICAgICAgICAgICBjYXNlICdidmVjNCc6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gV2ViR0xTZXR0aW5ncy5ib29sZWFuQXJyYXkoNCAqIHNpemUpO1xyXG4gICAgICAgICAgICBjYXNlICdtYXQyJzpcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRmxvYXQzMkFycmF5KFsxLCAwLFxyXG4gICAgICAgICAgICAgICAgICAgIDAsIDFdKTtcclxuICAgICAgICAgICAgY2FzZSAnbWF0Myc6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEZsb2F0MzJBcnJheShbMSwgMCwgMCxcclxuICAgICAgICAgICAgICAgICAgICAwLCAxLCAwLFxyXG4gICAgICAgICAgICAgICAgICAgIDAsIDAsIDFdKTtcclxuICAgICAgICAgICAgY2FzZSAnbWF0NCc6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEZsb2F0MzJBcnJheShbMSwgMCwgMCwgMCxcclxuICAgICAgICAgICAgICAgICAgICAwLCAxLCAwLCAwLFxyXG4gICAgICAgICAgICAgICAgICAgIDAsIDAsIDEsIDAsXHJcbiAgICAgICAgICAgICAgICAgICAgMCwgMCwgMCwgMV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIHN0YXRpYyBib29sZWFuQXJyYXkoc2l6ZSkge1xyXG4gICAgICAgIHZhciBhcnJheSA9IG5ldyBBcnJheShzaXplKTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGFycmF5W2ldID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhcnJheTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBtYXBUeXBlKGdsLCB0eXBlKSB7XHJcbiAgICAgICAgaWYgKCFXZWJHTFNldHRpbmdzLkdMX1RBQkxFKSB7XHJcbiAgICAgICAgICAgIHZhciB0eXBlTmFtZXMgPSBPYmplY3Qua2V5cyhXZWJHTFNldHRpbmdzLkdMX1RPX0dMU0xfVFlQRVMpO1xyXG4gICAgICAgICAgICBXZWJHTFNldHRpbmdzLkdMX1RBQkxFID0ge307XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHlwZU5hbWVzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdG4gPSB0eXBlTmFtZXNbaV07XHJcbiAgICAgICAgICAgICAgICBXZWJHTFNldHRpbmdzLkdMX1RBQkxFW2dsW3RuXV0gPSBXZWJHTFNldHRpbmdzLkdMX1RPX0dMU0xfVFlQRVNbdG5dO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBXZWJHTFNldHRpbmdzLkdMX1RBQkxFW3R5cGVdO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIG1hcFNpemUodHlwZSkge1xyXG4gICAgICAgIHJldHVybiBXZWJHTFNldHRpbmdzLkdMU0xfVE9fU0laRVt0eXBlXTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBnZW5lcmF0ZVVuaWZvcm1zU3luYyhncm91cCwgdW5pZm9ybURhdGEpIHtcclxuICAgICAgICB2YXIgdGV4dHVyZUNvdW50ID0gMDtcclxuICAgICAgICB2YXIgZnVuYyA9IFwidmFyIHYgPSBudWxsO1xcbiAgICB2YXIgY3YgPSBudWxsXFxuICAgIHZhciBnbCA9IHJlbmRlcmVyLmdsXCI7XHJcbiAgICAgICAgZm9yICh2YXIgaSBpbiBncm91cC51bmlmb3Jtcykge1xyXG4gICAgICAgICAgICB2YXIgZGF0YSA9IHVuaWZvcm1EYXRhW2ldO1xyXG4gICAgICAgICAgICBpZiAoIWRhdGEpIHtcclxuICAgICAgICAgICAgICAgIGlmIChncm91cC51bmlmb3Jtc1tpXS5ncm91cCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZ1bmMgKz0gXCJcXG4gICAgICAgICAgICAgICAgICAgIHJlbmRlcmVyLnNoYWRlci5zeW5jVW5pZm9ybUdyb3VwKHV2LlwiICsgaSArIFwiKTtcXG4gICAgICAgICAgICAgICAgXCI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBUT0RPICYmIHVuaWZvcm1EYXRhW2ldLnZhbHVlICE9PSAwIDwtLSBkbyB3ZSBzdGlsbCBuZWVkIHRoaXM/XHJcbiAgICAgICAgICAgIGlmIChkYXRhLnR5cGUgPT09ICdmbG9hdCcgJiYgZGF0YS5zaXplID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICBmdW5jICs9IFwiXFxuICAgICAgICAgICAgaWYodXYuXCIgKyBpICsgXCIgIT09IHVkLlwiICsgaSArIFwiLnZhbHVlKVxcbiAgICAgICAgICAgIHtcXG4gICAgICAgICAgICAgICAgdWQuXCIgKyBpICsgXCIudmFsdWUgPSB1di5cIiArIGkgKyBcIlxcbiAgICAgICAgICAgICAgICBnbC51bmlmb3JtMWYodWQuXCIgKyBpICsgXCIubG9jYXRpb24sIHV2LlwiICsgaSArIFwiKVxcbiAgICAgICAgICAgIH1cXG5cIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXHJcbiAgICAgICAgICAgIGVsc2UgaWYgKChkYXRhLnR5cGUgPT09ICdzYW1wbGVyMkQnIHx8IGRhdGEudHlwZSA9PT0gJ3NhbXBsZXJDdWJlJyB8fCBkYXRhLnR5cGUgPT09ICdzYW1wbGVyMkRBcnJheScpICYmIGRhdGEuc2l6ZSA9PT0gMSAmJiAhZGF0YS5pc0FycmF5KSBcclxuICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBmdW5jICs9IFwiXFxuICAgICAgICAgICAgcmVuZGVyZXIudGV4dHVyZS5iaW5kKHV2LlwiICsgaSArIFwiLCBcIiArIHRleHR1cmVDb3VudCArIFwiKTtcXG5cXG4gICAgICAgICAgICBpZih1ZC5cIiArIGkgKyBcIi52YWx1ZSAhPT0gXCIgKyB0ZXh0dXJlQ291bnQgKyBcIilcXG4gICAgICAgICAgICB7XFxuICAgICAgICAgICAgICAgIHVkLlwiICsgaSArIFwiLnZhbHVlID0gXCIgKyB0ZXh0dXJlQ291bnQgKyBcIjtcXG4gICAgICAgICAgICAgICAgZ2wudW5pZm9ybTFpKHVkLlwiICsgaSArIFwiLmxvY2F0aW9uLCBcIiArIHRleHR1cmVDb3VudCArIFwiKTtcXG47IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbWF4LWxlblxcbiAgICAgICAgICAgIH1cXG5cIjtcclxuICAgICAgICAgICAgICAgIHRleHR1cmVDb3VudCsrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGRhdGEudHlwZSA9PT0gJ21hdDMnICYmIGRhdGEuc2l6ZSA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGdyb3VwLnVuaWZvcm1zW2ldLmEgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gYW5kIHNvbWUgc21hcnQgY2FjaGluZyBkaXJ0eSBpZHMgaGVyZSFcclxuICAgICAgICAgICAgICAgICAgICBmdW5jICs9IFwiXFxuICAgICAgICAgICAgICAgIGdsLnVuaWZvcm1NYXRyaXgzZnYodWQuXCIgKyBpICsgXCIubG9jYXRpb24sIGZhbHNlLCB1di5cIiArIGkgKyBcIi50b0FycmF5KHRydWUpKTtcXG4gICAgICAgICAgICAgICAgXFxuXCI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBmdW5jICs9IFwiXFxuICAgICAgICAgICAgICAgIGdsLnVuaWZvcm1NYXRyaXgzZnYodWQuXCIgKyBpICsgXCIubG9jYXRpb24sIGZhbHNlLCB1di5cIiArIGkgKyBcIik7XFxuICAgICAgICAgICAgICAgIFxcblwiO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGRhdGEudHlwZSA9PT0gJ3ZlYzInICYmIGRhdGEuc2l6ZSA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgLy8gVE9ETyAtIGRvIHdlIG5lZWQgYm90aCBoZXJlP1xyXG4gICAgICAgICAgICAgICAgLy8gbWF5YmUgd2UgY2FuIGdldCBhd2F5IHdpdGggb25seSB1c2luZyBwb2ludHM/XHJcbiAgICAgICAgICAgICAgICBpZiAoZ3JvdXAudW5pZm9ybXNbaV0ueCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZnVuYyArPSBcIlxcbiAgICAgICAgICAgICAgICBjdiA9IHVkLlwiICsgaSArIFwiLnZhbHVlO1xcbiAgICAgICAgICAgICAgICB2ID0gdXYuXCIgKyBpICsgXCI7XFxuXFxuICAgICAgICAgICAgICAgIGlmKGN2WzBdICE9PSB2LnggfHwgY3ZbMV0gIT09IHYueSlcXG4gICAgICAgICAgICAgICAge1xcbiAgICAgICAgICAgICAgICAgICAgY3ZbMF0gPSB2Lng7XFxuICAgICAgICAgICAgICAgICAgICBjdlsxXSA9IHYueTtcXG4gICAgICAgICAgICAgICAgICAgIGdsLnVuaWZvcm0yZih1ZC5cIiArIGkgKyBcIi5sb2NhdGlvbiwgdi54LCB2LnkpO1xcbiAgICAgICAgICAgICAgICB9XFxuXCI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBmdW5jICs9IFwiXFxuICAgICAgICAgICAgICAgIGN2ID0gdWQuXCIgKyBpICsgXCIudmFsdWU7XFxuICAgICAgICAgICAgICAgIHYgPSB1di5cIiArIGkgKyBcIjtcXG5cXG4gICAgICAgICAgICAgICAgaWYoY3ZbMF0gIT09IHZbMF0gfHwgY3ZbMV0gIT09IHZbMV0pXFxuICAgICAgICAgICAgICAgIHtcXG4gICAgICAgICAgICAgICAgICAgIGN2WzBdID0gdlswXTtcXG4gICAgICAgICAgICAgICAgICAgIGN2WzFdID0gdlsxXTtcXG4gICAgICAgICAgICAgICAgICAgIGdsLnVuaWZvcm0yZih1ZC5cIiArIGkgKyBcIi5sb2NhdGlvbiwgdlswXSwgdlsxXSk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgXFxuXCI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoZGF0YS50eXBlID09PSAndmVjNCcgJiYgZGF0YS5zaXplID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUT0RPIC0gZG8gd2UgbmVlZCBib3RoIGhlcmU/XHJcbiAgICAgICAgICAgICAgICAvLyBtYXliZSB3ZSBjYW4gZ2V0IGF3YXkgd2l0aCBvbmx5IHVzaW5nIHBvaW50cz9cclxuICAgICAgICAgICAgICAgIGlmIChncm91cC51bmlmb3Jtc1tpXS53aWR0aCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZnVuYyArPSBcIlxcbiAgICAgICAgICAgICAgICBjdiA9IHVkLlwiICsgaSArIFwiLnZhbHVlO1xcbiAgICAgICAgICAgICAgICB2ID0gdXYuXCIgKyBpICsgXCI7XFxuXFxuICAgICAgICAgICAgICAgIGlmKGN2WzBdICE9PSB2LnggfHwgY3ZbMV0gIT09IHYueSB8fCBjdlsyXSAhPT0gdi53aWR0aCB8fCBjdlszXSAhPT0gdi5oZWlnaHQpXFxuICAgICAgICAgICAgICAgIHtcXG4gICAgICAgICAgICAgICAgICAgIGN2WzBdID0gdi54O1xcbiAgICAgICAgICAgICAgICAgICAgY3ZbMV0gPSB2Lnk7XFxuICAgICAgICAgICAgICAgICAgICBjdlsyXSA9IHYud2lkdGg7XFxuICAgICAgICAgICAgICAgICAgICBjdlszXSA9IHYuaGVpZ2h0O1xcbiAgICAgICAgICAgICAgICAgICAgZ2wudW5pZm9ybTRmKHVkLlwiICsgaSArIFwiLmxvY2F0aW9uLCB2LngsIHYueSwgdi53aWR0aCwgdi5oZWlnaHQpXFxuICAgICAgICAgICAgICAgIH1cXG5cIjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGZ1bmMgKz0gXCJcXG4gICAgICAgICAgICAgICAgY3YgPSB1ZC5cIiArIGkgKyBcIi52YWx1ZTtcXG4gICAgICAgICAgICAgICAgdiA9IHV2LlwiICsgaSArIFwiO1xcblxcbiAgICAgICAgICAgICAgICBpZihjdlswXSAhPT0gdlswXSB8fCBjdlsxXSAhPT0gdlsxXSB8fCBjdlsyXSAhPT0gdlsyXSB8fCBjdlszXSAhPT0gdlszXSlcXG4gICAgICAgICAgICAgICAge1xcbiAgICAgICAgICAgICAgICAgICAgY3ZbMF0gPSB2WzBdO1xcbiAgICAgICAgICAgICAgICAgICAgY3ZbMV0gPSB2WzFdO1xcbiAgICAgICAgICAgICAgICAgICAgY3ZbMl0gPSB2WzJdO1xcbiAgICAgICAgICAgICAgICAgICAgY3ZbM10gPSB2WzNdO1xcblxcbiAgICAgICAgICAgICAgICAgICAgZ2wudW5pZm9ybTRmKHVkLlwiICsgaSArIFwiLmxvY2F0aW9uLCB2WzBdLCB2WzFdLCB2WzJdLCB2WzNdKVxcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIFxcblwiO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmFyIHRlbXBsYXRlVHlwZSA9IChkYXRhLnNpemUgPT09IDEpID8gV2ViR0xTZXR0aW5ncy5HTFNMX1RPX1NJTkdMRV9TRVRURVJTX0NBQ0hFRCA6IFdlYkdMU2V0dGluZ3MuR0xTTF9UT19BUlJBWV9TRVRURVJTO1xyXG4gICAgICAgICAgICAgICAgdmFyIHRlbXBsYXRlID0gdGVtcGxhdGVUeXBlW2RhdGEudHlwZV0ucmVwbGFjZSgnbG9jYXRpb24nLCAoXCJ1ZC5cIiArIGkgKyBcIi5sb2NhdGlvblwiKSk7XHJcbiAgICAgICAgICAgICAgICBmdW5jICs9IFwiXFxuICAgICAgICAgICAgY3YgPSB1ZC5cIiArIGkgKyBcIi52YWx1ZTtcXG4gICAgICAgICAgICB2ID0gdXYuXCIgKyBpICsgXCI7XFxuICAgICAgICAgICAgXCIgKyB0ZW1wbGF0ZSArIFwiO1xcblwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgRnVuY3Rpb24oJ3VkJywgJ3V2JywgJ3JlbmRlcmVyJywgZnVuYyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3LWZ1bmNcclxuICAgIH1cclxufVxyXG5XZWJHTFNldHRpbmdzLlVQTE9BRFNfUEVSX0ZSQU1FID0gNDtcclxuV2ViR0xTZXR0aW5ncy5HTFNMX1RPX0FSUkFZX1NFVFRFUlMgPSB7XHJcbiAgICBmbG9hdDogXCJnbC51bmlmb3JtMWZ2KGxvY2F0aW9uLCB2KVwiLFxyXG4gICAgdmVjMjogXCJnbC51bmlmb3JtMmZ2KGxvY2F0aW9uLCB2KVwiLFxyXG4gICAgdmVjMzogXCJnbC51bmlmb3JtM2Z2KGxvY2F0aW9uLCB2KVwiLFxyXG4gICAgdmVjNDogJ2dsLnVuaWZvcm00ZnYobG9jYXRpb24sIHYpJyxcclxuICAgIG1hdDQ6ICdnbC51bmlmb3JtTWF0cml4NGZ2KGxvY2F0aW9uLCBmYWxzZSwgdiknLFxyXG4gICAgbWF0MzogJ2dsLnVuaWZvcm1NYXRyaXgzZnYobG9jYXRpb24sIGZhbHNlLCB2KScsXHJcbiAgICBtYXQyOiAnZ2wudW5pZm9ybU1hdHJpeDJmdihsb2NhdGlvbiwgZmFsc2UsIHYpJyxcclxuICAgIGludDogJ2dsLnVuaWZvcm0xaXYobG9jYXRpb24sIHYpJyxcclxuICAgIGl2ZWMyOiAnZ2wudW5pZm9ybTJpdihsb2NhdGlvbiwgdiknLFxyXG4gICAgaXZlYzM6ICdnbC51bmlmb3JtM2l2KGxvY2F0aW9uLCB2KScsXHJcbiAgICBpdmVjNDogJ2dsLnVuaWZvcm00aXYobG9jYXRpb24sIHYpJyxcclxuICAgIGJvb2w6ICdnbC51bmlmb3JtMWl2KGxvY2F0aW9uLCB2KScsXHJcbiAgICBidmVjMjogJ2dsLnVuaWZvcm0yaXYobG9jYXRpb24sIHYpJyxcclxuICAgIGJ2ZWMzOiAnZ2wudW5pZm9ybTNpdihsb2NhdGlvbiwgdiknLFxyXG4gICAgYnZlYzQ6ICdnbC51bmlmb3JtNGl2KGxvY2F0aW9uLCB2KScsXHJcbiAgICBzYW1wbGVyMkQ6ICdnbC51bmlmb3JtMWl2KGxvY2F0aW9uLCB2KScsXHJcbiAgICBzYW1wbGVyQ3ViZTogJ2dsLnVuaWZvcm0xaXYobG9jYXRpb24sIHYpJyxcclxuICAgIHNhbXBsZXIyREFycmF5OiAnZ2wudW5pZm9ybTFpdihsb2NhdGlvbiwgdiknLFxyXG59O1xyXG5XZWJHTFNldHRpbmdzLkdMU0xfVE9fU0lOR0xFX1NFVFRFUlNfQ0FDSEVEID0ge1xyXG4gICAgZmxvYXQ6IFwiXFxuICAgIGlmKGN2ICE9PSB2KVxcbiAgICB7XFxuICAgICAgICBjdi52ID0gdjtcXG4gICAgICAgIGdsLnVuaWZvcm0xZihsb2NhdGlvbiwgdilcXG4gICAgfVwiLFxyXG4gICAgdmVjMjogXCJcXG4gICAgaWYoY3ZbMF0gIT09IHZbMF0gfHwgY3ZbMV0gIT09IHZbMV0pXFxuICAgIHtcXG4gICAgICAgIGN2WzBdID0gdlswXTtcXG4gICAgICAgIGN2WzFdID0gdlsxXTtcXG4gICAgICAgIGdsLnVuaWZvcm0yZihsb2NhdGlvbiwgdlswXSwgdlsxXSlcXG4gICAgfVwiLFxyXG4gICAgdmVjMzogXCJcXG4gICAgaWYoY3ZbMF0gIT09IHZbMF0gfHwgY3ZbMV0gIT09IHZbMV0gfHwgY3ZbMl0gIT09IHZbMl0pXFxuICAgIHtcXG4gICAgICAgIGN2WzBdID0gdlswXTtcXG4gICAgICAgIGN2WzFdID0gdlsxXTtcXG4gICAgICAgIGN2WzJdID0gdlsyXTtcXG5cXG4gICAgICAgIGdsLnVuaWZvcm0zZihsb2NhdGlvbiwgdlswXSwgdlsxXSwgdlsyXSlcXG4gICAgfVwiLFxyXG4gICAgdmVjNDogJ2dsLnVuaWZvcm00Zihsb2NhdGlvbiwgdlswXSwgdlsxXSwgdlsyXSwgdlszXSknLFxyXG4gICAgaW50OiAnZ2wudW5pZm9ybTFpKGxvY2F0aW9uLCB2KScsXHJcbiAgICBpdmVjMjogJ2dsLnVuaWZvcm0yaShsb2NhdGlvbiwgdlswXSwgdlsxXSknLFxyXG4gICAgaXZlYzM6ICdnbC51bmlmb3JtM2kobG9jYXRpb24sIHZbMF0sIHZbMV0sIHZbMl0pJyxcclxuICAgIGl2ZWM0OiAnZ2wudW5pZm9ybTRpKGxvY2F0aW9uLCB2WzBdLCB2WzFdLCB2WzJdLCB2WzNdKScsXHJcbiAgICBib29sOiAnZ2wudW5pZm9ybTFpKGxvY2F0aW9uLCB2KScsXHJcbiAgICBidmVjMjogJ2dsLnVuaWZvcm0yaShsb2NhdGlvbiwgdlswXSwgdlsxXSknLFxyXG4gICAgYnZlYzM6ICdnbC51bmlmb3JtM2kobG9jYXRpb24sIHZbMF0sIHZbMV0sIHZbMl0pJyxcclxuICAgIGJ2ZWM0OiAnZ2wudW5pZm9ybTRpKGxvY2F0aW9uLCB2WzBdLCB2WzFdLCB2WzJdLCB2WzNdKScsXHJcbiAgICBtYXQyOiAnZ2wudW5pZm9ybU1hdHJpeDJmdihsb2NhdGlvbiwgZmFsc2UsIHYpJyxcclxuICAgIG1hdDM6ICdnbC51bmlmb3JtTWF0cml4M2Z2KGxvY2F0aW9uLCBmYWxzZSwgdiknLFxyXG4gICAgbWF0NDogJ2dsLnVuaWZvcm1NYXRyaXg0ZnYobG9jYXRpb24sIGZhbHNlLCB2KScsXHJcbiAgICBzYW1wbGVyMkQ6ICdnbC51bmlmb3JtMWkobG9jYXRpb24sIHYpJyxcclxuICAgIHNhbXBsZXJDdWJlOiAnZ2wudW5pZm9ybTFpKGxvY2F0aW9uLCB2KScsXHJcbiAgICBzYW1wbGVyMkRBcnJheTogJ2dsLnVuaWZvcm0xaShsb2NhdGlvbiwgdiknLFxyXG59O1xyXG5XZWJHTFNldHRpbmdzLkdMU0xfVE9fU0laRSA9IHtcclxuICAgIGZsb2F0OiAxLFxyXG4gICAgdmVjMjogMixcclxuICAgIHZlYzM6IDMsXHJcbiAgICB2ZWM0OiA0LFxyXG4gICAgaW50OiAxLFxyXG4gICAgaXZlYzI6IDIsXHJcbiAgICBpdmVjMzogMyxcclxuICAgIGl2ZWM0OiA0LFxyXG4gICAgYm9vbDogMSxcclxuICAgIGJ2ZWMyOiAyLFxyXG4gICAgYnZlYzM6IDMsXHJcbiAgICBidmVjNDogNCxcclxuICAgIG1hdDI6IDQsXHJcbiAgICBtYXQzOiA5LFxyXG4gICAgbWF0NDogMTYsXHJcbiAgICBzYW1wbGVyMkQ6IDEsXHJcbn07XHJcbldlYkdMU2V0dGluZ3MuR0xfVE9fR0xTTF9UWVBFUyA9IHtcclxuICAgIEZMT0FUOiAnZmxvYXQnLFxyXG4gICAgRkxPQVRfVkVDMjogJ3ZlYzInLFxyXG4gICAgRkxPQVRfVkVDMzogJ3ZlYzMnLFxyXG4gICAgRkxPQVRfVkVDNDogJ3ZlYzQnLFxyXG4gICAgSU5UOiAnaW50JyxcclxuICAgIElOVF9WRUMyOiAnaXZlYzInLFxyXG4gICAgSU5UX1ZFQzM6ICdpdmVjMycsXHJcbiAgICBJTlRfVkVDNDogJ2l2ZWM0JyxcclxuICAgIEJPT0w6ICdib29sJyxcclxuICAgIEJPT0xfVkVDMjogJ2J2ZWMyJyxcclxuICAgIEJPT0xfVkVDMzogJ2J2ZWMzJyxcclxuICAgIEJPT0xfVkVDNDogJ2J2ZWM0JyxcclxuICAgIEZMT0FUX01BVDI6ICdtYXQyJyxcclxuICAgIEZMT0FUX01BVDM6ICdtYXQzJyxcclxuICAgIEZMT0FUX01BVDQ6ICdtYXQ0JyxcclxuICAgIFNBTVBMRVJfMkQ6ICdzYW1wbGVyMkQnLFxyXG4gICAgU0FNUExFUl9DVUJFOiAnc2FtcGxlckN1YmUnLFxyXG4gICAgU0FNUExFUl8yRF9BUlJBWTogJ3NhbXBsZXIyREFycmF5JyxcclxufTtcclxuV2ViR0xTZXR0aW5ncy5HTF9UQUJMRSA9IG51bGw7XHJcbldlYkdMU2V0dGluZ3MuY29udGV4dCA9IG51bGw7XHJcbldlYkdMU2V0dGluZ3MuUFJFQ0lTSU9OX0ZSQUdNRU5UID0gJ2hpZ2hwJztcclxuV2ViR0xTZXR0aW5ncy5QUkVDSVNJT05fVkVSVEVYID0gJ2hpZ2hwJztcclxuV2ViR0xTZXR0aW5ncy5mcmFnVGVtcGxhdGUgPSBbXHJcbiAgICAncHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7JyxcclxuICAgICd2b2lkIG1haW4odm9pZCl7JyxcclxuICAgICdmbG9hdCB0ZXN0ID0gMC4xOycsXHJcbiAgICAnJWZvcmxvb3AlJyxcclxuICAgICdnbF9GcmFnQ29sb3IgPSB2ZWM0KDAuMCk7JyxcclxuICAgICd9J1xyXG5dLmpvaW4oJ1xcbicpO1xyXG5XZWJHTFNldHRpbmdzLnZlcnRleCQxID0gXCJwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxyXFxuYXR0cmlidXRlIHZlYzIgYVZlcnRleFBvc2l0aW9uO1xcclxcbmF0dHJpYnV0ZSB2ZWMyIGFUZXh0dXJlQ29vcmQ7XFxyXFxuYXR0cmlidXRlIHZlYzQgYUNvbG9yO1xcclxcbmF0dHJpYnV0ZSBmbG9hdCBhVGV4dHVyZUlkO1xcclxcblxcclxcbnVuaWZvcm0gbWF0MyBwcm9qZWN0aW9uTWF0cml4O1xcclxcbnVuaWZvcm0gbWF0MyB0cmFuc2xhdGlvbk1hdHJpeDtcXHJcXG51bmlmb3JtIHZlYzQgdGludDtcXHJcXG5cXHJcXG52YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXHJcXG52YXJ5aW5nIHZlYzQgdkNvbG9yO1xcclxcbnZhcnlpbmcgZmxvYXQgdlRleHR1cmVJZDtcXHJcXG5cXHJcXG52b2lkIG1haW4odm9pZCl7XFxyXFxuICAgIGdsX1Bvc2l0aW9uID0gdmVjNCgocHJvamVjdGlvbk1hdHJpeCAqIHRyYW5zbGF0aW9uTWF0cml4ICogdmVjMyhhVmVydGV4UG9zaXRpb24sIDEuMCkpLnh5LCAwLjAsIDEuMCk7XFxyXFxuXFxyXFxuICAgIHZUZXh0dXJlQ29vcmQgPSBhVGV4dHVyZUNvb3JkO1xcclxcbiAgICB2VGV4dHVyZUlkID0gYVRleHR1cmVJZDtcXHJcXG4gICAgdkNvbG9yID0gYUNvbG9yICogdGludDtcXHJcXG59XFxyXFxuXCI7XHJcbldlYkdMU2V0dGluZ3MuZnJhZ1RlbXBsYXRlJDEgPSBbXHJcbiAgICAndmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7JyxcclxuICAgICd2YXJ5aW5nIHZlYzQgdkNvbG9yOycsXHJcbiAgICAndmFyeWluZyBmbG9hdCB2VGV4dHVyZUlkOycsXHJcbiAgICAndW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXJzWyVjb3VudCVdOycsXHJcbiAgICAndm9pZCBtYWluKHZvaWQpeycsXHJcbiAgICAndmVjNCBjb2xvcjsnLFxyXG4gICAgJyVmb3Jsb29wJScsXHJcbiAgICAnZ2xfRnJhZ0NvbG9yID0gY29sb3IgKiB2Q29sb3I7JyxcclxuICAgICd9J1xyXG5dLmpvaW4oJ1xcbicpO1xyXG5XZWJHTFNldHRpbmdzLk1JUE1BUF9URVhUVVJFUyA9IDE7XHJcbldlYkdMU2V0dGluZ3MuV1JBUF9NT0RFID0gMzMwNzE7XHJcbldlYkdMU2V0dGluZ3MuVEFSR0VUUyA9IHtcclxuICAgIFRFWFRVUkVfMkQ6IDM1NTMsXHJcbiAgICBURVhUVVJFX0NVQkVfTUFQOiAzNDA2NyxcclxuICAgIFRFWFRVUkVfMkRfQVJSQVk6IDM1ODY2LFxyXG4gICAgVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YOiAzNDA2OSxcclxuICAgIFRFWFRVUkVfQ1VCRV9NQVBfTkVHQVRJVkVfWDogMzQwNzAsXHJcbiAgICBURVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1k6IDM0MDcxLFxyXG4gICAgVEVYVFVSRV9DVUJFX01BUF9ORUdBVElWRV9ZOiAzNDA3MixcclxuICAgIFRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWjogMzQwNzMsXHJcbiAgICBURVhUVVJFX0NVQkVfTUFQX05FR0FUSVZFX1o6IDM0MDc0LFxyXG59O1xyXG5XZWJHTFNldHRpbmdzLkZPUk1BVFMgPSB7XHJcbiAgICBSR0JBOiA2NDA4LFxyXG4gICAgUkdCOiA2NDA3LFxyXG4gICAgQUxQSEE6IDY0MDYsXHJcbiAgICBMVU1JTkFOQ0U6IDY0MDksXHJcbiAgICBMVU1JTkFOQ0VfQUxQSEE6IDY0MTAsXHJcbiAgICBERVBUSF9DT01QT05FTlQ6IDY0MDIsXHJcbiAgICBERVBUSF9TVEVOQ0lMOiAzNDA0MSxcclxufTtcclxuV2ViR0xTZXR0aW5ncy5UWVBFUyA9IHtcclxuICAgIFVOU0lHTkVEX0JZVEU6IDUxMjEsXHJcbiAgICBVTlNJR05FRF9TSE9SVDogNTEyMyxcclxuICAgIFVOU0lHTkVEX1NIT1JUXzVfNl81OiAzMzYzNSxcclxuICAgIFVOU0lHTkVEX1NIT1JUXzRfNF80XzQ6IDMyODE5LFxyXG4gICAgVU5TSUdORURfU0hPUlRfNV81XzVfMTogMzI4MjAsXHJcbiAgICBGTE9BVDogNTEyNixcclxuICAgIEhBTEZfRkxPQVQ6IDM2MTkzLFxyXG59O1xyXG5XZWJHTFNldHRpbmdzLk1JUE1BUF9NT0RFUyA9IHtcclxuICAgIE9GRjogMCxcclxuICAgIFBPVzI6IDEsXHJcbiAgICBPTjogMixcclxufTtcclxuV2ViR0xTZXR0aW5ncy5TQ0FMRV9NT0RFUyA9IHtcclxuICAgIExJTkVBUjogMSxcclxuICAgIE5FQVJFU1Q6IDAsXHJcbn07XHJcbldlYkdMU2V0dGluZ3MuV1JBUF9NT0RFUyA9IHtcclxuICAgIENMQU1QOiAzMzA3MSxcclxuICAgIFJFUEVBVDogMTA0OTcsXHJcbiAgICBNSVJST1JFRF9SRVBFQVQ6IDMzNjQ4LFxyXG59O1xyXG5XZWJHTFNldHRpbmdzLmRlZmF1bHRCdWZmZXJPcHRpb25zID0ge1xyXG4gICAgc2NhbGVNb2RlOiBXZWJHTFNldHRpbmdzLlNDQUxFX01PREVTLk5FQVJFU1QsXHJcbiAgICBmb3JtYXQ6IFdlYkdMU2V0dGluZ3MuRk9STUFUUy5SR0JBLFxyXG4gICAgcHJlbXVsdGlwbHlBbHBoYTogZmFsc2UsXHJcbn07XHJcbldlYkdMU2V0dGluZ3MuQ0FOX1VQTE9BRF9TQU1FX0JVRkZFUiA9IFdlYkdMU2V0dGluZ3MuY2FuVXBsb2FkU2FtZUJ1ZmZlcigpO1xyXG5XZWJHTFNldHRpbmdzLlNQUklURV9NQVhfVEVYVFVSRVMgPSBXZWJHTFNldHRpbmdzLm1heFJlY29tbWVuZGVkVGV4dHVyZXMoMzIpO1xyXG5leHBvcnRzLldlYkdMU2V0dGluZ3MgPSBXZWJHTFNldHRpbmdzO1xyXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jbGFzcyBzZXR0aW5ncyB7XHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnRzIGEgZGlnaXQvaW50ZWdlciBpbnRvIGEgYmFzaWMgY29kZSBwb2ludC5cclxuICAgICAqIEBzZWUgYGJhc2ljVG9EaWdpdCgpYFxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkaWdpdCBUaGUgbnVtZXJpYyB2YWx1ZSBvZiBhIGJhc2ljIGNvZGUgcG9pbnQuXHJcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgYmFzaWMgY29kZSBwb2ludCB3aG9zZSB2YWx1ZSAod2hlbiB1c2VkIGZvclxyXG4gICAgICogcmVwcmVzZW50aW5nIGludGVnZXJzKSBpcyBgZGlnaXRgLCB3aGljaCBuZWVkcyB0byBiZSBpbiB0aGUgcmFuZ2VcclxuICAgICAqIGAwYCB0byBgYmFzZSAtIDFgLiBJZiBgZmxhZ2AgaXMgbm9uLXplcm8sIHRoZSB1cHBlcmNhc2UgZm9ybSBpc1xyXG4gICAgICogdXNlZDsgZWxzZSwgdGhlIGxvd2VyY2FzZSBmb3JtIGlzIHVzZWQuIFRoZSBiZWhhdmlvciBpcyB1bmRlZmluZWRcclxuICAgICAqIGlmIGBmbGFnYCBpcyBub24temVybyBhbmQgYGRpZ2l0YCBoYXMgbm8gdXBwZXJjYXNlIGZvcm0uXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBkaWdpdFRvQmFzaWMoZGlnaXQsIGZsYWcpIHtcclxuICAgICAgICAvLyAgMC4uMjUgbWFwIHRvIEFTQ0lJIGEuLnogb3IgQS4uWlxyXG4gICAgICAgIC8vIDI2Li4zNSBtYXAgdG8gQVNDSUkgMC4uOVxyXG4gICAgICAgIHJldHVybiBkaWdpdCArIDIyICsgNzUgKiAoZGlnaXQgPCAyNikgLSAoKGZsYWcgIT0gMCkgPDwgNSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEEgZ2VuZXJpYyBlcnJvciB1dGlsaXR5IGZ1bmN0aW9uLlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBlcnJvciB0eXBlLlxyXG4gICAgICogQHJldHVybnMge0Vycm9yfSBUaHJvd3MgYSBgUmFuZ2VFcnJvcmAgd2l0aCB0aGUgYXBwbGljYWJsZSBlcnJvciBtZXNzYWdlLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZXJyb3IodHlwZSkge1xyXG4gICAgICAgIHRocm93IFJhbmdlRXJyb3Ioc2V0dGluZ3MuZXJyb3JzW3R5cGVdKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gKiBDb252ZXJ0cyBhIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMgKGUuZy4gYSBkb21haW4gbmFtZSBsYWJlbCkgdG8gYVxyXG4gKiBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxyXG4gKiBAbWVtYmVyT2YgcHVueWNvZGVcclxuICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzLlxyXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgcmVzdWx0aW5nIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXHJcbiAqL1xyXG4gICAgc3RhdGljIGVuY29kZShpbnB1dCkge1xyXG4gICAgICAgIHZhciBuLCBkZWx0YSwgaGFuZGxlZENQQ291bnQsIGJhc2ljTGVuZ3RoLCBiaWFzLCBqLCBtLCBxLCBrLCB0LCBjdXJyZW50VmFsdWUsIG91dHB1dCA9IFtdLCBcclxuICAgICAgICAvKiogYGlucHV0TGVuZ3RoYCB3aWxsIGhvbGQgdGhlIG51bWJlciBvZiBjb2RlIHBvaW50cyBpbiBgaW5wdXRgLiAqL1xyXG4gICAgICAgIGlucHV0TGVuZ3RoLCBcclxuICAgICAgICAvKiogQ2FjaGVkIGNhbGN1bGF0aW9uIHJlc3VsdHMgKi9cclxuICAgICAgICBoYW5kbGVkQ1BDb3VudFBsdXNPbmUsIGJhc2VNaW51c1QsIHFNaW51c1Q7XHJcbiAgICAgICAgLy8gQ29udmVydCB0aGUgaW5wdXQgaW4gVUNTLTIgdG8gVW5pY29kZVxyXG4gICAgICAgIGlucHV0ID0gc2V0dGluZ3MudWNzMmRlY29kZShpbnB1dCk7XHJcbiAgICAgICAgLy8gQ2FjaGUgdGhlIGxlbmd0aFxyXG4gICAgICAgIGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xyXG4gICAgICAgIC8vIEluaXRpYWxpemUgdGhlIHN0YXRlXHJcbiAgICAgICAgbiA9IHNldHRpbmdzLmluaXRpYWxOO1xyXG4gICAgICAgIGRlbHRhID0gMDtcclxuICAgICAgICBiaWFzID0gc2V0dGluZ3MuaW5pdGlhbEJpYXM7XHJcbiAgICAgICAgLy8gSGFuZGxlIHRoZSBiYXNpYyBjb2RlIHBvaW50c1xyXG4gICAgICAgIGZvciAoaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XHJcbiAgICAgICAgICAgIGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xyXG4gICAgICAgICAgICBpZiAoY3VycmVudFZhbHVlIDwgMHg4MCkge1xyXG4gICAgICAgICAgICAgICAgb3V0cHV0LnB1c2goc2V0dGluZ3Muc3RyaW5nRnJvbUNoYXJDb2RlKGN1cnJlbnRWYWx1ZSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGhhbmRsZWRDUENvdW50ID0gYmFzaWNMZW5ndGggPSBvdXRwdXQubGVuZ3RoO1xyXG4gICAgICAgIC8vIGBoYW5kbGVkQ1BDb3VudGAgaXMgdGhlIG51bWJlciBvZiBjb2RlIHBvaW50cyB0aGF0IGhhdmUgYmVlbiBoYW5kbGVkO1xyXG4gICAgICAgIC8vIGBiYXNpY0xlbmd0aGAgaXMgdGhlIG51bWJlciBvZiBiYXNpYyBjb2RlIHBvaW50cy5cclxuICAgICAgICAvLyBGaW5pc2ggdGhlIGJhc2ljIHN0cmluZyAtIGlmIGl0IGlzIG5vdCBlbXB0eSAtIHdpdGggYSBkZWxpbWl0ZXJcclxuICAgICAgICBpZiAoYmFzaWNMZW5ndGgpIHtcclxuICAgICAgICAgICAgb3V0cHV0LnB1c2goc2V0dGluZ3MuZGVsaW1pdGVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gTWFpbiBlbmNvZGluZyBsb29wOlxyXG4gICAgICAgIHdoaWxlIChoYW5kbGVkQ1BDb3VudCA8IGlucHV0TGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIC8vIEFsbCBub24tYmFzaWMgY29kZSBwb2ludHMgPCBuIGhhdmUgYmVlbiBoYW5kbGVkIGFscmVhZHkuIEZpbmQgdGhlIG5leHRcclxuICAgICAgICAgICAgLy8gbGFyZ2VyIG9uZTpcclxuICAgICAgICAgICAgZm9yIChtID0gc2V0dGluZ3MubWF4SW50LCBqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xyXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRWYWx1ZSA+PSBuICYmIGN1cnJlbnRWYWx1ZSA8IG0pIHtcclxuICAgICAgICAgICAgICAgICAgICBtID0gY3VycmVudFZhbHVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIEluY3JlYXNlIGBkZWx0YWAgZW5vdWdoIHRvIGFkdmFuY2UgdGhlIGRlY29kZXIncyA8bixpPiBzdGF0ZSB0byA8bSwwPixcclxuICAgICAgICAgICAgLy8gYnV0IGd1YXJkIGFnYWluc3Qgb3ZlcmZsb3dcclxuICAgICAgICAgICAgaGFuZGxlZENQQ291bnRQbHVzT25lID0gaGFuZGxlZENQQ291bnQgKyAxO1xyXG4gICAgICAgICAgICBpZiAobSAtIG4gPiBzZXR0aW5ncy5mbG9vcigoc2V0dGluZ3MubWF4SW50IC0gZGVsdGEpIC8gaGFuZGxlZENQQ291bnRQbHVzT25lKSkge1xyXG4gICAgICAgICAgICAgICAgc2V0dGluZ3MuZXJyb3IoJ292ZXJmbG93Jyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZGVsdGEgKz0gKG0gLSBuKSAqIGhhbmRsZWRDUENvdW50UGx1c09uZTtcclxuICAgICAgICAgICAgbiA9IG07XHJcbiAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcclxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50VmFsdWUgPCBuICYmICsrZGVsdGEgPiBzZXR0aW5ncy5tYXhJbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5lcnJvcignb3ZlcmZsb3cnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50VmFsdWUgPT0gbikge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlcHJlc2VudCBkZWx0YSBhcyBhIGdlbmVyYWxpemVkIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChxID0gZGVsdGEsIGsgPSBzZXR0aW5ncy5iYXNlOyAvKiBubyBjb25kaXRpb24gKi87IGsgKz0gc2V0dGluZ3MuYmFzZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ID0gayA8PSBiaWFzID8gc2V0dGluZ3MudE1pbiA6IChrID49IGJpYXMgKyBzZXR0aW5ncy50TWF4ID8gc2V0dGluZ3MudE1heCA6IGsgLSBiaWFzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHEgPCB0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBxTWludXNUID0gcSAtIHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhc2VNaW51c1QgPSBzZXR0aW5ncy5iYXNlIC0gdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnB1c2goc2V0dGluZ3Muc3RyaW5nRnJvbUNoYXJDb2RlKHNldHRpbmdzLmRpZ2l0VG9CYXNpYyh0ICsgcU1pbnVzVCAlIGJhc2VNaW51c1QsIDApKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHEgPSBzZXR0aW5ncy5mbG9vcihxTWludXNUIC8gYmFzZU1pbnVzVCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKHNldHRpbmdzLnN0cmluZ0Zyb21DaGFyQ29kZShzZXR0aW5ncy5kaWdpdFRvQmFzaWMocSwgMCkpKTtcclxuICAgICAgICAgICAgICAgICAgICBiaWFzID0gc2V0dGluZ3MuYWRhcHQoZGVsdGEsIGhhbmRsZWRDUENvdW50UGx1c09uZSwgaGFuZGxlZENQQ291bnQgPT0gYmFzaWNMZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGRlbHRhID0gMDtcclxuICAgICAgICAgICAgICAgICAgICArK2hhbmRsZWRDUENvdW50O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICsrZGVsdGE7XHJcbiAgICAgICAgICAgICsrbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG91dHB1dC5qb2luKCcnKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4qIEJpYXMgYWRhcHRhdGlvbiBmdW5jdGlvbiBhcyBwZXIgc2VjdGlvbiAzLjQgb2YgUkZDIDM0OTIuXHJcbiogaHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzQ5MiNzZWN0aW9uLTMuNFxyXG4qIEBwcml2YXRlXHJcbiovXHJcbiAgICBzdGF0aWMgYWRhcHQoZGVsdGEsIG51bVBvaW50cywgZmlyc3RUaW1lKSB7XHJcbiAgICAgICAgdmFyIGsgPSAwO1xyXG4gICAgICAgIGRlbHRhID0gZmlyc3RUaW1lID8gc2V0dGluZ3MuZmxvb3IoZGVsdGEgLyBzZXR0aW5ncy5kYW1wKSA6IGRlbHRhID4+IDE7XHJcbiAgICAgICAgZGVsdGEgKz0gc2V0dGluZ3MuZmxvb3IoZGVsdGEgLyBudW1Qb2ludHMpO1xyXG4gICAgICAgIGZvciAoIC8qIG5vIGluaXRpYWxpemF0aW9uICovOyBkZWx0YSA+IHNldHRpbmdzLmJhc2VNaW51c1RNaW4gKiBzZXR0aW5ncy50TWF4ID4+IDE7IGsgKz0gc2V0dGluZ3MuYmFzZSkge1xyXG4gICAgICAgICAgICBkZWx0YSA9IHNldHRpbmdzLmZsb29yKGRlbHRhIC8gc2V0dGluZ3MuYmFzZU1pbnVzVE1pbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzZXR0aW5ncy5mbG9vcihrICsgKHNldHRpbmdzLmJhc2VNaW51c1RNaW4gKyAxKSAqIGRlbHRhIC8gKGRlbHRhICsgc2V0dGluZ3Muc2tldykpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiogQ3JlYXRlcyBhbiBhcnJheSBjb250YWluaW5nIHRoZSBudW1lcmljIGNvZGUgcG9pbnRzIG9mIGVhY2ggVW5pY29kZVxyXG4qIGNoYXJhY3RlciBpbiB0aGUgc3RyaW5nLiBXaGlsZSBKYXZhU2NyaXB0IHVzZXMgVUNTLTIgaW50ZXJuYWxseSxcclxuKiB0aGlzIGZ1bmN0aW9uIHdpbGwgY29udmVydCBhIHBhaXIgb2Ygc3Vycm9nYXRlIGhhbHZlcyAoZWFjaCBvZiB3aGljaFxyXG4qIFVDUy0yIGV4cG9zZXMgYXMgc2VwYXJhdGUgY2hhcmFjdGVycykgaW50byBhIHNpbmdsZSBjb2RlIHBvaW50LFxyXG4qIG1hdGNoaW5nIFVURi0xNi5cclxuKiBAc2VlIGBwdW55Y29kZS51Y3MyLmVuY29kZWBcclxuKiBAc2VlIDxodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZz5cclxuKiBAbWVtYmVyT2YgcHVueWNvZGUudWNzMlxyXG4qIEBuYW1lIGRlY29kZVxyXG4qIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgVGhlIFVuaWNvZGUgaW5wdXQgc3RyaW5nIChVQ1MtMikuXHJcbiogQHJldHVybnMge0FycmF5fSBUaGUgbmV3IGFycmF5IG9mIGNvZGUgcG9pbnRzLlxyXG4qL1xyXG4gICAgc3RhdGljIHVjczJkZWNvZGUoc3RyaW5nKSB7XHJcbiAgICAgICAgdmFyIG91dHB1dCA9IFtdLCBjb3VudGVyID0gMCwgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aCwgdmFsdWUsIGV4dHJhO1xyXG4gICAgICAgIHdoaWxlIChjb3VudGVyIDwgbGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHZhbHVlID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcclxuICAgICAgICAgICAgaWYgKHZhbHVlID49IDB4RDgwMCAmJiB2YWx1ZSA8PSAweERCRkYgJiYgY291bnRlciA8IGxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgLy8gaGlnaCBzdXJyb2dhdGUsIGFuZCB0aGVyZSBpcyBhIG5leHQgY2hhcmFjdGVyXHJcbiAgICAgICAgICAgICAgICBleHRyYSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoKGV4dHJhICYgMHhGQzAwKSA9PSAweERDMDApIHsgLy8gbG93IHN1cnJvZ2F0ZVxyXG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKCgodmFsdWUgJiAweDNGRikgPDwgMTApICsgKGV4dHJhICYgMHgzRkYpICsgMHgxMDAwMCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyB1bm1hdGNoZWQgc3Vycm9nYXRlOyBvbmx5IGFwcGVuZCB0aGlzIGNvZGUgdW5pdCwgaW4gY2FzZSB0aGUgbmV4dFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvZGUgdW5pdCBpcyB0aGUgaGlnaCBzdXJyb2dhdGUgb2YgYSBzdXJyb2dhdGUgcGFpclxyXG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICBjb3VudGVyLS07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBvdXRwdXQucHVzaCh2YWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG91dHB1dDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gKiBUeXBlZGVmIGZvciBkZWNvbXBvc2VEYXRhVXJpIHJldHVybiBvYmplY3QuXHJcbiAqXHJcbiAqIEBtZW1iZXJvZiBQSVhJLnV0aWxzXHJcbiAqIEB0eXBlZGVmIHtvYmplY3R9IERlY29tcG9zZWREYXRhVXJpXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBtZWRpYVR5cGUgTWVkaWEgdHlwZSwgZWcuIGBpbWFnZWBcclxuICogQHByb3BlcnR5IHtzdHJpbmd9IHN1YlR5cGUgU3ViIHR5cGUsIGVnLiBgcG5nYFxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gZW5jb2RpbmcgRGF0YSBlbmNvZGluZywgZWcuIGBiYXNlNjRgXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBkYXRhIFRoZSBhY3R1YWwgZGF0YVxyXG4gKi9cclxuICAgIC8qKlxyXG4gICAgICogU3BsaXQgYSBkYXRhIFVSSSBpbnRvIGNvbXBvbmVudHMuIFJldHVybnMgdW5kZWZpbmVkIGlmXHJcbiAgICAgKiBwYXJhbWV0ZXIgYGRhdGFVcmlgIGlzIG5vdCBhIHZhbGlkIGRhdGEgVVJJLlxyXG4gICAgICpcclxuICAgICAqIEBtZW1iZXJvZiBQSVhJLnV0aWxzXHJcbiAgICAgKiBAZnVuY3Rpb24gZGVjb21wb3NlRGF0YVVyaVxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRhdGFVcmkgLSB0aGUgZGF0YSBVUkkgdG8gY2hlY2tcclxuICAgICAqIEByZXR1cm4ge1BJWEkudXRpbHMuRGVjb21wb3NlZERhdGFVcml8dW5kZWZpbmVkfSBUaGUgZGVjb21wb3NlZCBkYXRhIHVyaSBvciB1bmRlZmluZWRcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGRlY29tcG9zZURhdGFVcmkoZGF0YVVyaSkge1xyXG4gICAgICAgIHZhciBkYXRhVXJpTWF0Y2ggPSBzZXR0aW5ncy5EQVRBX1VSSS5leGVjKGRhdGFVcmkpO1xyXG4gICAgICAgIGlmIChkYXRhVXJpTWF0Y2gpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIG1lZGlhVHlwZTogZGF0YVVyaU1hdGNoWzFdID8gZGF0YVVyaU1hdGNoWzFdLnRvTG93ZXJDYXNlKCkgOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgICAgICBzdWJUeXBlOiBkYXRhVXJpTWF0Y2hbMl0gPyBkYXRhVXJpTWF0Y2hbMl0udG9Mb3dlckNhc2UoKSA6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgICAgIGNoYXJzZXQ6IGRhdGFVcmlNYXRjaFszXSA/IGRhdGFVcmlNYXRjaFszXS50b0xvd2VyQ2FzZSgpIDogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICAgICAgZW5jb2Rpbmc6IGRhdGFVcmlNYXRjaFs0XSA/IGRhdGFVcmlNYXRjaFs0XS50b0xvd2VyQ2FzZSgpIDogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICAgICAgZGF0YTogZGF0YVVyaU1hdGNoWzVdLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBUYXJnZXQgZnJhbWVzIHBlciBtaWxsaXNlY29uZC5cclxuICpcclxuICogQHN0YXRpY1xyXG4gKiBAbmFtZSBUQVJHRVRfRlBNU1xyXG4gKiBAbWVtYmVyb2YgUElYSS5zZXR0aW5nc1xyXG4gKiBAdHlwZSB7bnVtYmVyfVxyXG4gKiBAZGVmYXVsdCAwLjA2XHJcbiAqL1xyXG5zZXR0aW5ncy5UQVJHRVRfRlBNUyA9IDAuMDY7XHJcbi8qKlxyXG4gKiBEZWZhdWx0IGZpbHRlciByZXNvbHV0aW9uLlxyXG4gKlxyXG4gKiBAc3RhdGljXHJcbiAqIEBuYW1lIEZJTFRFUl9SRVNPTFVUSU9OXHJcbiAqIEBtZW1iZXJvZiBQSVhJLnNldHRpbmdzXHJcbiAqIEB0eXBlIHtudW1iZXJ9XHJcbiAqIEBkZWZhdWx0IDFcclxuICovXHJcbnNldHRpbmdzLkZJTFRFUl9SRVNPTFVUSU9OID0gMTtcclxuLy8gVE9ETzogbWF5YmUgY2hhbmdlIHRvIFNQUklURS5CQVRDSF9TSVpFOiAyMDAwXHJcbi8vIFRPRE86IG1heWJlIGFkZCBQQVJUSUNMRS5CQVRDSF9TSVpFOiAxNTAwMFxyXG4vKipcclxuICogVGhlIGRlZmF1bHQgc3ByaXRlIGJhdGNoIHNpemUuXHJcbiAqXHJcbiAqIFRoZSBkZWZhdWx0IGFpbXMgdG8gYmFsYW5jZSBkZXNrdG9wIGFuZCBtb2JpbGUgZGV2aWNlcy5cclxuICpcclxuICogQHN0YXRpY1xyXG4gKiBAbmFtZSBTUFJJVEVfQkFUQ0hfU0laRVxyXG4gKiBAbWVtYmVyb2YgUElYSS5zZXR0aW5nc1xyXG4gKiBAdHlwZSB7bnVtYmVyfVxyXG4gKiBAZGVmYXVsdCA0MDk2XHJcbiAqL1xyXG5zZXR0aW5ncy5TUFJJVEVfQkFUQ0hfU0laRSA9IDQwOTY7XHJcbi8qKlxyXG4gKiBEZWZhdWx0IEdhcmJhZ2UgQ29sbGVjdGlvbiBtb2RlLlxyXG4gKlxyXG4gKiBAc3RhdGljXHJcbiAqIEBuYW1lIEdDX01PREVcclxuICogQG1lbWJlcm9mIFBJWEkuc2V0dGluZ3NcclxuICogQHR5cGUge1BJWEkuR0NfTU9ERVN9XHJcbiAqIEBkZWZhdWx0IFBJWEkuR0NfTU9ERVMuQVVUT1xyXG4gKi9cclxuc2V0dGluZ3MuR0NfTU9ERSA9IDA7XHJcbi8qKlxyXG4gKiBEZWZhdWx0IEdhcmJhZ2UgQ29sbGVjdGlvbiBtYXggaWRsZS5cclxuICpcclxuICogQHN0YXRpY1xyXG4gKiBAbmFtZSBHQ19NQVhfSURMRVxyXG4gKiBAbWVtYmVyb2YgUElYSS5zZXR0aW5nc1xyXG4gKiBAdHlwZSB7bnVtYmVyfVxyXG4gKiBAZGVmYXVsdCAzNjAwXHJcbiAqL1xyXG5zZXR0aW5ncy5HQ19NQVhfSURMRSA9IDYwICogNjA7XHJcbi8qKlxyXG4gKiBEZWZhdWx0IEdhcmJhZ2UgQ29sbGVjdGlvbiBtYXhpbXVtIGNoZWNrIGNvdW50LlxyXG4gKlxyXG4gKiBAc3RhdGljXHJcbiAqIEBuYW1lIEdDX01BWF9DSEVDS19DT1VOVFxyXG4gKiBAbWVtYmVyb2YgUElYSS5zZXR0aW5nc1xyXG4gKiBAdHlwZSB7bnVtYmVyfVxyXG4gKiBAZGVmYXVsdCA2MDBcclxuICovXHJcbnNldHRpbmdzLkdDX01BWF9DSEVDS19DT1VOVCA9IDYwICogMTA7XHJcbi8qKlxyXG4qIFRoZSBnYyBtb2RlcyB0aGF0IGFyZSBzdXBwb3J0ZWQgYnkgcGl4aS5cclxuKlxyXG4qIFRoZSB7QGxpbmsgUElYSS5zZXR0aW5ncy5HQ19NT0RFfSBHYXJiYWdlIENvbGxlY3Rpb24gbW9kZSBmb3IgUGl4aUpTIHRleHR1cmVzIGlzIEFVVE9cclxuKiBJZiBzZXQgdG8gR0NfTU9ERSwgdGhlIHJlbmRlcmVyIHdpbGwgb2NjYXNpb25hbGx5IGNoZWNrIHRleHR1cmVzIHVzYWdlLiBJZiB0aGV5IGFyZSBub3RcclxuKiB1c2VkIGZvciBhIHNwZWNpZmllZCBwZXJpb2Qgb2YgdGltZSB0aGV5IHdpbGwgYmUgcmVtb3ZlZCBmcm9tIHRoZSBHUFUuIFRoZXkgd2lsbCBvZiBjb3Vyc2VcclxuKiBiZSB1cGxvYWRlZCBhZ2FpbiB3aGVuIHRoZXkgYXJlIHJlcXVpcmVkLiBUaGlzIGlzIGEgc2lsZW50IGJlaGluZCB0aGUgc2NlbmVzIHByb2Nlc3MgdGhhdFxyXG4qIHNob3VsZCBlbnN1cmUgdGhhdCB0aGUgR1BVIGRvZXMgbm90ICBnZXQgZmlsbGVkIHVwLlxyXG4qXHJcbiogSGFuZHkgZm9yIG1vYmlsZSBkZXZpY2VzIVxyXG4qIFRoaXMgcHJvcGVydHkgb25seSBhZmZlY3RzIFdlYkdMLlxyXG4qXHJcbiogQG5hbWUgR0NfTU9ERVNcclxuKiBAZW51bSB7bnVtYmVyfVxyXG4qIEBzdGF0aWNcclxuKiBAbWVtYmVyb2YgUElYSVxyXG4qIEBwcm9wZXJ0eSB7bnVtYmVyfSBBVVRPIC0gR2FyYmFnZSBjb2xsZWN0aW9uIHdpbGwgaGFwcGVuIHBlcmlvZGljYWxseSBhdXRvbWF0aWNhbGx5XHJcbiogQHByb3BlcnR5IHtudW1iZXJ9IE1BTlVBTCAtIEdhcmJhZ2UgY29sbGVjdGlvbiB3aWxsIG5lZWQgdG8gYmUgY2FsbGVkIG1hbnVhbGx5XHJcbiovXHJcbnNldHRpbmdzLkdDX01PREVTID0ge1xyXG4gICAgQVVUTzogMCxcclxuICAgIE1BTlVBTDogMSxcclxufTtcclxuLyoqXHJcbiAqIENvbnN0YW50cyB0aGF0IHNwZWNpZnkgZmxvYXQgcHJlY2lzaW9uIGluIHNoYWRlcnMuXHJcbiAqXHJcbiAqIEBuYW1lIFBSRUNJU0lPTlxyXG4gKiBAbWVtYmVyb2YgUElYSVxyXG4gKiBAc3RhdGljXHJcbiAqIEBlbnVtIHtzdHJpbmd9XHJcbiAqIEBjb25zdGFudFxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gTE9XPSdsb3dwJ1xyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gTUVESVVNPSdtZWRpdW1wJ1xyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gSElHSD0naGlnaHAnXHJcbiAqL1xyXG5zZXR0aW5ncy5QUkVDSVNJT04gPSB7XHJcbiAgICBMT1c6ICdsb3dwJyxcclxuICAgIE1FRElVTTogJ21lZGl1bXAnLFxyXG4gICAgSElHSDogJ2hpZ2hwJyxcclxufTtcclxuLyoqXHJcbiogR3JhcGhpY3MgY3VydmVzIHJlc29sdXRpb24gc2V0dGluZ3MuIElmIGBhZGFwdGl2ZWAgZmxhZyBpcyBzZXQgdG8gYHRydWVgLFxyXG4qIHRoZSByZXNvbHV0aW9uIGlzIGNhbGN1bGF0ZWQgYmFzZWQgb24gdGhlIGN1cnZlJ3MgbGVuZ3RoIHRvIGVuc3VyZSBiZXR0ZXIgdmlzdWFsIHF1YWxpdHkuXHJcbiogQWRhcHRpdmUgZHJhdyB3b3JrcyB3aXRoIGBiZXppZXJDdXJ2ZVRvYCBhbmQgYHF1YWRyYXRpY0N1cnZlVG9gLlxyXG4qXHJcbiogQHN0YXRpY1xyXG4qIEBjb25zdGFudFxyXG4qIEBtZW1iZXJvZiBQSVhJXHJcbiogQG5hbWUgR1JBUEhJQ1NfQ1VSVkVTXHJcbiogQHR5cGUge29iamVjdH1cclxuKiBAcHJvcGVydHkge2Jvb2xlYW59IGFkYXB0aXZlPWZhbHNlIC0gZmxhZyBpbmRpY2F0aW5nIGlmIHRoZSByZXNvbHV0aW9uIHNob3VsZCBiZSBhZGFwdGl2ZVxyXG4qIEBwcm9wZXJ0eSB7bnVtYmVyfSBtYXhMZW5ndGg9MTAgLSBtYXhpbWFsIGxlbmd0aCBvZiBhIHNpbmdsZSBzZWdtZW50IG9mIHRoZSBjdXJ2ZSAoaWYgYWRhcHRpdmUgPSBmYWxzZSwgaWdub3JlZClcclxuKiBAcHJvcGVydHkge251bWJlcn0gbWluU2VnbWVudHM9OCAtIG1pbmltYWwgbnVtYmVyIG9mIHNlZ21lbnRzIGluIHRoZSBjdXJ2ZSAoaWYgYWRhcHRpdmUgPSBmYWxzZSwgaWdub3JlZClcclxuKiBAcHJvcGVydHkge251bWJlcn0gbWF4U2VnbWVudHM9MjA0OCAtIG1heGltYWwgbnVtYmVyIG9mIHNlZ21lbnRzIGluIHRoZSBjdXJ2ZSAoaWYgYWRhcHRpdmUgPSBmYWxzZSwgaWdub3JlZClcclxuKi9cclxuc2V0dGluZ3MuR1JBUEhJQ1NfQ1VSVkVTID0ge1xyXG4gICAgYWRhcHRpdmU6IHRydWUsXHJcbiAgICBtYXhMZW5ndGg6IDEwLFxyXG4gICAgbWluU2VnbWVudHM6IDgsXHJcbiAgICBtYXhTZWdtZW50czogMjA0OCxcclxuICAgIF9zZWdtZW50c0NvdW50OiBmdW5jdGlvbiBfc2VnbWVudHNDb3VudChsZW5ndGgsIGRlZmF1bHRTZWdtZW50cyA9IG51bGwpIHtcclxuICAgICAgICBpZiAoZGVmYXVsdFNlZ21lbnRzID09PSB2b2lkIDApIHtcclxuICAgICAgICAgICAgZGVmYXVsdFNlZ21lbnRzID0gMjA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghdGhpcy5hZGFwdGl2ZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZGVmYXVsdFNlZ21lbnRzO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcmVzdWx0ID0gTWF0aC5jZWlsKGxlbmd0aCAvIHRoaXMubWF4TGVuZ3RoKTtcclxuICAgICAgICBpZiAocmVzdWx0IDwgdGhpcy5taW5TZWdtZW50cykge1xyXG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLm1pblNlZ21lbnRzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChyZXN1bHQgPiB0aGlzLm1heFNlZ21lbnRzKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMubWF4U2VnbWVudHM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9LFxyXG59O1xyXG5zZXR0aW5ncy5pbml0aWFsTiA9IDEyODtcclxuc2V0dGluZ3MuaW5pdGlhbEJpYXMgPSA3Mjtcclxuc2V0dGluZ3Muc3RyaW5nRnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZTtcclxuc2V0dGluZ3MuZGVsaW1pdGVyID0gJy0nO1xyXG5zZXR0aW5ncy5tYXhJbnQgPSAyMTQ3NDgzNjQ3O1xyXG5zZXR0aW5ncy5mbG9vciA9IE1hdGguZmxvb3I7XHJcbnNldHRpbmdzLmJhc2UgPSAzNjtcclxuc2V0dGluZ3MudE1pbiA9IDE7XHJcbnNldHRpbmdzLnRNYXggPSAyNjtcclxuLyoqIEVycm9yIG1lc3NhZ2VzICovXHJcbnNldHRpbmdzLmVycm9ycyA9IHtcclxuICAgICdvdmVyZmxvdyc6ICdPdmVyZmxvdzogaW5wdXQgbmVlZHMgd2lkZXIgaW50ZWdlcnMgdG8gcHJvY2VzcycsXHJcbiAgICAnbm90LWJhc2ljJzogJ0lsbGVnYWwgaW5wdXQgPj0gMHg4MCAobm90IGEgYmFzaWMgY29kZSBwb2ludCknLFxyXG4gICAgJ2ludmFsaWQtaW5wdXQnOiAnSW52YWxpZCBpbnB1dCdcclxufTtcclxuc2V0dGluZ3MuZGFtcCA9IDcwMDtcclxuc2V0dGluZ3MuYmFzZU1pbnVzVE1pbiA9IHNldHRpbmdzLmJhc2UgLSBzZXR0aW5ncy50TWluO1xyXG5zZXR0aW5ncy5za2V3ID0gMzg7XHJcbi8qKlxyXG4qIFJlZ2V4cCBmb3IgZGF0YSBVUkkuXHJcbiogQmFzZWQgb246IHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vcmFnaW5nd2luZC9kYXRhLXVyaS1yZWdleH1cclxuKlxyXG4qIEBzdGF0aWNcclxuKiBAY29uc3RhbnQge1JlZ0V4cHxzdHJpbmd9IERBVEFfVVJJXHJcbiogQG1lbWJlcm9mIFBJWElcclxuKiBAZXhhbXBsZSBkYXRhOmltYWdlL3BuZztiYXNlNjRcclxuKi9cclxuc2V0dGluZ3MuREFUQV9VUkkgPSAvXlxccypkYXRhOig/OihbXFx3LV0rKVxcLyhbXFx3Ky4tXSspKT8oPzo7Y2hhcnNldD0oW1xcdy1dKykpPyg/OjsoYmFzZTY0KSk/LCguKikvaTtcclxuLy8gVGFrZW4gZnJvbSB0aGUgYml0LXR3aWRkbGUgcGFja2FnZVxyXG5zZXR0aW5ncy5kZWZhdWx0VmVydGV4ID0gXCJhdHRyaWJ1dGUgdmVjMiBhVmVydGV4UG9zaXRpb247XFxyXFxuYXR0cmlidXRlIHZlYzIgYVRleHR1cmVDb29yZDtcXHJcXG5cXHJcXG51bmlmb3JtIG1hdDMgcHJvamVjdGlvbk1hdHJpeDtcXHJcXG5cXHJcXG52YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXHJcXG5cXHJcXG52b2lkIG1haW4odm9pZClcXHJcXG57XFxyXFxuICAgIGdsX1Bvc2l0aW9uID0gdmVjNCgocHJvamVjdGlvbk1hdHJpeCAqIHZlYzMoYVZlcnRleFBvc2l0aW9uLCAxLjApKS54eSwgMC4wLCAxLjApO1xcclxcbiAgICB2VGV4dHVyZUNvb3JkID0gYVRleHR1cmVDb29yZDtcXHJcXG59XCI7XHJcbnNldHRpbmdzLmRlZmF1bHRGaWx0ZXJWZXJ0ZXggPSBcImF0dHJpYnV0ZSB2ZWMyIGFWZXJ0ZXhQb3NpdGlvbjtcXHJcXG5cXHJcXG51bmlmb3JtIG1hdDMgcHJvamVjdGlvbk1hdHJpeDtcXHJcXG5cXHJcXG52YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXHJcXG5cXHJcXG51bmlmb3JtIHZlYzQgaW5wdXRTaXplO1xcclxcbnVuaWZvcm0gdmVjNCBvdXRwdXRGcmFtZTtcXHJcXG5cXHJcXG52ZWM0IGZpbHRlclZlcnRleFBvc2l0aW9uKCB2b2lkIClcXHJcXG57XFxyXFxuICAgIHZlYzIgcG9zaXRpb24gPSBhVmVydGV4UG9zaXRpb24gKiBtYXgob3V0cHV0RnJhbWUuencsIHZlYzIoMC4pKSArIG91dHB1dEZyYW1lLnh5O1xcclxcblxcclxcbiAgICByZXR1cm4gdmVjNCgocHJvamVjdGlvbk1hdHJpeCAqIHZlYzMocG9zaXRpb24sIDEuMCkpLnh5LCAwLjAsIDEuMCk7XFxyXFxufVxcclxcblxcclxcbnZlYzIgZmlsdGVyVGV4dHVyZUNvb3JkKCB2b2lkIClcXHJcXG57XFxyXFxuICAgIHJldHVybiBhVmVydGV4UG9zaXRpb24gKiAob3V0cHV0RnJhbWUuencgKiBpbnB1dFNpemUuencpO1xcclxcbn1cXHJcXG5cXHJcXG52b2lkIG1haW4odm9pZClcXHJcXG57XFxyXFxuICAgIGdsX1Bvc2l0aW9uID0gZmlsdGVyVmVydGV4UG9zaXRpb24oKTtcXHJcXG4gICAgdlRleHR1cmVDb29yZCA9IGZpbHRlclRleHR1cmVDb29yZCgpO1xcclxcbn1cXHJcXG5cIjtcclxuZXhwb3J0cy5zZXR0aW5ncyA9IHNldHRpbmdzO1xyXG4iXSwic291cmNlUm9vdCI6IiJ9