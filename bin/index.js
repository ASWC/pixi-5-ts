/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./js-compile/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./js-compile/examples/AdvancedCard.js":
/*!*********************************************!*\
  !*** ./js-compile/examples/AdvancedCard.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseExample_1 = __webpack_require__(/*! ./BaseExample */ "./js-compile/examples/BaseExample.js");
const ResourceLoader_1 = __webpack_require__(/*! ../raw-pixi-ts/ResourceLoader */ "./js-compile/raw-pixi-ts/ResourceLoader.js");
const URLRequest_1 = __webpack_require__(/*! ../raw-pixi-ts/URLRequest */ "./js-compile/raw-pixi-ts/URLRequest.js");
const Event_1 = __webpack_require__(/*! ../raw-pixi-ts/Event */ "./js-compile/raw-pixi-ts/Event.js");
const Texture_1 = __webpack_require__(/*! ../raw-pixi-ts/Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const BaseTexture_1 = __webpack_require__(/*! ../raw-pixi-ts/BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const Graphics_1 = __webpack_require__(/*! ../raw-pixi-ts/Graphics */ "./js-compile/raw-pixi-ts/Graphics.js");
const Sprite_1 = __webpack_require__(/*! ../raw-pixi-ts/Sprite */ "./js-compile/raw-pixi-ts/Sprite.js");
const RenderTexture_1 = __webpack_require__(/*! ../raw-pixi-ts/RenderTexture */ "./js-compile/raw-pixi-ts/RenderTexture.js");
const MouseEvent_1 = __webpack_require__(/*! ../raw-pixi-ts/MouseEvent */ "./js-compile/raw-pixi-ts/MouseEvent.js");
class AdvancedCard extends BaseExample_1.BaseExample {
    constructor(app, width, height) {
        super(app, width, height);
        this.handleRotateLoaded = (event) => {
            this.rotatetxt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            this.brush = new Graphics_1.Graphics();
            this.brush.beginFill(0xffffff);
            this.brush.drawCircle(0, 0, 50);
            this.brush.endFill();
            const background = new Sprite_1.Sprite(this.grasstxt);
            this.stage.addChild(background);
            background.width = this.sizew;
            background.height = this.sizeh;
            const imageToReveal = new Sprite_1.Sprite(this.rotatetxt);
            this.stage.addChild(imageToReveal);
            imageToReveal.width = this.sizew;
            imageToReveal.height = this.sizeh;
            this.renderTexture = RenderTexture_1.RenderTexture.create(this.sizew, this.sizeh);
            const renderTextureSprite = new Sprite_1.Sprite(this.renderTexture);
            this.stage.addChild(renderTextureSprite);
            imageToReveal.mask = renderTextureSprite;
            this.stage.interactive = true;
            this.dragging = false;
            this.stage.addEventListener(MouseEvent_1.MouseEvent.POINTER_DOWN, this.pointerDown);
            this.stage.addEventListener(MouseEvent_1.MouseEvent.POINTER_UP, this.pointerUp);
            this.stage.addEventListener(MouseEvent_1.MouseEvent.POINTER_MOVE, this.pointerMove);
            this.exampleReady();
        };
        this.pointerMove = (event) => {
            if (this.dragging) {
                this.brush.position.copyFrom(event.data.global);
                this.app.renderer.render(this.brush, this.renderTexture, false, null, false);
            }
        };
        this.pointerDown = (event) => {
            this.dragging = true;
            this.pointerMove(event);
        };
        this.pointerUp = (event) => {
            this.dragging = false;
        };
        this.handleGrassLoaded = (event) => {
            this.grasstxt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/bg_rotate.jpg"));
            this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleRotateLoaded);
            this.loader.load();
        };
        this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/bg_grass.jpg"));
        this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleGrassLoaded);
        this.loader.load();
    }
    destructor() {
        this.stage.removeEventListener(MouseEvent_1.MouseEvent.POINTER_DOWN, this.pointerDown);
        this.stage.removeEventListener(MouseEvent_1.MouseEvent.POINTER_UP, this.pointerUp);
        this.stage.removeEventListener(MouseEvent_1.MouseEvent.POINTER_MOVE, this.pointerMove);
        super.destructor();
        this.brush.destroy(null);
        this.grasstxt.destroy(null);
    }
}
exports.AdvancedCard = AdvancedCard;


/***/ }),

/***/ "./js-compile/examples/AdvancedSlots.js":
/*!**********************************************!*\
  !*** ./js-compile/examples/AdvancedSlots.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseExample_1 = __webpack_require__(/*! ./BaseExample */ "./js-compile/examples/BaseExample.js");
const ResourceLoader_1 = __webpack_require__(/*! ../raw-pixi-ts/ResourceLoader */ "./js-compile/raw-pixi-ts/ResourceLoader.js");
const URLRequest_1 = __webpack_require__(/*! ../raw-pixi-ts/URLRequest */ "./js-compile/raw-pixi-ts/URLRequest.js");
const Event_1 = __webpack_require__(/*! ../raw-pixi-ts/Event */ "./js-compile/raw-pixi-ts/Event.js");
const Texture_1 = __webpack_require__(/*! ../raw-pixi-ts/Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const BaseTexture_1 = __webpack_require__(/*! ../raw-pixi-ts/BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const Container_1 = __webpack_require__(/*! ../raw-pixi-ts/Container */ "./js-compile/raw-pixi-ts/Container.js");
const BlurFilter_1 = __webpack_require__(/*! ../raw-pixi-ts/BlurFilter */ "./js-compile/raw-pixi-ts/BlurFilter.js");
const Sprite_1 = __webpack_require__(/*! ../raw-pixi-ts/Sprite */ "./js-compile/raw-pixi-ts/Sprite.js");
const Graphics_1 = __webpack_require__(/*! ../raw-pixi-ts/Graphics */ "./js-compile/raw-pixi-ts/Graphics.js");
const TextStyle_1 = __webpack_require__(/*! ../raw-pixi-ts/TextStyle */ "./js-compile/raw-pixi-ts/TextStyle.js");
const Text_1 = __webpack_require__(/*! ../raw-pixi-ts/Text */ "./js-compile/raw-pixi-ts/Text.js");
const MouseEvent_1 = __webpack_require__(/*! ../raw-pixi-ts/MouseEvent */ "./js-compile/raw-pixi-ts/MouseEvent.js");
class AdvancedSlots extends BaseExample_1.BaseExample {
    constructor(app, width, height) {
        super(app, width, height);
        this.handleEggLoaded = (event) => {
            this.eggTxt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/flowerTop.png"));
            this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleFlowerLoaded);
            this.loader.load();
        };
        this.handleFlowerLoaded = (event) => {
            this.flowerTxt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/helmlok.png"));
            this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleHelmLoaded);
            this.loader.load();
        };
        this.handleHelmLoaded = (event) => {
            this.helmTxt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/skully.png"));
            this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleSkullLoaded);
            this.loader.load();
        };
        this.handleSkullLoaded = (event) => {
            this.skullTxt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            const REEL_WIDTH = 160;
            this.SYMBOL_SIZE = 150;
            this.slotTextures = [
                this.eggTxt,
                this.flowerTxt,
                this.helmTxt,
                this.skullTxt,
            ];
            this.reels = [];
            const reelContainer = new Container_1.Container();
            for (let i = 0; i < 5; i++) {
                const rc = new Container_1.Container();
                rc.x = i * REEL_WIDTH;
                reelContainer.addChild(rc);
                const reel = {
                    container: rc,
                    symbols: [],
                    position: 0,
                    previousPosition: 0,
                    blur: new BlurFilter_1.BlurFilter(),
                };
                reel.blur.blurX = 0;
                reel.blur.blurY = 0;
                rc.filters = [reel.blur];
                for (let j = 0; j < 4; j++) {
                    const symbol = new Sprite_1.Sprite(this.slotTextures[Math.floor(Math.random() * this.slotTextures.length)]);
                    symbol.y = j * this.SYMBOL_SIZE;
                    symbol.scale.x = symbol.scale.y = Math.min(this.SYMBOL_SIZE / symbol.width, this.SYMBOL_SIZE / symbol.height);
                    symbol.x = Math.round((this.SYMBOL_SIZE - symbol.width) / 2);
                    reel.symbols.push(symbol);
                    rc.addChild(symbol);
                }
                this.reels.push(reel);
                this.stage.addChild(reelContainer);
                const margin = (this.sizeh - this.SYMBOL_SIZE * 3) / 2;
                reelContainer.y = margin;
                reelContainer.x = Math.round(this.sizew - REEL_WIDTH * 5);
                const top = new Graphics_1.Graphics();
                top.beginFill(0, 1);
                top.drawRect(0, 0, this.sizew, margin);
                const bottom = new Graphics_1.Graphics();
                bottom.beginFill(0, 1);
                bottom.drawRect(0, this.SYMBOL_SIZE * 3 + margin, this.sizew, margin);
                const style = new TextStyle_1.TextStyle({
                    fontFamily: 'Arial',
                    fontSize: 36,
                    fontStyle: 'italic',
                    fontWeight: 'bold',
                    fill: ['#ffffff', '#00ff99'],
                    stroke: '#4a1850',
                    strokeThickness: 5,
                    dropShadow: true,
                    dropShadowColor: '#000000',
                    dropShadowBlur: 4,
                    dropShadowAngle: Math.PI / 6,
                    dropShadowDistance: 6,
                    wordWrap: true,
                    wordWrapWidth: 440,
                });
                const playText = new Text_1.Text('Spin the wheels!', style);
                playText.x = Math.round((bottom.width - playText.width) / 2);
                playText.y = this.sizeh - margin + Math.round((margin - playText.height) / 2);
                bottom.addChild(playText);
                const headerText = new Text_1.Text('PIXI MONSTER SLOTS!', style);
                headerText.x = Math.round((top.width - headerText.width) / 2);
                headerText.y = Math.round((margin - headerText.height) / 2);
                top.addChild(headerText);
                this.stage.addChild(top);
                this.stage.addChild(bottom);
                bottom.interactive = true;
                bottom.buttonMode = true;
                bottom.addEventListener(MouseEvent_1.MouseEvent.POINTER_DOWN, this.startPlay);
                this.running = false;
            }
            this.app.ticker.add(this.runExample);
            this.app.ticker.add(this.tween);
            this.exampleReady();
        };
        this.startPlay = () => {
            if (this.running)
                return;
            this.running = true;
            for (let i = 0; i < this.reels.length; i++) {
                const r = this.reels[i];
                const extra = Math.floor(Math.random() * 3);
                const target = r.position + 10 + i * 5 + extra;
                const time = 2500 + i * 600 + extra * 600;
                this.tweenTo(r, 'position', target, time, this.backout(0.5), null, i === this.reels.length - 1 ? this.reelsComplete : null);
            }
        };
        this.reelsComplete = () => {
            this.running = false;
        };
        this.runExample = (delta) => {
            for (let i = 0; i < this.reels.length; i++) {
                const r = this.reels[i];
                r.blur.blurY = (r.position - r.previousPosition) * 8;
                r.previousPosition = r.position;
                for (let j = 0; j < r.symbols.length; j++) {
                    const s = r.symbols[j];
                    const prevy = s.y;
                    s.y = ((r.position + j) % r.symbols.length) * this.SYMBOL_SIZE - this.SYMBOL_SIZE;
                    if (s.y < 0 && prevy > this.SYMBOL_SIZE) {
                        s.texture = this.slotTextures[Math.floor(Math.random() * this.slotTextures.length)];
                        s.scale.x = s.scale.y = Math.min(this.SYMBOL_SIZE / s.texture.width, this.SYMBOL_SIZE / s.texture.height);
                        s.x = Math.round((this.SYMBOL_SIZE - s.width) / 2);
                    }
                }
            }
        };
        this.tween = (delta) => {
            const now = Date.now();
            const remove = [];
            for (let i = 0; i < this.tweening.length; i++) {
                const t = this.tweening[i];
                const phase = Math.min(1, (now - t.start) / t.time);
                t.object[t.property] = this.lerp(t.propertyBeginValue, t.target, t.easing(phase));
                if (t.change)
                    t.change(t);
                if (phase === 1) {
                    t.object[t.property] = t.target;
                    if (t.complete)
                        t.complete(t);
                    remove.push(t);
                }
            }
            for (let i = 0; i < remove.length; i++) {
                this.tweening.splice(this.tweening.indexOf(remove[i]), 1);
            }
        };
        this.tweening = [];
        this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/eggHead.png"));
        this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleEggLoaded);
        this.loader.load();
    }
    tweenTo(object, property, target, time, easing, onchange, oncomplete) {
        const tween = {
            object,
            property,
            propertyBeginValue: object[property],
            target,
            easing,
            time,
            change: onchange,
            complete: oncomplete,
            start: Date.now(),
        };
        this.tweening.push(tween);
        return tween;
    }
    lerp(a1, a2, t) {
        return a1 * (1 - t) + a2 * t;
    }
    backout(amount) {
        return t => (--t * t * ((amount + 1) * t + amount) + 1);
    }
    destructor() {
        super.destructor();
        this.app.ticker.remove(this.runExample, null);
        this.app.ticker.remove(this.tween, null);
        this.eggTxt.destroy(null);
        this.flowerTxt.destroy(null);
        this.helmTxt.destroy(null);
        this.skullTxt.destroy(null);
        this.slotTextures = null;
        this.tweening = null;
    }
}
exports.AdvancedSlots = AdvancedSlots;


/***/ }),

/***/ "./js-compile/examples/AdvancedTrail.js":
/*!**********************************************!*\
  !*** ./js-compile/examples/AdvancedTrail.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseExample_1 = __webpack_require__(/*! ./BaseExample */ "./js-compile/examples/BaseExample.js");
const ResourceLoader_1 = __webpack_require__(/*! ../raw-pixi-ts/ResourceLoader */ "./js-compile/raw-pixi-ts/ResourceLoader.js");
const URLRequest_1 = __webpack_require__(/*! ../raw-pixi-ts/URLRequest */ "./js-compile/raw-pixi-ts/URLRequest.js");
const Event_1 = __webpack_require__(/*! ../raw-pixi-ts/Event */ "./js-compile/raw-pixi-ts/Event.js");
const Texture_1 = __webpack_require__(/*! ../raw-pixi-ts/Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const BaseTexture_1 = __webpack_require__(/*! ../raw-pixi-ts/BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const Point_1 = __webpack_require__(/*! ../flash/geom/Point */ "./js-compile/flash/geom/Point.js");
const SimpleRope_1 = __webpack_require__(/*! ../raw-pixi-ts/SimpleRope */ "./js-compile/raw-pixi-ts/SimpleRope.js");
const BlendModesSettings_1 = __webpack_require__(/*! ../raw-pixi-ts/BlendModesSettings */ "./js-compile/raw-pixi-ts/BlendModesSettings.js");
class AdvancedTrail extends BaseExample_1.BaseExample {
    constructor(app, width, height) {
        super(app, width, height);
        this.handleGrassLoaded = (event) => {
            this.trailTexture = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            this.historyX = [];
            this.historyY = [];
            this.historySize = 20;
            this.ropeSize = 100;
            this.points = [];
            for (let i = 0; i < this.historySize; i++) {
                this.historyX.push(0);
                this.historyY.push(0);
            }
            for (let i = 0; i < this.ropeSize; i++) {
                this.points.push(Point_1.Point.getPoint(0, 0));
            }
            const rope = new SimpleRope_1.SimpleRope(this.trailTexture, this.points);
            rope.blendMode = BlendModesSettings_1.BlendModesSettings.BLEND_MODES.ADD;
            this.stage.addChild(rope);
            this.app.ticker.add(this.runExample);
            this.exampleReady();
        };
        this.runExample = (delta) => {
            const mouseposition = this.app.renderer.plugins.interaction.mouse.global;
            this.historyX.pop();
            this.historyX.unshift(mouseposition.x);
            this.historyY.pop();
            this.historyY.unshift(mouseposition.y);
            for (let i = 0; i < this.ropeSize; i++) {
                const p = this.points[i];
                const ix = this.cubicInterpolation(this.historyX, i / this.ropeSize * this.historySize);
                const iy = this.cubicInterpolation(this.historyY, i / this.ropeSize * this.historySize);
                p.x = ix;
                p.y = iy;
            }
        };
        this.backColor = 0x000378;
        this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/trail.png"));
        this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleGrassLoaded);
        this.loader.load();
    }
    clipInput(k, arr) {
        if (k < 0)
            k = 0;
        if (k > arr.length - 1)
            k = arr.length - 1;
        return arr[k];
    }
    getTangent(k, factor, array) {
        return factor * (this.clipInput(k + 1, array) - this.clipInput(k - 1, array)) / 2;
    }
    cubicInterpolation(array, t, tangentFactor = 1) {
        const k = Math.floor(t);
        const m = [this.getTangent(k, tangentFactor, array), this.getTangent(k + 1, tangentFactor, array)];
        const p = [this.clipInput(k, array), this.clipInput(k + 1, array)];
        t -= k;
        const t2 = t * t;
        const t3 = t * t2;
        return (2 * t3 - 3 * t2 + 1) * p[0] + (t3 - 2 * t2 + t) * m[0] + (-2 * t3 + 3 * t2) * p[1] + (t3 - t2) * m[1];
    }
    destructor() {
        super.destructor();
        if (this.points && this.points.length) {
            while (this.points.length) {
                let point = this.points.shift();
                point.recycle();
            }
        }
        this.points = null;
        this.historyY = null;
        this.historyX = null;
        this.app.ticker.remove(this.runExample, null);
        this.trailTexture.destroy(null);
    }
}
exports.AdvancedTrail = AdvancedTrail;


/***/ }),

/***/ "./js-compile/examples/AdvancedWarp.js":
/*!*********************************************!*\
  !*** ./js-compile/examples/AdvancedWarp.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseExample_1 = __webpack_require__(/*! ./BaseExample */ "./js-compile/examples/BaseExample.js");
const Event_1 = __webpack_require__(/*! ../raw-pixi-ts/Event */ "./js-compile/raw-pixi-ts/Event.js");
const URLRequest_1 = __webpack_require__(/*! ../raw-pixi-ts/URLRequest */ "./js-compile/raw-pixi-ts/URLRequest.js");
const ResourceLoader_1 = __webpack_require__(/*! ../raw-pixi-ts/ResourceLoader */ "./js-compile/raw-pixi-ts/ResourceLoader.js");
const Texture_1 = __webpack_require__(/*! ../raw-pixi-ts/Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const BaseTexture_1 = __webpack_require__(/*! ../raw-pixi-ts/BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const Sprite_1 = __webpack_require__(/*! ../raw-pixi-ts/Sprite */ "./js-compile/raw-pixi-ts/Sprite.js");
class AdvancedWarp extends BaseExample_1.BaseExample {
    constructor(app, width, height) {
        super(app, width, height);
        this.handleGrassLoaded = (event) => {
            this.starTexture = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            this.starAmount = 1000;
            this.cameraZ = 0;
            this.fov = 20;
            this.baseSpeed = 0.025;
            this.speed = 0;
            this.warpSpeed = 0;
            this.starStretch = 5;
            this.starBaseSize = 0.05;
            this.stars = [];
            for (let i = 0; i < this.starAmount; i++) {
                const star = {
                    sprite: new Sprite_1.Sprite(this.starTexture),
                    z: 0,
                    x: 0,
                    y: 0,
                };
                star.sprite.anchor.x = 0.5;
                star.sprite.anchor.y = 0.7;
                this.randomizeStar(star, true);
                this.stage.addChild(star.sprite);
                this.stars.push(star);
            }
            setInterval(() => {
                this.warpSpeed = this.warpSpeed > 0 ? 0 : 1;
            }, 5000);
            this.app.ticker.add(this.runExample);
            this.exampleReady();
        };
        this.runExample = (delta) => {
            this.speed += (this.warpSpeed - this.speed) / 20;
            this.cameraZ += delta * 10 * (this.speed + this.baseSpeed);
            for (let i = 0; i < this.starAmount; i++) {
                const star = this.stars[i];
                if (star.z < this.cameraZ)
                    this.randomizeStar(star);
                const z = star.z - this.cameraZ;
                star.sprite.x = star.x * (this.fov / z) * this.sizew + this.sizew / 2;
                star.sprite.y = star.y * (this.fov / z) * this.sizew + this.sizeh / 2;
                const dxCenter = star.sprite.x - this.sizew / 2;
                const dyCenter = star.sprite.y - this.sizeh / 2;
                const distanceCenter = Math.sqrt(dxCenter * dxCenter + dyCenter + dyCenter);
                const distanceScale = Math.max(0, (2000 - z) / 2000);
                star.sprite.scale.x = distanceScale * this.starBaseSize;
                star.sprite.scale.y = distanceScale * this.starBaseSize + distanceScale * this.speed * this.starStretch * distanceCenter / this.sizew;
                star.sprite.rotation = Math.atan2(dyCenter, dxCenter) + Math.PI / 2;
            }
        };
        this.backColor = 0x000000;
        this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/star.png"));
        this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleGrassLoaded);
        this.loader.load();
    }
    randomizeStar(star, initial = true) {
        star.z = initial ? Math.random() * 2000 : this.cameraZ + Math.random() * 1000 + 2000;
        const deg = Math.random() * Math.PI * 2;
        const distance = Math.random() * 50 + 1;
        star.x = Math.cos(deg) * distance;
        star.y = Math.sin(deg) * distance;
    }
    destructor() {
        super.destructor();
        this.stars = null;
        this.app.ticker.remove(this.runExample, null);
        this.starTexture.destroy(null);
    }
}
exports.AdvancedWarp = AdvancedWarp;


/***/ }),

/***/ "./js-compile/examples/BaseExample.js":
/*!********************************************!*\
  !*** ./js-compile/examples/BaseExample.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Graphics_1 = __webpack_require__(/*! ../raw-pixi-ts/Graphics */ "./js-compile/raw-pixi-ts/Graphics.js");
const Container_1 = __webpack_require__(/*! ../raw-pixi-ts/Container */ "./js-compile/raw-pixi-ts/Container.js");
const EventDispatcher_1 = __webpack_require__(/*! ../raw-pixi-ts/EventDispatcher */ "./js-compile/raw-pixi-ts/EventDispatcher.js");
const Event_1 = __webpack_require__(/*! ../raw-pixi-ts/Event */ "./js-compile/raw-pixi-ts/Event.js");
class BaseExample extends EventDispatcher_1.EventDispatcher {
    constructor(app, width = 100, height = 100) {
        super();
        this.backColor = 0x969696;
        this.sizew = width;
        this.sizeh = height;
        this.app = app;
        this.stage = new Container_1.Container();
    }
    activateMask() {
        this.stageMask = new Graphics_1.Graphics();
        this.stageMask.beginFill(0);
        this.stageMask.drawRect(0, 0, this.sizew, this.sizeh);
        this.stage.mask = this.stageMask;
    }
    destructor() {
        if (this.stage.children.length) {
            while (this.stage.children.length) {
                let child = this.stage.children.shift();
                child.destructor();
            }
        }
        this.stage = null;
        if (this.stageMask) {
            this.stageMask.destroy(null);
        }
    }
    exampleReady() {
        this.dispatchEvent(Event_1.Event.getEvent(Event_1.Event.COMPLETE));
    }
}
exports.BaseExample = BaseExample;


/***/ }),

/***/ "./js-compile/examples/BasicBlend.js":
/*!*******************************************!*\
  !*** ./js-compile/examples/BasicBlend.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseExample_1 = __webpack_require__(/*! ./BaseExample */ "./js-compile/examples/BaseExample.js");
const ResourceLoader_1 = __webpack_require__(/*! ../raw-pixi-ts/ResourceLoader */ "./js-compile/raw-pixi-ts/ResourceLoader.js");
const URLRequest_1 = __webpack_require__(/*! ../raw-pixi-ts/URLRequest */ "./js-compile/raw-pixi-ts/URLRequest.js");
const Event_1 = __webpack_require__(/*! ../raw-pixi-ts/Event */ "./js-compile/raw-pixi-ts/Event.js");
const Texture_1 = __webpack_require__(/*! ../raw-pixi-ts/Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const BaseTexture_1 = __webpack_require__(/*! ../raw-pixi-ts/BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const Sprite_1 = __webpack_require__(/*! ../raw-pixi-ts/Sprite */ "./js-compile/raw-pixi-ts/Sprite.js");
const Rectangle_1 = __webpack_require__(/*! ../flash/geom/Rectangle */ "./js-compile/flash/geom/Rectangle.js");
const BlendModesSettings_1 = __webpack_require__(/*! ../raw-pixi-ts/BlendModesSettings */ "./js-compile/raw-pixi-ts/BlendModesSettings.js");
class BasicBlend extends BaseExample_1.BaseExample {
    constructor(app, width, height) {
        super(app, width, height);
        this.handleResourceLoaded = (event) => {
            let txt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            const background = new Sprite_1.Sprite(txt);
            background.width = this.sizew;
            background.height = this.sizeh;
            this.stage.addChild(background);
            this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/flowerTop.png"));
            this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleFlowerLoaded);
            this.loader.load();
        };
        this.handleFlowerLoaded = (event) => {
            let txt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            this.dudeArray = [];
            const totaldudes = 20;
            for (let i = 0; i < totaldudes; i++) {
                const dude = new ExtendedSprite(txt);
                dude.anchor.set(0.5);
                dude.scale.set(0.8 + Math.random() * 0.3);
                dude.x = Math.floor(Math.random() * this.sizew);
                dude.y = Math.floor(Math.random() * this.sizeh);
                dude.blendMode = BlendModesSettings_1.BlendModesSettings.BLEND_MODES.ADD;
                dude.direction = Math.random() * Math.PI * 2;
                dude.turningSpeed = Math.random() - 0.8;
                dude.speed = 2 + Math.random() * 2;
                this.dudeArray.push(dude);
                this.stage.addChild(dude);
            }
            const dudeBoundsPadding = 100;
            this.dudeBounds = Rectangle_1.Rectangle.getRectangle(-dudeBoundsPadding, -dudeBoundsPadding, this.sizew + dudeBoundsPadding * 2, this.sizeh + dudeBoundsPadding * 2);
            this.app.ticker.add(this.runExample);
            this.exampleReady();
        };
        this.runExample = (delta) => {
            for (let i = 0; i < this.dudeArray.length; i++) {
                const dude = this.dudeArray[i];
                dude.direction += dude.turningSpeed * 0.01;
                dude.x += Math.sin(dude.direction) * dude.speed;
                dude.y += Math.cos(dude.direction) * dude.speed;
                dude.rotation = -dude.direction - Math.PI / 2;
                if (dude.x < this.dudeBounds.x) {
                    dude.x += this.dudeBounds.width;
                }
                else if (dude.x > this.dudeBounds.x + this.dudeBounds.width) {
                    dude.x -= this.dudeBounds.width;
                }
                if (dude.y < this.dudeBounds.y) {
                    dude.y += this.dudeBounds.height;
                }
                else if (dude.y > this.dudeBounds.y + this.dudeBounds.height) {
                    dude.y -= this.dudeBounds.height;
                }
            }
        };
        this.backColor = 0xFFFFFF;
        this.activateMask();
        this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/eggHead.png"));
        this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleResourceLoaded);
        this.loader.load();
    }
    destructor() {
        super.destructor();
        this.app.ticker.remove(this.runExample, null);
        this.dudeArray = null;
    }
}
exports.BasicBlend = BasicBlend;
class ExtendedSprite extends Sprite_1.Sprite {
}


/***/ }),

/***/ "./js-compile/examples/BasicContainer.js":
/*!***********************************************!*\
  !*** ./js-compile/examples/BasicContainer.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseExample_1 = __webpack_require__(/*! ./BaseExample */ "./js-compile/examples/BaseExample.js");
const Container_1 = __webpack_require__(/*! ../raw-pixi-ts/Container */ "./js-compile/raw-pixi-ts/Container.js");
const Texture_1 = __webpack_require__(/*! ../raw-pixi-ts/Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const Sprite_1 = __webpack_require__(/*! ../raw-pixi-ts/Sprite */ "./js-compile/raw-pixi-ts/Sprite.js");
const ResourceLoader_1 = __webpack_require__(/*! ../raw-pixi-ts/ResourceLoader */ "./js-compile/raw-pixi-ts/ResourceLoader.js");
const URLRequest_1 = __webpack_require__(/*! ../raw-pixi-ts/URLRequest */ "./js-compile/raw-pixi-ts/URLRequest.js");
const Event_1 = __webpack_require__(/*! ../raw-pixi-ts/Event */ "./js-compile/raw-pixi-ts/Event.js");
const BaseTexture_1 = __webpack_require__(/*! ../raw-pixi-ts/BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
class BasicContainer extends BaseExample_1.BaseExample {
    constructor(app, width, height) {
        super(app, width, height);
        this.handleResourceLoaded = (event) => {
            let txt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            for (let i = 0; i < 25; i++) {
                const bunny = new Sprite_1.Sprite(txt);
                bunny.anchor.set(0.5);
                bunny.x = (i % 5) * 40;
                bunny.y = Math.floor(i / 5) * 40;
                this.container.addChild(bunny);
            }
            this.container.x = this.sizew / 2;
            this.container.y = this.sizeh / 2;
            this.container.pivot.x = this.container.width / 2;
            this.container.pivot.y = this.container.height / 2;
            this.app.ticker.add(this.runExample);
            this.exampleReady();
        };
        this.runExample = (delta) => {
            this.container.rotation -= 0.01 * delta;
        };
        this.container = new Container_1.Container();
        this.stage.addChild(this.container);
        this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/bunny.png"));
        this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleResourceLoaded);
        this.loader.load();
    }
    destructor() {
        super.destructor();
        this.app.ticker.remove(this.runExample, null);
        if (this.container) {
            this.container.destructor();
        }
        this.container = null;
    }
}
exports.BasicContainer = BasicContainer;


/***/ }),

/***/ "./js-compile/examples/BasicParticles.js":
/*!***********************************************!*\
  !*** ./js-compile/examples/BasicParticles.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseExample_1 = __webpack_require__(/*! ./BaseExample */ "./js-compile/examples/BaseExample.js");
const ResourceLoader_1 = __webpack_require__(/*! ../raw-pixi-ts/ResourceLoader */ "./js-compile/raw-pixi-ts/ResourceLoader.js");
const URLRequest_1 = __webpack_require__(/*! ../raw-pixi-ts/URLRequest */ "./js-compile/raw-pixi-ts/URLRequest.js");
const Event_1 = __webpack_require__(/*! ../raw-pixi-ts/Event */ "./js-compile/raw-pixi-ts/Event.js");
const Texture_1 = __webpack_require__(/*! ../raw-pixi-ts/Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const BaseTexture_1 = __webpack_require__(/*! ../raw-pixi-ts/BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const ParticleContainer_1 = __webpack_require__(/*! ../raw-pixi-ts/ParticleContainer */ "./js-compile/raw-pixi-ts/ParticleContainer.js");
const Sprite_1 = __webpack_require__(/*! ../raw-pixi-ts/Sprite */ "./js-compile/raw-pixi-ts/Sprite.js");
const Rectangle_1 = __webpack_require__(/*! ../flash/geom/Rectangle */ "./js-compile/flash/geom/Rectangle.js");
class BasicParticles extends BaseExample_1.BaseExample {
    constructor(app, width, height) {
        super(app, width, height);
        this.handleResourceLoaded = (event) => {
            let txt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            const sprites = new ParticleContainer_1.ParticleContainer(10000, { scale: true, position: true, rotation: true, uvs: true, alpha: true, });
            this.stage.addChild(sprites);
            this.maggots = [];
            const totalSprites = 10000;
            for (let i = 0; i < totalSprites; i++) {
                const dude = new ExtendedSprite(txt);
                dude.tint = Math.random() * 0xE8D4CD;
                dude.anchor.set(0.5);
                dude.scale.set(0.8 + Math.random() * 0.3);
                dude.x = Math.random() * this.sizew;
                dude.y = Math.random() * this.sizeh;
                dude.tint = Math.random() * 0x808080;
                dude.direction = Math.random() * Math.PI * 2;
                dude.turningSpeed = Math.random() - 0.8;
                dude.speed = (2 + Math.random() * 2) * 0.2;
                dude.offset = Math.random() * 100;
                this.maggots.push(dude);
                sprites.addChild(dude);
            }
            const dudeBoundsPadding = 100;
            this.dudeBounds = Rectangle_1.Rectangle.getRectangle(-dudeBoundsPadding, -dudeBoundsPadding, this.sizew + dudeBoundsPadding * 2, this.sizeh + dudeBoundsPadding * 2);
            this.tick = 0;
            this.app.ticker.add(this.runExample);
            this.exampleReady();
        };
        this.runExample = (delta) => {
            for (let i = 0; i < this.maggots.length; i++) {
                const dude = this.maggots[i];
                dude.scale.y = 0.95 + Math.sin(this.tick + dude.offset) * 0.05;
                dude.direction += dude.turningSpeed * 0.01;
                dude.x += Math.sin(dude.direction) * (dude.speed * dude.scale.y);
                dude.y += Math.cos(dude.direction) * (dude.speed * dude.scale.y);
                dude.rotation = -dude.direction + Math.PI;
                if (dude.x < this.dudeBounds.x) {
                    dude.x += this.dudeBounds.width;
                }
                else if (dude.x > this.dudeBounds.x + this.dudeBounds.width) {
                    dude.x -= this.dudeBounds.width;
                }
                if (dude.y < this.dudeBounds.y) {
                    dude.y += this.dudeBounds.height;
                }
                else if (dude.y > this.dudeBounds.y + this.dudeBounds.height) {
                    dude.y -= this.dudeBounds.height;
                }
            }
            this.tick += 0.1;
        };
        this.activateMask();
        this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/maggot_tiny.png"));
        this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleResourceLoaded);
        this.loader.load();
    }
    destructor() {
        super.destructor();
        this.app.ticker.remove(this.runExample, null);
        this.maggots = null;
    }
}
exports.BasicParticles = BasicParticles;
class ExtendedSprite extends Sprite_1.Sprite {
}


/***/ }),

/***/ "./js-compile/examples/BasicTinting.js":
/*!*********************************************!*\
  !*** ./js-compile/examples/BasicTinting.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseExample_1 = __webpack_require__(/*! ./BaseExample */ "./js-compile/examples/BaseExample.js");
const ResourceLoader_1 = __webpack_require__(/*! ../raw-pixi-ts/ResourceLoader */ "./js-compile/raw-pixi-ts/ResourceLoader.js");
const Event_1 = __webpack_require__(/*! ../raw-pixi-ts/Event */ "./js-compile/raw-pixi-ts/Event.js");
const URLRequest_1 = __webpack_require__(/*! ../raw-pixi-ts/URLRequest */ "./js-compile/raw-pixi-ts/URLRequest.js");
const Texture_1 = __webpack_require__(/*! ../raw-pixi-ts/Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const BaseTexture_1 = __webpack_require__(/*! ../raw-pixi-ts/BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const Sprite_1 = __webpack_require__(/*! ../raw-pixi-ts/Sprite */ "./js-compile/raw-pixi-ts/Sprite.js");
const Rectangle_1 = __webpack_require__(/*! ../flash/geom/Rectangle */ "./js-compile/flash/geom/Rectangle.js");
class BasicTinting extends BaseExample_1.BaseExample {
    constructor(app, width, height) {
        super(app, width, height);
        this.handleResourceLoaded = (event) => {
            let txt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            this.aliens = [];
            const totalDudes = 20;
            for (let i = 0; i < totalDudes; i++) {
                const dude = new ExtendedSprite(txt);
                dude.anchor.set(0.5);
                dude.scale.set(0.8 + Math.random() * 0.3);
                dude.x = Math.random() * this.sizew;
                dude.y = Math.random() * this.sizeh;
                dude.tint = Math.random() * 0xFFFFFF;
                dude.direction = Math.random() * Math.PI * 2;
                dude.turningSpeed = Math.random() - 0.8;
                dude.speed = 2 + Math.random() * 2;
                this.aliens.push(dude);
                this.stage.addChild(dude);
            }
            const dudeBoundsPadding = 100;
            this.dudeBounds = Rectangle_1.Rectangle.getRectangle(-dudeBoundsPadding, -dudeBoundsPadding, this.sizew + dudeBoundsPadding * 2, this.sizeh + dudeBoundsPadding * 2);
            this.app.ticker.add(this.runExample);
            this.exampleReady();
        };
        this.runExample = (delta) => {
            for (let i = 0; i < this.aliens.length; i++) {
                const dude = this.aliens[i];
                dude.direction += dude.turningSpeed * 0.01;
                dude.x += Math.sin(dude.direction) * dude.speed;
                dude.y += Math.cos(dude.direction) * dude.speed;
                dude.rotation = -dude.direction - Math.PI / 2;
                if (dude.x < this.dudeBounds.x) {
                    dude.x += this.dudeBounds.width;
                }
                else if (dude.x > this.dudeBounds.x + this.dudeBounds.width) {
                    dude.x -= this.dudeBounds.width;
                }
                if (dude.y < this.dudeBounds.y) {
                    dude.y += this.dudeBounds.height;
                }
                else if (dude.y > this.dudeBounds.y + this.dudeBounds.height) {
                    dude.y -= this.dudeBounds.height;
                }
            }
        };
        this.backColor = 0xFFF000;
        this.activateMask();
        this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/eggHead.png"));
        this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleResourceLoaded);
        this.loader.load();
    }
    destructor() {
        super.destructor();
        this.app.ticker.remove(this.runExample, null);
        this.aliens = null;
    }
}
exports.BasicTinting = BasicTinting;
class ExtendedSprite extends Sprite_1.Sprite {
}


/***/ }),

/***/ "./js-compile/examples/FilterBlending.js":
/*!***********************************************!*\
  !*** ./js-compile/examples/FilterBlending.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseExample_1 = __webpack_require__(/*! ./BaseExample */ "./js-compile/examples/BaseExample.js");
const ResourceLoader_1 = __webpack_require__(/*! ../raw-pixi-ts/ResourceLoader */ "./js-compile/raw-pixi-ts/ResourceLoader.js");
const URLRequest_1 = __webpack_require__(/*! ../raw-pixi-ts/URLRequest */ "./js-compile/raw-pixi-ts/URLRequest.js");
const Event_1 = __webpack_require__(/*! ../raw-pixi-ts/Event */ "./js-compile/raw-pixi-ts/Event.js");
const Texture_1 = __webpack_require__(/*! ../raw-pixi-ts/Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const BaseTexture_1 = __webpack_require__(/*! ../raw-pixi-ts/BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const Sprite_1 = __webpack_require__(/*! ../raw-pixi-ts/Sprite */ "./js-compile/raw-pixi-ts/Sprite.js");
const Container_1 = __webpack_require__(/*! ../raw-pixi-ts/Container */ "./js-compile/raw-pixi-ts/Container.js");
const Rectangle_1 = __webpack_require__(/*! ../flash/geom/Rectangle */ "./js-compile/flash/geom/Rectangle.js");
const Filter_1 = __webpack_require__(/*! ../raw-pixi-ts/Filter */ "./js-compile/raw-pixi-ts/Filter.js");
const Point_1 = __webpack_require__(/*! ../flash/geom/Point */ "./js-compile/flash/geom/Point.js");
class FilterBlending extends BaseExample_1.BaseExample {
    constructor(app, width, height) {
        super(app, width, height);
        this.handleGrassLoaded = (event) => {
            this.backgroundtxt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            const background = new Sprite_1.Sprite(this.backgroundtxt);
            background.width = this.sizew;
            background.height = this.sizeh;
            this.stage.addChild(background);
            const shaderFrag = `
            precision highp float;
            varying vec2 vTextureCoord;
            uniform vec2 mouse;
            uniform vec4 inputSize;
            uniform vec4 outputFrame;
            uniform float time;
            void main() {
            vec2 screenPos = vTextureCoord * inputSize.xy + outputFrame.xy;
            if (length(mouse - screenPos) < 25.0) {
                gl_FragColor = vec4(1.0, 1.0, 0.0, 1.0) * 0.7; //yellow circle, alpha=0.7
            } else {
                gl_FragColor = vec4( sin(time), (mouse.xy - outputFrame.xy) / outputFrame.zw, 1.0) * 0.5; // blend with underlying image, alpha=0.5
            }
            }
            `;
            const container = new Container_1.Container();
            container.filterArea = Rectangle_1.Rectangle.getRectangle(100, 100, this.sizew - 200, this.sizeh - 200);
            this.stage.addChild(container);
            this.filter = new Filter_1.Filter(null, shaderFrag, {
                mouse: Point_1.Point.getPoint()
            });
            container.filters = [this.filter];
            this.app.ticker.add(this.runExample);
            this.exampleReady();
        };
        this.runExample = (delta) => {
            this.filter.uniforms.mouse.copyFrom(this.app.renderer.plugins.interaction.mouse.global);
        };
        this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/bg_grass.jpg"));
        this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleGrassLoaded);
        this.loader.load();
    }
    destructor() {
        super.destructor();
        this.backgroundtxt.destroy(null);
        this.backgroundtxt = null;
        this.filter.destroy();
        this.filter = null;
        this.app.ticker.remove(this.runExample, null);
    }
}
exports.FilterBlending = FilterBlending;


/***/ }),

/***/ "./js-compile/examples/FilterBlur.js":
/*!*******************************************!*\
  !*** ./js-compile/examples/FilterBlur.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseExample_1 = __webpack_require__(/*! ./BaseExample */ "./js-compile/examples/BaseExample.js");
const ResourceLoader_1 = __webpack_require__(/*! ../raw-pixi-ts/ResourceLoader */ "./js-compile/raw-pixi-ts/ResourceLoader.js");
const Texture_1 = __webpack_require__(/*! ../raw-pixi-ts/Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const URLRequest_1 = __webpack_require__(/*! ../raw-pixi-ts/URLRequest */ "./js-compile/raw-pixi-ts/URLRequest.js");
const Event_1 = __webpack_require__(/*! ../raw-pixi-ts/Event */ "./js-compile/raw-pixi-ts/Event.js");
const BaseTexture_1 = __webpack_require__(/*! ../raw-pixi-ts/BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const Sprite_1 = __webpack_require__(/*! ../raw-pixi-ts/Sprite */ "./js-compile/raw-pixi-ts/Sprite.js");
const BlurFilter_1 = __webpack_require__(/*! ../raw-pixi-ts/BlurFilter */ "./js-compile/raw-pixi-ts/BlurFilter.js");
class FilterBlur extends BaseExample_1.BaseExample {
    constructor(app, width, height) {
        super(app, width, height);
        this.handleMobyLoaded = (event) => {
            this.mobyTxt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            const bg = new Sprite_1.Sprite(this.depthTxt);
            bg.width = this.sizew;
            bg.height = this.sizeh;
            this.stage.addChild(bg);
            const littleDudes = new Sprite_1.Sprite(this.dudesTxt);
            littleDudes.x = (this.sizew / 2) - 315;
            littleDudes.y = 200;
            this.stage.addChild(littleDudes);
            const littleRobot = new Sprite_1.Sprite(this.mobyTxt);
            littleRobot.x = (this.sizew / 2) - 200;
            littleRobot.y = 100;
            this.stage.addChild(littleRobot);
            this.blurFilter1 = new BlurFilter_1.BlurFilter();
            this.blurFilter2 = new BlurFilter_1.BlurFilter();
            littleDudes.filters = [this.blurFilter1];
            littleRobot.filters = [this.blurFilter2];
            this.count = 0;
            this.app.ticker.add(this.runExample);
            this.exampleReady();
        };
        this.runExample = (delta) => {
            this.count += 0.005;
            const blurAmount = Math.cos(this.count);
            const blurAmount2 = Math.sin(this.count);
            this.blurFilter1.blur = 20 * (blurAmount);
            this.blurFilter2.blur = 20 * (blurAmount2);
        };
        this.handleDudesLoaded = (event) => {
            this.dudesTxt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/pixi-filters/depth_blur_moby.jpg"));
            this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleMobyLoaded);
            this.loader.load();
        };
        this.handleDepthLoaded = (event) => {
            this.depthTxt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/pixi-filters/depth_blur_dudes.jpg"));
            this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleDudesLoaded);
            this.loader.load();
        };
        this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/pixi-filters/bg_depth_blur.jpg"));
        this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleDepthLoaded);
        this.loader.load();
    }
    destructor() {
        super.destructor();
        this.app.ticker.remove(this.runExample, null);
        this.blurFilter1.destroy();
        this.blurFilter1 = null;
        this.blurFilter2.destroy();
        this.blurFilter2 = null;
        this.mobyTxt.destroy(null);
        this.mobyTxt = null;
        this.dudesTxt.destroy(null);
        this.dudesTxt = null;
        this.depthTxt.destroy(null);
        this.depthTxt = null;
    }
}
exports.FilterBlur = FilterBlur;


/***/ }),

/***/ "./js-compile/examples/FilterColor.js":
/*!********************************************!*\
  !*** ./js-compile/examples/FilterColor.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseExample_1 = __webpack_require__(/*! ./BaseExample */ "./js-compile/examples/BaseExample.js");
const ResourceLoader_1 = __webpack_require__(/*! ../raw-pixi-ts/ResourceLoader */ "./js-compile/raw-pixi-ts/ResourceLoader.js");
const Texture_1 = __webpack_require__(/*! ../raw-pixi-ts/Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const URLRequest_1 = __webpack_require__(/*! ../raw-pixi-ts/URLRequest */ "./js-compile/raw-pixi-ts/URLRequest.js");
const Event_1 = __webpack_require__(/*! ../raw-pixi-ts/Event */ "./js-compile/raw-pixi-ts/Event.js");
const BaseTexture_1 = __webpack_require__(/*! ../raw-pixi-ts/BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const Sprite_1 = __webpack_require__(/*! ../raw-pixi-ts/Sprite */ "./js-compile/raw-pixi-ts/Sprite.js");
const ColorMatrixFilter_1 = __webpack_require__(/*! ../raw-pixi-ts/ColorMatrixFilter */ "./js-compile/raw-pixi-ts/ColorMatrixFilter.js");
const Text_1 = __webpack_require__(/*! ../raw-pixi-ts/Text */ "./js-compile/raw-pixi-ts/Text.js");
const Container_1 = __webpack_require__(/*! ../raw-pixi-ts/Container */ "./js-compile/raw-pixi-ts/Container.js");
const MouseEvent_1 = __webpack_require__(/*! ../raw-pixi-ts/MouseEvent */ "./js-compile/raw-pixi-ts/MouseEvent.js");
class FilterColor extends BaseExample_1.BaseExample {
    constructor(app, width, height) {
        super(app, width, height);
        this.handlePandaLoaded = (event) => {
            this.pandaTxt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            this.bg = new Sprite_1.Sprite(this.rotateTxt);
            this.bg.anchor.set(0.5);
            this.bg.x = this.sizew / 2;
            this.bg.y = this.sizeh / 2;
            this.filter = new ColorMatrixFilter_1.ColorMatrixFilter();
            const container = new Container_1.Container();
            container.x = this.sizew / 2;
            container.y = this.sizeh / 2;
            this.bgFront = new Sprite_1.Sprite(this.scenerotateTxt);
            this.bgFront.anchor.set(0.5);
            container.addChild(this.bgFront);
            this.light2 = new Sprite_1.Sprite(this.lightrotate2Txt);
            this.light2.anchor.set(0.5);
            container.addChild(this.light2);
            this.light1 = new Sprite_1.Sprite(this.lightrotate1Txt);
            this.light1.anchor.set(0.5);
            container.addChild(this.light1);
            this.panda = new Sprite_1.Sprite(this.pandaTxt);
            this.panda.anchor.set(0.5);
            container.addChild(this.panda);
            this.stage.addChild(container);
            this.stage.filters = [this.filter];
            this.count = 0;
            this.enabled = true;
            this.stage.addEventListener(MouseEvent_1.MouseEvent.POINTER_TAP, this.handlePointer);
            const help = new Text_1.Text('Click or tap to turn filters on / off.', {
                fontFamily: 'Arial',
                fontSize: 12,
                fontWeight: 'bold',
                fill: 'white',
            });
            help.y = this.sizeh - 25;
            help.x = 10;
            this.stage.addChild(help);
            this.app.ticker.add(this.runExample);
            this.exampleReady();
        };
        this.runExample = (delta) => {
            this.bg.rotation += 0.01;
            this.bgFront.rotation -= 0.01;
            this.light1.rotation += 0.02;
            this.light2.rotation += 0.01;
            this.panda.scale.x = 1 + Math.sin(this.count) * 0.04;
            this.panda.scale.y = 1 + Math.cos(this.count) * 0.04;
            this.count += 0.1;
            const { matrix } = this.filter;
            matrix[1] = Math.sin(this.count) * 3;
            matrix[2] = Math.cos(this.count);
            matrix[3] = Math.cos(this.count) * 1.5;
            matrix[4] = Math.sin(this.count / 3) * 2;
            matrix[5] = Math.sin(this.count / 2);
            matrix[6] = Math.sin(this.count / 4);
        };
        this.handlePointer = (event) => {
            this.enabled = !this.enabled;
            this.stage.filters = this.enabled ? [this.filter] : null;
        };
        this.handleLightRotate1Loaded = (event) => {
            this.lightrotate1Txt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/light_rotate_1.png"));
            this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleLightRotate1Loaded);
            this.loader.load();
        };
        this.handleRotateLoaded = (event) => {
            this.rotateTxt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/bg_scene_rotate.jpg"));
            this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleSceneRotateLoaded);
            this.loader.load();
        };
        this.handleSceneRotateLoaded = (event) => {
            this.scenerotateTxt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/light_rotate_2.png"));
            this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleLightRotate2Loaded);
            this.loader.load();
        };
        this.handleLightRotate2Loaded = (event) => {
            this.lightrotate2Txt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/panda.png"));
            this.loader.addEventListener(Event_1.Event.COMPLETE, this.handlePandaLoaded);
            this.loader.load();
        };
        this.backColor = 0;
        this.activateMask();
        this.stage.interactive = true;
        this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/bg_rotate.jpg"));
        this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleRotateLoaded);
        this.loader.load();
    }
    destructor() {
        super.destructor();
        if (this.bg) {
            this.bg.destructor();
        }
        this.bg = null;
        if (this.bgFront) {
            this.bgFront.destructor();
        }
        this.bgFront = null;
        if (this.light2) {
            this.light2.destructor();
        }
        this.light2 = null;
        if (this.panda) {
            this.panda.destructor();
        }
        this.panda = null;
        if (this.light1) {
            this.light1.destructor();
        }
        this.light1 = null;
        if (this.filter) {
            this.filter.destructor();
        }
        this.filter = null;
        this.app.ticker.remove(this.runExample, null);
        if (this.rotateTxt) {
            this.rotateTxt.destructor();
        }
        this.rotateTxt = null;
        if (this.scenerotateTxt) {
            this.scenerotateTxt.destructor();
        }
        this.scenerotateTxt = null;
        if (this.lightrotate2Txt) {
            this.lightrotate2Txt.destructor();
        }
        this.lightrotate2Txt = null;
        if (this.lightrotate1Txt) {
            this.lightrotate1Txt.destructor();
        }
        this.lightrotate1Txt = null;
        if (this.pandaTxt) {
            this.pandaTxt.destructor();
        }
        this.pandaTxt = null;
    }
}
exports.FilterColor = FilterColor;


/***/ }),

/***/ "./js-compile/examples/FilterCrawlies.js":
/*!***********************************************!*\
  !*** ./js-compile/examples/FilterCrawlies.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseExample_1 = __webpack_require__(/*! ./BaseExample */ "./js-compile/examples/BaseExample.js");
const ResourceLoader_1 = __webpack_require__(/*! ../raw-pixi-ts/ResourceLoader */ "./js-compile/raw-pixi-ts/ResourceLoader.js");
const Texture_1 = __webpack_require__(/*! ../raw-pixi-ts/Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const Container_1 = __webpack_require__(/*! ../raw-pixi-ts/Container */ "./js-compile/raw-pixi-ts/Container.js");
const Rectangle_1 = __webpack_require__(/*! ../flash/geom/Rectangle */ "./js-compile/flash/geom/Rectangle.js");
const MouseEvent_1 = __webpack_require__(/*! ../raw-pixi-ts/MouseEvent */ "./js-compile/raw-pixi-ts/MouseEvent.js");
const Sprite_1 = __webpack_require__(/*! ../raw-pixi-ts/Sprite */ "./js-compile/raw-pixi-ts/Sprite.js");
const URLRequest_1 = __webpack_require__(/*! ../raw-pixi-ts/URLRequest */ "./js-compile/raw-pixi-ts/URLRequest.js");
const Event_1 = __webpack_require__(/*! ../raw-pixi-ts/Event */ "./js-compile/raw-pixi-ts/Event.js");
const BaseTexture_1 = __webpack_require__(/*! ../raw-pixi-ts/BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const Point_1 = __webpack_require__(/*! ../flash/geom/Point */ "./js-compile/flash/geom/Point.js");
const DisplacementFilter_1 = __webpack_require__(/*! ../raw-pixi-ts/DisplacementFilter */ "./js-compile/raw-pixi-ts/DisplacementFilter.js");
class FilterCrawlies extends BaseExample_1.BaseExample {
    constructor(app, width, height) {
        super(app, width, height);
        this.handleGrassLoaded = (event) => {
            this.grassTxt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            this.container = new Container_1.Container();
            this.stage.addChild(this.container);
            const padding = 100;
            this.bounds = Rectangle_1.Rectangle.getRectangle(-padding, -padding, this.sizew + padding * 2, this.sizeh + padding * 2);
            for (let i = 0; i < 20; i++) {
                const maggot = new ExtendedSprite(this.maggotTxt);
                maggot.anchor.set(0.5);
                this.container.addChild(maggot);
                maggot.direction = Math.random() * Math.PI * 2;
                maggot.speed = 1;
                maggot.turnSpeed = Math.random() - 0.8;
                maggot.x = Math.random() * this.bounds.width;
                maggot.y = Math.random() * this.bounds.height;
                maggot.scale.set(1 + Math.random() * 0.3);
                maggot.original = Point_1.Point.getPoint();
                maggot.original.copyFrom(maggot.scale);
                this.maggots.push(maggot);
            }
            this.displacementSprite = new Sprite_1.Sprite(this.displacementTxt);
            const displacementFilter = new DisplacementFilter_1.DisplacementFilter(this.displacementSprite);
            this.stage.addChild(this.displacementSprite);
            this.container.filters = [displacementFilter];
            displacementFilter.scale.x = 110;
            displacementFilter.scale.y = 110;
            this.displacementSprite.anchor.set(0.5);
            this.ring = new Sprite_1.Sprite(this.ringTxt);
            this.ring.anchor.set(0.5);
            this.ring.visible = false;
            this.stage.addChild(this.ring);
            const bg = new Sprite_1.Sprite(this.grassTxt);
            bg.width = this.sizew;
            bg.height = this.sizeh;
            bg.alpha = 0.4;
            this.container.addChild(bg);
            this.stage.addEventListener(MouseEvent_1.MouseEvent.MOUSE_MOVE, this.onPointerMove);
            this.stage.addEventListener(MouseEvent_1.MouseEvent.TOUCH_MOVE, this.onPointerMove);
            this.app.ticker.add(this.runExample);
            this.exampleReady();
        };
        this.handleMaggotLoaded = (event) => {
            this.maggotTxt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest('examples/assets/bg_grass.jpg'));
            this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleGrassLoaded);
            this.loader.load();
        };
        this.handleRingLoaded = (event) => {
            this.ringTxt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest('examples/assets/maggot.png'));
            this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleMaggotLoaded);
            this.loader.load();
        };
        this.handleDisplacementLoaded = (event) => {
            this.displacementTxt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest('examples/assets/pixi-filters/ring.png'));
            this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleRingLoaded);
            this.loader.load();
        };
        this.handleRotateLoaded = (event) => {
            this.maggotTxt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest('examples/assets/pixi-filters/displace.png'));
            this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleDisplacementLoaded);
            this.loader.load();
        };
        this.onPointerMove = (event) => {
            this.ring.visible = true;
            this.displacementSprite.position.set(event.data.global.x - 25, event.data.global.y);
            this.ring.position.copyFrom(this.displacementSprite.position);
        };
        this.runExample = (delta) => {
            this.count += 0.05;
            for (let i = 0; i < this.maggots.length; i++) {
                const maggot = this.maggots[i];
                maggot.direction += maggot.turnSpeed * 0.01;
                maggot.x += Math.sin(maggot.direction) * maggot.speed;
                maggot.y += Math.cos(maggot.direction) * maggot.speed;
                maggot.rotation = -maggot.direction - Math.PI / 2;
                maggot.scale.x = maggot.original.x + Math.sin(this.count) * 0.2;
                if (maggot.x < this.bounds.x) {
                    maggot.x += this.bounds.width;
                }
                else if (maggot.x > this.bounds.x + this.bounds.width) {
                    maggot.x -= this.bounds.width;
                }
                if (maggot.y < this.bounds.y) {
                    maggot.y += this.bounds.height;
                }
                else if (maggot.y > this.bounds.y + this.bounds.height) {
                    maggot.y -= this.bounds.height;
                }
            }
        };
        this.activateMask();
        this.count = 0;
        this.maggots = [];
        this.stage.interactive = true;
        this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/bg_rotate.jpg"));
        this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleRotateLoaded);
        this.loader.load();
    }
    destructor() {
        super.destructor();
        this.maggotTxt.destroy(null);
        this.maggotTxt = null;
        this.displacementTxt.destroy(null);
        this.displacementTxt = null;
        this.ringTxt.destroy(null);
        this.ringTxt = null;
        this.grassTxt.destroy(null);
        this.grassTxt = null;
        if (this.maggots && this.maggots.length) {
            while (this.maggots.length) {
                let maggot = this.maggots.shift();
                maggot.destructor();
            }
        }
        this.maggots = null;
        this.ring.destroy(null);
        this.ring = null;
        this.app.ticker.remove(this.runExample, null);
        this.displacementSprite.destroy(null);
        this.displacementSprite = null;
        this.container.destroy(null);
        this.container = null;
    }
}
exports.FilterCrawlies = FilterCrawlies;
class ExtendedSprite extends Sprite_1.Sprite {
    destructor() {
        super.destructor();
        if (this.original) {
            this.original.recycle();
        }
        this.original = null;
    }
}


/***/ }),

/***/ "./js-compile/examples/FilterCustom.js":
/*!*********************************************!*\
  !*** ./js-compile/examples/FilterCustom.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseExample_1 = __webpack_require__(/*! ./BaseExample */ "./js-compile/examples/BaseExample.js");
const ResourceLoader_1 = __webpack_require__(/*! ../raw-pixi-ts/ResourceLoader */ "./js-compile/raw-pixi-ts/ResourceLoader.js");
const Texture_1 = __webpack_require__(/*! ../raw-pixi-ts/Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const URLRequest_1 = __webpack_require__(/*! ../raw-pixi-ts/URLRequest */ "./js-compile/raw-pixi-ts/URLRequest.js");
const Event_1 = __webpack_require__(/*! ../raw-pixi-ts/Event */ "./js-compile/raw-pixi-ts/Event.js");
const BaseTexture_1 = __webpack_require__(/*! ../raw-pixi-ts/BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const Sprite_1 = __webpack_require__(/*! ../raw-pixi-ts/Sprite */ "./js-compile/raw-pixi-ts/Sprite.js");
const URLLoader_1 = __webpack_require__(/*! ../raw-pixi-ts/URLLoader */ "./js-compile/raw-pixi-ts/URLLoader.js");
const Filter_1 = __webpack_require__(/*! ../raw-pixi-ts/Filter */ "./js-compile/raw-pixi-ts/Filter.js");
class FilterCustom extends BaseExample_1.BaseExample {
    constructor(app, width, height) {
        super(app, width, height);
        this.handleGrassLoaded = (event) => {
            this.grasstxt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            this.background = new Sprite_1.Sprite(this.grasstxt);
            this.background.width = this.sizew;
            this.background.height = this.sizeh;
            this.stage.addChild(this.background);
            this.urlloader = new URLLoader_1.URLLoader();
            this.urlloader.addEventListener(Event_1.Event.COMPLETE, this.handleFragLoaded);
            this.urlloader.load(new URLRequest_1.URLRequest("examples/assets/pixi-filters/shader.frag"));
        };
        this.handleFragLoaded = (event) => {
            let fragdata = this.urlloader.data;
            this.filter = new Filter_1.Filter(null, fragdata, {
                customUniform: 0.0
            });
            this.background.filters = [this.filter];
            this.app.ticker.add(this.runExample);
            this.exampleReady();
        };
        this.runExample = (delta) => {
            this.filter.uniforms.customUniform += 0.04 * delta;
        };
        this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/bg_grass.jpg"));
        this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleGrassLoaded);
        this.loader.load();
    }
    destructor() {
        super.destructor();
        this.app.ticker.remove(this.runExample, null);
        this.grasstxt.destroy(null);
        this.grasstxt = null;
        this.background.destroy(null);
        this.background = null;
        this.filter.destroy();
        this.filter = null;
    }
}
exports.FilterCustom = FilterCustom;


/***/ }),

/***/ "./js-compile/examples/FilterFlag.js":
/*!*******************************************!*\
  !*** ./js-compile/examples/FilterFlag.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseExample_1 = __webpack_require__(/*! ./BaseExample */ "./js-compile/examples/BaseExample.js");
const Container_1 = __webpack_require__(/*! ../raw-pixi-ts/Container */ "./js-compile/raw-pixi-ts/Container.js");
const ResourceLoader_1 = __webpack_require__(/*! ../raw-pixi-ts/ResourceLoader */ "./js-compile/raw-pixi-ts/ResourceLoader.js");
const Texture_1 = __webpack_require__(/*! ../raw-pixi-ts/Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const URLRequest_1 = __webpack_require__(/*! ../raw-pixi-ts/URLRequest */ "./js-compile/raw-pixi-ts/URLRequest.js");
const Event_1 = __webpack_require__(/*! ../raw-pixi-ts/Event */ "./js-compile/raw-pixi-ts/Event.js");
const BaseTexture_1 = __webpack_require__(/*! ../raw-pixi-ts/BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const Sprite_1 = __webpack_require__(/*! ../raw-pixi-ts/Sprite */ "./js-compile/raw-pixi-ts/Sprite.js");
const WebGLSettings_1 = __webpack_require__(/*! ../raw-pixi-ts/WebGLSettings */ "./js-compile/raw-pixi-ts/WebGLSettings.js");
const DisplacementFilter_1 = __webpack_require__(/*! ../raw-pixi-ts/DisplacementFilter */ "./js-compile/raw-pixi-ts/DisplacementFilter.js");
class FilterFlag extends BaseExample_1.BaseExample {
    constructor(app, width, height) {
        super(app, width, height);
        this.handleDisplacementLoaded = (event) => {
            this.repeatTxt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            const container = new Container_1.Container();
            this.stage.addChild(container);
            const flag = new Sprite_1.Sprite(this.flagTxt);
            container.addChild(flag);
            flag.x = 100;
            flag.y = 100;
            this.displacementSprite = new Sprite_1.Sprite(this.repeatTxt);
            this.displacementSprite.texture.baseTexture.wrapMode = WebGLSettings_1.WebGLSettings.WRAP_MODES.REPEAT;
            const displacementFilter = new DisplacementFilter_1.DisplacementFilter(this.displacementSprite);
            displacementFilter.padding = 10;
            this.displacementSprite.position = flag.position;
            this.stage.addChild(this.displacementSprite);
            flag.filters = [displacementFilter];
            displacementFilter.scale.x = 30;
            displacementFilter.scale.y = 60;
            this.app.ticker.add(this.runExample);
            this.exampleReady();
        };
        this.runExample = (delta) => {
            this.displacementSprite.x++;
            if (this.displacementSprite.x > this.displacementSprite.width) {
                this.displacementSprite.x = 0;
            }
        };
        this.handleRotateLoaded = (event) => {
            this.flagTxt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest('examples/assets/pixi-filters/displacement_map_repeat.jpg'));
            this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleDisplacementLoaded);
            this.loader.load();
        };
        this.stage.interactive = true;
        this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/pixi-filters/flag.png"));
        this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleRotateLoaded);
        this.loader.load();
    }
    destructor() {
        super.destructor();
        this.flagTxt.destroy(null);
        this.flagTxt = null;
        this.repeatTxt.destroy(null);
        this.repeatTxt = null;
        this.displacementSprite.destroy(null);
        this.displacementSprite = null;
        this.app.ticker.remove(this.runExample, null);
    }
}
exports.FilterFlag = FilterFlag;


/***/ }),

/***/ "./js-compile/examples/FilterShadow.js":
/*!*********************************************!*\
  !*** ./js-compile/examples/FilterShadow.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseExample_1 = __webpack_require__(/*! ./BaseExample */ "./js-compile/examples/BaseExample.js");
const URLLoader_1 = __webpack_require__(/*! ../raw-pixi-ts/URLLoader */ "./js-compile/raw-pixi-ts/URLLoader.js");
const Event_1 = __webpack_require__(/*! ../raw-pixi-ts/Event */ "./js-compile/raw-pixi-ts/Event.js");
const URLRequest_1 = __webpack_require__(/*! ../raw-pixi-ts/URLRequest */ "./js-compile/raw-pixi-ts/URLRequest.js");
const ResourceLoader_1 = __webpack_require__(/*! ../raw-pixi-ts/ResourceLoader */ "./js-compile/raw-pixi-ts/ResourceLoader.js");
const Texture_1 = __webpack_require__(/*! ../raw-pixi-ts/Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const BaseTexture_1 = __webpack_require__(/*! ../raw-pixi-ts/BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const Spritesheet_1 = __webpack_require__(/*! ../raw-pixi-ts/Spritesheet */ "./js-compile/raw-pixi-ts/Spritesheet.js");
const AnimatedSprite_1 = __webpack_require__(/*! ../raw-pixi-ts/AnimatedSprite */ "./js-compile/raw-pixi-ts/AnimatedSprite.js");
const Filter_1 = __webpack_require__(/*! ../raw-pixi-ts/Filter */ "./js-compile/raw-pixi-ts/Filter.js");
class FilterShadow extends BaseExample_1.BaseExample {
    constructor(app, width, height) {
        super(app, width, height);
        this.onAnimationParsed = (textures) => {
            this.stage.interactive = true;
            const frames = [];
            for (let i = 0; i < 30; i++) {
                const val = i < 10 ? `0${i}` : i;
                frames.push(textures[`rollSequence00${val}.png`]);
            }
            this.anim = new AnimatedSprite_1.AnimatedSprite(frames);
            this.anim.x = this.sizew / 2;
            this.anim.y = this.sizeh / 2;
            this.anim.anchor.set(0.5);
            this.anim.animationSpeed = 0.5;
            this.anim.play();
            this.stage.addChild(this.anim);
            this.filter = new Filter_1.Filter(FilterShadow.myVertex, FilterShadow.myFragment);
            this.filter.uniforms.shadowDirection = [0.1, 0.5];
            this.filter.uniforms.floorY = this.anim.height * 2;
            this.filter.padding = 200;
            this.anim.filters = [this.filter];
            this.app.ticker.add(this.runExample);
            this.exampleReady();
        };
        this.runExample = (delta) => {
            this.filter.uniforms.floorY = this.app.renderer.plugins.interaction.mouse.global.y;
        };
        this.handleJsonLoaded = (event) => {
            this.jsondata = JSON.parse(this.urlloader.data);
            this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/spritesheet/fighter.png"));
            this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleRotateLoaded);
            this.loader.load();
        };
        this.handleRotateLoaded = (event) => {
            this.txt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            let spritesheet = new Spritesheet_1.Spritesheet(this.txt, this.jsondata);
            spritesheet.parse(this.onAnimationParsed);
        };
        this.urlloader = new URLLoader_1.URLLoader();
        this.urlloader.addEventListener(Event_1.Event.COMPLETE, this.handleJsonLoaded);
        this.urlloader.load(new URLRequest_1.URLRequest("examples/assets/spritesheet/fighter.json"));
    }
    destructor() {
        super.destructor();
        this.app.ticker.remove(this.runExample, null);
        this.txt.destroy(null);
        this.txt = null;
        this.anim.destroy(null);
        this.anim = null;
        this.filter.destroy();
        this.filter = null;
        this.jsondata = null;
    }
}
FilterShadow.myVertex = `
        attribute vec2 aVertexPosition;
        attribute vec2 aTextureCoord;
        uniform mat3 projectionMatrix;
        varying vec2 vTextureCoord;
        void main(void) {
            gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);
            vTextureCoord = aTextureCoord;
        }
    `;
FilterShadow.myFragment = `
        varying vec2 vTextureCoord;
        uniform sampler2D uSampler;
        uniform vec4 inputSize;
        uniform vec4 outputFrame;
        uniform vec2 shadowDirection;
        uniform float floorY;
        void main(void) {
            //1. get the screen coordinate
            vec2 screenCoord = vTextureCoord * inputSize.xy + outputFrame.xy;
            //2. calculate Y shift of our dimension vector
            vec2 shadow;
            //shadow coordinate system is a bit skewed, but it has to be the same for screenCoord.y = floorY
            float paramY = (screenCoord.y - floorY) / shadowDirection.y;
            shadow.y = paramY + floorY;
            shadow.x = screenCoord.x + paramY * shadowDirection.x;
            vec2 bodyFilterCoord = (shadow - outputFrame.xy) * inputSize.zw; // same as / inputSize.xy
            vec4 originalColor = texture2D(uSampler, vTextureCoord);
            vec4 shadowColor = texture2D(uSampler, bodyFilterCoord);
            shadowColor.rgb = vec3(0.0);
            shadowColor.a *= 0.5;
            // normal blend mode coefficients (1, 1-src_alpha)
            // shadow is destination (backdrop), original is source
            gl_FragColor = originalColor + shadowColor * (1.0 - originalColor.a);
        }
    `;
exports.FilterShadow = FilterShadow;


/***/ }),

/***/ "./js-compile/examples/GraphicsAdvanced.js":
/*!*************************************************!*\
  !*** ./js-compile/examples/GraphicsAdvanced.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseExample_1 = __webpack_require__(/*! ./BaseExample */ "./js-compile/examples/BaseExample.js");
const ResourceLoader_1 = __webpack_require__(/*! ../raw-pixi-ts/ResourceLoader */ "./js-compile/raw-pixi-ts/ResourceLoader.js");
const URLRequest_1 = __webpack_require__(/*! ../raw-pixi-ts/URLRequest */ "./js-compile/raw-pixi-ts/URLRequest.js");
const Event_1 = __webpack_require__(/*! ../raw-pixi-ts/Event */ "./js-compile/raw-pixi-ts/Event.js");
const Texture_1 = __webpack_require__(/*! ../raw-pixi-ts/Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const BaseTexture_1 = __webpack_require__(/*! ../raw-pixi-ts/BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const Sprite_1 = __webpack_require__(/*! ../raw-pixi-ts/Sprite */ "./js-compile/raw-pixi-ts/Sprite.js");
const Graphics_1 = __webpack_require__(/*! ../raw-pixi-ts/Graphics */ "./js-compile/raw-pixi-ts/Graphics.js");
class GraphicsAdvanced extends BaseExample_1.BaseExample {
    constructor(app, width, height) {
        super(app, width, height);
        this.handleResourceLoaded = (event) => {
            let txt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            const sprite = new Sprite_1.Sprite(txt);
            const realPath = new Graphics_1.Graphics();
            realPath.lineStyle(2, 0xFFFFFF, 1);
            realPath.moveTo(0, 0);
            realPath.lineTo(100, 200);
            realPath.lineTo(200, 200);
            realPath.lineTo(240, 100);
            realPath.position.x = 50;
            realPath.position.y = 50;
            this.stage.addChild(realPath);
            const bezier = new Graphics_1.Graphics();
            bezier.lineStyle(5, 0xAA0000, 1);
            bezier.bezierCurveTo(100, 200, 200, 200, 240, 100);
            bezier.position.x = 50;
            bezier.position.y = 50;
            this.stage.addChild(bezier);
            const realPath2 = new Graphics_1.Graphics();
            realPath2.lineStyle(2, 0xFFFFFF, 1);
            realPath2.moveTo(0, 0);
            realPath2.lineTo(0, -100);
            realPath2.lineTo(150, 150);
            realPath2.lineTo(240, 100);
            realPath2.position.x = 320;
            realPath2.position.y = 150;
            this.stage.addChild(realPath2);
            const bezier2 = new Graphics_1.Graphics();
            bezier2.lineTextureStyle(10, sprite.texture);
            bezier2.bezierCurveTo(0, -100, 150, 150, 240, 100);
            bezier2.position.x = 320;
            bezier2.position.y = 150;
            this.stage.addChild(bezier2);
            const arc = new Graphics_1.Graphics();
            arc.lineStyle(5, 0xAA00BB, 1);
            arc.arc(600, 100, 50, Math.PI, 2 * Math.PI);
            this.stage.addChild(arc);
            const arc2 = new Graphics_1.Graphics();
            arc2.lineStyle(6, 0x3333DD, 1);
            arc2.arc(650, 270, 60, 2 * Math.PI, 3 * Math.PI / 2);
            this.stage.addChild(arc2);
            const arc3 = new Graphics_1.Graphics();
            arc3.lineTextureStyle(20, sprite.texture);
            arc3.arc(650, 420, 60, 2 * Math.PI, 2.5 * Math.PI / 2);
            this.stage.addChild(arc3);
            const rectAndHole = new Graphics_1.Graphics();
            rectAndHole.beginFill(0x00FF00);
            rectAndHole.drawRect(350, 350, 150, 150);
            rectAndHole.beginHole();
            rectAndHole.drawCircle(375, 375, 25);
            rectAndHole.drawCircle(425, 425, 25);
            rectAndHole.drawCircle(475, 475, 25);
            rectAndHole.endHole();
            rectAndHole.endFill();
            this.stage.addChild(rectAndHole);
            const beatifulRect = new Graphics_1.Graphics();
            beatifulRect.lineTextureStyle(20, sprite.texture);
            beatifulRect.beginFill(0xFF0000);
            beatifulRect.drawRect(80, 350, 150, 150);
            beatifulRect.endFill();
            this.stage.addChild(beatifulRect);
            this.exampleReady();
        };
        this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/bg_rotate.jpg"));
        this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleResourceLoaded);
        this.loader.load();
    }
}
exports.GraphicsAdvanced = GraphicsAdvanced;


/***/ }),

/***/ "./js-compile/examples/GraphicsDynamic.js":
/*!************************************************!*\
  !*** ./js-compile/examples/GraphicsDynamic.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseExample_1 = __webpack_require__(/*! ./BaseExample */ "./js-compile/examples/BaseExample.js");
const Graphics_1 = __webpack_require__(/*! ../raw-pixi-ts/Graphics */ "./js-compile/raw-pixi-ts/Graphics.js");
const MouseEvent_1 = __webpack_require__(/*! ../raw-pixi-ts/MouseEvent */ "./js-compile/raw-pixi-ts/MouseEvent.js");
class GraphicsDynamic extends BaseExample_1.BaseExample {
    constructor(app, width, height) {
        super(app, width, height);
        this.runExample = (delta) => {
            this.count += 0.1;
            this.thing.clear();
            this.thing.lineStyle(10, 0xff0000, 1);
            this.thing.beginFill(0xffFF00, 0.5);
            this.thing.moveTo(-120 + Math.sin(this.count) * 20, -100 + Math.cos(this.count) * 20);
            this.thing.lineTo(120 + Math.cos(this.count) * 20, -100 + Math.sin(this.count) * 20);
            this.thing.lineTo(120 + Math.sin(this.count) * 20, 100 + Math.cos(this.count) * 20);
            this.thing.lineTo(-120 + Math.cos(this.count) * 20, 100 + Math.sin(this.count) * 20);
            this.thing.lineTo(-120 + Math.sin(this.count) * 20, -100 + Math.cos(this.count) * 20);
            this.thing.rotation = this.count * 0.1;
        };
        this.onPointerDown = () => {
            this.graphics.lineStyle(Math.random() * 30, Math.random() * 0xFFFFFF, 1);
            this.graphics.moveTo(Math.random() * 800, Math.random() * 600);
            this.graphics.bezierCurveTo(Math.random() * 800, Math.random() * 600, Math.random() * 800, Math.random() * 600, Math.random() * 800, Math.random() * 600);
        };
        app.stage.interactive = true;
        this.graphics = new Graphics_1.Graphics();
        this.graphics.beginFill(0xFF3300);
        this.graphics.lineStyle(10, 0xffd900, 1);
        this.graphics.moveTo(50, 50);
        this.graphics.lineTo(250, 50);
        this.graphics.lineTo(100, 100);
        this.graphics.lineTo(250, 220);
        this.graphics.lineTo(50, 220);
        this.graphics.lineTo(50, 50);
        this.graphics.endFill();
        this.graphics.lineStyle(10, 0xFF0000, 0.8);
        this.graphics.beginFill(0xFF700B, 1);
        this.graphics.moveTo(210, 300);
        this.graphics.lineTo(450, 320);
        this.graphics.lineTo(570, 350);
        this.graphics.quadraticCurveTo(600, 0, 480, 100);
        this.graphics.lineTo(330, 120);
        this.graphics.lineTo(410, 200);
        this.graphics.lineTo(210, 300);
        this.graphics.endFill();
        this.graphics.lineStyle(2, 0x0000FF, 1);
        this.graphics.drawRect(50, 250, 100, 100);
        this.graphics.lineStyle(0);
        this.graphics.beginFill(0xFFFF0B, 0.5);
        this.graphics.drawCircle(470, 200, 100);
        this.graphics.endFill();
        this.graphics.lineStyle(20, 0x33FF00);
        this.graphics.moveTo(30, 30);
        this.graphics.lineTo(600, 300);
        this.stage.addChild(this.graphics);
        this.thing = new Graphics_1.Graphics();
        this.stage.addChild(this.thing);
        this.thing.x = 800 / 2;
        this.thing.y = 600 / 2;
        this.count = 0;
        app.ticker.add(this.runExample);
        this.stage.interactive = true;
        this.stage.addEventListener(MouseEvent_1.MouseEvent.POINTER_DOWN, this.onPointerDown);
        setTimeout(() => {
            this.exampleReady();
        }, 1000);
    }
    destructor() {
        super.destructor();
        this.app.ticker.remove(this.runExample, null);
        this.graphics.destroy(null);
        this.graphics = null;
        this.thing.destroy(null);
        this.thing = null;
    }
}
exports.GraphicsDynamic = GraphicsDynamic;


/***/ }),

/***/ "./js-compile/examples/GraphicsSimple.js":
/*!***********************************************!*\
  !*** ./js-compile/examples/GraphicsSimple.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseExample_1 = __webpack_require__(/*! ./BaseExample */ "./js-compile/examples/BaseExample.js");
const Graphics_1 = __webpack_require__(/*! ../raw-pixi-ts/Graphics */ "./js-compile/raw-pixi-ts/Graphics.js");
class GraphicsSimple extends BaseExample_1.BaseExample {
    constructor(app, width, height) {
        super(app, width, height);
        this.backColor = 0;
        const graphics = new Graphics_1.Graphics();
        graphics.beginFill(0xDE3249);
        graphics.drawRect(50, 50, 100, 100);
        graphics.endFill();
        graphics.lineStyle(2, 0xFEEB77, 1);
        graphics.beginFill(0x650A5A);
        graphics.drawRect(200, 50, 100, 100);
        graphics.endFill();
        graphics.lineStyle(10, 0xFFBD01, 1);
        graphics.beginFill(0xC34288);
        graphics.drawRect(350, 50, 100, 100);
        graphics.endFill();
        graphics.lineStyle(2, 0xFFFFFF, 1);
        graphics.beginFill(0xAA4F08);
        graphics.drawRect(530, 50, 140, 100);
        graphics.endFill();
        graphics.lineStyle(0); // draw a circle, set the lineStyle to zero so the circle doesn't have an outline
        graphics.beginFill(0xDE3249, 1);
        graphics.drawCircle(100, 250, 50);
        graphics.endFill();
        graphics.lineStyle(2, 0xFEEB77, 1);
        graphics.beginFill(0x650A5A, 1);
        graphics.drawCircle(250, 250, 50);
        graphics.endFill();
        graphics.lineStyle(10, 0xFFBD01, 1);
        graphics.beginFill(0xC34288, 1);
        graphics.drawCircle(400, 250, 50);
        graphics.endFill();
        graphics.lineStyle(2, 0xFFFFFF, 1);
        graphics.beginFill(0xAA4F08, 1);
        graphics.drawEllipse(600, 250, 80, 50);
        graphics.endFill();
        graphics.beginFill(0xFF3300);
        graphics.lineStyle(4, 0xffd900, 1);
        graphics.moveTo(50, 350);
        graphics.lineTo(250, 350);
        graphics.lineTo(100, 400);
        graphics.lineTo(50, 350);
        graphics.endFill();
        graphics.lineStyle(2, 0xFF00FF, 1);
        graphics.beginFill(0x650A5A, 0.25);
        graphics.drawRoundedRect(50, 440, 100, 100, 16);
        graphics.endFill();
        graphics.lineStyle(2, 0xFFFFFF);
        graphics.beginFill(0x35CC5A, 1);
        graphics.drawStar(360, 370, 5, 50);
        graphics.endFill();
        graphics.lineStyle(2, 0xFFFFFF);
        graphics.beginFill(0xFFCC5A, 1);
        graphics.drawStar(280, 510, 7, 50);
        graphics.endFill();
        graphics.lineStyle(4, 0xFFFFFF);
        graphics.beginFill(0x55335A, 1);
        graphics.drawStar(470, 450, 4, 50);
        graphics.endFill();
        const path = [600, 370, 700, 460, 780, 420, 730, 570, 590, 520];
        graphics.lineStyle(0);
        graphics.beginFill(0x3500FA, 1);
        graphics.drawPolygon(path);
        graphics.endFill();
        this.stage.addChild(graphics);
        setTimeout(() => {
            this.exampleReady();
        }, 1000);
    }
}
exports.GraphicsSimple = GraphicsSimple;


/***/ }),

/***/ "./js-compile/examples/InteractionClick.js":
/*!*************************************************!*\
  !*** ./js-compile/examples/InteractionClick.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseExample_1 = __webpack_require__(/*! ./BaseExample */ "./js-compile/examples/BaseExample.js");
const ResourceLoader_1 = __webpack_require__(/*! ../raw-pixi-ts/ResourceLoader */ "./js-compile/raw-pixi-ts/ResourceLoader.js");
const URLRequest_1 = __webpack_require__(/*! ../raw-pixi-ts/URLRequest */ "./js-compile/raw-pixi-ts/URLRequest.js");
const Event_1 = __webpack_require__(/*! ../raw-pixi-ts/Event */ "./js-compile/raw-pixi-ts/Event.js");
const Texture_1 = __webpack_require__(/*! ../raw-pixi-ts/Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const BaseTexture_1 = __webpack_require__(/*! ../raw-pixi-ts/BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const DisplaySettings_1 = __webpack_require__(/*! ../raw-pixi-ts/DisplaySettings */ "./js-compile/raw-pixi-ts/DisplaySettings.js");
const WebGLSettings_1 = __webpack_require__(/*! ../raw-pixi-ts/WebGLSettings */ "./js-compile/raw-pixi-ts/WebGLSettings.js");
const Sprite_1 = __webpack_require__(/*! ../raw-pixi-ts/Sprite */ "./js-compile/raw-pixi-ts/Sprite.js");
const MouseEvent_1 = __webpack_require__(/*! ../raw-pixi-ts/MouseEvent */ "./js-compile/raw-pixi-ts/MouseEvent.js");
class InteractionClick extends BaseExample_1.BaseExample {
    constructor(app, width, height) {
        super(app, width, height);
        this.handleRotateLoaded = (event) => {
            let txt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            DisplaySettings_1.DisplaySettings.SCALE_MODE = WebGLSettings_1.WebGLSettings.SCALE_MODES.NEAREST;
            this.sprite = new Sprite_1.Sprite(txt);
            this.sprite.anchor.set(0.5);
            this.sprite.x = this.sizew / 2;
            this.sprite.y = this.sizeh / 2;
            this.sprite.interactive = true;
            this.sprite.buttonMode = true;
            this.sprite.addEventListener(MouseEvent_1.MouseEvent.POINTER_DOWN, this.onClick);
            this.stage.addChild(this.sprite);
            this.exampleReady();
        };
        this.onClick = (event) => {
            this.sprite.scale.x *= 1.25;
            this.sprite.scale.y *= 1.25;
        };
        this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/bunny.png"));
        this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleRotateLoaded);
        this.loader.load();
    }
    destructor() {
        super.destructor();
        this.sprite.destroy(null);
        this.sprite = null;
    }
}
exports.InteractionClick = InteractionClick;


/***/ }),

/***/ "./js-compile/examples/InteractionDragging.js":
/*!****************************************************!*\
  !*** ./js-compile/examples/InteractionDragging.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseExample_1 = __webpack_require__(/*! ./BaseExample */ "./js-compile/examples/BaseExample.js");
const ResourceLoader_1 = __webpack_require__(/*! ../raw-pixi-ts/ResourceLoader */ "./js-compile/raw-pixi-ts/ResourceLoader.js");
const URLRequest_1 = __webpack_require__(/*! ../raw-pixi-ts/URLRequest */ "./js-compile/raw-pixi-ts/URLRequest.js");
const Event_1 = __webpack_require__(/*! ../raw-pixi-ts/Event */ "./js-compile/raw-pixi-ts/Event.js");
const Texture_1 = __webpack_require__(/*! ../raw-pixi-ts/Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const BaseTexture_1 = __webpack_require__(/*! ../raw-pixi-ts/BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const WebGLSettings_1 = __webpack_require__(/*! ../raw-pixi-ts/WebGLSettings */ "./js-compile/raw-pixi-ts/WebGLSettings.js");
const Sprite_1 = __webpack_require__(/*! ../raw-pixi-ts/Sprite */ "./js-compile/raw-pixi-ts/Sprite.js");
const MouseEvent_1 = __webpack_require__(/*! ../raw-pixi-ts/MouseEvent */ "./js-compile/raw-pixi-ts/MouseEvent.js");
class InteractionDragging extends BaseExample_1.BaseExample {
    constructor(app, width, height) {
        super(app, width, height);
        this.handleRotateLoaded = (event) => {
            let texture = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            texture.baseTexture.scaleMode = WebGLSettings_1.WebGLSettings.SCALE_MODES.NEAREST;
            for (let i = 0; i < 10; i++) {
                this.createBunny(Math.floor(Math.random() * this.sizew), Math.floor(Math.random() * this.sizeh), texture);
            }
            this.exampleReady();
        };
        this.onDragStart = (event) => {
            let button = event.currentTarget;
            button.data = event.data;
            button.alpha = 0.5;
            button.dragging = true;
        };
        this.onDragEnd = (event) => {
            let button = event.currentTarget;
            button.alpha = 1;
            button.dragging = false;
            button.data = null;
        };
        this.onDragMove = (event) => {
            let button = event.currentTarget;
            if (button.dragging) {
                const newPosition = button.data.getLocalPosition(button.parent);
                button.x = newPosition.x;
                button.y = newPosition.y;
            }
        };
        this.activateMask();
        this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/bunny.png"));
        this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleRotateLoaded);
        this.loader.load();
    }
    createBunny(x, y, texture) {
        const bunny = new ExtendedSprite(texture);
        bunny.interactive = true;
        bunny.buttonMode = true;
        bunny.anchor.set(0.5);
        bunny.scale.set(3);
        bunny.addEventListener(MouseEvent_1.MouseEvent.POINTER_DOWN, this.onDragStart);
        bunny.addEventListener(MouseEvent_1.MouseEvent.POINTER_UP, this.onDragEnd);
        bunny.addEventListener(MouseEvent_1.MouseEvent.POINTER_UP_OUTSIDE, this.onDragEnd);
        bunny.addEventListener(MouseEvent_1.MouseEvent.POINTER_MOVE, this.onDragMove);
        // For mouse-only events
        // .on('mousedown', onDragStart)
        // .on('mouseup', onDragEnd)
        // .on('mouseupoutside', onDragEnd)
        // .on('mousemove', onDragMove);
        // For touch-only events
        // .on('touchstart', onDragStart)
        // .on('touchend', onDragEnd)
        // .on('touchendoutside', onDragEnd)
        // .on('touchmove', onDragMove);
        bunny.x = x;
        bunny.y = y;
        this.stage.addChild(bunny);
    }
}
exports.InteractionDragging = InteractionDragging;
class ExtendedSprite extends Sprite_1.Sprite {
}


/***/ }),

/***/ "./js-compile/examples/InteractionIcon.js":
/*!************************************************!*\
  !*** ./js-compile/examples/InteractionIcon.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseExample_1 = __webpack_require__(/*! ./BaseExample */ "./js-compile/examples/BaseExample.js");
const Sprite_1 = __webpack_require__(/*! ../raw-pixi-ts/Sprite */ "./js-compile/raw-pixi-ts/Sprite.js");
const ResourceLoader_1 = __webpack_require__(/*! ../raw-pixi-ts/ResourceLoader */ "./js-compile/raw-pixi-ts/ResourceLoader.js");
const Texture_1 = __webpack_require__(/*! ../raw-pixi-ts/Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const URLRequest_1 = __webpack_require__(/*! ../raw-pixi-ts/URLRequest */ "./js-compile/raw-pixi-ts/URLRequest.js");
const Event_1 = __webpack_require__(/*! ../raw-pixi-ts/Event */ "./js-compile/raw-pixi-ts/Event.js");
const BaseTexture_1 = __webpack_require__(/*! ../raw-pixi-ts/BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const MouseEvent_1 = __webpack_require__(/*! ../raw-pixi-ts/MouseEvent */ "./js-compile/raw-pixi-ts/MouseEvent.js");
class InteractionIcon extends BaseExample_1.BaseExample {
    constructor(app, width, height) {
        super(app, width, height);
        this.handleButtonOverLoaded = (event) => {
            this.textureButtonOver = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            const buttons = [];
            const buttonPositions = [
                175, 75,
                655, 75,
                410, 325,
                150, 465,
                685, 445,
            ];
            for (let i = 0; i < 5; i++) {
                const button = new ExtendedSprite(this.textureButton);
                button.anchor.set(0.5);
                button.x = buttonPositions[i * 2];
                button.y = buttonPositions[i * 2 + 1];
                button.interactive = true;
                button.buttonMode = true;
                button.addEventListener(MouseEvent_1.MouseEvent.POINTER_DOWN, this.onButtonDown);
                button.addEventListener(MouseEvent_1.MouseEvent.POINTER_UP, this.onButtonUp);
                button.addEventListener(MouseEvent_1.MouseEvent.POINTER_UP_OUTSIDE, this.onButtonUp);
                button.addEventListener(MouseEvent_1.MouseEvent.POINTER_OVER, this.onButtonOver);
                button.addEventListener(MouseEvent_1.MouseEvent.POINTER_OUT, this.onButtonOut);
                // button.on('mousedown', onButtonDown)
                // button.on('mouseup', onButtonUp)
                // button.on('mouseupoutside', onButtonUp)
                // button.on('mouseover', onButtonOver)
                // button.on('mouseout', onButtonOut)
                // Use touch-only events
                // .on('touchstart', onButtonDown)
                // .on('touchend', onButtonUp)
                // .on('touchendoutside', onButtonUp)
                this.stage.addChild(button);
                buttons.push(button);
            }
            buttons[0].scale.set(1.2);
            buttons[2].rotation = Math.PI / 10;
            buttons[3].scale.set(0.8);
            buttons[4].scale.set(0.8, 1.2);
            buttons[4].rotation = Math.PI;
            this.exampleReady();
        };
        this.onButtonDown = (event) => {
            let button = event.currentTarget;
            button.isdown = true;
            button.texture = this.textureButtonDown;
            button.alpha = 1;
        };
        this.onButtonUp = (event) => {
            let button = event.currentTarget;
            button.isdown = false;
            if (button.isOver) {
                button.texture = this.textureButtonOver;
            }
            else {
                button.texture = this.textureButton;
            }
        };
        this.onButtonOver = (event) => {
            let button = event.currentTarget;
            button.isOver = true;
            if (button.isdown) {
                return;
            }
            button.texture = this.textureButtonOver;
            this.app.renderer.view.style.cursor = "url('examples/assets/bunny.png'), pointer";
        };
        this.onButtonOut = (event) => {
            let button = event.currentTarget;
            button.isOver = false;
            if (button.isdown) {
                return;
            }
            button.texture = this.textureButton;
            this.app.renderer.view.style.cursor = "url('examples/assets/bunny.png'), pointer";
        };
        this.handleButtonDownLoaded = (event) => {
            this.textureButtonDown = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/button_over.png"));
            this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleButtonOverLoaded);
            this.loader.load();
        };
        this.handleButtonLoaded = (event) => {
            this.textureButton = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/button_down.png"));
            this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleButtonDownLoaded);
            this.loader.load();
        };
        this.handleRotateLoaded = (event) => {
            let txt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            const background = new Sprite_1.Sprite(txt);
            background.width = this.sizew;
            background.height = this.sizeh;
            this.stage.addChild(background);
            this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/button.png"));
            this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleButtonLoaded);
            this.loader.load();
        };
        const defaultIcon = "url('examples/assets/bunny.png'),auto;";
        const hoverIcon = "url('examples/assets/bunny_saturated.png'),auto;";
        this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/bg_button.jpg"));
        this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleRotateLoaded);
        this.loader.load();
    }
    destructor() {
        super.destructor();
        this.textureButton.destroy(null);
        this.textureButton = null;
        this.textureButtonOver.destroy(null);
        this.textureButtonOver = null;
        this.textureButtonDown.destroy(null);
        this.textureButtonDown = null;
    }
}
exports.InteractionIcon = InteractionIcon;
class ExtendedSprite extends Sprite_1.Sprite {
}


/***/ }),

/***/ "./js-compile/examples/InteractionInteractivity.js":
/*!*********************************************************!*\
  !*** ./js-compile/examples/InteractionInteractivity.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseExample_1 = __webpack_require__(/*! ./BaseExample */ "./js-compile/examples/BaseExample.js");
const ResourceLoader_1 = __webpack_require__(/*! ../raw-pixi-ts/ResourceLoader */ "./js-compile/raw-pixi-ts/ResourceLoader.js");
const URLRequest_1 = __webpack_require__(/*! ../raw-pixi-ts/URLRequest */ "./js-compile/raw-pixi-ts/URLRequest.js");
const Event_1 = __webpack_require__(/*! ../raw-pixi-ts/Event */ "./js-compile/raw-pixi-ts/Event.js");
const Texture_1 = __webpack_require__(/*! ../raw-pixi-ts/Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const BaseTexture_1 = __webpack_require__(/*! ../raw-pixi-ts/BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const Sprite_1 = __webpack_require__(/*! ../raw-pixi-ts/Sprite */ "./js-compile/raw-pixi-ts/Sprite.js");
const MouseEvent_1 = __webpack_require__(/*! ../raw-pixi-ts/MouseEvent */ "./js-compile/raw-pixi-ts/MouseEvent.js");
class InteractionInteractivity extends BaseExample_1.BaseExample {
    constructor(app, width, height) {
        super(app, width, height);
        this.handleButtonOverLoaded = (event) => {
            this.textureButtonOver = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            const buttons = [];
            const buttonPositions = [
                175, 75,
                655, 75,
                410, 325,
                150, 465,
                685, 445,
            ];
            for (let i = 0; i < 5; i++) {
                const button = new ExtendedSprite(this.textureButton);
                button.buttonMode = true;
                button.anchor.set(0.5);
                button.x = buttonPositions[i * 2];
                button.y = buttonPositions[i * 2 + 1];
                button.interactive = true;
                button.buttonMode = true;
                button.addEventListener(MouseEvent_1.MouseEvent.POINTER_DOWN, this.onButtonDown);
                button.addEventListener(MouseEvent_1.MouseEvent.POINTER_UP, this.onButtonUp);
                button.addEventListener(MouseEvent_1.MouseEvent.POINTER_UP_OUTSIDE, this.onButtonUp);
                button.addEventListener(MouseEvent_1.MouseEvent.POINTER_OVER, this.onButtonOver);
                button.addEventListener(MouseEvent_1.MouseEvent.POINTER_OUT, this.onButtonOut);
                // button.on('mousedown', onButtonDown)
                // button.on('mouseup', onButtonUp)
                // button.on('mouseupoutside', onButtonUp)
                // button.on('mouseover', onButtonOver)
                // button.on('mouseout', onButtonOut)
                // Use touch-only events
                // .on('touchstart', onButtonDown)
                // .on('touchend', onButtonUp)
                // .on('touchendoutside', onButtonUp)
                this.stage.addChild(button);
                buttons.push(button);
            }
            buttons[0].scale.set(1.2);
            buttons[2].rotation = Math.PI / 10;
            buttons[3].scale.set(0.8);
            buttons[4].scale.set(0.8, 1.2);
            buttons[4].rotation = Math.PI;
            this.exampleReady();
        };
        this.onButtonDown = (event) => {
            let button = event.currentTarget;
            button.isdown = true;
            button.texture = this.textureButtonDown;
            button.alpha = 1;
        };
        this.onButtonUp = (event) => {
            let button = event.currentTarget;
            button.isdown = false;
            if (button.isOver) {
                button.texture = this.textureButtonOver;
            }
            else {
                button.texture = this.textureButton;
            }
        };
        this.onButtonOver = (event) => {
            let button = event.currentTarget;
            button.isOver = true;
            if (button.isdown) {
                return;
            }
            button.texture = this.textureButtonOver;
        };
        this.onButtonOut = (event) => {
            let button = event.currentTarget;
            button.isOver = false;
            if (button.isdown) {
                return;
            }
            button.texture = this.textureButton;
        };
        this.handleButtonDownLoaded = (event) => {
            this.textureButtonDown = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/button_over.png"));
            this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleButtonOverLoaded);
            this.loader.load();
        };
        this.handleButtonLoaded = (event) => {
            this.textureButton = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/button_down.png"));
            this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleButtonDownLoaded);
            this.loader.load();
        };
        this.handleRotateLoaded = (event) => {
            let txt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            const background = new Sprite_1.Sprite(txt);
            background.width = this.sizew;
            background.height = this.sizeh;
            this.stage.addChild(background);
            this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/button.png"));
            this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleButtonLoaded);
            this.loader.load();
        };
        this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/bg_button.jpg"));
        this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleRotateLoaded);
        this.loader.load();
    }
    destructor() {
        super.destructor();
        this.textureButton.destroy(null);
        this.textureButton = null;
        this.textureButtonOver.destroy(null);
        this.textureButtonOver = null;
        this.textureButtonDown.destroy(null);
        this.textureButtonDown = null;
    }
}
exports.InteractionInteractivity = InteractionInteractivity;
class ExtendedSprite extends Sprite_1.Sprite {
}


/***/ }),

/***/ "./js-compile/examples/MaskFilter.js":
/*!*******************************************!*\
  !*** ./js-compile/examples/MaskFilter.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseExample_1 = __webpack_require__(/*! ./BaseExample */ "./js-compile/examples/BaseExample.js");
const ResourceLoader_1 = __webpack_require__(/*! ../raw-pixi-ts/ResourceLoader */ "./js-compile/raw-pixi-ts/ResourceLoader.js");
const Texture_1 = __webpack_require__(/*! ../raw-pixi-ts/Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const URLRequest_1 = __webpack_require__(/*! ../raw-pixi-ts/URLRequest */ "./js-compile/raw-pixi-ts/URLRequest.js");
const Event_1 = __webpack_require__(/*! ../raw-pixi-ts/Event */ "./js-compile/raw-pixi-ts/Event.js");
const BaseTexture_1 = __webpack_require__(/*! ../raw-pixi-ts/BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const Graphics_1 = __webpack_require__(/*! ../raw-pixi-ts/Graphics */ "./js-compile/raw-pixi-ts/Graphics.js");
const BlurFilter_1 = __webpack_require__(/*! ../raw-pixi-ts/BlurFilter */ "./js-compile/raw-pixi-ts/BlurFilter.js");
const Rectangle_1 = __webpack_require__(/*! ../flash/geom/Rectangle */ "./js-compile/flash/geom/Rectangle.js");
const WebGLSettings_1 = __webpack_require__(/*! ../raw-pixi-ts/WebGLSettings */ "./js-compile/raw-pixi-ts/WebGLSettings.js");
const Sprite_1 = __webpack_require__(/*! ../raw-pixi-ts/Sprite */ "./js-compile/raw-pixi-ts/Sprite.js");
const MouseEvent_1 = __webpack_require__(/*! ../raw-pixi-ts/MouseEvent */ "./js-compile/raw-pixi-ts/MouseEvent.js");
class MaskFilter extends BaseExample_1.BaseExample {
    constructor(app, width, height) {
        super(app, width, height);
        this.handleRotateLoaded = (event) => {
            this.flagTxt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            const radius = 100;
            const blurSize = 32;
            const background = new Sprite_1.Sprite(this.flagTxt);
            this.stage.addChild(background);
            background.width = this.sizew;
            background.height = this.sizeh;
            const circle = new Graphics_1.Graphics()
                .beginFill(0xFF0000)
                .drawCircle(radius + blurSize, radius + blurSize, radius)
                .endFill();
            circle.filters = [new BlurFilter_1.BlurFilter(blurSize)];
            const bounds = Rectangle_1.Rectangle.getRectangle(0, 0, (radius + blurSize) * 2, (radius + blurSize) * 2);
            const texture = this.app.renderer.generateTexture(circle, WebGLSettings_1.WebGLSettings.SCALE_MODES.NEAREST, 1, bounds);
            this.focus = new Sprite_1.Sprite(texture);
            this.stage.addChild(this.focus);
            background.mask = this.focus;
            this.stage.interactive = true;
            this.stage.addEventListener(MouseEvent_1.MouseEvent.MOUSE_MOVE, this.pointerMove);
            this.exampleReady();
        };
        this.pointerMove = (event) => {
            this.focus.position.x = event.data.global.x - this.focus.width / 2;
            this.focus.position.y = event.data.global.y - this.focus.height / 2;
        };
        this.backColor = 0;
        this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/bg_grass.jpg"));
        this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleRotateLoaded);
        this.loader.load();
    }
    destructor() {
        super.destructor();
        this.flagTxt.destroy(null);
        this.flagTxt = null;
        this.focus.destroy(null);
        this.focus = null;
    }
}
exports.MaskFilter = MaskFilter;


/***/ }),

/***/ "./js-compile/examples/MaskGraphics.js":
/*!*********************************************!*\
  !*** ./js-compile/examples/MaskGraphics.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseExample_1 = __webpack_require__(/*! ./BaseExample */ "./js-compile/examples/BaseExample.js");
const ResourceLoader_1 = __webpack_require__(/*! ../raw-pixi-ts/ResourceLoader */ "./js-compile/raw-pixi-ts/ResourceLoader.js");
const URLRequest_1 = __webpack_require__(/*! ../raw-pixi-ts/URLRequest */ "./js-compile/raw-pixi-ts/URLRequest.js");
const Event_1 = __webpack_require__(/*! ../raw-pixi-ts/Event */ "./js-compile/raw-pixi-ts/Event.js");
const Texture_1 = __webpack_require__(/*! ../raw-pixi-ts/Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const BaseTexture_1 = __webpack_require__(/*! ../raw-pixi-ts/BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const Sprite_1 = __webpack_require__(/*! ../raw-pixi-ts/Sprite */ "./js-compile/raw-pixi-ts/Sprite.js");
const Container_1 = __webpack_require__(/*! ../raw-pixi-ts/Container */ "./js-compile/raw-pixi-ts/Container.js");
const Graphics_1 = __webpack_require__(/*! ../raw-pixi-ts/Graphics */ "./js-compile/raw-pixi-ts/Graphics.js");
const MouseEvent_1 = __webpack_require__(/*! ../raw-pixi-ts/MouseEvent */ "./js-compile/raw-pixi-ts/MouseEvent.js");
const Text_1 = __webpack_require__(/*! ../raw-pixi-ts/Text */ "./js-compile/raw-pixi-ts/Text.js");
class MaskGraphics extends BaseExample_1.BaseExample {
    constructor(app, width, height) {
        super(app, width, height);
        this.handlePandaLoaded = (event) => {
            this.pandaTxt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            this.bg = new Sprite_1.Sprite(this.rotateTxt);
            this.bg.anchor.set(0.5);
            this.bg.x = this.sizew / 2;
            this.bg.y = this.sizeh / 2;
            this.stage.addChild(this.bg);
            this.container = new Container_1.Container();
            this.container.x = this.sizew / 2;
            this.container.y = this.sizeh / 2;
            this.bgFront = new Sprite_1.Sprite(this.scenerotateTxt);
            this.bgFront.anchor.set(0.5);
            this.light2 = new Sprite_1.Sprite(this.lightrotate2Txt);
            this.light2.anchor.set(0.5);
            this.light1 = new Sprite_1.Sprite(this.lightrotate1Txt);
            this.light1.anchor.set(0.5);
            this.panda = new Sprite_1.Sprite(this.pandaTxt);
            this.panda.anchor.set(0.5);
            this.container.addChild(this.bgFront);
            this.container.addChild(this.light2);
            this.container.addChild(this.light1);
            this.container.addChild(this.panda);
            this.stage.addChild(this.container);
            this.thing = new Graphics_1.Graphics();
            this.stage.addChild(this.thing);
            this.thing.x = this.sizew / 2;
            this.thing.y = this.sizeh / 2;
            this.thing.lineStyle(0);
            this.container.mask = this.thing;
            this.count = 0;
            this.stage.addEventListener(MouseEvent_1.MouseEvent.POINTER_TAP, this.handleStageTap);
            const help = new Text_1.Text('Click or tap to turn masking on / off.', {
                fontFamily: 'Arial',
                fontSize: 12,
                fontWeight: 'bold',
                fill: 'white',
            });
            help.y = this.app.screen.height - 35;
            help.x = 15;
            this.stage.addChild(help);
            this.app.ticker.add(this.runExample);
            this.exampleReady();
        };
        this.runExample = (delta) => {
            this.bg.rotation += 0.01;
            this.bgFront.rotation -= 0.01;
            this.light1.rotation += 0.02;
            this.light2.rotation += 0.01;
            this.panda.scale.x = 1 + Math.sin(this.count) * 0.04;
            this.panda.scale.y = 1 + Math.cos(this.count) * 0.04;
            this.count += 0.1;
            this.thing.clear();
            this.thing.beginFill(0x8bc5ff, 0.4);
            this.thing.moveTo(-120 + Math.sin(this.count) * 20, -100 + Math.cos(this.count) * 20);
            this.thing.lineTo(120 + Math.cos(this.count) * 20, -100 + Math.sin(this.count) * 20);
            this.thing.lineTo(120 + Math.sin(this.count) * 20, 100 + Math.cos(this.count) * 20);
            this.thing.lineTo(-120 + Math.cos(this.count) * 20, 100 + Math.sin(this.count) * 20);
            this.thing.rotation = this.count * 0.1;
        };
        this.handleStageTap = (event) => {
            if (!this.container.mask) {
                this.container.mask = this.thing;
            }
            else {
                this.container.mask = null;
            }
        };
        this.handleLightRotate1Loaded = (event) => {
            this.lightrotate1Txt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/light_rotate_1.png"));
            this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleLightRotate1Loaded);
            this.loader.load();
        };
        this.handleRotateLoaded = (event) => {
            this.rotateTxt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/bg_scene_rotate.jpg"));
            this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleSceneRotateLoaded);
            this.loader.load();
        };
        this.handleSceneRotateLoaded = (event) => {
            this.scenerotateTxt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/light_rotate_2.png"));
            this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleLightRotate2Loaded);
            this.loader.load();
        };
        this.handleLightRotate2Loaded = (event) => {
            this.lightrotate2Txt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/panda.png"));
            this.loader.addEventListener(Event_1.Event.COMPLETE, this.handlePandaLoaded);
            this.loader.load();
        };
        this.backColor = 0;
        this.activateMask();
        app.stage.interactive = true;
        this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/bg_rotate.jpg"));
        this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleRotateLoaded);
        this.loader.load();
    }
    destructor() {
        super.destructor();
        this.app.ticker.remove(this.runExample, null);
        this.panda.destroy(null);
        this.panda = null;
        this.rotateTxt.destroy(null);
        this.rotateTxt = null;
        this.scenerotateTxt.destroy(null);
        this.scenerotateTxt = null;
        this.lightrotate2Txt.destroy(null);
        this.lightrotate2Txt = null;
        this.lightrotate1Txt.destroy(null);
        this.lightrotate1Txt = null;
        this.pandaTxt.destroy(null);
        this.pandaTxt = null;
        this.container.destroy(null);
        this.container = null;
        this.thing.destroy(null);
        this.thing = null;
        this.bg.destroy(null);
        this.bg = null;
        this.bgFront.destroy(null);
        this.bgFront = null;
        this.light2.destroy(null);
        this.light2 = null;
        this.light1.destroy(null);
        this.light1 = null;
    }
}
exports.MaskGraphics = MaskGraphics;


/***/ }),

/***/ "./js-compile/examples/MaskSprite.js":
/*!*******************************************!*\
  !*** ./js-compile/examples/MaskSprite.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseExample_1 = __webpack_require__(/*! ./BaseExample */ "./js-compile/examples/BaseExample.js");
const ResourceLoader_1 = __webpack_require__(/*! ../raw-pixi-ts/ResourceLoader */ "./js-compile/raw-pixi-ts/ResourceLoader.js");
const URLRequest_1 = __webpack_require__(/*! ../raw-pixi-ts/URLRequest */ "./js-compile/raw-pixi-ts/URLRequest.js");
const Event_1 = __webpack_require__(/*! ../raw-pixi-ts/Event */ "./js-compile/raw-pixi-ts/Event.js");
const Texture_1 = __webpack_require__(/*! ../raw-pixi-ts/Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const BaseTexture_1 = __webpack_require__(/*! ../raw-pixi-ts/BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const Sprite_1 = __webpack_require__(/*! ../raw-pixi-ts/Sprite */ "./js-compile/raw-pixi-ts/Sprite.js");
const Point_1 = __webpack_require__(/*! ../flash/geom/Point */ "./js-compile/flash/geom/Point.js");
class MaskSprite extends BaseExample_1.BaseExample {
    constructor(app, width, height) {
        super(app, width, height);
        this.handleFlowerLoaded = (event) => {
            this.flowerTxt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            this.app.stage.interactive = true;
            const bg = new Sprite_1.Sprite(this.planeTxt);
            bg.width = this.sizew;
            bg.height = this.sizeh;
            this.stage.addChild(bg);
            const cells = new Sprite_1.Sprite(this.cellTxt);
            cells.scale.set(1.5);
            this.mask = new Sprite_1.Sprite(this.flowerTxt);
            this.mask.anchor.set(0.5);
            this.mask.x = 310;
            this.mask.y = 190;
            cells.mask = this.mask;
            this.stage.addChild(this.mask);
            this.stage.addChild(cells);
            this.target = Point_1.Point.getPoint();
            this.reset();
            this.app.ticker.add(this.runExample);
            this.exampleReady();
        };
        this.runExample = (delta) => {
            this.mask.x += (this.target.x - this.mask.x) * 0.1;
            this.mask.y += (this.target.y - this.mask.y) * 0.1;
            if (Math.abs(this.mask.x - this.target.x) < 1) {
                this.reset();
            }
        };
        this.handleCellLoaded = (event) => {
            this.cellTxt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/flowerTop.png"));
            this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleFlowerLoaded);
            this.loader.load();
        };
        this.handlePlaneLoaded = (event) => {
            this.planeTxt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/cells.png"));
            this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleCellLoaded);
            this.loader.load();
        };
        this.activateMask();
        this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/bg_plane.jpg"));
        this.loader.addEventListener(Event_1.Event.COMPLETE, this.handlePlaneLoaded);
        this.loader.load();
    }
    reset() {
        this.target.x = Math.floor(Math.random() * 550);
        this.target.y = Math.floor(Math.random() * 300);
    }
    destructor() {
        super.destructor();
        this.app.ticker.remove(this.runExample, null);
        this.mask.destroy(null);
        this.mask = null;
        this.planeTxt.destroy(null);
        this.planeTxt = null;
        this.cellTxt.destroy(null);
        this.cellTxt = null;
        this.flowerTxt.destroy(null);
        this.flowerTxt = null;
        if (this.target) {
            this.target.recycle();
        }
        this.target = null;
    }
}
exports.MaskSprite = MaskSprite;


/***/ }),

/***/ "./js-compile/examples/MeshAdvanced.js":
/*!*********************************************!*\
  !*** ./js-compile/examples/MeshAdvanced.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseExample_1 = __webpack_require__(/*! ./BaseExample */ "./js-compile/examples/BaseExample.js");
const Texture_1 = __webpack_require__(/*! ../raw-pixi-ts/Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const BaseTexture_1 = __webpack_require__(/*! ../raw-pixi-ts/BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const Event_1 = __webpack_require__(/*! ../raw-pixi-ts/Event */ "./js-compile/raw-pixi-ts/Event.js");
const ResourceLoader_1 = __webpack_require__(/*! ../raw-pixi-ts/ResourceLoader */ "./js-compile/raw-pixi-ts/ResourceLoader.js");
const URLRequest_1 = __webpack_require__(/*! ../raw-pixi-ts/URLRequest */ "./js-compile/raw-pixi-ts/URLRequest.js");
const Point_1 = __webpack_require__(/*! ../flash/geom/Point */ "./js-compile/flash/geom/Point.js");
const SimpleRope_1 = __webpack_require__(/*! ../raw-pixi-ts/SimpleRope */ "./js-compile/raw-pixi-ts/SimpleRope.js");
const Graphics_1 = __webpack_require__(/*! ../raw-pixi-ts/Graphics */ "./js-compile/raw-pixi-ts/Graphics.js");
class MeshAdvanced extends BaseExample_1.BaseExample {
    constructor(app, width, height) {
        super(app, width, height);
        this.runExample = (delta) => {
            this.count += 0.1;
            for (let i = 0; i < this.points.length; i++) {
                this.points[i].y = Math.sin((i * 0.5) + this.count) * 30;
                this.points[i].x = i * this.ropeLength + Math.cos((i * 0.3) + this.count) * 20;
            }
            this.renderPoints();
        };
        this.handlePlaneLoaded = (event) => {
            this.planeTxt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            this.count = 0;
            this.ropeLength = 30;
            this.points = [];
            for (let i = 0; i < 25; i++) {
                this.points.push(Point_1.Point.getPoint(i * this.ropeLength, 0));
            }
            const strip = new SimpleRope_1.SimpleRope(this.planeTxt, this.points);
            strip.x = 20;
            strip.y = 300;
            this.stage.addChild(strip);
            this.g = new Graphics_1.Graphics();
            this.g.x = strip.x;
            this.g.y = strip.y;
            this.stage.addChild(this.g);
            this.app.ticker.add(this.runExample);
            this.exampleReady();
        };
        this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/snake.png"));
        this.loader.addEventListener(Event_1.Event.COMPLETE, this.handlePlaneLoaded);
        this.loader.load();
    }
    renderPoints() {
        this.g.clear();
        this.g.lineStyle(2, 0xffc2c2);
        this.g.moveTo(this.points[0].x, this.points[0].y);
        for (let i = 1; i < this.points.length; i++) {
            this.g.lineTo(this.points[i].x, this.points[i].y);
        }
        for (let i = 1; i < this.points.length; i++) {
            this.g.beginFill(0xff0022);
            this.g.drawCircle(this.points[i].x, this.points[i].y, 10);
            this.g.endFill();
        }
    }
    destructor() {
        super.destructor();
        this.app.ticker.remove(this.runExample, null);
        this.planeTxt.destroy(null);
        this.planeTxt = null;
        this.g.destroy(null);
        this.g = null;
        if (this.points && this.points.length) {
            while (this.points.length) {
                let point = this.points.shift();
                point.recycle();
            }
        }
        this.points = null;
    }
}
exports.MeshAdvanced = MeshAdvanced;


/***/ }),

/***/ "./js-compile/examples/MeshBasic.js":
/*!******************************************!*\
  !*** ./js-compile/examples/MeshBasic.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseExample_1 = __webpack_require__(/*! ./BaseExample */ "./js-compile/examples/BaseExample.js");
const ResourceLoader_1 = __webpack_require__(/*! ../raw-pixi-ts/ResourceLoader */ "./js-compile/raw-pixi-ts/ResourceLoader.js");
const Texture_1 = __webpack_require__(/*! ../raw-pixi-ts/Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const URLRequest_1 = __webpack_require__(/*! ../raw-pixi-ts/URLRequest */ "./js-compile/raw-pixi-ts/URLRequest.js");
const Event_1 = __webpack_require__(/*! ../raw-pixi-ts/Event */ "./js-compile/raw-pixi-ts/Event.js");
const BaseTexture_1 = __webpack_require__(/*! ../raw-pixi-ts/BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const Point_1 = __webpack_require__(/*! ../flash/geom/Point */ "./js-compile/flash/geom/Point.js");
const SimpleRope_1 = __webpack_require__(/*! ../raw-pixi-ts/SimpleRope */ "./js-compile/raw-pixi-ts/SimpleRope.js");
const Container_1 = __webpack_require__(/*! ../raw-pixi-ts/Container */ "./js-compile/raw-pixi-ts/Container.js");
class MeshBasic extends BaseExample_1.BaseExample {
    constructor(app, width, height) {
        super(app, width, height);
        this.runExample = (delta) => {
            this.count += 0.1;
            for (let i = 0; i < this.points.length; i++) {
                this.points[i].y = Math.sin((i * 0.5) + this.count) * 30;
                this.points[i].x = i * this.ropeLength + Math.cos((i * 0.3) + this.count) * 20;
            }
        };
        this.handlePlaneLoaded = (event) => {
            this.planeTxt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            this.count = 0;
            this.ropeLength = 918 / 20;
            this.points = [];
            for (let i = 0; i < 20; i++) {
                this.points.push(Point_1.Point.getPoint(i * this.ropeLength, 0));
            }
            const strip = new SimpleRope_1.SimpleRope(this.planeTxt, this.points);
            strip.x = -459;
            const snakeContainer = new Container_1.Container();
            snakeContainer.x = 400;
            snakeContainer.y = 300;
            snakeContainer.scale.set(800 / 1100);
            this.stage.addChild(snakeContainer);
            snakeContainer.addChild(strip);
            this.app.ticker.add(this.runExample);
            this.exampleReady();
        };
        this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/snake.png"));
        this.loader.addEventListener(Event_1.Event.COMPLETE, this.handlePlaneLoaded);
        this.loader.load();
    }
    destructor() {
        super.destructor();
        this.app.ticker.remove(this.runExample, null);
        this.planeTxt.destroy(null);
        this.planeTxt = null;
        if (this.points && this.points.length) {
            while (this.points.length) {
                let point = this.points.shift();
                point.recycle();
            }
        }
        this.points = null;
    }
}
exports.MeshBasic = MeshBasic;


/***/ }),

/***/ "./js-compile/examples/MeshColoredTriangle.js":
/*!****************************************************!*\
  !*** ./js-compile/examples/MeshColoredTriangle.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseExample_1 = __webpack_require__(/*! ./BaseExample */ "./js-compile/examples/BaseExample.js");
const Geometry_1 = __webpack_require__(/*! ../raw-pixi-ts/Geometry */ "./js-compile/raw-pixi-ts/Geometry.js");
const Program_1 = __webpack_require__(/*! ../raw-pixi-ts/Program */ "./js-compile/raw-pixi-ts/Program.js");
const Shader_1 = __webpack_require__(/*! ../raw-pixi-ts/Shader */ "./js-compile/raw-pixi-ts/Shader.js");
const Mesh_1 = __webpack_require__(/*! ../raw-pixi-ts/Mesh */ "./js-compile/raw-pixi-ts/Mesh.js");
class MeshColoredTriangle extends BaseExample_1.BaseExample {
    constructor(app, width, height) {
        super(app, width, height);
        this.runExample = (delta) => {
            this.triangle.rotation += 0.01;
        };
        const geometry = new Geometry_1.Geometry();
        geometry.addAttribute('aVertexPosition', // the attribute name
        [-100, -50,
            100, -50,
            0.0, 100.0], // x, y
        2); // the size of the attribute
        geometry.addAttribute('aColor', // the attribute name
        [1, 0, 0,
            0, 1, 0,
            0, 0, 1], // r, g, b
        3); // the size of the attribute
        let vx = `
            precision mediump float;
            attribute vec2 aVertexPosition;
            attribute vec3 aColor;    
            uniform mat3 translationMatrix;
            uniform mat3 projectionMatrix;    
            varying vec3 vColor;    
            void main() {    
                vColor = aColor;
                gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);    
            }`;
        let fx = `precision mediump float;
            varying vec3 vColor;    
            void main() {
                gl_FragColor = vec4(vColor, 1.0);
            }    
            `;
        let program = new Program_1.Program(vx, fx);
        const shader = new Shader_1.Shader(program, null);
        this.triangle = new Mesh_1.Mesh(geometry, shader);
        this.triangle.position.set(400, 300);
        this.triangle.scale.set(2);
        this.stage.addChild(this.triangle);
        this.app.ticker.add(this.runExample);
        setTimeout(() => {
            this.exampleReady();
        }, 1000);
    }
    destructor() {
        super.destructor();
        this.app.ticker.remove(this.runExample, null);
        this.triangle.destroy(null);
        this.triangle = null;
    }
}
exports.MeshColoredTriangle = MeshColoredTriangle;


/***/ }),

/***/ "./js-compile/examples/MeshGeometry.js":
/*!*********************************************!*\
  !*** ./js-compile/examples/MeshGeometry.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseExample_1 = __webpack_require__(/*! ./BaseExample */ "./js-compile/examples/BaseExample.js");
const ResourceLoader_1 = __webpack_require__(/*! ../raw-pixi-ts/ResourceLoader */ "./js-compile/raw-pixi-ts/ResourceLoader.js");
const Texture_1 = __webpack_require__(/*! ../raw-pixi-ts/Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const URLRequest_1 = __webpack_require__(/*! ../raw-pixi-ts/URLRequest */ "./js-compile/raw-pixi-ts/URLRequest.js");
const Event_1 = __webpack_require__(/*! ../raw-pixi-ts/Event */ "./js-compile/raw-pixi-ts/Event.js");
const BaseTexture_1 = __webpack_require__(/*! ../raw-pixi-ts/BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const Geometry_1 = __webpack_require__(/*! ../raw-pixi-ts/Geometry */ "./js-compile/raw-pixi-ts/Geometry.js");
const Program_1 = __webpack_require__(/*! ../raw-pixi-ts/Program */ "./js-compile/raw-pixi-ts/Program.js");
const Mesh_1 = __webpack_require__(/*! ../raw-pixi-ts/Mesh */ "./js-compile/raw-pixi-ts/Mesh.js");
const Shader_1 = __webpack_require__(/*! ../raw-pixi-ts/Shader */ "./js-compile/raw-pixi-ts/Shader.js");
class MeshGeometry extends BaseExample_1.BaseExample {
    constructor(app, width, height) {
        super(app, width, height);
        this.handleTxt3Loaded = (event) => {
            this.txt3 = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            const geometry = new Geometry_1.Geometry();
            geometry.addAttribute('aVertexPosition', // the attribute name
            [-100, -100,
                100, -100,
                100, 100], // x, y
            2); // the size of the attribute    
            geometry.addAttribute('aUvs', // the attribute name
            [0, 0,
                1, 0,
                1, 1], // u, v
            2); // the size of the attribute    
            const program = Program_1.Program.from(`    
            precision mediump float;    
            attribute vec2 aVertexPosition;
            attribute vec2 aUvs;    
            uniform mat3 translationMatrix;
            uniform mat3 projectionMatrix;    
            varying vec2 vUvs;    
            void main() {    
                vUvs = aUvs;
                gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);    
            }`, `precision mediump float;    
            varying vec2 vUvs;    
            uniform sampler2D uSamplerTexture;    
            void main() {    
                gl_FragColor = texture2D(uSamplerTexture, vUvs);
            }    
        `);
            this.triangle = new Mesh_1.Mesh(geometry, new Shader_1.Shader(program, {
                uSamplerTexture: this.txt1,
            }));
            this.triangle2 = new Mesh_1.Mesh(geometry, new Shader_1.Shader(program, {
                uSamplerTexture: this.txt2,
            }));
            this.triangle3 = new Mesh_1.Mesh(geometry, new Shader_1.Shader(program, {
                uSamplerTexture: this.txt3,
            }));
            this.triangle.position.set(400, 300);
            this.triangle.scale.set(2);
            this.triangle2.position.set(200, 100);
            this.triangle3.position.set(500, 400);
            this.triangle3.scale.set(3);
            this.stage.addChild(this.triangle3);
            this.stage.addChild(this.triangle2);
            this.stage.addChild(this.triangle);
            this.app.ticker.add(this.runExample);
            this.exampleReady();
        };
        this.runExample = (delta) => {
            this.triangle.rotation += 0.01;
            this.triangle2.rotation -= 0.01;
            this.triangle3.rotation -= 0.005;
        };
        this.handleTxt2Loaded = (event) => {
            this.txt2 = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/bg_displacement.jpg"));
            this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleTxt3Loaded);
            this.loader.load();
        };
        this.handleTxt1Loaded = (event) => {
            this.txt1 = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/bg_rotate.jpg"));
            this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleTxt2Loaded);
            this.loader.load();
        };
        this.activateMask();
        this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/bg_scene_rotate.jpg"));
        this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleTxt1Loaded);
        this.loader.load();
    }
    destructor() {
        super.destructor();
        this.app.ticker.remove(this.runExample, null);
        this.txt1.destroy(null);
        this.txt1 = null;
        this.triangle3.destroy(null);
        this.triangle3 = null;
        this.triangle2.destroy(null);
        this.triangle2 = null;
        this.triangle.destroy(null);
        this.triangle = null;
        this.txt3.destroy(null);
        this.txt3 = null;
        this.txt2.destroy(null);
        this.txt2 = null;
    }
}
exports.MeshGeometry = MeshGeometry;


/***/ }),

/***/ "./js-compile/examples/MeshShader.js":
/*!*******************************************!*\
  !*** ./js-compile/examples/MeshShader.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseExample_1 = __webpack_require__(/*! ./BaseExample */ "./js-compile/examples/BaseExample.js");
const ResourceLoader_1 = __webpack_require__(/*! ../raw-pixi-ts/ResourceLoader */ "./js-compile/raw-pixi-ts/ResourceLoader.js");
const Texture_1 = __webpack_require__(/*! ../raw-pixi-ts/Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const URLRequest_1 = __webpack_require__(/*! ../raw-pixi-ts/URLRequest */ "./js-compile/raw-pixi-ts/URLRequest.js");
const Event_1 = __webpack_require__(/*! ../raw-pixi-ts/Event */ "./js-compile/raw-pixi-ts/Event.js");
const BaseTexture_1 = __webpack_require__(/*! ../raw-pixi-ts/BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const Geometry_1 = __webpack_require__(/*! ../raw-pixi-ts/Geometry */ "./js-compile/raw-pixi-ts/Geometry.js");
const Program_1 = __webpack_require__(/*! ../raw-pixi-ts/Program */ "./js-compile/raw-pixi-ts/Program.js");
const Shader_1 = __webpack_require__(/*! ../raw-pixi-ts/Shader */ "./js-compile/raw-pixi-ts/Shader.js");
const Mesh_1 = __webpack_require__(/*! ../raw-pixi-ts/Mesh */ "./js-compile/raw-pixi-ts/Mesh.js");
class MeshShader extends BaseExample_1.BaseExample {
    constructor(app, width, height) {
        super(app, width, height);
        this.handleTxt1Loaded = (event) => {
            this.txt1 = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            const geometry = new Geometry_1.Geometry();
            geometry.addAttribute('aVertexPosition', // the attribute name
            [-100, -100,
                100, -100,
                100, 100]); // x, y
            geometry.addAttribute('aUvs', // the attribute name
            [0, 0,
                1, 0,
                1, 1]); // u, v
            let vx = `
            precision mediump float;
            attribute vec2 aVertexPosition;
            attribute vec2 aUvs;
            uniform mat3 translationMatrix;
            uniform mat3 projectionMatrix;
            varying vec2 vUvs;
            void main() {
                vUvs = aUvs;
                gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);
            }`;
            let fx = `precision mediump float;
            varying vec2 vUvs;
            uniform sampler2D uSampler2;
            void main() {
                gl_FragColor = texture2D(uSampler2, vUvs);
            }        
            `;
            let program = new Program_1.Program(vx, fx);
            const shader = new Shader_1.Shader(program, { uSampler2: this.txt1 });
            let vx2 = `
            precision mediump float;    
            attribute vec2 aVertexPosition;
            attribute vec2 aUvs;    
            uniform mat3 translationMatrix;
            uniform mat3 projectionMatrix;    
            varying vec2 vUvs;    
            void main() {    
                vUvs = aUvs;
                gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);    
            }`;
            let fx2 = `precision mediump float;
            varying vec2 vUvs;    
            uniform sampler2D uSampler2;    
            void main() {    
                gl_FragColor = texture2D(uSampler2, vUvs);
                gl_FragColor.r += (abs(sin(gl_FragCoord.x * 0.06)) * 0.5) * 2.;
                gl_FragColor.g += (abs(cos(gl_FragCoord.y * 0.06)) * 0.5) * 2.;
            }    
            `;
            let program2 = new Program_1.Program(vx2, fx2);
            const shader2 = new Shader_1.Shader(program2, { uSampler2: this.txt1 });
            this.triangle = new Mesh_1.Mesh(geometry, shader);
            this.triangle2 = new Mesh_1.Mesh(geometry, shader2);
            this.triangle.position.set(400, 300);
            this.triangle.scale.set(2);
            this.triangle2.position.set(500, 400);
            this.triangle2.scale.set(3);
            this.stage.addChild(this.triangle2);
            this.stage.addChild(this.triangle);
            this.app.ticker.add(this.runExample);
            this.exampleReady();
        };
        this.runExample = (delta) => {
            this.triangle.rotation += 0.01;
            this.triangle2.rotation -= 0.005;
        };
        this.activateMask();
        this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/bg_scene_rotate.jpg"));
        this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleTxt1Loaded);
        this.loader.load();
    }
    destructor() {
        super.destructor();
        this.app.ticker.remove(this.runExample, null);
        this.txt1.destroy(null);
        this.txt1 = null;
        this.triangle.destroy(null);
        this.triangle = null;
        this.triangle2.destroy(null);
        this.triangle2 = null;
    }
}
exports.MeshShader = MeshShader;


/***/ }),

/***/ "./js-compile/examples/MeshTextured.js":
/*!*********************************************!*\
  !*** ./js-compile/examples/MeshTextured.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseExample_1 = __webpack_require__(/*! ./BaseExample */ "./js-compile/examples/BaseExample.js");
const ResourceLoader_1 = __webpack_require__(/*! ../raw-pixi-ts/ResourceLoader */ "./js-compile/raw-pixi-ts/ResourceLoader.js");
const Texture_1 = __webpack_require__(/*! ../raw-pixi-ts/Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const URLRequest_1 = __webpack_require__(/*! ../raw-pixi-ts/URLRequest */ "./js-compile/raw-pixi-ts/URLRequest.js");
const Event_1 = __webpack_require__(/*! ../raw-pixi-ts/Event */ "./js-compile/raw-pixi-ts/Event.js");
const BaseTexture_1 = __webpack_require__(/*! ../raw-pixi-ts/BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const Geometry_1 = __webpack_require__(/*! ../raw-pixi-ts/Geometry */ "./js-compile/raw-pixi-ts/Geometry.js");
const Program_1 = __webpack_require__(/*! ../raw-pixi-ts/Program */ "./js-compile/raw-pixi-ts/Program.js");
const Shader_1 = __webpack_require__(/*! ../raw-pixi-ts/Shader */ "./js-compile/raw-pixi-ts/Shader.js");
const Mesh_1 = __webpack_require__(/*! ../raw-pixi-ts/Mesh */ "./js-compile/raw-pixi-ts/Mesh.js");
class MeshTextured extends BaseExample_1.BaseExample {
    constructor(app, width, height) {
        super(app, width, height);
        this.handlePlaneLoaded = (event) => {
            this.planeTxt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            const geometry = new Geometry_1.Geometry();
            geometry.addAttribute('aVertexPosition', // the attribute name
            [-100, -100,
                100, -100,
                100, 100], // x, y
            2); // the size of the attribute
            geometry.addAttribute('aColor', // the attribute name
            [1, 0, 0,
                0, 1, 0,
                0, 0, 1], // r, g, b
            3); // the size of the attribute
            geometry.addAttribute('aUvs', // the attribute name
            [0, 0,
                1, 0,
                1, 1], // u, v
            2); // the size of the attribute
            const vertexSrc = `
            precision mediump float;
            attribute vec2 aVertexPosition;
            attribute vec3 aColor;
            attribute vec2 aUvs;
            uniform mat3 translationMatrix;
            uniform mat3 projectionMatrix;
            varying vec2 vUvs;
            varying vec3 vColor;
            void main() {
                vUvs = aUvs;
                vColor = aColor;
                gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);
            }`;
            const fragmentSrc = `
            precision mediump float;
            varying vec3 vColor;
            varying vec2 vUvs;
            uniform sampler2D uSampler2;
            void main() {
                gl_FragColor = texture2D(uSampler2, vUvs) * vec4(vColor, 1.0);
            }`;
            const uniforms = { uSampler2: this.planeTxt };
            let program = new Program_1.Program(vertexSrc, fragmentSrc);
            const shader = new Shader_1.Shader(program, uniforms);
            this.triangle = new Mesh_1.Mesh(geometry, shader);
            this.triangle.position.set(400, 300);
            this.triangle.scale.set(2);
            this.stage.addChild(this.triangle);
            this.app.ticker.add(this.runExample);
            this.exampleReady();
        };
        this.runExample = (delta) => {
            this.triangle.rotation += 0.01;
        };
        this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/bg_scene_rotate.jpg"));
        this.loader.addEventListener(Event_1.Event.COMPLETE, this.handlePlaneLoaded);
        this.loader.load();
    }
    destructor() {
        super.destructor();
        this.app.ticker.remove(this.runExample, null);
        this.triangle.destroy(null);
        this.triangle = null;
        this.planeTxt.destroy(null);
        this.planeTxt = null;
    }
}
exports.MeshTextured = MeshTextured;


/***/ }),

/***/ "./js-compile/examples/MeshTriangle.js":
/*!*********************************************!*\
  !*** ./js-compile/examples/MeshTriangle.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseExample_1 = __webpack_require__(/*! ./BaseExample */ "./js-compile/examples/BaseExample.js");
const Geometry_1 = __webpack_require__(/*! ../raw-pixi-ts/Geometry */ "./js-compile/raw-pixi-ts/Geometry.js");
const Shader_1 = __webpack_require__(/*! ../raw-pixi-ts/Shader */ "./js-compile/raw-pixi-ts/Shader.js");
const Program_1 = __webpack_require__(/*! ../raw-pixi-ts/Program */ "./js-compile/raw-pixi-ts/Program.js");
const Mesh_1 = __webpack_require__(/*! ../raw-pixi-ts/Mesh */ "./js-compile/raw-pixi-ts/Mesh.js");
class MeshTriangle extends BaseExample_1.BaseExample {
    constructor(app, width, height) {
        super(app, width, height);
        this.runExample = (delta) => {
            this.triangle.rotation += 0.01;
        };
        const geometry = new Geometry_1.Geometry();
        geometry.addAttribute('aVertexPosition', [-100, -50, 100, -50, 0, 100]);
        let vx = `
            precision mediump float;
            attribute vec2 aVertexPosition;
            uniform mat3 translationMatrix;
            uniform mat3 projectionMatrix;
            void main() {
                gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);
            }`;
        let fx = `precision mediump float;
            void main() {
                gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
            }
        `;
        let program = new Program_1.Program(vx, fx);
        const shader = new Shader_1.Shader(program, null);
        this.triangle = new Mesh_1.Mesh(geometry, shader);
        this.triangle.position.set(400, 300);
        this.stage.addChild(this.triangle);
        this.app.ticker.add(this.runExample);
        setTimeout(() => {
            this.exampleReady();
        }, 1000);
    }
    destructor() {
        super.destructor();
        this.app.ticker.remove(this.runExample, null);
        this.triangle.destroy(null);
        this.triangle = null;
    }
}
exports.MeshTriangle = MeshTriangle;


/***/ }),

/***/ "./js-compile/examples/MeshUniforms.js":
/*!*********************************************!*\
  !*** ./js-compile/examples/MeshUniforms.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseExample_1 = __webpack_require__(/*! ./BaseExample */ "./js-compile/examples/BaseExample.js");
const Mesh_1 = __webpack_require__(/*! ../raw-pixi-ts/Mesh */ "./js-compile/raw-pixi-ts/Mesh.js");
const ResourceLoader_1 = __webpack_require__(/*! ../raw-pixi-ts/ResourceLoader */ "./js-compile/raw-pixi-ts/ResourceLoader.js");
const Texture_1 = __webpack_require__(/*! ../raw-pixi-ts/Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const URLRequest_1 = __webpack_require__(/*! ../raw-pixi-ts/URLRequest */ "./js-compile/raw-pixi-ts/URLRequest.js");
const Event_1 = __webpack_require__(/*! ../raw-pixi-ts/Event */ "./js-compile/raw-pixi-ts/Event.js");
const BaseTexture_1 = __webpack_require__(/*! ../raw-pixi-ts/BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const Geometry_1 = __webpack_require__(/*! ../raw-pixi-ts/Geometry */ "./js-compile/raw-pixi-ts/Geometry.js");
const Program_1 = __webpack_require__(/*! ../raw-pixi-ts/Program */ "./js-compile/raw-pixi-ts/Program.js");
const Shader_1 = __webpack_require__(/*! ../raw-pixi-ts/Shader */ "./js-compile/raw-pixi-ts/Shader.js");
class MeshUniforms extends BaseExample_1.BaseExample {
    constructor(app, width, height) {
        super(app, width, height);
        this.handlePlaneLoaded = (event) => {
            this.planeTxt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            const geometry = new Geometry_1.Geometry();
            geometry.addAttribute('aVertexPosition', // the attribute name
            [-100, -100,
                100, -100,
                100, 100,
                -100, 100], // x, y
            2); // the size of the attribute
            geometry.addAttribute('aUvs', // the attribute name
            [0, 0,
                1, 0,
                1, 1,
                0, 1], // u, v
            2); // the size of the attribute
            geometry.addIndex([0, 1, 2, 0, 2, 3]);
            const vertexSrc = `
            precision mediump float;    
            attribute vec2 aVertexPosition;
            attribute vec2 aUvs;    
            uniform mat3 translationMatrix;
            uniform mat3 projectionMatrix;    
            varying vec2 vUvs;    
            void main() {    
                vUvs = aUvs;
                gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);    
            }`;
            const fragmentSrc = `    
            precision mediump float;    
            varying vec2 vUvs;    
            uniform sampler2D uSampler2;
            uniform float time;    
            void main() {    
                gl_FragColor = texture2D(uSampler2, vUvs + sin( (time + (vUvs.x) * 14.) ) * 0.1 );
            }`;
            const uniforms = {
                uSampler2: this.planeTxt,
                time: 0,
            };
            let program = new Program_1.Program(vertexSrc, fragmentSrc);
            const shader = new Shader_1.Shader(program, uniforms);
            this.triangle = new Mesh_1.Mesh(geometry, shader);
            this.triangle.position.set(400, 300);
            this.triangle.scale.set(2);
            this.stage.addChild(this.triangle);
            this.app.ticker.add(this.runExample);
            this.exampleReady();
        };
        this.runExample = (delta) => {
            this.triangle.rotation += 0.01;
            this.triangle.shader.uniforms.time += 0.1;
        };
        this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/bg_scene_rotate.jpg"));
        this.loader.addEventListener(Event_1.Event.COMPLETE, this.handlePlaneLoaded);
        this.loader.load();
    }
    destructor() {
        super.destructor();
        this.app.ticker.remove(this.runExample, null);
        this.planeTxt.destroy(null);
        this.planeTxt = null;
        this.triangle.destroy(null);
        this.triangle = null;
    }
}
exports.MeshUniforms = MeshUniforms;


/***/ }),

/***/ "./js-compile/examples/SpriteBasic.js":
/*!********************************************!*\
  !*** ./js-compile/examples/SpriteBasic.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseExample_1 = __webpack_require__(/*! ./BaseExample */ "./js-compile/examples/BaseExample.js");
const ResourceLoader_1 = __webpack_require__(/*! ../raw-pixi-ts/ResourceLoader */ "./js-compile/raw-pixi-ts/ResourceLoader.js");
const URLRequest_1 = __webpack_require__(/*! ../raw-pixi-ts/URLRequest */ "./js-compile/raw-pixi-ts/URLRequest.js");
const Event_1 = __webpack_require__(/*! ../raw-pixi-ts/Event */ "./js-compile/raw-pixi-ts/Event.js");
const Texture_1 = __webpack_require__(/*! ../raw-pixi-ts/Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const BaseTexture_1 = __webpack_require__(/*! ../raw-pixi-ts/BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const Sprite_1 = __webpack_require__(/*! ../raw-pixi-ts/Sprite */ "./js-compile/raw-pixi-ts/Sprite.js");
class SpriteBasic extends BaseExample_1.BaseExample {
    constructor(app, width = 100, height = 100) {
        super(app, width, height);
        this.handleRotateLoaded = (event) => {
            let texture = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            this.bunny = new Sprite_1.Sprite(texture);
            this.bunny.anchor.set(0.5);
            this.bunny.x = this.sizew / 2;
            this.bunny.y = this.sizeh / 2;
            this.stage.addChild(this.bunny);
            this.app.ticker.add(this.runExample);
            this.exampleReady();
        };
        this.runExample = (delta) => {
            this.bunny.rotation += 0.1 * delta;
        };
        this.backColor = 0xFFF000;
        this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/bunny.png"));
        this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleRotateLoaded);
        this.loader.load();
    }
    destructor() {
        super.destructor();
        this.app.ticker.remove(this.runExample, null);
        this.bunny.destructor();
        this.bunny = null;
    }
}
exports.SpriteBasic = SpriteBasic;


/***/ }),

/***/ "./js-compile/examples/SpriteExplosion.js":
/*!************************************************!*\
  !*** ./js-compile/examples/SpriteExplosion.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseExample_1 = __webpack_require__(/*! ./BaseExample */ "./js-compile/examples/BaseExample.js");
const URLLoader_1 = __webpack_require__(/*! ../raw-pixi-ts/URLLoader */ "./js-compile/raw-pixi-ts/URLLoader.js");
const Event_1 = __webpack_require__(/*! ../raw-pixi-ts/Event */ "./js-compile/raw-pixi-ts/Event.js");
const URLRequest_1 = __webpack_require__(/*! ../raw-pixi-ts/URLRequest */ "./js-compile/raw-pixi-ts/URLRequest.js");
const ResourceLoader_1 = __webpack_require__(/*! ../raw-pixi-ts/ResourceLoader */ "./js-compile/raw-pixi-ts/ResourceLoader.js");
const Texture_1 = __webpack_require__(/*! ../raw-pixi-ts/Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const BaseTexture_1 = __webpack_require__(/*! ../raw-pixi-ts/BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const Spritesheet_1 = __webpack_require__(/*! ../raw-pixi-ts/Spritesheet */ "./js-compile/raw-pixi-ts/Spritesheet.js");
const AnimatedSprite_1 = __webpack_require__(/*! ../raw-pixi-ts/AnimatedSprite */ "./js-compile/raw-pixi-ts/AnimatedSprite.js");
class SpriteExplosion extends BaseExample_1.BaseExample {
    constructor(app, width, height) {
        super(app, width, height);
        this.onAnimationParsed = (textures) => {
            const explosionTextures = [];
            let i;
            for (i = 0; i < 26; i++) {
                const texture = textures[`Explosion_Sequence_A ${i + 1}.png`];
                explosionTextures.push(texture);
            }
            for (i = 0; i < 50; i++) {
                const explosion = new AnimatedSprite_1.AnimatedSprite(explosionTextures);
                explosion.x = Math.random() * this.sizew;
                explosion.y = Math.random() * this.sizeh;
                explosion.anchor.set(0.5);
                explosion.rotation = Math.random() * Math.PI;
                explosion.scale.set(0.75 + Math.random() * 0.5);
                explosion.gotoAndPlay(Math.random() * 27);
                this.stage.addChild(explosion);
            }
            this.exampleReady();
        };
        this.handleJsonLoaded = (event) => {
            this.jsondata = JSON.parse(this.urlloader.data);
            this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/spritesheet/mc.png"));
            this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleRotateLoaded);
            this.loader.load();
        };
        this.handleRotateLoaded = (event) => {
            this.txt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            let spritesheet = new Spritesheet_1.Spritesheet(this.txt, this.jsondata);
            spritesheet.parse(this.onAnimationParsed);
        };
        this.backColor = 0x000000;
        this.activateMask();
        this.urlloader = new URLLoader_1.URLLoader();
        this.urlloader.addEventListener(Event_1.Event.COMPLETE, this.handleJsonLoaded);
        this.urlloader.load(new URLRequest_1.URLRequest("examples/assets/spritesheet/mc.json"));
    }
    destructor() {
        super.destructor();
        this.txt.destroy(null);
        this.txt = null;
        this.jsondata = null;
    }
}
exports.SpriteExplosion = SpriteExplosion;


/***/ }),

/***/ "./js-compile/examples/SpriteSpeed.js":
/*!********************************************!*\
  !*** ./js-compile/examples/SpriteSpeed.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseExample_1 = __webpack_require__(/*! ./BaseExample */ "./js-compile/examples/BaseExample.js");
const URLLoader_1 = __webpack_require__(/*! ../raw-pixi-ts/URLLoader */ "./js-compile/raw-pixi-ts/URLLoader.js");
const ResourceLoader_1 = __webpack_require__(/*! ../raw-pixi-ts/ResourceLoader */ "./js-compile/raw-pixi-ts/ResourceLoader.js");
const Texture_1 = __webpack_require__(/*! ../raw-pixi-ts/Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const AnimatedSprite_1 = __webpack_require__(/*! ../raw-pixi-ts/AnimatedSprite */ "./js-compile/raw-pixi-ts/AnimatedSprite.js");
const Event_1 = __webpack_require__(/*! ../raw-pixi-ts/Event */ "./js-compile/raw-pixi-ts/Event.js");
const URLRequest_1 = __webpack_require__(/*! ../raw-pixi-ts/URLRequest */ "./js-compile/raw-pixi-ts/URLRequest.js");
const BaseTexture_1 = __webpack_require__(/*! ../raw-pixi-ts/BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const Spritesheet_1 = __webpack_require__(/*! ../raw-pixi-ts/Spritesheet */ "./js-compile/raw-pixi-ts/Spritesheet.js");
class SpriteSpeed extends BaseExample_1.BaseExample {
    constructor(app, width, height) {
        super(app, width, height);
        this.onAnimationParsed = (loadedtextures) => {
            const textures = [];
            let i;
            for (i = 0; i < 10; i++) {
                const framekey = `0123456789 ${i}.ase`;
                const texture = loadedtextures[framekey];
                const time = this.spritesheet.data.frames[framekey].duration;
                textures.push({ texture, time });
            }
            const scaling = 4;
            const slow = new AnimatedSprite_1.AnimatedSprite(textures);
            slow.anchor.set(0.5);
            slow.scale.set(scaling);
            slow.animationSpeed = 0.5;
            slow.x = (this.sizew - slow.width) / 2;
            slow.y = this.sizeh / 2;
            slow.play();
            this.stage.addChild(slow);
            const fast = new AnimatedSprite_1.AnimatedSprite(textures);
            fast.anchor.set(0.5);
            fast.scale.set(scaling);
            fast.x = (this.sizew + fast.width) / 2;
            fast.y = this.sizeh / 2;
            fast.play();
            this.stage.addChild(fast);
            // this.app.ticker.add(this.runExample)
            this.exampleReady();
        };
        this.runExample = (delta) => {
        };
        this.handleJsonLoaded = (event) => {
            this.jsondata = JSON.parse(this.urlloader.data);
            this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/spritesheet/0123456789.png"));
            this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleRotateLoaded);
            this.loader.load();
        };
        this.handleRotateLoaded = (event) => {
            this.txt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            this.spritesheet = new Spritesheet_1.Spritesheet(this.txt, this.jsondata);
            this.spritesheet.parse(this.onAnimationParsed);
        };
        this.backColor = 0x57AACC;
        this.urlloader = new URLLoader_1.URLLoader();
        this.urlloader.addEventListener(Event_1.Event.COMPLETE, this.handleJsonLoaded);
        this.urlloader.load(new URLRequest_1.URLRequest("examples/assets/spritesheet/0123456789.json"));
    }
    destructor() {
        super.destructor();
        this.app.ticker.remove(this.runExample, null);
        if (this.spritesheet) {
            this.spritesheet.destructor();
        }
        this.spritesheet = null;
        if (this.txt) {
            this.txt.destructor();
        }
        this.txt = null;
        if (this.anim) {
            this.anim.destructor();
        }
        this.anim = null;
    }
}
exports.SpriteSpeed = SpriteSpeed;


/***/ }),

/***/ "./js-compile/examples/SpriteSwap.js":
/*!*******************************************!*\
  !*** ./js-compile/examples/SpriteSwap.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseExample_1 = __webpack_require__(/*! ./BaseExample */ "./js-compile/examples/BaseExample.js");
const ResourceLoader_1 = __webpack_require__(/*! ../raw-pixi-ts/ResourceLoader */ "./js-compile/raw-pixi-ts/ResourceLoader.js");
const URLRequest_1 = __webpack_require__(/*! ../raw-pixi-ts/URLRequest */ "./js-compile/raw-pixi-ts/URLRequest.js");
const Event_1 = __webpack_require__(/*! ../raw-pixi-ts/Event */ "./js-compile/raw-pixi-ts/Event.js");
const Texture_1 = __webpack_require__(/*! ../raw-pixi-ts/Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const BaseTexture_1 = __webpack_require__(/*! ../raw-pixi-ts/BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const Sprite_1 = __webpack_require__(/*! ../raw-pixi-ts/Sprite */ "./js-compile/raw-pixi-ts/Sprite.js");
const MouseEvent_1 = __webpack_require__(/*! ../raw-pixi-ts/MouseEvent */ "./js-compile/raw-pixi-ts/MouseEvent.js");
class SpriteSwap extends BaseExample_1.BaseExample {
    constructor(app, width, height) {
        super(app, width, height);
        this.handleRotateLoaded = (event) => {
            this.txt1 = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/eggHead.png"));
            this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleRotate2Loaded);
            this.loader.load();
        };
        this.handleRotate2Loaded = (event) => {
            this.txt2 = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            this.dude = new Sprite_1.Sprite(this.txt1);
            this.dude.anchor.set(0.5);
            this.dude.x = this.sizew / 2;
            this.dude.y = this.sizeh / 2;
            this.stage.addChild(this.dude);
            this.dude.interactive = true;
            this.dude.buttonMode = true;
            this.dude.addEventListener(MouseEvent_1.MouseEvent.POINTER_DOWN, this.handleDown);
            this.app.ticker.add(this.runExample);
            this.exampleReady();
        };
        this.handleDown = (event) => {
            this.bol = !this.bol;
            if (this.bol) {
                this.dude.texture = this.txt2;
            }
            else {
                this.dude.texture = this.txt1;
            }
        };
        this.runExample = (delta) => {
            this.dude.rotation += 0.1;
        };
        this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/flowerTop.png"));
        this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleRotateLoaded);
        this.loader.load();
    }
    destructor() {
        super.destructor();
        this.app.ticker.remove(this.runExample, null);
        this.dude.destroy(null);
        this.dude = null;
        this.txt1.destroy(null);
        this.txt1 = null;
        this.txt2.destroy(null);
        this.txt2 = null;
    }
}
exports.SpriteSwap = SpriteSwap;


/***/ }),

/***/ "./js-compile/examples/SpriteTiling.js":
/*!*********************************************!*\
  !*** ./js-compile/examples/SpriteTiling.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseExample_1 = __webpack_require__(/*! ./BaseExample */ "./js-compile/examples/BaseExample.js");
const ResourceLoader_1 = __webpack_require__(/*! ../raw-pixi-ts/ResourceLoader */ "./js-compile/raw-pixi-ts/ResourceLoader.js");
const URLRequest_1 = __webpack_require__(/*! ../raw-pixi-ts/URLRequest */ "./js-compile/raw-pixi-ts/URLRequest.js");
const Event_1 = __webpack_require__(/*! ../raw-pixi-ts/Event */ "./js-compile/raw-pixi-ts/Event.js");
const Texture_1 = __webpack_require__(/*! ../raw-pixi-ts/Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const BaseTexture_1 = __webpack_require__(/*! ../raw-pixi-ts/BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const TilingSprite_1 = __webpack_require__(/*! ../raw-pixi-ts/TilingSprite */ "./js-compile/raw-pixi-ts/TilingSprite.js");
class SpriteTiling extends BaseExample_1.BaseExample {
    constructor(app, width, height) {
        super(app, width, height);
        this.handleRotateLoaded = (event) => {
            this.txt1 = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            this.tilingSprite = new TilingSprite_1.TilingSprite(this.txt1, this.sizew, this.sizeh);
            this.stage.addChild(this.tilingSprite);
            this.count = 0;
            this.app.ticker.add(this.runExample);
            this.exampleReady();
        };
        this.runExample = (delta) => {
            this.count += 0.005;
            this.tilingSprite.tileScale.x = 2 + Math.sin(this.count);
            this.tilingSprite.tileScale.y = 2 + Math.cos(this.count);
            this.tilingSprite.tilePosition.x += 1;
            this.tilingSprite.tilePosition.y += 1;
        };
        this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/p2.jpeg"));
        this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleRotateLoaded);
        this.loader.load();
    }
    destructor() {
        super.destructor();
        this.app.ticker.remove(this.runExample, null);
        this.tilingSprite.destroy(null);
        this.tilingSprite = null;
        this.txt1.destroy(null);
        this.txt1 = null;
    }
}
exports.SpriteTiling = SpriteTiling;


/***/ }),

/***/ "./js-compile/examples/SpriteVideo.js":
/*!********************************************!*\
  !*** ./js-compile/examples/SpriteVideo.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseExample_1 = __webpack_require__(/*! ./BaseExample */ "./js-compile/examples/BaseExample.js");
const Graphics_1 = __webpack_require__(/*! ../raw-pixi-ts/Graphics */ "./js-compile/raw-pixi-ts/Graphics.js");
const MouseEvent_1 = __webpack_require__(/*! ../raw-pixi-ts/MouseEvent */ "./js-compile/raw-pixi-ts/MouseEvent.js");
const Texture_1 = __webpack_require__(/*! ../raw-pixi-ts/Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const Sprite_1 = __webpack_require__(/*! ../raw-pixi-ts/Sprite */ "./js-compile/raw-pixi-ts/Sprite.js");
const BaseTexture_1 = __webpack_require__(/*! ../raw-pixi-ts/BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
class SpriteVideo extends BaseExample_1.BaseExample {
    constructor(app, width, height) {
        super(app, width, height);
        this.onPlayVideo = (event) => {
            this.button.destroy(null);
            this.video.play();
            const texture = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.video));
            const videoSprite = new Sprite_1.Sprite(texture);
            videoSprite.width = this.sizew;
            videoSprite.height = this.sizeh;
            this.stage.addChild(videoSprite);
        };
        this.button = new Graphics_1.Graphics()
            .beginFill(0x0, 0.5)
            .drawRoundedRect(0, 0, 100, 100, 10)
            .endFill()
            .beginFill(0xffffff)
            .moveTo(36, 30)
            .lineTo(36, 70)
            .lineTo(70, 50);
        this.button.x = (this.sizew - this.button.width) / 2;
        this.button.y = (this.sizeh - this.button.height) / 2;
        this.button.interactive = true;
        this.button.buttonMode = true;
        this.stage.addChild(this.button);
        this.video = document.createElement("video");
        this.video['type'] = "video/mp4";
        this.video.src = "examples/assets/video.mp4";
        this.video.addEventListener('canplay', () => {
            this.button.addEventListener(MouseEvent_1.MouseEvent.POINTER_TAP, this.onPlayVideo);
            this.exampleReady();
        });
    }
    destructor() {
        super.destructor();
        this.video = null;
    }
}
exports.SpriteVideo = SpriteVideo;


/***/ }),

/***/ "./js-compile/examples/Spritejet.js":
/*!******************************************!*\
  !*** ./js-compile/examples/Spritejet.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseExample_1 = __webpack_require__(/*! ./BaseExample */ "./js-compile/examples/BaseExample.js");
const URLLoader_1 = __webpack_require__(/*! ../raw-pixi-ts/URLLoader */ "./js-compile/raw-pixi-ts/URLLoader.js");
const ResourceLoader_1 = __webpack_require__(/*! ../raw-pixi-ts/ResourceLoader */ "./js-compile/raw-pixi-ts/ResourceLoader.js");
const Texture_1 = __webpack_require__(/*! ../raw-pixi-ts/Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const Event_1 = __webpack_require__(/*! ../raw-pixi-ts/Event */ "./js-compile/raw-pixi-ts/Event.js");
const URLRequest_1 = __webpack_require__(/*! ../raw-pixi-ts/URLRequest */ "./js-compile/raw-pixi-ts/URLRequest.js");
const BaseTexture_1 = __webpack_require__(/*! ../raw-pixi-ts/BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const Spritesheet_1 = __webpack_require__(/*! ../raw-pixi-ts/Spritesheet */ "./js-compile/raw-pixi-ts/Spritesheet.js");
const AnimatedSprite_1 = __webpack_require__(/*! ../raw-pixi-ts/AnimatedSprite */ "./js-compile/raw-pixi-ts/AnimatedSprite.js");
class Spritejet extends BaseExample_1.BaseExample {
    constructor(app, width, height) {
        super(app, width, height);
        this.onAnimationParsed = (textures) => {
            const frames = [];
            for (let i = 0; i < 30; i++) {
                const val = i < 10 ? `0${i}` : i;
                frames.push(textures[`rollSequence00${val}.png`]);
            }
            this.anim = new AnimatedSprite_1.AnimatedSprite(frames);
            this.anim.x = this.sizew / 2;
            this.anim.y = this.sizeh / 2;
            this.anim.anchor.set(0.5);
            this.anim.animationSpeed = 0.5;
            this.anim.play();
            this.stage.addChild(this.anim);
            this.app.ticker.add(this.runExample);
            this.exampleReady();
        };
        this.runExample = (delta) => {
            this.anim.rotation += 0.01;
        };
        this.handleJsonLoaded = (event) => {
            this.jsondata = JSON.parse(this.urlloader.data);
            this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/spritesheet/fighter.png"));
            this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleRotateLoaded);
            this.loader.load();
        };
        this.handleRotateLoaded = (event) => {
            this.txt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            let spritesheet = new Spritesheet_1.Spritesheet(this.txt, this.jsondata);
            spritesheet.parse(this.onAnimationParsed);
        };
        this.backColor = 0x969696;
        this.urlloader = new URLLoader_1.URLLoader();
        this.urlloader.addEventListener(Event_1.Event.COMPLETE, this.handleJsonLoaded);
        this.urlloader.load(new URLRequest_1.URLRequest("examples/assets/spritesheet/fighter.json"));
    }
    destructor() {
        super.destructor();
        this.app.ticker.remove(this.runExample, null);
        if (this.anim) {
            this.anim.destructor();
        }
        this.anim = null;
        if (this.txt) {
            this.txt.destructor();
        }
        this.txt = null;
        this.jsondata = null;
    }
}
exports.Spritejet = Spritejet;


/***/ }),

/***/ "./js-compile/examples/TextBase.js":
/*!*****************************************!*\
  !*** ./js-compile/examples/TextBase.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseExample_1 = __webpack_require__(/*! ./BaseExample */ "./js-compile/examples/BaseExample.js");
const Text_1 = __webpack_require__(/*! ../raw-pixi-ts/Text */ "./js-compile/raw-pixi-ts/Text.js");
const TextStyle_1 = __webpack_require__(/*! ../raw-pixi-ts/TextStyle */ "./js-compile/raw-pixi-ts/TextStyle.js");
class TextBase extends BaseExample_1.BaseExample {
    constructor(app, width, height) {
        super(app, width, height);
        const basicText = new Text_1.Text('Basic text in pixi');
        basicText.x = 50;
        basicText.y = 100;
        this.stage.addChild(basicText);
        const style = new TextStyle_1.TextStyle({
            fontFamily: 'Arial',
            fontSize: 36,
            fontStyle: 'italic',
            fontWeight: 'bold',
            fill: ['#ffffff', '#00ff99'],
            stroke: '#4a1850',
            strokeThickness: 5,
            dropShadow: true,
            dropShadowColor: '#000000',
            dropShadowBlur: 4,
            dropShadowAngle: Math.PI / 6,
            dropShadowDistance: 6,
            wordWrap: true,
            wordWrapWidth: 440,
        });
        const richText = new Text_1.Text('Rich text with a lot of options and across multiple lines', style);
        richText.x = 50;
        richText.y = 250;
        this.stage.addChild(richText);
        setTimeout(() => {
            this.exampleReady();
        }, 1000);
    }
}
exports.TextBase = TextBase;


/***/ }),

/***/ "./js-compile/examples/TextBitmap.js":
/*!*******************************************!*\
  !*** ./js-compile/examples/TextBitmap.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseExample_1 = __webpack_require__(/*! ./BaseExample */ "./js-compile/examples/BaseExample.js");
const FontManager_1 = __webpack_require__(/*! ../raw-pixi-ts/FontManager */ "./js-compile/raw-pixi-ts/FontManager.js");
const Event_1 = __webpack_require__(/*! ../raw-pixi-ts/Event */ "./js-compile/raw-pixi-ts/Event.js");
const BitmapText_1 = __webpack_require__(/*! ../raw-pixi-ts/BitmapText */ "./js-compile/raw-pixi-ts/BitmapText.js");
class TextBitmap extends BaseExample_1.BaseExample {
    constructor(app, width, height) {
        super(app, width, height);
        this.handleFontLoaded = (event) => {
            const bitmapFontText = new BitmapText_1.BitmapText('bitmap fonts are supported!\nWoo yay!');
            bitmapFontText.fontSize = 55;
            bitmapFontText.font = "Desyrel";
            bitmapFontText.align = 'left';
            bitmapFontText.x = 50;
            bitmapFontText.y = 200;
            this.stage.addChild(bitmapFontText);
            this.exampleReady();
        };
        let loader = FontManager_1.FontManager.loadBitmapFont("examples/assets/bitmap-font/desyrel.xml");
        loader.addEventListener(Event_1.Event.COMPLETE, this.handleFontLoaded);
    }
}
exports.TextBitmap = TextBitmap;


/***/ }),

/***/ "./js-compile/examples/TextWebFont.js":
/*!********************************************!*\
  !*** ./js-compile/examples/TextWebFont.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseExample_1 = __webpack_require__(/*! ./BaseExample */ "./js-compile/examples/BaseExample.js");
const FontManager_1 = __webpack_require__(/*! ../raw-pixi-ts/FontManager */ "./js-compile/raw-pixi-ts/FontManager.js");
const Text_1 = __webpack_require__(/*! ../raw-pixi-ts/Text */ "./js-compile/raw-pixi-ts/Text.js");
class TextWebFont extends BaseExample_1.BaseExample {
    constructor(app, width, height) {
        super(app, width, height);
        this.handleWebFontLoaded = () => {
            const textSample = new Text_1.Text('Pixi.js text using the\ncustom "Snippet" Webfont', {
                fontFamily: 'Snippet',
                fontSize: 50,
                fill: 'white',
                align: 'left',
            });
            textSample.position.set(50, 200);
            this.stage.addChild(textSample);
            this.exampleReady();
        };
        FontManager_1.FontManager.onWebFontloaded = this.handleWebFontLoaded;
        FontManager_1.FontManager.WebFontConfig = {
            google: {
                families: ['Snippet', 'Arvo:700italic', 'Podkova:700'],
            }
        };
    }
}
exports.TextWebFont = TextWebFont;


/***/ }),

/***/ "./js-compile/examples/TextureAdvanced.js":
/*!************************************************!*\
  !*** ./js-compile/examples/TextureAdvanced.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseExample_1 = __webpack_require__(/*! ./BaseExample */ "./js-compile/examples/BaseExample.js");
const RenderTexture_1 = __webpack_require__(/*! ../raw-pixi-ts/RenderTexture */ "./js-compile/raw-pixi-ts/RenderTexture.js");
const Sprite_1 = __webpack_require__(/*! ../raw-pixi-ts/Sprite */ "./js-compile/raw-pixi-ts/Sprite.js");
const Container_1 = __webpack_require__(/*! ../raw-pixi-ts/Container */ "./js-compile/raw-pixi-ts/Container.js");
const ResourceLoader_1 = __webpack_require__(/*! ../raw-pixi-ts/ResourceLoader */ "./js-compile/raw-pixi-ts/ResourceLoader.js");
const URLRequest_1 = __webpack_require__(/*! ../raw-pixi-ts/URLRequest */ "./js-compile/raw-pixi-ts/URLRequest.js");
const Event_1 = __webpack_require__(/*! ../raw-pixi-ts/Event */ "./js-compile/raw-pixi-ts/Event.js");
const Texture_1 = __webpack_require__(/*! ../raw-pixi-ts/Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const BaseTexture_1 = __webpack_require__(/*! ../raw-pixi-ts/BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
class TextureAdvanced extends BaseExample_1.BaseExample {
    constructor(app, width, height) {
        super(app, width, height);
        this.runExample = (delta) => {
            for (let i = 0; i < this.items.length; i++) {
                const item = this.items[i];
                item.rotation += 0.1;
            }
            this.count += 0.01;
            const temp = this.renderTexture;
            this.renderTexture = this.renderTexture2;
            this.renderTexture2 = temp;
            this.outputSprite.texture = this.renderTexture;
            this.stuffContainer.rotation -= 0.01;
            this.outputSprite.scale.set(1 + Math.sin(this.count) * 0.2);
            this.app.renderer.render(this.stage, this.renderTexture2, false);
        };
        this.handleResourceLoaded = (event) => {
            let txt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            this.fruits.push(txt);
            this.loadAssets();
        };
        this.renderTexture = RenderTexture_1.RenderTexture.create(this.sizew, this.sizeh);
        this.renderTexture2 = RenderTexture_1.RenderTexture.create(this.sizew, this.sizeh);
        const currentTexture = this.renderTexture;
        this.outputSprite = new Sprite_1.Sprite(currentTexture);
        this.outputSprite.x = 400;
        this.outputSprite.y = 300;
        this.outputSprite.anchor.set(0.5);
        this.stage.addChild(this.outputSprite);
        this.stuffContainer = new Container_1.Container();
        this.stuffContainer.x = 400;
        this.stuffContainer.y = 300;
        this.stage.addChild(this.stuffContainer);
        this.fruitslinks = [
            'examples/assets/rt_object_01.png',
            'examples/assets/rt_object_02.png',
            'examples/assets/rt_object_03.png',
            'examples/assets/rt_object_04.png',
            'examples/assets/rt_object_05.png',
            'examples/assets/rt_object_06.png',
            'examples/assets/rt_object_07.png',
            'examples/assets/rt_object_08.png',
        ];
        this.fruits = [];
        this.loadAssets();
    }
    init() {
        this.items = [];
        for (let i = 0; i < 20; i++) {
            const item = new Sprite_1.Sprite(this.fruits[i % this.fruits.length]);
            item.x = Math.random() * 400 - 200;
            item.y = Math.random() * 400 - 200;
            item.anchor.set(0.5);
            this.stuffContainer.addChild(item);
            this.items.push(item);
        }
        this.count = 0;
        this.app.ticker.add(this.runExample);
        this.exampleReady();
    }
    loadAssets() {
        if (!this.fruitslinks.length) {
            this.init();
            return;
        }
        this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest(this.fruitslinks.pop()));
        this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleResourceLoaded);
        this.loader.load();
    }
    destructor() {
        super.destructor();
        this.app.ticker.remove(this.runExample, null);
        this.stuffContainer.destroy(null);
        this.stuffContainer = null;
        this.outputSprite.destroy(null);
        this.outputSprite = null;
        this.items = null;
        this.fruitslinks = null;
        this.fruits = null;
    }
}
exports.TextureAdvanced = TextureAdvanced;


/***/ }),

/***/ "./js-compile/examples/TextureGradientBasic.js":
/*!*****************************************************!*\
  !*** ./js-compile/examples/TextureGradientBasic.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseExample_1 = __webpack_require__(/*! ./BaseExample */ "./js-compile/examples/BaseExample.js");
const Texture_1 = __webpack_require__(/*! ../raw-pixi-ts/Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const Sprite_1 = __webpack_require__(/*! ../raw-pixi-ts/Sprite */ "./js-compile/raw-pixi-ts/Sprite.js");
class TextureGradientBasic extends BaseExample_1.BaseExample {
    constructor(app, width, height) {
        super(app, width, height);
        const gradTexture = this.createGradTexture();
        const sprite = new Sprite_1.Sprite(gradTexture);
        sprite.position.set(100, 100);
        sprite.rotation = Math.PI / 8;
        sprite.width = 500;
        sprite.height = 50;
        this.stage.addChild(sprite);
        setTimeout(() => {
            this.exampleReady();
        }, 1000);
    }
    createGradTexture() {
        const quality = 256;
        const canvas = document.createElement('canvas');
        canvas.width = quality;
        canvas.height = 1;
        const ctx = canvas.getContext('2d');
        const grd = ctx.createLinearGradient(0, 0, quality, 0);
        grd.addColorStop(0, 'rgba(255, 255, 255, 0.0)');
        grd.addColorStop(0.3, 'cyan');
        grd.addColorStop(0.7, 'red');
        grd.addColorStop(1, 'green');
        ctx.fillStyle = grd;
        ctx.fillRect(0, 0, quality, 1);
        return Texture_1.Texture.from(canvas);
    }
}
exports.TextureGradientBasic = TextureGradientBasic;


/***/ }),

/***/ "./js-compile/examples/TextureGradientResource.js":
/*!********************************************************!*\
  !*** ./js-compile/examples/TextureGradientResource.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseExample_1 = __webpack_require__(/*! ./BaseExample */ "./js-compile/examples/BaseExample.js");
const Resource_1 = __webpack_require__(/*! ../raw-pixi-ts/Resource */ "./js-compile/raw-pixi-ts/Resource.js");
const BaseTexture_1 = __webpack_require__(/*! ../raw-pixi-ts/BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const Texture_1 = __webpack_require__(/*! ../raw-pixi-ts/Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const Sprite_1 = __webpack_require__(/*! ../raw-pixi-ts/Sprite */ "./js-compile/raw-pixi-ts/Sprite.js");
class TextureGradientResource extends BaseExample_1.BaseExample {
    constructor(app, width, height) {
        super(app, width, height);
        const gradBaseTexture = new BaseTexture_1.BaseTexture(new GradientResource());
        gradBaseTexture.setSize(500, 50);
        const gradTexture = new Texture_1.Texture(gradBaseTexture);
        const sprite = new Sprite_1.Sprite(gradTexture);
        sprite.position.set(100, 100);
        sprite.rotation = Math.PI / 8;
        this.stage.addChild(sprite);
        setTimeout(() => {
            this.exampleReady();
        }, 1000);
    }
}
exports.TextureGradientResource = TextureGradientResource;
class GradientResource extends Resource_1.Resource {
    constructor() {
        super(256, 100);
        this.canUpload = true;
    }
    upload(renderer, baseTexture, glTexture) {
        const { width } = this; // default size or from baseTexture?
        const { height } = this; // your choice.
        const canvas = document.createElement('canvas');
        this.source = canvas;
        this.source.width = width;
        this.source.height = height;
        const ctx = this.source.getContext('2d');
        const grd = ctx.createLinearGradient(0, 0, width, 0);
        grd.addColorStop(0, 'rgba(255, 255, 255, 0.0)');
        grd.addColorStop(0.3, 'cyan');
        grd.addColorStop(0.7, 'red');
        grd.addColorStop(1, 'green');
        ctx.fillStyle = grd;
        ctx.fillRect(0, 0, width, height);
        glTexture.width = width;
        glTexture.height = height;
        const { gl } = renderer;
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, baseTexture.premultiplyAlpha);
        gl.texImage2D(baseTexture.target, 0, baseTexture.format, baseTexture.format, baseTexture.type, this.source);
        return true;
    }
}


/***/ }),

/***/ "./js-compile/examples/TextureRender.js":
/*!**********************************************!*\
  !*** ./js-compile/examples/TextureRender.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseExample_1 = __webpack_require__(/*! ./BaseExample */ "./js-compile/examples/BaseExample.js");
const ResourceLoader_1 = __webpack_require__(/*! ../raw-pixi-ts/ResourceLoader */ "./js-compile/raw-pixi-ts/ResourceLoader.js");
const URLRequest_1 = __webpack_require__(/*! ../raw-pixi-ts/URLRequest */ "./js-compile/raw-pixi-ts/URLRequest.js");
const Event_1 = __webpack_require__(/*! ../raw-pixi-ts/Event */ "./js-compile/raw-pixi-ts/Event.js");
const Texture_1 = __webpack_require__(/*! ../raw-pixi-ts/Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const BaseTexture_1 = __webpack_require__(/*! ../raw-pixi-ts/BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const Container_1 = __webpack_require__(/*! ../raw-pixi-ts/Container */ "./js-compile/raw-pixi-ts/Container.js");
const Sprite_1 = __webpack_require__(/*! ../raw-pixi-ts/Sprite */ "./js-compile/raw-pixi-ts/Sprite.js");
const WebGLSettings_1 = __webpack_require__(/*! ../raw-pixi-ts/WebGLSettings */ "./js-compile/raw-pixi-ts/WebGLSettings.js");
const BaseRenderTexture_1 = __webpack_require__(/*! ../raw-pixi-ts/BaseRenderTexture */ "./js-compile/raw-pixi-ts/BaseRenderTexture.js");
const RenderTexture_1 = __webpack_require__(/*! ../raw-pixi-ts/RenderTexture */ "./js-compile/raw-pixi-ts/RenderTexture.js");
class TextureRender extends BaseExample_1.BaseExample {
    constructor(app, width, height) {
        super(app, width, height);
        this.handleResourceLoaded = (event) => {
            let txt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            this.container = new Container_1.Container();
            this.stage.addChild(this.container);
            for (let i = 0; i < 25; i++) {
                const bunny = new Sprite_1.Sprite(txt);
                bunny.x = (i % 5) * 30;
                bunny.y = Math.floor(i / 5) * 30;
                bunny.rotation = Math.random() * (Math.PI * 2);
                this.container.addChild(bunny);
            }
            const brt = new BaseRenderTexture_1.BaseRenderTexture(300, 300, WebGLSettings_1.WebGLSettings.SCALE_MODES.LINEAR, 1);
            this.rt = new RenderTexture_1.RenderTexture(brt);
            const sprite = new Sprite_1.Sprite(this.rt);
            sprite.x = 450;
            sprite.y = 60;
            this.stage.addChild(sprite);
            this.container.x = 100;
            this.container.y = 60;
            this.app.ticker.add(this.runExample);
            this.exampleReady();
        };
        this.runExample = (delta) => {
            this.app.renderer.render(this.container, this.rt);
        };
        this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/bunny.png"));
        this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleResourceLoaded);
        this.loader.load();
    }
    destructor() {
        super.destructor();
        this.app.ticker.remove(this.runExample, null);
        this.container.destroy(null);
        this.container = null;
        this.rt.destroy(null);
        this.rt = null;
    }
}
exports.TextureRender = TextureRender;


/***/ }),

/***/ "./js-compile/examples/TextureRotate.js":
/*!**********************************************!*\
  !*** ./js-compile/examples/TextureRotate.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseExample_1 = __webpack_require__(/*! ./BaseExample */ "./js-compile/examples/BaseExample.js");
const ResourceLoader_1 = __webpack_require__(/*! ../raw-pixi-ts/ResourceLoader */ "./js-compile/raw-pixi-ts/ResourceLoader.js");
const URLRequest_1 = __webpack_require__(/*! ../raw-pixi-ts/URLRequest */ "./js-compile/raw-pixi-ts/URLRequest.js");
const Event_1 = __webpack_require__(/*! ../raw-pixi-ts/Event */ "./js-compile/raw-pixi-ts/Event.js");
const Texture_1 = __webpack_require__(/*! ../raw-pixi-ts/Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const BaseTexture_1 = __webpack_require__(/*! ../raw-pixi-ts/BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const GroupD8_1 = __webpack_require__(/*! ../raw-pixi-ts/GroupD8 */ "./js-compile/raw-pixi-ts/GroupD8.js");
const Rectangle_1 = __webpack_require__(/*! ../flash/geom/Rectangle */ "./js-compile/flash/geom/Rectangle.js");
const Sprite_1 = __webpack_require__(/*! ../raw-pixi-ts/Sprite */ "./js-compile/raw-pixi-ts/Sprite.js");
const Text_1 = __webpack_require__(/*! ../raw-pixi-ts/Text */ "./js-compile/raw-pixi-ts/Text.js");
class TextureRotate extends BaseExample_1.BaseExample {
    constructor(app, width, height) {
        super(app, width, height);
        this.handleResourceLoaded = (event) => {
            let txt = new Texture_1.Texture(new BaseTexture_1.BaseTexture(this.loader.imageData));
            const textures = [txt];
            const D8 = GroupD8_1.GroupD8;
            for (let rotate = 1; rotate < 16; rotate++) {
                const h = D8.isVertical(rotate) ? txt.frame.width : txt.frame.height;
                const w = D8.isVertical(rotate) ? txt.frame.height : txt.frame.width;
                const { frame } = txt;
                const crop = Rectangle_1.Rectangle.getRectangle(txt.frame.x, txt.frame.y, w, h);
                const trim = crop;
                let rotatedTexture;
                if (rotate % 2 === 0) {
                    rotatedTexture = new Texture_1.Texture(txt.baseTexture, frame, crop, trim, rotate);
                }
                else {
                    rotatedTexture = new Texture_1.Texture(txt.baseTexture, frame, crop, trim, rotate - 1);
                    rotatedTexture.rotate++;
                }
                textures.push(rotatedTexture);
            }
            const offsetX = this.sizew / 16 | 0;
            const offsetY = this.sizeh / 8 | 0;
            const gridW = this.sizew / 4 | 0;
            const gridH = this.sizeh / 5 | 0;
            for (let i = 0; i < 16; i++) {
                const dude = new Sprite_1.Sprite(textures[i < 8 ? i * 2 : (i - 8) * 2 + 1]);
                dude.scale.x = 0.5;
                dude.scale.y = 0.5;
                dude.x = offsetX + gridW * (i % 4);
                dude.y = offsetY + gridH * (i / 4 | 0);
                this.stage.addChild(dude);
                const text = new Text_1.Text(`rotate = ${dude.texture.rotate}`, {
                    fontFamily: 'Courier New', fontSize: '12px', fill: 'white', align: 'left',
                });
                text.x = dude.x;
                text.y = dude.y - 20;
                this.stage.addChild(text);
            }
            this.exampleReady();
        };
        this.loader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest("examples/assets/flowerTop.png"));
        this.loader.addEventListener(Event_1.Event.COMPLETE, this.handleResourceLoaded);
        this.loader.load();
    }
}
exports.TextureRotate = TextureRotate;


/***/ }),

/***/ "./js-compile/examples/controls/ExampleDisplay.js":
/*!********************************************************!*\
  !*** ./js-compile/examples/controls/ExampleDisplay.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Container_1 = __webpack_require__(/*! ../../raw-pixi-ts/Container */ "./js-compile/raw-pixi-ts/Container.js");
const Graphics_1 = __webpack_require__(/*! ../../raw-pixi-ts/Graphics */ "./js-compile/raw-pixi-ts/Graphics.js");
const ExampleList_1 = __webpack_require__(/*! ./ExampleList */ "./js-compile/examples/controls/ExampleList.js");
const AdvancedCard_1 = __webpack_require__(/*! ../AdvancedCard */ "./js-compile/examples/AdvancedCard.js");
const AdvancedSlots_1 = __webpack_require__(/*! ../AdvancedSlots */ "./js-compile/examples/AdvancedSlots.js");
const AdvancedTrail_1 = __webpack_require__(/*! ../AdvancedTrail */ "./js-compile/examples/AdvancedTrail.js");
const AdvancedWarp_1 = __webpack_require__(/*! ../AdvancedWarp */ "./js-compile/examples/AdvancedWarp.js");
const BasicBlend_1 = __webpack_require__(/*! ../BasicBlend */ "./js-compile/examples/BasicBlend.js");
const InteractionIcon_1 = __webpack_require__(/*! ../InteractionIcon */ "./js-compile/examples/InteractionIcon.js");
const SpriteVideo_1 = __webpack_require__(/*! ../SpriteVideo */ "./js-compile/examples/SpriteVideo.js");
const TextureRotate_1 = __webpack_require__(/*! ../TextureRotate */ "./js-compile/examples/TextureRotate.js");
const BasicContainer_1 = __webpack_require__(/*! ../BasicContainer */ "./js-compile/examples/BasicContainer.js");
const BasicTinting_1 = __webpack_require__(/*! ../BasicTinting */ "./js-compile/examples/BasicTinting.js");
const BasicParticles_1 = __webpack_require__(/*! ../BasicParticles */ "./js-compile/examples/BasicParticles.js");
const GraphicsSimple_1 = __webpack_require__(/*! ../GraphicsSimple */ "./js-compile/examples/GraphicsSimple.js");
const GraphicsAdvanced_1 = __webpack_require__(/*! ../GraphicsAdvanced */ "./js-compile/examples/GraphicsAdvanced.js");
const GraphicsDynamic_1 = __webpack_require__(/*! ../GraphicsDynamic */ "./js-compile/examples/GraphicsDynamic.js");
const TextureRender_1 = __webpack_require__(/*! ../TextureRender */ "./js-compile/examples/TextureRender.js");
const TextureAdvanced_1 = __webpack_require__(/*! ../TextureAdvanced */ "./js-compile/examples/TextureAdvanced.js");
const TextureGradientBasic_1 = __webpack_require__(/*! ../TextureGradientBasic */ "./js-compile/examples/TextureGradientBasic.js");
const TextureGradientResource_1 = __webpack_require__(/*! ../TextureGradientResource */ "./js-compile/examples/TextureGradientResource.js");
const TextBase_1 = __webpack_require__(/*! ../TextBase */ "./js-compile/examples/TextBase.js");
const TextBitmap_1 = __webpack_require__(/*! ../TextBitmap */ "./js-compile/examples/TextBitmap.js");
const TextWebFont_1 = __webpack_require__(/*! ../TextWebFont */ "./js-compile/examples/TextWebFont.js");
const MaskGraphics_1 = __webpack_require__(/*! ../MaskGraphics */ "./js-compile/examples/MaskGraphics.js");
const MaskSprite_1 = __webpack_require__(/*! ../MaskSprite */ "./js-compile/examples/MaskSprite.js");
const FilterBlur_1 = __webpack_require__(/*! ../FilterBlur */ "./js-compile/examples/FilterBlur.js");
const FilterColor_1 = __webpack_require__(/*! ../FilterColor */ "./js-compile/examples/FilterColor.js");
const FilterCrawlies_1 = __webpack_require__(/*! ../FilterCrawlies */ "./js-compile/examples/FilterCrawlies.js");
const FilterFlag_1 = __webpack_require__(/*! ../FilterFlag */ "./js-compile/examples/FilterFlag.js");
const MaskFilter_1 = __webpack_require__(/*! ../MaskFilter */ "./js-compile/examples/MaskFilter.js");
const InteractionClick_1 = __webpack_require__(/*! ../InteractionClick */ "./js-compile/examples/InteractionClick.js");
const InteractionInteractivity_1 = __webpack_require__(/*! ../InteractionInteractivity */ "./js-compile/examples/InteractionInteractivity.js");
const InteractionDragging_1 = __webpack_require__(/*! ../InteractionDragging */ "./js-compile/examples/InteractionDragging.js");
const SpriteBasic_1 = __webpack_require__(/*! ../SpriteBasic */ "./js-compile/examples/SpriteBasic.js");
const SpriteSwap_1 = __webpack_require__(/*! ../SpriteSwap */ "./js-compile/examples/SpriteSwap.js");
const SpriteTiling_1 = __webpack_require__(/*! ../SpriteTiling */ "./js-compile/examples/SpriteTiling.js");
const SpriteExplosion_1 = __webpack_require__(/*! ../SpriteExplosion */ "./js-compile/examples/SpriteExplosion.js");
const Spritejet_1 = __webpack_require__(/*! ../Spritejet */ "./js-compile/examples/Spritejet.js");
const SpriteSpeed_1 = __webpack_require__(/*! ../SpriteSpeed */ "./js-compile/examples/SpriteSpeed.js");
const FilterBlending_1 = __webpack_require__(/*! ../FilterBlending */ "./js-compile/examples/FilterBlending.js");
const FilterCustom_1 = __webpack_require__(/*! ../FilterCustom */ "./js-compile/examples/FilterCustom.js");
const FilterShadow_1 = __webpack_require__(/*! ../FilterShadow */ "./js-compile/examples/FilterShadow.js");
const MeshBasic_1 = __webpack_require__(/*! ../MeshBasic */ "./js-compile/examples/MeshBasic.js");
const MeshAdvanced_1 = __webpack_require__(/*! ../MeshAdvanced */ "./js-compile/examples/MeshAdvanced.js");
const MeshTriangle_1 = __webpack_require__(/*! ../MeshTriangle */ "./js-compile/examples/MeshTriangle.js");
const MeshColoredTriangle_1 = __webpack_require__(/*! ../MeshColoredTriangle */ "./js-compile/examples/MeshColoredTriangle.js");
const MeshTextured_1 = __webpack_require__(/*! ../MeshTextured */ "./js-compile/examples/MeshTextured.js");
const MeshUniforms_1 = __webpack_require__(/*! ../MeshUniforms */ "./js-compile/examples/MeshUniforms.js");
const MeshGeometry_1 = __webpack_require__(/*! ../MeshGeometry */ "./js-compile/examples/MeshGeometry.js");
const MeshShader_1 = __webpack_require__(/*! ../MeshShader */ "./js-compile/examples/MeshShader.js");
const Event_1 = __webpack_require__(/*! ../../raw-pixi-ts/Event */ "./js-compile/raw-pixi-ts/Event.js");
const InstanceCounter_1 = __webpack_require__(/*! ../../raw-pixi-ts/InstanceCounter */ "./js-compile/raw-pixi-ts/InstanceCounter.js");
class ExampleDisplay extends Container_1.Container {
    constructor(app, displayWidth, displayheight) {
        super();
        this.handleExampleRequest = (event) => {
            this.setExample(this.list.selectedClass);
        };
        this.handleComplete = (event) => {
            this.list.addEventListener(Event_1.Event.CHANGE, this.handleExampleRequest);
        };
        let controlSize = 200;
        this.app = app;
        this.background = new Graphics_1.Graphics();
        this.refreshBackground(0x969696);
        app.stage.addChild(this.background);
        this.stageLayer = new Container_1.Container();
        app.stage.addChild(this.stageLayer);
        this.list = new ExampleList_1.ExampleList(controlSize, displayheight);
        this.list.x = displayWidth - controlSize;
        displayWidth = displayWidth - controlSize;
        app.stage.addChild(this.list);
        this.controlLayer = new Container_1.Container();
        app.stage.addChild(this.controlLayer);
        this.framesize = 5;
        this.exampleWidth = displayWidth; //(displayWidth - controlSize) - (this.framesize / 2)
        this.exampleheight = displayheight - (this.framesize / 2);
        this.frame = new Graphics_1.Graphics();
        this.frame.beginFill(0x000FFF);
        this.frame.drawRect(0, 0, this.framesize, displayheight);
        this.frame.drawRect(displayWidth - this.framesize, 0, 5, displayheight);
        this.frame.drawRect(this.framesize, 0, displayWidth - (this.framesize * 2), this.framesize);
        this.frame.drawRect(this.framesize, displayheight - this.framesize, displayWidth - (this.framesize * 2), this.framesize);
        this.controlLayer.addChild(this.frame);
        this.list.addExample("Sprite Basic", SpriteBasic_1.SpriteBasic);
        this.list.addExample("Sprite Reveal", AdvancedCard_1.AdvancedCard);
        this.list.addExample("Sprite Slots", AdvancedSlots_1.AdvancedSlots);
        this.list.addExample("Sprite Trail", AdvancedTrail_1.AdvancedTrail);
        this.list.addExample("Sprite Warp", AdvancedWarp_1.AdvancedWarp);
        this.list.addExample("Sprite Blend", BasicBlend_1.BasicBlend);
        this.list.addExample("Sprite Tinting", BasicTinting_1.BasicTinting);
        this.list.addExample("Sprite Video", SpriteVideo_1.SpriteVideo);
        this.list.addExample("Sprite Tiling", SpriteTiling_1.SpriteTiling);
        this.list.addExample("Sprite Animation", SpriteExplosion_1.SpriteExplosion);
        this.list.addExample("Sprite Animation 2", Spritejet_1.Spritejet);
        this.list.addExample("Sprite Animation 3", SpriteSpeed_1.SpriteSpeed);
        this.list.addExample("Graphics Basic", GraphicsSimple_1.GraphicsSimple);
        this.list.addExample("Graphics Advanced", GraphicsAdvanced_1.GraphicsAdvanced);
        this.list.addExample("Graphics Dynamic", GraphicsDynamic_1.GraphicsDynamic);
        this.list.addExample("Container", BasicContainer_1.BasicContainer);
        this.list.addExample("Mask Graphics", MaskGraphics_1.MaskGraphics);
        this.list.addExample("Mask Sprite", MaskSprite_1.MaskSprite);
        this.list.addExample("Particles", BasicParticles_1.BasicParticles);
        this.list.addExample("Text", TextBase_1.TextBase);
        this.list.addExample("Text Bitmap", TextBitmap_1.TextBitmap);
        this.list.addExample("Text WebFont", TextWebFont_1.TextWebFont);
        this.list.addExample("Interaction", InteractionInteractivity_1.InteractionInteractivity);
        this.list.addExample("Interaction Click", InteractionClick_1.InteractionClick);
        this.list.addExample("Interaction Drag", InteractionDragging_1.InteractionDragging);
        this.list.addExample("Interaction Icon", InteractionIcon_1.InteractionIcon);
        this.list.addExample("texture Swap", SpriteSwap_1.SpriteSwap);
        this.list.addExample("Texture Advanced", TextureAdvanced_1.TextureAdvanced);
        this.list.addExample("Texture Gradient", TextureGradientBasic_1.TextureGradientBasic);
        this.list.addExample("Texture Gradient 2", TextureGradientResource_1.TextureGradientResource);
        this.list.addExample("Texture Rotate", TextureRotate_1.TextureRotate);
        this.list.addExample("Texture Render", TextureRender_1.TextureRender);
        this.list.addExample("Filter Blur", FilterBlur_1.FilterBlur);
        this.list.addExample("Filter ColorMatrix", FilterColor_1.FilterColor);
        this.list.addExample("Filter Displacement", FilterCrawlies_1.FilterCrawlies);
        this.list.addExample("Filter Displacement 2", FilterFlag_1.FilterFlag);
        this.list.addExample("Filter Blur 2", MaskFilter_1.MaskFilter);
        this.list.addExample("Filter Blending", FilterBlending_1.FilterBlending);
        this.list.addExample("Filter Custom", FilterCustom_1.FilterCustom);
        this.list.addExample("Filter Shadow", FilterShadow_1.FilterShadow);
        this.list.addExample("Mesh Basic", MeshBasic_1.MeshBasic);
        this.list.addExample("Mesh Triangle", MeshTriangle_1.MeshTriangle);
        this.list.addExample("Mesh Triangle 2", MeshColoredTriangle_1.MeshColoredTriangle);
        this.list.addExample("Mesh Texture", MeshTextured_1.MeshTextured);
        this.list.addExample("Mesh Advanced", MeshAdvanced_1.MeshAdvanced);
        this.list.addExample("Mesh Uniforms", MeshUniforms_1.MeshUniforms);
        this.list.addExample("Mesh Geometry", MeshGeometry_1.MeshGeometry);
        this.list.addExample("Mesh Shader", MeshShader_1.MeshShader);
        InstanceCounter_1.InstanceCounter.enable();
        this.setExample(SpriteBasic_1.SpriteBasic);
    }
    setExample(keyclass) {
        this.list.removeEventListener(Event_1.Event.CHANGE, this.handleExampleRequest);
        if (this.currentExample) {
            this.currentExample.destructor();
        }
        this.currentExample = new keyclass(this.app, this.exampleWidth, this.exampleheight);
        this.currentExample.addEventListener(Event_1.Event.COMPLETE, this.handleComplete);
        this.stageLayer.removeChildren();
        this.stageLayer.addChild(this.currentExample.stage);
        this.refreshBackground(this.currentExample.backColor);
    }
    refreshBackground(color) {
        this.background.clear();
        this.background.beginFill(color);
        this.background.drawRect(0, 0, this.exampleWidth, this.exampleheight);
    }
}
exports.ExampleDisplay = ExampleDisplay;


/***/ }),

/***/ "./js-compile/examples/controls/ExampleList.js":
/*!*****************************************************!*\
  !*** ./js-compile/examples/controls/ExampleList.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Container_1 = __webpack_require__(/*! ../../raw-pixi-ts/Container */ "./js-compile/raw-pixi-ts/Container.js");
const Button_1 = __webpack_require__(/*! ../../fl-package/Button */ "./js-compile/fl-package/Button.js");
const Graphics_1 = __webpack_require__(/*! ../../raw-pixi-ts/Graphics */ "./js-compile/raw-pixi-ts/Graphics.js");
const MouseEvent_1 = __webpack_require__(/*! ../../raw-pixi-ts/MouseEvent */ "./js-compile/raw-pixi-ts/MouseEvent.js");
const Event_1 = __webpack_require__(/*! ../../raw-pixi-ts/Event */ "./js-compile/raw-pixi-ts/Event.js");
class ExampleList extends Container_1.Container {
    constructor(displayWidth, displayheight) {
        super();
        this.handleScrollChange = (event) => {
            this.listContainer.y = this.scroll.targetPosition;
        };
        this.handleButtonTap = (event) => {
            this._selectedClass = this.classReference[event.currentTarget.name];
            this.dispatchEvent(Event_1.Event.getEvent(Event_1.Event.CHANGE));
        };
        this.buttons = [];
        this.classReference = {};
        this.itemGap = 2;
        this.sideGap = 2;
        this.listContainer = new Container_1.Container();
        this.addChild(this.listContainer);
        this.listmask = new Graphics_1.Graphics();
        this.listmask.beginFill(0);
        this.listmask.drawRect(0, 0, displayWidth, displayheight);
        this.listContainer.mask = this.listmask;
        this.addChild(this.listmask);
        let gr = new Graphics_1.Graphics();
        gr.beginFill(0xAAA0AA);
        gr.drawRect(0, 0, 25, displayheight);
        this.addChild(gr);
        gr.x = displayWidth - 25;
        this.buttonWidth = displayWidth - 25 - (this.sideGap * 2);
        this.buttonheight = 40;
        this.scroll = new ScrollBar();
        this.addChild(this.scroll);
        this.scroll.x = displayWidth - 25;
        this.scroll.scrollArea = displayheight;
        this.scroll.addEventListener(Event_1.Event.CHANGE, this.handleScrollChange);
    }
    get selectedClass() {
        return this._selectedClass;
    }
    addExample(keyname, keyclass) {
        let button = new Button_1.Button(keyname, this.buttonWidth, this.buttonheight);
        button.addEventListener(MouseEvent_1.MouseEvent.POINTER_TAP, this.handleButtonTap);
        this.buttons.push(button);
        button.name = keyname;
        button.x = this.sideGap;
        this.listContainer.addChild(button);
        this.classReference[keyname] = keyclass;
        this.refreshList();
    }
    refreshList() {
        let start = this.itemGap;
        for (let button of this.buttons) {
            button.y = start;
            start += button.height + this.itemGap;
        }
        this.scroll.scrollDistance = start;
    }
}
exports.ExampleList = ExampleList;
class ScrollBar extends Container_1.Container {
    constructor() {
        super();
        this.handleHandleUp = (event) => {
            this.dragging = false;
            this.eventData = null;
        };
        this.handleHandleMove = (event) => {
            if (this.eventData) {
                const newPosition = this.eventData.getLocalPosition(this._handle.parent);
                this._handle.y = newPosition.y - (this._handle.height / 2);
                if (this._handle.y > this._scrollArea) {
                    this._handle.y = this._scrollArea;
                }
                else if (this._handle.y < 0) {
                    this._handle.y = 0;
                }
                this.areaPercent = this._handle.y / this._scrollArea;
                this._targetPosition = (this._scrollDistance - this._visibleArea) * this.areaPercent * -1;
                this.dispatchEvent(Event_1.Event.getEvent(Event_1.Event.CHANGE));
            }
        };
        this.handleHandleDown = (event) => {
            this.dragging = true;
            this.eventData = event.data;
        };
        this._handle = new Graphics_1.Graphics();
        this._handle.beginFill(0x636363);
        this._handle.drawRect(0, 0, 25, 25);
        this.addChild(this._handle);
        this._handle.buttonMode = this._handle.interactive = true;
        this._handle.addEventListener(MouseEvent_1.MouseEvent.POINTER_DOWN, this.handleHandleDown);
        this._handle.addEventListener(MouseEvent_1.MouseEvent.POINTER_UP, this.handleHandleUp);
        this._handle.addEventListener(MouseEvent_1.MouseEvent.POINTER_UP_OUTSIDE, this.handleHandleUp);
        this._handle.addEventListener(MouseEvent_1.MouseEvent.POINTER_MOVE, this.handleHandleMove);
    }
    get targetPosition() {
        return this._targetPosition;
    }
    set scrollDistance(value) {
        this._scrollDistance = value;
    }
    set scrollArea(value) {
        this._scrollArea = value - 25;
        this._visibleArea = value;
    }
}


/***/ }),

/***/ "./js-compile/fl-package/Button.js":
/*!*****************************************!*\
  !*** ./js-compile/fl-package/Button.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Container_1 = __webpack_require__(/*! ../raw-pixi-ts/Container */ "./js-compile/raw-pixi-ts/Container.js");
const Graphics_1 = __webpack_require__(/*! ../raw-pixi-ts/Graphics */ "./js-compile/raw-pixi-ts/Graphics.js");
const MouseEvent_1 = __webpack_require__(/*! ../raw-pixi-ts/MouseEvent */ "./js-compile/raw-pixi-ts/MouseEvent.js");
const Text_1 = __webpack_require__(/*! ../raw-pixi-ts/Text */ "./js-compile/raw-pixi-ts/Text.js");
const TextStyle_1 = __webpack_require__(/*! ../raw-pixi-ts/TextStyle */ "./js-compile/raw-pixi-ts/TextStyle.js");
class Button extends Container_1.Container {
    constructor(caption, buttonWidth = 150, buttonheight = 40) {
        super();
        this.handleOut = (event) => {
            this.buttongraphic.visible = true;
            this.buttonovergraphic.visible = false;
            this.buttondowngraphic.visible = false;
        };
        this.handleOver = (event) => {
            this.buttongraphic.visible = false;
            this.buttonovergraphic.visible = true;
            this.buttondowngraphic.visible = false;
        };
        this.handleUp = (event) => {
            this.buttongraphic.visible = true;
            this.buttonovergraphic.visible = false;
            this.buttondowngraphic.visible = false;
        };
        this.handleDown = (event) => {
            this.buttongraphic.visible = false;
            this.buttonovergraphic.visible = false;
            this.buttondowngraphic.visible = true;
        };
        this.interactive = true;
        this.buttongraphic = new Graphics_1.Graphics();
        this.buttongraphic.beginFill(0x969696);
        this.buttongraphic.drawRoundedRect(0, 0, buttonWidth, buttonheight, 10);
        this.addChild(this.buttongraphic);
        this.buttonovergraphic = new Graphics_1.Graphics();
        this.buttonovergraphic.beginFill(0xB9B9B9);
        this.buttonovergraphic.drawRoundedRect(0, 0, buttonWidth, buttonheight, 10);
        this.addChild(this.buttonovergraphic);
        this.buttonovergraphic.visible = false;
        this.buttondowngraphic = new Graphics_1.Graphics();
        this.buttondowngraphic.beginFill(0x636363);
        this.buttondowngraphic.drawRoundedRect(0, 0, buttonWidth, buttonheight, 10);
        this.addChild(this.buttondowngraphic);
        this.buttondowngraphic.visible = false;
        let style = new TextStyle_1.TextStyle({});
        style.fontSize = 16;
        style.align = "center";
        style.fontFamily = "Arial";
        this.label = new Text_1.Text(caption, style);
        this.label.interactive = false;
        this.label.y = (buttonheight - (this.label.height)) / 2;
        this.label.x = (buttonWidth / 2 - this.label.width / 2);
        this.addChild(this.label);
        this.addEventListener(MouseEvent_1.MouseEvent.POINTER_DOWN, this.handleDown);
        this.addEventListener(MouseEvent_1.MouseEvent.POINTER_OVER, this.handleOver);
        this.addEventListener(MouseEvent_1.MouseEvent.POINTER_UP, this.handleUp);
        this.addEventListener(MouseEvent_1.MouseEvent.POINTER_OUT, this.handleOut);
        this.addEventListener(MouseEvent_1.MouseEvent.POINTER_UP_OUTSIDE, this.handleOut);
    }
}
exports.Button = Button;


/***/ }),

/***/ "./js-compile/flash/geom/Point.js":
/*!****************************************!*\
  !*** ./js-compile/flash/geom/Point.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const FlashBaseObject_1 = __webpack_require__(/*! ../../raw-pixi-ts/FlashBaseObject */ "./js-compile/raw-pixi-ts/FlashBaseObject.js");
const InstanceCounter_1 = __webpack_require__(/*! ../../raw-pixi-ts/InstanceCounter */ "./js-compile/raw-pixi-ts/InstanceCounter.js");
class Point extends FlashBaseObject_1.FlashBaseObject {
    constructor(x = 0, y = 0) {
        super();
        this._x = x;
        this._y = y;
        InstanceCounter_1.InstanceCounter.count(this);
    }
    get length() {
        return Point.distance(Point.DEFAULT, this);
    }
    ;
    get x() {
        return this._x;
    }
    ;
    set x(value) {
        this._x = value;
    }
    ;
    get y() {
        return this._y;
    }
    ;
    set y(value) {
        this._y = value;
    }
    ;
    subtract(v) {
        let point = new Point();
        point.x = this._x - v.x;
        point.y = this._y - v.y;
        return point;
    }
    setTo(xa, ya) {
        this._x = xa;
        this._y = ya;
    }
    offset(dx, dy) {
        this._x += dx;
        this._y += dy;
    }
    normalize(thickness) {
        let norm = Math.sqrt(this._x * this._x + this._y * this._y);
        this._x = this._x / norm * thickness;
        this._y = this._y / norm * thickness;
    }
    add(v) {
        let point = new Point();
        point.x = v.x + this._x;
        point.y = v.y + this._y;
        return point;
    }
    set(x = 0, y = 0) {
        this._x = x;
        this._y = y;
    }
    ;
    equals(p) {
        return (p._x === this._x) && (p._y === this._y);
    }
    ;
    copyTo(p) {
        p.set(this._x, this._y);
        return p;
    }
    ;
    copyFrom(p) {
        this.set(p._x, p._y);
        return this;
    }
    ;
    clone() {
        return new Point(this._x, this._y);
    }
    ;
    reset(x = 0, y = 0) {
        this._x = x;
        this._y = y;
    }
    recycle() {
        InstanceCounter_1.InstanceCounter.recycleCount(this);
        let index = Point.cachedInstances.indexOf(this);
        if (index < 0) {
            Point.cachedInstances.unshift(this);
        }
    }
    destructor() {
        InstanceCounter_1.InstanceCounter.destructorCount(this);
    }
    static getPoint(x = 0, y = 0) {
        if (Point.cachedInstances.length) {
            let r = Point.cachedInstances[Point.cachedInstances.length - 1];
            Point.cachedInstances.length -= 1;
            r.reset(x, y);
            return r;
        }
        return new Point(x, y);
    }
    static polar(len, angle) {
        return new Point(len * Math.cos(angle), len * Math.sin(angle));
    }
    static interpolate(pt1, pt2, f) {
        if (f < 0 || f > 1) {
            return null;
        }
        let nx = pt1.x + (pt2.x - pt1.x) * f;
        let ny = pt1.y + (pt2.y - pt1.y) * f;
        return new Point(nx, ny);
    }
    static distance(pt1, pt2) {
        return Math.sqrt(((pt2.x - pt1.x) * (pt2.x - pt1.x)) + ((pt2.y - pt1.y) * (pt2.y - pt1.y)));
    }
    static get DEFAULT() {
        if (!Point._Rect) {
            Point._Rect = new Point();
        }
        Point._Rect.reset();
        return Point._Rect;
    }
}
Point.cachedInstances = [];
exports.Point = Point;


/***/ }),

/***/ "./js-compile/flash/geom/Rectangle.js":
/*!********************************************!*\
  !*** ./js-compile/flash/geom/Rectangle.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const ShapeSettings_1 = __webpack_require__(/*! ../../raw-pixi-ts/ShapeSettings */ "./js-compile/raw-pixi-ts/ShapeSettings.js");
const FlashBaseObject_1 = __webpack_require__(/*! ../../raw-pixi-ts/FlashBaseObject */ "./js-compile/raw-pixi-ts/FlashBaseObject.js");
const InstanceCounter_1 = __webpack_require__(/*! ../../raw-pixi-ts/InstanceCounter */ "./js-compile/raw-pixi-ts/InstanceCounter.js");
const Point_1 = __webpack_require__(/*! ./Point */ "./js-compile/flash/geom/Point.js");
class Rectangle extends FlashBaseObject_1.FlashBaseObject {
    constructor(x = 0, y = 0, width = 0, height = 0) {
        super();
        Rectangle.instanceCount++;
        this.reset(x, y, width, height);
        this.type = ShapeSettings_1.ShapeSettings.SHAPES.RECT;
        InstanceCounter_1.InstanceCounter.count(this);
    }
    get bottom() {
        return this._y + this._height;
    }
    ;
    set bottom(value) {
        this._y = value - this._height;
    }
    get bottomRight() {
        return new Point_1.Point(this._x + this._width, this._y + this._height);
    }
    set bottomRight(value) {
        this._x = value.x - this._width;
        this._y = value.y - this._height;
    }
    get height() {
        return this._height;
    }
    ;
    set height(value) {
        this._height = value;
    }
    ;
    get left() {
        return this._x;
    }
    set left(value) {
        this._x = value;
    }
    get right() {
        return this._x + this._width;
    }
    ;
    set right(value) {
        this._x = value - this._width;
    }
    get size() {
        return new Point_1.Point(this._width, this._height);
    }
    set size(value) {
        this._width = value.x;
        this._height = value.y;
    }
    get top() {
        return this._y;
    }
    ;
    set top(value) {
        this._y = value - this._height;
    }
    get topLeft() {
        return new Point_1.Point(this._x, this._y);
    }
    set topLeft(value) {
        this._x = value.x;
        this._y = value.y;
    }
    get width() {
        return this._width;
    }
    ;
    set width(value) {
        this._width = value;
    }
    ;
    get x() {
        return this._x;
    }
    ;
    set x(value) {
        this._x = value;
    }
    ;
    get y() {
        return this._y;
    }
    ;
    set y(value) {
        this._y = value;
    }
    ;
    clone() {
        return new Rectangle(this._x, this._y, this._width, this._height);
    }
    ;
    contains(x, y) {
        if (this._width <= 0 || this._height <= 0) {
            return false;
        }
        if (x >= this._x && x < this._x + this._width) {
            if (y >= this._y && y < this._y + this._height) {
                return true;
            }
        }
        return false;
    }
    ;
    containsPoint(point) {
        return this.contains(point.x, point.y);
    }
    containsRect(rect) {
        if (this.contains(rect.x, rect.y) && this.contains(rect.bottomRight.x, rect.bottomRight.y)) {
            return true;
        }
        return false;
    }
    copyFrom(rectangle) {
        this._x = rectangle._x;
        this._y = rectangle._y;
        this._width = rectangle._width;
        this._height = rectangle._height;
        return this;
    }
    ;
    equals(rect) {
        if (rect._x == this._x && rect._y == this._y && rect._width == this._width && rect._height == this._height) {
            return true;
        }
        return false;
    }
    inflate(dx, dy) {
        this._x -= dx;
        this._width += 2 * dx;
        this._y -= dy;
        this._height += 2 * dy;
    }
    pad(paddingX = 0, paddingY = 0) {
        this._x -= paddingX;
        this._y -= paddingY;
        this._width += paddingX * 2;
        this._height += paddingY * 2;
    }
    ;
    inflatePoint(point) {
        this.inflate(point.x, point.y);
    }
    intersection(toIntersect) {
        let x1 = Math.max(this._x, toIntersect._x);
        let x2 = Math.min(this._x + this._width, toIntersect._x + toIntersect._width);
        let y1 = Math.max(this._y, toIntersect._y);
        let y2 = Math.min(this._y + this._height, toIntersect._y + toIntersect._height);
        let rect = new Rectangle(x1, y1, x2, y2);
        return rect;
    }
    intersects(toIntersect) {
        return this.contains(toIntersect._x, toIntersect._y);
    }
    isEmpty() {
        if (this._width == 0 && this._height == 0) {
            return true;
        }
        return false;
    }
    offset(dx, dy) {
        this._x = dx;
        this._y = dy;
    }
    offsetPoint(point) {
        this.offset(point.x, point.y);
    }
    setEmpty() {
        this._x = this._y = this._width = this._height = 0;
    }
    copyTo(rectangle) {
        rectangle._x = this._x;
        rectangle._y = this._y;
        rectangle._width = this._width;
        rectangle._height = this._height;
        return rectangle;
    }
    ;
    setTo(xa, ya, widtha, heighta) {
        this.reset(xa, ya, widtha, heighta);
    }
    toString() {
        return "x: " + this._x + ", y: " + this._y + ", width: " + this._width + ", height: " + this._height;
    }
    union(toUnion) {
        let x1 = Math.min(this._x, toUnion._x);
        let x2 = Math.max(this._x + this._width, toUnion._x + toUnion._width);
        let y1 = Math.min(this._y, toUnion._y);
        let y2 = Math.max(this._y + this._height, toUnion._y + toUnion._height);
        let rect = new Rectangle(x1, y1, x2, y2);
        return rect;
    }
    fit(rectangle) {
        let x1 = Math.max(this._x, rectangle._x);
        let x2 = Math.min(this._x + this._width, rectangle._x + rectangle._width);
        let y1 = Math.max(this._y, rectangle._y);
        let y2 = Math.min(this._y + this._height, rectangle._y + rectangle._height);
        this._x = x1;
        this._width = Math.max(x2 - x1, 0);
        this._y = y1;
        this._height = Math.max(y2 - y1, 0);
    }
    ;
    ceil(resolution = 1, eps = 0.001) {
        let x2 = Math.ceil((this._x + this._width - eps) * resolution) / resolution;
        let y2 = Math.ceil((this._y + this._height - eps) * resolution) / resolution;
        this._x = Math.floor((this._x + eps) * resolution) / resolution;
        this._y = Math.floor((this._y + eps) * resolution) / resolution;
        this._width = x2 - this._x;
        this._height = y2 - this._y;
    }
    ;
    enlarge(rectangle) {
        let x1 = Math.min(this._x, rectangle._x);
        let x2 = Math.max(this._x + this._width, rectangle._x + rectangle._width);
        let y1 = Math.min(this._y, rectangle._y);
        let y2 = Math.max(this._y + this._height, rectangle._y + rectangle._height);
        this._x = x1;
        this._width = x2 - x1;
        this._y = y1;
        this._height = y2 - y1;
    }
    ;
    static getRectangle(x = 0, y = 0, width = 0, height = 0) {
        if (Rectangle.cachedInstances.length) {
            let r = Rectangle.cachedInstances[Rectangle.cachedInstances.length - 1];
            Rectangle.cachedInstances.length -= 1;
            r.reset(x, y, width, height);
            return r;
        }
        return new Rectangle(x, y, width, height);
    }
    static get DEFAULT() {
        if (!Rectangle._Rect) {
            Rectangle._Rect = new Rectangle();
        }
        Rectangle._Rect.reset();
        return Rectangle._Rect;
    }
    destructor() {
        InstanceCounter_1.InstanceCounter.destructorCount(this);
    }
    recycle() {
        InstanceCounter_1.InstanceCounter.recycleCount(this);
        let index = Rectangle.cachedInstances.indexOf(this);
        if (index < 0) {
            Rectangle.cachedInstances.unshift(this);
        }
    }
    reset(x = 0, y = 0, width = 0, height = 0) {
        this._x = Number(x);
        this._y = Number(y);
        this._width = Number(width);
        this._height = Number(height);
    }
}
Rectangle.cachedInstances = [];
Rectangle.instanceCount = 0;
exports.Rectangle = Rectangle;


/***/ }),

/***/ "./js-compile/flash/geom/Transform.js":
/*!********************************************!*\
  !*** ./js-compile/flash/geom/Transform.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Matrix_1 = __webpack_require__(/*! ../../raw-pixi-ts/Matrix */ "./js-compile/raw-pixi-ts/Matrix.js");
const ObservablePoint_1 = __webpack_require__(/*! ../../raw-pixi-ts/ObservablePoint */ "./js-compile/raw-pixi-ts/ObservablePoint.js");
const FlashBaseObject_1 = __webpack_require__(/*! ../../raw-pixi-ts/FlashBaseObject */ "./js-compile/raw-pixi-ts/FlashBaseObject.js");
class Transform extends FlashBaseObject_1.FlashBaseObject {
    constructor() {
        super();
        this.worldTransform = new Matrix_1.Matrix();
        this.localTransform = new Matrix_1.Matrix();
        this.position = new ObservablePoint_1.ObservablePoint(0, 0);
        this.position.scope = this;
        this.position.callback = this.onChange;
        this.scale = new ObservablePoint_1.ObservablePoint(1, 1);
        this.scale.scope = this;
        this.scale.callback = this.onChange;
        this.pivot = new ObservablePoint_1.ObservablePoint(0, 0);
        this.pivot.scope = this;
        this.pivot.callback = this.onChange;
        this.skew = new ObservablePoint_1.ObservablePoint(0, 0);
        this.skew.scope = this;
        this.skew.callback = this.updateSkew;
        this._rotation = 0;
        this._cx = 1;
        this._sx = 0;
        this._cy = 0;
        this._sy = 1;
        this._localID = 0;
        this._currentLocalID = 0;
        this._worldID = 0;
        this._parentID = 0;
    }
    get pixelBounds() {
        return null;
    }
    // public get matrix():Matrix
    // {
    // 	return null;
    // }
    // public set matrix(value:Matrix)
    // {
    // }
    // public get concatenatedMatrix():Matrix
    // {
    // 	return null;
    // }
    // public get concatenatedColorTransform():ColorTransform
    // {
    // 	return null;
    // }
    // public get colorTransform():ColorTransform
    // {
    // 	return null;
    // }
    // public set colorTransform(value:ColorTransform)
    // {
    // }
    get rotation() {
        return this._rotation;
    }
    ;
    set rotation(value) {
        if (this._rotation !== value) {
            this._rotation = value;
            this.updateSkew();
        }
    }
    ;
    setFromMatrix(matrix) {
        matrix.decompose(this);
        this._localID++;
    }
    ;
    updateTransform(parentTransform) {
        let lt = this.localTransform;
        if (this._localID !== this._currentLocalID) {
            lt.a = this._cx * this.scale.x;
            lt.b = this._sx * this.scale.x;
            lt.c = this._cy * this.scale.y;
            lt.d = this._sy * this.scale.y;
            lt.tx = this.position.x - ((this.pivot.x * lt.a) + (this.pivot.y * lt.c));
            lt.ty = this.position.y - ((this.pivot.x * lt.b) + (this.pivot.y * lt.d));
            this._currentLocalID = this._localID;
            this._parentID = -1;
        }
        if (this._parentID !== parentTransform._worldID) {
            let pt = parentTransform.worldTransform;
            let wt = this.worldTransform;
            wt.a = (lt.a * pt.a) + (lt.b * pt.c);
            wt.b = (lt.a * pt.b) + (lt.b * pt.d);
            wt.c = (lt.c * pt.a) + (lt.d * pt.c);
            wt.d = (lt.c * pt.b) + (lt.d * pt.d);
            wt.tx = (lt.tx * pt.a) + (lt.ty * pt.c) + pt.tx;
            wt.ty = (lt.tx * pt.b) + (lt.ty * pt.d) + pt.ty;
            this._parentID = parentTransform._worldID;
            this._worldID++;
        }
    }
    ;
    onChange() {
        this._localID++;
    }
    ;
    updateSkew() {
        this._cx = Math.cos(this._rotation + this.skew.y);
        this._sx = Math.sin(this._rotation + this.skew.y);
        this._cy = -Math.sin(this._rotation - this.skew.x);
        this._sy = Math.cos(this._rotation - this.skew.x);
        this._localID++;
    }
    ;
    updateLocalTransform() {
        let lt = this.localTransform;
        if (this._localID !== this._currentLocalID) {
            lt.a = this._cx * this.scale.x;
            lt.b = this._sx * this.scale.x;
            lt.c = this._cy * this.scale.y;
            lt.d = this._sy * this.scale.y;
            lt.tx = this.position.x - ((this.pivot.x * lt.a) + (this.pivot.y * lt.c));
            lt.ty = this.position.y - ((this.pivot.x * lt.b) + (this.pivot.y * lt.d));
            this._currentLocalID = this._localID;
            this._parentID = -1;
        }
    }
    ;
    get worldID() {
        return this._worldID;
    }
    set parentID(value) {
        this._parentID = value;
    }
}
exports.Transform = Transform;


/***/ }),

/***/ "./js-compile/index.js":
/*!*****************************!*\
  !*** ./js-compile/index.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Application_1 = __webpack_require__(/*! ./raw-pixi-ts/Application */ "./js-compile/raw-pixi-ts/Application.js");
const StageOptions_1 = __webpack_require__(/*! ./raw-pixi-ts/StageOptions */ "./js-compile/raw-pixi-ts/StageOptions.js");
const ExampleDisplay_1 = __webpack_require__(/*! ./examples/controls/ExampleDisplay */ "./js-compile/examples/controls/ExampleDisplay.js");
window.addEventListener("load", () => {
    var options = new StageOptions_1.StageOptions();
    options.width = 1000;
    options.height = 600;
    options.autoResize = false;
    options.backgroundColor = 0x00000000;
    options.clearBeforeRender = true;
    options.resolution = 1;
    options.autoStart = true;
    options.transparent = true;
    options.antialias = true;
    options.view = document.getElementById("fakecanvas");
    var app = new Application_1.Application(options);
    let display = new ExampleDisplay_1.ExampleDisplay(app, 1024, 768);
    app.stage.addChild(display);
    // create a view class with frame
    // create a control class with buttons
    // each button click change content of class frame
    // let button:Button = new Button("Test", 200, 40);
    // app.stage.addChild(button);
    // button.x = 800;
    // let example:BasicCache = new BasicCache(app); NOT WORKING
    // let example:InteractionIcon = new InteractionIcon(app);
    // let example:SpriteVideo = new SpriteVideo(app);
    // let example:AdvancedSlots = new AdvancedSlots(app); 
    // let example:TextureRotate = new TextureRotate(app); 
    // let example:BasicContainer = new BasicContainer(app);
    // let example:BasicBackground = new BasicBackground(app);
    // let example:BasicTinting = new BasicTinting(app);    
    // let example:BasicParticles = new BasicParticles(app);
    // let example:BasicBlend = new BasicBlend(app);    
    // let example:GraphicsSimple = new GraphicsSimple(app);
    // let example:GraphicsAdvanced = new GraphicsAdvanced(app);
    // let example:GraphicsDynamic = new GraphicsDynamic(app);
    // let example:TextureRender = new TextureRender(app);
    // let example:TextureAdvanced = new TextureAdvanced(app);
    // let example:TextureGradientBasic = new TextureGradientBasic(app);
    // let example:TextureGradientResource = new TextureGradientResource(app);
    // let example:TextBase = new TextBase(app);
    // let example:TextBitmap = new TextBitmap(app); 
    // let example:TextWebFont = new TextWebFont(app); 
    // let example:MaskGraphics = new MaskGraphics(app);
    // let example:MaskSprite = new MaskSprite(app);
    // let example:FilterBlur = new FilterBlur(app);
    // let example:FilterColor = new FilterColor(app);
    // let example:FilterCrawlies = new FilterCrawlies(app);
    // let example:FilterFlag = new FilterFlag(app);
    // let example:MaskFilter = new MaskFilter(app);
    // let example:InteractionClick = new InteractionClick(app);
    // let example:InteractionInteractivity = new InteractionInteractivity(app);
    // let example:InteractionDragging = new InteractionDragging(app); 
    // let example:SpriteBasic = new SpriteBasic(app);  
    // let example:SpriteSwap = new SpriteSwap(app);    
    // let example:SpriteTiling = new SpriteTiling(app);    
    // let example:SpriteExplosion = new SpriteExplosion(app);
    // let example:Spritejet = new Spritejet(app); 
    // let example:SpriteSpeed = new SpriteSpeed(app); 
    // let example:AdvancedCard = new AdvancedCard(app); 
    // let example:AdvancedTrail = new AdvancedTrail(app); 
    // let example:AdvancedWarp = new AdvancedWarp(app); 
    // let example:FilterBlending = new FilterBlending(app); 
    // let example:FilterCustom = new FilterCustom(app); 
    // let example:FilterShadow = new FilterShadow(app); 
    // let example:MeshBasic = new MeshBasic(app);
    // let example:MeshAdvanced = new MeshAdvanced(app);
    // let example:MeshTriangle = new MeshTriangle(app);
    // let example:MeshColoredTriangle = new MeshColoredTriangle(app);
    // let example:MeshTextured = new MeshTextured(app);
    // let example:MeshUniforms = new MeshUniforms(app);
    // let example:MeshGeometry = new MeshGeometry(app);
    // let example:MeshShader = new MeshShader(app);
});


/***/ }),

/***/ "./js-compile/raw-pixi-ts/AbstractRenderer.js":
/*!****************************************************!*\
  !*** ./js-compile/raw-pixi-ts/AbstractRenderer.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const EventDispatcher_1 = __webpack_require__(/*! ./EventDispatcher */ "./js-compile/raw-pixi-ts/EventDispatcher.js");
const Matrix_1 = __webpack_require__(/*! ./Matrix */ "./js-compile/raw-pixi-ts/Matrix.js");
const Rectangle_1 = __webpack_require__(/*! ../flash/geom/Rectangle */ "./js-compile/flash/geom/Rectangle.js");
const RenderTexture_1 = __webpack_require__(/*! ./RenderTexture */ "./js-compile/raw-pixi-ts/RenderTexture.js");
const Container_1 = __webpack_require__(/*! ./Container */ "./js-compile/raw-pixi-ts/Container.js");
const DisplaySettings_1 = __webpack_require__(/*! ./DisplaySettings */ "./js-compile/raw-pixi-ts/DisplaySettings.js");
const MathSettings_1 = __webpack_require__(/*! ./MathSettings */ "./js-compile/raw-pixi-ts/MathSettings.js");
const ColorSettings_1 = __webpack_require__(/*! ./ColorSettings */ "./js-compile/raw-pixi-ts/ColorSettings.js");
const InstanceCounter_1 = __webpack_require__(/*! ./InstanceCounter */ "./js-compile/raw-pixi-ts/InstanceCounter.js");
class AbstractRenderer extends EventDispatcher_1.EventDispatcher {
    constructor(system, options) {
        super();
        if (options.roundPixels) {
            DisplaySettings_1.DisplaySettings.ROUND_PIXELS = options.roundPixels;
        }
        this.options = options;
        this.type = DisplaySettings_1.DisplaySettings.RENDERER_TYPE.UNKNOWN;
        InstanceCounter_1.InstanceCounter.addCall("Rectangle.getRectangle", "AbstractRenderer");
        this.screen = Rectangle_1.Rectangle.getRectangle(0, 0, options.width, options.height);
        this.view = options.view || document.createElement('canvas');
        this.resolution = options.resolution || DisplaySettings_1.DisplaySettings.RESOLUTION;
        this.transparent = options.transparent;
        this.autoDensity = options.autoDensity || options.autoResize || false;
        this.preserveDrawingBuffer = options.preserveDrawingBuffer;
        this.clearBeforeRender = options.clearBeforeRender;
        this._backgroundColor = 0x000000;
        this._backgroundColorRgba = [0, 0, 0, 0];
        this._backgroundColorString = '#000000';
        this.backgroundColor = options.backgroundColor || this._backgroundColor;
        this._tempDisplayObjectParent = new Container_1.Container();
        this._lastObjectRendered = this._tempDisplayObjectParent;
        this.blendModes = 0;
    }
    resize(screenWidth, screenHeight) {
        this.screen.width = screenWidth;
        this.screen.height = screenHeight;
        this.view.width = screenWidth * this.resolution;
        this.view.height = screenHeight * this.resolution;
        if (this.autoDensity) {
            this.view.style.width = screenWidth + "px";
            this.view.style.height = screenHeight + "px";
        }
    }
    ;
    get width() {
        return this.view.width;
    }
    ;
    get height() {
        return this.view.height;
    }
    ;
    generateTexture(displayObject, scaleMode, resolution, region) {
        region = region || displayObject.getLocalBounds();
        if (region.width === 0) {
            region.width = 1;
        }
        if (region.height === 0) {
            region.height = 1;
        }
        var renderTexture = RenderTexture_1.RenderTexture.create(region.width | 0, region.height | 0, scaleMode, resolution);
        AbstractRenderer.tempMatrix.tx = -region.x;
        AbstractRenderer.tempMatrix.ty = -region.y;
        this.render(displayObject, renderTexture, false, AbstractRenderer.tempMatrix, !!displayObject.parent);
        return renderTexture;
    }
    ;
    render(displayObject, renderTexture, b, m, parent) {
    }
    /**
     * Removes everything from the renderer and optionally removes the Canvas DOM element.
     *
     * @param {boolean} [removeView=false] - Removes the Canvas element from the DOM.
     */
    destroy(removeView) {
        // for (var o in this.plugins)
        // {
        //     this.plugins[o].destroy();
        //     this.plugins[o] = null;
        // }
        if (removeView && this.view.parentNode) {
            this.view.parentNode.removeChild(this.view);
        }
        // this.plugins = null;
        this.type = DisplaySettings_1.DisplaySettings.RENDERER_TYPE.UNKNOWN;
        this.view = null;
        this.screen = null;
        this.resolution = 0;
        this.transparent = false;
        this.autoDensity = false;
        this.blendModes = null;
        this.options = null;
        this.preserveDrawingBuffer = false;
        this.clearBeforeRender = false;
        this._backgroundColor = 0;
        this._backgroundColorRgba = null;
        this._backgroundColorString = null;
        this._tempDisplayObjectParent = null;
        this._lastObjectRendered = null;
    }
    ;
    /**
     * The background color to fill if not transparent
     *
     * @member {number}
     */
    get backgroundColor() {
        return this._backgroundColor;
    }
    ;
    set backgroundColor(value) {
        this._backgroundColor = value;
        this._backgroundColorString = MathSettings_1.MathSettings.hex2string(value);
        ColorSettings_1.ColorSettings.hex2rgb(value, this._backgroundColorRgba);
    }
    ;
}
AbstractRenderer.tempMatrix = new Matrix_1.Matrix();
exports.AbstractRenderer = AbstractRenderer;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/AccessibilityManager.js":
/*!********************************************************!*\
  !*** ./js-compile/raw-pixi-ts/AccessibilityManager.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
// import { settings } from './settings';
const UtilsSettings_1 = __webpack_require__(/*! ./UtilsSettings */ "./js-compile/raw-pixi-ts/UtilsSettings.js");
class AccessibilityManager {
    constructor(renderer) {
        /**
                 * @type {?HTMLElement}
                 * @private
                 */
        this._hookDiv = null;
        // if (settings.isMobile_min.tablet || settings.isMobile_min.phone)
        // {
        this.createTouchHook();
        // }
        // first we create a div that will sit over the PixiJS element. This is where the div overlays will go.
        var div = document.createElement('div');
        div.style.width = AccessibilityManager.DIV_TOUCH_SIZE + "px";
        div.style.height = AccessibilityManager.DIV_TOUCH_SIZE + "px";
        div.style.position = 'absolute';
        div.style.top = AccessibilityManager.DIV_TOUCH_POS_X + "px";
        div.style.left = AccessibilityManager.DIV_TOUCH_POS_Y + "px";
        div.style.zIndex = AccessibilityManager.DIV_TOUCH_ZINDEX.toString();
        /**
         * This is the dom element that will sit over the PixiJS element. This is where the div overlays will go.
         *
         * @type {HTMLElement}
         * @private
         */
        this.div = div;
        /**
         * A simple pool for storing divs.
         *
         * @type {*}
         * @private
         */
        this.pool = [];
        /**
         * This is a tick used to check if an object is no longer being rendered.
         *
         * @type {Number}
         * @private
         */
        this.renderId = 0;
        /**
         * Setting this to true will visually show the divs.
         *
         * @type {boolean}
         */
        this.debug = false;
        /**
         * The renderer this accessibility manager works for.
         *
         * @member {PIXI.AbstractRenderer}
         */
        this.renderer = renderer;
        /**
         * The array of currently active accessible items.
         *
         * @member {Array<*>}
         * @private
         */
        this.children = [];
        /**
         * pre-bind the functions
         *
         * @type {Function}
         * @private
         */
        this._onKeyDown = this._onKeyDown.bind(this);
        /**
         * pre-bind the functions
         *
         * @type {Function}
         * @private
         */
        this._onMouseMove = this._onMouseMove.bind(this);
        /**
         * A flag
         * @type {boolean}
         * @readonly
         */
        this.isActive = false;
        /**
         * A flag
         * @type {boolean}
         * @readonly
         */
        this.isMobileAccessibility = false;
        // let listen for tab.. once pressed we can fire up and show the accessibility layer
        window.addEventListener('keydown', this._onKeyDown, false);
    }
    /**
     * Creates the touch hooks.
     *
     * @private
     */
    createTouchHook() {
        var this$1 = this;
        var hookDiv = document.createElement('button');
        hookDiv.style.width = AccessibilityManager.DIV_HOOK_SIZE + "px";
        hookDiv.style.height = AccessibilityManager.DIV_HOOK_SIZE + "px";
        hookDiv.style.position = 'absolute';
        hookDiv.style.top = AccessibilityManager.DIV_HOOK_POS_X + "px";
        hookDiv.style.left = AccessibilityManager.DIV_HOOK_POS_Y + "px";
        hookDiv.style.zIndex = AccessibilityManager.DIV_HOOK_ZINDEX.toString();
        hookDiv.style.backgroundColor = '#FF0000';
        hookDiv.title = 'HOOK DIV';
        hookDiv.addEventListener('focus', function () {
            this$1.isMobileAccessibility = true;
            this$1.activate();
            this$1.destroyTouchHook();
        });
        document.body.appendChild(hookDiv);
        this._hookDiv = hookDiv;
    }
    ;
    /**
     * Destroys the touch hooks.
     *
     * @private
     */
    destroyTouchHook() {
        if (!this._hookDiv) {
            return;
        }
        document.body.removeChild(this._hookDiv);
        this._hookDiv = null;
    }
    ;
    /**
     * Activating will cause the Accessibility layer to be shown.
     * This is called when a user presses the tab key.
     *
     * @private
     */
    activate() {
        if (this.isActive) {
            return;
        }
        this.isActive = true;
        window.document.addEventListener('mousemove', this._onMouseMove, true);
        window.removeEventListener('keydown', this._onKeyDown, false);
        this.renderer.on('postrender', this.update, this);
        if (this.renderer.view.parentNode) {
            this.renderer.view.parentNode.appendChild(this.div);
        }
    }
    ;
    /**
     * Deactivating will cause the Accessibility layer to be hidden.
     * This is called when a user moves the mouse.
     *
     * @private
     */
    deactivate() {
        if (!this.isActive || this.isMobileAccessibility) {
            return;
        }
        this.isActive = false;
        window.document.removeEventListener('mousemove', this._onMouseMove, true);
        window.addEventListener('keydown', this._onKeyDown, false);
        this.renderer.off('postrender', this.update);
        if (this.div.parentNode) {
            this.div.parentNode.removeChild(this.div);
        }
    }
    ;
    /**
     * This recursive function will run through the scene graph and add any new accessible objects to the DOM layer.
     *
     * @private
     * @param {PIXI.Container} displayObject - The DisplayObject to check.
     */
    updateAccessibleObjects(displayObject) {
        if (!displayObject.visible) {
            return;
        }
        if (displayObject.accessible && displayObject.interactive) {
            if (!displayObject._accessibleActive) {
                this.addChild(displayObject);
            }
            displayObject.renderId = this.renderId;
        }
        var children = displayObject.children;
        for (var i = 0; i < children.length; i++) {
            this.updateAccessibleObjects(children[i]);
        }
    }
    ;
    /**
     * Before each render this function will ensure that all divs are mapped correctly to their DisplayObjects.
     *
     * @private
     */
    update() {
        if (!this.renderer.renderingToScreen) {
            return;
        }
        // update children...
        this.updateAccessibleObjects(this.renderer._lastObjectRendered);
        var rect = this.renderer.view.getBoundingClientRect();
        var sx = rect.width / this.renderer.width;
        var sy = rect.height / this.renderer.height;
        var div = this.div;
        div.style.left = (rect.left) + "px";
        div.style.top = (rect.top) + "px";
        div.style.width = (this.renderer.width) + "px";
        div.style.height = (this.renderer.height) + "px";
        for (var i = 0; i < this.children.length; i++) {
            var child = this.children[i];
            if (child.renderId !== this.renderId) {
                child._accessibleActive = false;
                UtilsSettings_1.UtilsSettings.removeItems(this.children, i, 1);
                this.div.removeChild(child._accessibleDiv);
                this.pool.push(child._accessibleDiv);
                child._accessibleDiv = null;
                i--;
                if (this.children.length === 0) {
                    this.deactivate();
                }
            }
            else {
                // map div to display..
                div = child._accessibleDiv;
                var hitArea = child.hitArea;
                var wt = child.worldTransform;
                if (child.hitArea) {
                    div.style.left = ((wt.tx + (hitArea.x * wt.a)) * sx) + "px";
                    div.style.top = ((wt.ty + (hitArea.y * wt.d)) * sy) + "px";
                    div.style.width = (hitArea.width * wt.a * sx) + "px";
                    div.style.height = (hitArea.height * wt.d * sy) + "px";
                }
                else {
                    hitArea = child.getBounds();
                    this.capHitArea(hitArea);
                    div.style.left = (hitArea.x * sx) + "px";
                    div.style.top = (hitArea.y * sy) + "px";
                    div.style.width = (hitArea.width * sx) + "px";
                    div.style.height = (hitArea.height * sy) + "px";
                    // update button titles and hints if they exist and they've changed
                    if (div.title !== child.accessibleTitle && child.accessibleTitle !== null) {
                        div.title = child.accessibleTitle;
                    }
                    if (div.getAttribute('aria-label') !== child.accessibleHint
                        && child.accessibleHint !== null) {
                        div.setAttribute('aria-label', child.accessibleHint);
                    }
                }
            }
        }
        // increment the render id..
        this.renderId++;
    }
    ;
    /**
     * Adjust the hit area based on the bounds of a display object
     *
     * @param {Rectangle} hitArea - Bounds of the child
     */
    capHitArea(hitArea) {
        if (hitArea.x < 0) {
            hitArea.width += hitArea.x;
            hitArea.x = 0;
        }
        if (hitArea.y < 0) {
            hitArea.height += hitArea.y;
            hitArea.y = 0;
        }
        if (hitArea.x + hitArea.width > this.renderer.width) {
            hitArea.width = this.renderer.width - hitArea.x;
        }
        if (hitArea.y + hitArea.height > this.renderer.height) {
            hitArea.height = this.renderer.height - hitArea.y;
        }
    }
    ;
    /**
     * Adds a DisplayObject to the accessibility manager
     *
     * @private
     * @param {DisplayObject} displayObject - The child to make accessible.
     */
    addChild(displayObject) {
        //this.activate();
        var div = this.pool.pop();
        if (!div) {
            div = document.createElement('button');
            div.style.width = AccessibilityManager.DIV_TOUCH_SIZE + "px";
            div.style.height = AccessibilityManager.DIV_TOUCH_SIZE + "px";
            div.style.backgroundColor = this.debug ? 'rgba(255,0,0,0.5)' : 'transparent';
            div.style.position = 'absolute';
            div.style.zIndex = AccessibilityManager.DIV_TOUCH_ZINDEX;
            div.style.borderStyle = 'none';
            // ARIA attributes ensure that button title and hint updates are announced properly
            if (navigator.userAgent.toLowerCase().indexOf('chrome') > -1) {
                // Chrome doesn't need aria-live to work as intended; in fact it just gets more confused.
                div.setAttribute('aria-live', 'off');
            }
            else {
                div.setAttribute('aria-live', 'polite');
            }
            if (navigator.userAgent.match(/rv:.*Gecko\//)) {
                // FireFox needs this to announce only the new button name
                div.setAttribute('aria-relevant', 'additions');
            }
            else {
                // required by IE, other browsers don't much care
                div.setAttribute('aria-relevant', 'text');
            }
            div.addEventListener('click', this._onClick.bind(this));
            div.addEventListener('focus', this._onFocus.bind(this));
            div.addEventListener('focusout', this._onFocusOut.bind(this));
        }
        if (displayObject.accessibleTitle && displayObject.accessibleTitle !== null) {
            div.title = displayObject.accessibleTitle;
        }
        else if (!displayObject.accessibleHint
            || displayObject.accessibleHint === null) {
            div.title = "displayObject " + (displayObject.tabIndex);
        }
        if (displayObject.accessibleHint
            && displayObject.accessibleHint !== null) {
            div.setAttribute('aria-label', displayObject.accessibleHint);
        }
        //
        displayObject._accessibleActive = true;
        displayObject._accessibleDiv = div;
        div.displayObject = displayObject;
        this.children.push(displayObject);
        this.div.appendChild(displayObject._accessibleDiv);
        displayObject._accessibleDiv.tabIndex = displayObject.tabIndex;
    }
    ;
    /**
     * Maps the div button press to pixi's  (click)
     *
     * @private
     * @param {MouseEvent} e - The click event.
     */
    _onClick(e) {
        var interactionManager = this.renderer.plugins.interaction;
        interactionManager.dispatchEvent(e.target.displayObject, 'click', interactionManager.eventData);
    }
    ;
    /**
     * Maps the div focus events to pixi's  (mouseover)
     *
     * @private
     * @param {FocusEvent} e - The focus event.
     */
    _onFocus(e) {
        if (!e.target.getAttribute('aria-live', 'off')) {
            e.target.setAttribute('aria-live', 'assertive');
        }
        var interactionManager = this.renderer.plugins.interaction;
        interactionManager.dispatchEvent(e.target.displayObject, 'mouseover', interactionManager.eventData);
    }
    ;
    /**
     * Maps the div focus events to pixi's  (mouseout)
     *
     * @private
     * @param {FocusEvent} e - The focusout event.
     */
    _onFocusOut(e) {
        if (!e.target.getAttribute('aria-live', 'off')) {
            e.target.setAttribute('aria-live', 'polite');
        }
        var interactionManager = this.renderer.plugins.interaction;
        interactionManager.dispatchEvent(e.target.displayObject, 'mouseout', interactionManager.eventData);
    }
    ;
    /**
     * Is called when a key is pressed
     *
     * @private
     * @param {KeyboardEvent} e - The keydown event.
     */
    _onKeyDown(e) {
        if (e.keyCode !== AccessibilityManager.KEY_CODE_TAB) {
            return;
        }
        this.activate();
    }
    ;
    /**
     * Is called when the mouse moves across the renderer element
     *
     * @private
     * @param {MouseEvent} e - The mouse event.
     */
    _onMouseMove(e) {
        if (e.movementX === 0 && e.movementY === 0) {
            return;
        }
        this.deactivate();
    }
    ;
    /**
     * Destroys the accessibility manager
     *
     */
    destroy() {
        this.destroyTouchHook();
        this.div = null;
        for (var i = 0; i < this.children.length; i++) {
            this.children[i].div = null;
        }
        window.document.removeEventListener('mousemove', this._onMouseMove, true);
        window.removeEventListener('keydown', this._onKeyDown);
        this.pool = null;
        this.children = null;
        this.renderer = null;
    }
    ;
}
AccessibilityManager.DIV_HOOK_SIZE = 1;
AccessibilityManager.DIV_HOOK_POS_X = -1000;
AccessibilityManager.DIV_HOOK_POS_Y = -1000;
AccessibilityManager.DIV_HOOK_ZINDEX = 2;
AccessibilityManager.KEY_CODE_TAB = 9;
AccessibilityManager.DIV_TOUCH_SIZE = 100;
AccessibilityManager.DIV_TOUCH_POS_X = 0;
AccessibilityManager.DIV_TOUCH_POS_Y = 0;
AccessibilityManager.DIV_TOUCH_ZINDEX = 2;
exports.AccessibilityManager = AccessibilityManager;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/AnimatedSprite.js":
/*!**************************************************!*\
  !*** ./js-compile/raw-pixi-ts/AnimatedSprite.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Sprite_1 = __webpack_require__(/*! ./Sprite */ "./js-compile/raw-pixi-ts/Sprite.js");
const Texture_1 = __webpack_require__(/*! ./Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const Ticker_1 = __webpack_require__(/*! ./Ticker */ "./js-compile/raw-pixi-ts/Ticker.js");
class AnimatedSprite extends Sprite_1.Sprite {
    constructor(textures, autoUpdate = true) {
        super(textures[0] instanceof Texture_1.Texture ? textures[0] : textures[0].texture);
        /**
         * @type {PIXI.Texture[]}
         * @private
         */
        this._textures = null;
        /**
         * @type {number[]}
         * @private
         */
        this._durations = null;
        this.textures = textures;
        /**
         * `true` uses PIXI.Ticker.shared to auto update animation time.
         * @type {boolean}
         * @default true
         * @private
         */
        this._autoUpdate = autoUpdate !== false;
        /**
         * The speed that the AnimatedSprite will play at. Higher is faster, lower is slower.
         *
         * @member {number}
         * @default 1
         */
        this.animationSpeed = 1;
        /**
         * Whether or not the animate sprite repeats after playing.
         *
         * @member {boolean}
         * @default true
         */
        this.loop = true;
        /**
         * Update anchor to [Texture's defaultAnchor]{@link PIXI.Texture#defaultAnchor} when frame changes.
         *
         * Useful with [sprite sheet animations]{@link PIXI.Spritesheet#animations} created with tools.
         * Changing anchor for each frame allows to pin sprite origin to certain moving feature
         * of the frame (e.g. left foot).
         *
         * Note: Enabling this will override any previously set `anchor` on each frame change.
         *
         * @member {boolean}
         * @default false
         */
        this.updateAnchor = false;
        /**
         * Function to call when a AnimatedSprite finishes playing.
         *
         * @member {Function}
         */
        this.onComplete = null;
        /**
         * Function to call when a AnimatedSprite changes which texture is being rendered.
         *
         * @member {Function}
         */
        this.onFrameChange = null;
        /**
         * Function to call when `loop` is true, and an AnimatedSprite is played and loops around to start again.
         *
         * @member {Function}
         */
        this.onLoop = null;
        /**
         * Elapsed time since animation has been started, used internally to display current texture.
         *
         * @member {number}
         * @private
         */
        this._currentTime = 0;
        /**
         * Indicates if the AnimatedSprite is currently playing.
         *
         * @member {boolean}
         * @readonly
         */
        this.playing = false;
    }
    /**
     * Stops the AnimatedSprite.
     *
     */
    stop() {
        if (!this.playing) {
            return;
        }
        this.playing = false;
        if (this._autoUpdate) {
            Ticker_1.Ticker.shared.remove(this.update, this);
        }
    }
    ;
    /**
     * Plays the AnimatedSprite.
     *
     */
    play() {
        if (this.playing) {
            return;
        }
        this.playing = true;
        if (this._autoUpdate) {
            Ticker_1.Ticker.shared.add(this.update, this, Ticker_1.Ticker.UPDATE_PRIORITY.HIGH);
        }
    }
    ;
    /**
     * Stops the AnimatedSprite and goes to a specific frame.
     *
     * @param {number} frameNumber - Frame index to stop at.
     */
    gotoAndStop(frameNumber) {
        this.stop();
        var previousFrame = this.currentFrame;
        this._currentTime = frameNumber;
        if (previousFrame !== this.currentFrame) {
            this.updateTexture();
        }
    }
    ;
    /**
     * Goes to a specific frame and begins playing the AnimatedSprite.
     *
     * @param {number} frameNumber - Frame index to start at.
     */
    gotoAndPlay(frameNumber) {
        var previousFrame = this.currentFrame;
        this._currentTime = frameNumber;
        if (previousFrame !== this.currentFrame) {
            this.updateTexture();
        }
        this.play();
    }
    ;
    /**
     * Updates the object transform for rendering.
     *
     * @private
     * @param {number} deltaTime - Time since last tick.
     */
    update(deltaTime) {
        var elapsed = this.animationSpeed * deltaTime;
        var previousFrame = this.currentFrame;
        if (this._durations !== null) {
            var lag = this._currentTime % 1 * this._durations[this.currentFrame];
            lag += elapsed / 60 * 1000;
            while (lag < 0) {
                this._currentTime--;
                lag += this._durations[this.currentFrame];
            }
            var sign = Math.sign(this.animationSpeed * deltaTime);
            this._currentTime = Math.floor(this._currentTime);
            while (lag >= this._durations[this.currentFrame]) {
                lag -= this._durations[this.currentFrame] * sign;
                this._currentTime += sign;
            }
            this._currentTime += lag / this._durations[this.currentFrame];
        }
        else {
            this._currentTime += elapsed;
        }
        if (this._currentTime < 0 && !this.loop) {
            this.gotoAndStop(0);
            if (this.onComplete) {
                this.onComplete();
            }
        }
        else if (this._currentTime >= this._textures.length && !this.loop) {
            this.gotoAndStop(this._textures.length - 1);
            if (this.onComplete) {
                this.onComplete();
            }
        }
        else if (previousFrame !== this.currentFrame) {
            if (this.loop && this.onLoop) {
                if (this.animationSpeed > 0 && this.currentFrame < previousFrame) {
                    this.onLoop();
                }
                else if (this.animationSpeed < 0 && this.currentFrame > previousFrame) {
                    this.onLoop();
                }
            }
            this.updateTexture();
        }
    }
    ;
    /**
     * Updates the displayed texture to match the current frame index.
     *
     * @private
     */
    updateTexture() {
        this._texture = this._textures[this.currentFrame];
        this._textureID = -1;
        this._textureTrimmedID = -1;
        this.cachedTint = 0xFFFFFF;
        this.uvs = this._texture._uvs.uvsFloat32;
        if (this.updateAnchor) {
            this._anchor.copyFrom(this._texture.defaultAnchor);
        }
        if (this.onFrameChange) {
            this.onFrameChange(this.currentFrame);
        }
    }
    ;
    /**
     * Stops the AnimatedSprite and destroys it.
     *
     * @param {object|boolean} [options] - Options parameter. A boolean will act as if all options
     *  have been set to that value.
     * @param {boolean} [options.children=false] - If set to true, all the children will have their destroy
     *      method called as well. 'options' will be passed on to those calls.
     * @param {boolean} [options.texture=false] - Should it destroy the current texture of the sprite as well.
     * @param {boolean} [options.baseTexture=false] - Should it destroy the base texture of the sprite as well.
     */
    destroy(options) {
        this.stop();
        Sprite_1.Sprite.prototype.destroy.call(this, options);
        this.onComplete = null;
        this.onFrameChange = null;
        this.onLoop = null;
    }
    ;
    /**
     * A short hand way of creating a movieclip from an array of frame ids.
     *
     * @static
     * @param {string[]} frames - The array of frames ids the movieclip will use as its texture frames.
     * @return {AnimatedSprite} The new animated sprite with the specified frames.
     */
    static fromFrames(frames) {
        var textures = [];
        for (var i = 0; i < frames.length; ++i) {
            textures.push(Texture_1.Texture.from(frames[i]));
        }
        return new AnimatedSprite(textures);
    }
    ;
    /**
     * A short hand way of creating a movieclip from an array of image ids.
     *
     * @static
     * @param {string[]} images - The array of image urls the movieclip will use as its texture frames.
     * @return {AnimatedSprite} The new animate sprite with the specified images as frames.
     */
    static fromImages(images) {
        var textures = [];
        for (var i = 0; i < images.length; ++i) {
            textures.push(Texture_1.Texture.from(images[i]));
        }
        return new AnimatedSprite(textures);
    }
    ;
    /**
     * The total number of frames in the AnimatedSprite. This is the same as number of textures
     * assigned to the AnimatedSprite.
     *
     * @readonly
     * @member {number}
     * @default 0
     */
    get totalFrames() {
        return this._textures.length;
    }
    ;
    /**
     * The array of textures used for this AnimatedSprite.
     *
     * @member {PIXI.Texture[]}
     */
    get textures() {
        return this._textures;
    }
    ;
    set textures(value) {
        if (value[0] instanceof Texture_1.Texture) {
            this._textures = value;
            this._durations = null;
        }
        else {
            this._textures = [];
            this._durations = [];
            for (var i = 0; i < value.length; i++) {
                this._textures.push(value[i].texture);
                this._durations.push(value[i].time);
            }
        }
        this.gotoAndStop(0);
        this.updateTexture();
    }
    ;
    /**
    * The AnimatedSprites current frame index.
    *
    * @member {number}
    * @readonly
    */
    get currentFrame() {
        var currentFrame = Math.floor(this._currentTime) % this._textures.length;
        if (currentFrame < 0) {
            currentFrame += this._textures.length;
        }
        return currentFrame;
    }
    ;
}
exports.AnimatedSprite = AnimatedSprite;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/Application.js":
/*!***********************************************!*\
  !*** ./js-compile/raw-pixi-ts/Application.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Container_1 = __webpack_require__(/*! ./Container */ "./js-compile/raw-pixi-ts/Container.js");
const Renderer_1 = __webpack_require__(/*! ./Renderer */ "./js-compile/raw-pixi-ts/Renderer.js");
const StageOptions_1 = __webpack_require__(/*! ./StageOptions */ "./js-compile/raw-pixi-ts/StageOptions.js");
const Ticker_1 = __webpack_require__(/*! ./Ticker */ "./js-compile/raw-pixi-ts/Ticker.js");
const AccessibilityManager_1 = __webpack_require__(/*! ./AccessibilityManager */ "./js-compile/raw-pixi-ts/AccessibilityManager.js");
const Extract_1 = __webpack_require__(/*! ./Extract */ "./js-compile/raw-pixi-ts/Extract.js");
const InteractionManager_1 = __webpack_require__(/*! ./InteractionManager */ "./js-compile/raw-pixi-ts/InteractionManager.js");
const ParticleRenderer_1 = __webpack_require__(/*! ./ParticleRenderer */ "./js-compile/raw-pixi-ts/ParticleRenderer.js");
const Prepare_1 = __webpack_require__(/*! ./Prepare */ "./js-compile/raw-pixi-ts/Prepare.js");
const BatchRenderer_1 = __webpack_require__(/*! ./BatchRenderer */ "./js-compile/raw-pixi-ts/BatchRenderer.js");
const TilingSpriteRenderer_1 = __webpack_require__(/*! ./TilingSpriteRenderer */ "./js-compile/raw-pixi-ts/TilingSpriteRenderer.js");
class Application {
    constructor(options = null) {
        this.resize = () => {
            if (this._resizeTo) {
                if (this._resizeTo === window) {
                    this.renderer.resize(window.innerWidth, window.innerHeight);
                }
                else {
                    this.renderer.resize(this._resizeTo['clientWidth'], this._resizeTo['clientHeight']);
                }
            }
        };
        if (!options) {
            options = new StageOptions_1.StageOptions();
        }
        Renderer_1.Renderer.registerPlugin('accessibility', AccessibilityManager_1.AccessibilityManager);
        Renderer_1.Renderer.registerPlugin('extract', Extract_1.Extract);
        Renderer_1.Renderer.registerPlugin('interaction', InteractionManager_1.InteractionManager);
        Renderer_1.Renderer.registerPlugin('particle', ParticleRenderer_1.ParticleRenderer);
        Renderer_1.Renderer.registerPlugin('prepare', Prepare_1.Prepare);
        Renderer_1.Renderer.registerPlugin('batch', BatchRenderer_1.BatchRenderer);
        Renderer_1.Renderer.registerPlugin('tilingSprite', TilingSpriteRenderer_1.TilingSpriteRenderer);
        // this.loader = /*options.sharedLoader ? Loader.shared : */new Loader();
        this.renderer = new Renderer_1.Renderer(options); //Application.autoDetectRenderer(options);
        this._stage = new Container_1.Container();
        this.ticker = options.sharedTicker ? Ticker_1.Ticker.shared : new Ticker_1.Ticker();
        this.resizeTo = window;
        // DisplayObject.mixin(interactiveTarget);
        if (options.autoStart) {
            this.start();
        }
    }
    get ticker() {
        return this._ticker;
    }
    set ticker(ticker) {
        if (this._ticker) {
            this._ticker.remove(this.render, this);
        }
        this._ticker = ticker;
        if (ticker) {
            ticker.add(this.render, this, Ticker_1.Ticker.UPDATE_PRIORITY.LOW);
        }
    }
    start() {
        this._ticker.start();
    }
    ;
    stop() {
        this._ticker.stop();
    }
    ;
    get resizeTo() {
        return this._resizeTo;
    }
    set resizeTo(value) {
        window.removeEventListener('resize', this.resize);
        this._resizeTo = value;
        if (value) {
            window.addEventListener('resize', this.resize);
            this.resize();
        }
    }
    render() {
        this.renderer.render(this._stage);
    }
    ;
    get stage() {
        return this._stage;
    }
    get view() {
        return this.renderer.view;
    }
    ;
    get screen() {
        return this.renderer.screen;
    }
    ;
    destroy(options = null) {
        this._stage.destroy(options);
        this._stage = null;
        this.renderer.destroy(options);
        this.renderer = null;
        this._options = null;
        // if (this.loader)
        // {
        //     this.loader.destroy();
        //     this.loader = null;
        // }
    }
    ;
}
exports.Application = Application;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/ArcUtils.js":
/*!********************************************!*\
  !*** ./js-compile/raw-pixi-ts/ArcUtils.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const settings_1 = __webpack_require__(/*! ./settings */ "./js-compile/raw-pixi-ts/settings.js");
const MathSettings_1 = __webpack_require__(/*! ./MathSettings */ "./js-compile/raw-pixi-ts/MathSettings.js");
class ArcUtils {
    constructor() {
    }
    static curveTo(x1, y1, x2, y2, radius, points) {
        var fromX = points[points.length - 2];
        var fromY = points[points.length - 1];
        var a1 = fromY - y1;
        var b1 = fromX - x1;
        var a2 = y2 - y1;
        var b2 = x2 - x1;
        var mm = Math.abs((a1 * b2) - (b1 * a2));
        if (mm < 1.0e-8 || radius === 0) {
            if (points[points.length - 2] !== x1 || points[points.length - 1] !== y1) {
                points.push(x1, y1);
            }
            return null;
        }
        var dd = (a1 * a1) + (b1 * b1);
        var cc = (a2 * a2) + (b2 * b2);
        var tt = (a1 * a2) + (b1 * b2);
        var k1 = radius * Math.sqrt(dd) / mm;
        var k2 = radius * Math.sqrt(cc) / mm;
        var j1 = k1 * tt / dd;
        var j2 = k2 * tt / cc;
        var cx = (k1 * b2) + (k2 * b1);
        var cy = (k1 * a2) + (k2 * a1);
        var px = b1 * (k2 + j1);
        var py = a1 * (k2 + j1);
        var qx = b2 * (k1 + j2);
        var qy = a2 * (k1 + j2);
        var startAngle = Math.atan2(py - cy, px - cx);
        var endAngle = Math.atan2(qy - cy, qx - cx);
        return {
            cx: (cx + x1),
            cy: (cy + y1),
            radius: radius,
            startAngle: startAngle,
            endAngle: endAngle,
            anticlockwise: (b1 * a2 > b2 * a1),
        };
    }
    ;
    /**
     * The arc method creates an arc/curve (used to create circles, or parts of circles).
     *
     * @private
     * @param {number} startX - Start x location of arc
     * @param {number} startY - Start y location of arc
     * @param {number} cx - The x-coordinate of the center of the circle
     * @param {number} cy - The y-coordinate of the center of the circle
     * @param {number} radius - The radius of the circle
     * @param {number} startAngle - The starting angle, in radians (0 is at the 3 o'clock position
     *  of the arc's circle)
     * @param {number} endAngle - The ending angle, in radians
     * @param {boolean} anticlockwise - Specifies whether the drawing should be
     *  counter-clockwise or clockwise. False is default, and indicates clockwise, while true
     *  indicates counter-clockwise.
     * @param {number} n - Number of segments
     * @param {number[]} points - Collection of points to add to
     */
    static arc(startX, startY, cx, cy, radius, startAngle, endAngle, anticlockwise, points) {
        var sweep = endAngle - startAngle;
        var n = settings_1.settings.GRAPHICS_CURVES._segmentsCount(Math.abs(sweep) * radius, Math.ceil(Math.abs(sweep) / MathSettings_1.MathSettings.PI_2) * 40);
        var theta = (sweep) / (n * 2);
        var theta2 = theta * 2;
        var cTheta = Math.cos(theta);
        var sTheta = Math.sin(theta);
        var segMinus = n - 1;
        var remainder = (segMinus % 1) / segMinus;
        for (var i = 0; i <= segMinus; ++i) {
            var real = i + (remainder * i);
            var angle = ((theta) + startAngle + (theta2 * real));
            var c = Math.cos(angle);
            var s = -Math.sin(angle);
            points.push((((cTheta * c) + (sTheta * s)) * radius) + cx, (((cTheta * -s) + (sTheta * c)) * radius) + cy);
        }
    }
    ;
}
exports.ArcUtils = ArcUtils;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/ArrayResource.js":
/*!*************************************************!*\
  !*** ./js-compile/raw-pixi-ts/ArrayResource.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Resource_1 = __webpack_require__(/*! ./Resource */ "./js-compile/raw-pixi-ts/Resource.js");
const BaseTexture_1 = __webpack_require__(/*! ./BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const ResourceSettings_1 = __webpack_require__(/*! ./ResourceSettings */ "./js-compile/raw-pixi-ts/ResourceSettings.js");
const WebGLSettings_1 = __webpack_require__(/*! ./WebGLSettings */ "./js-compile/raw-pixi-ts/WebGLSettings.js");
class ArrayResource extends Resource_1.Resource {
    constructor(source, options) {
        options = options || {};
        var urls;
        var length = source;
        if (Array.isArray(source)) {
            urls = source;
            length = source.length;
        }
        super(options.width, options.height);
        /**
         * Collection of resources.
         * @member {Array<PIXI.BaseTexture>}
         * @readonly
         */
        this.items = [];
        /**
         * Dirty IDs for each part
         * @member {Array<number>}
         * @readonly
         */
        this.itemDirtyIds = [];
        for (var i = 0; i < length; i++) {
            var partTexture = new BaseTexture_1.BaseTexture();
            this.items.push(partTexture);
            this.itemDirtyIds.push(-1);
        }
        /**
         * Number of elements in array
         *
         * @member {number}
         * @readonly
         */
        this.length = length;
        /**
         * Promise when loading
         * @member {Promise}
         * @private
         * @default null
         */
        this._load = null;
        if (urls) {
            for (var i$1 = 0; i$1 < length; i$1++) {
                this.addResourceAt(ResourceSettings_1.ResourceSettings.autoDetectResource(urls[i$1], options), i$1);
            }
        }
    }
    /**
     * Destroy this BaseImageResource
     * @override
     */
    dispose() {
        for (var i = 0, len = this.length; i < len; i++) {
            this.items[i].destroy();
        }
        this.items = null;
        this.itemDirtyIds = null;
        this._load = null;
    }
    ;
    /**
     * Set a resource by ID
     *
     * @param {PIXI.resources.Resource} resource
     * @param {number} index - Zero-based index of resource to set
     * @return {PIXI.resources.ArrayResource} Instance for chaining
     */
    addResourceAt(resource, index) {
        var baseTexture = this.items[index];
        if (!baseTexture) {
            throw new Error(("Index " + index + " is out of bounds"));
        }
        // Inherit the first resource dimensions
        if (resource.valid && !this.valid) {
            this.resize(resource.width, resource.height);
        }
        this.items[index].setResource(resource);
        return this;
    }
    ;
    /**
     * Set the parent base texture
     * @member {PIXI.BaseTexture}
     * @override
     */
    bind(baseTexture) {
        super.bind(baseTexture);
        baseTexture.target = WebGLSettings_1.WebGLSettings.TARGETS.TEXTURE_2D_ARRAY;
        for (var i = 0; i < this.length; i++) {
            this.items[i].on('update', baseTexture.update, baseTexture);
        }
    }
    ;
    /**
     * Unset the parent base texture
     * @member {PIXI.BaseTexture}
     * @override
     */
    unbind(baseTexture) {
        super.unbind(baseTexture);
        for (var i = 0; i < this.length; i++) {
            this.items[i].off('update', baseTexture.update, baseTexture);
        }
    }
    ;
    /**
     * Load all the resources simultaneously
     * @override
     * @return {Promise<void>} When load is resolved
     */
    load() {
        var this$1 = this;
        if (this._load) {
            return this._load;
        }
        var resources = this.items.map(function (item) { return item.resource; });
        // TODO: also implement load part-by-part strategy
        var promises = resources.map(function (item) { return item.load(); });
        this._load = Promise.all(promises)
            .then(function () {
            var ref = resources[0];
            var width = ref.width;
            var height = ref.height;
            this$1.resize(width, height);
            return Promise.resolve(this$1);
        });
        return this._load;
    }
    ;
    /**
     * Upload the resources to the GPU.
     * @param {PIXI.Renderer} renderer
     * @param {PIXI.BaseTexture} texture
     * @param {PIXI.GLTexture} glTexture
     * @returns {boolean} whether texture was uploaded
     */
    upload(renderer, texture, glTexture) {
        var ref = this;
        var length = ref.length;
        var itemDirtyIds = ref.itemDirtyIds;
        var items = ref.items;
        var gl = renderer.gl;
        if (glTexture.dirtyId < 0) {
            gl.texImage3D(gl.TEXTURE_2D_ARRAY, 0, texture.format, this._width, this._height, length, 0, texture.format, texture.type, null);
        }
        for (var i = 0; i < length; i++) {
            var item = items[i];
            if (itemDirtyIds[i] < item.dirtyId) {
                itemDirtyIds[i] = item.dirtyId;
                if (item.valid) {
                    gl.texSubImage3D(gl.TEXTURE_2D_ARRAY, 0, 0, // xoffset
                    0, // yoffset
                    i, // zoffset
                    item.resource.width, item.resource.height, 1, texture.format, texture.type, item.resource.source);
                }
            }
        }
        return true;
    }
    ;
}
exports.ArrayResource = ArrayResource;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/Attribute.js":
/*!*********************************************!*\
  !*** ./js-compile/raw-pixi-ts/Attribute.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class Attribute {
    constructor(buffer, size, normalized = false, type = 5126, stride = undefined, start = undefined, instance = undefined) {
        this.buffer = buffer;
        this.size = size;
        this.normalized = normalized;
        this.type = type;
        this._stride = stride;
        this.start = start;
        this.instance = instance;
    }
    ;
    set stride(value) {
        this._stride = value;
    }
    get stride() {
        return this._stride;
    }
    destroy(options = null) {
        this.buffer = null;
    }
    ;
}
exports.Attribute = Attribute;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/BaseImageResource.js":
/*!*****************************************************!*\
  !*** ./js-compile/raw-pixi-ts/BaseImageResource.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Resource_1 = __webpack_require__(/*! ./Resource */ "./js-compile/raw-pixi-ts/Resource.js");
const NetworkSettings_1 = __webpack_require__(/*! ./NetworkSettings */ "./js-compile/raw-pixi-ts/NetworkSettings.js");
class BaseImageResource extends Resource_1.Resource {
    constructor(source) {
        super(source.width, source.height);
        this.source = source;
    }
    /**
     * Set cross origin based detecting the url and the crossorigin
     * @protected
     * @param {HTMLElement} element - Element to apply crossOrigin
     * @param {string} url - URL to check
     * @param {boolean|string} [crossorigin=true] - Cross origin value to use
     */
    static crossOrigin(element, url, crossorigin) {
        if (crossorigin === undefined && url.indexOf('data:') !== 0) {
            element.crossOrigin = NetworkSettings_1.NetworkSettings.determineCrossOrigin(url);
        }
        else if (crossorigin !== false) {
            element.crossOrigin = typeof crossorigin === 'string' ? crossorigin : 'anonymous';
        }
    }
    ;
    /**
     * Upload the texture to the GPU.
     * @param {PIXI.Renderer} renderer Upload to the renderer
     * @param {PIXI.BaseTexture} baseTexture Reference to parent texture
     * @param {PIXI.GLTexture} glTexture
     * @param {HTMLImageElement|HTMLCanvasElement|HTMLVideoElement|SVGElement} [source] (optional)
     * @returns {boolean} true is success
     */
    upload(renderer, baseTexture, glTexture, source = null) {
        var gl = renderer.gl;
        var width = baseTexture.realWidth;
        var height = baseTexture.realHeight;
        source = source || this.source;
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, baseTexture.premultiplyAlpha);
        if (baseTexture.target === gl.TEXTURE_2D && glTexture.width === width && glTexture.height === height) {
            gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, baseTexture.format, baseTexture.type, source);
        }
        else {
            glTexture.width = width;
            glTexture.height = height;
            gl.texImage2D(baseTexture.target, 0, baseTexture.format, baseTexture.format, baseTexture.type, source);
        }
        return true;
    }
    ;
    /**
     * Destroy this BaseImageResource
     * @override
     * @param {PIXI.BaseTexture} [fromTexture] Optional base texture
     * @return {boolean} Destroy was successful
     */
    dispose() {
        this.source = null;
    }
    ;
}
exports.BaseImageResource = BaseImageResource;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/BasePrepare.js":
/*!***********************************************!*\
  !*** ./js-compile/raw-pixi-ts/BasePrepare.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Ticker_1 = __webpack_require__(/*! ./Ticker */ "./js-compile/raw-pixi-ts/Ticker.js");
const Container_1 = __webpack_require__(/*! ./Container */ "./js-compile/raw-pixi-ts/Container.js");
const TextStyle_1 = __webpack_require__(/*! ./TextStyle */ "./js-compile/raw-pixi-ts/TextStyle.js");
const Text_1 = __webpack_require__(/*! ./Text */ "./js-compile/raw-pixi-ts/Text.js");
const Texture_1 = __webpack_require__(/*! ./Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const BaseTexture_1 = __webpack_require__(/*! ./BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const TextMetrics_1 = __webpack_require__(/*! ./TextMetrics */ "./js-compile/raw-pixi-ts/TextMetrics.js");
const CountLimiter_1 = __webpack_require__(/*! ./CountLimiter */ "./js-compile/raw-pixi-ts/CountLimiter.js");
const WebGLSettings_1 = __webpack_require__(/*! ./WebGLSettings */ "./js-compile/raw-pixi-ts/WebGLSettings.js");
class BasePrepare //extends Renderer
 {
    constructor(renderer) {
        // super(null);
        /**
         * The limiter to be used to control how quickly items are prepared.
         * @type {PIXI.prepare.CountLimiter|PIXI.prepare.TimeLimiter}
         */
        this.limiter = new CountLimiter_1.CountLimiter(WebGLSettings_1.WebGLSettings.UPLOADS_PER_FRAME);
        /**
         * Reference to the renderer.
         * @type {PIXI.AbstractRenderer}
         * @protected
         */
        this.renderer = renderer;
        /**
         * The only real difference between CanvasPrepare and WebGLPrepare is what they pass
         * to upload hooks. That different parameter is stored here.
         * @type {PIXI.prepare.CanvasPrepare|PIXI.Renderer}
         * @protected
         */
        this.uploadHookHelper = renderer;
        /**
         * Collection of items to uploads at once.
         * @type {Array<*>}
         * @private
         */
        this.queue = [];
        /**
         * Collection of additional hooks for finding assets.
         * @type {Array<Function>}
         * @private
         */
        this.addHooks = [];
        /**
         * Collection of additional hooks for processing assets.
         * @type {Array<Function>}
         * @private
         */
        this.uploadHooks = [];
        /**
         * Callback to call after completed.
         * @type {Array<Function>}
         * @private
         */
        this.completes = [];
        /**
         * If prepare is ticking (running).
         * @type {boolean}
         * @private
         */
        this.ticking = false;
        /**
         * 'bound' call for prepareItems().
         * @type {Function}
         * @private
         */
        this.delayedTick = function () {
            // unlikely, but in case we were destroyed between tick() and delayedTick()
            if (!this.queue) {
                return;
            }
            this.prepareItems();
        };
        // hooks to find the correct texture
        this.registerFindHook(BasePrepare.findText);
        this.registerFindHook(BasePrepare.findTextStyle);
        this.registerFindHook(BasePrepare.findMultipleBaseTextures);
        this.registerFindHook(BasePrepare.findBaseTexture);
        this.registerFindHook(BasePrepare.findTexture);
        // upload hooks
        this.registerUploadHook(BasePrepare.drawText);
        this.registerUploadHook(BasePrepare.calculateTextStyle);
    }
    /**
     * Upload all the textures and graphics to the GPU.
     *
     * @param {Function|PIXI.DisplayObject|PIXI.Container|PIXI.BaseTexture|PIXI.Texture|PIXI.Graphics|PIXI.Text} item -
     *    Either the container or display object to search for items to upload, the items to upload themselves,
     *    or the callback function, if items have been added using `prepare.add`.
     * @param {Function} [done] - Optional callback when all queued uploads have completed
     */
    upload(item, done) {
        if (typeof item === 'function') {
            done = item;
            item = null;
        }
        // If a display object, search for items
        // that we could upload
        if (item) {
            this.add(item);
        }
        // Get the items for upload from the display
        if (this.queue.length) {
            if (done) {
                this.completes.push(done);
            }
            if (!this.ticking) {
                this.ticking = true;
                Ticker_1.Ticker.system.addOnce(this.tick, this, Ticker_1.Ticker.UPDATE_PRIORITY.UTILITY);
            }
        }
        else if (done) {
            done();
        }
    }
    ;
    /**
     * Handle tick update
     *
     * @private
     */
    tick() {
        setTimeout(this.delayedTick, 0);
    }
    ;
    /**
     * Actually prepare items. This is handled outside of the tick because it will take a while
     * and we do NOT want to block the current animation frame from rendering.
     *
     * @private
     */
    prepareItems() {
        this.limiter.beginFrame();
        // Upload the graphics
        while (this.queue.length && this.limiter.allowedToUpload()) {
            var item = this.queue[0];
            var uploaded = false;
            if (item && !item._destroyed) {
                for (var i = 0, len = this.uploadHooks.length; i < len; i++) {
                    if (this.uploadHooks[i](this.uploadHookHelper, item)) {
                        this.queue.shift();
                        uploaded = true;
                        break;
                    }
                }
            }
            if (!uploaded) {
                this.queue.shift();
            }
        }
        // We're finished
        if (!this.queue.length) {
            this.ticking = false;
            var completes = this.completes.slice(0);
            this.completes.length = 0;
            for (var i$1 = 0, len$1 = completes.length; i$1 < len$1; i$1++) {
                completes[i$1]();
            }
        }
        else {
            // if we are not finished, on the next rAF do this again
            Ticker_1.Ticker.system.addOnce(this.tick, this, Ticker_1.Ticker.UPDATE_PRIORITY.UTILITY);
        }
    }
    ;
    /**
     * Adds hooks for finding items.
     *
     * @param {Function} addHook - Function call that takes two parameters: `item:*, queue:Array`
     *      function must return `true` if it was able to add item to the queue.
     * @return {PIXI.prepare.BasePrepare} Instance of plugin for chaining.
     */
    registerFindHook(addHook) {
        if (addHook) {
            this.addHooks.push(addHook);
        }
        return this;
    }
    ;
    /**
     * Adds hooks for uploading items.
     *
     * @param {Function} uploadHook - Function call that takes two parameters: `prepare:CanvasPrepare, item:*` and
     *      function must return `true` if it was able to handle upload of item.
     * @return {PIXI.prepare.BasePrepare} Instance of plugin for chaining.
     */
    registerUploadHook(uploadHook) {
        if (uploadHook) {
            this.uploadHooks.push(uploadHook);
        }
        return this;
    }
    ;
    /**
     * Manually add an item to the uploading queue.
     *
     * @param {PIXI.DisplayObject|PIXI.Container|PIXI.BaseTexture|PIXI.Texture|PIXI.Graphics|PIXI.Text|*} item - Object to
     *    add to the queue
     * @return {PIXI.prepare.BasePrepare} Instance of plugin for chaining.
     */
    add(item) {
        // Add additional hooks for finding elements on special
        // types of objects that
        for (var i = 0, len = this.addHooks.length; i < len; i++) {
            if (this.addHooks[i](item, this.queue)) {
                break;
            }
        }
        // Get children recursively
        if (item instanceof Container_1.Container) {
            for (var i$1 = item.children.length - 1; i$1 >= 0; i$1--) {
                this.add(item.children[i$1]);
            }
        }
        return this;
    }
    ;
    /**
     * Destroys the plugin, don't use after this.
     *
     */
    destroy() {
        if (this.ticking) {
            Ticker_1.Ticker.system.remove(this.tick, this);
        }
        this.ticking = false;
        this.addHooks = null;
        this.uploadHooks = null;
        this.renderer = null;
        this.completes = null;
        this.queue = null;
        this.limiter = null;
        this.uploadHookHelper = null;
    }
    ;
    /**
 * Built-in hook to find Text objects.
 *
 * @private
 * @param {PIXI.DisplayObject} item - Display object to check
 * @param {Array<*>} queue - Collection of items to upload
 * @return {boolean} if a PIXI.Text object was found.
 */
    static findText(item, queue) {
        if (item instanceof Text_1.Text) {
            // push the text style to prepare it - this can be really expensive
            if (queue.indexOf(item.style) === -1) {
                queue.push(item.style);
            }
            // also push the text object so that we can render it (to canvas/texture) if needed
            if (queue.indexOf(item) === -1) {
                queue.push(item);
            }
            // also push the Text's texture for upload to GPU
            var texture = item._texture.baseTexture;
            if (queue.indexOf(texture) === -1) {
                queue.push(texture);
            }
            return true;
        }
        return false;
    }
    /**
 * Built-in hook to find TextStyle objects.
 *
 * @private
 * @param {PIXI.TextStyle} item - Display object to check
 * @param {Array<*>} queue - Collection of items to upload
 * @return {boolean} if a PIXI.TextStyle object was found.
 */
    static findTextStyle(item, queue) {
        if (item instanceof TextStyle_1.TextStyle) {
            if (queue.indexOf(item) === -1) {
                queue.push(item);
            }
            return true;
        }
        return false;
    }
    /**
 * Built-in hook to find multiple textures from objects like AnimatedSprites.
 *
 * @private
 * @param {PIXI.DisplayObject} item - Display object to check
 * @param {Array<*>} queue - Collection of items to upload
 * @return {boolean} if a PIXI.Texture object was found.
 */
    static findMultipleBaseTextures(item, queue) {
        var result = false;
        // Objects with multiple textures
        if (item && item._textures && item._textures.length) {
            for (var i = 0; i < item._textures.length; i++) {
                if (item._textures[i] instanceof Texture_1.Texture) {
                    var baseTexture = item._textures[i].baseTexture;
                    if (queue.indexOf(baseTexture) === -1) {
                        queue.push(baseTexture);
                        result = true;
                    }
                }
            }
        }
        return result;
    }
    /**
 * Built-in hook to find BaseTextures from Sprites.
 *
 * @private
 * @param {PIXI.DisplayObject} item - Display object to check
 * @param {Array<*>} queue - Collection of items to upload
 * @return {boolean} if a PIXI.Texture object was found.
 */
    static findBaseTexture(item, queue) {
        // Objects with textures, like Sprites/Text
        if (item instanceof BaseTexture_1.BaseTexture) {
            if (queue.indexOf(item) === -1) {
                queue.push(item);
            }
            return true;
        }
        return false;
    }
    /**
 * Built-in hook to find textures from objects.
 *
 * @private
 * @param {PIXI.DisplayObject} item - Display object to check
 * @param {Array<*>} queue - Collection of items to upload
 * @return {boolean} if a PIXI.Texture object was found.
 */
    static findTexture(item, queue) {
        if (item._texture && item._texture instanceof Texture_1.Texture) {
            var texture = item._texture.baseTexture;
            if (queue.indexOf(texture) === -1) {
                queue.push(texture);
            }
            return true;
        }
        return false;
    }
    /**
     * Built-in hook to draw PIXI.Text to its texture.
     *
     * @private
     * @param {PIXI.Renderer|PIXI.CanvasPrepare} helper - Not used by this upload handler
     * @param {PIXI.DisplayObject} item - Item to check
     * @return {boolean} If item was uploaded.
     */
    static drawText(helper, item) {
        if (item instanceof Text_1.Text) {
            // updating text will return early if it is not dirty
            item.updateText(true);
            return true;
        }
        return false;
    }
    /**
 * Built-in hook to calculate a text style for a PIXI.Text object.
 *
 * @private
 * @param {PIXI.Renderer|PIXI.CanvasPrepare} helper - Not used by this upload handler
 * @param {PIXI.DisplayObject} item - Item to check
 * @return {boolean} If item was uploaded.
 */
    static calculateTextStyle(helper, item) {
        if (item instanceof TextStyle_1.TextStyle) {
            var font = item.toFontString();
            TextMetrics_1.TextMetrics.measureFont(font);
            return true;
        }
        return false;
    }
}
exports.BasePrepare = BasePrepare;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/BaseRenderTexture.js":
/*!*****************************************************!*\
  !*** ./js-compile/raw-pixi-ts/BaseRenderTexture.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseTexture_1 = __webpack_require__(/*! ./BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const Framebuffer_1 = __webpack_require__(/*! ./Framebuffer */ "./js-compile/raw-pixi-ts/Framebuffer.js");
class BaseRenderTexture extends BaseTexture_1.BaseTexture {
    constructor(options, arg1 = null, arg2 = null, arg4 = null) {
        super(null, options);
        if (typeof options === 'number') {
            /* eslint-disable prefer-rest-params */
            // Backward compatibility of signature
            var width$1 = arguments[0];
            var height$1 = arguments[1];
            var scaleMode = arguments[2];
            var resolution = arguments[3];
            options = { width: width$1, height: height$1, scaleMode: scaleMode, resolution: resolution };
            /* eslint-enable prefer-rest-params */
        }
        var ref = options || {};
        var width = ref.width;
        var height = ref.height;
        // Set defaults
        this.mipmap = false;
        this.width = Math.ceil(width) || 100;
        this.height = Math.ceil(height) || 100;
        this.valid = true;
        /**
         * A reference to the canvas render target (we only need one as this can be shared across renderers)
         *
         * @protected
         * @member {object}
         */
        this._canvasRenderTarget = null;
        this.clearColor = [0, 0, 0, 0];
        this.framebuffer = new Framebuffer_1.Framebuffer(this.width * this.resolution, this.height * this.resolution)
            .addColorTexture(0, this)
            .enableStencil();
        // TODO - could this be added the systems?
        /**
         * The data structure for the stencil masks.
         *
         * @member {PIXI.Graphics[]}
         */
        this.stencilMaskStack = [];
        /**
         * The data structure for the filters.
         *
         * @member {PIXI.Graphics[]}
         */
        this.filterStack = [{}];
    }
    /**
     * Resizes the BaseRenderTexture.
     *
     * @param {number} width - The width to resize to.
     * @param {number} height - The height to resize to.
     */
    resize(width, height) {
        width = Math.ceil(width);
        height = Math.ceil(height);
        this.framebuffer.resize(width * this.resolution, height * this.resolution);
    }
    ;
    /**
     * Frees the texture and framebuffer from WebGL memory without destroying this texture object.
     * This means you can still use the texture later which will upload it to GPU
     * memory again.
     *
     * @fires PIXI.BaseTexture#dispose
     */
    dispose() {
        this.framebuffer.dispose();
        super.dispose();
    }
    ;
    /**
     * Destroys this texture.
     *
     */
    destroy() {
        super.destroy();
        this.framebuffer = null;
        this.renderer = null;
    }
    ;
}
exports.BaseRenderTexture = BaseRenderTexture;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/BaseTexture.js":
/*!***********************************************!*\
  !*** ./js-compile/raw-pixi-ts/BaseTexture.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const EventDispatcher_1 = __webpack_require__(/*! ./EventDispatcher */ "./js-compile/raw-pixi-ts/EventDispatcher.js");
const Event_1 = __webpack_require__(/*! ./Event */ "./js-compile/raw-pixi-ts/Event.js");
const Resource_1 = __webpack_require__(/*! ./Resource */ "./js-compile/raw-pixi-ts/Resource.js");
const BufferResource_1 = __webpack_require__(/*! ./BufferResource */ "./js-compile/raw-pixi-ts/BufferResource.js");
const DisplaySettings_1 = __webpack_require__(/*! ./DisplaySettings */ "./js-compile/raw-pixi-ts/DisplaySettings.js");
const MathSettings_1 = __webpack_require__(/*! ./MathSettings */ "./js-compile/raw-pixi-ts/MathSettings.js");
const WebGLSettings_1 = __webpack_require__(/*! ./WebGLSettings */ "./js-compile/raw-pixi-ts/WebGLSettings.js");
const CacheSettings_1 = __webpack_require__(/*! ./CacheSettings */ "./js-compile/raw-pixi-ts/CacheSettings.js");
const ResourceSettings_1 = __webpack_require__(/*! ./ResourceSettings */ "./js-compile/raw-pixi-ts/ResourceSettings.js");
class BaseTexture extends EventDispatcher_1.EventDispatcher {
    constructor(resource = null, options = null) {
        super();
        this.handleResize = (event) => {
            this.setRealSize(this.resource.width, this.resource.height);
        };
        this.handleUpdate = (event) => {
            this.update();
        };
        options = options || {};
        var premultiplyAlpha = options.premultiplyAlpha;
        var mipmap = options.mipmap;
        var scaleMode = options.scaleMode;
        var width = options.width;
        var height = options.height;
        var wrapMode = options.wrapMode;
        var format = options.format;
        var type = options.type;
        var target = options.target;
        var resolution = options.resolution;
        var resourceOptions = options.resourceOptions;
        // Convert the resource to a Resource object
        if (resource && resource instanceof ImageBitmap) {
        }
        else if (resource && !(resource instanceof Resource_1.Resource)) {
            resource = ResourceSettings_1.ResourceSettings.autoDetectResource(resource, resourceOptions);
            resource.internal = true;
        }
        /**
         * The width of the base texture set when the image has loaded
         *
         * @readonly
         * @member {number}
         */
        this.width = width || 0;
        /**
         * The height of the base texture set when the image has loaded
         *
         * @readonly
         * @member {number}
         */
        this.height = height || 0;
        /**
         * The resolution / device pixel ratio of the texture
         *
         * @member {number}
         * @default PIXI.settings.RESOLUTION
         */
        this.resolution = resolution || DisplaySettings_1.DisplaySettings.RESOLUTION;
        /**
         * Mipmap mode of the texture, affects downscaled images
         *
         * @member {PIXI.MIPMAP_MODES}
         * @default PIXI.settings.MIPMAP_TEXTURES
         */
        this.mipmap = mipmap !== undefined ? mipmap : WebGLSettings_1.WebGLSettings.MIPMAP_TEXTURES;
        /**
         * How the texture wraps
         * @member {number}
         */
        this.wrapMode = wrapMode || WebGLSettings_1.WebGLSettings.WRAP_MODE;
        /**
         * The scale mode to apply when scaling this texture
         *
         * @member {PIXI.SCALE_MODES}
         * @default PIXI.settings.SCALE_MODE
         */
        this.scaleMode = scaleMode !== undefined ? scaleMode : DisplaySettings_1.DisplaySettings.SCALE_MODE;
        /**
         * The pixel format of the texture
         *
         * @member {PIXI.FORMATS}
         * @default PIXI.FORMATS.RGBA
         */
        this.format = format || WebGLSettings_1.WebGLSettings.FORMATS.RGBA;
        /**
         * The type of resource data
         *
         * @member {PIXI.TYPES}
         * @default PIXI.TYPES.UNSIGNED_BYTE
         */
        this.type = type || WebGLSettings_1.WebGLSettings.TYPES.UNSIGNED_BYTE;
        /**
         * The target type
         *
         * @member {PIXI.TARGETS}
         * @default PIXI.TARGETS.TEXTURE_2D
         */
        this.target = target || WebGLSettings_1.WebGLSettings.TARGETS.TEXTURE_2D;
        /**
         * Set to true to enable pre-multiplied alpha
         *
         * @member {boolean}
         * @default true
         */
        this.premultiplyAlpha = premultiplyAlpha !== false;
        /**
         * Global unique identifier for this BaseTexture
         *
         * @member {string}
         * @protected
         */
        this.uid = MathSettings_1.MathSettings.uid();
        /**
         * Used by automatic texture Garbage Collection, stores last GC tick when it was bound
         *
         * @member {number}
         * @protected
         */
        this.touched = 0;
        /**
         * Whether or not the texture is a power of two, try to use power of two textures as much
         * as you can
         *
         * @readonly
         * @member {boolean}
         * @default false
         */
        this.isPowerOfTwo = false;
        this._refreshPOT();
        /**
         * The map of render context textures where this is bound
         *
         * @member {Object}
         * @private
         */
        this._glTextures = {};
        /**
         * Used by TextureSystem to only update texture to the GPU when needed.
         *
         * @protected
         * @member {number}
         */
        this.dirtyId = 0;
        /**
         * Used by TextureSystem to only update texture style when needed.
         *
         * @protected
         * @member {number}
         */
        this.dirtyStyleId = 0;
        /**
         * Currently default cache ID.
         *
         * @member {string}
         */
        this.cacheId = null;
        /**
         * Generally speaking means when resource is loaded.
         * @readonly
         * @member {boolean}
         */
        this.valid = width > 0 && height > 0;
        /**
         * The collection of alternative cache ids, since some BaseTextures
         * can have more than one ID, short name and longer full URL
         *
         * @member {Array<string>}
         * @readonly
         */
        this.textureCacheIds = [];
        /**
         * Flag if BaseTexture has been destroyed.
         *
         * @member {boolean}
         * @readonly
         */
        this.destroyed = false;
        /**
         * The resource used by this BaseTexture, there can only
         * be one resource per BaseTexture, but textures can share
         * resources.
         *
         * @member {PIXI.resources.Resource}
         * @readonly
         */
        this.resource = null;
        /**
         * Number of the texture batch, used by multi-texture renderers
         *
         * @member {number}
         */
        this._batchEnabled = 0;
        /**
         * Fired when a not-immediately-available source finishes loading.
         *
         * @protected
         * @event PIXI.BaseTexture#loaded
         * @param {PIXI.BaseTexture} baseTexture - Resource loaded.
         */
        /**
         * Fired when a not-immediately-available source fails to load.
         *
         * @protected
         * @event PIXI.BaseTexture#error
         * @param {PIXI.BaseTexture} baseTexture - Resource errored.
         */
        /**
         * Fired when BaseTexture is updated.
         *
         * @protected
         * @event PIXI.BaseTexture#loaded
         * @param {PIXI.BaseTexture} baseTexture - Resource loaded.
         */
        /**
         * Fired when BaseTexture is destroyed.
         *
         * @protected
         * @event PIXI.BaseTexture#error
         * @param {PIXI.BaseTexture} baseTexture - Resource errored.
         */
        /**
         * Fired when BaseTexture is updated.
         *
         * @protected
         * @event PIXI.BaseTexture#update
         * @param {PIXI.BaseTexture} baseTexture - Instance of texture being updated.
         */
        /**
         * Fired when BaseTexture is destroyed.
         *
         * @protected
         * @event PIXI.BaseTexture#dispose
         * @param {PIXI.BaseTexture} baseTexture - Instance of texture being destroyed.
         */
        // Set the resource
        this.setResource(resource);
    }
    /**
     * Pixel width of the source of this texture
     *
     * @readonly
     * @member {number}
     */
    get realWidth() {
        return this.width * this.resolution;
    }
    ;
    /**
     * Pixel height of the source of this texture
     *
     * @readonly
     * @member {number}
     */
    get realHeight() {
        return this.height * this.resolution;
    }
    ;
    /**
     * Changes style options of BaseTexture
     *
     * @param {PIXI.SCALE_MODES} [scaleMode] - Pixi scalemode
     * @param {PIXI.MIPMAP_MODES} [mipmap] - enable mipmaps
     * @returns {BaseTexture} this
     */
    BsetStyle(scaleMode, mipmap) {
        var dirty;
        if (scaleMode !== undefined && scaleMode !== this.scaleMode) {
            this.scaleMode = scaleMode;
            dirty = true;
        }
        if (mipmap !== undefined && mipmap !== this.mipmap) {
            this.mipmap = mipmap;
            dirty = true;
        }
        if (dirty) {
            this.dirtyStyleId++;
        }
        return this;
    }
    ;
    /**
     * Changes w/h/resolution. Texture becomes valid if width and height are greater than zero.
     *
     * @param {number} width Visual width
     * @param {number} height Visual height
     * @param {number} [resolution] Optionally set resolution
     * @returns {BaseTexture} this
     */
    setSize(width, height, resolution = null) {
        this.resolution = resolution || this.resolution;
        this.width = width;
        this.height = height;
        this._refreshPOT();
        this.update();
        return this;
    }
    ;
    /**
     * Sets real size of baseTexture, preserves current resolution.
     *
     * @param {number} realWidth Full rendered width
     * @param {number} realHeight Full rendered height
     * @param {number} [resolution] Optionally set resolution
     * @returns {BaseTexture} this
     */
    setRealSize(realWidth, realHeight, resolution = null) {
        this.resolution = resolution || this.resolution;
        this.width = realWidth / this.resolution;
        this.height = realHeight / this.resolution;
        this._refreshPOT();
        this.update();
        return this;
    }
    ;
    /**
     * Refresh check for isPowerOfTwo texture based on size
     *
     * @private
     */
    _refreshPOT() {
        this.isPowerOfTwo = MathSettings_1.MathSettings.isPow2(this.realWidth) && MathSettings_1.MathSettings.isPow2(this.realHeight);
    }
    ;
    /**
     * Changes resolution
     *
     * @param {number} [resolution] res
     * @returns {BaseTexture} this
     */
    setResolution(resolution) {
        var oldResolution = this.resolution;
        if (oldResolution === resolution) {
            return this;
        }
        this.resolution = resolution;
        if (this.valid) {
            this.width = this.width * oldResolution / resolution;
            this.height = this.height * oldResolution / resolution;
            this.dispatchEvent(Event_1.Event.getEvent("update"));
            // this.emit('update');
        }
        this._refreshPOT();
        return this;
    }
    ;
    /**
     * Sets the resource if it wasn't set. Throws error if resource already present
     *
     * @param {PIXI.resources.Resource} resource - that is managing this BaseTexture
     * @returns {BaseTexture} this
     */
    setResource(resource) {
        if (this.resource === resource) {
            return this;
        }
        if (this.resource) {
            throw new Error('Resource can be set only once');
        }
        this.resource = resource;
        if (resource instanceof ImageBitmap) {
            this.setRealSize(this.resource.width, this.resource.height);
            this.handleUpdate(null);
        }
        else {
            resource.addEventListener("update", this.handleUpdate);
            resource.addEventListener("setRealSize", this.handleResize);
            this.setRealSize(this.resource.width, this.resource.height);
        }
        // resource.bind(this);
        return this;
    }
    ;
    /**
     * Invalidates the object. Texture becomes valid if width and height are greater than zero.
     */
    update() {
        if (!this.valid) {
            if (this.width > 0 && this.height > 0) {
                this.valid = true;
                this.dispatchEvent(Event_1.Event.getEvent("loaded"));
                this.dispatchEvent(Event_1.Event.getEvent("update"));
                // this.emit('loaded', this);
                // this.emit('update', this);
            }
        }
        else {
            this.dirtyId++;
            this.dirtyStyleId++;
            this.dispatchEvent(Event_1.Event.getEvent("update"));
            // this.emit('update', this);
        }
    }
    ;
    /**
     * Destroys this base texture.
     * The method stops if resource doesn't want this texture to be destroyed.
     * Removes texture from all caches.
     */
    destroy() {
        // remove and destroy the resource
        if (this.resource) {
            this.resource.unbind(this);
            // only destroy resourced created internally
            if (this.resource.internal) {
                this.resource.destroy();
            }
            this.resource = null;
        }
        if (this.cacheId) {
            delete CacheSettings_1.CacheSettings.BaseTextureCache[this.cacheId];
            delete CacheSettings_1.CacheSettings.TextureCache[this.cacheId];
            this.cacheId = null;
        }
        // finally let the WebGL renderer know..
        this.dispose();
        BaseTexture.removeFromCache(this);
        this.textureCacheIds = null;
        this.destroyed = true;
    }
    ;
    /**
     * Frees the texture from WebGL memory without destroying this texture object.
     * This means you can still use the texture later which will upload it to GPU
     * memory again.
     *
     * @fires PIXI.BaseTexture#dispose
     */
    dispose() {
        this.dispatchEvent(Event_1.Event.getEvent("dispose"));
        // this.emit('dispose', this);
    }
    ;
    /**
     * Helper function that creates a base texture based on the source you provide.
     * The source can be - image url, image element, canvas element. If the
     * source is an image url or an image element and not in the base texture
     * cache, it will be created and loaded.
     *
     * @static
     * @param {string|HTMLImageElement|HTMLCanvasElement|SVGElement|HTMLVideoElement} source - The
     *        source to create base texture from.
     * @param {object} [options] See {@link PIXI.BaseTexture}'s constructor for options.
     * @returns {PIXI.BaseTexture} The new base texture.
     */
    static from(source, options) {
        var cacheId = null;
        if (typeof source === 'string') {
            cacheId = source;
        }
        else {
            if (!source._pixiId) {
                source._pixiId = "pixiid_" + (MathSettings_1.MathSettings.uid());
            }
            cacheId = source._pixiId;
        }
        var baseTexture = CacheSettings_1.CacheSettings.BaseTextureCache[cacheId];
        if (!baseTexture) {
            baseTexture = new BaseTexture(source, options);
            baseTexture.cacheId = cacheId;
            BaseTexture.addToCache(baseTexture, cacheId);
        }
        return baseTexture;
    }
    ;
    /**
     * Create a new BaseTexture with a BufferResource from a Float32Array.
     * RGBA values are floats from 0 to 1.
     * @static
     * @param {Float32Array|Uint8Array} buffer The optional array to use, if no data
     *        is provided, a new Float32Array is created.
     * @param {number} width - Width of the resource
     * @param {number} height - Height of the resource
     * @param {object} [options] See {@link PIXI.BaseTexture}'s constructor for options.
     * @return {PIXI.BaseTexture} The resulting new BaseTexture
     */
    static fromBuffer(buffer, width, height, options) {
        buffer = buffer || new Float32Array(width * height * 4);
        var resource = new BufferResource_1.BufferResource(buffer, { width: width, height: height });
        var type = buffer instanceof Float32Array ? WebGLSettings_1.WebGLSettings.TYPES.FLOAT : WebGLSettings_1.WebGLSettings.TYPES.UNSIGNED_BYTE;
        return new BaseTexture(resource, Object.assign(WebGLSettings_1.WebGLSettings.defaultBufferOptions, options || { width: width, height: height, type: type }));
    }
    ;
    /**
     * Adds a BaseTexture to the global BaseTextureCache. This cache is shared across the whole PIXI object.
     *
     * @static
     * @param {PIXI.BaseTexture} baseTexture - The BaseTexture to add to the cache.
     * @param {string} id - The id that the BaseTexture will be stored against.
     */
    static addToCache(baseTexture, id) {
        if (id) {
            if (baseTexture.textureCacheIds.indexOf(id) === -1) {
                baseTexture.textureCacheIds.push(id);
            }
            if (CacheSettings_1.CacheSettings.BaseTextureCache[id]) {
                // eslint-disable-next-line no-console
                console.warn(("BaseTexture added to the cache with an id [" + id + "] that already had an entry"));
            }
            CacheSettings_1.CacheSettings.BaseTextureCache[id] = baseTexture;
        }
    }
    ;
    /**
     * Remove a BaseTexture from the global BaseTextureCache.
     *
     * @static
     * @param {string|PIXI.BaseTexture} baseTexture - id of a BaseTexture to be removed, or a BaseTexture instance itself.
     * @return {PIXI.BaseTexture|null} The BaseTexture that was removed.
     */
    static removeFromCache(baseTexture) {
        if (typeof baseTexture === 'string') {
            var baseTextureFromCache = CacheSettings_1.CacheSettings.BaseTextureCache[baseTexture];
            if (baseTextureFromCache) {
                var index = baseTextureFromCache.textureCacheIds.indexOf(baseTexture);
                if (index > -1) {
                    baseTextureFromCache.textureCacheIds.splice(index, 1);
                }
                delete CacheSettings_1.CacheSettings.BaseTextureCache[baseTexture];
                return baseTextureFromCache;
            }
        }
        else if (baseTexture && baseTexture.textureCacheIds) {
            for (var i = 0; i < baseTexture.textureCacheIds.length; ++i) {
                delete CacheSettings_1.CacheSettings.BaseTextureCache[baseTexture.textureCacheIds[i]];
            }
            baseTexture.textureCacheIds.length = 0;
            return baseTexture;
        }
        return null;
    }
    ;
}
/**
 * Global number of the texture batch, used by multi-texture renderers
 *
 * @static
 * @member {number} new texture batch number
 */
BaseTexture._globalBatch = 0;
exports.BaseTexture = BaseTexture;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/BatchBuffer.js":
/*!***********************************************!*\
  !*** ./js-compile/raw-pixi-ts/BatchBuffer.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class BatchBuffer {
    constructor(size) {
        this.vertices = new ArrayBuffer(size);
        /**
         * View on the vertices as a Float32Array for positions
         *
         * @member {Float32Array}
         */
        this.float32View = new Float32Array(this.vertices);
        /**
         * View on the vertices as a Uint32Array for uvs
         *
         * @member {Float32Array}
         */
        this.uint32View = new Uint32Array(this.vertices);
    }
    destroy() {
        this.vertices = null;
        this.float32View = null;
        this.uint32View = null;
    }
    ;
}
exports.BatchBuffer = BatchBuffer;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/BatchDrawCall.js":
/*!*************************************************!*\
  !*** ./js-compile/raw-pixi-ts/BatchDrawCall.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class BatchDrawCall {
    constructor() {
        this.textures = [];
        this.ids = [];
        this.blend = 0;
        this.textureCount = 0;
        this.start = 0;
        this.size = 0;
        this.type = 4;
    }
    ;
}
exports.BatchDrawCall = BatchDrawCall;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/BatchGeometry.js":
/*!*************************************************!*\
  !*** ./js-compile/raw-pixi-ts/BatchGeometry.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Geometry_1 = __webpack_require__(/*! ./Geometry */ "./js-compile/raw-pixi-ts/Geometry.js");
const Buffer_1 = __webpack_require__(/*! ./Buffer */ "./js-compile/raw-pixi-ts/Buffer.js");
const WebGLSettings_1 = __webpack_require__(/*! ./WebGLSettings */ "./js-compile/raw-pixi-ts/WebGLSettings.js");
class BatchGeometry extends Geometry_1.Geometry {
    constructor(_static = false) {
        super();
        /**
         * Buffer used for position, color, texture IDs
         *
         * @member {PIXI.Buffer}
         * @protected
         */
        this._buffer = new Buffer_1.Buffer(null, _static, false);
        /**
         * Index buffer data
         *
         * @member {PIXI.Buffer}
         * @protected
         */
        this._indexBuffer = new Buffer_1.Buffer(null, _static, true);
        this.addAttribute('aVertexPosition', this._buffer, 2, false, WebGLSettings_1.WebGLSettings.TYPES.FLOAT)
            .addAttribute('aTextureCoord', this._buffer, 2, false, WebGLSettings_1.WebGLSettings.TYPES.FLOAT)
            .addAttribute('aColor', this._buffer, 4, true, WebGLSettings_1.WebGLSettings.TYPES.UNSIGNED_BYTE)
            .addAttribute('aTextureId', this._buffer, 1, true, WebGLSettings_1.WebGLSettings.TYPES.FLOAT)
            .addIndex(this._indexBuffer);
    }
}
exports.BatchGeometry = BatchGeometry;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/BatchRenderer.js":
/*!*************************************************!*\
  !*** ./js-compile/raw-pixi-ts/BatchRenderer.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const ObjectRenderer_1 = __webpack_require__(/*! ./ObjectRenderer */ "./js-compile/raw-pixi-ts/ObjectRenderer.js");
const BatchGeometry_1 = __webpack_require__(/*! ./BatchGeometry */ "./js-compile/raw-pixi-ts/BatchGeometry.js");
const BaseTexture_1 = __webpack_require__(/*! ./BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const BatchDrawCall_1 = __webpack_require__(/*! ./BatchDrawCall */ "./js-compile/raw-pixi-ts/BatchDrawCall.js");
const State_1 = __webpack_require__(/*! ./State */ "./js-compile/raw-pixi-ts/State.js");
const BatchBuffer_1 = __webpack_require__(/*! ./BatchBuffer */ "./js-compile/raw-pixi-ts/BatchBuffer.js");
const ColorSettings_1 = __webpack_require__(/*! ./ColorSettings */ "./js-compile/raw-pixi-ts/ColorSettings.js");
const WebGLSettings_1 = __webpack_require__(/*! ./WebGLSettings */ "./js-compile/raw-pixi-ts/WebGLSettings.js");
const BlendModesSettings_1 = __webpack_require__(/*! ./BlendModesSettings */ "./js-compile/raw-pixi-ts/BlendModesSettings.js");
const MathSettings_1 = __webpack_require__(/*! ./MathSettings */ "./js-compile/raw-pixi-ts/MathSettings.js");
const DisplaySettings_1 = __webpack_require__(/*! ./DisplaySettings */ "./js-compile/raw-pixi-ts/DisplaySettings.js");
class BatchRenderer extends ObjectRenderer_1.ObjectRenderer {
    constructor(renderer) {
        super(renderer);
        /**
         * Called before the renderer starts rendering.
         *
         */
        this.onPrerender = (event) => {
            this.vertexCount = 0;
        };
        /**
         * Number of values sent in the vertex buffer.
         * aVertexPosition(2), aTextureCoord(1), aColor(1), aTextureId(1) = 5
         *
         * @member {number}
         */
        this.vertSize = 6;
        /**
         * The size of the vertex information in bytes.
         *
         * @member {number}
         */
        this.vertByteSize = this.vertSize * 4;
        /**
         * The number of images in the SpriteRenderer before it flushes.
         *
         * @member {number}
         */
        this.size = 2000 * 4; // settings.SPRITE_BATCH_SIZE; // 2000 is a nice balance between mobile / desktop
        this.currentSize = 0;
        this.currentIndexSize = 0;
        // the total number of bytes in our batch
        // let numVerts = this.size * 4 * this.vertByteSize;
        this.attributeBuffers = {};
        this.aBuffers = {};
        this.iBuffers = {};
        //     this.defualtSpriteIndexBuffer = new Buffer(createIndicesForQuads(this.size), true, true);
        /**
         * Holds the defualt indices of the geometry (quads) to draw
         *
         * @member {Uint16Array}
         */
        // const indicies = createIndicesForQuads(this.size);
        //  this.defaultQuadIndexBuffer = new Buffer(indicies, true, true);
        this.onlySprites = false;
        /**
         * The default shaders that is used if a sprite doesn't have a more specific one.
         * there is a shader for each number of textures that can be rendered.
         * These shaders will also be generated on the fly as required.
         * @member {PIXI.Shader[]}
         */
        this.shader = null;
        this.currentIndex = 0;
        this.groups = [];
        for (var k = 0; k < this.size / 4; k++) {
            this.groups[k] = new BatchDrawCall_1.BatchDrawCall();
        }
        this.elements = [];
        this.vaos = [];
        this.vaoMax = 2;
        this.vertexCount = 0;
        this.renderer.addEventListener("prerender", this.onPrerender);
        // this.renderer.on('prerender', this.onPrerender, this);
        this.state = State_1.State.for2d();
    }
    /**
     * Sets up the renderer context and necessary buffers.
     */
    contextChange() {
        var gl = this.renderer.gl;
        if (DisplaySettings_1.DisplaySettings.PREFER_ENV === DisplaySettings_1.DisplaySettings.ENV.WEBGL_LEGACY) {
            this.MAX_TEXTURES = 1;
        }
        else {
            // step 1: first check max textures the GPU can handle.
            this.MAX_TEXTURES = Math.min(gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS), WebGLSettings_1.WebGLSettings.SPRITE_MAX_TEXTURES);
            // step 2: check the maximum number of if statements the shader can have too..
            this.MAX_TEXTURES = WebGLSettings_1.WebGLSettings.checkMaxIfStatementsInShader(this.MAX_TEXTURES, gl);
        }
        // generate generateMultiTextureProgram, may be a better move?
        this.shader = WebGLSettings_1.WebGLSettings.generateMultiTextureShader(gl, this.MAX_TEXTURES);
        // we use the second shader as the first one depending on your browser may omit aTextureId
        // as it is not used by the shader so is optimized out.
        for (var i = 0; i < this.vaoMax; i++) {
            /* eslint-disable max-len */
            this.vaos[i] = new BatchGeometry_1.BatchGeometry();
        }
    }
    ;
    /**
     * Renders the sprite object.
     *
     * @param {PIXI.Sprite} sprite - the sprite to render when using this spritebatch
     */
    render(element) {
        if (!element._texture.valid) {
            return;
        }
        if (this.currentSize + (element.vertexData.length / 2) > this.size) {
            this.flush();
        }
        this.elements[this.currentIndex++] = element;
        this.currentSize += element.vertexData.length / 2;
        this.currentIndexSize += element.indices.length;
    }
    ;
    getIndexBuffer(size) {
        // 12 indices is enough for 2 quads
        var roundedP2 = MathSettings_1.MathSettings.nextPow2(Math.ceil(size / 12));
        var roundedSizeIndex = MathSettings_1.MathSettings.log2(roundedP2);
        var roundedSize = roundedP2 * 12;
        if (this.iBuffers.length <= roundedSizeIndex) {
            this.iBuffers.length = roundedSizeIndex + 1;
        }
        var buffer = this.iBuffers[roundedSizeIndex];
        if (!buffer) {
            this.iBuffers[roundedSizeIndex] = buffer = new Uint16Array(roundedSize);
        }
        return buffer;
    }
    ;
    getAttributeBuffer(size) {
        // 8 vertices is enough for 2 quads
        var roundedP2 = MathSettings_1.MathSettings.nextPow2(Math.ceil(size / 8));
        var roundedSizeIndex = MathSettings_1.MathSettings.log2(roundedP2);
        var roundedSize = roundedP2 * 8;
        if (this.aBuffers.length <= roundedSizeIndex) {
            this.iBuffers.length = roundedSizeIndex + 1;
        }
        var buffer = this.aBuffers[roundedSize];
        if (!buffer) {
            this.aBuffers[roundedSize] = buffer = new BatchBuffer_1.BatchBuffer(roundedSize * this.vertByteSize);
        }
        return buffer;
    }
    ;
    /**
     * Renders the content and empties the current batch.
     *
     */
    flush() {
        if (this.currentSize === 0) {
            return;
        }
        var gl = this.renderer.gl;
        var MAX_TEXTURES = this.MAX_TEXTURES;
        var buffer = this.getAttributeBuffer(this.currentSize);
        var indexBuffer = this.getIndexBuffer(this.currentIndexSize);
        var elements = this.elements;
        var groups = this.groups;
        var float32View = buffer.float32View;
        var uint32View = buffer.uint32View;
        var touch = this.renderer.textureGC.count;
        var index = 0;
        var indexCount = 0;
        var nextTexture;
        var currentTexture;
        var groupCount = 0;
        var textureCount = 0;
        var currentGroup = groups[0];
        var blendMode = -1; // premultiplyBlendMode[elements[0]._texture.baseTexture.premultiplyAlpha ? 0 : ][elements[0].blendMode];
        currentGroup.textureCount = 0;
        currentGroup.start = 0;
        currentGroup.blend = blendMode;
        var TICK = ++BaseTexture_1.BaseTexture._globalBatch;
        var i;
        for (i = 0; i < this.currentIndex; ++i) {
            // upload the sprite elements...
            // they have all ready been calculated so we just need to push them into the buffer.
            var sprite = elements[i];
            elements[i] = null;
            nextTexture = sprite._texture.baseTexture;
            var spriteBlendMode = BlendModesSettings_1.BlendModesSettings.premultiplyBlendMode[nextTexture.premultiplyAlpha ? 1 : 0][sprite.blendMode];
            if (blendMode !== spriteBlendMode) {
                blendMode = spriteBlendMode;
                // force the batch to break!
                currentTexture = null;
                textureCount = MAX_TEXTURES;
                TICK++;
            }
            if (currentTexture !== nextTexture) {
                currentTexture = nextTexture;
                if (nextTexture._batchEnabled !== TICK) {
                    if (textureCount === MAX_TEXTURES) {
                        TICK++;
                        textureCount = 0;
                        currentGroup.size = indexCount - currentGroup.start;
                        currentGroup = groups[groupCount++];
                        currentGroup.textureCount = 0;
                        currentGroup.blend = blendMode;
                        currentGroup.start = indexCount;
                    }
                    nextTexture.touched = touch;
                    nextTexture._batchEnabled = TICK;
                    nextTexture._id = textureCount;
                    currentGroup.textures[currentGroup.textureCount++] = nextTexture;
                    textureCount++;
                }
            }
            this.packGeometry(sprite, float32View, uint32View, indexBuffer, index, indexCount); // argb, nextTexture._id, float32View, uint32View, indexBuffer, index, indexCount);
            // HERE 
            // push a graphics..
            index += (sprite.vertexData.length / 2) * this.vertSize;
            indexCount += sprite.indices.length;
        }
        BaseTexture_1.BaseTexture._globalBatch = TICK;
        currentGroup.size = indexCount - currentGroup.start;
        //        this.indexBuffer.update();
        if (!WebGLSettings_1.WebGLSettings.CAN_UPLOAD_SAME_BUFFER) {
            // this is still needed for IOS performance..
            // it really does not like uploading to the same buffer in a single frame!
            if (this.vaoMax <= this.vertexCount) {
                this.vaoMax++;
                /* eslint-disable max-len */
                this.vaos[this.vertexCount] = new BatchGeometry_1.BatchGeometry();
            }
            this.vaos[this.vertexCount]._buffer.update(buffer.vertices, 0);
            this.vaos[this.vertexCount]._indexBuffer.update(indexBuffer, 0);
            //   this.vertexBuffers[this.vertexCount].update(buffer.vertices, 0);
            this.renderer.geometry.bind(this.vaos[this.vertexCount]);
            this.renderer.geometry.updateBuffers();
            this.vertexCount++;
        }
        else {
            // lets use the faster option, always use buffer number 0
            this.vaos[this.vertexCount]._buffer.update(buffer.vertices, 0);
            this.vaos[this.vertexCount]._indexBuffer.update(indexBuffer, 0);
            //   if (true)// this.spriteOnly)
            // {
            // this.vaos[this.vertexCount].indexBuffer = this.defualtSpriteIndexBuffer;
            // this.vaos[this.vertexCount].buffers[1] = this.defualtSpriteIndexBuffer;
            // }
            // this.vaos[0].attributes.aColor.stride = 24
            // this.vaos[0].attributes.aColor.start = 16
            // NOT SET
            // this.vaos[0].attributes.aTextureCoord.stride = 24
            // this.vaos[0].attributes.aTextureCoord.start = 8
            // NOT SET
            // this.vaos[0].attributes.aVertexPosition.stride = 24
            // NOT SET
            this.renderer.geometry.updateBuffers();
            //    
        }
        //   this.renderer.state.set(this.state);
        var textureSystem = this.renderer.texture;
        var stateSystem = this.renderer.state;
        // e.log(groupCount);
        // / render the groups..
        for (i = 0; i < groupCount; i++) {
            var group = groups[i];
            var groupTextureCount = group.textureCount;
            for (var j = 0; j < groupTextureCount; j++) {
                textureSystem.bind(group.textures[j], j);
                group.textures[j] = null;
            }
            // this.state.blendMode = group.blend;
            // this.state.blend = true;
            // this.renderer.state.setState(this.state);
            // set the blend mode..
            stateSystem.setBlendMode(group.blend);
            gl.drawElements(group.type, group.size, gl.UNSIGNED_SHORT, group.start * 2);
        }
        // reset elements for the next flush
        this.currentIndex = 0;
        this.currentSize = 0;
        this.currentIndexSize = 0;
    }
    ;
    packGeometry(element, float32View, uint32View, indexBuffer, index, indexCount) {
        var p = index / this.vertSize; // float32View.length / 6 / 2;
        var uvs = element.uvs;
        var indicies = element.indices; // geometry.getIndex().data;// indicies;
        var vertexData = element.vertexData;
        var textureId = element._texture.baseTexture._id;
        var alpha = Math.min(element.worldAlpha, 1.0);
        var argb = alpha < 1.0 && element._texture.baseTexture.premultiplyAlpha ? ColorSettings_1.ColorSettings.premultiplyTint(element._tintRGB, alpha)
            : element._tintRGB + (alpha * 255 << 24);
        // lets not worry about tint! for now..
        for (var i = 0; i < vertexData.length; i += 2) {
            float32View[index++] = vertexData[i];
            float32View[index++] = vertexData[i + 1];
            float32View[index++] = uvs[i];
            float32View[index++] = uvs[i + 1];
            uint32View[index++] = argb;
            float32View[index++] = textureId;
        }
        for (var i$1 = 0; i$1 < indicies.length; i$1++) {
            indexBuffer[indexCount++] = p + indicies[i$1];
        }
    }
    ;
    /**
     * Starts a new sprite batch.
     */
    start() {
        this.renderer.state.setState(this.state);
        this.renderer.shader.bind(this.shader);
        if (WebGLSettings_1.WebGLSettings.CAN_UPLOAD_SAME_BUFFER) {
            // bind buffer #0, we don't need others
            this.renderer.geometry.bind(this.vaos[this.vertexCount]);
        }
    }
    ;
    /**
     * Stops and flushes the current batch.
     *
     */
    stop() {
        this.flush();
    }
    ;
    /**
     * Destroys the SpriteRenderer.
     *
     */
    destroy() {
        for (var i = 0; i < this.vaoMax; i++) {
            // if (this.vertexBuffers[i])
            // {
            //     this.vertexBuffers[i].destroy();
            // }
            if (this.vaos[i]) {
                this.vaos[i].destroy(null);
            }
        }
        if (this.indexBuffer) {
            this.indexBuffer.destroy();
        }
        this.renderer.removeEventListener('prerender', this.onPrerender);
        if (this.shader) {
            this.shader.destroy();
            this.shader = null;
        }
        // this.vertexBuffers = null;
        this.vaos = null;
        this.indexBuffer = null;
        this.indices = null;
        this.sprites = null;
        // for (let i = 0; i < this.buffers.length; ++i)
        // {
        //     this.buffers[i].destroy();
        // }
        super.destroy();
    }
    ;
}
exports.BatchRenderer = BatchRenderer;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/BatchSystem.js":
/*!***********************************************!*\
  !*** ./js-compile/raw-pixi-ts/BatchSystem.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const System_1 = __webpack_require__(/*! ./System */ "./js-compile/raw-pixi-ts/System.js");
const ObjectRenderer_1 = __webpack_require__(/*! ./ObjectRenderer */ "./js-compile/raw-pixi-ts/ObjectRenderer.js");
class BatchSystem extends System_1.System {
    constructor(renderer) {
        super(renderer);
        /**
         * An empty renderer.
         *
         * @member {PIXI.ObjectRenderer}
         */
        this.emptyRenderer = new ObjectRenderer_1.ObjectRenderer(renderer);
        /**
         * The currently active ObjectRenderer.
         *
         * @member {PIXI.ObjectRenderer}
         */
        this.currentRenderer = this.emptyRenderer;
    }
    /**
     * Changes the current renderer to the one given in parameter
     *
     * @param {PIXI.ObjectRenderer} objectRenderer - The object renderer to use.
     */
    setObjectRenderer(objectRenderer) {
        if (this.currentRenderer === objectRenderer) {
            return;
        }
        this.currentRenderer.stop();
        this.currentRenderer = objectRenderer;
        this.currentRenderer.start();
    }
    ;
    /**
     * This should be called if you wish to do some custom rendering
     * It will basically render anything that may be batched up such as sprites
     */
    flush() {
        this.setObjectRenderer(this.emptyRenderer);
    }
    ;
    /**
     * Reset the system to an empty renderer
     */
    reset() {
        this.setObjectRenderer(this.emptyRenderer);
    }
    ;
}
exports.BatchSystem = BatchSystem;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/BezierUtils.js":
/*!***********************************************!*\
  !*** ./js-compile/raw-pixi-ts/BezierUtils.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const settings_1 = __webpack_require__(/*! ./settings */ "./js-compile/raw-pixi-ts/settings.js");
class BezierUtils {
    constructor() {
    }
    static curveLength(fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY) {
        var n = 10;
        var result = 0.0;
        var t = 0.0;
        var t2 = 0.0;
        var t3 = 0.0;
        var nt = 0.0;
        var nt2 = 0.0;
        var nt3 = 0.0;
        var x = 0.0;
        var y = 0.0;
        var dx = 0.0;
        var dy = 0.0;
        var prevX = fromX;
        var prevY = fromY;
        for (var i = 1; i <= n; ++i) {
            t = i / n;
            t2 = t * t;
            t3 = t2 * t;
            nt = (1.0 - t);
            nt2 = nt * nt;
            nt3 = nt2 * nt;
            x = (nt3 * fromX) + (3.0 * nt2 * t * cpX) + (3.0 * nt * t2 * cpX2) + (t3 * toX);
            y = (nt3 * fromY) + (3.0 * nt2 * t * cpY) + (3 * nt * t2 * cpY2) + (t3 * toY);
            dx = prevX - x;
            dy = prevY - y;
            prevX = x;
            prevY = y;
            result += Math.sqrt((dx * dx) + (dy * dy));
        }
        return result;
    }
    ;
    /**
     * Calculate the points for a bezier curve and then draws it.
     *
     * Ignored from docs since it is not directly exposed.
     *
     * @ignore
     * @param {number} cpX - Control point x
     * @param {number} cpY - Control point y
     * @param {number} cpX2 - Second Control point x
     * @param {number} cpY2 - Second Control point y
     * @param {number} toX - Destination point x
     * @param {number} toY - Destination point y
     * @param {number[]} points - Path array to push points into
     */
    static curveTo(cpX, cpY, cpX2, cpY2, toX, toY, points) {
        var fromX = points[points.length - 2];
        var fromY = points[points.length - 1];
        points.length -= 2;
        var n = settings_1.settings.GRAPHICS_CURVES._segmentsCount(BezierUtils.curveLength(fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY));
        var dt = 0;
        var dt2 = 0;
        var dt3 = 0;
        var t2 = 0;
        var t3 = 0;
        points.push(fromX, fromY);
        for (var i = 1, j = 0; i <= n; ++i) {
            j = i / n;
            dt = (1 - j);
            dt2 = dt * dt;
            dt3 = dt2 * dt;
            t2 = j * j;
            t3 = t2 * j;
            points.push((dt3 * fromX) + (3 * dt2 * j * cpX) + (3 * dt * t2 * cpX2) + (t3 * toX), (dt3 * fromY) + (3 * dt2 * j * cpY) + (3 * dt * t2 * cpY2) + (t3 * toY));
        }
    }
    ;
}
exports.BezierUtils = BezierUtils;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/BitmapText.js":
/*!**********************************************!*\
  !*** ./js-compile/raw-pixi-ts/BitmapText.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Container_1 = __webpack_require__(/*! ./Container */ "./js-compile/raw-pixi-ts/Container.js");
const ObservablePoint_1 = __webpack_require__(/*! ./ObservablePoint */ "./js-compile/raw-pixi-ts/ObservablePoint.js");
const Sprite_1 = __webpack_require__(/*! ./Sprite */ "./js-compile/raw-pixi-ts/Sprite.js");
const DisplaySettings_1 = __webpack_require__(/*! ./DisplaySettings */ "./js-compile/raw-pixi-ts/DisplaySettings.js");
const UtilsSettings_1 = __webpack_require__(/*! ./UtilsSettings */ "./js-compile/raw-pixi-ts/UtilsSettings.js");
const Point_1 = __webpack_require__(/*! ../flash/geom/Point */ "./js-compile/flash/geom/Point.js");
const FlashBaseObject_1 = __webpack_require__(/*! ./FlashBaseObject */ "./js-compile/raw-pixi-ts/FlashBaseObject.js");
const FontManager_1 = __webpack_require__(/*! ./FontManager */ "./js-compile/raw-pixi-ts/FontManager.js");
class BitmapText extends Container_1.Container {
    constructor(text) {
        super();
        this.hasFont = false;
        this.bitmapfont = null;
        this._textWidth = 0;
        this._textHeight = 0;
        this._glyphs = [];
        this._font = new BitmapFontTracker();
        this._font.align = "left";
        this._font.size = 16;
        this._font.tint = 0xFFFFFF;
        this.font = null;
        this._text = text;
        this._maxWidth = 0;
        this._maxLineHeight = 0;
        this._letterSpacing = 0;
        this._anchor = new ObservablePoint_1.ObservablePoint(0, 0);
        this._anchor.scope = this;
        this._anchor.callback = function () { this.dirty = true; };
        this.dirty = false;
        this.roundPixels = DisplaySettings_1.DisplaySettings.ROUND_PIXELS;
        this.updateText();
    }
    get font() {
        return this._font.name;
    }
    ;
    set font(value) {
        if (!value) {
            return;
        }
        if (value == this._font.name) {
            return;
        }
        this._font.name = value;
        this.dirty = true;
    }
    ;
    render(renderer) {
        if (!this.bitmapfont) {
            this.bitmapfont = FontManager_1.FontManager.getBitmapFont(this._font.name);
            return;
        }
        if (this.bitmapfont && !this.hasFont) {
            this.hasFont = true;
            this.dirty = true;
            return;
        }
        super.render(renderer);
    }
    updateText() {
        if (!this.bitmapfont) {
            this.bitmapfont = FontManager_1.FontManager.getBitmapFont(this._font.name);
            return;
        }
        let scale = this._font.fontSize / this.bitmapfont.size;
        if (scale <= 0) {
            scale = 1;
        }
        let pos = Point_1.Point.getPoint();
        let chars = [];
        let lineWidths = [];
        let text = this._text.replace(/(?:\r\n|\r)/g, '\n') || ' ';
        let textLength = text.length;
        let maxWidth = this._maxWidth * this.bitmapfont.size / this._font.size;
        let prevCharCode = null;
        let lastLineWidth = 0;
        let maxLineWidth = 0;
        let line = 0;
        let lastBreakPos = -1;
        let lastBreakWidth = 0;
        let spacesRemoved = 0;
        let maxLineHeight = 0;
        for (let i = 0; i < textLength; i++) {
            let charCode = text.charCodeAt(i);
            let char = text.charAt(i);
            if ((/(?:\s)/).test(char)) {
                lastBreakPos = i;
                lastBreakWidth = lastLineWidth;
            }
            if (char === '\r' || char === '\n') {
                lineWidths.push(lastLineWidth);
                maxLineWidth = Math.max(maxLineWidth, lastLineWidth);
                ++line;
                ++spacesRemoved;
                pos.x = 0;
                pos.y += this.bitmapfont.lineHeight;
                prevCharCode = null;
                continue;
            }
            let charData = this.bitmapfont.chars[charCode];
            if (!charData) {
                continue;
            }
            if (prevCharCode && charData.kerning[prevCharCode]) {
                pos.x += charData.kerning[prevCharCode];
            }
            let glipthdata = new DataGlipth();
            glipthdata.texture = charData.texture;
            glipthdata.line = line;
            glipthdata.charCode = charCode;
            glipthdata.position = Point_1.Point.getPoint(pos.x + charData.xOffset + (this._letterSpacing / 2), pos.y + charData.yOffset);
            chars.push(glipthdata);
            pos.x += charData.xAdvance + this._letterSpacing;
            lastLineWidth = pos.x;
            maxLineHeight = Math.max(maxLineHeight, (charData.yOffset + charData.texture.height));
            prevCharCode = charCode;
            if (lastBreakPos !== -1 && maxWidth > 0 && pos.x > maxWidth) {
                ++spacesRemoved;
                UtilsSettings_1.UtilsSettings.removeItems(chars, 1 + lastBreakPos - spacesRemoved, 1 + i - lastBreakPos);
                i = lastBreakPos;
                lastBreakPos = -1;
                lineWidths.push(lastBreakWidth);
                maxLineWidth = Math.max(maxLineWidth, lastBreakWidth);
                line++;
                pos.x = 0;
                pos.y += this.bitmapfont.lineHeight;
                prevCharCode = null;
            }
        }
        let lastChar = text.charAt(text.length - 1);
        if (lastChar !== '\r' && lastChar !== '\n') {
            if ((/(?:\s)/).test(lastChar)) {
                lastLineWidth = lastBreakWidth;
            }
            lineWidths.push(lastLineWidth);
            maxLineWidth = Math.max(maxLineWidth, lastLineWidth);
        }
        let lineAlignOffsets = [];
        for (let i$1 = 0; i$1 <= line; i$1++) {
            let alignOffset = 0;
            if (this._font.align === 'right') {
                alignOffset = maxLineWidth - lineWidths[i$1];
            }
            else if (this._font.align === 'center') {
                alignOffset = (maxLineWidth - lineWidths[i$1]) / 2;
            }
            lineAlignOffsets.push(alignOffset);
        }
        let lenChars = chars.length;
        let tint = this.tint;
        for (let i$2 = 0; i$2 < lenChars; i$2++) {
            let c = this._glyphs[i$2];
            if (c) {
                c.texture = chars[i$2].texture;
            }
            else {
                c = new Sprite_1.Sprite(chars[i$2].texture);
                c.roundPixels = this.roundPixels;
                this._glyphs.push(c);
                this.addChild(c);
            }
            c.position.x = (chars[i$2].position.x + lineAlignOffsets[chars[i$2].line]) * scale;
            c.position.y = chars[i$2].position.y * scale;
            c.scale.x = c.scale.y = scale;
            c.tint = tint;
        }
        for (let i$3 = lenChars; i$3 < this._glyphs.length; ++i$3) {
            this.removeChild(this._glyphs[i$3]);
        }
        this._textWidth = maxLineWidth * scale;
        this._textHeight = (pos.y + this.bitmapfont.lineHeight) * scale;
        if (this.anchor.x !== 0 || this.anchor.y !== 0) {
            for (let i$4 = 0; i$4 < lenChars; i$4++) {
                this._glyphs[i$4].x -= this._textWidth * this.anchor.x;
                this._glyphs[i$4].y -= this._textHeight * this.anchor.y;
            }
        }
        this._maxLineHeight = maxLineHeight * scale;
        pos.recycle();
    }
    ;
    updateTransform() {
        super.updateTransform();
        this.validate();
    }
    ;
    getLocalBounds() {
        this.validate();
        return super.getLocalBounds();
    }
    ;
    validate() {
        if (this.dirty) {
            this.updateText();
            this.dirty = false;
        }
    }
    ;
    get fontSize() {
        return this._font.fontSize;
    }
    ;
    set fontSize(value) {
        this._font.fontSize = value;
        this.dirty = true;
    }
    ;
    get tint() {
        return this._font.tint;
    }
    ;
    set tint(value) {
        this._font.tint = value;
        this.dirty = true;
    }
    ;
    get align() {
        return this._font.align;
    }
    ;
    set align(value) {
        this._font.align = value || 'left';
        this.dirty = true;
    }
    ;
    get anchor() {
        return this._anchor;
    }
    ;
    set anchor(value) {
        this._anchor.copyFrom(value);
    }
    ;
    get text() {
        return this._text;
    }
    ;
    set text(text) {
        if (this._text === text) {
            return;
        }
        this._text = text;
        this.dirty = true;
    }
    ;
    get maxWidth() {
        return this._maxWidth;
    }
    ;
    set maxWidth(value) {
        if (this._maxWidth === value) {
            return;
        }
        this._maxWidth = value;
        this.dirty = true;
    }
    ;
    get maxLineHeight() {
        this.validate();
        return this._maxLineHeight;
    }
    ;
    get textWidth() {
        this.validate();
        return this._textWidth;
    }
    ;
    get letterSpacing() {
        return this._letterSpacing;
    }
    ;
    set letterSpacing(value) {
        if (this._letterSpacing !== value) {
            this._letterSpacing = value;
            this.dirty = true;
        }
    }
    ;
    get textHeight() {
        this.validate();
        return this._textHeight;
    }
    ;
}
exports.BitmapText = BitmapText;
class BitmapFontTracker extends FlashBaseObject_1.FlashBaseObject {
    constructor() {
        super(...arguments);
        this.fontSize = 16;
    }
}
class DataGlipth {
}
class FontMap {
}
class FontCharacterData {
}


/***/ }),

/***/ "./js-compile/raw-pixi-ts/BlendModesSettings.js":
/*!******************************************************!*\
  !*** ./js-compile/raw-pixi-ts/BlendModesSettings.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class BlendModesSettings {
    /**
* Corrects PixiJS blend, takes premultiplied alpha into account
*
* @memberof PIXI.utils
* @function mapPremultipliedBlendModes
* @private
* @param {Array<number[]>} [array] - The array to output into.
* @return {Array<number[]>} Mapped modes.
*/
    static mapPremultipliedBlendModes() {
        var pm = [];
        var npm = [];
        for (var i = 0; i < 32; i++) {
            pm[i] = i;
            npm[i] = i;
        }
        pm[BlendModesSettings.BLEND_MODES.NORMAL_NPM] = BlendModesSettings.BLEND_MODES.NORMAL;
        pm[BlendModesSettings.BLEND_MODES.ADD_NPM] = BlendModesSettings.BLEND_MODES.ADD;
        pm[BlendModesSettings.BLEND_MODES.SCREEN_NPM] = BlendModesSettings.BLEND_MODES.SCREEN;
        npm[BlendModesSettings.BLEND_MODES.NORMAL] = BlendModesSettings.BLEND_MODES.NORMAL_NPM;
        npm[BlendModesSettings.BLEND_MODES.ADD] = BlendModesSettings.BLEND_MODES.ADD_NPM;
        npm[BlendModesSettings.BLEND_MODES.SCREEN] = BlendModesSettings.BLEND_MODES.SCREEN_NPM;
        var array = [];
        array.push(npm);
        array.push(pm);
        return array;
    }
    /**
* changes blendMode according to texture format
*
* @memberof PIXI.utils
* @function correctBlendMode
* @param {number} blendMode supposed blend mode
* @param {boolean} premultiplied  whether source is premultiplied
* @returns {number} true blend mode for this texture
*/
    static correctBlendMode(blendMode, premultiplied) {
        return BlendModesSettings.premultiplyBlendMode[premultiplied ? 1 : 0][blendMode];
    }
    /**
* Maps gl blend combinations to WebGL.
*
* @memberof PIXI
* @function mapWebGLBlendModesToPixi
* @private
* @param {WebGLRenderingContext} gl - The rendering context.
* @param {number[][]} [array=[]] - The array to output into.
* @return {number[][]} Mapped modes.
*/
    static mapWebGLBlendModesToPixi(gl, array = []) {
        // TODO - premultiply alpha would be different.
        // add a boolean for that!
        array[BlendModesSettings.BLEND_MODES.NORMAL] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
        array[BlendModesSettings.BLEND_MODES.ADD] = [gl.ONE, gl.DST_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
        array[BlendModesSettings.BLEND_MODES.MULTIPLY] = [gl.DST_COLOR, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
        array[BlendModesSettings.BLEND_MODES.SCREEN] = [gl.ONE, gl.ONE_MINUS_SRC_COLOR, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
        array[BlendModesSettings.BLEND_MODES.OVERLAY] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
        array[BlendModesSettings.BLEND_MODES.DARKEN] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
        array[BlendModesSettings.BLEND_MODES.LIGHTEN] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
        array[BlendModesSettings.BLEND_MODES.COLOR_DODGE] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
        array[BlendModesSettings.BLEND_MODES.COLOR_BURN] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
        array[BlendModesSettings.BLEND_MODES.HARD_LIGHT] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
        array[BlendModesSettings.BLEND_MODES.SOFT_LIGHT] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
        array[BlendModesSettings.BLEND_MODES.DIFFERENCE] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
        array[BlendModesSettings.BLEND_MODES.EXCLUSION] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
        array[BlendModesSettings.BLEND_MODES.HUE] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
        array[BlendModesSettings.BLEND_MODES.SATURATION] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
        array[BlendModesSettings.BLEND_MODES.COLOR] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
        array[BlendModesSettings.BLEND_MODES.LUMINOSITY] = [gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
        array[BlendModesSettings.BLEND_MODES.NONE] = [0, 0];
        // not-premultiplied blend modes
        array[BlendModesSettings.BLEND_MODES.NORMAL_NPM] = [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
        array[BlendModesSettings.BLEND_MODES.ADD_NPM] = [gl.SRC_ALPHA, gl.DST_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
        array[BlendModesSettings.BLEND_MODES.SCREEN_NPM] = [gl.SRC_ALPHA, gl.ONE_MINUS_SRC_COLOR, gl.ONE, gl.ONE_MINUS_SRC_ALPHA];
        // composite operations
        array[BlendModesSettings.BLEND_MODES.SRC_IN] = [gl.DST_ALPHA, gl.ZERO];
        array[BlendModesSettings.BLEND_MODES.SRC_OUT] = [gl.ONE_MINUS_DST_ALPHA, gl.ZERO];
        array[BlendModesSettings.BLEND_MODES.SRC_ATOP] = [gl.DST_ALPHA, gl.ONE_MINUS_SRC_ALPHA];
        array[BlendModesSettings.BLEND_MODES.DST_OVER] = [gl.ONE_MINUS_DST_ALPHA, gl.ONE];
        array[BlendModesSettings.BLEND_MODES.DST_IN] = [gl.ZERO, gl.SRC_ALPHA];
        array[BlendModesSettings.BLEND_MODES.DST_OUT] = [gl.ZERO, gl.ONE_MINUS_SRC_ALPHA];
        array[BlendModesSettings.BLEND_MODES.DST_ATOP] = [gl.ONE_MINUS_DST_ALPHA, gl.SRC_ALPHA];
        // SUBTRACT from flash
        array[BlendModesSettings.BLEND_MODES.SUBTRACT] = [gl.ONE, gl.ONE, gl.ONE, gl.ONE, gl.FUNC_REVERSE_SUBTRACT, gl.FUNC_ADD];
        return array;
    }
}
/**
* Various blend modes supported by PIXI.
*
* IMPORTANT - The WebGL renderer only supports the NORMAL, ADD, MULTIPLY and SCREEN blend modes.
* Anything else will silently act like NORMAL.
*
* @memberof PIXI
* @name BLEND_MODES
* @enum {number}
* @property {number} NORMAL
* @property {number} ADD
* @property {number} MULTIPLY
* @property {number} SCREEN
* @property {number} OVERLAY
* @property {number} DARKEN
* @property {number} LIGHTEN
* @property {number} COLOR_DODGE
* @property {number} COLOR_BURN
* @property {number} HARD_LIGHT
* @property {number} SOFT_LIGHT
* @property {number} DIFFERENCE
* @property {number} EXCLUSION
* @property {number} HUE
* @property {number} SATURATION
* @property {number} COLOR
* @property {number} LUMINOSITY
* @property {number} NORMAL_NPM
* @property {number} ADD_NPM
* @property {number} SCREEN_NPM
* @property {number} NONE
* @property {number} SRC_IN
* @property {number} SRC_OUT
* @property {number} SRC_ATOP
* @property {number} DST_OVER
* @property {number} DST_IN
* @property {number} DST_OUT
* @property {number} DST_ATOP
* @property {number} SUBTRACT
* @property {number} SRC_OVER
* @property {number} ERASE
*/
BlendModesSettings.BLEND_MODES = {
    NORMAL: 0,
    ADD: 1,
    MULTIPLY: 2,
    SCREEN: 3,
    OVERLAY: 4,
    DARKEN: 5,
    LIGHTEN: 6,
    COLOR_DODGE: 7,
    COLOR_BURN: 8,
    HARD_LIGHT: 9,
    SOFT_LIGHT: 10,
    DIFFERENCE: 11,
    EXCLUSION: 12,
    HUE: 13,
    SATURATION: 14,
    COLOR: 15,
    LUMINOSITY: 16,
    NORMAL_NPM: 17,
    ADD_NPM: 18,
    SCREEN_NPM: 19,
    NONE: 20,
    SRC_OVER: 0,
    SRC_IN: 21,
    SRC_OUT: 22,
    SRC_ATOP: 23,
    DST_OVER: 24,
    DST_IN: 25,
    DST_OUT: 26,
    DST_ATOP: 27,
    ERASE: 26,
    SUBTRACT: 28,
};
/**
* maps premultiply flag and blendMode to adjusted blendMode
* @memberof PIXI.utils
* @const premultiplyBlendMode
* @type {Array<number[]>}
*/
BlendModesSettings.premultiplyBlendMode = BlendModesSettings.mapPremultipliedBlendModes();
exports.BlendModesSettings = BlendModesSettings;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/BlurFilter.js":
/*!**********************************************!*\
  !*** ./js-compile/raw-pixi-ts/BlurFilter.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Filter_1 = __webpack_require__(/*! ./Filter */ "./js-compile/raw-pixi-ts/Filter.js");
const BlurFilterPass_1 = __webpack_require__(/*! ./BlurFilterPass */ "./js-compile/raw-pixi-ts/BlurFilterPass.js");
const DisplaySettings_1 = __webpack_require__(/*! ./DisplaySettings */ "./js-compile/raw-pixi-ts/DisplaySettings.js");
class BlurFilter extends Filter_1.Filter {
    constructor(strength = 1, quality = 1, resolution = 1, kernelSize = 5) {
        super();
        this.blurXFilter = new BlurFilterPass_1.BlurFilterPass(true, strength, quality, resolution, kernelSize);
        this.blurYFilter = new BlurFilterPass_1.BlurFilterPass(false, strength, quality, resolution, kernelSize);
        this.resolution = resolution || DisplaySettings_1.DisplaySettings.RESOLUTION;
        this.quality = quality || 4;
        this.blur = strength || 8;
        this.repeatEdgePixels = false;
    }
    /**
     * Applies the filter.
     *
     * @param {PIXI.systems.FilterSystem} filterManager - The manager.
     * @param {PIXI.RenderTexture} input - The input target.
     * @param {PIXI.RenderTexture} output - The output target.
     */
    apply(filterManager, input, output, clear) {
        var xStrength = Math.abs(this.blurXFilter.strength);
        var yStrength = Math.abs(this.blurYFilter.strength);
        if (xStrength && yStrength) {
            var renderTarget = filterManager.getFilterTexture();
            this.blurXFilter.apply(filterManager, input, renderTarget, true);
            this.blurYFilter.apply(filterManager, renderTarget, output, clear);
            filterManager.returnFilterTexture(renderTarget);
        }
        else if (yStrength) {
            this.blurYFilter.apply(filterManager, input, output, clear);
        }
        else {
            this.blurXFilter.apply(filterManager, input, output, clear);
        }
    }
    ;
    updatePadding() {
        if (this._repeatEdgePixels) {
            this.padding = 0;
        }
        else {
            this.padding = Math.max(Math.abs(this.blurXFilter.strength), Math.abs(this.blurYFilter.strength)) * 2;
        }
    }
    ;
    /**
     * Sets the strength of both the blurX and blurY properties simultaneously
     *
     * @member {number}
     * @default 2
     */
    get blur() {
        return this.blurXFilter.blur;
    }
    ;
    set blur(value) {
        this.blurXFilter.blur = this.blurYFilter.blur = value;
        this.updatePadding();
    }
    ;
    /**
     * Sets the number of passes for blur. More passes means higher quaility bluring.
     *
     * @member {number}
     * @default 1
     */
    get quality() {
        return this.blurXFilter.quality;
    }
    ;
    set quality(value) {
        this.blurXFilter.quality = this.blurYFilter.quality = value;
    }
    ;
    /**
     * Sets the strength of the blurX property
     *
     * @member {number}
     * @default 2
     */
    get blurX() {
        return this.blurXFilter.blur;
    }
    ;
    set blurX(value) {
        this.blurXFilter.blur = value;
        this.updatePadding();
    }
    ;
    /**
     * Sets the strength of the blurY property
     *
     * @member {number}
     * @default 2
     */
    get blurY() {
        return this.blurYFilter.blur;
    }
    ;
    set blurY(value) {
        this.blurYFilter.blur = value;
        this.updatePadding();
    }
    ;
    /**
     * Sets the blendmode of the filter
     *
     * @member {number}
     * @default PIXI.BLEND_MODES.NORMAL
     */
    get blendMode() {
        return this.blurYFilter.blendMode;
    }
    ;
    set blendMode(value) {
        this.blurYFilter.blendMode = value;
    }
    ;
    /**
     * If set to true the edge of the target will be clamped
     *
     * @member {bool}
     * @default false
     */
    get repeatEdgePixels() {
        return this._repeatEdgePixels;
    }
    ;
    set repeatEdgePixels(value) {
        this._repeatEdgePixels = value;
        this.updatePadding();
    }
    ;
}
exports.BlurFilter = BlurFilter;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/BlurFilterPass.js":
/*!**************************************************!*\
  !*** ./js-compile/raw-pixi-ts/BlurFilterPass.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Filter_1 = __webpack_require__(/*! ./Filter */ "./js-compile/raw-pixi-ts/Filter.js");
const DisplaySettings_1 = __webpack_require__(/*! ./DisplaySettings */ "./js-compile/raw-pixi-ts/DisplaySettings.js");
class BlurFilterPass extends Filter_1.Filter {
    constructor(horizontal, strength, quality, resolution, kernelSize) {
        kernelSize = kernelSize || 5;
        var vertSrc = BlurFilterPass.generateBlurVertSource(kernelSize, horizontal);
        var fragSrc = BlurFilterPass.generateBlurFragSource(kernelSize);
        super(vertSrc, fragSrc);
        this.horizontal = horizontal;
        this.resolution = resolution || DisplaySettings_1.DisplaySettings.RESOLUTION;
        this._quality = 0;
        this.quality = quality || 4;
        this.blur = strength || 8;
    }
    static generateBlurFragSource(kernelSize) {
        var kernel = BlurFilterPass.GAUSSIAN_VALUES[kernelSize];
        var halfLength = kernel.length;
        var fragSource = BlurFilterPass.fragTemplate$2;
        var blurLoop = '';
        var template = 'gl_FragColor += texture2D(uSampler, vBlurTexCoords[%index%]) * %value%;';
        var value;
        for (var i = 0; i < kernelSize; i++) {
            var blur = template.replace('%index%', i.toString());
            value = i;
            if (i >= halfLength) {
                value = kernelSize - i - 1;
            }
            blur = blur.replace('%value%', kernel[value]);
            blurLoop += blur;
            blurLoop += '\n';
        }
        fragSource = fragSource.replace('%blur%', blurLoop);
        fragSource = fragSource.replace('%size%', kernelSize);
        return fragSource;
    }
    static generateBlurVertSource(kernelSize, x) {
        var halfLength = Math.ceil(kernelSize / 2);
        var vertSource = BlurFilterPass.vertTemplate;
        var blurLoop = '';
        var template;
        // let value;
        if (x) {
            template = 'vBlurTexCoords[%index%] =  textureCoord + vec2(%sampleIndex% * strength, 0.0);';
        }
        else {
            template = 'vBlurTexCoords[%index%] =  textureCoord + vec2(0.0, %sampleIndex% * strength);';
        }
        for (var i = 0; i < kernelSize; i++) {
            var blur = template.replace('%index%', i);
            // value = i;
            // if(i >= halfLength)
            // {
            //     value = kernelSize - i - 1;
            // }
            blur = blur.replace('%sampleIndex%', ((i - (halfLength - 1)) + ".0"));
            blurLoop += blur;
            blurLoop += '\n';
        }
        vertSource = vertSource.replace('%blur%', blurLoop);
        vertSource = vertSource.replace('%size%', kernelSize);
        return vertSource;
    }
    apply(filterManager, input, output, clear) {
        if (output) {
            if (this.horizontal) {
                this.uniforms.strength = (1 / output.width) * (output.width / input.width);
            }
            else {
                this.uniforms.strength = (1 / output.height) * (output.height / input.height);
            }
        }
        else {
            if (this.horizontal) // eslint-disable-line
             {
                this.uniforms.strength = (1 / filterManager.renderer.width) * (filterManager.renderer.width / input.width);
            }
            else {
                this.uniforms.strength = (1 / filterManager.renderer.height) * (filterManager.renderer.height / input.height); // eslint-disable-line
            }
        }
        // screen space!
        this.uniforms.strength *= this.strength;
        this.uniforms.strength /= this.passes;
        if (this.passes === 1) {
            filterManager.applyFilter(this, input, output, clear);
        }
        else {
            var renderTarget = filterManager.getFilterTexture();
            var renderer = filterManager.renderer;
            var flip = input;
            var flop = renderTarget;
            this.state.blend = false;
            filterManager.applyFilter(this, flip, flop, false);
            for (var i = 1; i < this.passes - 1; i++) {
                renderer.renderTexture.bind(flip, flip.filterFrame);
                this.uniforms.uSampler = flop;
                var temp = flop;
                flop = flip;
                flip = temp;
                renderer.shader.bind(this);
                renderer.geometry.draw(5);
            }
            this.state.blend = true;
            filterManager.applyFilter(this, flop, output, clear);
            filterManager.returnFilterTexture(renderTarget);
        }
    }
    ;
    /**
     * Sets the strength of both the blur.
     *
     * @member {number}
     * @default 16
     */
    get blur() {
        return this.strength;
    }
    ;
    set blur(value) {
        this.padding = 1 + (Math.abs(value) * 2);
        this.strength = value;
    }
    ;
    /**
     * Sets the quality of the blur by modifying the number of passes. More passes means higher
     * quaility bluring but the lower the performance.
     *
     * @member {number}
     * @default 4
     */
    get quality() {
        return this._quality;
    }
    ;
    set quality(value) {
        this._quality = value;
        this.passes = value;
    }
    ;
}
BlurFilterPass.GAUSSIAN_VALUES = {
    5: [0.153388, 0.221461, 0.250301],
    7: [0.071303, 0.131514, 0.189879, 0.214607],
    9: [0.028532, 0.067234, 0.124009, 0.179044, 0.20236],
    11: [0.0093, 0.028002, 0.065984, 0.121703, 0.175713, 0.198596],
    13: [0.002406, 0.009255, 0.027867, 0.065666, 0.121117, 0.174868, 0.197641],
    15: [0.000489, 0.002403, 0.009246, 0.02784, 0.065602, 0.120999, 0.174697, 0.197448],
};
BlurFilterPass.vertTemplate = "\n    attribute vec2 aVertexPosition;\n\n    uniform mat3 projectionMatrix;\n\n    uniform float strength;\n\n    varying vec2 vBlurTexCoords[%size%];\n\n    uniform vec4 inputSize;\n    uniform vec4 outputFrame;\n    \n    vec4 filterVertexPosition( void )\n    {\n        vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\n    \n        return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n    }\n    \n    vec2 filterTextureCoord( void )\n    {\n        return aVertexPosition * (outputFrame.zw * inputSize.zw);\n    }\n\n    void main(void)\n    {\n        gl_Position = filterVertexPosition();\n\n        vec2 textureCoord = filterTextureCoord();\n        %blur%\n    }";
BlurFilterPass.fragTemplate$2 = [
    'varying vec2 vBlurTexCoords[%size%];',
    'uniform sampler2D uSampler;',
    'void main(void)',
    '{',
    '    gl_FragColor = vec4(0.0);',
    '    %blur%',
    '}'
].join('\n');
exports.BlurFilterPass = BlurFilterPass;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/Bounds.js":
/*!******************************************!*\
  !*** ./js-compile/raw-pixi-ts/Bounds.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Rectangle_1 = __webpack_require__(/*! ../flash/geom/Rectangle */ "./js-compile/flash/geom/Rectangle.js");
const InstanceCounter_1 = __webpack_require__(/*! ./InstanceCounter */ "./js-compile/raw-pixi-ts/InstanceCounter.js");
const FlashBaseObject_1 = __webpack_require__(/*! ./FlashBaseObject */ "./js-compile/raw-pixi-ts/FlashBaseObject.js");
class Bounds extends FlashBaseObject_1.FlashBaseObject {
    constructor() {
        super();
        /**
         * @member {number}
         * @default 0
         */
        this.minX = Infinity;
        /**
         * @member {number}
         * @default 0
         */
        this.minY = Infinity;
        /**
         * @member {number}
         * @default 0
         */
        this.maxX = -Infinity;
        /**
         * @member {number}
         * @default 0
         */
        this.maxY = -Infinity;
        this.rect = null;
    }
    /**
 * Checks if bounds are empty.
 *
 * @return {boolean} True if empty.
 */
    isEmpty() {
        return this.minX > this.maxX || this.minY > this.maxY;
    }
    ;
    /**
     * Clears the bounds and resets.
     *
     */
    clear() {
        this.updateID++;
        this.minX = Infinity;
        this.minY = Infinity;
        this.maxX = -Infinity;
        this.maxY = -Infinity;
    }
    ;
    /**
 * Can return Rectangle.EMPTY constant, either construct new rectangle, either use your rectangle
 * It is not guaranteed that it will return tempRect
 *
 * @param {PIXI.Rectangle} rect - temporary object will be used if AABB is not empty
 * @returns {PIXI.Rectangle} A rectangle of the bounds
 */
    getRectangle(rect) {
        if (this.minX > this.maxX || this.minY > this.maxY) {
            InstanceCounter_1.InstanceCounter.addCall("Rectangle.getRectangle", "Bounds getRectangle");
            return Rectangle_1.Rectangle.getRectangle();
        }
        rect = rect;
        if (!rect) {
            InstanceCounter_1.InstanceCounter.addCall("Rectangle.getRectangle", "Bounds getRectangle");
            rect = Rectangle_1.Rectangle.getRectangle(0, 0, 1, 1);
        }
        rect.x = this.minX;
        rect.y = this.minY;
        rect.width = this.maxX - this.minX;
        rect.height = this.maxY - this.minY;
        return rect;
    }
    ;
    /**
     * This function should be inlined when its possible.
     *
     * @param {PIXI.Point} point - The point to add.
     */
    addPoint(point) {
        this.minX = Math.min(this.minX, point.x);
        this.maxX = Math.max(this.maxX, point.x);
        this.minY = Math.min(this.minY, point.y);
        this.maxY = Math.max(this.maxY, point.y);
    }
    ;
    /**
     * Adds a quad, not transformed
     *
     * @param {Float32Array} vertices - The verts to add.
     */
    addQuad(vertices) {
        var minX = this.minX;
        var minY = this.minY;
        var maxX = this.maxX;
        var maxY = this.maxY;
        var x = vertices[0];
        var y = vertices[1];
        minX = x < minX ? x : minX;
        minY = y < minY ? y : minY;
        maxX = x > maxX ? x : maxX;
        maxY = y > maxY ? y : maxY;
        x = vertices[2];
        y = vertices[3];
        minX = x < minX ? x : minX;
        minY = y < minY ? y : minY;
        maxX = x > maxX ? x : maxX;
        maxY = y > maxY ? y : maxY;
        x = vertices[4];
        y = vertices[5];
        minX = x < minX ? x : minX;
        minY = y < minY ? y : minY;
        maxX = x > maxX ? x : maxX;
        maxY = y > maxY ? y : maxY;
        x = vertices[6];
        y = vertices[7];
        minX = x < minX ? x : minX;
        minY = y < minY ? y : minY;
        maxX = x > maxX ? x : maxX;
        maxY = y > maxY ? y : maxY;
        this.minX = minX;
        this.minY = minY;
        this.maxX = maxX;
        this.maxY = maxY;
    }
    ;
    /**
     * Adds sprite frame, transformed.
     *
     * @param {PIXI.Transform} transform - TODO
     * @param {number} x0 - TODO
     * @param {number} y0 - TODO
     * @param {number} x1 - TODO
     * @param {number} y1 - TODO
     */
    addFrame(transform, x0, y0, x1, y1) {
        var matrix = transform.worldTransform;
        var a = matrix.a;
        var b = matrix.b;
        var c = matrix.c;
        var d = matrix.d;
        var tx = matrix.tx;
        var ty = matrix.ty;
        var minX = this.minX;
        var minY = this.minY;
        var maxX = this.maxX;
        var maxY = this.maxY;
        var x = (a * x0) + (c * y0) + tx;
        var y = (b * x0) + (d * y0) + ty;
        minX = x < minX ? x : minX;
        minY = y < minY ? y : minY;
        maxX = x > maxX ? x : maxX;
        maxY = y > maxY ? y : maxY;
        x = (a * x1) + (c * y0) + tx;
        y = (b * x1) + (d * y0) + ty;
        minX = x < minX ? x : minX;
        minY = y < minY ? y : minY;
        maxX = x > maxX ? x : maxX;
        maxY = y > maxY ? y : maxY;
        x = (a * x0) + (c * y1) + tx;
        y = (b * x0) + (d * y1) + ty;
        minX = x < minX ? x : minX;
        minY = y < minY ? y : minY;
        maxX = x > maxX ? x : maxX;
        maxY = y > maxY ? y : maxY;
        x = (a * x1) + (c * y1) + tx;
        y = (b * x1) + (d * y1) + ty;
        minX = x < minX ? x : minX;
        minY = y < minY ? y : minY;
        maxX = x > maxX ? x : maxX;
        maxY = y > maxY ? y : maxY;
        this.minX = minX;
        this.minY = minY;
        this.maxX = maxX;
        this.maxY = maxY;
    }
    ;
    /**
     * Adds screen vertices from array
     *
     * @param {Float32Array} vertexData - calculated vertices
     * @param {number} beginOffset - begin offset
     * @param {number} endOffset - end offset, excluded
     */
    addVertexData(vertexData, beginOffset, endOffset) {
        var minX = this.minX;
        var minY = this.minY;
        var maxX = this.maxX;
        var maxY = this.maxY;
        for (var i = beginOffset; i < endOffset; i += 2) {
            var x = vertexData[i];
            var y = vertexData[i + 1];
            minX = x < minX ? x : minX;
            minY = y < minY ? y : minY;
            maxX = x > maxX ? x : maxX;
            maxY = y > maxY ? y : maxY;
        }
        this.minX = minX;
        this.minY = minY;
        this.maxX = maxX;
        this.maxY = maxY;
    }
    ;
    /**
     * Add an array of mesh vertices
     *
     * @param {PIXI.Transform} transform - mesh transform
     * @param {Float32Array} vertices - mesh coordinates in array
     * @param {number} beginOffset - begin offset
     * @param {number} endOffset - end offset, excluded
     */
    addVertices(transform, vertices, beginOffset, endOffset) {
        var matrix = transform.worldTransform;
        var a = matrix.a;
        var b = matrix.b;
        var c = matrix.c;
        var d = matrix.d;
        var tx = matrix.tx;
        var ty = matrix.ty;
        var minX = this.minX;
        var minY = this.minY;
        var maxX = this.maxX;
        var maxY = this.maxY;
        for (var i = beginOffset; i < endOffset; i += 2) {
            var rawX = vertices[i];
            var rawY = vertices[i + 1];
            var x = (a * rawX) + (c * rawY) + tx;
            var y = (d * rawY) + (b * rawX) + ty;
            minX = x < minX ? x : minX;
            minY = y < minY ? y : minY;
            maxX = x > maxX ? x : maxX;
            maxY = y > maxY ? y : maxY;
        }
        this.minX = minX;
        this.minY = minY;
        this.maxX = maxX;
        this.maxY = maxY;
    }
    ;
    /**
     * Adds other Bounds
     *
     * @param {PIXI.Bounds} bounds - TODO
     */
    addBounds(bounds) {
        var minX = this.minX;
        var minY = this.minY;
        var maxX = this.maxX;
        var maxY = this.maxY;
        this.minX = bounds.minX < minX ? bounds.minX : minX;
        this.minY = bounds.minY < minY ? bounds.minY : minY;
        this.maxX = bounds.maxX > maxX ? bounds.maxX : maxX;
        this.maxY = bounds.maxY > maxY ? bounds.maxY : maxY;
    }
    ;
    /**
     * Adds other Bounds, masked with Bounds
     *
     * @param {PIXI.Bounds} bounds - TODO
     * @param {PIXI.Bounds} mask - TODO
     */
    addBoundsMask(bounds, mask) {
        var _minX = bounds.minX > mask.minX ? bounds.minX : mask.minX;
        var _minY = bounds.minY > mask.minY ? bounds.minY : mask.minY;
        var _maxX = bounds.maxX < mask.maxX ? bounds.maxX : mask.maxX;
        var _maxY = bounds.maxY < mask.maxY ? bounds.maxY : mask.maxY;
        if (_minX <= _maxX && _minY <= _maxY) {
            var minX = this.minX;
            var minY = this.minY;
            var maxX = this.maxX;
            var maxY = this.maxY;
            this.minX = _minX < minX ? _minX : minX;
            this.minY = _minY < minY ? _minY : minY;
            this.maxX = _maxX > maxX ? _maxX : maxX;
            this.maxY = _maxY > maxY ? _maxY : maxY;
        }
    }
    ;
    /**
     * Adds other Bounds, masked with Rectangle
     *
     * @param {PIXI.Bounds} bounds - TODO
     * @param {PIXI.Rectangle} area - TODO
     */
    addBoundsArea(bounds, area) {
        var _minX = bounds.minX > area.x ? bounds.minX : area.x;
        var _minY = bounds.minY > area.y ? bounds.minY : area.y;
        var _maxX = bounds.maxX < area.x + area.width ? bounds.maxX : (area.x + area.width);
        var _maxY = bounds.maxY < area.y + area.height ? bounds.maxY : (area.y + area.height);
        if (_minX <= _maxX && _minY <= _maxY) {
            var minX = this.minX;
            var minY = this.minY;
            var maxX = this.maxX;
            var maxY = this.maxY;
            this.minX = _minX < minX ? _minX : minX;
            this.minY = _minY < minY ? _minY : minY;
            this.maxX = _maxX > maxX ? _maxX : maxX;
            this.maxY = _maxY > maxY ? _maxY : maxY;
        }
    }
    ;
}
exports.Bounds = Bounds;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/Buffer.js":
/*!******************************************!*\
  !*** ./js-compile/raw-pixi-ts/Buffer.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Runner_1 = __webpack_require__(/*! ./Runner */ "./js-compile/raw-pixi-ts/Runner.js");
class Buffer {
    constructor(data = null, _static = false, index = null) {
        if (_static === void 0) {
            _static = true;
        }
        if (index === void 0) {
            index = false;
        }
        /**
         * The data in the buffer, as a typed array
         *
         * @member {ArrayBuffer| SharedArrayBuffer|ArrayBufferView}
         */
        this.data = data || new Float32Array(1);
        /**
         * A map of renderer IDs to webgl buffer
         *
         * @private
         * @member {object<number, GLBuffer>}
         */
        this._glBuffers = {};
        this._updateID = 0;
        this.index = index;
        this.static = _static;
        this.id = Buffer.UID++;
        this.disposeRunner = new Runner_1.Runner('disposeBuffer', 2);
        // this.disposeRunner = new Runner('disposeBuffer', 2);
    }
    // TODO could explore flagging only a partial upload?
    /**
     * flags this buffer as requiring an upload to the GPU
     */
    update(data) {
        this.data = data || this.data;
        this._updateID++;
    }
    ;
    /**
     * disposes WebGL resources that are connected to this geometry
     */
    dispose() {
        this.disposeRunner.run(this, false);
        // this.disposeRunner.run(this, false);
    }
    ;
    /**
     * Destroys the buffer
     */
    destroy() {
        this.dispose();
        this.data = null;
    }
    ;
    /**
     * Helper function that creates a buffer based on an array or TypedArray
     *
     * @static
     * @param {ArrayBufferView | number[]} data the TypedArray that the buffer will store. If this is a regular Array it will be converted to a Float32Array.
     * @return {PIXI.Buffer} A new Buffer based on the data provided.
     */
    static from(data) {
        if (data instanceof Array) {
            data = new Float32Array(data);
        }
        return new Buffer(data);
    }
    ;
}
Buffer.UID = 0;
exports.Buffer = Buffer;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/BufferResource.js":
/*!**************************************************!*\
  !*** ./js-compile/raw-pixi-ts/BufferResource.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Resource_1 = __webpack_require__(/*! ./Resource */ "./js-compile/raw-pixi-ts/Resource.js");
class BufferResource extends Resource_1.Resource {
    constructor(source, options) {
        var ref = options || {};
        var width = ref.width;
        var height = ref.height;
        if (!width || !height) {
            throw new Error('BufferResource width or height invalid');
        }
        super(width, height);
        /**
         * Source array
         * Cannot be ClampedUint8Array because it cant be uploaded to WebGL
         *
         * @member {Float32Array|Uint8Array|Uint32Array}
         */
        this.data = source;
    }
    /**
     * Upload the texture to the GPU.
     * @param {PIXI.Renderer} renderer Upload to the renderer
     * @param {PIXI.BaseTexture} baseTexture Reference to parent texture
     * @param {PIXI.GLTexture} glTexture glTexture
     * @returns {boolean} true is success
     */
    upload(renderer, baseTexture, glTexture) {
        var gl = renderer.gl;
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, baseTexture.premultiplyAlpha);
        if (glTexture.width === baseTexture.width && glTexture.height === baseTexture.height) {
            gl.texSubImage2D(baseTexture.target, 0, 0, 0, baseTexture.width, baseTexture.height, baseTexture.format, baseTexture.type, this.data);
        }
        else {
            glTexture.width = baseTexture.width;
            glTexture.height = baseTexture.height;
            var internalFormat = baseTexture.format;
            // guess sized format by type and format
            // https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/texImage2D
            if (renderer.context.webGLVersion === 2
                && baseTexture.type === renderer.gl.FLOAT
                && baseTexture.format === renderer.gl.RGBA) {
                internalFormat = renderer.gl.RGBA32F;
            }
            gl.texImage2D(baseTexture.target, 0, internalFormat, baseTexture.width, baseTexture.height, 0, baseTexture.format, baseTexture.type, this.data);
        }
        return true;
    }
    ;
    /**
     * Destroy and don't use after this
     * @override
     */
    dispose() {
        this.data = null;
    }
    ;
    /**
     * Used to auto-detect the type of resource.
     *
     * @static
     * @param {*} source - The source object
     * @return {boolean} `true` if <canvas>
     */
    static test(source) {
        return source instanceof Float32Array
            || source instanceof Uint8Array
            || source instanceof Uint32Array;
    }
    ;
}
exports.BufferResource = BufferResource;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/CacheSettings.js":
/*!*************************************************!*\
  !*** ./js-compile/raw-pixi-ts/CacheSettings.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class CacheSettings {
    static clearTextureCache() {
        var key;
        for (key in CacheSettings.TextureCache) {
            delete CacheSettings.TextureCache[key];
        }
        for (key in CacheSettings.BaseTextureCache) {
            delete CacheSettings.BaseTextureCache[key];
        }
    }
    static destroyTextureCache() {
        var key;
        for (key in CacheSettings.TextureCache) {
            CacheSettings.TextureCache[key].destroy();
        }
        for (key in CacheSettings.BaseTextureCache) {
            CacheSettings.BaseTextureCache[key].destroy();
        }
    }
}
CacheSettings.ProgramCache = {};
CacheSettings.nameCache = {};
CacheSettings.programCache = {};
CacheSettings.TextureCache = {};
CacheSettings.BaseTextureCache = {};
CacheSettings.defaultGroupCache = {};
exports.CacheSettings = CacheSettings;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/CanvasRenderTarget.js":
/*!******************************************************!*\
  !*** ./js-compile/raw-pixi-ts/CanvasRenderTarget.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const DisplaySettings_1 = __webpack_require__(/*! ./DisplaySettings */ "./js-compile/raw-pixi-ts/DisplaySettings.js");
class CanvasRenderTarget {
    constructor(width, height, resolution) {
        /**
                 * The Canvas object that belongs to this CanvasRenderTarget.
                 *
                 * @member {HTMLCanvasElement}
                 */
        this.canvas = document.createElement('canvas');
        /**
         * A CanvasRenderingContext2D object representing a two-dimensional rendering context.
         *
         * @member {CanvasRenderingContext2D}
         */
        this.context = this.canvas.getContext('2d');
        this.resolution = resolution || DisplaySettings_1.DisplaySettings.RESOLUTION;
        this.resize(width, height);
    }
    /**
     * Clears the canvas that was created by the CanvasRenderTarget class.
     *
     * @private
     */
    clear() {
        this.context.setTransform(1, 0, 0, 1, 0, 0);
        this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
    }
    ;
    /**
     * Resizes the canvas to the specified width and height.
     *
     * @param {number} width - the new width of the canvas
     * @param {number} height - the new height of the canvas
     */
    resize(width, height) {
        this.canvas.width = width * this.resolution;
        this.canvas.height = height * this.resolution;
    }
    ;
    /**
     * Destroys this canvas.
     *
     */
    destroy() {
        this.context = null;
        this.canvas = null;
    }
    ;
    /**
     * The width of the canvas buffer in pixels.
     *
     * @member {number}
     */
    get width() {
        return this.canvas.width;
    }
    ;
    set width(val) {
        this.canvas.width = val;
    }
    ;
    /**
     * The height of the canvas buffer in pixels.
     *
     * @member {number}
     */
    get height() {
        return this.canvas.height;
    }
    ;
    set height(val) {
        this.canvas.height = val;
    }
    ;
}
exports.CanvasRenderTarget = CanvasRenderTarget;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/CanvasResource.js":
/*!**************************************************!*\
  !*** ./js-compile/raw-pixi-ts/CanvasResource.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseImageResource_1 = __webpack_require__(/*! ./BaseImageResource */ "./js-compile/raw-pixi-ts/BaseImageResource.js");
class CanvasResource extends BaseImageResource_1.BaseImageResource {
    constructor(source) {
        super(source);
    }
    static test(source) {
        return (source instanceof HTMLCanvasElement);
    }
    ;
}
exports.CanvasResource = CanvasResource;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/CanvasSettings.js":
/*!**************************************************!*\
  !*** ./js-compile/raw-pixi-ts/CanvasSettings.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class CanvasSettings {
    /**
* Trim transparent borders from a canvas
*
* @memberof PIXI.utils
* @function trimCanvas
* @param {HTMLCanvasElement} canvas - the canvas to trim
* @returns {object} Trim data
*/
    static trimCanvas(canvas) {
        // https://gist.github.com/remy/784508
        var width = canvas.width;
        var height = canvas.height;
        var context = canvas.getContext('2d');
        var imageData = context.getImageData(0, 0, width, height);
        var pixels = imageData.data;
        var len = pixels.length;
        var bound = {
            top: null,
            left: null,
            right: null,
            bottom: null,
        };
        var data = null;
        var i;
        var x;
        var y;
        for (i = 0; i < len; i += 4) {
            if (pixels[i + 3] !== 0) {
                x = (i / 4) % width;
                y = ~~((i / 4) / width);
                if (bound.top === null) {
                    bound.top = y;
                }
                if (bound.left === null) {
                    bound.left = x;
                }
                else if (x < bound.left) {
                    bound.left = x;
                }
                if (bound.right === null) {
                    bound.right = x + 1;
                }
                else if (bound.right < x) {
                    bound.right = x + 1;
                }
                if (bound.bottom === null) {
                    bound.bottom = y;
                }
                else if (bound.bottom < y) {
                    bound.bottom = y;
                }
            }
        }
        if (bound.top !== null) {
            width = bound.right - bound.left;
            height = bound.bottom - bound.top + 1;
            data = context.getImageData(bound.left, bound.top, width, height);
        }
        return {
            height: height,
            width: width,
            data: data,
        };
    }
}
exports.CanvasSettings = CanvasSettings;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/Circle.js":
/*!******************************************!*\
  !*** ./js-compile/raw-pixi-ts/Circle.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Rectangle_1 = __webpack_require__(/*! ../flash/geom/Rectangle */ "./js-compile/flash/geom/Rectangle.js");
const ShapeSettings_1 = __webpack_require__(/*! ./ShapeSettings */ "./js-compile/raw-pixi-ts/ShapeSettings.js");
const InstanceCounter_1 = __webpack_require__(/*! ./InstanceCounter */ "./js-compile/raw-pixi-ts/InstanceCounter.js");
class Circle {
    constructor(x = 0, y = 0, radius = 0) {
        if (x === void 0) {
            x = 0;
        }
        if (y === void 0) {
            y = 0;
        }
        if (radius === void 0) {
            radius = 0;
        }
        /**
         * @member {number}
         * @default 0
         */
        this.x = x;
        /**
         * @member {number}
         * @default 0
         */
        this.y = y;
        /**
         * @member {number}
         * @default 0
         */
        this.radius = radius;
        /**
         * The type of the object, mainly used to avoid `instanceof` checks
         *
         * @member {number}
         * @readOnly
         * @default PIXI.SHAPES.CIRC
         * @see PIXI.SHAPES
         */
        this.type = ShapeSettings_1.ShapeSettings.SHAPES.CIRC;
    }
    /**
     * Creates a clone of this Circle instance
     *
     * @return {PIXI.Circle} a copy of the Circle
     */
    clone() {
        return new Circle(this.x, this.y, this.radius);
    }
    ;
    /**
     * Checks whether the x and y coordinates given are contained within this circle
     *
     * @param {number} x - The X coordinate of the point to test
     * @param {number} y - The Y coordinate of the point to test
     * @return {boolean} Whether the x/y coordinates are within this Circle
     */
    contains(x, y) {
        if (this.radius <= 0) {
            return false;
        }
        var r2 = this.radius * this.radius;
        var dx = (this.x - x);
        var dy = (this.y - y);
        dx *= dx;
        dy *= dy;
        return (dx + dy <= r2);
    }
    ;
    /**
    * Returns the framing rectangle of the circle as a Rectangle object
    *
    * @return {PIXI.Rectangle} the framing rectangle
    */
    getBounds() {
        InstanceCounter_1.InstanceCounter.addCall("Rectangle.getRectangle", "Circle getBounds");
        return Rectangle_1.Rectangle.getRectangle(this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2);
    }
    ;
}
exports.Circle = Circle;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/CleanUpSettings.js":
/*!***************************************************!*\
  !*** ./js-compile/raw-pixi-ts/CleanUpSettings.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class CleanUpSettings {
}
CleanUpSettings.defaultDestroyOptions = {
    texture: true,
    children: false,
    baseTexture: true,
};
exports.CleanUpSettings = CleanUpSettings;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/ColorMatrixFilter.js":
/*!*****************************************************!*\
  !*** ./js-compile/raw-pixi-ts/ColorMatrixFilter.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Filter_1 = __webpack_require__(/*! ./Filter */ "./js-compile/raw-pixi-ts/Filter.js");
const settings_1 = __webpack_require__(/*! ./settings */ "./js-compile/raw-pixi-ts/settings.js");
class ColorMatrixFilter extends Filter_1.Filter {
    constructor() {
        var uniforms = {
            m: new Float32Array([1, 0, 0, 0, 0,
                0, 1, 0, 0, 0,
                0, 0, 1, 0, 0,
                0, 0, 0, 1, 0]),
            uAlpha: 1,
        };
        super(settings_1.settings.defaultFilterVertex, ColorMatrixFilter.fragment$4, uniforms);
        this.alpha = 1;
    }
    /**
     * Transforms current matrix and set the new one
     *
     * @param {number[]} matrix - 5x4 matrix
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */
    _loadMatrix(matrix, multiply) {
        if (multiply === void 0) {
            multiply = false;
        }
        var newMatrix = matrix;
        if (multiply) {
            this._multiply(newMatrix, this.uniforms.m, matrix);
            newMatrix = this._colorMatrix(newMatrix);
        }
        // set the new matrix
        this.uniforms.m = newMatrix;
    }
    ;
    /**
     * Multiplies two mat5's
     *
     * @private
     * @param {number[]} out - 5x4 matrix the receiving matrix
     * @param {number[]} a - 5x4 matrix the first operand
     * @param {number[]} b - 5x4 matrix the second operand
     * @returns {number[]} 5x4 matrix
     */
    _multiply(out, a, b) {
        // Red Channel
        out[0] = (a[0] * b[0]) + (a[1] * b[5]) + (a[2] * b[10]) + (a[3] * b[15]);
        out[1] = (a[0] * b[1]) + (a[1] * b[6]) + (a[2] * b[11]) + (a[3] * b[16]);
        out[2] = (a[0] * b[2]) + (a[1] * b[7]) + (a[2] * b[12]) + (a[3] * b[17]);
        out[3] = (a[0] * b[3]) + (a[1] * b[8]) + (a[2] * b[13]) + (a[3] * b[18]);
        out[4] = (a[0] * b[4]) + (a[1] * b[9]) + (a[2] * b[14]) + (a[3] * b[19]) + a[4];
        // Green Channel
        out[5] = (a[5] * b[0]) + (a[6] * b[5]) + (a[7] * b[10]) + (a[8] * b[15]);
        out[6] = (a[5] * b[1]) + (a[6] * b[6]) + (a[7] * b[11]) + (a[8] * b[16]);
        out[7] = (a[5] * b[2]) + (a[6] * b[7]) + (a[7] * b[12]) + (a[8] * b[17]);
        out[8] = (a[5] * b[3]) + (a[6] * b[8]) + (a[7] * b[13]) + (a[8] * b[18]);
        out[9] = (a[5] * b[4]) + (a[6] * b[9]) + (a[7] * b[14]) + (a[8] * b[19]) + a[9];
        // Blue Channel
        out[10] = (a[10] * b[0]) + (a[11] * b[5]) + (a[12] * b[10]) + (a[13] * b[15]);
        out[11] = (a[10] * b[1]) + (a[11] * b[6]) + (a[12] * b[11]) + (a[13] * b[16]);
        out[12] = (a[10] * b[2]) + (a[11] * b[7]) + (a[12] * b[12]) + (a[13] * b[17]);
        out[13] = (a[10] * b[3]) + (a[11] * b[8]) + (a[12] * b[13]) + (a[13] * b[18]);
        out[14] = (a[10] * b[4]) + (a[11] * b[9]) + (a[12] * b[14]) + (a[13] * b[19]) + a[14];
        // Alpha Channel
        out[15] = (a[15] * b[0]) + (a[16] * b[5]) + (a[17] * b[10]) + (a[18] * b[15]);
        out[16] = (a[15] * b[1]) + (a[16] * b[6]) + (a[17] * b[11]) + (a[18] * b[16]);
        out[17] = (a[15] * b[2]) + (a[16] * b[7]) + (a[17] * b[12]) + (a[18] * b[17]);
        out[18] = (a[15] * b[3]) + (a[16] * b[8]) + (a[17] * b[13]) + (a[18] * b[18]);
        out[19] = (a[15] * b[4]) + (a[16] * b[9]) + (a[17] * b[14]) + (a[18] * b[19]) + a[19];
        return out;
    }
    ;
    /**
     * Create a Float32 Array and normalize the offset component to 0-1
     *
     * @private
     * @param {number[]} matrix - 5x4 matrix
     * @return {number[]} 5x4 matrix with all values between 0-1
     */
    _colorMatrix(matrix) {
        // Create a Float32 Array and normalize the offset component to 0-1
        var m = new Float32Array(matrix);
        m[4] /= 255;
        m[9] /= 255;
        m[14] /= 255;
        m[19] /= 255;
        return m;
    }
    ;
    /**
     * Adjusts brightness
     *
     * @param {number} b - value of the brigthness (0-1, where 0 is black)
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */
    brightness(b, multiply) {
        var matrix = [
            b, 0, 0, 0, 0,
            0, b, 0, 0, 0,
            0, 0, b, 0, 0,
            0, 0, 0, 1, 0
        ];
        this._loadMatrix(matrix, multiply);
    }
    ;
    /**
     * Set the matrices in grey scales
     *
     * @param {number} scale - value of the grey (0-1, where 0 is black)
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */
    greyscale(scale, multiply) {
        var matrix = [
            scale, scale, scale, 0, 0,
            scale, scale, scale, 0, 0,
            scale, scale, scale, 0, 0,
            0, 0, 0, 1, 0
        ];
        this._loadMatrix(matrix, multiply);
    }
    ;
    /**
     * Set the black and white matrice.
     *
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */
    blackAndWhite(multiply) {
        var matrix = [
            0.3, 0.6, 0.1, 0, 0,
            0.3, 0.6, 0.1, 0, 0,
            0.3, 0.6, 0.1, 0, 0,
            0, 0, 0, 1, 0
        ];
        this._loadMatrix(matrix, multiply);
    }
    ;
    /**
     * Set the hue property of the color
     *
     * @param {number} rotation - in degrees
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */
    hue(rotation, multiply) {
        rotation = (rotation || 0) / 180 * Math.PI;
        var cosR = Math.cos(rotation);
        var sinR = Math.sin(rotation);
        var sqrt = Math.sqrt;
        /* a good approximation for hue rotation
            This matrix is far better than the versions with magic luminance constants
            formerly used here, but also used in the starling framework (flash) and known from this
            old part of the internet: quasimondo.com/archives/000565.php

            This new matrix is based on rgb cube rotation in space. Look here for a more descriptive
            implementation as a shader not a general matrix:
            https://github.com/evanw/glfx.js/blob/58841c23919bd59787effc0333a4897b43835412/src/filters/adjust/huesaturation.js

            This is the source for the code:
            see http://stackoverflow.com/questions/8507885/shift-hue-of-an-rgb-color/8510751#8510751
            */
        var w = 1 / 3;
        var sqrW = sqrt(w); // weight is
        var a00 = cosR + ((1.0 - cosR) * w);
        var a01 = (w * (1.0 - cosR)) - (sqrW * sinR);
        var a02 = (w * (1.0 - cosR)) + (sqrW * sinR);
        var a10 = (w * (1.0 - cosR)) + (sqrW * sinR);
        var a11 = cosR + (w * (1.0 - cosR));
        var a12 = (w * (1.0 - cosR)) - (sqrW * sinR);
        var a20 = (w * (1.0 - cosR)) - (sqrW * sinR);
        var a21 = (w * (1.0 - cosR)) + (sqrW * sinR);
        var a22 = cosR + (w * (1.0 - cosR));
        var matrix = [
            a00, a01, a02, 0, 0,
            a10, a11, a12, 0, 0,
            a20, a21, a22, 0, 0,
            0, 0, 0, 1, 0
        ];
        this._loadMatrix(matrix, multiply);
    }
    ;
    /**
     * Set the contrast matrix, increase the separation between dark and bright
     * Increase contrast : shadows darker and highlights brighter
     * Decrease contrast : bring the shadows up and the highlights down
     *
     * @param {number} amount - value of the contrast (0-1)
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */
    contrast(amount, multiply) {
        var v = (amount || 0) + 1;
        var o = -0.5 * (v - 1);
        var matrix = [
            v, 0, 0, 0, o,
            0, v, 0, 0, o,
            0, 0, v, 0, o,
            0, 0, 0, 1, 0
        ];
        this._loadMatrix(matrix, multiply);
    }
    ;
    /**
     * Set the saturation matrix, increase the separation between colors
     * Increase saturation : increase contrast, brightness, and sharpness
     *
     * @param {number} amount - The saturation amount (0-1)
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */
    saturate(amount, multiply = null) {
        if (amount === void 0) {
            amount = 0;
        }
        var x = (amount * 2 / 3) + 1;
        var y = ((x - 1) * -0.5);
        var matrix = [
            x, y, y, 0, 0,
            y, x, y, 0, 0,
            y, y, x, 0, 0,
            0, 0, 0, 1, 0
        ];
        this._loadMatrix(matrix, multiply);
    }
    ;
    /**
     * Desaturate image (remove color)
     *
     * Call the saturate function
     *
     */
    desaturate() {
        this.saturate(-1);
    }
    ;
    /**
     * Negative image (inverse of classic rgb matrix)
     *
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */
    negative(multiply) {
        var matrix = [
            -1, 0, 0, 1, 0,
            0, -1, 0, 1, 0,
            0, 0, -1, 1, 0,
            0, 0, 0, 1, 0
        ];
        this._loadMatrix(matrix, multiply);
    }
    ;
    /**
     * Sepia image
     *
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */
    sepia(multiply) {
        var matrix = [
            0.393, 0.7689999, 0.18899999, 0, 0,
            0.349, 0.6859999, 0.16799999, 0, 0,
            0.272, 0.5339999, 0.13099999, 0, 0,
            0, 0, 0, 1, 0
        ];
        this._loadMatrix(matrix, multiply);
    }
    ;
    /**
     * Color motion picture process invented in 1916 (thanks Dominic Szablewski)
     *
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */
    technicolor(multiply) {
        var matrix = [
            1.9125277891456083, -0.8545344976951645, -0.09155508482755585, 0, 11.793603434377337,
            -0.3087833385928097, 1.7658908555458428, -0.10601743074722245, 0, -70.35205161461398,
            -0.231103377548616, -0.7501899197440212, 1.847597816108189, 0, 30.950940869491138,
            0, 0, 0, 1, 0
        ];
        this._loadMatrix(matrix, multiply);
    }
    ;
    /**
     * Polaroid filter
     *
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */
    polaroid(multiply) {
        var matrix = [
            1.438, -0.062, -0.062, 0, 0,
            -0.122, 1.378, -0.122, 0, 0,
            -0.016, -0.016, 1.483, 0, 0,
            0, 0, 0, 1, 0
        ];
        this._loadMatrix(matrix, multiply);
    }
    ;
    /**
     * Filter who transforms : Red -> Blue and Blue -> Red
     *
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */
    toBGR(multiply) {
        var matrix = [
            0, 0, 1, 0, 0,
            0, 1, 0, 0, 0,
            1, 0, 0, 0, 0,
            0, 0, 0, 1, 0
        ];
        this._loadMatrix(matrix, multiply);
    }
    ;
    /**
     * Color reversal film introduced by Eastman Kodak in 1935. (thanks Dominic Szablewski)
     *
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */
    kodachrome(multiply) {
        var matrix = [
            1.1285582396593525, -0.3967382283601348, -0.03992559172921793, 0, 63.72958762196502,
            -0.16404339962244616, 1.0835251566291304, -0.05498805115633132, 0, 24.732407896706203,
            -0.16786010706155763, -0.5603416277695248, 1.6014850761964943, 0, 35.62982807460946,
            0, 0, 0, 1, 0
        ];
        this._loadMatrix(matrix, multiply);
    }
    ;
    /**
     * Brown delicious browni filter (thanks Dominic Szablewski)
     *
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */
    browni(multiply) {
        var matrix = [
            0.5997023498159715, 0.34553243048391263, -0.2708298674538042, 0, 47.43192855600873,
            -0.037703249837783157, 0.8609577587992641, 0.15059552388459913, 0, -36.96841498319127,
            0.24113635128153335, -0.07441037908422492, 0.44972182064877153, 0, -7.562075277591283,
            0, 0, 0, 1, 0
        ];
        this._loadMatrix(matrix, multiply);
    }
    ;
    /**
     * Vintage filter (thanks Dominic Szablewski)
     *
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */
    vintage(multiply) {
        var matrix = [
            0.6279345635605994, 0.3202183420819367, -0.03965408211312453, 0, 9.651285835294123,
            0.02578397704808868, 0.6441188644374771, 0.03259127616149294, 0, 7.462829176470591,
            0.0466055556782719, -0.0851232987247891, 0.5241648018700465, 0, 5.159190588235296,
            0, 0, 0, 1, 0
        ];
        this._loadMatrix(matrix, multiply);
    }
    ;
    /**
     * We don't know exactly what it does, kind of gradient map, but funny to play with!
     *
     * @param {number} desaturation - Tone values.
     * @param {number} toned - Tone values.
     * @param {string} lightColor - Tone values, example: `0xFFE580`
     * @param {string} darkColor - Tone values, example: `0xFFE580`
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */
    colorTone(desaturation, toned, lightColor, darkColor, multiply) {
        desaturation = desaturation || 0.2;
        toned = toned || 0.15;
        lightColor = lightColor || 0xFFE580;
        darkColor = darkColor || 0x338000;
        var lR = ((lightColor >> 16) & 0xFF) / 255;
        var lG = ((lightColor >> 8) & 0xFF) / 255;
        var lB = (lightColor & 0xFF) / 255;
        var dR = ((darkColor >> 16) & 0xFF) / 255;
        var dG = ((darkColor >> 8) & 0xFF) / 255;
        var dB = (darkColor & 0xFF) / 255;
        var matrix = [
            0.3, 0.59, 0.11, 0, 0,
            lR, lG, lB, desaturation, 0,
            dR, dG, dB, toned, 0,
            lR - dR, lG - dG, lB - dB, 0, 0
        ];
        this._loadMatrix(matrix, multiply);
    }
    ;
    /**
     * Night effect
     *
     * @param {number} intensity - The intensity of the night effect.
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */
    night(intensity, multiply) {
        intensity = intensity || 0.1;
        var matrix = [
            intensity * (-2.0), -intensity, 0, 0, 0,
            -intensity, 0, intensity, 0, 0,
            0, intensity, intensity * 2.0, 0, 0,
            0, 0, 0, 1, 0
        ];
        this._loadMatrix(matrix, multiply);
    }
    ;
    /**
     * Predator effect
     *
     * Erase the current matrix by setting a new indepent one
     *
     * @param {number} amount - how much the predator feels his future victim
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */
    predator(amount, multiply) {
        var matrix = [
            // row 1
            11.224130630493164 * amount,
            -4.794486999511719 * amount,
            -2.8746118545532227 * amount,
            0 * amount,
            0.40342438220977783 * amount,
            // row 2
            -3.6330697536468506 * amount,
            9.193157196044922 * amount,
            -2.951810836791992 * amount,
            0 * amount,
            -1.316135048866272 * amount,
            // row 3
            -3.2184197902679443 * amount,
            -4.2375030517578125 * amount,
            7.476448059082031 * amount,
            0 * amount,
            0.8044459223747253 * amount,
            // row 4
            0, 0, 0, 1, 0
        ];
        this._loadMatrix(matrix, multiply);
    }
    ;
    /**
     * LSD effect
     *
     * Multiply the current matrix
     *
     * @param {boolean} multiply - if true, current matrix and matrix are multiplied. If false,
     *  just set the current matrix with @param matrix
     */
    lsd(multiply) {
        var matrix = [
            2, -0.4, 0.5, 0, 0,
            -0.5, 2, -0.4, 0, 0,
            -0.4, -0.5, 3, 0, 0,
            0, 0, 0, 1, 0
        ];
        this._loadMatrix(matrix, multiply);
    }
    ;
    /**
     * Erase the current matrix by setting the default one
     *
     */
    reset() {
        var matrix = [
            1, 0, 0, 0, 0,
            0, 1, 0, 0, 0,
            0, 0, 1, 0, 0,
            0, 0, 0, 1, 0
        ];
        this._loadMatrix(matrix, false);
    }
    ;
    /**
     * The matrix of the color matrix filter
     *
     * @member {number[]}
     * @default [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0]
     */
    get matrix() {
        return this.uniforms.m;
    }
    ;
    set matrix(value) {
        this.uniforms.m = value;
    }
    ;
    /**
     * The opacity value to use when mixing the original and resultant colors.
     *
     * When the value is 0, the original color is used without modification.
     * When the value is 1, the result color is used.
     * When in the range (0, 1) the color is interpolated between the original and result by this amount.
     *
     * @member {number}
     * @default 1
     */
    get alpha() {
        return this.uniforms.uAlpha;
    }
    ;
    set alpha(value) {
        this.uniforms.uAlpha = value;
    }
    ;
}
/*!
* @pixi/filter-color-matrix - v5.0.0-rc.3
* Compiled Wed, 10 Apr 2019 01:21:15 UTC
*
* @pixi/filter-color-matrix is licensed under the MIT License.
* http://www.opensource.org/licenses/mit-license
*/
ColorMatrixFilter.fragment$4 = "varying vec2 vTextureCoord;\r\nuniform sampler2D uSampler;\r\nuniform float m[20];\r\nuniform float uAlpha;\r\n\r\nvoid main(void)\r\n{\r\n    vec4 c = texture2D(uSampler, vTextureCoord);\r\n\r\n    if (uAlpha == 0.0) {\r\n        gl_FragColor = c;\r\n        return;\r\n    }\r\n\r\n    // Un-premultiply alpha before applying the color matrix. See issue #3539.\r\n    if (c.a > 0.0) {\r\n      c.rgb /= c.a;\r\n    }\r\n\r\n    vec4 result;\r\n\r\n    result.r = (m[0] * c.r);\r\n        result.r += (m[1] * c.g);\r\n        result.r += (m[2] * c.b);\r\n        result.r += (m[3] * c.a);\r\n        result.r += m[4];\r\n\r\n    result.g = (m[5] * c.r);\r\n        result.g += (m[6] * c.g);\r\n        result.g += (m[7] * c.b);\r\n        result.g += (m[8] * c.a);\r\n        result.g += m[9];\r\n\r\n    result.b = (m[10] * c.r);\r\n       result.b += (m[11] * c.g);\r\n       result.b += (m[12] * c.b);\r\n       result.b += (m[13] * c.a);\r\n       result.b += m[14];\r\n\r\n    result.a = (m[15] * c.r);\r\n       result.a += (m[16] * c.g);\r\n       result.a += (m[17] * c.b);\r\n       result.a += (m[18] * c.a);\r\n       result.a += m[19];\r\n\r\n    vec3 rgb = mix(c.rgb, result.rgb, uAlpha);\r\n\r\n    // Premultiply alpha again.\r\n    rgb *= result.a;\r\n\r\n    gl_FragColor = vec4(rgb, result.a);\r\n}\r\n";
exports.ColorMatrixFilter = ColorMatrixFilter;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/ColorSettings.js":
/*!*************************************************!*\
  !*** ./js-compile/raw-pixi-ts/ColorSettings.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const MathSettings_1 = __webpack_require__(/*! ./MathSettings */ "./js-compile/raw-pixi-ts/MathSettings.js");
class ColorSettings {
    static premultiplyTint(tint, alpha) {
        if (alpha === 1.0) {
            return (alpha * 255 << 24) + tint;
        }
        if (alpha === 0.0) {
            return 0;
        }
        var R = ((tint >> 16) & 0xFF);
        var G = ((tint >> 8) & 0xFF);
        var B = (tint & 0xFF);
        R = ((R * alpha) + 0.5) | 0;
        G = ((G * alpha) + 0.5) | 0;
        B = ((B * alpha) + 0.5) | 0;
        return (alpha * 255 << 24) + (R << 16) + (G << 8) + B;
    }
    static premultiplyTintToRgba(tint, alpha, out, premultiply) {
        out = out || new Float32Array(4);
        out[0] = ((tint >> 16) & 0xFF) / 255.0;
        out[1] = ((tint >> 8) & 0xFF) / 255.0;
        out[2] = (tint & 0xFF) / 255.0;
        if (premultiply || premultiply === undefined) {
            out[0] *= alpha;
            out[1] *= alpha;
            out[2] *= alpha;
        }
        out[3] = alpha;
        return out;
    }
    static getSingleColor(color) {
        if (typeof color === 'number') {
            return MathSettings_1.MathSettings.hex2string(color);
        }
        else if (typeof color === 'string') {
            if (color.indexOf('0x') === 0) {
                color = color.replace('0x', '#');
            }
        }
        return color;
    }
    static getColor(color) {
        if (!Array.isArray(color)) {
            return ColorSettings.getSingleColor(color);
        }
        else {
            for (var i = 0; i < color.length; ++i) {
                color[i] = ColorSettings.getSingleColor(color[i]);
            }
            return color;
        }
    }
    static premultiplyRgba(rgb, alpha, out, premultiply) {
        out = out || new Float32Array(4);
        if (premultiply || premultiply === undefined) {
            out[0] = rgb[0] * alpha;
            out[1] = rgb[1] * alpha;
            out[2] = rgb[2] * alpha;
        }
        else {
            out[0] = rgb[0];
            out[1] = rgb[1];
            out[2] = rgb[2];
        }
        out[3] = alpha;
        return out;
    }
    /**
* Converts a hexadecimal color number to an [R, G, B] array of normalized floats (numbers from 0.0 to 1.0).
*
* @example
* PIXI.utils.hex2rgb(0xffffff); // returns [1, 1, 1]
* @memberof PIXI.utils
* @function hex2rgb
* @param {number} hex - The hexadecimal number to convert
* @param  {number[]} [out=[]] If supplied, this array will be used rather than returning a new one
* @return {number[]} An array representing the [R, G, B] of the color where all values are floats.
*/
    static hex2rgb(hex, out = null) {
        out = out || [];
        out[0] = ((hex >> 16) & 0xFF) / 255;
        out[1] = ((hex >> 8) & 0xFF) / 255;
        out[2] = (hex & 0xFF) / 255;
        return out;
    }
    /**
* Converts a color as an [R, G, B] array of normalized floats to a hexadecimal number.
*
* @example
* PIXI.utils.rgb2hex([1, 1, 1]); // returns 0xffffff
* @memberof PIXI.utils
* @function rgb2hex
* @param {number[]} rgb - Array of numbers where all values are normalized floats from 0.0 to 1.0.
* @return {number} Number in hexadecimal.
*/
    static rgb2hex(rgb) {
        return (((rgb[0] * 255) << 16) + ((rgb[1] * 255) << 8) + (rgb[2] * 255 | 0));
    }
}
exports.ColorSettings = ColorSettings;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/Container.js":
/*!*********************************************!*\
  !*** ./js-compile/raw-pixi-ts/Container.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const DisplayObject_1 = __webpack_require__(/*! ./DisplayObject */ "./js-compile/raw-pixi-ts/DisplayObject.js");
const Event_1 = __webpack_require__(/*! ./Event */ "./js-compile/raw-pixi-ts/Event.js");
const UtilsSettings_1 = __webpack_require__(/*! ./UtilsSettings */ "./js-compile/raw-pixi-ts/UtilsSettings.js");
const DisplaySettings_1 = __webpack_require__(/*! ./DisplaySettings */ "./js-compile/raw-pixi-ts/DisplaySettings.js");
class Container extends DisplayObject_1.DisplayObject {
    destructor() {
        super.destructor();
        if (this.children) {
            while (this.children.length) {
                let child = this.children.shift();
                child.destructor();
            }
        }
        this.children = null;
        this.sortDirty = null;
        this.sortableChildren = null;
        this.containerUpdateTransform = null;
    }
    constructor() {
        super();
        this.containerUpdateTransform = this.updateTransform;
        /**
         * The array of children of this container.
         *
         * @member {PIXI.DisplayObject[]}
         * @readonly
         */
        this.children = [];
        /**
         * If set to true, the container will sort its children by zIndex value
         * when updateTransform() is called, or manually if sortChildren() is called.
         *
         * This actually changes the order of elements in the array, so should be treated
         * as a basic solution that is not performant compared to other solutions,
         * such as @link https://github.com/pixijs/pixi-display
         *
         * Also be aware of that this may not work nicely with the addChildAt() function,
         * as the zIndex sorting may cause the child to automatically sorted to another position.
         *
         * @see PIXI.settings.SORTABLE_CHILDREN
         *
         * @member {boolean}
         */
        this.sortableChildren = DisplaySettings_1.DisplaySettings.SORTABLE_CHILDREN;
        /**
         * Should children be sorted by zIndex at the next updateTransform call.
         * Will get automatically set to true if a new child is added, or if a child's zIndex changes.
         *
         * @member {boolean}
         */
        this.sortDirty = false;
        /**
         * Fired when a DisplayObject is added to this Container.
         *
         * @event PIXI.Container#childAdded
         * @param {PIXI.DisplayObject} child - The child added to the Container.
         * @param {PIXI.Container} container - The container that added the child.
         * @param {number} index - The children's index of the added child.
         */
        /**
         * Fired when a DisplayObject is removed from this Container.
         *
         * @event PIXI.DisplayObject#removedFrom
         * @param {PIXI.DisplayObject} child - The child removed from the Container.
         * @param {PIXI.Container} container - The container that removed removed the child.
         * @param {number} index - The former children's index of the removed child
         */
    }
    /**
 * Returns the display object in the container.
 *
 * @method getChildByName
 * @memberof PIXI.Container#
 * @param {string} name - Instance name.
 * @return {PIXI.DisplayObject} The child with the specified name.
 */
    getChildByName(name) {
        for (var i = 0; i < this.children.length; i++) {
            if (this.children[i].name === name) {
                return this.children[i];
            }
        }
        return null;
    }
    ;
    /**
     * Overridable method that can be used by Container subclasses whenever the children array is modified
     *
     * @protected
     */
    onChildrenChange(options) {
        /* empty */
    }
    ;
    /**
     * Adds one or more children to the container.
     *
     * Multiple items can be added like so: `myContainer.addChild(thingOne, thingTwo, thingThree)`
     *
     * @param {...PIXI.DisplayObject} child - The DisplayObject(s) to add to the container
     * @return {PIXI.DisplayObject} The first child that was added.
     */
    addChild(child) {
        var arguments$1 = arguments;
        var argumentsLength = arguments.length;
        // if there is only one argument we can bypass looping through the them
        if (argumentsLength > 1) {
            // loop through the arguments property and add all children
            // use it the right way (.length and [i]) so that this function can still be optimized by JS runtimes
            for (var i = 0; i < argumentsLength; i++) {
                this.addChild(arguments$1[i]);
            }
        }
        else {
            // if the child has a parent then lets remove it as PixiJS objects can only exist in one place
            if (child.parent) {
                child.parent.removeChild(child);
            }
            child.parent = this;
            this.sortDirty = true;
            // ensure child transform will be recalculated
            child.transform.parentID = -1;
            this.children.push(child);
            // ensure bounds will be recalculated
            this._boundsID++;
            // TODO - lets either do all callbacks or all events.. not both!
            this.onChildrenChange(this.children.length - 1);
            this.dispatchEvent(Event_1.Event.getEvent("childAdded"));
            // this.emit('childAdded', child, this, this.children.length - 1);
            child.dispatchEvent(Event_1.Event.getEvent("added"));
            // child.emit('added', this);
        }
        return child;
    }
    ;
    /**
     * Adds a child to the container at a specified index. If the index is out of bounds an error will be thrown
     *
     * @param {PIXI.DisplayObject} child - The child to add
     * @param {number} index - The index to place the child in
     * @return {PIXI.DisplayObject} The child that was added.
     */
    addChildAt(child, index) {
        if (index < 0 || index > this.children.length) {
            throw new Error((child + "addChildAt: The index " + index + " supplied is out of bounds " + (this.children.length)));
        }
        if (child.parent) {
            child.parent.removeChild(child);
        }
        child.parent = this;
        this.sortDirty = true;
        // ensure child transform will be recalculated
        child.transform._parentID = -1;
        this.children.splice(index, 0, child);
        // ensure bounds will be recalculated
        this._boundsID++;
        // TODO - lets either do all callbacks or all events.. not both!
        this.onChildrenChange(index);
        // child.emit('added', this);
        this.dispatchEvent(Event_1.Event.getEvent("childAdded"));
        // this.emit('childAdded', child, this, index);
        return child;
    }
    ;
    /**
     * Swaps the position of 2 Display Objects within this container.
     *
     * @param {PIXI.DisplayObject} child - First display object to swap
     * @param {PIXI.DisplayObject} child2 - Second display object to swap
     */
    swapChildren(child, child2) {
        if (child === child2) {
            return;
        }
        var index1 = this.getChildIndex(child);
        var index2 = this.getChildIndex(child2);
        this.children[index1] = child2;
        this.children[index2] = child;
        this.onChildrenChange(index1 < index2 ? index1 : index2);
    }
    ;
    /**
     * Returns the index position of a child DisplayObject instance
     *
     * @param {PIXI.DisplayObject} child - The DisplayObject instance to identify
     * @return {number} The index position of the child display object to identify
     */
    getChildIndex(child) {
        var index = this.children.indexOf(child);
        if (index === -1) {
            throw new Error('The supplied DisplayObject must be a child of the caller');
        }
        return index;
    }
    ;
    /**
     * Changes the position of an existing child in the display object container
     *
     * @param {PIXI.DisplayObject} child - The child DisplayObject instance for which you want to change the index number
     * @param {number} index - The resulting index number for the child display object
     */
    setChildIndex(child, index) {
        if (index < 0 || index >= this.children.length) {
            throw new Error(("The index " + index + " supplied is out of bounds " + (this.children.length)));
        }
        var currentIndex = this.getChildIndex(child);
        UtilsSettings_1.UtilsSettings.removeItems(this.children, currentIndex, 1); // remove from old position
        this.children.splice(index, 0, child); // add at new position
        this.onChildrenChange(index);
    }
    ;
    /**
     * Returns the child at the specified index
     *
     * @param {number} index - The index to get the child at
     * @return {PIXI.DisplayObject} The child at the given index, if any.
     */
    getChildAt(index) {
        if (index < 0 || index >= this.children.length) {
            throw new Error(("getChildAt: Index (" + index + ") does not exist."));
        }
        return this.children[index];
    }
    ;
    /**
     * Removes one or more children from the container.
     *
     * @param {...PIXI.DisplayObject} child - The DisplayObject(s) to remove
     * @return {PIXI.DisplayObject} The first child that was removed.
     */
    removeChild(child) {
        var arguments$1 = arguments;
        var argumentsLength = arguments.length;
        // if there is only one argument we can bypass looping through the them
        if (argumentsLength > 1) {
            // loop through the arguments property and add all children
            // use it the right way (.length and [i]) so that this function can still be optimized by JS runtimes
            for (var i = 0; i < argumentsLength; i++) {
                this.removeChild(arguments$1[i]);
            }
        }
        else {
            var index = this.children.indexOf(child);
            if (index === -1) {
                return null;
            }
            child.parent = null;
            // ensure child transform will be recalculated
            child.transform._parentID = -1;
            UtilsSettings_1.UtilsSettings.removeItems(this.children, index, 1);
            // ensure bounds will be recalculated
            this._boundsID++;
            // TODO - lets either do all callbacks or all events.. not both!
            this.onChildrenChange(index);
            // child.emit('removed', this);
            this.dispatchEvent(Event_1.Event.getEvent("childRemoved"));
            // this.emit('childRemoved', child, this, index);
        }
        return child;
    }
    ;
    /**
     * Removes a child from the specified index position.
     *
     * @param {number} index - The index to get the child from
     * @return {PIXI.DisplayObject} The child that was removed.
     */
    removeChildAt(index) {
        var child = this.getChildAt(index);
        // ensure child transform will be recalculated..
        child.parent = null;
        child.transform._parentID = -1;
        UtilsSettings_1.UtilsSettings.removeItems(this.children, index, 1);
        // ensure bounds will be recalculated
        this._boundsID++;
        // TODO - lets either do all callbacks or all events.. not both!
        this.onChildrenChange(index);
        // child.emit('removed', this);
        this.dispatchEvent(Event_1.Event.getEvent("childRemoved"));
        // this.emit('childRemoved', child, this, index);
        return child;
    }
    ;
    /**
     * Removes all children from this container that are within the begin and end indexes.
     *
     * @param {number} [beginIndex=0] - The beginning position.
     * @param {number} [endIndex=this.children.length] - The ending position. Default value is size of the container.
     * @returns {DisplayObject[]} List of removed children
     */
    removeChildren(beginIndex = 0, endIndex = Infinity) {
        if (beginIndex === void 0) {
            beginIndex = 0;
        }
        var begin = beginIndex;
        var end = typeof endIndex === 'number' ? endIndex : this.children.length;
        var range = end - begin;
        var removed;
        if (range > 0 && range <= end) {
            removed = this.children.splice(begin, range);
            for (var i = 0; i < removed.length; ++i) {
                removed[i].parent = null;
                if (removed[i].transform) {
                    removed[i].transform._parentID = -1;
                }
            }
            this._boundsID++;
            this.onChildrenChange(beginIndex);
            for (var i$1 = 0; i$1 < removed.length; ++i$1) {
                // removed[i$1].emit('removed', this);
                this.dispatchEvent(Event_1.Event.getEvent("childRemoved"));
                // this.emit('childRemoved', removed[i$1], this, i$1);
            }
            return removed;
        }
        else if (range === 0 && this.children.length === 0) {
            return [];
        }
        throw new RangeError('removeChildren: numeric values are outside the acceptable range.');
    }
    ;
    /**
     * Sorts children by zIndex. Previous order is mantained for 2 children with the same zIndex.
     */
    sortChildren() {
        var sortRequired = false;
        for (var i = 0, j = this.children.length; i < j; ++i) {
            var child = this.children[i];
            child._lastSortedIndex = i;
            if (!sortRequired && child.zIndex !== 0) {
                sortRequired = true;
            }
        }
        if (sortRequired && this.children.length > 1) {
            this.children.sort(Container.sortChildren);
        }
        this.sortDirty = false;
    }
    ;
    /**
     * Updates the transform on all children of this container for rendering
     */
    updateTransform() {
        if (this.sortableChildren && this.sortDirty) {
            this.sortChildren();
        }
        this._boundsID++;
        this.transform.updateTransform(this.parent.transform);
        // TODO: check render flags, how to process stuff here
        this.worldAlpha = this.alpha * this.parent.worldAlpha;
        for (var i = 0, j = this.children.length; i < j; ++i) {
            var child = this.children[i];
            if (child.visible) {
                child.updateTransform();
            }
        }
    }
    ;
    /**
     * Recalculates the bounds of the container.
     *
     */
    calculateBounds() {
        this._bounds.clear();
        this._calculateBounds();
        for (var i = 0; i < this.children.length; i++) {
            var child = this.children[i];
            if (!child.visible || !child.renderable) {
                continue;
            }
            child.calculateBounds();
            // TODO: filter+mask, need to mask both somehow
            if (child._mask) {
                child._mask.calculateBounds();
                this._bounds.addBoundsMask(child._bounds, child._mask._bounds);
            }
            else if (child.filterArea) {
                this._bounds.addBoundsArea(child._bounds, child.filterArea);
            }
            else {
                this._bounds.addBounds(child._bounds);
            }
        }
        this._lastBoundsID = this._boundsID;
    }
    ;
    /**
     * Recalculates the bounds of the object. Override this to
     * calculate the bounds of the specific object (not including children).
     *
     * @protected
     */
    _calculateBounds() {
        // FILL IN//
    }
    ;
    /**
     * Renders the object using the WebGL renderer
     *
     * @param {PIXI.Renderer} renderer - The renderer
     */
    render(renderer) {
        // if the object is not visible or the alpha is 0 then no need to render this element
        if (!this.visible || this.worldAlpha <= 0 || !this.renderable) {
            return;
        }
        // do a quick check to see if this element has a mask or a filter.
        if (this._mask || this.filters) {
            this.renderAdvanced(renderer);
        }
        else {
            this._render(renderer);
            // simple render children!
            for (var i = 0, j = this.children.length; i < j; ++i) {
                this.children[i].render(renderer);
            }
        }
    }
    ;
    /**
     * Render the object using the WebGL renderer and advanced features.
     *
     * @protected
     * @param {PIXI.Renderer} renderer - The renderer
     */
    renderAdvanced(renderer) {
        renderer.batch.flush();
        var filters = this.filters;
        var mask = this._mask;
        // push filter first as we need to ensure the stencil buffer is correct for any masking
        if (filters) {
            if (!this._enabledFilters) {
                this._enabledFilters = [];
            }
            this._enabledFilters.length = 0;
            for (var i = 0; i < filters.length; i++) {
                if (filters[i].enabled) {
                    this._enabledFilters.push(filters[i]);
                }
            }
            if (this._enabledFilters.length) {
                renderer.filter.push(this, this._enabledFilters);
            }
        }
        if (mask) {
            renderer.mask.push(this, this._mask);
        }
        // add this object to the batch, only rendered if it has a texture.
        this._render(renderer);
        // now loop through the children and make sure they get rendered
        for (var i$1 = 0, j = this.children.length; i$1 < j; i$1++) {
            this.children[i$1].render(renderer);
        }
        renderer.batch.flush();
        if (mask) {
            renderer.mask.pop(this, this._mask);
        }
        if (filters && this._enabledFilters && this._enabledFilters.length) {
            renderer.filter.pop();
        }
    }
    ;
    /**
     * To be overridden by the subclasses.
     *
     * @protected
     * @param {PIXI.Renderer} renderer - The renderer
     */
    _render(renderer) {
        // this is where content itself gets rendered...
    }
    ;
    /**
     * Removes all internal references and listeners as well as removes children from the display list.
     * Do not use a Container after calling `destroy`.
     *
     * @param {object|boolean} [options] - Options parameter. A boolean will act as if all options
     *  have been set to that value
     * @param {boolean} [options.children=false] - if set to true, all the children will have their destroy
     *  method called as well. 'options' will be passed on to those calls.
     * @param {boolean} [options.texture=false] - Only used for child Sprites if options.children is set to true
     *  Should it destroy the texture of the child sprite
     * @param {boolean} [options.baseTexture=false] - Only used for child Sprites if options.children is set to true
     *  Should it destroy the base texture of the child sprite
     */
    destroy(options) {
        super.destroy(options);
        this.sortDirty = false;
        var destroyChildren = typeof options === 'boolean' ? options : options && options.children;
        var oldChildren = this.removeChildren(0, this.children.length);
        if (destroyChildren) {
            for (var i = 0; i < oldChildren.length; ++i) {
                oldChildren[i].destroy(options);
            }
        }
    }
    ;
    /**
     * The width of the Container, setting this will actually modify the scale to achieve the value set
     *
     * @member {number}
     */
    get width() {
        return this.scale.x * this.getLocalBounds().width;
    }
    ;
    set width(value) {
        var width = this.getLocalBounds().width;
        if (width !== 0) {
            this.scale.x = value / width;
        }
        else {
            this.scale.x = 1;
        }
        this._width = value;
    }
    ;
    /**
     * The height of the Container, setting this will actually modify the scale to achieve the value set
     *
     * @member {number}
     */
    get height() {
        return this.scale.y * this.getLocalBounds().height;
    }
    ;
    set height(value) {
        var height = this.getLocalBounds().height;
        if (height !== 0) {
            this.scale.y = value / height;
        }
        else {
            this.scale.y = 1;
        }
        this._height = value;
    }
    ;
    static sortChildren(a, b) {
        if (a.zIndex === b.zIndex) {
            return a._lastSortedIndex - b._lastSortedIndex;
        }
        return a.zIndex - b.zIndex;
    }
}
exports.Container = Container;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/ContextSystem.js":
/*!*************************************************!*\
  !*** ./js-compile/raw-pixi-ts/ContextSystem.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const System_1 = __webpack_require__(/*! ./System */ "./js-compile/raw-pixi-ts/System.js");
const DisplaySettings_1 = __webpack_require__(/*! ./DisplaySettings */ "./js-compile/raw-pixi-ts/DisplaySettings.js");
class ContextSystem extends System_1.System {
    constructor(renderer) {
        super(renderer);
        /**
         * Either 1 or 2 to reflect the WebGL version being used
         * @member {number}
         * @readonly
         */
        this.webGLVersion = 1;
        /**
         * Extensions being used
         * @member {object}
         * @readonly
         * @property {WEBGL_draw_buffers} drawBuffers - WebGL v1 extension
         * @property {WEBGL_depth_texture} depthTexture - WebGL v1 extension
         * @property {OES_texture_float} floatTexture - WebGL v1 extension
         * @property {WEBGL_lose_context} loseContext - WebGL v1 extension
         * @property {OES_vertex_array_object} vertexArrayObject - WebGL v1 extension
         */
        this.extensions = {};
        // Bind functions
        this.handleContextLost = this.handleContextLost.bind(this);
        this.handleContextRestored = this.handleContextRestored.bind(this);
        renderer.view.addEventListener('webglcontextlost', this.handleContextLost, false);
        renderer.view.addEventListener('webglcontextrestored', this.handleContextRestored, false);
    }
    /**
     * `true` if the context is lost
     * @member {boolean}
     * @readonly
     */
    get isLost() {
        return (!this.gl || this.gl.isContextLost());
    }
    ;
    /**
     * Handle the context change event
     * @param {WebGLRenderingContext} gl new webgl context
     */
    contextChange(gl) {
        this.gl = gl;
        // restore a context if it was previously lost
        if (gl.isContextLost() && gl.getExtension('WEBGL_lose_context')) {
            gl.getExtension('WEBGL_lose_context').restoreContext();
        }
    }
    ;
    /**
     * Initialize the context
     *
     * @protected
     * @param {WebGLRenderingContext} gl - WebGL context
     */
    initFromContext(gl) {
        this.gl = gl;
        this.validateContext(gl);
        this.renderer.gl = gl;
        this.renderer.CONTEXT_UID = ContextSystem.CONTEXT_UID++;
        // this.dispatchEvent(Event.getEvent("contextchange"))
        this.renderer.runners.contextChange.run(gl);
    }
    ;
    /**
     * Initialize from context options
     *
     * @protected
     * @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/getContext
     * @param {object} options - context attributes
     */
    initFromOptions(options) {
        var gl = this.createContext(this.renderer.view, options);
        this.initFromContext(gl);
    }
    ;
    /**
     * Helper class to create a WebGL Context
     *
     * @param canvas {HTMLCanvasElement} the canvas element that we will get the context from
     * @param options {object} An options object that gets passed in to the canvas element containing the context attributes
     * @see https://developer.mozilla.org/en/docs/Web/API/HTMLCanvasElement/getContext
     * @return {WebGLRenderingContext} the WebGL context
     */
    createContext(canvas, options) {
        var gl;
        if (DisplaySettings_1.DisplaySettings.PREFER_ENV >= DisplaySettings_1.DisplaySettings.ENV.WEBGL2) {
            gl = canvas.getContext('webgl2', options);
        }
        if (gl) {
            this.webGLVersion = 2;
        }
        else {
            this.webGLVersion = 1;
            gl = canvas.getContext('webgl', options)
                || canvas.getContext('experimental-webgl', options);
            if (!gl) {
                // fail, not able to get a context
                throw new Error('This browser does not support WebGL. Try using the canvas renderer');
            }
        }
        this.gl = gl;
        this.getExtensions();
        return gl;
    }
    ;
    /**
     * Auto-populate the extensions
     *
     * @protected
     */
    getExtensions() {
        // time to set up default extensions that Pixi uses.
        var ref = this;
        var gl = ref.gl;
        if (this.webGLVersion === 1) {
            Object.assign(this.extensions, {
                drawBuffers: gl.getExtension('WEBGL_draw_buffers'),
                depthTexture: gl.getExtension('WEBKIT_WEBGL_depth_texture'),
                floatTexture: gl.getExtension('OES_texture_float'),
                loseContext: gl.getExtension('WEBGL_lose_context'),
                vertexArrayObject: gl.getExtension('OES_vertex_array_object')
                    || gl.getExtension('MOZ_OES_vertex_array_object')
                    || gl.getExtension('WEBKIT_OES_vertex_array_object'),
            });
        }
        // we don't use any specific WebGL 2 ones yet!
    }
    ;
    /**
     * Handles a lost webgl context
     *
     * @protected
     * @param {WebGLContextEvent} event - The context lost event.
     */
    handleContextLost(event) {
        event.preventDefault();
    }
    ;
    /**
     * Handles a restored webgl context
     *
     * @protected
     */
    handleContextRestored() {
        this.renderer.runners.contextChange.run(this.gl);
    }
    ;
    destroy() {
        var view = this.renderer.view;
        // remove listeners
        view.removeEventListener('webglcontextlost', this.handleContextLost);
        view.removeEventListener('webglcontextrestored', this.handleContextRestored);
        this.gl.useProgram(null);
        if (this.extensions.loseContext) {
            this.extensions.loseContext.loseContext();
        }
    }
    ;
    /**
     * Handle the post-render runner event
     *
     * @protected
     */
    postrender() {
        this.gl.flush();
    }
    ;
    /**
     * Validate context
     *
     * @protected
     * @param {WebGLRenderingContext} gl - Render context
     */
    validateContext(gl) {
        var attributes = gl.getContextAttributes();
        // this is going to be fairly simple for now.. but at least we have room to grow!
        if (!attributes.stencil) {
            /* eslint-disable max-len */
            /* eslint-disable no-console */
            console.warn('Provided WebGL context does not have a stencil buffer, masks may not render correctly');
            /* eslint-enable no-console */
            /* eslint-enable max-len */
        }
    }
    ;
}
ContextSystem.CONTEXT_UID = 0;
exports.ContextSystem = ContextSystem;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/CountLimiter.js":
/*!************************************************!*\
  !*** ./js-compile/raw-pixi-ts/CountLimiter.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class CountLimiter {
    constructor(maxItemsPerFrame) {
        /**
             * The maximum number of items that can be prepared each frame.
             * @type {number}
             * @private
             */
        this.maxItemsPerFrame = maxItemsPerFrame;
        /**
         * The number of items that can be prepared in the current frame.
         * @type {number}
         * @private
         */
        this.itemsLeft = 0;
    }
    /**
     * Resets any counting properties to start fresh on a new frame.
     */
    beginFrame() {
        this.itemsLeft = this.maxItemsPerFrame;
    }
    ;
    /**
     * Checks to see if another item can be uploaded. This should only be called once per item.
     * @return {boolean} If the item is allowed to be uploaded.
     */
    allowedToUpload() {
        return this.itemsLeft-- > 0;
    }
    ;
}
exports.CountLimiter = CountLimiter;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/CubeResource.js":
/*!************************************************!*\
  !*** ./js-compile/raw-pixi-ts/CubeResource.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const ArrayResource_1 = __webpack_require__(/*! ./ArrayResource */ "./js-compile/raw-pixi-ts/ArrayResource.js");
const WebGLSettings_1 = __webpack_require__(/*! ./WebGLSettings */ "./js-compile/raw-pixi-ts/WebGLSettings.js");
class CubeResource extends ArrayResource_1.ArrayResource {
    constructor(source, options) {
        super(source, options);
        options = options || {};
        if (this.length !== CubeResource.SIDES) {
            throw new Error(("Invalid length. Got " + (this.length) + ", expected 6"));
        }
        for (var i = 0; i < CubeResource.SIDES; i++) {
            this.items[i].target = WebGLSettings_1.WebGLSettings.TARGETS.TEXTURE_CUBE_MAP_POSITIVE_X + i;
        }
        if (options.autoLoad !== false) {
            this.load();
        }
    }
    /**
     * Add binding
     *
     * @override
     * @param {PIXI.BaseTexture} baseTexture - parent base texture
     */
    bind(baseTexture) {
        super.bind(baseTexture);
        baseTexture.target = WebGLSettings_1.WebGLSettings.TARGETS.TEXTURE_CUBE_MAP;
    }
    ;
    /**
     * Upload the resource
     *
     * @returns {boolean} true is success
     */
    upload(renderer, baseTexture, glTexture) {
        var dirty = this.itemDirtyIds;
        for (var i = 0; i < CubeResource.SIDES; i++) {
            var side = this.items[i];
            if (dirty[i] < side.dirtyId) {
                dirty[i] = side.dirtyId;
                if (side.valid) {
                    side.resource.upload(renderer, side, glTexture);
                }
            }
        }
        return true;
    }
    ;
}
/**
* Number of texture sides to store for CubeResources
*
* @name PIXI.resources.CubeResource.SIDES
* @static
* @member {number}
* @default 6
*/
CubeResource.SIDES = 6;
exports.CubeResource = CubeResource;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/DepthResource.js":
/*!*************************************************!*\
  !*** ./js-compile/raw-pixi-ts/DepthResource.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BufferResource_1 = __webpack_require__(/*! ./BufferResource */ "./js-compile/raw-pixi-ts/BufferResource.js");
class DepthResource extends BufferResource_1.BufferResource {
    constructor(source, options) {
        super(source, options);
    }
    upload(renderer, baseTexture, glTexture) {
        var gl = renderer.gl;
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, baseTexture.premultiplyAlpha);
        if (glTexture.width === baseTexture.width && glTexture.height === baseTexture.height) {
            gl.texSubImage2D(baseTexture.target, 0, 0, 0, baseTexture.width, baseTexture.height, baseTexture.format, baseTexture.type, this.data);
        }
        else {
            glTexture.width = baseTexture.width;
            glTexture.height = baseTexture.height;
            gl.texImage2D(baseTexture.target, 0, gl.DEPTH_COMPONENT16, // Needed for depth to render properly in webgl2.0
            baseTexture.width, baseTexture.height, 0, baseTexture.format, baseTexture.type, this.data);
        }
        return true;
    }
    ;
}
exports.DepthResource = DepthResource;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/DisplacementFilter.js":
/*!******************************************************!*\
  !*** ./js-compile/raw-pixi-ts/DisplacementFilter.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Filter_1 = __webpack_require__(/*! ./Filter */ "./js-compile/raw-pixi-ts/Filter.js");
const Matrix_1 = __webpack_require__(/*! ./Matrix */ "./js-compile/raw-pixi-ts/Matrix.js");
const Point_1 = __webpack_require__(/*! ../flash/geom/Point */ "./js-compile/flash/geom/Point.js");
class DisplacementFilter extends Filter_1.Filter {
    constructor(sprite, scale = 1) {
        var maskMatrix = new Matrix_1.Matrix();
        sprite.renderable = false;
        super(DisplacementFilter.vertex$4, DisplacementFilter.fragment$5, { mapSampler: sprite._texture, filterMatrix: maskMatrix, scale: { x: 1, y: 1 }, rotation: new Float32Array([1, 0, 0, 1]), });
        this.maskSprite = sprite;
        this.maskMatrix = maskMatrix;
        if (scale === null || scale === undefined) {
            scale = 20;
        }
        /**
         * scaleX, scaleY for displacements
         * @member {PIXI.Point}
         */
        this.scale = Point_1.Point.getPoint(scale, scale);
    }
    destructor() {
        if (this.scale) {
            this.scale.recycle();
        }
        this.scale = null;
    }
    /**
     * Applies the filter.
     *
     * @param {PIXI.systems.FilterSystem} filterManager - The manager.
     * @param {PIXI.RenderTexture} input - The input target.
     * @param {PIXI.RenderTexture} output - The output target.
     */
    apply(filterManager, input, output) {
        this.uniforms.filterMatrix = filterManager.calculateSpriteMatrix(this.maskMatrix, this.maskSprite);
        this.uniforms.scale.x = this.scale.x;
        this.uniforms.scale.y = this.scale.y;
        // Extract rotation from world transform
        var wt = this.maskSprite.transform.worldTransform;
        var lenX = Math.sqrt((wt.a * wt.a) + (wt.b * wt.b));
        var lenY = Math.sqrt((wt.c * wt.c) + (wt.d * wt.d));
        if (lenX !== 0 && lenY !== 0) {
            this.uniforms.rotation[0] = wt.a / lenX;
            this.uniforms.rotation[1] = wt.b / lenX;
            this.uniforms.rotation[2] = wt.c / lenY;
            this.uniforms.rotation[3] = wt.d / lenY;
        }
        // draw the filter...
        filterManager.applyFilter(this, input, output);
    }
    ;
    /**
     * The texture used for the displacement map. Must be power of 2 sized texture.
     *
     * @member {PIXI.Texture}
     */
    get map() {
        return this.uniforms.mapSampler;
    }
    ;
    set map(value) {
        this.uniforms.mapSampler = value;
    }
    ;
}
DisplacementFilter.fragment$5 = "varying vec2 vFilterCoord;\r\nvarying vec2 vTextureCoord;\r\n\r\nuniform vec2 scale;\r\nuniform mat2 rotation;\r\nuniform sampler2D uSampler;\r\nuniform sampler2D mapSampler;\r\n\r\nuniform highp vec4 inputSize;\r\nuniform vec4 inputClamp;\r\n\r\nvoid main(void)\r\n{\r\n  vec4 map =  texture2D(mapSampler, vFilterCoord);\r\n\r\n  map -= 0.5;\r\n  map.xy = scale * inputSize.zw * (rotation * map.xy);\r\n\r\n  gl_FragColor = texture2D(uSampler, clamp(vec2(vTextureCoord.x + map.x, vTextureCoord.y + map.y), inputClamp.xy, inputClamp.zw));\r\n}\r\n";
DisplacementFilter.vertex$4 = "attribute vec2 aVertexPosition;\r\n\r\nuniform mat3 projectionMatrix;\r\nuniform mat3 filterMatrix;\r\n\r\nvarying vec2 vTextureCoord;\r\nvarying vec2 vFilterCoord;\r\n\r\nuniform vec4 inputSize;\r\nuniform vec4 outputFrame;\r\n\r\nvec4 filterVertexPosition( void )\r\n{\r\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\r\n\r\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\r\n}\r\n\r\nvec2 filterTextureCoord( void )\r\n{\r\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\r\n}\r\n\r\nvoid main(void)\r\n{\r\n\tgl_Position = filterVertexPosition();\r\n\tvTextureCoord = filterTextureCoord();\r\n\tvFilterCoord = ( filterMatrix * vec3( vTextureCoord, 1.0)  ).xy;\r\n}\r\n";
exports.DisplacementFilter = DisplacementFilter;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/DisplayObject.js":
/*!*************************************************!*\
  !*** ./js-compile/raw-pixi-ts/DisplayObject.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const EventDispatcher_1 = __webpack_require__(/*! ./EventDispatcher */ "./js-compile/raw-pixi-ts/EventDispatcher.js");
const Rectangle_1 = __webpack_require__(/*! ../flash/geom/Rectangle */ "./js-compile/flash/geom/Rectangle.js");
const Matrix_1 = __webpack_require__(/*! ./Matrix */ "./js-compile/raw-pixi-ts/Matrix.js");
const RenderTexture_1 = __webpack_require__(/*! ./RenderTexture */ "./js-compile/raw-pixi-ts/RenderTexture.js");
const BaseTexture_1 = __webpack_require__(/*! ./BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const Texture_1 = __webpack_require__(/*! ./Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const Bounds_1 = __webpack_require__(/*! ./Bounds */ "./js-compile/raw-pixi-ts/Bounds.js");
const Transform_1 = __webpack_require__(/*! ../flash/geom/Transform */ "./js-compile/flash/geom/Transform.js");
const Point_1 = __webpack_require__(/*! ../flash/geom/Point */ "./js-compile/flash/geom/Point.js");
const MathSettings_1 = __webpack_require__(/*! ./MathSettings */ "./js-compile/raw-pixi-ts/MathSettings.js");
const DisplaySettings_1 = __webpack_require__(/*! ./DisplaySettings */ "./js-compile/raw-pixi-ts/DisplaySettings.js");
const InstanceCounter_1 = __webpack_require__(/*! ./InstanceCounter */ "./js-compile/raw-pixi-ts/InstanceCounter.js");
class DisplayObject extends EventDispatcher_1.EventDispatcher {
    constructor() {
        super();
        /*!
 * @pixi/mixin-get-child-by-name - v5.0.0-rc.3
 * Compiled Wed, 10 Apr 2019 01:21:15 UTC
 *
 * @pixi/mixin-get-child-by-name is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
        /**
         * The instance name of the object.
         *
         * @memberof PIXI.DisplayObject#
         * @member {string} name
         */
        this.name = null;
        /**
         *  Flag for if the object is accessible. If true AccessibilityManager will overlay a
         *   shadow div with attributes set
         *
         * @member {boolean}
         * @memberof PIXI.DisplayObject#
         */
        this.accessible = false;
        /**
         * Sets the title attribute of the shadow div
         * If accessibleTitle AND accessibleHint has not been this will default to 'displayObject [tabIndex]'
         *
         * @member {?string}
         * @memberof PIXI.DisplayObject#
         */
        this.accessibleTitle = null;
        /**
         * Sets the aria-label attribute of the shadow div
         *
         * @member {string}
         * @memberof PIXI.DisplayObject#
         */
        this.accessibleHint = null;
        /**
         * @member {number}
         * @memberof PIXI.DisplayObject#
         * @private
         * @todo Needs docs.
         */
        this.tabIndex = 0;
        /**
         * @member {boolean}
         * @memberof PIXI.DisplayObject#
         * @todo Needs docs.
         */
        this._accessibleActive = false;
        /**
         * @member {boolean}
         * @memberof PIXI.DisplayObject#
         * @todo Needs docs.
         */
        this._accessibleDiv = false;
        /**
        * Enable interaction events for the DisplayObject. Touch, pointer and mouse
        * events will not be emitted unless `interactive` is set to `true`.
        *
        * @example
        * const sprite = new PIXI.Sprite(texture);
        * sprite.interactive = true;
        * sprite.on('tap', (event) => {
        *    //handle event
        * });
        * @member {boolean}
        * @memberof PIXI.DisplayObject#
        */
        this.interactive = false;
        /**
         * Determines if the children to the displayObject can be clicked/touched
         * Setting this to false allows PixiJS to bypass a recursive `hitTest` function
         *
         * @member {boolean}
         * @memberof PIXI.Container#
         */
        this.interactiveChildren = true;
        /**
         * Interaction shape. Children will be hit first, then this shape will be checked.
         * Setting this will cause this shape to be checked in hit tests rather than the displayObject's bounds.
         *
         * @example
         * const sprite = new PIXI.Sprite(texture);
         * sprite.interactive = true;
         * sprite.hitArea = new PIXI.Rectangle(0, 0, 100, 100);
         * @member {PIXI.Rectangle|PIXI.Circle|PIXI.Ellipse|PIXI.Polygon|PIXI.RoundedRectangle}
         * @memberof PIXI.DisplayObject#
         */
        this.hitArea = null;
        /**
         * This defines what cursor mode is used when the mouse cursor
         * is hovered over the displayObject.
         *
         * @example
         * const sprite = new PIXI.Sprite(texture);
         * sprite.interactive = true;
         * sprite.cursor = 'wait';
         * @see https://developer.mozilla.org/en/docs/Web/CSS/cursor
         *
         * @member {string}
         * @memberof PIXI.DisplayObject#
         */
        this.cursor = null;
        /**
         * Map of all tracked pointers, by identifier. Use trackedPointers to access.
         *
         * @private
         * @type {Map<number, InteractionTrackingData>}
         */
        this._trackedPointers = undefined;
        this._cacheAsBitmap = false;
        this._cacheData = false;
        // performance increase to avoid using call.. (10x faster)
        this.displayObjectUpdateTransform = this.updateTransform;
        this.tempDisplayObjectParent = null;
        // TODO: need to create Transform from factory
        /**
         * World transform and local transform of this object.
         * This will become read-only later, please do not assign anything there unless you know what are you doing.
         *
         * @member {PIXI.Transform}
         */
        this.transform = new Transform_1.Transform();
        /**
         * The opacity of the object.
         *
         * @member {number}
         */
        this.alpha = 1;
        /**
         * The visibility of the object. If false the object will not be drawn, and
         * the updateTransform function will not be called.
         *
         * Only affects recursive calls from parent. You can ask for bounds or call updateTransform manually.
         *
         * @member {boolean}
         */
        this.visible = true;
        /**
         * Can this object be rendered, if false the object will not be drawn but the updateTransform
         * methods will still be called.
         *
         * Only affects recursive calls from parent. You can ask for bounds manually.
         *
         * @member {boolean}
         */
        this.renderable = true;
        /**
         * The display object container that contains this display object.
         *
         * @member {PIXI.Container}
         * @readonly
         */
        this.parent = null;
        /**
         * The multiplied alpha of the displayObject.
         *
         * @member {number}
         * @readonly
         */
        this.worldAlpha = 1;
        /**
         * Which index in the children array the display component was before the previous zIndex sort.
         * Used by containers to help sort objects with the same zIndex, by using previous array index as the decider.
         *
         * @member {number}
         * @protected
         */
        this._lastSortedIndex = 0;
        /**
         * The zIndex of the displayObject.
         * A higher value will mean it will be rendered on top of other displayObjects within the same container.
         *
         * @member {number}
         * @protected
         */
        this._zIndex = 0;
        /**
         * The area the filter is applied to. This is used as more of an optimization
         * rather than figuring out the dimensions of the displayObject each frame you can set this rectangle.
         *
         * Also works as an interaction mask.
         *
         * @member {?PIXI.Rectangle}
         */
        this.filterArea = null;
        /**
         * Sets the filters for the displayObject.
         * * IMPORTANT: This is a WebGL only feature and will be ignored by the canvas renderer.
         * To remove filters simply set this property to `'null'`.
         *
         * @member {?PIXI.Filter[]}
         */
        this.filters = null;
        this._enabledFilters = null;
        /**
         * The bounds object, this is used to calculate and store the bounds of the displayObject.
         *
         * @member {PIXI.Bounds}
         * @protected
         */
        this._bounds = new Bounds_1.Bounds();
        this._boundsID = 0;
        this._lastBoundsID = -1;
        this._boundsRect = null;
        this._localBoundsRect = null;
        /**
         * The original, cached mask of the object.
         *
         * @member {PIXI.Graphics|PIXI.Sprite}
         * @protected
         */
        this._mask = null;
        /**
         * Fired when this DisplayObject is added to a Container.
         *
         * @event PIXI.DisplayObject#added
         * @param {PIXI.Container} container - The container added to.
         */
        /**
         * Fired when this DisplayObject is removed from a Container.
         *
         * @event PIXI.DisplayObject#removed
         * @param {PIXI.Container} container - The container removed from.
         */
        /**
         * If the object has been destroyed via destroy(). If true, it should not be used.
         *
         * @member {boolean}
         * @protected
         */
        this._destroyed = false;
        /**
         * used to fast check if a sprite is.. a sprite!
         * @member {boolean}
         */
        this.isSprite = false;
    }
    destructor() {
        super.destructor();
        this._cacheAsBitmap = null;
        this._cacheData = null;
        this.displayObjectUpdateTransform = null;
        this.tempDisplayObjectParent = null;
        if (this.transform) {
            this.transform.recycle();
        }
        this.transform = null;
        this.alpha = null;
        this.visible = null;
        this.renderable = null;
        this.parent = null;
        this.worldAlpha = null;
        this._lastSortedIndex = null;
        this._zIndex = null;
        if (this.filterArea) {
            this.filterArea.recycle();
        }
        this.filterArea = null;
        if (this.filters && this.filters.length) {
            while (this.filters.length) {
                let filter = this.filters.shift();
                filter.destructor();
            }
        }
        this.filters = null;
        this._enabledFilters = null;
        if (this._bounds) {
            this._bounds.recycle();
        }
        this._bounds = null;
        this._boundsID = null;
        this._lastBoundsID = null;
        this._boundsRect = null;
        this._localBoundsRect = null;
        if (this._mask) {
            this._mask.destructor();
        }
        this._mask = null;
        this._destroyed = true;
        this.isSprite = null;
        this._trackedPointers = null;
        this.tempDisplayObjectParent = null;
        if (this._localBoundsRect) {
            this._localBoundsRect.recycle();
        }
        this._localBoundsRect = null;
    }
    /**
 * Internal set of all active pointers, by identifier
 *
 * @member {Map<number, InteractionTrackingData>}
 * @memberof PIXI.DisplayObject#
 * @private
 */
    get trackedPointers() {
        if (this._trackedPointers === undefined) {
            this._trackedPointers = {};
        }
        return this._trackedPointers;
    }
    /*!
 * @pixi/mixin-get-global-position - v5.0.0-rc.3
 * Compiled Wed, 10 Apr 2019 01:21:15 UTC
 *
 * @pixi/mixin-get-global-position is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 */
    /**
     * Returns the global position of the displayObject. Does not depend on object scale, rotation and pivot.
     *
     * @method getGlobalPosition
     * @memberof PIXI.DisplayObject#
     * @param {Point} point - The point to write the global value to. If null a new point will be returned
     * @param {boolean} skipUpdate - Setting to true will stop the transforms of the scene graph from
     *  being updated. This means the calculation returned MAY be out of date BUT will give you a
     *  nice performance boost.
     * @return {Point} The updated point.
     */
    getGlobalPosition(point = null, skipUpdate = false) {
        if (!point) {
            point = Point_1.Point.getPoint();
        }
        if (this.parent) {
            this.parent.toGlobal(this.position, point, skipUpdate);
        }
        else {
            point.x = this.position.x;
            point.y = this.position.y;
        }
        return point;
    }
    ;
    /**
 * If enabled, the mouse cursor use the pointer behavior when hovered over the displayObject if it is interactive
 * Setting this changes the 'cursor' property to `'pointer'`.
 *
 * @example
 * const sprite = new PIXI.Sprite(texture);
 * sprite.interactive = true;
 * sprite.buttonMode = true;
 * @member {boolean}
 * @memberof PIXI.DisplayObject#
 */
    get buttonMode() {
        return this.cursor === 'pointer';
    }
    set buttonMode(value) {
        if (value) {
            this.cursor = 'pointer';
        }
        else if (this.cursor === 'pointer') {
            this.cursor = null;
        }
    }
    /**
     * @protected
     * @member {PIXI.DisplayObject}
     */
    static mixin(source) {
        // in ES8/ES2017, this would be really easy:
        // Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        // get all the enumerable property keys
        var keys = Object.keys(source);
        // loop through properties
        for (var i = 0; i < keys.length; ++i) {
            var propertyName = keys[i];
            // Set the property using the property descriptor - this works for accessors and normal value properties
            Object.defineProperty(DisplayObject.prototype, propertyName, Object.getOwnPropertyDescriptor(source, propertyName));
        }
    }
    ;
    get _tempDisplayObjectParent() {
        if (this.tempDisplayObjectParent === null) {
            this.tempDisplayObjectParent = new DisplayObject();
        }
        return this.tempDisplayObjectParent;
    }
    ;
    /**
     * Updates the object transform for rendering.
     *
     * TODO - Optimization pass!
     */
    updateTransform() {
        this.transform.updateTransform(this.parent.transform);
        // multiply the alphas..
        this.worldAlpha = this.alpha * this.parent.worldAlpha;
        this._bounds.updateID++;
    }
    ;
    /**
     * Recursively updates transform of all objects from the root to this one
     * internal function for toLocal()
     */
    _recursivePostUpdateTransform() {
        if (this.parent) {
            this.parent._recursivePostUpdateTransform();
            this.transform.updateTransform(this.parent.transform);
        }
        else {
            this.transform.updateTransform(this._tempDisplayObjectParent.transform);
        }
    }
    ;
    /**
     * Retrieves the bounds of the displayObject as a rectangle object.
     *
     * @param {boolean} [skipUpdate] - Setting to `true` will stop the transforms of the scene graph from
     *  being updated. This means the calculation returned MAY be out of date BUT will give you a
     *  nice performance boost.
     * @param {PIXI.Rectangle} [rect] - Optional rectangle to store the result of the bounds calculation.
     * @return {PIXI.Rectangle} The rectangular bounding area.
     */
    getBounds(skipUpdate = true, rect = null) {
        if (!skipUpdate) {
            if (!this.parent) {
                this.parent = this._tempDisplayObjectParent;
                this.updateTransform();
                this.parent = null;
            }
            else {
                this._recursivePostUpdateTransform();
                this.updateTransform();
            }
        }
        if (this._boundsID !== this._lastBoundsID) {
            this.calculateBounds();
        }
        if (!rect) {
            if (!this._boundsRect) {
                InstanceCounter_1.InstanceCounter.addCall("Rectangle.getRectangle", "DisplayObject getBounds");
                this._boundsRect = Rectangle_1.Rectangle.getRectangle();
            }
            rect = this._boundsRect;
        }
        return this._bounds.getRectangle(rect);
    }
    ;
    calculateBounds() {
    }
    /**
     * Retrieves the local bounds of the displayObject as a rectangle object.
     *
     * @param {PIXI.Rectangle} [rect] - Optional rectangle to store the result of the bounds calculation.
     * @return {PIXI.Rectangle} The rectangular bounding area.
     */
    getLocalBounds(rect = null) {
        var transformRef = this.transform;
        var parentRef = this.parent;
        this.parent = null;
        this.transform = this._tempDisplayObjectParent.transform;
        if (!rect) {
            if (!this._localBoundsRect) {
                InstanceCounter_1.InstanceCounter.addCall("Rectangle.getRectangle", "DisplayObject getlocalBounds");
                this._localBoundsRect = Rectangle_1.Rectangle.getRectangle();
            }
            rect = this._localBoundsRect;
        }
        var bounds = this.getBounds(false, rect);
        this.parent = parentRef;
        this.transform = transformRef;
        return bounds;
    }
    ;
    /**
     * Calculates the global position of the display object.
     *
     * @param {PIXI.IPoint} position - The world origin to calculate from.
     * @param {PIXI.IPoint} [point] - A Point object in which to store the value, optional
     *  (otherwise will create a new Point).
     * @param {boolean} [skipUpdate=false] - Should we skip the update transform.
     * @return {PIXI.IPoint} A point object representing the position of this object.
     */
    toGlobal(position, point, skipUpdate) {
        if (skipUpdate === void 0) {
            skipUpdate = false;
        }
        if (!skipUpdate) {
            this._recursivePostUpdateTransform();
            // this parent check is for just in case the item is a root object.
            // If it is we need to give it a temporary parent so that displayObjectUpdateTransform works correctly
            // this is mainly to avoid a parent check in the main loop. Every little helps for performance :)
            if (!this.parent) {
                this.parent = this._tempDisplayObjectParent;
                this.displayObjectUpdateTransform();
                this.parent = null;
            }
            else {
                this.displayObjectUpdateTransform();
            }
        }
        // don't need to update the lot
        return this.worldTransform.apply(position, point);
    }
    ;
    /**
     * Calculates the local position of the display object relative to another point.
     *
     * @param {PIXI.IPoint} position - The world origin to calculate from.
     * @param {PIXI.DisplayObject} [from] - The DisplayObject to calculate the global position from.
     * @param {PIXI.IPoint} [point] - A Point object in which to store the value, optional
     *  (otherwise will create a new Point).
     * @param {boolean} [skipUpdate=false] - Should we skip the update transform
     * @return {PIXI.IPoint} A point object representing the position of this object
     */
    toLocal(position, from, point, skipUpdate) {
        if (from) {
            position = from.toGlobal(position, point, skipUpdate);
        }
        if (!skipUpdate) {
            this._recursivePostUpdateTransform();
            // this parent check is for just in case the item is a root object.
            // If it is we need to give it a temporary parent so that displayObjectUpdateTransform works correctly
            // this is mainly to avoid a parent check in the main loop. Every little helps for performance :)
            if (!this.parent) {
                this.parent = this._tempDisplayObjectParent;
                this.displayObjectUpdateTransform();
                this.parent = null;
            }
            else {
                this.displayObjectUpdateTransform();
            }
        }
        // simply apply the matrix..
        return this.worldTransform.applyInverse(position, point);
    }
    ;
    /**
     * Renders the object using the WebGL renderer.
     *
     * @param {PIXI.Renderer} renderer - The renderer.
     */
    render(renderer) {
        // OVERWRITE;
    }
    ;
    /**
     * Set the parent Container of this DisplayObject.
     *
     * @param {PIXI.Container} container - The Container to add this DisplayObject to.
     * @return {PIXI.Container} The Container that this DisplayObject was added to.
     */
    setParent(container) {
        if (!container || !container.addChild) {
            throw new Error('setParent: Argument must be a Container');
        }
        container.addChild(this);
        return container;
    }
    ;
    /**
     * Convenience function to set the position, scale, skew and pivot at once.
     *
     * @param {number} [x=0] - The X position
     * @param {number} [y=0] - The Y position
     * @param {number} [scaleX=1] - The X scale value
     * @param {number} [scaleY=1] - The Y scale value
     * @param {number} [rotation=0] - The rotation
     * @param {number} [skewX=0] - The X skew value
     * @param {number} [skewY=0] - The Y skew value
     * @param {number} [pivotX=0] - The X pivot value
     * @param {number} [pivotY=0] - The Y pivot value
     * @return {PIXI.DisplayObject} The DisplayObject instance
     */
    setTransform(x, y, scaleX, scaleY, rotation, skewX, skewY, pivotX, pivotY) {
        if (x === void 0) {
            x = 0;
        }
        if (y === void 0) {
            y = 0;
        }
        if (scaleX === void 0) {
            scaleX = 1;
        }
        if (scaleY === void 0) {
            scaleY = 1;
        }
        if (rotation === void 0) {
            rotation = 0;
        }
        if (skewX === void 0) {
            skewX = 0;
        }
        if (skewY === void 0) {
            skewY = 0;
        }
        if (pivotX === void 0) {
            pivotX = 0;
        }
        if (pivotY === void 0) {
            pivotY = 0;
        }
        this.position.x = x;
        this.position.y = y;
        this.scale.x = !scaleX ? 1 : scaleX;
        this.scale.y = !scaleY ? 1 : scaleY;
        this.rotation = rotation;
        this.skew.x = skewX;
        this.skew.y = skewY;
        this.pivot.x = pivotX;
        this.pivot.y = pivotY;
        return this;
    }
    ;
    /**
     * Base destroy method for generic display objects. This will automatically
     * remove the display object from its parent Container as well as remove
     * all current event listeners and internal references. Do not use a DisplayObject
     * after calling `destroy()`.
     *
     */
    destroy(options = null) {
        // this.removeAllListeners();
        if (this.parent) {
            this.parent.removeChild(this);
        }
        this.transform = null;
        this.parent = null;
        this._bounds = null;
        this._currentBounds = null;
        this._mask = null;
        this.filterArea = null;
        this.interactive = false;
        this.interactiveChildren = false;
        this._destroyed = true;
    }
    ;
    /**
     * The position of the displayObject on the x axis relative to the local coordinates of the parent.
     * An alias to position.x
     *
     * @member {number}
     */
    get x() {
        return this.position.x;
    }
    ;
    set x(value) {
        this.transform.position.x = value;
    }
    ;
    /**
     * The position of the displayObject on the y axis relative to the local coordinates of the parent.
     * An alias to position.y
     *
     * @member {number}
     */
    get y() {
        return this.position.y;
    }
    ;
    set y(value) {
        this.transform.position.y = value;
    }
    ;
    /**
     * Current transform of the object based on world (parent) factors.
     *
     * @member {PIXI.Matrix}
     * @readonly
     */
    get worldTransform() {
        return this.transform.worldTransform;
    }
    ;
    /**
     * Current transform of the object based on local factors: position, scale, other stuff.
     *
     * @member {PIXI.Matrix}
     * @readonly
     */
    get localTransform() {
        return this.transform.localTransform;
    }
    ;
    /**
     * The coordinate of the object relative to the local coordinates of the parent.
     * Assignment by value since pixi-v4.
     *
     * @member {PIXI.IPoint}
     */
    get position() {
        return this.transform.position;
    }
    ;
    set position(value) {
        this.transform.position.copyFrom(value);
    }
    ;
    /**
     * The scale factor of the object.
     * Assignment by value since pixi-v4.
     *
     * @member {PIXI.IPoint}
     */
    get scale() {
        return this.transform.scale;
    }
    ;
    set scale(value) {
        this.transform.scale.copyFrom(value);
    }
    ;
    /**
     * The pivot point of the displayObject that it rotates around.
     * Assignment by value since pixi-v4.
     *
     * @member {PIXI.IPoint}
     */
    get pivot() {
        return this.transform.pivot;
    }
    ;
    set pivot(value) {
        this.transform.pivot.copyFrom(value);
    }
    ;
    /**
     * The skew factor for the object in radians.
     * Assignment by value since pixi-v4.
     *
     * @member {PIXI.ObservablePoint}
     */
    get skew() {
        return this.transform.skew;
    }
    ;
    set skew(value) {
        this.transform.skew.copyFrom(value);
    }
    ;
    /**
     * The rotation of the object in radians.
     * 'rotation' and 'angle' have the same effect on a display object; rotation is in radians, angle is in degrees.
     *
     * @member {number}
     */
    get rotation() {
        return this.transform.rotation;
    }
    ;
    set rotation(value) {
        this.transform.rotation = value;
    }
    ;
    /**
     * The angle of the object in degrees.
     * 'rotation' and 'angle' have the same effect on a display object; rotation is in radians, angle is in degrees.
     *
     * @member {number}
     */
    get angle() {
        return this.transform.rotation * MathSettings_1.MathSettings.RAD_TO_DEG;
    }
    ;
    set angle(value) {
        this.transform.rotation = value * MathSettings_1.MathSettings.DEG_TO_RAD;
    }
    ;
    /**
     * The zIndex of the displayObject.
     * If a container has the sortableChildren property set to true, children will be automatically
     * sorted by zIndex value; a higher value will mean it will be moved towards the end of the array,
     * and thus rendered on top of other displayObjects within the same container.
     *
     * @member {number}
     */
    get zIndex() {
        return this._zIndex;
    }
    ;
    set zIndex(value) {
        this._zIndex = value;
        if (this.parent) {
            this.parent.sortDirty = true;
        }
    }
    ;
    /**
     * Indicates if the object is globally visible.
     *
     * @member {boolean}
     * @readonly
     */
    get worldVisible() {
        var item = this;
        do {
            if (!item.visible) {
                return false;
            }
            item = item.parent;
        } while (item);
        return true;
    }
    ;
    /**
     * Sets a mask for the displayObject. A mask is an object that limits the visibility of an
     * object to the shape of the mask applied to it. In PixiJS a regular mask must be a
     * {@link PIXI.Graphics} or a {@link PIXI.Sprite} object. This allows for much faster masking in canvas as it
     * utilities shape clipping. To remove a mask, set this property to `null`.
     *
     * For sprite mask both alpha and red channel are used. Black mask is the same as transparent mask.
     * @example
     * const graphics = new PIXI.Graphics();
     * graphics.beginFill(0xFF3300);
     * graphics.drawRect(50, 250, 100, 100);
     * graphics.endFill();
     *
     * const sprite = new PIXI.Sprite(texture);
     * sprite.mask = graphics;
     * @todo At the moment, PIXI.CanvasRenderer doesn't support PIXI.Sprite as mask.
     *
     * @member {PIXI.Graphics|PIXI.Sprite}
     */
    get mask() {
        return this._mask;
    }
    ;
    set mask(value) {
        if (this._mask) {
            this._mask.renderable = true;
            this._mask.isMask = false;
        }
        this._mask = value;
        if (this._mask) {
            this._mask.renderable = false;
            this._mask.isMask = true;
        }
    }
    ;
    /**
             * Set this to true if you want this display object to be cached as a bitmap.
             * This basically takes a snap shot of the display object as it is at that moment. It can
             * provide a performance benefit for complex static displayObjects.
             * To remove simply set this property to `false`
             *
             * IMPORTANT GOTCHA - Make sure that all your textures are preloaded BEFORE setting this property to true
             * as it will take a snapshot of what is currently there. If the textures have not loaded then they will not appear.
             *
             * @member {boolean}
             * @memberof PIXI.DisplayObject#
             */
    get cacheAsBitmap() {
        return this._cacheAsBitmap;
    }
    set cacheAsBitmap(value) {
        if (this._cacheAsBitmap === value) {
            return;
        }
        this._cacheAsBitmap = value;
        var data;
        if (value) {
            if (!this._cacheData) {
                this._cacheData = new CacheData();
            }
            data = this._cacheData;
            data.originalRender = this.render;
            data.originalRenderCanvas = this.renderCanvas;
            data.originalUpdateTransform = this.updateTransform;
            data.originalCalculateBounds = this.calculateBounds;
            data.originalGetLocalBounds = this.getLocalBounds;
            data.originalDestroy = this.destroy;
            data.originalContainsPoint = this.containsPoint;
            data.originalMask = this._mask;
            data.originalFilterArea = this.filterArea;
            this.render = this._renderCached;
            this.renderCanvas = this._renderCachedCanvas;
            this.destroy = this._cacheAsBitmapDestroy;
        }
        else {
            data = this._cacheData;
            if (data.sprite) {
                this._destroyCachedDisplayObject();
            }
            this.render = data.originalRender;
            this.renderCanvas = data.originalRenderCanvas;
            this.calculateBounds = data.originalCalculateBounds;
            this.getLocalBounds = data.originalGetLocalBounds;
            this.destroy = data.originalDestroy;
            this.updateTransform = data.originalUpdateTransform;
            this.containsPoint = data.originalContainsPoint;
            this._mask = data.originalMask;
            this.filterArea = data.originalFilterArea;
        }
    }
    containsPoint(point) {
        return false;
    }
    /**
     * Renders a cached version of the sprite with WebGL
     *
     * @private
     * @function _renderCached
     * @memberof PIXI.DisplayObject#
     * @param {PIXI.Renderer} renderer - the WebGL renderer
     */
    _renderCached(renderer) {
        if (!this.visible || this.worldAlpha <= 0 || !this.renderable) {
            return;
        }
        this._initCachedDisplayObject(renderer);
        this._cacheData.sprite.transform._worldID = this.transform.worldID;
        this._cacheData.sprite.worldAlpha = this.worldAlpha;
        this._cacheData.sprite._render(renderer);
    }
    /**
     * Prepares the WebGL renderer to cache the sprite
     *
     * @private
     * @function _initCachedDisplayObject
     * @memberof PIXI.DisplayObject#
     * @param {PIXI.Renderer} renderer - the WebGL renderer
     */
    _initCachedDisplayObject(renderer) {
        if (this._cacheData && this._cacheData.sprite) {
            return;
        }
        // make sure alpha is set to 1 otherwise it will get rendered as invisible!
        var cacheAlpha = this.alpha;
        this.alpha = 1;
        // first we flush anything left in the renderer (otherwise it would get rendered to the cached texture)
        renderer.batch.flush();
        // this.filters= [];
        // next we find the dimensions of the untransformed object
        // this function also calls updatetransform on all its children as part of the measuring.
        // This means we don't need to update the transform again in this function
        // TODO pass an object to clone too? saves having to create a new one each time!
        var bounds = this.getLocalBounds().clone();
        // add some padding!
        if (this.filters) {
            var padding = this.filters[0].padding;
            bounds.pad(padding);
        }
        bounds.ceil(DisplaySettings_1.DisplaySettings.RESOLUTION);
        // for now we cache the current renderTarget that the WebGL renderer is currently using.
        // this could be more elegant..
        var cachedRenderTarget = renderer._activeRenderTarget;
        // We also store the filter stack - I will definitely look to change how this works a little later down the line.
        // const stack = renderer.filterManager.filterStack;
        // this renderTexture will be used to store the cached DisplayObject
        var renderTexture = RenderTexture_1.RenderTexture.create(bounds.width, bounds.height);
        var textureCacheId = "cacheAsBitmap_" + (MathSettings_1.MathSettings.uid());
        this._cacheData.textureCacheId = textureCacheId;
        BaseTexture_1.BaseTexture.addToCache(renderTexture.baseTexture, textureCacheId);
        Texture_1.Texture.addToCache(renderTexture, textureCacheId);
        // need to set //
        var m = DisplayObject._tempMatrix;
        m.tx = -bounds.x;
        m.ty = -bounds.y;
        // reset
        this.transform.worldTransform.identity();
        // set all properties to there original so we can render to a texture
        this.render = this._cacheData.originalRender;
        renderer.render(this, renderTexture, true, m, true);
        // now restore the state be setting the new properties
        renderer.renderTexture.bind(cachedRenderTarget);
        // renderer.filterManager.filterStack = stack;
        this.render = this._renderCached;
        // the rest is the same as for Canvas
        this.updateTransform = this.displayObjectUpdateTransform;
        this.calculateBounds = this._calculateCachedBounds;
        this.getLocalBounds = this._getCachedLocalBounds;
        this._mask = null;
        this.filterArea = null;
        // create our cached sprite
        var cachedSprite; // = new Sprite(renderTexture);
        cachedSprite.transform.worldTransform = this.transform.worldTransform;
        cachedSprite.anchor.x = -(bounds.x / bounds.width);
        cachedSprite.anchor.y = -(bounds.y / bounds.height);
        cachedSprite.alpha = cacheAlpha;
        cachedSprite._bounds = this._bounds;
        this._cacheData.sprite = cachedSprite;
        this.transform.parentID = -1;
        // restore the transform of the cached sprite to avoid the nasty flicker..
        if (!this.parent) {
            this.parent = renderer._tempDisplayObjectParent;
            this.updateTransform();
            this.parent = null;
        }
        else {
            this.updateTransform();
        }
        // map the hit test..
        this.containsPoint = cachedSprite.containsPoint.bind(cachedSprite);
    }
    ;
    /**
 * Renders a cached version of the sprite with canvas
 *
 * @private
 * @function _renderCachedCanvas
 * @memberof PIXI.DisplayObject#
 * @param {PIXI.Renderer} renderer - the WebGL renderer
 */
    _renderCachedCanvas(renderer) {
        if (!this.visible || this.worldAlpha <= 0 || !this.renderable) {
            return;
        }
        this._initCachedDisplayObjectCanvas(renderer);
        this._cacheData.sprite.worldAlpha = this.worldAlpha;
        this._cacheData.sprite._renderCanvas(renderer);
    }
    ;
    // TODO this can be the same as the WebGL version.. will need to do a little tweaking first though..
    /**
     * Prepares the Canvas renderer to cache the sprite
     *
     * @private
     * @function _initCachedDisplayObjectCanvas
     * @memberof PIXI.DisplayObject#
     * @param {PIXI.Renderer} renderer - the WebGL renderer
     */
    _initCachedDisplayObjectCanvas(renderer) {
        if (this._cacheData && this._cacheData.sprite) {
            return;
        }
        // get bounds actually transforms the object for us already!
        var bounds = this.getLocalBounds();
        var cacheAlpha = this.alpha;
        this.alpha = 1;
        var cachedRenderTarget = renderer.context;
        bounds.ceil(DisplaySettings_1.DisplaySettings.RESOLUTION);
        var renderTexture = RenderTexture_1.RenderTexture.create(bounds.width, bounds.height);
        var textureCacheId = "cacheAsBitmap_" + (MathSettings_1.MathSettings.uid());
        this._cacheData.textureCacheId = textureCacheId;
        BaseTexture_1.BaseTexture.addToCache(renderTexture.baseTexture, textureCacheId);
        Texture_1.Texture.addToCache(renderTexture, textureCacheId);
        // need to set //
        var m = DisplayObject._tempMatrix;
        this.transform.localTransform.copyTo(m);
        m.invert();
        m.tx -= bounds.x;
        m.ty -= bounds.y;
        // m.append(this.transform.worldTransform.)
        // set all properties to there original so we can render to a texture
        this.renderCanvas = this._cacheData.originalRenderCanvas;
        // renderTexture.render(this, m, true);
        renderer.render(this, renderTexture, true, m, false);
        // now restore the state be setting the new properties
        renderer.context = cachedRenderTarget;
        this.renderCanvas = this._renderCachedCanvas;
        // the rest is the same as for WebGL
        this.updateTransform = this.displayObjectUpdateTransform;
        this.calculateBounds = this._calculateCachedBounds;
        this.getLocalBounds = this._getCachedLocalBounds;
        this._mask = null;
        this.filterArea = null;
        // create our cached sprite
        var cachedSprite; //= new Sprite(renderTexture);
        cachedSprite.transform.worldTransform = this.transform.worldTransform;
        cachedSprite.anchor.x = -(bounds.x / bounds.width);
        cachedSprite.anchor.y = -(bounds.y / bounds.height);
        cachedSprite.alpha = cacheAlpha;
        cachedSprite._bounds = this._bounds;
        this._cacheData.sprite = cachedSprite;
        this.transform.parentID = -1;
        // restore the transform of the cached sprite to avoid the nasty flicker..
        if (!this.parent) {
            this.parent = renderer._tempDisplayObjectParent;
            this.updateTransform();
            this.parent = null;
        }
        else {
            this.updateTransform();
        }
        // map the hit test..
        this.containsPoint = cachedSprite.containsPoint.bind(cachedSprite);
    }
    ;
    renderCanvas(renderer) {
    }
    /**
     * Calculates the bounds of the cached sprite
     *
     * @private
     */
    _calculateCachedBounds() {
        this._bounds.clear();
        this._cacheData.sprite.transform._worldID = this.transform.worldID;
        this._cacheData.sprite._calculateBounds();
        this._lastBoundsID = this._boundsID;
    }
    ;
    /**
     * Gets the bounds of the cached sprite.
     *
     * @private
     * @return {Rectangle} The local bounds.
     */
    _getCachedLocalBounds() {
        return this._cacheData.sprite.getLocalBounds();
    }
    ;
    /**
     * Destroys the cached sprite.
     *
     * @private
     */
    _destroyCachedDisplayObject() {
        this._cacheData.sprite._texture.destroy(true);
        this._cacheData.sprite = null;
        BaseTexture_1.BaseTexture.removeFromCache(this._cacheData.textureCacheId);
        Texture_1.Texture.removeFromCache(this._cacheData.textureCacheId);
        this._cacheData.textureCacheId = null;
    }
    ;
    /**
 * Destroys the cached object.
 *
 * @private
 * @param {object|boolean} [options] - Options parameter. A boolean will act as if all options
 *  have been set to that value.
 *  Used when destroying containers, see the Container.destroy method.
 */
    _cacheAsBitmapDestroy(options) {
        this.cacheAsBitmap = false;
        this.destroy(options);
    }
    ;
}
DisplayObject._tempMatrix = new Matrix_1.Matrix();
exports.DisplayObject = DisplayObject;
// figured theres no point adding ALL the extra variables to prototype.
// this model can hold the information needed. This can also be generated on demand as
// most objects are not cached as bitmaps.
/**
 * @class
 * @ignore
 */
class CacheData {
    constructor() {
        this.textureCacheId = null;
        this.originalRender = null;
        this.originalRenderCanvas = null;
        this.originalCalculateBounds = null;
        this.originalGetLocalBounds = null;
        this.originalUpdateTransform = null;
        this.originalHitTest = null;
        this.originalDestroy = null;
        this.originalMask = null;
        this.originalFilterArea = null;
        this.sprite = null;
    }
}
;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/DisplaySettings.js":
/*!***************************************************!*\
  !*** ./js-compile/raw-pixi-ts/DisplaySettings.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class DisplaySettings {
}
DisplaySettings.SORTABLE_CHILDREN = false;
DisplaySettings.CREATE_IMAGE_BITMAP = true;
DisplaySettings.RENDERER_TYPE = {
    UNKNOWN: 0,
    WEBGL: 1,
    CANVAS: 2,
};
DisplaySettings.ENV = {
    WEBGL_LEGACY: 0,
    WEBGL: 1,
    WEBGL2: 2,
};
DisplaySettings.RESOLUTION = 1;
DisplaySettings.SCALE_MODE = 1;
DisplaySettings.ROUND_PIXELS = false;
DisplaySettings.PREFER_ENV = DisplaySettings.ENV.WEBGL;
exports.DisplaySettings = DisplaySettings;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/DrawModeSettings.js":
/*!****************************************************!*\
  !*** ./js-compile/raw-pixi-ts/DrawModeSettings.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class DrawModeSettings {
}
/**
* Various webgl draw modes. These can be used to specify which GL drawMode to use
* under certain situations and renderers.
*
* @memberof PIXI
* @static
* @name DRAW_MODES
* @enum {number}
* @property {number} POINTS
* @property {number} LINES
* @property {number} LINE_LOOP
* @property {number} LINE_STRIP
* @property {number} TRIANGLES
* @property {number} TRIANGLE_STRIP
* @property {number} TRIANGLE_FAN
*/
DrawModeSettings.DRAW_MODES = {
    POINTS: 0,
    LINES: 1,
    LINE_LOOP: 2,
    LINE_STRIP: 3,
    TRIANGLES: 4,
    TRIANGLE_STRIP: 5,
    TRIANGLE_FAN: 6,
};
exports.DrawModeSettings = DrawModeSettings;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/Ellipse.js":
/*!*******************************************!*\
  !*** ./js-compile/raw-pixi-ts/Ellipse.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Rectangle_1 = __webpack_require__(/*! ../flash/geom/Rectangle */ "./js-compile/flash/geom/Rectangle.js");
const ShapeSettings_1 = __webpack_require__(/*! ./ShapeSettings */ "./js-compile/raw-pixi-ts/ShapeSettings.js");
const InstanceCounter_1 = __webpack_require__(/*! ./InstanceCounter */ "./js-compile/raw-pixi-ts/InstanceCounter.js");
class Ellipse {
    constructor(x = 0, y = 0, halfWidth = 0, halfHeight = 0) {
        if (x === void 0) {
            x = 0;
        }
        if (y === void 0) {
            y = 0;
        }
        if (halfWidth === void 0) {
            halfWidth = 0;
        }
        if (halfHeight === void 0) {
            halfHeight = 0;
        }
        /**
         * @member {number}
         * @default 0
         */
        this.x = x;
        /**
         * @member {number}
         * @default 0
         */
        this.y = y;
        /**
         * @member {number}
         * @default 0
         */
        this.width = halfWidth;
        /**
         * @member {number}
         * @default 0
         */
        this.height = halfHeight;
        /**
         * The type of the object, mainly used to avoid `instanceof` checks
         *
         * @member {number}
         * @readOnly
         * @default PIXI.SHAPES.ELIP
         * @see PIXI.SHAPES
         */
        this.type = ShapeSettings_1.ShapeSettings.SHAPES.ELIP;
    }
    /**
     * Creates a clone of this Ellipse instance
     *
     * @return {PIXI.Ellipse} a copy of the ellipse
     */
    clone() {
        return new Ellipse(this.x, this.y, this.width, this.height);
    }
    ;
    /**
     * Checks whether the x and y coordinates given are contained within this ellipse
     *
     * @param {number} x - The X coordinate of the point to test
     * @param {number} y - The Y coordinate of the point to test
     * @return {boolean} Whether the x/y coords are within this ellipse
     */
    contains(x, y) {
        if (this.width <= 0 || this.height <= 0) {
            return false;
        }
        // normalize the coords to an ellipse with center 0,0
        var normx = ((x - this.x) / this.width);
        var normy = ((y - this.y) / this.height);
        normx *= normx;
        normy *= normy;
        return (normx + normy <= 1);
    }
    ;
    /**
     * Returns the framing rectangle of the ellipse as a Rectangle object
     *
     * @return {PIXI.Rectangle} the framing rectangle
     */
    getBounds() {
        InstanceCounter_1.InstanceCounter.addCall("Rectangle.getRectangle", "Ellipse getBounds");
        return Rectangle_1.Rectangle.getRectangle(this.x - this.width, this.y - this.height, this.width, this.height);
    }
    ;
}
exports.Ellipse = Ellipse;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/Event.js":
/*!*****************************************!*\
  !*** ./js-compile/raw-pixi-ts/Event.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const FlashBaseObject_1 = __webpack_require__(/*! ./FlashBaseObject */ "./js-compile/raw-pixi-ts/FlashBaseObject.js");
class Event extends FlashBaseObject_1.FlashBaseObject {
    constructor(type, bubble = true, cancelable = true) {
        super();
        this.reset(type, bubble, cancelable);
    }
    get currentTarget() {
        return this._currentTarget;
    }
    setCurrentTarget(value) {
        this._currentTarget = value;
    }
    get type() {
        return this._type;
    }
    get cancelable() {
        return this._cancelable;
    }
    get bubbles() {
        return this._bubbles;
    }
    get eventPhase() {
        return this._eventPhase;
    }
    clone() {
        return Event.getEvent(this._type, this._bubbles, this._cancelable);
    }
    reset(type, bubble = true, cancelable = true) {
        this._type = type;
        this._bubbles = bubble;
        this._cancelable = cancelable;
    }
    static getEvent(type, bubble = true, cancelable = true) {
        if (Event.EventCache.length) {
            let te = Event.EventCache[Event.EventCache.length - 1];
            Event.EventCache.length -= 1;
            te.reset(type, bubble, cancelable);
            return te;
        }
        return new Event(type, bubble, cancelable);
    }
    destructor() {
        this._currentTarget = null;
        let index = Event.EventCache.indexOf(this);
        if (index < 0) {
            Event.EventCache.push(this);
        }
    }
    get isDisposable() {
        return true;
    }
    stopPropagation() {
    }
    stopImmediatePropagation() {
    }
    preventDefault() {
    }
}
Event.ADDED_TO_STAGE = "addedToStage";
Event.ADDED = "added";
Event.ENTER_FRAME = "enterFrame";
Event.EXIT_FRAME = "exitFrame";
Event.FRAME_CONSTRUCTED = "frameConstructed";
Event.REMOVED = "removed";
Event.REMOVED_FROM_STAGE = "removedFromStage";
Event.RENDER = "render";
Event.COMPLETE = "complete";
Event.INIT = "init";
Event.OPEN = "open";
Event.UNLOAD = "unload";
Event.CLEAR = "clear";
Event.SOUND_COMPLETE = "soundComplete";
Event.SOUND_STARTED = "soundStarted";
Event.ACTIVATE = "activate";
Event.DEACTIVATE = "desactivate";
Event.RESIZE = "resize";
Event.CHANGE = "change";
Event.EventCache = [];
exports.Event = Event;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/EventDispatcher.js":
/*!***************************************************!*\
  !*** ./js-compile/raw-pixi-ts/EventDispatcher.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const FlashBaseObject_1 = __webpack_require__(/*! ./FlashBaseObject */ "./js-compile/raw-pixi-ts/FlashBaseObject.js");
class EventDispatcher extends FlashBaseObject_1.FlashBaseObject {
    constructor(target = null) {
        super();
        this.registeredListeners = {};
    }
    removeListeners() {
        for (var i in this.registeredListeners) {
            var methods = this.registeredListeners[i];
            while (methods.length) {
                let ms = methods.shift();
                ms.destructor();
            }
            delete this.registeredListeners[i];
        }
        this.registeredListeners = {};
    }
    destructor() {
        super.destructor();
        this.removeListeners();
    }
    willTrigger(type) {
        if (this.registeredListeners[type] != null) {
            var methods = this.registeredListeners[type];
            if (methods && methods.length) {
                return true;
            }
            return false;
        }
        return false;
    }
    removeEventListener(type, listener, useCapture = false) {
        if (this.registeredListeners[type] != null) {
            var methods = this.registeredListeners[type];
            if (methods && methods.length) {
                for (var i = 0; i < methods.length; i++) {
                    if (methods[i].objectFunction == listener) {
                        methods[i].destructor();
                        methods.splice(i, 1);
                    }
                }
            }
            if (!methods.length) {
                delete this.registeredListeners[type];
            }
        }
    }
    hasEventListener(type) {
        if (this.registeredListeners[type] != null) {
            var methods = this.registeredListeners[type];
            if (methods && methods.length) {
                return true;
            }
            return false;
        }
        return false;
    }
    dispatchEvent(event) {
        if (this.registeredListeners[event.type] != null) {
            event.setCurrentTarget(this);
            var methods = this.registeredListeners[event.type];
            if (methods && methods.length) {
                let methodcopy = methods.concat();
                methodcopy = methodcopy.sort(this.getMethodPriority);
                while (methodcopy.length) {
                    var method = methodcopy.shift();
                    if (method.eventType != event.type) {
                        continue;
                    }
                    if (method) {
                        this.trigger(method, event);
                    }
                }
            }
        }
        if (event.isDisposable) {
            event.destructor();
        }
        return false;
    }
    addEventListener(type, listener, useCapture = false, priority = 0, useWeakReference = false, scope = null) {
        if (this.isRegistered(type, listener)) {
            return;
        }
        if (!this.registeredListeners[type]) {
            this.registeredListeners[type] = [];
        }
        var methods = this.registeredListeners[type];
        var methodScope = MethodScope.getMethodScope();
        methodScope.eventType = type;
        methodScope.parentDispatcher = this;
        methodScope.objectFunction = listener;
        methodScope.scope = scope;
        methodScope.priority = priority;
        methods.push(methodScope);
    }
    trigger(method, event) {
        if (method.objectFunction) {
            method.objectFunction.call(method.scope, event);
        }
    }
    getMethodPriority(method1, method2) {
        if (method1.priority > method2.priority) {
            return 1;
        }
        return -1;
    }
    isRegistered(type, listener) {
        if (!this.registeredListeners[type]) {
            return false;
        }
        var methods = this.registeredListeners[type];
        for (var i = 0; i < methods.length; i++) {
            if (methods[i].objectFunction == listener) {
                return true;
            }
        }
        return false;
    }
}
exports.EventDispatcher = EventDispatcher;
class MethodScope extends FlashBaseObject_1.FlashBaseObject {
    constructor() {
        super();
        this.reset();
    }
    reset() {
        this.objectFunction = null;
        this.scope = null;
        this.parentDispatcher = null;
        this.priority = 0;
        this.eventType = null;
    }
    static getMethodScope() {
        if (MethodScope.MethodScopeCache.length) {
            let te = MethodScope.MethodScopeCache[MethodScope.MethodScopeCache.length - 1];
            MethodScope.MethodScopeCache.length -= 1;
            te.reset();
            return te;
        }
        return new MethodScope();
    }
    destructor() {
        this.objectFunction = null;
        this.scope = null;
        this.parentDispatcher = null;
        let index = MethodScope.MethodScopeCache.indexOf(this);
        if (index < 0) {
            MethodScope.MethodScopeCache.unshift(this);
        }
    }
}
MethodScope.MethodScopeCache = [];


/***/ }),

/***/ "./js-compile/raw-pixi-ts/Extract.js":
/*!*******************************************!*\
  !*** ./js-compile/raw-pixi-ts/Extract.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const RenderTexture_1 = __webpack_require__(/*! ./RenderTexture */ "./js-compile/raw-pixi-ts/RenderTexture.js");
const Rectangle_1 = __webpack_require__(/*! ../flash/geom/Rectangle */ "./js-compile/flash/geom/Rectangle.js");
const CanvasRenderTarget_1 = __webpack_require__(/*! ./CanvasRenderTarget */ "./js-compile/raw-pixi-ts/CanvasRenderTarget.js");
const InstanceCounter_1 = __webpack_require__(/*! ./InstanceCounter */ "./js-compile/raw-pixi-ts/InstanceCounter.js");
class Extract {
    constructor(renderer) {
        this.renderer = renderer;
        /**
         * Collection of methods for extracting data (image, pixels, etc.) from a display object or render texture
         *
         * @member {PIXI.extract.Extract} extract
         * @memberof PIXI.Renderer#
         * @see PIXI.extract.Extract
         */
        renderer.extract = this;
    }
    /**
     * Will return a HTML Image of the target
     *
     * @param {PIXI.DisplayObject|PIXI.RenderTexture} target - A displayObject or renderTexture
     *  to convert. If left empty will use the main renderer
     * @return {HTMLImageElement} HTML Image of the target
     */
    image(target) {
        var image = new Image();
        image.src = this.base64(target);
        return image;
    }
    ;
    /**
     * Will return a a base64 encoded string of this target. It works by calling
     *  `Extract.getCanvas` and then running toDataURL on that.
     *
     * @param {PIXI.DisplayObject|PIXI.RenderTexture} target - A displayObject or renderTexture
     *  to convert. If left empty will use the main renderer
     * @return {string} A base64 encoded string of the texture.
     */
    base64(target) {
        return this.canvas(target).toDataURL();
    }
    ;
    /**
     * Creates a Canvas element, renders this target to it and then returns it.
     *
     * @param {PIXI.DisplayObject|PIXI.RenderTexture} target - A displayObject or renderTexture
     *  to convert. If left empty will use the main renderer
     * @return {HTMLCanvasElement} A Canvas element with the texture rendered on.
     */
    canvas(target) {
        var renderer = this.renderer;
        var resolution;
        var frame;
        var flipY = false;
        var renderTexture;
        var generated = false;
        if (target) {
            if (target instanceof RenderTexture_1.RenderTexture) {
                renderTexture = target;
            }
            else {
                renderTexture = this.renderer.generateTexture(target);
                generated = true;
            }
        }
        if (renderTexture) {
            resolution = renderTexture.baseTexture.resolution;
            frame = renderTexture.frame;
            flipY = false;
            renderer.renderTexture.bind(renderTexture);
        }
        else {
            resolution = this.renderer.resolution;
            flipY = true;
            InstanceCounter_1.InstanceCounter.addCall("Rectangle.getRectangle", "Extract canvas");
            frame = Rectangle_1.Rectangle.getRectangle();
            frame.width = this.renderer.width;
            frame.height = this.renderer.height;
            renderer.renderTexture.bind(null);
        }
        var width = frame.width * resolution;
        var height = frame.height * resolution;
        var canvasBuffer = new CanvasRenderTarget_1.CanvasRenderTarget(width, height, 1);
        var webglPixels = new Uint8Array(Extract.BYTES_PER_PIXEL * width * height);
        // read pixels to the array
        var gl = renderer.gl;
        gl.readPixels(frame.x * resolution, frame.y * resolution, width, height, gl.RGBA, gl.UNSIGNED_BYTE, webglPixels);
        // add the pixels to the canvas
        var canvasData = canvasBuffer.context.getImageData(0, 0, width, height);
        canvasData.data.set(webglPixels);
        canvasBuffer.context.putImageData(canvasData, 0, 0);
        // pulling pixels
        if (flipY) {
            canvasBuffer.context.scale(1, -1);
            canvasBuffer.context.drawImage(canvasBuffer.canvas, 0, -height);
        }
        if (generated) {
            renderTexture.destroy(true);
        }
        // send the canvas back..
        return canvasBuffer.canvas;
    }
    ;
    /**
     * Will return a one-dimensional array containing the pixel data of the entire texture in RGBA
     * order, with integer values between 0 and 255 (included).
     *
     * @param {PIXI.DisplayObject|PIXI.RenderTexture} target - A displayObject or renderTexture
     *  to convert. If left empty will use the main renderer
     * @return {Uint8ClampedArray} One-dimensional array containing the pixel data of the entire texture
     */
    pixels(target) {
        var renderer = this.renderer;
        var resolution;
        var frame;
        var renderTexture;
        var generated = false;
        if (target) {
            if (target instanceof RenderTexture_1.RenderTexture) {
                renderTexture = target;
            }
            else {
                renderTexture = this.renderer.generateTexture(target);
                generated = true;
            }
        }
        if (renderTexture) {
            resolution = renderTexture.baseTexture.resolution;
            frame = renderTexture.frame;
            // bind the buffer
            renderer.renderTexture.bind(renderTexture);
        }
        else {
            resolution = renderer.resolution;
            InstanceCounter_1.InstanceCounter.addCall("Rectangle.getRectangle", "Extract pixels");
            frame = Rectangle_1.Rectangle.getRectangle();
            frame.width = renderer.width;
            frame.height = renderer.height;
            renderer.renderTexture.bind(null);
        }
        var width = frame.width * resolution;
        var height = frame.height * resolution;
        var webglPixels = new Uint8Array(Extract.BYTES_PER_PIXEL * width * height);
        // read pixels to the array
        var gl = renderer.gl;
        gl.readPixels(frame.x * resolution, frame.y * resolution, width, height, gl.RGBA, gl.UNSIGNED_BYTE, webglPixels);
        if (generated) {
            renderTexture.destroy(true);
        }
        return webglPixels;
    }
    ;
    /**
     * Destroys the extract
     *
     */
    destroy() {
        this.renderer.extract = null;
        this.renderer = null;
    }
    ;
}
// static TEMP_RECT = new Rectangle();
Extract.BYTES_PER_PIXEL = 4;
exports.Extract = Extract;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/FillStyle.js":
/*!*********************************************!*\
  !*** ./js-compile/raw-pixi-ts/FillStyle.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Texture_1 = __webpack_require__(/*! ./Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const FlashBaseObject_1 = __webpack_require__(/*! ./FlashBaseObject */ "./js-compile/raw-pixi-ts/FlashBaseObject.js");
class FillStyle extends FlashBaseObject_1.FlashBaseObject {
    constructor() {
        super();
        this.reset();
    }
    /**
     * Clones the object
     *
     * @return {PIXI.FillStyle}
     */
    clone() {
        var obj = new FillStyle();
        obj.color = this.color;
        obj.alpha = this.alpha;
        obj.texture = this.texture;
        obj.matrix = this.matrix;
        obj.visible = this.visible;
        return obj;
    }
    ;
    /**
     * Reset
     */
    reset() {
        /**
         * The hex color value used when coloring the Graphics object.
         *
         * @member {number}
         * @default 1
         */
        this.color = 0xFFFFFF;
        /**
         * The alpha value used when filling the Graphics object.
         *
         * @member {number}
         * @default 1
         */
        this.alpha = 1;
        /**
         * The texture to be used for the fill.
         *
         * @member {string}
         * @default 0
         */
        this.texture = Texture_1.Texture.WHITE;
        /**
         * The transform aplpied to the texture.
         *
         * @member {string}
         * @default 0
         */
        this.matrix = null;
        /**
         * If the current fill is visible.
         *
         * @member {boolean}
         * @default false
         */
        this.visible = false;
    }
    ;
    /**
     * Destroy and don't use after this
     */
    destroy() {
        this.texture = null;
        this.matrix = null;
    }
    ;
}
exports.FillStyle = FillStyle;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/Filter.js":
/*!******************************************!*\
  !*** ./js-compile/raw-pixi-ts/Filter.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Shader_1 = __webpack_require__(/*! ./Shader */ "./js-compile/raw-pixi-ts/Shader.js");
const Program_1 = __webpack_require__(/*! ./Program */ "./js-compile/raw-pixi-ts/Program.js");
const settings_1 = __webpack_require__(/*! ./settings */ "./js-compile/raw-pixi-ts/settings.js");
const State_1 = __webpack_require__(/*! ./State */ "./js-compile/raw-pixi-ts/State.js");
class Filter extends Shader_1.Shader {
    constructor(vertexSrc = null, fragmentSrc = null, uniforms = null) {
        var program = Program_1.Program.from(vertexSrc || Filter.defaultVertexSrc, fragmentSrc || Filter.defaultFragmentSrc);
        super(program, uniforms);
        /**
         * The padding of the filter. Some filters require extra space to breath such as a blur.
         * Increasing this will add extra width and height to the bounds of the object that the
         * filter is applied to.
         *
         * @member {number}
         */
        this.padding = 0;
        /**
         * The resolution of the filter. Setting this to be lower will lower the quality but
         * increase the performance of the filter.
         *
         * @member {number}
         */
        this.resolution = settings_1.settings.FILTER_RESOLUTION;
        /**
         * If enabled is true the filter is applied, if false it will not.
         *
         * @member {boolean}
         */
        this.enabled = true;
        /**
         * If enabled, PixiJS will fit the filter area into boundaries for better performance.
         * Switch it off if it does not work for specific shader.
         *
         * @member {boolean}
         */
        this.autoFit = true;
        /**
         * Legacy filters use position and uvs from attributes
         * @member {boolean}
         * @readonly
         */
        this.legacy = !!this.program.attributeData.aTextureCoord;
        /**
         * The WebGL state the filter requires to render
         * @member {PIXI.State}
         */
        this.state = new State_1.State();
    }
    /**
     * Applies the filter
     *
     * @param {PIXI.systems.FilterSystem} filterManager - The renderer to retrieve the filter from
     * @param {PIXI.RenderTexture} input - The input render target.
     * @param {PIXI.RenderTexture} output - The target to output to.
     * @param {boolean} clear - Should the output be cleared before rendering to it
     * @param {object} [currentState] - It's current state of filter.
     *        There are some useful properties in the currentState :
     *        target, filters, sourceFrame, destinationFrame, renderTarget, resolution
     */
    apply(filterManager, input, output, clear, currentState, derp) {
        // do as you please!
        filterManager.applyFilter(this, input, output, clear, currentState, derp);
        // or just do a regular render..
    }
    ;
    /**
     * Sets the blendmode of the filter
     *
     * @member {number}
     * @default PIXI.BLEND_MODES.NORMAL
     */
    get blendMode() {
        return this.state.blendMode;
    }
    ;
    set blendMode(value) {
        this.state.blendMode = value;
    }
    ;
    /**
     * The default vertex shader source
     *
     * @static
     * @type {string}
     * @constant
     */
    static get defaultVertexSrc() {
        return Filter.defaultVertex$1;
    }
    ;
    /**
     * The default fragment shader source
     *
     * @static
     * @type {string}
     * @constant
     */
    static get defaultFragmentSrc() {
        return Filter.defaultFragment$1;
    }
    ;
}
/**
 * Used for caching shader IDs
 *
 * @static
 * @type {object}
 * @protected
 */
Filter.SOURCE_KEY_MAP = {};
Filter.defaultVertex$1 = "attribute vec2 aVertexPosition;\r\n\r\nuniform mat3 projectionMatrix;\r\n\r\nvarying vec2 vTextureCoord;\r\n\r\nuniform vec4 inputSize;\r\nuniform vec4 outputFrame;\r\n\r\nvec4 filterVertexPosition( void )\r\n{\r\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\r\n\r\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\r\n}\r\n\r\nvec2 filterTextureCoord( void )\r\n{\r\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\r\n}\r\n\r\nvoid main(void)\r\n{\r\n    gl_Position = filterVertexPosition();\r\n    vTextureCoord = filterTextureCoord();\r\n}\r\n";
Filter.defaultFragment$1 = "varying vec2 vTextureCoord;\r\n\r\nuniform sampler2D uSampler;\r\n\r\nvoid main(void){\r\n   gl_FragColor = texture2D(uSampler, vTextureCoord);\r\n}\r\n";
exports.Filter = Filter;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/FilterState.js":
/*!***********************************************!*\
  !*** ./js-compile/raw-pixi-ts/FilterState.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Rectangle_1 = __webpack_require__(/*! ../flash/geom/Rectangle */ "./js-compile/flash/geom/Rectangle.js");
const InstanceCounter_1 = __webpack_require__(/*! ./InstanceCounter */ "./js-compile/raw-pixi-ts/InstanceCounter.js");
class FilterState {
    constructor() {
        this.renderTexture = null;
        /**
         * Target of the filters
         * We store for case when custom filter wants to know the element it was applied on
         * @member {PIXI.DisplayObject}
         * @private
         */
        this.target = null;
        /**
         * Compatibility with PixiJS v4 filters
         * @member {boolean}
         * @default false
         * @private
         */
        this.legacy = false;
        /**
         * Resolution of filters
         * @member {number}
         * @default 1
         * @private
         */
        this.resolution = 1;
        // next three fields are created only for root
        // re-assigned for everything else
        /**
         * Source frame
         * @member {PIXI.Rectangle}
         * @private
         */
        InstanceCounter_1.InstanceCounter.addCall("Rectangle.getRectangle", "FilterState");
        this.sourceFrame = Rectangle_1.Rectangle.getRectangle();
        /**
         * Destination frame
         * @member {PIXI.Rectangle}
         * @private
         */
        InstanceCounter_1.InstanceCounter.addCall("Rectangle.getRectangle", "FilterState");
        this.destinationFrame = Rectangle_1.Rectangle.getRectangle();
        /**
         * Collection of filters
         * @member {PIXI.Filter[]}
         * @private
         */
        this.filters = [];
    }
    /**
     * clears the state
     * @private
     */
    clear() {
        this.target = null;
        this.filters = null;
        this.renderTexture = null;
    }
    ;
}
exports.FilterState = FilterState;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/FilterSystem.js":
/*!************************************************!*\
  !*** ./js-compile/raw-pixi-ts/FilterSystem.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const System_1 = __webpack_require__(/*! ./System */ "./js-compile/raw-pixi-ts/System.js");
const Quad_1 = __webpack_require__(/*! ./Quad */ "./js-compile/raw-pixi-ts/Quad.js");
const QuadUv_1 = __webpack_require__(/*! ./QuadUv */ "./js-compile/raw-pixi-ts/QuadUv.js");
const Rectangle_1 = __webpack_require__(/*! ../flash/geom/Rectangle */ "./js-compile/flash/geom/Rectangle.js");
const UniformGroup_1 = __webpack_require__(/*! ./UniformGroup */ "./js-compile/raw-pixi-ts/UniformGroup.js");
const RenderTexture_1 = __webpack_require__(/*! ./RenderTexture */ "./js-compile/raw-pixi-ts/RenderTexture.js");
const Matrix_1 = __webpack_require__(/*! ./Matrix */ "./js-compile/raw-pixi-ts/Matrix.js");
const FilterState_1 = __webpack_require__(/*! ./FilterState */ "./js-compile/raw-pixi-ts/FilterState.js");
const DrawModeSettings_1 = __webpack_require__(/*! ./DrawModeSettings */ "./js-compile/raw-pixi-ts/DrawModeSettings.js");
const MathSettings_1 = __webpack_require__(/*! ./MathSettings */ "./js-compile/raw-pixi-ts/MathSettings.js");
const InstanceCounter_1 = __webpack_require__(/*! ./InstanceCounter */ "./js-compile/raw-pixi-ts/InstanceCounter.js");
class FilterSystem extends System_1.System {
    constructor(renderer) {
        super(renderer);
        /**
         * List of filters for the FilterSystem
         * @member {Object[]}
         * @readonly
         */
        this.defaultFilterStack = [{}];
        /**
         * stores a bunch of PO2 textures used for filtering
         * @member {Object}
         */
        this.texturePool = {};
        /**
         * a pool for storing filter states, save us creating new ones each tick
         * @member {Object[]}
         */
        this.statePool = [];
        /**
         * A very simple geometry used when drawing a filter effect to the screen
         * @member {PIXI.Quad}
         */
        this.quad = new Quad_1.Quad();
        /**
         * Quad UVs
         * @member {PIXI.QuadUv}
         */
        this.quadUv = new QuadUv_1.QuadUv();
        /**
         * Temporary rect for maths
         * @type {PIXI.Rectangle}
         */
        InstanceCounter_1.InstanceCounter.addCall("Rectangle.getRectangle", "FilterSystem");
        this.tempRect = Rectangle_1.Rectangle.getRectangle();
        /**
         * Active state
         * @member {object}
         */
        this.activeState = {};
        /**
         * This uniform group is attached to filter uniforms when used
         * @member {PIXI.UniformGroup}
         * @property {PIXI.Rectangle} outputFrame
         * @property {Float32Array} inputSize
         * @property {Float32Array} inputPixel
         * @property {Float32Array} inputClamp
         * @property {Number} resolution
         * @property {Float32Array} filterArea
         * @property {Fload32Array} filterClamp
         */
        this.globalUniforms = new UniformGroup_1.UniformGroup({
            outputFrame: this.tempRect,
            inputSize: new Float32Array(4),
            inputPixel: new Float32Array(4),
            inputClamp: new Float32Array(4),
            resolution: 1,
            // legacy variables
            filterArea: new Float32Array(4),
            filterClamp: new Float32Array(4),
        }, true);
        this._pixelsWidth = renderer.view.width;
        this._pixelsHeight = renderer.view.height;
    }
    /**
     * Adds a new filter to the System.
     *
     * @param {PIXI.DisplayObject} target - The target of the filter to render.
     * @param {PIXI.Filter[]} filters - The filters to apply.
     */
    push(target, filters) {
        var renderer = this.renderer;
        var filterStack = this.defaultFilterStack;
        var state = this.statePool.pop() || new FilterState_1.FilterState();
        var resolution = filters[0].resolution;
        var padding = filters[0].padding;
        var autoFit = filters[0].autoFit;
        var legacy = filters[0].legacy;
        for (var i = 1; i < filters.length; i++) {
            var filter = filters[i];
            // lets use the lowest resolution..
            resolution = Math.min(resolution, filter.resolution);
            // and the largest amount of padding!
            padding = Math.max(padding, filter.padding);
            // only auto fit if all filters are autofit
            autoFit = autoFit || filter.autoFit;
            legacy = legacy || filter.legacy;
        }
        if (filterStack.length === 1) {
            this.defaultFilterStack[0].renderTexture = renderer.renderTexture.current;
        }
        filterStack.push(state);
        state.resolution = resolution;
        state.legacy = legacy;
        state.target = target;
        state.sourceFrame.copyFrom(target.filterArea || target.getBounds(true));
        state.sourceFrame.pad(padding);
        if (autoFit) {
            state.sourceFrame.fit(this.renderer.renderTexture.sourceFrame);
        }
        // round to whole number based on resolution
        state.sourceFrame.ceil(resolution);
        state.renderTexture = this.getOptimalFilterTexture(state.sourceFrame.width, state.sourceFrame.height, resolution);
        state.filters = filters;
        state.destinationFrame.width = state.renderTexture.width;
        state.destinationFrame.height = state.renderTexture.height;
        state.renderTexture.filterFrame = state.sourceFrame;
        renderer.renderTexture.bind(state.renderTexture, state.sourceFrame); // /, state.destinationFrame);
        renderer.renderTexture.clear();
    }
    ;
    /**
     * Pops off the filter and applies it.
     *
     */
    pop() {
        var filterStack = this.defaultFilterStack;
        var state = filterStack.pop();
        var filters = state.filters;
        this.activeState = state;
        var globalUniforms = this.globalUniforms.uniforms;
        globalUniforms.outputFrame = state.sourceFrame;
        globalUniforms.resolution = state.resolution;
        var inputSize = globalUniforms.inputSize;
        var inputPixel = globalUniforms.inputPixel;
        var inputClamp = globalUniforms.inputClamp;
        inputSize[0] = state.destinationFrame.width;
        inputSize[1] = state.destinationFrame.height;
        inputSize[2] = 1.0 / inputSize[0];
        inputSize[3] = 1.0 / inputSize[1];
        inputPixel[0] = inputSize[0] * state.resolution;
        inputPixel[1] = inputSize[1] * state.resolution;
        inputPixel[2] = 1.0 / inputPixel[0];
        inputPixel[3] = 1.0 / inputPixel[1];
        inputClamp[0] = 0.5 * inputPixel[2];
        inputClamp[1] = 0.5 * inputPixel[3];
        inputClamp[2] = (state.sourceFrame.width * inputSize[2]) - (0.5 * inputPixel[2]);
        inputClamp[3] = (state.sourceFrame.height * inputSize[3]) - (0.5 * inputPixel[3]);
        // only update the rect if its legacy..
        if (state.legacy) {
            var filterArea = globalUniforms.filterArea;
            filterArea[0] = state.destinationFrame.width;
            filterArea[1] = state.destinationFrame.height;
            filterArea[2] = state.sourceFrame.x;
            filterArea[3] = state.sourceFrame.y;
            globalUniforms.filterClamp = globalUniforms.inputClamp;
        }
        this.globalUniforms.update();
        var lastState = filterStack[filterStack.length - 1];
        if (filters.length === 1) {
            filters[0].apply(this, state.renderTexture, lastState.renderTexture, false, state);
            this.returnFilterTexture(state.renderTexture);
        }
        else {
            var flip = state.renderTexture;
            var flop = this.getOptimalFilterTexture(flip.width, flip.height, state.resolution);
            flop.filterFrame = flip.filterFrame;
            var i = 0;
            for (i = 0; i < filters.length - 1; ++i) {
                filters[i].apply(this, flip, flop, true, state);
                var t = flip;
                flip = flop;
                flop = t;
            }
            filters[i].apply(this, flip, lastState.renderTexture, false, state);
            this.returnFilterTexture(flip);
            this.returnFilterTexture(flop);
        }
        state.clear();
        this.statePool.push(state);
    }
    ;
    /**
     * Draws a filter.
     *
     * @param {PIXI.Filter} filter - The filter to draw.
     * @param {PIXI.RenderTexture} input - The input render target.
     * @param {PIXI.RenderTexture} output - The target to output to.
     * @param {boolean} clear - Should the output be cleared before rendering to it
     */
    applyFilter(filter, input, output, clear) {
        var renderer = this.renderer;
        renderer.renderTexture.bind(output, output ? output.filterFrame : null);
        if (clear) {
            // gl.disable(gl.SCISSOR_TEST);
            renderer.renderTexture.clear();
            // gl.enable(gl.SCISSOR_TEST);
        }
        // set the uniforms..
        filter.uniforms.uSampler = input;
        filter.uniforms.filterGlobals = this.globalUniforms;
        // TODO make it so that the order of this does not matter..
        // because it does at the moment cos of global uniforms.
        // they need to get resynced
        renderer.state.setState(filter.state);
        renderer.shader.bind(filter);
        if (filter.legacy) {
            this.quadUv.map(input._frame, input.filterFrame);
            renderer.geometry.bind(this.quadUv);
            renderer.geometry.draw(DrawModeSettings_1.DrawModeSettings.DRAW_MODES.TRIANGLES);
        }
        else {
            renderer.geometry.bind(this.quad);
            renderer.geometry.draw(DrawModeSettings_1.DrawModeSettings.DRAW_MODES.TRIANGLE_STRIP);
        }
    }
    ;
    /**
     * Calculates the mapped matrix.
     *
     * TODO playing around here.. this is temporary - (will end up in the shader)
     * this returns a matrix that will normalize map filter cords in the filter to screen space
     *
     * @param {PIXI.Matrix} outputMatrix - the matrix to output to.
     * @return {PIXI.Matrix} The mapped matrix.
     */
    calculateScreenSpaceMatrix(outputMatrix) {
        var currentState = this.activeState;
        return FilterSystem.calculateScreenSpaceMatrix(outputMatrix, currentState.sourceFrame, currentState.destinationFrame);
    }
    ;
    /**
     * This will map the filter coord so that a texture can be used based on the transform of a sprite
     *
     * @param {PIXI.Matrix} outputMatrix - The matrix to output to.
     * @param {PIXI.Sprite} sprite - The sprite to map to.
     * @return {PIXI.Matrix} The mapped matrix.
     */
    calculateSpriteMatrix(outputMatrix, sprite) {
        var currentState = this.activeState;
        return FilterSystem.calculateSpriteMatrix(outputMatrix, currentState.sourceFrame, currentState.destinationFrame, sprite);
    }
    ;
    /**
     * Destroys this Filter System.
     *
     * @param {boolean} [contextLost=false] context was lost, do not free shaders
     *
     */
    destroy(contextLost) {
        if (contextLost === void 0) {
            contextLost = false;
        }
        if (!contextLost) {
            this.emptyPool();
        }
        else {
            this.texturePool = {};
        }
    }
    ;
    /**
     * Gets a Power-of-Two render texture or fullScreen texture
     *
     * TODO move to a separate class could be on renderer?
     *
     * @protected
     * @param {number} minWidth - The minimum width of the render texture in real pixels.
     * @param {number} minHeight - The minimum height of the render texture in real pixels.
     * @param {number} [resolution=1] - The resolution of the render texture.
     * @return {PIXI.RenderTexture} The new render texture.
     */
    getOptimalFilterTexture(minWidth, minHeight, resolution) {
        if (resolution === void 0) {
            resolution = 1;
        }
        var key = FilterSystem.screenKey;
        minWidth *= resolution;
        minHeight *= resolution;
        if (minWidth !== this._pixelsWidth || minHeight !== this._pixelsHeight) {
            minWidth = MathSettings_1.MathSettings.nextPow2(minWidth);
            minHeight = MathSettings_1.MathSettings.nextPow2(minHeight);
            key = ((minWidth & 0xFFFF) << 16) | (minHeight & 0xFFFF);
        }
        if (!this.texturePool[key]) {
            this.texturePool[key] = [];
        }
        var renderTexture = this.texturePool[key].pop();
        if (!renderTexture) {
            // temporary bypass cache..
            // internally - this will cause a texture to be bound..
            renderTexture = RenderTexture_1.RenderTexture.create({
                width: minWidth / resolution,
                height: minHeight / resolution,
                resolution: resolution,
            });
        }
        renderTexture.filterPoolKey = key;
        return renderTexture;
    }
    ;
    /**
     * Gets extra render texture to use inside current filter
     *
     * @param {number} resolution resolution of the renderTexture
     * @returns {PIXI.RenderTexture}
     */
    getFilterTexture(resolution) {
        var rt = this.activeState.renderTexture;
        var filterTexture = this.getOptimalFilterTexture(rt.width, rt.height, resolution || rt.baseTexture.resolution);
        filterTexture.filterFrame = rt.filterFrame;
        return filterTexture;
    }
    ;
    /**
     * Frees a render texture back into the pool.
     *
     * @param {PIXI.RenderTexture} renderTexture - The renderTarget to free
     */
    returnFilterTexture(renderTexture) {
        var key = renderTexture.filterPoolKey;
        renderTexture.filterFrame = null;
        this.texturePool[key].push(renderTexture);
    }
    ;
    /**
     * Empties the texture pool.
     *
     */
    emptyPool() {
        for (var i in this.texturePool) {
            var textures = this.texturePool[i];
            if (textures) {
                for (var j = 0; j < textures.length; j++) {
                    textures[j].destroy(true);
                }
            }
        }
        this.texturePool = {};
    }
    ;
    resize() {
        var textures = this.texturePool[FilterSystem.screenKey];
        if (textures) {
            for (var j = 0; j < textures.length; j++) {
                textures[j].destroy(true);
            }
        }
        this.texturePool[FilterSystem.screenKey] = [];
        this._pixelsWidth = this.renderer.view.width;
        this._pixelsHeight = this.renderer.view.height;
    }
    ;
    // this will map the filter coord so that a texture can be used based on the transform of a sprite
    static calculateSpriteMatrix(outputMatrix, filterArea, textureSize, sprite) {
        var orig = sprite._texture.orig;
        var mappedMatrix = outputMatrix.set(textureSize.width, 0, 0, textureSize.height, filterArea.x, filterArea.y);
        var worldTransform = sprite.worldTransform.copyTo(Matrix_1.Matrix.TEMP_MATRIX);
        worldTransform.invert();
        mappedMatrix.prepend(worldTransform);
        mappedMatrix.scale(1.0 / orig.width, 1.0 / orig.height);
        mappedMatrix.translate(sprite.anchor.x, sprite.anchor.y);
        return mappedMatrix;
    }
    /**
 * Calculates the mapped matrix
 * @param {PIXI.Matrix} outputMatrix matrix that will normalize map filter cords in the filter to screen space
 * @param {PIXI.Rectangle} filterArea filter area
 * @param {PIXI.Rectangle} textureSize texture size
 * @returns {PIXI.Matrix} same as outputMatrix
 * @private
 */
    static calculateScreenSpaceMatrix(outputMatrix, filterArea, textureSize) {
        // TODO unwrap?
        var mappedMatrix = outputMatrix.identity();
        mappedMatrix.translate(filterArea.x / textureSize.width, filterArea.y / textureSize.height);
        mappedMatrix.scale(textureSize.width, textureSize.height);
        return mappedMatrix;
    }
}
FilterSystem.screenKey = 'screen';
exports.FilterSystem = FilterSystem;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/FlashBaseObject.js":
/*!***************************************************!*\
  !*** ./js-compile/raw-pixi-ts/FlashBaseObject.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class FlashBaseObject {
    constructor() {
        FlashBaseObject.nameCount++;
        this._name = "instance-" + this.className + "-" + FlashBaseObject.nameCount;
        this._instanceName = "instance-" + this.className + "-" + FlashBaseObject.nameCount;
        this._hasChanged = true;
        this._className = this.constructor['name'];
    }
    get className() {
        return this.constructor['name'];
    }
    destructor() {
    }
    recycle() {
    }
    dispose() {
    }
    get hasChanged() {
        return this._hasChanged;
    }
    set hasChanged(value) {
        this._hasChanged = value;
    }
    get name() {
        return this._name;
    }
    set name(value) {
        this._name = value;
    }
    get instanceName() {
        return this._instanceName;
    }
}
FlashBaseObject.nameCount = 0;
exports.FlashBaseObject = FlashBaseObject;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/FontManager.js":
/*!***********************************************!*\
  !*** ./js-compile/raw-pixi-ts/FontManager.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Texture_1 = __webpack_require__(/*! ./Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const URLRequest_1 = __webpack_require__(/*! ./URLRequest */ "./js-compile/raw-pixi-ts/URLRequest.js");
const URLLoader_1 = __webpack_require__(/*! ./URLLoader */ "./js-compile/raw-pixi-ts/URLLoader.js");
const Event_1 = __webpack_require__(/*! ./Event */ "./js-compile/raw-pixi-ts/Event.js");
const IOErrorEvent_1 = __webpack_require__(/*! ./IOErrorEvent */ "./js-compile/raw-pixi-ts/IOErrorEvent.js");
const EventDispatcher_1 = __webpack_require__(/*! ./EventDispatcher */ "./js-compile/raw-pixi-ts/EventDispatcher.js");
const URLRequestMethod_1 = __webpack_require__(/*! ./URLRequestMethod */ "./js-compile/raw-pixi-ts/URLRequestMethod.js");
const XMLParser_1 = __webpack_require__(/*! ./XMLParser */ "./js-compile/raw-pixi-ts/XMLParser.js");
const NetworkSettings_1 = __webpack_require__(/*! ./NetworkSettings */ "./js-compile/raw-pixi-ts/NetworkSettings.js");
const DisplaySettings_1 = __webpack_require__(/*! ./DisplaySettings */ "./js-compile/raw-pixi-ts/DisplaySettings.js");
const Rectangle_1 = __webpack_require__(/*! ../flash/geom/Rectangle */ "./js-compile/flash/geom/Rectangle.js");
const BaseTexture_1 = __webpack_require__(/*! ./BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const ResourceLoader_1 = __webpack_require__(/*! ./ResourceLoader */ "./js-compile/raw-pixi-ts/ResourceLoader.js");
const InstanceCounter_1 = __webpack_require__(/*! ./InstanceCounter */ "./js-compile/raw-pixi-ts/InstanceCounter.js");
class FontManager {
    constructor() {
    }
    static set WebFontConfig(value) {
        let config = {
            active() {
                FontManager.webFontActive();
            }
        };
        for (let key in value) {
            config[key] = value[key];
        }
        window['WebFontConfig'] = config;
        FontManager.loadWebFont();
    }
    static getBitmapFont(name) {
        if (FontManager.bitmapfonts[name] != undefined) {
            return FontManager.bitmapfonts[name];
        }
        return null;
    }
    static addBitmapFont(data) {
        FontManager.bitmapfonts[data.font] = data;
    }
    static loadBitmapFont(path) {
        let loader = new BitmapFontLoader();
        FontManager.fontLoaders[loader.instanceName] = loader;
        loader.loadFont(path);
        return loader;
    }
    static parseBitmapFontData(xml, base) {
        let pageid;
        let pagepath;
        let data = new BitmapFont();
        data.texture = base;
        let info = xml.getElementsByTagName('info')[0];
        let common = xml.getElementsByTagName('common')[0];
        let pages = xml.getElementsByTagName('page')[0];
        let res = NetworkSettings_1.NetworkSettings.getResolutionOfUrl(pages.getAttribute('file'), DisplaySettings_1.DisplaySettings.RESOLUTION);
        data.font = info.getAttribute('face');
        data.size = parseInt(info.getAttribute('size'), 10);
        data.lineHeight = parseInt(common.getAttribute('lineHeight'), 10) / res;
        data.chars = {};
        pageid = pages.getAttribute('id');
        pagepath = pages.getAttribute('file');
        data.texturePath = pagepath;
        let letters = Array.from(xml.getElementsByTagName('char'));
        for (let i$1 = 0; i$1 < letters.length; i$1++) {
            let letter = letters[i$1];
            let charCode = parseInt(letter.getAttribute('id'), 10);
            let page = parseInt(letter.getAttribute('page')) || 0;
            InstanceCounter_1.InstanceCounter.addCall("Rectangle.getRectangle", "FontManager parseBitmapFontData");
            let textureRect = Rectangle_1.Rectangle.getRectangle((parseInt(letter.getAttribute('x'), 10) / res) + (base.frame.x / res), (parseInt(letter.getAttribute('y'), 10) / res) + (base.frame.y / res), parseInt(letter.getAttribute('width'), 10) / res, parseInt(letter.getAttribute('height'), 10) / res);
            let fontchar = new FontCharacterData();
            fontchar.xOffset = parseInt(letter.getAttribute('xoffset'), 10) / res;
            fontchar.yOffset = parseInt(letter.getAttribute('yoffset'), 10) / res;
            fontchar.xAdvance = parseInt(letter.getAttribute('xadvance'), 10) / res;
            fontchar.kerning = {};
            fontchar.texture = new Texture_1.Texture(base.baseTexture, textureRect);
            fontchar.page = page;
            data.chars[charCode] = fontchar;
        }
        let kernings = Array.from(xml.getElementsByTagName('kerning'));
        for (let i$2 = 0; i$2 < kernings.length; i$2++) {
            let kerning = kernings[i$2];
            let first = parseInt(kerning.getAttribute('first'), 10) / res;
            let second = parseInt(kerning.getAttribute('second'), 10) / res;
            let amount = parseInt(kerning.getAttribute('amount'), 10) / res;
            if (data.chars[second]) {
                data.chars[second].kerning[first] = amount;
            }
        }
        return data;
    }
}
FontManager.fontLoaders = {};
FontManager.bitmapfonts = {};
FontManager.webFontActive = () => {
    if (FontManager.onWebFontloaded) {
        FontManager.onWebFontloaded();
    }
};
FontManager.loadWebFont = () => {
    const wf = document.createElement('script');
    wf.src = `${document.location.protocol === 'https:' ? 'https' : 'http'}://ajax.googleapis.com/ajax/libs/webfont/1/webfont.js`;
    wf.type = 'text/javascript';
    wf.async = 'true';
    const s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(wf, s);
};
exports.FontManager = FontManager;
class BitmapFont {
}
exports.BitmapFont = BitmapFont;
class BitmapFontLoader extends EventDispatcher_1.EventDispatcher {
    constructor() {
        super();
        this.handleFontXMLComplete = (event) => {
            this.fontxml = XMLParser_1.XMLParser.parse(this.urlloader.data);
            let pages = this.fontxml.getElementsByTagName('page')[0];
            let pagepath = pages.getAttribute('file');
            this.textureloader = new ResourceLoader_1.ResourceLoader(new URLRequest_1.URLRequest(this.rootpath + pagepath));
            this.textureloader.addEventListener(Event_1.Event.COMPLETE, this.handletextureLoaded);
            this.textureloader.load();
        };
        this.handletextureLoaded = (event) => {
            let b = new BaseTexture_1.BaseTexture(this.textureloader.imageData);
            let t = new Texture_1.Texture(b);
            this.fontdata = FontManager.parseBitmapFontData(this.fontxml, t);
            FontManager.addBitmapFont(this.fontdata);
            this.dispatchEvent(Event_1.Event.getEvent(Event_1.Event.COMPLETE));
        };
        this.handleFontLoadError = (event) => {
            this.dispatchEvent(event);
        };
    }
    loadFont(path) {
        let request = new URLRequest_1.URLRequest(path);
        if (path.indexOf("/") >= 0) {
            let pathparts = path.split("/");
            pathparts.pop();
            this.rootpath = pathparts.join("/") + "/";
        }
        else {
            this.rootpath = "";
        }
        request.method = URLRequestMethod_1.URLRequestMethod.POST;
        this.urlloader = new URLLoader_1.URLLoader();
        this.urlloader.addEventListener(Event_1.Event.COMPLETE, this.handleFontXMLComplete);
        this.urlloader.addEventListener(IOErrorEvent_1.IOErrorEvent.IO_ERROR, this.handleFontLoadError);
        this.urlloader.load(request);
    }
}
class FontCharacterData {
}


/***/ }),

/***/ "./js-compile/raw-pixi-ts/Framebuffer.js":
/*!***********************************************!*\
  !*** ./js-compile/raw-pixi-ts/Framebuffer.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseTexture_1 = __webpack_require__(/*! ./BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const DepthResource_1 = __webpack_require__(/*! ./DepthResource */ "./js-compile/raw-pixi-ts/DepthResource.js");
const WebGLSettings_1 = __webpack_require__(/*! ./WebGLSettings */ "./js-compile/raw-pixi-ts/WebGLSettings.js");
const Runner_1 = __webpack_require__(/*! ./Runner */ "./js-compile/raw-pixi-ts/Runner.js");
class Framebuffer {
    constructor(width, height) {
        this.width = Math.ceil(width || 100);
        this.height = Math.ceil(height || 100);
        this.stencil = false;
        this.depth = false;
        this.dirtyId = 0;
        this.dirtyFormat = 0;
        this.dirtySize = 0;
        this.depthTexture = null;
        this.colorTextures = [];
        this.glFramebuffers = {};
        this.disposeRunner = new Runner_1.Runner('disposeFramebuffer', 2);
        // this.disposeRunner = new Runner('disposeFramebuffer', 2);
    }
    /**
     * Reference to the colorTexture.
     *
     * @member {PIXI.Texture[]}
     * @readonly
     */
    get colorTexture() {
        return this.colorTextures[0];
    }
    ;
    /**
     * Add texture to the colorTexture array
     *
     * @param {number} [index=0] - Index of the array to add the texture to
     * @param {PIXI.Texture} [texture] - Texture to add to the array
     */
    addColorTexture(index, texture) {
        if (index === void 0) {
            index = 0;
        }
        // TODO add some validation to the texture - same width / height etc?
        this.colorTextures[index] = texture || new BaseTexture_1.BaseTexture(null, { scaleMode: 0,
            resolution: 1,
            mipmap: false,
            width: this.width,
            height: this.height }); // || new Texture();
        this.dirtyId++;
        this.dirtyFormat++;
        return this;
    }
    ;
    /**
     * Add a depth texture to the frame buffer
     *
     * @param {PIXI.Texture} [texture] - Texture to add
     */
    addDepthTexture(texture) {
        /* eslint-disable max-len */
        this.depthTexture = texture || new BaseTexture_1.BaseTexture(new DepthResource_1.DepthResource(null, { width: this.width, height: this.height }), { scaleMode: 0,
            resolution: 1,
            width: this.width,
            height: this.height,
            mipmap: false,
            format: WebGLSettings_1.WebGLSettings.FORMATS.DEPTH_COMPONENT,
            type: WebGLSettings_1.WebGLSettings.TYPES.UNSIGNED_SHORT }); // UNSIGNED_SHORT;
        /* eslint-disable max-len */
        this.dirtyId++;
        this.dirtyFormat++;
        return this;
    }
    ;
    /**
     * Enable depth on the frame buffer
     */
    enableDepth() {
        this.depth = true;
        this.dirtyId++;
        this.dirtyFormat++;
        return this;
    }
    ;
    /**
     * Enable stencil on the frame buffer
     */
    enableStencil() {
        this.stencil = true;
        this.dirtyId++;
        this.dirtyFormat++;
        return this;
    }
    ;
    /**
     * Resize the frame buffer
     *
     * @param {number} width - Width of the frame buffer to resize to
     * @param {number} height - Height of the frame buffer to resize to
     */
    resize(width, height) {
        width = Math.ceil(width);
        height = Math.ceil(height);
        if (width === this.width && height === this.height) {
            return;
        }
        this.width = width;
        this.height = height;
        this.dirtyId++;
        this.dirtySize++;
        for (var i = 0; i < this.colorTextures.length; i++) {
            var texture = this.colorTextures[i];
            var resolution = texture.resolution;
            // take into acount the fact the texture may have a different resolution..
            texture.setSize(width / resolution, height / resolution);
        }
        if (this.depthTexture) {
            var resolution$1 = this.depthTexture.resolution;
            this.depthTexture.setSize(width / resolution$1, height / resolution$1);
        }
    }
    ;
    /**
     * disposes WebGL resources that are connected to this geometry
     */
    dispose() {
        // this.disposeRunner.run(this, false);
        this.disposeRunner.run(this, false);
    }
    ;
}
exports.Framebuffer = Framebuffer;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/FramebufferSystem.js":
/*!*****************************************************!*\
  !*** ./js-compile/raw-pixi-ts/FramebufferSystem.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const System_1 = __webpack_require__(/*! ./System */ "./js-compile/raw-pixi-ts/System.js");
const Framebuffer_1 = __webpack_require__(/*! ./Framebuffer */ "./js-compile/raw-pixi-ts/Framebuffer.js");
const Rectangle_1 = __webpack_require__(/*! ../flash/geom/Rectangle */ "./js-compile/flash/geom/Rectangle.js");
const DisplaySettings_1 = __webpack_require__(/*! ./DisplaySettings */ "./js-compile/raw-pixi-ts/DisplaySettings.js");
const InstanceCounter_1 = __webpack_require__(/*! ./InstanceCounter */ "./js-compile/raw-pixi-ts/InstanceCounter.js");
class FramebufferSystem extends System_1.System {
    constructor(renderer) {
        super(renderer);
        /**
         * A list of managed framebuffers
         * @member {PIXI.Framebuffer[]}
         * @readonly
         */
        this.managedFramebuffers = [];
        /**
         * Framebuffer value that shows that we don't know what is bound
         * @member {Framebuffer}
         * @readonly
         */
        this.unknownFramebuffer = new Framebuffer_1.Framebuffer(10, 10);
        InstanceCounter_1.InstanceCounter.addCall("Rectangle.getRectangle", "FrameBufferSystem");
        this.viewport = Rectangle_1.Rectangle.getRectangle();
    }
    /**
     * Sets up the renderer context and necessary buffers.
     */
    contextChange(gl) {
        var gl = this.gl = this.renderer.gl;
        this.CONTEXT_UID = this.renderer.CONTEXT_UID;
        this.current = this.unknownFramebuffer;
        InstanceCounter_1.InstanceCounter.addCall("Rectangle.getRectangle", "FrameBufferSystem contextChange");
        this.viewport = Rectangle_1.Rectangle.getRectangle();
        this.hasMRT = true;
        this.writeDepthTexture = true;
        this.disposeAll(true);
        // webgl2
        if (this.renderer.context.webGLVersion === 1) {
            // webgl 1!
            var nativeDrawBuffersExtension = this.renderer.context.extensions.drawBuffers;
            var nativeDepthTextureExtension = this.renderer.context.extensions.depthTexture;
            if (DisplaySettings_1.DisplaySettings.PREFER_ENV === DisplaySettings_1.DisplaySettings.ENV.WEBGL_LEGACY) {
                nativeDrawBuffersExtension = null;
                nativeDepthTextureExtension = null;
            }
            if (nativeDrawBuffersExtension) {
                gl.drawBuffers = function (activeTextures) { return nativeDrawBuffersExtension.drawBuffersWEBGL(activeTextures); };
            }
            else {
                this.hasMRT = false;
                gl.drawBuffers = function () {
                    // empty
                };
            }
            if (!nativeDepthTextureExtension) {
                this.writeDepthTexture = false;
            }
        }
    }
    ;
    /**
         * Bind a framebuffer
         *
         * @param {PIXI.Framebuffer} framebuffer
         * @param {PIXI.Rectangle} [frame] frame, default is framebuffer size
         */
    bind(framebuffer = null, frame = null) {
        var ref = this;
        var gl = ref.gl;
        if (framebuffer) {
            // TODO caching layer!
            var fbo = framebuffer.glFramebuffers[this.CONTEXT_UID] || this.initFramebuffer(framebuffer);
            if (this.current !== framebuffer) {
                this.current = framebuffer;
                gl.bindFramebuffer(gl.FRAMEBUFFER, fbo.framebuffer);
            }
            // make sure all textures are unbound..
            // now check for updates...
            if (fbo.dirtyId !== framebuffer.dirtyId) {
                fbo.dirtyId = framebuffer.dirtyId;
                if (fbo.dirtyFormat !== framebuffer.dirtyFormat) {
                    fbo.dirtyFormat = framebuffer.dirtyFormat;
                    this.updateFramebuffer(framebuffer);
                }
                else if (fbo.dirtySize !== framebuffer.dirtySize) {
                    fbo.dirtySize = framebuffer.dirtySize;
                    this.resizeFramebuffer(framebuffer);
                }
            }
            for (var i = 0; i < framebuffer.colorTextures.length; i++) {
                if (framebuffer.colorTextures[i].texturePart) {
                    this.renderer.texture.unbind(framebuffer.colorTextures[i].texture);
                }
                else {
                    this.renderer.texture.unbind(framebuffer.colorTextures[i]);
                }
            }
            if (framebuffer.depthTexture) {
                this.renderer.texture.unbind(framebuffer.depthTexture);
            }
            if (frame) {
                this.setViewport(frame.x, frame.y, frame.width, frame.height);
            }
            else {
                this.setViewport(0, 0, framebuffer.width, framebuffer.height);
            }
        }
        else {
            if (this.current) {
                this.current = null;
                gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            }
            if (frame) {
                this.setViewport(frame.x, frame.y, frame.width, frame.height);
            }
            else {
                this.setViewport(0, 0, this.renderer.width, this.renderer.height);
            }
        }
    }
    ;
    /**
     * Set the WebGLRenderingContext's viewport.
     *
     * @param {Number} x - X position of viewport
     * @param {Number} y - Y position of viewport
     * @param {Number} width - Width of viewport
     * @param {Number} height - Height of viewport
     */
    setViewport(x, y, width, height) {
        var v = this.viewport;
        if (v.width !== width || v.height !== height || v.x !== x || v.y !== y) {
            v.x = x;
            v.y = y;
            v.width = width;
            v.height = height;
            this.gl.viewport(x, y, width, height);
        }
    }
    ;
    /**
     * Get the size of the current width and height. Returns object with `width` and `height` values.
     *
     * @member {object}
     * @readonly
     */
    get size() {
        if (this.current) {
            // TODO store temp
            return { x: 0, y: 0, width: this.current.width, height: this.current.height };
        }
        return { x: 0, y: 0, width: this.renderer.width, height: this.renderer.height };
    }
    ;
    /**
     * Clear the color of the context
     *
     * @param {Number} r - Red value from 0 to 1
     * @param {Number} g - Green value from 0 to 1
     * @param {Number} b - Blue value from 0 to 1
     * @param {Number} a - Alpha value from 0 to 1
     */
    clear(r = 0, g = 0, b = 0, a = 1) {
        var ref = this;
        var gl = ref.gl;
        // TODO clear color can be set only one right?
        gl.clearColor(r, g, b, a);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    }
    ;
    /**
 * Initialize framebuffer
 *
 * @protected
 * @param {PIXI.Framebuffer} framebuffer
 */
    initFramebuffer(framebuffer) {
        var ref = this;
        var gl = ref.gl;
        // TODO - make this a class?
        var fbo = {
            framebuffer: gl.createFramebuffer(),
            stencil: null,
            dirtyId: 0,
            dirtyFormat: 0,
            dirtySize: 0,
        };
        framebuffer.glFramebuffers[this.CONTEXT_UID] = fbo;
        this.managedFramebuffers.push(framebuffer);
        framebuffer.disposeRunner.add(this);
        return fbo;
    }
    ;
    /**
     * Resize the framebuffer
     *
     * @protected
     * @param {PIXI.Framebuffer} framebuffer
     */
    resizeFramebuffer(framebuffer) {
        var ref = this;
        var gl = ref.gl;
        var fbo = framebuffer.glFramebuffers[this.CONTEXT_UID];
        if (fbo.stencil) {
            gl.bindRenderbuffer(gl.RENDERBUFFER, fbo.stencil);
            gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, framebuffer.width, framebuffer.height);
        }
        var colorTextures = framebuffer.colorTextures;
        for (var i = 0; i < colorTextures.length; i++) {
            this.renderer.texture.bind(colorTextures[i], 0);
        }
        if (framebuffer.depthTexture) {
            this.renderer.texture.bind(framebuffer.depthTexture, 0);
        }
    }
    ;
    /**
     * Update the framebuffer
     *
     * @protected
     * @param {PIXI.Framebuffer} framebuffer
     */
    updateFramebuffer(framebuffer) {
        var ref = this;
        var gl = ref.gl;
        var fbo = framebuffer.glFramebuffers[this.CONTEXT_UID];
        // bind the color texture
        var colorTextures = framebuffer.colorTextures;
        var count = colorTextures.length;
        if (!gl.drawBuffers) {
            count = Math.min(count, 1);
        }
        var activeTextures = [];
        for (var i = 0; i < count; i++) {
            var texture = framebuffer.colorTextures[i];
            if (texture.texturePart) {
                this.renderer.texture.bind(texture.texture, 0);
                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, gl.TEXTURE_CUBE_MAP_NEGATIVE_X + texture.side, texture.texture._glTextures[this.CONTEXT_UID].texture, 0);
            }
            else {
                this.renderer.texture.bind(texture, 0);
                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, gl.TEXTURE_2D, texture._glTextures[this.CONTEXT_UID].texture, 0);
            }
            activeTextures.push(gl.COLOR_ATTACHMENT0 + i);
        }
        if (activeTextures.length > 1) {
            gl.drawBuffers(activeTextures);
        }
        if (framebuffer.depthTexture) {
            var writeDepthTexture = this.writeDepthTexture;
            if (writeDepthTexture) {
                var depthTexture = framebuffer.depthTexture;
                this.renderer.texture.bind(depthTexture, 0);
                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, depthTexture._glTextures[this.CONTEXT_UID].texture, 0);
            }
        }
        if (!fbo.stencil && (framebuffer.stencil || framebuffer.depth)) {
            fbo.stencil = gl.createRenderbuffer();
            gl.bindRenderbuffer(gl.RENDERBUFFER, fbo.stencil);
            // TODO.. this is depth AND stencil?
            if (!framebuffer.depthTexture) { // you can't have both, so one should take priority if enabled
                gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, fbo.stencil);
            }
            gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, framebuffer.width, framebuffer.height);
            // fbo.enableStencil();
        }
    }
    ;
    /**
     * Disposes framebuffer
     * @param {PIXI.Framebuffer} framebuffer framebuffer that has to be disposed of
     * @param {boolean} [contextLost=false] If context was lost, we suppress all delete function calls
     */
    disposeFramebuffer(framebuffer, contextLost) {
        var fbo = framebuffer.glFramebuffers[this.CONTEXT_UID];
        var gl = this.gl;
        if (!fbo) {
            return;
        }
        delete framebuffer.glFramebuffers[this.CONTEXT_UID];
        var index = this.managedFramebuffers.indexOf(framebuffer);
        if (index >= 0) {
            this.managedFramebuffers.splice(index, 1);
        }
        framebuffer.disposeRunner.remove(this);
        if (!contextLost) {
            gl.deleteFramebuffer(fbo.framebuffer);
            if (fbo.stencil) {
                gl.deleteRenderbuffer(fbo.stencil);
            }
        }
    }
    ;
    /**
     * Disposes all framebuffers, but not textures bound to them
     * @param {boolean} [contextLost=false] If context was lost, we suppress all delete function calls
     */
    disposeAll(contextLost) {
        var list = this.managedFramebuffers;
        this.managedFramebuffers = [];
        for (var i = 0; i < list.count; i++) {
            this.disposeFramebuffer(list[i], contextLost);
        }
    }
    ;
    /**
     * resets framebuffer stored state, binds screen framebuffer
     *
     * should be called before renderTexture reset()
     */
    reset() {
        this.current = this.unknownFramebuffer;
        InstanceCounter_1.InstanceCounter.addCall("Rectangle.getRectangle", "FrameBufferSystem reset");
        this.viewport = Rectangle_1.Rectangle.getRectangle();
    }
    ;
}
exports.FramebufferSystem = FramebufferSystem;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/GLBuffer.js":
/*!********************************************!*\
  !*** ./js-compile/raw-pixi-ts/GLBuffer.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class GLBuffer {
    constructor(buffer) {
        this.buffer = buffer;
        this.updateID = -1;
        this.byteLength = -1;
        this.refCount = 0;
    }
}
exports.GLBuffer = GLBuffer;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/GLProgram.js":
/*!*********************************************!*\
  !*** ./js-compile/raw-pixi-ts/GLProgram.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class GLProgram {
    constructor(program, uniformData) {
        /**
                 * The shader program
                 *
                 * @member {WebGLProgram}
                 */
        this.program = program;
        /**
         * holds the uniform data which contains uniform locations
         * and current uniform values used for caching and preventing unneeded GPU commands
         * @member {Object}
         */
        this.uniformData = uniformData;
        /**
         * uniformGroups holds the various upload functions for the shader. Each uniform group
         * and program have a unique upload function generated.
         * @member {Object}
         */
        this.uniformGroups = {};
    }
    /**
     * Destroys this program
     */
    destroy() {
        this.uniformData = null;
        this.uniformGroups = null;
        this.program = null;
    }
    ;
}
exports.GLProgram = GLProgram;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/GLTexture.js":
/*!*********************************************!*\
  !*** ./js-compile/raw-pixi-ts/GLTexture.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class GLTexture {
    constructor(texture) {
        /**
                 * The WebGL texture
                 * @member {WebGLTexture}
                 */
        this.texture = texture;
        this.width = -1;
        this.height = -1;
        /**
         * Texture contents dirty flag
         * @member {number}
         */
        this.dirtyId = -1;
        /**
         * Texture style dirty flag
         * @member {number}
         */
        this.dirtyStyleId = -1;
        /**
         * Whether mip levels has to be generated
         * @member {boolean}
         */
        this.mipmap = false;
        /**
         * WrapMode copied from baseTexture
         * @member {number}
         */
        this.wrapMode = 33071;
    }
}
exports.GLTexture = GLTexture;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/Geometry.js":
/*!********************************************!*\
  !*** ./js-compile/raw-pixi-ts/Geometry.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Attribute_1 = __webpack_require__(/*! ./Attribute */ "./js-compile/raw-pixi-ts/Attribute.js");
const Buffer_1 = __webpack_require__(/*! ./Buffer */ "./js-compile/raw-pixi-ts/Buffer.js");
const Runner_1 = __webpack_require__(/*! ./Runner */ "./js-compile/raw-pixi-ts/Runner.js");
class Geometry {
    constructor(buffers = [], attributes = {}) {
        this.buffers = buffers;
        this.indexBuffer = null;
        this.attributes = attributes;
        /**
         * A map of renderer IDs to webgl VAOs
         *
         * @protected
         * @type {object}
         */
        this.glVertexArrayObjects = {};
        this.id = Geometry.UID$1++;
        this.instanced = false;
        this.instanceCount = 1;
        this._size = null;
        this.disposeRunner = new Runner_1.Runner('disposeGeometry', 2);
        // this.disposeRunner = new Runner('disposeGeometry', 2);
        /**
         * Count of existing (not destroyed) meshes that reference this geometry
         * @member {boolean}
         */
        this.refCount = 0;
    }
    /**
    *
    * Adds an attribute to the geometry
    *
    * @param {String} id - the name of the attribute (matching up to a shader)
    * @param {PIXI.Buffer} [buffer] the buffer that holds the data of the attribute . You can also provide an Array and a buffer will be created from it.
    * @param {Number} [size=0] the size of the attribute. If you have 2 floats per vertex (eg position x and y) this would be 2
    * @param {Boolean} [normalized=false] should the data be normalized.
    * @param {Number} [type=PIXI.TYPES.FLOAT] what type of number is the attribute. Check {PIXI.TYPES} to see the ones available
    * @param {Number} [stride=0] How far apart (in floats) the start of each value is. (used for interleaving data)
    * @param {Number} [start=0] How far into the array to start reading values (used for interleaving data)
    *
    * @return {PIXI.Geometry} returns self, useful for chaining.
    */
    addAttribute(id, buffer, size = null, normalized = false, type = null, stride = undefined, start = undefined, instance = undefined) {
        if (!buffer) {
            throw new Error('You must pass a buffer when creating an attribute');
        }
        // check if this is a buffer!
        if (!buffer.data) {
            // its an array!
            if (buffer instanceof Array) {
                buffer = new Float32Array(buffer);
            }
            buffer = new Buffer_1.Buffer(buffer);
        }
        var ids = id.split('|');
        if (ids.length > 1) {
            for (var i = 0; i < ids.length; i++) {
                this.addAttribute(ids[i], buffer, size, normalized, type);
            }
            return this;
        }
        var bufferIndex = this.buffers.indexOf(buffer);
        if (bufferIndex === -1) {
            this.buffers.push(buffer);
            bufferIndex = this.buffers.length - 1;
        }
        this.attributes[id] = new Attribute_1.Attribute(bufferIndex, size, normalized, type, stride, start, instance);
        // assuming that if there is instanced data then this will be drawn with instancing!
        this.instanced = this.instanced || instance;
        return this;
    }
    ;
    /**
     * returns the requested attribute
     *
     * @param {String} id  the name of the attribute required
     * @return {PIXI.Attribute} the attribute requested.
     */
    getAttribute(id) {
        return this.buffers[this.attributes[id].buffer];
    }
    ;
    /**
    *
    * Adds an index buffer to the geometry
    * The index buffer contains integers, three for each triangle in the geometry, which reference the various attribute buffers (position, colour, UV coordinates, other UV coordinates, normal, ). There is only ONE index buffer.
    *
    * @param {PIXI.Buffer} [buffer] the buffer that holds the data of the index buffer. You can also provide an Array and a buffer will be created from it.
    * @return {PIXI.Geometry} returns self, useful for chaining.
    */
    addIndex(buffer) {
        if (!buffer.data) {
            // its an array!
            if (buffer instanceof Array) {
                buffer = new Uint16Array(buffer);
            }
            buffer = new Buffer_1.Buffer(buffer);
        }
        buffer.index = true;
        this.indexBuffer = buffer;
        if (this.buffers.indexOf(buffer) === -1) {
            this.buffers.push(buffer);
        }
        return this;
    }
    ;
    /**
     * returns the index buffer
     *
     * @return {PIXI.Buffer} the index buffer.
     */
    getIndex() {
        return this.indexBuffer;
    }
    ;
    /**
     * this function modifies the structure so that all current attributes become interleaved into a single buffer
     * This can be useful if your model remains static as it offers a little performance boost
     *
     * @return {PIXI.Geometry} returns self, useful for chaining.
     */
    interleave() {
        // a simple check to see if buffers are already interleaved..
        if (this.buffers.length === 1 || (this.buffers.length === 2 && this.indexBuffer)) {
            return this;
        }
        // assume already that no buffers are interleaved
        var arrays = [];
        var sizes = [];
        var interleavedBuffer = new Buffer_1.Buffer();
        var i;
        for (i in this.attributes) {
            var attribute = this.attributes[i];
            var buffer = this.buffers[attribute.buffer];
            arrays.push(buffer.data);
            sizes.push((attribute.size * Geometry.byteSizeMap[attribute.type]) / 4);
            attribute.buffer = 0;
        }
        interleavedBuffer.data = Geometry.interleaveTypedArrays(arrays, sizes);
        for (i = 0; i < this.buffers.length; i++) {
            if (this.buffers[i] !== this.indexBuffer) {
                this.buffers[i].destroy();
            }
        }
        this.buffers = [interleavedBuffer];
        if (this.indexBuffer) {
            this.buffers.push(this.indexBuffer);
        }
        return this;
    }
    ;
    getSize() {
        for (var i in this.attributes) {
            var attribute = this.attributes[i];
            var buffer = this.buffers[attribute.buffer];
            return buffer.data.length / ((attribute.stride / 4) || attribute.size);
        }
        return 0;
    }
    ;
    /**
     * disposes WebGL resources that are connected to this geometry
     */
    dispose() {
        // this.disposeRunner.run(this, false);
        this.disposeRunner.run(this, false);
    }
    ;
    /**
     * Destroys the geometry.
     */
    destroy(options = null) {
        this.dispose();
        this.buffers = null;
        this.indexBuffer.destroy();
        this.attributes = null;
    }
    ;
    /**
     * returns a clone of the geometry
     *
     * @returns {PIXI.Geometry} a new clone of this geometry
     */
    clone() {
        var geometry = new Geometry();
        for (var i = 0; i < this.buffers.length; i++) {
            geometry.buffers[i] = new Buffer_1.Buffer(this.buffers[i].data.slice());
        }
        for (var i$1 in this.attributes) {
            var attrib = this.attributes[i$1];
            geometry.attributes[i$1] = new Attribute_1.Attribute(attrib.buffer, attrib.size, attrib.normalized, attrib.type, attrib.stride, attrib.start, attrib.instance);
        }
        if (this.indexBuffer) {
            geometry.indexBuffer = geometry.buffers[this.buffers.indexOf(this.indexBuffer)];
            geometry.indexBuffer.index = true;
        }
        return geometry;
    }
    ;
    /**
     * merges an array of geometries into a new single one
     * geometry attribute styles must match for this operation to work
     *
     * @param {PIXI.Geometry[]} geometries array of geometries to merge
     * @returns {PIXI.Geometry} shiny new geometry!
     */
    static merge(geometries) {
        // todo add a geometry check!
        // also a size check.. cant be too big!]
        var geometryOut = new Geometry();
        var arrays = [];
        var sizes = [];
        var offsets = [];
        var geometry;
        // pass one.. get sizes..
        for (var i = 0; i < geometries.length; i++) {
            geometry = geometries[i];
            for (var j = 0; j < geometry.buffers.length; j++) {
                sizes[j] = sizes[j] || 0;
                sizes[j] += geometry.buffers[j].data.length;
                offsets[j] = 0;
            }
        }
        // build the correct size arrays..
        for (var i$1 = 0; i$1 < geometry.buffers.length; i$1++) {
            // TODO types!
            arrays[i$1] = new Geometry.map$1[Geometry.getBufferType(geometry.buffers[i$1].data)](sizes[i$1]);
            geometryOut.buffers[i$1] = new Buffer_1.Buffer(arrays[i$1]);
        }
        // pass to set data..
        for (var i$2 = 0; i$2 < geometries.length; i$2++) {
            geometry = geometries[i$2];
            for (var j$1 = 0; j$1 < geometry.buffers.length; j$1++) {
                arrays[j$1].set(geometry.buffers[j$1].data, offsets[j$1]);
                offsets[j$1] += geometry.buffers[j$1].data.length;
            }
        }
        geometryOut.attributes = geometry.attributes;
        if (geometry.indexBuffer) {
            geometryOut.indexBuffer = geometryOut.buffers[geometry.buffers.indexOf(geometry.indexBuffer)];
            geometryOut.indexBuffer.index = true;
            var offset = 0;
            var stride = 0;
            var offset2 = 0;
            var bufferIndexToCount = 0;
            // get a buffer
            for (var i$3 = 0; i$3 < geometry.buffers.length; i$3++) {
                if (geometry.buffers[i$3] !== geometry.indexBuffer) {
                    bufferIndexToCount = i$3;
                    break;
                }
            }
            // figure out the stride of one buffer..
            for (var i$4 in geometry.attributes) {
                var attribute = geometry.attributes[i$4];
                if ((attribute.buffer | 0) === bufferIndexToCount) {
                    stride += ((attribute.size * Geometry.byteSizeMap[attribute.type]) / 4);
                }
            }
            // time to off set all indexes..
            for (var i$5 = 0; i$5 < geometries.length; i$5++) {
                var indexBufferData = geometries[i$5].indexBuffer.data;
                for (var j$2 = 0; j$2 < indexBufferData.length; j$2++) {
                    geometryOut.indexBuffer.data[j$2 + offset2] += offset;
                }
                offset += geometry.buffers[bufferIndexToCount].data.length / (stride);
                offset2 += indexBufferData.length;
            }
        }
        return geometryOut;
    }
    ;
    static getBufferType(array) {
        if (array.BYTES_PER_ELEMENT === 4) {
            if (array instanceof Float32Array) {
                return 'Float32Array';
            }
            else if (array instanceof Uint32Array) {
                return 'Uint32Array';
            }
            return 'Int32Array';
        }
        else if (array.BYTES_PER_ELEMENT === 2) {
            if (array instanceof Uint16Array) {
                return 'Uint16Array';
            }
        }
        else if (array.BYTES_PER_ELEMENT === 1) {
            if (array instanceof Uint8Array) {
                return 'Uint8Array';
            }
        }
        // TODO map out the rest of the array elements!
        return null;
    }
    static interleaveTypedArrays(arrays, sizes) {
        var outSize = 0;
        var stride = 0;
        var views = {};
        for (var i = 0; i < arrays.length; i++) {
            stride += sizes[i];
            outSize += arrays[i].length;
        }
        var buffer = new ArrayBuffer(outSize * 4);
        var out = null;
        var littleOffset = 0;
        for (var i$1 = 0; i$1 < arrays.length; i$1++) {
            var size = sizes[i$1];
            var array = arrays[i$1];
            var type = Geometry.getBufferType(array);
            if (!views[type]) {
                views[type] = new Geometry.map[type](buffer);
            }
            out = views[type];
            for (var j = 0; j < array.length; j++) {
                var indexStart = ((j / size | 0) * stride) + littleOffset;
                var index = j % size;
                out[indexStart + index] = array[j];
            }
            littleOffset += size;
        }
        return new Float32Array(buffer);
    }
}
/* eslint-disable object-shorthand */
Geometry.map = {
    Float32Array: Float32Array,
    Uint32Array: Uint32Array,
    Int32Array: Int32Array,
    Uint8Array: Uint8Array,
};
Geometry.UID$1 = 0;
/* eslint-disable object-shorthand */
Geometry.map$1 = {
    Float32Array: Float32Array,
    Uint32Array: Uint32Array,
    Int32Array: Int32Array,
    Uint8Array: Uint8Array,
    Uint16Array: Uint16Array,
};
Geometry.byteSizeMap = { 5126: 4, 5123: 2, 5121: 1 };
exports.Geometry = Geometry;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/GeometrySystem.js":
/*!**************************************************!*\
  !*** ./js-compile/raw-pixi-ts/GeometrySystem.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const System_1 = __webpack_require__(/*! ./System */ "./js-compile/raw-pixi-ts/System.js");
const GLBuffer_1 = __webpack_require__(/*! ./GLBuffer */ "./js-compile/raw-pixi-ts/GLBuffer.js");
const DisplaySettings_1 = __webpack_require__(/*! ./DisplaySettings */ "./js-compile/raw-pixi-ts/DisplaySettings.js");
class GeometrySystem extends System_1.System {
    constructor(renderer) {
        super(renderer);
        this._activeGeometry = null;
        this._activeVao = null;
        /**
         * `true` if we has `*_vertex_array_object` extension
         * @member {boolean}
         * @readonly
         */
        this.hasVao = true;
        /**
         * `true` if has `ANGLE_instanced_arrays` extension
         * @member {boolean}
         * @readonly
         */
        this.hasInstance = true;
        /**
         * A cache of currently bound buffer,
         * contains only two members with keys ARRAY_BUFFER and ELEMENT_ARRAY_BUFFER
         * @member {Object.<number, PIXI.Buffer>}
         * @readonly
         */
        this.boundBuffers = {};
        /**
         * Cache for all geometries by id, used in case renderer gets destroyed or for profiling
         * @member {object}
         * @readonly
         */
        this.managedGeometries = {};
        /**
         * Cache for all buffers by id, used in case renderer gets destroyed or for profiling
         * @member {object}
         * @readonly
         */
        this.managedBuffers = {};
    }
    /**
     * Sets up the renderer context and necessary buffers.
     */
    contextChange() {
        this.disposeAll(true);
        var gl = this.gl = this.renderer.gl;
        this.CONTEXT_UID = this.renderer.CONTEXT_UID;
        // webgl2
        if (!gl.createVertexArray) {
            // webgl 1!
            var nativeVaoExtension = this.renderer.context.extensions.vertexArrayObject;
            if (DisplaySettings_1.DisplaySettings.PREFER_ENV === DisplaySettings_1.DisplaySettings.ENV.WEBGL_LEGACY) {
                nativeVaoExtension = null;
            }
            if (nativeVaoExtension) {
                gl.createVertexArray = function () { return nativeVaoExtension.createVertexArrayOES(); };
                gl.bindVertexArray = function (vao) { return nativeVaoExtension.bindVertexArrayOES(vao); };
                gl.deleteVertexArray = function (vao) { return nativeVaoExtension.deleteVertexArrayOES(vao); };
            }
            else {
                this.hasVao = false;
                gl.createVertexArray = function () {
                    // empty
                };
                gl.bindVertexArray = function () {
                    // empty
                };
                gl.deleteVertexArray = function () {
                    // empty
                };
            }
        }
        if (!gl.vertexAttribDivisor) {
            var instanceExt = gl.getExtension('ANGLE_instanced_arrays');
            if (instanceExt) {
                gl.vertexAttribDivisor = function (a, b) { return instanceExt.vertexAttribDivisorANGLE(a, b); };
                gl.drawElementsInstanced = function (a, b, c, d, e) { return instanceExt.drawElementsInstancedANGLE(a, b, c, d, e); };
                gl.drawArraysInstanced = function (a, b, c, d) { return instanceExt.drawArraysInstancedANGLE(a, b, c, d); };
            }
            else {
                this.hasInstance = false;
            }
        }
    }
    ;
    /**
     * Binds geometry so that is can be drawn. Creating a Vao if required
     * @protected
     * @param {PIXI.Geometry} geometry instance of geometry to bind
     * @param {PIXI.Shader} shader instance of shader to bind
     */
    bind(geometry, shader = null) {
        shader = shader || this.renderer.shader.shader;
        var ref = this;
        var gl = ref.gl;
        // not sure the best way to address this..
        // currently different shaders require different VAOs for the same geometry
        // Still mulling over the best way to solve this one..
        // will likely need to modify the shader attribute locations at run time!
        var vaos = geometry.glVertexArrayObjects[this.CONTEXT_UID];
        if (!vaos) {
            this.managedGeometries[geometry.id] = geometry;
            // geometry.disposeRunner.add(this);
            geometry.glVertexArrayObjects[this.CONTEXT_UID] = vaos = {};
        }
        var vao = vaos[shader.program.id] || this.initGeometryVao(geometry, shader.program);
        this._activeGeometry = geometry;
        if (this._activeVao !== vao) {
            this._activeVao = vao;
            if (this.hasVao) {
                gl.bindVertexArray(vao);
            }
            else {
                this.activateVao(geometry, shader.program);
            }
        }
        // TODO - optimise later!
        // don't need to loop through if nothing changed!
        // maybe look to add an 'autoupdate' to geometry?
        this.updateBuffers();
    }
    ;
    /**
     * Reset and unbind any active VAO and geometry
     */
    reset() {
        this.unbind();
    }
    ;
    /**
     * Update buffers
     * @protected
     */
    updateBuffers() {
        var geometry = this._activeGeometry;
        var ref = this;
        var gl = ref.gl;
        for (var i = 0; i < geometry.buffers.length; i++) {
            var buffer = geometry.buffers[i];
            var glBuffer = buffer._glBuffers[this.CONTEXT_UID];
            if (buffer._updateID !== glBuffer.updateID) {
                glBuffer.updateID = buffer._updateID;
                // TODO can cache this on buffer! maybe added a getter / setter?
                var type = buffer.index ? gl.ELEMENT_ARRAY_BUFFER : gl.ARRAY_BUFFER;
                // TODO this could change if the VAO changes...
                // need to come up with a better way to cache..
                // if (this.boundBuffers[type] !== glBuffer)
                // {
                // this.boundBuffers[type] = glBuffer;
                gl.bindBuffer(type, glBuffer.buffer);
                // }
                this._boundBuffer = glBuffer;
                if (glBuffer.byteLength >= buffer.data.byteLength) {
                    // offset is always zero for now!
                    gl.bufferSubData(type, 0, buffer.data);
                }
                else {
                    var drawType = buffer.static ? gl.STATIC_DRAW : gl.DYNAMIC_DRAW;
                    glBuffer.byteLength = buffer.data.byteLength;
                    gl.bufferData(type, buffer.data, drawType);
                }
            }
        }
    }
    ;
    /**
     * Check compability between a geometry and a program
     * @protected
     * @param {PIXI.Geometry} geometry - Geometry instance
     * @param {PIXI.Program} program - Program instance
     */
    checkCompatibility(geometry, program) {
        // geometry must have at least all the attributes that the shader requires.
        var geometryAttributes = geometry.attributes;
        var shaderAttributes = program.attributeData;
        for (var j in shaderAttributes) {
            if (!geometryAttributes[j]) {
                throw new Error(("shader and geometry incompatible, geometry missing the \"" + j + "\" attribute"));
            }
        }
    }
    ;
    /**
     * Takes a geometry and program and generates a unique signature for them.
     *
     * @param {PIXI.Geometry} geometry to get signature from
     * @param {PIXI.Program} program to test geometry against
     * @returns {String} Unique signature of the geometry and program
     * @protected
     */
    getSignature(geometry, program) {
        var attribs = geometry.attributes;
        var shaderAttributes = program.attributeData;
        var strings = ['g', geometry.id];
        for (var i in attribs) {
            if (shaderAttributes[i]) {
                strings.push(i);
            }
        }
        return strings.join('-');
    }
    ;
    /**
     * Creates or gets Vao with the same structure as the geometry and stores it on the geometry.
     * If vao is created, it is bound automatically.
     *
     * @protected
     * @param {PIXI.Geometry} geometry - Instance of geometry to to generate Vao for
     * @param {PIXI.Program} program - Instance of program
     */
    initGeometryVao(geometry, program) {
        this.checkCompatibility(geometry, program);
        var gl = this.gl;
        var CONTEXT_UID = this.CONTEXT_UID;
        var signature = this.getSignature(geometry, program);
        var vaoObjectHash = geometry.glVertexArrayObjects[this.CONTEXT_UID];
        var vao = vaoObjectHash[signature];
        if (vao) {
            // this will give us easy access to the vao
            vaoObjectHash[program.id] = vao;
            return vao;
        }
        var buffers = geometry.buffers;
        var attributes = geometry.attributes;
        var tempStride = {};
        var tempStart = {};
        for (var j in buffers) {
            tempStride[j] = 0;
            tempStart[j] = 0;
        }
        for (var j$1 in attributes) {
            if (!attributes[j$1].size && program.attributeData[j$1]) {
                attributes[j$1].size = program.attributeData[j$1].size;
            }
            else if (!attributes[j$1].size) {
                console.warn(("PIXI Geometry attribute '" + j$1 + "' size cannot be determined (likely the bound shader does not have the attribute)")); // eslint-disable-line
            }
            tempStride[attributes[j$1].buffer] += attributes[j$1].size * GeometrySystem.byteSizeMap$1[attributes[j$1].type];
        }
        for (var j$2 in attributes) {
            var attribute = attributes[j$2];
            var attribSize = attribute.size;
            if (attribute.stride === undefined) {
                if (tempStride[attribute.buffer] === attribSize * GeometrySystem.byteSizeMap$1[attribute.type]) {
                    attribute.stride = 0;
                }
                else {
                    attribute.stride = tempStride[attribute.buffer];
                }
            }
            if (attribute.start === undefined) {
                attribute.start = tempStart[attribute.buffer];
                tempStart[attribute.buffer] += attribSize * GeometrySystem.byteSizeMap$1[attribute.type];
            }
        }
        vao = gl.createVertexArray();
        gl.bindVertexArray(vao);
        // first update - and create the buffers!
        // only create a gl buffer if it actually gets
        for (var i = 0; i < buffers.length; i++) {
            var buffer = buffers[i];
            if (!buffer._glBuffers[CONTEXT_UID]) {
                buffer._glBuffers[CONTEXT_UID] = new GLBuffer_1.GLBuffer(gl.createBuffer());
                this.managedBuffers[buffer.id] = buffer;
                // buffer.disposeRunner.add(this);
            }
            buffer._glBuffers[CONTEXT_UID].refCount++;
        }
        // TODO - maybe make this a data object?
        // lets wait to see if we need to first!
        this.activateVao(geometry, program);
        this._activeVao = vao;
        // add it to the cache!
        vaoObjectHash[program.id] = vao;
        vaoObjectHash[signature] = vao;
        return vao;
    }
    ;
    /**
     * Disposes buffer
     * @param {PIXI.Buffer} buffer buffer with data
     * @param {boolean} [contextLost=false] If context was lost, we suppress deleteVertexArray
     */
    disposeBuffer(buffer, contextLost) {
        if (!this.managedBuffers[buffer.id]) {
            return;
        }
        delete this.managedBuffers[buffer.id];
        var glBuffer = buffer._glBuffers[this.CONTEXT_UID];
        var gl = this.gl;
        // buffer.disposeRunner.remove(this);
        if (!glBuffer) {
            return;
        }
        if (!contextLost) {
            gl.deleteBuffer(glBuffer.buffer);
        }
        delete buffer._glBuffers[this.CONTEXT_UID];
    }
    ;
    /**
     * Disposes geometry
     * @param {PIXI.Geometry} geometry Geometry with buffers. Only VAO will be disposed
     * @param {boolean} [contextLost=false] If context was lost, we suppress deleteVertexArray
     */
    disposeGeometry(geometry, contextLost) {
        if (!this.managedGeometries[geometry.id]) {
            return;
        }
        delete this.managedGeometries[geometry.id];
        var vaos = geometry.glVertexArrayObjects[this.CONTEXT_UID];
        var gl = this.gl;
        var buffers = geometry.buffers;
        geometry.disposeRunner.remove(this);
        if (!vaos) {
            return;
        }
        for (var i = 0; i < buffers.length; i++) {
            var buf = buffers[i]._glBuffers[this.CONTEXT_UID];
            buf.refCount--;
            if (buf.refCount === 0 && !contextLost) {
                this.disposeBuffer(buffers[i], contextLost);
            }
        }
        if (!contextLost) {
            for (var vaoId in vaos) {
                // delete only signatures, everything else are copies
                if (vaoId[0] === 'g') {
                    var vao = vaos[vaoId];
                    if (this._activeVao === vao) {
                        this.unbind();
                    }
                    gl.deleteVertexArray(vao);
                }
            }
        }
        delete geometry.glVertexArrayObjects[this.CONTEXT_UID];
    }
    ;
    /**
     * dispose all WebGL resources of all managed geometries and buffers
     * @param {boolean} [contextLost=false] If context was lost, we suppress `gl.delete` calls
     */
    disposeAll(contextLost) {
        var all = Object.keys(this.managedGeometries);
        for (var i = 0; i < all.length; i++) {
            this.disposeGeometry(this.managedGeometries[all[i]], contextLost);
        }
        all = Object.keys(this.managedBuffers);
        for (var i$1 = 0; i$1 < all.length; i$1++) {
            this.disposeBuffer(this.managedBuffers[all[i$1]], contextLost);
        }
    }
    ;
    /**
     * Activate vertex array object
     *
     * @protected
     * @param {PIXI.Geometry} geometry - Geometry instance
     * @param {PIXI.Program} program - Shader program instance
     */
    activateVao(geometry, program) {
        var gl = this.gl;
        var CONTEXT_UID = this.CONTEXT_UID;
        var buffers = geometry.buffers;
        var attributes = geometry.attributes;
        if (geometry.indexBuffer) {
            // first update the index buffer if we have one..
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, geometry.indexBuffer._glBuffers[CONTEXT_UID].buffer);
        }
        var lastBuffer = null;
        // add a new one!
        for (var j in attributes) {
            var attribute = attributes[j];
            var buffer = buffers[attribute.buffer];
            var glBuffer = buffer._glBuffers[CONTEXT_UID];
            if (program.attributeData[j]) {
                if (lastBuffer !== glBuffer) {
                    gl.bindBuffer(gl.ARRAY_BUFFER, glBuffer.buffer);
                    lastBuffer = glBuffer;
                }
                var location = program.attributeData[j].location;
                // TODO introduce state again
                // we can optimise this for older devices that have no VAOs
                gl.enableVertexAttribArray(location);
                gl.vertexAttribPointer(location, attribute.size, attribute.type || gl.FLOAT, attribute.normalized, attribute.stride, attribute.start);
                if (attribute.instance) {
                    // TODO calculate instance count based of this...
                    if (this.hasInstance) {
                        gl.vertexAttribDivisor(location, 1);
                    }
                    else {
                        throw new Error('geometry error, GPU Instancing is not supported on this device');
                    }
                }
            }
        }
    }
    ;
    /**
     * Draw the geometry
     *
     * @param {Number} type - the type primitive to render
     * @param {Number} [size] - the number of elements to be rendered
     * @param {Number} [start] - Starting index
     * @param {Number} [instanceCount] - the number of instances of the set of elements to execute
     */
    draw(type, size = -1, start = 0, instanceCount = 1) {
        var ref = this;
        var gl = ref.gl;
        var geometry = this._activeGeometry;
        // TODO.. this should not change so maybe cache the function?
        if (size < 0) {
            size = geometry.indexBuffer.data.length;
        }
        if (geometry.indexBuffer) {
            if (geometry.instanced) {
                /* eslint-disable max-len */
                gl.drawElementsInstanced(type, size || geometry.indexBuffer.data.length, gl.UNSIGNED_SHORT, (start || 0) * 2, instanceCount || 1);
                /* eslint-enable max-len */
            }
            else {
                gl.drawElements(type, size || geometry.indexBuffer.data.length, gl.UNSIGNED_SHORT, (start || 0) * 2);
            }
        }
        else if (geometry.instanced) {
            // TODO need a better way to calculate size..
            gl.drawArraysInstanced(type, start, size || geometry.getSize(), instanceCount || 1);
        }
        else {
            gl.drawArrays(type, start, size || geometry.getSize());
        }
        return this;
    }
    ;
    /**
     * Unbind/reset everything
     * @protected
     */
    unbind() {
        this.gl.bindVertexArray(null);
        this._activeVao = null;
        this._activeGeometry = null;
    }
    ;
}
GeometrySystem.byteSizeMap$1 = { 5126: 4, 5123: 2, 5121: 1 };
exports.GeometrySystem = GeometrySystem;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/Graphics.js":
/*!********************************************!*\
  !*** ./js-compile/raw-pixi-ts/Graphics.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Container_1 = __webpack_require__(/*! ./Container */ "./js-compile/raw-pixi-ts/Container.js");
const State_1 = __webpack_require__(/*! ./State */ "./js-compile/raw-pixi-ts/State.js");
const FillStyle_1 = __webpack_require__(/*! ./FillStyle */ "./js-compile/raw-pixi-ts/FillStyle.js");
// import { settings } from "./settings";
const Texture_1 = __webpack_require__(/*! ./Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const Rectangle_1 = __webpack_require__(/*! ../flash/geom/Rectangle */ "./js-compile/flash/geom/Rectangle.js");
const Matrix_1 = __webpack_require__(/*! ./Matrix */ "./js-compile/raw-pixi-ts/Matrix.js");
const UniformGroup_1 = __webpack_require__(/*! ./UniformGroup */ "./js-compile/raw-pixi-ts/UniformGroup.js");
const Shader_1 = __webpack_require__(/*! ./Shader */ "./js-compile/raw-pixi-ts/Shader.js");
const Point_1 = __webpack_require__(/*! ../flash/geom/Point */ "./js-compile/flash/geom/Point.js");
const Polygon_1 = __webpack_require__(/*! ./Polygon */ "./js-compile/raw-pixi-ts/Polygon.js");
const Ellipse_1 = __webpack_require__(/*! ./Ellipse */ "./js-compile/raw-pixi-ts/Ellipse.js");
const Circle_1 = __webpack_require__(/*! ./Circle */ "./js-compile/raw-pixi-ts/Circle.js");
const RoundedRectangle_1 = __webpack_require__(/*! ./RoundedRectangle */ "./js-compile/raw-pixi-ts/RoundedRectangle.js");
const ArcUtils_1 = __webpack_require__(/*! ./ArcUtils */ "./js-compile/raw-pixi-ts/ArcUtils.js");
const BezierUtils_1 = __webpack_require__(/*! ./BezierUtils */ "./js-compile/raw-pixi-ts/BezierUtils.js");
const QuadraticUtils_1 = __webpack_require__(/*! ./QuadraticUtils */ "./js-compile/raw-pixi-ts/QuadraticUtils.js");
const LineStyle_1 = __webpack_require__(/*! ./LineStyle */ "./js-compile/raw-pixi-ts/LineStyle.js");
const GraphicsGeometry_1 = __webpack_require__(/*! ./GraphicsGeometry */ "./js-compile/raw-pixi-ts/GraphicsGeometry.js");
const Star_1 = __webpack_require__(/*! ./Star */ "./js-compile/raw-pixi-ts/Star.js");
const MathSettings_1 = __webpack_require__(/*! ./MathSettings */ "./js-compile/raw-pixi-ts/MathSettings.js");
const BlendModesSettings_1 = __webpack_require__(/*! ./BlendModesSettings */ "./js-compile/raw-pixi-ts/BlendModesSettings.js");
const ColorSettings_1 = __webpack_require__(/*! ./ColorSettings */ "./js-compile/raw-pixi-ts/ColorSettings.js");
const InstanceCounter_1 = __webpack_require__(/*! ./InstanceCounter */ "./js-compile/raw-pixi-ts/InstanceCounter.js");
class Graphics extends Container_1.Container {
    constructor(geometry = null) {
        super();
        if (geometry === void 0) {
            geometry = null;
        }
        /**
         * Includes vertex positions, face indices, normals, colors, UVs, and
         * custom attributes within buffers, reducing the cost of passing all
         * this data to the GPU. Can be shared between multiple Mesh or Graphics objects.
         * @member {PIXI.GraphicsGeometry}
         * @readonly
         */
        this.geometry = geometry || new GraphicsGeometry_1.GraphicsGeometry();
        this.geometry.refCount++;
        /**
         * Represents the vertex and fragment shaders that processes the geometry and runs on the GPU.
         * Can be shared between multiple Graphics objects.
         * @member {PIXI.Shader}
         */
        this.shader = null;
        /**
         * Represents the WebGL state the Graphics required to render, excludes shader and geometry. E.g.,
         * blend mode, culling, depth testing, direction of rendering triangles, backface, etc.
         * @member {PIXI.State}
         */
        this.state = State_1.State.for2d();
        /**
         * Current fill style
         *
         * @member {PIXI.FillStyle}
         * @protected
         */
        this._fillStyle = new FillStyle_1.FillStyle();
        /**
         * Current line style
         *
         * @member {PIXI.LineStyle}
         * @protected
         */
        this._lineStyle = new LineStyle_1.LineStyle();
        /**
         * Current shape transform matrix.
         *
         * @member {PIXI.Matrix}
         * @protected
         */
        this._matrix = null;
        /**
         * Current hole mode is enabled.
         *
         * @member {boolean}
         * @default false
         * @protected
         */
        this._holeMode = false;
        /**
         * Current path
         *
         * @member {PIXI.Polygon}
         * @protected
         */
        this.currentPath = null;
        /**
         * When cacheAsBitmap is set to true the graphics object will be rendered as if it was a sprite.
         * This is useful if your graphics element does not change often, as it will speed up the rendering
         * of the object in exchange for taking up texture memory. It is also useful if you need the graphics
         * object to be anti-aliased, because it will be rendered using canvas. This is not recommended if
         * you are constantly redrawing the graphics element.
         *
         * @name cacheAsBitmap
         * @member {boolean}
         * @memberof PIXI.Graphics#
         * @default false
         */
        /**
         * A collections of batches! These can be drawn by the renderer batch system.
         *
         * @protected
         * @member {object[]}
         */
        this.batches = [];
        /**
         * Update dirty for limiting calculating tints for batches.
         *
         * @protected
         * @member {number}
         * @default -1
         */
        this.batchTint = -1;
        /**
         * Copy of the object vertex data.
         *
         * @protected
         * @member {Float32Array}
         */
        this.vertexData = null;
        this._transformID = -1;
        this.batchDirty = -1;
        // Set default
        this.tint = 0xFFFFFF;
        this.blendMode = BlendModesSettings_1.BlendModesSettings.BLEND_MODES.NORMAL;
    }
    /**
     * Creates a new Graphics object with the same values as this one.
     * Note that the only the properties of the object are cloned, not its transform (position,scale,etc)
     *
     * @return {PIXI.Graphics} A clone of the graphics object
     */
    clone() {
        this.finishPoly();
        return new Graphics(this.geometry);
    }
    ;
    /**
     * The blend mode to be applied to the graphic shape. Apply a value of
     * `PIXI.BLEND_MODES.NORMAL` to reset the blend mode.
     *
     * @member {number}
     * @default PIXI.BLEND_MODES.NORMAL;
     * @see PIXI.BLEND_MODES
     */
    set blendMode(value) {
        this.state.blendMode = value;
    }
    ;
    get blendMode() {
        return this.state.blendMode;
    }
    ;
    /**
     * The tint applied to the graphic shape. This is a hex value. A value of
     * 0xFFFFFF will remove any tint effect.
     *
     * @member {number}
     * @default 0xFFFFFF
     */
    get tint() {
        return this._tint;
    }
    ;
    set tint(value) {
        this._tint = value;
    }
    ;
    /**
     * The current fill style.
     *
     * @member {PIXI.FillStyle}
     * @readonly
     */
    get fill() {
        return this._fillStyle;
    }
    ;
    /**
     * The current line style.
     *
     * @member {PIXI.LineStyle}
     * @readonly
     */
    get line() {
        return this._lineStyle;
    }
    ;
    /**
     * Specifies the line style used for subsequent calls to Graphics methods such as the lineTo()
     * method or the drawCircle() method.
     *
     * @param {number} [width=0] - width of the line to draw, will update the objects stored style
     * @param {number} [color=0] - color of the line to draw, will update the objects stored style
     * @param {number} [alpha=1] - alpha of the line to draw, will update the objects stored style
     * @param {number} [alignment=1] - alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outter)
     * @param {boolean} [native=false] - If true the lines will be draw using LINES instead of TRIANGLE_STRIP
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */
    lineStyle(width, color = 0, alpha = 1, alignment = 0.5, native = false) {
        if (width === void 0) {
            width = 0;
        }
        if (color === void 0) {
            color = 0;
        }
        if (alpha === void 0) {
            alpha = 1;
        }
        if (alignment === void 0) {
            alignment = 0.5;
        }
        if (native === void 0) {
            native = false;
        }
        this.lineTextureStyle(width, Texture_1.Texture.WHITE, color, alpha, null, alignment, native);
        return this;
    }
    ;
    /**
     * Like line style but support texture for line fill.
     *
     * @param {number} [width=0] - width of the line to draw, will update the objects stored style
     * @param {PIXI.Texture} [texture=PIXI.Texture.WHITE] - Texture to use
     * @param {number} [color=0] - color of the line to draw, will update the objects stored style
     * @param {number} [alpha=1] - alpha of the line to draw, will update the objects stored style
     * @param {PIXI.Matrix} [matrix=null] Texture matrix to transform texture
     * @param {number} [alignment=0.5] - alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outter)
     * @param {boolean} [native=false] - If true the lines will be draw using LINES instead of TRIANGLE_STRIP
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */
    lineTextureStyle(width = 0, texture = Texture_1.Texture.WHITE, color = 0xFFFFFF, alpha = 1, matrix = null, alignment = 0.5, native = false) {
        if (width === void 0) {
            width = 0;
        }
        if (texture === void 0) {
            texture = Texture_1.Texture.WHITE;
        }
        if (color === void 0) {
            color = 0xFFFFFF;
        }
        if (alpha === void 0) {
            alpha = 1;
        }
        if (matrix === void 0) {
            matrix = null;
        }
        if (alignment === void 0) {
            alignment = 0.5;
        }
        if (native === void 0) {
            native = false;
        }
        if (this.currentPath) {
            this.startPoly();
        }
        var visible = width > 0 && alpha > 0;
        if (!visible) {
            this._lineStyle.reset();
        }
        else {
            if (matrix) {
                matrix = matrix.clone();
                matrix.invert();
            }
            Object.assign(this._lineStyle, {
                color: color,
                width: width,
                alpha: alpha,
                matrix: matrix,
                texture: texture,
                alignment: alignment,
                native: native,
                visible: visible,
            });
        }
        return this;
    }
    ;
    /**
     * Start a polygon object internally
     * @protected
     */
    startPoly() {
        if (this.currentPath) {
            var points = this.currentPath.points;
            var len = this.currentPath.points.length;
            if (len > 2) {
                this.drawShape(this.currentPath);
                this.currentPath = new Polygon_1.Polygon();
                this.currentPath.closeStroke = false;
                this.currentPath.points.push(points[len - 2], points[len - 1]);
            }
        }
        else {
            this.currentPath = new Polygon_1.Polygon();
            this.currentPath.closeStroke = false;
        }
    }
    ;
    /**
     * Finish the polygon object.
     * @protected
     */
    finishPoly() {
        if (this.currentPath) {
            if (this.currentPath.points.length > 2) {
                this.drawShape(this.currentPath);
                this.currentPath = null;
            }
            else {
                this.currentPath.points.length = 0;
            }
        }
    }
    ;
    /**
     * Moves the current drawing position to x, y.
     *
     * @param {number} x - the X coordinate to move to
     * @param {number} y - the Y coordinate to move to
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */
    moveTo(x, y) {
        this.startPoly();
        this.currentPath.points[0] = x;
        this.currentPath.points[1] = y;
        return this;
    }
    ;
    /**
     * Draws a line using the current line style from the current drawing position to (x, y);
     * The current drawing position is then set to (x, y).
     *
     * @param {number} x - the X coordinate to draw to
     * @param {number} y - the Y coordinate to draw to
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */
    lineTo(x, y) {
        if (!this.currentPath) {
            this.moveTo(0, 0);
        }
        // remove duplicates..
        var points = this.currentPath.points;
        var fromX = points[points.length - 2];
        var fromY = points[points.length - 1];
        if (fromX !== x || fromY !== y) {
            points.push(x, y);
        }
        return this;
    }
    ;
    /**
     * Initialize the curve
     *
     * @protected
     * @param {number} [x=0]
     * @param {number} [y=0]
     */
    _initCurve(x = 0, y = 0) {
        if (x === void 0) {
            x = 0;
        }
        if (y === void 0) {
            y = 0;
        }
        if (this.currentPath) {
            if (this.currentPath.points.length === 0) {
                this.currentPath.points = [x, y];
            }
        }
        else {
            this.moveTo(x, y);
        }
    }
    ;
    /**
     * Calculate the points for a quadratic bezier curve and then draws it.
     * Based on: https://stackoverflow.com/questions/785097/how-do-i-implement-a-bezier-curve-in-c
     *
     * @param {number} cpX - Control point x
     * @param {number} cpY - Control point y
     * @param {number} toX - Destination point x
     * @param {number} toY - Destination point y
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */
    quadraticCurveTo(cpX, cpY, toX, toY) {
        this._initCurve();
        var points = this.currentPath.points;
        if (points.length === 0) {
            this.moveTo(0, 0);
        }
        QuadraticUtils_1.QuadraticUtils.curveTo(cpX, cpY, toX, toY, points);
        return this;
    }
    ;
    /**
     * Calculate the points for a bezier curve and then draws it.
     *
     * @param {number} cpX - Control point x
     * @param {number} cpY - Control point y
     * @param {number} cpX2 - Second Control point x
     * @param {number} cpY2 - Second Control point y
     * @param {number} toX - Destination point x
     * @param {number} toY - Destination point y
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */
    bezierCurveTo(cpX, cpY, cpX2, cpY2, toX, toY) {
        this._initCurve();
        BezierUtils_1.BezierUtils.curveTo(cpX, cpY, cpX2, cpY2, toX, toY, this.currentPath.points);
        return this;
    }
    ;
    /**
     * The arcTo() method creates an arc/curve between two tangents on the canvas.
     *
     * "borrowed" from https://code.google.com/p/fxcanvas/ - thanks google!
     *
     * @param {number} x1 - The x-coordinate of the beginning of the arc
     * @param {number} y1 - The y-coordinate of the beginning of the arc
     * @param {number} x2 - The x-coordinate of the end of the arc
     * @param {number} y2 - The y-coordinate of the end of the arc
     * @param {number} radius - The radius of the arc
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */
    arcTo(x1, y1, x2, y2, radius) {
        this._initCurve(x1, y1);
        var points = this.currentPath.points;
        var result = ArcUtils_1.ArcUtils.curveTo(x1, y1, x2, y2, radius, points);
        if (result) {
            var cx = result.cx;
            var cy = result.cy;
            var radius$1 = result.radius;
            var startAngle = result.startAngle;
            var endAngle = result.endAngle;
            var anticlockwise = result.anticlockwise;
            this.arc(cx, cy, radius$1, startAngle, endAngle, anticlockwise);
        }
        return this;
    }
    ;
    /**
     * The arc method creates an arc/curve (used to create circles, or parts of circles).
     *
     * @param {number} cx - The x-coordinate of the center of the circle
     * @param {number} cy - The y-coordinate of the center of the circle
     * @param {number} radius - The radius of the circle
     * @param {number} startAngle - The starting angle, in radians (0 is at the 3 o'clock position
     *  of the arc's circle)
     * @param {number} endAngle - The ending angle, in radians
     * @param {boolean} [anticlockwise=false] - Specifies whether the drawing should be
     *  counter-clockwise or clockwise. False is default, and indicates clockwise, while true
     *  indicates counter-clockwise.
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */
    arc(cx, cy, radius, startAngle, endAngle, anticlockwise = false) {
        if (anticlockwise === void 0) {
            anticlockwise = false;
        }
        if (startAngle === endAngle) {
            return this;
        }
        if (!anticlockwise && endAngle <= startAngle) {
            endAngle += MathSettings_1.MathSettings.PI_2;
        }
        else if (anticlockwise && startAngle <= endAngle) {
            startAngle += MathSettings_1.MathSettings.PI_2;
        }
        var sweep = endAngle - startAngle;
        if (sweep === 0) {
            return this;
        }
        var startX = cx + (Math.cos(startAngle) * radius);
        var startY = cy + (Math.sin(startAngle) * radius);
        // If the currentPath exists, take its points. Otherwise call `moveTo` to start a path.
        var points = this.currentPath ? this.currentPath.points : null;
        if (points) {
            // TODO: make a better fix.
            // We check how far our start is from the last existing point
            var xDiff = Math.abs(points[points.length - 2] - startX);
            var yDiff = Math.abs(points[points.length - 1] - startY);
            if (xDiff < 0.001 && yDiff < 0.001) {
                ;
            }
            else {
                points.push(startX, startY);
            }
        }
        else {
            this.moveTo(startX, startY);
            points = this.currentPath.points;
        }
        ArcUtils_1.ArcUtils.arc(startX, startY, cx, cy, radius, startAngle, endAngle, anticlockwise, points);
        return this;
    }
    ;
    /**
     * Specifies a simple one-color fill that subsequent calls to other Graphics methods
     * (such as lineTo() or drawCircle()) use when drawing.
     *
     * @param {number} [color=0] - the color of the fill
     * @param {number} [alpha=1] - the alpha of the fill
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */
    beginFill(color = 0, alpha = 1) {
        return this.beginTextureFill(Texture_1.Texture.WHITE, color, alpha);
    }
    ;
    /**
     * Begin the texture fill
     *
     * @param {PIXI.Texture} [texture=PIXI.Texture.WHITE] - Texture to fill
     * @param {number} [color=0xffffff] - Background to fill behind texture
     * @param {number} [alpha=1] - Alpha of fill
     * @param {PIXI.Matrix} [matrix=null] - Transform matrix
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */
    beginTextureFill(texture, color, alpha, matrix = null) {
        if (texture === void 0) {
            texture = Texture_1.Texture.WHITE;
        }
        if (color === void 0) {
            color = 0xFFFFFF;
        }
        if (alpha === void 0) {
            alpha = 1;
        }
        if (matrix === void 0) {
            matrix = null;
        }
        if (this.currentPath) {
            this.startPoly();
        }
        var visible = alpha > 0;
        if (!visible) {
            this._fillStyle.reset();
        }
        else {
            if (matrix) {
                matrix = matrix.clone();
                matrix.invert();
            }
            Object.assign(this._fillStyle, {
                color: color,
                alpha: alpha,
                texture: texture,
                matrix: matrix,
                visible: visible,
            });
        }
        return this;
    }
    ;
    /**
     * Applies a fill to the lines and shapes that were added since the last call to the beginFill() method.
     *
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */
    endFill() {
        this.finishPoly();
        this._fillStyle.reset();
        return this;
    }
    ;
    /**
     * Draws a rectangle shape.
     *
     * @param {number} x - The X coord of the top-left of the rectangle
     * @param {number} y - The Y coord of the top-left of the rectangle
     * @param {number} width - The width of the rectangle
     * @param {number} height - The height of the rectangle
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */
    drawRect(x, y, width, height) {
        InstanceCounter_1.InstanceCounter.addCall("Rectangle.getRectangle", "Graphics drawRect");
        return this.drawShape(Rectangle_1.Rectangle.getRectangle(x, y, width, height));
    }
    ;
    /**
     * Draw a rectangle shape with rounded/beveled corners.
     *
     * @param {number} x - The X coord of the top-left of the rectangle
     * @param {number} y - The Y coord of the top-left of the rectangle
     * @param {number} width - The width of the rectangle
     * @param {number} height - The height of the rectangle
     * @param {number} radius - Radius of the rectangle corners
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */
    drawRoundedRect(x, y, width, height, radius) {
        return this.drawShape(new RoundedRectangle_1.RoundedRectangle(x, y, width, height, radius));
    }
    ;
    /**
     * Draws a circle.
     *
     * @param {number} x - The X coordinate of the center of the circle
     * @param {number} y - The Y coordinate of the center of the circle
     * @param {number} radius - The radius of the circle
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */
    drawCircle(x, y, radius) {
        return this.drawShape(new Circle_1.Circle(x, y, radius));
    }
    ;
    /**
     * Draws an ellipse.
     *
     * @param {number} x - The X coordinate of the center of the ellipse
     * @param {number} y - The Y coordinate of the center of the ellipse
     * @param {number} width - The half width of the ellipse
     * @param {number} height - The half height of the ellipse
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */
    drawEllipse(x, y, width, height) {
        return this.drawShape(new Ellipse_1.Ellipse(x, y, width, height));
    }
    ;
    /**
     * Draws a polygon using the given path.
     *
     * @param {number[]|PIXI.Point[]|PIXI.Polygon} path - The path data used to construct the polygon.
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */
    drawPolygon(path) {
        var arguments$1 = arguments;
        // prevents an argument assignment deopt
        // see section 3.1: https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#3-managing-arguments
        var points = path;
        var closeStroke = true; // !!this._fillStyle;
        // check if data has points..
        if (points.points) {
            closeStroke = points.closeStroke;
            points = points.points;
        }
        if (!Array.isArray(points)) {
            // prevents an argument leak deopt
            // see section 3.2: https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#3-managing-arguments
            points = new Array(arguments.length);
            for (var i = 0; i < points.length; ++i) {
                points[i] = arguments$1[i]; // eslint-disable-line prefer-rest-params
            }
        }
        var shape = new Polygon_1.Polygon(points);
        shape.closeStroke = closeStroke;
        this.drawShape(shape);
        return this;
    }
    ;
    /**
     * Draw any shape.
     *
     * @param {PIXI.Circle|PIXI.Ellipse|PIXI.Polygon|PIXI.Rectangle|PIXI.RoundedRectangle} shape - Shape to draw
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */
    drawShape(shape) {
        if (!this._holeMode) {
            this.geometry.drawShape(shape, this._fillStyle.clone(), this._lineStyle.clone(), this._matrix);
        }
        else {
            this.geometry.drawHole(shape, this._matrix);
        }
        return this;
    }
    ;
    /**
     * Draw a star shape with an arbitrary number of points.
     *
     * @param {number} x - Center X position of the star
     * @param {number} y - Center Y position of the star
     * @param {number} points - The number of points of the star, must be > 1
     * @param {number} radius - The outer radius of the star
     * @param {number} [innerRadius] - The inner radius between points, default half `radius`
     * @param {number} [rotation=0] - The rotation of the star in radians, where 0 is vertical
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */
    drawStar(x, y, points, radius, innerRadius = 0, rotation = 0) {
        if (rotation === void 0) {
            rotation = 0;
        }
        return this.drawPolygon(new Star_1.Star(x, y, points, radius, innerRadius, rotation));
    }
    ;
    /**
     * Clears the graphics that were drawn to this Graphics object, and resets fill and line style settings.
     *
     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls
     */
    clear() {
        this.geometry.clear();
        this._matrix = null;
        this._holeMode = false;
        this.currentPath = null;
        this._spriteRect = null;
        return this;
    }
    ;
    /**
     * True if graphics consists of one rectangle, and thus, can be drawn like a Sprite and
     * masked with gl.scissor.
     *
     * @returns {boolean} True if only 1 rect.
     */
    isFastRect() {
        // will fix this!
        return false;
        // this.graphicsData.length === 1
        //  && this.graphicsData[0].shape.type === SHAPES.RECT
        // && !this.graphicsData[0].lineWidth;
    }
    ;
    /**
     * Renders the object using the WebGL renderer
     *
     * @protected
     * @param {PIXI.Renderer} renderer - The renderer
     */
    _render(renderer) {
        this.finishPoly();
        var geometry = this.geometry;
        // batch part..
        // batch it!
        geometry.updateBatches();
        if (geometry.batchable) {
            if (this.batchDirty !== geometry.batchDirty) {
                this.batches = [];
                this.batchTint = -1;
                this._transformID = -1;
                this.batchDirty = geometry.batchDirty;
                this.vertexData = new Float32Array(geometry.points);
                var blendMode = this.blendMode;
                for (var i = 0; i < geometry.batches.length; i++) {
                    var gI = geometry.batches[i];
                    var color = gI.style.color;
                    //        + (alpha * 255 << 24);
                    var vertexData = new Float32Array(this.vertexData.buffer, gI.attribStart * 4 * 2, gI.attribSize * 2);
                    var uvs = new Float32Array(geometry.uvsFloat32.buffer, gI.attribStart * 4 * 2, gI.attribSize * 2);
                    var indices = new Uint16Array(geometry.indicesUint16.buffer, gI.start * 2, gI.size);
                    var batch = {
                        vertexData: vertexData,
                        blendMode: blendMode,
                        indices: indices,
                        uvs: uvs,
                        _batchRGB: ColorSettings_1.ColorSettings.hex2rgb(color),
                        _tintRGB: color,
                        _texture: gI.style.texture,
                        alpha: gI.style.alpha,
                        worldAlpha: 1
                    };
                    this.batches[i] = batch;
                }
            }
            renderer.batch.setObjectRenderer(renderer.plugins.batch);
            if (this.batches.length) {
                this.calculateVertices();
                this.calculateTints();
                for (var i$1 = 0; i$1 < this.batches.length; i$1++) {
                    var batch$1 = this.batches[i$1];
                    batch$1.worldAlpha = this.worldAlpha * batch$1.alpha;
                    renderer.plugins.batch.render(batch$1);
                }
            }
        }
        else {
            // no batching...
            renderer.batch.flush();
            if (!this.shader) {
                // if there is no shader here, we can use the default shader.
                // and that only gets created if we actually need it..
                if (!Graphics.defaultShader) {
                    var sampleValues = new Int32Array(16);
                    for (var i$2 = 0; i$2 < 16; i$2++) {
                        sampleValues[i$2] = i$2;
                    }
                    var uniforms = {
                        tint: new Float32Array([1, 1, 1, 1]),
                        translationMatrix: new Matrix_1.Matrix(),
                        default: UniformGroup_1.UniformGroup.from({ uSamplers: sampleValues }, true),
                    };
                    // we can bbase default shader of the batch renderers program
                    var program = renderer.plugins.batch.shader.program;
                    Graphics.defaultShader = new Shader_1.Shader(program, uniforms);
                }
                this.shader = Graphics.defaultShader;
            }
            var uniforms$1 = this.shader.uniforms;
            // lets set the transfomr
            uniforms$1.translationMatrix = this.transform.worldTransform;
            var tint = this.tint;
            var wa = this.worldAlpha;
            // and then lets set the tint..
            uniforms$1.tint[0] = (((tint >> 16) & 0xFF) / 255) * wa;
            uniforms$1.tint[1] = (((tint >> 8) & 0xFF) / 255) * wa;
            uniforms$1.tint[2] = ((tint & 0xFF) / 255) * wa;
            uniforms$1.tint[3] = wa;
            // the first draw call, we can set the uniforms of the shader directly here.
            // this means that we can tack advantage of the sync function of pixi!
            // bind and sync uniforms..
            // there is a way to optimise this..
            renderer.shader.bind(this.shader);
            // then render it
            renderer.geometry.bind(geometry, this.shader);
            // set state..
            renderer.state.setState(this.state);
            // then render the rest of them...
            for (var i$3 = 0; i$3 < geometry.drawCalls.length; i$3++) {
                var drawCall = geometry.drawCalls[i$3];
                var groupTextureCount = drawCall.textureCount;
                for (var j = 0; j < groupTextureCount; j++) {
                    renderer.texture.bind(drawCall.textures[j], j);
                }
                // bind the geometry...
                renderer.geometry.draw(drawCall.type, drawCall.size, drawCall.start);
            }
        }
    }
    ;
    /**
     * Retrieves the bounds of the graphic shape as a rectangle object
     *
     * @protected
     */
    _calculateBounds() {
        this.finishPoly();
        var lb = this.geometry.bounds;
        this._bounds.addFrame(this.transform, lb.minX, lb.minY, lb.maxX, lb.maxY);
    }
    ;
    /**
     * Tests if a point is inside this graphics object
     *
     * @param {PIXI.Point} point - the point to test
     * @return {boolean} the result of the test
     */
    containsPoint(point) {
        let defaultpoint = Point_1.Point.DEFAULT;
        this.worldTransform.applyInverse(point, defaultpoint);
        return this.geometry.containsPoint(defaultpoint);
    }
    ;
    /**
     * Recalcuate the tint by applying tin to batches using Graphics tint.
     * @protected
     */
    calculateTints() {
        if (this.batchTint !== this.tint) {
            this.batchTint = this.tint;
            var tintRGB = ColorSettings_1.ColorSettings.hex2rgb(this.tint, Graphics.temp);
            for (var i = 0; i < this.batches.length; i++) {
                var batch = this.batches[i];
                var batchTint = batch._batchRGB;
                var r = (tintRGB[0] * batchTint[0]) * 255;
                var g = (tintRGB[1] * batchTint[1]) * 255;
                var b = (tintRGB[2] * batchTint[2]) * 255;
                // TODO Ivan, can this be done in one go?
                var color = (r << 16) + (g << 8) + (b | 0);
                batch._tintRGB = (color >> 16)
                    + (color & 0xff00)
                    + ((color & 0xff) << 16);
            }
        }
    }
    ;
    /**
     * If there's a transform update or a change to the shape of the
     * geometry, recaculate the vertices.
     * @protected
     */
    calculateVertices() {
        if (this._transformID === this.transform.worldID) {
            return;
        }
        this._transformID = this.transform.worldID;
        var wt = this.transform.worldTransform;
        var a = wt.a;
        var b = wt.b;
        var c = wt.c;
        var d = wt.d;
        var tx = wt.tx;
        var ty = wt.ty;
        var data = this.geometry.points; // batch.vertexDataOriginal;
        var vertexData = this.vertexData;
        var count = 0;
        for (var i = 0; i < data.length; i += 2) {
            var x = data[i];
            var y = data[i + 1];
            vertexData[count++] = (a * x) + (c * y) + tx;
            vertexData[count++] = (d * y) + (b * x) + ty;
        }
    }
    ;
    /**
     * Closes the current path.
     *
     * @return {PIXI.Graphics} Returns itself.
     */
    closePath() {
        var currentPath = this.currentPath;
        if (currentPath) {
            // we don't need to add extra point in the end because buildLine will take care of that
            currentPath.closeStroke = true;
        }
        return this;
    }
    ;
    /**
     * Apply a matrix to the positional data.
     *
     * @param {PIXI.Matrix} matrix - Matrix to use for transform current shape.
     * @return {PIXI.Graphics} Returns itself.
     */
    setMatrix(matrix) {
        this._matrix = matrix;
        return this;
    }
    ;
    /**
     * Begin adding holes to the last draw shape
     * IMPORTANT: holes must be fully inside a shape to work
     * Also weirdness ensues if holes overlap!
     * Ellipses, Circles, Rectangles and Rounded Rectangles cannot be holes or host for holes in CanvasRenderer,
     * please use `moveTo` `lineTo`, `quadraticCurveTo` if you rely on pixi-legacy bundle.
     * @return {PIXI.Graphics} Returns itself.
     */
    beginHole() {
        this.finishPoly();
        this._holeMode = true;
        return this;
    }
    ;
    /**
     * End adding holes to the last draw shape
     * @return {PIXI.Graphics} Returns itself.
     */
    endHole() {
        this.finishPoly();
        this._holeMode = false;
        return this;
    }
    ;
    /**
     * Destroys the Graphics object.
     *
     * @param {object|boolean} [options] - Options parameter. A boolean will act as if all
     *  options have been set to that value
     * @param {boolean} [options.children=false] - if set to true, all the children will have
     *  their destroy method called as well. 'options' will be passed on to those calls.
     * @param {boolean} [options.texture=false] - Only used for child Sprites if options.children is set to true
     *  Should it destroy the texture of the child sprite
     * @param {boolean} [options.baseTexture=false] - Only used for child Sprites if options.children is set to true
     *  Should it destroy the base texture of the child sprite
     */
    destroy(options) {
        super.destroy(options);
        this.geometry.refCount--;
        if (this.geometry.refCount === 0) {
            this.geometry.dispose();
        }
        this._matrix = null;
        this.currentPath = null;
        this._lineStyle.destroy();
        this._lineStyle = null;
        this._fillStyle.destroy();
        this._fillStyle = null;
        this.geometry = null;
        this.shader = null;
        this.vertexData = null;
        this.batches.length = 0;
        this.batches = null;
        super.destroy(options);
    }
    ;
}
Graphics.temp = new Float32Array([1, 1, 1]);
Graphics.defaultShader = null;
exports.Graphics = Graphics;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/GraphicsData.js":
/*!************************************************!*\
  !*** ./js-compile/raw-pixi-ts/GraphicsData.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class GraphicsData {
    constructor(shape, fillStyle = null, lineStyle = null, matrix = null) {
        /**
         * The shape object to draw.
         * @member {PIXI.Circle|PIXI.Ellipse|PIXI.Polygon|PIXI.Rectangle|PIXI.RoundedRectangle}
         */
        this.shape = shape;
        /**
         * The style of the line.
         * @member {PIXI.LineStyle}
         */
        this.lineStyle = lineStyle;
        /**
         * The style of the fill.
         * @member {PIXI.FillStyle}
         */
        this.fillStyle = fillStyle;
        /**
         * The transform matrix.
         * @member {PIXI.Matrix}
         */
        this.matrix = matrix;
        /**
         * The type of the shape, see the Const.Shapes file for all the existing types,
         * @member {number}
         */
        this.type = shape.type;
        /**
         * The collection of points.
         * @member {number[]}
         */
        this.points = [];
        /**
         * The collection of holes.
         * @member {PIXI.GraphicsData[]}
         */
        this.holes = [];
    }
    /**
     * Creates a new GraphicsData object with the same values as this one.
     *
     * @return {PIXI.GraphicsData} Cloned GraphicsData object
     */
    clone() {
        return new GraphicsData(this.shape, this.fillStyle, this.lineStyle, this.matrix);
    }
    ;
    /**
     * Destroys the Graphics data.
     */
    destroy() {
        this.shape = null;
        this.holes.length = 0;
        this.holes = null;
        this.points.length = 0;
        this.points = null;
        this.lineStyle = null;
        this.fillStyle = null;
    }
    ;
}
exports.GraphicsData = GraphicsData;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/GraphicsGeometry.js":
/*!****************************************************!*\
  !*** ./js-compile/raw-pixi-ts/GraphicsGeometry.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BatchGeometry_1 = __webpack_require__(/*! ./BatchGeometry */ "./js-compile/raw-pixi-ts/BatchGeometry.js");
const Bounds_1 = __webpack_require__(/*! ./Bounds */ "./js-compile/raw-pixi-ts/Bounds.js");
const GraphicsData_1 = __webpack_require__(/*! ./GraphicsData */ "./js-compile/raw-pixi-ts/GraphicsData.js");
const BaseTexture_1 = __webpack_require__(/*! ./BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const BatchDrawCall_1 = __webpack_require__(/*! ./BatchDrawCall */ "./js-compile/raw-pixi-ts/BatchDrawCall.js");
const Point_1 = __webpack_require__(/*! ../flash/geom/Point */ "./js-compile/flash/geom/Point.js");
const ShapeSettings_1 = __webpack_require__(/*! ./ShapeSettings */ "./js-compile/raw-pixi-ts/ShapeSettings.js");
const DrawModeSettings_1 = __webpack_require__(/*! ./DrawModeSettings */ "./js-compile/raw-pixi-ts/DrawModeSettings.js");
const ColorSettings_1 = __webpack_require__(/*! ./ColorSettings */ "./js-compile/raw-pixi-ts/ColorSettings.js");
class BatchPart {
    constructor() {
        this.style = null;
        this.size = 0;
        this.start = 0;
        this.attribStart = 0;
        this.attribSize = 0;
    }
}
class GraphicsGeometry extends BatchGeometry_1.BatchGeometry {
    constructor() {
        super();
        /**
         * An array of points to draw
         *
         * @member {PIXI.Point[]}
         * @protected
         */
        this.points = [];
        /**
         * The collection of colors
         *
         * @member {number[]}
         * @protected
         */
        this.colors = [];
        /**
         * The UVs collection
         *
         * @member {number[]}
         * @protected
         */
        this.uvs = [];
        /**
         * The indices of the vertices
         *
         * @member {number[]}
         * @protected
         */
        this.indices = [];
        /**
         * Reference to the texture IDs.
         *
         * @member {number[]}
         * @protected
         */
        this.textureIds = [];
        /**
         * The collection of drawn shapes.
         *
         * @member {PIXI.GraphicsData[]}
         * @protected
         */
        this.graphicsData = [];
        /**
         * Used to detect if the graphics object has changed. If this is set to true then the graphics
         * object will be recalculated.
         *
         * @member {number}
         * @protected
         */
        this.dirty = 0;
        /**
         * Batches need to regenerated if the geometry is updated.
         *
         * @member {number}
         * @protected
         */
        this.batchDirty = -1;
        /**
         * Used to check if the cache is dirty.
         *
         * @member {number}
         * @protected
         */
        this.cacheDirty = -1;
        /**
         * Used to detect if we clear the graphics WebGL data.
         *
         * @member {number}
         * @default 0
         * @protected
         */
        this.clearDirty = 0;
        /**
         * List of current draw calls drived from the batches.
         *
         * @member {object[]}
         * @protected
         */
        this.drawCalls = [];
        /**
         * Intermediate abstract format sent to batch system.
         * Can be converted to drawCalls or to batchable objects.
         *
         * @member {object[]}
         * @protected
         */
        this.batches = [];
        /**
         * Index of the current last shape in the stack of calls.
         *
         * @member {number}
         * @protected
         */
        this.shapeIndex = 0;
        /**
         * Cached bounds.
         *
         * @member {PIXI.Bounds}
         * @protected
         */
        this._bounds = new Bounds_1.Bounds();
        /**
         * The bounds dirty flag.
         *
         * @member {number}
         * @protected
         */
        this.boundsDirty = -1;
        /**
         * Padding to add to the bounds.
         *
         * @member {number}
         * @default 0
         */
        this.boundsPadding = 0;
        this.batchable = false;
        this.indicesUint16 = null;
        this.uvsFloat32 = null;
    }
    static getFillCommand(type) {
        if (!GraphicsGeometry.fillCommands) {
            GraphicsGeometry.fillCommands = {};
            GraphicsGeometry.fillCommands[ShapeSettings_1.ShapeSettings.SHAPES.POLY] = GraphicsGeometry.buildPoly;
            GraphicsGeometry.fillCommands[ShapeSettings_1.ShapeSettings.SHAPES.CIRC] = GraphicsGeometry.buildCircle;
            GraphicsGeometry.fillCommands[ShapeSettings_1.ShapeSettings.SHAPES.ELIP] = GraphicsGeometry.buildCircle;
            GraphicsGeometry.fillCommands[ShapeSettings_1.ShapeSettings.SHAPES.RECT] = GraphicsGeometry.buildRectangle;
            GraphicsGeometry.fillCommands[ShapeSettings_1.ShapeSettings.SHAPES.RREC] = GraphicsGeometry.buildRoundedRectangle;
        }
        return GraphicsGeometry.fillCommands[type];
    }
    /**
     * Get the current bounds of the graphic geometry.
     *
     * @member {PIXI.Bounds}
     * @readonly
     */
    get bounds() {
        if (this.boundsDirty !== this.dirty) {
            this.boundsDirty = this.dirty;
            this.calculateBounds();
        }
        return this._bounds;
    }
    ;
    /**
     * Clears the graphics that were drawn to this Graphics object, and resets fill and line style settings.
     *
     * @return {PIXI.GraphicsGeometry} This GraphicsGeometry object. Good for chaining method calls
     */
    clear() {
        if (this.graphicsData.length > 0) {
            this.boundsDirty = -1;
            this.dirty++;
            this.clearDirty++;
            this.batchDirty++;
            this.graphicsData.length = 0;
            this.shapeIndex = 0;
            this.points.length = 0;
            this.colors.length = 0;
            this.uvs.length = 0;
            this.indices.length = 0;
            this.textureIds.length = 0;
            for (var i = 0; i < this.drawCalls.length; i++) {
                this.drawCalls[i].textures.length = 0;
                GraphicsGeometry.DRAW_CALL_POOL.push(this.drawCalls[i]);
            }
            this.drawCalls.length = 0;
            for (var i$1 = 0; i$1 < this.batches.length; i$1++) {
                var batch = this.batches[i$1];
                batch.start = 0;
                batch.attribStart = 0;
                batch.style = null;
                GraphicsGeometry.BATCH_POOL.push(batch);
            }
            this.batches.length = 0;
        }
        return this;
    }
    ;
    /**
     * Draws the given shape to this Graphics object. Can be any of Circle, Rectangle, Ellipse, Line or Polygon.
     *
     * @param {PIXI.Circle|PIXI.Ellipse|PIXI.Polygon|PIXI.Rectangle|PIXI.RoundedRectangle} shape - The shape object to draw.
     * @param {PIXI.FillStyle} fillStyle - Defines style of the fill.
     * @param {PIXI.LineStyle} lineStyle - Defines style of the lines.
     * @param {PIXI.Matrix} matrix - Transform applied to the points of the shape.
     * @return {PIXI.GraphicsGeometry} Returns geometry for chaining.
     */
    drawShape(shape, fillStyle, lineStyle, matrix) {
        var data = new GraphicsData_1.GraphicsData(shape, fillStyle, lineStyle, matrix);
        this.graphicsData.push(data);
        this.dirty++;
        return this;
    }
    ;
    /**
     * Draws the given shape to this Graphics object. Can be any of Circle, Rectangle, Ellipse, Line or Polygon.
     *
     * @param {PIXI.Circle|PIXI.Ellipse|PIXI.Polygon|PIXI.Rectangle|PIXI.RoundedRectangle} shape - The shape object to draw.
     * @param {PIXI.Matrix} matrix - Transform applied to the points of the shape.
     * @return {PIXI.GraphicsGeometry} Returns geometry for chaining.
     */
    drawHole(shape, matrix) {
        if (!this.graphicsData.length) {
            return null;
        }
        var data = new GraphicsData_1.GraphicsData(shape, null, null, matrix);
        var lastShape = this.graphicsData[this.graphicsData.length - 1];
        data.lineStyle = lastShape.lineStyle;
        lastShape.holes.push(data);
        this.dirty++;
        return data;
    }
    ;
    /**
     * Destroys the Graphics object.
     *
     * @param {object|boolean} [options] - Options parameter. A boolean will act as if all
     *  options have been set to that value
     * @param {boolean} [options.children=false] - if set to true, all the children will have
     *  their destroy method called as well. 'options' will be passed on to those calls.
     * @param {boolean} [options.texture=false] - Only used for child Sprites if options.children is set to true
     *  Should it destroy the texture of the child sprite
     * @param {boolean} [options.baseTexture=false] - Only used for child Sprites if options.children is set to true
     *  Should it destroy the base texture of the child sprite
     */
    destroy(options) {
        super.destroy(options);
        // destroy each of the GraphicsData objects
        for (var i = 0; i < this.graphicsData.length; ++i) {
            this.graphicsData[i].destroy();
        }
        this.points.length = 0;
        this.points = null;
        this.colors.length = 0;
        this.colors = null;
        this.uvs.length = 0;
        this.uvs = null;
        this.indices.length = 0;
        this.indices = null;
        this.indexBuffer.destroy();
        this.indexBuffer = null;
        this.graphicsData.length = 0;
        this.graphicsData = null;
        this.drawCalls.length = 0;
        this.drawCalls = null;
        this.batches.length = 0;
        this.batches = null;
        this._bounds = null;
    }
    ;
    /**
     * Check to see if a point is contained within this geometry.
     *
     * @param {PIXI.Point} point - Point to check if it's contained.
     * @return {Boolean} `true` if the point is contained within geometry.
     */
    containsPoint(point) {
        var graphicsData = this.graphicsData;
        for (var i = 0; i < graphicsData.length; ++i) {
            var data = graphicsData[i];
            if (!data.fillStyle.visible) {
                continue;
            }
            // only deal with fills..
            if (data.shape) {
                if (data.shape.contains(point.x, point.y)) {
                    if (data.holes) {
                        for (var i$1 = 0; i$1 < data.holes.length; i$1++) {
                            var hole = data.holes[i$1];
                            if (hole.shape.contains(point.x, point.y)) {
                                return false;
                            }
                        }
                    }
                    return true;
                }
            }
        }
        return false;
    }
    ;
    /**
     * Generates intermediate batch data. Either gets converted to drawCalls
     * or used to convert to batch objects directly by the Graphics object.
     * @protected
     */
    updateBatches() {
        if (this.dirty === this.cacheDirty) {
            return;
        }
        if (this.graphicsData.length === 0) {
            return;
        }
        if (this.dirty !== this.cacheDirty) {
            for (var i = 0; i < this.graphicsData.length; i++) {
                var data = this.graphicsData[i];
                if (data.fillStyle && !data.fillStyle.texture.baseTexture.valid) {
                    return;
                }
                if (data.lineStyle && !data.lineStyle.texture.baseTexture.valid) {
                    return;
                }
            }
        }
        this.cacheDirty = this.dirty;
        var uvs = this.uvs;
        var batchPart = this.batches.pop()
            || GraphicsGeometry.BATCH_POOL.pop()
            || new BatchPart();
        batchPart.style = batchPart.style
            || this.graphicsData[0].fillStyle
            || this.graphicsData[0].lineStyle;
        var currentTexture = batchPart.style.texture.baseTexture;
        var currentColor = batchPart.style.color + batchPart.style.alpha;
        this.batches.push(batchPart);
        // TODO - this can be simplified
        for (var i$1 = this.shapeIndex; i$1 < this.graphicsData.length; i$1++) {
            this.shapeIndex++;
            var data$1 = this.graphicsData[i$1];
            var command = GraphicsGeometry.getFillCommand(data$1.type);
            var fillStyle = data$1.fillStyle;
            var lineStyle = data$1.lineStyle;
            // build out the shapes points..
            command.build(data$1);
            if (data$1.matrix) {
                this.transformPoints(data$1.points, data$1.matrix);
            }
            for (var j = 0; j < 2; j++) {
                var style = (j === 0) ? fillStyle : lineStyle;
                if (!style.visible) {
                    continue;
                }
                var nextTexture = style.texture.baseTexture;
                if (currentTexture !== nextTexture || (style.color + style.alpha) !== currentColor) {
                    // TODO use a const
                    nextTexture.wrapMode = 10497;
                    currentTexture = nextTexture;
                    currentColor = style.color + style.alpha;
                    var index$1 = this.indices.length;
                    var attribIndex = this.points.length / 2;
                    batchPart.size = index$1 - batchPart.start;
                    batchPart.attribSize = attribIndex - batchPart.attribStart;
                    if (batchPart.size > 0) {
                        batchPart = GraphicsGeometry.BATCH_POOL.pop() || new BatchPart();
                        this.batches.push(batchPart);
                    }
                    batchPart.style = style;
                    batchPart.start = index$1;
                    batchPart.attribStart = attribIndex;
                    // TODO add this to the render part..
                }
                var start = this.points.length / 2;
                if (j === 0) {
                    if (data$1.holes.length) {
                        this.processHoles(data$1.holes);
                        GraphicsGeometry.buildPoly.triangulate(data$1, this);
                    }
                    else {
                        command.triangulate(data$1, this);
                    }
                }
                else {
                    GraphicsGeometry.buildLine(data$1, this);
                    for (var i$2 = 0; i$2 < data$1.holes.length; i$2++) {
                        GraphicsGeometry.buildLine(data$1.holes[i$2], this);
                    }
                }
                var size = (this.points.length / 2) - start;
                this.addUvs(this.points, uvs, style.texture, start, size, style.matrix);
            }
        }
        var index = this.indices.length;
        var attrib = this.points.length / 2;
        batchPart.size = index - batchPart.start;
        batchPart.attribSize = attrib - batchPart.attribStart;
        this.indicesUint16 = new Uint16Array(this.indices);
        // TODO make this a const..
        this.batchable = this.isBatchable();
        if (this.batchable) {
            this.batchDirty++;
            this.uvsFloat32 = new Float32Array(this.uvs);
            // offset the indices so that it works with the batcher...
            for (var i$3 = 0; i$3 < this.batches.length; i$3++) {
                var batch = this.batches[i$3];
                for (var j$1 = 0; j$1 < batch.size; j$1++) {
                    var index$2 = batch.start + j$1;
                    this.indicesUint16[index$2] = this.indicesUint16[index$2] - batch.attribStart;
                }
            }
        }
        else {
            this.buildDrawCalls();
        }
    }
    ;
    /**
     * Checks to see if this graphics geometry can be batched.
     * Currently it needs to be small enough and not contain any native lines.
     * @protected
     */
    isBatchable() {
        var batches = this.batches;
        for (var i = 0; i < batches.length; i++) {
            if (batches[i].style.native) {
                return false;
            }
        }
        return (this.points.length < GraphicsGeometry.BATCHABLE_SIZE * 2);
    }
    ;
    /**
     * Converts intermediate batches data to drawCalls.
     * @protected
     */
    buildDrawCalls() {
        var TICK = ++BaseTexture_1.BaseTexture._globalBatch;
        for (var i = 0; i < this.drawCalls.length; i++) {
            this.drawCalls[i].textures.length = 0;
            GraphicsGeometry.DRAW_CALL_POOL.push(this.drawCalls[i]);
        }
        this.drawCalls.length = 0;
        var uvs = this.uvs;
        var colors = this.colors;
        var textureIds = this.textureIds;
        var currentGroup = GraphicsGeometry.DRAW_CALL_POOL.pop() || new BatchDrawCall_1.BatchDrawCall();
        currentGroup.textureCount = 0;
        currentGroup.start = 0;
        currentGroup.size = 0;
        currentGroup.type = DrawModeSettings_1.DrawModeSettings.DRAW_MODES.TRIANGLES;
        var textureCount = 0;
        var currentTexture = null;
        var textureId = 0;
        var native = false;
        var drawMode = DrawModeSettings_1.DrawModeSettings.DRAW_MODES.TRIANGLES;
        var index = 0;
        this.drawCalls.push(currentGroup);
        // TODO - this can be simplified
        for (var i$1 = 0; i$1 < this.batches.length; i$1++) {
            var data = this.batches[i$1];
            // TODO add some full on MAX_TEXTURE CODE..
            var MAX_TEXTURES = 8;
            var style = data.style;
            var nextTexture = style.texture.baseTexture;
            if (native !== style.native) {
                native = style.native;
                drawMode = native ? DrawModeSettings_1.DrawModeSettings.DRAW_MODES.LINES : DrawModeSettings_1.DrawModeSettings.DRAW_MODES.TRIANGLES;
                // force the batch to break!
                currentTexture = null;
                textureCount = MAX_TEXTURES;
                TICK++;
            }
            if (currentTexture !== nextTexture) {
                currentTexture = nextTexture;
                if (nextTexture._batchEnabled !== TICK) {
                    if (textureCount === MAX_TEXTURES) {
                        TICK++;
                        textureCount = 0;
                        if (currentGroup.size > 0) {
                            currentGroup = GraphicsGeometry.DRAW_CALL_POOL.pop() || new BatchDrawCall_1.BatchDrawCall();
                            this.drawCalls.push(currentGroup);
                        }
                        currentGroup.start = index;
                        currentGroup.size = 0;
                        currentGroup.textureCount = 0;
                        currentGroup.type = drawMode;
                    }
                    // TODO add this to the render part..
                    nextTexture.touched = 1; // touch;
                    nextTexture._batchEnabled = TICK;
                    nextTexture._id = textureCount;
                    nextTexture.wrapMode = 10497;
                    currentGroup.textures[currentGroup.textureCount++] = nextTexture;
                    textureCount++;
                }
            }
            currentGroup.size += data.size;
            index += data.size;
            textureId = nextTexture._id;
            this.addColors(colors, style.color, style.alpha, data.attribSize);
            this.addTextureIds(textureIds, textureId, data.attribSize);
        }
        BaseTexture_1.BaseTexture._globalBatch = TICK;
        // upload..
        // merge for now!
        var verts = this.points;
        // verts are 2 positions.. so we * by 3 as there are 6 properties.. then 4 cos its bytes
        var glPoints = new ArrayBuffer(verts.length * 3 * 4);
        var f32 = new Float32Array(glPoints);
        var u32 = new Uint32Array(glPoints);
        var p = 0;
        for (var i$2 = 0; i$2 < verts.length / 2; i$2++) {
            f32[p++] = verts[i$2 * 2];
            f32[p++] = verts[(i$2 * 2) + 1];
            f32[p++] = uvs[i$2 * 2];
            f32[p++] = uvs[(i$2 * 2) + 1];
            u32[p++] = colors[i$2];
            f32[p++] = textureIds[i$2];
        }
        this._buffer.update(glPoints);
        this._indexBuffer.update(this.indicesUint16);
    }
    ;
    /**
     * Process the holes data.
     *
     * @param {PIXI.GraphicsData[]} holes - Holes to render
     * @protected
     */
    processHoles(holes) {
        for (var i = 0; i < holes.length; i++) {
            var hole = holes[i];
            var command = GraphicsGeometry.fillCommands[hole.type];
            command.build(hole);
            if (hole.matrix) {
                this.transformPoints(hole.points, hole.matrix);
            }
        }
    }
    ;
    /**
     * Update the local bounds of the object. Expensive to use performance-wise.
     * @protected
     */
    calculateBounds() {
        var minX = Infinity;
        var maxX = -Infinity;
        var minY = Infinity;
        var maxY = -Infinity;
        if (this.graphicsData.length) {
            var shape = null;
            var x = 0;
            var y = 0;
            var w = 0;
            var h = 0;
            for (var i = 0; i < this.graphicsData.length; i++) {
                var data = this.graphicsData[i];
                var type = data.type;
                var lineWidth = data.lineStyle ? data.lineStyle.width : 0;
                shape = data.shape;
                if (type === ShapeSettings_1.ShapeSettings.SHAPES.RECT || type === ShapeSettings_1.ShapeSettings.SHAPES.RREC) {
                    x = shape.x - (lineWidth / 2);
                    y = shape.y - (lineWidth / 2);
                    w = shape.width + lineWidth;
                    h = shape.height + lineWidth;
                    minX = x < minX ? x : minX;
                    maxX = x + w > maxX ? x + w : maxX;
                    minY = y < minY ? y : minY;
                    maxY = y + h > maxY ? y + h : maxY;
                }
                else if (type === ShapeSettings_1.ShapeSettings.SHAPES.CIRC) {
                    x = shape.x;
                    y = shape.y;
                    w = shape.radius + (lineWidth / 2);
                    h = shape.radius + (lineWidth / 2);
                    minX = x - w < minX ? x - w : minX;
                    maxX = x + w > maxX ? x + w : maxX;
                    minY = y - h < minY ? y - h : minY;
                    maxY = y + h > maxY ? y + h : maxY;
                }
                else if (type === ShapeSettings_1.ShapeSettings.SHAPES.ELIP) {
                    x = shape.x;
                    y = shape.y;
                    w = shape.width + (lineWidth / 2);
                    h = shape.height + (lineWidth / 2);
                    minX = x - w < minX ? x - w : minX;
                    maxX = x + w > maxX ? x + w : maxX;
                    minY = y - h < minY ? y - h : minY;
                    maxY = y + h > maxY ? y + h : maxY;
                }
                else {
                    // POLY
                    var points = shape.points;
                    var x2 = 0;
                    var y2 = 0;
                    var dx = 0;
                    var dy = 0;
                    var rw = 0;
                    var rh = 0;
                    var cx = 0;
                    var cy = 0;
                    for (var j = 0; j + 2 < points.length; j += 2) {
                        x = points[j];
                        y = points[j + 1];
                        x2 = points[j + 2];
                        y2 = points[j + 3];
                        dx = Math.abs(x2 - x);
                        dy = Math.abs(y2 - y);
                        h = lineWidth;
                        w = Math.sqrt((dx * dx) + (dy * dy));
                        if (w < 1e-9) {
                            continue;
                        }
                        rw = ((h / w * dy) + dx) / 2;
                        rh = ((h / w * dx) + dy) / 2;
                        cx = (x2 + x) / 2;
                        cy = (y2 + y) / 2;
                        minX = cx - rw < minX ? cx - rw : minX;
                        maxX = cx + rw > maxX ? cx + rw : maxX;
                        minY = cy - rh < minY ? cy - rh : minY;
                        maxY = cy + rh > maxY ? cy + rh : maxY;
                    }
                }
            }
        }
        else {
            minX = 0;
            maxX = 0;
            minY = 0;
            maxY = 0;
        }
        var padding = this.boundsPadding;
        this._bounds.minX = minX - padding;
        this._bounds.maxX = maxX + padding;
        this._bounds.minY = minY - padding;
        this._bounds.maxY = maxY + padding;
    }
    ;
    /**
     * Transform points using matrix.
     *
     * @protected
     * @param {number[]} points - Points to transform
     * @param {PIXI.Matrix} matrix - Transform matrix
     */
    transformPoints(points, matrix) {
        for (var i = 0; i < points.length / 2; i++) {
            var x = points[(i * 2)];
            var y = points[(i * 2) + 1];
            points[(i * 2)] = (matrix.a * x) + (matrix.c * y) + matrix.tx;
            points[(i * 2) + 1] = (matrix.b * x) + (matrix.d * y) + matrix.ty;
        }
    }
    ;
    /**
     * Add colors.
     *
     * @protected
     * @param {number[]} colors - List of colors to add to
     * @param {number} color - Color to add
     * @param {number} alpha - Alpha to use
     * @param {number} size - Number of colors to add
     */
    addColors(colors, color, alpha, size) {
        // TODO use the premultiply bits Ivan added
        var rgb = (color >> 16) + (color & 0xff00) + ((color & 0xff) << 16);
        var rgba = ColorSettings_1.ColorSettings.premultiplyTint(rgb, alpha);
        while (size-- > 0) {
            colors.push(rgba);
        }
    }
    ;
    /**
     * Add texture id that the shader/fragment wants to use.
     *
     * @protected
     * @param {number[]} textureIds
     * @param {number} id
     * @param {number} size
     */
    addTextureIds(textureIds, id, size) {
        while (size-- > 0) {
            textureIds.push(id);
        }
    }
    ;
    /**
     * Generates the UVs for a shape.
     *
     * @protected
     * @param {number[]} verts - Vertices
     * @param {number[]} uvs - UVs
     * @param {PIXI.Texture} texture - Reference to Texture
     * @param {number} start - Index buffer start index.
     * @param {number} size - The size/length for index buffer.
     * @param {PIXI.Matrix} [matrix] - Optional transform for all points.
     */
    addUvs(verts, uvs, texture, start, size, matrix) {
        var index = 0;
        var uvsStart = uvs.length;
        var frame = texture.frame;
        while (index < size) {
            var x = verts[(start + index) * 2];
            var y = verts[((start + index) * 2) + 1];
            if (matrix) {
                var nx = (matrix.a * x) + (matrix.c * y) + matrix.tx;
                y = (matrix.b * x) + (matrix.d * y) + matrix.ty;
                x = nx;
            }
            index++;
            uvs.push(x / frame.width, y / frame.height);
        }
        var baseTexture = texture.baseTexture;
        if (frame.width < baseTexture.width
            || frame.height < baseTexture.height) {
            this.adjustUvs(uvs, texture, uvsStart, size);
        }
    }
    ;
    /**
     * Modify uvs array according to position of texture region
     * Does not work with rotated or trimmed textures
     * @param {number} uvs array
     * @param {PIXI.Texture} texture region
     * @param {number} start starting index for uvs
     * @param {number} size how many points to adjust
     */
    adjustUvs(uvs, texture, start, size) {
        var baseTexture = texture.baseTexture;
        var eps = 1e-6;
        var finish = start + (size * 2);
        var frame = texture.frame;
        var scaleX = frame.width / baseTexture.width;
        var scaleY = frame.height / baseTexture.height;
        var offsetX = frame.x / frame.width;
        var offsetY = frame.y / frame.width;
        var minX = Math.floor(uvs[start] + eps);
        var minY = Math.floor(uvs[start + 1] + eps);
        for (var i = start + 2; i < finish; i += 2) {
            minX = Math.min(minX, Math.floor(uvs[i] + eps));
            minY = Math.min(minY, Math.floor(uvs[i + 1] + eps));
        }
        offsetX -= minX;
        offsetY -= minY;
        for (var i$1 = start; i$1 < finish; i$1 += 2) {
            uvs[i$1] = (uvs[i$1] + offsetX) * scaleX;
            uvs[i$1 + 1] = (uvs[i$1 + 1] + offsetY) * scaleY;
        }
    }
    ;
    /**
 * Builds a line to draw
 *
 * Ignored from docs since it is not directly exposed.
 *
 * @ignore
 * @private
 * @param {PIXI.GraphicsData} graphicsData - The graphics object containing all the necessary properties
 * @param {PIXI.GraphicsGeometry} graphicsGeometry - Geometry where to append output
 */
    static buildLine(graphicsData, graphicsGeometry) {
        if (graphicsData.lineStyle.native) {
            GraphicsGeometry.buildNativeLine(graphicsData, graphicsGeometry);
        }
        else {
            GraphicsGeometry.buildLine$1(graphicsData, graphicsGeometry);
        }
    }
    /**
 * Builds a line to draw using the gl.drawArrays(gl.LINES) method
 *
 * Ignored from docs since it is not directly exposed.
 *
 * @ignore
 * @private
 * @param {PIXI.GraphicsData} graphicsData - The graphics object containing all the necessary properties
 * @param {PIXI.GraphicsGeometry} graphicsGeometry - Geometry where to append output
 */
    static buildNativeLine(graphicsData, graphicsGeometry) {
        var i = 0;
        var points = graphicsData.points || graphicsData.shape.points;
        if (points.length === 0) {
            return;
        }
        var verts = graphicsGeometry.points;
        var indices = graphicsGeometry.indices;
        var length = points.length / 2;
        var indexStart = verts.length / 2;
        // sort color
        for (i = 1; i < length; i++) {
            var p1x = points[(i - 1) * 2];
            var p1y = points[((i - 1) * 2) + 1];
            var p2x = points[i * 2];
            var p2y = points[(i * 2) + 1];
            verts.push(p1x, p1y);
            verts.push(p2x, p2y);
            indices.push(indexStart++, indexStart++);
        }
    }
    /**
 * Builds a line to draw using the polygon method.
 *
 * Ignored from docs since it is not directly exposed.
 *
 * @ignore
 * @private
 * @param {PIXI.GraphicsData} graphicsData - The graphics object containing all the necessary properties
 * @param {PIXI.GraphicsGeometry} graphicsGeometry - Geometry where to append output
 */
    static buildLine$1(graphicsData, graphicsGeometry) {
        var shape = graphicsData.shape;
        var points = graphicsData.points || shape.points.slice();
        if (points.length === 0) {
            return;
        }
        // if the line width is an odd number add 0.5 to align to a whole pixel
        // commenting this out fixes #711 and #1620
        // if (graphicsData.lineWidth%2)
        // {
        //     for (i = 0; i < points.length; i++)
        //     {
        //         points[i] += 0.5;
        //     }
        // }
        var style = graphicsData.lineStyle;
        // get first and last point.. figure out the middle!
        var firstPoint = Point_1.Point.getPoint(points[0], points[1]);
        var lastPoint = Point_1.Point.getPoint(points[points.length - 2], points[points.length - 1]);
        var closedShape = shape.type !== ShapeSettings_1.ShapeSettings.SHAPES.POLY || shape.closeStroke;
        var closedPath = firstPoint.x === lastPoint.x && firstPoint.y === lastPoint.y;
        // if the first point is the last point - gonna have issues :)
        if (closedShape) {
            // need to clone as we are going to slightly modify the shape..
            points = points.slice();
            if (closedPath) {
                points.pop();
                points.pop();
                lastPoint.set(points[points.length - 2], points[points.length - 1]);
            }
            var midPointX = lastPoint.x + ((firstPoint.x - lastPoint.x) * 0.5);
            var midPointY = lastPoint.y + ((firstPoint.y - lastPoint.y) * 0.5);
            points.unshift(midPointX, midPointY);
            points.push(midPointX, midPointY);
        }
        var verts = graphicsGeometry.points;
        var length = points.length / 2;
        var indexCount = points.length;
        var indexStart = verts.length / 2;
        // DRAW the Line
        var width = style.width / 2;
        // sort color
        var p1x = points[0];
        var p1y = points[1];
        var p2x = points[2];
        var p2y = points[3];
        var p3x = 0;
        var p3y = 0;
        var perpx = -(p1y - p2y);
        var perpy = p1x - p2x;
        var perp2x = 0;
        var perp2y = 0;
        var perp3x = 0;
        var perp3y = 0;
        var dist = Math.sqrt((perpx * perpx) + (perpy * perpy));
        perpx /= dist;
        perpy /= dist;
        perpx *= width;
        perpy *= width;
        var ratio = style.alignment; // 0.5;
        var r1 = (1 - ratio) * 2;
        var r2 = ratio * 2;
        // start
        verts.push(p1x - (perpx * r1), p1y - (perpy * r1));
        verts.push(p1x + (perpx * r2), p1y + (perpy * r2));
        for (var i = 1; i < length - 1; ++i) {
            p1x = points[(i - 1) * 2];
            p1y = points[((i - 1) * 2) + 1];
            p2x = points[i * 2];
            p2y = points[(i * 2) + 1];
            p3x = points[(i + 1) * 2];
            p3y = points[((i + 1) * 2) + 1];
            perpx = -(p1y - p2y);
            perpy = p1x - p2x;
            dist = Math.sqrt((perpx * perpx) + (perpy * perpy));
            perpx /= dist;
            perpy /= dist;
            perpx *= width;
            perpy *= width;
            perp2x = -(p2y - p3y);
            perp2y = p2x - p3x;
            dist = Math.sqrt((perp2x * perp2x) + (perp2y * perp2y));
            perp2x /= dist;
            perp2y /= dist;
            perp2x *= width;
            perp2y *= width;
            var a1 = (-perpy + p1y) - (-perpy + p2y);
            var b1 = (-perpx + p2x) - (-perpx + p1x);
            var c1 = ((-perpx + p1x) * (-perpy + p2y)) - ((-perpx + p2x) * (-perpy + p1y));
            var a2 = (-perp2y + p3y) - (-perp2y + p2y);
            var b2 = (-perp2x + p2x) - (-perp2x + p3x);
            var c2 = ((-perp2x + p3x) * (-perp2y + p2y)) - ((-perp2x + p2x) * (-perp2y + p3y));
            var denom = (a1 * b2) - (a2 * b1);
            if (Math.abs(denom) < 0.1) {
                denom += 10.1;
                verts.push(p2x - (perpx * r1), p2y - (perpy * r1));
                verts.push(p2x + (perpx * r2), p2y + (perpy * r2));
                continue;
            }
            var px = ((b1 * c2) - (b2 * c1)) / denom;
            var py = ((a2 * c1) - (a1 * c2)) / denom;
            var pdist = ((px - p2x) * (px - p2x)) + ((py - p2y) * (py - p2y));
            if (pdist > (196 * width * width)) {
                perp3x = perpx - perp2x;
                perp3y = perpy - perp2y;
                dist = Math.sqrt((perp3x * perp3x) + (perp3y * perp3y));
                perp3x /= dist;
                perp3y /= dist;
                perp3x *= width;
                perp3y *= width;
                verts.push(p2x - (perp3x * r1), p2y - (perp3y * r1));
                verts.push(p2x + (perp3x * r2), p2y + (perp3y * r2));
                verts.push(p2x - (perp3x * r2 * r1), p2y - (perp3y * r1));
                indexCount++;
            }
            else {
                verts.push(p2x + ((px - p2x) * r1), p2y + ((py - p2y) * r1));
                verts.push(p2x - ((px - p2x) * r2), p2y - ((py - p2y) * r2));
            }
        }
        p1x = points[(length - 2) * 2];
        p1y = points[((length - 2) * 2) + 1];
        p2x = points[(length - 1) * 2];
        p2y = points[((length - 1) * 2) + 1];
        perpx = -(p1y - p2y);
        perpy = p1x - p2x;
        dist = Math.sqrt((perpx * perpx) + (perpy * perpy));
        perpx /= dist;
        perpy /= dist;
        perpx *= width;
        perpy *= width;
        verts.push(p2x - (perpx * r1), p2y - (perpy * r1));
        verts.push(p2x + (perpx * r2), p2y + (perpy * r2));
        var indices = graphicsGeometry.indices;
        // indices.push(indexStart);
        for (var i$1 = 0; i$1 < indexCount - 2; ++i$1) {
            indices.push(indexStart, indexStart + 1, indexStart + 2);
            indexStart++;
        }
        if (firstPoint) {
            firstPoint.recycle();
        }
        if (lastPoint) {
            lastPoint.recycle();
        }
    }
    static earcut(data, holeIndices, dim) {
        dim = dim || 2;
        var hasHoles = holeIndices && holeIndices.length, outerLen = hasHoles ? holeIndices[0] * dim : data.length, outerNode = GraphicsGeometry.linkedList(data, 0, outerLen, dim, true), triangles = [];
        if (!outerNode || outerNode.next === outerNode.prev) {
            return triangles;
        }
        var minX, minY, maxX, maxY, x, y, invSize;
        if (hasHoles) {
            outerNode = GraphicsGeometry.eliminateHoles(data, holeIndices, outerNode, dim);
        }
        // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
        if (data.length > 80 * dim) {
            minX = maxX = data[0];
            minY = maxY = data[1];
            for (var i = dim; i < outerLen; i += dim) {
                x = data[i];
                y = data[i + 1];
                if (x < minX) {
                    minX = x;
                }
                if (y < minY) {
                    minY = y;
                }
                if (x > maxX) {
                    maxX = x;
                }
                if (y > maxY) {
                    maxY = y;
                }
            }
            // minX, minY and invSize are later used to transform coords into integers for z-order calculation
            invSize = Math.max(maxX - minX, maxY - minY);
            invSize = invSize !== 0 ? 1 / invSize : 0;
        }
        GraphicsGeometry.earcutLinked(outerNode, triangles, dim, minX, minY, invSize);
        return triangles;
    }
    // create a circular doubly linked list from polygon points in the specified winding order
    static linkedList(data, start, end, dim, clockwise) {
        var i, last;
        if (clockwise === (GraphicsGeometry.signedArea(data, start, end, dim) > 0)) {
            for (i = start; i < end; i += dim) {
                last = GraphicsGeometry.insertNode(i, data[i], data[i + 1], last);
            }
        }
        else {
            for (i = end - dim; i >= start; i -= dim) {
                last = GraphicsGeometry.insertNode(i, data[i], data[i + 1], last);
            }
        }
        if (last && GraphicsGeometry.equals(last, last.next)) {
            GraphicsGeometry.removeNode(last);
            last = last.next;
        }
        return last;
    }
    // link every hole into the outer loop, producing a single-ring polygon without holes
    static eliminateHoles(data, holeIndices, outerNode, dim) {
        var queue = [], i, len, start, end, list;
        for (i = 0, len = holeIndices.length; i < len; i++) {
            start = holeIndices[i] * dim;
            end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
            list = GraphicsGeometry.linkedList(data, start, end, dim, false);
            if (list === list.next) {
                list.steiner = true;
            }
            queue.push(GraphicsGeometry.getLeftmost(list));
        }
        queue.sort(GraphicsGeometry.compareX);
        // process holes from left to right
        for (i = 0; i < queue.length; i++) {
            GraphicsGeometry.eliminateHole(queue[i], outerNode);
            outerNode = GraphicsGeometry.filterPoints(outerNode, outerNode.next);
        }
        return outerNode;
    }
    // main ear slicing loop which triangulates a polygon (given as a linked list)
    static earcutLinked(ear, triangles, dim, minX, minY, invSize, pass = null) {
        if (!ear) {
            return;
        }
        // interlink polygon nodes in z-order
        if (!pass && invSize) {
            GraphicsGeometry.indexCurve(ear, minX, minY, invSize);
        }
        var stop = ear, prev, next;
        // iterate through ears, slicing them one by one
        while (ear.prev !== ear.next) {
            prev = ear.prev;
            next = ear.next;
            if (invSize ? GraphicsGeometry.isEarHashed(ear, minX, minY, invSize) : GraphicsGeometry.isEar(ear)) {
                // cut off the triangle
                triangles.push(prev.i / dim);
                triangles.push(ear.i / dim);
                triangles.push(next.i / dim);
                GraphicsGeometry.removeNode(ear);
                // skipping the next vertex leads to less sliver triangles
                ear = next.next;
                stop = next.next;
                continue;
            }
            ear = next;
            // if we looped through the whole remaining polygon and can't find any more ears
            if (ear === stop) {
                // try filtering points and slicing again
                if (!pass) {
                    GraphicsGeometry.earcutLinked(GraphicsGeometry.filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
                    // if this didn't work, try curing all small self-intersections locally
                }
                else if (pass === 1) {
                    ear = GraphicsGeometry.cureLocalIntersections(ear, triangles, dim);
                    GraphicsGeometry.earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
                    // as a last resort, try splitting the remaining polygon into two
                }
                else if (pass === 2) {
                    GraphicsGeometry.splitEarcut(ear, triangles, dim, minX, minY, invSize);
                }
                break;
            }
        }
    }
    static signedArea(data, start, end, dim) {
        var sum = 0;
        for (var i = start, j = end - dim; i < end; i += dim) {
            sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
            j = i;
        }
        return sum;
    }
    // create a node and optionally link it with previous one (in a circular doubly linked list)
    static insertNode(i, x, y, last) {
        var p = new Node(i, x, y);
        if (!last) {
            p.prev = p;
            p.next = p;
        }
        else {
            p.next = last.next;
            p.prev = last;
            last.next.prev = p;
            last.next = p;
        }
        return p;
    }
    // check if two points are equal
    static equals(p1, p2) {
        return p1.x === p2.x && p1.y === p2.y;
    }
    static removeNode(p) {
        p.next.prev = p.prev;
        p.prev.next = p.next;
        if (p.prevZ) {
            p.prevZ.nextZ = p.nextZ;
        }
        if (p.nextZ) {
            p.nextZ.prevZ = p.prevZ;
        }
    }
    // find the leftmost node of a polygon ring
    static getLeftmost(start) {
        var p = start, leftmost = start;
        do {
            if (p.x < leftmost.x || (p.x === leftmost.x && p.y < leftmost.y)) {
                leftmost = p;
            }
            p = p.next;
        } while (p !== start);
        return leftmost;
    }
    static compareX(a, b) {
        return a.x - b.x;
    }
    // find a bridge between vertices that connects hole with an outer ring and and link it
    static eliminateHole(hole, outerNode) {
        outerNode = GraphicsGeometry.findHoleBridge(hole, outerNode);
        if (outerNode) {
            var b = GraphicsGeometry.splitPolygon(outerNode, hole);
            GraphicsGeometry.filterPoints(b, b.next);
        }
    }
    // eliminate colinear or duplicate points
    static filterPoints(start, end = null) {
        if (!start) {
            return start;
        }
        if (!end) {
            end = start;
        }
        var p = start, again;
        do {
            again = false;
            if (!p.steiner && (GraphicsGeometry.equals(p, p.next) || GraphicsGeometry.area(p.prev, p, p.next) === 0)) {
                GraphicsGeometry.removeNode(p);
                p = end = p.prev;
                if (p === p.next) {
                    break;
                }
                again = true;
            }
            else {
                p = p.next;
            }
        } while (again || p !== end);
        return end;
    }
    // signed area of a triangle
    static area(p, q, r) {
        return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
    }
    // link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
    // if one belongs to the outer ring and another to a hole, it merges it into a single ring
    static splitPolygon(a, b) {
        var a2 = new Node(a.i, a.x, a.y), b2 = new Node(b.i, b.x, b.y), an = a.next, bp = b.prev;
        a.next = b;
        b.prev = a;
        a2.next = an;
        an.prev = a2;
        b2.next = a2;
        a2.prev = b2;
        bp.next = b2;
        b2.prev = bp;
        return b2;
    }
    // David Eberly's algorithm for finding a bridge between hole and outer polygon
    static findHoleBridge(hole, outerNode) {
        var p = outerNode, hx = hole.x, hy = hole.y, qx = -Infinity, m;
        // find a segment intersected by a ray from the hole's leftmost point to the left;
        // segment's endpoint with lesser x will be potential connection point
        do {
            if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
                var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
                if (x <= hx && x > qx) {
                    qx = x;
                    if (x === hx) {
                        if (hy === p.y) {
                            return p;
                        }
                        if (hy === p.next.y) {
                            return p.next;
                        }
                    }
                    m = p.x < p.next.x ? p : p.next;
                }
            }
            p = p.next;
        } while (p !== outerNode);
        if (!m) {
            return null;
        }
        if (hx === qx) {
            return m.prev;
        } // hole touches outer segment; pick lower endpoint
        // look for points inside the triangle of hole point, segment intersection and endpoint;
        // if there are no points found, we have a valid connection;
        // otherwise choose the point of the minimum angle with the ray as connection point
        var stop = m, mx = m.x, my = m.y, tanMin = Infinity, tan;
        p = m.next;
        while (p !== stop) {
            if (hx >= p.x && p.x >= mx && hx !== p.x &&
                GraphicsGeometry.pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
                tan = Math.abs(hy - p.y) / (hx - p.x); // tangential
                if ((tan < tanMin || (tan === tanMin && p.x > m.x)) && GraphicsGeometry.locallyInside(p, hole)) {
                    m = p;
                    tanMin = tan;
                }
            }
            p = p.next;
        }
        return m;
    }
    // check if a polygon diagonal is locally inside the polygon
    static locallyInside(a, b) {
        return GraphicsGeometry.area(a.prev, a, a.next) < 0 ?
            GraphicsGeometry.area(a, b, a.next) >= 0 && GraphicsGeometry.area(a, a.prev, b) >= 0 :
            GraphicsGeometry.area(a, b, a.prev) < 0 || GraphicsGeometry.area(a, a.next, b) < 0;
    }
    // check if a point lies within a convex triangle
    static pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
        return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 &&
            (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 &&
            (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
    }
    // try splitting polygon into two and triangulate them independently
    static splitEarcut(start, triangles, dim, minX, minY, invSize) {
        // look for a valid diagonal that divides the polygon into two
        var a = start;
        do {
            var b = a.next.next;
            while (b !== a.prev) {
                if (a.i !== b.i && GraphicsGeometry.isValidDiagonal(a, b)) {
                    // split the polygon in two by the diagonal
                    var c = GraphicsGeometry.splitPolygon(a, b);
                    // filter colinear points around the cuts
                    a = GraphicsGeometry.filterPoints(a, a.next);
                    c = GraphicsGeometry.filterPoints(c, c.next);
                    // run earcut on each half
                    GraphicsGeometry.earcutLinked(a, triangles, dim, minX, minY, invSize);
                    GraphicsGeometry.earcutLinked(c, triangles, dim, minX, minY, invSize);
                    return;
                }
                b = b.next;
            }
            a = a.next;
        } while (a !== start);
    }
    // check if a diagonal between two polygon nodes is valid (lies in polygon interior)
    static isValidDiagonal(a, b) {
        return a.next.i !== b.i && a.prev.i !== b.i && !GraphicsGeometry.intersectsPolygon(a, b) &&
            GraphicsGeometry.locallyInside(a, b) && GraphicsGeometry.locallyInside(b, a) && GraphicsGeometry.middleInside(a, b);
    }
    // check if the middle point of a polygon diagonal is inside the polygon
    static middleInside(a, b) {
        var p = a, inside = false, px = (a.x + b.x) / 2, py = (a.y + b.y) / 2;
        do {
            if (((p.y > py) !== (p.next.y > py)) && p.next.y !== p.y &&
                (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x)) {
                inside = !inside;
            }
            p = p.next;
        } while (p !== a);
        return inside;
    }
    // check if a polygon diagonal intersects any polygon segments
    static intersectsPolygon(a, b) {
        var p = a;
        do {
            if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&
                GraphicsGeometry.intersects(p, p.next, a, b)) {
                return true;
            }
            p = p.next;
        } while (p !== a);
        return false;
    }
    // check if two segments intersect
    static intersects(p1, q1, p2, q2) {
        if ((GraphicsGeometry.equals(p1, q1) && GraphicsGeometry.equals(p2, q2)) ||
            (GraphicsGeometry.equals(p1, q2) && GraphicsGeometry.equals(p2, q1))) {
            return true;
        }
        return GraphicsGeometry.area(p1, q1, p2) > 0 !== GraphicsGeometry.area(p1, q1, q2) > 0 &&
            GraphicsGeometry.area(p2, q2, p1) > 0 !== GraphicsGeometry.area(p2, q2, q1) > 0;
    }
    // go through all polygon nodes and cure small local self-intersections
    static cureLocalIntersections(start, triangles, dim) {
        var p = start;
        do {
            var a = p.prev, b = p.next.next;
            if (!GraphicsGeometry.equals(a, b) && GraphicsGeometry.intersects(a, p, p.next, b) && GraphicsGeometry.locallyInside(a, b) && GraphicsGeometry.locallyInside(b, a)) {
                triangles.push(a.i / dim);
                triangles.push(p.i / dim);
                triangles.push(b.i / dim);
                // remove two nodes involved
                GraphicsGeometry.removeNode(p);
                GraphicsGeometry.removeNode(p.next);
                p = start = b;
            }
            p = p.next;
        } while (p !== start);
        return p;
    }
    static isEarHashed(ear, minX, minY, invSize) {
        var a = ear.prev, b = ear, c = ear.next;
        if (GraphicsGeometry.area(a, b, c) >= 0) {
            return false;
        } // reflex, can't be an ear
        // triangle bbox; min & max are calculated like this for speed
        var minTX = a.x < b.x ? (a.x < c.x ? a.x : c.x) : (b.x < c.x ? b.x : c.x), minTY = a.y < b.y ? (a.y < c.y ? a.y : c.y) : (b.y < c.y ? b.y : c.y), maxTX = a.x > b.x ? (a.x > c.x ? a.x : c.x) : (b.x > c.x ? b.x : c.x), maxTY = a.y > b.y ? (a.y > c.y ? a.y : c.y) : (b.y > c.y ? b.y : c.y);
        // z-order range for the current triangle bbox;
        var minZ = GraphicsGeometry.zOrder(minTX, minTY, minX, minY, invSize), maxZ = GraphicsGeometry.zOrder(maxTX, maxTY, minX, minY, invSize);
        var p = ear.prevZ, n = ear.nextZ;
        // look for points inside the triangle in both directions
        while (p && p.z >= minZ && n && n.z <= maxZ) {
            if (p !== ear.prev && p !== ear.next &&
                GraphicsGeometry.pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
                GraphicsGeometry.area(p.prev, p, p.next) >= 0) {
                return false;
            }
            p = p.prevZ;
            if (n !== ear.prev && n !== ear.next &&
                GraphicsGeometry.pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) &&
                GraphicsGeometry.area(n.prev, n, n.next) >= 0) {
                return false;
            }
            n = n.nextZ;
        }
        // look for remaining points in decreasing z-order
        while (p && p.z >= minZ) {
            if (p !== ear.prev && p !== ear.next &&
                GraphicsGeometry.pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
                GraphicsGeometry.area(p.prev, p, p.next) >= 0) {
                return false;
            }
            p = p.prevZ;
        }
        // look for remaining points in increasing z-order
        while (n && n.z <= maxZ) {
            if (n !== ear.prev && n !== ear.next &&
                GraphicsGeometry.pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) &&
                GraphicsGeometry.area(n.prev, n, n.next) >= 0) {
                return false;
            }
            n = n.nextZ;
        }
        return true;
    }
    // z-order of a point given coords and inverse of the longer side of data bbox
    static zOrder(x, y, minX, minY, invSize) {
        // coords are transformed into non-negative 15-bit integer range
        x = 32767 * (x - minX) * invSize;
        y = 32767 * (y - minY) * invSize;
        x = (x | (x << 8)) & 0x00FF00FF;
        x = (x | (x << 4)) & 0x0F0F0F0F;
        x = (x | (x << 2)) & 0x33333333;
        x = (x | (x << 1)) & 0x55555555;
        y = (y | (y << 8)) & 0x00FF00FF;
        y = (y | (y << 4)) & 0x0F0F0F0F;
        y = (y | (y << 2)) & 0x33333333;
        y = (y | (y << 1)) & 0x55555555;
        return x | (y << 1);
    }
    // check whether a polygon node forms a valid ear with adjacent nodes
    static isEar(ear) {
        var a = ear.prev, b = ear, c = ear.next;
        if (GraphicsGeometry.area(a, b, c) >= 0) {
            return false;
        } // reflex, can't be an ear
        // now make sure we don't have other points inside the potential ear
        var p = ear.next.next;
        while (p !== ear.prev) {
            if (GraphicsGeometry.pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
                GraphicsGeometry.area(p.prev, p, p.next) >= 0) {
                return false;
            }
            p = p.next;
        }
        return true;
    }
    // interlink polygon nodes in z-order
    static indexCurve(start, minX, minY, invSize) {
        var p = start;
        do {
            if (p.z === null) {
                p.z = GraphicsGeometry.zOrder(p.x, p.y, minX, minY, invSize);
            }
            p.prevZ = p.prev;
            p.nextZ = p.next;
            p = p.next;
        } while (p !== start);
        p.prevZ.nextZ = null;
        p.prevZ = null;
        GraphicsGeometry.sortLinked(p);
    }
    // Simon Tatham's linked list merge sort algorithm
    // http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
    static sortLinked(list) {
        var i, p, q, e, tail, numMerges, pSize, qSize, inSize = 1;
        do {
            p = list;
            list = null;
            tail = null;
            numMerges = 0;
            while (p) {
                numMerges++;
                q = p;
                pSize = 0;
                for (i = 0; i < inSize; i++) {
                    pSize++;
                    q = q.nextZ;
                    if (!q) {
                        break;
                    }
                }
                qSize = inSize;
                while (pSize > 0 || (qSize > 0 && q)) {
                    if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
                        e = p;
                        p = p.nextZ;
                        pSize--;
                    }
                    else {
                        e = q;
                        q = q.nextZ;
                        qSize--;
                    }
                    if (tail) {
                        tail.nextZ = e;
                    }
                    else {
                        list = e;
                    }
                    e.prevZ = tail;
                    tail = e;
                }
                p = q;
            }
            tail.nextZ = null;
            inSize *= 2;
        } while (numMerges > 1);
        return list;
    }
    /**
 * Calculate the points for a quadratic bezier curve. (helper function..)
 * Based on: https://stackoverflow.com/questions/785097/how-do-i-implement-a-bezier-curve-in-c
 *
 * Ignored from docs since it is not directly exposed.
 *
 * @ignore
 * @private
 * @param {number} fromX - Origin point x
 * @param {number} fromY - Origin point x
 * @param {number} cpX - Control point x
 * @param {number} cpY - Control point y
 * @param {number} toX - Destination point x
 * @param {number} toY - Destination point y
 * @param {number[]} [out=[]] - The output array to add points into. If not passed, a new array is created.
 * @return {number[]} an array of points
 */
    static quadraticBezierCurve(fromX, fromY, cpX, cpY, toX, toY, out) {
        if (out === void 0) {
            out = [];
        }
        var n = 20;
        var points = out;
        var xa = 0;
        var ya = 0;
        var xb = 0;
        var yb = 0;
        var x = 0;
        var y = 0;
        for (var i = 0, j = 0; i <= n; ++i) {
            j = i / n;
            // The Green Line
            xa = GraphicsGeometry.getPt(fromX, cpX, j);
            ya = GraphicsGeometry.getPt(fromY, cpY, j);
            xb = GraphicsGeometry.getPt(cpX, toX, j);
            yb = GraphicsGeometry.getPt(cpY, toY, j);
            // The Black Dot
            x = GraphicsGeometry.getPt(xa, xb, j);
            y = GraphicsGeometry.getPt(ya, yb, j);
            points.push(x, y);
        }
        return points;
    }
    /**
 * Calculate a single point for a quadratic bezier curve.
 * Utility function used by quadraticBezierCurve.
 * Ignored from docs since it is not directly exposed.
 *
 * @ignore
 * @private
 * @param {number} n1 - first number
 * @param {number} n2 - second number
 * @param {number} perc - percentage
 * @return {number} the result
 *
 */
    static getPt(n1, n2, perc) {
        var diff = n2 - n1;
        return n1 + (diff * perc);
    }
}
GraphicsGeometry.BATCH_POOL = [];
GraphicsGeometry.DRAW_CALL_POOL = [];
/**
* The maximum number of points to consider an object "batchable",
* able to be batched by the renderer's batch system.
*
* @memberof PIXI.GraphicsGeometry
* @static
* @member {number} BATCHABLE_SIZE
* @default 100
*/
GraphicsGeometry.BATCHABLE_SIZE = 100;
/**
* Builds a polygon to draw
*
* Ignored from docs since it is not directly exposed.
*
* @ignore
* @private
* @param {PIXI.WebGLGraphicsData} graphicsData - The graphics object containing all the necessary properties
* @param {object} webGLData - an object containing all the WebGL-specific information to create this shape
* @param {object} webGLDataNativeLines - an object containing all the WebGL-specific information to create nativeLines
*/
GraphicsGeometry.buildPoly = {
    name: "buildPoly",
    build: function build(graphicsData) {
        graphicsData.points = graphicsData.shape.points.slice();
    },
    triangulate: function triangulate(graphicsData, graphicsGeometry) {
        var points = graphicsData.points;
        var holes = graphicsData.holes;
        var verts = graphicsGeometry.points;
        var indices = graphicsGeometry.indices;
        if (points.length >= 6) {
            var holeArray = [];
            // Process holes..
            for (var i = 0; i < holes.length; i++) {
                var hole = holes[i];
                holeArray.push(points.length / 2);
                points = points.concat(hole.points);
            }
            // sort color
            var triangles = GraphicsGeometry.earcut(points, holeArray, 2);
            if (!triangles) {
                return;
            }
            var vertPos = verts.length / 2;
            for (var i$1 = 0; i$1 < triangles.length; i$1 += 3) {
                indices.push(triangles[i$1] + vertPos);
                indices.push(triangles[i$1 + 1] + vertPos);
                indices.push(triangles[i$1 + 2] + vertPos);
            }
            for (var i$2 = 0; i$2 < points.length; i$2++) {
                verts.push(points[i$2]);
            }
        }
    },
};
/**
* Builds a rectangle to draw
*
* Ignored from docs since it is not directly exposed.
*
* @ignore
* @private
* @param {PIXI.WebGLGraphicsData} graphicsData - The graphics object containing all the necessary properties
* @param {object} webGLData - an object containing all the WebGL-specific information to create this shape
* @param {object} webGLDataNativeLines - an object containing all the WebGL-specific information to create nativeLines
*/
GraphicsGeometry.buildRectangle = {
    name: "buildRectangle",
    build: function build(graphicsData) {
        // --- //
        // need to convert points to a nice regular data
        //
        var rectData = graphicsData.shape;
        var x = rectData.x;
        var y = rectData.y;
        var width = rectData.width;
        var height = rectData.height;
        var points = graphicsData.points;
        points.length = 0;
        points.push(x, y, x + width, y, x + width, y + height, x, y + height);
    },
    triangulate: function triangulate(graphicsData, graphicsGeometry) {
        var points = graphicsData.points;
        var verts = graphicsGeometry.points;
        var vertPos = verts.length / 2;
        verts.push(points[0], points[1], points[2], points[3], points[6], points[7], points[4], points[5]);
        graphicsGeometry.indices.push(vertPos, vertPos + 1, vertPos + 2, vertPos + 1, vertPos + 2, vertPos + 3);
    },
};
/**
* Builds a rounded rectangle to draw
*
* Ignored from docs since it is not directly exposed.
*
* @ignore
* @private
* @param {PIXI.WebGLGraphicsData} graphicsData - The graphics object containing all the necessary properties
* @param {object} webGLData - an object containing all the WebGL-specific information to create this shape
* @param {object} webGLDataNativeLines - an object containing all the WebGL-specific information to create nativeLines
*/
GraphicsGeometry.buildRoundedRectangle = {
    name: "buildRoundedRectangle",
    build: function build(graphicsData) {
        var rrectData = graphicsData.shape;
        var points = graphicsData.points;
        var x = rrectData.x;
        var y = rrectData.y;
        var width = rrectData.width;
        var height = rrectData.height;
        var radius = rrectData.radius;
        points.length = 0;
        GraphicsGeometry.quadraticBezierCurve(x, y + radius, x, y, x + radius, y, points);
        GraphicsGeometry.quadraticBezierCurve(x + width - radius, y, x + width, y, x + width, y + radius, points);
        GraphicsGeometry.quadraticBezierCurve(x + width, y + height - radius, x + width, y + height, x + width - radius, y + height, points);
        GraphicsGeometry.quadraticBezierCurve(x + radius, y + height, x, y + height, x, y + height - radius, points);
        // this tiny number deals with the issue that occurs when points overlap and earcut fails to triangulate the item.
        // TODO - fix this properly, this is not very elegant.. but it works for now.
    },
    triangulate: function triangulate(graphicsData, graphicsGeometry) {
        var points = graphicsData.points;
        var verts = graphicsGeometry.points;
        var indices = graphicsGeometry.indices;
        var vecPos = verts.length / 2;
        var triangles = GraphicsGeometry.earcut(points, null, 2);
        for (var i = 0, j = triangles.length; i < j; i += 3) {
            indices.push(triangles[i] + vecPos);
            //     indices.push(triangles[i] + vecPos);
            indices.push(triangles[i + 1] + vecPos);
            //   indices.push(triangles[i + 2] + vecPos);
            indices.push(triangles[i + 2] + vecPos);
        }
        for (var i$1 = 0, j$1 = points.length; i$1 < j$1; i$1++) {
            verts.push(points[i$1], points[++i$1]);
        }
    },
};
/**
* Builds a circle to draw
*
* Ignored from docs since it is not directly exposed.
*
* @ignore
* @private
* @param {PIXI.WebGLGraphicsData} graphicsData - The graphics object to draw
* @param {object} webGLData - an object containing all the WebGL-specific information to create this shape
* @param {object} webGLDataNativeLines - an object containing all the WebGL-specific information to create nativeLines
*/
GraphicsGeometry.buildCircle = {
    name: "buildCircle",
    build: function build(graphicsData) {
        // need to convert points to a nice regular data
        var circleData = graphicsData.shape;
        var points = graphicsData.points;
        var x = circleData.x;
        var y = circleData.y;
        var width;
        var height;
        points.length = 0;
        // TODO - bit hacky??
        if (graphicsData.type === ShapeSettings_1.ShapeSettings.SHAPES.CIRC) {
            width = circleData.radius;
            height = circleData.radius;
        }
        else {
            width = circleData.width;
            height = circleData.height;
        }
        if (width === 0 || height === 0) {
            return;
        }
        var totalSegs = Math.floor(30 * Math.sqrt(circleData.radius))
            || Math.floor(15 * Math.sqrt(circleData.width + circleData.height));
        totalSegs /= 2.3;
        var seg = (Math.PI * 2) / totalSegs;
        for (var i = 0; i < totalSegs; i++) {
            points.push(x + (Math.sin(-seg * i) * width), y + (Math.cos(-seg * i) * height));
        }
        points.push(points[0], points[1]);
    },
    triangulate: function triangulate(graphicsData, graphicsGeometry) {
        var points = graphicsData.points;
        var verts = graphicsGeometry.points;
        var indices = graphicsGeometry.indices;
        var vertPos = verts.length / 2;
        var center = vertPos;
        verts.push(graphicsData.shape.x, graphicsData.shape.y);
        for (var i = 0; i < points.length; i += 2) {
            verts.push(points[i], points[i + 1]);
            // add some uvs
            indices.push(vertPos++, center, vertPos);
        }
    },
};
exports.GraphicsGeometry = GraphicsGeometry;
class Node {
    constructor(i, x, y) {
        // vertex index in coordinates array
        this.i = i;
        // vertex coordinates
        this.x = x;
        this.y = y;
        // previous and next vertex nodes in a polygon ring
        this.prev = null;
        this.next = null;
        // z-order curve value
        this.z = null;
        // previous and next nodes in z-order
        this.prevZ = null;
        this.nextZ = null;
        // indicates whether this is a steiner point
        this.steiner = false;
    }
}


/***/ }),

/***/ "./js-compile/raw-pixi-ts/GroupD8.js":
/*!*******************************************!*\
  !*** ./js-compile/raw-pixi-ts/GroupD8.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Matrix_1 = __webpack_require__(/*! ./Matrix */ "./js-compile/raw-pixi-ts/Matrix.js");
class GroupD8 {
    static uX(ind) {
        GroupD8.init();
        return GroupD8.ux[ind];
    }
    static uY(ind) {
        GroupD8.init();
        return GroupD8.uy[ind];
    }
    static vX(ind) {
        GroupD8.init();
        return GroupD8.vx[ind];
    }
    static vY(ind) {
        GroupD8.init();
        return GroupD8.vy[ind];
    }
    static inv(rotation) {
        if (rotation & 8) {
            return rotation & 15;
        }
        return (-rotation) & 7;
    }
    static add(rotationSecond, rotationFirst) {
        GroupD8.init();
        return GroupD8.mul[rotationSecond][rotationFirst];
    }
    static sub(rotationSecond, rotationFirst) {
        GroupD8.init();
        return GroupD8.mul[rotationSecond][GroupD8.inv(rotationFirst)];
    }
    static rotate180(rotation) {
        return rotation ^ 4;
    }
    static isVertical(rotation) {
        return (rotation & 3) === 2;
    }
    static byDirection(dx, dy) {
        GroupD8.init();
        if (Math.abs(dx) * 2 <= Math.abs(dy)) {
            if (dy >= 0) {
                return GroupD8.S;
            }
            return GroupD8.N;
        }
        else if (Math.abs(dy) * 2 <= Math.abs(dx)) {
            if (dx > 0) {
                return GroupD8.E;
            }
            return GroupD8.W;
        }
        else if (dy > 0) {
            if (dx > 0) {
                return GroupD8.SE;
            }
            return GroupD8.SW;
        }
        else if (dx > 0) {
            return GroupD8.NE;
        }
        return GroupD8.NW;
    }
    static matrixAppendRotationInv(matrix, rotation, tx = 0, ty = 0) {
        GroupD8.init();
        let mat = GroupD8.tempMatrices[GroupD8.inv(rotation)];
        mat.tx = tx;
        mat.ty = ty;
        matrix.append(mat);
    }
    static signum(x) {
        if (x < 0) {
            return -1;
        }
        if (x > 0) {
            return 1;
        }
        return 0;
    }
    static init() {
        if (GroupD8.isInit) {
            return;
        }
        GroupD8.isInit = true;
        for (var i = 0; i < 16; i++) {
            var row = [];
            GroupD8.mul.push(row);
            for (var j = 0; j < 16; j++) {
                var _ux = GroupD8.signum((GroupD8.ux[i] * GroupD8.ux[j]) + (GroupD8.vx[i] * GroupD8.uy[j]));
                var _uy = GroupD8.signum((GroupD8.uy[i] * GroupD8.ux[j]) + (GroupD8.vy[i] * GroupD8.uy[j]));
                var _vx = GroupD8.signum((GroupD8.ux[i] * GroupD8.vx[j]) + (GroupD8.vx[i] * GroupD8.vy[j]));
                var _vy = GroupD8.signum((GroupD8.uy[i] * GroupD8.vx[j]) + (GroupD8.vy[i] * GroupD8.vy[j]));
                for (var k = 0; k < 16; k++) {
                    if (GroupD8.ux[k] === _ux && GroupD8.uy[k] === _uy && GroupD8.vx[k] === _vx && GroupD8.vy[k] === _vy) {
                        row.push(k);
                        break;
                    }
                }
            }
        }
        for (var i$1 = 0; i$1 < 16; i$1++) {
            var mat = new Matrix_1.Matrix();
            mat.set(GroupD8.ux[i$1], GroupD8.uy[i$1], GroupD8.vx[i$1], GroupD8.vy[i$1], 0, 0);
            GroupD8.tempMatrices.push(mat);
        }
    }
}
GroupD8.isInit = false;
GroupD8.E = 0;
GroupD8.SE = 1;
GroupD8.S = 2;
GroupD8.SW = 3;
GroupD8.W = 4;
GroupD8.NW = 5;
GroupD8.N = 6;
GroupD8.NE = 7;
GroupD8.MIRROR_VERTICAL = 8;
GroupD8.MIRROR_HORIZONTAL = 12;
GroupD8.ux = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1];
GroupD8.uy = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1];
GroupD8.vx = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1];
GroupD8.vy = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1];
GroupD8.tempMatrices = [];
GroupD8.mul = [];
exports.GroupD8 = GroupD8;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/IOErrorEvent.js":
/*!************************************************!*\
  !*** ./js-compile/raw-pixi-ts/IOErrorEvent.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Event_1 = __webpack_require__(/*! ./Event */ "./js-compile/raw-pixi-ts/Event.js");
class IOErrorEvent extends Event_1.Event {
    constructor(type, bubble = true, cancelable = true) {
        super(type, bubble, cancelable);
        this.errorId = 0;
    }
    clone() {
        var event = new IOErrorEvent(this.type, this.bubbles, this.cancelable);
        event.text = this.text;
        event.errorId = this.errorId;
        return event;
    }
    get isDisposable() {
        return false;
    }
}
IOErrorEvent.IO_ERROR = "ioError";
exports.IOErrorEvent = IOErrorEvent;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/ImageResource.js":
/*!*************************************************!*\
  !*** ./js-compile/raw-pixi-ts/ImageResource.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseImageResource_1 = __webpack_require__(/*! ./BaseImageResource */ "./js-compile/raw-pixi-ts/BaseImageResource.js");
const DisplaySettings_1 = __webpack_require__(/*! ./DisplaySettings */ "./js-compile/raw-pixi-ts/DisplaySettings.js");
class ImageResource extends BaseImageResource_1.BaseImageResource {
    constructor(source, options = {}) {
        super(source);
        if (!(source instanceof HTMLImageElement)) {
            var imageElement = new Image();
            // BaseImageResource.crossOrigin(imageElement, source, options.crossorigin);
            imageElement.src = source;
            source = imageElement;
            this.source = source;
        }
        /**
         * URL of the image source
         * @member {string}
         */
        this.url = source.src;
        /**
         * When process is completed
         * @member {Promise<void>}
         * @private
         */
        this._process = null;
        /**
         * If the image should be disposed after upload
         * @member {boolean}
         * @default false
         */
        this.preserveBitmap = false;
        /**
         * If capable, convert the image using createImageBitmap API
         * @member {boolean}
         * @default PIXI.settings.CREATE_IMAGE_BITMAP
         */
        this.createBitmap = options.createBitmap !== false && DisplaySettings_1.DisplaySettings.CREATE_IMAGE_BITMAP && !!window.createImageBitmap;
        /**
         * Controls texture premultiplyAlpha field
         * Copies from options
         * @member {boolean|null}
         * @readonly
         */
        this.premultiplyAlpha = options.premultiplyAlpha !== false;
        /**
         * The ImageBitmap element created for HTMLImageElement
         * @member {ImageBitmap}
         * @default null
         */
        this.bitmap = null;
        /**
         * Promise when loading
         * @member {Promise<void>}
         * @private
         * @default null
         */
        this._load = null;
        if (options.autoLoad !== false) {
            this.load();
        }
    }
    /**
     * returns a promise when image will be loaded and processed
     *
     * @param {boolean} [createBitmap=true] whether process image into bitmap
     * @returns {Promise<void>}
     */
    load(createBitmap = undefined) {
        if (createBitmap !== undefined) {
            this.createBitmap = createBitmap;
        }
        if (this._load) {
            return this._load;
        }
        this._load = new Promise((resolve) => {
            this.url = this.source.src;
            var ref = this;
            var source = ref.source;
            var completed = () => {
                if (this.destroyed) {
                    return;
                }
                source.onload = null;
                source.onerror = null;
                this.resize(source.width, source.height);
                this._load = null;
                if (this.createBitmap) {
                    resolve(this.process());
                }
                else {
                    resolve(this);
                }
            };
            if (source.complete && source.src) {
                completed();
            }
            else {
                source.onload = completed;
            }
        });
        return this._load;
    }
    ;
    /**
    * Called when we need to convert image into BitmapImage.
    * Can be called multiple times, real promise is cached inside.
    *
    * @returns {Promise<void>} cached promise to fill that bitmap
    */
    process() {
        if (this._process !== null) {
            return this._process;
        }
        if (this.bitmap !== null || !window.createImageBitmap) {
            return Promise.resolve(this);
        }
        this._process = window.createImageBitmap(this.source, 0, 0, this.source.width, this.source.height)
            .then((bitmap) => {
            if (this.destroyed) {
                return Promise.reject("");
            }
            this.bitmap = bitmap;
            this.update(0);
            this._process = null;
            return Promise.resolve(this);
        });
        return this._process;
    }
    ;
    /**
    * Upload the image resource to GPU.
    *
    * @param {PIXI.Renderer} renderer - Renderer to upload to
    * @param {PIXI.BaseTexture} baseTexture - BaseTexture for this resource
    * @param {PIXI.GLTexture} glTexture - GLTexture to use
    * @returns {boolean} true is success
    */
    upload(renderer, baseTexture, glTexture) {
        baseTexture.premultiplyAlpha = this.premultiplyAlpha;
        if (!this.createBitmap) {
            return super.upload(renderer, baseTexture, glTexture);
        }
        if (!this.bitmap) {
            // yeah, ignore the output
            this.process();
            if (!this.bitmap) {
                return false;
            }
        }
        super.upload(renderer, baseTexture, glTexture, this.bitmap);
        if (!this.preserveBitmap) {
            // checks if there are other renderers that possibly need this bitmap
            var flag = true;
            for (var key in baseTexture._glTextures) {
                var otherTex = baseTexture._glTextures[key];
                if (otherTex !== glTexture && otherTex.dirtyId !== baseTexture.dirtyId) {
                    flag = false;
                    break;
                }
            }
            if (flag) {
                if (this.bitmap.close) {
                    this.bitmap.close();
                }
                this.bitmap = null;
            }
        }
        return true;
    }
    ;
    /**
    * Destroys this texture
    * @override
    */
    dispose() {
        super.dispose();
        if (this.bitmap) {
            this.bitmap.close();
            this.bitmap = null;
        }
        this._process = null;
        this._load = null;
    }
    ;
}
exports.ImageResource = ImageResource;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/InstanceCounter.js":
/*!***************************************************!*\
  !*** ./js-compile/raw-pixi-ts/InstanceCounter.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Logger_1 = __webpack_require__(/*! ./Logger */ "./js-compile/raw-pixi-ts/Logger.js");
class InstanceCounter {
    static enable() {
        InstanceCounter.ENABLED = true;
    }
    static recycleCount(instance) {
        if (!InstanceCounter.ENABLED) {
            return;
        }
        if (!InstanceCounter.recycleClassInstances[instance.className]) {
            InstanceCounter.recycleClassInstances[instance.className] = 0;
        }
        InstanceCounter.recycleClassInstances[instance.className]++;
        // trace(instance.className + " destructor count: " + InstanceCounter.recycleClassInstances[instance.className])        
    }
    static destructorCount(instance) {
        if (!InstanceCounter.ENABLED) {
            return;
        }
        if (!InstanceCounter.destructorClassInstances[instance.className]) {
            InstanceCounter.destructorClassInstances[instance.className] = 0;
        }
        InstanceCounter.destructorClassInstances[instance.className]++;
        // trace(instance.className + " destructor count: " + InstanceCounter.destructorClassInstances[instance.className])        
    }
    static count(instance) {
        if (!InstanceCounter.ENABLED) {
            return;
        }
        if (!InstanceCounter.classInstances[instance.className]) {
            InstanceCounter.classInstances[instance.className] = 0;
        }
        InstanceCounter.classInstances[instance.className]++;
        let created = InstanceCounter.classInstances[instance.className];
        let recyled = 0;
        let destroyed = 0;
        if (InstanceCounter.destructorClassInstances[instance.className]) {
            destroyed = InstanceCounter.destructorClassInstances[instance.className];
        }
        if (InstanceCounter.recycleClassInstances[instance.className]) {
            recyled = InstanceCounter.recycleClassInstances[instance.className];
        }
        Logger_1.trace(instance.className + " created: " + created + " , destroyed: " + destroyed + " , recycled: " + recyled);
    }
    static addCall(callTarget, caller) {
        if (!InstanceCounter.ENABLED) {
            return;
        }
        let callstack = callTarget + ":" + caller;
        if (!InstanceCounter[callstack]) {
            InstanceCounter[callstack] = 0;
        }
        InstanceCounter[callstack]++;
        Logger_1.trace(caller + " called " + callTarget + " " + InstanceCounter[callstack] + " times.");
    }
}
InstanceCounter.classInstances = {};
InstanceCounter.destructorClassInstances = {};
InstanceCounter.recycleClassInstances = {};
InstanceCounter.callStacks = {};
InstanceCounter.ENABLED = false;
exports.InstanceCounter = InstanceCounter;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/InteractionData.js":
/*!***************************************************!*\
  !*** ./js-compile/raw-pixi-ts/InteractionData.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Point_1 = __webpack_require__(/*! ../flash/geom/Point */ "./js-compile/flash/geom/Point.js");
const FlashBaseObject_1 = __webpack_require__(/*! ./FlashBaseObject */ "./js-compile/raw-pixi-ts/FlashBaseObject.js");
class InteractionData extends FlashBaseObject_1.FlashBaseObject {
    destructor() {
        if (this.global) {
            this.global.recycle();
        }
        this.global = null;
    }
    constructor() {
        super();
        this.global = Point_1.Point.getPoint();
        this.target = null;
        this.originalEvent = null;
        this.identifier = null;
        this.isPrimary = false;
        this.button = 0;
        this.buttons = 0;
        this.width = 0;
        this.height = 0;
        this.tiltX = 0;
        this.tiltY = 0;
        this.pointerType = null;
        this.pressure = 0;
        this.rotationAngle = 0;
        this.twist = 0;
        this.tangentialPressure = 0;
        this.which = 0;
    }
    getLocalPosition(displayObject, point = null, globalPos = null) {
        return displayObject.worldTransform.applyInverse(globalPos || this.global, point);
    }
    ;
    copyEvent(event) {
        if (event.isPrimary) {
            this.isPrimary = true;
        }
        this.button = event.button;
        this.buttons = Number.isInteger(event.buttons) ? event.buttons : event.which;
        this.width = event.width;
        this.height = event.height;
        this.tiltX = event.tiltX;
        this.tiltY = event.tiltY;
        this.pointerType = event.pointerType;
        this.pressure = event.pressure;
        this.rotationAngle = event.rotationAngle;
        this.twist = event.twist || 0;
        this.tangentialPressure = event.tangentialPressure || 0;
    }
    ;
    get pointerId() {
        return this.identifier;
    }
    ;
    reset() {
        this.isPrimary = false;
    }
    ;
}
exports.InteractionData = InteractionData;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/InteractionEvent.js":
/*!****************************************************!*\
  !*** ./js-compile/raw-pixi-ts/InteractionEvent.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Event_1 = __webpack_require__(/*! ./Event */ "./js-compile/raw-pixi-ts/Event.js");
class InteractionEvent extends Event_1.Event {
    constructor(type, bubble = true, cancelable = true) {
        super(type, bubble, cancelable);
        this.target = null;
        this.stopped = false;
        this._currentTarget = null;
        this._type = null;
        this.data = null;
    }
    reset() {
        this.stopped = false;
        this._currentTarget = null;
        this.target = null;
    }
    ;
    stopPropagation() {
        this.stopped = true;
    }
    ;
}
exports.InteractionEvent = InteractionEvent;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/InteractionManager.js":
/*!******************************************************!*\
  !*** ./js-compile/raw-pixi-ts/InteractionManager.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const InteractionData_1 = __webpack_require__(/*! ./InteractionData */ "./js-compile/raw-pixi-ts/InteractionData.js");
const InteractionEvent_1 = __webpack_require__(/*! ./InteractionEvent */ "./js-compile/raw-pixi-ts/InteractionEvent.js");
const MouseEvent_1 = __webpack_require__(/*! ./MouseEvent */ "./js-compile/raw-pixi-ts/MouseEvent.js");
const InteractionTrackingData_1 = __webpack_require__(/*! ./InteractionTrackingData */ "./js-compile/raw-pixi-ts/InteractionTrackingData.js");
const Ticker_1 = __webpack_require__(/*! ./Ticker */ "./js-compile/raw-pixi-ts/Ticker.js");
const Point_1 = __webpack_require__(/*! ../flash/geom/Point */ "./js-compile/flash/geom/Point.js");
const Container_1 = __webpack_require__(/*! ./Container */ "./js-compile/raw-pixi-ts/Container.js");
const Rectangle_1 = __webpack_require__(/*! ../flash/geom/Rectangle */ "./js-compile/flash/geom/Rectangle.js");
const EventDispatcher_1 = __webpack_require__(/*! ./EventDispatcher */ "./js-compile/raw-pixi-ts/EventDispatcher.js");
const InstanceCounter_1 = __webpack_require__(/*! ./InstanceCounter */ "./js-compile/raw-pixi-ts/InstanceCounter.js");
class InteractionManager extends EventDispatcher_1.EventDispatcher {
    constructor(renderer) {
        super();
        this.update = (deltaTime) => {
            this._deltaTime += deltaTime;
            if (this._deltaTime < this.interactionFrequency) {
                return;
            }
            this._deltaTime = 0;
            if (!this.interactionDOMElement) {
                return;
            }
            if (this.didMove) {
                this.didMove = false;
                return;
            }
            this.cursor = null;
            for (let k in this.activeInteractionData) {
                if (this.activeInteractionData.hasOwnProperty(k)) {
                    let interactionData = this.activeInteractionData[k];
                    if (interactionData.originalEvent && interactionData.pointerType !== 'touch') {
                        let interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, interactionData.originalEvent, interactionData);
                        this.processInteractive(interactionEvent, this.renderer._lastObjectRendered, this.processPointerOverOut, true);
                    }
                }
            }
            this.setCursorMode(this.cursor);
        };
        this.onPointerUp = (event) => {
            if (this.supportsTouchEvents && event.pointerType === 'touch') {
                return;
            }
            this.onPointerComplete(event, false, this.processPointerUp);
        };
        this.onPointerCancel = (event) => {
            if (this.supportsTouchEvents && event.pointerType === 'touch') {
                return;
            }
            this.onPointerComplete(event, true, this.processPointerCancel);
        };
        this.onPointerOver = (originalEvent) => {
            let events = this.normalizeToPointerData(originalEvent);
            let event = events[0];
            let interactionData = this.getInteractionDataForPointerId(event);
            let interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);
            interactionEvent.data.originalEvent = event;
            if (event.pointerType === 'mouse') {
                this.mouseOverRenderer = true;
            }
            let pointer = new MouseEvent_1.MouseEvent(MouseEvent_1.MouseEvent.POINTER_OVER);
            pointer.data = interactionData;
            this.dispatchEvent(pointer);
            if (event.pointerType === 'mouse' || event.pointerType === 'pen') {
                let pointer = new MouseEvent_1.MouseEvent(MouseEvent_1.MouseEvent.MOUSE_OVER);
                pointer.data = interactionData;
                this.dispatchEvent(pointer);
                this.dispatchEvent(pointer);
            }
        };
        this.onPointerOut = (originalEvent) => {
            if (this.supportsTouchEvents && originalEvent.pointerType === 'touch') {
                return;
            }
            let events = this.normalizeToPointerData(originalEvent);
            let event = events[0];
            if (event.pointerType === 'mouse') {
                this.mouseOverRenderer = false;
                this.setCursorMode(null);
            }
            let interactionData = this.getInteractionDataForPointerId(event);
            let interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);
            interactionEvent.data.originalEvent = event;
            this.processInteractive(interactionEvent, this.renderer._lastObjectRendered, this.processPointerOverOut, false);
            let pointer = new MouseEvent_1.MouseEvent(MouseEvent_1.MouseEvent.POINTER_OUT);
            pointer.data = interactionData;
            this.dispatchEvent(pointer);
            if (event.pointerType === 'mouse' || event.pointerType === 'pen') {
                let pointer = new MouseEvent_1.MouseEvent(MouseEvent_1.MouseEvent.MOUSE_OUT);
                pointer.data = interactionData;
                this.dispatchEvent(pointer);
            }
            else {
                this.releaseInteractionDataForPointerId(interactionData.identifier);
            }
        };
        this.onPointerDown = (originalEvent) => {
            if (this.supportsTouchEvents && originalEvent.pointerType === 'touch') {
                return;
            }
            let events = this.normalizeToPointerData(originalEvent);
            let event = events[0];
            if (this.autoPreventDefault && event.isNormalized) {
                let cancelable = originalEvent.cancelable || !('cancelable' in originalEvent);
                if (cancelable) {
                    originalEvent.preventDefault();
                }
            }
            let eventLen = events.length;
            for (let i = 0; i < eventLen; i++) {
                let event = events[i];
                let interactionData = this.getInteractionDataForPointerId(event);
                let interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);
                interactionEvent.data.originalEvent = originalEvent;
                let result = this.processInteractive(interactionEvent, this.renderer._lastObjectRendered, this.processPointerDown, true);
                let pointer = new MouseEvent_1.MouseEvent(MouseEvent_1.MouseEvent.POINTER_DOWN);
                pointer.data = interactionData;
                this.dispatchEvent(pointer);
                if (event.pointerType === 'touch') {
                    let pointer = new MouseEvent_1.MouseEvent(MouseEvent_1.MouseEvent.TOUCH_START);
                    pointer.data = interactionData;
                    this.dispatchEvent(pointer);
                }
                else if (event.pointerType === 'mouse' || event.pointerType === 'pen') {
                    let isRightButton = event.button === 2;
                    let pointer = new MouseEvent_1.MouseEvent(isRightButton ? MouseEvent_1.MouseEvent.RIGHT_MOUSE_DOWN : MouseEvent_1.MouseEvent.MOUSE_DOWN);
                    pointer.data = interactionData;
                    this.dispatchEvent(pointer);
                }
            }
        };
        this.onPointerMove = (originalEvent) => {
            if (this.supportsTouchEvents && originalEvent.pointerType === 'touch') {
                return;
            }
            let events = this.normalizeToPointerData(originalEvent);
            if (events[0].pointerType === 'mouse' || events[0].pointerType === 'pen') {
                this.didMove = true;
                this.cursor = null;
            }
            let eventLen = events.length;
            for (var i = 0; i < eventLen; i++) {
                let event = events[i];
                let interactionData = this.getInteractionDataForPointerId(event);
                let interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);
                interactionEvent.data.originalEvent = originalEvent;
                let interactive = event.pointerType === 'touch' ? this.moveWhenInside : true;
                this.processInteractive(interactionEvent, this.renderer._lastObjectRendered, this.processPointerMove, interactive);
                let pointer = new MouseEvent_1.MouseEvent(MouseEvent_1.MouseEvent.POINTER_MOVE);
                pointer.data = interactionData;
                this.dispatchEvent(pointer);
                if (event.pointerType === 'touch') {
                    let pointer = new MouseEvent_1.MouseEvent(MouseEvent_1.MouseEvent.TOUCH_MOVE);
                    pointer.data = interactionData;
                    this.dispatchEvent(pointer);
                }
                if (event.pointerType === 'mouse' || event.pointerType === 'pen') {
                    let pointer = new MouseEvent_1.MouseEvent(MouseEvent_1.MouseEvent.MOUSE_MOVE);
                    pointer.data = interactionData;
                    this.dispatchEvent(pointer);
                }
            }
            if (events[0].pointerType === 'mouse') {
                this.setCursorMode(this.cursor);
            }
        };
        this.processPointerDown = (interactionEvent, displayObject, hit) => {
            let data = interactionEvent.data;
            let id = interactionEvent.data.identifier;
            if (hit) {
                if (!displayObject.trackedPointers[id]) {
                    displayObject.trackedPointers[id] = new InteractionTrackingData_1.InteractionTrackingData(id);
                }
                let pointer = new MouseEvent_1.MouseEvent(MouseEvent_1.MouseEvent.POINTER_DOWN);
                pointer.data = data;
                displayObject.dispatchEvent(pointer);
                if (data.pointerType === 'touch') {
                    let pointer = new MouseEvent_1.MouseEvent(MouseEvent_1.MouseEvent.TOUCH_START);
                    pointer.data = data;
                    displayObject.dispatchEvent(pointer);
                }
                else if (data.pointerType === 'mouse' || data.pointerType === 'pen') {
                    let isRightButton = data.button === 2;
                    if (isRightButton) {
                        displayObject.trackedPointers[id].rightDown = true;
                    }
                    else {
                        displayObject.trackedPointers[id].leftDown = true;
                    }
                    let pointer = new MouseEvent_1.MouseEvent(isRightButton ? MouseEvent_1.MouseEvent.RIGHT_MOUSE_DOWN : MouseEvent_1.MouseEvent.MOUSE_DOWN);
                    pointer.data = data;
                    displayObject.dispatchEvent(pointer);
                }
            }
        };
        this.processPointerUp = (interactionEvent, displayObject, hit) => {
            let data = interactionEvent.data;
            let id = interactionEvent.data.identifier;
            let trackingData = displayObject.trackedPointers[id];
            let isTouch = data.pointerType === 'touch';
            let isMouse = (data.pointerType === 'mouse' || data.pointerType === 'pen');
            let isMouseTap = false;
            if (isMouse) {
                let isRightButton = data.button === 2;
                let flags = InteractionTrackingData_1.InteractionTrackingData.FLAGS;
                let test = isRightButton ? flags.RIGHT_DOWN : flags.LEFT_DOWN;
                let isDown = trackingData !== undefined && (trackingData.flags & test);
                if (hit) {
                    let pointer = new MouseEvent_1.MouseEvent(isRightButton ? MouseEvent_1.MouseEvent.RIGHT_MOUSE_UP : MouseEvent_1.MouseEvent.MOUSE_UP);
                    pointer.data = data;
                    displayObject.dispatchEvent(pointer);
                    if (isDown) {
                        let pointer = new MouseEvent_1.MouseEvent(isRightButton ? MouseEvent_1.MouseEvent.RIGHT_CLICK : MouseEvent_1.MouseEvent.CLICK);
                        pointer.data = data;
                        displayObject.dispatchEvent(pointer);
                        isMouseTap = true;
                    }
                }
                else if (isDown) {
                    let pointer = new MouseEvent_1.MouseEvent(isRightButton ? MouseEvent_1.MouseEvent.RIGHT_MOUSE_UP_OUTSIDE : MouseEvent_1.MouseEvent.MOUSE_UP_OUTSIDE);
                    pointer.data = data;
                    displayObject.dispatchEvent(pointer);
                }
                if (trackingData) {
                    if (isRightButton) {
                        trackingData.rightDown = false;
                    }
                    else {
                        trackingData.leftDown = false;
                    }
                }
            }
            if (hit) {
                let pointer = new MouseEvent_1.MouseEvent(MouseEvent_1.MouseEvent.POINTER_UP);
                pointer.data = data;
                displayObject.dispatchEvent(pointer);
                if (isTouch) {
                    let pointer = new MouseEvent_1.MouseEvent(MouseEvent_1.MouseEvent.TOUCH_END);
                    pointer.data = data;
                    displayObject.dispatchEvent(pointer);
                }
                if (trackingData) {
                    if (!isMouse || isMouseTap) {
                        let pointer = new MouseEvent_1.MouseEvent(MouseEvent_1.MouseEvent.POINTER_TAP);
                        pointer.data = data;
                        displayObject.dispatchEvent(pointer);
                    }
                    if (isTouch) {
                        let pointer = new MouseEvent_1.MouseEvent(MouseEvent_1.MouseEvent.TOUCH_TAP);
                        pointer.data = data;
                        displayObject.dispatchEvent(pointer);
                        trackingData.over = false;
                    }
                }
            }
            else if (trackingData) {
                let pointer = new MouseEvent_1.MouseEvent(MouseEvent_1.MouseEvent.POINTER_UP_OUTSIDE);
                pointer.data = data;
                displayObject.dispatchEvent(pointer);
                if (isTouch) {
                    let pointer = new MouseEvent_1.MouseEvent(MouseEvent_1.MouseEvent.TOUCH_END_OUTSIDE);
                    pointer.data = data;
                    displayObject.dispatchEvent(pointer);
                }
            }
            if (trackingData && trackingData.none) {
                delete displayObject.trackedPointers[id];
            }
        };
        this.processPointerMove = (interactionEvent, displayObject, hit) => {
            let data = interactionEvent.data;
            let isTouch = data.pointerType === 'touch';
            let isMouse = (data.pointerType === 'mouse' || data.pointerType === 'pen');
            if (isMouse) {
                this.processPointerOverOut(interactionEvent, displayObject, hit);
            }
            if (!this.moveWhenInside || hit) {
                let pointer = new MouseEvent_1.MouseEvent(MouseEvent_1.MouseEvent.POINTER_MOVE);
                pointer.data = data;
                displayObject.dispatchEvent(pointer);
                if (isTouch) {
                    let pointer = new MouseEvent_1.MouseEvent(MouseEvent_1.MouseEvent.TOUCH_MOVE);
                    pointer.data = data;
                    displayObject.dispatchEvent(pointer);
                }
                if (isMouse) {
                    let pointer = new MouseEvent_1.MouseEvent(MouseEvent_1.MouseEvent.MOUSE_MOVE);
                    pointer.data = data;
                    displayObject.dispatchEvent(pointer);
                }
            }
        };
        this.processPointerOverOut = (interactionEvent, displayObject, hit) => {
            let data = interactionEvent.data;
            let id = interactionEvent.data.identifier;
            let isMouse = (data.pointerType === 'mouse' || data.pointerType === 'pen');
            let trackingData = displayObject.trackedPointers[id];
            if (hit && !trackingData) {
                trackingData = displayObject.trackedPointers[id] = new InteractionTrackingData_1.InteractionTrackingData(id);
            }
            if (trackingData === undefined) {
                return;
            }
            if (hit && this.mouseOverRenderer) {
                if (!trackingData.over) {
                    trackingData.over = true;
                    let pointer = new MouseEvent_1.MouseEvent(MouseEvent_1.MouseEvent.POINTER_OVER);
                    pointer.data = data;
                    displayObject.dispatchEvent(pointer);
                    if (isMouse) {
                        let pointer = new MouseEvent_1.MouseEvent(MouseEvent_1.MouseEvent.MOUSE_OVER);
                        pointer.data = data;
                        displayObject.dispatchEvent(pointer);
                    }
                }
                if (isMouse && this.cursor === null) {
                    this.cursor = displayObject.cursor;
                }
            }
            else if (trackingData.over) {
                trackingData.over = false;
                let pointer = new MouseEvent_1.MouseEvent(MouseEvent_1.MouseEvent.POINTER_OUT);
                pointer.data = data;
                displayObject.dispatchEvent(pointer);
                if (isMouse) {
                    let pointer = new MouseEvent_1.MouseEvent(MouseEvent_1.MouseEvent.MOUSE_OUT);
                    pointer.data = data;
                    displayObject.dispatchEvent(pointer);
                }
                if (trackingData.none) {
                    delete displayObject.trackedPointers[id];
                }
            }
        };
        this.hitTestEvent = new InteractionEvent_1.InteractionEvent(null, null, null);
        this.hitTestEvent.target = null;
        this.renderer = renderer;
        this.autoPreventDefault = true;
        this.interactionFrequency = 10;
        this.mouse = new InteractionData_1.InteractionData();
        this.mouse.identifier = InteractionManager.MOUSE_POINTER_ID;
        this.mouse.global.set(-999999);
        this.activeInteractionData = {};
        this.activeInteractionData[InteractionManager.MOUSE_POINTER_ID] = this.mouse;
        this.interactionDataPool = [];
        this.eventData = new InteractionEvent_1.InteractionEvent("interaction");
        this.interactionDOMElement = null;
        this.moveWhenInside = false;
        this.eventsAdded = false;
        this.mouseOverRenderer = false;
        this.supportsTouchEvents = 'ontouchstart' in window;
        this.supportsPointerEvents = !!window['PointerEvent'];
        this.cursorStyles = {
            default: 'inherit',
            pointer: 'pointer'
        };
        this.currentCursorMode = null;
        this.cursor = null;
        this._tempPoint = Point_1.Point.getPoint();
        this.resolution = 1;
        this.setTargetElement(this.renderer.view, this.renderer.resolution);
    }
    destructor() {
        if (this._tempPoint) {
            this._tempPoint.destructor();
        }
        this._tempPoint = null;
    }
    setTargetElement(element, resolution = 1) {
        this.removeEvents();
        this.interactionDOMElement = element;
        this.resolution = resolution;
        this.addEvents();
    }
    ;
    removeEvents() {
        if (!this.interactionDOMElement) {
            return;
        }
        Ticker_1.Ticker.system.remove(this.update);
        if (window.navigator.msPointerEnabled) {
            this.interactionDOMElement.style['-ms-content-zooming'] = '';
            this.interactionDOMElement.style['-ms-touch-action'] = '';
        }
        else if (this.supportsPointerEvents) {
            this.interactionDOMElement.style['touch-action'] = '';
        }
        if (this.supportsPointerEvents) {
            window.document.removeEventListener('pointermove', this.onPointerMove);
            this.interactionDOMElement.removeEventListener('pointerdown', this.onPointerDown);
            this.interactionDOMElement.removeEventListener('pointerleave', this.onPointerOut);
            this.interactionDOMElement.removeEventListener('pointerover', this.onPointerOver);
            window.removeEventListener('pointercancel', this.onPointerCancel);
            window.removeEventListener('pointerup', this.onPointerUp);
        }
        else {
            window.document.removeEventListener('mousemove', this.onPointerMove);
            this.interactionDOMElement.removeEventListener('mousedown', this.onPointerDown);
            this.interactionDOMElement.removeEventListener('mouseout', this.onPointerOut);
            this.interactionDOMElement.removeEventListener('mouseover', this.onPointerOver);
            window.removeEventListener('mouseup', this.onPointerUp);
        }
        if (this.supportsTouchEvents) {
            this.interactionDOMElement.removeEventListener('touchstart', this.onPointerDown);
            this.interactionDOMElement.removeEventListener('touchcancel', this.onPointerCancel);
            this.interactionDOMElement.removeEventListener('touchend', this.onPointerUp);
            this.interactionDOMElement.removeEventListener('touchmove', this.onPointerMove);
        }
        this.interactionDOMElement = null;
        this.eventsAdded = false;
    }
    ;
    mapPositionToPoint(point, x, y) {
        let rect;
        if (!this.interactionDOMElement.parentElement) {
            InstanceCounter_1.InstanceCounter.addCall("Rectangle.getRectangle", "Interactionmanager mapPositionToPoint");
            rect = Rectangle_1.Rectangle.getRectangle();
        }
        else {
            rect = this.interactionDOMElement.getBoundingClientRect();
        }
        let resolutionMultiplier = 1.0 / this.resolution;
        point.x = ((x - rect.left) * (this.interactionDOMElement.width / rect.width)) * resolutionMultiplier;
        point.y = ((y - rect.top) * (this.interactionDOMElement.height / rect.height)) * resolutionMultiplier;
        if (rect instanceof Rectangle_1.Rectangle) {
            rect.recycle();
        }
    }
    ;
    configureInteractionEventForDOMEvent(interactionEvent, pointerEvent, interactionData) {
        interactionEvent.data = interactionData;
        this.mapPositionToPoint(interactionData.global, pointerEvent.clientX, pointerEvent.clientY);
        if (pointerEvent.pointerType === 'touch') {
            pointerEvent.globalX = interactionData.global.x;
            pointerEvent.globalY = interactionData.global.y;
        }
        interactionData.originalEvent = pointerEvent;
        interactionEvent.reset();
        return interactionEvent;
    }
    ;
    addEvents() {
        if (!this.interactionDOMElement) {
            return;
        }
        Ticker_1.Ticker.system.add(this.update, this, Ticker_1.Ticker.UPDATE_PRIORITY.INTERACTION);
        if (window.navigator.msPointerEnabled) {
            this.interactionDOMElement.style['-ms-content-zooming'] = 'none';
            this.interactionDOMElement.style['-ms-touch-action'] = 'none';
        }
        else if (this.supportsPointerEvents) {
            this.interactionDOMElement.style['touch-action'] = 'none';
        }
        if (this.supportsPointerEvents) {
            window.document.addEventListener('pointermove', this.onPointerMove);
            this.interactionDOMElement.addEventListener('pointerdown', this.onPointerDown);
            this.interactionDOMElement.addEventListener('pointerleave', this.onPointerOut);
            this.interactionDOMElement.addEventListener('pointerover', this.onPointerOver);
            window.addEventListener('pointercancel', this.onPointerCancel);
            window.addEventListener('pointerup', this.onPointerUp);
        }
        else {
            window.document.addEventListener('mousemove', this.onPointerMove);
            this.interactionDOMElement.addEventListener('mousedown', this.onPointerDown);
            this.interactionDOMElement.addEventListener('mouseout', this.onPointerOut);
            this.interactionDOMElement.addEventListener('mouseover', this.onPointerOver);
            window.addEventListener('mouseup', this.onPointerUp);
        }
        if (this.supportsTouchEvents) {
            this.interactionDOMElement.addEventListener('touchstart', this.onPointerDown);
            this.interactionDOMElement.addEventListener('touchcancel', this.onPointerCancel);
            this.interactionDOMElement.addEventListener('touchend', this.onPointerUp);
            this.interactionDOMElement.addEventListener('touchmove', this.onPointerMove);
        }
        this.eventsAdded = true;
    }
    ;
    processInteractive(interactionEvent, displayObject, func, hitTest, interactive = true) {
        if (!displayObject || !displayObject.visible) {
            return false;
        }
        let point = interactionEvent.data.global;
        interactive = displayObject.interactive || interactive;
        let hit = false;
        let interactiveParent = interactive;
        let hitTestChildren = true;
        if (displayObject.hitArea) {
            if (hitTest) {
                displayObject.worldTransform.applyInverse(point, this._tempPoint);
                if (!displayObject.hitArea.contains(this._tempPoint.x, this._tempPoint.y)) {
                    hitTest = false;
                    hitTestChildren = false;
                }
                else {
                    hit = true;
                }
            }
            interactiveParent = false;
        }
        else if (displayObject._mask) {
            if (hitTest) {
                if (!(displayObject._mask.containsPoint && displayObject._mask.containsPoint(point))) {
                    hitTest = false;
                    hitTestChildren = false;
                }
            }
        }
        if (displayObject instanceof Container_1.Container) {
            if (hitTestChildren && displayObject.interactiveChildren && displayObject.children) {
                let children = displayObject.children;
                for (let i = children.length - 1; i >= 0; i--) {
                    let child = children[i];
                    let childHit = this.processInteractive(interactionEvent, child, func, hitTest, interactiveParent);
                    if (childHit) {
                        if (!child.parent) {
                            continue;
                        }
                        interactiveParent = false;
                        if (childHit) {
                            if (interactionEvent.target) {
                                hitTest = false;
                            }
                            hit = true;
                        }
                    }
                }
            }
        }
        if (interactive) {
            if (hitTest && !interactionEvent.target) {
                if (!displayObject.hitArea && displayObject.containsPoint) {
                    if (displayObject.containsPoint(point)) {
                        hit = true;
                    }
                }
            }
            if (displayObject.interactive) {
                if (hit && !interactionEvent.target) {
                    interactionEvent.target = displayObject;
                }
                if (func) {
                    func(interactionEvent, displayObject, !!hit);
                }
            }
        }
        return hit;
    }
    ;
    setCursorMode(mode = "default") {
        if (this.currentCursorMode === mode) {
            return;
        }
        this.currentCursorMode = mode;
        let style = this.cursorStyles[mode];
        if (style) {
            switch (typeof style) {
                case 'string':
                    this.interactionDOMElement.style.cursor = style;
                    break;
                case 'function':
                    style(mode);
                    break;
                case 'object':
                    Object.assign(this.interactionDOMElement.style, style);
                    break;
            }
        }
        else if (typeof mode === 'string' && !Object.prototype.hasOwnProperty.call(this.cursorStyles, mode)) {
            this.interactionDOMElement.style.cursor = mode;
        }
    }
    ;
    hitTest(globalPoint, root) {
        this.hitTestEvent.target = null;
        this.hitTestEvent.data.global = globalPoint;
        let currentdisplay;
        if (root) {
            currentdisplay = root;
        }
        else {
            currentdisplay = this.renderer._lastObjectRendered;
        }
        this.processInteractive(this.hitTestEvent, currentdisplay, null, true);
        return this.hitTestEvent.target;
    }
    ;
    normalizeToPointerData(event) {
        let normalizedEvents = [];
        if (this.supportsTouchEvents && event instanceof TouchEvent) {
            for (let i = 0, li = event.changedTouches.length; i < li; i++) {
                let touch = event.changedTouches[i];
                if (typeof touch.button === 'undefined') {
                    touch.button = event.touches.length ? 1 : 0;
                }
                if (typeof touch.buttons === 'undefined') {
                    touch.buttons = event.touches.length ? 1 : 0;
                }
                if (typeof touch.isPrimary === 'undefined') {
                    touch.isPrimary = event.touches.length === 1 && event.type === 'touchstart';
                }
                if (typeof touch.width === 'undefined') {
                    touch.width = touch.radiusX || 1;
                }
                if (typeof touch.height === 'undefined') {
                    touch.height = touch.radiusY || 1;
                }
                if (typeof touch.tiltX === 'undefined') {
                    touch.tiltX = 0;
                }
                if (typeof touch.tiltY === 'undefined') {
                    touch.tiltY = 0;
                }
                if (typeof touch.pointerType === 'undefined') {
                    touch.pointerType = 'touch';
                }
                if (typeof touch.pointerId === 'undefined') {
                    touch.pointerId = touch.identifier || 0;
                }
                if (typeof touch.pressure === 'undefined') {
                    touch.pressure = touch.force || 0.5;
                }
                if (typeof touch.twist === 'undefined') {
                    touch.twist = 0;
                }
                if (typeof touch.tangentialPressure === 'undefined') {
                    touch.tangentialPressure = 0;
                }
                if (typeof touch.layerX === 'undefined') {
                    touch.layerX = touch.offsetX = touch.clientX;
                }
                if (typeof touch.layerY === 'undefined') {
                    touch.layerY = touch.offsetY = touch.clientY;
                }
                touch.isNormalized = true;
                normalizedEvents.push(touch);
            }
        }
        else if (event instanceof MouseEvent_1.MouseEvent && (!this.supportsPointerEvents || !(event instanceof window['PointerEvent']))) {
            let originevent = event;
            if (typeof originevent.isPrimary === 'undefined') {
                originevent.isPrimary = true;
            }
            if (typeof originevent.width === 'undefined') {
                originevent.width = 1;
            }
            if (typeof originevent.height === 'undefined') {
                originevent.height = 1;
            }
            if (typeof originevent.tiltX === 'undefined') {
                originevent.tiltX = 0;
            }
            if (typeof originevent.tiltY === 'undefined') {
                originevent.tiltY = 0;
            }
            if (typeof originevent.pointerType === 'undefined') {
                originevent.pointerType = 'mouse';
            }
            if (typeof originevent.pointerId === 'undefined') {
                originevent.pointerId = InteractionManager.MOUSE_POINTER_ID;
            }
            if (typeof originevent.pressure === 'undefined') {
                originevent.pressure = 0.5;
            }
            if (typeof originevent.twist === 'undefined') {
                originevent.twist = 0;
            }
            if (typeof originevent.tangentialPressure === 'undefined') {
                originevent.tangentialPressure = 0;
            }
            originevent.isNormalized = true;
            normalizedEvents.push(event);
        }
        else {
            normalizedEvents.push(event);
        }
        return normalizedEvents;
    }
    ;
    getInteractionDataForPointerId(event) {
        let pointerId = event.pointerId;
        let interactionData;
        if (pointerId === InteractionManager.MOUSE_POINTER_ID || event.pointerType === 'mouse') {
            interactionData = this.mouse;
        }
        else if (this.activeInteractionData[pointerId]) {
            interactionData = this.activeInteractionData[pointerId];
        }
        else {
            interactionData = this.interactionDataPool.pop() || new InteractionData_1.InteractionData();
            interactionData.identifier = pointerId;
            this.activeInteractionData[pointerId] = interactionData;
        }
        interactionData.copyEvent(event);
        return interactionData;
    }
    ;
    onPointerComplete(originalEvent, cancelled, func) {
        let events = this.normalizeToPointerData(originalEvent);
        let eventLen = events.length;
        let eventAppend = originalEvent.target !== this.interactionDOMElement ? 'outside' : '';
        for (let i = 0; i < eventLen; i++) {
            let event = events[i];
            let interactionData = this.getInteractionDataForPointerId(event);
            let interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);
            interactionEvent.data.originalEvent = originalEvent;
            this.processInteractive(interactionEvent, this.renderer._lastObjectRendered, func, cancelled || !eventAppend);
            let pointer = new MouseEvent_1.MouseEvent(cancelled ? MouseEvent_1.MouseEvent.POINTER_CANCEL : (MouseEvent_1.MouseEvent.POINTER_UP));
            pointer.data = interactionData;
            this.dispatchEvent(pointer);
            if (event.pointerType === 'mouse' || event.pointerType === 'pen') {
                let isRightButton = event.button === 2;
                let pointer = new MouseEvent_1.MouseEvent(isRightButton ? (MouseEvent_1.MouseEvent.RIGHT_MOUSE_UP) : (MouseEvent_1.MouseEvent.MOUSE_UP));
                pointer.data = interactionData;
                this.dispatchEvent(pointer);
            }
            else if (event.pointerType === 'touch') {
                let pointer = new MouseEvent_1.MouseEvent(cancelled ? MouseEvent_1.MouseEvent.TOUCH_CANCEL : (MouseEvent_1.MouseEvent.TOUCH_END));
                pointer.data = interactionData;
                this.dispatchEvent(pointer);
                this.releaseInteractionDataForPointerId(event.pointerId);
            }
        }
    }
    ;
    releaseInteractionDataForPointerId(pointerId) {
        let interactionData = this.activeInteractionData[pointerId];
        if (interactionData) {
            delete this.activeInteractionData[pointerId];
            interactionData.reset();
            this.interactionDataPool.push(interactionData);
        }
    }
    ;
    processPointerCancel(interactionEvent, displayObject) {
        let data = interactionEvent.data;
        let id = interactionEvent.data.identifier;
        if (displayObject.trackedPointers[id] !== undefined) {
            delete displayObject.trackedPointers[id];
            let pointer = new MouseEvent_1.MouseEvent(MouseEvent_1.MouseEvent.POINTER_CANCEL);
            pointer.data = data;
            displayObject.dispatchEvent(pointer);
            if (data.pointerType === 'touch') {
                let pointer = new MouseEvent_1.MouseEvent(MouseEvent_1.MouseEvent.TOUCH_CANCEL);
                pointer.data = data;
                displayObject.dispatchEvent(pointer);
            }
        }
    }
    ;
    destroy(options = null) {
        this.removeEvents();
        this.renderer = null;
        this.mouse = null;
        this.eventData = null;
        this.interactionDOMElement = null;
        this.onPointerDown = null;
        this.processPointerDown = null;
        this.onPointerUp = null;
        this.processPointerUp = null;
        this.onPointerCancel = null;
        this.processPointerCancel = null;
        this.onPointerMove = null;
        this.processPointerMove = null;
        this.onPointerOut = null;
        this.processPointerOverOut = null;
        this.onPointerOver = null;
        this._tempPoint = null;
    }
    ;
}
InteractionManager.MOUSE_POINTER_ID = 1;
exports.InteractionManager = InteractionManager;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/InteractionTrackingData.js":
/*!***********************************************************!*\
  !*** ./js-compile/raw-pixi-ts/InteractionTrackingData.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class InteractionTrackingData {
    constructor(pointerId) {
        this._pointerId = pointerId;
        this._flags = InteractionTrackingData.FLAGS.NONE;
    }
    _doSet(flag, yn) {
        if (yn) {
            this._flags = this._flags | flag;
        }
        else {
            this._flags = this._flags & (~flag);
        }
    }
    ;
    get pointerId() {
        return this._pointerId;
    }
    ;
    get flags() {
        return this._flags;
    }
    ;
    set flags(flags) {
        this._flags = flags;
    }
    ;
    get none() {
        return this._flags === InteractionTrackingData.FLAGS.NONE;
    }
    ;
    get over() {
        return (this._flags & InteractionTrackingData.FLAGS.OVER) !== 0;
    }
    ;
    set over(yn) {
        this._doSet(InteractionTrackingData.FLAGS.OVER, yn);
    }
    ;
    get rightDown() {
        return (this._flags & InteractionTrackingData.FLAGS.RIGHT_DOWN) !== 0;
    }
    ;
    set rightDown(yn) {
        this._doSet(InteractionTrackingData.FLAGS.RIGHT_DOWN, yn);
    }
    ;
    get leftDown() {
        return (this._flags & InteractionTrackingData.FLAGS.LEFT_DOWN) !== 0;
    }
    ;
    set leftDown(yn) {
        this._doSet(InteractionTrackingData.FLAGS.LEFT_DOWN, yn);
    }
    ;
}
InteractionTrackingData.FLAGS = {
    NONE: 0,
    OVER: 1 << 0,
    LEFT_DOWN: 1 << 1,
    RIGHT_DOWN: 1 << 2,
};
exports.InteractionTrackingData = InteractionTrackingData;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/LineStyle.js":
/*!*********************************************!*\
  !*** ./js-compile/raw-pixi-ts/LineStyle.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const FillStyle_1 = __webpack_require__(/*! ./FillStyle */ "./js-compile/raw-pixi-ts/FillStyle.js");
class LineStyle extends FillStyle_1.FillStyle {
    constructor() {
        super();
    }
    clone() {
        var obj = new LineStyle();
        obj.color = this.color;
        obj.alpha = this.alpha;
        obj.texture = this.texture;
        obj.matrix = this.matrix;
        obj.visible = this.visible;
        obj.width = this.width;
        obj.alignment = this.alignment;
        obj.native = this.native;
        return obj;
    }
    ;
    /**
     * Reset the line style to default.
     */
    reset() {
        super.reset();
        // Override default line style color
        this.color = 0x0;
        /**
         * The width (thickness) of any lines drawn.
         *
         * @member {number}
         * @default 0
         */
        this.width = 0;
        /**
         * The alignment of any lines drawn (0.5 = middle, 1 = outter, 0 = inner).
         *
         * @member {number}
         * @default 0
         */
        this.alignment = 0.5;
        /**
         * If true the lines will be draw using LINES instead of TRIANGLE_STRIP
         *
         * @member {boolean}
         * @default false
         */
        this.native = false;
    }
    ;
}
exports.LineStyle = LineStyle;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/Logger.js":
/*!******************************************!*\
  !*** ./js-compile/raw-pixi-ts/Logger.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.OUTPUT_TO_CONSOLE = true;
exports.trace = function (value) {
    try {
        if (!value) {
            if (isNaN(value)) {
                var result = "show: null";
            }
            else {
                var result = "show: 0";
            }
        }
        else {
            var result = "show: " + value.toString();
        }
        if (exports.OUTPUT_TO_CONSOLE) {
            console.log(result);
        }
        return result;
    }
    catch (e) {
    }
    return null;
};
exports.revealMethods = function (value) {
    try {
        if (!value) {
            var result = "reveal methods: null";
        }
        else {
            var result = "reveal methods: ";
        }
        for (var key in value) {
            var instanceItem = value[key];
            if (instanceItem instanceof Function) {
                result += 'method: ' + key + ' : ' + value[key] + "\n";
            }
        }
        if (exports.OUTPUT_TO_CONSOLE) {
            console.log(result);
        }
        return result;
    }
    catch (e) {
    }
    return null;
};
exports.reveal = function (value) {
    if (!value) {
        var result = "reveal: null";
        if (exports.OUTPUT_TO_CONSOLE) {
            console.log(result);
        }
        return;
    }
    if (value === undefined) {
        var result = "reveal: undefined";
        if (exports.OUTPUT_TO_CONSOLE) {
            console.log(result);
        }
        return;
    }
    var result = "reveal: ";
    for (var key in value) {
        var instanceItem = getValue(key, value);
        if (instanceItem) {
            if (instanceItem instanceof Function) {
                result += 'method: ' + key + "\n";
            }
            else {
                try {
                    result += key + ' : ' + instanceItem + "\n";
                }
                catch (e) {
                }
            }
        }
    }
    if (exports.OUTPUT_TO_CONSOLE) {
        console.log(result);
    }
    return result;
};
const getValue = function (key, value) {
    var valueResult = null;
    try {
        valueResult = value[key];
    }
    catch (e) {
    }
    return valueResult;
};


/***/ }),

/***/ "./js-compile/raw-pixi-ts/MaskSystem.js":
/*!**********************************************!*\
  !*** ./js-compile/raw-pixi-ts/MaskSystem.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const System_1 = __webpack_require__(/*! ./System */ "./js-compile/raw-pixi-ts/System.js");
const SpriteMaskFilter_1 = __webpack_require__(/*! ./SpriteMaskFilter */ "./js-compile/raw-pixi-ts/SpriteMaskFilter.js");
class MaskSystem extends System_1.System {
    constructor(renderer) {
        super(renderer);
        // TODO - we don't need both!
        /**
         * `true` if current pushed masked is scissor
         * @member {boolean}
         * @readonly
         */
        this.scissor = false;
        /**
         * Mask data
         * @member {PIXI.Graphics}
         * @readonly
         */
        this.scissorData = null;
        /**
         * Target to mask
         * @member {PIXI.DisplayObject}
         * @readonly
         */
        this.scissorRenderTarget = null;
        /**
         * Enable scissor
         * @member {boolean}
         * @readonly
         */
        this.enableScissor = false;
        /**
         * Pool of used sprite mask filters
         * @member {PIXI.SpriteMaskFilter[]}
         * @readonly
         */
        this.alphaMaskPool = [];
        /**
         * Current index of alpha mask pool
         * @member {number}
         * @default 0
         * @readonly
         */
        this.alphaMaskIndex = 0;
    }
    /**
     * Applies the Mask and adds it to the current filter stack.
     *
     * @param {PIXI.DisplayObject} target - Display Object to push the mask to
     * @param {PIXI.Sprite|PIXI.Graphics} maskData - The masking data.
     */
    push(target, maskData) {
        // TODO the root check means scissor rect will not
        // be used on render textures more info here:
        // https://github.com/pixijs/pixi.js/pull/3545
        if (maskData.isSprite) {
            this.pushSpriteMask(target, maskData);
        }
        else if (this.enableScissor
            && !this.scissor
            && this.renderer._activeRenderTarget.root
            && !this.renderer.stencil.stencilMaskStack.length
            && maskData.isFastRect()) {
            var matrix = maskData.worldTransform;
            var rot = Math.atan2(matrix.b, matrix.a);
            // use the nearest degree!
            rot = Math.round(rot * (180 / Math.PI));
            if (rot % 90) {
                this.pushStencilMask(maskData);
            }
            else {
                this.pushScissorMask(target, maskData);
            }
        }
        else {
            this.pushStencilMask(maskData);
        }
    }
    ;
    /**
     * Removes the last mask from the mask stack and doesn't return it.
     *
     * @param {PIXI.DisplayObject} target - Display Object to pop the mask from
     * @param {PIXI.Sprite|PIXI.Graphics} maskData - The masking data.
     */
    pop(target, maskData) {
        if (maskData.isSprite) {
            this.popSpriteMask(target, maskData);
        }
        else if (this.enableScissor && !this.renderer.stencil.stencilMaskStack.length) {
            this.popScissorMask(target, maskData);
        }
        else {
            this.popStencilMask(target, maskData);
        }
    }
    ;
    /**
     * Applies the Mask and adds it to the current filter stack.
     *
     * @param {PIXI.RenderTexture} target - Display Object to push the sprite mask to
     * @param {PIXI.Sprite} maskData - Sprite to be used as the mask
     */
    pushSpriteMask(target, maskData) {
        var alphaMaskFilter = this.alphaMaskPool[this.alphaMaskIndex];
        if (!alphaMaskFilter) {
            alphaMaskFilter = this.alphaMaskPool[this.alphaMaskIndex] = [new SpriteMaskFilter_1.SpriteMaskFilter(maskData)];
        }
        alphaMaskFilter[0].resolution = this.renderer.resolution;
        alphaMaskFilter[0].maskSprite = maskData;
        var stashFilterArea = target.filterArea;
        target.filterArea = maskData.getBounds(true);
        this.renderer.filter.push(target, alphaMaskFilter);
        target.filterArea = stashFilterArea;
        this.alphaMaskIndex++;
    }
    ;
    /**
     * Removes the last filter from the filter stack and doesn't return it.
     *
     */
    popSpriteMask(a, b) {
        this.renderer.filter.pop();
        this.alphaMaskIndex--;
    }
    ;
    /**
     * Applies the Mask and adds it to the current filter stack.
     *
     * @param {PIXI.Sprite|PIXI.Graphics} maskData - The masking data.
     */
    pushStencilMask(maskData) {
        this.renderer.batch.flush();
        this.renderer.stencil.pushStencil(maskData);
    }
    ;
    /**
     * Removes the last filter from the filter stack and doesn't return it.
     *
     */
    popStencilMask(a, b) {
        // this.renderer.currentRenderer.stop();
        this.renderer.stencil.popStencil();
    }
    ;
    /**
     *
     * @param {PIXI.DisplayObject} target - Display Object to push the mask to
     * @param {PIXI.Graphics} maskData - The masking data.
     */
    pushScissorMask(target, maskData) {
        maskData.renderable = true;
        var renderTarget = this.renderer._activeRenderTarget;
        var bounds = maskData.getBounds();
        bounds.fit(renderTarget.size);
        maskData.renderable = false;
        this.renderer.gl.enable(this.renderer.gl.SCISSOR_TEST);
        var resolution = this.renderer.resolution;
        this.renderer.gl.scissor(bounds.x * resolution, (renderTarget.root ? renderTarget.size.height - bounds.y - bounds.height : bounds.y) * resolution, bounds.width * resolution, bounds.height * resolution);
        this.scissorRenderTarget = renderTarget;
        this.scissorData = maskData;
        this.scissor = true;
    }
    ;
    /**
     * Pop scissor mask
     *
     */
    popScissorMask(a, b) {
        this.scissorRenderTarget = null;
        this.scissorData = null;
        this.scissor = false;
        // must be scissor!
        var ref = this.renderer;
        var gl = ref.gl;
        gl.disable(gl.SCISSOR_TEST);
    }
    ;
}
exports.MaskSystem = MaskSystem;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/MathSettings.js":
/*!************************************************!*\
  !*** ./js-compile/raw-pixi-ts/MathSettings.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class MathSettings {
    static uid() {
        return ++MathSettings.nextUid;
    }
    static sign(n) {
        if (n === 0) {
            return 0;
        }
        return n < 0 ? -1 : 1;
    }
    static string2hex(string) {
        if (typeof string === 'string' && string[0] === '#') {
            string = string.substr(1);
        }
        return parseInt(string, 16);
    }
    static hex2string(hex) {
        hex = hex.toString(16);
        hex = '000000'.substr(0, 6 - hex.length) + hex;
        return ("#" + hex);
    }
    static log2(v) {
        var r = (v > 0xFFFF) << 4;
        v >>>= r;
        var shift = (v > 0xFF) << 3;
        v >>>= shift;
        r |= shift;
        shift = (v > 0xF) << 2;
        v >>>= shift;
        r |= shift;
        shift = (v > 0x3) << 1;
        v >>>= shift;
        r |= shift;
        return r | (v >> 1);
    }
    static nextPow2(v) {
        v += v === 0;
        --v;
        v |= v >>> 1;
        v |= v >>> 2;
        v |= v >>> 4;
        v |= v >>> 8;
        v |= v >>> 16;
        return v + 1;
    }
    static isPow2(v) {
        return !(v & (v - 1)) && (!!v);
    }
}
MathSettings.nextUid = 0;
MathSettings.PI_2 = Math.PI * 2;
MathSettings.RAD_TO_DEG = 180 / Math.PI;
MathSettings.DEG_TO_RAD = Math.PI / 180;
exports.MathSettings = MathSettings;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/Matrix.js":
/*!******************************************!*\
  !*** ./js-compile/raw-pixi-ts/Matrix.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Point_1 = __webpack_require__(/*! ../flash/geom/Point */ "./js-compile/flash/geom/Point.js");
const MathSettings_1 = __webpack_require__(/*! ./MathSettings */ "./js-compile/raw-pixi-ts/MathSettings.js");
const FlashBaseObject_1 = __webpack_require__(/*! ./FlashBaseObject */ "./js-compile/raw-pixi-ts/FlashBaseObject.js");
class Matrix extends FlashBaseObject_1.FlashBaseObject {
    constructor(a = 1, b = 0, c = 0, d = 1, tx = 0, ty = 0) {
        super();
        if (a === void 0) {
            a = 1;
        }
        if (b === void 0) {
            b = 0;
        }
        if (c === void 0) {
            c = 0;
        }
        if (d === void 0) {
            d = 1;
        }
        if (tx === void 0) {
            tx = 0;
        }
        if (ty === void 0) {
            ty = 0;
        }
        /**
         * @member {number}
         * @default 1
         */
        this.a = a;
        /**
         * @member {number}
         * @default 0
         */
        this.b = b;
        /**
         * @member {number}
         * @default 0
         */
        this.c = c;
        /**
         * @member {number}
         * @default 1
         */
        this.d = d;
        /**
         * @member {number}
         * @default 0
         */
        this.tx = tx;
        /**
         * @member {number}
         * @default 0
         */
        this.ty = ty;
        this.array = null;
    }
    /**
     * Creates a Matrix object based on the given array. The Element to Matrix mapping order is as follows:
     *
     * a = array[0]
     * b = array[1]
     * c = array[3]
     * d = array[4]
     * tx = array[2]
     * ty = array[5]
     *
     * @param {number[]} array - The array that the matrix will be populated from.
     */
    fromArray(array) {
        this.a = array[0];
        this.b = array[1];
        this.c = array[3];
        this.d = array[4];
        this.tx = array[2];
        this.ty = array[5];
    }
    ;
    /**
     * sets the matrix properties
     *
     * @param {number} a - Matrix component
     * @param {number} b - Matrix component
     * @param {number} c - Matrix component
     * @param {number} d - Matrix component
     * @param {number} tx - Matrix component
     * @param {number} ty - Matrix component
     *
     * @return {PIXI.Matrix} This matrix. Good for chaining method calls.
     */
    set(a, b, c, d, tx, ty) {
        this.a = a;
        this.b = b;
        this.c = c;
        this.d = d;
        this.tx = tx;
        this.ty = ty;
        return this;
    }
    ;
    /**
     * Creates an array from the current Matrix object.
     *
     * @param {boolean} transpose - Whether we need to transpose the matrix or not
     * @param {Float32Array} [out=new Float32Array(9)] - If provided the array will be assigned to out
     * @return {number[]} the newly created array which contains the matrix
     */
    toArray(transpose, out = null) {
        if (!this.array) {
            this.array = new Float32Array(9);
        }
        var array = out || this.array;
        if (transpose) {
            array[0] = this.a;
            array[1] = this.b;
            array[2] = 0;
            array[3] = this.c;
            array[4] = this.d;
            array[5] = 0;
            array[6] = this.tx;
            array[7] = this.ty;
            array[8] = 1;
        }
        else {
            array[0] = this.a;
            array[1] = this.c;
            array[2] = this.tx;
            array[3] = this.b;
            array[4] = this.d;
            array[5] = this.ty;
            array[6] = 0;
            array[7] = 0;
            array[8] = 1;
        }
        return array;
    }
    ;
    /**
     * Get a new position with the current transformation applied.
     * Can be used to go from a child's coordinate space to the world coordinate space. (e.g. rendering)
     *
     * @param {PIXI.Point} pos - The origin
     * @param {PIXI.Point} [newPos] - The point that the new position is assigned to (allowed to be same as input)
     * @return {PIXI.Point} The new point, transformed through this matrix
     */
    apply(pos, newPos) {
        newPos = newPos;
        if (!newPos) {
            newPos = Point_1.Point.getPoint();
        }
        var x = pos.x;
        var y = pos.y;
        newPos.x = (this.a * x) + (this.c * y) + this.tx;
        newPos.y = (this.b * x) + (this.d * y) + this.ty;
        return newPos;
    }
    ;
    /**
     * Get a new position with the inverse of the current transformation applied.
     * Can be used to go from the world coordinate space to a child's coordinate space. (e.g. input)
     *
     * @param {PIXI.Point} pos - The origin
     * @param {PIXI.Point} [newPos] - The point that the new position is assigned to (allowed to be same as input)
     * @return {PIXI.Point} The new point, inverse-transformed through this matrix
     */
    applyInverse(pos, newPos) {
        newPos = newPos;
        if (!newPos) {
            newPos = Point_1.Point.getPoint();
        }
        var id = 1 / ((this.a * this.d) + (this.c * -this.b));
        var x = pos.x;
        var y = pos.y;
        newPos.x = (this.d * id * x) + (-this.c * id * y) + (((this.ty * this.c) - (this.tx * this.d)) * id);
        newPos.y = (this.a * id * y) + (-this.b * id * x) + (((-this.ty * this.a) + (this.tx * this.b)) * id);
        return newPos;
    }
    ;
    /**
     * Translates the matrix on the x and y.
     *
     * @param {number} x How much to translate x by
     * @param {number} y How much to translate y by
     * @return {PIXI.Matrix} This matrix. Good for chaining method calls.
     */
    translate(x, y) {
        this.tx += x;
        this.ty += y;
        return this;
    }
    ;
    /**
     * Applies a scale transformation to the matrix.
     *
     * @param {number} x The amount to scale horizontally
     * @param {number} y The amount to scale vertically
     * @return {PIXI.Matrix} This matrix. Good for chaining method calls.
     */
    scale(x, y) {
        this.a *= x;
        this.d *= y;
        this.c *= x;
        this.b *= y;
        this.tx *= x;
        this.ty *= y;
        return this;
    }
    ;
    /**
     * Applies a rotation transformation to the matrix.
     *
     * @param {number} angle - The angle in radians.
     * @return {PIXI.Matrix} This matrix. Good for chaining method calls.
     */
    rotate(angle) {
        var cos = Math.cos(angle);
        var sin = Math.sin(angle);
        var a1 = this.a;
        var c1 = this.c;
        var tx1 = this.tx;
        this.a = (a1 * cos) - (this.b * sin);
        this.b = (a1 * sin) + (this.b * cos);
        this.c = (c1 * cos) - (this.d * sin);
        this.d = (c1 * sin) + (this.d * cos);
        this.tx = (tx1 * cos) - (this.ty * sin);
        this.ty = (tx1 * sin) + (this.ty * cos);
        return this;
    }
    ;
    /**
     * Appends the given Matrix to this Matrix.
     *
     * @param {PIXI.Matrix} matrix - The matrix to append.
     * @return {PIXI.Matrix} This matrix. Good for chaining method calls.
     */
    append(matrix) {
        var a1 = this.a;
        var b1 = this.b;
        var c1 = this.c;
        var d1 = this.d;
        this.a = (matrix.a * a1) + (matrix.b * c1);
        this.b = (matrix.a * b1) + (matrix.b * d1);
        this.c = (matrix.c * a1) + (matrix.d * c1);
        this.d = (matrix.c * b1) + (matrix.d * d1);
        this.tx = (matrix.tx * a1) + (matrix.ty * c1) + this.tx;
        this.ty = (matrix.tx * b1) + (matrix.ty * d1) + this.ty;
        return this;
    }
    ;
    /**
     * Sets the matrix based on all the available properties
     *
     * @param {number} x - Position on the x axis
     * @param {number} y - Position on the y axis
     * @param {number} pivotX - Pivot on the x axis
     * @param {number} pivotY - Pivot on the y axis
     * @param {number} scaleX - Scale on the x axis
     * @param {number} scaleY - Scale on the y axis
     * @param {number} rotation - Rotation in radians
     * @param {number} skewX - Skew on the x axis
     * @param {number} skewY - Skew on the y axis
     * @return {PIXI.Matrix} This matrix. Good for chaining method calls.
     */
    setTransform(x, y, pivotX, pivotY, scaleX, scaleY, rotation, skewX, skewY) {
        this.a = Math.cos(rotation + skewY) * scaleX;
        this.b = Math.sin(rotation + skewY) * scaleX;
        this.c = -Math.sin(rotation - skewX) * scaleY;
        this.d = Math.cos(rotation - skewX) * scaleY;
        this.tx = x - ((pivotX * this.a) + (pivotY * this.c));
        this.ty = y - ((pivotX * this.b) + (pivotY * this.d));
        return this;
    }
    ;
    /**
     * Prepends the given Matrix to this Matrix.
     *
     * @param {PIXI.Matrix} matrix - The matrix to prepend
     * @return {PIXI.Matrix} This matrix. Good for chaining method calls.
     */
    prepend(matrix) {
        var tx1 = this.tx;
        if (matrix.a !== 1 || matrix.b !== 0 || matrix.c !== 0 || matrix.d !== 1) {
            var a1 = this.a;
            var c1 = this.c;
            this.a = (a1 * matrix.a) + (this.b * matrix.c);
            this.b = (a1 * matrix.b) + (this.b * matrix.d);
            this.c = (c1 * matrix.a) + (this.d * matrix.c);
            this.d = (c1 * matrix.b) + (this.d * matrix.d);
        }
        this.tx = (tx1 * matrix.a) + (this.ty * matrix.c) + matrix.tx;
        this.ty = (tx1 * matrix.b) + (this.ty * matrix.d) + matrix.ty;
        return this;
    }
    ;
    /**
     * Decomposes the matrix (x, y, scaleX, scaleY, and rotation) and sets the properties on to a transform.
     *
     * @param {PIXI.Transform} transform - The transform to apply the properties to.
     * @return {PIXI.Transform} The transform with the newly applied properties
     */
    decompose(transform) {
        // sort out rotation / skew..
        var a = this.a;
        var b = this.b;
        var c = this.c;
        var d = this.d;
        var skewX = -Math.atan2(-c, d);
        var skewY = Math.atan2(b, a);
        var delta = Math.abs(skewX + skewY);
        if (delta < 0.00001 || Math.abs(MathSettings_1.MathSettings.PI_2 - delta) < 0.00001) {
            transform.rotation = skewY;
            transform.skew.x = transform.skew.y = 0;
        }
        else {
            transform.rotation = 0;
            transform.skew.x = skewX;
            transform.skew.y = skewY;
        }
        // next set scale
        transform.scale.x = Math.sqrt((a * a) + (b * b));
        transform.scale.y = Math.sqrt((c * c) + (d * d));
        // next set position
        transform.position.x = this.tx;
        transform.position.y = this.ty;
        return transform;
    }
    ;
    /**
     * Inverts this matrix
     *
     * @return {PIXI.Matrix} This matrix. Good for chaining method calls.
     */
    invert() {
        var a1 = this.a;
        var b1 = this.b;
        var c1 = this.c;
        var d1 = this.d;
        var tx1 = this.tx;
        var n = (a1 * d1) - (b1 * c1);
        this.a = d1 / n;
        this.b = -b1 / n;
        this.c = -c1 / n;
        this.d = a1 / n;
        this.tx = ((c1 * this.ty) - (d1 * tx1)) / n;
        this.ty = -((a1 * this.ty) - (b1 * tx1)) / n;
        return this;
    }
    ;
    /**
     * Resets this Matrix to an identity (default) matrix.
     *
     * @return {PIXI.Matrix} This matrix. Good for chaining method calls.
     */
    identity() {
        this.a = 1;
        this.b = 0;
        this.c = 0;
        this.d = 1;
        this.tx = 0;
        this.ty = 0;
        return this;
    }
    ;
    /**
     * Creates a new Matrix object with the same values as this one.
     *
     * @return {PIXI.Matrix} A copy of this matrix. Good for chaining method calls.
     */
    clone() {
        var matrix = new Matrix();
        matrix.a = this.a;
        matrix.b = this.b;
        matrix.c = this.c;
        matrix.d = this.d;
        matrix.tx = this.tx;
        matrix.ty = this.ty;
        return matrix;
    }
    ;
    /**
     * Changes the values of the given matrix to be the same as the ones in this matrix
     *
     * @param {PIXI.Matrix} matrix - The matrix to copy to.
     * @return {PIXI.Matrix} The matrix given in parameter with its values updated.
     */
    copyTo(matrix) {
        matrix.a = this.a;
        matrix.b = this.b;
        matrix.c = this.c;
        matrix.d = this.d;
        matrix.tx = this.tx;
        matrix.ty = this.ty;
        return matrix;
    }
    ;
    /**
     * Changes the values of the matrix to be the same as the ones in given matrix
     *
     * @param {PIXI.Matrix} matrix - The matrix to copy from.
     * @return {PIXI.Matrix} this
     */
    copyFrom(matrix) {
        this.a = matrix.a;
        this.b = matrix.b;
        this.c = matrix.c;
        this.d = matrix.d;
        this.tx = matrix.tx;
        this.ty = matrix.ty;
        return this;
    }
    ;
    /**
     * A default (identity) matrix
     *
     * @static
     * @const
     * @member {PIXI.Matrix}
     */
    static get IDENTITY() {
        return new Matrix();
    }
    ;
    /**
     * A temp matrix
     *
     * @static
     * @const
     * @member {PIXI.Matrix}
     */
    static get TEMP_MATRIX() {
        return new Matrix();
    }
    ;
}
exports.Matrix = Matrix;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/Mesh.js":
/*!****************************************!*\
  !*** ./js-compile/raw-pixi-ts/Mesh.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Container_1 = __webpack_require__(/*! ./Container */ "./js-compile/raw-pixi-ts/Container.js");
const State_1 = __webpack_require__(/*! ./State */ "./js-compile/raw-pixi-ts/State.js");
const Polygon_1 = __webpack_require__(/*! ./Polygon */ "./js-compile/raw-pixi-ts/Polygon.js");
const MeshBatchUvs_1 = __webpack_require__(/*! ./MeshBatchUvs */ "./js-compile/raw-pixi-ts/MeshBatchUvs.js");
const Point_1 = __webpack_require__(/*! ../flash/geom/Point */ "./js-compile/flash/geom/Point.js");
const DrawModeSettings_1 = __webpack_require__(/*! ./DrawModeSettings */ "./js-compile/raw-pixi-ts/DrawModeSettings.js");
const BlendModesSettings_1 = __webpack_require__(/*! ./BlendModesSettings */ "./js-compile/raw-pixi-ts/BlendModesSettings.js");
const DisplaySettings_1 = __webpack_require__(/*! ./DisplaySettings */ "./js-compile/raw-pixi-ts/DisplaySettings.js");
class Mesh extends Container_1.Container {
    constructor(geometry, shader, state = null, drawMode = DrawModeSettings_1.DrawModeSettings.DRAW_MODES.TRIANGLES) {
        super();
        this.interactive = false;
        /**
         * Includes vertex positions, face indices, normals, colors, UVs, and
         * custom attributes within buffers, reducing the cost of passing all
         * this data to the GPU. Can be shared between multiple Mesh objects.
         * @member {PIXI.Geometry}
         * @readonly
         */
        this.geometry = geometry;
        geometry.refCount++;
        /**
         * Represents the vertex and fragment shaders that processes the geometry and runs on the GPU.
         * Can be shared between multiple Mesh objects.
         * @member {PIXI.Shader|PIXI.MeshMaterial}
         */
        this.shader = shader;
        /**
         * Represents the WebGL state the Mesh required to render, excludes shader and geometry. E.g.,
         * blend mode, culling, depth testing, direction of rendering triangles, backface, etc.
         * @member {PIXI.State}
         */
        this.state = state || State_1.State.for2d();
        /**
         * The way the Mesh should be drawn, can be any of the {@link PIXI.DRAW_MODES} constants.
         *
         * @member {number}
         * @see PIXI.DRAW_MODES
         */
        this.drawMode = drawMode;
        /**
         * Typically the index of the IndexBuffer where to start drawing.
         * @member {number}
         * @default 0
         */
        this.start = 0;
        /**
         * How much of the geometry to draw, by default `0` renders everything.
         * @member {number}
         * @default 0
         */
        this.size = 0;
        /**
         * thease are used as easy access for batching
         * @member {Float32Array}
         * @private
         */
        this.uvs = null;
        /**
         * thease are used as easy access for batching
         * @member {Uint16Array}
         * @private
         */
        this.indices = null;
        /**
         * this is the caching layer used by the batcher
         * @member {Float32Array}
         * @private
         */
        this.vertexData = new Float32Array(1);
        /**
         * If geometry is changed used to decide to re-transform
         * the vertexData.
         * @member {number}
         * @private
         */
        this.vertexDirty = 0;
        this._transformID = -1;
        // Inherited from DisplayMode, set defaults
        this.tint = 0xFFFFFF;
        this.blendMode = BlendModesSettings_1.BlendModesSettings.BLEND_MODES.NORMAL;
        /**
         * Internal roundPixels field
         *
         * @member {boolean}
         * @private
         */
        this._roundPixels = DisplaySettings_1.DisplaySettings.ROUND_PIXELS;
        /**
         * Batched UV's are cached for atlas textures
         * @member {PIXI.MeshBatchUvs}
         * @private
         */
        this.batchUvs = null;
    }
    /**
     * To change mesh uv's, change its uvBuffer data and increment its _updateID.
     * @member {PIXI.Buffer}
     * @readonly
     */
    get uvBuffer() {
        return this.geometry.buffers[1].data;
    }
    ;
    /**
     * To change mesh vertices, change its uvBuffer data and increment its _updateID.
     * Incrementing _updateID is optional because most of Mesh objects do it anyway.
     * @member {PIXI.Buffer}
     * @readonly
     */
    get verticesBuffer() {
        return this.geometry.buffers[0].data;
    }
    ;
    /**
     * Alias for {@link PIXI.Mesh#shader}.
     * @member {PIXI.Shader|PIXI.MeshMaterial}
     */
    set material(value) {
        this.shader = value;
    }
    ;
    get material() {
        return this.shader;
    }
    ;
    /**
     * The blend mode to be applied to the Mesh. Apply a value of
     * `PIXI.BLEND_MODES.NORMAL` to reset the blend mode.
     *
     * @member {number}
     * @default PIXI.BLEND_MODES.NORMAL;
     * @see PIXI.BLEND_MODES
     */
    set blendMode(value) {
        this.state.blendMode = value;
    }
    ;
    get blendMode() {
        return this.state.blendMode;
    }
    ;
    /**
     * If true PixiJS will Math.floor() x/y values when rendering, stopping pixel interpolation.
     * Advantages can include sharper image quality (like text) and faster rendering on canvas.
     * The main disadvantage is movement of objects may appear less smooth.
     * To set the global default, change {@link PIXI.settings.ROUND_PIXELS}
     *
     * @member {boolean}
     * @default false
     */
    set roundPixels(value) {
        if (this._roundPixels !== value) {
            this._transformID = -1;
        }
        this._roundPixels = value;
    }
    ;
    get roundPixels() {
        return this._roundPixels;
    }
    ;
    /**
     * The multiply tint applied to the Mesh. This is a hex value. A value of
     * `0xFFFFFF` will remove any tint effect.
     *
     * @member {number}
     * @default 0xFFFFFF
     */
    get tint() {
        return this.shader.tint;
    }
    ;
    set tint(value) {
        this.shader.tint = value;
    }
    ;
    /**
     * The texture that the Mesh uses.
     *
     * @member {PIXI.Texture}
     */
    get texture() {
        return this.shader.texture;
    }
    ;
    set texture(value) {
        this.shader.texture = value;
    }
    ;
    /**
     * Standard renderer draw.
     * @protected
     */
    _render(renderer) {
        // set properties for batching..
        // TODO could use a different way to grab verts?
        var vertices = this.geometry.buffers[0].data;
        // TODO benchmark check for attribute size..
        if (this.shader.batchable && this.drawMode === DrawModeSettings_1.DrawModeSettings.DRAW_MODES.TRIANGLES && vertices.length < Mesh.BATCHABLE_SIZE * 2) {
            this._renderToBatch(renderer);
        }
        else {
            this._renderDefault(renderer);
        }
    }
    ;
    /**
     * Standard non-batching way of rendering.
     * @protected
     * @param {PIXI.Renderer} renderer - Instance to renderer.
     */
    _renderDefault(renderer) {
        var shader = this.shader;
        shader.alpha = this.worldAlpha;
        if (shader.update) {
            shader.update();
        }
        renderer.batch.flush();
        if (shader.program.uniformData.translationMatrix) {
            shader.uniforms.translationMatrix = this.transform.worldTransform.toArray(true);
        }
        // bind and sync uniforms..
        renderer.shader.bind(shader);
        // set state..
        renderer.state.setState(this.state);
        // bind the geometry...
        renderer.geometry.bind(this.geometry, shader);
        // then render it
        renderer.geometry.draw(this.drawMode, this.size, this.start, this.geometry.instanceCount);
    }
    ;
    /**
     * Rendering by using the Batch system.
     * @protected
     * @param {PIXI.Renderer} renderer - Instance to renderer.
     */
    _renderToBatch(renderer) {
        var geometry = this.geometry;
        if (this.shader.uvMatrix) {
            this.shader.uvMatrix.update();
            this.calculateUvs();
        }
        // set properties for batching..
        this.calculateVertices();
        this.indices = geometry.indexBuffer.data;
        this._tintRGB = this.shader._tintRGB;
        this._texture = this.shader.texture;
        var pluginName = this.material.pluginName;
        renderer.batch.setObjectRenderer(renderer.plugins[pluginName]);
        renderer.plugins[pluginName].render(this);
    }
    ;
    /**
     * Updates vertexData field based on transform and vertices
     */
    calculateVertices() {
        var geometry = this.geometry;
        var vertices = geometry.buffers[0].data;
        if (geometry.vertexDirtyId === this.vertexDirty && this._transformID === this.transform.worldID) {
            return;
        }
        this._transformID = this.transform.worldID;
        if (this.vertexData.length !== vertices.length) {
            this.vertexData = new Float32Array(vertices.length);
        }
        var wt = this.transform.worldTransform;
        var a = wt.a;
        var b = wt.b;
        var c = wt.c;
        var d = wt.d;
        var tx = wt.tx;
        var ty = wt.ty;
        var vertexData = this.vertexData;
        for (var i = 0; i < vertexData.length / 2; i++) {
            var x = vertices[(i * 2)];
            var y = vertices[(i * 2) + 1];
            vertexData[(i * 2)] = (a * x) + (c * y) + tx;
            vertexData[(i * 2) + 1] = (b * x) + (d * y) + ty;
        }
        if (this._roundPixels) {
            for (var i$1 = 0; i$1 < vertexData.length; i$1++) {
                vertexData[i$1] = Math.round(vertexData[i$1]);
            }
        }
        this.vertexDirty = geometry.vertexDirtyId;
    }
    ;
    /**
     * Updates uv field based on from geometry uv's or batchUvs
     */
    calculateUvs() {
        var geomUvs = this.geometry.buffers[1];
        if (!this.shader.uvMatrix.isSimple) {
            if (!this.batchUvs) {
                this.batchUvs = new MeshBatchUvs_1.MeshBatchUvs(geomUvs, this.shader.uvMatrix);
            }
            this.batchUvs.update();
            this.uvs = this.batchUvs.data;
        }
        else {
            this.uvs = geomUvs.data;
        }
    }
    ;
    /**
     * Updates the bounds of the mesh as a rectangle. The bounds calculation takes the worldTransform into account.
     * there must be a aVertexPosition attribute present in the geometry for bounds to be calculated correctly.
     *
     * @protected
     */
    _calculateBounds() {
        this.calculateVertices();
        this._bounds.addVertexData(this.vertexData, 0, this.vertexData.length);
    }
    ;
    /**
     * Tests if a point is inside this mesh. Works only for PIXI.DRAW_MODES.TRIANGLES.
     *
     * @param {PIXI.Point} point the point to test
     * @return {boolean} the result of the test
     */
    containsPoint(point) {
        if (!this.interactive) {
            return false;
        }
        if (!this.getBounds().contains(point.x, point.y)) {
            return false;
        }
        let defaultpoint = Point_1.Point.DEFAULT;
        this.worldTransform.applyInverse(point, defaultpoint);
        var vertices = this.geometry.getAttribute('aVertexPosition').data;
        var points = Mesh.tempPolygon.points;
        var indices = this.geometry.getIndex().data;
        var len = indices.length;
        var step = this.drawMode === 4 ? 3 : 1;
        for (var i = 0; i + 2 < len; i += step) {
            var ind0 = indices[i] * 2;
            var ind1 = indices[i + 1] * 2;
            var ind2 = indices[i + 2] * 2;
            points[0] = vertices[ind0];
            points[1] = vertices[ind0 + 1];
            points[2] = vertices[ind1];
            points[3] = vertices[ind1 + 1];
            points[4] = vertices[ind2];
            points[5] = vertices[ind2 + 1];
            if (Mesh.tempPolygon.contains(defaultpoint.x, defaultpoint.y)) {
                return true;
            }
        }
        return false;
    }
    ;
    /**
     * Destroys the Mesh object.
     *
     * @param {object|boolean} [options] - Options parameter. A boolean will act as if all
     *  options have been set to that value
     * @param {boolean} [options.children=false] - if set to true, all the children will have
     *  their destroy method called as well. 'options' will be passed on to those calls.
     */
    destroy(options) {
        super.destroy(options);
        this.geometry.refCount--;
        if (this.geometry.refCount === 0) {
            this.geometry.dispose();
        }
        this.geometry = null;
        this.shader = null;
        this.state = null;
        this.uvs = null;
        this.indices = null;
        this.vertexData = null;
    }
    ;
}
Mesh.tempPolygon = new Polygon_1.Polygon();
/**
 * The maximum number of vertices to consider batchable. Generally, the complexity
 * of the geometry.
 * @memberof PIXI.Mesh
 * @static
 * @member {number} BATCHABLE_SIZE
 */
Mesh.BATCHABLE_SIZE = 100;
exports.Mesh = Mesh;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/MeshBatchUvs.js":
/*!************************************************!*\
  !*** ./js-compile/raw-pixi-ts/MeshBatchUvs.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class MeshBatchUvs {
    constructor(uvBuffer, uvMatrix) {
        /**
                 * Buffer with normalized UV's
                 * @member {PIXI.Buffer}
                 */
        this.uvBuffer = uvBuffer;
        /**
         * Material UV matrix
         * @member {PIXI.TextureMatrix}
         */
        this.uvMatrix = uvMatrix;
        /**
         * UV Buffer data
         * @member {Float32Array}
         * @readonly
         */
        this.data = null;
        this._bufferUpdateId = -1;
        this._textureUpdateId = -1;
        this._updateID = 0;
    }
    /**
     * updates
     *
     * @param {boolean} forceUpdate - force the update
     */
    update(forceUpdate) {
        if (!forceUpdate
            && this._bufferUpdateId === this.uvBuffer._updateID
            && this._textureUpdateId === this.uvMatrix._updateID) {
            return;
        }
        this._bufferUpdateId = this.uvBuffer._updateID;
        this._textureUpdateId = this.uvMatrix._updateID;
        var data = this.uvBuffer.data;
        if (!this.data || this.data.length !== data.length) {
            this.data = new Float32Array(data.length);
        }
        this.uvMatrix.multiplyUvs(data, this.data);
        this._updateID++;
    }
    ;
}
exports.MeshBatchUvs = MeshBatchUvs;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/MeshGeometry.js":
/*!************************************************!*\
  !*** ./js-compile/raw-pixi-ts/MeshGeometry.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Geometry_1 = __webpack_require__(/*! ./Geometry */ "./js-compile/raw-pixi-ts/Geometry.js");
const Buffer_1 = __webpack_require__(/*! ./Buffer */ "./js-compile/raw-pixi-ts/Buffer.js");
const WebGLSettings_1 = __webpack_require__(/*! ./WebGLSettings */ "./js-compile/raw-pixi-ts/WebGLSettings.js");
class MeshGeometry extends Geometry_1.Geometry {
    constructor(vertices = null, uvs = null, index = null) {
        super();
        var verticesBuffer = new Buffer_1.Buffer(vertices);
        var uvsBuffer = new Buffer_1.Buffer(uvs, true);
        var indexBuffer = new Buffer_1.Buffer(index, true, true);
        this.addAttribute('aVertexPosition', verticesBuffer, 2, false, WebGLSettings_1.WebGLSettings.TYPES.FLOAT)
            .addAttribute('aTextureCoord', uvsBuffer, 2, false, WebGLSettings_1.WebGLSettings.TYPES.FLOAT)
            .addIndex(indexBuffer);
        /**
         * Dirty flag to limit update calls on Mesh. For example,
         * limiting updates on a single Mesh instance with a shared Geometry
         * within the render loop.
         * @private
         * @member {number}
         * @default -1
         */
        this._updateId = -1;
    }
    /**
     * If the vertex position is updated.
     * @member {number}
     * @readonly
     * @private
     */
    get vertexDirtyId() {
        return this.buffers[0]._updateID;
    }
    ;
}
exports.MeshGeometry = MeshGeometry;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/MeshMaterial.js":
/*!************************************************!*\
  !*** ./js-compile/raw-pixi-ts/MeshMaterial.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Shader_1 = __webpack_require__(/*! ./Shader */ "./js-compile/raw-pixi-ts/Shader.js");
const Matrix_1 = __webpack_require__(/*! ./Matrix */ "./js-compile/raw-pixi-ts/Matrix.js");
const Program_1 = __webpack_require__(/*! ./Program */ "./js-compile/raw-pixi-ts/Program.js");
const TextureMatrix_1 = __webpack_require__(/*! ./TextureMatrix */ "./js-compile/raw-pixi-ts/TextureMatrix.js");
const ColorSettings_1 = __webpack_require__(/*! ./ColorSettings */ "./js-compile/raw-pixi-ts/ColorSettings.js");
class MeshMaterial extends Shader_1.Shader {
    constructor(uSampler, options = null) {
        var uniforms = {
            uSampler: uSampler,
            alpha: 1,
            uTextureMatrix: Matrix_1.Matrix.IDENTITY,
            uColor: new Float32Array([1, 1, 1, 1]),
        };
        // Set defaults
        options = Object.assign({
            tint: 0xFFFFFF,
            alpha: 1,
            pluginName: 'batch',
        }, options);
        if (options.uniforms) {
            Object.assign(uniforms, options.uniforms);
        }
        super(options.program || Program_1.Program.from(MeshMaterial.vertex$6, MeshMaterial.fragment$8), uniforms);
        /**
         * Only do update if tint or alpha changes.
         * @member {boolean}
         * @private
         * @default false
         */
        this._colorDirty = false;
        /**
         * TextureMatrix instance for this Mesh, used to track Texture changes
         *
         * @member {PIXI.TextureMatrix}
         * @readonly
         */
        this.uvMatrix = new TextureMatrix_1.TextureMatrix(uSampler);
        /**
         * `true` if shader can be batch with the renderer's batch system.
         * @member {boolean}
         * @default true
         */
        this.batchable = options.program === undefined;
        /**
         * Renderer plugin for batching
         *
         * @member {string}
         * @default 'batch'
         */
        this.pluginName = options.pluginName;
        this.tint = options.tint;
        this.alpha = options.alpha;
    }
    /**
     * Reference to the texture being rendered.
     * @member {PIXI.Texture}
     */
    get texture() {
        return this.uniforms.uSampler;
    }
    ;
    set texture(value) {
        if (this.uniforms.uSampler !== value) {
            this.uniforms.uSampler = value;
            this.uvMatrix.texture = value;
        }
    }
    ;
    /**
     * This gets automatically set by the object using this.
     *
     * @default 1
     * @member {number}
     */
    set alpha(value) {
        if (value === this._alpha) {
            return;
        }
        this._alpha = value;
        this._colorDirty = true;
    }
    ;
    get alpha() {
        return this._alpha;
    }
    ;
    /**
     * Multiply tint for the material.
     * @member {number}
     * @default 0xFFFFFF
     */
    set tint(value) {
        if (value === this._tint) {
            return;
        }
        this._tint = value;
        this._tintRGB = (value >> 16) + (value & 0xff00) + ((value & 0xff) << 16);
        this._colorDirty = true;
    }
    ;
    get tint() {
        return this._tint;
    }
    ;
    /**
     * Gets called automatically by the Mesh. Intended to be overridden for custom
     * MeshMaterial objects.
     */
    update() {
        if (this._colorDirty) {
            this._colorDirty = false;
            var baseTexture = this.texture.baseTexture;
            ColorSettings_1.ColorSettings.premultiplyTintToRgba(this._tint, this._alpha, this.uniforms.uColor, baseTexture.premultiplyAlpha);
        }
        if (this.uvMatrix.update()) {
            this.uniforms.uTextureMatrix = this.uvMatrix.mapCoord;
        }
    }
    ;
}
MeshMaterial.vertex$6 = "attribute vec2 aVertexPosition;\r\nattribute vec2 aTextureCoord;\r\n\r\nuniform mat3 projectionMatrix;\r\nuniform mat3 translationMatrix;\r\nuniform mat3 uTextureMatrix;\r\n\r\nvarying vec2 vTextureCoord;\r\n\r\nvoid main(void)\r\n{\r\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\r\n\r\n    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;\r\n}\r\n";
MeshMaterial.fragment$8 = "varying vec2 vTextureCoord;\r\nuniform vec4 uColor;\r\n\r\nuniform sampler2D uSampler;\r\n\r\nvoid main(void)\r\n{\r\n    gl_FragColor = texture2D(uSampler, vTextureCoord) * uColor;\r\n}\r\n";
exports.MeshMaterial = MeshMaterial;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/MouseEvent.js":
/*!**********************************************!*\
  !*** ./js-compile/raw-pixi-ts/MouseEvent.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Event_1 = __webpack_require__(/*! ./Event */ "./js-compile/raw-pixi-ts/Event.js");
class MouseEvent extends Event_1.Event {
    constructor(type, bubbles = false) {
        super(type, bubbles);
        this.movementX = 0;
        this.movementY = 0;
    }
}
MouseEvent.CLICK = "click";
MouseEvent.MOUSE_DOWN = "mouseDown";
MouseEvent.MOUSE_UP = "mouseUp";
MouseEvent.MIDDLE_CLICK = "middleClick";
MouseEvent.MIDDLE_MOUSE_DOWN = "middleMouseDown";
MouseEvent.MIDDLE_MOUSE_UP = "middleMouseUp";
MouseEvent.RIGHT_CLICK = "rightClick";
MouseEvent.RIGHT_MOUSE_DOWN = "rightMouseDown";
MouseEvent.RIGHT_MOUSE_UP = "rightMouseUp";
MouseEvent.MOUSE_MOVE = "mouseMove";
MouseEvent.MOUSE_OVER = "mouseOver";
MouseEvent.MOUSE_OUT = "mouseOut";
MouseEvent.RIGHT_MOUSE_UP_OUTSIDE = "rightupoutside";
MouseEvent.MOUSE_UP_OUTSIDE = "mouseupoutside";
MouseEvent.POINTER_OVER = "pointerover";
MouseEvent.POINTER_ENTER = "pointerenter";
MouseEvent.POINTER_DOWN = "pointerdown";
MouseEvent.POINTER_MOVE = "pointermove";
MouseEvent.POINTER_UP = "pointerup";
MouseEvent.POINTER_CANCEL = "pointercancel";
MouseEvent.POINTER_OUT = "pointerout";
MouseEvent.POINTER_LEAVE = "pointerleave";
MouseEvent.POINTER_CAPTURE = "gotpointercapture";
MouseEvent.POINTER_LOST = "lostpointercapture";
MouseEvent.POINTER_UP_OUTSIDE = "pointerupoutside";
MouseEvent.POINTER_TAP = "pointertap";
MouseEvent.TOUCH_START = "touchstart";
MouseEvent.TOUCH_END = "touchend";
MouseEvent.TOUCH_END_OUTSIDE = "touchendoutside";
MouseEvent.TOUCH_MOVE = "touchmove";
MouseEvent.TOUCH_CANCEL = "touchcancel";
MouseEvent.TOUCH_TAP = "tap";
exports.MouseEvent = MouseEvent;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/NetworkSettings.js":
/*!***************************************************!*\
  !*** ./js-compile/raw-pixi-ts/NetworkSettings.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Url_1 = __webpack_require__(/*! ./Url */ "./js-compile/raw-pixi-ts/Url.js");
class NetworkSettings {
    static getResolutionOfUrl(url, defaultValue = null) {
        var resolution = NetworkSettings.RETINA_PREFIX.exec(url);
        if (resolution) {
            return parseFloat(resolution[1]);
        }
        return defaultValue !== undefined ? defaultValue : 1;
    }
    static determineCrossOrigin(url$1, loc = null) {
        if (loc === void 0) {
            loc = window.location;
        }
        if (url$1.indexOf('data:') === 0) {
            return '';
        }
        loc = loc || window.location;
        if (!NetworkSettings.tempAnchor) {
            NetworkSettings.tempAnchor = document.createElement('a');
        }
        NetworkSettings.tempAnchor.href = url$1;
        url$1 = NetworkSettings.url.parse(NetworkSettings.tempAnchor.href);
        var samePort = (!url$1.port && loc.port === '') || (url$1.port === loc.port);
        if (url$1.hostname !== loc.hostname || !samePort || url$1.protocol !== loc.protocol) {
            return 'anonymous';
        }
        return '';
    }
}
NetworkSettings.RETINA_PREFIX = /@([0-9\.]+)x/;
NetworkSettings.url = {
    parse: Url_1.Url.urlParse,
    resolve: Url_1.Url.urlResolve,
    resolveObject: Url_1.Url.urlResolveObject,
    format: Url_1.Url.urlFormat,
    Url: Url_1.Url
};
exports.NetworkSettings = NetworkSettings;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/ObjectRenderer.js":
/*!**************************************************!*\
  !*** ./js-compile/raw-pixi-ts/ObjectRenderer.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const System_1 = __webpack_require__(/*! ./System */ "./js-compile/raw-pixi-ts/System.js");
class ObjectRenderer extends System_1.System {
    constructor(renderer) {
        super(renderer);
    }
    start() {
        // set the shader..
    }
    ;
    /**
     * Stops the renderer
     *
     */
    stop() {
        this.flush();
    }
    ;
    /**
     * Stub method for rendering content and emptying the current batch.
     *
     */
    flush() {
        // flush!
    }
    ;
    /**
     * Renders an object
     *
     * @param {PIXI.DisplayObject} object - The object to render.
     */
    render(object) {
        // render the object
    }
    ;
}
exports.ObjectRenderer = ObjectRenderer;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/ObservablePoint.js":
/*!***************************************************!*\
  !*** ./js-compile/raw-pixi-ts/ObservablePoint.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Point_1 = __webpack_require__(/*! ../flash/geom/Point */ "./js-compile/flash/geom/Point.js");
class ObservablePoint extends Point_1.Point {
    constructor(x = 0, y = 0) {
        super(x, y);
    }
    /**
     * Sets the point to a new x and y position.
     * If y is omitted, both x and y will be set to x.
     *
     * @param {number} [x=0] - position of the point on the x axis
     * @param {number} [y=0] - position of the point on the y axis
     */
    set(x = 0, y = NaN) {
        var _x = x;
        var _y = y;
        if (isNaN(_y)) {
            _y = _x;
        }
        if (this._x !== _x || this._y !== _y) {
            this._x = _x;
            this._y = _y;
            this.callback.call(this.scope);
        }
    }
    ;
    /**
     * Copies x and y from the given point
     *
     * @param {PIXI.IPoint} p - The point to copy from.
     * @returns {PIXI.IPoint} Returns itself.
     */
    copyFrom(p) {
        if (this._x !== p.x || this._y !== p.y) {
            this._x = p.x;
            this._y = p.y;
            this.callback.call(this.scope);
        }
        return this;
    }
    ;
    /**
     * Copies x and y into the given point
     *
     * @param {PIXI.IPoint} p - The point to copy.
     * @returns {PIXI.IPoint} Given point with values updated
     */
    copyTo(p) {
        p.set(this._x, this._y);
        return p;
    }
    ;
    /**
     * Returns true if the given point is equal to this point
     *
     * @param {PIXI.IPoint} p - The point to check
     * @returns {boolean} Whether the given point equal to this point
     */
    equals(p) {
        return (p.x === this._x) && (p.y === this._y);
    }
    ;
    /**
     * The position of the displayObject on the x axis relative to the local coordinates of the parent.
     *
     * @member {number}
     */
    get x() {
        return this._x;
    }
    ;
    set x(value) {
        if (this._x !== value) {
            this._x = value;
            this.callback.call(this.scope);
        }
    }
    ;
    /**
     * The position of the displayObject on the x axis relative to the local coordinates of the parent.
     *
     * @member {number}
     */
    get y() {
        return this._y;
    }
    ;
    set y(value) {
        if (this._y !== value) {
            this._y = value;
            this.callback.call(this.scope);
        }
    }
    ;
}
exports.ObservablePoint = ObservablePoint;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/ParticleBuffer.js":
/*!**************************************************!*\
  !*** ./js-compile/raw-pixi-ts/ParticleBuffer.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Geometry_1 = __webpack_require__(/*! ./Geometry */ "./js-compile/raw-pixi-ts/Geometry.js");
const Buffer_1 = __webpack_require__(/*! ./Buffer */ "./js-compile/raw-pixi-ts/Buffer.js");
const WebGLSettings_1 = __webpack_require__(/*! ./WebGLSettings */ "./js-compile/raw-pixi-ts/WebGLSettings.js");
class ParticleBuffer {
    constructor(properties, dynamicPropertyFlags, size) {
        this.geometry = new Geometry_1.Geometry();
        this.indexBuffer = null;
        /**
         * The number of particles the buffer can hold
         *
         * @private
         * @member {number}
         */
        this.size = size;
        /**
         * A list of the properties that are dynamic.
         *
         * @private
         * @member {object[]}
         */
        this.dynamicProperties = [];
        /**
         * A list of the properties that are static.
         *
         * @private
         * @member {object[]}
         */
        this.staticProperties = [];
        for (var i = 0; i < properties.length; ++i) {
            var property = properties[i];
            // Make copy of properties object so that when we edit the offset it doesn't
            // change all other instances of the object literal
            property = {
                attributeName: property.attributeName,
                size: property.size,
                uploadFunction: property.uploadFunction,
                type: property.type || WebGLSettings_1.WebGLSettings.TYPES.FLOAT,
                offset: property.offset,
            };
            if (dynamicPropertyFlags[i]) {
                this.dynamicProperties.push(property);
            }
            else {
                this.staticProperties.push(property);
            }
        }
        this.staticStride = 0;
        this.staticBuffer = null;
        this.staticData = null;
        this.staticDataUint32 = null;
        this.dynamicStride = 0;
        this.dynamicBuffer = null;
        this.dynamicData = null;
        this.dynamicDataUint32 = null;
        this._updateID = 0;
        this.initBuffers();
    }
    /**
     * Sets up the renderer context and necessary buffers.
     *
     * @private
     */
    initBuffers() {
        var geometry = this.geometry;
        var dynamicOffset = 0;
        /**
         * Holds the indices of the geometry (quads) to draw
         *
         * @member {Uint16Array}
         * @private
         */
        this.indexBuffer = new Buffer_1.Buffer(WebGLSettings_1.WebGLSettings.createIndicesForQuads(this.size), true, true);
        geometry.addIndex(this.indexBuffer);
        this.dynamicStride = 0;
        for (var i = 0; i < this.dynamicProperties.length; ++i) {
            var property = this.dynamicProperties[i];
            property.offset = dynamicOffset;
            dynamicOffset += property.size;
            this.dynamicStride += property.size;
        }
        var dynBuffer = new ArrayBuffer(this.size * this.dynamicStride * 4 * 4);
        this.dynamicData = new Float32Array(dynBuffer);
        this.dynamicDataUint32 = new Uint32Array(dynBuffer);
        this.dynamicBuffer = new Buffer_1.Buffer(this.dynamicData, false, false);
        // static //
        var staticOffset = 0;
        this.staticStride = 0;
        for (var i$1 = 0; i$1 < this.staticProperties.length; ++i$1) {
            var property$1 = this.staticProperties[i$1];
            property$1.offset = staticOffset;
            staticOffset += property$1.size;
            this.staticStride += property$1.size;
        }
        var statBuffer = new ArrayBuffer(this.size * this.staticStride * 4 * 4);
        this.staticData = new Float32Array(statBuffer);
        this.staticDataUint32 = new Uint32Array(statBuffer);
        this.staticBuffer = new Buffer_1.Buffer(this.staticData, true, false);
        for (var i$2 = 0; i$2 < this.dynamicProperties.length; ++i$2) {
            var property$2 = this.dynamicProperties[i$2];
            geometry.addAttribute(property$2.attributeName, this.dynamicBuffer, 0, property$2.type === WebGLSettings_1.WebGLSettings.TYPES.UNSIGNED_BYTE, property$2.type, this.dynamicStride * 4, property$2.offset * 4);
        }
        for (var i$3 = 0; i$3 < this.staticProperties.length; ++i$3) {
            var property$3 = this.staticProperties[i$3];
            geometry.addAttribute(property$3.attributeName, this.staticBuffer, 0, property$3.type === WebGLSettings_1.WebGLSettings.TYPES.UNSIGNED_BYTE, property$3.type, this.staticStride * 4, property$3.offset * 4);
        }
    }
    ;
    /**
     * Uploads the dynamic properties.
     *
     * @private
     * @param {PIXI.DisplayObject[]} children - The children to upload.
     * @param {number} startIndex - The index to start at.
     * @param {number} amount - The number to upload.
     */
    uploadDynamic(children, startIndex, amount) {
        for (var i = 0; i < this.dynamicProperties.length; i++) {
            var property = this.dynamicProperties[i];
            property.uploadFunction(children, startIndex, amount, property.type === WebGLSettings_1.WebGLSettings.TYPES.UNSIGNED_BYTE ? this.dynamicDataUint32 : this.dynamicData, this.dynamicStride, property.offset);
        }
        this.dynamicBuffer._updateID++;
    }
    ;
    /**
     * Uploads the static properties.
     *
     * @private
     * @param {PIXI.DisplayObject[]} children - The children to upload.
     * @param {number} startIndex - The index to start at.
     * @param {number} amount - The number to upload.
     */
    uploadStatic(children, startIndex, amount) {
        for (var i = 0; i < this.staticProperties.length; i++) {
            var property = this.staticProperties[i];
            property.uploadFunction(children, startIndex, amount, property.type === WebGLSettings_1.WebGLSettings.TYPES.UNSIGNED_BYTE ? this.staticDataUint32 : this.staticData, this.staticStride, property.offset);
        }
        this.staticBuffer._updateID++;
    }
    ;
    /**
     * Destroys the ParticleBuffer.
     *
     * @private
     */
    destroy() {
        this.indexBuffer = null;
        this.dynamicProperties = null;
        // this.dynamicBuffer.destroy();
        this.dynamicBuffer = null;
        this.dynamicData = null;
        this.dynamicDataUint32 = null;
        this.staticProperties = null;
        // this.staticBuffer.destroy();
        this.staticBuffer = null;
        this.staticData = null;
        this.staticDataUint32 = null;
        // all buffers are destroyed inside geometry
        this.geometry.destroy();
    }
    ;
}
exports.ParticleBuffer = ParticleBuffer;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/ParticleContainer.js":
/*!*****************************************************!*\
  !*** ./js-compile/raw-pixi-ts/ParticleContainer.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Container_1 = __webpack_require__(/*! ./Container */ "./js-compile/raw-pixi-ts/Container.js");
const BlendModesSettings_1 = __webpack_require__(/*! ./BlendModesSettings */ "./js-compile/raw-pixi-ts/BlendModesSettings.js");
const ColorSettings_1 = __webpack_require__(/*! ./ColorSettings */ "./js-compile/raw-pixi-ts/ColorSettings.js");
class ParticleContainer extends Container_1.Container {
    constructor(maxSize = 1500, properties = null, batchSize = 16384, autoResize = false) {
        if (maxSize === void 0) {
            maxSize = 1500;
        }
        if (batchSize === void 0) {
            batchSize = 16384;
        }
        if (autoResize === void 0) {
            autoResize = false;
        }
        super();
        // Making sure the batch size is valid
        // 65535 is max vertex index in the index buffer (see ParticleRenderer)
        // so max number of particles is 65536 / 4 = 16384
        var maxBatchSize = 16384;
        if (batchSize > maxBatchSize) {
            batchSize = maxBatchSize;
        }
        if (batchSize > maxSize) {
            batchSize = maxSize;
        }
        /**
         * Set properties to be dynamic (true) / static (false)
         *
         * @member {boolean[]}
         * @private
         */
        this._properties = [false, true, false, false, false];
        /**
         * @member {number}
         * @private
         */
        this._maxSize = maxSize;
        /**
         * @member {number}
         * @private
         */
        this._batchSize = batchSize;
        /**
         * @member {Array<PIXI.Buffer>}
         * @private
         */
        this._buffers = null;
        /**
         * for every batch stores _updateID corresponding to the last change in that batch
         * @member {number[]}
         * @private
         */
        this._bufferUpdateIDs = [];
        /**
         * when child inserted, removed or changes position this number goes up
         * @member {number[]}
         * @private
         */
        this._updateID = 0;
        /**
         * @member {boolean}
         *
         */
        this.interactiveChildren = false;
        /**
         * The blend mode to be applied to the sprite. Apply a value of `PIXI.BLEND_MODES.NORMAL`
         * to reset the blend mode.
         *
         * @member {number}
         * @default PIXI.BLEND_MODES.NORMAL
         * @see PIXI.BLEND_MODES
         */
        this.blendMode = BlendModesSettings_1.BlendModesSettings.BLEND_MODES.NORMAL;
        /**
         * If true, container allocates more batches in case there are more than `maxSize` particles.
         * @member {boolean}
         * @default false
         */
        this.autoResize = autoResize;
        /**
         * If true PixiJS will Math.floor() x/y values when rendering, stopping pixel interpolation.
         * Advantages can include sharper image quality (like text) and faster rendering on canvas.
         * The main disadvantage is movement of objects may appear less smooth.
         * Default to true here as performance is usually the priority for particles.
         *
         * @member {boolean}
         * @default true
         */
        this.roundPixels = true;
        /**
         * The texture used to render the children.
         *
         * @readonly
         * @member {BaseTexture}
         */
        this.baseTexture = null;
        this.setProperties(properties);
        /**
         * The tint applied to the container.
         * This is a hex value. A value of 0xFFFFFF will remove any tint effect.
         *
         * @private
         * @member {number}
         * @default 0xFFFFFF
         */
        this._tint = 0;
        this.tintRgb = new Float32Array(4);
        this.tint = 0xFFFFFF;
    }
    /**
     * Sets the private properties array to dynamic / static based on the passed properties object
     *
     * @param {object} properties - The properties to be uploaded
     */
    setProperties(properties) {
        if (properties) {
            this._properties[0] = 'vertices' in properties || 'scale' in properties
                ? !!properties.vertices || !!properties.scale : this._properties[0];
            this._properties[1] = 'position' in properties ? !!properties.position : this._properties[1];
            this._properties[2] = 'rotation' in properties ? !!properties.rotation : this._properties[2];
            this._properties[3] = 'uvs' in properties ? !!properties.uvs : this._properties[3];
            this._properties[4] = 'tint' in properties || 'alpha' in properties
                ? !!properties.tint || !!properties.alpha : this._properties[4];
        }
    }
    ;
    /**
     * Updates the object transform for rendering
     *
     * @private
     */
    updateTransform() {
        super.updateTransform();
        // TODO don't need to!
        // this.displayObjectUpdateTransform();
        //  PIXI.Container.prototype.updateTransform.call( this );
    }
    ;
    /**
     * The tint applied to the container. This is a hex value.
     * A value of 0xFFFFFF will remove any tint effect.
     ** IMPORTANT: This is a WebGL only feature and will be ignored by the canvas renderer.
        * @member {number}
        * @default 0xFFFFFF
        */
    get tint() {
        return this._tint;
    }
    ;
    set tint(value) {
        this._tint = value;
        ColorSettings_1.ColorSettings.hex2rgb(value, this.tintRgb);
    }
    ;
    /**
     * Renders the container using the WebGL renderer
     *
     * @private
     * @param {PIXI.Renderer} renderer - The webgl renderer
     */
    render(renderer) {
        var this$1 = this;
        if (!this.visible || this.worldAlpha <= 0 || !this.children.length || !this.renderable) {
            return;
        }
        if (!this.baseTexture) {
            this.baseTexture = this.children[0]._texture.baseTexture;
            if (!this.baseTexture.valid) {
                this.baseTexture.once('update', function () { return this$1.onChildrenChange(0); });
            }
        }
        renderer.batch.setObjectRenderer(renderer.plugins.particle);
        renderer.plugins.particle.render(this);
    }
    ;
    /**
     * Set the flag that static data should be updated to true
     *
     * @private
     * @param {number} smallestChildIndex - The smallest child index
     */
    onChildrenChange(smallestChildIndex) {
        var bufferIndex = Math.floor(smallestChildIndex / this._batchSize);
        while (this._bufferUpdateIDs.length < bufferIndex) {
            this._bufferUpdateIDs.push(0);
        }
        this._bufferUpdateIDs[bufferIndex] = ++this._updateID;
    }
    ;
    dispose() {
        if (this._buffers) {
            for (var i = 0; i < this._buffers.length; ++i) {
                this._buffers[i].destroy();
            }
            this._buffers = null;
        }
    }
    ;
    /**
     * Destroys the container
     *
     * @param {object|boolean} [options] - Options parameter. A boolean will act as if all options
     *  have been set to that value
     * @param {boolean} [options.children=false] - if set to true, all the children will have their
     *  destroy method called as well. 'options' will be passed on to those calls.
     * @param {boolean} [options.texture=false] - Only used for child Sprites if options.children is set to true
     *  Should it destroy the texture of the child sprite
     * @param {boolean} [options.baseTexture=false] - Only used for child Sprites if options.children is set to true
     *  Should it destroy the base texture of the child sprite
     */
    destroy(options) {
        super.destroy(options);
        this.dispose();
        this._properties = null;
        this._buffers = null;
        this._bufferUpdateIDs = null;
    }
    ;
}
exports.ParticleContainer = ParticleContainer;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/ParticleRenderer.js":
/*!****************************************************!*\
  !*** ./js-compile/raw-pixi-ts/ParticleRenderer.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const ObjectRenderer_1 = __webpack_require__(/*! ./ObjectRenderer */ "./js-compile/raw-pixi-ts/ObjectRenderer.js");
const Matrix_1 = __webpack_require__(/*! ./Matrix */ "./js-compile/raw-pixi-ts/Matrix.js");
const Shader_1 = __webpack_require__(/*! ./Shader */ "./js-compile/raw-pixi-ts/Shader.js");
const ParticleBuffer_1 = __webpack_require__(/*! ./ParticleBuffer */ "./js-compile/raw-pixi-ts/ParticleBuffer.js");
const ColorSettings_1 = __webpack_require__(/*! ./ColorSettings */ "./js-compile/raw-pixi-ts/ColorSettings.js");
const BlendModesSettings_1 = __webpack_require__(/*! ./BlendModesSettings */ "./js-compile/raw-pixi-ts/BlendModesSettings.js");
const WebGLSettings_1 = __webpack_require__(/*! ./WebGLSettings */ "./js-compile/raw-pixi-ts/WebGLSettings.js");
class ParticleRenderer extends ObjectRenderer_1.ObjectRenderer {
    constructor(renderer) {
        super(renderer);
        // 65535 is max vertex index in the index buffer (see ParticleRenderer)
        // so max number of particles is 65536 / 4 = 16384
        // and max number of element in the index buffer is 16384 * 6 = 98304
        // Creating a full index buffer, overhead is 98304 * 2 = 196Ko
        // let numIndices = 98304;
        /**
         * The default shader that is used if a sprite doesn't have a more specific one.
         *
         * @member {PIXI.Shader}
         */
        this.shader = null;
        this.properties = null;
        this.tempMatrix = new Matrix_1.Matrix();
        this.properties = [
            // verticesData
            {
                attributeName: 'aVertexPosition',
                size: 2,
                uploadFunction: this.uploadVertices,
                offset: 0,
            },
            // positionData
            {
                attributeName: 'aPositionCoord',
                size: 2,
                uploadFunction: this.uploadPosition,
                offset: 0,
            },
            // rotationData
            {
                attributeName: 'aRotation',
                size: 1,
                uploadFunction: this.uploadRotation,
                offset: 0,
            },
            // uvsData
            {
                attributeName: 'aTextureCoord',
                size: 2,
                uploadFunction: this.uploadUvs,
                offset: 0,
            },
            // tintData
            {
                attributeName: 'aColor',
                size: 1,
                type: WebGLSettings_1.WebGLSettings.TYPES.UNSIGNED_BYTE,
                uploadFunction: this.uploadTint,
                offset: 0,
            }
        ];
        this.shader = Shader_1.Shader.from(ParticleRenderer.vertex$2, ParticleRenderer.fragment$1, {});
    }
    /**
     * Renders the particle container object.
     *
     * @param {PIXI.ParticleContainer} container - The container to render using this ParticleRenderer
     */
    render(container) {
        var children = container.children;
        var maxSize = container._maxSize;
        var batchSize = container._batchSize;
        var renderer = this.renderer;
        var totalChildren = children.length;
        if (totalChildren === 0) {
            return;
        }
        else if (totalChildren > maxSize) {
            totalChildren = maxSize;
        }
        var buffers = container._buffers;
        if (!buffers) {
            buffers = container._buffers = this.generateBuffers(container);
        }
        var baseTexture = children[0]._texture.baseTexture;
        // if the uvs have not updated then no point rendering just yet!
        this.renderer.state.setBlendMode(BlendModesSettings_1.BlendModesSettings.correctBlendMode(container.blendMode, baseTexture.premultiplyAlpha));
        var gl = renderer.gl;
        var m = container.worldTransform.copyTo(this.tempMatrix);
        m.prepend(renderer.globalUniforms.uniforms.projectionMatrix);
        this.shader.uniforms.translationMatrix = m.toArray(true);
        this.shader.uniforms.uColor = ColorSettings_1.ColorSettings.premultiplyRgba(container.tintRgb, container.worldAlpha, this.shader.uniforms.uColor, baseTexture.premultiplyAlpha);
        this.shader.uniforms.uSampler = baseTexture;
        this.renderer.shader.bind(this.shader);
        var updateStatic = false;
        // now lets upload and render the buffers..
        for (var i = 0, j = 0; i < totalChildren; i += batchSize, j += 1) {
            var amount = (totalChildren - i);
            if (amount > batchSize) {
                amount = batchSize;
            }
            if (j >= buffers.length) {
                if (!container.autoResize) {
                    break;
                }
                buffers.push(this._generateOneMoreBuffer(container));
            }
            var buffer = buffers[j];
            // we always upload the dynamic
            buffer.uploadDynamic(children, i, amount);
            var bid = container._bufferUpdateIDs[j] || 0;
            updateStatic = updateStatic || (buffer._updateID < bid);
            // we only upload the static content when we have to!
            if (updateStatic) {
                buffer._updateID = container._updateID;
                buffer.uploadStatic(children, i, amount);
            }
            // bind the buffer
            renderer.geometry.bind(buffer.geometry);
            gl.drawElements(gl.TRIANGLES, amount * 6, gl.UNSIGNED_SHORT, 0);
        }
    }
    ;
    /**
     * Creates one particle buffer for each child in the container we want to render and updates internal properties
     *
     * @param {PIXI.ParticleContainer} container - The container to render using this ParticleRenderer
     * @return {PIXI.ParticleBuffer[]} The buffers
     * @private
     */
    generateBuffers(container) {
        var buffers = [];
        var size = container._maxSize;
        var batchSize = container._batchSize;
        var dynamicPropertyFlags = container._properties;
        for (var i = 0; i < size; i += batchSize) {
            buffers.push(new ParticleBuffer_1.ParticleBuffer(this.properties, dynamicPropertyFlags, batchSize));
        }
        return buffers;
    }
    ;
    /**
     * Creates one more particle buffer, because container has autoResize feature
     *
     * @param {PIXI.ParticleContainer} container - The container to render using this ParticleRenderer
     * @return {PIXI.ParticleBuffer} generated buffer
     * @private
     */
    _generateOneMoreBuffer(container) {
        var batchSize = container._batchSize;
        var dynamicPropertyFlags = container._properties;
        return new ParticleBuffer_1.ParticleBuffer(this.properties, dynamicPropertyFlags, batchSize);
    }
    ;
    /**
     * Uploads the vertices.
     *
     * @param {PIXI.DisplayObject[]} children - the array of display objects to render
     * @param {number} startIndex - the index to start from in the children array
     * @param {number} amount - the amount of children that will have their vertices uploaded
     * @param {number[]} array - The vertices to upload.
     * @param {number} stride - Stride to use for iteration.
     * @param {number} offset - Offset to start at.
     */
    uploadVertices(children, startIndex, amount, array, stride, offset) {
        var w0 = 0;
        var w1 = 0;
        var h0 = 0;
        var h1 = 0;
        for (var i = 0; i < amount; ++i) {
            var sprite = children[startIndex + i];
            var texture = sprite._texture;
            var sx = sprite.scale.x;
            var sy = sprite.scale.y;
            var trim = texture.trim;
            var orig = texture.orig;
            if (trim) {
                // if the sprite is trimmed and is not a tilingsprite then we need to add the
                // extra space before transforming the sprite coords..
                w1 = trim.x - (sprite.anchor.x * orig.width);
                w0 = w1 + trim.width;
                h1 = trim.y - (sprite.anchor.y * orig.height);
                h0 = h1 + trim.height;
            }
            else {
                w0 = (orig.width) * (1 - sprite.anchor.x);
                w1 = (orig.width) * -sprite.anchor.x;
                h0 = orig.height * (1 - sprite.anchor.y);
                h1 = orig.height * -sprite.anchor.y;
            }
            array[offset] = w1 * sx;
            array[offset + 1] = h1 * sy;
            array[offset + stride] = w0 * sx;
            array[offset + stride + 1] = h1 * sy;
            array[offset + (stride * 2)] = w0 * sx;
            array[offset + (stride * 2) + 1] = h0 * sy;
            array[offset + (stride * 3)] = w1 * sx;
            array[offset + (stride * 3) + 1] = h0 * sy;
            offset += stride * 4;
        }
    }
    ;
    /**
     * Uploads the position.
     *
     * @param {PIXI.DisplayObject[]} children - the array of display objects to render
     * @param {number} startIndex - the index to start from in the children array
     * @param {number} amount - the amount of children that will have their positions uploaded
     * @param {number[]} array - The vertices to upload.
     * @param {number} stride - Stride to use for iteration.
     * @param {number} offset - Offset to start at.
     */
    uploadPosition(children, startIndex, amount, array, stride, offset) {
        for (var i = 0; i < amount; i++) {
            var spritePosition = children[startIndex + i].position;
            array[offset] = spritePosition.x;
            array[offset + 1] = spritePosition.y;
            array[offset + stride] = spritePosition.x;
            array[offset + stride + 1] = spritePosition.y;
            array[offset + (stride * 2)] = spritePosition.x;
            array[offset + (stride * 2) + 1] = spritePosition.y;
            array[offset + (stride * 3)] = spritePosition.x;
            array[offset + (stride * 3) + 1] = spritePosition.y;
            offset += stride * 4;
        }
    }
    ;
    /**
     * Uploads the rotiation.
     *
     * @param {PIXI.DisplayObject[]} children - the array of display objects to render
     * @param {number} startIndex - the index to start from in the children array
     * @param {number} amount - the amount of children that will have their rotation uploaded
     * @param {number[]} array - The vertices to upload.
     * @param {number} stride - Stride to use for iteration.
     * @param {number} offset - Offset to start at.
     */
    uploadRotation(children, startIndex, amount, array, stride, offset) {
        for (var i = 0; i < amount; i++) {
            var spriteRotation = children[startIndex + i].rotation;
            array[offset] = spriteRotation;
            array[offset + stride] = spriteRotation;
            array[offset + (stride * 2)] = spriteRotation;
            array[offset + (stride * 3)] = spriteRotation;
            offset += stride * 4;
        }
    }
    ;
    /**
     * Uploads the Uvs
     *
     * @param {PIXI.DisplayObject[]} children - the array of display objects to render
     * @param {number} startIndex - the index to start from in the children array
     * @param {number} amount - the amount of children that will have their rotation uploaded
     * @param {number[]} array - The vertices to upload.
     * @param {number} stride - Stride to use for iteration.
     * @param {number} offset - Offset to start at.
     */
    uploadUvs(children, startIndex, amount, array, stride, offset) {
        for (var i = 0; i < amount; ++i) {
            var textureUvs = children[startIndex + i]._texture._uvs;
            if (textureUvs) {
                array[offset] = textureUvs.x0;
                array[offset + 1] = textureUvs.y0;
                array[offset + stride] = textureUvs.x1;
                array[offset + stride + 1] = textureUvs.y1;
                array[offset + (stride * 2)] = textureUvs.x2;
                array[offset + (stride * 2) + 1] = textureUvs.y2;
                array[offset + (stride * 3)] = textureUvs.x3;
                array[offset + (stride * 3) + 1] = textureUvs.y3;
                offset += stride * 4;
            }
            else {
                // TODO you know this can be easier!
                array[offset] = 0;
                array[offset + 1] = 0;
                array[offset + stride] = 0;
                array[offset + stride + 1] = 0;
                array[offset + (stride * 2)] = 0;
                array[offset + (stride * 2) + 1] = 0;
                array[offset + (stride * 3)] = 0;
                array[offset + (stride * 3) + 1] = 0;
                offset += stride * 4;
            }
        }
    }
    ;
    /**
     * Uploads the tint.
     *
     * @param {PIXI.DisplayObject[]} children - the array of display objects to render
     * @param {number} startIndex - the index to start from in the children array
     * @param {number} amount - the amount of children that will have their rotation uploaded
     * @param {number[]} array - The vertices to upload.
     * @param {number} stride - Stride to use for iteration.
     * @param {number} offset - Offset to start at.
     */
    uploadTint(children, startIndex, amount, array, stride, offset) {
        for (var i = 0; i < amount; ++i) {
            var sprite = children[startIndex + i];
            var premultiplied = sprite._texture.baseTexture.premultiplyAlpha;
            var alpha = sprite.alpha;
            // we dont call extra function if alpha is 1.0, that's faster
            var argb = alpha < 1.0 && premultiplied ? ColorSettings_1.ColorSettings.premultiplyTint(sprite._tintRGB, alpha)
                : sprite._tintRGB + (alpha * 255 << 24);
            array[offset] = argb;
            array[offset + stride] = argb;
            array[offset + (stride * 2)] = argb;
            array[offset + (stride * 3)] = argb;
            offset += stride * 4;
        }
    }
    ;
    /**
     * Destroys the ParticleRenderer.
     */
    destroy() {
        super.destroy();
        if (this.shader) {
            this.shader.destroy();
            this.shader = null;
        }
        this.tempMatrix = null;
    }
    ;
}
ParticleRenderer.vertex$2 = "attribute vec2 aVertexPosition;\r\nattribute vec2 aTextureCoord;\r\nattribute vec4 aColor;\r\n\r\nattribute vec2 aPositionCoord;\r\nattribute float aRotation;\r\n\r\nuniform mat3 translationMatrix;\r\nuniform vec4 uColor;\r\n\r\nvarying vec2 vTextureCoord;\r\nvarying vec4 vColor;\r\n\r\nvoid main(void){\r\n    float x = (aVertexPosition.x) * cos(aRotation) - (aVertexPosition.y) * sin(aRotation);\r\n    float y = (aVertexPosition.x) * sin(aRotation) + (aVertexPosition.y) * cos(aRotation);\r\n\r\n    vec2 v = vec2(x, y);\r\n    v = v + aPositionCoord;\r\n\r\n    gl_Position = vec4((translationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);\r\n\r\n    vTextureCoord = aTextureCoord;\r\n    vColor = aColor * uColor;\r\n}\r\n";
ParticleRenderer.fragment$1 = "varying vec2 vTextureCoord;\r\nvarying vec4 vColor;\r\n\r\nuniform sampler2D uSampler;\r\n\r\nvoid main(void){\r\n    vec4 color = texture2D(uSampler, vTextureCoord) * vColor;\r\n    gl_FragColor = color;\r\n}";
exports.ParticleRenderer = ParticleRenderer;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/Polygon.js":
/*!*******************************************!*\
  !*** ./js-compile/raw-pixi-ts/Polygon.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Point_1 = __webpack_require__(/*! ../flash/geom/Point */ "./js-compile/flash/geom/Point.js");
const ShapeSettings_1 = __webpack_require__(/*! ./ShapeSettings */ "./js-compile/raw-pixi-ts/ShapeSettings.js");
class Polygon {
    constructor(arg = null) {
        var arguments$1 = arguments;
        var points = [], len = arguments.length;
        while (len--) {
            points[len] = arguments$1[len];
        }
        if (Array.isArray(points[0])) {
            points = points[0];
        }
        // if this is an array of points, convert it to a flat array of numbers
        if (points[0] instanceof Point_1.Point) {
            var p = [];
            for (var i = 0, il = points.length; i < il; i++) {
                p.push(points[i].x, points[i].y);
            }
            points = p;
        }
        /**
         * An array of the points of this polygon
         *
         * @member {number[]}
         */
        this.points = points;
        /**
         * The type of the object, mainly used to avoid `instanceof` checks
         *
         * @member {number}
         * @readOnly
         * @default PIXI.SHAPES.POLY
         * @see PIXI.SHAPES
         */
        this.type = ShapeSettings_1.ShapeSettings.SHAPES.POLY;
        /**
         * `false` after moveTo, `true` after `closePath`. In all other cases it is `true`.
         * @member {boolean}
         * @default true
         */
        this.closeStroke = true;
    }
    /**
     * Creates a clone of this polygon
     *
     * @return {PIXI.Polygon} a copy of the polygon
     */
    clone() {
        var polygon = new Polygon(this.points.slice());
        polygon.closeStroke = this.closeStroke;
        return polygon;
    }
    ;
    /**
     * Checks whether the x and y coordinates passed to this function are contained within this polygon
     *
     * @param {number} x - The X coordinate of the point to test
     * @param {number} y - The Y coordinate of the point to test
     * @return {boolean} Whether the x/y coordinates are within this polygon
     */
    contains(x, y) {
        var inside = false;
        // use some raycasting to test hits
        // https://github.com/substack/point-in-polygon/blob/master/index.js
        var length = this.points.length / 2;
        for (var i = 0, j = length - 1; i < length; j = i++) {
            var xi = this.points[i * 2];
            var yi = this.points[(i * 2) + 1];
            var xj = this.points[j * 2];
            var yj = this.points[(j * 2) + 1];
            var intersect = ((yi > y) !== (yj > y)) && (x < ((xj - xi) * ((y - yi) / (yj - yi))) + xi);
            if (intersect) {
                inside = !inside;
            }
        }
        return inside;
    }
    ;
}
exports.Polygon = Polygon;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/Prepare.js":
/*!*******************************************!*\
  !*** ./js-compile/raw-pixi-ts/Prepare.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BasePrepare_1 = __webpack_require__(/*! ./BasePrepare */ "./js-compile/raw-pixi-ts/BasePrepare.js");
// import { settings } from "./settings";
const Graphics_1 = __webpack_require__(/*! ./Graphics */ "./js-compile/raw-pixi-ts/Graphics.js");
const BaseTexture_1 = __webpack_require__(/*! ./BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
class Prepare extends BasePrepare_1.BasePrepare {
    constructor(renderer) {
        super(renderer);
        this.uploadHookHelper = this.renderer;
        // Add textures and graphics to upload
        this.registerFindHook(Prepare.findGraphics);
        this.registerUploadHook(Prepare.uploadBaseTextures);
        this.registerUploadHook(Prepare.uploadGraphics);
    }
    static findGraphics(item, queue) {
        if (item instanceof Graphics_1.Graphics) {
            queue.push(item);
            return true;
        }
        return false;
    }
    static uploadBaseTextures(renderer, item) {
        if (item instanceof BaseTexture_1.BaseTexture) {
            if (!item._glTextures[renderer.CONTEXT_UID]) {
                renderer.textureManager.updateTexture(item);
            }
            return true;
        }
        return false;
    }
    static uploadGraphics(renderer, item) {
        if (item instanceof Graphics_1.Graphics) {
            if (item.dirty || item.clearDirty || !item._webGL[renderer.plugins.graphics.CONTEXT_UID]) {
                renderer.plugins.graphics.updateGraphics(item);
            }
            return true;
        }
        return false;
    }
}
exports.Prepare = Prepare;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/Program.js":
/*!*******************************************!*\
  !*** ./js-compile/raw-pixi-ts/Program.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Shader_1 = __webpack_require__(/*! ./Shader */ "./js-compile/raw-pixi-ts/Shader.js");
const CacheSettings_1 = __webpack_require__(/*! ./CacheSettings */ "./js-compile/raw-pixi-ts/CacheSettings.js");
const WebGLSettings_1 = __webpack_require__(/*! ./WebGLSettings */ "./js-compile/raw-pixi-ts/WebGLSettings.js");
class Program {
    constructor(vertexSrc, fragmentSrc, name = 'pixi-shader') {
        this.id = Program.UID$3++;
        /**
         * The vertex shader.
         *
         * @member {string}
         */
        this.vertexSrc = vertexSrc || Program.defaultVertexSrc;
        /**
         * The fragment shader.
         *
         * @member {string}
         */
        this.fragmentSrc = fragmentSrc || Program.defaultFragmentSrc;
        this.vertexSrc = this.vertexSrc.trim();
        this.fragmentSrc = this.fragmentSrc.trim();
        if (this.vertexSrc.substring(0, 8) !== '#version') {
            name = name.replace(/\s+/g, '-');
            if (CacheSettings_1.CacheSettings.nameCache[name]) {
                CacheSettings_1.CacheSettings.nameCache[name]++;
                name += "-" + (CacheSettings_1.CacheSettings.nameCache[name]);
            }
            else {
                CacheSettings_1.CacheSettings.nameCache[name] = 1;
            }
            this.vertexSrc = "#define SHADER_NAME " + name + "\n" + (this.vertexSrc);
            this.fragmentSrc = "#define SHADER_NAME " + name + "\n" + (this.fragmentSrc);
            this.vertexSrc = WebGLSettings_1.WebGLSettings.setPrecision(this.vertexSrc, WebGLSettings_1.WebGLSettings.PRECISION_VERTEX);
            this.fragmentSrc = WebGLSettings_1.WebGLSettings.setPrecision(this.fragmentSrc, WebGLSettings_1.WebGLSettings.PRECISION_FRAGMENT);
        }
        if (name == "pixi-shader-4") {
        }
        // currently this does not extract structs only default types
        this.extractData(this.vertexSrc, this.fragmentSrc);
        // this is where we store shader references..
        this.glPrograms = {};
        this.syncUniforms = null;
    }
    /**
     * Extracts the data for a buy creating a small test program
     * or reading the src directly.
     * @protected
     *
     * @param {string} [vertexSrc] - The source of the vertex shader.
     * @param {string} [fragmentSrc] - The source of the fragment shader.
     */
    extractData(vertexSrc, fragmentSrc) {
        var gl = WebGLSettings_1.WebGLSettings.getTestContext();
        if (gl) {
            var program = Program.compileProgram(gl, vertexSrc, fragmentSrc);
            this.attributeData = this.getAttributeData(program, gl);
            this.uniformData = this.getUniformData(program, gl);
            gl.deleteProgram(program);
        }
        else {
            this.uniformData = {};
            this.attributeData = {};
        }
    }
    ;
    /**
     * returns the attribute data from the program
     * @private
     *
     * @param {WebGLProgram} [program] - the WebGL program
     * @param {WebGLRenderingContext} [gl] - the WebGL context
     *
     * @returns {object} the attribute data for this program
     */
    getAttributeData(program, gl) {
        var attributes = {};
        var attributesArray = [];
        var totalAttributes = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
        for (var i = 0; i < totalAttributes; i++) {
            var attribData = gl.getActiveAttrib(program, i);
            var type = WebGLSettings_1.WebGLSettings.mapType(gl, attribData.type);
            /*eslint-disable */
            var data = {
                type: type,
                name: attribData.name,
                size: WebGLSettings_1.WebGLSettings.mapSize(type),
                location: 0,
            };
            /* eslint-enable */
            attributes[attribData.name] = data;
            attributesArray.push(data);
        }
        attributesArray.sort(function (a, b) { return (a.name > b.name) ? 1 : -1; }); // eslint-disable-line no-confusing-arrow
        for (var i$1 = 0; i$1 < attributesArray.length; i$1++) {
            attributesArray[i$1].location = i$1;
        }
        return attributes;
    }
    ;
    /**
     * returns the uniform data from the program
     * @private
     *
     * @param {webGL-program} [program] - the webgl program
     * @param {context} [gl] - the WebGL context
     *
     * @returns {object} the uniform data for this program
     */
    getUniformData(program, gl) {
        var uniforms = {};
        var totalUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
        // TODO expose this as a prop?
        // const maskRegex = new RegExp('^(projectionMatrix|uSampler|translationMatrix)$');
        // const maskRegex = new RegExp('^(projectionMatrix|uSampler|translationMatrix)$');
        for (var i = 0; i < totalUniforms; i++) {
            var uniformData = gl.getActiveUniform(program, i);
            var name = uniformData.name.replace(/\[.*?\]/, '');
            var isArray = uniformData.name.match(/\[.*?\]/, '');
            var type = WebGLSettings_1.WebGLSettings.mapType(gl, uniformData.type);
            /*eslint-disable */
            uniforms[name] = {
                type: type,
                size: uniformData.size,
                isArray: isArray,
                value: WebGLSettings_1.WebGLSettings.defaultValue(type, uniformData.size),
            };
            /* eslint-enable */
        }
        return uniforms;
    }
    ;
    /**
     * The default vertex shader source
     *
     * @static
     * @constant
     * @member {string}
     */
    static get defaultVertexSrc() {
        return Program.defaultVertex;
    }
    ;
    /**
     * The default fragment shader source
     *
     * @static
     * @constant
     * @member {string}
     */
    static get defaultFragmentSrc() {
        return Program.defaultFragment;
    }
    ;
    /**
     * A short hand function to create a program based of a vertex and fragment shader
     * this method will also check to see if there is a cached program.
     *
     * @param {string} [vertexSrc] - The source of the vertex shader.
     * @param {string} [fragmentSrc] - The source of the fragment shader.
     * @param {object} [uniforms] - Custom uniforms to use to augment the built-in ones.
     *
     * @returns {PIXI.Program} an shiny new Pixi shader!
     */
    static from(vertexSrc, fragmentSrc, name = "pixi-shader") {
        var key = vertexSrc + fragmentSrc;
        var program = CacheSettings_1.CacheSettings.ProgramCache[key];
        if (!program) {
            CacheSettings_1.CacheSettings.ProgramCache[key] = program = new Program(vertexSrc, fragmentSrc, name);
        }
        return program;
    }
    ;
    /**
 * @method compileProgram
 * @private
 * @memberof PIXI.glCore.shader
 * @param gl {WebGLRenderingContext} The current WebGL context {WebGLProgram}
 * @param vertexSrc {string|string[]} The vertex shader source as an array of strings.
 * @param fragmentSrc {string|string[]} The fragment shader source as an array of strings.
 * @param attributeLocations {Object} An attribute location map that lets you manually set the attribute locations
 * @return {WebGLProgram} the shader program
 */
    static compileProgram(gl, vertexSrc, fragmentSrc, attributeLocations = null) {
        var glVertShader = Shader_1.Shader.compileShader(gl, gl.VERTEX_SHADER, vertexSrc);
        var glFragShader = Shader_1.Shader.compileShader(gl, gl.FRAGMENT_SHADER, fragmentSrc);
        var program = gl.createProgram();
        gl.attachShader(program, glVertShader);
        gl.attachShader(program, glFragShader);
        // optionally, set the attributes manually for the program rather than letting WebGL decide..
        if (attributeLocations) {
            for (var i in attributeLocations) {
                gl.bindAttribLocation(program, attributeLocations[i], i);
            }
        }
        gl.linkProgram(program);
        // if linking fails, then log and cleanup
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            console.error('Pixi.js Error: Could not initialize shader.');
            console.error('gl.VALIDATE_STATUS', gl.getProgramParameter(program, gl.VALIDATE_STATUS));
            console.error('gl.getError()', gl.getError());
            // if there is a program info log, log it
            if (gl.getProgramInfoLog(program) !== '') {
                console.warn('Pixi.js Warning: gl.getProgramInfoLog()', gl.getProgramInfoLog(program));
            }
            gl.deleteProgram(program);
            program = null;
        }
        // clean up some shaders
        gl.deleteShader(glVertShader);
        gl.deleteShader(glFragShader);
        return program;
    }
}
Program.UID$3 = 0;
Program.defaultFragment = "varying vec2 vTextureCoord;\r\n\r\nuniform sampler2D uSampler;\r\n\r\nvoid main(void){\r\n   gl_FragColor *= texture2D(uSampler, vTextureCoord);\r\n}";
Program.defaultVertex = "attribute vec2 aVertexPosition;\r\nattribute vec2 aTextureCoord;\r\n\r\nuniform mat3 projectionMatrix;\r\n\r\nvarying vec2 vTextureCoord;\r\n\r\nvoid main(void){\r\n   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\r\n   vTextureCoord = aTextureCoord;\r\n}\r\n";
exports.Program = Program;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/ProgressEvent.js":
/*!*************************************************!*\
  !*** ./js-compile/raw-pixi-ts/ProgressEvent.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Event_1 = __webpack_require__(/*! ./Event */ "./js-compile/raw-pixi-ts/Event.js");
class ProgressEvent extends Event_1.Event {
    constructor(type, bubbles = false, cancelable = false) {
        super(type, bubbles, cancelable);
    }
    clone() {
        var event = ProgressEvent.getProgressEvent(this.type, this.bubbles, this.cancelable);
        event.bytesLoaded = this.bytesLoaded;
        event.bytesTotal = this.bytesTotal;
        event.percent = this.percent;
        return event;
    }
    get isDisposable() {
        return true;
    }
    static getProgressEvent(type, bubble = true, cancelable = true) {
        if (ProgressEvent.ProgressEventCache.length) {
            let te = ProgressEvent.ProgressEventCache[ProgressEvent.ProgressEventCache.length - 1];
            ProgressEvent.ProgressEventCache.length -= 1;
            te.reset(type, bubble, cancelable);
            return te;
        }
        return new ProgressEvent(type, bubble, cancelable);
    }
    destructor() {
        this._currentTarget = null;
        // this._legacyTarget = null;
        let index = ProgressEvent.ProgressEventCache.indexOf(this);
        if (index < 0) {
            ProgressEvent.ProgressEventCache.push(this);
        }
    }
}
ProgressEvent.ProgressEventCache = [];
ProgressEvent.PROGRESS = "progress";
exports.ProgressEvent = ProgressEvent;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/ProjectionSystem.js":
/*!****************************************************!*\
  !*** ./js-compile/raw-pixi-ts/ProjectionSystem.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const System_1 = __webpack_require__(/*! ./System */ "./js-compile/raw-pixi-ts/System.js");
const Matrix_1 = __webpack_require__(/*! ./Matrix */ "./js-compile/raw-pixi-ts/Matrix.js");
class ProjectionSystem extends System_1.System {
    constructor(renderer) {
        super(renderer);
        /**
         * Destination frame
         * @member {PIXI.Rectangle}
         * @readonly
         */
        this.destinationFrame = null;
        /**
         * Source frame
         * @member {PIXI.Rectangle}
         * @readonly
         */
        this.sourceFrame = null;
        /**
         * Default destination frame
         * @member {PIXI.Rectangle}
         * @readonly
         */
        this.defaultFrame = null;
        /**
         * Project matrix
         * @member {PIXI.Matrix}
         * @readonly
         */
        this.projectionMatrix = new Matrix_1.Matrix();
        /**
         * A transform that will be appended to the projection matrix
         * if null, nothing will be applied
         * @member {PIXI.Matrix}
         */
        this.transform = null;
    }
    /**
     * Updates the projection matrix based on a projection frame (which is a rectangle)
     *
     * @param {PIXI.Rectangle} destinationFrame - The destination frame.
     * @param {PIXI.Rectangle} sourceFrame - The source frame.
     * @param {Number} resolution - Resolution
     * @param {boolean} root - If is root
     */
    update(destinationFrame, sourceFrame, resolution, root) {
        this.destinationFrame = destinationFrame || this.destinationFrame || this.defaultFrame;
        this.sourceFrame = sourceFrame || this.sourceFrame || destinationFrame;
        this.calculateProjection(this.destinationFrame, this.sourceFrame, resolution, root);
        if (this.transform) {
            this.projectionMatrix.append(this.transform);
        }
        var renderer = this.renderer;
        renderer.globalUniforms.uniforms.projectionMatrix = this.projectionMatrix;
        renderer.globalUniforms.update();
        // this will work for now
        // but would be sweet to stick and even on the global uniforms..
        if (renderer.shader.shader) {
            renderer.shader.syncUniformGroup(renderer.shader.shader.uniforms.globals);
        }
    }
    ;
    /**
     * Updates the projection matrix based on a projection frame (which is a rectangle)
     *
     * @param {PIXI.Rectangle} destinationFrame - The destination frame.
     * @param {PIXI.Rectangle} sourceFrame - The source frame.
     * @param {Number} resolution - Resolution
     * @param {boolean} root - If is root
     */
    calculateProjection(destinationFrame, sourceFrame, resolution, root) {
        var pm = this.projectionMatrix;
        // I don't think we will need this line..
        // pm.identity();
        if (!root) {
            pm.a = (1 / destinationFrame.width * 2) * resolution;
            pm.d = (1 / destinationFrame.height * 2) * resolution;
            pm.tx = -1 - (sourceFrame.x * pm.a);
            pm.ty = -1 - (sourceFrame.y * pm.d);
        }
        else {
            pm.a = (1 / destinationFrame.width * 2) * resolution;
            pm.d = (-1 / destinationFrame.height * 2) * resolution;
            pm.tx = -1 - (sourceFrame.x * pm.a);
            pm.ty = 1 - (sourceFrame.y * pm.d);
        }
    }
    ;
    /**
     * Sets the transform of the active render target to the given matrix
     *
     * @param {PIXI.Matrix} matrix - The transformation matrix
     */
    setTransform() {
        // this._activeRenderTarget.transform = matrix;
    }
    ;
}
exports.ProjectionSystem = ProjectionSystem;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/Quad.js":
/*!****************************************!*\
  !*** ./js-compile/raw-pixi-ts/Quad.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Geometry_1 = __webpack_require__(/*! ./Geometry */ "./js-compile/raw-pixi-ts/Geometry.js");
class Quad extends Geometry_1.Geometry {
    constructor() {
        super();
        this.addAttribute('aVertexPosition', [0, 0, 1, 0, 1, 1, 0, 1]).addIndex([0, 1, 3, 2]);
    }
}
exports.Quad = Quad;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/QuadUv.js":
/*!******************************************!*\
  !*** ./js-compile/raw-pixi-ts/QuadUv.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Geometry_1 = __webpack_require__(/*! ./Geometry */ "./js-compile/raw-pixi-ts/Geometry.js");
const Buffer_1 = __webpack_require__(/*! ./Buffer */ "./js-compile/raw-pixi-ts/Buffer.js");
class QuadUv extends Geometry_1.Geometry {
    constructor() {
        super();
        /**
         * An array of vertices
         *
         * @member {Float32Array}
         */
        this.vertices = new Float32Array([
            -1, -1,
            1, -1,
            1, 1,
            -1, 1
        ]);
        /**
         * The Uvs of the quad
         *
         * @member {Float32Array}
         */
        this.uvs = new Float32Array([
            0, 0,
            1, 0,
            1, 1,
            0, 1
        ]);
        this.vertexBuffer = new Buffer_1.Buffer(this.vertices);
        this.uvBuffer = new Buffer_1.Buffer(this.uvs);
        this.addAttribute('aVertexPosition', this.vertexBuffer)
            .addAttribute('aTextureCoord', this.uvBuffer)
            .addIndex([0, 1, 2, 0, 2, 3]);
    }
    /**
     * Maps two Rectangle to the quad.
     *
     * @param {PIXI.Rectangle} targetTextureFrame - the first rectangle
     * @param {PIXI.Rectangle} destinationFrame - the second rectangle
     * @return {PIXI.Quad} Returns itself.
     */
    map(targetTextureFrame, destinationFrame) {
        var x = 0; // destinationFrame.x / targetTextureFrame.width;
        var y = 0; // destinationFrame.y / targetTextureFrame.height;
        this.uvs[0] = x;
        this.uvs[1] = y;
        this.uvs[2] = x + (destinationFrame.width / targetTextureFrame.width);
        this.uvs[3] = y;
        this.uvs[4] = x + (destinationFrame.width / targetTextureFrame.width);
        this.uvs[5] = y + (destinationFrame.height / targetTextureFrame.height);
        this.uvs[6] = x;
        this.uvs[7] = y + (destinationFrame.height / targetTextureFrame.height);
        x = destinationFrame.x;
        y = destinationFrame.y;
        this.vertices[0] = x;
        this.vertices[1] = y;
        this.vertices[2] = x + destinationFrame.width;
        this.vertices[3] = y;
        this.vertices[4] = x + destinationFrame.width;
        this.vertices[5] = y + destinationFrame.height;
        this.vertices[6] = x;
        this.vertices[7] = y + destinationFrame.height;
        this.invalidate();
        return this;
    }
    ;
    /**
     * legacy upload method, just marks buffers dirty
     * @returns {PIXI.QuadUv} Returns itself.
     */
    invalidate() {
        this.vertexBuffer._updateID++;
        this.uvBuffer._updateID++;
        return this;
    }
    ;
}
exports.QuadUv = QuadUv;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/QuadraticUtils.js":
/*!**************************************************!*\
  !*** ./js-compile/raw-pixi-ts/QuadraticUtils.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const settings_1 = __webpack_require__(/*! ./settings */ "./js-compile/raw-pixi-ts/settings.js");
class QuadraticUtils {
    static curveLength(fromX, fromY, cpX, cpY, toX, toY) {
        var ax = fromX - (2.0 * cpX) + toX;
        var ay = fromY - (2.0 * cpY) + toY;
        var bx = (2.0 * cpX) - (2.0 * fromX);
        var by = (2.0 * cpY) - (2.0 * fromY);
        var a = 4.0 * ((ax * ax) + (ay * ay));
        var b = 4.0 * ((ax * bx) + (ay * by));
        var c = (bx * bx) + (by * by);
        var s = 2.0 * Math.sqrt(a + b + c);
        var a2 = Math.sqrt(a);
        var a32 = 2.0 * a * a2;
        var c2 = 2.0 * Math.sqrt(c);
        var ba = b / a2;
        return ((a32 * s)
            + (a2 * b * (s - c2))
            + (((4.0 * c * a) - (b * b))
                * Math.log(((2.0 * a2) + ba + s) / (ba + c2)))) / (4.0 * a32);
    }
    ;
    /**
     * Calculate the points for a quadratic bezier curve and then draws it.
     * Based on: https://stackoverflow.com/questions/785097/how-do-i-implement-a-bezier-curve-in-c
     *
     * @private
     * @param {number} cpX - Control point x
     * @param {number} cpY - Control point y
     * @param {number} toX - Destination point x
     * @param {number} toY - Destination point y
     * @param {number[]} points - Points to add segments to.
     */
    static curveTo(cpX, cpY, toX, toY, points) {
        var fromX = points[points.length - 2];
        var fromY = points[points.length - 1];
        var n = settings_1.settings.GRAPHICS_CURVES._segmentsCount(QuadraticUtils.curveLength(fromX, fromY, cpX, cpY, toX, toY));
        var xa = 0;
        var ya = 0;
        for (var i = 1; i <= n; ++i) {
            var j = i / n;
            xa = fromX + ((cpX - fromX) * j);
            ya = fromY + ((cpY - fromY) * j);
            points.push(xa + (((cpX + ((toX - cpX) * j)) - xa) * j), ya + (((cpY + ((toY - cpY) * j)) - ya) * j));
        }
    }
    ;
}
exports.QuadraticUtils = QuadraticUtils;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/RenderTexture.js":
/*!*************************************************!*\
  !*** ./js-compile/raw-pixi-ts/RenderTexture.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Texture_1 = __webpack_require__(/*! ./Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const BaseRenderTexture_1 = __webpack_require__(/*! ./BaseRenderTexture */ "./js-compile/raw-pixi-ts/BaseRenderTexture.js");
class RenderTexture extends Texture_1.Texture {
    constructor(baseRenderTexture = null, frame = null) {
        super(baseRenderTexture, frame);
        var _legacyRenderer = null;
        if (!(baseRenderTexture instanceof BaseRenderTexture_1.BaseRenderTexture)) {
            /* eslint-disable prefer-rest-params, no-console */
            var width = arguments[1];
            var height = arguments[2];
            var scaleMode = arguments[3];
            var resolution = arguments[4];
            // we have an old render texture..
            console.warn(("Please use RenderTexture.create(" + width + ", " + height + ") instead of the ctor directly."));
            _legacyRenderer = arguments[0];
            /* eslint-enable prefer-rest-params, no-console */
            frame = null;
            baseRenderTexture = new BaseRenderTexture_1.BaseRenderTexture({
                width: width,
                height: height,
                scaleMode: scaleMode,
                resolution: resolution,
            });
        }
        this.legacyRenderer = _legacyRenderer;
        /**
         * This will let the renderer know if the texture is valid. If it's not then it cannot be rendered.
         *
         * @member {boolean}
         */
        this.valid = true;
        /**
         * FilterSystem temporary storage
         * @protected
         * @member {PIXI.Rectangle}
         */
        this.filterFrame = null;
        /**
        * The key for pooled texture of FilterSystem
        * @protected
        * @member {string}
        */
        this.filterPoolKey = null;
        this.updateUvs();
    }
    /**
    * Resizes the RenderTexture.
    *
    * @param {number} width - The width to resize to.
    * @param {number} height - The height to resize to.
    * @param {boolean} [resizeBaseTexture=true] - Should the baseTexture.width and height values be resized as well?
    */
    resize(width, height, resizeBaseTexture) {
        if (resizeBaseTexture === void 0) {
            resizeBaseTexture = true;
        }
        width = Math.ceil(width);
        height = Math.ceil(height);
        // TODO - could be not required..
        this.valid = (width > 0 && height > 0);
        this._frame.width = this.orig.width = width;
        this._frame.height = this.orig.height = height;
        if (resizeBaseTexture) {
            this.baseTexture.resize(width, height);
        }
        this.updateUvs();
    }
    ;
    /**
     * A short hand way of creating a render texture.
     *
     * @param {object} [options] - Options
     * @param {number} [options.width=100] - The width of the render texture
     * @param {number} [options.height=100] - The height of the render texture
     * @param {number} [options.scaleMode=PIXI.settings.SCALE_MODE] - See {@link PIXI.SCALE_MODES} for possible values
     * @param {number} [options.resolution=1] - The resolution / device pixel ratio of the texture being generated
     * @return {PIXI.RenderTexture} The new render texture
     */
    static create(options, height = null, scaleMode = null, resolution = null) {
        // fallback, old-style: create(width, height, scaleMode, resolution)
        if (typeof options === 'number') {
            /* eslint-disable prefer-rest-params */
            options = {
                width: options,
                height: arguments[1],
                scaleMode: arguments[2],
                resolution: arguments[3],
            };
            /* eslint-enable prefer-rest-params */
        }
        return new RenderTexture(new BaseRenderTexture_1.BaseRenderTexture(options));
    }
    ;
}
exports.RenderTexture = RenderTexture;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/RenderTextureSystem.js":
/*!*******************************************************!*\
  !*** ./js-compile/raw-pixi-ts/RenderTextureSystem.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const System_1 = __webpack_require__(/*! ./System */ "./js-compile/raw-pixi-ts/System.js");
const Rectangle_1 = __webpack_require__(/*! ../flash/geom/Rectangle */ "./js-compile/flash/geom/Rectangle.js");
const InstanceCounter_1 = __webpack_require__(/*! ./InstanceCounter */ "./js-compile/raw-pixi-ts/InstanceCounter.js");
class RenderTextureSystem extends System_1.System {
    constructor(renderer) {
        super(renderer);
        /**
         * The clear background color as rgba
         * @member {number[]}
         */
        this.clearColor = renderer._backgroundColorRgba;
        // TODO move this property somewhere else!
        /**
         * List of masks for the StencilSystem
         * @member {PIXI.Graphics[]}
         * @readonly
         */
        this.defaultMaskStack = [];
        // empty render texture?
        /**
         * Render texture
         * @member {PIXI.RenderTexture}
         * @readonly
         */
        this.current = null;
        /**
         * Source frame
         * @member {PIXI.Rectangle}
         * @readonly
         */
        InstanceCounter_1.InstanceCounter.addCall("Rectangle.getRectangle", "RendertextureSystem");
        this.sourceFrame = Rectangle_1.Rectangle.getRectangle();
        /**
         * Destination frame
         * @member {PIXI.Rectangle}
         * @readonly
         */
        InstanceCounter_1.InstanceCounter.addCall("Rectangle.getRectangle", "RendertextureSystem");
        this.destinationFrame = Rectangle_1.Rectangle.getRectangle();
    }
    destructor() {
        this.sourceFrame.recycle();
        this.destinationFrame.recycle();
        this.sourceFrame = null;
        this.destinationFrame = null;
    }
    /**
     * Bind the current render texture
     * @param {PIXI.RenderTexture} renderTexture
     * @param {PIXI.Rectangle} sourceFrame
     * @param {PIXI.Rectangle} destinationFrame
     */
    bind(renderTexture, sourceFrame = null, destinationFrame = null) {
        if (renderTexture === void 0) {
            renderTexture = null;
        }
        this.current = renderTexture;
        var renderer = this.renderer;
        var resolution;
        if (renderTexture) {
            var baseTexture = renderTexture.baseTexture;
            resolution = baseTexture.resolution;
            if (!destinationFrame) {
                // InstanceCounter.addCall("Rectangle.getRectangle", "RendertextureSystem bind")
                let temprect = Rectangle_1.Rectangle.DEFAULT;
                temprect.width = baseTexture.realWidth;
                temprect.height = baseTexture.realHeight;
                destinationFrame = temprect;
            }
            if (!sourceFrame) {
                sourceFrame = destinationFrame;
            }
            this.renderer.framebuffer.bind(baseTexture.framebuffer, destinationFrame);
            this.renderer.projection.update(destinationFrame, sourceFrame, resolution, false);
            this.renderer.stencil.setMaskStack(baseTexture.stencilMaskStack);
        }
        else {
            resolution = this.renderer.resolution;
            // TODO these validation checks happen deeper down..
            // thing they can be avoided..
            if (!destinationFrame) {
                // InstanceCounter.addCall("Rectangle.getRectangle", "RendertextureSystem bind")
                let tempRect = Rectangle_1.Rectangle.DEFAULT;
                tempRect.width = renderer.width;
                tempRect.height = renderer.height;
                destinationFrame = tempRect;
            }
            if (!sourceFrame) {
                sourceFrame = destinationFrame;
            }
            renderer.framebuffer.bind(null, destinationFrame);
            this.renderer.projection.update(destinationFrame, sourceFrame, resolution, true);
            this.renderer.stencil.setMaskStack(this.defaultMaskStack);
        }
        this.sourceFrame.copyFrom(sourceFrame);
        this.destinationFrame.x = destinationFrame.x / resolution;
        this.destinationFrame.y = destinationFrame.y / resolution;
        this.destinationFrame.width = destinationFrame.width / resolution;
        this.destinationFrame.height = destinationFrame.height / resolution;
    }
    ;
    /**
     * Erases the render texture and fills the drawing area with a colour
     *
     * @param {number[]} [clearColor] - The color as rgba, default to use the renderer backgroundColor
     * @return {PIXI.Renderer} Returns itself.
     */
    clear(clearColor = null) {
        if (this.current) {
            clearColor = clearColor || this.current.baseTexture.clearColor;
        }
        else {
            clearColor = clearColor || this.clearColor;
        }
        this.renderer.framebuffer.clear(clearColor[0], clearColor[1], clearColor[2], clearColor[3]);
    }
    ;
    resize() {
        // resize the root only!
        this.bind(null);
    }
    ;
    /**
     * Resets renderTexture state
     */
    reset() {
        this.bind(null);
    }
    ;
}
exports.RenderTextureSystem = RenderTextureSystem;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/Renderer.js":
/*!********************************************!*\
  !*** ./js-compile/raw-pixi-ts/Renderer.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const AbstractRenderer_1 = __webpack_require__(/*! ./AbstractRenderer */ "./js-compile/raw-pixi-ts/AbstractRenderer.js");
const UniformGroup_1 = __webpack_require__(/*! ./UniformGroup */ "./js-compile/raw-pixi-ts/UniformGroup.js");
const Matrix_1 = __webpack_require__(/*! ./Matrix */ "./js-compile/raw-pixi-ts/Matrix.js");
const Event_1 = __webpack_require__(/*! ./Event */ "./js-compile/raw-pixi-ts/Event.js");
const BatchRenderer_1 = __webpack_require__(/*! ./BatchRenderer */ "./js-compile/raw-pixi-ts/BatchRenderer.js");
const BatchSystem_1 = __webpack_require__(/*! ./BatchSystem */ "./js-compile/raw-pixi-ts/BatchSystem.js");
const RenderTextureSystem_1 = __webpack_require__(/*! ./RenderTextureSystem */ "./js-compile/raw-pixi-ts/RenderTextureSystem.js");
const FilterSystem_1 = __webpack_require__(/*! ./FilterSystem */ "./js-compile/raw-pixi-ts/FilterSystem.js");
const TextureGCSystem_1 = __webpack_require__(/*! ./TextureGCSystem */ "./js-compile/raw-pixi-ts/TextureGCSystem.js");
const ProjectionSystem_1 = __webpack_require__(/*! ./ProjectionSystem */ "./js-compile/raw-pixi-ts/ProjectionSystem.js");
const StencilSystem_1 = __webpack_require__(/*! ./StencilSystem */ "./js-compile/raw-pixi-ts/StencilSystem.js");
const FramebufferSystem_1 = __webpack_require__(/*! ./FramebufferSystem */ "./js-compile/raw-pixi-ts/FramebufferSystem.js");
const GeometrySystem_1 = __webpack_require__(/*! ./GeometrySystem */ "./js-compile/raw-pixi-ts/GeometrySystem.js");
const TextureSystem_1 = __webpack_require__(/*! ./TextureSystem */ "./js-compile/raw-pixi-ts/TextureSystem.js");
const ShaderSystem_1 = __webpack_require__(/*! ./ShaderSystem */ "./js-compile/raw-pixi-ts/ShaderSystem.js");
const StateSystem_1 = __webpack_require__(/*! ./StateSystem */ "./js-compile/raw-pixi-ts/StateSystem.js");
const ContextSystem_1 = __webpack_require__(/*! ./ContextSystem */ "./js-compile/raw-pixi-ts/ContextSystem.js");
const MaskSystem_1 = __webpack_require__(/*! ./MaskSystem */ "./js-compile/raw-pixi-ts/MaskSystem.js");
const DisplaySettings_1 = __webpack_require__(/*! ./DisplaySettings */ "./js-compile/raw-pixi-ts/DisplaySettings.js");
const TilingSpriteRenderer_1 = __webpack_require__(/*! ./TilingSpriteRenderer */ "./js-compile/raw-pixi-ts/TilingSpriteRenderer.js");
const AccessibilityManager_1 = __webpack_require__(/*! ./AccessibilityManager */ "./js-compile/raw-pixi-ts/AccessibilityManager.js");
const Extract_1 = __webpack_require__(/*! ./Extract */ "./js-compile/raw-pixi-ts/Extract.js");
const InteractionManager_1 = __webpack_require__(/*! ./InteractionManager */ "./js-compile/raw-pixi-ts/InteractionManager.js");
const ParticleRenderer_1 = __webpack_require__(/*! ./ParticleRenderer */ "./js-compile/raw-pixi-ts/ParticleRenderer.js");
const Prepare_1 = __webpack_require__(/*! ./Prepare */ "./js-compile/raw-pixi-ts/Prepare.js");
const Runner_1 = __webpack_require__(/*! ./Runner */ "./js-compile/raw-pixi-ts/Runner.js");
class Renderer extends AbstractRenderer_1.AbstractRenderer {
    constructor(options) {
        super('WebGL', options);
        this.plugins = {};
        this.type = DisplaySettings_1.DisplaySettings.RENDERER_TYPE.WEBGL;
        this.gl = null;
        this.CONTEXT_UID = 0;
        this.runners = {
            destroy: new Runner_1.Runner('destroy'),
            contextChange: new Runner_1.Runner('contextChange', 1),
            reset: new Runner_1.Runner('reset'),
            update: new Runner_1.Runner('update'),
            postrender: new Runner_1.Runner('postrender'),
            prerender: new Runner_1.Runner('prerender'),
            resize: new Runner_1.Runner('resize', 2),
        };
        this.globalUniforms = new UniformGroup_1.UniformGroup({
            projectionMatrix: new Matrix_1.Matrix(),
        }, true);
        this.addSystem(MaskSystem_1.MaskSystem, 'mask')
            .addSystem(ContextSystem_1.ContextSystem, 'context')
            .addSystem(StateSystem_1.StateSystem, 'state')
            .addSystem(ShaderSystem_1.ShaderSystem, 'shader')
            .addSystem(TextureSystem_1.TextureSystem, 'texture')
            .addSystem(GeometrySystem_1.GeometrySystem, 'geometry')
            .addSystem(FramebufferSystem_1.FramebufferSystem, 'framebuffer')
            .addSystem(StencilSystem_1.StencilSystem, 'stencil')
            .addSystem(ProjectionSystem_1.ProjectionSystem, 'projection')
            .addSystem(TextureGCSystem_1.TextureGCSystem, 'textureGC')
            .addSystem(FilterSystem_1.FilterSystem, 'filter')
            .addSystem(RenderTextureSystem_1.RenderTextureSystem, 'renderTexture')
            .addSystem(BatchSystem_1.BatchSystem, 'batch');
        this.initPlugins(Renderer.__plugins);
        if (options.context) {
            this.context.initFromContext(options.context);
        }
        else {
            this.context.initFromOptions({
                alpha: this.transparent,
                antialias: options.antialias,
                premultipliedAlpha: this.transparent,
                stencil: true,
                preserveDrawingBuffer: options.preserveDrawingBuffer,
                powerPreference: this.options.powerPreference,
            });
        }
        this.renderingToScreen = true;
        //     sayHello(this.context.webGLVersion === 2 ? 'WebGL 2' : 'WebGL 1');
        this.resize(this.options.width, this.options.height);
    }
    static registerPlugin(pluginName, ctor) {
        Renderer.__plugins = Renderer.__plugins || {};
        Renderer.__plugins[pluginName] = ctor;
    }
    ;
    initPlugins(staticMap) {
        for (var o in staticMap) {
            this.plugins[o] = new (staticMap[o])(this);
        }
    }
    ;
    addSystem(ClassRef, name) {
        if (!name) {
            name = ClassRef.name;
        }
        var system = new ClassRef(this);
        if (this[name]) {
            throw new Error(("Whoops! The name \"" + name + "\" is already in use"));
        }
        this[name] = system;
        for (var i in this.runners) {
            this.runners[i].add(system);
        }
        /**
         * Fired after rendering finishes.
         *
         * @event PIXI.Renderer#postrender
         */
        /**
         * Fired before rendering starts.
         *
         * @event PIXI.Renderer#prerender
         */
        /**
         * Fired when the WebGL context is set.
         *
         * @event PIXI.Renderer#context
         * @param {WebGLRenderingContext} gl - WebGL context.
         */
        return this;
    }
    ;
    // protected handleContextChange = (event:Event)=>
    // {
    // 	this.plugins.particle.contextChange(this.context.gl)
    // 	this.framebuffer.contextChange(this.context.gl)		
    // 	this.shader.contextChange(this.context.gl)
    // 	this.geometry.contextChange();
    // 	this.state.contextChange(this.context.gl)
    // 	this.texture.contextChange();
    // 	this.framebuffer.contextChange(this.context.gl)
    // 	this.stencil.contextChange(this.context.gl)
    // 	this.projection.contextChange(this.context.gl)
    // 	this.textureGC.contextChange(this.context.gl)
    // 	this.filter.contextChange(this.context.gl)
    // 	this.renderTexture.contextChange(this.context.gl)
    // 	this.batch.contextChange(this.context.gl)
    // 	this.mask.contextChange(this.context.gl);
    // 	this.plugins.batch.contextChange();		
    // 	this.plugins.tilingSprite.contextChange(this.context.gl)		
    // }
    render(displayObject, renderTexture = null, clear = true, transform = null, skipUpdateTransform = false) {
        this.renderingToScreen = !renderTexture;
        this.runners.prerender.run();
        // this.emit('prerender');
        this.dispatchEvent(Event_1.Event.getEvent("prerender"));
        if (this.context.isLost) {
            return;
        }
        if (!renderTexture) {
            this._lastObjectRendered = displayObject;
        }
        if (!skipUpdateTransform) {
            let cacheParent = displayObject.parent;
            displayObject.parent = this._tempDisplayObjectParent;
            displayObject.updateTransform();
            displayObject.parent = cacheParent;
        }
        this.renderTexture.bind(renderTexture);
        this.batch.currentRenderer.start();
        if (clear !== undefined ? clear : this.clearBeforeRender) {
            this.renderTexture.clear();
        }
        displayObject.render(this);
        this.batch.currentRenderer.flush();
        if (renderTexture) {
            renderTexture.baseTexture.update();
        }
        this.runners.postrender.run();
        this.dispatchEvent(Event_1.Event.getEvent("postrender"));
    }
    ;
    resize(screenWidth, screenHeight) {
        super.resize(screenWidth, screenHeight);
        this.runners.resize.run(screenWidth, screenHeight);
        // this.dispatchEvent(Event.getEvent("resize"));
    }
    ;
    reset() {
        this.runners.reset.run();
        // this.dispatchEvent(Event.getEvent("reset"));
        return this;
    }
    ;
    clear() {
        this.framebuffer.bind();
        this.framebuffer.clear();
    }
    ;
    destroy(options = null) {
        this.runners.destroy.run();
        // this.dispatchEvent(Event.getEvent("destroy"));
        super.destroy(options);
        this.gl = null;
    }
    ;
}
Renderer.__plugins = {};
exports.Renderer = Renderer;
class RendererPlugins {
    constructor(renderer) {
        this.particle = new ParticleRenderer_1.ParticleRenderer(renderer);
        this.tilingSprite = new TilingSpriteRenderer_1.TilingSpriteRenderer(renderer);
        this.accessibility = new AccessibilityManager_1.AccessibilityManager(renderer);
        this.extract = new Extract_1.Extract(renderer);
        this.interaction = new InteractionManager_1.InteractionManager(renderer);
        this.prepare = new Prepare_1.Prepare(renderer);
        this.batch = new BatchRenderer_1.BatchRenderer(renderer);
        // Loader$2.registerPlugin(BitmapFontLoader);
        // Loader$2.registerPlugin(SpritesheetLoader);	
    }
}


/***/ }),

/***/ "./js-compile/raw-pixi-ts/Resource.js":
/*!********************************************!*\
  !*** ./js-compile/raw-pixi-ts/Resource.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Event_1 = __webpack_require__(/*! ./Event */ "./js-compile/raw-pixi-ts/Event.js");
const EventDispatcher_1 = __webpack_require__(/*! ./EventDispatcher */ "./js-compile/raw-pixi-ts/EventDispatcher.js");
const Runner_1 = __webpack_require__(/*! ./Runner */ "./js-compile/raw-pixi-ts/Runner.js");
class Resource extends EventDispatcher_1.EventDispatcher {
    constructor(width = 0, height = 0) {
        super();
        /**
         * Internal width of the resource
         * @member {number}
         * @protected
         */
        this._width = width;
        /**
         * Internal height of the resource
         * @member {number}
         * @protected
         */
        this._height = height;
        /**
         * If resource has been destroyed
         * @member {boolean}
         * @readonly
         * @default false
         */
        this.destroyed = false;
        /**
         * `true` if resource is created by BaseTexture
         * useful for doing cleanup with BaseTexture destroy
         * and not cleaning up resources that were created
         * externally.
         * @member {boolean}
         * @protected
         */
        this.internal = false;
        /**
         * Mini-runner for handling resize events
         *
         * @member {Runner}
         * @private
         */
        // this.onResize = Event.getEvent("setRealSize")
        // Runner('setRealSize', 2);
        /**
         * Mini-runner for handling update events
         *
         * @member {Runner}
         * @private
         */
        // this.onUpdate = Event.getEvent("update")
        // new Runner('update');
        this.onResize = new Runner_1.Runner('setRealSize', 2);
        /**
         * Mini-runner for handling update events
         *
         * @member {Runner}
         * @private
         */
        this.onUpdate = new Runner_1.Runner('update');
    }
    /**
     * Bind to a parent BaseTexture
     *
     * @param {PIXI.BaseTexture} baseTexture - Parent texture
     */
    bind(baseTexture) {
        this.onResize.add(baseTexture);
        this.onUpdate.add(baseTexture);
        // Call a resize immediate if we already
        // have the width and height of the resource
        if (this._width || this._height) {
            this.onResize.run(this._width, this._height);
        }
        // this.onResize.add(baseTexture);
        // this.onUpdate.add(baseTexture);
        // Call a resize immediate if we already
        // have the width and height of the resource
        // if (this._width || this._height)
        // {
        // 	this.dispatchEvent(Event.getEvent("setRealSize"))
        //     // this.onResize.run(this._width, this._height);
        // }
    }
    ;
    /**
     * Unbind to a parent BaseTexture
     *
     * @param {PIXI.BaseTexture} baseTexture - Parent texture
     */
    unbind(baseTexture) {
        this.onResize.remove(baseTexture);
        this.onUpdate.remove(baseTexture);
        // this.onResize.remove(baseTexture);
        // this.onUpdate.remove(baseTexture);
    }
    ;
    /**
     * Trigger a resize event
     */
    resize(width, height) {
        if (width !== this._width || height !== this._height) {
            this._width = width;
            this._height = height;
            this.onResize.run(width, height);
            this.dispatchEvent(Event_1.Event.getEvent("setRealSize"));
            // Event.getEvent("setRealSize")
            // this.onResize.run(width, height);
        }
    }
    ;
    /**
     * Has been validated
     * @readonly
     * @member {boolean}
     */
    get valid() {
        return !!this._width && !!this._height;
    }
    ;
    /**
     * Has been updated trigger event
     */
    update(deltaTime) {
        if (!this.destroyed) {
            this.dispatchEvent(Event_1.Event.getEvent("update"));
        }
    }
    ;
    /**
     * This can be overridden to start preloading a resource
     * or do any other prepare step.
     * @protected
     * @return {Promise<void>} Handle the validate event
     */
    load() {
        return Promise.resolve();
    }
    ;
    /**
     * The width of the resource.
     *
     * @member {number}
     * @readonly
     */
    get width() {
        return this._width;
    }
    ;
    /**
     * The height of the resource.
     *
     * @member {number}
     * @readonly
     */
    get height() {
        return this._height;
    }
    ;
    /**
     * Uploads the texture or returns false if it cant for some reason. Override this.
     *
     * @param {PIXI.Renderer} renderer - yeah, renderer!
     * @param {PIXI.BaseTexture} baseTexture - the texture
     * @param {PIXI.GLTexture} glTexture - texture instance for this webgl context
     * @returns {boolean} true is success
     */
    upload(renderer, baseTexture, glTexture, source) {
        return false;
    }
    ;
    /**
     * Set the style, optional to override
     *
     * @param {PIXI.Renderer} renderer - yeah, renderer!
     * @param {PIXI.BaseTexture} baseTexture - the texture
     * @param {PIXI.GLTexture} glTexture - texture instance for this webgl context
     * @returns {boolean} `true` is success
     */
    style(renderer, baseTexture, glTexture) {
        return false;
    }
    ;
    /**
     * Clean up anything, this happens when destroying is ready.
     *
     * @protected
     */
    dispose() {
        // override
    }
    ;
    /**
     * Call when destroying resource, unbind any BaseTexture object
     * before calling this method, as reference counts are maintained
     * internally.
     */
    destroy() {
        if (!this.destroyed) {
            this.onResize.removeAll();
            this.onResize = null;
            this.onUpdate.removeAll();
            this.onUpdate = null;
            this.destroyed = true;
            this.dispose();
        }
    }
    ;
}
exports.Resource = Resource;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/ResourceLoader.js":
/*!**************************************************!*\
  !*** ./js-compile/raw-pixi-ts/ResourceLoader.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const EventDispatcher_1 = __webpack_require__(/*! ./EventDispatcher */ "./js-compile/raw-pixi-ts/EventDispatcher.js");
const Event_1 = __webpack_require__(/*! ./Event */ "./js-compile/raw-pixi-ts/Event.js");
const ProgressEvent_1 = __webpack_require__(/*! ./ProgressEvent */ "./js-compile/raw-pixi-ts/ProgressEvent.js");
class ResourceLoader extends EventDispatcher_1.EventDispatcher {
    constructor(request) {
        super();
        this.complete = (event) => {
            let promise = window.createImageBitmap(this._imageElement, 0, 0, this._imageElement.width, this._imageElement.height);
            promise.then(this.onImageBitmapCreated).catch();
        };
        this.onImageBitmapCreated = (image) => {
            this._imageData = image;
            this._clearEvents();
            this._finish();
        };
        this._onTimeout = () => {
            this.abort('Load timed out.');
        };
        this._onProgress = (event) => {
            if (event && event.lengthComputable) {
                let pe = ProgressEvent_1.ProgressEvent.getProgressEvent(ProgressEvent_1.ProgressEvent.PROGRESS);
                pe.bytesLoaded = event.loaded;
                pe.bytesTotal = event.total;
                pe.percent = event.loaded / event.total;
                this.dispatchEvent(pe);
            }
        };
        this._onError = (event) => {
            this.abort('Failed to load element using: ' + event.target.nodeName);
        };
        this._request = request;
        this._flags = 0;
        this._setFlag(ResourceLoader.STATUS_FLAGS.DATA_URL, this._request.url.indexOf('data:') === 0);
        this.extension = this._getExtension();
        this.data = null;
        this.crossOrigin = request.crossOrigin === true ? 'anonymous' : "";
        this.timeout = request.timeout || 0;
        this.loadType = this._determineLoadType();
        this.error = null;
        this.xhr = null;
        this.type = ResourceLoader.TYPE.UNKNOWN;
        this.progressChunk = 0;
        this._elementTimer = 0;
        this.metadata = request.requestMetaData;
        this.xhrType = null;
        // this.children = [];
        // this._dequeue = ResourceLoader._noop;
        // this._onLoadBinding = null;
    }
    load() {
        if (this.isLoading) {
            return;
        }
        if (this.isComplete) {
            this.dispatchEvent(Event_1.Event.getEvent(Event_1.Event.COMPLETE));
            return;
        }
        this._setFlag(ResourceLoader.STATUS_FLAGS.LOADING, true);
        if (!this.crossOrigin) {
            this.crossOrigin = this._determineCrossOrigin(this._request.url);
        }
        switch (this.loadType) {
            case ResourceLoader.LOAD_TYPE.IMAGE:
                this.type = ResourceLoader.TYPE.IMAGE;
                this._loadElement('image');
                break;
            case ResourceLoader.LOAD_TYPE.AUDIO:
                this.type = ResourceLoader.TYPE.AUDIO;
                // this._loadSourceElement('audio');
                break;
            case ResourceLoader.LOAD_TYPE.VIDEO:
                this.type = ResourceLoader.TYPE.VIDEO;
                // this._loadSourceElement('video');
                break;
            case ResourceLoader.LOAD_TYPE.XHR:
            default:
                if (ResourceLoader.useXdr && this.crossOrigin) {
                    this._loadXdr();
                }
                else {
                    this._loadXhr();
                }
                break;
        }
        // _loadSourceElement
        // _loadXdr
        // _loadXhr
    }
    ;
    /**
     * Loads this resources using an element that has multiple sources,
     * like an HTMLAudioElement or HTMLVideoElement.
     *
     * @private
     * @param {string} type - The type of element to use.
     */
    // protected _loadSourceElement(type):void
    // {
    //     if (this.metadata.loadElement) 
    //     {
    //         this.data = this.metadata.loadElement;
    //     } else if (type === 'audio' && typeof window['Audio'] !== 'undefined') {
    //         this.data = new Audio();
    //     } else {
    //         this.data = document.createElement(type);
    //     }
    //     if (this.data === null) {
    //         this.abort('Unsupported element: ' + type);
    //         return;
    //     }
    //     if (this.crossOrigin) {
    //         this.data.crossOrigin = this.crossOrigin;
    //     }
    //     if (!this.metadata.skipSource) {
    //         // support for CocoonJS Canvas+ runtime, lacks document.createElement('source')
    //         if (navigator['isCocoonJS']) {
    //             this.data.src = Array.isArray(this._request.url) ? this._request.url[0] : this._request.url;
    //         } else if (Array.isArray(this._request.url)) {
    //             var mimeTypes = this.metadata.mimeType;
    //             for (var i = 0; i < this._request.url.length; ++i) {
    //                 this.data.appendChild(this._createSource(type, this._request.url[i], Array.isArray(mimeTypes) ? mimeTypes[i] : mimeTypes));
    //             }
    //         } else {
    //             var _mimeTypes = this.metadata.mimeType;
    //             this.data.appendChild(this._createSource(type, this._request.url, Array.isArray(_mimeTypes) ? _mimeTypes[0] : _mimeTypes));
    //         }
    //     }
    //     this.data.addEventListener('error', this._boundOnError, false);
    //     this.data.addEventListener('load', this._boundComplete, false);
    //     this.data.addEventListener('progress', this._boundOnProgress, false);
    //     this.data.addEventListener('canplaythrough', this._boundComplete, false);
    //     this.data.load();
    //     if (this.timeout) {
    //         this._elementTimer = setTimeout(this._boundOnTimeout, this.timeout);
    //     }
    // };
    _clearEvents() {
        clearTimeout(this._elementTimer);
        if (this._imageElement && this._imageElement.removeEventListener) {
            this._imageElement.removeEventListener('error', this._onError);
            this._imageElement.removeEventListener('load', this.complete);
            this._imageElement.removeEventListener('progress', this._onProgress);
            this._imageElement.removeEventListener('canplaythrough', this.complete);
        }
        if (this.xhr) {
            // if (this.xhr.removeEventListener) {
            //     this.xhr.removeEventListener('error', this._boundXhrOnError, false);
            //     this.xhr.removeEventListener('timeout', this._boundXhrOnTimeout, false);
            //     this.xhr.removeEventListener('abort', this._boundXhrOnAbort, false);
            //     this.xhr.removeEventListener('progress', this._boundOnProgress, false);
            //     this.xhr.removeEventListener('load', this._boundXhrOnLoad, false);
            // } else {
            //     this.xhr.onerror = null;
            //     this.xhr.ontimeout = null;
            //     this.xhr.onprogress = null;
            //     this.xhr.onload = null;
            // }
        }
    }
    ;
    _loadElement(type) {
        this._imageElement = document.createElement("img");
        if (this.crossOrigin) {
            this._imageElement.crossOrigin = this.crossOrigin;
        }
        this._imageElement.src = this._request.url;
        this._imageElement.addEventListener('error', this._onError);
        this._imageElement.addEventListener('load', this.complete);
        this._imageElement.addEventListener('progress', this._onProgress);
        // if (this.timeout > 0) 
        // {
        //     this._elementTimer = setTimeout(this._onTimeout, this.timeout);
        // }
    }
    ;
    get imageData() {
        return this._imageData;
    }
    abort(message) {
        if (this.error) {
            return;
        }
        this.error = new Error(message);
        this._clearEvents();
        if (this.xhr) {
            this.xhr.abort();
        }
        else if (this.xdr) {
            this.xdr.abort();
        }
        else if (this.data) {
            if (this.data.src) {
                this.data.src = ResourceLoader.EMPTY_GIF;
            }
            else {
                while (this.data.firstChild) {
                    this.data.removeChild(this.data.firstChild);
                }
            }
        }
        this._finish();
    }
    ;
    _finish() {
        if (this.isComplete) {
            return;
        }
        this._setFlag(ResourceLoader.STATUS_FLAGS.COMPLETE, true);
        this._setFlag(ResourceLoader.STATUS_FLAGS.LOADING, false);
        this.dispatchEvent(Event_1.Event.getEvent(Event_1.Event.COMPLETE));
    }
    ;
    _determineCrossOrigin(url, loc = null) {
        if (url.indexOf('data:') === 0) {
            return '';
        }
        if (window['origin'] !== window.location.origin) {
            return 'anonymous';
        }
        loc = loc || window.location;
        if (!ResourceLoader.tempAnchor) {
            ResourceLoader.tempAnchor = document.createElement('a');
        }
        ResourceLoader.tempAnchor.href = url;
        let uri = ResourceLoader.parseUri(ResourceLoader.tempAnchor.href, true);
        let samePort = !uri.port && loc.port === '' || uri.port === loc.port;
        let protocol = uri.protocol ? uri.protocol + ':' : '';
        if (uri.host !== loc.hostname || !samePort || protocol !== loc.protocol) {
            return 'anonymous';
        }
        return '';
    }
    ;
    static parseUri(str, strict = true) {
        let o = {
            key: ['source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'],
            q: {
                name: 'queryKey',
                parser: /(?:^|&)([^&=]*)=?([^&]*)/g
            },
            parser: {
                strict: /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/,
                loose: /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/
            }
        };
        let m = o.parser[strict ? 'strict' : 'loose'].exec(str);
        let uri = new URIData();
        uri.source = m["source"] || '';
        uri.protocol = m["protocol"] || '';
        uri.authority = m["authority"] || '';
        uri.userInfo = m["userInfo"] || '';
        uri.user = m["user"] || '';
        uri.password = m["password"] || '';
        uri.host = m["host"] || '';
        uri.port = m["port"] || '';
        uri.relative = m["relative"] || '';
        uri.path = m["path"] || '';
        uri.directory = m["directory"] || '';
        uri.file = m["file"] || '';
        uri.query = m["query"] || '';
        uri.anchor = m["anchor"] || '';
        uri[o.q.name] = {};
        uri[o.key[12]].replace(o.q.parser, function ($0, $1, $2) {
            if ($1) {
                uri[o.q.name][$1] = $2;
            }
        });
        return uri;
    }
    ;
    _determineLoadType() {
        return ResourceLoader._loadTypeMap[this.extension] || ResourceLoader.LOAD_TYPE.XHR;
    }
    ;
    _getExtension() {
        let url = this._request.url;
        let ext = '';
        if (this.isDataUrl) {
            let slashIndex = url.indexOf('/');
            ext = url.substring(slashIndex + 1, url.indexOf(';', slashIndex));
        }
        else {
            let queryStart = url.indexOf('?');
            let hashStart = url.indexOf('#');
            let index = Math.min(queryStart > -1 ? queryStart : url.length, hashStart > -1 ? hashStart : url.length);
            url = url.substring(0, index);
            ext = url.substring(url.lastIndexOf('.') + 1);
        }
        return ext.toLowerCase();
    }
    ;
    _hasFlag(flag) {
        return (this._flags & flag) !== 0;
    }
    ;
    _setFlag(flag, value) {
        this._flags = value ? this._flags | flag : this._flags & ~flag;
    }
    ;
    static setExtMap(map, extname, val) {
        if (extname && extname.indexOf('.') === 0) {
            extname = extname.substring(1);
        }
        if (!extname) {
            return;
        }
        map[extname] = val;
    }
    static setExtensionLoadType(extname, loadType) {
        ResourceLoader.setExtMap(ResourceLoader._loadTypeMap, extname, loadType);
    }
    ;
    static setExtensionXhrType(extname, xhrType) {
        ResourceLoader.setExtMap(ResourceLoader._xhrTypeMap, extname, xhrType);
    }
    ;
    /**
     * Quick helper to get string xhr type.
     *
     * @ignore
     * @param {XMLHttpRequest|XDomainRequest} xhr - The request to check.
     * @return {string} The type.
     */
    static reqType(xhr) {
        return xhr.toString().replace('object ', '');
    }
    /**
     * Loads this resources using an XMLHttpRequest.
     *
     * @private
     */
    _loadXhr() {
        // // if unset, determine the value
        // if (typeof this.xhrType !== 'string') {
        //     this.xhrType = this._determineXhrType();
        // }
        // var xhr = this.xhr = new XMLHttpRequest();
        // // set the request type and url
        // xhr.open('GET', this._request.url, true);
        // xhr.timeout = this.timeout;
        // // load json as text and parse it ourselves. We do this because some browsers
        // // *cough* safari *cough* can't deal with it.
        // if (this.xhrType === ResourceLoader.XHR_RESPONSE_TYPE.JSON || this.xhrType === ResourceLoader.XHR_RESPONSE_TYPE.DOCUMENT) {
        //     xhr.responseType = <any>ResourceLoader.XHR_RESPONSE_TYPE.TEXT;
        // } else {
        //     xhr.responseType = this.xhrType;
        // }
        // xhr.addEventListener('error', this._boundXhrOnError, false);
        // xhr.addEventListener('timeout', this._boundXhrOnTimeout, false);
        // xhr.addEventListener('abort', this._boundXhrOnAbort, false);
        // xhr.addEventListener('progress', this._boundOnProgress, false);
        // xhr.addEventListener('load', this._boundXhrOnLoad, false);
        // xhr.send();
    }
    ;
    /**
     * Loads this resources using an XDomainRequest. This is here because we need to support IE9 (gross).
     *
     * @private
     */
    _loadXdr() {
        // // if unset, determine the value
        // if (typeof this.xhrType !== 'string') {
        //     this.xhrType = this._determineXhrType();
        // }
        // var xdr = this.xhr = new window['XDomainRequest'](); // eslint-disable-line no-undef
        // // XDomainRequest has a few quirks. Occasionally it will abort requests
        // // A way to avoid this is to make sure ALL callbacks are set even if not used
        // // More info here: http://stackoverflow.com/questions/15786966/xdomainrequest-aborts-post-on-ie-9
        // xdr.timeout = this.timeout || 5000; // XDR needs a timeout value or it breaks in IE9
        // xdr.onerror = this._boundXhrOnError;
        // xdr.ontimeout = this._boundXhrOnTimeout;
        // xdr.onprogress = this._boundOnProgress;
        // xdr.onload = this._boundXhrOnLoad;
        // xdr.open('GET', this._request.url, true);
        // // Note: The xdr.send() call is wrapped in a timeout to prevent an
        // // issue with the interface where some requests are lost if multiple
        // // XDomainRequests are being sent at the same time.
        // // Some info here: https://github.com/photonstorm/phaser/issues/1248
        // setTimeout(function () {
        //     return xdr.send();
        // }, 1);
    }
    ;
    /**
     * Creates a source used in loading via an element.
     *
     * @private
     * @param {string} type - The element type (video or audio).
     * @param {string} url - The source URL to load from.
     * @param {string} [mime] - The mime type of the video
     * @return {HTMLSourceElement} The source element.
     */
    _createSource(type, url, mime) {
        // if (!mime) {
        //     mime = type + '/' + this._getExtension(url);
        // }
        // var source = document.createElement('source');
        // source.src = url;
        // source.type = mime;
        // return source;
    }
    ;
    /**
     * Called if an error event fires for xhr/xdr.
     *
     * @private
     */
    _xhrOnError() {
        var xhr = this.xhr;
        this.abort(ResourceLoader.reqType(xhr) + ' Request failed. Status: ' + xhr.status + ', text: "' + xhr.statusText + '"');
    }
    ;
    /**
     * Called if an error event fires for xhr/xdr.
     *
     * @private
     */
    _xhrOnTimeout() {
        var xhr = this.xhr;
        this.abort(ResourceLoader.reqType(xhr) + ' Request timed out.');
    }
    ;
    /**
     * Called if an abort event fires for xhr/xdr.
     *
     * @private
     */
    _xhrOnAbort() {
        var xhr = this.xhr;
        this.abort(ResourceLoader.reqType(xhr) + ' Request was aborted by the user.');
    }
    ;
    /**
     * Called when data successfully loads from an xhr/xdr request.
     *
     * @private
     * @param {XMLHttpRequestLoadEvent|Event} event - Load event
     */
    _xhrOnLoad() {
        // var xhr = this.xhr;
        // var text = '';
        // var status = typeof xhr.status === 'undefined' ? ResourceLoader.STATUS_OK : xhr.status; // XDR has no `.status`, assume 200.
        // // responseText is accessible only if responseType is '' or 'text' and on older browsers
        // if (xhr.responseType === '' || xhr.responseType === 'text' || typeof xhr.responseType === 'undefined') {
        //     text = xhr.responseText;
        // }
        // // status can be 0 when using the `file://` protocol so we also check if a response is set.
        // // If it has a response, we assume 200; otherwise a 0 status code with no contents is an aborted request.
        // if (status === ResourceLoader.STATUS_NONE && (text.length > 0 || xhr.responseType === ResourceLoader.XHR_RESPONSE_TYPE.BUFFER)) {
        //     status = ResourceLoader.STATUS_OK;
        // }
        // // handle IE9 bug: http://stackoverflow.com/questions/10046972/msie-returns-status-code-of-1223-for-ajax-request
        // else if (status === ResourceLoader.STATUS_IE_BUG_EMPTY) {
        //         status = ResourceLoader.STATUS_EMPTY;
        //     }
        // var statusType = status / 100 | 0;
        // if (statusType === ResourceLoader.STATUS_TYPE_OK) {
        //     // if text, just return it
        //     if (this.xhrType === ResourceLoader.XHR_RESPONSE_TYPE.TEXT) {
        //         this.data = text;
        //         this.type = ResourceLoader.TYPE.TEXT;
        //     }
        //     // if json, parse into json object
        //     else if (this.xhrType === ResourceLoader.XHR_RESPONSE_TYPE.JSON) {
        //             try {
        //                 this.data = JSON.parse(text);
        //                 this.type = ResourceLoader.TYPE.JSON;
        //             } catch (e) {
        //                 this.abort('Error trying to parse loaded json: ' + e);
        //                 return;
        //             }
        //         }
        //         // if xml, parse into an xml document or div element
        //         else if (this.xhrType === ResourceLoader.XHR_RESPONSE_TYPE.DOCUMENT) {
        //                 try {
        //                     if (window['DOMParser']) {
        //                         var domparser = new DOMParser();
        //                         this.data = domparser.parseFromString(text, 'text/xml');
        //                     } else {
        //                         var div = document.createElement('div');
        //                         div.innerHTML = text;
        //                         this.data = div;
        //                     }
        //                     this.type = ResourceLoader.TYPE.XML;
        //                 } catch (e) {
        //                     this.abort('Error trying to parse loaded xml: ' + e);
        //                     return;
        //                 }
        //             }
        //             // other types just return the response
        //             else {
        //                     this.data = xhr.response || text;
        //                 }
        // } else {
        //     this.abort('[' + xhr.status + '] ' + xhr.statusText + ': ' + xhr.responseURL);
        //     return;
        // }
        // this.complete();
    }
    ;
    /**
     * Determines the responseType of an XHR request based on the extension of the
     * resource being loaded.
     *
     * @private
     * @return {Resource.XHR_RESPONSE_TYPE} The responseType to use.
     */
    _determineXhrType() {
        return ResourceLoader._xhrTypeMap[this.extension] || ResourceLoader.XHR_RESPONSE_TYPE.TEXT;
    }
    ;
    /**
     * Determines the loadType of a resource based on the extension of the
     * resource being loaded.
     *
     * @private
     * @return {Resource.LOAD_TYPE} The loadType to use.
     */
    /**
     * Determines the mime type of an XHR request based on the responseType of
     * resource being loaded.
     *
     * @private
     * @param {Resource.XHR_RESPONSE_TYPE} type - The type to get a mime type for.
     * @return {string} The mime type to use.
     */
    _getMimeFromXhrType(type) {
        switch (type) {
            case ResourceLoader.XHR_RESPONSE_TYPE.BUFFER:
                return 'application/octet-binary';
            case ResourceLoader.XHR_RESPONSE_TYPE.BLOB:
                return 'application/blob';
            case ResourceLoader.XHR_RESPONSE_TYPE.DOCUMENT:
                return 'application/xml';
            case ResourceLoader.XHR_RESPONSE_TYPE.JSON:
                return 'application/json';
            case ResourceLoader.XHR_RESPONSE_TYPE.DEFAULT:
            case ResourceLoader.XHR_RESPONSE_TYPE.TEXT:
            /* falls through */
            default:
                return 'text/plain';
        }
    }
    ;
    get isDataUrl() {
        return this._hasFlag(ResourceLoader.STATUS_FLAGS.DATA_URL);
    }
    get isComplete() {
        return this._hasFlag(ResourceLoader.STATUS_FLAGS.COMPLETE);
    }
    get isLoading() {
        return this._hasFlag(ResourceLoader.STATUS_FLAGS.LOADING);
    }
}
ResourceLoader.STATUS_NONE = 0;
ResourceLoader.STATUS_OK = 200;
ResourceLoader.STATUS_EMPTY = 204;
ResourceLoader.STATUS_IE_BUG_EMPTY = 1223;
ResourceLoader.STATUS_TYPE_OK = 2;
ResourceLoader.useXdr = !!(window['XDomainRequest'] && !('withCredentials' in new XMLHttpRequest()));
ResourceLoader.EMPTY_GIF = 'data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==';
ResourceLoader.LOAD_TYPE = {
    XHR: 1,
    IMAGE: 2,
    AUDIO: 3,
    VIDEO: 4
};
ResourceLoader.XHR_RESPONSE_TYPE = {
    DEFAULT: 'text',
    BUFFER: 'arraybuffer',
    BLOB: 'blob',
    DOCUMENT: 'document',
    JSON: 'json',
    TEXT: 'text'
};
ResourceLoader._xhrTypeMap = {
    xhtml: ResourceLoader.XHR_RESPONSE_TYPE.DOCUMENT,
    html: ResourceLoader.XHR_RESPONSE_TYPE.DOCUMENT,
    htm: ResourceLoader.XHR_RESPONSE_TYPE.DOCUMENT,
    xml: ResourceLoader.XHR_RESPONSE_TYPE.DOCUMENT,
    tmx: ResourceLoader.XHR_RESPONSE_TYPE.DOCUMENT,
    svg: ResourceLoader.XHR_RESPONSE_TYPE.DOCUMENT,
    tsx: ResourceLoader.XHR_RESPONSE_TYPE.DOCUMENT,
    gif: ResourceLoader.XHR_RESPONSE_TYPE.BLOB,
    png: ResourceLoader.XHR_RESPONSE_TYPE.BLOB,
    bmp: ResourceLoader.XHR_RESPONSE_TYPE.BLOB,
    jpg: ResourceLoader.XHR_RESPONSE_TYPE.BLOB,
    jpeg: ResourceLoader.XHR_RESPONSE_TYPE.BLOB,
    tif: ResourceLoader.XHR_RESPONSE_TYPE.BLOB,
    tiff: ResourceLoader.XHR_RESPONSE_TYPE.BLOB,
    webp: ResourceLoader.XHR_RESPONSE_TYPE.BLOB,
    tga: ResourceLoader.XHR_RESPONSE_TYPE.BLOB,
    json: ResourceLoader.XHR_RESPONSE_TYPE.JSON,
    text: ResourceLoader.XHR_RESPONSE_TYPE.TEXT,
    txt: ResourceLoader.XHR_RESPONSE_TYPE.TEXT,
    ttf: ResourceLoader.XHR_RESPONSE_TYPE.BUFFER,
    otf: ResourceLoader.XHR_RESPONSE_TYPE.BUFFER
};
ResourceLoader._loadTypeMap = {
    gif: ResourceLoader.LOAD_TYPE.IMAGE,
    png: ResourceLoader.LOAD_TYPE.IMAGE,
    bmp: ResourceLoader.LOAD_TYPE.IMAGE,
    jpg: ResourceLoader.LOAD_TYPE.IMAGE,
    jpeg: ResourceLoader.LOAD_TYPE.IMAGE,
    tif: ResourceLoader.LOAD_TYPE.IMAGE,
    tiff: ResourceLoader.LOAD_TYPE.IMAGE,
    webp: ResourceLoader.LOAD_TYPE.IMAGE,
    tga: ResourceLoader.LOAD_TYPE.IMAGE,
    svg: ResourceLoader.LOAD_TYPE.IMAGE,
    'svg+xml': ResourceLoader.LOAD_TYPE.IMAGE,
    mp3: ResourceLoader.LOAD_TYPE.AUDIO,
    ogg: ResourceLoader.LOAD_TYPE.AUDIO,
    wav: ResourceLoader.LOAD_TYPE.AUDIO,
    mp4: ResourceLoader.LOAD_TYPE.VIDEO,
    webm: ResourceLoader.LOAD_TYPE.VIDEO
};
ResourceLoader.TYPE = {
    UNKNOWN: 0,
    JSON: 1,
    XML: 2,
    IMAGE: 3,
    AUDIO: 4,
    VIDEO: 5,
    TEXT: 6
};
ResourceLoader.STATUS_FLAGS = {
    NONE: 0,
    DATA_URL: 1 << 0,
    COMPLETE: 1 << 1,
    LOADING: 1 << 2
};
exports.ResourceLoader = ResourceLoader;
class URIData {
}


/***/ }),

/***/ "./js-compile/raw-pixi-ts/ResourceSettings.js":
/*!****************************************************!*\
  !*** ./js-compile/raw-pixi-ts/ResourceSettings.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const ImageResource_1 = __webpack_require__(/*! ./ImageResource */ "./js-compile/raw-pixi-ts/ImageResource.js");
const CanvasResource_1 = __webpack_require__(/*! ./CanvasResource */ "./js-compile/raw-pixi-ts/CanvasResource.js");
const VideoResource_1 = __webpack_require__(/*! ./VideoResource */ "./js-compile/raw-pixi-ts/VideoResource.js");
const SVGResource_1 = __webpack_require__(/*! ./SVGResource */ "./js-compile/raw-pixi-ts/SVGResource.js");
const BufferResource_1 = __webpack_require__(/*! ./BufferResource */ "./js-compile/raw-pixi-ts/BufferResource.js");
const CubeResource_1 = __webpack_require__(/*! ./CubeResource */ "./js-compile/raw-pixi-ts/CubeResource.js");
const ArrayResource_1 = __webpack_require__(/*! ./ArrayResource */ "./js-compile/raw-pixi-ts/ArrayResource.js");
class ResourceSettings {
    static autoDetectResource(source, options) {
        if (!source) {
            return null;
        }
        var extension = '';
        if (typeof source === 'string') {
            var result = (/\.(\w{3,4})(?:$|\?|#)/i).exec(source);
            if (result) {
                extension = result[1].toLowerCase();
            }
        }
        for (var i = ResourceSettings.INSTALLED.length - 1; i >= 0; --i) {
            var ResourcePlugin = ResourceSettings.INSTALLED[i];
            if (ResourcePlugin.test && ResourcePlugin.test(source, extension)) {
                return new ResourcePlugin(source, options);
            }
        }
        return new ImageResource_1.ImageResource(source, options);
    }
}
ResourceSettings.INSTALLED = [
    ImageResource_1.ImageResource,
    CanvasResource_1.CanvasResource,
    VideoResource_1.VideoResource,
    SVGResource_1.SVGResource,
    BufferResource_1.BufferResource,
    CubeResource_1.CubeResource,
    ArrayResource_1.ArrayResource
];
exports.ResourceSettings = ResourceSettings;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/RopeGeometry.js":
/*!************************************************!*\
  !*** ./js-compile/raw-pixi-ts/RopeGeometry.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const MeshGeometry_1 = __webpack_require__(/*! ./MeshGeometry */ "./js-compile/raw-pixi-ts/MeshGeometry.js");
class RopeGeometry extends MeshGeometry_1.MeshGeometry {
    constructor(width = 200, points = null) {
        if (width === void 0) {
            width = 200;
        }
        super(new Float32Array(points.length * 4), new Float32Array(points.length * 4), new Uint16Array((points.length - 1) * 6));
        /**
        * An array of points that determine the rope
        * @member {PIXI.Point[]}
        */
        this.points = points;
        /**
        * The width (i.e., thickness) of the rope.
        * @member {number}
        * @readOnly
        */
        this.width = width;
        this.build();
    }
    /**
    * Refreshes Rope indices and uvs
    * @private
    */
    build() {
        var points = this.points;
        if (!points) {
            return;
        }
        var vertexBuffer = this.getAttribute('aVertexPosition');
        var uvBuffer = this.getAttribute('aTextureCoord');
        var indexBuffer = this.getIndex();
        // if too little points, or texture hasn't got UVs set yet just move on.
        if (points.length < 1) {
            return;
        }
        // if the number of points has changed we will need to recreate the arraybuffers
        if (vertexBuffer.data.length / 4 !== points.length) {
            vertexBuffer.data = new Float32Array(points.length * 4);
            uvBuffer.data = new Float32Array(points.length * 4);
            indexBuffer.data = new Uint16Array((points.length - 1) * 6);
        }
        var uvs = uvBuffer.data;
        var indices = indexBuffer.data;
        uvs[0] = 0;
        uvs[1] = 0;
        uvs[2] = 0;
        uvs[3] = 1;
        // indices[0] = 0;
        // indices[1] = 1;
        var total = points.length; // - 1;
        for (var i = 0; i < total; i++) {
            // time to do some smart drawing!
            var index = i * 4;
            var amount = i / (total - 1);
            uvs[index] = amount;
            uvs[index + 1] = 0;
            uvs[index + 2] = amount;
            uvs[index + 3] = 1;
        }
        var indexCount = 0;
        for (var i$1 = 0; i$1 < total - 1; i$1++) {
            var index$1 = i$1 * 2;
            indices[indexCount++] = index$1;
            indices[indexCount++] = index$1 + 1;
            indices[indexCount++] = index$1 + 2;
            indices[indexCount++] = index$1 + 2;
            indices[indexCount++] = index$1 + 1;
            indices[indexCount++] = index$1 + 3;
        }
        // ensure that the changes are uploaded
        uvBuffer.update();
        indexBuffer.update();
        this.updateVertices();
    }
    ;
    /**
    * refreshes vertices of Rope mesh
    */
    updateVertices() {
        var points = this.points;
        if (points.length < 1) {
            return;
        }
        var lastPoint = points[0];
        var nextPoint;
        var perpX = 0;
        var perpY = 0;
        // this.count -= 0.2;
        var vertices = this.buffers[0].data;
        var total = points.length;
        for (var i = 0; i < total; i++) {
            var point = points[i];
            var index = i * 4;
            if (i < points.length - 1) {
                nextPoint = points[i + 1];
            }
            else {
                nextPoint = point;
            }
            perpY = -(nextPoint.x - lastPoint.x);
            perpX = nextPoint.y - lastPoint.y;
            var perpLength = Math.sqrt((perpX * perpX) + (perpY * perpY));
            var num = this.width / 2; // (20 + Math.abs(Math.sin((i + this.count) * 0.3) * 50) )* ratio;
            perpX /= perpLength;
            perpY /= perpLength;
            perpX *= num;
            perpY *= num;
            vertices[index] = point.x + perpX;
            vertices[index + 1] = point.y + perpY;
            vertices[index + 2] = point.x - perpX;
            vertices[index + 3] = point.y - perpY;
            lastPoint = point;
        }
        this.buffers[0].update();
    }
    ;
    update() {
        this.updateVertices();
    }
    ;
}
exports.RopeGeometry = RopeGeometry;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/RoundedRectangle.js":
/*!****************************************************!*\
  !*** ./js-compile/raw-pixi-ts/RoundedRectangle.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const ShapeSettings_1 = __webpack_require__(/*! ./ShapeSettings */ "./js-compile/raw-pixi-ts/ShapeSettings.js");
class RoundedRectangle {
    constructor(x = 0, y = 0, width = 0, height = 0, radius = 20) {
        if (x === void 0) {
            x = 0;
        }
        if (y === void 0) {
            y = 0;
        }
        if (width === void 0) {
            width = 0;
        }
        if (height === void 0) {
            height = 0;
        }
        if (radius === void 0) {
            radius = 20;
        }
        /**
         * @member {number}
         * @default 0
         */
        this.x = x;
        /**
         * @member {number}
         * @default 0
         */
        this.y = y;
        /**
         * @member {number}
         * @default 0
         */
        this.width = width;
        /**
         * @member {number}
         * @default 0
         */
        this.height = height;
        /**
         * @member {number}
         * @default 20
         */
        this.radius = radius;
        /**
         * The type of the object, mainly used to avoid `instanceof` checks
         *
         * @member {number}
         * @readonly
         * @default PIXI.SHAPES.RREC
         * @see PIXI.SHAPES
         */
        this.type = ShapeSettings_1.ShapeSettings.SHAPES.RREC;
    }
    /**
     * Creates a clone of this Rounded Rectangle
     *
     * @return {PIXI.RoundedRectangle} a copy of the rounded rectangle
     */
    clone() {
        return new RoundedRectangle(this.x, this.y, this.width, this.height, this.radius);
    }
    ;
    /**
     * Checks whether the x and y coordinates given are contained within this Rounded Rectangle
     *
     * @param {number} x - The X coordinate of the point to test
     * @param {number} y - The Y coordinate of the point to test
     * @return {boolean} Whether the x/y coordinates are within this Rounded Rectangle
     */
    contains(x, y) {
        if (this.width <= 0 || this.height <= 0) {
            return false;
        }
        if (x >= this.x && x <= this.x + this.width) {
            if (y >= this.y && y <= this.y + this.height) {
                if ((y >= this.y + this.radius && y <= this.y + this.height - this.radius)
                    || (x >= this.x + this.radius && x <= this.x + this.width - this.radius)) {
                    return true;
                }
                var dx = x - (this.x + this.radius);
                var dy = y - (this.y + this.radius);
                var radius2 = this.radius * this.radius;
                if ((dx * dx) + (dy * dy) <= radius2) {
                    return true;
                }
                dx = x - (this.x + this.width - this.radius);
                if ((dx * dx) + (dy * dy) <= radius2) {
                    return true;
                }
                dy = y - (this.y + this.height - this.radius);
                if ((dx * dx) + (dy * dy) <= radius2) {
                    return true;
                }
                dx = x - (this.x + this.radius);
                if ((dx * dx) + (dy * dy) <= radius2) {
                    return true;
                }
            }
        }
        return false;
    }
    ;
}
exports.RoundedRectangle = RoundedRectangle;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/Runner.js":
/*!******************************************!*\
  !*** ./js-compile/raw-pixi-ts/Runner.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class Runner {
    constructor(name, priority = 0) {
        this.items = [];
        this._name = name;
        this.dispatch = this.emit;
        this.run = this.emit;
    }
    emit(a0, a1, a2, a3, a4, a5, a6, a7) {
        if (arguments.length > 8) {
            throw new Error('max arguments reached');
        }
        var ref = this;
        var name = ref.name;
        var items = ref.items;
        for (var i = 0, len = items.length; i < len; i++) {
            items[i][name](a0, a1, a2, a3, a4, a5, a6, a7);
        }
        return this;
    }
    ;
    /**
     * Add a listener to the Runner
     *
     * Runners do not need to have scope or functions passed to them.
     * All that is required is to pass the listening object and ensure that it has contains a function that has the same name
     * as the name provided to the Runner when it was created.
     *
     * Eg A listener passed to this Runner will require a 'complete' function.
     *
     * ```
     * const complete = new PIXI.Runner('complete');
     * ```
     *
     * The scope used will be the object itself.
     *
     * @param {any} item - The object that will be listening.
     */
    add(item) {
        if (item[this._name]) {
            this.remove(item);
            this.items.push(item);
        }
        return this;
    }
    ;
    /**
     * Remove a single listener from the dispatch queue.
     * @param {any} item - The listenr that you would like to remove.
     */
    remove(item) {
        var index = this.items.indexOf(item);
        if (index !== -1) {
            this.items.splice(index, 1);
        }
        return this;
    }
    ;
    /**
     * Check to see if the listener is already in the Runner
     * @param {any} item - The listener that you would like to check.
     */
    contains(item) {
        return this.items.indexOf(item) !== -1;
    }
    ;
    /**
     * Remove all listeners from the Runner
     */
    removeAll() {
        this.items.length = 0;
        return this;
    }
    ;
    /**
     * Remove all references, don't use after this.
     */
    destroy() {
        this.removeAll();
        this.items = null;
        this._name = null;
    }
    ;
    /**
     * `true` if there are no this Runner contains no listeners
     *
     * @member {boolean}
     * @readonly
     */
    get empty() {
        return this.items.length === 0;
    }
    ;
    /**
     * The name of the runner.
     *
     * @member {string}
     * @readonly
     */
    get name() {
        return this._name;
    }
    ;
}
exports.Runner = Runner;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/SVGResource.js":
/*!***********************************************!*\
  !*** ./js-compile/raw-pixi-ts/SVGResource.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseImageResource_1 = __webpack_require__(/*! ./BaseImageResource */ "./js-compile/raw-pixi-ts/BaseImageResource.js");
const settings_1 = __webpack_require__(/*! ./settings */ "./js-compile/raw-pixi-ts/settings.js");
const MathSettings_1 = __webpack_require__(/*! ./MathSettings */ "./js-compile/raw-pixi-ts/MathSettings.js");
class SVGResource extends BaseImageResource_1.BaseImageResource {
    constructor(source, options) {
        options = options || {};
        super(document.createElement('canvas'));
        /**
         * Base64 encoded SVG element or URL for SVG file
         * @readonly
         * @member {string}
         */
        this.svg = source;
        /**
         * The source scale to apply to render
         * @readonly
         * @member {number}
         */
        this.scale = options.scale || 1;
        /**
         * Call when completely loaded
         * @private
         * @member {function}
         */
        this._resolve = null;
        /**
         * Promise when loading
         * @member {Promise<void>}
         * @private
         * @default null
         */
        this._load = null;
        if (options.autoLoad !== false) {
            this.load();
        }
    }
    load() {
        var this$1 = this;
        if (this._load) {
            return this._load;
        }
        this._load = new Promise(function (resolve) {
            // Save this until after load is finished
            this$1._resolve = function () {
                this$1.resize(this$1.source.width, this$1.source.height);
                resolve(this$1);
            };
            // Convert SVG inline string to data-uri
            if ((/^\<svg/).test(this$1.svg.trim())) {
                this$1.svg = "data:image/svg+xml;utf8," + (this$1.svg);
            }
            // Checks if `source` is an SVG image and whether it's
            // loaded via a URL or a data URI. Then calls
            // `_loadDataUri` or `_loadXhr`.
            var dataUri = settings_1.settings.decomposeDataUri(this$1.svg);
            if (dataUri) {
                this$1._loadDataUri(dataUri);
            }
            else {
                // We got an URL, so we need to do an XHR to check the svg size
                this$1._loadXhr();
            }
        });
        return this._load;
    }
    ;
    /**
     * Reads an SVG string from data URI and then calls `_loadString`.
     *
     * @param {string} dataUri - The data uri to load from.
     */
    _loadDataUri(dataUri) {
        var svgString;
        if (dataUri.encoding === 'base64') {
            if (!atob) {
                throw new Error('Your browser doesn\'t support base64 conversions.');
            }
            svgString = atob(dataUri.data);
        }
        else {
            svgString = dataUri.data;
        }
        this._loadString(svgString);
    }
    ;
    /**
     * Loads an SVG string from `imageUrl` using XHR and then calls `_loadString`.
     *
     * @private
     */
    _loadXhr() {
        var this$1 = this;
        var svgXhr = new XMLHttpRequest();
        // This throws error on IE, so SVG Document can't be used
        // svgXhr.responseType = 'document';
        // This is not needed since we load the svg as string (breaks IE too)
        // but overrideMimeType() can be used to force the response to be parsed as XML
        // svgXhr.overrideMimeType('image/svg+xml');
        svgXhr.onload = function () {
            if (svgXhr.readyState !== svgXhr.DONE || svgXhr.status !== 200) {
                throw new Error('Failed to load SVG using XHR.');
            }
            this$1._loadString(svgXhr.response);
        };
        // svgXhr.onerror = () => this.emit('error', this);
        svgXhr.open('GET', this.svg, true);
        svgXhr.send();
    }
    ;
    /**
     * Loads texture using an SVG string. The original SVG Image is stored as `origSource` and the
     * created canvas is the new `source`. The SVG is scaled using `sourceScale`. Called by
     * `_loadXhr` or `_loadDataUri`.
     *
     * @private
     * @param  {string} svgString SVG source as string
     *
     * @fires loaded
     */
    _loadString(svgString) {
        var svgSize = SVGResource.getSize(svgString);
        // TODO do we need to wait for this to load?
        // seems instant!
        //
        var tempImage = new Image();
        tempImage.src = "data:image/svg+xml," + svgString;
        var svgWidth = svgSize.width;
        var svgHeight = svgSize.height;
        if (!svgWidth || !svgHeight) {
            throw new Error('The SVG image must have width and height defined (in pixels), canvas API needs them.');
        }
        // Scale realWidth and realHeight
        this._width = Math.round(svgWidth * this.scale);
        this._height = Math.round(svgHeight * this.scale);
        // Create a canvas element
        var canvas = this.source;
        canvas.width = this._width;
        canvas.height = this._height;
        canvas._pixiId = "canvas_" + (MathSettings_1.MathSettings.uid());
        // Draw the Svg to the canvas
        canvas
            .getContext('2d')
            .drawImage(tempImage, 0, 0, svgWidth, svgHeight, 0, 0, this.width, this.height);
        this._resolve();
        this._resolve = null;
    }
    ;
    /**
     * Typedef for Size object.
     *
     * @memberof PIXI.resources.SVGResource
     * @typedef {object} Size
     * @property {number} width - Width component
     * @property {number} height - Height component
     */
    /**
     * Get size from an svg string using regexp.
     *
     * @method
     * @param {string} svgString - a serialized svg element
     * @return {PIXI.resources.SVGResource.Size} image extension
     */
    static getSize(svgString) {
        var sizeMatch = SVGResource.SVG_SIZE.exec(svgString);
        var size = {};
        if (sizeMatch) {
            size[sizeMatch[1]] = Math.round(parseFloat(sizeMatch[3]));
            size[sizeMatch[5]] = Math.round(parseFloat(sizeMatch[7]));
        }
        return size;
    }
    ;
    /**
     * Destroys this texture
     * @override
     */
    dispose() {
        BaseImageResource_1.BaseImageResource.prototype.dispose.call(this);
        this._resolve = null;
    }
    ;
    /**
     * Used to auto-detect the type of resource.
     *
     * @static
     * @param {*} source - The source object
     * @param {string} extension - The extension of source, if set
     */
    static test(source, extension) {
        // url file extension is SVG
        return extension === 'svg'
            // source is SVG data-uri
            || (typeof source === 'string' && source.indexOf('data:image/svg+xml') === 0);
    }
    ;
}
/**
* RegExp for SVG size.
*
* @static
* @constant {RegExp|string} SVG_SIZE
* @memberof PIXI.resources.SVGResource
* @example &lt;svg width="100" height="100"&gt;&lt;/svg&gt;
*/
SVGResource.SVG_SIZE = /<svg[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*>/i; // eslint-disable-line max-len
exports.SVGResource = SVGResource;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/Shader.js":
/*!******************************************!*\
  !*** ./js-compile/raw-pixi-ts/Shader.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const UniformGroup_1 = __webpack_require__(/*! ./UniformGroup */ "./js-compile/raw-pixi-ts/UniformGroup.js");
const Program_1 = __webpack_require__(/*! ./Program */ "./js-compile/raw-pixi-ts/Program.js");
const FlashBaseObject_1 = __webpack_require__(/*! ./FlashBaseObject */ "./js-compile/raw-pixi-ts/FlashBaseObject.js");
class Shader extends FlashBaseObject_1.FlashBaseObject {
    constructor(program, uniforms) {
        super();
        this.program = program;
        // lets see whats been passed in
        // uniforms should be converted to a uniform group
        if (uniforms) {
            if (uniforms instanceof UniformGroup_1.UniformGroup) {
                this.uniformGroup = uniforms;
            }
            else {
                this.uniformGroup = new UniformGroup_1.UniformGroup(uniforms);
            }
        }
        else {
            this.uniformGroup = new UniformGroup_1.UniformGroup({});
        }
        // time to build some getters and setters!
        // I guess down the line this could sort of generate an instruction list rather than use dirty ids?
        // does the trick for now though!
        for (var i in program.uniformData) {
            if (this.uniformGroup.uniforms[i] instanceof Array) {
                this.uniformGroup.uniforms[i] = new Float32Array(this.uniformGroup.uniforms[i]);
            }
        }
    }
    // TODO move to shader system..
    checkUniformExists(name, group) {
        if (group.uniforms[name]) {
            return true;
        }
        for (var i in group.uniforms) {
            var uniform = group.uniforms[i];
            if (uniform.group) {
                if (this.checkUniformExists(name, uniform)) {
                    return true;
                }
            }
        }
        return false;
    }
    ;
    destroy() {
        // usage count on programs?
        // remove if not used!
        this.uniformGroup = null;
    }
    ;
    /**
     * Shader uniform values, shortcut for `uniformGroup.uniforms`
     * @readonly
     * @member {object}
     */
    get uniforms() {
        return this.uniformGroup.uniforms;
    }
    ;
    /**
     * A short hand function to create a shader based of a vertex and fragment shader
     *
     * @param {string} [vertexSrc] - The source of the vertex shader.
     * @param {string} [fragmentSrc] - The source of the fragment shader.
     * @param {object} [uniforms] - Custom uniforms to use to augment the built-in ones.
     *
     * @returns {PIXI.Shader} an shiny new Pixi shader!
     */
    static from(vertexSrc, fragmentSrc, uniforms) {
        var program = Program_1.Program.from(vertexSrc, fragmentSrc);
        return new Shader(program, uniforms);
    }
    ;
    /**
 * @private
 * @param gl {WebGLRenderingContext} The current WebGL context {WebGLProgram}
 * @param type {Number} the type, can be either VERTEX_SHADER or FRAGMENT_SHADER
 * @param vertexSrc {string|string[]} The vertex shader source as an array of strings.
 * @return {WebGLShader} the shader
 */
    static compileShader(gl, type, src) {
        var shader = gl.createShader(type);
        gl.shaderSource(shader, src);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            console.warn(src);
            console.error(gl.getShaderInfoLog(shader));
            return null;
        }
        return shader;
    }
}
exports.Shader = Shader;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/ShaderSystem.js":
/*!************************************************!*\
  !*** ./js-compile/raw-pixi-ts/ShaderSystem.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const System_1 = __webpack_require__(/*! ./System */ "./js-compile/raw-pixi-ts/System.js");
const Program_1 = __webpack_require__(/*! ./Program */ "./js-compile/raw-pixi-ts/Program.js");
const GLProgram_1 = __webpack_require__(/*! ./GLProgram */ "./js-compile/raw-pixi-ts/GLProgram.js");
const StateSystem_1 = __webpack_require__(/*! ./StateSystem */ "./js-compile/raw-pixi-ts/StateSystem.js");
const UtilsSettings_1 = __webpack_require__(/*! ./UtilsSettings */ "./js-compile/raw-pixi-ts/UtilsSettings.js");
const WebGLSettings_1 = __webpack_require__(/*! ./WebGLSettings */ "./js-compile/raw-pixi-ts/WebGLSettings.js");
class ShaderSystem extends System_1.System {
    constructor(renderer) {
        super(renderer);
        // Validation check that this environment support `new Function`
        this.systemCheck();
        /**
         * The current WebGL rendering context
         *
         * @member {WebGLRenderingContext}
         */
        this.gl = null;
        this.shader = null;
        this.program = null;
        /**
         * Cache to holds the generated functions. Stored against UniformObjects unique signature
         * @type {Object}
         * @private
         */
        this.cache = {};
        this.id = StateSystem_1.StateSystem.UID$4++;
    }
    /**
     * Overrideable function by `@pixi/unsafe-eval` to silence
     * throwing an error if platform doesn't support unsafe-evals.
     *
     * @private
     */
    systemCheck() {
        if (!UtilsSettings_1.UtilsSettings.unsafeEvalSupported()) {
            throw new Error('Current environment does not allow unsafe-eval, '
                + 'please use @pixi/unsafe-eval module to enable support.');
        }
    }
    ;
    contextChange(gl) {
        this.gl = gl;
    }
    ;
    /**
     * Changes the current shader to the one given in parameter
     *
     * @param {PIXI.Shader} shader - the new shader
     * @param {boolean} dontSync - false if the shader should automatically sync its uniforms.
     * @returns {PIXI.GLProgram} the glProgram that belongs to the shader.
     */
    bind(shader, dontSync = false) {
        shader.uniforms.globals = this.renderer.globalUniforms;
        var program = shader.program;
        var glProgram = program.glPrograms[this.renderer.CONTEXT_UID] || this.generateShader(shader);
        this.shader = shader;
        // TODO - some current Pixi plugins bypass this.. so it not safe to use yet..
        if (this.program !== program) {
            this.program = program;
            this.gl.useProgram(glProgram.program);
        }
        if (!dontSync) {
            this.syncUniformGroup(shader.uniformGroup);
        }
        return glProgram;
    }
    ;
    /**
     * Uploads the uniforms values to the currently bound shader.
     *
     * @param {object} uniforms - the uniforms values that be applied to the current shader
     */
    setUniforms(uniforms) {
        var shader = this.shader.program;
        var glProgram = shader.glPrograms[this.renderer.CONTEXT_UID];
        shader.syncUniforms(glProgram.uniformData, uniforms, this.renderer);
    }
    ;
    syncUniformGroup(group) {
        var glProgram = this.getglProgram();
        if (!group.static || group.dirtyId !== glProgram.uniformGroups[group.id]) {
            glProgram.uniformGroups[group.id] = group.dirtyId;
            this.syncUniforms(group, glProgram);
        }
    }
    ;
    /**
     * Overrideable by the @pixi/unsafe-eval package to use static
     * syncUnforms instead.
     *
     * @private
     */
    syncUniforms(group, glProgram) {
        var syncFunc = group.syncUniforms[this.shader.program.id] || this.createSyncGroups(group);
        syncFunc(glProgram.uniformData, group.uniforms, this.renderer);
    }
    ;
    createSyncGroups(group) {
        var id = this.getSignature(group, this.shader.program.uniformData);
        if (!this.cache[id]) {
            this.cache[id] = WebGLSettings_1.WebGLSettings.generateUniformsSync(group, this.shader.program.uniformData);
        }
        group.syncUniforms[this.shader.program.id] = this.cache[id];
        return group.syncUniforms[this.shader.program.id];
    }
    ;
    /**
     * Takes a uniform group and data and generates a unique signature for them.
     *
     * @param {PIXI.UniformGroup} group the uniform group to get signature of
     * @param {Object} uniformData uniform information generated by the shader
     * @returns {String} Unique signature of the uniform group
     * @private
     */
    getSignature(group, uniformData) {
        var uniforms = group.uniforms;
        var strings = [];
        for (var i in uniforms) {
            strings.push(i);
            if (uniformData[i]) {
                strings.push(uniformData[i].type);
            }
        }
        return strings.join('-');
    }
    ;
    /**
     * Returns the underlying GLShade rof the currently bound shader.
     * This can be handy for when you to have a little more control over the setting of your uniforms.
     *
     * @return {PIXI.GLProgram} the glProgram for the currently bound Shader for this context
     */
    getglProgram() {
        if (this.shader) {
            return this.shader.program.glPrograms[this.renderer.CONTEXT_UID];
        }
        return null;
    }
    ;
    /**
     * Generates a glProgram version of the Shader provided.
     *
     * @private
     * @param {PIXI.Shader} shader the shader that the glProgram will be based on.
     * @return {PIXI.GLProgram} A shiny new glProgram!
     */
    generateShader(shader) {
        var gl = this.gl;
        var program = shader.program;
        var attribMap = {};
        for (var i in program.attributeData) {
            attribMap[i] = program.attributeData[i].location;
        }
        var shaderProgram = Program_1.Program.compileProgram(gl, program.vertexSrc, program.fragmentSrc, attribMap);
        var uniformData = {};
        for (var i$1 in program.uniformData) {
            var data = program.uniformData[i$1];
            uniformData[i$1] = {
                location: gl.getUniformLocation(shaderProgram, i$1),
                value: WebGLSettings_1.WebGLSettings.defaultValue(data.type, data.size),
            };
        }
        var glProgram = new GLProgram_1.GLProgram(shaderProgram, uniformData);
        program.glPrograms[this.renderer.CONTEXT_UID] = glProgram;
        return glProgram;
    }
    ;
    /**
     * Resets ShaderSystem state, does not affect WebGL state
     */
    reset() {
        this.program = null;
        this.shader = null;
    }
    ;
    /**
     * Destroys this System and removes all its textures
     */
    destroy() {
        // TODO implement destroy method for ShaderSystem
        this.destroyed = true;
    }
    ;
}
exports.ShaderSystem = ShaderSystem;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/ShapeSettings.js":
/*!*************************************************!*\
  !*** ./js-compile/raw-pixi-ts/ShapeSettings.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class ShapeSettings {
}
/**
* Constants that identify shapes, mainly to prevent `instanceof` calls.
*
* @static
* @constant
* @name SHAPES
* @memberof PIXI
* @type {object}
* @property {number} POLY Polygon
* @property {number} RECT Rectangle
* @property {number} CIRC Circle
* @property {number} ELIP Ellipse
* @property {number} RREC Rounded Rectangle
*/
ShapeSettings.SHAPES = {
    POLY: 0,
    RECT: 1,
    CIRC: 2,
    ELIP: 3,
    RREC: 4,
};
exports.ShapeSettings = ShapeSettings;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/SimpleRope.js":
/*!**********************************************!*\
  !*** ./js-compile/raw-pixi-ts/SimpleRope.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Mesh_1 = __webpack_require__(/*! ./Mesh */ "./js-compile/raw-pixi-ts/Mesh.js");
const RopeGeometry_1 = __webpack_require__(/*! ./RopeGeometry */ "./js-compile/raw-pixi-ts/RopeGeometry.js");
const MeshMaterial_1 = __webpack_require__(/*! ./MeshMaterial */ "./js-compile/raw-pixi-ts/MeshMaterial.js");
class SimpleRope extends Mesh_1.Mesh {
    constructor(texture, points) {
        var ropeGeometry = new RopeGeometry_1.RopeGeometry(texture.height, points);
        var meshMaterial = new MeshMaterial_1.MeshMaterial(texture);
        super(ropeGeometry, meshMaterial);
        this.autoUpdate = true;
    }
    _render(renderer) {
        if (this.autoUpdate
            || this.geometry.width !== this.shader.texture.height) {
            this.geometry.width = this.shader.texture.height;
            this.geometry.update();
        }
        super._render(renderer);
    }
    ;
}
exports.SimpleRope = SimpleRope;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/Sprite.js":
/*!******************************************!*\
  !*** ./js-compile/raw-pixi-ts/Sprite.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Container_1 = __webpack_require__(/*! ./Container */ "./js-compile/raw-pixi-ts/Container.js");
const ObservablePoint_1 = __webpack_require__(/*! ./ObservablePoint */ "./js-compile/raw-pixi-ts/ObservablePoint.js");
const Texture_1 = __webpack_require__(/*! ./Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const Rectangle_1 = __webpack_require__(/*! ../flash/geom/Rectangle */ "./js-compile/flash/geom/Rectangle.js");
const Point_1 = __webpack_require__(/*! ../flash/geom/Point */ "./js-compile/flash/geom/Point.js");
const BlendModesSettings_1 = __webpack_require__(/*! ./BlendModesSettings */ "./js-compile/raw-pixi-ts/BlendModesSettings.js");
const DisplaySettings_1 = __webpack_require__(/*! ./DisplaySettings */ "./js-compile/raw-pixi-ts/DisplaySettings.js");
const MathSettings_1 = __webpack_require__(/*! ./MathSettings */ "./js-compile/raw-pixi-ts/MathSettings.js");
const InstanceCounter_1 = __webpack_require__(/*! ./InstanceCounter */ "./js-compile/raw-pixi-ts/InstanceCounter.js");
class Sprite extends Container_1.Container {
    constructor(texture) {
        super();
        /**
         * When the texture is updated, this event will fire to update the scale and frame
         *
         * @private
         */
        this._onTextureUpdate = () => {
            this._textureID = -1;
            this._textureTrimmedID = -1;
            this.cachedTint = 0xFFFFFF;
            this.uvs = this._texture._uvs.uvsFloat32;
            // so if _width is 0 then width was not set..
            if (this._width) {
                this.scale.x = MathSettings_1.MathSettings.sign(this.scale.x) * this._width / this._texture.orig.width;
            }
            if (this._height) {
                this.scale.y = MathSettings_1.MathSettings.sign(this.scale.y) * this._height / this._texture.orig.height;
            }
        };
        /**
         * The anchor sets the origin point of the texture.
         * The default is 0,0 or taken from the {@link PIXI.Texture#defaultAnchor|Texture}
         * passed to the constructor. A value of 0,0 means the texture's origin is the top left.
         * Setting the anchor to 0.5,0.5 means the texture's origin is centered.
         * Setting the anchor to 1,1 would mean the texture's origin point will be the bottom right corner.
         * Note: Updating the {@link PIXI.Texture#defaultAnchor} after a Texture is
         * created does _not_ update the Sprite's anchor values.
         *
         * @member {PIXI.ObservablePoint}
         * @private
         */
        this._anchor = new ObservablePoint_1.ObservablePoint(0, 0);
        if (texture) {
            this._anchor.setTo(texture.defaultAnchor.x, texture.defaultAnchor.y);
        }
        this._anchor.scope = this;
        this._anchor.callback = this._onAnchorUpdate;
        ;
        /**
         * The texture that the sprite is using
         *
         * @private
         * @member {PIXI.Texture}
         */
        this._texture = null;
        /**
         * The width of the sprite (this is initially set by the texture)
         *
         * @private
         * @member {number}
         */
        this._width = 0;
        /**
         * The height of the sprite (this is initially set by the texture)
         *
         * @private
         * @member {number}
         */
        this._height = 0;
        /**
         * The tint applied to the sprite. This is a hex value. A value of 0xFFFFFF will remove any tint effect.
         *
         * @private
         * @member {number}
         * @default 0xFFFFFF
         */
        this._tint = null;
        this._tintRGB = null;
        this.tint = 0xFFFFFF;
        /**
         * The blend mode to be applied to the sprite. Apply a value of `PIXI.BLEND_MODES.NORMAL` to reset the blend mode.
         *
         * @member {number}
         * @default PIXI.BLEND_MODES.NORMAL
         * @see PIXI.BLEND_MODES
         */
        this.blendMode = BlendModesSettings_1.BlendModesSettings.BLEND_MODES.NORMAL;
        /**
         * The shader that will be used to render the sprite. Set to null to remove a current shader.
         *
         * @member {PIXI.Filter|PIXI.Shader}
         */
        this.shader = null;
        /**
         * An internal cached value of the tint.
         *
         * @private
         * @member {number}
         * @default 0xFFFFFF
         */
        this.cachedTint = 0xFFFFFF;
        this.uvs = null;
        // call texture setter
        this.texture = texture || Texture_1.Texture.EMPTY;
        /**
         * this is used to store the vertex data of the sprite (basically a quad)
         *
         * @private
         * @member {Float32Array}
         */
        this.vertexData = new Float32Array(8);
        /**
         * This is used to calculate the bounds of the object IF it is a trimmed sprite
         *
         * @private
         * @member {Float32Array}
         */
        this.vertexTrimmedData = null;
        this._transformID = -1;
        this._textureID = -1;
        this._transformTrimmedID = -1;
        this._textureTrimmedID = -1;
        // Batchable stuff..
        // TODO could make this a mixin?
        this.indices = Sprite.indices;
        this.size = 4;
        this.start = 0;
        /**
         * Plugin that is responsible for rendering this element.
         * Allows to customize the rendering process without overriding '_render' & '_renderCanvas' methods.
         *
         * @member {string}
         * @default 'sprite'
         */
        this.pluginName = 'batch';
        /**
         * used to fast check if a sprite is.. a sprite!
         * @member {boolean}
         */
        this.isSprite = true;
        /**
         * Internal roundPixels field
         *
         * @member {boolean}
         * @private
         */
        this._roundPixels = DisplaySettings_1.DisplaySettings.ROUND_PIXELS;
    }
    destructor() {
        super.destructor();
        // this._anchor observablepoint
        // this._texture = null;
        this._width = null;
        this._height = null;
        this._tint = null;
        this._tintRGB = null;
        this.blendMode = null;
        // this.shader = null; Shader
        this.cachedTint = null;
        // this.uvs = null;
        this.vertexData = null;
        this.vertexTrimmedData = null;
        this._transformID = null;
        this._textureID = null;
        this._transformTrimmedID = null;
        this._textureTrimmedID = null;
        this.indices = null;
        this.size = null;
        this.start = null;
        this.pluginName = null;
        this.isSprite = null;
        this._roundPixels = null;
    }
    /**
     * Called when the anchor position updates.
     *
     * @private
     */
    _onAnchorUpdate() {
        this._transformID = -1;
        this._transformTrimmedID = -1;
    }
    ;
    /**
     * calculates worldTransform * vertices, store it in vertexData
     */
    calculateVertices() {
        var texture = this._texture;
        if (this._transformID === this.transform.worldID && this._textureID === texture._updateID) {
            return;
        }
        this._transformID = this.transform.worldID;
        this._textureID = texture._updateID;
        // set the vertex data
        var wt = this.transform.worldTransform;
        var a = wt.a;
        var b = wt.b;
        var c = wt.c;
        var d = wt.d;
        var tx = wt.tx;
        var ty = wt.ty;
        var vertexData = this.vertexData;
        var trim = texture.trim;
        var orig = texture.orig;
        var anchor = this._anchor;
        var w0 = 0;
        var w1 = 0;
        var h0 = 0;
        var h1 = 0;
        if (trim) {
            // if the sprite is trimmed and is not a tilingsprite then we need to add the extra
            // space before transforming the sprite coords.
            w1 = trim.x - (anchor.x * orig.width);
            w0 = w1 + trim.width;
            h1 = trim.y - (anchor.y * orig.height);
            h0 = h1 + trim.height;
        }
        else {
            w1 = -anchor.x * orig.width;
            w0 = w1 + orig.width;
            h1 = -anchor.y * orig.height;
            h0 = h1 + orig.height;
        }
        // xy
        vertexData[0] = (a * w1) + (c * h1) + tx;
        vertexData[1] = (d * h1) + (b * w1) + ty;
        // xy
        vertexData[2] = (a * w0) + (c * h1) + tx;
        vertexData[3] = (d * h1) + (b * w0) + ty;
        // xy
        vertexData[4] = (a * w0) + (c * h0) + tx;
        vertexData[5] = (d * h0) + (b * w0) + ty;
        // xy
        vertexData[6] = (a * w1) + (c * h0) + tx;
        vertexData[7] = (d * h0) + (b * w1) + ty;
        if (this._roundPixels) {
            for (var i = 0; i < 8; i++) {
                vertexData[i] = Math.round(vertexData[i]);
            }
        }
    }
    ;
    /**
     * calculates worldTransform * vertices for a non texture with a trim. store it in vertexTrimmedData
     * This is used to ensure that the true width and height of a trimmed texture is respected
     */
    calculateTrimmedVertices() {
        if (!this.vertexTrimmedData) {
            this.vertexTrimmedData = new Float32Array(8);
        }
        else if (this._transformTrimmedID === this.transform.worldID && this._textureTrimmedID === this._texture._updateID) {
            return;
        }
        this._transformTrimmedID = this.transform.worldID;
        this._textureTrimmedID = this._texture._updateID;
        // lets do some special trim code!
        var texture = this._texture;
        var vertexData = this.vertexTrimmedData;
        var orig = texture.orig;
        var anchor = this._anchor;
        // lets calculate the new untrimmed bounds..
        var wt = this.transform.worldTransform;
        var a = wt.a;
        var b = wt.b;
        var c = wt.c;
        var d = wt.d;
        var tx = wt.tx;
        var ty = wt.ty;
        var w1 = -anchor.x * orig.width;
        var w0 = w1 + orig.width;
        var h1 = -anchor.y * orig.height;
        var h0 = h1 + orig.height;
        // xy
        vertexData[0] = (a * w1) + (c * h1) + tx;
        vertexData[1] = (d * h1) + (b * w1) + ty;
        // xy
        vertexData[2] = (a * w0) + (c * h1) + tx;
        vertexData[3] = (d * h1) + (b * w0) + ty;
        // xy
        vertexData[4] = (a * w0) + (c * h0) + tx;
        vertexData[5] = (d * h0) + (b * w0) + ty;
        // xy
        vertexData[6] = (a * w1) + (c * h0) + tx;
        vertexData[7] = (d * h0) + (b * w1) + ty;
    }
    ;
    /**
    *
    * Renders the object using the WebGL renderer
    *
    * @protected
    * @param {PIXI.Renderer} renderer - The webgl renderer to use.
    */
    _render(renderer) {
        this.calculateVertices();
        renderer.batch.setObjectRenderer(renderer.plugins[this.pluginName]);
        renderer.plugins[this.pluginName].render(this);
    }
    ;
    /**
     * Updates the bounds of the sprite.
     *
     * @protected
     */
    _calculateBounds() {
        var trim = this._texture.trim;
        var orig = this._texture.orig;
        // First lets check to see if the current texture has a trim..
        if (!trim || (trim.width === orig.width && trim.height === orig.height)) {
            // no trim! lets use the usual calculations..
            this.calculateVertices();
            this._bounds.addQuad(this.vertexData);
        }
        else {
            // lets calculate a special trimmed bounds...
            this.calculateTrimmedVertices();
            this._bounds.addQuad(this.vertexTrimmedData);
        }
    }
    ;
    /**
     * Gets the local bounds of the sprite object.
     *
     * @param {PIXI.Rectangle} rect - The output rectangle.
     * @return {PIXI.Rectangle} The bounds.
     */
    getLocalBounds(rect) {
        // we can do a fast local bounds if the sprite has no children!
        if (this.children.length === 0) {
            this._bounds.minX = this._texture.orig.width * -this._anchor.x;
            this._bounds.minY = this._texture.orig.height * -this._anchor.y;
            this._bounds.maxX = this._texture.orig.width * (1 - this._anchor.x);
            this._bounds.maxY = this._texture.orig.height * (1 - this._anchor.y);
            if (!rect) {
                if (!this._localBoundsRect) {
                    InstanceCounter_1.InstanceCounter.addCall("Rectangle.getRectangle", "Sprite getLocalBounds");
                    this._localBoundsRect = Rectangle_1.Rectangle.getRectangle();
                }
                rect = this._localBoundsRect;
            }
            InstanceCounter_1.InstanceCounter.addCall("Rectangle.getRectangle", "Sprite getLocalBounds");
            return this._bounds.getRectangle(rect);
        }
        return Container_1.Container.prototype.getLocalBounds.call(this, rect);
    }
    ;
    /**
     * Tests if a point is inside this sprite
     *
     * @param {PIXI.Point} point - the point to test
     * @return {boolean} the result of the test
     */
    containsPoint(point) {
        let defulatpoint = Point_1.Point.DEFAULT;
        this.worldTransform.applyInverse(point, defulatpoint);
        var width = this._texture.orig.width;
        var height = this._texture.orig.height;
        var x1 = -width * this.anchor.x;
        var y1 = 0;
        if (defulatpoint.x >= x1 && defulatpoint.x < x1 + width) {
            y1 = -height * this.anchor.y;
            if (defulatpoint.y >= y1 && defulatpoint.y < y1 + height) {
                return true;
            }
        }
        return false;
    }
    ;
    /**
     * Destroys this sprite and optionally its texture and children
     *
     * @param {object|boolean} [options] - Options parameter. A boolean will act as if all options
     *  have been set to that value
     * @param {boolean} [options.children=false] - if set to true, all the children will have their destroy
     *      method called as well. 'options' will be passed on to those calls.
     * @param {boolean} [options.texture=false] - Should it destroy the current texture of the sprite as well
     * @param {boolean} [options.baseTexture=false] - Should it destroy the base texture of the sprite as well
     */
    destroy(options) {
        super.destroy(options);
        // this._texture.off('update', this._onTextureUpdate, this);
        this._anchor = null;
        var destroyTexture = typeof options === 'boolean' ? options : options && options.texture;
        if (destroyTexture) {
            var destroyBaseTexture = typeof options === 'boolean' ? options : options && options.baseTexture;
            this._texture.destroy(!!destroyBaseTexture);
        }
        this._texture = null;
        this.shader = null;
    }
    ;
    /**
     * If true PixiJS will Math.floor() x/y values when rendering, stopping pixel interpolation.
     * Advantages can include sharper image quality (like text) and faster rendering on canvas.
     * The main disadvantage is movement of objects may appear less smooth.
     * To set the global default, change {@link PIXI.settings.ROUND_PIXELS}
     *
     * @member {boolean}
     * @default false
     */
    set roundPixels(value) {
        if (this._roundPixels !== value) {
            this._transformID = -1;
        }
        this._roundPixels = value;
    }
    ;
    get roundPixels() {
        return this._roundPixels;
    }
    ;
    /**
     * The width of the sprite, setting this will actually modify the scale to achieve the value set
     *
     * @member {number}
     */
    get width() {
        return Math.abs(this.scale.x) * this._texture.orig.width;
    }
    ;
    set width(value) {
        var s = MathSettings_1.MathSettings.sign(this.scale.x) || 1;
        this.scale.x = s * value / this._texture.orig.width;
        this._width = value;
    }
    ;
    /**
     * The height of the sprite, setting this will actually modify the scale to achieve the value set
     *
     * @member {number}
     */
    get height() {
        return Math.abs(this.scale.y) * this._texture.orig.height;
    }
    ;
    set height(value) {
        var s = MathSettings_1.MathSettings.sign(this.scale.y) || 1;
        this.scale.y = s * value / this._texture.orig.height;
        this._height = value;
    }
    ;
    /**
     * The anchor sets the origin point of the text. The default value is taken from the {@link PIXI.Texture|Texture}
     * and passed to the constructor.
     *
     * The default is `(0,0)`, this means the text's origin is the top left.
     *
     * Setting the anchor to `(0.5,0.5)` means the text's origin is centered.
     *
     * Setting the anchor to `(1,1)` would mean the text's origin point will be the bottom right corner.
     *
     * If you pass only single parameter, it will set both x and y to the same value as shown in the example below.
     *
     * @example
     * const sprite = new PIXI.Sprite(texture);
     * sprite.anchor.set(0.5); // This will set the origin to center. (0.5) is same as (0.5, 0.5).
     *
     * @member {PIXI.ObservablePoint}
     */
    get anchor() {
        return this._anchor;
    }
    ;
    set anchor(value) {
        this._anchor.copyFrom(value);
    }
    ;
    /**
     * The tint applied to the sprite. This is a hex value.
     * A value of 0xFFFFFF will remove any tint effect.
     *
     * @member {number}
     * @default 0xFFFFFF
     */
    get tint() {
        return this._tint;
    }
    ;
    set tint(value) {
        this._tint = value;
        this._tintRGB = (value >> 16) + (value & 0xff00) + ((value & 0xff) << 16);
    }
    ;
    /**
     * The texture that the sprite is using
     *
     * @member {PIXI.Texture}
     */
    get texture() {
        return this._texture;
    }
    ;
    set texture(value) {
        if (this._texture === value) {
            return;
        }
        this._texture = value || Texture_1.Texture.EMPTY;
        this.cachedTint = 0xFFFFFF;
        this._textureID = -1;
        this._textureTrimmedID = -1;
        if (value) {
            // wait for the texture to load
            if (value.baseTexture.valid) {
                this._onTextureUpdate();
            }
            else {
                value.addEventListener('update', this._onTextureUpdate);
                // value.once('update', this._onTextureUpdate, this);
            }
        }
    }
    ;
}
Sprite.indices = new Uint16Array([0, 1, 2, 0, 2, 3]);
// some helper functions..
/**
 * Helper function that creates a new sprite based on the source you provide.
 * The source can be - frame id, image url, video url, canvas element, video element, base texture
 *
 * @static
 * @param {number|string|PIXI.Texture|HTMLCanvasElement|HTMLVideoElement} source Source to create texture from
 * @param {object} [options] See {@link PIXI.BaseTexture}'s constructor for options.
 * @return {PIXI.Sprite} The newly created sprite
 */
Sprite.from = function from(source, options = {}) {
    if (options == null) {
        options = {};
    }
    var texture = (source instanceof Texture_1.Texture)
        ? source
        : Texture_1.Texture.from(source, options);
    return new Sprite(texture);
};
exports.Sprite = Sprite;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/SpriteMaskFilter.js":
/*!****************************************************!*\
  !*** ./js-compile/raw-pixi-ts/SpriteMaskFilter.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Filter_1 = __webpack_require__(/*! ./Filter */ "./js-compile/raw-pixi-ts/Filter.js");
const Matrix_1 = __webpack_require__(/*! ./Matrix */ "./js-compile/raw-pixi-ts/Matrix.js");
const TextureMatrix_1 = __webpack_require__(/*! ./TextureMatrix */ "./js-compile/raw-pixi-ts/TextureMatrix.js");
class SpriteMaskFilter extends Filter_1.Filter {
    constructor(sprite) {
        var maskMatrix = new Matrix_1.Matrix();
        super(SpriteMaskFilter.vertex, SpriteMaskFilter.fragment);
        sprite.renderable = false;
        /**
         * Sprite mask
         * @member {PIXI.Sprite}
         */
        this.maskSprite = sprite;
        /**
         * Mask matrix
         * @member {PIXI.Matrix}
         */
        this.maskMatrix = maskMatrix;
    }
    /**
     * Applies the filter
     *
     * @param {PIXI.systems.FilterSystem} filterManager - The renderer to retrieve the filter from
     * @param {PIXI.RenderTexture} input - The input render target.
     * @param {PIXI.RenderTexture} output - The target to output to.
     * @param {boolean} clear - Should the output be cleared before rendering to it.
     */
    apply(filterManager, input, output, clear) {
        var maskSprite = this.maskSprite;
        var tex = this.maskSprite.texture;
        if (!tex.valid) {
            return;
        }
        if (!tex.transform) {
            // margin = 0.0, let it bleed a bit, shader code becomes easier
            // assuming that atlas textures were made with 1-pixel padding
            tex.transform = new TextureMatrix_1.TextureMatrix(tex, 0.0);
        }
        tex.transform.update();
        this.uniforms.npmAlpha = tex.baseTexture.premultiplyAlpha ? 0.0 : 1.0;
        this.uniforms.mask = tex;
        this.uniforms.otherMatrix = filterManager.calculateSpriteMatrix(this.maskMatrix, maskSprite)
            .prepend(tex.transform.mapCoord);
        this.uniforms.alpha = maskSprite.worldAlpha;
        this.uniforms.maskClamp = tex.transform.uClampFrame;
        filterManager.applyFilter(this, input, output, clear);
    }
    ;
}
SpriteMaskFilter.vertex = "attribute vec2 aVertexPosition;\r\nattribute vec2 aTextureCoord;\r\n\r\nuniform mat3 projectionMatrix;\r\nuniform mat3 otherMatrix;\r\n\r\nvarying vec2 vMaskCoord;\r\nvarying vec2 vTextureCoord;\r\n\r\nvoid main(void)\r\n{\r\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\r\n\r\n    vTextureCoord = aTextureCoord;\r\n    vMaskCoord = ( otherMatrix * vec3( aTextureCoord, 1.0)  ).xy;\r\n}\r\n";
SpriteMaskFilter.fragment = "varying vec2 vMaskCoord;\r\nvarying vec2 vTextureCoord;\r\n\r\nuniform sampler2D uSampler;\r\nuniform sampler2D mask;\r\nuniform float alpha;\r\nuniform float npmAlpha;\r\nuniform vec4 maskClamp;\r\n\r\nvoid main(void)\r\n{\r\n    float clip = step(3.5,\r\n        step(maskClamp.x, vMaskCoord.x) +\r\n        step(maskClamp.y, vMaskCoord.y) +\r\n        step(vMaskCoord.x, maskClamp.z) +\r\n        step(vMaskCoord.y, maskClamp.w));\r\n\r\n    vec4 original = texture2D(uSampler, vTextureCoord);\r\n    vec4 masky = texture2D(mask, vMaskCoord);\r\n    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);\r\n\r\n    original *= (alphaMul * masky.r * alpha * clip);\r\n\r\n    gl_FragColor = original;\r\n}\r\n";
exports.SpriteMaskFilter = SpriteMaskFilter;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/Spritesheet.js":
/*!***********************************************!*\
  !*** ./js-compile/raw-pixi-ts/Spritesheet.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Rectangle_1 = __webpack_require__(/*! ../flash/geom/Rectangle */ "./js-compile/flash/geom/Rectangle.js");
const Texture_1 = __webpack_require__(/*! ./Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const NetworkSettings_1 = __webpack_require__(/*! ./NetworkSettings */ "./js-compile/raw-pixi-ts/NetworkSettings.js");
const InstanceCounter_1 = __webpack_require__(/*! ./InstanceCounter */ "./js-compile/raw-pixi-ts/InstanceCounter.js");
const FlashBaseObject_1 = __webpack_require__(/*! ./FlashBaseObject */ "./js-compile/raw-pixi-ts/FlashBaseObject.js");
class Spritesheet extends FlashBaseObject_1.FlashBaseObject {
    constructor(baseTexture, data, resolutionFilename = null) {
        super();
        /**
         * Reference to ths source texture
         * @type {PIXI.BaseTexture}
         */
        this.baseTexture = baseTexture;
        /**
         * A map containing all textures of the sprite sheet.
         * Can be used to create a {@link PIXI.Sprite|Sprite}:
         * ```js
         * new PIXI.Sprite(sheet.textures["image.png"]);
         * ```
         * @member {Object}
         */
        this.textures = {};
        /**
         * A map containing the textures for each animation.
         * Can be used to create an {@link PIXI.AnimatedSprite|AnimatedSprite}:
         * ```js
         * new PIXI.AnimatedSprite(sheet.animations["anim_name"])
         * ```
         * @member {Object}
         */
        this.animations = {};
        /**
         * Reference to the original JSON data.
         * @type {Object}
         */
        this.data = data;
        /**
         * The resolution of the spritesheet.
         * @type {number}
         */
        this.resolution = this._updateResolution(resolutionFilename
            || (this.baseTexture.resource ? this.baseTexture.resource.url : null));
        /**
         * Map of spritesheet frames.
         * @type {Object}
         * @private
         */
        this._frames = this.data.frames;
        /**
         * Collection of frame names.
         * @type {string[]}
         * @private
         */
        this._frameKeys = Object.keys(this._frames);
        /**
         * Current batch index being processed.
         * @type {number}
         * @private
         */
        this._batchIndex = 0;
        /**
         * Callback when parse is completed.
         * @type {Function}
         * @private
         */
        this._callback = null;
    }
    _updateResolution(resolutionFilename) {
        var scale = this.data.meta.scale;
        // Use a defaultValue of `null` to check if a url-based resolution is set
        var resolution = NetworkSettings_1.NetworkSettings.getResolutionOfUrl(resolutionFilename, null);
        // No resolution found via URL
        if (resolution === null) {
            // Use the scale value or default to 1
            resolution = scale !== undefined ? parseFloat(scale) : 1;
        }
        // For non-1 resolutions, update baseTexture
        if (resolution !== 1) {
            this.baseTexture.setResolution(resolution);
        }
        return resolution;
    }
    ;
    /**
     * Generate the resolution from the filename or fallback
     * to the meta.scale field of the JSON data.
     *
     * @private
     * @param {string} resolutionFilename - The filename to use for resolving
     *    the default resolution.
     * @return {number} Resolution to use for spritesheet.
     */
    static get BATCH_SIZE() {
        return 1000;
    }
    ;
    /**
     * Parser spritesheet from loaded data. This is done asynchronously
     * to prevent creating too many Texture within a single process.
     *
     * @param {Function} callback - Callback when complete returns
     *    a map of the Textures for this spritesheet.
     */
    parse(callback) {
        this._batchIndex = 0;
        this._callback = callback;
        if (this._frameKeys.length <= Spritesheet.BATCH_SIZE) {
            this._processFrames(0);
            this._processAnimations();
            this._parseComplete();
        }
        else {
            this._nextBatch();
        }
    }
    ;
    /**
     * Process a batch of frames
     *
     * @private
     * @param {number} initialFrameIndex - The index of frame to start.
     */
    _processFrames(initialFrameIndex) {
        var frameIndex = initialFrameIndex;
        var maxFrames = Spritesheet.BATCH_SIZE;
        while (frameIndex - initialFrameIndex < maxFrames && frameIndex < this._frameKeys.length) {
            var i = this._frameKeys[frameIndex];
            var data = this._frames[i];
            var rect = data.frame;
            if (rect) {
                var frame = null;
                var trim = null;
                var sourceSize = data.trimmed !== false && data.sourceSize ? data.sourceSize : data.frame;
                InstanceCounter_1.InstanceCounter.addCall("Rectangle.getRectangle", "SpriteSheet _processFrames");
                var orig = Rectangle_1.Rectangle.getRectangle(0, 0, Math.floor(sourceSize.w) / this.resolution, Math.floor(sourceSize.h) / this.resolution);
                if (data.rotated) {
                    InstanceCounter_1.InstanceCounter.addCall("Rectangle.getRectangle", "SpriteSheet _processFrames");
                    frame = Rectangle_1.Rectangle.getRectangle(Math.floor(rect.x) / this.resolution, Math.floor(rect.y) / this.resolution, Math.floor(rect.h) / this.resolution, Math.floor(rect.w) / this.resolution);
                }
                else {
                    InstanceCounter_1.InstanceCounter.addCall("Rectangle.getRectangle", "SpriteSheet _processFrames");
                    frame = Rectangle_1.Rectangle.getRectangle(Math.floor(rect.x) / this.resolution, Math.floor(rect.y) / this.resolution, Math.floor(rect.w) / this.resolution, Math.floor(rect.h) / this.resolution);
                }
                //  Check to see if the sprite is trimmed
                if (data.trimmed !== false && data.spriteSourceSize) {
                    InstanceCounter_1.InstanceCounter.addCall("Rectangle.getRectangle", "SpriteSheet _processFrames");
                    trim = Rectangle_1.Rectangle.getRectangle(Math.floor(data.spriteSourceSize.x) / this.resolution, Math.floor(data.spriteSourceSize.y) / this.resolution, Math.floor(rect.w) / this.resolution, Math.floor(rect.h) / this.resolution);
                }
                this.textures[i] = new Texture_1.Texture(this.baseTexture, frame, orig, trim, data.rotated ? 2 : 0, data.anchor);
                // lets also add the frame to pixi's global cache for fromFrame and fromImage functions
                Texture_1.Texture.addToCache(this.textures[i], i);
            }
            frameIndex++;
        }
    }
    ;
    /**
     * Parse animations config
     *
     * @private
     */
    _processAnimations() {
        var animations = this.data.animations || {};
        for (var animName in animations) {
            this.animations[animName] = [];
            for (var i = 0; i < animations[animName].length; i++) {
                var frameName = animations[animName][i];
                this.animations[animName].push(this.textures[frameName]);
            }
        }
    }
    ;
    /**
     * The parse has completed.
     *
     * @private
     */
    _parseComplete() {
        var callback = this._callback;
        this._callback = null;
        this._batchIndex = 0;
        callback.call(this, this.textures);
    }
    ;
    /**
     * Begin the next batch of textures.
     *
     * @private
     */
    _nextBatch() {
        var this$1 = this;
        this._processFrames(this._batchIndex * Spritesheet.BATCH_SIZE);
        this._batchIndex++;
        setTimeout(function () {
            if (this$1._batchIndex * Spritesheet.BATCH_SIZE < this$1._frameKeys.length) {
                this$1._nextBatch();
            }
            else {
                this$1._processAnimations();
                this$1._parseComplete();
            }
        }, 0);
    }
    ;
    /**
     * Destroy Spritesheet and don't use after this.
     *
     * @param {boolean} [destroyBase=false] Whether to destroy the base texture as well
     */
    destroy(destroyBase) {
        if (destroyBase === void 0) {
            destroyBase = false;
        }
        for (var i in this.textures) {
            this.textures[i].destroy();
        }
        this._frames = null;
        this._frameKeys = null;
        this.data = null;
        this.textures = null;
        if (destroyBase) {
            this.baseTexture.destroy();
        }
        this.baseTexture = null;
    }
    ;
}
exports.Spritesheet = Spritesheet;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/StageOptions.js":
/*!************************************************!*\
  !*** ./js-compile/raw-pixi-ts/StageOptions.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class StageOptions {
    constructor() {
        this.sharedLoader = false;
        this.forceCanvas = false;
        this.view = null;
        this.antialias = false;
        this.forceFXAA = false;
        this.autoDensity = true;
        this.autoResize = true;
        this.transparent = false;
        this.backgroundColor = 0x000000;
        this.clearBeforeRender = true;
        this.autoStart = true;
        this.preserveDrawingBuffer = false;
        this.width = 1024;
        this.height = 768;
        this.resolution = 1;
        this.legacy = false;
        this.roundPixels = false;
        this.sharedTicker = false;
        this.context = null;
        this.resizeTo = null;
        this.powerPreference = "high-performance";
    }
}
exports.StageOptions = StageOptions;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/Star.js":
/*!****************************************!*\
  !*** ./js-compile/raw-pixi-ts/Star.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Polygon_1 = __webpack_require__(/*! ./Polygon */ "./js-compile/raw-pixi-ts/Polygon.js");
const MathSettings_1 = __webpack_require__(/*! ./MathSettings */ "./js-compile/raw-pixi-ts/MathSettings.js");
class Star extends Polygon_1.Polygon {
    constructor(x, y, points, radius, innerRadius, rotation) {
        innerRadius = innerRadius || radius / 2;
        var startAngle = (-1 * Math.PI / 2) + rotation;
        var len = points * 2;
        var delta = MathSettings_1.MathSettings.PI_2 / len;
        var polygon = [];
        for (var i = 0; i < len; i++) {
            var r = i % 2 ? innerRadius : radius;
            var angle = (i * delta) + startAngle;
            polygon.push(x + (r * Math.cos(angle)), y + (r * Math.sin(angle)));
        }
        super(polygon);
    }
}
exports.Star = Star;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/State.js":
/*!*****************************************!*\
  !*** ./js-compile/raw-pixi-ts/State.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BlendModesSettings_1 = __webpack_require__(/*! ./BlendModesSettings */ "./js-compile/raw-pixi-ts/BlendModesSettings.js");
class State {
    constructor() {
        this.data = 0;
        this.blendMode = BlendModesSettings_1.BlendModesSettings.BLEND_MODES.NORMAL;
        this.polygonOffset = 0;
        this.blend = true;
        //  this.depthTest = true;
    }
    /**
     * Activates blending of the computed fragment color values
     *
     * @member {boolean}
     */
    get blend() {
        return !!(this.data & (1 << State.BLEND));
    }
    ;
    set blend(value) {
        if (!!(this.data & (1 << State.BLEND)) !== value) {
            this.data ^= (1 << State.BLEND);
        }
    }
    ;
    /**
     * Activates adding an offset to depth values of polygon's fragments
     *
     * @member {boolean}
     * @default false
     */
    get offsets() {
        return !!(this.data & (1 << State.OFFSET));
    }
    ;
    set offsets(value) {
        if (!!(this.data & (1 << State.OFFSET)) !== value) {
            this.data ^= (1 << State.OFFSET);
        }
    }
    ;
    /**
     * Activates culling of polygons.
     *
     * @member {boolean}
     * @default false
     */
    get culling() {
        return !!(this.data & (1 << State.CULLING));
    }
    ;
    set culling(value) {
        if (!!(this.data & (1 << State.CULLING)) !== value) {
            this.data ^= (1 << State.CULLING);
        }
    }
    ;
    /**
     * Activates depth comparisons and updates to the depth buffer.
     *
     * @member {boolean}
     * @default false
     */
    get depthTest() {
        return !!(this.data & (1 << State.DEPTH_TEST));
    }
    ;
    set depthTest(value) {
        if (!!(this.data & (1 << State.DEPTH_TEST)) !== value) {
            this.data ^= (1 << State.DEPTH_TEST);
        }
    }
    ;
    /**
     * Specifies whether or not front or back-facing polygons can be culled.
     * @member {boolean}
     * @default false
     */
    get clockwiseFrontFace() {
        return !!(this.data & (1 << State.WINDING));
    }
    ;
    set clockwiseFrontFace(value) {
        if (!!(this.data & (1 << State.WINDING)) !== value) {
            this.data ^= (1 << State.WINDING);
        }
    }
    ;
    /**
     * The blend mode to be applied when this state is set. Apply a value of `PIXI.BLEND_MODES.NORMAL` to reset the blend mode.
     * Setting this mode to anything other than NO_BLEND will automatically switch blending on.
     *
     * @member {boolean}
     * @default PIXI.BLEND_MODES.NORMAL
     * @see PIXI.BLEND_MODES
     */
    get blendMode() {
        return this._blendMode;
    }
    ;
    set blendMode(value) {
        this.blend = (value !== BlendModesSettings_1.BlendModesSettings.BLEND_MODES.NONE);
        this._blendMode = value;
    }
    ;
    /**
     * The polygon offset. Setting this property to anything other than 0 will automatically enable polygon offset fill.
     *
     * @member {number}
     * @default 0
     */
    get polygonOffset() {
        return this._polygonOffset;
    }
    ;
    set polygonOffset(value) {
        this.offsets = !!value;
        this._polygonOffset = value;
    }
    ;
    static for2d() {
        var state = new State();
        state.depthTest = false;
        state.blend = true;
        return state;
    }
    ;
}
State.BLEND = 0;
State.OFFSET = 1;
State.CULLING = 2;
State.DEPTH_TEST = 3;
State.WINDING = 4;
exports.State = State;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/StateSystem.js":
/*!***********************************************!*\
  !*** ./js-compile/raw-pixi-ts/StateSystem.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const System_1 = __webpack_require__(/*! ./System */ "./js-compile/raw-pixi-ts/System.js");
const State_1 = __webpack_require__(/*! ./State */ "./js-compile/raw-pixi-ts/State.js");
const BlendModesSettings_1 = __webpack_require__(/*! ./BlendModesSettings */ "./js-compile/raw-pixi-ts/BlendModesSettings.js");
class StateSystem extends System_1.System {
    constructor(renderer) {
        super(renderer);
        /**
         * GL context
         * @member {WebGLRenderingContext}
         * @readonly
         */
        this.gl = null;
        /**
         * State ID
         * @member {number}
         * @readonly
         */
        this.stateId = 0;
        /**
         * Polygon offset
         * @member {number}
         * @readonly
         */
        this.polygonOffset = 0;
        /**
         * Blend mode
         * @member {number}
         * @default PIXI.BLEND_MODES.NONE
         * @readonly
         */
        this.blendMode = BlendModesSettings_1.BlendModesSettings.BLEND_MODES.NONE;
        /**
         * Whether current blend equation is different
         * @member {boolean}
         * @protected
         */
        this._blendEq = false;
        /**
         * Collection of calls
         * @member {function[]}
         * @readonly
         */
        this.map = [];
        // map functions for when we set state..
        this.map[StateSystem.BLEND$1] = this.setBlend;
        this.map[StateSystem.OFFSET$1] = this.setOffset;
        this.map[StateSystem.CULLING$1] = this.setCullFace;
        this.map[StateSystem.DEPTH_TEST$1] = this.setDepthTest;
        this.map[StateSystem.WINDING$1] = this.setFrontFace;
        /**
         * Collection of check calls
         * @member {function[]}
         * @readonly
         */
        this.checks = [];
        /**
         * Default WebGL State
         * @member {PIXI.State}
         * @readonly
         */
        this.defaultState = new State_1.State();
        this.defaultState.blend = true;
        this.defaultState.depth = true;
    }
    contextChange(gl) {
        this.gl = gl;
        this.blendModes = BlendModesSettings_1.BlendModesSettings.mapWebGLBlendModesToPixi(gl);
        this.setState(this.defaultState);
        this.reset();
    }
    ;
    /**
     * Sets the current state
     *
     * @param {*} state - The state to set.
     */
    setState(state) {
        state = state || this.defaultState;
        // TODO maybe to an object check? ( this.state === state )?
        if (this.stateId !== state.data) {
            var diff = this.stateId ^ state.data;
            var i = 0;
            // order from least to most common
            while (diff) {
                if (diff & 1) {
                    // state change!
                    this.map[i].call(this, !!(state.data & (1 << i)));
                }
                diff = diff >> 1;
                i++;
            }
            this.stateId = state.data;
        }
        // based on the above settings we check for specific modes..
        // for example if blend is active we check and set the blend modes
        // or of polygon offset is active we check the poly depth.
        for (var i$1 = 0; i$1 < this.checks.length; i$1++) {
            this.checks[i$1](this, state);
        }
    }
    ;
    /**
     * Sets the state, when previous state is unknown
     *
     * @param {*} state - The state to set
     */
    forceState(state) {
        state = state || this.defaultState;
        for (var i = 0; i < this.map.length; i++) {
            this.map[i].call(this, !!(state.data & (1 << i)));
        }
        for (var i$1 = 0; i$1 < this.checks.length; i$1++) {
            this.checks[i$1](this, state);
        }
        this.stateId = state.data;
    }
    ;
    /**
     * Enables or disabled blending.
     *
     * @param {boolean} value - Turn on or off webgl blending.
     */
    setBlend(value) {
        this.updateCheck(StateSystem.checkBlendMode, value);
        this.gl[value ? 'enable' : 'disable'](this.gl.BLEND);
    }
    ;
    /**
     * Enables or disable polygon offset fill
     *
     * @param {boolean} value - Turn on or off webgl polygon offset testing.
     */
    setOffset(value) {
        this.gl[value ? 'enable' : 'disable'](this.gl.POLYGON_OFFSET_FILL);
    }
    ;
    /**
     * Sets whether to enable or disable depth test.
     *
     * @param {boolean} value - Turn on or off webgl depth testing.
     */
    setDepthTest(value) {
        this.gl[value ? 'enable' : 'disable'](this.gl.DEPTH_TEST);
    }
    ;
    /**
     * Sets whether to enable or disable cull face.
     *
     * @param {boolean} value - Turn on or off webgl cull face.
     */
    setCullFace(value) {
        this.gl[value ? 'enable' : 'disable'](this.gl.CULL_FACE);
    }
    ;
    /**
     * Sets the gl front face.
     *
     * @param {boolean} value - true is clockwise and false is counter-clockwise
     */
    setFrontFace(value) {
        this.gl.frontFace(this.gl[value ? 'CW' : 'CCW']);
    }
    ;
    /**
     * Sets the blend mode.
     *
     * @param {number} value - The blend mode to set to.
     */
    setBlendMode(value) {
        if (value === this.blendMode) {
            return;
        }
        this.blendMode = value;
        var mode = this.blendModes[value];
        var gl = this.gl;
        if (mode.length === 2) {
            gl.blendFunc(mode[0], mode[1]);
        }
        else {
            gl.blendFuncSeparate(mode[0], mode[1], mode[2], mode[3]);
        }
        if (mode.length === 6) {
            this._blendEq = true;
            gl.blendEquationSeparate(mode[4], mode[5]);
        }
        else if (this._blendEq) {
            this._blendEq = false;
            gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
        }
    }
    ;
    /**
     * Sets the polygon offset.
     *
     * @param {number} value - the polygon offset
     * @param {number} scale - the polygon offset scale
     */
    setPolygonOffset(value, scale) {
        this.gl.polygonOffset(value, scale);
    }
    ;
    // used
    /**
     * Resets all the logic and disables the vaos
     */
    reset() {
        this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, false);
        this.forceState(0);
        this._blendEq = true;
        this.blendMode = -1;
        this.setBlendMode(0);
    }
    ;
    /**
     * checks to see which updates should be checked based on which settings have been activated.
     * For example, if blend is enabled then we should check the blend modes each time the state is changed
     * or if polygon fill is activated then we need to check if the polygon offset changes.
     * The idea is that we only check what we have too.
     *
     * @param {Function} func  the checking function to add or remove
     * @param {boolean} value  should the check function be added or removed.
     */
    updateCheck(func, value) {
        var index = this.checks.indexOf(func);
        if (value && index === -1) {
            this.checks.push(func);
        }
        else if (!value && index !== -1) {
            this.checks.splice(index, 1);
        }
    }
    ;
    /**
     * A private little wrapper function that we call to check the blend mode.
     *
     * @static
     * @private
     * @param {PIXI.StateSystem} System  the System to perform the state check on
     * @param {PIXI.State} state  the state that the blendMode will pulled from
     */
    static checkBlendMode(system, state) {
        system.setBlendMode(state.blendMode);
    }
    ;
}
StateSystem.UID$4 = 0;
StateSystem.BLEND$1 = 0;
StateSystem.OFFSET$1 = 1;
StateSystem.CULLING$1 = 2;
StateSystem.DEPTH_TEST$1 = 3;
StateSystem.WINDING$1 = 4;
exports.StateSystem = StateSystem;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/StencilSystem.js":
/*!*************************************************!*\
  !*** ./js-compile/raw-pixi-ts/StencilSystem.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const System_1 = __webpack_require__(/*! ./System */ "./js-compile/raw-pixi-ts/System.js");
class StencilSystem extends System_1.System {
    constructor(renderer) {
        super(renderer);
        this.stencilMaskStack = [];
    }
    /**
     * Changes the mask stack that is used by this System.
     *
     * @param {PIXI.Graphics[]} stencilMaskStack - The mask stack
     */
    setMaskStack(stencilMaskStack) {
        var gl = this.renderer.gl;
        if (stencilMaskStack.length !== this.stencilMaskStack.length) {
            if (stencilMaskStack.length === 0) {
                gl.disable(gl.STENCIL_TEST);
            }
            else {
                gl.enable(gl.STENCIL_TEST);
            }
        }
        this.stencilMaskStack = stencilMaskStack;
    }
    ;
    /**
     * Applies the Mask and adds it to the current stencil stack. @alvin
     *
     * @param {PIXI.Graphics} graphics - The mask
     */
    pushStencil(graphics) {
        var gl = this.renderer.gl;
        var prevMaskCount = this.stencilMaskStack.length;
        if (prevMaskCount === 0) {
            gl.enable(gl.STENCIL_TEST);
        }
        this.stencilMaskStack.push(graphics);
        // Increment the reference stencil value where the new mask overlaps with the old ones.
        gl.colorMask(false, false, false, false);
        gl.stencilFunc(gl.EQUAL, prevMaskCount, this._getBitwiseMask());
        gl.stencilOp(gl.KEEP, gl.KEEP, gl.INCR);
        graphics.renderable = true;
        graphics.render(this.renderer);
        this.renderer.batch.flush();
        graphics.renderable = false;
        this._useCurrent();
    }
    ;
    /**
     * Removes the last mask from the stencil stack. @alvin
     */
    popStencil() {
        var gl = this.renderer.gl;
        var graphics = this.stencilMaskStack.pop();
        if (this.stencilMaskStack.length === 0) {
            // the stack is empty!
            gl.disable(gl.STENCIL_TEST);
            gl.clear(gl.STENCIL_BUFFER_BIT);
            gl.clearStencil(0);
        }
        else {
            // Decrement the reference stencil value where the popped mask overlaps with the other ones
            gl.colorMask(false, false, false, false);
            gl.stencilOp(gl.KEEP, gl.KEEP, gl.DECR);
            graphics.renderable = true;
            graphics.render(this.renderer);
            this.renderer.batch.flush();
            graphics.renderable = false;
            this._useCurrent();
        }
    }
    ;
    /**
     * Setup renderer to use the current stencil data.
     * @private
     */
    _useCurrent() {
        var gl = this.renderer.gl;
        gl.colorMask(true, true, true, true);
        gl.stencilFunc(gl.EQUAL, this.stencilMaskStack.length, this._getBitwiseMask());
        gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
    }
    ;
    /**
     * Fill 1s equal to the number of acitve stencil masks.
     * @private
     * @return {number} The bitwise mask.
     */
    _getBitwiseMask() {
        return (1 << this.stencilMaskStack.length) - 1;
    }
    ;
    /**
     * Destroys the mask stack.
     *
     */
    destroy() {
        super.destroy();
        this.stencilMaskStack = null;
    }
    ;
}
exports.StencilSystem = StencilSystem;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/System.js":
/*!******************************************!*\
  !*** ./js-compile/raw-pixi-ts/System.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const EventDispatcher_1 = __webpack_require__(/*! ./EventDispatcher */ "./js-compile/raw-pixi-ts/EventDispatcher.js");
class System extends EventDispatcher_1.EventDispatcher {
    constructor(renderer = null) {
        super();
        this.renderer = renderer;
        this.renderer.runners.contextChange.add(this);
    }
    contextChange(gl) {
    }
    ;
    destroy(options = null) {
        this.renderer.runners.contextChange.remove(this);
        this.renderer = null;
    }
    ;
}
exports.System = System;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/Text.js":
/*!****************************************!*\
  !*** ./js-compile/raw-pixi-ts/Text.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Sprite_1 = __webpack_require__(/*! ./Sprite */ "./js-compile/raw-pixi-ts/Sprite.js");
const Texture_1 = __webpack_require__(/*! ./Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const Rectangle_1 = __webpack_require__(/*! ../flash/geom/Rectangle */ "./js-compile/flash/geom/Rectangle.js");
const TextMetrics_1 = __webpack_require__(/*! ./TextMetrics */ "./js-compile/raw-pixi-ts/TextMetrics.js");
const TextStyle_1 = __webpack_require__(/*! ./TextStyle */ "./js-compile/raw-pixi-ts/TextStyle.js");
const DisplaySettings_1 = __webpack_require__(/*! ./DisplaySettings */ "./js-compile/raw-pixi-ts/DisplaySettings.js");
const MathSettings_1 = __webpack_require__(/*! ./MathSettings */ "./js-compile/raw-pixi-ts/MathSettings.js");
const CanvasSettings_1 = __webpack_require__(/*! ./CanvasSettings */ "./js-compile/raw-pixi-ts/CanvasSettings.js");
const TextSettings_1 = __webpack_require__(/*! ./TextSettings */ "./js-compile/raw-pixi-ts/TextSettings.js");
const CleanUpSettings_1 = __webpack_require__(/*! ./CleanUpSettings */ "./js-compile/raw-pixi-ts/CleanUpSettings.js");
const ColorSettings_1 = __webpack_require__(/*! ./ColorSettings */ "./js-compile/raw-pixi-ts/ColorSettings.js");
const InstanceCounter_1 = __webpack_require__(/*! ./InstanceCounter */ "./js-compile/raw-pixi-ts/InstanceCounter.js");
class Text extends Sprite_1.Sprite {
    constructor(text, style = null, canvas = null) {
        canvas = canvas || document.createElement('canvas');
        canvas.width = 3;
        canvas.height = 3;
        var texture = Texture_1.Texture.from(canvas);
        InstanceCounter_1.InstanceCounter.addCall("Rectangle.getRectangle", "Text");
        texture.orig = Rectangle_1.Rectangle.getRectangle();
        InstanceCounter_1.InstanceCounter.addCall("Rectangle.getRectangle", "Text");
        texture.trim = Rectangle_1.Rectangle.getRectangle();
        super(texture);
        /**
         * The canvas element that everything is drawn to
         *
         * @member {HTMLCanvasElement}
         */
        this.canvas = canvas;
        /**
         * The canvas 2d context that everything is drawn with
         * @member {CanvasRenderingContext2D}
         */
        this.context = this.canvas.getContext('2d');
        /**
         * The resolution / device pixel ratio of the canvas.
         * This is set to automatically match the renderer resolution by default, but can be overridden by setting manually.
         * @member {number}
         * @default 1
         */
        this._resolution = DisplaySettings_1.DisplaySettings.RESOLUTION;
        this._autoResolution = true;
        /**
         * Private tracker for the current text.
         *
         * @member {string}
         * @private
         */
        this._text = null;
        /**
         * Private tracker for the current style.
         *
         * @member {object}
         * @private
         */
        this._style = null;
        /**
         * Private listener to track style changes.
         *
         * @member {Function}
         * @private
         */
        this._styleListener = null;
        /**
         * Private tracker for the current font.
         *
         * @member {string}
         * @private
         */
        this._font = '';
        this.text = text;
        this.style = style;
        this.localStyleID = -1;
    }
    /**
     * Renders text and updates it when needed.
     *
     * @private
     * @param {boolean} respectDirty - Whether to abort updating the text if the Text isn't dirty and the function is called.
     */
    updateText(respectDirty) {
        var style = this._style;
        // check if style has changed..
        if (this.localStyleID !== style.styleID) {
            this.dirty = true;
            this.localStyleID = style.styleID;
        }
        if (!this.dirty && respectDirty) {
            return;
        }
        this._font = this._style.toFontString();
        var context = this.context;
        TextMetrics_1.TextMetrics.init();
        var measured = TextMetrics_1.TextMetrics.measureText(this._text || ' ', this._style, this._style.wordWrap, this.canvas);
        var width = measured.width;
        var height = measured.height;
        var lines = measured.lines;
        var lineHeight = measured.lineHeight;
        var lineWidths = measured.lineWidths;
        var maxLineWidth = measured.maxLineWidth;
        var fontProperties = measured.fontProperties;
        this.canvas.width = Math.ceil((Math.max(1, width) + (style.padding * 2)) * this._resolution);
        this.canvas.height = Math.ceil((Math.max(1, height) + (style.padding * 2)) * this._resolution);
        context.scale(this._resolution, this._resolution);
        context.clearRect(0, 0, this.canvas.width, this.canvas.height);
        context.font = this._font;
        context.strokeStyle = style.stroke;
        context.lineWidth = style.strokeThickness;
        context.textBaseline = style.textBaseline;
        context.lineJoin = style.lineJoin;
        context.miterLimit = style.miterLimit;
        var linePositionX;
        var linePositionY;
        if (style.dropShadow) {
            var dropShadowColor = style.dropShadowColor;
            var rgb = ColorSettings_1.ColorSettings.hex2rgb(typeof dropShadowColor === 'number' ? dropShadowColor : MathSettings_1.MathSettings.string2hex(dropShadowColor));
            context.shadowColor = "rgba(" + (rgb[0] * 255) + "," + (rgb[1] * 255) + "," + (rgb[2] * 255) + "," + (style.dropShadowAlpha) + ")";
            context.shadowBlur = style.dropShadowBlur;
            context.shadowOffsetX = Math.cos(style.dropShadowAngle) * style.dropShadowDistance;
            context.shadowOffsetY = Math.sin(style.dropShadowAngle) * style.dropShadowDistance;
        }
        else {
            context.shadowColor = 0;
            context.shadowBlur = 0;
            context.shadowOffsetX = 0;
            context.shadowOffsetY = 0;
        }
        // set canvas text styles
        context.fillStyle = this._generateFillStyle(style, lines);
        // draw lines line by line
        for (var i = 0; i < lines.length; i++) {
            linePositionX = style.strokeThickness / 2;
            linePositionY = ((style.strokeThickness / 2) + (i * lineHeight)) + fontProperties.ascent;
            if (style.align === 'right') {
                linePositionX += maxLineWidth - lineWidths[i];
            }
            else if (style.align === 'center') {
                linePositionX += (maxLineWidth - lineWidths[i]) / 2;
            }
            if (style.stroke && style.strokeThickness) {
                this.drawLetterSpacing(lines[i], linePositionX + style.padding, linePositionY + style.padding, true);
            }
            if (style.fill) {
                this.drawLetterSpacing(lines[i], linePositionX + style.padding, linePositionY + style.padding);
            }
        }
        this.updateTexture();
    }
    ;
    /**
     * Render the text with letter-spacing.
     * @param {string} text - The text to draw
     * @param {number} x - Horizontal position to draw the text
     * @param {number} y - Vertical position to draw the text
     * @param {boolean} [isStroke=false] - Is this drawing for the outside stroke of the
     *  text? If not, it's for the inside fill
     * @private
     */
    drawLetterSpacing(text, x, y, isStroke = false) {
        if (isStroke === void 0) {
            isStroke = false;
        }
        var style = this._style;
        // letterSpacing of 0 means normal
        var letterSpacing = style.letterSpacing;
        if (letterSpacing === 0) {
            if (isStroke) {
                this.context.strokeText(text, x, y);
            }
            else {
                this.context.fillText(text, x, y);
            }
            return;
        }
        var characters = String.prototype.split.call(text, '');
        var currentPosition = x;
        var index = 0;
        var current = '';
        while (index < text.length) {
            current = characters[index++];
            if (isStroke) {
                this.context.strokeText(current, currentPosition, y);
            }
            else {
                this.context.fillText(current, currentPosition, y);
            }
            currentPosition += this.context.measureText(current).width + letterSpacing;
        }
    }
    ;
    /**
     * Updates texture size based on canvas size
     *
     * @private
     */
    updateTexture() {
        var canvas = this.canvas;
        if (this._style.trim) {
            var trimmed = CanvasSettings_1.CanvasSettings.trimCanvas(canvas);
            if (trimmed.data) {
                canvas.width = trimmed.width;
                canvas.height = trimmed.height;
                this.context.putImageData(trimmed.data, 0, 0);
            }
        }
        var texture = this._texture;
        var style = this._style;
        var padding = style.trim ? 0 : style.padding;
        var baseTexture = texture.baseTexture;
        texture.trim.width = texture._frame.width = canvas.width / this._resolution;
        texture.trim.height = texture._frame.height = canvas.height / this._resolution;
        texture.trim.x = -padding;
        texture.trim.y = -padding;
        texture.orig.width = texture._frame.width - (padding * 2);
        texture.orig.height = texture._frame.height - (padding * 2);
        // call sprite onTextureUpdate to update scale if _width or _height were set
        this._onTextureUpdate();
        baseTexture.setRealSize(canvas.width, canvas.height, this._resolution);
        this.dirty = false;
    }
    ;
    /**
     * Renders the object using the WebGL renderer
     *
     * @param {PIXI.Renderer} renderer - The renderer
     */
    render(renderer) {
        if (this._autoResolution && this._resolution !== renderer.resolution) {
            this._resolution = renderer.resolution;
            this.dirty = true;
        }
        this.updateText(true);
        super.render(renderer);
    }
    ;
    /**
     * Renders the object using the Canvas renderer
     *
     * @private
     * @param {PIXI.CanvasRenderer} renderer - The renderer
     */
    _renderCanvas(renderer) {
        if (this._autoResolution && this._resolution !== renderer.resolution) {
            this._resolution = renderer.resolution;
            this.dirty = true;
        }
        this.updateText(true);
        // super._renderCanvas(renderer);
    }
    ;
    /**
     * Gets the local bounds of the text object.
     *
     * @param {Rectangle} rect - The output rectangle.
     * @return {Rectangle} The bounds.
     */
    getLocalBounds(rect) {
        this.updateText(true);
        return super.getLocalBounds(rect);
    }
    ;
    /**
     * calculates the bounds of the Text as a rectangle. The bounds calculation takes the worldTransform into account.
     * @protected
     */
    _calculateBounds() {
        this.updateText(true);
        this.calculateVertices();
        // if we have already done this on THIS frame.
        this._bounds.addQuad(this.vertexData);
    }
    ;
    /**
     * Method to be called upon a TextStyle change.
     * @private
     */
    _onStyleChange() {
        this.dirty = true;
    }
    ;
    /**
     * Generates the fill style. Can automatically generate a gradient based on the fill style being an array
     *
     * @private
     * @param {object} style - The style.
     * @param {string[]} lines - The lines of text.
     * @return {string|number|CanvasGradient} The fill style
     */
    _generateFillStyle(style, lines) {
        if (!Array.isArray(style.fill)) {
            return style.fill;
        }
        // the gradient will be evenly spaced out according to how large the array is.
        // ['#FF0000', '#00FF00', '#0000FF'] would created stops at 0.25, 0.5 and 0.75
        var gradient;
        var totalIterations;
        var currentIteration;
        var stop;
        var width = this.canvas.width / this._resolution;
        var height = this.canvas.height / this._resolution;
        // make a copy of the style settings, so we can manipulate them later
        var fill = style.fill.slice();
        var fillGradientStops = style.fillGradientStops.slice();
        // wanting to evenly distribute the fills. So an array of 4 colours should give fills of 0.25, 0.5 and 0.75
        if (!fillGradientStops.length) {
            var lengthPlus1 = fill.length + 1;
            for (var i = 1; i < lengthPlus1; ++i) {
                fillGradientStops.push(i / lengthPlus1);
            }
        }
        // stop the bleeding of the last gradient on the line above to the top gradient of the this line
        // by hard defining the first gradient colour at point 0, and last gradient colour at point 1
        fill.unshift(style.fill[0]);
        fillGradientStops.unshift(0);
        fill.push(style.fill[style.fill.length - 1]);
        fillGradientStops.push(1);
        if (style.fillGradientType === TextSettings_1.TextSettings.TEXT_GRADIENT.LINEAR_VERTICAL) {
            // start the gradient at the top center of the canvas, and end at the bottom middle of the canvas
            gradient = this.context.createLinearGradient(width / 2, 0, width / 2, height);
            // we need to repeat the gradient so that each individual line of text has the same vertical gradient effect
            // ['#FF0000', '#00FF00', '#0000FF'] over 2 lines would create stops at 0.125, 0.25, 0.375, 0.625, 0.75, 0.875
            totalIterations = (fill.length + 1) * lines.length;
            currentIteration = 0;
            for (var i$1 = 0; i$1 < lines.length; i$1++) {
                currentIteration += 1;
                for (var j = 0; j < fill.length; j++) {
                    if (typeof fillGradientStops[j] === 'number') {
                        stop = (fillGradientStops[j] / lines.length) + (i$1 / lines.length);
                    }
                    else {
                        stop = currentIteration / totalIterations;
                    }
                    gradient.addColorStop(stop, fill[j]);
                    currentIteration++;
                }
            }
        }
        else {
            // start the gradient at the center left of the canvas, and end at the center right of the canvas
            gradient = this.context.createLinearGradient(0, height / 2, width, height / 2);
            // can just evenly space out the gradients in this case, as multiple lines makes no difference
            // to an even left to right gradient
            totalIterations = fill.length + 1;
            currentIteration = 1;
            for (var i$2 = 0; i$2 < fill.length; i$2++) {
                if (typeof fillGradientStops[i$2] === 'number') {
                    stop = fillGradientStops[i$2];
                }
                else {
                    stop = currentIteration / totalIterations;
                }
                gradient.addColorStop(stop, fill[i$2]);
                currentIteration++;
            }
        }
        return gradient;
    }
    ;
    /**
     * Destroys this text object.
     * Note* Unlike a Sprite, a Text object will automatically destroy its baseTexture and texture as
     * the majority of the time the texture will not be shared with any other Sprites.
     *
     * @param {object|boolean} [options] - Options parameter. A boolean will act as if all options
     *  have been set to that value
     * @param {boolean} [options.children=false] - if set to true, all the children will have their
     *  destroy method called as well. 'options' will be passed on to those calls.
     * @param {boolean} [options.texture=true] - Should it destroy the current texture of the sprite as well
     * @param {boolean} [options.baseTexture=true] - Should it destroy the base texture of the sprite as well
     */
    destroy(options) {
        if (typeof options === 'boolean') {
            options = { children: options };
        }
        options = Object.assign({}, CleanUpSettings_1.CleanUpSettings.defaultDestroyOptions, options);
        super.destroy(options);
        // make sure to reset the the context and canvas.. dont want this hanging around in memory!
        this.context = null;
        this.canvas = null;
        this._style = null;
    }
    ;
    /**
     * The width of the Text, setting this will actually modify the scale to achieve the value set
     *
     * @member {number}
     */
    get width() {
        this.updateText(true);
        return Math.abs(this.scale.x) * this._texture.orig.width;
    }
    ;
    set width(value) {
        this.updateText(true);
        var s = MathSettings_1.MathSettings.sign(this.scale.x) || 1;
        this.scale.x = s * value / this._texture.orig.width;
        this._width = value;
    }
    ;
    /**
     * The height of the Text, setting this will actually modify the scale to achieve the value set
     *
     * @member {number}
     */
    get height() {
        this.updateText(true);
        return Math.abs(this.scale.y) * this._texture.orig.height;
    }
    ;
    set height(value) {
        this.updateText(true);
        var s = MathSettings_1.MathSettings.sign(this.scale.y) || 1;
        this.scale.y = s * value / this._texture.orig.height;
        this._height = value;
    }
    ;
    /**
     * Set the style of the text. Set up an event listener to listen for changes on the style
     * object and mark the text as dirty.
     *
     * @member {object|PIXI.TextStyle}
     */
    get style() {
        return this._style;
    }
    ;
    set style(style) {
        style = style || {};
        if (style instanceof TextStyle_1.TextStyle) {
            this._style = style;
        }
        else {
            this._style = new TextStyle_1.TextStyle(style);
        }
        this.localStyleID = -1;
        this.dirty = true;
    }
    ;
    /**
     * Set the copy for the text object. To split a line you can use '\n'.
     *
     * @member {string}
     */
    get text() {
        return this._text;
    }
    ;
    set text(text) {
        text = String(text === null || text === undefined ? '' : text);
        if (this._text === text) {
            return;
        }
        this._text = text;
        this.dirty = true;
    }
    ;
    /**
     * The resolution / device pixel ratio of the canvas.
     * This is set to automatically match the renderer resolution by default, but can be overridden by setting manually.
     * @member {number}
     * @default 1
     */
    get resolution() {
        return this._resolution;
    }
    ;
    set resolution(value) {
        this._autoResolution = false;
        if (this._resolution === value) {
            return;
        }
        this._resolution = value;
        this.dirty = true;
    }
    ;
}
exports.Text = Text;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/TextMetrics.js":
/*!***********************************************!*\
  !*** ./js-compile/raw-pixi-ts/TextMetrics.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class TextMetrics {
    constructor(text, style, width, height, lines, lineWidths, lineHeight, maxLineWidth, fontProperties) {
        if (!TextMetrics.canvas) {
            TextMetrics.canvas = document.createElement('canvas');
            TextMetrics.canvas.width = TextMetrics.canvas.height = 10;
            TextMetrics._canvas = TextMetrics.canvas;
            TextMetrics._context = TextMetrics.canvas.getContext('2d');
        }
        this.text = text;
        this.style = style;
        this.width = width;
        this.height = height;
        this.lines = lines;
        this.lineWidths = lineWidths;
        this.lineHeight = lineHeight;
        this.maxLineWidth = maxLineWidth;
        this.fontProperties = fontProperties;
    }
    static init() {
        if (!TextMetrics.canvas) {
            TextMetrics.canvas = document.createElement('canvas');
            TextMetrics.canvas.width = TextMetrics.canvas.height = 10;
            TextMetrics._canvas = TextMetrics.canvas;
            TextMetrics._context = TextMetrics.canvas.getContext('2d');
        }
    }
    /**
     * Measures the supplied string of text and returns a Rectangle.
     *
     * @param {string} text - the text to measure.
     * @param {PIXI.TextStyle} style - the text style to use for measuring
     * @param {boolean} [wordWrap] - optional override for if word-wrap should be applied to the text.
     * @param {HTMLCanvasElement} [canvas] - optional specification of the canvas to use for measuring.
     * @return {PIXI.TextMetrics} measured width and height of the text.
     */
    static measureText(text, style, wordWrap, canvas = TextMetrics._canvas) {
        wordWrap = (wordWrap === undefined || wordWrap === null) ? style.wordWrap : wordWrap;
        var font = style.toFontString();
        var fontProperties = TextMetrics.measureFont(font);
        // fallback in case UA disallow canvas data extraction
        // (toDataURI, getImageData functions)
        if (fontProperties.fontSize === 0) {
            fontProperties.fontSize = style.fontSize;
            fontProperties.ascent = style.fontSize;
        }
        var context = canvas.getContext('2d');
        context.font = font;
        var outputText = wordWrap ? TextMetrics.wordWrap(text, style, canvas) : text;
        var lines = outputText.split(/(?:\r\n|\r|\n)/);
        var lineWidths = new Array(lines.length);
        var maxLineWidth = 0;
        for (var i = 0; i < lines.length; i++) {
            var lineWidth = context.measureText(lines[i]).width + ((lines[i].length - 1) * style.letterSpacing);
            lineWidths[i] = lineWidth;
            maxLineWidth = Math.max(maxLineWidth, lineWidth);
        }
        var width = maxLineWidth + style.strokeThickness;
        if (style.dropShadow) {
            width += style.dropShadowDistance;
        }
        var lineHeight = style.lineHeight || fontProperties.fontSize + style.strokeThickness;
        var height = Math.max(lineHeight, fontProperties.fontSize + style.strokeThickness)
            + ((lines.length - 1) * (lineHeight + style.leading));
        if (style.dropShadow) {
            height += style.dropShadowDistance;
        }
        return new TextMetrics(text, style, width, height, lines, lineWidths, lineHeight + style.leading, maxLineWidth, fontProperties);
    }
    ;
    /**
     * Applies newlines to a string to have it optimally fit into the horizontal
     * bounds set by the Text object's wordWrapWidth property.
     *
     * @private
     * @param {string} text - String to apply word wrapping to
     * @param {PIXI.TextStyle} style - the style to use when wrapping
     * @param {HTMLCanvasElement} [canvas] - optional specification of the canvas to use for measuring.
     * @return {string} New string with new lines applied where required
     */
    static wordWrap(text, style, canvas) {
        if (canvas === void 0) {
            canvas = TextMetrics._canvas;
        }
        var context = canvas.getContext('2d');
        var width = 0;
        var line = '';
        var lines = '';
        var cache = {};
        var letterSpacing = style.letterSpacing;
        var whiteSpace = style.whiteSpace;
        // How to handle whitespaces
        var collapseSpaces = TextMetrics.collapseSpaces(whiteSpace);
        var collapseNewlines = TextMetrics.collapseNewlines(whiteSpace);
        // whether or not spaces may be added to the beginning of lines
        var canPrependSpaces = !collapseSpaces;
        // There is letterSpacing after every char except the last one
        // t_h_i_s_' '_i_s_' '_a_n_' '_e_x_a_m_p_l_e_' '_!
        // so for convenience the above needs to be compared to width + 1 extra letterSpace
        // t_h_i_s_' '_i_s_' '_a_n_' '_e_x_a_m_p_l_e_' '_!_
        // ________________________________________________
        // And then the final space is simply no appended to each line
        var wordWrapWidth = style.wordWrapWidth + letterSpacing;
        // break text into words, spaces and newline chars
        var tokens = TextMetrics.tokenize(text);
        for (var i = 0; i < tokens.length; i++) {
            // get the word, space or newlineChar
            var token = tokens[i];
            // if word is a new line
            if (TextMetrics.isNewline(token)) {
                // keep the new line
                if (!collapseNewlines) {
                    lines += TextMetrics.addLine(line);
                    canPrependSpaces = !collapseSpaces;
                    line = '';
                    width = 0;
                    continue;
                }
                // if we should collapse new lines
                // we simply convert it into a space
                token = ' ';
            }
            // if we should collapse repeated whitespaces
            if (collapseSpaces) {
                // check both this and the last tokens for spaces
                var currIsBreakingSpace = TextMetrics.isBreakingSpace(token);
                var lastIsBreakingSpace = TextMetrics.isBreakingSpace(line[line.length - 1]);
                if (currIsBreakingSpace && lastIsBreakingSpace) {
                    continue;
                }
            }
            // get word width from cache if possible
            var tokenWidth = TextMetrics.getFromCache(token, letterSpacing, cache, context);
            // word is longer than desired bounds
            if (tokenWidth > wordWrapWidth) {
                // if we are not already at the beginning of a line
                if (line !== '') {
                    // start newlines for overflow words
                    lines += TextMetrics.addLine(line);
                    line = '';
                    width = 0;
                }
                // break large word over multiple lines
                if (TextMetrics.canBreakWords(token, style.breakWords)) {
                    // break word into characters
                    var characters = token.split('');
                    // loop the characters
                    for (var j = 0; j < characters.length; j++) {
                        var char = characters[j];
                        var k = 1;
                        // we are not at the end of the token
                        while (characters[j + k]) {
                            var nextChar = characters[j + k];
                            var lastChar = char[char.length - 1];
                            // should not split chars
                            if (!TextMetrics.canBreakChars(lastChar, nextChar, token, j, style.breakWords)) {
                                // combine chars & move forward one
                                char += nextChar;
                            }
                            else {
                                break;
                            }
                            k++;
                        }
                        j += char.length - 1;
                        var characterWidth = TextMetrics.getFromCache(char, letterSpacing, cache, context);
                        if (characterWidth + width > wordWrapWidth) {
                            lines += TextMetrics.addLine(line);
                            canPrependSpaces = false;
                            line = '';
                            width = 0;
                        }
                        line += char;
                        width += characterWidth;
                    }
                }
                // run word out of the bounds
                else {
                    // if there are words in this line already
                    // finish that line and start a new one
                    if (line.length > 0) {
                        lines += TextMetrics.addLine(line);
                        line = '';
                        width = 0;
                    }
                    var isLastToken = i === tokens.length - 1;
                    // give it its own line if it's not the end
                    lines += TextMetrics.addLine(token, !isLastToken);
                    canPrependSpaces = false;
                    line = '';
                    width = 0;
                }
            }
            // word could fit
            else {
                // word won't fit because of existing words
                // start a new line
                if (tokenWidth + width > wordWrapWidth) {
                    // if its a space we don't want it
                    canPrependSpaces = false;
                    // add a new line
                    lines += TextMetrics.addLine(line);
                    // start a new line
                    line = '';
                    width = 0;
                }
                // don't add spaces to the beginning of lines
                if (line.length > 0 || !TextMetrics.isBreakingSpace(token) || canPrependSpaces) {
                    // add the word to the current line
                    line += token;
                    // update width counter
                    width += tokenWidth;
                }
            }
        }
        lines += TextMetrics.addLine(line, false);
        return lines;
    }
    ;
    /**
     * Convienience function for logging each line added during the wordWrap
     * method
     *
     * @private
     * @param  {string}   line    - The line of text to add
     * @param  {boolean}  newLine - Add new line character to end
     * @return {string}   A formatted line
     */
    static addLine(line, newLine = true) {
        if (newLine === void 0) {
            newLine = true;
        }
        line = TextMetrics.trimRight(line);
        line = (newLine) ? (line + "\n") : line;
        return line;
    }
    ;
    /**
     * Gets & sets the widths of calculated characters in a cache object
     *
     * @private
     * @param  {string}                key        The key
     * @param  {number}                letterSpacing  The letter spacing
     * @param  {object}                cache      The cache
     * @param  {CanvasRenderingContext2D}  context    The canvas context
     * @return {number}                The from cache.
     */
    static getFromCache(key, letterSpacing, cache, context) {
        var width = cache[key];
        if (width === undefined) {
            var spacing = ((key.length) * letterSpacing);
            width = context.measureText(key).width + spacing;
            cache[key] = width;
        }
        return width;
    }
    ;
    /**
     * Determines whether we should collapse breaking spaces
     *
     * @private
     * @param  {string}   whiteSpace  The TextStyle property whiteSpace
     * @return {boolean}  should collapse
     */
    static collapseSpaces(whiteSpace) {
        return (whiteSpace === 'normal' || whiteSpace === 'pre-line');
    }
    ;
    /**
     * Determines whether we should collapse newLine chars
     *
     * @private
     * @param  {string}   whiteSpace  The white space
     * @return {boolean}  should collapse
     */
    static collapseNewlines(whiteSpace) {
        return (whiteSpace === 'normal');
    }
    ;
    /**
     * trims breaking whitespaces from string
     *
     * @private
     * @param  {string}  text  The text
     * @return {string}  trimmed string
     */
    static trimRight(text) {
        if (typeof text !== 'string') {
            return '';
        }
        for (var i = text.length - 1; i >= 0; i--) {
            var char = text[i];
            if (!TextMetrics.isBreakingSpace(char)) {
                break;
            }
            text = text.slice(0, -1);
        }
        return text;
    }
    ;
    /**
     * Determines if char is a newline.
     *
     * @private
     * @param  {string}  char  The character
     * @return {boolean}  True if newline, False otherwise.
     */
    static isNewline(char) {
        if (typeof char !== 'string') {
            return false;
        }
        return (TextMetrics._newlines.indexOf(char.charCodeAt(0)) >= 0);
    }
    ;
    /**
     * Determines if char is a breaking whitespace.
     *
     * @private
     * @param  {string}  char  The character
     * @return {boolean}  True if whitespace, False otherwise.
     */
    static isBreakingSpace(char) {
        if (typeof char !== 'string') {
            return false;
        }
        return (TextMetrics._breakingSpaces.indexOf(char.charCodeAt(0)) >= 0);
    }
    ;
    /**
     * Splits a string into words, breaking-spaces and newLine characters
     *
     * @private
     * @param  {string}  text   The text
     * @return {string[]}  A tokenized array
     */
    static tokenize(text) {
        var tokens = [];
        var token = '';
        if (typeof text !== 'string') {
            return tokens;
        }
        for (var i = 0; i < text.length; i++) {
            var char = text[i];
            if (TextMetrics.isBreakingSpace(char) || TextMetrics.isNewline(char)) {
                if (token !== '') {
                    tokens.push(token);
                    token = '';
                }
                tokens.push(char);
                continue;
            }
            token += char;
        }
        if (token !== '') {
            tokens.push(token);
        }
        return tokens;
    }
    ;
    /**
     * This method exists to be easily overridden
     * It allows one to customise which words should break
     * Examples are if the token is CJK or numbers.
     * It must return a boolean.
     *
     * @private
     * @param  {string}  token   The token
     * @param  {boolean}  breakWords  The style attr break words
     * @return {boolean} whether to break word or not
     */
    static canBreakWords(token, breakWords) {
        return breakWords;
    }
    ;
    /**
     * This method exists to be easily overridden
     * It allows one to determine whether a pair of characters
     * should be broken by newlines
     * For example certain characters in CJK langs or numbers.
     * It must return a boolean.
     *
     * @private
     * @param  {string}  char  The character
     * @param  {string}  nextChar  The next character
     * @param  {string}  token The token/word the characters are from
     * @param  {number}  index The index in the token of the char
     * @param  {boolean}  breakWords  The style attr break words
     * @return {boolean} whether to break word or not
     */
    static canBreakChars(char, nextChar, token, index, breakWords) {
        return true;
    }
    ;
    /**
     * Calculates the ascent, descent and fontSize of a given font-style
     *
     * @static
     * @param {string} font - String representing the style of the font
     * @return {PIXI.IFontMetrics} Font properties object
     */
    static measureFont(font) {
        // as this method is used for preparing assets, don't recalculate things if we don't need to
        if (TextMetrics._fonts[font]) {
            return TextMetrics._fonts[font];
        }
        var properties = {};
        var canvas = TextMetrics._canvas;
        var context = TextMetrics._context;
        context.font = font;
        var metricsString = TextMetrics.METRICS_STRING + TextMetrics.BASELINE_SYMBOL;
        var width = Math.ceil(context.measureText(metricsString).width);
        var baseline = Math.ceil(context.measureText(TextMetrics.BASELINE_SYMBOL).width);
        var height = 2 * baseline;
        baseline = baseline * TextMetrics.BASELINE_MULTIPLIER | 0;
        canvas.width = width;
        canvas.height = height;
        context.fillStyle = '#f00';
        context.fillRect(0, 0, width, height);
        context.font = font;
        context.textBaseline = 'alphabetic';
        context.fillStyle = '#000';
        context.fillText(metricsString, 0, baseline);
        var imagedata = context.getImageData(0, 0, width, height).data;
        var pixels = imagedata.length;
        var line = width * 4;
        var i = 0;
        var idx = 0;
        var stop = false;
        // ascent. scan from top to bottom until we find a non red pixel
        for (i = 0; i < baseline; ++i) {
            for (var j = 0; j < line; j += 4) {
                if (imagedata[idx + j] !== 255) {
                    stop = true;
                    break;
                }
            }
            if (!stop) {
                idx += line;
            }
            else {
                break;
            }
        }
        properties.ascent = baseline - i;
        idx = pixels - line;
        stop = false;
        // descent. scan from bottom to top until we find a non red pixel
        for (i = height; i > baseline; --i) {
            for (var j$1 = 0; j$1 < line; j$1 += 4) {
                if (imagedata[idx + j$1] !== 255) {
                    stop = true;
                    break;
                }
            }
            if (!stop) {
                idx -= line;
            }
            else {
                break;
            }
        }
        properties.descent = i - baseline;
        properties.fontSize = properties.ascent + properties.descent;
        TextMetrics._fonts[font] = properties;
        return properties;
    }
    ;
    /**
     * Clear font metrics in metrics cache.
     *
     * @static
     * @param {string} [font] - font name. If font name not set then clear cache for all fonts.
     */
    static clearMetrics(font) {
        if (font === void 0) {
            font = '';
        }
        if (font) {
            delete TextMetrics._fonts[font];
        }
        else {
            TextMetrics._fonts = {};
        }
    }
    ;
}
/**
 * Internal return object for {@link PIXI.TextMetrics.measureFont `TextMetrics.measureFont`}.
 *
 * @typedef {object} FontMetrics
 * @property {number} ascent - The ascent distance
 * @property {number} descent - The descent distance
 * @property {number} fontSize - Font size from ascent to descent
 * @memberof PIXI.TextMetrics
 * @private
 */
/**
 * Cache of {@see PIXI.TextMetrics.FontMetrics} objects.
 * @memberof PIXI.TextMetrics
 * @type {Object}
 * @private
 */
TextMetrics._fonts = {};
/**
 * String used for calculate font metrics.
 * @static
 * @memberof PIXI.TextMetrics
 * @name METRICS_STRING
 * @type {string}
 * @default |q
 */
TextMetrics.METRICS_STRING = '|q';
/**
 * Baseline symbol for calculate font metrics.
 * @static
 * @memberof PIXI.TextMetrics
 * @name BASELINE_SYMBOL
 * @type {string}
 * @default M
 */
TextMetrics.BASELINE_SYMBOL = 'M';
/**
 * Baseline multiplier for calculate font metrics.
 * @static
 * @memberof PIXI.TextMetrics
 * @name BASELINE_MULTIPLIER
 * @type {number}
 * @default 1.4
 */
TextMetrics.BASELINE_MULTIPLIER = 1.4;
/**
 * Cache of new line chars.
 * @memberof PIXI.TextMetrics
 * @type {number[]}
 * @private
 */
TextMetrics._newlines = [
    0x000A,
    0x000D
];
/**
 * Cache of breaking spaces.
 * @memberof PIXI.TextMetrics
 * @type {number[]}
 * @private
 */
TextMetrics._breakingSpaces = [
    0x0009,
    0x0020,
    0x2000,
    0x2001,
    0x2002,
    0x2003,
    0x2004,
    0x2005,
    0x2006,
    0x2008,
    0x2009,
    0x200A,
    0x205F,
    0x3000
];
exports.TextMetrics = TextMetrics;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/TextSettings.js":
/*!************************************************!*\
  !*** ./js-compile/raw-pixi-ts/TextSettings.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class TextSettings {
}
TextSettings.TEXT_GRADIENT = {
    LINEAR_VERTICAL: 0,
    LINEAR_HORIZONTAL: 1,
};
TextSettings.defaultStyle = {
    align: 'left',
    breakWords: false,
    dropShadow: false,
    dropShadowAlpha: 1,
    dropShadowAngle: Math.PI / 6,
    dropShadowBlur: 0,
    dropShadowColor: 'black',
    dropShadowDistance: 5,
    fill: 'black',
    fillGradientType: TextSettings.TEXT_GRADIENT.LINEAR_VERTICAL,
    fillGradientStops: [],
    fontFamily: 'Arial',
    fontSize: 26,
    fontStyle: 'normal',
    fontVariant: 'normal',
    fontWeight: 'normal',
    letterSpacing: 0,
    lineHeight: 0,
    lineJoin: 'miter',
    miterLimit: 10,
    padding: 0,
    stroke: 'black',
    strokeThickness: 0,
    textBaseline: 'alphabetic',
    trim: false,
    whiteSpace: 'pre',
    wordWrap: false,
    wordWrapWidth: 100,
    leading: 0,
};
exports.TextSettings = TextSettings;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/TextStyle.js":
/*!*********************************************!*\
  !*** ./js-compile/raw-pixi-ts/TextStyle.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const TextSettings_1 = __webpack_require__(/*! ./TextSettings */ "./js-compile/raw-pixi-ts/TextSettings.js");
const ColorSettings_1 = __webpack_require__(/*! ./ColorSettings */ "./js-compile/raw-pixi-ts/ColorSettings.js");
const UtilsSettings_1 = __webpack_require__(/*! ./UtilsSettings */ "./js-compile/raw-pixi-ts/UtilsSettings.js");
class TextStyle {
    constructor(style) {
        this.styleID = 0;
        this.reset();
        UtilsSettings_1.UtilsSettings.deepCopyProperties(this, style, style);
    }
    /**
     * Creates a new TextStyle object with the same values as this one.
     * Note that the only the properties of the object are cloned.
     *
     * @return {PIXI.TextStyle} New cloned TextStyle object
     */
    clone() {
        var clonedProperties = {};
        UtilsSettings_1.UtilsSettings.deepCopyProperties(clonedProperties, this, TextSettings_1.TextSettings.defaultStyle);
        return new TextStyle(clonedProperties);
    }
    ;
    /**
     * Resets all properties to the defaults specified in TextStyle.prototype._default
     */
    reset() {
        UtilsSettings_1.UtilsSettings.deepCopyProperties(this, TextSettings_1.TextSettings.defaultStyle, TextSettings_1.TextSettings.defaultStyle);
    }
    ;
    /**
     * Alignment for multiline text ('left', 'center' or 'right'), does not affect single line text
     *
     * @member {string}
     */
    get align() {
        return this._align;
    }
    ;
    set align(align) {
        if (this._align !== align) {
            this._align = align;
            this.styleID++;
        }
    }
    ;
    /**
     * Indicates if lines can be wrapped within words, it needs wordWrap to be set to true
     *
     * @member {boolean}
     */
    get breakWords() {
        return this._breakWords;
    }
    ;
    set breakWords(breakWords) {
        if (this._breakWords !== breakWords) {
            this._breakWords = breakWords;
            this.styleID++;
        }
    }
    ;
    /**
     * Set a drop shadow for the text
     *
     * @member {boolean}
     */
    get dropShadow() {
        return this._dropShadow;
    }
    ;
    set dropShadow(dropShadow) {
        if (this._dropShadow !== dropShadow) {
            this._dropShadow = dropShadow;
            this.styleID++;
        }
    }
    ;
    /**
     * Set alpha for the drop shadow
     *
     * @member {number}
     */
    get dropShadowAlpha() {
        return this._dropShadowAlpha;
    }
    ;
    set dropShadowAlpha(dropShadowAlpha) {
        if (this._dropShadowAlpha !== dropShadowAlpha) {
            this._dropShadowAlpha = dropShadowAlpha;
            this.styleID++;
        }
    }
    ;
    /**
     * Set a angle of the drop shadow
     *
     * @member {number}
     */
    get dropShadowAngle() {
        return this._dropShadowAngle;
    }
    ;
    set dropShadowAngle(dropShadowAngle) {
        if (this._dropShadowAngle !== dropShadowAngle) {
            this._dropShadowAngle = dropShadowAngle;
            this.styleID++;
        }
    }
    ;
    /**
     * Set a shadow blur radius
     *
     * @member {number}
     */
    get dropShadowBlur() {
        return this._dropShadowBlur;
    }
    ;
    set dropShadowBlur(dropShadowBlur) {
        if (this._dropShadowBlur !== dropShadowBlur) {
            this._dropShadowBlur = dropShadowBlur;
            this.styleID++;
        }
    }
    ;
    /**
     * A fill style to be used on the dropshadow e.g 'red', '#00FF00'
     *
     * @member {string|number}
     */
    get dropShadowColor() {
        return this._dropShadowColor;
    }
    ;
    set dropShadowColor(dropShadowColor) {
        var outputColor = ColorSettings_1.ColorSettings.getColor(dropShadowColor);
        if (this._dropShadowColor !== outputColor) {
            this._dropShadowColor = outputColor;
            this.styleID++;
        }
    }
    ;
    /**
     * Set a distance of the drop shadow
     *
     * @member {number}
     */
    get dropShadowDistance() {
        return this._dropShadowDistance;
    }
    ;
    set dropShadowDistance(dropShadowDistance) {
        if (this._dropShadowDistance !== dropShadowDistance) {
            this._dropShadowDistance = dropShadowDistance;
            this.styleID++;
        }
    }
    ;
    /**
     * A canvas fillstyle that will be used on the text e.g 'red', '#00FF00'.
     * Can be an array to create a gradient eg ['#000000','#FFFFFF']
     * {@link https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/fillStyle|MDN}
     *
     * @member {string|string[]|number|number[]|CanvasGradient|CanvasPattern}
     */
    get fill() {
        return this._fill;
    }
    ;
    set fill(fill) {
        var outputColor = ColorSettings_1.ColorSettings.getColor(fill);
        if (this._fill !== outputColor) {
            this._fill = outputColor;
            this.styleID++;
        }
    }
    ;
    /**
     * If fill is an array of colours to create a gradient, this can change the type/direction of the gradient.
     * See {@link PIXI.TEXT_GRADIENT}
     *
     * @member {number}
     */
    get fillGradientType() {
        return this._fillGradientType;
    }
    ;
    set fillGradientType(fillGradientType) {
        if (this._fillGradientType !== fillGradientType) {
            this._fillGradientType = fillGradientType;
            this.styleID++;
        }
    }
    ;
    /**
     * If fill is an array of colours to create a gradient, this array can set the stop points
     * (numbers between 0 and 1) for the color, overriding the default behaviour of evenly spacing them.
     *
     * @member {number[]}
     */
    get fillGradientStops() {
        return this._fillGradientStops;
    }
    ;
    set fillGradientStops(fillGradientStops) {
        if (!UtilsSettings_1.UtilsSettings.areArraysEqual(this._fillGradientStops, fillGradientStops)) {
            this._fillGradientStops = fillGradientStops;
            this.styleID++;
        }
    }
    ;
    /**
     * The font family
     *
     * @member {string|string[]}
     */
    get fontFamily() {
        return this._fontFamily;
    }
    ;
    set fontFamily(fontFamily) {
        if (this.fontFamily !== fontFamily) {
            this._fontFamily = fontFamily;
            this.styleID++;
        }
    }
    ;
    /**
     * The font size
     * (as a number it converts to px, but as a string, equivalents are '26px','20pt','160%' or '1.6em')
     *
     * @member {number|string}
     */
    get fontSize() {
        return this._fontSize;
    }
    ;
    set fontSize(fontSize) {
        if (this._fontSize !== fontSize) {
            this._fontSize = fontSize;
            this.styleID++;
        }
    }
    ;
    /**
     * The font style
     * ('normal', 'italic' or 'oblique')
     *
     * @member {string}
     */
    get fontStyle() {
        return this._fontStyle;
    }
    ;
    set fontStyle(fontStyle) {
        if (this._fontStyle !== fontStyle) {
            this._fontStyle = fontStyle;
            this.styleID++;
        }
    }
    ;
    /**
     * The font variant
     * ('normal' or 'small-caps')
     *
     * @member {string}
     */
    get fontVariant() {
        return this._fontVariant;
    }
    ;
    set fontVariant(fontVariant) {
        if (this._fontVariant !== fontVariant) {
            this._fontVariant = fontVariant;
            this.styleID++;
        }
    }
    ;
    /**
     * The font weight
     * ('normal', 'bold', 'bolder', 'lighter' and '100', '200', '300', '400', '500', '600', '700', 800' or '900')
     *
     * @member {string}
     */
    get fontWeight() {
        return this._fontWeight;
    }
    ;
    set fontWeight(fontWeight) {
        if (this._fontWeight !== fontWeight) {
            this._fontWeight = fontWeight;
            this.styleID++;
        }
    }
    ;
    /**
     * The amount of spacing between letters, default is 0
     *
     * @member {number}
     */
    get letterSpacing() {
        return this._letterSpacing;
    }
    ;
    set letterSpacing(letterSpacing) {
        if (this._letterSpacing !== letterSpacing) {
            this._letterSpacing = letterSpacing;
            this.styleID++;
        }
    }
    ;
    /**
     * The line height, a number that represents the vertical space that a letter uses
     *
     * @member {number}
     */
    get lineHeight() {
        return this._lineHeight;
    }
    ;
    set lineHeight(lineHeight) {
        if (this._lineHeight !== lineHeight) {
            this._lineHeight = lineHeight;
            this.styleID++;
        }
    }
    ;
    /**
     * The space between lines
     *
     * @member {number}
     */
    get leading() {
        return this._leading;
    }
    ;
    set leading(leading) {
        if (this._leading !== leading) {
            this._leading = leading;
            this.styleID++;
        }
    }
    ;
    /**
     * The lineJoin property sets the type of corner created, it can resolve spiked text issues.
     * Default is 'miter' (creates a sharp corner).
     *
     * @member {string}
     */
    get lineJoin() {
        return this._lineJoin;
    }
    ;
    set lineJoin(lineJoin) {
        if (this._lineJoin !== lineJoin) {
            this._lineJoin = lineJoin;
            this.styleID++;
        }
    }
    ;
    /**
     * The miter limit to use when using the 'miter' lineJoin mode
     * This can reduce or increase the spikiness of rendered text.
     *
     * @member {number}
     */
    get miterLimit() {
        return this._miterLimit;
    }
    ;
    set miterLimit(miterLimit) {
        if (this._miterLimit !== miterLimit) {
            this._miterLimit = miterLimit;
            this.styleID++;
        }
    }
    ;
    /**
     * Occasionally some fonts are cropped. Adding some padding will prevent this from happening
     * by adding padding to all sides of the text.
     *
     * @member {number}
     */
    get padding() {
        return this._padding;
    }
    ;
    set padding(padding) {
        if (this._padding !== padding) {
            this._padding = padding;
            this.styleID++;
        }
    }
    ;
    /**
     * A canvas fillstyle that will be used on the text stroke
     * e.g 'blue', '#FCFF00'
     *
     * @member {string|number}
     */
    get stroke() {
        return this._stroke;
    }
    ;
    set stroke(stroke) {
        var outputColor = ColorSettings_1.ColorSettings.getColor(stroke);
        if (this._stroke !== outputColor) {
            this._stroke = outputColor;
            this.styleID++;
        }
    }
    ;
    /**
     * A number that represents the thickness of the stroke.
     * Default is 0 (no stroke)
     *
     * @member {number}
     */
    get strokeThickness() {
        return this._strokeThickness;
    }
    ;
    set strokeThickness(strokeThickness) {
        if (this._strokeThickness !== strokeThickness) {
            this._strokeThickness = strokeThickness;
            this.styleID++;
        }
    }
    ;
    /**
     * The baseline of the text that is rendered.
     *
     * @member {string}
     */
    get textBaseline() {
        return this._textBaseline;
    }
    ;
    set textBaseline(textBaseline) {
        if (this._textBaseline !== textBaseline) {
            this._textBaseline = textBaseline;
            this.styleID++;
        }
    }
    ;
    /**
     * Trim transparent borders
     *
     * @member {boolean}
     */
    get trim() {
        return this._trim;
    }
    ;
    set trim(trim) {
        if (this._trim !== trim) {
            this._trim = trim;
            this.styleID++;
        }
    }
    ;
    /**
     * How newlines and spaces should be handled.
     * Default is 'pre' (preserve, preserve).
     *
     *  value   | New lines |   Spaces
     *  ---     | ---       |   ---
     * 'normal' | Collapse  |   Collapse
     * 'pre'    | Preserve  |   Preserve
     * 'pre-line'   | Preserve  |   Collapse
     *
     * @member {string}
     */
    get whiteSpace() {
        return this._whiteSpace;
    }
    ;
    set whiteSpace(whiteSpace) {
        if (this._whiteSpace !== whiteSpace) {
            this._whiteSpace = whiteSpace;
            this.styleID++;
        }
    }
    ;
    /**
     * Indicates if word wrap should be used
     *
     * @member {boolean}
     */
    get wordWrap() {
        return this._wordWrap;
    }
    ;
    set wordWrap(wordWrap) {
        if (this._wordWrap !== wordWrap) {
            this._wordWrap = wordWrap;
            this.styleID++;
        }
    }
    ;
    /**
     * The width at which text will wrap, it needs wordWrap to be set to true
     *
     * @member {number}
     */
    get wordWrapWidth() {
        return this._wordWrapWidth;
    }
    ;
    set wordWrapWidth(wordWrapWidth) {
        if (this._wordWrapWidth !== wordWrapWidth) {
            this._wordWrapWidth = wordWrapWidth;
            this.styleID++;
        }
    }
    ;
    /**
     * Generates a font style string to use for `TextMetrics.measureFont()`.
     *
     * @return {string} Font style string, for passing to `TextMetrics.measureFont()`
     */
    toFontString() {
        // build canvas api font setting from individual components. Convert a numeric this.fontSize to px
        var fontSizeString = (typeof this.fontSize === 'number') ? ((this.fontSize) + "px") : this.fontSize;
        // Clean-up fontFamily property by quoting each font name
        // this will support font names with spaces
        var fontFamilies = this.fontFamily;
        if (!Array.isArray(this.fontFamily)) {
            fontFamilies = this.fontFamily.split(',');
        }
        for (var i = fontFamilies.length - 1; i >= 0; i--) {
            // Trim any extra white-space
            var fontFamily = fontFamilies[i].trim();
            // Check if font already contains strings
            if (!(/([\"\'])[^\'\"]+\1/).test(fontFamily)) {
                fontFamily = "\"" + fontFamily + "\"";
            }
            fontFamilies[i] = fontFamily;
        }
        return ((this.fontStyle) + " " + (this.fontVariant) + " " + (this.fontWeight) + " " + fontSizeString + " " + (fontFamilies.join(',')));
    }
    ;
}
exports.TextStyle = TextStyle;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/Texture.js":
/*!*******************************************!*\
  !*** ./js-compile/raw-pixi-ts/Texture.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const EventDispatcher_1 = __webpack_require__(/*! ./EventDispatcher */ "./js-compile/raw-pixi-ts/EventDispatcher.js");
const Rectangle_1 = __webpack_require__(/*! ../flash/geom/Rectangle */ "./js-compile/flash/geom/Rectangle.js");
const Point_1 = __webpack_require__(/*! ../flash/geom/Point */ "./js-compile/flash/geom/Point.js");
const Event_1 = __webpack_require__(/*! ./Event */ "./js-compile/raw-pixi-ts/Event.js");
const TextureUvs_1 = __webpack_require__(/*! ./TextureUvs */ "./js-compile/raw-pixi-ts/TextureUvs.js");
const BaseTexture_1 = __webpack_require__(/*! ./BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const ImageResource_1 = __webpack_require__(/*! ./ImageResource */ "./js-compile/raw-pixi-ts/ImageResource.js");
const CanvasResource_1 = __webpack_require__(/*! ./CanvasResource */ "./js-compile/raw-pixi-ts/CanvasResource.js");
const MathSettings_1 = __webpack_require__(/*! ./MathSettings */ "./js-compile/raw-pixi-ts/MathSettings.js");
const CacheSettings_1 = __webpack_require__(/*! ./CacheSettings */ "./js-compile/raw-pixi-ts/CacheSettings.js");
const DisplaySettings_1 = __webpack_require__(/*! ./DisplaySettings */ "./js-compile/raw-pixi-ts/DisplaySettings.js");
const NetworkSettings_1 = __webpack_require__(/*! ./NetworkSettings */ "./js-compile/raw-pixi-ts/NetworkSettings.js");
const InstanceCounter_1 = __webpack_require__(/*! ./InstanceCounter */ "./js-compile/raw-pixi-ts/InstanceCounter.js");
class Texture extends EventDispatcher_1.EventDispatcher {
    constructor(baseTexture, frame = null, orig = null, trim = null, rotate = null, anchor = null) {
        super();
        /**
         * Called when the base texture is updated
         *
         * @protected
         * @param {PIXI.BaseTexture} baseTexture - The base texture.
         */
        this.onBaseTextureUpdated = (baseTexture) => {
            this._updateID++;
            // TODO this code looks confusing.. boo to abusing getters and setters!
            if (this.noFrame) {
                InstanceCounter_1.InstanceCounter.addCall("Rectangle.getRectangle", "Texture onBaseTextureUpdated");
                this.frame = Rectangle_1.Rectangle.getRectangle(0, 0, baseTexture.width, baseTexture.height);
            }
            else {
                this.frame = this._frame;
                // TODO maybe watch out for the no frame option
                // updating the texture will should update the frame if it was set to no frame..
            }
            this.valid = this.baseTexture.valid;
            this.dispatchEvent(Event_1.Event.getEvent("update"));
            // this.emit('update', this);
            // this.baseTexture.addEventListener("update", this.onBaseTextureUpdated)
        };
        // InstanceCounter.count(this)
        this.noFrame = false;
        if (!frame) {
            this.noFrame = true;
            frame = Rectangle_1.Rectangle.getRectangle(0, 0, 1, 1);
        }
        if (baseTexture instanceof Texture) {
            baseTexture = baseTexture.baseTexture;
        }
        /**
         * The base texture that this texture uses.
         *
         * @member {PIXI.BaseTexture}
         */
        this.baseTexture = baseTexture;
        /**
         * This is the area of the BaseTexture image to actually copy to the Canvas / WebGL when rendering,
         * irrespective of the actual frame size or placement (which can be influenced by trimmed texture atlases)
         *
         * @member {PIXI.Rectangle}
         */
        this._frame = frame;
        /**
         * This is the trimmed area of original texture, before it was put in atlas
         * Please call `updateUvs()` after you change coordinates of `trim` manually.
         *
         * @member {PIXI.Rectangle}
         */
        this.trim = trim;
        /**
         * This will let the renderer know if the texture is valid. If it's not then it cannot be rendered.
         *
         * @member {boolean}
         */
        this.valid = false;
        /**
         * This will let a renderer know that a texture has been updated (used mainly for WebGL uv updates)
         *
         * @member {boolean}
         */
        this.requiresUpdate = false;
        /**
         * The WebGL UV data cache. Can be used as quad UV
         *
         * @member {PIXI.TextureUvs}
         * @protected
         */
        this._uvs = Texture.DEFAULT_UVS;
        /**
         * Default TextureMatrix instance for this texture
         * By default that object is not created because its heavy
         *
         * @member {PIXI.TextureMatrix}
         */
        this.uvMatrix = null;
        /**
         * This is the area of original texture, before it was put in atlas
         *
         * @member {PIXI.Rectangle}
         */
        this.orig = orig || frame; // new Rectangle(0, 0, 1, 1);
        this._rotate = Number(rotate || 0);
        if (rotate === true) {
            // this is old texturepacker legacy, some games/libraries are passing "true" for rotated textures
            this._rotate = 2;
        }
        else if (this._rotate % 2 !== 0) {
            throw new Error('attempt to use diamond-shaped UVs. If you are sure, set rotation manually');
        }
        if (baseTexture.valid) {
            if (this.noFrame) {
                if (frame) {
                    frame.recycle();
                }
                InstanceCounter_1.InstanceCounter.addCall("Rectangle.getRectangle", "Texture");
                frame = Rectangle_1.Rectangle.getRectangle(0, 0, baseTexture.width, baseTexture.height);
                // if there is no frame we should monitor for any base texture changes..
                baseTexture.addEventListener("update", this.onBaseTextureUpdated);
                // baseTexture.on('update', this.onBaseTextureUpdated, this);
            }
            this.frame = frame;
        }
        else {
            baseTexture.addEventListener("loaded", this.onBaseTextureUpdated);
            // baseTexture.once('loaded', this.onBaseTextureUpdated, this);
        }
        /**
         * Anchor point that is used as default if sprite is created with this texture.
         * Changing the `defaultAnchor` at a later point of time will not update Sprite's anchor point.
         * @member {PIXI.Point}
         * @default {0,0}
         */
        if (anchor) {
            this.defaultAnchor = Point_1.Point.getPoint(anchor.x, anchor.y);
        }
        else {
            this.defaultAnchor = Point_1.Point.getPoint(0, 0);
        }
        /**
         * Update ID is observed by sprites and TextureMatrix instances.
         * Call updateUvs() to increment it.
         *
         * @member {number}
         * @protected
         */
        this._updateID = 0;
        /**
         * The ids under which this Texture has been added to the texture cache. This is
         * automatically set as long as Texture.addToCache is used, but may not be set if a
         * Texture is added directly to the TextureCache array.
         *
         * @member {string[]}
         */
        this.textureCacheIds = [];
    }
    destructor() {
        if (this.defaultAnchor) {
            this.defaultAnchor.recycle();
        }
        this.defaultAnchor = null;
        if (this.trim) {
            this.trim.recycle();
        }
        this.trim = null;
        if (this.orig) {
            this.orig.recycle();
        }
        this.orig = null;
    }
    /**
     * Updates this texture on the gpu.
     *
     */
    update() {
        this.baseTexture.update();
    }
    ;
    /**
     * Destroys this texture
     *
     * @param {boolean} [destroyBase=false] Whether to destroy the base texture as well
     */
    destroy(destroyBase) {
        if (this.baseTexture) {
            if (destroyBase) {
                // delete the texture if it exists in the texture cache..
                // this only needs to be removed if the base texture is actually destroyed too..
                if (CacheSettings_1.CacheSettings.TextureCache[this.baseTexture.imageUrl]) {
                    Texture.removeFromCache(this.baseTexture.imageUrl);
                }
                this.baseTexture.destroy();
            }
            // this.baseTexture.remo('update', this.onBaseTextureUpdated, this);
            this.baseTexture = null;
        }
        if (this._frame) {
            this._frame.recycle();
        }
        this._frame = null;
        this._uvs = null;
        if (this.trim) {
            this.trim.recycle();
        }
        this.trim = null;
        if (this.orig) {
            this.orig.recycle();
        }
        this.orig = null;
        this.valid = false;
        Texture.removeFromCache(this);
        this.textureCacheIds = null;
    }
    ;
    /**
     * Creates a new texture object that acts the same as this one.
     *
     * @return {PIXI.Texture} The new texture
     */
    clone() {
        return new Texture(this.baseTexture, this.frame, this.orig, this.trim, this.rotate, this.defaultAnchor);
    }
    ;
    /**
     * Updates the internal WebGL UV cache. Use it after you change `frame` or `trim` of the texture.
     * Call it after changing the frame
     */
    updateUvs() {
        if (this._uvs === Texture.DEFAULT_UVS) {
            this._uvs = new TextureUvs_1.TextureUvs();
        }
        this._uvs.set(this._frame, this.baseTexture, this.rotate);
        this._updateID++;
    }
    ;
    /**
     * Helper function that creates a new Texture based on the source you provide.
     * The source can be - frame id, image url, video url, canvas element, video element, base texture
     *
     * @static
     * @param {number|string|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement|PIXI.BaseTexture} source
     *        Source to create texture from
     * @param {object} [options] See {@link PIXI.BaseTexture}'s constructor for options.
     * @return {PIXI.Texture} The newly created texture
     */
    static from(source, options = {}) {
        var cacheId = null;
        if (typeof source === 'string') {
            cacheId = source;
        }
        else {
            if (!source._pixiId) {
                source._pixiId = "pixiid_" + (MathSettings_1.MathSettings.uid());
            }
            cacheId = source._pixiId;
        }
        var texture = CacheSettings_1.CacheSettings.TextureCache[cacheId];
        if (!texture) {
            if (options['resolution'] == undefined) {
                options.resolution = NetworkSettings_1.NetworkSettings.getResolutionOfUrl(source);
            }
            texture = new Texture(new BaseTexture_1.BaseTexture(source, options));
            texture.baseTexture.cacheId = cacheId;
            BaseTexture_1.BaseTexture.addToCache(texture.baseTexture, cacheId);
            Texture.addToCache(texture, cacheId);
        }
        // lets assume its a base texture!
        return texture;
    }
    ;
    /**
     * Adds a Texture to the global TextureCache. This cache is shared across the whole PIXI object.
     *
     * @static
     * @param {PIXI.Texture} texture - The Texture to add to the cache.
     * @param {string} id - The id that the Texture will be stored against.
     */
    static addToCache(texture, id) {
        if (id) {
            if (texture.textureCacheIds.indexOf(id) === -1) {
                texture.textureCacheIds.push(id);
            }
            if (CacheSettings_1.CacheSettings.TextureCache[id]) {
                // eslint-disable-next-line no-console
                console.warn(("Texture added to the cache with an id [" + id + "] that already had an entry"));
            }
            CacheSettings_1.CacheSettings.TextureCache[id] = texture;
        }
    }
    ;
    /**
     * Remove a Texture from the global TextureCache.
     *
     * @static
     * @param {string|PIXI.Texture} texture - id of a Texture to be removed, or a Texture instance itself
     * @return {PIXI.Texture|null} The Texture that was removed
     */
    static removeFromCache(texture) {
        if (typeof texture === 'string') {
            var textureFromCache = CacheSettings_1.CacheSettings.TextureCache[texture];
            if (textureFromCache) {
                var index = textureFromCache.textureCacheIds.indexOf(texture);
                if (index > -1) {
                    textureFromCache.textureCacheIds.splice(index, 1);
                }
                delete CacheSettings_1.CacheSettings.TextureCache[texture];
                return textureFromCache;
            }
        }
        else if (texture && texture.textureCacheIds) {
            for (var i = 0; i < texture.textureCacheIds.length; ++i) {
                // Check that texture matches the one being passed in before deleting it from the cache.
                if (CacheSettings_1.CacheSettings.TextureCache[texture.textureCacheIds[i]] === texture) {
                    delete CacheSettings_1.CacheSettings.TextureCache[texture.textureCacheIds[i]];
                }
            }
            texture.textureCacheIds.length = 0;
            return texture;
        }
        return null;
    }
    ;
    get frame() {
        return this._frame;
    }
    ;
    set frame(frame) {
        this._frame = frame;
        this.noFrame = false;
        var x = frame.x;
        var y = frame.y;
        var width = frame.width;
        var height = frame.height;
        var xNotFit = x + width > this.baseTexture.width;
        var yNotFit = y + height > this.baseTexture.height;
        if (xNotFit || yNotFit) {
            var relationship = xNotFit && yNotFit ? 'and' : 'or';
            var errorX = "X: " + x + " + " + width + " = " + (x + width) + " > " + (this.baseTexture.width);
            var errorY = "Y: " + y + " + " + height + " = " + (y + height) + " > " + (this.baseTexture.height);
            throw new Error('Texture Error: frame does not fit inside the base Texture dimensions: '
                + errorX + " " + relationship + " " + errorY);
        }
        this.valid = width && height && this.baseTexture.valid;
        if (!this.trim && !this.rotate) {
            this.orig = frame;
        }
        if (this.valid) {
            this.updateUvs();
        }
    }
    ;
    /**
     * Indicates whether the texture is rotated inside the atlas
     * set to 2 to compensate for texture packer rotation
     * set to 6 to compensate for spine packer rotation
     * can be used to rotate or mirror sprites
     * See {@link PIXI.GroupD8} for explanation
     *
     * @member {number}
     */
    get rotate() {
        return this._rotate;
    }
    ;
    set rotate(rotate) {
        this._rotate = rotate;
        if (this.valid) {
            this.updateUvs();
        }
    }
    ;
    /**
     * The width of the Texture in pixels.
     *
     * @member {number}
     */
    get width() {
        return this.orig.width;
    }
    ;
    /**
     * The height of the Texture in pixels.
     *
     * @member {number}
     */
    get height() {
        return this.orig.height;
    }
    ;
    /**
     * An empty texture, used often to not have to create multiple empty textures.
     * Can not be destroyed.
     *
     * @static
     * @constant
     * @member {PIXI.Texture}
     */
    static get EMPTY() {
        return new Texture(new BaseTexture_1.BaseTexture());
    }
    /**
 * A white texture of 10x10 size, used for graphics and other things
 * Can not be destroyed.
 *
 * @static
 * @constant
 * @member {PIXI.Texture}
 */
    static get WHITE() {
        return Texture.createWhiteTexture();
    }
    static createWhiteTexture() {
        var canvas = document.createElement('canvas');
        canvas.width = 16;
        canvas.height = 16;
        var context = canvas.getContext('2d');
        context.fillStyle = 'white';
        context.fillRect(0, 0, 16, 16);
        return new Texture(new BaseTexture_1.BaseTexture(new CanvasResource_1.CanvasResource(canvas)));
    }
}
Texture.DEFAULT_UVS = new TextureUvs_1.TextureUvs();
/**
 * Create a new Texture with a BufferResource from a Float32Array.
 * RGBA values are floats from 0 to 1.
 * @static
 * @param {Float32Array|Uint8Array} buffer The optional array to use, if no data
 *        is provided, a new Float32Array is created.
 * @param {number} width - Width of the resource
 * @param {number} height - Height of the resource
 * @param {object} [options] See {@link PIXI.BaseTexture}'s constructor for options.
 * @return {PIXI.Texture} The resulting new BaseTexture
 */
Texture.fromBuffer = function fromBuffer(buffer, width, height, options) {
    return new Texture(BaseTexture_1.BaseTexture.fromBuffer(buffer, width, height, options));
};
/**
 * Create a texture from a source and add to the cache.
 *
 * @static
 * @param {HTMLImageElement|HTMLCanvasElement} source - The input source.
 * @param {String} imageUrl - File name of texture, for cache and resolving resolution.
 * @param {String} [name] - Human readable name for the texture cache. If no name is
 *        specified, only `imageUrl` will be used as the cache ID.
 * @return {PIXI.Texture} Output texture
 */
Texture.fromLoader = function fromLoader(source, imageUrl, name) {
    var resource = new ImageResource_1.ImageResource(source);
    resource.url = imageUrl;
    var baseTexture = new BaseTexture_1.BaseTexture(resource, {
        scaleMode: DisplaySettings_1.DisplaySettings.SCALE_MODE,
        resolution: NetworkSettings_1.NetworkSettings.getResolutionOfUrl(imageUrl),
    });
    var texture = new Texture(baseTexture);
    // No name, use imageUrl instead
    if (!name) {
        name = imageUrl;
    }
    // lets also add the frame to pixi's global cache for fromFrame and fromImage functions
    BaseTexture_1.BaseTexture.addToCache(texture.baseTexture, name);
    Texture.addToCache(texture, name);
    // also add references by url if they are different.
    if (name !== imageUrl) {
        BaseTexture_1.BaseTexture.addToCache(texture.baseTexture, imageUrl);
        Texture.addToCache(texture, imageUrl);
    }
    return texture;
};
exports.Texture = Texture;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/TextureGCSystem.js":
/*!***************************************************!*\
  !*** ./js-compile/raw-pixi-ts/TextureGCSystem.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const System_1 = __webpack_require__(/*! ./System */ "./js-compile/raw-pixi-ts/System.js");
const settings_1 = __webpack_require__(/*! ./settings */ "./js-compile/raw-pixi-ts/settings.js");
class TextureGCSystem extends System_1.System {
    constructor(renderer) {
        super(renderer);
        /**
         * Count
         * @member {number}
         * @readonly
         */
        this.count = 0;
        /**
         * Check count
         * @member {number}
         * @readonly
         */
        this.checkCount = 0;
        /**
         * Maximum idle time, in seconds
         * @member {number}
         * @see PIXI.settings.GC_MAX_IDLE
         */
        this.maxIdle = settings_1.settings.GC_MAX_IDLE;
        /**
         * Maximum number of itesm to check
         * @member {number}
         * @see PIXI.settings.GC_MAX_CHECK_COUNT
         */
        this.checkCountMax = settings_1.settings.GC_MAX_CHECK_COUNT;
        /**
         * Current garabage collection mode
         * @member {PIXI.GC_MODES}
         * @see PIXI.settings.GC_MODE
         */
        this.mode = settings_1.settings.GC_MODE;
    }
    /**
     * Checks to see when the last time a texture was used
     * if the texture has not been used for a specified amount of time it will be removed from the GPU
     */
    postrender() {
        this.count++;
        if (this.mode === settings_1.settings.GC_MODES.MANUAL) {
            return;
        }
        this.checkCount++;
        if (this.checkCount > this.checkCountMax) {
            this.checkCount = 0;
            this.run();
        }
    }
    ;
    /**
     * Checks to see when the last time a texture was used
     * if the texture has not been used for a specified amount of time it will be removed from the GPU
     */
    run() {
        var tm = this.renderer.texture;
        var managedTextures = tm.managedTextures;
        var wasRemoved = false;
        for (var i = 0; i < managedTextures.length; i++) {
            var texture = managedTextures[i];
            // only supports non generated textures at the moment!
            if (!texture.framebuffer && this.count - texture.touched > this.maxIdle) {
                tm.destroyTexture(texture, true);
                managedTextures[i] = null;
                wasRemoved = true;
            }
        }
        if (wasRemoved) {
            var j = 0;
            for (var i$1 = 0; i$1 < managedTextures.length; i$1++) {
                if (managedTextures[i$1] !== null) {
                    managedTextures[j++] = managedTextures[i$1];
                }
            }
            managedTextures.length = j;
        }
    }
    ;
    /**
     * Removes all the textures within the specified displayObject and its children from the GPU
     *
     * @param {PIXI.DisplayObject} displayObject - the displayObject to remove the textures from.
     */
    unload(displayObject) {
        // var tm = this.renderer.textureSystem;
        var tm = this.renderer.texture;
        // only destroy non generated textures
        if (displayObject._texture && displayObject._texture._glRenderTargets) {
            tm.destroyTexture(displayObject._texture);
        }
        for (var i = displayObject.children.length - 1; i >= 0; i--) {
            this.unload(displayObject.children[i]);
        }
    }
    ;
}
exports.TextureGCSystem = TextureGCSystem;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/TextureMatrix.js":
/*!*************************************************!*\
  !*** ./js-compile/raw-pixi-ts/TextureMatrix.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Matrix_1 = __webpack_require__(/*! ./Matrix */ "./js-compile/raw-pixi-ts/Matrix.js");
class TextureMatrix {
    constructor(texture, clampMargin = null) {
        this._texture = texture;
        this.mapCoord = new Matrix_1.Matrix();
        this.uClampFrame = new Float32Array(4);
        this.uClampOffset = new Float32Array(2);
        /**
         * Tracks Texture frame changes
         * @member {number}
         * @protected
         */
        this._updateID = -1;
        /**
         * Changes frame clamping
         * Works with TilingSprite and Mesh
         * Change to 1.5 if you texture has repeated right and bottom lines, that leads to smoother borders
         *
         * @default 0
         * @member {number}
         */
        this.clampOffset = 0;
        /**
         * Changes frame clamping
         * Works with TilingSprite and Mesh
         * Change to -0.5 to add a pixel to the edge, recommended for transparent trimmed textures in atlas
         *
         * @default 0.5
         * @member {number}
         */
        this.clampMargin = (typeof clampMargin === 'undefined') ? 0.5 : clampMargin;
        /**
         * If texture size is the same as baseTexture
         * @member {boolean}
         * @default false
         * @readonly
         */
        this.isSimple = false;
    }
    /**
     * texture property
     * @member {PIXI.Texture}
     */
    get texture() {
        return this._texture;
    }
    ;
    set texture(value) {
        this._texture = value;
        this._updateID = -1;
    }
    ;
    /**
     * Multiplies uvs array to transform
     * @param {Float32Array} uvs mesh uvs
     * @param {Float32Array} [out=uvs] output
     * @returns {Float32Array} output
     */
    multiplyUvs(uvs, out) {
        if (out === undefined) {
            out = uvs;
        }
        var mat = this.mapCoord;
        for (var i = 0; i < uvs.length; i += 2) {
            var x = uvs[i];
            var y = uvs[i + 1];
            out[i] = (x * mat.a) + (y * mat.c) + mat.tx;
            out[i + 1] = (x * mat.b) + (y * mat.d) + mat.ty;
        }
        return out;
    }
    ;
    /**
     * updates matrices if texture was changed
     * @param {boolean} forceUpdate if true, matrices will be updated any case
     * @returns {boolean} whether or not it was updated
     */
    update(forceUpdate) {
        var tex = this._texture;
        if (!tex || !tex.valid) {
            return false;
        }
        if (!forceUpdate
            && this._updateID === tex._updateID) {
            return false;
        }
        this._updateID = tex._updateID;
        var uvs = tex._uvs;
        this.mapCoord.set(uvs.x1 - uvs.x0, uvs.y1 - uvs.y0, uvs.x3 - uvs.x0, uvs.y3 - uvs.y0, uvs.x0, uvs.y0);
        var orig = tex.orig;
        var trim = tex.trim;
        if (trim) {
            TextureMatrix.tempMat.set(orig.width / trim.width, 0, 0, orig.height / trim.height, -trim.x / trim.width, -trim.y / trim.height);
            this.mapCoord.append(TextureMatrix.tempMat);
        }
        var texBase = tex.baseTexture;
        var frame = this.uClampFrame;
        var margin = this.clampMargin / texBase.resolution;
        var offset = this.clampOffset;
        frame[0] = (tex._frame.x + margin + offset) / texBase.width;
        frame[1] = (tex._frame.y + margin + offset) / texBase.height;
        frame[2] = (tex._frame.x + tex._frame.width - margin + offset) / texBase.width;
        frame[3] = (tex._frame.y + tex._frame.height - margin + offset) / texBase.height;
        this.uClampOffset[0] = offset / texBase.realWidth;
        this.uClampOffset[1] = offset / texBase.realHeight;
        this.isSimple = tex._frame.width === texBase.width
            && tex._frame.height === texBase.height
            && tex.rotate === 0;
        return true;
    }
    ;
}
TextureMatrix.tempMat = new Matrix_1.Matrix();
exports.TextureMatrix = TextureMatrix;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/TextureSystem.js":
/*!*************************************************!*\
  !*** ./js-compile/raw-pixi-ts/TextureSystem.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const System_1 = __webpack_require__(/*! ./System */ "./js-compile/raw-pixi-ts/System.js");
const BaseTexture_1 = __webpack_require__(/*! ./BaseTexture */ "./js-compile/raw-pixi-ts/BaseTexture.js");
const GLTexture_1 = __webpack_require__(/*! ./GLTexture */ "./js-compile/raw-pixi-ts/GLTexture.js");
const UtilsSettings_1 = __webpack_require__(/*! ./UtilsSettings */ "./js-compile/raw-pixi-ts/UtilsSettings.js");
const WebGLSettings_1 = __webpack_require__(/*! ./WebGLSettings */ "./js-compile/raw-pixi-ts/WebGLSettings.js");
class TextureSystem extends System_1.System {
    constructor(renderer) {
        super(renderer);
        // TODO set to max textures...
        /**
         * Bound textures
         * @member {PIXI.BaseTexture[]}
         * @readonly
         */
        this.boundTextures = [];
        /**
         * Current location
         * @member {number}
         * @readonly
         */
        this.currentLocation = -1;
        /**
         * List of managed textures
         * @member {PIXI.BaseTexture[]}
         * @readonly
         */
        this.managedTextures = [];
        /**
         * Did someone temper with textures state? We'll overwrite them when we need to unbind something.
         * @member {boolean}
         * @private
         */
        this._unknownBoundTextures = false;
        /**
         * BaseTexture value that shows that we don't know what is bound
         * @member {PIXI.BaseTexture}
         * @readonly
         */
        this.unknownTexture = new BaseTexture_1.BaseTexture();
    }
    /**
     * Sets up the renderer context and necessary buffers.
     */
    contextChange() {
        var gl = this.gl = this.renderer.gl;
        this.CONTEXT_UID = this.renderer.CONTEXT_UID;
        this.webGLVersion = this.renderer.context.webGLVersion;
        var maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
        this.boundTextures.length = maxTextures;
        for (var i = 0; i < maxTextures; i++) {
            this.boundTextures[i] = null;
        }
        // TODO move this.. to a nice make empty textures class..
        this.emptyTextures = {};
        var emptyTexture2D = new GLTexture_1.GLTexture(gl.createTexture());
        gl.bindTexture(gl.TEXTURE_2D, emptyTexture2D.texture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array(4));
        this.emptyTextures[gl.TEXTURE_2D] = emptyTexture2D;
        this.emptyTextures[gl.TEXTURE_CUBE_MAP] = new GLTexture_1.GLTexture(gl.createTexture());
        gl.bindTexture(gl.TEXTURE_CUBE_MAP, this.emptyTextures[gl.TEXTURE_CUBE_MAP].texture);
        for (var i$1 = 0; i$1 < 6; i$1++) {
            gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + i$1, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
        }
        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        for (var i$2 = 0; i$2 < this.boundTextures.length; i$2++) {
            this.bind(null, i$2);
        }
    }
    ;
    /**
     * Bind a texture to a specific location
     *
     * If you want to unbind something, please use `unbind(texture)` instead of `bind(null, textureLocation)`
     *
     * @param {PIXI.Texture|PIXI.BaseTexture} texture - Texture to bind
     * @param {number} [location=0] - Location to bind at
     */
    bind(texture, location = 0) {
        var ref = this;
        var gl = ref.gl;
        if (texture) {
            texture = texture.baseTexture || texture;
            if (texture.valid) {
                texture.touched = this.renderer.textureGC.count;
                var glTexture = texture._glTextures[this.CONTEXT_UID] || this.initTexture(texture);
                if (this.currentLocation !== location) {
                    this.currentLocation = location;
                    gl.activeTexture(gl.TEXTURE0 + location);
                }
                if (this.boundTextures[location] !== texture) {
                    gl.bindTexture(texture.target, glTexture.texture);
                }
                if (glTexture.dirtyId !== texture.dirtyId) {
                    this.updateTexture(texture);
                }
                this.boundTextures[location] = texture;
            }
        }
        else {
            if (this.currentLocation !== location) {
                this.currentLocation = location;
                gl.activeTexture(gl.TEXTURE0 + location);
            }
            gl.bindTexture(gl.TEXTURE_2D, this.emptyTextures[gl.TEXTURE_2D].texture);
            this.boundTextures[location] = null;
        }
    }
    ;
    /**
     * Resets texture location and bound textures
     *
     * Actual `bind(null, i)` calls will be performed at next `unbind()` call
     */
    reset() {
        this._unknownBoundTextures = true;
        this.currentLocation = -1;
        for (var i = 0; i < this.boundTextures.length; i++) {
            this.boundTextures[i] = this.unknownTexture;
        }
    }
    ;
    /**
     * Unbind a texture
     * @param {PIXI.Texture|PIXI.BaseTexture} texture - Texture to bind
     */
    unbind(texture) {
        var ref = this;
        var gl = ref.gl;
        var boundTextures = ref.boundTextures;
        if (this._unknownBoundTextures) {
            this._unknownBoundTextures = false;
            // someone changed webGL state,
            // we have to be sure that our texture does not appear in multi-texture renderer samplers
            for (var i = 0; i < boundTextures.length; i++) {
                if (boundTextures[i] === this.unknownTexture) {
                    this.bind(null, i);
                }
            }
        }
        for (var i$1 = 0; i$1 < boundTextures.length; i$1++) {
            if (boundTextures[i$1] === texture) {
                if (this.currentLocation !== i$1) {
                    gl.activeTexture(gl.TEXTURE0 + i$1);
                    this.currentLocation = i$1;
                }
                gl.bindTexture(gl.TEXTURE_2D, this.emptyTextures[texture.target].texture);
                boundTextures[i$1] = null;
            }
        }
    }
    ;
    /**
     * Initialize a texture
     *
     * @private
     * @param {PIXI.BaseTexture} texture - Texture to initialize
     */
    initTexture(texture) {
        var glTexture = new GLTexture_1.GLTexture(this.gl.createTexture());
        // guarantee an update..
        glTexture.dirtyId = -1;
        texture._glTextures[this.CONTEXT_UID] = glTexture;
        this.managedTextures.push(texture);
        // texture.on('dispose', this.destroyTexture, this);
        return glTexture;
    }
    ;
    /**
     * Update a texture
     *
     * @private
     * @param {PIXI.BaseTexture} texture - Texture to initialize
     */
    updateTexture(texture) {
        var glTexture = texture._glTextures[this.CONTEXT_UID];
        var renderer = this.renderer;
        if (texture.resource && texture.resource.canUpload) {
            texture.resource.upload(renderer, texture, glTexture);
        }
        // if (texture.resource && texture.resource.upload(renderer, texture, glTexture))
        else if (texture.resource && this.uploadTexture(renderer, texture, glTexture, texture.resource)) {
        }
        else {
            // default, renderTexture-like logic
            var width = texture.realWidth;
            var height = texture.realHeight;
            var gl = renderer.gl;
            if (glTexture.width !== width
                || glTexture.height !== height
                || glTexture.dirtyId < 0) {
                glTexture.width = width;
                glTexture.height = height;
                gl.texImage2D(texture.target, 0, texture.format, width, height, 0, texture.format, texture.type, null);
            }
        }
        // lets only update what changes..
        if (texture.dirtyStyleId !== glTexture.dirtyStyleId) {
            this.updateTextureStyle(texture);
        }
        glTexture.dirtyId = texture.dirtyId;
    }
    ;
    uploadTexture(renderer, baseTexture, glTexture, source) {
        var gl = renderer.gl;
        var width = baseTexture.realWidth;
        var height = baseTexture.realHeight;
        // source = source || this.source;
        if (source.constructor['name'] == "CanvasResource") {
            source = source.source;
        }
        else if (source.constructor['name'] == "ImageResource") {
            source = source.source;
        }
        else if (source.constructor['name'] == "VideoResource") {
            source = source.source;
        }
        // else if(source.constructor['name'] == "GradientResource")
        // {
        //     if(!source.source)
        //     {
        //         return
        //     }
        //     source = source.source
        // }
        else {
        }
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, baseTexture.premultiplyAlpha);
        if (baseTexture.target === gl.TEXTURE_2D && glTexture.width === width && glTexture.height === height) {
            gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, baseTexture.format, baseTexture.type, source);
        }
        else {
            glTexture.width = width;
            glTexture.height = height;
            gl.texImage2D(baseTexture.target, 0, baseTexture.format, baseTexture.format, baseTexture.type, source);
        }
        return true;
    }
    ;
    /**
     * Deletes the texture from WebGL
     *
     * @private
     * @param {PIXI.BaseTexture|PIXI.Texture} texture - the texture to destroy
     * @param {boolean} [skipRemove=false] - Whether to skip removing the texture from the TextureManager.
     */
    destroyTexture(texture, skipRemove = false) {
        var ref = this;
        var gl = ref.gl;
        texture = texture.baseTexture || texture;
        if (texture._glTextures[this.renderer.CONTEXT_UID]) {
            this.unbind(texture);
            gl.deleteTexture(texture._glTextures[this.renderer.CONTEXT_UID].texture);
            // texture.off('dispose', this.destroyTexture, this);
            delete texture._glTextures[this.renderer.CONTEXT_UID];
            if (!skipRemove) {
                var i = this.managedTextures.indexOf(texture);
                if (i !== -1) {
                    UtilsSettings_1.UtilsSettings.removeItems(this.managedTextures, i, 1);
                }
            }
        }
    }
    ;
    /**
     * Update texture style such as mipmap flag
     *
     * @private
     * @param {PIXI.BaseTexture} texture - Texture to update
     */
    updateTextureStyle(texture) {
        var glTexture = texture._glTextures[this.CONTEXT_UID];
        if (!glTexture) {
            return;
        }
        if ((texture.mipmap === WebGLSettings_1.WebGLSettings.MIPMAP_MODES.POW2 || this.webGLVersion !== 2) && !texture.isPowerOfTwo) {
            glTexture.mipmap = 0;
            glTexture.wrapMode = WebGLSettings_1.WebGLSettings.WRAP_MODES.CLAMP;
        }
        else {
            glTexture.mipmap = texture.mipmap >= 1;
            glTexture.wrapMode = texture.wrapMode;
        }
        // if (texture.resource && texture.resource.style(this.renderer, texture, glTexture))
        // { ; }
        // else
        // {
        this.setStyle(texture, glTexture);
        // }
        glTexture.dirtyStyleId = texture.dirtyStyleId;
    }
    ;
    /**
     * Set style for texture
     *
     * @private
     * @param {PIXI.BaseTexture} texture - Texture to update
     * @param {glTexture} glTexture
     */
    setStyle(texture, glTexture) {
        var gl = this.gl;
        if (glTexture.mipmap) {
            gl.generateMipmap(texture.target);
        }
        gl.texParameteri(texture.target, gl.TEXTURE_WRAP_S, glTexture.wrapMode);
        gl.texParameteri(texture.target, gl.TEXTURE_WRAP_T, glTexture.wrapMode);
        if (glTexture.mipmap) {
            /* eslint-disable max-len */
            gl.texParameteri(texture.target, gl.TEXTURE_MIN_FILTER, texture.scaleMode ? gl.LINEAR_MIPMAP_LINEAR : gl.NEAREST_MIPMAP_NEAREST);
            /* eslint-disable max-len */
        }
        else {
            gl.texParameteri(texture.target, gl.TEXTURE_MIN_FILTER, texture.scaleMode ? gl.LINEAR : gl.NEAREST);
        }
        gl.texParameteri(texture.target, gl.TEXTURE_MAG_FILTER, texture.scaleMode ? gl.LINEAR : gl.NEAREST);
    }
    ;
}
exports.TextureSystem = TextureSystem;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/TextureUvs.js":
/*!**********************************************!*\
  !*** ./js-compile/raw-pixi-ts/TextureUvs.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const GroupD8_1 = __webpack_require__(/*! ./GroupD8 */ "./js-compile/raw-pixi-ts/GroupD8.js");
class TextureUvs {
    constructor() {
        this.x0 = 0;
        this.y0 = 0;
        this.x1 = 1;
        this.y1 = 0;
        this.x2 = 1;
        this.y2 = 1;
        this.x3 = 0;
        this.y3 = 1;
        this.uvsFloat32 = new Float32Array(8);
    }
    /**
 * Sets the texture Uvs based on the given frame information.
 *
 * @protected
 * @param {PIXI.Rectangle} frame - The frame of the texture
 * @param {PIXI.Rectangle} baseFrame - The base frame of the texture
 * @param {number} rotate - Rotation of frame, see {@link PIXI.GroupD8}
 */
    set(frame, baseFrame, rotate) {
        var tw = baseFrame.width;
        var th = baseFrame.height;
        if (rotate) {
            // width and height div 2 div baseFrame size
            var w2 = frame.width / 2 / tw;
            var h2 = frame.height / 2 / th;
            // coordinates of center
            var cX = (frame.x / tw) + w2;
            var cY = (frame.y / th) + h2;
            rotate = GroupD8_1.GroupD8.add(rotate, GroupD8_1.GroupD8.NW); // NW is top-left corner
            this.x0 = cX + (w2 * GroupD8_1.GroupD8.uX(rotate));
            this.y0 = cY + (h2 * GroupD8_1.GroupD8.uY(rotate));
            rotate = GroupD8_1.GroupD8.add(rotate, 2); // rotate 90 degrees clockwise
            this.x1 = cX + (w2 * GroupD8_1.GroupD8.uX(rotate));
            this.y1 = cY + (h2 * GroupD8_1.GroupD8.uY(rotate));
            rotate = GroupD8_1.GroupD8.add(rotate, 2);
            this.x2 = cX + (w2 * GroupD8_1.GroupD8.uX(rotate));
            this.y2 = cY + (h2 * GroupD8_1.GroupD8.uY(rotate));
            rotate = GroupD8_1.GroupD8.add(rotate, 2);
            this.x3 = cX + (w2 * GroupD8_1.GroupD8.uX(rotate));
            this.y3 = cY + (h2 * GroupD8_1.GroupD8.uY(rotate));
        }
        else {
            this.x0 = frame.x / tw;
            this.y0 = frame.y / th;
            this.x1 = (frame.x + frame.width) / tw;
            this.y1 = frame.y / th;
            this.x2 = (frame.x + frame.width) / tw;
            this.y2 = (frame.y + frame.height) / th;
            this.x3 = frame.x / tw;
            this.y3 = (frame.y + frame.height) / th;
        }
        this.uvsFloat32[0] = this.x0;
        this.uvsFloat32[1] = this.y0;
        this.uvsFloat32[2] = this.x1;
        this.uvsFloat32[3] = this.y1;
        this.uvsFloat32[4] = this.x2;
        this.uvsFloat32[5] = this.y2;
        this.uvsFloat32[6] = this.x3;
        this.uvsFloat32[7] = this.y3;
    }
    ;
}
exports.TextureUvs = TextureUvs;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/Ticker.js":
/*!******************************************!*\
  !*** ./js-compile/raw-pixi-ts/Ticker.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const EventDispatcher_1 = __webpack_require__(/*! ./EventDispatcher */ "./js-compile/raw-pixi-ts/EventDispatcher.js");
const TickerListener_1 = __webpack_require__(/*! ./TickerListener */ "./js-compile/raw-pixi-ts/TickerListener.js");
const settings_1 = __webpack_require__(/*! ./settings */ "./js-compile/raw-pixi-ts/settings.js");
class Ticker extends EventDispatcher_1.EventDispatcher {
    constructor() {
        super();
        var this$1 = this;
        /**
         * The first listener. All new listeners added are chained on this.
         * @private
         * @type {TickerListener}
         */
        this._head = new TickerListener_1.TickerListener(null, null, Infinity);
        /**
         * Internal current frame request ID
         * @type {?number}
         * @private
         */
        this._requestId = null;
        /**
         * Internal value managed by minFPS property setter and getter.
         * This is the maximum allowed milliseconds between updates.
         * @type {number}
         * @private
         */
        this._maxElapsedMS = 100;
        /**
         * Internal value managed by maxFPS property setter and getter.
         * This is the minimum allowed milliseconds between updates.
         * @private
         */
        this._minElapsedMS = 0;
        /**
         * Whether or not this ticker should invoke the method
         * {@link PIXI.Ticker#start} automatically
         * when a listener is added.
         *
         * @member {boolean}
         * @default false
         */
        this.autoStart = false;
        /**
         * Scalar time value from last frame to this frame.
         * This value is capped by setting {@link PIXI.Ticker#minFPS}
         * and is scaled with {@link PIXI.Ticker#speed}.
         * **Note:** The cap may be exceeded by scaling.
         *
         * @member {number}
         * @default 1
         */
        this.deltaTime = 1;
        /**
         * Scaler time elapsed in milliseconds from last frame to this frame.
         * This value is capped by setting {@link PIXI.Ticker#minFPS}
         * and is scaled with {@link PIXI.Ticker#speed}.
         * **Note:** The cap may be exceeded by scaling.
         * If the platform supports DOMHighResTimeStamp,
         * this value will have a precision of 1 s.
         * Defaults to target frame time
         *
         * @member {number}
         * @default 16.66
         */
        this.deltaMS = 1 / settings_1.settings.TARGET_FPMS;
        /**
         * Time elapsed in milliseconds from last frame to this frame.
         * Opposed to what the scalar {@link PIXI.Ticker#deltaTime}
         * is based, this value is neither capped nor scaled.
         * If the platform supports DOMHighResTimeStamp,
         * this value will have a precision of 1 s.
         * Defaults to target frame time
         *
         * @member {number}
         * @default 16.66
         */
        this.elapsedMS = 1 / settings_1.settings.TARGET_FPMS;
        /**
         * The last time {@link PIXI.Ticker#update} was invoked.
         * This value is also reset internally outside of invoking
         * update, but only when a new animation frame is requested.
         * If the platform supports DOMHighResTimeStamp,
         * this value will have a precision of 1 s.
         *
         * @member {number}
         * @default -1
         */
        this.lastTime = -1;
        /**
         * Factor of current {@link PIXI.Ticker#deltaTime}.
         * @example
         * // Scales ticker.deltaTime to what would be
         * // the equivalent of approximately 120 FPS
         * ticker.speed = 2;
         *
         * @member {number}
         * @default 1
         */
        this.speed = 1;
        /**
         * Whether or not this ticker has been started.
         * `true` if {@link PIXI.Ticker#start} has been called.
         * `false` if {@link PIXI.Ticker#stop} has been called.
         * While `false`, this value may change to `true` in the
         * event of {@link PIXI.Ticker#autoStart} being `true`
         * and a listener is added.
         *
         * @member {boolean}
         * @default false
         */
        this.started = false;
        /**
         * If enabled, deleting is disabled.
         * @member {boolean}
         * @default false
         * @private
         */
        this._protected = false;
        /**
         * Internal tick method bound to ticker instance.
         * This is because in early 2015, Function.bind
         * is still 60% slower in high performance scenarios.
         * Also separating frame requests from update method
         * so listeners may be called at any time and with
         * any animation API, just invoke ticker.update(time).
         *
         * @private
         * @param {number} time - Time since last tick.
         */
        this._tick = function (time) {
            this$1._requestId = null;
            if (this$1.started) {
                // Invoke listeners now
                this$1.update(time);
                // Listener side effects may have modified ticker state.
                if (this$1.started && this$1._requestId === null && this$1._head.next) {
                    this$1._requestId = requestAnimationFrame(this$1._tick);
                }
            }
        };
    }
    /**
     * Internally adds the event handler so that it can be sorted by priority.
     * Priority allows certain handler (user, AnimatedSprite, Interaction) to be run
     * before the rendering.
     *
     * @private
     * @param {TickerListener} listener - Current listener being added.
     * @returns {PIXI.Ticker} This instance of a ticker
     */
    _addListener(listener) {
        // For attaching to head
        var current = this._head.next;
        var previous = this._head;
        // Add the first item
        if (!current) {
            listener.connect(previous);
        }
        else {
            // Go from highest to lowest priority
            while (current) {
                if (listener.priority > current.priority) {
                    listener.connect(previous);
                    break;
                }
                previous = current;
                current = current.next;
            }
            // Not yet connected
            if (!listener.previous) {
                listener.connect(previous);
            }
        }
        this._startIfPossible();
        return this;
    }
    ;
    /**
     * Triggers an update. An update entails setting the
     * current {@link PIXI.Ticker#elapsedMS},
     * the current {@link PIXI.Ticker#deltaTime},
     * invoking all listeners with current deltaTime,
     * and then finally setting {@link PIXI.Ticker#lastTime}
     * with the value of currentTime that was provided.
     * This method will be called automatically by animation
     * frame callbacks if the ticker instance has been started
     * and listeners are added.
     *
     * @param {number} [currentTime=performance.now()] - the current time of execution
     */
    update(currentTime) {
        if (currentTime === void 0) {
            currentTime = performance.now();
        }
        var elapsedMS;
        // If the difference in time is zero or negative, we ignore most of the work done here.
        // If there is no valid difference, then should be no reason to let anyone know about it.
        // A zero delta, is exactly that, nothing should update.
        //
        // The difference in time can be negative, and no this does not mean time traveling.
        // This can be the result of a race condition between when an animation frame is requested
        // on the current JavaScript engine event loop, and when the ticker's start method is invoked
        // (which invokes the internal _requestIfNeeded method). If a frame is requested before
        // _requestIfNeeded is invoked, then the callback for the animation frame the ticker requests,
        // can receive a time argument that can be less than the lastTime value that was set within
        // _requestIfNeeded. This difference is in microseconds, but this is enough to cause problems.
        //
        // This check covers this browser engine timing issue, as well as if consumers pass an invalid
        // currentTime value. This may happen if consumers opt-out of the autoStart, and update themselves.
        if (currentTime > this.lastTime) {
            // Save uncapped elapsedMS for measurement
            elapsedMS = this.elapsedMS = currentTime - this.lastTime;
            // cap the milliseconds elapsed used for deltaTime
            if (elapsedMS > this._maxElapsedMS) {
                elapsedMS = this._maxElapsedMS;
            }
            elapsedMS *= this.speed;
            // if not enough time has passed, exit the function.
            // We give an extra ms to elapsedMS for this check, because the nature of
            // request animation frame means that not all browsers will return precise values.
            // However, because rAF works based on v-sync, it's won't change the effective FPS.
            if (this._minElapsedMS && elapsedMS + 1 < this._minElapsedMS) {
                return;
            }
            this.deltaMS = elapsedMS;
            this.deltaTime = this.deltaMS * settings_1.settings.TARGET_FPMS;
            // Cache a local reference, in-case ticker is destroyed
            // during the emit, we can still check for head.next
            var head = this._head;
            // Invoke listeners added to internal emitter
            var listener = head.next;
            while (listener) {
                listener = listener.emit(this.deltaTime);
            }
            if (!head.next) {
                this._cancelIfNeeded();
            }
        }
        else {
            this.deltaTime = this.deltaMS = this.elapsedMS = 0;
        }
        this.lastTime = currentTime;
    }
    ;
    /**
     * Destroy the ticker and don't use after this. Calling
     * this method removes all references to internal events.
     */
    destroy() {
        if (!this._protected) {
            this.stop();
            var listener = this._head.next;
            while (listener) {
                listener = listener.destroy(true);
            }
            this._head.destroy();
            this._head = null;
        }
    }
    ;
    /**
     * Stops the ticker. If the ticker has requested
     * an animation frame it is canceled at this point.
     */
    stop() {
        if (this.started) {
            this.started = false;
            this._cancelIfNeeded();
        }
    }
    ;
    /**
     * Starts the ticker. If the ticker has listeners
     * a new animation frame is requested at this point.
     */
    start() {
        if (!this.started) {
            this.started = true;
            this._requestIfNeeded();
        }
    }
    ;
    /**
     * Removes any handlers matching the function and context parameters.
     * If no handlers are left after removing, then it cancels the animation frame.
     *
     * @param {Function} fn - The listener function to be removed
     * @param {*} [context] - The listener context to be removed
     * @returns {PIXI.Ticker} This instance of a ticker
     */
    remove(fn, context) {
        var listener = this._head.next;
        while (listener) {
            // We found a match, lets remove it
            // no break to delete all possible matches
            // incase a listener was added 2+ times
            if (listener.match(fn, context)) {
                listener = listener.destroy();
            }
            else {
                listener = listener.next;
            }
        }
        if (!this._head.next) {
            this._cancelIfNeeded();
        }
        return this;
    }
    ;
    /**
     * Add a handler for the tick event which is only execute once.
     *
     * @param {Function} fn - The listener function to be added for one update
     * @param {*} [context] - The listener context
     * @param {number} [priority=PIXI.UPDATE_PRIORITY.NORMAL] - The priority for emitting
     * @returns {PIXI.Ticker} This instance of a ticker
     */
    addOnce(fn, context, priority) {
        if (priority === void 0) {
            priority = Ticker.UPDATE_PRIORITY.NORMAL;
        }
        return this._addListener(new TickerListener_1.TickerListener(fn, context, priority, true));
    }
    ;
    /**
     * Register a handler for tick events. Calls continuously unless
     * it is removed or the ticker is stopped.
     *
     * @param {Function} fn - The listener function to be added for updates
     * @param {*} [context] - The listener context
     * @param {number} [priority=PIXI.UPDATE_PRIORITY.NORMAL] - The priority for emitting
     * @returns {PIXI.Ticker} This instance of a ticker
     */
    add(fn, context = null, priority = null) {
        if (priority === void 0) {
            priority = Ticker.UPDATE_PRIORITY.NORMAL;
        }
        return this._addListener(new TickerListener_1.TickerListener(fn, context, priority));
    }
    ;
    /**
     * Conditionally requests a new animation frame.
     * If the ticker has been started it checks if a frame has not already
     * been requested, and if the internal emitter has listeners. If these
     * conditions are met, a new frame is requested. If the ticker has not
     * been started, but autoStart is `true`, then the ticker starts now,
     * and continues with the previous conditions to request a new frame.
     *
     * @private
     */
    _startIfPossible() {
        if (this.started) {
            this._requestIfNeeded();
        }
        else if (this.autoStart) {
            this.start();
        }
    }
    ;
    /**
     * Conditionally cancels a pending animation frame.
     *
     * @private
     */
    _cancelIfNeeded() {
        if (this._requestId !== null) {
            cancelAnimationFrame(this._requestId);
            this._requestId = null;
        }
    }
    ;
    /**
 * Conditionally requests a new animation frame.
 * If a frame has not already been requested, and if the internal
 * emitter has listeners, a new frame is requested.
 *
 * @private
 */
    _requestIfNeeded() {
        if (this._requestId === null && this._head.next) {
            // ensure callbacks get correct delta
            this.lastTime = performance.now();
            this._requestId = requestAnimationFrame(this._tick);
        }
    }
    ;
    /**
     * The frames per second at which this ticker is running.
     * The default is approximately 60 in most modern browsers.
     * **Note:** This does not factor in the value of
     * {@link PIXI.Ticker#speed}, which is specific
     * to scaling {@link PIXI.Ticker#deltaTime}.
     *
     * @member {number}
     * @readonly
     */
    get FPS() {
        return 1000 / this.elapsedMS;
    }
    ;
    /**
     * Manages the maximum amount of milliseconds allowed to
     * elapse between invoking {@link PIXI.Ticker#update}.
     * This value is used to cap {@link PIXI.Ticker#deltaTime},
     * but does not effect the measured value of {@link PIXI.Ticker#FPS}.
     * When setting this property it is clamped to a value between
     * `0` and `PIXI.settings.TARGET_FPMS * 1000`.
     *
     * @member {number}
     * @default 10
     */
    get minFPS() {
        return 1000 / this._maxElapsedMS;
    }
    ;
    set minFPS(fps) {
        // Minimum must be below the maxFPS
        var minFPS = Math.min(this.maxFPS, fps);
        // Must be at least 0, but below 1 / settings.TARGET_FPMS
        var minFPMS = Math.min(Math.max(0, minFPS) / 1000, settings_1.settings.TARGET_FPMS);
        this._maxElapsedMS = 1 / minFPMS;
    }
    ;
    set maxFPS(fps) {
        if (fps / 1000 >= settings_1.settings.TARGET_FPMS) {
            this._minElapsedMS = 0;
        }
        else {
            // Max must be at least the minFPS
            var maxFPS = Math.max(this.minFPS, fps);
            // Must be at least 1, but below 1 / settings.TARGET_FPMS
            var maxFPMS = Math.min(Math.max(1, maxFPS) / 1000, settings_1.settings.TARGET_FPMS);
            this._minElapsedMS = 1 / maxFPMS;
        }
    }
    ;
    /**
 * The shared ticker instance used by {@link PIXI.AnimatedSprite} and by
 * {@link PIXI.VideoResource} to update animation frames / video textures.
 *
 * It may also be used by {@link PIXI.Application} if created with the `sharedTicker` option property set to true.
 *
 * The property {@link PIXI.Ticker#autoStart} is set to `true` for this instance.
 * Please follow the examples for usage, including how to opt-out of auto-starting the shared ticker.
 *
 * @example
 * let ticker = PIXI.Ticker.shared;
 * // Set this to prevent starting this ticker when listeners are added.
 * // By default this is true only for the PIXI.Ticker.shared instance.
 * ticker.autoStart = false;
 * // FYI, call this to ensure the ticker is stopped. It should be stopped
 * // if you have not attempted to render anything yet.
 * ticker.stop();
 * // Call this when you are ready for a running shared ticker.
 * ticker.start();
 *
 * @example
 * // You may use the shared ticker to render...
 * let renderer = PIXI.autoDetectRenderer();
 * let stage = new PIXI.Container();
 * document.body.appendChild(renderer.view);
 * ticker.add(function (time) {
 * renderer.render(stage);
 * });
 *
 * @example
 * // Or you can just update it manually.
 * ticker.autoStart = false;
 * ticker.stop();
 * function animate(time) {
 * ticker.update(time);
 * renderer.render(stage);
 * requestAnimationFrame(animate);
 * }
 * animate(performance.now());
 *
 * @member {PIXI.Ticker}
 * @static
 */
    static get shared() {
        if (!Ticker._shared) {
            var shared = Ticker._shared = new Ticker();
            shared.autoStart = true;
            shared._protected = true;
        }
        return Ticker._shared;
    }
    ;
    /**
     * The system ticker instance used by {@link PIXI.interaction.InteractionManager} and by
     * {@link PIXI.BasePrepare} for core timing functionality that shouldn't usually need to be paused,
     * unlike the `shared` ticker which drives visual animations and rendering which may want to be paused.
     *
     * The property {@link PIXI.Ticker#autoStart} is set to `true` for this instance.
     *
     * @member {PIXI.Ticker}
     * @static
     */
    static get system() {
        if (!Ticker._system) {
            var system = Ticker._system = new Ticker();
            system.autoStart = true;
            system._protected = true;
        }
        return Ticker._system;
    }
    ;
    /**
     * Manages the minimum amount of milliseconds allowed to
     * elapse between invoking {@link PIXI.Ticker#update}.
     * This will effect the measured value of {@link PIXI.ticker.Ticker#FPS}.
     * When setting this property it is clamped to a value between
     * `1` and `TARGET_FPMS * 1000`.
     *
     * @member {number}
     * @default 60
     */
    get maxFPS() {
        if (this._minElapsedMS) {
            return 1000 / this._minElapsedMS;
        }
        return settings_1.settings.TARGET_FPMS * 1000;
    }
    ;
}
/**
 * Represents the update priorities used by internal PIXI classes when registered with
 * the {@link PIXI.Ticker} object. Higher priority items are updated first and lower
 * priority items, such as render, should go later.
 *
 * @static
 * @constant
 * @name UPDATE_PRIORITY
 * @memberof PIXI
 * @type {object}
 * @property {number} INTERACTION=50 Highest priority, used for {@link PIXI.interaction.InteractionManager}
 * @property {number} HIGH=25 High priority updating, {@link PIXI.VideoBaseTexture} and {@link PIXI.AnimatedSprite}
 * @property {number} NORMAL=0 Default priority for ticker events, see {@link PIXI.Ticker#add}.
 * @property {number} LOW=-25 Low priority used for {@link PIXI.Application} rendering.
 * @property {number} UTILITY=-50 Lowest priority used for {@link PIXI.prepare.BasePrepare} utility.
 */
Ticker.UPDATE_PRIORITY = {
    INTERACTION: 50,
    HIGH: 25,
    NORMAL: 0,
    LOW: -25,
    UTILITY: -50,
};
exports.Ticker = Ticker;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/TickerListener.js":
/*!**************************************************!*\
  !*** ./js-compile/raw-pixi-ts/TickerListener.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class TickerListener {
    constructor(fn, context, priority, once = false) {
        if (context === void 0) {
            context = null;
        }
        if (priority === void 0) {
            priority = 0;
        }
        if (once === void 0) {
            once = false;
        }
        /**
         * The handler function to execute.
         * @private
         * @member {Function}
         */
        this.fn = fn;
        /**
         * The calling to execute.
         * @private
         * @member {*}
         */
        this.context = context;
        /**
         * The current priority.
         * @private
         * @member {number}
         */
        this.priority = priority;
        /**
         * If this should only execute once.
         * @private
         * @member {boolean}
         */
        this.once = once;
        /**
         * The next item in chain.
         * @private
         * @member {TickerListener}
         */
        this.next = null;
        /**
         * The previous item in chain.
         * @private
         * @member {TickerListener}
         */
        this.previous = null;
        /**
         * `true` if this listener has been destroyed already.
         * @member {boolean}
         * @private
         */
        this._destroyed = false;
    }
    /**
     * Emit by calling the current function.
     * @private
     * @param {number} deltaTime - time since the last emit.
     * @return {TickerListener} Next ticker
     */
    emit(deltaTime) {
        if (this.fn) {
            if (this.context) {
                this.fn.call(this.context, deltaTime);
            }
            else {
                this.fn(deltaTime);
            }
        }
        var redirect = this.next;
        if (this.once) {
            this.destroy(true);
        }
        // Soft-destroying should remove
        // the next reference
        if (this._destroyed) {
            this.next = null;
        }
        return redirect;
    }
    ;
    /**
     * Destroy and don't use after this.
     * @private
     * @param {boolean} [hard = false] `true` to remove the `next` reference, this
     *    is considered a hard destroy. Soft destroy maintains the next reference.
     * @return {TickerListener} The listener to redirect while emitting or removing.
     */
    destroy(hard) {
        if (hard === void 0) {
            hard = false;
        }
        this._destroyed = true;
        this.fn = null;
        this.context = null;
        // Disconnect, hook up next and previous
        if (this.previous) {
            this.previous.next = this.next;
        }
        if (this.next) {
            this.next.previous = this.previous;
        }
        // Redirect to the next item
        var redirect = this.next;
        // Remove references
        this.next = hard ? null : redirect;
        this.previous = null;
        return redirect;
    }
    ;
    /**
     * Connect to the list.
     * @private
     * @param {TickerListener} previous - Input node, previous listener
     */
    connect(previous) {
        this.previous = previous;
        if (previous.next) {
            previous.next.previous = this;
        }
        this.next = previous.next;
        previous.next = this;
    }
    ;
    /**
     * Simple compare function to figure out if a function and context match.
     * @private
     * @param {Function} fn - The listener function to be added for one update
     * @param {Function} context - The listener context
     * @return {boolean} `true` if the listener match the arguments
     */
    match(fn, context) {
        context = context || null;
        return this.fn === fn && this.context === context;
    }
    ;
}
exports.TickerListener = TickerListener;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/TilingSprite.js":
/*!************************************************!*\
  !*** ./js-compile/raw-pixi-ts/TilingSprite.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Sprite_1 = __webpack_require__(/*! ./Sprite */ "./js-compile/raw-pixi-ts/Sprite.js");
const Transform_1 = __webpack_require__(/*! ../flash/geom/Transform */ "./js-compile/flash/geom/Transform.js");
const TextureMatrix_1 = __webpack_require__(/*! ./TextureMatrix */ "./js-compile/raw-pixi-ts/TextureMatrix.js");
const Rectangle_1 = __webpack_require__(/*! ../flash/geom/Rectangle */ "./js-compile/flash/geom/Rectangle.js");
const Texture_1 = __webpack_require__(/*! ./Texture */ "./js-compile/raw-pixi-ts/Texture.js");
const Point_1 = __webpack_require__(/*! ../flash/geom/Point */ "./js-compile/flash/geom/Point.js");
const CacheSettings_1 = __webpack_require__(/*! ./CacheSettings */ "./js-compile/raw-pixi-ts/CacheSettings.js");
const InstanceCounter_1 = __webpack_require__(/*! ./InstanceCounter */ "./js-compile/raw-pixi-ts/InstanceCounter.js");
class TilingSprite extends Sprite_1.Sprite {
    constructor(texture, width = 100, height = 100) {
        super(texture);
        /**
         * @private
         */
        this._onTextureUpdate = () => {
            if (this.uvMatrix) {
                this.uvMatrix.texture = this._texture;
            }
            this.cachedTint = 0xFFFFFF;
        };
        if (width === void 0) {
            width = 100;
        }
        if (height === void 0) {
            height = 100;
        }
        /**
         * Tile transform
         *
         * @member {PIXI.Transform}
         */
        this.tileTransform = new Transform_1.Transform();
        // /// private
        /**
         * The with of the tiling sprite
         *
         * @member {number}
         * @private
         */
        this._width = width;
        /**
         * The height of the tiling sprite
         *
         * @member {number}
         * @private
         */
        this._height = height;
        /**
         * Canvas pattern
         *
         * @type {CanvasPattern}
         * @private
         */
        this._canvasPattern = null;
        /**
         * matrix that is applied to UV to get the coords in Texture normalized space to coords in BaseTexture space
         *
         * @member {PIXI.TextureMatrix}
         */
        this.uvMatrix = texture.uvMatrix || new TextureMatrix_1.TextureMatrix(texture);
        /**
         * Plugin that is responsible for rendering this element.
         * Allows to customize the rendering process without overriding '_render' method.
         *
         * @member {string}
         * @default 'tilingSprite'
         */
        this.pluginName = 'tilingSprite';
        /**
         * Whether or not anchor affects uvs
         *
         * @member {boolean}
         * @default false
         */
        this.uvRespectAnchor = false;
    }
    /**
     * Changes frame clamping in corresponding textureTransform, shortcut
     * Change to -0.5 to add a pixel to the edge, recommended for transparent trimmed textures in atlas
     *
     * @default 0.5
     * @member {number}
     */
    get clampMargin() {
        return this.uvMatrix.clampMargin;
    }
    ;
    set clampMargin(value) {
        this.uvMatrix.clampMargin = value;
        this.uvMatrix.update(true);
    }
    ;
    /**
     * The scaling of the image that is being tiled
     *
     * @member {PIXI.ObservablePoint}
     */
    get tileScale() {
        return this.tileTransform.scale;
    }
    ;
    set tileScale(value) {
        this.tileTransform.scale.copyFrom(value);
    }
    ;
    /**
     * The offset of the image that is being tiled
     *
     * @member {PIXI.ObservablePoint}
     */
    get tilePosition() {
        return this.tileTransform.position;
    }
    ;
    set tilePosition(value) {
        this.tileTransform.position.copyFrom(value);
    }
    ;
    /**
     * Renders the object using the WebGL renderer
     *
     * @protected
     * @param {PIXI.Renderer} renderer - The renderer
     */
    _render(renderer) {
        // tweak our texture temporarily..
        var texture = this._texture;
        if (!texture || !texture.valid) {
            return;
        }
        this.tileTransform.updateLocalTransform();
        this.uvMatrix.update();
        renderer.batch.setObjectRenderer(renderer.plugins[this.pluginName]);
        renderer.plugins[this.pluginName].render(this);
    }
    ;
    /**
     * Updates the bounds of the tiling sprite.
     *
     * @protected
     */
    _calculateBounds() {
        var minX = this._width * -this._anchor.x;
        var minY = this._height * -this._anchor.y;
        var maxX = this._width * (1 - this._anchor.x);
        var maxY = this._height * (1 - this._anchor.y);
        this._bounds.addFrame(this.transform, minX, minY, maxX, maxY);
    }
    ;
    /**
     * Gets the local bounds of the sprite object.
     *
     * @param {PIXI.Rectangle} rect - The output rectangle.
     * @return {PIXI.Rectangle} The bounds.
     */
    getLocalBounds(rect) {
        // we can do a fast local bounds if the sprite has no children!
        if (this.children.length === 0) {
            this._bounds.minX = this._width * -this._anchor.x;
            this._bounds.minY = this._height * -this._anchor.y;
            this._bounds.maxX = this._width * (1 - this._anchor.x);
            this._bounds.maxY = this._height * (1 - this._anchor.y);
            if (!rect) {
                if (!this._localBoundsRect) {
                    InstanceCounter_1.InstanceCounter.addCall("Rectangle.getRectangle", "TilingSprite getLocalBounds");
                    this._localBoundsRect = Rectangle_1.Rectangle.getRectangle();
                }
                rect = this._localBoundsRect;
            }
            InstanceCounter_1.InstanceCounter.addCall("Rectangle.getRectangle", "TilingSprite getLocalBounds");
            return this._bounds.getRectangle(rect);
        }
        return super.getLocalBounds(rect);
    }
    ;
    /**
     * Checks if a point is inside this tiling sprite.
     *
     * @param {PIXI.Point} point - the point to check
     * @return {boolean} Whether or not the sprite contains the point.
     */
    containsPoint(point) {
        let defaultpoint = Point_1.Point.DEFAULT;
        this.worldTransform.applyInverse(point, defaultpoint);
        var width = this._width;
        var height = this._height;
        var x1 = -width * this.anchor.x;
        if (defaultpoint.x >= x1 && defaultpoint.x < x1 + width) {
            var y1 = -height * this.anchor.y;
            if (defaultpoint.y >= y1 && defaultpoint.y < y1 + height) {
                return true;
            }
        }
        return false;
    }
    ;
    /**
     * Destroys this sprite and optionally its texture and children
     *
     * @param {object|boolean} [options] - Options parameter. A boolean will act as if all options
     *  have been set to that value
     * @param {boolean} [options.children=false] - if set to true, all the children will have their destroy
     *      method called as well. 'options' will be passed on to those calls.
     * @param {boolean} [options.texture=false] - Should it destroy the current texture of the sprite as well
     * @param {boolean} [options.baseTexture=false] - Should it destroy the base texture of the sprite as well
     */
    destroy(options) {
        super.destroy(options);
        this.tileTransform = null;
        this.uvMatrix = null;
    }
    ;
    /**
     * Helper function that creates a new tiling sprite based on the source you provide.
     * The source can be - frame id, image url, video url, canvas element, video element, base texture
     *
     * @static
     * @param {number|string|PIXI.Texture|HTMLCanvasElement|HTMLVideoElement} source - Source to create texture from
     * @param {number} width - the width of the tiling sprite
     * @param {number} height - the height of the tiling sprite
     * @return {PIXI.TilingSprite} The newly created texture
     */
    // static from  (source, width, height)
    // {
    //     return new TilingSprite(Texture.from(source), width, height);
    // };
    /**
     * Helper function that creates a tiling sprite that will use a texture from the TextureCache based on the frameId
     * The frame ids are created when a Texture packer file has been loaded
     *
     * @static
     * @param {string} frameId - The frame Id of the texture in the cache
     * @param {number} width - the width of the tiling sprite
     * @param {number} height - the height of the tiling sprite
     * @return {PIXI.TilingSprite} A new TilingSprite using a texture from the texture cache matching the frameId
     */
    static fromFrame(frameId, width, height) {
        var texture = CacheSettings_1.CacheSettings.TextureCache[frameId];
        if (!texture) {
            throw new Error(("The frameId \"" + frameId + "\" does not exist in the texture cache " + (this)));
        }
        return new TilingSprite(texture, width, height);
    }
    ;
    /**
     * Helper function that creates a sprite that will contain a texture based on an image url
     * If the image is not in the texture cache it will be loaded
     *
     * @static
     * @param {string} imageId - The image url of the texture
     * @param {number} width - the width of the tiling sprite
     * @param {number} height - the height of the tiling sprite
     * @param {Object} [options] - See {@link PIXI.BaseTexture}'s constructor for options.
     * @return {PIXI.TilingSprite} A new TilingSprite using a texture from the texture cache matching the image id
     */
    static fromImage(imageId, width, height, options) {
        // Fallback support for crossorigin, scaleMode parameters
        if (options && typeof options !== 'object') {
            options = {
                scaleMode: arguments[4],
                resourceOptions: {
                    crossorigin: arguments[3],
                },
            };
        }
        return new TilingSprite(Texture_1.Texture.from(imageId, options), width, height);
    }
    ;
    /**
     * The width of the sprite, setting this will actually modify the scale to achieve the value set
     *
     * @member {number}
     */
    get width() {
        return this._width;
    }
    ;
    set width(value) {
        this._width = value;
    }
    ;
    /**
     * The height of the TilingSprite, setting this will actually modify the scale to achieve the value set
     *
     * @member {number}
     */
    get height() {
        return this._height;
    }
    ;
    set height(value) {
        this._height = value;
    }
    ;
}
exports.TilingSprite = TilingSprite;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/TilingSpriteRenderer.js":
/*!********************************************************!*\
  !*** ./js-compile/raw-pixi-ts/TilingSpriteRenderer.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const ObjectRenderer_1 = __webpack_require__(/*! ./ObjectRenderer */ "./js-compile/raw-pixi-ts/ObjectRenderer.js");
const Shader_1 = __webpack_require__(/*! ./Shader */ "./js-compile/raw-pixi-ts/Shader.js");
const QuadUv_1 = __webpack_require__(/*! ./QuadUv */ "./js-compile/raw-pixi-ts/QuadUv.js");
const Matrix_1 = __webpack_require__(/*! ./Matrix */ "./js-compile/raw-pixi-ts/Matrix.js");
const WebGLSettings_1 = __webpack_require__(/*! ./WebGLSettings */ "./js-compile/raw-pixi-ts/WebGLSettings.js");
const ColorSettings_1 = __webpack_require__(/*! ./ColorSettings */ "./js-compile/raw-pixi-ts/ColorSettings.js");
const BlendModesSettings_1 = __webpack_require__(/*! ./BlendModesSettings */ "./js-compile/raw-pixi-ts/BlendModesSettings.js");
class TilingSpriteRenderer extends ObjectRenderer_1.ObjectRenderer {
    constructor(renderer) {
        super(renderer);
        var uniforms = { globals: this.renderer.globalUniforms };
        this.shader = Shader_1.Shader.from(TilingSpriteRenderer.vertex$3, TilingSpriteRenderer.fragment$2, uniforms);
        this.simpleShader = Shader_1.Shader.from(TilingSpriteRenderer.vertex$3, TilingSpriteRenderer.fragmentSimple, uniforms);
        this.quad = new QuadUv_1.QuadUv();
    }
    /**
     *
     * @param {PIXI.TilingSprite} ts tilingSprite to be rendered
     */
    render(ts) {
        var renderer = this.renderer;
        var quad = this.quad;
        var vertices = quad.vertices;
        vertices[0] = vertices[6] = (ts._width) * -ts.anchor.x;
        vertices[1] = vertices[3] = ts._height * -ts.anchor.y;
        vertices[2] = vertices[4] = (ts._width) * (1.0 - ts.anchor.x);
        vertices[5] = vertices[7] = ts._height * (1.0 - ts.anchor.y);
        if (ts.uvRespectAnchor) {
            vertices = quad.uvs;
            vertices[0] = vertices[6] = -ts.anchor.x;
            vertices[1] = vertices[3] = -ts.anchor.y;
            vertices[2] = vertices[4] = 1.0 - ts.anchor.x;
            vertices[5] = vertices[7] = 1.0 - ts.anchor.y;
        }
        quad.invalidate();
        var tex = ts._texture;
        var baseTex = tex.baseTexture;
        var lt = ts.tileTransform.localTransform;
        var uv = ts.uvMatrix;
        var isSimple = baseTex.isPowerOfTwo
            && tex.frame.width === baseTex.width && tex.frame.height === baseTex.height;
        // auto, force repeat wrapMode for big tiling textures
        if (isSimple) {
            if (!baseTex._glTextures[renderer.CONTEXT_UID]) {
                if (baseTex.wrapMode === WebGLSettings_1.WebGLSettings.WRAP_MODES.CLAMP) {
                    baseTex.wrapMode = WebGLSettings_1.WebGLSettings.WRAP_MODES.REPEAT;
                }
            }
            else {
                isSimple = baseTex.wrapMode !== WebGLSettings_1.WebGLSettings.WRAP_MODES.CLAMP;
            }
        }
        var shader = isSimple ? this.simpleShader : this.shader;
        var w = tex.width;
        var h = tex.height;
        var W = ts._width;
        var H = ts._height;
        TilingSpriteRenderer.tempMat$1.set(lt.a * w / W, lt.b * w / H, lt.c * h / W, lt.d * h / H, lt.tx / W, lt.ty / H);
        // that part is the same as above:
        // tempMat.identity();
        // tempMat.scale(tex.width, tex.height);
        // tempMat.prepend(lt);
        // tempMat.scale(1.0 / ts._width, 1.0 / ts._height);
        TilingSpriteRenderer.tempMat$1.invert();
        if (isSimple) {
            TilingSpriteRenderer.tempMat$1.prepend(uv.mapCoord);
        }
        else {
            shader.uniforms.uMapCoord = uv.mapCoord.toArray(true);
            shader.uniforms.uClampFrame = uv.uClampFrame;
            shader.uniforms.uClampOffset = uv.uClampOffset;
        }
        shader.uniforms.uTransform = TilingSpriteRenderer.tempMat$1.toArray(true);
        shader.uniforms.uColor = ColorSettings_1.ColorSettings.premultiplyTintToRgba(ts.tint, ts.worldAlpha, shader.uniforms.uColor, baseTex.premultiplyAlpha);
        shader.uniforms.translationMatrix = ts.transform.worldTransform.toArray(true);
        shader.uniforms.uSampler = tex;
        renderer.shader.bind(shader);
        renderer.geometry.bind(quad); // , renderer.shader.getGLShader());
        renderer.state.setBlendMode(BlendModesSettings_1.BlendModesSettings.correctBlendMode(ts.blendMode, baseTex.premultiplyAlpha));
        renderer.geometry.draw(this.renderer.gl.TRIANGLES, 6, 0);
    }
    ;
}
TilingSpriteRenderer.fragmentSimple = "varying vec2 vTextureCoord;\r\n\r\nuniform sampler2D uSampler;\r\nuniform vec4 uColor;\r\n\r\nvoid main(void)\r\n{\r\n    vec4 sample = texture2D(uSampler, vTextureCoord);\r\n    gl_FragColor = sample * uColor;\r\n}\r\n";
TilingSpriteRenderer.fragment$2 = "varying vec2 vTextureCoord;\r\n\r\nuniform sampler2D uSampler;\r\nuniform vec4 uColor;\r\nuniform mat3 uMapCoord;\r\nuniform vec4 uClampFrame;\r\nuniform vec2 uClampOffset;\r\n\r\nvoid main(void)\r\n{\r\n    vec2 coord = mod(vTextureCoord - uClampOffset, vec2(1.0, 1.0)) + uClampOffset;\r\n    coord = (uMapCoord * vec3(coord, 1.0)).xy;\r\n    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\r\n\r\n    vec4 sample = texture2D(uSampler, coord);\r\n    gl_FragColor = sample * uColor;\r\n}\r\n";
TilingSpriteRenderer.vertex$3 = "attribute vec2 aVertexPosition;\r\nattribute vec2 aTextureCoord;\r\n\r\nuniform mat3 projectionMatrix;\r\nuniform mat3 translationMatrix;\r\nuniform mat3 uTransform;\r\n\r\nvarying vec2 vTextureCoord;\r\n\r\nvoid main(void)\r\n{\r\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\r\n\r\n    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;\r\n}\r\n";
TilingSpriteRenderer.tempMat$1 = new Matrix_1.Matrix();
exports.TilingSpriteRenderer = TilingSpriteRenderer;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/URLLoader.js":
/*!*********************************************!*\
  !*** ./js-compile/raw-pixi-ts/URLLoader.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const IOErrorEvent_1 = __webpack_require__(/*! ./IOErrorEvent */ "./js-compile/raw-pixi-ts/IOErrorEvent.js");
const EventDispatcher_1 = __webpack_require__(/*! ./EventDispatcher */ "./js-compile/raw-pixi-ts/EventDispatcher.js");
const Event_1 = __webpack_require__(/*! ./Event */ "./js-compile/raw-pixi-ts/Event.js");
class URLLoader extends EventDispatcher_1.EventDispatcher {
    constructor() {
        super();
        this.onHttpResponse = () => {
            if (this.xmlhttp.readyState == 4 && this.xmlhttp.status == 200) {
                this._data = this.xmlhttp.responseText;
                this.dispatchEvent(Event_1.Event.getEvent(Event_1.Event.COMPLETE));
            }
            else if (this.xmlhttp.readyState == 4 && this.xmlhttp.status == 0 && this.xmlhttp.responseText) {
                this._data = this.xmlhttp.responseText;
                this.dispatchEvent(Event_1.Event.getEvent(Event_1.Event.COMPLETE));
            }
            else if (this.xmlhttp.readyState == 4 && this.xmlhttp.status == 404) {
                var errorevent = new IOErrorEvent_1.IOErrorEvent(IOErrorEvent_1.IOErrorEvent.IO_ERROR);
                errorevent.text = "Could not find file " + this.request.url;
                errorevent.errorId = 404;
                this.dispatchEvent(errorevent);
            }
            else if (this.xmlhttp.readyState == 4 && this.xmlhttp.status == 403) {
                var errorevent = new IOErrorEvent_1.IOErrorEvent(IOErrorEvent_1.IOErrorEvent.IO_ERROR);
                errorevent.text = "Cross Origin Error " + this.request.url;
                errorevent.errorId = 403;
                this.dispatchEvent(errorevent);
            }
            else if (this.xmlhttp.readyState == 4 && this.xmlhttp.status != 200) {
                var errorevent = new IOErrorEvent_1.IOErrorEvent(IOErrorEvent_1.IOErrorEvent.IO_ERROR);
                errorevent.text = "Unkown Error " + this.request.url;
                errorevent.errorId = this.xmlhttp.status;
                this.dispatchEvent(errorevent);
            }
        };
        this.xmlhttp = new XMLHttpRequest();
    }
    destructor() {
        super.destructor();
        if (this.xmlhttp) {
            this.xmlhttp.onreadystatechange = null;
        }
        this.xmlhttp = null;
        if (this.request) {
            this.request.destructor();
        }
        this.request = null;
        this._data = null;
    }
    get url() {
        if (this.request) {
            return this.request.url;
        }
        return null;
    }
    get data() {
        return this._data;
    }
    set data(value) {
    }
    close() {
    }
    load(value) {
        this.request = value;
        var path = this.request.url;
        if (!path) {
            return;
        }
        if (this.request.data) {
            var params = '';
            for (var key in this.request.data) {
                params += key + "=" + this.request.data[key] + "&";
            }
            params = params.substr(0, params.length - 1);
            path += "?" + params;
        }
        this.xmlhttp.open(this.request.method, path, true);
        this.xmlhttp.onreadystatechange = this.onHttpResponse;
        if (path.indexOf(".json") < 0) {
            if (this.request.contentType != 'json') {
                this.xmlhttp.setRequestHeader('Content-Type', 'text/xml');
            }
        }
        if (this.request.envelop) {
            this.xmlhttp.send(this.request.envelop);
        }
        else {
            this.xmlhttp.send();
        }
    }
    get dataFormat() {
        return null;
    }
    set dataFormat(value) {
    }
}
exports.URLLoader = URLLoader;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/URLRequest.js":
/*!**********************************************!*\
  !*** ./js-compile/raw-pixi-ts/URLRequest.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const URLRequestMethod_1 = __webpack_require__(/*! ./URLRequestMethod */ "./js-compile/raw-pixi-ts/URLRequestMethod.js");
const FlashBaseObject_1 = __webpack_require__(/*! ./FlashBaseObject */ "./js-compile/raw-pixi-ts/FlashBaseObject.js");
class URLRequest extends FlashBaseObject_1.FlashBaseObject {
    constructor(path = null) {
        super();
        this._requestMetaData = new RequestMetaData();
        this._timeout = 0;
        this._crossOrigin = true;
        this.reset(path);
    }
    destructor() {
        this._url = null;
        this._method = URLRequestMethod_1.URLRequestMethod.POST;
        let index = URLRequest.URLRequestCache.indexOf(this);
        if (index < 0) {
            URLRequest.URLRequestCache.push(this);
        }
    }
    reset(path = null) {
        this._url = path;
        this._method = URLRequestMethod_1.URLRequestMethod.POST;
        this._contentType = null;
        this._envelop = null;
        this._data = null;
    }
    static getURLRequest(path = null) {
        if (URLRequest.URLRequestCache.length) {
            let ur = URLRequest.URLRequestCache[URLRequest.URLRequestCache.length - 1];
            URLRequest.URLRequestCache.length -= 1;
            ur.reset(path);
            return ur;
        }
        return new URLRequest(path);
    }
    set requestMetaData(value) {
        this._requestMetaData = value;
    }
    get requestMetaData() {
        return this._requestMetaData;
    }
    set timeout(value) {
        this._timeout = value;
    }
    get timeout() {
        return this._timeout;
    }
    set crossOrigin(value) {
        this._crossOrigin = value;
    }
    get crossOrigin() {
        return this._crossOrigin;
    }
    set envelop(value) {
        this._envelop = value;
    }
    get envelop() {
        return this._envelop;
    }
    get requestHeaders() {
        return null;
    }
    set requestHeaders(value) {
    }
    get contentType() {
        return this._contentType;
    }
    set contentType(value) {
        this._contentType = value;
    }
    get url() {
        return this._url;
    }
    set url(value) {
        this._url = value;
    }
    set data(value) {
        this._data = value;
    }
    get data() {
        return this._data;
    }
    get method() {
        return this._method;
    }
    set method(value) {
        this._method = value;
    }
}
URLRequest.URLRequestCache = [];
exports.URLRequest = URLRequest;
class RequestMetaData {
    constructor() {
        this.mimeType = '';
        this.skipSource = false;
    }
}
exports.RequestMetaData = RequestMetaData;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/URLRequestMethod.js":
/*!****************************************************!*\
  !*** ./js-compile/raw-pixi-ts/URLRequestMethod.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class URLRequestMethod {
}
URLRequestMethod.GET = "GET";
URLRequestMethod.POST = "POST";
exports.URLRequestMethod = URLRequestMethod;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/UniformGroup.js":
/*!************************************************!*\
  !*** ./js-compile/raw-pixi-ts/UniformGroup.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class UniformGroup {
    constructor(uniforms = null, _static = null) {
        /**
                 * uniform values
                 * @member {object}
                 * @readonly
                 */
        this.uniforms = uniforms;
        /**
         * Its a group and not a single uniforms
         * @member {boolean}
         * @readonly
         * @default true
         */
        this.group = true;
        // lets generate this when the shader ?
        this.syncUniforms = {};
        /**
         * dirty version
         * @protected
         * @member {number}
         */
        this.dirtyId = 0;
        /**
         * unique id
         * @protected
         * @member {number}
         */
        this.id = UniformGroup.UID$2++;
        /**
         * Uniforms wont be changed after creation
         * @member {boolean}
         */
        this.static = !!_static;
    }
    update() {
        this.dirtyId++;
    }
    ;
    add(name, uniforms, _static) {
        this.uniforms[name] = new UniformGroup(uniforms, _static);
    }
    ;
    static from(uniforms, _static) {
        return new UniformGroup(uniforms, _static);
    }
    ;
}
UniformGroup.UID$2 = 0;
exports.UniformGroup = UniformGroup;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/Url.js":
/*!***************************************!*\
  !*** ./js-compile/raw-pixi-ts/Url.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const UtilsSettings_1 = __webpack_require__(/*! ./UtilsSettings */ "./js-compile/raw-pixi-ts/UtilsSettings.js");
class Url {
    constructor() {
        this.protocol = null;
        this.slashes = null;
        this.auth = null;
        this.host = null;
        this.port = null;
        this.hostname = null;
        this.hash = null;
        this.search = null;
        this.query = null;
        this.pathname = null;
        this.path = null;
        this.href = null;
    }
    // format a parsed object into a url string
    static urlFormat(obj) {
        // ensure it's an object, and not a string url.
        // If it's an obj, this is a no-op.
        // this way, you can call url_format() on strings
        // to clean up potentially wonky urls.
        if (UtilsSettings_1.UtilsSettings.util.isString(obj)) {
            obj = Url.urlParse(obj);
        }
        if (!(obj instanceof Url)) {
            return Url.prototype.format.call(obj);
        }
        return obj.format();
    }
    static urlResolveObject(source, relative) {
        if (!source) {
            return relative;
        }
        return Url.urlParse(source, false, true).resolveObject(relative);
    }
    static urlResolve(source, relative) {
        return Url.urlParse(source, false, true).resolve(relative);
    }
    resolveObject(relative) {
        if (UtilsSettings_1.UtilsSettings.util.isString(relative)) {
            var rel = new Url();
            rel.parse(relative, false, true);
            relative = rel;
        }
        var result = new Url();
        var tkeys = Object.keys(this);
        for (var tk = 0; tk < tkeys.length; tk++) {
            var tkey = tkeys[tk];
            result[tkey] = this[tkey];
        }
        // hash is always overridden, no matter what.
        // even href="" will remove it.
        result.hash = relative.hash;
        // if the relative url is empty, then there's nothing left to do here.
        if (relative.href === '') {
            result.href = result.format();
            return result;
        }
        // hrefs like //foo/bar always cut to the protocol.
        if (relative.slashes && !relative.protocol) {
            // take everything except the protocol from relative
            var rkeys = Object.keys(relative);
            for (var rk = 0; rk < rkeys.length; rk++) {
                var rkey = rkeys[rk];
                if (rkey !== 'protocol') {
                    result[rkey] = relative[rkey];
                }
            }
            //urlParse appends trailing / to urls like http://www.example.com
            if (Url.slashedProtocol[result.protocol] &&
                result.hostname && !result.pathname) {
                result.path = result.pathname = '/';
            }
            result.href = result.format();
            return result;
        }
        if (relative.protocol && relative.protocol !== result.protocol) {
            // if it's a known url protocol, then changing
            // the protocol does weird things
            // first, if it's not file:, then we MUST have a host,
            // and if there was a path
            // to begin with, then we MUST have a path.
            // if it is file:, then the host is dropped,
            // because that's known to be hostless.
            // anything else is assumed to be absolute.
            if (!Url.slashedProtocol[relative.protocol]) {
                var keys = Object.keys(relative);
                for (var v = 0; v < keys.length; v++) {
                    var k = keys[v];
                    result[k] = relative[k];
                }
                result.href = result.format();
                return result;
            }
            result.protocol = relative.protocol;
            if (!relative.host && !Url.hostlessProtocol[relative.protocol]) {
                var relPath = (relative.pathname || '').split('/');
                while (relPath.length && !(relative.host = relPath.shift())) {
                    ;
                }
                if (!relative.host) {
                    relative.host = '';
                }
                if (!relative.hostname) {
                    relative.hostname = '';
                }
                if (relPath[0] !== '') {
                    relPath.unshift('');
                }
                if (relPath.length < 2) {
                    relPath.unshift('');
                }
                result.pathname = relPath.join('/');
            }
            else {
                result.pathname = relative.pathname;
            }
            result.search = relative.search;
            result.query = relative.query;
            result.host = relative.host || '';
            result.auth = relative.auth;
            result.hostname = relative.hostname || relative.host;
            result.port = relative.port;
            // to support http.request
            if (result.pathname || result.search) {
                var p = result.pathname || '';
                var s = result.search || '';
                result.path = p + s;
            }
            result.slashes = result.slashes || relative.slashes;
            result.href = result.format();
            return result;
        }
        var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'), isRelAbs = (relative.host ||
            relative.pathname && relative.pathname.charAt(0) === '/'), mustEndAbs = (isRelAbs || isSourceAbs ||
            (result.host && relative.pathname)), removeAllDots = mustEndAbs, srcPath = result.pathname && result.pathname.split('/') || [], relPath = relative.pathname && relative.pathname.split('/') || [], psychotic = result.protocol && !Url.slashedProtocol[result.protocol];
        // if the url is a non-slashed url, then relative
        // links like ../.. should be able
        // to crawl up to the hostname, as well.  This is strange.
        // result.protocol has already been set by now.
        // Later on, put the first path part into the host field.
        if (psychotic) {
            result.hostname = '';
            result.port = null;
            if (result.host) {
                if (srcPath[0] === '') {
                    srcPath[0] = result.host;
                }
                else {
                    srcPath.unshift(result.host);
                }
            }
            result.host = '';
            if (relative.protocol) {
                relative.hostname = null;
                relative.port = null;
                if (relative.host) {
                    if (relPath[0] === '') {
                        relPath[0] = relative.host;
                    }
                    else {
                        relPath.unshift(relative.host);
                    }
                }
                relative.host = null;
            }
            mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
        }
        if (isRelAbs) {
            // it's absolute.
            result.host = (relative.host || relative.host === '') ?
                relative.host : result.host;
            result.hostname = (relative.hostname || relative.hostname === '') ?
                relative.hostname : result.hostname;
            result.search = relative.search;
            result.query = relative.query;
            srcPath = relPath;
            // fall through to the dot-handling below.
        }
        else if (relPath.length) {
            // it's relative
            // throw away the existing file, and take the new path instead.
            if (!srcPath) {
                srcPath = [];
            }
            srcPath.pop();
            srcPath = srcPath.concat(relPath);
            result.search = relative.search;
            result.query = relative.query;
        }
        else if (!UtilsSettings_1.UtilsSettings.util.isNullOrUndefined(relative.search)) {
            // just pull out the search.
            // like href='?foo'.
            // Put this after the other two cases because it simplifies the booleans
            if (psychotic) {
                result.hostname = result.host = srcPath.shift();
                //occationaly the auth can get stuck only in host
                //this especially happens in cases like
                //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
                var authInHost = result.host && result.host.indexOf('@') > 0 ?
                    result.host.split('@') : false;
                if (authInHost) {
                    result.auth = authInHost.shift();
                    result.host = result.hostname = authInHost.shift();
                }
            }
            result.search = relative.search;
            result.query = relative.query;
            //to support http.request
            if (!UtilsSettings_1.UtilsSettings.util.isNull(result.pathname) || !UtilsSettings_1.UtilsSettings.util.isNull(result.search)) {
                result.path = (result.pathname ? result.pathname : '') +
                    (result.search ? result.search : '');
            }
            result.href = result.format();
            return result;
        }
        if (!srcPath.length) {
            // no path at all.  easy.
            // we've already handled the other stuff above.
            result.pathname = null;
            //to support http.request
            if (result.search) {
                result.path = '/' + result.search;
            }
            else {
                result.path = null;
            }
            result.href = result.format();
            return result;
        }
        // if a url ENDs in . or .., then it must get a trailing slash.
        // however, if it ends in anything else non-slashy,
        // then it must NOT get a trailing slash.
        var last = srcPath.slice(-1)[0];
        var hasTrailingSlash = ((result.host || relative.host || srcPath.length > 1) &&
            (last === '.' || last === '..') || last === '');
        // strip single dots, resolve double dots to parent dir
        // if the path tries to go above the root, `up` ends up > 0
        var up = 0;
        for (var i = srcPath.length; i >= 0; i--) {
            last = srcPath[i];
            if (last === '.') {
                srcPath.splice(i, 1);
            }
            else if (last === '..') {
                srcPath.splice(i, 1);
                up++;
            }
            else if (up) {
                srcPath.splice(i, 1);
                up--;
            }
        }
        // if the path is allowed to go above the root, restore leading ..s
        if (!mustEndAbs && !removeAllDots) {
            for (; up--; up) {
                srcPath.unshift('..');
            }
        }
        if (mustEndAbs && srcPath[0] !== '' &&
            (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
            srcPath.unshift('');
        }
        if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
            srcPath.push('');
        }
        var isAbsolute = srcPath[0] === '' ||
            (srcPath[0] && srcPath[0].charAt(0) === '/');
        // put the host back
        if (psychotic) {
            result.hostname = result.host = isAbsolute ? '' :
                srcPath.length ? srcPath.shift() : '';
            //occationaly the auth can get stuck only in host
            //this especially happens in cases like
            //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
            var authInHost = result.host && result.host.indexOf('@') > 0 ?
                result.host.split('@') : false;
            if (authInHost) {
                result.auth = authInHost.shift();
                result.host = result.hostname = authInHost.shift();
            }
        }
        mustEndAbs = mustEndAbs || (result.host && srcPath.length);
        if (mustEndAbs && !isAbsolute) {
            srcPath.unshift('');
        }
        if (!srcPath.length) {
            result.pathname = null;
            result.path = null;
        }
        else {
            result.pathname = srcPath.join('/');
        }
        //to support request.http
        if (!UtilsSettings_1.UtilsSettings.util.isNull(result.pathname) || !UtilsSettings_1.UtilsSettings.util.isNull(result.search)) {
            result.path = (result.pathname ? result.pathname : '') +
                (result.search ? result.search : '');
        }
        result.auth = relative.auth || result.auth;
        result.slashes = result.slashes || relative.slashes;
        result.href = result.format();
        return result;
    }
    ;
    static urlParse(url, parseQueryString = null, slashesDenoteHost = null) {
        if (url && UtilsSettings_1.UtilsSettings.util.isObject(url) && url instanceof Url) {
            return url;
        }
        var u = new Url;
        u.parse(url, parseQueryString, slashesDenoteHost);
        return u;
    }
    resolve(relative) {
        return this.resolveObject(Url.urlParse(relative, false, true)).format();
    }
    ;
    parseHost() {
        var host = this.host;
        var port = Url.portPattern.exec(host);
        if (port) {
            port = port[0];
            if (port !== ':') {
                this.port = port.substr(1);
            }
            host = host.substr(0, host.length - port.length);
        }
        if (host) {
            this.hostname = host;
        }
    }
    ;
    parse(url, parseQueryString = null, slashesDenoteHost = null) {
        if (!UtilsSettings_1.UtilsSettings.util.isString(url)) {
            throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
        }
        // Copy chrome, IE, opera backslash-handling behavior.
        // Back slashes before the query string get converted to forward slashes
        // See: https://code.google.com/p/chromium/issues/detail?id=25916
        var queryIndex = url.indexOf('?'), splitter = (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#', uSplit = url.split(splitter), slashRegex = /\\/g;
        uSplit[0] = uSplit[0].replace(slashRegex, '/');
        url = uSplit.join(splitter);
        var rest = url;
        // trim before proceeding.
        // This is to support parse stuff like "  http://foo.com  \n"
        rest = rest.trim();
        if (!slashesDenoteHost && url.split('#').length === 1) {
            // Try fast path regexp
            var simplePath = Url.simplePathPattern.exec(rest);
            if (simplePath) {
                this.path = rest;
                this.href = rest;
                this.pathname = simplePath[1];
                if (simplePath[2]) {
                    this.search = simplePath[2];
                    if (parseQueryString) {
                        this.query = this.parse(this.search.substr(1));
                    }
                    else {
                        this.query = this.search.substr(1);
                    }
                }
                else if (parseQueryString) {
                    this.search = '';
                    this.query = {};
                }
                return this;
            }
        }
        var proto = Url.protocolPattern.exec(rest);
        if (proto) {
            proto = proto[0];
            var lowerProto = proto.toLowerCase();
            this.protocol = lowerProto;
            rest = rest.substr(proto.length);
        }
        // figure out if it's got a host
        // user@server is *always* interpreted as a hostname, and url
        // resolution will treat //foo/bar as host=foo,path=bar because that's
        // how the browser resolves relative URLs.
        if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
            var slashes = rest.substr(0, 2) === '//';
            if (slashes && !(proto && Url.hostlessProtocol[proto])) {
                rest = rest.substr(2);
                this.slashes = true;
            }
        }
        if (!Url.hostlessProtocol[proto] &&
            (slashes || (proto && !Url.slashedProtocol[proto]))) {
            // there's a hostname.
            // the first instance of /, ?, ;, or # ends the host.
            //
            // If there is an @ in the hostname, then non-host chars *are* allowed
            // to the left of the last @ sign, unless some host-ending character
            // comes *before* the @-sign.
            // URLs are obnoxious.
            //
            // ex:
            // http://a@b@c/ => user:a@b host:c
            // http://a@b?@c => user:a host:c path:/?@c
            // v0.12 TODO(isaacs): This is not quite how Chrome does things.
            // Review our test case against browsers more comprehensively.
            // find the first instance of any hostEndingChars
            var hostEnd = -1;
            for (var i = 0; i < Url.hostEndingChars.length; i++) {
                var hec = rest.indexOf(Url.hostEndingChars[i]);
                if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
                    hostEnd = hec;
                }
            }
            // at this point, either we have an explicit point where the
            // auth portion cannot go past, or the last @ char is the decider.
            var auth, atSign;
            if (hostEnd === -1) {
                // atSign can be anywhere.
                atSign = rest.lastIndexOf('@');
            }
            else {
                // atSign must be in auth portion.
                // http://a@b/c@d => host:b auth:a path:/c@d
                atSign = rest.lastIndexOf('@', hostEnd);
            }
            // Now we have a portion which is definitely the auth.
            // Pull that off.
            if (atSign !== -1) {
                auth = rest.slice(0, atSign);
                rest = rest.slice(atSign + 1);
                this.auth = decodeURIComponent(auth);
            }
            // the host is the remaining to the left of the first non-host char
            hostEnd = -1;
            for (var i = 0; i < Url.nonHostChars.length; i++) {
                var hec = rest.indexOf(Url.nonHostChars[i]);
                if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
                    hostEnd = hec;
                }
            }
            // if we still have not hit it, then the entire thing is a host.
            if (hostEnd === -1) {
                hostEnd = rest.length;
            }
            this.host = rest.slice(0, hostEnd);
            rest = rest.slice(hostEnd);
            // pull out port.
            this.parseHost();
            // we've indicated that there is a hostname,
            // so even if it's empty, it has to be present.
            this.hostname = this.hostname || '';
            // if hostname begins with [ and ends with ]
            // assume that it's an IPv6 address.
            var ipv6Hostname = this.hostname[0] === '[' &&
                this.hostname[this.hostname.length - 1] === ']';
            // validate a little.
            if (!ipv6Hostname) {
                var hostparts = this.hostname.split(/\./);
                for (var i = 0, l = hostparts.length; i < l; i++) {
                    var part = hostparts[i];
                    if (!part) {
                        continue;
                    }
                    if (!part.match(Url.hostnamePartPattern)) {
                        var newpart = '';
                        for (var j = 0, k = part.length; j < k; j++) {
                            if (part.charCodeAt(j) > 127) {
                                // we replace non-ASCII char with a temporary placeholder
                                // we need this to make sure size of hostname is not
                                // broken by replacing non-ASCII by nothing
                                newpart += 'x';
                            }
                            else {
                                newpart += part[j];
                            }
                        }
                        // we test again with ASCII char only
                        if (!newpart.match(Url.hostnamePartPattern)) {
                            var validParts = hostparts.slice(0, i);
                            var notHost = hostparts.slice(i + 1);
                            var bit = part.match(Url.hostnamePartStart);
                            if (bit) {
                                validParts.push(bit[1]);
                                notHost.unshift(bit[2]);
                            }
                            if (notHost.length) {
                                rest = '/' + notHost.join('.') + rest;
                            }
                            this.hostname = validParts.join('.');
                            break;
                        }
                    }
                }
            }
            if (this.hostname.length > Url.hostnameMaxLen) {
                this.hostname = '';
            }
            else {
                // hostnames are always lower case.
                this.hostname = this.hostname.toLowerCase();
            }
            if (!ipv6Hostname) {
                // IDNA Support: Returns a punycoded representation of "domain".
                // It only converts parts of the domain name that
                // have non-ASCII characters, i.e. it doesn't matter if
                // you call it with a domain that already is ASCII-only.
                this.hostname = this.toASCII(this.hostname);
            }
            var p = this.port ? ':' + this.port : '';
            var h = this.hostname || '';
            this.host = h + p;
            this.href += this.host;
            // strip [ and ] from the hostname
            // the host field still retains them, though
            if (ipv6Hostname) {
                this.hostname = this.hostname.substr(1, this.hostname.length - 2);
                if (rest[0] !== '/') {
                    rest = '/' + rest;
                }
            }
        }
        // now rest is set to the post-host stuff.
        // chop off any delim chars.
        if (!Url.unsafeProtocol[lowerProto]) {
            // First, make 100% sure that any "autoEscape" chars get
            // escaped, even if encodeURIComponent doesn't think they
            // need to be.
            for (var i = 0, l = Url.autoEscape.length; i < l; i++) {
                var ae = Url.autoEscape[i];
                if (rest.indexOf(ae) === -1) {
                    continue;
                }
                var esc = encodeURIComponent(ae);
                if (esc === ae) {
                    esc = escape(ae);
                }
                rest = rest.split(ae).join(esc);
            }
        }
        // chop off from the tail first.
        var hash = rest.indexOf('#');
        if (hash !== -1) {
            // got a fragment string.
            this.hash = rest.substr(hash);
            rest = rest.slice(0, hash);
        }
        var qm = rest.indexOf('?');
        if (qm !== -1) {
            this.search = rest.substr(qm);
            this.query = rest.substr(qm + 1);
            if (parseQueryString) {
                this.query = this.parse(this.query);
            }
            rest = rest.slice(0, qm);
        }
        else if (parseQueryString) {
            // no query string, but parseQueryString still requested
            this.search = '';
            this.query = {};
        }
        if (rest) {
            this.pathname = rest;
        }
        if (Url.slashedProtocol[lowerProto] &&
            this.hostname && !this.pathname) {
            this.pathname = '/';
        }
        //to support http.request
        if (this.pathname || this.search) {
            var p = this.pathname || '';
            var s = this.search || '';
            this.path = p + s;
        }
        // finally, reconstruct the href based on what has been validated.
        this.href = this.format();
        return this;
    }
    ;
    /**
 * Converts a Unicode string representing a domain name or an email address to
 * Punycode. Only the non-ASCII parts of the domain name will be converted,
 * i.e. it doesn't matter if you call it with a domain that's already in
 * ASCII.
 * @memberOf punycode
 * @param {String} input The domain name or email address to convert, as a
 * Unicode string.
 * @returns {String} The Punycode representation of the given domain name or
 * email address.
 */
    toASCII(input) {
        return this.mapDomain(input, function (string) {
            return Url.regexNonASCII.test(string)
                ? 'xn--' + this.encode(string)
                : string;
        });
    }
    stringifyPrimitive(v) {
        switch (typeof v) {
            case 'string':
                return v;
            case 'boolean':
                return v ? 'true' : 'false';
            case 'number':
                return isFinite(v) ? v : '';
            default:
                return '';
        }
    }
    ;
    encode(obj, sep = null, eq = null, name = null) {
        sep = sep || '&';
        eq = eq || '=';
        if (obj === null) {
            obj = undefined;
        }
        if (typeof obj === 'object') {
            return Object.keys(obj).map(function (k) {
                var ks = encodeURIComponent(this.stringifyPrimitive(k)) + eq;
                if (Array.isArray(obj[k])) {
                    return obj[k].map(function (v) {
                        return ks + encodeURIComponent(this.stringifyPrimitive(v));
                    }).join(sep);
                }
                else {
                    return ks + encodeURIComponent(this.stringifyPrimitive(obj[k]));
                }
            }).join(sep);
        }
        if (!name) {
            return '';
        }
        return encodeURIComponent(this.stringifyPrimitive(name)) + eq +
            encodeURIComponent(this.stringifyPrimitive(obj));
    }
    ;
    /**
     * A simple `Array#map`-like wrapper to work with domain name strings or email
     * addresses.
     * @private
     * @param {String} domain The domain name or email address.
     * @param {Function} callback The function that gets called for every
     * character.
     * @returns {Array} A new string of characters returned by the callback
     * function.
     */
    mapDomain(string, fn) {
        var parts = string.split('@');
        var result = '';
        if (parts.length > 1) {
            // In email addresses, only the domain name should be punycoded. Leave
            // the local part (i.e. everything up to `@`) intact.
            result = parts[0] + '@';
            string = parts[1];
        }
        // Avoid `split(regex)` for IE8 compatibility. See #17.
        string = string.replace(Url.regexSeparators, '\x2E');
        var labels = string.split('.');
        var encoded = this.map(labels, fn).join('.');
        return result + encoded;
    }
    /**
     * A generic `Array#map` utility function.
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} callback The function that gets called for every array
     * item.
     * @returns {Array} A new array of values returned by the callback function.
     */
    map(array, fn) {
        var length = array.length;
        var result = [];
        while (length--) {
            result[length] = fn(array[length]);
        }
        return result;
    }
    format() {
        var auth = this.auth || '';
        if (auth) {
            auth = encodeURIComponent(auth);
            auth = auth.replace(/%3A/i, ':');
            auth += '@';
        }
        var protocol = this.protocol || '', pathname = this.pathname || '', hash = this.hash || '', host = false, query = '';
        if (this.host) {
            host = auth + this.host;
        }
        else if (this.hostname) {
            host = auth + (this.hostname.indexOf(':') === -1 ?
                this.hostname :
                '[' + this.hostname + ']');
            if (this.port) {
                host += ':' + this.port;
            }
        }
        if (this.query &&
            UtilsSettings_1.UtilsSettings.util.isObject(this.query) &&
            Object.keys(this.query).length) {
            query = this.encode(this.query);
        }
        var search = this.search || (query && ('?' + query)) || '';
        if (protocol && protocol.substr(-1) !== ':') {
            protocol += ':';
        }
        // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
        // unless they had them to begin with.
        if (this.slashes ||
            (!protocol || Url.slashedProtocol[protocol]) && host !== false) {
            host = '//' + (host || '');
            if (pathname && pathname.charAt(0) !== '/') {
                pathname = '/' + pathname;
            }
        }
        else if (!host) {
            host = '';
        }
        if (hash && hash.charAt(0) !== '#') {
            hash = '#' + hash;
        }
        if (search && search.charAt(0) !== '?') {
            search = '?' + search;
        }
        pathname = pathname.replace(/[?#]/g, function (match) {
            return encodeURIComponent(match);
        });
        search = search.replace('#', '%23');
        return protocol + host + pathname + search + hash;
    }
    ;
}
Url.regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g;
Url.portPattern = /:[0-9]*$/;
Url.simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/;
Url.protocolPattern = /^([a-z0-9.+-]+:)/i;
Url.regexNonASCII = /[^\x20-\x7E]/;
Url.hostlessProtocol = {
    'javascript': true,
    'javascript:': true
};
Url.slashedProtocol = {
    'http': true,
    'https': true,
    'ftp': true,
    'gopher': true,
    'file': true,
    'http:': true,
    'https:': true,
    'ftp:': true,
    'gopher:': true,
    'file:': true
};
Url.hostEndingChars = ['/', '?', '#'];
Url.delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'];
Url.unwise = ['{', '}', '|', '\\', '^', '`'].concat(Url.delims);
Url.autoEscape = ['\''].concat(Url.unwise);
Url.nonHostChars = ['%', '/', '?', ';', '#'].concat(Url.autoEscape);
Url.hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/;
Url.hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/;
Url.hostnameMaxLen = 255;
Url.unsafeProtocol = {
    'javascript': true,
    'javascript:': true
};
exports.Url = Url;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/UtilsSettings.js":
/*!*************************************************!*\
  !*** ./js-compile/raw-pixi-ts/UtilsSettings.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class UtilsSettings {
    static removeItems(arr, startIdx, removeCount) {
        var length = arr.length;
        var i;
        if (startIdx >= length || removeCount === 0) {
            return;
        }
        removeCount = (startIdx + removeCount > length ? length - startIdx : removeCount);
        var len = length - removeCount;
        for (i = startIdx; i < len; ++i) {
            arr[i] = arr[i + removeCount];
        }
        arr.length = len;
    }
    static deepCopyProperties(target, source, propertyObj) {
        for (var prop in propertyObj) {
            if (Array.isArray(source[prop])) {
                target[prop] = source[prop].slice();
            }
            else {
                target[prop] = source[prop];
            }
        }
    }
    static areArraysEqual(array1, array2) {
        if (!Array.isArray(array1) || !Array.isArray(array2)) {
            return false;
        }
        if (array1.length !== array2.length) {
            return false;
        }
        for (var i = 0; i < array1.length; ++i) {
            if (array1[i] !== array2[i]) {
                return false;
            }
        }
        return true;
    }
    static unsafeEvalSupported() {
        if (typeof UtilsSettings.unsafeEval === 'boolean') {
            return UtilsSettings.unsafeEval;
        }
        try {
            var func = new Function('param1', 'param2', 'param3', 'return param1[param2] === param3;');
            UtilsSettings.unsafeEval = func({ a: 'b' }, 'a', 'b') === true;
        }
        catch (e) {
            UtilsSettings.unsafeEval = false;
        }
        return UtilsSettings.unsafeEval;
    }
    static isWebGLSupported() {
        var contextOptions = { stencil: true, failIfMajorPerformanceCaveat: true };
        try {
            if (!window['WebGLRenderingContext']) {
                return false;
            }
            var canvas = document.createElement('canvas');
            var gl = canvas.getContext('webgl', contextOptions) || canvas.getContext('experimental-webgl', contextOptions);
            var success = !!(gl && gl.getContextAttributes().stencil);
            if (gl) {
                var loseContext = gl.getExtension('WEBGL_lose_context');
                if (loseContext) {
                    loseContext.loseContext();
                }
            }
            gl = null;
            return success;
        }
        catch (e) {
            return false;
        }
    }
}
UtilsSettings.util = {
    isString: function (arg) {
        return typeof (arg) === 'string';
    },
    isObject: function (arg) {
        return typeof (arg) === 'object' && arg !== null;
    },
    isNull: function (arg) {
        return arg === null;
    },
    isNullOrUndefined: function (arg) {
        return arg == null;
    }
};
exports.UtilsSettings = UtilsSettings;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/VideoResource.js":
/*!*************************************************!*\
  !*** ./js-compile/raw-pixi-ts/VideoResource.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const BaseImageResource_1 = __webpack_require__(/*! ./BaseImageResource */ "./js-compile/raw-pixi-ts/BaseImageResource.js");
const Ticker_1 = __webpack_require__(/*! ./Ticker */ "./js-compile/raw-pixi-ts/Ticker.js");
class VideoResource extends BaseImageResource_1.BaseImageResource {
    constructor(source, options) {
        options = options || {};
        // throw "stop"
        if (!(source instanceof HTMLVideoElement)) {
            var videoElement = document.createElement('video');
            videoElement.setAttribute('webkit-playsinline', '');
            videoElement.setAttribute('playsinline', '');
            if (typeof source === 'string') {
                source = [source];
            }
            BaseImageResource_1.BaseImageResource.crossOrigin(videoElement, (source[0].src || source[0]), options.crossorigin);
            // array of objects or strings
            for (var i = 0; i < source.length; ++i) {
                var sourceElement = document.createElement('source');
                var ref = source[i];
                var src = ref.src;
                var mime = ref.mime;
                src = src || source[i];
                var baseSrc = src.split('?').shift().toLowerCase();
                var ext = baseSrc.substr(baseSrc.lastIndexOf('.') + 1);
                mime = mime || ("video/" + ext);
                sourceElement.src = src;
                sourceElement.type = mime;
                videoElement.appendChild(sourceElement);
            }
            // Override the source
            source = videoElement;
        }
        super(source);
        this.canUpload = false;
        this._autoUpdate = true;
        this._isAutoUpdating = false;
        this._updateFPS = options.updateFPS || 0;
        this._msToNextUpdate = 0;
        /**
         * When set to true will automatically play videos used by this texture once
         * they are loaded. If false, it will not modify the playing state.
         *
         * @member {boolean}
         * @default true
         */
        this.autoPlay = options.autoPlay !== false;
        /**
         * Promise when loading
         * @member {Promise<void>}
         * @private
         * @default null
         */
        this._load = null;
        /**
         * Callback when completed with load.
         * @member {function}
         * @private
         */
        this._resolve = null;
        // Bind for listeners
        this._onCanPlay = this._onCanPlay.bind(this);
        if (options.autoLoad !== false) {
            this.load();
        }
    }
    /**
     * Trigger updating of the texture
     *
     * @param {number} [deltaTime=0] - time delta since last tick
     */
    update(deltaTime = 0) {
        if (!this.destroyed) {
            // account for if video has had its playbackRate changed
            var elapsedMS = Ticker_1.Ticker.shared.elapsedMS * this.source.playbackRate;
            this._msToNextUpdate = Math.floor(this._msToNextUpdate - elapsedMS);
            if (!this._updateFPS || this._msToNextUpdate <= 0) {
                super.update(deltaTime);
                this._msToNextUpdate = this._updateFPS ? Math.floor(1000 / this._updateFPS) : 0;
            }
        }
    }
    ;
    /**
     * Start preloading the video resource.
     *
     * @protected
     * @return {Promise<void>} Handle the validate event
     */
    load() {
        var this$1 = this;
        if (this._load) {
            return this._load;
        }
        var source = this.source;
        if ((source.readyState === source.HAVE_ENOUGH_DATA || source.readyState === source.HAVE_FUTURE_DATA)
            && source.width && source.height) {
            source.complete = true;
        }
        source.addEventListener('play', this._onPlayStart.bind(this));
        source.addEventListener('pause', this._onPlayStop.bind(this));
        if (!this._isSourceReady()) {
            source.addEventListener('canplay', this._onCanPlay);
            source.addEventListener('canplaythrough', this._onCanPlay);
        }
        else {
            this._onCanPlay();
        }
        this._load = new Promise(function (resolve) {
            if (this$1.valid) {
                resolve(this$1);
            }
            else {
                this$1._resolve = resolve;
                source.load();
            }
        });
        return this._load;
    }
    ;
    /**
     * Returns true if the underlying source is playing.
     *
     * @private
     * @return {boolean} True if playing.
     */
    _isSourcePlaying() {
        var source = this.source;
        return (source.currentTime > 0 && source.paused === false && source.ended === false && source.readyState > 2);
    }
    ;
    /**
     * Returns true if the underlying source is ready for playing.
     *
     * @private
     * @return {boolean} True if ready.
     */
    _isSourceReady() {
        return this.source.readyState === 3 || this.source.readyState === 4;
    }
    ;
    /**
     * Runs the update loop when the video is ready to play
     *
     * @private
     */
    _onPlayStart() {
        // Just in case the video has not received its can play even yet..
        if (!this.valid) {
            this._onCanPlay();
        }
        if (!this._isAutoUpdating && this.autoUpdate) {
            Ticker_1.Ticker.shared.add(this.update, this);
            this._isAutoUpdating = true;
        }
    }
    ;
    /**
     * Fired when a pause event is triggered, stops the update loop
     *
     * @private
     */
    _onPlayStop() {
        if (this._isAutoUpdating) {
            Ticker_1.Ticker.shared.remove(this.update, this);
            this._isAutoUpdating = false;
        }
    }
    ;
    /**
     * Fired when the video is loaded and ready to play
     *
     * @private
     */
    _onCanPlay() {
        var ref = this;
        var source = ref.source;
        source.removeEventListener('canplay', this._onCanPlay);
        source.removeEventListener('canplaythrough', this._onCanPlay);
        var valid = this.valid;
        this.resize(source.videoWidth, source.videoHeight);
        // prevent multiple loaded dispatches..
        if (!valid && this._resolve) {
            this._resolve(this);
            this._resolve = null;
        }
        if (this._isSourcePlaying()) {
            this._onPlayStart();
        }
        else if (this.autoPlay) {
            source.play();
        }
    }
    ;
    /**
     * Destroys this texture
     * @override
     */
    dispose() {
        if (this._isAutoUpdating) {
            Ticker_1.Ticker.shared.remove(this.update, this);
        }
        if (this.source) {
            this.source.pause();
            this.source.src = '';
            this.source.load();
        }
        BaseImageResource_1.BaseImageResource.prototype.dispose.call(this);
    }
    ;
    /**
     * Should the base texture automatically update itself, set to true by default
     *
     * @member {boolean}
     */
    get autoUpdate() {
        return this._autoUpdate;
    }
    ;
    set autoUpdate(value) {
        if (value !== this._autoUpdate) {
            this._autoUpdate = value;
            if (!this._autoUpdate && this._isAutoUpdating) {
                Ticker_1.Ticker.shared.remove(this.update, this);
                this._isAutoUpdating = false;
            }
            else if (this._autoUpdate && !this._isAutoUpdating) {
                Ticker_1.Ticker.shared.add(this.update, this);
                this._isAutoUpdating = true;
            }
        }
    }
    ;
    /**
     * How many times a second to update the texture from the video. Leave at 0 to update at every render.
     * A lower fps can help performance, as updating the texture at 60fps on a 30ps video may not be efficient.
     *
     * @member {number}
     */
    get updateFPS() {
        return this._updateFPS;
    }
    ;
    set updateFPS(value) {
        if (value !== this._updateFPS) {
            this._updateFPS = value;
        }
    }
    ;
    /**
     * Used to auto-detect the type of resource.
     *
     * @static
     * @param {*} source - The source object
     * @param {string} extension - The extension of source, if set
     * @return {boolean} `true` if video source
     */
    static test(source, extension) {
        return (source instanceof HTMLVideoElement)
            || VideoResource.TYPES.indexOf(extension) > -1;
    }
    ;
}
VideoResource.TYPES = ['mp4', 'm4v', 'webm', 'ogg', 'ogv', 'h264', 'avi', 'mov'];
exports.VideoResource = VideoResource;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/WebGLSettings.js":
/*!*************************************************!*\
  !*** ./js-compile/raw-pixi-ts/WebGLSettings.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Program_1 = __webpack_require__(/*! ./Program */ "./js-compile/raw-pixi-ts/Program.js");
const Matrix_1 = __webpack_require__(/*! ./Matrix */ "./js-compile/raw-pixi-ts/Matrix.js");
const Shader_1 = __webpack_require__(/*! ./Shader */ "./js-compile/raw-pixi-ts/Shader.js");
const CacheSettings_1 = __webpack_require__(/*! ./CacheSettings */ "./js-compile/raw-pixi-ts/CacheSettings.js");
const UniformGroup_1 = __webpack_require__(/*! ./UniformGroup */ "./js-compile/raw-pixi-ts/UniformGroup.js");
const DisplaySettings_1 = __webpack_require__(/*! ./DisplaySettings */ "./js-compile/raw-pixi-ts/DisplaySettings.js");
class WebGLSettings {
    static createIndicesForQuads(size) {
        var totalIndices = size * 6;
        var indices = new Uint16Array(totalIndices);
        for (var i = 0, j = 0; i < totalIndices; i += 6, j += 4) {
            indices[i + 0] = j + 0;
            indices[i + 1] = j + 1;
            indices[i + 2] = j + 2;
            indices[i + 3] = j + 0;
            indices[i + 4] = j + 2;
            indices[i + 5] = j + 3;
        }
        return indices;
    }
    static canUploadSameBuffer() {
        return true;
    }
    static generateMultiTextureShader(gl, maxTextures) {
        if (!CacheSettings_1.CacheSettings.programCache[maxTextures]) {
            var sampleValues = new Int32Array(maxTextures);
            for (var i = 0; i < maxTextures; i++) {
                sampleValues[i] = i;
            }
            CacheSettings_1.CacheSettings.defaultGroupCache[maxTextures] = UniformGroup_1.UniformGroup.from({ uSamplers: sampleValues }, true);
            var fragmentSrc = WebGLSettings.fragTemplate$1;
            fragmentSrc = fragmentSrc.replace(/%count%/gi, maxTextures);
            fragmentSrc = fragmentSrc.replace(/%forloop%/gi, WebGLSettings.generateSampleSrc(maxTextures));
            CacheSettings_1.CacheSettings.programCache[maxTextures] = new Program_1.Program(WebGLSettings.vertex$1, fragmentSrc);
        }
        var uniforms = {
            tint: new Float32Array([1, 1, 1, 1]),
            translationMatrix: new Matrix_1.Matrix(),
            default: CacheSettings_1.CacheSettings.defaultGroupCache[maxTextures],
        };
        var shader = new Shader_1.Shader(CacheSettings_1.CacheSettings.programCache[maxTextures], uniforms);
        return shader;
    }
    static generateSampleSrc(maxTextures) {
        var src = '';
        src += '\n';
        src += '\n';
        for (var i = 0; i < maxTextures; i++) {
            if (i > 0) {
                src += '\nelse ';
            }
            if (i < maxTextures - 1) {
                src += "if(vTextureId < " + i + ".5)";
            }
            src += '\n{';
            src += "\n\tcolor = texture2D(uSamplers[" + i + "], vTextureCoord);";
            src += '\n}';
        }
        src += '\n';
        src += '\n';
        return src;
    }
    static checkMaxIfStatementsInShader(maxIfs, gl) {
        if (maxIfs === 0) {
            throw new Error('Invalid value of `0` passed to `checkMaxIfStatementsInShader`');
        }
        var shader = gl.createShader(gl.FRAGMENT_SHADER);
        while (true) // eslint-disable-line no-constant-condition
         {
            var fragmentSrc = WebGLSettings.fragTemplate.replace(/%forloop%/gi, WebGLSettings.generateIfTestSrc(maxIfs));
            gl.shaderSource(shader, fragmentSrc);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                maxIfs = (maxIfs / 2) | 0;
            }
            else {
                // valid!
                break;
            }
        }
        return maxIfs;
    }
    static generateIfTestSrc(maxIfs) {
        var src = '';
        for (var i = 0; i < maxIfs; ++i) {
            if (i > 0) {
                src += '\nelse ';
            }
            if (i < maxIfs - 1) {
                src += "if(test == " + i + ".0){}";
            }
        }
        return src;
    }
    static maxRecommendedTextures(max) {
        var allowMax = true;
        var match = (navigator.userAgent).match(/OS (\d+)_(\d+)?/);
        if (match) {
            var majorVersion = parseInt(match[1], 10);
            if (majorVersion >= 11) {
                allowMax = true;
            }
        }
        var match$1 = (navigator.userAgent).match(/Android\s([0-9.]*)/);
        if (match$1) {
            var majorVersion$1 = parseInt(match$1[1], 10);
            if (majorVersion$1 >= 7) {
                allowMax = true;
            }
        }
        return allowMax ? max : 4;
    }
    static setPrecision(src, precision) {
        if (src.substring(0, 9) !== 'precision') // && src.substring(0, 1) !== '#')
         {
            return ("precision " + precision + " float;\n" + src);
        }
        return src;
    }
    static getTestContext() {
        if (!WebGLSettings.context) {
            var canvas = document.createElement('canvas');
            var gl;
            if (DisplaySettings_1.DisplaySettings.PREFER_ENV >= DisplaySettings_1.DisplaySettings.ENV.WEBGL2) {
                gl = canvas.getContext('webgl2', {});
            }
            if (!gl) {
                gl = canvas.getContext('webgl', {})
                    || canvas.getContext('experimental-webgl', {});
                if (!gl) {
                    // fail, not able to get a context
                    throw new Error('This browser does not support WebGL. Try using the canvas renderer');
                }
                else {
                    // for shader testing..
                    gl.getExtension('WEBGL_draw_buffers');
                }
            }
            WebGLSettings.context = gl;
            return gl;
        }
        return WebGLSettings.context;
    }
    static defaultValue(type, size) {
        switch (type) {
            case 'float':
                return 0;
            case 'vec2':
                return new Float32Array(2 * size);
            case 'vec3':
                return new Float32Array(3 * size);
            case 'vec4':
                return new Float32Array(4 * size);
            case 'int':
            case 'sampler2D':
            case 'sampler2DArray':
                return 0;
            case 'ivec2':
                return new Int32Array(2 * size);
            case 'ivec3':
                return new Int32Array(3 * size);
            case 'ivec4':
                return new Int32Array(4 * size);
            case 'bool':
                return false;
            case 'bvec2':
                return WebGLSettings.booleanArray(2 * size);
            case 'bvec3':
                return WebGLSettings.booleanArray(3 * size);
            case 'bvec4':
                return WebGLSettings.booleanArray(4 * size);
            case 'mat2':
                return new Float32Array([1, 0,
                    0, 1]);
            case 'mat3':
                return new Float32Array([1, 0, 0,
                    0, 1, 0,
                    0, 0, 1]);
            case 'mat4':
                return new Float32Array([1, 0, 0, 0,
                    0, 1, 0, 0,
                    0, 0, 1, 0,
                    0, 0, 0, 1]);
        }
        return null;
    }
    static booleanArray(size) {
        var array = new Array(size);
        for (var i = 0; i < array.length; i++) {
            array[i] = false;
        }
        return array;
    }
    static mapType(gl, type) {
        if (!WebGLSettings.GL_TABLE) {
            var typeNames = Object.keys(WebGLSettings.GL_TO_GLSL_TYPES);
            WebGLSettings.GL_TABLE = {};
            for (var i = 0; i < typeNames.length; ++i) {
                var tn = typeNames[i];
                WebGLSettings.GL_TABLE[gl[tn]] = WebGLSettings.GL_TO_GLSL_TYPES[tn];
            }
        }
        return WebGLSettings.GL_TABLE[type];
    }
    static mapSize(type) {
        return WebGLSettings.GLSL_TO_SIZE[type];
    }
    static generateUniformsSync(group, uniformData) {
        var textureCount = 0;
        var func = "var v = null;\n    var cv = null\n    var gl = renderer.gl";
        for (var i in group.uniforms) {
            var data = uniformData[i];
            if (!data) {
                if (group.uniforms[i].group) {
                    func += "\n                    renderer.shader.syncUniformGroup(uv." + i + ");\n                ";
                }
                continue;
            }
            // TODO && uniformData[i].value !== 0 <-- do we still need this?
            if (data.type === 'float' && data.size === 1) {
                func += "\n            if(uv." + i + " !== ud." + i + ".value)\n            {\n                ud." + i + ".value = uv." + i + "\n                gl.uniform1f(ud." + i + ".location, uv." + i + ")\n            }\n";
            }
            /* eslint-disable max-len */
            else if ((data.type === 'sampler2D' || data.type === 'samplerCube' || data.type === 'sampler2DArray') && data.size === 1 && !data.isArray) 
            /* eslint-disable max-len */
            {
                func += "\n            renderer.texture.bind(uv." + i + ", " + textureCount + ");\n\n            if(ud." + i + ".value !== " + textureCount + ")\n            {\n                ud." + i + ".value = " + textureCount + ";\n                gl.uniform1i(ud." + i + ".location, " + textureCount + ");\n; // eslint-disable-line max-len\n            }\n";
                textureCount++;
            }
            else if (data.type === 'mat3' && data.size === 1) {
                if (group.uniforms[i].a !== undefined) {
                    // TODO and some smart caching dirty ids here!
                    func += "\n                gl.uniformMatrix3fv(ud." + i + ".location, false, uv." + i + ".toArray(true));\n                \n";
                }
                else {
                    func += "\n                gl.uniformMatrix3fv(ud." + i + ".location, false, uv." + i + ");\n                \n";
                }
            }
            else if (data.type === 'vec2' && data.size === 1) {
                // TODO - do we need both here?
                // maybe we can get away with only using points?
                if (group.uniforms[i].x !== undefined) {
                    func += "\n                cv = ud." + i + ".value;\n                v = uv." + i + ";\n\n                if(cv[0] !== v.x || cv[1] !== v.y)\n                {\n                    cv[0] = v.x;\n                    cv[1] = v.y;\n                    gl.uniform2f(ud." + i + ".location, v.x, v.y);\n                }\n";
                }
                else {
                    func += "\n                cv = ud." + i + ".value;\n                v = uv." + i + ";\n\n                if(cv[0] !== v[0] || cv[1] !== v[1])\n                {\n                    cv[0] = v[0];\n                    cv[1] = v[1];\n                    gl.uniform2f(ud." + i + ".location, v[0], v[1]);\n                }\n                \n";
                }
            }
            else if (data.type === 'vec4' && data.size === 1) {
                // TODO - do we need both here?
                // maybe we can get away with only using points?
                if (group.uniforms[i].width !== undefined) {
                    func += "\n                cv = ud." + i + ".value;\n                v = uv." + i + ";\n\n                if(cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height)\n                {\n                    cv[0] = v.x;\n                    cv[1] = v.y;\n                    cv[2] = v.width;\n                    cv[3] = v.height;\n                    gl.uniform4f(ud." + i + ".location, v.x, v.y, v.width, v.height)\n                }\n";
                }
                else {
                    func += "\n                cv = ud." + i + ".value;\n                v = uv." + i + ";\n\n                if(cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])\n                {\n                    cv[0] = v[0];\n                    cv[1] = v[1];\n                    cv[2] = v[2];\n                    cv[3] = v[3];\n\n                    gl.uniform4f(ud." + i + ".location, v[0], v[1], v[2], v[3])\n                }\n                \n";
                }
            }
            else {
                var templateType = (data.size === 1) ? WebGLSettings.GLSL_TO_SINGLE_SETTERS_CACHED : WebGLSettings.GLSL_TO_ARRAY_SETTERS;
                var template = templateType[data.type].replace('location', ("ud." + i + ".location"));
                func += "\n            cv = ud." + i + ".value;\n            v = uv." + i + ";\n            " + template + ";\n";
            }
        }
        return new Function('ud', 'uv', 'renderer', func); // eslint-disable-line no-new-func
    }
}
WebGLSettings.UPLOADS_PER_FRAME = 4;
WebGLSettings.GLSL_TO_ARRAY_SETTERS = {
    float: "gl.uniform1fv(location, v)",
    vec2: "gl.uniform2fv(location, v)",
    vec3: "gl.uniform3fv(location, v)",
    vec4: 'gl.uniform4fv(location, v)',
    mat4: 'gl.uniformMatrix4fv(location, false, v)',
    mat3: 'gl.uniformMatrix3fv(location, false, v)',
    mat2: 'gl.uniformMatrix2fv(location, false, v)',
    int: 'gl.uniform1iv(location, v)',
    ivec2: 'gl.uniform2iv(location, v)',
    ivec3: 'gl.uniform3iv(location, v)',
    ivec4: 'gl.uniform4iv(location, v)',
    bool: 'gl.uniform1iv(location, v)',
    bvec2: 'gl.uniform2iv(location, v)',
    bvec3: 'gl.uniform3iv(location, v)',
    bvec4: 'gl.uniform4iv(location, v)',
    sampler2D: 'gl.uniform1iv(location, v)',
    samplerCube: 'gl.uniform1iv(location, v)',
    sampler2DArray: 'gl.uniform1iv(location, v)',
};
WebGLSettings.GLSL_TO_SINGLE_SETTERS_CACHED = {
    float: "\n    if(cv !== v)\n    {\n        cv.v = v;\n        gl.uniform1f(location, v)\n    }",
    vec2: "\n    if(cv[0] !== v[0] || cv[1] !== v[1])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        gl.uniform2f(location, v[0], v[1])\n    }",
    vec3: "\n    if(cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])\n    {\n        cv[0] = v[0];\n        cv[1] = v[1];\n        cv[2] = v[2];\n\n        gl.uniform3f(location, v[0], v[1], v[2])\n    }",
    vec4: 'gl.uniform4f(location, v[0], v[1], v[2], v[3])',
    int: 'gl.uniform1i(location, v)',
    ivec2: 'gl.uniform2i(location, v[0], v[1])',
    ivec3: 'gl.uniform3i(location, v[0], v[1], v[2])',
    ivec4: 'gl.uniform4i(location, v[0], v[1], v[2], v[3])',
    bool: 'gl.uniform1i(location, v)',
    bvec2: 'gl.uniform2i(location, v[0], v[1])',
    bvec3: 'gl.uniform3i(location, v[0], v[1], v[2])',
    bvec4: 'gl.uniform4i(location, v[0], v[1], v[2], v[3])',
    mat2: 'gl.uniformMatrix2fv(location, false, v)',
    mat3: 'gl.uniformMatrix3fv(location, false, v)',
    mat4: 'gl.uniformMatrix4fv(location, false, v)',
    sampler2D: 'gl.uniform1i(location, v)',
    samplerCube: 'gl.uniform1i(location, v)',
    sampler2DArray: 'gl.uniform1i(location, v)',
};
WebGLSettings.GLSL_TO_SIZE = {
    float: 1,
    vec2: 2,
    vec3: 3,
    vec4: 4,
    int: 1,
    ivec2: 2,
    ivec3: 3,
    ivec4: 4,
    bool: 1,
    bvec2: 2,
    bvec3: 3,
    bvec4: 4,
    mat2: 4,
    mat3: 9,
    mat4: 16,
    sampler2D: 1,
};
WebGLSettings.GL_TO_GLSL_TYPES = {
    FLOAT: 'float',
    FLOAT_VEC2: 'vec2',
    FLOAT_VEC3: 'vec3',
    FLOAT_VEC4: 'vec4',
    INT: 'int',
    INT_VEC2: 'ivec2',
    INT_VEC3: 'ivec3',
    INT_VEC4: 'ivec4',
    BOOL: 'bool',
    BOOL_VEC2: 'bvec2',
    BOOL_VEC3: 'bvec3',
    BOOL_VEC4: 'bvec4',
    FLOAT_MAT2: 'mat2',
    FLOAT_MAT3: 'mat3',
    FLOAT_MAT4: 'mat4',
    SAMPLER_2D: 'sampler2D',
    SAMPLER_CUBE: 'samplerCube',
    SAMPLER_2D_ARRAY: 'sampler2DArray',
};
WebGLSettings.GL_TABLE = null;
WebGLSettings.context = null;
WebGLSettings.PRECISION_FRAGMENT = 'highp';
WebGLSettings.PRECISION_VERTEX = 'highp';
WebGLSettings.fragTemplate = [
    'precision mediump float;',
    'void main(void){',
    'float test = 0.1;',
    '%forloop%',
    'gl_FragColor = vec4(0.0);',
    '}'
].join('\n');
WebGLSettings.vertex$1 = "precision highp float;\r\nattribute vec2 aVertexPosition;\r\nattribute vec2 aTextureCoord;\r\nattribute vec4 aColor;\r\nattribute float aTextureId;\r\n\r\nuniform mat3 projectionMatrix;\r\nuniform mat3 translationMatrix;\r\nuniform vec4 tint;\r\n\r\nvarying vec2 vTextureCoord;\r\nvarying vec4 vColor;\r\nvarying float vTextureId;\r\n\r\nvoid main(void){\r\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\r\n\r\n    vTextureCoord = aTextureCoord;\r\n    vTextureId = aTextureId;\r\n    vColor = aColor * tint;\r\n}\r\n";
WebGLSettings.fragTemplate$1 = [
    'varying vec2 vTextureCoord;',
    'varying vec4 vColor;',
    'varying float vTextureId;',
    'uniform sampler2D uSamplers[%count%];',
    'void main(void){',
    'vec4 color;',
    '%forloop%',
    'gl_FragColor = color * vColor;',
    '}'
].join('\n');
WebGLSettings.MIPMAP_TEXTURES = 1;
WebGLSettings.WRAP_MODE = 33071;
WebGLSettings.TARGETS = {
    TEXTURE_2D: 3553,
    TEXTURE_CUBE_MAP: 34067,
    TEXTURE_2D_ARRAY: 35866,
    TEXTURE_CUBE_MAP_POSITIVE_X: 34069,
    TEXTURE_CUBE_MAP_NEGATIVE_X: 34070,
    TEXTURE_CUBE_MAP_POSITIVE_Y: 34071,
    TEXTURE_CUBE_MAP_NEGATIVE_Y: 34072,
    TEXTURE_CUBE_MAP_POSITIVE_Z: 34073,
    TEXTURE_CUBE_MAP_NEGATIVE_Z: 34074,
};
WebGLSettings.FORMATS = {
    RGBA: 6408,
    RGB: 6407,
    ALPHA: 6406,
    LUMINANCE: 6409,
    LUMINANCE_ALPHA: 6410,
    DEPTH_COMPONENT: 6402,
    DEPTH_STENCIL: 34041,
};
WebGLSettings.TYPES = {
    UNSIGNED_BYTE: 5121,
    UNSIGNED_SHORT: 5123,
    UNSIGNED_SHORT_5_6_5: 33635,
    UNSIGNED_SHORT_4_4_4_4: 32819,
    UNSIGNED_SHORT_5_5_5_1: 32820,
    FLOAT: 5126,
    HALF_FLOAT: 36193,
};
WebGLSettings.MIPMAP_MODES = {
    OFF: 0,
    POW2: 1,
    ON: 2,
};
WebGLSettings.SCALE_MODES = {
    LINEAR: 1,
    NEAREST: 0,
};
WebGLSettings.WRAP_MODES = {
    CLAMP: 33071,
    REPEAT: 10497,
    MIRRORED_REPEAT: 33648,
};
WebGLSettings.defaultBufferOptions = {
    scaleMode: WebGLSettings.SCALE_MODES.NEAREST,
    format: WebGLSettings.FORMATS.RGBA,
    premultiplyAlpha: false,
};
WebGLSettings.CAN_UPLOAD_SAME_BUFFER = WebGLSettings.canUploadSameBuffer();
WebGLSettings.SPRITE_MAX_TEXTURES = WebGLSettings.maxRecommendedTextures(32);
exports.WebGLSettings = WebGLSettings;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/XMLParser.js":
/*!*********************************************!*\
  !*** ./js-compile/raw-pixi-ts/XMLParser.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class XMLParser {
    static parse(value) {
        var parser = new DOMParser();
        var result = parser.parseFromString(value, "text/xml");
        return result;
    }
}
exports.XMLParser = XMLParser;


/***/ }),

/***/ "./js-compile/raw-pixi-ts/settings.js":
/*!********************************************!*\
  !*** ./js-compile/raw-pixi-ts/settings.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
class settings {
    /**
     * Converts a digit/integer into a basic code point.
     * @see `basicToDigit()`
     * @private
     * @param {Number} digit The numeric value of a basic code point.
     * @returns {Number} The basic code point whose value (when used for
     * representing integers) is `digit`, which needs to be in the range
     * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
     * used; else, the lowercase form is used. The behavior is undefined
     * if `flag` is non-zero and `digit` has no uppercase form.
     */
    static digitToBasic(digit, flag) {
        //  0..25 map to ASCII a..z or A..Z
        // 26..35 map to ASCII 0..9
        return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
    }
    /**
     * A generic error utility function.
     * @private
     * @param {String} type The error type.
     * @returns {Error} Throws a `RangeError` with the applicable error message.
     */
    static error(type) {
        throw RangeError(settings.errors[type]);
    }
    /**
 * Converts a string of Unicode symbols (e.g. a domain name label) to a
 * Punycode string of ASCII-only symbols.
 * @memberOf punycode
 * @param {String} input The string of Unicode symbols.
 * @returns {String} The resulting Punycode string of ASCII-only symbols.
 */
    static encode(input) {
        var n, delta, handledCPCount, basicLength, bias, j, m, q, k, t, currentValue, output = [], 
        /** `inputLength` will hold the number of code points in `input`. */
        inputLength, 
        /** Cached calculation results */
        handledCPCountPlusOne, baseMinusT, qMinusT;
        // Convert the input in UCS-2 to Unicode
        input = settings.ucs2decode(input);
        // Cache the length
        inputLength = input.length;
        // Initialize the state
        n = settings.initialN;
        delta = 0;
        bias = settings.initialBias;
        // Handle the basic code points
        for (j = 0; j < inputLength; ++j) {
            currentValue = input[j];
            if (currentValue < 0x80) {
                output.push(settings.stringFromCharCode(currentValue));
            }
        }
        handledCPCount = basicLength = output.length;
        // `handledCPCount` is the number of code points that have been handled;
        // `basicLength` is the number of basic code points.
        // Finish the basic string - if it is not empty - with a delimiter
        if (basicLength) {
            output.push(settings.delimiter);
        }
        // Main encoding loop:
        while (handledCPCount < inputLength) {
            // All non-basic code points < n have been handled already. Find the next
            // larger one:
            for (m = settings.maxInt, j = 0; j < inputLength; ++j) {
                currentValue = input[j];
                if (currentValue >= n && currentValue < m) {
                    m = currentValue;
                }
            }
            // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
            // but guard against overflow
            handledCPCountPlusOne = handledCPCount + 1;
            if (m - n > settings.floor((settings.maxInt - delta) / handledCPCountPlusOne)) {
                settings.error('overflow');
            }
            delta += (m - n) * handledCPCountPlusOne;
            n = m;
            for (j = 0; j < inputLength; ++j) {
                currentValue = input[j];
                if (currentValue < n && ++delta > settings.maxInt) {
                    settings.error('overflow');
                }
                if (currentValue == n) {
                    // Represent delta as a generalized variable-length integer
                    for (q = delta, k = settings.base; /* no condition */; k += settings.base) {
                        t = k <= bias ? settings.tMin : (k >= bias + settings.tMax ? settings.tMax : k - bias);
                        if (q < t) {
                            break;
                        }
                        qMinusT = q - t;
                        baseMinusT = settings.base - t;
                        output.push(settings.stringFromCharCode(settings.digitToBasic(t + qMinusT % baseMinusT, 0)));
                        q = settings.floor(qMinusT / baseMinusT);
                    }
                    output.push(settings.stringFromCharCode(settings.digitToBasic(q, 0)));
                    bias = settings.adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
                    delta = 0;
                    ++handledCPCount;
                }
            }
            ++delta;
            ++n;
        }
        return output.join('');
    }
    /**
* Bias adaptation function as per section 3.4 of RFC 3492.
* http://tools.ietf.org/html/rfc3492#section-3.4
* @private
*/
    static adapt(delta, numPoints, firstTime) {
        var k = 0;
        delta = firstTime ? settings.floor(delta / settings.damp) : delta >> 1;
        delta += settings.floor(delta / numPoints);
        for ( /* no initialization */; delta > settings.baseMinusTMin * settings.tMax >> 1; k += settings.base) {
            delta = settings.floor(delta / settings.baseMinusTMin);
        }
        return settings.floor(k + (settings.baseMinusTMin + 1) * delta / (delta + settings.skew));
    }
    /**
* Creates an array containing the numeric code points of each Unicode
* character in the string. While JavaScript uses UCS-2 internally,
* this function will convert a pair of surrogate halves (each of which
* UCS-2 exposes as separate characters) into a single code point,
* matching UTF-16.
* @see `punycode.ucs2.encode`
* @see <https://mathiasbynens.be/notes/javascript-encoding>
* @memberOf punycode.ucs2
* @name decode
* @param {String} string The Unicode input string (UCS-2).
* @returns {Array} The new array of code points.
*/
    static ucs2decode(string) {
        var output = [], counter = 0, length = string.length, value, extra;
        while (counter < length) {
            value = string.charCodeAt(counter++);
            if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
                // high surrogate, and there is a next character
                extra = string.charCodeAt(counter++);
                if ((extra & 0xFC00) == 0xDC00) { // low surrogate
                    output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
                }
                else {
                    // unmatched surrogate; only append this code unit, in case the next
                    // code unit is the high surrogate of a surrogate pair
                    output.push(value);
                    counter--;
                }
            }
            else {
                output.push(value);
            }
        }
        return output;
    }
    /**
 * Typedef for decomposeDataUri return object.
 *
 * @memberof PIXI.utils
 * @typedef {object} DecomposedDataUri
 * @property {string} mediaType Media type, eg. `image`
 * @property {string} subType Sub type, eg. `png`
 * @property {string} encoding Data encoding, eg. `base64`
 * @property {string} data The actual data
 */
    /**
     * Split a data URI into components. Returns undefined if
     * parameter `dataUri` is not a valid data URI.
     *
     * @memberof PIXI.utils
     * @function decomposeDataUri
     * @param {string} dataUri - the data URI to check
     * @return {PIXI.utils.DecomposedDataUri|undefined} The decomposed data uri or undefined
     */
    static decomposeDataUri(dataUri) {
        var dataUriMatch = settings.DATA_URI.exec(dataUri);
        if (dataUriMatch) {
            return {
                mediaType: dataUriMatch[1] ? dataUriMatch[1].toLowerCase() : undefined,
                subType: dataUriMatch[2] ? dataUriMatch[2].toLowerCase() : undefined,
                charset: dataUriMatch[3] ? dataUriMatch[3].toLowerCase() : undefined,
                encoding: dataUriMatch[4] ? dataUriMatch[4].toLowerCase() : undefined,
                data: dataUriMatch[5],
            };
        }
        return undefined;
    }
}
/**
 * Target frames per millisecond.
 *
 * @static
 * @name TARGET_FPMS
 * @memberof PIXI.settings
 * @type {number}
 * @default 0.06
 */
settings.TARGET_FPMS = 0.06;
/**
 * Default filter resolution.
 *
 * @static
 * @name FILTER_RESOLUTION
 * @memberof PIXI.settings
 * @type {number}
 * @default 1
 */
settings.FILTER_RESOLUTION = 1;
// TODO: maybe change to SPRITE.BATCH_SIZE: 2000
// TODO: maybe add PARTICLE.BATCH_SIZE: 15000
/**
 * The default sprite batch size.
 *
 * The default aims to balance desktop and mobile devices.
 *
 * @static
 * @name SPRITE_BATCH_SIZE
 * @memberof PIXI.settings
 * @type {number}
 * @default 4096
 */
settings.SPRITE_BATCH_SIZE = 4096;
/**
 * Default Garbage Collection mode.
 *
 * @static
 * @name GC_MODE
 * @memberof PIXI.settings
 * @type {PIXI.GC_MODES}
 * @default PIXI.GC_MODES.AUTO
 */
settings.GC_MODE = 0;
/**
 * Default Garbage Collection max idle.
 *
 * @static
 * @name GC_MAX_IDLE
 * @memberof PIXI.settings
 * @type {number}
 * @default 3600
 */
settings.GC_MAX_IDLE = 60 * 60;
/**
 * Default Garbage Collection maximum check count.
 *
 * @static
 * @name GC_MAX_CHECK_COUNT
 * @memberof PIXI.settings
 * @type {number}
 * @default 600
 */
settings.GC_MAX_CHECK_COUNT = 60 * 10;
/**
* The gc modes that are supported by pixi.
*
* The {@link PIXI.settings.GC_MODE} Garbage Collection mode for PixiJS textures is AUTO
* If set to GC_MODE, the renderer will occasionally check textures usage. If they are not
* used for a specified period of time they will be removed from the GPU. They will of course
* be uploaded again when they are required. This is a silent behind the scenes process that
* should ensure that the GPU does not  get filled up.
*
* Handy for mobile devices!
* This property only affects WebGL.
*
* @name GC_MODES
* @enum {number}
* @static
* @memberof PIXI
* @property {number} AUTO - Garbage collection will happen periodically automatically
* @property {number} MANUAL - Garbage collection will need to be called manually
*/
settings.GC_MODES = {
    AUTO: 0,
    MANUAL: 1,
};
/**
 * Constants that specify float precision in shaders.
 *
 * @name PRECISION
 * @memberof PIXI
 * @static
 * @enum {string}
 * @constant
 * @property {string} LOW='lowp'
 * @property {string} MEDIUM='mediump'
 * @property {string} HIGH='highp'
 */
settings.PRECISION = {
    LOW: 'lowp',
    MEDIUM: 'mediump',
    HIGH: 'highp',
};
/**
* Graphics curves resolution settings. If `adaptive` flag is set to `true`,
* the resolution is calculated based on the curve's length to ensure better visual quality.
* Adaptive draw works with `bezierCurveTo` and `quadraticCurveTo`.
*
* @static
* @constant
* @memberof PIXI
* @name GRAPHICS_CURVES
* @type {object}
* @property {boolean} adaptive=false - flag indicating if the resolution should be adaptive
* @property {number} maxLength=10 - maximal length of a single segment of the curve (if adaptive = false, ignored)
* @property {number} minSegments=8 - minimal number of segments in the curve (if adaptive = false, ignored)
* @property {number} maxSegments=2048 - maximal number of segments in the curve (if adaptive = false, ignored)
*/
settings.GRAPHICS_CURVES = {
    adaptive: true,
    maxLength: 10,
    minSegments: 8,
    maxSegments: 2048,
    _segmentsCount: function _segmentsCount(length, defaultSegments = null) {
        if (defaultSegments === void 0) {
            defaultSegments = 20;
        }
        if (!this.adaptive) {
            return defaultSegments;
        }
        var result = Math.ceil(length / this.maxLength);
        if (result < this.minSegments) {
            result = this.minSegments;
        }
        else if (result > this.maxSegments) {
            result = this.maxSegments;
        }
        return result;
    },
};
settings.initialN = 128;
settings.initialBias = 72;
settings.stringFromCharCode = String.fromCharCode;
settings.delimiter = '-';
settings.maxInt = 2147483647;
settings.floor = Math.floor;
settings.base = 36;
settings.tMin = 1;
settings.tMax = 26;
/** Error messages */
settings.errors = {
    'overflow': 'Overflow: input needs wider integers to process',
    'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
    'invalid-input': 'Invalid input'
};
settings.damp = 700;
settings.baseMinusTMin = settings.base - settings.tMin;
settings.skew = 38;
/**
* Regexp for data URI.
* Based on: {@link https://github.com/ragingwind/data-uri-regex}
*
* @static
* @constant {RegExp|string} DATA_URI
* @memberof PIXI
* @example data:image/png;base64
*/
settings.DATA_URI = /^\s*data:(?:([\w-]+)\/([\w+.-]+))?(?:;charset=([\w-]+))?(?:;(base64))?,(.*)/i;
// Taken from the bit-twiddle package
settings.defaultVertex = "attribute vec2 aVertexPosition;\r\nattribute vec2 aTextureCoord;\r\n\r\nuniform mat3 projectionMatrix;\r\n\r\nvarying vec2 vTextureCoord;\r\n\r\nvoid main(void)\r\n{\r\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\r\n    vTextureCoord = aTextureCoord;\r\n}";
settings.defaultFilterVertex = "attribute vec2 aVertexPosition;\r\n\r\nuniform mat3 projectionMatrix;\r\n\r\nvarying vec2 vTextureCoord;\r\n\r\nuniform vec4 inputSize;\r\nuniform vec4 outputFrame;\r\n\r\nvec4 filterVertexPosition( void )\r\n{\r\n    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;\r\n\r\n    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\r\n}\r\n\r\nvec2 filterTextureCoord( void )\r\n{\r\n    return aVertexPosition * (outputFrame.zw * inputSize.zw);\r\n}\r\n\r\nvoid main(void)\r\n{\r\n    gl_Position = filterVertexPosition();\r\n    vTextureCoord = filterTextureCoord();\r\n}\r\n";
exports.settings = settings;


/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9leGFtcGxlcy9BZHZhbmNlZENhcmQuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9leGFtcGxlcy9BZHZhbmNlZFNsb3RzLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvZXhhbXBsZXMvQWR2YW5jZWRUcmFpbC5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL2V4YW1wbGVzL0FkdmFuY2VkV2FycC5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL2V4YW1wbGVzL0Jhc2VFeGFtcGxlLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvZXhhbXBsZXMvQmFzaWNCbGVuZC5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL2V4YW1wbGVzL0Jhc2ljQ29udGFpbmVyLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvZXhhbXBsZXMvQmFzaWNQYXJ0aWNsZXMuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9leGFtcGxlcy9CYXNpY1RpbnRpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9leGFtcGxlcy9GaWx0ZXJCbGVuZGluZy5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL2V4YW1wbGVzL0ZpbHRlckJsdXIuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9leGFtcGxlcy9GaWx0ZXJDb2xvci5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL2V4YW1wbGVzL0ZpbHRlckNyYXdsaWVzLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvZXhhbXBsZXMvRmlsdGVyQ3VzdG9tLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvZXhhbXBsZXMvRmlsdGVyRmxhZy5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL2V4YW1wbGVzL0ZpbHRlclNoYWRvdy5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL2V4YW1wbGVzL0dyYXBoaWNzQWR2YW5jZWQuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9leGFtcGxlcy9HcmFwaGljc0R5bmFtaWMuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9leGFtcGxlcy9HcmFwaGljc1NpbXBsZS5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL2V4YW1wbGVzL0ludGVyYWN0aW9uQ2xpY2suanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9leGFtcGxlcy9JbnRlcmFjdGlvbkRyYWdnaW5nLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvZXhhbXBsZXMvSW50ZXJhY3Rpb25JY29uLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvZXhhbXBsZXMvSW50ZXJhY3Rpb25JbnRlcmFjdGl2aXR5LmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvZXhhbXBsZXMvTWFza0ZpbHRlci5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL2V4YW1wbGVzL01hc2tHcmFwaGljcy5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL2V4YW1wbGVzL01hc2tTcHJpdGUuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9leGFtcGxlcy9NZXNoQWR2YW5jZWQuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9leGFtcGxlcy9NZXNoQmFzaWMuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9leGFtcGxlcy9NZXNoQ29sb3JlZFRyaWFuZ2xlLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvZXhhbXBsZXMvTWVzaEdlb21ldHJ5LmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvZXhhbXBsZXMvTWVzaFNoYWRlci5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL2V4YW1wbGVzL01lc2hUZXh0dXJlZC5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL2V4YW1wbGVzL01lc2hUcmlhbmdsZS5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL2V4YW1wbGVzL01lc2hVbmlmb3Jtcy5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL2V4YW1wbGVzL1Nwcml0ZUJhc2ljLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvZXhhbXBsZXMvU3ByaXRlRXhwbG9zaW9uLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvZXhhbXBsZXMvU3ByaXRlU3BlZWQuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9leGFtcGxlcy9TcHJpdGVTd2FwLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvZXhhbXBsZXMvU3ByaXRlVGlsaW5nLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvZXhhbXBsZXMvU3ByaXRlVmlkZW8uanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9leGFtcGxlcy9TcHJpdGVqZXQuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9leGFtcGxlcy9UZXh0QmFzZS5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL2V4YW1wbGVzL1RleHRCaXRtYXAuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9leGFtcGxlcy9UZXh0V2ViRm9udC5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL2V4YW1wbGVzL1RleHR1cmVBZHZhbmNlZC5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL2V4YW1wbGVzL1RleHR1cmVHcmFkaWVudEJhc2ljLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvZXhhbXBsZXMvVGV4dHVyZUdyYWRpZW50UmVzb3VyY2UuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9leGFtcGxlcy9UZXh0dXJlUmVuZGVyLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvZXhhbXBsZXMvVGV4dHVyZVJvdGF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL2V4YW1wbGVzL2NvbnRyb2xzL0V4YW1wbGVEaXNwbGF5LmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvZXhhbXBsZXMvY29udHJvbHMvRXhhbXBsZUxpc3QuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9mbC1wYWNrYWdlL0J1dHRvbi5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL2ZsYXNoL2dlb20vUG9pbnQuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9mbGFzaC9nZW9tL1JlY3RhbmdsZS5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL2ZsYXNoL2dlb20vVHJhbnNmb3JtLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9BYnN0cmFjdFJlbmRlcmVyLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvQWNjZXNzaWJpbGl0eU1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9BbmltYXRlZFNwcml0ZS5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL0FwcGxpY2F0aW9uLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvQXJjVXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9BcnJheVJlc291cmNlLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvQXR0cmlidXRlLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvQmFzZUltYWdlUmVzb3VyY2UuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9CYXNlUHJlcGFyZS5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL0Jhc2VSZW5kZXJUZXh0dXJlLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvQmFzZVRleHR1cmUuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9CYXRjaEJ1ZmZlci5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL0JhdGNoRHJhd0NhbGwuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9CYXRjaEdlb21ldHJ5LmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvQmF0Y2hSZW5kZXJlci5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL0JhdGNoU3lzdGVtLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvQmV6aWVyVXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9CaXRtYXBUZXh0LmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvQmxlbmRNb2Rlc1NldHRpbmdzLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvQmx1ckZpbHRlci5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL0JsdXJGaWx0ZXJQYXNzLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvQm91bmRzLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvQnVmZmVyLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvQnVmZmVyUmVzb3VyY2UuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9DYWNoZVNldHRpbmdzLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvQ2FudmFzUmVuZGVyVGFyZ2V0LmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvQ2FudmFzUmVzb3VyY2UuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9DYW52YXNTZXR0aW5ncy5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL0NpcmNsZS5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL0NsZWFuVXBTZXR0aW5ncy5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL0NvbG9yTWF0cml4RmlsdGVyLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvQ29sb3JTZXR0aW5ncy5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL0NvbnRhaW5lci5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL0NvbnRleHRTeXN0ZW0uanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9Db3VudExpbWl0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9DdWJlUmVzb3VyY2UuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9EZXB0aFJlc291cmNlLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvRGlzcGxhY2VtZW50RmlsdGVyLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvRGlzcGxheU9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL0Rpc3BsYXlTZXR0aW5ncy5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL0RyYXdNb2RlU2V0dGluZ3MuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9FbGxpcHNlLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvRXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9FdmVudERpc3BhdGNoZXIuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9FeHRyYWN0LmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvRmlsbFN0eWxlLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvRmlsdGVyLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvRmlsdGVyU3RhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9GaWx0ZXJTeXN0ZW0uanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9GbGFzaEJhc2VPYmplY3QuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9Gb250TWFuYWdlci5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL0ZyYW1lYnVmZmVyLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvRnJhbWVidWZmZXJTeXN0ZW0uanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9HTEJ1ZmZlci5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL0dMUHJvZ3JhbS5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL0dMVGV4dHVyZS5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL0dlb21ldHJ5LmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvR2VvbWV0cnlTeXN0ZW0uanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9HcmFwaGljcy5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL0dyYXBoaWNzRGF0YS5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL0dyYXBoaWNzR2VvbWV0cnkuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9Hcm91cEQ4LmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvSU9FcnJvckV2ZW50LmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvSW1hZ2VSZXNvdXJjZS5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL0luc3RhbmNlQ291bnRlci5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL0ludGVyYWN0aW9uRGF0YS5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL0ludGVyYWN0aW9uRXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9JbnRlcmFjdGlvbk1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9JbnRlcmFjdGlvblRyYWNraW5nRGF0YS5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL0xpbmVTdHlsZS5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL0xvZ2dlci5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL01hc2tTeXN0ZW0uanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9NYXRoU2V0dGluZ3MuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9NYXRyaXguanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9NZXNoLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvTWVzaEJhdGNoVXZzLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvTWVzaEdlb21ldHJ5LmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvTWVzaE1hdGVyaWFsLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvTW91c2VFdmVudC5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL05ldHdvcmtTZXR0aW5ncy5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL09iamVjdFJlbmRlcmVyLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvT2JzZXJ2YWJsZVBvaW50LmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvUGFydGljbGVCdWZmZXIuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9QYXJ0aWNsZUNvbnRhaW5lci5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL1BhcnRpY2xlUmVuZGVyZXIuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9Qb2x5Z29uLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvUHJlcGFyZS5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL1Byb2dyYW0uanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9Qcm9ncmVzc0V2ZW50LmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvUHJvamVjdGlvblN5c3RlbS5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL1F1YWQuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9RdWFkVXYuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9RdWFkcmF0aWNVdGlscy5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL1JlbmRlclRleHR1cmUuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9SZW5kZXJUZXh0dXJlU3lzdGVtLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvUmVuZGVyZXIuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9SZXNvdXJjZS5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL1Jlc291cmNlTG9hZGVyLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvUmVzb3VyY2VTZXR0aW5ncy5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL1JvcGVHZW9tZXRyeS5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL1JvdW5kZWRSZWN0YW5nbGUuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9SdW5uZXIuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9TVkdSZXNvdXJjZS5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL1NoYWRlci5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL1NoYWRlclN5c3RlbS5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL1NoYXBlU2V0dGluZ3MuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9TaW1wbGVSb3BlLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvU3ByaXRlLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvU3ByaXRlTWFza0ZpbHRlci5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL1Nwcml0ZXNoZWV0LmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvU3RhZ2VPcHRpb25zLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvU3Rhci5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL1N0YXRlLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvU3RhdGVTeXN0ZW0uanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9TdGVuY2lsU3lzdGVtLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvU3lzdGVtLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvVGV4dC5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL1RleHRNZXRyaWNzLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvVGV4dFNldHRpbmdzLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvVGV4dFN0eWxlLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvVGV4dHVyZS5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL1RleHR1cmVHQ1N5c3RlbS5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL1RleHR1cmVNYXRyaXguanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9UZXh0dXJlU3lzdGVtLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvVGV4dHVyZVV2cy5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL1RpY2tlci5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL1RpY2tlckxpc3RlbmVyLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvVGlsaW5nU3ByaXRlLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvVGlsaW5nU3ByaXRlUmVuZGVyZXIuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9VUkxMb2FkZXIuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9VUkxSZXF1ZXN0LmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvVVJMUmVxdWVzdE1ldGhvZC5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL1VuaWZvcm1Hcm91cC5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL1VybC5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL1V0aWxzU2V0dGluZ3MuanMiLCJ3ZWJwYWNrOi8vLy4vanMtY29tcGlsZS9yYXctcGl4aS10cy9WaWRlb1Jlc291cmNlLmpzIiwid2VicGFjazovLy8uL2pzLWNvbXBpbGUvcmF3LXBpeGktdHMvV2ViR0xTZXR0aW5ncy5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL1hNTFBhcnNlci5qcyIsIndlYnBhY2s6Ly8vLi9qcy1jb21waWxlL3Jhdy1waXhpLXRzL3NldHRpbmdzLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtEQUEwQyxnQ0FBZ0M7QUFDMUU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnRUFBd0Qsa0JBQWtCO0FBQzFFO0FBQ0EseURBQWlELGNBQWM7QUFDL0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUF5QyxpQ0FBaUM7QUFDMUUsd0hBQWdILG1CQUFtQixFQUFFO0FBQ3JJO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDeFFhO0FBQ2Is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QUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZUFBZTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIscUJBQXFCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsMEJBQTBCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsY0FBYztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFdBQVc7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFdBQVc7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFdBQVc7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGNBQWM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxXQUFXO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QiwwQkFBMEI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzFhYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVELGlCQUFpQixtQkFBTyxDQUFDLG9EQUFVO0FBQ25DLGtCQUFrQixtQkFBTyxDQUFDLHNEQUFXO0FBQ3JDLGlCQUFpQixtQkFBTyxDQUFDLG9EQUFVO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsaUNBQWlDO0FBQ3ZGO0FBQ0EsaURBQWlELGtDQUFrQztBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZUFBZTtBQUM5QjtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsZ0JBQWdCLGVBQWU7QUFDL0I7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG1CQUFtQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsZ0JBQWdCLGVBQWU7QUFDL0I7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG1CQUFtQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Es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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixnQkFBZ0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLDJCQUEyQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGdCQUFnQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzFTYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Es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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGVBQWU7QUFDMUIsYUFBYSxlQUFlO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsV0FBVztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZUFBZTtBQUM5QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUU7QUFDdkU7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RTtBQUN2RTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsb0JBQW9CLE9BQU8sa0JBQWtCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxjQUFjO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxjQUFjO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxjQUFjO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsVUFBVTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixnQkFBZ0IsY0FBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQixjQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixnQkFBZ0IsY0FBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZ0JBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixnQkFBZ0IsY0FBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0EsZ0JBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQixjQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGFBQWE7QUFDNUIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLFlBQVk7QUFDM0IsZ0JBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixjQUFj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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHNCQUFzQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFNBQVM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsK0JBQStCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsY0FBYztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixjQUFjO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsUUFBUTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsUUFBUTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGNBQWM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLGFBQWE7QUFDNUIsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsV0FBVztBQUMxQixlQUFlLFdBQVc7QUFDMUIsZ0JBQWdCLFdBQVc7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsV0FBVztBQUMxQixlQUFlLFdBQVc7QUFDMUIsZ0JBQWdCLFdBQVc7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZ0JBQWdCLFlBQVk7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQixZQUFZO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZ0JBQWdCLFlBQVk7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0IsZ0JBQWdCLFlBQVk7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZ0JBQWdCLFlBQVk7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQixnQkFBZ0IsWUFBWTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZUFBZTtBQUM5QixnQkFBZ0IsZUFBZTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixZQUFZO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsWUFBWTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFlBQVk7QUFDNUI7QUFDQTtBQUNBO0FB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O0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsY0FBYztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsbUNBQW1DLEVBQUU7QUFDbEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0Esa0NBQWtDLDhCQUE4QjtBQUNoRTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixRQUFRO0FBQ3hCLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0IseUJBQXlCO0FBQ3pDLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsUUFBUTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxRQUFRO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDaGlCYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVELDBCQUEwQixtQkFBTyxDQUFDLHNFQUFtQjtBQUNyRCxvQkFBb0IsbUJBQU8sQ0FBQyxxRUFBeUI7QUFDckQsZ0JBQWdCLG1CQUFPLENBQUMsNkRBQXFCO0FBQzdDLGdCQUFnQixtQkFBTyxDQUFDLGtEQUFTO0FBQ2pDLHFCQUFxQixtQkFBTyxDQUFDLDREQUFjO0FBQzNDLHNCQUFzQixtQkFBTyxDQUFDLDhEQUFlO0FBQzdDLHdCQUF3QixtQkFBTyxDQUFDLGtFQUFpQjtBQUNqRCx5QkFBeUIsbUJBQU8sQ0FBQyxvRUFBa0I7QUFDbkQsdUJBQXVCLG1CQUFPLENBQUMsZ0VBQWdCO0FBQy9DLHdCQUF3QixtQkFBTyxDQUFDLGtFQUFpQjtBQUNqRCwwQkFBMEIsbUJBQU8sQ0FBQyxzRUFBbUI7QUFDckQsMEJBQTBCLG1CQUFPLENBQUMsc0VBQW1CO0FBQ3JELDBCQUEwQixtQkFBTyxDQUFDLHNFQUFtQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixpQkFBaUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQixxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsRUFBRTtBQUNqQixpQkFBaUIsWUFBWTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsRUFBRTtBQUNqQixlQUFlLE9BQU87QUFDdEIsaUJBQWlCLFlBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsRUFBRTtBQUNqQixlQUFlLE9BQU87QUFDdEIsaUJBQWlCLFlBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHdCQUF3QjtBQUNo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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxRQUFRO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixNQUFNO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGdDQUFnQztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDZCQUE2QjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELE9BQU87QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELE9BQU87QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsT0FBTztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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O0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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LGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWEsY0FBYztBQUMzQjtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBLDJEQUEyRCxzQkFBc0I7QUFDakY7QUFDQSx5REFBeUQsaUNBQWlDLHNDQUFzQyxtQ0FBbUMsNEJBQTRCLHlGQUF5RixzQ0FBc0MsS0FBSztBQUNuVSwrREFBK0Qsc0NBQXNDLG1DQUFtQywrQkFBK0IsNkJBQTZCLDhDQUE4Qyx5RkFBeUYsK0VBQStFLEtBQUssNENBQTRDLGlFQUFpRSxLQUFLLDRCQUE0Qiw2Q0FBNkMsNkNBQTZDLEtBQUs7QUFDNW9CIiwiZmlsZSI6ImluZGV4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZ2V0dGVyIH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XG4gXHRcdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuIFx0XHR9XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gXHR9O1xuXG4gXHQvLyBjcmVhdGUgYSBmYWtlIG5hbWVzcGFjZSBvYmplY3RcbiBcdC8vIG1vZGUgJiAxOiB2YWx1ZSBpcyBhIG1vZHVsZSBpZCwgcmVxdWlyZSBpdFxuIFx0Ly8gbW9kZSAmIDI6IG1lcmdlIGFsbCBwcm9wZXJ0aWVzIG9mIHZhbHVlIGludG8gdGhlIG5zXG4gXHQvLyBtb2RlICYgNDogcmV0dXJuIHZhbHVlIHdoZW4gYWxyZWFkeSBucyBvYmplY3RcbiBcdC8vIG1vZGUgJiA4fDE6IGJlaGF2ZSBsaWtlIHJlcXVpcmVcbiBcdF9fd2VicGFja19yZXF1aXJlX18udCA9IGZ1bmN0aW9uKHZhbHVlLCBtb2RlKSB7XG4gXHRcdGlmKG1vZGUgJiAxKSB2YWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18odmFsdWUpO1xuIFx0XHRpZihtb2RlICYgOCkgcmV0dXJuIHZhbHVlO1xuIFx0XHRpZigobW9kZSAmIDQpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgJiYgdmFsdWUuX19lc01vZHVsZSkgcmV0dXJuIHZhbHVlO1xuIFx0XHR2YXIgbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIobnMpO1xuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobnMsICdkZWZhdWx0JywgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdmFsdWUgfSk7XG4gXHRcdGlmKG1vZGUgJiAyICYmIHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykgZm9yKHZhciBrZXkgaW4gdmFsdWUpIF9fd2VicGFja19yZXF1aXJlX18uZChucywga2V5LCBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIHZhbHVlW2tleV07IH0uYmluZChudWxsLCBrZXkpKTtcbiBcdFx0cmV0dXJuIG5zO1xuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IFwiLi9qcy1jb21waWxlL2luZGV4LmpzXCIpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBCYXNlRXhhbXBsZV8xID0gcmVxdWlyZShcIi4vQmFzZUV4YW1wbGVcIik7XG5jb25zdCBSZXNvdXJjZUxvYWRlcl8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1Jlc291cmNlTG9hZGVyXCIpO1xuY29uc3QgVVJMUmVxdWVzdF8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1VSTFJlcXVlc3RcIik7XG5jb25zdCBFdmVudF8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0V2ZW50XCIpO1xuY29uc3QgVGV4dHVyZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1RleHR1cmVcIik7XG5jb25zdCBCYXNlVGV4dHVyZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0Jhc2VUZXh0dXJlXCIpO1xuY29uc3QgR3JhcGhpY3NfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9HcmFwaGljc1wiKTtcbmNvbnN0IFNwcml0ZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1Nwcml0ZVwiKTtcbmNvbnN0IFJlbmRlclRleHR1cmVfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9SZW5kZXJUZXh0dXJlXCIpO1xuY29uc3QgTW91c2VFdmVudF8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL01vdXNlRXZlbnRcIik7XG5jbGFzcyBBZHZhbmNlZENhcmQgZXh0ZW5kcyBCYXNlRXhhbXBsZV8xLkJhc2VFeGFtcGxlIHtcbiAgICBjb25zdHJ1Y3RvcihhcHAsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgc3VwZXIoYXBwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgdGhpcy5oYW5kbGVSb3RhdGVMb2FkZWQgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIHRoaXMucm90YXRldHh0ID0gbmV3IFRleHR1cmVfMS5UZXh0dXJlKG5ldyBCYXNlVGV4dHVyZV8xLkJhc2VUZXh0dXJlKHRoaXMubG9hZGVyLmltYWdlRGF0YSkpO1xuICAgICAgICAgICAgdGhpcy5icnVzaCA9IG5ldyBHcmFwaGljc18xLkdyYXBoaWNzKCk7XG4gICAgICAgICAgICB0aGlzLmJydXNoLmJlZ2luRmlsbCgweGZmZmZmZik7XG4gICAgICAgICAgICB0aGlzLmJydXNoLmRyYXdDaXJjbGUoMCwgMCwgNTApO1xuICAgICAgICAgICAgdGhpcy5icnVzaC5lbmRGaWxsKCk7XG4gICAgICAgICAgICBjb25zdCBiYWNrZ3JvdW5kID0gbmV3IFNwcml0ZV8xLlNwcml0ZSh0aGlzLmdyYXNzdHh0KTtcbiAgICAgICAgICAgIHRoaXMuc3RhZ2UuYWRkQ2hpbGQoYmFja2dyb3VuZCk7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kLndpZHRoID0gdGhpcy5zaXpldztcbiAgICAgICAgICAgIGJhY2tncm91bmQuaGVpZ2h0ID0gdGhpcy5zaXplaDtcbiAgICAgICAgICAgIGNvbnN0IGltYWdlVG9SZXZlYWwgPSBuZXcgU3ByaXRlXzEuU3ByaXRlKHRoaXMucm90YXRldHh0KTtcbiAgICAgICAgICAgIHRoaXMuc3RhZ2UuYWRkQ2hpbGQoaW1hZ2VUb1JldmVhbCk7XG4gICAgICAgICAgICBpbWFnZVRvUmV2ZWFsLndpZHRoID0gdGhpcy5zaXpldztcbiAgICAgICAgICAgIGltYWdlVG9SZXZlYWwuaGVpZ2h0ID0gdGhpcy5zaXplaDtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyVGV4dHVyZSA9IFJlbmRlclRleHR1cmVfMS5SZW5kZXJUZXh0dXJlLmNyZWF0ZSh0aGlzLnNpemV3LCB0aGlzLnNpemVoKTtcbiAgICAgICAgICAgIGNvbnN0IHJlbmRlclRleHR1cmVTcHJpdGUgPSBuZXcgU3ByaXRlXzEuU3ByaXRlKHRoaXMucmVuZGVyVGV4dHVyZSk7XG4gICAgICAgICAgICB0aGlzLnN0YWdlLmFkZENoaWxkKHJlbmRlclRleHR1cmVTcHJpdGUpO1xuICAgICAgICAgICAgaW1hZ2VUb1JldmVhbC5tYXNrID0gcmVuZGVyVGV4dHVyZVNwcml0ZTtcbiAgICAgICAgICAgIHRoaXMuc3RhZ2UuaW50ZXJhY3RpdmUgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5kcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5zdGFnZS5hZGRFdmVudExpc3RlbmVyKE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50LlBPSU5URVJfRE9XTiwgdGhpcy5wb2ludGVyRG93bik7XG4gICAgICAgICAgICB0aGlzLnN0YWdlLmFkZEV2ZW50TGlzdGVuZXIoTW91c2VFdmVudF8xLk1vdXNlRXZlbnQuUE9JTlRFUl9VUCwgdGhpcy5wb2ludGVyVXApO1xuICAgICAgICAgICAgdGhpcy5zdGFnZS5hZGRFdmVudExpc3RlbmVyKE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50LlBPSU5URVJfTU9WRSwgdGhpcy5wb2ludGVyTW92ZSk7XG4gICAgICAgICAgICB0aGlzLmV4YW1wbGVSZWFkeSgpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnBvaW50ZXJNb3ZlID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5kcmFnZ2luZykge1xuICAgICAgICAgICAgICAgIHRoaXMuYnJ1c2gucG9zaXRpb24uY29weUZyb20oZXZlbnQuZGF0YS5nbG9iYWwpO1xuICAgICAgICAgICAgICAgIHRoaXMuYXBwLnJlbmRlcmVyLnJlbmRlcih0aGlzLmJydXNoLCB0aGlzLnJlbmRlclRleHR1cmUsIGZhbHNlLCBudWxsLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucG9pbnRlckRvd24gPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZHJhZ2dpbmcgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5wb2ludGVyTW92ZShldmVudCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucG9pbnRlclVwID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICB0aGlzLmRyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlR3Jhc3NMb2FkZWQgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZ3Jhc3N0eHQgPSBuZXcgVGV4dHVyZV8xLlRleHR1cmUobmV3IEJhc2VUZXh0dXJlXzEuQmFzZVRleHR1cmUodGhpcy5sb2FkZXIuaW1hZ2VEYXRhKSk7XG4gICAgICAgICAgICB0aGlzLmxvYWRlciA9IG5ldyBSZXNvdXJjZUxvYWRlcl8xLlJlc291cmNlTG9hZGVyKG5ldyBVUkxSZXF1ZXN0XzEuVVJMUmVxdWVzdChcImV4YW1wbGVzL2Fzc2V0cy9iZ19yb3RhdGUuanBnXCIpKTtcbiAgICAgICAgICAgIHRoaXMubG9hZGVyLmFkZEV2ZW50TGlzdGVuZXIoRXZlbnRfMS5FdmVudC5DT01QTEVURSwgdGhpcy5oYW5kbGVSb3RhdGVMb2FkZWQpO1xuICAgICAgICAgICAgdGhpcy5sb2FkZXIubG9hZCgpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmxvYWRlciA9IG5ldyBSZXNvdXJjZUxvYWRlcl8xLlJlc291cmNlTG9hZGVyKG5ldyBVUkxSZXF1ZXN0XzEuVVJMUmVxdWVzdChcImV4YW1wbGVzL2Fzc2V0cy9iZ19ncmFzcy5qcGdcIikpO1xuICAgICAgICB0aGlzLmxvYWRlci5hZGRFdmVudExpc3RlbmVyKEV2ZW50XzEuRXZlbnQuQ09NUExFVEUsIHRoaXMuaGFuZGxlR3Jhc3NMb2FkZWQpO1xuICAgICAgICB0aGlzLmxvYWRlci5sb2FkKCk7XG4gICAgfVxuICAgIGRlc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuc3RhZ2UucmVtb3ZlRXZlbnRMaXN0ZW5lcihNb3VzZUV2ZW50XzEuTW91c2VFdmVudC5QT0lOVEVSX0RPV04sIHRoaXMucG9pbnRlckRvd24pO1xuICAgICAgICB0aGlzLnN0YWdlLnJlbW92ZUV2ZW50TGlzdGVuZXIoTW91c2VFdmVudF8xLk1vdXNlRXZlbnQuUE9JTlRFUl9VUCwgdGhpcy5wb2ludGVyVXApO1xuICAgICAgICB0aGlzLnN0YWdlLnJlbW92ZUV2ZW50TGlzdGVuZXIoTW91c2VFdmVudF8xLk1vdXNlRXZlbnQuUE9JTlRFUl9NT1ZFLCB0aGlzLnBvaW50ZXJNb3ZlKTtcbiAgICAgICAgc3VwZXIuZGVzdHJ1Y3RvcigpO1xuICAgICAgICB0aGlzLmJydXNoLmRlc3Ryb3kobnVsbCk7XG4gICAgICAgIHRoaXMuZ3Jhc3N0eHQuZGVzdHJveShudWxsKTtcbiAgICB9XG59XG5leHBvcnRzLkFkdmFuY2VkQ2FyZCA9IEFkdmFuY2VkQ2FyZDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgQmFzZUV4YW1wbGVfMSA9IHJlcXVpcmUoXCIuL0Jhc2VFeGFtcGxlXCIpO1xuY29uc3QgUmVzb3VyY2VMb2FkZXJfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9SZXNvdXJjZUxvYWRlclwiKTtcbmNvbnN0IFVSTFJlcXVlc3RfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9VUkxSZXF1ZXN0XCIpO1xuY29uc3QgRXZlbnRfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9FdmVudFwiKTtcbmNvbnN0IFRleHR1cmVfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9UZXh0dXJlXCIpO1xuY29uc3QgQmFzZVRleHR1cmVfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9CYXNlVGV4dHVyZVwiKTtcbmNvbnN0IENvbnRhaW5lcl8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0NvbnRhaW5lclwiKTtcbmNvbnN0IEJsdXJGaWx0ZXJfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9CbHVyRmlsdGVyXCIpO1xuY29uc3QgU3ByaXRlXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvU3ByaXRlXCIpO1xuY29uc3QgR3JhcGhpY3NfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9HcmFwaGljc1wiKTtcbmNvbnN0IFRleHRTdHlsZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1RleHRTdHlsZVwiKTtcbmNvbnN0IFRleHRfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9UZXh0XCIpO1xuY29uc3QgTW91c2VFdmVudF8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL01vdXNlRXZlbnRcIik7XG5jbGFzcyBBZHZhbmNlZFNsb3RzIGV4dGVuZHMgQmFzZUV4YW1wbGVfMS5CYXNlRXhhbXBsZSB7XG4gICAgY29uc3RydWN0b3IoYXBwLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHN1cGVyKGFwcCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIHRoaXMuaGFuZGxlRWdnTG9hZGVkID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICB0aGlzLmVnZ1R4dCA9IG5ldyBUZXh0dXJlXzEuVGV4dHVyZShuZXcgQmFzZVRleHR1cmVfMS5CYXNlVGV4dHVyZSh0aGlzLmxvYWRlci5pbWFnZURhdGEpKTtcbiAgICAgICAgICAgIHRoaXMubG9hZGVyID0gbmV3IFJlc291cmNlTG9hZGVyXzEuUmVzb3VyY2VMb2FkZXIobmV3IFVSTFJlcXVlc3RfMS5VUkxSZXF1ZXN0KFwiZXhhbXBsZXMvYXNzZXRzL2Zsb3dlclRvcC5wbmdcIikpO1xuICAgICAgICAgICAgdGhpcy5sb2FkZXIuYWRkRXZlbnRMaXN0ZW5lcihFdmVudF8xLkV2ZW50LkNPTVBMRVRFLCB0aGlzLmhhbmRsZUZsb3dlckxvYWRlZCk7XG4gICAgICAgICAgICB0aGlzLmxvYWRlci5sb2FkKCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlRmxvd2VyTG9hZGVkID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICB0aGlzLmZsb3dlclR4dCA9IG5ldyBUZXh0dXJlXzEuVGV4dHVyZShuZXcgQmFzZVRleHR1cmVfMS5CYXNlVGV4dHVyZSh0aGlzLmxvYWRlci5pbWFnZURhdGEpKTtcbiAgICAgICAgICAgIHRoaXMubG9hZGVyID0gbmV3IFJlc291cmNlTG9hZGVyXzEuUmVzb3VyY2VMb2FkZXIobmV3IFVSTFJlcXVlc3RfMS5VUkxSZXF1ZXN0KFwiZXhhbXBsZXMvYXNzZXRzL2hlbG1sb2sucG5nXCIpKTtcbiAgICAgICAgICAgIHRoaXMubG9hZGVyLmFkZEV2ZW50TGlzdGVuZXIoRXZlbnRfMS5FdmVudC5DT01QTEVURSwgdGhpcy5oYW5kbGVIZWxtTG9hZGVkKTtcbiAgICAgICAgICAgIHRoaXMubG9hZGVyLmxvYWQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVIZWxtTG9hZGVkID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICB0aGlzLmhlbG1UeHQgPSBuZXcgVGV4dHVyZV8xLlRleHR1cmUobmV3IEJhc2VUZXh0dXJlXzEuQmFzZVRleHR1cmUodGhpcy5sb2FkZXIuaW1hZ2VEYXRhKSk7XG4gICAgICAgICAgICB0aGlzLmxvYWRlciA9IG5ldyBSZXNvdXJjZUxvYWRlcl8xLlJlc291cmNlTG9hZGVyKG5ldyBVUkxSZXF1ZXN0XzEuVVJMUmVxdWVzdChcImV4YW1wbGVzL2Fzc2V0cy9za3VsbHkucG5nXCIpKTtcbiAgICAgICAgICAgIHRoaXMubG9hZGVyLmFkZEV2ZW50TGlzdGVuZXIoRXZlbnRfMS5FdmVudC5DT01QTEVURSwgdGhpcy5oYW5kbGVTa3VsbExvYWRlZCk7XG4gICAgICAgICAgICB0aGlzLmxvYWRlci5sb2FkKCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlU2t1bGxMb2FkZWQgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc2t1bGxUeHQgPSBuZXcgVGV4dHVyZV8xLlRleHR1cmUobmV3IEJhc2VUZXh0dXJlXzEuQmFzZVRleHR1cmUodGhpcy5sb2FkZXIuaW1hZ2VEYXRhKSk7XG4gICAgICAgICAgICBjb25zdCBSRUVMX1dJRFRIID0gMTYwO1xuICAgICAgICAgICAgdGhpcy5TWU1CT0xfU0laRSA9IDE1MDtcbiAgICAgICAgICAgIHRoaXMuc2xvdFRleHR1cmVzID0gW1xuICAgICAgICAgICAgICAgIHRoaXMuZWdnVHh0LFxuICAgICAgICAgICAgICAgIHRoaXMuZmxvd2VyVHh0LFxuICAgICAgICAgICAgICAgIHRoaXMuaGVsbVR4dCxcbiAgICAgICAgICAgICAgICB0aGlzLnNrdWxsVHh0LFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIHRoaXMucmVlbHMgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IHJlZWxDb250YWluZXIgPSBuZXcgQ29udGFpbmVyXzEuQ29udGFpbmVyKCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDU7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJjID0gbmV3IENvbnRhaW5lcl8xLkNvbnRhaW5lcigpO1xuICAgICAgICAgICAgICAgIHJjLnggPSBpICogUkVFTF9XSURUSDtcbiAgICAgICAgICAgICAgICByZWVsQ29udGFpbmVyLmFkZENoaWxkKHJjKTtcbiAgICAgICAgICAgICAgICBjb25zdCByZWVsID0ge1xuICAgICAgICAgICAgICAgICAgICBjb250YWluZXI6IHJjLFxuICAgICAgICAgICAgICAgICAgICBzeW1ib2xzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IDAsXG4gICAgICAgICAgICAgICAgICAgIHByZXZpb3VzUG9zaXRpb246IDAsXG4gICAgICAgICAgICAgICAgICAgIGJsdXI6IG5ldyBCbHVyRmlsdGVyXzEuQmx1ckZpbHRlcigpLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmVlbC5ibHVyLmJsdXJYID0gMDtcbiAgICAgICAgICAgICAgICByZWVsLmJsdXIuYmx1clkgPSAwO1xuICAgICAgICAgICAgICAgIHJjLmZpbHRlcnMgPSBbcmVlbC5ibHVyXTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IDQ7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzeW1ib2wgPSBuZXcgU3ByaXRlXzEuU3ByaXRlKHRoaXMuc2xvdFRleHR1cmVzW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIHRoaXMuc2xvdFRleHR1cmVzLmxlbmd0aCldKTtcbiAgICAgICAgICAgICAgICAgICAgc3ltYm9sLnkgPSBqICogdGhpcy5TWU1CT0xfU0laRTtcbiAgICAgICAgICAgICAgICAgICAgc3ltYm9sLnNjYWxlLnggPSBzeW1ib2wuc2NhbGUueSA9IE1hdGgubWluKHRoaXMuU1lNQk9MX1NJWkUgLyBzeW1ib2wud2lkdGgsIHRoaXMuU1lNQk9MX1NJWkUgLyBzeW1ib2wuaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgc3ltYm9sLnggPSBNYXRoLnJvdW5kKCh0aGlzLlNZTUJPTF9TSVpFIC0gc3ltYm9sLndpZHRoKSAvIDIpO1xuICAgICAgICAgICAgICAgICAgICByZWVsLnN5bWJvbHMucHVzaChzeW1ib2wpO1xuICAgICAgICAgICAgICAgICAgICByYy5hZGRDaGlsZChzeW1ib2wpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnJlZWxzLnB1c2gocmVlbCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFnZS5hZGRDaGlsZChyZWVsQ29udGFpbmVyKTtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXJnaW4gPSAodGhpcy5zaXplaCAtIHRoaXMuU1lNQk9MX1NJWkUgKiAzKSAvIDI7XG4gICAgICAgICAgICAgICAgcmVlbENvbnRhaW5lci55ID0gbWFyZ2luO1xuICAgICAgICAgICAgICAgIHJlZWxDb250YWluZXIueCA9IE1hdGgucm91bmQodGhpcy5zaXpldyAtIFJFRUxfV0lEVEggKiA1KTtcbiAgICAgICAgICAgICAgICBjb25zdCB0b3AgPSBuZXcgR3JhcGhpY3NfMS5HcmFwaGljcygpO1xuICAgICAgICAgICAgICAgIHRvcC5iZWdpbkZpbGwoMCwgMSk7XG4gICAgICAgICAgICAgICAgdG9wLmRyYXdSZWN0KDAsIDAsIHRoaXMuc2l6ZXcsIG1hcmdpbik7XG4gICAgICAgICAgICAgICAgY29uc3QgYm90dG9tID0gbmV3IEdyYXBoaWNzXzEuR3JhcGhpY3MoKTtcbiAgICAgICAgICAgICAgICBib3R0b20uYmVnaW5GaWxsKDAsIDEpO1xuICAgICAgICAgICAgICAgIGJvdHRvbS5kcmF3UmVjdCgwLCB0aGlzLlNZTUJPTF9TSVpFICogMyArIG1hcmdpbiwgdGhpcy5zaXpldywgbWFyZ2luKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzdHlsZSA9IG5ldyBUZXh0U3R5bGVfMS5UZXh0U3R5bGUoe1xuICAgICAgICAgICAgICAgICAgICBmb250RmFtaWx5OiAnQXJpYWwnLFxuICAgICAgICAgICAgICAgICAgICBmb250U2l6ZTogMzYsXG4gICAgICAgICAgICAgICAgICAgIGZvbnRTdHlsZTogJ2l0YWxpYycsXG4gICAgICAgICAgICAgICAgICAgIGZvbnRXZWlnaHQ6ICdib2xkJyxcbiAgICAgICAgICAgICAgICAgICAgZmlsbDogWycjZmZmZmZmJywgJyMwMGZmOTknXSxcbiAgICAgICAgICAgICAgICAgICAgc3Ryb2tlOiAnIzRhMTg1MCcsXG4gICAgICAgICAgICAgICAgICAgIHN0cm9rZVRoaWNrbmVzczogNSxcbiAgICAgICAgICAgICAgICAgICAgZHJvcFNoYWRvdzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZHJvcFNoYWRvd0NvbG9yOiAnIzAwMDAwMCcsXG4gICAgICAgICAgICAgICAgICAgIGRyb3BTaGFkb3dCbHVyOiA0LFxuICAgICAgICAgICAgICAgICAgICBkcm9wU2hhZG93QW5nbGU6IE1hdGguUEkgLyA2LFxuICAgICAgICAgICAgICAgICAgICBkcm9wU2hhZG93RGlzdGFuY2U6IDYsXG4gICAgICAgICAgICAgICAgICAgIHdvcmRXcmFwOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB3b3JkV3JhcFdpZHRoOiA0NDAsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcGxheVRleHQgPSBuZXcgVGV4dF8xLlRleHQoJ1NwaW4gdGhlIHdoZWVscyEnLCBzdHlsZSk7XG4gICAgICAgICAgICAgICAgcGxheVRleHQueCA9IE1hdGgucm91bmQoKGJvdHRvbS53aWR0aCAtIHBsYXlUZXh0LndpZHRoKSAvIDIpO1xuICAgICAgICAgICAgICAgIHBsYXlUZXh0LnkgPSB0aGlzLnNpemVoIC0gbWFyZ2luICsgTWF0aC5yb3VuZCgobWFyZ2luIC0gcGxheVRleHQuaGVpZ2h0KSAvIDIpO1xuICAgICAgICAgICAgICAgIGJvdHRvbS5hZGRDaGlsZChwbGF5VGV4dCk7XG4gICAgICAgICAgICAgICAgY29uc3QgaGVhZGVyVGV4dCA9IG5ldyBUZXh0XzEuVGV4dCgnUElYSSBNT05TVEVSIFNMT1RTIScsIHN0eWxlKTtcbiAgICAgICAgICAgICAgICBoZWFkZXJUZXh0LnggPSBNYXRoLnJvdW5kKCh0b3Aud2lkdGggLSBoZWFkZXJUZXh0LndpZHRoKSAvIDIpO1xuICAgICAgICAgICAgICAgIGhlYWRlclRleHQueSA9IE1hdGgucm91bmQoKG1hcmdpbiAtIGhlYWRlclRleHQuaGVpZ2h0KSAvIDIpO1xuICAgICAgICAgICAgICAgIHRvcC5hZGRDaGlsZChoZWFkZXJUZXh0KTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YWdlLmFkZENoaWxkKHRvcCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFnZS5hZGRDaGlsZChib3R0b20pO1xuICAgICAgICAgICAgICAgIGJvdHRvbS5pbnRlcmFjdGl2ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgYm90dG9tLmJ1dHRvbk1vZGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJvdHRvbS5hZGRFdmVudExpc3RlbmVyKE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50LlBPSU5URVJfRE9XTiwgdGhpcy5zdGFydFBsYXkpO1xuICAgICAgICAgICAgICAgIHRoaXMucnVubmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5hcHAudGlja2VyLmFkZCh0aGlzLnJ1bkV4YW1wbGUpO1xuICAgICAgICAgICAgdGhpcy5hcHAudGlja2VyLmFkZCh0aGlzLnR3ZWVuKTtcbiAgICAgICAgICAgIHRoaXMuZXhhbXBsZVJlYWR5KCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc3RhcnRQbGF5ID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMucnVubmluZylcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB0aGlzLnJ1bm5pbmcgPSB0cnVlO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnJlZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgciA9IHRoaXMucmVlbHNbaV07XG4gICAgICAgICAgICAgICAgY29uc3QgZXh0cmEgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAzKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXQgPSByLnBvc2l0aW9uICsgMTAgKyBpICogNSArIGV4dHJhO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRpbWUgPSAyNTAwICsgaSAqIDYwMCArIGV4dHJhICogNjAwO1xuICAgICAgICAgICAgICAgIHRoaXMudHdlZW5UbyhyLCAncG9zaXRpb24nLCB0YXJnZXQsIHRpbWUsIHRoaXMuYmFja291dCgwLjUpLCBudWxsLCBpID09PSB0aGlzLnJlZWxzLmxlbmd0aCAtIDEgPyB0aGlzLnJlZWxzQ29tcGxldGUgOiBudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5yZWVsc0NvbXBsZXRlID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5ydW5uaW5nID0gZmFsc2U7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucnVuRXhhbXBsZSA9IChkZWx0YSkgPT4ge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnJlZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgciA9IHRoaXMucmVlbHNbaV07XG4gICAgICAgICAgICAgICAgci5ibHVyLmJsdXJZID0gKHIucG9zaXRpb24gLSByLnByZXZpb3VzUG9zaXRpb24pICogODtcbiAgICAgICAgICAgICAgICByLnByZXZpb3VzUG9zaXRpb24gPSByLnBvc2l0aW9uO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgci5zeW1ib2xzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHMgPSByLnN5bWJvbHNbal07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByZXZ5ID0gcy55O1xuICAgICAgICAgICAgICAgICAgICBzLnkgPSAoKHIucG9zaXRpb24gKyBqKSAlIHIuc3ltYm9scy5sZW5ndGgpICogdGhpcy5TWU1CT0xfU0laRSAtIHRoaXMuU1lNQk9MX1NJWkU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzLnkgPCAwICYmIHByZXZ5ID4gdGhpcy5TWU1CT0xfU0laRSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcy50ZXh0dXJlID0gdGhpcy5zbG90VGV4dHVyZXNbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogdGhpcy5zbG90VGV4dHVyZXMubGVuZ3RoKV07XG4gICAgICAgICAgICAgICAgICAgICAgICBzLnNjYWxlLnggPSBzLnNjYWxlLnkgPSBNYXRoLm1pbih0aGlzLlNZTUJPTF9TSVpFIC8gcy50ZXh0dXJlLndpZHRoLCB0aGlzLlNZTUJPTF9TSVpFIC8gcy50ZXh0dXJlLmhlaWdodCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzLnggPSBNYXRoLnJvdW5kKCh0aGlzLlNZTUJPTF9TSVpFIC0gcy53aWR0aCkgLyAyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy50d2VlbiA9IChkZWx0YSkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgIGNvbnN0IHJlbW92ZSA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnR3ZWVuaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdCA9IHRoaXMudHdlZW5pbmdbaV07XG4gICAgICAgICAgICAgICAgY29uc3QgcGhhc2UgPSBNYXRoLm1pbigxLCAobm93IC0gdC5zdGFydCkgLyB0LnRpbWUpO1xuICAgICAgICAgICAgICAgIHQub2JqZWN0W3QucHJvcGVydHldID0gdGhpcy5sZXJwKHQucHJvcGVydHlCZWdpblZhbHVlLCB0LnRhcmdldCwgdC5lYXNpbmcocGhhc2UpKTtcbiAgICAgICAgICAgICAgICBpZiAodC5jaGFuZ2UpXG4gICAgICAgICAgICAgICAgICAgIHQuY2hhbmdlKHQpO1xuICAgICAgICAgICAgICAgIGlmIChwaGFzZSA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICB0Lm9iamVjdFt0LnByb3BlcnR5XSA9IHQudGFyZ2V0O1xuICAgICAgICAgICAgICAgICAgICBpZiAodC5jb21wbGV0ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHQuY29tcGxldGUodCk7XG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZS5wdXNoKHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVtb3ZlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50d2VlbmluZy5zcGxpY2UodGhpcy50d2VlbmluZy5pbmRleE9mKHJlbW92ZVtpXSksIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnR3ZWVuaW5nID0gW107XG4gICAgICAgIHRoaXMubG9hZGVyID0gbmV3IFJlc291cmNlTG9hZGVyXzEuUmVzb3VyY2VMb2FkZXIobmV3IFVSTFJlcXVlc3RfMS5VUkxSZXF1ZXN0KFwiZXhhbXBsZXMvYXNzZXRzL2VnZ0hlYWQucG5nXCIpKTtcbiAgICAgICAgdGhpcy5sb2FkZXIuYWRkRXZlbnRMaXN0ZW5lcihFdmVudF8xLkV2ZW50LkNPTVBMRVRFLCB0aGlzLmhhbmRsZUVnZ0xvYWRlZCk7XG4gICAgICAgIHRoaXMubG9hZGVyLmxvYWQoKTtcbiAgICB9XG4gICAgdHdlZW5UbyhvYmplY3QsIHByb3BlcnR5LCB0YXJnZXQsIHRpbWUsIGVhc2luZywgb25jaGFuZ2UsIG9uY29tcGxldGUpIHtcbiAgICAgICAgY29uc3QgdHdlZW4gPSB7XG4gICAgICAgICAgICBvYmplY3QsXG4gICAgICAgICAgICBwcm9wZXJ0eSxcbiAgICAgICAgICAgIHByb3BlcnR5QmVnaW5WYWx1ZTogb2JqZWN0W3Byb3BlcnR5XSxcbiAgICAgICAgICAgIHRhcmdldCxcbiAgICAgICAgICAgIGVhc2luZyxcbiAgICAgICAgICAgIHRpbWUsXG4gICAgICAgICAgICBjaGFuZ2U6IG9uY2hhbmdlLFxuICAgICAgICAgICAgY29tcGxldGU6IG9uY29tcGxldGUsXG4gICAgICAgICAgICBzdGFydDogRGF0ZS5ub3coKSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy50d2VlbmluZy5wdXNoKHR3ZWVuKTtcbiAgICAgICAgcmV0dXJuIHR3ZWVuO1xuICAgIH1cbiAgICBsZXJwKGExLCBhMiwgdCkge1xuICAgICAgICByZXR1cm4gYTEgKiAoMSAtIHQpICsgYTIgKiB0O1xuICAgIH1cbiAgICBiYWNrb3V0KGFtb3VudCkge1xuICAgICAgICByZXR1cm4gdCA9PiAoLS10ICogdCAqICgoYW1vdW50ICsgMSkgKiB0ICsgYW1vdW50KSArIDEpO1xuICAgIH1cbiAgICBkZXN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlci5kZXN0cnVjdG9yKCk7XG4gICAgICAgIHRoaXMuYXBwLnRpY2tlci5yZW1vdmUodGhpcy5ydW5FeGFtcGxlLCBudWxsKTtcbiAgICAgICAgdGhpcy5hcHAudGlja2VyLnJlbW92ZSh0aGlzLnR3ZWVuLCBudWxsKTtcbiAgICAgICAgdGhpcy5lZ2dUeHQuZGVzdHJveShudWxsKTtcbiAgICAgICAgdGhpcy5mbG93ZXJUeHQuZGVzdHJveShudWxsKTtcbiAgICAgICAgdGhpcy5oZWxtVHh0LmRlc3Ryb3kobnVsbCk7XG4gICAgICAgIHRoaXMuc2t1bGxUeHQuZGVzdHJveShudWxsKTtcbiAgICAgICAgdGhpcy5zbG90VGV4dHVyZXMgPSBudWxsO1xuICAgICAgICB0aGlzLnR3ZWVuaW5nID0gbnVsbDtcbiAgICB9XG59XG5leHBvcnRzLkFkdmFuY2VkU2xvdHMgPSBBZHZhbmNlZFNsb3RzO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBCYXNlRXhhbXBsZV8xID0gcmVxdWlyZShcIi4vQmFzZUV4YW1wbGVcIik7XG5jb25zdCBSZXNvdXJjZUxvYWRlcl8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1Jlc291cmNlTG9hZGVyXCIpO1xuY29uc3QgVVJMUmVxdWVzdF8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1VSTFJlcXVlc3RcIik7XG5jb25zdCBFdmVudF8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0V2ZW50XCIpO1xuY29uc3QgVGV4dHVyZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1RleHR1cmVcIik7XG5jb25zdCBCYXNlVGV4dHVyZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0Jhc2VUZXh0dXJlXCIpO1xuY29uc3QgUG9pbnRfMSA9IHJlcXVpcmUoXCIuLi9mbGFzaC9nZW9tL1BvaW50XCIpO1xuY29uc3QgU2ltcGxlUm9wZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1NpbXBsZVJvcGVcIik7XG5jb25zdCBCbGVuZE1vZGVzU2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9CbGVuZE1vZGVzU2V0dGluZ3NcIik7XG5jbGFzcyBBZHZhbmNlZFRyYWlsIGV4dGVuZHMgQmFzZUV4YW1wbGVfMS5CYXNlRXhhbXBsZSB7XG4gICAgY29uc3RydWN0b3IoYXBwLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHN1cGVyKGFwcCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIHRoaXMuaGFuZGxlR3Jhc3NMb2FkZWQgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIHRoaXMudHJhaWxUZXh0dXJlID0gbmV3IFRleHR1cmVfMS5UZXh0dXJlKG5ldyBCYXNlVGV4dHVyZV8xLkJhc2VUZXh0dXJlKHRoaXMubG9hZGVyLmltYWdlRGF0YSkpO1xuICAgICAgICAgICAgdGhpcy5oaXN0b3J5WCA9IFtdO1xuICAgICAgICAgICAgdGhpcy5oaXN0b3J5WSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5oaXN0b3J5U2l6ZSA9IDIwO1xuICAgICAgICAgICAgdGhpcy5yb3BlU2l6ZSA9IDEwMDtcbiAgICAgICAgICAgIHRoaXMucG9pbnRzID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuaGlzdG9yeVNpemU7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMuaGlzdG9yeVgucHVzaCgwKTtcbiAgICAgICAgICAgICAgICB0aGlzLmhpc3RvcnlZLnB1c2goMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucm9wZVNpemU7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMucG9pbnRzLnB1c2goUG9pbnRfMS5Qb2ludC5nZXRQb2ludCgwLCAwKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByb3BlID0gbmV3IFNpbXBsZVJvcGVfMS5TaW1wbGVSb3BlKHRoaXMudHJhaWxUZXh0dXJlLCB0aGlzLnBvaW50cyk7XG4gICAgICAgICAgICByb3BlLmJsZW5kTW9kZSA9IEJsZW5kTW9kZXNTZXR0aW5nc18xLkJsZW5kTW9kZXNTZXR0aW5ncy5CTEVORF9NT0RFUy5BREQ7XG4gICAgICAgICAgICB0aGlzLnN0YWdlLmFkZENoaWxkKHJvcGUpO1xuICAgICAgICAgICAgdGhpcy5hcHAudGlja2VyLmFkZCh0aGlzLnJ1bkV4YW1wbGUpO1xuICAgICAgICAgICAgdGhpcy5leGFtcGxlUmVhZHkoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5ydW5FeGFtcGxlID0gKGRlbHRhKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBtb3VzZXBvc2l0aW9uID0gdGhpcy5hcHAucmVuZGVyZXIucGx1Z2lucy5pbnRlcmFjdGlvbi5tb3VzZS5nbG9iYWw7XG4gICAgICAgICAgICB0aGlzLmhpc3RvcnlYLnBvcCgpO1xuICAgICAgICAgICAgdGhpcy5oaXN0b3J5WC51bnNoaWZ0KG1vdXNlcG9zaXRpb24ueCk7XG4gICAgICAgICAgICB0aGlzLmhpc3RvcnlZLnBvcCgpO1xuICAgICAgICAgICAgdGhpcy5oaXN0b3J5WS51bnNoaWZ0KG1vdXNlcG9zaXRpb24ueSk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucm9wZVNpemU7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHAgPSB0aGlzLnBvaW50c1tpXTtcbiAgICAgICAgICAgICAgICBjb25zdCBpeCA9IHRoaXMuY3ViaWNJbnRlcnBvbGF0aW9uKHRoaXMuaGlzdG9yeVgsIGkgLyB0aGlzLnJvcGVTaXplICogdGhpcy5oaXN0b3J5U2l6ZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgaXkgPSB0aGlzLmN1YmljSW50ZXJwb2xhdGlvbih0aGlzLmhpc3RvcnlZLCBpIC8gdGhpcy5yb3BlU2l6ZSAqIHRoaXMuaGlzdG9yeVNpemUpO1xuICAgICAgICAgICAgICAgIHAueCA9IGl4O1xuICAgICAgICAgICAgICAgIHAueSA9IGl5O1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmJhY2tDb2xvciA9IDB4MDAwMzc4O1xuICAgICAgICB0aGlzLmxvYWRlciA9IG5ldyBSZXNvdXJjZUxvYWRlcl8xLlJlc291cmNlTG9hZGVyKG5ldyBVUkxSZXF1ZXN0XzEuVVJMUmVxdWVzdChcImV4YW1wbGVzL2Fzc2V0cy90cmFpbC5wbmdcIikpO1xuICAgICAgICB0aGlzLmxvYWRlci5hZGRFdmVudExpc3RlbmVyKEV2ZW50XzEuRXZlbnQuQ09NUExFVEUsIHRoaXMuaGFuZGxlR3Jhc3NMb2FkZWQpO1xuICAgICAgICB0aGlzLmxvYWRlci5sb2FkKCk7XG4gICAgfVxuICAgIGNsaXBJbnB1dChrLCBhcnIpIHtcbiAgICAgICAgaWYgKGsgPCAwKVxuICAgICAgICAgICAgayA9IDA7XG4gICAgICAgIGlmIChrID4gYXJyLmxlbmd0aCAtIDEpXG4gICAgICAgICAgICBrID0gYXJyLmxlbmd0aCAtIDE7XG4gICAgICAgIHJldHVybiBhcnJba107XG4gICAgfVxuICAgIGdldFRhbmdlbnQoaywgZmFjdG9yLCBhcnJheSkge1xuICAgICAgICByZXR1cm4gZmFjdG9yICogKHRoaXMuY2xpcElucHV0KGsgKyAxLCBhcnJheSkgLSB0aGlzLmNsaXBJbnB1dChrIC0gMSwgYXJyYXkpKSAvIDI7XG4gICAgfVxuICAgIGN1YmljSW50ZXJwb2xhdGlvbihhcnJheSwgdCwgdGFuZ2VudEZhY3RvciA9IDEpIHtcbiAgICAgICAgY29uc3QgayA9IE1hdGguZmxvb3IodCk7XG4gICAgICAgIGNvbnN0IG0gPSBbdGhpcy5nZXRUYW5nZW50KGssIHRhbmdlbnRGYWN0b3IsIGFycmF5KSwgdGhpcy5nZXRUYW5nZW50KGsgKyAxLCB0YW5nZW50RmFjdG9yLCBhcnJheSldO1xuICAgICAgICBjb25zdCBwID0gW3RoaXMuY2xpcElucHV0KGssIGFycmF5KSwgdGhpcy5jbGlwSW5wdXQoayArIDEsIGFycmF5KV07XG4gICAgICAgIHQgLT0gaztcbiAgICAgICAgY29uc3QgdDIgPSB0ICogdDtcbiAgICAgICAgY29uc3QgdDMgPSB0ICogdDI7XG4gICAgICAgIHJldHVybiAoMiAqIHQzIC0gMyAqIHQyICsgMSkgKiBwWzBdICsgKHQzIC0gMiAqIHQyICsgdCkgKiBtWzBdICsgKC0yICogdDMgKyAzICogdDIpICogcFsxXSArICh0MyAtIHQyKSAqIG1bMV07XG4gICAgfVxuICAgIGRlc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyLmRlc3RydWN0b3IoKTtcbiAgICAgICAgaWYgKHRoaXMucG9pbnRzICYmIHRoaXMucG9pbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgd2hpbGUgKHRoaXMucG9pbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGxldCBwb2ludCA9IHRoaXMucG9pbnRzLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgcG9pbnQucmVjeWNsZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMucG9pbnRzID0gbnVsbDtcbiAgICAgICAgdGhpcy5oaXN0b3J5WSA9IG51bGw7XG4gICAgICAgIHRoaXMuaGlzdG9yeVggPSBudWxsO1xuICAgICAgICB0aGlzLmFwcC50aWNrZXIucmVtb3ZlKHRoaXMucnVuRXhhbXBsZSwgbnVsbCk7XG4gICAgICAgIHRoaXMudHJhaWxUZXh0dXJlLmRlc3Ryb3kobnVsbCk7XG4gICAgfVxufVxuZXhwb3J0cy5BZHZhbmNlZFRyYWlsID0gQWR2YW5jZWRUcmFpbDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgQmFzZUV4YW1wbGVfMSA9IHJlcXVpcmUoXCIuL0Jhc2VFeGFtcGxlXCIpO1xuY29uc3QgRXZlbnRfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9FdmVudFwiKTtcbmNvbnN0IFVSTFJlcXVlc3RfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9VUkxSZXF1ZXN0XCIpO1xuY29uc3QgUmVzb3VyY2VMb2FkZXJfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9SZXNvdXJjZUxvYWRlclwiKTtcbmNvbnN0IFRleHR1cmVfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9UZXh0dXJlXCIpO1xuY29uc3QgQmFzZVRleHR1cmVfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9CYXNlVGV4dHVyZVwiKTtcbmNvbnN0IFNwcml0ZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1Nwcml0ZVwiKTtcbmNsYXNzIEFkdmFuY2VkV2FycCBleHRlbmRzIEJhc2VFeGFtcGxlXzEuQmFzZUV4YW1wbGUge1xuICAgIGNvbnN0cnVjdG9yKGFwcCwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICBzdXBlcihhcHAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICB0aGlzLmhhbmRsZUdyYXNzTG9hZGVkID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnN0YXJUZXh0dXJlID0gbmV3IFRleHR1cmVfMS5UZXh0dXJlKG5ldyBCYXNlVGV4dHVyZV8xLkJhc2VUZXh0dXJlKHRoaXMubG9hZGVyLmltYWdlRGF0YSkpO1xuICAgICAgICAgICAgdGhpcy5zdGFyQW1vdW50ID0gMTAwMDtcbiAgICAgICAgICAgIHRoaXMuY2FtZXJhWiA9IDA7XG4gICAgICAgICAgICB0aGlzLmZvdiA9IDIwO1xuICAgICAgICAgICAgdGhpcy5iYXNlU3BlZWQgPSAwLjAyNTtcbiAgICAgICAgICAgIHRoaXMuc3BlZWQgPSAwO1xuICAgICAgICAgICAgdGhpcy53YXJwU3BlZWQgPSAwO1xuICAgICAgICAgICAgdGhpcy5zdGFyU3RyZXRjaCA9IDU7XG4gICAgICAgICAgICB0aGlzLnN0YXJCYXNlU2l6ZSA9IDAuMDU7XG4gICAgICAgICAgICB0aGlzLnN0YXJzID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc3RhckFtb3VudDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhciA9IHtcbiAgICAgICAgICAgICAgICAgICAgc3ByaXRlOiBuZXcgU3ByaXRlXzEuU3ByaXRlKHRoaXMuc3RhclRleHR1cmUpLFxuICAgICAgICAgICAgICAgICAgICB6OiAwLFxuICAgICAgICAgICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgICAgICAgICB5OiAwLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgc3Rhci5zcHJpdGUuYW5jaG9yLnggPSAwLjU7XG4gICAgICAgICAgICAgICAgc3Rhci5zcHJpdGUuYW5jaG9yLnkgPSAwLjc7XG4gICAgICAgICAgICAgICAgdGhpcy5yYW5kb21pemVTdGFyKHN0YXIsIHRydWUpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhZ2UuYWRkQ2hpbGQoc3Rhci5zcHJpdGUpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnMucHVzaChzdGFyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLndhcnBTcGVlZCA9IHRoaXMud2FycFNwZWVkID4gMCA/IDAgOiAxO1xuICAgICAgICAgICAgfSwgNTAwMCk7XG4gICAgICAgICAgICB0aGlzLmFwcC50aWNrZXIuYWRkKHRoaXMucnVuRXhhbXBsZSk7XG4gICAgICAgICAgICB0aGlzLmV4YW1wbGVSZWFkeSgpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnJ1bkV4YW1wbGUgPSAoZGVsdGEpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc3BlZWQgKz0gKHRoaXMud2FycFNwZWVkIC0gdGhpcy5zcGVlZCkgLyAyMDtcbiAgICAgICAgICAgIHRoaXMuY2FtZXJhWiArPSBkZWx0YSAqIDEwICogKHRoaXMuc3BlZWQgKyB0aGlzLmJhc2VTcGVlZCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc3RhckFtb3VudDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhciA9IHRoaXMuc3RhcnNbaV07XG4gICAgICAgICAgICAgICAgaWYgKHN0YXIueiA8IHRoaXMuY2FtZXJhWilcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yYW5kb21pemVTdGFyKHN0YXIpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHogPSBzdGFyLnogLSB0aGlzLmNhbWVyYVo7XG4gICAgICAgICAgICAgICAgc3Rhci5zcHJpdGUueCA9IHN0YXIueCAqICh0aGlzLmZvdiAvIHopICogdGhpcy5zaXpldyArIHRoaXMuc2l6ZXcgLyAyO1xuICAgICAgICAgICAgICAgIHN0YXIuc3ByaXRlLnkgPSBzdGFyLnkgKiAodGhpcy5mb3YgLyB6KSAqIHRoaXMuc2l6ZXcgKyB0aGlzLnNpemVoIC8gMjtcbiAgICAgICAgICAgICAgICBjb25zdCBkeENlbnRlciA9IHN0YXIuc3ByaXRlLnggLSB0aGlzLnNpemV3IC8gMjtcbiAgICAgICAgICAgICAgICBjb25zdCBkeUNlbnRlciA9IHN0YXIuc3ByaXRlLnkgLSB0aGlzLnNpemVoIC8gMjtcbiAgICAgICAgICAgICAgICBjb25zdCBkaXN0YW5jZUNlbnRlciA9IE1hdGguc3FydChkeENlbnRlciAqIGR4Q2VudGVyICsgZHlDZW50ZXIgKyBkeUNlbnRlcik7XG4gICAgICAgICAgICAgICAgY29uc3QgZGlzdGFuY2VTY2FsZSA9IE1hdGgubWF4KDAsICgyMDAwIC0geikgLyAyMDAwKTtcbiAgICAgICAgICAgICAgICBzdGFyLnNwcml0ZS5zY2FsZS54ID0gZGlzdGFuY2VTY2FsZSAqIHRoaXMuc3RhckJhc2VTaXplO1xuICAgICAgICAgICAgICAgIHN0YXIuc3ByaXRlLnNjYWxlLnkgPSBkaXN0YW5jZVNjYWxlICogdGhpcy5zdGFyQmFzZVNpemUgKyBkaXN0YW5jZVNjYWxlICogdGhpcy5zcGVlZCAqIHRoaXMuc3RhclN0cmV0Y2ggKiBkaXN0YW5jZUNlbnRlciAvIHRoaXMuc2l6ZXc7XG4gICAgICAgICAgICAgICAgc3Rhci5zcHJpdGUucm90YXRpb24gPSBNYXRoLmF0YW4yKGR5Q2VudGVyLCBkeENlbnRlcikgKyBNYXRoLlBJIC8gMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5iYWNrQ29sb3IgPSAweDAwMDAwMDtcbiAgICAgICAgdGhpcy5sb2FkZXIgPSBuZXcgUmVzb3VyY2VMb2FkZXJfMS5SZXNvdXJjZUxvYWRlcihuZXcgVVJMUmVxdWVzdF8xLlVSTFJlcXVlc3QoXCJleGFtcGxlcy9hc3NldHMvc3Rhci5wbmdcIikpO1xuICAgICAgICB0aGlzLmxvYWRlci5hZGRFdmVudExpc3RlbmVyKEV2ZW50XzEuRXZlbnQuQ09NUExFVEUsIHRoaXMuaGFuZGxlR3Jhc3NMb2FkZWQpO1xuICAgICAgICB0aGlzLmxvYWRlci5sb2FkKCk7XG4gICAgfVxuICAgIHJhbmRvbWl6ZVN0YXIoc3RhciwgaW5pdGlhbCA9IHRydWUpIHtcbiAgICAgICAgc3Rhci56ID0gaW5pdGlhbCA/IE1hdGgucmFuZG9tKCkgKiAyMDAwIDogdGhpcy5jYW1lcmFaICsgTWF0aC5yYW5kb20oKSAqIDEwMDAgKyAyMDAwO1xuICAgICAgICBjb25zdCBkZWcgPSBNYXRoLnJhbmRvbSgpICogTWF0aC5QSSAqIDI7XG4gICAgICAgIGNvbnN0IGRpc3RhbmNlID0gTWF0aC5yYW5kb20oKSAqIDUwICsgMTtcbiAgICAgICAgc3Rhci54ID0gTWF0aC5jb3MoZGVnKSAqIGRpc3RhbmNlO1xuICAgICAgICBzdGFyLnkgPSBNYXRoLnNpbihkZWcpICogZGlzdGFuY2U7XG4gICAgfVxuICAgIGRlc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyLmRlc3RydWN0b3IoKTtcbiAgICAgICAgdGhpcy5zdGFycyA9IG51bGw7XG4gICAgICAgIHRoaXMuYXBwLnRpY2tlci5yZW1vdmUodGhpcy5ydW5FeGFtcGxlLCBudWxsKTtcbiAgICAgICAgdGhpcy5zdGFyVGV4dHVyZS5kZXN0cm95KG51bGwpO1xuICAgIH1cbn1cbmV4cG9ydHMuQWR2YW5jZWRXYXJwID0gQWR2YW5jZWRXYXJwO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBHcmFwaGljc18xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0dyYXBoaWNzXCIpO1xuY29uc3QgQ29udGFpbmVyXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvQ29udGFpbmVyXCIpO1xuY29uc3QgRXZlbnREaXNwYXRjaGVyXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvRXZlbnREaXNwYXRjaGVyXCIpO1xuY29uc3QgRXZlbnRfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9FdmVudFwiKTtcbmNsYXNzIEJhc2VFeGFtcGxlIGV4dGVuZHMgRXZlbnREaXNwYXRjaGVyXzEuRXZlbnREaXNwYXRjaGVyIHtcbiAgICBjb25zdHJ1Y3RvcihhcHAsIHdpZHRoID0gMTAwLCBoZWlnaHQgPSAxMDApIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5iYWNrQ29sb3IgPSAweDk2OTY5NjtcbiAgICAgICAgdGhpcy5zaXpldyA9IHdpZHRoO1xuICAgICAgICB0aGlzLnNpemVoID0gaGVpZ2h0O1xuICAgICAgICB0aGlzLmFwcCA9IGFwcDtcbiAgICAgICAgdGhpcy5zdGFnZSA9IG5ldyBDb250YWluZXJfMS5Db250YWluZXIoKTtcbiAgICB9XG4gICAgYWN0aXZhdGVNYXNrKCkge1xuICAgICAgICB0aGlzLnN0YWdlTWFzayA9IG5ldyBHcmFwaGljc18xLkdyYXBoaWNzKCk7XG4gICAgICAgIHRoaXMuc3RhZ2VNYXNrLmJlZ2luRmlsbCgwKTtcbiAgICAgICAgdGhpcy5zdGFnZU1hc2suZHJhd1JlY3QoMCwgMCwgdGhpcy5zaXpldywgdGhpcy5zaXplaCk7XG4gICAgICAgIHRoaXMuc3RhZ2UubWFzayA9IHRoaXMuc3RhZ2VNYXNrO1xuICAgIH1cbiAgICBkZXN0cnVjdG9yKCkge1xuICAgICAgICBpZiAodGhpcy5zdGFnZS5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgICAgIHdoaWxlICh0aGlzLnN0YWdlLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGxldCBjaGlsZCA9IHRoaXMuc3RhZ2UuY2hpbGRyZW4uc2hpZnQoKTtcbiAgICAgICAgICAgICAgICBjaGlsZC5kZXN0cnVjdG9yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGFnZSA9IG51bGw7XG4gICAgICAgIGlmICh0aGlzLnN0YWdlTWFzaykge1xuICAgICAgICAgICAgdGhpcy5zdGFnZU1hc2suZGVzdHJveShudWxsKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBleGFtcGxlUmVhZHkoKSB7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChFdmVudF8xLkV2ZW50LmdldEV2ZW50KEV2ZW50XzEuRXZlbnQuQ09NUExFVEUpKTtcbiAgICB9XG59XG5leHBvcnRzLkJhc2VFeGFtcGxlID0gQmFzZUV4YW1wbGU7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IEJhc2VFeGFtcGxlXzEgPSByZXF1aXJlKFwiLi9CYXNlRXhhbXBsZVwiKTtcbmNvbnN0IFJlc291cmNlTG9hZGVyXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvUmVzb3VyY2VMb2FkZXJcIik7XG5jb25zdCBVUkxSZXF1ZXN0XzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvVVJMUmVxdWVzdFwiKTtcbmNvbnN0IEV2ZW50XzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvRXZlbnRcIik7XG5jb25zdCBUZXh0dXJlXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvVGV4dHVyZVwiKTtcbmNvbnN0IEJhc2VUZXh0dXJlXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvQmFzZVRleHR1cmVcIik7XG5jb25zdCBTcHJpdGVfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9TcHJpdGVcIik7XG5jb25zdCBSZWN0YW5nbGVfMSA9IHJlcXVpcmUoXCIuLi9mbGFzaC9nZW9tL1JlY3RhbmdsZVwiKTtcbmNvbnN0IEJsZW5kTW9kZXNTZXR0aW5nc18xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0JsZW5kTW9kZXNTZXR0aW5nc1wiKTtcbmNsYXNzIEJhc2ljQmxlbmQgZXh0ZW5kcyBCYXNlRXhhbXBsZV8xLkJhc2VFeGFtcGxlIHtcbiAgICBjb25zdHJ1Y3RvcihhcHAsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgc3VwZXIoYXBwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgdGhpcy5oYW5kbGVSZXNvdXJjZUxvYWRlZCA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgbGV0IHR4dCA9IG5ldyBUZXh0dXJlXzEuVGV4dHVyZShuZXcgQmFzZVRleHR1cmVfMS5CYXNlVGV4dHVyZSh0aGlzLmxvYWRlci5pbWFnZURhdGEpKTtcbiAgICAgICAgICAgIGNvbnN0IGJhY2tncm91bmQgPSBuZXcgU3ByaXRlXzEuU3ByaXRlKHR4dCk7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kLndpZHRoID0gdGhpcy5zaXpldztcbiAgICAgICAgICAgIGJhY2tncm91bmQuaGVpZ2h0ID0gdGhpcy5zaXplaDtcbiAgICAgICAgICAgIHRoaXMuc3RhZ2UuYWRkQ2hpbGQoYmFja2dyb3VuZCk7XG4gICAgICAgICAgICB0aGlzLmxvYWRlciA9IG5ldyBSZXNvdXJjZUxvYWRlcl8xLlJlc291cmNlTG9hZGVyKG5ldyBVUkxSZXF1ZXN0XzEuVVJMUmVxdWVzdChcImV4YW1wbGVzL2Fzc2V0cy9mbG93ZXJUb3AucG5nXCIpKTtcbiAgICAgICAgICAgIHRoaXMubG9hZGVyLmFkZEV2ZW50TGlzdGVuZXIoRXZlbnRfMS5FdmVudC5DT01QTEVURSwgdGhpcy5oYW5kbGVGbG93ZXJMb2FkZWQpO1xuICAgICAgICAgICAgdGhpcy5sb2FkZXIubG9hZCgpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZUZsb3dlckxvYWRlZCA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgbGV0IHR4dCA9IG5ldyBUZXh0dXJlXzEuVGV4dHVyZShuZXcgQmFzZVRleHR1cmVfMS5CYXNlVGV4dHVyZSh0aGlzLmxvYWRlci5pbWFnZURhdGEpKTtcbiAgICAgICAgICAgIHRoaXMuZHVkZUFycmF5ID0gW107XG4gICAgICAgICAgICBjb25zdCB0b3RhbGR1ZGVzID0gMjA7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRvdGFsZHVkZXM7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGR1ZGUgPSBuZXcgRXh0ZW5kZWRTcHJpdGUodHh0KTtcbiAgICAgICAgICAgICAgICBkdWRlLmFuY2hvci5zZXQoMC41KTtcbiAgICAgICAgICAgICAgICBkdWRlLnNjYWxlLnNldCgwLjggKyBNYXRoLnJhbmRvbSgpICogMC4zKTtcbiAgICAgICAgICAgICAgICBkdWRlLnggPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiB0aGlzLnNpemV3KTtcbiAgICAgICAgICAgICAgICBkdWRlLnkgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiB0aGlzLnNpemVoKTtcbiAgICAgICAgICAgICAgICBkdWRlLmJsZW5kTW9kZSA9IEJsZW5kTW9kZXNTZXR0aW5nc18xLkJsZW5kTW9kZXNTZXR0aW5ncy5CTEVORF9NT0RFUy5BREQ7XG4gICAgICAgICAgICAgICAgZHVkZS5kaXJlY3Rpb24gPSBNYXRoLnJhbmRvbSgpICogTWF0aC5QSSAqIDI7XG4gICAgICAgICAgICAgICAgZHVkZS50dXJuaW5nU3BlZWQgPSBNYXRoLnJhbmRvbSgpIC0gMC44O1xuICAgICAgICAgICAgICAgIGR1ZGUuc3BlZWQgPSAyICsgTWF0aC5yYW5kb20oKSAqIDI7XG4gICAgICAgICAgICAgICAgdGhpcy5kdWRlQXJyYXkucHVzaChkdWRlKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YWdlLmFkZENoaWxkKGR1ZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZHVkZUJvdW5kc1BhZGRpbmcgPSAxMDA7XG4gICAgICAgICAgICB0aGlzLmR1ZGVCb3VuZHMgPSBSZWN0YW5nbGVfMS5SZWN0YW5nbGUuZ2V0UmVjdGFuZ2xlKC1kdWRlQm91bmRzUGFkZGluZywgLWR1ZGVCb3VuZHNQYWRkaW5nLCB0aGlzLnNpemV3ICsgZHVkZUJvdW5kc1BhZGRpbmcgKiAyLCB0aGlzLnNpemVoICsgZHVkZUJvdW5kc1BhZGRpbmcgKiAyKTtcbiAgICAgICAgICAgIHRoaXMuYXBwLnRpY2tlci5hZGQodGhpcy5ydW5FeGFtcGxlKTtcbiAgICAgICAgICAgIHRoaXMuZXhhbXBsZVJlYWR5KCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucnVuRXhhbXBsZSA9IChkZWx0YSkgPT4ge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmR1ZGVBcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGR1ZGUgPSB0aGlzLmR1ZGVBcnJheVtpXTtcbiAgICAgICAgICAgICAgICBkdWRlLmRpcmVjdGlvbiArPSBkdWRlLnR1cm5pbmdTcGVlZCAqIDAuMDE7XG4gICAgICAgICAgICAgICAgZHVkZS54ICs9IE1hdGguc2luKGR1ZGUuZGlyZWN0aW9uKSAqIGR1ZGUuc3BlZWQ7XG4gICAgICAgICAgICAgICAgZHVkZS55ICs9IE1hdGguY29zKGR1ZGUuZGlyZWN0aW9uKSAqIGR1ZGUuc3BlZWQ7XG4gICAgICAgICAgICAgICAgZHVkZS5yb3RhdGlvbiA9IC1kdWRlLmRpcmVjdGlvbiAtIE1hdGguUEkgLyAyO1xuICAgICAgICAgICAgICAgIGlmIChkdWRlLnggPCB0aGlzLmR1ZGVCb3VuZHMueCkge1xuICAgICAgICAgICAgICAgICAgICBkdWRlLnggKz0gdGhpcy5kdWRlQm91bmRzLndpZHRoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChkdWRlLnggPiB0aGlzLmR1ZGVCb3VuZHMueCArIHRoaXMuZHVkZUJvdW5kcy53aWR0aCkge1xuICAgICAgICAgICAgICAgICAgICBkdWRlLnggLT0gdGhpcy5kdWRlQm91bmRzLndpZHRoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZHVkZS55IDwgdGhpcy5kdWRlQm91bmRzLnkpIHtcbiAgICAgICAgICAgICAgICAgICAgZHVkZS55ICs9IHRoaXMuZHVkZUJvdW5kcy5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGR1ZGUueSA+IHRoaXMuZHVkZUJvdW5kcy55ICsgdGhpcy5kdWRlQm91bmRzLmhlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICBkdWRlLnkgLT0gdGhpcy5kdWRlQm91bmRzLmhlaWdodDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuYmFja0NvbG9yID0gMHhGRkZGRkY7XG4gICAgICAgIHRoaXMuYWN0aXZhdGVNYXNrKCk7XG4gICAgICAgIHRoaXMubG9hZGVyID0gbmV3IFJlc291cmNlTG9hZGVyXzEuUmVzb3VyY2VMb2FkZXIobmV3IFVSTFJlcXVlc3RfMS5VUkxSZXF1ZXN0KFwiZXhhbXBsZXMvYXNzZXRzL2VnZ0hlYWQucG5nXCIpKTtcbiAgICAgICAgdGhpcy5sb2FkZXIuYWRkRXZlbnRMaXN0ZW5lcihFdmVudF8xLkV2ZW50LkNPTVBMRVRFLCB0aGlzLmhhbmRsZVJlc291cmNlTG9hZGVkKTtcbiAgICAgICAgdGhpcy5sb2FkZXIubG9hZCgpO1xuICAgIH1cbiAgICBkZXN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlci5kZXN0cnVjdG9yKCk7XG4gICAgICAgIHRoaXMuYXBwLnRpY2tlci5yZW1vdmUodGhpcy5ydW5FeGFtcGxlLCBudWxsKTtcbiAgICAgICAgdGhpcy5kdWRlQXJyYXkgPSBudWxsO1xuICAgIH1cbn1cbmV4cG9ydHMuQmFzaWNCbGVuZCA9IEJhc2ljQmxlbmQ7XG5jbGFzcyBFeHRlbmRlZFNwcml0ZSBleHRlbmRzIFNwcml0ZV8xLlNwcml0ZSB7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IEJhc2VFeGFtcGxlXzEgPSByZXF1aXJlKFwiLi9CYXNlRXhhbXBsZVwiKTtcbmNvbnN0IENvbnRhaW5lcl8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0NvbnRhaW5lclwiKTtcbmNvbnN0IFRleHR1cmVfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9UZXh0dXJlXCIpO1xuY29uc3QgU3ByaXRlXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvU3ByaXRlXCIpO1xuY29uc3QgUmVzb3VyY2VMb2FkZXJfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9SZXNvdXJjZUxvYWRlclwiKTtcbmNvbnN0IFVSTFJlcXVlc3RfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9VUkxSZXF1ZXN0XCIpO1xuY29uc3QgRXZlbnRfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9FdmVudFwiKTtcbmNvbnN0IEJhc2VUZXh0dXJlXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvQmFzZVRleHR1cmVcIik7XG5jbGFzcyBCYXNpY0NvbnRhaW5lciBleHRlbmRzIEJhc2VFeGFtcGxlXzEuQmFzZUV4YW1wbGUge1xuICAgIGNvbnN0cnVjdG9yKGFwcCwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICBzdXBlcihhcHAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICB0aGlzLmhhbmRsZVJlc291cmNlTG9hZGVkID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBsZXQgdHh0ID0gbmV3IFRleHR1cmVfMS5UZXh0dXJlKG5ldyBCYXNlVGV4dHVyZV8xLkJhc2VUZXh0dXJlKHRoaXMubG9hZGVyLmltYWdlRGF0YSkpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAyNTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYnVubnkgPSBuZXcgU3ByaXRlXzEuU3ByaXRlKHR4dCk7XG4gICAgICAgICAgICAgICAgYnVubnkuYW5jaG9yLnNldCgwLjUpO1xuICAgICAgICAgICAgICAgIGJ1bm55LnggPSAoaSAlIDUpICogNDA7XG4gICAgICAgICAgICAgICAgYnVubnkueSA9IE1hdGguZmxvb3IoaSAvIDUpICogNDA7XG4gICAgICAgICAgICAgICAgdGhpcy5jb250YWluZXIuYWRkQ2hpbGQoYnVubnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jb250YWluZXIueCA9IHRoaXMuc2l6ZXcgLyAyO1xuICAgICAgICAgICAgdGhpcy5jb250YWluZXIueSA9IHRoaXMuc2l6ZWggLyAyO1xuICAgICAgICAgICAgdGhpcy5jb250YWluZXIucGl2b3QueCA9IHRoaXMuY29udGFpbmVyLndpZHRoIC8gMjtcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLnBpdm90LnkgPSB0aGlzLmNvbnRhaW5lci5oZWlnaHQgLyAyO1xuICAgICAgICAgICAgdGhpcy5hcHAudGlja2VyLmFkZCh0aGlzLnJ1bkV4YW1wbGUpO1xuICAgICAgICAgICAgdGhpcy5leGFtcGxlUmVhZHkoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5ydW5FeGFtcGxlID0gKGRlbHRhKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5yb3RhdGlvbiAtPSAwLjAxICogZGVsdGE7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY29udGFpbmVyID0gbmV3IENvbnRhaW5lcl8xLkNvbnRhaW5lcigpO1xuICAgICAgICB0aGlzLnN0YWdlLmFkZENoaWxkKHRoaXMuY29udGFpbmVyKTtcbiAgICAgICAgdGhpcy5sb2FkZXIgPSBuZXcgUmVzb3VyY2VMb2FkZXJfMS5SZXNvdXJjZUxvYWRlcihuZXcgVVJMUmVxdWVzdF8xLlVSTFJlcXVlc3QoXCJleGFtcGxlcy9hc3NldHMvYnVubnkucG5nXCIpKTtcbiAgICAgICAgdGhpcy5sb2FkZXIuYWRkRXZlbnRMaXN0ZW5lcihFdmVudF8xLkV2ZW50LkNPTVBMRVRFLCB0aGlzLmhhbmRsZVJlc291cmNlTG9hZGVkKTtcbiAgICAgICAgdGhpcy5sb2FkZXIubG9hZCgpO1xuICAgIH1cbiAgICBkZXN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlci5kZXN0cnVjdG9yKCk7XG4gICAgICAgIHRoaXMuYXBwLnRpY2tlci5yZW1vdmUodGhpcy5ydW5FeGFtcGxlLCBudWxsKTtcbiAgICAgICAgaWYgKHRoaXMuY29udGFpbmVyKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5kZXN0cnVjdG9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb250YWluZXIgPSBudWxsO1xuICAgIH1cbn1cbmV4cG9ydHMuQmFzaWNDb250YWluZXIgPSBCYXNpY0NvbnRhaW5lcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgQmFzZUV4YW1wbGVfMSA9IHJlcXVpcmUoXCIuL0Jhc2VFeGFtcGxlXCIpO1xuY29uc3QgUmVzb3VyY2VMb2FkZXJfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9SZXNvdXJjZUxvYWRlclwiKTtcbmNvbnN0IFVSTFJlcXVlc3RfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9VUkxSZXF1ZXN0XCIpO1xuY29uc3QgRXZlbnRfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9FdmVudFwiKTtcbmNvbnN0IFRleHR1cmVfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9UZXh0dXJlXCIpO1xuY29uc3QgQmFzZVRleHR1cmVfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9CYXNlVGV4dHVyZVwiKTtcbmNvbnN0IFBhcnRpY2xlQ29udGFpbmVyXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvUGFydGljbGVDb250YWluZXJcIik7XG5jb25zdCBTcHJpdGVfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9TcHJpdGVcIik7XG5jb25zdCBSZWN0YW5nbGVfMSA9IHJlcXVpcmUoXCIuLi9mbGFzaC9nZW9tL1JlY3RhbmdsZVwiKTtcbmNsYXNzIEJhc2ljUGFydGljbGVzIGV4dGVuZHMgQmFzZUV4YW1wbGVfMS5CYXNlRXhhbXBsZSB7XG4gICAgY29uc3RydWN0b3IoYXBwLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHN1cGVyKGFwcCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIHRoaXMuaGFuZGxlUmVzb3VyY2VMb2FkZWQgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGxldCB0eHQgPSBuZXcgVGV4dHVyZV8xLlRleHR1cmUobmV3IEJhc2VUZXh0dXJlXzEuQmFzZVRleHR1cmUodGhpcy5sb2FkZXIuaW1hZ2VEYXRhKSk7XG4gICAgICAgICAgICBjb25zdCBzcHJpdGVzID0gbmV3IFBhcnRpY2xlQ29udGFpbmVyXzEuUGFydGljbGVDb250YWluZXIoMTAwMDAsIHsgc2NhbGU6IHRydWUsIHBvc2l0aW9uOiB0cnVlLCByb3RhdGlvbjogdHJ1ZSwgdXZzOiB0cnVlLCBhbHBoYTogdHJ1ZSwgfSk7XG4gICAgICAgICAgICB0aGlzLnN0YWdlLmFkZENoaWxkKHNwcml0ZXMpO1xuICAgICAgICAgICAgdGhpcy5tYWdnb3RzID0gW107XG4gICAgICAgICAgICBjb25zdCB0b3RhbFNwcml0ZXMgPSAxMDAwMDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdG90YWxTcHJpdGVzOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkdWRlID0gbmV3IEV4dGVuZGVkU3ByaXRlKHR4dCk7XG4gICAgICAgICAgICAgICAgZHVkZS50aW50ID0gTWF0aC5yYW5kb20oKSAqIDB4RThENENEO1xuICAgICAgICAgICAgICAgIGR1ZGUuYW5jaG9yLnNldCgwLjUpO1xuICAgICAgICAgICAgICAgIGR1ZGUuc2NhbGUuc2V0KDAuOCArIE1hdGgucmFuZG9tKCkgKiAwLjMpO1xuICAgICAgICAgICAgICAgIGR1ZGUueCA9IE1hdGgucmFuZG9tKCkgKiB0aGlzLnNpemV3O1xuICAgICAgICAgICAgICAgIGR1ZGUueSA9IE1hdGgucmFuZG9tKCkgKiB0aGlzLnNpemVoO1xuICAgICAgICAgICAgICAgIGR1ZGUudGludCA9IE1hdGgucmFuZG9tKCkgKiAweDgwODA4MDtcbiAgICAgICAgICAgICAgICBkdWRlLmRpcmVjdGlvbiA9IE1hdGgucmFuZG9tKCkgKiBNYXRoLlBJICogMjtcbiAgICAgICAgICAgICAgICBkdWRlLnR1cm5pbmdTcGVlZCA9IE1hdGgucmFuZG9tKCkgLSAwLjg7XG4gICAgICAgICAgICAgICAgZHVkZS5zcGVlZCA9ICgyICsgTWF0aC5yYW5kb20oKSAqIDIpICogMC4yO1xuICAgICAgICAgICAgICAgIGR1ZGUub2Zmc2V0ID0gTWF0aC5yYW5kb20oKSAqIDEwMDtcbiAgICAgICAgICAgICAgICB0aGlzLm1hZ2dvdHMucHVzaChkdWRlKTtcbiAgICAgICAgICAgICAgICBzcHJpdGVzLmFkZENoaWxkKGR1ZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZHVkZUJvdW5kc1BhZGRpbmcgPSAxMDA7XG4gICAgICAgICAgICB0aGlzLmR1ZGVCb3VuZHMgPSBSZWN0YW5nbGVfMS5SZWN0YW5nbGUuZ2V0UmVjdGFuZ2xlKC1kdWRlQm91bmRzUGFkZGluZywgLWR1ZGVCb3VuZHNQYWRkaW5nLCB0aGlzLnNpemV3ICsgZHVkZUJvdW5kc1BhZGRpbmcgKiAyLCB0aGlzLnNpemVoICsgZHVkZUJvdW5kc1BhZGRpbmcgKiAyKTtcbiAgICAgICAgICAgIHRoaXMudGljayA9IDA7XG4gICAgICAgICAgICB0aGlzLmFwcC50aWNrZXIuYWRkKHRoaXMucnVuRXhhbXBsZSk7XG4gICAgICAgICAgICB0aGlzLmV4YW1wbGVSZWFkeSgpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnJ1bkV4YW1wbGUgPSAoZGVsdGEpID0+IHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5tYWdnb3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZHVkZSA9IHRoaXMubWFnZ290c1tpXTtcbiAgICAgICAgICAgICAgICBkdWRlLnNjYWxlLnkgPSAwLjk1ICsgTWF0aC5zaW4odGhpcy50aWNrICsgZHVkZS5vZmZzZXQpICogMC4wNTtcbiAgICAgICAgICAgICAgICBkdWRlLmRpcmVjdGlvbiArPSBkdWRlLnR1cm5pbmdTcGVlZCAqIDAuMDE7XG4gICAgICAgICAgICAgICAgZHVkZS54ICs9IE1hdGguc2luKGR1ZGUuZGlyZWN0aW9uKSAqIChkdWRlLnNwZWVkICogZHVkZS5zY2FsZS55KTtcbiAgICAgICAgICAgICAgICBkdWRlLnkgKz0gTWF0aC5jb3MoZHVkZS5kaXJlY3Rpb24pICogKGR1ZGUuc3BlZWQgKiBkdWRlLnNjYWxlLnkpO1xuICAgICAgICAgICAgICAgIGR1ZGUucm90YXRpb24gPSAtZHVkZS5kaXJlY3Rpb24gKyBNYXRoLlBJO1xuICAgICAgICAgICAgICAgIGlmIChkdWRlLnggPCB0aGlzLmR1ZGVCb3VuZHMueCkge1xuICAgICAgICAgICAgICAgICAgICBkdWRlLnggKz0gdGhpcy5kdWRlQm91bmRzLndpZHRoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChkdWRlLnggPiB0aGlzLmR1ZGVCb3VuZHMueCArIHRoaXMuZHVkZUJvdW5kcy53aWR0aCkge1xuICAgICAgICAgICAgICAgICAgICBkdWRlLnggLT0gdGhpcy5kdWRlQm91bmRzLndpZHRoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZHVkZS55IDwgdGhpcy5kdWRlQm91bmRzLnkpIHtcbiAgICAgICAgICAgICAgICAgICAgZHVkZS55ICs9IHRoaXMuZHVkZUJvdW5kcy5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGR1ZGUueSA+IHRoaXMuZHVkZUJvdW5kcy55ICsgdGhpcy5kdWRlQm91bmRzLmhlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICBkdWRlLnkgLT0gdGhpcy5kdWRlQm91bmRzLmhlaWdodDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnRpY2sgKz0gMC4xO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmFjdGl2YXRlTWFzaygpO1xuICAgICAgICB0aGlzLmxvYWRlciA9IG5ldyBSZXNvdXJjZUxvYWRlcl8xLlJlc291cmNlTG9hZGVyKG5ldyBVUkxSZXF1ZXN0XzEuVVJMUmVxdWVzdChcImV4YW1wbGVzL2Fzc2V0cy9tYWdnb3RfdGlueS5wbmdcIikpO1xuICAgICAgICB0aGlzLmxvYWRlci5hZGRFdmVudExpc3RlbmVyKEV2ZW50XzEuRXZlbnQuQ09NUExFVEUsIHRoaXMuaGFuZGxlUmVzb3VyY2VMb2FkZWQpO1xuICAgICAgICB0aGlzLmxvYWRlci5sb2FkKCk7XG4gICAgfVxuICAgIGRlc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyLmRlc3RydWN0b3IoKTtcbiAgICAgICAgdGhpcy5hcHAudGlja2VyLnJlbW92ZSh0aGlzLnJ1bkV4YW1wbGUsIG51bGwpO1xuICAgICAgICB0aGlzLm1hZ2dvdHMgPSBudWxsO1xuICAgIH1cbn1cbmV4cG9ydHMuQmFzaWNQYXJ0aWNsZXMgPSBCYXNpY1BhcnRpY2xlcztcbmNsYXNzIEV4dGVuZGVkU3ByaXRlIGV4dGVuZHMgU3ByaXRlXzEuU3ByaXRlIHtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgQmFzZUV4YW1wbGVfMSA9IHJlcXVpcmUoXCIuL0Jhc2VFeGFtcGxlXCIpO1xuY29uc3QgUmVzb3VyY2VMb2FkZXJfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9SZXNvdXJjZUxvYWRlclwiKTtcbmNvbnN0IEV2ZW50XzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvRXZlbnRcIik7XG5jb25zdCBVUkxSZXF1ZXN0XzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvVVJMUmVxdWVzdFwiKTtcbmNvbnN0IFRleHR1cmVfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9UZXh0dXJlXCIpO1xuY29uc3QgQmFzZVRleHR1cmVfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9CYXNlVGV4dHVyZVwiKTtcbmNvbnN0IFNwcml0ZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1Nwcml0ZVwiKTtcbmNvbnN0IFJlY3RhbmdsZV8xID0gcmVxdWlyZShcIi4uL2ZsYXNoL2dlb20vUmVjdGFuZ2xlXCIpO1xuY2xhc3MgQmFzaWNUaW50aW5nIGV4dGVuZHMgQmFzZUV4YW1wbGVfMS5CYXNlRXhhbXBsZSB7XG4gICAgY29uc3RydWN0b3IoYXBwLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHN1cGVyKGFwcCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIHRoaXMuaGFuZGxlUmVzb3VyY2VMb2FkZWQgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGxldCB0eHQgPSBuZXcgVGV4dHVyZV8xLlRleHR1cmUobmV3IEJhc2VUZXh0dXJlXzEuQmFzZVRleHR1cmUodGhpcy5sb2FkZXIuaW1hZ2VEYXRhKSk7XG4gICAgICAgICAgICB0aGlzLmFsaWVucyA9IFtdO1xuICAgICAgICAgICAgY29uc3QgdG90YWxEdWRlcyA9IDIwO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b3RhbER1ZGVzOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkdWRlID0gbmV3IEV4dGVuZGVkU3ByaXRlKHR4dCk7XG4gICAgICAgICAgICAgICAgZHVkZS5hbmNob3Iuc2V0KDAuNSk7XG4gICAgICAgICAgICAgICAgZHVkZS5zY2FsZS5zZXQoMC44ICsgTWF0aC5yYW5kb20oKSAqIDAuMyk7XG4gICAgICAgICAgICAgICAgZHVkZS54ID0gTWF0aC5yYW5kb20oKSAqIHRoaXMuc2l6ZXc7XG4gICAgICAgICAgICAgICAgZHVkZS55ID0gTWF0aC5yYW5kb20oKSAqIHRoaXMuc2l6ZWg7XG4gICAgICAgICAgICAgICAgZHVkZS50aW50ID0gTWF0aC5yYW5kb20oKSAqIDB4RkZGRkZGO1xuICAgICAgICAgICAgICAgIGR1ZGUuZGlyZWN0aW9uID0gTWF0aC5yYW5kb20oKSAqIE1hdGguUEkgKiAyO1xuICAgICAgICAgICAgICAgIGR1ZGUudHVybmluZ1NwZWVkID0gTWF0aC5yYW5kb20oKSAtIDAuODtcbiAgICAgICAgICAgICAgICBkdWRlLnNwZWVkID0gMiArIE1hdGgucmFuZG9tKCkgKiAyO1xuICAgICAgICAgICAgICAgIHRoaXMuYWxpZW5zLnB1c2goZHVkZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFnZS5hZGRDaGlsZChkdWRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGR1ZGVCb3VuZHNQYWRkaW5nID0gMTAwO1xuICAgICAgICAgICAgdGhpcy5kdWRlQm91bmRzID0gUmVjdGFuZ2xlXzEuUmVjdGFuZ2xlLmdldFJlY3RhbmdsZSgtZHVkZUJvdW5kc1BhZGRpbmcsIC1kdWRlQm91bmRzUGFkZGluZywgdGhpcy5zaXpldyArIGR1ZGVCb3VuZHNQYWRkaW5nICogMiwgdGhpcy5zaXplaCArIGR1ZGVCb3VuZHNQYWRkaW5nICogMik7XG4gICAgICAgICAgICB0aGlzLmFwcC50aWNrZXIuYWRkKHRoaXMucnVuRXhhbXBsZSk7XG4gICAgICAgICAgICB0aGlzLmV4YW1wbGVSZWFkeSgpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnJ1bkV4YW1wbGUgPSAoZGVsdGEpID0+IHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5hbGllbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkdWRlID0gdGhpcy5hbGllbnNbaV07XG4gICAgICAgICAgICAgICAgZHVkZS5kaXJlY3Rpb24gKz0gZHVkZS50dXJuaW5nU3BlZWQgKiAwLjAxO1xuICAgICAgICAgICAgICAgIGR1ZGUueCArPSBNYXRoLnNpbihkdWRlLmRpcmVjdGlvbikgKiBkdWRlLnNwZWVkO1xuICAgICAgICAgICAgICAgIGR1ZGUueSArPSBNYXRoLmNvcyhkdWRlLmRpcmVjdGlvbikgKiBkdWRlLnNwZWVkO1xuICAgICAgICAgICAgICAgIGR1ZGUucm90YXRpb24gPSAtZHVkZS5kaXJlY3Rpb24gLSBNYXRoLlBJIC8gMjtcbiAgICAgICAgICAgICAgICBpZiAoZHVkZS54IDwgdGhpcy5kdWRlQm91bmRzLngpIHtcbiAgICAgICAgICAgICAgICAgICAgZHVkZS54ICs9IHRoaXMuZHVkZUJvdW5kcy53aWR0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZHVkZS54ID4gdGhpcy5kdWRlQm91bmRzLnggKyB0aGlzLmR1ZGVCb3VuZHMud2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgZHVkZS54IC09IHRoaXMuZHVkZUJvdW5kcy53aWR0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGR1ZGUueSA8IHRoaXMuZHVkZUJvdW5kcy55KSB7XG4gICAgICAgICAgICAgICAgICAgIGR1ZGUueSArPSB0aGlzLmR1ZGVCb3VuZHMuaGVpZ2h0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChkdWRlLnkgPiB0aGlzLmR1ZGVCb3VuZHMueSArIHRoaXMuZHVkZUJvdW5kcy5oZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgZHVkZS55IC09IHRoaXMuZHVkZUJvdW5kcy5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmJhY2tDb2xvciA9IDB4RkZGMDAwO1xuICAgICAgICB0aGlzLmFjdGl2YXRlTWFzaygpO1xuICAgICAgICB0aGlzLmxvYWRlciA9IG5ldyBSZXNvdXJjZUxvYWRlcl8xLlJlc291cmNlTG9hZGVyKG5ldyBVUkxSZXF1ZXN0XzEuVVJMUmVxdWVzdChcImV4YW1wbGVzL2Fzc2V0cy9lZ2dIZWFkLnBuZ1wiKSk7XG4gICAgICAgIHRoaXMubG9hZGVyLmFkZEV2ZW50TGlzdGVuZXIoRXZlbnRfMS5FdmVudC5DT01QTEVURSwgdGhpcy5oYW5kbGVSZXNvdXJjZUxvYWRlZCk7XG4gICAgICAgIHRoaXMubG9hZGVyLmxvYWQoKTtcbiAgICB9XG4gICAgZGVzdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIuZGVzdHJ1Y3RvcigpO1xuICAgICAgICB0aGlzLmFwcC50aWNrZXIucmVtb3ZlKHRoaXMucnVuRXhhbXBsZSwgbnVsbCk7XG4gICAgICAgIHRoaXMuYWxpZW5zID0gbnVsbDtcbiAgICB9XG59XG5leHBvcnRzLkJhc2ljVGludGluZyA9IEJhc2ljVGludGluZztcbmNsYXNzIEV4dGVuZGVkU3ByaXRlIGV4dGVuZHMgU3ByaXRlXzEuU3ByaXRlIHtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgQmFzZUV4YW1wbGVfMSA9IHJlcXVpcmUoXCIuL0Jhc2VFeGFtcGxlXCIpO1xuY29uc3QgUmVzb3VyY2VMb2FkZXJfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9SZXNvdXJjZUxvYWRlclwiKTtcbmNvbnN0IFVSTFJlcXVlc3RfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9VUkxSZXF1ZXN0XCIpO1xuY29uc3QgRXZlbnRfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9FdmVudFwiKTtcbmNvbnN0IFRleHR1cmVfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9UZXh0dXJlXCIpO1xuY29uc3QgQmFzZVRleHR1cmVfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9CYXNlVGV4dHVyZVwiKTtcbmNvbnN0IFNwcml0ZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1Nwcml0ZVwiKTtcbmNvbnN0IENvbnRhaW5lcl8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0NvbnRhaW5lclwiKTtcbmNvbnN0IFJlY3RhbmdsZV8xID0gcmVxdWlyZShcIi4uL2ZsYXNoL2dlb20vUmVjdGFuZ2xlXCIpO1xuY29uc3QgRmlsdGVyXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvRmlsdGVyXCIpO1xuY29uc3QgUG9pbnRfMSA9IHJlcXVpcmUoXCIuLi9mbGFzaC9nZW9tL1BvaW50XCIpO1xuY2xhc3MgRmlsdGVyQmxlbmRpbmcgZXh0ZW5kcyBCYXNlRXhhbXBsZV8xLkJhc2VFeGFtcGxlIHtcbiAgICBjb25zdHJ1Y3RvcihhcHAsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgc3VwZXIoYXBwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgdGhpcy5oYW5kbGVHcmFzc0xvYWRlZCA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5iYWNrZ3JvdW5kdHh0ID0gbmV3IFRleHR1cmVfMS5UZXh0dXJlKG5ldyBCYXNlVGV4dHVyZV8xLkJhc2VUZXh0dXJlKHRoaXMubG9hZGVyLmltYWdlRGF0YSkpO1xuICAgICAgICAgICAgY29uc3QgYmFja2dyb3VuZCA9IG5ldyBTcHJpdGVfMS5TcHJpdGUodGhpcy5iYWNrZ3JvdW5kdHh0KTtcbiAgICAgICAgICAgIGJhY2tncm91bmQud2lkdGggPSB0aGlzLnNpemV3O1xuICAgICAgICAgICAgYmFja2dyb3VuZC5oZWlnaHQgPSB0aGlzLnNpemVoO1xuICAgICAgICAgICAgdGhpcy5zdGFnZS5hZGRDaGlsZChiYWNrZ3JvdW5kKTtcbiAgICAgICAgICAgIGNvbnN0IHNoYWRlckZyYWcgPSBgXG4gICAgICAgICAgICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XG4gICAgICAgICAgICB2YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcbiAgICAgICAgICAgIHVuaWZvcm0gdmVjMiBtb3VzZTtcbiAgICAgICAgICAgIHVuaWZvcm0gdmVjNCBpbnB1dFNpemU7XG4gICAgICAgICAgICB1bmlmb3JtIHZlYzQgb3V0cHV0RnJhbWU7XG4gICAgICAgICAgICB1bmlmb3JtIGZsb2F0IHRpbWU7XG4gICAgICAgICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgICAgICB2ZWMyIHNjcmVlblBvcyA9IHZUZXh0dXJlQ29vcmQgKiBpbnB1dFNpemUueHkgKyBvdXRwdXRGcmFtZS54eTtcbiAgICAgICAgICAgIGlmIChsZW5ndGgobW91c2UgLSBzY3JlZW5Qb3MpIDwgMjUuMCkge1xuICAgICAgICAgICAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoMS4wLCAxLjAsIDAuMCwgMS4wKSAqIDAuNzsgLy95ZWxsb3cgY2lyY2xlLCBhbHBoYT0wLjdcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCggc2luKHRpbWUpLCAobW91c2UueHkgLSBvdXRwdXRGcmFtZS54eSkgLyBvdXRwdXRGcmFtZS56dywgMS4wKSAqIDAuNTsgLy8gYmxlbmQgd2l0aCB1bmRlcmx5aW5nIGltYWdlLCBhbHBoYT0wLjVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGA7XG4gICAgICAgICAgICBjb25zdCBjb250YWluZXIgPSBuZXcgQ29udGFpbmVyXzEuQ29udGFpbmVyKCk7XG4gICAgICAgICAgICBjb250YWluZXIuZmlsdGVyQXJlYSA9IFJlY3RhbmdsZV8xLlJlY3RhbmdsZS5nZXRSZWN0YW5nbGUoMTAwLCAxMDAsIHRoaXMuc2l6ZXcgLSAyMDAsIHRoaXMuc2l6ZWggLSAyMDApO1xuICAgICAgICAgICAgdGhpcy5zdGFnZS5hZGRDaGlsZChjb250YWluZXIpO1xuICAgICAgICAgICAgdGhpcy5maWx0ZXIgPSBuZXcgRmlsdGVyXzEuRmlsdGVyKG51bGwsIHNoYWRlckZyYWcsIHtcbiAgICAgICAgICAgICAgICBtb3VzZTogUG9pbnRfMS5Qb2ludC5nZXRQb2ludCgpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnRhaW5lci5maWx0ZXJzID0gW3RoaXMuZmlsdGVyXTtcbiAgICAgICAgICAgIHRoaXMuYXBwLnRpY2tlci5hZGQodGhpcy5ydW5FeGFtcGxlKTtcbiAgICAgICAgICAgIHRoaXMuZXhhbXBsZVJlYWR5KCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucnVuRXhhbXBsZSA9IChkZWx0YSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5maWx0ZXIudW5pZm9ybXMubW91c2UuY29weUZyb20odGhpcy5hcHAucmVuZGVyZXIucGx1Z2lucy5pbnRlcmFjdGlvbi5tb3VzZS5nbG9iYWwpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmxvYWRlciA9IG5ldyBSZXNvdXJjZUxvYWRlcl8xLlJlc291cmNlTG9hZGVyKG5ldyBVUkxSZXF1ZXN0XzEuVVJMUmVxdWVzdChcImV4YW1wbGVzL2Fzc2V0cy9iZ19ncmFzcy5qcGdcIikpO1xuICAgICAgICB0aGlzLmxvYWRlci5hZGRFdmVudExpc3RlbmVyKEV2ZW50XzEuRXZlbnQuQ09NUExFVEUsIHRoaXMuaGFuZGxlR3Jhc3NMb2FkZWQpO1xuICAgICAgICB0aGlzLmxvYWRlci5sb2FkKCk7XG4gICAgfVxuICAgIGRlc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyLmRlc3RydWN0b3IoKTtcbiAgICAgICAgdGhpcy5iYWNrZ3JvdW5kdHh0LmRlc3Ryb3kobnVsbCk7XG4gICAgICAgIHRoaXMuYmFja2dyb3VuZHR4dCA9IG51bGw7XG4gICAgICAgIHRoaXMuZmlsdGVyLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5maWx0ZXIgPSBudWxsO1xuICAgICAgICB0aGlzLmFwcC50aWNrZXIucmVtb3ZlKHRoaXMucnVuRXhhbXBsZSwgbnVsbCk7XG4gICAgfVxufVxuZXhwb3J0cy5GaWx0ZXJCbGVuZGluZyA9IEZpbHRlckJsZW5kaW5nO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBCYXNlRXhhbXBsZV8xID0gcmVxdWlyZShcIi4vQmFzZUV4YW1wbGVcIik7XG5jb25zdCBSZXNvdXJjZUxvYWRlcl8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1Jlc291cmNlTG9hZGVyXCIpO1xuY29uc3QgVGV4dHVyZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1RleHR1cmVcIik7XG5jb25zdCBVUkxSZXF1ZXN0XzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvVVJMUmVxdWVzdFwiKTtcbmNvbnN0IEV2ZW50XzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvRXZlbnRcIik7XG5jb25zdCBCYXNlVGV4dHVyZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0Jhc2VUZXh0dXJlXCIpO1xuY29uc3QgU3ByaXRlXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvU3ByaXRlXCIpO1xuY29uc3QgQmx1ckZpbHRlcl8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0JsdXJGaWx0ZXJcIik7XG5jbGFzcyBGaWx0ZXJCbHVyIGV4dGVuZHMgQmFzZUV4YW1wbGVfMS5CYXNlRXhhbXBsZSB7XG4gICAgY29uc3RydWN0b3IoYXBwLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHN1cGVyKGFwcCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIHRoaXMuaGFuZGxlTW9ieUxvYWRlZCA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5tb2J5VHh0ID0gbmV3IFRleHR1cmVfMS5UZXh0dXJlKG5ldyBCYXNlVGV4dHVyZV8xLkJhc2VUZXh0dXJlKHRoaXMubG9hZGVyLmltYWdlRGF0YSkpO1xuICAgICAgICAgICAgY29uc3QgYmcgPSBuZXcgU3ByaXRlXzEuU3ByaXRlKHRoaXMuZGVwdGhUeHQpO1xuICAgICAgICAgICAgYmcud2lkdGggPSB0aGlzLnNpemV3O1xuICAgICAgICAgICAgYmcuaGVpZ2h0ID0gdGhpcy5zaXplaDtcbiAgICAgICAgICAgIHRoaXMuc3RhZ2UuYWRkQ2hpbGQoYmcpO1xuICAgICAgICAgICAgY29uc3QgbGl0dGxlRHVkZXMgPSBuZXcgU3ByaXRlXzEuU3ByaXRlKHRoaXMuZHVkZXNUeHQpO1xuICAgICAgICAgICAgbGl0dGxlRHVkZXMueCA9ICh0aGlzLnNpemV3IC8gMikgLSAzMTU7XG4gICAgICAgICAgICBsaXR0bGVEdWRlcy55ID0gMjAwO1xuICAgICAgICAgICAgdGhpcy5zdGFnZS5hZGRDaGlsZChsaXR0bGVEdWRlcyk7XG4gICAgICAgICAgICBjb25zdCBsaXR0bGVSb2JvdCA9IG5ldyBTcHJpdGVfMS5TcHJpdGUodGhpcy5tb2J5VHh0KTtcbiAgICAgICAgICAgIGxpdHRsZVJvYm90LnggPSAodGhpcy5zaXpldyAvIDIpIC0gMjAwO1xuICAgICAgICAgICAgbGl0dGxlUm9ib3QueSA9IDEwMDtcbiAgICAgICAgICAgIHRoaXMuc3RhZ2UuYWRkQ2hpbGQobGl0dGxlUm9ib3QpO1xuICAgICAgICAgICAgdGhpcy5ibHVyRmlsdGVyMSA9IG5ldyBCbHVyRmlsdGVyXzEuQmx1ckZpbHRlcigpO1xuICAgICAgICAgICAgdGhpcy5ibHVyRmlsdGVyMiA9IG5ldyBCbHVyRmlsdGVyXzEuQmx1ckZpbHRlcigpO1xuICAgICAgICAgICAgbGl0dGxlRHVkZXMuZmlsdGVycyA9IFt0aGlzLmJsdXJGaWx0ZXIxXTtcbiAgICAgICAgICAgIGxpdHRsZVJvYm90LmZpbHRlcnMgPSBbdGhpcy5ibHVyRmlsdGVyMl07XG4gICAgICAgICAgICB0aGlzLmNvdW50ID0gMDtcbiAgICAgICAgICAgIHRoaXMuYXBwLnRpY2tlci5hZGQodGhpcy5ydW5FeGFtcGxlKTtcbiAgICAgICAgICAgIHRoaXMuZXhhbXBsZVJlYWR5KCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucnVuRXhhbXBsZSA9IChkZWx0YSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5jb3VudCArPSAwLjAwNTtcbiAgICAgICAgICAgIGNvbnN0IGJsdXJBbW91bnQgPSBNYXRoLmNvcyh0aGlzLmNvdW50KTtcbiAgICAgICAgICAgIGNvbnN0IGJsdXJBbW91bnQyID0gTWF0aC5zaW4odGhpcy5jb3VudCk7XG4gICAgICAgICAgICB0aGlzLmJsdXJGaWx0ZXIxLmJsdXIgPSAyMCAqIChibHVyQW1vdW50KTtcbiAgICAgICAgICAgIHRoaXMuYmx1ckZpbHRlcjIuYmx1ciA9IDIwICogKGJsdXJBbW91bnQyKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVEdWRlc0xvYWRlZCA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5kdWRlc1R4dCA9IG5ldyBUZXh0dXJlXzEuVGV4dHVyZShuZXcgQmFzZVRleHR1cmVfMS5CYXNlVGV4dHVyZSh0aGlzLmxvYWRlci5pbWFnZURhdGEpKTtcbiAgICAgICAgICAgIHRoaXMubG9hZGVyID0gbmV3IFJlc291cmNlTG9hZGVyXzEuUmVzb3VyY2VMb2FkZXIobmV3IFVSTFJlcXVlc3RfMS5VUkxSZXF1ZXN0KFwiZXhhbXBsZXMvYXNzZXRzL3BpeGktZmlsdGVycy9kZXB0aF9ibHVyX21vYnkuanBnXCIpKTtcbiAgICAgICAgICAgIHRoaXMubG9hZGVyLmFkZEV2ZW50TGlzdGVuZXIoRXZlbnRfMS5FdmVudC5DT01QTEVURSwgdGhpcy5oYW5kbGVNb2J5TG9hZGVkKTtcbiAgICAgICAgICAgIHRoaXMubG9hZGVyLmxvYWQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVEZXB0aExvYWRlZCA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5kZXB0aFR4dCA9IG5ldyBUZXh0dXJlXzEuVGV4dHVyZShuZXcgQmFzZVRleHR1cmVfMS5CYXNlVGV4dHVyZSh0aGlzLmxvYWRlci5pbWFnZURhdGEpKTtcbiAgICAgICAgICAgIHRoaXMubG9hZGVyID0gbmV3IFJlc291cmNlTG9hZGVyXzEuUmVzb3VyY2VMb2FkZXIobmV3IFVSTFJlcXVlc3RfMS5VUkxSZXF1ZXN0KFwiZXhhbXBsZXMvYXNzZXRzL3BpeGktZmlsdGVycy9kZXB0aF9ibHVyX2R1ZGVzLmpwZ1wiKSk7XG4gICAgICAgICAgICB0aGlzLmxvYWRlci5hZGRFdmVudExpc3RlbmVyKEV2ZW50XzEuRXZlbnQuQ09NUExFVEUsIHRoaXMuaGFuZGxlRHVkZXNMb2FkZWQpO1xuICAgICAgICAgICAgdGhpcy5sb2FkZXIubG9hZCgpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmxvYWRlciA9IG5ldyBSZXNvdXJjZUxvYWRlcl8xLlJlc291cmNlTG9hZGVyKG5ldyBVUkxSZXF1ZXN0XzEuVVJMUmVxdWVzdChcImV4YW1wbGVzL2Fzc2V0cy9waXhpLWZpbHRlcnMvYmdfZGVwdGhfYmx1ci5qcGdcIikpO1xuICAgICAgICB0aGlzLmxvYWRlci5hZGRFdmVudExpc3RlbmVyKEV2ZW50XzEuRXZlbnQuQ09NUExFVEUsIHRoaXMuaGFuZGxlRGVwdGhMb2FkZWQpO1xuICAgICAgICB0aGlzLmxvYWRlci5sb2FkKCk7XG4gICAgfVxuICAgIGRlc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyLmRlc3RydWN0b3IoKTtcbiAgICAgICAgdGhpcy5hcHAudGlja2VyLnJlbW92ZSh0aGlzLnJ1bkV4YW1wbGUsIG51bGwpO1xuICAgICAgICB0aGlzLmJsdXJGaWx0ZXIxLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5ibHVyRmlsdGVyMSA9IG51bGw7XG4gICAgICAgIHRoaXMuYmx1ckZpbHRlcjIuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLmJsdXJGaWx0ZXIyID0gbnVsbDtcbiAgICAgICAgdGhpcy5tb2J5VHh0LmRlc3Ryb3kobnVsbCk7XG4gICAgICAgIHRoaXMubW9ieVR4dCA9IG51bGw7XG4gICAgICAgIHRoaXMuZHVkZXNUeHQuZGVzdHJveShudWxsKTtcbiAgICAgICAgdGhpcy5kdWRlc1R4dCA9IG51bGw7XG4gICAgICAgIHRoaXMuZGVwdGhUeHQuZGVzdHJveShudWxsKTtcbiAgICAgICAgdGhpcy5kZXB0aFR4dCA9IG51bGw7XG4gICAgfVxufVxuZXhwb3J0cy5GaWx0ZXJCbHVyID0gRmlsdGVyQmx1cjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgQmFzZUV4YW1wbGVfMSA9IHJlcXVpcmUoXCIuL0Jhc2VFeGFtcGxlXCIpO1xuY29uc3QgUmVzb3VyY2VMb2FkZXJfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9SZXNvdXJjZUxvYWRlclwiKTtcbmNvbnN0IFRleHR1cmVfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9UZXh0dXJlXCIpO1xuY29uc3QgVVJMUmVxdWVzdF8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1VSTFJlcXVlc3RcIik7XG5jb25zdCBFdmVudF8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0V2ZW50XCIpO1xuY29uc3QgQmFzZVRleHR1cmVfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9CYXNlVGV4dHVyZVwiKTtcbmNvbnN0IFNwcml0ZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1Nwcml0ZVwiKTtcbmNvbnN0IENvbG9yTWF0cml4RmlsdGVyXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvQ29sb3JNYXRyaXhGaWx0ZXJcIik7XG5jb25zdCBUZXh0XzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvVGV4dFwiKTtcbmNvbnN0IENvbnRhaW5lcl8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0NvbnRhaW5lclwiKTtcbmNvbnN0IE1vdXNlRXZlbnRfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9Nb3VzZUV2ZW50XCIpO1xuY2xhc3MgRmlsdGVyQ29sb3IgZXh0ZW5kcyBCYXNlRXhhbXBsZV8xLkJhc2VFeGFtcGxlIHtcbiAgICBjb25zdHJ1Y3RvcihhcHAsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgc3VwZXIoYXBwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgdGhpcy5oYW5kbGVQYW5kYUxvYWRlZCA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5wYW5kYVR4dCA9IG5ldyBUZXh0dXJlXzEuVGV4dHVyZShuZXcgQmFzZVRleHR1cmVfMS5CYXNlVGV4dHVyZSh0aGlzLmxvYWRlci5pbWFnZURhdGEpKTtcbiAgICAgICAgICAgIHRoaXMuYmcgPSBuZXcgU3ByaXRlXzEuU3ByaXRlKHRoaXMucm90YXRlVHh0KTtcbiAgICAgICAgICAgIHRoaXMuYmcuYW5jaG9yLnNldCgwLjUpO1xuICAgICAgICAgICAgdGhpcy5iZy54ID0gdGhpcy5zaXpldyAvIDI7XG4gICAgICAgICAgICB0aGlzLmJnLnkgPSB0aGlzLnNpemVoIC8gMjtcbiAgICAgICAgICAgIHRoaXMuZmlsdGVyID0gbmV3IENvbG9yTWF0cml4RmlsdGVyXzEuQ29sb3JNYXRyaXhGaWx0ZXIoKTtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IG5ldyBDb250YWluZXJfMS5Db250YWluZXIoKTtcbiAgICAgICAgICAgIGNvbnRhaW5lci54ID0gdGhpcy5zaXpldyAvIDI7XG4gICAgICAgICAgICBjb250YWluZXIueSA9IHRoaXMuc2l6ZWggLyAyO1xuICAgICAgICAgICAgdGhpcy5iZ0Zyb250ID0gbmV3IFNwcml0ZV8xLlNwcml0ZSh0aGlzLnNjZW5lcm90YXRlVHh0KTtcbiAgICAgICAgICAgIHRoaXMuYmdGcm9udC5hbmNob3Iuc2V0KDAuNSk7XG4gICAgICAgICAgICBjb250YWluZXIuYWRkQ2hpbGQodGhpcy5iZ0Zyb250KTtcbiAgICAgICAgICAgIHRoaXMubGlnaHQyID0gbmV3IFNwcml0ZV8xLlNwcml0ZSh0aGlzLmxpZ2h0cm90YXRlMlR4dCk7XG4gICAgICAgICAgICB0aGlzLmxpZ2h0Mi5hbmNob3Iuc2V0KDAuNSk7XG4gICAgICAgICAgICBjb250YWluZXIuYWRkQ2hpbGQodGhpcy5saWdodDIpO1xuICAgICAgICAgICAgdGhpcy5saWdodDEgPSBuZXcgU3ByaXRlXzEuU3ByaXRlKHRoaXMubGlnaHRyb3RhdGUxVHh0KTtcbiAgICAgICAgICAgIHRoaXMubGlnaHQxLmFuY2hvci5zZXQoMC41KTtcbiAgICAgICAgICAgIGNvbnRhaW5lci5hZGRDaGlsZCh0aGlzLmxpZ2h0MSk7XG4gICAgICAgICAgICB0aGlzLnBhbmRhID0gbmV3IFNwcml0ZV8xLlNwcml0ZSh0aGlzLnBhbmRhVHh0KTtcbiAgICAgICAgICAgIHRoaXMucGFuZGEuYW5jaG9yLnNldCgwLjUpO1xuICAgICAgICAgICAgY29udGFpbmVyLmFkZENoaWxkKHRoaXMucGFuZGEpO1xuICAgICAgICAgICAgdGhpcy5zdGFnZS5hZGRDaGlsZChjb250YWluZXIpO1xuICAgICAgICAgICAgdGhpcy5zdGFnZS5maWx0ZXJzID0gW3RoaXMuZmlsdGVyXTtcbiAgICAgICAgICAgIHRoaXMuY291bnQgPSAwO1xuICAgICAgICAgICAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuc3RhZ2UuYWRkRXZlbnRMaXN0ZW5lcihNb3VzZUV2ZW50XzEuTW91c2VFdmVudC5QT0lOVEVSX1RBUCwgdGhpcy5oYW5kbGVQb2ludGVyKTtcbiAgICAgICAgICAgIGNvbnN0IGhlbHAgPSBuZXcgVGV4dF8xLlRleHQoJ0NsaWNrIG9yIHRhcCB0byB0dXJuIGZpbHRlcnMgb24gLyBvZmYuJywge1xuICAgICAgICAgICAgICAgIGZvbnRGYW1pbHk6ICdBcmlhbCcsXG4gICAgICAgICAgICAgICAgZm9udFNpemU6IDEyLFxuICAgICAgICAgICAgICAgIGZvbnRXZWlnaHQ6ICdib2xkJyxcbiAgICAgICAgICAgICAgICBmaWxsOiAnd2hpdGUnLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBoZWxwLnkgPSB0aGlzLnNpemVoIC0gMjU7XG4gICAgICAgICAgICBoZWxwLnggPSAxMDtcbiAgICAgICAgICAgIHRoaXMuc3RhZ2UuYWRkQ2hpbGQoaGVscCk7XG4gICAgICAgICAgICB0aGlzLmFwcC50aWNrZXIuYWRkKHRoaXMucnVuRXhhbXBsZSk7XG4gICAgICAgICAgICB0aGlzLmV4YW1wbGVSZWFkeSgpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnJ1bkV4YW1wbGUgPSAoZGVsdGEpID0+IHtcbiAgICAgICAgICAgIHRoaXMuYmcucm90YXRpb24gKz0gMC4wMTtcbiAgICAgICAgICAgIHRoaXMuYmdGcm9udC5yb3RhdGlvbiAtPSAwLjAxO1xuICAgICAgICAgICAgdGhpcy5saWdodDEucm90YXRpb24gKz0gMC4wMjtcbiAgICAgICAgICAgIHRoaXMubGlnaHQyLnJvdGF0aW9uICs9IDAuMDE7XG4gICAgICAgICAgICB0aGlzLnBhbmRhLnNjYWxlLnggPSAxICsgTWF0aC5zaW4odGhpcy5jb3VudCkgKiAwLjA0O1xuICAgICAgICAgICAgdGhpcy5wYW5kYS5zY2FsZS55ID0gMSArIE1hdGguY29zKHRoaXMuY291bnQpICogMC4wNDtcbiAgICAgICAgICAgIHRoaXMuY291bnQgKz0gMC4xO1xuICAgICAgICAgICAgY29uc3QgeyBtYXRyaXggfSA9IHRoaXMuZmlsdGVyO1xuICAgICAgICAgICAgbWF0cml4WzFdID0gTWF0aC5zaW4odGhpcy5jb3VudCkgKiAzO1xuICAgICAgICAgICAgbWF0cml4WzJdID0gTWF0aC5jb3ModGhpcy5jb3VudCk7XG4gICAgICAgICAgICBtYXRyaXhbM10gPSBNYXRoLmNvcyh0aGlzLmNvdW50KSAqIDEuNTtcbiAgICAgICAgICAgIG1hdHJpeFs0XSA9IE1hdGguc2luKHRoaXMuY291bnQgLyAzKSAqIDI7XG4gICAgICAgICAgICBtYXRyaXhbNV0gPSBNYXRoLnNpbih0aGlzLmNvdW50IC8gMik7XG4gICAgICAgICAgICBtYXRyaXhbNl0gPSBNYXRoLnNpbih0aGlzLmNvdW50IC8gNCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlUG9pbnRlciA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5lbmFibGVkID0gIXRoaXMuZW5hYmxlZDtcbiAgICAgICAgICAgIHRoaXMuc3RhZ2UuZmlsdGVycyA9IHRoaXMuZW5hYmxlZCA/IFt0aGlzLmZpbHRlcl0gOiBudWxsO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZUxpZ2h0Um90YXRlMUxvYWRlZCA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5saWdodHJvdGF0ZTFUeHQgPSBuZXcgVGV4dHVyZV8xLlRleHR1cmUobmV3IEJhc2VUZXh0dXJlXzEuQmFzZVRleHR1cmUodGhpcy5sb2FkZXIuaW1hZ2VEYXRhKSk7XG4gICAgICAgICAgICB0aGlzLmxvYWRlciA9IG5ldyBSZXNvdXJjZUxvYWRlcl8xLlJlc291cmNlTG9hZGVyKG5ldyBVUkxSZXF1ZXN0XzEuVVJMUmVxdWVzdChcImV4YW1wbGVzL2Fzc2V0cy9saWdodF9yb3RhdGVfMS5wbmdcIikpO1xuICAgICAgICAgICAgdGhpcy5sb2FkZXIuYWRkRXZlbnRMaXN0ZW5lcihFdmVudF8xLkV2ZW50LkNPTVBMRVRFLCB0aGlzLmhhbmRsZUxpZ2h0Um90YXRlMUxvYWRlZCk7XG4gICAgICAgICAgICB0aGlzLmxvYWRlci5sb2FkKCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlUm90YXRlTG9hZGVkID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnJvdGF0ZVR4dCA9IG5ldyBUZXh0dXJlXzEuVGV4dHVyZShuZXcgQmFzZVRleHR1cmVfMS5CYXNlVGV4dHVyZSh0aGlzLmxvYWRlci5pbWFnZURhdGEpKTtcbiAgICAgICAgICAgIHRoaXMubG9hZGVyID0gbmV3IFJlc291cmNlTG9hZGVyXzEuUmVzb3VyY2VMb2FkZXIobmV3IFVSTFJlcXVlc3RfMS5VUkxSZXF1ZXN0KFwiZXhhbXBsZXMvYXNzZXRzL2JnX3NjZW5lX3JvdGF0ZS5qcGdcIikpO1xuICAgICAgICAgICAgdGhpcy5sb2FkZXIuYWRkRXZlbnRMaXN0ZW5lcihFdmVudF8xLkV2ZW50LkNPTVBMRVRFLCB0aGlzLmhhbmRsZVNjZW5lUm90YXRlTG9hZGVkKTtcbiAgICAgICAgICAgIHRoaXMubG9hZGVyLmxvYWQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVTY2VuZVJvdGF0ZUxvYWRlZCA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zY2VuZXJvdGF0ZVR4dCA9IG5ldyBUZXh0dXJlXzEuVGV4dHVyZShuZXcgQmFzZVRleHR1cmVfMS5CYXNlVGV4dHVyZSh0aGlzLmxvYWRlci5pbWFnZURhdGEpKTtcbiAgICAgICAgICAgIHRoaXMubG9hZGVyID0gbmV3IFJlc291cmNlTG9hZGVyXzEuUmVzb3VyY2VMb2FkZXIobmV3IFVSTFJlcXVlc3RfMS5VUkxSZXF1ZXN0KFwiZXhhbXBsZXMvYXNzZXRzL2xpZ2h0X3JvdGF0ZV8yLnBuZ1wiKSk7XG4gICAgICAgICAgICB0aGlzLmxvYWRlci5hZGRFdmVudExpc3RlbmVyKEV2ZW50XzEuRXZlbnQuQ09NUExFVEUsIHRoaXMuaGFuZGxlTGlnaHRSb3RhdGUyTG9hZGVkKTtcbiAgICAgICAgICAgIHRoaXMubG9hZGVyLmxvYWQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVMaWdodFJvdGF0ZTJMb2FkZWQgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIHRoaXMubGlnaHRyb3RhdGUyVHh0ID0gbmV3IFRleHR1cmVfMS5UZXh0dXJlKG5ldyBCYXNlVGV4dHVyZV8xLkJhc2VUZXh0dXJlKHRoaXMubG9hZGVyLmltYWdlRGF0YSkpO1xuICAgICAgICAgICAgdGhpcy5sb2FkZXIgPSBuZXcgUmVzb3VyY2VMb2FkZXJfMS5SZXNvdXJjZUxvYWRlcihuZXcgVVJMUmVxdWVzdF8xLlVSTFJlcXVlc3QoXCJleGFtcGxlcy9hc3NldHMvcGFuZGEucG5nXCIpKTtcbiAgICAgICAgICAgIHRoaXMubG9hZGVyLmFkZEV2ZW50TGlzdGVuZXIoRXZlbnRfMS5FdmVudC5DT01QTEVURSwgdGhpcy5oYW5kbGVQYW5kYUxvYWRlZCk7XG4gICAgICAgICAgICB0aGlzLmxvYWRlci5sb2FkKCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuYmFja0NvbG9yID0gMDtcbiAgICAgICAgdGhpcy5hY3RpdmF0ZU1hc2soKTtcbiAgICAgICAgdGhpcy5zdGFnZS5pbnRlcmFjdGl2ZSA9IHRydWU7XG4gICAgICAgIHRoaXMubG9hZGVyID0gbmV3IFJlc291cmNlTG9hZGVyXzEuUmVzb3VyY2VMb2FkZXIobmV3IFVSTFJlcXVlc3RfMS5VUkxSZXF1ZXN0KFwiZXhhbXBsZXMvYXNzZXRzL2JnX3JvdGF0ZS5qcGdcIikpO1xuICAgICAgICB0aGlzLmxvYWRlci5hZGRFdmVudExpc3RlbmVyKEV2ZW50XzEuRXZlbnQuQ09NUExFVEUsIHRoaXMuaGFuZGxlUm90YXRlTG9hZGVkKTtcbiAgICAgICAgdGhpcy5sb2FkZXIubG9hZCgpO1xuICAgIH1cbiAgICBkZXN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlci5kZXN0cnVjdG9yKCk7XG4gICAgICAgIGlmICh0aGlzLmJnKSB7XG4gICAgICAgICAgICB0aGlzLmJnLmRlc3RydWN0b3IoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJnID0gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMuYmdGcm9udCkge1xuICAgICAgICAgICAgdGhpcy5iZ0Zyb250LmRlc3RydWN0b3IoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJnRnJvbnQgPSBudWxsO1xuICAgICAgICBpZiAodGhpcy5saWdodDIpIHtcbiAgICAgICAgICAgIHRoaXMubGlnaHQyLmRlc3RydWN0b3IoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxpZ2h0MiA9IG51bGw7XG4gICAgICAgIGlmICh0aGlzLnBhbmRhKSB7XG4gICAgICAgICAgICB0aGlzLnBhbmRhLmRlc3RydWN0b3IoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBhbmRhID0gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMubGlnaHQxKSB7XG4gICAgICAgICAgICB0aGlzLmxpZ2h0MS5kZXN0cnVjdG9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5saWdodDEgPSBudWxsO1xuICAgICAgICBpZiAodGhpcy5maWx0ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuZmlsdGVyLmRlc3RydWN0b3IoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZpbHRlciA9IG51bGw7XG4gICAgICAgIHRoaXMuYXBwLnRpY2tlci5yZW1vdmUodGhpcy5ydW5FeGFtcGxlLCBudWxsKTtcbiAgICAgICAgaWYgKHRoaXMucm90YXRlVHh0KSB7XG4gICAgICAgICAgICB0aGlzLnJvdGF0ZVR4dC5kZXN0cnVjdG9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yb3RhdGVUeHQgPSBudWxsO1xuICAgICAgICBpZiAodGhpcy5zY2VuZXJvdGF0ZVR4dCkge1xuICAgICAgICAgICAgdGhpcy5zY2VuZXJvdGF0ZVR4dC5kZXN0cnVjdG9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zY2VuZXJvdGF0ZVR4dCA9IG51bGw7XG4gICAgICAgIGlmICh0aGlzLmxpZ2h0cm90YXRlMlR4dCkge1xuICAgICAgICAgICAgdGhpcy5saWdodHJvdGF0ZTJUeHQuZGVzdHJ1Y3RvcigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubGlnaHRyb3RhdGUyVHh0ID0gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMubGlnaHRyb3RhdGUxVHh0KSB7XG4gICAgICAgICAgICB0aGlzLmxpZ2h0cm90YXRlMVR4dC5kZXN0cnVjdG9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5saWdodHJvdGF0ZTFUeHQgPSBudWxsO1xuICAgICAgICBpZiAodGhpcy5wYW5kYVR4dCkge1xuICAgICAgICAgICAgdGhpcy5wYW5kYVR4dC5kZXN0cnVjdG9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wYW5kYVR4dCA9IG51bGw7XG4gICAgfVxufVxuZXhwb3J0cy5GaWx0ZXJDb2xvciA9IEZpbHRlckNvbG9yO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBCYXNlRXhhbXBsZV8xID0gcmVxdWlyZShcIi4vQmFzZUV4YW1wbGVcIik7XG5jb25zdCBSZXNvdXJjZUxvYWRlcl8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1Jlc291cmNlTG9hZGVyXCIpO1xuY29uc3QgVGV4dHVyZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1RleHR1cmVcIik7XG5jb25zdCBDb250YWluZXJfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9Db250YWluZXJcIik7XG5jb25zdCBSZWN0YW5nbGVfMSA9IHJlcXVpcmUoXCIuLi9mbGFzaC9nZW9tL1JlY3RhbmdsZVwiKTtcbmNvbnN0IE1vdXNlRXZlbnRfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9Nb3VzZUV2ZW50XCIpO1xuY29uc3QgU3ByaXRlXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvU3ByaXRlXCIpO1xuY29uc3QgVVJMUmVxdWVzdF8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1VSTFJlcXVlc3RcIik7XG5jb25zdCBFdmVudF8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0V2ZW50XCIpO1xuY29uc3QgQmFzZVRleHR1cmVfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9CYXNlVGV4dHVyZVwiKTtcbmNvbnN0IFBvaW50XzEgPSByZXF1aXJlKFwiLi4vZmxhc2gvZ2VvbS9Qb2ludFwiKTtcbmNvbnN0IERpc3BsYWNlbWVudEZpbHRlcl8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0Rpc3BsYWNlbWVudEZpbHRlclwiKTtcbmNsYXNzIEZpbHRlckNyYXdsaWVzIGV4dGVuZHMgQmFzZUV4YW1wbGVfMS5CYXNlRXhhbXBsZSB7XG4gICAgY29uc3RydWN0b3IoYXBwLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHN1cGVyKGFwcCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIHRoaXMuaGFuZGxlR3Jhc3NMb2FkZWQgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZ3Jhc3NUeHQgPSBuZXcgVGV4dHVyZV8xLlRleHR1cmUobmV3IEJhc2VUZXh0dXJlXzEuQmFzZVRleHR1cmUodGhpcy5sb2FkZXIuaW1hZ2VEYXRhKSk7XG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lciA9IG5ldyBDb250YWluZXJfMS5Db250YWluZXIoKTtcbiAgICAgICAgICAgIHRoaXMuc3RhZ2UuYWRkQ2hpbGQodGhpcy5jb250YWluZXIpO1xuICAgICAgICAgICAgY29uc3QgcGFkZGluZyA9IDEwMDtcbiAgICAgICAgICAgIHRoaXMuYm91bmRzID0gUmVjdGFuZ2xlXzEuUmVjdGFuZ2xlLmdldFJlY3RhbmdsZSgtcGFkZGluZywgLXBhZGRpbmcsIHRoaXMuc2l6ZXcgKyBwYWRkaW5nICogMiwgdGhpcy5zaXplaCArIHBhZGRpbmcgKiAyKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMjA7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1hZ2dvdCA9IG5ldyBFeHRlbmRlZFNwcml0ZSh0aGlzLm1hZ2dvdFR4dCk7XG4gICAgICAgICAgICAgICAgbWFnZ290LmFuY2hvci5zZXQoMC41KTtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5hZGRDaGlsZChtYWdnb3QpO1xuICAgICAgICAgICAgICAgIG1hZ2dvdC5kaXJlY3Rpb24gPSBNYXRoLnJhbmRvbSgpICogTWF0aC5QSSAqIDI7XG4gICAgICAgICAgICAgICAgbWFnZ290LnNwZWVkID0gMTtcbiAgICAgICAgICAgICAgICBtYWdnb3QudHVyblNwZWVkID0gTWF0aC5yYW5kb20oKSAtIDAuODtcbiAgICAgICAgICAgICAgICBtYWdnb3QueCA9IE1hdGgucmFuZG9tKCkgKiB0aGlzLmJvdW5kcy53aWR0aDtcbiAgICAgICAgICAgICAgICBtYWdnb3QueSA9IE1hdGgucmFuZG9tKCkgKiB0aGlzLmJvdW5kcy5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgbWFnZ290LnNjYWxlLnNldCgxICsgTWF0aC5yYW5kb20oKSAqIDAuMyk7XG4gICAgICAgICAgICAgICAgbWFnZ290Lm9yaWdpbmFsID0gUG9pbnRfMS5Qb2ludC5nZXRQb2ludCgpO1xuICAgICAgICAgICAgICAgIG1hZ2dvdC5vcmlnaW5hbC5jb3B5RnJvbShtYWdnb3Quc2NhbGUpO1xuICAgICAgICAgICAgICAgIHRoaXMubWFnZ290cy5wdXNoKG1hZ2dvdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmRpc3BsYWNlbWVudFNwcml0ZSA9IG5ldyBTcHJpdGVfMS5TcHJpdGUodGhpcy5kaXNwbGFjZW1lbnRUeHQpO1xuICAgICAgICAgICAgY29uc3QgZGlzcGxhY2VtZW50RmlsdGVyID0gbmV3IERpc3BsYWNlbWVudEZpbHRlcl8xLkRpc3BsYWNlbWVudEZpbHRlcih0aGlzLmRpc3BsYWNlbWVudFNwcml0ZSk7XG4gICAgICAgICAgICB0aGlzLnN0YWdlLmFkZENoaWxkKHRoaXMuZGlzcGxhY2VtZW50U3ByaXRlKTtcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLmZpbHRlcnMgPSBbZGlzcGxhY2VtZW50RmlsdGVyXTtcbiAgICAgICAgICAgIGRpc3BsYWNlbWVudEZpbHRlci5zY2FsZS54ID0gMTEwO1xuICAgICAgICAgICAgZGlzcGxhY2VtZW50RmlsdGVyLnNjYWxlLnkgPSAxMTA7XG4gICAgICAgICAgICB0aGlzLmRpc3BsYWNlbWVudFNwcml0ZS5hbmNob3Iuc2V0KDAuNSk7XG4gICAgICAgICAgICB0aGlzLnJpbmcgPSBuZXcgU3ByaXRlXzEuU3ByaXRlKHRoaXMucmluZ1R4dCk7XG4gICAgICAgICAgICB0aGlzLnJpbmcuYW5jaG9yLnNldCgwLjUpO1xuICAgICAgICAgICAgdGhpcy5yaW5nLnZpc2libGUgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuc3RhZ2UuYWRkQ2hpbGQodGhpcy5yaW5nKTtcbiAgICAgICAgICAgIGNvbnN0IGJnID0gbmV3IFNwcml0ZV8xLlNwcml0ZSh0aGlzLmdyYXNzVHh0KTtcbiAgICAgICAgICAgIGJnLndpZHRoID0gdGhpcy5zaXpldztcbiAgICAgICAgICAgIGJnLmhlaWdodCA9IHRoaXMuc2l6ZWg7XG4gICAgICAgICAgICBiZy5hbHBoYSA9IDAuNDtcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLmFkZENoaWxkKGJnKTtcbiAgICAgICAgICAgIHRoaXMuc3RhZ2UuYWRkRXZlbnRMaXN0ZW5lcihNb3VzZUV2ZW50XzEuTW91c2VFdmVudC5NT1VTRV9NT1ZFLCB0aGlzLm9uUG9pbnRlck1vdmUpO1xuICAgICAgICAgICAgdGhpcy5zdGFnZS5hZGRFdmVudExpc3RlbmVyKE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50LlRPVUNIX01PVkUsIHRoaXMub25Qb2ludGVyTW92ZSk7XG4gICAgICAgICAgICB0aGlzLmFwcC50aWNrZXIuYWRkKHRoaXMucnVuRXhhbXBsZSk7XG4gICAgICAgICAgICB0aGlzLmV4YW1wbGVSZWFkeSgpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZU1hZ2dvdExvYWRlZCA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5tYWdnb3RUeHQgPSBuZXcgVGV4dHVyZV8xLlRleHR1cmUobmV3IEJhc2VUZXh0dXJlXzEuQmFzZVRleHR1cmUodGhpcy5sb2FkZXIuaW1hZ2VEYXRhKSk7XG4gICAgICAgICAgICB0aGlzLmxvYWRlciA9IG5ldyBSZXNvdXJjZUxvYWRlcl8xLlJlc291cmNlTG9hZGVyKG5ldyBVUkxSZXF1ZXN0XzEuVVJMUmVxdWVzdCgnZXhhbXBsZXMvYXNzZXRzL2JnX2dyYXNzLmpwZycpKTtcbiAgICAgICAgICAgIHRoaXMubG9hZGVyLmFkZEV2ZW50TGlzdGVuZXIoRXZlbnRfMS5FdmVudC5DT01QTEVURSwgdGhpcy5oYW5kbGVHcmFzc0xvYWRlZCk7XG4gICAgICAgICAgICB0aGlzLmxvYWRlci5sb2FkKCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlUmluZ0xvYWRlZCA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5yaW5nVHh0ID0gbmV3IFRleHR1cmVfMS5UZXh0dXJlKG5ldyBCYXNlVGV4dHVyZV8xLkJhc2VUZXh0dXJlKHRoaXMubG9hZGVyLmltYWdlRGF0YSkpO1xuICAgICAgICAgICAgdGhpcy5sb2FkZXIgPSBuZXcgUmVzb3VyY2VMb2FkZXJfMS5SZXNvdXJjZUxvYWRlcihuZXcgVVJMUmVxdWVzdF8xLlVSTFJlcXVlc3QoJ2V4YW1wbGVzL2Fzc2V0cy9tYWdnb3QucG5nJykpO1xuICAgICAgICAgICAgdGhpcy5sb2FkZXIuYWRkRXZlbnRMaXN0ZW5lcihFdmVudF8xLkV2ZW50LkNPTVBMRVRFLCB0aGlzLmhhbmRsZU1hZ2dvdExvYWRlZCk7XG4gICAgICAgICAgICB0aGlzLmxvYWRlci5sb2FkKCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlRGlzcGxhY2VtZW50TG9hZGVkID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICB0aGlzLmRpc3BsYWNlbWVudFR4dCA9IG5ldyBUZXh0dXJlXzEuVGV4dHVyZShuZXcgQmFzZVRleHR1cmVfMS5CYXNlVGV4dHVyZSh0aGlzLmxvYWRlci5pbWFnZURhdGEpKTtcbiAgICAgICAgICAgIHRoaXMubG9hZGVyID0gbmV3IFJlc291cmNlTG9hZGVyXzEuUmVzb3VyY2VMb2FkZXIobmV3IFVSTFJlcXVlc3RfMS5VUkxSZXF1ZXN0KCdleGFtcGxlcy9hc3NldHMvcGl4aS1maWx0ZXJzL3JpbmcucG5nJykpO1xuICAgICAgICAgICAgdGhpcy5sb2FkZXIuYWRkRXZlbnRMaXN0ZW5lcihFdmVudF8xLkV2ZW50LkNPTVBMRVRFLCB0aGlzLmhhbmRsZVJpbmdMb2FkZWQpO1xuICAgICAgICAgICAgdGhpcy5sb2FkZXIubG9hZCgpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZVJvdGF0ZUxvYWRlZCA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5tYWdnb3RUeHQgPSBuZXcgVGV4dHVyZV8xLlRleHR1cmUobmV3IEJhc2VUZXh0dXJlXzEuQmFzZVRleHR1cmUodGhpcy5sb2FkZXIuaW1hZ2VEYXRhKSk7XG4gICAgICAgICAgICB0aGlzLmxvYWRlciA9IG5ldyBSZXNvdXJjZUxvYWRlcl8xLlJlc291cmNlTG9hZGVyKG5ldyBVUkxSZXF1ZXN0XzEuVVJMUmVxdWVzdCgnZXhhbXBsZXMvYXNzZXRzL3BpeGktZmlsdGVycy9kaXNwbGFjZS5wbmcnKSk7XG4gICAgICAgICAgICB0aGlzLmxvYWRlci5hZGRFdmVudExpc3RlbmVyKEV2ZW50XzEuRXZlbnQuQ09NUExFVEUsIHRoaXMuaGFuZGxlRGlzcGxhY2VtZW50TG9hZGVkKTtcbiAgICAgICAgICAgIHRoaXMubG9hZGVyLmxvYWQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vblBvaW50ZXJNb3ZlID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnJpbmcudmlzaWJsZSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmRpc3BsYWNlbWVudFNwcml0ZS5wb3NpdGlvbi5zZXQoZXZlbnQuZGF0YS5nbG9iYWwueCAtIDI1LCBldmVudC5kYXRhLmdsb2JhbC55KTtcbiAgICAgICAgICAgIHRoaXMucmluZy5wb3NpdGlvbi5jb3B5RnJvbSh0aGlzLmRpc3BsYWNlbWVudFNwcml0ZS5wb3NpdGlvbik7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucnVuRXhhbXBsZSA9IChkZWx0YSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5jb3VudCArPSAwLjA1O1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm1hZ2dvdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtYWdnb3QgPSB0aGlzLm1hZ2dvdHNbaV07XG4gICAgICAgICAgICAgICAgbWFnZ290LmRpcmVjdGlvbiArPSBtYWdnb3QudHVyblNwZWVkICogMC4wMTtcbiAgICAgICAgICAgICAgICBtYWdnb3QueCArPSBNYXRoLnNpbihtYWdnb3QuZGlyZWN0aW9uKSAqIG1hZ2dvdC5zcGVlZDtcbiAgICAgICAgICAgICAgICBtYWdnb3QueSArPSBNYXRoLmNvcyhtYWdnb3QuZGlyZWN0aW9uKSAqIG1hZ2dvdC5zcGVlZDtcbiAgICAgICAgICAgICAgICBtYWdnb3Qucm90YXRpb24gPSAtbWFnZ290LmRpcmVjdGlvbiAtIE1hdGguUEkgLyAyO1xuICAgICAgICAgICAgICAgIG1hZ2dvdC5zY2FsZS54ID0gbWFnZ290Lm9yaWdpbmFsLnggKyBNYXRoLnNpbih0aGlzLmNvdW50KSAqIDAuMjtcbiAgICAgICAgICAgICAgICBpZiAobWFnZ290LnggPCB0aGlzLmJvdW5kcy54KSB7XG4gICAgICAgICAgICAgICAgICAgIG1hZ2dvdC54ICs9IHRoaXMuYm91bmRzLndpZHRoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChtYWdnb3QueCA+IHRoaXMuYm91bmRzLnggKyB0aGlzLmJvdW5kcy53aWR0aCkge1xuICAgICAgICAgICAgICAgICAgICBtYWdnb3QueCAtPSB0aGlzLmJvdW5kcy53aWR0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG1hZ2dvdC55IDwgdGhpcy5ib3VuZHMueSkge1xuICAgICAgICAgICAgICAgICAgICBtYWdnb3QueSArPSB0aGlzLmJvdW5kcy5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1hZ2dvdC55ID4gdGhpcy5ib3VuZHMueSArIHRoaXMuYm91bmRzLmhlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICBtYWdnb3QueSAtPSB0aGlzLmJvdW5kcy5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmFjdGl2YXRlTWFzaygpO1xuICAgICAgICB0aGlzLmNvdW50ID0gMDtcbiAgICAgICAgdGhpcy5tYWdnb3RzID0gW107XG4gICAgICAgIHRoaXMuc3RhZ2UuaW50ZXJhY3RpdmUgPSB0cnVlO1xuICAgICAgICB0aGlzLmxvYWRlciA9IG5ldyBSZXNvdXJjZUxvYWRlcl8xLlJlc291cmNlTG9hZGVyKG5ldyBVUkxSZXF1ZXN0XzEuVVJMUmVxdWVzdChcImV4YW1wbGVzL2Fzc2V0cy9iZ19yb3RhdGUuanBnXCIpKTtcbiAgICAgICAgdGhpcy5sb2FkZXIuYWRkRXZlbnRMaXN0ZW5lcihFdmVudF8xLkV2ZW50LkNPTVBMRVRFLCB0aGlzLmhhbmRsZVJvdGF0ZUxvYWRlZCk7XG4gICAgICAgIHRoaXMubG9hZGVyLmxvYWQoKTtcbiAgICB9XG4gICAgZGVzdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIuZGVzdHJ1Y3RvcigpO1xuICAgICAgICB0aGlzLm1hZ2dvdFR4dC5kZXN0cm95KG51bGwpO1xuICAgICAgICB0aGlzLm1hZ2dvdFR4dCA9IG51bGw7XG4gICAgICAgIHRoaXMuZGlzcGxhY2VtZW50VHh0LmRlc3Ryb3kobnVsbCk7XG4gICAgICAgIHRoaXMuZGlzcGxhY2VtZW50VHh0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5yaW5nVHh0LmRlc3Ryb3kobnVsbCk7XG4gICAgICAgIHRoaXMucmluZ1R4dCA9IG51bGw7XG4gICAgICAgIHRoaXMuZ3Jhc3NUeHQuZGVzdHJveShudWxsKTtcbiAgICAgICAgdGhpcy5ncmFzc1R4dCA9IG51bGw7XG4gICAgICAgIGlmICh0aGlzLm1hZ2dvdHMgJiYgdGhpcy5tYWdnb3RzLmxlbmd0aCkge1xuICAgICAgICAgICAgd2hpbGUgKHRoaXMubWFnZ290cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBsZXQgbWFnZ290ID0gdGhpcy5tYWdnb3RzLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgbWFnZ290LmRlc3RydWN0b3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1hZ2dvdHMgPSBudWxsO1xuICAgICAgICB0aGlzLnJpbmcuZGVzdHJveShudWxsKTtcbiAgICAgICAgdGhpcy5yaW5nID0gbnVsbDtcbiAgICAgICAgdGhpcy5hcHAudGlja2VyLnJlbW92ZSh0aGlzLnJ1bkV4YW1wbGUsIG51bGwpO1xuICAgICAgICB0aGlzLmRpc3BsYWNlbWVudFNwcml0ZS5kZXN0cm95KG51bGwpO1xuICAgICAgICB0aGlzLmRpc3BsYWNlbWVudFNwcml0ZSA9IG51bGw7XG4gICAgICAgIHRoaXMuY29udGFpbmVyLmRlc3Ryb3kobnVsbCk7XG4gICAgICAgIHRoaXMuY29udGFpbmVyID0gbnVsbDtcbiAgICB9XG59XG5leHBvcnRzLkZpbHRlckNyYXdsaWVzID0gRmlsdGVyQ3Jhd2xpZXM7XG5jbGFzcyBFeHRlbmRlZFNwcml0ZSBleHRlbmRzIFNwcml0ZV8xLlNwcml0ZSB7XG4gICAgZGVzdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIuZGVzdHJ1Y3RvcigpO1xuICAgICAgICBpZiAodGhpcy5vcmlnaW5hbCkge1xuICAgICAgICAgICAgdGhpcy5vcmlnaW5hbC5yZWN5Y2xlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vcmlnaW5hbCA9IG51bGw7XG4gICAgfVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBCYXNlRXhhbXBsZV8xID0gcmVxdWlyZShcIi4vQmFzZUV4YW1wbGVcIik7XG5jb25zdCBSZXNvdXJjZUxvYWRlcl8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1Jlc291cmNlTG9hZGVyXCIpO1xuY29uc3QgVGV4dHVyZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1RleHR1cmVcIik7XG5jb25zdCBVUkxSZXF1ZXN0XzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvVVJMUmVxdWVzdFwiKTtcbmNvbnN0IEV2ZW50XzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvRXZlbnRcIik7XG5jb25zdCBCYXNlVGV4dHVyZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0Jhc2VUZXh0dXJlXCIpO1xuY29uc3QgU3ByaXRlXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvU3ByaXRlXCIpO1xuY29uc3QgVVJMTG9hZGVyXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvVVJMTG9hZGVyXCIpO1xuY29uc3QgRmlsdGVyXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvRmlsdGVyXCIpO1xuY2xhc3MgRmlsdGVyQ3VzdG9tIGV4dGVuZHMgQmFzZUV4YW1wbGVfMS5CYXNlRXhhbXBsZSB7XG4gICAgY29uc3RydWN0b3IoYXBwLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHN1cGVyKGFwcCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIHRoaXMuaGFuZGxlR3Jhc3NMb2FkZWQgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZ3Jhc3N0eHQgPSBuZXcgVGV4dHVyZV8xLlRleHR1cmUobmV3IEJhc2VUZXh0dXJlXzEuQmFzZVRleHR1cmUodGhpcy5sb2FkZXIuaW1hZ2VEYXRhKSk7XG4gICAgICAgICAgICB0aGlzLmJhY2tncm91bmQgPSBuZXcgU3ByaXRlXzEuU3ByaXRlKHRoaXMuZ3Jhc3N0eHQpO1xuICAgICAgICAgICAgdGhpcy5iYWNrZ3JvdW5kLndpZHRoID0gdGhpcy5zaXpldztcbiAgICAgICAgICAgIHRoaXMuYmFja2dyb3VuZC5oZWlnaHQgPSB0aGlzLnNpemVoO1xuICAgICAgICAgICAgdGhpcy5zdGFnZS5hZGRDaGlsZCh0aGlzLmJhY2tncm91bmQpO1xuICAgICAgICAgICAgdGhpcy51cmxsb2FkZXIgPSBuZXcgVVJMTG9hZGVyXzEuVVJMTG9hZGVyKCk7XG4gICAgICAgICAgICB0aGlzLnVybGxvYWRlci5hZGRFdmVudExpc3RlbmVyKEV2ZW50XzEuRXZlbnQuQ09NUExFVEUsIHRoaXMuaGFuZGxlRnJhZ0xvYWRlZCk7XG4gICAgICAgICAgICB0aGlzLnVybGxvYWRlci5sb2FkKG5ldyBVUkxSZXF1ZXN0XzEuVVJMUmVxdWVzdChcImV4YW1wbGVzL2Fzc2V0cy9waXhpLWZpbHRlcnMvc2hhZGVyLmZyYWdcIikpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZUZyYWdMb2FkZWQgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGxldCBmcmFnZGF0YSA9IHRoaXMudXJsbG9hZGVyLmRhdGE7XG4gICAgICAgICAgICB0aGlzLmZpbHRlciA9IG5ldyBGaWx0ZXJfMS5GaWx0ZXIobnVsbCwgZnJhZ2RhdGEsIHtcbiAgICAgICAgICAgICAgICBjdXN0b21Vbmlmb3JtOiAwLjBcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5iYWNrZ3JvdW5kLmZpbHRlcnMgPSBbdGhpcy5maWx0ZXJdO1xuICAgICAgICAgICAgdGhpcy5hcHAudGlja2VyLmFkZCh0aGlzLnJ1bkV4YW1wbGUpO1xuICAgICAgICAgICAgdGhpcy5leGFtcGxlUmVhZHkoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5ydW5FeGFtcGxlID0gKGRlbHRhKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmZpbHRlci51bmlmb3Jtcy5jdXN0b21Vbmlmb3JtICs9IDAuMDQgKiBkZWx0YTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5sb2FkZXIgPSBuZXcgUmVzb3VyY2VMb2FkZXJfMS5SZXNvdXJjZUxvYWRlcihuZXcgVVJMUmVxdWVzdF8xLlVSTFJlcXVlc3QoXCJleGFtcGxlcy9hc3NldHMvYmdfZ3Jhc3MuanBnXCIpKTtcbiAgICAgICAgdGhpcy5sb2FkZXIuYWRkRXZlbnRMaXN0ZW5lcihFdmVudF8xLkV2ZW50LkNPTVBMRVRFLCB0aGlzLmhhbmRsZUdyYXNzTG9hZGVkKTtcbiAgICAgICAgdGhpcy5sb2FkZXIubG9hZCgpO1xuICAgIH1cbiAgICBkZXN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlci5kZXN0cnVjdG9yKCk7XG4gICAgICAgIHRoaXMuYXBwLnRpY2tlci5yZW1vdmUodGhpcy5ydW5FeGFtcGxlLCBudWxsKTtcbiAgICAgICAgdGhpcy5ncmFzc3R4dC5kZXN0cm95KG51bGwpO1xuICAgICAgICB0aGlzLmdyYXNzdHh0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5iYWNrZ3JvdW5kLmRlc3Ryb3kobnVsbCk7XG4gICAgICAgIHRoaXMuYmFja2dyb3VuZCA9IG51bGw7XG4gICAgICAgIHRoaXMuZmlsdGVyLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5maWx0ZXIgPSBudWxsO1xuICAgIH1cbn1cbmV4cG9ydHMuRmlsdGVyQ3VzdG9tID0gRmlsdGVyQ3VzdG9tO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBCYXNlRXhhbXBsZV8xID0gcmVxdWlyZShcIi4vQmFzZUV4YW1wbGVcIik7XG5jb25zdCBDb250YWluZXJfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9Db250YWluZXJcIik7XG5jb25zdCBSZXNvdXJjZUxvYWRlcl8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1Jlc291cmNlTG9hZGVyXCIpO1xuY29uc3QgVGV4dHVyZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1RleHR1cmVcIik7XG5jb25zdCBVUkxSZXF1ZXN0XzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvVVJMUmVxdWVzdFwiKTtcbmNvbnN0IEV2ZW50XzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvRXZlbnRcIik7XG5jb25zdCBCYXNlVGV4dHVyZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0Jhc2VUZXh0dXJlXCIpO1xuY29uc3QgU3ByaXRlXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvU3ByaXRlXCIpO1xuY29uc3QgV2ViR0xTZXR0aW5nc18xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1dlYkdMU2V0dGluZ3NcIik7XG5jb25zdCBEaXNwbGFjZW1lbnRGaWx0ZXJfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9EaXNwbGFjZW1lbnRGaWx0ZXJcIik7XG5jbGFzcyBGaWx0ZXJGbGFnIGV4dGVuZHMgQmFzZUV4YW1wbGVfMS5CYXNlRXhhbXBsZSB7XG4gICAgY29uc3RydWN0b3IoYXBwLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHN1cGVyKGFwcCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIHRoaXMuaGFuZGxlRGlzcGxhY2VtZW50TG9hZGVkID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnJlcGVhdFR4dCA9IG5ldyBUZXh0dXJlXzEuVGV4dHVyZShuZXcgQmFzZVRleHR1cmVfMS5CYXNlVGV4dHVyZSh0aGlzLmxvYWRlci5pbWFnZURhdGEpKTtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IG5ldyBDb250YWluZXJfMS5Db250YWluZXIoKTtcbiAgICAgICAgICAgIHRoaXMuc3RhZ2UuYWRkQ2hpbGQoY29udGFpbmVyKTtcbiAgICAgICAgICAgIGNvbnN0IGZsYWcgPSBuZXcgU3ByaXRlXzEuU3ByaXRlKHRoaXMuZmxhZ1R4dCk7XG4gICAgICAgICAgICBjb250YWluZXIuYWRkQ2hpbGQoZmxhZyk7XG4gICAgICAgICAgICBmbGFnLnggPSAxMDA7XG4gICAgICAgICAgICBmbGFnLnkgPSAxMDA7XG4gICAgICAgICAgICB0aGlzLmRpc3BsYWNlbWVudFNwcml0ZSA9IG5ldyBTcHJpdGVfMS5TcHJpdGUodGhpcy5yZXBlYXRUeHQpO1xuICAgICAgICAgICAgdGhpcy5kaXNwbGFjZW1lbnRTcHJpdGUudGV4dHVyZS5iYXNlVGV4dHVyZS53cmFwTW9kZSA9IFdlYkdMU2V0dGluZ3NfMS5XZWJHTFNldHRpbmdzLldSQVBfTU9ERVMuUkVQRUFUO1xuICAgICAgICAgICAgY29uc3QgZGlzcGxhY2VtZW50RmlsdGVyID0gbmV3IERpc3BsYWNlbWVudEZpbHRlcl8xLkRpc3BsYWNlbWVudEZpbHRlcih0aGlzLmRpc3BsYWNlbWVudFNwcml0ZSk7XG4gICAgICAgICAgICBkaXNwbGFjZW1lbnRGaWx0ZXIucGFkZGluZyA9IDEwO1xuICAgICAgICAgICAgdGhpcy5kaXNwbGFjZW1lbnRTcHJpdGUucG9zaXRpb24gPSBmbGFnLnBvc2l0aW9uO1xuICAgICAgICAgICAgdGhpcy5zdGFnZS5hZGRDaGlsZCh0aGlzLmRpc3BsYWNlbWVudFNwcml0ZSk7XG4gICAgICAgICAgICBmbGFnLmZpbHRlcnMgPSBbZGlzcGxhY2VtZW50RmlsdGVyXTtcbiAgICAgICAgICAgIGRpc3BsYWNlbWVudEZpbHRlci5zY2FsZS54ID0gMzA7XG4gICAgICAgICAgICBkaXNwbGFjZW1lbnRGaWx0ZXIuc2NhbGUueSA9IDYwO1xuICAgICAgICAgICAgdGhpcy5hcHAudGlja2VyLmFkZCh0aGlzLnJ1bkV4YW1wbGUpO1xuICAgICAgICAgICAgdGhpcy5leGFtcGxlUmVhZHkoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5ydW5FeGFtcGxlID0gKGRlbHRhKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmRpc3BsYWNlbWVudFNwcml0ZS54Kys7XG4gICAgICAgICAgICBpZiAodGhpcy5kaXNwbGFjZW1lbnRTcHJpdGUueCA+IHRoaXMuZGlzcGxhY2VtZW50U3ByaXRlLndpZHRoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwbGFjZW1lbnRTcHJpdGUueCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlUm90YXRlTG9hZGVkID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICB0aGlzLmZsYWdUeHQgPSBuZXcgVGV4dHVyZV8xLlRleHR1cmUobmV3IEJhc2VUZXh0dXJlXzEuQmFzZVRleHR1cmUodGhpcy5sb2FkZXIuaW1hZ2VEYXRhKSk7XG4gICAgICAgICAgICB0aGlzLmxvYWRlciA9IG5ldyBSZXNvdXJjZUxvYWRlcl8xLlJlc291cmNlTG9hZGVyKG5ldyBVUkxSZXF1ZXN0XzEuVVJMUmVxdWVzdCgnZXhhbXBsZXMvYXNzZXRzL3BpeGktZmlsdGVycy9kaXNwbGFjZW1lbnRfbWFwX3JlcGVhdC5qcGcnKSk7XG4gICAgICAgICAgICB0aGlzLmxvYWRlci5hZGRFdmVudExpc3RlbmVyKEV2ZW50XzEuRXZlbnQuQ09NUExFVEUsIHRoaXMuaGFuZGxlRGlzcGxhY2VtZW50TG9hZGVkKTtcbiAgICAgICAgICAgIHRoaXMubG9hZGVyLmxvYWQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zdGFnZS5pbnRlcmFjdGl2ZSA9IHRydWU7XG4gICAgICAgIHRoaXMubG9hZGVyID0gbmV3IFJlc291cmNlTG9hZGVyXzEuUmVzb3VyY2VMb2FkZXIobmV3IFVSTFJlcXVlc3RfMS5VUkxSZXF1ZXN0KFwiZXhhbXBsZXMvYXNzZXRzL3BpeGktZmlsdGVycy9mbGFnLnBuZ1wiKSk7XG4gICAgICAgIHRoaXMubG9hZGVyLmFkZEV2ZW50TGlzdGVuZXIoRXZlbnRfMS5FdmVudC5DT01QTEVURSwgdGhpcy5oYW5kbGVSb3RhdGVMb2FkZWQpO1xuICAgICAgICB0aGlzLmxvYWRlci5sb2FkKCk7XG4gICAgfVxuICAgIGRlc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyLmRlc3RydWN0b3IoKTtcbiAgICAgICAgdGhpcy5mbGFnVHh0LmRlc3Ryb3kobnVsbCk7XG4gICAgICAgIHRoaXMuZmxhZ1R4dCA9IG51bGw7XG4gICAgICAgIHRoaXMucmVwZWF0VHh0LmRlc3Ryb3kobnVsbCk7XG4gICAgICAgIHRoaXMucmVwZWF0VHh0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5kaXNwbGFjZW1lbnRTcHJpdGUuZGVzdHJveShudWxsKTtcbiAgICAgICAgdGhpcy5kaXNwbGFjZW1lbnRTcHJpdGUgPSBudWxsO1xuICAgICAgICB0aGlzLmFwcC50aWNrZXIucmVtb3ZlKHRoaXMucnVuRXhhbXBsZSwgbnVsbCk7XG4gICAgfVxufVxuZXhwb3J0cy5GaWx0ZXJGbGFnID0gRmlsdGVyRmxhZztcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgQmFzZUV4YW1wbGVfMSA9IHJlcXVpcmUoXCIuL0Jhc2VFeGFtcGxlXCIpO1xuY29uc3QgVVJMTG9hZGVyXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvVVJMTG9hZGVyXCIpO1xuY29uc3QgRXZlbnRfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9FdmVudFwiKTtcbmNvbnN0IFVSTFJlcXVlc3RfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9VUkxSZXF1ZXN0XCIpO1xuY29uc3QgUmVzb3VyY2VMb2FkZXJfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9SZXNvdXJjZUxvYWRlclwiKTtcbmNvbnN0IFRleHR1cmVfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9UZXh0dXJlXCIpO1xuY29uc3QgQmFzZVRleHR1cmVfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9CYXNlVGV4dHVyZVwiKTtcbmNvbnN0IFNwcml0ZXNoZWV0XzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvU3ByaXRlc2hlZXRcIik7XG5jb25zdCBBbmltYXRlZFNwcml0ZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0FuaW1hdGVkU3ByaXRlXCIpO1xuY29uc3QgRmlsdGVyXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvRmlsdGVyXCIpO1xuY2xhc3MgRmlsdGVyU2hhZG93IGV4dGVuZHMgQmFzZUV4YW1wbGVfMS5CYXNlRXhhbXBsZSB7XG4gICAgY29uc3RydWN0b3IoYXBwLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHN1cGVyKGFwcCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIHRoaXMub25BbmltYXRpb25QYXJzZWQgPSAodGV4dHVyZXMpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc3RhZ2UuaW50ZXJhY3RpdmUgPSB0cnVlO1xuICAgICAgICAgICAgY29uc3QgZnJhbWVzID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDMwOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWwgPSBpIDwgMTAgPyBgMCR7aX1gIDogaTtcbiAgICAgICAgICAgICAgICBmcmFtZXMucHVzaCh0ZXh0dXJlc1tgcm9sbFNlcXVlbmNlMDAke3ZhbH0ucG5nYF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5hbmltID0gbmV3IEFuaW1hdGVkU3ByaXRlXzEuQW5pbWF0ZWRTcHJpdGUoZnJhbWVzKTtcbiAgICAgICAgICAgIHRoaXMuYW5pbS54ID0gdGhpcy5zaXpldyAvIDI7XG4gICAgICAgICAgICB0aGlzLmFuaW0ueSA9IHRoaXMuc2l6ZWggLyAyO1xuICAgICAgICAgICAgdGhpcy5hbmltLmFuY2hvci5zZXQoMC41KTtcbiAgICAgICAgICAgIHRoaXMuYW5pbS5hbmltYXRpb25TcGVlZCA9IDAuNTtcbiAgICAgICAgICAgIHRoaXMuYW5pbS5wbGF5KCk7XG4gICAgICAgICAgICB0aGlzLnN0YWdlLmFkZENoaWxkKHRoaXMuYW5pbSk7XG4gICAgICAgICAgICB0aGlzLmZpbHRlciA9IG5ldyBGaWx0ZXJfMS5GaWx0ZXIoRmlsdGVyU2hhZG93Lm15VmVydGV4LCBGaWx0ZXJTaGFkb3cubXlGcmFnbWVudCk7XG4gICAgICAgICAgICB0aGlzLmZpbHRlci51bmlmb3Jtcy5zaGFkb3dEaXJlY3Rpb24gPSBbMC4xLCAwLjVdO1xuICAgICAgICAgICAgdGhpcy5maWx0ZXIudW5pZm9ybXMuZmxvb3JZID0gdGhpcy5hbmltLmhlaWdodCAqIDI7XG4gICAgICAgICAgICB0aGlzLmZpbHRlci5wYWRkaW5nID0gMjAwO1xuICAgICAgICAgICAgdGhpcy5hbmltLmZpbHRlcnMgPSBbdGhpcy5maWx0ZXJdO1xuICAgICAgICAgICAgdGhpcy5hcHAudGlja2VyLmFkZCh0aGlzLnJ1bkV4YW1wbGUpO1xuICAgICAgICAgICAgdGhpcy5leGFtcGxlUmVhZHkoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5ydW5FeGFtcGxlID0gKGRlbHRhKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmZpbHRlci51bmlmb3Jtcy5mbG9vclkgPSB0aGlzLmFwcC5yZW5kZXJlci5wbHVnaW5zLmludGVyYWN0aW9uLm1vdXNlLmdsb2JhbC55O1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZUpzb25Mb2FkZWQgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuanNvbmRhdGEgPSBKU09OLnBhcnNlKHRoaXMudXJsbG9hZGVyLmRhdGEpO1xuICAgICAgICAgICAgdGhpcy5sb2FkZXIgPSBuZXcgUmVzb3VyY2VMb2FkZXJfMS5SZXNvdXJjZUxvYWRlcihuZXcgVVJMUmVxdWVzdF8xLlVSTFJlcXVlc3QoXCJleGFtcGxlcy9hc3NldHMvc3ByaXRlc2hlZXQvZmlnaHRlci5wbmdcIikpO1xuICAgICAgICAgICAgdGhpcy5sb2FkZXIuYWRkRXZlbnRMaXN0ZW5lcihFdmVudF8xLkV2ZW50LkNPTVBMRVRFLCB0aGlzLmhhbmRsZVJvdGF0ZUxvYWRlZCk7XG4gICAgICAgICAgICB0aGlzLmxvYWRlci5sb2FkKCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlUm90YXRlTG9hZGVkID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnR4dCA9IG5ldyBUZXh0dXJlXzEuVGV4dHVyZShuZXcgQmFzZVRleHR1cmVfMS5CYXNlVGV4dHVyZSh0aGlzLmxvYWRlci5pbWFnZURhdGEpKTtcbiAgICAgICAgICAgIGxldCBzcHJpdGVzaGVldCA9IG5ldyBTcHJpdGVzaGVldF8xLlNwcml0ZXNoZWV0KHRoaXMudHh0LCB0aGlzLmpzb25kYXRhKTtcbiAgICAgICAgICAgIHNwcml0ZXNoZWV0LnBhcnNlKHRoaXMub25BbmltYXRpb25QYXJzZWQpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnVybGxvYWRlciA9IG5ldyBVUkxMb2FkZXJfMS5VUkxMb2FkZXIoKTtcbiAgICAgICAgdGhpcy51cmxsb2FkZXIuYWRkRXZlbnRMaXN0ZW5lcihFdmVudF8xLkV2ZW50LkNPTVBMRVRFLCB0aGlzLmhhbmRsZUpzb25Mb2FkZWQpO1xuICAgICAgICB0aGlzLnVybGxvYWRlci5sb2FkKG5ldyBVUkxSZXF1ZXN0XzEuVVJMUmVxdWVzdChcImV4YW1wbGVzL2Fzc2V0cy9zcHJpdGVzaGVldC9maWdodGVyLmpzb25cIikpO1xuICAgIH1cbiAgICBkZXN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlci5kZXN0cnVjdG9yKCk7XG4gICAgICAgIHRoaXMuYXBwLnRpY2tlci5yZW1vdmUodGhpcy5ydW5FeGFtcGxlLCBudWxsKTtcbiAgICAgICAgdGhpcy50eHQuZGVzdHJveShudWxsKTtcbiAgICAgICAgdGhpcy50eHQgPSBudWxsO1xuICAgICAgICB0aGlzLmFuaW0uZGVzdHJveShudWxsKTtcbiAgICAgICAgdGhpcy5hbmltID0gbnVsbDtcbiAgICAgICAgdGhpcy5maWx0ZXIuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLmZpbHRlciA9IG51bGw7XG4gICAgICAgIHRoaXMuanNvbmRhdGEgPSBudWxsO1xuICAgIH1cbn1cbkZpbHRlclNoYWRvdy5teVZlcnRleCA9IGBcbiAgICAgICAgYXR0cmlidXRlIHZlYzIgYVZlcnRleFBvc2l0aW9uO1xuICAgICAgICBhdHRyaWJ1dGUgdmVjMiBhVGV4dHVyZUNvb3JkO1xuICAgICAgICB1bmlmb3JtIG1hdDMgcHJvamVjdGlvbk1hdHJpeDtcbiAgICAgICAgdmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XG4gICAgICAgIHZvaWQgbWFpbih2b2lkKSB7XG4gICAgICAgICAgICBnbF9Qb3NpdGlvbiA9IHZlYzQoKHByb2plY3Rpb25NYXRyaXggKiB2ZWMzKGFWZXJ0ZXhQb3NpdGlvbiwgMS4wKSkueHksIDAuMCwgMS4wKTtcbiAgICAgICAgICAgIHZUZXh0dXJlQ29vcmQgPSBhVGV4dHVyZUNvb3JkO1xuICAgICAgICB9XG4gICAgYDtcbkZpbHRlclNoYWRvdy5teUZyYWdtZW50ID0gYFxuICAgICAgICB2YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcbiAgICAgICAgdW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXI7XG4gICAgICAgIHVuaWZvcm0gdmVjNCBpbnB1dFNpemU7XG4gICAgICAgIHVuaWZvcm0gdmVjNCBvdXRwdXRGcmFtZTtcbiAgICAgICAgdW5pZm9ybSB2ZWMyIHNoYWRvd0RpcmVjdGlvbjtcbiAgICAgICAgdW5pZm9ybSBmbG9hdCBmbG9vclk7XG4gICAgICAgIHZvaWQgbWFpbih2b2lkKSB7XG4gICAgICAgICAgICAvLzEuIGdldCB0aGUgc2NyZWVuIGNvb3JkaW5hdGVcbiAgICAgICAgICAgIHZlYzIgc2NyZWVuQ29vcmQgPSB2VGV4dHVyZUNvb3JkICogaW5wdXRTaXplLnh5ICsgb3V0cHV0RnJhbWUueHk7XG4gICAgICAgICAgICAvLzIuIGNhbGN1bGF0ZSBZIHNoaWZ0IG9mIG91ciBkaW1lbnNpb24gdmVjdG9yXG4gICAgICAgICAgICB2ZWMyIHNoYWRvdztcbiAgICAgICAgICAgIC8vc2hhZG93IGNvb3JkaW5hdGUgc3lzdGVtIGlzIGEgYml0IHNrZXdlZCwgYnV0IGl0IGhhcyB0byBiZSB0aGUgc2FtZSBmb3Igc2NyZWVuQ29vcmQueSA9IGZsb29yWVxuICAgICAgICAgICAgZmxvYXQgcGFyYW1ZID0gKHNjcmVlbkNvb3JkLnkgLSBmbG9vclkpIC8gc2hhZG93RGlyZWN0aW9uLnk7XG4gICAgICAgICAgICBzaGFkb3cueSA9IHBhcmFtWSArIGZsb29yWTtcbiAgICAgICAgICAgIHNoYWRvdy54ID0gc2NyZWVuQ29vcmQueCArIHBhcmFtWSAqIHNoYWRvd0RpcmVjdGlvbi54O1xuICAgICAgICAgICAgdmVjMiBib2R5RmlsdGVyQ29vcmQgPSAoc2hhZG93IC0gb3V0cHV0RnJhbWUueHkpICogaW5wdXRTaXplLnp3OyAvLyBzYW1lIGFzIC8gaW5wdXRTaXplLnh5XG4gICAgICAgICAgICB2ZWM0IG9yaWdpbmFsQ29sb3IgPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZUZXh0dXJlQ29vcmQpO1xuICAgICAgICAgICAgdmVjNCBzaGFkb3dDb2xvciA9IHRleHR1cmUyRCh1U2FtcGxlciwgYm9keUZpbHRlckNvb3JkKTtcbiAgICAgICAgICAgIHNoYWRvd0NvbG9yLnJnYiA9IHZlYzMoMC4wKTtcbiAgICAgICAgICAgIHNoYWRvd0NvbG9yLmEgKj0gMC41O1xuICAgICAgICAgICAgLy8gbm9ybWFsIGJsZW5kIG1vZGUgY29lZmZpY2llbnRzICgxLCAxLXNyY19hbHBoYSlcbiAgICAgICAgICAgIC8vIHNoYWRvdyBpcyBkZXN0aW5hdGlvbiAoYmFja2Ryb3ApLCBvcmlnaW5hbCBpcyBzb3VyY2VcbiAgICAgICAgICAgIGdsX0ZyYWdDb2xvciA9IG9yaWdpbmFsQ29sb3IgKyBzaGFkb3dDb2xvciAqICgxLjAgLSBvcmlnaW5hbENvbG9yLmEpO1xuICAgICAgICB9XG4gICAgYDtcbmV4cG9ydHMuRmlsdGVyU2hhZG93ID0gRmlsdGVyU2hhZG93O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBCYXNlRXhhbXBsZV8xID0gcmVxdWlyZShcIi4vQmFzZUV4YW1wbGVcIik7XG5jb25zdCBSZXNvdXJjZUxvYWRlcl8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1Jlc291cmNlTG9hZGVyXCIpO1xuY29uc3QgVVJMUmVxdWVzdF8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1VSTFJlcXVlc3RcIik7XG5jb25zdCBFdmVudF8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0V2ZW50XCIpO1xuY29uc3QgVGV4dHVyZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1RleHR1cmVcIik7XG5jb25zdCBCYXNlVGV4dHVyZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0Jhc2VUZXh0dXJlXCIpO1xuY29uc3QgU3ByaXRlXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvU3ByaXRlXCIpO1xuY29uc3QgR3JhcGhpY3NfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9HcmFwaGljc1wiKTtcbmNsYXNzIEdyYXBoaWNzQWR2YW5jZWQgZXh0ZW5kcyBCYXNlRXhhbXBsZV8xLkJhc2VFeGFtcGxlIHtcbiAgICBjb25zdHJ1Y3RvcihhcHAsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgc3VwZXIoYXBwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgdGhpcy5oYW5kbGVSZXNvdXJjZUxvYWRlZCA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgbGV0IHR4dCA9IG5ldyBUZXh0dXJlXzEuVGV4dHVyZShuZXcgQmFzZVRleHR1cmVfMS5CYXNlVGV4dHVyZSh0aGlzLmxvYWRlci5pbWFnZURhdGEpKTtcbiAgICAgICAgICAgIGNvbnN0IHNwcml0ZSA9IG5ldyBTcHJpdGVfMS5TcHJpdGUodHh0KTtcbiAgICAgICAgICAgIGNvbnN0IHJlYWxQYXRoID0gbmV3IEdyYXBoaWNzXzEuR3JhcGhpY3MoKTtcbiAgICAgICAgICAgIHJlYWxQYXRoLmxpbmVTdHlsZSgyLCAweEZGRkZGRiwgMSk7XG4gICAgICAgICAgICByZWFsUGF0aC5tb3ZlVG8oMCwgMCk7XG4gICAgICAgICAgICByZWFsUGF0aC5saW5lVG8oMTAwLCAyMDApO1xuICAgICAgICAgICAgcmVhbFBhdGgubGluZVRvKDIwMCwgMjAwKTtcbiAgICAgICAgICAgIHJlYWxQYXRoLmxpbmVUbygyNDAsIDEwMCk7XG4gICAgICAgICAgICByZWFsUGF0aC5wb3NpdGlvbi54ID0gNTA7XG4gICAgICAgICAgICByZWFsUGF0aC5wb3NpdGlvbi55ID0gNTA7XG4gICAgICAgICAgICB0aGlzLnN0YWdlLmFkZENoaWxkKHJlYWxQYXRoKTtcbiAgICAgICAgICAgIGNvbnN0IGJlemllciA9IG5ldyBHcmFwaGljc18xLkdyYXBoaWNzKCk7XG4gICAgICAgICAgICBiZXppZXIubGluZVN0eWxlKDUsIDB4QUEwMDAwLCAxKTtcbiAgICAgICAgICAgIGJlemllci5iZXppZXJDdXJ2ZVRvKDEwMCwgMjAwLCAyMDAsIDIwMCwgMjQwLCAxMDApO1xuICAgICAgICAgICAgYmV6aWVyLnBvc2l0aW9uLnggPSA1MDtcbiAgICAgICAgICAgIGJlemllci5wb3NpdGlvbi55ID0gNTA7XG4gICAgICAgICAgICB0aGlzLnN0YWdlLmFkZENoaWxkKGJlemllcik7XG4gICAgICAgICAgICBjb25zdCByZWFsUGF0aDIgPSBuZXcgR3JhcGhpY3NfMS5HcmFwaGljcygpO1xuICAgICAgICAgICAgcmVhbFBhdGgyLmxpbmVTdHlsZSgyLCAweEZGRkZGRiwgMSk7XG4gICAgICAgICAgICByZWFsUGF0aDIubW92ZVRvKDAsIDApO1xuICAgICAgICAgICAgcmVhbFBhdGgyLmxpbmVUbygwLCAtMTAwKTtcbiAgICAgICAgICAgIHJlYWxQYXRoMi5saW5lVG8oMTUwLCAxNTApO1xuICAgICAgICAgICAgcmVhbFBhdGgyLmxpbmVUbygyNDAsIDEwMCk7XG4gICAgICAgICAgICByZWFsUGF0aDIucG9zaXRpb24ueCA9IDMyMDtcbiAgICAgICAgICAgIHJlYWxQYXRoMi5wb3NpdGlvbi55ID0gMTUwO1xuICAgICAgICAgICAgdGhpcy5zdGFnZS5hZGRDaGlsZChyZWFsUGF0aDIpO1xuICAgICAgICAgICAgY29uc3QgYmV6aWVyMiA9IG5ldyBHcmFwaGljc18xLkdyYXBoaWNzKCk7XG4gICAgICAgICAgICBiZXppZXIyLmxpbmVUZXh0dXJlU3R5bGUoMTAsIHNwcml0ZS50ZXh0dXJlKTtcbiAgICAgICAgICAgIGJlemllcjIuYmV6aWVyQ3VydmVUbygwLCAtMTAwLCAxNTAsIDE1MCwgMjQwLCAxMDApO1xuICAgICAgICAgICAgYmV6aWVyMi5wb3NpdGlvbi54ID0gMzIwO1xuICAgICAgICAgICAgYmV6aWVyMi5wb3NpdGlvbi55ID0gMTUwO1xuICAgICAgICAgICAgdGhpcy5zdGFnZS5hZGRDaGlsZChiZXppZXIyKTtcbiAgICAgICAgICAgIGNvbnN0IGFyYyA9IG5ldyBHcmFwaGljc18xLkdyYXBoaWNzKCk7XG4gICAgICAgICAgICBhcmMubGluZVN0eWxlKDUsIDB4QUEwMEJCLCAxKTtcbiAgICAgICAgICAgIGFyYy5hcmMoNjAwLCAxMDAsIDUwLCBNYXRoLlBJLCAyICogTWF0aC5QSSk7XG4gICAgICAgICAgICB0aGlzLnN0YWdlLmFkZENoaWxkKGFyYyk7XG4gICAgICAgICAgICBjb25zdCBhcmMyID0gbmV3IEdyYXBoaWNzXzEuR3JhcGhpY3MoKTtcbiAgICAgICAgICAgIGFyYzIubGluZVN0eWxlKDYsIDB4MzMzM0RELCAxKTtcbiAgICAgICAgICAgIGFyYzIuYXJjKDY1MCwgMjcwLCA2MCwgMiAqIE1hdGguUEksIDMgKiBNYXRoLlBJIC8gMik7XG4gICAgICAgICAgICB0aGlzLnN0YWdlLmFkZENoaWxkKGFyYzIpO1xuICAgICAgICAgICAgY29uc3QgYXJjMyA9IG5ldyBHcmFwaGljc18xLkdyYXBoaWNzKCk7XG4gICAgICAgICAgICBhcmMzLmxpbmVUZXh0dXJlU3R5bGUoMjAsIHNwcml0ZS50ZXh0dXJlKTtcbiAgICAgICAgICAgIGFyYzMuYXJjKDY1MCwgNDIwLCA2MCwgMiAqIE1hdGguUEksIDIuNSAqIE1hdGguUEkgLyAyKTtcbiAgICAgICAgICAgIHRoaXMuc3RhZ2UuYWRkQ2hpbGQoYXJjMyk7XG4gICAgICAgICAgICBjb25zdCByZWN0QW5kSG9sZSA9IG5ldyBHcmFwaGljc18xLkdyYXBoaWNzKCk7XG4gICAgICAgICAgICByZWN0QW5kSG9sZS5iZWdpbkZpbGwoMHgwMEZGMDApO1xuICAgICAgICAgICAgcmVjdEFuZEhvbGUuZHJhd1JlY3QoMzUwLCAzNTAsIDE1MCwgMTUwKTtcbiAgICAgICAgICAgIHJlY3RBbmRIb2xlLmJlZ2luSG9sZSgpO1xuICAgICAgICAgICAgcmVjdEFuZEhvbGUuZHJhd0NpcmNsZSgzNzUsIDM3NSwgMjUpO1xuICAgICAgICAgICAgcmVjdEFuZEhvbGUuZHJhd0NpcmNsZSg0MjUsIDQyNSwgMjUpO1xuICAgICAgICAgICAgcmVjdEFuZEhvbGUuZHJhd0NpcmNsZSg0NzUsIDQ3NSwgMjUpO1xuICAgICAgICAgICAgcmVjdEFuZEhvbGUuZW5kSG9sZSgpO1xuICAgICAgICAgICAgcmVjdEFuZEhvbGUuZW5kRmlsbCgpO1xuICAgICAgICAgICAgdGhpcy5zdGFnZS5hZGRDaGlsZChyZWN0QW5kSG9sZSk7XG4gICAgICAgICAgICBjb25zdCBiZWF0aWZ1bFJlY3QgPSBuZXcgR3JhcGhpY3NfMS5HcmFwaGljcygpO1xuICAgICAgICAgICAgYmVhdGlmdWxSZWN0LmxpbmVUZXh0dXJlU3R5bGUoMjAsIHNwcml0ZS50ZXh0dXJlKTtcbiAgICAgICAgICAgIGJlYXRpZnVsUmVjdC5iZWdpbkZpbGwoMHhGRjAwMDApO1xuICAgICAgICAgICAgYmVhdGlmdWxSZWN0LmRyYXdSZWN0KDgwLCAzNTAsIDE1MCwgMTUwKTtcbiAgICAgICAgICAgIGJlYXRpZnVsUmVjdC5lbmRGaWxsKCk7XG4gICAgICAgICAgICB0aGlzLnN0YWdlLmFkZENoaWxkKGJlYXRpZnVsUmVjdCk7XG4gICAgICAgICAgICB0aGlzLmV4YW1wbGVSZWFkeSgpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmxvYWRlciA9IG5ldyBSZXNvdXJjZUxvYWRlcl8xLlJlc291cmNlTG9hZGVyKG5ldyBVUkxSZXF1ZXN0XzEuVVJMUmVxdWVzdChcImV4YW1wbGVzL2Fzc2V0cy9iZ19yb3RhdGUuanBnXCIpKTtcbiAgICAgICAgdGhpcy5sb2FkZXIuYWRkRXZlbnRMaXN0ZW5lcihFdmVudF8xLkV2ZW50LkNPTVBMRVRFLCB0aGlzLmhhbmRsZVJlc291cmNlTG9hZGVkKTtcbiAgICAgICAgdGhpcy5sb2FkZXIubG9hZCgpO1xuICAgIH1cbn1cbmV4cG9ydHMuR3JhcGhpY3NBZHZhbmNlZCA9IEdyYXBoaWNzQWR2YW5jZWQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IEJhc2VFeGFtcGxlXzEgPSByZXF1aXJlKFwiLi9CYXNlRXhhbXBsZVwiKTtcbmNvbnN0IEdyYXBoaWNzXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvR3JhcGhpY3NcIik7XG5jb25zdCBNb3VzZUV2ZW50XzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvTW91c2VFdmVudFwiKTtcbmNsYXNzIEdyYXBoaWNzRHluYW1pYyBleHRlbmRzIEJhc2VFeGFtcGxlXzEuQmFzZUV4YW1wbGUge1xuICAgIGNvbnN0cnVjdG9yKGFwcCwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICBzdXBlcihhcHAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICB0aGlzLnJ1bkV4YW1wbGUgPSAoZGVsdGEpID0+IHtcbiAgICAgICAgICAgIHRoaXMuY291bnQgKz0gMC4xO1xuICAgICAgICAgICAgdGhpcy50aGluZy5jbGVhcigpO1xuICAgICAgICAgICAgdGhpcy50aGluZy5saW5lU3R5bGUoMTAsIDB4ZmYwMDAwLCAxKTtcbiAgICAgICAgICAgIHRoaXMudGhpbmcuYmVnaW5GaWxsKDB4ZmZGRjAwLCAwLjUpO1xuICAgICAgICAgICAgdGhpcy50aGluZy5tb3ZlVG8oLTEyMCArIE1hdGguc2luKHRoaXMuY291bnQpICogMjAsIC0xMDAgKyBNYXRoLmNvcyh0aGlzLmNvdW50KSAqIDIwKTtcbiAgICAgICAgICAgIHRoaXMudGhpbmcubGluZVRvKDEyMCArIE1hdGguY29zKHRoaXMuY291bnQpICogMjAsIC0xMDAgKyBNYXRoLnNpbih0aGlzLmNvdW50KSAqIDIwKTtcbiAgICAgICAgICAgIHRoaXMudGhpbmcubGluZVRvKDEyMCArIE1hdGguc2luKHRoaXMuY291bnQpICogMjAsIDEwMCArIE1hdGguY29zKHRoaXMuY291bnQpICogMjApO1xuICAgICAgICAgICAgdGhpcy50aGluZy5saW5lVG8oLTEyMCArIE1hdGguY29zKHRoaXMuY291bnQpICogMjAsIDEwMCArIE1hdGguc2luKHRoaXMuY291bnQpICogMjApO1xuICAgICAgICAgICAgdGhpcy50aGluZy5saW5lVG8oLTEyMCArIE1hdGguc2luKHRoaXMuY291bnQpICogMjAsIC0xMDAgKyBNYXRoLmNvcyh0aGlzLmNvdW50KSAqIDIwKTtcbiAgICAgICAgICAgIHRoaXMudGhpbmcucm90YXRpb24gPSB0aGlzLmNvdW50ICogMC4xO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLm9uUG9pbnRlckRvd24gPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmdyYXBoaWNzLmxpbmVTdHlsZShNYXRoLnJhbmRvbSgpICogMzAsIE1hdGgucmFuZG9tKCkgKiAweEZGRkZGRiwgMSk7XG4gICAgICAgICAgICB0aGlzLmdyYXBoaWNzLm1vdmVUbyhNYXRoLnJhbmRvbSgpICogODAwLCBNYXRoLnJhbmRvbSgpICogNjAwKTtcbiAgICAgICAgICAgIHRoaXMuZ3JhcGhpY3MuYmV6aWVyQ3VydmVUbyhNYXRoLnJhbmRvbSgpICogODAwLCBNYXRoLnJhbmRvbSgpICogNjAwLCBNYXRoLnJhbmRvbSgpICogODAwLCBNYXRoLnJhbmRvbSgpICogNjAwLCBNYXRoLnJhbmRvbSgpICogODAwLCBNYXRoLnJhbmRvbSgpICogNjAwKTtcbiAgICAgICAgfTtcbiAgICAgICAgYXBwLnN0YWdlLmludGVyYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5ncmFwaGljcyA9IG5ldyBHcmFwaGljc18xLkdyYXBoaWNzKCk7XG4gICAgICAgIHRoaXMuZ3JhcGhpY3MuYmVnaW5GaWxsKDB4RkYzMzAwKTtcbiAgICAgICAgdGhpcy5ncmFwaGljcy5saW5lU3R5bGUoMTAsIDB4ZmZkOTAwLCAxKTtcbiAgICAgICAgdGhpcy5ncmFwaGljcy5tb3ZlVG8oNTAsIDUwKTtcbiAgICAgICAgdGhpcy5ncmFwaGljcy5saW5lVG8oMjUwLCA1MCk7XG4gICAgICAgIHRoaXMuZ3JhcGhpY3MubGluZVRvKDEwMCwgMTAwKTtcbiAgICAgICAgdGhpcy5ncmFwaGljcy5saW5lVG8oMjUwLCAyMjApO1xuICAgICAgICB0aGlzLmdyYXBoaWNzLmxpbmVUbyg1MCwgMjIwKTtcbiAgICAgICAgdGhpcy5ncmFwaGljcy5saW5lVG8oNTAsIDUwKTtcbiAgICAgICAgdGhpcy5ncmFwaGljcy5lbmRGaWxsKCk7XG4gICAgICAgIHRoaXMuZ3JhcGhpY3MubGluZVN0eWxlKDEwLCAweEZGMDAwMCwgMC44KTtcbiAgICAgICAgdGhpcy5ncmFwaGljcy5iZWdpbkZpbGwoMHhGRjcwMEIsIDEpO1xuICAgICAgICB0aGlzLmdyYXBoaWNzLm1vdmVUbygyMTAsIDMwMCk7XG4gICAgICAgIHRoaXMuZ3JhcGhpY3MubGluZVRvKDQ1MCwgMzIwKTtcbiAgICAgICAgdGhpcy5ncmFwaGljcy5saW5lVG8oNTcwLCAzNTApO1xuICAgICAgICB0aGlzLmdyYXBoaWNzLnF1YWRyYXRpY0N1cnZlVG8oNjAwLCAwLCA0ODAsIDEwMCk7XG4gICAgICAgIHRoaXMuZ3JhcGhpY3MubGluZVRvKDMzMCwgMTIwKTtcbiAgICAgICAgdGhpcy5ncmFwaGljcy5saW5lVG8oNDEwLCAyMDApO1xuICAgICAgICB0aGlzLmdyYXBoaWNzLmxpbmVUbygyMTAsIDMwMCk7XG4gICAgICAgIHRoaXMuZ3JhcGhpY3MuZW5kRmlsbCgpO1xuICAgICAgICB0aGlzLmdyYXBoaWNzLmxpbmVTdHlsZSgyLCAweDAwMDBGRiwgMSk7XG4gICAgICAgIHRoaXMuZ3JhcGhpY3MuZHJhd1JlY3QoNTAsIDI1MCwgMTAwLCAxMDApO1xuICAgICAgICB0aGlzLmdyYXBoaWNzLmxpbmVTdHlsZSgwKTtcbiAgICAgICAgdGhpcy5ncmFwaGljcy5iZWdpbkZpbGwoMHhGRkZGMEIsIDAuNSk7XG4gICAgICAgIHRoaXMuZ3JhcGhpY3MuZHJhd0NpcmNsZSg0NzAsIDIwMCwgMTAwKTtcbiAgICAgICAgdGhpcy5ncmFwaGljcy5lbmRGaWxsKCk7XG4gICAgICAgIHRoaXMuZ3JhcGhpY3MubGluZVN0eWxlKDIwLCAweDMzRkYwMCk7XG4gICAgICAgIHRoaXMuZ3JhcGhpY3MubW92ZVRvKDMwLCAzMCk7XG4gICAgICAgIHRoaXMuZ3JhcGhpY3MubGluZVRvKDYwMCwgMzAwKTtcbiAgICAgICAgdGhpcy5zdGFnZS5hZGRDaGlsZCh0aGlzLmdyYXBoaWNzKTtcbiAgICAgICAgdGhpcy50aGluZyA9IG5ldyBHcmFwaGljc18xLkdyYXBoaWNzKCk7XG4gICAgICAgIHRoaXMuc3RhZ2UuYWRkQ2hpbGQodGhpcy50aGluZyk7XG4gICAgICAgIHRoaXMudGhpbmcueCA9IDgwMCAvIDI7XG4gICAgICAgIHRoaXMudGhpbmcueSA9IDYwMCAvIDI7XG4gICAgICAgIHRoaXMuY291bnQgPSAwO1xuICAgICAgICBhcHAudGlja2VyLmFkZCh0aGlzLnJ1bkV4YW1wbGUpO1xuICAgICAgICB0aGlzLnN0YWdlLmludGVyYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zdGFnZS5hZGRFdmVudExpc3RlbmVyKE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50LlBPSU5URVJfRE9XTiwgdGhpcy5vblBvaW50ZXJEb3duKTtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmV4YW1wbGVSZWFkeSgpO1xuICAgICAgICB9LCAxMDAwKTtcbiAgICB9XG4gICAgZGVzdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIuZGVzdHJ1Y3RvcigpO1xuICAgICAgICB0aGlzLmFwcC50aWNrZXIucmVtb3ZlKHRoaXMucnVuRXhhbXBsZSwgbnVsbCk7XG4gICAgICAgIHRoaXMuZ3JhcGhpY3MuZGVzdHJveShudWxsKTtcbiAgICAgICAgdGhpcy5ncmFwaGljcyA9IG51bGw7XG4gICAgICAgIHRoaXMudGhpbmcuZGVzdHJveShudWxsKTtcbiAgICAgICAgdGhpcy50aGluZyA9IG51bGw7XG4gICAgfVxufVxuZXhwb3J0cy5HcmFwaGljc0R5bmFtaWMgPSBHcmFwaGljc0R5bmFtaWM7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IEJhc2VFeGFtcGxlXzEgPSByZXF1aXJlKFwiLi9CYXNlRXhhbXBsZVwiKTtcbmNvbnN0IEdyYXBoaWNzXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvR3JhcGhpY3NcIik7XG5jbGFzcyBHcmFwaGljc1NpbXBsZSBleHRlbmRzIEJhc2VFeGFtcGxlXzEuQmFzZUV4YW1wbGUge1xuICAgIGNvbnN0cnVjdG9yKGFwcCwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICBzdXBlcihhcHAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICB0aGlzLmJhY2tDb2xvciA9IDA7XG4gICAgICAgIGNvbnN0IGdyYXBoaWNzID0gbmV3IEdyYXBoaWNzXzEuR3JhcGhpY3MoKTtcbiAgICAgICAgZ3JhcGhpY3MuYmVnaW5GaWxsKDB4REUzMjQ5KTtcbiAgICAgICAgZ3JhcGhpY3MuZHJhd1JlY3QoNTAsIDUwLCAxMDAsIDEwMCk7XG4gICAgICAgIGdyYXBoaWNzLmVuZEZpbGwoKTtcbiAgICAgICAgZ3JhcGhpY3MubGluZVN0eWxlKDIsIDB4RkVFQjc3LCAxKTtcbiAgICAgICAgZ3JhcGhpY3MuYmVnaW5GaWxsKDB4NjUwQTVBKTtcbiAgICAgICAgZ3JhcGhpY3MuZHJhd1JlY3QoMjAwLCA1MCwgMTAwLCAxMDApO1xuICAgICAgICBncmFwaGljcy5lbmRGaWxsKCk7XG4gICAgICAgIGdyYXBoaWNzLmxpbmVTdHlsZSgxMCwgMHhGRkJEMDEsIDEpO1xuICAgICAgICBncmFwaGljcy5iZWdpbkZpbGwoMHhDMzQyODgpO1xuICAgICAgICBncmFwaGljcy5kcmF3UmVjdCgzNTAsIDUwLCAxMDAsIDEwMCk7XG4gICAgICAgIGdyYXBoaWNzLmVuZEZpbGwoKTtcbiAgICAgICAgZ3JhcGhpY3MubGluZVN0eWxlKDIsIDB4RkZGRkZGLCAxKTtcbiAgICAgICAgZ3JhcGhpY3MuYmVnaW5GaWxsKDB4QUE0RjA4KTtcbiAgICAgICAgZ3JhcGhpY3MuZHJhd1JlY3QoNTMwLCA1MCwgMTQwLCAxMDApO1xuICAgICAgICBncmFwaGljcy5lbmRGaWxsKCk7XG4gICAgICAgIGdyYXBoaWNzLmxpbmVTdHlsZSgwKTsgLy8gZHJhdyBhIGNpcmNsZSwgc2V0IHRoZSBsaW5lU3R5bGUgdG8gemVybyBzbyB0aGUgY2lyY2xlIGRvZXNuJ3QgaGF2ZSBhbiBvdXRsaW5lXG4gICAgICAgIGdyYXBoaWNzLmJlZ2luRmlsbCgweERFMzI0OSwgMSk7XG4gICAgICAgIGdyYXBoaWNzLmRyYXdDaXJjbGUoMTAwLCAyNTAsIDUwKTtcbiAgICAgICAgZ3JhcGhpY3MuZW5kRmlsbCgpO1xuICAgICAgICBncmFwaGljcy5saW5lU3R5bGUoMiwgMHhGRUVCNzcsIDEpO1xuICAgICAgICBncmFwaGljcy5iZWdpbkZpbGwoMHg2NTBBNUEsIDEpO1xuICAgICAgICBncmFwaGljcy5kcmF3Q2lyY2xlKDI1MCwgMjUwLCA1MCk7XG4gICAgICAgIGdyYXBoaWNzLmVuZEZpbGwoKTtcbiAgICAgICAgZ3JhcGhpY3MubGluZVN0eWxlKDEwLCAweEZGQkQwMSwgMSk7XG4gICAgICAgIGdyYXBoaWNzLmJlZ2luRmlsbCgweEMzNDI4OCwgMSk7XG4gICAgICAgIGdyYXBoaWNzLmRyYXdDaXJjbGUoNDAwLCAyNTAsIDUwKTtcbiAgICAgICAgZ3JhcGhpY3MuZW5kRmlsbCgpO1xuICAgICAgICBncmFwaGljcy5saW5lU3R5bGUoMiwgMHhGRkZGRkYsIDEpO1xuICAgICAgICBncmFwaGljcy5iZWdpbkZpbGwoMHhBQTRGMDgsIDEpO1xuICAgICAgICBncmFwaGljcy5kcmF3RWxsaXBzZSg2MDAsIDI1MCwgODAsIDUwKTtcbiAgICAgICAgZ3JhcGhpY3MuZW5kRmlsbCgpO1xuICAgICAgICBncmFwaGljcy5iZWdpbkZpbGwoMHhGRjMzMDApO1xuICAgICAgICBncmFwaGljcy5saW5lU3R5bGUoNCwgMHhmZmQ5MDAsIDEpO1xuICAgICAgICBncmFwaGljcy5tb3ZlVG8oNTAsIDM1MCk7XG4gICAgICAgIGdyYXBoaWNzLmxpbmVUbygyNTAsIDM1MCk7XG4gICAgICAgIGdyYXBoaWNzLmxpbmVUbygxMDAsIDQwMCk7XG4gICAgICAgIGdyYXBoaWNzLmxpbmVUbyg1MCwgMzUwKTtcbiAgICAgICAgZ3JhcGhpY3MuZW5kRmlsbCgpO1xuICAgICAgICBncmFwaGljcy5saW5lU3R5bGUoMiwgMHhGRjAwRkYsIDEpO1xuICAgICAgICBncmFwaGljcy5iZWdpbkZpbGwoMHg2NTBBNUEsIDAuMjUpO1xuICAgICAgICBncmFwaGljcy5kcmF3Um91bmRlZFJlY3QoNTAsIDQ0MCwgMTAwLCAxMDAsIDE2KTtcbiAgICAgICAgZ3JhcGhpY3MuZW5kRmlsbCgpO1xuICAgICAgICBncmFwaGljcy5saW5lU3R5bGUoMiwgMHhGRkZGRkYpO1xuICAgICAgICBncmFwaGljcy5iZWdpbkZpbGwoMHgzNUNDNUEsIDEpO1xuICAgICAgICBncmFwaGljcy5kcmF3U3RhcigzNjAsIDM3MCwgNSwgNTApO1xuICAgICAgICBncmFwaGljcy5lbmRGaWxsKCk7XG4gICAgICAgIGdyYXBoaWNzLmxpbmVTdHlsZSgyLCAweEZGRkZGRik7XG4gICAgICAgIGdyYXBoaWNzLmJlZ2luRmlsbCgweEZGQ0M1QSwgMSk7XG4gICAgICAgIGdyYXBoaWNzLmRyYXdTdGFyKDI4MCwgNTEwLCA3LCA1MCk7XG4gICAgICAgIGdyYXBoaWNzLmVuZEZpbGwoKTtcbiAgICAgICAgZ3JhcGhpY3MubGluZVN0eWxlKDQsIDB4RkZGRkZGKTtcbiAgICAgICAgZ3JhcGhpY3MuYmVnaW5GaWxsKDB4NTUzMzVBLCAxKTtcbiAgICAgICAgZ3JhcGhpY3MuZHJhd1N0YXIoNDcwLCA0NTAsIDQsIDUwKTtcbiAgICAgICAgZ3JhcGhpY3MuZW5kRmlsbCgpO1xuICAgICAgICBjb25zdCBwYXRoID0gWzYwMCwgMzcwLCA3MDAsIDQ2MCwgNzgwLCA0MjAsIDczMCwgNTcwLCA1OTAsIDUyMF07XG4gICAgICAgIGdyYXBoaWNzLmxpbmVTdHlsZSgwKTtcbiAgICAgICAgZ3JhcGhpY3MuYmVnaW5GaWxsKDB4MzUwMEZBLCAxKTtcbiAgICAgICAgZ3JhcGhpY3MuZHJhd1BvbHlnb24ocGF0aCk7XG4gICAgICAgIGdyYXBoaWNzLmVuZEZpbGwoKTtcbiAgICAgICAgdGhpcy5zdGFnZS5hZGRDaGlsZChncmFwaGljcyk7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5leGFtcGxlUmVhZHkoKTtcbiAgICAgICAgfSwgMTAwMCk7XG4gICAgfVxufVxuZXhwb3J0cy5HcmFwaGljc1NpbXBsZSA9IEdyYXBoaWNzU2ltcGxlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBCYXNlRXhhbXBsZV8xID0gcmVxdWlyZShcIi4vQmFzZUV4YW1wbGVcIik7XG5jb25zdCBSZXNvdXJjZUxvYWRlcl8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1Jlc291cmNlTG9hZGVyXCIpO1xuY29uc3QgVVJMUmVxdWVzdF8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1VSTFJlcXVlc3RcIik7XG5jb25zdCBFdmVudF8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0V2ZW50XCIpO1xuY29uc3QgVGV4dHVyZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1RleHR1cmVcIik7XG5jb25zdCBCYXNlVGV4dHVyZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0Jhc2VUZXh0dXJlXCIpO1xuY29uc3QgRGlzcGxheVNldHRpbmdzXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvRGlzcGxheVNldHRpbmdzXCIpO1xuY29uc3QgV2ViR0xTZXR0aW5nc18xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1dlYkdMU2V0dGluZ3NcIik7XG5jb25zdCBTcHJpdGVfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9TcHJpdGVcIik7XG5jb25zdCBNb3VzZUV2ZW50XzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvTW91c2VFdmVudFwiKTtcbmNsYXNzIEludGVyYWN0aW9uQ2xpY2sgZXh0ZW5kcyBCYXNlRXhhbXBsZV8xLkJhc2VFeGFtcGxlIHtcbiAgICBjb25zdHJ1Y3RvcihhcHAsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgc3VwZXIoYXBwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgdGhpcy5oYW5kbGVSb3RhdGVMb2FkZWQgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGxldCB0eHQgPSBuZXcgVGV4dHVyZV8xLlRleHR1cmUobmV3IEJhc2VUZXh0dXJlXzEuQmFzZVRleHR1cmUodGhpcy5sb2FkZXIuaW1hZ2VEYXRhKSk7XG4gICAgICAgICAgICBEaXNwbGF5U2V0dGluZ3NfMS5EaXNwbGF5U2V0dGluZ3MuU0NBTEVfTU9ERSA9IFdlYkdMU2V0dGluZ3NfMS5XZWJHTFNldHRpbmdzLlNDQUxFX01PREVTLk5FQVJFU1Q7XG4gICAgICAgICAgICB0aGlzLnNwcml0ZSA9IG5ldyBTcHJpdGVfMS5TcHJpdGUodHh0KTtcbiAgICAgICAgICAgIHRoaXMuc3ByaXRlLmFuY2hvci5zZXQoMC41KTtcbiAgICAgICAgICAgIHRoaXMuc3ByaXRlLnggPSB0aGlzLnNpemV3IC8gMjtcbiAgICAgICAgICAgIHRoaXMuc3ByaXRlLnkgPSB0aGlzLnNpemVoIC8gMjtcbiAgICAgICAgICAgIHRoaXMuc3ByaXRlLmludGVyYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuc3ByaXRlLmJ1dHRvbk1vZGUgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5zcHJpdGUuYWRkRXZlbnRMaXN0ZW5lcihNb3VzZUV2ZW50XzEuTW91c2VFdmVudC5QT0lOVEVSX0RPV04sIHRoaXMub25DbGljayk7XG4gICAgICAgICAgICB0aGlzLnN0YWdlLmFkZENoaWxkKHRoaXMuc3ByaXRlKTtcbiAgICAgICAgICAgIHRoaXMuZXhhbXBsZVJlYWR5KCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMub25DbGljayA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zcHJpdGUuc2NhbGUueCAqPSAxLjI1O1xuICAgICAgICAgICAgdGhpcy5zcHJpdGUuc2NhbGUueSAqPSAxLjI1O1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmxvYWRlciA9IG5ldyBSZXNvdXJjZUxvYWRlcl8xLlJlc291cmNlTG9hZGVyKG5ldyBVUkxSZXF1ZXN0XzEuVVJMUmVxdWVzdChcImV4YW1wbGVzL2Fzc2V0cy9idW5ueS5wbmdcIikpO1xuICAgICAgICB0aGlzLmxvYWRlci5hZGRFdmVudExpc3RlbmVyKEV2ZW50XzEuRXZlbnQuQ09NUExFVEUsIHRoaXMuaGFuZGxlUm90YXRlTG9hZGVkKTtcbiAgICAgICAgdGhpcy5sb2FkZXIubG9hZCgpO1xuICAgIH1cbiAgICBkZXN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlci5kZXN0cnVjdG9yKCk7XG4gICAgICAgIHRoaXMuc3ByaXRlLmRlc3Ryb3kobnVsbCk7XG4gICAgICAgIHRoaXMuc3ByaXRlID0gbnVsbDtcbiAgICB9XG59XG5leHBvcnRzLkludGVyYWN0aW9uQ2xpY2sgPSBJbnRlcmFjdGlvbkNsaWNrO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBCYXNlRXhhbXBsZV8xID0gcmVxdWlyZShcIi4vQmFzZUV4YW1wbGVcIik7XG5jb25zdCBSZXNvdXJjZUxvYWRlcl8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1Jlc291cmNlTG9hZGVyXCIpO1xuY29uc3QgVVJMUmVxdWVzdF8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1VSTFJlcXVlc3RcIik7XG5jb25zdCBFdmVudF8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0V2ZW50XCIpO1xuY29uc3QgVGV4dHVyZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1RleHR1cmVcIik7XG5jb25zdCBCYXNlVGV4dHVyZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0Jhc2VUZXh0dXJlXCIpO1xuY29uc3QgV2ViR0xTZXR0aW5nc18xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1dlYkdMU2V0dGluZ3NcIik7XG5jb25zdCBTcHJpdGVfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9TcHJpdGVcIik7XG5jb25zdCBNb3VzZUV2ZW50XzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvTW91c2VFdmVudFwiKTtcbmNsYXNzIEludGVyYWN0aW9uRHJhZ2dpbmcgZXh0ZW5kcyBCYXNlRXhhbXBsZV8xLkJhc2VFeGFtcGxlIHtcbiAgICBjb25zdHJ1Y3RvcihhcHAsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgc3VwZXIoYXBwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgdGhpcy5oYW5kbGVSb3RhdGVMb2FkZWQgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGxldCB0ZXh0dXJlID0gbmV3IFRleHR1cmVfMS5UZXh0dXJlKG5ldyBCYXNlVGV4dHVyZV8xLkJhc2VUZXh0dXJlKHRoaXMubG9hZGVyLmltYWdlRGF0YSkpO1xuICAgICAgICAgICAgdGV4dHVyZS5iYXNlVGV4dHVyZS5zY2FsZU1vZGUgPSBXZWJHTFNldHRpbmdzXzEuV2ViR0xTZXR0aW5ncy5TQ0FMRV9NT0RFUy5ORUFSRVNUO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jcmVhdGVCdW5ueShNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiB0aGlzLnNpemV3KSwgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogdGhpcy5zaXplaCksIHRleHR1cmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5leGFtcGxlUmVhZHkoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vbkRyYWdTdGFydCA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgbGV0IGJ1dHRvbiA9IGV2ZW50LmN1cnJlbnRUYXJnZXQ7XG4gICAgICAgICAgICBidXR0b24uZGF0YSA9IGV2ZW50LmRhdGE7XG4gICAgICAgICAgICBidXR0b24uYWxwaGEgPSAwLjU7XG4gICAgICAgICAgICBidXR0b24uZHJhZ2dpbmcgPSB0cnVlO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLm9uRHJhZ0VuZCA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgbGV0IGJ1dHRvbiA9IGV2ZW50LmN1cnJlbnRUYXJnZXQ7XG4gICAgICAgICAgICBidXR0b24uYWxwaGEgPSAxO1xuICAgICAgICAgICAgYnV0dG9uLmRyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgICAgICBidXR0b24uZGF0YSA9IG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMub25EcmFnTW92ZSA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgbGV0IGJ1dHRvbiA9IGV2ZW50LmN1cnJlbnRUYXJnZXQ7XG4gICAgICAgICAgICBpZiAoYnV0dG9uLmRyYWdnaW5nKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3UG9zaXRpb24gPSBidXR0b24uZGF0YS5nZXRMb2NhbFBvc2l0aW9uKGJ1dHRvbi5wYXJlbnQpO1xuICAgICAgICAgICAgICAgIGJ1dHRvbi54ID0gbmV3UG9zaXRpb24ueDtcbiAgICAgICAgICAgICAgICBidXR0b24ueSA9IG5ld1Bvc2l0aW9uLnk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuYWN0aXZhdGVNYXNrKCk7XG4gICAgICAgIHRoaXMubG9hZGVyID0gbmV3IFJlc291cmNlTG9hZGVyXzEuUmVzb3VyY2VMb2FkZXIobmV3IFVSTFJlcXVlc3RfMS5VUkxSZXF1ZXN0KFwiZXhhbXBsZXMvYXNzZXRzL2J1bm55LnBuZ1wiKSk7XG4gICAgICAgIHRoaXMubG9hZGVyLmFkZEV2ZW50TGlzdGVuZXIoRXZlbnRfMS5FdmVudC5DT01QTEVURSwgdGhpcy5oYW5kbGVSb3RhdGVMb2FkZWQpO1xuICAgICAgICB0aGlzLmxvYWRlci5sb2FkKCk7XG4gICAgfVxuICAgIGNyZWF0ZUJ1bm55KHgsIHksIHRleHR1cmUpIHtcbiAgICAgICAgY29uc3QgYnVubnkgPSBuZXcgRXh0ZW5kZWRTcHJpdGUodGV4dHVyZSk7XG4gICAgICAgIGJ1bm55LmludGVyYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgYnVubnkuYnV0dG9uTW9kZSA9IHRydWU7XG4gICAgICAgIGJ1bm55LmFuY2hvci5zZXQoMC41KTtcbiAgICAgICAgYnVubnkuc2NhbGUuc2V0KDMpO1xuICAgICAgICBidW5ueS5hZGRFdmVudExpc3RlbmVyKE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50LlBPSU5URVJfRE9XTiwgdGhpcy5vbkRyYWdTdGFydCk7XG4gICAgICAgIGJ1bm55LmFkZEV2ZW50TGlzdGVuZXIoTW91c2VFdmVudF8xLk1vdXNlRXZlbnQuUE9JTlRFUl9VUCwgdGhpcy5vbkRyYWdFbmQpO1xuICAgICAgICBidW5ueS5hZGRFdmVudExpc3RlbmVyKE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50LlBPSU5URVJfVVBfT1VUU0lERSwgdGhpcy5vbkRyYWdFbmQpO1xuICAgICAgICBidW5ueS5hZGRFdmVudExpc3RlbmVyKE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50LlBPSU5URVJfTU9WRSwgdGhpcy5vbkRyYWdNb3ZlKTtcbiAgICAgICAgLy8gRm9yIG1vdXNlLW9ubHkgZXZlbnRzXG4gICAgICAgIC8vIC5vbignbW91c2Vkb3duJywgb25EcmFnU3RhcnQpXG4gICAgICAgIC8vIC5vbignbW91c2V1cCcsIG9uRHJhZ0VuZClcbiAgICAgICAgLy8gLm9uKCdtb3VzZXVwb3V0c2lkZScsIG9uRHJhZ0VuZClcbiAgICAgICAgLy8gLm9uKCdtb3VzZW1vdmUnLCBvbkRyYWdNb3ZlKTtcbiAgICAgICAgLy8gRm9yIHRvdWNoLW9ubHkgZXZlbnRzXG4gICAgICAgIC8vIC5vbigndG91Y2hzdGFydCcsIG9uRHJhZ1N0YXJ0KVxuICAgICAgICAvLyAub24oJ3RvdWNoZW5kJywgb25EcmFnRW5kKVxuICAgICAgICAvLyAub24oJ3RvdWNoZW5kb3V0c2lkZScsIG9uRHJhZ0VuZClcbiAgICAgICAgLy8gLm9uKCd0b3VjaG1vdmUnLCBvbkRyYWdNb3ZlKTtcbiAgICAgICAgYnVubnkueCA9IHg7XG4gICAgICAgIGJ1bm55LnkgPSB5O1xuICAgICAgICB0aGlzLnN0YWdlLmFkZENoaWxkKGJ1bm55KTtcbiAgICB9XG59XG5leHBvcnRzLkludGVyYWN0aW9uRHJhZ2dpbmcgPSBJbnRlcmFjdGlvbkRyYWdnaW5nO1xuY2xhc3MgRXh0ZW5kZWRTcHJpdGUgZXh0ZW5kcyBTcHJpdGVfMS5TcHJpdGUge1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBCYXNlRXhhbXBsZV8xID0gcmVxdWlyZShcIi4vQmFzZUV4YW1wbGVcIik7XG5jb25zdCBTcHJpdGVfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9TcHJpdGVcIik7XG5jb25zdCBSZXNvdXJjZUxvYWRlcl8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1Jlc291cmNlTG9hZGVyXCIpO1xuY29uc3QgVGV4dHVyZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1RleHR1cmVcIik7XG5jb25zdCBVUkxSZXF1ZXN0XzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvVVJMUmVxdWVzdFwiKTtcbmNvbnN0IEV2ZW50XzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvRXZlbnRcIik7XG5jb25zdCBCYXNlVGV4dHVyZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0Jhc2VUZXh0dXJlXCIpO1xuY29uc3QgTW91c2VFdmVudF8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL01vdXNlRXZlbnRcIik7XG5jbGFzcyBJbnRlcmFjdGlvbkljb24gZXh0ZW5kcyBCYXNlRXhhbXBsZV8xLkJhc2VFeGFtcGxlIHtcbiAgICBjb25zdHJ1Y3RvcihhcHAsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgc3VwZXIoYXBwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgdGhpcy5oYW5kbGVCdXR0b25PdmVyTG9hZGVkID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnRleHR1cmVCdXR0b25PdmVyID0gbmV3IFRleHR1cmVfMS5UZXh0dXJlKG5ldyBCYXNlVGV4dHVyZV8xLkJhc2VUZXh0dXJlKHRoaXMubG9hZGVyLmltYWdlRGF0YSkpO1xuICAgICAgICAgICAgY29uc3QgYnV0dG9ucyA9IFtdO1xuICAgICAgICAgICAgY29uc3QgYnV0dG9uUG9zaXRpb25zID0gW1xuICAgICAgICAgICAgICAgIDE3NSwgNzUsXG4gICAgICAgICAgICAgICAgNjU1LCA3NSxcbiAgICAgICAgICAgICAgICA0MTAsIDMyNSxcbiAgICAgICAgICAgICAgICAxNTAsIDQ2NSxcbiAgICAgICAgICAgICAgICA2ODUsIDQ0NSxcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDU7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJ1dHRvbiA9IG5ldyBFeHRlbmRlZFNwcml0ZSh0aGlzLnRleHR1cmVCdXR0b24pO1xuICAgICAgICAgICAgICAgIGJ1dHRvbi5hbmNob3Iuc2V0KDAuNSk7XG4gICAgICAgICAgICAgICAgYnV0dG9uLnggPSBidXR0b25Qb3NpdGlvbnNbaSAqIDJdO1xuICAgICAgICAgICAgICAgIGJ1dHRvbi55ID0gYnV0dG9uUG9zaXRpb25zW2kgKiAyICsgMV07XG4gICAgICAgICAgICAgICAgYnV0dG9uLmludGVyYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBidXR0b24uYnV0dG9uTW9kZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoTW91c2VFdmVudF8xLk1vdXNlRXZlbnQuUE9JTlRFUl9ET1dOLCB0aGlzLm9uQnV0dG9uRG93bik7XG4gICAgICAgICAgICAgICAgYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoTW91c2VFdmVudF8xLk1vdXNlRXZlbnQuUE9JTlRFUl9VUCwgdGhpcy5vbkJ1dHRvblVwKTtcbiAgICAgICAgICAgICAgICBidXR0b24uYWRkRXZlbnRMaXN0ZW5lcihNb3VzZUV2ZW50XzEuTW91c2VFdmVudC5QT0lOVEVSX1VQX09VVFNJREUsIHRoaXMub25CdXR0b25VcCk7XG4gICAgICAgICAgICAgICAgYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoTW91c2VFdmVudF8xLk1vdXNlRXZlbnQuUE9JTlRFUl9PVkVSLCB0aGlzLm9uQnV0dG9uT3Zlcik7XG4gICAgICAgICAgICAgICAgYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoTW91c2VFdmVudF8xLk1vdXNlRXZlbnQuUE9JTlRFUl9PVVQsIHRoaXMub25CdXR0b25PdXQpO1xuICAgICAgICAgICAgICAgIC8vIGJ1dHRvbi5vbignbW91c2Vkb3duJywgb25CdXR0b25Eb3duKVxuICAgICAgICAgICAgICAgIC8vIGJ1dHRvbi5vbignbW91c2V1cCcsIG9uQnV0dG9uVXApXG4gICAgICAgICAgICAgICAgLy8gYnV0dG9uLm9uKCdtb3VzZXVwb3V0c2lkZScsIG9uQnV0dG9uVXApXG4gICAgICAgICAgICAgICAgLy8gYnV0dG9uLm9uKCdtb3VzZW92ZXInLCBvbkJ1dHRvbk92ZXIpXG4gICAgICAgICAgICAgICAgLy8gYnV0dG9uLm9uKCdtb3VzZW91dCcsIG9uQnV0dG9uT3V0KVxuICAgICAgICAgICAgICAgIC8vIFVzZSB0b3VjaC1vbmx5IGV2ZW50c1xuICAgICAgICAgICAgICAgIC8vIC5vbigndG91Y2hzdGFydCcsIG9uQnV0dG9uRG93bilcbiAgICAgICAgICAgICAgICAvLyAub24oJ3RvdWNoZW5kJywgb25CdXR0b25VcClcbiAgICAgICAgICAgICAgICAvLyAub24oJ3RvdWNoZW5kb3V0c2lkZScsIG9uQnV0dG9uVXApXG4gICAgICAgICAgICAgICAgdGhpcy5zdGFnZS5hZGRDaGlsZChidXR0b24pO1xuICAgICAgICAgICAgICAgIGJ1dHRvbnMucHVzaChidXR0b24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnV0dG9uc1swXS5zY2FsZS5zZXQoMS4yKTtcbiAgICAgICAgICAgIGJ1dHRvbnNbMl0ucm90YXRpb24gPSBNYXRoLlBJIC8gMTA7XG4gICAgICAgICAgICBidXR0b25zWzNdLnNjYWxlLnNldCgwLjgpO1xuICAgICAgICAgICAgYnV0dG9uc1s0XS5zY2FsZS5zZXQoMC44LCAxLjIpO1xuICAgICAgICAgICAgYnV0dG9uc1s0XS5yb3RhdGlvbiA9IE1hdGguUEk7XG4gICAgICAgICAgICB0aGlzLmV4YW1wbGVSZWFkeSgpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLm9uQnV0dG9uRG93biA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgbGV0IGJ1dHRvbiA9IGV2ZW50LmN1cnJlbnRUYXJnZXQ7XG4gICAgICAgICAgICBidXR0b24uaXNkb3duID0gdHJ1ZTtcbiAgICAgICAgICAgIGJ1dHRvbi50ZXh0dXJlID0gdGhpcy50ZXh0dXJlQnV0dG9uRG93bjtcbiAgICAgICAgICAgIGJ1dHRvbi5hbHBoYSA9IDE7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMub25CdXR0b25VcCA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgbGV0IGJ1dHRvbiA9IGV2ZW50LmN1cnJlbnRUYXJnZXQ7XG4gICAgICAgICAgICBidXR0b24uaXNkb3duID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoYnV0dG9uLmlzT3Zlcikge1xuICAgICAgICAgICAgICAgIGJ1dHRvbi50ZXh0dXJlID0gdGhpcy50ZXh0dXJlQnV0dG9uT3ZlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGJ1dHRvbi50ZXh0dXJlID0gdGhpcy50ZXh0dXJlQnV0dG9uO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLm9uQnV0dG9uT3ZlciA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgbGV0IGJ1dHRvbiA9IGV2ZW50LmN1cnJlbnRUYXJnZXQ7XG4gICAgICAgICAgICBidXR0b24uaXNPdmVyID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChidXR0b24uaXNkb3duKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnV0dG9uLnRleHR1cmUgPSB0aGlzLnRleHR1cmVCdXR0b25PdmVyO1xuICAgICAgICAgICAgdGhpcy5hcHAucmVuZGVyZXIudmlldy5zdHlsZS5jdXJzb3IgPSBcInVybCgnZXhhbXBsZXMvYXNzZXRzL2J1bm55LnBuZycpLCBwb2ludGVyXCI7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMub25CdXR0b25PdXQgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGxldCBidXR0b24gPSBldmVudC5jdXJyZW50VGFyZ2V0O1xuICAgICAgICAgICAgYnV0dG9uLmlzT3ZlciA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKGJ1dHRvbi5pc2Rvd24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBidXR0b24udGV4dHVyZSA9IHRoaXMudGV4dHVyZUJ1dHRvbjtcbiAgICAgICAgICAgIHRoaXMuYXBwLnJlbmRlcmVyLnZpZXcuc3R5bGUuY3Vyc29yID0gXCJ1cmwoJ2V4YW1wbGVzL2Fzc2V0cy9idW5ueS5wbmcnKSwgcG9pbnRlclwiO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZUJ1dHRvbkRvd25Mb2FkZWQgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIHRoaXMudGV4dHVyZUJ1dHRvbkRvd24gPSBuZXcgVGV4dHVyZV8xLlRleHR1cmUobmV3IEJhc2VUZXh0dXJlXzEuQmFzZVRleHR1cmUodGhpcy5sb2FkZXIuaW1hZ2VEYXRhKSk7XG4gICAgICAgICAgICB0aGlzLmxvYWRlciA9IG5ldyBSZXNvdXJjZUxvYWRlcl8xLlJlc291cmNlTG9hZGVyKG5ldyBVUkxSZXF1ZXN0XzEuVVJMUmVxdWVzdChcImV4YW1wbGVzL2Fzc2V0cy9idXR0b25fb3Zlci5wbmdcIikpO1xuICAgICAgICAgICAgdGhpcy5sb2FkZXIuYWRkRXZlbnRMaXN0ZW5lcihFdmVudF8xLkV2ZW50LkNPTVBMRVRFLCB0aGlzLmhhbmRsZUJ1dHRvbk92ZXJMb2FkZWQpO1xuICAgICAgICAgICAgdGhpcy5sb2FkZXIubG9hZCgpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZUJ1dHRvbkxvYWRlZCA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgdGhpcy50ZXh0dXJlQnV0dG9uID0gbmV3IFRleHR1cmVfMS5UZXh0dXJlKG5ldyBCYXNlVGV4dHVyZV8xLkJhc2VUZXh0dXJlKHRoaXMubG9hZGVyLmltYWdlRGF0YSkpO1xuICAgICAgICAgICAgdGhpcy5sb2FkZXIgPSBuZXcgUmVzb3VyY2VMb2FkZXJfMS5SZXNvdXJjZUxvYWRlcihuZXcgVVJMUmVxdWVzdF8xLlVSTFJlcXVlc3QoXCJleGFtcGxlcy9hc3NldHMvYnV0dG9uX2Rvd24ucG5nXCIpKTtcbiAgICAgICAgICAgIHRoaXMubG9hZGVyLmFkZEV2ZW50TGlzdGVuZXIoRXZlbnRfMS5FdmVudC5DT01QTEVURSwgdGhpcy5oYW5kbGVCdXR0b25Eb3duTG9hZGVkKTtcbiAgICAgICAgICAgIHRoaXMubG9hZGVyLmxvYWQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVSb3RhdGVMb2FkZWQgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGxldCB0eHQgPSBuZXcgVGV4dHVyZV8xLlRleHR1cmUobmV3IEJhc2VUZXh0dXJlXzEuQmFzZVRleHR1cmUodGhpcy5sb2FkZXIuaW1hZ2VEYXRhKSk7XG4gICAgICAgICAgICBjb25zdCBiYWNrZ3JvdW5kID0gbmV3IFNwcml0ZV8xLlNwcml0ZSh0eHQpO1xuICAgICAgICAgICAgYmFja2dyb3VuZC53aWR0aCA9IHRoaXMuc2l6ZXc7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kLmhlaWdodCA9IHRoaXMuc2l6ZWg7XG4gICAgICAgICAgICB0aGlzLnN0YWdlLmFkZENoaWxkKGJhY2tncm91bmQpO1xuICAgICAgICAgICAgdGhpcy5sb2FkZXIgPSBuZXcgUmVzb3VyY2VMb2FkZXJfMS5SZXNvdXJjZUxvYWRlcihuZXcgVVJMUmVxdWVzdF8xLlVSTFJlcXVlc3QoXCJleGFtcGxlcy9hc3NldHMvYnV0dG9uLnBuZ1wiKSk7XG4gICAgICAgICAgICB0aGlzLmxvYWRlci5hZGRFdmVudExpc3RlbmVyKEV2ZW50XzEuRXZlbnQuQ09NUExFVEUsIHRoaXMuaGFuZGxlQnV0dG9uTG9hZGVkKTtcbiAgICAgICAgICAgIHRoaXMubG9hZGVyLmxvYWQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZGVmYXVsdEljb24gPSBcInVybCgnZXhhbXBsZXMvYXNzZXRzL2J1bm55LnBuZycpLGF1dG87XCI7XG4gICAgICAgIGNvbnN0IGhvdmVySWNvbiA9IFwidXJsKCdleGFtcGxlcy9hc3NldHMvYnVubnlfc2F0dXJhdGVkLnBuZycpLGF1dG87XCI7XG4gICAgICAgIHRoaXMubG9hZGVyID0gbmV3IFJlc291cmNlTG9hZGVyXzEuUmVzb3VyY2VMb2FkZXIobmV3IFVSTFJlcXVlc3RfMS5VUkxSZXF1ZXN0KFwiZXhhbXBsZXMvYXNzZXRzL2JnX2J1dHRvbi5qcGdcIikpO1xuICAgICAgICB0aGlzLmxvYWRlci5hZGRFdmVudExpc3RlbmVyKEV2ZW50XzEuRXZlbnQuQ09NUExFVEUsIHRoaXMuaGFuZGxlUm90YXRlTG9hZGVkKTtcbiAgICAgICAgdGhpcy5sb2FkZXIubG9hZCgpO1xuICAgIH1cbiAgICBkZXN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlci5kZXN0cnVjdG9yKCk7XG4gICAgICAgIHRoaXMudGV4dHVyZUJ1dHRvbi5kZXN0cm95KG51bGwpO1xuICAgICAgICB0aGlzLnRleHR1cmVCdXR0b24gPSBudWxsO1xuICAgICAgICB0aGlzLnRleHR1cmVCdXR0b25PdmVyLmRlc3Ryb3kobnVsbCk7XG4gICAgICAgIHRoaXMudGV4dHVyZUJ1dHRvbk92ZXIgPSBudWxsO1xuICAgICAgICB0aGlzLnRleHR1cmVCdXR0b25Eb3duLmRlc3Ryb3kobnVsbCk7XG4gICAgICAgIHRoaXMudGV4dHVyZUJ1dHRvbkRvd24gPSBudWxsO1xuICAgIH1cbn1cbmV4cG9ydHMuSW50ZXJhY3Rpb25JY29uID0gSW50ZXJhY3Rpb25JY29uO1xuY2xhc3MgRXh0ZW5kZWRTcHJpdGUgZXh0ZW5kcyBTcHJpdGVfMS5TcHJpdGUge1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBCYXNlRXhhbXBsZV8xID0gcmVxdWlyZShcIi4vQmFzZUV4YW1wbGVcIik7XG5jb25zdCBSZXNvdXJjZUxvYWRlcl8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1Jlc291cmNlTG9hZGVyXCIpO1xuY29uc3QgVVJMUmVxdWVzdF8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1VSTFJlcXVlc3RcIik7XG5jb25zdCBFdmVudF8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0V2ZW50XCIpO1xuY29uc3QgVGV4dHVyZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1RleHR1cmVcIik7XG5jb25zdCBCYXNlVGV4dHVyZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0Jhc2VUZXh0dXJlXCIpO1xuY29uc3QgU3ByaXRlXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvU3ByaXRlXCIpO1xuY29uc3QgTW91c2VFdmVudF8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL01vdXNlRXZlbnRcIik7XG5jbGFzcyBJbnRlcmFjdGlvbkludGVyYWN0aXZpdHkgZXh0ZW5kcyBCYXNlRXhhbXBsZV8xLkJhc2VFeGFtcGxlIHtcbiAgICBjb25zdHJ1Y3RvcihhcHAsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgc3VwZXIoYXBwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgdGhpcy5oYW5kbGVCdXR0b25PdmVyTG9hZGVkID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnRleHR1cmVCdXR0b25PdmVyID0gbmV3IFRleHR1cmVfMS5UZXh0dXJlKG5ldyBCYXNlVGV4dHVyZV8xLkJhc2VUZXh0dXJlKHRoaXMubG9hZGVyLmltYWdlRGF0YSkpO1xuICAgICAgICAgICAgY29uc3QgYnV0dG9ucyA9IFtdO1xuICAgICAgICAgICAgY29uc3QgYnV0dG9uUG9zaXRpb25zID0gW1xuICAgICAgICAgICAgICAgIDE3NSwgNzUsXG4gICAgICAgICAgICAgICAgNjU1LCA3NSxcbiAgICAgICAgICAgICAgICA0MTAsIDMyNSxcbiAgICAgICAgICAgICAgICAxNTAsIDQ2NSxcbiAgICAgICAgICAgICAgICA2ODUsIDQ0NSxcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDU7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJ1dHRvbiA9IG5ldyBFeHRlbmRlZFNwcml0ZSh0aGlzLnRleHR1cmVCdXR0b24pO1xuICAgICAgICAgICAgICAgIGJ1dHRvbi5idXR0b25Nb2RlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBidXR0b24uYW5jaG9yLnNldCgwLjUpO1xuICAgICAgICAgICAgICAgIGJ1dHRvbi54ID0gYnV0dG9uUG9zaXRpb25zW2kgKiAyXTtcbiAgICAgICAgICAgICAgICBidXR0b24ueSA9IGJ1dHRvblBvc2l0aW9uc1tpICogMiArIDFdO1xuICAgICAgICAgICAgICAgIGJ1dHRvbi5pbnRlcmFjdGl2ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnV0dG9uLmJ1dHRvbk1vZGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50LlBPSU5URVJfRE9XTiwgdGhpcy5vbkJ1dHRvbkRvd24pO1xuICAgICAgICAgICAgICAgIGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50LlBPSU5URVJfVVAsIHRoaXMub25CdXR0b25VcCk7XG4gICAgICAgICAgICAgICAgYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoTW91c2VFdmVudF8xLk1vdXNlRXZlbnQuUE9JTlRFUl9VUF9PVVRTSURFLCB0aGlzLm9uQnV0dG9uVXApO1xuICAgICAgICAgICAgICAgIGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50LlBPSU5URVJfT1ZFUiwgdGhpcy5vbkJ1dHRvbk92ZXIpO1xuICAgICAgICAgICAgICAgIGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50LlBPSU5URVJfT1VULCB0aGlzLm9uQnV0dG9uT3V0KTtcbiAgICAgICAgICAgICAgICAvLyBidXR0b24ub24oJ21vdXNlZG93bicsIG9uQnV0dG9uRG93bilcbiAgICAgICAgICAgICAgICAvLyBidXR0b24ub24oJ21vdXNldXAnLCBvbkJ1dHRvblVwKVxuICAgICAgICAgICAgICAgIC8vIGJ1dHRvbi5vbignbW91c2V1cG91dHNpZGUnLCBvbkJ1dHRvblVwKVxuICAgICAgICAgICAgICAgIC8vIGJ1dHRvbi5vbignbW91c2VvdmVyJywgb25CdXR0b25PdmVyKVxuICAgICAgICAgICAgICAgIC8vIGJ1dHRvbi5vbignbW91c2VvdXQnLCBvbkJ1dHRvbk91dClcbiAgICAgICAgICAgICAgICAvLyBVc2UgdG91Y2gtb25seSBldmVudHNcbiAgICAgICAgICAgICAgICAvLyAub24oJ3RvdWNoc3RhcnQnLCBvbkJ1dHRvbkRvd24pXG4gICAgICAgICAgICAgICAgLy8gLm9uKCd0b3VjaGVuZCcsIG9uQnV0dG9uVXApXG4gICAgICAgICAgICAgICAgLy8gLm9uKCd0b3VjaGVuZG91dHNpZGUnLCBvbkJ1dHRvblVwKVxuICAgICAgICAgICAgICAgIHRoaXMuc3RhZ2UuYWRkQ2hpbGQoYnV0dG9uKTtcbiAgICAgICAgICAgICAgICBidXR0b25zLnB1c2goYnV0dG9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJ1dHRvbnNbMF0uc2NhbGUuc2V0KDEuMik7XG4gICAgICAgICAgICBidXR0b25zWzJdLnJvdGF0aW9uID0gTWF0aC5QSSAvIDEwO1xuICAgICAgICAgICAgYnV0dG9uc1szXS5zY2FsZS5zZXQoMC44KTtcbiAgICAgICAgICAgIGJ1dHRvbnNbNF0uc2NhbGUuc2V0KDAuOCwgMS4yKTtcbiAgICAgICAgICAgIGJ1dHRvbnNbNF0ucm90YXRpb24gPSBNYXRoLlBJO1xuICAgICAgICAgICAgdGhpcy5leGFtcGxlUmVhZHkoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vbkJ1dHRvbkRvd24gPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGxldCBidXR0b24gPSBldmVudC5jdXJyZW50VGFyZ2V0O1xuICAgICAgICAgICAgYnV0dG9uLmlzZG93biA9IHRydWU7XG4gICAgICAgICAgICBidXR0b24udGV4dHVyZSA9IHRoaXMudGV4dHVyZUJ1dHRvbkRvd247XG4gICAgICAgICAgICBidXR0b24uYWxwaGEgPSAxO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLm9uQnV0dG9uVXAgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGxldCBidXR0b24gPSBldmVudC5jdXJyZW50VGFyZ2V0O1xuICAgICAgICAgICAgYnV0dG9uLmlzZG93biA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKGJ1dHRvbi5pc092ZXIpIHtcbiAgICAgICAgICAgICAgICBidXR0b24udGV4dHVyZSA9IHRoaXMudGV4dHVyZUJ1dHRvbk92ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBidXR0b24udGV4dHVyZSA9IHRoaXMudGV4dHVyZUJ1dHRvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vbkJ1dHRvbk92ZXIgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGxldCBidXR0b24gPSBldmVudC5jdXJyZW50VGFyZ2V0O1xuICAgICAgICAgICAgYnV0dG9uLmlzT3ZlciA9IHRydWU7XG4gICAgICAgICAgICBpZiAoYnV0dG9uLmlzZG93bikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJ1dHRvbi50ZXh0dXJlID0gdGhpcy50ZXh0dXJlQnV0dG9uT3ZlcjtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vbkJ1dHRvbk91dCA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgbGV0IGJ1dHRvbiA9IGV2ZW50LmN1cnJlbnRUYXJnZXQ7XG4gICAgICAgICAgICBidXR0b24uaXNPdmVyID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoYnV0dG9uLmlzZG93bikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJ1dHRvbi50ZXh0dXJlID0gdGhpcy50ZXh0dXJlQnV0dG9uO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZUJ1dHRvbkRvd25Mb2FkZWQgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIHRoaXMudGV4dHVyZUJ1dHRvbkRvd24gPSBuZXcgVGV4dHVyZV8xLlRleHR1cmUobmV3IEJhc2VUZXh0dXJlXzEuQmFzZVRleHR1cmUodGhpcy5sb2FkZXIuaW1hZ2VEYXRhKSk7XG4gICAgICAgICAgICB0aGlzLmxvYWRlciA9IG5ldyBSZXNvdXJjZUxvYWRlcl8xLlJlc291cmNlTG9hZGVyKG5ldyBVUkxSZXF1ZXN0XzEuVVJMUmVxdWVzdChcImV4YW1wbGVzL2Fzc2V0cy9idXR0b25fb3Zlci5wbmdcIikpO1xuICAgICAgICAgICAgdGhpcy5sb2FkZXIuYWRkRXZlbnRMaXN0ZW5lcihFdmVudF8xLkV2ZW50LkNPTVBMRVRFLCB0aGlzLmhhbmRsZUJ1dHRvbk92ZXJMb2FkZWQpO1xuICAgICAgICAgICAgdGhpcy5sb2FkZXIubG9hZCgpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZUJ1dHRvbkxvYWRlZCA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgdGhpcy50ZXh0dXJlQnV0dG9uID0gbmV3IFRleHR1cmVfMS5UZXh0dXJlKG5ldyBCYXNlVGV4dHVyZV8xLkJhc2VUZXh0dXJlKHRoaXMubG9hZGVyLmltYWdlRGF0YSkpO1xuICAgICAgICAgICAgdGhpcy5sb2FkZXIgPSBuZXcgUmVzb3VyY2VMb2FkZXJfMS5SZXNvdXJjZUxvYWRlcihuZXcgVVJMUmVxdWVzdF8xLlVSTFJlcXVlc3QoXCJleGFtcGxlcy9hc3NldHMvYnV0dG9uX2Rvd24ucG5nXCIpKTtcbiAgICAgICAgICAgIHRoaXMubG9hZGVyLmFkZEV2ZW50TGlzdGVuZXIoRXZlbnRfMS5FdmVudC5DT01QTEVURSwgdGhpcy5oYW5kbGVCdXR0b25Eb3duTG9hZGVkKTtcbiAgICAgICAgICAgIHRoaXMubG9hZGVyLmxvYWQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVSb3RhdGVMb2FkZWQgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGxldCB0eHQgPSBuZXcgVGV4dHVyZV8xLlRleHR1cmUobmV3IEJhc2VUZXh0dXJlXzEuQmFzZVRleHR1cmUodGhpcy5sb2FkZXIuaW1hZ2VEYXRhKSk7XG4gICAgICAgICAgICBjb25zdCBiYWNrZ3JvdW5kID0gbmV3IFNwcml0ZV8xLlNwcml0ZSh0eHQpO1xuICAgICAgICAgICAgYmFja2dyb3VuZC53aWR0aCA9IHRoaXMuc2l6ZXc7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kLmhlaWdodCA9IHRoaXMuc2l6ZWg7XG4gICAgICAgICAgICB0aGlzLnN0YWdlLmFkZENoaWxkKGJhY2tncm91bmQpO1xuICAgICAgICAgICAgdGhpcy5sb2FkZXIgPSBuZXcgUmVzb3VyY2VMb2FkZXJfMS5SZXNvdXJjZUxvYWRlcihuZXcgVVJMUmVxdWVzdF8xLlVSTFJlcXVlc3QoXCJleGFtcGxlcy9hc3NldHMvYnV0dG9uLnBuZ1wiKSk7XG4gICAgICAgICAgICB0aGlzLmxvYWRlci5hZGRFdmVudExpc3RlbmVyKEV2ZW50XzEuRXZlbnQuQ09NUExFVEUsIHRoaXMuaGFuZGxlQnV0dG9uTG9hZGVkKTtcbiAgICAgICAgICAgIHRoaXMubG9hZGVyLmxvYWQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5sb2FkZXIgPSBuZXcgUmVzb3VyY2VMb2FkZXJfMS5SZXNvdXJjZUxvYWRlcihuZXcgVVJMUmVxdWVzdF8xLlVSTFJlcXVlc3QoXCJleGFtcGxlcy9hc3NldHMvYmdfYnV0dG9uLmpwZ1wiKSk7XG4gICAgICAgIHRoaXMubG9hZGVyLmFkZEV2ZW50TGlzdGVuZXIoRXZlbnRfMS5FdmVudC5DT01QTEVURSwgdGhpcy5oYW5kbGVSb3RhdGVMb2FkZWQpO1xuICAgICAgICB0aGlzLmxvYWRlci5sb2FkKCk7XG4gICAgfVxuICAgIGRlc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyLmRlc3RydWN0b3IoKTtcbiAgICAgICAgdGhpcy50ZXh0dXJlQnV0dG9uLmRlc3Ryb3kobnVsbCk7XG4gICAgICAgIHRoaXMudGV4dHVyZUJ1dHRvbiA9IG51bGw7XG4gICAgICAgIHRoaXMudGV4dHVyZUJ1dHRvbk92ZXIuZGVzdHJveShudWxsKTtcbiAgICAgICAgdGhpcy50ZXh0dXJlQnV0dG9uT3ZlciA9IG51bGw7XG4gICAgICAgIHRoaXMudGV4dHVyZUJ1dHRvbkRvd24uZGVzdHJveShudWxsKTtcbiAgICAgICAgdGhpcy50ZXh0dXJlQnV0dG9uRG93biA9IG51bGw7XG4gICAgfVxufVxuZXhwb3J0cy5JbnRlcmFjdGlvbkludGVyYWN0aXZpdHkgPSBJbnRlcmFjdGlvbkludGVyYWN0aXZpdHk7XG5jbGFzcyBFeHRlbmRlZFNwcml0ZSBleHRlbmRzIFNwcml0ZV8xLlNwcml0ZSB7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IEJhc2VFeGFtcGxlXzEgPSByZXF1aXJlKFwiLi9CYXNlRXhhbXBsZVwiKTtcbmNvbnN0IFJlc291cmNlTG9hZGVyXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvUmVzb3VyY2VMb2FkZXJcIik7XG5jb25zdCBUZXh0dXJlXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvVGV4dHVyZVwiKTtcbmNvbnN0IFVSTFJlcXVlc3RfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9VUkxSZXF1ZXN0XCIpO1xuY29uc3QgRXZlbnRfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9FdmVudFwiKTtcbmNvbnN0IEJhc2VUZXh0dXJlXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvQmFzZVRleHR1cmVcIik7XG5jb25zdCBHcmFwaGljc18xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0dyYXBoaWNzXCIpO1xuY29uc3QgQmx1ckZpbHRlcl8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0JsdXJGaWx0ZXJcIik7XG5jb25zdCBSZWN0YW5nbGVfMSA9IHJlcXVpcmUoXCIuLi9mbGFzaC9nZW9tL1JlY3RhbmdsZVwiKTtcbmNvbnN0IFdlYkdMU2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9XZWJHTFNldHRpbmdzXCIpO1xuY29uc3QgU3ByaXRlXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvU3ByaXRlXCIpO1xuY29uc3QgTW91c2VFdmVudF8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL01vdXNlRXZlbnRcIik7XG5jbGFzcyBNYXNrRmlsdGVyIGV4dGVuZHMgQmFzZUV4YW1wbGVfMS5CYXNlRXhhbXBsZSB7XG4gICAgY29uc3RydWN0b3IoYXBwLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHN1cGVyKGFwcCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIHRoaXMuaGFuZGxlUm90YXRlTG9hZGVkID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICB0aGlzLmZsYWdUeHQgPSBuZXcgVGV4dHVyZV8xLlRleHR1cmUobmV3IEJhc2VUZXh0dXJlXzEuQmFzZVRleHR1cmUodGhpcy5sb2FkZXIuaW1hZ2VEYXRhKSk7XG4gICAgICAgICAgICBjb25zdCByYWRpdXMgPSAxMDA7XG4gICAgICAgICAgICBjb25zdCBibHVyU2l6ZSA9IDMyO1xuICAgICAgICAgICAgY29uc3QgYmFja2dyb3VuZCA9IG5ldyBTcHJpdGVfMS5TcHJpdGUodGhpcy5mbGFnVHh0KTtcbiAgICAgICAgICAgIHRoaXMuc3RhZ2UuYWRkQ2hpbGQoYmFja2dyb3VuZCk7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kLndpZHRoID0gdGhpcy5zaXpldztcbiAgICAgICAgICAgIGJhY2tncm91bmQuaGVpZ2h0ID0gdGhpcy5zaXplaDtcbiAgICAgICAgICAgIGNvbnN0IGNpcmNsZSA9IG5ldyBHcmFwaGljc18xLkdyYXBoaWNzKClcbiAgICAgICAgICAgICAgICAuYmVnaW5GaWxsKDB4RkYwMDAwKVxuICAgICAgICAgICAgICAgIC5kcmF3Q2lyY2xlKHJhZGl1cyArIGJsdXJTaXplLCByYWRpdXMgKyBibHVyU2l6ZSwgcmFkaXVzKVxuICAgICAgICAgICAgICAgIC5lbmRGaWxsKCk7XG4gICAgICAgICAgICBjaXJjbGUuZmlsdGVycyA9IFtuZXcgQmx1ckZpbHRlcl8xLkJsdXJGaWx0ZXIoYmx1clNpemUpXTtcbiAgICAgICAgICAgIGNvbnN0IGJvdW5kcyA9IFJlY3RhbmdsZV8xLlJlY3RhbmdsZS5nZXRSZWN0YW5nbGUoMCwgMCwgKHJhZGl1cyArIGJsdXJTaXplKSAqIDIsIChyYWRpdXMgKyBibHVyU2l6ZSkgKiAyKTtcbiAgICAgICAgICAgIGNvbnN0IHRleHR1cmUgPSB0aGlzLmFwcC5yZW5kZXJlci5nZW5lcmF0ZVRleHR1cmUoY2lyY2xlLCBXZWJHTFNldHRpbmdzXzEuV2ViR0xTZXR0aW5ncy5TQ0FMRV9NT0RFUy5ORUFSRVNULCAxLCBib3VuZHMpO1xuICAgICAgICAgICAgdGhpcy5mb2N1cyA9IG5ldyBTcHJpdGVfMS5TcHJpdGUodGV4dHVyZSk7XG4gICAgICAgICAgICB0aGlzLnN0YWdlLmFkZENoaWxkKHRoaXMuZm9jdXMpO1xuICAgICAgICAgICAgYmFja2dyb3VuZC5tYXNrID0gdGhpcy5mb2N1cztcbiAgICAgICAgICAgIHRoaXMuc3RhZ2UuaW50ZXJhY3RpdmUgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5zdGFnZS5hZGRFdmVudExpc3RlbmVyKE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50Lk1PVVNFX01PVkUsIHRoaXMucG9pbnRlck1vdmUpO1xuICAgICAgICAgICAgdGhpcy5leGFtcGxlUmVhZHkoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5wb2ludGVyTW92ZSA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5mb2N1cy5wb3NpdGlvbi54ID0gZXZlbnQuZGF0YS5nbG9iYWwueCAtIHRoaXMuZm9jdXMud2lkdGggLyAyO1xuICAgICAgICAgICAgdGhpcy5mb2N1cy5wb3NpdGlvbi55ID0gZXZlbnQuZGF0YS5nbG9iYWwueSAtIHRoaXMuZm9jdXMuaGVpZ2h0IC8gMjtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5iYWNrQ29sb3IgPSAwO1xuICAgICAgICB0aGlzLmxvYWRlciA9IG5ldyBSZXNvdXJjZUxvYWRlcl8xLlJlc291cmNlTG9hZGVyKG5ldyBVUkxSZXF1ZXN0XzEuVVJMUmVxdWVzdChcImV4YW1wbGVzL2Fzc2V0cy9iZ19ncmFzcy5qcGdcIikpO1xuICAgICAgICB0aGlzLmxvYWRlci5hZGRFdmVudExpc3RlbmVyKEV2ZW50XzEuRXZlbnQuQ09NUExFVEUsIHRoaXMuaGFuZGxlUm90YXRlTG9hZGVkKTtcbiAgICAgICAgdGhpcy5sb2FkZXIubG9hZCgpO1xuICAgIH1cbiAgICBkZXN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlci5kZXN0cnVjdG9yKCk7XG4gICAgICAgIHRoaXMuZmxhZ1R4dC5kZXN0cm95KG51bGwpO1xuICAgICAgICB0aGlzLmZsYWdUeHQgPSBudWxsO1xuICAgICAgICB0aGlzLmZvY3VzLmRlc3Ryb3kobnVsbCk7XG4gICAgICAgIHRoaXMuZm9jdXMgPSBudWxsO1xuICAgIH1cbn1cbmV4cG9ydHMuTWFza0ZpbHRlciA9IE1hc2tGaWx0ZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IEJhc2VFeGFtcGxlXzEgPSByZXF1aXJlKFwiLi9CYXNlRXhhbXBsZVwiKTtcbmNvbnN0IFJlc291cmNlTG9hZGVyXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvUmVzb3VyY2VMb2FkZXJcIik7XG5jb25zdCBVUkxSZXF1ZXN0XzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvVVJMUmVxdWVzdFwiKTtcbmNvbnN0IEV2ZW50XzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvRXZlbnRcIik7XG5jb25zdCBUZXh0dXJlXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvVGV4dHVyZVwiKTtcbmNvbnN0IEJhc2VUZXh0dXJlXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvQmFzZVRleHR1cmVcIik7XG5jb25zdCBTcHJpdGVfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9TcHJpdGVcIik7XG5jb25zdCBDb250YWluZXJfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9Db250YWluZXJcIik7XG5jb25zdCBHcmFwaGljc18xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0dyYXBoaWNzXCIpO1xuY29uc3QgTW91c2VFdmVudF8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL01vdXNlRXZlbnRcIik7XG5jb25zdCBUZXh0XzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvVGV4dFwiKTtcbmNsYXNzIE1hc2tHcmFwaGljcyBleHRlbmRzIEJhc2VFeGFtcGxlXzEuQmFzZUV4YW1wbGUge1xuICAgIGNvbnN0cnVjdG9yKGFwcCwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICBzdXBlcihhcHAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICB0aGlzLmhhbmRsZVBhbmRhTG9hZGVkID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnBhbmRhVHh0ID0gbmV3IFRleHR1cmVfMS5UZXh0dXJlKG5ldyBCYXNlVGV4dHVyZV8xLkJhc2VUZXh0dXJlKHRoaXMubG9hZGVyLmltYWdlRGF0YSkpO1xuICAgICAgICAgICAgdGhpcy5iZyA9IG5ldyBTcHJpdGVfMS5TcHJpdGUodGhpcy5yb3RhdGVUeHQpO1xuICAgICAgICAgICAgdGhpcy5iZy5hbmNob3Iuc2V0KDAuNSk7XG4gICAgICAgICAgICB0aGlzLmJnLnggPSB0aGlzLnNpemV3IC8gMjtcbiAgICAgICAgICAgIHRoaXMuYmcueSA9IHRoaXMuc2l6ZWggLyAyO1xuICAgICAgICAgICAgdGhpcy5zdGFnZS5hZGRDaGlsZCh0aGlzLmJnKTtcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyID0gbmV3IENvbnRhaW5lcl8xLkNvbnRhaW5lcigpO1xuICAgICAgICAgICAgdGhpcy5jb250YWluZXIueCA9IHRoaXMuc2l6ZXcgLyAyO1xuICAgICAgICAgICAgdGhpcy5jb250YWluZXIueSA9IHRoaXMuc2l6ZWggLyAyO1xuICAgICAgICAgICAgdGhpcy5iZ0Zyb250ID0gbmV3IFNwcml0ZV8xLlNwcml0ZSh0aGlzLnNjZW5lcm90YXRlVHh0KTtcbiAgICAgICAgICAgIHRoaXMuYmdGcm9udC5hbmNob3Iuc2V0KDAuNSk7XG4gICAgICAgICAgICB0aGlzLmxpZ2h0MiA9IG5ldyBTcHJpdGVfMS5TcHJpdGUodGhpcy5saWdodHJvdGF0ZTJUeHQpO1xuICAgICAgICAgICAgdGhpcy5saWdodDIuYW5jaG9yLnNldCgwLjUpO1xuICAgICAgICAgICAgdGhpcy5saWdodDEgPSBuZXcgU3ByaXRlXzEuU3ByaXRlKHRoaXMubGlnaHRyb3RhdGUxVHh0KTtcbiAgICAgICAgICAgIHRoaXMubGlnaHQxLmFuY2hvci5zZXQoMC41KTtcbiAgICAgICAgICAgIHRoaXMucGFuZGEgPSBuZXcgU3ByaXRlXzEuU3ByaXRlKHRoaXMucGFuZGFUeHQpO1xuICAgICAgICAgICAgdGhpcy5wYW5kYS5hbmNob3Iuc2V0KDAuNSk7XG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5hZGRDaGlsZCh0aGlzLmJnRnJvbnQpO1xuICAgICAgICAgICAgdGhpcy5jb250YWluZXIuYWRkQ2hpbGQodGhpcy5saWdodDIpO1xuICAgICAgICAgICAgdGhpcy5jb250YWluZXIuYWRkQ2hpbGQodGhpcy5saWdodDEpO1xuICAgICAgICAgICAgdGhpcy5jb250YWluZXIuYWRkQ2hpbGQodGhpcy5wYW5kYSk7XG4gICAgICAgICAgICB0aGlzLnN0YWdlLmFkZENoaWxkKHRoaXMuY29udGFpbmVyKTtcbiAgICAgICAgICAgIHRoaXMudGhpbmcgPSBuZXcgR3JhcGhpY3NfMS5HcmFwaGljcygpO1xuICAgICAgICAgICAgdGhpcy5zdGFnZS5hZGRDaGlsZCh0aGlzLnRoaW5nKTtcbiAgICAgICAgICAgIHRoaXMudGhpbmcueCA9IHRoaXMuc2l6ZXcgLyAyO1xuICAgICAgICAgICAgdGhpcy50aGluZy55ID0gdGhpcy5zaXplaCAvIDI7XG4gICAgICAgICAgICB0aGlzLnRoaW5nLmxpbmVTdHlsZSgwKTtcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLm1hc2sgPSB0aGlzLnRoaW5nO1xuICAgICAgICAgICAgdGhpcy5jb3VudCA9IDA7XG4gICAgICAgICAgICB0aGlzLnN0YWdlLmFkZEV2ZW50TGlzdGVuZXIoTW91c2VFdmVudF8xLk1vdXNlRXZlbnQuUE9JTlRFUl9UQVAsIHRoaXMuaGFuZGxlU3RhZ2VUYXApO1xuICAgICAgICAgICAgY29uc3QgaGVscCA9IG5ldyBUZXh0XzEuVGV4dCgnQ2xpY2sgb3IgdGFwIHRvIHR1cm4gbWFza2luZyBvbiAvIG9mZi4nLCB7XG4gICAgICAgICAgICAgICAgZm9udEZhbWlseTogJ0FyaWFsJyxcbiAgICAgICAgICAgICAgICBmb250U2l6ZTogMTIsXG4gICAgICAgICAgICAgICAgZm9udFdlaWdodDogJ2JvbGQnLFxuICAgICAgICAgICAgICAgIGZpbGw6ICd3aGl0ZScsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGhlbHAueSA9IHRoaXMuYXBwLnNjcmVlbi5oZWlnaHQgLSAzNTtcbiAgICAgICAgICAgIGhlbHAueCA9IDE1O1xuICAgICAgICAgICAgdGhpcy5zdGFnZS5hZGRDaGlsZChoZWxwKTtcbiAgICAgICAgICAgIHRoaXMuYXBwLnRpY2tlci5hZGQodGhpcy5ydW5FeGFtcGxlKTtcbiAgICAgICAgICAgIHRoaXMuZXhhbXBsZVJlYWR5KCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucnVuRXhhbXBsZSA9IChkZWx0YSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5iZy5yb3RhdGlvbiArPSAwLjAxO1xuICAgICAgICAgICAgdGhpcy5iZ0Zyb250LnJvdGF0aW9uIC09IDAuMDE7XG4gICAgICAgICAgICB0aGlzLmxpZ2h0MS5yb3RhdGlvbiArPSAwLjAyO1xuICAgICAgICAgICAgdGhpcy5saWdodDIucm90YXRpb24gKz0gMC4wMTtcbiAgICAgICAgICAgIHRoaXMucGFuZGEuc2NhbGUueCA9IDEgKyBNYXRoLnNpbih0aGlzLmNvdW50KSAqIDAuMDQ7XG4gICAgICAgICAgICB0aGlzLnBhbmRhLnNjYWxlLnkgPSAxICsgTWF0aC5jb3ModGhpcy5jb3VudCkgKiAwLjA0O1xuICAgICAgICAgICAgdGhpcy5jb3VudCArPSAwLjE7XG4gICAgICAgICAgICB0aGlzLnRoaW5nLmNsZWFyKCk7XG4gICAgICAgICAgICB0aGlzLnRoaW5nLmJlZ2luRmlsbCgweDhiYzVmZiwgMC40KTtcbiAgICAgICAgICAgIHRoaXMudGhpbmcubW92ZVRvKC0xMjAgKyBNYXRoLnNpbih0aGlzLmNvdW50KSAqIDIwLCAtMTAwICsgTWF0aC5jb3ModGhpcy5jb3VudCkgKiAyMCk7XG4gICAgICAgICAgICB0aGlzLnRoaW5nLmxpbmVUbygxMjAgKyBNYXRoLmNvcyh0aGlzLmNvdW50KSAqIDIwLCAtMTAwICsgTWF0aC5zaW4odGhpcy5jb3VudCkgKiAyMCk7XG4gICAgICAgICAgICB0aGlzLnRoaW5nLmxpbmVUbygxMjAgKyBNYXRoLnNpbih0aGlzLmNvdW50KSAqIDIwLCAxMDAgKyBNYXRoLmNvcyh0aGlzLmNvdW50KSAqIDIwKTtcbiAgICAgICAgICAgIHRoaXMudGhpbmcubGluZVRvKC0xMjAgKyBNYXRoLmNvcyh0aGlzLmNvdW50KSAqIDIwLCAxMDAgKyBNYXRoLnNpbih0aGlzLmNvdW50KSAqIDIwKTtcbiAgICAgICAgICAgIHRoaXMudGhpbmcucm90YXRpb24gPSB0aGlzLmNvdW50ICogMC4xO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZVN0YWdlVGFwID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuY29udGFpbmVyLm1hc2spIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5tYXNrID0gdGhpcy50aGluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLm1hc2sgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZUxpZ2h0Um90YXRlMUxvYWRlZCA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5saWdodHJvdGF0ZTFUeHQgPSBuZXcgVGV4dHVyZV8xLlRleHR1cmUobmV3IEJhc2VUZXh0dXJlXzEuQmFzZVRleHR1cmUodGhpcy5sb2FkZXIuaW1hZ2VEYXRhKSk7XG4gICAgICAgICAgICB0aGlzLmxvYWRlciA9IG5ldyBSZXNvdXJjZUxvYWRlcl8xLlJlc291cmNlTG9hZGVyKG5ldyBVUkxSZXF1ZXN0XzEuVVJMUmVxdWVzdChcImV4YW1wbGVzL2Fzc2V0cy9saWdodF9yb3RhdGVfMS5wbmdcIikpO1xuICAgICAgICAgICAgdGhpcy5sb2FkZXIuYWRkRXZlbnRMaXN0ZW5lcihFdmVudF8xLkV2ZW50LkNPTVBMRVRFLCB0aGlzLmhhbmRsZUxpZ2h0Um90YXRlMUxvYWRlZCk7XG4gICAgICAgICAgICB0aGlzLmxvYWRlci5sb2FkKCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlUm90YXRlTG9hZGVkID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnJvdGF0ZVR4dCA9IG5ldyBUZXh0dXJlXzEuVGV4dHVyZShuZXcgQmFzZVRleHR1cmVfMS5CYXNlVGV4dHVyZSh0aGlzLmxvYWRlci5pbWFnZURhdGEpKTtcbiAgICAgICAgICAgIHRoaXMubG9hZGVyID0gbmV3IFJlc291cmNlTG9hZGVyXzEuUmVzb3VyY2VMb2FkZXIobmV3IFVSTFJlcXVlc3RfMS5VUkxSZXF1ZXN0KFwiZXhhbXBsZXMvYXNzZXRzL2JnX3NjZW5lX3JvdGF0ZS5qcGdcIikpO1xuICAgICAgICAgICAgdGhpcy5sb2FkZXIuYWRkRXZlbnRMaXN0ZW5lcihFdmVudF8xLkV2ZW50LkNPTVBMRVRFLCB0aGlzLmhhbmRsZVNjZW5lUm90YXRlTG9hZGVkKTtcbiAgICAgICAgICAgIHRoaXMubG9hZGVyLmxvYWQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVTY2VuZVJvdGF0ZUxvYWRlZCA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zY2VuZXJvdGF0ZVR4dCA9IG5ldyBUZXh0dXJlXzEuVGV4dHVyZShuZXcgQmFzZVRleHR1cmVfMS5CYXNlVGV4dHVyZSh0aGlzLmxvYWRlci5pbWFnZURhdGEpKTtcbiAgICAgICAgICAgIHRoaXMubG9hZGVyID0gbmV3IFJlc291cmNlTG9hZGVyXzEuUmVzb3VyY2VMb2FkZXIobmV3IFVSTFJlcXVlc3RfMS5VUkxSZXF1ZXN0KFwiZXhhbXBsZXMvYXNzZXRzL2xpZ2h0X3JvdGF0ZV8yLnBuZ1wiKSk7XG4gICAgICAgICAgICB0aGlzLmxvYWRlci5hZGRFdmVudExpc3RlbmVyKEV2ZW50XzEuRXZlbnQuQ09NUExFVEUsIHRoaXMuaGFuZGxlTGlnaHRSb3RhdGUyTG9hZGVkKTtcbiAgICAgICAgICAgIHRoaXMubG9hZGVyLmxvYWQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVMaWdodFJvdGF0ZTJMb2FkZWQgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIHRoaXMubGlnaHRyb3RhdGUyVHh0ID0gbmV3IFRleHR1cmVfMS5UZXh0dXJlKG5ldyBCYXNlVGV4dHVyZV8xLkJhc2VUZXh0dXJlKHRoaXMubG9hZGVyLmltYWdlRGF0YSkpO1xuICAgICAgICAgICAgdGhpcy5sb2FkZXIgPSBuZXcgUmVzb3VyY2VMb2FkZXJfMS5SZXNvdXJjZUxvYWRlcihuZXcgVVJMUmVxdWVzdF8xLlVSTFJlcXVlc3QoXCJleGFtcGxlcy9hc3NldHMvcGFuZGEucG5nXCIpKTtcbiAgICAgICAgICAgIHRoaXMubG9hZGVyLmFkZEV2ZW50TGlzdGVuZXIoRXZlbnRfMS5FdmVudC5DT01QTEVURSwgdGhpcy5oYW5kbGVQYW5kYUxvYWRlZCk7XG4gICAgICAgICAgICB0aGlzLmxvYWRlci5sb2FkKCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuYmFja0NvbG9yID0gMDtcbiAgICAgICAgdGhpcy5hY3RpdmF0ZU1hc2soKTtcbiAgICAgICAgYXBwLnN0YWdlLmludGVyYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5sb2FkZXIgPSBuZXcgUmVzb3VyY2VMb2FkZXJfMS5SZXNvdXJjZUxvYWRlcihuZXcgVVJMUmVxdWVzdF8xLlVSTFJlcXVlc3QoXCJleGFtcGxlcy9hc3NldHMvYmdfcm90YXRlLmpwZ1wiKSk7XG4gICAgICAgIHRoaXMubG9hZGVyLmFkZEV2ZW50TGlzdGVuZXIoRXZlbnRfMS5FdmVudC5DT01QTEVURSwgdGhpcy5oYW5kbGVSb3RhdGVMb2FkZWQpO1xuICAgICAgICB0aGlzLmxvYWRlci5sb2FkKCk7XG4gICAgfVxuICAgIGRlc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyLmRlc3RydWN0b3IoKTtcbiAgICAgICAgdGhpcy5hcHAudGlja2VyLnJlbW92ZSh0aGlzLnJ1bkV4YW1wbGUsIG51bGwpO1xuICAgICAgICB0aGlzLnBhbmRhLmRlc3Ryb3kobnVsbCk7XG4gICAgICAgIHRoaXMucGFuZGEgPSBudWxsO1xuICAgICAgICB0aGlzLnJvdGF0ZVR4dC5kZXN0cm95KG51bGwpO1xuICAgICAgICB0aGlzLnJvdGF0ZVR4dCA9IG51bGw7XG4gICAgICAgIHRoaXMuc2NlbmVyb3RhdGVUeHQuZGVzdHJveShudWxsKTtcbiAgICAgICAgdGhpcy5zY2VuZXJvdGF0ZVR4dCA9IG51bGw7XG4gICAgICAgIHRoaXMubGlnaHRyb3RhdGUyVHh0LmRlc3Ryb3kobnVsbCk7XG4gICAgICAgIHRoaXMubGlnaHRyb3RhdGUyVHh0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5saWdodHJvdGF0ZTFUeHQuZGVzdHJveShudWxsKTtcbiAgICAgICAgdGhpcy5saWdodHJvdGF0ZTFUeHQgPSBudWxsO1xuICAgICAgICB0aGlzLnBhbmRhVHh0LmRlc3Ryb3kobnVsbCk7XG4gICAgICAgIHRoaXMucGFuZGFUeHQgPSBudWxsO1xuICAgICAgICB0aGlzLmNvbnRhaW5lci5kZXN0cm95KG51bGwpO1xuICAgICAgICB0aGlzLmNvbnRhaW5lciA9IG51bGw7XG4gICAgICAgIHRoaXMudGhpbmcuZGVzdHJveShudWxsKTtcbiAgICAgICAgdGhpcy50aGluZyA9IG51bGw7XG4gICAgICAgIHRoaXMuYmcuZGVzdHJveShudWxsKTtcbiAgICAgICAgdGhpcy5iZyA9IG51bGw7XG4gICAgICAgIHRoaXMuYmdGcm9udC5kZXN0cm95KG51bGwpO1xuICAgICAgICB0aGlzLmJnRnJvbnQgPSBudWxsO1xuICAgICAgICB0aGlzLmxpZ2h0Mi5kZXN0cm95KG51bGwpO1xuICAgICAgICB0aGlzLmxpZ2h0MiA9IG51bGw7XG4gICAgICAgIHRoaXMubGlnaHQxLmRlc3Ryb3kobnVsbCk7XG4gICAgICAgIHRoaXMubGlnaHQxID0gbnVsbDtcbiAgICB9XG59XG5leHBvcnRzLk1hc2tHcmFwaGljcyA9IE1hc2tHcmFwaGljcztcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgQmFzZUV4YW1wbGVfMSA9IHJlcXVpcmUoXCIuL0Jhc2VFeGFtcGxlXCIpO1xuY29uc3QgUmVzb3VyY2VMb2FkZXJfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9SZXNvdXJjZUxvYWRlclwiKTtcbmNvbnN0IFVSTFJlcXVlc3RfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9VUkxSZXF1ZXN0XCIpO1xuY29uc3QgRXZlbnRfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9FdmVudFwiKTtcbmNvbnN0IFRleHR1cmVfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9UZXh0dXJlXCIpO1xuY29uc3QgQmFzZVRleHR1cmVfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9CYXNlVGV4dHVyZVwiKTtcbmNvbnN0IFNwcml0ZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1Nwcml0ZVwiKTtcbmNvbnN0IFBvaW50XzEgPSByZXF1aXJlKFwiLi4vZmxhc2gvZ2VvbS9Qb2ludFwiKTtcbmNsYXNzIE1hc2tTcHJpdGUgZXh0ZW5kcyBCYXNlRXhhbXBsZV8xLkJhc2VFeGFtcGxlIHtcbiAgICBjb25zdHJ1Y3RvcihhcHAsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgc3VwZXIoYXBwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgdGhpcy5oYW5kbGVGbG93ZXJMb2FkZWQgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZmxvd2VyVHh0ID0gbmV3IFRleHR1cmVfMS5UZXh0dXJlKG5ldyBCYXNlVGV4dHVyZV8xLkJhc2VUZXh0dXJlKHRoaXMubG9hZGVyLmltYWdlRGF0YSkpO1xuICAgICAgICAgICAgdGhpcy5hcHAuc3RhZ2UuaW50ZXJhY3RpdmUgPSB0cnVlO1xuICAgICAgICAgICAgY29uc3QgYmcgPSBuZXcgU3ByaXRlXzEuU3ByaXRlKHRoaXMucGxhbmVUeHQpO1xuICAgICAgICAgICAgYmcud2lkdGggPSB0aGlzLnNpemV3O1xuICAgICAgICAgICAgYmcuaGVpZ2h0ID0gdGhpcy5zaXplaDtcbiAgICAgICAgICAgIHRoaXMuc3RhZ2UuYWRkQ2hpbGQoYmcpO1xuICAgICAgICAgICAgY29uc3QgY2VsbHMgPSBuZXcgU3ByaXRlXzEuU3ByaXRlKHRoaXMuY2VsbFR4dCk7XG4gICAgICAgICAgICBjZWxscy5zY2FsZS5zZXQoMS41KTtcbiAgICAgICAgICAgIHRoaXMubWFzayA9IG5ldyBTcHJpdGVfMS5TcHJpdGUodGhpcy5mbG93ZXJUeHQpO1xuICAgICAgICAgICAgdGhpcy5tYXNrLmFuY2hvci5zZXQoMC41KTtcbiAgICAgICAgICAgIHRoaXMubWFzay54ID0gMzEwO1xuICAgICAgICAgICAgdGhpcy5tYXNrLnkgPSAxOTA7XG4gICAgICAgICAgICBjZWxscy5tYXNrID0gdGhpcy5tYXNrO1xuICAgICAgICAgICAgdGhpcy5zdGFnZS5hZGRDaGlsZCh0aGlzLm1hc2spO1xuICAgICAgICAgICAgdGhpcy5zdGFnZS5hZGRDaGlsZChjZWxscyk7XG4gICAgICAgICAgICB0aGlzLnRhcmdldCA9IFBvaW50XzEuUG9pbnQuZ2V0UG9pbnQoKTtcbiAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgICAgIHRoaXMuYXBwLnRpY2tlci5hZGQodGhpcy5ydW5FeGFtcGxlKTtcbiAgICAgICAgICAgIHRoaXMuZXhhbXBsZVJlYWR5KCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucnVuRXhhbXBsZSA9IChkZWx0YSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5tYXNrLnggKz0gKHRoaXMudGFyZ2V0LnggLSB0aGlzLm1hc2sueCkgKiAwLjE7XG4gICAgICAgICAgICB0aGlzLm1hc2sueSArPSAodGhpcy50YXJnZXQueSAtIHRoaXMubWFzay55KSAqIDAuMTtcbiAgICAgICAgICAgIGlmIChNYXRoLmFicyh0aGlzLm1hc2sueCAtIHRoaXMudGFyZ2V0LngpIDwgMSkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVDZWxsTG9hZGVkID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNlbGxUeHQgPSBuZXcgVGV4dHVyZV8xLlRleHR1cmUobmV3IEJhc2VUZXh0dXJlXzEuQmFzZVRleHR1cmUodGhpcy5sb2FkZXIuaW1hZ2VEYXRhKSk7XG4gICAgICAgICAgICB0aGlzLmxvYWRlciA9IG5ldyBSZXNvdXJjZUxvYWRlcl8xLlJlc291cmNlTG9hZGVyKG5ldyBVUkxSZXF1ZXN0XzEuVVJMUmVxdWVzdChcImV4YW1wbGVzL2Fzc2V0cy9mbG93ZXJUb3AucG5nXCIpKTtcbiAgICAgICAgICAgIHRoaXMubG9hZGVyLmFkZEV2ZW50TGlzdGVuZXIoRXZlbnRfMS5FdmVudC5DT01QTEVURSwgdGhpcy5oYW5kbGVGbG93ZXJMb2FkZWQpO1xuICAgICAgICAgICAgdGhpcy5sb2FkZXIubG9hZCgpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZVBsYW5lTG9hZGVkID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnBsYW5lVHh0ID0gbmV3IFRleHR1cmVfMS5UZXh0dXJlKG5ldyBCYXNlVGV4dHVyZV8xLkJhc2VUZXh0dXJlKHRoaXMubG9hZGVyLmltYWdlRGF0YSkpO1xuICAgICAgICAgICAgdGhpcy5sb2FkZXIgPSBuZXcgUmVzb3VyY2VMb2FkZXJfMS5SZXNvdXJjZUxvYWRlcihuZXcgVVJMUmVxdWVzdF8xLlVSTFJlcXVlc3QoXCJleGFtcGxlcy9hc3NldHMvY2VsbHMucG5nXCIpKTtcbiAgICAgICAgICAgIHRoaXMubG9hZGVyLmFkZEV2ZW50TGlzdGVuZXIoRXZlbnRfMS5FdmVudC5DT01QTEVURSwgdGhpcy5oYW5kbGVDZWxsTG9hZGVkKTtcbiAgICAgICAgICAgIHRoaXMubG9hZGVyLmxvYWQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5hY3RpdmF0ZU1hc2soKTtcbiAgICAgICAgdGhpcy5sb2FkZXIgPSBuZXcgUmVzb3VyY2VMb2FkZXJfMS5SZXNvdXJjZUxvYWRlcihuZXcgVVJMUmVxdWVzdF8xLlVSTFJlcXVlc3QoXCJleGFtcGxlcy9hc3NldHMvYmdfcGxhbmUuanBnXCIpKTtcbiAgICAgICAgdGhpcy5sb2FkZXIuYWRkRXZlbnRMaXN0ZW5lcihFdmVudF8xLkV2ZW50LkNPTVBMRVRFLCB0aGlzLmhhbmRsZVBsYW5lTG9hZGVkKTtcbiAgICAgICAgdGhpcy5sb2FkZXIubG9hZCgpO1xuICAgIH1cbiAgICByZXNldCgpIHtcbiAgICAgICAgdGhpcy50YXJnZXQueCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDU1MCk7XG4gICAgICAgIHRoaXMudGFyZ2V0LnkgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAzMDApO1xuICAgIH1cbiAgICBkZXN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlci5kZXN0cnVjdG9yKCk7XG4gICAgICAgIHRoaXMuYXBwLnRpY2tlci5yZW1vdmUodGhpcy5ydW5FeGFtcGxlLCBudWxsKTtcbiAgICAgICAgdGhpcy5tYXNrLmRlc3Ryb3kobnVsbCk7XG4gICAgICAgIHRoaXMubWFzayA9IG51bGw7XG4gICAgICAgIHRoaXMucGxhbmVUeHQuZGVzdHJveShudWxsKTtcbiAgICAgICAgdGhpcy5wbGFuZVR4dCA9IG51bGw7XG4gICAgICAgIHRoaXMuY2VsbFR4dC5kZXN0cm95KG51bGwpO1xuICAgICAgICB0aGlzLmNlbGxUeHQgPSBudWxsO1xuICAgICAgICB0aGlzLmZsb3dlclR4dC5kZXN0cm95KG51bGwpO1xuICAgICAgICB0aGlzLmZsb3dlclR4dCA9IG51bGw7XG4gICAgICAgIGlmICh0aGlzLnRhcmdldCkge1xuICAgICAgICAgICAgdGhpcy50YXJnZXQucmVjeWNsZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudGFyZ2V0ID0gbnVsbDtcbiAgICB9XG59XG5leHBvcnRzLk1hc2tTcHJpdGUgPSBNYXNrU3ByaXRlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBCYXNlRXhhbXBsZV8xID0gcmVxdWlyZShcIi4vQmFzZUV4YW1wbGVcIik7XG5jb25zdCBUZXh0dXJlXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvVGV4dHVyZVwiKTtcbmNvbnN0IEJhc2VUZXh0dXJlXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvQmFzZVRleHR1cmVcIik7XG5jb25zdCBFdmVudF8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0V2ZW50XCIpO1xuY29uc3QgUmVzb3VyY2VMb2FkZXJfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9SZXNvdXJjZUxvYWRlclwiKTtcbmNvbnN0IFVSTFJlcXVlc3RfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9VUkxSZXF1ZXN0XCIpO1xuY29uc3QgUG9pbnRfMSA9IHJlcXVpcmUoXCIuLi9mbGFzaC9nZW9tL1BvaW50XCIpO1xuY29uc3QgU2ltcGxlUm9wZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1NpbXBsZVJvcGVcIik7XG5jb25zdCBHcmFwaGljc18xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0dyYXBoaWNzXCIpO1xuY2xhc3MgTWVzaEFkdmFuY2VkIGV4dGVuZHMgQmFzZUV4YW1wbGVfMS5CYXNlRXhhbXBsZSB7XG4gICAgY29uc3RydWN0b3IoYXBwLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHN1cGVyKGFwcCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIHRoaXMucnVuRXhhbXBsZSA9IChkZWx0YSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5jb3VudCArPSAwLjE7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wb2ludHNbaV0ueSA9IE1hdGguc2luKChpICogMC41KSArIHRoaXMuY291bnQpICogMzA7XG4gICAgICAgICAgICAgICAgdGhpcy5wb2ludHNbaV0ueCA9IGkgKiB0aGlzLnJvcGVMZW5ndGggKyBNYXRoLmNvcygoaSAqIDAuMykgKyB0aGlzLmNvdW50KSAqIDIwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5yZW5kZXJQb2ludHMoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVQbGFuZUxvYWRlZCA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5wbGFuZVR4dCA9IG5ldyBUZXh0dXJlXzEuVGV4dHVyZShuZXcgQmFzZVRleHR1cmVfMS5CYXNlVGV4dHVyZSh0aGlzLmxvYWRlci5pbWFnZURhdGEpKTtcbiAgICAgICAgICAgIHRoaXMuY291bnQgPSAwO1xuICAgICAgICAgICAgdGhpcy5yb3BlTGVuZ3RoID0gMzA7XG4gICAgICAgICAgICB0aGlzLnBvaW50cyA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAyNTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wb2ludHMucHVzaChQb2ludF8xLlBvaW50LmdldFBvaW50KGkgKiB0aGlzLnJvcGVMZW5ndGgsIDApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHN0cmlwID0gbmV3IFNpbXBsZVJvcGVfMS5TaW1wbGVSb3BlKHRoaXMucGxhbmVUeHQsIHRoaXMucG9pbnRzKTtcbiAgICAgICAgICAgIHN0cmlwLnggPSAyMDtcbiAgICAgICAgICAgIHN0cmlwLnkgPSAzMDA7XG4gICAgICAgICAgICB0aGlzLnN0YWdlLmFkZENoaWxkKHN0cmlwKTtcbiAgICAgICAgICAgIHRoaXMuZyA9IG5ldyBHcmFwaGljc18xLkdyYXBoaWNzKCk7XG4gICAgICAgICAgICB0aGlzLmcueCA9IHN0cmlwLng7XG4gICAgICAgICAgICB0aGlzLmcueSA9IHN0cmlwLnk7XG4gICAgICAgICAgICB0aGlzLnN0YWdlLmFkZENoaWxkKHRoaXMuZyk7XG4gICAgICAgICAgICB0aGlzLmFwcC50aWNrZXIuYWRkKHRoaXMucnVuRXhhbXBsZSk7XG4gICAgICAgICAgICB0aGlzLmV4YW1wbGVSZWFkeSgpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmxvYWRlciA9IG5ldyBSZXNvdXJjZUxvYWRlcl8xLlJlc291cmNlTG9hZGVyKG5ldyBVUkxSZXF1ZXN0XzEuVVJMUmVxdWVzdChcImV4YW1wbGVzL2Fzc2V0cy9zbmFrZS5wbmdcIikpO1xuICAgICAgICB0aGlzLmxvYWRlci5hZGRFdmVudExpc3RlbmVyKEV2ZW50XzEuRXZlbnQuQ09NUExFVEUsIHRoaXMuaGFuZGxlUGxhbmVMb2FkZWQpO1xuICAgICAgICB0aGlzLmxvYWRlci5sb2FkKCk7XG4gICAgfVxuICAgIHJlbmRlclBvaW50cygpIHtcbiAgICAgICAgdGhpcy5nLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuZy5saW5lU3R5bGUoMiwgMHhmZmMyYzIpO1xuICAgICAgICB0aGlzLmcubW92ZVRvKHRoaXMucG9pbnRzWzBdLngsIHRoaXMucG9pbnRzWzBdLnkpO1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHRoaXMucG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLmcubGluZVRvKHRoaXMucG9pbnRzW2ldLngsIHRoaXMucG9pbnRzW2ldLnkpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgdGhpcy5wb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuZy5iZWdpbkZpbGwoMHhmZjAwMjIpO1xuICAgICAgICAgICAgdGhpcy5nLmRyYXdDaXJjbGUodGhpcy5wb2ludHNbaV0ueCwgdGhpcy5wb2ludHNbaV0ueSwgMTApO1xuICAgICAgICAgICAgdGhpcy5nLmVuZEZpbGwoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkZXN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlci5kZXN0cnVjdG9yKCk7XG4gICAgICAgIHRoaXMuYXBwLnRpY2tlci5yZW1vdmUodGhpcy5ydW5FeGFtcGxlLCBudWxsKTtcbiAgICAgICAgdGhpcy5wbGFuZVR4dC5kZXN0cm95KG51bGwpO1xuICAgICAgICB0aGlzLnBsYW5lVHh0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5nLmRlc3Ryb3kobnVsbCk7XG4gICAgICAgIHRoaXMuZyA9IG51bGw7XG4gICAgICAgIGlmICh0aGlzLnBvaW50cyAmJiB0aGlzLnBvaW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHdoaWxlICh0aGlzLnBvaW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBsZXQgcG9pbnQgPSB0aGlzLnBvaW50cy5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIHBvaW50LnJlY3ljbGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBvaW50cyA9IG51bGw7XG4gICAgfVxufVxuZXhwb3J0cy5NZXNoQWR2YW5jZWQgPSBNZXNoQWR2YW5jZWQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IEJhc2VFeGFtcGxlXzEgPSByZXF1aXJlKFwiLi9CYXNlRXhhbXBsZVwiKTtcbmNvbnN0IFJlc291cmNlTG9hZGVyXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvUmVzb3VyY2VMb2FkZXJcIik7XG5jb25zdCBUZXh0dXJlXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvVGV4dHVyZVwiKTtcbmNvbnN0IFVSTFJlcXVlc3RfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9VUkxSZXF1ZXN0XCIpO1xuY29uc3QgRXZlbnRfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9FdmVudFwiKTtcbmNvbnN0IEJhc2VUZXh0dXJlXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvQmFzZVRleHR1cmVcIik7XG5jb25zdCBQb2ludF8xID0gcmVxdWlyZShcIi4uL2ZsYXNoL2dlb20vUG9pbnRcIik7XG5jb25zdCBTaW1wbGVSb3BlXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvU2ltcGxlUm9wZVwiKTtcbmNvbnN0IENvbnRhaW5lcl8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0NvbnRhaW5lclwiKTtcbmNsYXNzIE1lc2hCYXNpYyBleHRlbmRzIEJhc2VFeGFtcGxlXzEuQmFzZUV4YW1wbGUge1xuICAgIGNvbnN0cnVjdG9yKGFwcCwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICBzdXBlcihhcHAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICB0aGlzLnJ1bkV4YW1wbGUgPSAoZGVsdGEpID0+IHtcbiAgICAgICAgICAgIHRoaXMuY291bnQgKz0gMC4xO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMucG9pbnRzW2ldLnkgPSBNYXRoLnNpbigoaSAqIDAuNSkgKyB0aGlzLmNvdW50KSAqIDMwO1xuICAgICAgICAgICAgICAgIHRoaXMucG9pbnRzW2ldLnggPSBpICogdGhpcy5yb3BlTGVuZ3RoICsgTWF0aC5jb3MoKGkgKiAwLjMpICsgdGhpcy5jb3VudCkgKiAyMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVQbGFuZUxvYWRlZCA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5wbGFuZVR4dCA9IG5ldyBUZXh0dXJlXzEuVGV4dHVyZShuZXcgQmFzZVRleHR1cmVfMS5CYXNlVGV4dHVyZSh0aGlzLmxvYWRlci5pbWFnZURhdGEpKTtcbiAgICAgICAgICAgIHRoaXMuY291bnQgPSAwO1xuICAgICAgICAgICAgdGhpcy5yb3BlTGVuZ3RoID0gOTE4IC8gMjA7XG4gICAgICAgICAgICB0aGlzLnBvaW50cyA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAyMDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wb2ludHMucHVzaChQb2ludF8xLlBvaW50LmdldFBvaW50KGkgKiB0aGlzLnJvcGVMZW5ndGgsIDApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHN0cmlwID0gbmV3IFNpbXBsZVJvcGVfMS5TaW1wbGVSb3BlKHRoaXMucGxhbmVUeHQsIHRoaXMucG9pbnRzKTtcbiAgICAgICAgICAgIHN0cmlwLnggPSAtNDU5O1xuICAgICAgICAgICAgY29uc3Qgc25ha2VDb250YWluZXIgPSBuZXcgQ29udGFpbmVyXzEuQ29udGFpbmVyKCk7XG4gICAgICAgICAgICBzbmFrZUNvbnRhaW5lci54ID0gNDAwO1xuICAgICAgICAgICAgc25ha2VDb250YWluZXIueSA9IDMwMDtcbiAgICAgICAgICAgIHNuYWtlQ29udGFpbmVyLnNjYWxlLnNldCg4MDAgLyAxMTAwKTtcbiAgICAgICAgICAgIHRoaXMuc3RhZ2UuYWRkQ2hpbGQoc25ha2VDb250YWluZXIpO1xuICAgICAgICAgICAgc25ha2VDb250YWluZXIuYWRkQ2hpbGQoc3RyaXApO1xuICAgICAgICAgICAgdGhpcy5hcHAudGlja2VyLmFkZCh0aGlzLnJ1bkV4YW1wbGUpO1xuICAgICAgICAgICAgdGhpcy5leGFtcGxlUmVhZHkoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5sb2FkZXIgPSBuZXcgUmVzb3VyY2VMb2FkZXJfMS5SZXNvdXJjZUxvYWRlcihuZXcgVVJMUmVxdWVzdF8xLlVSTFJlcXVlc3QoXCJleGFtcGxlcy9hc3NldHMvc25ha2UucG5nXCIpKTtcbiAgICAgICAgdGhpcy5sb2FkZXIuYWRkRXZlbnRMaXN0ZW5lcihFdmVudF8xLkV2ZW50LkNPTVBMRVRFLCB0aGlzLmhhbmRsZVBsYW5lTG9hZGVkKTtcbiAgICAgICAgdGhpcy5sb2FkZXIubG9hZCgpO1xuICAgIH1cbiAgICBkZXN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlci5kZXN0cnVjdG9yKCk7XG4gICAgICAgIHRoaXMuYXBwLnRpY2tlci5yZW1vdmUodGhpcy5ydW5FeGFtcGxlLCBudWxsKTtcbiAgICAgICAgdGhpcy5wbGFuZVR4dC5kZXN0cm95KG51bGwpO1xuICAgICAgICB0aGlzLnBsYW5lVHh0ID0gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMucG9pbnRzICYmIHRoaXMucG9pbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgd2hpbGUgKHRoaXMucG9pbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGxldCBwb2ludCA9IHRoaXMucG9pbnRzLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgcG9pbnQucmVjeWNsZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMucG9pbnRzID0gbnVsbDtcbiAgICB9XG59XG5leHBvcnRzLk1lc2hCYXNpYyA9IE1lc2hCYXNpYztcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgQmFzZUV4YW1wbGVfMSA9IHJlcXVpcmUoXCIuL0Jhc2VFeGFtcGxlXCIpO1xuY29uc3QgR2VvbWV0cnlfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9HZW9tZXRyeVwiKTtcbmNvbnN0IFByb2dyYW1fMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9Qcm9ncmFtXCIpO1xuY29uc3QgU2hhZGVyXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvU2hhZGVyXCIpO1xuY29uc3QgTWVzaF8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL01lc2hcIik7XG5jbGFzcyBNZXNoQ29sb3JlZFRyaWFuZ2xlIGV4dGVuZHMgQmFzZUV4YW1wbGVfMS5CYXNlRXhhbXBsZSB7XG4gICAgY29uc3RydWN0b3IoYXBwLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHN1cGVyKGFwcCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIHRoaXMucnVuRXhhbXBsZSA9IChkZWx0YSkgPT4ge1xuICAgICAgICAgICAgdGhpcy50cmlhbmdsZS5yb3RhdGlvbiArPSAwLjAxO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBnZW9tZXRyeSA9IG5ldyBHZW9tZXRyeV8xLkdlb21ldHJ5KCk7XG4gICAgICAgIGdlb21ldHJ5LmFkZEF0dHJpYnV0ZSgnYVZlcnRleFBvc2l0aW9uJywgLy8gdGhlIGF0dHJpYnV0ZSBuYW1lXG4gICAgICAgIFstMTAwLCAtNTAsXG4gICAgICAgICAgICAxMDAsIC01MCxcbiAgICAgICAgICAgIDAuMCwgMTAwLjBdLCAvLyB4LCB5XG4gICAgICAgIDIpOyAvLyB0aGUgc2l6ZSBvZiB0aGUgYXR0cmlidXRlXG4gICAgICAgIGdlb21ldHJ5LmFkZEF0dHJpYnV0ZSgnYUNvbG9yJywgLy8gdGhlIGF0dHJpYnV0ZSBuYW1lXG4gICAgICAgIFsxLCAwLCAwLFxuICAgICAgICAgICAgMCwgMSwgMCxcbiAgICAgICAgICAgIDAsIDAsIDFdLCAvLyByLCBnLCBiXG4gICAgICAgIDMpOyAvLyB0aGUgc2l6ZSBvZiB0aGUgYXR0cmlidXRlXG4gICAgICAgIGxldCB2eCA9IGBcbiAgICAgICAgICAgIHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xuICAgICAgICAgICAgYXR0cmlidXRlIHZlYzIgYVZlcnRleFBvc2l0aW9uO1xuICAgICAgICAgICAgYXR0cmlidXRlIHZlYzMgYUNvbG9yOyAgICBcbiAgICAgICAgICAgIHVuaWZvcm0gbWF0MyB0cmFuc2xhdGlvbk1hdHJpeDtcbiAgICAgICAgICAgIHVuaWZvcm0gbWF0MyBwcm9qZWN0aW9uTWF0cml4OyAgICBcbiAgICAgICAgICAgIHZhcnlpbmcgdmVjMyB2Q29sb3I7ICAgIFxuICAgICAgICAgICAgdm9pZCBtYWluKCkgeyAgICBcbiAgICAgICAgICAgICAgICB2Q29sb3IgPSBhQ29sb3I7XG4gICAgICAgICAgICAgICAgZ2xfUG9zaXRpb24gPSB2ZWM0KChwcm9qZWN0aW9uTWF0cml4ICogdHJhbnNsYXRpb25NYXRyaXggKiB2ZWMzKGFWZXJ0ZXhQb3NpdGlvbiwgMS4wKSkueHksIDAuMCwgMS4wKTsgICAgXG4gICAgICAgICAgICB9YDtcbiAgICAgICAgbGV0IGZ4ID0gYHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xuICAgICAgICAgICAgdmFyeWluZyB2ZWMzIHZDb2xvcjsgICAgXG4gICAgICAgICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgICAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCh2Q29sb3IsIDEuMCk7XG4gICAgICAgICAgICB9ICAgIFxuICAgICAgICAgICAgYDtcbiAgICAgICAgbGV0IHByb2dyYW0gPSBuZXcgUHJvZ3JhbV8xLlByb2dyYW0odngsIGZ4KTtcbiAgICAgICAgY29uc3Qgc2hhZGVyID0gbmV3IFNoYWRlcl8xLlNoYWRlcihwcm9ncmFtLCBudWxsKTtcbiAgICAgICAgdGhpcy50cmlhbmdsZSA9IG5ldyBNZXNoXzEuTWVzaChnZW9tZXRyeSwgc2hhZGVyKTtcbiAgICAgICAgdGhpcy50cmlhbmdsZS5wb3NpdGlvbi5zZXQoNDAwLCAzMDApO1xuICAgICAgICB0aGlzLnRyaWFuZ2xlLnNjYWxlLnNldCgyKTtcbiAgICAgICAgdGhpcy5zdGFnZS5hZGRDaGlsZCh0aGlzLnRyaWFuZ2xlKTtcbiAgICAgICAgdGhpcy5hcHAudGlja2VyLmFkZCh0aGlzLnJ1bkV4YW1wbGUpO1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZXhhbXBsZVJlYWR5KCk7XG4gICAgICAgIH0sIDEwMDApO1xuICAgIH1cbiAgICBkZXN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlci5kZXN0cnVjdG9yKCk7XG4gICAgICAgIHRoaXMuYXBwLnRpY2tlci5yZW1vdmUodGhpcy5ydW5FeGFtcGxlLCBudWxsKTtcbiAgICAgICAgdGhpcy50cmlhbmdsZS5kZXN0cm95KG51bGwpO1xuICAgICAgICB0aGlzLnRyaWFuZ2xlID0gbnVsbDtcbiAgICB9XG59XG5leHBvcnRzLk1lc2hDb2xvcmVkVHJpYW5nbGUgPSBNZXNoQ29sb3JlZFRyaWFuZ2xlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBCYXNlRXhhbXBsZV8xID0gcmVxdWlyZShcIi4vQmFzZUV4YW1wbGVcIik7XG5jb25zdCBSZXNvdXJjZUxvYWRlcl8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1Jlc291cmNlTG9hZGVyXCIpO1xuY29uc3QgVGV4dHVyZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1RleHR1cmVcIik7XG5jb25zdCBVUkxSZXF1ZXN0XzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvVVJMUmVxdWVzdFwiKTtcbmNvbnN0IEV2ZW50XzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvRXZlbnRcIik7XG5jb25zdCBCYXNlVGV4dHVyZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0Jhc2VUZXh0dXJlXCIpO1xuY29uc3QgR2VvbWV0cnlfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9HZW9tZXRyeVwiKTtcbmNvbnN0IFByb2dyYW1fMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9Qcm9ncmFtXCIpO1xuY29uc3QgTWVzaF8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL01lc2hcIik7XG5jb25zdCBTaGFkZXJfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9TaGFkZXJcIik7XG5jbGFzcyBNZXNoR2VvbWV0cnkgZXh0ZW5kcyBCYXNlRXhhbXBsZV8xLkJhc2VFeGFtcGxlIHtcbiAgICBjb25zdHJ1Y3RvcihhcHAsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgc3VwZXIoYXBwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgdGhpcy5oYW5kbGVUeHQzTG9hZGVkID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnR4dDMgPSBuZXcgVGV4dHVyZV8xLlRleHR1cmUobmV3IEJhc2VUZXh0dXJlXzEuQmFzZVRleHR1cmUodGhpcy5sb2FkZXIuaW1hZ2VEYXRhKSk7XG4gICAgICAgICAgICBjb25zdCBnZW9tZXRyeSA9IG5ldyBHZW9tZXRyeV8xLkdlb21ldHJ5KCk7XG4gICAgICAgICAgICBnZW9tZXRyeS5hZGRBdHRyaWJ1dGUoJ2FWZXJ0ZXhQb3NpdGlvbicsIC8vIHRoZSBhdHRyaWJ1dGUgbmFtZVxuICAgICAgICAgICAgWy0xMDAsIC0xMDAsXG4gICAgICAgICAgICAgICAgMTAwLCAtMTAwLFxuICAgICAgICAgICAgICAgIDEwMCwgMTAwXSwgLy8geCwgeVxuICAgICAgICAgICAgMik7IC8vIHRoZSBzaXplIG9mIHRoZSBhdHRyaWJ1dGUgICAgXG4gICAgICAgICAgICBnZW9tZXRyeS5hZGRBdHRyaWJ1dGUoJ2FVdnMnLCAvLyB0aGUgYXR0cmlidXRlIG5hbWVcbiAgICAgICAgICAgIFswLCAwLFxuICAgICAgICAgICAgICAgIDEsIDAsXG4gICAgICAgICAgICAgICAgMSwgMV0sIC8vIHUsIHZcbiAgICAgICAgICAgIDIpOyAvLyB0aGUgc2l6ZSBvZiB0aGUgYXR0cmlidXRlICAgIFxuICAgICAgICAgICAgY29uc3QgcHJvZ3JhbSA9IFByb2dyYW1fMS5Qcm9ncmFtLmZyb20oYCAgICBcbiAgICAgICAgICAgIHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0OyAgICBcbiAgICAgICAgICAgIGF0dHJpYnV0ZSB2ZWMyIGFWZXJ0ZXhQb3NpdGlvbjtcbiAgICAgICAgICAgIGF0dHJpYnV0ZSB2ZWMyIGFVdnM7ICAgIFxuICAgICAgICAgICAgdW5pZm9ybSBtYXQzIHRyYW5zbGF0aW9uTWF0cml4O1xuICAgICAgICAgICAgdW5pZm9ybSBtYXQzIHByb2plY3Rpb25NYXRyaXg7ICAgIFxuICAgICAgICAgICAgdmFyeWluZyB2ZWMyIHZVdnM7ICAgIFxuICAgICAgICAgICAgdm9pZCBtYWluKCkgeyAgICBcbiAgICAgICAgICAgICAgICB2VXZzID0gYVV2cztcbiAgICAgICAgICAgICAgICBnbF9Qb3NpdGlvbiA9IHZlYzQoKHByb2plY3Rpb25NYXRyaXggKiB0cmFuc2xhdGlvbk1hdHJpeCAqIHZlYzMoYVZlcnRleFBvc2l0aW9uLCAxLjApKS54eSwgMC4wLCAxLjApOyAgICBcbiAgICAgICAgICAgIH1gLCBgcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7ICAgIFxuICAgICAgICAgICAgdmFyeWluZyB2ZWMyIHZVdnM7ICAgIFxuICAgICAgICAgICAgdW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXJUZXh0dXJlOyAgICBcbiAgICAgICAgICAgIHZvaWQgbWFpbigpIHsgICAgXG4gICAgICAgICAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKHVTYW1wbGVyVGV4dHVyZSwgdlV2cyk7XG4gICAgICAgICAgICB9ICAgIFxuICAgICAgICBgKTtcbiAgICAgICAgICAgIHRoaXMudHJpYW5nbGUgPSBuZXcgTWVzaF8xLk1lc2goZ2VvbWV0cnksIG5ldyBTaGFkZXJfMS5TaGFkZXIocHJvZ3JhbSwge1xuICAgICAgICAgICAgICAgIHVTYW1wbGVyVGV4dHVyZTogdGhpcy50eHQxLFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgdGhpcy50cmlhbmdsZTIgPSBuZXcgTWVzaF8xLk1lc2goZ2VvbWV0cnksIG5ldyBTaGFkZXJfMS5TaGFkZXIocHJvZ3JhbSwge1xuICAgICAgICAgICAgICAgIHVTYW1wbGVyVGV4dHVyZTogdGhpcy50eHQyLFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgdGhpcy50cmlhbmdsZTMgPSBuZXcgTWVzaF8xLk1lc2goZ2VvbWV0cnksIG5ldyBTaGFkZXJfMS5TaGFkZXIocHJvZ3JhbSwge1xuICAgICAgICAgICAgICAgIHVTYW1wbGVyVGV4dHVyZTogdGhpcy50eHQzLFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgdGhpcy50cmlhbmdsZS5wb3NpdGlvbi5zZXQoNDAwLCAzMDApO1xuICAgICAgICAgICAgdGhpcy50cmlhbmdsZS5zY2FsZS5zZXQoMik7XG4gICAgICAgICAgICB0aGlzLnRyaWFuZ2xlMi5wb3NpdGlvbi5zZXQoMjAwLCAxMDApO1xuICAgICAgICAgICAgdGhpcy50cmlhbmdsZTMucG9zaXRpb24uc2V0KDUwMCwgNDAwKTtcbiAgICAgICAgICAgIHRoaXMudHJpYW5nbGUzLnNjYWxlLnNldCgzKTtcbiAgICAgICAgICAgIHRoaXMuc3RhZ2UuYWRkQ2hpbGQodGhpcy50cmlhbmdsZTMpO1xuICAgICAgICAgICAgdGhpcy5zdGFnZS5hZGRDaGlsZCh0aGlzLnRyaWFuZ2xlMik7XG4gICAgICAgICAgICB0aGlzLnN0YWdlLmFkZENoaWxkKHRoaXMudHJpYW5nbGUpO1xuICAgICAgICAgICAgdGhpcy5hcHAudGlja2VyLmFkZCh0aGlzLnJ1bkV4YW1wbGUpO1xuICAgICAgICAgICAgdGhpcy5leGFtcGxlUmVhZHkoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5ydW5FeGFtcGxlID0gKGRlbHRhKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnRyaWFuZ2xlLnJvdGF0aW9uICs9IDAuMDE7XG4gICAgICAgICAgICB0aGlzLnRyaWFuZ2xlMi5yb3RhdGlvbiAtPSAwLjAxO1xuICAgICAgICAgICAgdGhpcy50cmlhbmdsZTMucm90YXRpb24gLT0gMC4wMDU7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlVHh0MkxvYWRlZCA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgdGhpcy50eHQyID0gbmV3IFRleHR1cmVfMS5UZXh0dXJlKG5ldyBCYXNlVGV4dHVyZV8xLkJhc2VUZXh0dXJlKHRoaXMubG9hZGVyLmltYWdlRGF0YSkpO1xuICAgICAgICAgICAgdGhpcy5sb2FkZXIgPSBuZXcgUmVzb3VyY2VMb2FkZXJfMS5SZXNvdXJjZUxvYWRlcihuZXcgVVJMUmVxdWVzdF8xLlVSTFJlcXVlc3QoXCJleGFtcGxlcy9hc3NldHMvYmdfZGlzcGxhY2VtZW50LmpwZ1wiKSk7XG4gICAgICAgICAgICB0aGlzLmxvYWRlci5hZGRFdmVudExpc3RlbmVyKEV2ZW50XzEuRXZlbnQuQ09NUExFVEUsIHRoaXMuaGFuZGxlVHh0M0xvYWRlZCk7XG4gICAgICAgICAgICB0aGlzLmxvYWRlci5sb2FkKCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlVHh0MUxvYWRlZCA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgdGhpcy50eHQxID0gbmV3IFRleHR1cmVfMS5UZXh0dXJlKG5ldyBCYXNlVGV4dHVyZV8xLkJhc2VUZXh0dXJlKHRoaXMubG9hZGVyLmltYWdlRGF0YSkpO1xuICAgICAgICAgICAgdGhpcy5sb2FkZXIgPSBuZXcgUmVzb3VyY2VMb2FkZXJfMS5SZXNvdXJjZUxvYWRlcihuZXcgVVJMUmVxdWVzdF8xLlVSTFJlcXVlc3QoXCJleGFtcGxlcy9hc3NldHMvYmdfcm90YXRlLmpwZ1wiKSk7XG4gICAgICAgICAgICB0aGlzLmxvYWRlci5hZGRFdmVudExpc3RlbmVyKEV2ZW50XzEuRXZlbnQuQ09NUExFVEUsIHRoaXMuaGFuZGxlVHh0MkxvYWRlZCk7XG4gICAgICAgICAgICB0aGlzLmxvYWRlci5sb2FkKCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuYWN0aXZhdGVNYXNrKCk7XG4gICAgICAgIHRoaXMubG9hZGVyID0gbmV3IFJlc291cmNlTG9hZGVyXzEuUmVzb3VyY2VMb2FkZXIobmV3IFVSTFJlcXVlc3RfMS5VUkxSZXF1ZXN0KFwiZXhhbXBsZXMvYXNzZXRzL2JnX3NjZW5lX3JvdGF0ZS5qcGdcIikpO1xuICAgICAgICB0aGlzLmxvYWRlci5hZGRFdmVudExpc3RlbmVyKEV2ZW50XzEuRXZlbnQuQ09NUExFVEUsIHRoaXMuaGFuZGxlVHh0MUxvYWRlZCk7XG4gICAgICAgIHRoaXMubG9hZGVyLmxvYWQoKTtcbiAgICB9XG4gICAgZGVzdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIuZGVzdHJ1Y3RvcigpO1xuICAgICAgICB0aGlzLmFwcC50aWNrZXIucmVtb3ZlKHRoaXMucnVuRXhhbXBsZSwgbnVsbCk7XG4gICAgICAgIHRoaXMudHh0MS5kZXN0cm95KG51bGwpO1xuICAgICAgICB0aGlzLnR4dDEgPSBudWxsO1xuICAgICAgICB0aGlzLnRyaWFuZ2xlMy5kZXN0cm95KG51bGwpO1xuICAgICAgICB0aGlzLnRyaWFuZ2xlMyA9IG51bGw7XG4gICAgICAgIHRoaXMudHJpYW5nbGUyLmRlc3Ryb3kobnVsbCk7XG4gICAgICAgIHRoaXMudHJpYW5nbGUyID0gbnVsbDtcbiAgICAgICAgdGhpcy50cmlhbmdsZS5kZXN0cm95KG51bGwpO1xuICAgICAgICB0aGlzLnRyaWFuZ2xlID0gbnVsbDtcbiAgICAgICAgdGhpcy50eHQzLmRlc3Ryb3kobnVsbCk7XG4gICAgICAgIHRoaXMudHh0MyA9IG51bGw7XG4gICAgICAgIHRoaXMudHh0Mi5kZXN0cm95KG51bGwpO1xuICAgICAgICB0aGlzLnR4dDIgPSBudWxsO1xuICAgIH1cbn1cbmV4cG9ydHMuTWVzaEdlb21ldHJ5ID0gTWVzaEdlb21ldHJ5O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBCYXNlRXhhbXBsZV8xID0gcmVxdWlyZShcIi4vQmFzZUV4YW1wbGVcIik7XG5jb25zdCBSZXNvdXJjZUxvYWRlcl8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1Jlc291cmNlTG9hZGVyXCIpO1xuY29uc3QgVGV4dHVyZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1RleHR1cmVcIik7XG5jb25zdCBVUkxSZXF1ZXN0XzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvVVJMUmVxdWVzdFwiKTtcbmNvbnN0IEV2ZW50XzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvRXZlbnRcIik7XG5jb25zdCBCYXNlVGV4dHVyZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0Jhc2VUZXh0dXJlXCIpO1xuY29uc3QgR2VvbWV0cnlfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9HZW9tZXRyeVwiKTtcbmNvbnN0IFByb2dyYW1fMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9Qcm9ncmFtXCIpO1xuY29uc3QgU2hhZGVyXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvU2hhZGVyXCIpO1xuY29uc3QgTWVzaF8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL01lc2hcIik7XG5jbGFzcyBNZXNoU2hhZGVyIGV4dGVuZHMgQmFzZUV4YW1wbGVfMS5CYXNlRXhhbXBsZSB7XG4gICAgY29uc3RydWN0b3IoYXBwLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHN1cGVyKGFwcCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIHRoaXMuaGFuZGxlVHh0MUxvYWRlZCA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgdGhpcy50eHQxID0gbmV3IFRleHR1cmVfMS5UZXh0dXJlKG5ldyBCYXNlVGV4dHVyZV8xLkJhc2VUZXh0dXJlKHRoaXMubG9hZGVyLmltYWdlRGF0YSkpO1xuICAgICAgICAgICAgY29uc3QgZ2VvbWV0cnkgPSBuZXcgR2VvbWV0cnlfMS5HZW9tZXRyeSgpO1xuICAgICAgICAgICAgZ2VvbWV0cnkuYWRkQXR0cmlidXRlKCdhVmVydGV4UG9zaXRpb24nLCAvLyB0aGUgYXR0cmlidXRlIG5hbWVcbiAgICAgICAgICAgIFstMTAwLCAtMTAwLFxuICAgICAgICAgICAgICAgIDEwMCwgLTEwMCxcbiAgICAgICAgICAgICAgICAxMDAsIDEwMF0pOyAvLyB4LCB5XG4gICAgICAgICAgICBnZW9tZXRyeS5hZGRBdHRyaWJ1dGUoJ2FVdnMnLCAvLyB0aGUgYXR0cmlidXRlIG5hbWVcbiAgICAgICAgICAgIFswLCAwLFxuICAgICAgICAgICAgICAgIDEsIDAsXG4gICAgICAgICAgICAgICAgMSwgMV0pOyAvLyB1LCB2XG4gICAgICAgICAgICBsZXQgdnggPSBgXG4gICAgICAgICAgICBwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcbiAgICAgICAgICAgIGF0dHJpYnV0ZSB2ZWMyIGFWZXJ0ZXhQb3NpdGlvbjtcbiAgICAgICAgICAgIGF0dHJpYnV0ZSB2ZWMyIGFVdnM7XG4gICAgICAgICAgICB1bmlmb3JtIG1hdDMgdHJhbnNsYXRpb25NYXRyaXg7XG4gICAgICAgICAgICB1bmlmb3JtIG1hdDMgcHJvamVjdGlvbk1hdHJpeDtcbiAgICAgICAgICAgIHZhcnlpbmcgdmVjMiB2VXZzO1xuICAgICAgICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICAgICAgICAgIHZVdnMgPSBhVXZzO1xuICAgICAgICAgICAgICAgIGdsX1Bvc2l0aW9uID0gdmVjNCgocHJvamVjdGlvbk1hdHJpeCAqIHRyYW5zbGF0aW9uTWF0cml4ICogdmVjMyhhVmVydGV4UG9zaXRpb24sIDEuMCkpLnh5LCAwLjAsIDEuMCk7XG4gICAgICAgICAgICB9YDtcbiAgICAgICAgICAgIGxldCBmeCA9IGBwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcbiAgICAgICAgICAgIHZhcnlpbmcgdmVjMiB2VXZzO1xuICAgICAgICAgICAgdW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXIyO1xuICAgICAgICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICAgICAgICAgIGdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCh1U2FtcGxlcjIsIHZVdnMpO1xuICAgICAgICAgICAgfSAgICAgICAgXG4gICAgICAgICAgICBgO1xuICAgICAgICAgICAgbGV0IHByb2dyYW0gPSBuZXcgUHJvZ3JhbV8xLlByb2dyYW0odngsIGZ4KTtcbiAgICAgICAgICAgIGNvbnN0IHNoYWRlciA9IG5ldyBTaGFkZXJfMS5TaGFkZXIocHJvZ3JhbSwgeyB1U2FtcGxlcjI6IHRoaXMudHh0MSB9KTtcbiAgICAgICAgICAgIGxldCB2eDIgPSBgXG4gICAgICAgICAgICBwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDsgICAgXG4gICAgICAgICAgICBhdHRyaWJ1dGUgdmVjMiBhVmVydGV4UG9zaXRpb247XG4gICAgICAgICAgICBhdHRyaWJ1dGUgdmVjMiBhVXZzOyAgICBcbiAgICAgICAgICAgIHVuaWZvcm0gbWF0MyB0cmFuc2xhdGlvbk1hdHJpeDtcbiAgICAgICAgICAgIHVuaWZvcm0gbWF0MyBwcm9qZWN0aW9uTWF0cml4OyAgICBcbiAgICAgICAgICAgIHZhcnlpbmcgdmVjMiB2VXZzOyAgICBcbiAgICAgICAgICAgIHZvaWQgbWFpbigpIHsgICAgXG4gICAgICAgICAgICAgICAgdlV2cyA9IGFVdnM7XG4gICAgICAgICAgICAgICAgZ2xfUG9zaXRpb24gPSB2ZWM0KChwcm9qZWN0aW9uTWF0cml4ICogdHJhbnNsYXRpb25NYXRyaXggKiB2ZWMzKGFWZXJ0ZXhQb3NpdGlvbiwgMS4wKSkueHksIDAuMCwgMS4wKTsgICAgXG4gICAgICAgICAgICB9YDtcbiAgICAgICAgICAgIGxldCBmeDIgPSBgcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XG4gICAgICAgICAgICB2YXJ5aW5nIHZlYzIgdlV2czsgICAgXG4gICAgICAgICAgICB1bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjI7ICAgIFxuICAgICAgICAgICAgdm9pZCBtYWluKCkgeyAgICBcbiAgICAgICAgICAgICAgICBnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQodVNhbXBsZXIyLCB2VXZzKTtcbiAgICAgICAgICAgICAgICBnbF9GcmFnQ29sb3IuciArPSAoYWJzKHNpbihnbF9GcmFnQ29vcmQueCAqIDAuMDYpKSAqIDAuNSkgKiAyLjtcbiAgICAgICAgICAgICAgICBnbF9GcmFnQ29sb3IuZyArPSAoYWJzKGNvcyhnbF9GcmFnQ29vcmQueSAqIDAuMDYpKSAqIDAuNSkgKiAyLjtcbiAgICAgICAgICAgIH0gICAgXG4gICAgICAgICAgICBgO1xuICAgICAgICAgICAgbGV0IHByb2dyYW0yID0gbmV3IFByb2dyYW1fMS5Qcm9ncmFtKHZ4MiwgZngyKTtcbiAgICAgICAgICAgIGNvbnN0IHNoYWRlcjIgPSBuZXcgU2hhZGVyXzEuU2hhZGVyKHByb2dyYW0yLCB7IHVTYW1wbGVyMjogdGhpcy50eHQxIH0pO1xuICAgICAgICAgICAgdGhpcy50cmlhbmdsZSA9IG5ldyBNZXNoXzEuTWVzaChnZW9tZXRyeSwgc2hhZGVyKTtcbiAgICAgICAgICAgIHRoaXMudHJpYW5nbGUyID0gbmV3IE1lc2hfMS5NZXNoKGdlb21ldHJ5LCBzaGFkZXIyKTtcbiAgICAgICAgICAgIHRoaXMudHJpYW5nbGUucG9zaXRpb24uc2V0KDQwMCwgMzAwKTtcbiAgICAgICAgICAgIHRoaXMudHJpYW5nbGUuc2NhbGUuc2V0KDIpO1xuICAgICAgICAgICAgdGhpcy50cmlhbmdsZTIucG9zaXRpb24uc2V0KDUwMCwgNDAwKTtcbiAgICAgICAgICAgIHRoaXMudHJpYW5nbGUyLnNjYWxlLnNldCgzKTtcbiAgICAgICAgICAgIHRoaXMuc3RhZ2UuYWRkQ2hpbGQodGhpcy50cmlhbmdsZTIpO1xuICAgICAgICAgICAgdGhpcy5zdGFnZS5hZGRDaGlsZCh0aGlzLnRyaWFuZ2xlKTtcbiAgICAgICAgICAgIHRoaXMuYXBwLnRpY2tlci5hZGQodGhpcy5ydW5FeGFtcGxlKTtcbiAgICAgICAgICAgIHRoaXMuZXhhbXBsZVJlYWR5KCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucnVuRXhhbXBsZSA9IChkZWx0YSkgPT4ge1xuICAgICAgICAgICAgdGhpcy50cmlhbmdsZS5yb3RhdGlvbiArPSAwLjAxO1xuICAgICAgICAgICAgdGhpcy50cmlhbmdsZTIucm90YXRpb24gLT0gMC4wMDU7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuYWN0aXZhdGVNYXNrKCk7XG4gICAgICAgIHRoaXMubG9hZGVyID0gbmV3IFJlc291cmNlTG9hZGVyXzEuUmVzb3VyY2VMb2FkZXIobmV3IFVSTFJlcXVlc3RfMS5VUkxSZXF1ZXN0KFwiZXhhbXBsZXMvYXNzZXRzL2JnX3NjZW5lX3JvdGF0ZS5qcGdcIikpO1xuICAgICAgICB0aGlzLmxvYWRlci5hZGRFdmVudExpc3RlbmVyKEV2ZW50XzEuRXZlbnQuQ09NUExFVEUsIHRoaXMuaGFuZGxlVHh0MUxvYWRlZCk7XG4gICAgICAgIHRoaXMubG9hZGVyLmxvYWQoKTtcbiAgICB9XG4gICAgZGVzdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIuZGVzdHJ1Y3RvcigpO1xuICAgICAgICB0aGlzLmFwcC50aWNrZXIucmVtb3ZlKHRoaXMucnVuRXhhbXBsZSwgbnVsbCk7XG4gICAgICAgIHRoaXMudHh0MS5kZXN0cm95KG51bGwpO1xuICAgICAgICB0aGlzLnR4dDEgPSBudWxsO1xuICAgICAgICB0aGlzLnRyaWFuZ2xlLmRlc3Ryb3kobnVsbCk7XG4gICAgICAgIHRoaXMudHJpYW5nbGUgPSBudWxsO1xuICAgICAgICB0aGlzLnRyaWFuZ2xlMi5kZXN0cm95KG51bGwpO1xuICAgICAgICB0aGlzLnRyaWFuZ2xlMiA9IG51bGw7XG4gICAgfVxufVxuZXhwb3J0cy5NZXNoU2hhZGVyID0gTWVzaFNoYWRlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgQmFzZUV4YW1wbGVfMSA9IHJlcXVpcmUoXCIuL0Jhc2VFeGFtcGxlXCIpO1xuY29uc3QgUmVzb3VyY2VMb2FkZXJfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9SZXNvdXJjZUxvYWRlclwiKTtcbmNvbnN0IFRleHR1cmVfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9UZXh0dXJlXCIpO1xuY29uc3QgVVJMUmVxdWVzdF8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1VSTFJlcXVlc3RcIik7XG5jb25zdCBFdmVudF8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0V2ZW50XCIpO1xuY29uc3QgQmFzZVRleHR1cmVfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9CYXNlVGV4dHVyZVwiKTtcbmNvbnN0IEdlb21ldHJ5XzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvR2VvbWV0cnlcIik7XG5jb25zdCBQcm9ncmFtXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvUHJvZ3JhbVwiKTtcbmNvbnN0IFNoYWRlcl8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1NoYWRlclwiKTtcbmNvbnN0IE1lc2hfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9NZXNoXCIpO1xuY2xhc3MgTWVzaFRleHR1cmVkIGV4dGVuZHMgQmFzZUV4YW1wbGVfMS5CYXNlRXhhbXBsZSB7XG4gICAgY29uc3RydWN0b3IoYXBwLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHN1cGVyKGFwcCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIHRoaXMuaGFuZGxlUGxhbmVMb2FkZWQgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIHRoaXMucGxhbmVUeHQgPSBuZXcgVGV4dHVyZV8xLlRleHR1cmUobmV3IEJhc2VUZXh0dXJlXzEuQmFzZVRleHR1cmUodGhpcy5sb2FkZXIuaW1hZ2VEYXRhKSk7XG4gICAgICAgICAgICBjb25zdCBnZW9tZXRyeSA9IG5ldyBHZW9tZXRyeV8xLkdlb21ldHJ5KCk7XG4gICAgICAgICAgICBnZW9tZXRyeS5hZGRBdHRyaWJ1dGUoJ2FWZXJ0ZXhQb3NpdGlvbicsIC8vIHRoZSBhdHRyaWJ1dGUgbmFtZVxuICAgICAgICAgICAgWy0xMDAsIC0xMDAsXG4gICAgICAgICAgICAgICAgMTAwLCAtMTAwLFxuICAgICAgICAgICAgICAgIDEwMCwgMTAwXSwgLy8geCwgeVxuICAgICAgICAgICAgMik7IC8vIHRoZSBzaXplIG9mIHRoZSBhdHRyaWJ1dGVcbiAgICAgICAgICAgIGdlb21ldHJ5LmFkZEF0dHJpYnV0ZSgnYUNvbG9yJywgLy8gdGhlIGF0dHJpYnV0ZSBuYW1lXG4gICAgICAgICAgICBbMSwgMCwgMCxcbiAgICAgICAgICAgICAgICAwLCAxLCAwLFxuICAgICAgICAgICAgICAgIDAsIDAsIDFdLCAvLyByLCBnLCBiXG4gICAgICAgICAgICAzKTsgLy8gdGhlIHNpemUgb2YgdGhlIGF0dHJpYnV0ZVxuICAgICAgICAgICAgZ2VvbWV0cnkuYWRkQXR0cmlidXRlKCdhVXZzJywgLy8gdGhlIGF0dHJpYnV0ZSBuYW1lXG4gICAgICAgICAgICBbMCwgMCxcbiAgICAgICAgICAgICAgICAxLCAwLFxuICAgICAgICAgICAgICAgIDEsIDFdLCAvLyB1LCB2XG4gICAgICAgICAgICAyKTsgLy8gdGhlIHNpemUgb2YgdGhlIGF0dHJpYnV0ZVxuICAgICAgICAgICAgY29uc3QgdmVydGV4U3JjID0gYFxuICAgICAgICAgICAgcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XG4gICAgICAgICAgICBhdHRyaWJ1dGUgdmVjMiBhVmVydGV4UG9zaXRpb247XG4gICAgICAgICAgICBhdHRyaWJ1dGUgdmVjMyBhQ29sb3I7XG4gICAgICAgICAgICBhdHRyaWJ1dGUgdmVjMiBhVXZzO1xuICAgICAgICAgICAgdW5pZm9ybSBtYXQzIHRyYW5zbGF0aW9uTWF0cml4O1xuICAgICAgICAgICAgdW5pZm9ybSBtYXQzIHByb2plY3Rpb25NYXRyaXg7XG4gICAgICAgICAgICB2YXJ5aW5nIHZlYzIgdlV2cztcbiAgICAgICAgICAgIHZhcnlpbmcgdmVjMyB2Q29sb3I7XG4gICAgICAgICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgICAgICAgICAgdlV2cyA9IGFVdnM7XG4gICAgICAgICAgICAgICAgdkNvbG9yID0gYUNvbG9yO1xuICAgICAgICAgICAgICAgIGdsX1Bvc2l0aW9uID0gdmVjNCgocHJvamVjdGlvbk1hdHJpeCAqIHRyYW5zbGF0aW9uTWF0cml4ICogdmVjMyhhVmVydGV4UG9zaXRpb24sIDEuMCkpLnh5LCAwLjAsIDEuMCk7XG4gICAgICAgICAgICB9YDtcbiAgICAgICAgICAgIGNvbnN0IGZyYWdtZW50U3JjID0gYFxuICAgICAgICAgICAgcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XG4gICAgICAgICAgICB2YXJ5aW5nIHZlYzMgdkNvbG9yO1xuICAgICAgICAgICAgdmFyeWluZyB2ZWMyIHZVdnM7XG4gICAgICAgICAgICB1bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjI7XG4gICAgICAgICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgICAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKHVTYW1wbGVyMiwgdlV2cykgKiB2ZWM0KHZDb2xvciwgMS4wKTtcbiAgICAgICAgICAgIH1gO1xuICAgICAgICAgICAgY29uc3QgdW5pZm9ybXMgPSB7IHVTYW1wbGVyMjogdGhpcy5wbGFuZVR4dCB9O1xuICAgICAgICAgICAgbGV0IHByb2dyYW0gPSBuZXcgUHJvZ3JhbV8xLlByb2dyYW0odmVydGV4U3JjLCBmcmFnbWVudFNyYyk7XG4gICAgICAgICAgICBjb25zdCBzaGFkZXIgPSBuZXcgU2hhZGVyXzEuU2hhZGVyKHByb2dyYW0sIHVuaWZvcm1zKTtcbiAgICAgICAgICAgIHRoaXMudHJpYW5nbGUgPSBuZXcgTWVzaF8xLk1lc2goZ2VvbWV0cnksIHNoYWRlcik7XG4gICAgICAgICAgICB0aGlzLnRyaWFuZ2xlLnBvc2l0aW9uLnNldCg0MDAsIDMwMCk7XG4gICAgICAgICAgICB0aGlzLnRyaWFuZ2xlLnNjYWxlLnNldCgyKTtcbiAgICAgICAgICAgIHRoaXMuc3RhZ2UuYWRkQ2hpbGQodGhpcy50cmlhbmdsZSk7XG4gICAgICAgICAgICB0aGlzLmFwcC50aWNrZXIuYWRkKHRoaXMucnVuRXhhbXBsZSk7XG4gICAgICAgICAgICB0aGlzLmV4YW1wbGVSZWFkeSgpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnJ1bkV4YW1wbGUgPSAoZGVsdGEpID0+IHtcbiAgICAgICAgICAgIHRoaXMudHJpYW5nbGUucm90YXRpb24gKz0gMC4wMTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5sb2FkZXIgPSBuZXcgUmVzb3VyY2VMb2FkZXJfMS5SZXNvdXJjZUxvYWRlcihuZXcgVVJMUmVxdWVzdF8xLlVSTFJlcXVlc3QoXCJleGFtcGxlcy9hc3NldHMvYmdfc2NlbmVfcm90YXRlLmpwZ1wiKSk7XG4gICAgICAgIHRoaXMubG9hZGVyLmFkZEV2ZW50TGlzdGVuZXIoRXZlbnRfMS5FdmVudC5DT01QTEVURSwgdGhpcy5oYW5kbGVQbGFuZUxvYWRlZCk7XG4gICAgICAgIHRoaXMubG9hZGVyLmxvYWQoKTtcbiAgICB9XG4gICAgZGVzdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIuZGVzdHJ1Y3RvcigpO1xuICAgICAgICB0aGlzLmFwcC50aWNrZXIucmVtb3ZlKHRoaXMucnVuRXhhbXBsZSwgbnVsbCk7XG4gICAgICAgIHRoaXMudHJpYW5nbGUuZGVzdHJveShudWxsKTtcbiAgICAgICAgdGhpcy50cmlhbmdsZSA9IG51bGw7XG4gICAgICAgIHRoaXMucGxhbmVUeHQuZGVzdHJveShudWxsKTtcbiAgICAgICAgdGhpcy5wbGFuZVR4dCA9IG51bGw7XG4gICAgfVxufVxuZXhwb3J0cy5NZXNoVGV4dHVyZWQgPSBNZXNoVGV4dHVyZWQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IEJhc2VFeGFtcGxlXzEgPSByZXF1aXJlKFwiLi9CYXNlRXhhbXBsZVwiKTtcbmNvbnN0IEdlb21ldHJ5XzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvR2VvbWV0cnlcIik7XG5jb25zdCBTaGFkZXJfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9TaGFkZXJcIik7XG5jb25zdCBQcm9ncmFtXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvUHJvZ3JhbVwiKTtcbmNvbnN0IE1lc2hfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9NZXNoXCIpO1xuY2xhc3MgTWVzaFRyaWFuZ2xlIGV4dGVuZHMgQmFzZUV4YW1wbGVfMS5CYXNlRXhhbXBsZSB7XG4gICAgY29uc3RydWN0b3IoYXBwLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHN1cGVyKGFwcCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIHRoaXMucnVuRXhhbXBsZSA9IChkZWx0YSkgPT4ge1xuICAgICAgICAgICAgdGhpcy50cmlhbmdsZS5yb3RhdGlvbiArPSAwLjAxO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBnZW9tZXRyeSA9IG5ldyBHZW9tZXRyeV8xLkdlb21ldHJ5KCk7XG4gICAgICAgIGdlb21ldHJ5LmFkZEF0dHJpYnV0ZSgnYVZlcnRleFBvc2l0aW9uJywgWy0xMDAsIC01MCwgMTAwLCAtNTAsIDAsIDEwMF0pO1xuICAgICAgICBsZXQgdnggPSBgXG4gICAgICAgICAgICBwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcbiAgICAgICAgICAgIGF0dHJpYnV0ZSB2ZWMyIGFWZXJ0ZXhQb3NpdGlvbjtcbiAgICAgICAgICAgIHVuaWZvcm0gbWF0MyB0cmFuc2xhdGlvbk1hdHJpeDtcbiAgICAgICAgICAgIHVuaWZvcm0gbWF0MyBwcm9qZWN0aW9uTWF0cml4O1xuICAgICAgICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICAgICAgICAgIGdsX1Bvc2l0aW9uID0gdmVjNCgocHJvamVjdGlvbk1hdHJpeCAqIHRyYW5zbGF0aW9uTWF0cml4ICogdmVjMyhhVmVydGV4UG9zaXRpb24sIDEuMCkpLnh5LCAwLjAsIDEuMCk7XG4gICAgICAgICAgICB9YDtcbiAgICAgICAgbGV0IGZ4ID0gYHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xuICAgICAgICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICAgICAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoMS4wLCAwLjAsIDAuMCwgMS4wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgYDtcbiAgICAgICAgbGV0IHByb2dyYW0gPSBuZXcgUHJvZ3JhbV8xLlByb2dyYW0odngsIGZ4KTtcbiAgICAgICAgY29uc3Qgc2hhZGVyID0gbmV3IFNoYWRlcl8xLlNoYWRlcihwcm9ncmFtLCBudWxsKTtcbiAgICAgICAgdGhpcy50cmlhbmdsZSA9IG5ldyBNZXNoXzEuTWVzaChnZW9tZXRyeSwgc2hhZGVyKTtcbiAgICAgICAgdGhpcy50cmlhbmdsZS5wb3NpdGlvbi5zZXQoNDAwLCAzMDApO1xuICAgICAgICB0aGlzLnN0YWdlLmFkZENoaWxkKHRoaXMudHJpYW5nbGUpO1xuICAgICAgICB0aGlzLmFwcC50aWNrZXIuYWRkKHRoaXMucnVuRXhhbXBsZSk7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5leGFtcGxlUmVhZHkoKTtcbiAgICAgICAgfSwgMTAwMCk7XG4gICAgfVxuICAgIGRlc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyLmRlc3RydWN0b3IoKTtcbiAgICAgICAgdGhpcy5hcHAudGlja2VyLnJlbW92ZSh0aGlzLnJ1bkV4YW1wbGUsIG51bGwpO1xuICAgICAgICB0aGlzLnRyaWFuZ2xlLmRlc3Ryb3kobnVsbCk7XG4gICAgICAgIHRoaXMudHJpYW5nbGUgPSBudWxsO1xuICAgIH1cbn1cbmV4cG9ydHMuTWVzaFRyaWFuZ2xlID0gTWVzaFRyaWFuZ2xlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBCYXNlRXhhbXBsZV8xID0gcmVxdWlyZShcIi4vQmFzZUV4YW1wbGVcIik7XG5jb25zdCBNZXNoXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvTWVzaFwiKTtcbmNvbnN0IFJlc291cmNlTG9hZGVyXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvUmVzb3VyY2VMb2FkZXJcIik7XG5jb25zdCBUZXh0dXJlXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvVGV4dHVyZVwiKTtcbmNvbnN0IFVSTFJlcXVlc3RfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9VUkxSZXF1ZXN0XCIpO1xuY29uc3QgRXZlbnRfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9FdmVudFwiKTtcbmNvbnN0IEJhc2VUZXh0dXJlXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvQmFzZVRleHR1cmVcIik7XG5jb25zdCBHZW9tZXRyeV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0dlb21ldHJ5XCIpO1xuY29uc3QgUHJvZ3JhbV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1Byb2dyYW1cIik7XG5jb25zdCBTaGFkZXJfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9TaGFkZXJcIik7XG5jbGFzcyBNZXNoVW5pZm9ybXMgZXh0ZW5kcyBCYXNlRXhhbXBsZV8xLkJhc2VFeGFtcGxlIHtcbiAgICBjb25zdHJ1Y3RvcihhcHAsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgc3VwZXIoYXBwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgdGhpcy5oYW5kbGVQbGFuZUxvYWRlZCA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5wbGFuZVR4dCA9IG5ldyBUZXh0dXJlXzEuVGV4dHVyZShuZXcgQmFzZVRleHR1cmVfMS5CYXNlVGV4dHVyZSh0aGlzLmxvYWRlci5pbWFnZURhdGEpKTtcbiAgICAgICAgICAgIGNvbnN0IGdlb21ldHJ5ID0gbmV3IEdlb21ldHJ5XzEuR2VvbWV0cnkoKTtcbiAgICAgICAgICAgIGdlb21ldHJ5LmFkZEF0dHJpYnV0ZSgnYVZlcnRleFBvc2l0aW9uJywgLy8gdGhlIGF0dHJpYnV0ZSBuYW1lXG4gICAgICAgICAgICBbLTEwMCwgLTEwMCxcbiAgICAgICAgICAgICAgICAxMDAsIC0xMDAsXG4gICAgICAgICAgICAgICAgMTAwLCAxMDAsXG4gICAgICAgICAgICAgICAgLTEwMCwgMTAwXSwgLy8geCwgeVxuICAgICAgICAgICAgMik7IC8vIHRoZSBzaXplIG9mIHRoZSBhdHRyaWJ1dGVcbiAgICAgICAgICAgIGdlb21ldHJ5LmFkZEF0dHJpYnV0ZSgnYVV2cycsIC8vIHRoZSBhdHRyaWJ1dGUgbmFtZVxuICAgICAgICAgICAgWzAsIDAsXG4gICAgICAgICAgICAgICAgMSwgMCxcbiAgICAgICAgICAgICAgICAxLCAxLFxuICAgICAgICAgICAgICAgIDAsIDFdLCAvLyB1LCB2XG4gICAgICAgICAgICAyKTsgLy8gdGhlIHNpemUgb2YgdGhlIGF0dHJpYnV0ZVxuICAgICAgICAgICAgZ2VvbWV0cnkuYWRkSW5kZXgoWzAsIDEsIDIsIDAsIDIsIDNdKTtcbiAgICAgICAgICAgIGNvbnN0IHZlcnRleFNyYyA9IGBcbiAgICAgICAgICAgIHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0OyAgICBcbiAgICAgICAgICAgIGF0dHJpYnV0ZSB2ZWMyIGFWZXJ0ZXhQb3NpdGlvbjtcbiAgICAgICAgICAgIGF0dHJpYnV0ZSB2ZWMyIGFVdnM7ICAgIFxuICAgICAgICAgICAgdW5pZm9ybSBtYXQzIHRyYW5zbGF0aW9uTWF0cml4O1xuICAgICAgICAgICAgdW5pZm9ybSBtYXQzIHByb2plY3Rpb25NYXRyaXg7ICAgIFxuICAgICAgICAgICAgdmFyeWluZyB2ZWMyIHZVdnM7ICAgIFxuICAgICAgICAgICAgdm9pZCBtYWluKCkgeyAgICBcbiAgICAgICAgICAgICAgICB2VXZzID0gYVV2cztcbiAgICAgICAgICAgICAgICBnbF9Qb3NpdGlvbiA9IHZlYzQoKHByb2plY3Rpb25NYXRyaXggKiB0cmFuc2xhdGlvbk1hdHJpeCAqIHZlYzMoYVZlcnRleFBvc2l0aW9uLCAxLjApKS54eSwgMC4wLCAxLjApOyAgICBcbiAgICAgICAgICAgIH1gO1xuICAgICAgICAgICAgY29uc3QgZnJhZ21lbnRTcmMgPSBgICAgIFxuICAgICAgICAgICAgcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7ICAgIFxuICAgICAgICAgICAgdmFyeWluZyB2ZWMyIHZVdnM7ICAgIFxuICAgICAgICAgICAgdW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXIyO1xuICAgICAgICAgICAgdW5pZm9ybSBmbG9hdCB0aW1lOyAgICBcbiAgICAgICAgICAgIHZvaWQgbWFpbigpIHsgICAgXG4gICAgICAgICAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKHVTYW1wbGVyMiwgdlV2cyArIHNpbiggKHRpbWUgKyAodlV2cy54KSAqIDE0LikgKSAqIDAuMSApO1xuICAgICAgICAgICAgfWA7XG4gICAgICAgICAgICBjb25zdCB1bmlmb3JtcyA9IHtcbiAgICAgICAgICAgICAgICB1U2FtcGxlcjI6IHRoaXMucGxhbmVUeHQsXG4gICAgICAgICAgICAgICAgdGltZTogMCxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBsZXQgcHJvZ3JhbSA9IG5ldyBQcm9ncmFtXzEuUHJvZ3JhbSh2ZXJ0ZXhTcmMsIGZyYWdtZW50U3JjKTtcbiAgICAgICAgICAgIGNvbnN0IHNoYWRlciA9IG5ldyBTaGFkZXJfMS5TaGFkZXIocHJvZ3JhbSwgdW5pZm9ybXMpO1xuICAgICAgICAgICAgdGhpcy50cmlhbmdsZSA9IG5ldyBNZXNoXzEuTWVzaChnZW9tZXRyeSwgc2hhZGVyKTtcbiAgICAgICAgICAgIHRoaXMudHJpYW5nbGUucG9zaXRpb24uc2V0KDQwMCwgMzAwKTtcbiAgICAgICAgICAgIHRoaXMudHJpYW5nbGUuc2NhbGUuc2V0KDIpO1xuICAgICAgICAgICAgdGhpcy5zdGFnZS5hZGRDaGlsZCh0aGlzLnRyaWFuZ2xlKTtcbiAgICAgICAgICAgIHRoaXMuYXBwLnRpY2tlci5hZGQodGhpcy5ydW5FeGFtcGxlKTtcbiAgICAgICAgICAgIHRoaXMuZXhhbXBsZVJlYWR5KCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucnVuRXhhbXBsZSA9IChkZWx0YSkgPT4ge1xuICAgICAgICAgICAgdGhpcy50cmlhbmdsZS5yb3RhdGlvbiArPSAwLjAxO1xuICAgICAgICAgICAgdGhpcy50cmlhbmdsZS5zaGFkZXIudW5pZm9ybXMudGltZSArPSAwLjE7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMubG9hZGVyID0gbmV3IFJlc291cmNlTG9hZGVyXzEuUmVzb3VyY2VMb2FkZXIobmV3IFVSTFJlcXVlc3RfMS5VUkxSZXF1ZXN0KFwiZXhhbXBsZXMvYXNzZXRzL2JnX3NjZW5lX3JvdGF0ZS5qcGdcIikpO1xuICAgICAgICB0aGlzLmxvYWRlci5hZGRFdmVudExpc3RlbmVyKEV2ZW50XzEuRXZlbnQuQ09NUExFVEUsIHRoaXMuaGFuZGxlUGxhbmVMb2FkZWQpO1xuICAgICAgICB0aGlzLmxvYWRlci5sb2FkKCk7XG4gICAgfVxuICAgIGRlc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyLmRlc3RydWN0b3IoKTtcbiAgICAgICAgdGhpcy5hcHAudGlja2VyLnJlbW92ZSh0aGlzLnJ1bkV4YW1wbGUsIG51bGwpO1xuICAgICAgICB0aGlzLnBsYW5lVHh0LmRlc3Ryb3kobnVsbCk7XG4gICAgICAgIHRoaXMucGxhbmVUeHQgPSBudWxsO1xuICAgICAgICB0aGlzLnRyaWFuZ2xlLmRlc3Ryb3kobnVsbCk7XG4gICAgICAgIHRoaXMudHJpYW5nbGUgPSBudWxsO1xuICAgIH1cbn1cbmV4cG9ydHMuTWVzaFVuaWZvcm1zID0gTWVzaFVuaWZvcm1zO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBCYXNlRXhhbXBsZV8xID0gcmVxdWlyZShcIi4vQmFzZUV4YW1wbGVcIik7XG5jb25zdCBSZXNvdXJjZUxvYWRlcl8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1Jlc291cmNlTG9hZGVyXCIpO1xuY29uc3QgVVJMUmVxdWVzdF8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1VSTFJlcXVlc3RcIik7XG5jb25zdCBFdmVudF8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0V2ZW50XCIpO1xuY29uc3QgVGV4dHVyZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1RleHR1cmVcIik7XG5jb25zdCBCYXNlVGV4dHVyZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0Jhc2VUZXh0dXJlXCIpO1xuY29uc3QgU3ByaXRlXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvU3ByaXRlXCIpO1xuY2xhc3MgU3ByaXRlQmFzaWMgZXh0ZW5kcyBCYXNlRXhhbXBsZV8xLkJhc2VFeGFtcGxlIHtcbiAgICBjb25zdHJ1Y3RvcihhcHAsIHdpZHRoID0gMTAwLCBoZWlnaHQgPSAxMDApIHtcbiAgICAgICAgc3VwZXIoYXBwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgdGhpcy5oYW5kbGVSb3RhdGVMb2FkZWQgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGxldCB0ZXh0dXJlID0gbmV3IFRleHR1cmVfMS5UZXh0dXJlKG5ldyBCYXNlVGV4dHVyZV8xLkJhc2VUZXh0dXJlKHRoaXMubG9hZGVyLmltYWdlRGF0YSkpO1xuICAgICAgICAgICAgdGhpcy5idW5ueSA9IG5ldyBTcHJpdGVfMS5TcHJpdGUodGV4dHVyZSk7XG4gICAgICAgICAgICB0aGlzLmJ1bm55LmFuY2hvci5zZXQoMC41KTtcbiAgICAgICAgICAgIHRoaXMuYnVubnkueCA9IHRoaXMuc2l6ZXcgLyAyO1xuICAgICAgICAgICAgdGhpcy5idW5ueS55ID0gdGhpcy5zaXplaCAvIDI7XG4gICAgICAgICAgICB0aGlzLnN0YWdlLmFkZENoaWxkKHRoaXMuYnVubnkpO1xuICAgICAgICAgICAgdGhpcy5hcHAudGlja2VyLmFkZCh0aGlzLnJ1bkV4YW1wbGUpO1xuICAgICAgICAgICAgdGhpcy5leGFtcGxlUmVhZHkoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5ydW5FeGFtcGxlID0gKGRlbHRhKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmJ1bm55LnJvdGF0aW9uICs9IDAuMSAqIGRlbHRhO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmJhY2tDb2xvciA9IDB4RkZGMDAwO1xuICAgICAgICB0aGlzLmxvYWRlciA9IG5ldyBSZXNvdXJjZUxvYWRlcl8xLlJlc291cmNlTG9hZGVyKG5ldyBVUkxSZXF1ZXN0XzEuVVJMUmVxdWVzdChcImV4YW1wbGVzL2Fzc2V0cy9idW5ueS5wbmdcIikpO1xuICAgICAgICB0aGlzLmxvYWRlci5hZGRFdmVudExpc3RlbmVyKEV2ZW50XzEuRXZlbnQuQ09NUExFVEUsIHRoaXMuaGFuZGxlUm90YXRlTG9hZGVkKTtcbiAgICAgICAgdGhpcy5sb2FkZXIubG9hZCgpO1xuICAgIH1cbiAgICBkZXN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlci5kZXN0cnVjdG9yKCk7XG4gICAgICAgIHRoaXMuYXBwLnRpY2tlci5yZW1vdmUodGhpcy5ydW5FeGFtcGxlLCBudWxsKTtcbiAgICAgICAgdGhpcy5idW5ueS5kZXN0cnVjdG9yKCk7XG4gICAgICAgIHRoaXMuYnVubnkgPSBudWxsO1xuICAgIH1cbn1cbmV4cG9ydHMuU3ByaXRlQmFzaWMgPSBTcHJpdGVCYXNpYztcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgQmFzZUV4YW1wbGVfMSA9IHJlcXVpcmUoXCIuL0Jhc2VFeGFtcGxlXCIpO1xuY29uc3QgVVJMTG9hZGVyXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvVVJMTG9hZGVyXCIpO1xuY29uc3QgRXZlbnRfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9FdmVudFwiKTtcbmNvbnN0IFVSTFJlcXVlc3RfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9VUkxSZXF1ZXN0XCIpO1xuY29uc3QgUmVzb3VyY2VMb2FkZXJfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9SZXNvdXJjZUxvYWRlclwiKTtcbmNvbnN0IFRleHR1cmVfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9UZXh0dXJlXCIpO1xuY29uc3QgQmFzZVRleHR1cmVfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9CYXNlVGV4dHVyZVwiKTtcbmNvbnN0IFNwcml0ZXNoZWV0XzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvU3ByaXRlc2hlZXRcIik7XG5jb25zdCBBbmltYXRlZFNwcml0ZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0FuaW1hdGVkU3ByaXRlXCIpO1xuY2xhc3MgU3ByaXRlRXhwbG9zaW9uIGV4dGVuZHMgQmFzZUV4YW1wbGVfMS5CYXNlRXhhbXBsZSB7XG4gICAgY29uc3RydWN0b3IoYXBwLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHN1cGVyKGFwcCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIHRoaXMub25BbmltYXRpb25QYXJzZWQgPSAodGV4dHVyZXMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGV4cGxvc2lvblRleHR1cmVzID0gW107XG4gICAgICAgICAgICBsZXQgaTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCAyNjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGV4dHVyZSA9IHRleHR1cmVzW2BFeHBsb3Npb25fU2VxdWVuY2VfQSAke2kgKyAxfS5wbmdgXTtcbiAgICAgICAgICAgICAgICBleHBsb3Npb25UZXh0dXJlcy5wdXNoKHRleHR1cmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IDUwOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBleHBsb3Npb24gPSBuZXcgQW5pbWF0ZWRTcHJpdGVfMS5BbmltYXRlZFNwcml0ZShleHBsb3Npb25UZXh0dXJlcyk7XG4gICAgICAgICAgICAgICAgZXhwbG9zaW9uLnggPSBNYXRoLnJhbmRvbSgpICogdGhpcy5zaXpldztcbiAgICAgICAgICAgICAgICBleHBsb3Npb24ueSA9IE1hdGgucmFuZG9tKCkgKiB0aGlzLnNpemVoO1xuICAgICAgICAgICAgICAgIGV4cGxvc2lvbi5hbmNob3Iuc2V0KDAuNSk7XG4gICAgICAgICAgICAgICAgZXhwbG9zaW9uLnJvdGF0aW9uID0gTWF0aC5yYW5kb20oKSAqIE1hdGguUEk7XG4gICAgICAgICAgICAgICAgZXhwbG9zaW9uLnNjYWxlLnNldCgwLjc1ICsgTWF0aC5yYW5kb20oKSAqIDAuNSk7XG4gICAgICAgICAgICAgICAgZXhwbG9zaW9uLmdvdG9BbmRQbGF5KE1hdGgucmFuZG9tKCkgKiAyNyk7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFnZS5hZGRDaGlsZChleHBsb3Npb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5leGFtcGxlUmVhZHkoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVKc29uTG9hZGVkID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICB0aGlzLmpzb25kYXRhID0gSlNPTi5wYXJzZSh0aGlzLnVybGxvYWRlci5kYXRhKTtcbiAgICAgICAgICAgIHRoaXMubG9hZGVyID0gbmV3IFJlc291cmNlTG9hZGVyXzEuUmVzb3VyY2VMb2FkZXIobmV3IFVSTFJlcXVlc3RfMS5VUkxSZXF1ZXN0KFwiZXhhbXBsZXMvYXNzZXRzL3Nwcml0ZXNoZWV0L21jLnBuZ1wiKSk7XG4gICAgICAgICAgICB0aGlzLmxvYWRlci5hZGRFdmVudExpc3RlbmVyKEV2ZW50XzEuRXZlbnQuQ09NUExFVEUsIHRoaXMuaGFuZGxlUm90YXRlTG9hZGVkKTtcbiAgICAgICAgICAgIHRoaXMubG9hZGVyLmxvYWQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVSb3RhdGVMb2FkZWQgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIHRoaXMudHh0ID0gbmV3IFRleHR1cmVfMS5UZXh0dXJlKG5ldyBCYXNlVGV4dHVyZV8xLkJhc2VUZXh0dXJlKHRoaXMubG9hZGVyLmltYWdlRGF0YSkpO1xuICAgICAgICAgICAgbGV0IHNwcml0ZXNoZWV0ID0gbmV3IFNwcml0ZXNoZWV0XzEuU3ByaXRlc2hlZXQodGhpcy50eHQsIHRoaXMuanNvbmRhdGEpO1xuICAgICAgICAgICAgc3ByaXRlc2hlZXQucGFyc2UodGhpcy5vbkFuaW1hdGlvblBhcnNlZCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuYmFja0NvbG9yID0gMHgwMDAwMDA7XG4gICAgICAgIHRoaXMuYWN0aXZhdGVNYXNrKCk7XG4gICAgICAgIHRoaXMudXJsbG9hZGVyID0gbmV3IFVSTExvYWRlcl8xLlVSTExvYWRlcigpO1xuICAgICAgICB0aGlzLnVybGxvYWRlci5hZGRFdmVudExpc3RlbmVyKEV2ZW50XzEuRXZlbnQuQ09NUExFVEUsIHRoaXMuaGFuZGxlSnNvbkxvYWRlZCk7XG4gICAgICAgIHRoaXMudXJsbG9hZGVyLmxvYWQobmV3IFVSTFJlcXVlc3RfMS5VUkxSZXF1ZXN0KFwiZXhhbXBsZXMvYXNzZXRzL3Nwcml0ZXNoZWV0L21jLmpzb25cIikpO1xuICAgIH1cbiAgICBkZXN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlci5kZXN0cnVjdG9yKCk7XG4gICAgICAgIHRoaXMudHh0LmRlc3Ryb3kobnVsbCk7XG4gICAgICAgIHRoaXMudHh0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5qc29uZGF0YSA9IG51bGw7XG4gICAgfVxufVxuZXhwb3J0cy5TcHJpdGVFeHBsb3Npb24gPSBTcHJpdGVFeHBsb3Npb247XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IEJhc2VFeGFtcGxlXzEgPSByZXF1aXJlKFwiLi9CYXNlRXhhbXBsZVwiKTtcbmNvbnN0IFVSTExvYWRlcl8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1VSTExvYWRlclwiKTtcbmNvbnN0IFJlc291cmNlTG9hZGVyXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvUmVzb3VyY2VMb2FkZXJcIik7XG5jb25zdCBUZXh0dXJlXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvVGV4dHVyZVwiKTtcbmNvbnN0IEFuaW1hdGVkU3ByaXRlXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvQW5pbWF0ZWRTcHJpdGVcIik7XG5jb25zdCBFdmVudF8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0V2ZW50XCIpO1xuY29uc3QgVVJMUmVxdWVzdF8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1VSTFJlcXVlc3RcIik7XG5jb25zdCBCYXNlVGV4dHVyZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0Jhc2VUZXh0dXJlXCIpO1xuY29uc3QgU3ByaXRlc2hlZXRfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9TcHJpdGVzaGVldFwiKTtcbmNsYXNzIFNwcml0ZVNwZWVkIGV4dGVuZHMgQmFzZUV4YW1wbGVfMS5CYXNlRXhhbXBsZSB7XG4gICAgY29uc3RydWN0b3IoYXBwLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHN1cGVyKGFwcCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIHRoaXMub25BbmltYXRpb25QYXJzZWQgPSAobG9hZGVkdGV4dHVyZXMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHRleHR1cmVzID0gW107XG4gICAgICAgICAgICBsZXQgaTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCAxMDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZnJhbWVrZXkgPSBgMDEyMzQ1Njc4OSAke2l9LmFzZWA7XG4gICAgICAgICAgICAgICAgY29uc3QgdGV4dHVyZSA9IGxvYWRlZHRleHR1cmVzW2ZyYW1la2V5XTtcbiAgICAgICAgICAgICAgICBjb25zdCB0aW1lID0gdGhpcy5zcHJpdGVzaGVldC5kYXRhLmZyYW1lc1tmcmFtZWtleV0uZHVyYXRpb247XG4gICAgICAgICAgICAgICAgdGV4dHVyZXMucHVzaCh7IHRleHR1cmUsIHRpbWUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzY2FsaW5nID0gNDtcbiAgICAgICAgICAgIGNvbnN0IHNsb3cgPSBuZXcgQW5pbWF0ZWRTcHJpdGVfMS5BbmltYXRlZFNwcml0ZSh0ZXh0dXJlcyk7XG4gICAgICAgICAgICBzbG93LmFuY2hvci5zZXQoMC41KTtcbiAgICAgICAgICAgIHNsb3cuc2NhbGUuc2V0KHNjYWxpbmcpO1xuICAgICAgICAgICAgc2xvdy5hbmltYXRpb25TcGVlZCA9IDAuNTtcbiAgICAgICAgICAgIHNsb3cueCA9ICh0aGlzLnNpemV3IC0gc2xvdy53aWR0aCkgLyAyO1xuICAgICAgICAgICAgc2xvdy55ID0gdGhpcy5zaXplaCAvIDI7XG4gICAgICAgICAgICBzbG93LnBsYXkoKTtcbiAgICAgICAgICAgIHRoaXMuc3RhZ2UuYWRkQ2hpbGQoc2xvdyk7XG4gICAgICAgICAgICBjb25zdCBmYXN0ID0gbmV3IEFuaW1hdGVkU3ByaXRlXzEuQW5pbWF0ZWRTcHJpdGUodGV4dHVyZXMpO1xuICAgICAgICAgICAgZmFzdC5hbmNob3Iuc2V0KDAuNSk7XG4gICAgICAgICAgICBmYXN0LnNjYWxlLnNldChzY2FsaW5nKTtcbiAgICAgICAgICAgIGZhc3QueCA9ICh0aGlzLnNpemV3ICsgZmFzdC53aWR0aCkgLyAyO1xuICAgICAgICAgICAgZmFzdC55ID0gdGhpcy5zaXplaCAvIDI7XG4gICAgICAgICAgICBmYXN0LnBsYXkoKTtcbiAgICAgICAgICAgIHRoaXMuc3RhZ2UuYWRkQ2hpbGQoZmFzdCk7XG4gICAgICAgICAgICAvLyB0aGlzLmFwcC50aWNrZXIuYWRkKHRoaXMucnVuRXhhbXBsZSlcbiAgICAgICAgICAgIHRoaXMuZXhhbXBsZVJlYWR5KCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucnVuRXhhbXBsZSA9IChkZWx0YSkgPT4ge1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZUpzb25Mb2FkZWQgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuanNvbmRhdGEgPSBKU09OLnBhcnNlKHRoaXMudXJsbG9hZGVyLmRhdGEpO1xuICAgICAgICAgICAgdGhpcy5sb2FkZXIgPSBuZXcgUmVzb3VyY2VMb2FkZXJfMS5SZXNvdXJjZUxvYWRlcihuZXcgVVJMUmVxdWVzdF8xLlVSTFJlcXVlc3QoXCJleGFtcGxlcy9hc3NldHMvc3ByaXRlc2hlZXQvMDEyMzQ1Njc4OS5wbmdcIikpO1xuICAgICAgICAgICAgdGhpcy5sb2FkZXIuYWRkRXZlbnRMaXN0ZW5lcihFdmVudF8xLkV2ZW50LkNPTVBMRVRFLCB0aGlzLmhhbmRsZVJvdGF0ZUxvYWRlZCk7XG4gICAgICAgICAgICB0aGlzLmxvYWRlci5sb2FkKCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlUm90YXRlTG9hZGVkID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnR4dCA9IG5ldyBUZXh0dXJlXzEuVGV4dHVyZShuZXcgQmFzZVRleHR1cmVfMS5CYXNlVGV4dHVyZSh0aGlzLmxvYWRlci5pbWFnZURhdGEpKTtcbiAgICAgICAgICAgIHRoaXMuc3ByaXRlc2hlZXQgPSBuZXcgU3ByaXRlc2hlZXRfMS5TcHJpdGVzaGVldCh0aGlzLnR4dCwgdGhpcy5qc29uZGF0YSk7XG4gICAgICAgICAgICB0aGlzLnNwcml0ZXNoZWV0LnBhcnNlKHRoaXMub25BbmltYXRpb25QYXJzZWQpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmJhY2tDb2xvciA9IDB4NTdBQUNDO1xuICAgICAgICB0aGlzLnVybGxvYWRlciA9IG5ldyBVUkxMb2FkZXJfMS5VUkxMb2FkZXIoKTtcbiAgICAgICAgdGhpcy51cmxsb2FkZXIuYWRkRXZlbnRMaXN0ZW5lcihFdmVudF8xLkV2ZW50LkNPTVBMRVRFLCB0aGlzLmhhbmRsZUpzb25Mb2FkZWQpO1xuICAgICAgICB0aGlzLnVybGxvYWRlci5sb2FkKG5ldyBVUkxSZXF1ZXN0XzEuVVJMUmVxdWVzdChcImV4YW1wbGVzL2Fzc2V0cy9zcHJpdGVzaGVldC8wMTIzNDU2Nzg5Lmpzb25cIikpO1xuICAgIH1cbiAgICBkZXN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlci5kZXN0cnVjdG9yKCk7XG4gICAgICAgIHRoaXMuYXBwLnRpY2tlci5yZW1vdmUodGhpcy5ydW5FeGFtcGxlLCBudWxsKTtcbiAgICAgICAgaWYgKHRoaXMuc3ByaXRlc2hlZXQpIHtcbiAgICAgICAgICAgIHRoaXMuc3ByaXRlc2hlZXQuZGVzdHJ1Y3RvcigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3ByaXRlc2hlZXQgPSBudWxsO1xuICAgICAgICBpZiAodGhpcy50eHQpIHtcbiAgICAgICAgICAgIHRoaXMudHh0LmRlc3RydWN0b3IoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnR4dCA9IG51bGw7XG4gICAgICAgIGlmICh0aGlzLmFuaW0pIHtcbiAgICAgICAgICAgIHRoaXMuYW5pbS5kZXN0cnVjdG9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hbmltID0gbnVsbDtcbiAgICB9XG59XG5leHBvcnRzLlNwcml0ZVNwZWVkID0gU3ByaXRlU3BlZWQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IEJhc2VFeGFtcGxlXzEgPSByZXF1aXJlKFwiLi9CYXNlRXhhbXBsZVwiKTtcbmNvbnN0IFJlc291cmNlTG9hZGVyXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvUmVzb3VyY2VMb2FkZXJcIik7XG5jb25zdCBVUkxSZXF1ZXN0XzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvVVJMUmVxdWVzdFwiKTtcbmNvbnN0IEV2ZW50XzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvRXZlbnRcIik7XG5jb25zdCBUZXh0dXJlXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvVGV4dHVyZVwiKTtcbmNvbnN0IEJhc2VUZXh0dXJlXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvQmFzZVRleHR1cmVcIik7XG5jb25zdCBTcHJpdGVfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9TcHJpdGVcIik7XG5jb25zdCBNb3VzZUV2ZW50XzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvTW91c2VFdmVudFwiKTtcbmNsYXNzIFNwcml0ZVN3YXAgZXh0ZW5kcyBCYXNlRXhhbXBsZV8xLkJhc2VFeGFtcGxlIHtcbiAgICBjb25zdHJ1Y3RvcihhcHAsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgc3VwZXIoYXBwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgdGhpcy5oYW5kbGVSb3RhdGVMb2FkZWQgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIHRoaXMudHh0MSA9IG5ldyBUZXh0dXJlXzEuVGV4dHVyZShuZXcgQmFzZVRleHR1cmVfMS5CYXNlVGV4dHVyZSh0aGlzLmxvYWRlci5pbWFnZURhdGEpKTtcbiAgICAgICAgICAgIHRoaXMubG9hZGVyID0gbmV3IFJlc291cmNlTG9hZGVyXzEuUmVzb3VyY2VMb2FkZXIobmV3IFVSTFJlcXVlc3RfMS5VUkxSZXF1ZXN0KFwiZXhhbXBsZXMvYXNzZXRzL2VnZ0hlYWQucG5nXCIpKTtcbiAgICAgICAgICAgIHRoaXMubG9hZGVyLmFkZEV2ZW50TGlzdGVuZXIoRXZlbnRfMS5FdmVudC5DT01QTEVURSwgdGhpcy5oYW5kbGVSb3RhdGUyTG9hZGVkKTtcbiAgICAgICAgICAgIHRoaXMubG9hZGVyLmxvYWQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVSb3RhdGUyTG9hZGVkID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnR4dDIgPSBuZXcgVGV4dHVyZV8xLlRleHR1cmUobmV3IEJhc2VUZXh0dXJlXzEuQmFzZVRleHR1cmUodGhpcy5sb2FkZXIuaW1hZ2VEYXRhKSk7XG4gICAgICAgICAgICB0aGlzLmR1ZGUgPSBuZXcgU3ByaXRlXzEuU3ByaXRlKHRoaXMudHh0MSk7XG4gICAgICAgICAgICB0aGlzLmR1ZGUuYW5jaG9yLnNldCgwLjUpO1xuICAgICAgICAgICAgdGhpcy5kdWRlLnggPSB0aGlzLnNpemV3IC8gMjtcbiAgICAgICAgICAgIHRoaXMuZHVkZS55ID0gdGhpcy5zaXplaCAvIDI7XG4gICAgICAgICAgICB0aGlzLnN0YWdlLmFkZENoaWxkKHRoaXMuZHVkZSk7XG4gICAgICAgICAgICB0aGlzLmR1ZGUuaW50ZXJhY3RpdmUgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5kdWRlLmJ1dHRvbk1vZGUgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5kdWRlLmFkZEV2ZW50TGlzdGVuZXIoTW91c2VFdmVudF8xLk1vdXNlRXZlbnQuUE9JTlRFUl9ET1dOLCB0aGlzLmhhbmRsZURvd24pO1xuICAgICAgICAgICAgdGhpcy5hcHAudGlja2VyLmFkZCh0aGlzLnJ1bkV4YW1wbGUpO1xuICAgICAgICAgICAgdGhpcy5leGFtcGxlUmVhZHkoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVEb3duID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICB0aGlzLmJvbCA9ICF0aGlzLmJvbDtcbiAgICAgICAgICAgIGlmICh0aGlzLmJvbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZHVkZS50ZXh0dXJlID0gdGhpcy50eHQyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kdWRlLnRleHR1cmUgPSB0aGlzLnR4dDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucnVuRXhhbXBsZSA9IChkZWx0YSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5kdWRlLnJvdGF0aW9uICs9IDAuMTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5sb2FkZXIgPSBuZXcgUmVzb3VyY2VMb2FkZXJfMS5SZXNvdXJjZUxvYWRlcihuZXcgVVJMUmVxdWVzdF8xLlVSTFJlcXVlc3QoXCJleGFtcGxlcy9hc3NldHMvZmxvd2VyVG9wLnBuZ1wiKSk7XG4gICAgICAgIHRoaXMubG9hZGVyLmFkZEV2ZW50TGlzdGVuZXIoRXZlbnRfMS5FdmVudC5DT01QTEVURSwgdGhpcy5oYW5kbGVSb3RhdGVMb2FkZWQpO1xuICAgICAgICB0aGlzLmxvYWRlci5sb2FkKCk7XG4gICAgfVxuICAgIGRlc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyLmRlc3RydWN0b3IoKTtcbiAgICAgICAgdGhpcy5hcHAudGlja2VyLnJlbW92ZSh0aGlzLnJ1bkV4YW1wbGUsIG51bGwpO1xuICAgICAgICB0aGlzLmR1ZGUuZGVzdHJveShudWxsKTtcbiAgICAgICAgdGhpcy5kdWRlID0gbnVsbDtcbiAgICAgICAgdGhpcy50eHQxLmRlc3Ryb3kobnVsbCk7XG4gICAgICAgIHRoaXMudHh0MSA9IG51bGw7XG4gICAgICAgIHRoaXMudHh0Mi5kZXN0cm95KG51bGwpO1xuICAgICAgICB0aGlzLnR4dDIgPSBudWxsO1xuICAgIH1cbn1cbmV4cG9ydHMuU3ByaXRlU3dhcCA9IFNwcml0ZVN3YXA7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IEJhc2VFeGFtcGxlXzEgPSByZXF1aXJlKFwiLi9CYXNlRXhhbXBsZVwiKTtcbmNvbnN0IFJlc291cmNlTG9hZGVyXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvUmVzb3VyY2VMb2FkZXJcIik7XG5jb25zdCBVUkxSZXF1ZXN0XzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvVVJMUmVxdWVzdFwiKTtcbmNvbnN0IEV2ZW50XzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvRXZlbnRcIik7XG5jb25zdCBUZXh0dXJlXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvVGV4dHVyZVwiKTtcbmNvbnN0IEJhc2VUZXh0dXJlXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvQmFzZVRleHR1cmVcIik7XG5jb25zdCBUaWxpbmdTcHJpdGVfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9UaWxpbmdTcHJpdGVcIik7XG5jbGFzcyBTcHJpdGVUaWxpbmcgZXh0ZW5kcyBCYXNlRXhhbXBsZV8xLkJhc2VFeGFtcGxlIHtcbiAgICBjb25zdHJ1Y3RvcihhcHAsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgc3VwZXIoYXBwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgdGhpcy5oYW5kbGVSb3RhdGVMb2FkZWQgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIHRoaXMudHh0MSA9IG5ldyBUZXh0dXJlXzEuVGV4dHVyZShuZXcgQmFzZVRleHR1cmVfMS5CYXNlVGV4dHVyZSh0aGlzLmxvYWRlci5pbWFnZURhdGEpKTtcbiAgICAgICAgICAgIHRoaXMudGlsaW5nU3ByaXRlID0gbmV3IFRpbGluZ1Nwcml0ZV8xLlRpbGluZ1Nwcml0ZSh0aGlzLnR4dDEsIHRoaXMuc2l6ZXcsIHRoaXMuc2l6ZWgpO1xuICAgICAgICAgICAgdGhpcy5zdGFnZS5hZGRDaGlsZCh0aGlzLnRpbGluZ1Nwcml0ZSk7XG4gICAgICAgICAgICB0aGlzLmNvdW50ID0gMDtcbiAgICAgICAgICAgIHRoaXMuYXBwLnRpY2tlci5hZGQodGhpcy5ydW5FeGFtcGxlKTtcbiAgICAgICAgICAgIHRoaXMuZXhhbXBsZVJlYWR5KCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucnVuRXhhbXBsZSA9IChkZWx0YSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5jb3VudCArPSAwLjAwNTtcbiAgICAgICAgICAgIHRoaXMudGlsaW5nU3ByaXRlLnRpbGVTY2FsZS54ID0gMiArIE1hdGguc2luKHRoaXMuY291bnQpO1xuICAgICAgICAgICAgdGhpcy50aWxpbmdTcHJpdGUudGlsZVNjYWxlLnkgPSAyICsgTWF0aC5jb3ModGhpcy5jb3VudCk7XG4gICAgICAgICAgICB0aGlzLnRpbGluZ1Nwcml0ZS50aWxlUG9zaXRpb24ueCArPSAxO1xuICAgICAgICAgICAgdGhpcy50aWxpbmdTcHJpdGUudGlsZVBvc2l0aW9uLnkgKz0gMTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5sb2FkZXIgPSBuZXcgUmVzb3VyY2VMb2FkZXJfMS5SZXNvdXJjZUxvYWRlcihuZXcgVVJMUmVxdWVzdF8xLlVSTFJlcXVlc3QoXCJleGFtcGxlcy9hc3NldHMvcDIuanBlZ1wiKSk7XG4gICAgICAgIHRoaXMubG9hZGVyLmFkZEV2ZW50TGlzdGVuZXIoRXZlbnRfMS5FdmVudC5DT01QTEVURSwgdGhpcy5oYW5kbGVSb3RhdGVMb2FkZWQpO1xuICAgICAgICB0aGlzLmxvYWRlci5sb2FkKCk7XG4gICAgfVxuICAgIGRlc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyLmRlc3RydWN0b3IoKTtcbiAgICAgICAgdGhpcy5hcHAudGlja2VyLnJlbW92ZSh0aGlzLnJ1bkV4YW1wbGUsIG51bGwpO1xuICAgICAgICB0aGlzLnRpbGluZ1Nwcml0ZS5kZXN0cm95KG51bGwpO1xuICAgICAgICB0aGlzLnRpbGluZ1Nwcml0ZSA9IG51bGw7XG4gICAgICAgIHRoaXMudHh0MS5kZXN0cm95KG51bGwpO1xuICAgICAgICB0aGlzLnR4dDEgPSBudWxsO1xuICAgIH1cbn1cbmV4cG9ydHMuU3ByaXRlVGlsaW5nID0gU3ByaXRlVGlsaW5nO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBCYXNlRXhhbXBsZV8xID0gcmVxdWlyZShcIi4vQmFzZUV4YW1wbGVcIik7XG5jb25zdCBHcmFwaGljc18xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0dyYXBoaWNzXCIpO1xuY29uc3QgTW91c2VFdmVudF8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL01vdXNlRXZlbnRcIik7XG5jb25zdCBUZXh0dXJlXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvVGV4dHVyZVwiKTtcbmNvbnN0IFNwcml0ZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1Nwcml0ZVwiKTtcbmNvbnN0IEJhc2VUZXh0dXJlXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvQmFzZVRleHR1cmVcIik7XG5jbGFzcyBTcHJpdGVWaWRlbyBleHRlbmRzIEJhc2VFeGFtcGxlXzEuQmFzZUV4YW1wbGUge1xuICAgIGNvbnN0cnVjdG9yKGFwcCwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICBzdXBlcihhcHAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICB0aGlzLm9uUGxheVZpZGVvID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICB0aGlzLmJ1dHRvbi5kZXN0cm95KG51bGwpO1xuICAgICAgICAgICAgdGhpcy52aWRlby5wbGF5KCk7XG4gICAgICAgICAgICBjb25zdCB0ZXh0dXJlID0gbmV3IFRleHR1cmVfMS5UZXh0dXJlKG5ldyBCYXNlVGV4dHVyZV8xLkJhc2VUZXh0dXJlKHRoaXMudmlkZW8pKTtcbiAgICAgICAgICAgIGNvbnN0IHZpZGVvU3ByaXRlID0gbmV3IFNwcml0ZV8xLlNwcml0ZSh0ZXh0dXJlKTtcbiAgICAgICAgICAgIHZpZGVvU3ByaXRlLndpZHRoID0gdGhpcy5zaXpldztcbiAgICAgICAgICAgIHZpZGVvU3ByaXRlLmhlaWdodCA9IHRoaXMuc2l6ZWg7XG4gICAgICAgICAgICB0aGlzLnN0YWdlLmFkZENoaWxkKHZpZGVvU3ByaXRlKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5idXR0b24gPSBuZXcgR3JhcGhpY3NfMS5HcmFwaGljcygpXG4gICAgICAgICAgICAuYmVnaW5GaWxsKDB4MCwgMC41KVxuICAgICAgICAgICAgLmRyYXdSb3VuZGVkUmVjdCgwLCAwLCAxMDAsIDEwMCwgMTApXG4gICAgICAgICAgICAuZW5kRmlsbCgpXG4gICAgICAgICAgICAuYmVnaW5GaWxsKDB4ZmZmZmZmKVxuICAgICAgICAgICAgLm1vdmVUbygzNiwgMzApXG4gICAgICAgICAgICAubGluZVRvKDM2LCA3MClcbiAgICAgICAgICAgIC5saW5lVG8oNzAsIDUwKTtcbiAgICAgICAgdGhpcy5idXR0b24ueCA9ICh0aGlzLnNpemV3IC0gdGhpcy5idXR0b24ud2lkdGgpIC8gMjtcbiAgICAgICAgdGhpcy5idXR0b24ueSA9ICh0aGlzLnNpemVoIC0gdGhpcy5idXR0b24uaGVpZ2h0KSAvIDI7XG4gICAgICAgIHRoaXMuYnV0dG9uLmludGVyYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5idXR0b24uYnV0dG9uTW9kZSA9IHRydWU7XG4gICAgICAgIHRoaXMuc3RhZ2UuYWRkQ2hpbGQodGhpcy5idXR0b24pO1xuICAgICAgICB0aGlzLnZpZGVvID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInZpZGVvXCIpO1xuICAgICAgICB0aGlzLnZpZGVvWyd0eXBlJ10gPSBcInZpZGVvL21wNFwiO1xuICAgICAgICB0aGlzLnZpZGVvLnNyYyA9IFwiZXhhbXBsZXMvYXNzZXRzL3ZpZGVvLm1wNFwiO1xuICAgICAgICB0aGlzLnZpZGVvLmFkZEV2ZW50TGlzdGVuZXIoJ2NhbnBsYXknLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50LlBPSU5URVJfVEFQLCB0aGlzLm9uUGxheVZpZGVvKTtcbiAgICAgICAgICAgIHRoaXMuZXhhbXBsZVJlYWR5KCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBkZXN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlci5kZXN0cnVjdG9yKCk7XG4gICAgICAgIHRoaXMudmlkZW8gPSBudWxsO1xuICAgIH1cbn1cbmV4cG9ydHMuU3ByaXRlVmlkZW8gPSBTcHJpdGVWaWRlbztcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgQmFzZUV4YW1wbGVfMSA9IHJlcXVpcmUoXCIuL0Jhc2VFeGFtcGxlXCIpO1xuY29uc3QgVVJMTG9hZGVyXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvVVJMTG9hZGVyXCIpO1xuY29uc3QgUmVzb3VyY2VMb2FkZXJfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9SZXNvdXJjZUxvYWRlclwiKTtcbmNvbnN0IFRleHR1cmVfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9UZXh0dXJlXCIpO1xuY29uc3QgRXZlbnRfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9FdmVudFwiKTtcbmNvbnN0IFVSTFJlcXVlc3RfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9VUkxSZXF1ZXN0XCIpO1xuY29uc3QgQmFzZVRleHR1cmVfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9CYXNlVGV4dHVyZVwiKTtcbmNvbnN0IFNwcml0ZXNoZWV0XzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvU3ByaXRlc2hlZXRcIik7XG5jb25zdCBBbmltYXRlZFNwcml0ZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0FuaW1hdGVkU3ByaXRlXCIpO1xuY2xhc3MgU3ByaXRlamV0IGV4dGVuZHMgQmFzZUV4YW1wbGVfMS5CYXNlRXhhbXBsZSB7XG4gICAgY29uc3RydWN0b3IoYXBwLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHN1cGVyKGFwcCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIHRoaXMub25BbmltYXRpb25QYXJzZWQgPSAodGV4dHVyZXMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGZyYW1lcyA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAzMDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsID0gaSA8IDEwID8gYDAke2l9YCA6IGk7XG4gICAgICAgICAgICAgICAgZnJhbWVzLnB1c2godGV4dHVyZXNbYHJvbGxTZXF1ZW5jZTAwJHt2YWx9LnBuZ2BdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYW5pbSA9IG5ldyBBbmltYXRlZFNwcml0ZV8xLkFuaW1hdGVkU3ByaXRlKGZyYW1lcyk7XG4gICAgICAgICAgICB0aGlzLmFuaW0ueCA9IHRoaXMuc2l6ZXcgLyAyO1xuICAgICAgICAgICAgdGhpcy5hbmltLnkgPSB0aGlzLnNpemVoIC8gMjtcbiAgICAgICAgICAgIHRoaXMuYW5pbS5hbmNob3Iuc2V0KDAuNSk7XG4gICAgICAgICAgICB0aGlzLmFuaW0uYW5pbWF0aW9uU3BlZWQgPSAwLjU7XG4gICAgICAgICAgICB0aGlzLmFuaW0ucGxheSgpO1xuICAgICAgICAgICAgdGhpcy5zdGFnZS5hZGRDaGlsZCh0aGlzLmFuaW0pO1xuICAgICAgICAgICAgdGhpcy5hcHAudGlja2VyLmFkZCh0aGlzLnJ1bkV4YW1wbGUpO1xuICAgICAgICAgICAgdGhpcy5leGFtcGxlUmVhZHkoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5ydW5FeGFtcGxlID0gKGRlbHRhKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmFuaW0ucm90YXRpb24gKz0gMC4wMTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVKc29uTG9hZGVkID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICB0aGlzLmpzb25kYXRhID0gSlNPTi5wYXJzZSh0aGlzLnVybGxvYWRlci5kYXRhKTtcbiAgICAgICAgICAgIHRoaXMubG9hZGVyID0gbmV3IFJlc291cmNlTG9hZGVyXzEuUmVzb3VyY2VMb2FkZXIobmV3IFVSTFJlcXVlc3RfMS5VUkxSZXF1ZXN0KFwiZXhhbXBsZXMvYXNzZXRzL3Nwcml0ZXNoZWV0L2ZpZ2h0ZXIucG5nXCIpKTtcbiAgICAgICAgICAgIHRoaXMubG9hZGVyLmFkZEV2ZW50TGlzdGVuZXIoRXZlbnRfMS5FdmVudC5DT01QTEVURSwgdGhpcy5oYW5kbGVSb3RhdGVMb2FkZWQpO1xuICAgICAgICAgICAgdGhpcy5sb2FkZXIubG9hZCgpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZVJvdGF0ZUxvYWRlZCA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgdGhpcy50eHQgPSBuZXcgVGV4dHVyZV8xLlRleHR1cmUobmV3IEJhc2VUZXh0dXJlXzEuQmFzZVRleHR1cmUodGhpcy5sb2FkZXIuaW1hZ2VEYXRhKSk7XG4gICAgICAgICAgICBsZXQgc3ByaXRlc2hlZXQgPSBuZXcgU3ByaXRlc2hlZXRfMS5TcHJpdGVzaGVldCh0aGlzLnR4dCwgdGhpcy5qc29uZGF0YSk7XG4gICAgICAgICAgICBzcHJpdGVzaGVldC5wYXJzZSh0aGlzLm9uQW5pbWF0aW9uUGFyc2VkKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5iYWNrQ29sb3IgPSAweDk2OTY5NjtcbiAgICAgICAgdGhpcy51cmxsb2FkZXIgPSBuZXcgVVJMTG9hZGVyXzEuVVJMTG9hZGVyKCk7XG4gICAgICAgIHRoaXMudXJsbG9hZGVyLmFkZEV2ZW50TGlzdGVuZXIoRXZlbnRfMS5FdmVudC5DT01QTEVURSwgdGhpcy5oYW5kbGVKc29uTG9hZGVkKTtcbiAgICAgICAgdGhpcy51cmxsb2FkZXIubG9hZChuZXcgVVJMUmVxdWVzdF8xLlVSTFJlcXVlc3QoXCJleGFtcGxlcy9hc3NldHMvc3ByaXRlc2hlZXQvZmlnaHRlci5qc29uXCIpKTtcbiAgICB9XG4gICAgZGVzdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIuZGVzdHJ1Y3RvcigpO1xuICAgICAgICB0aGlzLmFwcC50aWNrZXIucmVtb3ZlKHRoaXMucnVuRXhhbXBsZSwgbnVsbCk7XG4gICAgICAgIGlmICh0aGlzLmFuaW0pIHtcbiAgICAgICAgICAgIHRoaXMuYW5pbS5kZXN0cnVjdG9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hbmltID0gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMudHh0KSB7XG4gICAgICAgICAgICB0aGlzLnR4dC5kZXN0cnVjdG9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50eHQgPSBudWxsO1xuICAgICAgICB0aGlzLmpzb25kYXRhID0gbnVsbDtcbiAgICB9XG59XG5leHBvcnRzLlNwcml0ZWpldCA9IFNwcml0ZWpldDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgQmFzZUV4YW1wbGVfMSA9IHJlcXVpcmUoXCIuL0Jhc2VFeGFtcGxlXCIpO1xuY29uc3QgVGV4dF8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1RleHRcIik7XG5jb25zdCBUZXh0U3R5bGVfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9UZXh0U3R5bGVcIik7XG5jbGFzcyBUZXh0QmFzZSBleHRlbmRzIEJhc2VFeGFtcGxlXzEuQmFzZUV4YW1wbGUge1xuICAgIGNvbnN0cnVjdG9yKGFwcCwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICBzdXBlcihhcHAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICBjb25zdCBiYXNpY1RleHQgPSBuZXcgVGV4dF8xLlRleHQoJ0Jhc2ljIHRleHQgaW4gcGl4aScpO1xuICAgICAgICBiYXNpY1RleHQueCA9IDUwO1xuICAgICAgICBiYXNpY1RleHQueSA9IDEwMDtcbiAgICAgICAgdGhpcy5zdGFnZS5hZGRDaGlsZChiYXNpY1RleHQpO1xuICAgICAgICBjb25zdCBzdHlsZSA9IG5ldyBUZXh0U3R5bGVfMS5UZXh0U3R5bGUoe1xuICAgICAgICAgICAgZm9udEZhbWlseTogJ0FyaWFsJyxcbiAgICAgICAgICAgIGZvbnRTaXplOiAzNixcbiAgICAgICAgICAgIGZvbnRTdHlsZTogJ2l0YWxpYycsXG4gICAgICAgICAgICBmb250V2VpZ2h0OiAnYm9sZCcsXG4gICAgICAgICAgICBmaWxsOiBbJyNmZmZmZmYnLCAnIzAwZmY5OSddLFxuICAgICAgICAgICAgc3Ryb2tlOiAnIzRhMTg1MCcsXG4gICAgICAgICAgICBzdHJva2VUaGlja25lc3M6IDUsXG4gICAgICAgICAgICBkcm9wU2hhZG93OiB0cnVlLFxuICAgICAgICAgICAgZHJvcFNoYWRvd0NvbG9yOiAnIzAwMDAwMCcsXG4gICAgICAgICAgICBkcm9wU2hhZG93Qmx1cjogNCxcbiAgICAgICAgICAgIGRyb3BTaGFkb3dBbmdsZTogTWF0aC5QSSAvIDYsXG4gICAgICAgICAgICBkcm9wU2hhZG93RGlzdGFuY2U6IDYsXG4gICAgICAgICAgICB3b3JkV3JhcDogdHJ1ZSxcbiAgICAgICAgICAgIHdvcmRXcmFwV2lkdGg6IDQ0MCxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJpY2hUZXh0ID0gbmV3IFRleHRfMS5UZXh0KCdSaWNoIHRleHQgd2l0aCBhIGxvdCBvZiBvcHRpb25zIGFuZCBhY3Jvc3MgbXVsdGlwbGUgbGluZXMnLCBzdHlsZSk7XG4gICAgICAgIHJpY2hUZXh0LnggPSA1MDtcbiAgICAgICAgcmljaFRleHQueSA9IDI1MDtcbiAgICAgICAgdGhpcy5zdGFnZS5hZGRDaGlsZChyaWNoVGV4dCk7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5leGFtcGxlUmVhZHkoKTtcbiAgICAgICAgfSwgMTAwMCk7XG4gICAgfVxufVxuZXhwb3J0cy5UZXh0QmFzZSA9IFRleHRCYXNlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBCYXNlRXhhbXBsZV8xID0gcmVxdWlyZShcIi4vQmFzZUV4YW1wbGVcIik7XG5jb25zdCBGb250TWFuYWdlcl8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0ZvbnRNYW5hZ2VyXCIpO1xuY29uc3QgRXZlbnRfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9FdmVudFwiKTtcbmNvbnN0IEJpdG1hcFRleHRfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9CaXRtYXBUZXh0XCIpO1xuY2xhc3MgVGV4dEJpdG1hcCBleHRlbmRzIEJhc2VFeGFtcGxlXzEuQmFzZUV4YW1wbGUge1xuICAgIGNvbnN0cnVjdG9yKGFwcCwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICBzdXBlcihhcHAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICB0aGlzLmhhbmRsZUZvbnRMb2FkZWQgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGJpdG1hcEZvbnRUZXh0ID0gbmV3IEJpdG1hcFRleHRfMS5CaXRtYXBUZXh0KCdiaXRtYXAgZm9udHMgYXJlIHN1cHBvcnRlZCFcXG5Xb28geWF5IScpO1xuICAgICAgICAgICAgYml0bWFwRm9udFRleHQuZm9udFNpemUgPSA1NTtcbiAgICAgICAgICAgIGJpdG1hcEZvbnRUZXh0LmZvbnQgPSBcIkRlc3lyZWxcIjtcbiAgICAgICAgICAgIGJpdG1hcEZvbnRUZXh0LmFsaWduID0gJ2xlZnQnO1xuICAgICAgICAgICAgYml0bWFwRm9udFRleHQueCA9IDUwO1xuICAgICAgICAgICAgYml0bWFwRm9udFRleHQueSA9IDIwMDtcbiAgICAgICAgICAgIHRoaXMuc3RhZ2UuYWRkQ2hpbGQoYml0bWFwRm9udFRleHQpO1xuICAgICAgICAgICAgdGhpcy5leGFtcGxlUmVhZHkoKTtcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IGxvYWRlciA9IEZvbnRNYW5hZ2VyXzEuRm9udE1hbmFnZXIubG9hZEJpdG1hcEZvbnQoXCJleGFtcGxlcy9hc3NldHMvYml0bWFwLWZvbnQvZGVzeXJlbC54bWxcIik7XG4gICAgICAgIGxvYWRlci5hZGRFdmVudExpc3RlbmVyKEV2ZW50XzEuRXZlbnQuQ09NUExFVEUsIHRoaXMuaGFuZGxlRm9udExvYWRlZCk7XG4gICAgfVxufVxuZXhwb3J0cy5UZXh0Qml0bWFwID0gVGV4dEJpdG1hcDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgQmFzZUV4YW1wbGVfMSA9IHJlcXVpcmUoXCIuL0Jhc2VFeGFtcGxlXCIpO1xuY29uc3QgRm9udE1hbmFnZXJfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9Gb250TWFuYWdlclwiKTtcbmNvbnN0IFRleHRfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9UZXh0XCIpO1xuY2xhc3MgVGV4dFdlYkZvbnQgZXh0ZW5kcyBCYXNlRXhhbXBsZV8xLkJhc2VFeGFtcGxlIHtcbiAgICBjb25zdHJ1Y3RvcihhcHAsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgc3VwZXIoYXBwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgdGhpcy5oYW5kbGVXZWJGb250TG9hZGVkID0gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdGV4dFNhbXBsZSA9IG5ldyBUZXh0XzEuVGV4dCgnUGl4aS5qcyB0ZXh0IHVzaW5nIHRoZVxcbmN1c3RvbSBcIlNuaXBwZXRcIiBXZWJmb250Jywge1xuICAgICAgICAgICAgICAgIGZvbnRGYW1pbHk6ICdTbmlwcGV0JyxcbiAgICAgICAgICAgICAgICBmb250U2l6ZTogNTAsXG4gICAgICAgICAgICAgICAgZmlsbDogJ3doaXRlJyxcbiAgICAgICAgICAgICAgICBhbGlnbjogJ2xlZnQnLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0ZXh0U2FtcGxlLnBvc2l0aW9uLnNldCg1MCwgMjAwKTtcbiAgICAgICAgICAgIHRoaXMuc3RhZ2UuYWRkQ2hpbGQodGV4dFNhbXBsZSk7XG4gICAgICAgICAgICB0aGlzLmV4YW1wbGVSZWFkeSgpO1xuICAgICAgICB9O1xuICAgICAgICBGb250TWFuYWdlcl8xLkZvbnRNYW5hZ2VyLm9uV2ViRm9udGxvYWRlZCA9IHRoaXMuaGFuZGxlV2ViRm9udExvYWRlZDtcbiAgICAgICAgRm9udE1hbmFnZXJfMS5Gb250TWFuYWdlci5XZWJGb250Q29uZmlnID0ge1xuICAgICAgICAgICAgZ29vZ2xlOiB7XG4gICAgICAgICAgICAgICAgZmFtaWxpZXM6IFsnU25pcHBldCcsICdBcnZvOjcwMGl0YWxpYycsICdQb2Rrb3ZhOjcwMCddLFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuVGV4dFdlYkZvbnQgPSBUZXh0V2ViRm9udDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgQmFzZUV4YW1wbGVfMSA9IHJlcXVpcmUoXCIuL0Jhc2VFeGFtcGxlXCIpO1xuY29uc3QgUmVuZGVyVGV4dHVyZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1JlbmRlclRleHR1cmVcIik7XG5jb25zdCBTcHJpdGVfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9TcHJpdGVcIik7XG5jb25zdCBDb250YWluZXJfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9Db250YWluZXJcIik7XG5jb25zdCBSZXNvdXJjZUxvYWRlcl8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1Jlc291cmNlTG9hZGVyXCIpO1xuY29uc3QgVVJMUmVxdWVzdF8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1VSTFJlcXVlc3RcIik7XG5jb25zdCBFdmVudF8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0V2ZW50XCIpO1xuY29uc3QgVGV4dHVyZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1RleHR1cmVcIik7XG5jb25zdCBCYXNlVGV4dHVyZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0Jhc2VUZXh0dXJlXCIpO1xuY2xhc3MgVGV4dHVyZUFkdmFuY2VkIGV4dGVuZHMgQmFzZUV4YW1wbGVfMS5CYXNlRXhhbXBsZSB7XG4gICAgY29uc3RydWN0b3IoYXBwLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHN1cGVyKGFwcCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIHRoaXMucnVuRXhhbXBsZSA9IChkZWx0YSkgPT4ge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLml0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaXRlbSA9IHRoaXMuaXRlbXNbaV07XG4gICAgICAgICAgICAgICAgaXRlbS5yb3RhdGlvbiArPSAwLjE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNvdW50ICs9IDAuMDE7XG4gICAgICAgICAgICBjb25zdCB0ZW1wID0gdGhpcy5yZW5kZXJUZXh0dXJlO1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJUZXh0dXJlID0gdGhpcy5yZW5kZXJUZXh0dXJlMjtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyVGV4dHVyZTIgPSB0ZW1wO1xuICAgICAgICAgICAgdGhpcy5vdXRwdXRTcHJpdGUudGV4dHVyZSA9IHRoaXMucmVuZGVyVGV4dHVyZTtcbiAgICAgICAgICAgIHRoaXMuc3R1ZmZDb250YWluZXIucm90YXRpb24gLT0gMC4wMTtcbiAgICAgICAgICAgIHRoaXMub3V0cHV0U3ByaXRlLnNjYWxlLnNldCgxICsgTWF0aC5zaW4odGhpcy5jb3VudCkgKiAwLjIpO1xuICAgICAgICAgICAgdGhpcy5hcHAucmVuZGVyZXIucmVuZGVyKHRoaXMuc3RhZ2UsIHRoaXMucmVuZGVyVGV4dHVyZTIsIGZhbHNlKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVSZXNvdXJjZUxvYWRlZCA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgbGV0IHR4dCA9IG5ldyBUZXh0dXJlXzEuVGV4dHVyZShuZXcgQmFzZVRleHR1cmVfMS5CYXNlVGV4dHVyZSh0aGlzLmxvYWRlci5pbWFnZURhdGEpKTtcbiAgICAgICAgICAgIHRoaXMuZnJ1aXRzLnB1c2godHh0KTtcbiAgICAgICAgICAgIHRoaXMubG9hZEFzc2V0cygpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnJlbmRlclRleHR1cmUgPSBSZW5kZXJUZXh0dXJlXzEuUmVuZGVyVGV4dHVyZS5jcmVhdGUodGhpcy5zaXpldywgdGhpcy5zaXplaCk7XG4gICAgICAgIHRoaXMucmVuZGVyVGV4dHVyZTIgPSBSZW5kZXJUZXh0dXJlXzEuUmVuZGVyVGV4dHVyZS5jcmVhdGUodGhpcy5zaXpldywgdGhpcy5zaXplaCk7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRUZXh0dXJlID0gdGhpcy5yZW5kZXJUZXh0dXJlO1xuICAgICAgICB0aGlzLm91dHB1dFNwcml0ZSA9IG5ldyBTcHJpdGVfMS5TcHJpdGUoY3VycmVudFRleHR1cmUpO1xuICAgICAgICB0aGlzLm91dHB1dFNwcml0ZS54ID0gNDAwO1xuICAgICAgICB0aGlzLm91dHB1dFNwcml0ZS55ID0gMzAwO1xuICAgICAgICB0aGlzLm91dHB1dFNwcml0ZS5hbmNob3Iuc2V0KDAuNSk7XG4gICAgICAgIHRoaXMuc3RhZ2UuYWRkQ2hpbGQodGhpcy5vdXRwdXRTcHJpdGUpO1xuICAgICAgICB0aGlzLnN0dWZmQ29udGFpbmVyID0gbmV3IENvbnRhaW5lcl8xLkNvbnRhaW5lcigpO1xuICAgICAgICB0aGlzLnN0dWZmQ29udGFpbmVyLnggPSA0MDA7XG4gICAgICAgIHRoaXMuc3R1ZmZDb250YWluZXIueSA9IDMwMDtcbiAgICAgICAgdGhpcy5zdGFnZS5hZGRDaGlsZCh0aGlzLnN0dWZmQ29udGFpbmVyKTtcbiAgICAgICAgdGhpcy5mcnVpdHNsaW5rcyA9IFtcbiAgICAgICAgICAgICdleGFtcGxlcy9hc3NldHMvcnRfb2JqZWN0XzAxLnBuZycsXG4gICAgICAgICAgICAnZXhhbXBsZXMvYXNzZXRzL3J0X29iamVjdF8wMi5wbmcnLFxuICAgICAgICAgICAgJ2V4YW1wbGVzL2Fzc2V0cy9ydF9vYmplY3RfMDMucG5nJyxcbiAgICAgICAgICAgICdleGFtcGxlcy9hc3NldHMvcnRfb2JqZWN0XzA0LnBuZycsXG4gICAgICAgICAgICAnZXhhbXBsZXMvYXNzZXRzL3J0X29iamVjdF8wNS5wbmcnLFxuICAgICAgICAgICAgJ2V4YW1wbGVzL2Fzc2V0cy9ydF9vYmplY3RfMDYucG5nJyxcbiAgICAgICAgICAgICdleGFtcGxlcy9hc3NldHMvcnRfb2JqZWN0XzA3LnBuZycsXG4gICAgICAgICAgICAnZXhhbXBsZXMvYXNzZXRzL3J0X29iamVjdF8wOC5wbmcnLFxuICAgICAgICBdO1xuICAgICAgICB0aGlzLmZydWl0cyA9IFtdO1xuICAgICAgICB0aGlzLmxvYWRBc3NldHMoKTtcbiAgICB9XG4gICAgaW5pdCgpIHtcbiAgICAgICAgdGhpcy5pdGVtcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDIwOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSBuZXcgU3ByaXRlXzEuU3ByaXRlKHRoaXMuZnJ1aXRzW2kgJSB0aGlzLmZydWl0cy5sZW5ndGhdKTtcbiAgICAgICAgICAgIGl0ZW0ueCA9IE1hdGgucmFuZG9tKCkgKiA0MDAgLSAyMDA7XG4gICAgICAgICAgICBpdGVtLnkgPSBNYXRoLnJhbmRvbSgpICogNDAwIC0gMjAwO1xuICAgICAgICAgICAgaXRlbS5hbmNob3Iuc2V0KDAuNSk7XG4gICAgICAgICAgICB0aGlzLnN0dWZmQ29udGFpbmVyLmFkZENoaWxkKGl0ZW0pO1xuICAgICAgICAgICAgdGhpcy5pdGVtcy5wdXNoKGl0ZW0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY291bnQgPSAwO1xuICAgICAgICB0aGlzLmFwcC50aWNrZXIuYWRkKHRoaXMucnVuRXhhbXBsZSk7XG4gICAgICAgIHRoaXMuZXhhbXBsZVJlYWR5KCk7XG4gICAgfVxuICAgIGxvYWRBc3NldHMoKSB7XG4gICAgICAgIGlmICghdGhpcy5mcnVpdHNsaW5rcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuaW5pdCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubG9hZGVyID0gbmV3IFJlc291cmNlTG9hZGVyXzEuUmVzb3VyY2VMb2FkZXIobmV3IFVSTFJlcXVlc3RfMS5VUkxSZXF1ZXN0KHRoaXMuZnJ1aXRzbGlua3MucG9wKCkpKTtcbiAgICAgICAgdGhpcy5sb2FkZXIuYWRkRXZlbnRMaXN0ZW5lcihFdmVudF8xLkV2ZW50LkNPTVBMRVRFLCB0aGlzLmhhbmRsZVJlc291cmNlTG9hZGVkKTtcbiAgICAgICAgdGhpcy5sb2FkZXIubG9hZCgpO1xuICAgIH1cbiAgICBkZXN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlci5kZXN0cnVjdG9yKCk7XG4gICAgICAgIHRoaXMuYXBwLnRpY2tlci5yZW1vdmUodGhpcy5ydW5FeGFtcGxlLCBudWxsKTtcbiAgICAgICAgdGhpcy5zdHVmZkNvbnRhaW5lci5kZXN0cm95KG51bGwpO1xuICAgICAgICB0aGlzLnN0dWZmQ29udGFpbmVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5vdXRwdXRTcHJpdGUuZGVzdHJveShudWxsKTtcbiAgICAgICAgdGhpcy5vdXRwdXRTcHJpdGUgPSBudWxsO1xuICAgICAgICB0aGlzLml0ZW1zID0gbnVsbDtcbiAgICAgICAgdGhpcy5mcnVpdHNsaW5rcyA9IG51bGw7XG4gICAgICAgIHRoaXMuZnJ1aXRzID0gbnVsbDtcbiAgICB9XG59XG5leHBvcnRzLlRleHR1cmVBZHZhbmNlZCA9IFRleHR1cmVBZHZhbmNlZDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgQmFzZUV4YW1wbGVfMSA9IHJlcXVpcmUoXCIuL0Jhc2VFeGFtcGxlXCIpO1xuY29uc3QgVGV4dHVyZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1RleHR1cmVcIik7XG5jb25zdCBTcHJpdGVfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9TcHJpdGVcIik7XG5jbGFzcyBUZXh0dXJlR3JhZGllbnRCYXNpYyBleHRlbmRzIEJhc2VFeGFtcGxlXzEuQmFzZUV4YW1wbGUge1xuICAgIGNvbnN0cnVjdG9yKGFwcCwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICBzdXBlcihhcHAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICBjb25zdCBncmFkVGV4dHVyZSA9IHRoaXMuY3JlYXRlR3JhZFRleHR1cmUoKTtcbiAgICAgICAgY29uc3Qgc3ByaXRlID0gbmV3IFNwcml0ZV8xLlNwcml0ZShncmFkVGV4dHVyZSk7XG4gICAgICAgIHNwcml0ZS5wb3NpdGlvbi5zZXQoMTAwLCAxMDApO1xuICAgICAgICBzcHJpdGUucm90YXRpb24gPSBNYXRoLlBJIC8gODtcbiAgICAgICAgc3ByaXRlLndpZHRoID0gNTAwO1xuICAgICAgICBzcHJpdGUuaGVpZ2h0ID0gNTA7XG4gICAgICAgIHRoaXMuc3RhZ2UuYWRkQ2hpbGQoc3ByaXRlKTtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmV4YW1wbGVSZWFkeSgpO1xuICAgICAgICB9LCAxMDAwKTtcbiAgICB9XG4gICAgY3JlYXRlR3JhZFRleHR1cmUoKSB7XG4gICAgICAgIGNvbnN0IHF1YWxpdHkgPSAyNTY7XG4gICAgICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICBjYW52YXMud2lkdGggPSBxdWFsaXR5O1xuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gMTtcbiAgICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIGNvbnN0IGdyZCA9IGN0eC5jcmVhdGVMaW5lYXJHcmFkaWVudCgwLCAwLCBxdWFsaXR5LCAwKTtcbiAgICAgICAgZ3JkLmFkZENvbG9yU3RvcCgwLCAncmdiYSgyNTUsIDI1NSwgMjU1LCAwLjApJyk7XG4gICAgICAgIGdyZC5hZGRDb2xvclN0b3AoMC4zLCAnY3lhbicpO1xuICAgICAgICBncmQuYWRkQ29sb3JTdG9wKDAuNywgJ3JlZCcpO1xuICAgICAgICBncmQuYWRkQ29sb3JTdG9wKDEsICdncmVlbicpO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gZ3JkO1xuICAgICAgICBjdHguZmlsbFJlY3QoMCwgMCwgcXVhbGl0eSwgMSk7XG4gICAgICAgIHJldHVybiBUZXh0dXJlXzEuVGV4dHVyZS5mcm9tKGNhbnZhcyk7XG4gICAgfVxufVxuZXhwb3J0cy5UZXh0dXJlR3JhZGllbnRCYXNpYyA9IFRleHR1cmVHcmFkaWVudEJhc2ljO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBCYXNlRXhhbXBsZV8xID0gcmVxdWlyZShcIi4vQmFzZUV4YW1wbGVcIik7XG5jb25zdCBSZXNvdXJjZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1Jlc291cmNlXCIpO1xuY29uc3QgQmFzZVRleHR1cmVfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9CYXNlVGV4dHVyZVwiKTtcbmNvbnN0IFRleHR1cmVfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9UZXh0dXJlXCIpO1xuY29uc3QgU3ByaXRlXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvU3ByaXRlXCIpO1xuY2xhc3MgVGV4dHVyZUdyYWRpZW50UmVzb3VyY2UgZXh0ZW5kcyBCYXNlRXhhbXBsZV8xLkJhc2VFeGFtcGxlIHtcbiAgICBjb25zdHJ1Y3RvcihhcHAsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgc3VwZXIoYXBwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgY29uc3QgZ3JhZEJhc2VUZXh0dXJlID0gbmV3IEJhc2VUZXh0dXJlXzEuQmFzZVRleHR1cmUobmV3IEdyYWRpZW50UmVzb3VyY2UoKSk7XG4gICAgICAgIGdyYWRCYXNlVGV4dHVyZS5zZXRTaXplKDUwMCwgNTApO1xuICAgICAgICBjb25zdCBncmFkVGV4dHVyZSA9IG5ldyBUZXh0dXJlXzEuVGV4dHVyZShncmFkQmFzZVRleHR1cmUpO1xuICAgICAgICBjb25zdCBzcHJpdGUgPSBuZXcgU3ByaXRlXzEuU3ByaXRlKGdyYWRUZXh0dXJlKTtcbiAgICAgICAgc3ByaXRlLnBvc2l0aW9uLnNldCgxMDAsIDEwMCk7XG4gICAgICAgIHNwcml0ZS5yb3RhdGlvbiA9IE1hdGguUEkgLyA4O1xuICAgICAgICB0aGlzLnN0YWdlLmFkZENoaWxkKHNwcml0ZSk7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5leGFtcGxlUmVhZHkoKTtcbiAgICAgICAgfSwgMTAwMCk7XG4gICAgfVxufVxuZXhwb3J0cy5UZXh0dXJlR3JhZGllbnRSZXNvdXJjZSA9IFRleHR1cmVHcmFkaWVudFJlc291cmNlO1xuY2xhc3MgR3JhZGllbnRSZXNvdXJjZSBleHRlbmRzIFJlc291cmNlXzEuUmVzb3VyY2Uge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigyNTYsIDEwMCk7XG4gICAgICAgIHRoaXMuY2FuVXBsb2FkID0gdHJ1ZTtcbiAgICB9XG4gICAgdXBsb2FkKHJlbmRlcmVyLCBiYXNlVGV4dHVyZSwgZ2xUZXh0dXJlKSB7XG4gICAgICAgIGNvbnN0IHsgd2lkdGggfSA9IHRoaXM7IC8vIGRlZmF1bHQgc2l6ZSBvciBmcm9tIGJhc2VUZXh0dXJlP1xuICAgICAgICBjb25zdCB7IGhlaWdodCB9ID0gdGhpczsgLy8geW91ciBjaG9pY2UuXG4gICAgICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICB0aGlzLnNvdXJjZSA9IGNhbnZhcztcbiAgICAgICAgdGhpcy5zb3VyY2Uud2lkdGggPSB3aWR0aDtcbiAgICAgICAgdGhpcy5zb3VyY2UuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICBjb25zdCBjdHggPSB0aGlzLnNvdXJjZS5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICBjb25zdCBncmQgPSBjdHguY3JlYXRlTGluZWFyR3JhZGllbnQoMCwgMCwgd2lkdGgsIDApO1xuICAgICAgICBncmQuYWRkQ29sb3JTdG9wKDAsICdyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMCknKTtcbiAgICAgICAgZ3JkLmFkZENvbG9yU3RvcCgwLjMsICdjeWFuJyk7XG4gICAgICAgIGdyZC5hZGRDb2xvclN0b3AoMC43LCAncmVkJyk7XG4gICAgICAgIGdyZC5hZGRDb2xvclN0b3AoMSwgJ2dyZWVuJyk7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBncmQ7XG4gICAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgZ2xUZXh0dXJlLndpZHRoID0gd2lkdGg7XG4gICAgICAgIGdsVGV4dHVyZS5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIGNvbnN0IHsgZ2wgfSA9IHJlbmRlcmVyO1xuICAgICAgICBnbC5waXhlbFN0b3JlaShnbC5VTlBBQ0tfUFJFTVVMVElQTFlfQUxQSEFfV0VCR0wsIGJhc2VUZXh0dXJlLnByZW11bHRpcGx5QWxwaGEpO1xuICAgICAgICBnbC50ZXhJbWFnZTJEKGJhc2VUZXh0dXJlLnRhcmdldCwgMCwgYmFzZVRleHR1cmUuZm9ybWF0LCBiYXNlVGV4dHVyZS5mb3JtYXQsIGJhc2VUZXh0dXJlLnR5cGUsIHRoaXMuc291cmNlKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBCYXNlRXhhbXBsZV8xID0gcmVxdWlyZShcIi4vQmFzZUV4YW1wbGVcIik7XG5jb25zdCBSZXNvdXJjZUxvYWRlcl8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1Jlc291cmNlTG9hZGVyXCIpO1xuY29uc3QgVVJMUmVxdWVzdF8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1VSTFJlcXVlc3RcIik7XG5jb25zdCBFdmVudF8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0V2ZW50XCIpO1xuY29uc3QgVGV4dHVyZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1RleHR1cmVcIik7XG5jb25zdCBCYXNlVGV4dHVyZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0Jhc2VUZXh0dXJlXCIpO1xuY29uc3QgQ29udGFpbmVyXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvQ29udGFpbmVyXCIpO1xuY29uc3QgU3ByaXRlXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvU3ByaXRlXCIpO1xuY29uc3QgV2ViR0xTZXR0aW5nc18xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1dlYkdMU2V0dGluZ3NcIik7XG5jb25zdCBCYXNlUmVuZGVyVGV4dHVyZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0Jhc2VSZW5kZXJUZXh0dXJlXCIpO1xuY29uc3QgUmVuZGVyVGV4dHVyZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1JlbmRlclRleHR1cmVcIik7XG5jbGFzcyBUZXh0dXJlUmVuZGVyIGV4dGVuZHMgQmFzZUV4YW1wbGVfMS5CYXNlRXhhbXBsZSB7XG4gICAgY29uc3RydWN0b3IoYXBwLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHN1cGVyKGFwcCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIHRoaXMuaGFuZGxlUmVzb3VyY2VMb2FkZWQgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGxldCB0eHQgPSBuZXcgVGV4dHVyZV8xLlRleHR1cmUobmV3IEJhc2VUZXh0dXJlXzEuQmFzZVRleHR1cmUodGhpcy5sb2FkZXIuaW1hZ2VEYXRhKSk7XG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lciA9IG5ldyBDb250YWluZXJfMS5Db250YWluZXIoKTtcbiAgICAgICAgICAgIHRoaXMuc3RhZ2UuYWRkQ2hpbGQodGhpcy5jb250YWluZXIpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAyNTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYnVubnkgPSBuZXcgU3ByaXRlXzEuU3ByaXRlKHR4dCk7XG4gICAgICAgICAgICAgICAgYnVubnkueCA9IChpICUgNSkgKiAzMDtcbiAgICAgICAgICAgICAgICBidW5ueS55ID0gTWF0aC5mbG9vcihpIC8gNSkgKiAzMDtcbiAgICAgICAgICAgICAgICBidW5ueS5yb3RhdGlvbiA9IE1hdGgucmFuZG9tKCkgKiAoTWF0aC5QSSAqIDIpO1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLmFkZENoaWxkKGJ1bm55KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGJydCA9IG5ldyBCYXNlUmVuZGVyVGV4dHVyZV8xLkJhc2VSZW5kZXJUZXh0dXJlKDMwMCwgMzAwLCBXZWJHTFNldHRpbmdzXzEuV2ViR0xTZXR0aW5ncy5TQ0FMRV9NT0RFUy5MSU5FQVIsIDEpO1xuICAgICAgICAgICAgdGhpcy5ydCA9IG5ldyBSZW5kZXJUZXh0dXJlXzEuUmVuZGVyVGV4dHVyZShicnQpO1xuICAgICAgICAgICAgY29uc3Qgc3ByaXRlID0gbmV3IFNwcml0ZV8xLlNwcml0ZSh0aGlzLnJ0KTtcbiAgICAgICAgICAgIHNwcml0ZS54ID0gNDUwO1xuICAgICAgICAgICAgc3ByaXRlLnkgPSA2MDtcbiAgICAgICAgICAgIHRoaXMuc3RhZ2UuYWRkQ2hpbGQoc3ByaXRlKTtcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLnggPSAxMDA7XG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lci55ID0gNjA7XG4gICAgICAgICAgICB0aGlzLmFwcC50aWNrZXIuYWRkKHRoaXMucnVuRXhhbXBsZSk7XG4gICAgICAgICAgICB0aGlzLmV4YW1wbGVSZWFkeSgpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnJ1bkV4YW1wbGUgPSAoZGVsdGEpID0+IHtcbiAgICAgICAgICAgIHRoaXMuYXBwLnJlbmRlcmVyLnJlbmRlcih0aGlzLmNvbnRhaW5lciwgdGhpcy5ydCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMubG9hZGVyID0gbmV3IFJlc291cmNlTG9hZGVyXzEuUmVzb3VyY2VMb2FkZXIobmV3IFVSTFJlcXVlc3RfMS5VUkxSZXF1ZXN0KFwiZXhhbXBsZXMvYXNzZXRzL2J1bm55LnBuZ1wiKSk7XG4gICAgICAgIHRoaXMubG9hZGVyLmFkZEV2ZW50TGlzdGVuZXIoRXZlbnRfMS5FdmVudC5DT01QTEVURSwgdGhpcy5oYW5kbGVSZXNvdXJjZUxvYWRlZCk7XG4gICAgICAgIHRoaXMubG9hZGVyLmxvYWQoKTtcbiAgICB9XG4gICAgZGVzdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIuZGVzdHJ1Y3RvcigpO1xuICAgICAgICB0aGlzLmFwcC50aWNrZXIucmVtb3ZlKHRoaXMucnVuRXhhbXBsZSwgbnVsbCk7XG4gICAgICAgIHRoaXMuY29udGFpbmVyLmRlc3Ryb3kobnVsbCk7XG4gICAgICAgIHRoaXMuY29udGFpbmVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5ydC5kZXN0cm95KG51bGwpO1xuICAgICAgICB0aGlzLnJ0ID0gbnVsbDtcbiAgICB9XG59XG5leHBvcnRzLlRleHR1cmVSZW5kZXIgPSBUZXh0dXJlUmVuZGVyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBCYXNlRXhhbXBsZV8xID0gcmVxdWlyZShcIi4vQmFzZUV4YW1wbGVcIik7XG5jb25zdCBSZXNvdXJjZUxvYWRlcl8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1Jlc291cmNlTG9hZGVyXCIpO1xuY29uc3QgVVJMUmVxdWVzdF8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1VSTFJlcXVlc3RcIik7XG5jb25zdCBFdmVudF8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0V2ZW50XCIpO1xuY29uc3QgVGV4dHVyZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1RleHR1cmVcIik7XG5jb25zdCBCYXNlVGV4dHVyZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0Jhc2VUZXh0dXJlXCIpO1xuY29uc3QgR3JvdXBEOF8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0dyb3VwRDhcIik7XG5jb25zdCBSZWN0YW5nbGVfMSA9IHJlcXVpcmUoXCIuLi9mbGFzaC9nZW9tL1JlY3RhbmdsZVwiKTtcbmNvbnN0IFNwcml0ZV8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL1Nwcml0ZVwiKTtcbmNvbnN0IFRleHRfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9UZXh0XCIpO1xuY2xhc3MgVGV4dHVyZVJvdGF0ZSBleHRlbmRzIEJhc2VFeGFtcGxlXzEuQmFzZUV4YW1wbGUge1xuICAgIGNvbnN0cnVjdG9yKGFwcCwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICBzdXBlcihhcHAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICB0aGlzLmhhbmRsZVJlc291cmNlTG9hZGVkID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBsZXQgdHh0ID0gbmV3IFRleHR1cmVfMS5UZXh0dXJlKG5ldyBCYXNlVGV4dHVyZV8xLkJhc2VUZXh0dXJlKHRoaXMubG9hZGVyLmltYWdlRGF0YSkpO1xuICAgICAgICAgICAgY29uc3QgdGV4dHVyZXMgPSBbdHh0XTtcbiAgICAgICAgICAgIGNvbnN0IEQ4ID0gR3JvdXBEOF8xLkdyb3VwRDg7XG4gICAgICAgICAgICBmb3IgKGxldCByb3RhdGUgPSAxOyByb3RhdGUgPCAxNjsgcm90YXRlKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBoID0gRDguaXNWZXJ0aWNhbChyb3RhdGUpID8gdHh0LmZyYW1lLndpZHRoIDogdHh0LmZyYW1lLmhlaWdodDtcbiAgICAgICAgICAgICAgICBjb25zdCB3ID0gRDguaXNWZXJ0aWNhbChyb3RhdGUpID8gdHh0LmZyYW1lLmhlaWdodCA6IHR4dC5mcmFtZS53aWR0aDtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGZyYW1lIH0gPSB0eHQ7XG4gICAgICAgICAgICAgICAgY29uc3QgY3JvcCA9IFJlY3RhbmdsZV8xLlJlY3RhbmdsZS5nZXRSZWN0YW5nbGUodHh0LmZyYW1lLngsIHR4dC5mcmFtZS55LCB3LCBoKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0cmltID0gY3JvcDtcbiAgICAgICAgICAgICAgICBsZXQgcm90YXRlZFRleHR1cmU7XG4gICAgICAgICAgICAgICAgaWYgKHJvdGF0ZSAlIDIgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcm90YXRlZFRleHR1cmUgPSBuZXcgVGV4dHVyZV8xLlRleHR1cmUodHh0LmJhc2VUZXh0dXJlLCBmcmFtZSwgY3JvcCwgdHJpbSwgcm90YXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJvdGF0ZWRUZXh0dXJlID0gbmV3IFRleHR1cmVfMS5UZXh0dXJlKHR4dC5iYXNlVGV4dHVyZSwgZnJhbWUsIGNyb3AsIHRyaW0sIHJvdGF0ZSAtIDEpO1xuICAgICAgICAgICAgICAgICAgICByb3RhdGVkVGV4dHVyZS5yb3RhdGUrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGV4dHVyZXMucHVzaChyb3RhdGVkVGV4dHVyZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBvZmZzZXRYID0gdGhpcy5zaXpldyAvIDE2IHwgMDtcbiAgICAgICAgICAgIGNvbnN0IG9mZnNldFkgPSB0aGlzLnNpemVoIC8gOCB8IDA7XG4gICAgICAgICAgICBjb25zdCBncmlkVyA9IHRoaXMuc2l6ZXcgLyA0IHwgMDtcbiAgICAgICAgICAgIGNvbnN0IGdyaWRIID0gdGhpcy5zaXplaCAvIDUgfCAwO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZHVkZSA9IG5ldyBTcHJpdGVfMS5TcHJpdGUodGV4dHVyZXNbaSA8IDggPyBpICogMiA6IChpIC0gOCkgKiAyICsgMV0pO1xuICAgICAgICAgICAgICAgIGR1ZGUuc2NhbGUueCA9IDAuNTtcbiAgICAgICAgICAgICAgICBkdWRlLnNjYWxlLnkgPSAwLjU7XG4gICAgICAgICAgICAgICAgZHVkZS54ID0gb2Zmc2V0WCArIGdyaWRXICogKGkgJSA0KTtcbiAgICAgICAgICAgICAgICBkdWRlLnkgPSBvZmZzZXRZICsgZ3JpZEggKiAoaSAvIDQgfCAwKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YWdlLmFkZENoaWxkKGR1ZGUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRleHQgPSBuZXcgVGV4dF8xLlRleHQoYHJvdGF0ZSA9ICR7ZHVkZS50ZXh0dXJlLnJvdGF0ZX1gLCB7XG4gICAgICAgICAgICAgICAgICAgIGZvbnRGYW1pbHk6ICdDb3VyaWVyIE5ldycsIGZvbnRTaXplOiAnMTJweCcsIGZpbGw6ICd3aGl0ZScsIGFsaWduOiAnbGVmdCcsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGV4dC54ID0gZHVkZS54O1xuICAgICAgICAgICAgICAgIHRleHQueSA9IGR1ZGUueSAtIDIwO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhZ2UuYWRkQ2hpbGQodGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmV4YW1wbGVSZWFkeSgpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmxvYWRlciA9IG5ldyBSZXNvdXJjZUxvYWRlcl8xLlJlc291cmNlTG9hZGVyKG5ldyBVUkxSZXF1ZXN0XzEuVVJMUmVxdWVzdChcImV4YW1wbGVzL2Fzc2V0cy9mbG93ZXJUb3AucG5nXCIpKTtcbiAgICAgICAgdGhpcy5sb2FkZXIuYWRkRXZlbnRMaXN0ZW5lcihFdmVudF8xLkV2ZW50LkNPTVBMRVRFLCB0aGlzLmhhbmRsZVJlc291cmNlTG9hZGVkKTtcbiAgICAgICAgdGhpcy5sb2FkZXIubG9hZCgpO1xuICAgIH1cbn1cbmV4cG9ydHMuVGV4dHVyZVJvdGF0ZSA9IFRleHR1cmVSb3RhdGU7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IENvbnRhaW5lcl8xID0gcmVxdWlyZShcIi4uLy4uL3Jhdy1waXhpLXRzL0NvbnRhaW5lclwiKTtcbmNvbnN0IEdyYXBoaWNzXzEgPSByZXF1aXJlKFwiLi4vLi4vcmF3LXBpeGktdHMvR3JhcGhpY3NcIik7XG5jb25zdCBFeGFtcGxlTGlzdF8xID0gcmVxdWlyZShcIi4vRXhhbXBsZUxpc3RcIik7XG5jb25zdCBBZHZhbmNlZENhcmRfMSA9IHJlcXVpcmUoXCIuLi9BZHZhbmNlZENhcmRcIik7XG5jb25zdCBBZHZhbmNlZFNsb3RzXzEgPSByZXF1aXJlKFwiLi4vQWR2YW5jZWRTbG90c1wiKTtcbmNvbnN0IEFkdmFuY2VkVHJhaWxfMSA9IHJlcXVpcmUoXCIuLi9BZHZhbmNlZFRyYWlsXCIpO1xuY29uc3QgQWR2YW5jZWRXYXJwXzEgPSByZXF1aXJlKFwiLi4vQWR2YW5jZWRXYXJwXCIpO1xuY29uc3QgQmFzaWNCbGVuZF8xID0gcmVxdWlyZShcIi4uL0Jhc2ljQmxlbmRcIik7XG5jb25zdCBJbnRlcmFjdGlvbkljb25fMSA9IHJlcXVpcmUoXCIuLi9JbnRlcmFjdGlvbkljb25cIik7XG5jb25zdCBTcHJpdGVWaWRlb18xID0gcmVxdWlyZShcIi4uL1Nwcml0ZVZpZGVvXCIpO1xuY29uc3QgVGV4dHVyZVJvdGF0ZV8xID0gcmVxdWlyZShcIi4uL1RleHR1cmVSb3RhdGVcIik7XG5jb25zdCBCYXNpY0NvbnRhaW5lcl8xID0gcmVxdWlyZShcIi4uL0Jhc2ljQ29udGFpbmVyXCIpO1xuY29uc3QgQmFzaWNUaW50aW5nXzEgPSByZXF1aXJlKFwiLi4vQmFzaWNUaW50aW5nXCIpO1xuY29uc3QgQmFzaWNQYXJ0aWNsZXNfMSA9IHJlcXVpcmUoXCIuLi9CYXNpY1BhcnRpY2xlc1wiKTtcbmNvbnN0IEdyYXBoaWNzU2ltcGxlXzEgPSByZXF1aXJlKFwiLi4vR3JhcGhpY3NTaW1wbGVcIik7XG5jb25zdCBHcmFwaGljc0FkdmFuY2VkXzEgPSByZXF1aXJlKFwiLi4vR3JhcGhpY3NBZHZhbmNlZFwiKTtcbmNvbnN0IEdyYXBoaWNzRHluYW1pY18xID0gcmVxdWlyZShcIi4uL0dyYXBoaWNzRHluYW1pY1wiKTtcbmNvbnN0IFRleHR1cmVSZW5kZXJfMSA9IHJlcXVpcmUoXCIuLi9UZXh0dXJlUmVuZGVyXCIpO1xuY29uc3QgVGV4dHVyZUFkdmFuY2VkXzEgPSByZXF1aXJlKFwiLi4vVGV4dHVyZUFkdmFuY2VkXCIpO1xuY29uc3QgVGV4dHVyZUdyYWRpZW50QmFzaWNfMSA9IHJlcXVpcmUoXCIuLi9UZXh0dXJlR3JhZGllbnRCYXNpY1wiKTtcbmNvbnN0IFRleHR1cmVHcmFkaWVudFJlc291cmNlXzEgPSByZXF1aXJlKFwiLi4vVGV4dHVyZUdyYWRpZW50UmVzb3VyY2VcIik7XG5jb25zdCBUZXh0QmFzZV8xID0gcmVxdWlyZShcIi4uL1RleHRCYXNlXCIpO1xuY29uc3QgVGV4dEJpdG1hcF8xID0gcmVxdWlyZShcIi4uL1RleHRCaXRtYXBcIik7XG5jb25zdCBUZXh0V2ViRm9udF8xID0gcmVxdWlyZShcIi4uL1RleHRXZWJGb250XCIpO1xuY29uc3QgTWFza0dyYXBoaWNzXzEgPSByZXF1aXJlKFwiLi4vTWFza0dyYXBoaWNzXCIpO1xuY29uc3QgTWFza1Nwcml0ZV8xID0gcmVxdWlyZShcIi4uL01hc2tTcHJpdGVcIik7XG5jb25zdCBGaWx0ZXJCbHVyXzEgPSByZXF1aXJlKFwiLi4vRmlsdGVyQmx1clwiKTtcbmNvbnN0IEZpbHRlckNvbG9yXzEgPSByZXF1aXJlKFwiLi4vRmlsdGVyQ29sb3JcIik7XG5jb25zdCBGaWx0ZXJDcmF3bGllc18xID0gcmVxdWlyZShcIi4uL0ZpbHRlckNyYXdsaWVzXCIpO1xuY29uc3QgRmlsdGVyRmxhZ18xID0gcmVxdWlyZShcIi4uL0ZpbHRlckZsYWdcIik7XG5jb25zdCBNYXNrRmlsdGVyXzEgPSByZXF1aXJlKFwiLi4vTWFza0ZpbHRlclwiKTtcbmNvbnN0IEludGVyYWN0aW9uQ2xpY2tfMSA9IHJlcXVpcmUoXCIuLi9JbnRlcmFjdGlvbkNsaWNrXCIpO1xuY29uc3QgSW50ZXJhY3Rpb25JbnRlcmFjdGl2aXR5XzEgPSByZXF1aXJlKFwiLi4vSW50ZXJhY3Rpb25JbnRlcmFjdGl2aXR5XCIpO1xuY29uc3QgSW50ZXJhY3Rpb25EcmFnZ2luZ18xID0gcmVxdWlyZShcIi4uL0ludGVyYWN0aW9uRHJhZ2dpbmdcIik7XG5jb25zdCBTcHJpdGVCYXNpY18xID0gcmVxdWlyZShcIi4uL1Nwcml0ZUJhc2ljXCIpO1xuY29uc3QgU3ByaXRlU3dhcF8xID0gcmVxdWlyZShcIi4uL1Nwcml0ZVN3YXBcIik7XG5jb25zdCBTcHJpdGVUaWxpbmdfMSA9IHJlcXVpcmUoXCIuLi9TcHJpdGVUaWxpbmdcIik7XG5jb25zdCBTcHJpdGVFeHBsb3Npb25fMSA9IHJlcXVpcmUoXCIuLi9TcHJpdGVFeHBsb3Npb25cIik7XG5jb25zdCBTcHJpdGVqZXRfMSA9IHJlcXVpcmUoXCIuLi9TcHJpdGVqZXRcIik7XG5jb25zdCBTcHJpdGVTcGVlZF8xID0gcmVxdWlyZShcIi4uL1Nwcml0ZVNwZWVkXCIpO1xuY29uc3QgRmlsdGVyQmxlbmRpbmdfMSA9IHJlcXVpcmUoXCIuLi9GaWx0ZXJCbGVuZGluZ1wiKTtcbmNvbnN0IEZpbHRlckN1c3RvbV8xID0gcmVxdWlyZShcIi4uL0ZpbHRlckN1c3RvbVwiKTtcbmNvbnN0IEZpbHRlclNoYWRvd18xID0gcmVxdWlyZShcIi4uL0ZpbHRlclNoYWRvd1wiKTtcbmNvbnN0IE1lc2hCYXNpY18xID0gcmVxdWlyZShcIi4uL01lc2hCYXNpY1wiKTtcbmNvbnN0IE1lc2hBZHZhbmNlZF8xID0gcmVxdWlyZShcIi4uL01lc2hBZHZhbmNlZFwiKTtcbmNvbnN0IE1lc2hUcmlhbmdsZV8xID0gcmVxdWlyZShcIi4uL01lc2hUcmlhbmdsZVwiKTtcbmNvbnN0IE1lc2hDb2xvcmVkVHJpYW5nbGVfMSA9IHJlcXVpcmUoXCIuLi9NZXNoQ29sb3JlZFRyaWFuZ2xlXCIpO1xuY29uc3QgTWVzaFRleHR1cmVkXzEgPSByZXF1aXJlKFwiLi4vTWVzaFRleHR1cmVkXCIpO1xuY29uc3QgTWVzaFVuaWZvcm1zXzEgPSByZXF1aXJlKFwiLi4vTWVzaFVuaWZvcm1zXCIpO1xuY29uc3QgTWVzaEdlb21ldHJ5XzEgPSByZXF1aXJlKFwiLi4vTWVzaEdlb21ldHJ5XCIpO1xuY29uc3QgTWVzaFNoYWRlcl8xID0gcmVxdWlyZShcIi4uL01lc2hTaGFkZXJcIik7XG5jb25zdCBFdmVudF8xID0gcmVxdWlyZShcIi4uLy4uL3Jhdy1waXhpLXRzL0V2ZW50XCIpO1xuY29uc3QgSW5zdGFuY2VDb3VudGVyXzEgPSByZXF1aXJlKFwiLi4vLi4vcmF3LXBpeGktdHMvSW5zdGFuY2VDb3VudGVyXCIpO1xuY2xhc3MgRXhhbXBsZURpc3BsYXkgZXh0ZW5kcyBDb250YWluZXJfMS5Db250YWluZXIge1xuICAgIGNvbnN0cnVjdG9yKGFwcCwgZGlzcGxheVdpZHRoLCBkaXNwbGF5aGVpZ2h0KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuaGFuZGxlRXhhbXBsZVJlcXVlc3QgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc2V0RXhhbXBsZSh0aGlzLmxpc3Quc2VsZWN0ZWRDbGFzcyk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlQ29tcGxldGUgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIHRoaXMubGlzdC5hZGRFdmVudExpc3RlbmVyKEV2ZW50XzEuRXZlbnQuQ0hBTkdFLCB0aGlzLmhhbmRsZUV4YW1wbGVSZXF1ZXN0KTtcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IGNvbnRyb2xTaXplID0gMjAwO1xuICAgICAgICB0aGlzLmFwcCA9IGFwcDtcbiAgICAgICAgdGhpcy5iYWNrZ3JvdW5kID0gbmV3IEdyYXBoaWNzXzEuR3JhcGhpY3MoKTtcbiAgICAgICAgdGhpcy5yZWZyZXNoQmFja2dyb3VuZCgweDk2OTY5Nik7XG4gICAgICAgIGFwcC5zdGFnZS5hZGRDaGlsZCh0aGlzLmJhY2tncm91bmQpO1xuICAgICAgICB0aGlzLnN0YWdlTGF5ZXIgPSBuZXcgQ29udGFpbmVyXzEuQ29udGFpbmVyKCk7XG4gICAgICAgIGFwcC5zdGFnZS5hZGRDaGlsZCh0aGlzLnN0YWdlTGF5ZXIpO1xuICAgICAgICB0aGlzLmxpc3QgPSBuZXcgRXhhbXBsZUxpc3RfMS5FeGFtcGxlTGlzdChjb250cm9sU2l6ZSwgZGlzcGxheWhlaWdodCk7XG4gICAgICAgIHRoaXMubGlzdC54ID0gZGlzcGxheVdpZHRoIC0gY29udHJvbFNpemU7XG4gICAgICAgIGRpc3BsYXlXaWR0aCA9IGRpc3BsYXlXaWR0aCAtIGNvbnRyb2xTaXplO1xuICAgICAgICBhcHAuc3RhZ2UuYWRkQ2hpbGQodGhpcy5saXN0KTtcbiAgICAgICAgdGhpcy5jb250cm9sTGF5ZXIgPSBuZXcgQ29udGFpbmVyXzEuQ29udGFpbmVyKCk7XG4gICAgICAgIGFwcC5zdGFnZS5hZGRDaGlsZCh0aGlzLmNvbnRyb2xMYXllcik7XG4gICAgICAgIHRoaXMuZnJhbWVzaXplID0gNTtcbiAgICAgICAgdGhpcy5leGFtcGxlV2lkdGggPSBkaXNwbGF5V2lkdGg7IC8vKGRpc3BsYXlXaWR0aCAtIGNvbnRyb2xTaXplKSAtICh0aGlzLmZyYW1lc2l6ZSAvIDIpXG4gICAgICAgIHRoaXMuZXhhbXBsZWhlaWdodCA9IGRpc3BsYXloZWlnaHQgLSAodGhpcy5mcmFtZXNpemUgLyAyKTtcbiAgICAgICAgdGhpcy5mcmFtZSA9IG5ldyBHcmFwaGljc18xLkdyYXBoaWNzKCk7XG4gICAgICAgIHRoaXMuZnJhbWUuYmVnaW5GaWxsKDB4MDAwRkZGKTtcbiAgICAgICAgdGhpcy5mcmFtZS5kcmF3UmVjdCgwLCAwLCB0aGlzLmZyYW1lc2l6ZSwgZGlzcGxheWhlaWdodCk7XG4gICAgICAgIHRoaXMuZnJhbWUuZHJhd1JlY3QoZGlzcGxheVdpZHRoIC0gdGhpcy5mcmFtZXNpemUsIDAsIDUsIGRpc3BsYXloZWlnaHQpO1xuICAgICAgICB0aGlzLmZyYW1lLmRyYXdSZWN0KHRoaXMuZnJhbWVzaXplLCAwLCBkaXNwbGF5V2lkdGggLSAodGhpcy5mcmFtZXNpemUgKiAyKSwgdGhpcy5mcmFtZXNpemUpO1xuICAgICAgICB0aGlzLmZyYW1lLmRyYXdSZWN0KHRoaXMuZnJhbWVzaXplLCBkaXNwbGF5aGVpZ2h0IC0gdGhpcy5mcmFtZXNpemUsIGRpc3BsYXlXaWR0aCAtICh0aGlzLmZyYW1lc2l6ZSAqIDIpLCB0aGlzLmZyYW1lc2l6ZSk7XG4gICAgICAgIHRoaXMuY29udHJvbExheWVyLmFkZENoaWxkKHRoaXMuZnJhbWUpO1xuICAgICAgICB0aGlzLmxpc3QuYWRkRXhhbXBsZShcIlNwcml0ZSBCYXNpY1wiLCBTcHJpdGVCYXNpY18xLlNwcml0ZUJhc2ljKTtcbiAgICAgICAgdGhpcy5saXN0LmFkZEV4YW1wbGUoXCJTcHJpdGUgUmV2ZWFsXCIsIEFkdmFuY2VkQ2FyZF8xLkFkdmFuY2VkQ2FyZCk7XG4gICAgICAgIHRoaXMubGlzdC5hZGRFeGFtcGxlKFwiU3ByaXRlIFNsb3RzXCIsIEFkdmFuY2VkU2xvdHNfMS5BZHZhbmNlZFNsb3RzKTtcbiAgICAgICAgdGhpcy5saXN0LmFkZEV4YW1wbGUoXCJTcHJpdGUgVHJhaWxcIiwgQWR2YW5jZWRUcmFpbF8xLkFkdmFuY2VkVHJhaWwpO1xuICAgICAgICB0aGlzLmxpc3QuYWRkRXhhbXBsZShcIlNwcml0ZSBXYXJwXCIsIEFkdmFuY2VkV2FycF8xLkFkdmFuY2VkV2FycCk7XG4gICAgICAgIHRoaXMubGlzdC5hZGRFeGFtcGxlKFwiU3ByaXRlIEJsZW5kXCIsIEJhc2ljQmxlbmRfMS5CYXNpY0JsZW5kKTtcbiAgICAgICAgdGhpcy5saXN0LmFkZEV4YW1wbGUoXCJTcHJpdGUgVGludGluZ1wiLCBCYXNpY1RpbnRpbmdfMS5CYXNpY1RpbnRpbmcpO1xuICAgICAgICB0aGlzLmxpc3QuYWRkRXhhbXBsZShcIlNwcml0ZSBWaWRlb1wiLCBTcHJpdGVWaWRlb18xLlNwcml0ZVZpZGVvKTtcbiAgICAgICAgdGhpcy5saXN0LmFkZEV4YW1wbGUoXCJTcHJpdGUgVGlsaW5nXCIsIFNwcml0ZVRpbGluZ18xLlNwcml0ZVRpbGluZyk7XG4gICAgICAgIHRoaXMubGlzdC5hZGRFeGFtcGxlKFwiU3ByaXRlIEFuaW1hdGlvblwiLCBTcHJpdGVFeHBsb3Npb25fMS5TcHJpdGVFeHBsb3Npb24pO1xuICAgICAgICB0aGlzLmxpc3QuYWRkRXhhbXBsZShcIlNwcml0ZSBBbmltYXRpb24gMlwiLCBTcHJpdGVqZXRfMS5TcHJpdGVqZXQpO1xuICAgICAgICB0aGlzLmxpc3QuYWRkRXhhbXBsZShcIlNwcml0ZSBBbmltYXRpb24gM1wiLCBTcHJpdGVTcGVlZF8xLlNwcml0ZVNwZWVkKTtcbiAgICAgICAgdGhpcy5saXN0LmFkZEV4YW1wbGUoXCJHcmFwaGljcyBCYXNpY1wiLCBHcmFwaGljc1NpbXBsZV8xLkdyYXBoaWNzU2ltcGxlKTtcbiAgICAgICAgdGhpcy5saXN0LmFkZEV4YW1wbGUoXCJHcmFwaGljcyBBZHZhbmNlZFwiLCBHcmFwaGljc0FkdmFuY2VkXzEuR3JhcGhpY3NBZHZhbmNlZCk7XG4gICAgICAgIHRoaXMubGlzdC5hZGRFeGFtcGxlKFwiR3JhcGhpY3MgRHluYW1pY1wiLCBHcmFwaGljc0R5bmFtaWNfMS5HcmFwaGljc0R5bmFtaWMpO1xuICAgICAgICB0aGlzLmxpc3QuYWRkRXhhbXBsZShcIkNvbnRhaW5lclwiLCBCYXNpY0NvbnRhaW5lcl8xLkJhc2ljQ29udGFpbmVyKTtcbiAgICAgICAgdGhpcy5saXN0LmFkZEV4YW1wbGUoXCJNYXNrIEdyYXBoaWNzXCIsIE1hc2tHcmFwaGljc18xLk1hc2tHcmFwaGljcyk7XG4gICAgICAgIHRoaXMubGlzdC5hZGRFeGFtcGxlKFwiTWFzayBTcHJpdGVcIiwgTWFza1Nwcml0ZV8xLk1hc2tTcHJpdGUpO1xuICAgICAgICB0aGlzLmxpc3QuYWRkRXhhbXBsZShcIlBhcnRpY2xlc1wiLCBCYXNpY1BhcnRpY2xlc18xLkJhc2ljUGFydGljbGVzKTtcbiAgICAgICAgdGhpcy5saXN0LmFkZEV4YW1wbGUoXCJUZXh0XCIsIFRleHRCYXNlXzEuVGV4dEJhc2UpO1xuICAgICAgICB0aGlzLmxpc3QuYWRkRXhhbXBsZShcIlRleHQgQml0bWFwXCIsIFRleHRCaXRtYXBfMS5UZXh0Qml0bWFwKTtcbiAgICAgICAgdGhpcy5saXN0LmFkZEV4YW1wbGUoXCJUZXh0IFdlYkZvbnRcIiwgVGV4dFdlYkZvbnRfMS5UZXh0V2ViRm9udCk7XG4gICAgICAgIHRoaXMubGlzdC5hZGRFeGFtcGxlKFwiSW50ZXJhY3Rpb25cIiwgSW50ZXJhY3Rpb25JbnRlcmFjdGl2aXR5XzEuSW50ZXJhY3Rpb25JbnRlcmFjdGl2aXR5KTtcbiAgICAgICAgdGhpcy5saXN0LmFkZEV4YW1wbGUoXCJJbnRlcmFjdGlvbiBDbGlja1wiLCBJbnRlcmFjdGlvbkNsaWNrXzEuSW50ZXJhY3Rpb25DbGljayk7XG4gICAgICAgIHRoaXMubGlzdC5hZGRFeGFtcGxlKFwiSW50ZXJhY3Rpb24gRHJhZ1wiLCBJbnRlcmFjdGlvbkRyYWdnaW5nXzEuSW50ZXJhY3Rpb25EcmFnZ2luZyk7XG4gICAgICAgIHRoaXMubGlzdC5hZGRFeGFtcGxlKFwiSW50ZXJhY3Rpb24gSWNvblwiLCBJbnRlcmFjdGlvbkljb25fMS5JbnRlcmFjdGlvbkljb24pO1xuICAgICAgICB0aGlzLmxpc3QuYWRkRXhhbXBsZShcInRleHR1cmUgU3dhcFwiLCBTcHJpdGVTd2FwXzEuU3ByaXRlU3dhcCk7XG4gICAgICAgIHRoaXMubGlzdC5hZGRFeGFtcGxlKFwiVGV4dHVyZSBBZHZhbmNlZFwiLCBUZXh0dXJlQWR2YW5jZWRfMS5UZXh0dXJlQWR2YW5jZWQpO1xuICAgICAgICB0aGlzLmxpc3QuYWRkRXhhbXBsZShcIlRleHR1cmUgR3JhZGllbnRcIiwgVGV4dHVyZUdyYWRpZW50QmFzaWNfMS5UZXh0dXJlR3JhZGllbnRCYXNpYyk7XG4gICAgICAgIHRoaXMubGlzdC5hZGRFeGFtcGxlKFwiVGV4dHVyZSBHcmFkaWVudCAyXCIsIFRleHR1cmVHcmFkaWVudFJlc291cmNlXzEuVGV4dHVyZUdyYWRpZW50UmVzb3VyY2UpO1xuICAgICAgICB0aGlzLmxpc3QuYWRkRXhhbXBsZShcIlRleHR1cmUgUm90YXRlXCIsIFRleHR1cmVSb3RhdGVfMS5UZXh0dXJlUm90YXRlKTtcbiAgICAgICAgdGhpcy5saXN0LmFkZEV4YW1wbGUoXCJUZXh0dXJlIFJlbmRlclwiLCBUZXh0dXJlUmVuZGVyXzEuVGV4dHVyZVJlbmRlcik7XG4gICAgICAgIHRoaXMubGlzdC5hZGRFeGFtcGxlKFwiRmlsdGVyIEJsdXJcIiwgRmlsdGVyQmx1cl8xLkZpbHRlckJsdXIpO1xuICAgICAgICB0aGlzLmxpc3QuYWRkRXhhbXBsZShcIkZpbHRlciBDb2xvck1hdHJpeFwiLCBGaWx0ZXJDb2xvcl8xLkZpbHRlckNvbG9yKTtcbiAgICAgICAgdGhpcy5saXN0LmFkZEV4YW1wbGUoXCJGaWx0ZXIgRGlzcGxhY2VtZW50XCIsIEZpbHRlckNyYXdsaWVzXzEuRmlsdGVyQ3Jhd2xpZXMpO1xuICAgICAgICB0aGlzLmxpc3QuYWRkRXhhbXBsZShcIkZpbHRlciBEaXNwbGFjZW1lbnQgMlwiLCBGaWx0ZXJGbGFnXzEuRmlsdGVyRmxhZyk7XG4gICAgICAgIHRoaXMubGlzdC5hZGRFeGFtcGxlKFwiRmlsdGVyIEJsdXIgMlwiLCBNYXNrRmlsdGVyXzEuTWFza0ZpbHRlcik7XG4gICAgICAgIHRoaXMubGlzdC5hZGRFeGFtcGxlKFwiRmlsdGVyIEJsZW5kaW5nXCIsIEZpbHRlckJsZW5kaW5nXzEuRmlsdGVyQmxlbmRpbmcpO1xuICAgICAgICB0aGlzLmxpc3QuYWRkRXhhbXBsZShcIkZpbHRlciBDdXN0b21cIiwgRmlsdGVyQ3VzdG9tXzEuRmlsdGVyQ3VzdG9tKTtcbiAgICAgICAgdGhpcy5saXN0LmFkZEV4YW1wbGUoXCJGaWx0ZXIgU2hhZG93XCIsIEZpbHRlclNoYWRvd18xLkZpbHRlclNoYWRvdyk7XG4gICAgICAgIHRoaXMubGlzdC5hZGRFeGFtcGxlKFwiTWVzaCBCYXNpY1wiLCBNZXNoQmFzaWNfMS5NZXNoQmFzaWMpO1xuICAgICAgICB0aGlzLmxpc3QuYWRkRXhhbXBsZShcIk1lc2ggVHJpYW5nbGVcIiwgTWVzaFRyaWFuZ2xlXzEuTWVzaFRyaWFuZ2xlKTtcbiAgICAgICAgdGhpcy5saXN0LmFkZEV4YW1wbGUoXCJNZXNoIFRyaWFuZ2xlIDJcIiwgTWVzaENvbG9yZWRUcmlhbmdsZV8xLk1lc2hDb2xvcmVkVHJpYW5nbGUpO1xuICAgICAgICB0aGlzLmxpc3QuYWRkRXhhbXBsZShcIk1lc2ggVGV4dHVyZVwiLCBNZXNoVGV4dHVyZWRfMS5NZXNoVGV4dHVyZWQpO1xuICAgICAgICB0aGlzLmxpc3QuYWRkRXhhbXBsZShcIk1lc2ggQWR2YW5jZWRcIiwgTWVzaEFkdmFuY2VkXzEuTWVzaEFkdmFuY2VkKTtcbiAgICAgICAgdGhpcy5saXN0LmFkZEV4YW1wbGUoXCJNZXNoIFVuaWZvcm1zXCIsIE1lc2hVbmlmb3Jtc18xLk1lc2hVbmlmb3Jtcyk7XG4gICAgICAgIHRoaXMubGlzdC5hZGRFeGFtcGxlKFwiTWVzaCBHZW9tZXRyeVwiLCBNZXNoR2VvbWV0cnlfMS5NZXNoR2VvbWV0cnkpO1xuICAgICAgICB0aGlzLmxpc3QuYWRkRXhhbXBsZShcIk1lc2ggU2hhZGVyXCIsIE1lc2hTaGFkZXJfMS5NZXNoU2hhZGVyKTtcbiAgICAgICAgSW5zdGFuY2VDb3VudGVyXzEuSW5zdGFuY2VDb3VudGVyLmVuYWJsZSgpO1xuICAgICAgICB0aGlzLnNldEV4YW1wbGUoU3ByaXRlQmFzaWNfMS5TcHJpdGVCYXNpYyk7XG4gICAgfVxuICAgIHNldEV4YW1wbGUoa2V5Y2xhc3MpIHtcbiAgICAgICAgdGhpcy5saXN0LnJlbW92ZUV2ZW50TGlzdGVuZXIoRXZlbnRfMS5FdmVudC5DSEFOR0UsIHRoaXMuaGFuZGxlRXhhbXBsZVJlcXVlc3QpO1xuICAgICAgICBpZiAodGhpcy5jdXJyZW50RXhhbXBsZSkge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50RXhhbXBsZS5kZXN0cnVjdG9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jdXJyZW50RXhhbXBsZSA9IG5ldyBrZXljbGFzcyh0aGlzLmFwcCwgdGhpcy5leGFtcGxlV2lkdGgsIHRoaXMuZXhhbXBsZWhlaWdodCk7XG4gICAgICAgIHRoaXMuY3VycmVudEV4YW1wbGUuYWRkRXZlbnRMaXN0ZW5lcihFdmVudF8xLkV2ZW50LkNPTVBMRVRFLCB0aGlzLmhhbmRsZUNvbXBsZXRlKTtcbiAgICAgICAgdGhpcy5zdGFnZUxheWVyLnJlbW92ZUNoaWxkcmVuKCk7XG4gICAgICAgIHRoaXMuc3RhZ2VMYXllci5hZGRDaGlsZCh0aGlzLmN1cnJlbnRFeGFtcGxlLnN0YWdlKTtcbiAgICAgICAgdGhpcy5yZWZyZXNoQmFja2dyb3VuZCh0aGlzLmN1cnJlbnRFeGFtcGxlLmJhY2tDb2xvcik7XG4gICAgfVxuICAgIHJlZnJlc2hCYWNrZ3JvdW5kKGNvbG9yKSB7XG4gICAgICAgIHRoaXMuYmFja2dyb3VuZC5jbGVhcigpO1xuICAgICAgICB0aGlzLmJhY2tncm91bmQuYmVnaW5GaWxsKGNvbG9yKTtcbiAgICAgICAgdGhpcy5iYWNrZ3JvdW5kLmRyYXdSZWN0KDAsIDAsIHRoaXMuZXhhbXBsZVdpZHRoLCB0aGlzLmV4YW1wbGVoZWlnaHQpO1xuICAgIH1cbn1cbmV4cG9ydHMuRXhhbXBsZURpc3BsYXkgPSBFeGFtcGxlRGlzcGxheTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgQ29udGFpbmVyXzEgPSByZXF1aXJlKFwiLi4vLi4vcmF3LXBpeGktdHMvQ29udGFpbmVyXCIpO1xuY29uc3QgQnV0dG9uXzEgPSByZXF1aXJlKFwiLi4vLi4vZmwtcGFja2FnZS9CdXR0b25cIik7XG5jb25zdCBHcmFwaGljc18xID0gcmVxdWlyZShcIi4uLy4uL3Jhdy1waXhpLXRzL0dyYXBoaWNzXCIpO1xuY29uc3QgTW91c2VFdmVudF8xID0gcmVxdWlyZShcIi4uLy4uL3Jhdy1waXhpLXRzL01vdXNlRXZlbnRcIik7XG5jb25zdCBFdmVudF8xID0gcmVxdWlyZShcIi4uLy4uL3Jhdy1waXhpLXRzL0V2ZW50XCIpO1xuY2xhc3MgRXhhbXBsZUxpc3QgZXh0ZW5kcyBDb250YWluZXJfMS5Db250YWluZXIge1xuICAgIGNvbnN0cnVjdG9yKGRpc3BsYXlXaWR0aCwgZGlzcGxheWhlaWdodCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmhhbmRsZVNjcm9sbENoYW5nZSA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5saXN0Q29udGFpbmVyLnkgPSB0aGlzLnNjcm9sbC50YXJnZXRQb3NpdGlvbjtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVCdXR0b25UYXAgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX3NlbGVjdGVkQ2xhc3MgPSB0aGlzLmNsYXNzUmVmZXJlbmNlW2V2ZW50LmN1cnJlbnRUYXJnZXQubmFtZV07XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoRXZlbnRfMS5FdmVudC5nZXRFdmVudChFdmVudF8xLkV2ZW50LkNIQU5HRSkpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmJ1dHRvbnMgPSBbXTtcbiAgICAgICAgdGhpcy5jbGFzc1JlZmVyZW5jZSA9IHt9O1xuICAgICAgICB0aGlzLml0ZW1HYXAgPSAyO1xuICAgICAgICB0aGlzLnNpZGVHYXAgPSAyO1xuICAgICAgICB0aGlzLmxpc3RDb250YWluZXIgPSBuZXcgQ29udGFpbmVyXzEuQ29udGFpbmVyKCk7XG4gICAgICAgIHRoaXMuYWRkQ2hpbGQodGhpcy5saXN0Q29udGFpbmVyKTtcbiAgICAgICAgdGhpcy5saXN0bWFzayA9IG5ldyBHcmFwaGljc18xLkdyYXBoaWNzKCk7XG4gICAgICAgIHRoaXMubGlzdG1hc2suYmVnaW5GaWxsKDApO1xuICAgICAgICB0aGlzLmxpc3RtYXNrLmRyYXdSZWN0KDAsIDAsIGRpc3BsYXlXaWR0aCwgZGlzcGxheWhlaWdodCk7XG4gICAgICAgIHRoaXMubGlzdENvbnRhaW5lci5tYXNrID0gdGhpcy5saXN0bWFzaztcbiAgICAgICAgdGhpcy5hZGRDaGlsZCh0aGlzLmxpc3RtYXNrKTtcbiAgICAgICAgbGV0IGdyID0gbmV3IEdyYXBoaWNzXzEuR3JhcGhpY3MoKTtcbiAgICAgICAgZ3IuYmVnaW5GaWxsKDB4QUFBMEFBKTtcbiAgICAgICAgZ3IuZHJhd1JlY3QoMCwgMCwgMjUsIGRpc3BsYXloZWlnaHQpO1xuICAgICAgICB0aGlzLmFkZENoaWxkKGdyKTtcbiAgICAgICAgZ3IueCA9IGRpc3BsYXlXaWR0aCAtIDI1O1xuICAgICAgICB0aGlzLmJ1dHRvbldpZHRoID0gZGlzcGxheVdpZHRoIC0gMjUgLSAodGhpcy5zaWRlR2FwICogMik7XG4gICAgICAgIHRoaXMuYnV0dG9uaGVpZ2h0ID0gNDA7XG4gICAgICAgIHRoaXMuc2Nyb2xsID0gbmV3IFNjcm9sbEJhcigpO1xuICAgICAgICB0aGlzLmFkZENoaWxkKHRoaXMuc2Nyb2xsKTtcbiAgICAgICAgdGhpcy5zY3JvbGwueCA9IGRpc3BsYXlXaWR0aCAtIDI1O1xuICAgICAgICB0aGlzLnNjcm9sbC5zY3JvbGxBcmVhID0gZGlzcGxheWhlaWdodDtcbiAgICAgICAgdGhpcy5zY3JvbGwuYWRkRXZlbnRMaXN0ZW5lcihFdmVudF8xLkV2ZW50LkNIQU5HRSwgdGhpcy5oYW5kbGVTY3JvbGxDaGFuZ2UpO1xuICAgIH1cbiAgICBnZXQgc2VsZWN0ZWRDbGFzcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NlbGVjdGVkQ2xhc3M7XG4gICAgfVxuICAgIGFkZEV4YW1wbGUoa2V5bmFtZSwga2V5Y2xhc3MpIHtcbiAgICAgICAgbGV0IGJ1dHRvbiA9IG5ldyBCdXR0b25fMS5CdXR0b24oa2V5bmFtZSwgdGhpcy5idXR0b25XaWR0aCwgdGhpcy5idXR0b25oZWlnaHQpO1xuICAgICAgICBidXR0b24uYWRkRXZlbnRMaXN0ZW5lcihNb3VzZUV2ZW50XzEuTW91c2VFdmVudC5QT0lOVEVSX1RBUCwgdGhpcy5oYW5kbGVCdXR0b25UYXApO1xuICAgICAgICB0aGlzLmJ1dHRvbnMucHVzaChidXR0b24pO1xuICAgICAgICBidXR0b24ubmFtZSA9IGtleW5hbWU7XG4gICAgICAgIGJ1dHRvbi54ID0gdGhpcy5zaWRlR2FwO1xuICAgICAgICB0aGlzLmxpc3RDb250YWluZXIuYWRkQ2hpbGQoYnV0dG9uKTtcbiAgICAgICAgdGhpcy5jbGFzc1JlZmVyZW5jZVtrZXluYW1lXSA9IGtleWNsYXNzO1xuICAgICAgICB0aGlzLnJlZnJlc2hMaXN0KCk7XG4gICAgfVxuICAgIHJlZnJlc2hMaXN0KCkge1xuICAgICAgICBsZXQgc3RhcnQgPSB0aGlzLml0ZW1HYXA7XG4gICAgICAgIGZvciAobGV0IGJ1dHRvbiBvZiB0aGlzLmJ1dHRvbnMpIHtcbiAgICAgICAgICAgIGJ1dHRvbi55ID0gc3RhcnQ7XG4gICAgICAgICAgICBzdGFydCArPSBidXR0b24uaGVpZ2h0ICsgdGhpcy5pdGVtR2FwO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2Nyb2xsLnNjcm9sbERpc3RhbmNlID0gc3RhcnQ7XG4gICAgfVxufVxuZXhwb3J0cy5FeGFtcGxlTGlzdCA9IEV4YW1wbGVMaXN0O1xuY2xhc3MgU2Nyb2xsQmFyIGV4dGVuZHMgQ29udGFpbmVyXzEuQ29udGFpbmVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5oYW5kbGVIYW5kbGVVcCA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5kcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5ldmVudERhdGEgPSBudWxsO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZUhhbmRsZU1vdmUgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmV2ZW50RGF0YSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld1Bvc2l0aW9uID0gdGhpcy5ldmVudERhdGEuZ2V0TG9jYWxQb3NpdGlvbih0aGlzLl9oYW5kbGUucGFyZW50KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGUueSA9IG5ld1Bvc2l0aW9uLnkgLSAodGhpcy5faGFuZGxlLmhlaWdodCAvIDIpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9oYW5kbGUueSA+IHRoaXMuX3Njcm9sbEFyZWEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faGFuZGxlLnkgPSB0aGlzLl9zY3JvbGxBcmVhO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9oYW5kbGUueSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faGFuZGxlLnkgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmFyZWFQZXJjZW50ID0gdGhpcy5faGFuZGxlLnkgLyB0aGlzLl9zY3JvbGxBcmVhO1xuICAgICAgICAgICAgICAgIHRoaXMuX3RhcmdldFBvc2l0aW9uID0gKHRoaXMuX3Njcm9sbERpc3RhbmNlIC0gdGhpcy5fdmlzaWJsZUFyZWEpICogdGhpcy5hcmVhUGVyY2VudCAqIC0xO1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChFdmVudF8xLkV2ZW50LmdldEV2ZW50KEV2ZW50XzEuRXZlbnQuQ0hBTkdFKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlSGFuZGxlRG93biA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5kcmFnZ2luZyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmV2ZW50RGF0YSA9IGV2ZW50LmRhdGE7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX2hhbmRsZSA9IG5ldyBHcmFwaGljc18xLkdyYXBoaWNzKCk7XG4gICAgICAgIHRoaXMuX2hhbmRsZS5iZWdpbkZpbGwoMHg2MzYzNjMpO1xuICAgICAgICB0aGlzLl9oYW5kbGUuZHJhd1JlY3QoMCwgMCwgMjUsIDI1KTtcbiAgICAgICAgdGhpcy5hZGRDaGlsZCh0aGlzLl9oYW5kbGUpO1xuICAgICAgICB0aGlzLl9oYW5kbGUuYnV0dG9uTW9kZSA9IHRoaXMuX2hhbmRsZS5pbnRlcmFjdGl2ZSA9IHRydWU7XG4gICAgICAgIHRoaXMuX2hhbmRsZS5hZGRFdmVudExpc3RlbmVyKE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50LlBPSU5URVJfRE9XTiwgdGhpcy5oYW5kbGVIYW5kbGVEb3duKTtcbiAgICAgICAgdGhpcy5faGFuZGxlLmFkZEV2ZW50TGlzdGVuZXIoTW91c2VFdmVudF8xLk1vdXNlRXZlbnQuUE9JTlRFUl9VUCwgdGhpcy5oYW5kbGVIYW5kbGVVcCk7XG4gICAgICAgIHRoaXMuX2hhbmRsZS5hZGRFdmVudExpc3RlbmVyKE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50LlBPSU5URVJfVVBfT1VUU0lERSwgdGhpcy5oYW5kbGVIYW5kbGVVcCk7XG4gICAgICAgIHRoaXMuX2hhbmRsZS5hZGRFdmVudExpc3RlbmVyKE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50LlBPSU5URVJfTU9WRSwgdGhpcy5oYW5kbGVIYW5kbGVNb3ZlKTtcbiAgICB9XG4gICAgZ2V0IHRhcmdldFBvc2l0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdGFyZ2V0UG9zaXRpb247XG4gICAgfVxuICAgIHNldCBzY3JvbGxEaXN0YW5jZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9zY3JvbGxEaXN0YW5jZSA9IHZhbHVlO1xuICAgIH1cbiAgICBzZXQgc2Nyb2xsQXJlYSh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9zY3JvbGxBcmVhID0gdmFsdWUgLSAyNTtcbiAgICAgICAgdGhpcy5fdmlzaWJsZUFyZWEgPSB2YWx1ZTtcbiAgICB9XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IENvbnRhaW5lcl8xID0gcmVxdWlyZShcIi4uL3Jhdy1waXhpLXRzL0NvbnRhaW5lclwiKTtcbmNvbnN0IEdyYXBoaWNzXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvR3JhcGhpY3NcIik7XG5jb25zdCBNb3VzZUV2ZW50XzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvTW91c2VFdmVudFwiKTtcbmNvbnN0IFRleHRfMSA9IHJlcXVpcmUoXCIuLi9yYXctcGl4aS10cy9UZXh0XCIpO1xuY29uc3QgVGV4dFN0eWxlXzEgPSByZXF1aXJlKFwiLi4vcmF3LXBpeGktdHMvVGV4dFN0eWxlXCIpO1xuY2xhc3MgQnV0dG9uIGV4dGVuZHMgQ29udGFpbmVyXzEuQ29udGFpbmVyIHtcbiAgICBjb25zdHJ1Y3RvcihjYXB0aW9uLCBidXR0b25XaWR0aCA9IDE1MCwgYnV0dG9uaGVpZ2h0ID0gNDApIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5oYW5kbGVPdXQgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuYnV0dG9uZ3JhcGhpYy52aXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuYnV0dG9ub3ZlcmdyYXBoaWMudmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5idXR0b25kb3duZ3JhcGhpYy52aXNpYmxlID0gZmFsc2U7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlT3ZlciA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5idXR0b25ncmFwaGljLnZpc2libGUgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuYnV0dG9ub3ZlcmdyYXBoaWMudmlzaWJsZSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmJ1dHRvbmRvd25ncmFwaGljLnZpc2libGUgPSBmYWxzZTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVVcCA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5idXR0b25ncmFwaGljLnZpc2libGUgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5idXR0b25vdmVyZ3JhcGhpYy52aXNpYmxlID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmJ1dHRvbmRvd25ncmFwaGljLnZpc2libGUgPSBmYWxzZTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVEb3duID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICB0aGlzLmJ1dHRvbmdyYXBoaWMudmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5idXR0b25vdmVyZ3JhcGhpYy52aXNpYmxlID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmJ1dHRvbmRvd25ncmFwaGljLnZpc2libGUgPSB0cnVlO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmludGVyYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5idXR0b25ncmFwaGljID0gbmV3IEdyYXBoaWNzXzEuR3JhcGhpY3MoKTtcbiAgICAgICAgdGhpcy5idXR0b25ncmFwaGljLmJlZ2luRmlsbCgweDk2OTY5Nik7XG4gICAgICAgIHRoaXMuYnV0dG9uZ3JhcGhpYy5kcmF3Um91bmRlZFJlY3QoMCwgMCwgYnV0dG9uV2lkdGgsIGJ1dHRvbmhlaWdodCwgMTApO1xuICAgICAgICB0aGlzLmFkZENoaWxkKHRoaXMuYnV0dG9uZ3JhcGhpYyk7XG4gICAgICAgIHRoaXMuYnV0dG9ub3ZlcmdyYXBoaWMgPSBuZXcgR3JhcGhpY3NfMS5HcmFwaGljcygpO1xuICAgICAgICB0aGlzLmJ1dHRvbm92ZXJncmFwaGljLmJlZ2luRmlsbCgweEI5QjlCOSk7XG4gICAgICAgIHRoaXMuYnV0dG9ub3ZlcmdyYXBoaWMuZHJhd1JvdW5kZWRSZWN0KDAsIDAsIGJ1dHRvbldpZHRoLCBidXR0b25oZWlnaHQsIDEwKTtcbiAgICAgICAgdGhpcy5hZGRDaGlsZCh0aGlzLmJ1dHRvbm92ZXJncmFwaGljKTtcbiAgICAgICAgdGhpcy5idXR0b25vdmVyZ3JhcGhpYy52aXNpYmxlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYnV0dG9uZG93bmdyYXBoaWMgPSBuZXcgR3JhcGhpY3NfMS5HcmFwaGljcygpO1xuICAgICAgICB0aGlzLmJ1dHRvbmRvd25ncmFwaGljLmJlZ2luRmlsbCgweDYzNjM2Myk7XG4gICAgICAgIHRoaXMuYnV0dG9uZG93bmdyYXBoaWMuZHJhd1JvdW5kZWRSZWN0KDAsIDAsIGJ1dHRvbldpZHRoLCBidXR0b25oZWlnaHQsIDEwKTtcbiAgICAgICAgdGhpcy5hZGRDaGlsZCh0aGlzLmJ1dHRvbmRvd25ncmFwaGljKTtcbiAgICAgICAgdGhpcy5idXR0b25kb3duZ3JhcGhpYy52aXNpYmxlID0gZmFsc2U7XG4gICAgICAgIGxldCBzdHlsZSA9IG5ldyBUZXh0U3R5bGVfMS5UZXh0U3R5bGUoe30pO1xuICAgICAgICBzdHlsZS5mb250U2l6ZSA9IDE2O1xuICAgICAgICBzdHlsZS5hbGlnbiA9IFwiY2VudGVyXCI7XG4gICAgICAgIHN0eWxlLmZvbnRGYW1pbHkgPSBcIkFyaWFsXCI7XG4gICAgICAgIHRoaXMubGFiZWwgPSBuZXcgVGV4dF8xLlRleHQoY2FwdGlvbiwgc3R5bGUpO1xuICAgICAgICB0aGlzLmxhYmVsLmludGVyYWN0aXZlID0gZmFsc2U7XG4gICAgICAgIHRoaXMubGFiZWwueSA9IChidXR0b25oZWlnaHQgLSAodGhpcy5sYWJlbC5oZWlnaHQpKSAvIDI7XG4gICAgICAgIHRoaXMubGFiZWwueCA9IChidXR0b25XaWR0aCAvIDIgLSB0aGlzLmxhYmVsLndpZHRoIC8gMik7XG4gICAgICAgIHRoaXMuYWRkQ2hpbGQodGhpcy5sYWJlbCk7XG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihNb3VzZUV2ZW50XzEuTW91c2VFdmVudC5QT0lOVEVSX0RPV04sIHRoaXMuaGFuZGxlRG93bik7XG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihNb3VzZUV2ZW50XzEuTW91c2VFdmVudC5QT0lOVEVSX09WRVIsIHRoaXMuaGFuZGxlT3Zlcik7XG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihNb3VzZUV2ZW50XzEuTW91c2VFdmVudC5QT0lOVEVSX1VQLCB0aGlzLmhhbmRsZVVwKTtcbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50LlBPSU5URVJfT1VULCB0aGlzLmhhbmRsZU91dCk7XG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihNb3VzZUV2ZW50XzEuTW91c2VFdmVudC5QT0lOVEVSX1VQX09VVFNJREUsIHRoaXMuaGFuZGxlT3V0KTtcbiAgICB9XG59XG5leHBvcnRzLkJ1dHRvbiA9IEJ1dHRvbjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgRmxhc2hCYXNlT2JqZWN0XzEgPSByZXF1aXJlKFwiLi4vLi4vcmF3LXBpeGktdHMvRmxhc2hCYXNlT2JqZWN0XCIpO1xuY29uc3QgSW5zdGFuY2VDb3VudGVyXzEgPSByZXF1aXJlKFwiLi4vLi4vcmF3LXBpeGktdHMvSW5zdGFuY2VDb3VudGVyXCIpO1xuY2xhc3MgUG9pbnQgZXh0ZW5kcyBGbGFzaEJhc2VPYmplY3RfMS5GbGFzaEJhc2VPYmplY3Qge1xuICAgIGNvbnN0cnVjdG9yKHggPSAwLCB5ID0gMCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLl94ID0geDtcbiAgICAgICAgdGhpcy5feSA9IHk7XG4gICAgICAgIEluc3RhbmNlQ291bnRlcl8xLkluc3RhbmNlQ291bnRlci5jb3VudCh0aGlzKTtcbiAgICB9XG4gICAgZ2V0IGxlbmd0aCgpIHtcbiAgICAgICAgcmV0dXJuIFBvaW50LmRpc3RhbmNlKFBvaW50LkRFRkFVTFQsIHRoaXMpO1xuICAgIH1cbiAgICA7XG4gICAgZ2V0IHgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl94O1xuICAgIH1cbiAgICA7XG4gICAgc2V0IHgodmFsdWUpIHtcbiAgICAgICAgdGhpcy5feCA9IHZhbHVlO1xuICAgIH1cbiAgICA7XG4gICAgZ2V0IHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl95O1xuICAgIH1cbiAgICA7XG4gICAgc2V0IHkodmFsdWUpIHtcbiAgICAgICAgdGhpcy5feSA9IHZhbHVlO1xuICAgIH1cbiAgICA7XG4gICAgc3VidHJhY3Qodikge1xuICAgICAgICBsZXQgcG9pbnQgPSBuZXcgUG9pbnQoKTtcbiAgICAgICAgcG9pbnQueCA9IHRoaXMuX3ggLSB2Lng7XG4gICAgICAgIHBvaW50LnkgPSB0aGlzLl95IC0gdi55O1xuICAgICAgICByZXR1cm4gcG9pbnQ7XG4gICAgfVxuICAgIHNldFRvKHhhLCB5YSkge1xuICAgICAgICB0aGlzLl94ID0geGE7XG4gICAgICAgIHRoaXMuX3kgPSB5YTtcbiAgICB9XG4gICAgb2Zmc2V0KGR4LCBkeSkge1xuICAgICAgICB0aGlzLl94ICs9IGR4O1xuICAgICAgICB0aGlzLl95ICs9IGR5O1xuICAgIH1cbiAgICBub3JtYWxpemUodGhpY2tuZXNzKSB7XG4gICAgICAgIGxldCBub3JtID0gTWF0aC5zcXJ0KHRoaXMuX3ggKiB0aGlzLl94ICsgdGhpcy5feSAqIHRoaXMuX3kpO1xuICAgICAgICB0aGlzLl94ID0gdGhpcy5feCAvIG5vcm0gKiB0aGlja25lc3M7XG4gICAgICAgIHRoaXMuX3kgPSB0aGlzLl95IC8gbm9ybSAqIHRoaWNrbmVzcztcbiAgICB9XG4gICAgYWRkKHYpIHtcbiAgICAgICAgbGV0IHBvaW50ID0gbmV3IFBvaW50KCk7XG4gICAgICAgIHBvaW50LnggPSB2LnggKyB0aGlzLl94O1xuICAgICAgICBwb2ludC55ID0gdi55ICsgdGhpcy5feTtcbiAgICAgICAgcmV0dXJuIHBvaW50O1xuICAgIH1cbiAgICBzZXQoeCA9IDAsIHkgPSAwKSB7XG4gICAgICAgIHRoaXMuX3ggPSB4O1xuICAgICAgICB0aGlzLl95ID0geTtcbiAgICB9XG4gICAgO1xuICAgIGVxdWFscyhwKSB7XG4gICAgICAgIHJldHVybiAocC5feCA9PT0gdGhpcy5feCkgJiYgKHAuX3kgPT09IHRoaXMuX3kpO1xuICAgIH1cbiAgICA7XG4gICAgY29weVRvKHApIHtcbiAgICAgICAgcC5zZXQodGhpcy5feCwgdGhpcy5feSk7XG4gICAgICAgIHJldHVybiBwO1xuICAgIH1cbiAgICA7XG4gICAgY29weUZyb20ocCkge1xuICAgICAgICB0aGlzLnNldChwLl94LCBwLl95KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIDtcbiAgICBjbG9uZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLl94LCB0aGlzLl95KTtcbiAgICB9XG4gICAgO1xuICAgIHJlc2V0KHggPSAwLCB5ID0gMCkge1xuICAgICAgICB0aGlzLl94ID0geDtcbiAgICAgICAgdGhpcy5feSA9IHk7XG4gICAgfVxuICAgIHJlY3ljbGUoKSB7XG4gICAgICAgIEluc3RhbmNlQ291bnRlcl8xLkluc3RhbmNlQ291bnRlci5yZWN5Y2xlQ291bnQodGhpcyk7XG4gICAgICAgIGxldCBpbmRleCA9IFBvaW50LmNhY2hlZEluc3RhbmNlcy5pbmRleE9mKHRoaXMpO1xuICAgICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgICAgICBQb2ludC5jYWNoZWRJbnN0YW5jZXMudW5zaGlmdCh0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkZXN0cnVjdG9yKCkge1xuICAgICAgICBJbnN0YW5jZUNvdW50ZXJfMS5JbnN0YW5jZUNvdW50ZXIuZGVzdHJ1Y3RvckNvdW50KHRoaXMpO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0UG9pbnQoeCA9IDAsIHkgPSAwKSB7XG4gICAgICAgIGlmIChQb2ludC5jYWNoZWRJbnN0YW5jZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgciA9IFBvaW50LmNhY2hlZEluc3RhbmNlc1tQb2ludC5jYWNoZWRJbnN0YW5jZXMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBQb2ludC5jYWNoZWRJbnN0YW5jZXMubGVuZ3RoIC09IDE7XG4gICAgICAgICAgICByLnJlc2V0KHgsIHkpO1xuICAgICAgICAgICAgcmV0dXJuIHI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludCh4LCB5KTtcbiAgICB9XG4gICAgc3RhdGljIHBvbGFyKGxlbiwgYW5nbGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQb2ludChsZW4gKiBNYXRoLmNvcyhhbmdsZSksIGxlbiAqIE1hdGguc2luKGFuZ2xlKSk7XG4gICAgfVxuICAgIHN0YXRpYyBpbnRlcnBvbGF0ZShwdDEsIHB0MiwgZikge1xuICAgICAgICBpZiAoZiA8IDAgfHwgZiA+IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGxldCBueCA9IHB0MS54ICsgKHB0Mi54IC0gcHQxLngpICogZjtcbiAgICAgICAgbGV0IG55ID0gcHQxLnkgKyAocHQyLnkgLSBwdDEueSkgKiBmO1xuICAgICAgICByZXR1cm4gbmV3IFBvaW50KG54LCBueSk7XG4gICAgfVxuICAgIHN0YXRpYyBkaXN0YW5jZShwdDEsIHB0Mikge1xuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KCgocHQyLnggLSBwdDEueCkgKiAocHQyLnggLSBwdDEueCkpICsgKChwdDIueSAtIHB0MS55KSAqIChwdDIueSAtIHB0MS55KSkpO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0IERFRkFVTFQoKSB7XG4gICAgICAgIGlmICghUG9pbnQuX1JlY3QpIHtcbiAgICAgICAgICAgIFBvaW50Ll9SZWN0ID0gbmV3IFBvaW50KCk7XG4gICAgICAgIH1cbiAgICAgICAgUG9pbnQuX1JlY3QucmVzZXQoKTtcbiAgICAgICAgcmV0dXJuIFBvaW50Ll9SZWN0O1xuICAgIH1cbn1cblBvaW50LmNhY2hlZEluc3RhbmNlcyA9IFtdO1xuZXhwb3J0cy5Qb2ludCA9IFBvaW50O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBTaGFwZVNldHRpbmdzXzEgPSByZXF1aXJlKFwiLi4vLi4vcmF3LXBpeGktdHMvU2hhcGVTZXR0aW5nc1wiKTtcbmNvbnN0IEZsYXNoQmFzZU9iamVjdF8xID0gcmVxdWlyZShcIi4uLy4uL3Jhdy1waXhpLXRzL0ZsYXNoQmFzZU9iamVjdFwiKTtcbmNvbnN0IEluc3RhbmNlQ291bnRlcl8xID0gcmVxdWlyZShcIi4uLy4uL3Jhdy1waXhpLXRzL0luc3RhbmNlQ291bnRlclwiKTtcbmNvbnN0IFBvaW50XzEgPSByZXF1aXJlKFwiLi9Qb2ludFwiKTtcbmNsYXNzIFJlY3RhbmdsZSBleHRlbmRzIEZsYXNoQmFzZU9iamVjdF8xLkZsYXNoQmFzZU9iamVjdCB7XG4gICAgY29uc3RydWN0b3IoeCA9IDAsIHkgPSAwLCB3aWR0aCA9IDAsIGhlaWdodCA9IDApIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgUmVjdGFuZ2xlLmluc3RhbmNlQ291bnQrKztcbiAgICAgICAgdGhpcy5yZXNldCh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgdGhpcy50eXBlID0gU2hhcGVTZXR0aW5nc18xLlNoYXBlU2V0dGluZ3MuU0hBUEVTLlJFQ1Q7XG4gICAgICAgIEluc3RhbmNlQ291bnRlcl8xLkluc3RhbmNlQ291bnRlci5jb3VudCh0aGlzKTtcbiAgICB9XG4gICAgZ2V0IGJvdHRvbSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3kgKyB0aGlzLl9oZWlnaHQ7XG4gICAgfVxuICAgIDtcbiAgICBzZXQgYm90dG9tKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX3kgPSB2YWx1ZSAtIHRoaXMuX2hlaWdodDtcbiAgICB9XG4gICAgZ2V0IGJvdHRvbVJpZ2h0KCkge1xuICAgICAgICByZXR1cm4gbmV3IFBvaW50XzEuUG9pbnQodGhpcy5feCArIHRoaXMuX3dpZHRoLCB0aGlzLl95ICsgdGhpcy5faGVpZ2h0KTtcbiAgICB9XG4gICAgc2V0IGJvdHRvbVJpZ2h0KHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX3ggPSB2YWx1ZS54IC0gdGhpcy5fd2lkdGg7XG4gICAgICAgIHRoaXMuX3kgPSB2YWx1ZS55IC0gdGhpcy5faGVpZ2h0O1xuICAgIH1cbiAgICBnZXQgaGVpZ2h0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faGVpZ2h0O1xuICAgIH1cbiAgICA7XG4gICAgc2V0IGhlaWdodCh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9oZWlnaHQgPSB2YWx1ZTtcbiAgICB9XG4gICAgO1xuICAgIGdldCBsZWZ0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5feDtcbiAgICB9XG4gICAgc2V0IGxlZnQodmFsdWUpIHtcbiAgICAgICAgdGhpcy5feCA9IHZhbHVlO1xuICAgIH1cbiAgICBnZXQgcmlnaHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl94ICsgdGhpcy5fd2lkdGg7XG4gICAgfVxuICAgIDtcbiAgICBzZXQgcmlnaHQodmFsdWUpIHtcbiAgICAgICAgdGhpcy5feCA9IHZhbHVlIC0gdGhpcy5fd2lkdGg7XG4gICAgfVxuICAgIGdldCBzaXplKCkge1xuICAgICAgICByZXR1cm4gbmV3IFBvaW50XzEuUG9pbnQodGhpcy5fd2lkdGgsIHRoaXMuX2hlaWdodCk7XG4gICAgfVxuICAgIHNldCBzaXplKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX3dpZHRoID0gdmFsdWUueDtcbiAgICAgICAgdGhpcy5faGVpZ2h0ID0gdmFsdWUueTtcbiAgICB9XG4gICAgZ2V0IHRvcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3k7XG4gICAgfVxuICAgIDtcbiAgICBzZXQgdG9wKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX3kgPSB2YWx1ZSAtIHRoaXMuX2hlaWdodDtcbiAgICB9XG4gICAgZ2V0IHRvcExlZnQoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUG9pbnRfMS5Qb2ludCh0aGlzLl94LCB0aGlzLl95KTtcbiAgICB9XG4gICAgc2V0IHRvcExlZnQodmFsdWUpIHtcbiAgICAgICAgdGhpcy5feCA9IHZhbHVlLng7XG4gICAgICAgIHRoaXMuX3kgPSB2YWx1ZS55O1xuICAgIH1cbiAgICBnZXQgd2lkdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93aWR0aDtcbiAgICB9XG4gICAgO1xuICAgIHNldCB3aWR0aCh2YWx1ZSkge1xuICAgICAgICB0aGlzLl93aWR0aCA9IHZhbHVlO1xuICAgIH1cbiAgICA7XG4gICAgZ2V0IHgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl94O1xuICAgIH1cbiAgICA7XG4gICAgc2V0IHgodmFsdWUpIHtcbiAgICAgICAgdGhpcy5feCA9IHZhbHVlO1xuICAgIH1cbiAgICA7XG4gICAgZ2V0IHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl95O1xuICAgIH1cbiAgICA7XG4gICAgc2V0IHkodmFsdWUpIHtcbiAgICAgICAgdGhpcy5feSA9IHZhbHVlO1xuICAgIH1cbiAgICA7XG4gICAgY2xvbmUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVjdGFuZ2xlKHRoaXMuX3gsIHRoaXMuX3ksIHRoaXMuX3dpZHRoLCB0aGlzLl9oZWlnaHQpO1xuICAgIH1cbiAgICA7XG4gICAgY29udGFpbnMoeCwgeSkge1xuICAgICAgICBpZiAodGhpcy5fd2lkdGggPD0gMCB8fCB0aGlzLl9oZWlnaHQgPD0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh4ID49IHRoaXMuX3ggJiYgeCA8IHRoaXMuX3ggKyB0aGlzLl93aWR0aCkge1xuICAgICAgICAgICAgaWYgKHkgPj0gdGhpcy5feSAmJiB5IDwgdGhpcy5feSArIHRoaXMuX2hlaWdodCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgO1xuICAgIGNvbnRhaW5zUG9pbnQocG9pbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGFpbnMocG9pbnQueCwgcG9pbnQueSk7XG4gICAgfVxuICAgIGNvbnRhaW5zUmVjdChyZWN0KSB7XG4gICAgICAgIGlmICh0aGlzLmNvbnRhaW5zKHJlY3QueCwgcmVjdC55KSAmJiB0aGlzLmNvbnRhaW5zKHJlY3QuYm90dG9tUmlnaHQueCwgcmVjdC5ib3R0b21SaWdodC55KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb3B5RnJvbShyZWN0YW5nbGUpIHtcbiAgICAgICAgdGhpcy5feCA9IHJlY3RhbmdsZS5feDtcbiAgICAgICAgdGhpcy5feSA9IHJlY3RhbmdsZS5feTtcbiAgICAgICAgdGhpcy5fd2lkdGggPSByZWN0YW5nbGUuX3dpZHRoO1xuICAgICAgICB0aGlzLl9oZWlnaHQgPSByZWN0YW5nbGUuX2hlaWdodDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIDtcbiAgICBlcXVhbHMocmVjdCkge1xuICAgICAgICBpZiAocmVjdC5feCA9PSB0aGlzLl94ICYmIHJlY3QuX3kgPT0gdGhpcy5feSAmJiByZWN0Ll93aWR0aCA9PSB0aGlzLl93aWR0aCAmJiByZWN0Ll9oZWlnaHQgPT0gdGhpcy5faGVpZ2h0KSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGluZmxhdGUoZHgsIGR5KSB7XG4gICAgICAgIHRoaXMuX3ggLT0gZHg7XG4gICAgICAgIHRoaXMuX3dpZHRoICs9IDIgKiBkeDtcbiAgICAgICAgdGhpcy5feSAtPSBkeTtcbiAgICAgICAgdGhpcy5faGVpZ2h0ICs9IDIgKiBkeTtcbiAgICB9XG4gICAgcGFkKHBhZGRpbmdYID0gMCwgcGFkZGluZ1kgPSAwKSB7XG4gICAgICAgIHRoaXMuX3ggLT0gcGFkZGluZ1g7XG4gICAgICAgIHRoaXMuX3kgLT0gcGFkZGluZ1k7XG4gICAgICAgIHRoaXMuX3dpZHRoICs9IHBhZGRpbmdYICogMjtcbiAgICAgICAgdGhpcy5faGVpZ2h0ICs9IHBhZGRpbmdZICogMjtcbiAgICB9XG4gICAgO1xuICAgIGluZmxhdGVQb2ludChwb2ludCkge1xuICAgICAgICB0aGlzLmluZmxhdGUocG9pbnQueCwgcG9pbnQueSk7XG4gICAgfVxuICAgIGludGVyc2VjdGlvbih0b0ludGVyc2VjdCkge1xuICAgICAgICBsZXQgeDEgPSBNYXRoLm1heCh0aGlzLl94LCB0b0ludGVyc2VjdC5feCk7XG4gICAgICAgIGxldCB4MiA9IE1hdGgubWluKHRoaXMuX3ggKyB0aGlzLl93aWR0aCwgdG9JbnRlcnNlY3QuX3ggKyB0b0ludGVyc2VjdC5fd2lkdGgpO1xuICAgICAgICBsZXQgeTEgPSBNYXRoLm1heCh0aGlzLl95LCB0b0ludGVyc2VjdC5feSk7XG4gICAgICAgIGxldCB5MiA9IE1hdGgubWluKHRoaXMuX3kgKyB0aGlzLl9oZWlnaHQsIHRvSW50ZXJzZWN0Ll95ICsgdG9JbnRlcnNlY3QuX2hlaWdodCk7XG4gICAgICAgIGxldCByZWN0ID0gbmV3IFJlY3RhbmdsZSh4MSwgeTEsIHgyLCB5Mik7XG4gICAgICAgIHJldHVybiByZWN0O1xuICAgIH1cbiAgICBpbnRlcnNlY3RzKHRvSW50ZXJzZWN0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRhaW5zKHRvSW50ZXJzZWN0Ll94LCB0b0ludGVyc2VjdC5feSk7XG4gICAgfVxuICAgIGlzRW1wdHkoKSB7XG4gICAgICAgIGlmICh0aGlzLl93aWR0aCA9PSAwICYmIHRoaXMuX2hlaWdodCA9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIG9mZnNldChkeCwgZHkpIHtcbiAgICAgICAgdGhpcy5feCA9IGR4O1xuICAgICAgICB0aGlzLl95ID0gZHk7XG4gICAgfVxuICAgIG9mZnNldFBvaW50KHBvaW50KSB7XG4gICAgICAgIHRoaXMub2Zmc2V0KHBvaW50LngsIHBvaW50LnkpO1xuICAgIH1cbiAgICBzZXRFbXB0eSgpIHtcbiAgICAgICAgdGhpcy5feCA9IHRoaXMuX3kgPSB0aGlzLl93aWR0aCA9IHRoaXMuX2hlaWdodCA9IDA7XG4gICAgfVxuICAgIGNvcHlUbyhyZWN0YW5nbGUpIHtcbiAgICAgICAgcmVjdGFuZ2xlLl94ID0gdGhpcy5feDtcbiAgICAgICAgcmVjdGFuZ2xlLl95ID0gdGhpcy5feTtcbiAgICAgICAgcmVjdGFuZ2xlLl93aWR0aCA9IHRoaXMuX3dpZHRoO1xuICAgICAgICByZWN0YW5nbGUuX2hlaWdodCA9IHRoaXMuX2hlaWdodDtcbiAgICAgICAgcmV0dXJuIHJlY3RhbmdsZTtcbiAgICB9XG4gICAgO1xuICAgIHNldFRvKHhhLCB5YSwgd2lkdGhhLCBoZWlnaHRhKSB7XG4gICAgICAgIHRoaXMucmVzZXQoeGEsIHlhLCB3aWR0aGEsIGhlaWdodGEpO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIFwieDogXCIgKyB0aGlzLl94ICsgXCIsIHk6IFwiICsgdGhpcy5feSArIFwiLCB3aWR0aDogXCIgKyB0aGlzLl93aWR0aCArIFwiLCBoZWlnaHQ6IFwiICsgdGhpcy5faGVpZ2h0O1xuICAgIH1cbiAgICB1bmlvbih0b1VuaW9uKSB7XG4gICAgICAgIGxldCB4MSA9IE1hdGgubWluKHRoaXMuX3gsIHRvVW5pb24uX3gpO1xuICAgICAgICBsZXQgeDIgPSBNYXRoLm1heCh0aGlzLl94ICsgdGhpcy5fd2lkdGgsIHRvVW5pb24uX3ggKyB0b1VuaW9uLl93aWR0aCk7XG4gICAgICAgIGxldCB5MSA9IE1hdGgubWluKHRoaXMuX3ksIHRvVW5pb24uX3kpO1xuICAgICAgICBsZXQgeTIgPSBNYXRoLm1heCh0aGlzLl95ICsgdGhpcy5faGVpZ2h0LCB0b1VuaW9uLl95ICsgdG9Vbmlvbi5faGVpZ2h0KTtcbiAgICAgICAgbGV0IHJlY3QgPSBuZXcgUmVjdGFuZ2xlKHgxLCB5MSwgeDIsIHkyKTtcbiAgICAgICAgcmV0dXJuIHJlY3Q7XG4gICAgfVxuICAgIGZpdChyZWN0YW5nbGUpIHtcbiAgICAgICAgbGV0IHgxID0gTWF0aC5tYXgodGhpcy5feCwgcmVjdGFuZ2xlLl94KTtcbiAgICAgICAgbGV0IHgyID0gTWF0aC5taW4odGhpcy5feCArIHRoaXMuX3dpZHRoLCByZWN0YW5nbGUuX3ggKyByZWN0YW5nbGUuX3dpZHRoKTtcbiAgICAgICAgbGV0IHkxID0gTWF0aC5tYXgodGhpcy5feSwgcmVjdGFuZ2xlLl95KTtcbiAgICAgICAgbGV0IHkyID0gTWF0aC5taW4odGhpcy5feSArIHRoaXMuX2hlaWdodCwgcmVjdGFuZ2xlLl95ICsgcmVjdGFuZ2xlLl9oZWlnaHQpO1xuICAgICAgICB0aGlzLl94ID0geDE7XG4gICAgICAgIHRoaXMuX3dpZHRoID0gTWF0aC5tYXgoeDIgLSB4MSwgMCk7XG4gICAgICAgIHRoaXMuX3kgPSB5MTtcbiAgICAgICAgdGhpcy5faGVpZ2h0ID0gTWF0aC5tYXgoeTIgLSB5MSwgMCk7XG4gICAgfVxuICAgIDtcbiAgICBjZWlsKHJlc29sdXRpb24gPSAxLCBlcHMgPSAwLjAwMSkge1xuICAgICAgICBsZXQgeDIgPSBNYXRoLmNlaWwoKHRoaXMuX3ggKyB0aGlzLl93aWR0aCAtIGVwcykgKiByZXNvbHV0aW9uKSAvIHJlc29sdXRpb247XG4gICAgICAgIGxldCB5MiA9IE1hdGguY2VpbCgodGhpcy5feSArIHRoaXMuX2hlaWdodCAtIGVwcykgKiByZXNvbHV0aW9uKSAvIHJlc29sdXRpb247XG4gICAgICAgIHRoaXMuX3ggPSBNYXRoLmZsb29yKCh0aGlzLl94ICsgZXBzKSAqIHJlc29sdXRpb24pIC8gcmVzb2x1dGlvbjtcbiAgICAgICAgdGhpcy5feSA9IE1hdGguZmxvb3IoKHRoaXMuX3kgKyBlcHMpICogcmVzb2x1dGlvbikgLyByZXNvbHV0aW9uO1xuICAgICAgICB0aGlzLl93aWR0aCA9IHgyIC0gdGhpcy5feDtcbiAgICAgICAgdGhpcy5faGVpZ2h0ID0geTIgLSB0aGlzLl95O1xuICAgIH1cbiAgICA7XG4gICAgZW5sYXJnZShyZWN0YW5nbGUpIHtcbiAgICAgICAgbGV0IHgxID0gTWF0aC5taW4odGhpcy5feCwgcmVjdGFuZ2xlLl94KTtcbiAgICAgICAgbGV0IHgyID0gTWF0aC5tYXgodGhpcy5feCArIHRoaXMuX3dpZHRoLCByZWN0YW5nbGUuX3ggKyByZWN0YW5nbGUuX3dpZHRoKTtcbiAgICAgICAgbGV0IHkxID0gTWF0aC5taW4odGhpcy5feSwgcmVjdGFuZ2xlLl95KTtcbiAgICAgICAgbGV0IHkyID0gTWF0aC5tYXgodGhpcy5feSArIHRoaXMuX2hlaWdodCwgcmVjdGFuZ2xlLl95ICsgcmVjdGFuZ2xlLl9oZWlnaHQpO1xuICAgICAgICB0aGlzLl94ID0geDE7XG4gICAgICAgIHRoaXMuX3dpZHRoID0geDIgLSB4MTtcbiAgICAgICAgdGhpcy5feSA9IHkxO1xuICAgICAgICB0aGlzLl9oZWlnaHQgPSB5MiAtIHkxO1xuICAgIH1cbiAgICA7XG4gICAgc3RhdGljIGdldFJlY3RhbmdsZSh4ID0gMCwgeSA9IDAsIHdpZHRoID0gMCwgaGVpZ2h0ID0gMCkge1xuICAgICAgICBpZiAoUmVjdGFuZ2xlLmNhY2hlZEluc3RhbmNlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCByID0gUmVjdGFuZ2xlLmNhY2hlZEluc3RhbmNlc1tSZWN0YW5nbGUuY2FjaGVkSW5zdGFuY2VzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgUmVjdGFuZ2xlLmNhY2hlZEluc3RhbmNlcy5sZW5ndGggLT0gMTtcbiAgICAgICAgICAgIHIucmVzZXQoeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICByZXR1cm4gcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFJlY3RhbmdsZSh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB9XG4gICAgc3RhdGljIGdldCBERUZBVUxUKCkge1xuICAgICAgICBpZiAoIVJlY3RhbmdsZS5fUmVjdCkge1xuICAgICAgICAgICAgUmVjdGFuZ2xlLl9SZWN0ID0gbmV3IFJlY3RhbmdsZSgpO1xuICAgICAgICB9XG4gICAgICAgIFJlY3RhbmdsZS5fUmVjdC5yZXNldCgpO1xuICAgICAgICByZXR1cm4gUmVjdGFuZ2xlLl9SZWN0O1xuICAgIH1cbiAgICBkZXN0cnVjdG9yKCkge1xuICAgICAgICBJbnN0YW5jZUNvdW50ZXJfMS5JbnN0YW5jZUNvdW50ZXIuZGVzdHJ1Y3RvckNvdW50KHRoaXMpO1xuICAgIH1cbiAgICByZWN5Y2xlKCkge1xuICAgICAgICBJbnN0YW5jZUNvdW50ZXJfMS5JbnN0YW5jZUNvdW50ZXIucmVjeWNsZUNvdW50KHRoaXMpO1xuICAgICAgICBsZXQgaW5kZXggPSBSZWN0YW5nbGUuY2FjaGVkSW5zdGFuY2VzLmluZGV4T2YodGhpcyk7XG4gICAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgICAgIFJlY3RhbmdsZS5jYWNoZWRJbnN0YW5jZXMudW5zaGlmdCh0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXNldCh4ID0gMCwgeSA9IDAsIHdpZHRoID0gMCwgaGVpZ2h0ID0gMCkge1xuICAgICAgICB0aGlzLl94ID0gTnVtYmVyKHgpO1xuICAgICAgICB0aGlzLl95ID0gTnVtYmVyKHkpO1xuICAgICAgICB0aGlzLl93aWR0aCA9IE51bWJlcih3aWR0aCk7XG4gICAgICAgIHRoaXMuX2hlaWdodCA9IE51bWJlcihoZWlnaHQpO1xuICAgIH1cbn1cblJlY3RhbmdsZS5jYWNoZWRJbnN0YW5jZXMgPSBbXTtcblJlY3RhbmdsZS5pbnN0YW5jZUNvdW50ID0gMDtcbmV4cG9ydHMuUmVjdGFuZ2xlID0gUmVjdGFuZ2xlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBNYXRyaXhfMSA9IHJlcXVpcmUoXCIuLi8uLi9yYXctcGl4aS10cy9NYXRyaXhcIik7XG5jb25zdCBPYnNlcnZhYmxlUG9pbnRfMSA9IHJlcXVpcmUoXCIuLi8uLi9yYXctcGl4aS10cy9PYnNlcnZhYmxlUG9pbnRcIik7XG5jb25zdCBGbGFzaEJhc2VPYmplY3RfMSA9IHJlcXVpcmUoXCIuLi8uLi9yYXctcGl4aS10cy9GbGFzaEJhc2VPYmplY3RcIik7XG5jbGFzcyBUcmFuc2Zvcm0gZXh0ZW5kcyBGbGFzaEJhc2VPYmplY3RfMS5GbGFzaEJhc2VPYmplY3Qge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLndvcmxkVHJhbnNmb3JtID0gbmV3IE1hdHJpeF8xLk1hdHJpeCgpO1xuICAgICAgICB0aGlzLmxvY2FsVHJhbnNmb3JtID0gbmV3IE1hdHJpeF8xLk1hdHJpeCgpO1xuICAgICAgICB0aGlzLnBvc2l0aW9uID0gbmV3IE9ic2VydmFibGVQb2ludF8xLk9ic2VydmFibGVQb2ludCgwLCAwKTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbi5zY29wZSA9IHRoaXM7XG4gICAgICAgIHRoaXMucG9zaXRpb24uY2FsbGJhY2sgPSB0aGlzLm9uQ2hhbmdlO1xuICAgICAgICB0aGlzLnNjYWxlID0gbmV3IE9ic2VydmFibGVQb2ludF8xLk9ic2VydmFibGVQb2ludCgxLCAxKTtcbiAgICAgICAgdGhpcy5zY2FsZS5zY29wZSA9IHRoaXM7XG4gICAgICAgIHRoaXMuc2NhbGUuY2FsbGJhY2sgPSB0aGlzLm9uQ2hhbmdlO1xuICAgICAgICB0aGlzLnBpdm90ID0gbmV3IE9ic2VydmFibGVQb2ludF8xLk9ic2VydmFibGVQb2ludCgwLCAwKTtcbiAgICAgICAgdGhpcy5waXZvdC5zY29wZSA9IHRoaXM7XG4gICAgICAgIHRoaXMucGl2b3QuY2FsbGJhY2sgPSB0aGlzLm9uQ2hhbmdlO1xuICAgICAgICB0aGlzLnNrZXcgPSBuZXcgT2JzZXJ2YWJsZVBvaW50XzEuT2JzZXJ2YWJsZVBvaW50KDAsIDApO1xuICAgICAgICB0aGlzLnNrZXcuc2NvcGUgPSB0aGlzO1xuICAgICAgICB0aGlzLnNrZXcuY2FsbGJhY2sgPSB0aGlzLnVwZGF0ZVNrZXc7XG4gICAgICAgIHRoaXMuX3JvdGF0aW9uID0gMDtcbiAgICAgICAgdGhpcy5fY3ggPSAxO1xuICAgICAgICB0aGlzLl9zeCA9IDA7XG4gICAgICAgIHRoaXMuX2N5ID0gMDtcbiAgICAgICAgdGhpcy5fc3kgPSAxO1xuICAgICAgICB0aGlzLl9sb2NhbElEID0gMDtcbiAgICAgICAgdGhpcy5fY3VycmVudExvY2FsSUQgPSAwO1xuICAgICAgICB0aGlzLl93b3JsZElEID0gMDtcbiAgICAgICAgdGhpcy5fcGFyZW50SUQgPSAwO1xuICAgIH1cbiAgICBnZXQgcGl4ZWxCb3VuZHMoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvLyBwdWJsaWMgZ2V0IG1hdHJpeCgpOk1hdHJpeFxuICAgIC8vIHtcbiAgICAvLyBcdHJldHVybiBudWxsO1xuICAgIC8vIH1cbiAgICAvLyBwdWJsaWMgc2V0IG1hdHJpeCh2YWx1ZTpNYXRyaXgpXG4gICAgLy8ge1xuICAgIC8vIH1cbiAgICAvLyBwdWJsaWMgZ2V0IGNvbmNhdGVuYXRlZE1hdHJpeCgpOk1hdHJpeFxuICAgIC8vIHtcbiAgICAvLyBcdHJldHVybiBudWxsO1xuICAgIC8vIH1cbiAgICAvLyBwdWJsaWMgZ2V0IGNvbmNhdGVuYXRlZENvbG9yVHJhbnNmb3JtKCk6Q29sb3JUcmFuc2Zvcm1cbiAgICAvLyB7XG4gICAgLy8gXHRyZXR1cm4gbnVsbDtcbiAgICAvLyB9XG4gICAgLy8gcHVibGljIGdldCBjb2xvclRyYW5zZm9ybSgpOkNvbG9yVHJhbnNmb3JtXG4gICAgLy8ge1xuICAgIC8vIFx0cmV0dXJuIG51bGw7XG4gICAgLy8gfVxuICAgIC8vIHB1YmxpYyBzZXQgY29sb3JUcmFuc2Zvcm0odmFsdWU6Q29sb3JUcmFuc2Zvcm0pXG4gICAgLy8ge1xuICAgIC8vIH1cbiAgICBnZXQgcm90YXRpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yb3RhdGlvbjtcbiAgICB9XG4gICAgO1xuICAgIHNldCByb3RhdGlvbih2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5fcm90YXRpb24gIT09IHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9yb3RhdGlvbiA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVTa2V3KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xuICAgIHNldEZyb21NYXRyaXgobWF0cml4KSB7XG4gICAgICAgIG1hdHJpeC5kZWNvbXBvc2UodGhpcyk7XG4gICAgICAgIHRoaXMuX2xvY2FsSUQrKztcbiAgICB9XG4gICAgO1xuICAgIHVwZGF0ZVRyYW5zZm9ybShwYXJlbnRUcmFuc2Zvcm0pIHtcbiAgICAgICAgbGV0IGx0ID0gdGhpcy5sb2NhbFRyYW5zZm9ybTtcbiAgICAgICAgaWYgKHRoaXMuX2xvY2FsSUQgIT09IHRoaXMuX2N1cnJlbnRMb2NhbElEKSB7XG4gICAgICAgICAgICBsdC5hID0gdGhpcy5fY3ggKiB0aGlzLnNjYWxlLng7XG4gICAgICAgICAgICBsdC5iID0gdGhpcy5fc3ggKiB0aGlzLnNjYWxlLng7XG4gICAgICAgICAgICBsdC5jID0gdGhpcy5fY3kgKiB0aGlzLnNjYWxlLnk7XG4gICAgICAgICAgICBsdC5kID0gdGhpcy5fc3kgKiB0aGlzLnNjYWxlLnk7XG4gICAgICAgICAgICBsdC50eCA9IHRoaXMucG9zaXRpb24ueCAtICgodGhpcy5waXZvdC54ICogbHQuYSkgKyAodGhpcy5waXZvdC55ICogbHQuYykpO1xuICAgICAgICAgICAgbHQudHkgPSB0aGlzLnBvc2l0aW9uLnkgLSAoKHRoaXMucGl2b3QueCAqIGx0LmIpICsgKHRoaXMucGl2b3QueSAqIGx0LmQpKTtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRMb2NhbElEID0gdGhpcy5fbG9jYWxJRDtcbiAgICAgICAgICAgIHRoaXMuX3BhcmVudElEID0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3BhcmVudElEICE9PSBwYXJlbnRUcmFuc2Zvcm0uX3dvcmxkSUQpIHtcbiAgICAgICAgICAgIGxldCBwdCA9IHBhcmVudFRyYW5zZm9ybS53b3JsZFRyYW5zZm9ybTtcbiAgICAgICAgICAgIGxldCB3dCA9IHRoaXMud29ybGRUcmFuc2Zvcm07XG4gICAgICAgICAgICB3dC5hID0gKGx0LmEgKiBwdC5hKSArIChsdC5iICogcHQuYyk7XG4gICAgICAgICAgICB3dC5iID0gKGx0LmEgKiBwdC5iKSArIChsdC5iICogcHQuZCk7XG4gICAgICAgICAgICB3dC5jID0gKGx0LmMgKiBwdC5hKSArIChsdC5kICogcHQuYyk7XG4gICAgICAgICAgICB3dC5kID0gKGx0LmMgKiBwdC5iKSArIChsdC5kICogcHQuZCk7XG4gICAgICAgICAgICB3dC50eCA9IChsdC50eCAqIHB0LmEpICsgKGx0LnR5ICogcHQuYykgKyBwdC50eDtcbiAgICAgICAgICAgIHd0LnR5ID0gKGx0LnR4ICogcHQuYikgKyAobHQudHkgKiBwdC5kKSArIHB0LnR5O1xuICAgICAgICAgICAgdGhpcy5fcGFyZW50SUQgPSBwYXJlbnRUcmFuc2Zvcm0uX3dvcmxkSUQ7XG4gICAgICAgICAgICB0aGlzLl93b3JsZElEKys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xuICAgIG9uQ2hhbmdlKCkge1xuICAgICAgICB0aGlzLl9sb2NhbElEKys7XG4gICAgfVxuICAgIDtcbiAgICB1cGRhdGVTa2V3KCkge1xuICAgICAgICB0aGlzLl9jeCA9IE1hdGguY29zKHRoaXMuX3JvdGF0aW9uICsgdGhpcy5za2V3LnkpO1xuICAgICAgICB0aGlzLl9zeCA9IE1hdGguc2luKHRoaXMuX3JvdGF0aW9uICsgdGhpcy5za2V3LnkpO1xuICAgICAgICB0aGlzLl9jeSA9IC1NYXRoLnNpbih0aGlzLl9yb3RhdGlvbiAtIHRoaXMuc2tldy54KTtcbiAgICAgICAgdGhpcy5fc3kgPSBNYXRoLmNvcyh0aGlzLl9yb3RhdGlvbiAtIHRoaXMuc2tldy54KTtcbiAgICAgICAgdGhpcy5fbG9jYWxJRCsrO1xuICAgIH1cbiAgICA7XG4gICAgdXBkYXRlTG9jYWxUcmFuc2Zvcm0oKSB7XG4gICAgICAgIGxldCBsdCA9IHRoaXMubG9jYWxUcmFuc2Zvcm07XG4gICAgICAgIGlmICh0aGlzLl9sb2NhbElEICE9PSB0aGlzLl9jdXJyZW50TG9jYWxJRCkge1xuICAgICAgICAgICAgbHQuYSA9IHRoaXMuX2N4ICogdGhpcy5zY2FsZS54O1xuICAgICAgICAgICAgbHQuYiA9IHRoaXMuX3N4ICogdGhpcy5zY2FsZS54O1xuICAgICAgICAgICAgbHQuYyA9IHRoaXMuX2N5ICogdGhpcy5zY2FsZS55O1xuICAgICAgICAgICAgbHQuZCA9IHRoaXMuX3N5ICogdGhpcy5zY2FsZS55O1xuICAgICAgICAgICAgbHQudHggPSB0aGlzLnBvc2l0aW9uLnggLSAoKHRoaXMucGl2b3QueCAqIGx0LmEpICsgKHRoaXMucGl2b3QueSAqIGx0LmMpKTtcbiAgICAgICAgICAgIGx0LnR5ID0gdGhpcy5wb3NpdGlvbi55IC0gKCh0aGlzLnBpdm90LnggKiBsdC5iKSArICh0aGlzLnBpdm90LnkgKiBsdC5kKSk7XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50TG9jYWxJRCA9IHRoaXMuX2xvY2FsSUQ7XG4gICAgICAgICAgICB0aGlzLl9wYXJlbnRJRCA9IC0xO1xuICAgICAgICB9XG4gICAgfVxuICAgIDtcbiAgICBnZXQgd29ybGRJRCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dvcmxkSUQ7XG4gICAgfVxuICAgIHNldCBwYXJlbnRJRCh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9wYXJlbnRJRCA9IHZhbHVlO1xuICAgIH1cbn1cbmV4cG9ydHMuVHJhbnNmb3JtID0gVHJhbnNmb3JtO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBBcHBsaWNhdGlvbl8xID0gcmVxdWlyZShcIi4vcmF3LXBpeGktdHMvQXBwbGljYXRpb25cIik7XG5jb25zdCBTdGFnZU9wdGlvbnNfMSA9IHJlcXVpcmUoXCIuL3Jhdy1waXhpLXRzL1N0YWdlT3B0aW9uc1wiKTtcbmNvbnN0IEV4YW1wbGVEaXNwbGF5XzEgPSByZXF1aXJlKFwiLi9leGFtcGxlcy9jb250cm9scy9FeGFtcGxlRGlzcGxheVwiKTtcbndpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCAoKSA9PiB7XG4gICAgdmFyIG9wdGlvbnMgPSBuZXcgU3RhZ2VPcHRpb25zXzEuU3RhZ2VPcHRpb25zKCk7XG4gICAgb3B0aW9ucy53aWR0aCA9IDEwMDA7XG4gICAgb3B0aW9ucy5oZWlnaHQgPSA2MDA7XG4gICAgb3B0aW9ucy5hdXRvUmVzaXplID0gZmFsc2U7XG4gICAgb3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3IgPSAweDAwMDAwMDAwO1xuICAgIG9wdGlvbnMuY2xlYXJCZWZvcmVSZW5kZXIgPSB0cnVlO1xuICAgIG9wdGlvbnMucmVzb2x1dGlvbiA9IDE7XG4gICAgb3B0aW9ucy5hdXRvU3RhcnQgPSB0cnVlO1xuICAgIG9wdGlvbnMudHJhbnNwYXJlbnQgPSB0cnVlO1xuICAgIG9wdGlvbnMuYW50aWFsaWFzID0gdHJ1ZTtcbiAgICBvcHRpb25zLnZpZXcgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImZha2VjYW52YXNcIik7XG4gICAgdmFyIGFwcCA9IG5ldyBBcHBsaWNhdGlvbl8xLkFwcGxpY2F0aW9uKG9wdGlvbnMpO1xuICAgIGxldCBkaXNwbGF5ID0gbmV3IEV4YW1wbGVEaXNwbGF5XzEuRXhhbXBsZURpc3BsYXkoYXBwLCAxMDI0LCA3NjgpO1xuICAgIGFwcC5zdGFnZS5hZGRDaGlsZChkaXNwbGF5KTtcbiAgICAvLyBjcmVhdGUgYSB2aWV3IGNsYXNzIHdpdGggZnJhbWVcbiAgICAvLyBjcmVhdGUgYSBjb250cm9sIGNsYXNzIHdpdGggYnV0dG9uc1xuICAgIC8vIGVhY2ggYnV0dG9uIGNsaWNrIGNoYW5nZSBjb250ZW50IG9mIGNsYXNzIGZyYW1lXG4gICAgLy8gbGV0IGJ1dHRvbjpCdXR0b24gPSBuZXcgQnV0dG9uKFwiVGVzdFwiLCAyMDAsIDQwKTtcbiAgICAvLyBhcHAuc3RhZ2UuYWRkQ2hpbGQoYnV0dG9uKTtcbiAgICAvLyBidXR0b24ueCA9IDgwMDtcbiAgICAvLyBsZXQgZXhhbXBsZTpCYXNpY0NhY2hlID0gbmV3IEJhc2ljQ2FjaGUoYXBwKTsgTk9UIFdPUktJTkdcbiAgICAvLyBsZXQgZXhhbXBsZTpJbnRlcmFjdGlvbkljb24gPSBuZXcgSW50ZXJhY3Rpb25JY29uKGFwcCk7XG4gICAgLy8gbGV0IGV4YW1wbGU6U3ByaXRlVmlkZW8gPSBuZXcgU3ByaXRlVmlkZW8oYXBwKTtcbiAgICAvLyBsZXQgZXhhbXBsZTpBZHZhbmNlZFNsb3RzID0gbmV3IEFkdmFuY2VkU2xvdHMoYXBwKTsgXG4gICAgLy8gbGV0IGV4YW1wbGU6VGV4dHVyZVJvdGF0ZSA9IG5ldyBUZXh0dXJlUm90YXRlKGFwcCk7IFxuICAgIC8vIGxldCBleGFtcGxlOkJhc2ljQ29udGFpbmVyID0gbmV3IEJhc2ljQ29udGFpbmVyKGFwcCk7XG4gICAgLy8gbGV0IGV4YW1wbGU6QmFzaWNCYWNrZ3JvdW5kID0gbmV3IEJhc2ljQmFja2dyb3VuZChhcHApO1xuICAgIC8vIGxldCBleGFtcGxlOkJhc2ljVGludGluZyA9IG5ldyBCYXNpY1RpbnRpbmcoYXBwKTsgICAgXG4gICAgLy8gbGV0IGV4YW1wbGU6QmFzaWNQYXJ0aWNsZXMgPSBuZXcgQmFzaWNQYXJ0aWNsZXMoYXBwKTtcbiAgICAvLyBsZXQgZXhhbXBsZTpCYXNpY0JsZW5kID0gbmV3IEJhc2ljQmxlbmQoYXBwKTsgICAgXG4gICAgLy8gbGV0IGV4YW1wbGU6R3JhcGhpY3NTaW1wbGUgPSBuZXcgR3JhcGhpY3NTaW1wbGUoYXBwKTtcbiAgICAvLyBsZXQgZXhhbXBsZTpHcmFwaGljc0FkdmFuY2VkID0gbmV3IEdyYXBoaWNzQWR2YW5jZWQoYXBwKTtcbiAgICAvLyBsZXQgZXhhbXBsZTpHcmFwaGljc0R5bmFtaWMgPSBuZXcgR3JhcGhpY3NEeW5hbWljKGFwcCk7XG4gICAgLy8gbGV0IGV4YW1wbGU6VGV4dHVyZVJlbmRlciA9IG5ldyBUZXh0dXJlUmVuZGVyKGFwcCk7XG4gICAgLy8gbGV0IGV4YW1wbGU6VGV4dHVyZUFkdmFuY2VkID0gbmV3IFRleHR1cmVBZHZhbmNlZChhcHApO1xuICAgIC8vIGxldCBleGFtcGxlOlRleHR1cmVHcmFkaWVudEJhc2ljID0gbmV3IFRleHR1cmVHcmFkaWVudEJhc2ljKGFwcCk7XG4gICAgLy8gbGV0IGV4YW1wbGU6VGV4dHVyZUdyYWRpZW50UmVzb3VyY2UgPSBuZXcgVGV4dHVyZUdyYWRpZW50UmVzb3VyY2UoYXBwKTtcbiAgICAvLyBsZXQgZXhhbXBsZTpUZXh0QmFzZSA9IG5ldyBUZXh0QmFzZShhcHApO1xuICAgIC8vIGxldCBleGFtcGxlOlRleHRCaXRtYXAgPSBuZXcgVGV4dEJpdG1hcChhcHApOyBcbiAgICAvLyBsZXQgZXhhbXBsZTpUZXh0V2ViRm9udCA9IG5ldyBUZXh0V2ViRm9udChhcHApOyBcbiAgICAvLyBsZXQgZXhhbXBsZTpNYXNrR3JhcGhpY3MgPSBuZXcgTWFza0dyYXBoaWNzKGFwcCk7XG4gICAgLy8gbGV0IGV4YW1wbGU6TWFza1Nwcml0ZSA9IG5ldyBNYXNrU3ByaXRlKGFwcCk7XG4gICAgLy8gbGV0IGV4YW1wbGU6RmlsdGVyQmx1ciA9IG5ldyBGaWx0ZXJCbHVyKGFwcCk7XG4gICAgLy8gbGV0IGV4YW1wbGU6RmlsdGVyQ29sb3IgPSBuZXcgRmlsdGVyQ29sb3IoYXBwKTtcbiAgICAvLyBsZXQgZXhhbXBsZTpGaWx0ZXJDcmF3bGllcyA9IG5ldyBGaWx0ZXJDcmF3bGllcyhhcHApO1xuICAgIC8vIGxldCBleGFtcGxlOkZpbHRlckZsYWcgPSBuZXcgRmlsdGVyRmxhZyhhcHApO1xuICAgIC8vIGxldCBleGFtcGxlOk1hc2tGaWx0ZXIgPSBuZXcgTWFza0ZpbHRlcihhcHApO1xuICAgIC8vIGxldCBleGFtcGxlOkludGVyYWN0aW9uQ2xpY2sgPSBuZXcgSW50ZXJhY3Rpb25DbGljayhhcHApO1xuICAgIC8vIGxldCBleGFtcGxlOkludGVyYWN0aW9uSW50ZXJhY3Rpdml0eSA9IG5ldyBJbnRlcmFjdGlvbkludGVyYWN0aXZpdHkoYXBwKTtcbiAgICAvLyBsZXQgZXhhbXBsZTpJbnRlcmFjdGlvbkRyYWdnaW5nID0gbmV3IEludGVyYWN0aW9uRHJhZ2dpbmcoYXBwKTsgXG4gICAgLy8gbGV0IGV4YW1wbGU6U3ByaXRlQmFzaWMgPSBuZXcgU3ByaXRlQmFzaWMoYXBwKTsgIFxuICAgIC8vIGxldCBleGFtcGxlOlNwcml0ZVN3YXAgPSBuZXcgU3ByaXRlU3dhcChhcHApOyAgICBcbiAgICAvLyBsZXQgZXhhbXBsZTpTcHJpdGVUaWxpbmcgPSBuZXcgU3ByaXRlVGlsaW5nKGFwcCk7ICAgIFxuICAgIC8vIGxldCBleGFtcGxlOlNwcml0ZUV4cGxvc2lvbiA9IG5ldyBTcHJpdGVFeHBsb3Npb24oYXBwKTtcbiAgICAvLyBsZXQgZXhhbXBsZTpTcHJpdGVqZXQgPSBuZXcgU3ByaXRlamV0KGFwcCk7IFxuICAgIC8vIGxldCBleGFtcGxlOlNwcml0ZVNwZWVkID0gbmV3IFNwcml0ZVNwZWVkKGFwcCk7IFxuICAgIC8vIGxldCBleGFtcGxlOkFkdmFuY2VkQ2FyZCA9IG5ldyBBZHZhbmNlZENhcmQoYXBwKTsgXG4gICAgLy8gbGV0IGV4YW1wbGU6QWR2YW5jZWRUcmFpbCA9IG5ldyBBZHZhbmNlZFRyYWlsKGFwcCk7IFxuICAgIC8vIGxldCBleGFtcGxlOkFkdmFuY2VkV2FycCA9IG5ldyBBZHZhbmNlZFdhcnAoYXBwKTsgXG4gICAgLy8gbGV0IGV4YW1wbGU6RmlsdGVyQmxlbmRpbmcgPSBuZXcgRmlsdGVyQmxlbmRpbmcoYXBwKTsgXG4gICAgLy8gbGV0IGV4YW1wbGU6RmlsdGVyQ3VzdG9tID0gbmV3IEZpbHRlckN1c3RvbShhcHApOyBcbiAgICAvLyBsZXQgZXhhbXBsZTpGaWx0ZXJTaGFkb3cgPSBuZXcgRmlsdGVyU2hhZG93KGFwcCk7IFxuICAgIC8vIGxldCBleGFtcGxlOk1lc2hCYXNpYyA9IG5ldyBNZXNoQmFzaWMoYXBwKTtcbiAgICAvLyBsZXQgZXhhbXBsZTpNZXNoQWR2YW5jZWQgPSBuZXcgTWVzaEFkdmFuY2VkKGFwcCk7XG4gICAgLy8gbGV0IGV4YW1wbGU6TWVzaFRyaWFuZ2xlID0gbmV3IE1lc2hUcmlhbmdsZShhcHApO1xuICAgIC8vIGxldCBleGFtcGxlOk1lc2hDb2xvcmVkVHJpYW5nbGUgPSBuZXcgTWVzaENvbG9yZWRUcmlhbmdsZShhcHApO1xuICAgIC8vIGxldCBleGFtcGxlOk1lc2hUZXh0dXJlZCA9IG5ldyBNZXNoVGV4dHVyZWQoYXBwKTtcbiAgICAvLyBsZXQgZXhhbXBsZTpNZXNoVW5pZm9ybXMgPSBuZXcgTWVzaFVuaWZvcm1zKGFwcCk7XG4gICAgLy8gbGV0IGV4YW1wbGU6TWVzaEdlb21ldHJ5ID0gbmV3IE1lc2hHZW9tZXRyeShhcHApO1xuICAgIC8vIGxldCBleGFtcGxlOk1lc2hTaGFkZXIgPSBuZXcgTWVzaFNoYWRlcihhcHApO1xufSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IEV2ZW50RGlzcGF0Y2hlcl8xID0gcmVxdWlyZShcIi4vRXZlbnREaXNwYXRjaGVyXCIpO1xuY29uc3QgTWF0cml4XzEgPSByZXF1aXJlKFwiLi9NYXRyaXhcIik7XG5jb25zdCBSZWN0YW5nbGVfMSA9IHJlcXVpcmUoXCIuLi9mbGFzaC9nZW9tL1JlY3RhbmdsZVwiKTtcbmNvbnN0IFJlbmRlclRleHR1cmVfMSA9IHJlcXVpcmUoXCIuL1JlbmRlclRleHR1cmVcIik7XG5jb25zdCBDb250YWluZXJfMSA9IHJlcXVpcmUoXCIuL0NvbnRhaW5lclwiKTtcbmNvbnN0IERpc3BsYXlTZXR0aW5nc18xID0gcmVxdWlyZShcIi4vRGlzcGxheVNldHRpbmdzXCIpO1xuY29uc3QgTWF0aFNldHRpbmdzXzEgPSByZXF1aXJlKFwiLi9NYXRoU2V0dGluZ3NcIik7XG5jb25zdCBDb2xvclNldHRpbmdzXzEgPSByZXF1aXJlKFwiLi9Db2xvclNldHRpbmdzXCIpO1xuY29uc3QgSW5zdGFuY2VDb3VudGVyXzEgPSByZXF1aXJlKFwiLi9JbnN0YW5jZUNvdW50ZXJcIik7XG5jbGFzcyBBYnN0cmFjdFJlbmRlcmVyIGV4dGVuZHMgRXZlbnREaXNwYXRjaGVyXzEuRXZlbnREaXNwYXRjaGVyIHtcbiAgICBjb25zdHJ1Y3RvcihzeXN0ZW0sIG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgaWYgKG9wdGlvbnMucm91bmRQaXhlbHMpIHtcbiAgICAgICAgICAgIERpc3BsYXlTZXR0aW5nc18xLkRpc3BsYXlTZXR0aW5ncy5ST1VORF9QSVhFTFMgPSBvcHRpb25zLnJvdW5kUGl4ZWxzO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMudHlwZSA9IERpc3BsYXlTZXR0aW5nc18xLkRpc3BsYXlTZXR0aW5ncy5SRU5ERVJFUl9UWVBFLlVOS05PV047XG4gICAgICAgIEluc3RhbmNlQ291bnRlcl8xLkluc3RhbmNlQ291bnRlci5hZGRDYWxsKFwiUmVjdGFuZ2xlLmdldFJlY3RhbmdsZVwiLCBcIkFic3RyYWN0UmVuZGVyZXJcIik7XG4gICAgICAgIHRoaXMuc2NyZWVuID0gUmVjdGFuZ2xlXzEuUmVjdGFuZ2xlLmdldFJlY3RhbmdsZSgwLCAwLCBvcHRpb25zLndpZHRoLCBvcHRpb25zLmhlaWdodCk7XG4gICAgICAgIHRoaXMudmlldyA9IG9wdGlvbnMudmlldyB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgdGhpcy5yZXNvbHV0aW9uID0gb3B0aW9ucy5yZXNvbHV0aW9uIHx8IERpc3BsYXlTZXR0aW5nc18xLkRpc3BsYXlTZXR0aW5ncy5SRVNPTFVUSU9OO1xuICAgICAgICB0aGlzLnRyYW5zcGFyZW50ID0gb3B0aW9ucy50cmFuc3BhcmVudDtcbiAgICAgICAgdGhpcy5hdXRvRGVuc2l0eSA9IG9wdGlvbnMuYXV0b0RlbnNpdHkgfHwgb3B0aW9ucy5hdXRvUmVzaXplIHx8IGZhbHNlO1xuICAgICAgICB0aGlzLnByZXNlcnZlRHJhd2luZ0J1ZmZlciA9IG9wdGlvbnMucHJlc2VydmVEcmF3aW5nQnVmZmVyO1xuICAgICAgICB0aGlzLmNsZWFyQmVmb3JlUmVuZGVyID0gb3B0aW9ucy5jbGVhckJlZm9yZVJlbmRlcjtcbiAgICAgICAgdGhpcy5fYmFja2dyb3VuZENvbG9yID0gMHgwMDAwMDA7XG4gICAgICAgIHRoaXMuX2JhY2tncm91bmRDb2xvclJnYmEgPSBbMCwgMCwgMCwgMF07XG4gICAgICAgIHRoaXMuX2JhY2tncm91bmRDb2xvclN0cmluZyA9ICcjMDAwMDAwJztcbiAgICAgICAgdGhpcy5iYWNrZ3JvdW5kQ29sb3IgPSBvcHRpb25zLmJhY2tncm91bmRDb2xvciB8fCB0aGlzLl9iYWNrZ3JvdW5kQ29sb3I7XG4gICAgICAgIHRoaXMuX3RlbXBEaXNwbGF5T2JqZWN0UGFyZW50ID0gbmV3IENvbnRhaW5lcl8xLkNvbnRhaW5lcigpO1xuICAgICAgICB0aGlzLl9sYXN0T2JqZWN0UmVuZGVyZWQgPSB0aGlzLl90ZW1wRGlzcGxheU9iamVjdFBhcmVudDtcbiAgICAgICAgdGhpcy5ibGVuZE1vZGVzID0gMDtcbiAgICB9XG4gICAgcmVzaXplKHNjcmVlbldpZHRoLCBzY3JlZW5IZWlnaHQpIHtcbiAgICAgICAgdGhpcy5zY3JlZW4ud2lkdGggPSBzY3JlZW5XaWR0aDtcbiAgICAgICAgdGhpcy5zY3JlZW4uaGVpZ2h0ID0gc2NyZWVuSGVpZ2h0O1xuICAgICAgICB0aGlzLnZpZXcud2lkdGggPSBzY3JlZW5XaWR0aCAqIHRoaXMucmVzb2x1dGlvbjtcbiAgICAgICAgdGhpcy52aWV3LmhlaWdodCA9IHNjcmVlbkhlaWdodCAqIHRoaXMucmVzb2x1dGlvbjtcbiAgICAgICAgaWYgKHRoaXMuYXV0b0RlbnNpdHkpIHtcbiAgICAgICAgICAgIHRoaXMudmlldy5zdHlsZS53aWR0aCA9IHNjcmVlbldpZHRoICsgXCJweFwiO1xuICAgICAgICAgICAgdGhpcy52aWV3LnN0eWxlLmhlaWdodCA9IHNjcmVlbkhlaWdodCArIFwicHhcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICA7XG4gICAgZ2V0IHdpZHRoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3LndpZHRoO1xuICAgIH1cbiAgICA7XG4gICAgZ2V0IGhlaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlldy5oZWlnaHQ7XG4gICAgfVxuICAgIDtcbiAgICBnZW5lcmF0ZVRleHR1cmUoZGlzcGxheU9iamVjdCwgc2NhbGVNb2RlLCByZXNvbHV0aW9uLCByZWdpb24pIHtcbiAgICAgICAgcmVnaW9uID0gcmVnaW9uIHx8IGRpc3BsYXlPYmplY3QuZ2V0TG9jYWxCb3VuZHMoKTtcbiAgICAgICAgaWYgKHJlZ2lvbi53aWR0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmVnaW9uLndpZHRoID0gMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVnaW9uLmhlaWdodCA9PT0gMCkge1xuICAgICAgICAgICAgcmVnaW9uLmhlaWdodCA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlbmRlclRleHR1cmUgPSBSZW5kZXJUZXh0dXJlXzEuUmVuZGVyVGV4dHVyZS5jcmVhdGUocmVnaW9uLndpZHRoIHwgMCwgcmVnaW9uLmhlaWdodCB8IDAsIHNjYWxlTW9kZSwgcmVzb2x1dGlvbik7XG4gICAgICAgIEFic3RyYWN0UmVuZGVyZXIudGVtcE1hdHJpeC50eCA9IC1yZWdpb24ueDtcbiAgICAgICAgQWJzdHJhY3RSZW5kZXJlci50ZW1wTWF0cml4LnR5ID0gLXJlZ2lvbi55O1xuICAgICAgICB0aGlzLnJlbmRlcihkaXNwbGF5T2JqZWN0LCByZW5kZXJUZXh0dXJlLCBmYWxzZSwgQWJzdHJhY3RSZW5kZXJlci50ZW1wTWF0cml4LCAhIWRpc3BsYXlPYmplY3QucGFyZW50KTtcbiAgICAgICAgcmV0dXJuIHJlbmRlclRleHR1cmU7XG4gICAgfVxuICAgIDtcbiAgICByZW5kZXIoZGlzcGxheU9iamVjdCwgcmVuZGVyVGV4dHVyZSwgYiwgbSwgcGFyZW50KSB7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgZXZlcnl0aGluZyBmcm9tIHRoZSByZW5kZXJlciBhbmQgb3B0aW9uYWxseSByZW1vdmVzIHRoZSBDYW52YXMgRE9NIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtyZW1vdmVWaWV3PWZhbHNlXSAtIFJlbW92ZXMgdGhlIENhbnZhcyBlbGVtZW50IGZyb20gdGhlIERPTS5cbiAgICAgKi9cbiAgICBkZXN0cm95KHJlbW92ZVZpZXcpIHtcbiAgICAgICAgLy8gZm9yICh2YXIgbyBpbiB0aGlzLnBsdWdpbnMpXG4gICAgICAgIC8vIHtcbiAgICAgICAgLy8gICAgIHRoaXMucGx1Z2luc1tvXS5kZXN0cm95KCk7XG4gICAgICAgIC8vICAgICB0aGlzLnBsdWdpbnNbb10gPSBudWxsO1xuICAgICAgICAvLyB9XG4gICAgICAgIGlmIChyZW1vdmVWaWV3ICYmIHRoaXMudmlldy5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICB0aGlzLnZpZXcucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLnZpZXcpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRoaXMucGx1Z2lucyA9IG51bGw7XG4gICAgICAgIHRoaXMudHlwZSA9IERpc3BsYXlTZXR0aW5nc18xLkRpc3BsYXlTZXR0aW5ncy5SRU5ERVJFUl9UWVBFLlVOS05PV047XG4gICAgICAgIHRoaXMudmlldyA9IG51bGw7XG4gICAgICAgIHRoaXMuc2NyZWVuID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZXNvbHV0aW9uID0gMDtcbiAgICAgICAgdGhpcy50cmFuc3BhcmVudCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmF1dG9EZW5zaXR5ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYmxlbmRNb2RlcyA9IG51bGw7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG51bGw7XG4gICAgICAgIHRoaXMucHJlc2VydmVEcmF3aW5nQnVmZmVyID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY2xlYXJCZWZvcmVSZW5kZXIgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fYmFja2dyb3VuZENvbG9yID0gMDtcbiAgICAgICAgdGhpcy5fYmFja2dyb3VuZENvbG9yUmdiYSA9IG51bGw7XG4gICAgICAgIHRoaXMuX2JhY2tncm91bmRDb2xvclN0cmluZyA9IG51bGw7XG4gICAgICAgIHRoaXMuX3RlbXBEaXNwbGF5T2JqZWN0UGFyZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fbGFzdE9iamVjdFJlbmRlcmVkID0gbnVsbDtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFRoZSBiYWNrZ3JvdW5kIGNvbG9yIHRvIGZpbGwgaWYgbm90IHRyYW5zcGFyZW50XG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICovXG4gICAgZ2V0IGJhY2tncm91bmRDb2xvcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2JhY2tncm91bmRDb2xvcjtcbiAgICB9XG4gICAgO1xuICAgIHNldCBiYWNrZ3JvdW5kQ29sb3IodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fYmFja2dyb3VuZENvbG9yID0gdmFsdWU7XG4gICAgICAgIHRoaXMuX2JhY2tncm91bmRDb2xvclN0cmluZyA9IE1hdGhTZXR0aW5nc18xLk1hdGhTZXR0aW5ncy5oZXgyc3RyaW5nKHZhbHVlKTtcbiAgICAgICAgQ29sb3JTZXR0aW5nc18xLkNvbG9yU2V0dGluZ3MuaGV4MnJnYih2YWx1ZSwgdGhpcy5fYmFja2dyb3VuZENvbG9yUmdiYSk7XG4gICAgfVxuICAgIDtcbn1cbkFic3RyYWN0UmVuZGVyZXIudGVtcE1hdHJpeCA9IG5ldyBNYXRyaXhfMS5NYXRyaXgoKTtcbmV4cG9ydHMuQWJzdHJhY3RSZW5kZXJlciA9IEFic3RyYWN0UmVuZGVyZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8vIGltcG9ydCB7IHNldHRpbmdzIH0gZnJvbSAnLi9zZXR0aW5ncyc7XG5jb25zdCBVdGlsc1NldHRpbmdzXzEgPSByZXF1aXJlKFwiLi9VdGlsc1NldHRpbmdzXCIpO1xuY2xhc3MgQWNjZXNzaWJpbGl0eU1hbmFnZXIge1xuICAgIGNvbnN0cnVjdG9yKHJlbmRlcmVyKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIEB0eXBlIHs/SFRNTEVsZW1lbnR9XG4gICAgICAgICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5faG9va0RpdiA9IG51bGw7XG4gICAgICAgIC8vIGlmIChzZXR0aW5ncy5pc01vYmlsZV9taW4udGFibGV0IHx8IHNldHRpbmdzLmlzTW9iaWxlX21pbi5waG9uZSlcbiAgICAgICAgLy8ge1xuICAgICAgICB0aGlzLmNyZWF0ZVRvdWNoSG9vaygpO1xuICAgICAgICAvLyB9XG4gICAgICAgIC8vIGZpcnN0IHdlIGNyZWF0ZSBhIGRpdiB0aGF0IHdpbGwgc2l0IG92ZXIgdGhlIFBpeGlKUyBlbGVtZW50LiBUaGlzIGlzIHdoZXJlIHRoZSBkaXYgb3ZlcmxheXMgd2lsbCBnby5cbiAgICAgICAgdmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBkaXYuc3R5bGUud2lkdGggPSBBY2Nlc3NpYmlsaXR5TWFuYWdlci5ESVZfVE9VQ0hfU0laRSArIFwicHhcIjtcbiAgICAgICAgZGl2LnN0eWxlLmhlaWdodCA9IEFjY2Vzc2liaWxpdHlNYW5hZ2VyLkRJVl9UT1VDSF9TSVpFICsgXCJweFwiO1xuICAgICAgICBkaXYuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgICBkaXYuc3R5bGUudG9wID0gQWNjZXNzaWJpbGl0eU1hbmFnZXIuRElWX1RPVUNIX1BPU19YICsgXCJweFwiO1xuICAgICAgICBkaXYuc3R5bGUubGVmdCA9IEFjY2Vzc2liaWxpdHlNYW5hZ2VyLkRJVl9UT1VDSF9QT1NfWSArIFwicHhcIjtcbiAgICAgICAgZGl2LnN0eWxlLnpJbmRleCA9IEFjY2Vzc2liaWxpdHlNYW5hZ2VyLkRJVl9UT1VDSF9aSU5ERVgudG9TdHJpbmcoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgaXMgdGhlIGRvbSBlbGVtZW50IHRoYXQgd2lsbCBzaXQgb3ZlciB0aGUgUGl4aUpTIGVsZW1lbnQuIFRoaXMgaXMgd2hlcmUgdGhlIGRpdiBvdmVybGF5cyB3aWxsIGdvLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRpdiA9IGRpdjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgc2ltcGxlIHBvb2wgZm9yIHN0b3JpbmcgZGl2cy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHR5cGUgeyp9XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnBvb2wgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgaXMgYSB0aWNrIHVzZWQgdG8gY2hlY2sgaWYgYW4gb2JqZWN0IGlzIG5vIGxvbmdlciBiZWluZyByZW5kZXJlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVuZGVySWQgPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0dGluZyB0aGlzIHRvIHRydWUgd2lsbCB2aXN1YWxseSBzaG93IHRoZSBkaXZzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGVidWcgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSByZW5kZXJlciB0aGlzIGFjY2Vzc2liaWxpdHkgbWFuYWdlciB3b3JrcyBmb3IuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuQWJzdHJhY3RSZW5kZXJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBhcnJheSBvZiBjdXJyZW50bHkgYWN0aXZlIGFjY2Vzc2libGUgaXRlbXMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge0FycmF5PCo+fVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgICogcHJlLWJpbmQgdGhlIGZ1bmN0aW9uc1xuICAgICAgICAgKlxuICAgICAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9vbktleURvd24gPSB0aGlzLl9vbktleURvd24uYmluZCh0aGlzKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHByZS1iaW5kIHRoZSBmdW5jdGlvbnNcbiAgICAgICAgICpcbiAgICAgICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fb25Nb3VzZU1vdmUgPSB0aGlzLl9vbk1vdXNlTW92ZS5iaW5kKHRoaXMpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBmbGFnXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKiBAcmVhZG9ubHlcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaXNBY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgZmxhZ1xuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICogQHJlYWRvbmx5XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmlzTW9iaWxlQWNjZXNzaWJpbGl0eSA9IGZhbHNlO1xuICAgICAgICAvLyBsZXQgbGlzdGVuIGZvciB0YWIuLiBvbmNlIHByZXNzZWQgd2UgY2FuIGZpcmUgdXAgYW5kIHNob3cgdGhlIGFjY2Vzc2liaWxpdHkgbGF5ZXJcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLl9vbktleURvd24sIGZhbHNlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyB0aGUgdG91Y2ggaG9va3MuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGNyZWF0ZVRvdWNoSG9vaygpIHtcbiAgICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG4gICAgICAgIHZhciBob29rRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnV0dG9uJyk7XG4gICAgICAgIGhvb2tEaXYuc3R5bGUud2lkdGggPSBBY2Nlc3NpYmlsaXR5TWFuYWdlci5ESVZfSE9PS19TSVpFICsgXCJweFwiO1xuICAgICAgICBob29rRGl2LnN0eWxlLmhlaWdodCA9IEFjY2Vzc2liaWxpdHlNYW5hZ2VyLkRJVl9IT09LX1NJWkUgKyBcInB4XCI7XG4gICAgICAgIGhvb2tEaXYuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgICBob29rRGl2LnN0eWxlLnRvcCA9IEFjY2Vzc2liaWxpdHlNYW5hZ2VyLkRJVl9IT09LX1BPU19YICsgXCJweFwiO1xuICAgICAgICBob29rRGl2LnN0eWxlLmxlZnQgPSBBY2Nlc3NpYmlsaXR5TWFuYWdlci5ESVZfSE9PS19QT1NfWSArIFwicHhcIjtcbiAgICAgICAgaG9va0Rpdi5zdHlsZS56SW5kZXggPSBBY2Nlc3NpYmlsaXR5TWFuYWdlci5ESVZfSE9PS19aSU5ERVgudG9TdHJpbmcoKTtcbiAgICAgICAgaG9va0Rpdi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSAnI0ZGMDAwMCc7XG4gICAgICAgIGhvb2tEaXYudGl0bGUgPSAnSE9PSyBESVYnO1xuICAgICAgICBob29rRGl2LmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcyQxLmlzTW9iaWxlQWNjZXNzaWJpbGl0eSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzJDEuYWN0aXZhdGUoKTtcbiAgICAgICAgICAgIHRoaXMkMS5kZXN0cm95VG91Y2hIb29rKCk7XG4gICAgICAgIH0pO1xuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGhvb2tEaXYpO1xuICAgICAgICB0aGlzLl9ob29rRGl2ID0gaG9va0RpdjtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIERlc3Ryb3lzIHRoZSB0b3VjaCBob29rcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZGVzdHJveVRvdWNoSG9vaygpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9ob29rRGl2KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZCh0aGlzLl9ob29rRGl2KTtcbiAgICAgICAgdGhpcy5faG9va0RpdiA9IG51bGw7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBBY3RpdmF0aW5nIHdpbGwgY2F1c2UgdGhlIEFjY2Vzc2liaWxpdHkgbGF5ZXIgdG8gYmUgc2hvd24uXG4gICAgICogVGhpcyBpcyBjYWxsZWQgd2hlbiBhIHVzZXIgcHJlc3NlcyB0aGUgdGFiIGtleS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgYWN0aXZhdGUoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzQWN0aXZlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc0FjdGl2ZSA9IHRydWU7XG4gICAgICAgIHdpbmRvdy5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLl9vbk1vdXNlTW92ZSwgdHJ1ZSk7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5fb25LZXlEb3duLCBmYWxzZSk7XG4gICAgICAgIHRoaXMucmVuZGVyZXIub24oJ3Bvc3RyZW5kZXInLCB0aGlzLnVwZGF0ZSwgdGhpcyk7XG4gICAgICAgIGlmICh0aGlzLnJlbmRlcmVyLnZpZXcucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci52aWV3LnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQodGhpcy5kaXYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBEZWFjdGl2YXRpbmcgd2lsbCBjYXVzZSB0aGUgQWNjZXNzaWJpbGl0eSBsYXllciB0byBiZSBoaWRkZW4uXG4gICAgICogVGhpcyBpcyBjYWxsZWQgd2hlbiBhIHVzZXIgbW92ZXMgdGhlIG1vdXNlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBkZWFjdGl2YXRlKCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNBY3RpdmUgfHwgdGhpcy5pc01vYmlsZUFjY2Vzc2liaWxpdHkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzQWN0aXZlID0gZmFsc2U7XG4gICAgICAgIHdpbmRvdy5kb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLl9vbk1vdXNlTW92ZSwgdHJ1ZSk7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5fb25LZXlEb3duLCBmYWxzZSk7XG4gICAgICAgIHRoaXMucmVuZGVyZXIub2ZmKCdwb3N0cmVuZGVyJywgdGhpcy51cGRhdGUpO1xuICAgICAgICBpZiAodGhpcy5kaXYucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgdGhpcy5kaXYucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmRpdik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFRoaXMgcmVjdXJzaXZlIGZ1bmN0aW9uIHdpbGwgcnVuIHRocm91Z2ggdGhlIHNjZW5lIGdyYXBoIGFuZCBhZGQgYW55IG5ldyBhY2Nlc3NpYmxlIG9iamVjdHMgdG8gdGhlIERPTSBsYXllci5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtQSVhJLkNvbnRhaW5lcn0gZGlzcGxheU9iamVjdCAtIFRoZSBEaXNwbGF5T2JqZWN0IHRvIGNoZWNrLlxuICAgICAqL1xuICAgIHVwZGF0ZUFjY2Vzc2libGVPYmplY3RzKGRpc3BsYXlPYmplY3QpIHtcbiAgICAgICAgaWYgKCFkaXNwbGF5T2JqZWN0LnZpc2libGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGlzcGxheU9iamVjdC5hY2Nlc3NpYmxlICYmIGRpc3BsYXlPYmplY3QuaW50ZXJhY3RpdmUpIHtcbiAgICAgICAgICAgIGlmICghZGlzcGxheU9iamVjdC5fYWNjZXNzaWJsZUFjdGl2ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkQ2hpbGQoZGlzcGxheU9iamVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkaXNwbGF5T2JqZWN0LnJlbmRlcklkID0gdGhpcy5yZW5kZXJJZDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2hpbGRyZW4gPSBkaXNwbGF5T2JqZWN0LmNoaWxkcmVuO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUFjY2Vzc2libGVPYmplY3RzKGNoaWxkcmVuW2ldKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogQmVmb3JlIGVhY2ggcmVuZGVyIHRoaXMgZnVuY3Rpb24gd2lsbCBlbnN1cmUgdGhhdCBhbGwgZGl2cyBhcmUgbWFwcGVkIGNvcnJlY3RseSB0byB0aGVpciBEaXNwbGF5T2JqZWN0cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdXBkYXRlKCkge1xuICAgICAgICBpZiAoIXRoaXMucmVuZGVyZXIucmVuZGVyaW5nVG9TY3JlZW4pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyB1cGRhdGUgY2hpbGRyZW4uLi5cbiAgICAgICAgdGhpcy51cGRhdGVBY2Nlc3NpYmxlT2JqZWN0cyh0aGlzLnJlbmRlcmVyLl9sYXN0T2JqZWN0UmVuZGVyZWQpO1xuICAgICAgICB2YXIgcmVjdCA9IHRoaXMucmVuZGVyZXIudmlldy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgdmFyIHN4ID0gcmVjdC53aWR0aCAvIHRoaXMucmVuZGVyZXIud2lkdGg7XG4gICAgICAgIHZhciBzeSA9IHJlY3QuaGVpZ2h0IC8gdGhpcy5yZW5kZXJlci5oZWlnaHQ7XG4gICAgICAgIHZhciBkaXYgPSB0aGlzLmRpdjtcbiAgICAgICAgZGl2LnN0eWxlLmxlZnQgPSAocmVjdC5sZWZ0KSArIFwicHhcIjtcbiAgICAgICAgZGl2LnN0eWxlLnRvcCA9IChyZWN0LnRvcCkgKyBcInB4XCI7XG4gICAgICAgIGRpdi5zdHlsZS53aWR0aCA9ICh0aGlzLnJlbmRlcmVyLndpZHRoKSArIFwicHhcIjtcbiAgICAgICAgZGl2LnN0eWxlLmhlaWdodCA9ICh0aGlzLnJlbmRlcmVyLmhlaWdodCkgKyBcInB4XCI7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgIGlmIChjaGlsZC5yZW5kZXJJZCAhPT0gdGhpcy5yZW5kZXJJZCkge1xuICAgICAgICAgICAgICAgIGNoaWxkLl9hY2Nlc3NpYmxlQWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgVXRpbHNTZXR0aW5nc18xLlV0aWxzU2V0dGluZ3MucmVtb3ZlSXRlbXModGhpcy5jaGlsZHJlbiwgaSwgMSk7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXYucmVtb3ZlQ2hpbGQoY2hpbGQuX2FjY2Vzc2libGVEaXYpO1xuICAgICAgICAgICAgICAgIHRoaXMucG9vbC5wdXNoKGNoaWxkLl9hY2Nlc3NpYmxlRGl2KTtcbiAgICAgICAgICAgICAgICBjaGlsZC5fYWNjZXNzaWJsZURpdiA9IG51bGw7XG4gICAgICAgICAgICAgICAgaS0tO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlYWN0aXZhdGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBtYXAgZGl2IHRvIGRpc3BsYXkuLlxuICAgICAgICAgICAgICAgIGRpdiA9IGNoaWxkLl9hY2Nlc3NpYmxlRGl2O1xuICAgICAgICAgICAgICAgIHZhciBoaXRBcmVhID0gY2hpbGQuaGl0QXJlYTtcbiAgICAgICAgICAgICAgICB2YXIgd3QgPSBjaGlsZC53b3JsZFRyYW5zZm9ybTtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGQuaGl0QXJlYSkge1xuICAgICAgICAgICAgICAgICAgICBkaXYuc3R5bGUubGVmdCA9ICgod3QudHggKyAoaGl0QXJlYS54ICogd3QuYSkpICogc3gpICsgXCJweFwiO1xuICAgICAgICAgICAgICAgICAgICBkaXYuc3R5bGUudG9wID0gKCh3dC50eSArIChoaXRBcmVhLnkgKiB3dC5kKSkgKiBzeSkgKyBcInB4XCI7XG4gICAgICAgICAgICAgICAgICAgIGRpdi5zdHlsZS53aWR0aCA9IChoaXRBcmVhLndpZHRoICogd3QuYSAqIHN4KSArIFwicHhcIjtcbiAgICAgICAgICAgICAgICAgICAgZGl2LnN0eWxlLmhlaWdodCA9IChoaXRBcmVhLmhlaWdodCAqIHd0LmQgKiBzeSkgKyBcInB4XCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBoaXRBcmVhID0gY2hpbGQuZ2V0Qm91bmRzKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FwSGl0QXJlYShoaXRBcmVhKTtcbiAgICAgICAgICAgICAgICAgICAgZGl2LnN0eWxlLmxlZnQgPSAoaGl0QXJlYS54ICogc3gpICsgXCJweFwiO1xuICAgICAgICAgICAgICAgICAgICBkaXYuc3R5bGUudG9wID0gKGhpdEFyZWEueSAqIHN5KSArIFwicHhcIjtcbiAgICAgICAgICAgICAgICAgICAgZGl2LnN0eWxlLndpZHRoID0gKGhpdEFyZWEud2lkdGggKiBzeCkgKyBcInB4XCI7XG4gICAgICAgICAgICAgICAgICAgIGRpdi5zdHlsZS5oZWlnaHQgPSAoaGl0QXJlYS5oZWlnaHQgKiBzeSkgKyBcInB4XCI7XG4gICAgICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSBidXR0b24gdGl0bGVzIGFuZCBoaW50cyBpZiB0aGV5IGV4aXN0IGFuZCB0aGV5J3ZlIGNoYW5nZWRcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRpdi50aXRsZSAhPT0gY2hpbGQuYWNjZXNzaWJsZVRpdGxlICYmIGNoaWxkLmFjY2Vzc2libGVUaXRsZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGl2LnRpdGxlID0gY2hpbGQuYWNjZXNzaWJsZVRpdGxlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChkaXYuZ2V0QXR0cmlidXRlKCdhcmlhLWxhYmVsJykgIT09IGNoaWxkLmFjY2Vzc2libGVIaW50XG4gICAgICAgICAgICAgICAgICAgICAgICAmJiBjaGlsZC5hY2Nlc3NpYmxlSGludCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGl2LnNldEF0dHJpYnV0ZSgnYXJpYS1sYWJlbCcsIGNoaWxkLmFjY2Vzc2libGVIaW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBpbmNyZW1lbnQgdGhlIHJlbmRlciBpZC4uXG4gICAgICAgIHRoaXMucmVuZGVySWQrKztcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIEFkanVzdCB0aGUgaGl0IGFyZWEgYmFzZWQgb24gdGhlIGJvdW5kcyBvZiBhIGRpc3BsYXkgb2JqZWN0XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1JlY3RhbmdsZX0gaGl0QXJlYSAtIEJvdW5kcyBvZiB0aGUgY2hpbGRcbiAgICAgKi9cbiAgICBjYXBIaXRBcmVhKGhpdEFyZWEpIHtcbiAgICAgICAgaWYgKGhpdEFyZWEueCA8IDApIHtcbiAgICAgICAgICAgIGhpdEFyZWEud2lkdGggKz0gaGl0QXJlYS54O1xuICAgICAgICAgICAgaGl0QXJlYS54ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGl0QXJlYS55IDwgMCkge1xuICAgICAgICAgICAgaGl0QXJlYS5oZWlnaHQgKz0gaGl0QXJlYS55O1xuICAgICAgICAgICAgaGl0QXJlYS55ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGl0QXJlYS54ICsgaGl0QXJlYS53aWR0aCA+IHRoaXMucmVuZGVyZXIud2lkdGgpIHtcbiAgICAgICAgICAgIGhpdEFyZWEud2lkdGggPSB0aGlzLnJlbmRlcmVyLndpZHRoIC0gaGl0QXJlYS54O1xuICAgICAgICB9XG4gICAgICAgIGlmIChoaXRBcmVhLnkgKyBoaXRBcmVhLmhlaWdodCA+IHRoaXMucmVuZGVyZXIuaGVpZ2h0KSB7XG4gICAgICAgICAgICBoaXRBcmVhLmhlaWdodCA9IHRoaXMucmVuZGVyZXIuaGVpZ2h0IC0gaGl0QXJlYS55O1xuICAgICAgICB9XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBBZGRzIGEgRGlzcGxheU9iamVjdCB0byB0aGUgYWNjZXNzaWJpbGl0eSBtYW5hZ2VyXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RGlzcGxheU9iamVjdH0gZGlzcGxheU9iamVjdCAtIFRoZSBjaGlsZCB0byBtYWtlIGFjY2Vzc2libGUuXG4gICAgICovXG4gICAgYWRkQ2hpbGQoZGlzcGxheU9iamVjdCkge1xuICAgICAgICAvL3RoaXMuYWN0aXZhdGUoKTtcbiAgICAgICAgdmFyIGRpdiA9IHRoaXMucG9vbC5wb3AoKTtcbiAgICAgICAgaWYgKCFkaXYpIHtcbiAgICAgICAgICAgIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpO1xuICAgICAgICAgICAgZGl2LnN0eWxlLndpZHRoID0gQWNjZXNzaWJpbGl0eU1hbmFnZXIuRElWX1RPVUNIX1NJWkUgKyBcInB4XCI7XG4gICAgICAgICAgICBkaXYuc3R5bGUuaGVpZ2h0ID0gQWNjZXNzaWJpbGl0eU1hbmFnZXIuRElWX1RPVUNIX1NJWkUgKyBcInB4XCI7XG4gICAgICAgICAgICBkaXYuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gdGhpcy5kZWJ1ZyA/ICdyZ2JhKDI1NSwwLDAsMC41KScgOiAndHJhbnNwYXJlbnQnO1xuICAgICAgICAgICAgZGl2LnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgICAgIGRpdi5zdHlsZS56SW5kZXggPSBBY2Nlc3NpYmlsaXR5TWFuYWdlci5ESVZfVE9VQ0hfWklOREVYO1xuICAgICAgICAgICAgZGl2LnN0eWxlLmJvcmRlclN0eWxlID0gJ25vbmUnO1xuICAgICAgICAgICAgLy8gQVJJQSBhdHRyaWJ1dGVzIGVuc3VyZSB0aGF0IGJ1dHRvbiB0aXRsZSBhbmQgaGludCB1cGRhdGVzIGFyZSBhbm5vdW5jZWQgcHJvcGVybHlcbiAgICAgICAgICAgIGlmIChuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkuaW5kZXhPZignY2hyb21lJykgPiAtMSkge1xuICAgICAgICAgICAgICAgIC8vIENocm9tZSBkb2Vzbid0IG5lZWQgYXJpYS1saXZlIHRvIHdvcmsgYXMgaW50ZW5kZWQ7IGluIGZhY3QgaXQganVzdCBnZXRzIG1vcmUgY29uZnVzZWQuXG4gICAgICAgICAgICAgICAgZGl2LnNldEF0dHJpYnV0ZSgnYXJpYS1saXZlJywgJ29mZicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGl2LnNldEF0dHJpYnV0ZSgnYXJpYS1saXZlJywgJ3BvbGl0ZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL3J2Oi4qR2Vja29cXC8vKSkge1xuICAgICAgICAgICAgICAgIC8vIEZpcmVGb3ggbmVlZHMgdGhpcyB0byBhbm5vdW5jZSBvbmx5IHRoZSBuZXcgYnV0dG9uIG5hbWVcbiAgICAgICAgICAgICAgICBkaXYuc2V0QXR0cmlidXRlKCdhcmlhLXJlbGV2YW50JywgJ2FkZGl0aW9ucycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gcmVxdWlyZWQgYnkgSUUsIG90aGVyIGJyb3dzZXJzIGRvbid0IG11Y2ggY2FyZVxuICAgICAgICAgICAgICAgIGRpdi5zZXRBdHRyaWJ1dGUoJ2FyaWEtcmVsZXZhbnQnLCAndGV4dCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGl2LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fb25DbGljay5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgIGRpdi5hZGRFdmVudExpc3RlbmVyKCdmb2N1cycsIHRoaXMuX29uRm9jdXMuYmluZCh0aGlzKSk7XG4gICAgICAgICAgICBkaXYuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXNvdXQnLCB0aGlzLl9vbkZvY3VzT3V0LmJpbmQodGhpcykpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkaXNwbGF5T2JqZWN0LmFjY2Vzc2libGVUaXRsZSAmJiBkaXNwbGF5T2JqZWN0LmFjY2Vzc2libGVUaXRsZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgZGl2LnRpdGxlID0gZGlzcGxheU9iamVjdC5hY2Nlc3NpYmxlVGl0bGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWRpc3BsYXlPYmplY3QuYWNjZXNzaWJsZUhpbnRcbiAgICAgICAgICAgIHx8IGRpc3BsYXlPYmplY3QuYWNjZXNzaWJsZUhpbnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGRpdi50aXRsZSA9IFwiZGlzcGxheU9iamVjdCBcIiArIChkaXNwbGF5T2JqZWN0LnRhYkluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGlzcGxheU9iamVjdC5hY2Nlc3NpYmxlSGludFxuICAgICAgICAgICAgJiYgZGlzcGxheU9iamVjdC5hY2Nlc3NpYmxlSGludCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgZGl2LnNldEF0dHJpYnV0ZSgnYXJpYS1sYWJlbCcsIGRpc3BsYXlPYmplY3QuYWNjZXNzaWJsZUhpbnQpO1xuICAgICAgICB9XG4gICAgICAgIC8vXG4gICAgICAgIGRpc3BsYXlPYmplY3QuX2FjY2Vzc2libGVBY3RpdmUgPSB0cnVlO1xuICAgICAgICBkaXNwbGF5T2JqZWN0Ll9hY2Nlc3NpYmxlRGl2ID0gZGl2O1xuICAgICAgICBkaXYuZGlzcGxheU9iamVjdCA9IGRpc3BsYXlPYmplY3Q7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4ucHVzaChkaXNwbGF5T2JqZWN0KTtcbiAgICAgICAgdGhpcy5kaXYuYXBwZW5kQ2hpbGQoZGlzcGxheU9iamVjdC5fYWNjZXNzaWJsZURpdik7XG4gICAgICAgIGRpc3BsYXlPYmplY3QuX2FjY2Vzc2libGVEaXYudGFiSW5kZXggPSBkaXNwbGF5T2JqZWN0LnRhYkluZGV4O1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogTWFwcyB0aGUgZGl2IGJ1dHRvbiBwcmVzcyB0byBwaXhpJ3MgIChjbGljaylcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtNb3VzZUV2ZW50fSBlIC0gVGhlIGNsaWNrIGV2ZW50LlxuICAgICAqL1xuICAgIF9vbkNsaWNrKGUpIHtcbiAgICAgICAgdmFyIGludGVyYWN0aW9uTWFuYWdlciA9IHRoaXMucmVuZGVyZXIucGx1Z2lucy5pbnRlcmFjdGlvbjtcbiAgICAgICAgaW50ZXJhY3Rpb25NYW5hZ2VyLmRpc3BhdGNoRXZlbnQoZS50YXJnZXQuZGlzcGxheU9iamVjdCwgJ2NsaWNrJywgaW50ZXJhY3Rpb25NYW5hZ2VyLmV2ZW50RGF0YSk7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBNYXBzIHRoZSBkaXYgZm9jdXMgZXZlbnRzIHRvIHBpeGkncyAgKG1vdXNlb3ZlcilcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGb2N1c0V2ZW50fSBlIC0gVGhlIGZvY3VzIGV2ZW50LlxuICAgICAqL1xuICAgIF9vbkZvY3VzKGUpIHtcbiAgICAgICAgaWYgKCFlLnRhcmdldC5nZXRBdHRyaWJ1dGUoJ2FyaWEtbGl2ZScsICdvZmYnKSkge1xuICAgICAgICAgICAgZS50YXJnZXQuc2V0QXR0cmlidXRlKCdhcmlhLWxpdmUnLCAnYXNzZXJ0aXZlJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGludGVyYWN0aW9uTWFuYWdlciA9IHRoaXMucmVuZGVyZXIucGx1Z2lucy5pbnRlcmFjdGlvbjtcbiAgICAgICAgaW50ZXJhY3Rpb25NYW5hZ2VyLmRpc3BhdGNoRXZlbnQoZS50YXJnZXQuZGlzcGxheU9iamVjdCwgJ21vdXNlb3ZlcicsIGludGVyYWN0aW9uTWFuYWdlci5ldmVudERhdGEpO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogTWFwcyB0aGUgZGl2IGZvY3VzIGV2ZW50cyB0byBwaXhpJ3MgIChtb3VzZW91dClcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGb2N1c0V2ZW50fSBlIC0gVGhlIGZvY3Vzb3V0IGV2ZW50LlxuICAgICAqL1xuICAgIF9vbkZvY3VzT3V0KGUpIHtcbiAgICAgICAgaWYgKCFlLnRhcmdldC5nZXRBdHRyaWJ1dGUoJ2FyaWEtbGl2ZScsICdvZmYnKSkge1xuICAgICAgICAgICAgZS50YXJnZXQuc2V0QXR0cmlidXRlKCdhcmlhLWxpdmUnLCAncG9saXRlJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGludGVyYWN0aW9uTWFuYWdlciA9IHRoaXMucmVuZGVyZXIucGx1Z2lucy5pbnRlcmFjdGlvbjtcbiAgICAgICAgaW50ZXJhY3Rpb25NYW5hZ2VyLmRpc3BhdGNoRXZlbnQoZS50YXJnZXQuZGlzcGxheU9iamVjdCwgJ21vdXNlb3V0JywgaW50ZXJhY3Rpb25NYW5hZ2VyLmV2ZW50RGF0YSk7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBJcyBjYWxsZWQgd2hlbiBhIGtleSBpcyBwcmVzc2VkXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7S2V5Ym9hcmRFdmVudH0gZSAtIFRoZSBrZXlkb3duIGV2ZW50LlxuICAgICAqL1xuICAgIF9vbktleURvd24oZSkge1xuICAgICAgICBpZiAoZS5rZXlDb2RlICE9PSBBY2Nlc3NpYmlsaXR5TWFuYWdlci5LRVlfQ09ERV9UQUIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFjdGl2YXRlKCk7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBJcyBjYWxsZWQgd2hlbiB0aGUgbW91c2UgbW92ZXMgYWNyb3NzIHRoZSByZW5kZXJlciBlbGVtZW50XG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7TW91c2VFdmVudH0gZSAtIFRoZSBtb3VzZSBldmVudC5cbiAgICAgKi9cbiAgICBfb25Nb3VzZU1vdmUoZSkge1xuICAgICAgICBpZiAoZS5tb3ZlbWVudFggPT09IDAgJiYgZS5tb3ZlbWVudFkgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlYWN0aXZhdGUoKTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIERlc3Ryb3lzIHRoZSBhY2Nlc3NpYmlsaXR5IG1hbmFnZXJcbiAgICAgKlxuICAgICAqL1xuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuZGVzdHJveVRvdWNoSG9vaygpO1xuICAgICAgICB0aGlzLmRpdiA9IG51bGw7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbltpXS5kaXYgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHdpbmRvdy5kb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLl9vbk1vdXNlTW92ZSwgdHJ1ZSk7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5fb25LZXlEb3duKTtcbiAgICAgICAgdGhpcy5wb29sID0gbnVsbDtcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IG51bGw7XG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSBudWxsO1xuICAgIH1cbiAgICA7XG59XG5BY2Nlc3NpYmlsaXR5TWFuYWdlci5ESVZfSE9PS19TSVpFID0gMTtcbkFjY2Vzc2liaWxpdHlNYW5hZ2VyLkRJVl9IT09LX1BPU19YID0gLTEwMDA7XG5BY2Nlc3NpYmlsaXR5TWFuYWdlci5ESVZfSE9PS19QT1NfWSA9IC0xMDAwO1xuQWNjZXNzaWJpbGl0eU1hbmFnZXIuRElWX0hPT0tfWklOREVYID0gMjtcbkFjY2Vzc2liaWxpdHlNYW5hZ2VyLktFWV9DT0RFX1RBQiA9IDk7XG5BY2Nlc3NpYmlsaXR5TWFuYWdlci5ESVZfVE9VQ0hfU0laRSA9IDEwMDtcbkFjY2Vzc2liaWxpdHlNYW5hZ2VyLkRJVl9UT1VDSF9QT1NfWCA9IDA7XG5BY2Nlc3NpYmlsaXR5TWFuYWdlci5ESVZfVE9VQ0hfUE9TX1kgPSAwO1xuQWNjZXNzaWJpbGl0eU1hbmFnZXIuRElWX1RPVUNIX1pJTkRFWCA9IDI7XG5leHBvcnRzLkFjY2Vzc2liaWxpdHlNYW5hZ2VyID0gQWNjZXNzaWJpbGl0eU1hbmFnZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IFNwcml0ZV8xID0gcmVxdWlyZShcIi4vU3ByaXRlXCIpO1xuY29uc3QgVGV4dHVyZV8xID0gcmVxdWlyZShcIi4vVGV4dHVyZVwiKTtcbmNvbnN0IFRpY2tlcl8xID0gcmVxdWlyZShcIi4vVGlja2VyXCIpO1xuY2xhc3MgQW5pbWF0ZWRTcHJpdGUgZXh0ZW5kcyBTcHJpdGVfMS5TcHJpdGUge1xuICAgIGNvbnN0cnVjdG9yKHRleHR1cmVzLCBhdXRvVXBkYXRlID0gdHJ1ZSkge1xuICAgICAgICBzdXBlcih0ZXh0dXJlc1swXSBpbnN0YW5jZW9mIFRleHR1cmVfMS5UZXh0dXJlID8gdGV4dHVyZXNbMF0gOiB0ZXh0dXJlc1swXS50ZXh0dXJlKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtQSVhJLlRleHR1cmVbXX1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3RleHR1cmVzID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJbXX1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2R1cmF0aW9ucyA9IG51bGw7XG4gICAgICAgIHRoaXMudGV4dHVyZXMgPSB0ZXh0dXJlcztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGB0cnVlYCB1c2VzIFBJWEkuVGlja2VyLnNoYXJlZCB0byBhdXRvIHVwZGF0ZSBhbmltYXRpb24gdGltZS5cbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2F1dG9VcGRhdGUgPSBhdXRvVXBkYXRlICE9PSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBzcGVlZCB0aGF0IHRoZSBBbmltYXRlZFNwcml0ZSB3aWxsIHBsYXkgYXQuIEhpZ2hlciBpcyBmYXN0ZXIsIGxvd2VyIGlzIHNsb3dlci5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAxXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmFuaW1hdGlvblNwZWVkID0gMTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgb3Igbm90IHRoZSBhbmltYXRlIHNwcml0ZSByZXBlYXRzIGFmdGVyIHBsYXlpbmcuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XG4gICAgICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubG9vcCA9IHRydWU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVcGRhdGUgYW5jaG9yIHRvIFtUZXh0dXJlJ3MgZGVmYXVsdEFuY2hvcl17QGxpbmsgUElYSS5UZXh0dXJlI2RlZmF1bHRBbmNob3J9IHdoZW4gZnJhbWUgY2hhbmdlcy5cbiAgICAgICAgICpcbiAgICAgICAgICogVXNlZnVsIHdpdGggW3Nwcml0ZSBzaGVldCBhbmltYXRpb25zXXtAbGluayBQSVhJLlNwcml0ZXNoZWV0I2FuaW1hdGlvbnN9IGNyZWF0ZWQgd2l0aCB0b29scy5cbiAgICAgICAgICogQ2hhbmdpbmcgYW5jaG9yIGZvciBlYWNoIGZyYW1lIGFsbG93cyB0byBwaW4gc3ByaXRlIG9yaWdpbiB0byBjZXJ0YWluIG1vdmluZyBmZWF0dXJlXG4gICAgICAgICAqIG9mIHRoZSBmcmFtZSAoZS5nLiBsZWZ0IGZvb3QpLlxuICAgICAgICAgKlxuICAgICAgICAgKiBOb3RlOiBFbmFibGluZyB0aGlzIHdpbGwgb3ZlcnJpZGUgYW55IHByZXZpb3VzbHkgc2V0IGBhbmNob3JgIG9uIGVhY2ggZnJhbWUgY2hhbmdlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtib29sZWFufVxuICAgICAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy51cGRhdGVBbmNob3IgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZ1bmN0aW9uIHRvIGNhbGwgd2hlbiBhIEFuaW1hdGVkU3ByaXRlIGZpbmlzaGVzIHBsYXlpbmcuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge0Z1bmN0aW9ufVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vbkNvbXBsZXRlID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZ1bmN0aW9uIHRvIGNhbGwgd2hlbiBhIEFuaW1hdGVkU3ByaXRlIGNoYW5nZXMgd2hpY2ggdGV4dHVyZSBpcyBiZWluZyByZW5kZXJlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7RnVuY3Rpb259XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9uRnJhbWVDaGFuZ2UgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogRnVuY3Rpb24gdG8gY2FsbCB3aGVuIGBsb29wYCBpcyB0cnVlLCBhbmQgYW4gQW5pbWF0ZWRTcHJpdGUgaXMgcGxheWVkIGFuZCBsb29wcyBhcm91bmQgdG8gc3RhcnQgYWdhaW4uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge0Z1bmN0aW9ufVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vbkxvb3AgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogRWxhcHNlZCB0aW1lIHNpbmNlIGFuaW1hdGlvbiBoYXMgYmVlbiBzdGFydGVkLCB1c2VkIGludGVybmFsbHkgdG8gZGlzcGxheSBjdXJyZW50IHRleHR1cmUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2N1cnJlbnRUaW1lID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluZGljYXRlcyBpZiB0aGUgQW5pbWF0ZWRTcHJpdGUgaXMgY3VycmVudGx5IHBsYXlpbmcuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XG4gICAgICAgICAqIEByZWFkb25seVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wbGF5aW5nID0gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0b3BzIHRoZSBBbmltYXRlZFNwcml0ZS5cbiAgICAgKlxuICAgICAqL1xuICAgIHN0b3AoKSB7XG4gICAgICAgIGlmICghdGhpcy5wbGF5aW5nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wbGF5aW5nID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLl9hdXRvVXBkYXRlKSB7XG4gICAgICAgICAgICBUaWNrZXJfMS5UaWNrZXIuc2hhcmVkLnJlbW92ZSh0aGlzLnVwZGF0ZSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFBsYXlzIHRoZSBBbmltYXRlZFNwcml0ZS5cbiAgICAgKlxuICAgICAqL1xuICAgIHBsYXkoKSB7XG4gICAgICAgIGlmICh0aGlzLnBsYXlpbmcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBsYXlpbmcgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5fYXV0b1VwZGF0ZSkge1xuICAgICAgICAgICAgVGlja2VyXzEuVGlja2VyLnNoYXJlZC5hZGQodGhpcy51cGRhdGUsIHRoaXMsIFRpY2tlcl8xLlRpY2tlci5VUERBVEVfUFJJT1JJVFkuSElHSCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFN0b3BzIHRoZSBBbmltYXRlZFNwcml0ZSBhbmQgZ29lcyB0byBhIHNwZWNpZmljIGZyYW1lLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGZyYW1lTnVtYmVyIC0gRnJhbWUgaW5kZXggdG8gc3RvcCBhdC5cbiAgICAgKi9cbiAgICBnb3RvQW5kU3RvcChmcmFtZU51bWJlcikge1xuICAgICAgICB0aGlzLnN0b3AoKTtcbiAgICAgICAgdmFyIHByZXZpb3VzRnJhbWUgPSB0aGlzLmN1cnJlbnRGcmFtZTtcbiAgICAgICAgdGhpcy5fY3VycmVudFRpbWUgPSBmcmFtZU51bWJlcjtcbiAgICAgICAgaWYgKHByZXZpb3VzRnJhbWUgIT09IHRoaXMuY3VycmVudEZyYW1lKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVRleHR1cmUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogR29lcyB0byBhIHNwZWNpZmljIGZyYW1lIGFuZCBiZWdpbnMgcGxheWluZyB0aGUgQW5pbWF0ZWRTcHJpdGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZnJhbWVOdW1iZXIgLSBGcmFtZSBpbmRleCB0byBzdGFydCBhdC5cbiAgICAgKi9cbiAgICBnb3RvQW5kUGxheShmcmFtZU51bWJlcikge1xuICAgICAgICB2YXIgcHJldmlvdXNGcmFtZSA9IHRoaXMuY3VycmVudEZyYW1lO1xuICAgICAgICB0aGlzLl9jdXJyZW50VGltZSA9IGZyYW1lTnVtYmVyO1xuICAgICAgICBpZiAocHJldmlvdXNGcmFtZSAhPT0gdGhpcy5jdXJyZW50RnJhbWUpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVGV4dHVyZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucGxheSgpO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgb2JqZWN0IHRyYW5zZm9ybSBmb3IgcmVuZGVyaW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZGVsdGFUaW1lIC0gVGltZSBzaW5jZSBsYXN0IHRpY2suXG4gICAgICovXG4gICAgdXBkYXRlKGRlbHRhVGltZSkge1xuICAgICAgICB2YXIgZWxhcHNlZCA9IHRoaXMuYW5pbWF0aW9uU3BlZWQgKiBkZWx0YVRpbWU7XG4gICAgICAgIHZhciBwcmV2aW91c0ZyYW1lID0gdGhpcy5jdXJyZW50RnJhbWU7XG4gICAgICAgIGlmICh0aGlzLl9kdXJhdGlvbnMgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBsYWcgPSB0aGlzLl9jdXJyZW50VGltZSAlIDEgKiB0aGlzLl9kdXJhdGlvbnNbdGhpcy5jdXJyZW50RnJhbWVdO1xuICAgICAgICAgICAgbGFnICs9IGVsYXBzZWQgLyA2MCAqIDEwMDA7XG4gICAgICAgICAgICB3aGlsZSAobGFnIDwgMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRUaW1lLS07XG4gICAgICAgICAgICAgICAgbGFnICs9IHRoaXMuX2R1cmF0aW9uc1t0aGlzLmN1cnJlbnRGcmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgc2lnbiA9IE1hdGguc2lnbih0aGlzLmFuaW1hdGlvblNwZWVkICogZGVsdGFUaW1lKTtcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRUaW1lID0gTWF0aC5mbG9vcih0aGlzLl9jdXJyZW50VGltZSk7XG4gICAgICAgICAgICB3aGlsZSAobGFnID49IHRoaXMuX2R1cmF0aW9uc1t0aGlzLmN1cnJlbnRGcmFtZV0pIHtcbiAgICAgICAgICAgICAgICBsYWcgLT0gdGhpcy5fZHVyYXRpb25zW3RoaXMuY3VycmVudEZyYW1lXSAqIHNpZ247XG4gICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudFRpbWUgKz0gc2lnbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRUaW1lICs9IGxhZyAvIHRoaXMuX2R1cmF0aW9uc1t0aGlzLmN1cnJlbnRGcmFtZV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50VGltZSArPSBlbGFwc2VkO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9jdXJyZW50VGltZSA8IDAgJiYgIXRoaXMubG9vcCkge1xuICAgICAgICAgICAgdGhpcy5nb3RvQW5kU3RvcCgwKTtcbiAgICAgICAgICAgIGlmICh0aGlzLm9uQ29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uQ29tcGxldGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLl9jdXJyZW50VGltZSA+PSB0aGlzLl90ZXh0dXJlcy5sZW5ndGggJiYgIXRoaXMubG9vcCkge1xuICAgICAgICAgICAgdGhpcy5nb3RvQW5kU3RvcCh0aGlzLl90ZXh0dXJlcy5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgIGlmICh0aGlzLm9uQ29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uQ29tcGxldGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcmV2aW91c0ZyYW1lICE9PSB0aGlzLmN1cnJlbnRGcmFtZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMubG9vcCAmJiB0aGlzLm9uTG9vcCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmFuaW1hdGlvblNwZWVkID4gMCAmJiB0aGlzLmN1cnJlbnRGcmFtZSA8IHByZXZpb3VzRnJhbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbkxvb3AoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5hbmltYXRpb25TcGVlZCA8IDAgJiYgdGhpcy5jdXJyZW50RnJhbWUgPiBwcmV2aW91c0ZyYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25Mb29wKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy51cGRhdGVUZXh0dXJlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIGRpc3BsYXllZCB0ZXh0dXJlIHRvIG1hdGNoIHRoZSBjdXJyZW50IGZyYW1lIGluZGV4LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB1cGRhdGVUZXh0dXJlKCkge1xuICAgICAgICB0aGlzLl90ZXh0dXJlID0gdGhpcy5fdGV4dHVyZXNbdGhpcy5jdXJyZW50RnJhbWVdO1xuICAgICAgICB0aGlzLl90ZXh0dXJlSUQgPSAtMTtcbiAgICAgICAgdGhpcy5fdGV4dHVyZVRyaW1tZWRJRCA9IC0xO1xuICAgICAgICB0aGlzLmNhY2hlZFRpbnQgPSAweEZGRkZGRjtcbiAgICAgICAgdGhpcy51dnMgPSB0aGlzLl90ZXh0dXJlLl91dnMudXZzRmxvYXQzMjtcbiAgICAgICAgaWYgKHRoaXMudXBkYXRlQW5jaG9yKSB7XG4gICAgICAgICAgICB0aGlzLl9hbmNob3IuY29weUZyb20odGhpcy5fdGV4dHVyZS5kZWZhdWx0QW5jaG9yKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vbkZyYW1lQ2hhbmdlKSB7XG4gICAgICAgICAgICB0aGlzLm9uRnJhbWVDaGFuZ2UodGhpcy5jdXJyZW50RnJhbWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBTdG9wcyB0aGUgQW5pbWF0ZWRTcHJpdGUgYW5kIGRlc3Ryb3lzIGl0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R8Ym9vbGVhbn0gW29wdGlvbnNdIC0gT3B0aW9ucyBwYXJhbWV0ZXIuIEEgYm9vbGVhbiB3aWxsIGFjdCBhcyBpZiBhbGwgb3B0aW9uc1xuICAgICAqICBoYXZlIGJlZW4gc2V0IHRvIHRoYXQgdmFsdWUuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jaGlsZHJlbj1mYWxzZV0gLSBJZiBzZXQgdG8gdHJ1ZSwgYWxsIHRoZSBjaGlsZHJlbiB3aWxsIGhhdmUgdGhlaXIgZGVzdHJveVxuICAgICAqICAgICAgbWV0aG9kIGNhbGxlZCBhcyB3ZWxsLiAnb3B0aW9ucycgd2lsbCBiZSBwYXNzZWQgb24gdG8gdGhvc2UgY2FsbHMuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50ZXh0dXJlPWZhbHNlXSAtIFNob3VsZCBpdCBkZXN0cm95IHRoZSBjdXJyZW50IHRleHR1cmUgb2YgdGhlIHNwcml0ZSBhcyB3ZWxsLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuYmFzZVRleHR1cmU9ZmFsc2VdIC0gU2hvdWxkIGl0IGRlc3Ryb3kgdGhlIGJhc2UgdGV4dHVyZSBvZiB0aGUgc3ByaXRlIGFzIHdlbGwuXG4gICAgICovXG4gICAgZGVzdHJveShvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuc3RvcCgpO1xuICAgICAgICBTcHJpdGVfMS5TcHJpdGUucHJvdG90eXBlLmRlc3Ryb3kuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5vbkNvbXBsZXRlID0gbnVsbDtcbiAgICAgICAgdGhpcy5vbkZyYW1lQ2hhbmdlID0gbnVsbDtcbiAgICAgICAgdGhpcy5vbkxvb3AgPSBudWxsO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogQSBzaG9ydCBoYW5kIHdheSBvZiBjcmVhdGluZyBhIG1vdmllY2xpcCBmcm9tIGFuIGFycmF5IG9mIGZyYW1lIGlkcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBmcmFtZXMgLSBUaGUgYXJyYXkgb2YgZnJhbWVzIGlkcyB0aGUgbW92aWVjbGlwIHdpbGwgdXNlIGFzIGl0cyB0ZXh0dXJlIGZyYW1lcy5cbiAgICAgKiBAcmV0dXJuIHtBbmltYXRlZFNwcml0ZX0gVGhlIG5ldyBhbmltYXRlZCBzcHJpdGUgd2l0aCB0aGUgc3BlY2lmaWVkIGZyYW1lcy5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbUZyYW1lcyhmcmFtZXMpIHtcbiAgICAgICAgdmFyIHRleHR1cmVzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZnJhbWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB0ZXh0dXJlcy5wdXNoKFRleHR1cmVfMS5UZXh0dXJlLmZyb20oZnJhbWVzW2ldKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBBbmltYXRlZFNwcml0ZSh0ZXh0dXJlcyk7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBBIHNob3J0IGhhbmQgd2F5IG9mIGNyZWF0aW5nIGEgbW92aWVjbGlwIGZyb20gYW4gYXJyYXkgb2YgaW1hZ2UgaWRzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IGltYWdlcyAtIFRoZSBhcnJheSBvZiBpbWFnZSB1cmxzIHRoZSBtb3ZpZWNsaXAgd2lsbCB1c2UgYXMgaXRzIHRleHR1cmUgZnJhbWVzLlxuICAgICAqIEByZXR1cm4ge0FuaW1hdGVkU3ByaXRlfSBUaGUgbmV3IGFuaW1hdGUgc3ByaXRlIHdpdGggdGhlIHNwZWNpZmllZCBpbWFnZXMgYXMgZnJhbWVzLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tSW1hZ2VzKGltYWdlcykge1xuICAgICAgICB2YXIgdGV4dHVyZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbWFnZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHRleHR1cmVzLnB1c2goVGV4dHVyZV8xLlRleHR1cmUuZnJvbShpbWFnZXNbaV0pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEFuaW1hdGVkU3ByaXRlKHRleHR1cmVzKTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFRoZSB0b3RhbCBudW1iZXIgb2YgZnJhbWVzIGluIHRoZSBBbmltYXRlZFNwcml0ZS4gVGhpcyBpcyB0aGUgc2FtZSBhcyBudW1iZXIgb2YgdGV4dHVyZXNcbiAgICAgKiBhc3NpZ25lZCB0byB0aGUgQW5pbWF0ZWRTcHJpdGUuXG4gICAgICpcbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqL1xuICAgIGdldCB0b3RhbEZyYW1lcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RleHR1cmVzLmxlbmd0aDtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFRoZSBhcnJheSBvZiB0ZXh0dXJlcyB1c2VkIGZvciB0aGlzIEFuaW1hdGVkU3ByaXRlLlxuICAgICAqXG4gICAgICogQG1lbWJlciB7UElYSS5UZXh0dXJlW119XG4gICAgICovXG4gICAgZ2V0IHRleHR1cmVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdGV4dHVyZXM7XG4gICAgfVxuICAgIDtcbiAgICBzZXQgdGV4dHVyZXModmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlWzBdIGluc3RhbmNlb2YgVGV4dHVyZV8xLlRleHR1cmUpIHtcbiAgICAgICAgICAgIHRoaXMuX3RleHR1cmVzID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLl9kdXJhdGlvbnMgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fdGV4dHVyZXMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX2R1cmF0aW9ucyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3RleHR1cmVzLnB1c2godmFsdWVbaV0udGV4dHVyZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fZHVyYXRpb25zLnB1c2godmFsdWVbaV0udGltZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5nb3RvQW5kU3RvcCgwKTtcbiAgICAgICAgdGhpcy51cGRhdGVUZXh0dXJlKCk7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAqIFRoZSBBbmltYXRlZFNwcml0ZXMgY3VycmVudCBmcmFtZSBpbmRleC5cbiAgICAqXG4gICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgKiBAcmVhZG9ubHlcbiAgICAqL1xuICAgIGdldCBjdXJyZW50RnJhbWUoKSB7XG4gICAgICAgIHZhciBjdXJyZW50RnJhbWUgPSBNYXRoLmZsb29yKHRoaXMuX2N1cnJlbnRUaW1lKSAlIHRoaXMuX3RleHR1cmVzLmxlbmd0aDtcbiAgICAgICAgaWYgKGN1cnJlbnRGcmFtZSA8IDApIHtcbiAgICAgICAgICAgIGN1cnJlbnRGcmFtZSArPSB0aGlzLl90ZXh0dXJlcy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGN1cnJlbnRGcmFtZTtcbiAgICB9XG4gICAgO1xufVxuZXhwb3J0cy5BbmltYXRlZFNwcml0ZSA9IEFuaW1hdGVkU3ByaXRlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBDb250YWluZXJfMSA9IHJlcXVpcmUoXCIuL0NvbnRhaW5lclwiKTtcbmNvbnN0IFJlbmRlcmVyXzEgPSByZXF1aXJlKFwiLi9SZW5kZXJlclwiKTtcbmNvbnN0IFN0YWdlT3B0aW9uc18xID0gcmVxdWlyZShcIi4vU3RhZ2VPcHRpb25zXCIpO1xuY29uc3QgVGlja2VyXzEgPSByZXF1aXJlKFwiLi9UaWNrZXJcIik7XG5jb25zdCBBY2Nlc3NpYmlsaXR5TWFuYWdlcl8xID0gcmVxdWlyZShcIi4vQWNjZXNzaWJpbGl0eU1hbmFnZXJcIik7XG5jb25zdCBFeHRyYWN0XzEgPSByZXF1aXJlKFwiLi9FeHRyYWN0XCIpO1xuY29uc3QgSW50ZXJhY3Rpb25NYW5hZ2VyXzEgPSByZXF1aXJlKFwiLi9JbnRlcmFjdGlvbk1hbmFnZXJcIik7XG5jb25zdCBQYXJ0aWNsZVJlbmRlcmVyXzEgPSByZXF1aXJlKFwiLi9QYXJ0aWNsZVJlbmRlcmVyXCIpO1xuY29uc3QgUHJlcGFyZV8xID0gcmVxdWlyZShcIi4vUHJlcGFyZVwiKTtcbmNvbnN0IEJhdGNoUmVuZGVyZXJfMSA9IHJlcXVpcmUoXCIuL0JhdGNoUmVuZGVyZXJcIik7XG5jb25zdCBUaWxpbmdTcHJpdGVSZW5kZXJlcl8xID0gcmVxdWlyZShcIi4vVGlsaW5nU3ByaXRlUmVuZGVyZXJcIik7XG5jbGFzcyBBcHBsaWNhdGlvbiB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucyA9IG51bGwpIHtcbiAgICAgICAgdGhpcy5yZXNpemUgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5fcmVzaXplVG8pIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fcmVzaXplVG8gPT09IHdpbmRvdykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnJlc2l6ZSh3aW5kb3cuaW5uZXJXaWR0aCwgd2luZG93LmlubmVySGVpZ2h0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIucmVzaXplKHRoaXMuX3Jlc2l6ZVRvWydjbGllbnRXaWR0aCddLCB0aGlzLl9yZXNpemVUb1snY2xpZW50SGVpZ2h0J10pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gbmV3IFN0YWdlT3B0aW9uc18xLlN0YWdlT3B0aW9ucygpO1xuICAgICAgICB9XG4gICAgICAgIFJlbmRlcmVyXzEuUmVuZGVyZXIucmVnaXN0ZXJQbHVnaW4oJ2FjY2Vzc2liaWxpdHknLCBBY2Nlc3NpYmlsaXR5TWFuYWdlcl8xLkFjY2Vzc2liaWxpdHlNYW5hZ2VyKTtcbiAgICAgICAgUmVuZGVyZXJfMS5SZW5kZXJlci5yZWdpc3RlclBsdWdpbignZXh0cmFjdCcsIEV4dHJhY3RfMS5FeHRyYWN0KTtcbiAgICAgICAgUmVuZGVyZXJfMS5SZW5kZXJlci5yZWdpc3RlclBsdWdpbignaW50ZXJhY3Rpb24nLCBJbnRlcmFjdGlvbk1hbmFnZXJfMS5JbnRlcmFjdGlvbk1hbmFnZXIpO1xuICAgICAgICBSZW5kZXJlcl8xLlJlbmRlcmVyLnJlZ2lzdGVyUGx1Z2luKCdwYXJ0aWNsZScsIFBhcnRpY2xlUmVuZGVyZXJfMS5QYXJ0aWNsZVJlbmRlcmVyKTtcbiAgICAgICAgUmVuZGVyZXJfMS5SZW5kZXJlci5yZWdpc3RlclBsdWdpbigncHJlcGFyZScsIFByZXBhcmVfMS5QcmVwYXJlKTtcbiAgICAgICAgUmVuZGVyZXJfMS5SZW5kZXJlci5yZWdpc3RlclBsdWdpbignYmF0Y2gnLCBCYXRjaFJlbmRlcmVyXzEuQmF0Y2hSZW5kZXJlcik7XG4gICAgICAgIFJlbmRlcmVyXzEuUmVuZGVyZXIucmVnaXN0ZXJQbHVnaW4oJ3RpbGluZ1Nwcml0ZScsIFRpbGluZ1Nwcml0ZVJlbmRlcmVyXzEuVGlsaW5nU3ByaXRlUmVuZGVyZXIpO1xuICAgICAgICAvLyB0aGlzLmxvYWRlciA9IC8qb3B0aW9ucy5zaGFyZWRMb2FkZXIgPyBMb2FkZXIuc2hhcmVkIDogKi9uZXcgTG9hZGVyKCk7XG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSBuZXcgUmVuZGVyZXJfMS5SZW5kZXJlcihvcHRpb25zKTsgLy9BcHBsaWNhdGlvbi5hdXRvRGV0ZWN0UmVuZGVyZXIob3B0aW9ucyk7XG4gICAgICAgIHRoaXMuX3N0YWdlID0gbmV3IENvbnRhaW5lcl8xLkNvbnRhaW5lcigpO1xuICAgICAgICB0aGlzLnRpY2tlciA9IG9wdGlvbnMuc2hhcmVkVGlja2VyID8gVGlja2VyXzEuVGlja2VyLnNoYXJlZCA6IG5ldyBUaWNrZXJfMS5UaWNrZXIoKTtcbiAgICAgICAgdGhpcy5yZXNpemVUbyA9IHdpbmRvdztcbiAgICAgICAgLy8gRGlzcGxheU9iamVjdC5taXhpbihpbnRlcmFjdGl2ZVRhcmdldCk7XG4gICAgICAgIGlmIChvcHRpb25zLmF1dG9TdGFydCkge1xuICAgICAgICAgICAgdGhpcy5zdGFydCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCB0aWNrZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90aWNrZXI7XG4gICAgfVxuICAgIHNldCB0aWNrZXIodGlja2VyKSB7XG4gICAgICAgIGlmICh0aGlzLl90aWNrZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX3RpY2tlci5yZW1vdmUodGhpcy5yZW5kZXIsIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3RpY2tlciA9IHRpY2tlcjtcbiAgICAgICAgaWYgKHRpY2tlcikge1xuICAgICAgICAgICAgdGlja2VyLmFkZCh0aGlzLnJlbmRlciwgdGhpcywgVGlja2VyXzEuVGlja2VyLlVQREFURV9QUklPUklUWS5MT1cpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXJ0KCkge1xuICAgICAgICB0aGlzLl90aWNrZXIuc3RhcnQoKTtcbiAgICB9XG4gICAgO1xuICAgIHN0b3AoKSB7XG4gICAgICAgIHRoaXMuX3RpY2tlci5zdG9wKCk7XG4gICAgfVxuICAgIDtcbiAgICBnZXQgcmVzaXplVG8oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZXNpemVUbztcbiAgICB9XG4gICAgc2V0IHJlc2l6ZVRvKHZhbHVlKSB7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLnJlc2l6ZSk7XG4gICAgICAgIHRoaXMuX3Jlc2l6ZVRvID0gdmFsdWU7XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMucmVzaXplKTtcbiAgICAgICAgICAgIHRoaXMucmVzaXplKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnJlbmRlcih0aGlzLl9zdGFnZSk7XG4gICAgfVxuICAgIDtcbiAgICBnZXQgc3RhZ2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdGFnZTtcbiAgICB9XG4gICAgZ2V0IHZpZXcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlbmRlcmVyLnZpZXc7XG4gICAgfVxuICAgIDtcbiAgICBnZXQgc2NyZWVuKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJlci5zY3JlZW47XG4gICAgfVxuICAgIDtcbiAgICBkZXN0cm95KG9wdGlvbnMgPSBudWxsKSB7XG4gICAgICAgIHRoaXMuX3N0YWdlLmRlc3Ryb3kob3B0aW9ucyk7XG4gICAgICAgIHRoaXMuX3N0YWdlID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5kZXN0cm95KG9wdGlvbnMpO1xuICAgICAgICB0aGlzLnJlbmRlcmVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5fb3B0aW9ucyA9IG51bGw7XG4gICAgICAgIC8vIGlmICh0aGlzLmxvYWRlcilcbiAgICAgICAgLy8ge1xuICAgICAgICAvLyAgICAgdGhpcy5sb2FkZXIuZGVzdHJveSgpO1xuICAgICAgICAvLyAgICAgdGhpcy5sb2FkZXIgPSBudWxsO1xuICAgICAgICAvLyB9XG4gICAgfVxuICAgIDtcbn1cbmV4cG9ydHMuQXBwbGljYXRpb24gPSBBcHBsaWNhdGlvbjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3Qgc2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL3NldHRpbmdzXCIpO1xuY29uc3QgTWF0aFNldHRpbmdzXzEgPSByZXF1aXJlKFwiLi9NYXRoU2V0dGluZ3NcIik7XG5jbGFzcyBBcmNVdGlscyB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgfVxuICAgIHN0YXRpYyBjdXJ2ZVRvKHgxLCB5MSwgeDIsIHkyLCByYWRpdXMsIHBvaW50cykge1xuICAgICAgICB2YXIgZnJvbVggPSBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDJdO1xuICAgICAgICB2YXIgZnJvbVkgPSBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDFdO1xuICAgICAgICB2YXIgYTEgPSBmcm9tWSAtIHkxO1xuICAgICAgICB2YXIgYjEgPSBmcm9tWCAtIHgxO1xuICAgICAgICB2YXIgYTIgPSB5MiAtIHkxO1xuICAgICAgICB2YXIgYjIgPSB4MiAtIHgxO1xuICAgICAgICB2YXIgbW0gPSBNYXRoLmFicygoYTEgKiBiMikgLSAoYjEgKiBhMikpO1xuICAgICAgICBpZiAobW0gPCAxLjBlLTggfHwgcmFkaXVzID09PSAwKSB7XG4gICAgICAgICAgICBpZiAocG9pbnRzW3BvaW50cy5sZW5ndGggLSAyXSAhPT0geDEgfHwgcG9pbnRzW3BvaW50cy5sZW5ndGggLSAxXSAhPT0geTEpIHtcbiAgICAgICAgICAgICAgICBwb2ludHMucHVzaCh4MSwgeTEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRkID0gKGExICogYTEpICsgKGIxICogYjEpO1xuICAgICAgICB2YXIgY2MgPSAoYTIgKiBhMikgKyAoYjIgKiBiMik7XG4gICAgICAgIHZhciB0dCA9IChhMSAqIGEyKSArIChiMSAqIGIyKTtcbiAgICAgICAgdmFyIGsxID0gcmFkaXVzICogTWF0aC5zcXJ0KGRkKSAvIG1tO1xuICAgICAgICB2YXIgazIgPSByYWRpdXMgKiBNYXRoLnNxcnQoY2MpIC8gbW07XG4gICAgICAgIHZhciBqMSA9IGsxICogdHQgLyBkZDtcbiAgICAgICAgdmFyIGoyID0gazIgKiB0dCAvIGNjO1xuICAgICAgICB2YXIgY3ggPSAoazEgKiBiMikgKyAoazIgKiBiMSk7XG4gICAgICAgIHZhciBjeSA9IChrMSAqIGEyKSArIChrMiAqIGExKTtcbiAgICAgICAgdmFyIHB4ID0gYjEgKiAoazIgKyBqMSk7XG4gICAgICAgIHZhciBweSA9IGExICogKGsyICsgajEpO1xuICAgICAgICB2YXIgcXggPSBiMiAqIChrMSArIGoyKTtcbiAgICAgICAgdmFyIHF5ID0gYTIgKiAoazEgKyBqMik7XG4gICAgICAgIHZhciBzdGFydEFuZ2xlID0gTWF0aC5hdGFuMihweSAtIGN5LCBweCAtIGN4KTtcbiAgICAgICAgdmFyIGVuZEFuZ2xlID0gTWF0aC5hdGFuMihxeSAtIGN5LCBxeCAtIGN4KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGN4OiAoY3ggKyB4MSksXG4gICAgICAgICAgICBjeTogKGN5ICsgeTEpLFxuICAgICAgICAgICAgcmFkaXVzOiByYWRpdXMsXG4gICAgICAgICAgICBzdGFydEFuZ2xlOiBzdGFydEFuZ2xlLFxuICAgICAgICAgICAgZW5kQW5nbGU6IGVuZEFuZ2xlLFxuICAgICAgICAgICAgYW50aWNsb2Nrd2lzZTogKGIxICogYTIgPiBiMiAqIGExKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFRoZSBhcmMgbWV0aG9kIGNyZWF0ZXMgYW4gYXJjL2N1cnZlICh1c2VkIHRvIGNyZWF0ZSBjaXJjbGVzLCBvciBwYXJ0cyBvZiBjaXJjbGVzKS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0WCAtIFN0YXJ0IHggbG9jYXRpb24gb2YgYXJjXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0WSAtIFN0YXJ0IHkgbG9jYXRpb24gb2YgYXJjXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGN4IC0gVGhlIHgtY29vcmRpbmF0ZSBvZiB0aGUgY2VudGVyIG9mIHRoZSBjaXJjbGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY3kgLSBUaGUgeS1jb29yZGluYXRlIG9mIHRoZSBjZW50ZXIgb2YgdGhlIGNpcmNsZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByYWRpdXMgLSBUaGUgcmFkaXVzIG9mIHRoZSBjaXJjbGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnRBbmdsZSAtIFRoZSBzdGFydGluZyBhbmdsZSwgaW4gcmFkaWFucyAoMCBpcyBhdCB0aGUgMyBvJ2Nsb2NrIHBvc2l0aW9uXG4gICAgICogIG9mIHRoZSBhcmMncyBjaXJjbGUpXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZEFuZ2xlIC0gVGhlIGVuZGluZyBhbmdsZSwgaW4gcmFkaWFuc1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gYW50aWNsb2Nrd2lzZSAtIFNwZWNpZmllcyB3aGV0aGVyIHRoZSBkcmF3aW5nIHNob3VsZCBiZVxuICAgICAqICBjb3VudGVyLWNsb2Nrd2lzZSBvciBjbG9ja3dpc2UuIEZhbHNlIGlzIGRlZmF1bHQsIGFuZCBpbmRpY2F0ZXMgY2xvY2t3aXNlLCB3aGlsZSB0cnVlXG4gICAgICogIGluZGljYXRlcyBjb3VudGVyLWNsb2Nrd2lzZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbiAtIE51bWJlciBvZiBzZWdtZW50c1xuICAgICAqIEBwYXJhbSB7bnVtYmVyW119IHBvaW50cyAtIENvbGxlY3Rpb24gb2YgcG9pbnRzIHRvIGFkZCB0b1xuICAgICAqL1xuICAgIHN0YXRpYyBhcmMoc3RhcnRYLCBzdGFydFksIGN4LCBjeSwgcmFkaXVzLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgYW50aWNsb2Nrd2lzZSwgcG9pbnRzKSB7XG4gICAgICAgIHZhciBzd2VlcCA9IGVuZEFuZ2xlIC0gc3RhcnRBbmdsZTtcbiAgICAgICAgdmFyIG4gPSBzZXR0aW5nc18xLnNldHRpbmdzLkdSQVBISUNTX0NVUlZFUy5fc2VnbWVudHNDb3VudChNYXRoLmFicyhzd2VlcCkgKiByYWRpdXMsIE1hdGguY2VpbChNYXRoLmFicyhzd2VlcCkgLyBNYXRoU2V0dGluZ3NfMS5NYXRoU2V0dGluZ3MuUElfMikgKiA0MCk7XG4gICAgICAgIHZhciB0aGV0YSA9IChzd2VlcCkgLyAobiAqIDIpO1xuICAgICAgICB2YXIgdGhldGEyID0gdGhldGEgKiAyO1xuICAgICAgICB2YXIgY1RoZXRhID0gTWF0aC5jb3ModGhldGEpO1xuICAgICAgICB2YXIgc1RoZXRhID0gTWF0aC5zaW4odGhldGEpO1xuICAgICAgICB2YXIgc2VnTWludXMgPSBuIC0gMTtcbiAgICAgICAgdmFyIHJlbWFpbmRlciA9IChzZWdNaW51cyAlIDEpIC8gc2VnTWludXM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IHNlZ01pbnVzOyArK2kpIHtcbiAgICAgICAgICAgIHZhciByZWFsID0gaSArIChyZW1haW5kZXIgKiBpKTtcbiAgICAgICAgICAgIHZhciBhbmdsZSA9ICgodGhldGEpICsgc3RhcnRBbmdsZSArICh0aGV0YTIgKiByZWFsKSk7XG4gICAgICAgICAgICB2YXIgYyA9IE1hdGguY29zKGFuZ2xlKTtcbiAgICAgICAgICAgIHZhciBzID0gLU1hdGguc2luKGFuZ2xlKTtcbiAgICAgICAgICAgIHBvaW50cy5wdXNoKCgoKGNUaGV0YSAqIGMpICsgKHNUaGV0YSAqIHMpKSAqIHJhZGl1cykgKyBjeCwgKCgoY1RoZXRhICogLXMpICsgKHNUaGV0YSAqIGMpKSAqIHJhZGl1cykgKyBjeSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xufVxuZXhwb3J0cy5BcmNVdGlscyA9IEFyY1V0aWxzO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBSZXNvdXJjZV8xID0gcmVxdWlyZShcIi4vUmVzb3VyY2VcIik7XG5jb25zdCBCYXNlVGV4dHVyZV8xID0gcmVxdWlyZShcIi4vQmFzZVRleHR1cmVcIik7XG5jb25zdCBSZXNvdXJjZVNldHRpbmdzXzEgPSByZXF1aXJlKFwiLi9SZXNvdXJjZVNldHRpbmdzXCIpO1xuY29uc3QgV2ViR0xTZXR0aW5nc18xID0gcmVxdWlyZShcIi4vV2ViR0xTZXR0aW5nc1wiKTtcbmNsYXNzIEFycmF5UmVzb3VyY2UgZXh0ZW5kcyBSZXNvdXJjZV8xLlJlc291cmNlIHtcbiAgICBjb25zdHJ1Y3Rvcihzb3VyY2UsIG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIHZhciB1cmxzO1xuICAgICAgICB2YXIgbGVuZ3RoID0gc291cmNlO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzb3VyY2UpKSB7XG4gICAgICAgICAgICB1cmxzID0gc291cmNlO1xuICAgICAgICAgICAgbGVuZ3RoID0gc291cmNlLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBzdXBlcihvcHRpb25zLndpZHRoLCBvcHRpb25zLmhlaWdodCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb2xsZWN0aW9uIG9mIHJlc291cmNlcy5cbiAgICAgICAgICogQG1lbWJlciB7QXJyYXk8UElYSS5CYXNlVGV4dHVyZT59XG4gICAgICAgICAqIEByZWFkb25seVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pdGVtcyA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgICogRGlydHkgSURzIGZvciBlYWNoIHBhcnRcbiAgICAgICAgICogQG1lbWJlciB7QXJyYXk8bnVtYmVyPn1cbiAgICAgICAgICogQHJlYWRvbmx5XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLml0ZW1EaXJ0eUlkcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcGFydFRleHR1cmUgPSBuZXcgQmFzZVRleHR1cmVfMS5CYXNlVGV4dHVyZSgpO1xuICAgICAgICAgICAgdGhpcy5pdGVtcy5wdXNoKHBhcnRUZXh0dXJlKTtcbiAgICAgICAgICAgIHRoaXMuaXRlbURpcnR5SWRzLnB1c2goLTEpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOdW1iZXIgb2YgZWxlbWVudHMgaW4gYXJyYXlcbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKiBAcmVhZG9ubHlcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICAvKipcbiAgICAgICAgICogUHJvbWlzZSB3aGVuIGxvYWRpbmdcbiAgICAgICAgICogQG1lbWJlciB7UHJvbWlzZX1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fbG9hZCA9IG51bGw7XG4gICAgICAgIGlmICh1cmxzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBsZW5ndGg7IGkkMSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRSZXNvdXJjZUF0KFJlc291cmNlU2V0dGluZ3NfMS5SZXNvdXJjZVNldHRpbmdzLmF1dG9EZXRlY3RSZXNvdXJjZSh1cmxzW2kkMV0sIG9wdGlvbnMpLCBpJDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlc3Ryb3kgdGhpcyBCYXNlSW1hZ2VSZXNvdXJjZVxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLml0ZW1zW2ldLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLml0ZW1zID0gbnVsbDtcbiAgICAgICAgdGhpcy5pdGVtRGlydHlJZHMgPSBudWxsO1xuICAgICAgICB0aGlzLl9sb2FkID0gbnVsbDtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFNldCBhIHJlc291cmNlIGJ5IElEXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BJWEkucmVzb3VyY2VzLlJlc291cmNlfSByZXNvdXJjZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIFplcm8tYmFzZWQgaW5kZXggb2YgcmVzb3VyY2UgdG8gc2V0XG4gICAgICogQHJldHVybiB7UElYSS5yZXNvdXJjZXMuQXJyYXlSZXNvdXJjZX0gSW5zdGFuY2UgZm9yIGNoYWluaW5nXG4gICAgICovXG4gICAgYWRkUmVzb3VyY2VBdChyZXNvdXJjZSwgaW5kZXgpIHtcbiAgICAgICAgdmFyIGJhc2VUZXh0dXJlID0gdGhpcy5pdGVtc1tpbmRleF07XG4gICAgICAgIGlmICghYmFzZVRleHR1cmUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigoXCJJbmRleCBcIiArIGluZGV4ICsgXCIgaXMgb3V0IG9mIGJvdW5kc1wiKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSW5oZXJpdCB0aGUgZmlyc3QgcmVzb3VyY2UgZGltZW5zaW9uc1xuICAgICAgICBpZiAocmVzb3VyY2UudmFsaWQgJiYgIXRoaXMudmFsaWQpIHtcbiAgICAgICAgICAgIHRoaXMucmVzaXplKHJlc291cmNlLndpZHRoLCByZXNvdXJjZS5oZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXRlbXNbaW5kZXhdLnNldFJlc291cmNlKHJlc291cmNlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHBhcmVudCBiYXNlIHRleHR1cmVcbiAgICAgKiBAbWVtYmVyIHtQSVhJLkJhc2VUZXh0dXJlfVxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIGJpbmQoYmFzZVRleHR1cmUpIHtcbiAgICAgICAgc3VwZXIuYmluZChiYXNlVGV4dHVyZSk7XG4gICAgICAgIGJhc2VUZXh0dXJlLnRhcmdldCA9IFdlYkdMU2V0dGluZ3NfMS5XZWJHTFNldHRpbmdzLlRBUkdFVFMuVEVYVFVSRV8yRF9BUlJBWTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLml0ZW1zW2ldLm9uKCd1cGRhdGUnLCBiYXNlVGV4dHVyZS51cGRhdGUsIGJhc2VUZXh0dXJlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogVW5zZXQgdGhlIHBhcmVudCBiYXNlIHRleHR1cmVcbiAgICAgKiBAbWVtYmVyIHtQSVhJLkJhc2VUZXh0dXJlfVxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIHVuYmluZChiYXNlVGV4dHVyZSkge1xuICAgICAgICBzdXBlci51bmJpbmQoYmFzZVRleHR1cmUpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuaXRlbXNbaV0ub2ZmKCd1cGRhdGUnLCBiYXNlVGV4dHVyZS51cGRhdGUsIGJhc2VUZXh0dXJlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogTG9hZCBhbGwgdGhlIHJlc291cmNlcyBzaW11bHRhbmVvdXNseVxuICAgICAqIEBvdmVycmlkZVxuICAgICAqIEByZXR1cm4ge1Byb21pc2U8dm9pZD59IFdoZW4gbG9hZCBpcyByZXNvbHZlZFxuICAgICAqL1xuICAgIGxvYWQoKSB7XG4gICAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5fbG9hZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xvYWQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlc291cmNlcyA9IHRoaXMuaXRlbXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiBpdGVtLnJlc291cmNlOyB9KTtcbiAgICAgICAgLy8gVE9ETzogYWxzbyBpbXBsZW1lbnQgbG9hZCBwYXJ0LWJ5LXBhcnQgc3RyYXRlZ3lcbiAgICAgICAgdmFyIHByb21pc2VzID0gcmVzb3VyY2VzLm1hcChmdW5jdGlvbiAoaXRlbSkgeyByZXR1cm4gaXRlbS5sb2FkKCk7IH0pO1xuICAgICAgICB0aGlzLl9sb2FkID0gUHJvbWlzZS5hbGwocHJvbWlzZXMpXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcmVmID0gcmVzb3VyY2VzWzBdO1xuICAgICAgICAgICAgdmFyIHdpZHRoID0gcmVmLndpZHRoO1xuICAgICAgICAgICAgdmFyIGhlaWdodCA9IHJlZi5oZWlnaHQ7XG4gICAgICAgICAgICB0aGlzJDEucmVzaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzJDEpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvYWQ7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBVcGxvYWQgdGhlIHJlc291cmNlcyB0byB0aGUgR1BVLlxuICAgICAqIEBwYXJhbSB7UElYSS5SZW5kZXJlcn0gcmVuZGVyZXJcbiAgICAgKiBAcGFyYW0ge1BJWEkuQmFzZVRleHR1cmV9IHRleHR1cmVcbiAgICAgKiBAcGFyYW0ge1BJWEkuR0xUZXh0dXJlfSBnbFRleHR1cmVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gd2hldGhlciB0ZXh0dXJlIHdhcyB1cGxvYWRlZFxuICAgICAqL1xuICAgIHVwbG9hZChyZW5kZXJlciwgdGV4dHVyZSwgZ2xUZXh0dXJlKSB7XG4gICAgICAgIHZhciByZWYgPSB0aGlzO1xuICAgICAgICB2YXIgbGVuZ3RoID0gcmVmLmxlbmd0aDtcbiAgICAgICAgdmFyIGl0ZW1EaXJ0eUlkcyA9IHJlZi5pdGVtRGlydHlJZHM7XG4gICAgICAgIHZhciBpdGVtcyA9IHJlZi5pdGVtcztcbiAgICAgICAgdmFyIGdsID0gcmVuZGVyZXIuZ2w7XG4gICAgICAgIGlmIChnbFRleHR1cmUuZGlydHlJZCA8IDApIHtcbiAgICAgICAgICAgIGdsLnRleEltYWdlM0QoZ2wuVEVYVFVSRV8yRF9BUlJBWSwgMCwgdGV4dHVyZS5mb3JtYXQsIHRoaXMuX3dpZHRoLCB0aGlzLl9oZWlnaHQsIGxlbmd0aCwgMCwgdGV4dHVyZS5mb3JtYXQsIHRleHR1cmUudHlwZSwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGl0ZW0gPSBpdGVtc1tpXTtcbiAgICAgICAgICAgIGlmIChpdGVtRGlydHlJZHNbaV0gPCBpdGVtLmRpcnR5SWQpIHtcbiAgICAgICAgICAgICAgICBpdGVtRGlydHlJZHNbaV0gPSBpdGVtLmRpcnR5SWQ7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0udmFsaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2wudGV4U3ViSW1hZ2UzRChnbC5URVhUVVJFXzJEX0FSUkFZLCAwLCAwLCAvLyB4b2Zmc2V0XG4gICAgICAgICAgICAgICAgICAgIDAsIC8vIHlvZmZzZXRcbiAgICAgICAgICAgICAgICAgICAgaSwgLy8gem9mZnNldFxuICAgICAgICAgICAgICAgICAgICBpdGVtLnJlc291cmNlLndpZHRoLCBpdGVtLnJlc291cmNlLmhlaWdodCwgMSwgdGV4dHVyZS5mb3JtYXQsIHRleHR1cmUudHlwZSwgaXRlbS5yZXNvdXJjZS5zb3VyY2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgO1xufVxuZXhwb3J0cy5BcnJheVJlc291cmNlID0gQXJyYXlSZXNvdXJjZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY2xhc3MgQXR0cmlidXRlIHtcbiAgICBjb25zdHJ1Y3RvcihidWZmZXIsIHNpemUsIG5vcm1hbGl6ZWQgPSBmYWxzZSwgdHlwZSA9IDUxMjYsIHN0cmlkZSA9IHVuZGVmaW5lZCwgc3RhcnQgPSB1bmRlZmluZWQsIGluc3RhbmNlID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gYnVmZmVyO1xuICAgICAgICB0aGlzLnNpemUgPSBzaXplO1xuICAgICAgICB0aGlzLm5vcm1hbGl6ZWQgPSBub3JtYWxpemVkO1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLl9zdHJpZGUgPSBzdHJpZGU7XG4gICAgICAgIHRoaXMuc3RhcnQgPSBzdGFydDtcbiAgICAgICAgdGhpcy5pbnN0YW5jZSA9IGluc3RhbmNlO1xuICAgIH1cbiAgICA7XG4gICAgc2V0IHN0cmlkZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9zdHJpZGUgPSB2YWx1ZTtcbiAgICB9XG4gICAgZ2V0IHN0cmlkZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0cmlkZTtcbiAgICB9XG4gICAgZGVzdHJveShvcHRpb25zID0gbnVsbCkge1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IG51bGw7XG4gICAgfVxuICAgIDtcbn1cbmV4cG9ydHMuQXR0cmlidXRlID0gQXR0cmlidXRlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBSZXNvdXJjZV8xID0gcmVxdWlyZShcIi4vUmVzb3VyY2VcIik7XG5jb25zdCBOZXR3b3JrU2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL05ldHdvcmtTZXR0aW5nc1wiKTtcbmNsYXNzIEJhc2VJbWFnZVJlc291cmNlIGV4dGVuZHMgUmVzb3VyY2VfMS5SZXNvdXJjZSB7XG4gICAgY29uc3RydWN0b3Ioc291cmNlKSB7XG4gICAgICAgIHN1cGVyKHNvdXJjZS53aWR0aCwgc291cmNlLmhlaWdodCk7XG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgY3Jvc3Mgb3JpZ2luIGJhc2VkIGRldGVjdGluZyB0aGUgdXJsIGFuZCB0aGUgY3Jvc3NvcmlnaW5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCAtIEVsZW1lbnQgdG8gYXBwbHkgY3Jvc3NPcmlnaW5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsIC0gVVJMIHRvIGNoZWNrXG4gICAgICogQHBhcmFtIHtib29sZWFufHN0cmluZ30gW2Nyb3Nzb3JpZ2luPXRydWVdIC0gQ3Jvc3Mgb3JpZ2luIHZhbHVlIHRvIHVzZVxuICAgICAqL1xuICAgIHN0YXRpYyBjcm9zc09yaWdpbihlbGVtZW50LCB1cmwsIGNyb3Nzb3JpZ2luKSB7XG4gICAgICAgIGlmIChjcm9zc29yaWdpbiA9PT0gdW5kZWZpbmVkICYmIHVybC5pbmRleE9mKCdkYXRhOicpICE9PSAwKSB7XG4gICAgICAgICAgICBlbGVtZW50LmNyb3NzT3JpZ2luID0gTmV0d29ya1NldHRpbmdzXzEuTmV0d29ya1NldHRpbmdzLmRldGVybWluZUNyb3NzT3JpZ2luKHVybCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY3Jvc3NvcmlnaW4gIT09IGZhbHNlKSB7XG4gICAgICAgICAgICBlbGVtZW50LmNyb3NzT3JpZ2luID0gdHlwZW9mIGNyb3Nzb3JpZ2luID09PSAnc3RyaW5nJyA/IGNyb3Nzb3JpZ2luIDogJ2Fub255bW91cyc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFVwbG9hZCB0aGUgdGV4dHVyZSB0byB0aGUgR1BVLlxuICAgICAqIEBwYXJhbSB7UElYSS5SZW5kZXJlcn0gcmVuZGVyZXIgVXBsb2FkIHRvIHRoZSByZW5kZXJlclxuICAgICAqIEBwYXJhbSB7UElYSS5CYXNlVGV4dHVyZX0gYmFzZVRleHR1cmUgUmVmZXJlbmNlIHRvIHBhcmVudCB0ZXh0dXJlXG4gICAgICogQHBhcmFtIHtQSVhJLkdMVGV4dHVyZX0gZ2xUZXh0dXJlXG4gICAgICogQHBhcmFtIHtIVE1MSW1hZ2VFbGVtZW50fEhUTUxDYW52YXNFbGVtZW50fEhUTUxWaWRlb0VsZW1lbnR8U1ZHRWxlbWVudH0gW3NvdXJjZV0gKG9wdGlvbmFsKVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlzIHN1Y2Nlc3NcbiAgICAgKi9cbiAgICB1cGxvYWQocmVuZGVyZXIsIGJhc2VUZXh0dXJlLCBnbFRleHR1cmUsIHNvdXJjZSA9IG51bGwpIHtcbiAgICAgICAgdmFyIGdsID0gcmVuZGVyZXIuZ2w7XG4gICAgICAgIHZhciB3aWR0aCA9IGJhc2VUZXh0dXJlLnJlYWxXaWR0aDtcbiAgICAgICAgdmFyIGhlaWdodCA9IGJhc2VUZXh0dXJlLnJlYWxIZWlnaHQ7XG4gICAgICAgIHNvdXJjZSA9IHNvdXJjZSB8fCB0aGlzLnNvdXJjZTtcbiAgICAgICAgZ2wucGl4ZWxTdG9yZWkoZ2wuVU5QQUNLX1BSRU1VTFRJUExZX0FMUEhBX1dFQkdMLCBiYXNlVGV4dHVyZS5wcmVtdWx0aXBseUFscGhhKTtcbiAgICAgICAgaWYgKGJhc2VUZXh0dXJlLnRhcmdldCA9PT0gZ2wuVEVYVFVSRV8yRCAmJiBnbFRleHR1cmUud2lkdGggPT09IHdpZHRoICYmIGdsVGV4dHVyZS5oZWlnaHQgPT09IGhlaWdodCkge1xuICAgICAgICAgICAgZ2wudGV4U3ViSW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCAwLCAwLCBiYXNlVGV4dHVyZS5mb3JtYXQsIGJhc2VUZXh0dXJlLnR5cGUsIHNvdXJjZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBnbFRleHR1cmUud2lkdGggPSB3aWR0aDtcbiAgICAgICAgICAgIGdsVGV4dHVyZS5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgICAgICBnbC50ZXhJbWFnZTJEKGJhc2VUZXh0dXJlLnRhcmdldCwgMCwgYmFzZVRleHR1cmUuZm9ybWF0LCBiYXNlVGV4dHVyZS5mb3JtYXQsIGJhc2VUZXh0dXJlLnR5cGUsIHNvdXJjZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBEZXN0cm95IHRoaXMgQmFzZUltYWdlUmVzb3VyY2VcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKiBAcGFyYW0ge1BJWEkuQmFzZVRleHR1cmV9IFtmcm9tVGV4dHVyZV0gT3B0aW9uYWwgYmFzZSB0ZXh0dXJlXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gRGVzdHJveSB3YXMgc3VjY2Vzc2Z1bFxuICAgICAqL1xuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgIHRoaXMuc291cmNlID0gbnVsbDtcbiAgICB9XG4gICAgO1xufVxuZXhwb3J0cy5CYXNlSW1hZ2VSZXNvdXJjZSA9IEJhc2VJbWFnZVJlc291cmNlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBUaWNrZXJfMSA9IHJlcXVpcmUoXCIuL1RpY2tlclwiKTtcbmNvbnN0IENvbnRhaW5lcl8xID0gcmVxdWlyZShcIi4vQ29udGFpbmVyXCIpO1xuY29uc3QgVGV4dFN0eWxlXzEgPSByZXF1aXJlKFwiLi9UZXh0U3R5bGVcIik7XG5jb25zdCBUZXh0XzEgPSByZXF1aXJlKFwiLi9UZXh0XCIpO1xuY29uc3QgVGV4dHVyZV8xID0gcmVxdWlyZShcIi4vVGV4dHVyZVwiKTtcbmNvbnN0IEJhc2VUZXh0dXJlXzEgPSByZXF1aXJlKFwiLi9CYXNlVGV4dHVyZVwiKTtcbmNvbnN0IFRleHRNZXRyaWNzXzEgPSByZXF1aXJlKFwiLi9UZXh0TWV0cmljc1wiKTtcbmNvbnN0IENvdW50TGltaXRlcl8xID0gcmVxdWlyZShcIi4vQ291bnRMaW1pdGVyXCIpO1xuY29uc3QgV2ViR0xTZXR0aW5nc18xID0gcmVxdWlyZShcIi4vV2ViR0xTZXR0aW5nc1wiKTtcbmNsYXNzIEJhc2VQcmVwYXJlIC8vZXh0ZW5kcyBSZW5kZXJlclxuIHtcbiAgICBjb25zdHJ1Y3RvcihyZW5kZXJlcikge1xuICAgICAgICAvLyBzdXBlcihudWxsKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBsaW1pdGVyIHRvIGJlIHVzZWQgdG8gY29udHJvbCBob3cgcXVpY2tseSBpdGVtcyBhcmUgcHJlcGFyZWQuXG4gICAgICAgICAqIEB0eXBlIHtQSVhJLnByZXBhcmUuQ291bnRMaW1pdGVyfFBJWEkucHJlcGFyZS5UaW1lTGltaXRlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubGltaXRlciA9IG5ldyBDb3VudExpbWl0ZXJfMS5Db3VudExpbWl0ZXIoV2ViR0xTZXR0aW5nc18xLldlYkdMU2V0dGluZ3MuVVBMT0FEU19QRVJfRlJBTUUpO1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVmZXJlbmNlIHRvIHRoZSByZW5kZXJlci5cbiAgICAgICAgICogQHR5cGUge1BJWEkuQWJzdHJhY3RSZW5kZXJlcn1cbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG9ubHkgcmVhbCBkaWZmZXJlbmNlIGJldHdlZW4gQ2FudmFzUHJlcGFyZSBhbmQgV2ViR0xQcmVwYXJlIGlzIHdoYXQgdGhleSBwYXNzXG4gICAgICAgICAqIHRvIHVwbG9hZCBob29rcy4gVGhhdCBkaWZmZXJlbnQgcGFyYW1ldGVyIGlzIHN0b3JlZCBoZXJlLlxuICAgICAgICAgKiBAdHlwZSB7UElYSS5wcmVwYXJlLkNhbnZhc1ByZXBhcmV8UElYSS5SZW5kZXJlcn1cbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy51cGxvYWRIb29rSGVscGVyID0gcmVuZGVyZXI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb2xsZWN0aW9uIG9mIGl0ZW1zIHRvIHVwbG9hZHMgYXQgb25jZS5cbiAgICAgICAgICogQHR5cGUge0FycmF5PCo+fVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5xdWV1ZSA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ29sbGVjdGlvbiBvZiBhZGRpdGlvbmFsIGhvb2tzIGZvciBmaW5kaW5nIGFzc2V0cy5cbiAgICAgICAgICogQHR5cGUge0FycmF5PEZ1bmN0aW9uPn1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYWRkSG9va3MgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbGxlY3Rpb24gb2YgYWRkaXRpb25hbCBob29rcyBmb3IgcHJvY2Vzc2luZyBhc3NldHMuXG4gICAgICAgICAqIEB0eXBlIHtBcnJheTxGdW5jdGlvbj59XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnVwbG9hZEhvb2tzID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYWxsYmFjayB0byBjYWxsIGFmdGVyIGNvbXBsZXRlZC5cbiAgICAgICAgICogQHR5cGUge0FycmF5PEZ1bmN0aW9uPn1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY29tcGxldGVzID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBwcmVwYXJlIGlzIHRpY2tpbmcgKHJ1bm5pbmcpLlxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudGlja2luZyA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogJ2JvdW5kJyBjYWxsIGZvciBwcmVwYXJlSXRlbXMoKS5cbiAgICAgICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kZWxheWVkVGljayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIHVubGlrZWx5LCBidXQgaW4gY2FzZSB3ZSB3ZXJlIGRlc3Ryb3llZCBiZXR3ZWVuIHRpY2soKSBhbmQgZGVsYXllZFRpY2soKVxuICAgICAgICAgICAgaWYgKCF0aGlzLnF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5wcmVwYXJlSXRlbXMoKTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gaG9va3MgdG8gZmluZCB0aGUgY29ycmVjdCB0ZXh0dXJlXG4gICAgICAgIHRoaXMucmVnaXN0ZXJGaW5kSG9vayhCYXNlUHJlcGFyZS5maW5kVGV4dCk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJGaW5kSG9vayhCYXNlUHJlcGFyZS5maW5kVGV4dFN0eWxlKTtcbiAgICAgICAgdGhpcy5yZWdpc3RlckZpbmRIb29rKEJhc2VQcmVwYXJlLmZpbmRNdWx0aXBsZUJhc2VUZXh0dXJlcyk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJGaW5kSG9vayhCYXNlUHJlcGFyZS5maW5kQmFzZVRleHR1cmUpO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyRmluZEhvb2soQmFzZVByZXBhcmUuZmluZFRleHR1cmUpO1xuICAgICAgICAvLyB1cGxvYWQgaG9va3NcbiAgICAgICAgdGhpcy5yZWdpc3RlclVwbG9hZEhvb2soQmFzZVByZXBhcmUuZHJhd1RleHQpO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyVXBsb2FkSG9vayhCYXNlUHJlcGFyZS5jYWxjdWxhdGVUZXh0U3R5bGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGxvYWQgYWxsIHRoZSB0ZXh0dXJlcyBhbmQgZ3JhcGhpY3MgdG8gdGhlIEdQVS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb258UElYSS5EaXNwbGF5T2JqZWN0fFBJWEkuQ29udGFpbmVyfFBJWEkuQmFzZVRleHR1cmV8UElYSS5UZXh0dXJlfFBJWEkuR3JhcGhpY3N8UElYSS5UZXh0fSBpdGVtIC1cbiAgICAgKiAgICBFaXRoZXIgdGhlIGNvbnRhaW5lciBvciBkaXNwbGF5IG9iamVjdCB0byBzZWFyY2ggZm9yIGl0ZW1zIHRvIHVwbG9hZCwgdGhlIGl0ZW1zIHRvIHVwbG9hZCB0aGVtc2VsdmVzLFxuICAgICAqICAgIG9yIHRoZSBjYWxsYmFjayBmdW5jdGlvbiwgaWYgaXRlbXMgaGF2ZSBiZWVuIGFkZGVkIHVzaW5nIGBwcmVwYXJlLmFkZGAuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2RvbmVdIC0gT3B0aW9uYWwgY2FsbGJhY2sgd2hlbiBhbGwgcXVldWVkIHVwbG9hZHMgaGF2ZSBjb21wbGV0ZWRcbiAgICAgKi9cbiAgICB1cGxvYWQoaXRlbSwgZG9uZSkge1xuICAgICAgICBpZiAodHlwZW9mIGl0ZW0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGRvbmUgPSBpdGVtO1xuICAgICAgICAgICAgaXRlbSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgYSBkaXNwbGF5IG9iamVjdCwgc2VhcmNoIGZvciBpdGVtc1xuICAgICAgICAvLyB0aGF0IHdlIGNvdWxkIHVwbG9hZFxuICAgICAgICBpZiAoaXRlbSkge1xuICAgICAgICAgICAgdGhpcy5hZGQoaXRlbSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gR2V0IHRoZSBpdGVtcyBmb3IgdXBsb2FkIGZyb20gdGhlIGRpc3BsYXlcbiAgICAgICAgaWYgKHRoaXMucXVldWUubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29tcGxldGVzLnB1c2goZG9uZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMudGlja2luZykge1xuICAgICAgICAgICAgICAgIHRoaXMudGlja2luZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgVGlja2VyXzEuVGlja2VyLnN5c3RlbS5hZGRPbmNlKHRoaXMudGljaywgdGhpcywgVGlja2VyXzEuVGlja2VyLlVQREFURV9QUklPUklUWS5VVElMSVRZKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkb25lKSB7XG4gICAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIEhhbmRsZSB0aWNrIHVwZGF0ZVxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aWNrKCkge1xuICAgICAgICBzZXRUaW1lb3V0KHRoaXMuZGVsYXllZFRpY2ssIDApO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogQWN0dWFsbHkgcHJlcGFyZSBpdGVtcy4gVGhpcyBpcyBoYW5kbGVkIG91dHNpZGUgb2YgdGhlIHRpY2sgYmVjYXVzZSBpdCB3aWxsIHRha2UgYSB3aGlsZVxuICAgICAqIGFuZCB3ZSBkbyBOT1Qgd2FudCB0byBibG9jayB0aGUgY3VycmVudCBhbmltYXRpb24gZnJhbWUgZnJvbSByZW5kZXJpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHByZXBhcmVJdGVtcygpIHtcbiAgICAgICAgdGhpcy5saW1pdGVyLmJlZ2luRnJhbWUoKTtcbiAgICAgICAgLy8gVXBsb2FkIHRoZSBncmFwaGljc1xuICAgICAgICB3aGlsZSAodGhpcy5xdWV1ZS5sZW5ndGggJiYgdGhpcy5saW1pdGVyLmFsbG93ZWRUb1VwbG9hZCgpKSB7XG4gICAgICAgICAgICB2YXIgaXRlbSA9IHRoaXMucXVldWVbMF07XG4gICAgICAgICAgICB2YXIgdXBsb2FkZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChpdGVtICYmICFpdGVtLl9kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy51cGxvYWRIb29rcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy51cGxvYWRIb29rc1tpXSh0aGlzLnVwbG9hZEhvb2tIZWxwZXIsIGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cGxvYWRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdXBsb2FkZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2UncmUgZmluaXNoZWRcbiAgICAgICAgaWYgKCF0aGlzLnF1ZXVlLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy50aWNraW5nID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgY29tcGxldGVzID0gdGhpcy5jb21wbGV0ZXMuc2xpY2UoMCk7XG4gICAgICAgICAgICB0aGlzLmNvbXBsZXRlcy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgZm9yICh2YXIgaSQxID0gMCwgbGVuJDEgPSBjb21wbGV0ZXMubGVuZ3RoOyBpJDEgPCBsZW4kMTsgaSQxKyspIHtcbiAgICAgICAgICAgICAgICBjb21wbGV0ZXNbaSQxXSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gaWYgd2UgYXJlIG5vdCBmaW5pc2hlZCwgb24gdGhlIG5leHQgckFGIGRvIHRoaXMgYWdhaW5cbiAgICAgICAgICAgIFRpY2tlcl8xLlRpY2tlci5zeXN0ZW0uYWRkT25jZSh0aGlzLnRpY2ssIHRoaXMsIFRpY2tlcl8xLlRpY2tlci5VUERBVEVfUFJJT1JJVFkuVVRJTElUWSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIEFkZHMgaG9va3MgZm9yIGZpbmRpbmcgaXRlbXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBhZGRIb29rIC0gRnVuY3Rpb24gY2FsbCB0aGF0IHRha2VzIHR3byBwYXJhbWV0ZXJzOiBgaXRlbToqLCBxdWV1ZTpBcnJheWBcbiAgICAgKiAgICAgIGZ1bmN0aW9uIG11c3QgcmV0dXJuIGB0cnVlYCBpZiBpdCB3YXMgYWJsZSB0byBhZGQgaXRlbSB0byB0aGUgcXVldWUuXG4gICAgICogQHJldHVybiB7UElYSS5wcmVwYXJlLkJhc2VQcmVwYXJlfSBJbnN0YW5jZSBvZiBwbHVnaW4gZm9yIGNoYWluaW5nLlxuICAgICAqL1xuICAgIHJlZ2lzdGVyRmluZEhvb2soYWRkSG9vaykge1xuICAgICAgICBpZiAoYWRkSG9vaykge1xuICAgICAgICAgICAgdGhpcy5hZGRIb29rcy5wdXNoKGFkZEhvb2spO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogQWRkcyBob29rcyBmb3IgdXBsb2FkaW5nIGl0ZW1zLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gdXBsb2FkSG9vayAtIEZ1bmN0aW9uIGNhbGwgdGhhdCB0YWtlcyB0d28gcGFyYW1ldGVyczogYHByZXBhcmU6Q2FudmFzUHJlcGFyZSwgaXRlbToqYCBhbmRcbiAgICAgKiAgICAgIGZ1bmN0aW9uIG11c3QgcmV0dXJuIGB0cnVlYCBpZiBpdCB3YXMgYWJsZSB0byBoYW5kbGUgdXBsb2FkIG9mIGl0ZW0uXG4gICAgICogQHJldHVybiB7UElYSS5wcmVwYXJlLkJhc2VQcmVwYXJlfSBJbnN0YW5jZSBvZiBwbHVnaW4gZm9yIGNoYWluaW5nLlxuICAgICAqL1xuICAgIHJlZ2lzdGVyVXBsb2FkSG9vayh1cGxvYWRIb29rKSB7XG4gICAgICAgIGlmICh1cGxvYWRIb29rKSB7XG4gICAgICAgICAgICB0aGlzLnVwbG9hZEhvb2tzLnB1c2godXBsb2FkSG9vayk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBNYW51YWxseSBhZGQgYW4gaXRlbSB0byB0aGUgdXBsb2FkaW5nIHF1ZXVlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQSVhJLkRpc3BsYXlPYmplY3R8UElYSS5Db250YWluZXJ8UElYSS5CYXNlVGV4dHVyZXxQSVhJLlRleHR1cmV8UElYSS5HcmFwaGljc3xQSVhJLlRleHR8Kn0gaXRlbSAtIE9iamVjdCB0b1xuICAgICAqICAgIGFkZCB0byB0aGUgcXVldWVcbiAgICAgKiBAcmV0dXJuIHtQSVhJLnByZXBhcmUuQmFzZVByZXBhcmV9IEluc3RhbmNlIG9mIHBsdWdpbiBmb3IgY2hhaW5pbmcuXG4gICAgICovXG4gICAgYWRkKGl0ZW0pIHtcbiAgICAgICAgLy8gQWRkIGFkZGl0aW9uYWwgaG9va3MgZm9yIGZpbmRpbmcgZWxlbWVudHMgb24gc3BlY2lhbFxuICAgICAgICAvLyB0eXBlcyBvZiBvYmplY3RzIHRoYXRcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuYWRkSG9va3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmFkZEhvb2tzW2ldKGl0ZW0sIHRoaXMucXVldWUpKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gR2V0IGNoaWxkcmVuIHJlY3Vyc2l2ZWx5XG4gICAgICAgIGlmIChpdGVtIGluc3RhbmNlb2YgQ29udGFpbmVyXzEuQ29udGFpbmVyKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpJDEgPSBpdGVtLmNoaWxkcmVuLmxlbmd0aCAtIDE7IGkkMSA+PSAwOyBpJDEtLSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkKGl0ZW0uY2hpbGRyZW5baSQxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBEZXN0cm95cyB0aGUgcGx1Z2luLCBkb24ndCB1c2UgYWZ0ZXIgdGhpcy5cbiAgICAgKlxuICAgICAqL1xuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIGlmICh0aGlzLnRpY2tpbmcpIHtcbiAgICAgICAgICAgIFRpY2tlcl8xLlRpY2tlci5zeXN0ZW0ucmVtb3ZlKHRoaXMudGljaywgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50aWNraW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYWRkSG9va3MgPSBudWxsO1xuICAgICAgICB0aGlzLnVwbG9hZEhvb2tzID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IG51bGw7XG4gICAgICAgIHRoaXMuY29tcGxldGVzID0gbnVsbDtcbiAgICAgICAgdGhpcy5xdWV1ZSA9IG51bGw7XG4gICAgICAgIHRoaXMubGltaXRlciA9IG51bGw7XG4gICAgICAgIHRoaXMudXBsb2FkSG9va0hlbHBlciA9IG51bGw7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAqIEJ1aWx0LWluIGhvb2sgdG8gZmluZCBUZXh0IG9iamVjdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7UElYSS5EaXNwbGF5T2JqZWN0fSBpdGVtIC0gRGlzcGxheSBvYmplY3QgdG8gY2hlY2tcbiAqIEBwYXJhbSB7QXJyYXk8Kj59IHF1ZXVlIC0gQ29sbGVjdGlvbiBvZiBpdGVtcyB0byB1cGxvYWRcbiAqIEByZXR1cm4ge2Jvb2xlYW59IGlmIGEgUElYSS5UZXh0IG9iamVjdCB3YXMgZm91bmQuXG4gKi9cbiAgICBzdGF0aWMgZmluZFRleHQoaXRlbSwgcXVldWUpIHtcbiAgICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBUZXh0XzEuVGV4dCkge1xuICAgICAgICAgICAgLy8gcHVzaCB0aGUgdGV4dCBzdHlsZSB0byBwcmVwYXJlIGl0IC0gdGhpcyBjYW4gYmUgcmVhbGx5IGV4cGVuc2l2ZVxuICAgICAgICAgICAgaWYgKHF1ZXVlLmluZGV4T2YoaXRlbS5zdHlsZSkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcXVldWUucHVzaChpdGVtLnN0eWxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGFsc28gcHVzaCB0aGUgdGV4dCBvYmplY3Qgc28gdGhhdCB3ZSBjYW4gcmVuZGVyIGl0ICh0byBjYW52YXMvdGV4dHVyZSkgaWYgbmVlZGVkXG4gICAgICAgICAgICBpZiAocXVldWUuaW5kZXhPZihpdGVtKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBxdWV1ZS5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYWxzbyBwdXNoIHRoZSBUZXh0J3MgdGV4dHVyZSBmb3IgdXBsb2FkIHRvIEdQVVxuICAgICAgICAgICAgdmFyIHRleHR1cmUgPSBpdGVtLl90ZXh0dXJlLmJhc2VUZXh0dXJlO1xuICAgICAgICAgICAgaWYgKHF1ZXVlLmluZGV4T2YodGV4dHVyZSkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcXVldWUucHVzaCh0ZXh0dXJlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gKiBCdWlsdC1pbiBob29rIHRvIGZpbmQgVGV4dFN0eWxlIG9iamVjdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7UElYSS5UZXh0U3R5bGV9IGl0ZW0gLSBEaXNwbGF5IG9iamVjdCB0byBjaGVja1xuICogQHBhcmFtIHtBcnJheTwqPn0gcXVldWUgLSBDb2xsZWN0aW9uIG9mIGl0ZW1zIHRvIHVwbG9hZFxuICogQHJldHVybiB7Ym9vbGVhbn0gaWYgYSBQSVhJLlRleHRTdHlsZSBvYmplY3Qgd2FzIGZvdW5kLlxuICovXG4gICAgc3RhdGljIGZpbmRUZXh0U3R5bGUoaXRlbSwgcXVldWUpIHtcbiAgICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBUZXh0U3R5bGVfMS5UZXh0U3R5bGUpIHtcbiAgICAgICAgICAgIGlmIChxdWV1ZS5pbmRleE9mKGl0ZW0pID09PSAtMSkge1xuICAgICAgICAgICAgICAgIHF1ZXVlLnB1c2goaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICogQnVpbHQtaW4gaG9vayB0byBmaW5kIG11bHRpcGxlIHRleHR1cmVzIGZyb20gb2JqZWN0cyBsaWtlIEFuaW1hdGVkU3ByaXRlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtQSVhJLkRpc3BsYXlPYmplY3R9IGl0ZW0gLSBEaXNwbGF5IG9iamVjdCB0byBjaGVja1xuICogQHBhcmFtIHtBcnJheTwqPn0gcXVldWUgLSBDb2xsZWN0aW9uIG9mIGl0ZW1zIHRvIHVwbG9hZFxuICogQHJldHVybiB7Ym9vbGVhbn0gaWYgYSBQSVhJLlRleHR1cmUgb2JqZWN0IHdhcyBmb3VuZC5cbiAqL1xuICAgIHN0YXRpYyBmaW5kTXVsdGlwbGVCYXNlVGV4dHVyZXMoaXRlbSwgcXVldWUpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICAvLyBPYmplY3RzIHdpdGggbXVsdGlwbGUgdGV4dHVyZXNcbiAgICAgICAgaWYgKGl0ZW0gJiYgaXRlbS5fdGV4dHVyZXMgJiYgaXRlbS5fdGV4dHVyZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGl0ZW0uX3RleHR1cmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0uX3RleHR1cmVzW2ldIGluc3RhbmNlb2YgVGV4dHVyZV8xLlRleHR1cmUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJhc2VUZXh0dXJlID0gaXRlbS5fdGV4dHVyZXNbaV0uYmFzZVRleHR1cmU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChxdWV1ZS5pbmRleE9mKGJhc2VUZXh0dXJlKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXVlLnB1c2goYmFzZVRleHR1cmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAqIEJ1aWx0LWluIGhvb2sgdG8gZmluZCBCYXNlVGV4dHVyZXMgZnJvbSBTcHJpdGVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1BJWEkuRGlzcGxheU9iamVjdH0gaXRlbSAtIERpc3BsYXkgb2JqZWN0IHRvIGNoZWNrXG4gKiBAcGFyYW0ge0FycmF5PCo+fSBxdWV1ZSAtIENvbGxlY3Rpb24gb2YgaXRlbXMgdG8gdXBsb2FkXG4gKiBAcmV0dXJuIHtib29sZWFufSBpZiBhIFBJWEkuVGV4dHVyZSBvYmplY3Qgd2FzIGZvdW5kLlxuICovXG4gICAgc3RhdGljIGZpbmRCYXNlVGV4dHVyZShpdGVtLCBxdWV1ZSkge1xuICAgICAgICAvLyBPYmplY3RzIHdpdGggdGV4dHVyZXMsIGxpa2UgU3ByaXRlcy9UZXh0XG4gICAgICAgIGlmIChpdGVtIGluc3RhbmNlb2YgQmFzZVRleHR1cmVfMS5CYXNlVGV4dHVyZSkge1xuICAgICAgICAgICAgaWYgKHF1ZXVlLmluZGV4T2YoaXRlbSkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcXVldWUucHVzaChpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gKiBCdWlsdC1pbiBob29rIHRvIGZpbmQgdGV4dHVyZXMgZnJvbSBvYmplY3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1BJWEkuRGlzcGxheU9iamVjdH0gaXRlbSAtIERpc3BsYXkgb2JqZWN0IHRvIGNoZWNrXG4gKiBAcGFyYW0ge0FycmF5PCo+fSBxdWV1ZSAtIENvbGxlY3Rpb24gb2YgaXRlbXMgdG8gdXBsb2FkXG4gKiBAcmV0dXJuIHtib29sZWFufSBpZiBhIFBJWEkuVGV4dHVyZSBvYmplY3Qgd2FzIGZvdW5kLlxuICovXG4gICAgc3RhdGljIGZpbmRUZXh0dXJlKGl0ZW0sIHF1ZXVlKSB7XG4gICAgICAgIGlmIChpdGVtLl90ZXh0dXJlICYmIGl0ZW0uX3RleHR1cmUgaW5zdGFuY2VvZiBUZXh0dXJlXzEuVGV4dHVyZSkge1xuICAgICAgICAgICAgdmFyIHRleHR1cmUgPSBpdGVtLl90ZXh0dXJlLmJhc2VUZXh0dXJlO1xuICAgICAgICAgICAgaWYgKHF1ZXVlLmluZGV4T2YodGV4dHVyZSkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcXVldWUucHVzaCh0ZXh0dXJlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQnVpbHQtaW4gaG9vayB0byBkcmF3IFBJWEkuVGV4dCB0byBpdHMgdGV4dHVyZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtQSVhJLlJlbmRlcmVyfFBJWEkuQ2FudmFzUHJlcGFyZX0gaGVscGVyIC0gTm90IHVzZWQgYnkgdGhpcyB1cGxvYWQgaGFuZGxlclxuICAgICAqIEBwYXJhbSB7UElYSS5EaXNwbGF5T2JqZWN0fSBpdGVtIC0gSXRlbSB0byBjaGVja1xuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IElmIGl0ZW0gd2FzIHVwbG9hZGVkLlxuICAgICAqL1xuICAgIHN0YXRpYyBkcmF3VGV4dChoZWxwZXIsIGl0ZW0pIHtcbiAgICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBUZXh0XzEuVGV4dCkge1xuICAgICAgICAgICAgLy8gdXBkYXRpbmcgdGV4dCB3aWxsIHJldHVybiBlYXJseSBpZiBpdCBpcyBub3QgZGlydHlcbiAgICAgICAgICAgIGl0ZW0udXBkYXRlVGV4dCh0cnVlKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gKiBCdWlsdC1pbiBob29rIHRvIGNhbGN1bGF0ZSBhIHRleHQgc3R5bGUgZm9yIGEgUElYSS5UZXh0IG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtQSVhJLlJlbmRlcmVyfFBJWEkuQ2FudmFzUHJlcGFyZX0gaGVscGVyIC0gTm90IHVzZWQgYnkgdGhpcyB1cGxvYWQgaGFuZGxlclxuICogQHBhcmFtIHtQSVhJLkRpc3BsYXlPYmplY3R9IGl0ZW0gLSBJdGVtIHRvIGNoZWNrXG4gKiBAcmV0dXJuIHtib29sZWFufSBJZiBpdGVtIHdhcyB1cGxvYWRlZC5cbiAqL1xuICAgIHN0YXRpYyBjYWxjdWxhdGVUZXh0U3R5bGUoaGVscGVyLCBpdGVtKSB7XG4gICAgICAgIGlmIChpdGVtIGluc3RhbmNlb2YgVGV4dFN0eWxlXzEuVGV4dFN0eWxlKSB7XG4gICAgICAgICAgICB2YXIgZm9udCA9IGl0ZW0udG9Gb250U3RyaW5nKCk7XG4gICAgICAgICAgICBUZXh0TWV0cmljc18xLlRleHRNZXRyaWNzLm1lYXN1cmVGb250KGZvbnQpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmV4cG9ydHMuQmFzZVByZXBhcmUgPSBCYXNlUHJlcGFyZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgQmFzZVRleHR1cmVfMSA9IHJlcXVpcmUoXCIuL0Jhc2VUZXh0dXJlXCIpO1xuY29uc3QgRnJhbWVidWZmZXJfMSA9IHJlcXVpcmUoXCIuL0ZyYW1lYnVmZmVyXCIpO1xuY2xhc3MgQmFzZVJlbmRlclRleHR1cmUgZXh0ZW5kcyBCYXNlVGV4dHVyZV8xLkJhc2VUZXh0dXJlIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zLCBhcmcxID0gbnVsbCwgYXJnMiA9IG51bGwsIGFyZzQgPSBudWxsKSB7XG4gICAgICAgIHN1cGVyKG51bGwsIG9wdGlvbnMpO1xuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBwcmVmZXItcmVzdC1wYXJhbXMgKi9cbiAgICAgICAgICAgIC8vIEJhY2t3YXJkIGNvbXBhdGliaWxpdHkgb2Ygc2lnbmF0dXJlXG4gICAgICAgICAgICB2YXIgd2lkdGgkMSA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgICAgIHZhciBoZWlnaHQkMSA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgICAgIHZhciBzY2FsZU1vZGUgPSBhcmd1bWVudHNbMl07XG4gICAgICAgICAgICB2YXIgcmVzb2x1dGlvbiA9IGFyZ3VtZW50c1szXTtcbiAgICAgICAgICAgIG9wdGlvbnMgPSB7IHdpZHRoOiB3aWR0aCQxLCBoZWlnaHQ6IGhlaWdodCQxLCBzY2FsZU1vZGU6IHNjYWxlTW9kZSwgcmVzb2x1dGlvbjogcmVzb2x1dGlvbiB9O1xuICAgICAgICAgICAgLyogZXNsaW50LWVuYWJsZSBwcmVmZXItcmVzdC1wYXJhbXMgKi9cbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVmID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgdmFyIHdpZHRoID0gcmVmLndpZHRoO1xuICAgICAgICB2YXIgaGVpZ2h0ID0gcmVmLmhlaWdodDtcbiAgICAgICAgLy8gU2V0IGRlZmF1bHRzXG4gICAgICAgIHRoaXMubWlwbWFwID0gZmFsc2U7XG4gICAgICAgIHRoaXMud2lkdGggPSBNYXRoLmNlaWwod2lkdGgpIHx8IDEwMDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBNYXRoLmNlaWwoaGVpZ2h0KSB8fCAxMDA7XG4gICAgICAgIHRoaXMudmFsaWQgPSB0cnVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogQSByZWZlcmVuY2UgdG8gdGhlIGNhbnZhcyByZW5kZXIgdGFyZ2V0ICh3ZSBvbmx5IG5lZWQgb25lIGFzIHRoaXMgY2FuIGJlIHNoYXJlZCBhY3Jvc3MgcmVuZGVyZXJzKVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqIEBtZW1iZXIge29iamVjdH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2NhbnZhc1JlbmRlclRhcmdldCA9IG51bGw7XG4gICAgICAgIHRoaXMuY2xlYXJDb2xvciA9IFswLCAwLCAwLCAwXTtcbiAgICAgICAgdGhpcy5mcmFtZWJ1ZmZlciA9IG5ldyBGcmFtZWJ1ZmZlcl8xLkZyYW1lYnVmZmVyKHRoaXMud2lkdGggKiB0aGlzLnJlc29sdXRpb24sIHRoaXMuaGVpZ2h0ICogdGhpcy5yZXNvbHV0aW9uKVxuICAgICAgICAgICAgLmFkZENvbG9yVGV4dHVyZSgwLCB0aGlzKVxuICAgICAgICAgICAgLmVuYWJsZVN0ZW5jaWwoKTtcbiAgICAgICAgLy8gVE9ETyAtIGNvdWxkIHRoaXMgYmUgYWRkZWQgdGhlIHN5c3RlbXM/XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZGF0YSBzdHJ1Y3R1cmUgZm9yIHRoZSBzdGVuY2lsIG1hc2tzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLkdyYXBoaWNzW119XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0ZW5jaWxNYXNrU3RhY2sgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBkYXRhIHN0cnVjdHVyZSBmb3IgdGhlIGZpbHRlcnMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuR3JhcGhpY3NbXX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZmlsdGVyU3RhY2sgPSBbe31dO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXNpemVzIHRoZSBCYXNlUmVuZGVyVGV4dHVyZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCAtIFRoZSB3aWR0aCB0byByZXNpemUgdG8uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCAtIFRoZSBoZWlnaHQgdG8gcmVzaXplIHRvLlxuICAgICAqL1xuICAgIHJlc2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHdpZHRoID0gTWF0aC5jZWlsKHdpZHRoKTtcbiAgICAgICAgaGVpZ2h0ID0gTWF0aC5jZWlsKGhlaWdodCk7XG4gICAgICAgIHRoaXMuZnJhbWVidWZmZXIucmVzaXplKHdpZHRoICogdGhpcy5yZXNvbHV0aW9uLCBoZWlnaHQgKiB0aGlzLnJlc29sdXRpb24pO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogRnJlZXMgdGhlIHRleHR1cmUgYW5kIGZyYW1lYnVmZmVyIGZyb20gV2ViR0wgbWVtb3J5IHdpdGhvdXQgZGVzdHJveWluZyB0aGlzIHRleHR1cmUgb2JqZWN0LlxuICAgICAqIFRoaXMgbWVhbnMgeW91IGNhbiBzdGlsbCB1c2UgdGhlIHRleHR1cmUgbGF0ZXIgd2hpY2ggd2lsbCB1cGxvYWQgaXQgdG8gR1BVXG4gICAgICogbWVtb3J5IGFnYWluLlxuICAgICAqXG4gICAgICogQGZpcmVzIFBJWEkuQmFzZVRleHR1cmUjZGlzcG9zZVxuICAgICAqL1xuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgIHRoaXMuZnJhbWVidWZmZXIuZGlzcG9zZSgpO1xuICAgICAgICBzdXBlci5kaXNwb3NlKCk7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBEZXN0cm95cyB0aGlzIHRleHR1cmUuXG4gICAgICpcbiAgICAgKi9cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBzdXBlci5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuZnJhbWVidWZmZXIgPSBudWxsO1xuICAgICAgICB0aGlzLnJlbmRlcmVyID0gbnVsbDtcbiAgICB9XG4gICAgO1xufVxuZXhwb3J0cy5CYXNlUmVuZGVyVGV4dHVyZSA9IEJhc2VSZW5kZXJUZXh0dXJlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBFdmVudERpc3BhdGNoZXJfMSA9IHJlcXVpcmUoXCIuL0V2ZW50RGlzcGF0Y2hlclwiKTtcbmNvbnN0IEV2ZW50XzEgPSByZXF1aXJlKFwiLi9FdmVudFwiKTtcbmNvbnN0IFJlc291cmNlXzEgPSByZXF1aXJlKFwiLi9SZXNvdXJjZVwiKTtcbmNvbnN0IEJ1ZmZlclJlc291cmNlXzEgPSByZXF1aXJlKFwiLi9CdWZmZXJSZXNvdXJjZVwiKTtcbmNvbnN0IERpc3BsYXlTZXR0aW5nc18xID0gcmVxdWlyZShcIi4vRGlzcGxheVNldHRpbmdzXCIpO1xuY29uc3QgTWF0aFNldHRpbmdzXzEgPSByZXF1aXJlKFwiLi9NYXRoU2V0dGluZ3NcIik7XG5jb25zdCBXZWJHTFNldHRpbmdzXzEgPSByZXF1aXJlKFwiLi9XZWJHTFNldHRpbmdzXCIpO1xuY29uc3QgQ2FjaGVTZXR0aW5nc18xID0gcmVxdWlyZShcIi4vQ2FjaGVTZXR0aW5nc1wiKTtcbmNvbnN0IFJlc291cmNlU2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL1Jlc291cmNlU2V0dGluZ3NcIik7XG5jbGFzcyBCYXNlVGV4dHVyZSBleHRlbmRzIEV2ZW50RGlzcGF0Y2hlcl8xLkV2ZW50RGlzcGF0Y2hlciB7XG4gICAgY29uc3RydWN0b3IocmVzb3VyY2UgPSBudWxsLCBvcHRpb25zID0gbnVsbCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmhhbmRsZVJlc2l6ZSA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zZXRSZWFsU2l6ZSh0aGlzLnJlc291cmNlLndpZHRoLCB0aGlzLnJlc291cmNlLmhlaWdodCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlVXBkYXRlID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgICAgICB9O1xuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgdmFyIHByZW11bHRpcGx5QWxwaGEgPSBvcHRpb25zLnByZW11bHRpcGx5QWxwaGE7XG4gICAgICAgIHZhciBtaXBtYXAgPSBvcHRpb25zLm1pcG1hcDtcbiAgICAgICAgdmFyIHNjYWxlTW9kZSA9IG9wdGlvbnMuc2NhbGVNb2RlO1xuICAgICAgICB2YXIgd2lkdGggPSBvcHRpb25zLndpZHRoO1xuICAgICAgICB2YXIgaGVpZ2h0ID0gb3B0aW9ucy5oZWlnaHQ7XG4gICAgICAgIHZhciB3cmFwTW9kZSA9IG9wdGlvbnMud3JhcE1vZGU7XG4gICAgICAgIHZhciBmb3JtYXQgPSBvcHRpb25zLmZvcm1hdDtcbiAgICAgICAgdmFyIHR5cGUgPSBvcHRpb25zLnR5cGU7XG4gICAgICAgIHZhciB0YXJnZXQgPSBvcHRpb25zLnRhcmdldDtcbiAgICAgICAgdmFyIHJlc29sdXRpb24gPSBvcHRpb25zLnJlc29sdXRpb247XG4gICAgICAgIHZhciByZXNvdXJjZU9wdGlvbnMgPSBvcHRpb25zLnJlc291cmNlT3B0aW9ucztcbiAgICAgICAgLy8gQ29udmVydCB0aGUgcmVzb3VyY2UgdG8gYSBSZXNvdXJjZSBvYmplY3RcbiAgICAgICAgaWYgKHJlc291cmNlICYmIHJlc291cmNlIGluc3RhbmNlb2YgSW1hZ2VCaXRtYXApIHtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyZXNvdXJjZSAmJiAhKHJlc291cmNlIGluc3RhbmNlb2YgUmVzb3VyY2VfMS5SZXNvdXJjZSkpIHtcbiAgICAgICAgICAgIHJlc291cmNlID0gUmVzb3VyY2VTZXR0aW5nc18xLlJlc291cmNlU2V0dGluZ3MuYXV0b0RldGVjdFJlc291cmNlKHJlc291cmNlLCByZXNvdXJjZU9wdGlvbnMpO1xuICAgICAgICAgICAgcmVzb3VyY2UuaW50ZXJuYWwgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgd2lkdGggb2YgdGhlIGJhc2UgdGV4dHVyZSBzZXQgd2hlbiB0aGUgaW1hZ2UgaGFzIGxvYWRlZFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmVhZG9ubHlcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoIHx8IDA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgaGVpZ2h0IG9mIHRoZSBiYXNlIHRleHR1cmUgc2V0IHdoZW4gdGhlIGltYWdlIGhhcyBsb2FkZWRcbiAgICAgICAgICpcbiAgICAgICAgICogQHJlYWRvbmx5XG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0IHx8IDA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgcmVzb2x1dGlvbiAvIGRldmljZSBwaXhlbCByYXRpbyBvZiB0aGUgdGV4dHVyZVxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IFBJWEkuc2V0dGluZ3MuUkVTT0xVVElPTlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZXNvbHV0aW9uID0gcmVzb2x1dGlvbiB8fCBEaXNwbGF5U2V0dGluZ3NfMS5EaXNwbGF5U2V0dGluZ3MuUkVTT0xVVElPTjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1pcG1hcCBtb2RlIG9mIHRoZSB0ZXh0dXJlLCBhZmZlY3RzIGRvd25zY2FsZWQgaW1hZ2VzXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuTUlQTUFQX01PREVTfVxuICAgICAgICAgKiBAZGVmYXVsdCBQSVhJLnNldHRpbmdzLk1JUE1BUF9URVhUVVJFU1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5taXBtYXAgPSBtaXBtYXAgIT09IHVuZGVmaW5lZCA/IG1pcG1hcCA6IFdlYkdMU2V0dGluZ3NfMS5XZWJHTFNldHRpbmdzLk1JUE1BUF9URVhUVVJFUztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEhvdyB0aGUgdGV4dHVyZSB3cmFwc1xuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLndyYXBNb2RlID0gd3JhcE1vZGUgfHwgV2ViR0xTZXR0aW5nc18xLldlYkdMU2V0dGluZ3MuV1JBUF9NT0RFO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHNjYWxlIG1vZGUgdG8gYXBwbHkgd2hlbiBzY2FsaW5nIHRoaXMgdGV4dHVyZVxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLlNDQUxFX01PREVTfVxuICAgICAgICAgKiBAZGVmYXVsdCBQSVhJLnNldHRpbmdzLlNDQUxFX01PREVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2NhbGVNb2RlID0gc2NhbGVNb2RlICE9PSB1bmRlZmluZWQgPyBzY2FsZU1vZGUgOiBEaXNwbGF5U2V0dGluZ3NfMS5EaXNwbGF5U2V0dGluZ3MuU0NBTEVfTU9ERTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBwaXhlbCBmb3JtYXQgb2YgdGhlIHRleHR1cmVcbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7UElYSS5GT1JNQVRTfVxuICAgICAgICAgKiBAZGVmYXVsdCBQSVhJLkZPUk1BVFMuUkdCQVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5mb3JtYXQgPSBmb3JtYXQgfHwgV2ViR0xTZXR0aW5nc18xLldlYkdMU2V0dGluZ3MuRk9STUFUUy5SR0JBO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHR5cGUgb2YgcmVzb3VyY2UgZGF0YVxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLlRZUEVTfVxuICAgICAgICAgKiBAZGVmYXVsdCBQSVhJLlRZUEVTLlVOU0lHTkVEX0JZVEVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGUgfHwgV2ViR0xTZXR0aW5nc18xLldlYkdMU2V0dGluZ3MuVFlQRVMuVU5TSUdORURfQllURTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0YXJnZXQgdHlwZVxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLlRBUkdFVFN9XG4gICAgICAgICAqIEBkZWZhdWx0IFBJWEkuVEFSR0VUUy5URVhUVVJFXzJEXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldCB8fCBXZWJHTFNldHRpbmdzXzEuV2ViR0xTZXR0aW5ncy5UQVJHRVRTLlRFWFRVUkVfMkQ7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgdG8gdHJ1ZSB0byBlbmFibGUgcHJlLW11bHRpcGxpZWQgYWxwaGFcbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICAgICAgICogQGRlZmF1bHQgdHJ1ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wcmVtdWx0aXBseUFscGhhID0gcHJlbXVsdGlwbHlBbHBoYSAhPT0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHbG9iYWwgdW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoaXMgQmFzZVRleHR1cmVcbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7c3RyaW5nfVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnVpZCA9IE1hdGhTZXR0aW5nc18xLk1hdGhTZXR0aW5ncy51aWQoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVzZWQgYnkgYXV0b21hdGljIHRleHR1cmUgR2FyYmFnZSBDb2xsZWN0aW9uLCBzdG9yZXMgbGFzdCBHQyB0aWNrIHdoZW4gaXQgd2FzIGJvdW5kXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50b3VjaGVkID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgb3Igbm90IHRoZSB0ZXh0dXJlIGlzIGEgcG93ZXIgb2YgdHdvLCB0cnkgdG8gdXNlIHBvd2VyIG9mIHR3byB0ZXh0dXJlcyBhcyBtdWNoXG4gICAgICAgICAqIGFzIHlvdSBjYW5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJlYWRvbmx5XG4gICAgICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XG4gICAgICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmlzUG93ZXJPZlR3byA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9yZWZyZXNoUE9UKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbWFwIG9mIHJlbmRlciBjb250ZXh0IHRleHR1cmVzIHdoZXJlIHRoaXMgaXMgYm91bmRcbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fZ2xUZXh0dXJlcyA9IHt9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVXNlZCBieSBUZXh0dXJlU3lzdGVtIHRvIG9ubHkgdXBkYXRlIHRleHR1cmUgdG8gdGhlIEdQVSB3aGVuIG5lZWRlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRpcnR5SWQgPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgICogVXNlZCBieSBUZXh0dXJlU3lzdGVtIHRvIG9ubHkgdXBkYXRlIHRleHR1cmUgc3R5bGUgd2hlbiBuZWVkZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kaXJ0eVN0eWxlSWQgPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3VycmVudGx5IGRlZmF1bHQgY2FjaGUgSUQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2FjaGVJZCA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZW5lcmFsbHkgc3BlYWtpbmcgbWVhbnMgd2hlbiByZXNvdXJjZSBpcyBsb2FkZWQuXG4gICAgICAgICAqIEByZWFkb25seVxuICAgICAgICAgKiBAbWVtYmVyIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy52YWxpZCA9IHdpZHRoID4gMCAmJiBoZWlnaHQgPiAwO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGNvbGxlY3Rpb24gb2YgYWx0ZXJuYXRpdmUgY2FjaGUgaWRzLCBzaW5jZSBzb21lIEJhc2VUZXh0dXJlc1xuICAgICAgICAgKiBjYW4gaGF2ZSBtb3JlIHRoYW4gb25lIElELCBzaG9ydCBuYW1lIGFuZCBsb25nZXIgZnVsbCBVUkxcbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7QXJyYXk8c3RyaW5nPn1cbiAgICAgICAgICogQHJlYWRvbmx5XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRleHR1cmVDYWNoZUlkcyA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmxhZyBpZiBCYXNlVGV4dHVyZSBoYXMgYmVlbiBkZXN0cm95ZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XG4gICAgICAgICAqIEByZWFkb25seVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSByZXNvdXJjZSB1c2VkIGJ5IHRoaXMgQmFzZVRleHR1cmUsIHRoZXJlIGNhbiBvbmx5XG4gICAgICAgICAqIGJlIG9uZSByZXNvdXJjZSBwZXIgQmFzZVRleHR1cmUsIGJ1dCB0ZXh0dXJlcyBjYW4gc2hhcmVcbiAgICAgICAgICogcmVzb3VyY2VzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLnJlc291cmNlcy5SZXNvdXJjZX1cbiAgICAgICAgICogQHJlYWRvbmx5XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJlc291cmNlID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE51bWJlciBvZiB0aGUgdGV4dHVyZSBiYXRjaCwgdXNlZCBieSBtdWx0aS10ZXh0dXJlIHJlbmRlcmVyc1xuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9iYXRjaEVuYWJsZWQgPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZWQgd2hlbiBhIG5vdC1pbW1lZGlhdGVseS1hdmFpbGFibGUgc291cmNlIGZpbmlzaGVzIGxvYWRpbmcuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICogQGV2ZW50IFBJWEkuQmFzZVRleHR1cmUjbG9hZGVkXG4gICAgICAgICAqIEBwYXJhbSB7UElYSS5CYXNlVGV4dHVyZX0gYmFzZVRleHR1cmUgLSBSZXNvdXJjZSBsb2FkZWQuXG4gICAgICAgICAqL1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZWQgd2hlbiBhIG5vdC1pbW1lZGlhdGVseS1hdmFpbGFibGUgc291cmNlIGZhaWxzIHRvIGxvYWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICogQGV2ZW50IFBJWEkuQmFzZVRleHR1cmUjZXJyb3JcbiAgICAgICAgICogQHBhcmFtIHtQSVhJLkJhc2VUZXh0dXJlfSBiYXNlVGV4dHVyZSAtIFJlc291cmNlIGVycm9yZWQuXG4gICAgICAgICAqL1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZWQgd2hlbiBCYXNlVGV4dHVyZSBpcyB1cGRhdGVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqIEBldmVudCBQSVhJLkJhc2VUZXh0dXJlI2xvYWRlZFxuICAgICAgICAgKiBAcGFyYW0ge1BJWEkuQmFzZVRleHR1cmV9IGJhc2VUZXh0dXJlIC0gUmVzb3VyY2UgbG9hZGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVkIHdoZW4gQmFzZVRleHR1cmUgaXMgZGVzdHJveWVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqIEBldmVudCBQSVhJLkJhc2VUZXh0dXJlI2Vycm9yXG4gICAgICAgICAqIEBwYXJhbSB7UElYSS5CYXNlVGV4dHVyZX0gYmFzZVRleHR1cmUgLSBSZXNvdXJjZSBlcnJvcmVkLlxuICAgICAgICAgKi9cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVkIHdoZW4gQmFzZVRleHR1cmUgaXMgdXBkYXRlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKiBAZXZlbnQgUElYSS5CYXNlVGV4dHVyZSN1cGRhdGVcbiAgICAgICAgICogQHBhcmFtIHtQSVhJLkJhc2VUZXh0dXJlfSBiYXNlVGV4dHVyZSAtIEluc3RhbmNlIG9mIHRleHR1cmUgYmVpbmcgdXBkYXRlZC5cbiAgICAgICAgICovXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlZCB3aGVuIEJhc2VUZXh0dXJlIGlzIGRlc3Ryb3llZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKiBAZXZlbnQgUElYSS5CYXNlVGV4dHVyZSNkaXNwb3NlXG4gICAgICAgICAqIEBwYXJhbSB7UElYSS5CYXNlVGV4dHVyZX0gYmFzZVRleHR1cmUgLSBJbnN0YW5jZSBvZiB0ZXh0dXJlIGJlaW5nIGRlc3Ryb3llZC5cbiAgICAgICAgICovXG4gICAgICAgIC8vIFNldCB0aGUgcmVzb3VyY2VcbiAgICAgICAgdGhpcy5zZXRSZXNvdXJjZShyZXNvdXJjZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBpeGVsIHdpZHRoIG9mIHRoZSBzb3VyY2Ugb2YgdGhpcyB0ZXh0dXJlXG4gICAgICpcbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICovXG4gICAgZ2V0IHJlYWxXaWR0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2lkdGggKiB0aGlzLnJlc29sdXRpb247XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBQaXhlbCBoZWlnaHQgb2YgdGhlIHNvdXJjZSBvZiB0aGlzIHRleHR1cmVcbiAgICAgKlxuICAgICAqIEByZWFkb25seVxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgcmVhbEhlaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGVpZ2h0ICogdGhpcy5yZXNvbHV0aW9uO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogQ2hhbmdlcyBzdHlsZSBvcHRpb25zIG9mIEJhc2VUZXh0dXJlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BJWEkuU0NBTEVfTU9ERVN9IFtzY2FsZU1vZGVdIC0gUGl4aSBzY2FsZW1vZGVcbiAgICAgKiBAcGFyYW0ge1BJWEkuTUlQTUFQX01PREVTfSBbbWlwbWFwXSAtIGVuYWJsZSBtaXBtYXBzXG4gICAgICogQHJldHVybnMge0Jhc2VUZXh0dXJlfSB0aGlzXG4gICAgICovXG4gICAgQnNldFN0eWxlKHNjYWxlTW9kZSwgbWlwbWFwKSB7XG4gICAgICAgIHZhciBkaXJ0eTtcbiAgICAgICAgaWYgKHNjYWxlTW9kZSAhPT0gdW5kZWZpbmVkICYmIHNjYWxlTW9kZSAhPT0gdGhpcy5zY2FsZU1vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuc2NhbGVNb2RlID0gc2NhbGVNb2RlO1xuICAgICAgICAgICAgZGlydHkgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtaXBtYXAgIT09IHVuZGVmaW5lZCAmJiBtaXBtYXAgIT09IHRoaXMubWlwbWFwKSB7XG4gICAgICAgICAgICB0aGlzLm1pcG1hcCA9IG1pcG1hcDtcbiAgICAgICAgICAgIGRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGlydHkpIHtcbiAgICAgICAgICAgIHRoaXMuZGlydHlTdHlsZUlkKys7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBDaGFuZ2VzIHcvaC9yZXNvbHV0aW9uLiBUZXh0dXJlIGJlY29tZXMgdmFsaWQgaWYgd2lkdGggYW5kIGhlaWdodCBhcmUgZ3JlYXRlciB0aGFuIHplcm8uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd2lkdGggVmlzdWFsIHdpZHRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCBWaXN1YWwgaGVpZ2h0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtyZXNvbHV0aW9uXSBPcHRpb25hbGx5IHNldCByZXNvbHV0aW9uXG4gICAgICogQHJldHVybnMge0Jhc2VUZXh0dXJlfSB0aGlzXG4gICAgICovXG4gICAgc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0LCByZXNvbHV0aW9uID0gbnVsbCkge1xuICAgICAgICB0aGlzLnJlc29sdXRpb24gPSByZXNvbHV0aW9uIHx8IHRoaXMucmVzb2x1dGlvbjtcbiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgdGhpcy5fcmVmcmVzaFBPVCgpO1xuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFNldHMgcmVhbCBzaXplIG9mIGJhc2VUZXh0dXJlLCBwcmVzZXJ2ZXMgY3VycmVudCByZXNvbHV0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJlYWxXaWR0aCBGdWxsIHJlbmRlcmVkIHdpZHRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJlYWxIZWlnaHQgRnVsbCByZW5kZXJlZCBoZWlnaHRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3Jlc29sdXRpb25dIE9wdGlvbmFsbHkgc2V0IHJlc29sdXRpb25cbiAgICAgKiBAcmV0dXJucyB7QmFzZVRleHR1cmV9IHRoaXNcbiAgICAgKi9cbiAgICBzZXRSZWFsU2l6ZShyZWFsV2lkdGgsIHJlYWxIZWlnaHQsIHJlc29sdXRpb24gPSBudWxsKSB7XG4gICAgICAgIHRoaXMucmVzb2x1dGlvbiA9IHJlc29sdXRpb24gfHwgdGhpcy5yZXNvbHV0aW9uO1xuICAgICAgICB0aGlzLndpZHRoID0gcmVhbFdpZHRoIC8gdGhpcy5yZXNvbHV0aW9uO1xuICAgICAgICB0aGlzLmhlaWdodCA9IHJlYWxIZWlnaHQgLyB0aGlzLnJlc29sdXRpb247XG4gICAgICAgIHRoaXMuX3JlZnJlc2hQT1QoKTtcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBSZWZyZXNoIGNoZWNrIGZvciBpc1Bvd2VyT2ZUd28gdGV4dHVyZSBiYXNlZCBvbiBzaXplXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZWZyZXNoUE9UKCkge1xuICAgICAgICB0aGlzLmlzUG93ZXJPZlR3byA9IE1hdGhTZXR0aW5nc18xLk1hdGhTZXR0aW5ncy5pc1BvdzIodGhpcy5yZWFsV2lkdGgpICYmIE1hdGhTZXR0aW5nc18xLk1hdGhTZXR0aW5ncy5pc1BvdzIodGhpcy5yZWFsSGVpZ2h0KTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIENoYW5nZXMgcmVzb2x1dGlvblxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtyZXNvbHV0aW9uXSByZXNcbiAgICAgKiBAcmV0dXJucyB7QmFzZVRleHR1cmV9IHRoaXNcbiAgICAgKi9cbiAgICBzZXRSZXNvbHV0aW9uKHJlc29sdXRpb24pIHtcbiAgICAgICAgdmFyIG9sZFJlc29sdXRpb24gPSB0aGlzLnJlc29sdXRpb247XG4gICAgICAgIGlmIChvbGRSZXNvbHV0aW9uID09PSByZXNvbHV0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlc29sdXRpb24gPSByZXNvbHV0aW9uO1xuICAgICAgICBpZiAodGhpcy52YWxpZCkge1xuICAgICAgICAgICAgdGhpcy53aWR0aCA9IHRoaXMud2lkdGggKiBvbGRSZXNvbHV0aW9uIC8gcmVzb2x1dGlvbjtcbiAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5oZWlnaHQgKiBvbGRSZXNvbHV0aW9uIC8gcmVzb2x1dGlvbjtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChFdmVudF8xLkV2ZW50LmdldEV2ZW50KFwidXBkYXRlXCIpKTtcbiAgICAgICAgICAgIC8vIHRoaXMuZW1pdCgndXBkYXRlJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcmVmcmVzaFBPVCgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHJlc291cmNlIGlmIGl0IHdhc24ndCBzZXQuIFRocm93cyBlcnJvciBpZiByZXNvdXJjZSBhbHJlYWR5IHByZXNlbnRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UElYSS5yZXNvdXJjZXMuUmVzb3VyY2V9IHJlc291cmNlIC0gdGhhdCBpcyBtYW5hZ2luZyB0aGlzIEJhc2VUZXh0dXJlXG4gICAgICogQHJldHVybnMge0Jhc2VUZXh0dXJlfSB0aGlzXG4gICAgICovXG4gICAgc2V0UmVzb3VyY2UocmVzb3VyY2UpIHtcbiAgICAgICAgaWYgKHRoaXMucmVzb3VyY2UgPT09IHJlc291cmNlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5yZXNvdXJjZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZXNvdXJjZSBjYW4gYmUgc2V0IG9ubHkgb25jZScpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVzb3VyY2UgPSByZXNvdXJjZTtcbiAgICAgICAgaWYgKHJlc291cmNlIGluc3RhbmNlb2YgSW1hZ2VCaXRtYXApIHtcbiAgICAgICAgICAgIHRoaXMuc2V0UmVhbFNpemUodGhpcy5yZXNvdXJjZS53aWR0aCwgdGhpcy5yZXNvdXJjZS5oZWlnaHQpO1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVVcGRhdGUobnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXNvdXJjZS5hZGRFdmVudExpc3RlbmVyKFwidXBkYXRlXCIsIHRoaXMuaGFuZGxlVXBkYXRlKTtcbiAgICAgICAgICAgIHJlc291cmNlLmFkZEV2ZW50TGlzdGVuZXIoXCJzZXRSZWFsU2l6ZVwiLCB0aGlzLmhhbmRsZVJlc2l6ZSk7XG4gICAgICAgICAgICB0aGlzLnNldFJlYWxTaXplKHRoaXMucmVzb3VyY2Uud2lkdGgsIHRoaXMucmVzb3VyY2UuaGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICAvLyByZXNvdXJjZS5iaW5kKHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIEludmFsaWRhdGVzIHRoZSBvYmplY3QuIFRleHR1cmUgYmVjb21lcyB2YWxpZCBpZiB3aWR0aCBhbmQgaGVpZ2h0IGFyZSBncmVhdGVyIHRoYW4gemVyby5cbiAgICAgKi9cbiAgICB1cGRhdGUoKSB7XG4gICAgICAgIGlmICghdGhpcy52YWxpZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMud2lkdGggPiAwICYmIHRoaXMuaGVpZ2h0ID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMudmFsaWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChFdmVudF8xLkV2ZW50LmdldEV2ZW50KFwibG9hZGVkXCIpKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoRXZlbnRfMS5FdmVudC5nZXRFdmVudChcInVwZGF0ZVwiKSk7XG4gICAgICAgICAgICAgICAgLy8gdGhpcy5lbWl0KCdsb2FkZWQnLCB0aGlzKTtcbiAgICAgICAgICAgICAgICAvLyB0aGlzLmVtaXQoJ3VwZGF0ZScsIHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kaXJ0eUlkKys7XG4gICAgICAgICAgICB0aGlzLmRpcnR5U3R5bGVJZCsrO1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KEV2ZW50XzEuRXZlbnQuZ2V0RXZlbnQoXCJ1cGRhdGVcIikpO1xuICAgICAgICAgICAgLy8gdGhpcy5lbWl0KCd1cGRhdGUnLCB0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogRGVzdHJveXMgdGhpcyBiYXNlIHRleHR1cmUuXG4gICAgICogVGhlIG1ldGhvZCBzdG9wcyBpZiByZXNvdXJjZSBkb2Vzbid0IHdhbnQgdGhpcyB0ZXh0dXJlIHRvIGJlIGRlc3Ryb3llZC5cbiAgICAgKiBSZW1vdmVzIHRleHR1cmUgZnJvbSBhbGwgY2FjaGVzLlxuICAgICAqL1xuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIC8vIHJlbW92ZSBhbmQgZGVzdHJveSB0aGUgcmVzb3VyY2VcbiAgICAgICAgaWYgKHRoaXMucmVzb3VyY2UpIHtcbiAgICAgICAgICAgIHRoaXMucmVzb3VyY2UudW5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgLy8gb25seSBkZXN0cm95IHJlc291cmNlZCBjcmVhdGVkIGludGVybmFsbHlcbiAgICAgICAgICAgIGlmICh0aGlzLnJlc291cmNlLmludGVybmFsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNvdXJjZS5kZXN0cm95KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnJlc291cmNlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jYWNoZUlkKSB7XG4gICAgICAgICAgICBkZWxldGUgQ2FjaGVTZXR0aW5nc18xLkNhY2hlU2V0dGluZ3MuQmFzZVRleHR1cmVDYWNoZVt0aGlzLmNhY2hlSWRdO1xuICAgICAgICAgICAgZGVsZXRlIENhY2hlU2V0dGluZ3NfMS5DYWNoZVNldHRpbmdzLlRleHR1cmVDYWNoZVt0aGlzLmNhY2hlSWRdO1xuICAgICAgICAgICAgdGhpcy5jYWNoZUlkID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBmaW5hbGx5IGxldCB0aGUgV2ViR0wgcmVuZGVyZXIga25vdy4uXG4gICAgICAgIHRoaXMuZGlzcG9zZSgpO1xuICAgICAgICBCYXNlVGV4dHVyZS5yZW1vdmVGcm9tQ2FjaGUodGhpcyk7XG4gICAgICAgIHRoaXMudGV4dHVyZUNhY2hlSWRzID0gbnVsbDtcbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogRnJlZXMgdGhlIHRleHR1cmUgZnJvbSBXZWJHTCBtZW1vcnkgd2l0aG91dCBkZXN0cm95aW5nIHRoaXMgdGV4dHVyZSBvYmplY3QuXG4gICAgICogVGhpcyBtZWFucyB5b3UgY2FuIHN0aWxsIHVzZSB0aGUgdGV4dHVyZSBsYXRlciB3aGljaCB3aWxsIHVwbG9hZCBpdCB0byBHUFVcbiAgICAgKiBtZW1vcnkgYWdhaW4uXG4gICAgICpcbiAgICAgKiBAZmlyZXMgUElYSS5CYXNlVGV4dHVyZSNkaXNwb3NlXG4gICAgICovXG4gICAgZGlzcG9zZSgpIHtcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KEV2ZW50XzEuRXZlbnQuZ2V0RXZlbnQoXCJkaXNwb3NlXCIpKTtcbiAgICAgICAgLy8gdGhpcy5lbWl0KCdkaXNwb3NlJywgdGhpcyk7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBIZWxwZXIgZnVuY3Rpb24gdGhhdCBjcmVhdGVzIGEgYmFzZSB0ZXh0dXJlIGJhc2VkIG9uIHRoZSBzb3VyY2UgeW91IHByb3ZpZGUuXG4gICAgICogVGhlIHNvdXJjZSBjYW4gYmUgLSBpbWFnZSB1cmwsIGltYWdlIGVsZW1lbnQsIGNhbnZhcyBlbGVtZW50LiBJZiB0aGVcbiAgICAgKiBzb3VyY2UgaXMgYW4gaW1hZ2UgdXJsIG9yIGFuIGltYWdlIGVsZW1lbnQgYW5kIG5vdCBpbiB0aGUgYmFzZSB0ZXh0dXJlXG4gICAgICogY2FjaGUsIGl0IHdpbGwgYmUgY3JlYXRlZCBhbmQgbG9hZGVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfEhUTUxJbWFnZUVsZW1lbnR8SFRNTENhbnZhc0VsZW1lbnR8U1ZHRWxlbWVudHxIVE1MVmlkZW9FbGVtZW50fSBzb3VyY2UgLSBUaGVcbiAgICAgKiAgICAgICAgc291cmNlIHRvIGNyZWF0ZSBiYXNlIHRleHR1cmUgZnJvbS5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIFNlZSB7QGxpbmsgUElYSS5CYXNlVGV4dHVyZX0ncyBjb25zdHJ1Y3RvciBmb3Igb3B0aW9ucy5cbiAgICAgKiBAcmV0dXJucyB7UElYSS5CYXNlVGV4dHVyZX0gVGhlIG5ldyBiYXNlIHRleHR1cmUuXG4gICAgICovXG4gICAgc3RhdGljIGZyb20oc291cmNlLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBjYWNoZUlkID0gbnVsbDtcbiAgICAgICAgaWYgKHR5cGVvZiBzb3VyY2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjYWNoZUlkID0gc291cmNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFzb3VyY2UuX3BpeGlJZCkge1xuICAgICAgICAgICAgICAgIHNvdXJjZS5fcGl4aUlkID0gXCJwaXhpaWRfXCIgKyAoTWF0aFNldHRpbmdzXzEuTWF0aFNldHRpbmdzLnVpZCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhY2hlSWQgPSBzb3VyY2UuX3BpeGlJZDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYmFzZVRleHR1cmUgPSBDYWNoZVNldHRpbmdzXzEuQ2FjaGVTZXR0aW5ncy5CYXNlVGV4dHVyZUNhY2hlW2NhY2hlSWRdO1xuICAgICAgICBpZiAoIWJhc2VUZXh0dXJlKSB7XG4gICAgICAgICAgICBiYXNlVGV4dHVyZSA9IG5ldyBCYXNlVGV4dHVyZShzb3VyY2UsIG9wdGlvbnMpO1xuICAgICAgICAgICAgYmFzZVRleHR1cmUuY2FjaGVJZCA9IGNhY2hlSWQ7XG4gICAgICAgICAgICBCYXNlVGV4dHVyZS5hZGRUb0NhY2hlKGJhc2VUZXh0dXJlLCBjYWNoZUlkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYmFzZVRleHR1cmU7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgQmFzZVRleHR1cmUgd2l0aCBhIEJ1ZmZlclJlc291cmNlIGZyb20gYSBGbG9hdDMyQXJyYXkuXG4gICAgICogUkdCQSB2YWx1ZXMgYXJlIGZsb2F0cyBmcm9tIDAgdG8gMS5cbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8VWludDhBcnJheX0gYnVmZmVyIFRoZSBvcHRpb25hbCBhcnJheSB0byB1c2UsIGlmIG5vIGRhdGFcbiAgICAgKiAgICAgICAgaXMgcHJvdmlkZWQsIGEgbmV3IEZsb2F0MzJBcnJheSBpcyBjcmVhdGVkLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCAtIFdpZHRoIG9mIHRoZSByZXNvdXJjZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgLSBIZWlnaHQgb2YgdGhlIHJlc291cmNlXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSBTZWUge0BsaW5rIFBJWEkuQmFzZVRleHR1cmV9J3MgY29uc3RydWN0b3IgZm9yIG9wdGlvbnMuXG4gICAgICogQHJldHVybiB7UElYSS5CYXNlVGV4dHVyZX0gVGhlIHJlc3VsdGluZyBuZXcgQmFzZVRleHR1cmVcbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbUJ1ZmZlcihidWZmZXIsIHdpZHRoLCBoZWlnaHQsIG9wdGlvbnMpIHtcbiAgICAgICAgYnVmZmVyID0gYnVmZmVyIHx8IG5ldyBGbG9hdDMyQXJyYXkod2lkdGggKiBoZWlnaHQgKiA0KTtcbiAgICAgICAgdmFyIHJlc291cmNlID0gbmV3IEJ1ZmZlclJlc291cmNlXzEuQnVmZmVyUmVzb3VyY2UoYnVmZmVyLCB7IHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQgfSk7XG4gICAgICAgIHZhciB0eXBlID0gYnVmZmVyIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5ID8gV2ViR0xTZXR0aW5nc18xLldlYkdMU2V0dGluZ3MuVFlQRVMuRkxPQVQgOiBXZWJHTFNldHRpbmdzXzEuV2ViR0xTZXR0aW5ncy5UWVBFUy5VTlNJR05FRF9CWVRFO1xuICAgICAgICByZXR1cm4gbmV3IEJhc2VUZXh0dXJlKHJlc291cmNlLCBPYmplY3QuYXNzaWduKFdlYkdMU2V0dGluZ3NfMS5XZWJHTFNldHRpbmdzLmRlZmF1bHRCdWZmZXJPcHRpb25zLCBvcHRpb25zIHx8IHsgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodCwgdHlwZTogdHlwZSB9KSk7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBBZGRzIGEgQmFzZVRleHR1cmUgdG8gdGhlIGdsb2JhbCBCYXNlVGV4dHVyZUNhY2hlLiBUaGlzIGNhY2hlIGlzIHNoYXJlZCBhY3Jvc3MgdGhlIHdob2xlIFBJWEkgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7UElYSS5CYXNlVGV4dHVyZX0gYmFzZVRleHR1cmUgLSBUaGUgQmFzZVRleHR1cmUgdG8gYWRkIHRvIHRoZSBjYWNoZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgLSBUaGUgaWQgdGhhdCB0aGUgQmFzZVRleHR1cmUgd2lsbCBiZSBzdG9yZWQgYWdhaW5zdC5cbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkVG9DYWNoZShiYXNlVGV4dHVyZSwgaWQpIHtcbiAgICAgICAgaWYgKGlkKSB7XG4gICAgICAgICAgICBpZiAoYmFzZVRleHR1cmUudGV4dHVyZUNhY2hlSWRzLmluZGV4T2YoaWQpID09PSAtMSkge1xuICAgICAgICAgICAgICAgIGJhc2VUZXh0dXJlLnRleHR1cmVDYWNoZUlkcy5wdXNoKGlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChDYWNoZVNldHRpbmdzXzEuQ2FjaGVTZXR0aW5ncy5CYXNlVGV4dHVyZUNhY2hlW2lkXSkge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKChcIkJhc2VUZXh0dXJlIGFkZGVkIHRvIHRoZSBjYWNoZSB3aXRoIGFuIGlkIFtcIiArIGlkICsgXCJdIHRoYXQgYWxyZWFkeSBoYWQgYW4gZW50cnlcIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgQ2FjaGVTZXR0aW5nc18xLkNhY2hlU2V0dGluZ3MuQmFzZVRleHR1cmVDYWNoZVtpZF0gPSBiYXNlVGV4dHVyZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGEgQmFzZVRleHR1cmUgZnJvbSB0aGUgZ2xvYmFsIEJhc2VUZXh0dXJlQ2FjaGUuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtzdHJpbmd8UElYSS5CYXNlVGV4dHVyZX0gYmFzZVRleHR1cmUgLSBpZCBvZiBhIEJhc2VUZXh0dXJlIHRvIGJlIHJlbW92ZWQsIG9yIGEgQmFzZVRleHR1cmUgaW5zdGFuY2UgaXRzZWxmLlxuICAgICAqIEByZXR1cm4ge1BJWEkuQmFzZVRleHR1cmV8bnVsbH0gVGhlIEJhc2VUZXh0dXJlIHRoYXQgd2FzIHJlbW92ZWQuXG4gICAgICovXG4gICAgc3RhdGljIHJlbW92ZUZyb21DYWNoZShiYXNlVGV4dHVyZSkge1xuICAgICAgICBpZiAodHlwZW9mIGJhc2VUZXh0dXJlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdmFyIGJhc2VUZXh0dXJlRnJvbUNhY2hlID0gQ2FjaGVTZXR0aW5nc18xLkNhY2hlU2V0dGluZ3MuQmFzZVRleHR1cmVDYWNoZVtiYXNlVGV4dHVyZV07XG4gICAgICAgICAgICBpZiAoYmFzZVRleHR1cmVGcm9tQ2FjaGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBiYXNlVGV4dHVyZUZyb21DYWNoZS50ZXh0dXJlQ2FjaGVJZHMuaW5kZXhPZihiYXNlVGV4dHVyZSk7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgYmFzZVRleHR1cmVGcm9tQ2FjaGUudGV4dHVyZUNhY2hlSWRzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlbGV0ZSBDYWNoZVNldHRpbmdzXzEuQ2FjaGVTZXR0aW5ncy5CYXNlVGV4dHVyZUNhY2hlW2Jhc2VUZXh0dXJlXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYmFzZVRleHR1cmVGcm9tQ2FjaGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYmFzZVRleHR1cmUgJiYgYmFzZVRleHR1cmUudGV4dHVyZUNhY2hlSWRzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJhc2VUZXh0dXJlLnRleHR1cmVDYWNoZUlkcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBDYWNoZVNldHRpbmdzXzEuQ2FjaGVTZXR0aW5ncy5CYXNlVGV4dHVyZUNhY2hlW2Jhc2VUZXh0dXJlLnRleHR1cmVDYWNoZUlkc1tpXV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBiYXNlVGV4dHVyZS50ZXh0dXJlQ2FjaGVJZHMubGVuZ3RoID0gMDtcbiAgICAgICAgICAgIHJldHVybiBiYXNlVGV4dHVyZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgO1xufVxuLyoqXG4gKiBHbG9iYWwgbnVtYmVyIG9mIHRoZSB0ZXh0dXJlIGJhdGNoLCB1c2VkIGJ5IG11bHRpLXRleHR1cmUgcmVuZGVyZXJzXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlciB7bnVtYmVyfSBuZXcgdGV4dHVyZSBiYXRjaCBudW1iZXJcbiAqL1xuQmFzZVRleHR1cmUuX2dsb2JhbEJhdGNoID0gMDtcbmV4cG9ydHMuQmFzZVRleHR1cmUgPSBCYXNlVGV4dHVyZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY2xhc3MgQmF0Y2hCdWZmZXIge1xuICAgIGNvbnN0cnVjdG9yKHNpemUpIHtcbiAgICAgICAgdGhpcy52ZXJ0aWNlcyA9IG5ldyBBcnJheUJ1ZmZlcihzaXplKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFZpZXcgb24gdGhlIHZlcnRpY2VzIGFzIGEgRmxvYXQzMkFycmF5IGZvciBwb3NpdGlvbnNcbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7RmxvYXQzMkFycmF5fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5mbG9hdDMyVmlldyA9IG5ldyBGbG9hdDMyQXJyYXkodGhpcy52ZXJ0aWNlcyk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBWaWV3IG9uIHRoZSB2ZXJ0aWNlcyBhcyBhIFVpbnQzMkFycmF5IGZvciB1dnNcbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7RmxvYXQzMkFycmF5fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy51aW50MzJWaWV3ID0gbmV3IFVpbnQzMkFycmF5KHRoaXMudmVydGljZXMpO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLnZlcnRpY2VzID0gbnVsbDtcbiAgICAgICAgdGhpcy5mbG9hdDMyVmlldyA9IG51bGw7XG4gICAgICAgIHRoaXMudWludDMyVmlldyA9IG51bGw7XG4gICAgfVxuICAgIDtcbn1cbmV4cG9ydHMuQmF0Y2hCdWZmZXIgPSBCYXRjaEJ1ZmZlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY2xhc3MgQmF0Y2hEcmF3Q2FsbCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMudGV4dHVyZXMgPSBbXTtcbiAgICAgICAgdGhpcy5pZHMgPSBbXTtcbiAgICAgICAgdGhpcy5ibGVuZCA9IDA7XG4gICAgICAgIHRoaXMudGV4dHVyZUNvdW50ID0gMDtcbiAgICAgICAgdGhpcy5zdGFydCA9IDA7XG4gICAgICAgIHRoaXMuc2l6ZSA9IDA7XG4gICAgICAgIHRoaXMudHlwZSA9IDQ7XG4gICAgfVxuICAgIDtcbn1cbmV4cG9ydHMuQmF0Y2hEcmF3Q2FsbCA9IEJhdGNoRHJhd0NhbGw7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IEdlb21ldHJ5XzEgPSByZXF1aXJlKFwiLi9HZW9tZXRyeVwiKTtcbmNvbnN0IEJ1ZmZlcl8xID0gcmVxdWlyZShcIi4vQnVmZmVyXCIpO1xuY29uc3QgV2ViR0xTZXR0aW5nc18xID0gcmVxdWlyZShcIi4vV2ViR0xTZXR0aW5nc1wiKTtcbmNsYXNzIEJhdGNoR2VvbWV0cnkgZXh0ZW5kcyBHZW9tZXRyeV8xLkdlb21ldHJ5IHtcbiAgICBjb25zdHJ1Y3Rvcihfc3RhdGljID0gZmFsc2UpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJ1ZmZlciB1c2VkIGZvciBwb3NpdGlvbiwgY29sb3IsIHRleHR1cmUgSURzXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuQnVmZmVyfVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9idWZmZXIgPSBuZXcgQnVmZmVyXzEuQnVmZmVyKG51bGwsIF9zdGF0aWMsIGZhbHNlKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluZGV4IGJ1ZmZlciBkYXRhXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuQnVmZmVyfVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9pbmRleEJ1ZmZlciA9IG5ldyBCdWZmZXJfMS5CdWZmZXIobnVsbCwgX3N0YXRpYywgdHJ1ZSk7XG4gICAgICAgIHRoaXMuYWRkQXR0cmlidXRlKCdhVmVydGV4UG9zaXRpb24nLCB0aGlzLl9idWZmZXIsIDIsIGZhbHNlLCBXZWJHTFNldHRpbmdzXzEuV2ViR0xTZXR0aW5ncy5UWVBFUy5GTE9BVClcbiAgICAgICAgICAgIC5hZGRBdHRyaWJ1dGUoJ2FUZXh0dXJlQ29vcmQnLCB0aGlzLl9idWZmZXIsIDIsIGZhbHNlLCBXZWJHTFNldHRpbmdzXzEuV2ViR0xTZXR0aW5ncy5UWVBFUy5GTE9BVClcbiAgICAgICAgICAgIC5hZGRBdHRyaWJ1dGUoJ2FDb2xvcicsIHRoaXMuX2J1ZmZlciwgNCwgdHJ1ZSwgV2ViR0xTZXR0aW5nc18xLldlYkdMU2V0dGluZ3MuVFlQRVMuVU5TSUdORURfQllURSlcbiAgICAgICAgICAgIC5hZGRBdHRyaWJ1dGUoJ2FUZXh0dXJlSWQnLCB0aGlzLl9idWZmZXIsIDEsIHRydWUsIFdlYkdMU2V0dGluZ3NfMS5XZWJHTFNldHRpbmdzLlRZUEVTLkZMT0FUKVxuICAgICAgICAgICAgLmFkZEluZGV4KHRoaXMuX2luZGV4QnVmZmVyKTtcbiAgICB9XG59XG5leHBvcnRzLkJhdGNoR2VvbWV0cnkgPSBCYXRjaEdlb21ldHJ5O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBPYmplY3RSZW5kZXJlcl8xID0gcmVxdWlyZShcIi4vT2JqZWN0UmVuZGVyZXJcIik7XG5jb25zdCBCYXRjaEdlb21ldHJ5XzEgPSByZXF1aXJlKFwiLi9CYXRjaEdlb21ldHJ5XCIpO1xuY29uc3QgQmFzZVRleHR1cmVfMSA9IHJlcXVpcmUoXCIuL0Jhc2VUZXh0dXJlXCIpO1xuY29uc3QgQmF0Y2hEcmF3Q2FsbF8xID0gcmVxdWlyZShcIi4vQmF0Y2hEcmF3Q2FsbFwiKTtcbmNvbnN0IFN0YXRlXzEgPSByZXF1aXJlKFwiLi9TdGF0ZVwiKTtcbmNvbnN0IEJhdGNoQnVmZmVyXzEgPSByZXF1aXJlKFwiLi9CYXRjaEJ1ZmZlclwiKTtcbmNvbnN0IENvbG9yU2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL0NvbG9yU2V0dGluZ3NcIik7XG5jb25zdCBXZWJHTFNldHRpbmdzXzEgPSByZXF1aXJlKFwiLi9XZWJHTFNldHRpbmdzXCIpO1xuY29uc3QgQmxlbmRNb2Rlc1NldHRpbmdzXzEgPSByZXF1aXJlKFwiLi9CbGVuZE1vZGVzU2V0dGluZ3NcIik7XG5jb25zdCBNYXRoU2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL01hdGhTZXR0aW5nc1wiKTtcbmNvbnN0IERpc3BsYXlTZXR0aW5nc18xID0gcmVxdWlyZShcIi4vRGlzcGxheVNldHRpbmdzXCIpO1xuY2xhc3MgQmF0Y2hSZW5kZXJlciBleHRlbmRzIE9iamVjdFJlbmRlcmVyXzEuT2JqZWN0UmVuZGVyZXIge1xuICAgIGNvbnN0cnVjdG9yKHJlbmRlcmVyKSB7XG4gICAgICAgIHN1cGVyKHJlbmRlcmVyKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbGxlZCBiZWZvcmUgdGhlIHJlbmRlcmVyIHN0YXJ0cyByZW5kZXJpbmcuXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9uUHJlcmVuZGVyID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnZlcnRleENvdW50ID0gMDtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE51bWJlciBvZiB2YWx1ZXMgc2VudCBpbiB0aGUgdmVydGV4IGJ1ZmZlci5cbiAgICAgICAgICogYVZlcnRleFBvc2l0aW9uKDIpLCBhVGV4dHVyZUNvb3JkKDEpLCBhQ29sb3IoMSksIGFUZXh0dXJlSWQoMSkgPSA1XG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudmVydFNpemUgPSA2O1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHNpemUgb2YgdGhlIHZlcnRleCBpbmZvcm1hdGlvbiBpbiBieXRlcy5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy52ZXJ0Qnl0ZVNpemUgPSB0aGlzLnZlcnRTaXplICogNDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBudW1iZXIgb2YgaW1hZ2VzIGluIHRoZSBTcHJpdGVSZW5kZXJlciBiZWZvcmUgaXQgZmx1c2hlcy5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zaXplID0gMjAwMCAqIDQ7IC8vIHNldHRpbmdzLlNQUklURV9CQVRDSF9TSVpFOyAvLyAyMDAwIGlzIGEgbmljZSBiYWxhbmNlIGJldHdlZW4gbW9iaWxlIC8gZGVza3RvcFxuICAgICAgICB0aGlzLmN1cnJlbnRTaXplID0gMDtcbiAgICAgICAgdGhpcy5jdXJyZW50SW5kZXhTaXplID0gMDtcbiAgICAgICAgLy8gdGhlIHRvdGFsIG51bWJlciBvZiBieXRlcyBpbiBvdXIgYmF0Y2hcbiAgICAgICAgLy8gbGV0IG51bVZlcnRzID0gdGhpcy5zaXplICogNCAqIHRoaXMudmVydEJ5dGVTaXplO1xuICAgICAgICB0aGlzLmF0dHJpYnV0ZUJ1ZmZlcnMgPSB7fTtcbiAgICAgICAgdGhpcy5hQnVmZmVycyA9IHt9O1xuICAgICAgICB0aGlzLmlCdWZmZXJzID0ge307XG4gICAgICAgIC8vICAgICB0aGlzLmRlZnVhbHRTcHJpdGVJbmRleEJ1ZmZlciA9IG5ldyBCdWZmZXIoY3JlYXRlSW5kaWNlc0ZvclF1YWRzKHRoaXMuc2l6ZSksIHRydWUsIHRydWUpO1xuICAgICAgICAvKipcbiAgICAgICAgICogSG9sZHMgdGhlIGRlZnVhbHQgaW5kaWNlcyBvZiB0aGUgZ2VvbWV0cnkgKHF1YWRzKSB0byBkcmF3XG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge1VpbnQxNkFycmF5fVxuICAgICAgICAgKi9cbiAgICAgICAgLy8gY29uc3QgaW5kaWNpZXMgPSBjcmVhdGVJbmRpY2VzRm9yUXVhZHModGhpcy5zaXplKTtcbiAgICAgICAgLy8gIHRoaXMuZGVmYXVsdFF1YWRJbmRleEJ1ZmZlciA9IG5ldyBCdWZmZXIoaW5kaWNpZXMsIHRydWUsIHRydWUpO1xuICAgICAgICB0aGlzLm9ubHlTcHJpdGVzID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZGVmYXVsdCBzaGFkZXJzIHRoYXQgaXMgdXNlZCBpZiBhIHNwcml0ZSBkb2Vzbid0IGhhdmUgYSBtb3JlIHNwZWNpZmljIG9uZS5cbiAgICAgICAgICogdGhlcmUgaXMgYSBzaGFkZXIgZm9yIGVhY2ggbnVtYmVyIG9mIHRleHR1cmVzIHRoYXQgY2FuIGJlIHJlbmRlcmVkLlxuICAgICAgICAgKiBUaGVzZSBzaGFkZXJzIHdpbGwgYWxzbyBiZSBnZW5lcmF0ZWQgb24gdGhlIGZseSBhcyByZXF1aXJlZC5cbiAgICAgICAgICogQG1lbWJlciB7UElYSS5TaGFkZXJbXX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2hhZGVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5jdXJyZW50SW5kZXggPSAwO1xuICAgICAgICB0aGlzLmdyb3VwcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IHRoaXMuc2l6ZSAvIDQ7IGsrKykge1xuICAgICAgICAgICAgdGhpcy5ncm91cHNba10gPSBuZXcgQmF0Y2hEcmF3Q2FsbF8xLkJhdGNoRHJhd0NhbGwoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVsZW1lbnRzID0gW107XG4gICAgICAgIHRoaXMudmFvcyA9IFtdO1xuICAgICAgICB0aGlzLnZhb01heCA9IDI7XG4gICAgICAgIHRoaXMudmVydGV4Q291bnQgPSAwO1xuICAgICAgICB0aGlzLnJlbmRlcmVyLmFkZEV2ZW50TGlzdGVuZXIoXCJwcmVyZW5kZXJcIiwgdGhpcy5vblByZXJlbmRlcik7XG4gICAgICAgIC8vIHRoaXMucmVuZGVyZXIub24oJ3ByZXJlbmRlcicsIHRoaXMub25QcmVyZW5kZXIsIHRoaXMpO1xuICAgICAgICB0aGlzLnN0YXRlID0gU3RhdGVfMS5TdGF0ZS5mb3IyZCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHVwIHRoZSByZW5kZXJlciBjb250ZXh0IGFuZCBuZWNlc3NhcnkgYnVmZmVycy5cbiAgICAgKi9cbiAgICBjb250ZXh0Q2hhbmdlKCkge1xuICAgICAgICB2YXIgZ2wgPSB0aGlzLnJlbmRlcmVyLmdsO1xuICAgICAgICBpZiAoRGlzcGxheVNldHRpbmdzXzEuRGlzcGxheVNldHRpbmdzLlBSRUZFUl9FTlYgPT09IERpc3BsYXlTZXR0aW5nc18xLkRpc3BsYXlTZXR0aW5ncy5FTlYuV0VCR0xfTEVHQUNZKSB7XG4gICAgICAgICAgICB0aGlzLk1BWF9URVhUVVJFUyA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBzdGVwIDE6IGZpcnN0IGNoZWNrIG1heCB0ZXh0dXJlcyB0aGUgR1BVIGNhbiBoYW5kbGUuXG4gICAgICAgICAgICB0aGlzLk1BWF9URVhUVVJFUyA9IE1hdGgubWluKGdsLmdldFBhcmFtZXRlcihnbC5NQVhfVEVYVFVSRV9JTUFHRV9VTklUUyksIFdlYkdMU2V0dGluZ3NfMS5XZWJHTFNldHRpbmdzLlNQUklURV9NQVhfVEVYVFVSRVMpO1xuICAgICAgICAgICAgLy8gc3RlcCAyOiBjaGVjayB0aGUgbWF4aW11bSBudW1iZXIgb2YgaWYgc3RhdGVtZW50cyB0aGUgc2hhZGVyIGNhbiBoYXZlIHRvby4uXG4gICAgICAgICAgICB0aGlzLk1BWF9URVhUVVJFUyA9IFdlYkdMU2V0dGluZ3NfMS5XZWJHTFNldHRpbmdzLmNoZWNrTWF4SWZTdGF0ZW1lbnRzSW5TaGFkZXIodGhpcy5NQVhfVEVYVFVSRVMsIGdsKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBnZW5lcmF0ZSBnZW5lcmF0ZU11bHRpVGV4dHVyZVByb2dyYW0sIG1heSBiZSBhIGJldHRlciBtb3ZlP1xuICAgICAgICB0aGlzLnNoYWRlciA9IFdlYkdMU2V0dGluZ3NfMS5XZWJHTFNldHRpbmdzLmdlbmVyYXRlTXVsdGlUZXh0dXJlU2hhZGVyKGdsLCB0aGlzLk1BWF9URVhUVVJFUyk7XG4gICAgICAgIC8vIHdlIHVzZSB0aGUgc2Vjb25kIHNoYWRlciBhcyB0aGUgZmlyc3Qgb25lIGRlcGVuZGluZyBvbiB5b3VyIGJyb3dzZXIgbWF5IG9taXQgYVRleHR1cmVJZFxuICAgICAgICAvLyBhcyBpdCBpcyBub3QgdXNlZCBieSB0aGUgc2hhZGVyIHNvIGlzIG9wdGltaXplZCBvdXQuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy52YW9NYXg7IGkrKykge1xuICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xuICAgICAgICAgICAgdGhpcy52YW9zW2ldID0gbmV3IEJhdGNoR2VvbWV0cnlfMS5CYXRjaEdlb21ldHJ5KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgdGhlIHNwcml0ZSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BJWEkuU3ByaXRlfSBzcHJpdGUgLSB0aGUgc3ByaXRlIHRvIHJlbmRlciB3aGVuIHVzaW5nIHRoaXMgc3ByaXRlYmF0Y2hcbiAgICAgKi9cbiAgICByZW5kZXIoZWxlbWVudCkge1xuICAgICAgICBpZiAoIWVsZW1lbnQuX3RleHR1cmUudmFsaWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jdXJyZW50U2l6ZSArIChlbGVtZW50LnZlcnRleERhdGEubGVuZ3RoIC8gMikgPiB0aGlzLnNpemUpIHtcbiAgICAgICAgICAgIHRoaXMuZmx1c2goKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVsZW1lbnRzW3RoaXMuY3VycmVudEluZGV4KytdID0gZWxlbWVudDtcbiAgICAgICAgdGhpcy5jdXJyZW50U2l6ZSArPSBlbGVtZW50LnZlcnRleERhdGEubGVuZ3RoIC8gMjtcbiAgICAgICAgdGhpcy5jdXJyZW50SW5kZXhTaXplICs9IGVsZW1lbnQuaW5kaWNlcy5sZW5ndGg7XG4gICAgfVxuICAgIDtcbiAgICBnZXRJbmRleEJ1ZmZlcihzaXplKSB7XG4gICAgICAgIC8vIDEyIGluZGljZXMgaXMgZW5vdWdoIGZvciAyIHF1YWRzXG4gICAgICAgIHZhciByb3VuZGVkUDIgPSBNYXRoU2V0dGluZ3NfMS5NYXRoU2V0dGluZ3MubmV4dFBvdzIoTWF0aC5jZWlsKHNpemUgLyAxMikpO1xuICAgICAgICB2YXIgcm91bmRlZFNpemVJbmRleCA9IE1hdGhTZXR0aW5nc18xLk1hdGhTZXR0aW5ncy5sb2cyKHJvdW5kZWRQMik7XG4gICAgICAgIHZhciByb3VuZGVkU2l6ZSA9IHJvdW5kZWRQMiAqIDEyO1xuICAgICAgICBpZiAodGhpcy5pQnVmZmVycy5sZW5ndGggPD0gcm91bmRlZFNpemVJbmRleCkge1xuICAgICAgICAgICAgdGhpcy5pQnVmZmVycy5sZW5ndGggPSByb3VuZGVkU2l6ZUluZGV4ICsgMTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYnVmZmVyID0gdGhpcy5pQnVmZmVyc1tyb3VuZGVkU2l6ZUluZGV4XTtcbiAgICAgICAgaWYgKCFidWZmZXIpIHtcbiAgICAgICAgICAgIHRoaXMuaUJ1ZmZlcnNbcm91bmRlZFNpemVJbmRleF0gPSBidWZmZXIgPSBuZXcgVWludDE2QXJyYXkocm91bmRlZFNpemUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBidWZmZXI7XG4gICAgfVxuICAgIDtcbiAgICBnZXRBdHRyaWJ1dGVCdWZmZXIoc2l6ZSkge1xuICAgICAgICAvLyA4IHZlcnRpY2VzIGlzIGVub3VnaCBmb3IgMiBxdWFkc1xuICAgICAgICB2YXIgcm91bmRlZFAyID0gTWF0aFNldHRpbmdzXzEuTWF0aFNldHRpbmdzLm5leHRQb3cyKE1hdGguY2VpbChzaXplIC8gOCkpO1xuICAgICAgICB2YXIgcm91bmRlZFNpemVJbmRleCA9IE1hdGhTZXR0aW5nc18xLk1hdGhTZXR0aW5ncy5sb2cyKHJvdW5kZWRQMik7XG4gICAgICAgIHZhciByb3VuZGVkU2l6ZSA9IHJvdW5kZWRQMiAqIDg7XG4gICAgICAgIGlmICh0aGlzLmFCdWZmZXJzLmxlbmd0aCA8PSByb3VuZGVkU2l6ZUluZGV4KSB7XG4gICAgICAgICAgICB0aGlzLmlCdWZmZXJzLmxlbmd0aCA9IHJvdW5kZWRTaXplSW5kZXggKyAxO1xuICAgICAgICB9XG4gICAgICAgIHZhciBidWZmZXIgPSB0aGlzLmFCdWZmZXJzW3JvdW5kZWRTaXplXTtcbiAgICAgICAgaWYgKCFidWZmZXIpIHtcbiAgICAgICAgICAgIHRoaXMuYUJ1ZmZlcnNbcm91bmRlZFNpemVdID0gYnVmZmVyID0gbmV3IEJhdGNoQnVmZmVyXzEuQmF0Y2hCdWZmZXIocm91bmRlZFNpemUgKiB0aGlzLnZlcnRCeXRlU2l6ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJ1ZmZlcjtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgdGhlIGNvbnRlbnQgYW5kIGVtcHRpZXMgdGhlIGN1cnJlbnQgYmF0Y2guXG4gICAgICpcbiAgICAgKi9cbiAgICBmbHVzaCgpIHtcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFNpemUgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZ2wgPSB0aGlzLnJlbmRlcmVyLmdsO1xuICAgICAgICB2YXIgTUFYX1RFWFRVUkVTID0gdGhpcy5NQVhfVEVYVFVSRVM7XG4gICAgICAgIHZhciBidWZmZXIgPSB0aGlzLmdldEF0dHJpYnV0ZUJ1ZmZlcih0aGlzLmN1cnJlbnRTaXplKTtcbiAgICAgICAgdmFyIGluZGV4QnVmZmVyID0gdGhpcy5nZXRJbmRleEJ1ZmZlcih0aGlzLmN1cnJlbnRJbmRleFNpemUpO1xuICAgICAgICB2YXIgZWxlbWVudHMgPSB0aGlzLmVsZW1lbnRzO1xuICAgICAgICB2YXIgZ3JvdXBzID0gdGhpcy5ncm91cHM7XG4gICAgICAgIHZhciBmbG9hdDMyVmlldyA9IGJ1ZmZlci5mbG9hdDMyVmlldztcbiAgICAgICAgdmFyIHVpbnQzMlZpZXcgPSBidWZmZXIudWludDMyVmlldztcbiAgICAgICAgdmFyIHRvdWNoID0gdGhpcy5yZW5kZXJlci50ZXh0dXJlR0MuY291bnQ7XG4gICAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICAgIHZhciBpbmRleENvdW50ID0gMDtcbiAgICAgICAgdmFyIG5leHRUZXh0dXJlO1xuICAgICAgICB2YXIgY3VycmVudFRleHR1cmU7XG4gICAgICAgIHZhciBncm91cENvdW50ID0gMDtcbiAgICAgICAgdmFyIHRleHR1cmVDb3VudCA9IDA7XG4gICAgICAgIHZhciBjdXJyZW50R3JvdXAgPSBncm91cHNbMF07XG4gICAgICAgIHZhciBibGVuZE1vZGUgPSAtMTsgLy8gcHJlbXVsdGlwbHlCbGVuZE1vZGVbZWxlbWVudHNbMF0uX3RleHR1cmUuYmFzZVRleHR1cmUucHJlbXVsdGlwbHlBbHBoYSA/IDAgOiBdW2VsZW1lbnRzWzBdLmJsZW5kTW9kZV07XG4gICAgICAgIGN1cnJlbnRHcm91cC50ZXh0dXJlQ291bnQgPSAwO1xuICAgICAgICBjdXJyZW50R3JvdXAuc3RhcnQgPSAwO1xuICAgICAgICBjdXJyZW50R3JvdXAuYmxlbmQgPSBibGVuZE1vZGU7XG4gICAgICAgIHZhciBUSUNLID0gKytCYXNlVGV4dHVyZV8xLkJhc2VUZXh0dXJlLl9nbG9iYWxCYXRjaDtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmN1cnJlbnRJbmRleDsgKytpKSB7XG4gICAgICAgICAgICAvLyB1cGxvYWQgdGhlIHNwcml0ZSBlbGVtZW50cy4uLlxuICAgICAgICAgICAgLy8gdGhleSBoYXZlIGFsbCByZWFkeSBiZWVuIGNhbGN1bGF0ZWQgc28gd2UganVzdCBuZWVkIHRvIHB1c2ggdGhlbSBpbnRvIHRoZSBidWZmZXIuXG4gICAgICAgICAgICB2YXIgc3ByaXRlID0gZWxlbWVudHNbaV07XG4gICAgICAgICAgICBlbGVtZW50c1tpXSA9IG51bGw7XG4gICAgICAgICAgICBuZXh0VGV4dHVyZSA9IHNwcml0ZS5fdGV4dHVyZS5iYXNlVGV4dHVyZTtcbiAgICAgICAgICAgIHZhciBzcHJpdGVCbGVuZE1vZGUgPSBCbGVuZE1vZGVzU2V0dGluZ3NfMS5CbGVuZE1vZGVzU2V0dGluZ3MucHJlbXVsdGlwbHlCbGVuZE1vZGVbbmV4dFRleHR1cmUucHJlbXVsdGlwbHlBbHBoYSA/IDEgOiAwXVtzcHJpdGUuYmxlbmRNb2RlXTtcbiAgICAgICAgICAgIGlmIChibGVuZE1vZGUgIT09IHNwcml0ZUJsZW5kTW9kZSkge1xuICAgICAgICAgICAgICAgIGJsZW5kTW9kZSA9IHNwcml0ZUJsZW5kTW9kZTtcbiAgICAgICAgICAgICAgICAvLyBmb3JjZSB0aGUgYmF0Y2ggdG8gYnJlYWshXG4gICAgICAgICAgICAgICAgY3VycmVudFRleHR1cmUgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRleHR1cmVDb3VudCA9IE1BWF9URVhUVVJFUztcbiAgICAgICAgICAgICAgICBUSUNLKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY3VycmVudFRleHR1cmUgIT09IG5leHRUZXh0dXJlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFRleHR1cmUgPSBuZXh0VGV4dHVyZTtcbiAgICAgICAgICAgICAgICBpZiAobmV4dFRleHR1cmUuX2JhdGNoRW5hYmxlZCAhPT0gVElDSykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGV4dHVyZUNvdW50ID09PSBNQVhfVEVYVFVSRVMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFRJQ0srKztcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHR1cmVDb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50R3JvdXAuc2l6ZSA9IGluZGV4Q291bnQgLSBjdXJyZW50R3JvdXAuc3RhcnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50R3JvdXAgPSBncm91cHNbZ3JvdXBDb3VudCsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRHcm91cC50ZXh0dXJlQ291bnQgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEdyb3VwLmJsZW5kID0gYmxlbmRNb2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEdyb3VwLnN0YXJ0ID0gaW5kZXhDb3VudDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBuZXh0VGV4dHVyZS50b3VjaGVkID0gdG91Y2g7XG4gICAgICAgICAgICAgICAgICAgIG5leHRUZXh0dXJlLl9iYXRjaEVuYWJsZWQgPSBUSUNLO1xuICAgICAgICAgICAgICAgICAgICBuZXh0VGV4dHVyZS5faWQgPSB0ZXh0dXJlQ291bnQ7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRHcm91cC50ZXh0dXJlc1tjdXJyZW50R3JvdXAudGV4dHVyZUNvdW50KytdID0gbmV4dFRleHR1cmU7XG4gICAgICAgICAgICAgICAgICAgIHRleHR1cmVDb3VudCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucGFja0dlb21ldHJ5KHNwcml0ZSwgZmxvYXQzMlZpZXcsIHVpbnQzMlZpZXcsIGluZGV4QnVmZmVyLCBpbmRleCwgaW5kZXhDb3VudCk7IC8vIGFyZ2IsIG5leHRUZXh0dXJlLl9pZCwgZmxvYXQzMlZpZXcsIHVpbnQzMlZpZXcsIGluZGV4QnVmZmVyLCBpbmRleCwgaW5kZXhDb3VudCk7XG4gICAgICAgICAgICAvLyBIRVJFIFxuICAgICAgICAgICAgLy8gcHVzaCBhIGdyYXBoaWNzLi5cbiAgICAgICAgICAgIGluZGV4ICs9IChzcHJpdGUudmVydGV4RGF0YS5sZW5ndGggLyAyKSAqIHRoaXMudmVydFNpemU7XG4gICAgICAgICAgICBpbmRleENvdW50ICs9IHNwcml0ZS5pbmRpY2VzLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBCYXNlVGV4dHVyZV8xLkJhc2VUZXh0dXJlLl9nbG9iYWxCYXRjaCA9IFRJQ0s7XG4gICAgICAgIGN1cnJlbnRHcm91cC5zaXplID0gaW5kZXhDb3VudCAtIGN1cnJlbnRHcm91cC5zdGFydDtcbiAgICAgICAgLy8gICAgICAgIHRoaXMuaW5kZXhCdWZmZXIudXBkYXRlKCk7XG4gICAgICAgIGlmICghV2ViR0xTZXR0aW5nc18xLldlYkdMU2V0dGluZ3MuQ0FOX1VQTE9BRF9TQU1FX0JVRkZFUikge1xuICAgICAgICAgICAgLy8gdGhpcyBpcyBzdGlsbCBuZWVkZWQgZm9yIElPUyBwZXJmb3JtYW5jZS4uXG4gICAgICAgICAgICAvLyBpdCByZWFsbHkgZG9lcyBub3QgbGlrZSB1cGxvYWRpbmcgdG8gdGhlIHNhbWUgYnVmZmVyIGluIGEgc2luZ2xlIGZyYW1lIVxuICAgICAgICAgICAgaWYgKHRoaXMudmFvTWF4IDw9IHRoaXMudmVydGV4Q291bnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZhb01heCsrO1xuICAgICAgICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4gKi9cbiAgICAgICAgICAgICAgICB0aGlzLnZhb3NbdGhpcy52ZXJ0ZXhDb3VudF0gPSBuZXcgQmF0Y2hHZW9tZXRyeV8xLkJhdGNoR2VvbWV0cnkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudmFvc1t0aGlzLnZlcnRleENvdW50XS5fYnVmZmVyLnVwZGF0ZShidWZmZXIudmVydGljZXMsIDApO1xuICAgICAgICAgICAgdGhpcy52YW9zW3RoaXMudmVydGV4Q291bnRdLl9pbmRleEJ1ZmZlci51cGRhdGUoaW5kZXhCdWZmZXIsIDApO1xuICAgICAgICAgICAgLy8gICB0aGlzLnZlcnRleEJ1ZmZlcnNbdGhpcy52ZXJ0ZXhDb3VudF0udXBkYXRlKGJ1ZmZlci52ZXJ0aWNlcywgMCk7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLmdlb21ldHJ5LmJpbmQodGhpcy52YW9zW3RoaXMudmVydGV4Q291bnRdKTtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuZ2VvbWV0cnkudXBkYXRlQnVmZmVycygpO1xuICAgICAgICAgICAgdGhpcy52ZXJ0ZXhDb3VudCsrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gbGV0cyB1c2UgdGhlIGZhc3RlciBvcHRpb24sIGFsd2F5cyB1c2UgYnVmZmVyIG51bWJlciAwXG4gICAgICAgICAgICB0aGlzLnZhb3NbdGhpcy52ZXJ0ZXhDb3VudF0uX2J1ZmZlci51cGRhdGUoYnVmZmVyLnZlcnRpY2VzLCAwKTtcbiAgICAgICAgICAgIHRoaXMudmFvc1t0aGlzLnZlcnRleENvdW50XS5faW5kZXhCdWZmZXIudXBkYXRlKGluZGV4QnVmZmVyLCAwKTtcbiAgICAgICAgICAgIC8vICAgaWYgKHRydWUpLy8gdGhpcy5zcHJpdGVPbmx5KVxuICAgICAgICAgICAgLy8ge1xuICAgICAgICAgICAgLy8gdGhpcy52YW9zW3RoaXMudmVydGV4Q291bnRdLmluZGV4QnVmZmVyID0gdGhpcy5kZWZ1YWx0U3ByaXRlSW5kZXhCdWZmZXI7XG4gICAgICAgICAgICAvLyB0aGlzLnZhb3NbdGhpcy52ZXJ0ZXhDb3VudF0uYnVmZmVyc1sxXSA9IHRoaXMuZGVmdWFsdFNwcml0ZUluZGV4QnVmZmVyO1xuICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgLy8gdGhpcy52YW9zWzBdLmF0dHJpYnV0ZXMuYUNvbG9yLnN0cmlkZSA9IDI0XG4gICAgICAgICAgICAvLyB0aGlzLnZhb3NbMF0uYXR0cmlidXRlcy5hQ29sb3Iuc3RhcnQgPSAxNlxuICAgICAgICAgICAgLy8gTk9UIFNFVFxuICAgICAgICAgICAgLy8gdGhpcy52YW9zWzBdLmF0dHJpYnV0ZXMuYVRleHR1cmVDb29yZC5zdHJpZGUgPSAyNFxuICAgICAgICAgICAgLy8gdGhpcy52YW9zWzBdLmF0dHJpYnV0ZXMuYVRleHR1cmVDb29yZC5zdGFydCA9IDhcbiAgICAgICAgICAgIC8vIE5PVCBTRVRcbiAgICAgICAgICAgIC8vIHRoaXMudmFvc1swXS5hdHRyaWJ1dGVzLmFWZXJ0ZXhQb3NpdGlvbi5zdHJpZGUgPSAyNFxuICAgICAgICAgICAgLy8gTk9UIFNFVFxuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5nZW9tZXRyeS51cGRhdGVCdWZmZXJzKCk7XG4gICAgICAgICAgICAvLyAgICBcbiAgICAgICAgfVxuICAgICAgICAvLyAgIHRoaXMucmVuZGVyZXIuc3RhdGUuc2V0KHRoaXMuc3RhdGUpO1xuICAgICAgICB2YXIgdGV4dHVyZVN5c3RlbSA9IHRoaXMucmVuZGVyZXIudGV4dHVyZTtcbiAgICAgICAgdmFyIHN0YXRlU3lzdGVtID0gdGhpcy5yZW5kZXJlci5zdGF0ZTtcbiAgICAgICAgLy8gZS5sb2coZ3JvdXBDb3VudCk7XG4gICAgICAgIC8vIC8gcmVuZGVyIHRoZSBncm91cHMuLlxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZ3JvdXBDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgZ3JvdXAgPSBncm91cHNbaV07XG4gICAgICAgICAgICB2YXIgZ3JvdXBUZXh0dXJlQ291bnQgPSBncm91cC50ZXh0dXJlQ291bnQ7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGdyb3VwVGV4dHVyZUNvdW50OyBqKyspIHtcbiAgICAgICAgICAgICAgICB0ZXh0dXJlU3lzdGVtLmJpbmQoZ3JvdXAudGV4dHVyZXNbal0sIGopO1xuICAgICAgICAgICAgICAgIGdyb3VwLnRleHR1cmVzW2pdID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHRoaXMuc3RhdGUuYmxlbmRNb2RlID0gZ3JvdXAuYmxlbmQ7XG4gICAgICAgICAgICAvLyB0aGlzLnN0YXRlLmJsZW5kID0gdHJ1ZTtcbiAgICAgICAgICAgIC8vIHRoaXMucmVuZGVyZXIuc3RhdGUuc2V0U3RhdGUodGhpcy5zdGF0ZSk7XG4gICAgICAgICAgICAvLyBzZXQgdGhlIGJsZW5kIG1vZGUuLlxuICAgICAgICAgICAgc3RhdGVTeXN0ZW0uc2V0QmxlbmRNb2RlKGdyb3VwLmJsZW5kKTtcbiAgICAgICAgICAgIGdsLmRyYXdFbGVtZW50cyhncm91cC50eXBlLCBncm91cC5zaXplLCBnbC5VTlNJR05FRF9TSE9SVCwgZ3JvdXAuc3RhcnQgKiAyKTtcbiAgICAgICAgfVxuICAgICAgICAvLyByZXNldCBlbGVtZW50cyBmb3IgdGhlIG5leHQgZmx1c2hcbiAgICAgICAgdGhpcy5jdXJyZW50SW5kZXggPSAwO1xuICAgICAgICB0aGlzLmN1cnJlbnRTaXplID0gMDtcbiAgICAgICAgdGhpcy5jdXJyZW50SW5kZXhTaXplID0gMDtcbiAgICB9XG4gICAgO1xuICAgIHBhY2tHZW9tZXRyeShlbGVtZW50LCBmbG9hdDMyVmlldywgdWludDMyVmlldywgaW5kZXhCdWZmZXIsIGluZGV4LCBpbmRleENvdW50KSB7XG4gICAgICAgIHZhciBwID0gaW5kZXggLyB0aGlzLnZlcnRTaXplOyAvLyBmbG9hdDMyVmlldy5sZW5ndGggLyA2IC8gMjtcbiAgICAgICAgdmFyIHV2cyA9IGVsZW1lbnQudXZzO1xuICAgICAgICB2YXIgaW5kaWNpZXMgPSBlbGVtZW50LmluZGljZXM7IC8vIGdlb21ldHJ5LmdldEluZGV4KCkuZGF0YTsvLyBpbmRpY2llcztcbiAgICAgICAgdmFyIHZlcnRleERhdGEgPSBlbGVtZW50LnZlcnRleERhdGE7XG4gICAgICAgIHZhciB0ZXh0dXJlSWQgPSBlbGVtZW50Ll90ZXh0dXJlLmJhc2VUZXh0dXJlLl9pZDtcbiAgICAgICAgdmFyIGFscGhhID0gTWF0aC5taW4oZWxlbWVudC53b3JsZEFscGhhLCAxLjApO1xuICAgICAgICB2YXIgYXJnYiA9IGFscGhhIDwgMS4wICYmIGVsZW1lbnQuX3RleHR1cmUuYmFzZVRleHR1cmUucHJlbXVsdGlwbHlBbHBoYSA/IENvbG9yU2V0dGluZ3NfMS5Db2xvclNldHRpbmdzLnByZW11bHRpcGx5VGludChlbGVtZW50Ll90aW50UkdCLCBhbHBoYSlcbiAgICAgICAgICAgIDogZWxlbWVudC5fdGludFJHQiArIChhbHBoYSAqIDI1NSA8PCAyNCk7XG4gICAgICAgIC8vIGxldHMgbm90IHdvcnJ5IGFib3V0IHRpbnQhIGZvciBub3cuLlxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZlcnRleERhdGEubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgIGZsb2F0MzJWaWV3W2luZGV4KytdID0gdmVydGV4RGF0YVtpXTtcbiAgICAgICAgICAgIGZsb2F0MzJWaWV3W2luZGV4KytdID0gdmVydGV4RGF0YVtpICsgMV07XG4gICAgICAgICAgICBmbG9hdDMyVmlld1tpbmRleCsrXSA9IHV2c1tpXTtcbiAgICAgICAgICAgIGZsb2F0MzJWaWV3W2luZGV4KytdID0gdXZzW2kgKyAxXTtcbiAgICAgICAgICAgIHVpbnQzMlZpZXdbaW5kZXgrK10gPSBhcmdiO1xuICAgICAgICAgICAgZmxvYXQzMlZpZXdbaW5kZXgrK10gPSB0ZXh0dXJlSWQ7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgaW5kaWNpZXMubGVuZ3RoOyBpJDErKykge1xuICAgICAgICAgICAgaW5kZXhCdWZmZXJbaW5kZXhDb3VudCsrXSA9IHAgKyBpbmRpY2llc1tpJDFdO1xuICAgICAgICB9XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBTdGFydHMgYSBuZXcgc3ByaXRlIGJhdGNoLlxuICAgICAqL1xuICAgIHN0YXJ0KCkge1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnN0YXRlLnNldFN0YXRlKHRoaXMuc3RhdGUpO1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnNoYWRlci5iaW5kKHRoaXMuc2hhZGVyKTtcbiAgICAgICAgaWYgKFdlYkdMU2V0dGluZ3NfMS5XZWJHTFNldHRpbmdzLkNBTl9VUExPQURfU0FNRV9CVUZGRVIpIHtcbiAgICAgICAgICAgIC8vIGJpbmQgYnVmZmVyICMwLCB3ZSBkb24ndCBuZWVkIG90aGVyc1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5nZW9tZXRyeS5iaW5kKHRoaXMudmFvc1t0aGlzLnZlcnRleENvdW50XSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFN0b3BzIGFuZCBmbHVzaGVzIHRoZSBjdXJyZW50IGJhdGNoLlxuICAgICAqXG4gICAgICovXG4gICAgc3RvcCgpIHtcbiAgICAgICAgdGhpcy5mbHVzaCgpO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogRGVzdHJveXMgdGhlIFNwcml0ZVJlbmRlcmVyLlxuICAgICAqXG4gICAgICovXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnZhb01heDsgaSsrKSB7XG4gICAgICAgICAgICAvLyBpZiAodGhpcy52ZXJ0ZXhCdWZmZXJzW2ldKVxuICAgICAgICAgICAgLy8ge1xuICAgICAgICAgICAgLy8gICAgIHRoaXMudmVydGV4QnVmZmVyc1tpXS5kZXN0cm95KCk7XG4gICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICBpZiAodGhpcy52YW9zW2ldKSB7XG4gICAgICAgICAgICAgICAgdGhpcy52YW9zW2ldLmRlc3Ryb3kobnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaW5kZXhCdWZmZXIpIHtcbiAgICAgICAgICAgIHRoaXMuaW5kZXhCdWZmZXIuZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVuZGVyZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcigncHJlcmVuZGVyJywgdGhpcy5vblByZXJlbmRlcik7XG4gICAgICAgIGlmICh0aGlzLnNoYWRlcikge1xuICAgICAgICAgICAgdGhpcy5zaGFkZXIuZGVzdHJveSgpO1xuICAgICAgICAgICAgdGhpcy5zaGFkZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRoaXMudmVydGV4QnVmZmVycyA9IG51bGw7XG4gICAgICAgIHRoaXMudmFvcyA9IG51bGw7XG4gICAgICAgIHRoaXMuaW5kZXhCdWZmZXIgPSBudWxsO1xuICAgICAgICB0aGlzLmluZGljZXMgPSBudWxsO1xuICAgICAgICB0aGlzLnNwcml0ZXMgPSBudWxsO1xuICAgICAgICAvLyBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuYnVmZmVycy5sZW5ndGg7ICsraSlcbiAgICAgICAgLy8ge1xuICAgICAgICAvLyAgICAgdGhpcy5idWZmZXJzW2ldLmRlc3Ryb3koKTtcbiAgICAgICAgLy8gfVxuICAgICAgICBzdXBlci5kZXN0cm95KCk7XG4gICAgfVxuICAgIDtcbn1cbmV4cG9ydHMuQmF0Y2hSZW5kZXJlciA9IEJhdGNoUmVuZGVyZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IFN5c3RlbV8xID0gcmVxdWlyZShcIi4vU3lzdGVtXCIpO1xuY29uc3QgT2JqZWN0UmVuZGVyZXJfMSA9IHJlcXVpcmUoXCIuL09iamVjdFJlbmRlcmVyXCIpO1xuY2xhc3MgQmF0Y2hTeXN0ZW0gZXh0ZW5kcyBTeXN0ZW1fMS5TeXN0ZW0ge1xuICAgIGNvbnN0cnVjdG9yKHJlbmRlcmVyKSB7XG4gICAgICAgIHN1cGVyKHJlbmRlcmVyKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIGVtcHR5IHJlbmRlcmVyLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLk9iamVjdFJlbmRlcmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5lbXB0eVJlbmRlcmVyID0gbmV3IE9iamVjdFJlbmRlcmVyXzEuT2JqZWN0UmVuZGVyZXIocmVuZGVyZXIpO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGN1cnJlbnRseSBhY3RpdmUgT2JqZWN0UmVuZGVyZXIuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuT2JqZWN0UmVuZGVyZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmN1cnJlbnRSZW5kZXJlciA9IHRoaXMuZW1wdHlSZW5kZXJlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hhbmdlcyB0aGUgY3VycmVudCByZW5kZXJlciB0byB0aGUgb25lIGdpdmVuIGluIHBhcmFtZXRlclxuICAgICAqXG4gICAgICogQHBhcmFtIHtQSVhJLk9iamVjdFJlbmRlcmVyfSBvYmplY3RSZW5kZXJlciAtIFRoZSBvYmplY3QgcmVuZGVyZXIgdG8gdXNlLlxuICAgICAqL1xuICAgIHNldE9iamVjdFJlbmRlcmVyKG9iamVjdFJlbmRlcmVyKSB7XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRSZW5kZXJlciA9PT0gb2JqZWN0UmVuZGVyZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmN1cnJlbnRSZW5kZXJlci5zdG9wKCk7XG4gICAgICAgIHRoaXMuY3VycmVudFJlbmRlcmVyID0gb2JqZWN0UmVuZGVyZXI7XG4gICAgICAgIHRoaXMuY3VycmVudFJlbmRlcmVyLnN0YXJ0KCk7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBUaGlzIHNob3VsZCBiZSBjYWxsZWQgaWYgeW91IHdpc2ggdG8gZG8gc29tZSBjdXN0b20gcmVuZGVyaW5nXG4gICAgICogSXQgd2lsbCBiYXNpY2FsbHkgcmVuZGVyIGFueXRoaW5nIHRoYXQgbWF5IGJlIGJhdGNoZWQgdXAgc3VjaCBhcyBzcHJpdGVzXG4gICAgICovXG4gICAgZmx1c2goKSB7XG4gICAgICAgIHRoaXMuc2V0T2JqZWN0UmVuZGVyZXIodGhpcy5lbXB0eVJlbmRlcmVyKTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFJlc2V0IHRoZSBzeXN0ZW0gdG8gYW4gZW1wdHkgcmVuZGVyZXJcbiAgICAgKi9cbiAgICByZXNldCgpIHtcbiAgICAgICAgdGhpcy5zZXRPYmplY3RSZW5kZXJlcih0aGlzLmVtcHR5UmVuZGVyZXIpO1xuICAgIH1cbiAgICA7XG59XG5leHBvcnRzLkJhdGNoU3lzdGVtID0gQmF0Y2hTeXN0ZW07XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHNldHRpbmdzXzEgPSByZXF1aXJlKFwiLi9zZXR0aW5nc1wiKTtcbmNsYXNzIEJlemllclV0aWxzIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICB9XG4gICAgc3RhdGljIGN1cnZlTGVuZ3RoKGZyb21YLCBmcm9tWSwgY3BYLCBjcFksIGNwWDIsIGNwWTIsIHRvWCwgdG9ZKSB7XG4gICAgICAgIHZhciBuID0gMTA7XG4gICAgICAgIHZhciByZXN1bHQgPSAwLjA7XG4gICAgICAgIHZhciB0ID0gMC4wO1xuICAgICAgICB2YXIgdDIgPSAwLjA7XG4gICAgICAgIHZhciB0MyA9IDAuMDtcbiAgICAgICAgdmFyIG50ID0gMC4wO1xuICAgICAgICB2YXIgbnQyID0gMC4wO1xuICAgICAgICB2YXIgbnQzID0gMC4wO1xuICAgICAgICB2YXIgeCA9IDAuMDtcbiAgICAgICAgdmFyIHkgPSAwLjA7XG4gICAgICAgIHZhciBkeCA9IDAuMDtcbiAgICAgICAgdmFyIGR5ID0gMC4wO1xuICAgICAgICB2YXIgcHJldlggPSBmcm9tWDtcbiAgICAgICAgdmFyIHByZXZZID0gZnJvbVk7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDw9IG47ICsraSkge1xuICAgICAgICAgICAgdCA9IGkgLyBuO1xuICAgICAgICAgICAgdDIgPSB0ICogdDtcbiAgICAgICAgICAgIHQzID0gdDIgKiB0O1xuICAgICAgICAgICAgbnQgPSAoMS4wIC0gdCk7XG4gICAgICAgICAgICBudDIgPSBudCAqIG50O1xuICAgICAgICAgICAgbnQzID0gbnQyICogbnQ7XG4gICAgICAgICAgICB4ID0gKG50MyAqIGZyb21YKSArICgzLjAgKiBudDIgKiB0ICogY3BYKSArICgzLjAgKiBudCAqIHQyICogY3BYMikgKyAodDMgKiB0b1gpO1xuICAgICAgICAgICAgeSA9IChudDMgKiBmcm9tWSkgKyAoMy4wICogbnQyICogdCAqIGNwWSkgKyAoMyAqIG50ICogdDIgKiBjcFkyKSArICh0MyAqIHRvWSk7XG4gICAgICAgICAgICBkeCA9IHByZXZYIC0geDtcbiAgICAgICAgICAgIGR5ID0gcHJldlkgLSB5O1xuICAgICAgICAgICAgcHJldlggPSB4O1xuICAgICAgICAgICAgcHJldlkgPSB5O1xuICAgICAgICAgICAgcmVzdWx0ICs9IE1hdGguc3FydCgoZHggKiBkeCkgKyAoZHkgKiBkeSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgdGhlIHBvaW50cyBmb3IgYSBiZXppZXIgY3VydmUgYW5kIHRoZW4gZHJhd3MgaXQuXG4gICAgICpcbiAgICAgKiBJZ25vcmVkIGZyb20gZG9jcyBzaW5jZSBpdCBpcyBub3QgZGlyZWN0bHkgZXhwb3NlZC5cbiAgICAgKlxuICAgICAqIEBpZ25vcmVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY3BYIC0gQ29udHJvbCBwb2ludCB4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNwWSAtIENvbnRyb2wgcG9pbnQgeVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjcFgyIC0gU2Vjb25kIENvbnRyb2wgcG9pbnQgeFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjcFkyIC0gU2Vjb25kIENvbnRyb2wgcG9pbnQgeVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0b1ggLSBEZXN0aW5hdGlvbiBwb2ludCB4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRvWSAtIERlc3RpbmF0aW9uIHBvaW50IHlcbiAgICAgKiBAcGFyYW0ge251bWJlcltdfSBwb2ludHMgLSBQYXRoIGFycmF5IHRvIHB1c2ggcG9pbnRzIGludG9cbiAgICAgKi9cbiAgICBzdGF0aWMgY3VydmVUbyhjcFgsIGNwWSwgY3BYMiwgY3BZMiwgdG9YLCB0b1ksIHBvaW50cykge1xuICAgICAgICB2YXIgZnJvbVggPSBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDJdO1xuICAgICAgICB2YXIgZnJvbVkgPSBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDFdO1xuICAgICAgICBwb2ludHMubGVuZ3RoIC09IDI7XG4gICAgICAgIHZhciBuID0gc2V0dGluZ3NfMS5zZXR0aW5ncy5HUkFQSElDU19DVVJWRVMuX3NlZ21lbnRzQ291bnQoQmV6aWVyVXRpbHMuY3VydmVMZW5ndGgoZnJvbVgsIGZyb21ZLCBjcFgsIGNwWSwgY3BYMiwgY3BZMiwgdG9YLCB0b1kpKTtcbiAgICAgICAgdmFyIGR0ID0gMDtcbiAgICAgICAgdmFyIGR0MiA9IDA7XG4gICAgICAgIHZhciBkdDMgPSAwO1xuICAgICAgICB2YXIgdDIgPSAwO1xuICAgICAgICB2YXIgdDMgPSAwO1xuICAgICAgICBwb2ludHMucHVzaChmcm9tWCwgZnJvbVkpO1xuICAgICAgICBmb3IgKHZhciBpID0gMSwgaiA9IDA7IGkgPD0gbjsgKytpKSB7XG4gICAgICAgICAgICBqID0gaSAvIG47XG4gICAgICAgICAgICBkdCA9ICgxIC0gaik7XG4gICAgICAgICAgICBkdDIgPSBkdCAqIGR0O1xuICAgICAgICAgICAgZHQzID0gZHQyICogZHQ7XG4gICAgICAgICAgICB0MiA9IGogKiBqO1xuICAgICAgICAgICAgdDMgPSB0MiAqIGo7XG4gICAgICAgICAgICBwb2ludHMucHVzaCgoZHQzICogZnJvbVgpICsgKDMgKiBkdDIgKiBqICogY3BYKSArICgzICogZHQgKiB0MiAqIGNwWDIpICsgKHQzICogdG9YKSwgKGR0MyAqIGZyb21ZKSArICgzICogZHQyICogaiAqIGNwWSkgKyAoMyAqIGR0ICogdDIgKiBjcFkyKSArICh0MyAqIHRvWSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIDtcbn1cbmV4cG9ydHMuQmV6aWVyVXRpbHMgPSBCZXppZXJVdGlscztcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgQ29udGFpbmVyXzEgPSByZXF1aXJlKFwiLi9Db250YWluZXJcIik7XG5jb25zdCBPYnNlcnZhYmxlUG9pbnRfMSA9IHJlcXVpcmUoXCIuL09ic2VydmFibGVQb2ludFwiKTtcbmNvbnN0IFNwcml0ZV8xID0gcmVxdWlyZShcIi4vU3ByaXRlXCIpO1xuY29uc3QgRGlzcGxheVNldHRpbmdzXzEgPSByZXF1aXJlKFwiLi9EaXNwbGF5U2V0dGluZ3NcIik7XG5jb25zdCBVdGlsc1NldHRpbmdzXzEgPSByZXF1aXJlKFwiLi9VdGlsc1NldHRpbmdzXCIpO1xuY29uc3QgUG9pbnRfMSA9IHJlcXVpcmUoXCIuLi9mbGFzaC9nZW9tL1BvaW50XCIpO1xuY29uc3QgRmxhc2hCYXNlT2JqZWN0XzEgPSByZXF1aXJlKFwiLi9GbGFzaEJhc2VPYmplY3RcIik7XG5jb25zdCBGb250TWFuYWdlcl8xID0gcmVxdWlyZShcIi4vRm9udE1hbmFnZXJcIik7XG5jbGFzcyBCaXRtYXBUZXh0IGV4dGVuZHMgQ29udGFpbmVyXzEuQ29udGFpbmVyIHtcbiAgICBjb25zdHJ1Y3Rvcih0ZXh0KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuaGFzRm9udCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmJpdG1hcGZvbnQgPSBudWxsO1xuICAgICAgICB0aGlzLl90ZXh0V2lkdGggPSAwO1xuICAgICAgICB0aGlzLl90ZXh0SGVpZ2h0ID0gMDtcbiAgICAgICAgdGhpcy5fZ2x5cGhzID0gW107XG4gICAgICAgIHRoaXMuX2ZvbnQgPSBuZXcgQml0bWFwRm9udFRyYWNrZXIoKTtcbiAgICAgICAgdGhpcy5fZm9udC5hbGlnbiA9IFwibGVmdFwiO1xuICAgICAgICB0aGlzLl9mb250LnNpemUgPSAxNjtcbiAgICAgICAgdGhpcy5fZm9udC50aW50ID0gMHhGRkZGRkY7XG4gICAgICAgIHRoaXMuZm9udCA9IG51bGw7XG4gICAgICAgIHRoaXMuX3RleHQgPSB0ZXh0O1xuICAgICAgICB0aGlzLl9tYXhXaWR0aCA9IDA7XG4gICAgICAgIHRoaXMuX21heExpbmVIZWlnaHQgPSAwO1xuICAgICAgICB0aGlzLl9sZXR0ZXJTcGFjaW5nID0gMDtcbiAgICAgICAgdGhpcy5fYW5jaG9yID0gbmV3IE9ic2VydmFibGVQb2ludF8xLk9ic2VydmFibGVQb2ludCgwLCAwKTtcbiAgICAgICAgdGhpcy5fYW5jaG9yLnNjb3BlID0gdGhpcztcbiAgICAgICAgdGhpcy5fYW5jaG9yLmNhbGxiYWNrID0gZnVuY3Rpb24gKCkgeyB0aGlzLmRpcnR5ID0gdHJ1ZTsgfTtcbiAgICAgICAgdGhpcy5kaXJ0eSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnJvdW5kUGl4ZWxzID0gRGlzcGxheVNldHRpbmdzXzEuRGlzcGxheVNldHRpbmdzLlJPVU5EX1BJWEVMUztcbiAgICAgICAgdGhpcy51cGRhdGVUZXh0KCk7XG4gICAgfVxuICAgIGdldCBmb250KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZm9udC5uYW1lO1xuICAgIH1cbiAgICA7XG4gICAgc2V0IGZvbnQodmFsdWUpIHtcbiAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSA9PSB0aGlzLl9mb250Lm5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9mb250Lm5hbWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgfVxuICAgIDtcbiAgICByZW5kZXIocmVuZGVyZXIpIHtcbiAgICAgICAgaWYgKCF0aGlzLmJpdG1hcGZvbnQpIHtcbiAgICAgICAgICAgIHRoaXMuYml0bWFwZm9udCA9IEZvbnRNYW5hZ2VyXzEuRm9udE1hbmFnZXIuZ2V0Qml0bWFwRm9udCh0aGlzLl9mb250Lm5hbWUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmJpdG1hcGZvbnQgJiYgIXRoaXMuaGFzRm9udCkge1xuICAgICAgICAgICAgdGhpcy5oYXNGb250ID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyLnJlbmRlcihyZW5kZXJlcik7XG4gICAgfVxuICAgIHVwZGF0ZVRleHQoKSB7XG4gICAgICAgIGlmICghdGhpcy5iaXRtYXBmb250KSB7XG4gICAgICAgICAgICB0aGlzLmJpdG1hcGZvbnQgPSBGb250TWFuYWdlcl8xLkZvbnRNYW5hZ2VyLmdldEJpdG1hcEZvbnQodGhpcy5fZm9udC5uYW1lKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc2NhbGUgPSB0aGlzLl9mb250LmZvbnRTaXplIC8gdGhpcy5iaXRtYXBmb250LnNpemU7XG4gICAgICAgIGlmIChzY2FsZSA8PSAwKSB7XG4gICAgICAgICAgICBzY2FsZSA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHBvcyA9IFBvaW50XzEuUG9pbnQuZ2V0UG9pbnQoKTtcbiAgICAgICAgbGV0IGNoYXJzID0gW107XG4gICAgICAgIGxldCBsaW5lV2lkdGhzID0gW107XG4gICAgICAgIGxldCB0ZXh0ID0gdGhpcy5fdGV4dC5yZXBsYWNlKC8oPzpcXHJcXG58XFxyKS9nLCAnXFxuJykgfHwgJyAnO1xuICAgICAgICBsZXQgdGV4dExlbmd0aCA9IHRleHQubGVuZ3RoO1xuICAgICAgICBsZXQgbWF4V2lkdGggPSB0aGlzLl9tYXhXaWR0aCAqIHRoaXMuYml0bWFwZm9udC5zaXplIC8gdGhpcy5fZm9udC5zaXplO1xuICAgICAgICBsZXQgcHJldkNoYXJDb2RlID0gbnVsbDtcbiAgICAgICAgbGV0IGxhc3RMaW5lV2lkdGggPSAwO1xuICAgICAgICBsZXQgbWF4TGluZVdpZHRoID0gMDtcbiAgICAgICAgbGV0IGxpbmUgPSAwO1xuICAgICAgICBsZXQgbGFzdEJyZWFrUG9zID0gLTE7XG4gICAgICAgIGxldCBsYXN0QnJlYWtXaWR0aCA9IDA7XG4gICAgICAgIGxldCBzcGFjZXNSZW1vdmVkID0gMDtcbiAgICAgICAgbGV0IG1heExpbmVIZWlnaHQgPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRleHRMZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGNoYXJDb2RlID0gdGV4dC5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAgICAgbGV0IGNoYXIgPSB0ZXh0LmNoYXJBdChpKTtcbiAgICAgICAgICAgIGlmICgoLyg/OlxccykvKS50ZXN0KGNoYXIpKSB7XG4gICAgICAgICAgICAgICAgbGFzdEJyZWFrUG9zID0gaTtcbiAgICAgICAgICAgICAgICBsYXN0QnJlYWtXaWR0aCA9IGxhc3RMaW5lV2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2hhciA9PT0gJ1xccicgfHwgY2hhciA9PT0gJ1xcbicpIHtcbiAgICAgICAgICAgICAgICBsaW5lV2lkdGhzLnB1c2gobGFzdExpbmVXaWR0aCk7XG4gICAgICAgICAgICAgICAgbWF4TGluZVdpZHRoID0gTWF0aC5tYXgobWF4TGluZVdpZHRoLCBsYXN0TGluZVdpZHRoKTtcbiAgICAgICAgICAgICAgICArK2xpbmU7XG4gICAgICAgICAgICAgICAgKytzcGFjZXNSZW1vdmVkO1xuICAgICAgICAgICAgICAgIHBvcy54ID0gMDtcbiAgICAgICAgICAgICAgICBwb3MueSArPSB0aGlzLmJpdG1hcGZvbnQubGluZUhlaWdodDtcbiAgICAgICAgICAgICAgICBwcmV2Q2hhckNvZGUgPSBudWxsO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGNoYXJEYXRhID0gdGhpcy5iaXRtYXBmb250LmNoYXJzW2NoYXJDb2RlXTtcbiAgICAgICAgICAgIGlmICghY2hhckRhdGEpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcmV2Q2hhckNvZGUgJiYgY2hhckRhdGEua2VybmluZ1twcmV2Q2hhckNvZGVdKSB7XG4gICAgICAgICAgICAgICAgcG9zLnggKz0gY2hhckRhdGEua2VybmluZ1twcmV2Q2hhckNvZGVdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGdsaXB0aGRhdGEgPSBuZXcgRGF0YUdsaXB0aCgpO1xuICAgICAgICAgICAgZ2xpcHRoZGF0YS50ZXh0dXJlID0gY2hhckRhdGEudGV4dHVyZTtcbiAgICAgICAgICAgIGdsaXB0aGRhdGEubGluZSA9IGxpbmU7XG4gICAgICAgICAgICBnbGlwdGhkYXRhLmNoYXJDb2RlID0gY2hhckNvZGU7XG4gICAgICAgICAgICBnbGlwdGhkYXRhLnBvc2l0aW9uID0gUG9pbnRfMS5Qb2ludC5nZXRQb2ludChwb3MueCArIGNoYXJEYXRhLnhPZmZzZXQgKyAodGhpcy5fbGV0dGVyU3BhY2luZyAvIDIpLCBwb3MueSArIGNoYXJEYXRhLnlPZmZzZXQpO1xuICAgICAgICAgICAgY2hhcnMucHVzaChnbGlwdGhkYXRhKTtcbiAgICAgICAgICAgIHBvcy54ICs9IGNoYXJEYXRhLnhBZHZhbmNlICsgdGhpcy5fbGV0dGVyU3BhY2luZztcbiAgICAgICAgICAgIGxhc3RMaW5lV2lkdGggPSBwb3MueDtcbiAgICAgICAgICAgIG1heExpbmVIZWlnaHQgPSBNYXRoLm1heChtYXhMaW5lSGVpZ2h0LCAoY2hhckRhdGEueU9mZnNldCArIGNoYXJEYXRhLnRleHR1cmUuaGVpZ2h0KSk7XG4gICAgICAgICAgICBwcmV2Q2hhckNvZGUgPSBjaGFyQ29kZTtcbiAgICAgICAgICAgIGlmIChsYXN0QnJlYWtQb3MgIT09IC0xICYmIG1heFdpZHRoID4gMCAmJiBwb3MueCA+IG1heFdpZHRoKSB7XG4gICAgICAgICAgICAgICAgKytzcGFjZXNSZW1vdmVkO1xuICAgICAgICAgICAgICAgIFV0aWxzU2V0dGluZ3NfMS5VdGlsc1NldHRpbmdzLnJlbW92ZUl0ZW1zKGNoYXJzLCAxICsgbGFzdEJyZWFrUG9zIC0gc3BhY2VzUmVtb3ZlZCwgMSArIGkgLSBsYXN0QnJlYWtQb3MpO1xuICAgICAgICAgICAgICAgIGkgPSBsYXN0QnJlYWtQb3M7XG4gICAgICAgICAgICAgICAgbGFzdEJyZWFrUG9zID0gLTE7XG4gICAgICAgICAgICAgICAgbGluZVdpZHRocy5wdXNoKGxhc3RCcmVha1dpZHRoKTtcbiAgICAgICAgICAgICAgICBtYXhMaW5lV2lkdGggPSBNYXRoLm1heChtYXhMaW5lV2lkdGgsIGxhc3RCcmVha1dpZHRoKTtcbiAgICAgICAgICAgICAgICBsaW5lKys7XG4gICAgICAgICAgICAgICAgcG9zLnggPSAwO1xuICAgICAgICAgICAgICAgIHBvcy55ICs9IHRoaXMuYml0bWFwZm9udC5saW5lSGVpZ2h0O1xuICAgICAgICAgICAgICAgIHByZXZDaGFyQ29kZSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGxhc3RDaGFyID0gdGV4dC5jaGFyQXQodGV4dC5sZW5ndGggLSAxKTtcbiAgICAgICAgaWYgKGxhc3RDaGFyICE9PSAnXFxyJyAmJiBsYXN0Q2hhciAhPT0gJ1xcbicpIHtcbiAgICAgICAgICAgIGlmICgoLyg/OlxccykvKS50ZXN0KGxhc3RDaGFyKSkge1xuICAgICAgICAgICAgICAgIGxhc3RMaW5lV2lkdGggPSBsYXN0QnJlYWtXaWR0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxpbmVXaWR0aHMucHVzaChsYXN0TGluZVdpZHRoKTtcbiAgICAgICAgICAgIG1heExpbmVXaWR0aCA9IE1hdGgubWF4KG1heExpbmVXaWR0aCwgbGFzdExpbmVXaWR0aCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGxpbmVBbGlnbk9mZnNldHMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSQxID0gMDsgaSQxIDw9IGxpbmU7IGkkMSsrKSB7XG4gICAgICAgICAgICBsZXQgYWxpZ25PZmZzZXQgPSAwO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2ZvbnQuYWxpZ24gPT09ICdyaWdodCcpIHtcbiAgICAgICAgICAgICAgICBhbGlnbk9mZnNldCA9IG1heExpbmVXaWR0aCAtIGxpbmVXaWR0aHNbaSQxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX2ZvbnQuYWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgICAgICAgICAgYWxpZ25PZmZzZXQgPSAobWF4TGluZVdpZHRoIC0gbGluZVdpZHRoc1tpJDFdKSAvIDI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsaW5lQWxpZ25PZmZzZXRzLnB1c2goYWxpZ25PZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBsZW5DaGFycyA9IGNoYXJzLmxlbmd0aDtcbiAgICAgICAgbGV0IHRpbnQgPSB0aGlzLnRpbnQ7XG4gICAgICAgIGZvciAobGV0IGkkMiA9IDA7IGkkMiA8IGxlbkNoYXJzOyBpJDIrKykge1xuICAgICAgICAgICAgbGV0IGMgPSB0aGlzLl9nbHlwaHNbaSQyXTtcbiAgICAgICAgICAgIGlmIChjKSB7XG4gICAgICAgICAgICAgICAgYy50ZXh0dXJlID0gY2hhcnNbaSQyXS50ZXh0dXJlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYyA9IG5ldyBTcHJpdGVfMS5TcHJpdGUoY2hhcnNbaSQyXS50ZXh0dXJlKTtcbiAgICAgICAgICAgICAgICBjLnJvdW5kUGl4ZWxzID0gdGhpcy5yb3VuZFBpeGVscztcbiAgICAgICAgICAgICAgICB0aGlzLl9nbHlwaHMucHVzaChjKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZENoaWxkKGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYy5wb3NpdGlvbi54ID0gKGNoYXJzW2kkMl0ucG9zaXRpb24ueCArIGxpbmVBbGlnbk9mZnNldHNbY2hhcnNbaSQyXS5saW5lXSkgKiBzY2FsZTtcbiAgICAgICAgICAgIGMucG9zaXRpb24ueSA9IGNoYXJzW2kkMl0ucG9zaXRpb24ueSAqIHNjYWxlO1xuICAgICAgICAgICAgYy5zY2FsZS54ID0gYy5zY2FsZS55ID0gc2NhbGU7XG4gICAgICAgICAgICBjLnRpbnQgPSB0aW50O1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkkMyA9IGxlbkNoYXJzOyBpJDMgPCB0aGlzLl9nbHlwaHMubGVuZ3RoOyArK2kkMykge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVDaGlsZCh0aGlzLl9nbHlwaHNbaSQzXSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdGV4dFdpZHRoID0gbWF4TGluZVdpZHRoICogc2NhbGU7XG4gICAgICAgIHRoaXMuX3RleHRIZWlnaHQgPSAocG9zLnkgKyB0aGlzLmJpdG1hcGZvbnQubGluZUhlaWdodCkgKiBzY2FsZTtcbiAgICAgICAgaWYgKHRoaXMuYW5jaG9yLnggIT09IDAgfHwgdGhpcy5hbmNob3IueSAhPT0gMCkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSQ0ID0gMDsgaSQ0IDwgbGVuQ2hhcnM7IGkkNCsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZ2x5cGhzW2kkNF0ueCAtPSB0aGlzLl90ZXh0V2lkdGggKiB0aGlzLmFuY2hvci54O1xuICAgICAgICAgICAgICAgIHRoaXMuX2dseXBoc1tpJDRdLnkgLT0gdGhpcy5fdGV4dEhlaWdodCAqIHRoaXMuYW5jaG9yLnk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbWF4TGluZUhlaWdodCA9IG1heExpbmVIZWlnaHQgKiBzY2FsZTtcbiAgICAgICAgcG9zLnJlY3ljbGUoKTtcbiAgICB9XG4gICAgO1xuICAgIHVwZGF0ZVRyYW5zZm9ybSgpIHtcbiAgICAgICAgc3VwZXIudXBkYXRlVHJhbnNmb3JtKCk7XG4gICAgICAgIHRoaXMudmFsaWRhdGUoKTtcbiAgICB9XG4gICAgO1xuICAgIGdldExvY2FsQm91bmRzKCkge1xuICAgICAgICB0aGlzLnZhbGlkYXRlKCk7XG4gICAgICAgIHJldHVybiBzdXBlci5nZXRMb2NhbEJvdW5kcygpO1xuICAgIH1cbiAgICA7XG4gICAgdmFsaWRhdGUoKSB7XG4gICAgICAgIGlmICh0aGlzLmRpcnR5KSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVRleHQoKTtcbiAgICAgICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICA7XG4gICAgZ2V0IGZvbnRTaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZm9udC5mb250U2l6ZTtcbiAgICB9XG4gICAgO1xuICAgIHNldCBmb250U2l6ZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9mb250LmZvbnRTaXplID0gdmFsdWU7XG4gICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgIH1cbiAgICA7XG4gICAgZ2V0IHRpbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9mb250LnRpbnQ7XG4gICAgfVxuICAgIDtcbiAgICBzZXQgdGludCh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9mb250LnRpbnQgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgfVxuICAgIDtcbiAgICBnZXQgYWxpZ24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9mb250LmFsaWduO1xuICAgIH1cbiAgICA7XG4gICAgc2V0IGFsaWduKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2ZvbnQuYWxpZ24gPSB2YWx1ZSB8fCAnbGVmdCc7XG4gICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgIH1cbiAgICA7XG4gICAgZ2V0IGFuY2hvcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FuY2hvcjtcbiAgICB9XG4gICAgO1xuICAgIHNldCBhbmNob3IodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fYW5jaG9yLmNvcHlGcm9tKHZhbHVlKTtcbiAgICB9XG4gICAgO1xuICAgIGdldCB0ZXh0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdGV4dDtcbiAgICB9XG4gICAgO1xuICAgIHNldCB0ZXh0KHRleHQpIHtcbiAgICAgICAgaWYgKHRoaXMuX3RleHQgPT09IHRleHQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl90ZXh0ID0gdGV4dDtcbiAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgfVxuICAgIDtcbiAgICBnZXQgbWF4V2lkdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXhXaWR0aDtcbiAgICB9XG4gICAgO1xuICAgIHNldCBtYXhXaWR0aCh2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5fbWF4V2lkdGggPT09IHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbWF4V2lkdGggPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgfVxuICAgIDtcbiAgICBnZXQgbWF4TGluZUhlaWdodCgpIHtcbiAgICAgICAgdGhpcy52YWxpZGF0ZSgpO1xuICAgICAgICByZXR1cm4gdGhpcy5fbWF4TGluZUhlaWdodDtcbiAgICB9XG4gICAgO1xuICAgIGdldCB0ZXh0V2lkdGgoKSB7XG4gICAgICAgIHRoaXMudmFsaWRhdGUoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RleHRXaWR0aDtcbiAgICB9XG4gICAgO1xuICAgIGdldCBsZXR0ZXJTcGFjaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGV0dGVyU3BhY2luZztcbiAgICB9XG4gICAgO1xuICAgIHNldCBsZXR0ZXJTcGFjaW5nKHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLl9sZXR0ZXJTcGFjaW5nICE9PSB2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fbGV0dGVyU3BhY2luZyA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xuICAgIGdldCB0ZXh0SGVpZ2h0KCkge1xuICAgICAgICB0aGlzLnZhbGlkYXRlKCk7XG4gICAgICAgIHJldHVybiB0aGlzLl90ZXh0SGVpZ2h0O1xuICAgIH1cbiAgICA7XG59XG5leHBvcnRzLkJpdG1hcFRleHQgPSBCaXRtYXBUZXh0O1xuY2xhc3MgQml0bWFwRm9udFRyYWNrZXIgZXh0ZW5kcyBGbGFzaEJhc2VPYmplY3RfMS5GbGFzaEJhc2VPYmplY3Qge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLmZvbnRTaXplID0gMTY7XG4gICAgfVxufVxuY2xhc3MgRGF0YUdsaXB0aCB7XG59XG5jbGFzcyBGb250TWFwIHtcbn1cbmNsYXNzIEZvbnRDaGFyYWN0ZXJEYXRhIHtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY2xhc3MgQmxlbmRNb2Rlc1NldHRpbmdzIHtcbiAgICAvKipcbiogQ29ycmVjdHMgUGl4aUpTIGJsZW5kLCB0YWtlcyBwcmVtdWx0aXBsaWVkIGFscGhhIGludG8gYWNjb3VudFxuKlxuKiBAbWVtYmVyb2YgUElYSS51dGlsc1xuKiBAZnVuY3Rpb24gbWFwUHJlbXVsdGlwbGllZEJsZW5kTW9kZXNcbiogQHByaXZhdGVcbiogQHBhcmFtIHtBcnJheTxudW1iZXJbXT59IFthcnJheV0gLSBUaGUgYXJyYXkgdG8gb3V0cHV0IGludG8uXG4qIEByZXR1cm4ge0FycmF5PG51bWJlcltdPn0gTWFwcGVkIG1vZGVzLlxuKi9cbiAgICBzdGF0aWMgbWFwUHJlbXVsdGlwbGllZEJsZW5kTW9kZXMoKSB7XG4gICAgICAgIHZhciBwbSA9IFtdO1xuICAgICAgICB2YXIgbnBtID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMzI7IGkrKykge1xuICAgICAgICAgICAgcG1baV0gPSBpO1xuICAgICAgICAgICAgbnBtW2ldID0gaTtcbiAgICAgICAgfVxuICAgICAgICBwbVtCbGVuZE1vZGVzU2V0dGluZ3MuQkxFTkRfTU9ERVMuTk9STUFMX05QTV0gPSBCbGVuZE1vZGVzU2V0dGluZ3MuQkxFTkRfTU9ERVMuTk9STUFMO1xuICAgICAgICBwbVtCbGVuZE1vZGVzU2V0dGluZ3MuQkxFTkRfTU9ERVMuQUREX05QTV0gPSBCbGVuZE1vZGVzU2V0dGluZ3MuQkxFTkRfTU9ERVMuQUREO1xuICAgICAgICBwbVtCbGVuZE1vZGVzU2V0dGluZ3MuQkxFTkRfTU9ERVMuU0NSRUVOX05QTV0gPSBCbGVuZE1vZGVzU2V0dGluZ3MuQkxFTkRfTU9ERVMuU0NSRUVOO1xuICAgICAgICBucG1bQmxlbmRNb2Rlc1NldHRpbmdzLkJMRU5EX01PREVTLk5PUk1BTF0gPSBCbGVuZE1vZGVzU2V0dGluZ3MuQkxFTkRfTU9ERVMuTk9STUFMX05QTTtcbiAgICAgICAgbnBtW0JsZW5kTW9kZXNTZXR0aW5ncy5CTEVORF9NT0RFUy5BRERdID0gQmxlbmRNb2Rlc1NldHRpbmdzLkJMRU5EX01PREVTLkFERF9OUE07XG4gICAgICAgIG5wbVtCbGVuZE1vZGVzU2V0dGluZ3MuQkxFTkRfTU9ERVMuU0NSRUVOXSA9IEJsZW5kTW9kZXNTZXR0aW5ncy5CTEVORF9NT0RFUy5TQ1JFRU5fTlBNO1xuICAgICAgICB2YXIgYXJyYXkgPSBbXTtcbiAgICAgICAgYXJyYXkucHVzaChucG0pO1xuICAgICAgICBhcnJheS5wdXNoKHBtKTtcbiAgICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH1cbiAgICAvKipcbiogY2hhbmdlcyBibGVuZE1vZGUgYWNjb3JkaW5nIHRvIHRleHR1cmUgZm9ybWF0XG4qXG4qIEBtZW1iZXJvZiBQSVhJLnV0aWxzXG4qIEBmdW5jdGlvbiBjb3JyZWN0QmxlbmRNb2RlXG4qIEBwYXJhbSB7bnVtYmVyfSBibGVuZE1vZGUgc3VwcG9zZWQgYmxlbmQgbW9kZVxuKiBAcGFyYW0ge2Jvb2xlYW59IHByZW11bHRpcGxpZWQgIHdoZXRoZXIgc291cmNlIGlzIHByZW11bHRpcGxpZWRcbiogQHJldHVybnMge251bWJlcn0gdHJ1ZSBibGVuZCBtb2RlIGZvciB0aGlzIHRleHR1cmVcbiovXG4gICAgc3RhdGljIGNvcnJlY3RCbGVuZE1vZGUoYmxlbmRNb2RlLCBwcmVtdWx0aXBsaWVkKSB7XG4gICAgICAgIHJldHVybiBCbGVuZE1vZGVzU2V0dGluZ3MucHJlbXVsdGlwbHlCbGVuZE1vZGVbcHJlbXVsdGlwbGllZCA/IDEgOiAwXVtibGVuZE1vZGVdO1xuICAgIH1cbiAgICAvKipcbiogTWFwcyBnbCBibGVuZCBjb21iaW5hdGlvbnMgdG8gV2ViR0wuXG4qXG4qIEBtZW1iZXJvZiBQSVhJXG4qIEBmdW5jdGlvbiBtYXBXZWJHTEJsZW5kTW9kZXNUb1BpeGlcbiogQHByaXZhdGVcbiogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIC0gVGhlIHJlbmRlcmluZyBjb250ZXh0LlxuKiBAcGFyYW0ge251bWJlcltdW119IFthcnJheT1bXV0gLSBUaGUgYXJyYXkgdG8gb3V0cHV0IGludG8uXG4qIEByZXR1cm4ge251bWJlcltdW119IE1hcHBlZCBtb2Rlcy5cbiovXG4gICAgc3RhdGljIG1hcFdlYkdMQmxlbmRNb2Rlc1RvUGl4aShnbCwgYXJyYXkgPSBbXSkge1xuICAgICAgICAvLyBUT0RPIC0gcHJlbXVsdGlwbHkgYWxwaGEgd291bGQgYmUgZGlmZmVyZW50LlxuICAgICAgICAvLyBhZGQgYSBib29sZWFuIGZvciB0aGF0IVxuICAgICAgICBhcnJheVtCbGVuZE1vZGVzU2V0dGluZ3MuQkxFTkRfTU9ERVMuTk9STUFMXSA9IFtnbC5PTkUsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEFdO1xuICAgICAgICBhcnJheVtCbGVuZE1vZGVzU2V0dGluZ3MuQkxFTkRfTU9ERVMuQUREXSA9IFtnbC5PTkUsIGdsLkRTVF9BTFBIQSwgZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBXTtcbiAgICAgICAgYXJyYXlbQmxlbmRNb2Rlc1NldHRpbmdzLkJMRU5EX01PREVTLk1VTFRJUExZXSA9IFtnbC5EU1RfQ09MT1IsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEEsIGdsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQV07XG4gICAgICAgIGFycmF5W0JsZW5kTW9kZXNTZXR0aW5ncy5CTEVORF9NT0RFUy5TQ1JFRU5dID0gW2dsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19DT0xPUiwgZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBXTtcbiAgICAgICAgYXJyYXlbQmxlbmRNb2Rlc1NldHRpbmdzLkJMRU5EX01PREVTLk9WRVJMQVldID0gW2dsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQV07XG4gICAgICAgIGFycmF5W0JsZW5kTW9kZXNTZXR0aW5ncy5CTEVORF9NT0RFUy5EQVJLRU5dID0gW2dsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQV07XG4gICAgICAgIGFycmF5W0JsZW5kTW9kZXNTZXR0aW5ncy5CTEVORF9NT0RFUy5MSUdIVEVOXSA9IFtnbC5PTkUsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEFdO1xuICAgICAgICBhcnJheVtCbGVuZE1vZGVzU2V0dGluZ3MuQkxFTkRfTU9ERVMuQ09MT1JfRE9ER0VdID0gW2dsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQV07XG4gICAgICAgIGFycmF5W0JsZW5kTW9kZXNTZXR0aW5ncy5CTEVORF9NT0RFUy5DT0xPUl9CVVJOXSA9IFtnbC5PTkUsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEFdO1xuICAgICAgICBhcnJheVtCbGVuZE1vZGVzU2V0dGluZ3MuQkxFTkRfTU9ERVMuSEFSRF9MSUdIVF0gPSBbZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBXTtcbiAgICAgICAgYXJyYXlbQmxlbmRNb2Rlc1NldHRpbmdzLkJMRU5EX01PREVTLlNPRlRfTElHSFRdID0gW2dsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQV07XG4gICAgICAgIGFycmF5W0JsZW5kTW9kZXNTZXR0aW5ncy5CTEVORF9NT0RFUy5ESUZGRVJFTkNFXSA9IFtnbC5PTkUsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEFdO1xuICAgICAgICBhcnJheVtCbGVuZE1vZGVzU2V0dGluZ3MuQkxFTkRfTU9ERVMuRVhDTFVTSU9OXSA9IFtnbC5PTkUsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEFdO1xuICAgICAgICBhcnJheVtCbGVuZE1vZGVzU2V0dGluZ3MuQkxFTkRfTU9ERVMuSFVFXSA9IFtnbC5PTkUsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEFdO1xuICAgICAgICBhcnJheVtCbGVuZE1vZGVzU2V0dGluZ3MuQkxFTkRfTU9ERVMuU0FUVVJBVElPTl0gPSBbZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBXTtcbiAgICAgICAgYXJyYXlbQmxlbmRNb2Rlc1NldHRpbmdzLkJMRU5EX01PREVTLkNPTE9SXSA9IFtnbC5PTkUsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEFdO1xuICAgICAgICBhcnJheVtCbGVuZE1vZGVzU2V0dGluZ3MuQkxFTkRfTU9ERVMuTFVNSU5PU0lUWV0gPSBbZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBXTtcbiAgICAgICAgYXJyYXlbQmxlbmRNb2Rlc1NldHRpbmdzLkJMRU5EX01PREVTLk5PTkVdID0gWzAsIDBdO1xuICAgICAgICAvLyBub3QtcHJlbXVsdGlwbGllZCBibGVuZCBtb2Rlc1xuICAgICAgICBhcnJheVtCbGVuZE1vZGVzU2V0dGluZ3MuQkxFTkRfTU9ERVMuTk9STUFMX05QTV0gPSBbZ2wuU1JDX0FMUEhBLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBLCBnbC5PTkUsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEFdO1xuICAgICAgICBhcnJheVtCbGVuZE1vZGVzU2V0dGluZ3MuQkxFTkRfTU9ERVMuQUREX05QTV0gPSBbZ2wuU1JDX0FMUEhBLCBnbC5EU1RfQUxQSEEsIGdsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQV07XG4gICAgICAgIGFycmF5W0JsZW5kTW9kZXNTZXR0aW5ncy5CTEVORF9NT0RFUy5TQ1JFRU5fTlBNXSA9IFtnbC5TUkNfQUxQSEEsIGdsLk9ORV9NSU5VU19TUkNfQ09MT1IsIGdsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQV07XG4gICAgICAgIC8vIGNvbXBvc2l0ZSBvcGVyYXRpb25zXG4gICAgICAgIGFycmF5W0JsZW5kTW9kZXNTZXR0aW5ncy5CTEVORF9NT0RFUy5TUkNfSU5dID0gW2dsLkRTVF9BTFBIQSwgZ2wuWkVST107XG4gICAgICAgIGFycmF5W0JsZW5kTW9kZXNTZXR0aW5ncy5CTEVORF9NT0RFUy5TUkNfT1VUXSA9IFtnbC5PTkVfTUlOVVNfRFNUX0FMUEhBLCBnbC5aRVJPXTtcbiAgICAgICAgYXJyYXlbQmxlbmRNb2Rlc1NldHRpbmdzLkJMRU5EX01PREVTLlNSQ19BVE9QXSA9IFtnbC5EU1RfQUxQSEEsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEFdO1xuICAgICAgICBhcnJheVtCbGVuZE1vZGVzU2V0dGluZ3MuQkxFTkRfTU9ERVMuRFNUX09WRVJdID0gW2dsLk9ORV9NSU5VU19EU1RfQUxQSEEsIGdsLk9ORV07XG4gICAgICAgIGFycmF5W0JsZW5kTW9kZXNTZXR0aW5ncy5CTEVORF9NT0RFUy5EU1RfSU5dID0gW2dsLlpFUk8sIGdsLlNSQ19BTFBIQV07XG4gICAgICAgIGFycmF5W0JsZW5kTW9kZXNTZXR0aW5ncy5CTEVORF9NT0RFUy5EU1RfT1VUXSA9IFtnbC5aRVJPLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBXTtcbiAgICAgICAgYXJyYXlbQmxlbmRNb2Rlc1NldHRpbmdzLkJMRU5EX01PREVTLkRTVF9BVE9QXSA9IFtnbC5PTkVfTUlOVVNfRFNUX0FMUEhBLCBnbC5TUkNfQUxQSEFdO1xuICAgICAgICAvLyBTVUJUUkFDVCBmcm9tIGZsYXNoXG4gICAgICAgIGFycmF5W0JsZW5kTW9kZXNTZXR0aW5ncy5CTEVORF9NT0RFUy5TVUJUUkFDVF0gPSBbZ2wuT05FLCBnbC5PTkUsIGdsLk9ORSwgZ2wuT05FLCBnbC5GVU5DX1JFVkVSU0VfU1VCVFJBQ1QsIGdsLkZVTkNfQUREXTtcbiAgICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH1cbn1cbi8qKlxuKiBWYXJpb3VzIGJsZW5kIG1vZGVzIHN1cHBvcnRlZCBieSBQSVhJLlxuKlxuKiBJTVBPUlRBTlQgLSBUaGUgV2ViR0wgcmVuZGVyZXIgb25seSBzdXBwb3J0cyB0aGUgTk9STUFMLCBBREQsIE1VTFRJUExZIGFuZCBTQ1JFRU4gYmxlbmQgbW9kZXMuXG4qIEFueXRoaW5nIGVsc2Ugd2lsbCBzaWxlbnRseSBhY3QgbGlrZSBOT1JNQUwuXG4qXG4qIEBtZW1iZXJvZiBQSVhJXG4qIEBuYW1lIEJMRU5EX01PREVTXG4qIEBlbnVtIHtudW1iZXJ9XG4qIEBwcm9wZXJ0eSB7bnVtYmVyfSBOT1JNQUxcbiogQHByb3BlcnR5IHtudW1iZXJ9IEFERFxuKiBAcHJvcGVydHkge251bWJlcn0gTVVMVElQTFlcbiogQHByb3BlcnR5IHtudW1iZXJ9IFNDUkVFTlxuKiBAcHJvcGVydHkge251bWJlcn0gT1ZFUkxBWVxuKiBAcHJvcGVydHkge251bWJlcn0gREFSS0VOXG4qIEBwcm9wZXJ0eSB7bnVtYmVyfSBMSUdIVEVOXG4qIEBwcm9wZXJ0eSB7bnVtYmVyfSBDT0xPUl9ET0RHRVxuKiBAcHJvcGVydHkge251bWJlcn0gQ09MT1JfQlVSTlxuKiBAcHJvcGVydHkge251bWJlcn0gSEFSRF9MSUdIVFxuKiBAcHJvcGVydHkge251bWJlcn0gU09GVF9MSUdIVFxuKiBAcHJvcGVydHkge251bWJlcn0gRElGRkVSRU5DRVxuKiBAcHJvcGVydHkge251bWJlcn0gRVhDTFVTSU9OXG4qIEBwcm9wZXJ0eSB7bnVtYmVyfSBIVUVcbiogQHByb3BlcnR5IHtudW1iZXJ9IFNBVFVSQVRJT05cbiogQHByb3BlcnR5IHtudW1iZXJ9IENPTE9SXG4qIEBwcm9wZXJ0eSB7bnVtYmVyfSBMVU1JTk9TSVRZXG4qIEBwcm9wZXJ0eSB7bnVtYmVyfSBOT1JNQUxfTlBNXG4qIEBwcm9wZXJ0eSB7bnVtYmVyfSBBRERfTlBNXG4qIEBwcm9wZXJ0eSB7bnVtYmVyfSBTQ1JFRU5fTlBNXG4qIEBwcm9wZXJ0eSB7bnVtYmVyfSBOT05FXG4qIEBwcm9wZXJ0eSB7bnVtYmVyfSBTUkNfSU5cbiogQHByb3BlcnR5IHtudW1iZXJ9IFNSQ19PVVRcbiogQHByb3BlcnR5IHtudW1iZXJ9IFNSQ19BVE9QXG4qIEBwcm9wZXJ0eSB7bnVtYmVyfSBEU1RfT1ZFUlxuKiBAcHJvcGVydHkge251bWJlcn0gRFNUX0lOXG4qIEBwcm9wZXJ0eSB7bnVtYmVyfSBEU1RfT1VUXG4qIEBwcm9wZXJ0eSB7bnVtYmVyfSBEU1RfQVRPUFxuKiBAcHJvcGVydHkge251bWJlcn0gU1VCVFJBQ1RcbiogQHByb3BlcnR5IHtudW1iZXJ9IFNSQ19PVkVSXG4qIEBwcm9wZXJ0eSB7bnVtYmVyfSBFUkFTRVxuKi9cbkJsZW5kTW9kZXNTZXR0aW5ncy5CTEVORF9NT0RFUyA9IHtcbiAgICBOT1JNQUw6IDAsXG4gICAgQUREOiAxLFxuICAgIE1VTFRJUExZOiAyLFxuICAgIFNDUkVFTjogMyxcbiAgICBPVkVSTEFZOiA0LFxuICAgIERBUktFTjogNSxcbiAgICBMSUdIVEVOOiA2LFxuICAgIENPTE9SX0RPREdFOiA3LFxuICAgIENPTE9SX0JVUk46IDgsXG4gICAgSEFSRF9MSUdIVDogOSxcbiAgICBTT0ZUX0xJR0hUOiAxMCxcbiAgICBESUZGRVJFTkNFOiAxMSxcbiAgICBFWENMVVNJT046IDEyLFxuICAgIEhVRTogMTMsXG4gICAgU0FUVVJBVElPTjogMTQsXG4gICAgQ09MT1I6IDE1LFxuICAgIExVTUlOT1NJVFk6IDE2LFxuICAgIE5PUk1BTF9OUE06IDE3LFxuICAgIEFERF9OUE06IDE4LFxuICAgIFNDUkVFTl9OUE06IDE5LFxuICAgIE5PTkU6IDIwLFxuICAgIFNSQ19PVkVSOiAwLFxuICAgIFNSQ19JTjogMjEsXG4gICAgU1JDX09VVDogMjIsXG4gICAgU1JDX0FUT1A6IDIzLFxuICAgIERTVF9PVkVSOiAyNCxcbiAgICBEU1RfSU46IDI1LFxuICAgIERTVF9PVVQ6IDI2LFxuICAgIERTVF9BVE9QOiAyNyxcbiAgICBFUkFTRTogMjYsXG4gICAgU1VCVFJBQ1Q6IDI4LFxufTtcbi8qKlxuKiBtYXBzIHByZW11bHRpcGx5IGZsYWcgYW5kIGJsZW5kTW9kZSB0byBhZGp1c3RlZCBibGVuZE1vZGVcbiogQG1lbWJlcm9mIFBJWEkudXRpbHNcbiogQGNvbnN0IHByZW11bHRpcGx5QmxlbmRNb2RlXG4qIEB0eXBlIHtBcnJheTxudW1iZXJbXT59XG4qL1xuQmxlbmRNb2Rlc1NldHRpbmdzLnByZW11bHRpcGx5QmxlbmRNb2RlID0gQmxlbmRNb2Rlc1NldHRpbmdzLm1hcFByZW11bHRpcGxpZWRCbGVuZE1vZGVzKCk7XG5leHBvcnRzLkJsZW5kTW9kZXNTZXR0aW5ncyA9IEJsZW5kTW9kZXNTZXR0aW5ncztcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgRmlsdGVyXzEgPSByZXF1aXJlKFwiLi9GaWx0ZXJcIik7XG5jb25zdCBCbHVyRmlsdGVyUGFzc18xID0gcmVxdWlyZShcIi4vQmx1ckZpbHRlclBhc3NcIik7XG5jb25zdCBEaXNwbGF5U2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL0Rpc3BsYXlTZXR0aW5nc1wiKTtcbmNsYXNzIEJsdXJGaWx0ZXIgZXh0ZW5kcyBGaWx0ZXJfMS5GaWx0ZXIge1xuICAgIGNvbnN0cnVjdG9yKHN0cmVuZ3RoID0gMSwgcXVhbGl0eSA9IDEsIHJlc29sdXRpb24gPSAxLCBrZXJuZWxTaXplID0gNSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmJsdXJYRmlsdGVyID0gbmV3IEJsdXJGaWx0ZXJQYXNzXzEuQmx1ckZpbHRlclBhc3ModHJ1ZSwgc3RyZW5ndGgsIHF1YWxpdHksIHJlc29sdXRpb24sIGtlcm5lbFNpemUpO1xuICAgICAgICB0aGlzLmJsdXJZRmlsdGVyID0gbmV3IEJsdXJGaWx0ZXJQYXNzXzEuQmx1ckZpbHRlclBhc3MoZmFsc2UsIHN0cmVuZ3RoLCBxdWFsaXR5LCByZXNvbHV0aW9uLCBrZXJuZWxTaXplKTtcbiAgICAgICAgdGhpcy5yZXNvbHV0aW9uID0gcmVzb2x1dGlvbiB8fCBEaXNwbGF5U2V0dGluZ3NfMS5EaXNwbGF5U2V0dGluZ3MuUkVTT0xVVElPTjtcbiAgICAgICAgdGhpcy5xdWFsaXR5ID0gcXVhbGl0eSB8fCA0O1xuICAgICAgICB0aGlzLmJsdXIgPSBzdHJlbmd0aCB8fCA4O1xuICAgICAgICB0aGlzLnJlcGVhdEVkZ2VQaXhlbHMgPSBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXBwbGllcyB0aGUgZmlsdGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQSVhJLnN5c3RlbXMuRmlsdGVyU3lzdGVtfSBmaWx0ZXJNYW5hZ2VyIC0gVGhlIG1hbmFnZXIuXG4gICAgICogQHBhcmFtIHtQSVhJLlJlbmRlclRleHR1cmV9IGlucHV0IC0gVGhlIGlucHV0IHRhcmdldC5cbiAgICAgKiBAcGFyYW0ge1BJWEkuUmVuZGVyVGV4dHVyZX0gb3V0cHV0IC0gVGhlIG91dHB1dCB0YXJnZXQuXG4gICAgICovXG4gICAgYXBwbHkoZmlsdGVyTWFuYWdlciwgaW5wdXQsIG91dHB1dCwgY2xlYXIpIHtcbiAgICAgICAgdmFyIHhTdHJlbmd0aCA9IE1hdGguYWJzKHRoaXMuYmx1clhGaWx0ZXIuc3RyZW5ndGgpO1xuICAgICAgICB2YXIgeVN0cmVuZ3RoID0gTWF0aC5hYnModGhpcy5ibHVyWUZpbHRlci5zdHJlbmd0aCk7XG4gICAgICAgIGlmICh4U3RyZW5ndGggJiYgeVN0cmVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgcmVuZGVyVGFyZ2V0ID0gZmlsdGVyTWFuYWdlci5nZXRGaWx0ZXJUZXh0dXJlKCk7XG4gICAgICAgICAgICB0aGlzLmJsdXJYRmlsdGVyLmFwcGx5KGZpbHRlck1hbmFnZXIsIGlucHV0LCByZW5kZXJUYXJnZXQsIHRydWUpO1xuICAgICAgICAgICAgdGhpcy5ibHVyWUZpbHRlci5hcHBseShmaWx0ZXJNYW5hZ2VyLCByZW5kZXJUYXJnZXQsIG91dHB1dCwgY2xlYXIpO1xuICAgICAgICAgICAgZmlsdGVyTWFuYWdlci5yZXR1cm5GaWx0ZXJUZXh0dXJlKHJlbmRlclRhcmdldCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoeVN0cmVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLmJsdXJZRmlsdGVyLmFwcGx5KGZpbHRlck1hbmFnZXIsIGlucHV0LCBvdXRwdXQsIGNsZWFyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYmx1clhGaWx0ZXIuYXBwbHkoZmlsdGVyTWFuYWdlciwgaW5wdXQsIG91dHB1dCwgY2xlYXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIDtcbiAgICB1cGRhdGVQYWRkaW5nKCkge1xuICAgICAgICBpZiAodGhpcy5fcmVwZWF0RWRnZVBpeGVscykge1xuICAgICAgICAgICAgdGhpcy5wYWRkaW5nID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucGFkZGluZyA9IE1hdGgubWF4KE1hdGguYWJzKHRoaXMuYmx1clhGaWx0ZXIuc3RyZW5ndGgpLCBNYXRoLmFicyh0aGlzLmJsdXJZRmlsdGVyLnN0cmVuZ3RoKSkgKiAyO1xuICAgICAgICB9XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBzdHJlbmd0aCBvZiBib3RoIHRoZSBibHVyWCBhbmQgYmx1clkgcHJvcGVydGllcyBzaW11bHRhbmVvdXNseVxuICAgICAqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IDJcbiAgICAgKi9cbiAgICBnZXQgYmx1cigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmx1clhGaWx0ZXIuYmx1cjtcbiAgICB9XG4gICAgO1xuICAgIHNldCBibHVyKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuYmx1clhGaWx0ZXIuYmx1ciA9IHRoaXMuYmx1cllGaWx0ZXIuYmx1ciA9IHZhbHVlO1xuICAgICAgICB0aGlzLnVwZGF0ZVBhZGRpbmcoKTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIG51bWJlciBvZiBwYXNzZXMgZm9yIGJsdXIuIE1vcmUgcGFzc2VzIG1lYW5zIGhpZ2hlciBxdWFpbGl0eSBibHVyaW5nLlxuICAgICAqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IDFcbiAgICAgKi9cbiAgICBnZXQgcXVhbGl0eSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmx1clhGaWx0ZXIucXVhbGl0eTtcbiAgICB9XG4gICAgO1xuICAgIHNldCBxdWFsaXR5KHZhbHVlKSB7XG4gICAgICAgIHRoaXMuYmx1clhGaWx0ZXIucXVhbGl0eSA9IHRoaXMuYmx1cllGaWx0ZXIucXVhbGl0eSA9IHZhbHVlO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgc3RyZW5ndGggb2YgdGhlIGJsdXJYIHByb3BlcnR5XG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMlxuICAgICAqL1xuICAgIGdldCBibHVyWCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmx1clhGaWx0ZXIuYmx1cjtcbiAgICB9XG4gICAgO1xuICAgIHNldCBibHVyWCh2YWx1ZSkge1xuICAgICAgICB0aGlzLmJsdXJYRmlsdGVyLmJsdXIgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy51cGRhdGVQYWRkaW5nKCk7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBzdHJlbmd0aCBvZiB0aGUgYmx1clkgcHJvcGVydHlcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAyXG4gICAgICovXG4gICAgZ2V0IGJsdXJZKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ibHVyWUZpbHRlci5ibHVyO1xuICAgIH1cbiAgICA7XG4gICAgc2V0IGJsdXJZKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuYmx1cllGaWx0ZXIuYmx1ciA9IHZhbHVlO1xuICAgICAgICB0aGlzLnVwZGF0ZVBhZGRpbmcoKTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGJsZW5kbW9kZSBvZiB0aGUgZmlsdGVyXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICogQGRlZmF1bHQgUElYSS5CTEVORF9NT0RFUy5OT1JNQUxcbiAgICAgKi9cbiAgICBnZXQgYmxlbmRNb2RlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ibHVyWUZpbHRlci5ibGVuZE1vZGU7XG4gICAgfVxuICAgIDtcbiAgICBzZXQgYmxlbmRNb2RlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuYmx1cllGaWx0ZXIuYmxlbmRNb2RlID0gdmFsdWU7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBJZiBzZXQgdG8gdHJ1ZSB0aGUgZWRnZSBvZiB0aGUgdGFyZ2V0IHdpbGwgYmUgY2xhbXBlZFxuICAgICAqXG4gICAgICogQG1lbWJlciB7Ym9vbH1cbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAqL1xuICAgIGdldCByZXBlYXRFZGdlUGl4ZWxzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVwZWF0RWRnZVBpeGVscztcbiAgICB9XG4gICAgO1xuICAgIHNldCByZXBlYXRFZGdlUGl4ZWxzKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX3JlcGVhdEVkZ2VQaXhlbHMgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy51cGRhdGVQYWRkaW5nKCk7XG4gICAgfVxuICAgIDtcbn1cbmV4cG9ydHMuQmx1ckZpbHRlciA9IEJsdXJGaWx0ZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IEZpbHRlcl8xID0gcmVxdWlyZShcIi4vRmlsdGVyXCIpO1xuY29uc3QgRGlzcGxheVNldHRpbmdzXzEgPSByZXF1aXJlKFwiLi9EaXNwbGF5U2V0dGluZ3NcIik7XG5jbGFzcyBCbHVyRmlsdGVyUGFzcyBleHRlbmRzIEZpbHRlcl8xLkZpbHRlciB7XG4gICAgY29uc3RydWN0b3IoaG9yaXpvbnRhbCwgc3RyZW5ndGgsIHF1YWxpdHksIHJlc29sdXRpb24sIGtlcm5lbFNpemUpIHtcbiAgICAgICAga2VybmVsU2l6ZSA9IGtlcm5lbFNpemUgfHwgNTtcbiAgICAgICAgdmFyIHZlcnRTcmMgPSBCbHVyRmlsdGVyUGFzcy5nZW5lcmF0ZUJsdXJWZXJ0U291cmNlKGtlcm5lbFNpemUsIGhvcml6b250YWwpO1xuICAgICAgICB2YXIgZnJhZ1NyYyA9IEJsdXJGaWx0ZXJQYXNzLmdlbmVyYXRlQmx1ckZyYWdTb3VyY2Uoa2VybmVsU2l6ZSk7XG4gICAgICAgIHN1cGVyKHZlcnRTcmMsIGZyYWdTcmMpO1xuICAgICAgICB0aGlzLmhvcml6b250YWwgPSBob3Jpem9udGFsO1xuICAgICAgICB0aGlzLnJlc29sdXRpb24gPSByZXNvbHV0aW9uIHx8IERpc3BsYXlTZXR0aW5nc18xLkRpc3BsYXlTZXR0aW5ncy5SRVNPTFVUSU9OO1xuICAgICAgICB0aGlzLl9xdWFsaXR5ID0gMDtcbiAgICAgICAgdGhpcy5xdWFsaXR5ID0gcXVhbGl0eSB8fCA0O1xuICAgICAgICB0aGlzLmJsdXIgPSBzdHJlbmd0aCB8fCA4O1xuICAgIH1cbiAgICBzdGF0aWMgZ2VuZXJhdGVCbHVyRnJhZ1NvdXJjZShrZXJuZWxTaXplKSB7XG4gICAgICAgIHZhciBrZXJuZWwgPSBCbHVyRmlsdGVyUGFzcy5HQVVTU0lBTl9WQUxVRVNba2VybmVsU2l6ZV07XG4gICAgICAgIHZhciBoYWxmTGVuZ3RoID0ga2VybmVsLmxlbmd0aDtcbiAgICAgICAgdmFyIGZyYWdTb3VyY2UgPSBCbHVyRmlsdGVyUGFzcy5mcmFnVGVtcGxhdGUkMjtcbiAgICAgICAgdmFyIGJsdXJMb29wID0gJyc7XG4gICAgICAgIHZhciB0ZW1wbGF0ZSA9ICdnbF9GcmFnQ29sb3IgKz0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2Qmx1clRleENvb3Jkc1slaW5kZXglXSkgKiAldmFsdWUlOyc7XG4gICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXJuZWxTaXplOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBibHVyID0gdGVtcGxhdGUucmVwbGFjZSgnJWluZGV4JScsIGkudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICB2YWx1ZSA9IGk7XG4gICAgICAgICAgICBpZiAoaSA+PSBoYWxmTGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBrZXJuZWxTaXplIC0gaSAtIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBibHVyID0gYmx1ci5yZXBsYWNlKCcldmFsdWUlJywga2VybmVsW3ZhbHVlXSk7XG4gICAgICAgICAgICBibHVyTG9vcCArPSBibHVyO1xuICAgICAgICAgICAgYmx1ckxvb3AgKz0gJ1xcbic7XG4gICAgICAgIH1cbiAgICAgICAgZnJhZ1NvdXJjZSA9IGZyYWdTb3VyY2UucmVwbGFjZSgnJWJsdXIlJywgYmx1ckxvb3ApO1xuICAgICAgICBmcmFnU291cmNlID0gZnJhZ1NvdXJjZS5yZXBsYWNlKCclc2l6ZSUnLCBrZXJuZWxTaXplKTtcbiAgICAgICAgcmV0dXJuIGZyYWdTb3VyY2U7XG4gICAgfVxuICAgIHN0YXRpYyBnZW5lcmF0ZUJsdXJWZXJ0U291cmNlKGtlcm5lbFNpemUsIHgpIHtcbiAgICAgICAgdmFyIGhhbGZMZW5ndGggPSBNYXRoLmNlaWwoa2VybmVsU2l6ZSAvIDIpO1xuICAgICAgICB2YXIgdmVydFNvdXJjZSA9IEJsdXJGaWx0ZXJQYXNzLnZlcnRUZW1wbGF0ZTtcbiAgICAgICAgdmFyIGJsdXJMb29wID0gJyc7XG4gICAgICAgIHZhciB0ZW1wbGF0ZTtcbiAgICAgICAgLy8gbGV0IHZhbHVlO1xuICAgICAgICBpZiAoeCkge1xuICAgICAgICAgICAgdGVtcGxhdGUgPSAndkJsdXJUZXhDb29yZHNbJWluZGV4JV0gPSAgdGV4dHVyZUNvb3JkICsgdmVjMiglc2FtcGxlSW5kZXglICogc3RyZW5ndGgsIDAuMCk7JztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRlbXBsYXRlID0gJ3ZCbHVyVGV4Q29vcmRzWyVpbmRleCVdID0gIHRleHR1cmVDb29yZCArIHZlYzIoMC4wLCAlc2FtcGxlSW5kZXglICogc3RyZW5ndGgpOyc7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXJuZWxTaXplOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBibHVyID0gdGVtcGxhdGUucmVwbGFjZSgnJWluZGV4JScsIGkpO1xuICAgICAgICAgICAgLy8gdmFsdWUgPSBpO1xuICAgICAgICAgICAgLy8gaWYoaSA+PSBoYWxmTGVuZ3RoKVxuICAgICAgICAgICAgLy8ge1xuICAgICAgICAgICAgLy8gICAgIHZhbHVlID0ga2VybmVsU2l6ZSAtIGkgLSAxO1xuICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgYmx1ciA9IGJsdXIucmVwbGFjZSgnJXNhbXBsZUluZGV4JScsICgoaSAtIChoYWxmTGVuZ3RoIC0gMSkpICsgXCIuMFwiKSk7XG4gICAgICAgICAgICBibHVyTG9vcCArPSBibHVyO1xuICAgICAgICAgICAgYmx1ckxvb3AgKz0gJ1xcbic7XG4gICAgICAgIH1cbiAgICAgICAgdmVydFNvdXJjZSA9IHZlcnRTb3VyY2UucmVwbGFjZSgnJWJsdXIlJywgYmx1ckxvb3ApO1xuICAgICAgICB2ZXJ0U291cmNlID0gdmVydFNvdXJjZS5yZXBsYWNlKCclc2l6ZSUnLCBrZXJuZWxTaXplKTtcbiAgICAgICAgcmV0dXJuIHZlcnRTb3VyY2U7XG4gICAgfVxuICAgIGFwcGx5KGZpbHRlck1hbmFnZXIsIGlucHV0LCBvdXRwdXQsIGNsZWFyKSB7XG4gICAgICAgIGlmIChvdXRwdXQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmhvcml6b250YWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVuaWZvcm1zLnN0cmVuZ3RoID0gKDEgLyBvdXRwdXQud2lkdGgpICogKG91dHB1dC53aWR0aCAvIGlucHV0LndpZHRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMudW5pZm9ybXMuc3RyZW5ndGggPSAoMSAvIG91dHB1dC5oZWlnaHQpICogKG91dHB1dC5oZWlnaHQgLyBpbnB1dC5oZWlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMuaG9yaXpvbnRhbCkgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVuaWZvcm1zLnN0cmVuZ3RoID0gKDEgLyBmaWx0ZXJNYW5hZ2VyLnJlbmRlcmVyLndpZHRoKSAqIChmaWx0ZXJNYW5hZ2VyLnJlbmRlcmVyLndpZHRoIC8gaW5wdXQud2lkdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy51bmlmb3Jtcy5zdHJlbmd0aCA9ICgxIC8gZmlsdGVyTWFuYWdlci5yZW5kZXJlci5oZWlnaHQpICogKGZpbHRlck1hbmFnZXIucmVuZGVyZXIuaGVpZ2h0IC8gaW5wdXQuaGVpZ2h0KTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHNjcmVlbiBzcGFjZSFcbiAgICAgICAgdGhpcy51bmlmb3Jtcy5zdHJlbmd0aCAqPSB0aGlzLnN0cmVuZ3RoO1xuICAgICAgICB0aGlzLnVuaWZvcm1zLnN0cmVuZ3RoIC89IHRoaXMucGFzc2VzO1xuICAgICAgICBpZiAodGhpcy5wYXNzZXMgPT09IDEpIHtcbiAgICAgICAgICAgIGZpbHRlck1hbmFnZXIuYXBwbHlGaWx0ZXIodGhpcywgaW5wdXQsIG91dHB1dCwgY2xlYXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIHJlbmRlclRhcmdldCA9IGZpbHRlck1hbmFnZXIuZ2V0RmlsdGVyVGV4dHVyZSgpO1xuICAgICAgICAgICAgdmFyIHJlbmRlcmVyID0gZmlsdGVyTWFuYWdlci5yZW5kZXJlcjtcbiAgICAgICAgICAgIHZhciBmbGlwID0gaW5wdXQ7XG4gICAgICAgICAgICB2YXIgZmxvcCA9IHJlbmRlclRhcmdldDtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUuYmxlbmQgPSBmYWxzZTtcbiAgICAgICAgICAgIGZpbHRlck1hbmFnZXIuYXBwbHlGaWx0ZXIodGhpcywgZmxpcCwgZmxvcCwgZmFsc2UpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCB0aGlzLnBhc3NlcyAtIDE7IGkrKykge1xuICAgICAgICAgICAgICAgIHJlbmRlcmVyLnJlbmRlclRleHR1cmUuYmluZChmbGlwLCBmbGlwLmZpbHRlckZyYW1lKTtcbiAgICAgICAgICAgICAgICB0aGlzLnVuaWZvcm1zLnVTYW1wbGVyID0gZmxvcDtcbiAgICAgICAgICAgICAgICB2YXIgdGVtcCA9IGZsb3A7XG4gICAgICAgICAgICAgICAgZmxvcCA9IGZsaXA7XG4gICAgICAgICAgICAgICAgZmxpcCA9IHRlbXA7XG4gICAgICAgICAgICAgICAgcmVuZGVyZXIuc2hhZGVyLmJpbmQodGhpcyk7XG4gICAgICAgICAgICAgICAgcmVuZGVyZXIuZ2VvbWV0cnkuZHJhdyg1KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc3RhdGUuYmxlbmQgPSB0cnVlO1xuICAgICAgICAgICAgZmlsdGVyTWFuYWdlci5hcHBseUZpbHRlcih0aGlzLCBmbG9wLCBvdXRwdXQsIGNsZWFyKTtcbiAgICAgICAgICAgIGZpbHRlck1hbmFnZXIucmV0dXJuRmlsdGVyVGV4dHVyZShyZW5kZXJUYXJnZXQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBzdHJlbmd0aCBvZiBib3RoIHRoZSBibHVyLlxuICAgICAqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IDE2XG4gICAgICovXG4gICAgZ2V0IGJsdXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0cmVuZ3RoO1xuICAgIH1cbiAgICA7XG4gICAgc2V0IGJsdXIodmFsdWUpIHtcbiAgICAgICAgdGhpcy5wYWRkaW5nID0gMSArIChNYXRoLmFicyh2YWx1ZSkgKiAyKTtcbiAgICAgICAgdGhpcy5zdHJlbmd0aCA9IHZhbHVlO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgcXVhbGl0eSBvZiB0aGUgYmx1ciBieSBtb2RpZnlpbmcgdGhlIG51bWJlciBvZiBwYXNzZXMuIE1vcmUgcGFzc2VzIG1lYW5zIGhpZ2hlclxuICAgICAqIHF1YWlsaXR5IGJsdXJpbmcgYnV0IHRoZSBsb3dlciB0aGUgcGVyZm9ybWFuY2UuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICogQGRlZmF1bHQgNFxuICAgICAqL1xuICAgIGdldCBxdWFsaXR5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcXVhbGl0eTtcbiAgICB9XG4gICAgO1xuICAgIHNldCBxdWFsaXR5KHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX3F1YWxpdHkgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5wYXNzZXMgPSB2YWx1ZTtcbiAgICB9XG4gICAgO1xufVxuQmx1ckZpbHRlclBhc3MuR0FVU1NJQU5fVkFMVUVTID0ge1xuICAgIDU6IFswLjE1MzM4OCwgMC4yMjE0NjEsIDAuMjUwMzAxXSxcbiAgICA3OiBbMC4wNzEzMDMsIDAuMTMxNTE0LCAwLjE4OTg3OSwgMC4yMTQ2MDddLFxuICAgIDk6IFswLjAyODUzMiwgMC4wNjcyMzQsIDAuMTI0MDA5LCAwLjE3OTA0NCwgMC4yMDIzNl0sXG4gICAgMTE6IFswLjAwOTMsIDAuMDI4MDAyLCAwLjA2NTk4NCwgMC4xMjE3MDMsIDAuMTc1NzEzLCAwLjE5ODU5Nl0sXG4gICAgMTM6IFswLjAwMjQwNiwgMC4wMDkyNTUsIDAuMDI3ODY3LCAwLjA2NTY2NiwgMC4xMjExMTcsIDAuMTc0ODY4LCAwLjE5NzY0MV0sXG4gICAgMTU6IFswLjAwMDQ4OSwgMC4wMDI0MDMsIDAuMDA5MjQ2LCAwLjAyNzg0LCAwLjA2NTYwMiwgMC4xMjA5OTksIDAuMTc0Njk3LCAwLjE5NzQ0OF0sXG59O1xuQmx1ckZpbHRlclBhc3MudmVydFRlbXBsYXRlID0gXCJcXG4gICAgYXR0cmlidXRlIHZlYzIgYVZlcnRleFBvc2l0aW9uO1xcblxcbiAgICB1bmlmb3JtIG1hdDMgcHJvamVjdGlvbk1hdHJpeDtcXG5cXG4gICAgdW5pZm9ybSBmbG9hdCBzdHJlbmd0aDtcXG5cXG4gICAgdmFyeWluZyB2ZWMyIHZCbHVyVGV4Q29vcmRzWyVzaXplJV07XFxuXFxuICAgIHVuaWZvcm0gdmVjNCBpbnB1dFNpemU7XFxuICAgIHVuaWZvcm0gdmVjNCBvdXRwdXRGcmFtZTtcXG4gICAgXFxuICAgIHZlYzQgZmlsdGVyVmVydGV4UG9zaXRpb24oIHZvaWQgKVxcbiAgICB7XFxuICAgICAgICB2ZWMyIHBvc2l0aW9uID0gYVZlcnRleFBvc2l0aW9uICogbWF4KG91dHB1dEZyYW1lLnp3LCB2ZWMyKDAuKSkgKyBvdXRwdXRGcmFtZS54eTtcXG4gICAgXFxuICAgICAgICByZXR1cm4gdmVjNCgocHJvamVjdGlvbk1hdHJpeCAqIHZlYzMocG9zaXRpb24sIDEuMCkpLnh5LCAwLjAsIDEuMCk7XFxuICAgIH1cXG4gICAgXFxuICAgIHZlYzIgZmlsdGVyVGV4dHVyZUNvb3JkKCB2b2lkIClcXG4gICAge1xcbiAgICAgICAgcmV0dXJuIGFWZXJ0ZXhQb3NpdGlvbiAqIChvdXRwdXRGcmFtZS56dyAqIGlucHV0U2l6ZS56dyk7XFxuICAgIH1cXG5cXG4gICAgdm9pZCBtYWluKHZvaWQpXFxuICAgIHtcXG4gICAgICAgIGdsX1Bvc2l0aW9uID0gZmlsdGVyVmVydGV4UG9zaXRpb24oKTtcXG5cXG4gICAgICAgIHZlYzIgdGV4dHVyZUNvb3JkID0gZmlsdGVyVGV4dHVyZUNvb3JkKCk7XFxuICAgICAgICAlYmx1ciVcXG4gICAgfVwiO1xuQmx1ckZpbHRlclBhc3MuZnJhZ1RlbXBsYXRlJDIgPSBbXG4gICAgJ3ZhcnlpbmcgdmVjMiB2Qmx1clRleENvb3Jkc1slc2l6ZSVdOycsXG4gICAgJ3VuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyOycsXG4gICAgJ3ZvaWQgbWFpbih2b2lkKScsXG4gICAgJ3snLFxuICAgICcgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCgwLjApOycsXG4gICAgJyAgICAlYmx1ciUnLFxuICAgICd9J1xuXS5qb2luKCdcXG4nKTtcbmV4cG9ydHMuQmx1ckZpbHRlclBhc3MgPSBCbHVyRmlsdGVyUGFzcztcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgUmVjdGFuZ2xlXzEgPSByZXF1aXJlKFwiLi4vZmxhc2gvZ2VvbS9SZWN0YW5nbGVcIik7XG5jb25zdCBJbnN0YW5jZUNvdW50ZXJfMSA9IHJlcXVpcmUoXCIuL0luc3RhbmNlQ291bnRlclwiKTtcbmNvbnN0IEZsYXNoQmFzZU9iamVjdF8xID0gcmVxdWlyZShcIi4vRmxhc2hCYXNlT2JqZWN0XCIpO1xuY2xhc3MgQm91bmRzIGV4dGVuZHMgRmxhc2hCYXNlT2JqZWN0XzEuRmxhc2hCYXNlT2JqZWN0IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgMFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5taW5YID0gSW5maW5pdHk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubWluWSA9IEluZmluaXR5O1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAwXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm1heFggPSAtSW5maW5pdHk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubWF4WSA9IC1JbmZpbml0eTtcbiAgICAgICAgdGhpcy5yZWN0ID0gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gKiBDaGVja3MgaWYgYm91bmRzIGFyZSBlbXB0eS5cbiAqXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGVtcHR5LlxuICovXG4gICAgaXNFbXB0eSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWluWCA+IHRoaXMubWF4WCB8fCB0aGlzLm1pblkgPiB0aGlzLm1heFk7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBDbGVhcnMgdGhlIGJvdW5kcyBhbmQgcmVzZXRzLlxuICAgICAqXG4gICAgICovXG4gICAgY2xlYXIoKSB7XG4gICAgICAgIHRoaXMudXBkYXRlSUQrKztcbiAgICAgICAgdGhpcy5taW5YID0gSW5maW5pdHk7XG4gICAgICAgIHRoaXMubWluWSA9IEluZmluaXR5O1xuICAgICAgICB0aGlzLm1heFggPSAtSW5maW5pdHk7XG4gICAgICAgIHRoaXMubWF4WSA9IC1JbmZpbml0eTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICogQ2FuIHJldHVybiBSZWN0YW5nbGUuRU1QVFkgY29uc3RhbnQsIGVpdGhlciBjb25zdHJ1Y3QgbmV3IHJlY3RhbmdsZSwgZWl0aGVyIHVzZSB5b3VyIHJlY3RhbmdsZVxuICogSXQgaXMgbm90IGd1YXJhbnRlZWQgdGhhdCBpdCB3aWxsIHJldHVybiB0ZW1wUmVjdFxuICpcbiAqIEBwYXJhbSB7UElYSS5SZWN0YW5nbGV9IHJlY3QgLSB0ZW1wb3Jhcnkgb2JqZWN0IHdpbGwgYmUgdXNlZCBpZiBBQUJCIGlzIG5vdCBlbXB0eVxuICogQHJldHVybnMge1BJWEkuUmVjdGFuZ2xlfSBBIHJlY3RhbmdsZSBvZiB0aGUgYm91bmRzXG4gKi9cbiAgICBnZXRSZWN0YW5nbGUocmVjdCkge1xuICAgICAgICBpZiAodGhpcy5taW5YID4gdGhpcy5tYXhYIHx8IHRoaXMubWluWSA+IHRoaXMubWF4WSkge1xuICAgICAgICAgICAgSW5zdGFuY2VDb3VudGVyXzEuSW5zdGFuY2VDb3VudGVyLmFkZENhbGwoXCJSZWN0YW5nbGUuZ2V0UmVjdGFuZ2xlXCIsIFwiQm91bmRzIGdldFJlY3RhbmdsZVwiKTtcbiAgICAgICAgICAgIHJldHVybiBSZWN0YW5nbGVfMS5SZWN0YW5nbGUuZ2V0UmVjdGFuZ2xlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmVjdCA9IHJlY3Q7XG4gICAgICAgIGlmICghcmVjdCkge1xuICAgICAgICAgICAgSW5zdGFuY2VDb3VudGVyXzEuSW5zdGFuY2VDb3VudGVyLmFkZENhbGwoXCJSZWN0YW5nbGUuZ2V0UmVjdGFuZ2xlXCIsIFwiQm91bmRzIGdldFJlY3RhbmdsZVwiKTtcbiAgICAgICAgICAgIHJlY3QgPSBSZWN0YW5nbGVfMS5SZWN0YW5nbGUuZ2V0UmVjdGFuZ2xlKDAsIDAsIDEsIDEpO1xuICAgICAgICB9XG4gICAgICAgIHJlY3QueCA9IHRoaXMubWluWDtcbiAgICAgICAgcmVjdC55ID0gdGhpcy5taW5ZO1xuICAgICAgICByZWN0LndpZHRoID0gdGhpcy5tYXhYIC0gdGhpcy5taW5YO1xuICAgICAgICByZWN0LmhlaWdodCA9IHRoaXMubWF4WSAtIHRoaXMubWluWTtcbiAgICAgICAgcmV0dXJuIHJlY3Q7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHNob3VsZCBiZSBpbmxpbmVkIHdoZW4gaXRzIHBvc3NpYmxlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQSVhJLlBvaW50fSBwb2ludCAtIFRoZSBwb2ludCB0byBhZGQuXG4gICAgICovXG4gICAgYWRkUG9pbnQocG9pbnQpIHtcbiAgICAgICAgdGhpcy5taW5YID0gTWF0aC5taW4odGhpcy5taW5YLCBwb2ludC54KTtcbiAgICAgICAgdGhpcy5tYXhYID0gTWF0aC5tYXgodGhpcy5tYXhYLCBwb2ludC54KTtcbiAgICAgICAgdGhpcy5taW5ZID0gTWF0aC5taW4odGhpcy5taW5ZLCBwb2ludC55KTtcbiAgICAgICAgdGhpcy5tYXhZID0gTWF0aC5tYXgodGhpcy5tYXhZLCBwb2ludC55KTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIEFkZHMgYSBxdWFkLCBub3QgdHJhbnNmb3JtZWRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fSB2ZXJ0aWNlcyAtIFRoZSB2ZXJ0cyB0byBhZGQuXG4gICAgICovXG4gICAgYWRkUXVhZCh2ZXJ0aWNlcykge1xuICAgICAgICB2YXIgbWluWCA9IHRoaXMubWluWDtcbiAgICAgICAgdmFyIG1pblkgPSB0aGlzLm1pblk7XG4gICAgICAgIHZhciBtYXhYID0gdGhpcy5tYXhYO1xuICAgICAgICB2YXIgbWF4WSA9IHRoaXMubWF4WTtcbiAgICAgICAgdmFyIHggPSB2ZXJ0aWNlc1swXTtcbiAgICAgICAgdmFyIHkgPSB2ZXJ0aWNlc1sxXTtcbiAgICAgICAgbWluWCA9IHggPCBtaW5YID8geCA6IG1pblg7XG4gICAgICAgIG1pblkgPSB5IDwgbWluWSA/IHkgOiBtaW5ZO1xuICAgICAgICBtYXhYID0geCA+IG1heFggPyB4IDogbWF4WDtcbiAgICAgICAgbWF4WSA9IHkgPiBtYXhZID8geSA6IG1heFk7XG4gICAgICAgIHggPSB2ZXJ0aWNlc1syXTtcbiAgICAgICAgeSA9IHZlcnRpY2VzWzNdO1xuICAgICAgICBtaW5YID0geCA8IG1pblggPyB4IDogbWluWDtcbiAgICAgICAgbWluWSA9IHkgPCBtaW5ZID8geSA6IG1pblk7XG4gICAgICAgIG1heFggPSB4ID4gbWF4WCA/IHggOiBtYXhYO1xuICAgICAgICBtYXhZID0geSA+IG1heFkgPyB5IDogbWF4WTtcbiAgICAgICAgeCA9IHZlcnRpY2VzWzRdO1xuICAgICAgICB5ID0gdmVydGljZXNbNV07XG4gICAgICAgIG1pblggPSB4IDwgbWluWCA/IHggOiBtaW5YO1xuICAgICAgICBtaW5ZID0geSA8IG1pblkgPyB5IDogbWluWTtcbiAgICAgICAgbWF4WCA9IHggPiBtYXhYID8geCA6IG1heFg7XG4gICAgICAgIG1heFkgPSB5ID4gbWF4WSA/IHkgOiBtYXhZO1xuICAgICAgICB4ID0gdmVydGljZXNbNl07XG4gICAgICAgIHkgPSB2ZXJ0aWNlc1s3XTtcbiAgICAgICAgbWluWCA9IHggPCBtaW5YID8geCA6IG1pblg7XG4gICAgICAgIG1pblkgPSB5IDwgbWluWSA/IHkgOiBtaW5ZO1xuICAgICAgICBtYXhYID0geCA+IG1heFggPyB4IDogbWF4WDtcbiAgICAgICAgbWF4WSA9IHkgPiBtYXhZID8geSA6IG1heFk7XG4gICAgICAgIHRoaXMubWluWCA9IG1pblg7XG4gICAgICAgIHRoaXMubWluWSA9IG1pblk7XG4gICAgICAgIHRoaXMubWF4WCA9IG1heFg7XG4gICAgICAgIHRoaXMubWF4WSA9IG1heFk7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBBZGRzIHNwcml0ZSBmcmFtZSwgdHJhbnNmb3JtZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BJWEkuVHJhbnNmb3JtfSB0cmFuc2Zvcm0gLSBUT0RPXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHgwIC0gVE9ET1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5MCAtIFRPRE9cbiAgICAgKiBAcGFyYW0ge251bWJlcn0geDEgLSBUT0RPXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkxIC0gVE9ET1xuICAgICAqL1xuICAgIGFkZEZyYW1lKHRyYW5zZm9ybSwgeDAsIHkwLCB4MSwgeTEpIHtcbiAgICAgICAgdmFyIG1hdHJpeCA9IHRyYW5zZm9ybS53b3JsZFRyYW5zZm9ybTtcbiAgICAgICAgdmFyIGEgPSBtYXRyaXguYTtcbiAgICAgICAgdmFyIGIgPSBtYXRyaXguYjtcbiAgICAgICAgdmFyIGMgPSBtYXRyaXguYztcbiAgICAgICAgdmFyIGQgPSBtYXRyaXguZDtcbiAgICAgICAgdmFyIHR4ID0gbWF0cml4LnR4O1xuICAgICAgICB2YXIgdHkgPSBtYXRyaXgudHk7XG4gICAgICAgIHZhciBtaW5YID0gdGhpcy5taW5YO1xuICAgICAgICB2YXIgbWluWSA9IHRoaXMubWluWTtcbiAgICAgICAgdmFyIG1heFggPSB0aGlzLm1heFg7XG4gICAgICAgIHZhciBtYXhZID0gdGhpcy5tYXhZO1xuICAgICAgICB2YXIgeCA9IChhICogeDApICsgKGMgKiB5MCkgKyB0eDtcbiAgICAgICAgdmFyIHkgPSAoYiAqIHgwKSArIChkICogeTApICsgdHk7XG4gICAgICAgIG1pblggPSB4IDwgbWluWCA/IHggOiBtaW5YO1xuICAgICAgICBtaW5ZID0geSA8IG1pblkgPyB5IDogbWluWTtcbiAgICAgICAgbWF4WCA9IHggPiBtYXhYID8geCA6IG1heFg7XG4gICAgICAgIG1heFkgPSB5ID4gbWF4WSA/IHkgOiBtYXhZO1xuICAgICAgICB4ID0gKGEgKiB4MSkgKyAoYyAqIHkwKSArIHR4O1xuICAgICAgICB5ID0gKGIgKiB4MSkgKyAoZCAqIHkwKSArIHR5O1xuICAgICAgICBtaW5YID0geCA8IG1pblggPyB4IDogbWluWDtcbiAgICAgICAgbWluWSA9IHkgPCBtaW5ZID8geSA6IG1pblk7XG4gICAgICAgIG1heFggPSB4ID4gbWF4WCA/IHggOiBtYXhYO1xuICAgICAgICBtYXhZID0geSA+IG1heFkgPyB5IDogbWF4WTtcbiAgICAgICAgeCA9IChhICogeDApICsgKGMgKiB5MSkgKyB0eDtcbiAgICAgICAgeSA9IChiICogeDApICsgKGQgKiB5MSkgKyB0eTtcbiAgICAgICAgbWluWCA9IHggPCBtaW5YID8geCA6IG1pblg7XG4gICAgICAgIG1pblkgPSB5IDwgbWluWSA/IHkgOiBtaW5ZO1xuICAgICAgICBtYXhYID0geCA+IG1heFggPyB4IDogbWF4WDtcbiAgICAgICAgbWF4WSA9IHkgPiBtYXhZID8geSA6IG1heFk7XG4gICAgICAgIHggPSAoYSAqIHgxKSArIChjICogeTEpICsgdHg7XG4gICAgICAgIHkgPSAoYiAqIHgxKSArIChkICogeTEpICsgdHk7XG4gICAgICAgIG1pblggPSB4IDwgbWluWCA/IHggOiBtaW5YO1xuICAgICAgICBtaW5ZID0geSA8IG1pblkgPyB5IDogbWluWTtcbiAgICAgICAgbWF4WCA9IHggPiBtYXhYID8geCA6IG1heFg7XG4gICAgICAgIG1heFkgPSB5ID4gbWF4WSA/IHkgOiBtYXhZO1xuICAgICAgICB0aGlzLm1pblggPSBtaW5YO1xuICAgICAgICB0aGlzLm1pblkgPSBtaW5ZO1xuICAgICAgICB0aGlzLm1heFggPSBtYXhYO1xuICAgICAgICB0aGlzLm1heFkgPSBtYXhZO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogQWRkcyBzY3JlZW4gdmVydGljZXMgZnJvbSBhcnJheVxuICAgICAqXG4gICAgICogQHBhcmFtIHtGbG9hdDMyQXJyYXl9IHZlcnRleERhdGEgLSBjYWxjdWxhdGVkIHZlcnRpY2VzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJlZ2luT2Zmc2V0IC0gYmVnaW4gb2Zmc2V0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZE9mZnNldCAtIGVuZCBvZmZzZXQsIGV4Y2x1ZGVkXG4gICAgICovXG4gICAgYWRkVmVydGV4RGF0YSh2ZXJ0ZXhEYXRhLCBiZWdpbk9mZnNldCwgZW5kT2Zmc2V0KSB7XG4gICAgICAgIHZhciBtaW5YID0gdGhpcy5taW5YO1xuICAgICAgICB2YXIgbWluWSA9IHRoaXMubWluWTtcbiAgICAgICAgdmFyIG1heFggPSB0aGlzLm1heFg7XG4gICAgICAgIHZhciBtYXhZID0gdGhpcy5tYXhZO1xuICAgICAgICBmb3IgKHZhciBpID0gYmVnaW5PZmZzZXQ7IGkgPCBlbmRPZmZzZXQ7IGkgKz0gMikge1xuICAgICAgICAgICAgdmFyIHggPSB2ZXJ0ZXhEYXRhW2ldO1xuICAgICAgICAgICAgdmFyIHkgPSB2ZXJ0ZXhEYXRhW2kgKyAxXTtcbiAgICAgICAgICAgIG1pblggPSB4IDwgbWluWCA/IHggOiBtaW5YO1xuICAgICAgICAgICAgbWluWSA9IHkgPCBtaW5ZID8geSA6IG1pblk7XG4gICAgICAgICAgICBtYXhYID0geCA+IG1heFggPyB4IDogbWF4WDtcbiAgICAgICAgICAgIG1heFkgPSB5ID4gbWF4WSA/IHkgOiBtYXhZO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubWluWCA9IG1pblg7XG4gICAgICAgIHRoaXMubWluWSA9IG1pblk7XG4gICAgICAgIHRoaXMubWF4WCA9IG1heFg7XG4gICAgICAgIHRoaXMubWF4WSA9IG1heFk7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBBZGQgYW4gYXJyYXkgb2YgbWVzaCB2ZXJ0aWNlc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtQSVhJLlRyYW5zZm9ybX0gdHJhbnNmb3JtIC0gbWVzaCB0cmFuc2Zvcm1cbiAgICAgKiBAcGFyYW0ge0Zsb2F0MzJBcnJheX0gdmVydGljZXMgLSBtZXNoIGNvb3JkaW5hdGVzIGluIGFycmF5XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJlZ2luT2Zmc2V0IC0gYmVnaW4gb2Zmc2V0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZE9mZnNldCAtIGVuZCBvZmZzZXQsIGV4Y2x1ZGVkXG4gICAgICovXG4gICAgYWRkVmVydGljZXModHJhbnNmb3JtLCB2ZXJ0aWNlcywgYmVnaW5PZmZzZXQsIGVuZE9mZnNldCkge1xuICAgICAgICB2YXIgbWF0cml4ID0gdHJhbnNmb3JtLndvcmxkVHJhbnNmb3JtO1xuICAgICAgICB2YXIgYSA9IG1hdHJpeC5hO1xuICAgICAgICB2YXIgYiA9IG1hdHJpeC5iO1xuICAgICAgICB2YXIgYyA9IG1hdHJpeC5jO1xuICAgICAgICB2YXIgZCA9IG1hdHJpeC5kO1xuICAgICAgICB2YXIgdHggPSBtYXRyaXgudHg7XG4gICAgICAgIHZhciB0eSA9IG1hdHJpeC50eTtcbiAgICAgICAgdmFyIG1pblggPSB0aGlzLm1pblg7XG4gICAgICAgIHZhciBtaW5ZID0gdGhpcy5taW5ZO1xuICAgICAgICB2YXIgbWF4WCA9IHRoaXMubWF4WDtcbiAgICAgICAgdmFyIG1heFkgPSB0aGlzLm1heFk7XG4gICAgICAgIGZvciAodmFyIGkgPSBiZWdpbk9mZnNldDsgaSA8IGVuZE9mZnNldDsgaSArPSAyKSB7XG4gICAgICAgICAgICB2YXIgcmF3WCA9IHZlcnRpY2VzW2ldO1xuICAgICAgICAgICAgdmFyIHJhd1kgPSB2ZXJ0aWNlc1tpICsgMV07XG4gICAgICAgICAgICB2YXIgeCA9IChhICogcmF3WCkgKyAoYyAqIHJhd1kpICsgdHg7XG4gICAgICAgICAgICB2YXIgeSA9IChkICogcmF3WSkgKyAoYiAqIHJhd1gpICsgdHk7XG4gICAgICAgICAgICBtaW5YID0geCA8IG1pblggPyB4IDogbWluWDtcbiAgICAgICAgICAgIG1pblkgPSB5IDwgbWluWSA/IHkgOiBtaW5ZO1xuICAgICAgICAgICAgbWF4WCA9IHggPiBtYXhYID8geCA6IG1heFg7XG4gICAgICAgICAgICBtYXhZID0geSA+IG1heFkgPyB5IDogbWF4WTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1pblggPSBtaW5YO1xuICAgICAgICB0aGlzLm1pblkgPSBtaW5ZO1xuICAgICAgICB0aGlzLm1heFggPSBtYXhYO1xuICAgICAgICB0aGlzLm1heFkgPSBtYXhZO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogQWRkcyBvdGhlciBCb3VuZHNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UElYSS5Cb3VuZHN9IGJvdW5kcyAtIFRPRE9cbiAgICAgKi9cbiAgICBhZGRCb3VuZHMoYm91bmRzKSB7XG4gICAgICAgIHZhciBtaW5YID0gdGhpcy5taW5YO1xuICAgICAgICB2YXIgbWluWSA9IHRoaXMubWluWTtcbiAgICAgICAgdmFyIG1heFggPSB0aGlzLm1heFg7XG4gICAgICAgIHZhciBtYXhZID0gdGhpcy5tYXhZO1xuICAgICAgICB0aGlzLm1pblggPSBib3VuZHMubWluWCA8IG1pblggPyBib3VuZHMubWluWCA6IG1pblg7XG4gICAgICAgIHRoaXMubWluWSA9IGJvdW5kcy5taW5ZIDwgbWluWSA/IGJvdW5kcy5taW5ZIDogbWluWTtcbiAgICAgICAgdGhpcy5tYXhYID0gYm91bmRzLm1heFggPiBtYXhYID8gYm91bmRzLm1heFggOiBtYXhYO1xuICAgICAgICB0aGlzLm1heFkgPSBib3VuZHMubWF4WSA+IG1heFkgPyBib3VuZHMubWF4WSA6IG1heFk7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBBZGRzIG90aGVyIEJvdW5kcywgbWFza2VkIHdpdGggQm91bmRzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BJWEkuQm91bmRzfSBib3VuZHMgLSBUT0RPXG4gICAgICogQHBhcmFtIHtQSVhJLkJvdW5kc30gbWFzayAtIFRPRE9cbiAgICAgKi9cbiAgICBhZGRCb3VuZHNNYXNrKGJvdW5kcywgbWFzaykge1xuICAgICAgICB2YXIgX21pblggPSBib3VuZHMubWluWCA+IG1hc2subWluWCA/IGJvdW5kcy5taW5YIDogbWFzay5taW5YO1xuICAgICAgICB2YXIgX21pblkgPSBib3VuZHMubWluWSA+IG1hc2subWluWSA/IGJvdW5kcy5taW5ZIDogbWFzay5taW5ZO1xuICAgICAgICB2YXIgX21heFggPSBib3VuZHMubWF4WCA8IG1hc2subWF4WCA/IGJvdW5kcy5tYXhYIDogbWFzay5tYXhYO1xuICAgICAgICB2YXIgX21heFkgPSBib3VuZHMubWF4WSA8IG1hc2subWF4WSA/IGJvdW5kcy5tYXhZIDogbWFzay5tYXhZO1xuICAgICAgICBpZiAoX21pblggPD0gX21heFggJiYgX21pblkgPD0gX21heFkpIHtcbiAgICAgICAgICAgIHZhciBtaW5YID0gdGhpcy5taW5YO1xuICAgICAgICAgICAgdmFyIG1pblkgPSB0aGlzLm1pblk7XG4gICAgICAgICAgICB2YXIgbWF4WCA9IHRoaXMubWF4WDtcbiAgICAgICAgICAgIHZhciBtYXhZID0gdGhpcy5tYXhZO1xuICAgICAgICAgICAgdGhpcy5taW5YID0gX21pblggPCBtaW5YID8gX21pblggOiBtaW5YO1xuICAgICAgICAgICAgdGhpcy5taW5ZID0gX21pblkgPCBtaW5ZID8gX21pblkgOiBtaW5ZO1xuICAgICAgICAgICAgdGhpcy5tYXhYID0gX21heFggPiBtYXhYID8gX21heFggOiBtYXhYO1xuICAgICAgICAgICAgdGhpcy5tYXhZID0gX21heFkgPiBtYXhZID8gX21heFkgOiBtYXhZO1xuICAgICAgICB9XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBBZGRzIG90aGVyIEJvdW5kcywgbWFza2VkIHdpdGggUmVjdGFuZ2xlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BJWEkuQm91bmRzfSBib3VuZHMgLSBUT0RPXG4gICAgICogQHBhcmFtIHtQSVhJLlJlY3RhbmdsZX0gYXJlYSAtIFRPRE9cbiAgICAgKi9cbiAgICBhZGRCb3VuZHNBcmVhKGJvdW5kcywgYXJlYSkge1xuICAgICAgICB2YXIgX21pblggPSBib3VuZHMubWluWCA+IGFyZWEueCA/IGJvdW5kcy5taW5YIDogYXJlYS54O1xuICAgICAgICB2YXIgX21pblkgPSBib3VuZHMubWluWSA+IGFyZWEueSA/IGJvdW5kcy5taW5ZIDogYXJlYS55O1xuICAgICAgICB2YXIgX21heFggPSBib3VuZHMubWF4WCA8IGFyZWEueCArIGFyZWEud2lkdGggPyBib3VuZHMubWF4WCA6IChhcmVhLnggKyBhcmVhLndpZHRoKTtcbiAgICAgICAgdmFyIF9tYXhZID0gYm91bmRzLm1heFkgPCBhcmVhLnkgKyBhcmVhLmhlaWdodCA/IGJvdW5kcy5tYXhZIDogKGFyZWEueSArIGFyZWEuaGVpZ2h0KTtcbiAgICAgICAgaWYgKF9taW5YIDw9IF9tYXhYICYmIF9taW5ZIDw9IF9tYXhZKSB7XG4gICAgICAgICAgICB2YXIgbWluWCA9IHRoaXMubWluWDtcbiAgICAgICAgICAgIHZhciBtaW5ZID0gdGhpcy5taW5ZO1xuICAgICAgICAgICAgdmFyIG1heFggPSB0aGlzLm1heFg7XG4gICAgICAgICAgICB2YXIgbWF4WSA9IHRoaXMubWF4WTtcbiAgICAgICAgICAgIHRoaXMubWluWCA9IF9taW5YIDwgbWluWCA/IF9taW5YIDogbWluWDtcbiAgICAgICAgICAgIHRoaXMubWluWSA9IF9taW5ZIDwgbWluWSA/IF9taW5ZIDogbWluWTtcbiAgICAgICAgICAgIHRoaXMubWF4WCA9IF9tYXhYID4gbWF4WCA/IF9tYXhYIDogbWF4WDtcbiAgICAgICAgICAgIHRoaXMubWF4WSA9IF9tYXhZID4gbWF4WSA/IF9tYXhZIDogbWF4WTtcbiAgICAgICAgfVxuICAgIH1cbiAgICA7XG59XG5leHBvcnRzLkJvdW5kcyA9IEJvdW5kcztcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgUnVubmVyXzEgPSByZXF1aXJlKFwiLi9SdW5uZXJcIik7XG5jbGFzcyBCdWZmZXIge1xuICAgIGNvbnN0cnVjdG9yKGRhdGEgPSBudWxsLCBfc3RhdGljID0gZmFsc2UsIGluZGV4ID0gbnVsbCkge1xuICAgICAgICBpZiAoX3N0YXRpYyA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBfc3RhdGljID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5kZXggPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgaW5kZXggPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGRhdGEgaW4gdGhlIGJ1ZmZlciwgYXMgYSB0eXBlZCBhcnJheVxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtBcnJheUJ1ZmZlcnwgU2hhcmVkQXJyYXlCdWZmZXJ8QXJyYXlCdWZmZXJWaWV3fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YSB8fCBuZXcgRmxvYXQzMkFycmF5KDEpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBtYXAgb2YgcmVuZGVyZXIgSURzIHRvIHdlYmdsIGJ1ZmZlclxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAbWVtYmVyIHtvYmplY3Q8bnVtYmVyLCBHTEJ1ZmZlcj59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9nbEJ1ZmZlcnMgPSB7fTtcbiAgICAgICAgdGhpcy5fdXBkYXRlSUQgPSAwO1xuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgICAgIHRoaXMuc3RhdGljID0gX3N0YXRpYztcbiAgICAgICAgdGhpcy5pZCA9IEJ1ZmZlci5VSUQrKztcbiAgICAgICAgdGhpcy5kaXNwb3NlUnVubmVyID0gbmV3IFJ1bm5lcl8xLlJ1bm5lcignZGlzcG9zZUJ1ZmZlcicsIDIpO1xuICAgICAgICAvLyB0aGlzLmRpc3Bvc2VSdW5uZXIgPSBuZXcgUnVubmVyKCdkaXNwb3NlQnVmZmVyJywgMik7XG4gICAgfVxuICAgIC8vIFRPRE8gY291bGQgZXhwbG9yZSBmbGFnZ2luZyBvbmx5IGEgcGFydGlhbCB1cGxvYWQ/XG4gICAgLyoqXG4gICAgICogZmxhZ3MgdGhpcyBidWZmZXIgYXMgcmVxdWlyaW5nIGFuIHVwbG9hZCB0byB0aGUgR1BVXG4gICAgICovXG4gICAgdXBkYXRlKGRhdGEpIHtcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YSB8fCB0aGlzLmRhdGE7XG4gICAgICAgIHRoaXMuX3VwZGF0ZUlEKys7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBkaXNwb3NlcyBXZWJHTCByZXNvdXJjZXMgdGhhdCBhcmUgY29ubmVjdGVkIHRvIHRoaXMgZ2VvbWV0cnlcbiAgICAgKi9cbiAgICBkaXNwb3NlKCkge1xuICAgICAgICB0aGlzLmRpc3Bvc2VSdW5uZXIucnVuKHRoaXMsIGZhbHNlKTtcbiAgICAgICAgLy8gdGhpcy5kaXNwb3NlUnVubmVyLnJ1bih0aGlzLCBmYWxzZSk7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBEZXN0cm95cyB0aGUgYnVmZmVyXG4gICAgICovXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMuZGF0YSA9IG51bGw7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBIZWxwZXIgZnVuY3Rpb24gdGhhdCBjcmVhdGVzIGEgYnVmZmVyIGJhc2VkIG9uIGFuIGFycmF5IG9yIFR5cGVkQXJyYXlcbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge0FycmF5QnVmZmVyVmlldyB8IG51bWJlcltdfSBkYXRhIHRoZSBUeXBlZEFycmF5IHRoYXQgdGhlIGJ1ZmZlciB3aWxsIHN0b3JlLiBJZiB0aGlzIGlzIGEgcmVndWxhciBBcnJheSBpdCB3aWxsIGJlIGNvbnZlcnRlZCB0byBhIEZsb2F0MzJBcnJheS5cbiAgICAgKiBAcmV0dXJuIHtQSVhJLkJ1ZmZlcn0gQSBuZXcgQnVmZmVyIGJhc2VkIG9uIHRoZSBkYXRhIHByb3ZpZGVkLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tKGRhdGEpIHtcbiAgICAgICAgaWYgKGRhdGEgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBCdWZmZXIoZGF0YSk7XG4gICAgfVxuICAgIDtcbn1cbkJ1ZmZlci5VSUQgPSAwO1xuZXhwb3J0cy5CdWZmZXIgPSBCdWZmZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IFJlc291cmNlXzEgPSByZXF1aXJlKFwiLi9SZXNvdXJjZVwiKTtcbmNsYXNzIEJ1ZmZlclJlc291cmNlIGV4dGVuZHMgUmVzb3VyY2VfMS5SZXNvdXJjZSB7XG4gICAgY29uc3RydWN0b3Ioc291cmNlLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciByZWYgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICB2YXIgd2lkdGggPSByZWYud2lkdGg7XG4gICAgICAgIHZhciBoZWlnaHQgPSByZWYuaGVpZ2h0O1xuICAgICAgICBpZiAoIXdpZHRoIHx8ICFoZWlnaHQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQnVmZmVyUmVzb3VyY2Ugd2lkdGggb3IgaGVpZ2h0IGludmFsaWQnKTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlcih3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNvdXJjZSBhcnJheVxuICAgICAgICAgKiBDYW5ub3QgYmUgQ2xhbXBlZFVpbnQ4QXJyYXkgYmVjYXVzZSBpdCBjYW50IGJlIHVwbG9hZGVkIHRvIFdlYkdMXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge0Zsb2F0MzJBcnJheXxVaW50OEFycmF5fFVpbnQzMkFycmF5fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kYXRhID0gc291cmNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGxvYWQgdGhlIHRleHR1cmUgdG8gdGhlIEdQVS5cbiAgICAgKiBAcGFyYW0ge1BJWEkuUmVuZGVyZXJ9IHJlbmRlcmVyIFVwbG9hZCB0byB0aGUgcmVuZGVyZXJcbiAgICAgKiBAcGFyYW0ge1BJWEkuQmFzZVRleHR1cmV9IGJhc2VUZXh0dXJlIFJlZmVyZW5jZSB0byBwYXJlbnQgdGV4dHVyZVxuICAgICAqIEBwYXJhbSB7UElYSS5HTFRleHR1cmV9IGdsVGV4dHVyZSBnbFRleHR1cmVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpcyBzdWNjZXNzXG4gICAgICovXG4gICAgdXBsb2FkKHJlbmRlcmVyLCBiYXNlVGV4dHVyZSwgZ2xUZXh0dXJlKSB7XG4gICAgICAgIHZhciBnbCA9IHJlbmRlcmVyLmdsO1xuICAgICAgICBnbC5waXhlbFN0b3JlaShnbC5VTlBBQ0tfUFJFTVVMVElQTFlfQUxQSEFfV0VCR0wsIGJhc2VUZXh0dXJlLnByZW11bHRpcGx5QWxwaGEpO1xuICAgICAgICBpZiAoZ2xUZXh0dXJlLndpZHRoID09PSBiYXNlVGV4dHVyZS53aWR0aCAmJiBnbFRleHR1cmUuaGVpZ2h0ID09PSBiYXNlVGV4dHVyZS5oZWlnaHQpIHtcbiAgICAgICAgICAgIGdsLnRleFN1YkltYWdlMkQoYmFzZVRleHR1cmUudGFyZ2V0LCAwLCAwLCAwLCBiYXNlVGV4dHVyZS53aWR0aCwgYmFzZVRleHR1cmUuaGVpZ2h0LCBiYXNlVGV4dHVyZS5mb3JtYXQsIGJhc2VUZXh0dXJlLnR5cGUsIHRoaXMuZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBnbFRleHR1cmUud2lkdGggPSBiYXNlVGV4dHVyZS53aWR0aDtcbiAgICAgICAgICAgIGdsVGV4dHVyZS5oZWlnaHQgPSBiYXNlVGV4dHVyZS5oZWlnaHQ7XG4gICAgICAgICAgICB2YXIgaW50ZXJuYWxGb3JtYXQgPSBiYXNlVGV4dHVyZS5mb3JtYXQ7XG4gICAgICAgICAgICAvLyBndWVzcyBzaXplZCBmb3JtYXQgYnkgdHlwZSBhbmQgZm9ybWF0XG4gICAgICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvV2ViR0xSZW5kZXJpbmdDb250ZXh0L3RleEltYWdlMkRcbiAgICAgICAgICAgIGlmIChyZW5kZXJlci5jb250ZXh0LndlYkdMVmVyc2lvbiA9PT0gMlxuICAgICAgICAgICAgICAgICYmIGJhc2VUZXh0dXJlLnR5cGUgPT09IHJlbmRlcmVyLmdsLkZMT0FUXG4gICAgICAgICAgICAgICAgJiYgYmFzZVRleHR1cmUuZm9ybWF0ID09PSByZW5kZXJlci5nbC5SR0JBKSB7XG4gICAgICAgICAgICAgICAgaW50ZXJuYWxGb3JtYXQgPSByZW5kZXJlci5nbC5SR0JBMzJGO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ2wudGV4SW1hZ2UyRChiYXNlVGV4dHVyZS50YXJnZXQsIDAsIGludGVybmFsRm9ybWF0LCBiYXNlVGV4dHVyZS53aWR0aCwgYmFzZVRleHR1cmUuaGVpZ2h0LCAwLCBiYXNlVGV4dHVyZS5mb3JtYXQsIGJhc2VUZXh0dXJlLnR5cGUsIHRoaXMuZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBEZXN0cm95IGFuZCBkb24ndCB1c2UgYWZ0ZXIgdGhpc1xuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgIHRoaXMuZGF0YSA9IG51bGw7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBVc2VkIHRvIGF1dG8tZGV0ZWN0IHRoZSB0eXBlIG9mIHJlc291cmNlLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7Kn0gc291cmNlIC0gVGhlIHNvdXJjZSBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBgdHJ1ZWAgaWYgPGNhbnZhcz5cbiAgICAgKi9cbiAgICBzdGF0aWMgdGVzdChzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZSBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheVxuICAgICAgICAgICAgfHwgc291cmNlIGluc3RhbmNlb2YgVWludDhBcnJheVxuICAgICAgICAgICAgfHwgc291cmNlIGluc3RhbmNlb2YgVWludDMyQXJyYXk7XG4gICAgfVxuICAgIDtcbn1cbmV4cG9ydHMuQnVmZmVyUmVzb3VyY2UgPSBCdWZmZXJSZXNvdXJjZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY2xhc3MgQ2FjaGVTZXR0aW5ncyB7XG4gICAgc3RhdGljIGNsZWFyVGV4dHVyZUNhY2hlKCkge1xuICAgICAgICB2YXIga2V5O1xuICAgICAgICBmb3IgKGtleSBpbiBDYWNoZVNldHRpbmdzLlRleHR1cmVDYWNoZSkge1xuICAgICAgICAgICAgZGVsZXRlIENhY2hlU2V0dGluZ3MuVGV4dHVyZUNhY2hlW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChrZXkgaW4gQ2FjaGVTZXR0aW5ncy5CYXNlVGV4dHVyZUNhY2hlKSB7XG4gICAgICAgICAgICBkZWxldGUgQ2FjaGVTZXR0aW5ncy5CYXNlVGV4dHVyZUNhY2hlW2tleV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIGRlc3Ryb3lUZXh0dXJlQ2FjaGUoKSB7XG4gICAgICAgIHZhciBrZXk7XG4gICAgICAgIGZvciAoa2V5IGluIENhY2hlU2V0dGluZ3MuVGV4dHVyZUNhY2hlKSB7XG4gICAgICAgICAgICBDYWNoZVNldHRpbmdzLlRleHR1cmVDYWNoZVtrZXldLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGtleSBpbiBDYWNoZVNldHRpbmdzLkJhc2VUZXh0dXJlQ2FjaGUpIHtcbiAgICAgICAgICAgIENhY2hlU2V0dGluZ3MuQmFzZVRleHR1cmVDYWNoZVtrZXldLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbkNhY2hlU2V0dGluZ3MuUHJvZ3JhbUNhY2hlID0ge307XG5DYWNoZVNldHRpbmdzLm5hbWVDYWNoZSA9IHt9O1xuQ2FjaGVTZXR0aW5ncy5wcm9ncmFtQ2FjaGUgPSB7fTtcbkNhY2hlU2V0dGluZ3MuVGV4dHVyZUNhY2hlID0ge307XG5DYWNoZVNldHRpbmdzLkJhc2VUZXh0dXJlQ2FjaGUgPSB7fTtcbkNhY2hlU2V0dGluZ3MuZGVmYXVsdEdyb3VwQ2FjaGUgPSB7fTtcbmV4cG9ydHMuQ2FjaGVTZXR0aW5ncyA9IENhY2hlU2V0dGluZ3M7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IERpc3BsYXlTZXR0aW5nc18xID0gcmVxdWlyZShcIi4vRGlzcGxheVNldHRpbmdzXCIpO1xuY2xhc3MgQ2FudmFzUmVuZGVyVGFyZ2V0IHtcbiAgICBjb25zdHJ1Y3Rvcih3aWR0aCwgaGVpZ2h0LCByZXNvbHV0aW9uKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFRoZSBDYW52YXMgb2JqZWN0IHRoYXQgYmVsb25ncyB0byB0aGlzIENhbnZhc1JlbmRlclRhcmdldC5cbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIEBtZW1iZXIge0hUTUxDYW52YXNFbGVtZW50fVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICB0aGlzLmNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQgb2JqZWN0IHJlcHJlc2VudGluZyBhIHR3by1kaW1lbnNpb25hbCByZW5kZXJpbmcgY29udGV4dC5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jb250ZXh0ID0gdGhpcy5jYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgdGhpcy5yZXNvbHV0aW9uID0gcmVzb2x1dGlvbiB8fCBEaXNwbGF5U2V0dGluZ3NfMS5EaXNwbGF5U2V0dGluZ3MuUkVTT0xVVElPTjtcbiAgICAgICAgdGhpcy5yZXNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsZWFycyB0aGUgY2FudmFzIHRoYXQgd2FzIGNyZWF0ZWQgYnkgdGhlIENhbnZhc1JlbmRlclRhcmdldCBjbGFzcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgY2xlYXIoKSB7XG4gICAgICAgIHRoaXMuY29udGV4dC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG4gICAgICAgIHRoaXMuY29udGV4dC5jbGVhclJlY3QoMCwgMCwgdGhpcy5jYW52YXMud2lkdGgsIHRoaXMuY2FudmFzLmhlaWdodCk7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBSZXNpemVzIHRoZSBjYW52YXMgdG8gdGhlIHNwZWNpZmllZCB3aWR0aCBhbmQgaGVpZ2h0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIC0gdGhlIG5ldyB3aWR0aCBvZiB0aGUgY2FudmFzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCAtIHRoZSBuZXcgaGVpZ2h0IG9mIHRoZSBjYW52YXNcbiAgICAgKi9cbiAgICByZXNpemUod2lkdGgsIGhlaWdodCkge1xuICAgICAgICB0aGlzLmNhbnZhcy53aWR0aCA9IHdpZHRoICogdGhpcy5yZXNvbHV0aW9uO1xuICAgICAgICB0aGlzLmNhbnZhcy5oZWlnaHQgPSBoZWlnaHQgKiB0aGlzLnJlc29sdXRpb247XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBEZXN0cm95cyB0aGlzIGNhbnZhcy5cbiAgICAgKlxuICAgICAqL1xuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IG51bGw7XG4gICAgICAgIHRoaXMuY2FudmFzID0gbnVsbDtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFRoZSB3aWR0aCBvZiB0aGUgY2FudmFzIGJ1ZmZlciBpbiBwaXhlbHMuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICovXG4gICAgZ2V0IHdpZHRoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYW52YXMud2lkdGg7XG4gICAgfVxuICAgIDtcbiAgICBzZXQgd2lkdGgodmFsKSB7XG4gICAgICAgIHRoaXMuY2FudmFzLndpZHRoID0gdmFsO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogVGhlIGhlaWdodCBvZiB0aGUgY2FudmFzIGJ1ZmZlciBpbiBwaXhlbHMuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICovXG4gICAgZ2V0IGhlaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FudmFzLmhlaWdodDtcbiAgICB9XG4gICAgO1xuICAgIHNldCBoZWlnaHQodmFsKSB7XG4gICAgICAgIHRoaXMuY2FudmFzLmhlaWdodCA9IHZhbDtcbiAgICB9XG4gICAgO1xufVxuZXhwb3J0cy5DYW52YXNSZW5kZXJUYXJnZXQgPSBDYW52YXNSZW5kZXJUYXJnZXQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IEJhc2VJbWFnZVJlc291cmNlXzEgPSByZXF1aXJlKFwiLi9CYXNlSW1hZ2VSZXNvdXJjZVwiKTtcbmNsYXNzIENhbnZhc1Jlc291cmNlIGV4dGVuZHMgQmFzZUltYWdlUmVzb3VyY2VfMS5CYXNlSW1hZ2VSZXNvdXJjZSB7XG4gICAgY29uc3RydWN0b3Ioc291cmNlKSB7XG4gICAgICAgIHN1cGVyKHNvdXJjZSk7XG4gICAgfVxuICAgIHN0YXRpYyB0ZXN0KHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gKHNvdXJjZSBpbnN0YW5jZW9mIEhUTUxDYW52YXNFbGVtZW50KTtcbiAgICB9XG4gICAgO1xufVxuZXhwb3J0cy5DYW52YXNSZXNvdXJjZSA9IENhbnZhc1Jlc291cmNlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jbGFzcyBDYW52YXNTZXR0aW5ncyB7XG4gICAgLyoqXG4qIFRyaW0gdHJhbnNwYXJlbnQgYm9yZGVycyBmcm9tIGEgY2FudmFzXG4qXG4qIEBtZW1iZXJvZiBQSVhJLnV0aWxzXG4qIEBmdW5jdGlvbiB0cmltQ2FudmFzXG4qIEBwYXJhbSB7SFRNTENhbnZhc0VsZW1lbnR9IGNhbnZhcyAtIHRoZSBjYW52YXMgdG8gdHJpbVxuKiBAcmV0dXJucyB7b2JqZWN0fSBUcmltIGRhdGFcbiovXG4gICAgc3RhdGljIHRyaW1DYW52YXMoY2FudmFzKSB7XG4gICAgICAgIC8vIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL3JlbXkvNzg0NTA4XG4gICAgICAgIHZhciB3aWR0aCA9IGNhbnZhcy53aWR0aDtcbiAgICAgICAgdmFyIGhlaWdodCA9IGNhbnZhcy5oZWlnaHQ7XG4gICAgICAgIHZhciBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIHZhciBpbWFnZURhdGEgPSBjb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgdmFyIHBpeGVscyA9IGltYWdlRGF0YS5kYXRhO1xuICAgICAgICB2YXIgbGVuID0gcGl4ZWxzLmxlbmd0aDtcbiAgICAgICAgdmFyIGJvdW5kID0ge1xuICAgICAgICAgICAgdG9wOiBudWxsLFxuICAgICAgICAgICAgbGVmdDogbnVsbCxcbiAgICAgICAgICAgIHJpZ2h0OiBudWxsLFxuICAgICAgICAgICAgYm90dG9tOiBudWxsLFxuICAgICAgICB9O1xuICAgICAgICB2YXIgZGF0YSA9IG51bGw7XG4gICAgICAgIHZhciBpO1xuICAgICAgICB2YXIgeDtcbiAgICAgICAgdmFyIHk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgICAgICAgICAgaWYgKHBpeGVsc1tpICsgM10gIT09IDApIHtcbiAgICAgICAgICAgICAgICB4ID0gKGkgLyA0KSAlIHdpZHRoO1xuICAgICAgICAgICAgICAgIHkgPSB+figoaSAvIDQpIC8gd2lkdGgpO1xuICAgICAgICAgICAgICAgIGlmIChib3VuZC50b3AgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgYm91bmQudG9wID0geTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGJvdW5kLmxlZnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgYm91bmQubGVmdCA9IHg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHggPCBib3VuZC5sZWZ0KSB7XG4gICAgICAgICAgICAgICAgICAgIGJvdW5kLmxlZnQgPSB4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYm91bmQucmlnaHQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgYm91bmQucmlnaHQgPSB4ICsgMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYm91bmQucmlnaHQgPCB4KSB7XG4gICAgICAgICAgICAgICAgICAgIGJvdW5kLnJpZ2h0ID0geCArIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChib3VuZC5ib3R0b20gPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgYm91bmQuYm90dG9tID0geTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYm91bmQuYm90dG9tIDwgeSkge1xuICAgICAgICAgICAgICAgICAgICBib3VuZC5ib3R0b20gPSB5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYm91bmQudG9wICE9PSBudWxsKSB7XG4gICAgICAgICAgICB3aWR0aCA9IGJvdW5kLnJpZ2h0IC0gYm91bmQubGVmdDtcbiAgICAgICAgICAgIGhlaWdodCA9IGJvdW5kLmJvdHRvbSAtIGJvdW5kLnRvcCArIDE7XG4gICAgICAgICAgICBkYXRhID0gY29udGV4dC5nZXRJbWFnZURhdGEoYm91bmQubGVmdCwgYm91bmQudG9wLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuQ2FudmFzU2V0dGluZ3MgPSBDYW52YXNTZXR0aW5ncztcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgUmVjdGFuZ2xlXzEgPSByZXF1aXJlKFwiLi4vZmxhc2gvZ2VvbS9SZWN0YW5nbGVcIik7XG5jb25zdCBTaGFwZVNldHRpbmdzXzEgPSByZXF1aXJlKFwiLi9TaGFwZVNldHRpbmdzXCIpO1xuY29uc3QgSW5zdGFuY2VDb3VudGVyXzEgPSByZXF1aXJlKFwiLi9JbnN0YW5jZUNvdW50ZXJcIik7XG5jbGFzcyBDaXJjbGUge1xuICAgIGNvbnN0cnVjdG9yKHggPSAwLCB5ID0gMCwgcmFkaXVzID0gMCkge1xuICAgICAgICBpZiAoeCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICB4ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoeSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICB5ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmFkaXVzID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHJhZGl1cyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgMFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy54ID0geDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgMFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy55ID0geTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgMFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yYWRpdXMgPSByYWRpdXM7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdHlwZSBvZiB0aGUgb2JqZWN0LCBtYWlubHkgdXNlZCB0byBhdm9pZCBgaW5zdGFuY2VvZmAgY2hlY2tzXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICogQHJlYWRPbmx5XG4gICAgICAgICAqIEBkZWZhdWx0IFBJWEkuU0hBUEVTLkNJUkNcbiAgICAgICAgICogQHNlZSBQSVhJLlNIQVBFU1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50eXBlID0gU2hhcGVTZXR0aW5nc18xLlNoYXBlU2V0dGluZ3MuU0hBUEVTLkNJUkM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjbG9uZSBvZiB0aGlzIENpcmNsZSBpbnN0YW5jZVxuICAgICAqXG4gICAgICogQHJldHVybiB7UElYSS5DaXJjbGV9IGEgY29weSBvZiB0aGUgQ2lyY2xlXG4gICAgICovXG4gICAgY2xvbmUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ2lyY2xlKHRoaXMueCwgdGhpcy55LCB0aGlzLnJhZGl1cyk7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgeCBhbmQgeSBjb29yZGluYXRlcyBnaXZlbiBhcmUgY29udGFpbmVkIHdpdGhpbiB0aGlzIGNpcmNsZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggLSBUaGUgWCBjb29yZGluYXRlIG9mIHRoZSBwb2ludCB0byB0ZXN0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgLSBUaGUgWSBjb29yZGluYXRlIG9mIHRoZSBwb2ludCB0byB0ZXN0XG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUgeC95IGNvb3JkaW5hdGVzIGFyZSB3aXRoaW4gdGhpcyBDaXJjbGVcbiAgICAgKi9cbiAgICBjb250YWlucyh4LCB5KSB7XG4gICAgICAgIGlmICh0aGlzLnJhZGl1cyA8PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHIyID0gdGhpcy5yYWRpdXMgKiB0aGlzLnJhZGl1cztcbiAgICAgICAgdmFyIGR4ID0gKHRoaXMueCAtIHgpO1xuICAgICAgICB2YXIgZHkgPSAodGhpcy55IC0geSk7XG4gICAgICAgIGR4ICo9IGR4O1xuICAgICAgICBkeSAqPSBkeTtcbiAgICAgICAgcmV0dXJuIChkeCArIGR5IDw9IHIyKTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICogUmV0dXJucyB0aGUgZnJhbWluZyByZWN0YW5nbGUgb2YgdGhlIGNpcmNsZSBhcyBhIFJlY3RhbmdsZSBvYmplY3RcbiAgICAqXG4gICAgKiBAcmV0dXJuIHtQSVhJLlJlY3RhbmdsZX0gdGhlIGZyYW1pbmcgcmVjdGFuZ2xlXG4gICAgKi9cbiAgICBnZXRCb3VuZHMoKSB7XG4gICAgICAgIEluc3RhbmNlQ291bnRlcl8xLkluc3RhbmNlQ291bnRlci5hZGRDYWxsKFwiUmVjdGFuZ2xlLmdldFJlY3RhbmdsZVwiLCBcIkNpcmNsZSBnZXRCb3VuZHNcIik7XG4gICAgICAgIHJldHVybiBSZWN0YW5nbGVfMS5SZWN0YW5nbGUuZ2V0UmVjdGFuZ2xlKHRoaXMueCAtIHRoaXMucmFkaXVzLCB0aGlzLnkgLSB0aGlzLnJhZGl1cywgdGhpcy5yYWRpdXMgKiAyLCB0aGlzLnJhZGl1cyAqIDIpO1xuICAgIH1cbiAgICA7XG59XG5leHBvcnRzLkNpcmNsZSA9IENpcmNsZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY2xhc3MgQ2xlYW5VcFNldHRpbmdzIHtcbn1cbkNsZWFuVXBTZXR0aW5ncy5kZWZhdWx0RGVzdHJveU9wdGlvbnMgPSB7XG4gICAgdGV4dHVyZTogdHJ1ZSxcbiAgICBjaGlsZHJlbjogZmFsc2UsXG4gICAgYmFzZVRleHR1cmU6IHRydWUsXG59O1xuZXhwb3J0cy5DbGVhblVwU2V0dGluZ3MgPSBDbGVhblVwU2V0dGluZ3M7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IEZpbHRlcl8xID0gcmVxdWlyZShcIi4vRmlsdGVyXCIpO1xuY29uc3Qgc2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL3NldHRpbmdzXCIpO1xuY2xhc3MgQ29sb3JNYXRyaXhGaWx0ZXIgZXh0ZW5kcyBGaWx0ZXJfMS5GaWx0ZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB2YXIgdW5pZm9ybXMgPSB7XG4gICAgICAgICAgICBtOiBuZXcgRmxvYXQzMkFycmF5KFsxLCAwLCAwLCAwLCAwLFxuICAgICAgICAgICAgICAgIDAsIDEsIDAsIDAsIDAsXG4gICAgICAgICAgICAgICAgMCwgMCwgMSwgMCwgMCxcbiAgICAgICAgICAgICAgICAwLCAwLCAwLCAxLCAwXSksXG4gICAgICAgICAgICB1QWxwaGE6IDEsXG4gICAgICAgIH07XG4gICAgICAgIHN1cGVyKHNldHRpbmdzXzEuc2V0dGluZ3MuZGVmYXVsdEZpbHRlclZlcnRleCwgQ29sb3JNYXRyaXhGaWx0ZXIuZnJhZ21lbnQkNCwgdW5pZm9ybXMpO1xuICAgICAgICB0aGlzLmFscGhhID0gMTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJhbnNmb3JtcyBjdXJyZW50IG1hdHJpeCBhbmQgc2V0IHRoZSBuZXcgb25lXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcltdfSBtYXRyaXggLSA1eDQgbWF0cml4XG4gICAgICogQHBhcmFtIHtib29sZWFufSBtdWx0aXBseSAtIGlmIHRydWUsIGN1cnJlbnQgbWF0cml4IGFuZCBtYXRyaXggYXJlIG11bHRpcGxpZWQuIElmIGZhbHNlLFxuICAgICAqICBqdXN0IHNldCB0aGUgY3VycmVudCBtYXRyaXggd2l0aCBAcGFyYW0gbWF0cml4XG4gICAgICovXG4gICAgX2xvYWRNYXRyaXgobWF0cml4LCBtdWx0aXBseSkge1xuICAgICAgICBpZiAobXVsdGlwbHkgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgbXVsdGlwbHkgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmV3TWF0cml4ID0gbWF0cml4O1xuICAgICAgICBpZiAobXVsdGlwbHkpIHtcbiAgICAgICAgICAgIHRoaXMuX211bHRpcGx5KG5ld01hdHJpeCwgdGhpcy51bmlmb3Jtcy5tLCBtYXRyaXgpO1xuICAgICAgICAgICAgbmV3TWF0cml4ID0gdGhpcy5fY29sb3JNYXRyaXgobmV3TWF0cml4KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBzZXQgdGhlIG5ldyBtYXRyaXhcbiAgICAgICAgdGhpcy51bmlmb3Jtcy5tID0gbmV3TWF0cml4O1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogTXVsdGlwbGllcyB0d28gbWF0NSdzXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyW119IG91dCAtIDV4NCBtYXRyaXggdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAgICAgKiBAcGFyYW0ge251bWJlcltdfSBhIC0gNXg0IG1hdHJpeCB0aGUgZmlyc3Qgb3BlcmFuZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyW119IGIgLSA1eDQgbWF0cml4IHRoZSBzZWNvbmQgb3BlcmFuZFxuICAgICAqIEByZXR1cm5zIHtudW1iZXJbXX0gNXg0IG1hdHJpeFxuICAgICAqL1xuICAgIF9tdWx0aXBseShvdXQsIGEsIGIpIHtcbiAgICAgICAgLy8gUmVkIENoYW5uZWxcbiAgICAgICAgb3V0WzBdID0gKGFbMF0gKiBiWzBdKSArIChhWzFdICogYls1XSkgKyAoYVsyXSAqIGJbMTBdKSArIChhWzNdICogYlsxNV0pO1xuICAgICAgICBvdXRbMV0gPSAoYVswXSAqIGJbMV0pICsgKGFbMV0gKiBiWzZdKSArIChhWzJdICogYlsxMV0pICsgKGFbM10gKiBiWzE2XSk7XG4gICAgICAgIG91dFsyXSA9IChhWzBdICogYlsyXSkgKyAoYVsxXSAqIGJbN10pICsgKGFbMl0gKiBiWzEyXSkgKyAoYVszXSAqIGJbMTddKTtcbiAgICAgICAgb3V0WzNdID0gKGFbMF0gKiBiWzNdKSArIChhWzFdICogYls4XSkgKyAoYVsyXSAqIGJbMTNdKSArIChhWzNdICogYlsxOF0pO1xuICAgICAgICBvdXRbNF0gPSAoYVswXSAqIGJbNF0pICsgKGFbMV0gKiBiWzldKSArIChhWzJdICogYlsxNF0pICsgKGFbM10gKiBiWzE5XSkgKyBhWzRdO1xuICAgICAgICAvLyBHcmVlbiBDaGFubmVsXG4gICAgICAgIG91dFs1XSA9IChhWzVdICogYlswXSkgKyAoYVs2XSAqIGJbNV0pICsgKGFbN10gKiBiWzEwXSkgKyAoYVs4XSAqIGJbMTVdKTtcbiAgICAgICAgb3V0WzZdID0gKGFbNV0gKiBiWzFdKSArIChhWzZdICogYls2XSkgKyAoYVs3XSAqIGJbMTFdKSArIChhWzhdICogYlsxNl0pO1xuICAgICAgICBvdXRbN10gPSAoYVs1XSAqIGJbMl0pICsgKGFbNl0gKiBiWzddKSArIChhWzddICogYlsxMl0pICsgKGFbOF0gKiBiWzE3XSk7XG4gICAgICAgIG91dFs4XSA9IChhWzVdICogYlszXSkgKyAoYVs2XSAqIGJbOF0pICsgKGFbN10gKiBiWzEzXSkgKyAoYVs4XSAqIGJbMThdKTtcbiAgICAgICAgb3V0WzldID0gKGFbNV0gKiBiWzRdKSArIChhWzZdICogYls5XSkgKyAoYVs3XSAqIGJbMTRdKSArIChhWzhdICogYlsxOV0pICsgYVs5XTtcbiAgICAgICAgLy8gQmx1ZSBDaGFubmVsXG4gICAgICAgIG91dFsxMF0gPSAoYVsxMF0gKiBiWzBdKSArIChhWzExXSAqIGJbNV0pICsgKGFbMTJdICogYlsxMF0pICsgKGFbMTNdICogYlsxNV0pO1xuICAgICAgICBvdXRbMTFdID0gKGFbMTBdICogYlsxXSkgKyAoYVsxMV0gKiBiWzZdKSArIChhWzEyXSAqIGJbMTFdKSArIChhWzEzXSAqIGJbMTZdKTtcbiAgICAgICAgb3V0WzEyXSA9IChhWzEwXSAqIGJbMl0pICsgKGFbMTFdICogYls3XSkgKyAoYVsxMl0gKiBiWzEyXSkgKyAoYVsxM10gKiBiWzE3XSk7XG4gICAgICAgIG91dFsxM10gPSAoYVsxMF0gKiBiWzNdKSArIChhWzExXSAqIGJbOF0pICsgKGFbMTJdICogYlsxM10pICsgKGFbMTNdICogYlsxOF0pO1xuICAgICAgICBvdXRbMTRdID0gKGFbMTBdICogYls0XSkgKyAoYVsxMV0gKiBiWzldKSArIChhWzEyXSAqIGJbMTRdKSArIChhWzEzXSAqIGJbMTldKSArIGFbMTRdO1xuICAgICAgICAvLyBBbHBoYSBDaGFubmVsXG4gICAgICAgIG91dFsxNV0gPSAoYVsxNV0gKiBiWzBdKSArIChhWzE2XSAqIGJbNV0pICsgKGFbMTddICogYlsxMF0pICsgKGFbMThdICogYlsxNV0pO1xuICAgICAgICBvdXRbMTZdID0gKGFbMTVdICogYlsxXSkgKyAoYVsxNl0gKiBiWzZdKSArIChhWzE3XSAqIGJbMTFdKSArIChhWzE4XSAqIGJbMTZdKTtcbiAgICAgICAgb3V0WzE3XSA9IChhWzE1XSAqIGJbMl0pICsgKGFbMTZdICogYls3XSkgKyAoYVsxN10gKiBiWzEyXSkgKyAoYVsxOF0gKiBiWzE3XSk7XG4gICAgICAgIG91dFsxOF0gPSAoYVsxNV0gKiBiWzNdKSArIChhWzE2XSAqIGJbOF0pICsgKGFbMTddICogYlsxM10pICsgKGFbMThdICogYlsxOF0pO1xuICAgICAgICBvdXRbMTldID0gKGFbMTVdICogYls0XSkgKyAoYVsxNl0gKiBiWzldKSArIChhWzE3XSAqIGJbMTRdKSArIChhWzE4XSAqIGJbMTldKSArIGFbMTldO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgRmxvYXQzMiBBcnJheSBhbmQgbm9ybWFsaXplIHRoZSBvZmZzZXQgY29tcG9uZW50IHRvIDAtMVxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcltdfSBtYXRyaXggLSA1eDQgbWF0cml4XG4gICAgICogQHJldHVybiB7bnVtYmVyW119IDV4NCBtYXRyaXggd2l0aCBhbGwgdmFsdWVzIGJldHdlZW4gMC0xXG4gICAgICovXG4gICAgX2NvbG9yTWF0cml4KG1hdHJpeCkge1xuICAgICAgICAvLyBDcmVhdGUgYSBGbG9hdDMyIEFycmF5IGFuZCBub3JtYWxpemUgdGhlIG9mZnNldCBjb21wb25lbnQgdG8gMC0xXG4gICAgICAgIHZhciBtID0gbmV3IEZsb2F0MzJBcnJheShtYXRyaXgpO1xuICAgICAgICBtWzRdIC89IDI1NTtcbiAgICAgICAgbVs5XSAvPSAyNTU7XG4gICAgICAgIG1bMTRdIC89IDI1NTtcbiAgICAgICAgbVsxOV0gLz0gMjU1O1xuICAgICAgICByZXR1cm4gbTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIEFkanVzdHMgYnJpZ2h0bmVzc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGIgLSB2YWx1ZSBvZiB0aGUgYnJpZ3RobmVzcyAoMC0xLCB3aGVyZSAwIGlzIGJsYWNrKVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gbXVsdGlwbHkgLSBpZiB0cnVlLCBjdXJyZW50IG1hdHJpeCBhbmQgbWF0cml4IGFyZSBtdWx0aXBsaWVkLiBJZiBmYWxzZSxcbiAgICAgKiAganVzdCBzZXQgdGhlIGN1cnJlbnQgbWF0cml4IHdpdGggQHBhcmFtIG1hdHJpeFxuICAgICAqL1xuICAgIGJyaWdodG5lc3MoYiwgbXVsdGlwbHkpIHtcbiAgICAgICAgdmFyIG1hdHJpeCA9IFtcbiAgICAgICAgICAgIGIsIDAsIDAsIDAsIDAsXG4gICAgICAgICAgICAwLCBiLCAwLCAwLCAwLFxuICAgICAgICAgICAgMCwgMCwgYiwgMCwgMCxcbiAgICAgICAgICAgIDAsIDAsIDAsIDEsIDBcbiAgICAgICAgXTtcbiAgICAgICAgdGhpcy5fbG9hZE1hdHJpeChtYXRyaXgsIG11bHRpcGx5KTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFNldCB0aGUgbWF0cmljZXMgaW4gZ3JleSBzY2FsZXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzY2FsZSAtIHZhbHVlIG9mIHRoZSBncmV5ICgwLTEsIHdoZXJlIDAgaXMgYmxhY2spXG4gICAgICogQHBhcmFtIHtib29sZWFufSBtdWx0aXBseSAtIGlmIHRydWUsIGN1cnJlbnQgbWF0cml4IGFuZCBtYXRyaXggYXJlIG11bHRpcGxpZWQuIElmIGZhbHNlLFxuICAgICAqICBqdXN0IHNldCB0aGUgY3VycmVudCBtYXRyaXggd2l0aCBAcGFyYW0gbWF0cml4XG4gICAgICovXG4gICAgZ3JleXNjYWxlKHNjYWxlLCBtdWx0aXBseSkge1xuICAgICAgICB2YXIgbWF0cml4ID0gW1xuICAgICAgICAgICAgc2NhbGUsIHNjYWxlLCBzY2FsZSwgMCwgMCxcbiAgICAgICAgICAgIHNjYWxlLCBzY2FsZSwgc2NhbGUsIDAsIDAsXG4gICAgICAgICAgICBzY2FsZSwgc2NhbGUsIHNjYWxlLCAwLCAwLFxuICAgICAgICAgICAgMCwgMCwgMCwgMSwgMFxuICAgICAgICBdO1xuICAgICAgICB0aGlzLl9sb2FkTWF0cml4KG1hdHJpeCwgbXVsdGlwbHkpO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBibGFjayBhbmQgd2hpdGUgbWF0cmljZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gbXVsdGlwbHkgLSBpZiB0cnVlLCBjdXJyZW50IG1hdHJpeCBhbmQgbWF0cml4IGFyZSBtdWx0aXBsaWVkLiBJZiBmYWxzZSxcbiAgICAgKiAganVzdCBzZXQgdGhlIGN1cnJlbnQgbWF0cml4IHdpdGggQHBhcmFtIG1hdHJpeFxuICAgICAqL1xuICAgIGJsYWNrQW5kV2hpdGUobXVsdGlwbHkpIHtcbiAgICAgICAgdmFyIG1hdHJpeCA9IFtcbiAgICAgICAgICAgIDAuMywgMC42LCAwLjEsIDAsIDAsXG4gICAgICAgICAgICAwLjMsIDAuNiwgMC4xLCAwLCAwLFxuICAgICAgICAgICAgMC4zLCAwLjYsIDAuMSwgMCwgMCxcbiAgICAgICAgICAgIDAsIDAsIDAsIDEsIDBcbiAgICAgICAgXTtcbiAgICAgICAgdGhpcy5fbG9hZE1hdHJpeChtYXRyaXgsIG11bHRpcGx5KTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFNldCB0aGUgaHVlIHByb3BlcnR5IG9mIHRoZSBjb2xvclxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJvdGF0aW9uIC0gaW4gZGVncmVlc1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gbXVsdGlwbHkgLSBpZiB0cnVlLCBjdXJyZW50IG1hdHJpeCBhbmQgbWF0cml4IGFyZSBtdWx0aXBsaWVkLiBJZiBmYWxzZSxcbiAgICAgKiAganVzdCBzZXQgdGhlIGN1cnJlbnQgbWF0cml4IHdpdGggQHBhcmFtIG1hdHJpeFxuICAgICAqL1xuICAgIGh1ZShyb3RhdGlvbiwgbXVsdGlwbHkpIHtcbiAgICAgICAgcm90YXRpb24gPSAocm90YXRpb24gfHwgMCkgLyAxODAgKiBNYXRoLlBJO1xuICAgICAgICB2YXIgY29zUiA9IE1hdGguY29zKHJvdGF0aW9uKTtcbiAgICAgICAgdmFyIHNpblIgPSBNYXRoLnNpbihyb3RhdGlvbik7XG4gICAgICAgIHZhciBzcXJ0ID0gTWF0aC5zcXJ0O1xuICAgICAgICAvKiBhIGdvb2QgYXBwcm94aW1hdGlvbiBmb3IgaHVlIHJvdGF0aW9uXG4gICAgICAgICAgICBUaGlzIG1hdHJpeCBpcyBmYXIgYmV0dGVyIHRoYW4gdGhlIHZlcnNpb25zIHdpdGggbWFnaWMgbHVtaW5hbmNlIGNvbnN0YW50c1xuICAgICAgICAgICAgZm9ybWVybHkgdXNlZCBoZXJlLCBidXQgYWxzbyB1c2VkIGluIHRoZSBzdGFybGluZyBmcmFtZXdvcmsgKGZsYXNoKSBhbmQga25vd24gZnJvbSB0aGlzXG4gICAgICAgICAgICBvbGQgcGFydCBvZiB0aGUgaW50ZXJuZXQ6IHF1YXNpbW9uZG8uY29tL2FyY2hpdmVzLzAwMDU2NS5waHBcblxuICAgICAgICAgICAgVGhpcyBuZXcgbWF0cml4IGlzIGJhc2VkIG9uIHJnYiBjdWJlIHJvdGF0aW9uIGluIHNwYWNlLiBMb29rIGhlcmUgZm9yIGEgbW9yZSBkZXNjcmlwdGl2ZVxuICAgICAgICAgICAgaW1wbGVtZW50YXRpb24gYXMgYSBzaGFkZXIgbm90IGEgZ2VuZXJhbCBtYXRyaXg6XG4gICAgICAgICAgICBodHRwczovL2dpdGh1Yi5jb20vZXZhbncvZ2xmeC5qcy9ibG9iLzU4ODQxYzIzOTE5YmQ1OTc4N2VmZmMwMzMzYTQ4OTdiNDM4MzU0MTIvc3JjL2ZpbHRlcnMvYWRqdXN0L2h1ZXNhdHVyYXRpb24uanNcblxuICAgICAgICAgICAgVGhpcyBpcyB0aGUgc291cmNlIGZvciB0aGUgY29kZTpcbiAgICAgICAgICAgIHNlZSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzg1MDc4ODUvc2hpZnQtaHVlLW9mLWFuLXJnYi1jb2xvci84NTEwNzUxIzg1MTA3NTFcbiAgICAgICAgICAgICovXG4gICAgICAgIHZhciB3ID0gMSAvIDM7XG4gICAgICAgIHZhciBzcXJXID0gc3FydCh3KTsgLy8gd2VpZ2h0IGlzXG4gICAgICAgIHZhciBhMDAgPSBjb3NSICsgKCgxLjAgLSBjb3NSKSAqIHcpO1xuICAgICAgICB2YXIgYTAxID0gKHcgKiAoMS4wIC0gY29zUikpIC0gKHNxclcgKiBzaW5SKTtcbiAgICAgICAgdmFyIGEwMiA9ICh3ICogKDEuMCAtIGNvc1IpKSArIChzcXJXICogc2luUik7XG4gICAgICAgIHZhciBhMTAgPSAodyAqICgxLjAgLSBjb3NSKSkgKyAoc3FyVyAqIHNpblIpO1xuICAgICAgICB2YXIgYTExID0gY29zUiArICh3ICogKDEuMCAtIGNvc1IpKTtcbiAgICAgICAgdmFyIGExMiA9ICh3ICogKDEuMCAtIGNvc1IpKSAtIChzcXJXICogc2luUik7XG4gICAgICAgIHZhciBhMjAgPSAodyAqICgxLjAgLSBjb3NSKSkgLSAoc3FyVyAqIHNpblIpO1xuICAgICAgICB2YXIgYTIxID0gKHcgKiAoMS4wIC0gY29zUikpICsgKHNxclcgKiBzaW5SKTtcbiAgICAgICAgdmFyIGEyMiA9IGNvc1IgKyAodyAqICgxLjAgLSBjb3NSKSk7XG4gICAgICAgIHZhciBtYXRyaXggPSBbXG4gICAgICAgICAgICBhMDAsIGEwMSwgYTAyLCAwLCAwLFxuICAgICAgICAgICAgYTEwLCBhMTEsIGExMiwgMCwgMCxcbiAgICAgICAgICAgIGEyMCwgYTIxLCBhMjIsIDAsIDAsXG4gICAgICAgICAgICAwLCAwLCAwLCAxLCAwXG4gICAgICAgIF07XG4gICAgICAgIHRoaXMuX2xvYWRNYXRyaXgobWF0cml4LCBtdWx0aXBseSk7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGNvbnRyYXN0IG1hdHJpeCwgaW5jcmVhc2UgdGhlIHNlcGFyYXRpb24gYmV0d2VlbiBkYXJrIGFuZCBicmlnaHRcbiAgICAgKiBJbmNyZWFzZSBjb250cmFzdCA6IHNoYWRvd3MgZGFya2VyIGFuZCBoaWdobGlnaHRzIGJyaWdodGVyXG4gICAgICogRGVjcmVhc2UgY29udHJhc3QgOiBicmluZyB0aGUgc2hhZG93cyB1cCBhbmQgdGhlIGhpZ2hsaWdodHMgZG93blxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGFtb3VudCAtIHZhbHVlIG9mIHRoZSBjb250cmFzdCAoMC0xKVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gbXVsdGlwbHkgLSBpZiB0cnVlLCBjdXJyZW50IG1hdHJpeCBhbmQgbWF0cml4IGFyZSBtdWx0aXBsaWVkLiBJZiBmYWxzZSxcbiAgICAgKiAganVzdCBzZXQgdGhlIGN1cnJlbnQgbWF0cml4IHdpdGggQHBhcmFtIG1hdHJpeFxuICAgICAqL1xuICAgIGNvbnRyYXN0KGFtb3VudCwgbXVsdGlwbHkpIHtcbiAgICAgICAgdmFyIHYgPSAoYW1vdW50IHx8IDApICsgMTtcbiAgICAgICAgdmFyIG8gPSAtMC41ICogKHYgLSAxKTtcbiAgICAgICAgdmFyIG1hdHJpeCA9IFtcbiAgICAgICAgICAgIHYsIDAsIDAsIDAsIG8sXG4gICAgICAgICAgICAwLCB2LCAwLCAwLCBvLFxuICAgICAgICAgICAgMCwgMCwgdiwgMCwgbyxcbiAgICAgICAgICAgIDAsIDAsIDAsIDEsIDBcbiAgICAgICAgXTtcbiAgICAgICAgdGhpcy5fbG9hZE1hdHJpeChtYXRyaXgsIG11bHRpcGx5KTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFNldCB0aGUgc2F0dXJhdGlvbiBtYXRyaXgsIGluY3JlYXNlIHRoZSBzZXBhcmF0aW9uIGJldHdlZW4gY29sb3JzXG4gICAgICogSW5jcmVhc2Ugc2F0dXJhdGlvbiA6IGluY3JlYXNlIGNvbnRyYXN0LCBicmlnaHRuZXNzLCBhbmQgc2hhcnBuZXNzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYW1vdW50IC0gVGhlIHNhdHVyYXRpb24gYW1vdW50ICgwLTEpXG4gICAgICogQHBhcmFtIHtib29sZWFufSBtdWx0aXBseSAtIGlmIHRydWUsIGN1cnJlbnQgbWF0cml4IGFuZCBtYXRyaXggYXJlIG11bHRpcGxpZWQuIElmIGZhbHNlLFxuICAgICAqICBqdXN0IHNldCB0aGUgY3VycmVudCBtYXRyaXggd2l0aCBAcGFyYW0gbWF0cml4XG4gICAgICovXG4gICAgc2F0dXJhdGUoYW1vdW50LCBtdWx0aXBseSA9IG51bGwpIHtcbiAgICAgICAgaWYgKGFtb3VudCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBhbW91bnQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHZhciB4ID0gKGFtb3VudCAqIDIgLyAzKSArIDE7XG4gICAgICAgIHZhciB5ID0gKCh4IC0gMSkgKiAtMC41KTtcbiAgICAgICAgdmFyIG1hdHJpeCA9IFtcbiAgICAgICAgICAgIHgsIHksIHksIDAsIDAsXG4gICAgICAgICAgICB5LCB4LCB5LCAwLCAwLFxuICAgICAgICAgICAgeSwgeSwgeCwgMCwgMCxcbiAgICAgICAgICAgIDAsIDAsIDAsIDEsIDBcbiAgICAgICAgXTtcbiAgICAgICAgdGhpcy5fbG9hZE1hdHJpeChtYXRyaXgsIG11bHRpcGx5KTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIERlc2F0dXJhdGUgaW1hZ2UgKHJlbW92ZSBjb2xvcilcbiAgICAgKlxuICAgICAqIENhbGwgdGhlIHNhdHVyYXRlIGZ1bmN0aW9uXG4gICAgICpcbiAgICAgKi9cbiAgICBkZXNhdHVyYXRlKCkge1xuICAgICAgICB0aGlzLnNhdHVyYXRlKC0xKTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIE5lZ2F0aXZlIGltYWdlIChpbnZlcnNlIG9mIGNsYXNzaWMgcmdiIG1hdHJpeClcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gbXVsdGlwbHkgLSBpZiB0cnVlLCBjdXJyZW50IG1hdHJpeCBhbmQgbWF0cml4IGFyZSBtdWx0aXBsaWVkLiBJZiBmYWxzZSxcbiAgICAgKiAganVzdCBzZXQgdGhlIGN1cnJlbnQgbWF0cml4IHdpdGggQHBhcmFtIG1hdHJpeFxuICAgICAqL1xuICAgIG5lZ2F0aXZlKG11bHRpcGx5KSB7XG4gICAgICAgIHZhciBtYXRyaXggPSBbXG4gICAgICAgICAgICAtMSwgMCwgMCwgMSwgMCxcbiAgICAgICAgICAgIDAsIC0xLCAwLCAxLCAwLFxuICAgICAgICAgICAgMCwgMCwgLTEsIDEsIDAsXG4gICAgICAgICAgICAwLCAwLCAwLCAxLCAwXG4gICAgICAgIF07XG4gICAgICAgIHRoaXMuX2xvYWRNYXRyaXgobWF0cml4LCBtdWx0aXBseSk7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBTZXBpYSBpbWFnZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtib29sZWFufSBtdWx0aXBseSAtIGlmIHRydWUsIGN1cnJlbnQgbWF0cml4IGFuZCBtYXRyaXggYXJlIG11bHRpcGxpZWQuIElmIGZhbHNlLFxuICAgICAqICBqdXN0IHNldCB0aGUgY3VycmVudCBtYXRyaXggd2l0aCBAcGFyYW0gbWF0cml4XG4gICAgICovXG4gICAgc2VwaWEobXVsdGlwbHkpIHtcbiAgICAgICAgdmFyIG1hdHJpeCA9IFtcbiAgICAgICAgICAgIDAuMzkzLCAwLjc2ODk5OTksIDAuMTg4OTk5OTksIDAsIDAsXG4gICAgICAgICAgICAwLjM0OSwgMC42ODU5OTk5LCAwLjE2Nzk5OTk5LCAwLCAwLFxuICAgICAgICAgICAgMC4yNzIsIDAuNTMzOTk5OSwgMC4xMzA5OTk5OSwgMCwgMCxcbiAgICAgICAgICAgIDAsIDAsIDAsIDEsIDBcbiAgICAgICAgXTtcbiAgICAgICAgdGhpcy5fbG9hZE1hdHJpeChtYXRyaXgsIG11bHRpcGx5KTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIENvbG9yIG1vdGlvbiBwaWN0dXJlIHByb2Nlc3MgaW52ZW50ZWQgaW4gMTkxNiAodGhhbmtzIERvbWluaWMgU3phYmxld3NraSlcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gbXVsdGlwbHkgLSBpZiB0cnVlLCBjdXJyZW50IG1hdHJpeCBhbmQgbWF0cml4IGFyZSBtdWx0aXBsaWVkLiBJZiBmYWxzZSxcbiAgICAgKiAganVzdCBzZXQgdGhlIGN1cnJlbnQgbWF0cml4IHdpdGggQHBhcmFtIG1hdHJpeFxuICAgICAqL1xuICAgIHRlY2huaWNvbG9yKG11bHRpcGx5KSB7XG4gICAgICAgIHZhciBtYXRyaXggPSBbXG4gICAgICAgICAgICAxLjkxMjUyNzc4OTE0NTYwODMsIC0wLjg1NDUzNDQ5NzY5NTE2NDUsIC0wLjA5MTU1NTA4NDgyNzU1NTg1LCAwLCAxMS43OTM2MDM0MzQzNzczMzcsXG4gICAgICAgICAgICAtMC4zMDg3ODMzMzg1OTI4MDk3LCAxLjc2NTg5MDg1NTU0NTg0MjgsIC0wLjEwNjAxNzQzMDc0NzIyMjQ1LCAwLCAtNzAuMzUyMDUxNjE0NjEzOTgsXG4gICAgICAgICAgICAtMC4yMzExMDMzNzc1NDg2MTYsIC0wLjc1MDE4OTkxOTc0NDAyMTIsIDEuODQ3NTk3ODE2MTA4MTg5LCAwLCAzMC45NTA5NDA4Njk0OTExMzgsXG4gICAgICAgICAgICAwLCAwLCAwLCAxLCAwXG4gICAgICAgIF07XG4gICAgICAgIHRoaXMuX2xvYWRNYXRyaXgobWF0cml4LCBtdWx0aXBseSk7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBQb2xhcm9pZCBmaWx0ZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gbXVsdGlwbHkgLSBpZiB0cnVlLCBjdXJyZW50IG1hdHJpeCBhbmQgbWF0cml4IGFyZSBtdWx0aXBsaWVkLiBJZiBmYWxzZSxcbiAgICAgKiAganVzdCBzZXQgdGhlIGN1cnJlbnQgbWF0cml4IHdpdGggQHBhcmFtIG1hdHJpeFxuICAgICAqL1xuICAgIHBvbGFyb2lkKG11bHRpcGx5KSB7XG4gICAgICAgIHZhciBtYXRyaXggPSBbXG4gICAgICAgICAgICAxLjQzOCwgLTAuMDYyLCAtMC4wNjIsIDAsIDAsXG4gICAgICAgICAgICAtMC4xMjIsIDEuMzc4LCAtMC4xMjIsIDAsIDAsXG4gICAgICAgICAgICAtMC4wMTYsIC0wLjAxNiwgMS40ODMsIDAsIDAsXG4gICAgICAgICAgICAwLCAwLCAwLCAxLCAwXG4gICAgICAgIF07XG4gICAgICAgIHRoaXMuX2xvYWRNYXRyaXgobWF0cml4LCBtdWx0aXBseSk7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBGaWx0ZXIgd2hvIHRyYW5zZm9ybXMgOiBSZWQgLT4gQmx1ZSBhbmQgQmx1ZSAtPiBSZWRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gbXVsdGlwbHkgLSBpZiB0cnVlLCBjdXJyZW50IG1hdHJpeCBhbmQgbWF0cml4IGFyZSBtdWx0aXBsaWVkLiBJZiBmYWxzZSxcbiAgICAgKiAganVzdCBzZXQgdGhlIGN1cnJlbnQgbWF0cml4IHdpdGggQHBhcmFtIG1hdHJpeFxuICAgICAqL1xuICAgIHRvQkdSKG11bHRpcGx5KSB7XG4gICAgICAgIHZhciBtYXRyaXggPSBbXG4gICAgICAgICAgICAwLCAwLCAxLCAwLCAwLFxuICAgICAgICAgICAgMCwgMSwgMCwgMCwgMCxcbiAgICAgICAgICAgIDEsIDAsIDAsIDAsIDAsXG4gICAgICAgICAgICAwLCAwLCAwLCAxLCAwXG4gICAgICAgIF07XG4gICAgICAgIHRoaXMuX2xvYWRNYXRyaXgobWF0cml4LCBtdWx0aXBseSk7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBDb2xvciByZXZlcnNhbCBmaWxtIGludHJvZHVjZWQgYnkgRWFzdG1hbiBLb2RhayBpbiAxOTM1LiAodGhhbmtzIERvbWluaWMgU3phYmxld3NraSlcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gbXVsdGlwbHkgLSBpZiB0cnVlLCBjdXJyZW50IG1hdHJpeCBhbmQgbWF0cml4IGFyZSBtdWx0aXBsaWVkLiBJZiBmYWxzZSxcbiAgICAgKiAganVzdCBzZXQgdGhlIGN1cnJlbnQgbWF0cml4IHdpdGggQHBhcmFtIG1hdHJpeFxuICAgICAqL1xuICAgIGtvZGFjaHJvbWUobXVsdGlwbHkpIHtcbiAgICAgICAgdmFyIG1hdHJpeCA9IFtcbiAgICAgICAgICAgIDEuMTI4NTU4MjM5NjU5MzUyNSwgLTAuMzk2NzM4MjI4MzYwMTM0OCwgLTAuMDM5OTI1NTkxNzI5MjE3OTMsIDAsIDYzLjcyOTU4NzYyMTk2NTAyLFxuICAgICAgICAgICAgLTAuMTY0MDQzMzk5NjIyNDQ2MTYsIDEuMDgzNTI1MTU2NjI5MTMwNCwgLTAuMDU0OTg4MDUxMTU2MzMxMzIsIDAsIDI0LjczMjQwNzg5NjcwNjIwMyxcbiAgICAgICAgICAgIC0wLjE2Nzg2MDEwNzA2MTU1NzYzLCAtMC41NjAzNDE2Mjc3Njk1MjQ4LCAxLjYwMTQ4NTA3NjE5NjQ5NDMsIDAsIDM1LjYyOTgyODA3NDYwOTQ2LFxuICAgICAgICAgICAgMCwgMCwgMCwgMSwgMFxuICAgICAgICBdO1xuICAgICAgICB0aGlzLl9sb2FkTWF0cml4KG1hdHJpeCwgbXVsdGlwbHkpO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogQnJvd24gZGVsaWNpb3VzIGJyb3duaSBmaWx0ZXIgKHRoYW5rcyBEb21pbmljIFN6YWJsZXdza2kpXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IG11bHRpcGx5IC0gaWYgdHJ1ZSwgY3VycmVudCBtYXRyaXggYW5kIG1hdHJpeCBhcmUgbXVsdGlwbGllZC4gSWYgZmFsc2UsXG4gICAgICogIGp1c3Qgc2V0IHRoZSBjdXJyZW50IG1hdHJpeCB3aXRoIEBwYXJhbSBtYXRyaXhcbiAgICAgKi9cbiAgICBicm93bmkobXVsdGlwbHkpIHtcbiAgICAgICAgdmFyIG1hdHJpeCA9IFtcbiAgICAgICAgICAgIDAuNTk5NzAyMzQ5ODE1OTcxNSwgMC4zNDU1MzI0MzA0ODM5MTI2MywgLTAuMjcwODI5ODY3NDUzODA0MiwgMCwgNDcuNDMxOTI4NTU2MDA4NzMsXG4gICAgICAgICAgICAtMC4wMzc3MDMyNDk4Mzc3ODMxNTcsIDAuODYwOTU3NzU4Nzk5MjY0MSwgMC4xNTA1OTU1MjM4ODQ1OTkxMywgMCwgLTM2Ljk2ODQxNDk4MzE5MTI3LFxuICAgICAgICAgICAgMC4yNDExMzYzNTEyODE1MzMzNSwgLTAuMDc0NDEwMzc5MDg0MjI0OTIsIDAuNDQ5NzIxODIwNjQ4NzcxNTMsIDAsIC03LjU2MjA3NTI3NzU5MTI4MyxcbiAgICAgICAgICAgIDAsIDAsIDAsIDEsIDBcbiAgICAgICAgXTtcbiAgICAgICAgdGhpcy5fbG9hZE1hdHJpeChtYXRyaXgsIG11bHRpcGx5KTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFZpbnRhZ2UgZmlsdGVyICh0aGFua3MgRG9taW5pYyBTemFibGV3c2tpKVxuICAgICAqXG4gICAgICogQHBhcmFtIHtib29sZWFufSBtdWx0aXBseSAtIGlmIHRydWUsIGN1cnJlbnQgbWF0cml4IGFuZCBtYXRyaXggYXJlIG11bHRpcGxpZWQuIElmIGZhbHNlLFxuICAgICAqICBqdXN0IHNldCB0aGUgY3VycmVudCBtYXRyaXggd2l0aCBAcGFyYW0gbWF0cml4XG4gICAgICovXG4gICAgdmludGFnZShtdWx0aXBseSkge1xuICAgICAgICB2YXIgbWF0cml4ID0gW1xuICAgICAgICAgICAgMC42Mjc5MzQ1NjM1NjA1OTk0LCAwLjMyMDIxODM0MjA4MTkzNjcsIC0wLjAzOTY1NDA4MjExMzEyNDUzLCAwLCA5LjY1MTI4NTgzNTI5NDEyMyxcbiAgICAgICAgICAgIDAuMDI1NzgzOTc3MDQ4MDg4NjgsIDAuNjQ0MTE4ODY0NDM3NDc3MSwgMC4wMzI1OTEyNzYxNjE0OTI5NCwgMCwgNy40NjI4MjkxNzY0NzA1OTEsXG4gICAgICAgICAgICAwLjA0NjYwNTU1NTY3ODI3MTksIC0wLjA4NTEyMzI5ODcyNDc4OTEsIDAuNTI0MTY0ODAxODcwMDQ2NSwgMCwgNS4xNTkxOTA1ODgyMzUyOTYsXG4gICAgICAgICAgICAwLCAwLCAwLCAxLCAwXG4gICAgICAgIF07XG4gICAgICAgIHRoaXMuX2xvYWRNYXRyaXgobWF0cml4LCBtdWx0aXBseSk7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBXZSBkb24ndCBrbm93IGV4YWN0bHkgd2hhdCBpdCBkb2VzLCBraW5kIG9mIGdyYWRpZW50IG1hcCwgYnV0IGZ1bm55IHRvIHBsYXkgd2l0aCFcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkZXNhdHVyYXRpb24gLSBUb25lIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdG9uZWQgLSBUb25lIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbGlnaHRDb2xvciAtIFRvbmUgdmFsdWVzLCBleGFtcGxlOiBgMHhGRkU1ODBgXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRhcmtDb2xvciAtIFRvbmUgdmFsdWVzLCBleGFtcGxlOiBgMHhGRkU1ODBgXG4gICAgICogQHBhcmFtIHtib29sZWFufSBtdWx0aXBseSAtIGlmIHRydWUsIGN1cnJlbnQgbWF0cml4IGFuZCBtYXRyaXggYXJlIG11bHRpcGxpZWQuIElmIGZhbHNlLFxuICAgICAqICBqdXN0IHNldCB0aGUgY3VycmVudCBtYXRyaXggd2l0aCBAcGFyYW0gbWF0cml4XG4gICAgICovXG4gICAgY29sb3JUb25lKGRlc2F0dXJhdGlvbiwgdG9uZWQsIGxpZ2h0Q29sb3IsIGRhcmtDb2xvciwgbXVsdGlwbHkpIHtcbiAgICAgICAgZGVzYXR1cmF0aW9uID0gZGVzYXR1cmF0aW9uIHx8IDAuMjtcbiAgICAgICAgdG9uZWQgPSB0b25lZCB8fCAwLjE1O1xuICAgICAgICBsaWdodENvbG9yID0gbGlnaHRDb2xvciB8fCAweEZGRTU4MDtcbiAgICAgICAgZGFya0NvbG9yID0gZGFya0NvbG9yIHx8IDB4MzM4MDAwO1xuICAgICAgICB2YXIgbFIgPSAoKGxpZ2h0Q29sb3IgPj4gMTYpICYgMHhGRikgLyAyNTU7XG4gICAgICAgIHZhciBsRyA9ICgobGlnaHRDb2xvciA+PiA4KSAmIDB4RkYpIC8gMjU1O1xuICAgICAgICB2YXIgbEIgPSAobGlnaHRDb2xvciAmIDB4RkYpIC8gMjU1O1xuICAgICAgICB2YXIgZFIgPSAoKGRhcmtDb2xvciA+PiAxNikgJiAweEZGKSAvIDI1NTtcbiAgICAgICAgdmFyIGRHID0gKChkYXJrQ29sb3IgPj4gOCkgJiAweEZGKSAvIDI1NTtcbiAgICAgICAgdmFyIGRCID0gKGRhcmtDb2xvciAmIDB4RkYpIC8gMjU1O1xuICAgICAgICB2YXIgbWF0cml4ID0gW1xuICAgICAgICAgICAgMC4zLCAwLjU5LCAwLjExLCAwLCAwLFxuICAgICAgICAgICAgbFIsIGxHLCBsQiwgZGVzYXR1cmF0aW9uLCAwLFxuICAgICAgICAgICAgZFIsIGRHLCBkQiwgdG9uZWQsIDAsXG4gICAgICAgICAgICBsUiAtIGRSLCBsRyAtIGRHLCBsQiAtIGRCLCAwLCAwXG4gICAgICAgIF07XG4gICAgICAgIHRoaXMuX2xvYWRNYXRyaXgobWF0cml4LCBtdWx0aXBseSk7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBOaWdodCBlZmZlY3RcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbnRlbnNpdHkgLSBUaGUgaW50ZW5zaXR5IG9mIHRoZSBuaWdodCBlZmZlY3QuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBtdWx0aXBseSAtIGlmIHRydWUsIGN1cnJlbnQgbWF0cml4IGFuZCBtYXRyaXggYXJlIG11bHRpcGxpZWQuIElmIGZhbHNlLFxuICAgICAqICBqdXN0IHNldCB0aGUgY3VycmVudCBtYXRyaXggd2l0aCBAcGFyYW0gbWF0cml4XG4gICAgICovXG4gICAgbmlnaHQoaW50ZW5zaXR5LCBtdWx0aXBseSkge1xuICAgICAgICBpbnRlbnNpdHkgPSBpbnRlbnNpdHkgfHwgMC4xO1xuICAgICAgICB2YXIgbWF0cml4ID0gW1xuICAgICAgICAgICAgaW50ZW5zaXR5ICogKC0yLjApLCAtaW50ZW5zaXR5LCAwLCAwLCAwLFxuICAgICAgICAgICAgLWludGVuc2l0eSwgMCwgaW50ZW5zaXR5LCAwLCAwLFxuICAgICAgICAgICAgMCwgaW50ZW5zaXR5LCBpbnRlbnNpdHkgKiAyLjAsIDAsIDAsXG4gICAgICAgICAgICAwLCAwLCAwLCAxLCAwXG4gICAgICAgIF07XG4gICAgICAgIHRoaXMuX2xvYWRNYXRyaXgobWF0cml4LCBtdWx0aXBseSk7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBQcmVkYXRvciBlZmZlY3RcbiAgICAgKlxuICAgICAqIEVyYXNlIHRoZSBjdXJyZW50IG1hdHJpeCBieSBzZXR0aW5nIGEgbmV3IGluZGVwZW50IG9uZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGFtb3VudCAtIGhvdyBtdWNoIHRoZSBwcmVkYXRvciBmZWVscyBoaXMgZnV0dXJlIHZpY3RpbVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gbXVsdGlwbHkgLSBpZiB0cnVlLCBjdXJyZW50IG1hdHJpeCBhbmQgbWF0cml4IGFyZSBtdWx0aXBsaWVkLiBJZiBmYWxzZSxcbiAgICAgKiAganVzdCBzZXQgdGhlIGN1cnJlbnQgbWF0cml4IHdpdGggQHBhcmFtIG1hdHJpeFxuICAgICAqL1xuICAgIHByZWRhdG9yKGFtb3VudCwgbXVsdGlwbHkpIHtcbiAgICAgICAgdmFyIG1hdHJpeCA9IFtcbiAgICAgICAgICAgIC8vIHJvdyAxXG4gICAgICAgICAgICAxMS4yMjQxMzA2MzA0OTMxNjQgKiBhbW91bnQsXG4gICAgICAgICAgICAtNC43OTQ0ODY5OTk1MTE3MTkgKiBhbW91bnQsXG4gICAgICAgICAgICAtMi44NzQ2MTE4NTQ1NTMyMjI3ICogYW1vdW50LFxuICAgICAgICAgICAgMCAqIGFtb3VudCxcbiAgICAgICAgICAgIDAuNDAzNDI0MzgyMjA5Nzc3ODMgKiBhbW91bnQsXG4gICAgICAgICAgICAvLyByb3cgMlxuICAgICAgICAgICAgLTMuNjMzMDY5NzUzNjQ2ODUwNiAqIGFtb3VudCxcbiAgICAgICAgICAgIDkuMTkzMTU3MTk2MDQ0OTIyICogYW1vdW50LFxuICAgICAgICAgICAgLTIuOTUxODEwODM2NzkxOTkyICogYW1vdW50LFxuICAgICAgICAgICAgMCAqIGFtb3VudCxcbiAgICAgICAgICAgIC0xLjMxNjEzNTA0ODg2NjI3MiAqIGFtb3VudCxcbiAgICAgICAgICAgIC8vIHJvdyAzXG4gICAgICAgICAgICAtMy4yMTg0MTk3OTAyNjc5NDQzICogYW1vdW50LFxuICAgICAgICAgICAgLTQuMjM3NTAzMDUxNzU3ODEyNSAqIGFtb3VudCxcbiAgICAgICAgICAgIDcuNDc2NDQ4MDU5MDgyMDMxICogYW1vdW50LFxuICAgICAgICAgICAgMCAqIGFtb3VudCxcbiAgICAgICAgICAgIDAuODA0NDQ1OTIyMzc0NzI1MyAqIGFtb3VudCxcbiAgICAgICAgICAgIC8vIHJvdyA0XG4gICAgICAgICAgICAwLCAwLCAwLCAxLCAwXG4gICAgICAgIF07XG4gICAgICAgIHRoaXMuX2xvYWRNYXRyaXgobWF0cml4LCBtdWx0aXBseSk7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBMU0QgZWZmZWN0XG4gICAgICpcbiAgICAgKiBNdWx0aXBseSB0aGUgY3VycmVudCBtYXRyaXhcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gbXVsdGlwbHkgLSBpZiB0cnVlLCBjdXJyZW50IG1hdHJpeCBhbmQgbWF0cml4IGFyZSBtdWx0aXBsaWVkLiBJZiBmYWxzZSxcbiAgICAgKiAganVzdCBzZXQgdGhlIGN1cnJlbnQgbWF0cml4IHdpdGggQHBhcmFtIG1hdHJpeFxuICAgICAqL1xuICAgIGxzZChtdWx0aXBseSkge1xuICAgICAgICB2YXIgbWF0cml4ID0gW1xuICAgICAgICAgICAgMiwgLTAuNCwgMC41LCAwLCAwLFxuICAgICAgICAgICAgLTAuNSwgMiwgLTAuNCwgMCwgMCxcbiAgICAgICAgICAgIC0wLjQsIC0wLjUsIDMsIDAsIDAsXG4gICAgICAgICAgICAwLCAwLCAwLCAxLCAwXG4gICAgICAgIF07XG4gICAgICAgIHRoaXMuX2xvYWRNYXRyaXgobWF0cml4LCBtdWx0aXBseSk7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBFcmFzZSB0aGUgY3VycmVudCBtYXRyaXggYnkgc2V0dGluZyB0aGUgZGVmYXVsdCBvbmVcbiAgICAgKlxuICAgICAqL1xuICAgIHJlc2V0KCkge1xuICAgICAgICB2YXIgbWF0cml4ID0gW1xuICAgICAgICAgICAgMSwgMCwgMCwgMCwgMCxcbiAgICAgICAgICAgIDAsIDEsIDAsIDAsIDAsXG4gICAgICAgICAgICAwLCAwLCAxLCAwLCAwLFxuICAgICAgICAgICAgMCwgMCwgMCwgMSwgMFxuICAgICAgICBdO1xuICAgICAgICB0aGlzLl9sb2FkTWF0cml4KG1hdHJpeCwgZmFsc2UpO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogVGhlIG1hdHJpeCBvZiB0aGUgY29sb3IgbWF0cml4IGZpbHRlclxuICAgICAqXG4gICAgICogQG1lbWJlciB7bnVtYmVyW119XG4gICAgICogQGRlZmF1bHQgWzEsIDAsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDAsIDEsIDBdXG4gICAgICovXG4gICAgZ2V0IG1hdHJpeCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudW5pZm9ybXMubTtcbiAgICB9XG4gICAgO1xuICAgIHNldCBtYXRyaXgodmFsdWUpIHtcbiAgICAgICAgdGhpcy51bmlmb3Jtcy5tID0gdmFsdWU7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBUaGUgb3BhY2l0eSB2YWx1ZSB0byB1c2Ugd2hlbiBtaXhpbmcgdGhlIG9yaWdpbmFsIGFuZCByZXN1bHRhbnQgY29sb3JzLlxuICAgICAqXG4gICAgICogV2hlbiB0aGUgdmFsdWUgaXMgMCwgdGhlIG9yaWdpbmFsIGNvbG9yIGlzIHVzZWQgd2l0aG91dCBtb2RpZmljYXRpb24uXG4gICAgICogV2hlbiB0aGUgdmFsdWUgaXMgMSwgdGhlIHJlc3VsdCBjb2xvciBpcyB1c2VkLlxuICAgICAqIFdoZW4gaW4gdGhlIHJhbmdlICgwLCAxKSB0aGUgY29sb3IgaXMgaW50ZXJwb2xhdGVkIGJldHdlZW4gdGhlIG9yaWdpbmFsIGFuZCByZXN1bHQgYnkgdGhpcyBhbW91bnQuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMVxuICAgICAqL1xuICAgIGdldCBhbHBoYSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudW5pZm9ybXMudUFscGhhO1xuICAgIH1cbiAgICA7XG4gICAgc2V0IGFscGhhKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudW5pZm9ybXMudUFscGhhID0gdmFsdWU7XG4gICAgfVxuICAgIDtcbn1cbi8qIVxuKiBAcGl4aS9maWx0ZXItY29sb3ItbWF0cml4IC0gdjUuMC4wLXJjLjNcbiogQ29tcGlsZWQgV2VkLCAxMCBBcHIgMjAxOSAwMToyMToxNSBVVENcbipcbiogQHBpeGkvZmlsdGVyLWNvbG9yLW1hdHJpeCBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4qIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2VcbiovXG5Db2xvck1hdHJpeEZpbHRlci5mcmFnbWVudCQ0ID0gXCJ2YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXHJcXG51bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjtcXHJcXG51bmlmb3JtIGZsb2F0IG1bMjBdO1xcclxcbnVuaWZvcm0gZmxvYXQgdUFscGhhO1xcclxcblxcclxcbnZvaWQgbWFpbih2b2lkKVxcclxcbntcXHJcXG4gICAgdmVjNCBjID0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2VGV4dHVyZUNvb3JkKTtcXHJcXG5cXHJcXG4gICAgaWYgKHVBbHBoYSA9PSAwLjApIHtcXHJcXG4gICAgICAgIGdsX0ZyYWdDb2xvciA9IGM7XFxyXFxuICAgICAgICByZXR1cm47XFxyXFxuICAgIH1cXHJcXG5cXHJcXG4gICAgLy8gVW4tcHJlbXVsdGlwbHkgYWxwaGEgYmVmb3JlIGFwcGx5aW5nIHRoZSBjb2xvciBtYXRyaXguIFNlZSBpc3N1ZSAjMzUzOS5cXHJcXG4gICAgaWYgKGMuYSA+IDAuMCkge1xcclxcbiAgICAgIGMucmdiIC89IGMuYTtcXHJcXG4gICAgfVxcclxcblxcclxcbiAgICB2ZWM0IHJlc3VsdDtcXHJcXG5cXHJcXG4gICAgcmVzdWx0LnIgPSAobVswXSAqIGMucik7XFxyXFxuICAgICAgICByZXN1bHQuciArPSAobVsxXSAqIGMuZyk7XFxyXFxuICAgICAgICByZXN1bHQuciArPSAobVsyXSAqIGMuYik7XFxyXFxuICAgICAgICByZXN1bHQuciArPSAobVszXSAqIGMuYSk7XFxyXFxuICAgICAgICByZXN1bHQuciArPSBtWzRdO1xcclxcblxcclxcbiAgICByZXN1bHQuZyA9IChtWzVdICogYy5yKTtcXHJcXG4gICAgICAgIHJlc3VsdC5nICs9IChtWzZdICogYy5nKTtcXHJcXG4gICAgICAgIHJlc3VsdC5nICs9IChtWzddICogYy5iKTtcXHJcXG4gICAgICAgIHJlc3VsdC5nICs9IChtWzhdICogYy5hKTtcXHJcXG4gICAgICAgIHJlc3VsdC5nICs9IG1bOV07XFxyXFxuXFxyXFxuICAgIHJlc3VsdC5iID0gKG1bMTBdICogYy5yKTtcXHJcXG4gICAgICAgcmVzdWx0LmIgKz0gKG1bMTFdICogYy5nKTtcXHJcXG4gICAgICAgcmVzdWx0LmIgKz0gKG1bMTJdICogYy5iKTtcXHJcXG4gICAgICAgcmVzdWx0LmIgKz0gKG1bMTNdICogYy5hKTtcXHJcXG4gICAgICAgcmVzdWx0LmIgKz0gbVsxNF07XFxyXFxuXFxyXFxuICAgIHJlc3VsdC5hID0gKG1bMTVdICogYy5yKTtcXHJcXG4gICAgICAgcmVzdWx0LmEgKz0gKG1bMTZdICogYy5nKTtcXHJcXG4gICAgICAgcmVzdWx0LmEgKz0gKG1bMTddICogYy5iKTtcXHJcXG4gICAgICAgcmVzdWx0LmEgKz0gKG1bMThdICogYy5hKTtcXHJcXG4gICAgICAgcmVzdWx0LmEgKz0gbVsxOV07XFxyXFxuXFxyXFxuICAgIHZlYzMgcmdiID0gbWl4KGMucmdiLCByZXN1bHQucmdiLCB1QWxwaGEpO1xcclxcblxcclxcbiAgICAvLyBQcmVtdWx0aXBseSBhbHBoYSBhZ2Fpbi5cXHJcXG4gICAgcmdiICo9IHJlc3VsdC5hO1xcclxcblxcclxcbiAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KHJnYiwgcmVzdWx0LmEpO1xcclxcbn1cXHJcXG5cIjtcbmV4cG9ydHMuQ29sb3JNYXRyaXhGaWx0ZXIgPSBDb2xvck1hdHJpeEZpbHRlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgTWF0aFNldHRpbmdzXzEgPSByZXF1aXJlKFwiLi9NYXRoU2V0dGluZ3NcIik7XG5jbGFzcyBDb2xvclNldHRpbmdzIHtcbiAgICBzdGF0aWMgcHJlbXVsdGlwbHlUaW50KHRpbnQsIGFscGhhKSB7XG4gICAgICAgIGlmIChhbHBoYSA9PT0gMS4wKSB7XG4gICAgICAgICAgICByZXR1cm4gKGFscGhhICogMjU1IDw8IDI0KSArIHRpbnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFscGhhID09PSAwLjApIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHZhciBSID0gKCh0aW50ID4+IDE2KSAmIDB4RkYpO1xuICAgICAgICB2YXIgRyA9ICgodGludCA+PiA4KSAmIDB4RkYpO1xuICAgICAgICB2YXIgQiA9ICh0aW50ICYgMHhGRik7XG4gICAgICAgIFIgPSAoKFIgKiBhbHBoYSkgKyAwLjUpIHwgMDtcbiAgICAgICAgRyA9ICgoRyAqIGFscGhhKSArIDAuNSkgfCAwO1xuICAgICAgICBCID0gKChCICogYWxwaGEpICsgMC41KSB8IDA7XG4gICAgICAgIHJldHVybiAoYWxwaGEgKiAyNTUgPDwgMjQpICsgKFIgPDwgMTYpICsgKEcgPDwgOCkgKyBCO1xuICAgIH1cbiAgICBzdGF0aWMgcHJlbXVsdGlwbHlUaW50VG9SZ2JhKHRpbnQsIGFscGhhLCBvdXQsIHByZW11bHRpcGx5KSB7XG4gICAgICAgIG91dCA9IG91dCB8fCBuZXcgRmxvYXQzMkFycmF5KDQpO1xuICAgICAgICBvdXRbMF0gPSAoKHRpbnQgPj4gMTYpICYgMHhGRikgLyAyNTUuMDtcbiAgICAgICAgb3V0WzFdID0gKCh0aW50ID4+IDgpICYgMHhGRikgLyAyNTUuMDtcbiAgICAgICAgb3V0WzJdID0gKHRpbnQgJiAweEZGKSAvIDI1NS4wO1xuICAgICAgICBpZiAocHJlbXVsdGlwbHkgfHwgcHJlbXVsdGlwbHkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgb3V0WzBdICo9IGFscGhhO1xuICAgICAgICAgICAgb3V0WzFdICo9IGFscGhhO1xuICAgICAgICAgICAgb3V0WzJdICo9IGFscGhhO1xuICAgICAgICB9XG4gICAgICAgIG91dFszXSA9IGFscGhhO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0U2luZ2xlQ29sb3IoY29sb3IpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjb2xvciA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoU2V0dGluZ3NfMS5NYXRoU2V0dGluZ3MuaGV4MnN0cmluZyhjb2xvcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGNvbG9yID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaWYgKGNvbG9yLmluZGV4T2YoJzB4JykgPT09IDApIHtcbiAgICAgICAgICAgICAgICBjb2xvciA9IGNvbG9yLnJlcGxhY2UoJzB4JywgJyMnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29sb3I7XG4gICAgfVxuICAgIHN0YXRpYyBnZXRDb2xvcihjb2xvcikge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoY29sb3IpKSB7XG4gICAgICAgICAgICByZXR1cm4gQ29sb3JTZXR0aW5ncy5nZXRTaW5nbGVDb2xvcihjb2xvcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbG9yLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgY29sb3JbaV0gPSBDb2xvclNldHRpbmdzLmdldFNpbmdsZUNvbG9yKGNvbG9yW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjb2xvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgcHJlbXVsdGlwbHlSZ2JhKHJnYiwgYWxwaGEsIG91dCwgcHJlbXVsdGlwbHkpIHtcbiAgICAgICAgb3V0ID0gb3V0IHx8IG5ldyBGbG9hdDMyQXJyYXkoNCk7XG4gICAgICAgIGlmIChwcmVtdWx0aXBseSB8fCBwcmVtdWx0aXBseSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBvdXRbMF0gPSByZ2JbMF0gKiBhbHBoYTtcbiAgICAgICAgICAgIG91dFsxXSA9IHJnYlsxXSAqIGFscGhhO1xuICAgICAgICAgICAgb3V0WzJdID0gcmdiWzJdICogYWxwaGE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvdXRbMF0gPSByZ2JbMF07XG4gICAgICAgICAgICBvdXRbMV0gPSByZ2JbMV07XG4gICAgICAgICAgICBvdXRbMl0gPSByZ2JbMl07XG4gICAgICAgIH1cbiAgICAgICAgb3V0WzNdID0gYWxwaGE7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIC8qKlxuKiBDb252ZXJ0cyBhIGhleGFkZWNpbWFsIGNvbG9yIG51bWJlciB0byBhbiBbUiwgRywgQl0gYXJyYXkgb2Ygbm9ybWFsaXplZCBmbG9hdHMgKG51bWJlcnMgZnJvbSAwLjAgdG8gMS4wKS5cbipcbiogQGV4YW1wbGVcbiogUElYSS51dGlscy5oZXgycmdiKDB4ZmZmZmZmKTsgLy8gcmV0dXJucyBbMSwgMSwgMV1cbiogQG1lbWJlcm9mIFBJWEkudXRpbHNcbiogQGZ1bmN0aW9uIGhleDJyZ2JcbiogQHBhcmFtIHtudW1iZXJ9IGhleCAtIFRoZSBoZXhhZGVjaW1hbCBudW1iZXIgdG8gY29udmVydFxuKiBAcGFyYW0gIHtudW1iZXJbXX0gW291dD1bXV0gSWYgc3VwcGxpZWQsIHRoaXMgYXJyYXkgd2lsbCBiZSB1c2VkIHJhdGhlciB0aGFuIHJldHVybmluZyBhIG5ldyBvbmVcbiogQHJldHVybiB7bnVtYmVyW119IEFuIGFycmF5IHJlcHJlc2VudGluZyB0aGUgW1IsIEcsIEJdIG9mIHRoZSBjb2xvciB3aGVyZSBhbGwgdmFsdWVzIGFyZSBmbG9hdHMuXG4qL1xuICAgIHN0YXRpYyBoZXgycmdiKGhleCwgb3V0ID0gbnVsbCkge1xuICAgICAgICBvdXQgPSBvdXQgfHwgW107XG4gICAgICAgIG91dFswXSA9ICgoaGV4ID4+IDE2KSAmIDB4RkYpIC8gMjU1O1xuICAgICAgICBvdXRbMV0gPSAoKGhleCA+PiA4KSAmIDB4RkYpIC8gMjU1O1xuICAgICAgICBvdXRbMl0gPSAoaGV4ICYgMHhGRikgLyAyNTU7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIC8qKlxuKiBDb252ZXJ0cyBhIGNvbG9yIGFzIGFuIFtSLCBHLCBCXSBhcnJheSBvZiBub3JtYWxpemVkIGZsb2F0cyB0byBhIGhleGFkZWNpbWFsIG51bWJlci5cbipcbiogQGV4YW1wbGVcbiogUElYSS51dGlscy5yZ2IyaGV4KFsxLCAxLCAxXSk7IC8vIHJldHVybnMgMHhmZmZmZmZcbiogQG1lbWJlcm9mIFBJWEkudXRpbHNcbiogQGZ1bmN0aW9uIHJnYjJoZXhcbiogQHBhcmFtIHtudW1iZXJbXX0gcmdiIC0gQXJyYXkgb2YgbnVtYmVycyB3aGVyZSBhbGwgdmFsdWVzIGFyZSBub3JtYWxpemVkIGZsb2F0cyBmcm9tIDAuMCB0byAxLjAuXG4qIEByZXR1cm4ge251bWJlcn0gTnVtYmVyIGluIGhleGFkZWNpbWFsLlxuKi9cbiAgICBzdGF0aWMgcmdiMmhleChyZ2IpIHtcbiAgICAgICAgcmV0dXJuICgoKHJnYlswXSAqIDI1NSkgPDwgMTYpICsgKChyZ2JbMV0gKiAyNTUpIDw8IDgpICsgKHJnYlsyXSAqIDI1NSB8IDApKTtcbiAgICB9XG59XG5leHBvcnRzLkNvbG9yU2V0dGluZ3MgPSBDb2xvclNldHRpbmdzO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBEaXNwbGF5T2JqZWN0XzEgPSByZXF1aXJlKFwiLi9EaXNwbGF5T2JqZWN0XCIpO1xuY29uc3QgRXZlbnRfMSA9IHJlcXVpcmUoXCIuL0V2ZW50XCIpO1xuY29uc3QgVXRpbHNTZXR0aW5nc18xID0gcmVxdWlyZShcIi4vVXRpbHNTZXR0aW5nc1wiKTtcbmNvbnN0IERpc3BsYXlTZXR0aW5nc18xID0gcmVxdWlyZShcIi4vRGlzcGxheVNldHRpbmdzXCIpO1xuY2xhc3MgQ29udGFpbmVyIGV4dGVuZHMgRGlzcGxheU9iamVjdF8xLkRpc3BsYXlPYmplY3Qge1xuICAgIGRlc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyLmRlc3RydWN0b3IoKTtcbiAgICAgICAgaWYgKHRoaXMuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIHdoaWxlICh0aGlzLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGxldCBjaGlsZCA9IHRoaXMuY2hpbGRyZW4uc2hpZnQoKTtcbiAgICAgICAgICAgICAgICBjaGlsZC5kZXN0cnVjdG9yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IG51bGw7XG4gICAgICAgIHRoaXMuc29ydERpcnR5ID0gbnVsbDtcbiAgICAgICAgdGhpcy5zb3J0YWJsZUNoaWxkcmVuID0gbnVsbDtcbiAgICAgICAgdGhpcy5jb250YWluZXJVcGRhdGVUcmFuc2Zvcm0gPSBudWxsO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5jb250YWluZXJVcGRhdGVUcmFuc2Zvcm0gPSB0aGlzLnVwZGF0ZVRyYW5zZm9ybTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBhcnJheSBvZiBjaGlsZHJlbiBvZiB0aGlzIGNvbnRhaW5lci5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7UElYSS5EaXNwbGF5T2JqZWN0W119XG4gICAgICAgICAqIEByZWFkb25seVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgICogSWYgc2V0IHRvIHRydWUsIHRoZSBjb250YWluZXIgd2lsbCBzb3J0IGl0cyBjaGlsZHJlbiBieSB6SW5kZXggdmFsdWVcbiAgICAgICAgICogd2hlbiB1cGRhdGVUcmFuc2Zvcm0oKSBpcyBjYWxsZWQsIG9yIG1hbnVhbGx5IGlmIHNvcnRDaGlsZHJlbigpIGlzIGNhbGxlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyBhY3R1YWxseSBjaGFuZ2VzIHRoZSBvcmRlciBvZiBlbGVtZW50cyBpbiB0aGUgYXJyYXksIHNvIHNob3VsZCBiZSB0cmVhdGVkXG4gICAgICAgICAqIGFzIGEgYmFzaWMgc29sdXRpb24gdGhhdCBpcyBub3QgcGVyZm9ybWFudCBjb21wYXJlZCB0byBvdGhlciBzb2x1dGlvbnMsXG4gICAgICAgICAqIHN1Y2ggYXMgQGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3BpeGlqcy9waXhpLWRpc3BsYXlcbiAgICAgICAgICpcbiAgICAgICAgICogQWxzbyBiZSBhd2FyZSBvZiB0aGF0IHRoaXMgbWF5IG5vdCB3b3JrIG5pY2VseSB3aXRoIHRoZSBhZGRDaGlsZEF0KCkgZnVuY3Rpb24sXG4gICAgICAgICAqIGFzIHRoZSB6SW5kZXggc29ydGluZyBtYXkgY2F1c2UgdGhlIGNoaWxkIHRvIGF1dG9tYXRpY2FsbHkgc29ydGVkIHRvIGFub3RoZXIgcG9zaXRpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBzZWUgUElYSS5zZXR0aW5ncy5TT1JUQUJMRV9DSElMRFJFTlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zb3J0YWJsZUNoaWxkcmVuID0gRGlzcGxheVNldHRpbmdzXzEuRGlzcGxheVNldHRpbmdzLlNPUlRBQkxFX0NISUxEUkVOO1xuICAgICAgICAvKipcbiAgICAgICAgICogU2hvdWxkIGNoaWxkcmVuIGJlIHNvcnRlZCBieSB6SW5kZXggYXQgdGhlIG5leHQgdXBkYXRlVHJhbnNmb3JtIGNhbGwuXG4gICAgICAgICAqIFdpbGwgZ2V0IGF1dG9tYXRpY2FsbHkgc2V0IHRvIHRydWUgaWYgYSBuZXcgY2hpbGQgaXMgYWRkZWQsIG9yIGlmIGEgY2hpbGQncyB6SW5kZXggY2hhbmdlcy5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc29ydERpcnR5ID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlZCB3aGVuIGEgRGlzcGxheU9iamVjdCBpcyBhZGRlZCB0byB0aGlzIENvbnRhaW5lci5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV2ZW50IFBJWEkuQ29udGFpbmVyI2NoaWxkQWRkZWRcbiAgICAgICAgICogQHBhcmFtIHtQSVhJLkRpc3BsYXlPYmplY3R9IGNoaWxkIC0gVGhlIGNoaWxkIGFkZGVkIHRvIHRoZSBDb250YWluZXIuXG4gICAgICAgICAqIEBwYXJhbSB7UElYSS5Db250YWluZXJ9IGNvbnRhaW5lciAtIFRoZSBjb250YWluZXIgdGhhdCBhZGRlZCB0aGUgY2hpbGQuXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIFRoZSBjaGlsZHJlbidzIGluZGV4IG9mIHRoZSBhZGRlZCBjaGlsZC5cbiAgICAgICAgICovXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlZCB3aGVuIGEgRGlzcGxheU9iamVjdCBpcyByZW1vdmVkIGZyb20gdGhpcyBDb250YWluZXIuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBldmVudCBQSVhJLkRpc3BsYXlPYmplY3QjcmVtb3ZlZEZyb21cbiAgICAgICAgICogQHBhcmFtIHtQSVhJLkRpc3BsYXlPYmplY3R9IGNoaWxkIC0gVGhlIGNoaWxkIHJlbW92ZWQgZnJvbSB0aGUgQ29udGFpbmVyLlxuICAgICAgICAgKiBAcGFyYW0ge1BJWEkuQ29udGFpbmVyfSBjb250YWluZXIgLSBUaGUgY29udGFpbmVyIHRoYXQgcmVtb3ZlZCByZW1vdmVkIHRoZSBjaGlsZC5cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gVGhlIGZvcm1lciBjaGlsZHJlbidzIGluZGV4IG9mIHRoZSByZW1vdmVkIGNoaWxkXG4gICAgICAgICAqL1xuICAgIH1cbiAgICAvKipcbiAqIFJldHVybnMgdGhlIGRpc3BsYXkgb2JqZWN0IGluIHRoZSBjb250YWluZXIuXG4gKlxuICogQG1ldGhvZCBnZXRDaGlsZEJ5TmFtZVxuICogQG1lbWJlcm9mIFBJWEkuQ29udGFpbmVyI1xuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBJbnN0YW5jZSBuYW1lLlxuICogQHJldHVybiB7UElYSS5EaXNwbGF5T2JqZWN0fSBUaGUgY2hpbGQgd2l0aCB0aGUgc3BlY2lmaWVkIG5hbWUuXG4gKi9cbiAgICBnZXRDaGlsZEJ5TmFtZShuYW1lKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuY2hpbGRyZW5baV0ubmFtZSA9PT0gbmFtZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGFibGUgbWV0aG9kIHRoYXQgY2FuIGJlIHVzZWQgYnkgQ29udGFpbmVyIHN1YmNsYXNzZXMgd2hlbmV2ZXIgdGhlIGNoaWxkcmVuIGFycmF5IGlzIG1vZGlmaWVkXG4gICAgICpcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgb25DaGlsZHJlbkNoYW5nZShvcHRpb25zKSB7XG4gICAgICAgIC8qIGVtcHR5ICovXG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBBZGRzIG9uZSBvciBtb3JlIGNoaWxkcmVuIHRvIHRoZSBjb250YWluZXIuXG4gICAgICpcbiAgICAgKiBNdWx0aXBsZSBpdGVtcyBjYW4gYmUgYWRkZWQgbGlrZSBzbzogYG15Q29udGFpbmVyLmFkZENoaWxkKHRoaW5nT25lLCB0aGluZ1R3bywgdGhpbmdUaHJlZSlgXG4gICAgICpcbiAgICAgKiBAcGFyYW0gey4uLlBJWEkuRGlzcGxheU9iamVjdH0gY2hpbGQgLSBUaGUgRGlzcGxheU9iamVjdChzKSB0byBhZGQgdG8gdGhlIGNvbnRhaW5lclxuICAgICAqIEByZXR1cm4ge1BJWEkuRGlzcGxheU9iamVjdH0gVGhlIGZpcnN0IGNoaWxkIHRoYXQgd2FzIGFkZGVkLlxuICAgICAqL1xuICAgIGFkZENoaWxkKGNoaWxkKSB7XG4gICAgICAgIHZhciBhcmd1bWVudHMkMSA9IGFyZ3VtZW50cztcbiAgICAgICAgdmFyIGFyZ3VtZW50c0xlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIC8vIGlmIHRoZXJlIGlzIG9ubHkgb25lIGFyZ3VtZW50IHdlIGNhbiBieXBhc3MgbG9vcGluZyB0aHJvdWdoIHRoZSB0aGVtXG4gICAgICAgIGlmIChhcmd1bWVudHNMZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAvLyBsb29wIHRocm91Z2ggdGhlIGFyZ3VtZW50cyBwcm9wZXJ0eSBhbmQgYWRkIGFsbCBjaGlsZHJlblxuICAgICAgICAgICAgLy8gdXNlIGl0IHRoZSByaWdodCB3YXkgKC5sZW5ndGggYW5kIFtpXSkgc28gdGhhdCB0aGlzIGZ1bmN0aW9uIGNhbiBzdGlsbCBiZSBvcHRpbWl6ZWQgYnkgSlMgcnVudGltZXNcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZENoaWxkKGFyZ3VtZW50cyQxW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGlmIHRoZSBjaGlsZCBoYXMgYSBwYXJlbnQgdGhlbiBsZXRzIHJlbW92ZSBpdCBhcyBQaXhpSlMgb2JqZWN0cyBjYW4gb25seSBleGlzdCBpbiBvbmUgcGxhY2VcbiAgICAgICAgICAgIGlmIChjaGlsZC5wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICBjaGlsZC5wYXJlbnQucmVtb3ZlQ2hpbGQoY2hpbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2hpbGQucGFyZW50ID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuc29ydERpcnR5ID0gdHJ1ZTtcbiAgICAgICAgICAgIC8vIGVuc3VyZSBjaGlsZCB0cmFuc2Zvcm0gd2lsbCBiZSByZWNhbGN1bGF0ZWRcbiAgICAgICAgICAgIGNoaWxkLnRyYW5zZm9ybS5wYXJlbnRJRCA9IC0xO1xuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICAgICAgICAgIC8vIGVuc3VyZSBib3VuZHMgd2lsbCBiZSByZWNhbGN1bGF0ZWRcbiAgICAgICAgICAgIHRoaXMuX2JvdW5kc0lEKys7XG4gICAgICAgICAgICAvLyBUT0RPIC0gbGV0cyBlaXRoZXIgZG8gYWxsIGNhbGxiYWNrcyBvciBhbGwgZXZlbnRzLi4gbm90IGJvdGghXG4gICAgICAgICAgICB0aGlzLm9uQ2hpbGRyZW5DaGFuZ2UodGhpcy5jaGlsZHJlbi5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChFdmVudF8xLkV2ZW50LmdldEV2ZW50KFwiY2hpbGRBZGRlZFwiKSk7XG4gICAgICAgICAgICAvLyB0aGlzLmVtaXQoJ2NoaWxkQWRkZWQnLCBjaGlsZCwgdGhpcywgdGhpcy5jaGlsZHJlbi5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgIGNoaWxkLmRpc3BhdGNoRXZlbnQoRXZlbnRfMS5FdmVudC5nZXRFdmVudChcImFkZGVkXCIpKTtcbiAgICAgICAgICAgIC8vIGNoaWxkLmVtaXQoJ2FkZGVkJywgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNoaWxkO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogQWRkcyBhIGNoaWxkIHRvIHRoZSBjb250YWluZXIgYXQgYSBzcGVjaWZpZWQgaW5kZXguIElmIHRoZSBpbmRleCBpcyBvdXQgb2YgYm91bmRzIGFuIGVycm9yIHdpbGwgYmUgdGhyb3duXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BJWEkuRGlzcGxheU9iamVjdH0gY2hpbGQgLSBUaGUgY2hpbGQgdG8gYWRkXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gVGhlIGluZGV4IHRvIHBsYWNlIHRoZSBjaGlsZCBpblxuICAgICAqIEByZXR1cm4ge1BJWEkuRGlzcGxheU9iamVjdH0gVGhlIGNoaWxkIHRoYXQgd2FzIGFkZGVkLlxuICAgICAqL1xuICAgIGFkZENoaWxkQXQoY2hpbGQsIGluZGV4KSB7XG4gICAgICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPiB0aGlzLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKChjaGlsZCArIFwiYWRkQ2hpbGRBdDogVGhlIGluZGV4IFwiICsgaW5kZXggKyBcIiBzdXBwbGllZCBpcyBvdXQgb2YgYm91bmRzIFwiICsgKHRoaXMuY2hpbGRyZW4ubGVuZ3RoKSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGlsZC5wYXJlbnQpIHtcbiAgICAgICAgICAgIGNoaWxkLnBhcmVudC5yZW1vdmVDaGlsZChjaGlsZCk7XG4gICAgICAgIH1cbiAgICAgICAgY2hpbGQucGFyZW50ID0gdGhpcztcbiAgICAgICAgdGhpcy5zb3J0RGlydHkgPSB0cnVlO1xuICAgICAgICAvLyBlbnN1cmUgY2hpbGQgdHJhbnNmb3JtIHdpbGwgYmUgcmVjYWxjdWxhdGVkXG4gICAgICAgIGNoaWxkLnRyYW5zZm9ybS5fcGFyZW50SUQgPSAtMTtcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5zcGxpY2UoaW5kZXgsIDAsIGNoaWxkKTtcbiAgICAgICAgLy8gZW5zdXJlIGJvdW5kcyB3aWxsIGJlIHJlY2FsY3VsYXRlZFxuICAgICAgICB0aGlzLl9ib3VuZHNJRCsrO1xuICAgICAgICAvLyBUT0RPIC0gbGV0cyBlaXRoZXIgZG8gYWxsIGNhbGxiYWNrcyBvciBhbGwgZXZlbnRzLi4gbm90IGJvdGghXG4gICAgICAgIHRoaXMub25DaGlsZHJlbkNoYW5nZShpbmRleCk7XG4gICAgICAgIC8vIGNoaWxkLmVtaXQoJ2FkZGVkJywgdGhpcyk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChFdmVudF8xLkV2ZW50LmdldEV2ZW50KFwiY2hpbGRBZGRlZFwiKSk7XG4gICAgICAgIC8vIHRoaXMuZW1pdCgnY2hpbGRBZGRlZCcsIGNoaWxkLCB0aGlzLCBpbmRleCk7XG4gICAgICAgIHJldHVybiBjaGlsZDtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFN3YXBzIHRoZSBwb3NpdGlvbiBvZiAyIERpc3BsYXkgT2JqZWN0cyB3aXRoaW4gdGhpcyBjb250YWluZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BJWEkuRGlzcGxheU9iamVjdH0gY2hpbGQgLSBGaXJzdCBkaXNwbGF5IG9iamVjdCB0byBzd2FwXG4gICAgICogQHBhcmFtIHtQSVhJLkRpc3BsYXlPYmplY3R9IGNoaWxkMiAtIFNlY29uZCBkaXNwbGF5IG9iamVjdCB0byBzd2FwXG4gICAgICovXG4gICAgc3dhcENoaWxkcmVuKGNoaWxkLCBjaGlsZDIpIHtcbiAgICAgICAgaWYgKGNoaWxkID09PSBjaGlsZDIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW5kZXgxID0gdGhpcy5nZXRDaGlsZEluZGV4KGNoaWxkKTtcbiAgICAgICAgdmFyIGluZGV4MiA9IHRoaXMuZ2V0Q2hpbGRJbmRleChjaGlsZDIpO1xuICAgICAgICB0aGlzLmNoaWxkcmVuW2luZGV4MV0gPSBjaGlsZDI7XG4gICAgICAgIHRoaXMuY2hpbGRyZW5baW5kZXgyXSA9IGNoaWxkO1xuICAgICAgICB0aGlzLm9uQ2hpbGRyZW5DaGFuZ2UoaW5kZXgxIDwgaW5kZXgyID8gaW5kZXgxIDogaW5kZXgyKTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGluZGV4IHBvc2l0aW9uIG9mIGEgY2hpbGQgRGlzcGxheU9iamVjdCBpbnN0YW5jZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtQSVhJLkRpc3BsYXlPYmplY3R9IGNoaWxkIC0gVGhlIERpc3BsYXlPYmplY3QgaW5zdGFuY2UgdG8gaWRlbnRpZnlcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBpbmRleCBwb3NpdGlvbiBvZiB0aGUgY2hpbGQgZGlzcGxheSBvYmplY3QgdG8gaWRlbnRpZnlcbiAgICAgKi9cbiAgICBnZXRDaGlsZEluZGV4KGNoaWxkKSB7XG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMuY2hpbGRyZW4uaW5kZXhPZihjaGlsZCk7XG4gICAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHN1cHBsaWVkIERpc3BsYXlPYmplY3QgbXVzdCBiZSBhIGNoaWxkIG9mIHRoZSBjYWxsZXInKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBDaGFuZ2VzIHRoZSBwb3NpdGlvbiBvZiBhbiBleGlzdGluZyBjaGlsZCBpbiB0aGUgZGlzcGxheSBvYmplY3QgY29udGFpbmVyXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BJWEkuRGlzcGxheU9iamVjdH0gY2hpbGQgLSBUaGUgY2hpbGQgRGlzcGxheU9iamVjdCBpbnN0YW5jZSBmb3Igd2hpY2ggeW91IHdhbnQgdG8gY2hhbmdlIHRoZSBpbmRleCBudW1iZXJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggLSBUaGUgcmVzdWx0aW5nIGluZGV4IG51bWJlciBmb3IgdGhlIGNoaWxkIGRpc3BsYXkgb2JqZWN0XG4gICAgICovXG4gICAgc2V0Q2hpbGRJbmRleChjaGlsZCwgaW5kZXgpIHtcbiAgICAgICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSB0aGlzLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKChcIlRoZSBpbmRleCBcIiArIGluZGV4ICsgXCIgc3VwcGxpZWQgaXMgb3V0IG9mIGJvdW5kcyBcIiArICh0aGlzLmNoaWxkcmVuLmxlbmd0aCkpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY3VycmVudEluZGV4ID0gdGhpcy5nZXRDaGlsZEluZGV4KGNoaWxkKTtcbiAgICAgICAgVXRpbHNTZXR0aW5nc18xLlV0aWxzU2V0dGluZ3MucmVtb3ZlSXRlbXModGhpcy5jaGlsZHJlbiwgY3VycmVudEluZGV4LCAxKTsgLy8gcmVtb3ZlIGZyb20gb2xkIHBvc2l0aW9uXG4gICAgICAgIHRoaXMuY2hpbGRyZW4uc3BsaWNlKGluZGV4LCAwLCBjaGlsZCk7IC8vIGFkZCBhdCBuZXcgcG9zaXRpb25cbiAgICAgICAgdGhpcy5vbkNoaWxkcmVuQ2hhbmdlKGluZGV4KTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGNoaWxkIGF0IHRoZSBzcGVjaWZpZWQgaW5kZXhcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIFRoZSBpbmRleCB0byBnZXQgdGhlIGNoaWxkIGF0XG4gICAgICogQHJldHVybiB7UElYSS5EaXNwbGF5T2JqZWN0fSBUaGUgY2hpbGQgYXQgdGhlIGdpdmVuIGluZGV4LCBpZiBhbnkuXG4gICAgICovXG4gICAgZ2V0Q2hpbGRBdChpbmRleCkge1xuICAgICAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID49IHRoaXMuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKFwiZ2V0Q2hpbGRBdDogSW5kZXggKFwiICsgaW5kZXggKyBcIikgZG9lcyBub3QgZXhpc3QuXCIpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbltpbmRleF07XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIG9uZSBvciBtb3JlIGNoaWxkcmVuIGZyb20gdGhlIGNvbnRhaW5lci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Li4uUElYSS5EaXNwbGF5T2JqZWN0fSBjaGlsZCAtIFRoZSBEaXNwbGF5T2JqZWN0KHMpIHRvIHJlbW92ZVxuICAgICAqIEByZXR1cm4ge1BJWEkuRGlzcGxheU9iamVjdH0gVGhlIGZpcnN0IGNoaWxkIHRoYXQgd2FzIHJlbW92ZWQuXG4gICAgICovXG4gICAgcmVtb3ZlQ2hpbGQoY2hpbGQpIHtcbiAgICAgICAgdmFyIGFyZ3VtZW50cyQxID0gYXJndW1lbnRzO1xuICAgICAgICB2YXIgYXJndW1lbnRzTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgLy8gaWYgdGhlcmUgaXMgb25seSBvbmUgYXJndW1lbnQgd2UgY2FuIGJ5cGFzcyBsb29waW5nIHRocm91Z2ggdGhlIHRoZW1cbiAgICAgICAgaWYgKGFyZ3VtZW50c0xlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIC8vIGxvb3AgdGhyb3VnaCB0aGUgYXJndW1lbnRzIHByb3BlcnR5IGFuZCBhZGQgYWxsIGNoaWxkcmVuXG4gICAgICAgICAgICAvLyB1c2UgaXQgdGhlIHJpZ2h0IHdheSAoLmxlbmd0aCBhbmQgW2ldKSBzbyB0aGF0IHRoaXMgZnVuY3Rpb24gY2FuIHN0aWxsIGJlIG9wdGltaXplZCBieSBKUyBydW50aW1lc1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHNMZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlQ2hpbGQoYXJndW1lbnRzJDFbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5jaGlsZHJlbi5pbmRleE9mKGNoaWxkKTtcbiAgICAgICAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNoaWxkLnBhcmVudCA9IG51bGw7XG4gICAgICAgICAgICAvLyBlbnN1cmUgY2hpbGQgdHJhbnNmb3JtIHdpbGwgYmUgcmVjYWxjdWxhdGVkXG4gICAgICAgICAgICBjaGlsZC50cmFuc2Zvcm0uX3BhcmVudElEID0gLTE7XG4gICAgICAgICAgICBVdGlsc1NldHRpbmdzXzEuVXRpbHNTZXR0aW5ncy5yZW1vdmVJdGVtcyh0aGlzLmNoaWxkcmVuLCBpbmRleCwgMSk7XG4gICAgICAgICAgICAvLyBlbnN1cmUgYm91bmRzIHdpbGwgYmUgcmVjYWxjdWxhdGVkXG4gICAgICAgICAgICB0aGlzLl9ib3VuZHNJRCsrO1xuICAgICAgICAgICAgLy8gVE9ETyAtIGxldHMgZWl0aGVyIGRvIGFsbCBjYWxsYmFja3Mgb3IgYWxsIGV2ZW50cy4uIG5vdCBib3RoIVxuICAgICAgICAgICAgdGhpcy5vbkNoaWxkcmVuQ2hhbmdlKGluZGV4KTtcbiAgICAgICAgICAgIC8vIGNoaWxkLmVtaXQoJ3JlbW92ZWQnLCB0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChFdmVudF8xLkV2ZW50LmdldEV2ZW50KFwiY2hpbGRSZW1vdmVkXCIpKTtcbiAgICAgICAgICAgIC8vIHRoaXMuZW1pdCgnY2hpbGRSZW1vdmVkJywgY2hpbGQsIHRoaXMsIGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2hpbGQ7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGEgY2hpbGQgZnJvbSB0aGUgc3BlY2lmaWVkIGluZGV4IHBvc2l0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gVGhlIGluZGV4IHRvIGdldCB0aGUgY2hpbGQgZnJvbVxuICAgICAqIEByZXR1cm4ge1BJWEkuRGlzcGxheU9iamVjdH0gVGhlIGNoaWxkIHRoYXQgd2FzIHJlbW92ZWQuXG4gICAgICovXG4gICAgcmVtb3ZlQ2hpbGRBdChpbmRleCkge1xuICAgICAgICB2YXIgY2hpbGQgPSB0aGlzLmdldENoaWxkQXQoaW5kZXgpO1xuICAgICAgICAvLyBlbnN1cmUgY2hpbGQgdHJhbnNmb3JtIHdpbGwgYmUgcmVjYWxjdWxhdGVkLi5cbiAgICAgICAgY2hpbGQucGFyZW50ID0gbnVsbDtcbiAgICAgICAgY2hpbGQudHJhbnNmb3JtLl9wYXJlbnRJRCA9IC0xO1xuICAgICAgICBVdGlsc1NldHRpbmdzXzEuVXRpbHNTZXR0aW5ncy5yZW1vdmVJdGVtcyh0aGlzLmNoaWxkcmVuLCBpbmRleCwgMSk7XG4gICAgICAgIC8vIGVuc3VyZSBib3VuZHMgd2lsbCBiZSByZWNhbGN1bGF0ZWRcbiAgICAgICAgdGhpcy5fYm91bmRzSUQrKztcbiAgICAgICAgLy8gVE9ETyAtIGxldHMgZWl0aGVyIGRvIGFsbCBjYWxsYmFja3Mgb3IgYWxsIGV2ZW50cy4uIG5vdCBib3RoIVxuICAgICAgICB0aGlzLm9uQ2hpbGRyZW5DaGFuZ2UoaW5kZXgpO1xuICAgICAgICAvLyBjaGlsZC5lbWl0KCdyZW1vdmVkJywgdGhpcyk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChFdmVudF8xLkV2ZW50LmdldEV2ZW50KFwiY2hpbGRSZW1vdmVkXCIpKTtcbiAgICAgICAgLy8gdGhpcy5lbWl0KCdjaGlsZFJlbW92ZWQnLCBjaGlsZCwgdGhpcywgaW5kZXgpO1xuICAgICAgICByZXR1cm4gY2hpbGQ7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCBjaGlsZHJlbiBmcm9tIHRoaXMgY29udGFpbmVyIHRoYXQgYXJlIHdpdGhpbiB0aGUgYmVnaW4gYW5kIGVuZCBpbmRleGVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtiZWdpbkluZGV4PTBdIC0gVGhlIGJlZ2lubmluZyBwb3NpdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2VuZEluZGV4PXRoaXMuY2hpbGRyZW4ubGVuZ3RoXSAtIFRoZSBlbmRpbmcgcG9zaXRpb24uIERlZmF1bHQgdmFsdWUgaXMgc2l6ZSBvZiB0aGUgY29udGFpbmVyLlxuICAgICAqIEByZXR1cm5zIHtEaXNwbGF5T2JqZWN0W119IExpc3Qgb2YgcmVtb3ZlZCBjaGlsZHJlblxuICAgICAqL1xuICAgIHJlbW92ZUNoaWxkcmVuKGJlZ2luSW5kZXggPSAwLCBlbmRJbmRleCA9IEluZmluaXR5KSB7XG4gICAgICAgIGlmIChiZWdpbkluZGV4ID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIGJlZ2luSW5kZXggPSAwO1xuICAgICAgICB9XG4gICAgICAgIHZhciBiZWdpbiA9IGJlZ2luSW5kZXg7XG4gICAgICAgIHZhciBlbmQgPSB0eXBlb2YgZW5kSW5kZXggPT09ICdudW1iZXInID8gZW5kSW5kZXggOiB0aGlzLmNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgdmFyIHJhbmdlID0gZW5kIC0gYmVnaW47XG4gICAgICAgIHZhciByZW1vdmVkO1xuICAgICAgICBpZiAocmFuZ2UgPiAwICYmIHJhbmdlIDw9IGVuZCkge1xuICAgICAgICAgICAgcmVtb3ZlZCA9IHRoaXMuY2hpbGRyZW4uc3BsaWNlKGJlZ2luLCByYW5nZSk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlbW92ZWQubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICByZW1vdmVkW2ldLnBhcmVudCA9IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKHJlbW92ZWRbaV0udHJhbnNmb3JtKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZWRbaV0udHJhbnNmb3JtLl9wYXJlbnRJRCA9IC0xO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2JvdW5kc0lEKys7XG4gICAgICAgICAgICB0aGlzLm9uQ2hpbGRyZW5DaGFuZ2UoYmVnaW5JbmRleCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCByZW1vdmVkLmxlbmd0aDsgKytpJDEpIHtcbiAgICAgICAgICAgICAgICAvLyByZW1vdmVkW2kkMV0uZW1pdCgncmVtb3ZlZCcsIHRoaXMpO1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChFdmVudF8xLkV2ZW50LmdldEV2ZW50KFwiY2hpbGRSZW1vdmVkXCIpKTtcbiAgICAgICAgICAgICAgICAvLyB0aGlzLmVtaXQoJ2NoaWxkUmVtb3ZlZCcsIHJlbW92ZWRbaSQxXSwgdGhpcywgaSQxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZW1vdmVkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJhbmdlID09PSAwICYmIHRoaXMuY2hpbGRyZW4ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3JlbW92ZUNoaWxkcmVuOiBudW1lcmljIHZhbHVlcyBhcmUgb3V0c2lkZSB0aGUgYWNjZXB0YWJsZSByYW5nZS4nKTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFNvcnRzIGNoaWxkcmVuIGJ5IHpJbmRleC4gUHJldmlvdXMgb3JkZXIgaXMgbWFudGFpbmVkIGZvciAyIGNoaWxkcmVuIHdpdGggdGhlIHNhbWUgekluZGV4LlxuICAgICAqL1xuICAgIHNvcnRDaGlsZHJlbigpIHtcbiAgICAgICAgdmFyIHNvcnRSZXF1aXJlZCA9IGZhbHNlO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgaiA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgajsgKytpKSB7XG4gICAgICAgICAgICB2YXIgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgY2hpbGQuX2xhc3RTb3J0ZWRJbmRleCA9IGk7XG4gICAgICAgICAgICBpZiAoIXNvcnRSZXF1aXJlZCAmJiBjaGlsZC56SW5kZXggIT09IDApIHtcbiAgICAgICAgICAgICAgICBzb3J0UmVxdWlyZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzb3J0UmVxdWlyZWQgJiYgdGhpcy5jaGlsZHJlbi5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuLnNvcnQoQ29udGFpbmVyLnNvcnRDaGlsZHJlbik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zb3J0RGlydHkgPSBmYWxzZTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIHRyYW5zZm9ybSBvbiBhbGwgY2hpbGRyZW4gb2YgdGhpcyBjb250YWluZXIgZm9yIHJlbmRlcmluZ1xuICAgICAqL1xuICAgIHVwZGF0ZVRyYW5zZm9ybSgpIHtcbiAgICAgICAgaWYgKHRoaXMuc29ydGFibGVDaGlsZHJlbiAmJiB0aGlzLnNvcnREaXJ0eSkge1xuICAgICAgICAgICAgdGhpcy5zb3J0Q2hpbGRyZW4oKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9ib3VuZHNJRCsrO1xuICAgICAgICB0aGlzLnRyYW5zZm9ybS51cGRhdGVUcmFuc2Zvcm0odGhpcy5wYXJlbnQudHJhbnNmb3JtKTtcbiAgICAgICAgLy8gVE9ETzogY2hlY2sgcmVuZGVyIGZsYWdzLCBob3cgdG8gcHJvY2VzcyBzdHVmZiBoZXJlXG4gICAgICAgIHRoaXMud29ybGRBbHBoYSA9IHRoaXMuYWxwaGEgKiB0aGlzLnBhcmVudC53b3JsZEFscGhhO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgaiA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgajsgKytpKSB7XG4gICAgICAgICAgICB2YXIgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgaWYgKGNoaWxkLnZpc2libGUpIHtcbiAgICAgICAgICAgICAgICBjaGlsZC51cGRhdGVUcmFuc2Zvcm0oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogUmVjYWxjdWxhdGVzIHRoZSBib3VuZHMgb2YgdGhlIGNvbnRhaW5lci5cbiAgICAgKlxuICAgICAqL1xuICAgIGNhbGN1bGF0ZUJvdW5kcygpIHtcbiAgICAgICAgdGhpcy5fYm91bmRzLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuX2NhbGN1bGF0ZUJvdW5kcygpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV07XG4gICAgICAgICAgICBpZiAoIWNoaWxkLnZpc2libGUgfHwgIWNoaWxkLnJlbmRlcmFibGUpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNoaWxkLmNhbGN1bGF0ZUJvdW5kcygpO1xuICAgICAgICAgICAgLy8gVE9ETzogZmlsdGVyK21hc2ssIG5lZWQgdG8gbWFzayBib3RoIHNvbWVob3dcbiAgICAgICAgICAgIGlmIChjaGlsZC5fbWFzaykge1xuICAgICAgICAgICAgICAgIGNoaWxkLl9tYXNrLmNhbGN1bGF0ZUJvdW5kcygpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2JvdW5kcy5hZGRCb3VuZHNNYXNrKGNoaWxkLl9ib3VuZHMsIGNoaWxkLl9tYXNrLl9ib3VuZHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hpbGQuZmlsdGVyQXJlYSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2JvdW5kcy5hZGRCb3VuZHNBcmVhKGNoaWxkLl9ib3VuZHMsIGNoaWxkLmZpbHRlckFyZWEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYm91bmRzLmFkZEJvdW5kcyhjaGlsZC5fYm91bmRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9sYXN0Qm91bmRzSUQgPSB0aGlzLl9ib3VuZHNJRDtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFJlY2FsY3VsYXRlcyB0aGUgYm91bmRzIG9mIHRoZSBvYmplY3QuIE92ZXJyaWRlIHRoaXMgdG9cbiAgICAgKiBjYWxjdWxhdGUgdGhlIGJvdW5kcyBvZiB0aGUgc3BlY2lmaWMgb2JqZWN0IChub3QgaW5jbHVkaW5nIGNoaWxkcmVuKS5cbiAgICAgKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfY2FsY3VsYXRlQm91bmRzKCkge1xuICAgICAgICAvLyBGSUxMIElOLy9cbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgdGhlIG9iamVjdCB1c2luZyB0aGUgV2ViR0wgcmVuZGVyZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UElYSS5SZW5kZXJlcn0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXJcbiAgICAgKi9cbiAgICByZW5kZXIocmVuZGVyZXIpIHtcbiAgICAgICAgLy8gaWYgdGhlIG9iamVjdCBpcyBub3QgdmlzaWJsZSBvciB0aGUgYWxwaGEgaXMgMCB0aGVuIG5vIG5lZWQgdG8gcmVuZGVyIHRoaXMgZWxlbWVudFxuICAgICAgICBpZiAoIXRoaXMudmlzaWJsZSB8fCB0aGlzLndvcmxkQWxwaGEgPD0gMCB8fCAhdGhpcy5yZW5kZXJhYmxlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gZG8gYSBxdWljayBjaGVjayB0byBzZWUgaWYgdGhpcyBlbGVtZW50IGhhcyBhIG1hc2sgb3IgYSBmaWx0ZXIuXG4gICAgICAgIGlmICh0aGlzLl9tYXNrIHx8IHRoaXMuZmlsdGVycykge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJBZHZhbmNlZChyZW5kZXJlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXIocmVuZGVyZXIpO1xuICAgICAgICAgICAgLy8gc2ltcGxlIHJlbmRlciBjaGlsZHJlbiFcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBqID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgPCBqOyArK2kpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNoaWxkcmVuW2ldLnJlbmRlcihyZW5kZXJlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFJlbmRlciB0aGUgb2JqZWN0IHVzaW5nIHRoZSBXZWJHTCByZW5kZXJlciBhbmQgYWR2YW5jZWQgZmVhdHVyZXMuXG4gICAgICpcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHBhcmFtIHtQSVhJLlJlbmRlcmVyfSByZW5kZXJlciAtIFRoZSByZW5kZXJlclxuICAgICAqL1xuICAgIHJlbmRlckFkdmFuY2VkKHJlbmRlcmVyKSB7XG4gICAgICAgIHJlbmRlcmVyLmJhdGNoLmZsdXNoKCk7XG4gICAgICAgIHZhciBmaWx0ZXJzID0gdGhpcy5maWx0ZXJzO1xuICAgICAgICB2YXIgbWFzayA9IHRoaXMuX21hc2s7XG4gICAgICAgIC8vIHB1c2ggZmlsdGVyIGZpcnN0IGFzIHdlIG5lZWQgdG8gZW5zdXJlIHRoZSBzdGVuY2lsIGJ1ZmZlciBpcyBjb3JyZWN0IGZvciBhbnkgbWFza2luZ1xuICAgICAgICBpZiAoZmlsdGVycykge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9lbmFibGVkRmlsdGVycykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2VuYWJsZWRGaWx0ZXJzID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9lbmFibGVkRmlsdGVycy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaWx0ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZpbHRlcnNbaV0uZW5hYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9lbmFibGVkRmlsdGVycy5wdXNoKGZpbHRlcnNbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9lbmFibGVkRmlsdGVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZW5kZXJlci5maWx0ZXIucHVzaCh0aGlzLCB0aGlzLl9lbmFibGVkRmlsdGVycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hc2spIHtcbiAgICAgICAgICAgIHJlbmRlcmVyLm1hc2sucHVzaCh0aGlzLCB0aGlzLl9tYXNrKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBhZGQgdGhpcyBvYmplY3QgdG8gdGhlIGJhdGNoLCBvbmx5IHJlbmRlcmVkIGlmIGl0IGhhcyBhIHRleHR1cmUuXG4gICAgICAgIHRoaXMuX3JlbmRlcihyZW5kZXJlcik7XG4gICAgICAgIC8vIG5vdyBsb29wIHRocm91Z2ggdGhlIGNoaWxkcmVuIGFuZCBtYWtlIHN1cmUgdGhleSBnZXQgcmVuZGVyZWRcbiAgICAgICAgZm9yICh2YXIgaSQxID0gMCwgaiA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpJDEgPCBqOyBpJDErKykge1xuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbltpJDFdLnJlbmRlcihyZW5kZXJlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmVuZGVyZXIuYmF0Y2guZmx1c2goKTtcbiAgICAgICAgaWYgKG1hc2spIHtcbiAgICAgICAgICAgIHJlbmRlcmVyLm1hc2sucG9wKHRoaXMsIHRoaXMuX21hc2spO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmaWx0ZXJzICYmIHRoaXMuX2VuYWJsZWRGaWx0ZXJzICYmIHRoaXMuX2VuYWJsZWRGaWx0ZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmVuZGVyZXIuZmlsdGVyLnBvcCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBUbyBiZSBvdmVycmlkZGVuIGJ5IHRoZSBzdWJjbGFzc2VzLlxuICAgICAqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBwYXJhbSB7UElYSS5SZW5kZXJlcn0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXJcbiAgICAgKi9cbiAgICBfcmVuZGVyKHJlbmRlcmVyKSB7XG4gICAgICAgIC8vIHRoaXMgaXMgd2hlcmUgY29udGVudCBpdHNlbGYgZ2V0cyByZW5kZXJlZC4uLlxuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwgaW50ZXJuYWwgcmVmZXJlbmNlcyBhbmQgbGlzdGVuZXJzIGFzIHdlbGwgYXMgcmVtb3ZlcyBjaGlsZHJlbiBmcm9tIHRoZSBkaXNwbGF5IGxpc3QuXG4gICAgICogRG8gbm90IHVzZSBhIENvbnRhaW5lciBhZnRlciBjYWxsaW5nIGBkZXN0cm95YC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fGJvb2xlYW59IFtvcHRpb25zXSAtIE9wdGlvbnMgcGFyYW1ldGVyLiBBIGJvb2xlYW4gd2lsbCBhY3QgYXMgaWYgYWxsIG9wdGlvbnNcbiAgICAgKiAgaGF2ZSBiZWVuIHNldCB0byB0aGF0IHZhbHVlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jaGlsZHJlbj1mYWxzZV0gLSBpZiBzZXQgdG8gdHJ1ZSwgYWxsIHRoZSBjaGlsZHJlbiB3aWxsIGhhdmUgdGhlaXIgZGVzdHJveVxuICAgICAqICBtZXRob2QgY2FsbGVkIGFzIHdlbGwuICdvcHRpb25zJyB3aWxsIGJlIHBhc3NlZCBvbiB0byB0aG9zZSBjYWxscy5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRleHR1cmU9ZmFsc2VdIC0gT25seSB1c2VkIGZvciBjaGlsZCBTcHJpdGVzIGlmIG9wdGlvbnMuY2hpbGRyZW4gaXMgc2V0IHRvIHRydWVcbiAgICAgKiAgU2hvdWxkIGl0IGRlc3Ryb3kgdGhlIHRleHR1cmUgb2YgdGhlIGNoaWxkIHNwcml0ZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuYmFzZVRleHR1cmU9ZmFsc2VdIC0gT25seSB1c2VkIGZvciBjaGlsZCBTcHJpdGVzIGlmIG9wdGlvbnMuY2hpbGRyZW4gaXMgc2V0IHRvIHRydWVcbiAgICAgKiAgU2hvdWxkIGl0IGRlc3Ryb3kgdGhlIGJhc2UgdGV4dHVyZSBvZiB0aGUgY2hpbGQgc3ByaXRlXG4gICAgICovXG4gICAgZGVzdHJveShvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyLmRlc3Ryb3kob3B0aW9ucyk7XG4gICAgICAgIHRoaXMuc29ydERpcnR5ID0gZmFsc2U7XG4gICAgICAgIHZhciBkZXN0cm95Q2hpbGRyZW4gPSB0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Jvb2xlYW4nID8gb3B0aW9ucyA6IG9wdGlvbnMgJiYgb3B0aW9ucy5jaGlsZHJlbjtcbiAgICAgICAgdmFyIG9sZENoaWxkcmVuID0gdGhpcy5yZW1vdmVDaGlsZHJlbigwLCB0aGlzLmNoaWxkcmVuLmxlbmd0aCk7XG4gICAgICAgIGlmIChkZXN0cm95Q2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2xkQ2hpbGRyZW4ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBvbGRDaGlsZHJlbltpXS5kZXN0cm95KG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBUaGUgd2lkdGggb2YgdGhlIENvbnRhaW5lciwgc2V0dGluZyB0aGlzIHdpbGwgYWN0dWFsbHkgbW9kaWZ5IHRoZSBzY2FsZSB0byBhY2hpZXZlIHRoZSB2YWx1ZSBzZXRcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgd2lkdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjYWxlLnggKiB0aGlzLmdldExvY2FsQm91bmRzKCkud2lkdGg7XG4gICAgfVxuICAgIDtcbiAgICBzZXQgd2lkdGgodmFsdWUpIHtcbiAgICAgICAgdmFyIHdpZHRoID0gdGhpcy5nZXRMb2NhbEJvdW5kcygpLndpZHRoO1xuICAgICAgICBpZiAod2lkdGggIT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuc2NhbGUueCA9IHZhbHVlIC8gd2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNjYWxlLnggPSAxO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3dpZHRoID0gdmFsdWU7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBUaGUgaGVpZ2h0IG9mIHRoZSBDb250YWluZXIsIHNldHRpbmcgdGhpcyB3aWxsIGFjdHVhbGx5IG1vZGlmeSB0aGUgc2NhbGUgdG8gYWNoaWV2ZSB0aGUgdmFsdWUgc2V0XG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICovXG4gICAgZ2V0IGhlaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NhbGUueSAqIHRoaXMuZ2V0TG9jYWxCb3VuZHMoKS5oZWlnaHQ7XG4gICAgfVxuICAgIDtcbiAgICBzZXQgaGVpZ2h0KHZhbHVlKSB7XG4gICAgICAgIHZhciBoZWlnaHQgPSB0aGlzLmdldExvY2FsQm91bmRzKCkuaGVpZ2h0O1xuICAgICAgICBpZiAoaGVpZ2h0ICE9PSAwKSB7XG4gICAgICAgICAgICB0aGlzLnNjYWxlLnkgPSB2YWx1ZSAvIGhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2NhbGUueSA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faGVpZ2h0ID0gdmFsdWU7XG4gICAgfVxuICAgIDtcbiAgICBzdGF0aWMgc29ydENoaWxkcmVuKGEsIGIpIHtcbiAgICAgICAgaWYgKGEuekluZGV4ID09PSBiLnpJbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIGEuX2xhc3RTb3J0ZWRJbmRleCAtIGIuX2xhc3RTb3J0ZWRJbmRleDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYS56SW5kZXggLSBiLnpJbmRleDtcbiAgICB9XG59XG5leHBvcnRzLkNvbnRhaW5lciA9IENvbnRhaW5lcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgU3lzdGVtXzEgPSByZXF1aXJlKFwiLi9TeXN0ZW1cIik7XG5jb25zdCBEaXNwbGF5U2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL0Rpc3BsYXlTZXR0aW5nc1wiKTtcbmNsYXNzIENvbnRleHRTeXN0ZW0gZXh0ZW5kcyBTeXN0ZW1fMS5TeXN0ZW0ge1xuICAgIGNvbnN0cnVjdG9yKHJlbmRlcmVyKSB7XG4gICAgICAgIHN1cGVyKHJlbmRlcmVyKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVpdGhlciAxIG9yIDIgdG8gcmVmbGVjdCB0aGUgV2ViR0wgdmVyc2lvbiBiZWluZyB1c2VkXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICogQHJlYWRvbmx5XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLndlYkdMVmVyc2lvbiA9IDE7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFeHRlbnNpb25zIGJlaW5nIHVzZWRcbiAgICAgICAgICogQG1lbWJlciB7b2JqZWN0fVxuICAgICAgICAgKiBAcmVhZG9ubHlcbiAgICAgICAgICogQHByb3BlcnR5IHtXRUJHTF9kcmF3X2J1ZmZlcnN9IGRyYXdCdWZmZXJzIC0gV2ViR0wgdjEgZXh0ZW5zaW9uXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7V0VCR0xfZGVwdGhfdGV4dHVyZX0gZGVwdGhUZXh0dXJlIC0gV2ViR0wgdjEgZXh0ZW5zaW9uXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7T0VTX3RleHR1cmVfZmxvYXR9IGZsb2F0VGV4dHVyZSAtIFdlYkdMIHYxIGV4dGVuc2lvblxuICAgICAgICAgKiBAcHJvcGVydHkge1dFQkdMX2xvc2VfY29udGV4dH0gbG9zZUNvbnRleHQgLSBXZWJHTCB2MSBleHRlbnNpb25cbiAgICAgICAgICogQHByb3BlcnR5IHtPRVNfdmVydGV4X2FycmF5X29iamVjdH0gdmVydGV4QXJyYXlPYmplY3QgLSBXZWJHTCB2MSBleHRlbnNpb25cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZXh0ZW5zaW9ucyA9IHt9O1xuICAgICAgICAvLyBCaW5kIGZ1bmN0aW9uc1xuICAgICAgICB0aGlzLmhhbmRsZUNvbnRleHRMb3N0ID0gdGhpcy5oYW5kbGVDb250ZXh0TG9zdC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmhhbmRsZUNvbnRleHRSZXN0b3JlZCA9IHRoaXMuaGFuZGxlQ29udGV4dFJlc3RvcmVkLmJpbmQodGhpcyk7XG4gICAgICAgIHJlbmRlcmVyLnZpZXcuYWRkRXZlbnRMaXN0ZW5lcignd2ViZ2xjb250ZXh0bG9zdCcsIHRoaXMuaGFuZGxlQ29udGV4dExvc3QsIGZhbHNlKTtcbiAgICAgICAgcmVuZGVyZXIudmlldy5hZGRFdmVudExpc3RlbmVyKCd3ZWJnbGNvbnRleHRyZXN0b3JlZCcsIHRoaXMuaGFuZGxlQ29udGV4dFJlc3RvcmVkLCBmYWxzZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGB0cnVlYCBpZiB0aGUgY29udGV4dCBpcyBsb3N0XG4gICAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKi9cbiAgICBnZXQgaXNMb3N0KCkge1xuICAgICAgICByZXR1cm4gKCF0aGlzLmdsIHx8IHRoaXMuZ2wuaXNDb250ZXh0TG9zdCgpKTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIEhhbmRsZSB0aGUgY29udGV4dCBjaGFuZ2UgZXZlbnRcbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2wgbmV3IHdlYmdsIGNvbnRleHRcbiAgICAgKi9cbiAgICBjb250ZXh0Q2hhbmdlKGdsKSB7XG4gICAgICAgIHRoaXMuZ2wgPSBnbDtcbiAgICAgICAgLy8gcmVzdG9yZSBhIGNvbnRleHQgaWYgaXQgd2FzIHByZXZpb3VzbHkgbG9zdFxuICAgICAgICBpZiAoZ2wuaXNDb250ZXh0TG9zdCgpICYmIGdsLmdldEV4dGVuc2lvbignV0VCR0xfbG9zZV9jb250ZXh0JykpIHtcbiAgICAgICAgICAgIGdsLmdldEV4dGVuc2lvbignV0VCR0xfbG9zZV9jb250ZXh0JykucmVzdG9yZUNvbnRleHQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSB0aGUgY29udGV4dFxuICAgICAqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCAtIFdlYkdMIGNvbnRleHRcbiAgICAgKi9cbiAgICBpbml0RnJvbUNvbnRleHQoZ2wpIHtcbiAgICAgICAgdGhpcy5nbCA9IGdsO1xuICAgICAgICB0aGlzLnZhbGlkYXRlQ29udGV4dChnbCk7XG4gICAgICAgIHRoaXMucmVuZGVyZXIuZ2wgPSBnbDtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5DT05URVhUX1VJRCA9IENvbnRleHRTeXN0ZW0uQ09OVEVYVF9VSUQrKztcbiAgICAgICAgLy8gdGhpcy5kaXNwYXRjaEV2ZW50KEV2ZW50LmdldEV2ZW50KFwiY29udGV4dGNoYW5nZVwiKSlcbiAgICAgICAgdGhpcy5yZW5kZXJlci5ydW5uZXJzLmNvbnRleHRDaGFuZ2UucnVuKGdsKTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemUgZnJvbSBjb250ZXh0IG9wdGlvbnNcbiAgICAgKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9IVE1MQ2FudmFzRWxlbWVudC9nZXRDb250ZXh0XG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgLSBjb250ZXh0IGF0dHJpYnV0ZXNcbiAgICAgKi9cbiAgICBpbml0RnJvbU9wdGlvbnMob3B0aW9ucykge1xuICAgICAgICB2YXIgZ2wgPSB0aGlzLmNyZWF0ZUNvbnRleHQodGhpcy5yZW5kZXJlci52aWV3LCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5pbml0RnJvbUNvbnRleHQoZ2wpO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogSGVscGVyIGNsYXNzIHRvIGNyZWF0ZSBhIFdlYkdMIENvbnRleHRcbiAgICAgKlxuICAgICAqIEBwYXJhbSBjYW52YXMge0hUTUxDYW52YXNFbGVtZW50fSB0aGUgY2FudmFzIGVsZW1lbnQgdGhhdCB3ZSB3aWxsIGdldCB0aGUgY29udGV4dCBmcm9tXG4gICAgICogQHBhcmFtIG9wdGlvbnMge29iamVjdH0gQW4gb3B0aW9ucyBvYmplY3QgdGhhdCBnZXRzIHBhc3NlZCBpbiB0byB0aGUgY2FudmFzIGVsZW1lbnQgY29udGFpbmluZyB0aGUgY29udGV4dCBhdHRyaWJ1dGVzXG4gICAgICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9kb2NzL1dlYi9BUEkvSFRNTENhbnZhc0VsZW1lbnQvZ2V0Q29udGV4dFxuICAgICAqIEByZXR1cm4ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gdGhlIFdlYkdMIGNvbnRleHRcbiAgICAgKi9cbiAgICBjcmVhdGVDb250ZXh0KGNhbnZhcywgb3B0aW9ucykge1xuICAgICAgICB2YXIgZ2w7XG4gICAgICAgIGlmIChEaXNwbGF5U2V0dGluZ3NfMS5EaXNwbGF5U2V0dGluZ3MuUFJFRkVSX0VOViA+PSBEaXNwbGF5U2V0dGluZ3NfMS5EaXNwbGF5U2V0dGluZ3MuRU5WLldFQkdMMikge1xuICAgICAgICAgICAgZ2wgPSBjYW52YXMuZ2V0Q29udGV4dCgnd2ViZ2wyJywgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdsKSB7XG4gICAgICAgICAgICB0aGlzLndlYkdMVmVyc2lvbiA9IDI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLndlYkdMVmVyc2lvbiA9IDE7XG4gICAgICAgICAgICBnbCA9IGNhbnZhcy5nZXRDb250ZXh0KCd3ZWJnbCcsIG9wdGlvbnMpXG4gICAgICAgICAgICAgICAgfHwgY2FudmFzLmdldENvbnRleHQoJ2V4cGVyaW1lbnRhbC13ZWJnbCcsIG9wdGlvbnMpO1xuICAgICAgICAgICAgaWYgKCFnbCkge1xuICAgICAgICAgICAgICAgIC8vIGZhaWwsIG5vdCBhYmxlIHRvIGdldCBhIGNvbnRleHRcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IFdlYkdMLiBUcnkgdXNpbmcgdGhlIGNhbnZhcyByZW5kZXJlcicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuZ2wgPSBnbDtcbiAgICAgICAgdGhpcy5nZXRFeHRlbnNpb25zKCk7XG4gICAgICAgIHJldHVybiBnbDtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIEF1dG8tcG9wdWxhdGUgdGhlIGV4dGVuc2lvbnNcbiAgICAgKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBnZXRFeHRlbnNpb25zKCkge1xuICAgICAgICAvLyB0aW1lIHRvIHNldCB1cCBkZWZhdWx0IGV4dGVuc2lvbnMgdGhhdCBQaXhpIHVzZXMuXG4gICAgICAgIHZhciByZWYgPSB0aGlzO1xuICAgICAgICB2YXIgZ2wgPSByZWYuZ2w7XG4gICAgICAgIGlmICh0aGlzLndlYkdMVmVyc2lvbiA9PT0gMSkge1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLmV4dGVuc2lvbnMsIHtcbiAgICAgICAgICAgICAgICBkcmF3QnVmZmVyczogZ2wuZ2V0RXh0ZW5zaW9uKCdXRUJHTF9kcmF3X2J1ZmZlcnMnKSxcbiAgICAgICAgICAgICAgICBkZXB0aFRleHR1cmU6IGdsLmdldEV4dGVuc2lvbignV0VCS0lUX1dFQkdMX2RlcHRoX3RleHR1cmUnKSxcbiAgICAgICAgICAgICAgICBmbG9hdFRleHR1cmU6IGdsLmdldEV4dGVuc2lvbignT0VTX3RleHR1cmVfZmxvYXQnKSxcbiAgICAgICAgICAgICAgICBsb3NlQ29udGV4dDogZ2wuZ2V0RXh0ZW5zaW9uKCdXRUJHTF9sb3NlX2NvbnRleHQnKSxcbiAgICAgICAgICAgICAgICB2ZXJ0ZXhBcnJheU9iamVjdDogZ2wuZ2V0RXh0ZW5zaW9uKCdPRVNfdmVydGV4X2FycmF5X29iamVjdCcpXG4gICAgICAgICAgICAgICAgICAgIHx8IGdsLmdldEV4dGVuc2lvbignTU9aX09FU192ZXJ0ZXhfYXJyYXlfb2JqZWN0JylcbiAgICAgICAgICAgICAgICAgICAgfHwgZ2wuZ2V0RXh0ZW5zaW9uKCdXRUJLSVRfT0VTX3ZlcnRleF9hcnJheV9vYmplY3QnKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIHdlIGRvbid0IHVzZSBhbnkgc3BlY2lmaWMgV2ViR0wgMiBvbmVzIHlldCFcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgYSBsb3N0IHdlYmdsIGNvbnRleHRcbiAgICAgKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAcGFyYW0ge1dlYkdMQ29udGV4dEV2ZW50fSBldmVudCAtIFRoZSBjb250ZXh0IGxvc3QgZXZlbnQuXG4gICAgICovXG4gICAgaGFuZGxlQ29udGV4dExvc3QoZXZlbnQpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgYSByZXN0b3JlZCB3ZWJnbCBjb250ZXh0XG4gICAgICpcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgaGFuZGxlQ29udGV4dFJlc3RvcmVkKCkge1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnJ1bm5lcnMuY29udGV4dENoYW5nZS5ydW4odGhpcy5nbCk7XG4gICAgfVxuICAgIDtcbiAgICBkZXN0cm95KCkge1xuICAgICAgICB2YXIgdmlldyA9IHRoaXMucmVuZGVyZXIudmlldztcbiAgICAgICAgLy8gcmVtb3ZlIGxpc3RlbmVyc1xuICAgICAgICB2aWV3LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3dlYmdsY29udGV4dGxvc3QnLCB0aGlzLmhhbmRsZUNvbnRleHRMb3N0KTtcbiAgICAgICAgdmlldy5yZW1vdmVFdmVudExpc3RlbmVyKCd3ZWJnbGNvbnRleHRyZXN0b3JlZCcsIHRoaXMuaGFuZGxlQ29udGV4dFJlc3RvcmVkKTtcbiAgICAgICAgdGhpcy5nbC51c2VQcm9ncmFtKG51bGwpO1xuICAgICAgICBpZiAodGhpcy5leHRlbnNpb25zLmxvc2VDb250ZXh0KSB7XG4gICAgICAgICAgICB0aGlzLmV4dGVuc2lvbnMubG9zZUNvbnRleHQubG9zZUNvbnRleHQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogSGFuZGxlIHRoZSBwb3N0LXJlbmRlciBydW5uZXIgZXZlbnRcbiAgICAgKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBwb3N0cmVuZGVyKCkge1xuICAgICAgICB0aGlzLmdsLmZsdXNoKCk7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBWYWxpZGF0ZSBjb250ZXh0XG4gICAgICpcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsIC0gUmVuZGVyIGNvbnRleHRcbiAgICAgKi9cbiAgICB2YWxpZGF0ZUNvbnRleHQoZ2wpIHtcbiAgICAgICAgdmFyIGF0dHJpYnV0ZXMgPSBnbC5nZXRDb250ZXh0QXR0cmlidXRlcygpO1xuICAgICAgICAvLyB0aGlzIGlzIGdvaW5nIHRvIGJlIGZhaXJseSBzaW1wbGUgZm9yIG5vdy4uIGJ1dCBhdCBsZWFzdCB3ZSBoYXZlIHJvb20gdG8gZ3JvdyFcbiAgICAgICAgaWYgKCFhdHRyaWJ1dGVzLnN0ZW5jaWwpIHtcbiAgICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4gKi9cbiAgICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWNvbnNvbGUgKi9cbiAgICAgICAgICAgIGNvbnNvbGUud2FybignUHJvdmlkZWQgV2ViR0wgY29udGV4dCBkb2VzIG5vdCBoYXZlIGEgc3RlbmNpbCBidWZmZXIsIG1hc2tzIG1heSBub3QgcmVuZGVyIGNvcnJlY3RseScpO1xuICAgICAgICAgICAgLyogZXNsaW50LWVuYWJsZSBuby1jb25zb2xlICovXG4gICAgICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4gKi9cbiAgICAgICAgfVxuICAgIH1cbiAgICA7XG59XG5Db250ZXh0U3lzdGVtLkNPTlRFWFRfVUlEID0gMDtcbmV4cG9ydHMuQ29udGV4dFN5c3RlbSA9IENvbnRleHRTeXN0ZW07XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNsYXNzIENvdW50TGltaXRlciB7XG4gICAgY29uc3RydWN0b3IobWF4SXRlbXNQZXJGcmFtZSkge1xuICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRoZSBtYXhpbXVtIG51bWJlciBvZiBpdGVtcyB0aGF0IGNhbiBiZSBwcmVwYXJlZCBlYWNoIGZyYW1lLlxuICAgICAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tYXhJdGVtc1BlckZyYW1lID0gbWF4SXRlbXNQZXJGcmFtZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBudW1iZXIgb2YgaXRlbXMgdGhhdCBjYW4gYmUgcHJlcGFyZWQgaW4gdGhlIGN1cnJlbnQgZnJhbWUuXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLml0ZW1zTGVmdCA9IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc2V0cyBhbnkgY291bnRpbmcgcHJvcGVydGllcyB0byBzdGFydCBmcmVzaCBvbiBhIG5ldyBmcmFtZS5cbiAgICAgKi9cbiAgICBiZWdpbkZyYW1lKCkge1xuICAgICAgICB0aGlzLml0ZW1zTGVmdCA9IHRoaXMubWF4SXRlbXNQZXJGcmFtZTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB0byBzZWUgaWYgYW5vdGhlciBpdGVtIGNhbiBiZSB1cGxvYWRlZC4gVGhpcyBzaG91bGQgb25seSBiZSBjYWxsZWQgb25jZSBwZXIgaXRlbS5cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBJZiB0aGUgaXRlbSBpcyBhbGxvd2VkIHRvIGJlIHVwbG9hZGVkLlxuICAgICAqL1xuICAgIGFsbG93ZWRUb1VwbG9hZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXRlbXNMZWZ0LS0gPiAwO1xuICAgIH1cbiAgICA7XG59XG5leHBvcnRzLkNvdW50TGltaXRlciA9IENvdW50TGltaXRlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgQXJyYXlSZXNvdXJjZV8xID0gcmVxdWlyZShcIi4vQXJyYXlSZXNvdXJjZVwiKTtcbmNvbnN0IFdlYkdMU2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL1dlYkdMU2V0dGluZ3NcIik7XG5jbGFzcyBDdWJlUmVzb3VyY2UgZXh0ZW5kcyBBcnJheVJlc291cmNlXzEuQXJyYXlSZXNvdXJjZSB7XG4gICAgY29uc3RydWN0b3Ioc291cmNlLCBvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKHNvdXJjZSwgb3B0aW9ucyk7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICBpZiAodGhpcy5sZW5ndGggIT09IEN1YmVSZXNvdXJjZS5TSURFUykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKChcIkludmFsaWQgbGVuZ3RoLiBHb3QgXCIgKyAodGhpcy5sZW5ndGgpICsgXCIsIGV4cGVjdGVkIDZcIikpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgQ3ViZVJlc291cmNlLlNJREVTOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuaXRlbXNbaV0udGFyZ2V0ID0gV2ViR0xTZXR0aW5nc18xLldlYkdMU2V0dGluZ3MuVEFSR0VUUy5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1ggKyBpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmF1dG9Mb2FkICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgdGhpcy5sb2FkKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkIGJpbmRpbmdcbiAgICAgKlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqIEBwYXJhbSB7UElYSS5CYXNlVGV4dHVyZX0gYmFzZVRleHR1cmUgLSBwYXJlbnQgYmFzZSB0ZXh0dXJlXG4gICAgICovXG4gICAgYmluZChiYXNlVGV4dHVyZSkge1xuICAgICAgICBzdXBlci5iaW5kKGJhc2VUZXh0dXJlKTtcbiAgICAgICAgYmFzZVRleHR1cmUudGFyZ2V0ID0gV2ViR0xTZXR0aW5nc18xLldlYkdMU2V0dGluZ3MuVEFSR0VUUy5URVhUVVJFX0NVQkVfTUFQO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogVXBsb2FkIHRoZSByZXNvdXJjZVxuICAgICAqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaXMgc3VjY2Vzc1xuICAgICAqL1xuICAgIHVwbG9hZChyZW5kZXJlciwgYmFzZVRleHR1cmUsIGdsVGV4dHVyZSkge1xuICAgICAgICB2YXIgZGlydHkgPSB0aGlzLml0ZW1EaXJ0eUlkcztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBDdWJlUmVzb3VyY2UuU0lERVM7IGkrKykge1xuICAgICAgICAgICAgdmFyIHNpZGUgPSB0aGlzLml0ZW1zW2ldO1xuICAgICAgICAgICAgaWYgKGRpcnR5W2ldIDwgc2lkZS5kaXJ0eUlkKSB7XG4gICAgICAgICAgICAgICAgZGlydHlbaV0gPSBzaWRlLmRpcnR5SWQ7XG4gICAgICAgICAgICAgICAgaWYgKHNpZGUudmFsaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2lkZS5yZXNvdXJjZS51cGxvYWQocmVuZGVyZXIsIHNpZGUsIGdsVGV4dHVyZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICA7XG59XG4vKipcbiogTnVtYmVyIG9mIHRleHR1cmUgc2lkZXMgdG8gc3RvcmUgZm9yIEN1YmVSZXNvdXJjZXNcbipcbiogQG5hbWUgUElYSS5yZXNvdXJjZXMuQ3ViZVJlc291cmNlLlNJREVTXG4qIEBzdGF0aWNcbiogQG1lbWJlciB7bnVtYmVyfVxuKiBAZGVmYXVsdCA2XG4qL1xuQ3ViZVJlc291cmNlLlNJREVTID0gNjtcbmV4cG9ydHMuQ3ViZVJlc291cmNlID0gQ3ViZVJlc291cmNlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBCdWZmZXJSZXNvdXJjZV8xID0gcmVxdWlyZShcIi4vQnVmZmVyUmVzb3VyY2VcIik7XG5jbGFzcyBEZXB0aFJlc291cmNlIGV4dGVuZHMgQnVmZmVyUmVzb3VyY2VfMS5CdWZmZXJSZXNvdXJjZSB7XG4gICAgY29uc3RydWN0b3Ioc291cmNlLCBvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKHNvdXJjZSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIHVwbG9hZChyZW5kZXJlciwgYmFzZVRleHR1cmUsIGdsVGV4dHVyZSkge1xuICAgICAgICB2YXIgZ2wgPSByZW5kZXJlci5nbDtcbiAgICAgICAgZ2wucGl4ZWxTdG9yZWkoZ2wuVU5QQUNLX1BSRU1VTFRJUExZX0FMUEhBX1dFQkdMLCBiYXNlVGV4dHVyZS5wcmVtdWx0aXBseUFscGhhKTtcbiAgICAgICAgaWYgKGdsVGV4dHVyZS53aWR0aCA9PT0gYmFzZVRleHR1cmUud2lkdGggJiYgZ2xUZXh0dXJlLmhlaWdodCA9PT0gYmFzZVRleHR1cmUuaGVpZ2h0KSB7XG4gICAgICAgICAgICBnbC50ZXhTdWJJbWFnZTJEKGJhc2VUZXh0dXJlLnRhcmdldCwgMCwgMCwgMCwgYmFzZVRleHR1cmUud2lkdGgsIGJhc2VUZXh0dXJlLmhlaWdodCwgYmFzZVRleHR1cmUuZm9ybWF0LCBiYXNlVGV4dHVyZS50eXBlLCB0aGlzLmRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZ2xUZXh0dXJlLndpZHRoID0gYmFzZVRleHR1cmUud2lkdGg7XG4gICAgICAgICAgICBnbFRleHR1cmUuaGVpZ2h0ID0gYmFzZVRleHR1cmUuaGVpZ2h0O1xuICAgICAgICAgICAgZ2wudGV4SW1hZ2UyRChiYXNlVGV4dHVyZS50YXJnZXQsIDAsIGdsLkRFUFRIX0NPTVBPTkVOVDE2LCAvLyBOZWVkZWQgZm9yIGRlcHRoIHRvIHJlbmRlciBwcm9wZXJseSBpbiB3ZWJnbDIuMFxuICAgICAgICAgICAgYmFzZVRleHR1cmUud2lkdGgsIGJhc2VUZXh0dXJlLmhlaWdodCwgMCwgYmFzZVRleHR1cmUuZm9ybWF0LCBiYXNlVGV4dHVyZS50eXBlLCB0aGlzLmRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICA7XG59XG5leHBvcnRzLkRlcHRoUmVzb3VyY2UgPSBEZXB0aFJlc291cmNlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBGaWx0ZXJfMSA9IHJlcXVpcmUoXCIuL0ZpbHRlclwiKTtcbmNvbnN0IE1hdHJpeF8xID0gcmVxdWlyZShcIi4vTWF0cml4XCIpO1xuY29uc3QgUG9pbnRfMSA9IHJlcXVpcmUoXCIuLi9mbGFzaC9nZW9tL1BvaW50XCIpO1xuY2xhc3MgRGlzcGxhY2VtZW50RmlsdGVyIGV4dGVuZHMgRmlsdGVyXzEuRmlsdGVyIHtcbiAgICBjb25zdHJ1Y3RvcihzcHJpdGUsIHNjYWxlID0gMSkge1xuICAgICAgICB2YXIgbWFza01hdHJpeCA9IG5ldyBNYXRyaXhfMS5NYXRyaXgoKTtcbiAgICAgICAgc3ByaXRlLnJlbmRlcmFibGUgPSBmYWxzZTtcbiAgICAgICAgc3VwZXIoRGlzcGxhY2VtZW50RmlsdGVyLnZlcnRleCQ0LCBEaXNwbGFjZW1lbnRGaWx0ZXIuZnJhZ21lbnQkNSwgeyBtYXBTYW1wbGVyOiBzcHJpdGUuX3RleHR1cmUsIGZpbHRlck1hdHJpeDogbWFza01hdHJpeCwgc2NhbGU6IHsgeDogMSwgeTogMSB9LCByb3RhdGlvbjogbmV3IEZsb2F0MzJBcnJheShbMSwgMCwgMCwgMV0pLCB9KTtcbiAgICAgICAgdGhpcy5tYXNrU3ByaXRlID0gc3ByaXRlO1xuICAgICAgICB0aGlzLm1hc2tNYXRyaXggPSBtYXNrTWF0cml4O1xuICAgICAgICBpZiAoc2NhbGUgPT09IG51bGwgfHwgc2NhbGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgc2NhbGUgPSAyMDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogc2NhbGVYLCBzY2FsZVkgZm9yIGRpc3BsYWNlbWVudHNcbiAgICAgICAgICogQG1lbWJlciB7UElYSS5Qb2ludH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2NhbGUgPSBQb2ludF8xLlBvaW50LmdldFBvaW50KHNjYWxlLCBzY2FsZSk7XG4gICAgfVxuICAgIGRlc3RydWN0b3IoKSB7XG4gICAgICAgIGlmICh0aGlzLnNjYWxlKSB7XG4gICAgICAgICAgICB0aGlzLnNjYWxlLnJlY3ljbGUoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNjYWxlID0gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXBwbGllcyB0aGUgZmlsdGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQSVhJLnN5c3RlbXMuRmlsdGVyU3lzdGVtfSBmaWx0ZXJNYW5hZ2VyIC0gVGhlIG1hbmFnZXIuXG4gICAgICogQHBhcmFtIHtQSVhJLlJlbmRlclRleHR1cmV9IGlucHV0IC0gVGhlIGlucHV0IHRhcmdldC5cbiAgICAgKiBAcGFyYW0ge1BJWEkuUmVuZGVyVGV4dHVyZX0gb3V0cHV0IC0gVGhlIG91dHB1dCB0YXJnZXQuXG4gICAgICovXG4gICAgYXBwbHkoZmlsdGVyTWFuYWdlciwgaW5wdXQsIG91dHB1dCkge1xuICAgICAgICB0aGlzLnVuaWZvcm1zLmZpbHRlck1hdHJpeCA9IGZpbHRlck1hbmFnZXIuY2FsY3VsYXRlU3ByaXRlTWF0cml4KHRoaXMubWFza01hdHJpeCwgdGhpcy5tYXNrU3ByaXRlKTtcbiAgICAgICAgdGhpcy51bmlmb3Jtcy5zY2FsZS54ID0gdGhpcy5zY2FsZS54O1xuICAgICAgICB0aGlzLnVuaWZvcm1zLnNjYWxlLnkgPSB0aGlzLnNjYWxlLnk7XG4gICAgICAgIC8vIEV4dHJhY3Qgcm90YXRpb24gZnJvbSB3b3JsZCB0cmFuc2Zvcm1cbiAgICAgICAgdmFyIHd0ID0gdGhpcy5tYXNrU3ByaXRlLnRyYW5zZm9ybS53b3JsZFRyYW5zZm9ybTtcbiAgICAgICAgdmFyIGxlblggPSBNYXRoLnNxcnQoKHd0LmEgKiB3dC5hKSArICh3dC5iICogd3QuYikpO1xuICAgICAgICB2YXIgbGVuWSA9IE1hdGguc3FydCgod3QuYyAqIHd0LmMpICsgKHd0LmQgKiB3dC5kKSk7XG4gICAgICAgIGlmIChsZW5YICE9PSAwICYmIGxlblkgIT09IDApIHtcbiAgICAgICAgICAgIHRoaXMudW5pZm9ybXMucm90YXRpb25bMF0gPSB3dC5hIC8gbGVuWDtcbiAgICAgICAgICAgIHRoaXMudW5pZm9ybXMucm90YXRpb25bMV0gPSB3dC5iIC8gbGVuWDtcbiAgICAgICAgICAgIHRoaXMudW5pZm9ybXMucm90YXRpb25bMl0gPSB3dC5jIC8gbGVuWTtcbiAgICAgICAgICAgIHRoaXMudW5pZm9ybXMucm90YXRpb25bM10gPSB3dC5kIC8gbGVuWTtcbiAgICAgICAgfVxuICAgICAgICAvLyBkcmF3IHRoZSBmaWx0ZXIuLi5cbiAgICAgICAgZmlsdGVyTWFuYWdlci5hcHBseUZpbHRlcih0aGlzLCBpbnB1dCwgb3V0cHV0KTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFRoZSB0ZXh0dXJlIHVzZWQgZm9yIHRoZSBkaXNwbGFjZW1lbnQgbWFwLiBNdXN0IGJlIHBvd2VyIG9mIDIgc2l6ZWQgdGV4dHVyZS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge1BJWEkuVGV4dHVyZX1cbiAgICAgKi9cbiAgICBnZXQgbWFwKCkge1xuICAgICAgICByZXR1cm4gdGhpcy51bmlmb3Jtcy5tYXBTYW1wbGVyO1xuICAgIH1cbiAgICA7XG4gICAgc2V0IG1hcCh2YWx1ZSkge1xuICAgICAgICB0aGlzLnVuaWZvcm1zLm1hcFNhbXBsZXIgPSB2YWx1ZTtcbiAgICB9XG4gICAgO1xufVxuRGlzcGxhY2VtZW50RmlsdGVyLmZyYWdtZW50JDUgPSBcInZhcnlpbmcgdmVjMiB2RmlsdGVyQ29vcmQ7XFxyXFxudmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XFxyXFxuXFxyXFxudW5pZm9ybSB2ZWMyIHNjYWxlO1xcclxcbnVuaWZvcm0gbWF0MiByb3RhdGlvbjtcXHJcXG51bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjtcXHJcXG51bmlmb3JtIHNhbXBsZXIyRCBtYXBTYW1wbGVyO1xcclxcblxcclxcbnVuaWZvcm0gaGlnaHAgdmVjNCBpbnB1dFNpemU7XFxyXFxudW5pZm9ybSB2ZWM0IGlucHV0Q2xhbXA7XFxyXFxuXFxyXFxudm9pZCBtYWluKHZvaWQpXFxyXFxue1xcclxcbiAgdmVjNCBtYXAgPSAgdGV4dHVyZTJEKG1hcFNhbXBsZXIsIHZGaWx0ZXJDb29yZCk7XFxyXFxuXFxyXFxuICBtYXAgLT0gMC41O1xcclxcbiAgbWFwLnh5ID0gc2NhbGUgKiBpbnB1dFNpemUuencgKiAocm90YXRpb24gKiBtYXAueHkpO1xcclxcblxcclxcbiAgZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKHVTYW1wbGVyLCBjbGFtcCh2ZWMyKHZUZXh0dXJlQ29vcmQueCArIG1hcC54LCB2VGV4dHVyZUNvb3JkLnkgKyBtYXAueSksIGlucHV0Q2xhbXAueHksIGlucHV0Q2xhbXAuencpKTtcXHJcXG59XFxyXFxuXCI7XG5EaXNwbGFjZW1lbnRGaWx0ZXIudmVydGV4JDQgPSBcImF0dHJpYnV0ZSB2ZWMyIGFWZXJ0ZXhQb3NpdGlvbjtcXHJcXG5cXHJcXG51bmlmb3JtIG1hdDMgcHJvamVjdGlvbk1hdHJpeDtcXHJcXG51bmlmb3JtIG1hdDMgZmlsdGVyTWF0cml4O1xcclxcblxcclxcbnZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xcclxcbnZhcnlpbmcgdmVjMiB2RmlsdGVyQ29vcmQ7XFxyXFxuXFxyXFxudW5pZm9ybSB2ZWM0IGlucHV0U2l6ZTtcXHJcXG51bmlmb3JtIHZlYzQgb3V0cHV0RnJhbWU7XFxyXFxuXFxyXFxudmVjNCBmaWx0ZXJWZXJ0ZXhQb3NpdGlvbiggdm9pZCApXFxyXFxue1xcclxcbiAgICB2ZWMyIHBvc2l0aW9uID0gYVZlcnRleFBvc2l0aW9uICogbWF4KG91dHB1dEZyYW1lLnp3LCB2ZWMyKDAuKSkgKyBvdXRwdXRGcmFtZS54eTtcXHJcXG5cXHJcXG4gICAgcmV0dXJuIHZlYzQoKHByb2plY3Rpb25NYXRyaXggKiB2ZWMzKHBvc2l0aW9uLCAxLjApKS54eSwgMC4wLCAxLjApO1xcclxcbn1cXHJcXG5cXHJcXG52ZWMyIGZpbHRlclRleHR1cmVDb29yZCggdm9pZCApXFxyXFxue1xcclxcbiAgICByZXR1cm4gYVZlcnRleFBvc2l0aW9uICogKG91dHB1dEZyYW1lLnp3ICogaW5wdXRTaXplLnp3KTtcXHJcXG59XFxyXFxuXFxyXFxudm9pZCBtYWluKHZvaWQpXFxyXFxue1xcclxcblxcdGdsX1Bvc2l0aW9uID0gZmlsdGVyVmVydGV4UG9zaXRpb24oKTtcXHJcXG5cXHR2VGV4dHVyZUNvb3JkID0gZmlsdGVyVGV4dHVyZUNvb3JkKCk7XFxyXFxuXFx0dkZpbHRlckNvb3JkID0gKCBmaWx0ZXJNYXRyaXggKiB2ZWMzKCB2VGV4dHVyZUNvb3JkLCAxLjApICApLnh5O1xcclxcbn1cXHJcXG5cIjtcbmV4cG9ydHMuRGlzcGxhY2VtZW50RmlsdGVyID0gRGlzcGxhY2VtZW50RmlsdGVyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBFdmVudERpc3BhdGNoZXJfMSA9IHJlcXVpcmUoXCIuL0V2ZW50RGlzcGF0Y2hlclwiKTtcbmNvbnN0IFJlY3RhbmdsZV8xID0gcmVxdWlyZShcIi4uL2ZsYXNoL2dlb20vUmVjdGFuZ2xlXCIpO1xuY29uc3QgTWF0cml4XzEgPSByZXF1aXJlKFwiLi9NYXRyaXhcIik7XG5jb25zdCBSZW5kZXJUZXh0dXJlXzEgPSByZXF1aXJlKFwiLi9SZW5kZXJUZXh0dXJlXCIpO1xuY29uc3QgQmFzZVRleHR1cmVfMSA9IHJlcXVpcmUoXCIuL0Jhc2VUZXh0dXJlXCIpO1xuY29uc3QgVGV4dHVyZV8xID0gcmVxdWlyZShcIi4vVGV4dHVyZVwiKTtcbmNvbnN0IEJvdW5kc18xID0gcmVxdWlyZShcIi4vQm91bmRzXCIpO1xuY29uc3QgVHJhbnNmb3JtXzEgPSByZXF1aXJlKFwiLi4vZmxhc2gvZ2VvbS9UcmFuc2Zvcm1cIik7XG5jb25zdCBQb2ludF8xID0gcmVxdWlyZShcIi4uL2ZsYXNoL2dlb20vUG9pbnRcIik7XG5jb25zdCBNYXRoU2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL01hdGhTZXR0aW5nc1wiKTtcbmNvbnN0IERpc3BsYXlTZXR0aW5nc18xID0gcmVxdWlyZShcIi4vRGlzcGxheVNldHRpbmdzXCIpO1xuY29uc3QgSW5zdGFuY2VDb3VudGVyXzEgPSByZXF1aXJlKFwiLi9JbnN0YW5jZUNvdW50ZXJcIik7XG5jbGFzcyBEaXNwbGF5T2JqZWN0IGV4dGVuZHMgRXZlbnREaXNwYXRjaGVyXzEuRXZlbnREaXNwYXRjaGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgLyohXG4gKiBAcGl4aS9taXhpbi1nZXQtY2hpbGQtYnktbmFtZSAtIHY1LjAuMC1yYy4zXG4gKiBDb21waWxlZCBXZWQsIDEwIEFwciAyMDE5IDAxOjIxOjE1IFVUQ1xuICpcbiAqIEBwaXhpL21peGluLWdldC1jaGlsZC1ieS1uYW1lIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2VcbiAqL1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGluc3RhbmNlIG5hbWUgb2YgdGhlIG9iamVjdC5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlcm9mIFBJWEkuRGlzcGxheU9iamVjdCNcbiAgICAgICAgICogQG1lbWJlciB7c3RyaW5nfSBuYW1lXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm5hbWUgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogIEZsYWcgZm9yIGlmIHRoZSBvYmplY3QgaXMgYWNjZXNzaWJsZS4gSWYgdHJ1ZSBBY2Nlc3NpYmlsaXR5TWFuYWdlciB3aWxsIG92ZXJsYXkgYVxuICAgICAgICAgKiAgIHNoYWRvdyBkaXYgd2l0aCBhdHRyaWJ1dGVzIHNldFxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtib29sZWFufVxuICAgICAgICAgKiBAbWVtYmVyb2YgUElYSS5EaXNwbGF5T2JqZWN0I1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hY2Nlc3NpYmxlID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXRzIHRoZSB0aXRsZSBhdHRyaWJ1dGUgb2YgdGhlIHNoYWRvdyBkaXZcbiAgICAgICAgICogSWYgYWNjZXNzaWJsZVRpdGxlIEFORCBhY2Nlc3NpYmxlSGludCBoYXMgbm90IGJlZW4gdGhpcyB3aWxsIGRlZmF1bHQgdG8gJ2Rpc3BsYXlPYmplY3QgW3RhYkluZGV4XSdcbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7P3N0cmluZ31cbiAgICAgICAgICogQG1lbWJlcm9mIFBJWEkuRGlzcGxheU9iamVjdCNcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYWNjZXNzaWJsZVRpdGxlID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgdGhlIGFyaWEtbGFiZWwgYXR0cmlidXRlIG9mIHRoZSBzaGFkb3cgZGl2XG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge3N0cmluZ31cbiAgICAgICAgICogQG1lbWJlcm9mIFBJWEkuRGlzcGxheU9iamVjdCNcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYWNjZXNzaWJsZUhpbnQgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKiBAbWVtYmVyb2YgUElYSS5EaXNwbGF5T2JqZWN0I1xuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAdG9kbyBOZWVkcyBkb2NzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50YWJJbmRleCA9IDA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtib29sZWFufVxuICAgICAgICAgKiBAbWVtYmVyb2YgUElYSS5EaXNwbGF5T2JqZWN0I1xuICAgICAgICAgKiBAdG9kbyBOZWVkcyBkb2NzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fYWNjZXNzaWJsZUFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICAgICAgICogQG1lbWJlcm9mIFBJWEkuRGlzcGxheU9iamVjdCNcbiAgICAgICAgICogQHRvZG8gTmVlZHMgZG9jcy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2FjY2Vzc2libGVEaXYgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICogRW5hYmxlIGludGVyYWN0aW9uIGV2ZW50cyBmb3IgdGhlIERpc3BsYXlPYmplY3QuIFRvdWNoLCBwb2ludGVyIGFuZCBtb3VzZVxuICAgICAgICAqIGV2ZW50cyB3aWxsIG5vdCBiZSBlbWl0dGVkIHVubGVzcyBgaW50ZXJhY3RpdmVgIGlzIHNldCB0byBgdHJ1ZWAuXG4gICAgICAgICpcbiAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAqIGNvbnN0IHNwcml0ZSA9IG5ldyBQSVhJLlNwcml0ZSh0ZXh0dXJlKTtcbiAgICAgICAgKiBzcHJpdGUuaW50ZXJhY3RpdmUgPSB0cnVlO1xuICAgICAgICAqIHNwcml0ZS5vbigndGFwJywgKGV2ZW50KSA9PiB7XG4gICAgICAgICogICAgLy9oYW5kbGUgZXZlbnRcbiAgICAgICAgKiB9KTtcbiAgICAgICAgKiBAbWVtYmVyIHtib29sZWFufVxuICAgICAgICAqIEBtZW1iZXJvZiBQSVhJLkRpc3BsYXlPYmplY3QjXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuaW50ZXJhY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERldGVybWluZXMgaWYgdGhlIGNoaWxkcmVuIHRvIHRoZSBkaXNwbGF5T2JqZWN0IGNhbiBiZSBjbGlja2VkL3RvdWNoZWRcbiAgICAgICAgICogU2V0dGluZyB0aGlzIHRvIGZhbHNlIGFsbG93cyBQaXhpSlMgdG8gYnlwYXNzIGEgcmVjdXJzaXZlIGBoaXRUZXN0YCBmdW5jdGlvblxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtib29sZWFufVxuICAgICAgICAgKiBAbWVtYmVyb2YgUElYSS5Db250YWluZXIjXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmludGVyYWN0aXZlQ2hpbGRyZW4gPSB0cnVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogSW50ZXJhY3Rpb24gc2hhcGUuIENoaWxkcmVuIHdpbGwgYmUgaGl0IGZpcnN0LCB0aGVuIHRoaXMgc2hhcGUgd2lsbCBiZSBjaGVja2VkLlxuICAgICAgICAgKiBTZXR0aW5nIHRoaXMgd2lsbCBjYXVzZSB0aGlzIHNoYXBlIHRvIGJlIGNoZWNrZWQgaW4gaGl0IHRlc3RzIHJhdGhlciB0aGFuIHRoZSBkaXNwbGF5T2JqZWN0J3MgYm91bmRzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBjb25zdCBzcHJpdGUgPSBuZXcgUElYSS5TcHJpdGUodGV4dHVyZSk7XG4gICAgICAgICAqIHNwcml0ZS5pbnRlcmFjdGl2ZSA9IHRydWU7XG4gICAgICAgICAqIHNwcml0ZS5oaXRBcmVhID0gbmV3IFBJWEkuUmVjdGFuZ2xlKDAsIDAsIDEwMCwgMTAwKTtcbiAgICAgICAgICogQG1lbWJlciB7UElYSS5SZWN0YW5nbGV8UElYSS5DaXJjbGV8UElYSS5FbGxpcHNlfFBJWEkuUG9seWdvbnxQSVhJLlJvdW5kZWRSZWN0YW5nbGV9XG4gICAgICAgICAqIEBtZW1iZXJvZiBQSVhJLkRpc3BsYXlPYmplY3QjXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmhpdEFyZWEgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBkZWZpbmVzIHdoYXQgY3Vyc29yIG1vZGUgaXMgdXNlZCB3aGVuIHRoZSBtb3VzZSBjdXJzb3JcbiAgICAgICAgICogaXMgaG92ZXJlZCBvdmVyIHRoZSBkaXNwbGF5T2JqZWN0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBjb25zdCBzcHJpdGUgPSBuZXcgUElYSS5TcHJpdGUodGV4dHVyZSk7XG4gICAgICAgICAqIHNwcml0ZS5pbnRlcmFjdGl2ZSA9IHRydWU7XG4gICAgICAgICAqIHNwcml0ZS5jdXJzb3IgPSAnd2FpdCc7XG4gICAgICAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vZG9jcy9XZWIvQ1NTL2N1cnNvclxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtzdHJpbmd9XG4gICAgICAgICAqIEBtZW1iZXJvZiBQSVhJLkRpc3BsYXlPYmplY3QjXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmN1cnNvciA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNYXAgb2YgYWxsIHRyYWNrZWQgcG9pbnRlcnMsIGJ5IGlkZW50aWZpZXIuIFVzZSB0cmFja2VkUG9pbnRlcnMgdG8gYWNjZXNzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAdHlwZSB7TWFwPG51bWJlciwgSW50ZXJhY3Rpb25UcmFja2luZ0RhdGE+fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fdHJhY2tlZFBvaW50ZXJzID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9jYWNoZUFzQml0bWFwID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2NhY2hlRGF0YSA9IGZhbHNlO1xuICAgICAgICAvLyBwZXJmb3JtYW5jZSBpbmNyZWFzZSB0byBhdm9pZCB1c2luZyBjYWxsLi4gKDEweCBmYXN0ZXIpXG4gICAgICAgIHRoaXMuZGlzcGxheU9iamVjdFVwZGF0ZVRyYW5zZm9ybSA9IHRoaXMudXBkYXRlVHJhbnNmb3JtO1xuICAgICAgICB0aGlzLnRlbXBEaXNwbGF5T2JqZWN0UGFyZW50ID0gbnVsbDtcbiAgICAgICAgLy8gVE9ETzogbmVlZCB0byBjcmVhdGUgVHJhbnNmb3JtIGZyb20gZmFjdG9yeVxuICAgICAgICAvKipcbiAgICAgICAgICogV29ybGQgdHJhbnNmb3JtIGFuZCBsb2NhbCB0cmFuc2Zvcm0gb2YgdGhpcyBvYmplY3QuXG4gICAgICAgICAqIFRoaXMgd2lsbCBiZWNvbWUgcmVhZC1vbmx5IGxhdGVyLCBwbGVhc2UgZG8gbm90IGFzc2lnbiBhbnl0aGluZyB0aGVyZSB1bmxlc3MgeW91IGtub3cgd2hhdCBhcmUgeW91IGRvaW5nLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLlRyYW5zZm9ybX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudHJhbnNmb3JtID0gbmV3IFRyYW5zZm9ybV8xLlRyYW5zZm9ybSgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG9wYWNpdHkgb2YgdGhlIG9iamVjdC5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hbHBoYSA9IDE7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdmlzaWJpbGl0eSBvZiB0aGUgb2JqZWN0LiBJZiBmYWxzZSB0aGUgb2JqZWN0IHdpbGwgbm90IGJlIGRyYXduLCBhbmRcbiAgICAgICAgICogdGhlIHVwZGF0ZVRyYW5zZm9ybSBmdW5jdGlvbiB3aWxsIG5vdCBiZSBjYWxsZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIE9ubHkgYWZmZWN0cyByZWN1cnNpdmUgY2FsbHMgZnJvbSBwYXJlbnQuIFlvdSBjYW4gYXNrIGZvciBib3VuZHMgb3IgY2FsbCB1cGRhdGVUcmFuc2Zvcm0gbWFudWFsbHkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnZpc2libGUgPSB0cnVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2FuIHRoaXMgb2JqZWN0IGJlIHJlbmRlcmVkLCBpZiBmYWxzZSB0aGUgb2JqZWN0IHdpbGwgbm90IGJlIGRyYXduIGJ1dCB0aGUgdXBkYXRlVHJhbnNmb3JtXG4gICAgICAgICAqIG1ldGhvZHMgd2lsbCBzdGlsbCBiZSBjYWxsZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIE9ubHkgYWZmZWN0cyByZWN1cnNpdmUgY2FsbHMgZnJvbSBwYXJlbnQuIFlvdSBjYW4gYXNrIGZvciBib3VuZHMgbWFudWFsbHkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJlbmRlcmFibGUgPSB0cnVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGRpc3BsYXkgb2JqZWN0IGNvbnRhaW5lciB0aGF0IGNvbnRhaW5zIHRoaXMgZGlzcGxheSBvYmplY3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuQ29udGFpbmVyfVxuICAgICAgICAgKiBAcmVhZG9ubHlcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucGFyZW50ID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBtdWx0aXBsaWVkIGFscGhhIG9mIHRoZSBkaXNwbGF5T2JqZWN0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqIEByZWFkb25seVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy53b3JsZEFscGhhID0gMTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoaWNoIGluZGV4IGluIHRoZSBjaGlsZHJlbiBhcnJheSB0aGUgZGlzcGxheSBjb21wb25lbnQgd2FzIGJlZm9yZSB0aGUgcHJldmlvdXMgekluZGV4IHNvcnQuXG4gICAgICAgICAqIFVzZWQgYnkgY29udGFpbmVycyB0byBoZWxwIHNvcnQgb2JqZWN0cyB3aXRoIHRoZSBzYW1lIHpJbmRleCwgYnkgdXNpbmcgcHJldmlvdXMgYXJyYXkgaW5kZXggYXMgdGhlIGRlY2lkZXIuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fbGFzdFNvcnRlZEluZGV4ID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB6SW5kZXggb2YgdGhlIGRpc3BsYXlPYmplY3QuXG4gICAgICAgICAqIEEgaGlnaGVyIHZhbHVlIHdpbGwgbWVhbiBpdCB3aWxsIGJlIHJlbmRlcmVkIG9uIHRvcCBvZiBvdGhlciBkaXNwbGF5T2JqZWN0cyB3aXRoaW4gdGhlIHNhbWUgY29udGFpbmVyLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3pJbmRleCA9IDA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgYXJlYSB0aGUgZmlsdGVyIGlzIGFwcGxpZWQgdG8uIFRoaXMgaXMgdXNlZCBhcyBtb3JlIG9mIGFuIG9wdGltaXphdGlvblxuICAgICAgICAgKiByYXRoZXIgdGhhbiBmaWd1cmluZyBvdXQgdGhlIGRpbWVuc2lvbnMgb2YgdGhlIGRpc3BsYXlPYmplY3QgZWFjaCBmcmFtZSB5b3UgY2FuIHNldCB0aGlzIHJlY3RhbmdsZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQWxzbyB3b3JrcyBhcyBhbiBpbnRlcmFjdGlvbiBtYXNrLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHs/UElYSS5SZWN0YW5nbGV9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmZpbHRlckFyZWEgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyB0aGUgZmlsdGVycyBmb3IgdGhlIGRpc3BsYXlPYmplY3QuXG4gICAgICAgICAqICogSU1QT1JUQU5UOiBUaGlzIGlzIGEgV2ViR0wgb25seSBmZWF0dXJlIGFuZCB3aWxsIGJlIGlnbm9yZWQgYnkgdGhlIGNhbnZhcyByZW5kZXJlci5cbiAgICAgICAgICogVG8gcmVtb3ZlIGZpbHRlcnMgc2ltcGx5IHNldCB0aGlzIHByb3BlcnR5IHRvIGAnbnVsbCdgLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHs/UElYSS5GaWx0ZXJbXX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZmlsdGVycyA9IG51bGw7XG4gICAgICAgIHRoaXMuX2VuYWJsZWRGaWx0ZXJzID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBib3VuZHMgb2JqZWN0LCB0aGlzIGlzIHVzZWQgdG8gY2FsY3VsYXRlIGFuZCBzdG9yZSB0aGUgYm91bmRzIG9mIHRoZSBkaXNwbGF5T2JqZWN0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLkJvdW5kc31cbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fYm91bmRzID0gbmV3IEJvdW5kc18xLkJvdW5kcygpO1xuICAgICAgICB0aGlzLl9ib3VuZHNJRCA9IDA7XG4gICAgICAgIHRoaXMuX2xhc3RCb3VuZHNJRCA9IC0xO1xuICAgICAgICB0aGlzLl9ib3VuZHNSZWN0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fbG9jYWxCb3VuZHNSZWN0ID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBvcmlnaW5hbCwgY2FjaGVkIG1hc2sgb2YgdGhlIG9iamVjdC5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7UElYSS5HcmFwaGljc3xQSVhJLlNwcml0ZX1cbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fbWFzayA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlZCB3aGVuIHRoaXMgRGlzcGxheU9iamVjdCBpcyBhZGRlZCB0byBhIENvbnRhaW5lci5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV2ZW50IFBJWEkuRGlzcGxheU9iamVjdCNhZGRlZFxuICAgICAgICAgKiBAcGFyYW0ge1BJWEkuQ29udGFpbmVyfSBjb250YWluZXIgLSBUaGUgY29udGFpbmVyIGFkZGVkIHRvLlxuICAgICAgICAgKi9cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVkIHdoZW4gdGhpcyBEaXNwbGF5T2JqZWN0IGlzIHJlbW92ZWQgZnJvbSBhIENvbnRhaW5lci5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV2ZW50IFBJWEkuRGlzcGxheU9iamVjdCNyZW1vdmVkXG4gICAgICAgICAqIEBwYXJhbSB7UElYSS5Db250YWluZXJ9IGNvbnRhaW5lciAtIFRoZSBjb250YWluZXIgcmVtb3ZlZCBmcm9tLlxuICAgICAgICAgKi9cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHRoZSBvYmplY3QgaGFzIGJlZW4gZGVzdHJveWVkIHZpYSBkZXN0cm95KCkuIElmIHRydWUsIGl0IHNob3VsZCBub3QgYmUgdXNlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fZGVzdHJveWVkID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiB1c2VkIHRvIGZhc3QgY2hlY2sgaWYgYSBzcHJpdGUgaXMuLiBhIHNwcml0ZSFcbiAgICAgICAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaXNTcHJpdGUgPSBmYWxzZTtcbiAgICB9XG4gICAgZGVzdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIuZGVzdHJ1Y3RvcigpO1xuICAgICAgICB0aGlzLl9jYWNoZUFzQml0bWFwID0gbnVsbDtcbiAgICAgICAgdGhpcy5fY2FjaGVEYXRhID0gbnVsbDtcbiAgICAgICAgdGhpcy5kaXNwbGF5T2JqZWN0VXBkYXRlVHJhbnNmb3JtID0gbnVsbDtcbiAgICAgICAgdGhpcy50ZW1wRGlzcGxheU9iamVjdFBhcmVudCA9IG51bGw7XG4gICAgICAgIGlmICh0aGlzLnRyYW5zZm9ybSkge1xuICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm0ucmVjeWNsZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudHJhbnNmb3JtID0gbnVsbDtcbiAgICAgICAgdGhpcy5hbHBoYSA9IG51bGw7XG4gICAgICAgIHRoaXMudmlzaWJsZSA9IG51bGw7XG4gICAgICAgIHRoaXMucmVuZGVyYWJsZSA9IG51bGw7XG4gICAgICAgIHRoaXMucGFyZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy53b3JsZEFscGhhID0gbnVsbDtcbiAgICAgICAgdGhpcy5fbGFzdFNvcnRlZEluZGV4ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fekluZGV4ID0gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMuZmlsdGVyQXJlYSkge1xuICAgICAgICAgICAgdGhpcy5maWx0ZXJBcmVhLnJlY3ljbGUoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZpbHRlckFyZWEgPSBudWxsO1xuICAgICAgICBpZiAodGhpcy5maWx0ZXJzICYmIHRoaXMuZmlsdGVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHdoaWxlICh0aGlzLmZpbHRlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgbGV0IGZpbHRlciA9IHRoaXMuZmlsdGVycy5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIGZpbHRlci5kZXN0cnVjdG9yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5maWx0ZXJzID0gbnVsbDtcbiAgICAgICAgdGhpcy5fZW5hYmxlZEZpbHRlcnMgPSBudWxsO1xuICAgICAgICBpZiAodGhpcy5fYm91bmRzKSB7XG4gICAgICAgICAgICB0aGlzLl9ib3VuZHMucmVjeWNsZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2JvdW5kcyA9IG51bGw7XG4gICAgICAgIHRoaXMuX2JvdW5kc0lEID0gbnVsbDtcbiAgICAgICAgdGhpcy5fbGFzdEJvdW5kc0lEID0gbnVsbDtcbiAgICAgICAgdGhpcy5fYm91bmRzUmVjdCA9IG51bGw7XG4gICAgICAgIHRoaXMuX2xvY2FsQm91bmRzUmVjdCA9IG51bGw7XG4gICAgICAgIGlmICh0aGlzLl9tYXNrKSB7XG4gICAgICAgICAgICB0aGlzLl9tYXNrLmRlc3RydWN0b3IoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9tYXNrID0gbnVsbDtcbiAgICAgICAgdGhpcy5fZGVzdHJveWVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5pc1Nwcml0ZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX3RyYWNrZWRQb2ludGVycyA9IG51bGw7XG4gICAgICAgIHRoaXMudGVtcERpc3BsYXlPYmplY3RQYXJlbnQgPSBudWxsO1xuICAgICAgICBpZiAodGhpcy5fbG9jYWxCb3VuZHNSZWN0KSB7XG4gICAgICAgICAgICB0aGlzLl9sb2NhbEJvdW5kc1JlY3QucmVjeWNsZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2xvY2FsQm91bmRzUmVjdCA9IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICogSW50ZXJuYWwgc2V0IG9mIGFsbCBhY3RpdmUgcG9pbnRlcnMsIGJ5IGlkZW50aWZpZXJcbiAqXG4gKiBAbWVtYmVyIHtNYXA8bnVtYmVyLCBJbnRlcmFjdGlvblRyYWNraW5nRGF0YT59XG4gKiBAbWVtYmVyb2YgUElYSS5EaXNwbGF5T2JqZWN0I1xuICogQHByaXZhdGVcbiAqL1xuICAgIGdldCB0cmFja2VkUG9pbnRlcnMoKSB7XG4gICAgICAgIGlmICh0aGlzLl90cmFja2VkUG9pbnRlcnMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fdHJhY2tlZFBvaW50ZXJzID0ge307XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3RyYWNrZWRQb2ludGVycztcbiAgICB9XG4gICAgLyohXG4gKiBAcGl4aS9taXhpbi1nZXQtZ2xvYmFsLXBvc2l0aW9uIC0gdjUuMC4wLXJjLjNcbiAqIENvbXBpbGVkIFdlZCwgMTAgQXByIDIwMTkgMDE6MjE6MTUgVVRDXG4gKlxuICogQHBpeGkvbWl4aW4tZ2V0LWdsb2JhbC1wb3NpdGlvbiBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKiBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlXG4gKi9cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBnbG9iYWwgcG9zaXRpb24gb2YgdGhlIGRpc3BsYXlPYmplY3QuIERvZXMgbm90IGRlcGVuZCBvbiBvYmplY3Qgc2NhbGUsIHJvdGF0aW9uIGFuZCBwaXZvdC5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgZ2V0R2xvYmFsUG9zaXRpb25cbiAgICAgKiBAbWVtYmVyb2YgUElYSS5EaXNwbGF5T2JqZWN0I1xuICAgICAqIEBwYXJhbSB7UG9pbnR9IHBvaW50IC0gVGhlIHBvaW50IHRvIHdyaXRlIHRoZSBnbG9iYWwgdmFsdWUgdG8uIElmIG51bGwgYSBuZXcgcG9pbnQgd2lsbCBiZSByZXR1cm5lZFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2tpcFVwZGF0ZSAtIFNldHRpbmcgdG8gdHJ1ZSB3aWxsIHN0b3AgdGhlIHRyYW5zZm9ybXMgb2YgdGhlIHNjZW5lIGdyYXBoIGZyb21cbiAgICAgKiAgYmVpbmcgdXBkYXRlZC4gVGhpcyBtZWFucyB0aGUgY2FsY3VsYXRpb24gcmV0dXJuZWQgTUFZIGJlIG91dCBvZiBkYXRlIEJVVCB3aWxsIGdpdmUgeW91IGFcbiAgICAgKiAgbmljZSBwZXJmb3JtYW5jZSBib29zdC5cbiAgICAgKiBAcmV0dXJuIHtQb2ludH0gVGhlIHVwZGF0ZWQgcG9pbnQuXG4gICAgICovXG4gICAgZ2V0R2xvYmFsUG9zaXRpb24ocG9pbnQgPSBudWxsLCBza2lwVXBkYXRlID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKCFwb2ludCkge1xuICAgICAgICAgICAgcG9pbnQgPSBQb2ludF8xLlBvaW50LmdldFBvaW50KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICAgICAgICB0aGlzLnBhcmVudC50b0dsb2JhbCh0aGlzLnBvc2l0aW9uLCBwb2ludCwgc2tpcFVwZGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwb2ludC54ID0gdGhpcy5wb3NpdGlvbi54O1xuICAgICAgICAgICAgcG9pbnQueSA9IHRoaXMucG9zaXRpb24ueTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcG9pbnQ7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAqIElmIGVuYWJsZWQsIHRoZSBtb3VzZSBjdXJzb3IgdXNlIHRoZSBwb2ludGVyIGJlaGF2aW9yIHdoZW4gaG92ZXJlZCBvdmVyIHRoZSBkaXNwbGF5T2JqZWN0IGlmIGl0IGlzIGludGVyYWN0aXZlXG4gKiBTZXR0aW5nIHRoaXMgY2hhbmdlcyB0aGUgJ2N1cnNvcicgcHJvcGVydHkgdG8gYCdwb2ludGVyJ2AuXG4gKlxuICogQGV4YW1wbGVcbiAqIGNvbnN0IHNwcml0ZSA9IG5ldyBQSVhJLlNwcml0ZSh0ZXh0dXJlKTtcbiAqIHNwcml0ZS5pbnRlcmFjdGl2ZSA9IHRydWU7XG4gKiBzcHJpdGUuYnV0dG9uTW9kZSA9IHRydWU7XG4gKiBAbWVtYmVyIHtib29sZWFufVxuICogQG1lbWJlcm9mIFBJWEkuRGlzcGxheU9iamVjdCNcbiAqL1xuICAgIGdldCBidXR0b25Nb2RlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jdXJzb3IgPT09ICdwb2ludGVyJztcbiAgICB9XG4gICAgc2V0IGJ1dHRvbk1vZGUodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnNvciA9ICdwb2ludGVyJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmN1cnNvciA9PT0gJ3BvaW50ZXInKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnNvciA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBtZW1iZXIge1BJWEkuRGlzcGxheU9iamVjdH1cbiAgICAgKi9cbiAgICBzdGF0aWMgbWl4aW4oc291cmNlKSB7XG4gICAgICAgIC8vIGluIEVTOC9FUzIwMTcsIHRoaXMgd291bGQgYmUgcmVhbGx5IGVhc3k6XG4gICAgICAgIC8vIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7XG4gICAgICAgIC8vIGdldCBhbGwgdGhlIGVudW1lcmFibGUgcHJvcGVydHkga2V5c1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG4gICAgICAgIC8vIGxvb3AgdGhyb3VnaCBwcm9wZXJ0aWVzXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIHByb3BlcnR5TmFtZSA9IGtleXNbaV07XG4gICAgICAgICAgICAvLyBTZXQgdGhlIHByb3BlcnR5IHVzaW5nIHRoZSBwcm9wZXJ0eSBkZXNjcmlwdG9yIC0gdGhpcyB3b3JrcyBmb3IgYWNjZXNzb3JzIGFuZCBub3JtYWwgdmFsdWUgcHJvcGVydGllc1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERpc3BsYXlPYmplY3QucHJvdG90eXBlLCBwcm9wZXJ0eU5hbWUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBwcm9wZXJ0eU5hbWUpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICA7XG4gICAgZ2V0IF90ZW1wRGlzcGxheU9iamVjdFBhcmVudCgpIHtcbiAgICAgICAgaWYgKHRoaXMudGVtcERpc3BsYXlPYmplY3RQYXJlbnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMudGVtcERpc3BsYXlPYmplY3RQYXJlbnQgPSBuZXcgRGlzcGxheU9iamVjdCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnRlbXBEaXNwbGF5T2JqZWN0UGFyZW50O1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgb2JqZWN0IHRyYW5zZm9ybSBmb3IgcmVuZGVyaW5nLlxuICAgICAqXG4gICAgICogVE9ETyAtIE9wdGltaXphdGlvbiBwYXNzIVxuICAgICAqL1xuICAgIHVwZGF0ZVRyYW5zZm9ybSgpIHtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm0udXBkYXRlVHJhbnNmb3JtKHRoaXMucGFyZW50LnRyYW5zZm9ybSk7XG4gICAgICAgIC8vIG11bHRpcGx5IHRoZSBhbHBoYXMuLlxuICAgICAgICB0aGlzLndvcmxkQWxwaGEgPSB0aGlzLmFscGhhICogdGhpcy5wYXJlbnQud29ybGRBbHBoYTtcbiAgICAgICAgdGhpcy5fYm91bmRzLnVwZGF0ZUlEKys7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBSZWN1cnNpdmVseSB1cGRhdGVzIHRyYW5zZm9ybSBvZiBhbGwgb2JqZWN0cyBmcm9tIHRoZSByb290IHRvIHRoaXMgb25lXG4gICAgICogaW50ZXJuYWwgZnVuY3Rpb24gZm9yIHRvTG9jYWwoKVxuICAgICAqL1xuICAgIF9yZWN1cnNpdmVQb3N0VXBkYXRlVHJhbnNmb3JtKCkge1xuICAgICAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgICAgICAgIHRoaXMucGFyZW50Ll9yZWN1cnNpdmVQb3N0VXBkYXRlVHJhbnNmb3JtKCk7XG4gICAgICAgICAgICB0aGlzLnRyYW5zZm9ybS51cGRhdGVUcmFuc2Zvcm0odGhpcy5wYXJlbnQudHJhbnNmb3JtKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtLnVwZGF0ZVRyYW5zZm9ybSh0aGlzLl90ZW1wRGlzcGxheU9iamVjdFBhcmVudC50cmFuc2Zvcm0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIGJvdW5kcyBvZiB0aGUgZGlzcGxheU9iamVjdCBhcyBhIHJlY3RhbmdsZSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtza2lwVXBkYXRlXSAtIFNldHRpbmcgdG8gYHRydWVgIHdpbGwgc3RvcCB0aGUgdHJhbnNmb3JtcyBvZiB0aGUgc2NlbmUgZ3JhcGggZnJvbVxuICAgICAqICBiZWluZyB1cGRhdGVkLiBUaGlzIG1lYW5zIHRoZSBjYWxjdWxhdGlvbiByZXR1cm5lZCBNQVkgYmUgb3V0IG9mIGRhdGUgQlVUIHdpbGwgZ2l2ZSB5b3UgYVxuICAgICAqICBuaWNlIHBlcmZvcm1hbmNlIGJvb3N0LlxuICAgICAqIEBwYXJhbSB7UElYSS5SZWN0YW5nbGV9IFtyZWN0XSAtIE9wdGlvbmFsIHJlY3RhbmdsZSB0byBzdG9yZSB0aGUgcmVzdWx0IG9mIHRoZSBib3VuZHMgY2FsY3VsYXRpb24uXG4gICAgICogQHJldHVybiB7UElYSS5SZWN0YW5nbGV9IFRoZSByZWN0YW5ndWxhciBib3VuZGluZyBhcmVhLlxuICAgICAqL1xuICAgIGdldEJvdW5kcyhza2lwVXBkYXRlID0gdHJ1ZSwgcmVjdCA9IG51bGwpIHtcbiAgICAgICAgaWYgKCFza2lwVXBkYXRlKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMucGFyZW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQgPSB0aGlzLl90ZW1wRGlzcGxheU9iamVjdFBhcmVudDtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVRyYW5zZm9ybSgpO1xuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50ID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlY3Vyc2l2ZVBvc3RVcGRhdGVUcmFuc2Zvcm0oKTtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVRyYW5zZm9ybSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9ib3VuZHNJRCAhPT0gdGhpcy5fbGFzdEJvdW5kc0lEKSB7XG4gICAgICAgICAgICB0aGlzLmNhbGN1bGF0ZUJvdW5kcygpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcmVjdCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9ib3VuZHNSZWN0KSB7XG4gICAgICAgICAgICAgICAgSW5zdGFuY2VDb3VudGVyXzEuSW5zdGFuY2VDb3VudGVyLmFkZENhbGwoXCJSZWN0YW5nbGUuZ2V0UmVjdGFuZ2xlXCIsIFwiRGlzcGxheU9iamVjdCBnZXRCb3VuZHNcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5fYm91bmRzUmVjdCA9IFJlY3RhbmdsZV8xLlJlY3RhbmdsZS5nZXRSZWN0YW5nbGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlY3QgPSB0aGlzLl9ib3VuZHNSZWN0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9ib3VuZHMuZ2V0UmVjdGFuZ2xlKHJlY3QpO1xuICAgIH1cbiAgICA7XG4gICAgY2FsY3VsYXRlQm91bmRzKCkge1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIGxvY2FsIGJvdW5kcyBvZiB0aGUgZGlzcGxheU9iamVjdCBhcyBhIHJlY3RhbmdsZSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BJWEkuUmVjdGFuZ2xlfSBbcmVjdF0gLSBPcHRpb25hbCByZWN0YW5nbGUgdG8gc3RvcmUgdGhlIHJlc3VsdCBvZiB0aGUgYm91bmRzIGNhbGN1bGF0aW9uLlxuICAgICAqIEByZXR1cm4ge1BJWEkuUmVjdGFuZ2xlfSBUaGUgcmVjdGFuZ3VsYXIgYm91bmRpbmcgYXJlYS5cbiAgICAgKi9cbiAgICBnZXRMb2NhbEJvdW5kcyhyZWN0ID0gbnVsbCkge1xuICAgICAgICB2YXIgdHJhbnNmb3JtUmVmID0gdGhpcy50cmFuc2Zvcm07XG4gICAgICAgIHZhciBwYXJlbnRSZWYgPSB0aGlzLnBhcmVudDtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBudWxsO1xuICAgICAgICB0aGlzLnRyYW5zZm9ybSA9IHRoaXMuX3RlbXBEaXNwbGF5T2JqZWN0UGFyZW50LnRyYW5zZm9ybTtcbiAgICAgICAgaWYgKCFyZWN0KSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2xvY2FsQm91bmRzUmVjdCkge1xuICAgICAgICAgICAgICAgIEluc3RhbmNlQ291bnRlcl8xLkluc3RhbmNlQ291bnRlci5hZGRDYWxsKFwiUmVjdGFuZ2xlLmdldFJlY3RhbmdsZVwiLCBcIkRpc3BsYXlPYmplY3QgZ2V0bG9jYWxCb3VuZHNcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5fbG9jYWxCb3VuZHNSZWN0ID0gUmVjdGFuZ2xlXzEuUmVjdGFuZ2xlLmdldFJlY3RhbmdsZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVjdCA9IHRoaXMuX2xvY2FsQm91bmRzUmVjdDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYm91bmRzID0gdGhpcy5nZXRCb3VuZHMoZmFsc2UsIHJlY3QpO1xuICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudFJlZjtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm0gPSB0cmFuc2Zvcm1SZWY7XG4gICAgICAgIHJldHVybiBib3VuZHM7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVzIHRoZSBnbG9iYWwgcG9zaXRpb24gb2YgdGhlIGRpc3BsYXkgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQSVhJLklQb2ludH0gcG9zaXRpb24gLSBUaGUgd29ybGQgb3JpZ2luIHRvIGNhbGN1bGF0ZSBmcm9tLlxuICAgICAqIEBwYXJhbSB7UElYSS5JUG9pbnR9IFtwb2ludF0gLSBBIFBvaW50IG9iamVjdCBpbiB3aGljaCB0byBzdG9yZSB0aGUgdmFsdWUsIG9wdGlvbmFsXG4gICAgICogIChvdGhlcndpc2Ugd2lsbCBjcmVhdGUgYSBuZXcgUG9pbnQpLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3NraXBVcGRhdGU9ZmFsc2VdIC0gU2hvdWxkIHdlIHNraXAgdGhlIHVwZGF0ZSB0cmFuc2Zvcm0uXG4gICAgICogQHJldHVybiB7UElYSS5JUG9pbnR9IEEgcG9pbnQgb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgcG9zaXRpb24gb2YgdGhpcyBvYmplY3QuXG4gICAgICovXG4gICAgdG9HbG9iYWwocG9zaXRpb24sIHBvaW50LCBza2lwVXBkYXRlKSB7XG4gICAgICAgIGlmIChza2lwVXBkYXRlID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHNraXBVcGRhdGUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXNraXBVcGRhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlY3Vyc2l2ZVBvc3RVcGRhdGVUcmFuc2Zvcm0oKTtcbiAgICAgICAgICAgIC8vIHRoaXMgcGFyZW50IGNoZWNrIGlzIGZvciBqdXN0IGluIGNhc2UgdGhlIGl0ZW0gaXMgYSByb290IG9iamVjdC5cbiAgICAgICAgICAgIC8vIElmIGl0IGlzIHdlIG5lZWQgdG8gZ2l2ZSBpdCBhIHRlbXBvcmFyeSBwYXJlbnQgc28gdGhhdCBkaXNwbGF5T2JqZWN0VXBkYXRlVHJhbnNmb3JtIHdvcmtzIGNvcnJlY3RseVxuICAgICAgICAgICAgLy8gdGhpcyBpcyBtYWlubHkgdG8gYXZvaWQgYSBwYXJlbnQgY2hlY2sgaW4gdGhlIG1haW4gbG9vcC4gRXZlcnkgbGl0dGxlIGhlbHBzIGZvciBwZXJmb3JtYW5jZSA6KVxuICAgICAgICAgICAgaWYgKCF0aGlzLnBhcmVudCkge1xuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50ID0gdGhpcy5fdGVtcERpc3BsYXlPYmplY3RQYXJlbnQ7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwbGF5T2JqZWN0VXBkYXRlVHJhbnNmb3JtKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwbGF5T2JqZWN0VXBkYXRlVHJhbnNmb3JtKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gZG9uJ3QgbmVlZCB0byB1cGRhdGUgdGhlIGxvdFxuICAgICAgICByZXR1cm4gdGhpcy53b3JsZFRyYW5zZm9ybS5hcHBseShwb3NpdGlvbiwgcG9pbnQpO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlcyB0aGUgbG9jYWwgcG9zaXRpb24gb2YgdGhlIGRpc3BsYXkgb2JqZWN0IHJlbGF0aXZlIHRvIGFub3RoZXIgcG9pbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BJWEkuSVBvaW50fSBwb3NpdGlvbiAtIFRoZSB3b3JsZCBvcmlnaW4gdG8gY2FsY3VsYXRlIGZyb20uXG4gICAgICogQHBhcmFtIHtQSVhJLkRpc3BsYXlPYmplY3R9IFtmcm9tXSAtIFRoZSBEaXNwbGF5T2JqZWN0IHRvIGNhbGN1bGF0ZSB0aGUgZ2xvYmFsIHBvc2l0aW9uIGZyb20uXG4gICAgICogQHBhcmFtIHtQSVhJLklQb2ludH0gW3BvaW50XSAtIEEgUG9pbnQgb2JqZWN0IGluIHdoaWNoIHRvIHN0b3JlIHRoZSB2YWx1ZSwgb3B0aW9uYWxcbiAgICAgKiAgKG90aGVyd2lzZSB3aWxsIGNyZWF0ZSBhIG5ldyBQb2ludCkuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbc2tpcFVwZGF0ZT1mYWxzZV0gLSBTaG91bGQgd2Ugc2tpcCB0aGUgdXBkYXRlIHRyYW5zZm9ybVxuICAgICAqIEByZXR1cm4ge1BJWEkuSVBvaW50fSBBIHBvaW50IG9iamVjdCByZXByZXNlbnRpbmcgdGhlIHBvc2l0aW9uIG9mIHRoaXMgb2JqZWN0XG4gICAgICovXG4gICAgdG9Mb2NhbChwb3NpdGlvbiwgZnJvbSwgcG9pbnQsIHNraXBVcGRhdGUpIHtcbiAgICAgICAgaWYgKGZyb20pIHtcbiAgICAgICAgICAgIHBvc2l0aW9uID0gZnJvbS50b0dsb2JhbChwb3NpdGlvbiwgcG9pbnQsIHNraXBVcGRhdGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc2tpcFVwZGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5fcmVjdXJzaXZlUG9zdFVwZGF0ZVRyYW5zZm9ybSgpO1xuICAgICAgICAgICAgLy8gdGhpcyBwYXJlbnQgY2hlY2sgaXMgZm9yIGp1c3QgaW4gY2FzZSB0aGUgaXRlbSBpcyBhIHJvb3Qgb2JqZWN0LlxuICAgICAgICAgICAgLy8gSWYgaXQgaXMgd2UgbmVlZCB0byBnaXZlIGl0IGEgdGVtcG9yYXJ5IHBhcmVudCBzbyB0aGF0IGRpc3BsYXlPYmplY3RVcGRhdGVUcmFuc2Zvcm0gd29ya3MgY29ycmVjdGx5XG4gICAgICAgICAgICAvLyB0aGlzIGlzIG1haW5seSB0byBhdm9pZCBhIHBhcmVudCBjaGVjayBpbiB0aGUgbWFpbiBsb29wLiBFdmVyeSBsaXR0bGUgaGVscHMgZm9yIHBlcmZvcm1hbmNlIDopXG4gICAgICAgICAgICBpZiAoIXRoaXMucGFyZW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQgPSB0aGlzLl90ZW1wRGlzcGxheU9iamVjdFBhcmVudDtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BsYXlPYmplY3RVcGRhdGVUcmFuc2Zvcm0oKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BsYXlPYmplY3RVcGRhdGVUcmFuc2Zvcm0oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBzaW1wbHkgYXBwbHkgdGhlIG1hdHJpeC4uXG4gICAgICAgIHJldHVybiB0aGlzLndvcmxkVHJhbnNmb3JtLmFwcGx5SW52ZXJzZShwb3NpdGlvbiwgcG9pbnQpO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogUmVuZGVycyB0aGUgb2JqZWN0IHVzaW5nIHRoZSBXZWJHTCByZW5kZXJlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UElYSS5SZW5kZXJlcn0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXIuXG4gICAgICovXG4gICAgcmVuZGVyKHJlbmRlcmVyKSB7XG4gICAgICAgIC8vIE9WRVJXUklURTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFNldCB0aGUgcGFyZW50IENvbnRhaW5lciBvZiB0aGlzIERpc3BsYXlPYmplY3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BJWEkuQ29udGFpbmVyfSBjb250YWluZXIgLSBUaGUgQ29udGFpbmVyIHRvIGFkZCB0aGlzIERpc3BsYXlPYmplY3QgdG8uXG4gICAgICogQHJldHVybiB7UElYSS5Db250YWluZXJ9IFRoZSBDb250YWluZXIgdGhhdCB0aGlzIERpc3BsYXlPYmplY3Qgd2FzIGFkZGVkIHRvLlxuICAgICAqL1xuICAgIHNldFBhcmVudChjb250YWluZXIpIHtcbiAgICAgICAgaWYgKCFjb250YWluZXIgfHwgIWNvbnRhaW5lci5hZGRDaGlsZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzZXRQYXJlbnQ6IEFyZ3VtZW50IG11c3QgYmUgYSBDb250YWluZXInKTtcbiAgICAgICAgfVxuICAgICAgICBjb250YWluZXIuYWRkQ2hpbGQodGhpcyk7XG4gICAgICAgIHJldHVybiBjb250YWluZXI7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBDb252ZW5pZW5jZSBmdW5jdGlvbiB0byBzZXQgdGhlIHBvc2l0aW9uLCBzY2FsZSwgc2tldyBhbmQgcGl2b3QgYXQgb25jZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbeD0wXSAtIFRoZSBYIHBvc2l0aW9uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt5PTBdIC0gVGhlIFkgcG9zaXRpb25cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3NjYWxlWD0xXSAtIFRoZSBYIHNjYWxlIHZhbHVlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzY2FsZVk9MV0gLSBUaGUgWSBzY2FsZSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcm90YXRpb249MF0gLSBUaGUgcm90YXRpb25cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3NrZXdYPTBdIC0gVGhlIFggc2tldyB2YWx1ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc2tld1k9MF0gLSBUaGUgWSBza2V3IHZhbHVlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwaXZvdFg9MF0gLSBUaGUgWCBwaXZvdCB2YWx1ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcGl2b3RZPTBdIC0gVGhlIFkgcGl2b3QgdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtQSVhJLkRpc3BsYXlPYmplY3R9IFRoZSBEaXNwbGF5T2JqZWN0IGluc3RhbmNlXG4gICAgICovXG4gICAgc2V0VHJhbnNmb3JtKHgsIHksIHNjYWxlWCwgc2NhbGVZLCByb3RhdGlvbiwgc2tld1gsIHNrZXdZLCBwaXZvdFgsIHBpdm90WSkge1xuICAgICAgICBpZiAoeCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICB4ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoeSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICB5ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2NhbGVYID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHNjYWxlWCA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNjYWxlWSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBzY2FsZVkgPSAxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyb3RhdGlvbiA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICByb3RhdGlvbiA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNrZXdYID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHNrZXdYID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2tld1kgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgc2tld1kgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwaXZvdFggPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgcGl2b3RYID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGl2b3RZID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHBpdm90WSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wb3NpdGlvbi54ID0geDtcbiAgICAgICAgdGhpcy5wb3NpdGlvbi55ID0geTtcbiAgICAgICAgdGhpcy5zY2FsZS54ID0gIXNjYWxlWCA/IDEgOiBzY2FsZVg7XG4gICAgICAgIHRoaXMuc2NhbGUueSA9ICFzY2FsZVkgPyAxIDogc2NhbGVZO1xuICAgICAgICB0aGlzLnJvdGF0aW9uID0gcm90YXRpb247XG4gICAgICAgIHRoaXMuc2tldy54ID0gc2tld1g7XG4gICAgICAgIHRoaXMuc2tldy55ID0gc2tld1k7XG4gICAgICAgIHRoaXMucGl2b3QueCA9IHBpdm90WDtcbiAgICAgICAgdGhpcy5waXZvdC55ID0gcGl2b3RZO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIEJhc2UgZGVzdHJveSBtZXRob2QgZm9yIGdlbmVyaWMgZGlzcGxheSBvYmplY3RzLiBUaGlzIHdpbGwgYXV0b21hdGljYWxseVxuICAgICAqIHJlbW92ZSB0aGUgZGlzcGxheSBvYmplY3QgZnJvbSBpdHMgcGFyZW50IENvbnRhaW5lciBhcyB3ZWxsIGFzIHJlbW92ZVxuICAgICAqIGFsbCBjdXJyZW50IGV2ZW50IGxpc3RlbmVycyBhbmQgaW50ZXJuYWwgcmVmZXJlbmNlcy4gRG8gbm90IHVzZSBhIERpc3BsYXlPYmplY3RcbiAgICAgKiBhZnRlciBjYWxsaW5nIGBkZXN0cm95KClgLlxuICAgICAqXG4gICAgICovXG4gICAgZGVzdHJveShvcHRpb25zID0gbnVsbCkge1xuICAgICAgICAvLyB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgICAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgICAgICAgIHRoaXMucGFyZW50LnJlbW92ZUNoaWxkKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudHJhbnNmb3JtID0gbnVsbDtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBudWxsO1xuICAgICAgICB0aGlzLl9ib3VuZHMgPSBudWxsO1xuICAgICAgICB0aGlzLl9jdXJyZW50Qm91bmRzID0gbnVsbDtcbiAgICAgICAgdGhpcy5fbWFzayA9IG51bGw7XG4gICAgICAgIHRoaXMuZmlsdGVyQXJlYSA9IG51bGw7XG4gICAgICAgIHRoaXMuaW50ZXJhY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pbnRlcmFjdGl2ZUNoaWxkcmVuID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2Rlc3Ryb3llZCA9IHRydWU7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBUaGUgcG9zaXRpb24gb2YgdGhlIGRpc3BsYXlPYmplY3Qgb24gdGhlIHggYXhpcyByZWxhdGl2ZSB0byB0aGUgbG9jYWwgY29vcmRpbmF0ZXMgb2YgdGhlIHBhcmVudC5cbiAgICAgKiBBbiBhbGlhcyB0byBwb3NpdGlvbi54XG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICovXG4gICAgZ2V0IHgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBvc2l0aW9uLng7XG4gICAgfVxuICAgIDtcbiAgICBzZXQgeCh2YWx1ZSkge1xuICAgICAgICB0aGlzLnRyYW5zZm9ybS5wb3NpdGlvbi54ID0gdmFsdWU7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBUaGUgcG9zaXRpb24gb2YgdGhlIGRpc3BsYXlPYmplY3Qgb24gdGhlIHkgYXhpcyByZWxhdGl2ZSB0byB0aGUgbG9jYWwgY29vcmRpbmF0ZXMgb2YgdGhlIHBhcmVudC5cbiAgICAgKiBBbiBhbGlhcyB0byBwb3NpdGlvbi55XG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICovXG4gICAgZ2V0IHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBvc2l0aW9uLnk7XG4gICAgfVxuICAgIDtcbiAgICBzZXQgeSh2YWx1ZSkge1xuICAgICAgICB0aGlzLnRyYW5zZm9ybS5wb3NpdGlvbi55ID0gdmFsdWU7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBDdXJyZW50IHRyYW5zZm9ybSBvZiB0aGUgb2JqZWN0IGJhc2VkIG9uIHdvcmxkIChwYXJlbnQpIGZhY3RvcnMuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtQSVhJLk1hdHJpeH1cbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKi9cbiAgICBnZXQgd29ybGRUcmFuc2Zvcm0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybS53b3JsZFRyYW5zZm9ybTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIEN1cnJlbnQgdHJhbnNmb3JtIG9mIHRoZSBvYmplY3QgYmFzZWQgb24gbG9jYWwgZmFjdG9yczogcG9zaXRpb24sIHNjYWxlLCBvdGhlciBzdHVmZi5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge1BJWEkuTWF0cml4fVxuICAgICAqIEByZWFkb25seVxuICAgICAqL1xuICAgIGdldCBsb2NhbFRyYW5zZm9ybSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtLmxvY2FsVHJhbnNmb3JtO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogVGhlIGNvb3JkaW5hdGUgb2YgdGhlIG9iamVjdCByZWxhdGl2ZSB0byB0aGUgbG9jYWwgY29vcmRpbmF0ZXMgb2YgdGhlIHBhcmVudC5cbiAgICAgKiBBc3NpZ25tZW50IGJ5IHZhbHVlIHNpbmNlIHBpeGktdjQuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtQSVhJLklQb2ludH1cbiAgICAgKi9cbiAgICBnZXQgcG9zaXRpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybS5wb3NpdGlvbjtcbiAgICB9XG4gICAgO1xuICAgIHNldCBwb3NpdGlvbih2YWx1ZSkge1xuICAgICAgICB0aGlzLnRyYW5zZm9ybS5wb3NpdGlvbi5jb3B5RnJvbSh2YWx1ZSk7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBUaGUgc2NhbGUgZmFjdG9yIG9mIHRoZSBvYmplY3QuXG4gICAgICogQXNzaWdubWVudCBieSB2YWx1ZSBzaW5jZSBwaXhpLXY0LlxuICAgICAqXG4gICAgICogQG1lbWJlciB7UElYSS5JUG9pbnR9XG4gICAgICovXG4gICAgZ2V0IHNjYWxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0uc2NhbGU7XG4gICAgfVxuICAgIDtcbiAgICBzZXQgc2NhbGUodmFsdWUpIHtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm0uc2NhbGUuY29weUZyb20odmFsdWUpO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogVGhlIHBpdm90IHBvaW50IG9mIHRoZSBkaXNwbGF5T2JqZWN0IHRoYXQgaXQgcm90YXRlcyBhcm91bmQuXG4gICAgICogQXNzaWdubWVudCBieSB2YWx1ZSBzaW5jZSBwaXhpLXY0LlxuICAgICAqXG4gICAgICogQG1lbWJlciB7UElYSS5JUG9pbnR9XG4gICAgICovXG4gICAgZ2V0IHBpdm90KCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0ucGl2b3Q7XG4gICAgfVxuICAgIDtcbiAgICBzZXQgcGl2b3QodmFsdWUpIHtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm0ucGl2b3QuY29weUZyb20odmFsdWUpO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogVGhlIHNrZXcgZmFjdG9yIGZvciB0aGUgb2JqZWN0IGluIHJhZGlhbnMuXG4gICAgICogQXNzaWdubWVudCBieSB2YWx1ZSBzaW5jZSBwaXhpLXY0LlxuICAgICAqXG4gICAgICogQG1lbWJlciB7UElYSS5PYnNlcnZhYmxlUG9pbnR9XG4gICAgICovXG4gICAgZ2V0IHNrZXcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybS5za2V3O1xuICAgIH1cbiAgICA7XG4gICAgc2V0IHNrZXcodmFsdWUpIHtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm0uc2tldy5jb3B5RnJvbSh2YWx1ZSk7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBUaGUgcm90YXRpb24gb2YgdGhlIG9iamVjdCBpbiByYWRpYW5zLlxuICAgICAqICdyb3RhdGlvbicgYW5kICdhbmdsZScgaGF2ZSB0aGUgc2FtZSBlZmZlY3Qgb24gYSBkaXNwbGF5IG9iamVjdDsgcm90YXRpb24gaXMgaW4gcmFkaWFucywgYW5nbGUgaXMgaW4gZGVncmVlcy5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgcm90YXRpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybS5yb3RhdGlvbjtcbiAgICB9XG4gICAgO1xuICAgIHNldCByb3RhdGlvbih2YWx1ZSkge1xuICAgICAgICB0aGlzLnRyYW5zZm9ybS5yb3RhdGlvbiA9IHZhbHVlO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogVGhlIGFuZ2xlIG9mIHRoZSBvYmplY3QgaW4gZGVncmVlcy5cbiAgICAgKiAncm90YXRpb24nIGFuZCAnYW5nbGUnIGhhdmUgdGhlIHNhbWUgZWZmZWN0IG9uIGEgZGlzcGxheSBvYmplY3Q7IHJvdGF0aW9uIGlzIGluIHJhZGlhbnMsIGFuZ2xlIGlzIGluIGRlZ3JlZXMuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICovXG4gICAgZ2V0IGFuZ2xlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0ucm90YXRpb24gKiBNYXRoU2V0dGluZ3NfMS5NYXRoU2V0dGluZ3MuUkFEX1RPX0RFRztcbiAgICB9XG4gICAgO1xuICAgIHNldCBhbmdsZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLnRyYW5zZm9ybS5yb3RhdGlvbiA9IHZhbHVlICogTWF0aFNldHRpbmdzXzEuTWF0aFNldHRpbmdzLkRFR19UT19SQUQ7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBUaGUgekluZGV4IG9mIHRoZSBkaXNwbGF5T2JqZWN0LlxuICAgICAqIElmIGEgY29udGFpbmVyIGhhcyB0aGUgc29ydGFibGVDaGlsZHJlbiBwcm9wZXJ0eSBzZXQgdG8gdHJ1ZSwgY2hpbGRyZW4gd2lsbCBiZSBhdXRvbWF0aWNhbGx5XG4gICAgICogc29ydGVkIGJ5IHpJbmRleCB2YWx1ZTsgYSBoaWdoZXIgdmFsdWUgd2lsbCBtZWFuIGl0IHdpbGwgYmUgbW92ZWQgdG93YXJkcyB0aGUgZW5kIG9mIHRoZSBhcnJheSxcbiAgICAgKiBhbmQgdGh1cyByZW5kZXJlZCBvbiB0b3Agb2Ygb3RoZXIgZGlzcGxheU9iamVjdHMgd2l0aGluIHRoZSBzYW1lIGNvbnRhaW5lci5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgekluZGV4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fekluZGV4O1xuICAgIH1cbiAgICA7XG4gICAgc2V0IHpJbmRleCh2YWx1ZSkge1xuICAgICAgICB0aGlzLl96SW5kZXggPSB2YWx1ZTtcbiAgICAgICAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICAgICAgICB0aGlzLnBhcmVudC5zb3J0RGlydHkgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgaWYgdGhlIG9iamVjdCBpcyBnbG9iYWxseSB2aXNpYmxlLlxuICAgICAqXG4gICAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKi9cbiAgICBnZXQgd29ybGRWaXNpYmxlKCkge1xuICAgICAgICB2YXIgaXRlbSA9IHRoaXM7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGlmICghaXRlbS52aXNpYmxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaXRlbSA9IGl0ZW0ucGFyZW50O1xuICAgICAgICB9IHdoaWxlIChpdGVtKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBTZXRzIGEgbWFzayBmb3IgdGhlIGRpc3BsYXlPYmplY3QuIEEgbWFzayBpcyBhbiBvYmplY3QgdGhhdCBsaW1pdHMgdGhlIHZpc2liaWxpdHkgb2YgYW5cbiAgICAgKiBvYmplY3QgdG8gdGhlIHNoYXBlIG9mIHRoZSBtYXNrIGFwcGxpZWQgdG8gaXQuIEluIFBpeGlKUyBhIHJlZ3VsYXIgbWFzayBtdXN0IGJlIGFcbiAgICAgKiB7QGxpbmsgUElYSS5HcmFwaGljc30gb3IgYSB7QGxpbmsgUElYSS5TcHJpdGV9IG9iamVjdC4gVGhpcyBhbGxvd3MgZm9yIG11Y2ggZmFzdGVyIG1hc2tpbmcgaW4gY2FudmFzIGFzIGl0XG4gICAgICogdXRpbGl0aWVzIHNoYXBlIGNsaXBwaW5nLiBUbyByZW1vdmUgYSBtYXNrLCBzZXQgdGhpcyBwcm9wZXJ0eSB0byBgbnVsbGAuXG4gICAgICpcbiAgICAgKiBGb3Igc3ByaXRlIG1hc2sgYm90aCBhbHBoYSBhbmQgcmVkIGNoYW5uZWwgYXJlIHVzZWQuIEJsYWNrIG1hc2sgaXMgdGhlIHNhbWUgYXMgdHJhbnNwYXJlbnQgbWFzay5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNvbnN0IGdyYXBoaWNzID0gbmV3IFBJWEkuR3JhcGhpY3MoKTtcbiAgICAgKiBncmFwaGljcy5iZWdpbkZpbGwoMHhGRjMzMDApO1xuICAgICAqIGdyYXBoaWNzLmRyYXdSZWN0KDUwLCAyNTAsIDEwMCwgMTAwKTtcbiAgICAgKiBncmFwaGljcy5lbmRGaWxsKCk7XG4gICAgICpcbiAgICAgKiBjb25zdCBzcHJpdGUgPSBuZXcgUElYSS5TcHJpdGUodGV4dHVyZSk7XG4gICAgICogc3ByaXRlLm1hc2sgPSBncmFwaGljcztcbiAgICAgKiBAdG9kbyBBdCB0aGUgbW9tZW50LCBQSVhJLkNhbnZhc1JlbmRlcmVyIGRvZXNuJ3Qgc3VwcG9ydCBQSVhJLlNwcml0ZSBhcyBtYXNrLlxuICAgICAqXG4gICAgICogQG1lbWJlciB7UElYSS5HcmFwaGljc3xQSVhJLlNwcml0ZX1cbiAgICAgKi9cbiAgICBnZXQgbWFzaygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hc2s7XG4gICAgfVxuICAgIDtcbiAgICBzZXQgbWFzayh2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5fbWFzaykge1xuICAgICAgICAgICAgdGhpcy5fbWFzay5yZW5kZXJhYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX21hc2suaXNNYXNrID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbWFzayA9IHZhbHVlO1xuICAgICAgICBpZiAodGhpcy5fbWFzaykge1xuICAgICAgICAgICAgdGhpcy5fbWFzay5yZW5kZXJhYmxlID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9tYXNrLmlzTWFzayA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAgICAgICAgICogU2V0IHRoaXMgdG8gdHJ1ZSBpZiB5b3Ugd2FudCB0aGlzIGRpc3BsYXkgb2JqZWN0IHRvIGJlIGNhY2hlZCBhcyBhIGJpdG1hcC5cbiAgICAgICAgICAgICAqIFRoaXMgYmFzaWNhbGx5IHRha2VzIGEgc25hcCBzaG90IG9mIHRoZSBkaXNwbGF5IG9iamVjdCBhcyBpdCBpcyBhdCB0aGF0IG1vbWVudC4gSXQgY2FuXG4gICAgICAgICAgICAgKiBwcm92aWRlIGEgcGVyZm9ybWFuY2UgYmVuZWZpdCBmb3IgY29tcGxleCBzdGF0aWMgZGlzcGxheU9iamVjdHMuXG4gICAgICAgICAgICAgKiBUbyByZW1vdmUgc2ltcGx5IHNldCB0aGlzIHByb3BlcnR5IHRvIGBmYWxzZWBcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBJTVBPUlRBTlQgR09UQ0hBIC0gTWFrZSBzdXJlIHRoYXQgYWxsIHlvdXIgdGV4dHVyZXMgYXJlIHByZWxvYWRlZCBCRUZPUkUgc2V0dGluZyB0aGlzIHByb3BlcnR5IHRvIHRydWVcbiAgICAgICAgICAgICAqIGFzIGl0IHdpbGwgdGFrZSBhIHNuYXBzaG90IG9mIHdoYXQgaXMgY3VycmVudGx5IHRoZXJlLiBJZiB0aGUgdGV4dHVyZXMgaGF2ZSBub3QgbG9hZGVkIHRoZW4gdGhleSB3aWxsIG5vdCBhcHBlYXIuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBQSVhJLkRpc3BsYXlPYmplY3QjXG4gICAgICAgICAgICAgKi9cbiAgICBnZXQgY2FjaGVBc0JpdG1hcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhY2hlQXNCaXRtYXA7XG4gICAgfVxuICAgIHNldCBjYWNoZUFzQml0bWFwKHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLl9jYWNoZUFzQml0bWFwID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NhY2hlQXNCaXRtYXAgPSB2YWx1ZTtcbiAgICAgICAgdmFyIGRhdGE7XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9jYWNoZURhdGEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZURhdGEgPSBuZXcgQ2FjaGVEYXRhKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkYXRhID0gdGhpcy5fY2FjaGVEYXRhO1xuICAgICAgICAgICAgZGF0YS5vcmlnaW5hbFJlbmRlciA9IHRoaXMucmVuZGVyO1xuICAgICAgICAgICAgZGF0YS5vcmlnaW5hbFJlbmRlckNhbnZhcyA9IHRoaXMucmVuZGVyQ2FudmFzO1xuICAgICAgICAgICAgZGF0YS5vcmlnaW5hbFVwZGF0ZVRyYW5zZm9ybSA9IHRoaXMudXBkYXRlVHJhbnNmb3JtO1xuICAgICAgICAgICAgZGF0YS5vcmlnaW5hbENhbGN1bGF0ZUJvdW5kcyA9IHRoaXMuY2FsY3VsYXRlQm91bmRzO1xuICAgICAgICAgICAgZGF0YS5vcmlnaW5hbEdldExvY2FsQm91bmRzID0gdGhpcy5nZXRMb2NhbEJvdW5kcztcbiAgICAgICAgICAgIGRhdGEub3JpZ2luYWxEZXN0cm95ID0gdGhpcy5kZXN0cm95O1xuICAgICAgICAgICAgZGF0YS5vcmlnaW5hbENvbnRhaW5zUG9pbnQgPSB0aGlzLmNvbnRhaW5zUG9pbnQ7XG4gICAgICAgICAgICBkYXRhLm9yaWdpbmFsTWFzayA9IHRoaXMuX21hc2s7XG4gICAgICAgICAgICBkYXRhLm9yaWdpbmFsRmlsdGVyQXJlYSA9IHRoaXMuZmlsdGVyQXJlYTtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyID0gdGhpcy5fcmVuZGVyQ2FjaGVkO1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJDYW52YXMgPSB0aGlzLl9yZW5kZXJDYWNoZWRDYW52YXM7XG4gICAgICAgICAgICB0aGlzLmRlc3Ryb3kgPSB0aGlzLl9jYWNoZUFzQml0bWFwRGVzdHJveTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRhdGEgPSB0aGlzLl9jYWNoZURhdGE7XG4gICAgICAgICAgICBpZiAoZGF0YS5zcHJpdGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kZXN0cm95Q2FjaGVkRGlzcGxheU9iamVjdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5yZW5kZXIgPSBkYXRhLm9yaWdpbmFsUmVuZGVyO1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJDYW52YXMgPSBkYXRhLm9yaWdpbmFsUmVuZGVyQ2FudmFzO1xuICAgICAgICAgICAgdGhpcy5jYWxjdWxhdGVCb3VuZHMgPSBkYXRhLm9yaWdpbmFsQ2FsY3VsYXRlQm91bmRzO1xuICAgICAgICAgICAgdGhpcy5nZXRMb2NhbEJvdW5kcyA9IGRhdGEub3JpZ2luYWxHZXRMb2NhbEJvdW5kcztcbiAgICAgICAgICAgIHRoaXMuZGVzdHJveSA9IGRhdGEub3JpZ2luYWxEZXN0cm95O1xuICAgICAgICAgICAgdGhpcy51cGRhdGVUcmFuc2Zvcm0gPSBkYXRhLm9yaWdpbmFsVXBkYXRlVHJhbnNmb3JtO1xuICAgICAgICAgICAgdGhpcy5jb250YWluc1BvaW50ID0gZGF0YS5vcmlnaW5hbENvbnRhaW5zUG9pbnQ7XG4gICAgICAgICAgICB0aGlzLl9tYXNrID0gZGF0YS5vcmlnaW5hbE1hc2s7XG4gICAgICAgICAgICB0aGlzLmZpbHRlckFyZWEgPSBkYXRhLm9yaWdpbmFsRmlsdGVyQXJlYTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb250YWluc1BvaW50KHBvaW50KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVuZGVycyBhIGNhY2hlZCB2ZXJzaW9uIG9mIHRoZSBzcHJpdGUgd2l0aCBXZWJHTFxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAZnVuY3Rpb24gX3JlbmRlckNhY2hlZFxuICAgICAqIEBtZW1iZXJvZiBQSVhJLkRpc3BsYXlPYmplY3QjXG4gICAgICogQHBhcmFtIHtQSVhJLlJlbmRlcmVyfSByZW5kZXJlciAtIHRoZSBXZWJHTCByZW5kZXJlclxuICAgICAqL1xuICAgIF9yZW5kZXJDYWNoZWQocmVuZGVyZXIpIHtcbiAgICAgICAgaWYgKCF0aGlzLnZpc2libGUgfHwgdGhpcy53b3JsZEFscGhhIDw9IDAgfHwgIXRoaXMucmVuZGVyYWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2luaXRDYWNoZWREaXNwbGF5T2JqZWN0KHJlbmRlcmVyKTtcbiAgICAgICAgdGhpcy5fY2FjaGVEYXRhLnNwcml0ZS50cmFuc2Zvcm0uX3dvcmxkSUQgPSB0aGlzLnRyYW5zZm9ybS53b3JsZElEO1xuICAgICAgICB0aGlzLl9jYWNoZURhdGEuc3ByaXRlLndvcmxkQWxwaGEgPSB0aGlzLndvcmxkQWxwaGE7XG4gICAgICAgIHRoaXMuX2NhY2hlRGF0YS5zcHJpdGUuX3JlbmRlcihyZW5kZXJlcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByZXBhcmVzIHRoZSBXZWJHTCByZW5kZXJlciB0byBjYWNoZSB0aGUgc3ByaXRlXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBmdW5jdGlvbiBfaW5pdENhY2hlZERpc3BsYXlPYmplY3RcbiAgICAgKiBAbWVtYmVyb2YgUElYSS5EaXNwbGF5T2JqZWN0I1xuICAgICAqIEBwYXJhbSB7UElYSS5SZW5kZXJlcn0gcmVuZGVyZXIgLSB0aGUgV2ViR0wgcmVuZGVyZXJcbiAgICAgKi9cbiAgICBfaW5pdENhY2hlZERpc3BsYXlPYmplY3QocmVuZGVyZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuX2NhY2hlRGF0YSAmJiB0aGlzLl9jYWNoZURhdGEuc3ByaXRlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gbWFrZSBzdXJlIGFscGhhIGlzIHNldCB0byAxIG90aGVyd2lzZSBpdCB3aWxsIGdldCByZW5kZXJlZCBhcyBpbnZpc2libGUhXG4gICAgICAgIHZhciBjYWNoZUFscGhhID0gdGhpcy5hbHBoYTtcbiAgICAgICAgdGhpcy5hbHBoYSA9IDE7XG4gICAgICAgIC8vIGZpcnN0IHdlIGZsdXNoIGFueXRoaW5nIGxlZnQgaW4gdGhlIHJlbmRlcmVyIChvdGhlcndpc2UgaXQgd291bGQgZ2V0IHJlbmRlcmVkIHRvIHRoZSBjYWNoZWQgdGV4dHVyZSlcbiAgICAgICAgcmVuZGVyZXIuYmF0Y2guZmx1c2goKTtcbiAgICAgICAgLy8gdGhpcy5maWx0ZXJzPSBbXTtcbiAgICAgICAgLy8gbmV4dCB3ZSBmaW5kIHRoZSBkaW1lbnNpb25zIG9mIHRoZSB1bnRyYW5zZm9ybWVkIG9iamVjdFxuICAgICAgICAvLyB0aGlzIGZ1bmN0aW9uIGFsc28gY2FsbHMgdXBkYXRldHJhbnNmb3JtIG9uIGFsbCBpdHMgY2hpbGRyZW4gYXMgcGFydCBvZiB0aGUgbWVhc3VyaW5nLlxuICAgICAgICAvLyBUaGlzIG1lYW5zIHdlIGRvbid0IG5lZWQgdG8gdXBkYXRlIHRoZSB0cmFuc2Zvcm0gYWdhaW4gaW4gdGhpcyBmdW5jdGlvblxuICAgICAgICAvLyBUT0RPIHBhc3MgYW4gb2JqZWN0IHRvIGNsb25lIHRvbz8gc2F2ZXMgaGF2aW5nIHRvIGNyZWF0ZSBhIG5ldyBvbmUgZWFjaCB0aW1lIVxuICAgICAgICB2YXIgYm91bmRzID0gdGhpcy5nZXRMb2NhbEJvdW5kcygpLmNsb25lKCk7XG4gICAgICAgIC8vIGFkZCBzb21lIHBhZGRpbmchXG4gICAgICAgIGlmICh0aGlzLmZpbHRlcnMpIHtcbiAgICAgICAgICAgIHZhciBwYWRkaW5nID0gdGhpcy5maWx0ZXJzWzBdLnBhZGRpbmc7XG4gICAgICAgICAgICBib3VuZHMucGFkKHBhZGRpbmcpO1xuICAgICAgICB9XG4gICAgICAgIGJvdW5kcy5jZWlsKERpc3BsYXlTZXR0aW5nc18xLkRpc3BsYXlTZXR0aW5ncy5SRVNPTFVUSU9OKTtcbiAgICAgICAgLy8gZm9yIG5vdyB3ZSBjYWNoZSB0aGUgY3VycmVudCByZW5kZXJUYXJnZXQgdGhhdCB0aGUgV2ViR0wgcmVuZGVyZXIgaXMgY3VycmVudGx5IHVzaW5nLlxuICAgICAgICAvLyB0aGlzIGNvdWxkIGJlIG1vcmUgZWxlZ2FudC4uXG4gICAgICAgIHZhciBjYWNoZWRSZW5kZXJUYXJnZXQgPSByZW5kZXJlci5fYWN0aXZlUmVuZGVyVGFyZ2V0O1xuICAgICAgICAvLyBXZSBhbHNvIHN0b3JlIHRoZSBmaWx0ZXIgc3RhY2sgLSBJIHdpbGwgZGVmaW5pdGVseSBsb29rIHRvIGNoYW5nZSBob3cgdGhpcyB3b3JrcyBhIGxpdHRsZSBsYXRlciBkb3duIHRoZSBsaW5lLlxuICAgICAgICAvLyBjb25zdCBzdGFjayA9IHJlbmRlcmVyLmZpbHRlck1hbmFnZXIuZmlsdGVyU3RhY2s7XG4gICAgICAgIC8vIHRoaXMgcmVuZGVyVGV4dHVyZSB3aWxsIGJlIHVzZWQgdG8gc3RvcmUgdGhlIGNhY2hlZCBEaXNwbGF5T2JqZWN0XG4gICAgICAgIHZhciByZW5kZXJUZXh0dXJlID0gUmVuZGVyVGV4dHVyZV8xLlJlbmRlclRleHR1cmUuY3JlYXRlKGJvdW5kcy53aWR0aCwgYm91bmRzLmhlaWdodCk7XG4gICAgICAgIHZhciB0ZXh0dXJlQ2FjaGVJZCA9IFwiY2FjaGVBc0JpdG1hcF9cIiArIChNYXRoU2V0dGluZ3NfMS5NYXRoU2V0dGluZ3MudWlkKCkpO1xuICAgICAgICB0aGlzLl9jYWNoZURhdGEudGV4dHVyZUNhY2hlSWQgPSB0ZXh0dXJlQ2FjaGVJZDtcbiAgICAgICAgQmFzZVRleHR1cmVfMS5CYXNlVGV4dHVyZS5hZGRUb0NhY2hlKHJlbmRlclRleHR1cmUuYmFzZVRleHR1cmUsIHRleHR1cmVDYWNoZUlkKTtcbiAgICAgICAgVGV4dHVyZV8xLlRleHR1cmUuYWRkVG9DYWNoZShyZW5kZXJUZXh0dXJlLCB0ZXh0dXJlQ2FjaGVJZCk7XG4gICAgICAgIC8vIG5lZWQgdG8gc2V0IC8vXG4gICAgICAgIHZhciBtID0gRGlzcGxheU9iamVjdC5fdGVtcE1hdHJpeDtcbiAgICAgICAgbS50eCA9IC1ib3VuZHMueDtcbiAgICAgICAgbS50eSA9IC1ib3VuZHMueTtcbiAgICAgICAgLy8gcmVzZXRcbiAgICAgICAgdGhpcy50cmFuc2Zvcm0ud29ybGRUcmFuc2Zvcm0uaWRlbnRpdHkoKTtcbiAgICAgICAgLy8gc2V0IGFsbCBwcm9wZXJ0aWVzIHRvIHRoZXJlIG9yaWdpbmFsIHNvIHdlIGNhbiByZW5kZXIgdG8gYSB0ZXh0dXJlXG4gICAgICAgIHRoaXMucmVuZGVyID0gdGhpcy5fY2FjaGVEYXRhLm9yaWdpbmFsUmVuZGVyO1xuICAgICAgICByZW5kZXJlci5yZW5kZXIodGhpcywgcmVuZGVyVGV4dHVyZSwgdHJ1ZSwgbSwgdHJ1ZSk7XG4gICAgICAgIC8vIG5vdyByZXN0b3JlIHRoZSBzdGF0ZSBiZSBzZXR0aW5nIHRoZSBuZXcgcHJvcGVydGllc1xuICAgICAgICByZW5kZXJlci5yZW5kZXJUZXh0dXJlLmJpbmQoY2FjaGVkUmVuZGVyVGFyZ2V0KTtcbiAgICAgICAgLy8gcmVuZGVyZXIuZmlsdGVyTWFuYWdlci5maWx0ZXJTdGFjayA9IHN0YWNrO1xuICAgICAgICB0aGlzLnJlbmRlciA9IHRoaXMuX3JlbmRlckNhY2hlZDtcbiAgICAgICAgLy8gdGhlIHJlc3QgaXMgdGhlIHNhbWUgYXMgZm9yIENhbnZhc1xuICAgICAgICB0aGlzLnVwZGF0ZVRyYW5zZm9ybSA9IHRoaXMuZGlzcGxheU9iamVjdFVwZGF0ZVRyYW5zZm9ybTtcbiAgICAgICAgdGhpcy5jYWxjdWxhdGVCb3VuZHMgPSB0aGlzLl9jYWxjdWxhdGVDYWNoZWRCb3VuZHM7XG4gICAgICAgIHRoaXMuZ2V0TG9jYWxCb3VuZHMgPSB0aGlzLl9nZXRDYWNoZWRMb2NhbEJvdW5kcztcbiAgICAgICAgdGhpcy5fbWFzayA9IG51bGw7XG4gICAgICAgIHRoaXMuZmlsdGVyQXJlYSA9IG51bGw7XG4gICAgICAgIC8vIGNyZWF0ZSBvdXIgY2FjaGVkIHNwcml0ZVxuICAgICAgICB2YXIgY2FjaGVkU3ByaXRlOyAvLyA9IG5ldyBTcHJpdGUocmVuZGVyVGV4dHVyZSk7XG4gICAgICAgIGNhY2hlZFNwcml0ZS50cmFuc2Zvcm0ud29ybGRUcmFuc2Zvcm0gPSB0aGlzLnRyYW5zZm9ybS53b3JsZFRyYW5zZm9ybTtcbiAgICAgICAgY2FjaGVkU3ByaXRlLmFuY2hvci54ID0gLShib3VuZHMueCAvIGJvdW5kcy53aWR0aCk7XG4gICAgICAgIGNhY2hlZFNwcml0ZS5hbmNob3IueSA9IC0oYm91bmRzLnkgLyBib3VuZHMuaGVpZ2h0KTtcbiAgICAgICAgY2FjaGVkU3ByaXRlLmFscGhhID0gY2FjaGVBbHBoYTtcbiAgICAgICAgY2FjaGVkU3ByaXRlLl9ib3VuZHMgPSB0aGlzLl9ib3VuZHM7XG4gICAgICAgIHRoaXMuX2NhY2hlRGF0YS5zcHJpdGUgPSBjYWNoZWRTcHJpdGU7XG4gICAgICAgIHRoaXMudHJhbnNmb3JtLnBhcmVudElEID0gLTE7XG4gICAgICAgIC8vIHJlc3RvcmUgdGhlIHRyYW5zZm9ybSBvZiB0aGUgY2FjaGVkIHNwcml0ZSB0byBhdm9pZCB0aGUgbmFzdHkgZmxpY2tlci4uXG4gICAgICAgIGlmICghdGhpcy5wYXJlbnQpIHtcbiAgICAgICAgICAgIHRoaXMucGFyZW50ID0gcmVuZGVyZXIuX3RlbXBEaXNwbGF5T2JqZWN0UGFyZW50O1xuICAgICAgICAgICAgdGhpcy51cGRhdGVUcmFuc2Zvcm0oKTtcbiAgICAgICAgICAgIHRoaXMucGFyZW50ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVHJhbnNmb3JtKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbWFwIHRoZSBoaXQgdGVzdC4uXG4gICAgICAgIHRoaXMuY29udGFpbnNQb2ludCA9IGNhY2hlZFNwcml0ZS5jb250YWluc1BvaW50LmJpbmQoY2FjaGVkU3ByaXRlKTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICogUmVuZGVycyBhIGNhY2hlZCB2ZXJzaW9uIG9mIHRoZSBzcHJpdGUgd2l0aCBjYW52YXNcbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uIF9yZW5kZXJDYWNoZWRDYW52YXNcbiAqIEBtZW1iZXJvZiBQSVhJLkRpc3BsYXlPYmplY3QjXG4gKiBAcGFyYW0ge1BJWEkuUmVuZGVyZXJ9IHJlbmRlcmVyIC0gdGhlIFdlYkdMIHJlbmRlcmVyXG4gKi9cbiAgICBfcmVuZGVyQ2FjaGVkQ2FudmFzKHJlbmRlcmVyKSB7XG4gICAgICAgIGlmICghdGhpcy52aXNpYmxlIHx8IHRoaXMud29ybGRBbHBoYSA8PSAwIHx8ICF0aGlzLnJlbmRlcmFibGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9pbml0Q2FjaGVkRGlzcGxheU9iamVjdENhbnZhcyhyZW5kZXJlcik7XG4gICAgICAgIHRoaXMuX2NhY2hlRGF0YS5zcHJpdGUud29ybGRBbHBoYSA9IHRoaXMud29ybGRBbHBoYTtcbiAgICAgICAgdGhpcy5fY2FjaGVEYXRhLnNwcml0ZS5fcmVuZGVyQ2FudmFzKHJlbmRlcmVyKTtcbiAgICB9XG4gICAgO1xuICAgIC8vIFRPRE8gdGhpcyBjYW4gYmUgdGhlIHNhbWUgYXMgdGhlIFdlYkdMIHZlcnNpb24uLiB3aWxsIG5lZWQgdG8gZG8gYSBsaXR0bGUgdHdlYWtpbmcgZmlyc3QgdGhvdWdoLi5cbiAgICAvKipcbiAgICAgKiBQcmVwYXJlcyB0aGUgQ2FudmFzIHJlbmRlcmVyIHRvIGNhY2hlIHRoZSBzcHJpdGVcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGZ1bmN0aW9uIF9pbml0Q2FjaGVkRGlzcGxheU9iamVjdENhbnZhc1xuICAgICAqIEBtZW1iZXJvZiBQSVhJLkRpc3BsYXlPYmplY3QjXG4gICAgICogQHBhcmFtIHtQSVhJLlJlbmRlcmVyfSByZW5kZXJlciAtIHRoZSBXZWJHTCByZW5kZXJlclxuICAgICAqL1xuICAgIF9pbml0Q2FjaGVkRGlzcGxheU9iamVjdENhbnZhcyhyZW5kZXJlcikge1xuICAgICAgICBpZiAodGhpcy5fY2FjaGVEYXRhICYmIHRoaXMuX2NhY2hlRGF0YS5zcHJpdGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBnZXQgYm91bmRzIGFjdHVhbGx5IHRyYW5zZm9ybXMgdGhlIG9iamVjdCBmb3IgdXMgYWxyZWFkeSFcbiAgICAgICAgdmFyIGJvdW5kcyA9IHRoaXMuZ2V0TG9jYWxCb3VuZHMoKTtcbiAgICAgICAgdmFyIGNhY2hlQWxwaGEgPSB0aGlzLmFscGhhO1xuICAgICAgICB0aGlzLmFscGhhID0gMTtcbiAgICAgICAgdmFyIGNhY2hlZFJlbmRlclRhcmdldCA9IHJlbmRlcmVyLmNvbnRleHQ7XG4gICAgICAgIGJvdW5kcy5jZWlsKERpc3BsYXlTZXR0aW5nc18xLkRpc3BsYXlTZXR0aW5ncy5SRVNPTFVUSU9OKTtcbiAgICAgICAgdmFyIHJlbmRlclRleHR1cmUgPSBSZW5kZXJUZXh0dXJlXzEuUmVuZGVyVGV4dHVyZS5jcmVhdGUoYm91bmRzLndpZHRoLCBib3VuZHMuaGVpZ2h0KTtcbiAgICAgICAgdmFyIHRleHR1cmVDYWNoZUlkID0gXCJjYWNoZUFzQml0bWFwX1wiICsgKE1hdGhTZXR0aW5nc18xLk1hdGhTZXR0aW5ncy51aWQoKSk7XG4gICAgICAgIHRoaXMuX2NhY2hlRGF0YS50ZXh0dXJlQ2FjaGVJZCA9IHRleHR1cmVDYWNoZUlkO1xuICAgICAgICBCYXNlVGV4dHVyZV8xLkJhc2VUZXh0dXJlLmFkZFRvQ2FjaGUocmVuZGVyVGV4dHVyZS5iYXNlVGV4dHVyZSwgdGV4dHVyZUNhY2hlSWQpO1xuICAgICAgICBUZXh0dXJlXzEuVGV4dHVyZS5hZGRUb0NhY2hlKHJlbmRlclRleHR1cmUsIHRleHR1cmVDYWNoZUlkKTtcbiAgICAgICAgLy8gbmVlZCB0byBzZXQgLy9cbiAgICAgICAgdmFyIG0gPSBEaXNwbGF5T2JqZWN0Ll90ZW1wTWF0cml4O1xuICAgICAgICB0aGlzLnRyYW5zZm9ybS5sb2NhbFRyYW5zZm9ybS5jb3B5VG8obSk7XG4gICAgICAgIG0uaW52ZXJ0KCk7XG4gICAgICAgIG0udHggLT0gYm91bmRzLng7XG4gICAgICAgIG0udHkgLT0gYm91bmRzLnk7XG4gICAgICAgIC8vIG0uYXBwZW5kKHRoaXMudHJhbnNmb3JtLndvcmxkVHJhbnNmb3JtLilcbiAgICAgICAgLy8gc2V0IGFsbCBwcm9wZXJ0aWVzIHRvIHRoZXJlIG9yaWdpbmFsIHNvIHdlIGNhbiByZW5kZXIgdG8gYSB0ZXh0dXJlXG4gICAgICAgIHRoaXMucmVuZGVyQ2FudmFzID0gdGhpcy5fY2FjaGVEYXRhLm9yaWdpbmFsUmVuZGVyQ2FudmFzO1xuICAgICAgICAvLyByZW5kZXJUZXh0dXJlLnJlbmRlcih0aGlzLCBtLCB0cnVlKTtcbiAgICAgICAgcmVuZGVyZXIucmVuZGVyKHRoaXMsIHJlbmRlclRleHR1cmUsIHRydWUsIG0sIGZhbHNlKTtcbiAgICAgICAgLy8gbm93IHJlc3RvcmUgdGhlIHN0YXRlIGJlIHNldHRpbmcgdGhlIG5ldyBwcm9wZXJ0aWVzXG4gICAgICAgIHJlbmRlcmVyLmNvbnRleHQgPSBjYWNoZWRSZW5kZXJUYXJnZXQ7XG4gICAgICAgIHRoaXMucmVuZGVyQ2FudmFzID0gdGhpcy5fcmVuZGVyQ2FjaGVkQ2FudmFzO1xuICAgICAgICAvLyB0aGUgcmVzdCBpcyB0aGUgc2FtZSBhcyBmb3IgV2ViR0xcbiAgICAgICAgdGhpcy51cGRhdGVUcmFuc2Zvcm0gPSB0aGlzLmRpc3BsYXlPYmplY3RVcGRhdGVUcmFuc2Zvcm07XG4gICAgICAgIHRoaXMuY2FsY3VsYXRlQm91bmRzID0gdGhpcy5fY2FsY3VsYXRlQ2FjaGVkQm91bmRzO1xuICAgICAgICB0aGlzLmdldExvY2FsQm91bmRzID0gdGhpcy5fZ2V0Q2FjaGVkTG9jYWxCb3VuZHM7XG4gICAgICAgIHRoaXMuX21hc2sgPSBudWxsO1xuICAgICAgICB0aGlzLmZpbHRlckFyZWEgPSBudWxsO1xuICAgICAgICAvLyBjcmVhdGUgb3VyIGNhY2hlZCBzcHJpdGVcbiAgICAgICAgdmFyIGNhY2hlZFNwcml0ZTsgLy89IG5ldyBTcHJpdGUocmVuZGVyVGV4dHVyZSk7XG4gICAgICAgIGNhY2hlZFNwcml0ZS50cmFuc2Zvcm0ud29ybGRUcmFuc2Zvcm0gPSB0aGlzLnRyYW5zZm9ybS53b3JsZFRyYW5zZm9ybTtcbiAgICAgICAgY2FjaGVkU3ByaXRlLmFuY2hvci54ID0gLShib3VuZHMueCAvIGJvdW5kcy53aWR0aCk7XG4gICAgICAgIGNhY2hlZFNwcml0ZS5hbmNob3IueSA9IC0oYm91bmRzLnkgLyBib3VuZHMuaGVpZ2h0KTtcbiAgICAgICAgY2FjaGVkU3ByaXRlLmFscGhhID0gY2FjaGVBbHBoYTtcbiAgICAgICAgY2FjaGVkU3ByaXRlLl9ib3VuZHMgPSB0aGlzLl9ib3VuZHM7XG4gICAgICAgIHRoaXMuX2NhY2hlRGF0YS5zcHJpdGUgPSBjYWNoZWRTcHJpdGU7XG4gICAgICAgIHRoaXMudHJhbnNmb3JtLnBhcmVudElEID0gLTE7XG4gICAgICAgIC8vIHJlc3RvcmUgdGhlIHRyYW5zZm9ybSBvZiB0aGUgY2FjaGVkIHNwcml0ZSB0byBhdm9pZCB0aGUgbmFzdHkgZmxpY2tlci4uXG4gICAgICAgIGlmICghdGhpcy5wYXJlbnQpIHtcbiAgICAgICAgICAgIHRoaXMucGFyZW50ID0gcmVuZGVyZXIuX3RlbXBEaXNwbGF5T2JqZWN0UGFyZW50O1xuICAgICAgICAgICAgdGhpcy51cGRhdGVUcmFuc2Zvcm0oKTtcbiAgICAgICAgICAgIHRoaXMucGFyZW50ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVHJhbnNmb3JtKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbWFwIHRoZSBoaXQgdGVzdC4uXG4gICAgICAgIHRoaXMuY29udGFpbnNQb2ludCA9IGNhY2hlZFNwcml0ZS5jb250YWluc1BvaW50LmJpbmQoY2FjaGVkU3ByaXRlKTtcbiAgICB9XG4gICAgO1xuICAgIHJlbmRlckNhbnZhcyhyZW5kZXJlcikge1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVzIHRoZSBib3VuZHMgb2YgdGhlIGNhY2hlZCBzcHJpdGVcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2NhbGN1bGF0ZUNhY2hlZEJvdW5kcygpIHtcbiAgICAgICAgdGhpcy5fYm91bmRzLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuX2NhY2hlRGF0YS5zcHJpdGUudHJhbnNmb3JtLl93b3JsZElEID0gdGhpcy50cmFuc2Zvcm0ud29ybGRJRDtcbiAgICAgICAgdGhpcy5fY2FjaGVEYXRhLnNwcml0ZS5fY2FsY3VsYXRlQm91bmRzKCk7XG4gICAgICAgIHRoaXMuX2xhc3RCb3VuZHNJRCA9IHRoaXMuX2JvdW5kc0lEO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgYm91bmRzIG9mIHRoZSBjYWNoZWQgc3ByaXRlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJuIHtSZWN0YW5nbGV9IFRoZSBsb2NhbCBib3VuZHMuXG4gICAgICovXG4gICAgX2dldENhY2hlZExvY2FsQm91bmRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2FjaGVEYXRhLnNwcml0ZS5nZXRMb2NhbEJvdW5kcygpO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogRGVzdHJveXMgdGhlIGNhY2hlZCBzcHJpdGUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9kZXN0cm95Q2FjaGVkRGlzcGxheU9iamVjdCgpIHtcbiAgICAgICAgdGhpcy5fY2FjaGVEYXRhLnNwcml0ZS5fdGV4dHVyZS5kZXN0cm95KHRydWUpO1xuICAgICAgICB0aGlzLl9jYWNoZURhdGEuc3ByaXRlID0gbnVsbDtcbiAgICAgICAgQmFzZVRleHR1cmVfMS5CYXNlVGV4dHVyZS5yZW1vdmVGcm9tQ2FjaGUodGhpcy5fY2FjaGVEYXRhLnRleHR1cmVDYWNoZUlkKTtcbiAgICAgICAgVGV4dHVyZV8xLlRleHR1cmUucmVtb3ZlRnJvbUNhY2hlKHRoaXMuX2NhY2hlRGF0YS50ZXh0dXJlQ2FjaGVJZCk7XG4gICAgICAgIHRoaXMuX2NhY2hlRGF0YS50ZXh0dXJlQ2FjaGVJZCA9IG51bGw7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAqIERlc3Ryb3lzIHRoZSBjYWNoZWQgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge29iamVjdHxib29sZWFufSBbb3B0aW9uc10gLSBPcHRpb25zIHBhcmFtZXRlci4gQSBib29sZWFuIHdpbGwgYWN0IGFzIGlmIGFsbCBvcHRpb25zXG4gKiAgaGF2ZSBiZWVuIHNldCB0byB0aGF0IHZhbHVlLlxuICogIFVzZWQgd2hlbiBkZXN0cm95aW5nIGNvbnRhaW5lcnMsIHNlZSB0aGUgQ29udGFpbmVyLmRlc3Ryb3kgbWV0aG9kLlxuICovXG4gICAgX2NhY2hlQXNCaXRtYXBEZXN0cm95KG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5jYWNoZUFzQml0bWFwID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZGVzdHJveShvcHRpb25zKTtcbiAgICB9XG4gICAgO1xufVxuRGlzcGxheU9iamVjdC5fdGVtcE1hdHJpeCA9IG5ldyBNYXRyaXhfMS5NYXRyaXgoKTtcbmV4cG9ydHMuRGlzcGxheU9iamVjdCA9IERpc3BsYXlPYmplY3Q7XG4vLyBmaWd1cmVkIHRoZXJlcyBubyBwb2ludCBhZGRpbmcgQUxMIHRoZSBleHRyYSB2YXJpYWJsZXMgdG8gcHJvdG90eXBlLlxuLy8gdGhpcyBtb2RlbCBjYW4gaG9sZCB0aGUgaW5mb3JtYXRpb24gbmVlZGVkLiBUaGlzIGNhbiBhbHNvIGJlIGdlbmVyYXRlZCBvbiBkZW1hbmQgYXNcbi8vIG1vc3Qgb2JqZWN0cyBhcmUgbm90IGNhY2hlZCBhcyBiaXRtYXBzLlxuLyoqXG4gKiBAY2xhc3NcbiAqIEBpZ25vcmVcbiAqL1xuY2xhc3MgQ2FjaGVEYXRhIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy50ZXh0dXJlQ2FjaGVJZCA9IG51bGw7XG4gICAgICAgIHRoaXMub3JpZ2luYWxSZW5kZXIgPSBudWxsO1xuICAgICAgICB0aGlzLm9yaWdpbmFsUmVuZGVyQ2FudmFzID0gbnVsbDtcbiAgICAgICAgdGhpcy5vcmlnaW5hbENhbGN1bGF0ZUJvdW5kcyA9IG51bGw7XG4gICAgICAgIHRoaXMub3JpZ2luYWxHZXRMb2NhbEJvdW5kcyA9IG51bGw7XG4gICAgICAgIHRoaXMub3JpZ2luYWxVcGRhdGVUcmFuc2Zvcm0gPSBudWxsO1xuICAgICAgICB0aGlzLm9yaWdpbmFsSGl0VGVzdCA9IG51bGw7XG4gICAgICAgIHRoaXMub3JpZ2luYWxEZXN0cm95ID0gbnVsbDtcbiAgICAgICAgdGhpcy5vcmlnaW5hbE1hc2sgPSBudWxsO1xuICAgICAgICB0aGlzLm9yaWdpbmFsRmlsdGVyQXJlYSA9IG51bGw7XG4gICAgICAgIHRoaXMuc3ByaXRlID0gbnVsbDtcbiAgICB9XG59XG47XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNsYXNzIERpc3BsYXlTZXR0aW5ncyB7XG59XG5EaXNwbGF5U2V0dGluZ3MuU09SVEFCTEVfQ0hJTERSRU4gPSBmYWxzZTtcbkRpc3BsYXlTZXR0aW5ncy5DUkVBVEVfSU1BR0VfQklUTUFQID0gdHJ1ZTtcbkRpc3BsYXlTZXR0aW5ncy5SRU5ERVJFUl9UWVBFID0ge1xuICAgIFVOS05PV046IDAsXG4gICAgV0VCR0w6IDEsXG4gICAgQ0FOVkFTOiAyLFxufTtcbkRpc3BsYXlTZXR0aW5ncy5FTlYgPSB7XG4gICAgV0VCR0xfTEVHQUNZOiAwLFxuICAgIFdFQkdMOiAxLFxuICAgIFdFQkdMMjogMixcbn07XG5EaXNwbGF5U2V0dGluZ3MuUkVTT0xVVElPTiA9IDE7XG5EaXNwbGF5U2V0dGluZ3MuU0NBTEVfTU9ERSA9IDE7XG5EaXNwbGF5U2V0dGluZ3MuUk9VTkRfUElYRUxTID0gZmFsc2U7XG5EaXNwbGF5U2V0dGluZ3MuUFJFRkVSX0VOViA9IERpc3BsYXlTZXR0aW5ncy5FTlYuV0VCR0w7XG5leHBvcnRzLkRpc3BsYXlTZXR0aW5ncyA9IERpc3BsYXlTZXR0aW5ncztcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY2xhc3MgRHJhd01vZGVTZXR0aW5ncyB7XG59XG4vKipcbiogVmFyaW91cyB3ZWJnbCBkcmF3IG1vZGVzLiBUaGVzZSBjYW4gYmUgdXNlZCB0byBzcGVjaWZ5IHdoaWNoIEdMIGRyYXdNb2RlIHRvIHVzZVxuKiB1bmRlciBjZXJ0YWluIHNpdHVhdGlvbnMgYW5kIHJlbmRlcmVycy5cbipcbiogQG1lbWJlcm9mIFBJWElcbiogQHN0YXRpY1xuKiBAbmFtZSBEUkFXX01PREVTXG4qIEBlbnVtIHtudW1iZXJ9XG4qIEBwcm9wZXJ0eSB7bnVtYmVyfSBQT0lOVFNcbiogQHByb3BlcnR5IHtudW1iZXJ9IExJTkVTXG4qIEBwcm9wZXJ0eSB7bnVtYmVyfSBMSU5FX0xPT1BcbiogQHByb3BlcnR5IHtudW1iZXJ9IExJTkVfU1RSSVBcbiogQHByb3BlcnR5IHtudW1iZXJ9IFRSSUFOR0xFU1xuKiBAcHJvcGVydHkge251bWJlcn0gVFJJQU5HTEVfU1RSSVBcbiogQHByb3BlcnR5IHtudW1iZXJ9IFRSSUFOR0xFX0ZBTlxuKi9cbkRyYXdNb2RlU2V0dGluZ3MuRFJBV19NT0RFUyA9IHtcbiAgICBQT0lOVFM6IDAsXG4gICAgTElORVM6IDEsXG4gICAgTElORV9MT09QOiAyLFxuICAgIExJTkVfU1RSSVA6IDMsXG4gICAgVFJJQU5HTEVTOiA0LFxuICAgIFRSSUFOR0xFX1NUUklQOiA1LFxuICAgIFRSSUFOR0xFX0ZBTjogNixcbn07XG5leHBvcnRzLkRyYXdNb2RlU2V0dGluZ3MgPSBEcmF3TW9kZVNldHRpbmdzO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBSZWN0YW5nbGVfMSA9IHJlcXVpcmUoXCIuLi9mbGFzaC9nZW9tL1JlY3RhbmdsZVwiKTtcbmNvbnN0IFNoYXBlU2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL1NoYXBlU2V0dGluZ3NcIik7XG5jb25zdCBJbnN0YW5jZUNvdW50ZXJfMSA9IHJlcXVpcmUoXCIuL0luc3RhbmNlQ291bnRlclwiKTtcbmNsYXNzIEVsbGlwc2Uge1xuICAgIGNvbnN0cnVjdG9yKHggPSAwLCB5ID0gMCwgaGFsZldpZHRoID0gMCwgaGFsZkhlaWdodCA9IDApIHtcbiAgICAgICAgaWYgKHggPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgeCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHkgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgeSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhbGZXaWR0aCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBoYWxmV2lkdGggPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoYWxmSGVpZ2h0ID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIGhhbGZIZWlnaHQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMueCA9IHg7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMueSA9IHk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMud2lkdGggPSBoYWxmV2lkdGg7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGFsZkhlaWdodDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0eXBlIG9mIHRoZSBvYmplY3QsIG1haW5seSB1c2VkIHRvIGF2b2lkIGBpbnN0YW5jZW9mYCBjaGVja3NcbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKiBAcmVhZE9ubHlcbiAgICAgICAgICogQGRlZmF1bHQgUElYSS5TSEFQRVMuRUxJUFxuICAgICAgICAgKiBAc2VlIFBJWEkuU0hBUEVTXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnR5cGUgPSBTaGFwZVNldHRpbmdzXzEuU2hhcGVTZXR0aW5ncy5TSEFQRVMuRUxJUDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNsb25lIG9mIHRoaXMgRWxsaXBzZSBpbnN0YW5jZVxuICAgICAqXG4gICAgICogQHJldHVybiB7UElYSS5FbGxpcHNlfSBhIGNvcHkgb2YgdGhlIGVsbGlwc2VcbiAgICAgKi9cbiAgICBjbG9uZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBFbGxpcHNlKHRoaXMueCwgdGhpcy55LCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgeCBhbmQgeSBjb29yZGluYXRlcyBnaXZlbiBhcmUgY29udGFpbmVkIHdpdGhpbiB0aGlzIGVsbGlwc2VcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQgdG8gdGVzdFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQgdG8gdGVzdFxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIHgveSBjb29yZHMgYXJlIHdpdGhpbiB0aGlzIGVsbGlwc2VcbiAgICAgKi9cbiAgICBjb250YWlucyh4LCB5KSB7XG4gICAgICAgIGlmICh0aGlzLndpZHRoIDw9IDAgfHwgdGhpcy5oZWlnaHQgPD0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIG5vcm1hbGl6ZSB0aGUgY29vcmRzIHRvIGFuIGVsbGlwc2Ugd2l0aCBjZW50ZXIgMCwwXG4gICAgICAgIHZhciBub3JteCA9ICgoeCAtIHRoaXMueCkgLyB0aGlzLndpZHRoKTtcbiAgICAgICAgdmFyIG5vcm15ID0gKCh5IC0gdGhpcy55KSAvIHRoaXMuaGVpZ2h0KTtcbiAgICAgICAgbm9ybXggKj0gbm9ybXg7XG4gICAgICAgIG5vcm15ICo9IG5vcm15O1xuICAgICAgICByZXR1cm4gKG5vcm14ICsgbm9ybXkgPD0gMSk7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBmcmFtaW5nIHJlY3RhbmdsZSBvZiB0aGUgZWxsaXBzZSBhcyBhIFJlY3RhbmdsZSBvYmplY3RcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1BJWEkuUmVjdGFuZ2xlfSB0aGUgZnJhbWluZyByZWN0YW5nbGVcbiAgICAgKi9cbiAgICBnZXRCb3VuZHMoKSB7XG4gICAgICAgIEluc3RhbmNlQ291bnRlcl8xLkluc3RhbmNlQ291bnRlci5hZGRDYWxsKFwiUmVjdGFuZ2xlLmdldFJlY3RhbmdsZVwiLCBcIkVsbGlwc2UgZ2V0Qm91bmRzXCIpO1xuICAgICAgICByZXR1cm4gUmVjdGFuZ2xlXzEuUmVjdGFuZ2xlLmdldFJlY3RhbmdsZSh0aGlzLnggLSB0aGlzLndpZHRoLCB0aGlzLnkgLSB0aGlzLmhlaWdodCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgIH1cbiAgICA7XG59XG5leHBvcnRzLkVsbGlwc2UgPSBFbGxpcHNlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBGbGFzaEJhc2VPYmplY3RfMSA9IHJlcXVpcmUoXCIuL0ZsYXNoQmFzZU9iamVjdFwiKTtcbmNsYXNzIEV2ZW50IGV4dGVuZHMgRmxhc2hCYXNlT2JqZWN0XzEuRmxhc2hCYXNlT2JqZWN0IHtcbiAgICBjb25zdHJ1Y3Rvcih0eXBlLCBidWJibGUgPSB0cnVlLCBjYW5jZWxhYmxlID0gdHJ1ZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnJlc2V0KHR5cGUsIGJ1YmJsZSwgY2FuY2VsYWJsZSk7XG4gICAgfVxuICAgIGdldCBjdXJyZW50VGFyZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY3VycmVudFRhcmdldDtcbiAgICB9XG4gICAgc2V0Q3VycmVudFRhcmdldCh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9jdXJyZW50VGFyZ2V0ID0gdmFsdWU7XG4gICAgfVxuICAgIGdldCB0eXBlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdHlwZTtcbiAgICB9XG4gICAgZ2V0IGNhbmNlbGFibGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jYW5jZWxhYmxlO1xuICAgIH1cbiAgICBnZXQgYnViYmxlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2J1YmJsZXM7XG4gICAgfVxuICAgIGdldCBldmVudFBoYXNlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZXZlbnRQaGFzZTtcbiAgICB9XG4gICAgY2xvbmUoKSB7XG4gICAgICAgIHJldHVybiBFdmVudC5nZXRFdmVudCh0aGlzLl90eXBlLCB0aGlzLl9idWJibGVzLCB0aGlzLl9jYW5jZWxhYmxlKTtcbiAgICB9XG4gICAgcmVzZXQodHlwZSwgYnViYmxlID0gdHJ1ZSwgY2FuY2VsYWJsZSA9IHRydWUpIHtcbiAgICAgICAgdGhpcy5fdHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMuX2J1YmJsZXMgPSBidWJibGU7XG4gICAgICAgIHRoaXMuX2NhbmNlbGFibGUgPSBjYW5jZWxhYmxlO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0RXZlbnQodHlwZSwgYnViYmxlID0gdHJ1ZSwgY2FuY2VsYWJsZSA9IHRydWUpIHtcbiAgICAgICAgaWYgKEV2ZW50LkV2ZW50Q2FjaGUubGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgdGUgPSBFdmVudC5FdmVudENhY2hlW0V2ZW50LkV2ZW50Q2FjaGUubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBFdmVudC5FdmVudENhY2hlLmxlbmd0aCAtPSAxO1xuICAgICAgICAgICAgdGUucmVzZXQodHlwZSwgYnViYmxlLCBjYW5jZWxhYmxlKTtcbiAgICAgICAgICAgIHJldHVybiB0ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEV2ZW50KHR5cGUsIGJ1YmJsZSwgY2FuY2VsYWJsZSk7XG4gICAgfVxuICAgIGRlc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRUYXJnZXQgPSBudWxsO1xuICAgICAgICBsZXQgaW5kZXggPSBFdmVudC5FdmVudENhY2hlLmluZGV4T2YodGhpcyk7XG4gICAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgICAgIEV2ZW50LkV2ZW50Q2FjaGUucHVzaCh0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgaXNEaXNwb3NhYmxlKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgc3RvcFByb3BhZ2F0aW9uKCkge1xuICAgIH1cbiAgICBzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKSB7XG4gICAgfVxuICAgIHByZXZlbnREZWZhdWx0KCkge1xuICAgIH1cbn1cbkV2ZW50LkFEREVEX1RPX1NUQUdFID0gXCJhZGRlZFRvU3RhZ2VcIjtcbkV2ZW50LkFEREVEID0gXCJhZGRlZFwiO1xuRXZlbnQuRU5URVJfRlJBTUUgPSBcImVudGVyRnJhbWVcIjtcbkV2ZW50LkVYSVRfRlJBTUUgPSBcImV4aXRGcmFtZVwiO1xuRXZlbnQuRlJBTUVfQ09OU1RSVUNURUQgPSBcImZyYW1lQ29uc3RydWN0ZWRcIjtcbkV2ZW50LlJFTU9WRUQgPSBcInJlbW92ZWRcIjtcbkV2ZW50LlJFTU9WRURfRlJPTV9TVEFHRSA9IFwicmVtb3ZlZEZyb21TdGFnZVwiO1xuRXZlbnQuUkVOREVSID0gXCJyZW5kZXJcIjtcbkV2ZW50LkNPTVBMRVRFID0gXCJjb21wbGV0ZVwiO1xuRXZlbnQuSU5JVCA9IFwiaW5pdFwiO1xuRXZlbnQuT1BFTiA9IFwib3BlblwiO1xuRXZlbnQuVU5MT0FEID0gXCJ1bmxvYWRcIjtcbkV2ZW50LkNMRUFSID0gXCJjbGVhclwiO1xuRXZlbnQuU09VTkRfQ09NUExFVEUgPSBcInNvdW5kQ29tcGxldGVcIjtcbkV2ZW50LlNPVU5EX1NUQVJURUQgPSBcInNvdW5kU3RhcnRlZFwiO1xuRXZlbnQuQUNUSVZBVEUgPSBcImFjdGl2YXRlXCI7XG5FdmVudC5ERUFDVElWQVRFID0gXCJkZXNhY3RpdmF0ZVwiO1xuRXZlbnQuUkVTSVpFID0gXCJyZXNpemVcIjtcbkV2ZW50LkNIQU5HRSA9IFwiY2hhbmdlXCI7XG5FdmVudC5FdmVudENhY2hlID0gW107XG5leHBvcnRzLkV2ZW50ID0gRXZlbnQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IEZsYXNoQmFzZU9iamVjdF8xID0gcmVxdWlyZShcIi4vRmxhc2hCYXNlT2JqZWN0XCIpO1xuY2xhc3MgRXZlbnREaXNwYXRjaGVyIGV4dGVuZHMgRmxhc2hCYXNlT2JqZWN0XzEuRmxhc2hCYXNlT2JqZWN0IHtcbiAgICBjb25zdHJ1Y3Rvcih0YXJnZXQgPSBudWxsKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJlZExpc3RlbmVycyA9IHt9O1xuICAgIH1cbiAgICByZW1vdmVMaXN0ZW5lcnMoKSB7XG4gICAgICAgIGZvciAodmFyIGkgaW4gdGhpcy5yZWdpc3RlcmVkTGlzdGVuZXJzKSB7XG4gICAgICAgICAgICB2YXIgbWV0aG9kcyA9IHRoaXMucmVnaXN0ZXJlZExpc3RlbmVyc1tpXTtcbiAgICAgICAgICAgIHdoaWxlIChtZXRob2RzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGxldCBtcyA9IG1ldGhvZHMuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICBtcy5kZXN0cnVjdG9yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5yZWdpc3RlcmVkTGlzdGVuZXJzW2ldO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVnaXN0ZXJlZExpc3RlbmVycyA9IHt9O1xuICAgIH1cbiAgICBkZXN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlci5kZXN0cnVjdG9yKCk7XG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXJzKCk7XG4gICAgfVxuICAgIHdpbGxUcmlnZ2VyKHR5cGUpIHtcbiAgICAgICAgaWYgKHRoaXMucmVnaXN0ZXJlZExpc3RlbmVyc1t0eXBlXSAhPSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgbWV0aG9kcyA9IHRoaXMucmVnaXN0ZXJlZExpc3RlbmVyc1t0eXBlXTtcbiAgICAgICAgICAgIGlmIChtZXRob2RzICYmIG1ldGhvZHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyLCB1c2VDYXB0dXJlID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKHRoaXMucmVnaXN0ZXJlZExpc3RlbmVyc1t0eXBlXSAhPSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgbWV0aG9kcyA9IHRoaXMucmVnaXN0ZXJlZExpc3RlbmVyc1t0eXBlXTtcbiAgICAgICAgICAgIGlmIChtZXRob2RzICYmIG1ldGhvZHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXRob2RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtZXRob2RzW2ldLm9iamVjdEZ1bmN0aW9uID09IGxpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRob2RzW2ldLmRlc3RydWN0b3IoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZHMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFtZXRob2RzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnJlZ2lzdGVyZWRMaXN0ZW5lcnNbdHlwZV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGFzRXZlbnRMaXN0ZW5lcih0eXBlKSB7XG4gICAgICAgIGlmICh0aGlzLnJlZ2lzdGVyZWRMaXN0ZW5lcnNbdHlwZV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIG1ldGhvZHMgPSB0aGlzLnJlZ2lzdGVyZWRMaXN0ZW5lcnNbdHlwZV07XG4gICAgICAgICAgICBpZiAobWV0aG9kcyAmJiBtZXRob2RzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZGlzcGF0Y2hFdmVudChldmVudCkge1xuICAgICAgICBpZiAodGhpcy5yZWdpc3RlcmVkTGlzdGVuZXJzW2V2ZW50LnR5cGVdICE9IG51bGwpIHtcbiAgICAgICAgICAgIGV2ZW50LnNldEN1cnJlbnRUYXJnZXQodGhpcyk7XG4gICAgICAgICAgICB2YXIgbWV0aG9kcyA9IHRoaXMucmVnaXN0ZXJlZExpc3RlbmVyc1tldmVudC50eXBlXTtcbiAgICAgICAgICAgIGlmIChtZXRob2RzICYmIG1ldGhvZHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgbGV0IG1ldGhvZGNvcHkgPSBtZXRob2RzLmNvbmNhdCgpO1xuICAgICAgICAgICAgICAgIG1ldGhvZGNvcHkgPSBtZXRob2Rjb3B5LnNvcnQodGhpcy5nZXRNZXRob2RQcmlvcml0eSk7XG4gICAgICAgICAgICAgICAgd2hpbGUgKG1ldGhvZGNvcHkubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtZXRob2QgPSBtZXRob2Rjb3B5LnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtZXRob2QuZXZlbnRUeXBlICE9IGV2ZW50LnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChtZXRob2QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlcihtZXRob2QsIGV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZXZlbnQuaXNEaXNwb3NhYmxlKSB7XG4gICAgICAgICAgICBldmVudC5kZXN0cnVjdG9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBhZGRFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyLCB1c2VDYXB0dXJlID0gZmFsc2UsIHByaW9yaXR5ID0gMCwgdXNlV2Vha1JlZmVyZW5jZSA9IGZhbHNlLCBzY29wZSA9IG51bGwpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNSZWdpc3RlcmVkKHR5cGUsIGxpc3RlbmVyKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5yZWdpc3RlcmVkTGlzdGVuZXJzW3R5cGVdKSB7XG4gICAgICAgICAgICB0aGlzLnJlZ2lzdGVyZWRMaXN0ZW5lcnNbdHlwZV0gPSBbXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbWV0aG9kcyA9IHRoaXMucmVnaXN0ZXJlZExpc3RlbmVyc1t0eXBlXTtcbiAgICAgICAgdmFyIG1ldGhvZFNjb3BlID0gTWV0aG9kU2NvcGUuZ2V0TWV0aG9kU2NvcGUoKTtcbiAgICAgICAgbWV0aG9kU2NvcGUuZXZlbnRUeXBlID0gdHlwZTtcbiAgICAgICAgbWV0aG9kU2NvcGUucGFyZW50RGlzcGF0Y2hlciA9IHRoaXM7XG4gICAgICAgIG1ldGhvZFNjb3BlLm9iamVjdEZ1bmN0aW9uID0gbGlzdGVuZXI7XG4gICAgICAgIG1ldGhvZFNjb3BlLnNjb3BlID0gc2NvcGU7XG4gICAgICAgIG1ldGhvZFNjb3BlLnByaW9yaXR5ID0gcHJpb3JpdHk7XG4gICAgICAgIG1ldGhvZHMucHVzaChtZXRob2RTY29wZSk7XG4gICAgfVxuICAgIHRyaWdnZXIobWV0aG9kLCBldmVudCkge1xuICAgICAgICBpZiAobWV0aG9kLm9iamVjdEZ1bmN0aW9uKSB7XG4gICAgICAgICAgICBtZXRob2Qub2JqZWN0RnVuY3Rpb24uY2FsbChtZXRob2Quc2NvcGUsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRNZXRob2RQcmlvcml0eShtZXRob2QxLCBtZXRob2QyKSB7XG4gICAgICAgIGlmIChtZXRob2QxLnByaW9yaXR5ID4gbWV0aG9kMi5wcmlvcml0eSkge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICBpc1JlZ2lzdGVyZWQodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKCF0aGlzLnJlZ2lzdGVyZWRMaXN0ZW5lcnNbdHlwZV0pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbWV0aG9kcyA9IHRoaXMucmVnaXN0ZXJlZExpc3RlbmVyc1t0eXBlXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXRob2RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAobWV0aG9kc1tpXS5vYmplY3RGdW5jdGlvbiA9PSBsaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5leHBvcnRzLkV2ZW50RGlzcGF0Y2hlciA9IEV2ZW50RGlzcGF0Y2hlcjtcbmNsYXNzIE1ldGhvZFNjb3BlIGV4dGVuZHMgRmxhc2hCYXNlT2JqZWN0XzEuRmxhc2hCYXNlT2JqZWN0IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgIH1cbiAgICByZXNldCgpIHtcbiAgICAgICAgdGhpcy5vYmplY3RGdW5jdGlvbiA9IG51bGw7XG4gICAgICAgIHRoaXMuc2NvcGUgPSBudWxsO1xuICAgICAgICB0aGlzLnBhcmVudERpc3BhdGNoZXIgPSBudWxsO1xuICAgICAgICB0aGlzLnByaW9yaXR5ID0gMDtcbiAgICAgICAgdGhpcy5ldmVudFR5cGUgPSBudWxsO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0TWV0aG9kU2NvcGUoKSB7XG4gICAgICAgIGlmIChNZXRob2RTY29wZS5NZXRob2RTY29wZUNhY2hlLmxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IHRlID0gTWV0aG9kU2NvcGUuTWV0aG9kU2NvcGVDYWNoZVtNZXRob2RTY29wZS5NZXRob2RTY29wZUNhY2hlLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgTWV0aG9kU2NvcGUuTWV0aG9kU2NvcGVDYWNoZS5sZW5ndGggLT0gMTtcbiAgICAgICAgICAgIHRlLnJlc2V0KCk7XG4gICAgICAgICAgICByZXR1cm4gdGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBNZXRob2RTY29wZSgpO1xuICAgIH1cbiAgICBkZXN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLm9iamVjdEZ1bmN0aW9uID0gbnVsbDtcbiAgICAgICAgdGhpcy5zY29wZSA9IG51bGw7XG4gICAgICAgIHRoaXMucGFyZW50RGlzcGF0Y2hlciA9IG51bGw7XG4gICAgICAgIGxldCBpbmRleCA9IE1ldGhvZFNjb3BlLk1ldGhvZFNjb3BlQ2FjaGUuaW5kZXhPZih0aGlzKTtcbiAgICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICAgICAgTWV0aG9kU2NvcGUuTWV0aG9kU2NvcGVDYWNoZS51bnNoaWZ0KHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxufVxuTWV0aG9kU2NvcGUuTWV0aG9kU2NvcGVDYWNoZSA9IFtdO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBSZW5kZXJUZXh0dXJlXzEgPSByZXF1aXJlKFwiLi9SZW5kZXJUZXh0dXJlXCIpO1xuY29uc3QgUmVjdGFuZ2xlXzEgPSByZXF1aXJlKFwiLi4vZmxhc2gvZ2VvbS9SZWN0YW5nbGVcIik7XG5jb25zdCBDYW52YXNSZW5kZXJUYXJnZXRfMSA9IHJlcXVpcmUoXCIuL0NhbnZhc1JlbmRlclRhcmdldFwiKTtcbmNvbnN0IEluc3RhbmNlQ291bnRlcl8xID0gcmVxdWlyZShcIi4vSW5zdGFuY2VDb3VudGVyXCIpO1xuY2xhc3MgRXh0cmFjdCB7XG4gICAgY29uc3RydWN0b3IocmVuZGVyZXIpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ29sbGVjdGlvbiBvZiBtZXRob2RzIGZvciBleHRyYWN0aW5nIGRhdGEgKGltYWdlLCBwaXhlbHMsIGV0Yy4pIGZyb20gYSBkaXNwbGF5IG9iamVjdCBvciByZW5kZXIgdGV4dHVyZVxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLmV4dHJhY3QuRXh0cmFjdH0gZXh0cmFjdFxuICAgICAgICAgKiBAbWVtYmVyb2YgUElYSS5SZW5kZXJlciNcbiAgICAgICAgICogQHNlZSBQSVhJLmV4dHJhY3QuRXh0cmFjdFxuICAgICAgICAgKi9cbiAgICAgICAgcmVuZGVyZXIuZXh0cmFjdCA9IHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdpbGwgcmV0dXJuIGEgSFRNTCBJbWFnZSBvZiB0aGUgdGFyZ2V0XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BJWEkuRGlzcGxheU9iamVjdHxQSVhJLlJlbmRlclRleHR1cmV9IHRhcmdldCAtIEEgZGlzcGxheU9iamVjdCBvciByZW5kZXJUZXh0dXJlXG4gICAgICogIHRvIGNvbnZlcnQuIElmIGxlZnQgZW1wdHkgd2lsbCB1c2UgdGhlIG1haW4gcmVuZGVyZXJcbiAgICAgKiBAcmV0dXJuIHtIVE1MSW1hZ2VFbGVtZW50fSBIVE1MIEltYWdlIG9mIHRoZSB0YXJnZXRcbiAgICAgKi9cbiAgICBpbWFnZSh0YXJnZXQpIHtcbiAgICAgICAgdmFyIGltYWdlID0gbmV3IEltYWdlKCk7XG4gICAgICAgIGltYWdlLnNyYyA9IHRoaXMuYmFzZTY0KHRhcmdldCk7XG4gICAgICAgIHJldHVybiBpbWFnZTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFdpbGwgcmV0dXJuIGEgYSBiYXNlNjQgZW5jb2RlZCBzdHJpbmcgb2YgdGhpcyB0YXJnZXQuIEl0IHdvcmtzIGJ5IGNhbGxpbmdcbiAgICAgKiAgYEV4dHJhY3QuZ2V0Q2FudmFzYCBhbmQgdGhlbiBydW5uaW5nIHRvRGF0YVVSTCBvbiB0aGF0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQSVhJLkRpc3BsYXlPYmplY3R8UElYSS5SZW5kZXJUZXh0dXJlfSB0YXJnZXQgLSBBIGRpc3BsYXlPYmplY3Qgb3IgcmVuZGVyVGV4dHVyZVxuICAgICAqICB0byBjb252ZXJ0LiBJZiBsZWZ0IGVtcHR5IHdpbGwgdXNlIHRoZSBtYWluIHJlbmRlcmVyXG4gICAgICogQHJldHVybiB7c3RyaW5nfSBBIGJhc2U2NCBlbmNvZGVkIHN0cmluZyBvZiB0aGUgdGV4dHVyZS5cbiAgICAgKi9cbiAgICBiYXNlNjQodGFyZ2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbnZhcyh0YXJnZXQpLnRvRGF0YVVSTCgpO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIENhbnZhcyBlbGVtZW50LCByZW5kZXJzIHRoaXMgdGFyZ2V0IHRvIGl0IGFuZCB0aGVuIHJldHVybnMgaXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BJWEkuRGlzcGxheU9iamVjdHxQSVhJLlJlbmRlclRleHR1cmV9IHRhcmdldCAtIEEgZGlzcGxheU9iamVjdCBvciByZW5kZXJUZXh0dXJlXG4gICAgICogIHRvIGNvbnZlcnQuIElmIGxlZnQgZW1wdHkgd2lsbCB1c2UgdGhlIG1haW4gcmVuZGVyZXJcbiAgICAgKiBAcmV0dXJuIHtIVE1MQ2FudmFzRWxlbWVudH0gQSBDYW52YXMgZWxlbWVudCB3aXRoIHRoZSB0ZXh0dXJlIHJlbmRlcmVkIG9uLlxuICAgICAqL1xuICAgIGNhbnZhcyh0YXJnZXQpIHtcbiAgICAgICAgdmFyIHJlbmRlcmVyID0gdGhpcy5yZW5kZXJlcjtcbiAgICAgICAgdmFyIHJlc29sdXRpb247XG4gICAgICAgIHZhciBmcmFtZTtcbiAgICAgICAgdmFyIGZsaXBZID0gZmFsc2U7XG4gICAgICAgIHZhciByZW5kZXJUZXh0dXJlO1xuICAgICAgICB2YXIgZ2VuZXJhdGVkID0gZmFsc2U7XG4gICAgICAgIGlmICh0YXJnZXQpIHtcbiAgICAgICAgICAgIGlmICh0YXJnZXQgaW5zdGFuY2VvZiBSZW5kZXJUZXh0dXJlXzEuUmVuZGVyVGV4dHVyZSkge1xuICAgICAgICAgICAgICAgIHJlbmRlclRleHR1cmUgPSB0YXJnZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZW5kZXJUZXh0dXJlID0gdGhpcy5yZW5kZXJlci5nZW5lcmF0ZVRleHR1cmUodGFyZ2V0KTtcbiAgICAgICAgICAgICAgICBnZW5lcmF0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChyZW5kZXJUZXh0dXJlKSB7XG4gICAgICAgICAgICByZXNvbHV0aW9uID0gcmVuZGVyVGV4dHVyZS5iYXNlVGV4dHVyZS5yZXNvbHV0aW9uO1xuICAgICAgICAgICAgZnJhbWUgPSByZW5kZXJUZXh0dXJlLmZyYW1lO1xuICAgICAgICAgICAgZmxpcFkgPSBmYWxzZTtcbiAgICAgICAgICAgIHJlbmRlcmVyLnJlbmRlclRleHR1cmUuYmluZChyZW5kZXJUZXh0dXJlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc29sdXRpb24gPSB0aGlzLnJlbmRlcmVyLnJlc29sdXRpb247XG4gICAgICAgICAgICBmbGlwWSA9IHRydWU7XG4gICAgICAgICAgICBJbnN0YW5jZUNvdW50ZXJfMS5JbnN0YW5jZUNvdW50ZXIuYWRkQ2FsbChcIlJlY3RhbmdsZS5nZXRSZWN0YW5nbGVcIiwgXCJFeHRyYWN0IGNhbnZhc1wiKTtcbiAgICAgICAgICAgIGZyYW1lID0gUmVjdGFuZ2xlXzEuUmVjdGFuZ2xlLmdldFJlY3RhbmdsZSgpO1xuICAgICAgICAgICAgZnJhbWUud2lkdGggPSB0aGlzLnJlbmRlcmVyLndpZHRoO1xuICAgICAgICAgICAgZnJhbWUuaGVpZ2h0ID0gdGhpcy5yZW5kZXJlci5oZWlnaHQ7XG4gICAgICAgICAgICByZW5kZXJlci5yZW5kZXJUZXh0dXJlLmJpbmQobnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHdpZHRoID0gZnJhbWUud2lkdGggKiByZXNvbHV0aW9uO1xuICAgICAgICB2YXIgaGVpZ2h0ID0gZnJhbWUuaGVpZ2h0ICogcmVzb2x1dGlvbjtcbiAgICAgICAgdmFyIGNhbnZhc0J1ZmZlciA9IG5ldyBDYW52YXNSZW5kZXJUYXJnZXRfMS5DYW52YXNSZW5kZXJUYXJnZXQod2lkdGgsIGhlaWdodCwgMSk7XG4gICAgICAgIHZhciB3ZWJnbFBpeGVscyA9IG5ldyBVaW50OEFycmF5KEV4dHJhY3QuQllURVNfUEVSX1BJWEVMICogd2lkdGggKiBoZWlnaHQpO1xuICAgICAgICAvLyByZWFkIHBpeGVscyB0byB0aGUgYXJyYXlcbiAgICAgICAgdmFyIGdsID0gcmVuZGVyZXIuZ2w7XG4gICAgICAgIGdsLnJlYWRQaXhlbHMoZnJhbWUueCAqIHJlc29sdXRpb24sIGZyYW1lLnkgKiByZXNvbHV0aW9uLCB3aWR0aCwgaGVpZ2h0LCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCB3ZWJnbFBpeGVscyk7XG4gICAgICAgIC8vIGFkZCB0aGUgcGl4ZWxzIHRvIHRoZSBjYW52YXNcbiAgICAgICAgdmFyIGNhbnZhc0RhdGEgPSBjYW52YXNCdWZmZXIuY29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIGNhbnZhc0RhdGEuZGF0YS5zZXQod2ViZ2xQaXhlbHMpO1xuICAgICAgICBjYW52YXNCdWZmZXIuY29udGV4dC5wdXRJbWFnZURhdGEoY2FudmFzRGF0YSwgMCwgMCk7XG4gICAgICAgIC8vIHB1bGxpbmcgcGl4ZWxzXG4gICAgICAgIGlmIChmbGlwWSkge1xuICAgICAgICAgICAgY2FudmFzQnVmZmVyLmNvbnRleHQuc2NhbGUoMSwgLTEpO1xuICAgICAgICAgICAgY2FudmFzQnVmZmVyLmNvbnRleHQuZHJhd0ltYWdlKGNhbnZhc0J1ZmZlci5jYW52YXMsIDAsIC1oZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChnZW5lcmF0ZWQpIHtcbiAgICAgICAgICAgIHJlbmRlclRleHR1cmUuZGVzdHJveSh0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBzZW5kIHRoZSBjYW52YXMgYmFjay4uXG4gICAgICAgIHJldHVybiBjYW52YXNCdWZmZXIuY2FudmFzO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogV2lsbCByZXR1cm4gYSBvbmUtZGltZW5zaW9uYWwgYXJyYXkgY29udGFpbmluZyB0aGUgcGl4ZWwgZGF0YSBvZiB0aGUgZW50aXJlIHRleHR1cmUgaW4gUkdCQVxuICAgICAqIG9yZGVyLCB3aXRoIGludGVnZXIgdmFsdWVzIGJldHdlZW4gMCBhbmQgMjU1IChpbmNsdWRlZCkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BJWEkuRGlzcGxheU9iamVjdHxQSVhJLlJlbmRlclRleHR1cmV9IHRhcmdldCAtIEEgZGlzcGxheU9iamVjdCBvciByZW5kZXJUZXh0dXJlXG4gICAgICogIHRvIGNvbnZlcnQuIElmIGxlZnQgZW1wdHkgd2lsbCB1c2UgdGhlIG1haW4gcmVuZGVyZXJcbiAgICAgKiBAcmV0dXJuIHtVaW50OENsYW1wZWRBcnJheX0gT25lLWRpbWVuc2lvbmFsIGFycmF5IGNvbnRhaW5pbmcgdGhlIHBpeGVsIGRhdGEgb2YgdGhlIGVudGlyZSB0ZXh0dXJlXG4gICAgICovXG4gICAgcGl4ZWxzKHRhcmdldCkge1xuICAgICAgICB2YXIgcmVuZGVyZXIgPSB0aGlzLnJlbmRlcmVyO1xuICAgICAgICB2YXIgcmVzb2x1dGlvbjtcbiAgICAgICAgdmFyIGZyYW1lO1xuICAgICAgICB2YXIgcmVuZGVyVGV4dHVyZTtcbiAgICAgICAgdmFyIGdlbmVyYXRlZCA9IGZhbHNlO1xuICAgICAgICBpZiAodGFyZ2V0KSB7XG4gICAgICAgICAgICBpZiAodGFyZ2V0IGluc3RhbmNlb2YgUmVuZGVyVGV4dHVyZV8xLlJlbmRlclRleHR1cmUpIHtcbiAgICAgICAgICAgICAgICByZW5kZXJUZXh0dXJlID0gdGFyZ2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVuZGVyVGV4dHVyZSA9IHRoaXMucmVuZGVyZXIuZ2VuZXJhdGVUZXh0dXJlKHRhcmdldCk7XG4gICAgICAgICAgICAgICAgZ2VuZXJhdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocmVuZGVyVGV4dHVyZSkge1xuICAgICAgICAgICAgcmVzb2x1dGlvbiA9IHJlbmRlclRleHR1cmUuYmFzZVRleHR1cmUucmVzb2x1dGlvbjtcbiAgICAgICAgICAgIGZyYW1lID0gcmVuZGVyVGV4dHVyZS5mcmFtZTtcbiAgICAgICAgICAgIC8vIGJpbmQgdGhlIGJ1ZmZlclxuICAgICAgICAgICAgcmVuZGVyZXIucmVuZGVyVGV4dHVyZS5iaW5kKHJlbmRlclRleHR1cmUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzb2x1dGlvbiA9IHJlbmRlcmVyLnJlc29sdXRpb247XG4gICAgICAgICAgICBJbnN0YW5jZUNvdW50ZXJfMS5JbnN0YW5jZUNvdW50ZXIuYWRkQ2FsbChcIlJlY3RhbmdsZS5nZXRSZWN0YW5nbGVcIiwgXCJFeHRyYWN0IHBpeGVsc1wiKTtcbiAgICAgICAgICAgIGZyYW1lID0gUmVjdGFuZ2xlXzEuUmVjdGFuZ2xlLmdldFJlY3RhbmdsZSgpO1xuICAgICAgICAgICAgZnJhbWUud2lkdGggPSByZW5kZXJlci53aWR0aDtcbiAgICAgICAgICAgIGZyYW1lLmhlaWdodCA9IHJlbmRlcmVyLmhlaWdodDtcbiAgICAgICAgICAgIHJlbmRlcmVyLnJlbmRlclRleHR1cmUuYmluZChudWxsKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgd2lkdGggPSBmcmFtZS53aWR0aCAqIHJlc29sdXRpb247XG4gICAgICAgIHZhciBoZWlnaHQgPSBmcmFtZS5oZWlnaHQgKiByZXNvbHV0aW9uO1xuICAgICAgICB2YXIgd2ViZ2xQaXhlbHMgPSBuZXcgVWludDhBcnJheShFeHRyYWN0LkJZVEVTX1BFUl9QSVhFTCAqIHdpZHRoICogaGVpZ2h0KTtcbiAgICAgICAgLy8gcmVhZCBwaXhlbHMgdG8gdGhlIGFycmF5XG4gICAgICAgIHZhciBnbCA9IHJlbmRlcmVyLmdsO1xuICAgICAgICBnbC5yZWFkUGl4ZWxzKGZyYW1lLnggKiByZXNvbHV0aW9uLCBmcmFtZS55ICogcmVzb2x1dGlvbiwgd2lkdGgsIGhlaWdodCwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgd2ViZ2xQaXhlbHMpO1xuICAgICAgICBpZiAoZ2VuZXJhdGVkKSB7XG4gICAgICAgICAgICByZW5kZXJUZXh0dXJlLmRlc3Ryb3kodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdlYmdsUGl4ZWxzO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogRGVzdHJveXMgdGhlIGV4dHJhY3RcbiAgICAgKlxuICAgICAqL1xuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMucmVuZGVyZXIuZXh0cmFjdCA9IG51bGw7XG4gICAgICAgIHRoaXMucmVuZGVyZXIgPSBudWxsO1xuICAgIH1cbiAgICA7XG59XG4vLyBzdGF0aWMgVEVNUF9SRUNUID0gbmV3IFJlY3RhbmdsZSgpO1xuRXh0cmFjdC5CWVRFU19QRVJfUElYRUwgPSA0O1xuZXhwb3J0cy5FeHRyYWN0ID0gRXh0cmFjdDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgVGV4dHVyZV8xID0gcmVxdWlyZShcIi4vVGV4dHVyZVwiKTtcbmNvbnN0IEZsYXNoQmFzZU9iamVjdF8xID0gcmVxdWlyZShcIi4vRmxhc2hCYXNlT2JqZWN0XCIpO1xuY2xhc3MgRmlsbFN0eWxlIGV4dGVuZHMgRmxhc2hCYXNlT2JqZWN0XzEuRmxhc2hCYXNlT2JqZWN0IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbG9uZXMgdGhlIG9iamVjdFxuICAgICAqXG4gICAgICogQHJldHVybiB7UElYSS5GaWxsU3R5bGV9XG4gICAgICovXG4gICAgY2xvbmUoKSB7XG4gICAgICAgIHZhciBvYmogPSBuZXcgRmlsbFN0eWxlKCk7XG4gICAgICAgIG9iai5jb2xvciA9IHRoaXMuY29sb3I7XG4gICAgICAgIG9iai5hbHBoYSA9IHRoaXMuYWxwaGE7XG4gICAgICAgIG9iai50ZXh0dXJlID0gdGhpcy50ZXh0dXJlO1xuICAgICAgICBvYmoubWF0cml4ID0gdGhpcy5tYXRyaXg7XG4gICAgICAgIG9iai52aXNpYmxlID0gdGhpcy52aXNpYmxlO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogUmVzZXRcbiAgICAgKi9cbiAgICByZXNldCgpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBoZXggY29sb3IgdmFsdWUgdXNlZCB3aGVuIGNvbG9yaW5nIHRoZSBHcmFwaGljcyBvYmplY3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgMVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jb2xvciA9IDB4RkZGRkZGO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGFscGhhIHZhbHVlIHVzZWQgd2hlbiBmaWxsaW5nIHRoZSBHcmFwaGljcyBvYmplY3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgMVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hbHBoYSA9IDE7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdGV4dHVyZSB0byBiZSB1c2VkIGZvciB0aGUgZmlsbC5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7c3RyaW5nfVxuICAgICAgICAgKiBAZGVmYXVsdCAwXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRleHR1cmUgPSBUZXh0dXJlXzEuVGV4dHVyZS5XSElURTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0cmFuc2Zvcm0gYXBscGllZCB0byB0aGUgdGV4dHVyZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7c3RyaW5nfVxuICAgICAgICAgKiBAZGVmYXVsdCAwXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm1hdHJpeCA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB0aGUgY3VycmVudCBmaWxsIGlzIHZpc2libGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XG4gICAgICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnZpc2libGUgPSBmYWxzZTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIERlc3Ryb3kgYW5kIGRvbid0IHVzZSBhZnRlciB0aGlzXG4gICAgICovXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy50ZXh0dXJlID0gbnVsbDtcbiAgICAgICAgdGhpcy5tYXRyaXggPSBudWxsO1xuICAgIH1cbiAgICA7XG59XG5leHBvcnRzLkZpbGxTdHlsZSA9IEZpbGxTdHlsZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgU2hhZGVyXzEgPSByZXF1aXJlKFwiLi9TaGFkZXJcIik7XG5jb25zdCBQcm9ncmFtXzEgPSByZXF1aXJlKFwiLi9Qcm9ncmFtXCIpO1xuY29uc3Qgc2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL3NldHRpbmdzXCIpO1xuY29uc3QgU3RhdGVfMSA9IHJlcXVpcmUoXCIuL1N0YXRlXCIpO1xuY2xhc3MgRmlsdGVyIGV4dGVuZHMgU2hhZGVyXzEuU2hhZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcih2ZXJ0ZXhTcmMgPSBudWxsLCBmcmFnbWVudFNyYyA9IG51bGwsIHVuaWZvcm1zID0gbnVsbCkge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IFByb2dyYW1fMS5Qcm9ncmFtLmZyb20odmVydGV4U3JjIHx8IEZpbHRlci5kZWZhdWx0VmVydGV4U3JjLCBmcmFnbWVudFNyYyB8fCBGaWx0ZXIuZGVmYXVsdEZyYWdtZW50U3JjKTtcbiAgICAgICAgc3VwZXIocHJvZ3JhbSwgdW5pZm9ybXMpO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHBhZGRpbmcgb2YgdGhlIGZpbHRlci4gU29tZSBmaWx0ZXJzIHJlcXVpcmUgZXh0cmEgc3BhY2UgdG8gYnJlYXRoIHN1Y2ggYXMgYSBibHVyLlxuICAgICAgICAgKiBJbmNyZWFzaW5nIHRoaXMgd2lsbCBhZGQgZXh0cmEgd2lkdGggYW5kIGhlaWdodCB0byB0aGUgYm91bmRzIG9mIHRoZSBvYmplY3QgdGhhdCB0aGVcbiAgICAgICAgICogZmlsdGVyIGlzIGFwcGxpZWQgdG8uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucGFkZGluZyA9IDA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgcmVzb2x1dGlvbiBvZiB0aGUgZmlsdGVyLiBTZXR0aW5nIHRoaXMgdG8gYmUgbG93ZXIgd2lsbCBsb3dlciB0aGUgcXVhbGl0eSBidXRcbiAgICAgICAgICogaW5jcmVhc2UgdGhlIHBlcmZvcm1hbmNlIG9mIHRoZSBmaWx0ZXIuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVzb2x1dGlvbiA9IHNldHRpbmdzXzEuc2V0dGluZ3MuRklMVEVSX1JFU09MVVRJT047XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBlbmFibGVkIGlzIHRydWUgdGhlIGZpbHRlciBpcyBhcHBsaWVkLCBpZiBmYWxzZSBpdCB3aWxsIG5vdC5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZW5hYmxlZCA9IHRydWU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBlbmFibGVkLCBQaXhpSlMgd2lsbCBmaXQgdGhlIGZpbHRlciBhcmVhIGludG8gYm91bmRhcmllcyBmb3IgYmV0dGVyIHBlcmZvcm1hbmNlLlxuICAgICAgICAgKiBTd2l0Y2ggaXQgb2ZmIGlmIGl0IGRvZXMgbm90IHdvcmsgZm9yIHNwZWNpZmljIHNoYWRlci5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYXV0b0ZpdCA9IHRydWU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMZWdhY3kgZmlsdGVycyB1c2UgcG9zaXRpb24gYW5kIHV2cyBmcm9tIGF0dHJpYnV0ZXNcbiAgICAgICAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICAgICAgICogQHJlYWRvbmx5XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmxlZ2FjeSA9ICEhdGhpcy5wcm9ncmFtLmF0dHJpYnV0ZURhdGEuYVRleHR1cmVDb29yZDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBXZWJHTCBzdGF0ZSB0aGUgZmlsdGVyIHJlcXVpcmVzIHRvIHJlbmRlclxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLlN0YXRlfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdGF0ZSA9IG5ldyBTdGF0ZV8xLlN0YXRlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgdGhlIGZpbHRlclxuICAgICAqXG4gICAgICogQHBhcmFtIHtQSVhJLnN5c3RlbXMuRmlsdGVyU3lzdGVtfSBmaWx0ZXJNYW5hZ2VyIC0gVGhlIHJlbmRlcmVyIHRvIHJldHJpZXZlIHRoZSBmaWx0ZXIgZnJvbVxuICAgICAqIEBwYXJhbSB7UElYSS5SZW5kZXJUZXh0dXJlfSBpbnB1dCAtIFRoZSBpbnB1dCByZW5kZXIgdGFyZ2V0LlxuICAgICAqIEBwYXJhbSB7UElYSS5SZW5kZXJUZXh0dXJlfSBvdXRwdXQgLSBUaGUgdGFyZ2V0IHRvIG91dHB1dCB0by5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGNsZWFyIC0gU2hvdWxkIHRoZSBvdXRwdXQgYmUgY2xlYXJlZCBiZWZvcmUgcmVuZGVyaW5nIHRvIGl0XG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtjdXJyZW50U3RhdGVdIC0gSXQncyBjdXJyZW50IHN0YXRlIG9mIGZpbHRlci5cbiAgICAgKiAgICAgICAgVGhlcmUgYXJlIHNvbWUgdXNlZnVsIHByb3BlcnRpZXMgaW4gdGhlIGN1cnJlbnRTdGF0ZSA6XG4gICAgICogICAgICAgIHRhcmdldCwgZmlsdGVycywgc291cmNlRnJhbWUsIGRlc3RpbmF0aW9uRnJhbWUsIHJlbmRlclRhcmdldCwgcmVzb2x1dGlvblxuICAgICAqL1xuICAgIGFwcGx5KGZpbHRlck1hbmFnZXIsIGlucHV0LCBvdXRwdXQsIGNsZWFyLCBjdXJyZW50U3RhdGUsIGRlcnApIHtcbiAgICAgICAgLy8gZG8gYXMgeW91IHBsZWFzZSFcbiAgICAgICAgZmlsdGVyTWFuYWdlci5hcHBseUZpbHRlcih0aGlzLCBpbnB1dCwgb3V0cHV0LCBjbGVhciwgY3VycmVudFN0YXRlLCBkZXJwKTtcbiAgICAgICAgLy8gb3IganVzdCBkbyBhIHJlZ3VsYXIgcmVuZGVyLi5cbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGJsZW5kbW9kZSBvZiB0aGUgZmlsdGVyXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICogQGRlZmF1bHQgUElYSS5CTEVORF9NT0RFUy5OT1JNQUxcbiAgICAgKi9cbiAgICBnZXQgYmxlbmRNb2RlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5ibGVuZE1vZGU7XG4gICAgfVxuICAgIDtcbiAgICBzZXQgYmxlbmRNb2RlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuc3RhdGUuYmxlbmRNb2RlID0gdmFsdWU7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBUaGUgZGVmYXVsdCB2ZXJ0ZXggc2hhZGVyIHNvdXJjZVxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQGNvbnN0YW50XG4gICAgICovXG4gICAgc3RhdGljIGdldCBkZWZhdWx0VmVydGV4U3JjKCkge1xuICAgICAgICByZXR1cm4gRmlsdGVyLmRlZmF1bHRWZXJ0ZXgkMTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFRoZSBkZWZhdWx0IGZyYWdtZW50IHNoYWRlciBzb3VyY2VcbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBjb25zdGFudFxuICAgICAqL1xuICAgIHN0YXRpYyBnZXQgZGVmYXVsdEZyYWdtZW50U3JjKCkge1xuICAgICAgICByZXR1cm4gRmlsdGVyLmRlZmF1bHRGcmFnbWVudCQxO1xuICAgIH1cbiAgICA7XG59XG4vKipcbiAqIFVzZWQgZm9yIGNhY2hpbmcgc2hhZGVyIElEc1xuICpcbiAqIEBzdGF0aWNcbiAqIEB0eXBlIHtvYmplY3R9XG4gKiBAcHJvdGVjdGVkXG4gKi9cbkZpbHRlci5TT1VSQ0VfS0VZX01BUCA9IHt9O1xuRmlsdGVyLmRlZmF1bHRWZXJ0ZXgkMSA9IFwiYXR0cmlidXRlIHZlYzIgYVZlcnRleFBvc2l0aW9uO1xcclxcblxcclxcbnVuaWZvcm0gbWF0MyBwcm9qZWN0aW9uTWF0cml4O1xcclxcblxcclxcbnZhcnlpbmcgdmVjMiB2VGV4dHVyZUNvb3JkO1xcclxcblxcclxcbnVuaWZvcm0gdmVjNCBpbnB1dFNpemU7XFxyXFxudW5pZm9ybSB2ZWM0IG91dHB1dEZyYW1lO1xcclxcblxcclxcbnZlYzQgZmlsdGVyVmVydGV4UG9zaXRpb24oIHZvaWQgKVxcclxcbntcXHJcXG4gICAgdmVjMiBwb3NpdGlvbiA9IGFWZXJ0ZXhQb3NpdGlvbiAqIG1heChvdXRwdXRGcmFtZS56dywgdmVjMigwLikpICsgb3V0cHV0RnJhbWUueHk7XFxyXFxuXFxyXFxuICAgIHJldHVybiB2ZWM0KChwcm9qZWN0aW9uTWF0cml4ICogdmVjMyhwb3NpdGlvbiwgMS4wKSkueHksIDAuMCwgMS4wKTtcXHJcXG59XFxyXFxuXFxyXFxudmVjMiBmaWx0ZXJUZXh0dXJlQ29vcmQoIHZvaWQgKVxcclxcbntcXHJcXG4gICAgcmV0dXJuIGFWZXJ0ZXhQb3NpdGlvbiAqIChvdXRwdXRGcmFtZS56dyAqIGlucHV0U2l6ZS56dyk7XFxyXFxufVxcclxcblxcclxcbnZvaWQgbWFpbih2b2lkKVxcclxcbntcXHJcXG4gICAgZ2xfUG9zaXRpb24gPSBmaWx0ZXJWZXJ0ZXhQb3NpdGlvbigpO1xcclxcbiAgICB2VGV4dHVyZUNvb3JkID0gZmlsdGVyVGV4dHVyZUNvb3JkKCk7XFxyXFxufVxcclxcblwiO1xuRmlsdGVyLmRlZmF1bHRGcmFnbWVudCQxID0gXCJ2YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXHJcXG5cXHJcXG51bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjtcXHJcXG5cXHJcXG52b2lkIG1haW4odm9pZCl7XFxyXFxuICAgZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2VGV4dHVyZUNvb3JkKTtcXHJcXG59XFxyXFxuXCI7XG5leHBvcnRzLkZpbHRlciA9IEZpbHRlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgUmVjdGFuZ2xlXzEgPSByZXF1aXJlKFwiLi4vZmxhc2gvZ2VvbS9SZWN0YW5nbGVcIik7XG5jb25zdCBJbnN0YW5jZUNvdW50ZXJfMSA9IHJlcXVpcmUoXCIuL0luc3RhbmNlQ291bnRlclwiKTtcbmNsYXNzIEZpbHRlclN0YXRlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJUZXh0dXJlID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRhcmdldCBvZiB0aGUgZmlsdGVyc1xuICAgICAgICAgKiBXZSBzdG9yZSBmb3IgY2FzZSB3aGVuIGN1c3RvbSBmaWx0ZXIgd2FudHMgdG8ga25vdyB0aGUgZWxlbWVudCBpdCB3YXMgYXBwbGllZCBvblxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLkRpc3BsYXlPYmplY3R9XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRhcmdldCA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb21wYXRpYmlsaXR5IHdpdGggUGl4aUpTIHY0IGZpbHRlcnNcbiAgICAgICAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICAgICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubGVnYWN5ID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXNvbHV0aW9uIG9mIGZpbHRlcnNcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAxXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJlc29sdXRpb24gPSAxO1xuICAgICAgICAvLyBuZXh0IHRocmVlIGZpZWxkcyBhcmUgY3JlYXRlZCBvbmx5IGZvciByb290XG4gICAgICAgIC8vIHJlLWFzc2lnbmVkIGZvciBldmVyeXRoaW5nIGVsc2VcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNvdXJjZSBmcmFtZVxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLlJlY3RhbmdsZX1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIEluc3RhbmNlQ291bnRlcl8xLkluc3RhbmNlQ291bnRlci5hZGRDYWxsKFwiUmVjdGFuZ2xlLmdldFJlY3RhbmdsZVwiLCBcIkZpbHRlclN0YXRlXCIpO1xuICAgICAgICB0aGlzLnNvdXJjZUZyYW1lID0gUmVjdGFuZ2xlXzEuUmVjdGFuZ2xlLmdldFJlY3RhbmdsZSgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRGVzdGluYXRpb24gZnJhbWVcbiAgICAgICAgICogQG1lbWJlciB7UElYSS5SZWN0YW5nbGV9XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBJbnN0YW5jZUNvdW50ZXJfMS5JbnN0YW5jZUNvdW50ZXIuYWRkQ2FsbChcIlJlY3RhbmdsZS5nZXRSZWN0YW5nbGVcIiwgXCJGaWx0ZXJTdGF0ZVwiKTtcbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbkZyYW1lID0gUmVjdGFuZ2xlXzEuUmVjdGFuZ2xlLmdldFJlY3RhbmdsZSgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ29sbGVjdGlvbiBvZiBmaWx0ZXJzXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuRmlsdGVyW119XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmZpbHRlcnMgPSBbXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogY2xlYXJzIHRoZSBzdGF0ZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgY2xlYXIoKSB7XG4gICAgICAgIHRoaXMudGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5maWx0ZXJzID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZW5kZXJUZXh0dXJlID0gbnVsbDtcbiAgICB9XG4gICAgO1xufVxuZXhwb3J0cy5GaWx0ZXJTdGF0ZSA9IEZpbHRlclN0YXRlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBTeXN0ZW1fMSA9IHJlcXVpcmUoXCIuL1N5c3RlbVwiKTtcbmNvbnN0IFF1YWRfMSA9IHJlcXVpcmUoXCIuL1F1YWRcIik7XG5jb25zdCBRdWFkVXZfMSA9IHJlcXVpcmUoXCIuL1F1YWRVdlwiKTtcbmNvbnN0IFJlY3RhbmdsZV8xID0gcmVxdWlyZShcIi4uL2ZsYXNoL2dlb20vUmVjdGFuZ2xlXCIpO1xuY29uc3QgVW5pZm9ybUdyb3VwXzEgPSByZXF1aXJlKFwiLi9Vbmlmb3JtR3JvdXBcIik7XG5jb25zdCBSZW5kZXJUZXh0dXJlXzEgPSByZXF1aXJlKFwiLi9SZW5kZXJUZXh0dXJlXCIpO1xuY29uc3QgTWF0cml4XzEgPSByZXF1aXJlKFwiLi9NYXRyaXhcIik7XG5jb25zdCBGaWx0ZXJTdGF0ZV8xID0gcmVxdWlyZShcIi4vRmlsdGVyU3RhdGVcIik7XG5jb25zdCBEcmF3TW9kZVNldHRpbmdzXzEgPSByZXF1aXJlKFwiLi9EcmF3TW9kZVNldHRpbmdzXCIpO1xuY29uc3QgTWF0aFNldHRpbmdzXzEgPSByZXF1aXJlKFwiLi9NYXRoU2V0dGluZ3NcIik7XG5jb25zdCBJbnN0YW5jZUNvdW50ZXJfMSA9IHJlcXVpcmUoXCIuL0luc3RhbmNlQ291bnRlclwiKTtcbmNsYXNzIEZpbHRlclN5c3RlbSBleHRlbmRzIFN5c3RlbV8xLlN5c3RlbSB7XG4gICAgY29uc3RydWN0b3IocmVuZGVyZXIpIHtcbiAgICAgICAgc3VwZXIocmVuZGVyZXIpO1xuICAgICAgICAvKipcbiAgICAgICAgICogTGlzdCBvZiBmaWx0ZXJzIGZvciB0aGUgRmlsdGVyU3lzdGVtXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdFtdfVxuICAgICAgICAgKiBAcmVhZG9ubHlcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGVmYXVsdEZpbHRlclN0YWNrID0gW3t9XTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHN0b3JlcyBhIGJ1bmNoIG9mIFBPMiB0ZXh0dXJlcyB1c2VkIGZvciBmaWx0ZXJpbmdcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50ZXh0dXJlUG9vbCA9IHt9O1xuICAgICAgICAvKipcbiAgICAgICAgICogYSBwb29sIGZvciBzdG9yaW5nIGZpbHRlciBzdGF0ZXMsIHNhdmUgdXMgY3JlYXRpbmcgbmV3IG9uZXMgZWFjaCB0aWNrXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdFtdfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdGF0ZVBvb2wgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgdmVyeSBzaW1wbGUgZ2VvbWV0cnkgdXNlZCB3aGVuIGRyYXdpbmcgYSBmaWx0ZXIgZWZmZWN0IHRvIHRoZSBzY3JlZW5cbiAgICAgICAgICogQG1lbWJlciB7UElYSS5RdWFkfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5xdWFkID0gbmV3IFF1YWRfMS5RdWFkKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBRdWFkIFVWc1xuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLlF1YWRVdn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucXVhZFV2ID0gbmV3IFF1YWRVdl8xLlF1YWRVdigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGVtcG9yYXJ5IHJlY3QgZm9yIG1hdGhzXG4gICAgICAgICAqIEB0eXBlIHtQSVhJLlJlY3RhbmdsZX1cbiAgICAgICAgICovXG4gICAgICAgIEluc3RhbmNlQ291bnRlcl8xLkluc3RhbmNlQ291bnRlci5hZGRDYWxsKFwiUmVjdGFuZ2xlLmdldFJlY3RhbmdsZVwiLCBcIkZpbHRlclN5c3RlbVwiKTtcbiAgICAgICAgdGhpcy50ZW1wUmVjdCA9IFJlY3RhbmdsZV8xLlJlY3RhbmdsZS5nZXRSZWN0YW5nbGUoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFjdGl2ZSBzdGF0ZVxuICAgICAgICAgKiBAbWVtYmVyIHtvYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmFjdGl2ZVN0YXRlID0ge307XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIHVuaWZvcm0gZ3JvdXAgaXMgYXR0YWNoZWQgdG8gZmlsdGVyIHVuaWZvcm1zIHdoZW4gdXNlZFxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLlVuaWZvcm1Hcm91cH1cbiAgICAgICAgICogQHByb3BlcnR5IHtQSVhJLlJlY3RhbmdsZX0gb3V0cHV0RnJhbWVcbiAgICAgICAgICogQHByb3BlcnR5IHtGbG9hdDMyQXJyYXl9IGlucHV0U2l6ZVxuICAgICAgICAgKiBAcHJvcGVydHkge0Zsb2F0MzJBcnJheX0gaW5wdXRQaXhlbFxuICAgICAgICAgKiBAcHJvcGVydHkge0Zsb2F0MzJBcnJheX0gaW5wdXRDbGFtcFxuICAgICAgICAgKiBAcHJvcGVydHkge051bWJlcn0gcmVzb2x1dGlvblxuICAgICAgICAgKiBAcHJvcGVydHkge0Zsb2F0MzJBcnJheX0gZmlsdGVyQXJlYVxuICAgICAgICAgKiBAcHJvcGVydHkge0Zsb2FkMzJBcnJheX0gZmlsdGVyQ2xhbXBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZ2xvYmFsVW5pZm9ybXMgPSBuZXcgVW5pZm9ybUdyb3VwXzEuVW5pZm9ybUdyb3VwKHtcbiAgICAgICAgICAgIG91dHB1dEZyYW1lOiB0aGlzLnRlbXBSZWN0LFxuICAgICAgICAgICAgaW5wdXRTaXplOiBuZXcgRmxvYXQzMkFycmF5KDQpLFxuICAgICAgICAgICAgaW5wdXRQaXhlbDogbmV3IEZsb2F0MzJBcnJheSg0KSxcbiAgICAgICAgICAgIGlucHV0Q2xhbXA6IG5ldyBGbG9hdDMyQXJyYXkoNCksXG4gICAgICAgICAgICByZXNvbHV0aW9uOiAxLFxuICAgICAgICAgICAgLy8gbGVnYWN5IHZhcmlhYmxlc1xuICAgICAgICAgICAgZmlsdGVyQXJlYTogbmV3IEZsb2F0MzJBcnJheSg0KSxcbiAgICAgICAgICAgIGZpbHRlckNsYW1wOiBuZXcgRmxvYXQzMkFycmF5KDQpLFxuICAgICAgICB9LCB0cnVlKTtcbiAgICAgICAgdGhpcy5fcGl4ZWxzV2lkdGggPSByZW5kZXJlci52aWV3LndpZHRoO1xuICAgICAgICB0aGlzLl9waXhlbHNIZWlnaHQgPSByZW5kZXJlci52aWV3LmhlaWdodDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhIG5ldyBmaWx0ZXIgdG8gdGhlIFN5c3RlbS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UElYSS5EaXNwbGF5T2JqZWN0fSB0YXJnZXQgLSBUaGUgdGFyZ2V0IG9mIHRoZSBmaWx0ZXIgdG8gcmVuZGVyLlxuICAgICAqIEBwYXJhbSB7UElYSS5GaWx0ZXJbXX0gZmlsdGVycyAtIFRoZSBmaWx0ZXJzIHRvIGFwcGx5LlxuICAgICAqL1xuICAgIHB1c2godGFyZ2V0LCBmaWx0ZXJzKSB7XG4gICAgICAgIHZhciByZW5kZXJlciA9IHRoaXMucmVuZGVyZXI7XG4gICAgICAgIHZhciBmaWx0ZXJTdGFjayA9IHRoaXMuZGVmYXVsdEZpbHRlclN0YWNrO1xuICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLnN0YXRlUG9vbC5wb3AoKSB8fCBuZXcgRmlsdGVyU3RhdGVfMS5GaWx0ZXJTdGF0ZSgpO1xuICAgICAgICB2YXIgcmVzb2x1dGlvbiA9IGZpbHRlcnNbMF0ucmVzb2x1dGlvbjtcbiAgICAgICAgdmFyIHBhZGRpbmcgPSBmaWx0ZXJzWzBdLnBhZGRpbmc7XG4gICAgICAgIHZhciBhdXRvRml0ID0gZmlsdGVyc1swXS5hdXRvRml0O1xuICAgICAgICB2YXIgbGVnYWN5ID0gZmlsdGVyc1swXS5sZWdhY3k7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgZmlsdGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGZpbHRlciA9IGZpbHRlcnNbaV07XG4gICAgICAgICAgICAvLyBsZXRzIHVzZSB0aGUgbG93ZXN0IHJlc29sdXRpb24uLlxuICAgICAgICAgICAgcmVzb2x1dGlvbiA9IE1hdGgubWluKHJlc29sdXRpb24sIGZpbHRlci5yZXNvbHV0aW9uKTtcbiAgICAgICAgICAgIC8vIGFuZCB0aGUgbGFyZ2VzdCBhbW91bnQgb2YgcGFkZGluZyFcbiAgICAgICAgICAgIHBhZGRpbmcgPSBNYXRoLm1heChwYWRkaW5nLCBmaWx0ZXIucGFkZGluZyk7XG4gICAgICAgICAgICAvLyBvbmx5IGF1dG8gZml0IGlmIGFsbCBmaWx0ZXJzIGFyZSBhdXRvZml0XG4gICAgICAgICAgICBhdXRvRml0ID0gYXV0b0ZpdCB8fCBmaWx0ZXIuYXV0b0ZpdDtcbiAgICAgICAgICAgIGxlZ2FjeSA9IGxlZ2FjeSB8fCBmaWx0ZXIubGVnYWN5O1xuICAgICAgICB9XG4gICAgICAgIGlmIChmaWx0ZXJTdGFjay5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHRoaXMuZGVmYXVsdEZpbHRlclN0YWNrWzBdLnJlbmRlclRleHR1cmUgPSByZW5kZXJlci5yZW5kZXJUZXh0dXJlLmN1cnJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgZmlsdGVyU3RhY2sucHVzaChzdGF0ZSk7XG4gICAgICAgIHN0YXRlLnJlc29sdXRpb24gPSByZXNvbHV0aW9uO1xuICAgICAgICBzdGF0ZS5sZWdhY3kgPSBsZWdhY3k7XG4gICAgICAgIHN0YXRlLnRhcmdldCA9IHRhcmdldDtcbiAgICAgICAgc3RhdGUuc291cmNlRnJhbWUuY29weUZyb20odGFyZ2V0LmZpbHRlckFyZWEgfHwgdGFyZ2V0LmdldEJvdW5kcyh0cnVlKSk7XG4gICAgICAgIHN0YXRlLnNvdXJjZUZyYW1lLnBhZChwYWRkaW5nKTtcbiAgICAgICAgaWYgKGF1dG9GaXQpIHtcbiAgICAgICAgICAgIHN0YXRlLnNvdXJjZUZyYW1lLmZpdCh0aGlzLnJlbmRlcmVyLnJlbmRlclRleHR1cmUuc291cmNlRnJhbWUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJvdW5kIHRvIHdob2xlIG51bWJlciBiYXNlZCBvbiByZXNvbHV0aW9uXG4gICAgICAgIHN0YXRlLnNvdXJjZUZyYW1lLmNlaWwocmVzb2x1dGlvbik7XG4gICAgICAgIHN0YXRlLnJlbmRlclRleHR1cmUgPSB0aGlzLmdldE9wdGltYWxGaWx0ZXJUZXh0dXJlKHN0YXRlLnNvdXJjZUZyYW1lLndpZHRoLCBzdGF0ZS5zb3VyY2VGcmFtZS5oZWlnaHQsIHJlc29sdXRpb24pO1xuICAgICAgICBzdGF0ZS5maWx0ZXJzID0gZmlsdGVycztcbiAgICAgICAgc3RhdGUuZGVzdGluYXRpb25GcmFtZS53aWR0aCA9IHN0YXRlLnJlbmRlclRleHR1cmUud2lkdGg7XG4gICAgICAgIHN0YXRlLmRlc3RpbmF0aW9uRnJhbWUuaGVpZ2h0ID0gc3RhdGUucmVuZGVyVGV4dHVyZS5oZWlnaHQ7XG4gICAgICAgIHN0YXRlLnJlbmRlclRleHR1cmUuZmlsdGVyRnJhbWUgPSBzdGF0ZS5zb3VyY2VGcmFtZTtcbiAgICAgICAgcmVuZGVyZXIucmVuZGVyVGV4dHVyZS5iaW5kKHN0YXRlLnJlbmRlclRleHR1cmUsIHN0YXRlLnNvdXJjZUZyYW1lKTsgLy8gLywgc3RhdGUuZGVzdGluYXRpb25GcmFtZSk7XG4gICAgICAgIHJlbmRlcmVyLnJlbmRlclRleHR1cmUuY2xlYXIoKTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFBvcHMgb2ZmIHRoZSBmaWx0ZXIgYW5kIGFwcGxpZXMgaXQuXG4gICAgICpcbiAgICAgKi9cbiAgICBwb3AoKSB7XG4gICAgICAgIHZhciBmaWx0ZXJTdGFjayA9IHRoaXMuZGVmYXVsdEZpbHRlclN0YWNrO1xuICAgICAgICB2YXIgc3RhdGUgPSBmaWx0ZXJTdGFjay5wb3AoKTtcbiAgICAgICAgdmFyIGZpbHRlcnMgPSBzdGF0ZS5maWx0ZXJzO1xuICAgICAgICB0aGlzLmFjdGl2ZVN0YXRlID0gc3RhdGU7XG4gICAgICAgIHZhciBnbG9iYWxVbmlmb3JtcyA9IHRoaXMuZ2xvYmFsVW5pZm9ybXMudW5pZm9ybXM7XG4gICAgICAgIGdsb2JhbFVuaWZvcm1zLm91dHB1dEZyYW1lID0gc3RhdGUuc291cmNlRnJhbWU7XG4gICAgICAgIGdsb2JhbFVuaWZvcm1zLnJlc29sdXRpb24gPSBzdGF0ZS5yZXNvbHV0aW9uO1xuICAgICAgICB2YXIgaW5wdXRTaXplID0gZ2xvYmFsVW5pZm9ybXMuaW5wdXRTaXplO1xuICAgICAgICB2YXIgaW5wdXRQaXhlbCA9IGdsb2JhbFVuaWZvcm1zLmlucHV0UGl4ZWw7XG4gICAgICAgIHZhciBpbnB1dENsYW1wID0gZ2xvYmFsVW5pZm9ybXMuaW5wdXRDbGFtcDtcbiAgICAgICAgaW5wdXRTaXplWzBdID0gc3RhdGUuZGVzdGluYXRpb25GcmFtZS53aWR0aDtcbiAgICAgICAgaW5wdXRTaXplWzFdID0gc3RhdGUuZGVzdGluYXRpb25GcmFtZS5oZWlnaHQ7XG4gICAgICAgIGlucHV0U2l6ZVsyXSA9IDEuMCAvIGlucHV0U2l6ZVswXTtcbiAgICAgICAgaW5wdXRTaXplWzNdID0gMS4wIC8gaW5wdXRTaXplWzFdO1xuICAgICAgICBpbnB1dFBpeGVsWzBdID0gaW5wdXRTaXplWzBdICogc3RhdGUucmVzb2x1dGlvbjtcbiAgICAgICAgaW5wdXRQaXhlbFsxXSA9IGlucHV0U2l6ZVsxXSAqIHN0YXRlLnJlc29sdXRpb247XG4gICAgICAgIGlucHV0UGl4ZWxbMl0gPSAxLjAgLyBpbnB1dFBpeGVsWzBdO1xuICAgICAgICBpbnB1dFBpeGVsWzNdID0gMS4wIC8gaW5wdXRQaXhlbFsxXTtcbiAgICAgICAgaW5wdXRDbGFtcFswXSA9IDAuNSAqIGlucHV0UGl4ZWxbMl07XG4gICAgICAgIGlucHV0Q2xhbXBbMV0gPSAwLjUgKiBpbnB1dFBpeGVsWzNdO1xuICAgICAgICBpbnB1dENsYW1wWzJdID0gKHN0YXRlLnNvdXJjZUZyYW1lLndpZHRoICogaW5wdXRTaXplWzJdKSAtICgwLjUgKiBpbnB1dFBpeGVsWzJdKTtcbiAgICAgICAgaW5wdXRDbGFtcFszXSA9IChzdGF0ZS5zb3VyY2VGcmFtZS5oZWlnaHQgKiBpbnB1dFNpemVbM10pIC0gKDAuNSAqIGlucHV0UGl4ZWxbM10pO1xuICAgICAgICAvLyBvbmx5IHVwZGF0ZSB0aGUgcmVjdCBpZiBpdHMgbGVnYWN5Li5cbiAgICAgICAgaWYgKHN0YXRlLmxlZ2FjeSkge1xuICAgICAgICAgICAgdmFyIGZpbHRlckFyZWEgPSBnbG9iYWxVbmlmb3Jtcy5maWx0ZXJBcmVhO1xuICAgICAgICAgICAgZmlsdGVyQXJlYVswXSA9IHN0YXRlLmRlc3RpbmF0aW9uRnJhbWUud2lkdGg7XG4gICAgICAgICAgICBmaWx0ZXJBcmVhWzFdID0gc3RhdGUuZGVzdGluYXRpb25GcmFtZS5oZWlnaHQ7XG4gICAgICAgICAgICBmaWx0ZXJBcmVhWzJdID0gc3RhdGUuc291cmNlRnJhbWUueDtcbiAgICAgICAgICAgIGZpbHRlckFyZWFbM10gPSBzdGF0ZS5zb3VyY2VGcmFtZS55O1xuICAgICAgICAgICAgZ2xvYmFsVW5pZm9ybXMuZmlsdGVyQ2xhbXAgPSBnbG9iYWxVbmlmb3Jtcy5pbnB1dENsYW1wO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZ2xvYmFsVW5pZm9ybXMudXBkYXRlKCk7XG4gICAgICAgIHZhciBsYXN0U3RhdGUgPSBmaWx0ZXJTdGFja1tmaWx0ZXJTdGFjay5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKGZpbHRlcnMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICBmaWx0ZXJzWzBdLmFwcGx5KHRoaXMsIHN0YXRlLnJlbmRlclRleHR1cmUsIGxhc3RTdGF0ZS5yZW5kZXJUZXh0dXJlLCBmYWxzZSwgc3RhdGUpO1xuICAgICAgICAgICAgdGhpcy5yZXR1cm5GaWx0ZXJUZXh0dXJlKHN0YXRlLnJlbmRlclRleHR1cmUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGZsaXAgPSBzdGF0ZS5yZW5kZXJUZXh0dXJlO1xuICAgICAgICAgICAgdmFyIGZsb3AgPSB0aGlzLmdldE9wdGltYWxGaWx0ZXJUZXh0dXJlKGZsaXAud2lkdGgsIGZsaXAuaGVpZ2h0LCBzdGF0ZS5yZXNvbHV0aW9uKTtcbiAgICAgICAgICAgIGZsb3AuZmlsdGVyRnJhbWUgPSBmbGlwLmZpbHRlckZyYW1lO1xuICAgICAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGZpbHRlcnMubGVuZ3RoIC0gMTsgKytpKSB7XG4gICAgICAgICAgICAgICAgZmlsdGVyc1tpXS5hcHBseSh0aGlzLCBmbGlwLCBmbG9wLCB0cnVlLCBzdGF0ZSk7XG4gICAgICAgICAgICAgICAgdmFyIHQgPSBmbGlwO1xuICAgICAgICAgICAgICAgIGZsaXAgPSBmbG9wO1xuICAgICAgICAgICAgICAgIGZsb3AgPSB0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmlsdGVyc1tpXS5hcHBseSh0aGlzLCBmbGlwLCBsYXN0U3RhdGUucmVuZGVyVGV4dHVyZSwgZmFsc2UsIHN0YXRlKTtcbiAgICAgICAgICAgIHRoaXMucmV0dXJuRmlsdGVyVGV4dHVyZShmbGlwKTtcbiAgICAgICAgICAgIHRoaXMucmV0dXJuRmlsdGVyVGV4dHVyZShmbG9wKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5jbGVhcigpO1xuICAgICAgICB0aGlzLnN0YXRlUG9vbC5wdXNoKHN0YXRlKTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIERyYXdzIGEgZmlsdGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQSVhJLkZpbHRlcn0gZmlsdGVyIC0gVGhlIGZpbHRlciB0byBkcmF3LlxuICAgICAqIEBwYXJhbSB7UElYSS5SZW5kZXJUZXh0dXJlfSBpbnB1dCAtIFRoZSBpbnB1dCByZW5kZXIgdGFyZ2V0LlxuICAgICAqIEBwYXJhbSB7UElYSS5SZW5kZXJUZXh0dXJlfSBvdXRwdXQgLSBUaGUgdGFyZ2V0IHRvIG91dHB1dCB0by5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGNsZWFyIC0gU2hvdWxkIHRoZSBvdXRwdXQgYmUgY2xlYXJlZCBiZWZvcmUgcmVuZGVyaW5nIHRvIGl0XG4gICAgICovXG4gICAgYXBwbHlGaWx0ZXIoZmlsdGVyLCBpbnB1dCwgb3V0cHV0LCBjbGVhcikge1xuICAgICAgICB2YXIgcmVuZGVyZXIgPSB0aGlzLnJlbmRlcmVyO1xuICAgICAgICByZW5kZXJlci5yZW5kZXJUZXh0dXJlLmJpbmQob3V0cHV0LCBvdXRwdXQgPyBvdXRwdXQuZmlsdGVyRnJhbWUgOiBudWxsKTtcbiAgICAgICAgaWYgKGNsZWFyKSB7XG4gICAgICAgICAgICAvLyBnbC5kaXNhYmxlKGdsLlNDSVNTT1JfVEVTVCk7XG4gICAgICAgICAgICByZW5kZXJlci5yZW5kZXJUZXh0dXJlLmNsZWFyKCk7XG4gICAgICAgICAgICAvLyBnbC5lbmFibGUoZ2wuU0NJU1NPUl9URVNUKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBzZXQgdGhlIHVuaWZvcm1zLi5cbiAgICAgICAgZmlsdGVyLnVuaWZvcm1zLnVTYW1wbGVyID0gaW5wdXQ7XG4gICAgICAgIGZpbHRlci51bmlmb3Jtcy5maWx0ZXJHbG9iYWxzID0gdGhpcy5nbG9iYWxVbmlmb3JtcztcbiAgICAgICAgLy8gVE9ETyBtYWtlIGl0IHNvIHRoYXQgdGhlIG9yZGVyIG9mIHRoaXMgZG9lcyBub3QgbWF0dGVyLi5cbiAgICAgICAgLy8gYmVjYXVzZSBpdCBkb2VzIGF0IHRoZSBtb21lbnQgY29zIG9mIGdsb2JhbCB1bmlmb3Jtcy5cbiAgICAgICAgLy8gdGhleSBuZWVkIHRvIGdldCByZXN5bmNlZFxuICAgICAgICByZW5kZXJlci5zdGF0ZS5zZXRTdGF0ZShmaWx0ZXIuc3RhdGUpO1xuICAgICAgICByZW5kZXJlci5zaGFkZXIuYmluZChmaWx0ZXIpO1xuICAgICAgICBpZiAoZmlsdGVyLmxlZ2FjeSkge1xuICAgICAgICAgICAgdGhpcy5xdWFkVXYubWFwKGlucHV0Ll9mcmFtZSwgaW5wdXQuZmlsdGVyRnJhbWUpO1xuICAgICAgICAgICAgcmVuZGVyZXIuZ2VvbWV0cnkuYmluZCh0aGlzLnF1YWRVdik7XG4gICAgICAgICAgICByZW5kZXJlci5nZW9tZXRyeS5kcmF3KERyYXdNb2RlU2V0dGluZ3NfMS5EcmF3TW9kZVNldHRpbmdzLkRSQVdfTU9ERVMuVFJJQU5HTEVTKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlbmRlcmVyLmdlb21ldHJ5LmJpbmQodGhpcy5xdWFkKTtcbiAgICAgICAgICAgIHJlbmRlcmVyLmdlb21ldHJ5LmRyYXcoRHJhd01vZGVTZXR0aW5nc18xLkRyYXdNb2RlU2V0dGluZ3MuRFJBV19NT0RFUy5UUklBTkdMRV9TVFJJUCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgdGhlIG1hcHBlZCBtYXRyaXguXG4gICAgICpcbiAgICAgKiBUT0RPIHBsYXlpbmcgYXJvdW5kIGhlcmUuLiB0aGlzIGlzIHRlbXBvcmFyeSAtICh3aWxsIGVuZCB1cCBpbiB0aGUgc2hhZGVyKVxuICAgICAqIHRoaXMgcmV0dXJucyBhIG1hdHJpeCB0aGF0IHdpbGwgbm9ybWFsaXplIG1hcCBmaWx0ZXIgY29yZHMgaW4gdGhlIGZpbHRlciB0byBzY3JlZW4gc3BhY2VcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UElYSS5NYXRyaXh9IG91dHB1dE1hdHJpeCAtIHRoZSBtYXRyaXggdG8gb3V0cHV0IHRvLlxuICAgICAqIEByZXR1cm4ge1BJWEkuTWF0cml4fSBUaGUgbWFwcGVkIG1hdHJpeC5cbiAgICAgKi9cbiAgICBjYWxjdWxhdGVTY3JlZW5TcGFjZU1hdHJpeChvdXRwdXRNYXRyaXgpIHtcbiAgICAgICAgdmFyIGN1cnJlbnRTdGF0ZSA9IHRoaXMuYWN0aXZlU3RhdGU7XG4gICAgICAgIHJldHVybiBGaWx0ZXJTeXN0ZW0uY2FsY3VsYXRlU2NyZWVuU3BhY2VNYXRyaXgob3V0cHV0TWF0cml4LCBjdXJyZW50U3RhdGUuc291cmNlRnJhbWUsIGN1cnJlbnRTdGF0ZS5kZXN0aW5hdGlvbkZyYW1lKTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFRoaXMgd2lsbCBtYXAgdGhlIGZpbHRlciBjb29yZCBzbyB0aGF0IGEgdGV4dHVyZSBjYW4gYmUgdXNlZCBiYXNlZCBvbiB0aGUgdHJhbnNmb3JtIG9mIGEgc3ByaXRlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BJWEkuTWF0cml4fSBvdXRwdXRNYXRyaXggLSBUaGUgbWF0cml4IHRvIG91dHB1dCB0by5cbiAgICAgKiBAcGFyYW0ge1BJWEkuU3ByaXRlfSBzcHJpdGUgLSBUaGUgc3ByaXRlIHRvIG1hcCB0by5cbiAgICAgKiBAcmV0dXJuIHtQSVhJLk1hdHJpeH0gVGhlIG1hcHBlZCBtYXRyaXguXG4gICAgICovXG4gICAgY2FsY3VsYXRlU3ByaXRlTWF0cml4KG91dHB1dE1hdHJpeCwgc3ByaXRlKSB7XG4gICAgICAgIHZhciBjdXJyZW50U3RhdGUgPSB0aGlzLmFjdGl2ZVN0YXRlO1xuICAgICAgICByZXR1cm4gRmlsdGVyU3lzdGVtLmNhbGN1bGF0ZVNwcml0ZU1hdHJpeChvdXRwdXRNYXRyaXgsIGN1cnJlbnRTdGF0ZS5zb3VyY2VGcmFtZSwgY3VycmVudFN0YXRlLmRlc3RpbmF0aW9uRnJhbWUsIHNwcml0ZSk7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBEZXN0cm95cyB0aGlzIEZpbHRlciBTeXN0ZW0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtjb250ZXh0TG9zdD1mYWxzZV0gY29udGV4dCB3YXMgbG9zdCwgZG8gbm90IGZyZWUgc2hhZGVyc1xuICAgICAqXG4gICAgICovXG4gICAgZGVzdHJveShjb250ZXh0TG9zdCkge1xuICAgICAgICBpZiAoY29udGV4dExvc3QgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgY29udGV4dExvc3QgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNvbnRleHRMb3N0KSB7XG4gICAgICAgICAgICB0aGlzLmVtcHR5UG9vbCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy50ZXh0dXJlUG9vbCA9IHt9O1xuICAgICAgICB9XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBHZXRzIGEgUG93ZXItb2YtVHdvIHJlbmRlciB0ZXh0dXJlIG9yIGZ1bGxTY3JlZW4gdGV4dHVyZVxuICAgICAqXG4gICAgICogVE9ETyBtb3ZlIHRvIGEgc2VwYXJhdGUgY2xhc3MgY291bGQgYmUgb24gcmVuZGVyZXI/XG4gICAgICpcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1pbldpZHRoIC0gVGhlIG1pbmltdW0gd2lkdGggb2YgdGhlIHJlbmRlciB0ZXh0dXJlIGluIHJlYWwgcGl4ZWxzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtaW5IZWlnaHQgLSBUaGUgbWluaW11bSBoZWlnaHQgb2YgdGhlIHJlbmRlciB0ZXh0dXJlIGluIHJlYWwgcGl4ZWxzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcmVzb2x1dGlvbj0xXSAtIFRoZSByZXNvbHV0aW9uIG9mIHRoZSByZW5kZXIgdGV4dHVyZS5cbiAgICAgKiBAcmV0dXJuIHtQSVhJLlJlbmRlclRleHR1cmV9IFRoZSBuZXcgcmVuZGVyIHRleHR1cmUuXG4gICAgICovXG4gICAgZ2V0T3B0aW1hbEZpbHRlclRleHR1cmUobWluV2lkdGgsIG1pbkhlaWdodCwgcmVzb2x1dGlvbikge1xuICAgICAgICBpZiAocmVzb2x1dGlvbiA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICByZXNvbHV0aW9uID0gMTtcbiAgICAgICAgfVxuICAgICAgICB2YXIga2V5ID0gRmlsdGVyU3lzdGVtLnNjcmVlbktleTtcbiAgICAgICAgbWluV2lkdGggKj0gcmVzb2x1dGlvbjtcbiAgICAgICAgbWluSGVpZ2h0ICo9IHJlc29sdXRpb247XG4gICAgICAgIGlmIChtaW5XaWR0aCAhPT0gdGhpcy5fcGl4ZWxzV2lkdGggfHwgbWluSGVpZ2h0ICE9PSB0aGlzLl9waXhlbHNIZWlnaHQpIHtcbiAgICAgICAgICAgIG1pbldpZHRoID0gTWF0aFNldHRpbmdzXzEuTWF0aFNldHRpbmdzLm5leHRQb3cyKG1pbldpZHRoKTtcbiAgICAgICAgICAgIG1pbkhlaWdodCA9IE1hdGhTZXR0aW5nc18xLk1hdGhTZXR0aW5ncy5uZXh0UG93MihtaW5IZWlnaHQpO1xuICAgICAgICAgICAga2V5ID0gKChtaW5XaWR0aCAmIDB4RkZGRikgPDwgMTYpIHwgKG1pbkhlaWdodCAmIDB4RkZGRik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLnRleHR1cmVQb29sW2tleV0pIHtcbiAgICAgICAgICAgIHRoaXMudGV4dHVyZVBvb2xba2V5XSA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZW5kZXJUZXh0dXJlID0gdGhpcy50ZXh0dXJlUG9vbFtrZXldLnBvcCgpO1xuICAgICAgICBpZiAoIXJlbmRlclRleHR1cmUpIHtcbiAgICAgICAgICAgIC8vIHRlbXBvcmFyeSBieXBhc3MgY2FjaGUuLlxuICAgICAgICAgICAgLy8gaW50ZXJuYWxseSAtIHRoaXMgd2lsbCBjYXVzZSBhIHRleHR1cmUgdG8gYmUgYm91bmQuLlxuICAgICAgICAgICAgcmVuZGVyVGV4dHVyZSA9IFJlbmRlclRleHR1cmVfMS5SZW5kZXJUZXh0dXJlLmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgd2lkdGg6IG1pbldpZHRoIC8gcmVzb2x1dGlvbixcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IG1pbkhlaWdodCAvIHJlc29sdXRpb24sXG4gICAgICAgICAgICAgICAgcmVzb2x1dGlvbjogcmVzb2x1dGlvbixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJlbmRlclRleHR1cmUuZmlsdGVyUG9vbEtleSA9IGtleTtcbiAgICAgICAgcmV0dXJuIHJlbmRlclRleHR1cmU7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBHZXRzIGV4dHJhIHJlbmRlciB0ZXh0dXJlIHRvIHVzZSBpbnNpZGUgY3VycmVudCBmaWx0ZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByZXNvbHV0aW9uIHJlc29sdXRpb24gb2YgdGhlIHJlbmRlclRleHR1cmVcbiAgICAgKiBAcmV0dXJucyB7UElYSS5SZW5kZXJUZXh0dXJlfVxuICAgICAqL1xuICAgIGdldEZpbHRlclRleHR1cmUocmVzb2x1dGlvbikge1xuICAgICAgICB2YXIgcnQgPSB0aGlzLmFjdGl2ZVN0YXRlLnJlbmRlclRleHR1cmU7XG4gICAgICAgIHZhciBmaWx0ZXJUZXh0dXJlID0gdGhpcy5nZXRPcHRpbWFsRmlsdGVyVGV4dHVyZShydC53aWR0aCwgcnQuaGVpZ2h0LCByZXNvbHV0aW9uIHx8IHJ0LmJhc2VUZXh0dXJlLnJlc29sdXRpb24pO1xuICAgICAgICBmaWx0ZXJUZXh0dXJlLmZpbHRlckZyYW1lID0gcnQuZmlsdGVyRnJhbWU7XG4gICAgICAgIHJldHVybiBmaWx0ZXJUZXh0dXJlO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogRnJlZXMgYSByZW5kZXIgdGV4dHVyZSBiYWNrIGludG8gdGhlIHBvb2wuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BJWEkuUmVuZGVyVGV4dHVyZX0gcmVuZGVyVGV4dHVyZSAtIFRoZSByZW5kZXJUYXJnZXQgdG8gZnJlZVxuICAgICAqL1xuICAgIHJldHVybkZpbHRlclRleHR1cmUocmVuZGVyVGV4dHVyZSkge1xuICAgICAgICB2YXIga2V5ID0gcmVuZGVyVGV4dHVyZS5maWx0ZXJQb29sS2V5O1xuICAgICAgICByZW5kZXJUZXh0dXJlLmZpbHRlckZyYW1lID0gbnVsbDtcbiAgICAgICAgdGhpcy50ZXh0dXJlUG9vbFtrZXldLnB1c2gocmVuZGVyVGV4dHVyZSk7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBFbXB0aWVzIHRoZSB0ZXh0dXJlIHBvb2wuXG4gICAgICpcbiAgICAgKi9cbiAgICBlbXB0eVBvb2woKSB7XG4gICAgICAgIGZvciAodmFyIGkgaW4gdGhpcy50ZXh0dXJlUG9vbCkge1xuICAgICAgICAgICAgdmFyIHRleHR1cmVzID0gdGhpcy50ZXh0dXJlUG9vbFtpXTtcbiAgICAgICAgICAgIGlmICh0ZXh0dXJlcykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGV4dHVyZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dHVyZXNbal0uZGVzdHJveSh0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50ZXh0dXJlUG9vbCA9IHt9O1xuICAgIH1cbiAgICA7XG4gICAgcmVzaXplKCkge1xuICAgICAgICB2YXIgdGV4dHVyZXMgPSB0aGlzLnRleHR1cmVQb29sW0ZpbHRlclN5c3RlbS5zY3JlZW5LZXldO1xuICAgICAgICBpZiAodGV4dHVyZXMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGV4dHVyZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICB0ZXh0dXJlc1tqXS5kZXN0cm95KHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMudGV4dHVyZVBvb2xbRmlsdGVyU3lzdGVtLnNjcmVlbktleV0gPSBbXTtcbiAgICAgICAgdGhpcy5fcGl4ZWxzV2lkdGggPSB0aGlzLnJlbmRlcmVyLnZpZXcud2lkdGg7XG4gICAgICAgIHRoaXMuX3BpeGVsc0hlaWdodCA9IHRoaXMucmVuZGVyZXIudmlldy5oZWlnaHQ7XG4gICAgfVxuICAgIDtcbiAgICAvLyB0aGlzIHdpbGwgbWFwIHRoZSBmaWx0ZXIgY29vcmQgc28gdGhhdCBhIHRleHR1cmUgY2FuIGJlIHVzZWQgYmFzZWQgb24gdGhlIHRyYW5zZm9ybSBvZiBhIHNwcml0ZVxuICAgIHN0YXRpYyBjYWxjdWxhdGVTcHJpdGVNYXRyaXgob3V0cHV0TWF0cml4LCBmaWx0ZXJBcmVhLCB0ZXh0dXJlU2l6ZSwgc3ByaXRlKSB7XG4gICAgICAgIHZhciBvcmlnID0gc3ByaXRlLl90ZXh0dXJlLm9yaWc7XG4gICAgICAgIHZhciBtYXBwZWRNYXRyaXggPSBvdXRwdXRNYXRyaXguc2V0KHRleHR1cmVTaXplLndpZHRoLCAwLCAwLCB0ZXh0dXJlU2l6ZS5oZWlnaHQsIGZpbHRlckFyZWEueCwgZmlsdGVyQXJlYS55KTtcbiAgICAgICAgdmFyIHdvcmxkVHJhbnNmb3JtID0gc3ByaXRlLndvcmxkVHJhbnNmb3JtLmNvcHlUbyhNYXRyaXhfMS5NYXRyaXguVEVNUF9NQVRSSVgpO1xuICAgICAgICB3b3JsZFRyYW5zZm9ybS5pbnZlcnQoKTtcbiAgICAgICAgbWFwcGVkTWF0cml4LnByZXBlbmQod29ybGRUcmFuc2Zvcm0pO1xuICAgICAgICBtYXBwZWRNYXRyaXguc2NhbGUoMS4wIC8gb3JpZy53aWR0aCwgMS4wIC8gb3JpZy5oZWlnaHQpO1xuICAgICAgICBtYXBwZWRNYXRyaXgudHJhbnNsYXRlKHNwcml0ZS5hbmNob3IueCwgc3ByaXRlLmFuY2hvci55KTtcbiAgICAgICAgcmV0dXJuIG1hcHBlZE1hdHJpeDtcbiAgICB9XG4gICAgLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBtYXBwZWQgbWF0cml4XG4gKiBAcGFyYW0ge1BJWEkuTWF0cml4fSBvdXRwdXRNYXRyaXggbWF0cml4IHRoYXQgd2lsbCBub3JtYWxpemUgbWFwIGZpbHRlciBjb3JkcyBpbiB0aGUgZmlsdGVyIHRvIHNjcmVlbiBzcGFjZVxuICogQHBhcmFtIHtQSVhJLlJlY3RhbmdsZX0gZmlsdGVyQXJlYSBmaWx0ZXIgYXJlYVxuICogQHBhcmFtIHtQSVhJLlJlY3RhbmdsZX0gdGV4dHVyZVNpemUgdGV4dHVyZSBzaXplXG4gKiBAcmV0dXJucyB7UElYSS5NYXRyaXh9IHNhbWUgYXMgb3V0cHV0TWF0cml4XG4gKiBAcHJpdmF0ZVxuICovXG4gICAgc3RhdGljIGNhbGN1bGF0ZVNjcmVlblNwYWNlTWF0cml4KG91dHB1dE1hdHJpeCwgZmlsdGVyQXJlYSwgdGV4dHVyZVNpemUpIHtcbiAgICAgICAgLy8gVE9ETyB1bndyYXA/XG4gICAgICAgIHZhciBtYXBwZWRNYXRyaXggPSBvdXRwdXRNYXRyaXguaWRlbnRpdHkoKTtcbiAgICAgICAgbWFwcGVkTWF0cml4LnRyYW5zbGF0ZShmaWx0ZXJBcmVhLnggLyB0ZXh0dXJlU2l6ZS53aWR0aCwgZmlsdGVyQXJlYS55IC8gdGV4dHVyZVNpemUuaGVpZ2h0KTtcbiAgICAgICAgbWFwcGVkTWF0cml4LnNjYWxlKHRleHR1cmVTaXplLndpZHRoLCB0ZXh0dXJlU2l6ZS5oZWlnaHQpO1xuICAgICAgICByZXR1cm4gbWFwcGVkTWF0cml4O1xuICAgIH1cbn1cbkZpbHRlclN5c3RlbS5zY3JlZW5LZXkgPSAnc2NyZWVuJztcbmV4cG9ydHMuRmlsdGVyU3lzdGVtID0gRmlsdGVyU3lzdGVtO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jbGFzcyBGbGFzaEJhc2VPYmplY3Qge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBGbGFzaEJhc2VPYmplY3QubmFtZUNvdW50Kys7XG4gICAgICAgIHRoaXMuX25hbWUgPSBcImluc3RhbmNlLVwiICsgdGhpcy5jbGFzc05hbWUgKyBcIi1cIiArIEZsYXNoQmFzZU9iamVjdC5uYW1lQ291bnQ7XG4gICAgICAgIHRoaXMuX2luc3RhbmNlTmFtZSA9IFwiaW5zdGFuY2UtXCIgKyB0aGlzLmNsYXNzTmFtZSArIFwiLVwiICsgRmxhc2hCYXNlT2JqZWN0Lm5hbWVDb3VudDtcbiAgICAgICAgdGhpcy5faGFzQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuX2NsYXNzTmFtZSA9IHRoaXMuY29uc3RydWN0b3JbJ25hbWUnXTtcbiAgICB9XG4gICAgZ2V0IGNsYXNzTmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3JbJ25hbWUnXTtcbiAgICB9XG4gICAgZGVzdHJ1Y3RvcigpIHtcbiAgICB9XG4gICAgcmVjeWNsZSgpIHtcbiAgICB9XG4gICAgZGlzcG9zZSgpIHtcbiAgICB9XG4gICAgZ2V0IGhhc0NoYW5nZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9oYXNDaGFuZ2VkO1xuICAgIH1cbiAgICBzZXQgaGFzQ2hhbmdlZCh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9oYXNDaGFuZ2VkID0gdmFsdWU7XG4gICAgfVxuICAgIGdldCBuYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbmFtZTtcbiAgICB9XG4gICAgc2V0IG5hbWUodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fbmFtZSA9IHZhbHVlO1xuICAgIH1cbiAgICBnZXQgaW5zdGFuY2VOYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW5zdGFuY2VOYW1lO1xuICAgIH1cbn1cbkZsYXNoQmFzZU9iamVjdC5uYW1lQ291bnQgPSAwO1xuZXhwb3J0cy5GbGFzaEJhc2VPYmplY3QgPSBGbGFzaEJhc2VPYmplY3Q7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IFRleHR1cmVfMSA9IHJlcXVpcmUoXCIuL1RleHR1cmVcIik7XG5jb25zdCBVUkxSZXF1ZXN0XzEgPSByZXF1aXJlKFwiLi9VUkxSZXF1ZXN0XCIpO1xuY29uc3QgVVJMTG9hZGVyXzEgPSByZXF1aXJlKFwiLi9VUkxMb2FkZXJcIik7XG5jb25zdCBFdmVudF8xID0gcmVxdWlyZShcIi4vRXZlbnRcIik7XG5jb25zdCBJT0Vycm9yRXZlbnRfMSA9IHJlcXVpcmUoXCIuL0lPRXJyb3JFdmVudFwiKTtcbmNvbnN0IEV2ZW50RGlzcGF0Y2hlcl8xID0gcmVxdWlyZShcIi4vRXZlbnREaXNwYXRjaGVyXCIpO1xuY29uc3QgVVJMUmVxdWVzdE1ldGhvZF8xID0gcmVxdWlyZShcIi4vVVJMUmVxdWVzdE1ldGhvZFwiKTtcbmNvbnN0IFhNTFBhcnNlcl8xID0gcmVxdWlyZShcIi4vWE1MUGFyc2VyXCIpO1xuY29uc3QgTmV0d29ya1NldHRpbmdzXzEgPSByZXF1aXJlKFwiLi9OZXR3b3JrU2V0dGluZ3NcIik7XG5jb25zdCBEaXNwbGF5U2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL0Rpc3BsYXlTZXR0aW5nc1wiKTtcbmNvbnN0IFJlY3RhbmdsZV8xID0gcmVxdWlyZShcIi4uL2ZsYXNoL2dlb20vUmVjdGFuZ2xlXCIpO1xuY29uc3QgQmFzZVRleHR1cmVfMSA9IHJlcXVpcmUoXCIuL0Jhc2VUZXh0dXJlXCIpO1xuY29uc3QgUmVzb3VyY2VMb2FkZXJfMSA9IHJlcXVpcmUoXCIuL1Jlc291cmNlTG9hZGVyXCIpO1xuY29uc3QgSW5zdGFuY2VDb3VudGVyXzEgPSByZXF1aXJlKFwiLi9JbnN0YW5jZUNvdW50ZXJcIik7XG5jbGFzcyBGb250TWFuYWdlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgfVxuICAgIHN0YXRpYyBzZXQgV2ViRm9udENvbmZpZyh2YWx1ZSkge1xuICAgICAgICBsZXQgY29uZmlnID0ge1xuICAgICAgICAgICAgYWN0aXZlKCkge1xuICAgICAgICAgICAgICAgIEZvbnRNYW5hZ2VyLndlYkZvbnRBY3RpdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgZm9yIChsZXQga2V5IGluIHZhbHVlKSB7XG4gICAgICAgICAgICBjb25maWdba2V5XSA9IHZhbHVlW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgd2luZG93WydXZWJGb250Q29uZmlnJ10gPSBjb25maWc7XG4gICAgICAgIEZvbnRNYW5hZ2VyLmxvYWRXZWJGb250KCk7XG4gICAgfVxuICAgIHN0YXRpYyBnZXRCaXRtYXBGb250KG5hbWUpIHtcbiAgICAgICAgaWYgKEZvbnRNYW5hZ2VyLmJpdG1hcGZvbnRzW25hbWVdICE9IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIEZvbnRNYW5hZ2VyLmJpdG1hcGZvbnRzW25hbWVdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBzdGF0aWMgYWRkQml0bWFwRm9udChkYXRhKSB7XG4gICAgICAgIEZvbnRNYW5hZ2VyLmJpdG1hcGZvbnRzW2RhdGEuZm9udF0gPSBkYXRhO1xuICAgIH1cbiAgICBzdGF0aWMgbG9hZEJpdG1hcEZvbnQocGF0aCkge1xuICAgICAgICBsZXQgbG9hZGVyID0gbmV3IEJpdG1hcEZvbnRMb2FkZXIoKTtcbiAgICAgICAgRm9udE1hbmFnZXIuZm9udExvYWRlcnNbbG9hZGVyLmluc3RhbmNlTmFtZV0gPSBsb2FkZXI7XG4gICAgICAgIGxvYWRlci5sb2FkRm9udChwYXRoKTtcbiAgICAgICAgcmV0dXJuIGxvYWRlcjtcbiAgICB9XG4gICAgc3RhdGljIHBhcnNlQml0bWFwRm9udERhdGEoeG1sLCBiYXNlKSB7XG4gICAgICAgIGxldCBwYWdlaWQ7XG4gICAgICAgIGxldCBwYWdlcGF0aDtcbiAgICAgICAgbGV0IGRhdGEgPSBuZXcgQml0bWFwRm9udCgpO1xuICAgICAgICBkYXRhLnRleHR1cmUgPSBiYXNlO1xuICAgICAgICBsZXQgaW5mbyA9IHhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaW5mbycpWzBdO1xuICAgICAgICBsZXQgY29tbW9uID0geG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdjb21tb24nKVswXTtcbiAgICAgICAgbGV0IHBhZ2VzID0geG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdwYWdlJylbMF07XG4gICAgICAgIGxldCByZXMgPSBOZXR3b3JrU2V0dGluZ3NfMS5OZXR3b3JrU2V0dGluZ3MuZ2V0UmVzb2x1dGlvbk9mVXJsKHBhZ2VzLmdldEF0dHJpYnV0ZSgnZmlsZScpLCBEaXNwbGF5U2V0dGluZ3NfMS5EaXNwbGF5U2V0dGluZ3MuUkVTT0xVVElPTik7XG4gICAgICAgIGRhdGEuZm9udCA9IGluZm8uZ2V0QXR0cmlidXRlKCdmYWNlJyk7XG4gICAgICAgIGRhdGEuc2l6ZSA9IHBhcnNlSW50KGluZm8uZ2V0QXR0cmlidXRlKCdzaXplJyksIDEwKTtcbiAgICAgICAgZGF0YS5saW5lSGVpZ2h0ID0gcGFyc2VJbnQoY29tbW9uLmdldEF0dHJpYnV0ZSgnbGluZUhlaWdodCcpLCAxMCkgLyByZXM7XG4gICAgICAgIGRhdGEuY2hhcnMgPSB7fTtcbiAgICAgICAgcGFnZWlkID0gcGFnZXMuZ2V0QXR0cmlidXRlKCdpZCcpO1xuICAgICAgICBwYWdlcGF0aCA9IHBhZ2VzLmdldEF0dHJpYnV0ZSgnZmlsZScpO1xuICAgICAgICBkYXRhLnRleHR1cmVQYXRoID0gcGFnZXBhdGg7XG4gICAgICAgIGxldCBsZXR0ZXJzID0gQXJyYXkuZnJvbSh4bWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2NoYXInKSk7XG4gICAgICAgIGZvciAobGV0IGkkMSA9IDA7IGkkMSA8IGxldHRlcnMubGVuZ3RoOyBpJDErKykge1xuICAgICAgICAgICAgbGV0IGxldHRlciA9IGxldHRlcnNbaSQxXTtcbiAgICAgICAgICAgIGxldCBjaGFyQ29kZSA9IHBhcnNlSW50KGxldHRlci5nZXRBdHRyaWJ1dGUoJ2lkJyksIDEwKTtcbiAgICAgICAgICAgIGxldCBwYWdlID0gcGFyc2VJbnQobGV0dGVyLmdldEF0dHJpYnV0ZSgncGFnZScpKSB8fCAwO1xuICAgICAgICAgICAgSW5zdGFuY2VDb3VudGVyXzEuSW5zdGFuY2VDb3VudGVyLmFkZENhbGwoXCJSZWN0YW5nbGUuZ2V0UmVjdGFuZ2xlXCIsIFwiRm9udE1hbmFnZXIgcGFyc2VCaXRtYXBGb250RGF0YVwiKTtcbiAgICAgICAgICAgIGxldCB0ZXh0dXJlUmVjdCA9IFJlY3RhbmdsZV8xLlJlY3RhbmdsZS5nZXRSZWN0YW5nbGUoKHBhcnNlSW50KGxldHRlci5nZXRBdHRyaWJ1dGUoJ3gnKSwgMTApIC8gcmVzKSArIChiYXNlLmZyYW1lLnggLyByZXMpLCAocGFyc2VJbnQobGV0dGVyLmdldEF0dHJpYnV0ZSgneScpLCAxMCkgLyByZXMpICsgKGJhc2UuZnJhbWUueSAvIHJlcyksIHBhcnNlSW50KGxldHRlci5nZXRBdHRyaWJ1dGUoJ3dpZHRoJyksIDEwKSAvIHJlcywgcGFyc2VJbnQobGV0dGVyLmdldEF0dHJpYnV0ZSgnaGVpZ2h0JyksIDEwKSAvIHJlcyk7XG4gICAgICAgICAgICBsZXQgZm9udGNoYXIgPSBuZXcgRm9udENoYXJhY3RlckRhdGEoKTtcbiAgICAgICAgICAgIGZvbnRjaGFyLnhPZmZzZXQgPSBwYXJzZUludChsZXR0ZXIuZ2V0QXR0cmlidXRlKCd4b2Zmc2V0JyksIDEwKSAvIHJlcztcbiAgICAgICAgICAgIGZvbnRjaGFyLnlPZmZzZXQgPSBwYXJzZUludChsZXR0ZXIuZ2V0QXR0cmlidXRlKCd5b2Zmc2V0JyksIDEwKSAvIHJlcztcbiAgICAgICAgICAgIGZvbnRjaGFyLnhBZHZhbmNlID0gcGFyc2VJbnQobGV0dGVyLmdldEF0dHJpYnV0ZSgneGFkdmFuY2UnKSwgMTApIC8gcmVzO1xuICAgICAgICAgICAgZm9udGNoYXIua2VybmluZyA9IHt9O1xuICAgICAgICAgICAgZm9udGNoYXIudGV4dHVyZSA9IG5ldyBUZXh0dXJlXzEuVGV4dHVyZShiYXNlLmJhc2VUZXh0dXJlLCB0ZXh0dXJlUmVjdCk7XG4gICAgICAgICAgICBmb250Y2hhci5wYWdlID0gcGFnZTtcbiAgICAgICAgICAgIGRhdGEuY2hhcnNbY2hhckNvZGVdID0gZm9udGNoYXI7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGtlcm5pbmdzID0gQXJyYXkuZnJvbSh4bWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2tlcm5pbmcnKSk7XG4gICAgICAgIGZvciAobGV0IGkkMiA9IDA7IGkkMiA8IGtlcm5pbmdzLmxlbmd0aDsgaSQyKyspIHtcbiAgICAgICAgICAgIGxldCBrZXJuaW5nID0ga2VybmluZ3NbaSQyXTtcbiAgICAgICAgICAgIGxldCBmaXJzdCA9IHBhcnNlSW50KGtlcm5pbmcuZ2V0QXR0cmlidXRlKCdmaXJzdCcpLCAxMCkgLyByZXM7XG4gICAgICAgICAgICBsZXQgc2Vjb25kID0gcGFyc2VJbnQoa2VybmluZy5nZXRBdHRyaWJ1dGUoJ3NlY29uZCcpLCAxMCkgLyByZXM7XG4gICAgICAgICAgICBsZXQgYW1vdW50ID0gcGFyc2VJbnQoa2VybmluZy5nZXRBdHRyaWJ1dGUoJ2Ftb3VudCcpLCAxMCkgLyByZXM7XG4gICAgICAgICAgICBpZiAoZGF0YS5jaGFyc1tzZWNvbmRdKSB7XG4gICAgICAgICAgICAgICAgZGF0YS5jaGFyc1tzZWNvbmRdLmtlcm5pbmdbZmlyc3RdID0gYW1vdW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbn1cbkZvbnRNYW5hZ2VyLmZvbnRMb2FkZXJzID0ge307XG5Gb250TWFuYWdlci5iaXRtYXBmb250cyA9IHt9O1xuRm9udE1hbmFnZXIud2ViRm9udEFjdGl2ZSA9ICgpID0+IHtcbiAgICBpZiAoRm9udE1hbmFnZXIub25XZWJGb250bG9hZGVkKSB7XG4gICAgICAgIEZvbnRNYW5hZ2VyLm9uV2ViRm9udGxvYWRlZCgpO1xuICAgIH1cbn07XG5Gb250TWFuYWdlci5sb2FkV2ViRm9udCA9ICgpID0+IHtcbiAgICBjb25zdCB3ZiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICAgIHdmLnNyYyA9IGAke2RvY3VtZW50LmxvY2F0aW9uLnByb3RvY29sID09PSAnaHR0cHM6JyA/ICdodHRwcycgOiAnaHR0cCd9Oi8vYWpheC5nb29nbGVhcGlzLmNvbS9hamF4L2xpYnMvd2ViZm9udC8xL3dlYmZvbnQuanNgO1xuICAgIHdmLnR5cGUgPSAndGV4dC9qYXZhc2NyaXB0JztcbiAgICB3Zi5hc3luYyA9ICd0cnVlJztcbiAgICBjb25zdCBzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3NjcmlwdCcpWzBdO1xuICAgIHMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUod2YsIHMpO1xufTtcbmV4cG9ydHMuRm9udE1hbmFnZXIgPSBGb250TWFuYWdlcjtcbmNsYXNzIEJpdG1hcEZvbnQge1xufVxuZXhwb3J0cy5CaXRtYXBGb250ID0gQml0bWFwRm9udDtcbmNsYXNzIEJpdG1hcEZvbnRMb2FkZXIgZXh0ZW5kcyBFdmVudERpc3BhdGNoZXJfMS5FdmVudERpc3BhdGNoZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmhhbmRsZUZvbnRYTUxDb21wbGV0ZSA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5mb250eG1sID0gWE1MUGFyc2VyXzEuWE1MUGFyc2VyLnBhcnNlKHRoaXMudXJsbG9hZGVyLmRhdGEpO1xuICAgICAgICAgICAgbGV0IHBhZ2VzID0gdGhpcy5mb250eG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdwYWdlJylbMF07XG4gICAgICAgICAgICBsZXQgcGFnZXBhdGggPSBwYWdlcy5nZXRBdHRyaWJ1dGUoJ2ZpbGUnKTtcbiAgICAgICAgICAgIHRoaXMudGV4dHVyZWxvYWRlciA9IG5ldyBSZXNvdXJjZUxvYWRlcl8xLlJlc291cmNlTG9hZGVyKG5ldyBVUkxSZXF1ZXN0XzEuVVJMUmVxdWVzdCh0aGlzLnJvb3RwYXRoICsgcGFnZXBhdGgpKTtcbiAgICAgICAgICAgIHRoaXMudGV4dHVyZWxvYWRlci5hZGRFdmVudExpc3RlbmVyKEV2ZW50XzEuRXZlbnQuQ09NUExFVEUsIHRoaXMuaGFuZGxldGV4dHVyZUxvYWRlZCk7XG4gICAgICAgICAgICB0aGlzLnRleHR1cmVsb2FkZXIubG9hZCgpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZXRleHR1cmVMb2FkZWQgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGxldCBiID0gbmV3IEJhc2VUZXh0dXJlXzEuQmFzZVRleHR1cmUodGhpcy50ZXh0dXJlbG9hZGVyLmltYWdlRGF0YSk7XG4gICAgICAgICAgICBsZXQgdCA9IG5ldyBUZXh0dXJlXzEuVGV4dHVyZShiKTtcbiAgICAgICAgICAgIHRoaXMuZm9udGRhdGEgPSBGb250TWFuYWdlci5wYXJzZUJpdG1hcEZvbnREYXRhKHRoaXMuZm9udHhtbCwgdCk7XG4gICAgICAgICAgICBGb250TWFuYWdlci5hZGRCaXRtYXBGb250KHRoaXMuZm9udGRhdGEpO1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KEV2ZW50XzEuRXZlbnQuZ2V0RXZlbnQoRXZlbnRfMS5FdmVudC5DT01QTEVURSkpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZUZvbnRMb2FkRXJyb3IgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGxvYWRGb250KHBhdGgpIHtcbiAgICAgICAgbGV0IHJlcXVlc3QgPSBuZXcgVVJMUmVxdWVzdF8xLlVSTFJlcXVlc3QocGF0aCk7XG4gICAgICAgIGlmIChwYXRoLmluZGV4T2YoXCIvXCIpID49IDApIHtcbiAgICAgICAgICAgIGxldCBwYXRocGFydHMgPSBwYXRoLnNwbGl0KFwiL1wiKTtcbiAgICAgICAgICAgIHBhdGhwYXJ0cy5wb3AoKTtcbiAgICAgICAgICAgIHRoaXMucm9vdHBhdGggPSBwYXRocGFydHMuam9pbihcIi9cIikgKyBcIi9cIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucm9vdHBhdGggPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIHJlcXVlc3QubWV0aG9kID0gVVJMUmVxdWVzdE1ldGhvZF8xLlVSTFJlcXVlc3RNZXRob2QuUE9TVDtcbiAgICAgICAgdGhpcy51cmxsb2FkZXIgPSBuZXcgVVJMTG9hZGVyXzEuVVJMTG9hZGVyKCk7XG4gICAgICAgIHRoaXMudXJsbG9hZGVyLmFkZEV2ZW50TGlzdGVuZXIoRXZlbnRfMS5FdmVudC5DT01QTEVURSwgdGhpcy5oYW5kbGVGb250WE1MQ29tcGxldGUpO1xuICAgICAgICB0aGlzLnVybGxvYWRlci5hZGRFdmVudExpc3RlbmVyKElPRXJyb3JFdmVudF8xLklPRXJyb3JFdmVudC5JT19FUlJPUiwgdGhpcy5oYW5kbGVGb250TG9hZEVycm9yKTtcbiAgICAgICAgdGhpcy51cmxsb2FkZXIubG9hZChyZXF1ZXN0KTtcbiAgICB9XG59XG5jbGFzcyBGb250Q2hhcmFjdGVyRGF0YSB7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IEJhc2VUZXh0dXJlXzEgPSByZXF1aXJlKFwiLi9CYXNlVGV4dHVyZVwiKTtcbmNvbnN0IERlcHRoUmVzb3VyY2VfMSA9IHJlcXVpcmUoXCIuL0RlcHRoUmVzb3VyY2VcIik7XG5jb25zdCBXZWJHTFNldHRpbmdzXzEgPSByZXF1aXJlKFwiLi9XZWJHTFNldHRpbmdzXCIpO1xuY29uc3QgUnVubmVyXzEgPSByZXF1aXJlKFwiLi9SdW5uZXJcIik7XG5jbGFzcyBGcmFtZWJ1ZmZlciB7XG4gICAgY29uc3RydWN0b3Iod2lkdGgsIGhlaWdodCkge1xuICAgICAgICB0aGlzLndpZHRoID0gTWF0aC5jZWlsKHdpZHRoIHx8IDEwMCk7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gTWF0aC5jZWlsKGhlaWdodCB8fCAxMDApO1xuICAgICAgICB0aGlzLnN0ZW5jaWwgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kZXB0aCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRpcnR5SWQgPSAwO1xuICAgICAgICB0aGlzLmRpcnR5Rm9ybWF0ID0gMDtcbiAgICAgICAgdGhpcy5kaXJ0eVNpemUgPSAwO1xuICAgICAgICB0aGlzLmRlcHRoVGV4dHVyZSA9IG51bGw7XG4gICAgICAgIHRoaXMuY29sb3JUZXh0dXJlcyA9IFtdO1xuICAgICAgICB0aGlzLmdsRnJhbWVidWZmZXJzID0ge307XG4gICAgICAgIHRoaXMuZGlzcG9zZVJ1bm5lciA9IG5ldyBSdW5uZXJfMS5SdW5uZXIoJ2Rpc3Bvc2VGcmFtZWJ1ZmZlcicsIDIpO1xuICAgICAgICAvLyB0aGlzLmRpc3Bvc2VSdW5uZXIgPSBuZXcgUnVubmVyKCdkaXNwb3NlRnJhbWVidWZmZXInLCAyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVmZXJlbmNlIHRvIHRoZSBjb2xvclRleHR1cmUuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtQSVhJLlRleHR1cmVbXX1cbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKi9cbiAgICBnZXQgY29sb3JUZXh0dXJlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb2xvclRleHR1cmVzWzBdO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogQWRkIHRleHR1cmUgdG8gdGhlIGNvbG9yVGV4dHVyZSBhcnJheVxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtpbmRleD0wXSAtIEluZGV4IG9mIHRoZSBhcnJheSB0byBhZGQgdGhlIHRleHR1cmUgdG9cbiAgICAgKiBAcGFyYW0ge1BJWEkuVGV4dHVyZX0gW3RleHR1cmVdIC0gVGV4dHVyZSB0byBhZGQgdG8gdGhlIGFycmF5XG4gICAgICovXG4gICAgYWRkQ29sb3JUZXh0dXJlKGluZGV4LCB0ZXh0dXJlKSB7XG4gICAgICAgIGlmIChpbmRleCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBpbmRleCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVE9ETyBhZGQgc29tZSB2YWxpZGF0aW9uIHRvIHRoZSB0ZXh0dXJlIC0gc2FtZSB3aWR0aCAvIGhlaWdodCBldGM/XG4gICAgICAgIHRoaXMuY29sb3JUZXh0dXJlc1tpbmRleF0gPSB0ZXh0dXJlIHx8IG5ldyBCYXNlVGV4dHVyZV8xLkJhc2VUZXh0dXJlKG51bGwsIHsgc2NhbGVNb2RlOiAwLFxuICAgICAgICAgICAgcmVzb2x1dGlvbjogMSxcbiAgICAgICAgICAgIG1pcG1hcDogZmFsc2UsXG4gICAgICAgICAgICB3aWR0aDogdGhpcy53aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogdGhpcy5oZWlnaHQgfSk7IC8vIHx8IG5ldyBUZXh0dXJlKCk7XG4gICAgICAgIHRoaXMuZGlydHlJZCsrO1xuICAgICAgICB0aGlzLmRpcnR5Rm9ybWF0Kys7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogQWRkIGEgZGVwdGggdGV4dHVyZSB0byB0aGUgZnJhbWUgYnVmZmVyXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BJWEkuVGV4dHVyZX0gW3RleHR1cmVdIC0gVGV4dHVyZSB0byBhZGRcbiAgICAgKi9cbiAgICBhZGREZXB0aFRleHR1cmUodGV4dHVyZSkge1xuICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXG4gICAgICAgIHRoaXMuZGVwdGhUZXh0dXJlID0gdGV4dHVyZSB8fCBuZXcgQmFzZVRleHR1cmVfMS5CYXNlVGV4dHVyZShuZXcgRGVwdGhSZXNvdXJjZV8xLkRlcHRoUmVzb3VyY2UobnVsbCwgeyB3aWR0aDogdGhpcy53aWR0aCwgaGVpZ2h0OiB0aGlzLmhlaWdodCB9KSwgeyBzY2FsZU1vZGU6IDAsXG4gICAgICAgICAgICByZXNvbHV0aW9uOiAxLFxuICAgICAgICAgICAgd2lkdGg6IHRoaXMud2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0LFxuICAgICAgICAgICAgbWlwbWFwOiBmYWxzZSxcbiAgICAgICAgICAgIGZvcm1hdDogV2ViR0xTZXR0aW5nc18xLldlYkdMU2V0dGluZ3MuRk9STUFUUy5ERVBUSF9DT01QT05FTlQsXG4gICAgICAgICAgICB0eXBlOiBXZWJHTFNldHRpbmdzXzEuV2ViR0xTZXR0aW5ncy5UWVBFUy5VTlNJR05FRF9TSE9SVCB9KTsgLy8gVU5TSUdORURfU0hPUlQ7XG4gICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4gKi9cbiAgICAgICAgdGhpcy5kaXJ0eUlkKys7XG4gICAgICAgIHRoaXMuZGlydHlGb3JtYXQrKztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBFbmFibGUgZGVwdGggb24gdGhlIGZyYW1lIGJ1ZmZlclxuICAgICAqL1xuICAgIGVuYWJsZURlcHRoKCkge1xuICAgICAgICB0aGlzLmRlcHRoID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5kaXJ0eUlkKys7XG4gICAgICAgIHRoaXMuZGlydHlGb3JtYXQrKztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBFbmFibGUgc3RlbmNpbCBvbiB0aGUgZnJhbWUgYnVmZmVyXG4gICAgICovXG4gICAgZW5hYmxlU3RlbmNpbCgpIHtcbiAgICAgICAgdGhpcy5zdGVuY2lsID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5kaXJ0eUlkKys7XG4gICAgICAgIHRoaXMuZGlydHlGb3JtYXQrKztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBSZXNpemUgdGhlIGZyYW1lIGJ1ZmZlclxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIC0gV2lkdGggb2YgdGhlIGZyYW1lIGJ1ZmZlciB0byByZXNpemUgdG9cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IC0gSGVpZ2h0IG9mIHRoZSBmcmFtZSBidWZmZXIgdG8gcmVzaXplIHRvXG4gICAgICovXG4gICAgcmVzaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgd2lkdGggPSBNYXRoLmNlaWwod2lkdGgpO1xuICAgICAgICBoZWlnaHQgPSBNYXRoLmNlaWwoaGVpZ2h0KTtcbiAgICAgICAgaWYgKHdpZHRoID09PSB0aGlzLndpZHRoICYmIGhlaWdodCA9PT0gdGhpcy5oZWlnaHQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICB0aGlzLmRpcnR5SWQrKztcbiAgICAgICAgdGhpcy5kaXJ0eVNpemUrKztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNvbG9yVGV4dHVyZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciB0ZXh0dXJlID0gdGhpcy5jb2xvclRleHR1cmVzW2ldO1xuICAgICAgICAgICAgdmFyIHJlc29sdXRpb24gPSB0ZXh0dXJlLnJlc29sdXRpb247XG4gICAgICAgICAgICAvLyB0YWtlIGludG8gYWNvdW50IHRoZSBmYWN0IHRoZSB0ZXh0dXJlIG1heSBoYXZlIGEgZGlmZmVyZW50IHJlc29sdXRpb24uLlxuICAgICAgICAgICAgdGV4dHVyZS5zZXRTaXplKHdpZHRoIC8gcmVzb2x1dGlvbiwgaGVpZ2h0IC8gcmVzb2x1dGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZGVwdGhUZXh0dXJlKSB7XG4gICAgICAgICAgICB2YXIgcmVzb2x1dGlvbiQxID0gdGhpcy5kZXB0aFRleHR1cmUucmVzb2x1dGlvbjtcbiAgICAgICAgICAgIHRoaXMuZGVwdGhUZXh0dXJlLnNldFNpemUod2lkdGggLyByZXNvbHV0aW9uJDEsIGhlaWdodCAvIHJlc29sdXRpb24kMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIGRpc3Bvc2VzIFdlYkdMIHJlc291cmNlcyB0aGF0IGFyZSBjb25uZWN0ZWQgdG8gdGhpcyBnZW9tZXRyeVxuICAgICAqL1xuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgIC8vIHRoaXMuZGlzcG9zZVJ1bm5lci5ydW4odGhpcywgZmFsc2UpO1xuICAgICAgICB0aGlzLmRpc3Bvc2VSdW5uZXIucnVuKHRoaXMsIGZhbHNlKTtcbiAgICB9XG4gICAgO1xufVxuZXhwb3J0cy5GcmFtZWJ1ZmZlciA9IEZyYW1lYnVmZmVyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBTeXN0ZW1fMSA9IHJlcXVpcmUoXCIuL1N5c3RlbVwiKTtcbmNvbnN0IEZyYW1lYnVmZmVyXzEgPSByZXF1aXJlKFwiLi9GcmFtZWJ1ZmZlclwiKTtcbmNvbnN0IFJlY3RhbmdsZV8xID0gcmVxdWlyZShcIi4uL2ZsYXNoL2dlb20vUmVjdGFuZ2xlXCIpO1xuY29uc3QgRGlzcGxheVNldHRpbmdzXzEgPSByZXF1aXJlKFwiLi9EaXNwbGF5U2V0dGluZ3NcIik7XG5jb25zdCBJbnN0YW5jZUNvdW50ZXJfMSA9IHJlcXVpcmUoXCIuL0luc3RhbmNlQ291bnRlclwiKTtcbmNsYXNzIEZyYW1lYnVmZmVyU3lzdGVtIGV4dGVuZHMgU3lzdGVtXzEuU3lzdGVtIHtcbiAgICBjb25zdHJ1Y3RvcihyZW5kZXJlcikge1xuICAgICAgICBzdXBlcihyZW5kZXJlcik7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGxpc3Qgb2YgbWFuYWdlZCBmcmFtZWJ1ZmZlcnNcbiAgICAgICAgICogQG1lbWJlciB7UElYSS5GcmFtZWJ1ZmZlcltdfVxuICAgICAgICAgKiBAcmVhZG9ubHlcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubWFuYWdlZEZyYW1lYnVmZmVycyA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgICogRnJhbWVidWZmZXIgdmFsdWUgdGhhdCBzaG93cyB0aGF0IHdlIGRvbid0IGtub3cgd2hhdCBpcyBib3VuZFxuICAgICAgICAgKiBAbWVtYmVyIHtGcmFtZWJ1ZmZlcn1cbiAgICAgICAgICogQHJlYWRvbmx5XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnVua25vd25GcmFtZWJ1ZmZlciA9IG5ldyBGcmFtZWJ1ZmZlcl8xLkZyYW1lYnVmZmVyKDEwLCAxMCk7XG4gICAgICAgIEluc3RhbmNlQ291bnRlcl8xLkluc3RhbmNlQ291bnRlci5hZGRDYWxsKFwiUmVjdGFuZ2xlLmdldFJlY3RhbmdsZVwiLCBcIkZyYW1lQnVmZmVyU3lzdGVtXCIpO1xuICAgICAgICB0aGlzLnZpZXdwb3J0ID0gUmVjdGFuZ2xlXzEuUmVjdGFuZ2xlLmdldFJlY3RhbmdsZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHVwIHRoZSByZW5kZXJlciBjb250ZXh0IGFuZCBuZWNlc3NhcnkgYnVmZmVycy5cbiAgICAgKi9cbiAgICBjb250ZXh0Q2hhbmdlKGdsKSB7XG4gICAgICAgIHZhciBnbCA9IHRoaXMuZ2wgPSB0aGlzLnJlbmRlcmVyLmdsO1xuICAgICAgICB0aGlzLkNPTlRFWFRfVUlEID0gdGhpcy5yZW5kZXJlci5DT05URVhUX1VJRDtcbiAgICAgICAgdGhpcy5jdXJyZW50ID0gdGhpcy51bmtub3duRnJhbWVidWZmZXI7XG4gICAgICAgIEluc3RhbmNlQ291bnRlcl8xLkluc3RhbmNlQ291bnRlci5hZGRDYWxsKFwiUmVjdGFuZ2xlLmdldFJlY3RhbmdsZVwiLCBcIkZyYW1lQnVmZmVyU3lzdGVtIGNvbnRleHRDaGFuZ2VcIik7XG4gICAgICAgIHRoaXMudmlld3BvcnQgPSBSZWN0YW5nbGVfMS5SZWN0YW5nbGUuZ2V0UmVjdGFuZ2xlKCk7XG4gICAgICAgIHRoaXMuaGFzTVJUID0gdHJ1ZTtcbiAgICAgICAgdGhpcy53cml0ZURlcHRoVGV4dHVyZSA9IHRydWU7XG4gICAgICAgIHRoaXMuZGlzcG9zZUFsbCh0cnVlKTtcbiAgICAgICAgLy8gd2ViZ2wyXG4gICAgICAgIGlmICh0aGlzLnJlbmRlcmVyLmNvbnRleHQud2ViR0xWZXJzaW9uID09PSAxKSB7XG4gICAgICAgICAgICAvLyB3ZWJnbCAxIVxuICAgICAgICAgICAgdmFyIG5hdGl2ZURyYXdCdWZmZXJzRXh0ZW5zaW9uID0gdGhpcy5yZW5kZXJlci5jb250ZXh0LmV4dGVuc2lvbnMuZHJhd0J1ZmZlcnM7XG4gICAgICAgICAgICB2YXIgbmF0aXZlRGVwdGhUZXh0dXJlRXh0ZW5zaW9uID0gdGhpcy5yZW5kZXJlci5jb250ZXh0LmV4dGVuc2lvbnMuZGVwdGhUZXh0dXJlO1xuICAgICAgICAgICAgaWYgKERpc3BsYXlTZXR0aW5nc18xLkRpc3BsYXlTZXR0aW5ncy5QUkVGRVJfRU5WID09PSBEaXNwbGF5U2V0dGluZ3NfMS5EaXNwbGF5U2V0dGluZ3MuRU5WLldFQkdMX0xFR0FDWSkge1xuICAgICAgICAgICAgICAgIG5hdGl2ZURyYXdCdWZmZXJzRXh0ZW5zaW9uID0gbnVsbDtcbiAgICAgICAgICAgICAgICBuYXRpdmVEZXB0aFRleHR1cmVFeHRlbnNpb24gPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5hdGl2ZURyYXdCdWZmZXJzRXh0ZW5zaW9uKSB7XG4gICAgICAgICAgICAgICAgZ2wuZHJhd0J1ZmZlcnMgPSBmdW5jdGlvbiAoYWN0aXZlVGV4dHVyZXMpIHsgcmV0dXJuIG5hdGl2ZURyYXdCdWZmZXJzRXh0ZW5zaW9uLmRyYXdCdWZmZXJzV0VCR0woYWN0aXZlVGV4dHVyZXMpOyB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oYXNNUlQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBnbC5kcmF3QnVmZmVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZW1wdHlcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFuYXRpdmVEZXB0aFRleHR1cmVFeHRlbnNpb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLndyaXRlRGVwdGhUZXh0dXJlID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAgICAgKiBCaW5kIGEgZnJhbWVidWZmZXJcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtQSVhJLkZyYW1lYnVmZmVyfSBmcmFtZWJ1ZmZlclxuICAgICAgICAgKiBAcGFyYW0ge1BJWEkuUmVjdGFuZ2xlfSBbZnJhbWVdIGZyYW1lLCBkZWZhdWx0IGlzIGZyYW1lYnVmZmVyIHNpemVcbiAgICAgICAgICovXG4gICAgYmluZChmcmFtZWJ1ZmZlciA9IG51bGwsIGZyYW1lID0gbnVsbCkge1xuICAgICAgICB2YXIgcmVmID0gdGhpcztcbiAgICAgICAgdmFyIGdsID0gcmVmLmdsO1xuICAgICAgICBpZiAoZnJhbWVidWZmZXIpIHtcbiAgICAgICAgICAgIC8vIFRPRE8gY2FjaGluZyBsYXllciFcbiAgICAgICAgICAgIHZhciBmYm8gPSBmcmFtZWJ1ZmZlci5nbEZyYW1lYnVmZmVyc1t0aGlzLkNPTlRFWFRfVUlEXSB8fCB0aGlzLmluaXRGcmFtZWJ1ZmZlcihmcmFtZWJ1ZmZlcik7XG4gICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50ICE9PSBmcmFtZWJ1ZmZlcikge1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudCA9IGZyYW1lYnVmZmVyO1xuICAgICAgICAgICAgICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgZmJvLmZyYW1lYnVmZmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSBhbGwgdGV4dHVyZXMgYXJlIHVuYm91bmQuLlxuICAgICAgICAgICAgLy8gbm93IGNoZWNrIGZvciB1cGRhdGVzLi4uXG4gICAgICAgICAgICBpZiAoZmJvLmRpcnR5SWQgIT09IGZyYW1lYnVmZmVyLmRpcnR5SWQpIHtcbiAgICAgICAgICAgICAgICBmYm8uZGlydHlJZCA9IGZyYW1lYnVmZmVyLmRpcnR5SWQ7XG4gICAgICAgICAgICAgICAgaWYgKGZiby5kaXJ0eUZvcm1hdCAhPT0gZnJhbWVidWZmZXIuZGlydHlGb3JtYXQpIHtcbiAgICAgICAgICAgICAgICAgICAgZmJvLmRpcnR5Rm9ybWF0ID0gZnJhbWVidWZmZXIuZGlydHlGb3JtYXQ7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlRnJhbWVidWZmZXIoZnJhbWVidWZmZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChmYm8uZGlydHlTaXplICE9PSBmcmFtZWJ1ZmZlci5kaXJ0eVNpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgZmJvLmRpcnR5U2l6ZSA9IGZyYW1lYnVmZmVyLmRpcnR5U2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXNpemVGcmFtZWJ1ZmZlcihmcmFtZWJ1ZmZlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmcmFtZWJ1ZmZlci5jb2xvclRleHR1cmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZyYW1lYnVmZmVyLmNvbG9yVGV4dHVyZXNbaV0udGV4dHVyZVBhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci50ZXh0dXJlLnVuYmluZChmcmFtZWJ1ZmZlci5jb2xvclRleHR1cmVzW2ldLnRleHR1cmUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci50ZXh0dXJlLnVuYmluZChmcmFtZWJ1ZmZlci5jb2xvclRleHR1cmVzW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZnJhbWVidWZmZXIuZGVwdGhUZXh0dXJlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci50ZXh0dXJlLnVuYmluZChmcmFtZWJ1ZmZlci5kZXB0aFRleHR1cmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZyYW1lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRWaWV3cG9ydChmcmFtZS54LCBmcmFtZS55LCBmcmFtZS53aWR0aCwgZnJhbWUuaGVpZ2h0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0Vmlld3BvcnQoMCwgMCwgZnJhbWVidWZmZXIud2lkdGgsIGZyYW1lYnVmZmVyLmhlaWdodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgICAgICAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZyYW1lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRWaWV3cG9ydChmcmFtZS54LCBmcmFtZS55LCBmcmFtZS53aWR0aCwgZnJhbWUuaGVpZ2h0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0Vmlld3BvcnQoMCwgMCwgdGhpcy5yZW5kZXJlci53aWR0aCwgdGhpcy5yZW5kZXJlci5oZWlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIFdlYkdMUmVuZGVyaW5nQ29udGV4dCdzIHZpZXdwb3J0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHggLSBYIHBvc2l0aW9uIG9mIHZpZXdwb3J0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHkgLSBZIHBvc2l0aW9uIG9mIHZpZXdwb3J0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoIC0gV2lkdGggb2Ygdmlld3BvcnRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0IC0gSGVpZ2h0IG9mIHZpZXdwb3J0XG4gICAgICovXG4gICAgc2V0Vmlld3BvcnQoeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICB2YXIgdiA9IHRoaXMudmlld3BvcnQ7XG4gICAgICAgIGlmICh2LndpZHRoICE9PSB3aWR0aCB8fCB2LmhlaWdodCAhPT0gaGVpZ2h0IHx8IHYueCAhPT0geCB8fCB2LnkgIT09IHkpIHtcbiAgICAgICAgICAgIHYueCA9IHg7XG4gICAgICAgICAgICB2LnkgPSB5O1xuICAgICAgICAgICAgdi53aWR0aCA9IHdpZHRoO1xuICAgICAgICAgICAgdi5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgICAgICB0aGlzLmdsLnZpZXdwb3J0KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHNpemUgb2YgdGhlIGN1cnJlbnQgd2lkdGggYW5kIGhlaWdodC4gUmV0dXJucyBvYmplY3Qgd2l0aCBgd2lkdGhgIGFuZCBgaGVpZ2h0YCB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtvYmplY3R9XG4gICAgICogQHJlYWRvbmx5XG4gICAgICovXG4gICAgZ2V0IHNpemUoKSB7XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIC8vIFRPRE8gc3RvcmUgdGVtcFxuICAgICAgICAgICAgcmV0dXJuIHsgeDogMCwgeTogMCwgd2lkdGg6IHRoaXMuY3VycmVudC53aWR0aCwgaGVpZ2h0OiB0aGlzLmN1cnJlbnQuaGVpZ2h0IH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgeDogMCwgeTogMCwgd2lkdGg6IHRoaXMucmVuZGVyZXIud2lkdGgsIGhlaWdodDogdGhpcy5yZW5kZXJlci5oZWlnaHQgfTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIENsZWFyIHRoZSBjb2xvciBvZiB0aGUgY29udGV4dFxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHIgLSBSZWQgdmFsdWUgZnJvbSAwIHRvIDFcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZyAtIEdyZWVuIHZhbHVlIGZyb20gMCB0byAxXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGIgLSBCbHVlIHZhbHVlIGZyb20gMCB0byAxXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGEgLSBBbHBoYSB2YWx1ZSBmcm9tIDAgdG8gMVxuICAgICAqL1xuICAgIGNsZWFyKHIgPSAwLCBnID0gMCwgYiA9IDAsIGEgPSAxKSB7XG4gICAgICAgIHZhciByZWYgPSB0aGlzO1xuICAgICAgICB2YXIgZ2wgPSByZWYuZ2w7XG4gICAgICAgIC8vIFRPRE8gY2xlYXIgY29sb3IgY2FuIGJlIHNldCBvbmx5IG9uZSByaWdodD9cbiAgICAgICAgZ2wuY2xlYXJDb2xvcihyLCBnLCBiLCBhKTtcbiAgICAgICAgZ2wuY2xlYXIoZ2wuQ09MT1JfQlVGRkVSX0JJVCB8IGdsLkRFUFRIX0JVRkZFUl9CSVQpO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gKiBJbml0aWFsaXplIGZyYW1lYnVmZmVyXG4gKlxuICogQHByb3RlY3RlZFxuICogQHBhcmFtIHtQSVhJLkZyYW1lYnVmZmVyfSBmcmFtZWJ1ZmZlclxuICovXG4gICAgaW5pdEZyYW1lYnVmZmVyKGZyYW1lYnVmZmVyKSB7XG4gICAgICAgIHZhciByZWYgPSB0aGlzO1xuICAgICAgICB2YXIgZ2wgPSByZWYuZ2w7XG4gICAgICAgIC8vIFRPRE8gLSBtYWtlIHRoaXMgYSBjbGFzcz9cbiAgICAgICAgdmFyIGZibyA9IHtcbiAgICAgICAgICAgIGZyYW1lYnVmZmVyOiBnbC5jcmVhdGVGcmFtZWJ1ZmZlcigpLFxuICAgICAgICAgICAgc3RlbmNpbDogbnVsbCxcbiAgICAgICAgICAgIGRpcnR5SWQ6IDAsXG4gICAgICAgICAgICBkaXJ0eUZvcm1hdDogMCxcbiAgICAgICAgICAgIGRpcnR5U2l6ZTogMCxcbiAgICAgICAgfTtcbiAgICAgICAgZnJhbWVidWZmZXIuZ2xGcmFtZWJ1ZmZlcnNbdGhpcy5DT05URVhUX1VJRF0gPSBmYm87XG4gICAgICAgIHRoaXMubWFuYWdlZEZyYW1lYnVmZmVycy5wdXNoKGZyYW1lYnVmZmVyKTtcbiAgICAgICAgZnJhbWVidWZmZXIuZGlzcG9zZVJ1bm5lci5hZGQodGhpcyk7XG4gICAgICAgIHJldHVybiBmYm87XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBSZXNpemUgdGhlIGZyYW1lYnVmZmVyXG4gICAgICpcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHBhcmFtIHtQSVhJLkZyYW1lYnVmZmVyfSBmcmFtZWJ1ZmZlclxuICAgICAqL1xuICAgIHJlc2l6ZUZyYW1lYnVmZmVyKGZyYW1lYnVmZmVyKSB7XG4gICAgICAgIHZhciByZWYgPSB0aGlzO1xuICAgICAgICB2YXIgZ2wgPSByZWYuZ2w7XG4gICAgICAgIHZhciBmYm8gPSBmcmFtZWJ1ZmZlci5nbEZyYW1lYnVmZmVyc1t0aGlzLkNPTlRFWFRfVUlEXTtcbiAgICAgICAgaWYgKGZiby5zdGVuY2lsKSB7XG4gICAgICAgICAgICBnbC5iaW5kUmVuZGVyYnVmZmVyKGdsLlJFTkRFUkJVRkZFUiwgZmJvLnN0ZW5jaWwpO1xuICAgICAgICAgICAgZ2wucmVuZGVyYnVmZmVyU3RvcmFnZShnbC5SRU5ERVJCVUZGRVIsIGdsLkRFUFRIX1NURU5DSUwsIGZyYW1lYnVmZmVyLndpZHRoLCBmcmFtZWJ1ZmZlci5oZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb2xvclRleHR1cmVzID0gZnJhbWVidWZmZXIuY29sb3JUZXh0dXJlcztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb2xvclRleHR1cmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnRleHR1cmUuYmluZChjb2xvclRleHR1cmVzW2ldLCAwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZnJhbWVidWZmZXIuZGVwdGhUZXh0dXJlKSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnRleHR1cmUuYmluZChmcmFtZWJ1ZmZlci5kZXB0aFRleHR1cmUsIDApO1xuICAgICAgICB9XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdGhlIGZyYW1lYnVmZmVyXG4gICAgICpcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHBhcmFtIHtQSVhJLkZyYW1lYnVmZmVyfSBmcmFtZWJ1ZmZlclxuICAgICAqL1xuICAgIHVwZGF0ZUZyYW1lYnVmZmVyKGZyYW1lYnVmZmVyKSB7XG4gICAgICAgIHZhciByZWYgPSB0aGlzO1xuICAgICAgICB2YXIgZ2wgPSByZWYuZ2w7XG4gICAgICAgIHZhciBmYm8gPSBmcmFtZWJ1ZmZlci5nbEZyYW1lYnVmZmVyc1t0aGlzLkNPTlRFWFRfVUlEXTtcbiAgICAgICAgLy8gYmluZCB0aGUgY29sb3IgdGV4dHVyZVxuICAgICAgICB2YXIgY29sb3JUZXh0dXJlcyA9IGZyYW1lYnVmZmVyLmNvbG9yVGV4dHVyZXM7XG4gICAgICAgIHZhciBjb3VudCA9IGNvbG9yVGV4dHVyZXMubGVuZ3RoO1xuICAgICAgICBpZiAoIWdsLmRyYXdCdWZmZXJzKSB7XG4gICAgICAgICAgICBjb3VudCA9IE1hdGgubWluKGNvdW50LCAxKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYWN0aXZlVGV4dHVyZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgdGV4dHVyZSA9IGZyYW1lYnVmZmVyLmNvbG9yVGV4dHVyZXNbaV07XG4gICAgICAgICAgICBpZiAodGV4dHVyZS50ZXh0dXJlUGFydCkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIudGV4dHVyZS5iaW5kKHRleHR1cmUudGV4dHVyZSwgMCk7XG4gICAgICAgICAgICAgICAgZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoZ2wuRlJBTUVCVUZGRVIsIGdsLkNPTE9SX0FUVEFDSE1FTlQwICsgaSwgZ2wuVEVYVFVSRV9DVUJFX01BUF9ORUdBVElWRV9YICsgdGV4dHVyZS5zaWRlLCB0ZXh0dXJlLnRleHR1cmUuX2dsVGV4dHVyZXNbdGhpcy5DT05URVhUX1VJRF0udGV4dHVyZSwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnRleHR1cmUuYmluZCh0ZXh0dXJlLCAwKTtcbiAgICAgICAgICAgICAgICBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChnbC5GUkFNRUJVRkZFUiwgZ2wuQ09MT1JfQVRUQUNITUVOVDAgKyBpLCBnbC5URVhUVVJFXzJELCB0ZXh0dXJlLl9nbFRleHR1cmVzW3RoaXMuQ09OVEVYVF9VSURdLnRleHR1cmUsIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWN0aXZlVGV4dHVyZXMucHVzaChnbC5DT0xPUl9BVFRBQ0hNRU5UMCArIGkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhY3RpdmVUZXh0dXJlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBnbC5kcmF3QnVmZmVycyhhY3RpdmVUZXh0dXJlcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZyYW1lYnVmZmVyLmRlcHRoVGV4dHVyZSkge1xuICAgICAgICAgICAgdmFyIHdyaXRlRGVwdGhUZXh0dXJlID0gdGhpcy53cml0ZURlcHRoVGV4dHVyZTtcbiAgICAgICAgICAgIGlmICh3cml0ZURlcHRoVGV4dHVyZSkge1xuICAgICAgICAgICAgICAgIHZhciBkZXB0aFRleHR1cmUgPSBmcmFtZWJ1ZmZlci5kZXB0aFRleHR1cmU7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci50ZXh0dXJlLmJpbmQoZGVwdGhUZXh0dXJlLCAwKTtcbiAgICAgICAgICAgICAgICBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChnbC5GUkFNRUJVRkZFUiwgZ2wuREVQVEhfQVRUQUNITUVOVCwgZ2wuVEVYVFVSRV8yRCwgZGVwdGhUZXh0dXJlLl9nbFRleHR1cmVzW3RoaXMuQ09OVEVYVF9VSURdLnRleHR1cmUsIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghZmJvLnN0ZW5jaWwgJiYgKGZyYW1lYnVmZmVyLnN0ZW5jaWwgfHwgZnJhbWVidWZmZXIuZGVwdGgpKSB7XG4gICAgICAgICAgICBmYm8uc3RlbmNpbCA9IGdsLmNyZWF0ZVJlbmRlcmJ1ZmZlcigpO1xuICAgICAgICAgICAgZ2wuYmluZFJlbmRlcmJ1ZmZlcihnbC5SRU5ERVJCVUZGRVIsIGZiby5zdGVuY2lsKTtcbiAgICAgICAgICAgIC8vIFRPRE8uLiB0aGlzIGlzIGRlcHRoIEFORCBzdGVuY2lsP1xuICAgICAgICAgICAgaWYgKCFmcmFtZWJ1ZmZlci5kZXB0aFRleHR1cmUpIHsgLy8geW91IGNhbid0IGhhdmUgYm90aCwgc28gb25lIHNob3VsZCB0YWtlIHByaW9yaXR5IGlmIGVuYWJsZWRcbiAgICAgICAgICAgICAgICBnbC5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgZ2wuREVQVEhfU1RFTkNJTF9BVFRBQ0hNRU5ULCBnbC5SRU5ERVJCVUZGRVIsIGZiby5zdGVuY2lsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdsLnJlbmRlcmJ1ZmZlclN0b3JhZ2UoZ2wuUkVOREVSQlVGRkVSLCBnbC5ERVBUSF9TVEVOQ0lMLCBmcmFtZWJ1ZmZlci53aWR0aCwgZnJhbWVidWZmZXIuaGVpZ2h0KTtcbiAgICAgICAgICAgIC8vIGZiby5lbmFibGVTdGVuY2lsKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIERpc3Bvc2VzIGZyYW1lYnVmZmVyXG4gICAgICogQHBhcmFtIHtQSVhJLkZyYW1lYnVmZmVyfSBmcmFtZWJ1ZmZlciBmcmFtZWJ1ZmZlciB0aGF0IGhhcyB0byBiZSBkaXNwb3NlZCBvZlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2NvbnRleHRMb3N0PWZhbHNlXSBJZiBjb250ZXh0IHdhcyBsb3N0LCB3ZSBzdXBwcmVzcyBhbGwgZGVsZXRlIGZ1bmN0aW9uIGNhbGxzXG4gICAgICovXG4gICAgZGlzcG9zZUZyYW1lYnVmZmVyKGZyYW1lYnVmZmVyLCBjb250ZXh0TG9zdCkge1xuICAgICAgICB2YXIgZmJvID0gZnJhbWVidWZmZXIuZ2xGcmFtZWJ1ZmZlcnNbdGhpcy5DT05URVhUX1VJRF07XG4gICAgICAgIHZhciBnbCA9IHRoaXMuZ2w7XG4gICAgICAgIGlmICghZmJvKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZGVsZXRlIGZyYW1lYnVmZmVyLmdsRnJhbWVidWZmZXJzW3RoaXMuQ09OVEVYVF9VSURdO1xuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLm1hbmFnZWRGcmFtZWJ1ZmZlcnMuaW5kZXhPZihmcmFtZWJ1ZmZlcik7XG4gICAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgICAgICB0aGlzLm1hbmFnZWRGcmFtZWJ1ZmZlcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgICAgICBmcmFtZWJ1ZmZlci5kaXNwb3NlUnVubmVyLnJlbW92ZSh0aGlzKTtcbiAgICAgICAgaWYgKCFjb250ZXh0TG9zdCkge1xuICAgICAgICAgICAgZ2wuZGVsZXRlRnJhbWVidWZmZXIoZmJvLmZyYW1lYnVmZmVyKTtcbiAgICAgICAgICAgIGlmIChmYm8uc3RlbmNpbCkge1xuICAgICAgICAgICAgICAgIGdsLmRlbGV0ZVJlbmRlcmJ1ZmZlcihmYm8uc3RlbmNpbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIERpc3Bvc2VzIGFsbCBmcmFtZWJ1ZmZlcnMsIGJ1dCBub3QgdGV4dHVyZXMgYm91bmQgdG8gdGhlbVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2NvbnRleHRMb3N0PWZhbHNlXSBJZiBjb250ZXh0IHdhcyBsb3N0LCB3ZSBzdXBwcmVzcyBhbGwgZGVsZXRlIGZ1bmN0aW9uIGNhbGxzXG4gICAgICovXG4gICAgZGlzcG9zZUFsbChjb250ZXh0TG9zdCkge1xuICAgICAgICB2YXIgbGlzdCA9IHRoaXMubWFuYWdlZEZyYW1lYnVmZmVycztcbiAgICAgICAgdGhpcy5tYW5hZ2VkRnJhbWVidWZmZXJzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5jb3VudDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLmRpc3Bvc2VGcmFtZWJ1ZmZlcihsaXN0W2ldLCBjb250ZXh0TG9zdCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIHJlc2V0cyBmcmFtZWJ1ZmZlciBzdG9yZWQgc3RhdGUsIGJpbmRzIHNjcmVlbiBmcmFtZWJ1ZmZlclxuICAgICAqXG4gICAgICogc2hvdWxkIGJlIGNhbGxlZCBiZWZvcmUgcmVuZGVyVGV4dHVyZSByZXNldCgpXG4gICAgICovXG4gICAgcmVzZXQoKSB7XG4gICAgICAgIHRoaXMuY3VycmVudCA9IHRoaXMudW5rbm93bkZyYW1lYnVmZmVyO1xuICAgICAgICBJbnN0YW5jZUNvdW50ZXJfMS5JbnN0YW5jZUNvdW50ZXIuYWRkQ2FsbChcIlJlY3RhbmdsZS5nZXRSZWN0YW5nbGVcIiwgXCJGcmFtZUJ1ZmZlclN5c3RlbSByZXNldFwiKTtcbiAgICAgICAgdGhpcy52aWV3cG9ydCA9IFJlY3RhbmdsZV8xLlJlY3RhbmdsZS5nZXRSZWN0YW5nbGUoKTtcbiAgICB9XG4gICAgO1xufVxuZXhwb3J0cy5GcmFtZWJ1ZmZlclN5c3RlbSA9IEZyYW1lYnVmZmVyU3lzdGVtO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jbGFzcyBHTEJ1ZmZlciB7XG4gICAgY29uc3RydWN0b3IoYnVmZmVyKSB7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gYnVmZmVyO1xuICAgICAgICB0aGlzLnVwZGF0ZUlEID0gLTE7XG4gICAgICAgIHRoaXMuYnl0ZUxlbmd0aCA9IC0xO1xuICAgICAgICB0aGlzLnJlZkNvdW50ID0gMDtcbiAgICB9XG59XG5leHBvcnRzLkdMQnVmZmVyID0gR0xCdWZmZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNsYXNzIEdMUHJvZ3JhbSB7XG4gICAgY29uc3RydWN0b3IocHJvZ3JhbSwgdW5pZm9ybURhdGEpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogVGhlIHNoYWRlciBwcm9ncmFtXG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiBAbWVtYmVyIHtXZWJHTFByb2dyYW19XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgIHRoaXMucHJvZ3JhbSA9IHByb2dyYW07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBob2xkcyB0aGUgdW5pZm9ybSBkYXRhIHdoaWNoIGNvbnRhaW5zIHVuaWZvcm0gbG9jYXRpb25zXG4gICAgICAgICAqIGFuZCBjdXJyZW50IHVuaWZvcm0gdmFsdWVzIHVzZWQgZm9yIGNhY2hpbmcgYW5kIHByZXZlbnRpbmcgdW5uZWVkZWQgR1BVIGNvbW1hbmRzXG4gICAgICAgICAqIEBtZW1iZXIge09iamVjdH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudW5pZm9ybURhdGEgPSB1bmlmb3JtRGF0YTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHVuaWZvcm1Hcm91cHMgaG9sZHMgdGhlIHZhcmlvdXMgdXBsb2FkIGZ1bmN0aW9ucyBmb3IgdGhlIHNoYWRlci4gRWFjaCB1bmlmb3JtIGdyb3VwXG4gICAgICAgICAqIGFuZCBwcm9ncmFtIGhhdmUgYSB1bmlxdWUgdXBsb2FkIGZ1bmN0aW9uIGdlbmVyYXRlZC5cbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy51bmlmb3JtR3JvdXBzID0ge307XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlc3Ryb3lzIHRoaXMgcHJvZ3JhbVxuICAgICAqL1xuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMudW5pZm9ybURhdGEgPSBudWxsO1xuICAgICAgICB0aGlzLnVuaWZvcm1Hcm91cHMgPSBudWxsO1xuICAgICAgICB0aGlzLnByb2dyYW0gPSBudWxsO1xuICAgIH1cbiAgICA7XG59XG5leHBvcnRzLkdMUHJvZ3JhbSA9IEdMUHJvZ3JhbTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY2xhc3MgR0xUZXh0dXJlIHtcbiAgICBjb25zdHJ1Y3Rvcih0ZXh0dXJlKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFRoZSBXZWJHTCB0ZXh0dXJlXG4gICAgICAgICAgICAgICAgICogQG1lbWJlciB7V2ViR0xUZXh0dXJlfVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICB0aGlzLnRleHR1cmUgPSB0ZXh0dXJlO1xuICAgICAgICB0aGlzLndpZHRoID0gLTE7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gLTE7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUZXh0dXJlIGNvbnRlbnRzIGRpcnR5IGZsYWdcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kaXJ0eUlkID0gLTE7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUZXh0dXJlIHN0eWxlIGRpcnR5IGZsYWdcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kaXJ0eVN0eWxlSWQgPSAtMTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgbWlwIGxldmVscyBoYXMgdG8gYmUgZ2VuZXJhdGVkXG4gICAgICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm1pcG1hcCA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogV3JhcE1vZGUgY29waWVkIGZyb20gYmFzZVRleHR1cmVcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy53cmFwTW9kZSA9IDMzMDcxO1xuICAgIH1cbn1cbmV4cG9ydHMuR0xUZXh0dXJlID0gR0xUZXh0dXJlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBBdHRyaWJ1dGVfMSA9IHJlcXVpcmUoXCIuL0F0dHJpYnV0ZVwiKTtcbmNvbnN0IEJ1ZmZlcl8xID0gcmVxdWlyZShcIi4vQnVmZmVyXCIpO1xuY29uc3QgUnVubmVyXzEgPSByZXF1aXJlKFwiLi9SdW5uZXJcIik7XG5jbGFzcyBHZW9tZXRyeSB7XG4gICAgY29uc3RydWN0b3IoYnVmZmVycyA9IFtdLCBhdHRyaWJ1dGVzID0ge30pIHtcbiAgICAgICAgdGhpcy5idWZmZXJzID0gYnVmZmVycztcbiAgICAgICAgdGhpcy5pbmRleEJ1ZmZlciA9IG51bGw7XG4gICAgICAgIHRoaXMuYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXM7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIG1hcCBvZiByZW5kZXJlciBJRHMgdG8gd2ViZ2wgVkFPc1xuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmdsVmVydGV4QXJyYXlPYmplY3RzID0ge307XG4gICAgICAgIHRoaXMuaWQgPSBHZW9tZXRyeS5VSUQkMSsrO1xuICAgICAgICB0aGlzLmluc3RhbmNlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmluc3RhbmNlQ291bnQgPSAxO1xuICAgICAgICB0aGlzLl9zaXplID0gbnVsbDtcbiAgICAgICAgdGhpcy5kaXNwb3NlUnVubmVyID0gbmV3IFJ1bm5lcl8xLlJ1bm5lcignZGlzcG9zZUdlb21ldHJ5JywgMik7XG4gICAgICAgIC8vIHRoaXMuZGlzcG9zZVJ1bm5lciA9IG5ldyBSdW5uZXIoJ2Rpc3Bvc2VHZW9tZXRyeScsIDIpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ291bnQgb2YgZXhpc3RpbmcgKG5vdCBkZXN0cm95ZWQpIG1lc2hlcyB0aGF0IHJlZmVyZW5jZSB0aGlzIGdlb21ldHJ5XG4gICAgICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJlZkNvdW50ID0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgKlxuICAgICogQWRkcyBhbiBhdHRyaWJ1dGUgdG8gdGhlIGdlb21ldHJ5XG4gICAgKlxuICAgICogQHBhcmFtIHtTdHJpbmd9IGlkIC0gdGhlIG5hbWUgb2YgdGhlIGF0dHJpYnV0ZSAobWF0Y2hpbmcgdXAgdG8gYSBzaGFkZXIpXG4gICAgKiBAcGFyYW0ge1BJWEkuQnVmZmVyfSBbYnVmZmVyXSB0aGUgYnVmZmVyIHRoYXQgaG9sZHMgdGhlIGRhdGEgb2YgdGhlIGF0dHJpYnV0ZSAuIFlvdSBjYW4gYWxzbyBwcm92aWRlIGFuIEFycmF5IGFuZCBhIGJ1ZmZlciB3aWxsIGJlIGNyZWF0ZWQgZnJvbSBpdC5cbiAgICAqIEBwYXJhbSB7TnVtYmVyfSBbc2l6ZT0wXSB0aGUgc2l6ZSBvZiB0aGUgYXR0cmlidXRlLiBJZiB5b3UgaGF2ZSAyIGZsb2F0cyBwZXIgdmVydGV4IChlZyBwb3NpdGlvbiB4IGFuZCB5KSB0aGlzIHdvdWxkIGJlIDJcbiAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW25vcm1hbGl6ZWQ9ZmFsc2VdIHNob3VsZCB0aGUgZGF0YSBiZSBub3JtYWxpemVkLlxuICAgICogQHBhcmFtIHtOdW1iZXJ9IFt0eXBlPVBJWEkuVFlQRVMuRkxPQVRdIHdoYXQgdHlwZSBvZiBudW1iZXIgaXMgdGhlIGF0dHJpYnV0ZS4gQ2hlY2sge1BJWEkuVFlQRVN9IHRvIHNlZSB0aGUgb25lcyBhdmFpbGFibGVcbiAgICAqIEBwYXJhbSB7TnVtYmVyfSBbc3RyaWRlPTBdIEhvdyBmYXIgYXBhcnQgKGluIGZsb2F0cykgdGhlIHN0YXJ0IG9mIGVhY2ggdmFsdWUgaXMuICh1c2VkIGZvciBpbnRlcmxlYXZpbmcgZGF0YSlcbiAgICAqIEBwYXJhbSB7TnVtYmVyfSBbc3RhcnQ9MF0gSG93IGZhciBpbnRvIHRoZSBhcnJheSB0byBzdGFydCByZWFkaW5nIHZhbHVlcyAodXNlZCBmb3IgaW50ZXJsZWF2aW5nIGRhdGEpXG4gICAgKlxuICAgICogQHJldHVybiB7UElYSS5HZW9tZXRyeX0gcmV0dXJucyBzZWxmLCB1c2VmdWwgZm9yIGNoYWluaW5nLlxuICAgICovXG4gICAgYWRkQXR0cmlidXRlKGlkLCBidWZmZXIsIHNpemUgPSBudWxsLCBub3JtYWxpemVkID0gZmFsc2UsIHR5cGUgPSBudWxsLCBzdHJpZGUgPSB1bmRlZmluZWQsIHN0YXJ0ID0gdW5kZWZpbmVkLCBpbnN0YW5jZSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoIWJ1ZmZlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgbXVzdCBwYXNzIGEgYnVmZmVyIHdoZW4gY3JlYXRpbmcgYW4gYXR0cmlidXRlJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY2hlY2sgaWYgdGhpcyBpcyBhIGJ1ZmZlciFcbiAgICAgICAgaWYgKCFidWZmZXIuZGF0YSkge1xuICAgICAgICAgICAgLy8gaXRzIGFuIGFycmF5IVxuICAgICAgICAgICAgaWYgKGJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICAgICAgYnVmZmVyID0gbmV3IEZsb2F0MzJBcnJheShidWZmZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnVmZmVyID0gbmV3IEJ1ZmZlcl8xLkJ1ZmZlcihidWZmZXIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpZHMgPSBpZC5zcGxpdCgnfCcpO1xuICAgICAgICBpZiAoaWRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRBdHRyaWJ1dGUoaWRzW2ldLCBidWZmZXIsIHNpemUsIG5vcm1hbGl6ZWQsIHR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJ1ZmZlckluZGV4ID0gdGhpcy5idWZmZXJzLmluZGV4T2YoYnVmZmVyKTtcbiAgICAgICAgaWYgKGJ1ZmZlckluZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgdGhpcy5idWZmZXJzLnB1c2goYnVmZmVyKTtcbiAgICAgICAgICAgIGJ1ZmZlckluZGV4ID0gdGhpcy5idWZmZXJzLmxlbmd0aCAtIDE7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hdHRyaWJ1dGVzW2lkXSA9IG5ldyBBdHRyaWJ1dGVfMS5BdHRyaWJ1dGUoYnVmZmVySW5kZXgsIHNpemUsIG5vcm1hbGl6ZWQsIHR5cGUsIHN0cmlkZSwgc3RhcnQsIGluc3RhbmNlKTtcbiAgICAgICAgLy8gYXNzdW1pbmcgdGhhdCBpZiB0aGVyZSBpcyBpbnN0YW5jZWQgZGF0YSB0aGVuIHRoaXMgd2lsbCBiZSBkcmF3biB3aXRoIGluc3RhbmNpbmchXG4gICAgICAgIHRoaXMuaW5zdGFuY2VkID0gdGhpcy5pbnN0YW5jZWQgfHwgaW5zdGFuY2U7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogcmV0dXJucyB0aGUgcmVxdWVzdGVkIGF0dHJpYnV0ZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGlkICB0aGUgbmFtZSBvZiB0aGUgYXR0cmlidXRlIHJlcXVpcmVkXG4gICAgICogQHJldHVybiB7UElYSS5BdHRyaWJ1dGV9IHRoZSBhdHRyaWJ1dGUgcmVxdWVzdGVkLlxuICAgICAqL1xuICAgIGdldEF0dHJpYnV0ZShpZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5idWZmZXJzW3RoaXMuYXR0cmlidXRlc1tpZF0uYnVmZmVyXTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICpcbiAgICAqIEFkZHMgYW4gaW5kZXggYnVmZmVyIHRvIHRoZSBnZW9tZXRyeVxuICAgICogVGhlIGluZGV4IGJ1ZmZlciBjb250YWlucyBpbnRlZ2VycywgdGhyZWUgZm9yIGVhY2ggdHJpYW5nbGUgaW4gdGhlIGdlb21ldHJ5LCB3aGljaCByZWZlcmVuY2UgdGhlIHZhcmlvdXMgYXR0cmlidXRlIGJ1ZmZlcnMgKHBvc2l0aW9uLCBjb2xvdXIsIFVWIGNvb3JkaW5hdGVzLCBvdGhlciBVViBjb29yZGluYXRlcywgbm9ybWFsLCDigKYpLiBUaGVyZSBpcyBvbmx5IE9ORSBpbmRleCBidWZmZXIuXG4gICAgKlxuICAgICogQHBhcmFtIHtQSVhJLkJ1ZmZlcn0gW2J1ZmZlcl0gdGhlIGJ1ZmZlciB0aGF0IGhvbGRzIHRoZSBkYXRhIG9mIHRoZSBpbmRleCBidWZmZXIuIFlvdSBjYW4gYWxzbyBwcm92aWRlIGFuIEFycmF5IGFuZCBhIGJ1ZmZlciB3aWxsIGJlIGNyZWF0ZWQgZnJvbSBpdC5cbiAgICAqIEByZXR1cm4ge1BJWEkuR2VvbWV0cnl9IHJldHVybnMgc2VsZiwgdXNlZnVsIGZvciBjaGFpbmluZy5cbiAgICAqL1xuICAgIGFkZEluZGV4KGJ1ZmZlcikge1xuICAgICAgICBpZiAoIWJ1ZmZlci5kYXRhKSB7XG4gICAgICAgICAgICAvLyBpdHMgYW4gYXJyYXkhXG4gICAgICAgICAgICBpZiAoYnVmZmVyIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgICAgICBidWZmZXIgPSBuZXcgVWludDE2QXJyYXkoYnVmZmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJ1ZmZlciA9IG5ldyBCdWZmZXJfMS5CdWZmZXIoYnVmZmVyKTtcbiAgICAgICAgfVxuICAgICAgICBidWZmZXIuaW5kZXggPSB0cnVlO1xuICAgICAgICB0aGlzLmluZGV4QnVmZmVyID0gYnVmZmVyO1xuICAgICAgICBpZiAodGhpcy5idWZmZXJzLmluZGV4T2YoYnVmZmVyKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVycy5wdXNoKGJ1ZmZlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiByZXR1cm5zIHRoZSBpbmRleCBidWZmZXJcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1BJWEkuQnVmZmVyfSB0aGUgaW5kZXggYnVmZmVyLlxuICAgICAqL1xuICAgIGdldEluZGV4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbmRleEJ1ZmZlcjtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIHRoaXMgZnVuY3Rpb24gbW9kaWZpZXMgdGhlIHN0cnVjdHVyZSBzbyB0aGF0IGFsbCBjdXJyZW50IGF0dHJpYnV0ZXMgYmVjb21lIGludGVybGVhdmVkIGludG8gYSBzaW5nbGUgYnVmZmVyXG4gICAgICogVGhpcyBjYW4gYmUgdXNlZnVsIGlmIHlvdXIgbW9kZWwgcmVtYWlucyBzdGF0aWMgYXMgaXQgb2ZmZXJzIGEgbGl0dGxlIHBlcmZvcm1hbmNlIGJvb3N0XG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtQSVhJLkdlb21ldHJ5fSByZXR1cm5zIHNlbGYsIHVzZWZ1bCBmb3IgY2hhaW5pbmcuXG4gICAgICovXG4gICAgaW50ZXJsZWF2ZSgpIHtcbiAgICAgICAgLy8gYSBzaW1wbGUgY2hlY2sgdG8gc2VlIGlmIGJ1ZmZlcnMgYXJlIGFscmVhZHkgaW50ZXJsZWF2ZWQuLlxuICAgICAgICBpZiAodGhpcy5idWZmZXJzLmxlbmd0aCA9PT0gMSB8fCAodGhpcy5idWZmZXJzLmxlbmd0aCA9PT0gMiAmJiB0aGlzLmluZGV4QnVmZmVyKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYXNzdW1lIGFscmVhZHkgdGhhdCBubyBidWZmZXJzIGFyZSBpbnRlcmxlYXZlZFxuICAgICAgICB2YXIgYXJyYXlzID0gW107XG4gICAgICAgIHZhciBzaXplcyA9IFtdO1xuICAgICAgICB2YXIgaW50ZXJsZWF2ZWRCdWZmZXIgPSBuZXcgQnVmZmVyXzEuQnVmZmVyKCk7XG4gICAgICAgIHZhciBpO1xuICAgICAgICBmb3IgKGkgaW4gdGhpcy5hdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICB2YXIgYXR0cmlidXRlID0gdGhpcy5hdHRyaWJ1dGVzW2ldO1xuICAgICAgICAgICAgdmFyIGJ1ZmZlciA9IHRoaXMuYnVmZmVyc1thdHRyaWJ1dGUuYnVmZmVyXTtcbiAgICAgICAgICAgIGFycmF5cy5wdXNoKGJ1ZmZlci5kYXRhKTtcbiAgICAgICAgICAgIHNpemVzLnB1c2goKGF0dHJpYnV0ZS5zaXplICogR2VvbWV0cnkuYnl0ZVNpemVNYXBbYXR0cmlidXRlLnR5cGVdKSAvIDQpO1xuICAgICAgICAgICAgYXR0cmlidXRlLmJ1ZmZlciA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaW50ZXJsZWF2ZWRCdWZmZXIuZGF0YSA9IEdlb21ldHJ5LmludGVybGVhdmVUeXBlZEFycmF5cyhhcnJheXMsIHNpemVzKTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMuYnVmZmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuYnVmZmVyc1tpXSAhPT0gdGhpcy5pbmRleEJ1ZmZlcikge1xuICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVyc1tpXS5kZXN0cm95KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5idWZmZXJzID0gW2ludGVybGVhdmVkQnVmZmVyXTtcbiAgICAgICAgaWYgKHRoaXMuaW5kZXhCdWZmZXIpIHtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVycy5wdXNoKHRoaXMuaW5kZXhCdWZmZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICA7XG4gICAgZ2V0U2l6ZSgpIHtcbiAgICAgICAgZm9yICh2YXIgaSBpbiB0aGlzLmF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgIHZhciBhdHRyaWJ1dGUgPSB0aGlzLmF0dHJpYnV0ZXNbaV07XG4gICAgICAgICAgICB2YXIgYnVmZmVyID0gdGhpcy5idWZmZXJzW2F0dHJpYnV0ZS5idWZmZXJdO1xuICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlci5kYXRhLmxlbmd0aCAvICgoYXR0cmlidXRlLnN0cmlkZSAvIDQpIHx8IGF0dHJpYnV0ZS5zaXplKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIGRpc3Bvc2VzIFdlYkdMIHJlc291cmNlcyB0aGF0IGFyZSBjb25uZWN0ZWQgdG8gdGhpcyBnZW9tZXRyeVxuICAgICAqL1xuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgIC8vIHRoaXMuZGlzcG9zZVJ1bm5lci5ydW4odGhpcywgZmFsc2UpO1xuICAgICAgICB0aGlzLmRpc3Bvc2VSdW5uZXIucnVuKHRoaXMsIGZhbHNlKTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIERlc3Ryb3lzIHRoZSBnZW9tZXRyeS5cbiAgICAgKi9cbiAgICBkZXN0cm95KG9wdGlvbnMgPSBudWxsKSB7XG4gICAgICAgIHRoaXMuZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLmJ1ZmZlcnMgPSBudWxsO1xuICAgICAgICB0aGlzLmluZGV4QnVmZmVyLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5hdHRyaWJ1dGVzID0gbnVsbDtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIHJldHVybnMgYSBjbG9uZSBvZiB0aGUgZ2VvbWV0cnlcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtQSVhJLkdlb21ldHJ5fSBhIG5ldyBjbG9uZSBvZiB0aGlzIGdlb21ldHJ5XG4gICAgICovXG4gICAgY2xvbmUoKSB7XG4gICAgICAgIHZhciBnZW9tZXRyeSA9IG5ldyBHZW9tZXRyeSgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYnVmZmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZ2VvbWV0cnkuYnVmZmVyc1tpXSA9IG5ldyBCdWZmZXJfMS5CdWZmZXIodGhpcy5idWZmZXJzW2ldLmRhdGEuc2xpY2UoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSQxIGluIHRoaXMuYXR0cmlidXRlcykge1xuICAgICAgICAgICAgdmFyIGF0dHJpYiA9IHRoaXMuYXR0cmlidXRlc1tpJDFdO1xuICAgICAgICAgICAgZ2VvbWV0cnkuYXR0cmlidXRlc1tpJDFdID0gbmV3IEF0dHJpYnV0ZV8xLkF0dHJpYnV0ZShhdHRyaWIuYnVmZmVyLCBhdHRyaWIuc2l6ZSwgYXR0cmliLm5vcm1hbGl6ZWQsIGF0dHJpYi50eXBlLCBhdHRyaWIuc3RyaWRlLCBhdHRyaWIuc3RhcnQsIGF0dHJpYi5pbnN0YW5jZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaW5kZXhCdWZmZXIpIHtcbiAgICAgICAgICAgIGdlb21ldHJ5LmluZGV4QnVmZmVyID0gZ2VvbWV0cnkuYnVmZmVyc1t0aGlzLmJ1ZmZlcnMuaW5kZXhPZih0aGlzLmluZGV4QnVmZmVyKV07XG4gICAgICAgICAgICBnZW9tZXRyeS5pbmRleEJ1ZmZlci5pbmRleCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdlb21ldHJ5O1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogbWVyZ2VzIGFuIGFycmF5IG9mIGdlb21ldHJpZXMgaW50byBhIG5ldyBzaW5nbGUgb25lXG4gICAgICogZ2VvbWV0cnkgYXR0cmlidXRlIHN0eWxlcyBtdXN0IG1hdGNoIGZvciB0aGlzIG9wZXJhdGlvbiB0byB3b3JrXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BJWEkuR2VvbWV0cnlbXX0gZ2VvbWV0cmllcyBhcnJheSBvZiBnZW9tZXRyaWVzIHRvIG1lcmdlXG4gICAgICogQHJldHVybnMge1BJWEkuR2VvbWV0cnl9IHNoaW55IG5ldyBnZW9tZXRyeSFcbiAgICAgKi9cbiAgICBzdGF0aWMgbWVyZ2UoZ2VvbWV0cmllcykge1xuICAgICAgICAvLyB0b2RvIGFkZCBhIGdlb21ldHJ5IGNoZWNrIVxuICAgICAgICAvLyBhbHNvIGEgc2l6ZSBjaGVjay4uIGNhbnQgYmUgdG9vIGJpZyFdXG4gICAgICAgIHZhciBnZW9tZXRyeU91dCA9IG5ldyBHZW9tZXRyeSgpO1xuICAgICAgICB2YXIgYXJyYXlzID0gW107XG4gICAgICAgIHZhciBzaXplcyA9IFtdO1xuICAgICAgICB2YXIgb2Zmc2V0cyA9IFtdO1xuICAgICAgICB2YXIgZ2VvbWV0cnk7XG4gICAgICAgIC8vIHBhc3Mgb25lLi4gZ2V0IHNpemVzLi5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBnZW9tZXRyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBnZW9tZXRyeSA9IGdlb21ldHJpZXNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGdlb21ldHJ5LmJ1ZmZlcnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBzaXplc1tqXSA9IHNpemVzW2pdIHx8IDA7XG4gICAgICAgICAgICAgICAgc2l6ZXNbal0gKz0gZ2VvbWV0cnkuYnVmZmVyc1tqXS5kYXRhLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBvZmZzZXRzW2pdID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBidWlsZCB0aGUgY29ycmVjdCBzaXplIGFycmF5cy4uXG4gICAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGdlb21ldHJ5LmJ1ZmZlcnMubGVuZ3RoOyBpJDErKykge1xuICAgICAgICAgICAgLy8gVE9ETyB0eXBlcyFcbiAgICAgICAgICAgIGFycmF5c1tpJDFdID0gbmV3IEdlb21ldHJ5Lm1hcCQxW0dlb21ldHJ5LmdldEJ1ZmZlclR5cGUoZ2VvbWV0cnkuYnVmZmVyc1tpJDFdLmRhdGEpXShzaXplc1tpJDFdKTtcbiAgICAgICAgICAgIGdlb21ldHJ5T3V0LmJ1ZmZlcnNbaSQxXSA9IG5ldyBCdWZmZXJfMS5CdWZmZXIoYXJyYXlzW2kkMV0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIHBhc3MgdG8gc2V0IGRhdGEuLlxuICAgICAgICBmb3IgKHZhciBpJDIgPSAwOyBpJDIgPCBnZW9tZXRyaWVzLmxlbmd0aDsgaSQyKyspIHtcbiAgICAgICAgICAgIGdlb21ldHJ5ID0gZ2VvbWV0cmllc1tpJDJdO1xuICAgICAgICAgICAgZm9yICh2YXIgaiQxID0gMDsgaiQxIDwgZ2VvbWV0cnkuYnVmZmVycy5sZW5ndGg7IGokMSsrKSB7XG4gICAgICAgICAgICAgICAgYXJyYXlzW2okMV0uc2V0KGdlb21ldHJ5LmJ1ZmZlcnNbaiQxXS5kYXRhLCBvZmZzZXRzW2okMV0pO1xuICAgICAgICAgICAgICAgIG9mZnNldHNbaiQxXSArPSBnZW9tZXRyeS5idWZmZXJzW2okMV0uZGF0YS5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZ2VvbWV0cnlPdXQuYXR0cmlidXRlcyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXM7XG4gICAgICAgIGlmIChnZW9tZXRyeS5pbmRleEJ1ZmZlcikge1xuICAgICAgICAgICAgZ2VvbWV0cnlPdXQuaW5kZXhCdWZmZXIgPSBnZW9tZXRyeU91dC5idWZmZXJzW2dlb21ldHJ5LmJ1ZmZlcnMuaW5kZXhPZihnZW9tZXRyeS5pbmRleEJ1ZmZlcildO1xuICAgICAgICAgICAgZ2VvbWV0cnlPdXQuaW5kZXhCdWZmZXIuaW5kZXggPSB0cnVlO1xuICAgICAgICAgICAgdmFyIG9mZnNldCA9IDA7XG4gICAgICAgICAgICB2YXIgc3RyaWRlID0gMDtcbiAgICAgICAgICAgIHZhciBvZmZzZXQyID0gMDtcbiAgICAgICAgICAgIHZhciBidWZmZXJJbmRleFRvQ291bnQgPSAwO1xuICAgICAgICAgICAgLy8gZ2V0IGEgYnVmZmVyXG4gICAgICAgICAgICBmb3IgKHZhciBpJDMgPSAwOyBpJDMgPCBnZW9tZXRyeS5idWZmZXJzLmxlbmd0aDsgaSQzKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoZ2VvbWV0cnkuYnVmZmVyc1tpJDNdICE9PSBnZW9tZXRyeS5pbmRleEJ1ZmZlcikge1xuICAgICAgICAgICAgICAgICAgICBidWZmZXJJbmRleFRvQ291bnQgPSBpJDM7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGZpZ3VyZSBvdXQgdGhlIHN0cmlkZSBvZiBvbmUgYnVmZmVyLi5cbiAgICAgICAgICAgIGZvciAodmFyIGkkNCBpbiBnZW9tZXRyeS5hdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGF0dHJpYnV0ZSA9IGdlb21ldHJ5LmF0dHJpYnV0ZXNbaSQ0XTtcbiAgICAgICAgICAgICAgICBpZiAoKGF0dHJpYnV0ZS5idWZmZXIgfCAwKSA9PT0gYnVmZmVySW5kZXhUb0NvdW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHN0cmlkZSArPSAoKGF0dHJpYnV0ZS5zaXplICogR2VvbWV0cnkuYnl0ZVNpemVNYXBbYXR0cmlidXRlLnR5cGVdKSAvIDQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHRpbWUgdG8gb2ZmIHNldCBhbGwgaW5kZXhlcy4uXG4gICAgICAgICAgICBmb3IgKHZhciBpJDUgPSAwOyBpJDUgPCBnZW9tZXRyaWVzLmxlbmd0aDsgaSQ1KyspIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXhCdWZmZXJEYXRhID0gZ2VvbWV0cmllc1tpJDVdLmluZGV4QnVmZmVyLmRhdGE7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiQyID0gMDsgaiQyIDwgaW5kZXhCdWZmZXJEYXRhLmxlbmd0aDsgaiQyKyspIHtcbiAgICAgICAgICAgICAgICAgICAgZ2VvbWV0cnlPdXQuaW5kZXhCdWZmZXIuZGF0YVtqJDIgKyBvZmZzZXQyXSArPSBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9mZnNldCArPSBnZW9tZXRyeS5idWZmZXJzW2J1ZmZlckluZGV4VG9Db3VudF0uZGF0YS5sZW5ndGggLyAoc3RyaWRlKTtcbiAgICAgICAgICAgICAgICBvZmZzZXQyICs9IGluZGV4QnVmZmVyRGF0YS5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdlb21ldHJ5T3V0O1xuICAgIH1cbiAgICA7XG4gICAgc3RhdGljIGdldEJ1ZmZlclR5cGUoYXJyYXkpIHtcbiAgICAgICAgaWYgKGFycmF5LkJZVEVTX1BFUl9FTEVNRU5UID09PSA0KSB7XG4gICAgICAgICAgICBpZiAoYXJyYXkgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ0Zsb2F0MzJBcnJheSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChhcnJheSBpbnN0YW5jZW9mIFVpbnQzMkFycmF5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdVaW50MzJBcnJheSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gJ0ludDMyQXJyYXknO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFycmF5LkJZVEVTX1BFUl9FTEVNRU5UID09PSAyKSB7XG4gICAgICAgICAgICBpZiAoYXJyYXkgaW5zdGFuY2VvZiBVaW50MTZBcnJheSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnVWludDE2QXJyYXknO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFycmF5LkJZVEVTX1BFUl9FTEVNRU5UID09PSAxKSB7XG4gICAgICAgICAgICBpZiAoYXJyYXkgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdVaW50OEFycmF5JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPIG1hcCBvdXQgdGhlIHJlc3Qgb2YgdGhlIGFycmF5IGVsZW1lbnRzIVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgc3RhdGljIGludGVybGVhdmVUeXBlZEFycmF5cyhhcnJheXMsIHNpemVzKSB7XG4gICAgICAgIHZhciBvdXRTaXplID0gMDtcbiAgICAgICAgdmFyIHN0cmlkZSA9IDA7XG4gICAgICAgIHZhciB2aWV3cyA9IHt9O1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgc3RyaWRlICs9IHNpemVzW2ldO1xuICAgICAgICAgICAgb3V0U2l6ZSArPSBhcnJheXNbaV0ubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHZhciBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIob3V0U2l6ZSAqIDQpO1xuICAgICAgICB2YXIgb3V0ID0gbnVsbDtcbiAgICAgICAgdmFyIGxpdHRsZU9mZnNldCA9IDA7XG4gICAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGFycmF5cy5sZW5ndGg7IGkkMSsrKSB7XG4gICAgICAgICAgICB2YXIgc2l6ZSA9IHNpemVzW2kkMV07XG4gICAgICAgICAgICB2YXIgYXJyYXkgPSBhcnJheXNbaSQxXTtcbiAgICAgICAgICAgIHZhciB0eXBlID0gR2VvbWV0cnkuZ2V0QnVmZmVyVHlwZShhcnJheSk7XG4gICAgICAgICAgICBpZiAoIXZpZXdzW3R5cGVdKSB7XG4gICAgICAgICAgICAgICAgdmlld3NbdHlwZV0gPSBuZXcgR2VvbWV0cnkubWFwW3R5cGVdKGJ1ZmZlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvdXQgPSB2aWV3c1t0eXBlXTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgYXJyYXkubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXhTdGFydCA9ICgoaiAvIHNpemUgfCAwKSAqIHN0cmlkZSkgKyBsaXR0bGVPZmZzZXQ7XG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gaiAlIHNpemU7XG4gICAgICAgICAgICAgICAgb3V0W2luZGV4U3RhcnQgKyBpbmRleF0gPSBhcnJheVtqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxpdHRsZU9mZnNldCArPSBzaXplO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRmxvYXQzMkFycmF5KGJ1ZmZlcik7XG4gICAgfVxufVxuLyogZXNsaW50LWRpc2FibGUgb2JqZWN0LXNob3J0aGFuZCAqL1xuR2VvbWV0cnkubWFwID0ge1xuICAgIEZsb2F0MzJBcnJheTogRmxvYXQzMkFycmF5LFxuICAgIFVpbnQzMkFycmF5OiBVaW50MzJBcnJheSxcbiAgICBJbnQzMkFycmF5OiBJbnQzMkFycmF5LFxuICAgIFVpbnQ4QXJyYXk6IFVpbnQ4QXJyYXksXG59O1xuR2VvbWV0cnkuVUlEJDEgPSAwO1xuLyogZXNsaW50LWRpc2FibGUgb2JqZWN0LXNob3J0aGFuZCAqL1xuR2VvbWV0cnkubWFwJDEgPSB7XG4gICAgRmxvYXQzMkFycmF5OiBGbG9hdDMyQXJyYXksXG4gICAgVWludDMyQXJyYXk6IFVpbnQzMkFycmF5LFxuICAgIEludDMyQXJyYXk6IEludDMyQXJyYXksXG4gICAgVWludDhBcnJheTogVWludDhBcnJheSxcbiAgICBVaW50MTZBcnJheTogVWludDE2QXJyYXksXG59O1xuR2VvbWV0cnkuYnl0ZVNpemVNYXAgPSB7IDUxMjY6IDQsIDUxMjM6IDIsIDUxMjE6IDEgfTtcbmV4cG9ydHMuR2VvbWV0cnkgPSBHZW9tZXRyeTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgU3lzdGVtXzEgPSByZXF1aXJlKFwiLi9TeXN0ZW1cIik7XG5jb25zdCBHTEJ1ZmZlcl8xID0gcmVxdWlyZShcIi4vR0xCdWZmZXJcIik7XG5jb25zdCBEaXNwbGF5U2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL0Rpc3BsYXlTZXR0aW5nc1wiKTtcbmNsYXNzIEdlb21ldHJ5U3lzdGVtIGV4dGVuZHMgU3lzdGVtXzEuU3lzdGVtIHtcbiAgICBjb25zdHJ1Y3RvcihyZW5kZXJlcikge1xuICAgICAgICBzdXBlcihyZW5kZXJlcik7XG4gICAgICAgIHRoaXMuX2FjdGl2ZUdlb21ldHJ5ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fYWN0aXZlVmFvID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGB0cnVlYCBpZiB3ZSBoYXMgYCpfdmVydGV4X2FycmF5X29iamVjdGAgZXh0ZW5zaW9uXG4gICAgICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XG4gICAgICAgICAqIEByZWFkb25seVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5oYXNWYW8gPSB0cnVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogYHRydWVgIGlmIGhhcyBgQU5HTEVfaW5zdGFuY2VkX2FycmF5c2AgZXh0ZW5zaW9uXG4gICAgICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XG4gICAgICAgICAqIEByZWFkb25seVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5oYXNJbnN0YW5jZSA9IHRydWU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGNhY2hlIG9mIGN1cnJlbnRseSBib3VuZCBidWZmZXIsXG4gICAgICAgICAqIGNvbnRhaW5zIG9ubHkgdHdvIG1lbWJlcnMgd2l0aCBrZXlzIEFSUkFZX0JVRkZFUiBhbmQgRUxFTUVOVF9BUlJBWV9CVUZGRVJcbiAgICAgICAgICogQG1lbWJlciB7T2JqZWN0LjxudW1iZXIsIFBJWEkuQnVmZmVyPn1cbiAgICAgICAgICogQHJlYWRvbmx5XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmJvdW5kQnVmZmVycyA9IHt9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2FjaGUgZm9yIGFsbCBnZW9tZXRyaWVzIGJ5IGlkLCB1c2VkIGluIGNhc2UgcmVuZGVyZXIgZ2V0cyBkZXN0cm95ZWQgb3IgZm9yIHByb2ZpbGluZ1xuICAgICAgICAgKiBAbWVtYmVyIHtvYmplY3R9XG4gICAgICAgICAqIEByZWFkb25seVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tYW5hZ2VkR2VvbWV0cmllcyA9IHt9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2FjaGUgZm9yIGFsbCBidWZmZXJzIGJ5IGlkLCB1c2VkIGluIGNhc2UgcmVuZGVyZXIgZ2V0cyBkZXN0cm95ZWQgb3IgZm9yIHByb2ZpbGluZ1xuICAgICAgICAgKiBAbWVtYmVyIHtvYmplY3R9XG4gICAgICAgICAqIEByZWFkb25seVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tYW5hZ2VkQnVmZmVycyA9IHt9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHVwIHRoZSByZW5kZXJlciBjb250ZXh0IGFuZCBuZWNlc3NhcnkgYnVmZmVycy5cbiAgICAgKi9cbiAgICBjb250ZXh0Q2hhbmdlKCkge1xuICAgICAgICB0aGlzLmRpc3Bvc2VBbGwodHJ1ZSk7XG4gICAgICAgIHZhciBnbCA9IHRoaXMuZ2wgPSB0aGlzLnJlbmRlcmVyLmdsO1xuICAgICAgICB0aGlzLkNPTlRFWFRfVUlEID0gdGhpcy5yZW5kZXJlci5DT05URVhUX1VJRDtcbiAgICAgICAgLy8gd2ViZ2wyXG4gICAgICAgIGlmICghZ2wuY3JlYXRlVmVydGV4QXJyYXkpIHtcbiAgICAgICAgICAgIC8vIHdlYmdsIDEhXG4gICAgICAgICAgICB2YXIgbmF0aXZlVmFvRXh0ZW5zaW9uID0gdGhpcy5yZW5kZXJlci5jb250ZXh0LmV4dGVuc2lvbnMudmVydGV4QXJyYXlPYmplY3Q7XG4gICAgICAgICAgICBpZiAoRGlzcGxheVNldHRpbmdzXzEuRGlzcGxheVNldHRpbmdzLlBSRUZFUl9FTlYgPT09IERpc3BsYXlTZXR0aW5nc18xLkRpc3BsYXlTZXR0aW5ncy5FTlYuV0VCR0xfTEVHQUNZKSB7XG4gICAgICAgICAgICAgICAgbmF0aXZlVmFvRXh0ZW5zaW9uID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuYXRpdmVWYW9FeHRlbnNpb24pIHtcbiAgICAgICAgICAgICAgICBnbC5jcmVhdGVWZXJ0ZXhBcnJheSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5hdGl2ZVZhb0V4dGVuc2lvbi5jcmVhdGVWZXJ0ZXhBcnJheU9FUygpOyB9O1xuICAgICAgICAgICAgICAgIGdsLmJpbmRWZXJ0ZXhBcnJheSA9IGZ1bmN0aW9uICh2YW8pIHsgcmV0dXJuIG5hdGl2ZVZhb0V4dGVuc2lvbi5iaW5kVmVydGV4QXJyYXlPRVModmFvKTsgfTtcbiAgICAgICAgICAgICAgICBnbC5kZWxldGVWZXJ0ZXhBcnJheSA9IGZ1bmN0aW9uICh2YW8pIHsgcmV0dXJuIG5hdGl2ZVZhb0V4dGVuc2lvbi5kZWxldGVWZXJ0ZXhBcnJheU9FUyh2YW8pOyB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oYXNWYW8gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBnbC5jcmVhdGVWZXJ0ZXhBcnJheSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZW1wdHlcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGdsLmJpbmRWZXJ0ZXhBcnJheSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZW1wdHlcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGdsLmRlbGV0ZVZlcnRleEFycmF5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBlbXB0eVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFnbC52ZXJ0ZXhBdHRyaWJEaXZpc29yKSB7XG4gICAgICAgICAgICB2YXIgaW5zdGFuY2VFeHQgPSBnbC5nZXRFeHRlbnNpb24oJ0FOR0xFX2luc3RhbmNlZF9hcnJheXMnKTtcbiAgICAgICAgICAgIGlmIChpbnN0YW5jZUV4dCkge1xuICAgICAgICAgICAgICAgIGdsLnZlcnRleEF0dHJpYkRpdmlzb3IgPSBmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gaW5zdGFuY2VFeHQudmVydGV4QXR0cmliRGl2aXNvckFOR0xFKGEsIGIpOyB9O1xuICAgICAgICAgICAgICAgIGdsLmRyYXdFbGVtZW50c0luc3RhbmNlZCA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkLCBlKSB7IHJldHVybiBpbnN0YW5jZUV4dC5kcmF3RWxlbWVudHNJbnN0YW5jZWRBTkdMRShhLCBiLCBjLCBkLCBlKTsgfTtcbiAgICAgICAgICAgICAgICBnbC5kcmF3QXJyYXlzSW5zdGFuY2VkID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHsgcmV0dXJuIGluc3RhbmNlRXh0LmRyYXdBcnJheXNJbnN0YW5jZWRBTkdMRShhLCBiLCBjLCBkKTsgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuaGFzSW5zdGFuY2UgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogQmluZHMgZ2VvbWV0cnkgc28gdGhhdCBpcyBjYW4gYmUgZHJhd24uIENyZWF0aW5nIGEgVmFvIGlmIHJlcXVpcmVkXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBwYXJhbSB7UElYSS5HZW9tZXRyeX0gZ2VvbWV0cnkgaW5zdGFuY2Ugb2YgZ2VvbWV0cnkgdG8gYmluZFxuICAgICAqIEBwYXJhbSB7UElYSS5TaGFkZXJ9IHNoYWRlciBpbnN0YW5jZSBvZiBzaGFkZXIgdG8gYmluZFxuICAgICAqL1xuICAgIGJpbmQoZ2VvbWV0cnksIHNoYWRlciA9IG51bGwpIHtcbiAgICAgICAgc2hhZGVyID0gc2hhZGVyIHx8IHRoaXMucmVuZGVyZXIuc2hhZGVyLnNoYWRlcjtcbiAgICAgICAgdmFyIHJlZiA9IHRoaXM7XG4gICAgICAgIHZhciBnbCA9IHJlZi5nbDtcbiAgICAgICAgLy8gbm90IHN1cmUgdGhlIGJlc3Qgd2F5IHRvIGFkZHJlc3MgdGhpcy4uXG4gICAgICAgIC8vIGN1cnJlbnRseSBkaWZmZXJlbnQgc2hhZGVycyByZXF1aXJlIGRpZmZlcmVudCBWQU9zIGZvciB0aGUgc2FtZSBnZW9tZXRyeVxuICAgICAgICAvLyBTdGlsbCBtdWxsaW5nIG92ZXIgdGhlIGJlc3Qgd2F5IHRvIHNvbHZlIHRoaXMgb25lLi5cbiAgICAgICAgLy8gd2lsbCBsaWtlbHkgbmVlZCB0byBtb2RpZnkgdGhlIHNoYWRlciBhdHRyaWJ1dGUgbG9jYXRpb25zIGF0IHJ1biB0aW1lIVxuICAgICAgICB2YXIgdmFvcyA9IGdlb21ldHJ5LmdsVmVydGV4QXJyYXlPYmplY3RzW3RoaXMuQ09OVEVYVF9VSURdO1xuICAgICAgICBpZiAoIXZhb3MpIHtcbiAgICAgICAgICAgIHRoaXMubWFuYWdlZEdlb21ldHJpZXNbZ2VvbWV0cnkuaWRdID0gZ2VvbWV0cnk7XG4gICAgICAgICAgICAvLyBnZW9tZXRyeS5kaXNwb3NlUnVubmVyLmFkZCh0aGlzKTtcbiAgICAgICAgICAgIGdlb21ldHJ5LmdsVmVydGV4QXJyYXlPYmplY3RzW3RoaXMuQ09OVEVYVF9VSURdID0gdmFvcyA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIHZhciB2YW8gPSB2YW9zW3NoYWRlci5wcm9ncmFtLmlkXSB8fCB0aGlzLmluaXRHZW9tZXRyeVZhbyhnZW9tZXRyeSwgc2hhZGVyLnByb2dyYW0pO1xuICAgICAgICB0aGlzLl9hY3RpdmVHZW9tZXRyeSA9IGdlb21ldHJ5O1xuICAgICAgICBpZiAodGhpcy5fYWN0aXZlVmFvICE9PSB2YW8pIHtcbiAgICAgICAgICAgIHRoaXMuX2FjdGl2ZVZhbyA9IHZhbztcbiAgICAgICAgICAgIGlmICh0aGlzLmhhc1Zhbykge1xuICAgICAgICAgICAgICAgIGdsLmJpbmRWZXJ0ZXhBcnJheSh2YW8pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hY3RpdmF0ZVZhbyhnZW9tZXRyeSwgc2hhZGVyLnByb2dyYW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFRPRE8gLSBvcHRpbWlzZSBsYXRlciFcbiAgICAgICAgLy8gZG9uJ3QgbmVlZCB0byBsb29wIHRocm91Z2ggaWYgbm90aGluZyBjaGFuZ2VkIVxuICAgICAgICAvLyBtYXliZSBsb29rIHRvIGFkZCBhbiAnYXV0b3VwZGF0ZScgdG8gZ2VvbWV0cnk/XG4gICAgICAgIHRoaXMudXBkYXRlQnVmZmVycygpO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogUmVzZXQgYW5kIHVuYmluZCBhbnkgYWN0aXZlIFZBTyBhbmQgZ2VvbWV0cnlcbiAgICAgKi9cbiAgICByZXNldCgpIHtcbiAgICAgICAgdGhpcy51bmJpbmQoKTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBidWZmZXJzXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHVwZGF0ZUJ1ZmZlcnMoKSB7XG4gICAgICAgIHZhciBnZW9tZXRyeSA9IHRoaXMuX2FjdGl2ZUdlb21ldHJ5O1xuICAgICAgICB2YXIgcmVmID0gdGhpcztcbiAgICAgICAgdmFyIGdsID0gcmVmLmdsO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdlb21ldHJ5LmJ1ZmZlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBidWZmZXIgPSBnZW9tZXRyeS5idWZmZXJzW2ldO1xuICAgICAgICAgICAgdmFyIGdsQnVmZmVyID0gYnVmZmVyLl9nbEJ1ZmZlcnNbdGhpcy5DT05URVhUX1VJRF07XG4gICAgICAgICAgICBpZiAoYnVmZmVyLl91cGRhdGVJRCAhPT0gZ2xCdWZmZXIudXBkYXRlSUQpIHtcbiAgICAgICAgICAgICAgICBnbEJ1ZmZlci51cGRhdGVJRCA9IGJ1ZmZlci5fdXBkYXRlSUQ7XG4gICAgICAgICAgICAgICAgLy8gVE9ETyBjYW4gY2FjaGUgdGhpcyBvbiBidWZmZXIhIG1heWJlIGFkZGVkIGEgZ2V0dGVyIC8gc2V0dGVyP1xuICAgICAgICAgICAgICAgIHZhciB0eXBlID0gYnVmZmVyLmluZGV4ID8gZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIgOiBnbC5BUlJBWV9CVUZGRVI7XG4gICAgICAgICAgICAgICAgLy8gVE9ETyB0aGlzIGNvdWxkIGNoYW5nZSBpZiB0aGUgVkFPIGNoYW5nZXMuLi5cbiAgICAgICAgICAgICAgICAvLyBuZWVkIHRvIGNvbWUgdXAgd2l0aCBhIGJldHRlciB3YXkgdG8gY2FjaGUuLlxuICAgICAgICAgICAgICAgIC8vIGlmICh0aGlzLmJvdW5kQnVmZmVyc1t0eXBlXSAhPT0gZ2xCdWZmZXIpXG4gICAgICAgICAgICAgICAgLy8ge1xuICAgICAgICAgICAgICAgIC8vIHRoaXMuYm91bmRCdWZmZXJzW3R5cGVdID0gZ2xCdWZmZXI7XG4gICAgICAgICAgICAgICAgZ2wuYmluZEJ1ZmZlcih0eXBlLCBnbEJ1ZmZlci5idWZmZXIpO1xuICAgICAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9ib3VuZEJ1ZmZlciA9IGdsQnVmZmVyO1xuICAgICAgICAgICAgICAgIGlmIChnbEJ1ZmZlci5ieXRlTGVuZ3RoID49IGJ1ZmZlci5kYXRhLmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gb2Zmc2V0IGlzIGFsd2F5cyB6ZXJvIGZvciBub3chXG4gICAgICAgICAgICAgICAgICAgIGdsLmJ1ZmZlclN1YkRhdGEodHlwZSwgMCwgYnVmZmVyLmRhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRyYXdUeXBlID0gYnVmZmVyLnN0YXRpYyA/IGdsLlNUQVRJQ19EUkFXIDogZ2wuRFlOQU1JQ19EUkFXO1xuICAgICAgICAgICAgICAgICAgICBnbEJ1ZmZlci5ieXRlTGVuZ3RoID0gYnVmZmVyLmRhdGEuYnl0ZUxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgZ2wuYnVmZmVyRGF0YSh0eXBlLCBidWZmZXIuZGF0YSwgZHJhd1R5cGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogQ2hlY2sgY29tcGFiaWxpdHkgYmV0d2VlbiBhIGdlb21ldHJ5IGFuZCBhIHByb2dyYW1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHBhcmFtIHtQSVhJLkdlb21ldHJ5fSBnZW9tZXRyeSAtIEdlb21ldHJ5IGluc3RhbmNlXG4gICAgICogQHBhcmFtIHtQSVhJLlByb2dyYW19IHByb2dyYW0gLSBQcm9ncmFtIGluc3RhbmNlXG4gICAgICovXG4gICAgY2hlY2tDb21wYXRpYmlsaXR5KGdlb21ldHJ5LCBwcm9ncmFtKSB7XG4gICAgICAgIC8vIGdlb21ldHJ5IG11c3QgaGF2ZSBhdCBsZWFzdCBhbGwgdGhlIGF0dHJpYnV0ZXMgdGhhdCB0aGUgc2hhZGVyIHJlcXVpcmVzLlxuICAgICAgICB2YXIgZ2VvbWV0cnlBdHRyaWJ1dGVzID0gZ2VvbWV0cnkuYXR0cmlidXRlcztcbiAgICAgICAgdmFyIHNoYWRlckF0dHJpYnV0ZXMgPSBwcm9ncmFtLmF0dHJpYnV0ZURhdGE7XG4gICAgICAgIGZvciAodmFyIGogaW4gc2hhZGVyQXR0cmlidXRlcykge1xuICAgICAgICAgICAgaWYgKCFnZW9tZXRyeUF0dHJpYnV0ZXNbal0pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKFwic2hhZGVyIGFuZCBnZW9tZXRyeSBpbmNvbXBhdGlibGUsIGdlb21ldHJ5IG1pc3NpbmcgdGhlIFxcXCJcIiArIGogKyBcIlxcXCIgYXR0cmlidXRlXCIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogVGFrZXMgYSBnZW9tZXRyeSBhbmQgcHJvZ3JhbSBhbmQgZ2VuZXJhdGVzIGEgdW5pcXVlIHNpZ25hdHVyZSBmb3IgdGhlbS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UElYSS5HZW9tZXRyeX0gZ2VvbWV0cnkgdG8gZ2V0IHNpZ25hdHVyZSBmcm9tXG4gICAgICogQHBhcmFtIHtQSVhJLlByb2dyYW19IHByb2dyYW0gdG8gdGVzdCBnZW9tZXRyeSBhZ2FpbnN0XG4gICAgICogQHJldHVybnMge1N0cmluZ30gVW5pcXVlIHNpZ25hdHVyZSBvZiB0aGUgZ2VvbWV0cnkgYW5kIHByb2dyYW1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgZ2V0U2lnbmF0dXJlKGdlb21ldHJ5LCBwcm9ncmFtKSB7XG4gICAgICAgIHZhciBhdHRyaWJzID0gZ2VvbWV0cnkuYXR0cmlidXRlcztcbiAgICAgICAgdmFyIHNoYWRlckF0dHJpYnV0ZXMgPSBwcm9ncmFtLmF0dHJpYnV0ZURhdGE7XG4gICAgICAgIHZhciBzdHJpbmdzID0gWydnJywgZ2VvbWV0cnkuaWRdO1xuICAgICAgICBmb3IgKHZhciBpIGluIGF0dHJpYnMpIHtcbiAgICAgICAgICAgIGlmIChzaGFkZXJBdHRyaWJ1dGVzW2ldKSB7XG4gICAgICAgICAgICAgICAgc3RyaW5ncy5wdXNoKGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHJpbmdzLmpvaW4oJy0nKTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgb3IgZ2V0cyBWYW8gd2l0aCB0aGUgc2FtZSBzdHJ1Y3R1cmUgYXMgdGhlIGdlb21ldHJ5IGFuZCBzdG9yZXMgaXQgb24gdGhlIGdlb21ldHJ5LlxuICAgICAqIElmIHZhbyBpcyBjcmVhdGVkLCBpdCBpcyBib3VuZCBhdXRvbWF0aWNhbGx5LlxuICAgICAqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBwYXJhbSB7UElYSS5HZW9tZXRyeX0gZ2VvbWV0cnkgLSBJbnN0YW5jZSBvZiBnZW9tZXRyeSB0byB0byBnZW5lcmF0ZSBWYW8gZm9yXG4gICAgICogQHBhcmFtIHtQSVhJLlByb2dyYW19IHByb2dyYW0gLSBJbnN0YW5jZSBvZiBwcm9ncmFtXG4gICAgICovXG4gICAgaW5pdEdlb21ldHJ5VmFvKGdlb21ldHJ5LCBwcm9ncmFtKSB7XG4gICAgICAgIHRoaXMuY2hlY2tDb21wYXRpYmlsaXR5KGdlb21ldHJ5LCBwcm9ncmFtKTtcbiAgICAgICAgdmFyIGdsID0gdGhpcy5nbDtcbiAgICAgICAgdmFyIENPTlRFWFRfVUlEID0gdGhpcy5DT05URVhUX1VJRDtcbiAgICAgICAgdmFyIHNpZ25hdHVyZSA9IHRoaXMuZ2V0U2lnbmF0dXJlKGdlb21ldHJ5LCBwcm9ncmFtKTtcbiAgICAgICAgdmFyIHZhb09iamVjdEhhc2ggPSBnZW9tZXRyeS5nbFZlcnRleEFycmF5T2JqZWN0c1t0aGlzLkNPTlRFWFRfVUlEXTtcbiAgICAgICAgdmFyIHZhbyA9IHZhb09iamVjdEhhc2hbc2lnbmF0dXJlXTtcbiAgICAgICAgaWYgKHZhbykge1xuICAgICAgICAgICAgLy8gdGhpcyB3aWxsIGdpdmUgdXMgZWFzeSBhY2Nlc3MgdG8gdGhlIHZhb1xuICAgICAgICAgICAgdmFvT2JqZWN0SGFzaFtwcm9ncmFtLmlkXSA9IHZhbztcbiAgICAgICAgICAgIHJldHVybiB2YW87XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJ1ZmZlcnMgPSBnZW9tZXRyeS5idWZmZXJzO1xuICAgICAgICB2YXIgYXR0cmlidXRlcyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXM7XG4gICAgICAgIHZhciB0ZW1wU3RyaWRlID0ge307XG4gICAgICAgIHZhciB0ZW1wU3RhcnQgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgaiBpbiBidWZmZXJzKSB7XG4gICAgICAgICAgICB0ZW1wU3RyaWRlW2pdID0gMDtcbiAgICAgICAgICAgIHRlbXBTdGFydFtqXSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaiQxIGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgIGlmICghYXR0cmlidXRlc1tqJDFdLnNpemUgJiYgcHJvZ3JhbS5hdHRyaWJ1dGVEYXRhW2okMV0pIHtcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzW2okMV0uc2l6ZSA9IHByb2dyYW0uYXR0cmlidXRlRGF0YVtqJDFdLnNpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghYXR0cmlidXRlc1tqJDFdLnNpemUpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oKFwiUElYSSBHZW9tZXRyeSBhdHRyaWJ1dGUgJ1wiICsgaiQxICsgXCInIHNpemUgY2Fubm90IGJlIGRldGVybWluZWQgKGxpa2VseSB0aGUgYm91bmQgc2hhZGVyIGRvZXMgbm90IGhhdmUgdGhlIGF0dHJpYnV0ZSlcIikpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0ZW1wU3RyaWRlW2F0dHJpYnV0ZXNbaiQxXS5idWZmZXJdICs9IGF0dHJpYnV0ZXNbaiQxXS5zaXplICogR2VvbWV0cnlTeXN0ZW0uYnl0ZVNpemVNYXAkMVthdHRyaWJ1dGVzW2okMV0udHlwZV07XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaiQyIGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgIHZhciBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzW2okMl07XG4gICAgICAgICAgICB2YXIgYXR0cmliU2l6ZSA9IGF0dHJpYnV0ZS5zaXplO1xuICAgICAgICAgICAgaWYgKGF0dHJpYnV0ZS5zdHJpZGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGlmICh0ZW1wU3RyaWRlW2F0dHJpYnV0ZS5idWZmZXJdID09PSBhdHRyaWJTaXplICogR2VvbWV0cnlTeXN0ZW0uYnl0ZVNpemVNYXAkMVthdHRyaWJ1dGUudHlwZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlLnN0cmlkZSA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGUuc3RyaWRlID0gdGVtcFN0cmlkZVthdHRyaWJ1dGUuYnVmZmVyXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYXR0cmlidXRlLnN0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGUuc3RhcnQgPSB0ZW1wU3RhcnRbYXR0cmlidXRlLmJ1ZmZlcl07XG4gICAgICAgICAgICAgICAgdGVtcFN0YXJ0W2F0dHJpYnV0ZS5idWZmZXJdICs9IGF0dHJpYlNpemUgKiBHZW9tZXRyeVN5c3RlbS5ieXRlU2l6ZU1hcCQxW2F0dHJpYnV0ZS50eXBlXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YW8gPSBnbC5jcmVhdGVWZXJ0ZXhBcnJheSgpO1xuICAgICAgICBnbC5iaW5kVmVydGV4QXJyYXkodmFvKTtcbiAgICAgICAgLy8gZmlyc3QgdXBkYXRlIC0gYW5kIGNyZWF0ZSB0aGUgYnVmZmVycyFcbiAgICAgICAgLy8gb25seSBjcmVhdGUgYSBnbCBidWZmZXIgaWYgaXQgYWN0dWFsbHkgZ2V0c1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ1ZmZlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBidWZmZXIgPSBidWZmZXJzW2ldO1xuICAgICAgICAgICAgaWYgKCFidWZmZXIuX2dsQnVmZmVyc1tDT05URVhUX1VJRF0pIHtcbiAgICAgICAgICAgICAgICBidWZmZXIuX2dsQnVmZmVyc1tDT05URVhUX1VJRF0gPSBuZXcgR0xCdWZmZXJfMS5HTEJ1ZmZlcihnbC5jcmVhdGVCdWZmZXIoKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5tYW5hZ2VkQnVmZmVyc1tidWZmZXIuaWRdID0gYnVmZmVyO1xuICAgICAgICAgICAgICAgIC8vIGJ1ZmZlci5kaXNwb3NlUnVubmVyLmFkZCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJ1ZmZlci5fZ2xCdWZmZXJzW0NPTlRFWFRfVUlEXS5yZWZDb3VudCsrO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRPRE8gLSBtYXliZSBtYWtlIHRoaXMgYSBkYXRhIG9iamVjdD9cbiAgICAgICAgLy8gbGV0cyB3YWl0IHRvIHNlZSBpZiB3ZSBuZWVkIHRvIGZpcnN0IVxuICAgICAgICB0aGlzLmFjdGl2YXRlVmFvKGdlb21ldHJ5LCBwcm9ncmFtKTtcbiAgICAgICAgdGhpcy5fYWN0aXZlVmFvID0gdmFvO1xuICAgICAgICAvLyBhZGQgaXQgdG8gdGhlIGNhY2hlIVxuICAgICAgICB2YW9PYmplY3RIYXNoW3Byb2dyYW0uaWRdID0gdmFvO1xuICAgICAgICB2YW9PYmplY3RIYXNoW3NpZ25hdHVyZV0gPSB2YW87XG4gICAgICAgIHJldHVybiB2YW87XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBEaXNwb3NlcyBidWZmZXJcbiAgICAgKiBAcGFyYW0ge1BJWEkuQnVmZmVyfSBidWZmZXIgYnVmZmVyIHdpdGggZGF0YVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2NvbnRleHRMb3N0PWZhbHNlXSBJZiBjb250ZXh0IHdhcyBsb3N0LCB3ZSBzdXBwcmVzcyBkZWxldGVWZXJ0ZXhBcnJheVxuICAgICAqL1xuICAgIGRpc3Bvc2VCdWZmZXIoYnVmZmVyLCBjb250ZXh0TG9zdCkge1xuICAgICAgICBpZiAoIXRoaXMubWFuYWdlZEJ1ZmZlcnNbYnVmZmVyLmlkXSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZSB0aGlzLm1hbmFnZWRCdWZmZXJzW2J1ZmZlci5pZF07XG4gICAgICAgIHZhciBnbEJ1ZmZlciA9IGJ1ZmZlci5fZ2xCdWZmZXJzW3RoaXMuQ09OVEVYVF9VSURdO1xuICAgICAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuICAgICAgICAvLyBidWZmZXIuZGlzcG9zZVJ1bm5lci5yZW1vdmUodGhpcyk7XG4gICAgICAgIGlmICghZ2xCdWZmZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNvbnRleHRMb3N0KSB7XG4gICAgICAgICAgICBnbC5kZWxldGVCdWZmZXIoZ2xCdWZmZXIuYnVmZmVyKTtcbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgYnVmZmVyLl9nbEJ1ZmZlcnNbdGhpcy5DT05URVhUX1VJRF07XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBEaXNwb3NlcyBnZW9tZXRyeVxuICAgICAqIEBwYXJhbSB7UElYSS5HZW9tZXRyeX0gZ2VvbWV0cnkgR2VvbWV0cnkgd2l0aCBidWZmZXJzLiBPbmx5IFZBTyB3aWxsIGJlIGRpc3Bvc2VkXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbY29udGV4dExvc3Q9ZmFsc2VdIElmIGNvbnRleHQgd2FzIGxvc3QsIHdlIHN1cHByZXNzIGRlbGV0ZVZlcnRleEFycmF5XG4gICAgICovXG4gICAgZGlzcG9zZUdlb21ldHJ5KGdlb21ldHJ5LCBjb250ZXh0TG9zdCkge1xuICAgICAgICBpZiAoIXRoaXMubWFuYWdlZEdlb21ldHJpZXNbZ2VvbWV0cnkuaWRdKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZGVsZXRlIHRoaXMubWFuYWdlZEdlb21ldHJpZXNbZ2VvbWV0cnkuaWRdO1xuICAgICAgICB2YXIgdmFvcyA9IGdlb21ldHJ5LmdsVmVydGV4QXJyYXlPYmplY3RzW3RoaXMuQ09OVEVYVF9VSURdO1xuICAgICAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuICAgICAgICB2YXIgYnVmZmVycyA9IGdlb21ldHJ5LmJ1ZmZlcnM7XG4gICAgICAgIGdlb21ldHJ5LmRpc3Bvc2VSdW5uZXIucmVtb3ZlKHRoaXMpO1xuICAgICAgICBpZiAoIXZhb3MpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ1ZmZlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBidWYgPSBidWZmZXJzW2ldLl9nbEJ1ZmZlcnNbdGhpcy5DT05URVhUX1VJRF07XG4gICAgICAgICAgICBidWYucmVmQ291bnQtLTtcbiAgICAgICAgICAgIGlmIChidWYucmVmQ291bnQgPT09IDAgJiYgIWNvbnRleHRMb3N0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwb3NlQnVmZmVyKGJ1ZmZlcnNbaV0sIGNvbnRleHRMb3N0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNvbnRleHRMb3N0KSB7XG4gICAgICAgICAgICBmb3IgKHZhciB2YW9JZCBpbiB2YW9zKSB7XG4gICAgICAgICAgICAgICAgLy8gZGVsZXRlIG9ubHkgc2lnbmF0dXJlcywgZXZlcnl0aGluZyBlbHNlIGFyZSBjb3BpZXNcbiAgICAgICAgICAgICAgICBpZiAodmFvSWRbMF0gPT09ICdnJykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmFvID0gdmFvc1t2YW9JZF07XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9hY3RpdmVWYW8gPT09IHZhbykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51bmJpbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBnbC5kZWxldGVWZXJ0ZXhBcnJheSh2YW8pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgZ2VvbWV0cnkuZ2xWZXJ0ZXhBcnJheU9iamVjdHNbdGhpcy5DT05URVhUX1VJRF07XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBkaXNwb3NlIGFsbCBXZWJHTCByZXNvdXJjZXMgb2YgYWxsIG1hbmFnZWQgZ2VvbWV0cmllcyBhbmQgYnVmZmVyc1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2NvbnRleHRMb3N0PWZhbHNlXSBJZiBjb250ZXh0IHdhcyBsb3N0LCB3ZSBzdXBwcmVzcyBgZ2wuZGVsZXRlYCBjYWxsc1xuICAgICAqL1xuICAgIGRpc3Bvc2VBbGwoY29udGV4dExvc3QpIHtcbiAgICAgICAgdmFyIGFsbCA9IE9iamVjdC5rZXlzKHRoaXMubWFuYWdlZEdlb21ldHJpZXMpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFsbC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5kaXNwb3NlR2VvbWV0cnkodGhpcy5tYW5hZ2VkR2VvbWV0cmllc1thbGxbaV1dLCBjb250ZXh0TG9zdCk7XG4gICAgICAgIH1cbiAgICAgICAgYWxsID0gT2JqZWN0LmtleXModGhpcy5tYW5hZ2VkQnVmZmVycyk7XG4gICAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGFsbC5sZW5ndGg7IGkkMSsrKSB7XG4gICAgICAgICAgICB0aGlzLmRpc3Bvc2VCdWZmZXIodGhpcy5tYW5hZ2VkQnVmZmVyc1thbGxbaSQxXV0sIGNvbnRleHRMb3N0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogQWN0aXZhdGUgdmVydGV4IGFycmF5IG9iamVjdFxuICAgICAqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBwYXJhbSB7UElYSS5HZW9tZXRyeX0gZ2VvbWV0cnkgLSBHZW9tZXRyeSBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7UElYSS5Qcm9ncmFtfSBwcm9ncmFtIC0gU2hhZGVyIHByb2dyYW0gaW5zdGFuY2VcbiAgICAgKi9cbiAgICBhY3RpdmF0ZVZhbyhnZW9tZXRyeSwgcHJvZ3JhbSkge1xuICAgICAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuICAgICAgICB2YXIgQ09OVEVYVF9VSUQgPSB0aGlzLkNPTlRFWFRfVUlEO1xuICAgICAgICB2YXIgYnVmZmVycyA9IGdlb21ldHJ5LmJ1ZmZlcnM7XG4gICAgICAgIHZhciBhdHRyaWJ1dGVzID0gZ2VvbWV0cnkuYXR0cmlidXRlcztcbiAgICAgICAgaWYgKGdlb21ldHJ5LmluZGV4QnVmZmVyKSB7XG4gICAgICAgICAgICAvLyBmaXJzdCB1cGRhdGUgdGhlIGluZGV4IGJ1ZmZlciBpZiB3ZSBoYXZlIG9uZS4uXG4gICAgICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBnZW9tZXRyeS5pbmRleEJ1ZmZlci5fZ2xCdWZmZXJzW0NPTlRFWFRfVUlEXS5idWZmZXIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsYXN0QnVmZmVyID0gbnVsbDtcbiAgICAgICAgLy8gYWRkIGEgbmV3IG9uZSFcbiAgICAgICAgZm9yICh2YXIgaiBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICB2YXIgYXR0cmlidXRlID0gYXR0cmlidXRlc1tqXTtcbiAgICAgICAgICAgIHZhciBidWZmZXIgPSBidWZmZXJzW2F0dHJpYnV0ZS5idWZmZXJdO1xuICAgICAgICAgICAgdmFyIGdsQnVmZmVyID0gYnVmZmVyLl9nbEJ1ZmZlcnNbQ09OVEVYVF9VSURdO1xuICAgICAgICAgICAgaWYgKHByb2dyYW0uYXR0cmlidXRlRGF0YVtqXSkge1xuICAgICAgICAgICAgICAgIGlmIChsYXN0QnVmZmVyICE9PSBnbEJ1ZmZlcikge1xuICAgICAgICAgICAgICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgZ2xCdWZmZXIuYnVmZmVyKTtcbiAgICAgICAgICAgICAgICAgICAgbGFzdEJ1ZmZlciA9IGdsQnVmZmVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgbG9jYXRpb24gPSBwcm9ncmFtLmF0dHJpYnV0ZURhdGFbal0ubG9jYXRpb247XG4gICAgICAgICAgICAgICAgLy8gVE9ETyBpbnRyb2R1Y2Ugc3RhdGUgYWdhaW5cbiAgICAgICAgICAgICAgICAvLyB3ZSBjYW4gb3B0aW1pc2UgdGhpcyBmb3Igb2xkZXIgZGV2aWNlcyB0aGF0IGhhdmUgbm8gVkFPc1xuICAgICAgICAgICAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGxvY2F0aW9uKTtcbiAgICAgICAgICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKGxvY2F0aW9uLCBhdHRyaWJ1dGUuc2l6ZSwgYXR0cmlidXRlLnR5cGUgfHwgZ2wuRkxPQVQsIGF0dHJpYnV0ZS5ub3JtYWxpemVkLCBhdHRyaWJ1dGUuc3RyaWRlLCBhdHRyaWJ1dGUuc3RhcnQpO1xuICAgICAgICAgICAgICAgIGlmIChhdHRyaWJ1dGUuaW5zdGFuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyBjYWxjdWxhdGUgaW5zdGFuY2UgY291bnQgYmFzZWQgb2YgdGhpcy4uLlxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5oYXNJbnN0YW5jZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2wudmVydGV4QXR0cmliRGl2aXNvcihsb2NhdGlvbiwgMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dlb21ldHJ5IGVycm9yLCBHUFUgSW5zdGFuY2luZyBpcyBub3Qgc3VwcG9ydGVkIG9uIHRoaXMgZGV2aWNlJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIERyYXcgdGhlIGdlb21ldHJ5XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdHlwZSAtIHRoZSB0eXBlIHByaW1pdGl2ZSB0byByZW5kZXJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3NpemVdIC0gdGhlIG51bWJlciBvZiBlbGVtZW50cyB0byBiZSByZW5kZXJlZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbc3RhcnRdIC0gU3RhcnRpbmcgaW5kZXhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2luc3RhbmNlQ291bnRdIC0gdGhlIG51bWJlciBvZiBpbnN0YW5jZXMgb2YgdGhlIHNldCBvZiBlbGVtZW50cyB0byBleGVjdXRlXG4gICAgICovXG4gICAgZHJhdyh0eXBlLCBzaXplID0gLTEsIHN0YXJ0ID0gMCwgaW5zdGFuY2VDb3VudCA9IDEpIHtcbiAgICAgICAgdmFyIHJlZiA9IHRoaXM7XG4gICAgICAgIHZhciBnbCA9IHJlZi5nbDtcbiAgICAgICAgdmFyIGdlb21ldHJ5ID0gdGhpcy5fYWN0aXZlR2VvbWV0cnk7XG4gICAgICAgIC8vIFRPRE8uLiB0aGlzIHNob3VsZCBub3QgY2hhbmdlIHNvIG1heWJlIGNhY2hlIHRoZSBmdW5jdGlvbj9cbiAgICAgICAgaWYgKHNpemUgPCAwKSB7XG4gICAgICAgICAgICBzaXplID0gZ2VvbWV0cnkuaW5kZXhCdWZmZXIuZGF0YS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdlb21ldHJ5LmluZGV4QnVmZmVyKSB7XG4gICAgICAgICAgICBpZiAoZ2VvbWV0cnkuaW5zdGFuY2VkKSB7XG4gICAgICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xuICAgICAgICAgICAgICAgIGdsLmRyYXdFbGVtZW50c0luc3RhbmNlZCh0eXBlLCBzaXplIHx8IGdlb21ldHJ5LmluZGV4QnVmZmVyLmRhdGEubGVuZ3RoLCBnbC5VTlNJR05FRF9TSE9SVCwgKHN0YXJ0IHx8IDApICogMiwgaW5zdGFuY2VDb3VudCB8fCAxKTtcbiAgICAgICAgICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4gKi9cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGdsLmRyYXdFbGVtZW50cyh0eXBlLCBzaXplIHx8IGdlb21ldHJ5LmluZGV4QnVmZmVyLmRhdGEubGVuZ3RoLCBnbC5VTlNJR05FRF9TSE9SVCwgKHN0YXJ0IHx8IDApICogMik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZ2VvbWV0cnkuaW5zdGFuY2VkKSB7XG4gICAgICAgICAgICAvLyBUT0RPIG5lZWQgYSBiZXR0ZXIgd2F5IHRvIGNhbGN1bGF0ZSBzaXplLi5cbiAgICAgICAgICAgIGdsLmRyYXdBcnJheXNJbnN0YW5jZWQodHlwZSwgc3RhcnQsIHNpemUgfHwgZ2VvbWV0cnkuZ2V0U2l6ZSgpLCBpbnN0YW5jZUNvdW50IHx8IDEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZ2wuZHJhd0FycmF5cyh0eXBlLCBzdGFydCwgc2l6ZSB8fCBnZW9tZXRyeS5nZXRTaXplKCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogVW5iaW5kL3Jlc2V0IGV2ZXJ5dGhpbmdcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgdW5iaW5kKCkge1xuICAgICAgICB0aGlzLmdsLmJpbmRWZXJ0ZXhBcnJheShudWxsKTtcbiAgICAgICAgdGhpcy5fYWN0aXZlVmFvID0gbnVsbDtcbiAgICAgICAgdGhpcy5fYWN0aXZlR2VvbWV0cnkgPSBudWxsO1xuICAgIH1cbiAgICA7XG59XG5HZW9tZXRyeVN5c3RlbS5ieXRlU2l6ZU1hcCQxID0geyA1MTI2OiA0LCA1MTIzOiAyLCA1MTIxOiAxIH07XG5leHBvcnRzLkdlb21ldHJ5U3lzdGVtID0gR2VvbWV0cnlTeXN0ZW07XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IENvbnRhaW5lcl8xID0gcmVxdWlyZShcIi4vQ29udGFpbmVyXCIpO1xuY29uc3QgU3RhdGVfMSA9IHJlcXVpcmUoXCIuL1N0YXRlXCIpO1xuY29uc3QgRmlsbFN0eWxlXzEgPSByZXF1aXJlKFwiLi9GaWxsU3R5bGVcIik7XG4vLyBpbXBvcnQgeyBzZXR0aW5ncyB9IGZyb20gXCIuL3NldHRpbmdzXCI7XG5jb25zdCBUZXh0dXJlXzEgPSByZXF1aXJlKFwiLi9UZXh0dXJlXCIpO1xuY29uc3QgUmVjdGFuZ2xlXzEgPSByZXF1aXJlKFwiLi4vZmxhc2gvZ2VvbS9SZWN0YW5nbGVcIik7XG5jb25zdCBNYXRyaXhfMSA9IHJlcXVpcmUoXCIuL01hdHJpeFwiKTtcbmNvbnN0IFVuaWZvcm1Hcm91cF8xID0gcmVxdWlyZShcIi4vVW5pZm9ybUdyb3VwXCIpO1xuY29uc3QgU2hhZGVyXzEgPSByZXF1aXJlKFwiLi9TaGFkZXJcIik7XG5jb25zdCBQb2ludF8xID0gcmVxdWlyZShcIi4uL2ZsYXNoL2dlb20vUG9pbnRcIik7XG5jb25zdCBQb2x5Z29uXzEgPSByZXF1aXJlKFwiLi9Qb2x5Z29uXCIpO1xuY29uc3QgRWxsaXBzZV8xID0gcmVxdWlyZShcIi4vRWxsaXBzZVwiKTtcbmNvbnN0IENpcmNsZV8xID0gcmVxdWlyZShcIi4vQ2lyY2xlXCIpO1xuY29uc3QgUm91bmRlZFJlY3RhbmdsZV8xID0gcmVxdWlyZShcIi4vUm91bmRlZFJlY3RhbmdsZVwiKTtcbmNvbnN0IEFyY1V0aWxzXzEgPSByZXF1aXJlKFwiLi9BcmNVdGlsc1wiKTtcbmNvbnN0IEJlemllclV0aWxzXzEgPSByZXF1aXJlKFwiLi9CZXppZXJVdGlsc1wiKTtcbmNvbnN0IFF1YWRyYXRpY1V0aWxzXzEgPSByZXF1aXJlKFwiLi9RdWFkcmF0aWNVdGlsc1wiKTtcbmNvbnN0IExpbmVTdHlsZV8xID0gcmVxdWlyZShcIi4vTGluZVN0eWxlXCIpO1xuY29uc3QgR3JhcGhpY3NHZW9tZXRyeV8xID0gcmVxdWlyZShcIi4vR3JhcGhpY3NHZW9tZXRyeVwiKTtcbmNvbnN0IFN0YXJfMSA9IHJlcXVpcmUoXCIuL1N0YXJcIik7XG5jb25zdCBNYXRoU2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL01hdGhTZXR0aW5nc1wiKTtcbmNvbnN0IEJsZW5kTW9kZXNTZXR0aW5nc18xID0gcmVxdWlyZShcIi4vQmxlbmRNb2Rlc1NldHRpbmdzXCIpO1xuY29uc3QgQ29sb3JTZXR0aW5nc18xID0gcmVxdWlyZShcIi4vQ29sb3JTZXR0aW5nc1wiKTtcbmNvbnN0IEluc3RhbmNlQ291bnRlcl8xID0gcmVxdWlyZShcIi4vSW5zdGFuY2VDb3VudGVyXCIpO1xuY2xhc3MgR3JhcGhpY3MgZXh0ZW5kcyBDb250YWluZXJfMS5Db250YWluZXIge1xuICAgIGNvbnN0cnVjdG9yKGdlb21ldHJ5ID0gbnVsbCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICBpZiAoZ2VvbWV0cnkgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgZ2VvbWV0cnkgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbmNsdWRlcyB2ZXJ0ZXggcG9zaXRpb25zLCBmYWNlIGluZGljZXMsIG5vcm1hbHMsIGNvbG9ycywgVVZzLCBhbmRcbiAgICAgICAgICogY3VzdG9tIGF0dHJpYnV0ZXMgd2l0aGluIGJ1ZmZlcnMsIHJlZHVjaW5nIHRoZSBjb3N0IG9mIHBhc3NpbmcgYWxsXG4gICAgICAgICAqIHRoaXMgZGF0YSB0byB0aGUgR1BVLiBDYW4gYmUgc2hhcmVkIGJldHdlZW4gbXVsdGlwbGUgTWVzaCBvciBHcmFwaGljcyBvYmplY3RzLlxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLkdyYXBoaWNzR2VvbWV0cnl9XG4gICAgICAgICAqIEByZWFkb25seVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5nZW9tZXRyeSA9IGdlb21ldHJ5IHx8IG5ldyBHcmFwaGljc0dlb21ldHJ5XzEuR3JhcGhpY3NHZW9tZXRyeSgpO1xuICAgICAgICB0aGlzLmdlb21ldHJ5LnJlZkNvdW50Kys7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXByZXNlbnRzIHRoZSB2ZXJ0ZXggYW5kIGZyYWdtZW50IHNoYWRlcnMgdGhhdCBwcm9jZXNzZXMgdGhlIGdlb21ldHJ5IGFuZCBydW5zIG9uIHRoZSBHUFUuXG4gICAgICAgICAqIENhbiBiZSBzaGFyZWQgYmV0d2VlbiBtdWx0aXBsZSBHcmFwaGljcyBvYmplY3RzLlxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLlNoYWRlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2hhZGVyID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlcHJlc2VudHMgdGhlIFdlYkdMIHN0YXRlIHRoZSBHcmFwaGljcyByZXF1aXJlZCB0byByZW5kZXIsIGV4Y2x1ZGVzIHNoYWRlciBhbmQgZ2VvbWV0cnkuIEUuZy4sXG4gICAgICAgICAqIGJsZW5kIG1vZGUsIGN1bGxpbmcsIGRlcHRoIHRlc3RpbmcsIGRpcmVjdGlvbiBvZiByZW5kZXJpbmcgdHJpYW5nbGVzLCBiYWNrZmFjZSwgZXRjLlxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLlN0YXRlfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdGF0ZSA9IFN0YXRlXzEuU3RhdGUuZm9yMmQoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEN1cnJlbnQgZmlsbCBzdHlsZVxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLkZpbGxTdHlsZX1cbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fZmlsbFN0eWxlID0gbmV3IEZpbGxTdHlsZV8xLkZpbGxTdHlsZSgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3VycmVudCBsaW5lIHN0eWxlXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuTGluZVN0eWxlfVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9saW5lU3R5bGUgPSBuZXcgTGluZVN0eWxlXzEuTGluZVN0eWxlKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDdXJyZW50IHNoYXBlIHRyYW5zZm9ybSBtYXRyaXguXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuTWF0cml4fVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9tYXRyaXggPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3VycmVudCBob2xlIG1vZGUgaXMgZW5hYmxlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICAgICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5faG9sZU1vZGUgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEN1cnJlbnQgcGF0aFxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLlBvbHlnb259XG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY3VycmVudFBhdGggPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hlbiBjYWNoZUFzQml0bWFwIGlzIHNldCB0byB0cnVlIHRoZSBncmFwaGljcyBvYmplY3Qgd2lsbCBiZSByZW5kZXJlZCBhcyBpZiBpdCB3YXMgYSBzcHJpdGUuXG4gICAgICAgICAqIFRoaXMgaXMgdXNlZnVsIGlmIHlvdXIgZ3JhcGhpY3MgZWxlbWVudCBkb2VzIG5vdCBjaGFuZ2Ugb2Z0ZW4sIGFzIGl0IHdpbGwgc3BlZWQgdXAgdGhlIHJlbmRlcmluZ1xuICAgICAgICAgKiBvZiB0aGUgb2JqZWN0IGluIGV4Y2hhbmdlIGZvciB0YWtpbmcgdXAgdGV4dHVyZSBtZW1vcnkuIEl0IGlzIGFsc28gdXNlZnVsIGlmIHlvdSBuZWVkIHRoZSBncmFwaGljc1xuICAgICAgICAgKiBvYmplY3QgdG8gYmUgYW50aS1hbGlhc2VkLCBiZWNhdXNlIGl0IHdpbGwgYmUgcmVuZGVyZWQgdXNpbmcgY2FudmFzLiBUaGlzIGlzIG5vdCByZWNvbW1lbmRlZCBpZlxuICAgICAgICAgKiB5b3UgYXJlIGNvbnN0YW50bHkgcmVkcmF3aW5nIHRoZSBncmFwaGljcyBlbGVtZW50LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbmFtZSBjYWNoZUFzQml0bWFwXG4gICAgICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XG4gICAgICAgICAqIEBtZW1iZXJvZiBQSVhJLkdyYXBoaWNzI1xuICAgICAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgY29sbGVjdGlvbnMgb2YgYmF0Y2hlcyEgVGhlc2UgY2FuIGJlIGRyYXduIGJ5IHRoZSByZW5kZXJlciBiYXRjaCBzeXN0ZW0uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICogQG1lbWJlciB7b2JqZWN0W119XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmJhdGNoZXMgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVwZGF0ZSBkaXJ0eSBmb3IgbGltaXRpbmcgY2FsY3VsYXRpbmcgdGludHMgZm9yIGJhdGNoZXMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAtMVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5iYXRjaFRpbnQgPSAtMTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvcHkgb2YgdGhlIG9iamVjdCB2ZXJ0ZXggZGF0YS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKiBAbWVtYmVyIHtGbG9hdDMyQXJyYXl9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnZlcnRleERhdGEgPSBudWxsO1xuICAgICAgICB0aGlzLl90cmFuc2Zvcm1JRCA9IC0xO1xuICAgICAgICB0aGlzLmJhdGNoRGlydHkgPSAtMTtcbiAgICAgICAgLy8gU2V0IGRlZmF1bHRcbiAgICAgICAgdGhpcy50aW50ID0gMHhGRkZGRkY7XG4gICAgICAgIHRoaXMuYmxlbmRNb2RlID0gQmxlbmRNb2Rlc1NldHRpbmdzXzEuQmxlbmRNb2Rlc1NldHRpbmdzLkJMRU5EX01PREVTLk5PUk1BTDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBHcmFwaGljcyBvYmplY3Qgd2l0aCB0aGUgc2FtZSB2YWx1ZXMgYXMgdGhpcyBvbmUuXG4gICAgICogTm90ZSB0aGF0IHRoZSBvbmx5IHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBvYmplY3QgYXJlIGNsb25lZCwgbm90IGl0cyB0cmFuc2Zvcm0gKHBvc2l0aW9uLHNjYWxlLGV0YylcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1BJWEkuR3JhcGhpY3N9IEEgY2xvbmUgb2YgdGhlIGdyYXBoaWNzIG9iamVjdFxuICAgICAqL1xuICAgIGNsb25lKCkge1xuICAgICAgICB0aGlzLmZpbmlzaFBvbHkoKTtcbiAgICAgICAgcmV0dXJuIG5ldyBHcmFwaGljcyh0aGlzLmdlb21ldHJ5KTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFRoZSBibGVuZCBtb2RlIHRvIGJlIGFwcGxpZWQgdG8gdGhlIGdyYXBoaWMgc2hhcGUuIEFwcGx5IGEgdmFsdWUgb2ZcbiAgICAgKiBgUElYSS5CTEVORF9NT0RFUy5OT1JNQUxgIHRvIHJlc2V0IHRoZSBibGVuZCBtb2RlLlxuICAgICAqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IFBJWEkuQkxFTkRfTU9ERVMuTk9STUFMO1xuICAgICAqIEBzZWUgUElYSS5CTEVORF9NT0RFU1xuICAgICAqL1xuICAgIHNldCBibGVuZE1vZGUodmFsdWUpIHtcbiAgICAgICAgdGhpcy5zdGF0ZS5ibGVuZE1vZGUgPSB2YWx1ZTtcbiAgICB9XG4gICAgO1xuICAgIGdldCBibGVuZE1vZGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLmJsZW5kTW9kZTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFRoZSB0aW50IGFwcGxpZWQgdG8gdGhlIGdyYXBoaWMgc2hhcGUuIFRoaXMgaXMgYSBoZXggdmFsdWUuIEEgdmFsdWUgb2ZcbiAgICAgKiAweEZGRkZGRiB3aWxsIHJlbW92ZSBhbnkgdGludCBlZmZlY3QuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMHhGRkZGRkZcbiAgICAgKi9cbiAgICBnZXQgdGludCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RpbnQ7XG4gICAgfVxuICAgIDtcbiAgICBzZXQgdGludCh2YWx1ZSkge1xuICAgICAgICB0aGlzLl90aW50ID0gdmFsdWU7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBUaGUgY3VycmVudCBmaWxsIHN0eWxlLlxuICAgICAqXG4gICAgICogQG1lbWJlciB7UElYSS5GaWxsU3R5bGV9XG4gICAgICogQHJlYWRvbmx5XG4gICAgICovXG4gICAgZ2V0IGZpbGwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9maWxsU3R5bGU7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBUaGUgY3VycmVudCBsaW5lIHN0eWxlLlxuICAgICAqXG4gICAgICogQG1lbWJlciB7UElYSS5MaW5lU3R5bGV9XG4gICAgICogQHJlYWRvbmx5XG4gICAgICovXG4gICAgZ2V0IGxpbmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9saW5lU3R5bGU7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBTcGVjaWZpZXMgdGhlIGxpbmUgc3R5bGUgdXNlZCBmb3Igc3Vic2VxdWVudCBjYWxscyB0byBHcmFwaGljcyBtZXRob2RzIHN1Y2ggYXMgdGhlIGxpbmVUbygpXG4gICAgICogbWV0aG9kIG9yIHRoZSBkcmF3Q2lyY2xlKCkgbWV0aG9kLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt3aWR0aD0wXSAtIHdpZHRoIG9mIHRoZSBsaW5lIHRvIGRyYXcsIHdpbGwgdXBkYXRlIHRoZSBvYmplY3RzIHN0b3JlZCBzdHlsZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbY29sb3I9MF0gLSBjb2xvciBvZiB0aGUgbGluZSB0byBkcmF3LCB3aWxsIHVwZGF0ZSB0aGUgb2JqZWN0cyBzdG9yZWQgc3R5bGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FscGhhPTFdIC0gYWxwaGEgb2YgdGhlIGxpbmUgdG8gZHJhdywgd2lsbCB1cGRhdGUgdGhlIG9iamVjdHMgc3RvcmVkIHN0eWxlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthbGlnbm1lbnQ9MV0gLSBhbGlnbm1lbnQgb2YgdGhlIGxpbmUgdG8gZHJhdywgKDAgPSBpbm5lciwgMC41ID0gbWlkZGxlLCAxID0gb3V0dGVyKVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW25hdGl2ZT1mYWxzZV0gLSBJZiB0cnVlIHRoZSBsaW5lcyB3aWxsIGJlIGRyYXcgdXNpbmcgTElORVMgaW5zdGVhZCBvZiBUUklBTkdMRV9TVFJJUFxuICAgICAqIEByZXR1cm4ge1BJWEkuR3JhcGhpY3N9IFRoaXMgR3JhcGhpY3Mgb2JqZWN0LiBHb29kIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHNcbiAgICAgKi9cbiAgICBsaW5lU3R5bGUod2lkdGgsIGNvbG9yID0gMCwgYWxwaGEgPSAxLCBhbGlnbm1lbnQgPSAwLjUsIG5hdGl2ZSA9IGZhbHNlKSB7XG4gICAgICAgIGlmICh3aWR0aCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICB3aWR0aCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbG9yID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIGNvbG9yID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWxwaGEgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgYWxwaGEgPSAxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhbGlnbm1lbnQgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgYWxpZ25tZW50ID0gMC41O1xuICAgICAgICB9XG4gICAgICAgIGlmIChuYXRpdmUgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgbmF0aXZlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5saW5lVGV4dHVyZVN0eWxlKHdpZHRoLCBUZXh0dXJlXzEuVGV4dHVyZS5XSElURSwgY29sb3IsIGFscGhhLCBudWxsLCBhbGlnbm1lbnQsIG5hdGl2ZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogTGlrZSBsaW5lIHN0eWxlIGJ1dCBzdXBwb3J0IHRleHR1cmUgZm9yIGxpbmUgZmlsbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbd2lkdGg9MF0gLSB3aWR0aCBvZiB0aGUgbGluZSB0byBkcmF3LCB3aWxsIHVwZGF0ZSB0aGUgb2JqZWN0cyBzdG9yZWQgc3R5bGVcbiAgICAgKiBAcGFyYW0ge1BJWEkuVGV4dHVyZX0gW3RleHR1cmU9UElYSS5UZXh0dXJlLldISVRFXSAtIFRleHR1cmUgdG8gdXNlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtjb2xvcj0wXSAtIGNvbG9yIG9mIHRoZSBsaW5lIHRvIGRyYXcsIHdpbGwgdXBkYXRlIHRoZSBvYmplY3RzIHN0b3JlZCBzdHlsZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYWxwaGE9MV0gLSBhbHBoYSBvZiB0aGUgbGluZSB0byBkcmF3LCB3aWxsIHVwZGF0ZSB0aGUgb2JqZWN0cyBzdG9yZWQgc3R5bGVcbiAgICAgKiBAcGFyYW0ge1BJWEkuTWF0cml4fSBbbWF0cml4PW51bGxdIFRleHR1cmUgbWF0cml4IHRvIHRyYW5zZm9ybSB0ZXh0dXJlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthbGlnbm1lbnQ9MC41XSAtIGFsaWdubWVudCBvZiB0aGUgbGluZSB0byBkcmF3LCAoMCA9IGlubmVyLCAwLjUgPSBtaWRkbGUsIDEgPSBvdXR0ZXIpXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbbmF0aXZlPWZhbHNlXSAtIElmIHRydWUgdGhlIGxpbmVzIHdpbGwgYmUgZHJhdyB1c2luZyBMSU5FUyBpbnN0ZWFkIG9mIFRSSUFOR0xFX1NUUklQXG4gICAgICogQHJldHVybiB7UElYSS5HcmFwaGljc30gVGhpcyBHcmFwaGljcyBvYmplY3QuIEdvb2QgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxsc1xuICAgICAqL1xuICAgIGxpbmVUZXh0dXJlU3R5bGUod2lkdGggPSAwLCB0ZXh0dXJlID0gVGV4dHVyZV8xLlRleHR1cmUuV0hJVEUsIGNvbG9yID0gMHhGRkZGRkYsIGFscGhhID0gMSwgbWF0cml4ID0gbnVsbCwgYWxpZ25tZW50ID0gMC41LCBuYXRpdmUgPSBmYWxzZSkge1xuICAgICAgICBpZiAod2lkdGggPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgd2lkdGggPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0ZXh0dXJlID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHRleHR1cmUgPSBUZXh0dXJlXzEuVGV4dHVyZS5XSElURTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29sb3IgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgY29sb3IgPSAweEZGRkZGRjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWxwaGEgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgYWxwaGEgPSAxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXRyaXggPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgbWF0cml4ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWxpZ25tZW50ID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIGFsaWdubWVudCA9IDAuNTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmF0aXZlID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIG5hdGl2ZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRQYXRoKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0UG9seSgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB2aXNpYmxlID0gd2lkdGggPiAwICYmIGFscGhhID4gMDtcbiAgICAgICAgaWYgKCF2aXNpYmxlKSB7XG4gICAgICAgICAgICB0aGlzLl9saW5lU3R5bGUucmVzZXQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChtYXRyaXgpIHtcbiAgICAgICAgICAgICAgICBtYXRyaXggPSBtYXRyaXguY2xvbmUoKTtcbiAgICAgICAgICAgICAgICBtYXRyaXguaW52ZXJ0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMuX2xpbmVTdHlsZSwge1xuICAgICAgICAgICAgICAgIGNvbG9yOiBjb2xvcixcbiAgICAgICAgICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgICAgICAgICAgYWxwaGE6IGFscGhhLFxuICAgICAgICAgICAgICAgIG1hdHJpeDogbWF0cml4LFxuICAgICAgICAgICAgICAgIHRleHR1cmU6IHRleHR1cmUsXG4gICAgICAgICAgICAgICAgYWxpZ25tZW50OiBhbGlnbm1lbnQsXG4gICAgICAgICAgICAgICAgbmF0aXZlOiBuYXRpdmUsXG4gICAgICAgICAgICAgICAgdmlzaWJsZTogdmlzaWJsZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogU3RhcnQgYSBwb2x5Z29uIG9iamVjdCBpbnRlcm5hbGx5XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHN0YXJ0UG9seSgpIHtcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFBhdGgpIHtcbiAgICAgICAgICAgIHZhciBwb2ludHMgPSB0aGlzLmN1cnJlbnRQYXRoLnBvaW50cztcbiAgICAgICAgICAgIHZhciBsZW4gPSB0aGlzLmN1cnJlbnRQYXRoLnBvaW50cy5sZW5ndGg7XG4gICAgICAgICAgICBpZiAobGVuID4gMikge1xuICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NoYXBlKHRoaXMuY3VycmVudFBhdGgpO1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFBhdGggPSBuZXcgUG9seWdvbl8xLlBvbHlnb24oKTtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRQYXRoLmNsb3NlU3Ryb2tlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50UGF0aC5wb2ludHMucHVzaChwb2ludHNbbGVuIC0gMl0sIHBvaW50c1tsZW4gLSAxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRQYXRoID0gbmV3IFBvbHlnb25fMS5Qb2x5Z29uKCk7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRQYXRoLmNsb3NlU3Ryb2tlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIEZpbmlzaCB0aGUgcG9seWdvbiBvYmplY3QuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGZpbmlzaFBvbHkoKSB7XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRQYXRoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50UGF0aC5wb2ludHMubGVuZ3RoID4gMikge1xuICAgICAgICAgICAgICAgIHRoaXMuZHJhd1NoYXBlKHRoaXMuY3VycmVudFBhdGgpO1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFBhdGggPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50UGF0aC5wb2ludHMubGVuZ3RoID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogTW92ZXMgdGhlIGN1cnJlbnQgZHJhd2luZyBwb3NpdGlvbiB0byB4LCB5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggLSB0aGUgWCBjb29yZGluYXRlIHRvIG1vdmUgdG9cbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSAtIHRoZSBZIGNvb3JkaW5hdGUgdG8gbW92ZSB0b1xuICAgICAqIEByZXR1cm4ge1BJWEkuR3JhcGhpY3N9IFRoaXMgR3JhcGhpY3Mgb2JqZWN0LiBHb29kIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHNcbiAgICAgKi9cbiAgICBtb3ZlVG8oeCwgeSkge1xuICAgICAgICB0aGlzLnN0YXJ0UG9seSgpO1xuICAgICAgICB0aGlzLmN1cnJlbnRQYXRoLnBvaW50c1swXSA9IHg7XG4gICAgICAgIHRoaXMuY3VycmVudFBhdGgucG9pbnRzWzFdID0geTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBEcmF3cyBhIGxpbmUgdXNpbmcgdGhlIGN1cnJlbnQgbGluZSBzdHlsZSBmcm9tIHRoZSBjdXJyZW50IGRyYXdpbmcgcG9zaXRpb24gdG8gKHgsIHkpO1xuICAgICAqIFRoZSBjdXJyZW50IGRyYXdpbmcgcG9zaXRpb24gaXMgdGhlbiBzZXQgdG8gKHgsIHkpLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggLSB0aGUgWCBjb29yZGluYXRlIHRvIGRyYXcgdG9cbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSAtIHRoZSBZIGNvb3JkaW5hdGUgdG8gZHJhdyB0b1xuICAgICAqIEByZXR1cm4ge1BJWEkuR3JhcGhpY3N9IFRoaXMgR3JhcGhpY3Mgb2JqZWN0LiBHb29kIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHNcbiAgICAgKi9cbiAgICBsaW5lVG8oeCwgeSkge1xuICAgICAgICBpZiAoIXRoaXMuY3VycmVudFBhdGgpIHtcbiAgICAgICAgICAgIHRoaXMubW92ZVRvKDAsIDApO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJlbW92ZSBkdXBsaWNhdGVzLi5cbiAgICAgICAgdmFyIHBvaW50cyA9IHRoaXMuY3VycmVudFBhdGgucG9pbnRzO1xuICAgICAgICB2YXIgZnJvbVggPSBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDJdO1xuICAgICAgICB2YXIgZnJvbVkgPSBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAoZnJvbVggIT09IHggfHwgZnJvbVkgIT09IHkpIHtcbiAgICAgICAgICAgIHBvaW50cy5wdXNoKHgsIHkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSB0aGUgY3VydmVcbiAgICAgKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3g9MF1cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3k9MF1cbiAgICAgKi9cbiAgICBfaW5pdEN1cnZlKHggPSAwLCB5ID0gMCkge1xuICAgICAgICBpZiAoeCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICB4ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoeSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICB5ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jdXJyZW50UGF0aCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudFBhdGgucG9pbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFBhdGgucG9pbnRzID0gW3gsIHldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5tb3ZlVG8oeCwgeSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSB0aGUgcG9pbnRzIGZvciBhIHF1YWRyYXRpYyBiZXppZXIgY3VydmUgYW5kIHRoZW4gZHJhd3MgaXQuXG4gICAgICogQmFzZWQgb246IGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzc4NTA5Ny9ob3ctZG8taS1pbXBsZW1lbnQtYS1iZXppZXItY3VydmUtaW4tY1xuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNwWCAtIENvbnRyb2wgcG9pbnQgeFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjcFkgLSBDb250cm9sIHBvaW50IHlcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdG9YIC0gRGVzdGluYXRpb24gcG9pbnQgeFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0b1kgLSBEZXN0aW5hdGlvbiBwb2ludCB5XG4gICAgICogQHJldHVybiB7UElYSS5HcmFwaGljc30gVGhpcyBHcmFwaGljcyBvYmplY3QuIEdvb2QgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxsc1xuICAgICAqL1xuICAgIHF1YWRyYXRpY0N1cnZlVG8oY3BYLCBjcFksIHRvWCwgdG9ZKSB7XG4gICAgICAgIHRoaXMuX2luaXRDdXJ2ZSgpO1xuICAgICAgICB2YXIgcG9pbnRzID0gdGhpcy5jdXJyZW50UGF0aC5wb2ludHM7XG4gICAgICAgIGlmIChwb2ludHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLm1vdmVUbygwLCAwKTtcbiAgICAgICAgfVxuICAgICAgICBRdWFkcmF0aWNVdGlsc18xLlF1YWRyYXRpY1V0aWxzLmN1cnZlVG8oY3BYLCBjcFksIHRvWCwgdG9ZLCBwb2ludHMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSB0aGUgcG9pbnRzIGZvciBhIGJlemllciBjdXJ2ZSBhbmQgdGhlbiBkcmF3cyBpdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjcFggLSBDb250cm9sIHBvaW50IHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY3BZIC0gQ29udHJvbCBwb2ludCB5XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNwWDIgLSBTZWNvbmQgQ29udHJvbCBwb2ludCB4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNwWTIgLSBTZWNvbmQgQ29udHJvbCBwb2ludCB5XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRvWCAtIERlc3RpbmF0aW9uIHBvaW50IHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdG9ZIC0gRGVzdGluYXRpb24gcG9pbnQgeVxuICAgICAqIEByZXR1cm4ge1BJWEkuR3JhcGhpY3N9IFRoaXMgR3JhcGhpY3Mgb2JqZWN0LiBHb29kIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHNcbiAgICAgKi9cbiAgICBiZXppZXJDdXJ2ZVRvKGNwWCwgY3BZLCBjcFgyLCBjcFkyLCB0b1gsIHRvWSkge1xuICAgICAgICB0aGlzLl9pbml0Q3VydmUoKTtcbiAgICAgICAgQmV6aWVyVXRpbHNfMS5CZXppZXJVdGlscy5jdXJ2ZVRvKGNwWCwgY3BZLCBjcFgyLCBjcFkyLCB0b1gsIHRvWSwgdGhpcy5jdXJyZW50UGF0aC5wb2ludHMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFRoZSBhcmNUbygpIG1ldGhvZCBjcmVhdGVzIGFuIGFyYy9jdXJ2ZSBiZXR3ZWVuIHR3byB0YW5nZW50cyBvbiB0aGUgY2FudmFzLlxuICAgICAqXG4gICAgICogXCJib3Jyb3dlZFwiIGZyb20gaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9meGNhbnZhcy8gLSB0aGFua3MgZ29vZ2xlIVxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHgxIC0gVGhlIHgtY29vcmRpbmF0ZSBvZiB0aGUgYmVnaW5uaW5nIG9mIHRoZSBhcmNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geTEgLSBUaGUgeS1jb29yZGluYXRlIG9mIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGFyY1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4MiAtIFRoZSB4LWNvb3JkaW5hdGUgb2YgdGhlIGVuZCBvZiB0aGUgYXJjXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkyIC0gVGhlIHktY29vcmRpbmF0ZSBvZiB0aGUgZW5kIG9mIHRoZSBhcmNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcmFkaXVzIC0gVGhlIHJhZGl1cyBvZiB0aGUgYXJjXG4gICAgICogQHJldHVybiB7UElYSS5HcmFwaGljc30gVGhpcyBHcmFwaGljcyBvYmplY3QuIEdvb2QgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxsc1xuICAgICAqL1xuICAgIGFyY1RvKHgxLCB5MSwgeDIsIHkyLCByYWRpdXMpIHtcbiAgICAgICAgdGhpcy5faW5pdEN1cnZlKHgxLCB5MSk7XG4gICAgICAgIHZhciBwb2ludHMgPSB0aGlzLmN1cnJlbnRQYXRoLnBvaW50cztcbiAgICAgICAgdmFyIHJlc3VsdCA9IEFyY1V0aWxzXzEuQXJjVXRpbHMuY3VydmVUbyh4MSwgeTEsIHgyLCB5MiwgcmFkaXVzLCBwb2ludHMpO1xuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICB2YXIgY3ggPSByZXN1bHQuY3g7XG4gICAgICAgICAgICB2YXIgY3kgPSByZXN1bHQuY3k7XG4gICAgICAgICAgICB2YXIgcmFkaXVzJDEgPSByZXN1bHQucmFkaXVzO1xuICAgICAgICAgICAgdmFyIHN0YXJ0QW5nbGUgPSByZXN1bHQuc3RhcnRBbmdsZTtcbiAgICAgICAgICAgIHZhciBlbmRBbmdsZSA9IHJlc3VsdC5lbmRBbmdsZTtcbiAgICAgICAgICAgIHZhciBhbnRpY2xvY2t3aXNlID0gcmVzdWx0LmFudGljbG9ja3dpc2U7XG4gICAgICAgICAgICB0aGlzLmFyYyhjeCwgY3ksIHJhZGl1cyQxLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgYW50aWNsb2Nrd2lzZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBUaGUgYXJjIG1ldGhvZCBjcmVhdGVzIGFuIGFyYy9jdXJ2ZSAodXNlZCB0byBjcmVhdGUgY2lyY2xlcywgb3IgcGFydHMgb2YgY2lyY2xlcykuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY3ggLSBUaGUgeC1jb29yZGluYXRlIG9mIHRoZSBjZW50ZXIgb2YgdGhlIGNpcmNsZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjeSAtIFRoZSB5LWNvb3JkaW5hdGUgb2YgdGhlIGNlbnRlciBvZiB0aGUgY2lyY2xlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJhZGl1cyAtIFRoZSByYWRpdXMgb2YgdGhlIGNpcmNsZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydEFuZ2xlIC0gVGhlIHN0YXJ0aW5nIGFuZ2xlLCBpbiByYWRpYW5zICgwIGlzIGF0IHRoZSAzIG8nY2xvY2sgcG9zaXRpb25cbiAgICAgKiAgb2YgdGhlIGFyYydzIGNpcmNsZSlcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZW5kQW5nbGUgLSBUaGUgZW5kaW5nIGFuZ2xlLCBpbiByYWRpYW5zXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbYW50aWNsb2Nrd2lzZT1mYWxzZV0gLSBTcGVjaWZpZXMgd2hldGhlciB0aGUgZHJhd2luZyBzaG91bGQgYmVcbiAgICAgKiAgY291bnRlci1jbG9ja3dpc2Ugb3IgY2xvY2t3aXNlLiBGYWxzZSBpcyBkZWZhdWx0LCBhbmQgaW5kaWNhdGVzIGNsb2Nrd2lzZSwgd2hpbGUgdHJ1ZVxuICAgICAqICBpbmRpY2F0ZXMgY291bnRlci1jbG9ja3dpc2UuXG4gICAgICogQHJldHVybiB7UElYSS5HcmFwaGljc30gVGhpcyBHcmFwaGljcyBvYmplY3QuIEdvb2QgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxsc1xuICAgICAqL1xuICAgIGFyYyhjeCwgY3ksIHJhZGl1cywgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGFudGljbG9ja3dpc2UgPSBmYWxzZSkge1xuICAgICAgICBpZiAoYW50aWNsb2Nrd2lzZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBhbnRpY2xvY2t3aXNlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXJ0QW5nbGUgPT09IGVuZEFuZ2xlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWFudGljbG9ja3dpc2UgJiYgZW5kQW5nbGUgPD0gc3RhcnRBbmdsZSkge1xuICAgICAgICAgICAgZW5kQW5nbGUgKz0gTWF0aFNldHRpbmdzXzEuTWF0aFNldHRpbmdzLlBJXzI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYW50aWNsb2Nrd2lzZSAmJiBzdGFydEFuZ2xlIDw9IGVuZEFuZ2xlKSB7XG4gICAgICAgICAgICBzdGFydEFuZ2xlICs9IE1hdGhTZXR0aW5nc18xLk1hdGhTZXR0aW5ncy5QSV8yO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzd2VlcCA9IGVuZEFuZ2xlIC0gc3RhcnRBbmdsZTtcbiAgICAgICAgaWYgKHN3ZWVwID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3RhcnRYID0gY3ggKyAoTWF0aC5jb3Moc3RhcnRBbmdsZSkgKiByYWRpdXMpO1xuICAgICAgICB2YXIgc3RhcnRZID0gY3kgKyAoTWF0aC5zaW4oc3RhcnRBbmdsZSkgKiByYWRpdXMpO1xuICAgICAgICAvLyBJZiB0aGUgY3VycmVudFBhdGggZXhpc3RzLCB0YWtlIGl0cyBwb2ludHMuIE90aGVyd2lzZSBjYWxsIGBtb3ZlVG9gIHRvIHN0YXJ0IGEgcGF0aC5cbiAgICAgICAgdmFyIHBvaW50cyA9IHRoaXMuY3VycmVudFBhdGggPyB0aGlzLmN1cnJlbnRQYXRoLnBvaW50cyA6IG51bGw7XG4gICAgICAgIGlmIChwb2ludHMpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IG1ha2UgYSBiZXR0ZXIgZml4LlxuICAgICAgICAgICAgLy8gV2UgY2hlY2sgaG93IGZhciBvdXIgc3RhcnQgaXMgZnJvbSB0aGUgbGFzdCBleGlzdGluZyBwb2ludFxuICAgICAgICAgICAgdmFyIHhEaWZmID0gTWF0aC5hYnMocG9pbnRzW3BvaW50cy5sZW5ndGggLSAyXSAtIHN0YXJ0WCk7XG4gICAgICAgICAgICB2YXIgeURpZmYgPSBNYXRoLmFicyhwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDFdIC0gc3RhcnRZKTtcbiAgICAgICAgICAgIGlmICh4RGlmZiA8IDAuMDAxICYmIHlEaWZmIDwgMC4wMDEpIHtcbiAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwb2ludHMucHVzaChzdGFydFgsIHN0YXJ0WSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm1vdmVUbyhzdGFydFgsIHN0YXJ0WSk7XG4gICAgICAgICAgICBwb2ludHMgPSB0aGlzLmN1cnJlbnRQYXRoLnBvaW50cztcbiAgICAgICAgfVxuICAgICAgICBBcmNVdGlsc18xLkFyY1V0aWxzLmFyYyhzdGFydFgsIHN0YXJ0WSwgY3gsIGN5LCByYWRpdXMsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBhbnRpY2xvY2t3aXNlLCBwb2ludHMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFNwZWNpZmllcyBhIHNpbXBsZSBvbmUtY29sb3IgZmlsbCB0aGF0IHN1YnNlcXVlbnQgY2FsbHMgdG8gb3RoZXIgR3JhcGhpY3MgbWV0aG9kc1xuICAgICAqIChzdWNoIGFzIGxpbmVUbygpIG9yIGRyYXdDaXJjbGUoKSkgdXNlIHdoZW4gZHJhd2luZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbY29sb3I9MF0gLSB0aGUgY29sb3Igb2YgdGhlIGZpbGxcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FscGhhPTFdIC0gdGhlIGFscGhhIG9mIHRoZSBmaWxsXG4gICAgICogQHJldHVybiB7UElYSS5HcmFwaGljc30gVGhpcyBHcmFwaGljcyBvYmplY3QuIEdvb2QgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxsc1xuICAgICAqL1xuICAgIGJlZ2luRmlsbChjb2xvciA9IDAsIGFscGhhID0gMSkge1xuICAgICAgICByZXR1cm4gdGhpcy5iZWdpblRleHR1cmVGaWxsKFRleHR1cmVfMS5UZXh0dXJlLldISVRFLCBjb2xvciwgYWxwaGEpO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogQmVnaW4gdGhlIHRleHR1cmUgZmlsbFxuICAgICAqXG4gICAgICogQHBhcmFtIHtQSVhJLlRleHR1cmV9IFt0ZXh0dXJlPVBJWEkuVGV4dHVyZS5XSElURV0gLSBUZXh0dXJlIHRvIGZpbGxcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2NvbG9yPTB4ZmZmZmZmXSAtIEJhY2tncm91bmQgdG8gZmlsbCBiZWhpbmQgdGV4dHVyZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYWxwaGE9MV0gLSBBbHBoYSBvZiBmaWxsXG4gICAgICogQHBhcmFtIHtQSVhJLk1hdHJpeH0gW21hdHJpeD1udWxsXSAtIFRyYW5zZm9ybSBtYXRyaXhcbiAgICAgKiBAcmV0dXJuIHtQSVhJLkdyYXBoaWNzfSBUaGlzIEdyYXBoaWNzIG9iamVjdC4gR29vZCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzXG4gICAgICovXG4gICAgYmVnaW5UZXh0dXJlRmlsbCh0ZXh0dXJlLCBjb2xvciwgYWxwaGEsIG1hdHJpeCA9IG51bGwpIHtcbiAgICAgICAgaWYgKHRleHR1cmUgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgdGV4dHVyZSA9IFRleHR1cmVfMS5UZXh0dXJlLldISVRFO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb2xvciA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBjb2xvciA9IDB4RkZGRkZGO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhbHBoYSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBhbHBoYSA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hdHJpeCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBtYXRyaXggPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRQYXRoKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0UG9seSgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB2aXNpYmxlID0gYWxwaGEgPiAwO1xuICAgICAgICBpZiAoIXZpc2libGUpIHtcbiAgICAgICAgICAgIHRoaXMuX2ZpbGxTdHlsZS5yZXNldCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKG1hdHJpeCkge1xuICAgICAgICAgICAgICAgIG1hdHJpeCA9IG1hdHJpeC5jbG9uZSgpO1xuICAgICAgICAgICAgICAgIG1hdHJpeC5pbnZlcnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odGhpcy5fZmlsbFN0eWxlLCB7XG4gICAgICAgICAgICAgICAgY29sb3I6IGNvbG9yLFxuICAgICAgICAgICAgICAgIGFscGhhOiBhbHBoYSxcbiAgICAgICAgICAgICAgICB0ZXh0dXJlOiB0ZXh0dXJlLFxuICAgICAgICAgICAgICAgIG1hdHJpeDogbWF0cml4LFxuICAgICAgICAgICAgICAgIHZpc2libGU6IHZpc2libGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgYSBmaWxsIHRvIHRoZSBsaW5lcyBhbmQgc2hhcGVzIHRoYXQgd2VyZSBhZGRlZCBzaW5jZSB0aGUgbGFzdCBjYWxsIHRvIHRoZSBiZWdpbkZpbGwoKSBtZXRob2QuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtQSVhJLkdyYXBoaWNzfSBUaGlzIEdyYXBoaWNzIG9iamVjdC4gR29vZCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzXG4gICAgICovXG4gICAgZW5kRmlsbCgpIHtcbiAgICAgICAgdGhpcy5maW5pc2hQb2x5KCk7XG4gICAgICAgIHRoaXMuX2ZpbGxTdHlsZS5yZXNldCgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIERyYXdzIGEgcmVjdGFuZ2xlIHNoYXBlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggLSBUaGUgWCBjb29yZCBvZiB0aGUgdG9wLWxlZnQgb2YgdGhlIHJlY3RhbmdsZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gVGhlIFkgY29vcmQgb2YgdGhlIHRvcC1sZWZ0IG9mIHRoZSByZWN0YW5nbGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd2lkdGggLSBUaGUgd2lkdGggb2YgdGhlIHJlY3RhbmdsZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgLSBUaGUgaGVpZ2h0IG9mIHRoZSByZWN0YW5nbGVcbiAgICAgKiBAcmV0dXJuIHtQSVhJLkdyYXBoaWNzfSBUaGlzIEdyYXBoaWNzIG9iamVjdC4gR29vZCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzXG4gICAgICovXG4gICAgZHJhd1JlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICBJbnN0YW5jZUNvdW50ZXJfMS5JbnN0YW5jZUNvdW50ZXIuYWRkQ2FsbChcIlJlY3RhbmdsZS5nZXRSZWN0YW5nbGVcIiwgXCJHcmFwaGljcyBkcmF3UmVjdFwiKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZHJhd1NoYXBlKFJlY3RhbmdsZV8xLlJlY3RhbmdsZS5nZXRSZWN0YW5nbGUoeCwgeSwgd2lkdGgsIGhlaWdodCkpO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogRHJhdyBhIHJlY3RhbmdsZSBzaGFwZSB3aXRoIHJvdW5kZWQvYmV2ZWxlZCBjb3JuZXJzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggLSBUaGUgWCBjb29yZCBvZiB0aGUgdG9wLWxlZnQgb2YgdGhlIHJlY3RhbmdsZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gVGhlIFkgY29vcmQgb2YgdGhlIHRvcC1sZWZ0IG9mIHRoZSByZWN0YW5nbGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd2lkdGggLSBUaGUgd2lkdGggb2YgdGhlIHJlY3RhbmdsZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgLSBUaGUgaGVpZ2h0IG9mIHRoZSByZWN0YW5nbGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcmFkaXVzIC0gUmFkaXVzIG9mIHRoZSByZWN0YW5nbGUgY29ybmVyc1xuICAgICAqIEByZXR1cm4ge1BJWEkuR3JhcGhpY3N9IFRoaXMgR3JhcGhpY3Mgb2JqZWN0LiBHb29kIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHNcbiAgICAgKi9cbiAgICBkcmF3Um91bmRlZFJlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCwgcmFkaXVzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRyYXdTaGFwZShuZXcgUm91bmRlZFJlY3RhbmdsZV8xLlJvdW5kZWRSZWN0YW5nbGUoeCwgeSwgd2lkdGgsIGhlaWdodCwgcmFkaXVzKSk7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBEcmF3cyBhIGNpcmNsZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgY2VudGVyIG9mIHRoZSBjaXJjbGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSAtIFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIGNlbnRlciBvZiB0aGUgY2lyY2xlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJhZGl1cyAtIFRoZSByYWRpdXMgb2YgdGhlIGNpcmNsZVxuICAgICAqIEByZXR1cm4ge1BJWEkuR3JhcGhpY3N9IFRoaXMgR3JhcGhpY3Mgb2JqZWN0LiBHb29kIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHNcbiAgICAgKi9cbiAgICBkcmF3Q2lyY2xlKHgsIHksIHJhZGl1cykge1xuICAgICAgICByZXR1cm4gdGhpcy5kcmF3U2hhcGUobmV3IENpcmNsZV8xLkNpcmNsZSh4LCB5LCByYWRpdXMpKTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIERyYXdzIGFuIGVsbGlwc2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCAtIFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIGNlbnRlciBvZiB0aGUgZWxsaXBzZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgY2VudGVyIG9mIHRoZSBlbGxpcHNlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIC0gVGhlIGhhbGYgd2lkdGggb2YgdGhlIGVsbGlwc2VcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IC0gVGhlIGhhbGYgaGVpZ2h0IG9mIHRoZSBlbGxpcHNlXG4gICAgICogQHJldHVybiB7UElYSS5HcmFwaGljc30gVGhpcyBHcmFwaGljcyBvYmplY3QuIEdvb2QgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxsc1xuICAgICAqL1xuICAgIGRyYXdFbGxpcHNlKHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZHJhd1NoYXBlKG5ldyBFbGxpcHNlXzEuRWxsaXBzZSh4LCB5LCB3aWR0aCwgaGVpZ2h0KSk7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBEcmF3cyBhIHBvbHlnb24gdXNpbmcgdGhlIGdpdmVuIHBhdGguXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcltdfFBJWEkuUG9pbnRbXXxQSVhJLlBvbHlnb259IHBhdGggLSBUaGUgcGF0aCBkYXRhIHVzZWQgdG8gY29uc3RydWN0IHRoZSBwb2x5Z29uLlxuICAgICAqIEByZXR1cm4ge1BJWEkuR3JhcGhpY3N9IFRoaXMgR3JhcGhpY3Mgb2JqZWN0LiBHb29kIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHNcbiAgICAgKi9cbiAgICBkcmF3UG9seWdvbihwYXRoKSB7XG4gICAgICAgIHZhciBhcmd1bWVudHMkMSA9IGFyZ3VtZW50cztcbiAgICAgICAgLy8gcHJldmVudHMgYW4gYXJndW1lbnQgYXNzaWdubWVudCBkZW9wdFxuICAgICAgICAvLyBzZWUgc2VjdGlvbiAzLjE6IGh0dHBzOi8vZ2l0aHViLmNvbS9wZXRrYWFudG9ub3YvYmx1ZWJpcmQvd2lraS9PcHRpbWl6YXRpb24ta2lsbGVycyMzLW1hbmFnaW5nLWFyZ3VtZW50c1xuICAgICAgICB2YXIgcG9pbnRzID0gcGF0aDtcbiAgICAgICAgdmFyIGNsb3NlU3Ryb2tlID0gdHJ1ZTsgLy8gISF0aGlzLl9maWxsU3R5bGU7XG4gICAgICAgIC8vIGNoZWNrIGlmIGRhdGEgaGFzIHBvaW50cy4uXG4gICAgICAgIGlmIChwb2ludHMucG9pbnRzKSB7XG4gICAgICAgICAgICBjbG9zZVN0cm9rZSA9IHBvaW50cy5jbG9zZVN0cm9rZTtcbiAgICAgICAgICAgIHBvaW50cyA9IHBvaW50cy5wb2ludHM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHBvaW50cykpIHtcbiAgICAgICAgICAgIC8vIHByZXZlbnRzIGFuIGFyZ3VtZW50IGxlYWsgZGVvcHRcbiAgICAgICAgICAgIC8vIHNlZSBzZWN0aW9uIDMuMjogaHR0cHM6Ly9naXRodWIuY29tL3BldGthYW50b25vdi9ibHVlYmlyZC93aWtpL09wdGltaXphdGlvbi1raWxsZXJzIzMtbWFuYWdpbmctYXJndW1lbnRzXG4gICAgICAgICAgICBwb2ludHMgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIHBvaW50c1tpXSA9IGFyZ3VtZW50cyQxW2ldOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHByZWZlci1yZXN0LXBhcmFtc1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBzaGFwZSA9IG5ldyBQb2x5Z29uXzEuUG9seWdvbihwb2ludHMpO1xuICAgICAgICBzaGFwZS5jbG9zZVN0cm9rZSA9IGNsb3NlU3Ryb2tlO1xuICAgICAgICB0aGlzLmRyYXdTaGFwZShzaGFwZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogRHJhdyBhbnkgc2hhcGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BJWEkuQ2lyY2xlfFBJWEkuRWxsaXBzZXxQSVhJLlBvbHlnb258UElYSS5SZWN0YW5nbGV8UElYSS5Sb3VuZGVkUmVjdGFuZ2xlfSBzaGFwZSAtIFNoYXBlIHRvIGRyYXdcbiAgICAgKiBAcmV0dXJuIHtQSVhJLkdyYXBoaWNzfSBUaGlzIEdyYXBoaWNzIG9iamVjdC4gR29vZCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzXG4gICAgICovXG4gICAgZHJhd1NoYXBlKHNoYXBlKSB7XG4gICAgICAgIGlmICghdGhpcy5faG9sZU1vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuZ2VvbWV0cnkuZHJhd1NoYXBlKHNoYXBlLCB0aGlzLl9maWxsU3R5bGUuY2xvbmUoKSwgdGhpcy5fbGluZVN0eWxlLmNsb25lKCksIHRoaXMuX21hdHJpeCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmdlb21ldHJ5LmRyYXdIb2xlKHNoYXBlLCB0aGlzLl9tYXRyaXgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogRHJhdyBhIHN0YXIgc2hhcGUgd2l0aCBhbiBhcmJpdHJhcnkgbnVtYmVyIG9mIHBvaW50cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gQ2VudGVyIFggcG9zaXRpb24gb2YgdGhlIHN0YXJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSAtIENlbnRlciBZIHBvc2l0aW9uIG9mIHRoZSBzdGFyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBvaW50cyAtIFRoZSBudW1iZXIgb2YgcG9pbnRzIG9mIHRoZSBzdGFyLCBtdXN0IGJlID4gMVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByYWRpdXMgLSBUaGUgb3V0ZXIgcmFkaXVzIG9mIHRoZSBzdGFyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtpbm5lclJhZGl1c10gLSBUaGUgaW5uZXIgcmFkaXVzIGJldHdlZW4gcG9pbnRzLCBkZWZhdWx0IGhhbGYgYHJhZGl1c2BcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3JvdGF0aW9uPTBdIC0gVGhlIHJvdGF0aW9uIG9mIHRoZSBzdGFyIGluIHJhZGlhbnMsIHdoZXJlIDAgaXMgdmVydGljYWxcbiAgICAgKiBAcmV0dXJuIHtQSVhJLkdyYXBoaWNzfSBUaGlzIEdyYXBoaWNzIG9iamVjdC4gR29vZCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzXG4gICAgICovXG4gICAgZHJhd1N0YXIoeCwgeSwgcG9pbnRzLCByYWRpdXMsIGlubmVyUmFkaXVzID0gMCwgcm90YXRpb24gPSAwKSB7XG4gICAgICAgIGlmIChyb3RhdGlvbiA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICByb3RhdGlvbiA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZHJhd1BvbHlnb24obmV3IFN0YXJfMS5TdGFyKHgsIHksIHBvaW50cywgcmFkaXVzLCBpbm5lclJhZGl1cywgcm90YXRpb24pKTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIENsZWFycyB0aGUgZ3JhcGhpY3MgdGhhdCB3ZXJlIGRyYXduIHRvIHRoaXMgR3JhcGhpY3Mgb2JqZWN0LCBhbmQgcmVzZXRzIGZpbGwgYW5kIGxpbmUgc3R5bGUgc2V0dGluZ3MuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtQSVhJLkdyYXBoaWNzfSBUaGlzIEdyYXBoaWNzIG9iamVjdC4gR29vZCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzXG4gICAgICovXG4gICAgY2xlYXIoKSB7XG4gICAgICAgIHRoaXMuZ2VvbWV0cnkuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5fbWF0cml4ID0gbnVsbDtcbiAgICAgICAgdGhpcy5faG9sZU1vZGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jdXJyZW50UGF0aCA9IG51bGw7XG4gICAgICAgIHRoaXMuX3Nwcml0ZVJlY3QgPSBudWxsO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFRydWUgaWYgZ3JhcGhpY3MgY29uc2lzdHMgb2Ygb25lIHJlY3RhbmdsZSwgYW5kIHRodXMsIGNhbiBiZSBkcmF3biBsaWtlIGEgU3ByaXRlIGFuZFxuICAgICAqIG1hc2tlZCB3aXRoIGdsLnNjaXNzb3IuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiBvbmx5IDEgcmVjdC5cbiAgICAgKi9cbiAgICBpc0Zhc3RSZWN0KCkge1xuICAgICAgICAvLyB3aWxsIGZpeCB0aGlzIVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIC8vIHRoaXMuZ3JhcGhpY3NEYXRhLmxlbmd0aCA9PT0gMVxuICAgICAgICAvLyAgJiYgdGhpcy5ncmFwaGljc0RhdGFbMF0uc2hhcGUudHlwZSA9PT0gU0hBUEVTLlJFQ1RcbiAgICAgICAgLy8gJiYgIXRoaXMuZ3JhcGhpY3NEYXRhWzBdLmxpbmVXaWR0aDtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgdGhlIG9iamVjdCB1c2luZyB0aGUgV2ViR0wgcmVuZGVyZXJcbiAgICAgKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAcGFyYW0ge1BJWEkuUmVuZGVyZXJ9IHJlbmRlcmVyIC0gVGhlIHJlbmRlcmVyXG4gICAgICovXG4gICAgX3JlbmRlcihyZW5kZXJlcikge1xuICAgICAgICB0aGlzLmZpbmlzaFBvbHkoKTtcbiAgICAgICAgdmFyIGdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeTtcbiAgICAgICAgLy8gYmF0Y2ggcGFydC4uXG4gICAgICAgIC8vIGJhdGNoIGl0IVxuICAgICAgICBnZW9tZXRyeS51cGRhdGVCYXRjaGVzKCk7XG4gICAgICAgIGlmIChnZW9tZXRyeS5iYXRjaGFibGUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmJhdGNoRGlydHkgIT09IGdlb21ldHJ5LmJhdGNoRGlydHkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJhdGNoZXMgPSBbXTtcbiAgICAgICAgICAgICAgICB0aGlzLmJhdGNoVGludCA9IC0xO1xuICAgICAgICAgICAgICAgIHRoaXMuX3RyYW5zZm9ybUlEID0gLTE7XG4gICAgICAgICAgICAgICAgdGhpcy5iYXRjaERpcnR5ID0gZ2VvbWV0cnkuYmF0Y2hEaXJ0eTtcbiAgICAgICAgICAgICAgICB0aGlzLnZlcnRleERhdGEgPSBuZXcgRmxvYXQzMkFycmF5KGdlb21ldHJ5LnBvaW50cyk7XG4gICAgICAgICAgICAgICAgdmFyIGJsZW5kTW9kZSA9IHRoaXMuYmxlbmRNb2RlO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ2VvbWV0cnkuYmF0Y2hlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZ0kgPSBnZW9tZXRyeS5iYXRjaGVzW2ldO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29sb3IgPSBnSS5zdHlsZS5jb2xvcjtcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICsgKGFscGhhICogMjU1IDw8IDI0KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZlcnRleERhdGEgPSBuZXcgRmxvYXQzMkFycmF5KHRoaXMudmVydGV4RGF0YS5idWZmZXIsIGdJLmF0dHJpYlN0YXJ0ICogNCAqIDIsIGdJLmF0dHJpYlNpemUgKiAyKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHV2cyA9IG5ldyBGbG9hdDMyQXJyYXkoZ2VvbWV0cnkudXZzRmxvYXQzMi5idWZmZXIsIGdJLmF0dHJpYlN0YXJ0ICogNCAqIDIsIGdJLmF0dHJpYlNpemUgKiAyKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZGljZXMgPSBuZXcgVWludDE2QXJyYXkoZ2VvbWV0cnkuaW5kaWNlc1VpbnQxNi5idWZmZXIsIGdJLnN0YXJ0ICogMiwgZ0kuc2l6ZSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBiYXRjaCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlcnRleERhdGE6IHZlcnRleERhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICBibGVuZE1vZGU6IGJsZW5kTW9kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGljZXM6IGluZGljZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICB1dnM6IHV2cyxcbiAgICAgICAgICAgICAgICAgICAgICAgIF9iYXRjaFJHQjogQ29sb3JTZXR0aW5nc18xLkNvbG9yU2V0dGluZ3MuaGV4MnJnYihjb2xvciksXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGludFJHQjogY29sb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGV4dHVyZTogZ0kuc3R5bGUudGV4dHVyZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFscGhhOiBnSS5zdHlsZS5hbHBoYSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdvcmxkQWxwaGE6IDFcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5iYXRjaGVzW2ldID0gYmF0Y2g7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVuZGVyZXIuYmF0Y2guc2V0T2JqZWN0UmVuZGVyZXIocmVuZGVyZXIucGx1Z2lucy5iYXRjaCk7XG4gICAgICAgICAgICBpZiAodGhpcy5iYXRjaGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2FsY3VsYXRlVmVydGljZXMoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGN1bGF0ZVRpbnRzKCk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgdGhpcy5iYXRjaGVzLmxlbmd0aDsgaSQxKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJhdGNoJDEgPSB0aGlzLmJhdGNoZXNbaSQxXTtcbiAgICAgICAgICAgICAgICAgICAgYmF0Y2gkMS53b3JsZEFscGhhID0gdGhpcy53b3JsZEFscGhhICogYmF0Y2gkMS5hbHBoYTtcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyZXIucGx1Z2lucy5iYXRjaC5yZW5kZXIoYmF0Y2gkMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gbm8gYmF0Y2hpbmcuLi5cbiAgICAgICAgICAgIHJlbmRlcmVyLmJhdGNoLmZsdXNoKCk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuc2hhZGVyKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlcmUgaXMgbm8gc2hhZGVyIGhlcmUsIHdlIGNhbiB1c2UgdGhlIGRlZmF1bHQgc2hhZGVyLlxuICAgICAgICAgICAgICAgIC8vIGFuZCB0aGF0IG9ubHkgZ2V0cyBjcmVhdGVkIGlmIHdlIGFjdHVhbGx5IG5lZWQgaXQuLlxuICAgICAgICAgICAgICAgIGlmICghR3JhcGhpY3MuZGVmYXVsdFNoYWRlcikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2FtcGxlVmFsdWVzID0gbmV3IEludDMyQXJyYXkoMTYpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpJDIgPSAwOyBpJDIgPCAxNjsgaSQyKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNhbXBsZVZhbHVlc1tpJDJdID0gaSQyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciB1bmlmb3JtcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbnQ6IG5ldyBGbG9hdDMyQXJyYXkoWzEsIDEsIDEsIDFdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zbGF0aW9uTWF0cml4OiBuZXcgTWF0cml4XzEuTWF0cml4KCksXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OiBVbmlmb3JtR3JvdXBfMS5Vbmlmb3JtR3JvdXAuZnJvbSh7IHVTYW1wbGVyczogc2FtcGxlVmFsdWVzIH0sIHRydWUpLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAvLyB3ZSBjYW4gYmJhc2UgZGVmYXVsdCBzaGFkZXIgb2YgdGhlIGJhdGNoIHJlbmRlcmVycyBwcm9ncmFtXG4gICAgICAgICAgICAgICAgICAgIHZhciBwcm9ncmFtID0gcmVuZGVyZXIucGx1Z2lucy5iYXRjaC5zaGFkZXIucHJvZ3JhbTtcbiAgICAgICAgICAgICAgICAgICAgR3JhcGhpY3MuZGVmYXVsdFNoYWRlciA9IG5ldyBTaGFkZXJfMS5TaGFkZXIocHJvZ3JhbSwgdW5pZm9ybXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnNoYWRlciA9IEdyYXBoaWNzLmRlZmF1bHRTaGFkZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdW5pZm9ybXMkMSA9IHRoaXMuc2hhZGVyLnVuaWZvcm1zO1xuICAgICAgICAgICAgLy8gbGV0cyBzZXQgdGhlIHRyYW5zZm9tclxuICAgICAgICAgICAgdW5pZm9ybXMkMS50cmFuc2xhdGlvbk1hdHJpeCA9IHRoaXMudHJhbnNmb3JtLndvcmxkVHJhbnNmb3JtO1xuICAgICAgICAgICAgdmFyIHRpbnQgPSB0aGlzLnRpbnQ7XG4gICAgICAgICAgICB2YXIgd2EgPSB0aGlzLndvcmxkQWxwaGE7XG4gICAgICAgICAgICAvLyBhbmQgdGhlbiBsZXRzIHNldCB0aGUgdGludC4uXG4gICAgICAgICAgICB1bmlmb3JtcyQxLnRpbnRbMF0gPSAoKCh0aW50ID4+IDE2KSAmIDB4RkYpIC8gMjU1KSAqIHdhO1xuICAgICAgICAgICAgdW5pZm9ybXMkMS50aW50WzFdID0gKCgodGludCA+PiA4KSAmIDB4RkYpIC8gMjU1KSAqIHdhO1xuICAgICAgICAgICAgdW5pZm9ybXMkMS50aW50WzJdID0gKCh0aW50ICYgMHhGRikgLyAyNTUpICogd2E7XG4gICAgICAgICAgICB1bmlmb3JtcyQxLnRpbnRbM10gPSB3YTtcbiAgICAgICAgICAgIC8vIHRoZSBmaXJzdCBkcmF3IGNhbGwsIHdlIGNhbiBzZXQgdGhlIHVuaWZvcm1zIG9mIHRoZSBzaGFkZXIgZGlyZWN0bHkgaGVyZS5cbiAgICAgICAgICAgIC8vIHRoaXMgbWVhbnMgdGhhdCB3ZSBjYW4gdGFjayBhZHZhbnRhZ2Ugb2YgdGhlIHN5bmMgZnVuY3Rpb24gb2YgcGl4aSFcbiAgICAgICAgICAgIC8vIGJpbmQgYW5kIHN5bmMgdW5pZm9ybXMuLlxuICAgICAgICAgICAgLy8gdGhlcmUgaXMgYSB3YXkgdG8gb3B0aW1pc2UgdGhpcy4uXG4gICAgICAgICAgICByZW5kZXJlci5zaGFkZXIuYmluZCh0aGlzLnNoYWRlcik7XG4gICAgICAgICAgICAvLyB0aGVuIHJlbmRlciBpdFxuICAgICAgICAgICAgcmVuZGVyZXIuZ2VvbWV0cnkuYmluZChnZW9tZXRyeSwgdGhpcy5zaGFkZXIpO1xuICAgICAgICAgICAgLy8gc2V0IHN0YXRlLi5cbiAgICAgICAgICAgIHJlbmRlcmVyLnN0YXRlLnNldFN0YXRlKHRoaXMuc3RhdGUpO1xuICAgICAgICAgICAgLy8gdGhlbiByZW5kZXIgdGhlIHJlc3Qgb2YgdGhlbS4uLlxuICAgICAgICAgICAgZm9yICh2YXIgaSQzID0gMDsgaSQzIDwgZ2VvbWV0cnkuZHJhd0NhbGxzLmxlbmd0aDsgaSQzKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgZHJhd0NhbGwgPSBnZW9tZXRyeS5kcmF3Q2FsbHNbaSQzXTtcbiAgICAgICAgICAgICAgICB2YXIgZ3JvdXBUZXh0dXJlQ291bnQgPSBkcmF3Q2FsbC50ZXh0dXJlQ291bnQ7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBncm91cFRleHR1cmVDb3VudDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbmRlcmVyLnRleHR1cmUuYmluZChkcmF3Q2FsbC50ZXh0dXJlc1tqXSwgaik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGJpbmQgdGhlIGdlb21ldHJ5Li4uXG4gICAgICAgICAgICAgICAgcmVuZGVyZXIuZ2VvbWV0cnkuZHJhdyhkcmF3Q2FsbC50eXBlLCBkcmF3Q2FsbC5zaXplLCBkcmF3Q2FsbC5zdGFydCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgYm91bmRzIG9mIHRoZSBncmFwaGljIHNoYXBlIGFzIGEgcmVjdGFuZ2xlIG9iamVjdFxuICAgICAqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9jYWxjdWxhdGVCb3VuZHMoKSB7XG4gICAgICAgIHRoaXMuZmluaXNoUG9seSgpO1xuICAgICAgICB2YXIgbGIgPSB0aGlzLmdlb21ldHJ5LmJvdW5kcztcbiAgICAgICAgdGhpcy5fYm91bmRzLmFkZEZyYW1lKHRoaXMudHJhbnNmb3JtLCBsYi5taW5YLCBsYi5taW5ZLCBsYi5tYXhYLCBsYi5tYXhZKTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFRlc3RzIGlmIGEgcG9pbnQgaXMgaW5zaWRlIHRoaXMgZ3JhcGhpY3Mgb2JqZWN0XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BJWEkuUG9pbnR9IHBvaW50IC0gdGhlIHBvaW50IHRvIHRlc3RcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSB0aGUgcmVzdWx0IG9mIHRoZSB0ZXN0XG4gICAgICovXG4gICAgY29udGFpbnNQb2ludChwb2ludCkge1xuICAgICAgICBsZXQgZGVmYXVsdHBvaW50ID0gUG9pbnRfMS5Qb2ludC5ERUZBVUxUO1xuICAgICAgICB0aGlzLndvcmxkVHJhbnNmb3JtLmFwcGx5SW52ZXJzZShwb2ludCwgZGVmYXVsdHBvaW50KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2VvbWV0cnkuY29udGFpbnNQb2ludChkZWZhdWx0cG9pbnQpO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogUmVjYWxjdWF0ZSB0aGUgdGludCBieSBhcHBseWluZyB0aW4gdG8gYmF0Y2hlcyB1c2luZyBHcmFwaGljcyB0aW50LlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBjYWxjdWxhdGVUaW50cygpIHtcbiAgICAgICAgaWYgKHRoaXMuYmF0Y2hUaW50ICE9PSB0aGlzLnRpbnQpIHtcbiAgICAgICAgICAgIHRoaXMuYmF0Y2hUaW50ID0gdGhpcy50aW50O1xuICAgICAgICAgICAgdmFyIHRpbnRSR0IgPSBDb2xvclNldHRpbmdzXzEuQ29sb3JTZXR0aW5ncy5oZXgycmdiKHRoaXMudGludCwgR3JhcGhpY3MudGVtcCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYmF0Y2hlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBiYXRjaCA9IHRoaXMuYmF0Y2hlc1tpXTtcbiAgICAgICAgICAgICAgICB2YXIgYmF0Y2hUaW50ID0gYmF0Y2guX2JhdGNoUkdCO1xuICAgICAgICAgICAgICAgIHZhciByID0gKHRpbnRSR0JbMF0gKiBiYXRjaFRpbnRbMF0pICogMjU1O1xuICAgICAgICAgICAgICAgIHZhciBnID0gKHRpbnRSR0JbMV0gKiBiYXRjaFRpbnRbMV0pICogMjU1O1xuICAgICAgICAgICAgICAgIHZhciBiID0gKHRpbnRSR0JbMl0gKiBiYXRjaFRpbnRbMl0pICogMjU1O1xuICAgICAgICAgICAgICAgIC8vIFRPRE8gSXZhbiwgY2FuIHRoaXMgYmUgZG9uZSBpbiBvbmUgZ28/XG4gICAgICAgICAgICAgICAgdmFyIGNvbG9yID0gKHIgPDwgMTYpICsgKGcgPDwgOCkgKyAoYiB8IDApO1xuICAgICAgICAgICAgICAgIGJhdGNoLl90aW50UkdCID0gKGNvbG9yID4+IDE2KVxuICAgICAgICAgICAgICAgICAgICArIChjb2xvciAmIDB4ZmYwMClcbiAgICAgICAgICAgICAgICAgICAgKyAoKGNvbG9yICYgMHhmZikgPDwgMTYpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBJZiB0aGVyZSdzIGEgdHJhbnNmb3JtIHVwZGF0ZSBvciBhIGNoYW5nZSB0byB0aGUgc2hhcGUgb2YgdGhlXG4gICAgICogZ2VvbWV0cnksIHJlY2FjdWxhdGUgdGhlIHZlcnRpY2VzLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBjYWxjdWxhdGVWZXJ0aWNlcygpIHtcbiAgICAgICAgaWYgKHRoaXMuX3RyYW5zZm9ybUlEID09PSB0aGlzLnRyYW5zZm9ybS53b3JsZElEKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdHJhbnNmb3JtSUQgPSB0aGlzLnRyYW5zZm9ybS53b3JsZElEO1xuICAgICAgICB2YXIgd3QgPSB0aGlzLnRyYW5zZm9ybS53b3JsZFRyYW5zZm9ybTtcbiAgICAgICAgdmFyIGEgPSB3dC5hO1xuICAgICAgICB2YXIgYiA9IHd0LmI7XG4gICAgICAgIHZhciBjID0gd3QuYztcbiAgICAgICAgdmFyIGQgPSB3dC5kO1xuICAgICAgICB2YXIgdHggPSB3dC50eDtcbiAgICAgICAgdmFyIHR5ID0gd3QudHk7XG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5nZW9tZXRyeS5wb2ludHM7IC8vIGJhdGNoLnZlcnRleERhdGFPcmlnaW5hbDtcbiAgICAgICAgdmFyIHZlcnRleERhdGEgPSB0aGlzLnZlcnRleERhdGE7XG4gICAgICAgIHZhciBjb3VudCA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgdmFyIHggPSBkYXRhW2ldO1xuICAgICAgICAgICAgdmFyIHkgPSBkYXRhW2kgKyAxXTtcbiAgICAgICAgICAgIHZlcnRleERhdGFbY291bnQrK10gPSAoYSAqIHgpICsgKGMgKiB5KSArIHR4O1xuICAgICAgICAgICAgdmVydGV4RGF0YVtjb3VudCsrXSA9IChkICogeSkgKyAoYiAqIHgpICsgdHk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIENsb3NlcyB0aGUgY3VycmVudCBwYXRoLlxuICAgICAqXG4gICAgICogQHJldHVybiB7UElYSS5HcmFwaGljc30gUmV0dXJucyBpdHNlbGYuXG4gICAgICovXG4gICAgY2xvc2VQYXRoKCkge1xuICAgICAgICB2YXIgY3VycmVudFBhdGggPSB0aGlzLmN1cnJlbnRQYXRoO1xuICAgICAgICBpZiAoY3VycmVudFBhdGgpIHtcbiAgICAgICAgICAgIC8vIHdlIGRvbid0IG5lZWQgdG8gYWRkIGV4dHJhIHBvaW50IGluIHRoZSBlbmQgYmVjYXVzZSBidWlsZExpbmUgd2lsbCB0YWtlIGNhcmUgb2YgdGhhdFxuICAgICAgICAgICAgY3VycmVudFBhdGguY2xvc2VTdHJva2UgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogQXBwbHkgYSBtYXRyaXggdG8gdGhlIHBvc2l0aW9uYWwgZGF0YS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UElYSS5NYXRyaXh9IG1hdHJpeCAtIE1hdHJpeCB0byB1c2UgZm9yIHRyYW5zZm9ybSBjdXJyZW50IHNoYXBlLlxuICAgICAqIEByZXR1cm4ge1BJWEkuR3JhcGhpY3N9IFJldHVybnMgaXRzZWxmLlxuICAgICAqL1xuICAgIHNldE1hdHJpeChtYXRyaXgpIHtcbiAgICAgICAgdGhpcy5fbWF0cml4ID0gbWF0cml4O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIEJlZ2luIGFkZGluZyBob2xlcyB0byB0aGUgbGFzdCBkcmF3IHNoYXBlXG4gICAgICogSU1QT1JUQU5UOiBob2xlcyBtdXN0IGJlIGZ1bGx5IGluc2lkZSBhIHNoYXBlIHRvIHdvcmtcbiAgICAgKiBBbHNvIHdlaXJkbmVzcyBlbnN1ZXMgaWYgaG9sZXMgb3ZlcmxhcCFcbiAgICAgKiBFbGxpcHNlcywgQ2lyY2xlcywgUmVjdGFuZ2xlcyBhbmQgUm91bmRlZCBSZWN0YW5nbGVzIGNhbm5vdCBiZSBob2xlcyBvciBob3N0IGZvciBob2xlcyBpbiBDYW52YXNSZW5kZXJlcixcbiAgICAgKiBwbGVhc2UgdXNlIGBtb3ZlVG9gIGBsaW5lVG9gLCBgcXVhZHJhdGljQ3VydmVUb2AgaWYgeW91IHJlbHkgb24gcGl4aS1sZWdhY3kgYnVuZGxlLlxuICAgICAqIEByZXR1cm4ge1BJWEkuR3JhcGhpY3N9IFJldHVybnMgaXRzZWxmLlxuICAgICAqL1xuICAgIGJlZ2luSG9sZSgpIHtcbiAgICAgICAgdGhpcy5maW5pc2hQb2x5KCk7XG4gICAgICAgIHRoaXMuX2hvbGVNb2RlID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBFbmQgYWRkaW5nIGhvbGVzIHRvIHRoZSBsYXN0IGRyYXcgc2hhcGVcbiAgICAgKiBAcmV0dXJuIHtQSVhJLkdyYXBoaWNzfSBSZXR1cm5zIGl0c2VsZi5cbiAgICAgKi9cbiAgICBlbmRIb2xlKCkge1xuICAgICAgICB0aGlzLmZpbmlzaFBvbHkoKTtcbiAgICAgICAgdGhpcy5faG9sZU1vZGUgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBEZXN0cm95cyB0aGUgR3JhcGhpY3Mgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R8Ym9vbGVhbn0gW29wdGlvbnNdIC0gT3B0aW9ucyBwYXJhbWV0ZXIuIEEgYm9vbGVhbiB3aWxsIGFjdCBhcyBpZiBhbGxcbiAgICAgKiAgb3B0aW9ucyBoYXZlIGJlZW4gc2V0IHRvIHRoYXQgdmFsdWVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmNoaWxkcmVuPWZhbHNlXSAtIGlmIHNldCB0byB0cnVlLCBhbGwgdGhlIGNoaWxkcmVuIHdpbGwgaGF2ZVxuICAgICAqICB0aGVpciBkZXN0cm95IG1ldGhvZCBjYWxsZWQgYXMgd2VsbC4gJ29wdGlvbnMnIHdpbGwgYmUgcGFzc2VkIG9uIHRvIHRob3NlIGNhbGxzLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudGV4dHVyZT1mYWxzZV0gLSBPbmx5IHVzZWQgZm9yIGNoaWxkIFNwcml0ZXMgaWYgb3B0aW9ucy5jaGlsZHJlbiBpcyBzZXQgdG8gdHJ1ZVxuICAgICAqICBTaG91bGQgaXQgZGVzdHJveSB0aGUgdGV4dHVyZSBvZiB0aGUgY2hpbGQgc3ByaXRlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5iYXNlVGV4dHVyZT1mYWxzZV0gLSBPbmx5IHVzZWQgZm9yIGNoaWxkIFNwcml0ZXMgaWYgb3B0aW9ucy5jaGlsZHJlbiBpcyBzZXQgdG8gdHJ1ZVxuICAgICAqICBTaG91bGQgaXQgZGVzdHJveSB0aGUgYmFzZSB0ZXh0dXJlIG9mIHRoZSBjaGlsZCBzcHJpdGVcbiAgICAgKi9cbiAgICBkZXN0cm95KG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIuZGVzdHJveShvcHRpb25zKTtcbiAgICAgICAgdGhpcy5nZW9tZXRyeS5yZWZDb3VudC0tO1xuICAgICAgICBpZiAodGhpcy5nZW9tZXRyeS5yZWZDb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5nZW9tZXRyeS5kaXNwb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbWF0cml4ID0gbnVsbDtcbiAgICAgICAgdGhpcy5jdXJyZW50UGF0aCA9IG51bGw7XG4gICAgICAgIHRoaXMuX2xpbmVTdHlsZS5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuX2xpbmVTdHlsZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX2ZpbGxTdHlsZS5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuX2ZpbGxTdHlsZSA9IG51bGw7XG4gICAgICAgIHRoaXMuZ2VvbWV0cnkgPSBudWxsO1xuICAgICAgICB0aGlzLnNoYWRlciA9IG51bGw7XG4gICAgICAgIHRoaXMudmVydGV4RGF0YSA9IG51bGw7XG4gICAgICAgIHRoaXMuYmF0Y2hlcy5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLmJhdGNoZXMgPSBudWxsO1xuICAgICAgICBzdXBlci5kZXN0cm95KG9wdGlvbnMpO1xuICAgIH1cbiAgICA7XG59XG5HcmFwaGljcy50ZW1wID0gbmV3IEZsb2F0MzJBcnJheShbMSwgMSwgMV0pO1xuR3JhcGhpY3MuZGVmYXVsdFNoYWRlciA9IG51bGw7XG5leHBvcnRzLkdyYXBoaWNzID0gR3JhcGhpY3M7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNsYXNzIEdyYXBoaWNzRGF0YSB7XG4gICAgY29uc3RydWN0b3Ioc2hhcGUsIGZpbGxTdHlsZSA9IG51bGwsIGxpbmVTdHlsZSA9IG51bGwsIG1hdHJpeCA9IG51bGwpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBzaGFwZSBvYmplY3QgdG8gZHJhdy5cbiAgICAgICAgICogQG1lbWJlciB7UElYSS5DaXJjbGV8UElYSS5FbGxpcHNlfFBJWEkuUG9seWdvbnxQSVhJLlJlY3RhbmdsZXxQSVhJLlJvdW5kZWRSZWN0YW5nbGV9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNoYXBlID0gc2hhcGU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgc3R5bGUgb2YgdGhlIGxpbmUuXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuTGluZVN0eWxlfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5saW5lU3R5bGUgPSBsaW5lU3R5bGU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgc3R5bGUgb2YgdGhlIGZpbGwuXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuRmlsbFN0eWxlfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5maWxsU3R5bGUgPSBmaWxsU3R5bGU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdHJhbnNmb3JtIG1hdHJpeC5cbiAgICAgICAgICogQG1lbWJlciB7UElYSS5NYXRyaXh9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm1hdHJpeCA9IG1hdHJpeDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0eXBlIG9mIHRoZSBzaGFwZSwgc2VlIHRoZSBDb25zdC5TaGFwZXMgZmlsZSBmb3IgYWxsIHRoZSBleGlzdGluZyB0eXBlcyxcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50eXBlID0gc2hhcGUudHlwZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjb2xsZWN0aW9uIG9mIHBvaW50cy5cbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyW119XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnBvaW50cyA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGNvbGxlY3Rpb24gb2YgaG9sZXMuXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuR3JhcGhpY3NEYXRhW119XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmhvbGVzID0gW107XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgR3JhcGhpY3NEYXRhIG9iamVjdCB3aXRoIHRoZSBzYW1lIHZhbHVlcyBhcyB0aGlzIG9uZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1BJWEkuR3JhcGhpY3NEYXRhfSBDbG9uZWQgR3JhcGhpY3NEYXRhIG9iamVjdFxuICAgICAqL1xuICAgIGNsb25lKCkge1xuICAgICAgICByZXR1cm4gbmV3IEdyYXBoaWNzRGF0YSh0aGlzLnNoYXBlLCB0aGlzLmZpbGxTdHlsZSwgdGhpcy5saW5lU3R5bGUsIHRoaXMubWF0cml4KTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIERlc3Ryb3lzIHRoZSBHcmFwaGljcyBkYXRhLlxuICAgICAqL1xuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuc2hhcGUgPSBudWxsO1xuICAgICAgICB0aGlzLmhvbGVzLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMuaG9sZXMgPSBudWxsO1xuICAgICAgICB0aGlzLnBvaW50cy5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLnBvaW50cyA9IG51bGw7XG4gICAgICAgIHRoaXMubGluZVN0eWxlID0gbnVsbDtcbiAgICAgICAgdGhpcy5maWxsU3R5bGUgPSBudWxsO1xuICAgIH1cbiAgICA7XG59XG5leHBvcnRzLkdyYXBoaWNzRGF0YSA9IEdyYXBoaWNzRGF0YTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgQmF0Y2hHZW9tZXRyeV8xID0gcmVxdWlyZShcIi4vQmF0Y2hHZW9tZXRyeVwiKTtcbmNvbnN0IEJvdW5kc18xID0gcmVxdWlyZShcIi4vQm91bmRzXCIpO1xuY29uc3QgR3JhcGhpY3NEYXRhXzEgPSByZXF1aXJlKFwiLi9HcmFwaGljc0RhdGFcIik7XG5jb25zdCBCYXNlVGV4dHVyZV8xID0gcmVxdWlyZShcIi4vQmFzZVRleHR1cmVcIik7XG5jb25zdCBCYXRjaERyYXdDYWxsXzEgPSByZXF1aXJlKFwiLi9CYXRjaERyYXdDYWxsXCIpO1xuY29uc3QgUG9pbnRfMSA9IHJlcXVpcmUoXCIuLi9mbGFzaC9nZW9tL1BvaW50XCIpO1xuY29uc3QgU2hhcGVTZXR0aW5nc18xID0gcmVxdWlyZShcIi4vU2hhcGVTZXR0aW5nc1wiKTtcbmNvbnN0IERyYXdNb2RlU2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL0RyYXdNb2RlU2V0dGluZ3NcIik7XG5jb25zdCBDb2xvclNldHRpbmdzXzEgPSByZXF1aXJlKFwiLi9Db2xvclNldHRpbmdzXCIpO1xuY2xhc3MgQmF0Y2hQYXJ0IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5zdHlsZSA9IG51bGw7XG4gICAgICAgIHRoaXMuc2l6ZSA9IDA7XG4gICAgICAgIHRoaXMuc3RhcnQgPSAwO1xuICAgICAgICB0aGlzLmF0dHJpYlN0YXJ0ID0gMDtcbiAgICAgICAgdGhpcy5hdHRyaWJTaXplID0gMDtcbiAgICB9XG59XG5jbGFzcyBHcmFwaGljc0dlb21ldHJ5IGV4dGVuZHMgQmF0Y2hHZW9tZXRyeV8xLkJhdGNoR2VvbWV0cnkge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQW4gYXJyYXkgb2YgcG9pbnRzIHRvIGRyYXdcbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7UElYSS5Qb2ludFtdfVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnBvaW50cyA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGNvbGxlY3Rpb24gb2YgY29sb3JzXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcltdfVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNvbG9ycyA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIFVWcyBjb2xsZWN0aW9uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcltdfVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnV2cyA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGluZGljZXMgb2YgdGhlIHZlcnRpY2VzXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcltdfVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmluZGljZXMgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlZmVyZW5jZSB0byB0aGUgdGV4dHVyZSBJRHMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcltdfVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRleHR1cmVJZHMgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjb2xsZWN0aW9uIG9mIGRyYXduIHNoYXBlcy5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7UElYSS5HcmFwaGljc0RhdGFbXX1cbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5ncmFwaGljc0RhdGEgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVzZWQgdG8gZGV0ZWN0IGlmIHRoZSBncmFwaGljcyBvYmplY3QgaGFzIGNoYW5nZWQuIElmIHRoaXMgaXMgc2V0IHRvIHRydWUgdGhlbiB0aGUgZ3JhcGhpY3NcbiAgICAgICAgICogb2JqZWN0IHdpbGwgYmUgcmVjYWxjdWxhdGVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGlydHkgPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgICogQmF0Y2hlcyBuZWVkIHRvIHJlZ2VuZXJhdGVkIGlmIHRoZSBnZW9tZXRyeSBpcyB1cGRhdGVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYmF0Y2hEaXJ0eSA9IC0xO1xuICAgICAgICAvKipcbiAgICAgICAgICogVXNlZCB0byBjaGVjayBpZiB0aGUgY2FjaGUgaXMgZGlydHkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jYWNoZURpcnR5ID0gLTE7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVc2VkIHRvIGRldGVjdCBpZiB3ZSBjbGVhciB0aGUgZ3JhcGhpY3MgV2ViR0wgZGF0YS5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAwXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2xlYXJEaXJ0eSA9IDA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMaXN0IG9mIGN1cnJlbnQgZHJhdyBjYWxscyBkcml2ZWQgZnJvbSB0aGUgYmF0Y2hlcy5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7b2JqZWN0W119XG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZHJhd0NhbGxzID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbnRlcm1lZGlhdGUgYWJzdHJhY3QgZm9ybWF0IHNlbnQgdG8gYmF0Y2ggc3lzdGVtLlxuICAgICAgICAgKiBDYW4gYmUgY29udmVydGVkIHRvIGRyYXdDYWxscyBvciB0byBiYXRjaGFibGUgb2JqZWN0cy5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7b2JqZWN0W119XG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYmF0Y2hlcyA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgICogSW5kZXggb2YgdGhlIGN1cnJlbnQgbGFzdCBzaGFwZSBpbiB0aGUgc3RhY2sgb2YgY2FsbHMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zaGFwZUluZGV4ID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhY2hlZCBib3VuZHMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuQm91bmRzfVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9ib3VuZHMgPSBuZXcgQm91bmRzXzEuQm91bmRzKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgYm91bmRzIGRpcnR5IGZsYWcuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5ib3VuZHNEaXJ0eSA9IC0xO1xuICAgICAgICAvKipcbiAgICAgICAgICogUGFkZGluZyB0byBhZGQgdG8gdGhlIGJvdW5kcy5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAwXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmJvdW5kc1BhZGRpbmcgPSAwO1xuICAgICAgICB0aGlzLmJhdGNoYWJsZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmluZGljZXNVaW50MTYgPSBudWxsO1xuICAgICAgICB0aGlzLnV2c0Zsb2F0MzIgPSBudWxsO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0RmlsbENvbW1hbmQodHlwZSkge1xuICAgICAgICBpZiAoIUdyYXBoaWNzR2VvbWV0cnkuZmlsbENvbW1hbmRzKSB7XG4gICAgICAgICAgICBHcmFwaGljc0dlb21ldHJ5LmZpbGxDb21tYW5kcyA9IHt9O1xuICAgICAgICAgICAgR3JhcGhpY3NHZW9tZXRyeS5maWxsQ29tbWFuZHNbU2hhcGVTZXR0aW5nc18xLlNoYXBlU2V0dGluZ3MuU0hBUEVTLlBPTFldID0gR3JhcGhpY3NHZW9tZXRyeS5idWlsZFBvbHk7XG4gICAgICAgICAgICBHcmFwaGljc0dlb21ldHJ5LmZpbGxDb21tYW5kc1tTaGFwZVNldHRpbmdzXzEuU2hhcGVTZXR0aW5ncy5TSEFQRVMuQ0lSQ10gPSBHcmFwaGljc0dlb21ldHJ5LmJ1aWxkQ2lyY2xlO1xuICAgICAgICAgICAgR3JhcGhpY3NHZW9tZXRyeS5maWxsQ29tbWFuZHNbU2hhcGVTZXR0aW5nc18xLlNoYXBlU2V0dGluZ3MuU0hBUEVTLkVMSVBdID0gR3JhcGhpY3NHZW9tZXRyeS5idWlsZENpcmNsZTtcbiAgICAgICAgICAgIEdyYXBoaWNzR2VvbWV0cnkuZmlsbENvbW1hbmRzW1NoYXBlU2V0dGluZ3NfMS5TaGFwZVNldHRpbmdzLlNIQVBFUy5SRUNUXSA9IEdyYXBoaWNzR2VvbWV0cnkuYnVpbGRSZWN0YW5nbGU7XG4gICAgICAgICAgICBHcmFwaGljc0dlb21ldHJ5LmZpbGxDb21tYW5kc1tTaGFwZVNldHRpbmdzXzEuU2hhcGVTZXR0aW5ncy5TSEFQRVMuUlJFQ10gPSBHcmFwaGljc0dlb21ldHJ5LmJ1aWxkUm91bmRlZFJlY3RhbmdsZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gR3JhcGhpY3NHZW9tZXRyeS5maWxsQ29tbWFuZHNbdHlwZV07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY3VycmVudCBib3VuZHMgb2YgdGhlIGdyYXBoaWMgZ2VvbWV0cnkuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtQSVhJLkJvdW5kc31cbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKi9cbiAgICBnZXQgYm91bmRzKCkge1xuICAgICAgICBpZiAodGhpcy5ib3VuZHNEaXJ0eSAhPT0gdGhpcy5kaXJ0eSkge1xuICAgICAgICAgICAgdGhpcy5ib3VuZHNEaXJ0eSA9IHRoaXMuZGlydHk7XG4gICAgICAgICAgICB0aGlzLmNhbGN1bGF0ZUJvdW5kcygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9ib3VuZHM7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBDbGVhcnMgdGhlIGdyYXBoaWNzIHRoYXQgd2VyZSBkcmF3biB0byB0aGlzIEdyYXBoaWNzIG9iamVjdCwgYW5kIHJlc2V0cyBmaWxsIGFuZCBsaW5lIHN0eWxlIHNldHRpbmdzLlxuICAgICAqXG4gICAgICogQHJldHVybiB7UElYSS5HcmFwaGljc0dlb21ldHJ5fSBUaGlzIEdyYXBoaWNzR2VvbWV0cnkgb2JqZWN0LiBHb29kIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHNcbiAgICAgKi9cbiAgICBjbGVhcigpIHtcbiAgICAgICAgaWYgKHRoaXMuZ3JhcGhpY3NEYXRhLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuYm91bmRzRGlydHkgPSAtMTtcbiAgICAgICAgICAgIHRoaXMuZGlydHkrKztcbiAgICAgICAgICAgIHRoaXMuY2xlYXJEaXJ0eSsrO1xuICAgICAgICAgICAgdGhpcy5iYXRjaERpcnR5Kys7XG4gICAgICAgICAgICB0aGlzLmdyYXBoaWNzRGF0YS5sZW5ndGggPSAwO1xuICAgICAgICAgICAgdGhpcy5zaGFwZUluZGV4ID0gMDtcbiAgICAgICAgICAgIHRoaXMucG9pbnRzLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICB0aGlzLmNvbG9ycy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgdGhpcy51dnMubGVuZ3RoID0gMDtcbiAgICAgICAgICAgIHRoaXMuaW5kaWNlcy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgdGhpcy50ZXh0dXJlSWRzLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZHJhd0NhbGxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kcmF3Q2FsbHNbaV0udGV4dHVyZXMubGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICBHcmFwaGljc0dlb21ldHJ5LkRSQVdfQ0FMTF9QT09MLnB1c2godGhpcy5kcmF3Q2FsbHNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5kcmF3Q2FsbHMubGVuZ3RoID0gMDtcbiAgICAgICAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IHRoaXMuYmF0Y2hlcy5sZW5ndGg7IGkkMSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGJhdGNoID0gdGhpcy5iYXRjaGVzW2kkMV07XG4gICAgICAgICAgICAgICAgYmF0Y2guc3RhcnQgPSAwO1xuICAgICAgICAgICAgICAgIGJhdGNoLmF0dHJpYlN0YXJ0ID0gMDtcbiAgICAgICAgICAgICAgICBiYXRjaC5zdHlsZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgR3JhcGhpY3NHZW9tZXRyeS5CQVRDSF9QT09MLnB1c2goYmF0Y2gpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5iYXRjaGVzLmxlbmd0aCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBEcmF3cyB0aGUgZ2l2ZW4gc2hhcGUgdG8gdGhpcyBHcmFwaGljcyBvYmplY3QuIENhbiBiZSBhbnkgb2YgQ2lyY2xlLCBSZWN0YW5nbGUsIEVsbGlwc2UsIExpbmUgb3IgUG9seWdvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UElYSS5DaXJjbGV8UElYSS5FbGxpcHNlfFBJWEkuUG9seWdvbnxQSVhJLlJlY3RhbmdsZXxQSVhJLlJvdW5kZWRSZWN0YW5nbGV9IHNoYXBlIC0gVGhlIHNoYXBlIG9iamVjdCB0byBkcmF3LlxuICAgICAqIEBwYXJhbSB7UElYSS5GaWxsU3R5bGV9IGZpbGxTdHlsZSAtIERlZmluZXMgc3R5bGUgb2YgdGhlIGZpbGwuXG4gICAgICogQHBhcmFtIHtQSVhJLkxpbmVTdHlsZX0gbGluZVN0eWxlIC0gRGVmaW5lcyBzdHlsZSBvZiB0aGUgbGluZXMuXG4gICAgICogQHBhcmFtIHtQSVhJLk1hdHJpeH0gbWF0cml4IC0gVHJhbnNmb3JtIGFwcGxpZWQgdG8gdGhlIHBvaW50cyBvZiB0aGUgc2hhcGUuXG4gICAgICogQHJldHVybiB7UElYSS5HcmFwaGljc0dlb21ldHJ5fSBSZXR1cm5zIGdlb21ldHJ5IGZvciBjaGFpbmluZy5cbiAgICAgKi9cbiAgICBkcmF3U2hhcGUoc2hhcGUsIGZpbGxTdHlsZSwgbGluZVN0eWxlLCBtYXRyaXgpIHtcbiAgICAgICAgdmFyIGRhdGEgPSBuZXcgR3JhcGhpY3NEYXRhXzEuR3JhcGhpY3NEYXRhKHNoYXBlLCBmaWxsU3R5bGUsIGxpbmVTdHlsZSwgbWF0cml4KTtcbiAgICAgICAgdGhpcy5ncmFwaGljc0RhdGEucHVzaChkYXRhKTtcbiAgICAgICAgdGhpcy5kaXJ0eSsrO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIERyYXdzIHRoZSBnaXZlbiBzaGFwZSB0byB0aGlzIEdyYXBoaWNzIG9iamVjdC4gQ2FuIGJlIGFueSBvZiBDaXJjbGUsIFJlY3RhbmdsZSwgRWxsaXBzZSwgTGluZSBvciBQb2x5Z29uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQSVhJLkNpcmNsZXxQSVhJLkVsbGlwc2V8UElYSS5Qb2x5Z29ufFBJWEkuUmVjdGFuZ2xlfFBJWEkuUm91bmRlZFJlY3RhbmdsZX0gc2hhcGUgLSBUaGUgc2hhcGUgb2JqZWN0IHRvIGRyYXcuXG4gICAgICogQHBhcmFtIHtQSVhJLk1hdHJpeH0gbWF0cml4IC0gVHJhbnNmb3JtIGFwcGxpZWQgdG8gdGhlIHBvaW50cyBvZiB0aGUgc2hhcGUuXG4gICAgICogQHJldHVybiB7UElYSS5HcmFwaGljc0dlb21ldHJ5fSBSZXR1cm5zIGdlb21ldHJ5IGZvciBjaGFpbmluZy5cbiAgICAgKi9cbiAgICBkcmF3SG9sZShzaGFwZSwgbWF0cml4KSB7XG4gICAgICAgIGlmICghdGhpcy5ncmFwaGljc0RhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGF0YSA9IG5ldyBHcmFwaGljc0RhdGFfMS5HcmFwaGljc0RhdGEoc2hhcGUsIG51bGwsIG51bGwsIG1hdHJpeCk7XG4gICAgICAgIHZhciBsYXN0U2hhcGUgPSB0aGlzLmdyYXBoaWNzRGF0YVt0aGlzLmdyYXBoaWNzRGF0YS5sZW5ndGggLSAxXTtcbiAgICAgICAgZGF0YS5saW5lU3R5bGUgPSBsYXN0U2hhcGUubGluZVN0eWxlO1xuICAgICAgICBsYXN0U2hhcGUuaG9sZXMucHVzaChkYXRhKTtcbiAgICAgICAgdGhpcy5kaXJ0eSsrO1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIERlc3Ryb3lzIHRoZSBHcmFwaGljcyBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdHxib29sZWFufSBbb3B0aW9uc10gLSBPcHRpb25zIHBhcmFtZXRlci4gQSBib29sZWFuIHdpbGwgYWN0IGFzIGlmIGFsbFxuICAgICAqICBvcHRpb25zIGhhdmUgYmVlbiBzZXQgdG8gdGhhdCB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuY2hpbGRyZW49ZmFsc2VdIC0gaWYgc2V0IHRvIHRydWUsIGFsbCB0aGUgY2hpbGRyZW4gd2lsbCBoYXZlXG4gICAgICogIHRoZWlyIGRlc3Ryb3kgbWV0aG9kIGNhbGxlZCBhcyB3ZWxsLiAnb3B0aW9ucycgd2lsbCBiZSBwYXNzZWQgb24gdG8gdGhvc2UgY2FsbHMuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50ZXh0dXJlPWZhbHNlXSAtIE9ubHkgdXNlZCBmb3IgY2hpbGQgU3ByaXRlcyBpZiBvcHRpb25zLmNoaWxkcmVuIGlzIHNldCB0byB0cnVlXG4gICAgICogIFNob3VsZCBpdCBkZXN0cm95IHRoZSB0ZXh0dXJlIG9mIHRoZSBjaGlsZCBzcHJpdGVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmJhc2VUZXh0dXJlPWZhbHNlXSAtIE9ubHkgdXNlZCBmb3IgY2hpbGQgU3ByaXRlcyBpZiBvcHRpb25zLmNoaWxkcmVuIGlzIHNldCB0byB0cnVlXG4gICAgICogIFNob3VsZCBpdCBkZXN0cm95IHRoZSBiYXNlIHRleHR1cmUgb2YgdGhlIGNoaWxkIHNwcml0ZVxuICAgICAqL1xuICAgIGRlc3Ryb3kob3B0aW9ucykge1xuICAgICAgICBzdXBlci5kZXN0cm95KG9wdGlvbnMpO1xuICAgICAgICAvLyBkZXN0cm95IGVhY2ggb2YgdGhlIEdyYXBoaWNzRGF0YSBvYmplY3RzXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5ncmFwaGljc0RhdGEubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHRoaXMuZ3JhcGhpY3NEYXRhW2ldLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBvaW50cy5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLnBvaW50cyA9IG51bGw7XG4gICAgICAgIHRoaXMuY29sb3JzLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMuY29sb3JzID0gbnVsbDtcbiAgICAgICAgdGhpcy51dnMubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy51dnMgPSBudWxsO1xuICAgICAgICB0aGlzLmluZGljZXMubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5pbmRpY2VzID0gbnVsbDtcbiAgICAgICAgdGhpcy5pbmRleEJ1ZmZlci5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuaW5kZXhCdWZmZXIgPSBudWxsO1xuICAgICAgICB0aGlzLmdyYXBoaWNzRGF0YS5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLmdyYXBoaWNzRGF0YSA9IG51bGw7XG4gICAgICAgIHRoaXMuZHJhd0NhbGxzLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMuZHJhd0NhbGxzID0gbnVsbDtcbiAgICAgICAgdGhpcy5iYXRjaGVzLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMuYmF0Y2hlcyA9IG51bGw7XG4gICAgICAgIHRoaXMuX2JvdW5kcyA9IG51bGw7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBDaGVjayB0byBzZWUgaWYgYSBwb2ludCBpcyBjb250YWluZWQgd2l0aGluIHRoaXMgZ2VvbWV0cnkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BJWEkuUG9pbnR9IHBvaW50IC0gUG9pbnQgdG8gY2hlY2sgaWYgaXQncyBjb250YWluZWQuXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gYHRydWVgIGlmIHRoZSBwb2ludCBpcyBjb250YWluZWQgd2l0aGluIGdlb21ldHJ5LlxuICAgICAqL1xuICAgIGNvbnRhaW5zUG9pbnQocG9pbnQpIHtcbiAgICAgICAgdmFyIGdyYXBoaWNzRGF0YSA9IHRoaXMuZ3JhcGhpY3NEYXRhO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdyYXBoaWNzRGF0YS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIGRhdGEgPSBncmFwaGljc0RhdGFbaV07XG4gICAgICAgICAgICBpZiAoIWRhdGEuZmlsbFN0eWxlLnZpc2libGUpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIG9ubHkgZGVhbCB3aXRoIGZpbGxzLi5cbiAgICAgICAgICAgIGlmIChkYXRhLnNoYXBlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGEuc2hhcGUuY29udGFpbnMocG9pbnQueCwgcG9pbnQueSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEuaG9sZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGRhdGEuaG9sZXMubGVuZ3RoOyBpJDErKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBob2xlID0gZGF0YS5ob2xlc1tpJDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChob2xlLnNoYXBlLmNvbnRhaW5zKHBvaW50LngsIHBvaW50LnkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBpbnRlcm1lZGlhdGUgYmF0Y2ggZGF0YS4gRWl0aGVyIGdldHMgY29udmVydGVkIHRvIGRyYXdDYWxsc1xuICAgICAqIG9yIHVzZWQgdG8gY29udmVydCB0byBiYXRjaCBvYmplY3RzIGRpcmVjdGx5IGJ5IHRoZSBHcmFwaGljcyBvYmplY3QuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHVwZGF0ZUJhdGNoZXMoKSB7XG4gICAgICAgIGlmICh0aGlzLmRpcnR5ID09PSB0aGlzLmNhY2hlRGlydHkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5ncmFwaGljc0RhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZGlydHkgIT09IHRoaXMuY2FjaGVEaXJ0eSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmdyYXBoaWNzRGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5ncmFwaGljc0RhdGFbaV07XG4gICAgICAgICAgICAgICAgaWYgKGRhdGEuZmlsbFN0eWxlICYmICFkYXRhLmZpbGxTdHlsZS50ZXh0dXJlLmJhc2VUZXh0dXJlLnZhbGlkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGRhdGEubGluZVN0eWxlICYmICFkYXRhLmxpbmVTdHlsZS50ZXh0dXJlLmJhc2VUZXh0dXJlLnZhbGlkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jYWNoZURpcnR5ID0gdGhpcy5kaXJ0eTtcbiAgICAgICAgdmFyIHV2cyA9IHRoaXMudXZzO1xuICAgICAgICB2YXIgYmF0Y2hQYXJ0ID0gdGhpcy5iYXRjaGVzLnBvcCgpXG4gICAgICAgICAgICB8fCBHcmFwaGljc0dlb21ldHJ5LkJBVENIX1BPT0wucG9wKClcbiAgICAgICAgICAgIHx8IG5ldyBCYXRjaFBhcnQoKTtcbiAgICAgICAgYmF0Y2hQYXJ0LnN0eWxlID0gYmF0Y2hQYXJ0LnN0eWxlXG4gICAgICAgICAgICB8fCB0aGlzLmdyYXBoaWNzRGF0YVswXS5maWxsU3R5bGVcbiAgICAgICAgICAgIHx8IHRoaXMuZ3JhcGhpY3NEYXRhWzBdLmxpbmVTdHlsZTtcbiAgICAgICAgdmFyIGN1cnJlbnRUZXh0dXJlID0gYmF0Y2hQYXJ0LnN0eWxlLnRleHR1cmUuYmFzZVRleHR1cmU7XG4gICAgICAgIHZhciBjdXJyZW50Q29sb3IgPSBiYXRjaFBhcnQuc3R5bGUuY29sb3IgKyBiYXRjaFBhcnQuc3R5bGUuYWxwaGE7XG4gICAgICAgIHRoaXMuYmF0Y2hlcy5wdXNoKGJhdGNoUGFydCk7XG4gICAgICAgIC8vIFRPRE8gLSB0aGlzIGNhbiBiZSBzaW1wbGlmaWVkXG4gICAgICAgIGZvciAodmFyIGkkMSA9IHRoaXMuc2hhcGVJbmRleDsgaSQxIDwgdGhpcy5ncmFwaGljc0RhdGEubGVuZ3RoOyBpJDErKykge1xuICAgICAgICAgICAgdGhpcy5zaGFwZUluZGV4Kys7XG4gICAgICAgICAgICB2YXIgZGF0YSQxID0gdGhpcy5ncmFwaGljc0RhdGFbaSQxXTtcbiAgICAgICAgICAgIHZhciBjb21tYW5kID0gR3JhcGhpY3NHZW9tZXRyeS5nZXRGaWxsQ29tbWFuZChkYXRhJDEudHlwZSk7XG4gICAgICAgICAgICB2YXIgZmlsbFN0eWxlID0gZGF0YSQxLmZpbGxTdHlsZTtcbiAgICAgICAgICAgIHZhciBsaW5lU3R5bGUgPSBkYXRhJDEubGluZVN0eWxlO1xuICAgICAgICAgICAgLy8gYnVpbGQgb3V0IHRoZSBzaGFwZXMgcG9pbnRzLi5cbiAgICAgICAgICAgIGNvbW1hbmQuYnVpbGQoZGF0YSQxKTtcbiAgICAgICAgICAgIGlmIChkYXRhJDEubWF0cml4KSB7XG4gICAgICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm1Qb2ludHMoZGF0YSQxLnBvaW50cywgZGF0YSQxLm1hdHJpeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IDI7IGorKykge1xuICAgICAgICAgICAgICAgIHZhciBzdHlsZSA9IChqID09PSAwKSA/IGZpbGxTdHlsZSA6IGxpbmVTdHlsZTtcbiAgICAgICAgICAgICAgICBpZiAoIXN0eWxlLnZpc2libGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBuZXh0VGV4dHVyZSA9IHN0eWxlLnRleHR1cmUuYmFzZVRleHR1cmU7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRUZXh0dXJlICE9PSBuZXh0VGV4dHVyZSB8fCAoc3R5bGUuY29sb3IgKyBzdHlsZS5hbHBoYSkgIT09IGN1cnJlbnRDb2xvcikge1xuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIHVzZSBhIGNvbnN0XG4gICAgICAgICAgICAgICAgICAgIG5leHRUZXh0dXJlLndyYXBNb2RlID0gMTA0OTc7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRUZXh0dXJlID0gbmV4dFRleHR1cmU7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRDb2xvciA9IHN0eWxlLmNvbG9yICsgc3R5bGUuYWxwaGE7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCQxID0gdGhpcy5pbmRpY2VzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGF0dHJpYkluZGV4ID0gdGhpcy5wb2ludHMubGVuZ3RoIC8gMjtcbiAgICAgICAgICAgICAgICAgICAgYmF0Y2hQYXJ0LnNpemUgPSBpbmRleCQxIC0gYmF0Y2hQYXJ0LnN0YXJ0O1xuICAgICAgICAgICAgICAgICAgICBiYXRjaFBhcnQuYXR0cmliU2l6ZSA9IGF0dHJpYkluZGV4IC0gYmF0Y2hQYXJ0LmF0dHJpYlN0YXJ0O1xuICAgICAgICAgICAgICAgICAgICBpZiAoYmF0Y2hQYXJ0LnNpemUgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBiYXRjaFBhcnQgPSBHcmFwaGljc0dlb21ldHJ5LkJBVENIX1BPT0wucG9wKCkgfHwgbmV3IEJhdGNoUGFydCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5iYXRjaGVzLnB1c2goYmF0Y2hQYXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBiYXRjaFBhcnQuc3R5bGUgPSBzdHlsZTtcbiAgICAgICAgICAgICAgICAgICAgYmF0Y2hQYXJ0LnN0YXJ0ID0gaW5kZXgkMTtcbiAgICAgICAgICAgICAgICAgICAgYmF0Y2hQYXJ0LmF0dHJpYlN0YXJ0ID0gYXR0cmliSW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gYWRkIHRoaXMgdG8gdGhlIHJlbmRlciBwYXJ0Li5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5wb2ludHMubGVuZ3RoIC8gMjtcbiAgICAgICAgICAgICAgICBpZiAoaiA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YSQxLmhvbGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzSG9sZXMoZGF0YSQxLmhvbGVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIEdyYXBoaWNzR2VvbWV0cnkuYnVpbGRQb2x5LnRyaWFuZ3VsYXRlKGRhdGEkMSwgdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21tYW5kLnRyaWFuZ3VsYXRlKGRhdGEkMSwgdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIEdyYXBoaWNzR2VvbWV0cnkuYnVpbGRMaW5lKGRhdGEkMSwgdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkkMiA9IDA7IGkkMiA8IGRhdGEkMS5ob2xlcy5sZW5ndGg7IGkkMisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBHcmFwaGljc0dlb21ldHJ5LmJ1aWxkTGluZShkYXRhJDEuaG9sZXNbaSQyXSwgdGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHNpemUgPSAodGhpcy5wb2ludHMubGVuZ3RoIC8gMikgLSBzdGFydDtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZFV2cyh0aGlzLnBvaW50cywgdXZzLCBzdHlsZS50ZXh0dXJlLCBzdGFydCwgc2l6ZSwgc3R5bGUubWF0cml4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmluZGljZXMubGVuZ3RoO1xuICAgICAgICB2YXIgYXR0cmliID0gdGhpcy5wb2ludHMubGVuZ3RoIC8gMjtcbiAgICAgICAgYmF0Y2hQYXJ0LnNpemUgPSBpbmRleCAtIGJhdGNoUGFydC5zdGFydDtcbiAgICAgICAgYmF0Y2hQYXJ0LmF0dHJpYlNpemUgPSBhdHRyaWIgLSBiYXRjaFBhcnQuYXR0cmliU3RhcnQ7XG4gICAgICAgIHRoaXMuaW5kaWNlc1VpbnQxNiA9IG5ldyBVaW50MTZBcnJheSh0aGlzLmluZGljZXMpO1xuICAgICAgICAvLyBUT0RPIG1ha2UgdGhpcyBhIGNvbnN0Li5cbiAgICAgICAgdGhpcy5iYXRjaGFibGUgPSB0aGlzLmlzQmF0Y2hhYmxlKCk7XG4gICAgICAgIGlmICh0aGlzLmJhdGNoYWJsZSkge1xuICAgICAgICAgICAgdGhpcy5iYXRjaERpcnR5Kys7XG4gICAgICAgICAgICB0aGlzLnV2c0Zsb2F0MzIgPSBuZXcgRmxvYXQzMkFycmF5KHRoaXMudXZzKTtcbiAgICAgICAgICAgIC8vIG9mZnNldCB0aGUgaW5kaWNlcyBzbyB0aGF0IGl0IHdvcmtzIHdpdGggdGhlIGJhdGNoZXIuLi5cbiAgICAgICAgICAgIGZvciAodmFyIGkkMyA9IDA7IGkkMyA8IHRoaXMuYmF0Y2hlcy5sZW5ndGg7IGkkMysrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGJhdGNoID0gdGhpcy5iYXRjaGVzW2kkM107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiQxID0gMDsgaiQxIDwgYmF0Y2guc2l6ZTsgaiQxKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4JDIgPSBiYXRjaC5zdGFydCArIGokMTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmRpY2VzVWludDE2W2luZGV4JDJdID0gdGhpcy5pbmRpY2VzVWludDE2W2luZGV4JDJdIC0gYmF0Y2guYXR0cmliU3RhcnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5idWlsZERyYXdDYWxscygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBDaGVja3MgdG8gc2VlIGlmIHRoaXMgZ3JhcGhpY3MgZ2VvbWV0cnkgY2FuIGJlIGJhdGNoZWQuXG4gICAgICogQ3VycmVudGx5IGl0IG5lZWRzIHRvIGJlIHNtYWxsIGVub3VnaCBhbmQgbm90IGNvbnRhaW4gYW55IG5hdGl2ZSBsaW5lcy5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgaXNCYXRjaGFibGUoKSB7XG4gICAgICAgIHZhciBiYXRjaGVzID0gdGhpcy5iYXRjaGVzO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJhdGNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChiYXRjaGVzW2ldLnN0eWxlLm5hdGl2ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKHRoaXMucG9pbnRzLmxlbmd0aCA8IEdyYXBoaWNzR2VvbWV0cnkuQkFUQ0hBQkxFX1NJWkUgKiAyKTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGludGVybWVkaWF0ZSBiYXRjaGVzIGRhdGEgdG8gZHJhd0NhbGxzLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBidWlsZERyYXdDYWxscygpIHtcbiAgICAgICAgdmFyIFRJQ0sgPSArK0Jhc2VUZXh0dXJlXzEuQmFzZVRleHR1cmUuX2dsb2JhbEJhdGNoO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZHJhd0NhbGxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLmRyYXdDYWxsc1tpXS50ZXh0dXJlcy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgR3JhcGhpY3NHZW9tZXRyeS5EUkFXX0NBTExfUE9PTC5wdXNoKHRoaXMuZHJhd0NhbGxzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRyYXdDYWxscy5sZW5ndGggPSAwO1xuICAgICAgICB2YXIgdXZzID0gdGhpcy51dnM7XG4gICAgICAgIHZhciBjb2xvcnMgPSB0aGlzLmNvbG9ycztcbiAgICAgICAgdmFyIHRleHR1cmVJZHMgPSB0aGlzLnRleHR1cmVJZHM7XG4gICAgICAgIHZhciBjdXJyZW50R3JvdXAgPSBHcmFwaGljc0dlb21ldHJ5LkRSQVdfQ0FMTF9QT09MLnBvcCgpIHx8IG5ldyBCYXRjaERyYXdDYWxsXzEuQmF0Y2hEcmF3Q2FsbCgpO1xuICAgICAgICBjdXJyZW50R3JvdXAudGV4dHVyZUNvdW50ID0gMDtcbiAgICAgICAgY3VycmVudEdyb3VwLnN0YXJ0ID0gMDtcbiAgICAgICAgY3VycmVudEdyb3VwLnNpemUgPSAwO1xuICAgICAgICBjdXJyZW50R3JvdXAudHlwZSA9IERyYXdNb2RlU2V0dGluZ3NfMS5EcmF3TW9kZVNldHRpbmdzLkRSQVdfTU9ERVMuVFJJQU5HTEVTO1xuICAgICAgICB2YXIgdGV4dHVyZUNvdW50ID0gMDtcbiAgICAgICAgdmFyIGN1cnJlbnRUZXh0dXJlID0gbnVsbDtcbiAgICAgICAgdmFyIHRleHR1cmVJZCA9IDA7XG4gICAgICAgIHZhciBuYXRpdmUgPSBmYWxzZTtcbiAgICAgICAgdmFyIGRyYXdNb2RlID0gRHJhd01vZGVTZXR0aW5nc18xLkRyYXdNb2RlU2V0dGluZ3MuRFJBV19NT0RFUy5UUklBTkdMRVM7XG4gICAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICAgIHRoaXMuZHJhd0NhbGxzLnB1c2goY3VycmVudEdyb3VwKTtcbiAgICAgICAgLy8gVE9ETyAtIHRoaXMgY2FuIGJlIHNpbXBsaWZpZWRcbiAgICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgdGhpcy5iYXRjaGVzLmxlbmd0aDsgaSQxKyspIHtcbiAgICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5iYXRjaGVzW2kkMV07XG4gICAgICAgICAgICAvLyBUT0RPIGFkZCBzb21lIGZ1bGwgb24gTUFYX1RFWFRVUkUgQ09ERS4uXG4gICAgICAgICAgICB2YXIgTUFYX1RFWFRVUkVTID0gODtcbiAgICAgICAgICAgIHZhciBzdHlsZSA9IGRhdGEuc3R5bGU7XG4gICAgICAgICAgICB2YXIgbmV4dFRleHR1cmUgPSBzdHlsZS50ZXh0dXJlLmJhc2VUZXh0dXJlO1xuICAgICAgICAgICAgaWYgKG5hdGl2ZSAhPT0gc3R5bGUubmF0aXZlKSB7XG4gICAgICAgICAgICAgICAgbmF0aXZlID0gc3R5bGUubmF0aXZlO1xuICAgICAgICAgICAgICAgIGRyYXdNb2RlID0gbmF0aXZlID8gRHJhd01vZGVTZXR0aW5nc18xLkRyYXdNb2RlU2V0dGluZ3MuRFJBV19NT0RFUy5MSU5FUyA6IERyYXdNb2RlU2V0dGluZ3NfMS5EcmF3TW9kZVNldHRpbmdzLkRSQVdfTU9ERVMuVFJJQU5HTEVTO1xuICAgICAgICAgICAgICAgIC8vIGZvcmNlIHRoZSBiYXRjaCB0byBicmVhayFcbiAgICAgICAgICAgICAgICBjdXJyZW50VGV4dHVyZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGV4dHVyZUNvdW50ID0gTUFYX1RFWFRVUkVTO1xuICAgICAgICAgICAgICAgIFRJQ0srKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjdXJyZW50VGV4dHVyZSAhPT0gbmV4dFRleHR1cmUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50VGV4dHVyZSA9IG5leHRUZXh0dXJlO1xuICAgICAgICAgICAgICAgIGlmIChuZXh0VGV4dHVyZS5fYmF0Y2hFbmFibGVkICE9PSBUSUNLKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ZXh0dXJlQ291bnQgPT09IE1BWF9URVhUVVJFUykge1xuICAgICAgICAgICAgICAgICAgICAgICAgVElDSysrO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dHVyZUNvdW50ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50R3JvdXAuc2l6ZSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50R3JvdXAgPSBHcmFwaGljc0dlb21ldHJ5LkRSQVdfQ0FMTF9QT09MLnBvcCgpIHx8IG5ldyBCYXRjaERyYXdDYWxsXzEuQmF0Y2hEcmF3Q2FsbCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd0NhbGxzLnB1c2goY3VycmVudEdyb3VwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRHcm91cC5zdGFydCA9IGluZGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEdyb3VwLnNpemUgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEdyb3VwLnRleHR1cmVDb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50R3JvdXAudHlwZSA9IGRyYXdNb2RlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gYWRkIHRoaXMgdG8gdGhlIHJlbmRlciBwYXJ0Li5cbiAgICAgICAgICAgICAgICAgICAgbmV4dFRleHR1cmUudG91Y2hlZCA9IDE7IC8vIHRvdWNoO1xuICAgICAgICAgICAgICAgICAgICBuZXh0VGV4dHVyZS5fYmF0Y2hFbmFibGVkID0gVElDSztcbiAgICAgICAgICAgICAgICAgICAgbmV4dFRleHR1cmUuX2lkID0gdGV4dHVyZUNvdW50O1xuICAgICAgICAgICAgICAgICAgICBuZXh0VGV4dHVyZS53cmFwTW9kZSA9IDEwNDk3O1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50R3JvdXAudGV4dHVyZXNbY3VycmVudEdyb3VwLnRleHR1cmVDb3VudCsrXSA9IG5leHRUZXh0dXJlO1xuICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlQ291bnQrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50R3JvdXAuc2l6ZSArPSBkYXRhLnNpemU7XG4gICAgICAgICAgICBpbmRleCArPSBkYXRhLnNpemU7XG4gICAgICAgICAgICB0ZXh0dXJlSWQgPSBuZXh0VGV4dHVyZS5faWQ7XG4gICAgICAgICAgICB0aGlzLmFkZENvbG9ycyhjb2xvcnMsIHN0eWxlLmNvbG9yLCBzdHlsZS5hbHBoYSwgZGF0YS5hdHRyaWJTaXplKTtcbiAgICAgICAgICAgIHRoaXMuYWRkVGV4dHVyZUlkcyh0ZXh0dXJlSWRzLCB0ZXh0dXJlSWQsIGRhdGEuYXR0cmliU2l6ZSk7XG4gICAgICAgIH1cbiAgICAgICAgQmFzZVRleHR1cmVfMS5CYXNlVGV4dHVyZS5fZ2xvYmFsQmF0Y2ggPSBUSUNLO1xuICAgICAgICAvLyB1cGxvYWQuLlxuICAgICAgICAvLyBtZXJnZSBmb3Igbm93IVxuICAgICAgICB2YXIgdmVydHMgPSB0aGlzLnBvaW50cztcbiAgICAgICAgLy8gdmVydHMgYXJlIDIgcG9zaXRpb25zLi4gc28gd2UgKiBieSAzIGFzIHRoZXJlIGFyZSA2IHByb3BlcnRpZXMuLiB0aGVuIDQgY29zIGl0cyBieXRlc1xuICAgICAgICB2YXIgZ2xQb2ludHMgPSBuZXcgQXJyYXlCdWZmZXIodmVydHMubGVuZ3RoICogMyAqIDQpO1xuICAgICAgICB2YXIgZjMyID0gbmV3IEZsb2F0MzJBcnJheShnbFBvaW50cyk7XG4gICAgICAgIHZhciB1MzIgPSBuZXcgVWludDMyQXJyYXkoZ2xQb2ludHMpO1xuICAgICAgICB2YXIgcCA9IDA7XG4gICAgICAgIGZvciAodmFyIGkkMiA9IDA7IGkkMiA8IHZlcnRzLmxlbmd0aCAvIDI7IGkkMisrKSB7XG4gICAgICAgICAgICBmMzJbcCsrXSA9IHZlcnRzW2kkMiAqIDJdO1xuICAgICAgICAgICAgZjMyW3ArK10gPSB2ZXJ0c1soaSQyICogMikgKyAxXTtcbiAgICAgICAgICAgIGYzMltwKytdID0gdXZzW2kkMiAqIDJdO1xuICAgICAgICAgICAgZjMyW3ArK10gPSB1dnNbKGkkMiAqIDIpICsgMV07XG4gICAgICAgICAgICB1MzJbcCsrXSA9IGNvbG9yc1tpJDJdO1xuICAgICAgICAgICAgZjMyW3ArK10gPSB0ZXh0dXJlSWRzW2kkMl07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fYnVmZmVyLnVwZGF0ZShnbFBvaW50cyk7XG4gICAgICAgIHRoaXMuX2luZGV4QnVmZmVyLnVwZGF0ZSh0aGlzLmluZGljZXNVaW50MTYpO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogUHJvY2VzcyB0aGUgaG9sZXMgZGF0YS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UElYSS5HcmFwaGljc0RhdGFbXX0gaG9sZXMgLSBIb2xlcyB0byByZW5kZXJcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgcHJvY2Vzc0hvbGVzKGhvbGVzKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaG9sZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBob2xlID0gaG9sZXNbaV07XG4gICAgICAgICAgICB2YXIgY29tbWFuZCA9IEdyYXBoaWNzR2VvbWV0cnkuZmlsbENvbW1hbmRzW2hvbGUudHlwZV07XG4gICAgICAgICAgICBjb21tYW5kLmJ1aWxkKGhvbGUpO1xuICAgICAgICAgICAgaWYgKGhvbGUubWF0cml4KSB7XG4gICAgICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm1Qb2ludHMoaG9sZS5wb2ludHMsIGhvbGUubWF0cml4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogVXBkYXRlIHRoZSBsb2NhbCBib3VuZHMgb2YgdGhlIG9iamVjdC4gRXhwZW5zaXZlIHRvIHVzZSBwZXJmb3JtYW5jZS13aXNlLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBjYWxjdWxhdGVCb3VuZHMoKSB7XG4gICAgICAgIHZhciBtaW5YID0gSW5maW5pdHk7XG4gICAgICAgIHZhciBtYXhYID0gLUluZmluaXR5O1xuICAgICAgICB2YXIgbWluWSA9IEluZmluaXR5O1xuICAgICAgICB2YXIgbWF4WSA9IC1JbmZpbml0eTtcbiAgICAgICAgaWYgKHRoaXMuZ3JhcGhpY3NEYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIHNoYXBlID0gbnVsbDtcbiAgICAgICAgICAgIHZhciB4ID0gMDtcbiAgICAgICAgICAgIHZhciB5ID0gMDtcbiAgICAgICAgICAgIHZhciB3ID0gMDtcbiAgICAgICAgICAgIHZhciBoID0gMDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5ncmFwaGljc0RhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuZ3JhcGhpY3NEYXRhW2ldO1xuICAgICAgICAgICAgICAgIHZhciB0eXBlID0gZGF0YS50eXBlO1xuICAgICAgICAgICAgICAgIHZhciBsaW5lV2lkdGggPSBkYXRhLmxpbmVTdHlsZSA/IGRhdGEubGluZVN0eWxlLndpZHRoIDogMDtcbiAgICAgICAgICAgICAgICBzaGFwZSA9IGRhdGEuc2hhcGU7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09IFNoYXBlU2V0dGluZ3NfMS5TaGFwZVNldHRpbmdzLlNIQVBFUy5SRUNUIHx8IHR5cGUgPT09IFNoYXBlU2V0dGluZ3NfMS5TaGFwZVNldHRpbmdzLlNIQVBFUy5SUkVDKSB7XG4gICAgICAgICAgICAgICAgICAgIHggPSBzaGFwZS54IC0gKGxpbmVXaWR0aCAvIDIpO1xuICAgICAgICAgICAgICAgICAgICB5ID0gc2hhcGUueSAtIChsaW5lV2lkdGggLyAyKTtcbiAgICAgICAgICAgICAgICAgICAgdyA9IHNoYXBlLndpZHRoICsgbGluZVdpZHRoO1xuICAgICAgICAgICAgICAgICAgICBoID0gc2hhcGUuaGVpZ2h0ICsgbGluZVdpZHRoO1xuICAgICAgICAgICAgICAgICAgICBtaW5YID0geCA8IG1pblggPyB4IDogbWluWDtcbiAgICAgICAgICAgICAgICAgICAgbWF4WCA9IHggKyB3ID4gbWF4WCA/IHggKyB3IDogbWF4WDtcbiAgICAgICAgICAgICAgICAgICAgbWluWSA9IHkgPCBtaW5ZID8geSA6IG1pblk7XG4gICAgICAgICAgICAgICAgICAgIG1heFkgPSB5ICsgaCA+IG1heFkgPyB5ICsgaCA6IG1heFk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT09IFNoYXBlU2V0dGluZ3NfMS5TaGFwZVNldHRpbmdzLlNIQVBFUy5DSVJDKSB7XG4gICAgICAgICAgICAgICAgICAgIHggPSBzaGFwZS54O1xuICAgICAgICAgICAgICAgICAgICB5ID0gc2hhcGUueTtcbiAgICAgICAgICAgICAgICAgICAgdyA9IHNoYXBlLnJhZGl1cyArIChsaW5lV2lkdGggLyAyKTtcbiAgICAgICAgICAgICAgICAgICAgaCA9IHNoYXBlLnJhZGl1cyArIChsaW5lV2lkdGggLyAyKTtcbiAgICAgICAgICAgICAgICAgICAgbWluWCA9IHggLSB3IDwgbWluWCA/IHggLSB3IDogbWluWDtcbiAgICAgICAgICAgICAgICAgICAgbWF4WCA9IHggKyB3ID4gbWF4WCA/IHggKyB3IDogbWF4WDtcbiAgICAgICAgICAgICAgICAgICAgbWluWSA9IHkgLSBoIDwgbWluWSA/IHkgLSBoIDogbWluWTtcbiAgICAgICAgICAgICAgICAgICAgbWF4WSA9IHkgKyBoID4gbWF4WSA/IHkgKyBoIDogbWF4WTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gU2hhcGVTZXR0aW5nc18xLlNoYXBlU2V0dGluZ3MuU0hBUEVTLkVMSVApIHtcbiAgICAgICAgICAgICAgICAgICAgeCA9IHNoYXBlLng7XG4gICAgICAgICAgICAgICAgICAgIHkgPSBzaGFwZS55O1xuICAgICAgICAgICAgICAgICAgICB3ID0gc2hhcGUud2lkdGggKyAobGluZVdpZHRoIC8gMik7XG4gICAgICAgICAgICAgICAgICAgIGggPSBzaGFwZS5oZWlnaHQgKyAobGluZVdpZHRoIC8gMik7XG4gICAgICAgICAgICAgICAgICAgIG1pblggPSB4IC0gdyA8IG1pblggPyB4IC0gdyA6IG1pblg7XG4gICAgICAgICAgICAgICAgICAgIG1heFggPSB4ICsgdyA+IG1heFggPyB4ICsgdyA6IG1heFg7XG4gICAgICAgICAgICAgICAgICAgIG1pblkgPSB5IC0gaCA8IG1pblkgPyB5IC0gaCA6IG1pblk7XG4gICAgICAgICAgICAgICAgICAgIG1heFkgPSB5ICsgaCA+IG1heFkgPyB5ICsgaCA6IG1heFk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBQT0xZXG4gICAgICAgICAgICAgICAgICAgIHZhciBwb2ludHMgPSBzaGFwZS5wb2ludHM7XG4gICAgICAgICAgICAgICAgICAgIHZhciB4MiA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHZhciB5MiA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkeCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkeSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHZhciBydyA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHZhciByaCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjeCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjeSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqICsgMiA8IHBvaW50cy5sZW5ndGg7IGogKz0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgeCA9IHBvaW50c1tqXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHkgPSBwb2ludHNbaiArIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgeDIgPSBwb2ludHNbaiArIDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgeTIgPSBwb2ludHNbaiArIDNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZHggPSBNYXRoLmFicyh4MiAtIHgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZHkgPSBNYXRoLmFicyh5MiAtIHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaCA9IGxpbmVXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHcgPSBNYXRoLnNxcnQoKGR4ICogZHgpICsgKGR5ICogZHkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3IDwgMWUtOSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcncgPSAoKGggLyB3ICogZHkpICsgZHgpIC8gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJoID0gKChoIC8gdyAqIGR4KSArIGR5KSAvIDI7XG4gICAgICAgICAgICAgICAgICAgICAgICBjeCA9ICh4MiArIHgpIC8gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN5ID0gKHkyICsgeSkgLyAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWluWCA9IGN4IC0gcncgPCBtaW5YID8gY3ggLSBydyA6IG1pblg7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhYID0gY3ggKyBydyA+IG1heFggPyBjeCArIHJ3IDogbWF4WDtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pblkgPSBjeSAtIHJoIDwgbWluWSA/IGN5IC0gcmggOiBtaW5ZO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF4WSA9IGN5ICsgcmggPiBtYXhZID8gY3kgKyByaCA6IG1heFk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtaW5YID0gMDtcbiAgICAgICAgICAgIG1heFggPSAwO1xuICAgICAgICAgICAgbWluWSA9IDA7XG4gICAgICAgICAgICBtYXhZID0gMDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcGFkZGluZyA9IHRoaXMuYm91bmRzUGFkZGluZztcbiAgICAgICAgdGhpcy5fYm91bmRzLm1pblggPSBtaW5YIC0gcGFkZGluZztcbiAgICAgICAgdGhpcy5fYm91bmRzLm1heFggPSBtYXhYICsgcGFkZGluZztcbiAgICAgICAgdGhpcy5fYm91bmRzLm1pblkgPSBtaW5ZIC0gcGFkZGluZztcbiAgICAgICAgdGhpcy5fYm91bmRzLm1heFkgPSBtYXhZICsgcGFkZGluZztcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybSBwb2ludHMgdXNpbmcgbWF0cml4LlxuICAgICAqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyW119IHBvaW50cyAtIFBvaW50cyB0byB0cmFuc2Zvcm1cbiAgICAgKiBAcGFyYW0ge1BJWEkuTWF0cml4fSBtYXRyaXggLSBUcmFuc2Zvcm0gbWF0cml4XG4gICAgICovXG4gICAgdHJhbnNmb3JtUG9pbnRzKHBvaW50cywgbWF0cml4KSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aCAvIDI7IGkrKykge1xuICAgICAgICAgICAgdmFyIHggPSBwb2ludHNbKGkgKiAyKV07XG4gICAgICAgICAgICB2YXIgeSA9IHBvaW50c1soaSAqIDIpICsgMV07XG4gICAgICAgICAgICBwb2ludHNbKGkgKiAyKV0gPSAobWF0cml4LmEgKiB4KSArIChtYXRyaXguYyAqIHkpICsgbWF0cml4LnR4O1xuICAgICAgICAgICAgcG9pbnRzWyhpICogMikgKyAxXSA9IChtYXRyaXguYiAqIHgpICsgKG1hdHJpeC5kICogeSkgKyBtYXRyaXgudHk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIEFkZCBjb2xvcnMuXG4gICAgICpcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHBhcmFtIHtudW1iZXJbXX0gY29sb3JzIC0gTGlzdCBvZiBjb2xvcnMgdG8gYWRkIHRvXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbG9yIC0gQ29sb3IgdG8gYWRkXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGFscGhhIC0gQWxwaGEgdG8gdXNlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNpemUgLSBOdW1iZXIgb2YgY29sb3JzIHRvIGFkZFxuICAgICAqL1xuICAgIGFkZENvbG9ycyhjb2xvcnMsIGNvbG9yLCBhbHBoYSwgc2l6ZSkge1xuICAgICAgICAvLyBUT0RPIHVzZSB0aGUgcHJlbXVsdGlwbHkgYml0cyBJdmFuIGFkZGVkXG4gICAgICAgIHZhciByZ2IgPSAoY29sb3IgPj4gMTYpICsgKGNvbG9yICYgMHhmZjAwKSArICgoY29sb3IgJiAweGZmKSA8PCAxNik7XG4gICAgICAgIHZhciByZ2JhID0gQ29sb3JTZXR0aW5nc18xLkNvbG9yU2V0dGluZ3MucHJlbXVsdGlwbHlUaW50KHJnYiwgYWxwaGEpO1xuICAgICAgICB3aGlsZSAoc2l6ZS0tID4gMCkge1xuICAgICAgICAgICAgY29sb3JzLnB1c2gocmdiYSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIEFkZCB0ZXh0dXJlIGlkIHRoYXQgdGhlIHNoYWRlci9mcmFnbWVudCB3YW50cyB0byB1c2UuXG4gICAgICpcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHBhcmFtIHtudW1iZXJbXX0gdGV4dHVyZUlkc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzaXplXG4gICAgICovXG4gICAgYWRkVGV4dHVyZUlkcyh0ZXh0dXJlSWRzLCBpZCwgc2l6ZSkge1xuICAgICAgICB3aGlsZSAoc2l6ZS0tID4gMCkge1xuICAgICAgICAgICAgdGV4dHVyZUlkcy5wdXNoKGlkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIHRoZSBVVnMgZm9yIGEgc2hhcGUuXG4gICAgICpcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHBhcmFtIHtudW1iZXJbXX0gdmVydHMgLSBWZXJ0aWNlc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyW119IHV2cyAtIFVWc1xuICAgICAqIEBwYXJhbSB7UElYSS5UZXh0dXJlfSB0ZXh0dXJlIC0gUmVmZXJlbmNlIHRvIFRleHR1cmVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgLSBJbmRleCBidWZmZXIgc3RhcnQgaW5kZXguXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNpemUgLSBUaGUgc2l6ZS9sZW5ndGggZm9yIGluZGV4IGJ1ZmZlci5cbiAgICAgKiBAcGFyYW0ge1BJWEkuTWF0cml4fSBbbWF0cml4XSAtIE9wdGlvbmFsIHRyYW5zZm9ybSBmb3IgYWxsIHBvaW50cy5cbiAgICAgKi9cbiAgICBhZGRVdnModmVydHMsIHV2cywgdGV4dHVyZSwgc3RhcnQsIHNpemUsIG1hdHJpeCkge1xuICAgICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgICB2YXIgdXZzU3RhcnQgPSB1dnMubGVuZ3RoO1xuICAgICAgICB2YXIgZnJhbWUgPSB0ZXh0dXJlLmZyYW1lO1xuICAgICAgICB3aGlsZSAoaW5kZXggPCBzaXplKSB7XG4gICAgICAgICAgICB2YXIgeCA9IHZlcnRzWyhzdGFydCArIGluZGV4KSAqIDJdO1xuICAgICAgICAgICAgdmFyIHkgPSB2ZXJ0c1soKHN0YXJ0ICsgaW5kZXgpICogMikgKyAxXTtcbiAgICAgICAgICAgIGlmIChtYXRyaXgpIHtcbiAgICAgICAgICAgICAgICB2YXIgbnggPSAobWF0cml4LmEgKiB4KSArIChtYXRyaXguYyAqIHkpICsgbWF0cml4LnR4O1xuICAgICAgICAgICAgICAgIHkgPSAobWF0cml4LmIgKiB4KSArIChtYXRyaXguZCAqIHkpICsgbWF0cml4LnR5O1xuICAgICAgICAgICAgICAgIHggPSBueDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgICAgICB1dnMucHVzaCh4IC8gZnJhbWUud2lkdGgsIHkgLyBmcmFtZS5oZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBiYXNlVGV4dHVyZSA9IHRleHR1cmUuYmFzZVRleHR1cmU7XG4gICAgICAgIGlmIChmcmFtZS53aWR0aCA8IGJhc2VUZXh0dXJlLndpZHRoXG4gICAgICAgICAgICB8fCBmcmFtZS5oZWlnaHQgPCBiYXNlVGV4dHVyZS5oZWlnaHQpIHtcbiAgICAgICAgICAgIHRoaXMuYWRqdXN0VXZzKHV2cywgdGV4dHVyZSwgdXZzU3RhcnQsIHNpemUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBNb2RpZnkgdXZzIGFycmF5IGFjY29yZGluZyB0byBwb3NpdGlvbiBvZiB0ZXh0dXJlIHJlZ2lvblxuICAgICAqIERvZXMgbm90IHdvcmsgd2l0aCByb3RhdGVkIG9yIHRyaW1tZWQgdGV4dHVyZXNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdXZzIGFycmF5XG4gICAgICogQHBhcmFtIHtQSVhJLlRleHR1cmV9IHRleHR1cmUgcmVnaW9uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IHN0YXJ0aW5nIGluZGV4IGZvciB1dnNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2l6ZSBob3cgbWFueSBwb2ludHMgdG8gYWRqdXN0XG4gICAgICovXG4gICAgYWRqdXN0VXZzKHV2cywgdGV4dHVyZSwgc3RhcnQsIHNpemUpIHtcbiAgICAgICAgdmFyIGJhc2VUZXh0dXJlID0gdGV4dHVyZS5iYXNlVGV4dHVyZTtcbiAgICAgICAgdmFyIGVwcyA9IDFlLTY7XG4gICAgICAgIHZhciBmaW5pc2ggPSBzdGFydCArIChzaXplICogMik7XG4gICAgICAgIHZhciBmcmFtZSA9IHRleHR1cmUuZnJhbWU7XG4gICAgICAgIHZhciBzY2FsZVggPSBmcmFtZS53aWR0aCAvIGJhc2VUZXh0dXJlLndpZHRoO1xuICAgICAgICB2YXIgc2NhbGVZID0gZnJhbWUuaGVpZ2h0IC8gYmFzZVRleHR1cmUuaGVpZ2h0O1xuICAgICAgICB2YXIgb2Zmc2V0WCA9IGZyYW1lLnggLyBmcmFtZS53aWR0aDtcbiAgICAgICAgdmFyIG9mZnNldFkgPSBmcmFtZS55IC8gZnJhbWUud2lkdGg7XG4gICAgICAgIHZhciBtaW5YID0gTWF0aC5mbG9vcih1dnNbc3RhcnRdICsgZXBzKTtcbiAgICAgICAgdmFyIG1pblkgPSBNYXRoLmZsb29yKHV2c1tzdGFydCArIDFdICsgZXBzKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0ICsgMjsgaSA8IGZpbmlzaDsgaSArPSAyKSB7XG4gICAgICAgICAgICBtaW5YID0gTWF0aC5taW4obWluWCwgTWF0aC5mbG9vcih1dnNbaV0gKyBlcHMpKTtcbiAgICAgICAgICAgIG1pblkgPSBNYXRoLm1pbihtaW5ZLCBNYXRoLmZsb29yKHV2c1tpICsgMV0gKyBlcHMpKTtcbiAgICAgICAgfVxuICAgICAgICBvZmZzZXRYIC09IG1pblg7XG4gICAgICAgIG9mZnNldFkgLT0gbWluWTtcbiAgICAgICAgZm9yICh2YXIgaSQxID0gc3RhcnQ7IGkkMSA8IGZpbmlzaDsgaSQxICs9IDIpIHtcbiAgICAgICAgICAgIHV2c1tpJDFdID0gKHV2c1tpJDFdICsgb2Zmc2V0WCkgKiBzY2FsZVg7XG4gICAgICAgICAgICB1dnNbaSQxICsgMV0gPSAodXZzW2kkMSArIDFdICsgb2Zmc2V0WSkgKiBzY2FsZVk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICogQnVpbGRzIGEgbGluZSB0byBkcmF3XG4gKlxuICogSWdub3JlZCBmcm9tIGRvY3Mgc2luY2UgaXQgaXMgbm90IGRpcmVjdGx5IGV4cG9zZWQuXG4gKlxuICogQGlnbm9yZVxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7UElYSS5HcmFwaGljc0RhdGF9IGdyYXBoaWNzRGF0YSAtIFRoZSBncmFwaGljcyBvYmplY3QgY29udGFpbmluZyBhbGwgdGhlIG5lY2Vzc2FyeSBwcm9wZXJ0aWVzXG4gKiBAcGFyYW0ge1BJWEkuR3JhcGhpY3NHZW9tZXRyeX0gZ3JhcGhpY3NHZW9tZXRyeSAtIEdlb21ldHJ5IHdoZXJlIHRvIGFwcGVuZCBvdXRwdXRcbiAqL1xuICAgIHN0YXRpYyBidWlsZExpbmUoZ3JhcGhpY3NEYXRhLCBncmFwaGljc0dlb21ldHJ5KSB7XG4gICAgICAgIGlmIChncmFwaGljc0RhdGEubGluZVN0eWxlLm5hdGl2ZSkge1xuICAgICAgICAgICAgR3JhcGhpY3NHZW9tZXRyeS5idWlsZE5hdGl2ZUxpbmUoZ3JhcGhpY3NEYXRhLCBncmFwaGljc0dlb21ldHJ5KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIEdyYXBoaWNzR2VvbWV0cnkuYnVpbGRMaW5lJDEoZ3JhcGhpY3NEYXRhLCBncmFwaGljc0dlb21ldHJ5KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAqIEJ1aWxkcyBhIGxpbmUgdG8gZHJhdyB1c2luZyB0aGUgZ2wuZHJhd0FycmF5cyhnbC5MSU5FUykgbWV0aG9kXG4gKlxuICogSWdub3JlZCBmcm9tIGRvY3Mgc2luY2UgaXQgaXMgbm90IGRpcmVjdGx5IGV4cG9zZWQuXG4gKlxuICogQGlnbm9yZVxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7UElYSS5HcmFwaGljc0RhdGF9IGdyYXBoaWNzRGF0YSAtIFRoZSBncmFwaGljcyBvYmplY3QgY29udGFpbmluZyBhbGwgdGhlIG5lY2Vzc2FyeSBwcm9wZXJ0aWVzXG4gKiBAcGFyYW0ge1BJWEkuR3JhcGhpY3NHZW9tZXRyeX0gZ3JhcGhpY3NHZW9tZXRyeSAtIEdlb21ldHJ5IHdoZXJlIHRvIGFwcGVuZCBvdXRwdXRcbiAqL1xuICAgIHN0YXRpYyBidWlsZE5hdGl2ZUxpbmUoZ3JhcGhpY3NEYXRhLCBncmFwaGljc0dlb21ldHJ5KSB7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgdmFyIHBvaW50cyA9IGdyYXBoaWNzRGF0YS5wb2ludHMgfHwgZ3JhcGhpY3NEYXRhLnNoYXBlLnBvaW50cztcbiAgICAgICAgaWYgKHBvaW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdmVydHMgPSBncmFwaGljc0dlb21ldHJ5LnBvaW50cztcbiAgICAgICAgdmFyIGluZGljZXMgPSBncmFwaGljc0dlb21ldHJ5LmluZGljZXM7XG4gICAgICAgIHZhciBsZW5ndGggPSBwb2ludHMubGVuZ3RoIC8gMjtcbiAgICAgICAgdmFyIGluZGV4U3RhcnQgPSB2ZXJ0cy5sZW5ndGggLyAyO1xuICAgICAgICAvLyBzb3J0IGNvbG9yXG4gICAgICAgIGZvciAoaSA9IDE7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHAxeCA9IHBvaW50c1soaSAtIDEpICogMl07XG4gICAgICAgICAgICB2YXIgcDF5ID0gcG9pbnRzWygoaSAtIDEpICogMikgKyAxXTtcbiAgICAgICAgICAgIHZhciBwMnggPSBwb2ludHNbaSAqIDJdO1xuICAgICAgICAgICAgdmFyIHAyeSA9IHBvaW50c1soaSAqIDIpICsgMV07XG4gICAgICAgICAgICB2ZXJ0cy5wdXNoKHAxeCwgcDF5KTtcbiAgICAgICAgICAgIHZlcnRzLnB1c2gocDJ4LCBwMnkpO1xuICAgICAgICAgICAgaW5kaWNlcy5wdXNoKGluZGV4U3RhcnQrKywgaW5kZXhTdGFydCsrKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAqIEJ1aWxkcyBhIGxpbmUgdG8gZHJhdyB1c2luZyB0aGUgcG9seWdvbiBtZXRob2QuXG4gKlxuICogSWdub3JlZCBmcm9tIGRvY3Mgc2luY2UgaXQgaXMgbm90IGRpcmVjdGx5IGV4cG9zZWQuXG4gKlxuICogQGlnbm9yZVxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7UElYSS5HcmFwaGljc0RhdGF9IGdyYXBoaWNzRGF0YSAtIFRoZSBncmFwaGljcyBvYmplY3QgY29udGFpbmluZyBhbGwgdGhlIG5lY2Vzc2FyeSBwcm9wZXJ0aWVzXG4gKiBAcGFyYW0ge1BJWEkuR3JhcGhpY3NHZW9tZXRyeX0gZ3JhcGhpY3NHZW9tZXRyeSAtIEdlb21ldHJ5IHdoZXJlIHRvIGFwcGVuZCBvdXRwdXRcbiAqL1xuICAgIHN0YXRpYyBidWlsZExpbmUkMShncmFwaGljc0RhdGEsIGdyYXBoaWNzR2VvbWV0cnkpIHtcbiAgICAgICAgdmFyIHNoYXBlID0gZ3JhcGhpY3NEYXRhLnNoYXBlO1xuICAgICAgICB2YXIgcG9pbnRzID0gZ3JhcGhpY3NEYXRhLnBvaW50cyB8fCBzaGFwZS5wb2ludHMuc2xpY2UoKTtcbiAgICAgICAgaWYgKHBvaW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiB0aGUgbGluZSB3aWR0aCBpcyBhbiBvZGQgbnVtYmVyIGFkZCAwLjUgdG8gYWxpZ24gdG8gYSB3aG9sZSBwaXhlbFxuICAgICAgICAvLyBjb21tZW50aW5nIHRoaXMgb3V0IGZpeGVzICM3MTEgYW5kICMxNjIwXG4gICAgICAgIC8vIGlmIChncmFwaGljc0RhdGEubGluZVdpZHRoJTIpXG4gICAgICAgIC8vIHtcbiAgICAgICAgLy8gICAgIGZvciAoaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspXG4gICAgICAgIC8vICAgICB7XG4gICAgICAgIC8vICAgICAgICAgcG9pbnRzW2ldICs9IDAuNTtcbiAgICAgICAgLy8gICAgIH1cbiAgICAgICAgLy8gfVxuICAgICAgICB2YXIgc3R5bGUgPSBncmFwaGljc0RhdGEubGluZVN0eWxlO1xuICAgICAgICAvLyBnZXQgZmlyc3QgYW5kIGxhc3QgcG9pbnQuLiBmaWd1cmUgb3V0IHRoZSBtaWRkbGUhXG4gICAgICAgIHZhciBmaXJzdFBvaW50ID0gUG9pbnRfMS5Qb2ludC5nZXRQb2ludChwb2ludHNbMF0sIHBvaW50c1sxXSk7XG4gICAgICAgIHZhciBsYXN0UG9pbnQgPSBQb2ludF8xLlBvaW50LmdldFBvaW50KHBvaW50c1twb2ludHMubGVuZ3RoIC0gMl0sIHBvaW50c1twb2ludHMubGVuZ3RoIC0gMV0pO1xuICAgICAgICB2YXIgY2xvc2VkU2hhcGUgPSBzaGFwZS50eXBlICE9PSBTaGFwZVNldHRpbmdzXzEuU2hhcGVTZXR0aW5ncy5TSEFQRVMuUE9MWSB8fCBzaGFwZS5jbG9zZVN0cm9rZTtcbiAgICAgICAgdmFyIGNsb3NlZFBhdGggPSBmaXJzdFBvaW50LnggPT09IGxhc3RQb2ludC54ICYmIGZpcnN0UG9pbnQueSA9PT0gbGFzdFBvaW50Lnk7XG4gICAgICAgIC8vIGlmIHRoZSBmaXJzdCBwb2ludCBpcyB0aGUgbGFzdCBwb2ludCAtIGdvbm5hIGhhdmUgaXNzdWVzIDopXG4gICAgICAgIGlmIChjbG9zZWRTaGFwZSkge1xuICAgICAgICAgICAgLy8gbmVlZCB0byBjbG9uZSBhcyB3ZSBhcmUgZ29pbmcgdG8gc2xpZ2h0bHkgbW9kaWZ5IHRoZSBzaGFwZS4uXG4gICAgICAgICAgICBwb2ludHMgPSBwb2ludHMuc2xpY2UoKTtcbiAgICAgICAgICAgIGlmIChjbG9zZWRQYXRoKSB7XG4gICAgICAgICAgICAgICAgcG9pbnRzLnBvcCgpO1xuICAgICAgICAgICAgICAgIHBvaW50cy5wb3AoKTtcbiAgICAgICAgICAgICAgICBsYXN0UG9pbnQuc2V0KHBvaW50c1twb2ludHMubGVuZ3RoIC0gMl0sIHBvaW50c1twb2ludHMubGVuZ3RoIC0gMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG1pZFBvaW50WCA9IGxhc3RQb2ludC54ICsgKChmaXJzdFBvaW50LnggLSBsYXN0UG9pbnQueCkgKiAwLjUpO1xuICAgICAgICAgICAgdmFyIG1pZFBvaW50WSA9IGxhc3RQb2ludC55ICsgKChmaXJzdFBvaW50LnkgLSBsYXN0UG9pbnQueSkgKiAwLjUpO1xuICAgICAgICAgICAgcG9pbnRzLnVuc2hpZnQobWlkUG9pbnRYLCBtaWRQb2ludFkpO1xuICAgICAgICAgICAgcG9pbnRzLnB1c2gobWlkUG9pbnRYLCBtaWRQb2ludFkpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB2ZXJ0cyA9IGdyYXBoaWNzR2VvbWV0cnkucG9pbnRzO1xuICAgICAgICB2YXIgbGVuZ3RoID0gcG9pbnRzLmxlbmd0aCAvIDI7XG4gICAgICAgIHZhciBpbmRleENvdW50ID0gcG9pbnRzLmxlbmd0aDtcbiAgICAgICAgdmFyIGluZGV4U3RhcnQgPSB2ZXJ0cy5sZW5ndGggLyAyO1xuICAgICAgICAvLyBEUkFXIHRoZSBMaW5lXG4gICAgICAgIHZhciB3aWR0aCA9IHN0eWxlLndpZHRoIC8gMjtcbiAgICAgICAgLy8gc29ydCBjb2xvclxuICAgICAgICB2YXIgcDF4ID0gcG9pbnRzWzBdO1xuICAgICAgICB2YXIgcDF5ID0gcG9pbnRzWzFdO1xuICAgICAgICB2YXIgcDJ4ID0gcG9pbnRzWzJdO1xuICAgICAgICB2YXIgcDJ5ID0gcG9pbnRzWzNdO1xuICAgICAgICB2YXIgcDN4ID0gMDtcbiAgICAgICAgdmFyIHAzeSA9IDA7XG4gICAgICAgIHZhciBwZXJweCA9IC0ocDF5IC0gcDJ5KTtcbiAgICAgICAgdmFyIHBlcnB5ID0gcDF4IC0gcDJ4O1xuICAgICAgICB2YXIgcGVycDJ4ID0gMDtcbiAgICAgICAgdmFyIHBlcnAyeSA9IDA7XG4gICAgICAgIHZhciBwZXJwM3ggPSAwO1xuICAgICAgICB2YXIgcGVycDN5ID0gMDtcbiAgICAgICAgdmFyIGRpc3QgPSBNYXRoLnNxcnQoKHBlcnB4ICogcGVycHgpICsgKHBlcnB5ICogcGVycHkpKTtcbiAgICAgICAgcGVycHggLz0gZGlzdDtcbiAgICAgICAgcGVycHkgLz0gZGlzdDtcbiAgICAgICAgcGVycHggKj0gd2lkdGg7XG4gICAgICAgIHBlcnB5ICo9IHdpZHRoO1xuICAgICAgICB2YXIgcmF0aW8gPSBzdHlsZS5hbGlnbm1lbnQ7IC8vIDAuNTtcbiAgICAgICAgdmFyIHIxID0gKDEgLSByYXRpbykgKiAyO1xuICAgICAgICB2YXIgcjIgPSByYXRpbyAqIDI7XG4gICAgICAgIC8vIHN0YXJ0XG4gICAgICAgIHZlcnRzLnB1c2gocDF4IC0gKHBlcnB4ICogcjEpLCBwMXkgLSAocGVycHkgKiByMSkpO1xuICAgICAgICB2ZXJ0cy5wdXNoKHAxeCArIChwZXJweCAqIHIyKSwgcDF5ICsgKHBlcnB5ICogcjIpKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBsZW5ndGggLSAxOyArK2kpIHtcbiAgICAgICAgICAgIHAxeCA9IHBvaW50c1soaSAtIDEpICogMl07XG4gICAgICAgICAgICBwMXkgPSBwb2ludHNbKChpIC0gMSkgKiAyKSArIDFdO1xuICAgICAgICAgICAgcDJ4ID0gcG9pbnRzW2kgKiAyXTtcbiAgICAgICAgICAgIHAyeSA9IHBvaW50c1soaSAqIDIpICsgMV07XG4gICAgICAgICAgICBwM3ggPSBwb2ludHNbKGkgKyAxKSAqIDJdO1xuICAgICAgICAgICAgcDN5ID0gcG9pbnRzWygoaSArIDEpICogMikgKyAxXTtcbiAgICAgICAgICAgIHBlcnB4ID0gLShwMXkgLSBwMnkpO1xuICAgICAgICAgICAgcGVycHkgPSBwMXggLSBwMng7XG4gICAgICAgICAgICBkaXN0ID0gTWF0aC5zcXJ0KChwZXJweCAqIHBlcnB4KSArIChwZXJweSAqIHBlcnB5KSk7XG4gICAgICAgICAgICBwZXJweCAvPSBkaXN0O1xuICAgICAgICAgICAgcGVycHkgLz0gZGlzdDtcbiAgICAgICAgICAgIHBlcnB4ICo9IHdpZHRoO1xuICAgICAgICAgICAgcGVycHkgKj0gd2lkdGg7XG4gICAgICAgICAgICBwZXJwMnggPSAtKHAyeSAtIHAzeSk7XG4gICAgICAgICAgICBwZXJwMnkgPSBwMnggLSBwM3g7XG4gICAgICAgICAgICBkaXN0ID0gTWF0aC5zcXJ0KChwZXJwMnggKiBwZXJwMngpICsgKHBlcnAyeSAqIHBlcnAyeSkpO1xuICAgICAgICAgICAgcGVycDJ4IC89IGRpc3Q7XG4gICAgICAgICAgICBwZXJwMnkgLz0gZGlzdDtcbiAgICAgICAgICAgIHBlcnAyeCAqPSB3aWR0aDtcbiAgICAgICAgICAgIHBlcnAyeSAqPSB3aWR0aDtcbiAgICAgICAgICAgIHZhciBhMSA9ICgtcGVycHkgKyBwMXkpIC0gKC1wZXJweSArIHAyeSk7XG4gICAgICAgICAgICB2YXIgYjEgPSAoLXBlcnB4ICsgcDJ4KSAtICgtcGVycHggKyBwMXgpO1xuICAgICAgICAgICAgdmFyIGMxID0gKCgtcGVycHggKyBwMXgpICogKC1wZXJweSArIHAyeSkpIC0gKCgtcGVycHggKyBwMngpICogKC1wZXJweSArIHAxeSkpO1xuICAgICAgICAgICAgdmFyIGEyID0gKC1wZXJwMnkgKyBwM3kpIC0gKC1wZXJwMnkgKyBwMnkpO1xuICAgICAgICAgICAgdmFyIGIyID0gKC1wZXJwMnggKyBwMngpIC0gKC1wZXJwMnggKyBwM3gpO1xuICAgICAgICAgICAgdmFyIGMyID0gKCgtcGVycDJ4ICsgcDN4KSAqICgtcGVycDJ5ICsgcDJ5KSkgLSAoKC1wZXJwMnggKyBwMngpICogKC1wZXJwMnkgKyBwM3kpKTtcbiAgICAgICAgICAgIHZhciBkZW5vbSA9IChhMSAqIGIyKSAtIChhMiAqIGIxKTtcbiAgICAgICAgICAgIGlmIChNYXRoLmFicyhkZW5vbSkgPCAwLjEpIHtcbiAgICAgICAgICAgICAgICBkZW5vbSArPSAxMC4xO1xuICAgICAgICAgICAgICAgIHZlcnRzLnB1c2gocDJ4IC0gKHBlcnB4ICogcjEpLCBwMnkgLSAocGVycHkgKiByMSkpO1xuICAgICAgICAgICAgICAgIHZlcnRzLnB1c2gocDJ4ICsgKHBlcnB4ICogcjIpLCBwMnkgKyAocGVycHkgKiByMikpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHB4ID0gKChiMSAqIGMyKSAtIChiMiAqIGMxKSkgLyBkZW5vbTtcbiAgICAgICAgICAgIHZhciBweSA9ICgoYTIgKiBjMSkgLSAoYTEgKiBjMikpIC8gZGVub207XG4gICAgICAgICAgICB2YXIgcGRpc3QgPSAoKHB4IC0gcDJ4KSAqIChweCAtIHAyeCkpICsgKChweSAtIHAyeSkgKiAocHkgLSBwMnkpKTtcbiAgICAgICAgICAgIGlmIChwZGlzdCA+ICgxOTYgKiB3aWR0aCAqIHdpZHRoKSkge1xuICAgICAgICAgICAgICAgIHBlcnAzeCA9IHBlcnB4IC0gcGVycDJ4O1xuICAgICAgICAgICAgICAgIHBlcnAzeSA9IHBlcnB5IC0gcGVycDJ5O1xuICAgICAgICAgICAgICAgIGRpc3QgPSBNYXRoLnNxcnQoKHBlcnAzeCAqIHBlcnAzeCkgKyAocGVycDN5ICogcGVycDN5KSk7XG4gICAgICAgICAgICAgICAgcGVycDN4IC89IGRpc3Q7XG4gICAgICAgICAgICAgICAgcGVycDN5IC89IGRpc3Q7XG4gICAgICAgICAgICAgICAgcGVycDN4ICo9IHdpZHRoO1xuICAgICAgICAgICAgICAgIHBlcnAzeSAqPSB3aWR0aDtcbiAgICAgICAgICAgICAgICB2ZXJ0cy5wdXNoKHAyeCAtIChwZXJwM3ggKiByMSksIHAyeSAtIChwZXJwM3kgKiByMSkpO1xuICAgICAgICAgICAgICAgIHZlcnRzLnB1c2gocDJ4ICsgKHBlcnAzeCAqIHIyKSwgcDJ5ICsgKHBlcnAzeSAqIHIyKSk7XG4gICAgICAgICAgICAgICAgdmVydHMucHVzaChwMnggLSAocGVycDN4ICogcjIgKiByMSksIHAyeSAtIChwZXJwM3kgKiByMSkpO1xuICAgICAgICAgICAgICAgIGluZGV4Q291bnQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZlcnRzLnB1c2gocDJ4ICsgKChweCAtIHAyeCkgKiByMSksIHAyeSArICgocHkgLSBwMnkpICogcjEpKTtcbiAgICAgICAgICAgICAgICB2ZXJ0cy5wdXNoKHAyeCAtICgocHggLSBwMngpICogcjIpLCBwMnkgLSAoKHB5IC0gcDJ5KSAqIHIyKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcDF4ID0gcG9pbnRzWyhsZW5ndGggLSAyKSAqIDJdO1xuICAgICAgICBwMXkgPSBwb2ludHNbKChsZW5ndGggLSAyKSAqIDIpICsgMV07XG4gICAgICAgIHAyeCA9IHBvaW50c1sobGVuZ3RoIC0gMSkgKiAyXTtcbiAgICAgICAgcDJ5ID0gcG9pbnRzWygobGVuZ3RoIC0gMSkgKiAyKSArIDFdO1xuICAgICAgICBwZXJweCA9IC0ocDF5IC0gcDJ5KTtcbiAgICAgICAgcGVycHkgPSBwMXggLSBwMng7XG4gICAgICAgIGRpc3QgPSBNYXRoLnNxcnQoKHBlcnB4ICogcGVycHgpICsgKHBlcnB5ICogcGVycHkpKTtcbiAgICAgICAgcGVycHggLz0gZGlzdDtcbiAgICAgICAgcGVycHkgLz0gZGlzdDtcbiAgICAgICAgcGVycHggKj0gd2lkdGg7XG4gICAgICAgIHBlcnB5ICo9IHdpZHRoO1xuICAgICAgICB2ZXJ0cy5wdXNoKHAyeCAtIChwZXJweCAqIHIxKSwgcDJ5IC0gKHBlcnB5ICogcjEpKTtcbiAgICAgICAgdmVydHMucHVzaChwMnggKyAocGVycHggKiByMiksIHAyeSArIChwZXJweSAqIHIyKSk7XG4gICAgICAgIHZhciBpbmRpY2VzID0gZ3JhcGhpY3NHZW9tZXRyeS5pbmRpY2VzO1xuICAgICAgICAvLyBpbmRpY2VzLnB1c2goaW5kZXhTdGFydCk7XG4gICAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGluZGV4Q291bnQgLSAyOyArK2kkMSkge1xuICAgICAgICAgICAgaW5kaWNlcy5wdXNoKGluZGV4U3RhcnQsIGluZGV4U3RhcnQgKyAxLCBpbmRleFN0YXJ0ICsgMik7XG4gICAgICAgICAgICBpbmRleFN0YXJ0Kys7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZpcnN0UG9pbnQpIHtcbiAgICAgICAgICAgIGZpcnN0UG9pbnQucmVjeWNsZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsYXN0UG9pbnQpIHtcbiAgICAgICAgICAgIGxhc3RQb2ludC5yZWN5Y2xlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIGVhcmN1dChkYXRhLCBob2xlSW5kaWNlcywgZGltKSB7XG4gICAgICAgIGRpbSA9IGRpbSB8fCAyO1xuICAgICAgICB2YXIgaGFzSG9sZXMgPSBob2xlSW5kaWNlcyAmJiBob2xlSW5kaWNlcy5sZW5ndGgsIG91dGVyTGVuID0gaGFzSG9sZXMgPyBob2xlSW5kaWNlc1swXSAqIGRpbSA6IGRhdGEubGVuZ3RoLCBvdXRlck5vZGUgPSBHcmFwaGljc0dlb21ldHJ5LmxpbmtlZExpc3QoZGF0YSwgMCwgb3V0ZXJMZW4sIGRpbSwgdHJ1ZSksIHRyaWFuZ2xlcyA9IFtdO1xuICAgICAgICBpZiAoIW91dGVyTm9kZSB8fCBvdXRlck5vZGUubmV4dCA9PT0gb3V0ZXJOb2RlLnByZXYpIHtcbiAgICAgICAgICAgIHJldHVybiB0cmlhbmdsZXM7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1pblgsIG1pblksIG1heFgsIG1heFksIHgsIHksIGludlNpemU7XG4gICAgICAgIGlmIChoYXNIb2xlcykge1xuICAgICAgICAgICAgb3V0ZXJOb2RlID0gR3JhcGhpY3NHZW9tZXRyeS5lbGltaW5hdGVIb2xlcyhkYXRhLCBob2xlSW5kaWNlcywgb3V0ZXJOb2RlLCBkaW0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIHRoZSBzaGFwZSBpcyBub3QgdG9vIHNpbXBsZSwgd2UnbGwgdXNlIHotb3JkZXIgY3VydmUgaGFzaCBsYXRlcjsgY2FsY3VsYXRlIHBvbHlnb24gYmJveFxuICAgICAgICBpZiAoZGF0YS5sZW5ndGggPiA4MCAqIGRpbSkge1xuICAgICAgICAgICAgbWluWCA9IG1heFggPSBkYXRhWzBdO1xuICAgICAgICAgICAgbWluWSA9IG1heFkgPSBkYXRhWzFdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IGRpbTsgaSA8IG91dGVyTGVuOyBpICs9IGRpbSkge1xuICAgICAgICAgICAgICAgIHggPSBkYXRhW2ldO1xuICAgICAgICAgICAgICAgIHkgPSBkYXRhW2kgKyAxXTtcbiAgICAgICAgICAgICAgICBpZiAoeCA8IG1pblgpIHtcbiAgICAgICAgICAgICAgICAgICAgbWluWCA9IHg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh5IDwgbWluWSkge1xuICAgICAgICAgICAgICAgICAgICBtaW5ZID0geTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHggPiBtYXhYKSB7XG4gICAgICAgICAgICAgICAgICAgIG1heFggPSB4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoeSA+IG1heFkpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF4WSA9IHk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gbWluWCwgbWluWSBhbmQgaW52U2l6ZSBhcmUgbGF0ZXIgdXNlZCB0byB0cmFuc2Zvcm0gY29vcmRzIGludG8gaW50ZWdlcnMgZm9yIHotb3JkZXIgY2FsY3VsYXRpb25cbiAgICAgICAgICAgIGludlNpemUgPSBNYXRoLm1heChtYXhYIC0gbWluWCwgbWF4WSAtIG1pblkpO1xuICAgICAgICAgICAgaW52U2l6ZSA9IGludlNpemUgIT09IDAgPyAxIC8gaW52U2l6ZSA6IDA7XG4gICAgICAgIH1cbiAgICAgICAgR3JhcGhpY3NHZW9tZXRyeS5lYXJjdXRMaW5rZWQob3V0ZXJOb2RlLCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgaW52U2l6ZSk7XG4gICAgICAgIHJldHVybiB0cmlhbmdsZXM7XG4gICAgfVxuICAgIC8vIGNyZWF0ZSBhIGNpcmN1bGFyIGRvdWJseSBsaW5rZWQgbGlzdCBmcm9tIHBvbHlnb24gcG9pbnRzIGluIHRoZSBzcGVjaWZpZWQgd2luZGluZyBvcmRlclxuICAgIHN0YXRpYyBsaW5rZWRMaXN0KGRhdGEsIHN0YXJ0LCBlbmQsIGRpbSwgY2xvY2t3aXNlKSB7XG4gICAgICAgIHZhciBpLCBsYXN0O1xuICAgICAgICBpZiAoY2xvY2t3aXNlID09PSAoR3JhcGhpY3NHZW9tZXRyeS5zaWduZWRBcmVhKGRhdGEsIHN0YXJ0LCBlbmQsIGRpbSkgPiAwKSkge1xuICAgICAgICAgICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gZGltKSB7XG4gICAgICAgICAgICAgICAgbGFzdCA9IEdyYXBoaWNzR2VvbWV0cnkuaW5zZXJ0Tm9kZShpLCBkYXRhW2ldLCBkYXRhW2kgKyAxXSwgbGFzdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGkgPSBlbmQgLSBkaW07IGkgPj0gc3RhcnQ7IGkgLT0gZGltKSB7XG4gICAgICAgICAgICAgICAgbGFzdCA9IEdyYXBoaWNzR2VvbWV0cnkuaW5zZXJ0Tm9kZShpLCBkYXRhW2ldLCBkYXRhW2kgKyAxXSwgbGFzdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxhc3QgJiYgR3JhcGhpY3NHZW9tZXRyeS5lcXVhbHMobGFzdCwgbGFzdC5uZXh0KSkge1xuICAgICAgICAgICAgR3JhcGhpY3NHZW9tZXRyeS5yZW1vdmVOb2RlKGxhc3QpO1xuICAgICAgICAgICAgbGFzdCA9IGxhc3QubmV4dDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGFzdDtcbiAgICB9XG4gICAgLy8gbGluayBldmVyeSBob2xlIGludG8gdGhlIG91dGVyIGxvb3AsIHByb2R1Y2luZyBhIHNpbmdsZS1yaW5nIHBvbHlnb24gd2l0aG91dCBob2xlc1xuICAgIHN0YXRpYyBlbGltaW5hdGVIb2xlcyhkYXRhLCBob2xlSW5kaWNlcywgb3V0ZXJOb2RlLCBkaW0pIHtcbiAgICAgICAgdmFyIHF1ZXVlID0gW10sIGksIGxlbiwgc3RhcnQsIGVuZCwgbGlzdDtcbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gaG9sZUluZGljZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gaG9sZUluZGljZXNbaV0gKiBkaW07XG4gICAgICAgICAgICBlbmQgPSBpIDwgbGVuIC0gMSA/IGhvbGVJbmRpY2VzW2kgKyAxXSAqIGRpbSA6IGRhdGEubGVuZ3RoO1xuICAgICAgICAgICAgbGlzdCA9IEdyYXBoaWNzR2VvbWV0cnkubGlua2VkTGlzdChkYXRhLCBzdGFydCwgZW5kLCBkaW0sIGZhbHNlKTtcbiAgICAgICAgICAgIGlmIChsaXN0ID09PSBsaXN0Lm5leHQpIHtcbiAgICAgICAgICAgICAgICBsaXN0LnN0ZWluZXIgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcXVldWUucHVzaChHcmFwaGljc0dlb21ldHJ5LmdldExlZnRtb3N0KGxpc3QpKTtcbiAgICAgICAgfVxuICAgICAgICBxdWV1ZS5zb3J0KEdyYXBoaWNzR2VvbWV0cnkuY29tcGFyZVgpO1xuICAgICAgICAvLyBwcm9jZXNzIGhvbGVzIGZyb20gbGVmdCB0byByaWdodFxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIEdyYXBoaWNzR2VvbWV0cnkuZWxpbWluYXRlSG9sZShxdWV1ZVtpXSwgb3V0ZXJOb2RlKTtcbiAgICAgICAgICAgIG91dGVyTm9kZSA9IEdyYXBoaWNzR2VvbWV0cnkuZmlsdGVyUG9pbnRzKG91dGVyTm9kZSwgb3V0ZXJOb2RlLm5leHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXRlck5vZGU7XG4gICAgfVxuICAgIC8vIG1haW4gZWFyIHNsaWNpbmcgbG9vcCB3aGljaCB0cmlhbmd1bGF0ZXMgYSBwb2x5Z29uIChnaXZlbiBhcyBhIGxpbmtlZCBsaXN0KVxuICAgIHN0YXRpYyBlYXJjdXRMaW5rZWQoZWFyLCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgaW52U2l6ZSwgcGFzcyA9IG51bGwpIHtcbiAgICAgICAgaWYgKCFlYXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBpbnRlcmxpbmsgcG9seWdvbiBub2RlcyBpbiB6LW9yZGVyXG4gICAgICAgIGlmICghcGFzcyAmJiBpbnZTaXplKSB7XG4gICAgICAgICAgICBHcmFwaGljc0dlb21ldHJ5LmluZGV4Q3VydmUoZWFyLCBtaW5YLCBtaW5ZLCBpbnZTaXplKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3RvcCA9IGVhciwgcHJldiwgbmV4dDtcbiAgICAgICAgLy8gaXRlcmF0ZSB0aHJvdWdoIGVhcnMsIHNsaWNpbmcgdGhlbSBvbmUgYnkgb25lXG4gICAgICAgIHdoaWxlIChlYXIucHJldiAhPT0gZWFyLm5leHQpIHtcbiAgICAgICAgICAgIHByZXYgPSBlYXIucHJldjtcbiAgICAgICAgICAgIG5leHQgPSBlYXIubmV4dDtcbiAgICAgICAgICAgIGlmIChpbnZTaXplID8gR3JhcGhpY3NHZW9tZXRyeS5pc0Vhckhhc2hlZChlYXIsIG1pblgsIG1pblksIGludlNpemUpIDogR3JhcGhpY3NHZW9tZXRyeS5pc0VhcihlYXIpKSB7XG4gICAgICAgICAgICAgICAgLy8gY3V0IG9mZiB0aGUgdHJpYW5nbGVcbiAgICAgICAgICAgICAgICB0cmlhbmdsZXMucHVzaChwcmV2LmkgLyBkaW0pO1xuICAgICAgICAgICAgICAgIHRyaWFuZ2xlcy5wdXNoKGVhci5pIC8gZGltKTtcbiAgICAgICAgICAgICAgICB0cmlhbmdsZXMucHVzaChuZXh0LmkgLyBkaW0pO1xuICAgICAgICAgICAgICAgIEdyYXBoaWNzR2VvbWV0cnkucmVtb3ZlTm9kZShlYXIpO1xuICAgICAgICAgICAgICAgIC8vIHNraXBwaW5nIHRoZSBuZXh0IHZlcnRleCBsZWFkcyB0byBsZXNzIHNsaXZlciB0cmlhbmdsZXNcbiAgICAgICAgICAgICAgICBlYXIgPSBuZXh0Lm5leHQ7XG4gICAgICAgICAgICAgICAgc3RvcCA9IG5leHQubmV4dDtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVhciA9IG5leHQ7XG4gICAgICAgICAgICAvLyBpZiB3ZSBsb29wZWQgdGhyb3VnaCB0aGUgd2hvbGUgcmVtYWluaW5nIHBvbHlnb24gYW5kIGNhbid0IGZpbmQgYW55IG1vcmUgZWFyc1xuICAgICAgICAgICAgaWYgKGVhciA9PT0gc3RvcCkge1xuICAgICAgICAgICAgICAgIC8vIHRyeSBmaWx0ZXJpbmcgcG9pbnRzIGFuZCBzbGljaW5nIGFnYWluXG4gICAgICAgICAgICAgICAgaWYgKCFwYXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIEdyYXBoaWNzR2VvbWV0cnkuZWFyY3V0TGlua2VkKEdyYXBoaWNzR2VvbWV0cnkuZmlsdGVyUG9pbnRzKGVhciksIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBpbnZTaXplLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhpcyBkaWRuJ3Qgd29yaywgdHJ5IGN1cmluZyBhbGwgc21hbGwgc2VsZi1pbnRlcnNlY3Rpb25zIGxvY2FsbHlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocGFzcyA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICBlYXIgPSBHcmFwaGljc0dlb21ldHJ5LmN1cmVMb2NhbEludGVyc2VjdGlvbnMoZWFyLCB0cmlhbmdsZXMsIGRpbSk7XG4gICAgICAgICAgICAgICAgICAgIEdyYXBoaWNzR2VvbWV0cnkuZWFyY3V0TGlua2VkKGVhciwgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIGludlNpemUsIDIpO1xuICAgICAgICAgICAgICAgICAgICAvLyBhcyBhIGxhc3QgcmVzb3J0LCB0cnkgc3BsaXR0aW5nIHRoZSByZW1haW5pbmcgcG9seWdvbiBpbnRvIHR3b1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChwYXNzID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIEdyYXBoaWNzR2VvbWV0cnkuc3BsaXRFYXJjdXQoZWFyLCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgaW52U2l6ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBzaWduZWRBcmVhKGRhdGEsIHN0YXJ0LCBlbmQsIGRpbSkge1xuICAgICAgICB2YXIgc3VtID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0LCBqID0gZW5kIC0gZGltOyBpIDwgZW5kOyBpICs9IGRpbSkge1xuICAgICAgICAgICAgc3VtICs9IChkYXRhW2pdIC0gZGF0YVtpXSkgKiAoZGF0YVtpICsgMV0gKyBkYXRhW2ogKyAxXSk7XG4gICAgICAgICAgICBqID0gaTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3VtO1xuICAgIH1cbiAgICAvLyBjcmVhdGUgYSBub2RlIGFuZCBvcHRpb25hbGx5IGxpbmsgaXQgd2l0aCBwcmV2aW91cyBvbmUgKGluIGEgY2lyY3VsYXIgZG91Ymx5IGxpbmtlZCBsaXN0KVxuICAgIHN0YXRpYyBpbnNlcnROb2RlKGksIHgsIHksIGxhc3QpIHtcbiAgICAgICAgdmFyIHAgPSBuZXcgTm9kZShpLCB4LCB5KTtcbiAgICAgICAgaWYgKCFsYXN0KSB7XG4gICAgICAgICAgICBwLnByZXYgPSBwO1xuICAgICAgICAgICAgcC5uZXh0ID0gcDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHAubmV4dCA9IGxhc3QubmV4dDtcbiAgICAgICAgICAgIHAucHJldiA9IGxhc3Q7XG4gICAgICAgICAgICBsYXN0Lm5leHQucHJldiA9IHA7XG4gICAgICAgICAgICBsYXN0Lm5leHQgPSBwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwO1xuICAgIH1cbiAgICAvLyBjaGVjayBpZiB0d28gcG9pbnRzIGFyZSBlcXVhbFxuICAgIHN0YXRpYyBlcXVhbHMocDEsIHAyKSB7XG4gICAgICAgIHJldHVybiBwMS54ID09PSBwMi54ICYmIHAxLnkgPT09IHAyLnk7XG4gICAgfVxuICAgIHN0YXRpYyByZW1vdmVOb2RlKHApIHtcbiAgICAgICAgcC5uZXh0LnByZXYgPSBwLnByZXY7XG4gICAgICAgIHAucHJldi5uZXh0ID0gcC5uZXh0O1xuICAgICAgICBpZiAocC5wcmV2Wikge1xuICAgICAgICAgICAgcC5wcmV2Wi5uZXh0WiA9IHAubmV4dFo7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHAubmV4dFopIHtcbiAgICAgICAgICAgIHAubmV4dFoucHJldlogPSBwLnByZXZaO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGZpbmQgdGhlIGxlZnRtb3N0IG5vZGUgb2YgYSBwb2x5Z29uIHJpbmdcbiAgICBzdGF0aWMgZ2V0TGVmdG1vc3Qoc3RhcnQpIHtcbiAgICAgICAgdmFyIHAgPSBzdGFydCwgbGVmdG1vc3QgPSBzdGFydDtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgaWYgKHAueCA8IGxlZnRtb3N0LnggfHwgKHAueCA9PT0gbGVmdG1vc3QueCAmJiBwLnkgPCBsZWZ0bW9zdC55KSkge1xuICAgICAgICAgICAgICAgIGxlZnRtb3N0ID0gcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHAgPSBwLm5leHQ7XG4gICAgICAgIH0gd2hpbGUgKHAgIT09IHN0YXJ0KTtcbiAgICAgICAgcmV0dXJuIGxlZnRtb3N0O1xuICAgIH1cbiAgICBzdGF0aWMgY29tcGFyZVgoYSwgYikge1xuICAgICAgICByZXR1cm4gYS54IC0gYi54O1xuICAgIH1cbiAgICAvLyBmaW5kIGEgYnJpZGdlIGJldHdlZW4gdmVydGljZXMgdGhhdCBjb25uZWN0cyBob2xlIHdpdGggYW4gb3V0ZXIgcmluZyBhbmQgYW5kIGxpbmsgaXRcbiAgICBzdGF0aWMgZWxpbWluYXRlSG9sZShob2xlLCBvdXRlck5vZGUpIHtcbiAgICAgICAgb3V0ZXJOb2RlID0gR3JhcGhpY3NHZW9tZXRyeS5maW5kSG9sZUJyaWRnZShob2xlLCBvdXRlck5vZGUpO1xuICAgICAgICBpZiAob3V0ZXJOb2RlKSB7XG4gICAgICAgICAgICB2YXIgYiA9IEdyYXBoaWNzR2VvbWV0cnkuc3BsaXRQb2x5Z29uKG91dGVyTm9kZSwgaG9sZSk7XG4gICAgICAgICAgICBHcmFwaGljc0dlb21ldHJ5LmZpbHRlclBvaW50cyhiLCBiLm5leHQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGVsaW1pbmF0ZSBjb2xpbmVhciBvciBkdXBsaWNhdGUgcG9pbnRzXG4gICAgc3RhdGljIGZpbHRlclBvaW50cyhzdGFydCwgZW5kID0gbnVsbCkge1xuICAgICAgICBpZiAoIXN0YXJ0KSB7XG4gICAgICAgICAgICByZXR1cm4gc3RhcnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFlbmQpIHtcbiAgICAgICAgICAgIGVuZCA9IHN0YXJ0O1xuICAgICAgICB9XG4gICAgICAgIHZhciBwID0gc3RhcnQsIGFnYWluO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICBhZ2FpbiA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKCFwLnN0ZWluZXIgJiYgKEdyYXBoaWNzR2VvbWV0cnkuZXF1YWxzKHAsIHAubmV4dCkgfHwgR3JhcGhpY3NHZW9tZXRyeS5hcmVhKHAucHJldiwgcCwgcC5uZXh0KSA9PT0gMCkpIHtcbiAgICAgICAgICAgICAgICBHcmFwaGljc0dlb21ldHJ5LnJlbW92ZU5vZGUocCk7XG4gICAgICAgICAgICAgICAgcCA9IGVuZCA9IHAucHJldjtcbiAgICAgICAgICAgICAgICBpZiAocCA9PT0gcC5uZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhZ2FpbiA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwID0gcC5uZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IHdoaWxlIChhZ2FpbiB8fCBwICE9PSBlbmQpO1xuICAgICAgICByZXR1cm4gZW5kO1xuICAgIH1cbiAgICAvLyBzaWduZWQgYXJlYSBvZiBhIHRyaWFuZ2xlXG4gICAgc3RhdGljIGFyZWEocCwgcSwgcikge1xuICAgICAgICByZXR1cm4gKHEueSAtIHAueSkgKiAoci54IC0gcS54KSAtIChxLnggLSBwLngpICogKHIueSAtIHEueSk7XG4gICAgfVxuICAgIC8vIGxpbmsgdHdvIHBvbHlnb24gdmVydGljZXMgd2l0aCBhIGJyaWRnZTsgaWYgdGhlIHZlcnRpY2VzIGJlbG9uZyB0byB0aGUgc2FtZSByaW5nLCBpdCBzcGxpdHMgcG9seWdvbiBpbnRvIHR3bztcbiAgICAvLyBpZiBvbmUgYmVsb25ncyB0byB0aGUgb3V0ZXIgcmluZyBhbmQgYW5vdGhlciB0byBhIGhvbGUsIGl0IG1lcmdlcyBpdCBpbnRvIGEgc2luZ2xlIHJpbmdcbiAgICBzdGF0aWMgc3BsaXRQb2x5Z29uKGEsIGIpIHtcbiAgICAgICAgdmFyIGEyID0gbmV3IE5vZGUoYS5pLCBhLngsIGEueSksIGIyID0gbmV3IE5vZGUoYi5pLCBiLngsIGIueSksIGFuID0gYS5uZXh0LCBicCA9IGIucHJldjtcbiAgICAgICAgYS5uZXh0ID0gYjtcbiAgICAgICAgYi5wcmV2ID0gYTtcbiAgICAgICAgYTIubmV4dCA9IGFuO1xuICAgICAgICBhbi5wcmV2ID0gYTI7XG4gICAgICAgIGIyLm5leHQgPSBhMjtcbiAgICAgICAgYTIucHJldiA9IGIyO1xuICAgICAgICBicC5uZXh0ID0gYjI7XG4gICAgICAgIGIyLnByZXYgPSBicDtcbiAgICAgICAgcmV0dXJuIGIyO1xuICAgIH1cbiAgICAvLyBEYXZpZCBFYmVybHkncyBhbGdvcml0aG0gZm9yIGZpbmRpbmcgYSBicmlkZ2UgYmV0d2VlbiBob2xlIGFuZCBvdXRlciBwb2x5Z29uXG4gICAgc3RhdGljIGZpbmRIb2xlQnJpZGdlKGhvbGUsIG91dGVyTm9kZSkge1xuICAgICAgICB2YXIgcCA9IG91dGVyTm9kZSwgaHggPSBob2xlLngsIGh5ID0gaG9sZS55LCBxeCA9IC1JbmZpbml0eSwgbTtcbiAgICAgICAgLy8gZmluZCBhIHNlZ21lbnQgaW50ZXJzZWN0ZWQgYnkgYSByYXkgZnJvbSB0aGUgaG9sZSdzIGxlZnRtb3N0IHBvaW50IHRvIHRoZSBsZWZ0O1xuICAgICAgICAvLyBzZWdtZW50J3MgZW5kcG9pbnQgd2l0aCBsZXNzZXIgeCB3aWxsIGJlIHBvdGVudGlhbCBjb25uZWN0aW9uIHBvaW50XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGlmIChoeSA8PSBwLnkgJiYgaHkgPj0gcC5uZXh0LnkgJiYgcC5uZXh0LnkgIT09IHAueSkge1xuICAgICAgICAgICAgICAgIHZhciB4ID0gcC54ICsgKGh5IC0gcC55KSAqIChwLm5leHQueCAtIHAueCkgLyAocC5uZXh0LnkgLSBwLnkpO1xuICAgICAgICAgICAgICAgIGlmICh4IDw9IGh4ICYmIHggPiBxeCkge1xuICAgICAgICAgICAgICAgICAgICBxeCA9IHg7XG4gICAgICAgICAgICAgICAgICAgIGlmICh4ID09PSBoeCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGh5ID09PSBwLnkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoeSA9PT0gcC5uZXh0LnkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcC5uZXh0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG0gPSBwLnggPCBwLm5leHQueCA/IHAgOiBwLm5leHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcCA9IHAubmV4dDtcbiAgICAgICAgfSB3aGlsZSAocCAhPT0gb3V0ZXJOb2RlKTtcbiAgICAgICAgaWYgKCFtKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaHggPT09IHF4KSB7XG4gICAgICAgICAgICByZXR1cm4gbS5wcmV2O1xuICAgICAgICB9IC8vIGhvbGUgdG91Y2hlcyBvdXRlciBzZWdtZW50OyBwaWNrIGxvd2VyIGVuZHBvaW50XG4gICAgICAgIC8vIGxvb2sgZm9yIHBvaW50cyBpbnNpZGUgdGhlIHRyaWFuZ2xlIG9mIGhvbGUgcG9pbnQsIHNlZ21lbnQgaW50ZXJzZWN0aW9uIGFuZCBlbmRwb2ludDtcbiAgICAgICAgLy8gaWYgdGhlcmUgYXJlIG5vIHBvaW50cyBmb3VuZCwgd2UgaGF2ZSBhIHZhbGlkIGNvbm5lY3Rpb247XG4gICAgICAgIC8vIG90aGVyd2lzZSBjaG9vc2UgdGhlIHBvaW50IG9mIHRoZSBtaW5pbXVtIGFuZ2xlIHdpdGggdGhlIHJheSBhcyBjb25uZWN0aW9uIHBvaW50XG4gICAgICAgIHZhciBzdG9wID0gbSwgbXggPSBtLngsIG15ID0gbS55LCB0YW5NaW4gPSBJbmZpbml0eSwgdGFuO1xuICAgICAgICBwID0gbS5uZXh0O1xuICAgICAgICB3aGlsZSAocCAhPT0gc3RvcCkge1xuICAgICAgICAgICAgaWYgKGh4ID49IHAueCAmJiBwLnggPj0gbXggJiYgaHggIT09IHAueCAmJlxuICAgICAgICAgICAgICAgIEdyYXBoaWNzR2VvbWV0cnkucG9pbnRJblRyaWFuZ2xlKGh5IDwgbXkgPyBoeCA6IHF4LCBoeSwgbXgsIG15LCBoeSA8IG15ID8gcXggOiBoeCwgaHksIHAueCwgcC55KSkge1xuICAgICAgICAgICAgICAgIHRhbiA9IE1hdGguYWJzKGh5IC0gcC55KSAvIChoeCAtIHAueCk7IC8vIHRhbmdlbnRpYWxcbiAgICAgICAgICAgICAgICBpZiAoKHRhbiA8IHRhbk1pbiB8fCAodGFuID09PSB0YW5NaW4gJiYgcC54ID4gbS54KSkgJiYgR3JhcGhpY3NHZW9tZXRyeS5sb2NhbGx5SW5zaWRlKHAsIGhvbGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIG0gPSBwO1xuICAgICAgICAgICAgICAgICAgICB0YW5NaW4gPSB0YW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcCA9IHAubmV4dDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbTtcbiAgICB9XG4gICAgLy8gY2hlY2sgaWYgYSBwb2x5Z29uIGRpYWdvbmFsIGlzIGxvY2FsbHkgaW5zaWRlIHRoZSBwb2x5Z29uXG4gICAgc3RhdGljIGxvY2FsbHlJbnNpZGUoYSwgYikge1xuICAgICAgICByZXR1cm4gR3JhcGhpY3NHZW9tZXRyeS5hcmVhKGEucHJldiwgYSwgYS5uZXh0KSA8IDAgP1xuICAgICAgICAgICAgR3JhcGhpY3NHZW9tZXRyeS5hcmVhKGEsIGIsIGEubmV4dCkgPj0gMCAmJiBHcmFwaGljc0dlb21ldHJ5LmFyZWEoYSwgYS5wcmV2LCBiKSA+PSAwIDpcbiAgICAgICAgICAgIEdyYXBoaWNzR2VvbWV0cnkuYXJlYShhLCBiLCBhLnByZXYpIDwgMCB8fCBHcmFwaGljc0dlb21ldHJ5LmFyZWEoYSwgYS5uZXh0LCBiKSA8IDA7XG4gICAgfVxuICAgIC8vIGNoZWNrIGlmIGEgcG9pbnQgbGllcyB3aXRoaW4gYSBjb252ZXggdHJpYW5nbGVcbiAgICBzdGF0aWMgcG9pbnRJblRyaWFuZ2xlKGF4LCBheSwgYngsIGJ5LCBjeCwgY3ksIHB4LCBweSkge1xuICAgICAgICByZXR1cm4gKGN4IC0gcHgpICogKGF5IC0gcHkpIC0gKGF4IC0gcHgpICogKGN5IC0gcHkpID49IDAgJiZcbiAgICAgICAgICAgIChheCAtIHB4KSAqIChieSAtIHB5KSAtIChieCAtIHB4KSAqIChheSAtIHB5KSA+PSAwICYmXG4gICAgICAgICAgICAoYnggLSBweCkgKiAoY3kgLSBweSkgLSAoY3ggLSBweCkgKiAoYnkgLSBweSkgPj0gMDtcbiAgICB9XG4gICAgLy8gdHJ5IHNwbGl0dGluZyBwb2x5Z29uIGludG8gdHdvIGFuZCB0cmlhbmd1bGF0ZSB0aGVtIGluZGVwZW5kZW50bHlcbiAgICBzdGF0aWMgc3BsaXRFYXJjdXQoc3RhcnQsIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBpbnZTaXplKSB7XG4gICAgICAgIC8vIGxvb2sgZm9yIGEgdmFsaWQgZGlhZ29uYWwgdGhhdCBkaXZpZGVzIHRoZSBwb2x5Z29uIGludG8gdHdvXG4gICAgICAgIHZhciBhID0gc3RhcnQ7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIHZhciBiID0gYS5uZXh0Lm5leHQ7XG4gICAgICAgICAgICB3aGlsZSAoYiAhPT0gYS5wcmV2KSB7XG4gICAgICAgICAgICAgICAgaWYgKGEuaSAhPT0gYi5pICYmIEdyYXBoaWNzR2VvbWV0cnkuaXNWYWxpZERpYWdvbmFsKGEsIGIpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHNwbGl0IHRoZSBwb2x5Z29uIGluIHR3byBieSB0aGUgZGlhZ29uYWxcbiAgICAgICAgICAgICAgICAgICAgdmFyIGMgPSBHcmFwaGljc0dlb21ldHJ5LnNwbGl0UG9seWdvbihhLCBiKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gZmlsdGVyIGNvbGluZWFyIHBvaW50cyBhcm91bmQgdGhlIGN1dHNcbiAgICAgICAgICAgICAgICAgICAgYSA9IEdyYXBoaWNzR2VvbWV0cnkuZmlsdGVyUG9pbnRzKGEsIGEubmV4dCk7XG4gICAgICAgICAgICAgICAgICAgIGMgPSBHcmFwaGljc0dlb21ldHJ5LmZpbHRlclBvaW50cyhjLCBjLm5leHQpO1xuICAgICAgICAgICAgICAgICAgICAvLyBydW4gZWFyY3V0IG9uIGVhY2ggaGFsZlxuICAgICAgICAgICAgICAgICAgICBHcmFwaGljc0dlb21ldHJ5LmVhcmN1dExpbmtlZChhLCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgaW52U2l6ZSk7XG4gICAgICAgICAgICAgICAgICAgIEdyYXBoaWNzR2VvbWV0cnkuZWFyY3V0TGlua2VkKGMsIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBpbnZTaXplKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBiID0gYi5uZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYSA9IGEubmV4dDtcbiAgICAgICAgfSB3aGlsZSAoYSAhPT0gc3RhcnQpO1xuICAgIH1cbiAgICAvLyBjaGVjayBpZiBhIGRpYWdvbmFsIGJldHdlZW4gdHdvIHBvbHlnb24gbm9kZXMgaXMgdmFsaWQgKGxpZXMgaW4gcG9seWdvbiBpbnRlcmlvcilcbiAgICBzdGF0aWMgaXNWYWxpZERpYWdvbmFsKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGEubmV4dC5pICE9PSBiLmkgJiYgYS5wcmV2LmkgIT09IGIuaSAmJiAhR3JhcGhpY3NHZW9tZXRyeS5pbnRlcnNlY3RzUG9seWdvbihhLCBiKSAmJlxuICAgICAgICAgICAgR3JhcGhpY3NHZW9tZXRyeS5sb2NhbGx5SW5zaWRlKGEsIGIpICYmIEdyYXBoaWNzR2VvbWV0cnkubG9jYWxseUluc2lkZShiLCBhKSAmJiBHcmFwaGljc0dlb21ldHJ5Lm1pZGRsZUluc2lkZShhLCBiKTtcbiAgICB9XG4gICAgLy8gY2hlY2sgaWYgdGhlIG1pZGRsZSBwb2ludCBvZiBhIHBvbHlnb24gZGlhZ29uYWwgaXMgaW5zaWRlIHRoZSBwb2x5Z29uXG4gICAgc3RhdGljIG1pZGRsZUluc2lkZShhLCBiKSB7XG4gICAgICAgIHZhciBwID0gYSwgaW5zaWRlID0gZmFsc2UsIHB4ID0gKGEueCArIGIueCkgLyAyLCBweSA9IChhLnkgKyBiLnkpIC8gMjtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgaWYgKCgocC55ID4gcHkpICE9PSAocC5uZXh0LnkgPiBweSkpICYmIHAubmV4dC55ICE9PSBwLnkgJiZcbiAgICAgICAgICAgICAgICAocHggPCAocC5uZXh0LnggLSBwLngpICogKHB5IC0gcC55KSAvIChwLm5leHQueSAtIHAueSkgKyBwLngpKSB7XG4gICAgICAgICAgICAgICAgaW5zaWRlID0gIWluc2lkZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHAgPSBwLm5leHQ7XG4gICAgICAgIH0gd2hpbGUgKHAgIT09IGEpO1xuICAgICAgICByZXR1cm4gaW5zaWRlO1xuICAgIH1cbiAgICAvLyBjaGVjayBpZiBhIHBvbHlnb24gZGlhZ29uYWwgaW50ZXJzZWN0cyBhbnkgcG9seWdvbiBzZWdtZW50c1xuICAgIHN0YXRpYyBpbnRlcnNlY3RzUG9seWdvbihhLCBiKSB7XG4gICAgICAgIHZhciBwID0gYTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgaWYgKHAuaSAhPT0gYS5pICYmIHAubmV4dC5pICE9PSBhLmkgJiYgcC5pICE9PSBiLmkgJiYgcC5uZXh0LmkgIT09IGIuaSAmJlxuICAgICAgICAgICAgICAgIEdyYXBoaWNzR2VvbWV0cnkuaW50ZXJzZWN0cyhwLCBwLm5leHQsIGEsIGIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwID0gcC5uZXh0O1xuICAgICAgICB9IHdoaWxlIChwICE9PSBhKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBjaGVjayBpZiB0d28gc2VnbWVudHMgaW50ZXJzZWN0XG4gICAgc3RhdGljIGludGVyc2VjdHMocDEsIHExLCBwMiwgcTIpIHtcbiAgICAgICAgaWYgKChHcmFwaGljc0dlb21ldHJ5LmVxdWFscyhwMSwgcTEpICYmIEdyYXBoaWNzR2VvbWV0cnkuZXF1YWxzKHAyLCBxMikpIHx8XG4gICAgICAgICAgICAoR3JhcGhpY3NHZW9tZXRyeS5lcXVhbHMocDEsIHEyKSAmJiBHcmFwaGljc0dlb21ldHJ5LmVxdWFscyhwMiwgcTEpKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEdyYXBoaWNzR2VvbWV0cnkuYXJlYShwMSwgcTEsIHAyKSA+IDAgIT09IEdyYXBoaWNzR2VvbWV0cnkuYXJlYShwMSwgcTEsIHEyKSA+IDAgJiZcbiAgICAgICAgICAgIEdyYXBoaWNzR2VvbWV0cnkuYXJlYShwMiwgcTIsIHAxKSA+IDAgIT09IEdyYXBoaWNzR2VvbWV0cnkuYXJlYShwMiwgcTIsIHExKSA+IDA7XG4gICAgfVxuICAgIC8vIGdvIHRocm91Z2ggYWxsIHBvbHlnb24gbm9kZXMgYW5kIGN1cmUgc21hbGwgbG9jYWwgc2VsZi1pbnRlcnNlY3Rpb25zXG4gICAgc3RhdGljIGN1cmVMb2NhbEludGVyc2VjdGlvbnMoc3RhcnQsIHRyaWFuZ2xlcywgZGltKSB7XG4gICAgICAgIHZhciBwID0gc3RhcnQ7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIHZhciBhID0gcC5wcmV2LCBiID0gcC5uZXh0Lm5leHQ7XG4gICAgICAgICAgICBpZiAoIUdyYXBoaWNzR2VvbWV0cnkuZXF1YWxzKGEsIGIpICYmIEdyYXBoaWNzR2VvbWV0cnkuaW50ZXJzZWN0cyhhLCBwLCBwLm5leHQsIGIpICYmIEdyYXBoaWNzR2VvbWV0cnkubG9jYWxseUluc2lkZShhLCBiKSAmJiBHcmFwaGljc0dlb21ldHJ5LmxvY2FsbHlJbnNpZGUoYiwgYSkpIHtcbiAgICAgICAgICAgICAgICB0cmlhbmdsZXMucHVzaChhLmkgLyBkaW0pO1xuICAgICAgICAgICAgICAgIHRyaWFuZ2xlcy5wdXNoKHAuaSAvIGRpbSk7XG4gICAgICAgICAgICAgICAgdHJpYW5nbGVzLnB1c2goYi5pIC8gZGltKTtcbiAgICAgICAgICAgICAgICAvLyByZW1vdmUgdHdvIG5vZGVzIGludm9sdmVkXG4gICAgICAgICAgICAgICAgR3JhcGhpY3NHZW9tZXRyeS5yZW1vdmVOb2RlKHApO1xuICAgICAgICAgICAgICAgIEdyYXBoaWNzR2VvbWV0cnkucmVtb3ZlTm9kZShwLm5leHQpO1xuICAgICAgICAgICAgICAgIHAgPSBzdGFydCA9IGI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwID0gcC5uZXh0O1xuICAgICAgICB9IHdoaWxlIChwICE9PSBzdGFydCk7XG4gICAgICAgIHJldHVybiBwO1xuICAgIH1cbiAgICBzdGF0aWMgaXNFYXJIYXNoZWQoZWFyLCBtaW5YLCBtaW5ZLCBpbnZTaXplKSB7XG4gICAgICAgIHZhciBhID0gZWFyLnByZXYsIGIgPSBlYXIsIGMgPSBlYXIubmV4dDtcbiAgICAgICAgaWYgKEdyYXBoaWNzR2VvbWV0cnkuYXJlYShhLCBiLCBjKSA+PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0gLy8gcmVmbGV4LCBjYW4ndCBiZSBhbiBlYXJcbiAgICAgICAgLy8gdHJpYW5nbGUgYmJveDsgbWluICYgbWF4IGFyZSBjYWxjdWxhdGVkIGxpa2UgdGhpcyBmb3Igc3BlZWRcbiAgICAgICAgdmFyIG1pblRYID0gYS54IDwgYi54ID8gKGEueCA8IGMueCA/IGEueCA6IGMueCkgOiAoYi54IDwgYy54ID8gYi54IDogYy54KSwgbWluVFkgPSBhLnkgPCBiLnkgPyAoYS55IDwgYy55ID8gYS55IDogYy55KSA6IChiLnkgPCBjLnkgPyBiLnkgOiBjLnkpLCBtYXhUWCA9IGEueCA+IGIueCA/IChhLnggPiBjLnggPyBhLnggOiBjLngpIDogKGIueCA+IGMueCA/IGIueCA6IGMueCksIG1heFRZID0gYS55ID4gYi55ID8gKGEueSA+IGMueSA/IGEueSA6IGMueSkgOiAoYi55ID4gYy55ID8gYi55IDogYy55KTtcbiAgICAgICAgLy8gei1vcmRlciByYW5nZSBmb3IgdGhlIGN1cnJlbnQgdHJpYW5nbGUgYmJveDtcbiAgICAgICAgdmFyIG1pblogPSBHcmFwaGljc0dlb21ldHJ5LnpPcmRlcihtaW5UWCwgbWluVFksIG1pblgsIG1pblksIGludlNpemUpLCBtYXhaID0gR3JhcGhpY3NHZW9tZXRyeS56T3JkZXIobWF4VFgsIG1heFRZLCBtaW5YLCBtaW5ZLCBpbnZTaXplKTtcbiAgICAgICAgdmFyIHAgPSBlYXIucHJldlosIG4gPSBlYXIubmV4dFo7XG4gICAgICAgIC8vIGxvb2sgZm9yIHBvaW50cyBpbnNpZGUgdGhlIHRyaWFuZ2xlIGluIGJvdGggZGlyZWN0aW9uc1xuICAgICAgICB3aGlsZSAocCAmJiBwLnogPj0gbWluWiAmJiBuICYmIG4ueiA8PSBtYXhaKSB7XG4gICAgICAgICAgICBpZiAocCAhPT0gZWFyLnByZXYgJiYgcCAhPT0gZWFyLm5leHQgJiZcbiAgICAgICAgICAgICAgICBHcmFwaGljc0dlb21ldHJ5LnBvaW50SW5UcmlhbmdsZShhLngsIGEueSwgYi54LCBiLnksIGMueCwgYy55LCBwLngsIHAueSkgJiZcbiAgICAgICAgICAgICAgICBHcmFwaGljc0dlb21ldHJ5LmFyZWEocC5wcmV2LCBwLCBwLm5leHQpID49IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwID0gcC5wcmV2WjtcbiAgICAgICAgICAgIGlmIChuICE9PSBlYXIucHJldiAmJiBuICE9PSBlYXIubmV4dCAmJlxuICAgICAgICAgICAgICAgIEdyYXBoaWNzR2VvbWV0cnkucG9pbnRJblRyaWFuZ2xlKGEueCwgYS55LCBiLngsIGIueSwgYy54LCBjLnksIG4ueCwgbi55KSAmJlxuICAgICAgICAgICAgICAgIEdyYXBoaWNzR2VvbWV0cnkuYXJlYShuLnByZXYsIG4sIG4ubmV4dCkgPj0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG4gPSBuLm5leHRaO1xuICAgICAgICB9XG4gICAgICAgIC8vIGxvb2sgZm9yIHJlbWFpbmluZyBwb2ludHMgaW4gZGVjcmVhc2luZyB6LW9yZGVyXG4gICAgICAgIHdoaWxlIChwICYmIHAueiA+PSBtaW5aKSB7XG4gICAgICAgICAgICBpZiAocCAhPT0gZWFyLnByZXYgJiYgcCAhPT0gZWFyLm5leHQgJiZcbiAgICAgICAgICAgICAgICBHcmFwaGljc0dlb21ldHJ5LnBvaW50SW5UcmlhbmdsZShhLngsIGEueSwgYi54LCBiLnksIGMueCwgYy55LCBwLngsIHAueSkgJiZcbiAgICAgICAgICAgICAgICBHcmFwaGljc0dlb21ldHJ5LmFyZWEocC5wcmV2LCBwLCBwLm5leHQpID49IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwID0gcC5wcmV2WjtcbiAgICAgICAgfVxuICAgICAgICAvLyBsb29rIGZvciByZW1haW5pbmcgcG9pbnRzIGluIGluY3JlYXNpbmcgei1vcmRlclxuICAgICAgICB3aGlsZSAobiAmJiBuLnogPD0gbWF4Wikge1xuICAgICAgICAgICAgaWYgKG4gIT09IGVhci5wcmV2ICYmIG4gIT09IGVhci5uZXh0ICYmXG4gICAgICAgICAgICAgICAgR3JhcGhpY3NHZW9tZXRyeS5wb2ludEluVHJpYW5nbGUoYS54LCBhLnksIGIueCwgYi55LCBjLngsIGMueSwgbi54LCBuLnkpICYmXG4gICAgICAgICAgICAgICAgR3JhcGhpY3NHZW9tZXRyeS5hcmVhKG4ucHJldiwgbiwgbi5uZXh0KSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbiA9IG4ubmV4dFo7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8vIHotb3JkZXIgb2YgYSBwb2ludCBnaXZlbiBjb29yZHMgYW5kIGludmVyc2Ugb2YgdGhlIGxvbmdlciBzaWRlIG9mIGRhdGEgYmJveFxuICAgIHN0YXRpYyB6T3JkZXIoeCwgeSwgbWluWCwgbWluWSwgaW52U2l6ZSkge1xuICAgICAgICAvLyBjb29yZHMgYXJlIHRyYW5zZm9ybWVkIGludG8gbm9uLW5lZ2F0aXZlIDE1LWJpdCBpbnRlZ2VyIHJhbmdlXG4gICAgICAgIHggPSAzMjc2NyAqICh4IC0gbWluWCkgKiBpbnZTaXplO1xuICAgICAgICB5ID0gMzI3NjcgKiAoeSAtIG1pblkpICogaW52U2l6ZTtcbiAgICAgICAgeCA9ICh4IHwgKHggPDwgOCkpICYgMHgwMEZGMDBGRjtcbiAgICAgICAgeCA9ICh4IHwgKHggPDwgNCkpICYgMHgwRjBGMEYwRjtcbiAgICAgICAgeCA9ICh4IHwgKHggPDwgMikpICYgMHgzMzMzMzMzMztcbiAgICAgICAgeCA9ICh4IHwgKHggPDwgMSkpICYgMHg1NTU1NTU1NTtcbiAgICAgICAgeSA9ICh5IHwgKHkgPDwgOCkpICYgMHgwMEZGMDBGRjtcbiAgICAgICAgeSA9ICh5IHwgKHkgPDwgNCkpICYgMHgwRjBGMEYwRjtcbiAgICAgICAgeSA9ICh5IHwgKHkgPDwgMikpICYgMHgzMzMzMzMzMztcbiAgICAgICAgeSA9ICh5IHwgKHkgPDwgMSkpICYgMHg1NTU1NTU1NTtcbiAgICAgICAgcmV0dXJuIHggfCAoeSA8PCAxKTtcbiAgICB9XG4gICAgLy8gY2hlY2sgd2hldGhlciBhIHBvbHlnb24gbm9kZSBmb3JtcyBhIHZhbGlkIGVhciB3aXRoIGFkamFjZW50IG5vZGVzXG4gICAgc3RhdGljIGlzRWFyKGVhcikge1xuICAgICAgICB2YXIgYSA9IGVhci5wcmV2LCBiID0gZWFyLCBjID0gZWFyLm5leHQ7XG4gICAgICAgIGlmIChHcmFwaGljc0dlb21ldHJ5LmFyZWEoYSwgYiwgYykgPj0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9IC8vIHJlZmxleCwgY2FuJ3QgYmUgYW4gZWFyXG4gICAgICAgIC8vIG5vdyBtYWtlIHN1cmUgd2UgZG9uJ3QgaGF2ZSBvdGhlciBwb2ludHMgaW5zaWRlIHRoZSBwb3RlbnRpYWwgZWFyXG4gICAgICAgIHZhciBwID0gZWFyLm5leHQubmV4dDtcbiAgICAgICAgd2hpbGUgKHAgIT09IGVhci5wcmV2KSB7XG4gICAgICAgICAgICBpZiAoR3JhcGhpY3NHZW9tZXRyeS5wb2ludEluVHJpYW5nbGUoYS54LCBhLnksIGIueCwgYi55LCBjLngsIGMueSwgcC54LCBwLnkpICYmXG4gICAgICAgICAgICAgICAgR3JhcGhpY3NHZW9tZXRyeS5hcmVhKHAucHJldiwgcCwgcC5uZXh0KSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcCA9IHAubmV4dDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLy8gaW50ZXJsaW5rIHBvbHlnb24gbm9kZXMgaW4gei1vcmRlclxuICAgIHN0YXRpYyBpbmRleEN1cnZlKHN0YXJ0LCBtaW5YLCBtaW5ZLCBpbnZTaXplKSB7XG4gICAgICAgIHZhciBwID0gc3RhcnQ7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGlmIChwLnogPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBwLnogPSBHcmFwaGljc0dlb21ldHJ5LnpPcmRlcihwLngsIHAueSwgbWluWCwgbWluWSwgaW52U2l6ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwLnByZXZaID0gcC5wcmV2O1xuICAgICAgICAgICAgcC5uZXh0WiA9IHAubmV4dDtcbiAgICAgICAgICAgIHAgPSBwLm5leHQ7XG4gICAgICAgIH0gd2hpbGUgKHAgIT09IHN0YXJ0KTtcbiAgICAgICAgcC5wcmV2Wi5uZXh0WiA9IG51bGw7XG4gICAgICAgIHAucHJldlogPSBudWxsO1xuICAgICAgICBHcmFwaGljc0dlb21ldHJ5LnNvcnRMaW5rZWQocCk7XG4gICAgfVxuICAgIC8vIFNpbW9uIFRhdGhhbSdzIGxpbmtlZCBsaXN0IG1lcmdlIHNvcnQgYWxnb3JpdGhtXG4gICAgLy8gaHR0cDovL3d3dy5jaGlhcmsuZ3JlZW5lbmQub3JnLnVrL35zZ3RhdGhhbS9hbGdvcml0aG1zL2xpc3Rzb3J0Lmh0bWxcbiAgICBzdGF0aWMgc29ydExpbmtlZChsaXN0KSB7XG4gICAgICAgIHZhciBpLCBwLCBxLCBlLCB0YWlsLCBudW1NZXJnZXMsIHBTaXplLCBxU2l6ZSwgaW5TaXplID0gMTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgcCA9IGxpc3Q7XG4gICAgICAgICAgICBsaXN0ID0gbnVsbDtcbiAgICAgICAgICAgIHRhaWwgPSBudWxsO1xuICAgICAgICAgICAgbnVtTWVyZ2VzID0gMDtcbiAgICAgICAgICAgIHdoaWxlIChwKSB7XG4gICAgICAgICAgICAgICAgbnVtTWVyZ2VzKys7XG4gICAgICAgICAgICAgICAgcSA9IHA7XG4gICAgICAgICAgICAgICAgcFNpemUgPSAwO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBpblNpemU7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBwU2l6ZSsrO1xuICAgICAgICAgICAgICAgICAgICBxID0gcS5uZXh0WjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBxU2l6ZSA9IGluU2l6ZTtcbiAgICAgICAgICAgICAgICB3aGlsZSAocFNpemUgPiAwIHx8IChxU2l6ZSA+IDAgJiYgcSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBTaXplICE9PSAwICYmIChxU2l6ZSA9PT0gMCB8fCAhcSB8fCBwLnogPD0gcS56KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZSA9IHA7XG4gICAgICAgICAgICAgICAgICAgICAgICBwID0gcC5uZXh0WjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBTaXplLS07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlID0gcTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHEgPSBxLm5leHRaO1xuICAgICAgICAgICAgICAgICAgICAgICAgcVNpemUtLTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodGFpbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFpbC5uZXh0WiA9IGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaXN0ID0gZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlLnByZXZaID0gdGFpbDtcbiAgICAgICAgICAgICAgICAgICAgdGFpbCA9IGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHAgPSBxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGFpbC5uZXh0WiA9IG51bGw7XG4gICAgICAgICAgICBpblNpemUgKj0gMjtcbiAgICAgICAgfSB3aGlsZSAobnVtTWVyZ2VzID4gMSk7XG4gICAgICAgIHJldHVybiBsaXN0O1xuICAgIH1cbiAgICAvKipcbiAqIENhbGN1bGF0ZSB0aGUgcG9pbnRzIGZvciBhIHF1YWRyYXRpYyBiZXppZXIgY3VydmUuIChoZWxwZXIgZnVuY3Rpb24uLilcbiAqIEJhc2VkIG9uOiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy83ODUwOTcvaG93LWRvLWktaW1wbGVtZW50LWEtYmV6aWVyLWN1cnZlLWluLWNcbiAqXG4gKiBJZ25vcmVkIGZyb20gZG9jcyBzaW5jZSBpdCBpcyBub3QgZGlyZWN0bHkgZXhwb3NlZC5cbiAqXG4gKiBAaWdub3JlXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IGZyb21YIC0gT3JpZ2luIHBvaW50IHhcbiAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tWSAtIE9yaWdpbiBwb2ludCB4XG4gKiBAcGFyYW0ge251bWJlcn0gY3BYIC0gQ29udHJvbCBwb2ludCB4XG4gKiBAcGFyYW0ge251bWJlcn0gY3BZIC0gQ29udHJvbCBwb2ludCB5XG4gKiBAcGFyYW0ge251bWJlcn0gdG9YIC0gRGVzdGluYXRpb24gcG9pbnQgeFxuICogQHBhcmFtIHtudW1iZXJ9IHRvWSAtIERlc3RpbmF0aW9uIHBvaW50IHlcbiAqIEBwYXJhbSB7bnVtYmVyW119IFtvdXQ9W11dIC0gVGhlIG91dHB1dCBhcnJheSB0byBhZGQgcG9pbnRzIGludG8uIElmIG5vdCBwYXNzZWQsIGEgbmV3IGFycmF5IGlzIGNyZWF0ZWQuXG4gKiBAcmV0dXJuIHtudW1iZXJbXX0gYW4gYXJyYXkgb2YgcG9pbnRzXG4gKi9cbiAgICBzdGF0aWMgcXVhZHJhdGljQmV6aWVyQ3VydmUoZnJvbVgsIGZyb21ZLCBjcFgsIGNwWSwgdG9YLCB0b1ksIG91dCkge1xuICAgICAgICBpZiAob3V0ID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIG91dCA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuID0gMjA7XG4gICAgICAgIHZhciBwb2ludHMgPSBvdXQ7XG4gICAgICAgIHZhciB4YSA9IDA7XG4gICAgICAgIHZhciB5YSA9IDA7XG4gICAgICAgIHZhciB4YiA9IDA7XG4gICAgICAgIHZhciB5YiA9IDA7XG4gICAgICAgIHZhciB4ID0gMDtcbiAgICAgICAgdmFyIHkgPSAwO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgaiA9IDA7IGkgPD0gbjsgKytpKSB7XG4gICAgICAgICAgICBqID0gaSAvIG47XG4gICAgICAgICAgICAvLyBUaGUgR3JlZW4gTGluZVxuICAgICAgICAgICAgeGEgPSBHcmFwaGljc0dlb21ldHJ5LmdldFB0KGZyb21YLCBjcFgsIGopO1xuICAgICAgICAgICAgeWEgPSBHcmFwaGljc0dlb21ldHJ5LmdldFB0KGZyb21ZLCBjcFksIGopO1xuICAgICAgICAgICAgeGIgPSBHcmFwaGljc0dlb21ldHJ5LmdldFB0KGNwWCwgdG9YLCBqKTtcbiAgICAgICAgICAgIHliID0gR3JhcGhpY3NHZW9tZXRyeS5nZXRQdChjcFksIHRvWSwgaik7XG4gICAgICAgICAgICAvLyBUaGUgQmxhY2sgRG90XG4gICAgICAgICAgICB4ID0gR3JhcGhpY3NHZW9tZXRyeS5nZXRQdCh4YSwgeGIsIGopO1xuICAgICAgICAgICAgeSA9IEdyYXBoaWNzR2VvbWV0cnkuZ2V0UHQoeWEsIHliLCBqKTtcbiAgICAgICAgICAgIHBvaW50cy5wdXNoKHgsIHkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwb2ludHM7XG4gICAgfVxuICAgIC8qKlxuICogQ2FsY3VsYXRlIGEgc2luZ2xlIHBvaW50IGZvciBhIHF1YWRyYXRpYyBiZXppZXIgY3VydmUuXG4gKiBVdGlsaXR5IGZ1bmN0aW9uIHVzZWQgYnkgcXVhZHJhdGljQmV6aWVyQ3VydmUuXG4gKiBJZ25vcmVkIGZyb20gZG9jcyBzaW5jZSBpdCBpcyBub3QgZGlyZWN0bHkgZXhwb3NlZC5cbiAqXG4gKiBAaWdub3JlXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IG4xIC0gZmlyc3QgbnVtYmVyXG4gKiBAcGFyYW0ge251bWJlcn0gbjIgLSBzZWNvbmQgbnVtYmVyXG4gKiBAcGFyYW0ge251bWJlcn0gcGVyYyAtIHBlcmNlbnRhZ2VcbiAqIEByZXR1cm4ge251bWJlcn0gdGhlIHJlc3VsdFxuICpcbiAqL1xuICAgIHN0YXRpYyBnZXRQdChuMSwgbjIsIHBlcmMpIHtcbiAgICAgICAgdmFyIGRpZmYgPSBuMiAtIG4xO1xuICAgICAgICByZXR1cm4gbjEgKyAoZGlmZiAqIHBlcmMpO1xuICAgIH1cbn1cbkdyYXBoaWNzR2VvbWV0cnkuQkFUQ0hfUE9PTCA9IFtdO1xuR3JhcGhpY3NHZW9tZXRyeS5EUkFXX0NBTExfUE9PTCA9IFtdO1xuLyoqXG4qIFRoZSBtYXhpbXVtIG51bWJlciBvZiBwb2ludHMgdG8gY29uc2lkZXIgYW4gb2JqZWN0IFwiYmF0Y2hhYmxlXCIsXG4qIGFibGUgdG8gYmUgYmF0Y2hlZCBieSB0aGUgcmVuZGVyZXIncyBiYXRjaCBzeXN0ZW0uXG4qXG4qIEBtZW1iZXJvZiBQSVhJLkdyYXBoaWNzR2VvbWV0cnlcbiogQHN0YXRpY1xuKiBAbWVtYmVyIHtudW1iZXJ9IEJBVENIQUJMRV9TSVpFXG4qIEBkZWZhdWx0IDEwMFxuKi9cbkdyYXBoaWNzR2VvbWV0cnkuQkFUQ0hBQkxFX1NJWkUgPSAxMDA7XG4vKipcbiogQnVpbGRzIGEgcG9seWdvbiB0byBkcmF3XG4qXG4qIElnbm9yZWQgZnJvbSBkb2NzIHNpbmNlIGl0IGlzIG5vdCBkaXJlY3RseSBleHBvc2VkLlxuKlxuKiBAaWdub3JlXG4qIEBwcml2YXRlXG4qIEBwYXJhbSB7UElYSS5XZWJHTEdyYXBoaWNzRGF0YX0gZ3JhcGhpY3NEYXRhIC0gVGhlIGdyYXBoaWNzIG9iamVjdCBjb250YWluaW5nIGFsbCB0aGUgbmVjZXNzYXJ5IHByb3BlcnRpZXNcbiogQHBhcmFtIHtvYmplY3R9IHdlYkdMRGF0YSAtIGFuIG9iamVjdCBjb250YWluaW5nIGFsbCB0aGUgV2ViR0wtc3BlY2lmaWMgaW5mb3JtYXRpb24gdG8gY3JlYXRlIHRoaXMgc2hhcGVcbiogQHBhcmFtIHtvYmplY3R9IHdlYkdMRGF0YU5hdGl2ZUxpbmVzIC0gYW4gb2JqZWN0IGNvbnRhaW5pbmcgYWxsIHRoZSBXZWJHTC1zcGVjaWZpYyBpbmZvcm1hdGlvbiB0byBjcmVhdGUgbmF0aXZlTGluZXNcbiovXG5HcmFwaGljc0dlb21ldHJ5LmJ1aWxkUG9seSA9IHtcbiAgICBuYW1lOiBcImJ1aWxkUG9seVwiLFxuICAgIGJ1aWxkOiBmdW5jdGlvbiBidWlsZChncmFwaGljc0RhdGEpIHtcbiAgICAgICAgZ3JhcGhpY3NEYXRhLnBvaW50cyA9IGdyYXBoaWNzRGF0YS5zaGFwZS5wb2ludHMuc2xpY2UoKTtcbiAgICB9LFxuICAgIHRyaWFuZ3VsYXRlOiBmdW5jdGlvbiB0cmlhbmd1bGF0ZShncmFwaGljc0RhdGEsIGdyYXBoaWNzR2VvbWV0cnkpIHtcbiAgICAgICAgdmFyIHBvaW50cyA9IGdyYXBoaWNzRGF0YS5wb2ludHM7XG4gICAgICAgIHZhciBob2xlcyA9IGdyYXBoaWNzRGF0YS5ob2xlcztcbiAgICAgICAgdmFyIHZlcnRzID0gZ3JhcGhpY3NHZW9tZXRyeS5wb2ludHM7XG4gICAgICAgIHZhciBpbmRpY2VzID0gZ3JhcGhpY3NHZW9tZXRyeS5pbmRpY2VzO1xuICAgICAgICBpZiAocG9pbnRzLmxlbmd0aCA+PSA2KSB7XG4gICAgICAgICAgICB2YXIgaG9sZUFycmF5ID0gW107XG4gICAgICAgICAgICAvLyBQcm9jZXNzIGhvbGVzLi5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaG9sZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgaG9sZSA9IGhvbGVzW2ldO1xuICAgICAgICAgICAgICAgIGhvbGVBcnJheS5wdXNoKHBvaW50cy5sZW5ndGggLyAyKTtcbiAgICAgICAgICAgICAgICBwb2ludHMgPSBwb2ludHMuY29uY2F0KGhvbGUucG9pbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHNvcnQgY29sb3JcbiAgICAgICAgICAgIHZhciB0cmlhbmdsZXMgPSBHcmFwaGljc0dlb21ldHJ5LmVhcmN1dChwb2ludHMsIGhvbGVBcnJheSwgMik7XG4gICAgICAgICAgICBpZiAoIXRyaWFuZ2xlcykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB2ZXJ0UG9zID0gdmVydHMubGVuZ3RoIC8gMjtcbiAgICAgICAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IHRyaWFuZ2xlcy5sZW5ndGg7IGkkMSArPSAzKSB7XG4gICAgICAgICAgICAgICAgaW5kaWNlcy5wdXNoKHRyaWFuZ2xlc1tpJDFdICsgdmVydFBvcyk7XG4gICAgICAgICAgICAgICAgaW5kaWNlcy5wdXNoKHRyaWFuZ2xlc1tpJDEgKyAxXSArIHZlcnRQb3MpO1xuICAgICAgICAgICAgICAgIGluZGljZXMucHVzaCh0cmlhbmdsZXNbaSQxICsgMl0gKyB2ZXJ0UG9zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGkkMiA9IDA7IGkkMiA8IHBvaW50cy5sZW5ndGg7IGkkMisrKSB7XG4gICAgICAgICAgICAgICAgdmVydHMucHVzaChwb2ludHNbaSQyXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxufTtcbi8qKlxuKiBCdWlsZHMgYSByZWN0YW5nbGUgdG8gZHJhd1xuKlxuKiBJZ25vcmVkIGZyb20gZG9jcyBzaW5jZSBpdCBpcyBub3QgZGlyZWN0bHkgZXhwb3NlZC5cbipcbiogQGlnbm9yZVxuKiBAcHJpdmF0ZVxuKiBAcGFyYW0ge1BJWEkuV2ViR0xHcmFwaGljc0RhdGF9IGdyYXBoaWNzRGF0YSAtIFRoZSBncmFwaGljcyBvYmplY3QgY29udGFpbmluZyBhbGwgdGhlIG5lY2Vzc2FyeSBwcm9wZXJ0aWVzXG4qIEBwYXJhbSB7b2JqZWN0fSB3ZWJHTERhdGEgLSBhbiBvYmplY3QgY29udGFpbmluZyBhbGwgdGhlIFdlYkdMLXNwZWNpZmljIGluZm9ybWF0aW9uIHRvIGNyZWF0ZSB0aGlzIHNoYXBlXG4qIEBwYXJhbSB7b2JqZWN0fSB3ZWJHTERhdGFOYXRpdmVMaW5lcyAtIGFuIG9iamVjdCBjb250YWluaW5nIGFsbCB0aGUgV2ViR0wtc3BlY2lmaWMgaW5mb3JtYXRpb24gdG8gY3JlYXRlIG5hdGl2ZUxpbmVzXG4qL1xuR3JhcGhpY3NHZW9tZXRyeS5idWlsZFJlY3RhbmdsZSA9IHtcbiAgICBuYW1lOiBcImJ1aWxkUmVjdGFuZ2xlXCIsXG4gICAgYnVpbGQ6IGZ1bmN0aW9uIGJ1aWxkKGdyYXBoaWNzRGF0YSkge1xuICAgICAgICAvLyAtLS0gLy9cbiAgICAgICAgLy8gbmVlZCB0byBjb252ZXJ0IHBvaW50cyB0byBhIG5pY2UgcmVndWxhciBkYXRhXG4gICAgICAgIC8vXG4gICAgICAgIHZhciByZWN0RGF0YSA9IGdyYXBoaWNzRGF0YS5zaGFwZTtcbiAgICAgICAgdmFyIHggPSByZWN0RGF0YS54O1xuICAgICAgICB2YXIgeSA9IHJlY3REYXRhLnk7XG4gICAgICAgIHZhciB3aWR0aCA9IHJlY3REYXRhLndpZHRoO1xuICAgICAgICB2YXIgaGVpZ2h0ID0gcmVjdERhdGEuaGVpZ2h0O1xuICAgICAgICB2YXIgcG9pbnRzID0gZ3JhcGhpY3NEYXRhLnBvaW50cztcbiAgICAgICAgcG9pbnRzLmxlbmd0aCA9IDA7XG4gICAgICAgIHBvaW50cy5wdXNoKHgsIHksIHggKyB3aWR0aCwgeSwgeCArIHdpZHRoLCB5ICsgaGVpZ2h0LCB4LCB5ICsgaGVpZ2h0KTtcbiAgICB9LFxuICAgIHRyaWFuZ3VsYXRlOiBmdW5jdGlvbiB0cmlhbmd1bGF0ZShncmFwaGljc0RhdGEsIGdyYXBoaWNzR2VvbWV0cnkpIHtcbiAgICAgICAgdmFyIHBvaW50cyA9IGdyYXBoaWNzRGF0YS5wb2ludHM7XG4gICAgICAgIHZhciB2ZXJ0cyA9IGdyYXBoaWNzR2VvbWV0cnkucG9pbnRzO1xuICAgICAgICB2YXIgdmVydFBvcyA9IHZlcnRzLmxlbmd0aCAvIDI7XG4gICAgICAgIHZlcnRzLnB1c2gocG9pbnRzWzBdLCBwb2ludHNbMV0sIHBvaW50c1syXSwgcG9pbnRzWzNdLCBwb2ludHNbNl0sIHBvaW50c1s3XSwgcG9pbnRzWzRdLCBwb2ludHNbNV0pO1xuICAgICAgICBncmFwaGljc0dlb21ldHJ5LmluZGljZXMucHVzaCh2ZXJ0UG9zLCB2ZXJ0UG9zICsgMSwgdmVydFBvcyArIDIsIHZlcnRQb3MgKyAxLCB2ZXJ0UG9zICsgMiwgdmVydFBvcyArIDMpO1xuICAgIH0sXG59O1xuLyoqXG4qIEJ1aWxkcyBhIHJvdW5kZWQgcmVjdGFuZ2xlIHRvIGRyYXdcbipcbiogSWdub3JlZCBmcm9tIGRvY3Mgc2luY2UgaXQgaXMgbm90IGRpcmVjdGx5IGV4cG9zZWQuXG4qXG4qIEBpZ25vcmVcbiogQHByaXZhdGVcbiogQHBhcmFtIHtQSVhJLldlYkdMR3JhcGhpY3NEYXRhfSBncmFwaGljc0RhdGEgLSBUaGUgZ3JhcGhpY3Mgb2JqZWN0IGNvbnRhaW5pbmcgYWxsIHRoZSBuZWNlc3NhcnkgcHJvcGVydGllc1xuKiBAcGFyYW0ge29iamVjdH0gd2ViR0xEYXRhIC0gYW4gb2JqZWN0IGNvbnRhaW5pbmcgYWxsIHRoZSBXZWJHTC1zcGVjaWZpYyBpbmZvcm1hdGlvbiB0byBjcmVhdGUgdGhpcyBzaGFwZVxuKiBAcGFyYW0ge29iamVjdH0gd2ViR0xEYXRhTmF0aXZlTGluZXMgLSBhbiBvYmplY3QgY29udGFpbmluZyBhbGwgdGhlIFdlYkdMLXNwZWNpZmljIGluZm9ybWF0aW9uIHRvIGNyZWF0ZSBuYXRpdmVMaW5lc1xuKi9cbkdyYXBoaWNzR2VvbWV0cnkuYnVpbGRSb3VuZGVkUmVjdGFuZ2xlID0ge1xuICAgIG5hbWU6IFwiYnVpbGRSb3VuZGVkUmVjdGFuZ2xlXCIsXG4gICAgYnVpbGQ6IGZ1bmN0aW9uIGJ1aWxkKGdyYXBoaWNzRGF0YSkge1xuICAgICAgICB2YXIgcnJlY3REYXRhID0gZ3JhcGhpY3NEYXRhLnNoYXBlO1xuICAgICAgICB2YXIgcG9pbnRzID0gZ3JhcGhpY3NEYXRhLnBvaW50cztcbiAgICAgICAgdmFyIHggPSBycmVjdERhdGEueDtcbiAgICAgICAgdmFyIHkgPSBycmVjdERhdGEueTtcbiAgICAgICAgdmFyIHdpZHRoID0gcnJlY3REYXRhLndpZHRoO1xuICAgICAgICB2YXIgaGVpZ2h0ID0gcnJlY3REYXRhLmhlaWdodDtcbiAgICAgICAgdmFyIHJhZGl1cyA9IHJyZWN0RGF0YS5yYWRpdXM7XG4gICAgICAgIHBvaW50cy5sZW5ndGggPSAwO1xuICAgICAgICBHcmFwaGljc0dlb21ldHJ5LnF1YWRyYXRpY0JlemllckN1cnZlKHgsIHkgKyByYWRpdXMsIHgsIHksIHggKyByYWRpdXMsIHksIHBvaW50cyk7XG4gICAgICAgIEdyYXBoaWNzR2VvbWV0cnkucXVhZHJhdGljQmV6aWVyQ3VydmUoeCArIHdpZHRoIC0gcmFkaXVzLCB5LCB4ICsgd2lkdGgsIHksIHggKyB3aWR0aCwgeSArIHJhZGl1cywgcG9pbnRzKTtcbiAgICAgICAgR3JhcGhpY3NHZW9tZXRyeS5xdWFkcmF0aWNCZXppZXJDdXJ2ZSh4ICsgd2lkdGgsIHkgKyBoZWlnaHQgLSByYWRpdXMsIHggKyB3aWR0aCwgeSArIGhlaWdodCwgeCArIHdpZHRoIC0gcmFkaXVzLCB5ICsgaGVpZ2h0LCBwb2ludHMpO1xuICAgICAgICBHcmFwaGljc0dlb21ldHJ5LnF1YWRyYXRpY0JlemllckN1cnZlKHggKyByYWRpdXMsIHkgKyBoZWlnaHQsIHgsIHkgKyBoZWlnaHQsIHgsIHkgKyBoZWlnaHQgLSByYWRpdXMsIHBvaW50cyk7XG4gICAgICAgIC8vIHRoaXMgdGlueSBudW1iZXIgZGVhbHMgd2l0aCB0aGUgaXNzdWUgdGhhdCBvY2N1cnMgd2hlbiBwb2ludHMgb3ZlcmxhcCBhbmQgZWFyY3V0IGZhaWxzIHRvIHRyaWFuZ3VsYXRlIHRoZSBpdGVtLlxuICAgICAgICAvLyBUT0RPIC0gZml4IHRoaXMgcHJvcGVybHksIHRoaXMgaXMgbm90IHZlcnkgZWxlZ2FudC4uIGJ1dCBpdCB3b3JrcyBmb3Igbm93LlxuICAgIH0sXG4gICAgdHJpYW5ndWxhdGU6IGZ1bmN0aW9uIHRyaWFuZ3VsYXRlKGdyYXBoaWNzRGF0YSwgZ3JhcGhpY3NHZW9tZXRyeSkge1xuICAgICAgICB2YXIgcG9pbnRzID0gZ3JhcGhpY3NEYXRhLnBvaW50cztcbiAgICAgICAgdmFyIHZlcnRzID0gZ3JhcGhpY3NHZW9tZXRyeS5wb2ludHM7XG4gICAgICAgIHZhciBpbmRpY2VzID0gZ3JhcGhpY3NHZW9tZXRyeS5pbmRpY2VzO1xuICAgICAgICB2YXIgdmVjUG9zID0gdmVydHMubGVuZ3RoIC8gMjtcbiAgICAgICAgdmFyIHRyaWFuZ2xlcyA9IEdyYXBoaWNzR2VvbWV0cnkuZWFyY3V0KHBvaW50cywgbnVsbCwgMik7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBqID0gdHJpYW5nbGVzLmxlbmd0aDsgaSA8IGo7IGkgKz0gMykge1xuICAgICAgICAgICAgaW5kaWNlcy5wdXNoKHRyaWFuZ2xlc1tpXSArIHZlY1Bvcyk7XG4gICAgICAgICAgICAvLyAgICAgaW5kaWNlcy5wdXNoKHRyaWFuZ2xlc1tpXSArIHZlY1Bvcyk7XG4gICAgICAgICAgICBpbmRpY2VzLnB1c2godHJpYW5nbGVzW2kgKyAxXSArIHZlY1Bvcyk7XG4gICAgICAgICAgICAvLyAgIGluZGljZXMucHVzaCh0cmlhbmdsZXNbaSArIDJdICsgdmVjUG9zKTtcbiAgICAgICAgICAgIGluZGljZXMucHVzaCh0cmlhbmdsZXNbaSArIDJdICsgdmVjUG9zKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpJDEgPSAwLCBqJDEgPSBwb2ludHMubGVuZ3RoOyBpJDEgPCBqJDE7IGkkMSsrKSB7XG4gICAgICAgICAgICB2ZXJ0cy5wdXNoKHBvaW50c1tpJDFdLCBwb2ludHNbKytpJDFdKTtcbiAgICAgICAgfVxuICAgIH0sXG59O1xuLyoqXG4qIEJ1aWxkcyBhIGNpcmNsZSB0byBkcmF3XG4qXG4qIElnbm9yZWQgZnJvbSBkb2NzIHNpbmNlIGl0IGlzIG5vdCBkaXJlY3RseSBleHBvc2VkLlxuKlxuKiBAaWdub3JlXG4qIEBwcml2YXRlXG4qIEBwYXJhbSB7UElYSS5XZWJHTEdyYXBoaWNzRGF0YX0gZ3JhcGhpY3NEYXRhIC0gVGhlIGdyYXBoaWNzIG9iamVjdCB0byBkcmF3XG4qIEBwYXJhbSB7b2JqZWN0fSB3ZWJHTERhdGEgLSBhbiBvYmplY3QgY29udGFpbmluZyBhbGwgdGhlIFdlYkdMLXNwZWNpZmljIGluZm9ybWF0aW9uIHRvIGNyZWF0ZSB0aGlzIHNoYXBlXG4qIEBwYXJhbSB7b2JqZWN0fSB3ZWJHTERhdGFOYXRpdmVMaW5lcyAtIGFuIG9iamVjdCBjb250YWluaW5nIGFsbCB0aGUgV2ViR0wtc3BlY2lmaWMgaW5mb3JtYXRpb24gdG8gY3JlYXRlIG5hdGl2ZUxpbmVzXG4qL1xuR3JhcGhpY3NHZW9tZXRyeS5idWlsZENpcmNsZSA9IHtcbiAgICBuYW1lOiBcImJ1aWxkQ2lyY2xlXCIsXG4gICAgYnVpbGQ6IGZ1bmN0aW9uIGJ1aWxkKGdyYXBoaWNzRGF0YSkge1xuICAgICAgICAvLyBuZWVkIHRvIGNvbnZlcnQgcG9pbnRzIHRvIGEgbmljZSByZWd1bGFyIGRhdGFcbiAgICAgICAgdmFyIGNpcmNsZURhdGEgPSBncmFwaGljc0RhdGEuc2hhcGU7XG4gICAgICAgIHZhciBwb2ludHMgPSBncmFwaGljc0RhdGEucG9pbnRzO1xuICAgICAgICB2YXIgeCA9IGNpcmNsZURhdGEueDtcbiAgICAgICAgdmFyIHkgPSBjaXJjbGVEYXRhLnk7XG4gICAgICAgIHZhciB3aWR0aDtcbiAgICAgICAgdmFyIGhlaWdodDtcbiAgICAgICAgcG9pbnRzLmxlbmd0aCA9IDA7XG4gICAgICAgIC8vIFRPRE8gLSBiaXQgaGFja3k/P1xuICAgICAgICBpZiAoZ3JhcGhpY3NEYXRhLnR5cGUgPT09IFNoYXBlU2V0dGluZ3NfMS5TaGFwZVNldHRpbmdzLlNIQVBFUy5DSVJDKSB7XG4gICAgICAgICAgICB3aWR0aCA9IGNpcmNsZURhdGEucmFkaXVzO1xuICAgICAgICAgICAgaGVpZ2h0ID0gY2lyY2xlRGF0YS5yYWRpdXM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB3aWR0aCA9IGNpcmNsZURhdGEud2lkdGg7XG4gICAgICAgICAgICBoZWlnaHQgPSBjaXJjbGVEYXRhLmhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICBpZiAod2lkdGggPT09IDAgfHwgaGVpZ2h0ID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRvdGFsU2VncyA9IE1hdGguZmxvb3IoMzAgKiBNYXRoLnNxcnQoY2lyY2xlRGF0YS5yYWRpdXMpKVxuICAgICAgICAgICAgfHwgTWF0aC5mbG9vcigxNSAqIE1hdGguc3FydChjaXJjbGVEYXRhLndpZHRoICsgY2lyY2xlRGF0YS5oZWlnaHQpKTtcbiAgICAgICAgdG90YWxTZWdzIC89IDIuMztcbiAgICAgICAgdmFyIHNlZyA9IChNYXRoLlBJICogMikgLyB0b3RhbFNlZ3M7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG90YWxTZWdzOyBpKyspIHtcbiAgICAgICAgICAgIHBvaW50cy5wdXNoKHggKyAoTWF0aC5zaW4oLXNlZyAqIGkpICogd2lkdGgpLCB5ICsgKE1hdGguY29zKC1zZWcgKiBpKSAqIGhlaWdodCkpO1xuICAgICAgICB9XG4gICAgICAgIHBvaW50cy5wdXNoKHBvaW50c1swXSwgcG9pbnRzWzFdKTtcbiAgICB9LFxuICAgIHRyaWFuZ3VsYXRlOiBmdW5jdGlvbiB0cmlhbmd1bGF0ZShncmFwaGljc0RhdGEsIGdyYXBoaWNzR2VvbWV0cnkpIHtcbiAgICAgICAgdmFyIHBvaW50cyA9IGdyYXBoaWNzRGF0YS5wb2ludHM7XG4gICAgICAgIHZhciB2ZXJ0cyA9IGdyYXBoaWNzR2VvbWV0cnkucG9pbnRzO1xuICAgICAgICB2YXIgaW5kaWNlcyA9IGdyYXBoaWNzR2VvbWV0cnkuaW5kaWNlcztcbiAgICAgICAgdmFyIHZlcnRQb3MgPSB2ZXJ0cy5sZW5ndGggLyAyO1xuICAgICAgICB2YXIgY2VudGVyID0gdmVydFBvcztcbiAgICAgICAgdmVydHMucHVzaChncmFwaGljc0RhdGEuc2hhcGUueCwgZ3JhcGhpY3NEYXRhLnNoYXBlLnkpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgdmVydHMucHVzaChwb2ludHNbaV0sIHBvaW50c1tpICsgMV0pO1xuICAgICAgICAgICAgLy8gYWRkIHNvbWUgdXZzXG4gICAgICAgICAgICBpbmRpY2VzLnB1c2godmVydFBvcysrLCBjZW50ZXIsIHZlcnRQb3MpO1xuICAgICAgICB9XG4gICAgfSxcbn07XG5leHBvcnRzLkdyYXBoaWNzR2VvbWV0cnkgPSBHcmFwaGljc0dlb21ldHJ5O1xuY2xhc3MgTm9kZSB7XG4gICAgY29uc3RydWN0b3IoaSwgeCwgeSkge1xuICAgICAgICAvLyB2ZXJ0ZXggaW5kZXggaW4gY29vcmRpbmF0ZXMgYXJyYXlcbiAgICAgICAgdGhpcy5pID0gaTtcbiAgICAgICAgLy8gdmVydGV4IGNvb3JkaW5hdGVzXG4gICAgICAgIHRoaXMueCA9IHg7XG4gICAgICAgIHRoaXMueSA9IHk7XG4gICAgICAgIC8vIHByZXZpb3VzIGFuZCBuZXh0IHZlcnRleCBub2RlcyBpbiBhIHBvbHlnb24gcmluZ1xuICAgICAgICB0aGlzLnByZXYgPSBudWxsO1xuICAgICAgICB0aGlzLm5leHQgPSBudWxsO1xuICAgICAgICAvLyB6LW9yZGVyIGN1cnZlIHZhbHVlXG4gICAgICAgIHRoaXMueiA9IG51bGw7XG4gICAgICAgIC8vIHByZXZpb3VzIGFuZCBuZXh0IG5vZGVzIGluIHotb3JkZXJcbiAgICAgICAgdGhpcy5wcmV2WiA9IG51bGw7XG4gICAgICAgIHRoaXMubmV4dFogPSBudWxsO1xuICAgICAgICAvLyBpbmRpY2F0ZXMgd2hldGhlciB0aGlzIGlzIGEgc3RlaW5lciBwb2ludFxuICAgICAgICB0aGlzLnN0ZWluZXIgPSBmYWxzZTtcbiAgICB9XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IE1hdHJpeF8xID0gcmVxdWlyZShcIi4vTWF0cml4XCIpO1xuY2xhc3MgR3JvdXBEOCB7XG4gICAgc3RhdGljIHVYKGluZCkge1xuICAgICAgICBHcm91cEQ4LmluaXQoKTtcbiAgICAgICAgcmV0dXJuIEdyb3VwRDgudXhbaW5kXTtcbiAgICB9XG4gICAgc3RhdGljIHVZKGluZCkge1xuICAgICAgICBHcm91cEQ4LmluaXQoKTtcbiAgICAgICAgcmV0dXJuIEdyb3VwRDgudXlbaW5kXTtcbiAgICB9XG4gICAgc3RhdGljIHZYKGluZCkge1xuICAgICAgICBHcm91cEQ4LmluaXQoKTtcbiAgICAgICAgcmV0dXJuIEdyb3VwRDgudnhbaW5kXTtcbiAgICB9XG4gICAgc3RhdGljIHZZKGluZCkge1xuICAgICAgICBHcm91cEQ4LmluaXQoKTtcbiAgICAgICAgcmV0dXJuIEdyb3VwRDgudnlbaW5kXTtcbiAgICB9XG4gICAgc3RhdGljIGludihyb3RhdGlvbikge1xuICAgICAgICBpZiAocm90YXRpb24gJiA4KSB7XG4gICAgICAgICAgICByZXR1cm4gcm90YXRpb24gJiAxNTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKC1yb3RhdGlvbikgJiA3O1xuICAgIH1cbiAgICBzdGF0aWMgYWRkKHJvdGF0aW9uU2Vjb25kLCByb3RhdGlvbkZpcnN0KSB7XG4gICAgICAgIEdyb3VwRDguaW5pdCgpO1xuICAgICAgICByZXR1cm4gR3JvdXBEOC5tdWxbcm90YXRpb25TZWNvbmRdW3JvdGF0aW9uRmlyc3RdO1xuICAgIH1cbiAgICBzdGF0aWMgc3ViKHJvdGF0aW9uU2Vjb25kLCByb3RhdGlvbkZpcnN0KSB7XG4gICAgICAgIEdyb3VwRDguaW5pdCgpO1xuICAgICAgICByZXR1cm4gR3JvdXBEOC5tdWxbcm90YXRpb25TZWNvbmRdW0dyb3VwRDguaW52KHJvdGF0aW9uRmlyc3QpXTtcbiAgICB9XG4gICAgc3RhdGljIHJvdGF0ZTE4MChyb3RhdGlvbikge1xuICAgICAgICByZXR1cm4gcm90YXRpb24gXiA0O1xuICAgIH1cbiAgICBzdGF0aWMgaXNWZXJ0aWNhbChyb3RhdGlvbikge1xuICAgICAgICByZXR1cm4gKHJvdGF0aW9uICYgMykgPT09IDI7XG4gICAgfVxuICAgIHN0YXRpYyBieURpcmVjdGlvbihkeCwgZHkpIHtcbiAgICAgICAgR3JvdXBEOC5pbml0KCk7XG4gICAgICAgIGlmIChNYXRoLmFicyhkeCkgKiAyIDw9IE1hdGguYWJzKGR5KSkge1xuICAgICAgICAgICAgaWYgKGR5ID49IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gR3JvdXBEOC5TO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIEdyb3VwRDguTjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChNYXRoLmFicyhkeSkgKiAyIDw9IE1hdGguYWJzKGR4KSkge1xuICAgICAgICAgICAgaWYgKGR4ID4gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBHcm91cEQ4LkU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gR3JvdXBEOC5XO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGR5ID4gMCkge1xuICAgICAgICAgICAgaWYgKGR4ID4gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBHcm91cEQ4LlNFO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIEdyb3VwRDguU1c7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZHggPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gR3JvdXBEOC5ORTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gR3JvdXBEOC5OVztcbiAgICB9XG4gICAgc3RhdGljIG1hdHJpeEFwcGVuZFJvdGF0aW9uSW52KG1hdHJpeCwgcm90YXRpb24sIHR4ID0gMCwgdHkgPSAwKSB7XG4gICAgICAgIEdyb3VwRDguaW5pdCgpO1xuICAgICAgICBsZXQgbWF0ID0gR3JvdXBEOC50ZW1wTWF0cmljZXNbR3JvdXBEOC5pbnYocm90YXRpb24pXTtcbiAgICAgICAgbWF0LnR4ID0gdHg7XG4gICAgICAgIG1hdC50eSA9IHR5O1xuICAgICAgICBtYXRyaXguYXBwZW5kKG1hdCk7XG4gICAgfVxuICAgIHN0YXRpYyBzaWdudW0oeCkge1xuICAgICAgICBpZiAoeCA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoeCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBzdGF0aWMgaW5pdCgpIHtcbiAgICAgICAgaWYgKEdyb3VwRDguaXNJbml0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgR3JvdXBEOC5pc0luaXQgPSB0cnVlO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDE2OyBpKyspIHtcbiAgICAgICAgICAgIHZhciByb3cgPSBbXTtcbiAgICAgICAgICAgIEdyb3VwRDgubXVsLnB1c2gocm93KTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgMTY7IGorKykge1xuICAgICAgICAgICAgICAgIHZhciBfdXggPSBHcm91cEQ4LnNpZ251bSgoR3JvdXBEOC51eFtpXSAqIEdyb3VwRDgudXhbal0pICsgKEdyb3VwRDgudnhbaV0gKiBHcm91cEQ4LnV5W2pdKSk7XG4gICAgICAgICAgICAgICAgdmFyIF91eSA9IEdyb3VwRDguc2lnbnVtKChHcm91cEQ4LnV5W2ldICogR3JvdXBEOC51eFtqXSkgKyAoR3JvdXBEOC52eVtpXSAqIEdyb3VwRDgudXlbal0pKTtcbiAgICAgICAgICAgICAgICB2YXIgX3Z4ID0gR3JvdXBEOC5zaWdudW0oKEdyb3VwRDgudXhbaV0gKiBHcm91cEQ4LnZ4W2pdKSArIChHcm91cEQ4LnZ4W2ldICogR3JvdXBEOC52eVtqXSkpO1xuICAgICAgICAgICAgICAgIHZhciBfdnkgPSBHcm91cEQ4LnNpZ251bSgoR3JvdXBEOC51eVtpXSAqIEdyb3VwRDgudnhbal0pICsgKEdyb3VwRDgudnlbaV0gKiBHcm91cEQ4LnZ5W2pdKSk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCAxNjsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChHcm91cEQ4LnV4W2tdID09PSBfdXggJiYgR3JvdXBEOC51eVtrXSA9PT0gX3V5ICYmIEdyb3VwRDgudnhba10gPT09IF92eCAmJiBHcm91cEQ4LnZ5W2tdID09PSBfdnkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdy5wdXNoKGspO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgMTY7IGkkMSsrKSB7XG4gICAgICAgICAgICB2YXIgbWF0ID0gbmV3IE1hdHJpeF8xLk1hdHJpeCgpO1xuICAgICAgICAgICAgbWF0LnNldChHcm91cEQ4LnV4W2kkMV0sIEdyb3VwRDgudXlbaSQxXSwgR3JvdXBEOC52eFtpJDFdLCBHcm91cEQ4LnZ5W2kkMV0sIDAsIDApO1xuICAgICAgICAgICAgR3JvdXBEOC50ZW1wTWF0cmljZXMucHVzaChtYXQpO1xuICAgICAgICB9XG4gICAgfVxufVxuR3JvdXBEOC5pc0luaXQgPSBmYWxzZTtcbkdyb3VwRDguRSA9IDA7XG5Hcm91cEQ4LlNFID0gMTtcbkdyb3VwRDguUyA9IDI7XG5Hcm91cEQ4LlNXID0gMztcbkdyb3VwRDguVyA9IDQ7XG5Hcm91cEQ4Lk5XID0gNTtcbkdyb3VwRDguTiA9IDY7XG5Hcm91cEQ4Lk5FID0gNztcbkdyb3VwRDguTUlSUk9SX1ZFUlRJQ0FMID0gODtcbkdyb3VwRDguTUlSUk9SX0hPUklaT05UQUwgPSAxMjtcbkdyb3VwRDgudXggPSBbMSwgMSwgMCwgLTEsIC0xLCAtMSwgMCwgMSwgMSwgMSwgMCwgLTEsIC0xLCAtMSwgMCwgMV07XG5Hcm91cEQ4LnV5ID0gWzAsIDEsIDEsIDEsIDAsIC0xLCAtMSwgLTEsIDAsIDEsIDEsIDEsIDAsIC0xLCAtMSwgLTFdO1xuR3JvdXBEOC52eCA9IFswLCAtMSwgLTEsIC0xLCAwLCAxLCAxLCAxLCAwLCAxLCAxLCAxLCAwLCAtMSwgLTEsIC0xXTtcbkdyb3VwRDgudnkgPSBbMSwgMSwgMCwgLTEsIC0xLCAtMSwgMCwgMSwgLTEsIC0xLCAwLCAxLCAxLCAxLCAwLCAtMV07XG5Hcm91cEQ4LnRlbXBNYXRyaWNlcyA9IFtdO1xuR3JvdXBEOC5tdWwgPSBbXTtcbmV4cG9ydHMuR3JvdXBEOCA9IEdyb3VwRDg7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IEV2ZW50XzEgPSByZXF1aXJlKFwiLi9FdmVudFwiKTtcbmNsYXNzIElPRXJyb3JFdmVudCBleHRlbmRzIEV2ZW50XzEuRXZlbnQge1xuICAgIGNvbnN0cnVjdG9yKHR5cGUsIGJ1YmJsZSA9IHRydWUsIGNhbmNlbGFibGUgPSB0cnVlKSB7XG4gICAgICAgIHN1cGVyKHR5cGUsIGJ1YmJsZSwgY2FuY2VsYWJsZSk7XG4gICAgICAgIHRoaXMuZXJyb3JJZCA9IDA7XG4gICAgfVxuICAgIGNsb25lKCkge1xuICAgICAgICB2YXIgZXZlbnQgPSBuZXcgSU9FcnJvckV2ZW50KHRoaXMudHlwZSwgdGhpcy5idWJibGVzLCB0aGlzLmNhbmNlbGFibGUpO1xuICAgICAgICBldmVudC50ZXh0ID0gdGhpcy50ZXh0O1xuICAgICAgICBldmVudC5lcnJvcklkID0gdGhpcy5lcnJvcklkO1xuICAgICAgICByZXR1cm4gZXZlbnQ7XG4gICAgfVxuICAgIGdldCBpc0Rpc3Bvc2FibGUoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5JT0Vycm9yRXZlbnQuSU9fRVJST1IgPSBcImlvRXJyb3JcIjtcbmV4cG9ydHMuSU9FcnJvckV2ZW50ID0gSU9FcnJvckV2ZW50O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBCYXNlSW1hZ2VSZXNvdXJjZV8xID0gcmVxdWlyZShcIi4vQmFzZUltYWdlUmVzb3VyY2VcIik7XG5jb25zdCBEaXNwbGF5U2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL0Rpc3BsYXlTZXR0aW5nc1wiKTtcbmNsYXNzIEltYWdlUmVzb3VyY2UgZXh0ZW5kcyBCYXNlSW1hZ2VSZXNvdXJjZV8xLkJhc2VJbWFnZVJlc291cmNlIHtcbiAgICBjb25zdHJ1Y3Rvcihzb3VyY2UsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBzdXBlcihzb3VyY2UpO1xuICAgICAgICBpZiAoIShzb3VyY2UgaW5zdGFuY2VvZiBIVE1MSW1hZ2VFbGVtZW50KSkge1xuICAgICAgICAgICAgdmFyIGltYWdlRWxlbWVudCA9IG5ldyBJbWFnZSgpO1xuICAgICAgICAgICAgLy8gQmFzZUltYWdlUmVzb3VyY2UuY3Jvc3NPcmlnaW4oaW1hZ2VFbGVtZW50LCBzb3VyY2UsIG9wdGlvbnMuY3Jvc3NvcmlnaW4pO1xuICAgICAgICAgICAgaW1hZ2VFbGVtZW50LnNyYyA9IHNvdXJjZTtcbiAgICAgICAgICAgIHNvdXJjZSA9IGltYWdlRWxlbWVudDtcbiAgICAgICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVUkwgb2YgdGhlIGltYWdlIHNvdXJjZVxuICAgICAgICAgKiBAbWVtYmVyIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnVybCA9IHNvdXJjZS5zcmM7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGVuIHByb2Nlc3MgaXMgY29tcGxldGVkXG4gICAgICAgICAqIEBtZW1iZXIge1Byb21pc2U8dm9pZD59XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9wcm9jZXNzID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHRoZSBpbWFnZSBzaG91bGQgYmUgZGlzcG9zZWQgYWZ0ZXIgdXBsb2FkXG4gICAgICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XG4gICAgICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnByZXNlcnZlQml0bWFwID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBjYXBhYmxlLCBjb252ZXJ0IHRoZSBpbWFnZSB1c2luZyBjcmVhdGVJbWFnZUJpdG1hcCBBUElcbiAgICAgICAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICAgICAgICogQGRlZmF1bHQgUElYSS5zZXR0aW5ncy5DUkVBVEVfSU1BR0VfQklUTUFQXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNyZWF0ZUJpdG1hcCA9IG9wdGlvbnMuY3JlYXRlQml0bWFwICE9PSBmYWxzZSAmJiBEaXNwbGF5U2V0dGluZ3NfMS5EaXNwbGF5U2V0dGluZ3MuQ1JFQVRFX0lNQUdFX0JJVE1BUCAmJiAhIXdpbmRvdy5jcmVhdGVJbWFnZUJpdG1hcDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnRyb2xzIHRleHR1cmUgcHJlbXVsdGlwbHlBbHBoYSBmaWVsZFxuICAgICAgICAgKiBDb3BpZXMgZnJvbSBvcHRpb25zXG4gICAgICAgICAqIEBtZW1iZXIge2Jvb2xlYW58bnVsbH1cbiAgICAgICAgICogQHJlYWRvbmx5XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnByZW11bHRpcGx5QWxwaGEgPSBvcHRpb25zLnByZW11bHRpcGx5QWxwaGEgIT09IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIEltYWdlQml0bWFwIGVsZW1lbnQgY3JlYXRlZCBmb3IgSFRNTEltYWdlRWxlbWVudFxuICAgICAgICAgKiBAbWVtYmVyIHtJbWFnZUJpdG1hcH1cbiAgICAgICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5iaXRtYXAgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogUHJvbWlzZSB3aGVuIGxvYWRpbmdcbiAgICAgICAgICogQG1lbWJlciB7UHJvbWlzZTx2b2lkPn1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fbG9hZCA9IG51bGw7XG4gICAgICAgIGlmIChvcHRpb25zLmF1dG9Mb2FkICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgdGhpcy5sb2FkKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogcmV0dXJucyBhIHByb21pc2Ugd2hlbiBpbWFnZSB3aWxsIGJlIGxvYWRlZCBhbmQgcHJvY2Vzc2VkXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtjcmVhdGVCaXRtYXA9dHJ1ZV0gd2hldGhlciBwcm9jZXNzIGltYWdlIGludG8gYml0bWFwXG4gICAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAgICovXG4gICAgbG9hZChjcmVhdGVCaXRtYXAgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGNyZWF0ZUJpdG1hcCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmNyZWF0ZUJpdG1hcCA9IGNyZWF0ZUJpdG1hcDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fbG9hZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xvYWQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbG9hZCA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnVybCA9IHRoaXMuc291cmNlLnNyYztcbiAgICAgICAgICAgIHZhciByZWYgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIHNvdXJjZSA9IHJlZi5zb3VyY2U7XG4gICAgICAgICAgICB2YXIgY29tcGxldGVkID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNvdXJjZS5vbmxvYWQgPSBudWxsO1xuICAgICAgICAgICAgICAgIHNvdXJjZS5vbmVycm9yID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc2l6ZShzb3VyY2Uud2lkdGgsIHNvdXJjZS5oZWlnaHQpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2xvYWQgPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNyZWF0ZUJpdG1hcCkge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHRoaXMucHJvY2VzcygpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUodGhpcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChzb3VyY2UuY29tcGxldGUgJiYgc291cmNlLnNyYykge1xuICAgICAgICAgICAgICAgIGNvbXBsZXRlZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc291cmNlLm9ubG9hZCA9IGNvbXBsZXRlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLl9sb2FkO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgKiBDYWxsZWQgd2hlbiB3ZSBuZWVkIHRvIGNvbnZlcnQgaW1hZ2UgaW50byBCaXRtYXBJbWFnZS5cbiAgICAqIENhbiBiZSBjYWxsZWQgbXVsdGlwbGUgdGltZXMsIHJlYWwgcHJvbWlzZSBpcyBjYWNoZWQgaW5zaWRlLlxuICAgICpcbiAgICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fSBjYWNoZWQgcHJvbWlzZSB0byBmaWxsIHRoYXQgYml0bWFwXG4gICAgKi9cbiAgICBwcm9jZXNzKCkge1xuICAgICAgICBpZiAodGhpcy5fcHJvY2VzcyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Byb2Nlc3M7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYml0bWFwICE9PSBudWxsIHx8ICF3aW5kb3cuY3JlYXRlSW1hZ2VCaXRtYXApIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJvY2VzcyA9IHdpbmRvdy5jcmVhdGVJbWFnZUJpdG1hcCh0aGlzLnNvdXJjZSwgMCwgMCwgdGhpcy5zb3VyY2Uud2lkdGgsIHRoaXMuc291cmNlLmhlaWdodClcbiAgICAgICAgICAgIC50aGVuKChiaXRtYXApID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChcIlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYml0bWFwID0gYml0bWFwO1xuICAgICAgICAgICAgdGhpcy51cGRhdGUoMCk7XG4gICAgICAgICAgICB0aGlzLl9wcm9jZXNzID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcyk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJvY2VzcztcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICogVXBsb2FkIHRoZSBpbWFnZSByZXNvdXJjZSB0byBHUFUuXG4gICAgKlxuICAgICogQHBhcmFtIHtQSVhJLlJlbmRlcmVyfSByZW5kZXJlciAtIFJlbmRlcmVyIHRvIHVwbG9hZCB0b1xuICAgICogQHBhcmFtIHtQSVhJLkJhc2VUZXh0dXJlfSBiYXNlVGV4dHVyZSAtIEJhc2VUZXh0dXJlIGZvciB0aGlzIHJlc291cmNlXG4gICAgKiBAcGFyYW0ge1BJWEkuR0xUZXh0dXJlfSBnbFRleHR1cmUgLSBHTFRleHR1cmUgdG8gdXNlXG4gICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpcyBzdWNjZXNzXG4gICAgKi9cbiAgICB1cGxvYWQocmVuZGVyZXIsIGJhc2VUZXh0dXJlLCBnbFRleHR1cmUpIHtcbiAgICAgICAgYmFzZVRleHR1cmUucHJlbXVsdGlwbHlBbHBoYSA9IHRoaXMucHJlbXVsdGlwbHlBbHBoYTtcbiAgICAgICAgaWYgKCF0aGlzLmNyZWF0ZUJpdG1hcCkge1xuICAgICAgICAgICAgcmV0dXJuIHN1cGVyLnVwbG9hZChyZW5kZXJlciwgYmFzZVRleHR1cmUsIGdsVGV4dHVyZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmJpdG1hcCkge1xuICAgICAgICAgICAgLy8geWVhaCwgaWdub3JlIHRoZSBvdXRwdXRcbiAgICAgICAgICAgIHRoaXMucHJvY2VzcygpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmJpdG1hcCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdXBlci51cGxvYWQocmVuZGVyZXIsIGJhc2VUZXh0dXJlLCBnbFRleHR1cmUsIHRoaXMuYml0bWFwKTtcbiAgICAgICAgaWYgKCF0aGlzLnByZXNlcnZlQml0bWFwKSB7XG4gICAgICAgICAgICAvLyBjaGVja3MgaWYgdGhlcmUgYXJlIG90aGVyIHJlbmRlcmVycyB0aGF0IHBvc3NpYmx5IG5lZWQgdGhpcyBiaXRtYXBcbiAgICAgICAgICAgIHZhciBmbGFnID0gdHJ1ZTtcbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBiYXNlVGV4dHVyZS5fZ2xUZXh0dXJlcykge1xuICAgICAgICAgICAgICAgIHZhciBvdGhlclRleCA9IGJhc2VUZXh0dXJlLl9nbFRleHR1cmVzW2tleV07XG4gICAgICAgICAgICAgICAgaWYgKG90aGVyVGV4ICE9PSBnbFRleHR1cmUgJiYgb3RoZXJUZXguZGlydHlJZCAhPT0gYmFzZVRleHR1cmUuZGlydHlJZCkge1xuICAgICAgICAgICAgICAgICAgICBmbGFnID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmbGFnKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYml0bWFwLmNsb3NlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYml0bWFwLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuYml0bWFwID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICogRGVzdHJveXMgdGhpcyB0ZXh0dXJlXG4gICAgKiBAb3ZlcnJpZGVcbiAgICAqL1xuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgIHN1cGVyLmRpc3Bvc2UoKTtcbiAgICAgICAgaWYgKHRoaXMuYml0bWFwKSB7XG4gICAgICAgICAgICB0aGlzLmJpdG1hcC5jbG9zZSgpO1xuICAgICAgICAgICAgdGhpcy5iaXRtYXAgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3Byb2Nlc3MgPSBudWxsO1xuICAgICAgICB0aGlzLl9sb2FkID0gbnVsbDtcbiAgICB9XG4gICAgO1xufVxuZXhwb3J0cy5JbWFnZVJlc291cmNlID0gSW1hZ2VSZXNvdXJjZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgTG9nZ2VyXzEgPSByZXF1aXJlKFwiLi9Mb2dnZXJcIik7XG5jbGFzcyBJbnN0YW5jZUNvdW50ZXIge1xuICAgIHN0YXRpYyBlbmFibGUoKSB7XG4gICAgICAgIEluc3RhbmNlQ291bnRlci5FTkFCTEVEID0gdHJ1ZTtcbiAgICB9XG4gICAgc3RhdGljIHJlY3ljbGVDb3VudChpbnN0YW5jZSkge1xuICAgICAgICBpZiAoIUluc3RhbmNlQ291bnRlci5FTkFCTEVEKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFJbnN0YW5jZUNvdW50ZXIucmVjeWNsZUNsYXNzSW5zdGFuY2VzW2luc3RhbmNlLmNsYXNzTmFtZV0pIHtcbiAgICAgICAgICAgIEluc3RhbmNlQ291bnRlci5yZWN5Y2xlQ2xhc3NJbnN0YW5jZXNbaW5zdGFuY2UuY2xhc3NOYW1lXSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgSW5zdGFuY2VDb3VudGVyLnJlY3ljbGVDbGFzc0luc3RhbmNlc1tpbnN0YW5jZS5jbGFzc05hbWVdKys7XG4gICAgICAgIC8vIHRyYWNlKGluc3RhbmNlLmNsYXNzTmFtZSArIFwiIGRlc3RydWN0b3IgY291bnQ6IFwiICsgSW5zdGFuY2VDb3VudGVyLnJlY3ljbGVDbGFzc0luc3RhbmNlc1tpbnN0YW5jZS5jbGFzc05hbWVdKSAgICAgICAgXG4gICAgfVxuICAgIHN0YXRpYyBkZXN0cnVjdG9yQ291bnQoaW5zdGFuY2UpIHtcbiAgICAgICAgaWYgKCFJbnN0YW5jZUNvdW50ZXIuRU5BQkxFRCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghSW5zdGFuY2VDb3VudGVyLmRlc3RydWN0b3JDbGFzc0luc3RhbmNlc1tpbnN0YW5jZS5jbGFzc05hbWVdKSB7XG4gICAgICAgICAgICBJbnN0YW5jZUNvdW50ZXIuZGVzdHJ1Y3RvckNsYXNzSW5zdGFuY2VzW2luc3RhbmNlLmNsYXNzTmFtZV0gPSAwO1xuICAgICAgICB9XG4gICAgICAgIEluc3RhbmNlQ291bnRlci5kZXN0cnVjdG9yQ2xhc3NJbnN0YW5jZXNbaW5zdGFuY2UuY2xhc3NOYW1lXSsrO1xuICAgICAgICAvLyB0cmFjZShpbnN0YW5jZS5jbGFzc05hbWUgKyBcIiBkZXN0cnVjdG9yIGNvdW50OiBcIiArIEluc3RhbmNlQ291bnRlci5kZXN0cnVjdG9yQ2xhc3NJbnN0YW5jZXNbaW5zdGFuY2UuY2xhc3NOYW1lXSkgICAgICAgIFxuICAgIH1cbiAgICBzdGF0aWMgY291bnQoaW5zdGFuY2UpIHtcbiAgICAgICAgaWYgKCFJbnN0YW5jZUNvdW50ZXIuRU5BQkxFRCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghSW5zdGFuY2VDb3VudGVyLmNsYXNzSW5zdGFuY2VzW2luc3RhbmNlLmNsYXNzTmFtZV0pIHtcbiAgICAgICAgICAgIEluc3RhbmNlQ291bnRlci5jbGFzc0luc3RhbmNlc1tpbnN0YW5jZS5jbGFzc05hbWVdID0gMDtcbiAgICAgICAgfVxuICAgICAgICBJbnN0YW5jZUNvdW50ZXIuY2xhc3NJbnN0YW5jZXNbaW5zdGFuY2UuY2xhc3NOYW1lXSsrO1xuICAgICAgICBsZXQgY3JlYXRlZCA9IEluc3RhbmNlQ291bnRlci5jbGFzc0luc3RhbmNlc1tpbnN0YW5jZS5jbGFzc05hbWVdO1xuICAgICAgICBsZXQgcmVjeWxlZCA9IDA7XG4gICAgICAgIGxldCBkZXN0cm95ZWQgPSAwO1xuICAgICAgICBpZiAoSW5zdGFuY2VDb3VudGVyLmRlc3RydWN0b3JDbGFzc0luc3RhbmNlc1tpbnN0YW5jZS5jbGFzc05hbWVdKSB7XG4gICAgICAgICAgICBkZXN0cm95ZWQgPSBJbnN0YW5jZUNvdW50ZXIuZGVzdHJ1Y3RvckNsYXNzSW5zdGFuY2VzW2luc3RhbmNlLmNsYXNzTmFtZV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEluc3RhbmNlQ291bnRlci5yZWN5Y2xlQ2xhc3NJbnN0YW5jZXNbaW5zdGFuY2UuY2xhc3NOYW1lXSkge1xuICAgICAgICAgICAgcmVjeWxlZCA9IEluc3RhbmNlQ291bnRlci5yZWN5Y2xlQ2xhc3NJbnN0YW5jZXNbaW5zdGFuY2UuY2xhc3NOYW1lXTtcbiAgICAgICAgfVxuICAgICAgICBMb2dnZXJfMS50cmFjZShpbnN0YW5jZS5jbGFzc05hbWUgKyBcIiBjcmVhdGVkOiBcIiArIGNyZWF0ZWQgKyBcIiAsIGRlc3Ryb3llZDogXCIgKyBkZXN0cm95ZWQgKyBcIiAsIHJlY3ljbGVkOiBcIiArIHJlY3lsZWQpO1xuICAgIH1cbiAgICBzdGF0aWMgYWRkQ2FsbChjYWxsVGFyZ2V0LCBjYWxsZXIpIHtcbiAgICAgICAgaWYgKCFJbnN0YW5jZUNvdW50ZXIuRU5BQkxFRCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjYWxsc3RhY2sgPSBjYWxsVGFyZ2V0ICsgXCI6XCIgKyBjYWxsZXI7XG4gICAgICAgIGlmICghSW5zdGFuY2VDb3VudGVyW2NhbGxzdGFja10pIHtcbiAgICAgICAgICAgIEluc3RhbmNlQ291bnRlcltjYWxsc3RhY2tdID0gMDtcbiAgICAgICAgfVxuICAgICAgICBJbnN0YW5jZUNvdW50ZXJbY2FsbHN0YWNrXSsrO1xuICAgICAgICBMb2dnZXJfMS50cmFjZShjYWxsZXIgKyBcIiBjYWxsZWQgXCIgKyBjYWxsVGFyZ2V0ICsgXCIgXCIgKyBJbnN0YW5jZUNvdW50ZXJbY2FsbHN0YWNrXSArIFwiIHRpbWVzLlwiKTtcbiAgICB9XG59XG5JbnN0YW5jZUNvdW50ZXIuY2xhc3NJbnN0YW5jZXMgPSB7fTtcbkluc3RhbmNlQ291bnRlci5kZXN0cnVjdG9yQ2xhc3NJbnN0YW5jZXMgPSB7fTtcbkluc3RhbmNlQ291bnRlci5yZWN5Y2xlQ2xhc3NJbnN0YW5jZXMgPSB7fTtcbkluc3RhbmNlQ291bnRlci5jYWxsU3RhY2tzID0ge307XG5JbnN0YW5jZUNvdW50ZXIuRU5BQkxFRCA9IGZhbHNlO1xuZXhwb3J0cy5JbnN0YW5jZUNvdW50ZXIgPSBJbnN0YW5jZUNvdW50ZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IFBvaW50XzEgPSByZXF1aXJlKFwiLi4vZmxhc2gvZ2VvbS9Qb2ludFwiKTtcbmNvbnN0IEZsYXNoQmFzZU9iamVjdF8xID0gcmVxdWlyZShcIi4vRmxhc2hCYXNlT2JqZWN0XCIpO1xuY2xhc3MgSW50ZXJhY3Rpb25EYXRhIGV4dGVuZHMgRmxhc2hCYXNlT2JqZWN0XzEuRmxhc2hCYXNlT2JqZWN0IHtcbiAgICBkZXN0cnVjdG9yKCkge1xuICAgICAgICBpZiAodGhpcy5nbG9iYWwpIHtcbiAgICAgICAgICAgIHRoaXMuZ2xvYmFsLnJlY3ljbGUoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmdsb2JhbCA9IG51bGw7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmdsb2JhbCA9IFBvaW50XzEuUG9pbnQuZ2V0UG9pbnQoKTtcbiAgICAgICAgdGhpcy50YXJnZXQgPSBudWxsO1xuICAgICAgICB0aGlzLm9yaWdpbmFsRXZlbnQgPSBudWxsO1xuICAgICAgICB0aGlzLmlkZW50aWZpZXIgPSBudWxsO1xuICAgICAgICB0aGlzLmlzUHJpbWFyeSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmJ1dHRvbiA9IDA7XG4gICAgICAgIHRoaXMuYnV0dG9ucyA9IDA7XG4gICAgICAgIHRoaXMud2lkdGggPSAwO1xuICAgICAgICB0aGlzLmhlaWdodCA9IDA7XG4gICAgICAgIHRoaXMudGlsdFggPSAwO1xuICAgICAgICB0aGlzLnRpbHRZID0gMDtcbiAgICAgICAgdGhpcy5wb2ludGVyVHlwZSA9IG51bGw7XG4gICAgICAgIHRoaXMucHJlc3N1cmUgPSAwO1xuICAgICAgICB0aGlzLnJvdGF0aW9uQW5nbGUgPSAwO1xuICAgICAgICB0aGlzLnR3aXN0ID0gMDtcbiAgICAgICAgdGhpcy50YW5nZW50aWFsUHJlc3N1cmUgPSAwO1xuICAgICAgICB0aGlzLndoaWNoID0gMDtcbiAgICB9XG4gICAgZ2V0TG9jYWxQb3NpdGlvbihkaXNwbGF5T2JqZWN0LCBwb2ludCA9IG51bGwsIGdsb2JhbFBvcyA9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGRpc3BsYXlPYmplY3Qud29ybGRUcmFuc2Zvcm0uYXBwbHlJbnZlcnNlKGdsb2JhbFBvcyB8fCB0aGlzLmdsb2JhbCwgcG9pbnQpO1xuICAgIH1cbiAgICA7XG4gICAgY29weUV2ZW50KGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudC5pc1ByaW1hcnkpIHtcbiAgICAgICAgICAgIHRoaXMuaXNQcmltYXJ5ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJ1dHRvbiA9IGV2ZW50LmJ1dHRvbjtcbiAgICAgICAgdGhpcy5idXR0b25zID0gTnVtYmVyLmlzSW50ZWdlcihldmVudC5idXR0b25zKSA/IGV2ZW50LmJ1dHRvbnMgOiBldmVudC53aGljaDtcbiAgICAgICAgdGhpcy53aWR0aCA9IGV2ZW50LndpZHRoO1xuICAgICAgICB0aGlzLmhlaWdodCA9IGV2ZW50LmhlaWdodDtcbiAgICAgICAgdGhpcy50aWx0WCA9IGV2ZW50LnRpbHRYO1xuICAgICAgICB0aGlzLnRpbHRZID0gZXZlbnQudGlsdFk7XG4gICAgICAgIHRoaXMucG9pbnRlclR5cGUgPSBldmVudC5wb2ludGVyVHlwZTtcbiAgICAgICAgdGhpcy5wcmVzc3VyZSA9IGV2ZW50LnByZXNzdXJlO1xuICAgICAgICB0aGlzLnJvdGF0aW9uQW5nbGUgPSBldmVudC5yb3RhdGlvbkFuZ2xlO1xuICAgICAgICB0aGlzLnR3aXN0ID0gZXZlbnQudHdpc3QgfHwgMDtcbiAgICAgICAgdGhpcy50YW5nZW50aWFsUHJlc3N1cmUgPSBldmVudC50YW5nZW50aWFsUHJlc3N1cmUgfHwgMDtcbiAgICB9XG4gICAgO1xuICAgIGdldCBwb2ludGVySWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlkZW50aWZpZXI7XG4gICAgfVxuICAgIDtcbiAgICByZXNldCgpIHtcbiAgICAgICAgdGhpcy5pc1ByaW1hcnkgPSBmYWxzZTtcbiAgICB9XG4gICAgO1xufVxuZXhwb3J0cy5JbnRlcmFjdGlvbkRhdGEgPSBJbnRlcmFjdGlvbkRhdGE7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IEV2ZW50XzEgPSByZXF1aXJlKFwiLi9FdmVudFwiKTtcbmNsYXNzIEludGVyYWN0aW9uRXZlbnQgZXh0ZW5kcyBFdmVudF8xLkV2ZW50IHtcbiAgICBjb25zdHJ1Y3Rvcih0eXBlLCBidWJibGUgPSB0cnVlLCBjYW5jZWxhYmxlID0gdHJ1ZSkge1xuICAgICAgICBzdXBlcih0eXBlLCBidWJibGUsIGNhbmNlbGFibGUpO1xuICAgICAgICB0aGlzLnRhcmdldCA9IG51bGw7XG4gICAgICAgIHRoaXMuc3RvcHBlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9jdXJyZW50VGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fdHlwZSA9IG51bGw7XG4gICAgICAgIHRoaXMuZGF0YSA9IG51bGw7XG4gICAgfVxuICAgIHJlc2V0KCkge1xuICAgICAgICB0aGlzLnN0b3BwZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fY3VycmVudFRhcmdldCA9IG51bGw7XG4gICAgICAgIHRoaXMudGFyZ2V0ID0gbnVsbDtcbiAgICB9XG4gICAgO1xuICAgIHN0b3BQcm9wYWdhdGlvbigpIHtcbiAgICAgICAgdGhpcy5zdG9wcGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgO1xufVxuZXhwb3J0cy5JbnRlcmFjdGlvbkV2ZW50ID0gSW50ZXJhY3Rpb25FdmVudDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgSW50ZXJhY3Rpb25EYXRhXzEgPSByZXF1aXJlKFwiLi9JbnRlcmFjdGlvbkRhdGFcIik7XG5jb25zdCBJbnRlcmFjdGlvbkV2ZW50XzEgPSByZXF1aXJlKFwiLi9JbnRlcmFjdGlvbkV2ZW50XCIpO1xuY29uc3QgTW91c2VFdmVudF8xID0gcmVxdWlyZShcIi4vTW91c2VFdmVudFwiKTtcbmNvbnN0IEludGVyYWN0aW9uVHJhY2tpbmdEYXRhXzEgPSByZXF1aXJlKFwiLi9JbnRlcmFjdGlvblRyYWNraW5nRGF0YVwiKTtcbmNvbnN0IFRpY2tlcl8xID0gcmVxdWlyZShcIi4vVGlja2VyXCIpO1xuY29uc3QgUG9pbnRfMSA9IHJlcXVpcmUoXCIuLi9mbGFzaC9nZW9tL1BvaW50XCIpO1xuY29uc3QgQ29udGFpbmVyXzEgPSByZXF1aXJlKFwiLi9Db250YWluZXJcIik7XG5jb25zdCBSZWN0YW5nbGVfMSA9IHJlcXVpcmUoXCIuLi9mbGFzaC9nZW9tL1JlY3RhbmdsZVwiKTtcbmNvbnN0IEV2ZW50RGlzcGF0Y2hlcl8xID0gcmVxdWlyZShcIi4vRXZlbnREaXNwYXRjaGVyXCIpO1xuY29uc3QgSW5zdGFuY2VDb3VudGVyXzEgPSByZXF1aXJlKFwiLi9JbnN0YW5jZUNvdW50ZXJcIik7XG5jbGFzcyBJbnRlcmFjdGlvbk1hbmFnZXIgZXh0ZW5kcyBFdmVudERpc3BhdGNoZXJfMS5FdmVudERpc3BhdGNoZXIge1xuICAgIGNvbnN0cnVjdG9yKHJlbmRlcmVyKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMudXBkYXRlID0gKGRlbHRhVGltZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fZGVsdGFUaW1lICs9IGRlbHRhVGltZTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9kZWx0YVRpbWUgPCB0aGlzLmludGVyYWN0aW9uRnJlcXVlbmN5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fZGVsdGFUaW1lID0gMDtcbiAgICAgICAgICAgIGlmICghdGhpcy5pbnRlcmFjdGlvbkRPTUVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5kaWRNb3ZlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaWRNb3ZlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jdXJzb3IgPSBudWxsO1xuICAgICAgICAgICAgZm9yIChsZXQgayBpbiB0aGlzLmFjdGl2ZUludGVyYWN0aW9uRGF0YSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmFjdGl2ZUludGVyYWN0aW9uRGF0YS5oYXNPd25Qcm9wZXJ0eShrKSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgaW50ZXJhY3Rpb25EYXRhID0gdGhpcy5hY3RpdmVJbnRlcmFjdGlvbkRhdGFba107XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnRlcmFjdGlvbkRhdGEub3JpZ2luYWxFdmVudCAmJiBpbnRlcmFjdGlvbkRhdGEucG9pbnRlclR5cGUgIT09ICd0b3VjaCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBpbnRlcmFjdGlvbkV2ZW50ID0gdGhpcy5jb25maWd1cmVJbnRlcmFjdGlvbkV2ZW50Rm9yRE9NRXZlbnQodGhpcy5ldmVudERhdGEsIGludGVyYWN0aW9uRGF0YS5vcmlnaW5hbEV2ZW50LCBpbnRlcmFjdGlvbkRhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzSW50ZXJhY3RpdmUoaW50ZXJhY3Rpb25FdmVudCwgdGhpcy5yZW5kZXJlci5fbGFzdE9iamVjdFJlbmRlcmVkLCB0aGlzLnByb2Nlc3NQb2ludGVyT3Zlck91dCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNldEN1cnNvck1vZGUodGhpcy5jdXJzb3IpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLm9uUG9pbnRlclVwID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5zdXBwb3J0c1RvdWNoRXZlbnRzICYmIGV2ZW50LnBvaW50ZXJUeXBlID09PSAndG91Y2gnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5vblBvaW50ZXJDb21wbGV0ZShldmVudCwgZmFsc2UsIHRoaXMucHJvY2Vzc1BvaW50ZXJVcCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMub25Qb2ludGVyQ2FuY2VsID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5zdXBwb3J0c1RvdWNoRXZlbnRzICYmIGV2ZW50LnBvaW50ZXJUeXBlID09PSAndG91Y2gnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5vblBvaW50ZXJDb21wbGV0ZShldmVudCwgdHJ1ZSwgdGhpcy5wcm9jZXNzUG9pbnRlckNhbmNlbCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMub25Qb2ludGVyT3ZlciA9IChvcmlnaW5hbEV2ZW50KSA9PiB7XG4gICAgICAgICAgICBsZXQgZXZlbnRzID0gdGhpcy5ub3JtYWxpemVUb1BvaW50ZXJEYXRhKG9yaWdpbmFsRXZlbnQpO1xuICAgICAgICAgICAgbGV0IGV2ZW50ID0gZXZlbnRzWzBdO1xuICAgICAgICAgICAgbGV0IGludGVyYWN0aW9uRGF0YSA9IHRoaXMuZ2V0SW50ZXJhY3Rpb25EYXRhRm9yUG9pbnRlcklkKGV2ZW50KTtcbiAgICAgICAgICAgIGxldCBpbnRlcmFjdGlvbkV2ZW50ID0gdGhpcy5jb25maWd1cmVJbnRlcmFjdGlvbkV2ZW50Rm9yRE9NRXZlbnQodGhpcy5ldmVudERhdGEsIGV2ZW50LCBpbnRlcmFjdGlvbkRhdGEpO1xuICAgICAgICAgICAgaW50ZXJhY3Rpb25FdmVudC5kYXRhLm9yaWdpbmFsRXZlbnQgPSBldmVudDtcbiAgICAgICAgICAgIGlmIChldmVudC5wb2ludGVyVHlwZSA9PT0gJ21vdXNlJykge1xuICAgICAgICAgICAgICAgIHRoaXMubW91c2VPdmVyUmVuZGVyZXIgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHBvaW50ZXIgPSBuZXcgTW91c2VFdmVudF8xLk1vdXNlRXZlbnQoTW91c2VFdmVudF8xLk1vdXNlRXZlbnQuUE9JTlRFUl9PVkVSKTtcbiAgICAgICAgICAgIHBvaW50ZXIuZGF0YSA9IGludGVyYWN0aW9uRGF0YTtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChwb2ludGVyKTtcbiAgICAgICAgICAgIGlmIChldmVudC5wb2ludGVyVHlwZSA9PT0gJ21vdXNlJyB8fCBldmVudC5wb2ludGVyVHlwZSA9PT0gJ3BlbicpIHtcbiAgICAgICAgICAgICAgICBsZXQgcG9pbnRlciA9IG5ldyBNb3VzZUV2ZW50XzEuTW91c2VFdmVudChNb3VzZUV2ZW50XzEuTW91c2VFdmVudC5NT1VTRV9PVkVSKTtcbiAgICAgICAgICAgICAgICBwb2ludGVyLmRhdGEgPSBpbnRlcmFjdGlvbkRhdGE7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KHBvaW50ZXIpO1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChwb2ludGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vblBvaW50ZXJPdXQgPSAob3JpZ2luYWxFdmVudCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuc3VwcG9ydHNUb3VjaEV2ZW50cyAmJiBvcmlnaW5hbEV2ZW50LnBvaW50ZXJUeXBlID09PSAndG91Y2gnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGV2ZW50cyA9IHRoaXMubm9ybWFsaXplVG9Qb2ludGVyRGF0YShvcmlnaW5hbEV2ZW50KTtcbiAgICAgICAgICAgIGxldCBldmVudCA9IGV2ZW50c1swXTtcbiAgICAgICAgICAgIGlmIChldmVudC5wb2ludGVyVHlwZSA9PT0gJ21vdXNlJykge1xuICAgICAgICAgICAgICAgIHRoaXMubW91c2VPdmVyUmVuZGVyZXIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLnNldEN1cnNvck1vZGUobnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgaW50ZXJhY3Rpb25EYXRhID0gdGhpcy5nZXRJbnRlcmFjdGlvbkRhdGFGb3JQb2ludGVySWQoZXZlbnQpO1xuICAgICAgICAgICAgbGV0IGludGVyYWN0aW9uRXZlbnQgPSB0aGlzLmNvbmZpZ3VyZUludGVyYWN0aW9uRXZlbnRGb3JET01FdmVudCh0aGlzLmV2ZW50RGF0YSwgZXZlbnQsIGludGVyYWN0aW9uRGF0YSk7XG4gICAgICAgICAgICBpbnRlcmFjdGlvbkV2ZW50LmRhdGEub3JpZ2luYWxFdmVudCA9IGV2ZW50O1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzSW50ZXJhY3RpdmUoaW50ZXJhY3Rpb25FdmVudCwgdGhpcy5yZW5kZXJlci5fbGFzdE9iamVjdFJlbmRlcmVkLCB0aGlzLnByb2Nlc3NQb2ludGVyT3Zlck91dCwgZmFsc2UpO1xuICAgICAgICAgICAgbGV0IHBvaW50ZXIgPSBuZXcgTW91c2VFdmVudF8xLk1vdXNlRXZlbnQoTW91c2VFdmVudF8xLk1vdXNlRXZlbnQuUE9JTlRFUl9PVVQpO1xuICAgICAgICAgICAgcG9pbnRlci5kYXRhID0gaW50ZXJhY3Rpb25EYXRhO1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KHBvaW50ZXIpO1xuICAgICAgICAgICAgaWYgKGV2ZW50LnBvaW50ZXJUeXBlID09PSAnbW91c2UnIHx8IGV2ZW50LnBvaW50ZXJUeXBlID09PSAncGVuJykge1xuICAgICAgICAgICAgICAgIGxldCBwb2ludGVyID0gbmV3IE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50KE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50Lk1PVVNFX09VVCk7XG4gICAgICAgICAgICAgICAgcG9pbnRlci5kYXRhID0gaW50ZXJhY3Rpb25EYXRhO1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChwb2ludGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMucmVsZWFzZUludGVyYWN0aW9uRGF0YUZvclBvaW50ZXJJZChpbnRlcmFjdGlvbkRhdGEuaWRlbnRpZmllcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMub25Qb2ludGVyRG93biA9IChvcmlnaW5hbEV2ZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5zdXBwb3J0c1RvdWNoRXZlbnRzICYmIG9yaWdpbmFsRXZlbnQucG9pbnRlclR5cGUgPT09ICd0b3VjaCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZXZlbnRzID0gdGhpcy5ub3JtYWxpemVUb1BvaW50ZXJEYXRhKG9yaWdpbmFsRXZlbnQpO1xuICAgICAgICAgICAgbGV0IGV2ZW50ID0gZXZlbnRzWzBdO1xuICAgICAgICAgICAgaWYgKHRoaXMuYXV0b1ByZXZlbnREZWZhdWx0ICYmIGV2ZW50LmlzTm9ybWFsaXplZCkge1xuICAgICAgICAgICAgICAgIGxldCBjYW5jZWxhYmxlID0gb3JpZ2luYWxFdmVudC5jYW5jZWxhYmxlIHx8ICEoJ2NhbmNlbGFibGUnIGluIG9yaWdpbmFsRXZlbnQpO1xuICAgICAgICAgICAgICAgIGlmIChjYW5jZWxhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZXZlbnRMZW4gPSBldmVudHMubGVuZ3RoO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBldmVudExlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGV2ZW50ID0gZXZlbnRzW2ldO1xuICAgICAgICAgICAgICAgIGxldCBpbnRlcmFjdGlvbkRhdGEgPSB0aGlzLmdldEludGVyYWN0aW9uRGF0YUZvclBvaW50ZXJJZChldmVudCk7XG4gICAgICAgICAgICAgICAgbGV0IGludGVyYWN0aW9uRXZlbnQgPSB0aGlzLmNvbmZpZ3VyZUludGVyYWN0aW9uRXZlbnRGb3JET01FdmVudCh0aGlzLmV2ZW50RGF0YSwgZXZlbnQsIGludGVyYWN0aW9uRGF0YSk7XG4gICAgICAgICAgICAgICAgaW50ZXJhY3Rpb25FdmVudC5kYXRhLm9yaWdpbmFsRXZlbnQgPSBvcmlnaW5hbEV2ZW50O1xuICAgICAgICAgICAgICAgIGxldCByZXN1bHQgPSB0aGlzLnByb2Nlc3NJbnRlcmFjdGl2ZShpbnRlcmFjdGlvbkV2ZW50LCB0aGlzLnJlbmRlcmVyLl9sYXN0T2JqZWN0UmVuZGVyZWQsIHRoaXMucHJvY2Vzc1BvaW50ZXJEb3duLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBsZXQgcG9pbnRlciA9IG5ldyBNb3VzZUV2ZW50XzEuTW91c2VFdmVudChNb3VzZUV2ZW50XzEuTW91c2VFdmVudC5QT0lOVEVSX0RPV04pO1xuICAgICAgICAgICAgICAgIHBvaW50ZXIuZGF0YSA9IGludGVyYWN0aW9uRGF0YTtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQocG9pbnRlcik7XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50LnBvaW50ZXJUeXBlID09PSAndG91Y2gnKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBwb2ludGVyID0gbmV3IE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50KE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50LlRPVUNIX1NUQVJUKTtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRlci5kYXRhID0gaW50ZXJhY3Rpb25EYXRhO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQocG9pbnRlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGV2ZW50LnBvaW50ZXJUeXBlID09PSAnbW91c2UnIHx8IGV2ZW50LnBvaW50ZXJUeXBlID09PSAncGVuJykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgaXNSaWdodEJ1dHRvbiA9IGV2ZW50LmJ1dHRvbiA9PT0gMjtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBvaW50ZXIgPSBuZXcgTW91c2VFdmVudF8xLk1vdXNlRXZlbnQoaXNSaWdodEJ1dHRvbiA/IE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50LlJJR0hUX01PVVNFX0RPV04gOiBNb3VzZUV2ZW50XzEuTW91c2VFdmVudC5NT1VTRV9ET1dOKTtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRlci5kYXRhID0gaW50ZXJhY3Rpb25EYXRhO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQocG9pbnRlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLm9uUG9pbnRlck1vdmUgPSAob3JpZ2luYWxFdmVudCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuc3VwcG9ydHNUb3VjaEV2ZW50cyAmJiBvcmlnaW5hbEV2ZW50LnBvaW50ZXJUeXBlID09PSAndG91Y2gnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGV2ZW50cyA9IHRoaXMubm9ybWFsaXplVG9Qb2ludGVyRGF0YShvcmlnaW5hbEV2ZW50KTtcbiAgICAgICAgICAgIGlmIChldmVudHNbMF0ucG9pbnRlclR5cGUgPT09ICdtb3VzZScgfHwgZXZlbnRzWzBdLnBvaW50ZXJUeXBlID09PSAncGVuJykge1xuICAgICAgICAgICAgICAgIHRoaXMuZGlkTW92ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJzb3IgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGV2ZW50TGVuID0gZXZlbnRzLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXZlbnRMZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBldmVudCA9IGV2ZW50c1tpXTtcbiAgICAgICAgICAgICAgICBsZXQgaW50ZXJhY3Rpb25EYXRhID0gdGhpcy5nZXRJbnRlcmFjdGlvbkRhdGFGb3JQb2ludGVySWQoZXZlbnQpO1xuICAgICAgICAgICAgICAgIGxldCBpbnRlcmFjdGlvbkV2ZW50ID0gdGhpcy5jb25maWd1cmVJbnRlcmFjdGlvbkV2ZW50Rm9yRE9NRXZlbnQodGhpcy5ldmVudERhdGEsIGV2ZW50LCBpbnRlcmFjdGlvbkRhdGEpO1xuICAgICAgICAgICAgICAgIGludGVyYWN0aW9uRXZlbnQuZGF0YS5vcmlnaW5hbEV2ZW50ID0gb3JpZ2luYWxFdmVudDtcbiAgICAgICAgICAgICAgICBsZXQgaW50ZXJhY3RpdmUgPSBldmVudC5wb2ludGVyVHlwZSA9PT0gJ3RvdWNoJyA/IHRoaXMubW92ZVdoZW5JbnNpZGUgOiB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMucHJvY2Vzc0ludGVyYWN0aXZlKGludGVyYWN0aW9uRXZlbnQsIHRoaXMucmVuZGVyZXIuX2xhc3RPYmplY3RSZW5kZXJlZCwgdGhpcy5wcm9jZXNzUG9pbnRlck1vdmUsIGludGVyYWN0aXZlKTtcbiAgICAgICAgICAgICAgICBsZXQgcG9pbnRlciA9IG5ldyBNb3VzZUV2ZW50XzEuTW91c2VFdmVudChNb3VzZUV2ZW50XzEuTW91c2VFdmVudC5QT0lOVEVSX01PVkUpO1xuICAgICAgICAgICAgICAgIHBvaW50ZXIuZGF0YSA9IGludGVyYWN0aW9uRGF0YTtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQocG9pbnRlcik7XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50LnBvaW50ZXJUeXBlID09PSAndG91Y2gnKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBwb2ludGVyID0gbmV3IE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50KE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50LlRPVUNIX01PVkUpO1xuICAgICAgICAgICAgICAgICAgICBwb2ludGVyLmRhdGEgPSBpbnRlcmFjdGlvbkRhdGE7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChwb2ludGVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50LnBvaW50ZXJUeXBlID09PSAnbW91c2UnIHx8IGV2ZW50LnBvaW50ZXJUeXBlID09PSAncGVuJykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcG9pbnRlciA9IG5ldyBNb3VzZUV2ZW50XzEuTW91c2VFdmVudChNb3VzZUV2ZW50XzEuTW91c2VFdmVudC5NT1VTRV9NT1ZFKTtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRlci5kYXRhID0gaW50ZXJhY3Rpb25EYXRhO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQocG9pbnRlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGV2ZW50c1swXS5wb2ludGVyVHlwZSA9PT0gJ21vdXNlJykge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0Q3Vyc29yTW9kZSh0aGlzLmN1cnNvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucHJvY2Vzc1BvaW50ZXJEb3duID0gKGludGVyYWN0aW9uRXZlbnQsIGRpc3BsYXlPYmplY3QsIGhpdCkgPT4ge1xuICAgICAgICAgICAgbGV0IGRhdGEgPSBpbnRlcmFjdGlvbkV2ZW50LmRhdGE7XG4gICAgICAgICAgICBsZXQgaWQgPSBpbnRlcmFjdGlvbkV2ZW50LmRhdGEuaWRlbnRpZmllcjtcbiAgICAgICAgICAgIGlmIChoaXQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWRpc3BsYXlPYmplY3QudHJhY2tlZFBvaW50ZXJzW2lkXSkge1xuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5T2JqZWN0LnRyYWNrZWRQb2ludGVyc1tpZF0gPSBuZXcgSW50ZXJhY3Rpb25UcmFja2luZ0RhdGFfMS5JbnRlcmFjdGlvblRyYWNraW5nRGF0YShpZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBwb2ludGVyID0gbmV3IE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50KE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50LlBPSU5URVJfRE9XTik7XG4gICAgICAgICAgICAgICAgcG9pbnRlci5kYXRhID0gZGF0YTtcbiAgICAgICAgICAgICAgICBkaXNwbGF5T2JqZWN0LmRpc3BhdGNoRXZlbnQocG9pbnRlcik7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGEucG9pbnRlclR5cGUgPT09ICd0b3VjaCcpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBvaW50ZXIgPSBuZXcgTW91c2VFdmVudF8xLk1vdXNlRXZlbnQoTW91c2VFdmVudF8xLk1vdXNlRXZlbnQuVE9VQ0hfU1RBUlQpO1xuICAgICAgICAgICAgICAgICAgICBwb2ludGVyLmRhdGEgPSBkYXRhO1xuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5T2JqZWN0LmRpc3BhdGNoRXZlbnQocG9pbnRlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGRhdGEucG9pbnRlclR5cGUgPT09ICdtb3VzZScgfHwgZGF0YS5wb2ludGVyVHlwZSA9PT0gJ3BlbicpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGlzUmlnaHRCdXR0b24gPSBkYXRhLmJ1dHRvbiA9PT0gMjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzUmlnaHRCdXR0b24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXlPYmplY3QudHJhY2tlZFBvaW50ZXJzW2lkXS5yaWdodERvd24gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheU9iamVjdC50cmFja2VkUG9pbnRlcnNbaWRdLmxlZnREb3duID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsZXQgcG9pbnRlciA9IG5ldyBNb3VzZUV2ZW50XzEuTW91c2VFdmVudChpc1JpZ2h0QnV0dG9uID8gTW91c2VFdmVudF8xLk1vdXNlRXZlbnQuUklHSFRfTU9VU0VfRE9XTiA6IE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50Lk1PVVNFX0RPV04pO1xuICAgICAgICAgICAgICAgICAgICBwb2ludGVyLmRhdGEgPSBkYXRhO1xuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5T2JqZWN0LmRpc3BhdGNoRXZlbnQocG9pbnRlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnByb2Nlc3NQb2ludGVyVXAgPSAoaW50ZXJhY3Rpb25FdmVudCwgZGlzcGxheU9iamVjdCwgaGl0KSA9PiB7XG4gICAgICAgICAgICBsZXQgZGF0YSA9IGludGVyYWN0aW9uRXZlbnQuZGF0YTtcbiAgICAgICAgICAgIGxldCBpZCA9IGludGVyYWN0aW9uRXZlbnQuZGF0YS5pZGVudGlmaWVyO1xuICAgICAgICAgICAgbGV0IHRyYWNraW5nRGF0YSA9IGRpc3BsYXlPYmplY3QudHJhY2tlZFBvaW50ZXJzW2lkXTtcbiAgICAgICAgICAgIGxldCBpc1RvdWNoID0gZGF0YS5wb2ludGVyVHlwZSA9PT0gJ3RvdWNoJztcbiAgICAgICAgICAgIGxldCBpc01vdXNlID0gKGRhdGEucG9pbnRlclR5cGUgPT09ICdtb3VzZScgfHwgZGF0YS5wb2ludGVyVHlwZSA9PT0gJ3BlbicpO1xuICAgICAgICAgICAgbGV0IGlzTW91c2VUYXAgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChpc01vdXNlKSB7XG4gICAgICAgICAgICAgICAgbGV0IGlzUmlnaHRCdXR0b24gPSBkYXRhLmJ1dHRvbiA9PT0gMjtcbiAgICAgICAgICAgICAgICBsZXQgZmxhZ3MgPSBJbnRlcmFjdGlvblRyYWNraW5nRGF0YV8xLkludGVyYWN0aW9uVHJhY2tpbmdEYXRhLkZMQUdTO1xuICAgICAgICAgICAgICAgIGxldCB0ZXN0ID0gaXNSaWdodEJ1dHRvbiA/IGZsYWdzLlJJR0hUX0RPV04gOiBmbGFncy5MRUZUX0RPV047XG4gICAgICAgICAgICAgICAgbGV0IGlzRG93biA9IHRyYWNraW5nRGF0YSAhPT0gdW5kZWZpbmVkICYmICh0cmFja2luZ0RhdGEuZmxhZ3MgJiB0ZXN0KTtcbiAgICAgICAgICAgICAgICBpZiAoaGl0KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBwb2ludGVyID0gbmV3IE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50KGlzUmlnaHRCdXR0b24gPyBNb3VzZUV2ZW50XzEuTW91c2VFdmVudC5SSUdIVF9NT1VTRV9VUCA6IE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50Lk1PVVNFX1VQKTtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRlci5kYXRhID0gZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheU9iamVjdC5kaXNwYXRjaEV2ZW50KHBvaW50ZXIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNEb3duKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgcG9pbnRlciA9IG5ldyBNb3VzZUV2ZW50XzEuTW91c2VFdmVudChpc1JpZ2h0QnV0dG9uID8gTW91c2VFdmVudF8xLk1vdXNlRXZlbnQuUklHSFRfQ0xJQ0sgOiBNb3VzZUV2ZW50XzEuTW91c2VFdmVudC5DTElDSyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludGVyLmRhdGEgPSBkYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheU9iamVjdC5kaXNwYXRjaEV2ZW50KHBvaW50ZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNNb3VzZVRhcCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNEb3duKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBwb2ludGVyID0gbmV3IE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50KGlzUmlnaHRCdXR0b24gPyBNb3VzZUV2ZW50XzEuTW91c2VFdmVudC5SSUdIVF9NT1VTRV9VUF9PVVRTSURFIDogTW91c2VFdmVudF8xLk1vdXNlRXZlbnQuTU9VU0VfVVBfT1VUU0lERSk7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50ZXIuZGF0YSA9IGRhdGE7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXlPYmplY3QuZGlzcGF0Y2hFdmVudChwb2ludGVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRyYWNraW5nRGF0YSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNSaWdodEJ1dHRvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJhY2tpbmdEYXRhLnJpZ2h0RG93biA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJhY2tpbmdEYXRhLmxlZnREb3duID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaGl0KSB7XG4gICAgICAgICAgICAgICAgbGV0IHBvaW50ZXIgPSBuZXcgTW91c2VFdmVudF8xLk1vdXNlRXZlbnQoTW91c2VFdmVudF8xLk1vdXNlRXZlbnQuUE9JTlRFUl9VUCk7XG4gICAgICAgICAgICAgICAgcG9pbnRlci5kYXRhID0gZGF0YTtcbiAgICAgICAgICAgICAgICBkaXNwbGF5T2JqZWN0LmRpc3BhdGNoRXZlbnQocG9pbnRlcik7XG4gICAgICAgICAgICAgICAgaWYgKGlzVG91Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBvaW50ZXIgPSBuZXcgTW91c2VFdmVudF8xLk1vdXNlRXZlbnQoTW91c2VFdmVudF8xLk1vdXNlRXZlbnQuVE9VQ0hfRU5EKTtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRlci5kYXRhID0gZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheU9iamVjdC5kaXNwYXRjaEV2ZW50KHBvaW50ZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHJhY2tpbmdEYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNNb3VzZSB8fCBpc01vdXNlVGFwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgcG9pbnRlciA9IG5ldyBNb3VzZUV2ZW50XzEuTW91c2VFdmVudChNb3VzZUV2ZW50XzEuTW91c2VFdmVudC5QT0lOVEVSX1RBUCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludGVyLmRhdGEgPSBkYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheU9iamVjdC5kaXNwYXRjaEV2ZW50KHBvaW50ZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1RvdWNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgcG9pbnRlciA9IG5ldyBNb3VzZUV2ZW50XzEuTW91c2VFdmVudChNb3VzZUV2ZW50XzEuTW91c2VFdmVudC5UT1VDSF9UQVApO1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRlci5kYXRhID0gZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXlPYmplY3QuZGlzcGF0Y2hFdmVudChwb2ludGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYWNraW5nRGF0YS5vdmVyID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0cmFja2luZ0RhdGEpIHtcbiAgICAgICAgICAgICAgICBsZXQgcG9pbnRlciA9IG5ldyBNb3VzZUV2ZW50XzEuTW91c2VFdmVudChNb3VzZUV2ZW50XzEuTW91c2VFdmVudC5QT0lOVEVSX1VQX09VVFNJREUpO1xuICAgICAgICAgICAgICAgIHBvaW50ZXIuZGF0YSA9IGRhdGE7XG4gICAgICAgICAgICAgICAgZGlzcGxheU9iamVjdC5kaXNwYXRjaEV2ZW50KHBvaW50ZXIpO1xuICAgICAgICAgICAgICAgIGlmIChpc1RvdWNoKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBwb2ludGVyID0gbmV3IE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50KE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50LlRPVUNIX0VORF9PVVRTSURFKTtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRlci5kYXRhID0gZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheU9iamVjdC5kaXNwYXRjaEV2ZW50KHBvaW50ZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0cmFja2luZ0RhdGEgJiYgdHJhY2tpbmdEYXRhLm5vbmUpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgZGlzcGxheU9iamVjdC50cmFja2VkUG9pbnRlcnNbaWRdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnByb2Nlc3NQb2ludGVyTW92ZSA9IChpbnRlcmFjdGlvbkV2ZW50LCBkaXNwbGF5T2JqZWN0LCBoaXQpID0+IHtcbiAgICAgICAgICAgIGxldCBkYXRhID0gaW50ZXJhY3Rpb25FdmVudC5kYXRhO1xuICAgICAgICAgICAgbGV0IGlzVG91Y2ggPSBkYXRhLnBvaW50ZXJUeXBlID09PSAndG91Y2gnO1xuICAgICAgICAgICAgbGV0IGlzTW91c2UgPSAoZGF0YS5wb2ludGVyVHlwZSA9PT0gJ21vdXNlJyB8fCBkYXRhLnBvaW50ZXJUeXBlID09PSAncGVuJyk7XG4gICAgICAgICAgICBpZiAoaXNNb3VzZSkge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvY2Vzc1BvaW50ZXJPdmVyT3V0KGludGVyYWN0aW9uRXZlbnQsIGRpc3BsYXlPYmplY3QsIGhpdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMubW92ZVdoZW5JbnNpZGUgfHwgaGl0KSB7XG4gICAgICAgICAgICAgICAgbGV0IHBvaW50ZXIgPSBuZXcgTW91c2VFdmVudF8xLk1vdXNlRXZlbnQoTW91c2VFdmVudF8xLk1vdXNlRXZlbnQuUE9JTlRFUl9NT1ZFKTtcbiAgICAgICAgICAgICAgICBwb2ludGVyLmRhdGEgPSBkYXRhO1xuICAgICAgICAgICAgICAgIGRpc3BsYXlPYmplY3QuZGlzcGF0Y2hFdmVudChwb2ludGVyKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNUb3VjaCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcG9pbnRlciA9IG5ldyBNb3VzZUV2ZW50XzEuTW91c2VFdmVudChNb3VzZUV2ZW50XzEuTW91c2VFdmVudC5UT1VDSF9NT1ZFKTtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRlci5kYXRhID0gZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheU9iamVjdC5kaXNwYXRjaEV2ZW50KHBvaW50ZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaXNNb3VzZSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcG9pbnRlciA9IG5ldyBNb3VzZUV2ZW50XzEuTW91c2VFdmVudChNb3VzZUV2ZW50XzEuTW91c2VFdmVudC5NT1VTRV9NT1ZFKTtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRlci5kYXRhID0gZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheU9iamVjdC5kaXNwYXRjaEV2ZW50KHBvaW50ZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5wcm9jZXNzUG9pbnRlck92ZXJPdXQgPSAoaW50ZXJhY3Rpb25FdmVudCwgZGlzcGxheU9iamVjdCwgaGl0KSA9PiB7XG4gICAgICAgICAgICBsZXQgZGF0YSA9IGludGVyYWN0aW9uRXZlbnQuZGF0YTtcbiAgICAgICAgICAgIGxldCBpZCA9IGludGVyYWN0aW9uRXZlbnQuZGF0YS5pZGVudGlmaWVyO1xuICAgICAgICAgICAgbGV0IGlzTW91c2UgPSAoZGF0YS5wb2ludGVyVHlwZSA9PT0gJ21vdXNlJyB8fCBkYXRhLnBvaW50ZXJUeXBlID09PSAncGVuJyk7XG4gICAgICAgICAgICBsZXQgdHJhY2tpbmdEYXRhID0gZGlzcGxheU9iamVjdC50cmFja2VkUG9pbnRlcnNbaWRdO1xuICAgICAgICAgICAgaWYgKGhpdCAmJiAhdHJhY2tpbmdEYXRhKSB7XG4gICAgICAgICAgICAgICAgdHJhY2tpbmdEYXRhID0gZGlzcGxheU9iamVjdC50cmFja2VkUG9pbnRlcnNbaWRdID0gbmV3IEludGVyYWN0aW9uVHJhY2tpbmdEYXRhXzEuSW50ZXJhY3Rpb25UcmFja2luZ0RhdGEoaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRyYWNraW5nRGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGhpdCAmJiB0aGlzLm1vdXNlT3ZlclJlbmRlcmVyKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0cmFja2luZ0RhdGEub3Zlcikge1xuICAgICAgICAgICAgICAgICAgICB0cmFja2luZ0RhdGEub3ZlciA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGxldCBwb2ludGVyID0gbmV3IE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50KE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50LlBPSU5URVJfT1ZFUik7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50ZXIuZGF0YSA9IGRhdGE7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXlPYmplY3QuZGlzcGF0Y2hFdmVudChwb2ludGVyKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTW91c2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBwb2ludGVyID0gbmV3IE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50KE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50Lk1PVVNFX09WRVIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRlci5kYXRhID0gZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXlPYmplY3QuZGlzcGF0Y2hFdmVudChwb2ludGVyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaXNNb3VzZSAmJiB0aGlzLmN1cnNvciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnNvciA9IGRpc3BsYXlPYmplY3QuY3Vyc29yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRyYWNraW5nRGF0YS5vdmVyKSB7XG4gICAgICAgICAgICAgICAgdHJhY2tpbmdEYXRhLm92ZXIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBsZXQgcG9pbnRlciA9IG5ldyBNb3VzZUV2ZW50XzEuTW91c2VFdmVudChNb3VzZUV2ZW50XzEuTW91c2VFdmVudC5QT0lOVEVSX09VVCk7XG4gICAgICAgICAgICAgICAgcG9pbnRlci5kYXRhID0gZGF0YTtcbiAgICAgICAgICAgICAgICBkaXNwbGF5T2JqZWN0LmRpc3BhdGNoRXZlbnQocG9pbnRlcik7XG4gICAgICAgICAgICAgICAgaWYgKGlzTW91c2UpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBvaW50ZXIgPSBuZXcgTW91c2VFdmVudF8xLk1vdXNlRXZlbnQoTW91c2VFdmVudF8xLk1vdXNlRXZlbnQuTU9VU0VfT1VUKTtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRlci5kYXRhID0gZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheU9iamVjdC5kaXNwYXRjaEV2ZW50KHBvaW50ZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHJhY2tpbmdEYXRhLm5vbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGRpc3BsYXlPYmplY3QudHJhY2tlZFBvaW50ZXJzW2lkXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGl0VGVzdEV2ZW50ID0gbmV3IEludGVyYWN0aW9uRXZlbnRfMS5JbnRlcmFjdGlvbkV2ZW50KG51bGwsIG51bGwsIG51bGwpO1xuICAgICAgICB0aGlzLmhpdFRlc3RFdmVudC50YXJnZXQgPSBudWxsO1xuICAgICAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgICAgIHRoaXMuYXV0b1ByZXZlbnREZWZhdWx0ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5pbnRlcmFjdGlvbkZyZXF1ZW5jeSA9IDEwO1xuICAgICAgICB0aGlzLm1vdXNlID0gbmV3IEludGVyYWN0aW9uRGF0YV8xLkludGVyYWN0aW9uRGF0YSgpO1xuICAgICAgICB0aGlzLm1vdXNlLmlkZW50aWZpZXIgPSBJbnRlcmFjdGlvbk1hbmFnZXIuTU9VU0VfUE9JTlRFUl9JRDtcbiAgICAgICAgdGhpcy5tb3VzZS5nbG9iYWwuc2V0KC05OTk5OTkpO1xuICAgICAgICB0aGlzLmFjdGl2ZUludGVyYWN0aW9uRGF0YSA9IHt9O1xuICAgICAgICB0aGlzLmFjdGl2ZUludGVyYWN0aW9uRGF0YVtJbnRlcmFjdGlvbk1hbmFnZXIuTU9VU0VfUE9JTlRFUl9JRF0gPSB0aGlzLm1vdXNlO1xuICAgICAgICB0aGlzLmludGVyYWN0aW9uRGF0YVBvb2wgPSBbXTtcbiAgICAgICAgdGhpcy5ldmVudERhdGEgPSBuZXcgSW50ZXJhY3Rpb25FdmVudF8xLkludGVyYWN0aW9uRXZlbnQoXCJpbnRlcmFjdGlvblwiKTtcbiAgICAgICAgdGhpcy5pbnRlcmFjdGlvbkRPTUVsZW1lbnQgPSBudWxsO1xuICAgICAgICB0aGlzLm1vdmVXaGVuSW5zaWRlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZXZlbnRzQWRkZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5tb3VzZU92ZXJSZW5kZXJlciA9IGZhbHNlO1xuICAgICAgICB0aGlzLnN1cHBvcnRzVG91Y2hFdmVudHMgPSAnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3c7XG4gICAgICAgIHRoaXMuc3VwcG9ydHNQb2ludGVyRXZlbnRzID0gISF3aW5kb3dbJ1BvaW50ZXJFdmVudCddO1xuICAgICAgICB0aGlzLmN1cnNvclN0eWxlcyA9IHtcbiAgICAgICAgICAgIGRlZmF1bHQ6ICdpbmhlcml0JyxcbiAgICAgICAgICAgIHBvaW50ZXI6ICdwb2ludGVyJ1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmN1cnJlbnRDdXJzb3JNb2RlID0gbnVsbDtcbiAgICAgICAgdGhpcy5jdXJzb3IgPSBudWxsO1xuICAgICAgICB0aGlzLl90ZW1wUG9pbnQgPSBQb2ludF8xLlBvaW50LmdldFBvaW50KCk7XG4gICAgICAgIHRoaXMucmVzb2x1dGlvbiA9IDE7XG4gICAgICAgIHRoaXMuc2V0VGFyZ2V0RWxlbWVudCh0aGlzLnJlbmRlcmVyLnZpZXcsIHRoaXMucmVuZGVyZXIucmVzb2x1dGlvbik7XG4gICAgfVxuICAgIGRlc3RydWN0b3IoKSB7XG4gICAgICAgIGlmICh0aGlzLl90ZW1wUG9pbnQpIHtcbiAgICAgICAgICAgIHRoaXMuX3RlbXBQb2ludC5kZXN0cnVjdG9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdGVtcFBvaW50ID0gbnVsbDtcbiAgICB9XG4gICAgc2V0VGFyZ2V0RWxlbWVudChlbGVtZW50LCByZXNvbHV0aW9uID0gMSkge1xuICAgICAgICB0aGlzLnJlbW92ZUV2ZW50cygpO1xuICAgICAgICB0aGlzLmludGVyYWN0aW9uRE9NRWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAgIHRoaXMucmVzb2x1dGlvbiA9IHJlc29sdXRpb247XG4gICAgICAgIHRoaXMuYWRkRXZlbnRzKCk7XG4gICAgfVxuICAgIDtcbiAgICByZW1vdmVFdmVudHMoKSB7XG4gICAgICAgIGlmICghdGhpcy5pbnRlcmFjdGlvbkRPTUVsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBUaWNrZXJfMS5UaWNrZXIuc3lzdGVtLnJlbW92ZSh0aGlzLnVwZGF0ZSk7XG4gICAgICAgIGlmICh3aW5kb3cubmF2aWdhdG9yLm1zUG9pbnRlckVuYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuaW50ZXJhY3Rpb25ET01FbGVtZW50LnN0eWxlWyctbXMtY29udGVudC16b29taW5nJ10gPSAnJztcbiAgICAgICAgICAgIHRoaXMuaW50ZXJhY3Rpb25ET01FbGVtZW50LnN0eWxlWyctbXMtdG91Y2gtYWN0aW9uJ10gPSAnJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnN1cHBvcnRzUG9pbnRlckV2ZW50cykge1xuICAgICAgICAgICAgdGhpcy5pbnRlcmFjdGlvbkRPTUVsZW1lbnQuc3R5bGVbJ3RvdWNoLWFjdGlvbiddID0gJyc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc3VwcG9ydHNQb2ludGVyRXZlbnRzKSB7XG4gICAgICAgICAgICB3aW5kb3cuZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigncG9pbnRlcm1vdmUnLCB0aGlzLm9uUG9pbnRlck1vdmUpO1xuICAgICAgICAgICAgdGhpcy5pbnRlcmFjdGlvbkRPTUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigncG9pbnRlcmRvd24nLCB0aGlzLm9uUG9pbnRlckRvd24pO1xuICAgICAgICAgICAgdGhpcy5pbnRlcmFjdGlvbkRPTUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigncG9pbnRlcmxlYXZlJywgdGhpcy5vblBvaW50ZXJPdXQpO1xuICAgICAgICAgICAgdGhpcy5pbnRlcmFjdGlvbkRPTUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigncG9pbnRlcm92ZXInLCB0aGlzLm9uUG9pbnRlck92ZXIpO1xuICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJjYW5jZWwnLCB0aGlzLm9uUG9pbnRlckNhbmNlbCk7XG4gICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncG9pbnRlcnVwJywgdGhpcy5vblBvaW50ZXJVcCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB3aW5kb3cuZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5vblBvaW50ZXJNb3ZlKTtcbiAgICAgICAgICAgIHRoaXMuaW50ZXJhY3Rpb25ET01FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMub25Qb2ludGVyRG93bik7XG4gICAgICAgICAgICB0aGlzLmludGVyYWN0aW9uRE9NRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW91dCcsIHRoaXMub25Qb2ludGVyT3V0KTtcbiAgICAgICAgICAgIHRoaXMuaW50ZXJhY3Rpb25ET01FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlb3ZlcicsIHRoaXMub25Qb2ludGVyT3Zlcik7XG4gICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMub25Qb2ludGVyVXApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnN1cHBvcnRzVG91Y2hFdmVudHMpIHtcbiAgICAgICAgICAgIHRoaXMuaW50ZXJhY3Rpb25ET01FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCB0aGlzLm9uUG9pbnRlckRvd24pO1xuICAgICAgICAgICAgdGhpcy5pbnRlcmFjdGlvbkRPTUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hjYW5jZWwnLCB0aGlzLm9uUG9pbnRlckNhbmNlbCk7XG4gICAgICAgICAgICB0aGlzLmludGVyYWN0aW9uRE9NRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMub25Qb2ludGVyVXApO1xuICAgICAgICAgICAgdGhpcy5pbnRlcmFjdGlvbkRPTUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5vblBvaW50ZXJNb3ZlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmludGVyYWN0aW9uRE9NRWxlbWVudCA9IG51bGw7XG4gICAgICAgIHRoaXMuZXZlbnRzQWRkZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgO1xuICAgIG1hcFBvc2l0aW9uVG9Qb2ludChwb2ludCwgeCwgeSkge1xuICAgICAgICBsZXQgcmVjdDtcbiAgICAgICAgaWYgKCF0aGlzLmludGVyYWN0aW9uRE9NRWxlbWVudC5wYXJlbnRFbGVtZW50KSB7XG4gICAgICAgICAgICBJbnN0YW5jZUNvdW50ZXJfMS5JbnN0YW5jZUNvdW50ZXIuYWRkQ2FsbChcIlJlY3RhbmdsZS5nZXRSZWN0YW5nbGVcIiwgXCJJbnRlcmFjdGlvbm1hbmFnZXIgbWFwUG9zaXRpb25Ub1BvaW50XCIpO1xuICAgICAgICAgICAgcmVjdCA9IFJlY3RhbmdsZV8xLlJlY3RhbmdsZS5nZXRSZWN0YW5nbGUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlY3QgPSB0aGlzLmludGVyYWN0aW9uRE9NRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzb2x1dGlvbk11bHRpcGxpZXIgPSAxLjAgLyB0aGlzLnJlc29sdXRpb247XG4gICAgICAgIHBvaW50LnggPSAoKHggLSByZWN0LmxlZnQpICogKHRoaXMuaW50ZXJhY3Rpb25ET01FbGVtZW50LndpZHRoIC8gcmVjdC53aWR0aCkpICogcmVzb2x1dGlvbk11bHRpcGxpZXI7XG4gICAgICAgIHBvaW50LnkgPSAoKHkgLSByZWN0LnRvcCkgKiAodGhpcy5pbnRlcmFjdGlvbkRPTUVsZW1lbnQuaGVpZ2h0IC8gcmVjdC5oZWlnaHQpKSAqIHJlc29sdXRpb25NdWx0aXBsaWVyO1xuICAgICAgICBpZiAocmVjdCBpbnN0YW5jZW9mIFJlY3RhbmdsZV8xLlJlY3RhbmdsZSkge1xuICAgICAgICAgICAgcmVjdC5yZWN5Y2xlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xuICAgIGNvbmZpZ3VyZUludGVyYWN0aW9uRXZlbnRGb3JET01FdmVudChpbnRlcmFjdGlvbkV2ZW50LCBwb2ludGVyRXZlbnQsIGludGVyYWN0aW9uRGF0YSkge1xuICAgICAgICBpbnRlcmFjdGlvbkV2ZW50LmRhdGEgPSBpbnRlcmFjdGlvbkRhdGE7XG4gICAgICAgIHRoaXMubWFwUG9zaXRpb25Ub1BvaW50KGludGVyYWN0aW9uRGF0YS5nbG9iYWwsIHBvaW50ZXJFdmVudC5jbGllbnRYLCBwb2ludGVyRXZlbnQuY2xpZW50WSk7XG4gICAgICAgIGlmIChwb2ludGVyRXZlbnQucG9pbnRlclR5cGUgPT09ICd0b3VjaCcpIHtcbiAgICAgICAgICAgIHBvaW50ZXJFdmVudC5nbG9iYWxYID0gaW50ZXJhY3Rpb25EYXRhLmdsb2JhbC54O1xuICAgICAgICAgICAgcG9pbnRlckV2ZW50Lmdsb2JhbFkgPSBpbnRlcmFjdGlvbkRhdGEuZ2xvYmFsLnk7XG4gICAgICAgIH1cbiAgICAgICAgaW50ZXJhY3Rpb25EYXRhLm9yaWdpbmFsRXZlbnQgPSBwb2ludGVyRXZlbnQ7XG4gICAgICAgIGludGVyYWN0aW9uRXZlbnQucmVzZXQoKTtcbiAgICAgICAgcmV0dXJuIGludGVyYWN0aW9uRXZlbnQ7XG4gICAgfVxuICAgIDtcbiAgICBhZGRFdmVudHMoKSB7XG4gICAgICAgIGlmICghdGhpcy5pbnRlcmFjdGlvbkRPTUVsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBUaWNrZXJfMS5UaWNrZXIuc3lzdGVtLmFkZCh0aGlzLnVwZGF0ZSwgdGhpcywgVGlja2VyXzEuVGlja2VyLlVQREFURV9QUklPUklUWS5JTlRFUkFDVElPTik7XG4gICAgICAgIGlmICh3aW5kb3cubmF2aWdhdG9yLm1zUG9pbnRlckVuYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuaW50ZXJhY3Rpb25ET01FbGVtZW50LnN0eWxlWyctbXMtY29udGVudC16b29taW5nJ10gPSAnbm9uZSc7XG4gICAgICAgICAgICB0aGlzLmludGVyYWN0aW9uRE9NRWxlbWVudC5zdHlsZVsnLW1zLXRvdWNoLWFjdGlvbiddID0gJ25vbmUnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuc3VwcG9ydHNQb2ludGVyRXZlbnRzKSB7XG4gICAgICAgICAgICB0aGlzLmludGVyYWN0aW9uRE9NRWxlbWVudC5zdHlsZVsndG91Y2gtYWN0aW9uJ10gPSAnbm9uZSc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc3VwcG9ydHNQb2ludGVyRXZlbnRzKSB7XG4gICAgICAgICAgICB3aW5kb3cuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcm1vdmUnLCB0aGlzLm9uUG9pbnRlck1vdmUpO1xuICAgICAgICAgICAgdGhpcy5pbnRlcmFjdGlvbkRPTUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcmRvd24nLCB0aGlzLm9uUG9pbnRlckRvd24pO1xuICAgICAgICAgICAgdGhpcy5pbnRlcmFjdGlvbkRPTUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcmxlYXZlJywgdGhpcy5vblBvaW50ZXJPdXQpO1xuICAgICAgICAgICAgdGhpcy5pbnRlcmFjdGlvbkRPTUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcm92ZXInLCB0aGlzLm9uUG9pbnRlck92ZXIpO1xuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJjYW5jZWwnLCB0aGlzLm9uUG9pbnRlckNhbmNlbCk7XG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcnVwJywgdGhpcy5vblBvaW50ZXJVcCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB3aW5kb3cuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5vblBvaW50ZXJNb3ZlKTtcbiAgICAgICAgICAgIHRoaXMuaW50ZXJhY3Rpb25ET01FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMub25Qb2ludGVyRG93bik7XG4gICAgICAgICAgICB0aGlzLmludGVyYWN0aW9uRE9NRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW91dCcsIHRoaXMub25Qb2ludGVyT3V0KTtcbiAgICAgICAgICAgIHRoaXMuaW50ZXJhY3Rpb25ET01FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlb3ZlcicsIHRoaXMub25Qb2ludGVyT3Zlcik7XG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMub25Qb2ludGVyVXApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnN1cHBvcnRzVG91Y2hFdmVudHMpIHtcbiAgICAgICAgICAgIHRoaXMuaW50ZXJhY3Rpb25ET01FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCB0aGlzLm9uUG9pbnRlckRvd24pO1xuICAgICAgICAgICAgdGhpcy5pbnRlcmFjdGlvbkRPTUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hjYW5jZWwnLCB0aGlzLm9uUG9pbnRlckNhbmNlbCk7XG4gICAgICAgICAgICB0aGlzLmludGVyYWN0aW9uRE9NRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMub25Qb2ludGVyVXApO1xuICAgICAgICAgICAgdGhpcy5pbnRlcmFjdGlvbkRPTUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5vblBvaW50ZXJNb3ZlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmV2ZW50c0FkZGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgO1xuICAgIHByb2Nlc3NJbnRlcmFjdGl2ZShpbnRlcmFjdGlvbkV2ZW50LCBkaXNwbGF5T2JqZWN0LCBmdW5jLCBoaXRUZXN0LCBpbnRlcmFjdGl2ZSA9IHRydWUpIHtcbiAgICAgICAgaWYgKCFkaXNwbGF5T2JqZWN0IHx8ICFkaXNwbGF5T2JqZWN0LnZpc2libGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcG9pbnQgPSBpbnRlcmFjdGlvbkV2ZW50LmRhdGEuZ2xvYmFsO1xuICAgICAgICBpbnRlcmFjdGl2ZSA9IGRpc3BsYXlPYmplY3QuaW50ZXJhY3RpdmUgfHwgaW50ZXJhY3RpdmU7XG4gICAgICAgIGxldCBoaXQgPSBmYWxzZTtcbiAgICAgICAgbGV0IGludGVyYWN0aXZlUGFyZW50ID0gaW50ZXJhY3RpdmU7XG4gICAgICAgIGxldCBoaXRUZXN0Q2hpbGRyZW4gPSB0cnVlO1xuICAgICAgICBpZiAoZGlzcGxheU9iamVjdC5oaXRBcmVhKSB7XG4gICAgICAgICAgICBpZiAoaGl0VGVzdCkge1xuICAgICAgICAgICAgICAgIGRpc3BsYXlPYmplY3Qud29ybGRUcmFuc2Zvcm0uYXBwbHlJbnZlcnNlKHBvaW50LCB0aGlzLl90ZW1wUG9pbnQpO1xuICAgICAgICAgICAgICAgIGlmICghZGlzcGxheU9iamVjdC5oaXRBcmVhLmNvbnRhaW5zKHRoaXMuX3RlbXBQb2ludC54LCB0aGlzLl90ZW1wUG9pbnQueSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaGl0VGVzdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBoaXRUZXN0Q2hpbGRyZW4gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGhpdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW50ZXJhY3RpdmVQYXJlbnQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkaXNwbGF5T2JqZWN0Ll9tYXNrKSB7XG4gICAgICAgICAgICBpZiAoaGl0VGVzdCkge1xuICAgICAgICAgICAgICAgIGlmICghKGRpc3BsYXlPYmplY3QuX21hc2suY29udGFpbnNQb2ludCAmJiBkaXNwbGF5T2JqZWN0Ll9tYXNrLmNvbnRhaW5zUG9pbnQocG9pbnQpKSkge1xuICAgICAgICAgICAgICAgICAgICBoaXRUZXN0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGhpdFRlc3RDaGlsZHJlbiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZGlzcGxheU9iamVjdCBpbnN0YW5jZW9mIENvbnRhaW5lcl8xLkNvbnRhaW5lcikge1xuICAgICAgICAgICAgaWYgKGhpdFRlc3RDaGlsZHJlbiAmJiBkaXNwbGF5T2JqZWN0LmludGVyYWN0aXZlQ2hpbGRyZW4gJiYgZGlzcGxheU9iamVjdC5jaGlsZHJlbikge1xuICAgICAgICAgICAgICAgIGxldCBjaGlsZHJlbiA9IGRpc3BsYXlPYmplY3QuY2hpbGRyZW47XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IGNoaWxkcmVuLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgICAgICBsZXQgY2hpbGRIaXQgPSB0aGlzLnByb2Nlc3NJbnRlcmFjdGl2ZShpbnRlcmFjdGlvbkV2ZW50LCBjaGlsZCwgZnVuYywgaGl0VGVzdCwgaW50ZXJhY3RpdmVQYXJlbnQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGRIaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY2hpbGQucGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcmFjdGl2ZVBhcmVudCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkSGl0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGludGVyYWN0aW9uRXZlbnQudGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhpdFRlc3QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGl0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaW50ZXJhY3RpdmUpIHtcbiAgICAgICAgICAgIGlmIChoaXRUZXN0ICYmICFpbnRlcmFjdGlvbkV2ZW50LnRhcmdldCkge1xuICAgICAgICAgICAgICAgIGlmICghZGlzcGxheU9iamVjdC5oaXRBcmVhICYmIGRpc3BsYXlPYmplY3QuY29udGFpbnNQb2ludCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGlzcGxheU9iamVjdC5jb250YWluc1BvaW50KHBvaW50KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGl0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkaXNwbGF5T2JqZWN0LmludGVyYWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhpdCAmJiAhaW50ZXJhY3Rpb25FdmVudC50YXJnZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJhY3Rpb25FdmVudC50YXJnZXQgPSBkaXNwbGF5T2JqZWN0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZnVuYykge1xuICAgICAgICAgICAgICAgICAgICBmdW5jKGludGVyYWN0aW9uRXZlbnQsIGRpc3BsYXlPYmplY3QsICEhaGl0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhpdDtcbiAgICB9XG4gICAgO1xuICAgIHNldEN1cnNvck1vZGUobW9kZSA9IFwiZGVmYXVsdFwiKSB7XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRDdXJzb3JNb2RlID09PSBtb2RlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jdXJyZW50Q3Vyc29yTW9kZSA9IG1vZGU7XG4gICAgICAgIGxldCBzdHlsZSA9IHRoaXMuY3Vyc29yU3R5bGVzW21vZGVdO1xuICAgICAgICBpZiAoc3R5bGUpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIHN0eWxlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnRlcmFjdGlvbkRPTUVsZW1lbnQuc3R5bGUuY3Vyc29yID0gc3R5bGU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICAgICAgICAgICAgICAgICAgc3R5bGUobW9kZSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odGhpcy5pbnRlcmFjdGlvbkRPTUVsZW1lbnQuc3R5bGUsIHN0eWxlKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIG1vZGUgPT09ICdzdHJpbmcnICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5jdXJzb3JTdHlsZXMsIG1vZGUpKSB7XG4gICAgICAgICAgICB0aGlzLmludGVyYWN0aW9uRE9NRWxlbWVudC5zdHlsZS5jdXJzb3IgPSBtb2RlO1xuICAgICAgICB9XG4gICAgfVxuICAgIDtcbiAgICBoaXRUZXN0KGdsb2JhbFBvaW50LCByb290KSB7XG4gICAgICAgIHRoaXMuaGl0VGVzdEV2ZW50LnRhcmdldCA9IG51bGw7XG4gICAgICAgIHRoaXMuaGl0VGVzdEV2ZW50LmRhdGEuZ2xvYmFsID0gZ2xvYmFsUG9pbnQ7XG4gICAgICAgIGxldCBjdXJyZW50ZGlzcGxheTtcbiAgICAgICAgaWYgKHJvb3QpIHtcbiAgICAgICAgICAgIGN1cnJlbnRkaXNwbGF5ID0gcm9vdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGN1cnJlbnRkaXNwbGF5ID0gdGhpcy5yZW5kZXJlci5fbGFzdE9iamVjdFJlbmRlcmVkO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucHJvY2Vzc0ludGVyYWN0aXZlKHRoaXMuaGl0VGVzdEV2ZW50LCBjdXJyZW50ZGlzcGxheSwgbnVsbCwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiB0aGlzLmhpdFRlc3RFdmVudC50YXJnZXQ7XG4gICAgfVxuICAgIDtcbiAgICBub3JtYWxpemVUb1BvaW50ZXJEYXRhKGV2ZW50KSB7XG4gICAgICAgIGxldCBub3JtYWxpemVkRXZlbnRzID0gW107XG4gICAgICAgIGlmICh0aGlzLnN1cHBvcnRzVG91Y2hFdmVudHMgJiYgZXZlbnQgaW5zdGFuY2VvZiBUb3VjaEV2ZW50KSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbGkgPSBldmVudC5jaGFuZ2VkVG91Y2hlcy5sZW5ndGg7IGkgPCBsaTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHRvdWNoID0gZXZlbnQuY2hhbmdlZFRvdWNoZXNbaV07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0b3VjaC5idXR0b24gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvdWNoLmJ1dHRvbiA9IGV2ZW50LnRvdWNoZXMubGVuZ3RoID8gMSA6IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdG91Y2guYnV0dG9ucyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdG91Y2guYnV0dG9ucyA9IGV2ZW50LnRvdWNoZXMubGVuZ3RoID8gMSA6IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdG91Y2guaXNQcmltYXJ5ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICB0b3VjaC5pc1ByaW1hcnkgPSBldmVudC50b3VjaGVzLmxlbmd0aCA9PT0gMSAmJiBldmVudC50eXBlID09PSAndG91Y2hzdGFydCc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdG91Y2gud2lkdGggPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvdWNoLndpZHRoID0gdG91Y2gucmFkaXVzWCB8fCAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRvdWNoLmhlaWdodCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdG91Y2guaGVpZ2h0ID0gdG91Y2gucmFkaXVzWSB8fCAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRvdWNoLnRpbHRYID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICB0b3VjaC50aWx0WCA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdG91Y2gudGlsdFkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvdWNoLnRpbHRZID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0b3VjaC5wb2ludGVyVHlwZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdG91Y2gucG9pbnRlclR5cGUgPSAndG91Y2gnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRvdWNoLnBvaW50ZXJJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdG91Y2gucG9pbnRlcklkID0gdG91Y2guaWRlbnRpZmllciB8fCAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRvdWNoLnByZXNzdXJlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICB0b3VjaC5wcmVzc3VyZSA9IHRvdWNoLmZvcmNlIHx8IDAuNTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0b3VjaC50d2lzdCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdG91Y2gudHdpc3QgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRvdWNoLnRhbmdlbnRpYWxQcmVzc3VyZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdG91Y2gudGFuZ2VudGlhbFByZXNzdXJlID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0b3VjaC5sYXllclggPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvdWNoLmxheWVyWCA9IHRvdWNoLm9mZnNldFggPSB0b3VjaC5jbGllbnRYO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRvdWNoLmxheWVyWSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdG91Y2gubGF5ZXJZID0gdG91Y2gub2Zmc2V0WSA9IHRvdWNoLmNsaWVudFk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRvdWNoLmlzTm9ybWFsaXplZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgbm9ybWFsaXplZEV2ZW50cy5wdXNoKHRvdWNoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChldmVudCBpbnN0YW5jZW9mIE1vdXNlRXZlbnRfMS5Nb3VzZUV2ZW50ICYmICghdGhpcy5zdXBwb3J0c1BvaW50ZXJFdmVudHMgfHwgIShldmVudCBpbnN0YW5jZW9mIHdpbmRvd1snUG9pbnRlckV2ZW50J10pKSkge1xuICAgICAgICAgICAgbGV0IG9yaWdpbmV2ZW50ID0gZXZlbnQ7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9yaWdpbmV2ZW50LmlzUHJpbWFyeSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBvcmlnaW5ldmVudC5pc1ByaW1hcnkgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcmlnaW5ldmVudC53aWR0aCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBvcmlnaW5ldmVudC53aWR0aCA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9yaWdpbmV2ZW50LmhlaWdodCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBvcmlnaW5ldmVudC5oZWlnaHQgPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcmlnaW5ldmVudC50aWx0WCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBvcmlnaW5ldmVudC50aWx0WCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9yaWdpbmV2ZW50LnRpbHRZID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIG9yaWdpbmV2ZW50LnRpbHRZID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3JpZ2luZXZlbnQucG9pbnRlclR5cGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgb3JpZ2luZXZlbnQucG9pbnRlclR5cGUgPSAnbW91c2UnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcmlnaW5ldmVudC5wb2ludGVySWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgb3JpZ2luZXZlbnQucG9pbnRlcklkID0gSW50ZXJhY3Rpb25NYW5hZ2VyLk1PVVNFX1BPSU5URVJfSUQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9yaWdpbmV2ZW50LnByZXNzdXJlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIG9yaWdpbmV2ZW50LnByZXNzdXJlID0gMC41O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcmlnaW5ldmVudC50d2lzdCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBvcmlnaW5ldmVudC50d2lzdCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9yaWdpbmV2ZW50LnRhbmdlbnRpYWxQcmVzc3VyZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBvcmlnaW5ldmVudC50YW5nZW50aWFsUHJlc3N1cmUgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3JpZ2luZXZlbnQuaXNOb3JtYWxpemVkID0gdHJ1ZTtcbiAgICAgICAgICAgIG5vcm1hbGl6ZWRFdmVudHMucHVzaChldmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBub3JtYWxpemVkRXZlbnRzLnB1c2goZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub3JtYWxpemVkRXZlbnRzO1xuICAgIH1cbiAgICA7XG4gICAgZ2V0SW50ZXJhY3Rpb25EYXRhRm9yUG9pbnRlcklkKGV2ZW50KSB7XG4gICAgICAgIGxldCBwb2ludGVySWQgPSBldmVudC5wb2ludGVySWQ7XG4gICAgICAgIGxldCBpbnRlcmFjdGlvbkRhdGE7XG4gICAgICAgIGlmIChwb2ludGVySWQgPT09IEludGVyYWN0aW9uTWFuYWdlci5NT1VTRV9QT0lOVEVSX0lEIHx8IGV2ZW50LnBvaW50ZXJUeXBlID09PSAnbW91c2UnKSB7XG4gICAgICAgICAgICBpbnRlcmFjdGlvbkRhdGEgPSB0aGlzLm1vdXNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuYWN0aXZlSW50ZXJhY3Rpb25EYXRhW3BvaW50ZXJJZF0pIHtcbiAgICAgICAgICAgIGludGVyYWN0aW9uRGF0YSA9IHRoaXMuYWN0aXZlSW50ZXJhY3Rpb25EYXRhW3BvaW50ZXJJZF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpbnRlcmFjdGlvbkRhdGEgPSB0aGlzLmludGVyYWN0aW9uRGF0YVBvb2wucG9wKCkgfHwgbmV3IEludGVyYWN0aW9uRGF0YV8xLkludGVyYWN0aW9uRGF0YSgpO1xuICAgICAgICAgICAgaW50ZXJhY3Rpb25EYXRhLmlkZW50aWZpZXIgPSBwb2ludGVySWQ7XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZUludGVyYWN0aW9uRGF0YVtwb2ludGVySWRdID0gaW50ZXJhY3Rpb25EYXRhO1xuICAgICAgICB9XG4gICAgICAgIGludGVyYWN0aW9uRGF0YS5jb3B5RXZlbnQoZXZlbnQpO1xuICAgICAgICByZXR1cm4gaW50ZXJhY3Rpb25EYXRhO1xuICAgIH1cbiAgICA7XG4gICAgb25Qb2ludGVyQ29tcGxldGUob3JpZ2luYWxFdmVudCwgY2FuY2VsbGVkLCBmdW5jKSB7XG4gICAgICAgIGxldCBldmVudHMgPSB0aGlzLm5vcm1hbGl6ZVRvUG9pbnRlckRhdGEob3JpZ2luYWxFdmVudCk7XG4gICAgICAgIGxldCBldmVudExlbiA9IGV2ZW50cy5sZW5ndGg7XG4gICAgICAgIGxldCBldmVudEFwcGVuZCA9IG9yaWdpbmFsRXZlbnQudGFyZ2V0ICE9PSB0aGlzLmludGVyYWN0aW9uRE9NRWxlbWVudCA/ICdvdXRzaWRlJyA6ICcnO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGV2ZW50TGVuOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBldmVudCA9IGV2ZW50c1tpXTtcbiAgICAgICAgICAgIGxldCBpbnRlcmFjdGlvbkRhdGEgPSB0aGlzLmdldEludGVyYWN0aW9uRGF0YUZvclBvaW50ZXJJZChldmVudCk7XG4gICAgICAgICAgICBsZXQgaW50ZXJhY3Rpb25FdmVudCA9IHRoaXMuY29uZmlndXJlSW50ZXJhY3Rpb25FdmVudEZvckRPTUV2ZW50KHRoaXMuZXZlbnREYXRhLCBldmVudCwgaW50ZXJhY3Rpb25EYXRhKTtcbiAgICAgICAgICAgIGludGVyYWN0aW9uRXZlbnQuZGF0YS5vcmlnaW5hbEV2ZW50ID0gb3JpZ2luYWxFdmVudDtcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc0ludGVyYWN0aXZlKGludGVyYWN0aW9uRXZlbnQsIHRoaXMucmVuZGVyZXIuX2xhc3RPYmplY3RSZW5kZXJlZCwgZnVuYywgY2FuY2VsbGVkIHx8ICFldmVudEFwcGVuZCk7XG4gICAgICAgICAgICBsZXQgcG9pbnRlciA9IG5ldyBNb3VzZUV2ZW50XzEuTW91c2VFdmVudChjYW5jZWxsZWQgPyBNb3VzZUV2ZW50XzEuTW91c2VFdmVudC5QT0lOVEVSX0NBTkNFTCA6IChNb3VzZUV2ZW50XzEuTW91c2VFdmVudC5QT0lOVEVSX1VQKSk7XG4gICAgICAgICAgICBwb2ludGVyLmRhdGEgPSBpbnRlcmFjdGlvbkRhdGE7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQocG9pbnRlcik7XG4gICAgICAgICAgICBpZiAoZXZlbnQucG9pbnRlclR5cGUgPT09ICdtb3VzZScgfHwgZXZlbnQucG9pbnRlclR5cGUgPT09ICdwZW4nKSB7XG4gICAgICAgICAgICAgICAgbGV0IGlzUmlnaHRCdXR0b24gPSBldmVudC5idXR0b24gPT09IDI7XG4gICAgICAgICAgICAgICAgbGV0IHBvaW50ZXIgPSBuZXcgTW91c2VFdmVudF8xLk1vdXNlRXZlbnQoaXNSaWdodEJ1dHRvbiA/IChNb3VzZUV2ZW50XzEuTW91c2VFdmVudC5SSUdIVF9NT1VTRV9VUCkgOiAoTW91c2VFdmVudF8xLk1vdXNlRXZlbnQuTU9VU0VfVVApKTtcbiAgICAgICAgICAgICAgICBwb2ludGVyLmRhdGEgPSBpbnRlcmFjdGlvbkRhdGE7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KHBvaW50ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZXZlbnQucG9pbnRlclR5cGUgPT09ICd0b3VjaCcpIHtcbiAgICAgICAgICAgICAgICBsZXQgcG9pbnRlciA9IG5ldyBNb3VzZUV2ZW50XzEuTW91c2VFdmVudChjYW5jZWxsZWQgPyBNb3VzZUV2ZW50XzEuTW91c2VFdmVudC5UT1VDSF9DQU5DRUwgOiAoTW91c2VFdmVudF8xLk1vdXNlRXZlbnQuVE9VQ0hfRU5EKSk7XG4gICAgICAgICAgICAgICAgcG9pbnRlci5kYXRhID0gaW50ZXJhY3Rpb25EYXRhO1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChwb2ludGVyKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbGVhc2VJbnRlcmFjdGlvbkRhdGFGb3JQb2ludGVySWQoZXZlbnQucG9pbnRlcklkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICA7XG4gICAgcmVsZWFzZUludGVyYWN0aW9uRGF0YUZvclBvaW50ZXJJZChwb2ludGVySWQpIHtcbiAgICAgICAgbGV0IGludGVyYWN0aW9uRGF0YSA9IHRoaXMuYWN0aXZlSW50ZXJhY3Rpb25EYXRhW3BvaW50ZXJJZF07XG4gICAgICAgIGlmIChpbnRlcmFjdGlvbkRhdGEpIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmFjdGl2ZUludGVyYWN0aW9uRGF0YVtwb2ludGVySWRdO1xuICAgICAgICAgICAgaW50ZXJhY3Rpb25EYXRhLnJlc2V0KCk7XG4gICAgICAgICAgICB0aGlzLmludGVyYWN0aW9uRGF0YVBvb2wucHVzaChpbnRlcmFjdGlvbkRhdGEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIDtcbiAgICBwcm9jZXNzUG9pbnRlckNhbmNlbChpbnRlcmFjdGlvbkV2ZW50LCBkaXNwbGF5T2JqZWN0KSB7XG4gICAgICAgIGxldCBkYXRhID0gaW50ZXJhY3Rpb25FdmVudC5kYXRhO1xuICAgICAgICBsZXQgaWQgPSBpbnRlcmFjdGlvbkV2ZW50LmRhdGEuaWRlbnRpZmllcjtcbiAgICAgICAgaWYgKGRpc3BsYXlPYmplY3QudHJhY2tlZFBvaW50ZXJzW2lkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBkZWxldGUgZGlzcGxheU9iamVjdC50cmFja2VkUG9pbnRlcnNbaWRdO1xuICAgICAgICAgICAgbGV0IHBvaW50ZXIgPSBuZXcgTW91c2VFdmVudF8xLk1vdXNlRXZlbnQoTW91c2VFdmVudF8xLk1vdXNlRXZlbnQuUE9JTlRFUl9DQU5DRUwpO1xuICAgICAgICAgICAgcG9pbnRlci5kYXRhID0gZGF0YTtcbiAgICAgICAgICAgIGRpc3BsYXlPYmplY3QuZGlzcGF0Y2hFdmVudChwb2ludGVyKTtcbiAgICAgICAgICAgIGlmIChkYXRhLnBvaW50ZXJUeXBlID09PSAndG91Y2gnKSB7XG4gICAgICAgICAgICAgICAgbGV0IHBvaW50ZXIgPSBuZXcgTW91c2VFdmVudF8xLk1vdXNlRXZlbnQoTW91c2VFdmVudF8xLk1vdXNlRXZlbnQuVE9VQ0hfQ0FOQ0VMKTtcbiAgICAgICAgICAgICAgICBwb2ludGVyLmRhdGEgPSBkYXRhO1xuICAgICAgICAgICAgICAgIGRpc3BsYXlPYmplY3QuZGlzcGF0Y2hFdmVudChwb2ludGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICA7XG4gICAgZGVzdHJveShvcHRpb25zID0gbnVsbCkge1xuICAgICAgICB0aGlzLnJlbW92ZUV2ZW50cygpO1xuICAgICAgICB0aGlzLnJlbmRlcmVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5tb3VzZSA9IG51bGw7XG4gICAgICAgIHRoaXMuZXZlbnREYXRhID0gbnVsbDtcbiAgICAgICAgdGhpcy5pbnRlcmFjdGlvbkRPTUVsZW1lbnQgPSBudWxsO1xuICAgICAgICB0aGlzLm9uUG9pbnRlckRvd24gPSBudWxsO1xuICAgICAgICB0aGlzLnByb2Nlc3NQb2ludGVyRG93biA9IG51bGw7XG4gICAgICAgIHRoaXMub25Qb2ludGVyVXAgPSBudWxsO1xuICAgICAgICB0aGlzLnByb2Nlc3NQb2ludGVyVXAgPSBudWxsO1xuICAgICAgICB0aGlzLm9uUG9pbnRlckNhbmNlbCA9IG51bGw7XG4gICAgICAgIHRoaXMucHJvY2Vzc1BvaW50ZXJDYW5jZWwgPSBudWxsO1xuICAgICAgICB0aGlzLm9uUG9pbnRlck1vdmUgPSBudWxsO1xuICAgICAgICB0aGlzLnByb2Nlc3NQb2ludGVyTW92ZSA9IG51bGw7XG4gICAgICAgIHRoaXMub25Qb2ludGVyT3V0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5wcm9jZXNzUG9pbnRlck92ZXJPdXQgPSBudWxsO1xuICAgICAgICB0aGlzLm9uUG9pbnRlck92ZXIgPSBudWxsO1xuICAgICAgICB0aGlzLl90ZW1wUG9pbnQgPSBudWxsO1xuICAgIH1cbiAgICA7XG59XG5JbnRlcmFjdGlvbk1hbmFnZXIuTU9VU0VfUE9JTlRFUl9JRCA9IDE7XG5leHBvcnRzLkludGVyYWN0aW9uTWFuYWdlciA9IEludGVyYWN0aW9uTWFuYWdlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY2xhc3MgSW50ZXJhY3Rpb25UcmFja2luZ0RhdGEge1xuICAgIGNvbnN0cnVjdG9yKHBvaW50ZXJJZCkge1xuICAgICAgICB0aGlzLl9wb2ludGVySWQgPSBwb2ludGVySWQ7XG4gICAgICAgIHRoaXMuX2ZsYWdzID0gSW50ZXJhY3Rpb25UcmFja2luZ0RhdGEuRkxBR1MuTk9ORTtcbiAgICB9XG4gICAgX2RvU2V0KGZsYWcsIHluKSB7XG4gICAgICAgIGlmICh5bikge1xuICAgICAgICAgICAgdGhpcy5fZmxhZ3MgPSB0aGlzLl9mbGFncyB8IGZsYWc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9mbGFncyA9IHRoaXMuX2ZsYWdzICYgKH5mbGFnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICA7XG4gICAgZ2V0IHBvaW50ZXJJZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BvaW50ZXJJZDtcbiAgICB9XG4gICAgO1xuICAgIGdldCBmbGFncygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZsYWdzO1xuICAgIH1cbiAgICA7XG4gICAgc2V0IGZsYWdzKGZsYWdzKSB7XG4gICAgICAgIHRoaXMuX2ZsYWdzID0gZmxhZ3M7XG4gICAgfVxuICAgIDtcbiAgICBnZXQgbm9uZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZsYWdzID09PSBJbnRlcmFjdGlvblRyYWNraW5nRGF0YS5GTEFHUy5OT05FO1xuICAgIH1cbiAgICA7XG4gICAgZ2V0IG92ZXIoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5fZmxhZ3MgJiBJbnRlcmFjdGlvblRyYWNraW5nRGF0YS5GTEFHUy5PVkVSKSAhPT0gMDtcbiAgICB9XG4gICAgO1xuICAgIHNldCBvdmVyKHluKSB7XG4gICAgICAgIHRoaXMuX2RvU2V0KEludGVyYWN0aW9uVHJhY2tpbmdEYXRhLkZMQUdTLk9WRVIsIHluKTtcbiAgICB9XG4gICAgO1xuICAgIGdldCByaWdodERvd24oKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5fZmxhZ3MgJiBJbnRlcmFjdGlvblRyYWNraW5nRGF0YS5GTEFHUy5SSUdIVF9ET1dOKSAhPT0gMDtcbiAgICB9XG4gICAgO1xuICAgIHNldCByaWdodERvd24oeW4pIHtcbiAgICAgICAgdGhpcy5fZG9TZXQoSW50ZXJhY3Rpb25UcmFja2luZ0RhdGEuRkxBR1MuUklHSFRfRE9XTiwgeW4pO1xuICAgIH1cbiAgICA7XG4gICAgZ2V0IGxlZnREb3duKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuX2ZsYWdzICYgSW50ZXJhY3Rpb25UcmFja2luZ0RhdGEuRkxBR1MuTEVGVF9ET1dOKSAhPT0gMDtcbiAgICB9XG4gICAgO1xuICAgIHNldCBsZWZ0RG93bih5bikge1xuICAgICAgICB0aGlzLl9kb1NldChJbnRlcmFjdGlvblRyYWNraW5nRGF0YS5GTEFHUy5MRUZUX0RPV04sIHluKTtcbiAgICB9XG4gICAgO1xufVxuSW50ZXJhY3Rpb25UcmFja2luZ0RhdGEuRkxBR1MgPSB7XG4gICAgTk9ORTogMCxcbiAgICBPVkVSOiAxIDw8IDAsXG4gICAgTEVGVF9ET1dOOiAxIDw8IDEsXG4gICAgUklHSFRfRE9XTjogMSA8PCAyLFxufTtcbmV4cG9ydHMuSW50ZXJhY3Rpb25UcmFja2luZ0RhdGEgPSBJbnRlcmFjdGlvblRyYWNraW5nRGF0YTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgRmlsbFN0eWxlXzEgPSByZXF1aXJlKFwiLi9GaWxsU3R5bGVcIik7XG5jbGFzcyBMaW5lU3R5bGUgZXh0ZW5kcyBGaWxsU3R5bGVfMS5GaWxsU3R5bGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgIH1cbiAgICBjbG9uZSgpIHtcbiAgICAgICAgdmFyIG9iaiA9IG5ldyBMaW5lU3R5bGUoKTtcbiAgICAgICAgb2JqLmNvbG9yID0gdGhpcy5jb2xvcjtcbiAgICAgICAgb2JqLmFscGhhID0gdGhpcy5hbHBoYTtcbiAgICAgICAgb2JqLnRleHR1cmUgPSB0aGlzLnRleHR1cmU7XG4gICAgICAgIG9iai5tYXRyaXggPSB0aGlzLm1hdHJpeDtcbiAgICAgICAgb2JqLnZpc2libGUgPSB0aGlzLnZpc2libGU7XG4gICAgICAgIG9iai53aWR0aCA9IHRoaXMud2lkdGg7XG4gICAgICAgIG9iai5hbGlnbm1lbnQgPSB0aGlzLmFsaWdubWVudDtcbiAgICAgICAgb2JqLm5hdGl2ZSA9IHRoaXMubmF0aXZlO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogUmVzZXQgdGhlIGxpbmUgc3R5bGUgdG8gZGVmYXVsdC5cbiAgICAgKi9cbiAgICByZXNldCgpIHtcbiAgICAgICAgc3VwZXIucmVzZXQoKTtcbiAgICAgICAgLy8gT3ZlcnJpZGUgZGVmYXVsdCBsaW5lIHN0eWxlIGNvbG9yXG4gICAgICAgIHRoaXMuY29sb3IgPSAweDA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgd2lkdGggKHRoaWNrbmVzcykgb2YgYW55IGxpbmVzIGRyYXduLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMud2lkdGggPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGFsaWdubWVudCBvZiBhbnkgbGluZXMgZHJhd24gKDAuNSA9IG1pZGRsZSwgMSA9IG91dHRlciwgMCA9IGlubmVyKS5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAwXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmFsaWdubWVudCA9IDAuNTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHRydWUgdGhlIGxpbmVzIHdpbGwgYmUgZHJhdyB1c2luZyBMSU5FUyBpbnN0ZWFkIG9mIFRSSUFOR0xFX1NUUklQXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XG4gICAgICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm5hdGl2ZSA9IGZhbHNlO1xuICAgIH1cbiAgICA7XG59XG5leHBvcnRzLkxpbmVTdHlsZSA9IExpbmVTdHlsZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5PVVRQVVRfVE9fQ09OU09MRSA9IHRydWU7XG5leHBvcnRzLnRyYWNlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKGlzTmFOKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBcInNob3c6IG51bGxcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBcInNob3c6IDBcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBcInNob3c6IFwiICsgdmFsdWUudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXhwb3J0cy5PVVRQVVRfVE9fQ09OU09MRSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2cocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn07XG5leHBvcnRzLnJldmVhbE1ldGhvZHMgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gXCJyZXZlYWwgbWV0aG9kczogbnVsbFwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFwicmV2ZWFsIG1ldGhvZHM6IFwiO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIGluc3RhbmNlSXRlbSA9IHZhbHVlW2tleV07XG4gICAgICAgICAgICBpZiAoaW5zdGFuY2VJdGVtIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gJ21ldGhvZDogJyArIGtleSArICcgOiAnICsgdmFsdWVba2V5XSArIFwiXFxuXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV4cG9ydHMuT1VUUFVUX1RPX0NPTlNPTEUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59O1xuZXhwb3J0cy5yZXZlYWwgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBcInJldmVhbDogbnVsbFwiO1xuICAgICAgICBpZiAoZXhwb3J0cy5PVVRQVVRfVE9fQ09OU09MRSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2cocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBcInJldmVhbDogdW5kZWZpbmVkXCI7XG4gICAgICAgIGlmIChleHBvcnRzLk9VVFBVVF9UT19DT05TT0xFKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHJlc3VsdCA9IFwicmV2ZWFsOiBcIjtcbiAgICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICAgICAgdmFyIGluc3RhbmNlSXRlbSA9IGdldFZhbHVlKGtleSwgdmFsdWUpO1xuICAgICAgICBpZiAoaW5zdGFuY2VJdGVtKSB7XG4gICAgICAgICAgICBpZiAoaW5zdGFuY2VJdGVtIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gJ21ldGhvZDogJyArIGtleSArIFwiXFxuXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0ga2V5ICsgJyA6ICcgKyBpbnN0YW5jZUl0ZW0gKyBcIlxcblwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoZXhwb3J0cy5PVVRQVVRfVE9fQ09OU09MRSkge1xuICAgICAgICBjb25zb2xlLmxvZyhyZXN1bHQpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbmNvbnN0IGdldFZhbHVlID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICB2YXIgdmFsdWVSZXN1bHQgPSBudWxsO1xuICAgIHRyeSB7XG4gICAgICAgIHZhbHVlUmVzdWx0ID0gdmFsdWVba2V5XTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlUmVzdWx0O1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgU3lzdGVtXzEgPSByZXF1aXJlKFwiLi9TeXN0ZW1cIik7XG5jb25zdCBTcHJpdGVNYXNrRmlsdGVyXzEgPSByZXF1aXJlKFwiLi9TcHJpdGVNYXNrRmlsdGVyXCIpO1xuY2xhc3MgTWFza1N5c3RlbSBleHRlbmRzIFN5c3RlbV8xLlN5c3RlbSB7XG4gICAgY29uc3RydWN0b3IocmVuZGVyZXIpIHtcbiAgICAgICAgc3VwZXIocmVuZGVyZXIpO1xuICAgICAgICAvLyBUT0RPIC0gd2UgZG9uJ3QgbmVlZCBib3RoIVxuICAgICAgICAvKipcbiAgICAgICAgICogYHRydWVgIGlmIGN1cnJlbnQgcHVzaGVkIG1hc2tlZCBpcyBzY2lzc29yXG4gICAgICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XG4gICAgICAgICAqIEByZWFkb25seVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zY2lzc29yID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNYXNrIGRhdGFcbiAgICAgICAgICogQG1lbWJlciB7UElYSS5HcmFwaGljc31cbiAgICAgICAgICogQHJlYWRvbmx5XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNjaXNzb3JEYXRhID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRhcmdldCB0byBtYXNrXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuRGlzcGxheU9iamVjdH1cbiAgICAgICAgICogQHJlYWRvbmx5XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNjaXNzb3JSZW5kZXJUYXJnZXQgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogRW5hYmxlIHNjaXNzb3JcbiAgICAgICAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICAgICAgICogQHJlYWRvbmx5XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmVuYWJsZVNjaXNzb3IgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFBvb2wgb2YgdXNlZCBzcHJpdGUgbWFzayBmaWx0ZXJzXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuU3ByaXRlTWFza0ZpbHRlcltdfVxuICAgICAgICAgKiBAcmVhZG9ubHlcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYWxwaGFNYXNrUG9vbCA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3VycmVudCBpbmRleCBvZiBhbHBoYSBtYXNrIHBvb2xcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAwXG4gICAgICAgICAqIEByZWFkb25seVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hbHBoYU1hc2tJbmRleCA9IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgdGhlIE1hc2sgYW5kIGFkZHMgaXQgdG8gdGhlIGN1cnJlbnQgZmlsdGVyIHN0YWNrLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQSVhJLkRpc3BsYXlPYmplY3R9IHRhcmdldCAtIERpc3BsYXkgT2JqZWN0IHRvIHB1c2ggdGhlIG1hc2sgdG9cbiAgICAgKiBAcGFyYW0ge1BJWEkuU3ByaXRlfFBJWEkuR3JhcGhpY3N9IG1hc2tEYXRhIC0gVGhlIG1hc2tpbmcgZGF0YS5cbiAgICAgKi9cbiAgICBwdXNoKHRhcmdldCwgbWFza0RhdGEpIHtcbiAgICAgICAgLy8gVE9ETyB0aGUgcm9vdCBjaGVjayBtZWFucyBzY2lzc29yIHJlY3Qgd2lsbCBub3RcbiAgICAgICAgLy8gYmUgdXNlZCBvbiByZW5kZXIgdGV4dHVyZXMgbW9yZSBpbmZvIGhlcmU6XG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9waXhpanMvcGl4aS5qcy9wdWxsLzM1NDVcbiAgICAgICAgaWYgKG1hc2tEYXRhLmlzU3ByaXRlKSB7XG4gICAgICAgICAgICB0aGlzLnB1c2hTcHJpdGVNYXNrKHRhcmdldCwgbWFza0RhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuZW5hYmxlU2Npc3NvclxuICAgICAgICAgICAgJiYgIXRoaXMuc2Npc3NvclxuICAgICAgICAgICAgJiYgdGhpcy5yZW5kZXJlci5fYWN0aXZlUmVuZGVyVGFyZ2V0LnJvb3RcbiAgICAgICAgICAgICYmICF0aGlzLnJlbmRlcmVyLnN0ZW5jaWwuc3RlbmNpbE1hc2tTdGFjay5sZW5ndGhcbiAgICAgICAgICAgICYmIG1hc2tEYXRhLmlzRmFzdFJlY3QoKSkge1xuICAgICAgICAgICAgdmFyIG1hdHJpeCA9IG1hc2tEYXRhLndvcmxkVHJhbnNmb3JtO1xuICAgICAgICAgICAgdmFyIHJvdCA9IE1hdGguYXRhbjIobWF0cml4LmIsIG1hdHJpeC5hKTtcbiAgICAgICAgICAgIC8vIHVzZSB0aGUgbmVhcmVzdCBkZWdyZWUhXG4gICAgICAgICAgICByb3QgPSBNYXRoLnJvdW5kKHJvdCAqICgxODAgLyBNYXRoLlBJKSk7XG4gICAgICAgICAgICBpZiAocm90ICUgOTApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnB1c2hTdGVuY2lsTWFzayhtYXNrRGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnB1c2hTY2lzc29yTWFzayh0YXJnZXQsIG1hc2tEYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucHVzaFN0ZW5jaWxNYXNrKG1hc2tEYXRhKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB0aGUgbGFzdCBtYXNrIGZyb20gdGhlIG1hc2sgc3RhY2sgYW5kIGRvZXNuJ3QgcmV0dXJuIGl0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQSVhJLkRpc3BsYXlPYmplY3R9IHRhcmdldCAtIERpc3BsYXkgT2JqZWN0IHRvIHBvcCB0aGUgbWFzayBmcm9tXG4gICAgICogQHBhcmFtIHtQSVhJLlNwcml0ZXxQSVhJLkdyYXBoaWNzfSBtYXNrRGF0YSAtIFRoZSBtYXNraW5nIGRhdGEuXG4gICAgICovXG4gICAgcG9wKHRhcmdldCwgbWFza0RhdGEpIHtcbiAgICAgICAgaWYgKG1hc2tEYXRhLmlzU3ByaXRlKSB7XG4gICAgICAgICAgICB0aGlzLnBvcFNwcml0ZU1hc2sodGFyZ2V0LCBtYXNrRGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5lbmFibGVTY2lzc29yICYmICF0aGlzLnJlbmRlcmVyLnN0ZW5jaWwuc3RlbmNpbE1hc2tTdGFjay5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMucG9wU2Npc3Nvck1hc2sodGFyZ2V0LCBtYXNrRGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnBvcFN0ZW5jaWxNYXNrKHRhcmdldCwgbWFza0RhdGEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIHRoZSBNYXNrIGFuZCBhZGRzIGl0IHRvIHRoZSBjdXJyZW50IGZpbHRlciBzdGFjay5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UElYSS5SZW5kZXJUZXh0dXJlfSB0YXJnZXQgLSBEaXNwbGF5IE9iamVjdCB0byBwdXNoIHRoZSBzcHJpdGUgbWFzayB0b1xuICAgICAqIEBwYXJhbSB7UElYSS5TcHJpdGV9IG1hc2tEYXRhIC0gU3ByaXRlIHRvIGJlIHVzZWQgYXMgdGhlIG1hc2tcbiAgICAgKi9cbiAgICBwdXNoU3ByaXRlTWFzayh0YXJnZXQsIG1hc2tEYXRhKSB7XG4gICAgICAgIHZhciBhbHBoYU1hc2tGaWx0ZXIgPSB0aGlzLmFscGhhTWFza1Bvb2xbdGhpcy5hbHBoYU1hc2tJbmRleF07XG4gICAgICAgIGlmICghYWxwaGFNYXNrRmlsdGVyKSB7XG4gICAgICAgICAgICBhbHBoYU1hc2tGaWx0ZXIgPSB0aGlzLmFscGhhTWFza1Bvb2xbdGhpcy5hbHBoYU1hc2tJbmRleF0gPSBbbmV3IFNwcml0ZU1hc2tGaWx0ZXJfMS5TcHJpdGVNYXNrRmlsdGVyKG1hc2tEYXRhKV07XG4gICAgICAgIH1cbiAgICAgICAgYWxwaGFNYXNrRmlsdGVyWzBdLnJlc29sdXRpb24gPSB0aGlzLnJlbmRlcmVyLnJlc29sdXRpb247XG4gICAgICAgIGFscGhhTWFza0ZpbHRlclswXS5tYXNrU3ByaXRlID0gbWFza0RhdGE7XG4gICAgICAgIHZhciBzdGFzaEZpbHRlckFyZWEgPSB0YXJnZXQuZmlsdGVyQXJlYTtcbiAgICAgICAgdGFyZ2V0LmZpbHRlckFyZWEgPSBtYXNrRGF0YS5nZXRCb3VuZHModHJ1ZSk7XG4gICAgICAgIHRoaXMucmVuZGVyZXIuZmlsdGVyLnB1c2godGFyZ2V0LCBhbHBoYU1hc2tGaWx0ZXIpO1xuICAgICAgICB0YXJnZXQuZmlsdGVyQXJlYSA9IHN0YXNoRmlsdGVyQXJlYTtcbiAgICAgICAgdGhpcy5hbHBoYU1hc2tJbmRleCsrO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB0aGUgbGFzdCBmaWx0ZXIgZnJvbSB0aGUgZmlsdGVyIHN0YWNrIGFuZCBkb2Vzbid0IHJldHVybiBpdC5cbiAgICAgKlxuICAgICAqL1xuICAgIHBvcFNwcml0ZU1hc2soYSwgYikge1xuICAgICAgICB0aGlzLnJlbmRlcmVyLmZpbHRlci5wb3AoKTtcbiAgICAgICAgdGhpcy5hbHBoYU1hc2tJbmRleC0tO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogQXBwbGllcyB0aGUgTWFzayBhbmQgYWRkcyBpdCB0byB0aGUgY3VycmVudCBmaWx0ZXIgc3RhY2suXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BJWEkuU3ByaXRlfFBJWEkuR3JhcGhpY3N9IG1hc2tEYXRhIC0gVGhlIG1hc2tpbmcgZGF0YS5cbiAgICAgKi9cbiAgICBwdXNoU3RlbmNpbE1hc2sobWFza0RhdGEpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5iYXRjaC5mbHVzaCgpO1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnN0ZW5jaWwucHVzaFN0ZW5jaWwobWFza0RhdGEpO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB0aGUgbGFzdCBmaWx0ZXIgZnJvbSB0aGUgZmlsdGVyIHN0YWNrIGFuZCBkb2Vzbid0IHJldHVybiBpdC5cbiAgICAgKlxuICAgICAqL1xuICAgIHBvcFN0ZW5jaWxNYXNrKGEsIGIpIHtcbiAgICAgICAgLy8gdGhpcy5yZW5kZXJlci5jdXJyZW50UmVuZGVyZXIuc3RvcCgpO1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnN0ZW5jaWwucG9wU3RlbmNpbCgpO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BJWEkuRGlzcGxheU9iamVjdH0gdGFyZ2V0IC0gRGlzcGxheSBPYmplY3QgdG8gcHVzaCB0aGUgbWFzayB0b1xuICAgICAqIEBwYXJhbSB7UElYSS5HcmFwaGljc30gbWFza0RhdGEgLSBUaGUgbWFza2luZyBkYXRhLlxuICAgICAqL1xuICAgIHB1c2hTY2lzc29yTWFzayh0YXJnZXQsIG1hc2tEYXRhKSB7XG4gICAgICAgIG1hc2tEYXRhLnJlbmRlcmFibGUgPSB0cnVlO1xuICAgICAgICB2YXIgcmVuZGVyVGFyZ2V0ID0gdGhpcy5yZW5kZXJlci5fYWN0aXZlUmVuZGVyVGFyZ2V0O1xuICAgICAgICB2YXIgYm91bmRzID0gbWFza0RhdGEuZ2V0Qm91bmRzKCk7XG4gICAgICAgIGJvdW5kcy5maXQocmVuZGVyVGFyZ2V0LnNpemUpO1xuICAgICAgICBtYXNrRGF0YS5yZW5kZXJhYmxlID0gZmFsc2U7XG4gICAgICAgIHRoaXMucmVuZGVyZXIuZ2wuZW5hYmxlKHRoaXMucmVuZGVyZXIuZ2wuU0NJU1NPUl9URVNUKTtcbiAgICAgICAgdmFyIHJlc29sdXRpb24gPSB0aGlzLnJlbmRlcmVyLnJlc29sdXRpb247XG4gICAgICAgIHRoaXMucmVuZGVyZXIuZ2wuc2Npc3Nvcihib3VuZHMueCAqIHJlc29sdXRpb24sIChyZW5kZXJUYXJnZXQucm9vdCA/IHJlbmRlclRhcmdldC5zaXplLmhlaWdodCAtIGJvdW5kcy55IC0gYm91bmRzLmhlaWdodCA6IGJvdW5kcy55KSAqIHJlc29sdXRpb24sIGJvdW5kcy53aWR0aCAqIHJlc29sdXRpb24sIGJvdW5kcy5oZWlnaHQgKiByZXNvbHV0aW9uKTtcbiAgICAgICAgdGhpcy5zY2lzc29yUmVuZGVyVGFyZ2V0ID0gcmVuZGVyVGFyZ2V0O1xuICAgICAgICB0aGlzLnNjaXNzb3JEYXRhID0gbWFza0RhdGE7XG4gICAgICAgIHRoaXMuc2Npc3NvciA9IHRydWU7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBQb3Agc2Npc3NvciBtYXNrXG4gICAgICpcbiAgICAgKi9cbiAgICBwb3BTY2lzc29yTWFzayhhLCBiKSB7XG4gICAgICAgIHRoaXMuc2Npc3NvclJlbmRlclRhcmdldCA9IG51bGw7XG4gICAgICAgIHRoaXMuc2Npc3NvckRhdGEgPSBudWxsO1xuICAgICAgICB0aGlzLnNjaXNzb3IgPSBmYWxzZTtcbiAgICAgICAgLy8gbXVzdCBiZSBzY2lzc29yIVxuICAgICAgICB2YXIgcmVmID0gdGhpcy5yZW5kZXJlcjtcbiAgICAgICAgdmFyIGdsID0gcmVmLmdsO1xuICAgICAgICBnbC5kaXNhYmxlKGdsLlNDSVNTT1JfVEVTVCk7XG4gICAgfVxuICAgIDtcbn1cbmV4cG9ydHMuTWFza1N5c3RlbSA9IE1hc2tTeXN0ZW07XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNsYXNzIE1hdGhTZXR0aW5ncyB7XG4gICAgc3RhdGljIHVpZCgpIHtcbiAgICAgICAgcmV0dXJuICsrTWF0aFNldHRpbmdzLm5leHRVaWQ7XG4gICAgfVxuICAgIHN0YXRpYyBzaWduKG4pIHtcbiAgICAgICAgaWYgKG4gPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuIDwgMCA/IC0xIDogMTtcbiAgICB9XG4gICAgc3RhdGljIHN0cmluZzJoZXgoc3RyaW5nKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc3RyaW5nID09PSAnc3RyaW5nJyAmJiBzdHJpbmdbMF0gPT09ICcjJykge1xuICAgICAgICAgICAgc3RyaW5nID0gc3RyaW5nLnN1YnN0cigxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyc2VJbnQoc3RyaW5nLCAxNik7XG4gICAgfVxuICAgIHN0YXRpYyBoZXgyc3RyaW5nKGhleCkge1xuICAgICAgICBoZXggPSBoZXgudG9TdHJpbmcoMTYpO1xuICAgICAgICBoZXggPSAnMDAwMDAwJy5zdWJzdHIoMCwgNiAtIGhleC5sZW5ndGgpICsgaGV4O1xuICAgICAgICByZXR1cm4gKFwiI1wiICsgaGV4KTtcbiAgICB9XG4gICAgc3RhdGljIGxvZzIodikge1xuICAgICAgICB2YXIgciA9ICh2ID4gMHhGRkZGKSA8PCA0O1xuICAgICAgICB2ID4+Pj0gcjtcbiAgICAgICAgdmFyIHNoaWZ0ID0gKHYgPiAweEZGKSA8PCAzO1xuICAgICAgICB2ID4+Pj0gc2hpZnQ7XG4gICAgICAgIHIgfD0gc2hpZnQ7XG4gICAgICAgIHNoaWZ0ID0gKHYgPiAweEYpIDw8IDI7XG4gICAgICAgIHYgPj4+PSBzaGlmdDtcbiAgICAgICAgciB8PSBzaGlmdDtcbiAgICAgICAgc2hpZnQgPSAodiA+IDB4MykgPDwgMTtcbiAgICAgICAgdiA+Pj49IHNoaWZ0O1xuICAgICAgICByIHw9IHNoaWZ0O1xuICAgICAgICByZXR1cm4gciB8ICh2ID4+IDEpO1xuICAgIH1cbiAgICBzdGF0aWMgbmV4dFBvdzIodikge1xuICAgICAgICB2ICs9IHYgPT09IDA7XG4gICAgICAgIC0tdjtcbiAgICAgICAgdiB8PSB2ID4+PiAxO1xuICAgICAgICB2IHw9IHYgPj4+IDI7XG4gICAgICAgIHYgfD0gdiA+Pj4gNDtcbiAgICAgICAgdiB8PSB2ID4+PiA4O1xuICAgICAgICB2IHw9IHYgPj4+IDE2O1xuICAgICAgICByZXR1cm4gdiArIDE7XG4gICAgfVxuICAgIHN0YXRpYyBpc1BvdzIodikge1xuICAgICAgICByZXR1cm4gISh2ICYgKHYgLSAxKSkgJiYgKCEhdik7XG4gICAgfVxufVxuTWF0aFNldHRpbmdzLm5leHRVaWQgPSAwO1xuTWF0aFNldHRpbmdzLlBJXzIgPSBNYXRoLlBJICogMjtcbk1hdGhTZXR0aW5ncy5SQURfVE9fREVHID0gMTgwIC8gTWF0aC5QSTtcbk1hdGhTZXR0aW5ncy5ERUdfVE9fUkFEID0gTWF0aC5QSSAvIDE4MDtcbmV4cG9ydHMuTWF0aFNldHRpbmdzID0gTWF0aFNldHRpbmdzO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBQb2ludF8xID0gcmVxdWlyZShcIi4uL2ZsYXNoL2dlb20vUG9pbnRcIik7XG5jb25zdCBNYXRoU2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL01hdGhTZXR0aW5nc1wiKTtcbmNvbnN0IEZsYXNoQmFzZU9iamVjdF8xID0gcmVxdWlyZShcIi4vRmxhc2hCYXNlT2JqZWN0XCIpO1xuY2xhc3MgTWF0cml4IGV4dGVuZHMgRmxhc2hCYXNlT2JqZWN0XzEuRmxhc2hCYXNlT2JqZWN0IHtcbiAgICBjb25zdHJ1Y3RvcihhID0gMSwgYiA9IDAsIGMgPSAwLCBkID0gMSwgdHggPSAwLCB0eSA9IDApIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgaWYgKGEgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgYSA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGIgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgYiA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGMgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgYyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGQgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgZCA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR4ID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHR4ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHkgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgdHkgPSAwO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDFcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYSA9IGE7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYiA9IGI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYyA9IGM7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDFcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZCA9IGQ7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudHggPSB0eDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgMFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50eSA9IHR5O1xuICAgICAgICB0aGlzLmFycmF5ID0gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIE1hdHJpeCBvYmplY3QgYmFzZWQgb24gdGhlIGdpdmVuIGFycmF5LiBUaGUgRWxlbWVudCB0byBNYXRyaXggbWFwcGluZyBvcmRlciBpcyBhcyBmb2xsb3dzOlxuICAgICAqXG4gICAgICogYSA9IGFycmF5WzBdXG4gICAgICogYiA9IGFycmF5WzFdXG4gICAgICogYyA9IGFycmF5WzNdXG4gICAgICogZCA9IGFycmF5WzRdXG4gICAgICogdHggPSBhcnJheVsyXVxuICAgICAqIHR5ID0gYXJyYXlbNV1cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyW119IGFycmF5IC0gVGhlIGFycmF5IHRoYXQgdGhlIG1hdHJpeCB3aWxsIGJlIHBvcHVsYXRlZCBmcm9tLlxuICAgICAqL1xuICAgIGZyb21BcnJheShhcnJheSkge1xuICAgICAgICB0aGlzLmEgPSBhcnJheVswXTtcbiAgICAgICAgdGhpcy5iID0gYXJyYXlbMV07XG4gICAgICAgIHRoaXMuYyA9IGFycmF5WzNdO1xuICAgICAgICB0aGlzLmQgPSBhcnJheVs0XTtcbiAgICAgICAgdGhpcy50eCA9IGFycmF5WzJdO1xuICAgICAgICB0aGlzLnR5ID0gYXJyYXlbNV07XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBzZXRzIHRoZSBtYXRyaXggcHJvcGVydGllc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGEgLSBNYXRyaXggY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGIgLSBNYXRyaXggY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGMgLSBNYXRyaXggY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGQgLSBNYXRyaXggY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHR4IC0gTWF0cml4IGNvbXBvbmVudFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0eSAtIE1hdHJpeCBjb21wb25lbnRcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1BJWEkuTWF0cml4fSBUaGlzIG1hdHJpeC4gR29vZCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzLlxuICAgICAqL1xuICAgIHNldChhLCBiLCBjLCBkLCB0eCwgdHkpIHtcbiAgICAgICAgdGhpcy5hID0gYTtcbiAgICAgICAgdGhpcy5iID0gYjtcbiAgICAgICAgdGhpcy5jID0gYztcbiAgICAgICAgdGhpcy5kID0gZDtcbiAgICAgICAgdGhpcy50eCA9IHR4O1xuICAgICAgICB0aGlzLnR5ID0gdHk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBmcm9tIHRoZSBjdXJyZW50IE1hdHJpeCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHRyYW5zcG9zZSAtIFdoZXRoZXIgd2UgbmVlZCB0byB0cmFuc3Bvc2UgdGhlIG1hdHJpeCBvciBub3RcbiAgICAgKiBAcGFyYW0ge0Zsb2F0MzJBcnJheX0gW291dD1uZXcgRmxvYXQzMkFycmF5KDkpXSAtIElmIHByb3ZpZGVkIHRoZSBhcnJheSB3aWxsIGJlIGFzc2lnbmVkIHRvIG91dFxuICAgICAqIEByZXR1cm4ge251bWJlcltdfSB0aGUgbmV3bHkgY3JlYXRlZCBhcnJheSB3aGljaCBjb250YWlucyB0aGUgbWF0cml4XG4gICAgICovXG4gICAgdG9BcnJheSh0cmFuc3Bvc2UsIG91dCA9IG51bGwpIHtcbiAgICAgICAgaWYgKCF0aGlzLmFycmF5KSB7XG4gICAgICAgICAgICB0aGlzLmFycmF5ID0gbmV3IEZsb2F0MzJBcnJheSg5KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYXJyYXkgPSBvdXQgfHwgdGhpcy5hcnJheTtcbiAgICAgICAgaWYgKHRyYW5zcG9zZSkge1xuICAgICAgICAgICAgYXJyYXlbMF0gPSB0aGlzLmE7XG4gICAgICAgICAgICBhcnJheVsxXSA9IHRoaXMuYjtcbiAgICAgICAgICAgIGFycmF5WzJdID0gMDtcbiAgICAgICAgICAgIGFycmF5WzNdID0gdGhpcy5jO1xuICAgICAgICAgICAgYXJyYXlbNF0gPSB0aGlzLmQ7XG4gICAgICAgICAgICBhcnJheVs1XSA9IDA7XG4gICAgICAgICAgICBhcnJheVs2XSA9IHRoaXMudHg7XG4gICAgICAgICAgICBhcnJheVs3XSA9IHRoaXMudHk7XG4gICAgICAgICAgICBhcnJheVs4XSA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhcnJheVswXSA9IHRoaXMuYTtcbiAgICAgICAgICAgIGFycmF5WzFdID0gdGhpcy5jO1xuICAgICAgICAgICAgYXJyYXlbMl0gPSB0aGlzLnR4O1xuICAgICAgICAgICAgYXJyYXlbM10gPSB0aGlzLmI7XG4gICAgICAgICAgICBhcnJheVs0XSA9IHRoaXMuZDtcbiAgICAgICAgICAgIGFycmF5WzVdID0gdGhpcy50eTtcbiAgICAgICAgICAgIGFycmF5WzZdID0gMDtcbiAgICAgICAgICAgIGFycmF5WzddID0gMDtcbiAgICAgICAgICAgIGFycmF5WzhdID0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJyYXk7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBHZXQgYSBuZXcgcG9zaXRpb24gd2l0aCB0aGUgY3VycmVudCB0cmFuc2Zvcm1hdGlvbiBhcHBsaWVkLlxuICAgICAqIENhbiBiZSB1c2VkIHRvIGdvIGZyb20gYSBjaGlsZCdzIGNvb3JkaW5hdGUgc3BhY2UgdG8gdGhlIHdvcmxkIGNvb3JkaW5hdGUgc3BhY2UuIChlLmcuIHJlbmRlcmluZylcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UElYSS5Qb2ludH0gcG9zIC0gVGhlIG9yaWdpblxuICAgICAqIEBwYXJhbSB7UElYSS5Qb2ludH0gW25ld1Bvc10gLSBUaGUgcG9pbnQgdGhhdCB0aGUgbmV3IHBvc2l0aW9uIGlzIGFzc2lnbmVkIHRvIChhbGxvd2VkIHRvIGJlIHNhbWUgYXMgaW5wdXQpXG4gICAgICogQHJldHVybiB7UElYSS5Qb2ludH0gVGhlIG5ldyBwb2ludCwgdHJhbnNmb3JtZWQgdGhyb3VnaCB0aGlzIG1hdHJpeFxuICAgICAqL1xuICAgIGFwcGx5KHBvcywgbmV3UG9zKSB7XG4gICAgICAgIG5ld1BvcyA9IG5ld1BvcztcbiAgICAgICAgaWYgKCFuZXdQb3MpIHtcbiAgICAgICAgICAgIG5ld1BvcyA9IFBvaW50XzEuUG9pbnQuZ2V0UG9pbnQoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgeCA9IHBvcy54O1xuICAgICAgICB2YXIgeSA9IHBvcy55O1xuICAgICAgICBuZXdQb3MueCA9ICh0aGlzLmEgKiB4KSArICh0aGlzLmMgKiB5KSArIHRoaXMudHg7XG4gICAgICAgIG5ld1Bvcy55ID0gKHRoaXMuYiAqIHgpICsgKHRoaXMuZCAqIHkpICsgdGhpcy50eTtcbiAgICAgICAgcmV0dXJuIG5ld1BvcztcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIEdldCBhIG5ldyBwb3NpdGlvbiB3aXRoIHRoZSBpbnZlcnNlIG9mIHRoZSBjdXJyZW50IHRyYW5zZm9ybWF0aW9uIGFwcGxpZWQuXG4gICAgICogQ2FuIGJlIHVzZWQgdG8gZ28gZnJvbSB0aGUgd29ybGQgY29vcmRpbmF0ZSBzcGFjZSB0byBhIGNoaWxkJ3MgY29vcmRpbmF0ZSBzcGFjZS4gKGUuZy4gaW5wdXQpXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BJWEkuUG9pbnR9IHBvcyAtIFRoZSBvcmlnaW5cbiAgICAgKiBAcGFyYW0ge1BJWEkuUG9pbnR9IFtuZXdQb3NdIC0gVGhlIHBvaW50IHRoYXQgdGhlIG5ldyBwb3NpdGlvbiBpcyBhc3NpZ25lZCB0byAoYWxsb3dlZCB0byBiZSBzYW1lIGFzIGlucHV0KVxuICAgICAqIEByZXR1cm4ge1BJWEkuUG9pbnR9IFRoZSBuZXcgcG9pbnQsIGludmVyc2UtdHJhbnNmb3JtZWQgdGhyb3VnaCB0aGlzIG1hdHJpeFxuICAgICAqL1xuICAgIGFwcGx5SW52ZXJzZShwb3MsIG5ld1Bvcykge1xuICAgICAgICBuZXdQb3MgPSBuZXdQb3M7XG4gICAgICAgIGlmICghbmV3UG9zKSB7XG4gICAgICAgICAgICBuZXdQb3MgPSBQb2ludF8xLlBvaW50LmdldFBvaW50KCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGlkID0gMSAvICgodGhpcy5hICogdGhpcy5kKSArICh0aGlzLmMgKiAtdGhpcy5iKSk7XG4gICAgICAgIHZhciB4ID0gcG9zLng7XG4gICAgICAgIHZhciB5ID0gcG9zLnk7XG4gICAgICAgIG5ld1Bvcy54ID0gKHRoaXMuZCAqIGlkICogeCkgKyAoLXRoaXMuYyAqIGlkICogeSkgKyAoKCh0aGlzLnR5ICogdGhpcy5jKSAtICh0aGlzLnR4ICogdGhpcy5kKSkgKiBpZCk7XG4gICAgICAgIG5ld1Bvcy55ID0gKHRoaXMuYSAqIGlkICogeSkgKyAoLXRoaXMuYiAqIGlkICogeCkgKyAoKCgtdGhpcy50eSAqIHRoaXMuYSkgKyAodGhpcy50eCAqIHRoaXMuYikpICogaWQpO1xuICAgICAgICByZXR1cm4gbmV3UG9zO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogVHJhbnNsYXRlcyB0aGUgbWF0cml4IG9uIHRoZSB4IGFuZCB5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggSG93IG11Y2ggdG8gdHJhbnNsYXRlIHggYnlcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSBIb3cgbXVjaCB0byB0cmFuc2xhdGUgeSBieVxuICAgICAqIEByZXR1cm4ge1BJWEkuTWF0cml4fSBUaGlzIG1hdHJpeC4gR29vZCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzLlxuICAgICAqL1xuICAgIHRyYW5zbGF0ZSh4LCB5KSB7XG4gICAgICAgIHRoaXMudHggKz0geDtcbiAgICAgICAgdGhpcy50eSArPSB5O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgYSBzY2FsZSB0cmFuc2Zvcm1hdGlvbiB0byB0aGUgbWF0cml4LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggVGhlIGFtb3VudCB0byBzY2FsZSBob3Jpem9udGFsbHlcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSBUaGUgYW1vdW50IHRvIHNjYWxlIHZlcnRpY2FsbHlcbiAgICAgKiBAcmV0dXJuIHtQSVhJLk1hdHJpeH0gVGhpcyBtYXRyaXguIEdvb2QgZm9yIGNoYWluaW5nIG1ldGhvZCBjYWxscy5cbiAgICAgKi9cbiAgICBzY2FsZSh4LCB5KSB7XG4gICAgICAgIHRoaXMuYSAqPSB4O1xuICAgICAgICB0aGlzLmQgKj0geTtcbiAgICAgICAgdGhpcy5jICo9IHg7XG4gICAgICAgIHRoaXMuYiAqPSB5O1xuICAgICAgICB0aGlzLnR4ICo9IHg7XG4gICAgICAgIHRoaXMudHkgKj0geTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIGEgcm90YXRpb24gdHJhbnNmb3JtYXRpb24gdG8gdGhlIG1hdHJpeC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhbmdsZSAtIFRoZSBhbmdsZSBpbiByYWRpYW5zLlxuICAgICAqIEByZXR1cm4ge1BJWEkuTWF0cml4fSBUaGlzIG1hdHJpeC4gR29vZCBmb3IgY2hhaW5pbmcgbWV0aG9kIGNhbGxzLlxuICAgICAqL1xuICAgIHJvdGF0ZShhbmdsZSkge1xuICAgICAgICB2YXIgY29zID0gTWF0aC5jb3MoYW5nbGUpO1xuICAgICAgICB2YXIgc2luID0gTWF0aC5zaW4oYW5nbGUpO1xuICAgICAgICB2YXIgYTEgPSB0aGlzLmE7XG4gICAgICAgIHZhciBjMSA9IHRoaXMuYztcbiAgICAgICAgdmFyIHR4MSA9IHRoaXMudHg7XG4gICAgICAgIHRoaXMuYSA9IChhMSAqIGNvcykgLSAodGhpcy5iICogc2luKTtcbiAgICAgICAgdGhpcy5iID0gKGExICogc2luKSArICh0aGlzLmIgKiBjb3MpO1xuICAgICAgICB0aGlzLmMgPSAoYzEgKiBjb3MpIC0gKHRoaXMuZCAqIHNpbik7XG4gICAgICAgIHRoaXMuZCA9IChjMSAqIHNpbikgKyAodGhpcy5kICogY29zKTtcbiAgICAgICAgdGhpcy50eCA9ICh0eDEgKiBjb3MpIC0gKHRoaXMudHkgKiBzaW4pO1xuICAgICAgICB0aGlzLnR5ID0gKHR4MSAqIHNpbikgKyAodGhpcy50eSAqIGNvcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogQXBwZW5kcyB0aGUgZ2l2ZW4gTWF0cml4IHRvIHRoaXMgTWF0cml4LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQSVhJLk1hdHJpeH0gbWF0cml4IC0gVGhlIG1hdHJpeCB0byBhcHBlbmQuXG4gICAgICogQHJldHVybiB7UElYSS5NYXRyaXh9IFRoaXMgbWF0cml4LiBHb29kIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHMuXG4gICAgICovXG4gICAgYXBwZW5kKG1hdHJpeCkge1xuICAgICAgICB2YXIgYTEgPSB0aGlzLmE7XG4gICAgICAgIHZhciBiMSA9IHRoaXMuYjtcbiAgICAgICAgdmFyIGMxID0gdGhpcy5jO1xuICAgICAgICB2YXIgZDEgPSB0aGlzLmQ7XG4gICAgICAgIHRoaXMuYSA9IChtYXRyaXguYSAqIGExKSArIChtYXRyaXguYiAqIGMxKTtcbiAgICAgICAgdGhpcy5iID0gKG1hdHJpeC5hICogYjEpICsgKG1hdHJpeC5iICogZDEpO1xuICAgICAgICB0aGlzLmMgPSAobWF0cml4LmMgKiBhMSkgKyAobWF0cml4LmQgKiBjMSk7XG4gICAgICAgIHRoaXMuZCA9IChtYXRyaXguYyAqIGIxKSArIChtYXRyaXguZCAqIGQxKTtcbiAgICAgICAgdGhpcy50eCA9IChtYXRyaXgudHggKiBhMSkgKyAobWF0cml4LnR5ICogYzEpICsgdGhpcy50eDtcbiAgICAgICAgdGhpcy50eSA9IChtYXRyaXgudHggKiBiMSkgKyAobWF0cml4LnR5ICogZDEpICsgdGhpcy50eTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBtYXRyaXggYmFzZWQgb24gYWxsIHRoZSBhdmFpbGFibGUgcHJvcGVydGllc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggLSBQb3NpdGlvbiBvbiB0aGUgeCBheGlzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgLSBQb3NpdGlvbiBvbiB0aGUgeSBheGlzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHBpdm90WCAtIFBpdm90IG9uIHRoZSB4IGF4aXNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcGl2b3RZIC0gUGl2b3Qgb24gdGhlIHkgYXhpc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzY2FsZVggLSBTY2FsZSBvbiB0aGUgeCBheGlzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNjYWxlWSAtIFNjYWxlIG9uIHRoZSB5IGF4aXNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcm90YXRpb24gLSBSb3RhdGlvbiBpbiByYWRpYW5zXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNrZXdYIC0gU2tldyBvbiB0aGUgeCBheGlzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNrZXdZIC0gU2tldyBvbiB0aGUgeSBheGlzXG4gICAgICogQHJldHVybiB7UElYSS5NYXRyaXh9IFRoaXMgbWF0cml4LiBHb29kIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHMuXG4gICAgICovXG4gICAgc2V0VHJhbnNmb3JtKHgsIHksIHBpdm90WCwgcGl2b3RZLCBzY2FsZVgsIHNjYWxlWSwgcm90YXRpb24sIHNrZXdYLCBza2V3WSkge1xuICAgICAgICB0aGlzLmEgPSBNYXRoLmNvcyhyb3RhdGlvbiArIHNrZXdZKSAqIHNjYWxlWDtcbiAgICAgICAgdGhpcy5iID0gTWF0aC5zaW4ocm90YXRpb24gKyBza2V3WSkgKiBzY2FsZVg7XG4gICAgICAgIHRoaXMuYyA9IC1NYXRoLnNpbihyb3RhdGlvbiAtIHNrZXdYKSAqIHNjYWxlWTtcbiAgICAgICAgdGhpcy5kID0gTWF0aC5jb3Mocm90YXRpb24gLSBza2V3WCkgKiBzY2FsZVk7XG4gICAgICAgIHRoaXMudHggPSB4IC0gKChwaXZvdFggKiB0aGlzLmEpICsgKHBpdm90WSAqIHRoaXMuYykpO1xuICAgICAgICB0aGlzLnR5ID0geSAtICgocGl2b3RYICogdGhpcy5iKSArIChwaXZvdFkgKiB0aGlzLmQpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBQcmVwZW5kcyB0aGUgZ2l2ZW4gTWF0cml4IHRvIHRoaXMgTWF0cml4LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQSVhJLk1hdHJpeH0gbWF0cml4IC0gVGhlIG1hdHJpeCB0byBwcmVwZW5kXG4gICAgICogQHJldHVybiB7UElYSS5NYXRyaXh9IFRoaXMgbWF0cml4LiBHb29kIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHMuXG4gICAgICovXG4gICAgcHJlcGVuZChtYXRyaXgpIHtcbiAgICAgICAgdmFyIHR4MSA9IHRoaXMudHg7XG4gICAgICAgIGlmIChtYXRyaXguYSAhPT0gMSB8fCBtYXRyaXguYiAhPT0gMCB8fCBtYXRyaXguYyAhPT0gMCB8fCBtYXRyaXguZCAhPT0gMSkge1xuICAgICAgICAgICAgdmFyIGExID0gdGhpcy5hO1xuICAgICAgICAgICAgdmFyIGMxID0gdGhpcy5jO1xuICAgICAgICAgICAgdGhpcy5hID0gKGExICogbWF0cml4LmEpICsgKHRoaXMuYiAqIG1hdHJpeC5jKTtcbiAgICAgICAgICAgIHRoaXMuYiA9IChhMSAqIG1hdHJpeC5iKSArICh0aGlzLmIgKiBtYXRyaXguZCk7XG4gICAgICAgICAgICB0aGlzLmMgPSAoYzEgKiBtYXRyaXguYSkgKyAodGhpcy5kICogbWF0cml4LmMpO1xuICAgICAgICAgICAgdGhpcy5kID0gKGMxICogbWF0cml4LmIpICsgKHRoaXMuZCAqIG1hdHJpeC5kKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnR4ID0gKHR4MSAqIG1hdHJpeC5hKSArICh0aGlzLnR5ICogbWF0cml4LmMpICsgbWF0cml4LnR4O1xuICAgICAgICB0aGlzLnR5ID0gKHR4MSAqIG1hdHJpeC5iKSArICh0aGlzLnR5ICogbWF0cml4LmQpICsgbWF0cml4LnR5O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIERlY29tcG9zZXMgdGhlIG1hdHJpeCAoeCwgeSwgc2NhbGVYLCBzY2FsZVksIGFuZCByb3RhdGlvbikgYW5kIHNldHMgdGhlIHByb3BlcnRpZXMgb24gdG8gYSB0cmFuc2Zvcm0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BJWEkuVHJhbnNmb3JtfSB0cmFuc2Zvcm0gLSBUaGUgdHJhbnNmb3JtIHRvIGFwcGx5IHRoZSBwcm9wZXJ0aWVzIHRvLlxuICAgICAqIEByZXR1cm4ge1BJWEkuVHJhbnNmb3JtfSBUaGUgdHJhbnNmb3JtIHdpdGggdGhlIG5ld2x5IGFwcGxpZWQgcHJvcGVydGllc1xuICAgICAqL1xuICAgIGRlY29tcG9zZSh0cmFuc2Zvcm0pIHtcbiAgICAgICAgLy8gc29ydCBvdXQgcm90YXRpb24gLyBza2V3Li5cbiAgICAgICAgdmFyIGEgPSB0aGlzLmE7XG4gICAgICAgIHZhciBiID0gdGhpcy5iO1xuICAgICAgICB2YXIgYyA9IHRoaXMuYztcbiAgICAgICAgdmFyIGQgPSB0aGlzLmQ7XG4gICAgICAgIHZhciBza2V3WCA9IC1NYXRoLmF0YW4yKC1jLCBkKTtcbiAgICAgICAgdmFyIHNrZXdZID0gTWF0aC5hdGFuMihiLCBhKTtcbiAgICAgICAgdmFyIGRlbHRhID0gTWF0aC5hYnMoc2tld1ggKyBza2V3WSk7XG4gICAgICAgIGlmIChkZWx0YSA8IDAuMDAwMDEgfHwgTWF0aC5hYnMoTWF0aFNldHRpbmdzXzEuTWF0aFNldHRpbmdzLlBJXzIgLSBkZWx0YSkgPCAwLjAwMDAxKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm0ucm90YXRpb24gPSBza2V3WTtcbiAgICAgICAgICAgIHRyYW5zZm9ybS5za2V3LnggPSB0cmFuc2Zvcm0uc2tldy55ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybS5yb3RhdGlvbiA9IDA7XG4gICAgICAgICAgICB0cmFuc2Zvcm0uc2tldy54ID0gc2tld1g7XG4gICAgICAgICAgICB0cmFuc2Zvcm0uc2tldy55ID0gc2tld1k7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbmV4dCBzZXQgc2NhbGVcbiAgICAgICAgdHJhbnNmb3JtLnNjYWxlLnggPSBNYXRoLnNxcnQoKGEgKiBhKSArIChiICogYikpO1xuICAgICAgICB0cmFuc2Zvcm0uc2NhbGUueSA9IE1hdGguc3FydCgoYyAqIGMpICsgKGQgKiBkKSk7XG4gICAgICAgIC8vIG5leHQgc2V0IHBvc2l0aW9uXG4gICAgICAgIHRyYW5zZm9ybS5wb3NpdGlvbi54ID0gdGhpcy50eDtcbiAgICAgICAgdHJhbnNmb3JtLnBvc2l0aW9uLnkgPSB0aGlzLnR5O1xuICAgICAgICByZXR1cm4gdHJhbnNmb3JtO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogSW52ZXJ0cyB0aGlzIG1hdHJpeFxuICAgICAqXG4gICAgICogQHJldHVybiB7UElYSS5NYXRyaXh9IFRoaXMgbWF0cml4LiBHb29kIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHMuXG4gICAgICovXG4gICAgaW52ZXJ0KCkge1xuICAgICAgICB2YXIgYTEgPSB0aGlzLmE7XG4gICAgICAgIHZhciBiMSA9IHRoaXMuYjtcbiAgICAgICAgdmFyIGMxID0gdGhpcy5jO1xuICAgICAgICB2YXIgZDEgPSB0aGlzLmQ7XG4gICAgICAgIHZhciB0eDEgPSB0aGlzLnR4O1xuICAgICAgICB2YXIgbiA9IChhMSAqIGQxKSAtIChiMSAqIGMxKTtcbiAgICAgICAgdGhpcy5hID0gZDEgLyBuO1xuICAgICAgICB0aGlzLmIgPSAtYjEgLyBuO1xuICAgICAgICB0aGlzLmMgPSAtYzEgLyBuO1xuICAgICAgICB0aGlzLmQgPSBhMSAvIG47XG4gICAgICAgIHRoaXMudHggPSAoKGMxICogdGhpcy50eSkgLSAoZDEgKiB0eDEpKSAvIG47XG4gICAgICAgIHRoaXMudHkgPSAtKChhMSAqIHRoaXMudHkpIC0gKGIxICogdHgxKSkgLyBuO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFJlc2V0cyB0aGlzIE1hdHJpeCB0byBhbiBpZGVudGl0eSAoZGVmYXVsdCkgbWF0cml4LlxuICAgICAqXG4gICAgICogQHJldHVybiB7UElYSS5NYXRyaXh9IFRoaXMgbWF0cml4LiBHb29kIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHMuXG4gICAgICovXG4gICAgaWRlbnRpdHkoKSB7XG4gICAgICAgIHRoaXMuYSA9IDE7XG4gICAgICAgIHRoaXMuYiA9IDA7XG4gICAgICAgIHRoaXMuYyA9IDA7XG4gICAgICAgIHRoaXMuZCA9IDE7XG4gICAgICAgIHRoaXMudHggPSAwO1xuICAgICAgICB0aGlzLnR5ID0gMDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IE1hdHJpeCBvYmplY3Qgd2l0aCB0aGUgc2FtZSB2YWx1ZXMgYXMgdGhpcyBvbmUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtQSVhJLk1hdHJpeH0gQSBjb3B5IG9mIHRoaXMgbWF0cml4LiBHb29kIGZvciBjaGFpbmluZyBtZXRob2QgY2FsbHMuXG4gICAgICovXG4gICAgY2xvbmUoKSB7XG4gICAgICAgIHZhciBtYXRyaXggPSBuZXcgTWF0cml4KCk7XG4gICAgICAgIG1hdHJpeC5hID0gdGhpcy5hO1xuICAgICAgICBtYXRyaXguYiA9IHRoaXMuYjtcbiAgICAgICAgbWF0cml4LmMgPSB0aGlzLmM7XG4gICAgICAgIG1hdHJpeC5kID0gdGhpcy5kO1xuICAgICAgICBtYXRyaXgudHggPSB0aGlzLnR4O1xuICAgICAgICBtYXRyaXgudHkgPSB0aGlzLnR5O1xuICAgICAgICByZXR1cm4gbWF0cml4O1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogQ2hhbmdlcyB0aGUgdmFsdWVzIG9mIHRoZSBnaXZlbiBtYXRyaXggdG8gYmUgdGhlIHNhbWUgYXMgdGhlIG9uZXMgaW4gdGhpcyBtYXRyaXhcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UElYSS5NYXRyaXh9IG1hdHJpeCAtIFRoZSBtYXRyaXggdG8gY29weSB0by5cbiAgICAgKiBAcmV0dXJuIHtQSVhJLk1hdHJpeH0gVGhlIG1hdHJpeCBnaXZlbiBpbiBwYXJhbWV0ZXIgd2l0aCBpdHMgdmFsdWVzIHVwZGF0ZWQuXG4gICAgICovXG4gICAgY29weVRvKG1hdHJpeCkge1xuICAgICAgICBtYXRyaXguYSA9IHRoaXMuYTtcbiAgICAgICAgbWF0cml4LmIgPSB0aGlzLmI7XG4gICAgICAgIG1hdHJpeC5jID0gdGhpcy5jO1xuICAgICAgICBtYXRyaXguZCA9IHRoaXMuZDtcbiAgICAgICAgbWF0cml4LnR4ID0gdGhpcy50eDtcbiAgICAgICAgbWF0cml4LnR5ID0gdGhpcy50eTtcbiAgICAgICAgcmV0dXJuIG1hdHJpeDtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIENoYW5nZXMgdGhlIHZhbHVlcyBvZiB0aGUgbWF0cml4IHRvIGJlIHRoZSBzYW1lIGFzIHRoZSBvbmVzIGluIGdpdmVuIG1hdHJpeFxuICAgICAqXG4gICAgICogQHBhcmFtIHtQSVhJLk1hdHJpeH0gbWF0cml4IC0gVGhlIG1hdHJpeCB0byBjb3B5IGZyb20uXG4gICAgICogQHJldHVybiB7UElYSS5NYXRyaXh9IHRoaXNcbiAgICAgKi9cbiAgICBjb3B5RnJvbShtYXRyaXgpIHtcbiAgICAgICAgdGhpcy5hID0gbWF0cml4LmE7XG4gICAgICAgIHRoaXMuYiA9IG1hdHJpeC5iO1xuICAgICAgICB0aGlzLmMgPSBtYXRyaXguYztcbiAgICAgICAgdGhpcy5kID0gbWF0cml4LmQ7XG4gICAgICAgIHRoaXMudHggPSBtYXRyaXgudHg7XG4gICAgICAgIHRoaXMudHkgPSBtYXRyaXgudHk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogQSBkZWZhdWx0IChpZGVudGl0eSkgbWF0cml4XG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQGNvbnN0XG4gICAgICogQG1lbWJlciB7UElYSS5NYXRyaXh9XG4gICAgICovXG4gICAgc3RhdGljIGdldCBJREVOVElUWSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNYXRyaXgoKTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIEEgdGVtcCBtYXRyaXhcbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAY29uc3RcbiAgICAgKiBAbWVtYmVyIHtQSVhJLk1hdHJpeH1cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0IFRFTVBfTUFUUklYKCkge1xuICAgICAgICByZXR1cm4gbmV3IE1hdHJpeCgpO1xuICAgIH1cbiAgICA7XG59XG5leHBvcnRzLk1hdHJpeCA9IE1hdHJpeDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgQ29udGFpbmVyXzEgPSByZXF1aXJlKFwiLi9Db250YWluZXJcIik7XG5jb25zdCBTdGF0ZV8xID0gcmVxdWlyZShcIi4vU3RhdGVcIik7XG5jb25zdCBQb2x5Z29uXzEgPSByZXF1aXJlKFwiLi9Qb2x5Z29uXCIpO1xuY29uc3QgTWVzaEJhdGNoVXZzXzEgPSByZXF1aXJlKFwiLi9NZXNoQmF0Y2hVdnNcIik7XG5jb25zdCBQb2ludF8xID0gcmVxdWlyZShcIi4uL2ZsYXNoL2dlb20vUG9pbnRcIik7XG5jb25zdCBEcmF3TW9kZVNldHRpbmdzXzEgPSByZXF1aXJlKFwiLi9EcmF3TW9kZVNldHRpbmdzXCIpO1xuY29uc3QgQmxlbmRNb2Rlc1NldHRpbmdzXzEgPSByZXF1aXJlKFwiLi9CbGVuZE1vZGVzU2V0dGluZ3NcIik7XG5jb25zdCBEaXNwbGF5U2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL0Rpc3BsYXlTZXR0aW5nc1wiKTtcbmNsYXNzIE1lc2ggZXh0ZW5kcyBDb250YWluZXJfMS5Db250YWluZXIge1xuICAgIGNvbnN0cnVjdG9yKGdlb21ldHJ5LCBzaGFkZXIsIHN0YXRlID0gbnVsbCwgZHJhd01vZGUgPSBEcmF3TW9kZVNldHRpbmdzXzEuRHJhd01vZGVTZXR0aW5ncy5EUkFXX01PREVTLlRSSUFOR0xFUykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmludGVyYWN0aXZlID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbmNsdWRlcyB2ZXJ0ZXggcG9zaXRpb25zLCBmYWNlIGluZGljZXMsIG5vcm1hbHMsIGNvbG9ycywgVVZzLCBhbmRcbiAgICAgICAgICogY3VzdG9tIGF0dHJpYnV0ZXMgd2l0aGluIGJ1ZmZlcnMsIHJlZHVjaW5nIHRoZSBjb3N0IG9mIHBhc3NpbmcgYWxsXG4gICAgICAgICAqIHRoaXMgZGF0YSB0byB0aGUgR1BVLiBDYW4gYmUgc2hhcmVkIGJldHdlZW4gbXVsdGlwbGUgTWVzaCBvYmplY3RzLlxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLkdlb21ldHJ5fVxuICAgICAgICAgKiBAcmVhZG9ubHlcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZ2VvbWV0cnkgPSBnZW9tZXRyeTtcbiAgICAgICAgZ2VvbWV0cnkucmVmQ291bnQrKztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlcHJlc2VudHMgdGhlIHZlcnRleCBhbmQgZnJhZ21lbnQgc2hhZGVycyB0aGF0IHByb2Nlc3NlcyB0aGUgZ2VvbWV0cnkgYW5kIHJ1bnMgb24gdGhlIEdQVS5cbiAgICAgICAgICogQ2FuIGJlIHNoYXJlZCBiZXR3ZWVuIG11bHRpcGxlIE1lc2ggb2JqZWN0cy5cbiAgICAgICAgICogQG1lbWJlciB7UElYSS5TaGFkZXJ8UElYSS5NZXNoTWF0ZXJpYWx9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNoYWRlciA9IHNoYWRlcjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlcHJlc2VudHMgdGhlIFdlYkdMIHN0YXRlIHRoZSBNZXNoIHJlcXVpcmVkIHRvIHJlbmRlciwgZXhjbHVkZXMgc2hhZGVyIGFuZCBnZW9tZXRyeS4gRS5nLixcbiAgICAgICAgICogYmxlbmQgbW9kZSwgY3VsbGluZywgZGVwdGggdGVzdGluZywgZGlyZWN0aW9uIG9mIHJlbmRlcmluZyB0cmlhbmdsZXMsIGJhY2tmYWNlLCBldGMuXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuU3RhdGV9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0YXRlID0gc3RhdGUgfHwgU3RhdGVfMS5TdGF0ZS5mb3IyZCgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHdheSB0aGUgTWVzaCBzaG91bGQgYmUgZHJhd24sIGNhbiBiZSBhbnkgb2YgdGhlIHtAbGluayBQSVhJLkRSQVdfTU9ERVN9IGNvbnN0YW50cy5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKiBAc2VlIFBJWEkuRFJBV19NT0RFU1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kcmF3TW9kZSA9IGRyYXdNb2RlO1xuICAgICAgICAvKipcbiAgICAgICAgICogVHlwaWNhbGx5IHRoZSBpbmRleCBvZiB0aGUgSW5kZXhCdWZmZXIgd2hlcmUgdG8gc3RhcnQgZHJhd2luZy5cbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAwXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0YXJ0ID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEhvdyBtdWNoIG9mIHRoZSBnZW9tZXRyeSB0byBkcmF3LCBieSBkZWZhdWx0IGAwYCByZW5kZXJzIGV2ZXJ5dGhpbmcuXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgMFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zaXplID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHRoZWFzZSBhcmUgdXNlZCBhcyBlYXN5IGFjY2VzcyBmb3IgYmF0Y2hpbmdcbiAgICAgICAgICogQG1lbWJlciB7RmxvYXQzMkFycmF5fVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy51dnMgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogdGhlYXNlIGFyZSB1c2VkIGFzIGVhc3kgYWNjZXNzIGZvciBiYXRjaGluZ1xuICAgICAgICAgKiBAbWVtYmVyIHtVaW50MTZBcnJheX1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaW5kaWNlcyA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiB0aGlzIGlzIHRoZSBjYWNoaW5nIGxheWVyIHVzZWQgYnkgdGhlIGJhdGNoZXJcbiAgICAgICAgICogQG1lbWJlciB7RmxvYXQzMkFycmF5fVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy52ZXJ0ZXhEYXRhID0gbmV3IEZsb2F0MzJBcnJheSgxKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIGdlb21ldHJ5IGlzIGNoYW5nZWQgdXNlZCB0byBkZWNpZGUgdG8gcmUtdHJhbnNmb3JtXG4gICAgICAgICAqIHRoZSB2ZXJ0ZXhEYXRhLlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnZlcnRleERpcnR5ID0gMDtcbiAgICAgICAgdGhpcy5fdHJhbnNmb3JtSUQgPSAtMTtcbiAgICAgICAgLy8gSW5oZXJpdGVkIGZyb20gRGlzcGxheU1vZGUsIHNldCBkZWZhdWx0c1xuICAgICAgICB0aGlzLnRpbnQgPSAweEZGRkZGRjtcbiAgICAgICAgdGhpcy5ibGVuZE1vZGUgPSBCbGVuZE1vZGVzU2V0dGluZ3NfMS5CbGVuZE1vZGVzU2V0dGluZ3MuQkxFTkRfTU9ERVMuTk9STUFMO1xuICAgICAgICAvKipcbiAgICAgICAgICogSW50ZXJuYWwgcm91bmRQaXhlbHMgZmllbGRcbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3JvdW5kUGl4ZWxzID0gRGlzcGxheVNldHRpbmdzXzEuRGlzcGxheVNldHRpbmdzLlJPVU5EX1BJWEVMUztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJhdGNoZWQgVVYncyBhcmUgY2FjaGVkIGZvciBhdGxhcyB0ZXh0dXJlc1xuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLk1lc2hCYXRjaFV2c31cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYmF0Y2hVdnMgPSBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUbyBjaGFuZ2UgbWVzaCB1didzLCBjaGFuZ2UgaXRzIHV2QnVmZmVyIGRhdGEgYW5kIGluY3JlbWVudCBpdHMgX3VwZGF0ZUlELlxuICAgICAqIEBtZW1iZXIge1BJWEkuQnVmZmVyfVxuICAgICAqIEByZWFkb25seVxuICAgICAqL1xuICAgIGdldCB1dkJ1ZmZlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2VvbWV0cnkuYnVmZmVyc1sxXS5kYXRhO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogVG8gY2hhbmdlIG1lc2ggdmVydGljZXMsIGNoYW5nZSBpdHMgdXZCdWZmZXIgZGF0YSBhbmQgaW5jcmVtZW50IGl0cyBfdXBkYXRlSUQuXG4gICAgICogSW5jcmVtZW50aW5nIF91cGRhdGVJRCBpcyBvcHRpb25hbCBiZWNhdXNlIG1vc3Qgb2YgTWVzaCBvYmplY3RzIGRvIGl0IGFueXdheS5cbiAgICAgKiBAbWVtYmVyIHtQSVhJLkJ1ZmZlcn1cbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKi9cbiAgICBnZXQgdmVydGljZXNCdWZmZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdlb21ldHJ5LmJ1ZmZlcnNbMF0uZGF0YTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIEFsaWFzIGZvciB7QGxpbmsgUElYSS5NZXNoI3NoYWRlcn0uXG4gICAgICogQG1lbWJlciB7UElYSS5TaGFkZXJ8UElYSS5NZXNoTWF0ZXJpYWx9XG4gICAgICovXG4gICAgc2V0IG1hdGVyaWFsKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuc2hhZGVyID0gdmFsdWU7XG4gICAgfVxuICAgIDtcbiAgICBnZXQgbWF0ZXJpYWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNoYWRlcjtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFRoZSBibGVuZCBtb2RlIHRvIGJlIGFwcGxpZWQgdG8gdGhlIE1lc2guIEFwcGx5IGEgdmFsdWUgb2ZcbiAgICAgKiBgUElYSS5CTEVORF9NT0RFUy5OT1JNQUxgIHRvIHJlc2V0IHRoZSBibGVuZCBtb2RlLlxuICAgICAqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IFBJWEkuQkxFTkRfTU9ERVMuTk9STUFMO1xuICAgICAqIEBzZWUgUElYSS5CTEVORF9NT0RFU1xuICAgICAqL1xuICAgIHNldCBibGVuZE1vZGUodmFsdWUpIHtcbiAgICAgICAgdGhpcy5zdGF0ZS5ibGVuZE1vZGUgPSB2YWx1ZTtcbiAgICB9XG4gICAgO1xuICAgIGdldCBibGVuZE1vZGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLmJsZW5kTW9kZTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIElmIHRydWUgUGl4aUpTIHdpbGwgTWF0aC5mbG9vcigpIHgveSB2YWx1ZXMgd2hlbiByZW5kZXJpbmcsIHN0b3BwaW5nIHBpeGVsIGludGVycG9sYXRpb24uXG4gICAgICogQWR2YW50YWdlcyBjYW4gaW5jbHVkZSBzaGFycGVyIGltYWdlIHF1YWxpdHkgKGxpa2UgdGV4dCkgYW5kIGZhc3RlciByZW5kZXJpbmcgb24gY2FudmFzLlxuICAgICAqIFRoZSBtYWluIGRpc2FkdmFudGFnZSBpcyBtb3ZlbWVudCBvZiBvYmplY3RzIG1heSBhcHBlYXIgbGVzcyBzbW9vdGguXG4gICAgICogVG8gc2V0IHRoZSBnbG9iYWwgZGVmYXVsdCwgY2hhbmdlIHtAbGluayBQSVhJLnNldHRpbmdzLlJPVU5EX1BJWEVMU31cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKi9cbiAgICBzZXQgcm91bmRQaXhlbHModmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuX3JvdW5kUGl4ZWxzICE9PSB2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fdHJhbnNmb3JtSUQgPSAtMTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9yb3VuZFBpeGVscyA9IHZhbHVlO1xuICAgIH1cbiAgICA7XG4gICAgZ2V0IHJvdW5kUGl4ZWxzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcm91bmRQaXhlbHM7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBUaGUgbXVsdGlwbHkgdGludCBhcHBsaWVkIHRvIHRoZSBNZXNoLiBUaGlzIGlzIGEgaGV4IHZhbHVlLiBBIHZhbHVlIG9mXG4gICAgICogYDB4RkZGRkZGYCB3aWxsIHJlbW92ZSBhbnkgdGludCBlZmZlY3QuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMHhGRkZGRkZcbiAgICAgKi9cbiAgICBnZXQgdGludCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2hhZGVyLnRpbnQ7XG4gICAgfVxuICAgIDtcbiAgICBzZXQgdGludCh2YWx1ZSkge1xuICAgICAgICB0aGlzLnNoYWRlci50aW50ID0gdmFsdWU7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBUaGUgdGV4dHVyZSB0aGF0IHRoZSBNZXNoIHVzZXMuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtQSVhJLlRleHR1cmV9XG4gICAgICovXG4gICAgZ2V0IHRleHR1cmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNoYWRlci50ZXh0dXJlO1xuICAgIH1cbiAgICA7XG4gICAgc2V0IHRleHR1cmUodmFsdWUpIHtcbiAgICAgICAgdGhpcy5zaGFkZXIudGV4dHVyZSA9IHZhbHVlO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogU3RhbmRhcmQgcmVuZGVyZXIgZHJhdy5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX3JlbmRlcihyZW5kZXJlcikge1xuICAgICAgICAvLyBzZXQgcHJvcGVydGllcyBmb3IgYmF0Y2hpbmcuLlxuICAgICAgICAvLyBUT0RPIGNvdWxkIHVzZSBhIGRpZmZlcmVudCB3YXkgdG8gZ3JhYiB2ZXJ0cz9cbiAgICAgICAgdmFyIHZlcnRpY2VzID0gdGhpcy5nZW9tZXRyeS5idWZmZXJzWzBdLmRhdGE7XG4gICAgICAgIC8vIFRPRE8gYmVuY2htYXJrIGNoZWNrIGZvciBhdHRyaWJ1dGUgc2l6ZS4uXG4gICAgICAgIGlmICh0aGlzLnNoYWRlci5iYXRjaGFibGUgJiYgdGhpcy5kcmF3TW9kZSA9PT0gRHJhd01vZGVTZXR0aW5nc18xLkRyYXdNb2RlU2V0dGluZ3MuRFJBV19NT0RFUy5UUklBTkdMRVMgJiYgdmVydGljZXMubGVuZ3RoIDwgTWVzaC5CQVRDSEFCTEVfU0laRSAqIDIpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlclRvQmF0Y2gocmVuZGVyZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyRGVmYXVsdChyZW5kZXJlcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFN0YW5kYXJkIG5vbi1iYXRjaGluZyB3YXkgb2YgcmVuZGVyaW5nLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAcGFyYW0ge1BJWEkuUmVuZGVyZXJ9IHJlbmRlcmVyIC0gSW5zdGFuY2UgdG8gcmVuZGVyZXIuXG4gICAgICovXG4gICAgX3JlbmRlckRlZmF1bHQocmVuZGVyZXIpIHtcbiAgICAgICAgdmFyIHNoYWRlciA9IHRoaXMuc2hhZGVyO1xuICAgICAgICBzaGFkZXIuYWxwaGEgPSB0aGlzLndvcmxkQWxwaGE7XG4gICAgICAgIGlmIChzaGFkZXIudXBkYXRlKSB7XG4gICAgICAgICAgICBzaGFkZXIudXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmVuZGVyZXIuYmF0Y2guZmx1c2goKTtcbiAgICAgICAgaWYgKHNoYWRlci5wcm9ncmFtLnVuaWZvcm1EYXRhLnRyYW5zbGF0aW9uTWF0cml4KSB7XG4gICAgICAgICAgICBzaGFkZXIudW5pZm9ybXMudHJhbnNsYXRpb25NYXRyaXggPSB0aGlzLnRyYW5zZm9ybS53b3JsZFRyYW5zZm9ybS50b0FycmF5KHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGJpbmQgYW5kIHN5bmMgdW5pZm9ybXMuLlxuICAgICAgICByZW5kZXJlci5zaGFkZXIuYmluZChzaGFkZXIpO1xuICAgICAgICAvLyBzZXQgc3RhdGUuLlxuICAgICAgICByZW5kZXJlci5zdGF0ZS5zZXRTdGF0ZSh0aGlzLnN0YXRlKTtcbiAgICAgICAgLy8gYmluZCB0aGUgZ2VvbWV0cnkuLi5cbiAgICAgICAgcmVuZGVyZXIuZ2VvbWV0cnkuYmluZCh0aGlzLmdlb21ldHJ5LCBzaGFkZXIpO1xuICAgICAgICAvLyB0aGVuIHJlbmRlciBpdFxuICAgICAgICByZW5kZXJlci5nZW9tZXRyeS5kcmF3KHRoaXMuZHJhd01vZGUsIHRoaXMuc2l6ZSwgdGhpcy5zdGFydCwgdGhpcy5nZW9tZXRyeS5pbnN0YW5jZUNvdW50KTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFJlbmRlcmluZyBieSB1c2luZyB0aGUgQmF0Y2ggc3lzdGVtLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAcGFyYW0ge1BJWEkuUmVuZGVyZXJ9IHJlbmRlcmVyIC0gSW5zdGFuY2UgdG8gcmVuZGVyZXIuXG4gICAgICovXG4gICAgX3JlbmRlclRvQmF0Y2gocmVuZGVyZXIpIHtcbiAgICAgICAgdmFyIGdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeTtcbiAgICAgICAgaWYgKHRoaXMuc2hhZGVyLnV2TWF0cml4KSB7XG4gICAgICAgICAgICB0aGlzLnNoYWRlci51dk1hdHJpeC51cGRhdGUoKTtcbiAgICAgICAgICAgIHRoaXMuY2FsY3VsYXRlVXZzKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2V0IHByb3BlcnRpZXMgZm9yIGJhdGNoaW5nLi5cbiAgICAgICAgdGhpcy5jYWxjdWxhdGVWZXJ0aWNlcygpO1xuICAgICAgICB0aGlzLmluZGljZXMgPSBnZW9tZXRyeS5pbmRleEJ1ZmZlci5kYXRhO1xuICAgICAgICB0aGlzLl90aW50UkdCID0gdGhpcy5zaGFkZXIuX3RpbnRSR0I7XG4gICAgICAgIHRoaXMuX3RleHR1cmUgPSB0aGlzLnNoYWRlci50ZXh0dXJlO1xuICAgICAgICB2YXIgcGx1Z2luTmFtZSA9IHRoaXMubWF0ZXJpYWwucGx1Z2luTmFtZTtcbiAgICAgICAgcmVuZGVyZXIuYmF0Y2guc2V0T2JqZWN0UmVuZGVyZXIocmVuZGVyZXIucGx1Z2luc1twbHVnaW5OYW1lXSk7XG4gICAgICAgIHJlbmRlcmVyLnBsdWdpbnNbcGx1Z2luTmFtZV0ucmVuZGVyKHRoaXMpO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB2ZXJ0ZXhEYXRhIGZpZWxkIGJhc2VkIG9uIHRyYW5zZm9ybSBhbmQgdmVydGljZXNcbiAgICAgKi9cbiAgICBjYWxjdWxhdGVWZXJ0aWNlcygpIHtcbiAgICAgICAgdmFyIGdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeTtcbiAgICAgICAgdmFyIHZlcnRpY2VzID0gZ2VvbWV0cnkuYnVmZmVyc1swXS5kYXRhO1xuICAgICAgICBpZiAoZ2VvbWV0cnkudmVydGV4RGlydHlJZCA9PT0gdGhpcy52ZXJ0ZXhEaXJ0eSAmJiB0aGlzLl90cmFuc2Zvcm1JRCA9PT0gdGhpcy50cmFuc2Zvcm0ud29ybGRJRCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3RyYW5zZm9ybUlEID0gdGhpcy50cmFuc2Zvcm0ud29ybGRJRDtcbiAgICAgICAgaWYgKHRoaXMudmVydGV4RGF0YS5sZW5ndGggIT09IHZlcnRpY2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy52ZXJ0ZXhEYXRhID0gbmV3IEZsb2F0MzJBcnJheSh2ZXJ0aWNlcy5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB3dCA9IHRoaXMudHJhbnNmb3JtLndvcmxkVHJhbnNmb3JtO1xuICAgICAgICB2YXIgYSA9IHd0LmE7XG4gICAgICAgIHZhciBiID0gd3QuYjtcbiAgICAgICAgdmFyIGMgPSB3dC5jO1xuICAgICAgICB2YXIgZCA9IHd0LmQ7XG4gICAgICAgIHZhciB0eCA9IHd0LnR4O1xuICAgICAgICB2YXIgdHkgPSB3dC50eTtcbiAgICAgICAgdmFyIHZlcnRleERhdGEgPSB0aGlzLnZlcnRleERhdGE7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmVydGV4RGF0YS5sZW5ndGggLyAyOyBpKyspIHtcbiAgICAgICAgICAgIHZhciB4ID0gdmVydGljZXNbKGkgKiAyKV07XG4gICAgICAgICAgICB2YXIgeSA9IHZlcnRpY2VzWyhpICogMikgKyAxXTtcbiAgICAgICAgICAgIHZlcnRleERhdGFbKGkgKiAyKV0gPSAoYSAqIHgpICsgKGMgKiB5KSArIHR4O1xuICAgICAgICAgICAgdmVydGV4RGF0YVsoaSAqIDIpICsgMV0gPSAoYiAqIHgpICsgKGQgKiB5KSArIHR5O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9yb3VuZFBpeGVscykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgdmVydGV4RGF0YS5sZW5ndGg7IGkkMSsrKSB7XG4gICAgICAgICAgICAgICAgdmVydGV4RGF0YVtpJDFdID0gTWF0aC5yb3VuZCh2ZXJ0ZXhEYXRhW2kkMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMudmVydGV4RGlydHkgPSBnZW9tZXRyeS52ZXJ0ZXhEaXJ0eUlkO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB1diBmaWVsZCBiYXNlZCBvbiBmcm9tIGdlb21ldHJ5IHV2J3Mgb3IgYmF0Y2hVdnNcbiAgICAgKi9cbiAgICBjYWxjdWxhdGVVdnMoKSB7XG4gICAgICAgIHZhciBnZW9tVXZzID0gdGhpcy5nZW9tZXRyeS5idWZmZXJzWzFdO1xuICAgICAgICBpZiAoIXRoaXMuc2hhZGVyLnV2TWF0cml4LmlzU2ltcGxlKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuYmF0Y2hVdnMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJhdGNoVXZzID0gbmV3IE1lc2hCYXRjaFV2c18xLk1lc2hCYXRjaFV2cyhnZW9tVXZzLCB0aGlzLnNoYWRlci51dk1hdHJpeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmJhdGNoVXZzLnVwZGF0ZSgpO1xuICAgICAgICAgICAgdGhpcy51dnMgPSB0aGlzLmJhdGNoVXZzLmRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnV2cyA9IGdlb21VdnMuZGF0YTtcbiAgICAgICAgfVxuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgYm91bmRzIG9mIHRoZSBtZXNoIGFzIGEgcmVjdGFuZ2xlLiBUaGUgYm91bmRzIGNhbGN1bGF0aW9uIHRha2VzIHRoZSB3b3JsZFRyYW5zZm9ybSBpbnRvIGFjY291bnQuXG4gICAgICogdGhlcmUgbXVzdCBiZSBhIGFWZXJ0ZXhQb3NpdGlvbiBhdHRyaWJ1dGUgcHJlc2VudCBpbiB0aGUgZ2VvbWV0cnkgZm9yIGJvdW5kcyB0byBiZSBjYWxjdWxhdGVkIGNvcnJlY3RseS5cbiAgICAgKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfY2FsY3VsYXRlQm91bmRzKCkge1xuICAgICAgICB0aGlzLmNhbGN1bGF0ZVZlcnRpY2VzKCk7XG4gICAgICAgIHRoaXMuX2JvdW5kcy5hZGRWZXJ0ZXhEYXRhKHRoaXMudmVydGV4RGF0YSwgMCwgdGhpcy52ZXJ0ZXhEYXRhLmxlbmd0aCk7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBUZXN0cyBpZiBhIHBvaW50IGlzIGluc2lkZSB0aGlzIG1lc2guIFdvcmtzIG9ubHkgZm9yIFBJWEkuRFJBV19NT0RFUy5UUklBTkdMRVMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BJWEkuUG9pbnR9IHBvaW50IHRoZSBwb2ludCB0byB0ZXN0XG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gdGhlIHJlc3VsdCBvZiB0aGUgdGVzdFxuICAgICAqL1xuICAgIGNvbnRhaW5zUG9pbnQocG9pbnQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmludGVyYWN0aXZlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmdldEJvdW5kcygpLmNvbnRhaW5zKHBvaW50LngsIHBvaW50LnkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGRlZmF1bHRwb2ludCA9IFBvaW50XzEuUG9pbnQuREVGQVVMVDtcbiAgICAgICAgdGhpcy53b3JsZFRyYW5zZm9ybS5hcHBseUludmVyc2UocG9pbnQsIGRlZmF1bHRwb2ludCk7XG4gICAgICAgIHZhciB2ZXJ0aWNlcyA9IHRoaXMuZ2VvbWV0cnkuZ2V0QXR0cmlidXRlKCdhVmVydGV4UG9zaXRpb24nKS5kYXRhO1xuICAgICAgICB2YXIgcG9pbnRzID0gTWVzaC50ZW1wUG9seWdvbi5wb2ludHM7XG4gICAgICAgIHZhciBpbmRpY2VzID0gdGhpcy5nZW9tZXRyeS5nZXRJbmRleCgpLmRhdGE7XG4gICAgICAgIHZhciBsZW4gPSBpbmRpY2VzLmxlbmd0aDtcbiAgICAgICAgdmFyIHN0ZXAgPSB0aGlzLmRyYXdNb2RlID09PSA0ID8gMyA6IDE7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpICsgMiA8IGxlbjsgaSArPSBzdGVwKSB7XG4gICAgICAgICAgICB2YXIgaW5kMCA9IGluZGljZXNbaV0gKiAyO1xuICAgICAgICAgICAgdmFyIGluZDEgPSBpbmRpY2VzW2kgKyAxXSAqIDI7XG4gICAgICAgICAgICB2YXIgaW5kMiA9IGluZGljZXNbaSArIDJdICogMjtcbiAgICAgICAgICAgIHBvaW50c1swXSA9IHZlcnRpY2VzW2luZDBdO1xuICAgICAgICAgICAgcG9pbnRzWzFdID0gdmVydGljZXNbaW5kMCArIDFdO1xuICAgICAgICAgICAgcG9pbnRzWzJdID0gdmVydGljZXNbaW5kMV07XG4gICAgICAgICAgICBwb2ludHNbM10gPSB2ZXJ0aWNlc1tpbmQxICsgMV07XG4gICAgICAgICAgICBwb2ludHNbNF0gPSB2ZXJ0aWNlc1tpbmQyXTtcbiAgICAgICAgICAgIHBvaW50c1s1XSA9IHZlcnRpY2VzW2luZDIgKyAxXTtcbiAgICAgICAgICAgIGlmIChNZXNoLnRlbXBQb2x5Z29uLmNvbnRhaW5zKGRlZmF1bHRwb2ludC54LCBkZWZhdWx0cG9pbnQueSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBEZXN0cm95cyB0aGUgTWVzaCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdHxib29sZWFufSBbb3B0aW9uc10gLSBPcHRpb25zIHBhcmFtZXRlci4gQSBib29sZWFuIHdpbGwgYWN0IGFzIGlmIGFsbFxuICAgICAqICBvcHRpb25zIGhhdmUgYmVlbiBzZXQgdG8gdGhhdCB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuY2hpbGRyZW49ZmFsc2VdIC0gaWYgc2V0IHRvIHRydWUsIGFsbCB0aGUgY2hpbGRyZW4gd2lsbCBoYXZlXG4gICAgICogIHRoZWlyIGRlc3Ryb3kgbWV0aG9kIGNhbGxlZCBhcyB3ZWxsLiAnb3B0aW9ucycgd2lsbCBiZSBwYXNzZWQgb24gdG8gdGhvc2UgY2FsbHMuXG4gICAgICovXG4gICAgZGVzdHJveShvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyLmRlc3Ryb3kob3B0aW9ucyk7XG4gICAgICAgIHRoaXMuZ2VvbWV0cnkucmVmQ291bnQtLTtcbiAgICAgICAgaWYgKHRoaXMuZ2VvbWV0cnkucmVmQ291bnQgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuZ2VvbWV0cnkuZGlzcG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZ2VvbWV0cnkgPSBudWxsO1xuICAgICAgICB0aGlzLnNoYWRlciA9IG51bGw7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBudWxsO1xuICAgICAgICB0aGlzLnV2cyA9IG51bGw7XG4gICAgICAgIHRoaXMuaW5kaWNlcyA9IG51bGw7XG4gICAgICAgIHRoaXMudmVydGV4RGF0YSA9IG51bGw7XG4gICAgfVxuICAgIDtcbn1cbk1lc2gudGVtcFBvbHlnb24gPSBuZXcgUG9seWdvbl8xLlBvbHlnb24oKTtcbi8qKlxuICogVGhlIG1heGltdW0gbnVtYmVyIG9mIHZlcnRpY2VzIHRvIGNvbnNpZGVyIGJhdGNoYWJsZS4gR2VuZXJhbGx5LCB0aGUgY29tcGxleGl0eVxuICogb2YgdGhlIGdlb21ldHJ5LlxuICogQG1lbWJlcm9mIFBJWEkuTWVzaFxuICogQHN0YXRpY1xuICogQG1lbWJlciB7bnVtYmVyfSBCQVRDSEFCTEVfU0laRVxuICovXG5NZXNoLkJBVENIQUJMRV9TSVpFID0gMTAwO1xuZXhwb3J0cy5NZXNoID0gTWVzaDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY2xhc3MgTWVzaEJhdGNoVXZzIHtcbiAgICBjb25zdHJ1Y3Rvcih1dkJ1ZmZlciwgdXZNYXRyaXgpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogQnVmZmVyIHdpdGggbm9ybWFsaXplZCBVVidzXG4gICAgICAgICAgICAgICAgICogQG1lbWJlciB7UElYSS5CdWZmZXJ9XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgIHRoaXMudXZCdWZmZXIgPSB1dkJ1ZmZlcjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1hdGVyaWFsIFVWIG1hdHJpeFxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLlRleHR1cmVNYXRyaXh9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnV2TWF0cml4ID0gdXZNYXRyaXg7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVViBCdWZmZXIgZGF0YVxuICAgICAgICAgKiBAbWVtYmVyIHtGbG9hdDMyQXJyYXl9XG4gICAgICAgICAqIEByZWFkb25seVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kYXRhID0gbnVsbDtcbiAgICAgICAgdGhpcy5fYnVmZmVyVXBkYXRlSWQgPSAtMTtcbiAgICAgICAgdGhpcy5fdGV4dHVyZVVwZGF0ZUlkID0gLTE7XG4gICAgICAgIHRoaXMuX3VwZGF0ZUlEID0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogdXBkYXRlc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtib29sZWFufSBmb3JjZVVwZGF0ZSAtIGZvcmNlIHRoZSB1cGRhdGVcbiAgICAgKi9cbiAgICB1cGRhdGUoZm9yY2VVcGRhdGUpIHtcbiAgICAgICAgaWYgKCFmb3JjZVVwZGF0ZVxuICAgICAgICAgICAgJiYgdGhpcy5fYnVmZmVyVXBkYXRlSWQgPT09IHRoaXMudXZCdWZmZXIuX3VwZGF0ZUlEXG4gICAgICAgICAgICAmJiB0aGlzLl90ZXh0dXJlVXBkYXRlSWQgPT09IHRoaXMudXZNYXRyaXguX3VwZGF0ZUlEKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fYnVmZmVyVXBkYXRlSWQgPSB0aGlzLnV2QnVmZmVyLl91cGRhdGVJRDtcbiAgICAgICAgdGhpcy5fdGV4dHVyZVVwZGF0ZUlkID0gdGhpcy51dk1hdHJpeC5fdXBkYXRlSUQ7XG4gICAgICAgIHZhciBkYXRhID0gdGhpcy51dkJ1ZmZlci5kYXRhO1xuICAgICAgICBpZiAoIXRoaXMuZGF0YSB8fCB0aGlzLmRhdGEubGVuZ3RoICE9PSBkYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5kYXRhID0gbmV3IEZsb2F0MzJBcnJheShkYXRhLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51dk1hdHJpeC5tdWx0aXBseVV2cyhkYXRhLCB0aGlzLmRhdGEpO1xuICAgICAgICB0aGlzLl91cGRhdGVJRCsrO1xuICAgIH1cbiAgICA7XG59XG5leHBvcnRzLk1lc2hCYXRjaFV2cyA9IE1lc2hCYXRjaFV2cztcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgR2VvbWV0cnlfMSA9IHJlcXVpcmUoXCIuL0dlb21ldHJ5XCIpO1xuY29uc3QgQnVmZmVyXzEgPSByZXF1aXJlKFwiLi9CdWZmZXJcIik7XG5jb25zdCBXZWJHTFNldHRpbmdzXzEgPSByZXF1aXJlKFwiLi9XZWJHTFNldHRpbmdzXCIpO1xuY2xhc3MgTWVzaEdlb21ldHJ5IGV4dGVuZHMgR2VvbWV0cnlfMS5HZW9tZXRyeSB7XG4gICAgY29uc3RydWN0b3IodmVydGljZXMgPSBudWxsLCB1dnMgPSBudWxsLCBpbmRleCA9IG51bGwpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdmFyIHZlcnRpY2VzQnVmZmVyID0gbmV3IEJ1ZmZlcl8xLkJ1ZmZlcih2ZXJ0aWNlcyk7XG4gICAgICAgIHZhciB1dnNCdWZmZXIgPSBuZXcgQnVmZmVyXzEuQnVmZmVyKHV2cywgdHJ1ZSk7XG4gICAgICAgIHZhciBpbmRleEJ1ZmZlciA9IG5ldyBCdWZmZXJfMS5CdWZmZXIoaW5kZXgsIHRydWUsIHRydWUpO1xuICAgICAgICB0aGlzLmFkZEF0dHJpYnV0ZSgnYVZlcnRleFBvc2l0aW9uJywgdmVydGljZXNCdWZmZXIsIDIsIGZhbHNlLCBXZWJHTFNldHRpbmdzXzEuV2ViR0xTZXR0aW5ncy5UWVBFUy5GTE9BVClcbiAgICAgICAgICAgIC5hZGRBdHRyaWJ1dGUoJ2FUZXh0dXJlQ29vcmQnLCB1dnNCdWZmZXIsIDIsIGZhbHNlLCBXZWJHTFNldHRpbmdzXzEuV2ViR0xTZXR0aW5ncy5UWVBFUy5GTE9BVClcbiAgICAgICAgICAgIC5hZGRJbmRleChpbmRleEJ1ZmZlcik7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEaXJ0eSBmbGFnIHRvIGxpbWl0IHVwZGF0ZSBjYWxscyBvbiBNZXNoLiBGb3IgZXhhbXBsZSxcbiAgICAgICAgICogbGltaXRpbmcgdXBkYXRlcyBvbiBhIHNpbmdsZSBNZXNoIGluc3RhbmNlIHdpdGggYSBzaGFyZWQgR2VvbWV0cnlcbiAgICAgICAgICogd2l0aGluIHRoZSByZW5kZXIgbG9vcC5cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAtMVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fdXBkYXRlSWQgPSAtMTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSWYgdGhlIHZlcnRleCBwb3NpdGlvbiBpcyB1cGRhdGVkLlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGdldCB2ZXJ0ZXhEaXJ0eUlkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5idWZmZXJzWzBdLl91cGRhdGVJRDtcbiAgICB9XG4gICAgO1xufVxuZXhwb3J0cy5NZXNoR2VvbWV0cnkgPSBNZXNoR2VvbWV0cnk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IFNoYWRlcl8xID0gcmVxdWlyZShcIi4vU2hhZGVyXCIpO1xuY29uc3QgTWF0cml4XzEgPSByZXF1aXJlKFwiLi9NYXRyaXhcIik7XG5jb25zdCBQcm9ncmFtXzEgPSByZXF1aXJlKFwiLi9Qcm9ncmFtXCIpO1xuY29uc3QgVGV4dHVyZU1hdHJpeF8xID0gcmVxdWlyZShcIi4vVGV4dHVyZU1hdHJpeFwiKTtcbmNvbnN0IENvbG9yU2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL0NvbG9yU2V0dGluZ3NcIik7XG5jbGFzcyBNZXNoTWF0ZXJpYWwgZXh0ZW5kcyBTaGFkZXJfMS5TaGFkZXIge1xuICAgIGNvbnN0cnVjdG9yKHVTYW1wbGVyLCBvcHRpb25zID0gbnVsbCkge1xuICAgICAgICB2YXIgdW5pZm9ybXMgPSB7XG4gICAgICAgICAgICB1U2FtcGxlcjogdVNhbXBsZXIsXG4gICAgICAgICAgICBhbHBoYTogMSxcbiAgICAgICAgICAgIHVUZXh0dXJlTWF0cml4OiBNYXRyaXhfMS5NYXRyaXguSURFTlRJVFksXG4gICAgICAgICAgICB1Q29sb3I6IG5ldyBGbG9hdDMyQXJyYXkoWzEsIDEsIDEsIDFdKSxcbiAgICAgICAgfTtcbiAgICAgICAgLy8gU2V0IGRlZmF1bHRzXG4gICAgICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgIHRpbnQ6IDB4RkZGRkZGLFxuICAgICAgICAgICAgYWxwaGE6IDEsXG4gICAgICAgICAgICBwbHVnaW5OYW1lOiAnYmF0Y2gnLFxuICAgICAgICB9LCBvcHRpb25zKTtcbiAgICAgICAgaWYgKG9wdGlvbnMudW5pZm9ybXMpIHtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odW5pZm9ybXMsIG9wdGlvbnMudW5pZm9ybXMpO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyKG9wdGlvbnMucHJvZ3JhbSB8fCBQcm9ncmFtXzEuUHJvZ3JhbS5mcm9tKE1lc2hNYXRlcmlhbC52ZXJ0ZXgkNiwgTWVzaE1hdGVyaWFsLmZyYWdtZW50JDgpLCB1bmlmb3Jtcyk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBPbmx5IGRvIHVwZGF0ZSBpZiB0aW50IG9yIGFscGhhIGNoYW5nZXMuXG4gICAgICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9jb2xvckRpcnR5ID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUZXh0dXJlTWF0cml4IGluc3RhbmNlIGZvciB0aGlzIE1lc2gsIHVzZWQgdG8gdHJhY2sgVGV4dHVyZSBjaGFuZ2VzXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuVGV4dHVyZU1hdHJpeH1cbiAgICAgICAgICogQHJlYWRvbmx5XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnV2TWF0cml4ID0gbmV3IFRleHR1cmVNYXRyaXhfMS5UZXh0dXJlTWF0cml4KHVTYW1wbGVyKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGB0cnVlYCBpZiBzaGFkZXIgY2FuIGJlIGJhdGNoIHdpdGggdGhlIHJlbmRlcmVyJ3MgYmF0Y2ggc3lzdGVtLlxuICAgICAgICAgKiBAbWVtYmVyIHtib29sZWFufVxuICAgICAgICAgKiBAZGVmYXVsdCB0cnVlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmJhdGNoYWJsZSA9IG9wdGlvbnMucHJvZ3JhbSA9PT0gdW5kZWZpbmVkO1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVuZGVyZXIgcGx1Z2luIGZvciBiYXRjaGluZ1xuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtzdHJpbmd9XG4gICAgICAgICAqIEBkZWZhdWx0ICdiYXRjaCdcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucGx1Z2luTmFtZSA9IG9wdGlvbnMucGx1Z2luTmFtZTtcbiAgICAgICAgdGhpcy50aW50ID0gb3B0aW9ucy50aW50O1xuICAgICAgICB0aGlzLmFscGhhID0gb3B0aW9ucy5hbHBoYTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVmZXJlbmNlIHRvIHRoZSB0ZXh0dXJlIGJlaW5nIHJlbmRlcmVkLlxuICAgICAqIEBtZW1iZXIge1BJWEkuVGV4dHVyZX1cbiAgICAgKi9cbiAgICBnZXQgdGV4dHVyZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudW5pZm9ybXMudVNhbXBsZXI7XG4gICAgfVxuICAgIDtcbiAgICBzZXQgdGV4dHVyZSh2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy51bmlmb3Jtcy51U2FtcGxlciAhPT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMudW5pZm9ybXMudVNhbXBsZXIgPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMudXZNYXRyaXgudGV4dHVyZSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBUaGlzIGdldHMgYXV0b21hdGljYWxseSBzZXQgYnkgdGhlIG9iamVjdCB1c2luZyB0aGlzLlxuICAgICAqXG4gICAgICogQGRlZmF1bHQgMVxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKi9cbiAgICBzZXQgYWxwaGEodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlID09PSB0aGlzLl9hbHBoYSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2FscGhhID0gdmFsdWU7XG4gICAgICAgIHRoaXMuX2NvbG9yRGlydHkgPSB0cnVlO1xuICAgIH1cbiAgICA7XG4gICAgZ2V0IGFscGhhKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWxwaGE7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBNdWx0aXBseSB0aW50IGZvciB0aGUgbWF0ZXJpYWwuXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IDB4RkZGRkZGXG4gICAgICovXG4gICAgc2V0IHRpbnQodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlID09PSB0aGlzLl90aW50KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdGludCA9IHZhbHVlO1xuICAgICAgICB0aGlzLl90aW50UkdCID0gKHZhbHVlID4+IDE2KSArICh2YWx1ZSAmIDB4ZmYwMCkgKyAoKHZhbHVlICYgMHhmZikgPDwgMTYpO1xuICAgICAgICB0aGlzLl9jb2xvckRpcnR5ID0gdHJ1ZTtcbiAgICB9XG4gICAgO1xuICAgIGdldCB0aW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdGludDtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIEdldHMgY2FsbGVkIGF1dG9tYXRpY2FsbHkgYnkgdGhlIE1lc2guIEludGVuZGVkIHRvIGJlIG92ZXJyaWRkZW4gZm9yIGN1c3RvbVxuICAgICAqIE1lc2hNYXRlcmlhbCBvYmplY3RzLlxuICAgICAqL1xuICAgIHVwZGF0ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2NvbG9yRGlydHkpIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbG9yRGlydHkgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBiYXNlVGV4dHVyZSA9IHRoaXMudGV4dHVyZS5iYXNlVGV4dHVyZTtcbiAgICAgICAgICAgIENvbG9yU2V0dGluZ3NfMS5Db2xvclNldHRpbmdzLnByZW11bHRpcGx5VGludFRvUmdiYSh0aGlzLl90aW50LCB0aGlzLl9hbHBoYSwgdGhpcy51bmlmb3Jtcy51Q29sb3IsIGJhc2VUZXh0dXJlLnByZW11bHRpcGx5QWxwaGEpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnV2TWF0cml4LnVwZGF0ZSgpKSB7XG4gICAgICAgICAgICB0aGlzLnVuaWZvcm1zLnVUZXh0dXJlTWF0cml4ID0gdGhpcy51dk1hdHJpeC5tYXBDb29yZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICA7XG59XG5NZXNoTWF0ZXJpYWwudmVydGV4JDYgPSBcImF0dHJpYnV0ZSB2ZWMyIGFWZXJ0ZXhQb3NpdGlvbjtcXHJcXG5hdHRyaWJ1dGUgdmVjMiBhVGV4dHVyZUNvb3JkO1xcclxcblxcclxcbnVuaWZvcm0gbWF0MyBwcm9qZWN0aW9uTWF0cml4O1xcclxcbnVuaWZvcm0gbWF0MyB0cmFuc2xhdGlvbk1hdHJpeDtcXHJcXG51bmlmb3JtIG1hdDMgdVRleHR1cmVNYXRyaXg7XFxyXFxuXFxyXFxudmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XFxyXFxuXFxyXFxudm9pZCBtYWluKHZvaWQpXFxyXFxue1xcclxcbiAgICBnbF9Qb3NpdGlvbiA9IHZlYzQoKHByb2plY3Rpb25NYXRyaXggKiB0cmFuc2xhdGlvbk1hdHJpeCAqIHZlYzMoYVZlcnRleFBvc2l0aW9uLCAxLjApKS54eSwgMC4wLCAxLjApO1xcclxcblxcclxcbiAgICB2VGV4dHVyZUNvb3JkID0gKHVUZXh0dXJlTWF0cml4ICogdmVjMyhhVGV4dHVyZUNvb3JkLCAxLjApKS54eTtcXHJcXG59XFxyXFxuXCI7XG5NZXNoTWF0ZXJpYWwuZnJhZ21lbnQkOCA9IFwidmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XFxyXFxudW5pZm9ybSB2ZWM0IHVDb2xvcjtcXHJcXG5cXHJcXG51bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjtcXHJcXG5cXHJcXG52b2lkIG1haW4odm9pZClcXHJcXG57XFxyXFxuICAgIGdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCh1U2FtcGxlciwgdlRleHR1cmVDb29yZCkgKiB1Q29sb3I7XFxyXFxufVxcclxcblwiO1xuZXhwb3J0cy5NZXNoTWF0ZXJpYWwgPSBNZXNoTWF0ZXJpYWw7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IEV2ZW50XzEgPSByZXF1aXJlKFwiLi9FdmVudFwiKTtcbmNsYXNzIE1vdXNlRXZlbnQgZXh0ZW5kcyBFdmVudF8xLkV2ZW50IHtcbiAgICBjb25zdHJ1Y3Rvcih0eXBlLCBidWJibGVzID0gZmFsc2UpIHtcbiAgICAgICAgc3VwZXIodHlwZSwgYnViYmxlcyk7XG4gICAgICAgIHRoaXMubW92ZW1lbnRYID0gMDtcbiAgICAgICAgdGhpcy5tb3ZlbWVudFkgPSAwO1xuICAgIH1cbn1cbk1vdXNlRXZlbnQuQ0xJQ0sgPSBcImNsaWNrXCI7XG5Nb3VzZUV2ZW50Lk1PVVNFX0RPV04gPSBcIm1vdXNlRG93blwiO1xuTW91c2VFdmVudC5NT1VTRV9VUCA9IFwibW91c2VVcFwiO1xuTW91c2VFdmVudC5NSURETEVfQ0xJQ0sgPSBcIm1pZGRsZUNsaWNrXCI7XG5Nb3VzZUV2ZW50Lk1JRERMRV9NT1VTRV9ET1dOID0gXCJtaWRkbGVNb3VzZURvd25cIjtcbk1vdXNlRXZlbnQuTUlERExFX01PVVNFX1VQID0gXCJtaWRkbGVNb3VzZVVwXCI7XG5Nb3VzZUV2ZW50LlJJR0hUX0NMSUNLID0gXCJyaWdodENsaWNrXCI7XG5Nb3VzZUV2ZW50LlJJR0hUX01PVVNFX0RPV04gPSBcInJpZ2h0TW91c2VEb3duXCI7XG5Nb3VzZUV2ZW50LlJJR0hUX01PVVNFX1VQID0gXCJyaWdodE1vdXNlVXBcIjtcbk1vdXNlRXZlbnQuTU9VU0VfTU9WRSA9IFwibW91c2VNb3ZlXCI7XG5Nb3VzZUV2ZW50Lk1PVVNFX09WRVIgPSBcIm1vdXNlT3ZlclwiO1xuTW91c2VFdmVudC5NT1VTRV9PVVQgPSBcIm1vdXNlT3V0XCI7XG5Nb3VzZUV2ZW50LlJJR0hUX01PVVNFX1VQX09VVFNJREUgPSBcInJpZ2h0dXBvdXRzaWRlXCI7XG5Nb3VzZUV2ZW50Lk1PVVNFX1VQX09VVFNJREUgPSBcIm1vdXNldXBvdXRzaWRlXCI7XG5Nb3VzZUV2ZW50LlBPSU5URVJfT1ZFUiA9IFwicG9pbnRlcm92ZXJcIjtcbk1vdXNlRXZlbnQuUE9JTlRFUl9FTlRFUiA9IFwicG9pbnRlcmVudGVyXCI7XG5Nb3VzZUV2ZW50LlBPSU5URVJfRE9XTiA9IFwicG9pbnRlcmRvd25cIjtcbk1vdXNlRXZlbnQuUE9JTlRFUl9NT1ZFID0gXCJwb2ludGVybW92ZVwiO1xuTW91c2VFdmVudC5QT0lOVEVSX1VQID0gXCJwb2ludGVydXBcIjtcbk1vdXNlRXZlbnQuUE9JTlRFUl9DQU5DRUwgPSBcInBvaW50ZXJjYW5jZWxcIjtcbk1vdXNlRXZlbnQuUE9JTlRFUl9PVVQgPSBcInBvaW50ZXJvdXRcIjtcbk1vdXNlRXZlbnQuUE9JTlRFUl9MRUFWRSA9IFwicG9pbnRlcmxlYXZlXCI7XG5Nb3VzZUV2ZW50LlBPSU5URVJfQ0FQVFVSRSA9IFwiZ290cG9pbnRlcmNhcHR1cmVcIjtcbk1vdXNlRXZlbnQuUE9JTlRFUl9MT1NUID0gXCJsb3N0cG9pbnRlcmNhcHR1cmVcIjtcbk1vdXNlRXZlbnQuUE9JTlRFUl9VUF9PVVRTSURFID0gXCJwb2ludGVydXBvdXRzaWRlXCI7XG5Nb3VzZUV2ZW50LlBPSU5URVJfVEFQID0gXCJwb2ludGVydGFwXCI7XG5Nb3VzZUV2ZW50LlRPVUNIX1NUQVJUID0gXCJ0b3VjaHN0YXJ0XCI7XG5Nb3VzZUV2ZW50LlRPVUNIX0VORCA9IFwidG91Y2hlbmRcIjtcbk1vdXNlRXZlbnQuVE9VQ0hfRU5EX09VVFNJREUgPSBcInRvdWNoZW5kb3V0c2lkZVwiO1xuTW91c2VFdmVudC5UT1VDSF9NT1ZFID0gXCJ0b3VjaG1vdmVcIjtcbk1vdXNlRXZlbnQuVE9VQ0hfQ0FOQ0VMID0gXCJ0b3VjaGNhbmNlbFwiO1xuTW91c2VFdmVudC5UT1VDSF9UQVAgPSBcInRhcFwiO1xuZXhwb3J0cy5Nb3VzZUV2ZW50ID0gTW91c2VFdmVudDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgVXJsXzEgPSByZXF1aXJlKFwiLi9VcmxcIik7XG5jbGFzcyBOZXR3b3JrU2V0dGluZ3Mge1xuICAgIHN0YXRpYyBnZXRSZXNvbHV0aW9uT2ZVcmwodXJsLCBkZWZhdWx0VmFsdWUgPSBudWxsKSB7XG4gICAgICAgIHZhciByZXNvbHV0aW9uID0gTmV0d29ya1NldHRpbmdzLlJFVElOQV9QUkVGSVguZXhlYyh1cmwpO1xuICAgICAgICBpZiAocmVzb2x1dGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQocmVzb2x1dGlvblsxXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZSAhPT0gdW5kZWZpbmVkID8gZGVmYXVsdFZhbHVlIDogMTtcbiAgICB9XG4gICAgc3RhdGljIGRldGVybWluZUNyb3NzT3JpZ2luKHVybCQxLCBsb2MgPSBudWxsKSB7XG4gICAgICAgIGlmIChsb2MgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgbG9jID0gd2luZG93LmxvY2F0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1cmwkMS5pbmRleE9mKCdkYXRhOicpID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICAgICAgbG9jID0gbG9jIHx8IHdpbmRvdy5sb2NhdGlvbjtcbiAgICAgICAgaWYgKCFOZXR3b3JrU2V0dGluZ3MudGVtcEFuY2hvcikge1xuICAgICAgICAgICAgTmV0d29ya1NldHRpbmdzLnRlbXBBbmNob3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG4gICAgICAgIH1cbiAgICAgICAgTmV0d29ya1NldHRpbmdzLnRlbXBBbmNob3IuaHJlZiA9IHVybCQxO1xuICAgICAgICB1cmwkMSA9IE5ldHdvcmtTZXR0aW5ncy51cmwucGFyc2UoTmV0d29ya1NldHRpbmdzLnRlbXBBbmNob3IuaHJlZik7XG4gICAgICAgIHZhciBzYW1lUG9ydCA9ICghdXJsJDEucG9ydCAmJiBsb2MucG9ydCA9PT0gJycpIHx8ICh1cmwkMS5wb3J0ID09PSBsb2MucG9ydCk7XG4gICAgICAgIGlmICh1cmwkMS5ob3N0bmFtZSAhPT0gbG9jLmhvc3RuYW1lIHx8ICFzYW1lUG9ydCB8fCB1cmwkMS5wcm90b2NvbCAhPT0gbG9jLnByb3RvY29sKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2Fub255bW91cyc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbn1cbk5ldHdvcmtTZXR0aW5ncy5SRVRJTkFfUFJFRklYID0gL0AoWzAtOVxcLl0rKXgvO1xuTmV0d29ya1NldHRpbmdzLnVybCA9IHtcbiAgICBwYXJzZTogVXJsXzEuVXJsLnVybFBhcnNlLFxuICAgIHJlc29sdmU6IFVybF8xLlVybC51cmxSZXNvbHZlLFxuICAgIHJlc29sdmVPYmplY3Q6IFVybF8xLlVybC51cmxSZXNvbHZlT2JqZWN0LFxuICAgIGZvcm1hdDogVXJsXzEuVXJsLnVybEZvcm1hdCxcbiAgICBVcmw6IFVybF8xLlVybFxufTtcbmV4cG9ydHMuTmV0d29ya1NldHRpbmdzID0gTmV0d29ya1NldHRpbmdzO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBTeXN0ZW1fMSA9IHJlcXVpcmUoXCIuL1N5c3RlbVwiKTtcbmNsYXNzIE9iamVjdFJlbmRlcmVyIGV4dGVuZHMgU3lzdGVtXzEuU3lzdGVtIHtcbiAgICBjb25zdHJ1Y3RvcihyZW5kZXJlcikge1xuICAgICAgICBzdXBlcihyZW5kZXJlcik7XG4gICAgfVxuICAgIHN0YXJ0KCkge1xuICAgICAgICAvLyBzZXQgdGhlIHNoYWRlci4uXG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBTdG9wcyB0aGUgcmVuZGVyZXJcbiAgICAgKlxuICAgICAqL1xuICAgIHN0b3AoKSB7XG4gICAgICAgIHRoaXMuZmx1c2goKTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFN0dWIgbWV0aG9kIGZvciByZW5kZXJpbmcgY29udGVudCBhbmQgZW1wdHlpbmcgdGhlIGN1cnJlbnQgYmF0Y2guXG4gICAgICpcbiAgICAgKi9cbiAgICBmbHVzaCgpIHtcbiAgICAgICAgLy8gZmx1c2ghXG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIGFuIG9iamVjdFxuICAgICAqXG4gICAgICogQHBhcmFtIHtQSVhJLkRpc3BsYXlPYmplY3R9IG9iamVjdCAtIFRoZSBvYmplY3QgdG8gcmVuZGVyLlxuICAgICAqL1xuICAgIHJlbmRlcihvYmplY3QpIHtcbiAgICAgICAgLy8gcmVuZGVyIHRoZSBvYmplY3RcbiAgICB9XG4gICAgO1xufVxuZXhwb3J0cy5PYmplY3RSZW5kZXJlciA9IE9iamVjdFJlbmRlcmVyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBQb2ludF8xID0gcmVxdWlyZShcIi4uL2ZsYXNoL2dlb20vUG9pbnRcIik7XG5jbGFzcyBPYnNlcnZhYmxlUG9pbnQgZXh0ZW5kcyBQb2ludF8xLlBvaW50IHtcbiAgICBjb25zdHJ1Y3Rvcih4ID0gMCwgeSA9IDApIHtcbiAgICAgICAgc3VwZXIoeCwgeSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHBvaW50IHRvIGEgbmV3IHggYW5kIHkgcG9zaXRpb24uXG4gICAgICogSWYgeSBpcyBvbWl0dGVkLCBib3RoIHggYW5kIHkgd2lsbCBiZSBzZXQgdG8geC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbeD0wXSAtIHBvc2l0aW9uIG9mIHRoZSBwb2ludCBvbiB0aGUgeCBheGlzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt5PTBdIC0gcG9zaXRpb24gb2YgdGhlIHBvaW50IG9uIHRoZSB5IGF4aXNcbiAgICAgKi9cbiAgICBzZXQoeCA9IDAsIHkgPSBOYU4pIHtcbiAgICAgICAgdmFyIF94ID0geDtcbiAgICAgICAgdmFyIF95ID0geTtcbiAgICAgICAgaWYgKGlzTmFOKF95KSkge1xuICAgICAgICAgICAgX3kgPSBfeDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5feCAhPT0gX3ggfHwgdGhpcy5feSAhPT0gX3kpIHtcbiAgICAgICAgICAgIHRoaXMuX3ggPSBfeDtcbiAgICAgICAgICAgIHRoaXMuX3kgPSBfeTtcbiAgICAgICAgICAgIHRoaXMuY2FsbGJhY2suY2FsbCh0aGlzLnNjb3BlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogQ29waWVzIHggYW5kIHkgZnJvbSB0aGUgZ2l2ZW4gcG9pbnRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UElYSS5JUG9pbnR9IHAgLSBUaGUgcG9pbnQgdG8gY29weSBmcm9tLlxuICAgICAqIEByZXR1cm5zIHtQSVhJLklQb2ludH0gUmV0dXJucyBpdHNlbGYuXG4gICAgICovXG4gICAgY29weUZyb20ocCkge1xuICAgICAgICBpZiAodGhpcy5feCAhPT0gcC54IHx8IHRoaXMuX3kgIT09IHAueSkge1xuICAgICAgICAgICAgdGhpcy5feCA9IHAueDtcbiAgICAgICAgICAgIHRoaXMuX3kgPSBwLnk7XG4gICAgICAgICAgICB0aGlzLmNhbGxiYWNrLmNhbGwodGhpcy5zY29wZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBDb3BpZXMgeCBhbmQgeSBpbnRvIHRoZSBnaXZlbiBwb2ludFxuICAgICAqXG4gICAgICogQHBhcmFtIHtQSVhJLklQb2ludH0gcCAtIFRoZSBwb2ludCB0byBjb3B5LlxuICAgICAqIEByZXR1cm5zIHtQSVhJLklQb2ludH0gR2l2ZW4gcG9pbnQgd2l0aCB2YWx1ZXMgdXBkYXRlZFxuICAgICAqL1xuICAgIGNvcHlUbyhwKSB7XG4gICAgICAgIHAuc2V0KHRoaXMuX3gsIHRoaXMuX3kpO1xuICAgICAgICByZXR1cm4gcDtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gcG9pbnQgaXMgZXF1YWwgdG8gdGhpcyBwb2ludFxuICAgICAqXG4gICAgICogQHBhcmFtIHtQSVhJLklQb2ludH0gcCAtIFRoZSBwb2ludCB0byBjaGVja1xuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBXaGV0aGVyIHRoZSBnaXZlbiBwb2ludCBlcXVhbCB0byB0aGlzIHBvaW50XG4gICAgICovXG4gICAgZXF1YWxzKHApIHtcbiAgICAgICAgcmV0dXJuIChwLnggPT09IHRoaXMuX3gpICYmIChwLnkgPT09IHRoaXMuX3kpO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogVGhlIHBvc2l0aW9uIG9mIHRoZSBkaXNwbGF5T2JqZWN0IG9uIHRoZSB4IGF4aXMgcmVsYXRpdmUgdG8gdGhlIGxvY2FsIGNvb3JkaW5hdGVzIG9mIHRoZSBwYXJlbnQuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICovXG4gICAgZ2V0IHgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl94O1xuICAgIH1cbiAgICA7XG4gICAgc2V0IHgodmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuX3ggIT09IHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl94ID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLmNhbGxiYWNrLmNhbGwodGhpcy5zY29wZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFRoZSBwb3NpdGlvbiBvZiB0aGUgZGlzcGxheU9iamVjdCBvbiB0aGUgeCBheGlzIHJlbGF0aXZlIHRvIHRoZSBsb2NhbCBjb29yZGluYXRlcyBvZiB0aGUgcGFyZW50LlxuICAgICAqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdldCB5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5feTtcbiAgICB9XG4gICAgO1xuICAgIHNldCB5KHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLl95ICE9PSB2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5feSA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5jYWxsYmFjay5jYWxsKHRoaXMuc2NvcGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIDtcbn1cbmV4cG9ydHMuT2JzZXJ2YWJsZVBvaW50ID0gT2JzZXJ2YWJsZVBvaW50O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBHZW9tZXRyeV8xID0gcmVxdWlyZShcIi4vR2VvbWV0cnlcIik7XG5jb25zdCBCdWZmZXJfMSA9IHJlcXVpcmUoXCIuL0J1ZmZlclwiKTtcbmNvbnN0IFdlYkdMU2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL1dlYkdMU2V0dGluZ3NcIik7XG5jbGFzcyBQYXJ0aWNsZUJ1ZmZlciB7XG4gICAgY29uc3RydWN0b3IocHJvcGVydGllcywgZHluYW1pY1Byb3BlcnR5RmxhZ3MsIHNpemUpIHtcbiAgICAgICAgdGhpcy5nZW9tZXRyeSA9IG5ldyBHZW9tZXRyeV8xLkdlb21ldHJ5KCk7XG4gICAgICAgIHRoaXMuaW5kZXhCdWZmZXIgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG51bWJlciBvZiBwYXJ0aWNsZXMgdGhlIGJ1ZmZlciBjYW4gaG9sZFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNpemUgPSBzaXplO1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBsaXN0IG9mIHRoZSBwcm9wZXJ0aWVzIHRoYXQgYXJlIGR5bmFtaWMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBtZW1iZXIge29iamVjdFtdfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5keW5hbWljUHJvcGVydGllcyA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBsaXN0IG9mIHRoZSBwcm9wZXJ0aWVzIHRoYXQgYXJlIHN0YXRpYy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQG1lbWJlciB7b2JqZWN0W119XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0YXRpY1Byb3BlcnRpZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wZXJ0aWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgcHJvcGVydHkgPSBwcm9wZXJ0aWVzW2ldO1xuICAgICAgICAgICAgLy8gTWFrZSBjb3B5IG9mIHByb3BlcnRpZXMgb2JqZWN0IHNvIHRoYXQgd2hlbiB3ZSBlZGl0IHRoZSBvZmZzZXQgaXQgZG9lc24ndFxuICAgICAgICAgICAgLy8gY2hhbmdlIGFsbCBvdGhlciBpbnN0YW5jZXMgb2YgdGhlIG9iamVjdCBsaXRlcmFsXG4gICAgICAgICAgICBwcm9wZXJ0eSA9IHtcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVOYW1lOiBwcm9wZXJ0eS5hdHRyaWJ1dGVOYW1lLFxuICAgICAgICAgICAgICAgIHNpemU6IHByb3BlcnR5LnNpemUsXG4gICAgICAgICAgICAgICAgdXBsb2FkRnVuY3Rpb246IHByb3BlcnR5LnVwbG9hZEZ1bmN0aW9uLFxuICAgICAgICAgICAgICAgIHR5cGU6IHByb3BlcnR5LnR5cGUgfHwgV2ViR0xTZXR0aW5nc18xLldlYkdMU2V0dGluZ3MuVFlQRVMuRkxPQVQsXG4gICAgICAgICAgICAgICAgb2Zmc2V0OiBwcm9wZXJ0eS5vZmZzZXQsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKGR5bmFtaWNQcm9wZXJ0eUZsYWdzW2ldKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5keW5hbWljUHJvcGVydGllcy5wdXNoKHByb3BlcnR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGljUHJvcGVydGllcy5wdXNoKHByb3BlcnR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXRpY1N0cmlkZSA9IDA7XG4gICAgICAgIHRoaXMuc3RhdGljQnVmZmVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5zdGF0aWNEYXRhID0gbnVsbDtcbiAgICAgICAgdGhpcy5zdGF0aWNEYXRhVWludDMyID0gbnVsbDtcbiAgICAgICAgdGhpcy5keW5hbWljU3RyaWRlID0gMDtcbiAgICAgICAgdGhpcy5keW5hbWljQnVmZmVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5keW5hbWljRGF0YSA9IG51bGw7XG4gICAgICAgIHRoaXMuZHluYW1pY0RhdGFVaW50MzIgPSBudWxsO1xuICAgICAgICB0aGlzLl91cGRhdGVJRCA9IDA7XG4gICAgICAgIHRoaXMuaW5pdEJ1ZmZlcnMoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB1cCB0aGUgcmVuZGVyZXIgY29udGV4dCBhbmQgbmVjZXNzYXJ5IGJ1ZmZlcnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGluaXRCdWZmZXJzKCkge1xuICAgICAgICB2YXIgZ2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5O1xuICAgICAgICB2YXIgZHluYW1pY09mZnNldCA9IDA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBIb2xkcyB0aGUgaW5kaWNlcyBvZiB0aGUgZ2VvbWV0cnkgKHF1YWRzKSB0byBkcmF3XG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge1VpbnQxNkFycmF5fVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pbmRleEJ1ZmZlciA9IG5ldyBCdWZmZXJfMS5CdWZmZXIoV2ViR0xTZXR0aW5nc18xLldlYkdMU2V0dGluZ3MuY3JlYXRlSW5kaWNlc0ZvclF1YWRzKHRoaXMuc2l6ZSksIHRydWUsIHRydWUpO1xuICAgICAgICBnZW9tZXRyeS5hZGRJbmRleCh0aGlzLmluZGV4QnVmZmVyKTtcbiAgICAgICAgdGhpcy5keW5hbWljU3RyaWRlID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmR5bmFtaWNQcm9wZXJ0aWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgcHJvcGVydHkgPSB0aGlzLmR5bmFtaWNQcm9wZXJ0aWVzW2ldO1xuICAgICAgICAgICAgcHJvcGVydHkub2Zmc2V0ID0gZHluYW1pY09mZnNldDtcbiAgICAgICAgICAgIGR5bmFtaWNPZmZzZXQgKz0gcHJvcGVydHkuc2l6ZTtcbiAgICAgICAgICAgIHRoaXMuZHluYW1pY1N0cmlkZSArPSBwcm9wZXJ0eS5zaXplO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkeW5CdWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIodGhpcy5zaXplICogdGhpcy5keW5hbWljU3RyaWRlICogNCAqIDQpO1xuICAgICAgICB0aGlzLmR5bmFtaWNEYXRhID0gbmV3IEZsb2F0MzJBcnJheShkeW5CdWZmZXIpO1xuICAgICAgICB0aGlzLmR5bmFtaWNEYXRhVWludDMyID0gbmV3IFVpbnQzMkFycmF5KGR5bkJ1ZmZlcik7XG4gICAgICAgIHRoaXMuZHluYW1pY0J1ZmZlciA9IG5ldyBCdWZmZXJfMS5CdWZmZXIodGhpcy5keW5hbWljRGF0YSwgZmFsc2UsIGZhbHNlKTtcbiAgICAgICAgLy8gc3RhdGljIC8vXG4gICAgICAgIHZhciBzdGF0aWNPZmZzZXQgPSAwO1xuICAgICAgICB0aGlzLnN0YXRpY1N0cmlkZSA9IDA7XG4gICAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IHRoaXMuc3RhdGljUHJvcGVydGllcy5sZW5ndGg7ICsraSQxKSB7XG4gICAgICAgICAgICB2YXIgcHJvcGVydHkkMSA9IHRoaXMuc3RhdGljUHJvcGVydGllc1tpJDFdO1xuICAgICAgICAgICAgcHJvcGVydHkkMS5vZmZzZXQgPSBzdGF0aWNPZmZzZXQ7XG4gICAgICAgICAgICBzdGF0aWNPZmZzZXQgKz0gcHJvcGVydHkkMS5zaXplO1xuICAgICAgICAgICAgdGhpcy5zdGF0aWNTdHJpZGUgKz0gcHJvcGVydHkkMS5zaXplO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdGF0QnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKHRoaXMuc2l6ZSAqIHRoaXMuc3RhdGljU3RyaWRlICogNCAqIDQpO1xuICAgICAgICB0aGlzLnN0YXRpY0RhdGEgPSBuZXcgRmxvYXQzMkFycmF5KHN0YXRCdWZmZXIpO1xuICAgICAgICB0aGlzLnN0YXRpY0RhdGFVaW50MzIgPSBuZXcgVWludDMyQXJyYXkoc3RhdEJ1ZmZlcik7XG4gICAgICAgIHRoaXMuc3RhdGljQnVmZmVyID0gbmV3IEJ1ZmZlcl8xLkJ1ZmZlcih0aGlzLnN0YXRpY0RhdGEsIHRydWUsIGZhbHNlKTtcbiAgICAgICAgZm9yICh2YXIgaSQyID0gMDsgaSQyIDwgdGhpcy5keW5hbWljUHJvcGVydGllcy5sZW5ndGg7ICsraSQyKSB7XG4gICAgICAgICAgICB2YXIgcHJvcGVydHkkMiA9IHRoaXMuZHluYW1pY1Byb3BlcnRpZXNbaSQyXTtcbiAgICAgICAgICAgIGdlb21ldHJ5LmFkZEF0dHJpYnV0ZShwcm9wZXJ0eSQyLmF0dHJpYnV0ZU5hbWUsIHRoaXMuZHluYW1pY0J1ZmZlciwgMCwgcHJvcGVydHkkMi50eXBlID09PSBXZWJHTFNldHRpbmdzXzEuV2ViR0xTZXR0aW5ncy5UWVBFUy5VTlNJR05FRF9CWVRFLCBwcm9wZXJ0eSQyLnR5cGUsIHRoaXMuZHluYW1pY1N0cmlkZSAqIDQsIHByb3BlcnR5JDIub2Zmc2V0ICogNCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSQzID0gMDsgaSQzIDwgdGhpcy5zdGF0aWNQcm9wZXJ0aWVzLmxlbmd0aDsgKytpJDMpIHtcbiAgICAgICAgICAgIHZhciBwcm9wZXJ0eSQzID0gdGhpcy5zdGF0aWNQcm9wZXJ0aWVzW2kkM107XG4gICAgICAgICAgICBnZW9tZXRyeS5hZGRBdHRyaWJ1dGUocHJvcGVydHkkMy5hdHRyaWJ1dGVOYW1lLCB0aGlzLnN0YXRpY0J1ZmZlciwgMCwgcHJvcGVydHkkMy50eXBlID09PSBXZWJHTFNldHRpbmdzXzEuV2ViR0xTZXR0aW5ncy5UWVBFUy5VTlNJR05FRF9CWVRFLCBwcm9wZXJ0eSQzLnR5cGUsIHRoaXMuc3RhdGljU3RyaWRlICogNCwgcHJvcGVydHkkMy5vZmZzZXQgKiA0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogVXBsb2FkcyB0aGUgZHluYW1pYyBwcm9wZXJ0aWVzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1BJWEkuRGlzcGxheU9iamVjdFtdfSBjaGlsZHJlbiAtIFRoZSBjaGlsZHJlbiB0byB1cGxvYWQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0SW5kZXggLSBUaGUgaW5kZXggdG8gc3RhcnQgYXQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGFtb3VudCAtIFRoZSBudW1iZXIgdG8gdXBsb2FkLlxuICAgICAqL1xuICAgIHVwbG9hZER5bmFtaWMoY2hpbGRyZW4sIHN0YXJ0SW5kZXgsIGFtb3VudCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZHluYW1pY1Byb3BlcnRpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBwcm9wZXJ0eSA9IHRoaXMuZHluYW1pY1Byb3BlcnRpZXNbaV07XG4gICAgICAgICAgICBwcm9wZXJ0eS51cGxvYWRGdW5jdGlvbihjaGlsZHJlbiwgc3RhcnRJbmRleCwgYW1vdW50LCBwcm9wZXJ0eS50eXBlID09PSBXZWJHTFNldHRpbmdzXzEuV2ViR0xTZXR0aW5ncy5UWVBFUy5VTlNJR05FRF9CWVRFID8gdGhpcy5keW5hbWljRGF0YVVpbnQzMiA6IHRoaXMuZHluYW1pY0RhdGEsIHRoaXMuZHluYW1pY1N0cmlkZSwgcHJvcGVydHkub2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmR5bmFtaWNCdWZmZXIuX3VwZGF0ZUlEKys7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBVcGxvYWRzIHRoZSBzdGF0aWMgcHJvcGVydGllcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtQSVhJLkRpc3BsYXlPYmplY3RbXX0gY2hpbGRyZW4gLSBUaGUgY2hpbGRyZW4gdG8gdXBsb2FkLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydEluZGV4IC0gVGhlIGluZGV4IHRvIHN0YXJ0IGF0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhbW91bnQgLSBUaGUgbnVtYmVyIHRvIHVwbG9hZC5cbiAgICAgKi9cbiAgICB1cGxvYWRTdGF0aWMoY2hpbGRyZW4sIHN0YXJ0SW5kZXgsIGFtb3VudCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuc3RhdGljUHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHByb3BlcnR5ID0gdGhpcy5zdGF0aWNQcm9wZXJ0aWVzW2ldO1xuICAgICAgICAgICAgcHJvcGVydHkudXBsb2FkRnVuY3Rpb24oY2hpbGRyZW4sIHN0YXJ0SW5kZXgsIGFtb3VudCwgcHJvcGVydHkudHlwZSA9PT0gV2ViR0xTZXR0aW5nc18xLldlYkdMU2V0dGluZ3MuVFlQRVMuVU5TSUdORURfQllURSA/IHRoaXMuc3RhdGljRGF0YVVpbnQzMiA6IHRoaXMuc3RhdGljRGF0YSwgdGhpcy5zdGF0aWNTdHJpZGUsIHByb3BlcnR5Lm9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGF0aWNCdWZmZXIuX3VwZGF0ZUlEKys7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBEZXN0cm95cyB0aGUgUGFydGljbGVCdWZmZXIuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuaW5kZXhCdWZmZXIgPSBudWxsO1xuICAgICAgICB0aGlzLmR5bmFtaWNQcm9wZXJ0aWVzID0gbnVsbDtcbiAgICAgICAgLy8gdGhpcy5keW5hbWljQnVmZmVyLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5keW5hbWljQnVmZmVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5keW5hbWljRGF0YSA9IG51bGw7XG4gICAgICAgIHRoaXMuZHluYW1pY0RhdGFVaW50MzIgPSBudWxsO1xuICAgICAgICB0aGlzLnN0YXRpY1Byb3BlcnRpZXMgPSBudWxsO1xuICAgICAgICAvLyB0aGlzLnN0YXRpY0J1ZmZlci5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuc3RhdGljQnVmZmVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5zdGF0aWNEYXRhID0gbnVsbDtcbiAgICAgICAgdGhpcy5zdGF0aWNEYXRhVWludDMyID0gbnVsbDtcbiAgICAgICAgLy8gYWxsIGJ1ZmZlcnMgYXJlIGRlc3Ryb3llZCBpbnNpZGUgZ2VvbWV0cnlcbiAgICAgICAgdGhpcy5nZW9tZXRyeS5kZXN0cm95KCk7XG4gICAgfVxuICAgIDtcbn1cbmV4cG9ydHMuUGFydGljbGVCdWZmZXIgPSBQYXJ0aWNsZUJ1ZmZlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgQ29udGFpbmVyXzEgPSByZXF1aXJlKFwiLi9Db250YWluZXJcIik7XG5jb25zdCBCbGVuZE1vZGVzU2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL0JsZW5kTW9kZXNTZXR0aW5nc1wiKTtcbmNvbnN0IENvbG9yU2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL0NvbG9yU2V0dGluZ3NcIik7XG5jbGFzcyBQYXJ0aWNsZUNvbnRhaW5lciBleHRlbmRzIENvbnRhaW5lcl8xLkNvbnRhaW5lciB7XG4gICAgY29uc3RydWN0b3IobWF4U2l6ZSA9IDE1MDAsIHByb3BlcnRpZXMgPSBudWxsLCBiYXRjaFNpemUgPSAxNjM4NCwgYXV0b1Jlc2l6ZSA9IGZhbHNlKSB7XG4gICAgICAgIGlmIChtYXhTaXplID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIG1heFNpemUgPSAxNTAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChiYXRjaFNpemUgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgYmF0Y2hTaXplID0gMTYzODQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGF1dG9SZXNpemUgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgYXV0b1Jlc2l6ZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIC8vIE1ha2luZyBzdXJlIHRoZSBiYXRjaCBzaXplIGlzIHZhbGlkXG4gICAgICAgIC8vIDY1NTM1IGlzIG1heCB2ZXJ0ZXggaW5kZXggaW4gdGhlIGluZGV4IGJ1ZmZlciAoc2VlIFBhcnRpY2xlUmVuZGVyZXIpXG4gICAgICAgIC8vIHNvIG1heCBudW1iZXIgb2YgcGFydGljbGVzIGlzIDY1NTM2IC8gNCA9IDE2Mzg0XG4gICAgICAgIHZhciBtYXhCYXRjaFNpemUgPSAxNjM4NDtcbiAgICAgICAgaWYgKGJhdGNoU2l6ZSA+IG1heEJhdGNoU2l6ZSkge1xuICAgICAgICAgICAgYmF0Y2hTaXplID0gbWF4QmF0Y2hTaXplO1xuICAgICAgICB9XG4gICAgICAgIGlmIChiYXRjaFNpemUgPiBtYXhTaXplKSB7XG4gICAgICAgICAgICBiYXRjaFNpemUgPSBtYXhTaXplO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgcHJvcGVydGllcyB0byBiZSBkeW5hbWljICh0cnVlKSAvIHN0YXRpYyAoZmFsc2UpXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge2Jvb2xlYW5bXX1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3Byb3BlcnRpZXMgPSBbZmFsc2UsIHRydWUsIGZhbHNlLCBmYWxzZSwgZmFsc2VdO1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fbWF4U2l6ZSA9IG1heFNpemU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9iYXRjaFNpemUgPSBiYXRjaFNpemU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtBcnJheTxQSVhJLkJ1ZmZlcj59XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9idWZmZXJzID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGZvciBldmVyeSBiYXRjaCBzdG9yZXMgX3VwZGF0ZUlEIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGxhc3QgY2hhbmdlIGluIHRoYXQgYmF0Y2hcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyW119XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9idWZmZXJVcGRhdGVJRHMgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHdoZW4gY2hpbGQgaW5zZXJ0ZWQsIHJlbW92ZWQgb3IgY2hhbmdlcyBwb3NpdGlvbiB0aGlzIG51bWJlciBnb2VzIHVwXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcltdfVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fdXBkYXRlSUQgPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaW50ZXJhY3RpdmVDaGlsZHJlbiA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGJsZW5kIG1vZGUgdG8gYmUgYXBwbGllZCB0byB0aGUgc3ByaXRlLiBBcHBseSBhIHZhbHVlIG9mIGBQSVhJLkJMRU5EX01PREVTLk5PUk1BTGBcbiAgICAgICAgICogdG8gcmVzZXQgdGhlIGJsZW5kIG1vZGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgUElYSS5CTEVORF9NT0RFUy5OT1JNQUxcbiAgICAgICAgICogQHNlZSBQSVhJLkJMRU5EX01PREVTXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmJsZW5kTW9kZSA9IEJsZW5kTW9kZXNTZXR0aW5nc18xLkJsZW5kTW9kZXNTZXR0aW5ncy5CTEVORF9NT0RFUy5OT1JNQUw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB0cnVlLCBjb250YWluZXIgYWxsb2NhdGVzIG1vcmUgYmF0Y2hlcyBpbiBjYXNlIHRoZXJlIGFyZSBtb3JlIHRoYW4gYG1heFNpemVgIHBhcnRpY2xlcy5cbiAgICAgICAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICAgICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYXV0b1Jlc2l6ZSA9IGF1dG9SZXNpemU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB0cnVlIFBpeGlKUyB3aWxsIE1hdGguZmxvb3IoKSB4L3kgdmFsdWVzIHdoZW4gcmVuZGVyaW5nLCBzdG9wcGluZyBwaXhlbCBpbnRlcnBvbGF0aW9uLlxuICAgICAgICAgKiBBZHZhbnRhZ2VzIGNhbiBpbmNsdWRlIHNoYXJwZXIgaW1hZ2UgcXVhbGl0eSAobGlrZSB0ZXh0KSBhbmQgZmFzdGVyIHJlbmRlcmluZyBvbiBjYW52YXMuXG4gICAgICAgICAqIFRoZSBtYWluIGRpc2FkdmFudGFnZSBpcyBtb3ZlbWVudCBvZiBvYmplY3RzIG1heSBhcHBlYXIgbGVzcyBzbW9vdGguXG4gICAgICAgICAqIERlZmF1bHQgdG8gdHJ1ZSBoZXJlIGFzIHBlcmZvcm1hbmNlIGlzIHVzdWFsbHkgdGhlIHByaW9yaXR5IGZvciBwYXJ0aWNsZXMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XG4gICAgICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucm91bmRQaXhlbHMgPSB0cnVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHRleHR1cmUgdXNlZCB0byByZW5kZXIgdGhlIGNoaWxkcmVuLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmVhZG9ubHlcbiAgICAgICAgICogQG1lbWJlciB7QmFzZVRleHR1cmV9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmJhc2VUZXh0dXJlID0gbnVsbDtcbiAgICAgICAgdGhpcy5zZXRQcm9wZXJ0aWVzKHByb3BlcnRpZXMpO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHRpbnQgYXBwbGllZCB0byB0aGUgY29udGFpbmVyLlxuICAgICAgICAgKiBUaGlzIGlzIGEgaGV4IHZhbHVlLiBBIHZhbHVlIG9mIDB4RkZGRkZGIHdpbGwgcmVtb3ZlIGFueSB0aW50IGVmZmVjdC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAweEZGRkZGRlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fdGludCA9IDA7XG4gICAgICAgIHRoaXMudGludFJnYiA9IG5ldyBGbG9hdDMyQXJyYXkoNCk7XG4gICAgICAgIHRoaXMudGludCA9IDB4RkZGRkZGO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBwcml2YXRlIHByb3BlcnRpZXMgYXJyYXkgdG8gZHluYW1pYyAvIHN0YXRpYyBiYXNlZCBvbiB0aGUgcGFzc2VkIHByb3BlcnRpZXMgb2JqZWN0XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcHJvcGVydGllcyAtIFRoZSBwcm9wZXJ0aWVzIHRvIGJlIHVwbG9hZGVkXG4gICAgICovXG4gICAgc2V0UHJvcGVydGllcyhwcm9wZXJ0aWVzKSB7XG4gICAgICAgIGlmIChwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICB0aGlzLl9wcm9wZXJ0aWVzWzBdID0gJ3ZlcnRpY2VzJyBpbiBwcm9wZXJ0aWVzIHx8ICdzY2FsZScgaW4gcHJvcGVydGllc1xuICAgICAgICAgICAgICAgID8gISFwcm9wZXJ0aWVzLnZlcnRpY2VzIHx8ICEhcHJvcGVydGllcy5zY2FsZSA6IHRoaXMuX3Byb3BlcnRpZXNbMF07XG4gICAgICAgICAgICB0aGlzLl9wcm9wZXJ0aWVzWzFdID0gJ3Bvc2l0aW9uJyBpbiBwcm9wZXJ0aWVzID8gISFwcm9wZXJ0aWVzLnBvc2l0aW9uIDogdGhpcy5fcHJvcGVydGllc1sxXTtcbiAgICAgICAgICAgIHRoaXMuX3Byb3BlcnRpZXNbMl0gPSAncm90YXRpb24nIGluIHByb3BlcnRpZXMgPyAhIXByb3BlcnRpZXMucm90YXRpb24gOiB0aGlzLl9wcm9wZXJ0aWVzWzJdO1xuICAgICAgICAgICAgdGhpcy5fcHJvcGVydGllc1szXSA9ICd1dnMnIGluIHByb3BlcnRpZXMgPyAhIXByb3BlcnRpZXMudXZzIDogdGhpcy5fcHJvcGVydGllc1szXTtcbiAgICAgICAgICAgIHRoaXMuX3Byb3BlcnRpZXNbNF0gPSAndGludCcgaW4gcHJvcGVydGllcyB8fCAnYWxwaGEnIGluIHByb3BlcnRpZXNcbiAgICAgICAgICAgICAgICA/ICEhcHJvcGVydGllcy50aW50IHx8ICEhcHJvcGVydGllcy5hbHBoYSA6IHRoaXMuX3Byb3BlcnRpZXNbNF07XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIG9iamVjdCB0cmFuc2Zvcm0gZm9yIHJlbmRlcmluZ1xuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB1cGRhdGVUcmFuc2Zvcm0oKSB7XG4gICAgICAgIHN1cGVyLnVwZGF0ZVRyYW5zZm9ybSgpO1xuICAgICAgICAvLyBUT0RPIGRvbid0IG5lZWQgdG8hXG4gICAgICAgIC8vIHRoaXMuZGlzcGxheU9iamVjdFVwZGF0ZVRyYW5zZm9ybSgpO1xuICAgICAgICAvLyAgUElYSS5Db250YWluZXIucHJvdG90eXBlLnVwZGF0ZVRyYW5zZm9ybS5jYWxsKCB0aGlzICk7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBUaGUgdGludCBhcHBsaWVkIHRvIHRoZSBjb250YWluZXIuIFRoaXMgaXMgYSBoZXggdmFsdWUuXG4gICAgICogQSB2YWx1ZSBvZiAweEZGRkZGRiB3aWxsIHJlbW92ZSBhbnkgdGludCBlZmZlY3QuXG4gICAgICoqIElNUE9SVEFOVDogVGhpcyBpcyBhIFdlYkdMIG9ubHkgZmVhdHVyZSBhbmQgd2lsbCBiZSBpZ25vcmVkIGJ5IHRoZSBjYW52YXMgcmVuZGVyZXIuXG4gICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAqIEBkZWZhdWx0IDB4RkZGRkZGXG4gICAgICAgICovXG4gICAgZ2V0IHRpbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90aW50O1xuICAgIH1cbiAgICA7XG4gICAgc2V0IHRpbnQodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fdGludCA9IHZhbHVlO1xuICAgICAgICBDb2xvclNldHRpbmdzXzEuQ29sb3JTZXR0aW5ncy5oZXgycmdiKHZhbHVlLCB0aGlzLnRpbnRSZ2IpO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogUmVuZGVycyB0aGUgY29udGFpbmVyIHVzaW5nIHRoZSBXZWJHTCByZW5kZXJlclxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1BJWEkuUmVuZGVyZXJ9IHJlbmRlcmVyIC0gVGhlIHdlYmdsIHJlbmRlcmVyXG4gICAgICovXG4gICAgcmVuZGVyKHJlbmRlcmVyKSB7XG4gICAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuICAgICAgICBpZiAoIXRoaXMudmlzaWJsZSB8fCB0aGlzLndvcmxkQWxwaGEgPD0gMCB8fCAhdGhpcy5jaGlsZHJlbi5sZW5ndGggfHwgIXRoaXMucmVuZGVyYWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5iYXNlVGV4dHVyZSkge1xuICAgICAgICAgICAgdGhpcy5iYXNlVGV4dHVyZSA9IHRoaXMuY2hpbGRyZW5bMF0uX3RleHR1cmUuYmFzZVRleHR1cmU7XG4gICAgICAgICAgICBpZiAoIXRoaXMuYmFzZVRleHR1cmUudmFsaWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJhc2VUZXh0dXJlLm9uY2UoJ3VwZGF0ZScsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMkMS5vbkNoaWxkcmVuQ2hhbmdlKDApOyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZW5kZXJlci5iYXRjaC5zZXRPYmplY3RSZW5kZXJlcihyZW5kZXJlci5wbHVnaW5zLnBhcnRpY2xlKTtcbiAgICAgICAgcmVuZGVyZXIucGx1Z2lucy5wYXJ0aWNsZS5yZW5kZXIodGhpcyk7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIGZsYWcgdGhhdCBzdGF0aWMgZGF0YSBzaG91bGQgYmUgdXBkYXRlZCB0byB0cnVlXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzbWFsbGVzdENoaWxkSW5kZXggLSBUaGUgc21hbGxlc3QgY2hpbGQgaW5kZXhcbiAgICAgKi9cbiAgICBvbkNoaWxkcmVuQ2hhbmdlKHNtYWxsZXN0Q2hpbGRJbmRleCkge1xuICAgICAgICB2YXIgYnVmZmVySW5kZXggPSBNYXRoLmZsb29yKHNtYWxsZXN0Q2hpbGRJbmRleCAvIHRoaXMuX2JhdGNoU2l6ZSk7XG4gICAgICAgIHdoaWxlICh0aGlzLl9idWZmZXJVcGRhdGVJRHMubGVuZ3RoIDwgYnVmZmVySW5kZXgpIHtcbiAgICAgICAgICAgIHRoaXMuX2J1ZmZlclVwZGF0ZUlEcy5wdXNoKDApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2J1ZmZlclVwZGF0ZUlEc1tidWZmZXJJbmRleF0gPSArK3RoaXMuX3VwZGF0ZUlEO1xuICAgIH1cbiAgICA7XG4gICAgZGlzcG9zZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2J1ZmZlcnMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fYnVmZmVycy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2J1ZmZlcnNbaV0uZGVzdHJveSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fYnVmZmVycyA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIERlc3Ryb3lzIHRoZSBjb250YWluZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fGJvb2xlYW59IFtvcHRpb25zXSAtIE9wdGlvbnMgcGFyYW1ldGVyLiBBIGJvb2xlYW4gd2lsbCBhY3QgYXMgaWYgYWxsIG9wdGlvbnNcbiAgICAgKiAgaGF2ZSBiZWVuIHNldCB0byB0aGF0IHZhbHVlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jaGlsZHJlbj1mYWxzZV0gLSBpZiBzZXQgdG8gdHJ1ZSwgYWxsIHRoZSBjaGlsZHJlbiB3aWxsIGhhdmUgdGhlaXJcbiAgICAgKiAgZGVzdHJveSBtZXRob2QgY2FsbGVkIGFzIHdlbGwuICdvcHRpb25zJyB3aWxsIGJlIHBhc3NlZCBvbiB0byB0aG9zZSBjYWxscy5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRleHR1cmU9ZmFsc2VdIC0gT25seSB1c2VkIGZvciBjaGlsZCBTcHJpdGVzIGlmIG9wdGlvbnMuY2hpbGRyZW4gaXMgc2V0IHRvIHRydWVcbiAgICAgKiAgU2hvdWxkIGl0IGRlc3Ryb3kgdGhlIHRleHR1cmUgb2YgdGhlIGNoaWxkIHNwcml0ZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuYmFzZVRleHR1cmU9ZmFsc2VdIC0gT25seSB1c2VkIGZvciBjaGlsZCBTcHJpdGVzIGlmIG9wdGlvbnMuY2hpbGRyZW4gaXMgc2V0IHRvIHRydWVcbiAgICAgKiAgU2hvdWxkIGl0IGRlc3Ryb3kgdGhlIGJhc2UgdGV4dHVyZSBvZiB0aGUgY2hpbGQgc3ByaXRlXG4gICAgICovXG4gICAgZGVzdHJveShvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyLmRlc3Ryb3kob3B0aW9ucyk7XG4gICAgICAgIHRoaXMuZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLl9wcm9wZXJ0aWVzID0gbnVsbDtcbiAgICAgICAgdGhpcy5fYnVmZmVycyA9IG51bGw7XG4gICAgICAgIHRoaXMuX2J1ZmZlclVwZGF0ZUlEcyA9IG51bGw7XG4gICAgfVxuICAgIDtcbn1cbmV4cG9ydHMuUGFydGljbGVDb250YWluZXIgPSBQYXJ0aWNsZUNvbnRhaW5lcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgT2JqZWN0UmVuZGVyZXJfMSA9IHJlcXVpcmUoXCIuL09iamVjdFJlbmRlcmVyXCIpO1xuY29uc3QgTWF0cml4XzEgPSByZXF1aXJlKFwiLi9NYXRyaXhcIik7XG5jb25zdCBTaGFkZXJfMSA9IHJlcXVpcmUoXCIuL1NoYWRlclwiKTtcbmNvbnN0IFBhcnRpY2xlQnVmZmVyXzEgPSByZXF1aXJlKFwiLi9QYXJ0aWNsZUJ1ZmZlclwiKTtcbmNvbnN0IENvbG9yU2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL0NvbG9yU2V0dGluZ3NcIik7XG5jb25zdCBCbGVuZE1vZGVzU2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL0JsZW5kTW9kZXNTZXR0aW5nc1wiKTtcbmNvbnN0IFdlYkdMU2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL1dlYkdMU2V0dGluZ3NcIik7XG5jbGFzcyBQYXJ0aWNsZVJlbmRlcmVyIGV4dGVuZHMgT2JqZWN0UmVuZGVyZXJfMS5PYmplY3RSZW5kZXJlciB7XG4gICAgY29uc3RydWN0b3IocmVuZGVyZXIpIHtcbiAgICAgICAgc3VwZXIocmVuZGVyZXIpO1xuICAgICAgICAvLyA2NTUzNSBpcyBtYXggdmVydGV4IGluZGV4IGluIHRoZSBpbmRleCBidWZmZXIgKHNlZSBQYXJ0aWNsZVJlbmRlcmVyKVxuICAgICAgICAvLyBzbyBtYXggbnVtYmVyIG9mIHBhcnRpY2xlcyBpcyA2NTUzNiAvIDQgPSAxNjM4NFxuICAgICAgICAvLyBhbmQgbWF4IG51bWJlciBvZiBlbGVtZW50IGluIHRoZSBpbmRleCBidWZmZXIgaXMgMTYzODQgKiA2ID0gOTgzMDRcbiAgICAgICAgLy8gQ3JlYXRpbmcgYSBmdWxsIGluZGV4IGJ1ZmZlciwgb3ZlcmhlYWQgaXMgOTgzMDQgKiAyID0gMTk2S29cbiAgICAgICAgLy8gbGV0IG51bUluZGljZXMgPSA5ODMwNDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBkZWZhdWx0IHNoYWRlciB0aGF0IGlzIHVzZWQgaWYgYSBzcHJpdGUgZG9lc24ndCBoYXZlIGEgbW9yZSBzcGVjaWZpYyBvbmUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuU2hhZGVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zaGFkZXIgPSBudWxsO1xuICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSBudWxsO1xuICAgICAgICB0aGlzLnRlbXBNYXRyaXggPSBuZXcgTWF0cml4XzEuTWF0cml4KCk7XG4gICAgICAgIHRoaXMucHJvcGVydGllcyA9IFtcbiAgICAgICAgICAgIC8vIHZlcnRpY2VzRGF0YVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZU5hbWU6ICdhVmVydGV4UG9zaXRpb24nLFxuICAgICAgICAgICAgICAgIHNpemU6IDIsXG4gICAgICAgICAgICAgICAgdXBsb2FkRnVuY3Rpb246IHRoaXMudXBsb2FkVmVydGljZXMsXG4gICAgICAgICAgICAgICAgb2Zmc2V0OiAwLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIHBvc2l0aW9uRGF0YVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZU5hbWU6ICdhUG9zaXRpb25Db29yZCcsXG4gICAgICAgICAgICAgICAgc2l6ZTogMixcbiAgICAgICAgICAgICAgICB1cGxvYWRGdW5jdGlvbjogdGhpcy51cGxvYWRQb3NpdGlvbixcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IDAsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gcm90YXRpb25EYXRhXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgYXR0cmlidXRlTmFtZTogJ2FSb3RhdGlvbicsXG4gICAgICAgICAgICAgICAgc2l6ZTogMSxcbiAgICAgICAgICAgICAgICB1cGxvYWRGdW5jdGlvbjogdGhpcy51cGxvYWRSb3RhdGlvbixcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IDAsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gdXZzRGF0YVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZU5hbWU6ICdhVGV4dHVyZUNvb3JkJyxcbiAgICAgICAgICAgICAgICBzaXplOiAyLFxuICAgICAgICAgICAgICAgIHVwbG9hZEZ1bmN0aW9uOiB0aGlzLnVwbG9hZFV2cyxcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IDAsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gdGludERhdGFcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVOYW1lOiAnYUNvbG9yJyxcbiAgICAgICAgICAgICAgICBzaXplOiAxLFxuICAgICAgICAgICAgICAgIHR5cGU6IFdlYkdMU2V0dGluZ3NfMS5XZWJHTFNldHRpbmdzLlRZUEVTLlVOU0lHTkVEX0JZVEUsXG4gICAgICAgICAgICAgICAgdXBsb2FkRnVuY3Rpb246IHRoaXMudXBsb2FkVGludCxcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IDAsXG4gICAgICAgICAgICB9XG4gICAgICAgIF07XG4gICAgICAgIHRoaXMuc2hhZGVyID0gU2hhZGVyXzEuU2hhZGVyLmZyb20oUGFydGljbGVSZW5kZXJlci52ZXJ0ZXgkMiwgUGFydGljbGVSZW5kZXJlci5mcmFnbWVudCQxLCB7fSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgdGhlIHBhcnRpY2xlIGNvbnRhaW5lciBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BJWEkuUGFydGljbGVDb250YWluZXJ9IGNvbnRhaW5lciAtIFRoZSBjb250YWluZXIgdG8gcmVuZGVyIHVzaW5nIHRoaXMgUGFydGljbGVSZW5kZXJlclxuICAgICAqL1xuICAgIHJlbmRlcihjb250YWluZXIpIHtcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gY29udGFpbmVyLmNoaWxkcmVuO1xuICAgICAgICB2YXIgbWF4U2l6ZSA9IGNvbnRhaW5lci5fbWF4U2l6ZTtcbiAgICAgICAgdmFyIGJhdGNoU2l6ZSA9IGNvbnRhaW5lci5fYmF0Y2hTaXplO1xuICAgICAgICB2YXIgcmVuZGVyZXIgPSB0aGlzLnJlbmRlcmVyO1xuICAgICAgICB2YXIgdG90YWxDaGlsZHJlbiA9IGNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgaWYgKHRvdGFsQ2hpbGRyZW4gPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0b3RhbENoaWxkcmVuID4gbWF4U2l6ZSkge1xuICAgICAgICAgICAgdG90YWxDaGlsZHJlbiA9IG1heFNpemU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJ1ZmZlcnMgPSBjb250YWluZXIuX2J1ZmZlcnM7XG4gICAgICAgIGlmICghYnVmZmVycykge1xuICAgICAgICAgICAgYnVmZmVycyA9IGNvbnRhaW5lci5fYnVmZmVycyA9IHRoaXMuZ2VuZXJhdGVCdWZmZXJzKGNvbnRhaW5lcik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJhc2VUZXh0dXJlID0gY2hpbGRyZW5bMF0uX3RleHR1cmUuYmFzZVRleHR1cmU7XG4gICAgICAgIC8vIGlmIHRoZSB1dnMgaGF2ZSBub3QgdXBkYXRlZCB0aGVuIG5vIHBvaW50IHJlbmRlcmluZyBqdXN0IHlldCFcbiAgICAgICAgdGhpcy5yZW5kZXJlci5zdGF0ZS5zZXRCbGVuZE1vZGUoQmxlbmRNb2Rlc1NldHRpbmdzXzEuQmxlbmRNb2Rlc1NldHRpbmdzLmNvcnJlY3RCbGVuZE1vZGUoY29udGFpbmVyLmJsZW5kTW9kZSwgYmFzZVRleHR1cmUucHJlbXVsdGlwbHlBbHBoYSkpO1xuICAgICAgICB2YXIgZ2wgPSByZW5kZXJlci5nbDtcbiAgICAgICAgdmFyIG0gPSBjb250YWluZXIud29ybGRUcmFuc2Zvcm0uY29weVRvKHRoaXMudGVtcE1hdHJpeCk7XG4gICAgICAgIG0ucHJlcGVuZChyZW5kZXJlci5nbG9iYWxVbmlmb3Jtcy51bmlmb3Jtcy5wcm9qZWN0aW9uTWF0cml4KTtcbiAgICAgICAgdGhpcy5zaGFkZXIudW5pZm9ybXMudHJhbnNsYXRpb25NYXRyaXggPSBtLnRvQXJyYXkodHJ1ZSk7XG4gICAgICAgIHRoaXMuc2hhZGVyLnVuaWZvcm1zLnVDb2xvciA9IENvbG9yU2V0dGluZ3NfMS5Db2xvclNldHRpbmdzLnByZW11bHRpcGx5UmdiYShjb250YWluZXIudGludFJnYiwgY29udGFpbmVyLndvcmxkQWxwaGEsIHRoaXMuc2hhZGVyLnVuaWZvcm1zLnVDb2xvciwgYmFzZVRleHR1cmUucHJlbXVsdGlwbHlBbHBoYSk7XG4gICAgICAgIHRoaXMuc2hhZGVyLnVuaWZvcm1zLnVTYW1wbGVyID0gYmFzZVRleHR1cmU7XG4gICAgICAgIHRoaXMucmVuZGVyZXIuc2hhZGVyLmJpbmQodGhpcy5zaGFkZXIpO1xuICAgICAgICB2YXIgdXBkYXRlU3RhdGljID0gZmFsc2U7XG4gICAgICAgIC8vIG5vdyBsZXRzIHVwbG9hZCBhbmQgcmVuZGVyIHRoZSBidWZmZXJzLi5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGogPSAwOyBpIDwgdG90YWxDaGlsZHJlbjsgaSArPSBiYXRjaFNpemUsIGogKz0gMSkge1xuICAgICAgICAgICAgdmFyIGFtb3VudCA9ICh0b3RhbENoaWxkcmVuIC0gaSk7XG4gICAgICAgICAgICBpZiAoYW1vdW50ID4gYmF0Y2hTaXplKSB7XG4gICAgICAgICAgICAgICAgYW1vdW50ID0gYmF0Y2hTaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGogPj0gYnVmZmVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWNvbnRhaW5lci5hdXRvUmVzaXplKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBidWZmZXJzLnB1c2godGhpcy5fZ2VuZXJhdGVPbmVNb3JlQnVmZmVyKGNvbnRhaW5lcikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGJ1ZmZlciA9IGJ1ZmZlcnNbal07XG4gICAgICAgICAgICAvLyB3ZSBhbHdheXMgdXBsb2FkIHRoZSBkeW5hbWljXG4gICAgICAgICAgICBidWZmZXIudXBsb2FkRHluYW1pYyhjaGlsZHJlbiwgaSwgYW1vdW50KTtcbiAgICAgICAgICAgIHZhciBiaWQgPSBjb250YWluZXIuX2J1ZmZlclVwZGF0ZUlEc1tqXSB8fCAwO1xuICAgICAgICAgICAgdXBkYXRlU3RhdGljID0gdXBkYXRlU3RhdGljIHx8IChidWZmZXIuX3VwZGF0ZUlEIDwgYmlkKTtcbiAgICAgICAgICAgIC8vIHdlIG9ubHkgdXBsb2FkIHRoZSBzdGF0aWMgY29udGVudCB3aGVuIHdlIGhhdmUgdG8hXG4gICAgICAgICAgICBpZiAodXBkYXRlU3RhdGljKSB7XG4gICAgICAgICAgICAgICAgYnVmZmVyLl91cGRhdGVJRCA9IGNvbnRhaW5lci5fdXBkYXRlSUQ7XG4gICAgICAgICAgICAgICAgYnVmZmVyLnVwbG9hZFN0YXRpYyhjaGlsZHJlbiwgaSwgYW1vdW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGJpbmQgdGhlIGJ1ZmZlclxuICAgICAgICAgICAgcmVuZGVyZXIuZ2VvbWV0cnkuYmluZChidWZmZXIuZ2VvbWV0cnkpO1xuICAgICAgICAgICAgZ2wuZHJhd0VsZW1lbnRzKGdsLlRSSUFOR0xFUywgYW1vdW50ICogNiwgZ2wuVU5TSUdORURfU0hPUlQsIDApO1xuICAgICAgICB9XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIG9uZSBwYXJ0aWNsZSBidWZmZXIgZm9yIGVhY2ggY2hpbGQgaW4gdGhlIGNvbnRhaW5lciB3ZSB3YW50IHRvIHJlbmRlciBhbmQgdXBkYXRlcyBpbnRlcm5hbCBwcm9wZXJ0aWVzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BJWEkuUGFydGljbGVDb250YWluZXJ9IGNvbnRhaW5lciAtIFRoZSBjb250YWluZXIgdG8gcmVuZGVyIHVzaW5nIHRoaXMgUGFydGljbGVSZW5kZXJlclxuICAgICAqIEByZXR1cm4ge1BJWEkuUGFydGljbGVCdWZmZXJbXX0gVGhlIGJ1ZmZlcnNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGdlbmVyYXRlQnVmZmVycyhjb250YWluZXIpIHtcbiAgICAgICAgdmFyIGJ1ZmZlcnMgPSBbXTtcbiAgICAgICAgdmFyIHNpemUgPSBjb250YWluZXIuX21heFNpemU7XG4gICAgICAgIHZhciBiYXRjaFNpemUgPSBjb250YWluZXIuX2JhdGNoU2l6ZTtcbiAgICAgICAgdmFyIGR5bmFtaWNQcm9wZXJ0eUZsYWdzID0gY29udGFpbmVyLl9wcm9wZXJ0aWVzO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7IGkgKz0gYmF0Y2hTaXplKSB7XG4gICAgICAgICAgICBidWZmZXJzLnB1c2gobmV3IFBhcnRpY2xlQnVmZmVyXzEuUGFydGljbGVCdWZmZXIodGhpcy5wcm9wZXJ0aWVzLCBkeW5hbWljUHJvcGVydHlGbGFncywgYmF0Y2hTaXplKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJ1ZmZlcnM7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIG9uZSBtb3JlIHBhcnRpY2xlIGJ1ZmZlciwgYmVjYXVzZSBjb250YWluZXIgaGFzIGF1dG9SZXNpemUgZmVhdHVyZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtQSVhJLlBhcnRpY2xlQ29udGFpbmVyfSBjb250YWluZXIgLSBUaGUgY29udGFpbmVyIHRvIHJlbmRlciB1c2luZyB0aGlzIFBhcnRpY2xlUmVuZGVyZXJcbiAgICAgKiBAcmV0dXJuIHtQSVhJLlBhcnRpY2xlQnVmZmVyfSBnZW5lcmF0ZWQgYnVmZmVyXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2VuZXJhdGVPbmVNb3JlQnVmZmVyKGNvbnRhaW5lcikge1xuICAgICAgICB2YXIgYmF0Y2hTaXplID0gY29udGFpbmVyLl9iYXRjaFNpemU7XG4gICAgICAgIHZhciBkeW5hbWljUHJvcGVydHlGbGFncyA9IGNvbnRhaW5lci5fcHJvcGVydGllcztcbiAgICAgICAgcmV0dXJuIG5ldyBQYXJ0aWNsZUJ1ZmZlcl8xLlBhcnRpY2xlQnVmZmVyKHRoaXMucHJvcGVydGllcywgZHluYW1pY1Byb3BlcnR5RmxhZ3MsIGJhdGNoU2l6ZSk7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBVcGxvYWRzIHRoZSB2ZXJ0aWNlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UElYSS5EaXNwbGF5T2JqZWN0W119IGNoaWxkcmVuIC0gdGhlIGFycmF5IG9mIGRpc3BsYXkgb2JqZWN0cyB0byByZW5kZXJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnRJbmRleCAtIHRoZSBpbmRleCB0byBzdGFydCBmcm9tIGluIHRoZSBjaGlsZHJlbiBhcnJheVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhbW91bnQgLSB0aGUgYW1vdW50IG9mIGNoaWxkcmVuIHRoYXQgd2lsbCBoYXZlIHRoZWlyIHZlcnRpY2VzIHVwbG9hZGVkXG4gICAgICogQHBhcmFtIHtudW1iZXJbXX0gYXJyYXkgLSBUaGUgdmVydGljZXMgdG8gdXBsb2FkLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgLSBTdHJpZGUgdG8gdXNlIGZvciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCAtIE9mZnNldCB0byBzdGFydCBhdC5cbiAgICAgKi9cbiAgICB1cGxvYWRWZXJ0aWNlcyhjaGlsZHJlbiwgc3RhcnRJbmRleCwgYW1vdW50LCBhcnJheSwgc3RyaWRlLCBvZmZzZXQpIHtcbiAgICAgICAgdmFyIHcwID0gMDtcbiAgICAgICAgdmFyIHcxID0gMDtcbiAgICAgICAgdmFyIGgwID0gMDtcbiAgICAgICAgdmFyIGgxID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbW91bnQ7ICsraSkge1xuICAgICAgICAgICAgdmFyIHNwcml0ZSA9IGNoaWxkcmVuW3N0YXJ0SW5kZXggKyBpXTtcbiAgICAgICAgICAgIHZhciB0ZXh0dXJlID0gc3ByaXRlLl90ZXh0dXJlO1xuICAgICAgICAgICAgdmFyIHN4ID0gc3ByaXRlLnNjYWxlLng7XG4gICAgICAgICAgICB2YXIgc3kgPSBzcHJpdGUuc2NhbGUueTtcbiAgICAgICAgICAgIHZhciB0cmltID0gdGV4dHVyZS50cmltO1xuICAgICAgICAgICAgdmFyIG9yaWcgPSB0ZXh0dXJlLm9yaWc7XG4gICAgICAgICAgICBpZiAodHJpbSkge1xuICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBzcHJpdGUgaXMgdHJpbW1lZCBhbmQgaXMgbm90IGEgdGlsaW5nc3ByaXRlIHRoZW4gd2UgbmVlZCB0byBhZGQgdGhlXG4gICAgICAgICAgICAgICAgLy8gZXh0cmEgc3BhY2UgYmVmb3JlIHRyYW5zZm9ybWluZyB0aGUgc3ByaXRlIGNvb3Jkcy4uXG4gICAgICAgICAgICAgICAgdzEgPSB0cmltLnggLSAoc3ByaXRlLmFuY2hvci54ICogb3JpZy53aWR0aCk7XG4gICAgICAgICAgICAgICAgdzAgPSB3MSArIHRyaW0ud2lkdGg7XG4gICAgICAgICAgICAgICAgaDEgPSB0cmltLnkgLSAoc3ByaXRlLmFuY2hvci55ICogb3JpZy5oZWlnaHQpO1xuICAgICAgICAgICAgICAgIGgwID0gaDEgKyB0cmltLmhlaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHcwID0gKG9yaWcud2lkdGgpICogKDEgLSBzcHJpdGUuYW5jaG9yLngpO1xuICAgICAgICAgICAgICAgIHcxID0gKG9yaWcud2lkdGgpICogLXNwcml0ZS5hbmNob3IueDtcbiAgICAgICAgICAgICAgICBoMCA9IG9yaWcuaGVpZ2h0ICogKDEgLSBzcHJpdGUuYW5jaG9yLnkpO1xuICAgICAgICAgICAgICAgIGgxID0gb3JpZy5oZWlnaHQgKiAtc3ByaXRlLmFuY2hvci55O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXJyYXlbb2Zmc2V0XSA9IHcxICogc3g7XG4gICAgICAgICAgICBhcnJheVtvZmZzZXQgKyAxXSA9IGgxICogc3k7XG4gICAgICAgICAgICBhcnJheVtvZmZzZXQgKyBzdHJpZGVdID0gdzAgKiBzeDtcbiAgICAgICAgICAgIGFycmF5W29mZnNldCArIHN0cmlkZSArIDFdID0gaDEgKiBzeTtcbiAgICAgICAgICAgIGFycmF5W29mZnNldCArIChzdHJpZGUgKiAyKV0gPSB3MCAqIHN4O1xuICAgICAgICAgICAgYXJyYXlbb2Zmc2V0ICsgKHN0cmlkZSAqIDIpICsgMV0gPSBoMCAqIHN5O1xuICAgICAgICAgICAgYXJyYXlbb2Zmc2V0ICsgKHN0cmlkZSAqIDMpXSA9IHcxICogc3g7XG4gICAgICAgICAgICBhcnJheVtvZmZzZXQgKyAoc3RyaWRlICogMykgKyAxXSA9IGgwICogc3k7XG4gICAgICAgICAgICBvZmZzZXQgKz0gc3RyaWRlICogNDtcbiAgICAgICAgfVxuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogVXBsb2FkcyB0aGUgcG9zaXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BJWEkuRGlzcGxheU9iamVjdFtdfSBjaGlsZHJlbiAtIHRoZSBhcnJheSBvZiBkaXNwbGF5IG9iamVjdHMgdG8gcmVuZGVyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0SW5kZXggLSB0aGUgaW5kZXggdG8gc3RhcnQgZnJvbSBpbiB0aGUgY2hpbGRyZW4gYXJyYXlcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYW1vdW50IC0gdGhlIGFtb3VudCBvZiBjaGlsZHJlbiB0aGF0IHdpbGwgaGF2ZSB0aGVpciBwb3NpdGlvbnMgdXBsb2FkZWRcbiAgICAgKiBAcGFyYW0ge251bWJlcltdfSBhcnJheSAtIFRoZSB2ZXJ0aWNlcyB0byB1cGxvYWQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0cmlkZSAtIFN0cmlkZSB0byB1c2UgZm9yIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IC0gT2Zmc2V0IHRvIHN0YXJ0IGF0LlxuICAgICAqL1xuICAgIHVwbG9hZFBvc2l0aW9uKGNoaWxkcmVuLCBzdGFydEluZGV4LCBhbW91bnQsIGFycmF5LCBzdHJpZGUsIG9mZnNldCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFtb3VudDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgc3ByaXRlUG9zaXRpb24gPSBjaGlsZHJlbltzdGFydEluZGV4ICsgaV0ucG9zaXRpb247XG4gICAgICAgICAgICBhcnJheVtvZmZzZXRdID0gc3ByaXRlUG9zaXRpb24ueDtcbiAgICAgICAgICAgIGFycmF5W29mZnNldCArIDFdID0gc3ByaXRlUG9zaXRpb24ueTtcbiAgICAgICAgICAgIGFycmF5W29mZnNldCArIHN0cmlkZV0gPSBzcHJpdGVQb3NpdGlvbi54O1xuICAgICAgICAgICAgYXJyYXlbb2Zmc2V0ICsgc3RyaWRlICsgMV0gPSBzcHJpdGVQb3NpdGlvbi55O1xuICAgICAgICAgICAgYXJyYXlbb2Zmc2V0ICsgKHN0cmlkZSAqIDIpXSA9IHNwcml0ZVBvc2l0aW9uLng7XG4gICAgICAgICAgICBhcnJheVtvZmZzZXQgKyAoc3RyaWRlICogMikgKyAxXSA9IHNwcml0ZVBvc2l0aW9uLnk7XG4gICAgICAgICAgICBhcnJheVtvZmZzZXQgKyAoc3RyaWRlICogMyldID0gc3ByaXRlUG9zaXRpb24ueDtcbiAgICAgICAgICAgIGFycmF5W29mZnNldCArIChzdHJpZGUgKiAzKSArIDFdID0gc3ByaXRlUG9zaXRpb24ueTtcbiAgICAgICAgICAgIG9mZnNldCArPSBzdHJpZGUgKiA0O1xuICAgICAgICB9XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBVcGxvYWRzIHRoZSByb3RpYXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BJWEkuRGlzcGxheU9iamVjdFtdfSBjaGlsZHJlbiAtIHRoZSBhcnJheSBvZiBkaXNwbGF5IG9iamVjdHMgdG8gcmVuZGVyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0SW5kZXggLSB0aGUgaW5kZXggdG8gc3RhcnQgZnJvbSBpbiB0aGUgY2hpbGRyZW4gYXJyYXlcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYW1vdW50IC0gdGhlIGFtb3VudCBvZiBjaGlsZHJlbiB0aGF0IHdpbGwgaGF2ZSB0aGVpciByb3RhdGlvbiB1cGxvYWRlZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyW119IGFycmF5IC0gVGhlIHZlcnRpY2VzIHRvIHVwbG9hZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RyaWRlIC0gU3RyaWRlIHRvIHVzZSBmb3IgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgLSBPZmZzZXQgdG8gc3RhcnQgYXQuXG4gICAgICovXG4gICAgdXBsb2FkUm90YXRpb24oY2hpbGRyZW4sIHN0YXJ0SW5kZXgsIGFtb3VudCwgYXJyYXksIHN0cmlkZSwgb2Zmc2V0KSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYW1vdW50OyBpKyspIHtcbiAgICAgICAgICAgIHZhciBzcHJpdGVSb3RhdGlvbiA9IGNoaWxkcmVuW3N0YXJ0SW5kZXggKyBpXS5yb3RhdGlvbjtcbiAgICAgICAgICAgIGFycmF5W29mZnNldF0gPSBzcHJpdGVSb3RhdGlvbjtcbiAgICAgICAgICAgIGFycmF5W29mZnNldCArIHN0cmlkZV0gPSBzcHJpdGVSb3RhdGlvbjtcbiAgICAgICAgICAgIGFycmF5W29mZnNldCArIChzdHJpZGUgKiAyKV0gPSBzcHJpdGVSb3RhdGlvbjtcbiAgICAgICAgICAgIGFycmF5W29mZnNldCArIChzdHJpZGUgKiAzKV0gPSBzcHJpdGVSb3RhdGlvbjtcbiAgICAgICAgICAgIG9mZnNldCArPSBzdHJpZGUgKiA0O1xuICAgICAgICB9XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBVcGxvYWRzIHRoZSBVdnNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UElYSS5EaXNwbGF5T2JqZWN0W119IGNoaWxkcmVuIC0gdGhlIGFycmF5IG9mIGRpc3BsYXkgb2JqZWN0cyB0byByZW5kZXJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnRJbmRleCAtIHRoZSBpbmRleCB0byBzdGFydCBmcm9tIGluIHRoZSBjaGlsZHJlbiBhcnJheVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhbW91bnQgLSB0aGUgYW1vdW50IG9mIGNoaWxkcmVuIHRoYXQgd2lsbCBoYXZlIHRoZWlyIHJvdGF0aW9uIHVwbG9hZGVkXG4gICAgICogQHBhcmFtIHtudW1iZXJbXX0gYXJyYXkgLSBUaGUgdmVydGljZXMgdG8gdXBsb2FkLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgLSBTdHJpZGUgdG8gdXNlIGZvciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCAtIE9mZnNldCB0byBzdGFydCBhdC5cbiAgICAgKi9cbiAgICB1cGxvYWRVdnMoY2hpbGRyZW4sIHN0YXJ0SW5kZXgsIGFtb3VudCwgYXJyYXksIHN0cmlkZSwgb2Zmc2V0KSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYW1vdW50OyArK2kpIHtcbiAgICAgICAgICAgIHZhciB0ZXh0dXJlVXZzID0gY2hpbGRyZW5bc3RhcnRJbmRleCArIGldLl90ZXh0dXJlLl91dnM7XG4gICAgICAgICAgICBpZiAodGV4dHVyZVV2cykge1xuICAgICAgICAgICAgICAgIGFycmF5W29mZnNldF0gPSB0ZXh0dXJlVXZzLngwO1xuICAgICAgICAgICAgICAgIGFycmF5W29mZnNldCArIDFdID0gdGV4dHVyZVV2cy55MDtcbiAgICAgICAgICAgICAgICBhcnJheVtvZmZzZXQgKyBzdHJpZGVdID0gdGV4dHVyZVV2cy54MTtcbiAgICAgICAgICAgICAgICBhcnJheVtvZmZzZXQgKyBzdHJpZGUgKyAxXSA9IHRleHR1cmVVdnMueTE7XG4gICAgICAgICAgICAgICAgYXJyYXlbb2Zmc2V0ICsgKHN0cmlkZSAqIDIpXSA9IHRleHR1cmVVdnMueDI7XG4gICAgICAgICAgICAgICAgYXJyYXlbb2Zmc2V0ICsgKHN0cmlkZSAqIDIpICsgMV0gPSB0ZXh0dXJlVXZzLnkyO1xuICAgICAgICAgICAgICAgIGFycmF5W29mZnNldCArIChzdHJpZGUgKiAzKV0gPSB0ZXh0dXJlVXZzLngzO1xuICAgICAgICAgICAgICAgIGFycmF5W29mZnNldCArIChzdHJpZGUgKiAzKSArIDFdID0gdGV4dHVyZVV2cy55MztcbiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gc3RyaWRlICogNDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFRPRE8geW91IGtub3cgdGhpcyBjYW4gYmUgZWFzaWVyIVxuICAgICAgICAgICAgICAgIGFycmF5W29mZnNldF0gPSAwO1xuICAgICAgICAgICAgICAgIGFycmF5W29mZnNldCArIDFdID0gMDtcbiAgICAgICAgICAgICAgICBhcnJheVtvZmZzZXQgKyBzdHJpZGVdID0gMDtcbiAgICAgICAgICAgICAgICBhcnJheVtvZmZzZXQgKyBzdHJpZGUgKyAxXSA9IDA7XG4gICAgICAgICAgICAgICAgYXJyYXlbb2Zmc2V0ICsgKHN0cmlkZSAqIDIpXSA9IDA7XG4gICAgICAgICAgICAgICAgYXJyYXlbb2Zmc2V0ICsgKHN0cmlkZSAqIDIpICsgMV0gPSAwO1xuICAgICAgICAgICAgICAgIGFycmF5W29mZnNldCArIChzdHJpZGUgKiAzKV0gPSAwO1xuICAgICAgICAgICAgICAgIGFycmF5W29mZnNldCArIChzdHJpZGUgKiAzKSArIDFdID0gMDtcbiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gc3RyaWRlICogNDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogVXBsb2FkcyB0aGUgdGludC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UElYSS5EaXNwbGF5T2JqZWN0W119IGNoaWxkcmVuIC0gdGhlIGFycmF5IG9mIGRpc3BsYXkgb2JqZWN0cyB0byByZW5kZXJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnRJbmRleCAtIHRoZSBpbmRleCB0byBzdGFydCBmcm9tIGluIHRoZSBjaGlsZHJlbiBhcnJheVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhbW91bnQgLSB0aGUgYW1vdW50IG9mIGNoaWxkcmVuIHRoYXQgd2lsbCBoYXZlIHRoZWlyIHJvdGF0aW9uIHVwbG9hZGVkXG4gICAgICogQHBhcmFtIHtudW1iZXJbXX0gYXJyYXkgLSBUaGUgdmVydGljZXMgdG8gdXBsb2FkLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdHJpZGUgLSBTdHJpZGUgdG8gdXNlIGZvciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldCAtIE9mZnNldCB0byBzdGFydCBhdC5cbiAgICAgKi9cbiAgICB1cGxvYWRUaW50KGNoaWxkcmVuLCBzdGFydEluZGV4LCBhbW91bnQsIGFycmF5LCBzdHJpZGUsIG9mZnNldCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFtb3VudDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgc3ByaXRlID0gY2hpbGRyZW5bc3RhcnRJbmRleCArIGldO1xuICAgICAgICAgICAgdmFyIHByZW11bHRpcGxpZWQgPSBzcHJpdGUuX3RleHR1cmUuYmFzZVRleHR1cmUucHJlbXVsdGlwbHlBbHBoYTtcbiAgICAgICAgICAgIHZhciBhbHBoYSA9IHNwcml0ZS5hbHBoYTtcbiAgICAgICAgICAgIC8vIHdlIGRvbnQgY2FsbCBleHRyYSBmdW5jdGlvbiBpZiBhbHBoYSBpcyAxLjAsIHRoYXQncyBmYXN0ZXJcbiAgICAgICAgICAgIHZhciBhcmdiID0gYWxwaGEgPCAxLjAgJiYgcHJlbXVsdGlwbGllZCA/IENvbG9yU2V0dGluZ3NfMS5Db2xvclNldHRpbmdzLnByZW11bHRpcGx5VGludChzcHJpdGUuX3RpbnRSR0IsIGFscGhhKVxuICAgICAgICAgICAgICAgIDogc3ByaXRlLl90aW50UkdCICsgKGFscGhhICogMjU1IDw8IDI0KTtcbiAgICAgICAgICAgIGFycmF5W29mZnNldF0gPSBhcmdiO1xuICAgICAgICAgICAgYXJyYXlbb2Zmc2V0ICsgc3RyaWRlXSA9IGFyZ2I7XG4gICAgICAgICAgICBhcnJheVtvZmZzZXQgKyAoc3RyaWRlICogMildID0gYXJnYjtcbiAgICAgICAgICAgIGFycmF5W29mZnNldCArIChzdHJpZGUgKiAzKV0gPSBhcmdiO1xuICAgICAgICAgICAgb2Zmc2V0ICs9IHN0cmlkZSAqIDQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIERlc3Ryb3lzIHRoZSBQYXJ0aWNsZVJlbmRlcmVyLlxuICAgICAqL1xuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgICAgICAgaWYgKHRoaXMuc2hhZGVyKSB7XG4gICAgICAgICAgICB0aGlzLnNoYWRlci5kZXN0cm95KCk7XG4gICAgICAgICAgICB0aGlzLnNoYWRlciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50ZW1wTWF0cml4ID0gbnVsbDtcbiAgICB9XG4gICAgO1xufVxuUGFydGljbGVSZW5kZXJlci52ZXJ0ZXgkMiA9IFwiYXR0cmlidXRlIHZlYzIgYVZlcnRleFBvc2l0aW9uO1xcclxcbmF0dHJpYnV0ZSB2ZWMyIGFUZXh0dXJlQ29vcmQ7XFxyXFxuYXR0cmlidXRlIHZlYzQgYUNvbG9yO1xcclxcblxcclxcbmF0dHJpYnV0ZSB2ZWMyIGFQb3NpdGlvbkNvb3JkO1xcclxcbmF0dHJpYnV0ZSBmbG9hdCBhUm90YXRpb247XFxyXFxuXFxyXFxudW5pZm9ybSBtYXQzIHRyYW5zbGF0aW9uTWF0cml4O1xcclxcbnVuaWZvcm0gdmVjNCB1Q29sb3I7XFxyXFxuXFxyXFxudmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XFxyXFxudmFyeWluZyB2ZWM0IHZDb2xvcjtcXHJcXG5cXHJcXG52b2lkIG1haW4odm9pZCl7XFxyXFxuICAgIGZsb2F0IHggPSAoYVZlcnRleFBvc2l0aW9uLngpICogY29zKGFSb3RhdGlvbikgLSAoYVZlcnRleFBvc2l0aW9uLnkpICogc2luKGFSb3RhdGlvbik7XFxyXFxuICAgIGZsb2F0IHkgPSAoYVZlcnRleFBvc2l0aW9uLngpICogc2luKGFSb3RhdGlvbikgKyAoYVZlcnRleFBvc2l0aW9uLnkpICogY29zKGFSb3RhdGlvbik7XFxyXFxuXFxyXFxuICAgIHZlYzIgdiA9IHZlYzIoeCwgeSk7XFxyXFxuICAgIHYgPSB2ICsgYVBvc2l0aW9uQ29vcmQ7XFxyXFxuXFxyXFxuICAgIGdsX1Bvc2l0aW9uID0gdmVjNCgodHJhbnNsYXRpb25NYXRyaXggKiB2ZWMzKHYsIDEuMCkpLnh5LCAwLjAsIDEuMCk7XFxyXFxuXFxyXFxuICAgIHZUZXh0dXJlQ29vcmQgPSBhVGV4dHVyZUNvb3JkO1xcclxcbiAgICB2Q29sb3IgPSBhQ29sb3IgKiB1Q29sb3I7XFxyXFxufVxcclxcblwiO1xuUGFydGljbGVSZW5kZXJlci5mcmFnbWVudCQxID0gXCJ2YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXHJcXG52YXJ5aW5nIHZlYzQgdkNvbG9yO1xcclxcblxcclxcbnVuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyO1xcclxcblxcclxcbnZvaWQgbWFpbih2b2lkKXtcXHJcXG4gICAgdmVjNCBjb2xvciA9IHRleHR1cmUyRCh1U2FtcGxlciwgdlRleHR1cmVDb29yZCkgKiB2Q29sb3I7XFxyXFxuICAgIGdsX0ZyYWdDb2xvciA9IGNvbG9yO1xcclxcbn1cIjtcbmV4cG9ydHMuUGFydGljbGVSZW5kZXJlciA9IFBhcnRpY2xlUmVuZGVyZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IFBvaW50XzEgPSByZXF1aXJlKFwiLi4vZmxhc2gvZ2VvbS9Qb2ludFwiKTtcbmNvbnN0IFNoYXBlU2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL1NoYXBlU2V0dGluZ3NcIik7XG5jbGFzcyBQb2x5Z29uIHtcbiAgICBjb25zdHJ1Y3RvcihhcmcgPSBudWxsKSB7XG4gICAgICAgIHZhciBhcmd1bWVudHMkMSA9IGFyZ3VtZW50cztcbiAgICAgICAgdmFyIHBvaW50cyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAobGVuLS0pIHtcbiAgICAgICAgICAgIHBvaW50c1tsZW5dID0gYXJndW1lbnRzJDFbbGVuXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwb2ludHNbMF0pKSB7XG4gICAgICAgICAgICBwb2ludHMgPSBwb2ludHNbMF07XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgdGhpcyBpcyBhbiBhcnJheSBvZiBwb2ludHMsIGNvbnZlcnQgaXQgdG8gYSBmbGF0IGFycmF5IG9mIG51bWJlcnNcbiAgICAgICAgaWYgKHBvaW50c1swXSBpbnN0YW5jZW9mIFBvaW50XzEuUG9pbnQpIHtcbiAgICAgICAgICAgIHZhciBwID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaWwgPSBwb2ludHMubGVuZ3RoOyBpIDwgaWw7IGkrKykge1xuICAgICAgICAgICAgICAgIHAucHVzaChwb2ludHNbaV0ueCwgcG9pbnRzW2ldLnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9pbnRzID0gcDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQW4gYXJyYXkgb2YgdGhlIHBvaW50cyBvZiB0aGlzIHBvbHlnb25cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyW119XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnBvaW50cyA9IHBvaW50cztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0eXBlIG9mIHRoZSBvYmplY3QsIG1haW5seSB1c2VkIHRvIGF2b2lkIGBpbnN0YW5jZW9mYCBjaGVja3NcbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKiBAcmVhZE9ubHlcbiAgICAgICAgICogQGRlZmF1bHQgUElYSS5TSEFQRVMuUE9MWVxuICAgICAgICAgKiBAc2VlIFBJWEkuU0hBUEVTXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnR5cGUgPSBTaGFwZVNldHRpbmdzXzEuU2hhcGVTZXR0aW5ncy5TSEFQRVMuUE9MWTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGBmYWxzZWAgYWZ0ZXIgbW92ZVRvLCBgdHJ1ZWAgYWZ0ZXIgYGNsb3NlUGF0aGAuIEluIGFsbCBvdGhlciBjYXNlcyBpdCBpcyBgdHJ1ZWAuXG4gICAgICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XG4gICAgICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2xvc2VTdHJva2UgPSB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgdGhpcyBwb2x5Z29uXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtQSVhJLlBvbHlnb259IGEgY29weSBvZiB0aGUgcG9seWdvblxuICAgICAqL1xuICAgIGNsb25lKCkge1xuICAgICAgICB2YXIgcG9seWdvbiA9IG5ldyBQb2x5Z29uKHRoaXMucG9pbnRzLnNsaWNlKCkpO1xuICAgICAgICBwb2x5Z29uLmNsb3NlU3Ryb2tlID0gdGhpcy5jbG9zZVN0cm9rZTtcbiAgICAgICAgcmV0dXJuIHBvbHlnb247XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgeCBhbmQgeSBjb29yZGluYXRlcyBwYXNzZWQgdG8gdGhpcyBmdW5jdGlvbiBhcmUgY29udGFpbmVkIHdpdGhpbiB0aGlzIHBvbHlnb25cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gVGhlIFggY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQgdG8gdGVzdFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gVGhlIFkgY29vcmRpbmF0ZSBvZiB0aGUgcG9pbnQgdG8gdGVzdFxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIHgveSBjb29yZGluYXRlcyBhcmUgd2l0aGluIHRoaXMgcG9seWdvblxuICAgICAqL1xuICAgIGNvbnRhaW5zKHgsIHkpIHtcbiAgICAgICAgdmFyIGluc2lkZSA9IGZhbHNlO1xuICAgICAgICAvLyB1c2Ugc29tZSByYXljYXN0aW5nIHRvIHRlc3QgaGl0c1xuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vc3Vic3RhY2svcG9pbnQtaW4tcG9seWdvbi9ibG9iL21hc3Rlci9pbmRleC5qc1xuICAgICAgICB2YXIgbGVuZ3RoID0gdGhpcy5wb2ludHMubGVuZ3RoIC8gMjtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGogPSBsZW5ndGggLSAxOyBpIDwgbGVuZ3RoOyBqID0gaSsrKSB7XG4gICAgICAgICAgICB2YXIgeGkgPSB0aGlzLnBvaW50c1tpICogMl07XG4gICAgICAgICAgICB2YXIgeWkgPSB0aGlzLnBvaW50c1soaSAqIDIpICsgMV07XG4gICAgICAgICAgICB2YXIgeGogPSB0aGlzLnBvaW50c1tqICogMl07XG4gICAgICAgICAgICB2YXIgeWogPSB0aGlzLnBvaW50c1soaiAqIDIpICsgMV07XG4gICAgICAgICAgICB2YXIgaW50ZXJzZWN0ID0gKCh5aSA+IHkpICE9PSAoeWogPiB5KSkgJiYgKHggPCAoKHhqIC0geGkpICogKCh5IC0geWkpIC8gKHlqIC0geWkpKSkgKyB4aSk7XG4gICAgICAgICAgICBpZiAoaW50ZXJzZWN0KSB7XG4gICAgICAgICAgICAgICAgaW5zaWRlID0gIWluc2lkZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5zaWRlO1xuICAgIH1cbiAgICA7XG59XG5leHBvcnRzLlBvbHlnb24gPSBQb2x5Z29uO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBCYXNlUHJlcGFyZV8xID0gcmVxdWlyZShcIi4vQmFzZVByZXBhcmVcIik7XG4vLyBpbXBvcnQgeyBzZXR0aW5ncyB9IGZyb20gXCIuL3NldHRpbmdzXCI7XG5jb25zdCBHcmFwaGljc18xID0gcmVxdWlyZShcIi4vR3JhcGhpY3NcIik7XG5jb25zdCBCYXNlVGV4dHVyZV8xID0gcmVxdWlyZShcIi4vQmFzZVRleHR1cmVcIik7XG5jbGFzcyBQcmVwYXJlIGV4dGVuZHMgQmFzZVByZXBhcmVfMS5CYXNlUHJlcGFyZSB7XG4gICAgY29uc3RydWN0b3IocmVuZGVyZXIpIHtcbiAgICAgICAgc3VwZXIocmVuZGVyZXIpO1xuICAgICAgICB0aGlzLnVwbG9hZEhvb2tIZWxwZXIgPSB0aGlzLnJlbmRlcmVyO1xuICAgICAgICAvLyBBZGQgdGV4dHVyZXMgYW5kIGdyYXBoaWNzIHRvIHVwbG9hZFxuICAgICAgICB0aGlzLnJlZ2lzdGVyRmluZEhvb2soUHJlcGFyZS5maW5kR3JhcGhpY3MpO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyVXBsb2FkSG9vayhQcmVwYXJlLnVwbG9hZEJhc2VUZXh0dXJlcyk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJVcGxvYWRIb29rKFByZXBhcmUudXBsb2FkR3JhcGhpY3MpO1xuICAgIH1cbiAgICBzdGF0aWMgZmluZEdyYXBoaWNzKGl0ZW0sIHF1ZXVlKSB7XG4gICAgICAgIGlmIChpdGVtIGluc3RhbmNlb2YgR3JhcGhpY3NfMS5HcmFwaGljcykge1xuICAgICAgICAgICAgcXVldWUucHVzaChpdGVtKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgc3RhdGljIHVwbG9hZEJhc2VUZXh0dXJlcyhyZW5kZXJlciwgaXRlbSkge1xuICAgICAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIEJhc2VUZXh0dXJlXzEuQmFzZVRleHR1cmUpIHtcbiAgICAgICAgICAgIGlmICghaXRlbS5fZ2xUZXh0dXJlc1tyZW5kZXJlci5DT05URVhUX1VJRF0pIHtcbiAgICAgICAgICAgICAgICByZW5kZXJlci50ZXh0dXJlTWFuYWdlci51cGRhdGVUZXh0dXJlKGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBzdGF0aWMgdXBsb2FkR3JhcGhpY3MocmVuZGVyZXIsIGl0ZW0pIHtcbiAgICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBHcmFwaGljc18xLkdyYXBoaWNzKSB7XG4gICAgICAgICAgICBpZiAoaXRlbS5kaXJ0eSB8fCBpdGVtLmNsZWFyRGlydHkgfHwgIWl0ZW0uX3dlYkdMW3JlbmRlcmVyLnBsdWdpbnMuZ3JhcGhpY3MuQ09OVEVYVF9VSURdKSB7XG4gICAgICAgICAgICAgICAgcmVuZGVyZXIucGx1Z2lucy5ncmFwaGljcy51cGRhdGVHcmFwaGljcyhpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5leHBvcnRzLlByZXBhcmUgPSBQcmVwYXJlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBTaGFkZXJfMSA9IHJlcXVpcmUoXCIuL1NoYWRlclwiKTtcbmNvbnN0IENhY2hlU2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL0NhY2hlU2V0dGluZ3NcIik7XG5jb25zdCBXZWJHTFNldHRpbmdzXzEgPSByZXF1aXJlKFwiLi9XZWJHTFNldHRpbmdzXCIpO1xuY2xhc3MgUHJvZ3JhbSB7XG4gICAgY29uc3RydWN0b3IodmVydGV4U3JjLCBmcmFnbWVudFNyYywgbmFtZSA9ICdwaXhpLXNoYWRlcicpIHtcbiAgICAgICAgdGhpcy5pZCA9IFByb2dyYW0uVUlEJDMrKztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB2ZXJ0ZXggc2hhZGVyLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnZlcnRleFNyYyA9IHZlcnRleFNyYyB8fCBQcm9ncmFtLmRlZmF1bHRWZXJ0ZXhTcmM7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZnJhZ21lbnQgc2hhZGVyLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmZyYWdtZW50U3JjID0gZnJhZ21lbnRTcmMgfHwgUHJvZ3JhbS5kZWZhdWx0RnJhZ21lbnRTcmM7XG4gICAgICAgIHRoaXMudmVydGV4U3JjID0gdGhpcy52ZXJ0ZXhTcmMudHJpbSgpO1xuICAgICAgICB0aGlzLmZyYWdtZW50U3JjID0gdGhpcy5mcmFnbWVudFNyYy50cmltKCk7XG4gICAgICAgIGlmICh0aGlzLnZlcnRleFNyYy5zdWJzdHJpbmcoMCwgOCkgIT09ICcjdmVyc2lvbicpIHtcbiAgICAgICAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoL1xccysvZywgJy0nKTtcbiAgICAgICAgICAgIGlmIChDYWNoZVNldHRpbmdzXzEuQ2FjaGVTZXR0aW5ncy5uYW1lQ2FjaGVbbmFtZV0pIHtcbiAgICAgICAgICAgICAgICBDYWNoZVNldHRpbmdzXzEuQ2FjaGVTZXR0aW5ncy5uYW1lQ2FjaGVbbmFtZV0rKztcbiAgICAgICAgICAgICAgICBuYW1lICs9IFwiLVwiICsgKENhY2hlU2V0dGluZ3NfMS5DYWNoZVNldHRpbmdzLm5hbWVDYWNoZVtuYW1lXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBDYWNoZVNldHRpbmdzXzEuQ2FjaGVTZXR0aW5ncy5uYW1lQ2FjaGVbbmFtZV0gPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy52ZXJ0ZXhTcmMgPSBcIiNkZWZpbmUgU0hBREVSX05BTUUgXCIgKyBuYW1lICsgXCJcXG5cIiArICh0aGlzLnZlcnRleFNyYyk7XG4gICAgICAgICAgICB0aGlzLmZyYWdtZW50U3JjID0gXCIjZGVmaW5lIFNIQURFUl9OQU1FIFwiICsgbmFtZSArIFwiXFxuXCIgKyAodGhpcy5mcmFnbWVudFNyYyk7XG4gICAgICAgICAgICB0aGlzLnZlcnRleFNyYyA9IFdlYkdMU2V0dGluZ3NfMS5XZWJHTFNldHRpbmdzLnNldFByZWNpc2lvbih0aGlzLnZlcnRleFNyYywgV2ViR0xTZXR0aW5nc18xLldlYkdMU2V0dGluZ3MuUFJFQ0lTSU9OX1ZFUlRFWCk7XG4gICAgICAgICAgICB0aGlzLmZyYWdtZW50U3JjID0gV2ViR0xTZXR0aW5nc18xLldlYkdMU2V0dGluZ3Muc2V0UHJlY2lzaW9uKHRoaXMuZnJhZ21lbnRTcmMsIFdlYkdMU2V0dGluZ3NfMS5XZWJHTFNldHRpbmdzLlBSRUNJU0lPTl9GUkFHTUVOVCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5hbWUgPT0gXCJwaXhpLXNoYWRlci00XCIpIHtcbiAgICAgICAgfVxuICAgICAgICAvLyBjdXJyZW50bHkgdGhpcyBkb2VzIG5vdCBleHRyYWN0IHN0cnVjdHMgb25seSBkZWZhdWx0IHR5cGVzXG4gICAgICAgIHRoaXMuZXh0cmFjdERhdGEodGhpcy52ZXJ0ZXhTcmMsIHRoaXMuZnJhZ21lbnRTcmMpO1xuICAgICAgICAvLyB0aGlzIGlzIHdoZXJlIHdlIHN0b3JlIHNoYWRlciByZWZlcmVuY2VzLi5cbiAgICAgICAgdGhpcy5nbFByb2dyYW1zID0ge307XG4gICAgICAgIHRoaXMuc3luY1VuaWZvcm1zID0gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXh0cmFjdHMgdGhlIGRhdGEgZm9yIGEgYnV5IGNyZWF0aW5nIGEgc21hbGwgdGVzdCBwcm9ncmFtXG4gICAgICogb3IgcmVhZGluZyB0aGUgc3JjIGRpcmVjdGx5LlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbdmVydGV4U3JjXSAtIFRoZSBzb3VyY2Ugb2YgdGhlIHZlcnRleCBzaGFkZXIuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtmcmFnbWVudFNyY10gLSBUaGUgc291cmNlIG9mIHRoZSBmcmFnbWVudCBzaGFkZXIuXG4gICAgICovXG4gICAgZXh0cmFjdERhdGEodmVydGV4U3JjLCBmcmFnbWVudFNyYykge1xuICAgICAgICB2YXIgZ2wgPSBXZWJHTFNldHRpbmdzXzEuV2ViR0xTZXR0aW5ncy5nZXRUZXN0Q29udGV4dCgpO1xuICAgICAgICBpZiAoZ2wpIHtcbiAgICAgICAgICAgIHZhciBwcm9ncmFtID0gUHJvZ3JhbS5jb21waWxlUHJvZ3JhbShnbCwgdmVydGV4U3JjLCBmcmFnbWVudFNyYyk7XG4gICAgICAgICAgICB0aGlzLmF0dHJpYnV0ZURhdGEgPSB0aGlzLmdldEF0dHJpYnV0ZURhdGEocHJvZ3JhbSwgZ2wpO1xuICAgICAgICAgICAgdGhpcy51bmlmb3JtRGF0YSA9IHRoaXMuZ2V0VW5pZm9ybURhdGEocHJvZ3JhbSwgZ2wpO1xuICAgICAgICAgICAgZ2wuZGVsZXRlUHJvZ3JhbShwcm9ncmFtKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudW5pZm9ybURhdGEgPSB7fTtcbiAgICAgICAgICAgIHRoaXMuYXR0cmlidXRlRGF0YSA9IHt9O1xuICAgICAgICB9XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiByZXR1cm5zIHRoZSBhdHRyaWJ1dGUgZGF0YSBmcm9tIHRoZSBwcm9ncmFtXG4gICAgICogQHByaXZhdGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7V2ViR0xQcm9ncmFtfSBbcHJvZ3JhbV0gLSB0aGUgV2ViR0wgcHJvZ3JhbVxuICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBbZ2xdIC0gdGhlIFdlYkdMIGNvbnRleHRcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9IHRoZSBhdHRyaWJ1dGUgZGF0YSBmb3IgdGhpcyBwcm9ncmFtXG4gICAgICovXG4gICAgZ2V0QXR0cmlidXRlRGF0YShwcm9ncmFtLCBnbCkge1xuICAgICAgICB2YXIgYXR0cmlidXRlcyA9IHt9O1xuICAgICAgICB2YXIgYXR0cmlidXRlc0FycmF5ID0gW107XG4gICAgICAgIHZhciB0b3RhbEF0dHJpYnV0ZXMgPSBnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKHByb2dyYW0sIGdsLkFDVElWRV9BVFRSSUJVVEVTKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b3RhbEF0dHJpYnV0ZXM7IGkrKykge1xuICAgICAgICAgICAgdmFyIGF0dHJpYkRhdGEgPSBnbC5nZXRBY3RpdmVBdHRyaWIocHJvZ3JhbSwgaSk7XG4gICAgICAgICAgICB2YXIgdHlwZSA9IFdlYkdMU2V0dGluZ3NfMS5XZWJHTFNldHRpbmdzLm1hcFR5cGUoZ2wsIGF0dHJpYkRhdGEudHlwZSk7XG4gICAgICAgICAgICAvKmVzbGludC1kaXNhYmxlICovXG4gICAgICAgICAgICB2YXIgZGF0YSA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgICAgIG5hbWU6IGF0dHJpYkRhdGEubmFtZSxcbiAgICAgICAgICAgICAgICBzaXplOiBXZWJHTFNldHRpbmdzXzEuV2ViR0xTZXR0aW5ncy5tYXBTaXplKHR5cGUpLFxuICAgICAgICAgICAgICAgIGxvY2F0aW9uOiAwLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8qIGVzbGludC1lbmFibGUgKi9cbiAgICAgICAgICAgIGF0dHJpYnV0ZXNbYXR0cmliRGF0YS5uYW1lXSA9IGRhdGE7XG4gICAgICAgICAgICBhdHRyaWJ1dGVzQXJyYXkucHVzaChkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBhdHRyaWJ1dGVzQXJyYXkuc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gKGEubmFtZSA+IGIubmFtZSkgPyAxIDogLTE7IH0pOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbmZ1c2luZy1hcnJvd1xuICAgICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBhdHRyaWJ1dGVzQXJyYXkubGVuZ3RoOyBpJDErKykge1xuICAgICAgICAgICAgYXR0cmlidXRlc0FycmF5W2kkMV0ubG9jYXRpb24gPSBpJDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF0dHJpYnV0ZXM7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiByZXR1cm5zIHRoZSB1bmlmb3JtIGRhdGEgZnJvbSB0aGUgcHJvZ3JhbVxuICAgICAqIEBwcml2YXRlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3dlYkdMLXByb2dyYW19IFtwcm9ncmFtXSAtIHRoZSB3ZWJnbCBwcm9ncmFtXG4gICAgICogQHBhcmFtIHtjb250ZXh0fSBbZ2xdIC0gdGhlIFdlYkdMIGNvbnRleHRcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9IHRoZSB1bmlmb3JtIGRhdGEgZm9yIHRoaXMgcHJvZ3JhbVxuICAgICAqL1xuICAgIGdldFVuaWZvcm1EYXRhKHByb2dyYW0sIGdsKSB7XG4gICAgICAgIHZhciB1bmlmb3JtcyA9IHt9O1xuICAgICAgICB2YXIgdG90YWxVbmlmb3JtcyA9IGdsLmdldFByb2dyYW1QYXJhbWV0ZXIocHJvZ3JhbSwgZ2wuQUNUSVZFX1VOSUZPUk1TKTtcbiAgICAgICAgLy8gVE9ETyBleHBvc2UgdGhpcyBhcyBhIHByb3A/XG4gICAgICAgIC8vIGNvbnN0IG1hc2tSZWdleCA9IG5ldyBSZWdFeHAoJ14ocHJvamVjdGlvbk1hdHJpeHx1U2FtcGxlcnx0cmFuc2xhdGlvbk1hdHJpeCkkJyk7XG4gICAgICAgIC8vIGNvbnN0IG1hc2tSZWdleCA9IG5ldyBSZWdFeHAoJ14ocHJvamVjdGlvbk1hdHJpeHx1U2FtcGxlcnx0cmFuc2xhdGlvbk1hdHJpeCkkJyk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG90YWxVbmlmb3JtczsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgdW5pZm9ybURhdGEgPSBnbC5nZXRBY3RpdmVVbmlmb3JtKHByb2dyYW0sIGkpO1xuICAgICAgICAgICAgdmFyIG5hbWUgPSB1bmlmb3JtRGF0YS5uYW1lLnJlcGxhY2UoL1xcWy4qP1xcXS8sICcnKTtcbiAgICAgICAgICAgIHZhciBpc0FycmF5ID0gdW5pZm9ybURhdGEubmFtZS5tYXRjaCgvXFxbLio/XFxdLywgJycpO1xuICAgICAgICAgICAgdmFyIHR5cGUgPSBXZWJHTFNldHRpbmdzXzEuV2ViR0xTZXR0aW5ncy5tYXBUeXBlKGdsLCB1bmlmb3JtRGF0YS50eXBlKTtcbiAgICAgICAgICAgIC8qZXNsaW50LWRpc2FibGUgKi9cbiAgICAgICAgICAgIHVuaWZvcm1zW25hbWVdID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICAgICAgc2l6ZTogdW5pZm9ybURhdGEuc2l6ZSxcbiAgICAgICAgICAgICAgICBpc0FycmF5OiBpc0FycmF5LFxuICAgICAgICAgICAgICAgIHZhbHVlOiBXZWJHTFNldHRpbmdzXzEuV2ViR0xTZXR0aW5ncy5kZWZhdWx0VmFsdWUodHlwZSwgdW5pZm9ybURhdGEuc2l6ZSksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLyogZXNsaW50LWVuYWJsZSAqL1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmlmb3JtcztcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFRoZSBkZWZhdWx0IHZlcnRleCBzaGFkZXIgc291cmNlXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQGNvbnN0YW50XG4gICAgICogQG1lbWJlciB7c3RyaW5nfVxuICAgICAqL1xuICAgIHN0YXRpYyBnZXQgZGVmYXVsdFZlcnRleFNyYygpIHtcbiAgICAgICAgcmV0dXJuIFByb2dyYW0uZGVmYXVsdFZlcnRleDtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFRoZSBkZWZhdWx0IGZyYWdtZW50IHNoYWRlciBzb3VyY2VcbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAY29uc3RhbnRcbiAgICAgKiBAbWVtYmVyIHtzdHJpbmd9XG4gICAgICovXG4gICAgc3RhdGljIGdldCBkZWZhdWx0RnJhZ21lbnRTcmMoKSB7XG4gICAgICAgIHJldHVybiBQcm9ncmFtLmRlZmF1bHRGcmFnbWVudDtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIEEgc2hvcnQgaGFuZCBmdW5jdGlvbiB0byBjcmVhdGUgYSBwcm9ncmFtIGJhc2VkIG9mIGEgdmVydGV4IGFuZCBmcmFnbWVudCBzaGFkZXJcbiAgICAgKiB0aGlzIG1ldGhvZCB3aWxsIGFsc28gY2hlY2sgdG8gc2VlIGlmIHRoZXJlIGlzIGEgY2FjaGVkIHByb2dyYW0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3ZlcnRleFNyY10gLSBUaGUgc291cmNlIG9mIHRoZSB2ZXJ0ZXggc2hhZGVyLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbZnJhZ21lbnRTcmNdIC0gVGhlIHNvdXJjZSBvZiB0aGUgZnJhZ21lbnQgc2hhZGVyLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbdW5pZm9ybXNdIC0gQ3VzdG9tIHVuaWZvcm1zIHRvIHVzZSB0byBhdWdtZW50IHRoZSBidWlsdC1pbiBvbmVzLlxuICAgICAqXG4gICAgICogQHJldHVybnMge1BJWEkuUHJvZ3JhbX0gYW4gc2hpbnkgbmV3IFBpeGkgc2hhZGVyIVxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tKHZlcnRleFNyYywgZnJhZ21lbnRTcmMsIG5hbWUgPSBcInBpeGktc2hhZGVyXCIpIHtcbiAgICAgICAgdmFyIGtleSA9IHZlcnRleFNyYyArIGZyYWdtZW50U3JjO1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IENhY2hlU2V0dGluZ3NfMS5DYWNoZVNldHRpbmdzLlByb2dyYW1DYWNoZVtrZXldO1xuICAgICAgICBpZiAoIXByb2dyYW0pIHtcbiAgICAgICAgICAgIENhY2hlU2V0dGluZ3NfMS5DYWNoZVNldHRpbmdzLlByb2dyYW1DYWNoZVtrZXldID0gcHJvZ3JhbSA9IG5ldyBQcm9ncmFtKHZlcnRleFNyYywgZnJhZ21lbnRTcmMsIG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcm9ncmFtO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gKiBAbWV0aG9kIGNvbXBpbGVQcm9ncmFtXG4gKiBAcHJpdmF0ZVxuICogQG1lbWJlcm9mIFBJWEkuZ2xDb3JlLnNoYWRlclxuICogQHBhcmFtIGdsIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IFRoZSBjdXJyZW50IFdlYkdMIGNvbnRleHQge1dlYkdMUHJvZ3JhbX1cbiAqIEBwYXJhbSB2ZXJ0ZXhTcmMge3N0cmluZ3xzdHJpbmdbXX0gVGhlIHZlcnRleCBzaGFkZXIgc291cmNlIGFzIGFuIGFycmF5IG9mIHN0cmluZ3MuXG4gKiBAcGFyYW0gZnJhZ21lbnRTcmMge3N0cmluZ3xzdHJpbmdbXX0gVGhlIGZyYWdtZW50IHNoYWRlciBzb3VyY2UgYXMgYW4gYXJyYXkgb2Ygc3RyaW5ncy5cbiAqIEBwYXJhbSBhdHRyaWJ1dGVMb2NhdGlvbnMge09iamVjdH0gQW4gYXR0cmlidXRlIGxvY2F0aW9uIG1hcCB0aGF0IGxldHMgeW91IG1hbnVhbGx5IHNldCB0aGUgYXR0cmlidXRlIGxvY2F0aW9uc1xuICogQHJldHVybiB7V2ViR0xQcm9ncmFtfSB0aGUgc2hhZGVyIHByb2dyYW1cbiAqL1xuICAgIHN0YXRpYyBjb21waWxlUHJvZ3JhbShnbCwgdmVydGV4U3JjLCBmcmFnbWVudFNyYywgYXR0cmlidXRlTG9jYXRpb25zID0gbnVsbCkge1xuICAgICAgICB2YXIgZ2xWZXJ0U2hhZGVyID0gU2hhZGVyXzEuU2hhZGVyLmNvbXBpbGVTaGFkZXIoZ2wsIGdsLlZFUlRFWF9TSEFERVIsIHZlcnRleFNyYyk7XG4gICAgICAgIHZhciBnbEZyYWdTaGFkZXIgPSBTaGFkZXJfMS5TaGFkZXIuY29tcGlsZVNoYWRlcihnbCwgZ2wuRlJBR01FTlRfU0hBREVSLCBmcmFnbWVudFNyYyk7XG4gICAgICAgIHZhciBwcm9ncmFtID0gZ2wuY3JlYXRlUHJvZ3JhbSgpO1xuICAgICAgICBnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgZ2xWZXJ0U2hhZGVyKTtcbiAgICAgICAgZ2wuYXR0YWNoU2hhZGVyKHByb2dyYW0sIGdsRnJhZ1NoYWRlcik7XG4gICAgICAgIC8vIG9wdGlvbmFsbHksIHNldCB0aGUgYXR0cmlidXRlcyBtYW51YWxseSBmb3IgdGhlIHByb2dyYW0gcmF0aGVyIHRoYW4gbGV0dGluZyBXZWJHTCBkZWNpZGUuLlxuICAgICAgICBpZiAoYXR0cmlidXRlTG9jYXRpb25zKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpIGluIGF0dHJpYnV0ZUxvY2F0aW9ucykge1xuICAgICAgICAgICAgICAgIGdsLmJpbmRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCBhdHRyaWJ1dGVMb2NhdGlvbnNbaV0sIGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGdsLmxpbmtQcm9ncmFtKHByb2dyYW0pO1xuICAgICAgICAvLyBpZiBsaW5raW5nIGZhaWxzLCB0aGVuIGxvZyBhbmQgY2xlYW51cFxuICAgICAgICBpZiAoIWdsLmdldFByb2dyYW1QYXJhbWV0ZXIocHJvZ3JhbSwgZ2wuTElOS19TVEFUVVMpKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdQaXhpLmpzIEVycm9yOiBDb3VsZCBub3QgaW5pdGlhbGl6ZSBzaGFkZXIuJyk7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdnbC5WQUxJREFURV9TVEFUVVMnLCBnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKHByb2dyYW0sIGdsLlZBTElEQVRFX1NUQVRVUykpO1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignZ2wuZ2V0RXJyb3IoKScsIGdsLmdldEVycm9yKCkpO1xuICAgICAgICAgICAgLy8gaWYgdGhlcmUgaXMgYSBwcm9ncmFtIGluZm8gbG9nLCBsb2cgaXRcbiAgICAgICAgICAgIGlmIChnbC5nZXRQcm9ncmFtSW5mb0xvZyhwcm9ncmFtKSAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1BpeGkuanMgV2FybmluZzogZ2wuZ2V0UHJvZ3JhbUluZm9Mb2coKScsIGdsLmdldFByb2dyYW1JbmZvTG9nKHByb2dyYW0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdsLmRlbGV0ZVByb2dyYW0ocHJvZ3JhbSk7XG4gICAgICAgICAgICBwcm9ncmFtID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBjbGVhbiB1cCBzb21lIHNoYWRlcnNcbiAgICAgICAgZ2wuZGVsZXRlU2hhZGVyKGdsVmVydFNoYWRlcik7XG4gICAgICAgIGdsLmRlbGV0ZVNoYWRlcihnbEZyYWdTaGFkZXIpO1xuICAgICAgICByZXR1cm4gcHJvZ3JhbTtcbiAgICB9XG59XG5Qcm9ncmFtLlVJRCQzID0gMDtcblByb2dyYW0uZGVmYXVsdEZyYWdtZW50ID0gXCJ2YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXHJcXG5cXHJcXG51bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjtcXHJcXG5cXHJcXG52b2lkIG1haW4odm9pZCl7XFxyXFxuICAgZ2xfRnJhZ0NvbG9yICo9IHRleHR1cmUyRCh1U2FtcGxlciwgdlRleHR1cmVDb29yZCk7XFxyXFxufVwiO1xuUHJvZ3JhbS5kZWZhdWx0VmVydGV4ID0gXCJhdHRyaWJ1dGUgdmVjMiBhVmVydGV4UG9zaXRpb247XFxyXFxuYXR0cmlidXRlIHZlYzIgYVRleHR1cmVDb29yZDtcXHJcXG5cXHJcXG51bmlmb3JtIG1hdDMgcHJvamVjdGlvbk1hdHJpeDtcXHJcXG5cXHJcXG52YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXHJcXG5cXHJcXG52b2lkIG1haW4odm9pZCl7XFxyXFxuICAgZ2xfUG9zaXRpb24gPSB2ZWM0KChwcm9qZWN0aW9uTWF0cml4ICogdmVjMyhhVmVydGV4UG9zaXRpb24sIDEuMCkpLnh5LCAwLjAsIDEuMCk7XFxyXFxuICAgdlRleHR1cmVDb29yZCA9IGFUZXh0dXJlQ29vcmQ7XFxyXFxufVxcclxcblwiO1xuZXhwb3J0cy5Qcm9ncmFtID0gUHJvZ3JhbTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgRXZlbnRfMSA9IHJlcXVpcmUoXCIuL0V2ZW50XCIpO1xuY2xhc3MgUHJvZ3Jlc3NFdmVudCBleHRlbmRzIEV2ZW50XzEuRXZlbnQge1xuICAgIGNvbnN0cnVjdG9yKHR5cGUsIGJ1YmJsZXMgPSBmYWxzZSwgY2FuY2VsYWJsZSA9IGZhbHNlKSB7XG4gICAgICAgIHN1cGVyKHR5cGUsIGJ1YmJsZXMsIGNhbmNlbGFibGUpO1xuICAgIH1cbiAgICBjbG9uZSgpIHtcbiAgICAgICAgdmFyIGV2ZW50ID0gUHJvZ3Jlc3NFdmVudC5nZXRQcm9ncmVzc0V2ZW50KHRoaXMudHlwZSwgdGhpcy5idWJibGVzLCB0aGlzLmNhbmNlbGFibGUpO1xuICAgICAgICBldmVudC5ieXRlc0xvYWRlZCA9IHRoaXMuYnl0ZXNMb2FkZWQ7XG4gICAgICAgIGV2ZW50LmJ5dGVzVG90YWwgPSB0aGlzLmJ5dGVzVG90YWw7XG4gICAgICAgIGV2ZW50LnBlcmNlbnQgPSB0aGlzLnBlcmNlbnQ7XG4gICAgICAgIHJldHVybiBldmVudDtcbiAgICB9XG4gICAgZ2V0IGlzRGlzcG9zYWJsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHN0YXRpYyBnZXRQcm9ncmVzc0V2ZW50KHR5cGUsIGJ1YmJsZSA9IHRydWUsIGNhbmNlbGFibGUgPSB0cnVlKSB7XG4gICAgICAgIGlmIChQcm9ncmVzc0V2ZW50LlByb2dyZXNzRXZlbnRDYWNoZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCB0ZSA9IFByb2dyZXNzRXZlbnQuUHJvZ3Jlc3NFdmVudENhY2hlW1Byb2dyZXNzRXZlbnQuUHJvZ3Jlc3NFdmVudENhY2hlLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgUHJvZ3Jlc3NFdmVudC5Qcm9ncmVzc0V2ZW50Q2FjaGUubGVuZ3RoIC09IDE7XG4gICAgICAgICAgICB0ZS5yZXNldCh0eXBlLCBidWJibGUsIGNhbmNlbGFibGUpO1xuICAgICAgICAgICAgcmV0dXJuIHRlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUHJvZ3Jlc3NFdmVudCh0eXBlLCBidWJibGUsIGNhbmNlbGFibGUpO1xuICAgIH1cbiAgICBkZXN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLl9jdXJyZW50VGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgLy8gdGhpcy5fbGVnYWN5VGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgbGV0IGluZGV4ID0gUHJvZ3Jlc3NFdmVudC5Qcm9ncmVzc0V2ZW50Q2FjaGUuaW5kZXhPZih0aGlzKTtcbiAgICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICAgICAgUHJvZ3Jlc3NFdmVudC5Qcm9ncmVzc0V2ZW50Q2FjaGUucHVzaCh0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblByb2dyZXNzRXZlbnQuUHJvZ3Jlc3NFdmVudENhY2hlID0gW107XG5Qcm9ncmVzc0V2ZW50LlBST0dSRVNTID0gXCJwcm9ncmVzc1wiO1xuZXhwb3J0cy5Qcm9ncmVzc0V2ZW50ID0gUHJvZ3Jlc3NFdmVudDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgU3lzdGVtXzEgPSByZXF1aXJlKFwiLi9TeXN0ZW1cIik7XG5jb25zdCBNYXRyaXhfMSA9IHJlcXVpcmUoXCIuL01hdHJpeFwiKTtcbmNsYXNzIFByb2plY3Rpb25TeXN0ZW0gZXh0ZW5kcyBTeXN0ZW1fMS5TeXN0ZW0ge1xuICAgIGNvbnN0cnVjdG9yKHJlbmRlcmVyKSB7XG4gICAgICAgIHN1cGVyKHJlbmRlcmVyKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlc3RpbmF0aW9uIGZyYW1lXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuUmVjdGFuZ2xlfVxuICAgICAgICAgKiBAcmVhZG9ubHlcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGVzdGluYXRpb25GcmFtZSA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTb3VyY2UgZnJhbWVcbiAgICAgICAgICogQG1lbWJlciB7UElYSS5SZWN0YW5nbGV9XG4gICAgICAgICAqIEByZWFkb25seVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zb3VyY2VGcmFtZSA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWZhdWx0IGRlc3RpbmF0aW9uIGZyYW1lXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuUmVjdGFuZ2xlfVxuICAgICAgICAgKiBAcmVhZG9ubHlcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGVmYXVsdEZyYW1lID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByb2plY3QgbWF0cml4XG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuTWF0cml4fVxuICAgICAgICAgKiBAcmVhZG9ubHlcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucHJvamVjdGlvbk1hdHJpeCA9IG5ldyBNYXRyaXhfMS5NYXRyaXgoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgdHJhbnNmb3JtIHRoYXQgd2lsbCBiZSBhcHBlbmRlZCB0byB0aGUgcHJvamVjdGlvbiBtYXRyaXhcbiAgICAgICAgICogaWYgbnVsbCwgbm90aGluZyB3aWxsIGJlIGFwcGxpZWRcbiAgICAgICAgICogQG1lbWJlciB7UElYSS5NYXRyaXh9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRyYW5zZm9ybSA9IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIHByb2plY3Rpb24gbWF0cml4IGJhc2VkIG9uIGEgcHJvamVjdGlvbiBmcmFtZSAod2hpY2ggaXMgYSByZWN0YW5nbGUpXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BJWEkuUmVjdGFuZ2xlfSBkZXN0aW5hdGlvbkZyYW1lIC0gVGhlIGRlc3RpbmF0aW9uIGZyYW1lLlxuICAgICAqIEBwYXJhbSB7UElYSS5SZWN0YW5nbGV9IHNvdXJjZUZyYW1lIC0gVGhlIHNvdXJjZSBmcmFtZS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcmVzb2x1dGlvbiAtIFJlc29sdXRpb25cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHJvb3QgLSBJZiBpcyByb290XG4gICAgICovXG4gICAgdXBkYXRlKGRlc3RpbmF0aW9uRnJhbWUsIHNvdXJjZUZyYW1lLCByZXNvbHV0aW9uLCByb290KSB7XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb25GcmFtZSA9IGRlc3RpbmF0aW9uRnJhbWUgfHwgdGhpcy5kZXN0aW5hdGlvbkZyYW1lIHx8IHRoaXMuZGVmYXVsdEZyYW1lO1xuICAgICAgICB0aGlzLnNvdXJjZUZyYW1lID0gc291cmNlRnJhbWUgfHwgdGhpcy5zb3VyY2VGcmFtZSB8fCBkZXN0aW5hdGlvbkZyYW1lO1xuICAgICAgICB0aGlzLmNhbGN1bGF0ZVByb2plY3Rpb24odGhpcy5kZXN0aW5hdGlvbkZyYW1lLCB0aGlzLnNvdXJjZUZyYW1lLCByZXNvbHV0aW9uLCByb290KTtcbiAgICAgICAgaWYgKHRoaXMudHJhbnNmb3JtKSB7XG4gICAgICAgICAgICB0aGlzLnByb2plY3Rpb25NYXRyaXguYXBwZW5kKHRoaXMudHJhbnNmb3JtKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVuZGVyZXIgPSB0aGlzLnJlbmRlcmVyO1xuICAgICAgICByZW5kZXJlci5nbG9iYWxVbmlmb3Jtcy51bmlmb3Jtcy5wcm9qZWN0aW9uTWF0cml4ID0gdGhpcy5wcm9qZWN0aW9uTWF0cml4O1xuICAgICAgICByZW5kZXJlci5nbG9iYWxVbmlmb3Jtcy51cGRhdGUoKTtcbiAgICAgICAgLy8gdGhpcyB3aWxsIHdvcmsgZm9yIG5vd1xuICAgICAgICAvLyBidXQgd291bGQgYmUgc3dlZXQgdG8gc3RpY2sgYW5kIGV2ZW4gb24gdGhlIGdsb2JhbCB1bmlmb3Jtcy4uXG4gICAgICAgIGlmIChyZW5kZXJlci5zaGFkZXIuc2hhZGVyKSB7XG4gICAgICAgICAgICByZW5kZXJlci5zaGFkZXIuc3luY1VuaWZvcm1Hcm91cChyZW5kZXJlci5zaGFkZXIuc2hhZGVyLnVuaWZvcm1zLmdsb2JhbHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBwcm9qZWN0aW9uIG1hdHJpeCBiYXNlZCBvbiBhIHByb2plY3Rpb24gZnJhbWUgKHdoaWNoIGlzIGEgcmVjdGFuZ2xlKVxuICAgICAqXG4gICAgICogQHBhcmFtIHtQSVhJLlJlY3RhbmdsZX0gZGVzdGluYXRpb25GcmFtZSAtIFRoZSBkZXN0aW5hdGlvbiBmcmFtZS5cbiAgICAgKiBAcGFyYW0ge1BJWEkuUmVjdGFuZ2xlfSBzb3VyY2VGcmFtZSAtIFRoZSBzb3VyY2UgZnJhbWUuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHJlc29sdXRpb24gLSBSZXNvbHV0aW9uXG4gICAgICogQHBhcmFtIHtib29sZWFufSByb290IC0gSWYgaXMgcm9vdFxuICAgICAqL1xuICAgIGNhbGN1bGF0ZVByb2plY3Rpb24oZGVzdGluYXRpb25GcmFtZSwgc291cmNlRnJhbWUsIHJlc29sdXRpb24sIHJvb3QpIHtcbiAgICAgICAgdmFyIHBtID0gdGhpcy5wcm9qZWN0aW9uTWF0cml4O1xuICAgICAgICAvLyBJIGRvbid0IHRoaW5rIHdlIHdpbGwgbmVlZCB0aGlzIGxpbmUuLlxuICAgICAgICAvLyBwbS5pZGVudGl0eSgpO1xuICAgICAgICBpZiAoIXJvb3QpIHtcbiAgICAgICAgICAgIHBtLmEgPSAoMSAvIGRlc3RpbmF0aW9uRnJhbWUud2lkdGggKiAyKSAqIHJlc29sdXRpb247XG4gICAgICAgICAgICBwbS5kID0gKDEgLyBkZXN0aW5hdGlvbkZyYW1lLmhlaWdodCAqIDIpICogcmVzb2x1dGlvbjtcbiAgICAgICAgICAgIHBtLnR4ID0gLTEgLSAoc291cmNlRnJhbWUueCAqIHBtLmEpO1xuICAgICAgICAgICAgcG0udHkgPSAtMSAtIChzb3VyY2VGcmFtZS55ICogcG0uZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwbS5hID0gKDEgLyBkZXN0aW5hdGlvbkZyYW1lLndpZHRoICogMikgKiByZXNvbHV0aW9uO1xuICAgICAgICAgICAgcG0uZCA9ICgtMSAvIGRlc3RpbmF0aW9uRnJhbWUuaGVpZ2h0ICogMikgKiByZXNvbHV0aW9uO1xuICAgICAgICAgICAgcG0udHggPSAtMSAtIChzb3VyY2VGcmFtZS54ICogcG0uYSk7XG4gICAgICAgICAgICBwbS50eSA9IDEgLSAoc291cmNlRnJhbWUueSAqIHBtLmQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSB0cmFuc2Zvcm0gb2YgdGhlIGFjdGl2ZSByZW5kZXIgdGFyZ2V0IHRvIHRoZSBnaXZlbiBtYXRyaXhcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UElYSS5NYXRyaXh9IG1hdHJpeCAtIFRoZSB0cmFuc2Zvcm1hdGlvbiBtYXRyaXhcbiAgICAgKi9cbiAgICBzZXRUcmFuc2Zvcm0oKSB7XG4gICAgICAgIC8vIHRoaXMuX2FjdGl2ZVJlbmRlclRhcmdldC50cmFuc2Zvcm0gPSBtYXRyaXg7XG4gICAgfVxuICAgIDtcbn1cbmV4cG9ydHMuUHJvamVjdGlvblN5c3RlbSA9IFByb2plY3Rpb25TeXN0ZW07XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IEdlb21ldHJ5XzEgPSByZXF1aXJlKFwiLi9HZW9tZXRyeVwiKTtcbmNsYXNzIFF1YWQgZXh0ZW5kcyBHZW9tZXRyeV8xLkdlb21ldHJ5IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5hZGRBdHRyaWJ1dGUoJ2FWZXJ0ZXhQb3NpdGlvbicsIFswLCAwLCAxLCAwLCAxLCAxLCAwLCAxXSkuYWRkSW5kZXgoWzAsIDEsIDMsIDJdKTtcbiAgICB9XG59XG5leHBvcnRzLlF1YWQgPSBRdWFkO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBHZW9tZXRyeV8xID0gcmVxdWlyZShcIi4vR2VvbWV0cnlcIik7XG5jb25zdCBCdWZmZXJfMSA9IHJlcXVpcmUoXCIuL0J1ZmZlclwiKTtcbmNsYXNzIFF1YWRVdiBleHRlbmRzIEdlb21ldHJ5XzEuR2VvbWV0cnkge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQW4gYXJyYXkgb2YgdmVydGljZXNcbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7RmxvYXQzMkFycmF5fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy52ZXJ0aWNlcyA9IG5ldyBGbG9hdDMyQXJyYXkoW1xuICAgICAgICAgICAgLTEsIC0xLFxuICAgICAgICAgICAgMSwgLTEsXG4gICAgICAgICAgICAxLCAxLFxuICAgICAgICAgICAgLTEsIDFcbiAgICAgICAgXSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgVXZzIG9mIHRoZSBxdWFkXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge0Zsb2F0MzJBcnJheX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudXZzID0gbmV3IEZsb2F0MzJBcnJheShbXG4gICAgICAgICAgICAwLCAwLFxuICAgICAgICAgICAgMSwgMCxcbiAgICAgICAgICAgIDEsIDEsXG4gICAgICAgICAgICAwLCAxXG4gICAgICAgIF0pO1xuICAgICAgICB0aGlzLnZlcnRleEJ1ZmZlciA9IG5ldyBCdWZmZXJfMS5CdWZmZXIodGhpcy52ZXJ0aWNlcyk7XG4gICAgICAgIHRoaXMudXZCdWZmZXIgPSBuZXcgQnVmZmVyXzEuQnVmZmVyKHRoaXMudXZzKTtcbiAgICAgICAgdGhpcy5hZGRBdHRyaWJ1dGUoJ2FWZXJ0ZXhQb3NpdGlvbicsIHRoaXMudmVydGV4QnVmZmVyKVxuICAgICAgICAgICAgLmFkZEF0dHJpYnV0ZSgnYVRleHR1cmVDb29yZCcsIHRoaXMudXZCdWZmZXIpXG4gICAgICAgICAgICAuYWRkSW5kZXgoWzAsIDEsIDIsIDAsIDIsIDNdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWFwcyB0d28gUmVjdGFuZ2xlIHRvIHRoZSBxdWFkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQSVhJLlJlY3RhbmdsZX0gdGFyZ2V0VGV4dHVyZUZyYW1lIC0gdGhlIGZpcnN0IHJlY3RhbmdsZVxuICAgICAqIEBwYXJhbSB7UElYSS5SZWN0YW5nbGV9IGRlc3RpbmF0aW9uRnJhbWUgLSB0aGUgc2Vjb25kIHJlY3RhbmdsZVxuICAgICAqIEByZXR1cm4ge1BJWEkuUXVhZH0gUmV0dXJucyBpdHNlbGYuXG4gICAgICovXG4gICAgbWFwKHRhcmdldFRleHR1cmVGcmFtZSwgZGVzdGluYXRpb25GcmFtZSkge1xuICAgICAgICB2YXIgeCA9IDA7IC8vIGRlc3RpbmF0aW9uRnJhbWUueCAvIHRhcmdldFRleHR1cmVGcmFtZS53aWR0aDtcbiAgICAgICAgdmFyIHkgPSAwOyAvLyBkZXN0aW5hdGlvbkZyYW1lLnkgLyB0YXJnZXRUZXh0dXJlRnJhbWUuaGVpZ2h0O1xuICAgICAgICB0aGlzLnV2c1swXSA9IHg7XG4gICAgICAgIHRoaXMudXZzWzFdID0geTtcbiAgICAgICAgdGhpcy51dnNbMl0gPSB4ICsgKGRlc3RpbmF0aW9uRnJhbWUud2lkdGggLyB0YXJnZXRUZXh0dXJlRnJhbWUud2lkdGgpO1xuICAgICAgICB0aGlzLnV2c1szXSA9IHk7XG4gICAgICAgIHRoaXMudXZzWzRdID0geCArIChkZXN0aW5hdGlvbkZyYW1lLndpZHRoIC8gdGFyZ2V0VGV4dHVyZUZyYW1lLndpZHRoKTtcbiAgICAgICAgdGhpcy51dnNbNV0gPSB5ICsgKGRlc3RpbmF0aW9uRnJhbWUuaGVpZ2h0IC8gdGFyZ2V0VGV4dHVyZUZyYW1lLmhlaWdodCk7XG4gICAgICAgIHRoaXMudXZzWzZdID0geDtcbiAgICAgICAgdGhpcy51dnNbN10gPSB5ICsgKGRlc3RpbmF0aW9uRnJhbWUuaGVpZ2h0IC8gdGFyZ2V0VGV4dHVyZUZyYW1lLmhlaWdodCk7XG4gICAgICAgIHggPSBkZXN0aW5hdGlvbkZyYW1lLng7XG4gICAgICAgIHkgPSBkZXN0aW5hdGlvbkZyYW1lLnk7XG4gICAgICAgIHRoaXMudmVydGljZXNbMF0gPSB4O1xuICAgICAgICB0aGlzLnZlcnRpY2VzWzFdID0geTtcbiAgICAgICAgdGhpcy52ZXJ0aWNlc1syXSA9IHggKyBkZXN0aW5hdGlvbkZyYW1lLndpZHRoO1xuICAgICAgICB0aGlzLnZlcnRpY2VzWzNdID0geTtcbiAgICAgICAgdGhpcy52ZXJ0aWNlc1s0XSA9IHggKyBkZXN0aW5hdGlvbkZyYW1lLndpZHRoO1xuICAgICAgICB0aGlzLnZlcnRpY2VzWzVdID0geSArIGRlc3RpbmF0aW9uRnJhbWUuaGVpZ2h0O1xuICAgICAgICB0aGlzLnZlcnRpY2VzWzZdID0geDtcbiAgICAgICAgdGhpcy52ZXJ0aWNlc1s3XSA9IHkgKyBkZXN0aW5hdGlvbkZyYW1lLmhlaWdodDtcbiAgICAgICAgdGhpcy5pbnZhbGlkYXRlKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogbGVnYWN5IHVwbG9hZCBtZXRob2QsIGp1c3QgbWFya3MgYnVmZmVycyBkaXJ0eVxuICAgICAqIEByZXR1cm5zIHtQSVhJLlF1YWRVdn0gUmV0dXJucyBpdHNlbGYuXG4gICAgICovXG4gICAgaW52YWxpZGF0ZSgpIHtcbiAgICAgICAgdGhpcy52ZXJ0ZXhCdWZmZXIuX3VwZGF0ZUlEKys7XG4gICAgICAgIHRoaXMudXZCdWZmZXIuX3VwZGF0ZUlEKys7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICA7XG59XG5leHBvcnRzLlF1YWRVdiA9IFF1YWRVdjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3Qgc2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL3NldHRpbmdzXCIpO1xuY2xhc3MgUXVhZHJhdGljVXRpbHMge1xuICAgIHN0YXRpYyBjdXJ2ZUxlbmd0aChmcm9tWCwgZnJvbVksIGNwWCwgY3BZLCB0b1gsIHRvWSkge1xuICAgICAgICB2YXIgYXggPSBmcm9tWCAtICgyLjAgKiBjcFgpICsgdG9YO1xuICAgICAgICB2YXIgYXkgPSBmcm9tWSAtICgyLjAgKiBjcFkpICsgdG9ZO1xuICAgICAgICB2YXIgYnggPSAoMi4wICogY3BYKSAtICgyLjAgKiBmcm9tWCk7XG4gICAgICAgIHZhciBieSA9ICgyLjAgKiBjcFkpIC0gKDIuMCAqIGZyb21ZKTtcbiAgICAgICAgdmFyIGEgPSA0LjAgKiAoKGF4ICogYXgpICsgKGF5ICogYXkpKTtcbiAgICAgICAgdmFyIGIgPSA0LjAgKiAoKGF4ICogYngpICsgKGF5ICogYnkpKTtcbiAgICAgICAgdmFyIGMgPSAoYnggKiBieCkgKyAoYnkgKiBieSk7XG4gICAgICAgIHZhciBzID0gMi4wICogTWF0aC5zcXJ0KGEgKyBiICsgYyk7XG4gICAgICAgIHZhciBhMiA9IE1hdGguc3FydChhKTtcbiAgICAgICAgdmFyIGEzMiA9IDIuMCAqIGEgKiBhMjtcbiAgICAgICAgdmFyIGMyID0gMi4wICogTWF0aC5zcXJ0KGMpO1xuICAgICAgICB2YXIgYmEgPSBiIC8gYTI7XG4gICAgICAgIHJldHVybiAoKGEzMiAqIHMpXG4gICAgICAgICAgICArIChhMiAqIGIgKiAocyAtIGMyKSlcbiAgICAgICAgICAgICsgKCgoNC4wICogYyAqIGEpIC0gKGIgKiBiKSlcbiAgICAgICAgICAgICAgICAqIE1hdGgubG9nKCgoMi4wICogYTIpICsgYmEgKyBzKSAvIChiYSArIGMyKSkpKSAvICg0LjAgKiBhMzIpO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHRoZSBwb2ludHMgZm9yIGEgcXVhZHJhdGljIGJlemllciBjdXJ2ZSBhbmQgdGhlbiBkcmF3cyBpdC5cbiAgICAgKiBCYXNlZCBvbjogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNzg1MDk3L2hvdy1kby1pLWltcGxlbWVudC1hLWJlemllci1jdXJ2ZS1pbi1jXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjcFggLSBDb250cm9sIHBvaW50IHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY3BZIC0gQ29udHJvbCBwb2ludCB5XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHRvWCAtIERlc3RpbmF0aW9uIHBvaW50IHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdG9ZIC0gRGVzdGluYXRpb24gcG9pbnQgeVxuICAgICAqIEBwYXJhbSB7bnVtYmVyW119IHBvaW50cyAtIFBvaW50cyB0byBhZGQgc2VnbWVudHMgdG8uXG4gICAgICovXG4gICAgc3RhdGljIGN1cnZlVG8oY3BYLCBjcFksIHRvWCwgdG9ZLCBwb2ludHMpIHtcbiAgICAgICAgdmFyIGZyb21YID0gcG9pbnRzW3BvaW50cy5sZW5ndGggLSAyXTtcbiAgICAgICAgdmFyIGZyb21ZID0gcG9pbnRzW3BvaW50cy5sZW5ndGggLSAxXTtcbiAgICAgICAgdmFyIG4gPSBzZXR0aW5nc18xLnNldHRpbmdzLkdSQVBISUNTX0NVUlZFUy5fc2VnbWVudHNDb3VudChRdWFkcmF0aWNVdGlscy5jdXJ2ZUxlbmd0aChmcm9tWCwgZnJvbVksIGNwWCwgY3BZLCB0b1gsIHRvWSkpO1xuICAgICAgICB2YXIgeGEgPSAwO1xuICAgICAgICB2YXIgeWEgPSAwO1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8PSBuOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBqID0gaSAvIG47XG4gICAgICAgICAgICB4YSA9IGZyb21YICsgKChjcFggLSBmcm9tWCkgKiBqKTtcbiAgICAgICAgICAgIHlhID0gZnJvbVkgKyAoKGNwWSAtIGZyb21ZKSAqIGopO1xuICAgICAgICAgICAgcG9pbnRzLnB1c2goeGEgKyAoKChjcFggKyAoKHRvWCAtIGNwWCkgKiBqKSkgLSB4YSkgKiBqKSwgeWEgKyAoKChjcFkgKyAoKHRvWSAtIGNwWSkgKiBqKSkgLSB5YSkgKiBqKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xufVxuZXhwb3J0cy5RdWFkcmF0aWNVdGlscyA9IFF1YWRyYXRpY1V0aWxzO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBUZXh0dXJlXzEgPSByZXF1aXJlKFwiLi9UZXh0dXJlXCIpO1xuY29uc3QgQmFzZVJlbmRlclRleHR1cmVfMSA9IHJlcXVpcmUoXCIuL0Jhc2VSZW5kZXJUZXh0dXJlXCIpO1xuY2xhc3MgUmVuZGVyVGV4dHVyZSBleHRlbmRzIFRleHR1cmVfMS5UZXh0dXJlIHtcbiAgICBjb25zdHJ1Y3RvcihiYXNlUmVuZGVyVGV4dHVyZSA9IG51bGwsIGZyYW1lID0gbnVsbCkge1xuICAgICAgICBzdXBlcihiYXNlUmVuZGVyVGV4dHVyZSwgZnJhbWUpO1xuICAgICAgICB2YXIgX2xlZ2FjeVJlbmRlcmVyID0gbnVsbDtcbiAgICAgICAgaWYgKCEoYmFzZVJlbmRlclRleHR1cmUgaW5zdGFuY2VvZiBCYXNlUmVuZGVyVGV4dHVyZV8xLkJhc2VSZW5kZXJUZXh0dXJlKSkge1xuICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgcHJlZmVyLXJlc3QtcGFyYW1zLCBuby1jb25zb2xlICovXG4gICAgICAgICAgICB2YXIgd2lkdGggPSBhcmd1bWVudHNbMV07XG4gICAgICAgICAgICB2YXIgaGVpZ2h0ID0gYXJndW1lbnRzWzJdO1xuICAgICAgICAgICAgdmFyIHNjYWxlTW9kZSA9IGFyZ3VtZW50c1szXTtcbiAgICAgICAgICAgIHZhciByZXNvbHV0aW9uID0gYXJndW1lbnRzWzRdO1xuICAgICAgICAgICAgLy8gd2UgaGF2ZSBhbiBvbGQgcmVuZGVyIHRleHR1cmUuLlxuICAgICAgICAgICAgY29uc29sZS53YXJuKChcIlBsZWFzZSB1c2UgUmVuZGVyVGV4dHVyZS5jcmVhdGUoXCIgKyB3aWR0aCArIFwiLCBcIiArIGhlaWdodCArIFwiKSBpbnN0ZWFkIG9mIHRoZSBjdG9yIGRpcmVjdGx5LlwiKSk7XG4gICAgICAgICAgICBfbGVnYWN5UmVuZGVyZXIgPSBhcmd1bWVudHNbMF07XG4gICAgICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIHByZWZlci1yZXN0LXBhcmFtcywgbm8tY29uc29sZSAqL1xuICAgICAgICAgICAgZnJhbWUgPSBudWxsO1xuICAgICAgICAgICAgYmFzZVJlbmRlclRleHR1cmUgPSBuZXcgQmFzZVJlbmRlclRleHR1cmVfMS5CYXNlUmVuZGVyVGV4dHVyZSh7XG4gICAgICAgICAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgICAgICAgICAgIHNjYWxlTW9kZTogc2NhbGVNb2RlLFxuICAgICAgICAgICAgICAgIHJlc29sdXRpb246IHJlc29sdXRpb24sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxlZ2FjeVJlbmRlcmVyID0gX2xlZ2FjeVJlbmRlcmVyO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyB3aWxsIGxldCB0aGUgcmVuZGVyZXIga25vdyBpZiB0aGUgdGV4dHVyZSBpcyB2YWxpZC4gSWYgaXQncyBub3QgdGhlbiBpdCBjYW5ub3QgYmUgcmVuZGVyZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnZhbGlkID0gdHJ1ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpbHRlclN5c3RlbSB0ZW1wb3Jhcnkgc3RvcmFnZVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuUmVjdGFuZ2xlfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5maWx0ZXJGcmFtZSA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAqIFRoZSBrZXkgZm9yIHBvb2xlZCB0ZXh0dXJlIG9mIEZpbHRlclN5c3RlbVxuICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgKiBAbWVtYmVyIHtzdHJpbmd9XG4gICAgICAgICovXG4gICAgICAgIHRoaXMuZmlsdGVyUG9vbEtleSA9IG51bGw7XG4gICAgICAgIHRoaXMudXBkYXRlVXZzKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICogUmVzaXplcyB0aGUgUmVuZGVyVGV4dHVyZS5cbiAgICAqXG4gICAgKiBAcGFyYW0ge251bWJlcn0gd2lkdGggLSBUaGUgd2lkdGggdG8gcmVzaXplIHRvLlxuICAgICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCAtIFRoZSBoZWlnaHQgdG8gcmVzaXplIHRvLlxuICAgICogQHBhcmFtIHtib29sZWFufSBbcmVzaXplQmFzZVRleHR1cmU9dHJ1ZV0gLSBTaG91bGQgdGhlIGJhc2VUZXh0dXJlLndpZHRoIGFuZCBoZWlnaHQgdmFsdWVzIGJlIHJlc2l6ZWQgYXMgd2VsbD9cbiAgICAqL1xuICAgIHJlc2l6ZSh3aWR0aCwgaGVpZ2h0LCByZXNpemVCYXNlVGV4dHVyZSkge1xuICAgICAgICBpZiAocmVzaXplQmFzZVRleHR1cmUgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgcmVzaXplQmFzZVRleHR1cmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHdpZHRoID0gTWF0aC5jZWlsKHdpZHRoKTtcbiAgICAgICAgaGVpZ2h0ID0gTWF0aC5jZWlsKGhlaWdodCk7XG4gICAgICAgIC8vIFRPRE8gLSBjb3VsZCBiZSBub3QgcmVxdWlyZWQuLlxuICAgICAgICB0aGlzLnZhbGlkID0gKHdpZHRoID4gMCAmJiBoZWlnaHQgPiAwKTtcbiAgICAgICAgdGhpcy5fZnJhbWUud2lkdGggPSB0aGlzLm9yaWcud2lkdGggPSB3aWR0aDtcbiAgICAgICAgdGhpcy5fZnJhbWUuaGVpZ2h0ID0gdGhpcy5vcmlnLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgaWYgKHJlc2l6ZUJhc2VUZXh0dXJlKSB7XG4gICAgICAgICAgICB0aGlzLmJhc2VUZXh0dXJlLnJlc2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVwZGF0ZVV2cygpO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogQSBzaG9ydCBoYW5kIHdheSBvZiBjcmVhdGluZyBhIHJlbmRlciB0ZXh0dXJlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSAtIE9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMud2lkdGg9MTAwXSAtIFRoZSB3aWR0aCBvZiB0aGUgcmVuZGVyIHRleHR1cmVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuaGVpZ2h0PTEwMF0gLSBUaGUgaGVpZ2h0IG9mIHRoZSByZW5kZXIgdGV4dHVyZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5zY2FsZU1vZGU9UElYSS5zZXR0aW5ncy5TQ0FMRV9NT0RFXSAtIFNlZSB7QGxpbmsgUElYSS5TQ0FMRV9NT0RFU30gZm9yIHBvc3NpYmxlIHZhbHVlc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5yZXNvbHV0aW9uPTFdIC0gVGhlIHJlc29sdXRpb24gLyBkZXZpY2UgcGl4ZWwgcmF0aW8gb2YgdGhlIHRleHR1cmUgYmVpbmcgZ2VuZXJhdGVkXG4gICAgICogQHJldHVybiB7UElYSS5SZW5kZXJUZXh0dXJlfSBUaGUgbmV3IHJlbmRlciB0ZXh0dXJlXG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZShvcHRpb25zLCBoZWlnaHQgPSBudWxsLCBzY2FsZU1vZGUgPSBudWxsLCByZXNvbHV0aW9uID0gbnVsbCkge1xuICAgICAgICAvLyBmYWxsYmFjaywgb2xkLXN0eWxlOiBjcmVhdGUod2lkdGgsIGhlaWdodCwgc2NhbGVNb2RlLCByZXNvbHV0aW9uKVxuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBwcmVmZXItcmVzdC1wYXJhbXMgKi9cbiAgICAgICAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgd2lkdGg6IG9wdGlvbnMsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBhcmd1bWVudHNbMV0sXG4gICAgICAgICAgICAgICAgc2NhbGVNb2RlOiBhcmd1bWVudHNbMl0sXG4gICAgICAgICAgICAgICAgcmVzb2x1dGlvbjogYXJndW1lbnRzWzNdLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8qIGVzbGludC1lbmFibGUgcHJlZmVyLXJlc3QtcGFyYW1zICovXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBSZW5kZXJUZXh0dXJlKG5ldyBCYXNlUmVuZGVyVGV4dHVyZV8xLkJhc2VSZW5kZXJUZXh0dXJlKG9wdGlvbnMpKTtcbiAgICB9XG4gICAgO1xufVxuZXhwb3J0cy5SZW5kZXJUZXh0dXJlID0gUmVuZGVyVGV4dHVyZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgU3lzdGVtXzEgPSByZXF1aXJlKFwiLi9TeXN0ZW1cIik7XG5jb25zdCBSZWN0YW5nbGVfMSA9IHJlcXVpcmUoXCIuLi9mbGFzaC9nZW9tL1JlY3RhbmdsZVwiKTtcbmNvbnN0IEluc3RhbmNlQ291bnRlcl8xID0gcmVxdWlyZShcIi4vSW5zdGFuY2VDb3VudGVyXCIpO1xuY2xhc3MgUmVuZGVyVGV4dHVyZVN5c3RlbSBleHRlbmRzIFN5c3RlbV8xLlN5c3RlbSB7XG4gICAgY29uc3RydWN0b3IocmVuZGVyZXIpIHtcbiAgICAgICAgc3VwZXIocmVuZGVyZXIpO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGNsZWFyIGJhY2tncm91bmQgY29sb3IgYXMgcmdiYVxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJbXX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2xlYXJDb2xvciA9IHJlbmRlcmVyLl9iYWNrZ3JvdW5kQ29sb3JSZ2JhO1xuICAgICAgICAvLyBUT0RPIG1vdmUgdGhpcyBwcm9wZXJ0eSBzb21ld2hlcmUgZWxzZSFcbiAgICAgICAgLyoqXG4gICAgICAgICAqIExpc3Qgb2YgbWFza3MgZm9yIHRoZSBTdGVuY2lsU3lzdGVtXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuR3JhcGhpY3NbXX1cbiAgICAgICAgICogQHJlYWRvbmx5XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRlZmF1bHRNYXNrU3RhY2sgPSBbXTtcbiAgICAgICAgLy8gZW1wdHkgcmVuZGVyIHRleHR1cmU/XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW5kZXIgdGV4dHVyZVxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLlJlbmRlclRleHR1cmV9XG4gICAgICAgICAqIEByZWFkb25seVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNvdXJjZSBmcmFtZVxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLlJlY3RhbmdsZX1cbiAgICAgICAgICogQHJlYWRvbmx5XG4gICAgICAgICAqL1xuICAgICAgICBJbnN0YW5jZUNvdW50ZXJfMS5JbnN0YW5jZUNvdW50ZXIuYWRkQ2FsbChcIlJlY3RhbmdsZS5nZXRSZWN0YW5nbGVcIiwgXCJSZW5kZXJ0ZXh0dXJlU3lzdGVtXCIpO1xuICAgICAgICB0aGlzLnNvdXJjZUZyYW1lID0gUmVjdGFuZ2xlXzEuUmVjdGFuZ2xlLmdldFJlY3RhbmdsZSgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRGVzdGluYXRpb24gZnJhbWVcbiAgICAgICAgICogQG1lbWJlciB7UElYSS5SZWN0YW5nbGV9XG4gICAgICAgICAqIEByZWFkb25seVxuICAgICAgICAgKi9cbiAgICAgICAgSW5zdGFuY2VDb3VudGVyXzEuSW5zdGFuY2VDb3VudGVyLmFkZENhbGwoXCJSZWN0YW5nbGUuZ2V0UmVjdGFuZ2xlXCIsIFwiUmVuZGVydGV4dHVyZVN5c3RlbVwiKTtcbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbkZyYW1lID0gUmVjdGFuZ2xlXzEuUmVjdGFuZ2xlLmdldFJlY3RhbmdsZSgpO1xuICAgIH1cbiAgICBkZXN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnNvdXJjZUZyYW1lLnJlY3ljbGUoKTtcbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbkZyYW1lLnJlY3ljbGUoKTtcbiAgICAgICAgdGhpcy5zb3VyY2VGcmFtZSA9IG51bGw7XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb25GcmFtZSA9IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJpbmQgdGhlIGN1cnJlbnQgcmVuZGVyIHRleHR1cmVcbiAgICAgKiBAcGFyYW0ge1BJWEkuUmVuZGVyVGV4dHVyZX0gcmVuZGVyVGV4dHVyZVxuICAgICAqIEBwYXJhbSB7UElYSS5SZWN0YW5nbGV9IHNvdXJjZUZyYW1lXG4gICAgICogQHBhcmFtIHtQSVhJLlJlY3RhbmdsZX0gZGVzdGluYXRpb25GcmFtZVxuICAgICAqL1xuICAgIGJpbmQocmVuZGVyVGV4dHVyZSwgc291cmNlRnJhbWUgPSBudWxsLCBkZXN0aW5hdGlvbkZyYW1lID0gbnVsbCkge1xuICAgICAgICBpZiAocmVuZGVyVGV4dHVyZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICByZW5kZXJUZXh0dXJlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmN1cnJlbnQgPSByZW5kZXJUZXh0dXJlO1xuICAgICAgICB2YXIgcmVuZGVyZXIgPSB0aGlzLnJlbmRlcmVyO1xuICAgICAgICB2YXIgcmVzb2x1dGlvbjtcbiAgICAgICAgaWYgKHJlbmRlclRleHR1cmUpIHtcbiAgICAgICAgICAgIHZhciBiYXNlVGV4dHVyZSA9IHJlbmRlclRleHR1cmUuYmFzZVRleHR1cmU7XG4gICAgICAgICAgICByZXNvbHV0aW9uID0gYmFzZVRleHR1cmUucmVzb2x1dGlvbjtcbiAgICAgICAgICAgIGlmICghZGVzdGluYXRpb25GcmFtZSkge1xuICAgICAgICAgICAgICAgIC8vIEluc3RhbmNlQ291bnRlci5hZGRDYWxsKFwiUmVjdGFuZ2xlLmdldFJlY3RhbmdsZVwiLCBcIlJlbmRlcnRleHR1cmVTeXN0ZW0gYmluZFwiKVxuICAgICAgICAgICAgICAgIGxldCB0ZW1wcmVjdCA9IFJlY3RhbmdsZV8xLlJlY3RhbmdsZS5ERUZBVUxUO1xuICAgICAgICAgICAgICAgIHRlbXByZWN0LndpZHRoID0gYmFzZVRleHR1cmUucmVhbFdpZHRoO1xuICAgICAgICAgICAgICAgIHRlbXByZWN0LmhlaWdodCA9IGJhc2VUZXh0dXJlLnJlYWxIZWlnaHQ7XG4gICAgICAgICAgICAgICAgZGVzdGluYXRpb25GcmFtZSA9IHRlbXByZWN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFzb3VyY2VGcmFtZSkge1xuICAgICAgICAgICAgICAgIHNvdXJjZUZyYW1lID0gZGVzdGluYXRpb25GcmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuZnJhbWVidWZmZXIuYmluZChiYXNlVGV4dHVyZS5mcmFtZWJ1ZmZlciwgZGVzdGluYXRpb25GcmFtZSk7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnByb2plY3Rpb24udXBkYXRlKGRlc3RpbmF0aW9uRnJhbWUsIHNvdXJjZUZyYW1lLCByZXNvbHV0aW9uLCBmYWxzZSk7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnN0ZW5jaWwuc2V0TWFza1N0YWNrKGJhc2VUZXh0dXJlLnN0ZW5jaWxNYXNrU3RhY2spO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzb2x1dGlvbiA9IHRoaXMucmVuZGVyZXIucmVzb2x1dGlvbjtcbiAgICAgICAgICAgIC8vIFRPRE8gdGhlc2UgdmFsaWRhdGlvbiBjaGVja3MgaGFwcGVuIGRlZXBlciBkb3duLi5cbiAgICAgICAgICAgIC8vIHRoaW5nIHRoZXkgY2FuIGJlIGF2b2lkZWQuLlxuICAgICAgICAgICAgaWYgKCFkZXN0aW5hdGlvbkZyYW1lKSB7XG4gICAgICAgICAgICAgICAgLy8gSW5zdGFuY2VDb3VudGVyLmFkZENhbGwoXCJSZWN0YW5nbGUuZ2V0UmVjdGFuZ2xlXCIsIFwiUmVuZGVydGV4dHVyZVN5c3RlbSBiaW5kXCIpXG4gICAgICAgICAgICAgICAgbGV0IHRlbXBSZWN0ID0gUmVjdGFuZ2xlXzEuUmVjdGFuZ2xlLkRFRkFVTFQ7XG4gICAgICAgICAgICAgICAgdGVtcFJlY3Qud2lkdGggPSByZW5kZXJlci53aWR0aDtcbiAgICAgICAgICAgICAgICB0ZW1wUmVjdC5oZWlnaHQgPSByZW5kZXJlci5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgZGVzdGluYXRpb25GcmFtZSA9IHRlbXBSZWN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFzb3VyY2VGcmFtZSkge1xuICAgICAgICAgICAgICAgIHNvdXJjZUZyYW1lID0gZGVzdGluYXRpb25GcmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlbmRlcmVyLmZyYW1lYnVmZmVyLmJpbmQobnVsbCwgZGVzdGluYXRpb25GcmFtZSk7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnByb2plY3Rpb24udXBkYXRlKGRlc3RpbmF0aW9uRnJhbWUsIHNvdXJjZUZyYW1lLCByZXNvbHV0aW9uLCB0cnVlKTtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuc3RlbmNpbC5zZXRNYXNrU3RhY2sodGhpcy5kZWZhdWx0TWFza1N0YWNrKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNvdXJjZUZyYW1lLmNvcHlGcm9tKHNvdXJjZUZyYW1lKTtcbiAgICAgICAgdGhpcy5kZXN0aW5hdGlvbkZyYW1lLnggPSBkZXN0aW5hdGlvbkZyYW1lLnggLyByZXNvbHV0aW9uO1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uRnJhbWUueSA9IGRlc3RpbmF0aW9uRnJhbWUueSAvIHJlc29sdXRpb247XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb25GcmFtZS53aWR0aCA9IGRlc3RpbmF0aW9uRnJhbWUud2lkdGggLyByZXNvbHV0aW9uO1xuICAgICAgICB0aGlzLmRlc3RpbmF0aW9uRnJhbWUuaGVpZ2h0ID0gZGVzdGluYXRpb25GcmFtZS5oZWlnaHQgLyByZXNvbHV0aW9uO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogRXJhc2VzIHRoZSByZW5kZXIgdGV4dHVyZSBhbmQgZmlsbHMgdGhlIGRyYXdpbmcgYXJlYSB3aXRoIGEgY29sb3VyXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcltdfSBbY2xlYXJDb2xvcl0gLSBUaGUgY29sb3IgYXMgcmdiYSwgZGVmYXVsdCB0byB1c2UgdGhlIHJlbmRlcmVyIGJhY2tncm91bmRDb2xvclxuICAgICAqIEByZXR1cm4ge1BJWEkuUmVuZGVyZXJ9IFJldHVybnMgaXRzZWxmLlxuICAgICAqL1xuICAgIGNsZWFyKGNsZWFyQ29sb3IgPSBudWxsKSB7XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIGNsZWFyQ29sb3IgPSBjbGVhckNvbG9yIHx8IHRoaXMuY3VycmVudC5iYXNlVGV4dHVyZS5jbGVhckNvbG9yO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY2xlYXJDb2xvciA9IGNsZWFyQ29sb3IgfHwgdGhpcy5jbGVhckNvbG9yO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVuZGVyZXIuZnJhbWVidWZmZXIuY2xlYXIoY2xlYXJDb2xvclswXSwgY2xlYXJDb2xvclsxXSwgY2xlYXJDb2xvclsyXSwgY2xlYXJDb2xvclszXSk7XG4gICAgfVxuICAgIDtcbiAgICByZXNpemUoKSB7XG4gICAgICAgIC8vIHJlc2l6ZSB0aGUgcm9vdCBvbmx5IVxuICAgICAgICB0aGlzLmJpbmQobnVsbCk7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBSZXNldHMgcmVuZGVyVGV4dHVyZSBzdGF0ZVxuICAgICAqL1xuICAgIHJlc2V0KCkge1xuICAgICAgICB0aGlzLmJpbmQobnVsbCk7XG4gICAgfVxuICAgIDtcbn1cbmV4cG9ydHMuUmVuZGVyVGV4dHVyZVN5c3RlbSA9IFJlbmRlclRleHR1cmVTeXN0ZW07XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IEFic3RyYWN0UmVuZGVyZXJfMSA9IHJlcXVpcmUoXCIuL0Fic3RyYWN0UmVuZGVyZXJcIik7XG5jb25zdCBVbmlmb3JtR3JvdXBfMSA9IHJlcXVpcmUoXCIuL1VuaWZvcm1Hcm91cFwiKTtcbmNvbnN0IE1hdHJpeF8xID0gcmVxdWlyZShcIi4vTWF0cml4XCIpO1xuY29uc3QgRXZlbnRfMSA9IHJlcXVpcmUoXCIuL0V2ZW50XCIpO1xuY29uc3QgQmF0Y2hSZW5kZXJlcl8xID0gcmVxdWlyZShcIi4vQmF0Y2hSZW5kZXJlclwiKTtcbmNvbnN0IEJhdGNoU3lzdGVtXzEgPSByZXF1aXJlKFwiLi9CYXRjaFN5c3RlbVwiKTtcbmNvbnN0IFJlbmRlclRleHR1cmVTeXN0ZW1fMSA9IHJlcXVpcmUoXCIuL1JlbmRlclRleHR1cmVTeXN0ZW1cIik7XG5jb25zdCBGaWx0ZXJTeXN0ZW1fMSA9IHJlcXVpcmUoXCIuL0ZpbHRlclN5c3RlbVwiKTtcbmNvbnN0IFRleHR1cmVHQ1N5c3RlbV8xID0gcmVxdWlyZShcIi4vVGV4dHVyZUdDU3lzdGVtXCIpO1xuY29uc3QgUHJvamVjdGlvblN5c3RlbV8xID0gcmVxdWlyZShcIi4vUHJvamVjdGlvblN5c3RlbVwiKTtcbmNvbnN0IFN0ZW5jaWxTeXN0ZW1fMSA9IHJlcXVpcmUoXCIuL1N0ZW5jaWxTeXN0ZW1cIik7XG5jb25zdCBGcmFtZWJ1ZmZlclN5c3RlbV8xID0gcmVxdWlyZShcIi4vRnJhbWVidWZmZXJTeXN0ZW1cIik7XG5jb25zdCBHZW9tZXRyeVN5c3RlbV8xID0gcmVxdWlyZShcIi4vR2VvbWV0cnlTeXN0ZW1cIik7XG5jb25zdCBUZXh0dXJlU3lzdGVtXzEgPSByZXF1aXJlKFwiLi9UZXh0dXJlU3lzdGVtXCIpO1xuY29uc3QgU2hhZGVyU3lzdGVtXzEgPSByZXF1aXJlKFwiLi9TaGFkZXJTeXN0ZW1cIik7XG5jb25zdCBTdGF0ZVN5c3RlbV8xID0gcmVxdWlyZShcIi4vU3RhdGVTeXN0ZW1cIik7XG5jb25zdCBDb250ZXh0U3lzdGVtXzEgPSByZXF1aXJlKFwiLi9Db250ZXh0U3lzdGVtXCIpO1xuY29uc3QgTWFza1N5c3RlbV8xID0gcmVxdWlyZShcIi4vTWFza1N5c3RlbVwiKTtcbmNvbnN0IERpc3BsYXlTZXR0aW5nc18xID0gcmVxdWlyZShcIi4vRGlzcGxheVNldHRpbmdzXCIpO1xuY29uc3QgVGlsaW5nU3ByaXRlUmVuZGVyZXJfMSA9IHJlcXVpcmUoXCIuL1RpbGluZ1Nwcml0ZVJlbmRlcmVyXCIpO1xuY29uc3QgQWNjZXNzaWJpbGl0eU1hbmFnZXJfMSA9IHJlcXVpcmUoXCIuL0FjY2Vzc2liaWxpdHlNYW5hZ2VyXCIpO1xuY29uc3QgRXh0cmFjdF8xID0gcmVxdWlyZShcIi4vRXh0cmFjdFwiKTtcbmNvbnN0IEludGVyYWN0aW9uTWFuYWdlcl8xID0gcmVxdWlyZShcIi4vSW50ZXJhY3Rpb25NYW5hZ2VyXCIpO1xuY29uc3QgUGFydGljbGVSZW5kZXJlcl8xID0gcmVxdWlyZShcIi4vUGFydGljbGVSZW5kZXJlclwiKTtcbmNvbnN0IFByZXBhcmVfMSA9IHJlcXVpcmUoXCIuL1ByZXBhcmVcIik7XG5jb25zdCBSdW5uZXJfMSA9IHJlcXVpcmUoXCIuL1J1bm5lclwiKTtcbmNsYXNzIFJlbmRlcmVyIGV4dGVuZHMgQWJzdHJhY3RSZW5kZXJlcl8xLkFic3RyYWN0UmVuZGVyZXIge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIoJ1dlYkdMJywgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMucGx1Z2lucyA9IHt9O1xuICAgICAgICB0aGlzLnR5cGUgPSBEaXNwbGF5U2V0dGluZ3NfMS5EaXNwbGF5U2V0dGluZ3MuUkVOREVSRVJfVFlQRS5XRUJHTDtcbiAgICAgICAgdGhpcy5nbCA9IG51bGw7XG4gICAgICAgIHRoaXMuQ09OVEVYVF9VSUQgPSAwO1xuICAgICAgICB0aGlzLnJ1bm5lcnMgPSB7XG4gICAgICAgICAgICBkZXN0cm95OiBuZXcgUnVubmVyXzEuUnVubmVyKCdkZXN0cm95JyksXG4gICAgICAgICAgICBjb250ZXh0Q2hhbmdlOiBuZXcgUnVubmVyXzEuUnVubmVyKCdjb250ZXh0Q2hhbmdlJywgMSksXG4gICAgICAgICAgICByZXNldDogbmV3IFJ1bm5lcl8xLlJ1bm5lcigncmVzZXQnKSxcbiAgICAgICAgICAgIHVwZGF0ZTogbmV3IFJ1bm5lcl8xLlJ1bm5lcigndXBkYXRlJyksXG4gICAgICAgICAgICBwb3N0cmVuZGVyOiBuZXcgUnVubmVyXzEuUnVubmVyKCdwb3N0cmVuZGVyJyksXG4gICAgICAgICAgICBwcmVyZW5kZXI6IG5ldyBSdW5uZXJfMS5SdW5uZXIoJ3ByZXJlbmRlcicpLFxuICAgICAgICAgICAgcmVzaXplOiBuZXcgUnVubmVyXzEuUnVubmVyKCdyZXNpemUnLCAyKSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5nbG9iYWxVbmlmb3JtcyA9IG5ldyBVbmlmb3JtR3JvdXBfMS5Vbmlmb3JtR3JvdXAoe1xuICAgICAgICAgICAgcHJvamVjdGlvbk1hdHJpeDogbmV3IE1hdHJpeF8xLk1hdHJpeCgpLFxuICAgICAgICB9LCB0cnVlKTtcbiAgICAgICAgdGhpcy5hZGRTeXN0ZW0oTWFza1N5c3RlbV8xLk1hc2tTeXN0ZW0sICdtYXNrJylcbiAgICAgICAgICAgIC5hZGRTeXN0ZW0oQ29udGV4dFN5c3RlbV8xLkNvbnRleHRTeXN0ZW0sICdjb250ZXh0JylcbiAgICAgICAgICAgIC5hZGRTeXN0ZW0oU3RhdGVTeXN0ZW1fMS5TdGF0ZVN5c3RlbSwgJ3N0YXRlJylcbiAgICAgICAgICAgIC5hZGRTeXN0ZW0oU2hhZGVyU3lzdGVtXzEuU2hhZGVyU3lzdGVtLCAnc2hhZGVyJylcbiAgICAgICAgICAgIC5hZGRTeXN0ZW0oVGV4dHVyZVN5c3RlbV8xLlRleHR1cmVTeXN0ZW0sICd0ZXh0dXJlJylcbiAgICAgICAgICAgIC5hZGRTeXN0ZW0oR2VvbWV0cnlTeXN0ZW1fMS5HZW9tZXRyeVN5c3RlbSwgJ2dlb21ldHJ5JylcbiAgICAgICAgICAgIC5hZGRTeXN0ZW0oRnJhbWVidWZmZXJTeXN0ZW1fMS5GcmFtZWJ1ZmZlclN5c3RlbSwgJ2ZyYW1lYnVmZmVyJylcbiAgICAgICAgICAgIC5hZGRTeXN0ZW0oU3RlbmNpbFN5c3RlbV8xLlN0ZW5jaWxTeXN0ZW0sICdzdGVuY2lsJylcbiAgICAgICAgICAgIC5hZGRTeXN0ZW0oUHJvamVjdGlvblN5c3RlbV8xLlByb2plY3Rpb25TeXN0ZW0sICdwcm9qZWN0aW9uJylcbiAgICAgICAgICAgIC5hZGRTeXN0ZW0oVGV4dHVyZUdDU3lzdGVtXzEuVGV4dHVyZUdDU3lzdGVtLCAndGV4dHVyZUdDJylcbiAgICAgICAgICAgIC5hZGRTeXN0ZW0oRmlsdGVyU3lzdGVtXzEuRmlsdGVyU3lzdGVtLCAnZmlsdGVyJylcbiAgICAgICAgICAgIC5hZGRTeXN0ZW0oUmVuZGVyVGV4dHVyZVN5c3RlbV8xLlJlbmRlclRleHR1cmVTeXN0ZW0sICdyZW5kZXJUZXh0dXJlJylcbiAgICAgICAgICAgIC5hZGRTeXN0ZW0oQmF0Y2hTeXN0ZW1fMS5CYXRjaFN5c3RlbSwgJ2JhdGNoJyk7XG4gICAgICAgIHRoaXMuaW5pdFBsdWdpbnMoUmVuZGVyZXIuX19wbHVnaW5zKTtcbiAgICAgICAgaWYgKG9wdGlvbnMuY29udGV4dCkge1xuICAgICAgICAgICAgdGhpcy5jb250ZXh0LmluaXRGcm9tQ29udGV4dChvcHRpb25zLmNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jb250ZXh0LmluaXRGcm9tT3B0aW9ucyh7XG4gICAgICAgICAgICAgICAgYWxwaGE6IHRoaXMudHJhbnNwYXJlbnQsXG4gICAgICAgICAgICAgICAgYW50aWFsaWFzOiBvcHRpb25zLmFudGlhbGlhcyxcbiAgICAgICAgICAgICAgICBwcmVtdWx0aXBsaWVkQWxwaGE6IHRoaXMudHJhbnNwYXJlbnQsXG4gICAgICAgICAgICAgICAgc3RlbmNpbDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBwcmVzZXJ2ZURyYXdpbmdCdWZmZXI6IG9wdGlvbnMucHJlc2VydmVEcmF3aW5nQnVmZmVyLFxuICAgICAgICAgICAgICAgIHBvd2VyUHJlZmVyZW5jZTogdGhpcy5vcHRpb25zLnBvd2VyUHJlZmVyZW5jZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVuZGVyaW5nVG9TY3JlZW4gPSB0cnVlO1xuICAgICAgICAvLyAgICAgc2F5SGVsbG8odGhpcy5jb250ZXh0LndlYkdMVmVyc2lvbiA9PT0gMiA/ICdXZWJHTCAyJyA6ICdXZWJHTCAxJyk7XG4gICAgICAgIHRoaXMucmVzaXplKHRoaXMub3B0aW9ucy53aWR0aCwgdGhpcy5vcHRpb25zLmhlaWdodCk7XG4gICAgfVxuICAgIHN0YXRpYyByZWdpc3RlclBsdWdpbihwbHVnaW5OYW1lLCBjdG9yKSB7XG4gICAgICAgIFJlbmRlcmVyLl9fcGx1Z2lucyA9IFJlbmRlcmVyLl9fcGx1Z2lucyB8fCB7fTtcbiAgICAgICAgUmVuZGVyZXIuX19wbHVnaW5zW3BsdWdpbk5hbWVdID0gY3RvcjtcbiAgICB9XG4gICAgO1xuICAgIGluaXRQbHVnaW5zKHN0YXRpY01hcCkge1xuICAgICAgICBmb3IgKHZhciBvIGluIHN0YXRpY01hcCkge1xuICAgICAgICAgICAgdGhpcy5wbHVnaW5zW29dID0gbmV3IChzdGF0aWNNYXBbb10pKHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIDtcbiAgICBhZGRTeXN0ZW0oQ2xhc3NSZWYsIG5hbWUpIHtcbiAgICAgICAgaWYgKCFuYW1lKSB7XG4gICAgICAgICAgICBuYW1lID0gQ2xhc3NSZWYubmFtZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3lzdGVtID0gbmV3IENsYXNzUmVmKHRoaXMpO1xuICAgICAgICBpZiAodGhpc1tuYW1lXSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKChcIldob29wcyEgVGhlIG5hbWUgXFxcIlwiICsgbmFtZSArIFwiXFxcIiBpcyBhbHJlYWR5IGluIHVzZVwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpc1tuYW1lXSA9IHN5c3RlbTtcbiAgICAgICAgZm9yICh2YXIgaSBpbiB0aGlzLnJ1bm5lcnMpIHtcbiAgICAgICAgICAgIHRoaXMucnVubmVyc1tpXS5hZGQoc3lzdGVtKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZWQgYWZ0ZXIgcmVuZGVyaW5nIGZpbmlzaGVzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXZlbnQgUElYSS5SZW5kZXJlciNwb3N0cmVuZGVyXG4gICAgICAgICAqL1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZWQgYmVmb3JlIHJlbmRlcmluZyBzdGFydHMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBldmVudCBQSVhJLlJlbmRlcmVyI3ByZXJlbmRlclxuICAgICAgICAgKi9cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVkIHdoZW4gdGhlIFdlYkdMIGNvbnRleHQgaXMgc2V0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXZlbnQgUElYSS5SZW5kZXJlciNjb250ZXh0XG4gICAgICAgICAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbCAtIFdlYkdMIGNvbnRleHQuXG4gICAgICAgICAqL1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgO1xuICAgIC8vIHByb3RlY3RlZCBoYW5kbGVDb250ZXh0Q2hhbmdlID0gKGV2ZW50OkV2ZW50KT0+XG4gICAgLy8ge1xuICAgIC8vIFx0dGhpcy5wbHVnaW5zLnBhcnRpY2xlLmNvbnRleHRDaGFuZ2UodGhpcy5jb250ZXh0LmdsKVxuICAgIC8vIFx0dGhpcy5mcmFtZWJ1ZmZlci5jb250ZXh0Q2hhbmdlKHRoaXMuY29udGV4dC5nbClcdFx0XG4gICAgLy8gXHR0aGlzLnNoYWRlci5jb250ZXh0Q2hhbmdlKHRoaXMuY29udGV4dC5nbClcbiAgICAvLyBcdHRoaXMuZ2VvbWV0cnkuY29udGV4dENoYW5nZSgpO1xuICAgIC8vIFx0dGhpcy5zdGF0ZS5jb250ZXh0Q2hhbmdlKHRoaXMuY29udGV4dC5nbClcbiAgICAvLyBcdHRoaXMudGV4dHVyZS5jb250ZXh0Q2hhbmdlKCk7XG4gICAgLy8gXHR0aGlzLmZyYW1lYnVmZmVyLmNvbnRleHRDaGFuZ2UodGhpcy5jb250ZXh0LmdsKVxuICAgIC8vIFx0dGhpcy5zdGVuY2lsLmNvbnRleHRDaGFuZ2UodGhpcy5jb250ZXh0LmdsKVxuICAgIC8vIFx0dGhpcy5wcm9qZWN0aW9uLmNvbnRleHRDaGFuZ2UodGhpcy5jb250ZXh0LmdsKVxuICAgIC8vIFx0dGhpcy50ZXh0dXJlR0MuY29udGV4dENoYW5nZSh0aGlzLmNvbnRleHQuZ2wpXG4gICAgLy8gXHR0aGlzLmZpbHRlci5jb250ZXh0Q2hhbmdlKHRoaXMuY29udGV4dC5nbClcbiAgICAvLyBcdHRoaXMucmVuZGVyVGV4dHVyZS5jb250ZXh0Q2hhbmdlKHRoaXMuY29udGV4dC5nbClcbiAgICAvLyBcdHRoaXMuYmF0Y2guY29udGV4dENoYW5nZSh0aGlzLmNvbnRleHQuZ2wpXG4gICAgLy8gXHR0aGlzLm1hc2suY29udGV4dENoYW5nZSh0aGlzLmNvbnRleHQuZ2wpO1xuICAgIC8vIFx0dGhpcy5wbHVnaW5zLmJhdGNoLmNvbnRleHRDaGFuZ2UoKTtcdFx0XG4gICAgLy8gXHR0aGlzLnBsdWdpbnMudGlsaW5nU3ByaXRlLmNvbnRleHRDaGFuZ2UodGhpcy5jb250ZXh0LmdsKVx0XHRcbiAgICAvLyB9XG4gICAgcmVuZGVyKGRpc3BsYXlPYmplY3QsIHJlbmRlclRleHR1cmUgPSBudWxsLCBjbGVhciA9IHRydWUsIHRyYW5zZm9ybSA9IG51bGwsIHNraXBVcGRhdGVUcmFuc2Zvcm0gPSBmYWxzZSkge1xuICAgICAgICB0aGlzLnJlbmRlcmluZ1RvU2NyZWVuID0gIXJlbmRlclRleHR1cmU7XG4gICAgICAgIHRoaXMucnVubmVycy5wcmVyZW5kZXIucnVuKCk7XG4gICAgICAgIC8vIHRoaXMuZW1pdCgncHJlcmVuZGVyJyk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChFdmVudF8xLkV2ZW50LmdldEV2ZW50KFwicHJlcmVuZGVyXCIpKTtcbiAgICAgICAgaWYgKHRoaXMuY29udGV4dC5pc0xvc3QpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJlbmRlclRleHR1cmUpIHtcbiAgICAgICAgICAgIHRoaXMuX2xhc3RPYmplY3RSZW5kZXJlZCA9IGRpc3BsYXlPYmplY3Q7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFza2lwVXBkYXRlVHJhbnNmb3JtKSB7XG4gICAgICAgICAgICBsZXQgY2FjaGVQYXJlbnQgPSBkaXNwbGF5T2JqZWN0LnBhcmVudDtcbiAgICAgICAgICAgIGRpc3BsYXlPYmplY3QucGFyZW50ID0gdGhpcy5fdGVtcERpc3BsYXlPYmplY3RQYXJlbnQ7XG4gICAgICAgICAgICBkaXNwbGF5T2JqZWN0LnVwZGF0ZVRyYW5zZm9ybSgpO1xuICAgICAgICAgICAgZGlzcGxheU9iamVjdC5wYXJlbnQgPSBjYWNoZVBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlbmRlclRleHR1cmUuYmluZChyZW5kZXJUZXh0dXJlKTtcbiAgICAgICAgdGhpcy5iYXRjaC5jdXJyZW50UmVuZGVyZXIuc3RhcnQoKTtcbiAgICAgICAgaWYgKGNsZWFyICE9PSB1bmRlZmluZWQgPyBjbGVhciA6IHRoaXMuY2xlYXJCZWZvcmVSZW5kZXIpIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyVGV4dHVyZS5jbGVhcigpO1xuICAgICAgICB9XG4gICAgICAgIGRpc3BsYXlPYmplY3QucmVuZGVyKHRoaXMpO1xuICAgICAgICB0aGlzLmJhdGNoLmN1cnJlbnRSZW5kZXJlci5mbHVzaCgpO1xuICAgICAgICBpZiAocmVuZGVyVGV4dHVyZSkge1xuICAgICAgICAgICAgcmVuZGVyVGV4dHVyZS5iYXNlVGV4dHVyZS51cGRhdGUoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJ1bm5lcnMucG9zdHJlbmRlci5ydW4oKTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KEV2ZW50XzEuRXZlbnQuZ2V0RXZlbnQoXCJwb3N0cmVuZGVyXCIpKTtcbiAgICB9XG4gICAgO1xuICAgIHJlc2l6ZShzY3JlZW5XaWR0aCwgc2NyZWVuSGVpZ2h0KSB7XG4gICAgICAgIHN1cGVyLnJlc2l6ZShzY3JlZW5XaWR0aCwgc2NyZWVuSGVpZ2h0KTtcbiAgICAgICAgdGhpcy5ydW5uZXJzLnJlc2l6ZS5ydW4oc2NyZWVuV2lkdGgsIHNjcmVlbkhlaWdodCk7XG4gICAgICAgIC8vIHRoaXMuZGlzcGF0Y2hFdmVudChFdmVudC5nZXRFdmVudChcInJlc2l6ZVwiKSk7XG4gICAgfVxuICAgIDtcbiAgICByZXNldCgpIHtcbiAgICAgICAgdGhpcy5ydW5uZXJzLnJlc2V0LnJ1bigpO1xuICAgICAgICAvLyB0aGlzLmRpc3BhdGNoRXZlbnQoRXZlbnQuZ2V0RXZlbnQoXCJyZXNldFwiKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICA7XG4gICAgY2xlYXIoKSB7XG4gICAgICAgIHRoaXMuZnJhbWVidWZmZXIuYmluZCgpO1xuICAgICAgICB0aGlzLmZyYW1lYnVmZmVyLmNsZWFyKCk7XG4gICAgfVxuICAgIDtcbiAgICBkZXN0cm95KG9wdGlvbnMgPSBudWxsKSB7XG4gICAgICAgIHRoaXMucnVubmVycy5kZXN0cm95LnJ1bigpO1xuICAgICAgICAvLyB0aGlzLmRpc3BhdGNoRXZlbnQoRXZlbnQuZ2V0RXZlbnQoXCJkZXN0cm95XCIpKTtcbiAgICAgICAgc3VwZXIuZGVzdHJveShvcHRpb25zKTtcbiAgICAgICAgdGhpcy5nbCA9IG51bGw7XG4gICAgfVxuICAgIDtcbn1cblJlbmRlcmVyLl9fcGx1Z2lucyA9IHt9O1xuZXhwb3J0cy5SZW5kZXJlciA9IFJlbmRlcmVyO1xuY2xhc3MgUmVuZGVyZXJQbHVnaW5zIHtcbiAgICBjb25zdHJ1Y3RvcihyZW5kZXJlcikge1xuICAgICAgICB0aGlzLnBhcnRpY2xlID0gbmV3IFBhcnRpY2xlUmVuZGVyZXJfMS5QYXJ0aWNsZVJlbmRlcmVyKHJlbmRlcmVyKTtcbiAgICAgICAgdGhpcy50aWxpbmdTcHJpdGUgPSBuZXcgVGlsaW5nU3ByaXRlUmVuZGVyZXJfMS5UaWxpbmdTcHJpdGVSZW5kZXJlcihyZW5kZXJlcik7XG4gICAgICAgIHRoaXMuYWNjZXNzaWJpbGl0eSA9IG5ldyBBY2Nlc3NpYmlsaXR5TWFuYWdlcl8xLkFjY2Vzc2liaWxpdHlNYW5hZ2VyKHJlbmRlcmVyKTtcbiAgICAgICAgdGhpcy5leHRyYWN0ID0gbmV3IEV4dHJhY3RfMS5FeHRyYWN0KHJlbmRlcmVyKTtcbiAgICAgICAgdGhpcy5pbnRlcmFjdGlvbiA9IG5ldyBJbnRlcmFjdGlvbk1hbmFnZXJfMS5JbnRlcmFjdGlvbk1hbmFnZXIocmVuZGVyZXIpO1xuICAgICAgICB0aGlzLnByZXBhcmUgPSBuZXcgUHJlcGFyZV8xLlByZXBhcmUocmVuZGVyZXIpO1xuICAgICAgICB0aGlzLmJhdGNoID0gbmV3IEJhdGNoUmVuZGVyZXJfMS5CYXRjaFJlbmRlcmVyKHJlbmRlcmVyKTtcbiAgICAgICAgLy8gTG9hZGVyJDIucmVnaXN0ZXJQbHVnaW4oQml0bWFwRm9udExvYWRlcik7XG4gICAgICAgIC8vIExvYWRlciQyLnJlZ2lzdGVyUGx1Z2luKFNwcml0ZXNoZWV0TG9hZGVyKTtcdFxuICAgIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgRXZlbnRfMSA9IHJlcXVpcmUoXCIuL0V2ZW50XCIpO1xuY29uc3QgRXZlbnREaXNwYXRjaGVyXzEgPSByZXF1aXJlKFwiLi9FdmVudERpc3BhdGNoZXJcIik7XG5jb25zdCBSdW5uZXJfMSA9IHJlcXVpcmUoXCIuL1J1bm5lclwiKTtcbmNsYXNzIFJlc291cmNlIGV4dGVuZHMgRXZlbnREaXNwYXRjaGVyXzEuRXZlbnREaXNwYXRjaGVyIHtcbiAgICBjb25zdHJ1Y3Rvcih3aWR0aCA9IDAsIGhlaWdodCA9IDApIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEludGVybmFsIHdpZHRoIG9mIHRoZSByZXNvdXJjZVxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3dpZHRoID0gd2lkdGg7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbnRlcm5hbCBoZWlnaHQgb2YgdGhlIHJlc291cmNlXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5faGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICAvKipcbiAgICAgICAgICogSWYgcmVzb3VyY2UgaGFzIGJlZW4gZGVzdHJveWVkXG4gICAgICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XG4gICAgICAgICAqIEByZWFkb25seVxuICAgICAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGB0cnVlYCBpZiByZXNvdXJjZSBpcyBjcmVhdGVkIGJ5IEJhc2VUZXh0dXJlXG4gICAgICAgICAqIHVzZWZ1bCBmb3IgZG9pbmcgY2xlYW51cCB3aXRoIEJhc2VUZXh0dXJlIGRlc3Ryb3lcbiAgICAgICAgICogYW5kIG5vdCBjbGVhbmluZyB1cCByZXNvdXJjZXMgdGhhdCB3ZXJlIGNyZWF0ZWRcbiAgICAgICAgICogZXh0ZXJuYWxseS5cbiAgICAgICAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pbnRlcm5hbCA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogTWluaS1ydW5uZXIgZm9yIGhhbmRsaW5nIHJlc2l6ZSBldmVudHNcbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7UnVubmVyfVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgLy8gdGhpcy5vblJlc2l6ZSA9IEV2ZW50LmdldEV2ZW50KFwic2V0UmVhbFNpemVcIilcbiAgICAgICAgLy8gUnVubmVyKCdzZXRSZWFsU2l6ZScsIDIpO1xuICAgICAgICAvKipcbiAgICAgICAgICogTWluaS1ydW5uZXIgZm9yIGhhbmRsaW5nIHVwZGF0ZSBldmVudHNcbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7UnVubmVyfVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgLy8gdGhpcy5vblVwZGF0ZSA9IEV2ZW50LmdldEV2ZW50KFwidXBkYXRlXCIpXG4gICAgICAgIC8vIG5ldyBSdW5uZXIoJ3VwZGF0ZScpO1xuICAgICAgICB0aGlzLm9uUmVzaXplID0gbmV3IFJ1bm5lcl8xLlJ1bm5lcignc2V0UmVhbFNpemUnLCAyKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1pbmktcnVubmVyIGZvciBoYW5kbGluZyB1cGRhdGUgZXZlbnRzXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge1J1bm5lcn1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub25VcGRhdGUgPSBuZXcgUnVubmVyXzEuUnVubmVyKCd1cGRhdGUnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQmluZCB0byBhIHBhcmVudCBCYXNlVGV4dHVyZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtQSVhJLkJhc2VUZXh0dXJlfSBiYXNlVGV4dHVyZSAtIFBhcmVudCB0ZXh0dXJlXG4gICAgICovXG4gICAgYmluZChiYXNlVGV4dHVyZSkge1xuICAgICAgICB0aGlzLm9uUmVzaXplLmFkZChiYXNlVGV4dHVyZSk7XG4gICAgICAgIHRoaXMub25VcGRhdGUuYWRkKGJhc2VUZXh0dXJlKTtcbiAgICAgICAgLy8gQ2FsbCBhIHJlc2l6ZSBpbW1lZGlhdGUgaWYgd2UgYWxyZWFkeVxuICAgICAgICAvLyBoYXZlIHRoZSB3aWR0aCBhbmQgaGVpZ2h0IG9mIHRoZSByZXNvdXJjZVxuICAgICAgICBpZiAodGhpcy5fd2lkdGggfHwgdGhpcy5faGVpZ2h0KSB7XG4gICAgICAgICAgICB0aGlzLm9uUmVzaXplLnJ1bih0aGlzLl93aWR0aCwgdGhpcy5faGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICAvLyB0aGlzLm9uUmVzaXplLmFkZChiYXNlVGV4dHVyZSk7XG4gICAgICAgIC8vIHRoaXMub25VcGRhdGUuYWRkKGJhc2VUZXh0dXJlKTtcbiAgICAgICAgLy8gQ2FsbCBhIHJlc2l6ZSBpbW1lZGlhdGUgaWYgd2UgYWxyZWFkeVxuICAgICAgICAvLyBoYXZlIHRoZSB3aWR0aCBhbmQgaGVpZ2h0IG9mIHRoZSByZXNvdXJjZVxuICAgICAgICAvLyBpZiAodGhpcy5fd2lkdGggfHwgdGhpcy5faGVpZ2h0KVxuICAgICAgICAvLyB7XG4gICAgICAgIC8vIFx0dGhpcy5kaXNwYXRjaEV2ZW50KEV2ZW50LmdldEV2ZW50KFwic2V0UmVhbFNpemVcIikpXG4gICAgICAgIC8vICAgICAvLyB0aGlzLm9uUmVzaXplLnJ1bih0aGlzLl93aWR0aCwgdGhpcy5faGVpZ2h0KTtcbiAgICAgICAgLy8gfVxuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogVW5iaW5kIHRvIGEgcGFyZW50IEJhc2VUZXh0dXJlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BJWEkuQmFzZVRleHR1cmV9IGJhc2VUZXh0dXJlIC0gUGFyZW50IHRleHR1cmVcbiAgICAgKi9cbiAgICB1bmJpbmQoYmFzZVRleHR1cmUpIHtcbiAgICAgICAgdGhpcy5vblJlc2l6ZS5yZW1vdmUoYmFzZVRleHR1cmUpO1xuICAgICAgICB0aGlzLm9uVXBkYXRlLnJlbW92ZShiYXNlVGV4dHVyZSk7XG4gICAgICAgIC8vIHRoaXMub25SZXNpemUucmVtb3ZlKGJhc2VUZXh0dXJlKTtcbiAgICAgICAgLy8gdGhpcy5vblVwZGF0ZS5yZW1vdmUoYmFzZVRleHR1cmUpO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogVHJpZ2dlciBhIHJlc2l6ZSBldmVudFxuICAgICAqL1xuICAgIHJlc2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIGlmICh3aWR0aCAhPT0gdGhpcy5fd2lkdGggfHwgaGVpZ2h0ICE9PSB0aGlzLl9oZWlnaHQpIHtcbiAgICAgICAgICAgIHRoaXMuX3dpZHRoID0gd2lkdGg7XG4gICAgICAgICAgICB0aGlzLl9oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgICAgICB0aGlzLm9uUmVzaXplLnJ1bih3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChFdmVudF8xLkV2ZW50LmdldEV2ZW50KFwic2V0UmVhbFNpemVcIikpO1xuICAgICAgICAgICAgLy8gRXZlbnQuZ2V0RXZlbnQoXCJzZXRSZWFsU2l6ZVwiKVxuICAgICAgICAgICAgLy8gdGhpcy5vblJlc2l6ZS5ydW4od2lkdGgsIGhlaWdodCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIEhhcyBiZWVuIHZhbGlkYXRlZFxuICAgICAqIEByZWFkb25seVxuICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XG4gICAgICovXG4gICAgZ2V0IHZhbGlkKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl93aWR0aCAmJiAhIXRoaXMuX2hlaWdodDtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIEhhcyBiZWVuIHVwZGF0ZWQgdHJpZ2dlciBldmVudFxuICAgICAqL1xuICAgIHVwZGF0ZShkZWx0YVRpbWUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KEV2ZW50XzEuRXZlbnQuZ2V0RXZlbnQoXCJ1cGRhdGVcIikpO1xuICAgICAgICB9XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBUaGlzIGNhbiBiZSBvdmVycmlkZGVuIHRvIHN0YXJ0IHByZWxvYWRpbmcgYSByZXNvdXJjZVxuICAgICAqIG9yIGRvIGFueSBvdGhlciBwcmVwYXJlIHN0ZXAuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEByZXR1cm4ge1Byb21pc2U8dm9pZD59IEhhbmRsZSB0aGUgdmFsaWRhdGUgZXZlbnRcbiAgICAgKi9cbiAgICBsb2FkKCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBUaGUgd2lkdGggb2YgdGhlIHJlc291cmNlLlxuICAgICAqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqIEByZWFkb25seVxuICAgICAqL1xuICAgIGdldCB3aWR0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dpZHRoO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogVGhlIGhlaWdodCBvZiB0aGUgcmVzb3VyY2UuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICogQHJlYWRvbmx5XG4gICAgICovXG4gICAgZ2V0IGhlaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hlaWdodDtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFVwbG9hZHMgdGhlIHRleHR1cmUgb3IgcmV0dXJucyBmYWxzZSBpZiBpdCBjYW50IGZvciBzb21lIHJlYXNvbi4gT3ZlcnJpZGUgdGhpcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UElYSS5SZW5kZXJlcn0gcmVuZGVyZXIgLSB5ZWFoLCByZW5kZXJlciFcbiAgICAgKiBAcGFyYW0ge1BJWEkuQmFzZVRleHR1cmV9IGJhc2VUZXh0dXJlIC0gdGhlIHRleHR1cmVcbiAgICAgKiBAcGFyYW0ge1BJWEkuR0xUZXh0dXJlfSBnbFRleHR1cmUgLSB0ZXh0dXJlIGluc3RhbmNlIGZvciB0aGlzIHdlYmdsIGNvbnRleHRcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpcyBzdWNjZXNzXG4gICAgICovXG4gICAgdXBsb2FkKHJlbmRlcmVyLCBiYXNlVGV4dHVyZSwgZ2xUZXh0dXJlLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBzdHlsZSwgb3B0aW9uYWwgdG8gb3ZlcnJpZGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UElYSS5SZW5kZXJlcn0gcmVuZGVyZXIgLSB5ZWFoLCByZW5kZXJlciFcbiAgICAgKiBAcGFyYW0ge1BJWEkuQmFzZVRleHR1cmV9IGJhc2VUZXh0dXJlIC0gdGhlIHRleHR1cmVcbiAgICAgKiBAcGFyYW0ge1BJWEkuR0xUZXh0dXJlfSBnbFRleHR1cmUgLSB0ZXh0dXJlIGluc3RhbmNlIGZvciB0aGlzIHdlYmdsIGNvbnRleHRcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlzIHN1Y2Nlc3NcbiAgICAgKi9cbiAgICBzdHlsZShyZW5kZXJlciwgYmFzZVRleHR1cmUsIGdsVGV4dHVyZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBDbGVhbiB1cCBhbnl0aGluZywgdGhpcyBoYXBwZW5zIHdoZW4gZGVzdHJveWluZyBpcyByZWFkeS5cbiAgICAgKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBkaXNwb3NlKCkge1xuICAgICAgICAvLyBvdmVycmlkZVxuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogQ2FsbCB3aGVuIGRlc3Ryb3lpbmcgcmVzb3VyY2UsIHVuYmluZCBhbnkgQmFzZVRleHR1cmUgb2JqZWN0XG4gICAgICogYmVmb3JlIGNhbGxpbmcgdGhpcyBtZXRob2QsIGFzIHJlZmVyZW5jZSBjb3VudHMgYXJlIG1haW50YWluZWRcbiAgICAgKiBpbnRlcm5hbGx5LlxuICAgICAqL1xuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIGlmICghdGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgIHRoaXMub25SZXNpemUucmVtb3ZlQWxsKCk7XG4gICAgICAgICAgICB0aGlzLm9uUmVzaXplID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMub25VcGRhdGUucmVtb3ZlQWxsKCk7XG4gICAgICAgICAgICB0aGlzLm9uVXBkYXRlID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuZGlzcG9zZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIDtcbn1cbmV4cG9ydHMuUmVzb3VyY2UgPSBSZXNvdXJjZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgRXZlbnREaXNwYXRjaGVyXzEgPSByZXF1aXJlKFwiLi9FdmVudERpc3BhdGNoZXJcIik7XG5jb25zdCBFdmVudF8xID0gcmVxdWlyZShcIi4vRXZlbnRcIik7XG5jb25zdCBQcm9ncmVzc0V2ZW50XzEgPSByZXF1aXJlKFwiLi9Qcm9ncmVzc0V2ZW50XCIpO1xuY2xhc3MgUmVzb3VyY2VMb2FkZXIgZXh0ZW5kcyBFdmVudERpc3BhdGNoZXJfMS5FdmVudERpc3BhdGNoZXIge1xuICAgIGNvbnN0cnVjdG9yKHJlcXVlc3QpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5jb21wbGV0ZSA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgbGV0IHByb21pc2UgPSB3aW5kb3cuY3JlYXRlSW1hZ2VCaXRtYXAodGhpcy5faW1hZ2VFbGVtZW50LCAwLCAwLCB0aGlzLl9pbWFnZUVsZW1lbnQud2lkdGgsIHRoaXMuX2ltYWdlRWxlbWVudC5oZWlnaHQpO1xuICAgICAgICAgICAgcHJvbWlzZS50aGVuKHRoaXMub25JbWFnZUJpdG1hcENyZWF0ZWQpLmNhdGNoKCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMub25JbWFnZUJpdG1hcENyZWF0ZWQgPSAoaW1hZ2UpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX2ltYWdlRGF0YSA9IGltYWdlO1xuICAgICAgICAgICAgdGhpcy5fY2xlYXJFdmVudHMoKTtcbiAgICAgICAgICAgIHRoaXMuX2ZpbmlzaCgpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9vblRpbWVvdXQgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmFib3J0KCdMb2FkIHRpbWVkIG91dC4nKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fb25Qcm9ncmVzcyA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgaWYgKGV2ZW50ICYmIGV2ZW50Lmxlbmd0aENvbXB1dGFibGUpIHtcbiAgICAgICAgICAgICAgICBsZXQgcGUgPSBQcm9ncmVzc0V2ZW50XzEuUHJvZ3Jlc3NFdmVudC5nZXRQcm9ncmVzc0V2ZW50KFByb2dyZXNzRXZlbnRfMS5Qcm9ncmVzc0V2ZW50LlBST0dSRVNTKTtcbiAgICAgICAgICAgICAgICBwZS5ieXRlc0xvYWRlZCA9IGV2ZW50LmxvYWRlZDtcbiAgICAgICAgICAgICAgICBwZS5ieXRlc1RvdGFsID0gZXZlbnQudG90YWw7XG4gICAgICAgICAgICAgICAgcGUucGVyY2VudCA9IGV2ZW50LmxvYWRlZCAvIGV2ZW50LnRvdGFsO1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX29uRXJyb3IgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuYWJvcnQoJ0ZhaWxlZCB0byBsb2FkIGVsZW1lbnQgdXNpbmc6ICcgKyBldmVudC50YXJnZXQubm9kZU5hbWUpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9yZXF1ZXN0ID0gcmVxdWVzdDtcbiAgICAgICAgdGhpcy5fZmxhZ3MgPSAwO1xuICAgICAgICB0aGlzLl9zZXRGbGFnKFJlc291cmNlTG9hZGVyLlNUQVRVU19GTEFHUy5EQVRBX1VSTCwgdGhpcy5fcmVxdWVzdC51cmwuaW5kZXhPZignZGF0YTonKSA9PT0gMCk7XG4gICAgICAgIHRoaXMuZXh0ZW5zaW9uID0gdGhpcy5fZ2V0RXh0ZW5zaW9uKCk7XG4gICAgICAgIHRoaXMuZGF0YSA9IG51bGw7XG4gICAgICAgIHRoaXMuY3Jvc3NPcmlnaW4gPSByZXF1ZXN0LmNyb3NzT3JpZ2luID09PSB0cnVlID8gJ2Fub255bW91cycgOiBcIlwiO1xuICAgICAgICB0aGlzLnRpbWVvdXQgPSByZXF1ZXN0LnRpbWVvdXQgfHwgMDtcbiAgICAgICAgdGhpcy5sb2FkVHlwZSA9IHRoaXMuX2RldGVybWluZUxvYWRUeXBlKCk7XG4gICAgICAgIHRoaXMuZXJyb3IgPSBudWxsO1xuICAgICAgICB0aGlzLnhociA9IG51bGw7XG4gICAgICAgIHRoaXMudHlwZSA9IFJlc291cmNlTG9hZGVyLlRZUEUuVU5LTk9XTjtcbiAgICAgICAgdGhpcy5wcm9ncmVzc0NodW5rID0gMDtcbiAgICAgICAgdGhpcy5fZWxlbWVudFRpbWVyID0gMDtcbiAgICAgICAgdGhpcy5tZXRhZGF0YSA9IHJlcXVlc3QucmVxdWVzdE1ldGFEYXRhO1xuICAgICAgICB0aGlzLnhoclR5cGUgPSBudWxsO1xuICAgICAgICAvLyB0aGlzLmNoaWxkcmVuID0gW107XG4gICAgICAgIC8vIHRoaXMuX2RlcXVldWUgPSBSZXNvdXJjZUxvYWRlci5fbm9vcDtcbiAgICAgICAgLy8gdGhpcy5fb25Mb2FkQmluZGluZyA9IG51bGw7XG4gICAgfVxuICAgIGxvYWQoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzTG9hZGluZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmlzQ29tcGxldGUpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChFdmVudF8xLkV2ZW50LmdldEV2ZW50KEV2ZW50XzEuRXZlbnQuQ09NUExFVEUpKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zZXRGbGFnKFJlc291cmNlTG9hZGVyLlNUQVRVU19GTEFHUy5MT0FESU5HLCB0cnVlKTtcbiAgICAgICAgaWYgKCF0aGlzLmNyb3NzT3JpZ2luKSB7XG4gICAgICAgICAgICB0aGlzLmNyb3NzT3JpZ2luID0gdGhpcy5fZGV0ZXJtaW5lQ3Jvc3NPcmlnaW4odGhpcy5fcmVxdWVzdC51cmwpO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAodGhpcy5sb2FkVHlwZSkge1xuICAgICAgICAgICAgY2FzZSBSZXNvdXJjZUxvYWRlci5MT0FEX1RZUEUuSU1BR0U6XG4gICAgICAgICAgICAgICAgdGhpcy50eXBlID0gUmVzb3VyY2VMb2FkZXIuVFlQRS5JTUFHRTtcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2FkRWxlbWVudCgnaW1hZ2UnKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgUmVzb3VyY2VMb2FkZXIuTE9BRF9UWVBFLkFVRElPOlxuICAgICAgICAgICAgICAgIHRoaXMudHlwZSA9IFJlc291cmNlTG9hZGVyLlRZUEUuQVVESU87XG4gICAgICAgICAgICAgICAgLy8gdGhpcy5fbG9hZFNvdXJjZUVsZW1lbnQoJ2F1ZGlvJyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFJlc291cmNlTG9hZGVyLkxPQURfVFlQRS5WSURFTzpcbiAgICAgICAgICAgICAgICB0aGlzLnR5cGUgPSBSZXNvdXJjZUxvYWRlci5UWVBFLlZJREVPO1xuICAgICAgICAgICAgICAgIC8vIHRoaXMuX2xvYWRTb3VyY2VFbGVtZW50KCd2aWRlbycpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBSZXNvdXJjZUxvYWRlci5MT0FEX1RZUEUuWEhSOlxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBpZiAoUmVzb3VyY2VMb2FkZXIudXNlWGRyICYmIHRoaXMuY3Jvc3NPcmlnaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbG9hZFhkcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbG9hZFhocigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvLyBfbG9hZFNvdXJjZUVsZW1lbnRcbiAgICAgICAgLy8gX2xvYWRYZHJcbiAgICAgICAgLy8gX2xvYWRYaHJcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIExvYWRzIHRoaXMgcmVzb3VyY2VzIHVzaW5nIGFuIGVsZW1lbnQgdGhhdCBoYXMgbXVsdGlwbGUgc291cmNlcyxcbiAgICAgKiBsaWtlIGFuIEhUTUxBdWRpb0VsZW1lbnQgb3IgSFRNTFZpZGVvRWxlbWVudC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgLSBUaGUgdHlwZSBvZiBlbGVtZW50IHRvIHVzZS5cbiAgICAgKi9cbiAgICAvLyBwcm90ZWN0ZWQgX2xvYWRTb3VyY2VFbGVtZW50KHR5cGUpOnZvaWRcbiAgICAvLyB7XG4gICAgLy8gICAgIGlmICh0aGlzLm1ldGFkYXRhLmxvYWRFbGVtZW50KSBcbiAgICAvLyAgICAge1xuICAgIC8vICAgICAgICAgdGhpcy5kYXRhID0gdGhpcy5tZXRhZGF0YS5sb2FkRWxlbWVudDtcbiAgICAvLyAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnYXVkaW8nICYmIHR5cGVvZiB3aW5kb3dbJ0F1ZGlvJ10gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgLy8gICAgICAgICB0aGlzLmRhdGEgPSBuZXcgQXVkaW8oKTtcbiAgICAvLyAgICAgfSBlbHNlIHtcbiAgICAvLyAgICAgICAgIHRoaXMuZGF0YSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodHlwZSk7XG4gICAgLy8gICAgIH1cbiAgICAvLyAgICAgaWYgKHRoaXMuZGF0YSA9PT0gbnVsbCkge1xuICAgIC8vICAgICAgICAgdGhpcy5hYm9ydCgnVW5zdXBwb3J0ZWQgZWxlbWVudDogJyArIHR5cGUpO1xuICAgIC8vICAgICAgICAgcmV0dXJuO1xuICAgIC8vICAgICB9XG4gICAgLy8gICAgIGlmICh0aGlzLmNyb3NzT3JpZ2luKSB7XG4gICAgLy8gICAgICAgICB0aGlzLmRhdGEuY3Jvc3NPcmlnaW4gPSB0aGlzLmNyb3NzT3JpZ2luO1xuICAgIC8vICAgICB9XG4gICAgLy8gICAgIGlmICghdGhpcy5tZXRhZGF0YS5za2lwU291cmNlKSB7XG4gICAgLy8gICAgICAgICAvLyBzdXBwb3J0IGZvciBDb2Nvb25KUyBDYW52YXMrIHJ1bnRpbWUsIGxhY2tzIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NvdXJjZScpXG4gICAgLy8gICAgICAgICBpZiAobmF2aWdhdG9yWydpc0NvY29vbkpTJ10pIHtcbiAgICAvLyAgICAgICAgICAgICB0aGlzLmRhdGEuc3JjID0gQXJyYXkuaXNBcnJheSh0aGlzLl9yZXF1ZXN0LnVybCkgPyB0aGlzLl9yZXF1ZXN0LnVybFswXSA6IHRoaXMuX3JlcXVlc3QudXJsO1xuICAgIC8vICAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHRoaXMuX3JlcXVlc3QudXJsKSkge1xuICAgIC8vICAgICAgICAgICAgIHZhciBtaW1lVHlwZXMgPSB0aGlzLm1ldGFkYXRhLm1pbWVUeXBlO1xuICAgIC8vICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fcmVxdWVzdC51cmwubGVuZ3RoOyArK2kpIHtcbiAgICAvLyAgICAgICAgICAgICAgICAgdGhpcy5kYXRhLmFwcGVuZENoaWxkKHRoaXMuX2NyZWF0ZVNvdXJjZSh0eXBlLCB0aGlzLl9yZXF1ZXN0LnVybFtpXSwgQXJyYXkuaXNBcnJheShtaW1lVHlwZXMpID8gbWltZVR5cGVzW2ldIDogbWltZVR5cGVzKSk7XG4gICAgLy8gICAgICAgICAgICAgfVxuICAgIC8vICAgICAgICAgfSBlbHNlIHtcbiAgICAvLyAgICAgICAgICAgICB2YXIgX21pbWVUeXBlcyA9IHRoaXMubWV0YWRhdGEubWltZVR5cGU7XG4gICAgLy8gICAgICAgICAgICAgdGhpcy5kYXRhLmFwcGVuZENoaWxkKHRoaXMuX2NyZWF0ZVNvdXJjZSh0eXBlLCB0aGlzLl9yZXF1ZXN0LnVybCwgQXJyYXkuaXNBcnJheShfbWltZVR5cGVzKSA/IF9taW1lVHlwZXNbMF0gOiBfbWltZVR5cGVzKSk7XG4gICAgLy8gICAgICAgICB9XG4gICAgLy8gICAgIH1cbiAgICAvLyAgICAgdGhpcy5kYXRhLmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgdGhpcy5fYm91bmRPbkVycm9yLCBmYWxzZSk7XG4gICAgLy8gICAgIHRoaXMuZGF0YS5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgdGhpcy5fYm91bmRDb21wbGV0ZSwgZmFsc2UpO1xuICAgIC8vICAgICB0aGlzLmRhdGEuYWRkRXZlbnRMaXN0ZW5lcigncHJvZ3Jlc3MnLCB0aGlzLl9ib3VuZE9uUHJvZ3Jlc3MsIGZhbHNlKTtcbiAgICAvLyAgICAgdGhpcy5kYXRhLmFkZEV2ZW50TGlzdGVuZXIoJ2NhbnBsYXl0aHJvdWdoJywgdGhpcy5fYm91bmRDb21wbGV0ZSwgZmFsc2UpO1xuICAgIC8vICAgICB0aGlzLmRhdGEubG9hZCgpO1xuICAgIC8vICAgICBpZiAodGhpcy50aW1lb3V0KSB7XG4gICAgLy8gICAgICAgICB0aGlzLl9lbGVtZW50VGltZXIgPSBzZXRUaW1lb3V0KHRoaXMuX2JvdW5kT25UaW1lb3V0LCB0aGlzLnRpbWVvdXQpO1xuICAgIC8vICAgICB9XG4gICAgLy8gfTtcbiAgICBfY2xlYXJFdmVudHMoKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9lbGVtZW50VGltZXIpO1xuICAgICAgICBpZiAodGhpcy5faW1hZ2VFbGVtZW50ICYmIHRoaXMuX2ltYWdlRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKSB7XG4gICAgICAgICAgICB0aGlzLl9pbWFnZUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXJyb3InLCB0aGlzLl9vbkVycm9yKTtcbiAgICAgICAgICAgIHRoaXMuX2ltYWdlRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdsb2FkJywgdGhpcy5jb21wbGV0ZSk7XG4gICAgICAgICAgICB0aGlzLl9pbWFnZUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigncHJvZ3Jlc3MnLCB0aGlzLl9vblByb2dyZXNzKTtcbiAgICAgICAgICAgIHRoaXMuX2ltYWdlRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdjYW5wbGF5dGhyb3VnaCcsIHRoaXMuY29tcGxldGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnhocikge1xuICAgICAgICAgICAgLy8gaWYgKHRoaXMueGhyLnJlbW92ZUV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgICAgIC8vICAgICB0aGlzLnhoci5yZW1vdmVFdmVudExpc3RlbmVyKCdlcnJvcicsIHRoaXMuX2JvdW5kWGhyT25FcnJvciwgZmFsc2UpO1xuICAgICAgICAgICAgLy8gICAgIHRoaXMueGhyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RpbWVvdXQnLCB0aGlzLl9ib3VuZFhock9uVGltZW91dCwgZmFsc2UpO1xuICAgICAgICAgICAgLy8gICAgIHRoaXMueGhyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgdGhpcy5fYm91bmRYaHJPbkFib3J0LCBmYWxzZSk7XG4gICAgICAgICAgICAvLyAgICAgdGhpcy54aHIucmVtb3ZlRXZlbnRMaXN0ZW5lcigncHJvZ3Jlc3MnLCB0aGlzLl9ib3VuZE9uUHJvZ3Jlc3MsIGZhbHNlKTtcbiAgICAgICAgICAgIC8vICAgICB0aGlzLnhoci5yZW1vdmVFdmVudExpc3RlbmVyKCdsb2FkJywgdGhpcy5fYm91bmRYaHJPbkxvYWQsIGZhbHNlKTtcbiAgICAgICAgICAgIC8vIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyAgICAgdGhpcy54aHIub25lcnJvciA9IG51bGw7XG4gICAgICAgICAgICAvLyAgICAgdGhpcy54aHIub250aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgICAgIC8vICAgICB0aGlzLnhoci5vbnByb2dyZXNzID0gbnVsbDtcbiAgICAgICAgICAgIC8vICAgICB0aGlzLnhoci5vbmxvYWQgPSBudWxsO1xuICAgICAgICAgICAgLy8gfVxuICAgICAgICB9XG4gICAgfVxuICAgIDtcbiAgICBfbG9hZEVsZW1lbnQodHlwZSkge1xuICAgICAgICB0aGlzLl9pbWFnZUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW1nXCIpO1xuICAgICAgICBpZiAodGhpcy5jcm9zc09yaWdpbikge1xuICAgICAgICAgICAgdGhpcy5faW1hZ2VFbGVtZW50LmNyb3NzT3JpZ2luID0gdGhpcy5jcm9zc09yaWdpbjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9pbWFnZUVsZW1lbnQuc3JjID0gdGhpcy5fcmVxdWVzdC51cmw7XG4gICAgICAgIHRoaXMuX2ltYWdlRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIHRoaXMuX29uRXJyb3IpO1xuICAgICAgICB0aGlzLl9pbWFnZUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIHRoaXMuY29tcGxldGUpO1xuICAgICAgICB0aGlzLl9pbWFnZUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigncHJvZ3Jlc3MnLCB0aGlzLl9vblByb2dyZXNzKTtcbiAgICAgICAgLy8gaWYgKHRoaXMudGltZW91dCA+IDApIFxuICAgICAgICAvLyB7XG4gICAgICAgIC8vICAgICB0aGlzLl9lbGVtZW50VGltZXIgPSBzZXRUaW1lb3V0KHRoaXMuX29uVGltZW91dCwgdGhpcy50aW1lb3V0KTtcbiAgICAgICAgLy8gfVxuICAgIH1cbiAgICA7XG4gICAgZ2V0IGltYWdlRGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ltYWdlRGF0YTtcbiAgICB9XG4gICAgYWJvcnQobWVzc2FnZSkge1xuICAgICAgICBpZiAodGhpcy5lcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZXJyb3IgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgICAgIHRoaXMuX2NsZWFyRXZlbnRzKCk7XG4gICAgICAgIGlmICh0aGlzLnhocikge1xuICAgICAgICAgICAgdGhpcy54aHIuYWJvcnQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnhkcikge1xuICAgICAgICAgICAgdGhpcy54ZHIuYWJvcnQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmRhdGEpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRhdGEuc3JjKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhLnNyYyA9IFJlc291cmNlTG9hZGVyLkVNUFRZX0dJRjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHdoaWxlICh0aGlzLmRhdGEuZmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRhdGEucmVtb3ZlQ2hpbGQodGhpcy5kYXRhLmZpcnN0Q2hpbGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9maW5pc2goKTtcbiAgICB9XG4gICAgO1xuICAgIF9maW5pc2goKSB7XG4gICAgICAgIGlmICh0aGlzLmlzQ29tcGxldGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zZXRGbGFnKFJlc291cmNlTG9hZGVyLlNUQVRVU19GTEFHUy5DT01QTEVURSwgdHJ1ZSk7XG4gICAgICAgIHRoaXMuX3NldEZsYWcoUmVzb3VyY2VMb2FkZXIuU1RBVFVTX0ZMQUdTLkxPQURJTkcsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KEV2ZW50XzEuRXZlbnQuZ2V0RXZlbnQoRXZlbnRfMS5FdmVudC5DT01QTEVURSkpO1xuICAgIH1cbiAgICA7XG4gICAgX2RldGVybWluZUNyb3NzT3JpZ2luKHVybCwgbG9jID0gbnVsbCkge1xuICAgICAgICBpZiAodXJsLmluZGV4T2YoJ2RhdGE6JykgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgICAgICBpZiAod2luZG93WydvcmlnaW4nXSAhPT0gd2luZG93LmxvY2F0aW9uLm9yaWdpbikge1xuICAgICAgICAgICAgcmV0dXJuICdhbm9ueW1vdXMnO1xuICAgICAgICB9XG4gICAgICAgIGxvYyA9IGxvYyB8fCB3aW5kb3cubG9jYXRpb247XG4gICAgICAgIGlmICghUmVzb3VyY2VMb2FkZXIudGVtcEFuY2hvcikge1xuICAgICAgICAgICAgUmVzb3VyY2VMb2FkZXIudGVtcEFuY2hvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcbiAgICAgICAgfVxuICAgICAgICBSZXNvdXJjZUxvYWRlci50ZW1wQW5jaG9yLmhyZWYgPSB1cmw7XG4gICAgICAgIGxldCB1cmkgPSBSZXNvdXJjZUxvYWRlci5wYXJzZVVyaShSZXNvdXJjZUxvYWRlci50ZW1wQW5jaG9yLmhyZWYsIHRydWUpO1xuICAgICAgICBsZXQgc2FtZVBvcnQgPSAhdXJpLnBvcnQgJiYgbG9jLnBvcnQgPT09ICcnIHx8IHVyaS5wb3J0ID09PSBsb2MucG9ydDtcbiAgICAgICAgbGV0IHByb3RvY29sID0gdXJpLnByb3RvY29sID8gdXJpLnByb3RvY29sICsgJzonIDogJyc7XG4gICAgICAgIGlmICh1cmkuaG9zdCAhPT0gbG9jLmhvc3RuYW1lIHx8ICFzYW1lUG9ydCB8fCBwcm90b2NvbCAhPT0gbG9jLnByb3RvY29sKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2Fub255bW91cyc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICA7XG4gICAgc3RhdGljIHBhcnNlVXJpKHN0ciwgc3RyaWN0ID0gdHJ1ZSkge1xuICAgICAgICBsZXQgbyA9IHtcbiAgICAgICAgICAgIGtleTogWydzb3VyY2UnLCAncHJvdG9jb2wnLCAnYXV0aG9yaXR5JywgJ3VzZXJJbmZvJywgJ3VzZXInLCAncGFzc3dvcmQnLCAnaG9zdCcsICdwb3J0JywgJ3JlbGF0aXZlJywgJ3BhdGgnLCAnZGlyZWN0b3J5JywgJ2ZpbGUnLCAncXVlcnknLCAnYW5jaG9yJ10sXG4gICAgICAgICAgICBxOiB7XG4gICAgICAgICAgICAgICAgbmFtZTogJ3F1ZXJ5S2V5JyxcbiAgICAgICAgICAgICAgICBwYXJzZXI6IC8oPzpefCYpKFteJj1dKik9PyhbXiZdKikvZ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBhcnNlcjoge1xuICAgICAgICAgICAgICAgIHN0cmljdDogL14oPzooW146XFwvPyNdKyk6KT8oPzpcXC9cXC8oKD86KChbXjpAXSopKD86OihbXjpAXSopKT8pP0ApPyhbXjpcXC8/I10qKSg/OjooXFxkKikpPykpPygoKCg/OltePyNcXC9dKlxcLykqKShbXj8jXSopKSg/OlxcPyhbXiNdKikpPyg/OiMoLiopKT8pLyxcbiAgICAgICAgICAgICAgICBsb29zZTogL14oPzooPyFbXjpAXSs6W146QFxcL10qQCkoW146XFwvPyMuXSspOik/KD86XFwvXFwvKT8oKD86KChbXjpAXSopKD86OihbXjpAXSopKT8pP0ApPyhbXjpcXC8/I10qKSg/OjooXFxkKikpPykoKChcXC8oPzpbXj8jXSg/IVtePyNcXC9dKlxcLltePyNcXC8uXSsoPzpbPyNdfCQpKSkqXFwvPyk/KFtePyNcXC9dKikpKD86XFw/KFteI10qKSk/KD86IyguKikpPykvXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGxldCBtID0gby5wYXJzZXJbc3RyaWN0ID8gJ3N0cmljdCcgOiAnbG9vc2UnXS5leGVjKHN0cik7XG4gICAgICAgIGxldCB1cmkgPSBuZXcgVVJJRGF0YSgpO1xuICAgICAgICB1cmkuc291cmNlID0gbVtcInNvdXJjZVwiXSB8fCAnJztcbiAgICAgICAgdXJpLnByb3RvY29sID0gbVtcInByb3RvY29sXCJdIHx8ICcnO1xuICAgICAgICB1cmkuYXV0aG9yaXR5ID0gbVtcImF1dGhvcml0eVwiXSB8fCAnJztcbiAgICAgICAgdXJpLnVzZXJJbmZvID0gbVtcInVzZXJJbmZvXCJdIHx8ICcnO1xuICAgICAgICB1cmkudXNlciA9IG1bXCJ1c2VyXCJdIHx8ICcnO1xuICAgICAgICB1cmkucGFzc3dvcmQgPSBtW1wicGFzc3dvcmRcIl0gfHwgJyc7XG4gICAgICAgIHVyaS5ob3N0ID0gbVtcImhvc3RcIl0gfHwgJyc7XG4gICAgICAgIHVyaS5wb3J0ID0gbVtcInBvcnRcIl0gfHwgJyc7XG4gICAgICAgIHVyaS5yZWxhdGl2ZSA9IG1bXCJyZWxhdGl2ZVwiXSB8fCAnJztcbiAgICAgICAgdXJpLnBhdGggPSBtW1wicGF0aFwiXSB8fCAnJztcbiAgICAgICAgdXJpLmRpcmVjdG9yeSA9IG1bXCJkaXJlY3RvcnlcIl0gfHwgJyc7XG4gICAgICAgIHVyaS5maWxlID0gbVtcImZpbGVcIl0gfHwgJyc7XG4gICAgICAgIHVyaS5xdWVyeSA9IG1bXCJxdWVyeVwiXSB8fCAnJztcbiAgICAgICAgdXJpLmFuY2hvciA9IG1bXCJhbmNob3JcIl0gfHwgJyc7XG4gICAgICAgIHVyaVtvLnEubmFtZV0gPSB7fTtcbiAgICAgICAgdXJpW28ua2V5WzEyXV0ucmVwbGFjZShvLnEucGFyc2VyLCBmdW5jdGlvbiAoJDAsICQxLCAkMikge1xuICAgICAgICAgICAgaWYgKCQxKSB7XG4gICAgICAgICAgICAgICAgdXJpW28ucS5uYW1lXVskMV0gPSAkMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB1cmk7XG4gICAgfVxuICAgIDtcbiAgICBfZGV0ZXJtaW5lTG9hZFR5cGUoKSB7XG4gICAgICAgIHJldHVybiBSZXNvdXJjZUxvYWRlci5fbG9hZFR5cGVNYXBbdGhpcy5leHRlbnNpb25dIHx8IFJlc291cmNlTG9hZGVyLkxPQURfVFlQRS5YSFI7XG4gICAgfVxuICAgIDtcbiAgICBfZ2V0RXh0ZW5zaW9uKCkge1xuICAgICAgICBsZXQgdXJsID0gdGhpcy5fcmVxdWVzdC51cmw7XG4gICAgICAgIGxldCBleHQgPSAnJztcbiAgICAgICAgaWYgKHRoaXMuaXNEYXRhVXJsKSB7XG4gICAgICAgICAgICBsZXQgc2xhc2hJbmRleCA9IHVybC5pbmRleE9mKCcvJyk7XG4gICAgICAgICAgICBleHQgPSB1cmwuc3Vic3RyaW5nKHNsYXNoSW5kZXggKyAxLCB1cmwuaW5kZXhPZignOycsIHNsYXNoSW5kZXgpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBxdWVyeVN0YXJ0ID0gdXJsLmluZGV4T2YoJz8nKTtcbiAgICAgICAgICAgIGxldCBoYXNoU3RhcnQgPSB1cmwuaW5kZXhPZignIycpO1xuICAgICAgICAgICAgbGV0IGluZGV4ID0gTWF0aC5taW4ocXVlcnlTdGFydCA+IC0xID8gcXVlcnlTdGFydCA6IHVybC5sZW5ndGgsIGhhc2hTdGFydCA+IC0xID8gaGFzaFN0YXJ0IDogdXJsLmxlbmd0aCk7XG4gICAgICAgICAgICB1cmwgPSB1cmwuc3Vic3RyaW5nKDAsIGluZGV4KTtcbiAgICAgICAgICAgIGV4dCA9IHVybC5zdWJzdHJpbmcodXJsLmxhc3RJbmRleE9mKCcuJykgKyAxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXh0LnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuICAgIDtcbiAgICBfaGFzRmxhZyhmbGFnKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5fZmxhZ3MgJiBmbGFnKSAhPT0gMDtcbiAgICB9XG4gICAgO1xuICAgIF9zZXRGbGFnKGZsYWcsIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2ZsYWdzID0gdmFsdWUgPyB0aGlzLl9mbGFncyB8IGZsYWcgOiB0aGlzLl9mbGFncyAmIH5mbGFnO1xuICAgIH1cbiAgICA7XG4gICAgc3RhdGljIHNldEV4dE1hcChtYXAsIGV4dG5hbWUsIHZhbCkge1xuICAgICAgICBpZiAoZXh0bmFtZSAmJiBleHRuYW1lLmluZGV4T2YoJy4nKSA9PT0gMCkge1xuICAgICAgICAgICAgZXh0bmFtZSA9IGV4dG5hbWUuc3Vic3RyaW5nKDEpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZXh0bmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG1hcFtleHRuYW1lXSA9IHZhbDtcbiAgICB9XG4gICAgc3RhdGljIHNldEV4dGVuc2lvbkxvYWRUeXBlKGV4dG5hbWUsIGxvYWRUeXBlKSB7XG4gICAgICAgIFJlc291cmNlTG9hZGVyLnNldEV4dE1hcChSZXNvdXJjZUxvYWRlci5fbG9hZFR5cGVNYXAsIGV4dG5hbWUsIGxvYWRUeXBlKTtcbiAgICB9XG4gICAgO1xuICAgIHN0YXRpYyBzZXRFeHRlbnNpb25YaHJUeXBlKGV4dG5hbWUsIHhoclR5cGUpIHtcbiAgICAgICAgUmVzb3VyY2VMb2FkZXIuc2V0RXh0TWFwKFJlc291cmNlTG9hZGVyLl94aHJUeXBlTWFwLCBleHRuYW1lLCB4aHJUeXBlKTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFF1aWNrIGhlbHBlciB0byBnZXQgc3RyaW5nIHhociB0eXBlLlxuICAgICAqXG4gICAgICogQGlnbm9yZVxuICAgICAqIEBwYXJhbSB7WE1MSHR0cFJlcXVlc3R8WERvbWFpblJlcXVlc3R9IHhociAtIFRoZSByZXF1ZXN0IHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIHR5cGUuXG4gICAgICovXG4gICAgc3RhdGljIHJlcVR5cGUoeGhyKSB7XG4gICAgICAgIHJldHVybiB4aHIudG9TdHJpbmcoKS5yZXBsYWNlKCdvYmplY3QgJywgJycpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb2FkcyB0aGlzIHJlc291cmNlcyB1c2luZyBhbiBYTUxIdHRwUmVxdWVzdC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2xvYWRYaHIoKSB7XG4gICAgICAgIC8vIC8vIGlmIHVuc2V0LCBkZXRlcm1pbmUgdGhlIHZhbHVlXG4gICAgICAgIC8vIGlmICh0eXBlb2YgdGhpcy54aHJUeXBlICE9PSAnc3RyaW5nJykge1xuICAgICAgICAvLyAgICAgdGhpcy54aHJUeXBlID0gdGhpcy5fZGV0ZXJtaW5lWGhyVHlwZSgpO1xuICAgICAgICAvLyB9XG4gICAgICAgIC8vIHZhciB4aHIgPSB0aGlzLnhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICAvLyAvLyBzZXQgdGhlIHJlcXVlc3QgdHlwZSBhbmQgdXJsXG4gICAgICAgIC8vIHhoci5vcGVuKCdHRVQnLCB0aGlzLl9yZXF1ZXN0LnVybCwgdHJ1ZSk7XG4gICAgICAgIC8vIHhoci50aW1lb3V0ID0gdGhpcy50aW1lb3V0O1xuICAgICAgICAvLyAvLyBsb2FkIGpzb24gYXMgdGV4dCBhbmQgcGFyc2UgaXQgb3Vyc2VsdmVzLiBXZSBkbyB0aGlzIGJlY2F1c2Ugc29tZSBicm93c2Vyc1xuICAgICAgICAvLyAvLyAqY291Z2gqIHNhZmFyaSAqY291Z2gqIGNhbid0IGRlYWwgd2l0aCBpdC5cbiAgICAgICAgLy8gaWYgKHRoaXMueGhyVHlwZSA9PT0gUmVzb3VyY2VMb2FkZXIuWEhSX1JFU1BPTlNFX1RZUEUuSlNPTiB8fCB0aGlzLnhoclR5cGUgPT09IFJlc291cmNlTG9hZGVyLlhIUl9SRVNQT05TRV9UWVBFLkRPQ1VNRU5UKSB7XG4gICAgICAgIC8vICAgICB4aHIucmVzcG9uc2VUeXBlID0gPGFueT5SZXNvdXJjZUxvYWRlci5YSFJfUkVTUE9OU0VfVFlQRS5URVhUO1xuICAgICAgICAvLyB9IGVsc2Uge1xuICAgICAgICAvLyAgICAgeGhyLnJlc3BvbnNlVHlwZSA9IHRoaXMueGhyVHlwZTtcbiAgICAgICAgLy8gfVxuICAgICAgICAvLyB4aHIuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCB0aGlzLl9ib3VuZFhock9uRXJyb3IsIGZhbHNlKTtcbiAgICAgICAgLy8geGhyLmFkZEV2ZW50TGlzdGVuZXIoJ3RpbWVvdXQnLCB0aGlzLl9ib3VuZFhock9uVGltZW91dCwgZmFsc2UpO1xuICAgICAgICAvLyB4aHIuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCB0aGlzLl9ib3VuZFhock9uQWJvcnQsIGZhbHNlKTtcbiAgICAgICAgLy8geGhyLmFkZEV2ZW50TGlzdGVuZXIoJ3Byb2dyZXNzJywgdGhpcy5fYm91bmRPblByb2dyZXNzLCBmYWxzZSk7XG4gICAgICAgIC8vIHhoci5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgdGhpcy5fYm91bmRYaHJPbkxvYWQsIGZhbHNlKTtcbiAgICAgICAgLy8geGhyLnNlbmQoKTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIExvYWRzIHRoaXMgcmVzb3VyY2VzIHVzaW5nIGFuIFhEb21haW5SZXF1ZXN0LiBUaGlzIGlzIGhlcmUgYmVjYXVzZSB3ZSBuZWVkIHRvIHN1cHBvcnQgSUU5IChncm9zcykuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9sb2FkWGRyKCkge1xuICAgICAgICAvLyAvLyBpZiB1bnNldCwgZGV0ZXJtaW5lIHRoZSB2YWx1ZVxuICAgICAgICAvLyBpZiAodHlwZW9mIHRoaXMueGhyVHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgLy8gICAgIHRoaXMueGhyVHlwZSA9IHRoaXMuX2RldGVybWluZVhoclR5cGUoKTtcbiAgICAgICAgLy8gfVxuICAgICAgICAvLyB2YXIgeGRyID0gdGhpcy54aHIgPSBuZXcgd2luZG93WydYRG9tYWluUmVxdWVzdCddKCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcbiAgICAgICAgLy8gLy8gWERvbWFpblJlcXVlc3QgaGFzIGEgZmV3IHF1aXJrcy4gT2NjYXNpb25hbGx5IGl0IHdpbGwgYWJvcnQgcmVxdWVzdHNcbiAgICAgICAgLy8gLy8gQSB3YXkgdG8gYXZvaWQgdGhpcyBpcyB0byBtYWtlIHN1cmUgQUxMIGNhbGxiYWNrcyBhcmUgc2V0IGV2ZW4gaWYgbm90IHVzZWRcbiAgICAgICAgLy8gLy8gTW9yZSBpbmZvIGhlcmU6IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTU3ODY5NjYveGRvbWFpbnJlcXVlc3QtYWJvcnRzLXBvc3Qtb24taWUtOVxuICAgICAgICAvLyB4ZHIudGltZW91dCA9IHRoaXMudGltZW91dCB8fCA1MDAwOyAvLyBYRFIgbmVlZHMgYSB0aW1lb3V0IHZhbHVlIG9yIGl0IGJyZWFrcyBpbiBJRTlcbiAgICAgICAgLy8geGRyLm9uZXJyb3IgPSB0aGlzLl9ib3VuZFhock9uRXJyb3I7XG4gICAgICAgIC8vIHhkci5vbnRpbWVvdXQgPSB0aGlzLl9ib3VuZFhock9uVGltZW91dDtcbiAgICAgICAgLy8geGRyLm9ucHJvZ3Jlc3MgPSB0aGlzLl9ib3VuZE9uUHJvZ3Jlc3M7XG4gICAgICAgIC8vIHhkci5vbmxvYWQgPSB0aGlzLl9ib3VuZFhock9uTG9hZDtcbiAgICAgICAgLy8geGRyLm9wZW4oJ0dFVCcsIHRoaXMuX3JlcXVlc3QudXJsLCB0cnVlKTtcbiAgICAgICAgLy8gLy8gTm90ZTogVGhlIHhkci5zZW5kKCkgY2FsbCBpcyB3cmFwcGVkIGluIGEgdGltZW91dCB0byBwcmV2ZW50IGFuXG4gICAgICAgIC8vIC8vIGlzc3VlIHdpdGggdGhlIGludGVyZmFjZSB3aGVyZSBzb21lIHJlcXVlc3RzIGFyZSBsb3N0IGlmIG11bHRpcGxlXG4gICAgICAgIC8vIC8vIFhEb21haW5SZXF1ZXN0cyBhcmUgYmVpbmcgc2VudCBhdCB0aGUgc2FtZSB0aW1lLlxuICAgICAgICAvLyAvLyBTb21lIGluZm8gaGVyZTogaHR0cHM6Ly9naXRodWIuY29tL3Bob3RvbnN0b3JtL3BoYXNlci9pc3N1ZXMvMTI0OFxuICAgICAgICAvLyBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gICAgIHJldHVybiB4ZHIuc2VuZCgpO1xuICAgICAgICAvLyB9LCAxKTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzb3VyY2UgdXNlZCBpbiBsb2FkaW5nIHZpYSBhbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSAtIFRoZSBlbGVtZW50IHR5cGUgKHZpZGVvIG9yIGF1ZGlvKS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsIC0gVGhlIHNvdXJjZSBVUkwgdG8gbG9hZCBmcm9tLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbbWltZV0gLSBUaGUgbWltZSB0eXBlIG9mIHRoZSB2aWRlb1xuICAgICAqIEByZXR1cm4ge0hUTUxTb3VyY2VFbGVtZW50fSBUaGUgc291cmNlIGVsZW1lbnQuXG4gICAgICovXG4gICAgX2NyZWF0ZVNvdXJjZSh0eXBlLCB1cmwsIG1pbWUpIHtcbiAgICAgICAgLy8gaWYgKCFtaW1lKSB7XG4gICAgICAgIC8vICAgICBtaW1lID0gdHlwZSArICcvJyArIHRoaXMuX2dldEV4dGVuc2lvbih1cmwpO1xuICAgICAgICAvLyB9XG4gICAgICAgIC8vIHZhciBzb3VyY2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzb3VyY2UnKTtcbiAgICAgICAgLy8gc291cmNlLnNyYyA9IHVybDtcbiAgICAgICAgLy8gc291cmNlLnR5cGUgPSBtaW1lO1xuICAgICAgICAvLyByZXR1cm4gc291cmNlO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIGlmIGFuIGVycm9yIGV2ZW50IGZpcmVzIGZvciB4aHIveGRyLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfeGhyT25FcnJvcigpIHtcbiAgICAgICAgdmFyIHhociA9IHRoaXMueGhyO1xuICAgICAgICB0aGlzLmFib3J0KFJlc291cmNlTG9hZGVyLnJlcVR5cGUoeGhyKSArICcgUmVxdWVzdCBmYWlsZWQuIFN0YXR1czogJyArIHhoci5zdGF0dXMgKyAnLCB0ZXh0OiBcIicgKyB4aHIuc3RhdHVzVGV4dCArICdcIicpO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIGlmIGFuIGVycm9yIGV2ZW50IGZpcmVzIGZvciB4aHIveGRyLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfeGhyT25UaW1lb3V0KCkge1xuICAgICAgICB2YXIgeGhyID0gdGhpcy54aHI7XG4gICAgICAgIHRoaXMuYWJvcnQoUmVzb3VyY2VMb2FkZXIucmVxVHlwZSh4aHIpICsgJyBSZXF1ZXN0IHRpbWVkIG91dC4nKTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIENhbGxlZCBpZiBhbiBhYm9ydCBldmVudCBmaXJlcyBmb3IgeGhyL3hkci5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3hock9uQWJvcnQoKSB7XG4gICAgICAgIHZhciB4aHIgPSB0aGlzLnhocjtcbiAgICAgICAgdGhpcy5hYm9ydChSZXNvdXJjZUxvYWRlci5yZXFUeXBlKHhocikgKyAnIFJlcXVlc3Qgd2FzIGFib3J0ZWQgYnkgdGhlIHVzZXIuJyk7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbiBkYXRhIHN1Y2Nlc3NmdWxseSBsb2FkcyBmcm9tIGFuIHhoci94ZHIgcmVxdWVzdC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtYTUxIdHRwUmVxdWVzdExvYWRFdmVudHxFdmVudH0gZXZlbnQgLSBMb2FkIGV2ZW50XG4gICAgICovXG4gICAgX3hock9uTG9hZCgpIHtcbiAgICAgICAgLy8gdmFyIHhociA9IHRoaXMueGhyO1xuICAgICAgICAvLyB2YXIgdGV4dCA9ICcnO1xuICAgICAgICAvLyB2YXIgc3RhdHVzID0gdHlwZW9mIHhoci5zdGF0dXMgPT09ICd1bmRlZmluZWQnID8gUmVzb3VyY2VMb2FkZXIuU1RBVFVTX09LIDogeGhyLnN0YXR1czsgLy8gWERSIGhhcyBubyBgLnN0YXR1c2AsIGFzc3VtZSAyMDAuXG4gICAgICAgIC8vIC8vIHJlc3BvbnNlVGV4dCBpcyBhY2Nlc3NpYmxlIG9ubHkgaWYgcmVzcG9uc2VUeXBlIGlzICcnIG9yICd0ZXh0JyBhbmQgb24gb2xkZXIgYnJvd3NlcnNcbiAgICAgICAgLy8gaWYgKHhoci5yZXNwb25zZVR5cGUgPT09ICcnIHx8IHhoci5yZXNwb25zZVR5cGUgPT09ICd0ZXh0JyB8fCB0eXBlb2YgeGhyLnJlc3BvbnNlVHlwZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgLy8gICAgIHRleHQgPSB4aHIucmVzcG9uc2VUZXh0O1xuICAgICAgICAvLyB9XG4gICAgICAgIC8vIC8vIHN0YXR1cyBjYW4gYmUgMCB3aGVuIHVzaW5nIHRoZSBgZmlsZTovL2AgcHJvdG9jb2wgc28gd2UgYWxzbyBjaGVjayBpZiBhIHJlc3BvbnNlIGlzIHNldC5cbiAgICAgICAgLy8gLy8gSWYgaXQgaGFzIGEgcmVzcG9uc2UsIHdlIGFzc3VtZSAyMDA7IG90aGVyd2lzZSBhIDAgc3RhdHVzIGNvZGUgd2l0aCBubyBjb250ZW50cyBpcyBhbiBhYm9ydGVkIHJlcXVlc3QuXG4gICAgICAgIC8vIGlmIChzdGF0dXMgPT09IFJlc291cmNlTG9hZGVyLlNUQVRVU19OT05FICYmICh0ZXh0Lmxlbmd0aCA+IDAgfHwgeGhyLnJlc3BvbnNlVHlwZSA9PT0gUmVzb3VyY2VMb2FkZXIuWEhSX1JFU1BPTlNFX1RZUEUuQlVGRkVSKSkge1xuICAgICAgICAvLyAgICAgc3RhdHVzID0gUmVzb3VyY2VMb2FkZXIuU1RBVFVTX09LO1xuICAgICAgICAvLyB9XG4gICAgICAgIC8vIC8vIGhhbmRsZSBJRTkgYnVnOiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzEwMDQ2OTcyL21zaWUtcmV0dXJucy1zdGF0dXMtY29kZS1vZi0xMjIzLWZvci1hamF4LXJlcXVlc3RcbiAgICAgICAgLy8gZWxzZSBpZiAoc3RhdHVzID09PSBSZXNvdXJjZUxvYWRlci5TVEFUVVNfSUVfQlVHX0VNUFRZKSB7XG4gICAgICAgIC8vICAgICAgICAgc3RhdHVzID0gUmVzb3VyY2VMb2FkZXIuU1RBVFVTX0VNUFRZO1xuICAgICAgICAvLyAgICAgfVxuICAgICAgICAvLyB2YXIgc3RhdHVzVHlwZSA9IHN0YXR1cyAvIDEwMCB8IDA7XG4gICAgICAgIC8vIGlmIChzdGF0dXNUeXBlID09PSBSZXNvdXJjZUxvYWRlci5TVEFUVVNfVFlQRV9PSykge1xuICAgICAgICAvLyAgICAgLy8gaWYgdGV4dCwganVzdCByZXR1cm4gaXRcbiAgICAgICAgLy8gICAgIGlmICh0aGlzLnhoclR5cGUgPT09IFJlc291cmNlTG9hZGVyLlhIUl9SRVNQT05TRV9UWVBFLlRFWFQpIHtcbiAgICAgICAgLy8gICAgICAgICB0aGlzLmRhdGEgPSB0ZXh0O1xuICAgICAgICAvLyAgICAgICAgIHRoaXMudHlwZSA9IFJlc291cmNlTG9hZGVyLlRZUEUuVEVYVDtcbiAgICAgICAgLy8gICAgIH1cbiAgICAgICAgLy8gICAgIC8vIGlmIGpzb24sIHBhcnNlIGludG8ganNvbiBvYmplY3RcbiAgICAgICAgLy8gICAgIGVsc2UgaWYgKHRoaXMueGhyVHlwZSA9PT0gUmVzb3VyY2VMb2FkZXIuWEhSX1JFU1BPTlNFX1RZUEUuSlNPTikge1xuICAgICAgICAvLyAgICAgICAgICAgICB0cnkge1xuICAgICAgICAvLyAgICAgICAgICAgICAgICAgdGhpcy5kYXRhID0gSlNPTi5wYXJzZSh0ZXh0KTtcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgIHRoaXMudHlwZSA9IFJlc291cmNlTG9hZGVyLlRZUEUuSlNPTjtcbiAgICAgICAgLy8gICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyAgICAgICAgICAgICAgICAgdGhpcy5hYm9ydCgnRXJyb3IgdHJ5aW5nIHRvIHBhcnNlIGxvYWRlZCBqc29uOiAnICsgZSk7XG4gICAgICAgIC8vICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgIC8vICAgICAgICAgICAgIH1cbiAgICAgICAgLy8gICAgICAgICB9XG4gICAgICAgIC8vICAgICAgICAgLy8gaWYgeG1sLCBwYXJzZSBpbnRvIGFuIHhtbCBkb2N1bWVudCBvciBkaXYgZWxlbWVudFxuICAgICAgICAvLyAgICAgICAgIGVsc2UgaWYgKHRoaXMueGhyVHlwZSA9PT0gUmVzb3VyY2VMb2FkZXIuWEhSX1JFU1BPTlNFX1RZUEUuRE9DVU1FTlQpIHtcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgaWYgKHdpbmRvd1snRE9NUGFyc2VyJ10pIHtcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRvbXBhcnNlciA9IG5ldyBET01QYXJzZXIoKTtcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kYXRhID0gZG9tcGFyc2VyLnBhcnNlRnJvbVN0cmluZyh0ZXh0LCAndGV4dC94bWwnKTtcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgIGRpdi5pbm5lckhUTUwgPSB0ZXh0O1xuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRhdGEgPSBkaXY7XG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgIHRoaXMudHlwZSA9IFJlc291cmNlTG9hZGVyLlRZUEUuWE1MO1xuICAgICAgICAvLyAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWJvcnQoJ0Vycm9yIHRyeWluZyB0byBwYXJzZSBsb2FkZWQgeG1sOiAnICsgZSk7XG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAvLyAgICAgICAgICAgICAgICAgfVxuICAgICAgICAvLyAgICAgICAgICAgICB9XG4gICAgICAgIC8vICAgICAgICAgICAgIC8vIG90aGVyIHR5cGVzIGp1c3QgcmV0dXJuIHRoZSByZXNwb25zZVxuICAgICAgICAvLyAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICB0aGlzLmRhdGEgPSB4aHIucmVzcG9uc2UgfHwgdGV4dDtcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgIH1cbiAgICAgICAgLy8gfSBlbHNlIHtcbiAgICAgICAgLy8gICAgIHRoaXMuYWJvcnQoJ1snICsgeGhyLnN0YXR1cyArICddICcgKyB4aHIuc3RhdHVzVGV4dCArICc6ICcgKyB4aHIucmVzcG9uc2VVUkwpO1xuICAgICAgICAvLyAgICAgcmV0dXJuO1xuICAgICAgICAvLyB9XG4gICAgICAgIC8vIHRoaXMuY29tcGxldGUoKTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgdGhlIHJlc3BvbnNlVHlwZSBvZiBhbiBYSFIgcmVxdWVzdCBiYXNlZCBvbiB0aGUgZXh0ZW5zaW9uIG9mIHRoZVxuICAgICAqIHJlc291cmNlIGJlaW5nIGxvYWRlZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiB7UmVzb3VyY2UuWEhSX1JFU1BPTlNFX1RZUEV9IFRoZSByZXNwb25zZVR5cGUgdG8gdXNlLlxuICAgICAqL1xuICAgIF9kZXRlcm1pbmVYaHJUeXBlKCkge1xuICAgICAgICByZXR1cm4gUmVzb3VyY2VMb2FkZXIuX3hoclR5cGVNYXBbdGhpcy5leHRlbnNpb25dIHx8IFJlc291cmNlTG9hZGVyLlhIUl9SRVNQT05TRV9UWVBFLlRFWFQ7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIHRoZSBsb2FkVHlwZSBvZiBhIHJlc291cmNlIGJhc2VkIG9uIHRoZSBleHRlbnNpb24gb2YgdGhlXG4gICAgICogcmVzb3VyY2UgYmVpbmcgbG9hZGVkLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJuIHtSZXNvdXJjZS5MT0FEX1RZUEV9IFRoZSBsb2FkVHlwZSB0byB1c2UuXG4gICAgICovXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyB0aGUgbWltZSB0eXBlIG9mIGFuIFhIUiByZXF1ZXN0IGJhc2VkIG9uIHRoZSByZXNwb25zZVR5cGUgb2ZcbiAgICAgKiByZXNvdXJjZSBiZWluZyBsb2FkZWQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7UmVzb3VyY2UuWEhSX1JFU1BPTlNFX1RZUEV9IHR5cGUgLSBUaGUgdHlwZSB0byBnZXQgYSBtaW1lIHR5cGUgZm9yLlxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIG1pbWUgdHlwZSB0byB1c2UuXG4gICAgICovXG4gICAgX2dldE1pbWVGcm9tWGhyVHlwZSh0eXBlKSB7XG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgY2FzZSBSZXNvdXJjZUxvYWRlci5YSFJfUkVTUE9OU0VfVFlQRS5CVUZGRVI6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdhcHBsaWNhdGlvbi9vY3RldC1iaW5hcnknO1xuICAgICAgICAgICAgY2FzZSBSZXNvdXJjZUxvYWRlci5YSFJfUkVTUE9OU0VfVFlQRS5CTE9COlxuICAgICAgICAgICAgICAgIHJldHVybiAnYXBwbGljYXRpb24vYmxvYic7XG4gICAgICAgICAgICBjYXNlIFJlc291cmNlTG9hZGVyLlhIUl9SRVNQT05TRV9UWVBFLkRPQ1VNRU5UOlxuICAgICAgICAgICAgICAgIHJldHVybiAnYXBwbGljYXRpb24veG1sJztcbiAgICAgICAgICAgIGNhc2UgUmVzb3VyY2VMb2FkZXIuWEhSX1JFU1BPTlNFX1RZUEUuSlNPTjpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICAgICAgY2FzZSBSZXNvdXJjZUxvYWRlci5YSFJfUkVTUE9OU0VfVFlQRS5ERUZBVUxUOlxuICAgICAgICAgICAgY2FzZSBSZXNvdXJjZUxvYWRlci5YSFJfUkVTUE9OU0VfVFlQRS5URVhUOlxuICAgICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3RleHQvcGxhaW4nO1xuICAgICAgICB9XG4gICAgfVxuICAgIDtcbiAgICBnZXQgaXNEYXRhVXJsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faGFzRmxhZyhSZXNvdXJjZUxvYWRlci5TVEFUVVNfRkxBR1MuREFUQV9VUkwpO1xuICAgIH1cbiAgICBnZXQgaXNDb21wbGV0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hhc0ZsYWcoUmVzb3VyY2VMb2FkZXIuU1RBVFVTX0ZMQUdTLkNPTVBMRVRFKTtcbiAgICB9XG4gICAgZ2V0IGlzTG9hZGluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hhc0ZsYWcoUmVzb3VyY2VMb2FkZXIuU1RBVFVTX0ZMQUdTLkxPQURJTkcpO1xuICAgIH1cbn1cblJlc291cmNlTG9hZGVyLlNUQVRVU19OT05FID0gMDtcblJlc291cmNlTG9hZGVyLlNUQVRVU19PSyA9IDIwMDtcblJlc291cmNlTG9hZGVyLlNUQVRVU19FTVBUWSA9IDIwNDtcblJlc291cmNlTG9hZGVyLlNUQVRVU19JRV9CVUdfRU1QVFkgPSAxMjIzO1xuUmVzb3VyY2VMb2FkZXIuU1RBVFVTX1RZUEVfT0sgPSAyO1xuUmVzb3VyY2VMb2FkZXIudXNlWGRyID0gISEod2luZG93WydYRG9tYWluUmVxdWVzdCddICYmICEoJ3dpdGhDcmVkZW50aWFscycgaW4gbmV3IFhNTEh0dHBSZXF1ZXN0KCkpKTtcblJlc291cmNlTG9hZGVyLkVNUFRZX0dJRiA9ICdkYXRhOmltYWdlL2dpZjtiYXNlNjQsUjBsR09EbGhBUUFCQUlBQUFQLy8vd0FBQUNINUJBRUFBQUFBTEFBQUFBQUJBQUVBQUFJQ1JBRUFPdz09JztcblJlc291cmNlTG9hZGVyLkxPQURfVFlQRSA9IHtcbiAgICBYSFI6IDEsXG4gICAgSU1BR0U6IDIsXG4gICAgQVVESU86IDMsXG4gICAgVklERU86IDRcbn07XG5SZXNvdXJjZUxvYWRlci5YSFJfUkVTUE9OU0VfVFlQRSA9IHtcbiAgICBERUZBVUxUOiAndGV4dCcsXG4gICAgQlVGRkVSOiAnYXJyYXlidWZmZXInLFxuICAgIEJMT0I6ICdibG9iJyxcbiAgICBET0NVTUVOVDogJ2RvY3VtZW50JyxcbiAgICBKU09OOiAnanNvbicsXG4gICAgVEVYVDogJ3RleHQnXG59O1xuUmVzb3VyY2VMb2FkZXIuX3hoclR5cGVNYXAgPSB7XG4gICAgeGh0bWw6IFJlc291cmNlTG9hZGVyLlhIUl9SRVNQT05TRV9UWVBFLkRPQ1VNRU5ULFxuICAgIGh0bWw6IFJlc291cmNlTG9hZGVyLlhIUl9SRVNQT05TRV9UWVBFLkRPQ1VNRU5ULFxuICAgIGh0bTogUmVzb3VyY2VMb2FkZXIuWEhSX1JFU1BPTlNFX1RZUEUuRE9DVU1FTlQsXG4gICAgeG1sOiBSZXNvdXJjZUxvYWRlci5YSFJfUkVTUE9OU0VfVFlQRS5ET0NVTUVOVCxcbiAgICB0bXg6IFJlc291cmNlTG9hZGVyLlhIUl9SRVNQT05TRV9UWVBFLkRPQ1VNRU5ULFxuICAgIHN2ZzogUmVzb3VyY2VMb2FkZXIuWEhSX1JFU1BPTlNFX1RZUEUuRE9DVU1FTlQsXG4gICAgdHN4OiBSZXNvdXJjZUxvYWRlci5YSFJfUkVTUE9OU0VfVFlQRS5ET0NVTUVOVCxcbiAgICBnaWY6IFJlc291cmNlTG9hZGVyLlhIUl9SRVNQT05TRV9UWVBFLkJMT0IsXG4gICAgcG5nOiBSZXNvdXJjZUxvYWRlci5YSFJfUkVTUE9OU0VfVFlQRS5CTE9CLFxuICAgIGJtcDogUmVzb3VyY2VMb2FkZXIuWEhSX1JFU1BPTlNFX1RZUEUuQkxPQixcbiAgICBqcGc6IFJlc291cmNlTG9hZGVyLlhIUl9SRVNQT05TRV9UWVBFLkJMT0IsXG4gICAganBlZzogUmVzb3VyY2VMb2FkZXIuWEhSX1JFU1BPTlNFX1RZUEUuQkxPQixcbiAgICB0aWY6IFJlc291cmNlTG9hZGVyLlhIUl9SRVNQT05TRV9UWVBFLkJMT0IsXG4gICAgdGlmZjogUmVzb3VyY2VMb2FkZXIuWEhSX1JFU1BPTlNFX1RZUEUuQkxPQixcbiAgICB3ZWJwOiBSZXNvdXJjZUxvYWRlci5YSFJfUkVTUE9OU0VfVFlQRS5CTE9CLFxuICAgIHRnYTogUmVzb3VyY2VMb2FkZXIuWEhSX1JFU1BPTlNFX1RZUEUuQkxPQixcbiAgICBqc29uOiBSZXNvdXJjZUxvYWRlci5YSFJfUkVTUE9OU0VfVFlQRS5KU09OLFxuICAgIHRleHQ6IFJlc291cmNlTG9hZGVyLlhIUl9SRVNQT05TRV9UWVBFLlRFWFQsXG4gICAgdHh0OiBSZXNvdXJjZUxvYWRlci5YSFJfUkVTUE9OU0VfVFlQRS5URVhULFxuICAgIHR0ZjogUmVzb3VyY2VMb2FkZXIuWEhSX1JFU1BPTlNFX1RZUEUuQlVGRkVSLFxuICAgIG90ZjogUmVzb3VyY2VMb2FkZXIuWEhSX1JFU1BPTlNFX1RZUEUuQlVGRkVSXG59O1xuUmVzb3VyY2VMb2FkZXIuX2xvYWRUeXBlTWFwID0ge1xuICAgIGdpZjogUmVzb3VyY2VMb2FkZXIuTE9BRF9UWVBFLklNQUdFLFxuICAgIHBuZzogUmVzb3VyY2VMb2FkZXIuTE9BRF9UWVBFLklNQUdFLFxuICAgIGJtcDogUmVzb3VyY2VMb2FkZXIuTE9BRF9UWVBFLklNQUdFLFxuICAgIGpwZzogUmVzb3VyY2VMb2FkZXIuTE9BRF9UWVBFLklNQUdFLFxuICAgIGpwZWc6IFJlc291cmNlTG9hZGVyLkxPQURfVFlQRS5JTUFHRSxcbiAgICB0aWY6IFJlc291cmNlTG9hZGVyLkxPQURfVFlQRS5JTUFHRSxcbiAgICB0aWZmOiBSZXNvdXJjZUxvYWRlci5MT0FEX1RZUEUuSU1BR0UsXG4gICAgd2VicDogUmVzb3VyY2VMb2FkZXIuTE9BRF9UWVBFLklNQUdFLFxuICAgIHRnYTogUmVzb3VyY2VMb2FkZXIuTE9BRF9UWVBFLklNQUdFLFxuICAgIHN2ZzogUmVzb3VyY2VMb2FkZXIuTE9BRF9UWVBFLklNQUdFLFxuICAgICdzdmcreG1sJzogUmVzb3VyY2VMb2FkZXIuTE9BRF9UWVBFLklNQUdFLFxuICAgIG1wMzogUmVzb3VyY2VMb2FkZXIuTE9BRF9UWVBFLkFVRElPLFxuICAgIG9nZzogUmVzb3VyY2VMb2FkZXIuTE9BRF9UWVBFLkFVRElPLFxuICAgIHdhdjogUmVzb3VyY2VMb2FkZXIuTE9BRF9UWVBFLkFVRElPLFxuICAgIG1wNDogUmVzb3VyY2VMb2FkZXIuTE9BRF9UWVBFLlZJREVPLFxuICAgIHdlYm06IFJlc291cmNlTG9hZGVyLkxPQURfVFlQRS5WSURFT1xufTtcblJlc291cmNlTG9hZGVyLlRZUEUgPSB7XG4gICAgVU5LTk9XTjogMCxcbiAgICBKU09OOiAxLFxuICAgIFhNTDogMixcbiAgICBJTUFHRTogMyxcbiAgICBBVURJTzogNCxcbiAgICBWSURFTzogNSxcbiAgICBURVhUOiA2XG59O1xuUmVzb3VyY2VMb2FkZXIuU1RBVFVTX0ZMQUdTID0ge1xuICAgIE5PTkU6IDAsXG4gICAgREFUQV9VUkw6IDEgPDwgMCxcbiAgICBDT01QTEVURTogMSA8PCAxLFxuICAgIExPQURJTkc6IDEgPDwgMlxufTtcbmV4cG9ydHMuUmVzb3VyY2VMb2FkZXIgPSBSZXNvdXJjZUxvYWRlcjtcbmNsYXNzIFVSSURhdGEge1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBJbWFnZVJlc291cmNlXzEgPSByZXF1aXJlKFwiLi9JbWFnZVJlc291cmNlXCIpO1xuY29uc3QgQ2FudmFzUmVzb3VyY2VfMSA9IHJlcXVpcmUoXCIuL0NhbnZhc1Jlc291cmNlXCIpO1xuY29uc3QgVmlkZW9SZXNvdXJjZV8xID0gcmVxdWlyZShcIi4vVmlkZW9SZXNvdXJjZVwiKTtcbmNvbnN0IFNWR1Jlc291cmNlXzEgPSByZXF1aXJlKFwiLi9TVkdSZXNvdXJjZVwiKTtcbmNvbnN0IEJ1ZmZlclJlc291cmNlXzEgPSByZXF1aXJlKFwiLi9CdWZmZXJSZXNvdXJjZVwiKTtcbmNvbnN0IEN1YmVSZXNvdXJjZV8xID0gcmVxdWlyZShcIi4vQ3ViZVJlc291cmNlXCIpO1xuY29uc3QgQXJyYXlSZXNvdXJjZV8xID0gcmVxdWlyZShcIi4vQXJyYXlSZXNvdXJjZVwiKTtcbmNsYXNzIFJlc291cmNlU2V0dGluZ3Mge1xuICAgIHN0YXRpYyBhdXRvRGV0ZWN0UmVzb3VyY2Uoc291cmNlLCBvcHRpb25zKSB7XG4gICAgICAgIGlmICghc291cmNlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXh0ZW5zaW9uID0gJyc7XG4gICAgICAgIGlmICh0eXBlb2Ygc291cmNlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9ICgvXFwuKFxcd3szLDR9KSg/OiR8XFw/fCMpL2kpLmV4ZWMoc291cmNlKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICBleHRlbnNpb24gPSByZXN1bHRbMV0udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gUmVzb3VyY2VTZXR0aW5ncy5JTlNUQUxMRUQubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgICAgIHZhciBSZXNvdXJjZVBsdWdpbiA9IFJlc291cmNlU2V0dGluZ3MuSU5TVEFMTEVEW2ldO1xuICAgICAgICAgICAgaWYgKFJlc291cmNlUGx1Z2luLnRlc3QgJiYgUmVzb3VyY2VQbHVnaW4udGVzdChzb3VyY2UsIGV4dGVuc2lvbikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFJlc291cmNlUGx1Z2luKHNvdXJjZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBJbWFnZVJlc291cmNlXzEuSW1hZ2VSZXNvdXJjZShzb3VyY2UsIG9wdGlvbnMpO1xuICAgIH1cbn1cblJlc291cmNlU2V0dGluZ3MuSU5TVEFMTEVEID0gW1xuICAgIEltYWdlUmVzb3VyY2VfMS5JbWFnZVJlc291cmNlLFxuICAgIENhbnZhc1Jlc291cmNlXzEuQ2FudmFzUmVzb3VyY2UsXG4gICAgVmlkZW9SZXNvdXJjZV8xLlZpZGVvUmVzb3VyY2UsXG4gICAgU1ZHUmVzb3VyY2VfMS5TVkdSZXNvdXJjZSxcbiAgICBCdWZmZXJSZXNvdXJjZV8xLkJ1ZmZlclJlc291cmNlLFxuICAgIEN1YmVSZXNvdXJjZV8xLkN1YmVSZXNvdXJjZSxcbiAgICBBcnJheVJlc291cmNlXzEuQXJyYXlSZXNvdXJjZVxuXTtcbmV4cG9ydHMuUmVzb3VyY2VTZXR0aW5ncyA9IFJlc291cmNlU2V0dGluZ3M7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IE1lc2hHZW9tZXRyeV8xID0gcmVxdWlyZShcIi4vTWVzaEdlb21ldHJ5XCIpO1xuY2xhc3MgUm9wZUdlb21ldHJ5IGV4dGVuZHMgTWVzaEdlb21ldHJ5XzEuTWVzaEdlb21ldHJ5IHtcbiAgICBjb25zdHJ1Y3Rvcih3aWR0aCA9IDIwMCwgcG9pbnRzID0gbnVsbCkge1xuICAgICAgICBpZiAod2lkdGggPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgd2lkdGggPSAyMDA7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIobmV3IEZsb2F0MzJBcnJheShwb2ludHMubGVuZ3RoICogNCksIG5ldyBGbG9hdDMyQXJyYXkocG9pbnRzLmxlbmd0aCAqIDQpLCBuZXcgVWludDE2QXJyYXkoKHBvaW50cy5sZW5ndGggLSAxKSAqIDYpKTtcbiAgICAgICAgLyoqXG4gICAgICAgICogQW4gYXJyYXkgb2YgcG9pbnRzIHRoYXQgZGV0ZXJtaW5lIHRoZSByb3BlXG4gICAgICAgICogQG1lbWJlciB7UElYSS5Qb2ludFtdfVxuICAgICAgICAqL1xuICAgICAgICB0aGlzLnBvaW50cyA9IHBvaW50cztcbiAgICAgICAgLyoqXG4gICAgICAgICogVGhlIHdpZHRoIChpLmUuLCB0aGlja25lc3MpIG9mIHRoZSByb3BlLlxuICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgKiBAcmVhZE9ubHlcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgICAgICB0aGlzLmJ1aWxkKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICogUmVmcmVzaGVzIFJvcGUgaW5kaWNlcyBhbmQgdXZzXG4gICAgKiBAcHJpdmF0ZVxuICAgICovXG4gICAgYnVpbGQoKSB7XG4gICAgICAgIHZhciBwb2ludHMgPSB0aGlzLnBvaW50cztcbiAgICAgICAgaWYgKCFwb2ludHMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdmVydGV4QnVmZmVyID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2FWZXJ0ZXhQb3NpdGlvbicpO1xuICAgICAgICB2YXIgdXZCdWZmZXIgPSB0aGlzLmdldEF0dHJpYnV0ZSgnYVRleHR1cmVDb29yZCcpO1xuICAgICAgICB2YXIgaW5kZXhCdWZmZXIgPSB0aGlzLmdldEluZGV4KCk7XG4gICAgICAgIC8vIGlmIHRvbyBsaXR0bGUgcG9pbnRzLCBvciB0ZXh0dXJlIGhhc24ndCBnb3QgVVZzIHNldCB5ZXQganVzdCBtb3ZlIG9uLlxuICAgICAgICBpZiAocG9pbnRzLmxlbmd0aCA8IDEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiB0aGUgbnVtYmVyIG9mIHBvaW50cyBoYXMgY2hhbmdlZCB3ZSB3aWxsIG5lZWQgdG8gcmVjcmVhdGUgdGhlIGFycmF5YnVmZmVyc1xuICAgICAgICBpZiAodmVydGV4QnVmZmVyLmRhdGEubGVuZ3RoIC8gNCAhPT0gcG9pbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgdmVydGV4QnVmZmVyLmRhdGEgPSBuZXcgRmxvYXQzMkFycmF5KHBvaW50cy5sZW5ndGggKiA0KTtcbiAgICAgICAgICAgIHV2QnVmZmVyLmRhdGEgPSBuZXcgRmxvYXQzMkFycmF5KHBvaW50cy5sZW5ndGggKiA0KTtcbiAgICAgICAgICAgIGluZGV4QnVmZmVyLmRhdGEgPSBuZXcgVWludDE2QXJyYXkoKHBvaW50cy5sZW5ndGggLSAxKSAqIDYpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB1dnMgPSB1dkJ1ZmZlci5kYXRhO1xuICAgICAgICB2YXIgaW5kaWNlcyA9IGluZGV4QnVmZmVyLmRhdGE7XG4gICAgICAgIHV2c1swXSA9IDA7XG4gICAgICAgIHV2c1sxXSA9IDA7XG4gICAgICAgIHV2c1syXSA9IDA7XG4gICAgICAgIHV2c1szXSA9IDE7XG4gICAgICAgIC8vIGluZGljZXNbMF0gPSAwO1xuICAgICAgICAvLyBpbmRpY2VzWzFdID0gMTtcbiAgICAgICAgdmFyIHRvdGFsID0gcG9pbnRzLmxlbmd0aDsgLy8gLSAxO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRvdGFsOyBpKyspIHtcbiAgICAgICAgICAgIC8vIHRpbWUgdG8gZG8gc29tZSBzbWFydCBkcmF3aW5nIVxuICAgICAgICAgICAgdmFyIGluZGV4ID0gaSAqIDQ7XG4gICAgICAgICAgICB2YXIgYW1vdW50ID0gaSAvICh0b3RhbCAtIDEpO1xuICAgICAgICAgICAgdXZzW2luZGV4XSA9IGFtb3VudDtcbiAgICAgICAgICAgIHV2c1tpbmRleCArIDFdID0gMDtcbiAgICAgICAgICAgIHV2c1tpbmRleCArIDJdID0gYW1vdW50O1xuICAgICAgICAgICAgdXZzW2luZGV4ICsgM10gPSAxO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpbmRleENvdW50ID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgdG90YWwgLSAxOyBpJDErKykge1xuICAgICAgICAgICAgdmFyIGluZGV4JDEgPSBpJDEgKiAyO1xuICAgICAgICAgICAgaW5kaWNlc1tpbmRleENvdW50KytdID0gaW5kZXgkMTtcbiAgICAgICAgICAgIGluZGljZXNbaW5kZXhDb3VudCsrXSA9IGluZGV4JDEgKyAxO1xuICAgICAgICAgICAgaW5kaWNlc1tpbmRleENvdW50KytdID0gaW5kZXgkMSArIDI7XG4gICAgICAgICAgICBpbmRpY2VzW2luZGV4Q291bnQrK10gPSBpbmRleCQxICsgMjtcbiAgICAgICAgICAgIGluZGljZXNbaW5kZXhDb3VudCsrXSA9IGluZGV4JDEgKyAxO1xuICAgICAgICAgICAgaW5kaWNlc1tpbmRleENvdW50KytdID0gaW5kZXgkMSArIDM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZW5zdXJlIHRoYXQgdGhlIGNoYW5nZXMgYXJlIHVwbG9hZGVkXG4gICAgICAgIHV2QnVmZmVyLnVwZGF0ZSgpO1xuICAgICAgICBpbmRleEJ1ZmZlci51cGRhdGUoKTtcbiAgICAgICAgdGhpcy51cGRhdGVWZXJ0aWNlcygpO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgKiByZWZyZXNoZXMgdmVydGljZXMgb2YgUm9wZSBtZXNoXG4gICAgKi9cbiAgICB1cGRhdGVWZXJ0aWNlcygpIHtcbiAgICAgICAgdmFyIHBvaW50cyA9IHRoaXMucG9pbnRzO1xuICAgICAgICBpZiAocG9pbnRzLmxlbmd0aCA8IDEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGFzdFBvaW50ID0gcG9pbnRzWzBdO1xuICAgICAgICB2YXIgbmV4dFBvaW50O1xuICAgICAgICB2YXIgcGVycFggPSAwO1xuICAgICAgICB2YXIgcGVycFkgPSAwO1xuICAgICAgICAvLyB0aGlzLmNvdW50IC09IDAuMjtcbiAgICAgICAgdmFyIHZlcnRpY2VzID0gdGhpcy5idWZmZXJzWzBdLmRhdGE7XG4gICAgICAgIHZhciB0b3RhbCA9IHBvaW50cy5sZW5ndGg7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG90YWw7IGkrKykge1xuICAgICAgICAgICAgdmFyIHBvaW50ID0gcG9pbnRzW2ldO1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gaSAqIDQ7XG4gICAgICAgICAgICBpZiAoaSA8IHBvaW50cy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgbmV4dFBvaW50ID0gcG9pbnRzW2kgKyAxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG5leHRQb2ludCA9IHBvaW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGVycFkgPSAtKG5leHRQb2ludC54IC0gbGFzdFBvaW50LngpO1xuICAgICAgICAgICAgcGVycFggPSBuZXh0UG9pbnQueSAtIGxhc3RQb2ludC55O1xuICAgICAgICAgICAgdmFyIHBlcnBMZW5ndGggPSBNYXRoLnNxcnQoKHBlcnBYICogcGVycFgpICsgKHBlcnBZICogcGVycFkpKTtcbiAgICAgICAgICAgIHZhciBudW0gPSB0aGlzLndpZHRoIC8gMjsgLy8gKDIwICsgTWF0aC5hYnMoTWF0aC5zaW4oKGkgKyB0aGlzLmNvdW50KSAqIDAuMykgKiA1MCkgKSogcmF0aW87XG4gICAgICAgICAgICBwZXJwWCAvPSBwZXJwTGVuZ3RoO1xuICAgICAgICAgICAgcGVycFkgLz0gcGVycExlbmd0aDtcbiAgICAgICAgICAgIHBlcnBYICo9IG51bTtcbiAgICAgICAgICAgIHBlcnBZICo9IG51bTtcbiAgICAgICAgICAgIHZlcnRpY2VzW2luZGV4XSA9IHBvaW50LnggKyBwZXJwWDtcbiAgICAgICAgICAgIHZlcnRpY2VzW2luZGV4ICsgMV0gPSBwb2ludC55ICsgcGVycFk7XG4gICAgICAgICAgICB2ZXJ0aWNlc1tpbmRleCArIDJdID0gcG9pbnQueCAtIHBlcnBYO1xuICAgICAgICAgICAgdmVydGljZXNbaW5kZXggKyAzXSA9IHBvaW50LnkgLSBwZXJwWTtcbiAgICAgICAgICAgIGxhc3RQb2ludCA9IHBvaW50O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYnVmZmVyc1swXS51cGRhdGUoKTtcbiAgICB9XG4gICAgO1xuICAgIHVwZGF0ZSgpIHtcbiAgICAgICAgdGhpcy51cGRhdGVWZXJ0aWNlcygpO1xuICAgIH1cbiAgICA7XG59XG5leHBvcnRzLlJvcGVHZW9tZXRyeSA9IFJvcGVHZW9tZXRyeTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgU2hhcGVTZXR0aW5nc18xID0gcmVxdWlyZShcIi4vU2hhcGVTZXR0aW5nc1wiKTtcbmNsYXNzIFJvdW5kZWRSZWN0YW5nbGUge1xuICAgIGNvbnN0cnVjdG9yKHggPSAwLCB5ID0gMCwgd2lkdGggPSAwLCBoZWlnaHQgPSAwLCByYWRpdXMgPSAyMCkge1xuICAgICAgICBpZiAoeCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICB4ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoeSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICB5ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAod2lkdGggPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgd2lkdGggPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoZWlnaHQgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgaGVpZ2h0ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmFkaXVzID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHJhZGl1cyA9IDIwO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMueCA9IHg7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMueSA9IHk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgMFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDIwXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJhZGl1cyA9IHJhZGl1cztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0eXBlIG9mIHRoZSBvYmplY3QsIG1haW5seSB1c2VkIHRvIGF2b2lkIGBpbnN0YW5jZW9mYCBjaGVja3NcbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKiBAcmVhZG9ubHlcbiAgICAgICAgICogQGRlZmF1bHQgUElYSS5TSEFQRVMuUlJFQ1xuICAgICAgICAgKiBAc2VlIFBJWEkuU0hBUEVTXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnR5cGUgPSBTaGFwZVNldHRpbmdzXzEuU2hhcGVTZXR0aW5ncy5TSEFQRVMuUlJFQztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNsb25lIG9mIHRoaXMgUm91bmRlZCBSZWN0YW5nbGVcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1BJWEkuUm91bmRlZFJlY3RhbmdsZX0gYSBjb3B5IG9mIHRoZSByb3VuZGVkIHJlY3RhbmdsZVxuICAgICAqL1xuICAgIGNsb25lKCkge1xuICAgICAgICByZXR1cm4gbmV3IFJvdW5kZWRSZWN0YW5nbGUodGhpcy54LCB0aGlzLnksIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCB0aGlzLnJhZGl1cyk7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgeCBhbmQgeSBjb29yZGluYXRlcyBnaXZlbiBhcmUgY29udGFpbmVkIHdpdGhpbiB0aGlzIFJvdW5kZWQgUmVjdGFuZ2xlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCAtIFRoZSBYIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50IHRvIHRlc3RcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSAtIFRoZSBZIGNvb3JkaW5hdGUgb2YgdGhlIHBvaW50IHRvIHRlc3RcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSB4L3kgY29vcmRpbmF0ZXMgYXJlIHdpdGhpbiB0aGlzIFJvdW5kZWQgUmVjdGFuZ2xlXG4gICAgICovXG4gICAgY29udGFpbnMoeCwgeSkge1xuICAgICAgICBpZiAodGhpcy53aWR0aCA8PSAwIHx8IHRoaXMuaGVpZ2h0IDw9IDApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoeCA+PSB0aGlzLnggJiYgeCA8PSB0aGlzLnggKyB0aGlzLndpZHRoKSB7XG4gICAgICAgICAgICBpZiAoeSA+PSB0aGlzLnkgJiYgeSA8PSB0aGlzLnkgKyB0aGlzLmhlaWdodCkge1xuICAgICAgICAgICAgICAgIGlmICgoeSA+PSB0aGlzLnkgKyB0aGlzLnJhZGl1cyAmJiB5IDw9IHRoaXMueSArIHRoaXMuaGVpZ2h0IC0gdGhpcy5yYWRpdXMpXG4gICAgICAgICAgICAgICAgICAgIHx8ICh4ID49IHRoaXMueCArIHRoaXMucmFkaXVzICYmIHggPD0gdGhpcy54ICsgdGhpcy53aWR0aCAtIHRoaXMucmFkaXVzKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGR4ID0geCAtICh0aGlzLnggKyB0aGlzLnJhZGl1cyk7XG4gICAgICAgICAgICAgICAgdmFyIGR5ID0geSAtICh0aGlzLnkgKyB0aGlzLnJhZGl1cyk7XG4gICAgICAgICAgICAgICAgdmFyIHJhZGl1czIgPSB0aGlzLnJhZGl1cyAqIHRoaXMucmFkaXVzO1xuICAgICAgICAgICAgICAgIGlmICgoZHggKiBkeCkgKyAoZHkgKiBkeSkgPD0gcmFkaXVzMikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZHggPSB4IC0gKHRoaXMueCArIHRoaXMud2lkdGggLSB0aGlzLnJhZGl1cyk7XG4gICAgICAgICAgICAgICAgaWYgKChkeCAqIGR4KSArIChkeSAqIGR5KSA8PSByYWRpdXMyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkeSA9IHkgLSAodGhpcy55ICsgdGhpcy5oZWlnaHQgLSB0aGlzLnJhZGl1cyk7XG4gICAgICAgICAgICAgICAgaWYgKChkeCAqIGR4KSArIChkeSAqIGR5KSA8PSByYWRpdXMyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkeCA9IHggLSAodGhpcy54ICsgdGhpcy5yYWRpdXMpO1xuICAgICAgICAgICAgICAgIGlmICgoZHggKiBkeCkgKyAoZHkgKiBkeSkgPD0gcmFkaXVzMikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICA7XG59XG5leHBvcnRzLlJvdW5kZWRSZWN0YW5nbGUgPSBSb3VuZGVkUmVjdGFuZ2xlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jbGFzcyBSdW5uZXIge1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIHByaW9yaXR5ID0gMCkge1xuICAgICAgICB0aGlzLml0ZW1zID0gW107XG4gICAgICAgIHRoaXMuX25hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLmRpc3BhdGNoID0gdGhpcy5lbWl0O1xuICAgICAgICB0aGlzLnJ1biA9IHRoaXMuZW1pdDtcbiAgICB9XG4gICAgZW1pdChhMCwgYTEsIGEyLCBhMywgYTQsIGE1LCBhNiwgYTcpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiA4KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21heCBhcmd1bWVudHMgcmVhY2hlZCcpO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZWYgPSB0aGlzO1xuICAgICAgICB2YXIgbmFtZSA9IHJlZi5uYW1lO1xuICAgICAgICB2YXIgaXRlbXMgPSByZWYuaXRlbXM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBpdGVtcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgaXRlbXNbaV1bbmFtZV0oYTAsIGExLCBhMiwgYTMsIGE0LCBhNSwgYTYsIGE3KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIEFkZCBhIGxpc3RlbmVyIHRvIHRoZSBSdW5uZXJcbiAgICAgKlxuICAgICAqIFJ1bm5lcnMgZG8gbm90IG5lZWQgdG8gaGF2ZSBzY29wZSBvciBmdW5jdGlvbnMgcGFzc2VkIHRvIHRoZW0uXG4gICAgICogQWxsIHRoYXQgaXMgcmVxdWlyZWQgaXMgdG8gcGFzcyB0aGUgbGlzdGVuaW5nIG9iamVjdCBhbmQgZW5zdXJlIHRoYXQgaXQgaGFzIGNvbnRhaW5zIGEgZnVuY3Rpb24gdGhhdCBoYXMgdGhlIHNhbWUgbmFtZVxuICAgICAqIGFzIHRoZSBuYW1lIHByb3ZpZGVkIHRvIHRoZSBSdW5uZXIgd2hlbiBpdCB3YXMgY3JlYXRlZC5cbiAgICAgKlxuICAgICAqIEVnIEEgbGlzdGVuZXIgcGFzc2VkIHRvIHRoaXMgUnVubmVyIHdpbGwgcmVxdWlyZSBhICdjb21wbGV0ZScgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiBjb25zdCBjb21wbGV0ZSA9IG5ldyBQSVhJLlJ1bm5lcignY29tcGxldGUnKTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIFRoZSBzY29wZSB1c2VkIHdpbGwgYmUgdGhlIG9iamVjdCBpdHNlbGYuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2FueX0gaXRlbSAtIFRoZSBvYmplY3QgdGhhdCB3aWxsIGJlIGxpc3RlbmluZy5cbiAgICAgKi9cbiAgICBhZGQoaXRlbSkge1xuICAgICAgICBpZiAoaXRlbVt0aGlzLl9uYW1lXSkge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmUoaXRlbSk7XG4gICAgICAgICAgICB0aGlzLml0ZW1zLnB1c2goaXRlbSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYSBzaW5nbGUgbGlzdGVuZXIgZnJvbSB0aGUgZGlzcGF0Y2ggcXVldWUuXG4gICAgICogQHBhcmFtIHthbnl9IGl0ZW0gLSBUaGUgbGlzdGVuciB0aGF0IHlvdSB3b3VsZCBsaWtlIHRvIHJlbW92ZS5cbiAgICAgKi9cbiAgICByZW1vdmUoaXRlbSkge1xuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLml0ZW1zLmluZGV4T2YoaXRlbSk7XG4gICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuaXRlbXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIENoZWNrIHRvIHNlZSBpZiB0aGUgbGlzdGVuZXIgaXMgYWxyZWFkeSBpbiB0aGUgUnVubmVyXG4gICAgICogQHBhcmFtIHthbnl9IGl0ZW0gLSBUaGUgbGlzdGVuZXIgdGhhdCB5b3Ugd291bGQgbGlrZSB0byBjaGVjay5cbiAgICAgKi9cbiAgICBjb250YWlucyhpdGVtKSB7XG4gICAgICAgIHJldHVybiB0aGlzLml0ZW1zLmluZGV4T2YoaXRlbSkgIT09IC0xO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGFsbCBsaXN0ZW5lcnMgZnJvbSB0aGUgUnVubmVyXG4gICAgICovXG4gICAgcmVtb3ZlQWxsKCkge1xuICAgICAgICB0aGlzLml0ZW1zLmxlbmd0aCA9IDA7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGFsbCByZWZlcmVuY2VzLCBkb24ndCB1c2UgYWZ0ZXIgdGhpcy5cbiAgICAgKi9cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLnJlbW92ZUFsbCgpO1xuICAgICAgICB0aGlzLml0ZW1zID0gbnVsbDtcbiAgICAgICAgdGhpcy5fbmFtZSA9IG51bGw7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBgdHJ1ZWAgaWYgdGhlcmUgYXJlIG5vIHRoaXMgUnVubmVyIGNvbnRhaW5zIG5vIGxpc3RlbmVyc1xuICAgICAqXG4gICAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKi9cbiAgICBnZXQgZW1wdHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLml0ZW1zLmxlbmd0aCA9PT0gMDtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFRoZSBuYW1lIG9mIHRoZSBydW5uZXIuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtzdHJpbmd9XG4gICAgICogQHJlYWRvbmx5XG4gICAgICovXG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9uYW1lO1xuICAgIH1cbiAgICA7XG59XG5leHBvcnRzLlJ1bm5lciA9IFJ1bm5lcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgQmFzZUltYWdlUmVzb3VyY2VfMSA9IHJlcXVpcmUoXCIuL0Jhc2VJbWFnZVJlc291cmNlXCIpO1xuY29uc3Qgc2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL3NldHRpbmdzXCIpO1xuY29uc3QgTWF0aFNldHRpbmdzXzEgPSByZXF1aXJlKFwiLi9NYXRoU2V0dGluZ3NcIik7XG5jbGFzcyBTVkdSZXNvdXJjZSBleHRlbmRzIEJhc2VJbWFnZVJlc291cmNlXzEuQmFzZUltYWdlUmVzb3VyY2Uge1xuICAgIGNvbnN0cnVjdG9yKHNvdXJjZSwgb3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgc3VwZXIoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJykpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQmFzZTY0IGVuY29kZWQgU1ZHIGVsZW1lbnQgb3IgVVJMIGZvciBTVkcgZmlsZVxuICAgICAgICAgKiBAcmVhZG9ubHlcbiAgICAgICAgICogQG1lbWJlciB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdmcgPSBzb3VyY2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgc291cmNlIHNjYWxlIHRvIGFwcGx5IHRvIHJlbmRlclxuICAgICAgICAgKiBAcmVhZG9ubHlcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zY2FsZSA9IG9wdGlvbnMuc2NhbGUgfHwgMTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbGwgd2hlbiBjb21wbGV0ZWx5IGxvYWRlZFxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAbWVtYmVyIHtmdW5jdGlvbn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3Jlc29sdmUgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogUHJvbWlzZSB3aGVuIGxvYWRpbmdcbiAgICAgICAgICogQG1lbWJlciB7UHJvbWlzZTx2b2lkPn1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fbG9hZCA9IG51bGw7XG4gICAgICAgIGlmIChvcHRpb25zLmF1dG9Mb2FkICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgdGhpcy5sb2FkKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbG9hZCgpIHtcbiAgICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLl9sb2FkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbG9hZDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9sb2FkID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICAgIC8vIFNhdmUgdGhpcyB1bnRpbCBhZnRlciBsb2FkIGlzIGZpbmlzaGVkXG4gICAgICAgICAgICB0aGlzJDEuX3Jlc29sdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdGhpcyQxLnJlc2l6ZSh0aGlzJDEuc291cmNlLndpZHRoLCB0aGlzJDEuc291cmNlLmhlaWdodCk7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSh0aGlzJDEpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIENvbnZlcnQgU1ZHIGlubGluZSBzdHJpbmcgdG8gZGF0YS11cmlcbiAgICAgICAgICAgIGlmICgoL15cXDxzdmcvKS50ZXN0KHRoaXMkMS5zdmcudHJpbSgpKSkge1xuICAgICAgICAgICAgICAgIHRoaXMkMS5zdmcgPSBcImRhdGE6aW1hZ2Uvc3ZnK3htbDt1dGY4LFwiICsgKHRoaXMkMS5zdmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ2hlY2tzIGlmIGBzb3VyY2VgIGlzIGFuIFNWRyBpbWFnZSBhbmQgd2hldGhlciBpdCdzXG4gICAgICAgICAgICAvLyBsb2FkZWQgdmlhIGEgVVJMIG9yIGEgZGF0YSBVUkkuIFRoZW4gY2FsbHNcbiAgICAgICAgICAgIC8vIGBfbG9hZERhdGFVcmlgIG9yIGBfbG9hZFhocmAuXG4gICAgICAgICAgICB2YXIgZGF0YVVyaSA9IHNldHRpbmdzXzEuc2V0dGluZ3MuZGVjb21wb3NlRGF0YVVyaSh0aGlzJDEuc3ZnKTtcbiAgICAgICAgICAgIGlmIChkYXRhVXJpKSB7XG4gICAgICAgICAgICAgICAgdGhpcyQxLl9sb2FkRGF0YVVyaShkYXRhVXJpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFdlIGdvdCBhbiBVUkwsIHNvIHdlIG5lZWQgdG8gZG8gYW4gWEhSIHRvIGNoZWNrIHRoZSBzdmcgc2l6ZVxuICAgICAgICAgICAgICAgIHRoaXMkMS5fbG9hZFhocigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvYWQ7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBSZWFkcyBhbiBTVkcgc3RyaW5nIGZyb20gZGF0YSBVUkkgYW5kIHRoZW4gY2FsbHMgYF9sb2FkU3RyaW5nYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhVXJpIC0gVGhlIGRhdGEgdXJpIHRvIGxvYWQgZnJvbS5cbiAgICAgKi9cbiAgICBfbG9hZERhdGFVcmkoZGF0YVVyaSkge1xuICAgICAgICB2YXIgc3ZnU3RyaW5nO1xuICAgICAgICBpZiAoZGF0YVVyaS5lbmNvZGluZyA9PT0gJ2Jhc2U2NCcpIHtcbiAgICAgICAgICAgIGlmICghYXRvYikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignWW91ciBicm93c2VyIGRvZXNuXFwndCBzdXBwb3J0IGJhc2U2NCBjb252ZXJzaW9ucy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN2Z1N0cmluZyA9IGF0b2IoZGF0YVVyaS5kYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN2Z1N0cmluZyA9IGRhdGFVcmkuZGF0YTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9sb2FkU3RyaW5nKHN2Z1N0cmluZyk7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBMb2FkcyBhbiBTVkcgc3RyaW5nIGZyb20gYGltYWdlVXJsYCB1c2luZyBYSFIgYW5kIHRoZW4gY2FsbHMgYF9sb2FkU3RyaW5nYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2xvYWRYaHIoKSB7XG4gICAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuICAgICAgICB2YXIgc3ZnWGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgIC8vIFRoaXMgdGhyb3dzIGVycm9yIG9uIElFLCBzbyBTVkcgRG9jdW1lbnQgY2FuJ3QgYmUgdXNlZFxuICAgICAgICAvLyBzdmdYaHIucmVzcG9uc2VUeXBlID0gJ2RvY3VtZW50JztcbiAgICAgICAgLy8gVGhpcyBpcyBub3QgbmVlZGVkIHNpbmNlIHdlIGxvYWQgdGhlIHN2ZyBhcyBzdHJpbmcgKGJyZWFrcyBJRSB0b28pXG4gICAgICAgIC8vIGJ1dCBvdmVycmlkZU1pbWVUeXBlKCkgY2FuIGJlIHVzZWQgdG8gZm9yY2UgdGhlIHJlc3BvbnNlIHRvIGJlIHBhcnNlZCBhcyBYTUxcbiAgICAgICAgLy8gc3ZnWGhyLm92ZXJyaWRlTWltZVR5cGUoJ2ltYWdlL3N2Zyt4bWwnKTtcbiAgICAgICAgc3ZnWGhyLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChzdmdYaHIucmVhZHlTdGF0ZSAhPT0gc3ZnWGhyLkRPTkUgfHwgc3ZnWGhyLnN0YXR1cyAhPT0gMjAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gbG9hZCBTVkcgdXNpbmcgWEhSLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcyQxLl9sb2FkU3RyaW5nKHN2Z1hoci5yZXNwb25zZSk7XG4gICAgICAgIH07XG4gICAgICAgIC8vIHN2Z1hoci5vbmVycm9yID0gKCkgPT4gdGhpcy5lbWl0KCdlcnJvcicsIHRoaXMpO1xuICAgICAgICBzdmdYaHIub3BlbignR0VUJywgdGhpcy5zdmcsIHRydWUpO1xuICAgICAgICBzdmdYaHIuc2VuZCgpO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogTG9hZHMgdGV4dHVyZSB1c2luZyBhbiBTVkcgc3RyaW5nLiBUaGUgb3JpZ2luYWwgU1ZHIEltYWdlIGlzIHN0b3JlZCBhcyBgb3JpZ1NvdXJjZWAgYW5kIHRoZVxuICAgICAqIGNyZWF0ZWQgY2FudmFzIGlzIHRoZSBuZXcgYHNvdXJjZWAuIFRoZSBTVkcgaXMgc2NhbGVkIHVzaW5nIGBzb3VyY2VTY2FsZWAuIENhbGxlZCBieVxuICAgICAqIGBfbG9hZFhocmAgb3IgYF9sb2FkRGF0YVVyaWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSAge3N0cmluZ30gc3ZnU3RyaW5nIFNWRyBzb3VyY2UgYXMgc3RyaW5nXG4gICAgICpcbiAgICAgKiBAZmlyZXMgbG9hZGVkXG4gICAgICovXG4gICAgX2xvYWRTdHJpbmcoc3ZnU3RyaW5nKSB7XG4gICAgICAgIHZhciBzdmdTaXplID0gU1ZHUmVzb3VyY2UuZ2V0U2l6ZShzdmdTdHJpbmcpO1xuICAgICAgICAvLyBUT0RPIGRvIHdlIG5lZWQgdG8gd2FpdCBmb3IgdGhpcyB0byBsb2FkP1xuICAgICAgICAvLyBzZWVtcyBpbnN0YW50IVxuICAgICAgICAvL1xuICAgICAgICB2YXIgdGVtcEltYWdlID0gbmV3IEltYWdlKCk7XG4gICAgICAgIHRlbXBJbWFnZS5zcmMgPSBcImRhdGE6aW1hZ2Uvc3ZnK3htbCxcIiArIHN2Z1N0cmluZztcbiAgICAgICAgdmFyIHN2Z1dpZHRoID0gc3ZnU2l6ZS53aWR0aDtcbiAgICAgICAgdmFyIHN2Z0hlaWdodCA9IHN2Z1NpemUuaGVpZ2h0O1xuICAgICAgICBpZiAoIXN2Z1dpZHRoIHx8ICFzdmdIZWlnaHQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIFNWRyBpbWFnZSBtdXN0IGhhdmUgd2lkdGggYW5kIGhlaWdodCBkZWZpbmVkIChpbiBwaXhlbHMpLCBjYW52YXMgQVBJIG5lZWRzIHRoZW0uJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2NhbGUgcmVhbFdpZHRoIGFuZCByZWFsSGVpZ2h0XG4gICAgICAgIHRoaXMuX3dpZHRoID0gTWF0aC5yb3VuZChzdmdXaWR0aCAqIHRoaXMuc2NhbGUpO1xuICAgICAgICB0aGlzLl9oZWlnaHQgPSBNYXRoLnJvdW5kKHN2Z0hlaWdodCAqIHRoaXMuc2NhbGUpO1xuICAgICAgICAvLyBDcmVhdGUgYSBjYW52YXMgZWxlbWVudFxuICAgICAgICB2YXIgY2FudmFzID0gdGhpcy5zb3VyY2U7XG4gICAgICAgIGNhbnZhcy53aWR0aCA9IHRoaXMuX3dpZHRoO1xuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gdGhpcy5faGVpZ2h0O1xuICAgICAgICBjYW52YXMuX3BpeGlJZCA9IFwiY2FudmFzX1wiICsgKE1hdGhTZXR0aW5nc18xLk1hdGhTZXR0aW5ncy51aWQoKSk7XG4gICAgICAgIC8vIERyYXcgdGhlIFN2ZyB0byB0aGUgY2FudmFzXG4gICAgICAgIGNhbnZhc1xuICAgICAgICAgICAgLmdldENvbnRleHQoJzJkJylcbiAgICAgICAgICAgIC5kcmF3SW1hZ2UodGVtcEltYWdlLCAwLCAwLCBzdmdXaWR0aCwgc3ZnSGVpZ2h0LCAwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgICAgIHRoaXMuX3Jlc29sdmUoKTtcbiAgICAgICAgdGhpcy5fcmVzb2x2ZSA9IG51bGw7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBUeXBlZGVmIGZvciBTaXplIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBQSVhJLnJlc291cmNlcy5TVkdSZXNvdXJjZVxuICAgICAqIEB0eXBlZGVmIHtvYmplY3R9IFNpemVcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gd2lkdGggLSBXaWR0aCBjb21wb25lbnRcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gaGVpZ2h0IC0gSGVpZ2h0IGNvbXBvbmVudFxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIEdldCBzaXplIGZyb20gYW4gc3ZnIHN0cmluZyB1c2luZyByZWdleHAuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN2Z1N0cmluZyAtIGEgc2VyaWFsaXplZCBzdmcgZWxlbWVudFxuICAgICAqIEByZXR1cm4ge1BJWEkucmVzb3VyY2VzLlNWR1Jlc291cmNlLlNpemV9IGltYWdlIGV4dGVuc2lvblxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRTaXplKHN2Z1N0cmluZykge1xuICAgICAgICB2YXIgc2l6ZU1hdGNoID0gU1ZHUmVzb3VyY2UuU1ZHX1NJWkUuZXhlYyhzdmdTdHJpbmcpO1xuICAgICAgICB2YXIgc2l6ZSA9IHt9O1xuICAgICAgICBpZiAoc2l6ZU1hdGNoKSB7XG4gICAgICAgICAgICBzaXplW3NpemVNYXRjaFsxXV0gPSBNYXRoLnJvdW5kKHBhcnNlRmxvYXQoc2l6ZU1hdGNoWzNdKSk7XG4gICAgICAgICAgICBzaXplW3NpemVNYXRjaFs1XV0gPSBNYXRoLnJvdW5kKHBhcnNlRmxvYXQoc2l6ZU1hdGNoWzddKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNpemU7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBEZXN0cm95cyB0aGlzIHRleHR1cmVcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICBkaXNwb3NlKCkge1xuICAgICAgICBCYXNlSW1hZ2VSZXNvdXJjZV8xLkJhc2VJbWFnZVJlc291cmNlLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuX3Jlc29sdmUgPSBudWxsO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogVXNlZCB0byBhdXRvLWRldGVjdCB0aGUgdHlwZSBvZiByZXNvdXJjZS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0geyp9IHNvdXJjZSAtIFRoZSBzb3VyY2Ugb2JqZWN0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV4dGVuc2lvbiAtIFRoZSBleHRlbnNpb24gb2Ygc291cmNlLCBpZiBzZXRcbiAgICAgKi9cbiAgICBzdGF0aWMgdGVzdChzb3VyY2UsIGV4dGVuc2lvbikge1xuICAgICAgICAvLyB1cmwgZmlsZSBleHRlbnNpb24gaXMgU1ZHXG4gICAgICAgIHJldHVybiBleHRlbnNpb24gPT09ICdzdmcnXG4gICAgICAgICAgICAvLyBzb3VyY2UgaXMgU1ZHIGRhdGEtdXJpXG4gICAgICAgICAgICB8fCAodHlwZW9mIHNvdXJjZSA9PT0gJ3N0cmluZycgJiYgc291cmNlLmluZGV4T2YoJ2RhdGE6aW1hZ2Uvc3ZnK3htbCcpID09PSAwKTtcbiAgICB9XG4gICAgO1xufVxuLyoqXG4qIFJlZ0V4cCBmb3IgU1ZHIHNpemUuXG4qXG4qIEBzdGF0aWNcbiogQGNvbnN0YW50IHtSZWdFeHB8c3RyaW5nfSBTVkdfU0laRVxuKiBAbWVtYmVyb2YgUElYSS5yZXNvdXJjZXMuU1ZHUmVzb3VyY2VcbiogQGV4YW1wbGUgJmx0O3N2ZyB3aWR0aD1cIjEwMFwiIGhlaWdodD1cIjEwMFwiJmd0OyZsdDsvc3ZnJmd0O1xuKi9cblNWR1Jlc291cmNlLlNWR19TSVpFID0gLzxzdmdbXj5dKig/Olxccyh3aWR0aHxoZWlnaHQpPSgnfFwiKShcXGQqKD86XFwuXFxkKyk/KSg/OnB4KT8oJ3xcIikpW14+XSooPzpcXHMod2lkdGh8aGVpZ2h0KT0oJ3xcIikoXFxkKig/OlxcLlxcZCspPykoPzpweCk/KCd8XCIpKVtePl0qPi9pOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG1heC1sZW5cbmV4cG9ydHMuU1ZHUmVzb3VyY2UgPSBTVkdSZXNvdXJjZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgVW5pZm9ybUdyb3VwXzEgPSByZXF1aXJlKFwiLi9Vbmlmb3JtR3JvdXBcIik7XG5jb25zdCBQcm9ncmFtXzEgPSByZXF1aXJlKFwiLi9Qcm9ncmFtXCIpO1xuY29uc3QgRmxhc2hCYXNlT2JqZWN0XzEgPSByZXF1aXJlKFwiLi9GbGFzaEJhc2VPYmplY3RcIik7XG5jbGFzcyBTaGFkZXIgZXh0ZW5kcyBGbGFzaEJhc2VPYmplY3RfMS5GbGFzaEJhc2VPYmplY3Qge1xuICAgIGNvbnN0cnVjdG9yKHByb2dyYW0sIHVuaWZvcm1zKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMucHJvZ3JhbSA9IHByb2dyYW07XG4gICAgICAgIC8vIGxldHMgc2VlIHdoYXRzIGJlZW4gcGFzc2VkIGluXG4gICAgICAgIC8vIHVuaWZvcm1zIHNob3VsZCBiZSBjb252ZXJ0ZWQgdG8gYSB1bmlmb3JtIGdyb3VwXG4gICAgICAgIGlmICh1bmlmb3Jtcykge1xuICAgICAgICAgICAgaWYgKHVuaWZvcm1zIGluc3RhbmNlb2YgVW5pZm9ybUdyb3VwXzEuVW5pZm9ybUdyb3VwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51bmlmb3JtR3JvdXAgPSB1bmlmb3JtcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMudW5pZm9ybUdyb3VwID0gbmV3IFVuaWZvcm1Hcm91cF8xLlVuaWZvcm1Hcm91cCh1bmlmb3Jtcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnVuaWZvcm1Hcm91cCA9IG5ldyBVbmlmb3JtR3JvdXBfMS5Vbmlmb3JtR3JvdXAoe30pO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRpbWUgdG8gYnVpbGQgc29tZSBnZXR0ZXJzIGFuZCBzZXR0ZXJzIVxuICAgICAgICAvLyBJIGd1ZXNzIGRvd24gdGhlIGxpbmUgdGhpcyBjb3VsZCBzb3J0IG9mIGdlbmVyYXRlIGFuIGluc3RydWN0aW9uIGxpc3QgcmF0aGVyIHRoYW4gdXNlIGRpcnR5IGlkcz9cbiAgICAgICAgLy8gZG9lcyB0aGUgdHJpY2sgZm9yIG5vdyB0aG91Z2ghXG4gICAgICAgIGZvciAodmFyIGkgaW4gcHJvZ3JhbS51bmlmb3JtRGF0YSkge1xuICAgICAgICAgICAgaWYgKHRoaXMudW5pZm9ybUdyb3VwLnVuaWZvcm1zW2ldIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVuaWZvcm1Hcm91cC51bmlmb3Jtc1tpXSA9IG5ldyBGbG9hdDMyQXJyYXkodGhpcy51bmlmb3JtR3JvdXAudW5pZm9ybXNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFRPRE8gbW92ZSB0byBzaGFkZXIgc3lzdGVtLi5cbiAgICBjaGVja1VuaWZvcm1FeGlzdHMobmFtZSwgZ3JvdXApIHtcbiAgICAgICAgaWYgKGdyb3VwLnVuaWZvcm1zW25hbWVdKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpIGluIGdyb3VwLnVuaWZvcm1zKSB7XG4gICAgICAgICAgICB2YXIgdW5pZm9ybSA9IGdyb3VwLnVuaWZvcm1zW2ldO1xuICAgICAgICAgICAgaWYgKHVuaWZvcm0uZ3JvdXApIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jaGVja1VuaWZvcm1FeGlzdHMobmFtZSwgdW5pZm9ybSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgO1xuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIC8vIHVzYWdlIGNvdW50IG9uIHByb2dyYW1zP1xuICAgICAgICAvLyByZW1vdmUgaWYgbm90IHVzZWQhXG4gICAgICAgIHRoaXMudW5pZm9ybUdyb3VwID0gbnVsbDtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFNoYWRlciB1bmlmb3JtIHZhbHVlcywgc2hvcnRjdXQgZm9yIGB1bmlmb3JtR3JvdXAudW5pZm9ybXNgXG4gICAgICogQHJlYWRvbmx5XG4gICAgICogQG1lbWJlciB7b2JqZWN0fVxuICAgICAqL1xuICAgIGdldCB1bmlmb3JtcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudW5pZm9ybUdyb3VwLnVuaWZvcm1zO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogQSBzaG9ydCBoYW5kIGZ1bmN0aW9uIHRvIGNyZWF0ZSBhIHNoYWRlciBiYXNlZCBvZiBhIHZlcnRleCBhbmQgZnJhZ21lbnQgc2hhZGVyXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3ZlcnRleFNyY10gLSBUaGUgc291cmNlIG9mIHRoZSB2ZXJ0ZXggc2hhZGVyLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbZnJhZ21lbnRTcmNdIC0gVGhlIHNvdXJjZSBvZiB0aGUgZnJhZ21lbnQgc2hhZGVyLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbdW5pZm9ybXNdIC0gQ3VzdG9tIHVuaWZvcm1zIHRvIHVzZSB0byBhdWdtZW50IHRoZSBidWlsdC1pbiBvbmVzLlxuICAgICAqXG4gICAgICogQHJldHVybnMge1BJWEkuU2hhZGVyfSBhbiBzaGlueSBuZXcgUGl4aSBzaGFkZXIhXG4gICAgICovXG4gICAgc3RhdGljIGZyb20odmVydGV4U3JjLCBmcmFnbWVudFNyYywgdW5pZm9ybXMpIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBQcm9ncmFtXzEuUHJvZ3JhbS5mcm9tKHZlcnRleFNyYywgZnJhZ21lbnRTcmMpO1xuICAgICAgICByZXR1cm4gbmV3IFNoYWRlcihwcm9ncmFtLCB1bmlmb3Jtcyk7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0gZ2wge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gVGhlIGN1cnJlbnQgV2ViR0wgY29udGV4dCB7V2ViR0xQcm9ncmFtfVxuICogQHBhcmFtIHR5cGUge051bWJlcn0gdGhlIHR5cGUsIGNhbiBiZSBlaXRoZXIgVkVSVEVYX1NIQURFUiBvciBGUkFHTUVOVF9TSEFERVJcbiAqIEBwYXJhbSB2ZXJ0ZXhTcmMge3N0cmluZ3xzdHJpbmdbXX0gVGhlIHZlcnRleCBzaGFkZXIgc291cmNlIGFzIGFuIGFycmF5IG9mIHN0cmluZ3MuXG4gKiBAcmV0dXJuIHtXZWJHTFNoYWRlcn0gdGhlIHNoYWRlclxuICovXG4gICAgc3RhdGljIGNvbXBpbGVTaGFkZXIoZ2wsIHR5cGUsIHNyYykge1xuICAgICAgICB2YXIgc2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKHR5cGUpO1xuICAgICAgICBnbC5zaGFkZXJTb3VyY2Uoc2hhZGVyLCBzcmMpO1xuICAgICAgICBnbC5jb21waWxlU2hhZGVyKHNoYWRlcik7XG4gICAgICAgIGlmICghZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKHNoYWRlciwgZ2wuQ09NUElMRV9TVEFUVVMpKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oc3JjKTtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZ2wuZ2V0U2hhZGVySW5mb0xvZyhzaGFkZXIpKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzaGFkZXI7XG4gICAgfVxufVxuZXhwb3J0cy5TaGFkZXIgPSBTaGFkZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IFN5c3RlbV8xID0gcmVxdWlyZShcIi4vU3lzdGVtXCIpO1xuY29uc3QgUHJvZ3JhbV8xID0gcmVxdWlyZShcIi4vUHJvZ3JhbVwiKTtcbmNvbnN0IEdMUHJvZ3JhbV8xID0gcmVxdWlyZShcIi4vR0xQcm9ncmFtXCIpO1xuY29uc3QgU3RhdGVTeXN0ZW1fMSA9IHJlcXVpcmUoXCIuL1N0YXRlU3lzdGVtXCIpO1xuY29uc3QgVXRpbHNTZXR0aW5nc18xID0gcmVxdWlyZShcIi4vVXRpbHNTZXR0aW5nc1wiKTtcbmNvbnN0IFdlYkdMU2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL1dlYkdMU2V0dGluZ3NcIik7XG5jbGFzcyBTaGFkZXJTeXN0ZW0gZXh0ZW5kcyBTeXN0ZW1fMS5TeXN0ZW0ge1xuICAgIGNvbnN0cnVjdG9yKHJlbmRlcmVyKSB7XG4gICAgICAgIHN1cGVyKHJlbmRlcmVyKTtcbiAgICAgICAgLy8gVmFsaWRhdGlvbiBjaGVjayB0aGF0IHRoaXMgZW52aXJvbm1lbnQgc3VwcG9ydCBgbmV3IEZ1bmN0aW9uYFxuICAgICAgICB0aGlzLnN5c3RlbUNoZWNrKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgY3VycmVudCBXZWJHTCByZW5kZXJpbmcgY29udGV4dFxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmdsID0gbnVsbDtcbiAgICAgICAgdGhpcy5zaGFkZXIgPSBudWxsO1xuICAgICAgICB0aGlzLnByb2dyYW0gPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2FjaGUgdG8gaG9sZHMgdGhlIGdlbmVyYXRlZCBmdW5jdGlvbnMuIFN0b3JlZCBhZ2FpbnN0IFVuaWZvcm1PYmplY3RzIHVuaXF1ZSBzaWduYXR1cmVcbiAgICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2FjaGUgPSB7fTtcbiAgICAgICAgdGhpcy5pZCA9IFN0YXRlU3lzdGVtXzEuU3RhdGVTeXN0ZW0uVUlEJDQrKztcbiAgICB9XG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGVhYmxlIGZ1bmN0aW9uIGJ5IGBAcGl4aS91bnNhZmUtZXZhbGAgdG8gc2lsZW5jZVxuICAgICAqIHRocm93aW5nIGFuIGVycm9yIGlmIHBsYXRmb3JtIGRvZXNuJ3Qgc3VwcG9ydCB1bnNhZmUtZXZhbHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHN5c3RlbUNoZWNrKCkge1xuICAgICAgICBpZiAoIVV0aWxzU2V0dGluZ3NfMS5VdGlsc1NldHRpbmdzLnVuc2FmZUV2YWxTdXBwb3J0ZWQoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDdXJyZW50IGVudmlyb25tZW50IGRvZXMgbm90IGFsbG93IHVuc2FmZS1ldmFsLCAnXG4gICAgICAgICAgICAgICAgKyAncGxlYXNlIHVzZSBAcGl4aS91bnNhZmUtZXZhbCBtb2R1bGUgdG8gZW5hYmxlIHN1cHBvcnQuJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xuICAgIGNvbnRleHRDaGFuZ2UoZ2wpIHtcbiAgICAgICAgdGhpcy5nbCA9IGdsO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogQ2hhbmdlcyB0aGUgY3VycmVudCBzaGFkZXIgdG8gdGhlIG9uZSBnaXZlbiBpbiBwYXJhbWV0ZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UElYSS5TaGFkZXJ9IHNoYWRlciAtIHRoZSBuZXcgc2hhZGVyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBkb250U3luYyAtIGZhbHNlIGlmIHRoZSBzaGFkZXIgc2hvdWxkIGF1dG9tYXRpY2FsbHkgc3luYyBpdHMgdW5pZm9ybXMuXG4gICAgICogQHJldHVybnMge1BJWEkuR0xQcm9ncmFtfSB0aGUgZ2xQcm9ncmFtIHRoYXQgYmVsb25ncyB0byB0aGUgc2hhZGVyLlxuICAgICAqL1xuICAgIGJpbmQoc2hhZGVyLCBkb250U3luYyA9IGZhbHNlKSB7XG4gICAgICAgIHNoYWRlci51bmlmb3Jtcy5nbG9iYWxzID0gdGhpcy5yZW5kZXJlci5nbG9iYWxVbmlmb3JtcztcbiAgICAgICAgdmFyIHByb2dyYW0gPSBzaGFkZXIucHJvZ3JhbTtcbiAgICAgICAgdmFyIGdsUHJvZ3JhbSA9IHByb2dyYW0uZ2xQcm9ncmFtc1t0aGlzLnJlbmRlcmVyLkNPTlRFWFRfVUlEXSB8fCB0aGlzLmdlbmVyYXRlU2hhZGVyKHNoYWRlcik7XG4gICAgICAgIHRoaXMuc2hhZGVyID0gc2hhZGVyO1xuICAgICAgICAvLyBUT0RPIC0gc29tZSBjdXJyZW50IFBpeGkgcGx1Z2lucyBieXBhc3MgdGhpcy4uIHNvIGl0IG5vdCBzYWZlIHRvIHVzZSB5ZXQuLlxuICAgICAgICBpZiAodGhpcy5wcm9ncmFtICE9PSBwcm9ncmFtKSB7XG4gICAgICAgICAgICB0aGlzLnByb2dyYW0gPSBwcm9ncmFtO1xuICAgICAgICAgICAgdGhpcy5nbC51c2VQcm9ncmFtKGdsUHJvZ3JhbS5wcm9ncmFtKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRvbnRTeW5jKSB7XG4gICAgICAgICAgICB0aGlzLnN5bmNVbmlmb3JtR3JvdXAoc2hhZGVyLnVuaWZvcm1Hcm91cCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdsUHJvZ3JhbTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFVwbG9hZHMgdGhlIHVuaWZvcm1zIHZhbHVlcyB0byB0aGUgY3VycmVudGx5IGJvdW5kIHNoYWRlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSB1bmlmb3JtcyAtIHRoZSB1bmlmb3JtcyB2YWx1ZXMgdGhhdCBiZSBhcHBsaWVkIHRvIHRoZSBjdXJyZW50IHNoYWRlclxuICAgICAqL1xuICAgIHNldFVuaWZvcm1zKHVuaWZvcm1zKSB7XG4gICAgICAgIHZhciBzaGFkZXIgPSB0aGlzLnNoYWRlci5wcm9ncmFtO1xuICAgICAgICB2YXIgZ2xQcm9ncmFtID0gc2hhZGVyLmdsUHJvZ3JhbXNbdGhpcy5yZW5kZXJlci5DT05URVhUX1VJRF07XG4gICAgICAgIHNoYWRlci5zeW5jVW5pZm9ybXMoZ2xQcm9ncmFtLnVuaWZvcm1EYXRhLCB1bmlmb3JtcywgdGhpcy5yZW5kZXJlcik7XG4gICAgfVxuICAgIDtcbiAgICBzeW5jVW5pZm9ybUdyb3VwKGdyb3VwKSB7XG4gICAgICAgIHZhciBnbFByb2dyYW0gPSB0aGlzLmdldGdsUHJvZ3JhbSgpO1xuICAgICAgICBpZiAoIWdyb3VwLnN0YXRpYyB8fCBncm91cC5kaXJ0eUlkICE9PSBnbFByb2dyYW0udW5pZm9ybUdyb3Vwc1tncm91cC5pZF0pIHtcbiAgICAgICAgICAgIGdsUHJvZ3JhbS51bmlmb3JtR3JvdXBzW2dyb3VwLmlkXSA9IGdyb3VwLmRpcnR5SWQ7XG4gICAgICAgICAgICB0aGlzLnN5bmNVbmlmb3Jtcyhncm91cCwgZ2xQcm9ncmFtKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGVhYmxlIGJ5IHRoZSBAcGl4aS91bnNhZmUtZXZhbCBwYWNrYWdlIHRvIHVzZSBzdGF0aWNcbiAgICAgKiBzeW5jVW5mb3JtcyBpbnN0ZWFkLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBzeW5jVW5pZm9ybXMoZ3JvdXAsIGdsUHJvZ3JhbSkge1xuICAgICAgICB2YXIgc3luY0Z1bmMgPSBncm91cC5zeW5jVW5pZm9ybXNbdGhpcy5zaGFkZXIucHJvZ3JhbS5pZF0gfHwgdGhpcy5jcmVhdGVTeW5jR3JvdXBzKGdyb3VwKTtcbiAgICAgICAgc3luY0Z1bmMoZ2xQcm9ncmFtLnVuaWZvcm1EYXRhLCBncm91cC51bmlmb3JtcywgdGhpcy5yZW5kZXJlcik7XG4gICAgfVxuICAgIDtcbiAgICBjcmVhdGVTeW5jR3JvdXBzKGdyb3VwKSB7XG4gICAgICAgIHZhciBpZCA9IHRoaXMuZ2V0U2lnbmF0dXJlKGdyb3VwLCB0aGlzLnNoYWRlci5wcm9ncmFtLnVuaWZvcm1EYXRhKTtcbiAgICAgICAgaWYgKCF0aGlzLmNhY2hlW2lkXSkge1xuICAgICAgICAgICAgdGhpcy5jYWNoZVtpZF0gPSBXZWJHTFNldHRpbmdzXzEuV2ViR0xTZXR0aW5ncy5nZW5lcmF0ZVVuaWZvcm1zU3luYyhncm91cCwgdGhpcy5zaGFkZXIucHJvZ3JhbS51bmlmb3JtRGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgZ3JvdXAuc3luY1VuaWZvcm1zW3RoaXMuc2hhZGVyLnByb2dyYW0uaWRdID0gdGhpcy5jYWNoZVtpZF07XG4gICAgICAgIHJldHVybiBncm91cC5zeW5jVW5pZm9ybXNbdGhpcy5zaGFkZXIucHJvZ3JhbS5pZF07XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBUYWtlcyBhIHVuaWZvcm0gZ3JvdXAgYW5kIGRhdGEgYW5kIGdlbmVyYXRlcyBhIHVuaXF1ZSBzaWduYXR1cmUgZm9yIHRoZW0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BJWEkuVW5pZm9ybUdyb3VwfSBncm91cCB0aGUgdW5pZm9ybSBncm91cCB0byBnZXQgc2lnbmF0dXJlIG9mXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHVuaWZvcm1EYXRhIHVuaWZvcm0gaW5mb3JtYXRpb24gZ2VuZXJhdGVkIGJ5IHRoZSBzaGFkZXJcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBVbmlxdWUgc2lnbmF0dXJlIG9mIHRoZSB1bmlmb3JtIGdyb3VwXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBnZXRTaWduYXR1cmUoZ3JvdXAsIHVuaWZvcm1EYXRhKSB7XG4gICAgICAgIHZhciB1bmlmb3JtcyA9IGdyb3VwLnVuaWZvcm1zO1xuICAgICAgICB2YXIgc3RyaW5ncyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpIGluIHVuaWZvcm1zKSB7XG4gICAgICAgICAgICBzdHJpbmdzLnB1c2goaSk7XG4gICAgICAgICAgICBpZiAodW5pZm9ybURhdGFbaV0pIHtcbiAgICAgICAgICAgICAgICBzdHJpbmdzLnB1c2godW5pZm9ybURhdGFbaV0udHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0cmluZ3Muam9pbignLScpO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdW5kZXJseWluZyBHTFNoYWRlIHJvZiB0aGUgY3VycmVudGx5IGJvdW5kIHNoYWRlci5cbiAgICAgKiBUaGlzIGNhbiBiZSBoYW5keSBmb3Igd2hlbiB5b3UgdG8gaGF2ZSBhIGxpdHRsZSBtb3JlIGNvbnRyb2wgb3ZlciB0aGUgc2V0dGluZyBvZiB5b3VyIHVuaWZvcm1zLlxuICAgICAqXG4gICAgICogQHJldHVybiB7UElYSS5HTFByb2dyYW19IHRoZSBnbFByb2dyYW0gZm9yIHRoZSBjdXJyZW50bHkgYm91bmQgU2hhZGVyIGZvciB0aGlzIGNvbnRleHRcbiAgICAgKi9cbiAgICBnZXRnbFByb2dyYW0oKSB7XG4gICAgICAgIGlmICh0aGlzLnNoYWRlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2hhZGVyLnByb2dyYW0uZ2xQcm9ncmFtc1t0aGlzLnJlbmRlcmVyLkNPTlRFWFRfVUlEXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBhIGdsUHJvZ3JhbSB2ZXJzaW9uIG9mIHRoZSBTaGFkZXIgcHJvdmlkZWQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7UElYSS5TaGFkZXJ9IHNoYWRlciB0aGUgc2hhZGVyIHRoYXQgdGhlIGdsUHJvZ3JhbSB3aWxsIGJlIGJhc2VkIG9uLlxuICAgICAqIEByZXR1cm4ge1BJWEkuR0xQcm9ncmFtfSBBIHNoaW55IG5ldyBnbFByb2dyYW0hXG4gICAgICovXG4gICAgZ2VuZXJhdGVTaGFkZXIoc2hhZGVyKSB7XG4gICAgICAgIHZhciBnbCA9IHRoaXMuZ2w7XG4gICAgICAgIHZhciBwcm9ncmFtID0gc2hhZGVyLnByb2dyYW07XG4gICAgICAgIHZhciBhdHRyaWJNYXAgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgaSBpbiBwcm9ncmFtLmF0dHJpYnV0ZURhdGEpIHtcbiAgICAgICAgICAgIGF0dHJpYk1hcFtpXSA9IHByb2dyYW0uYXR0cmlidXRlRGF0YVtpXS5sb2NhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2hhZGVyUHJvZ3JhbSA9IFByb2dyYW1fMS5Qcm9ncmFtLmNvbXBpbGVQcm9ncmFtKGdsLCBwcm9ncmFtLnZlcnRleFNyYywgcHJvZ3JhbS5mcmFnbWVudFNyYywgYXR0cmliTWFwKTtcbiAgICAgICAgdmFyIHVuaWZvcm1EYXRhID0ge307XG4gICAgICAgIGZvciAodmFyIGkkMSBpbiBwcm9ncmFtLnVuaWZvcm1EYXRhKSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IHByb2dyYW0udW5pZm9ybURhdGFbaSQxXTtcbiAgICAgICAgICAgIHVuaWZvcm1EYXRhW2kkMV0gPSB7XG4gICAgICAgICAgICAgICAgbG9jYXRpb246IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihzaGFkZXJQcm9ncmFtLCBpJDEpLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBXZWJHTFNldHRpbmdzXzEuV2ViR0xTZXR0aW5ncy5kZWZhdWx0VmFsdWUoZGF0YS50eXBlLCBkYXRhLnNpemUpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZ2xQcm9ncmFtID0gbmV3IEdMUHJvZ3JhbV8xLkdMUHJvZ3JhbShzaGFkZXJQcm9ncmFtLCB1bmlmb3JtRGF0YSk7XG4gICAgICAgIHByb2dyYW0uZ2xQcm9ncmFtc1t0aGlzLnJlbmRlcmVyLkNPTlRFWFRfVUlEXSA9IGdsUHJvZ3JhbTtcbiAgICAgICAgcmV0dXJuIGdsUHJvZ3JhbTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFJlc2V0cyBTaGFkZXJTeXN0ZW0gc3RhdGUsIGRvZXMgbm90IGFmZmVjdCBXZWJHTCBzdGF0ZVxuICAgICAqL1xuICAgIHJlc2V0KCkge1xuICAgICAgICB0aGlzLnByb2dyYW0gPSBudWxsO1xuICAgICAgICB0aGlzLnNoYWRlciA9IG51bGw7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBEZXN0cm95cyB0aGlzIFN5c3RlbSBhbmQgcmVtb3ZlcyBhbGwgaXRzIHRleHR1cmVzXG4gICAgICovXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgLy8gVE9ETyBpbXBsZW1lbnQgZGVzdHJveSBtZXRob2QgZm9yIFNoYWRlclN5c3RlbVxuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IHRydWU7XG4gICAgfVxuICAgIDtcbn1cbmV4cG9ydHMuU2hhZGVyU3lzdGVtID0gU2hhZGVyU3lzdGVtO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jbGFzcyBTaGFwZVNldHRpbmdzIHtcbn1cbi8qKlxuKiBDb25zdGFudHMgdGhhdCBpZGVudGlmeSBzaGFwZXMsIG1haW5seSB0byBwcmV2ZW50IGBpbnN0YW5jZW9mYCBjYWxscy5cbipcbiogQHN0YXRpY1xuKiBAY29uc3RhbnRcbiogQG5hbWUgU0hBUEVTXG4qIEBtZW1iZXJvZiBQSVhJXG4qIEB0eXBlIHtvYmplY3R9XG4qIEBwcm9wZXJ0eSB7bnVtYmVyfSBQT0xZIFBvbHlnb25cbiogQHByb3BlcnR5IHtudW1iZXJ9IFJFQ1QgUmVjdGFuZ2xlXG4qIEBwcm9wZXJ0eSB7bnVtYmVyfSBDSVJDIENpcmNsZVxuKiBAcHJvcGVydHkge251bWJlcn0gRUxJUCBFbGxpcHNlXG4qIEBwcm9wZXJ0eSB7bnVtYmVyfSBSUkVDIFJvdW5kZWQgUmVjdGFuZ2xlXG4qL1xuU2hhcGVTZXR0aW5ncy5TSEFQRVMgPSB7XG4gICAgUE9MWTogMCxcbiAgICBSRUNUOiAxLFxuICAgIENJUkM6IDIsXG4gICAgRUxJUDogMyxcbiAgICBSUkVDOiA0LFxufTtcbmV4cG9ydHMuU2hhcGVTZXR0aW5ncyA9IFNoYXBlU2V0dGluZ3M7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IE1lc2hfMSA9IHJlcXVpcmUoXCIuL01lc2hcIik7XG5jb25zdCBSb3BlR2VvbWV0cnlfMSA9IHJlcXVpcmUoXCIuL1JvcGVHZW9tZXRyeVwiKTtcbmNvbnN0IE1lc2hNYXRlcmlhbF8xID0gcmVxdWlyZShcIi4vTWVzaE1hdGVyaWFsXCIpO1xuY2xhc3MgU2ltcGxlUm9wZSBleHRlbmRzIE1lc2hfMS5NZXNoIHtcbiAgICBjb25zdHJ1Y3Rvcih0ZXh0dXJlLCBwb2ludHMpIHtcbiAgICAgICAgdmFyIHJvcGVHZW9tZXRyeSA9IG5ldyBSb3BlR2VvbWV0cnlfMS5Sb3BlR2VvbWV0cnkodGV4dHVyZS5oZWlnaHQsIHBvaW50cyk7XG4gICAgICAgIHZhciBtZXNoTWF0ZXJpYWwgPSBuZXcgTWVzaE1hdGVyaWFsXzEuTWVzaE1hdGVyaWFsKHRleHR1cmUpO1xuICAgICAgICBzdXBlcihyb3BlR2VvbWV0cnksIG1lc2hNYXRlcmlhbCk7XG4gICAgICAgIHRoaXMuYXV0b1VwZGF0ZSA9IHRydWU7XG4gICAgfVxuICAgIF9yZW5kZXIocmVuZGVyZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuYXV0b1VwZGF0ZVxuICAgICAgICAgICAgfHwgdGhpcy5nZW9tZXRyeS53aWR0aCAhPT0gdGhpcy5zaGFkZXIudGV4dHVyZS5oZWlnaHQpIHtcbiAgICAgICAgICAgIHRoaXMuZ2VvbWV0cnkud2lkdGggPSB0aGlzLnNoYWRlci50ZXh0dXJlLmhlaWdodDtcbiAgICAgICAgICAgIHRoaXMuZ2VvbWV0cnkudXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIuX3JlbmRlcihyZW5kZXJlcik7XG4gICAgfVxuICAgIDtcbn1cbmV4cG9ydHMuU2ltcGxlUm9wZSA9IFNpbXBsZVJvcGU7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IENvbnRhaW5lcl8xID0gcmVxdWlyZShcIi4vQ29udGFpbmVyXCIpO1xuY29uc3QgT2JzZXJ2YWJsZVBvaW50XzEgPSByZXF1aXJlKFwiLi9PYnNlcnZhYmxlUG9pbnRcIik7XG5jb25zdCBUZXh0dXJlXzEgPSByZXF1aXJlKFwiLi9UZXh0dXJlXCIpO1xuY29uc3QgUmVjdGFuZ2xlXzEgPSByZXF1aXJlKFwiLi4vZmxhc2gvZ2VvbS9SZWN0YW5nbGVcIik7XG5jb25zdCBQb2ludF8xID0gcmVxdWlyZShcIi4uL2ZsYXNoL2dlb20vUG9pbnRcIik7XG5jb25zdCBCbGVuZE1vZGVzU2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL0JsZW5kTW9kZXNTZXR0aW5nc1wiKTtcbmNvbnN0IERpc3BsYXlTZXR0aW5nc18xID0gcmVxdWlyZShcIi4vRGlzcGxheVNldHRpbmdzXCIpO1xuY29uc3QgTWF0aFNldHRpbmdzXzEgPSByZXF1aXJlKFwiLi9NYXRoU2V0dGluZ3NcIik7XG5jb25zdCBJbnN0YW5jZUNvdW50ZXJfMSA9IHJlcXVpcmUoXCIuL0luc3RhbmNlQ291bnRlclwiKTtcbmNsYXNzIFNwcml0ZSBleHRlbmRzIENvbnRhaW5lcl8xLkNvbnRhaW5lciB7XG4gICAgY29uc3RydWN0b3IodGV4dHVyZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hlbiB0aGUgdGV4dHVyZSBpcyB1cGRhdGVkLCB0aGlzIGV2ZW50IHdpbGwgZmlyZSB0byB1cGRhdGUgdGhlIHNjYWxlIGFuZCBmcmFtZVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fb25UZXh0dXJlVXBkYXRlID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fdGV4dHVyZUlEID0gLTE7XG4gICAgICAgICAgICB0aGlzLl90ZXh0dXJlVHJpbW1lZElEID0gLTE7XG4gICAgICAgICAgICB0aGlzLmNhY2hlZFRpbnQgPSAweEZGRkZGRjtcbiAgICAgICAgICAgIHRoaXMudXZzID0gdGhpcy5fdGV4dHVyZS5fdXZzLnV2c0Zsb2F0MzI7XG4gICAgICAgICAgICAvLyBzbyBpZiBfd2lkdGggaXMgMCB0aGVuIHdpZHRoIHdhcyBub3Qgc2V0Li5cbiAgICAgICAgICAgIGlmICh0aGlzLl93aWR0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2NhbGUueCA9IE1hdGhTZXR0aW5nc18xLk1hdGhTZXR0aW5ncy5zaWduKHRoaXMuc2NhbGUueCkgKiB0aGlzLl93aWR0aCAvIHRoaXMuX3RleHR1cmUub3JpZy53aWR0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9oZWlnaHQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNjYWxlLnkgPSBNYXRoU2V0dGluZ3NfMS5NYXRoU2V0dGluZ3Muc2lnbih0aGlzLnNjYWxlLnkpICogdGhpcy5faGVpZ2h0IC8gdGhpcy5fdGV4dHVyZS5vcmlnLmhlaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBhbmNob3Igc2V0cyB0aGUgb3JpZ2luIHBvaW50IG9mIHRoZSB0ZXh0dXJlLlxuICAgICAgICAgKiBUaGUgZGVmYXVsdCBpcyAwLDAgb3IgdGFrZW4gZnJvbSB0aGUge0BsaW5rIFBJWEkuVGV4dHVyZSNkZWZhdWx0QW5jaG9yfFRleHR1cmV9XG4gICAgICAgICAqIHBhc3NlZCB0byB0aGUgY29uc3RydWN0b3IuIEEgdmFsdWUgb2YgMCwwIG1lYW5zIHRoZSB0ZXh0dXJlJ3Mgb3JpZ2luIGlzIHRoZSB0b3AgbGVmdC5cbiAgICAgICAgICogU2V0dGluZyB0aGUgYW5jaG9yIHRvIDAuNSwwLjUgbWVhbnMgdGhlIHRleHR1cmUncyBvcmlnaW4gaXMgY2VudGVyZWQuXG4gICAgICAgICAqIFNldHRpbmcgdGhlIGFuY2hvciB0byAxLDEgd291bGQgbWVhbiB0aGUgdGV4dHVyZSdzIG9yaWdpbiBwb2ludCB3aWxsIGJlIHRoZSBib3R0b20gcmlnaHQgY29ybmVyLlxuICAgICAgICAgKiBOb3RlOiBVcGRhdGluZyB0aGUge0BsaW5rIFBJWEkuVGV4dHVyZSNkZWZhdWx0QW5jaG9yfSBhZnRlciBhIFRleHR1cmUgaXNcbiAgICAgICAgICogY3JlYXRlZCBkb2VzIF9ub3RfIHVwZGF0ZSB0aGUgU3ByaXRlJ3MgYW5jaG9yIHZhbHVlcy5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7UElYSS5PYnNlcnZhYmxlUG9pbnR9XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9hbmNob3IgPSBuZXcgT2JzZXJ2YWJsZVBvaW50XzEuT2JzZXJ2YWJsZVBvaW50KDAsIDApO1xuICAgICAgICBpZiAodGV4dHVyZSkge1xuICAgICAgICAgICAgdGhpcy5fYW5jaG9yLnNldFRvKHRleHR1cmUuZGVmYXVsdEFuY2hvci54LCB0ZXh0dXJlLmRlZmF1bHRBbmNob3IueSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fYW5jaG9yLnNjb3BlID0gdGhpcztcbiAgICAgICAgdGhpcy5fYW5jaG9yLmNhbGxiYWNrID0gdGhpcy5fb25BbmNob3JVcGRhdGU7XG4gICAgICAgIDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0ZXh0dXJlIHRoYXQgdGhlIHNwcml0ZSBpcyB1c2luZ1xuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLlRleHR1cmV9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl90ZXh0dXJlID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB3aWR0aCBvZiB0aGUgc3ByaXRlICh0aGlzIGlzIGluaXRpYWxseSBzZXQgYnkgdGhlIHRleHR1cmUpXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3dpZHRoID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBoZWlnaHQgb2YgdGhlIHNwcml0ZSAodGhpcyBpcyBpbml0aWFsbHkgc2V0IGJ5IHRoZSB0ZXh0dXJlKVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9oZWlnaHQgPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHRpbnQgYXBwbGllZCB0byB0aGUgc3ByaXRlLiBUaGlzIGlzIGEgaGV4IHZhbHVlLiBBIHZhbHVlIG9mIDB4RkZGRkZGIHdpbGwgcmVtb3ZlIGFueSB0aW50IGVmZmVjdC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAweEZGRkZGRlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fdGludCA9IG51bGw7XG4gICAgICAgIHRoaXMuX3RpbnRSR0IgPSBudWxsO1xuICAgICAgICB0aGlzLnRpbnQgPSAweEZGRkZGRjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBibGVuZCBtb2RlIHRvIGJlIGFwcGxpZWQgdG8gdGhlIHNwcml0ZS4gQXBwbHkgYSB2YWx1ZSBvZiBgUElYSS5CTEVORF9NT0RFUy5OT1JNQUxgIHRvIHJlc2V0IHRoZSBibGVuZCBtb2RlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IFBJWEkuQkxFTkRfTU9ERVMuTk9STUFMXG4gICAgICAgICAqIEBzZWUgUElYSS5CTEVORF9NT0RFU1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5ibGVuZE1vZGUgPSBCbGVuZE1vZGVzU2V0dGluZ3NfMS5CbGVuZE1vZGVzU2V0dGluZ3MuQkxFTkRfTU9ERVMuTk9STUFMO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHNoYWRlciB0aGF0IHdpbGwgYmUgdXNlZCB0byByZW5kZXIgdGhlIHNwcml0ZS4gU2V0IHRvIG51bGwgdG8gcmVtb3ZlIGEgY3VycmVudCBzaGFkZXIuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuRmlsdGVyfFBJWEkuU2hhZGVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zaGFkZXIgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogQW4gaW50ZXJuYWwgY2FjaGVkIHZhbHVlIG9mIHRoZSB0aW50LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDB4RkZGRkZGXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNhY2hlZFRpbnQgPSAweEZGRkZGRjtcbiAgICAgICAgdGhpcy51dnMgPSBudWxsO1xuICAgICAgICAvLyBjYWxsIHRleHR1cmUgc2V0dGVyXG4gICAgICAgIHRoaXMudGV4dHVyZSA9IHRleHR1cmUgfHwgVGV4dHVyZV8xLlRleHR1cmUuRU1QVFk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiB0aGlzIGlzIHVzZWQgdG8gc3RvcmUgdGhlIHZlcnRleCBkYXRhIG9mIHRoZSBzcHJpdGUgKGJhc2ljYWxseSBhIHF1YWQpXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBtZW1iZXIge0Zsb2F0MzJBcnJheX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudmVydGV4RGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoOCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGlzIHVzZWQgdG8gY2FsY3VsYXRlIHRoZSBib3VuZHMgb2YgdGhlIG9iamVjdCBJRiBpdCBpcyBhIHRyaW1tZWQgc3ByaXRlXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBtZW1iZXIge0Zsb2F0MzJBcnJheX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudmVydGV4VHJpbW1lZERhdGEgPSBudWxsO1xuICAgICAgICB0aGlzLl90cmFuc2Zvcm1JRCA9IC0xO1xuICAgICAgICB0aGlzLl90ZXh0dXJlSUQgPSAtMTtcbiAgICAgICAgdGhpcy5fdHJhbnNmb3JtVHJpbW1lZElEID0gLTE7XG4gICAgICAgIHRoaXMuX3RleHR1cmVUcmltbWVkSUQgPSAtMTtcbiAgICAgICAgLy8gQmF0Y2hhYmxlIHN0dWZmLi5cbiAgICAgICAgLy8gVE9ETyBjb3VsZCBtYWtlIHRoaXMgYSBtaXhpbj9cbiAgICAgICAgdGhpcy5pbmRpY2VzID0gU3ByaXRlLmluZGljZXM7XG4gICAgICAgIHRoaXMuc2l6ZSA9IDQ7XG4gICAgICAgIHRoaXMuc3RhcnQgPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgICogUGx1Z2luIHRoYXQgaXMgcmVzcG9uc2libGUgZm9yIHJlbmRlcmluZyB0aGlzIGVsZW1lbnQuXG4gICAgICAgICAqIEFsbG93cyB0byBjdXN0b21pemUgdGhlIHJlbmRlcmluZyBwcm9jZXNzIHdpdGhvdXQgb3ZlcnJpZGluZyAnX3JlbmRlcicgJiAnX3JlbmRlckNhbnZhcycgbWV0aG9kcy5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7c3RyaW5nfVxuICAgICAgICAgKiBAZGVmYXVsdCAnc3ByaXRlJ1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wbHVnaW5OYW1lID0gJ2JhdGNoJztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHVzZWQgdG8gZmFzdCBjaGVjayBpZiBhIHNwcml0ZSBpcy4uIGEgc3ByaXRlIVxuICAgICAgICAgKiBAbWVtYmVyIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pc1Nwcml0ZSA9IHRydWU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbnRlcm5hbCByb3VuZFBpeGVscyBmaWVsZFxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtib29sZWFufVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fcm91bmRQaXhlbHMgPSBEaXNwbGF5U2V0dGluZ3NfMS5EaXNwbGF5U2V0dGluZ3MuUk9VTkRfUElYRUxTO1xuICAgIH1cbiAgICBkZXN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlci5kZXN0cnVjdG9yKCk7XG4gICAgICAgIC8vIHRoaXMuX2FuY2hvciBvYnNlcnZhYmxlcG9pbnRcbiAgICAgICAgLy8gdGhpcy5fdGV4dHVyZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX3dpZHRoID0gbnVsbDtcbiAgICAgICAgdGhpcy5faGVpZ2h0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fdGludCA9IG51bGw7XG4gICAgICAgIHRoaXMuX3RpbnRSR0IgPSBudWxsO1xuICAgICAgICB0aGlzLmJsZW5kTW9kZSA9IG51bGw7XG4gICAgICAgIC8vIHRoaXMuc2hhZGVyID0gbnVsbDsgU2hhZGVyXG4gICAgICAgIHRoaXMuY2FjaGVkVGludCA9IG51bGw7XG4gICAgICAgIC8vIHRoaXMudXZzID0gbnVsbDtcbiAgICAgICAgdGhpcy52ZXJ0ZXhEYXRhID0gbnVsbDtcbiAgICAgICAgdGhpcy52ZXJ0ZXhUcmltbWVkRGF0YSA9IG51bGw7XG4gICAgICAgIHRoaXMuX3RyYW5zZm9ybUlEID0gbnVsbDtcbiAgICAgICAgdGhpcy5fdGV4dHVyZUlEID0gbnVsbDtcbiAgICAgICAgdGhpcy5fdHJhbnNmb3JtVHJpbW1lZElEID0gbnVsbDtcbiAgICAgICAgdGhpcy5fdGV4dHVyZVRyaW1tZWRJRCA9IG51bGw7XG4gICAgICAgIHRoaXMuaW5kaWNlcyA9IG51bGw7XG4gICAgICAgIHRoaXMuc2l6ZSA9IG51bGw7XG4gICAgICAgIHRoaXMuc3RhcnQgPSBudWxsO1xuICAgICAgICB0aGlzLnBsdWdpbk5hbWUgPSBudWxsO1xuICAgICAgICB0aGlzLmlzU3ByaXRlID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcm91bmRQaXhlbHMgPSBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbiB0aGUgYW5jaG9yIHBvc2l0aW9uIHVwZGF0ZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9vbkFuY2hvclVwZGF0ZSgpIHtcbiAgICAgICAgdGhpcy5fdHJhbnNmb3JtSUQgPSAtMTtcbiAgICAgICAgdGhpcy5fdHJhbnNmb3JtVHJpbW1lZElEID0gLTE7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBjYWxjdWxhdGVzIHdvcmxkVHJhbnNmb3JtICogdmVydGljZXMsIHN0b3JlIGl0IGluIHZlcnRleERhdGFcbiAgICAgKi9cbiAgICBjYWxjdWxhdGVWZXJ0aWNlcygpIHtcbiAgICAgICAgdmFyIHRleHR1cmUgPSB0aGlzLl90ZXh0dXJlO1xuICAgICAgICBpZiAodGhpcy5fdHJhbnNmb3JtSUQgPT09IHRoaXMudHJhbnNmb3JtLndvcmxkSUQgJiYgdGhpcy5fdGV4dHVyZUlEID09PSB0ZXh0dXJlLl91cGRhdGVJRCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3RyYW5zZm9ybUlEID0gdGhpcy50cmFuc2Zvcm0ud29ybGRJRDtcbiAgICAgICAgdGhpcy5fdGV4dHVyZUlEID0gdGV4dHVyZS5fdXBkYXRlSUQ7XG4gICAgICAgIC8vIHNldCB0aGUgdmVydGV4IGRhdGFcbiAgICAgICAgdmFyIHd0ID0gdGhpcy50cmFuc2Zvcm0ud29ybGRUcmFuc2Zvcm07XG4gICAgICAgIHZhciBhID0gd3QuYTtcbiAgICAgICAgdmFyIGIgPSB3dC5iO1xuICAgICAgICB2YXIgYyA9IHd0LmM7XG4gICAgICAgIHZhciBkID0gd3QuZDtcbiAgICAgICAgdmFyIHR4ID0gd3QudHg7XG4gICAgICAgIHZhciB0eSA9IHd0LnR5O1xuICAgICAgICB2YXIgdmVydGV4RGF0YSA9IHRoaXMudmVydGV4RGF0YTtcbiAgICAgICAgdmFyIHRyaW0gPSB0ZXh0dXJlLnRyaW07XG4gICAgICAgIHZhciBvcmlnID0gdGV4dHVyZS5vcmlnO1xuICAgICAgICB2YXIgYW5jaG9yID0gdGhpcy5fYW5jaG9yO1xuICAgICAgICB2YXIgdzAgPSAwO1xuICAgICAgICB2YXIgdzEgPSAwO1xuICAgICAgICB2YXIgaDAgPSAwO1xuICAgICAgICB2YXIgaDEgPSAwO1xuICAgICAgICBpZiAodHJpbSkge1xuICAgICAgICAgICAgLy8gaWYgdGhlIHNwcml0ZSBpcyB0cmltbWVkIGFuZCBpcyBub3QgYSB0aWxpbmdzcHJpdGUgdGhlbiB3ZSBuZWVkIHRvIGFkZCB0aGUgZXh0cmFcbiAgICAgICAgICAgIC8vIHNwYWNlIGJlZm9yZSB0cmFuc2Zvcm1pbmcgdGhlIHNwcml0ZSBjb29yZHMuXG4gICAgICAgICAgICB3MSA9IHRyaW0ueCAtIChhbmNob3IueCAqIG9yaWcud2lkdGgpO1xuICAgICAgICAgICAgdzAgPSB3MSArIHRyaW0ud2lkdGg7XG4gICAgICAgICAgICBoMSA9IHRyaW0ueSAtIChhbmNob3IueSAqIG9yaWcuaGVpZ2h0KTtcbiAgICAgICAgICAgIGgwID0gaDEgKyB0cmltLmhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHcxID0gLWFuY2hvci54ICogb3JpZy53aWR0aDtcbiAgICAgICAgICAgIHcwID0gdzEgKyBvcmlnLndpZHRoO1xuICAgICAgICAgICAgaDEgPSAtYW5jaG9yLnkgKiBvcmlnLmhlaWdodDtcbiAgICAgICAgICAgIGgwID0gaDEgKyBvcmlnLmhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICAvLyB4eVxuICAgICAgICB2ZXJ0ZXhEYXRhWzBdID0gKGEgKiB3MSkgKyAoYyAqIGgxKSArIHR4O1xuICAgICAgICB2ZXJ0ZXhEYXRhWzFdID0gKGQgKiBoMSkgKyAoYiAqIHcxKSArIHR5O1xuICAgICAgICAvLyB4eVxuICAgICAgICB2ZXJ0ZXhEYXRhWzJdID0gKGEgKiB3MCkgKyAoYyAqIGgxKSArIHR4O1xuICAgICAgICB2ZXJ0ZXhEYXRhWzNdID0gKGQgKiBoMSkgKyAoYiAqIHcwKSArIHR5O1xuICAgICAgICAvLyB4eVxuICAgICAgICB2ZXJ0ZXhEYXRhWzRdID0gKGEgKiB3MCkgKyAoYyAqIGgwKSArIHR4O1xuICAgICAgICB2ZXJ0ZXhEYXRhWzVdID0gKGQgKiBoMCkgKyAoYiAqIHcwKSArIHR5O1xuICAgICAgICAvLyB4eVxuICAgICAgICB2ZXJ0ZXhEYXRhWzZdID0gKGEgKiB3MSkgKyAoYyAqIGgwKSArIHR4O1xuICAgICAgICB2ZXJ0ZXhEYXRhWzddID0gKGQgKiBoMCkgKyAoYiAqIHcxKSArIHR5O1xuICAgICAgICBpZiAodGhpcy5fcm91bmRQaXhlbHMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgODsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmVydGV4RGF0YVtpXSA9IE1hdGgucm91bmQodmVydGV4RGF0YVtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIGNhbGN1bGF0ZXMgd29ybGRUcmFuc2Zvcm0gKiB2ZXJ0aWNlcyBmb3IgYSBub24gdGV4dHVyZSB3aXRoIGEgdHJpbS4gc3RvcmUgaXQgaW4gdmVydGV4VHJpbW1lZERhdGFcbiAgICAgKiBUaGlzIGlzIHVzZWQgdG8gZW5zdXJlIHRoYXQgdGhlIHRydWUgd2lkdGggYW5kIGhlaWdodCBvZiBhIHRyaW1tZWQgdGV4dHVyZSBpcyByZXNwZWN0ZWRcbiAgICAgKi9cbiAgICBjYWxjdWxhdGVUcmltbWVkVmVydGljZXMoKSB7XG4gICAgICAgIGlmICghdGhpcy52ZXJ0ZXhUcmltbWVkRGF0YSkge1xuICAgICAgICAgICAgdGhpcy52ZXJ0ZXhUcmltbWVkRGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoOCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5fdHJhbnNmb3JtVHJpbW1lZElEID09PSB0aGlzLnRyYW5zZm9ybS53b3JsZElEICYmIHRoaXMuX3RleHR1cmVUcmltbWVkSUQgPT09IHRoaXMuX3RleHR1cmUuX3VwZGF0ZUlEKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdHJhbnNmb3JtVHJpbW1lZElEID0gdGhpcy50cmFuc2Zvcm0ud29ybGRJRDtcbiAgICAgICAgdGhpcy5fdGV4dHVyZVRyaW1tZWRJRCA9IHRoaXMuX3RleHR1cmUuX3VwZGF0ZUlEO1xuICAgICAgICAvLyBsZXRzIGRvIHNvbWUgc3BlY2lhbCB0cmltIGNvZGUhXG4gICAgICAgIHZhciB0ZXh0dXJlID0gdGhpcy5fdGV4dHVyZTtcbiAgICAgICAgdmFyIHZlcnRleERhdGEgPSB0aGlzLnZlcnRleFRyaW1tZWREYXRhO1xuICAgICAgICB2YXIgb3JpZyA9IHRleHR1cmUub3JpZztcbiAgICAgICAgdmFyIGFuY2hvciA9IHRoaXMuX2FuY2hvcjtcbiAgICAgICAgLy8gbGV0cyBjYWxjdWxhdGUgdGhlIG5ldyB1bnRyaW1tZWQgYm91bmRzLi5cbiAgICAgICAgdmFyIHd0ID0gdGhpcy50cmFuc2Zvcm0ud29ybGRUcmFuc2Zvcm07XG4gICAgICAgIHZhciBhID0gd3QuYTtcbiAgICAgICAgdmFyIGIgPSB3dC5iO1xuICAgICAgICB2YXIgYyA9IHd0LmM7XG4gICAgICAgIHZhciBkID0gd3QuZDtcbiAgICAgICAgdmFyIHR4ID0gd3QudHg7XG4gICAgICAgIHZhciB0eSA9IHd0LnR5O1xuICAgICAgICB2YXIgdzEgPSAtYW5jaG9yLnggKiBvcmlnLndpZHRoO1xuICAgICAgICB2YXIgdzAgPSB3MSArIG9yaWcud2lkdGg7XG4gICAgICAgIHZhciBoMSA9IC1hbmNob3IueSAqIG9yaWcuaGVpZ2h0O1xuICAgICAgICB2YXIgaDAgPSBoMSArIG9yaWcuaGVpZ2h0O1xuICAgICAgICAvLyB4eVxuICAgICAgICB2ZXJ0ZXhEYXRhWzBdID0gKGEgKiB3MSkgKyAoYyAqIGgxKSArIHR4O1xuICAgICAgICB2ZXJ0ZXhEYXRhWzFdID0gKGQgKiBoMSkgKyAoYiAqIHcxKSArIHR5O1xuICAgICAgICAvLyB4eVxuICAgICAgICB2ZXJ0ZXhEYXRhWzJdID0gKGEgKiB3MCkgKyAoYyAqIGgxKSArIHR4O1xuICAgICAgICB2ZXJ0ZXhEYXRhWzNdID0gKGQgKiBoMSkgKyAoYiAqIHcwKSArIHR5O1xuICAgICAgICAvLyB4eVxuICAgICAgICB2ZXJ0ZXhEYXRhWzRdID0gKGEgKiB3MCkgKyAoYyAqIGgwKSArIHR4O1xuICAgICAgICB2ZXJ0ZXhEYXRhWzVdID0gKGQgKiBoMCkgKyAoYiAqIHcwKSArIHR5O1xuICAgICAgICAvLyB4eVxuICAgICAgICB2ZXJ0ZXhEYXRhWzZdID0gKGEgKiB3MSkgKyAoYyAqIGgwKSArIHR4O1xuICAgICAgICB2ZXJ0ZXhEYXRhWzddID0gKGQgKiBoMCkgKyAoYiAqIHcxKSArIHR5O1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgKlxuICAgICogUmVuZGVycyB0aGUgb2JqZWN0IHVzaW5nIHRoZSBXZWJHTCByZW5kZXJlclxuICAgICpcbiAgICAqIEBwcm90ZWN0ZWRcbiAgICAqIEBwYXJhbSB7UElYSS5SZW5kZXJlcn0gcmVuZGVyZXIgLSBUaGUgd2ViZ2wgcmVuZGVyZXIgdG8gdXNlLlxuICAgICovXG4gICAgX3JlbmRlcihyZW5kZXJlcikge1xuICAgICAgICB0aGlzLmNhbGN1bGF0ZVZlcnRpY2VzKCk7XG4gICAgICAgIHJlbmRlcmVyLmJhdGNoLnNldE9iamVjdFJlbmRlcmVyKHJlbmRlcmVyLnBsdWdpbnNbdGhpcy5wbHVnaW5OYW1lXSk7XG4gICAgICAgIHJlbmRlcmVyLnBsdWdpbnNbdGhpcy5wbHVnaW5OYW1lXS5yZW5kZXIodGhpcyk7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBib3VuZHMgb2YgdGhlIHNwcml0ZS5cbiAgICAgKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfY2FsY3VsYXRlQm91bmRzKCkge1xuICAgICAgICB2YXIgdHJpbSA9IHRoaXMuX3RleHR1cmUudHJpbTtcbiAgICAgICAgdmFyIG9yaWcgPSB0aGlzLl90ZXh0dXJlLm9yaWc7XG4gICAgICAgIC8vIEZpcnN0IGxldHMgY2hlY2sgdG8gc2VlIGlmIHRoZSBjdXJyZW50IHRleHR1cmUgaGFzIGEgdHJpbS4uXG4gICAgICAgIGlmICghdHJpbSB8fCAodHJpbS53aWR0aCA9PT0gb3JpZy53aWR0aCAmJiB0cmltLmhlaWdodCA9PT0gb3JpZy5oZWlnaHQpKSB7XG4gICAgICAgICAgICAvLyBubyB0cmltISBsZXRzIHVzZSB0aGUgdXN1YWwgY2FsY3VsYXRpb25zLi5cbiAgICAgICAgICAgIHRoaXMuY2FsY3VsYXRlVmVydGljZXMoKTtcbiAgICAgICAgICAgIHRoaXMuX2JvdW5kcy5hZGRRdWFkKHRoaXMudmVydGV4RGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBsZXRzIGNhbGN1bGF0ZSBhIHNwZWNpYWwgdHJpbW1lZCBib3VuZHMuLi5cbiAgICAgICAgICAgIHRoaXMuY2FsY3VsYXRlVHJpbW1lZFZlcnRpY2VzKCk7XG4gICAgICAgICAgICB0aGlzLl9ib3VuZHMuYWRkUXVhZCh0aGlzLnZlcnRleFRyaW1tZWREYXRhKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgbG9jYWwgYm91bmRzIG9mIHRoZSBzcHJpdGUgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQSVhJLlJlY3RhbmdsZX0gcmVjdCAtIFRoZSBvdXRwdXQgcmVjdGFuZ2xlLlxuICAgICAqIEByZXR1cm4ge1BJWEkuUmVjdGFuZ2xlfSBUaGUgYm91bmRzLlxuICAgICAqL1xuICAgIGdldExvY2FsQm91bmRzKHJlY3QpIHtcbiAgICAgICAgLy8gd2UgY2FuIGRvIGEgZmFzdCBsb2NhbCBib3VuZHMgaWYgdGhlIHNwcml0ZSBoYXMgbm8gY2hpbGRyZW4hXG4gICAgICAgIGlmICh0aGlzLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5fYm91bmRzLm1pblggPSB0aGlzLl90ZXh0dXJlLm9yaWcud2lkdGggKiAtdGhpcy5fYW5jaG9yLng7XG4gICAgICAgICAgICB0aGlzLl9ib3VuZHMubWluWSA9IHRoaXMuX3RleHR1cmUub3JpZy5oZWlnaHQgKiAtdGhpcy5fYW5jaG9yLnk7XG4gICAgICAgICAgICB0aGlzLl9ib3VuZHMubWF4WCA9IHRoaXMuX3RleHR1cmUub3JpZy53aWR0aCAqICgxIC0gdGhpcy5fYW5jaG9yLngpO1xuICAgICAgICAgICAgdGhpcy5fYm91bmRzLm1heFkgPSB0aGlzLl90ZXh0dXJlLm9yaWcuaGVpZ2h0ICogKDEgLSB0aGlzLl9hbmNob3IueSk7XG4gICAgICAgICAgICBpZiAoIXJlY3QpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2xvY2FsQm91bmRzUmVjdCkge1xuICAgICAgICAgICAgICAgICAgICBJbnN0YW5jZUNvdW50ZXJfMS5JbnN0YW5jZUNvdW50ZXIuYWRkQ2FsbChcIlJlY3RhbmdsZS5nZXRSZWN0YW5nbGVcIiwgXCJTcHJpdGUgZ2V0TG9jYWxCb3VuZHNcIik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xvY2FsQm91bmRzUmVjdCA9IFJlY3RhbmdsZV8xLlJlY3RhbmdsZS5nZXRSZWN0YW5nbGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVjdCA9IHRoaXMuX2xvY2FsQm91bmRzUmVjdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIEluc3RhbmNlQ291bnRlcl8xLkluc3RhbmNlQ291bnRlci5hZGRDYWxsKFwiUmVjdGFuZ2xlLmdldFJlY3RhbmdsZVwiLCBcIlNwcml0ZSBnZXRMb2NhbEJvdW5kc1wiKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9ib3VuZHMuZ2V0UmVjdGFuZ2xlKHJlY3QpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBDb250YWluZXJfMS5Db250YWluZXIucHJvdG90eXBlLmdldExvY2FsQm91bmRzLmNhbGwodGhpcywgcmVjdCk7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBUZXN0cyBpZiBhIHBvaW50IGlzIGluc2lkZSB0aGlzIHNwcml0ZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtQSVhJLlBvaW50fSBwb2ludCAtIHRoZSBwb2ludCB0byB0ZXN0XG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gdGhlIHJlc3VsdCBvZiB0aGUgdGVzdFxuICAgICAqL1xuICAgIGNvbnRhaW5zUG9pbnQocG9pbnQpIHtcbiAgICAgICAgbGV0IGRlZnVsYXRwb2ludCA9IFBvaW50XzEuUG9pbnQuREVGQVVMVDtcbiAgICAgICAgdGhpcy53b3JsZFRyYW5zZm9ybS5hcHBseUludmVyc2UocG9pbnQsIGRlZnVsYXRwb2ludCk7XG4gICAgICAgIHZhciB3aWR0aCA9IHRoaXMuX3RleHR1cmUub3JpZy53aWR0aDtcbiAgICAgICAgdmFyIGhlaWdodCA9IHRoaXMuX3RleHR1cmUub3JpZy5oZWlnaHQ7XG4gICAgICAgIHZhciB4MSA9IC13aWR0aCAqIHRoaXMuYW5jaG9yLng7XG4gICAgICAgIHZhciB5MSA9IDA7XG4gICAgICAgIGlmIChkZWZ1bGF0cG9pbnQueCA+PSB4MSAmJiBkZWZ1bGF0cG9pbnQueCA8IHgxICsgd2lkdGgpIHtcbiAgICAgICAgICAgIHkxID0gLWhlaWdodCAqIHRoaXMuYW5jaG9yLnk7XG4gICAgICAgICAgICBpZiAoZGVmdWxhdHBvaW50LnkgPj0geTEgJiYgZGVmdWxhdHBvaW50LnkgPCB5MSArIGhlaWdodCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIERlc3Ryb3lzIHRoaXMgc3ByaXRlIGFuZCBvcHRpb25hbGx5IGl0cyB0ZXh0dXJlIGFuZCBjaGlsZHJlblxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R8Ym9vbGVhbn0gW29wdGlvbnNdIC0gT3B0aW9ucyBwYXJhbWV0ZXIuIEEgYm9vbGVhbiB3aWxsIGFjdCBhcyBpZiBhbGwgb3B0aW9uc1xuICAgICAqICBoYXZlIGJlZW4gc2V0IHRvIHRoYXQgdmFsdWVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmNoaWxkcmVuPWZhbHNlXSAtIGlmIHNldCB0byB0cnVlLCBhbGwgdGhlIGNoaWxkcmVuIHdpbGwgaGF2ZSB0aGVpciBkZXN0cm95XG4gICAgICogICAgICBtZXRob2QgY2FsbGVkIGFzIHdlbGwuICdvcHRpb25zJyB3aWxsIGJlIHBhc3NlZCBvbiB0byB0aG9zZSBjYWxscy5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRleHR1cmU9ZmFsc2VdIC0gU2hvdWxkIGl0IGRlc3Ryb3kgdGhlIGN1cnJlbnQgdGV4dHVyZSBvZiB0aGUgc3ByaXRlIGFzIHdlbGxcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmJhc2VUZXh0dXJlPWZhbHNlXSAtIFNob3VsZCBpdCBkZXN0cm95IHRoZSBiYXNlIHRleHR1cmUgb2YgdGhlIHNwcml0ZSBhcyB3ZWxsXG4gICAgICovXG4gICAgZGVzdHJveShvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyLmRlc3Ryb3kob3B0aW9ucyk7XG4gICAgICAgIC8vIHRoaXMuX3RleHR1cmUub2ZmKCd1cGRhdGUnLCB0aGlzLl9vblRleHR1cmVVcGRhdGUsIHRoaXMpO1xuICAgICAgICB0aGlzLl9hbmNob3IgPSBudWxsO1xuICAgICAgICB2YXIgZGVzdHJveVRleHR1cmUgPSB0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Jvb2xlYW4nID8gb3B0aW9ucyA6IG9wdGlvbnMgJiYgb3B0aW9ucy50ZXh0dXJlO1xuICAgICAgICBpZiAoZGVzdHJveVRleHR1cmUpIHtcbiAgICAgICAgICAgIHZhciBkZXN0cm95QmFzZVRleHR1cmUgPSB0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Jvb2xlYW4nID8gb3B0aW9ucyA6IG9wdGlvbnMgJiYgb3B0aW9ucy5iYXNlVGV4dHVyZTtcbiAgICAgICAgICAgIHRoaXMuX3RleHR1cmUuZGVzdHJveSghIWRlc3Ryb3lCYXNlVGV4dHVyZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdGV4dHVyZSA9IG51bGw7XG4gICAgICAgIHRoaXMuc2hhZGVyID0gbnVsbDtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIElmIHRydWUgUGl4aUpTIHdpbGwgTWF0aC5mbG9vcigpIHgveSB2YWx1ZXMgd2hlbiByZW5kZXJpbmcsIHN0b3BwaW5nIHBpeGVsIGludGVycG9sYXRpb24uXG4gICAgICogQWR2YW50YWdlcyBjYW4gaW5jbHVkZSBzaGFycGVyIGltYWdlIHF1YWxpdHkgKGxpa2UgdGV4dCkgYW5kIGZhc3RlciByZW5kZXJpbmcgb24gY2FudmFzLlxuICAgICAqIFRoZSBtYWluIGRpc2FkdmFudGFnZSBpcyBtb3ZlbWVudCBvZiBvYmplY3RzIG1heSBhcHBlYXIgbGVzcyBzbW9vdGguXG4gICAgICogVG8gc2V0IHRoZSBnbG9iYWwgZGVmYXVsdCwgY2hhbmdlIHtAbGluayBQSVhJLnNldHRpbmdzLlJPVU5EX1BJWEVMU31cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKi9cbiAgICBzZXQgcm91bmRQaXhlbHModmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuX3JvdW5kUGl4ZWxzICE9PSB2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fdHJhbnNmb3JtSUQgPSAtMTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9yb3VuZFBpeGVscyA9IHZhbHVlO1xuICAgIH1cbiAgICA7XG4gICAgZ2V0IHJvdW5kUGl4ZWxzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcm91bmRQaXhlbHM7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBUaGUgd2lkdGggb2YgdGhlIHNwcml0ZSwgc2V0dGluZyB0aGlzIHdpbGwgYWN0dWFsbHkgbW9kaWZ5IHRoZSBzY2FsZSB0byBhY2hpZXZlIHRoZSB2YWx1ZSBzZXRcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgd2lkdGgoKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmFicyh0aGlzLnNjYWxlLngpICogdGhpcy5fdGV4dHVyZS5vcmlnLndpZHRoO1xuICAgIH1cbiAgICA7XG4gICAgc2V0IHdpZHRoKHZhbHVlKSB7XG4gICAgICAgIHZhciBzID0gTWF0aFNldHRpbmdzXzEuTWF0aFNldHRpbmdzLnNpZ24odGhpcy5zY2FsZS54KSB8fCAxO1xuICAgICAgICB0aGlzLnNjYWxlLnggPSBzICogdmFsdWUgLyB0aGlzLl90ZXh0dXJlLm9yaWcud2lkdGg7XG4gICAgICAgIHRoaXMuX3dpZHRoID0gdmFsdWU7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBUaGUgaGVpZ2h0IG9mIHRoZSBzcHJpdGUsIHNldHRpbmcgdGhpcyB3aWxsIGFjdHVhbGx5IG1vZGlmeSB0aGUgc2NhbGUgdG8gYWNoaWV2ZSB0aGUgdmFsdWUgc2V0XG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICovXG4gICAgZ2V0IGhlaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguYWJzKHRoaXMuc2NhbGUueSkgKiB0aGlzLl90ZXh0dXJlLm9yaWcuaGVpZ2h0O1xuICAgIH1cbiAgICA7XG4gICAgc2V0IGhlaWdodCh2YWx1ZSkge1xuICAgICAgICB2YXIgcyA9IE1hdGhTZXR0aW5nc18xLk1hdGhTZXR0aW5ncy5zaWduKHRoaXMuc2NhbGUueSkgfHwgMTtcbiAgICAgICAgdGhpcy5zY2FsZS55ID0gcyAqIHZhbHVlIC8gdGhpcy5fdGV4dHVyZS5vcmlnLmhlaWdodDtcbiAgICAgICAgdGhpcy5faGVpZ2h0ID0gdmFsdWU7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBUaGUgYW5jaG9yIHNldHMgdGhlIG9yaWdpbiBwb2ludCBvZiB0aGUgdGV4dC4gVGhlIGRlZmF1bHQgdmFsdWUgaXMgdGFrZW4gZnJvbSB0aGUge0BsaW5rIFBJWEkuVGV4dHVyZXxUZXh0dXJlfVxuICAgICAqIGFuZCBwYXNzZWQgdG8gdGhlIGNvbnN0cnVjdG9yLlxuICAgICAqXG4gICAgICogVGhlIGRlZmF1bHQgaXMgYCgwLDApYCwgdGhpcyBtZWFucyB0aGUgdGV4dCdzIG9yaWdpbiBpcyB0aGUgdG9wIGxlZnQuXG4gICAgICpcbiAgICAgKiBTZXR0aW5nIHRoZSBhbmNob3IgdG8gYCgwLjUsMC41KWAgbWVhbnMgdGhlIHRleHQncyBvcmlnaW4gaXMgY2VudGVyZWQuXG4gICAgICpcbiAgICAgKiBTZXR0aW5nIHRoZSBhbmNob3IgdG8gYCgxLDEpYCB3b3VsZCBtZWFuIHRoZSB0ZXh0J3Mgb3JpZ2luIHBvaW50IHdpbGwgYmUgdGhlIGJvdHRvbSByaWdodCBjb3JuZXIuXG4gICAgICpcbiAgICAgKiBJZiB5b3UgcGFzcyBvbmx5IHNpbmdsZSBwYXJhbWV0ZXIsIGl0IHdpbGwgc2V0IGJvdGggeCBhbmQgeSB0byB0aGUgc2FtZSB2YWx1ZSBhcyBzaG93biBpbiB0aGUgZXhhbXBsZSBiZWxvdy5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogY29uc3Qgc3ByaXRlID0gbmV3IFBJWEkuU3ByaXRlKHRleHR1cmUpO1xuICAgICAqIHNwcml0ZS5hbmNob3Iuc2V0KDAuNSk7IC8vIFRoaXMgd2lsbCBzZXQgdGhlIG9yaWdpbiB0byBjZW50ZXIuICgwLjUpIGlzIHNhbWUgYXMgKDAuNSwgMC41KS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge1BJWEkuT2JzZXJ2YWJsZVBvaW50fVxuICAgICAqL1xuICAgIGdldCBhbmNob3IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hbmNob3I7XG4gICAgfVxuICAgIDtcbiAgICBzZXQgYW5jaG9yKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2FuY2hvci5jb3B5RnJvbSh2YWx1ZSk7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBUaGUgdGludCBhcHBsaWVkIHRvIHRoZSBzcHJpdGUuIFRoaXMgaXMgYSBoZXggdmFsdWUuXG4gICAgICogQSB2YWx1ZSBvZiAweEZGRkZGRiB3aWxsIHJlbW92ZSBhbnkgdGludCBlZmZlY3QuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMHhGRkZGRkZcbiAgICAgKi9cbiAgICBnZXQgdGludCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RpbnQ7XG4gICAgfVxuICAgIDtcbiAgICBzZXQgdGludCh2YWx1ZSkge1xuICAgICAgICB0aGlzLl90aW50ID0gdmFsdWU7XG4gICAgICAgIHRoaXMuX3RpbnRSR0IgPSAodmFsdWUgPj4gMTYpICsgKHZhbHVlICYgMHhmZjAwKSArICgodmFsdWUgJiAweGZmKSA8PCAxNik7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBUaGUgdGV4dHVyZSB0aGF0IHRoZSBzcHJpdGUgaXMgdXNpbmdcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge1BJWEkuVGV4dHVyZX1cbiAgICAgKi9cbiAgICBnZXQgdGV4dHVyZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RleHR1cmU7XG4gICAgfVxuICAgIDtcbiAgICBzZXQgdGV4dHVyZSh2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5fdGV4dHVyZSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl90ZXh0dXJlID0gdmFsdWUgfHwgVGV4dHVyZV8xLlRleHR1cmUuRU1QVFk7XG4gICAgICAgIHRoaXMuY2FjaGVkVGludCA9IDB4RkZGRkZGO1xuICAgICAgICB0aGlzLl90ZXh0dXJlSUQgPSAtMTtcbiAgICAgICAgdGhpcy5fdGV4dHVyZVRyaW1tZWRJRCA9IC0xO1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIC8vIHdhaXQgZm9yIHRoZSB0ZXh0dXJlIHRvIGxvYWRcbiAgICAgICAgICAgIGlmICh2YWx1ZS5iYXNlVGV4dHVyZS52YWxpZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX29uVGV4dHVyZVVwZGF0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFsdWUuYWRkRXZlbnRMaXN0ZW5lcigndXBkYXRlJywgdGhpcy5fb25UZXh0dXJlVXBkYXRlKTtcbiAgICAgICAgICAgICAgICAvLyB2YWx1ZS5vbmNlKCd1cGRhdGUnLCB0aGlzLl9vblRleHR1cmVVcGRhdGUsIHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIDtcbn1cblNwcml0ZS5pbmRpY2VzID0gbmV3IFVpbnQxNkFycmF5KFswLCAxLCAyLCAwLCAyLCAzXSk7XG4vLyBzb21lIGhlbHBlciBmdW5jdGlvbnMuLlxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdGhhdCBjcmVhdGVzIGEgbmV3IHNwcml0ZSBiYXNlZCBvbiB0aGUgc291cmNlIHlvdSBwcm92aWRlLlxuICogVGhlIHNvdXJjZSBjYW4gYmUgLSBmcmFtZSBpZCwgaW1hZ2UgdXJsLCB2aWRlbyB1cmwsIGNhbnZhcyBlbGVtZW50LCB2aWRlbyBlbGVtZW50LCBiYXNlIHRleHR1cmVcbiAqXG4gKiBAc3RhdGljXG4gKiBAcGFyYW0ge251bWJlcnxzdHJpbmd8UElYSS5UZXh0dXJlfEhUTUxDYW52YXNFbGVtZW50fEhUTUxWaWRlb0VsZW1lbnR9IHNvdXJjZSBTb3VyY2UgdG8gY3JlYXRlIHRleHR1cmUgZnJvbVxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSBTZWUge0BsaW5rIFBJWEkuQmFzZVRleHR1cmV9J3MgY29uc3RydWN0b3IgZm9yIG9wdGlvbnMuXG4gKiBAcmV0dXJuIHtQSVhJLlNwcml0ZX0gVGhlIG5ld2x5IGNyZWF0ZWQgc3ByaXRlXG4gKi9cblNwcml0ZS5mcm9tID0gZnVuY3Rpb24gZnJvbShzb3VyY2UsIG9wdGlvbnMgPSB7fSkge1xuICAgIGlmIChvcHRpb25zID09IG51bGwpIHtcbiAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cbiAgICB2YXIgdGV4dHVyZSA9IChzb3VyY2UgaW5zdGFuY2VvZiBUZXh0dXJlXzEuVGV4dHVyZSlcbiAgICAgICAgPyBzb3VyY2VcbiAgICAgICAgOiBUZXh0dXJlXzEuVGV4dHVyZS5mcm9tKHNvdXJjZSwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIG5ldyBTcHJpdGUodGV4dHVyZSk7XG59O1xuZXhwb3J0cy5TcHJpdGUgPSBTcHJpdGU7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IEZpbHRlcl8xID0gcmVxdWlyZShcIi4vRmlsdGVyXCIpO1xuY29uc3QgTWF0cml4XzEgPSByZXF1aXJlKFwiLi9NYXRyaXhcIik7XG5jb25zdCBUZXh0dXJlTWF0cml4XzEgPSByZXF1aXJlKFwiLi9UZXh0dXJlTWF0cml4XCIpO1xuY2xhc3MgU3ByaXRlTWFza0ZpbHRlciBleHRlbmRzIEZpbHRlcl8xLkZpbHRlciB7XG4gICAgY29uc3RydWN0b3Ioc3ByaXRlKSB7XG4gICAgICAgIHZhciBtYXNrTWF0cml4ID0gbmV3IE1hdHJpeF8xLk1hdHJpeCgpO1xuICAgICAgICBzdXBlcihTcHJpdGVNYXNrRmlsdGVyLnZlcnRleCwgU3ByaXRlTWFza0ZpbHRlci5mcmFnbWVudCk7XG4gICAgICAgIHNwcml0ZS5yZW5kZXJhYmxlID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcHJpdGUgbWFza1xuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLlNwcml0ZX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubWFza1Nwcml0ZSA9IHNwcml0ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1hc2sgbWF0cml4XG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuTWF0cml4fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tYXNrTWF0cml4ID0gbWFza01hdHJpeDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXBwbGllcyB0aGUgZmlsdGVyXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BJWEkuc3lzdGVtcy5GaWx0ZXJTeXN0ZW19IGZpbHRlck1hbmFnZXIgLSBUaGUgcmVuZGVyZXIgdG8gcmV0cmlldmUgdGhlIGZpbHRlciBmcm9tXG4gICAgICogQHBhcmFtIHtQSVhJLlJlbmRlclRleHR1cmV9IGlucHV0IC0gVGhlIGlucHV0IHJlbmRlciB0YXJnZXQuXG4gICAgICogQHBhcmFtIHtQSVhJLlJlbmRlclRleHR1cmV9IG91dHB1dCAtIFRoZSB0YXJnZXQgdG8gb3V0cHV0IHRvLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gY2xlYXIgLSBTaG91bGQgdGhlIG91dHB1dCBiZSBjbGVhcmVkIGJlZm9yZSByZW5kZXJpbmcgdG8gaXQuXG4gICAgICovXG4gICAgYXBwbHkoZmlsdGVyTWFuYWdlciwgaW5wdXQsIG91dHB1dCwgY2xlYXIpIHtcbiAgICAgICAgdmFyIG1hc2tTcHJpdGUgPSB0aGlzLm1hc2tTcHJpdGU7XG4gICAgICAgIHZhciB0ZXggPSB0aGlzLm1hc2tTcHJpdGUudGV4dHVyZTtcbiAgICAgICAgaWYgKCF0ZXgudmFsaWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRleC50cmFuc2Zvcm0pIHtcbiAgICAgICAgICAgIC8vIG1hcmdpbiA9IDAuMCwgbGV0IGl0IGJsZWVkIGEgYml0LCBzaGFkZXIgY29kZSBiZWNvbWVzIGVhc2llclxuICAgICAgICAgICAgLy8gYXNzdW1pbmcgdGhhdCBhdGxhcyB0ZXh0dXJlcyB3ZXJlIG1hZGUgd2l0aCAxLXBpeGVsIHBhZGRpbmdcbiAgICAgICAgICAgIHRleC50cmFuc2Zvcm0gPSBuZXcgVGV4dHVyZU1hdHJpeF8xLlRleHR1cmVNYXRyaXgodGV4LCAwLjApO1xuICAgICAgICB9XG4gICAgICAgIHRleC50cmFuc2Zvcm0udXBkYXRlKCk7XG4gICAgICAgIHRoaXMudW5pZm9ybXMubnBtQWxwaGEgPSB0ZXguYmFzZVRleHR1cmUucHJlbXVsdGlwbHlBbHBoYSA/IDAuMCA6IDEuMDtcbiAgICAgICAgdGhpcy51bmlmb3Jtcy5tYXNrID0gdGV4O1xuICAgICAgICB0aGlzLnVuaWZvcm1zLm90aGVyTWF0cml4ID0gZmlsdGVyTWFuYWdlci5jYWxjdWxhdGVTcHJpdGVNYXRyaXgodGhpcy5tYXNrTWF0cml4LCBtYXNrU3ByaXRlKVxuICAgICAgICAgICAgLnByZXBlbmQodGV4LnRyYW5zZm9ybS5tYXBDb29yZCk7XG4gICAgICAgIHRoaXMudW5pZm9ybXMuYWxwaGEgPSBtYXNrU3ByaXRlLndvcmxkQWxwaGE7XG4gICAgICAgIHRoaXMudW5pZm9ybXMubWFza0NsYW1wID0gdGV4LnRyYW5zZm9ybS51Q2xhbXBGcmFtZTtcbiAgICAgICAgZmlsdGVyTWFuYWdlci5hcHBseUZpbHRlcih0aGlzLCBpbnB1dCwgb3V0cHV0LCBjbGVhcik7XG4gICAgfVxuICAgIDtcbn1cblNwcml0ZU1hc2tGaWx0ZXIudmVydGV4ID0gXCJhdHRyaWJ1dGUgdmVjMiBhVmVydGV4UG9zaXRpb247XFxyXFxuYXR0cmlidXRlIHZlYzIgYVRleHR1cmVDb29yZDtcXHJcXG5cXHJcXG51bmlmb3JtIG1hdDMgcHJvamVjdGlvbk1hdHJpeDtcXHJcXG51bmlmb3JtIG1hdDMgb3RoZXJNYXRyaXg7XFxyXFxuXFxyXFxudmFyeWluZyB2ZWMyIHZNYXNrQ29vcmQ7XFxyXFxudmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XFxyXFxuXFxyXFxudm9pZCBtYWluKHZvaWQpXFxyXFxue1xcclxcbiAgICBnbF9Qb3NpdGlvbiA9IHZlYzQoKHByb2plY3Rpb25NYXRyaXggKiB2ZWMzKGFWZXJ0ZXhQb3NpdGlvbiwgMS4wKSkueHksIDAuMCwgMS4wKTtcXHJcXG5cXHJcXG4gICAgdlRleHR1cmVDb29yZCA9IGFUZXh0dXJlQ29vcmQ7XFxyXFxuICAgIHZNYXNrQ29vcmQgPSAoIG90aGVyTWF0cml4ICogdmVjMyggYVRleHR1cmVDb29yZCwgMS4wKSAgKS54eTtcXHJcXG59XFxyXFxuXCI7XG5TcHJpdGVNYXNrRmlsdGVyLmZyYWdtZW50ID0gXCJ2YXJ5aW5nIHZlYzIgdk1hc2tDb29yZDtcXHJcXG52YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXHJcXG5cXHJcXG51bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjtcXHJcXG51bmlmb3JtIHNhbXBsZXIyRCBtYXNrO1xcclxcbnVuaWZvcm0gZmxvYXQgYWxwaGE7XFxyXFxudW5pZm9ybSBmbG9hdCBucG1BbHBoYTtcXHJcXG51bmlmb3JtIHZlYzQgbWFza0NsYW1wO1xcclxcblxcclxcbnZvaWQgbWFpbih2b2lkKVxcclxcbntcXHJcXG4gICAgZmxvYXQgY2xpcCA9IHN0ZXAoMy41LFxcclxcbiAgICAgICAgc3RlcChtYXNrQ2xhbXAueCwgdk1hc2tDb29yZC54KSArXFxyXFxuICAgICAgICBzdGVwKG1hc2tDbGFtcC55LCB2TWFza0Nvb3JkLnkpICtcXHJcXG4gICAgICAgIHN0ZXAodk1hc2tDb29yZC54LCBtYXNrQ2xhbXAueikgK1xcclxcbiAgICAgICAgc3RlcCh2TWFza0Nvb3JkLnksIG1hc2tDbGFtcC53KSk7XFxyXFxuXFxyXFxuICAgIHZlYzQgb3JpZ2luYWwgPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZUZXh0dXJlQ29vcmQpO1xcclxcbiAgICB2ZWM0IG1hc2t5ID0gdGV4dHVyZTJEKG1hc2ssIHZNYXNrQ29vcmQpO1xcclxcbiAgICBmbG9hdCBhbHBoYU11bCA9IDEuMCAtIG5wbUFscGhhICogKDEuMCAtIG1hc2t5LmEpO1xcclxcblxcclxcbiAgICBvcmlnaW5hbCAqPSAoYWxwaGFNdWwgKiBtYXNreS5yICogYWxwaGEgKiBjbGlwKTtcXHJcXG5cXHJcXG4gICAgZ2xfRnJhZ0NvbG9yID0gb3JpZ2luYWw7XFxyXFxufVxcclxcblwiO1xuZXhwb3J0cy5TcHJpdGVNYXNrRmlsdGVyID0gU3ByaXRlTWFza0ZpbHRlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgUmVjdGFuZ2xlXzEgPSByZXF1aXJlKFwiLi4vZmxhc2gvZ2VvbS9SZWN0YW5nbGVcIik7XG5jb25zdCBUZXh0dXJlXzEgPSByZXF1aXJlKFwiLi9UZXh0dXJlXCIpO1xuY29uc3QgTmV0d29ya1NldHRpbmdzXzEgPSByZXF1aXJlKFwiLi9OZXR3b3JrU2V0dGluZ3NcIik7XG5jb25zdCBJbnN0YW5jZUNvdW50ZXJfMSA9IHJlcXVpcmUoXCIuL0luc3RhbmNlQ291bnRlclwiKTtcbmNvbnN0IEZsYXNoQmFzZU9iamVjdF8xID0gcmVxdWlyZShcIi4vRmxhc2hCYXNlT2JqZWN0XCIpO1xuY2xhc3MgU3ByaXRlc2hlZXQgZXh0ZW5kcyBGbGFzaEJhc2VPYmplY3RfMS5GbGFzaEJhc2VPYmplY3Qge1xuICAgIGNvbnN0cnVjdG9yKGJhc2VUZXh0dXJlLCBkYXRhLCByZXNvbHV0aW9uRmlsZW5hbWUgPSBudWxsKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWZlcmVuY2UgdG8gdGhzIHNvdXJjZSB0ZXh0dXJlXG4gICAgICAgICAqIEB0eXBlIHtQSVhJLkJhc2VUZXh0dXJlfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5iYXNlVGV4dHVyZSA9IGJhc2VUZXh0dXJlO1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBtYXAgY29udGFpbmluZyBhbGwgdGV4dHVyZXMgb2YgdGhlIHNwcml0ZSBzaGVldC5cbiAgICAgICAgICogQ2FuIGJlIHVzZWQgdG8gY3JlYXRlIGEge0BsaW5rIFBJWEkuU3ByaXRlfFNwcml0ZX06XG4gICAgICAgICAqIGBgYGpzXG4gICAgICAgICAqIG5ldyBQSVhJLlNwcml0ZShzaGVldC50ZXh0dXJlc1tcImltYWdlLnBuZ1wiXSk7XG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRleHR1cmVzID0ge307XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIG1hcCBjb250YWluaW5nIHRoZSB0ZXh0dXJlcyBmb3IgZWFjaCBhbmltYXRpb24uXG4gICAgICAgICAqIENhbiBiZSB1c2VkIHRvIGNyZWF0ZSBhbiB7QGxpbmsgUElYSS5BbmltYXRlZFNwcml0ZXxBbmltYXRlZFNwcml0ZX06XG4gICAgICAgICAqIGBgYGpzXG4gICAgICAgICAqIG5ldyBQSVhJLkFuaW1hdGVkU3ByaXRlKHNoZWV0LmFuaW1hdGlvbnNbXCJhbmltX25hbWVcIl0pXG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKiBAbWVtYmVyIHtPYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmFuaW1hdGlvbnMgPSB7fTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlZmVyZW5jZSB0byB0aGUgb3JpZ2luYWwgSlNPTiBkYXRhLlxuICAgICAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSByZXNvbHV0aW9uIG9mIHRoZSBzcHJpdGVzaGVldC5cbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVzb2x1dGlvbiA9IHRoaXMuX3VwZGF0ZVJlc29sdXRpb24ocmVzb2x1dGlvbkZpbGVuYW1lXG4gICAgICAgICAgICB8fCAodGhpcy5iYXNlVGV4dHVyZS5yZXNvdXJjZSA/IHRoaXMuYmFzZVRleHR1cmUucmVzb3VyY2UudXJsIDogbnVsbCkpO1xuICAgICAgICAvKipcbiAgICAgICAgICogTWFwIG9mIHNwcml0ZXNoZWV0IGZyYW1lcy5cbiAgICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2ZyYW1lcyA9IHRoaXMuZGF0YS5mcmFtZXM7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb2xsZWN0aW9uIG9mIGZyYW1lIG5hbWVzLlxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nW119XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9mcmFtZUtleXMgPSBPYmplY3Qua2V5cyh0aGlzLl9mcmFtZXMpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3VycmVudCBiYXRjaCBpbmRleCBiZWluZyBwcm9jZXNzZWQuXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9iYXRjaEluZGV4ID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbGxiYWNrIHdoZW4gcGFyc2UgaXMgY29tcGxldGVkLlxuICAgICAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9jYWxsYmFjayA9IG51bGw7XG4gICAgfVxuICAgIF91cGRhdGVSZXNvbHV0aW9uKHJlc29sdXRpb25GaWxlbmFtZSkge1xuICAgICAgICB2YXIgc2NhbGUgPSB0aGlzLmRhdGEubWV0YS5zY2FsZTtcbiAgICAgICAgLy8gVXNlIGEgZGVmYXVsdFZhbHVlIG9mIGBudWxsYCB0byBjaGVjayBpZiBhIHVybC1iYXNlZCByZXNvbHV0aW9uIGlzIHNldFxuICAgICAgICB2YXIgcmVzb2x1dGlvbiA9IE5ldHdvcmtTZXR0aW5nc18xLk5ldHdvcmtTZXR0aW5ncy5nZXRSZXNvbHV0aW9uT2ZVcmwocmVzb2x1dGlvbkZpbGVuYW1lLCBudWxsKTtcbiAgICAgICAgLy8gTm8gcmVzb2x1dGlvbiBmb3VuZCB2aWEgVVJMXG4gICAgICAgIGlmIChyZXNvbHV0aW9uID09PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBVc2UgdGhlIHNjYWxlIHZhbHVlIG9yIGRlZmF1bHQgdG8gMVxuICAgICAgICAgICAgcmVzb2x1dGlvbiA9IHNjYWxlICE9PSB1bmRlZmluZWQgPyBwYXJzZUZsb2F0KHNjYWxlKSA6IDE7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRm9yIG5vbi0xIHJlc29sdXRpb25zLCB1cGRhdGUgYmFzZVRleHR1cmVcbiAgICAgICAgaWYgKHJlc29sdXRpb24gIT09IDEpIHtcbiAgICAgICAgICAgIHRoaXMuYmFzZVRleHR1cmUuc2V0UmVzb2x1dGlvbihyZXNvbHV0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzb2x1dGlvbjtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlIHRoZSByZXNvbHV0aW9uIGZyb20gdGhlIGZpbGVuYW1lIG9yIGZhbGxiYWNrXG4gICAgICogdG8gdGhlIG1ldGEuc2NhbGUgZmllbGQgb2YgdGhlIEpTT04gZGF0YS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHJlc29sdXRpb25GaWxlbmFtZSAtIFRoZSBmaWxlbmFtZSB0byB1c2UgZm9yIHJlc29sdmluZ1xuICAgICAqICAgIHRoZSBkZWZhdWx0IHJlc29sdXRpb24uXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBSZXNvbHV0aW9uIHRvIHVzZSBmb3Igc3ByaXRlc2hlZXQuXG4gICAgICovXG4gICAgc3RhdGljIGdldCBCQVRDSF9TSVpFKCkge1xuICAgICAgICByZXR1cm4gMTAwMDtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFBhcnNlciBzcHJpdGVzaGVldCBmcm9tIGxvYWRlZCBkYXRhLiBUaGlzIGlzIGRvbmUgYXN5bmNocm9ub3VzbHlcbiAgICAgKiB0byBwcmV2ZW50IGNyZWF0aW5nIHRvbyBtYW55IFRleHR1cmUgd2l0aGluIGEgc2luZ2xlIHByb2Nlc3MuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtIENhbGxiYWNrIHdoZW4gY29tcGxldGUgcmV0dXJuc1xuICAgICAqICAgIGEgbWFwIG9mIHRoZSBUZXh0dXJlcyBmb3IgdGhpcyBzcHJpdGVzaGVldC5cbiAgICAgKi9cbiAgICBwYXJzZShjYWxsYmFjaykge1xuICAgICAgICB0aGlzLl9iYXRjaEluZGV4ID0gMDtcbiAgICAgICAgdGhpcy5fY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICAgICAgaWYgKHRoaXMuX2ZyYW1lS2V5cy5sZW5ndGggPD0gU3ByaXRlc2hlZXQuQkFUQ0hfU0laRSkge1xuICAgICAgICAgICAgdGhpcy5fcHJvY2Vzc0ZyYW1lcygwKTtcbiAgICAgICAgICAgIHRoaXMuX3Byb2Nlc3NBbmltYXRpb25zKCk7XG4gICAgICAgICAgICB0aGlzLl9wYXJzZUNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9uZXh0QmF0Y2goKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogUHJvY2VzcyBhIGJhdGNoIG9mIGZyYW1lc1xuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5pdGlhbEZyYW1lSW5kZXggLSBUaGUgaW5kZXggb2YgZnJhbWUgdG8gc3RhcnQuXG4gICAgICovXG4gICAgX3Byb2Nlc3NGcmFtZXMoaW5pdGlhbEZyYW1lSW5kZXgpIHtcbiAgICAgICAgdmFyIGZyYW1lSW5kZXggPSBpbml0aWFsRnJhbWVJbmRleDtcbiAgICAgICAgdmFyIG1heEZyYW1lcyA9IFNwcml0ZXNoZWV0LkJBVENIX1NJWkU7XG4gICAgICAgIHdoaWxlIChmcmFtZUluZGV4IC0gaW5pdGlhbEZyYW1lSW5kZXggPCBtYXhGcmFtZXMgJiYgZnJhbWVJbmRleCA8IHRoaXMuX2ZyYW1lS2V5cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBpID0gdGhpcy5fZnJhbWVLZXlzW2ZyYW1lSW5kZXhdO1xuICAgICAgICAgICAgdmFyIGRhdGEgPSB0aGlzLl9mcmFtZXNbaV07XG4gICAgICAgICAgICB2YXIgcmVjdCA9IGRhdGEuZnJhbWU7XG4gICAgICAgICAgICBpZiAocmVjdCkge1xuICAgICAgICAgICAgICAgIHZhciBmcmFtZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgdmFyIHRyaW0gPSBudWxsO1xuICAgICAgICAgICAgICAgIHZhciBzb3VyY2VTaXplID0gZGF0YS50cmltbWVkICE9PSBmYWxzZSAmJiBkYXRhLnNvdXJjZVNpemUgPyBkYXRhLnNvdXJjZVNpemUgOiBkYXRhLmZyYW1lO1xuICAgICAgICAgICAgICAgIEluc3RhbmNlQ291bnRlcl8xLkluc3RhbmNlQ291bnRlci5hZGRDYWxsKFwiUmVjdGFuZ2xlLmdldFJlY3RhbmdsZVwiLCBcIlNwcml0ZVNoZWV0IF9wcm9jZXNzRnJhbWVzXCIpO1xuICAgICAgICAgICAgICAgIHZhciBvcmlnID0gUmVjdGFuZ2xlXzEuUmVjdGFuZ2xlLmdldFJlY3RhbmdsZSgwLCAwLCBNYXRoLmZsb29yKHNvdXJjZVNpemUudykgLyB0aGlzLnJlc29sdXRpb24sIE1hdGguZmxvb3Ioc291cmNlU2l6ZS5oKSAvIHRoaXMucmVzb2x1dGlvbik7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGEucm90YXRlZCkge1xuICAgICAgICAgICAgICAgICAgICBJbnN0YW5jZUNvdW50ZXJfMS5JbnN0YW5jZUNvdW50ZXIuYWRkQ2FsbChcIlJlY3RhbmdsZS5nZXRSZWN0YW5nbGVcIiwgXCJTcHJpdGVTaGVldCBfcHJvY2Vzc0ZyYW1lc1wiKTtcbiAgICAgICAgICAgICAgICAgICAgZnJhbWUgPSBSZWN0YW5nbGVfMS5SZWN0YW5nbGUuZ2V0UmVjdGFuZ2xlKE1hdGguZmxvb3IocmVjdC54KSAvIHRoaXMucmVzb2x1dGlvbiwgTWF0aC5mbG9vcihyZWN0LnkpIC8gdGhpcy5yZXNvbHV0aW9uLCBNYXRoLmZsb29yKHJlY3QuaCkgLyB0aGlzLnJlc29sdXRpb24sIE1hdGguZmxvb3IocmVjdC53KSAvIHRoaXMucmVzb2x1dGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBJbnN0YW5jZUNvdW50ZXJfMS5JbnN0YW5jZUNvdW50ZXIuYWRkQ2FsbChcIlJlY3RhbmdsZS5nZXRSZWN0YW5nbGVcIiwgXCJTcHJpdGVTaGVldCBfcHJvY2Vzc0ZyYW1lc1wiKTtcbiAgICAgICAgICAgICAgICAgICAgZnJhbWUgPSBSZWN0YW5nbGVfMS5SZWN0YW5nbGUuZ2V0UmVjdGFuZ2xlKE1hdGguZmxvb3IocmVjdC54KSAvIHRoaXMucmVzb2x1dGlvbiwgTWF0aC5mbG9vcihyZWN0LnkpIC8gdGhpcy5yZXNvbHV0aW9uLCBNYXRoLmZsb29yKHJlY3QudykgLyB0aGlzLnJlc29sdXRpb24sIE1hdGguZmxvb3IocmVjdC5oKSAvIHRoaXMucmVzb2x1dGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vICBDaGVjayB0byBzZWUgaWYgdGhlIHNwcml0ZSBpcyB0cmltbWVkXG4gICAgICAgICAgICAgICAgaWYgKGRhdGEudHJpbW1lZCAhPT0gZmFsc2UgJiYgZGF0YS5zcHJpdGVTb3VyY2VTaXplKSB7XG4gICAgICAgICAgICAgICAgICAgIEluc3RhbmNlQ291bnRlcl8xLkluc3RhbmNlQ291bnRlci5hZGRDYWxsKFwiUmVjdGFuZ2xlLmdldFJlY3RhbmdsZVwiLCBcIlNwcml0ZVNoZWV0IF9wcm9jZXNzRnJhbWVzXCIpO1xuICAgICAgICAgICAgICAgICAgICB0cmltID0gUmVjdGFuZ2xlXzEuUmVjdGFuZ2xlLmdldFJlY3RhbmdsZShNYXRoLmZsb29yKGRhdGEuc3ByaXRlU291cmNlU2l6ZS54KSAvIHRoaXMucmVzb2x1dGlvbiwgTWF0aC5mbG9vcihkYXRhLnNwcml0ZVNvdXJjZVNpemUueSkgLyB0aGlzLnJlc29sdXRpb24sIE1hdGguZmxvb3IocmVjdC53KSAvIHRoaXMucmVzb2x1dGlvbiwgTWF0aC5mbG9vcihyZWN0LmgpIC8gdGhpcy5yZXNvbHV0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy50ZXh0dXJlc1tpXSA9IG5ldyBUZXh0dXJlXzEuVGV4dHVyZSh0aGlzLmJhc2VUZXh0dXJlLCBmcmFtZSwgb3JpZywgdHJpbSwgZGF0YS5yb3RhdGVkID8gMiA6IDAsIGRhdGEuYW5jaG9yKTtcbiAgICAgICAgICAgICAgICAvLyBsZXRzIGFsc28gYWRkIHRoZSBmcmFtZSB0byBwaXhpJ3MgZ2xvYmFsIGNhY2hlIGZvciBmcm9tRnJhbWUgYW5kIGZyb21JbWFnZSBmdW5jdGlvbnNcbiAgICAgICAgICAgICAgICBUZXh0dXJlXzEuVGV4dHVyZS5hZGRUb0NhY2hlKHRoaXMudGV4dHVyZXNbaV0sIGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnJhbWVJbmRleCsrO1xuICAgICAgICB9XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBQYXJzZSBhbmltYXRpb25zIGNvbmZpZ1xuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcHJvY2Vzc0FuaW1hdGlvbnMoKSB7XG4gICAgICAgIHZhciBhbmltYXRpb25zID0gdGhpcy5kYXRhLmFuaW1hdGlvbnMgfHwge307XG4gICAgICAgIGZvciAodmFyIGFuaW1OYW1lIGluIGFuaW1hdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9uc1thbmltTmFtZV0gPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYW5pbWF0aW9uc1thbmltTmFtZV0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgZnJhbWVOYW1lID0gYW5pbWF0aW9uc1thbmltTmFtZV1baV07XG4gICAgICAgICAgICAgICAgdGhpcy5hbmltYXRpb25zW2FuaW1OYW1lXS5wdXNoKHRoaXMudGV4dHVyZXNbZnJhbWVOYW1lXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFRoZSBwYXJzZSBoYXMgY29tcGxldGVkLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcGFyc2VDb21wbGV0ZSgpIHtcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gdGhpcy5fY2FsbGJhY2s7XG4gICAgICAgIHRoaXMuX2NhbGxiYWNrID0gbnVsbDtcbiAgICAgICAgdGhpcy5fYmF0Y2hJbmRleCA9IDA7XG4gICAgICAgIGNhbGxiYWNrLmNhbGwodGhpcywgdGhpcy50ZXh0dXJlcyk7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBCZWdpbiB0aGUgbmV4dCBiYXRjaCBvZiB0ZXh0dXJlcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX25leHRCYXRjaCgpIHtcbiAgICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG4gICAgICAgIHRoaXMuX3Byb2Nlc3NGcmFtZXModGhpcy5fYmF0Y2hJbmRleCAqIFNwcml0ZXNoZWV0LkJBVENIX1NJWkUpO1xuICAgICAgICB0aGlzLl9iYXRjaEluZGV4Kys7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMkMS5fYmF0Y2hJbmRleCAqIFNwcml0ZXNoZWV0LkJBVENIX1NJWkUgPCB0aGlzJDEuX2ZyYW1lS2V5cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzJDEuX25leHRCYXRjaCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcyQxLl9wcm9jZXNzQW5pbWF0aW9ucygpO1xuICAgICAgICAgICAgICAgIHRoaXMkMS5fcGFyc2VDb21wbGV0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCAwKTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIERlc3Ryb3kgU3ByaXRlc2hlZXQgYW5kIGRvbid0IHVzZSBhZnRlciB0aGlzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZGVzdHJveUJhc2U9ZmFsc2VdIFdoZXRoZXIgdG8gZGVzdHJveSB0aGUgYmFzZSB0ZXh0dXJlIGFzIHdlbGxcbiAgICAgKi9cbiAgICBkZXN0cm95KGRlc3Ryb3lCYXNlKSB7XG4gICAgICAgIGlmIChkZXN0cm95QmFzZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBkZXN0cm95QmFzZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgaW4gdGhpcy50ZXh0dXJlcykge1xuICAgICAgICAgICAgdGhpcy50ZXh0dXJlc1tpXS5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZnJhbWVzID0gbnVsbDtcbiAgICAgICAgdGhpcy5fZnJhbWVLZXlzID0gbnVsbDtcbiAgICAgICAgdGhpcy5kYXRhID0gbnVsbDtcbiAgICAgICAgdGhpcy50ZXh0dXJlcyA9IG51bGw7XG4gICAgICAgIGlmIChkZXN0cm95QmFzZSkge1xuICAgICAgICAgICAgdGhpcy5iYXNlVGV4dHVyZS5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5iYXNlVGV4dHVyZSA9IG51bGw7XG4gICAgfVxuICAgIDtcbn1cbmV4cG9ydHMuU3ByaXRlc2hlZXQgPSBTcHJpdGVzaGVldDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY2xhc3MgU3RhZ2VPcHRpb25zIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5zaGFyZWRMb2FkZXIgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5mb3JjZUNhbnZhcyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnZpZXcgPSBudWxsO1xuICAgICAgICB0aGlzLmFudGlhbGlhcyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmZvcmNlRlhBQSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmF1dG9EZW5zaXR5ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5hdXRvUmVzaXplID0gdHJ1ZTtcbiAgICAgICAgdGhpcy50cmFuc3BhcmVudCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmJhY2tncm91bmRDb2xvciA9IDB4MDAwMDAwO1xuICAgICAgICB0aGlzLmNsZWFyQmVmb3JlUmVuZGVyID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5hdXRvU3RhcnQgPSB0cnVlO1xuICAgICAgICB0aGlzLnByZXNlcnZlRHJhd2luZ0J1ZmZlciA9IGZhbHNlO1xuICAgICAgICB0aGlzLndpZHRoID0gMTAyNDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSA3Njg7XG4gICAgICAgIHRoaXMucmVzb2x1dGlvbiA9IDE7XG4gICAgICAgIHRoaXMubGVnYWN5ID0gZmFsc2U7XG4gICAgICAgIHRoaXMucm91bmRQaXhlbHMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zaGFyZWRUaWNrZXIgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZXNpemVUbyA9IG51bGw7XG4gICAgICAgIHRoaXMucG93ZXJQcmVmZXJlbmNlID0gXCJoaWdoLXBlcmZvcm1hbmNlXCI7XG4gICAgfVxufVxuZXhwb3J0cy5TdGFnZU9wdGlvbnMgPSBTdGFnZU9wdGlvbnM7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IFBvbHlnb25fMSA9IHJlcXVpcmUoXCIuL1BvbHlnb25cIik7XG5jb25zdCBNYXRoU2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL01hdGhTZXR0aW5nc1wiKTtcbmNsYXNzIFN0YXIgZXh0ZW5kcyBQb2x5Z29uXzEuUG9seWdvbiB7XG4gICAgY29uc3RydWN0b3IoeCwgeSwgcG9pbnRzLCByYWRpdXMsIGlubmVyUmFkaXVzLCByb3RhdGlvbikge1xuICAgICAgICBpbm5lclJhZGl1cyA9IGlubmVyUmFkaXVzIHx8IHJhZGl1cyAvIDI7XG4gICAgICAgIHZhciBzdGFydEFuZ2xlID0gKC0xICogTWF0aC5QSSAvIDIpICsgcm90YXRpb247XG4gICAgICAgIHZhciBsZW4gPSBwb2ludHMgKiAyO1xuICAgICAgICB2YXIgZGVsdGEgPSBNYXRoU2V0dGluZ3NfMS5NYXRoU2V0dGluZ3MuUElfMiAvIGxlbjtcbiAgICAgICAgdmFyIHBvbHlnb24gPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdmFyIHIgPSBpICUgMiA/IGlubmVyUmFkaXVzIDogcmFkaXVzO1xuICAgICAgICAgICAgdmFyIGFuZ2xlID0gKGkgKiBkZWx0YSkgKyBzdGFydEFuZ2xlO1xuICAgICAgICAgICAgcG9seWdvbi5wdXNoKHggKyAociAqIE1hdGguY29zKGFuZ2xlKSksIHkgKyAociAqIE1hdGguc2luKGFuZ2xlKSkpO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyKHBvbHlnb24pO1xuICAgIH1cbn1cbmV4cG9ydHMuU3RhciA9IFN0YXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IEJsZW5kTW9kZXNTZXR0aW5nc18xID0gcmVxdWlyZShcIi4vQmxlbmRNb2Rlc1NldHRpbmdzXCIpO1xuY2xhc3MgU3RhdGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmRhdGEgPSAwO1xuICAgICAgICB0aGlzLmJsZW5kTW9kZSA9IEJsZW5kTW9kZXNTZXR0aW5nc18xLkJsZW5kTW9kZXNTZXR0aW5ncy5CTEVORF9NT0RFUy5OT1JNQUw7XG4gICAgICAgIHRoaXMucG9seWdvbk9mZnNldCA9IDA7XG4gICAgICAgIHRoaXMuYmxlbmQgPSB0cnVlO1xuICAgICAgICAvLyAgdGhpcy5kZXB0aFRlc3QgPSB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBY3RpdmF0ZXMgYmxlbmRpbmcgb2YgdGhlIGNvbXB1dGVkIGZyYWdtZW50IGNvbG9yIHZhbHVlc1xuICAgICAqXG4gICAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBnZXQgYmxlbmQoKSB7XG4gICAgICAgIHJldHVybiAhISh0aGlzLmRhdGEgJiAoMSA8PCBTdGF0ZS5CTEVORCkpO1xuICAgIH1cbiAgICA7XG4gICAgc2V0IGJsZW5kKHZhbHVlKSB7XG4gICAgICAgIGlmICghISh0aGlzLmRhdGEgJiAoMSA8PCBTdGF0ZS5CTEVORCkpICE9PSB2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5kYXRhIF49ICgxIDw8IFN0YXRlLkJMRU5EKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogQWN0aXZhdGVzIGFkZGluZyBhbiBvZmZzZXQgdG8gZGVwdGggdmFsdWVzIG9mIHBvbHlnb24ncyBmcmFnbWVudHNcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKi9cbiAgICBnZXQgb2Zmc2V0cygpIHtcbiAgICAgICAgcmV0dXJuICEhKHRoaXMuZGF0YSAmICgxIDw8IFN0YXRlLk9GRlNFVCkpO1xuICAgIH1cbiAgICA7XG4gICAgc2V0IG9mZnNldHModmFsdWUpIHtcbiAgICAgICAgaWYgKCEhKHRoaXMuZGF0YSAmICgxIDw8IFN0YXRlLk9GRlNFVCkpICE9PSB2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5kYXRhIF49ICgxIDw8IFN0YXRlLk9GRlNFVCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIEFjdGl2YXRlcyBjdWxsaW5nIG9mIHBvbHlnb25zLlxuICAgICAqXG4gICAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAqL1xuICAgIGdldCBjdWxsaW5nKCkge1xuICAgICAgICByZXR1cm4gISEodGhpcy5kYXRhICYgKDEgPDwgU3RhdGUuQ1VMTElORykpO1xuICAgIH1cbiAgICA7XG4gICAgc2V0IGN1bGxpbmcodmFsdWUpIHtcbiAgICAgICAgaWYgKCEhKHRoaXMuZGF0YSAmICgxIDw8IFN0YXRlLkNVTExJTkcpKSAhPT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YSBePSAoMSA8PCBTdGF0ZS5DVUxMSU5HKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogQWN0aXZhdGVzIGRlcHRoIGNvbXBhcmlzb25zIGFuZCB1cGRhdGVzIHRvIHRoZSBkZXB0aCBidWZmZXIuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtib29sZWFufVxuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICovXG4gICAgZ2V0IGRlcHRoVGVzdCgpIHtcbiAgICAgICAgcmV0dXJuICEhKHRoaXMuZGF0YSAmICgxIDw8IFN0YXRlLkRFUFRIX1RFU1QpKTtcbiAgICB9XG4gICAgO1xuICAgIHNldCBkZXB0aFRlc3QodmFsdWUpIHtcbiAgICAgICAgaWYgKCEhKHRoaXMuZGF0YSAmICgxIDw8IFN0YXRlLkRFUFRIX1RFU1QpKSAhPT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YSBePSAoMSA8PCBTdGF0ZS5ERVBUSF9URVNUKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IGZyb250IG9yIGJhY2stZmFjaW5nIHBvbHlnb25zIGNhbiBiZSBjdWxsZWQuXG4gICAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAqL1xuICAgIGdldCBjbG9ja3dpc2VGcm9udEZhY2UoKSB7XG4gICAgICAgIHJldHVybiAhISh0aGlzLmRhdGEgJiAoMSA8PCBTdGF0ZS5XSU5ESU5HKSk7XG4gICAgfVxuICAgIDtcbiAgICBzZXQgY2xvY2t3aXNlRnJvbnRGYWNlKHZhbHVlKSB7XG4gICAgICAgIGlmICghISh0aGlzLmRhdGEgJiAoMSA8PCBTdGF0ZS5XSU5ESU5HKSkgIT09IHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGEgXj0gKDEgPDwgU3RhdGUuV0lORElORyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFRoZSBibGVuZCBtb2RlIHRvIGJlIGFwcGxpZWQgd2hlbiB0aGlzIHN0YXRlIGlzIHNldC4gQXBwbHkgYSB2YWx1ZSBvZiBgUElYSS5CTEVORF9NT0RFUy5OT1JNQUxgIHRvIHJlc2V0IHRoZSBibGVuZCBtb2RlLlxuICAgICAqIFNldHRpbmcgdGhpcyBtb2RlIHRvIGFueXRoaW5nIG90aGVyIHRoYW4gTk9fQkxFTkQgd2lsbCBhdXRvbWF0aWNhbGx5IHN3aXRjaCBibGVuZGluZyBvbi5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XG4gICAgICogQGRlZmF1bHQgUElYSS5CTEVORF9NT0RFUy5OT1JNQUxcbiAgICAgKiBAc2VlIFBJWEkuQkxFTkRfTU9ERVNcbiAgICAgKi9cbiAgICBnZXQgYmxlbmRNb2RlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYmxlbmRNb2RlO1xuICAgIH1cbiAgICA7XG4gICAgc2V0IGJsZW5kTW9kZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLmJsZW5kID0gKHZhbHVlICE9PSBCbGVuZE1vZGVzU2V0dGluZ3NfMS5CbGVuZE1vZGVzU2V0dGluZ3MuQkxFTkRfTU9ERVMuTk9ORSk7XG4gICAgICAgIHRoaXMuX2JsZW5kTW9kZSA9IHZhbHVlO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogVGhlIHBvbHlnb24gb2Zmc2V0LiBTZXR0aW5nIHRoaXMgcHJvcGVydHkgdG8gYW55dGhpbmcgb3RoZXIgdGhhbiAwIHdpbGwgYXV0b21hdGljYWxseSBlbmFibGUgcG9seWdvbiBvZmZzZXQgZmlsbC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICovXG4gICAgZ2V0IHBvbHlnb25PZmZzZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wb2x5Z29uT2Zmc2V0O1xuICAgIH1cbiAgICA7XG4gICAgc2V0IHBvbHlnb25PZmZzZXQodmFsdWUpIHtcbiAgICAgICAgdGhpcy5vZmZzZXRzID0gISF2YWx1ZTtcbiAgICAgICAgdGhpcy5fcG9seWdvbk9mZnNldCA9IHZhbHVlO1xuICAgIH1cbiAgICA7XG4gICAgc3RhdGljIGZvcjJkKCkge1xuICAgICAgICB2YXIgc3RhdGUgPSBuZXcgU3RhdGUoKTtcbiAgICAgICAgc3RhdGUuZGVwdGhUZXN0ID0gZmFsc2U7XG4gICAgICAgIHN0YXRlLmJsZW5kID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cbiAgICA7XG59XG5TdGF0ZS5CTEVORCA9IDA7XG5TdGF0ZS5PRkZTRVQgPSAxO1xuU3RhdGUuQ1VMTElORyA9IDI7XG5TdGF0ZS5ERVBUSF9URVNUID0gMztcblN0YXRlLldJTkRJTkcgPSA0O1xuZXhwb3J0cy5TdGF0ZSA9IFN0YXRlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBTeXN0ZW1fMSA9IHJlcXVpcmUoXCIuL1N5c3RlbVwiKTtcbmNvbnN0IFN0YXRlXzEgPSByZXF1aXJlKFwiLi9TdGF0ZVwiKTtcbmNvbnN0IEJsZW5kTW9kZXNTZXR0aW5nc18xID0gcmVxdWlyZShcIi4vQmxlbmRNb2Rlc1NldHRpbmdzXCIpO1xuY2xhc3MgU3RhdGVTeXN0ZW0gZXh0ZW5kcyBTeXN0ZW1fMS5TeXN0ZW0ge1xuICAgIGNvbnN0cnVjdG9yKHJlbmRlcmVyKSB7XG4gICAgICAgIHN1cGVyKHJlbmRlcmVyKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdMIGNvbnRleHRcbiAgICAgICAgICogQG1lbWJlciB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fVxuICAgICAgICAgKiBAcmVhZG9ubHlcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZ2wgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogU3RhdGUgSURcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKiBAcmVhZG9ubHlcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3RhdGVJZCA9IDA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQb2x5Z29uIG9mZnNldFxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqIEByZWFkb25seVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wb2x5Z29uT2Zmc2V0ID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJsZW5kIG1vZGVcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCBQSVhJLkJMRU5EX01PREVTLk5PTkVcbiAgICAgICAgICogQHJlYWRvbmx5XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmJsZW5kTW9kZSA9IEJsZW5kTW9kZXNTZXR0aW5nc18xLkJsZW5kTW9kZXNTZXR0aW5ncy5CTEVORF9NT0RFUy5OT05FO1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciBjdXJyZW50IGJsZW5kIGVxdWF0aW9uIGlzIGRpZmZlcmVudFxuICAgICAgICAgKiBAbWVtYmVyIHtib29sZWFufVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9ibGVuZEVxID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb2xsZWN0aW9uIG9mIGNhbGxzXG4gICAgICAgICAqIEBtZW1iZXIge2Z1bmN0aW9uW119XG4gICAgICAgICAqIEByZWFkb25seVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tYXAgPSBbXTtcbiAgICAgICAgLy8gbWFwIGZ1bmN0aW9ucyBmb3Igd2hlbiB3ZSBzZXQgc3RhdGUuLlxuICAgICAgICB0aGlzLm1hcFtTdGF0ZVN5c3RlbS5CTEVORCQxXSA9IHRoaXMuc2V0QmxlbmQ7XG4gICAgICAgIHRoaXMubWFwW1N0YXRlU3lzdGVtLk9GRlNFVCQxXSA9IHRoaXMuc2V0T2Zmc2V0O1xuICAgICAgICB0aGlzLm1hcFtTdGF0ZVN5c3RlbS5DVUxMSU5HJDFdID0gdGhpcy5zZXRDdWxsRmFjZTtcbiAgICAgICAgdGhpcy5tYXBbU3RhdGVTeXN0ZW0uREVQVEhfVEVTVCQxXSA9IHRoaXMuc2V0RGVwdGhUZXN0O1xuICAgICAgICB0aGlzLm1hcFtTdGF0ZVN5c3RlbS5XSU5ESU5HJDFdID0gdGhpcy5zZXRGcm9udEZhY2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb2xsZWN0aW9uIG9mIGNoZWNrIGNhbGxzXG4gICAgICAgICAqIEBtZW1iZXIge2Z1bmN0aW9uW119XG4gICAgICAgICAqIEByZWFkb25seVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jaGVja3MgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlZmF1bHQgV2ViR0wgU3RhdGVcbiAgICAgICAgICogQG1lbWJlciB7UElYSS5TdGF0ZX1cbiAgICAgICAgICogQHJlYWRvbmx5XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRlZmF1bHRTdGF0ZSA9IG5ldyBTdGF0ZV8xLlN0YXRlKCk7XG4gICAgICAgIHRoaXMuZGVmYXVsdFN0YXRlLmJsZW5kID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5kZWZhdWx0U3RhdGUuZGVwdGggPSB0cnVlO1xuICAgIH1cbiAgICBjb250ZXh0Q2hhbmdlKGdsKSB7XG4gICAgICAgIHRoaXMuZ2wgPSBnbDtcbiAgICAgICAgdGhpcy5ibGVuZE1vZGVzID0gQmxlbmRNb2Rlc1NldHRpbmdzXzEuQmxlbmRNb2Rlc1NldHRpbmdzLm1hcFdlYkdMQmxlbmRNb2Rlc1RvUGl4aShnbCk7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUodGhpcy5kZWZhdWx0U3RhdGUpO1xuICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBjdXJyZW50IHN0YXRlXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyp9IHN0YXRlIC0gVGhlIHN0YXRlIHRvIHNldC5cbiAgICAgKi9cbiAgICBzZXRTdGF0ZShzdGF0ZSkge1xuICAgICAgICBzdGF0ZSA9IHN0YXRlIHx8IHRoaXMuZGVmYXVsdFN0YXRlO1xuICAgICAgICAvLyBUT0RPIG1heWJlIHRvIGFuIG9iamVjdCBjaGVjaz8gKCB0aGlzLnN0YXRlID09PSBzdGF0ZSApP1xuICAgICAgICBpZiAodGhpcy5zdGF0ZUlkICE9PSBzdGF0ZS5kYXRhKSB7XG4gICAgICAgICAgICB2YXIgZGlmZiA9IHRoaXMuc3RhdGVJZCBeIHN0YXRlLmRhdGE7XG4gICAgICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgICAgICAvLyBvcmRlciBmcm9tIGxlYXN0IHRvIG1vc3QgY29tbW9uXG4gICAgICAgICAgICB3aGlsZSAoZGlmZikge1xuICAgICAgICAgICAgICAgIGlmIChkaWZmICYgMSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBzdGF0ZSBjaGFuZ2UhXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWFwW2ldLmNhbGwodGhpcywgISEoc3RhdGUuZGF0YSAmICgxIDw8IGkpKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRpZmYgPSBkaWZmID4+IDE7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zdGF0ZUlkID0gc3RhdGUuZGF0YTtcbiAgICAgICAgfVxuICAgICAgICAvLyBiYXNlZCBvbiB0aGUgYWJvdmUgc2V0dGluZ3Mgd2UgY2hlY2sgZm9yIHNwZWNpZmljIG1vZGVzLi5cbiAgICAgICAgLy8gZm9yIGV4YW1wbGUgaWYgYmxlbmQgaXMgYWN0aXZlIHdlIGNoZWNrIGFuZCBzZXQgdGhlIGJsZW5kIG1vZGVzXG4gICAgICAgIC8vIG9yIG9mIHBvbHlnb24gb2Zmc2V0IGlzIGFjdGl2ZSB3ZSBjaGVjayB0aGUgcG9seSBkZXB0aC5cbiAgICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgdGhpcy5jaGVja3MubGVuZ3RoOyBpJDErKykge1xuICAgICAgICAgICAgdGhpcy5jaGVja3NbaSQxXSh0aGlzLCBzdGF0ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHN0YXRlLCB3aGVuIHByZXZpb3VzIHN0YXRlIGlzIHVua25vd25cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Kn0gc3RhdGUgLSBUaGUgc3RhdGUgdG8gc2V0XG4gICAgICovXG4gICAgZm9yY2VTdGF0ZShzdGF0ZSkge1xuICAgICAgICBzdGF0ZSA9IHN0YXRlIHx8IHRoaXMuZGVmYXVsdFN0YXRlO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubWFwLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLm1hcFtpXS5jYWxsKHRoaXMsICEhKHN0YXRlLmRhdGEgJiAoMSA8PCBpKSkpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IHRoaXMuY2hlY2tzLmxlbmd0aDsgaSQxKyspIHtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tzW2kkMV0odGhpcywgc3RhdGUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGVJZCA9IHN0YXRlLmRhdGE7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBFbmFibGVzIG9yIGRpc2FibGVkIGJsZW5kaW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtib29sZWFufSB2YWx1ZSAtIFR1cm4gb24gb3Igb2ZmIHdlYmdsIGJsZW5kaW5nLlxuICAgICAqL1xuICAgIHNldEJsZW5kKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudXBkYXRlQ2hlY2soU3RhdGVTeXN0ZW0uY2hlY2tCbGVuZE1vZGUsIHZhbHVlKTtcbiAgICAgICAgdGhpcy5nbFt2YWx1ZSA/ICdlbmFibGUnIDogJ2Rpc2FibGUnXSh0aGlzLmdsLkJMRU5EKTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIEVuYWJsZXMgb3IgZGlzYWJsZSBwb2x5Z29uIG9mZnNldCBmaWxsXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHZhbHVlIC0gVHVybiBvbiBvciBvZmYgd2ViZ2wgcG9seWdvbiBvZmZzZXQgdGVzdGluZy5cbiAgICAgKi9cbiAgICBzZXRPZmZzZXQodmFsdWUpIHtcbiAgICAgICAgdGhpcy5nbFt2YWx1ZSA/ICdlbmFibGUnIDogJ2Rpc2FibGUnXSh0aGlzLmdsLlBPTFlHT05fT0ZGU0VUX0ZJTEwpO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogU2V0cyB3aGV0aGVyIHRvIGVuYWJsZSBvciBkaXNhYmxlIGRlcHRoIHRlc3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHZhbHVlIC0gVHVybiBvbiBvciBvZmYgd2ViZ2wgZGVwdGggdGVzdGluZy5cbiAgICAgKi9cbiAgICBzZXREZXB0aFRlc3QodmFsdWUpIHtcbiAgICAgICAgdGhpcy5nbFt2YWx1ZSA/ICdlbmFibGUnIDogJ2Rpc2FibGUnXSh0aGlzLmdsLkRFUFRIX1RFU1QpO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogU2V0cyB3aGV0aGVyIHRvIGVuYWJsZSBvciBkaXNhYmxlIGN1bGwgZmFjZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gdmFsdWUgLSBUdXJuIG9uIG9yIG9mZiB3ZWJnbCBjdWxsIGZhY2UuXG4gICAgICovXG4gICAgc2V0Q3VsbEZhY2UodmFsdWUpIHtcbiAgICAgICAgdGhpcy5nbFt2YWx1ZSA/ICdlbmFibGUnIDogJ2Rpc2FibGUnXSh0aGlzLmdsLkNVTExfRkFDRSk7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBnbCBmcm9udCBmYWNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtib29sZWFufSB2YWx1ZSAtIHRydWUgaXMgY2xvY2t3aXNlIGFuZCBmYWxzZSBpcyBjb3VudGVyLWNsb2Nrd2lzZVxuICAgICAqL1xuICAgIHNldEZyb250RmFjZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLmdsLmZyb250RmFjZSh0aGlzLmdsW3ZhbHVlID8gJ0NXJyA6ICdDQ1cnXSk7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBibGVuZCBtb2RlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIC0gVGhlIGJsZW5kIG1vZGUgdG8gc2V0IHRvLlxuICAgICAqL1xuICAgIHNldEJsZW5kTW9kZSh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPT09IHRoaXMuYmxlbmRNb2RlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ibGVuZE1vZGUgPSB2YWx1ZTtcbiAgICAgICAgdmFyIG1vZGUgPSB0aGlzLmJsZW5kTW9kZXNbdmFsdWVdO1xuICAgICAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuICAgICAgICBpZiAobW9kZS5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgIGdsLmJsZW5kRnVuYyhtb2RlWzBdLCBtb2RlWzFdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGdsLmJsZW5kRnVuY1NlcGFyYXRlKG1vZGVbMF0sIG1vZGVbMV0sIG1vZGVbMl0sIG1vZGVbM10pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtb2RlLmxlbmd0aCA9PT0gNikge1xuICAgICAgICAgICAgdGhpcy5fYmxlbmRFcSA9IHRydWU7XG4gICAgICAgICAgICBnbC5ibGVuZEVxdWF0aW9uU2VwYXJhdGUobW9kZVs0XSwgbW9kZVs1XSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5fYmxlbmRFcSkge1xuICAgICAgICAgICAgdGhpcy5fYmxlbmRFcSA9IGZhbHNlO1xuICAgICAgICAgICAgZ2wuYmxlbmRFcXVhdGlvblNlcGFyYXRlKGdsLkZVTkNfQURELCBnbC5GVU5DX0FERCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHBvbHlnb24gb2Zmc2V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIC0gdGhlIHBvbHlnb24gb2Zmc2V0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNjYWxlIC0gdGhlIHBvbHlnb24gb2Zmc2V0IHNjYWxlXG4gICAgICovXG4gICAgc2V0UG9seWdvbk9mZnNldCh2YWx1ZSwgc2NhbGUpIHtcbiAgICAgICAgdGhpcy5nbC5wb2x5Z29uT2Zmc2V0KHZhbHVlLCBzY2FsZSk7XG4gICAgfVxuICAgIDtcbiAgICAvLyB1c2VkXG4gICAgLyoqXG4gICAgICogUmVzZXRzIGFsbCB0aGUgbG9naWMgYW5kIGRpc2FibGVzIHRoZSB2YW9zXG4gICAgICovXG4gICAgcmVzZXQoKSB7XG4gICAgICAgIHRoaXMuZ2wucGl4ZWxTdG9yZWkodGhpcy5nbC5VTlBBQ0tfRkxJUF9ZX1dFQkdMLCBmYWxzZSk7XG4gICAgICAgIHRoaXMuZm9yY2VTdGF0ZSgwKTtcbiAgICAgICAgdGhpcy5fYmxlbmRFcSA9IHRydWU7XG4gICAgICAgIHRoaXMuYmxlbmRNb2RlID0gLTE7XG4gICAgICAgIHRoaXMuc2V0QmxlbmRNb2RlKDApO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogY2hlY2tzIHRvIHNlZSB3aGljaCB1cGRhdGVzIHNob3VsZCBiZSBjaGVja2VkIGJhc2VkIG9uIHdoaWNoIHNldHRpbmdzIGhhdmUgYmVlbiBhY3RpdmF0ZWQuXG4gICAgICogRm9yIGV4YW1wbGUsIGlmIGJsZW5kIGlzIGVuYWJsZWQgdGhlbiB3ZSBzaG91bGQgY2hlY2sgdGhlIGJsZW5kIG1vZGVzIGVhY2ggdGltZSB0aGUgc3RhdGUgaXMgY2hhbmdlZFxuICAgICAqIG9yIGlmIHBvbHlnb24gZmlsbCBpcyBhY3RpdmF0ZWQgdGhlbiB3ZSBuZWVkIHRvIGNoZWNrIGlmIHRoZSBwb2x5Z29uIG9mZnNldCBjaGFuZ2VzLlxuICAgICAqIFRoZSBpZGVhIGlzIHRoYXQgd2Ugb25seSBjaGVjayB3aGF0IHdlIGhhdmUgdG9vLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyAgdGhlIGNoZWNraW5nIGZ1bmN0aW9uIHRvIGFkZCBvciByZW1vdmVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHZhbHVlICBzaG91bGQgdGhlIGNoZWNrIGZ1bmN0aW9uIGJlIGFkZGVkIG9yIHJlbW92ZWQuXG4gICAgICovXG4gICAgdXBkYXRlQ2hlY2soZnVuYywgdmFsdWUpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5jaGVja3MuaW5kZXhPZihmdW5jKTtcbiAgICAgICAgaWYgKHZhbHVlICYmIGluZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgdGhpcy5jaGVja3MucHVzaChmdW5jKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghdmFsdWUgJiYgaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBBIHByaXZhdGUgbGl0dGxlIHdyYXBwZXIgZnVuY3Rpb24gdGhhdCB3ZSBjYWxsIHRvIGNoZWNrIHRoZSBibGVuZCBtb2RlLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtQSVhJLlN0YXRlU3lzdGVtfSBTeXN0ZW0gIHRoZSBTeXN0ZW0gdG8gcGVyZm9ybSB0aGUgc3RhdGUgY2hlY2sgb25cbiAgICAgKiBAcGFyYW0ge1BJWEkuU3RhdGV9IHN0YXRlICB0aGUgc3RhdGUgdGhhdCB0aGUgYmxlbmRNb2RlIHdpbGwgcHVsbGVkIGZyb21cbiAgICAgKi9cbiAgICBzdGF0aWMgY2hlY2tCbGVuZE1vZGUoc3lzdGVtLCBzdGF0ZSkge1xuICAgICAgICBzeXN0ZW0uc2V0QmxlbmRNb2RlKHN0YXRlLmJsZW5kTW9kZSk7XG4gICAgfVxuICAgIDtcbn1cblN0YXRlU3lzdGVtLlVJRCQ0ID0gMDtcblN0YXRlU3lzdGVtLkJMRU5EJDEgPSAwO1xuU3RhdGVTeXN0ZW0uT0ZGU0VUJDEgPSAxO1xuU3RhdGVTeXN0ZW0uQ1VMTElORyQxID0gMjtcblN0YXRlU3lzdGVtLkRFUFRIX1RFU1QkMSA9IDM7XG5TdGF0ZVN5c3RlbS5XSU5ESU5HJDEgPSA0O1xuZXhwb3J0cy5TdGF0ZVN5c3RlbSA9IFN0YXRlU3lzdGVtO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBTeXN0ZW1fMSA9IHJlcXVpcmUoXCIuL1N5c3RlbVwiKTtcbmNsYXNzIFN0ZW5jaWxTeXN0ZW0gZXh0ZW5kcyBTeXN0ZW1fMS5TeXN0ZW0ge1xuICAgIGNvbnN0cnVjdG9yKHJlbmRlcmVyKSB7XG4gICAgICAgIHN1cGVyKHJlbmRlcmVyKTtcbiAgICAgICAgdGhpcy5zdGVuY2lsTWFza1N0YWNrID0gW107XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoYW5nZXMgdGhlIG1hc2sgc3RhY2sgdGhhdCBpcyB1c2VkIGJ5IHRoaXMgU3lzdGVtLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQSVhJLkdyYXBoaWNzW119IHN0ZW5jaWxNYXNrU3RhY2sgLSBUaGUgbWFzayBzdGFja1xuICAgICAqL1xuICAgIHNldE1hc2tTdGFjayhzdGVuY2lsTWFza1N0YWNrKSB7XG4gICAgICAgIHZhciBnbCA9IHRoaXMucmVuZGVyZXIuZ2w7XG4gICAgICAgIGlmIChzdGVuY2lsTWFza1N0YWNrLmxlbmd0aCAhPT0gdGhpcy5zdGVuY2lsTWFza1N0YWNrLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKHN0ZW5jaWxNYXNrU3RhY2subGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgZ2wuZGlzYWJsZShnbC5TVEVOQ0lMX1RFU1QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZ2wuZW5hYmxlKGdsLlNURU5DSUxfVEVTVCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGVuY2lsTWFza1N0YWNrID0gc3RlbmNpbE1hc2tTdGFjaztcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgdGhlIE1hc2sgYW5kIGFkZHMgaXQgdG8gdGhlIGN1cnJlbnQgc3RlbmNpbCBzdGFjay4gQGFsdmluXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BJWEkuR3JhcGhpY3N9IGdyYXBoaWNzIC0gVGhlIG1hc2tcbiAgICAgKi9cbiAgICBwdXNoU3RlbmNpbChncmFwaGljcykge1xuICAgICAgICB2YXIgZ2wgPSB0aGlzLnJlbmRlcmVyLmdsO1xuICAgICAgICB2YXIgcHJldk1hc2tDb3VudCA9IHRoaXMuc3RlbmNpbE1hc2tTdGFjay5sZW5ndGg7XG4gICAgICAgIGlmIChwcmV2TWFza0NvdW50ID09PSAwKSB7XG4gICAgICAgICAgICBnbC5lbmFibGUoZ2wuU1RFTkNJTF9URVNUKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0ZW5jaWxNYXNrU3RhY2sucHVzaChncmFwaGljcyk7XG4gICAgICAgIC8vIEluY3JlbWVudCB0aGUgcmVmZXJlbmNlIHN0ZW5jaWwgdmFsdWUgd2hlcmUgdGhlIG5ldyBtYXNrIG92ZXJsYXBzIHdpdGggdGhlIG9sZCBvbmVzLlxuICAgICAgICBnbC5jb2xvck1hc2soZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2UpO1xuICAgICAgICBnbC5zdGVuY2lsRnVuYyhnbC5FUVVBTCwgcHJldk1hc2tDb3VudCwgdGhpcy5fZ2V0Qml0d2lzZU1hc2soKSk7XG4gICAgICAgIGdsLnN0ZW5jaWxPcChnbC5LRUVQLCBnbC5LRUVQLCBnbC5JTkNSKTtcbiAgICAgICAgZ3JhcGhpY3MucmVuZGVyYWJsZSA9IHRydWU7XG4gICAgICAgIGdyYXBoaWNzLnJlbmRlcih0aGlzLnJlbmRlcmVyKTtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5iYXRjaC5mbHVzaCgpO1xuICAgICAgICBncmFwaGljcy5yZW5kZXJhYmxlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3VzZUN1cnJlbnQoKTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdGhlIGxhc3QgbWFzayBmcm9tIHRoZSBzdGVuY2lsIHN0YWNrLiBAYWx2aW5cbiAgICAgKi9cbiAgICBwb3BTdGVuY2lsKCkge1xuICAgICAgICB2YXIgZ2wgPSB0aGlzLnJlbmRlcmVyLmdsO1xuICAgICAgICB2YXIgZ3JhcGhpY3MgPSB0aGlzLnN0ZW5jaWxNYXNrU3RhY2sucG9wKCk7XG4gICAgICAgIGlmICh0aGlzLnN0ZW5jaWxNYXNrU3RhY2subGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAvLyB0aGUgc3RhY2sgaXMgZW1wdHkhXG4gICAgICAgICAgICBnbC5kaXNhYmxlKGdsLlNURU5DSUxfVEVTVCk7XG4gICAgICAgICAgICBnbC5jbGVhcihnbC5TVEVOQ0lMX0JVRkZFUl9CSVQpO1xuICAgICAgICAgICAgZ2wuY2xlYXJTdGVuY2lsKDApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gRGVjcmVtZW50IHRoZSByZWZlcmVuY2Ugc3RlbmNpbCB2YWx1ZSB3aGVyZSB0aGUgcG9wcGVkIG1hc2sgb3ZlcmxhcHMgd2l0aCB0aGUgb3RoZXIgb25lc1xuICAgICAgICAgICAgZ2wuY29sb3JNYXNrKGZhbHNlLCBmYWxzZSwgZmFsc2UsIGZhbHNlKTtcbiAgICAgICAgICAgIGdsLnN0ZW5jaWxPcChnbC5LRUVQLCBnbC5LRUVQLCBnbC5ERUNSKTtcbiAgICAgICAgICAgIGdyYXBoaWNzLnJlbmRlcmFibGUgPSB0cnVlO1xuICAgICAgICAgICAgZ3JhcGhpY3MucmVuZGVyKHRoaXMucmVuZGVyZXIpO1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5iYXRjaC5mbHVzaCgpO1xuICAgICAgICAgICAgZ3JhcGhpY3MucmVuZGVyYWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5fdXNlQ3VycmVudCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBTZXR1cCByZW5kZXJlciB0byB1c2UgdGhlIGN1cnJlbnQgc3RlbmNpbCBkYXRhLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3VzZUN1cnJlbnQoKSB7XG4gICAgICAgIHZhciBnbCA9IHRoaXMucmVuZGVyZXIuZ2w7XG4gICAgICAgIGdsLmNvbG9yTWFzayh0cnVlLCB0cnVlLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgZ2wuc3RlbmNpbEZ1bmMoZ2wuRVFVQUwsIHRoaXMuc3RlbmNpbE1hc2tTdGFjay5sZW5ndGgsIHRoaXMuX2dldEJpdHdpc2VNYXNrKCkpO1xuICAgICAgICBnbC5zdGVuY2lsT3AoZ2wuS0VFUCwgZ2wuS0VFUCwgZ2wuS0VFUCk7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBGaWxsIDFzIGVxdWFsIHRvIHRoZSBudW1iZXIgb2YgYWNpdHZlIHN0ZW5jaWwgbWFza3MuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBiaXR3aXNlIG1hc2suXG4gICAgICovXG4gICAgX2dldEJpdHdpc2VNYXNrKCkge1xuICAgICAgICByZXR1cm4gKDEgPDwgdGhpcy5zdGVuY2lsTWFza1N0YWNrLmxlbmd0aCkgLSAxO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogRGVzdHJveXMgdGhlIG1hc2sgc3RhY2suXG4gICAgICpcbiAgICAgKi9cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBzdXBlci5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuc3RlbmNpbE1hc2tTdGFjayA9IG51bGw7XG4gICAgfVxuICAgIDtcbn1cbmV4cG9ydHMuU3RlbmNpbFN5c3RlbSA9IFN0ZW5jaWxTeXN0ZW07XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IEV2ZW50RGlzcGF0Y2hlcl8xID0gcmVxdWlyZShcIi4vRXZlbnREaXNwYXRjaGVyXCIpO1xuY2xhc3MgU3lzdGVtIGV4dGVuZHMgRXZlbnREaXNwYXRjaGVyXzEuRXZlbnREaXNwYXRjaGVyIHtcbiAgICBjb25zdHJ1Y3RvcihyZW5kZXJlciA9IG51bGwpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnJ1bm5lcnMuY29udGV4dENoYW5nZS5hZGQodGhpcyk7XG4gICAgfVxuICAgIGNvbnRleHRDaGFuZ2UoZ2wpIHtcbiAgICB9XG4gICAgO1xuICAgIGRlc3Ryb3kob3B0aW9ucyA9IG51bGwpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5ydW5uZXJzLmNvbnRleHRDaGFuZ2UucmVtb3ZlKHRoaXMpO1xuICAgICAgICB0aGlzLnJlbmRlcmVyID0gbnVsbDtcbiAgICB9XG4gICAgO1xufVxuZXhwb3J0cy5TeXN0ZW0gPSBTeXN0ZW07XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IFNwcml0ZV8xID0gcmVxdWlyZShcIi4vU3ByaXRlXCIpO1xuY29uc3QgVGV4dHVyZV8xID0gcmVxdWlyZShcIi4vVGV4dHVyZVwiKTtcbmNvbnN0IFJlY3RhbmdsZV8xID0gcmVxdWlyZShcIi4uL2ZsYXNoL2dlb20vUmVjdGFuZ2xlXCIpO1xuY29uc3QgVGV4dE1ldHJpY3NfMSA9IHJlcXVpcmUoXCIuL1RleHRNZXRyaWNzXCIpO1xuY29uc3QgVGV4dFN0eWxlXzEgPSByZXF1aXJlKFwiLi9UZXh0U3R5bGVcIik7XG5jb25zdCBEaXNwbGF5U2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL0Rpc3BsYXlTZXR0aW5nc1wiKTtcbmNvbnN0IE1hdGhTZXR0aW5nc18xID0gcmVxdWlyZShcIi4vTWF0aFNldHRpbmdzXCIpO1xuY29uc3QgQ2FudmFzU2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL0NhbnZhc1NldHRpbmdzXCIpO1xuY29uc3QgVGV4dFNldHRpbmdzXzEgPSByZXF1aXJlKFwiLi9UZXh0U2V0dGluZ3NcIik7XG5jb25zdCBDbGVhblVwU2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL0NsZWFuVXBTZXR0aW5nc1wiKTtcbmNvbnN0IENvbG9yU2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL0NvbG9yU2V0dGluZ3NcIik7XG5jb25zdCBJbnN0YW5jZUNvdW50ZXJfMSA9IHJlcXVpcmUoXCIuL0luc3RhbmNlQ291bnRlclwiKTtcbmNsYXNzIFRleHQgZXh0ZW5kcyBTcHJpdGVfMS5TcHJpdGUge1xuICAgIGNvbnN0cnVjdG9yKHRleHQsIHN0eWxlID0gbnVsbCwgY2FudmFzID0gbnVsbCkge1xuICAgICAgICBjYW52YXMgPSBjYW52YXMgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgIGNhbnZhcy53aWR0aCA9IDM7XG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSAzO1xuICAgICAgICB2YXIgdGV4dHVyZSA9IFRleHR1cmVfMS5UZXh0dXJlLmZyb20oY2FudmFzKTtcbiAgICAgICAgSW5zdGFuY2VDb3VudGVyXzEuSW5zdGFuY2VDb3VudGVyLmFkZENhbGwoXCJSZWN0YW5nbGUuZ2V0UmVjdGFuZ2xlXCIsIFwiVGV4dFwiKTtcbiAgICAgICAgdGV4dHVyZS5vcmlnID0gUmVjdGFuZ2xlXzEuUmVjdGFuZ2xlLmdldFJlY3RhbmdsZSgpO1xuICAgICAgICBJbnN0YW5jZUNvdW50ZXJfMS5JbnN0YW5jZUNvdW50ZXIuYWRkQ2FsbChcIlJlY3RhbmdsZS5nZXRSZWN0YW5nbGVcIiwgXCJUZXh0XCIpO1xuICAgICAgICB0ZXh0dXJlLnRyaW0gPSBSZWN0YW5nbGVfMS5SZWN0YW5nbGUuZ2V0UmVjdGFuZ2xlKCk7XG4gICAgICAgIHN1cGVyKHRleHR1cmUpO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGNhbnZhcyBlbGVtZW50IHRoYXQgZXZlcnl0aGluZyBpcyBkcmF3biB0b1xuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtIVE1MQ2FudmFzRWxlbWVudH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2FudmFzID0gY2FudmFzO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGNhbnZhcyAyZCBjb250ZXh0IHRoYXQgZXZlcnl0aGluZyBpcyBkcmF3biB3aXRoXG4gICAgICAgICAqIEBtZW1iZXIge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY29udGV4dCA9IHRoaXMuY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgcmVzb2x1dGlvbiAvIGRldmljZSBwaXhlbCByYXRpbyBvZiB0aGUgY2FudmFzLlxuICAgICAgICAgKiBUaGlzIGlzIHNldCB0byBhdXRvbWF0aWNhbGx5IG1hdGNoIHRoZSByZW5kZXJlciByZXNvbHV0aW9uIGJ5IGRlZmF1bHQsIGJ1dCBjYW4gYmUgb3ZlcnJpZGRlbiBieSBzZXR0aW5nIG1hbnVhbGx5LlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDFcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3Jlc29sdXRpb24gPSBEaXNwbGF5U2V0dGluZ3NfMS5EaXNwbGF5U2V0dGluZ3MuUkVTT0xVVElPTjtcbiAgICAgICAgdGhpcy5fYXV0b1Jlc29sdXRpb24gPSB0cnVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogUHJpdmF0ZSB0cmFja2VyIGZvciB0aGUgY3VycmVudCB0ZXh0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtzdHJpbmd9XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl90ZXh0ID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByaXZhdGUgdHJhY2tlciBmb3IgdGhlIGN1cnJlbnQgc3R5bGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge29iamVjdH1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3N0eWxlID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByaXZhdGUgbGlzdGVuZXIgdG8gdHJhY2sgc3R5bGUgY2hhbmdlcy5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7RnVuY3Rpb259XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9zdHlsZUxpc3RlbmVyID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByaXZhdGUgdHJhY2tlciBmb3IgdGhlIGN1cnJlbnQgZm9udC5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7c3RyaW5nfVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fZm9udCA9ICcnO1xuICAgICAgICB0aGlzLnRleHQgPSB0ZXh0O1xuICAgICAgICB0aGlzLnN0eWxlID0gc3R5bGU7XG4gICAgICAgIHRoaXMubG9jYWxTdHlsZUlEID0gLTE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgdGV4dCBhbmQgdXBkYXRlcyBpdCB3aGVuIG5lZWRlZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtib29sZWFufSByZXNwZWN0RGlydHkgLSBXaGV0aGVyIHRvIGFib3J0IHVwZGF0aW5nIHRoZSB0ZXh0IGlmIHRoZSBUZXh0IGlzbid0IGRpcnR5IGFuZCB0aGUgZnVuY3Rpb24gaXMgY2FsbGVkLlxuICAgICAqL1xuICAgIHVwZGF0ZVRleHQocmVzcGVjdERpcnR5KSB7XG4gICAgICAgIHZhciBzdHlsZSA9IHRoaXMuX3N0eWxlO1xuICAgICAgICAvLyBjaGVjayBpZiBzdHlsZSBoYXMgY2hhbmdlZC4uXG4gICAgICAgIGlmICh0aGlzLmxvY2FsU3R5bGVJRCAhPT0gc3R5bGUuc3R5bGVJRCkge1xuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmxvY2FsU3R5bGVJRCA9IHN0eWxlLnN0eWxlSUQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmRpcnR5ICYmIHJlc3BlY3REaXJ0eSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2ZvbnQgPSB0aGlzLl9zdHlsZS50b0ZvbnRTdHJpbmcoKTtcbiAgICAgICAgdmFyIGNvbnRleHQgPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgIFRleHRNZXRyaWNzXzEuVGV4dE1ldHJpY3MuaW5pdCgpO1xuICAgICAgICB2YXIgbWVhc3VyZWQgPSBUZXh0TWV0cmljc18xLlRleHRNZXRyaWNzLm1lYXN1cmVUZXh0KHRoaXMuX3RleHQgfHwgJyAnLCB0aGlzLl9zdHlsZSwgdGhpcy5fc3R5bGUud29yZFdyYXAsIHRoaXMuY2FudmFzKTtcbiAgICAgICAgdmFyIHdpZHRoID0gbWVhc3VyZWQud2lkdGg7XG4gICAgICAgIHZhciBoZWlnaHQgPSBtZWFzdXJlZC5oZWlnaHQ7XG4gICAgICAgIHZhciBsaW5lcyA9IG1lYXN1cmVkLmxpbmVzO1xuICAgICAgICB2YXIgbGluZUhlaWdodCA9IG1lYXN1cmVkLmxpbmVIZWlnaHQ7XG4gICAgICAgIHZhciBsaW5lV2lkdGhzID0gbWVhc3VyZWQubGluZVdpZHRocztcbiAgICAgICAgdmFyIG1heExpbmVXaWR0aCA9IG1lYXN1cmVkLm1heExpbmVXaWR0aDtcbiAgICAgICAgdmFyIGZvbnRQcm9wZXJ0aWVzID0gbWVhc3VyZWQuZm9udFByb3BlcnRpZXM7XG4gICAgICAgIHRoaXMuY2FudmFzLndpZHRoID0gTWF0aC5jZWlsKChNYXRoLm1heCgxLCB3aWR0aCkgKyAoc3R5bGUucGFkZGluZyAqIDIpKSAqIHRoaXMuX3Jlc29sdXRpb24pO1xuICAgICAgICB0aGlzLmNhbnZhcy5oZWlnaHQgPSBNYXRoLmNlaWwoKE1hdGgubWF4KDEsIGhlaWdodCkgKyAoc3R5bGUucGFkZGluZyAqIDIpKSAqIHRoaXMuX3Jlc29sdXRpb24pO1xuICAgICAgICBjb250ZXh0LnNjYWxlKHRoaXMuX3Jlc29sdXRpb24sIHRoaXMuX3Jlc29sdXRpb24pO1xuICAgICAgICBjb250ZXh0LmNsZWFyUmVjdCgwLCAwLCB0aGlzLmNhbnZhcy53aWR0aCwgdGhpcy5jYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgY29udGV4dC5mb250ID0gdGhpcy5fZm9udDtcbiAgICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9IHN0eWxlLnN0cm9rZTtcbiAgICAgICAgY29udGV4dC5saW5lV2lkdGggPSBzdHlsZS5zdHJva2VUaGlja25lc3M7XG4gICAgICAgIGNvbnRleHQudGV4dEJhc2VsaW5lID0gc3R5bGUudGV4dEJhc2VsaW5lO1xuICAgICAgICBjb250ZXh0LmxpbmVKb2luID0gc3R5bGUubGluZUpvaW47XG4gICAgICAgIGNvbnRleHQubWl0ZXJMaW1pdCA9IHN0eWxlLm1pdGVyTGltaXQ7XG4gICAgICAgIHZhciBsaW5lUG9zaXRpb25YO1xuICAgICAgICB2YXIgbGluZVBvc2l0aW9uWTtcbiAgICAgICAgaWYgKHN0eWxlLmRyb3BTaGFkb3cpIHtcbiAgICAgICAgICAgIHZhciBkcm9wU2hhZG93Q29sb3IgPSBzdHlsZS5kcm9wU2hhZG93Q29sb3I7XG4gICAgICAgICAgICB2YXIgcmdiID0gQ29sb3JTZXR0aW5nc18xLkNvbG9yU2V0dGluZ3MuaGV4MnJnYih0eXBlb2YgZHJvcFNoYWRvd0NvbG9yID09PSAnbnVtYmVyJyA/IGRyb3BTaGFkb3dDb2xvciA6IE1hdGhTZXR0aW5nc18xLk1hdGhTZXR0aW5ncy5zdHJpbmcyaGV4KGRyb3BTaGFkb3dDb2xvcikpO1xuICAgICAgICAgICAgY29udGV4dC5zaGFkb3dDb2xvciA9IFwicmdiYShcIiArIChyZ2JbMF0gKiAyNTUpICsgXCIsXCIgKyAocmdiWzFdICogMjU1KSArIFwiLFwiICsgKHJnYlsyXSAqIDI1NSkgKyBcIixcIiArIChzdHlsZS5kcm9wU2hhZG93QWxwaGEpICsgXCIpXCI7XG4gICAgICAgICAgICBjb250ZXh0LnNoYWRvd0JsdXIgPSBzdHlsZS5kcm9wU2hhZG93Qmx1cjtcbiAgICAgICAgICAgIGNvbnRleHQuc2hhZG93T2Zmc2V0WCA9IE1hdGguY29zKHN0eWxlLmRyb3BTaGFkb3dBbmdsZSkgKiBzdHlsZS5kcm9wU2hhZG93RGlzdGFuY2U7XG4gICAgICAgICAgICBjb250ZXh0LnNoYWRvd09mZnNldFkgPSBNYXRoLnNpbihzdHlsZS5kcm9wU2hhZG93QW5nbGUpICogc3R5bGUuZHJvcFNoYWRvd0Rpc3RhbmNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29udGV4dC5zaGFkb3dDb2xvciA9IDA7XG4gICAgICAgICAgICBjb250ZXh0LnNoYWRvd0JsdXIgPSAwO1xuICAgICAgICAgICAgY29udGV4dC5zaGFkb3dPZmZzZXRYID0gMDtcbiAgICAgICAgICAgIGNvbnRleHQuc2hhZG93T2Zmc2V0WSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2V0IGNhbnZhcyB0ZXh0IHN0eWxlc1xuICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IHRoaXMuX2dlbmVyYXRlRmlsbFN0eWxlKHN0eWxlLCBsaW5lcyk7XG4gICAgICAgIC8vIGRyYXcgbGluZXMgbGluZSBieSBsaW5lXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxpbmVQb3NpdGlvblggPSBzdHlsZS5zdHJva2VUaGlja25lc3MgLyAyO1xuICAgICAgICAgICAgbGluZVBvc2l0aW9uWSA9ICgoc3R5bGUuc3Ryb2tlVGhpY2tuZXNzIC8gMikgKyAoaSAqIGxpbmVIZWlnaHQpKSArIGZvbnRQcm9wZXJ0aWVzLmFzY2VudDtcbiAgICAgICAgICAgIGlmIChzdHlsZS5hbGlnbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICAgICAgICAgIGxpbmVQb3NpdGlvblggKz0gbWF4TGluZVdpZHRoIC0gbGluZVdpZHRoc1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHN0eWxlLmFsaWduID09PSAnY2VudGVyJykge1xuICAgICAgICAgICAgICAgIGxpbmVQb3NpdGlvblggKz0gKG1heExpbmVXaWR0aCAtIGxpbmVXaWR0aHNbaV0pIC8gMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdHlsZS5zdHJva2UgJiYgc3R5bGUuc3Ryb2tlVGhpY2tuZXNzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kcmF3TGV0dGVyU3BhY2luZyhsaW5lc1tpXSwgbGluZVBvc2l0aW9uWCArIHN0eWxlLnBhZGRpbmcsIGxpbmVQb3NpdGlvblkgKyBzdHlsZS5wYWRkaW5nLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdHlsZS5maWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kcmF3TGV0dGVyU3BhY2luZyhsaW5lc1tpXSwgbGluZVBvc2l0aW9uWCArIHN0eWxlLnBhZGRpbmcsIGxpbmVQb3NpdGlvblkgKyBzdHlsZS5wYWRkaW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVwZGF0ZVRleHR1cmUoKTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFJlbmRlciB0aGUgdGV4dCB3aXRoIGxldHRlci1zcGFjaW5nLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IC0gVGhlIHRleHQgdG8gZHJhd1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gSG9yaXpvbnRhbCBwb3NpdGlvbiB0byBkcmF3IHRoZSB0ZXh0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgLSBWZXJ0aWNhbCBwb3NpdGlvbiB0byBkcmF3IHRoZSB0ZXh0XG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNTdHJva2U9ZmFsc2VdIC0gSXMgdGhpcyBkcmF3aW5nIGZvciB0aGUgb3V0c2lkZSBzdHJva2Ugb2YgdGhlXG4gICAgICogIHRleHQ/IElmIG5vdCwgaXQncyBmb3IgdGhlIGluc2lkZSBmaWxsXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBkcmF3TGV0dGVyU3BhY2luZyh0ZXh0LCB4LCB5LCBpc1N0cm9rZSA9IGZhbHNlKSB7XG4gICAgICAgIGlmIChpc1N0cm9rZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBpc1N0cm9rZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdHlsZSA9IHRoaXMuX3N0eWxlO1xuICAgICAgICAvLyBsZXR0ZXJTcGFjaW5nIG9mIDAgbWVhbnMgbm9ybWFsXG4gICAgICAgIHZhciBsZXR0ZXJTcGFjaW5nID0gc3R5bGUubGV0dGVyU3BhY2luZztcbiAgICAgICAgaWYgKGxldHRlclNwYWNpbmcgPT09IDApIHtcbiAgICAgICAgICAgIGlmIChpc1N0cm9rZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5zdHJva2VUZXh0KHRleHQsIHgsIHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmZpbGxUZXh0KHRleHQsIHgsIHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjaGFyYWN0ZXJzID0gU3RyaW5nLnByb3RvdHlwZS5zcGxpdC5jYWxsKHRleHQsICcnKTtcbiAgICAgICAgdmFyIGN1cnJlbnRQb3NpdGlvbiA9IHg7XG4gICAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICAgIHZhciBjdXJyZW50ID0gJyc7XG4gICAgICAgIHdoaWxlIChpbmRleCA8IHRleHQubGVuZ3RoKSB7XG4gICAgICAgICAgICBjdXJyZW50ID0gY2hhcmFjdGVyc1tpbmRleCsrXTtcbiAgICAgICAgICAgIGlmIChpc1N0cm9rZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5zdHJva2VUZXh0KGN1cnJlbnQsIGN1cnJlbnRQb3NpdGlvbiwgeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuZmlsbFRleHQoY3VycmVudCwgY3VycmVudFBvc2l0aW9uLCB5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnRQb3NpdGlvbiArPSB0aGlzLmNvbnRleHQubWVhc3VyZVRleHQoY3VycmVudCkud2lkdGggKyBsZXR0ZXJTcGFjaW5nO1xuICAgICAgICB9XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRleHR1cmUgc2l6ZSBiYXNlZCBvbiBjYW52YXMgc2l6ZVxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB1cGRhdGVUZXh0dXJlKCkge1xuICAgICAgICB2YXIgY2FudmFzID0gdGhpcy5jYW52YXM7XG4gICAgICAgIGlmICh0aGlzLl9zdHlsZS50cmltKSB7XG4gICAgICAgICAgICB2YXIgdHJpbW1lZCA9IENhbnZhc1NldHRpbmdzXzEuQ2FudmFzU2V0dGluZ3MudHJpbUNhbnZhcyhjYW52YXMpO1xuICAgICAgICAgICAgaWYgKHRyaW1tZWQuZGF0YSkge1xuICAgICAgICAgICAgICAgIGNhbnZhcy53aWR0aCA9IHRyaW1tZWQud2lkdGg7XG4gICAgICAgICAgICAgICAgY2FudmFzLmhlaWdodCA9IHRyaW1tZWQuaGVpZ2h0O1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5wdXRJbWFnZURhdGEodHJpbW1lZC5kYXRhLCAwLCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgdGV4dHVyZSA9IHRoaXMuX3RleHR1cmU7XG4gICAgICAgIHZhciBzdHlsZSA9IHRoaXMuX3N0eWxlO1xuICAgICAgICB2YXIgcGFkZGluZyA9IHN0eWxlLnRyaW0gPyAwIDogc3R5bGUucGFkZGluZztcbiAgICAgICAgdmFyIGJhc2VUZXh0dXJlID0gdGV4dHVyZS5iYXNlVGV4dHVyZTtcbiAgICAgICAgdGV4dHVyZS50cmltLndpZHRoID0gdGV4dHVyZS5fZnJhbWUud2lkdGggPSBjYW52YXMud2lkdGggLyB0aGlzLl9yZXNvbHV0aW9uO1xuICAgICAgICB0ZXh0dXJlLnRyaW0uaGVpZ2h0ID0gdGV4dHVyZS5fZnJhbWUuaGVpZ2h0ID0gY2FudmFzLmhlaWdodCAvIHRoaXMuX3Jlc29sdXRpb247XG4gICAgICAgIHRleHR1cmUudHJpbS54ID0gLXBhZGRpbmc7XG4gICAgICAgIHRleHR1cmUudHJpbS55ID0gLXBhZGRpbmc7XG4gICAgICAgIHRleHR1cmUub3JpZy53aWR0aCA9IHRleHR1cmUuX2ZyYW1lLndpZHRoIC0gKHBhZGRpbmcgKiAyKTtcbiAgICAgICAgdGV4dHVyZS5vcmlnLmhlaWdodCA9IHRleHR1cmUuX2ZyYW1lLmhlaWdodCAtIChwYWRkaW5nICogMik7XG4gICAgICAgIC8vIGNhbGwgc3ByaXRlIG9uVGV4dHVyZVVwZGF0ZSB0byB1cGRhdGUgc2NhbGUgaWYgX3dpZHRoIG9yIF9oZWlnaHQgd2VyZSBzZXRcbiAgICAgICAgdGhpcy5fb25UZXh0dXJlVXBkYXRlKCk7XG4gICAgICAgIGJhc2VUZXh0dXJlLnNldFJlYWxTaXplKGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCwgdGhpcy5fcmVzb2x1dGlvbik7XG4gICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgdGhlIG9iamVjdCB1c2luZyB0aGUgV2ViR0wgcmVuZGVyZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UElYSS5SZW5kZXJlcn0gcmVuZGVyZXIgLSBUaGUgcmVuZGVyZXJcbiAgICAgKi9cbiAgICByZW5kZXIocmVuZGVyZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuX2F1dG9SZXNvbHV0aW9uICYmIHRoaXMuX3Jlc29sdXRpb24gIT09IHJlbmRlcmVyLnJlc29sdXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuX3Jlc29sdXRpb24gPSByZW5kZXJlci5yZXNvbHV0aW9uO1xuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51cGRhdGVUZXh0KHRydWUpO1xuICAgICAgICBzdXBlci5yZW5kZXIocmVuZGVyZXIpO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogUmVuZGVycyB0aGUgb2JqZWN0IHVzaW5nIHRoZSBDYW52YXMgcmVuZGVyZXJcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtQSVhJLkNhbnZhc1JlbmRlcmVyfSByZW5kZXJlciAtIFRoZSByZW5kZXJlclxuICAgICAqL1xuICAgIF9yZW5kZXJDYW52YXMocmVuZGVyZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuX2F1dG9SZXNvbHV0aW9uICYmIHRoaXMuX3Jlc29sdXRpb24gIT09IHJlbmRlcmVyLnJlc29sdXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuX3Jlc29sdXRpb24gPSByZW5kZXJlci5yZXNvbHV0aW9uO1xuICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51cGRhdGVUZXh0KHRydWUpO1xuICAgICAgICAvLyBzdXBlci5fcmVuZGVyQ2FudmFzKHJlbmRlcmVyKTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGxvY2FsIGJvdW5kcyBvZiB0aGUgdGV4dCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1JlY3RhbmdsZX0gcmVjdCAtIFRoZSBvdXRwdXQgcmVjdGFuZ2xlLlxuICAgICAqIEByZXR1cm4ge1JlY3RhbmdsZX0gVGhlIGJvdW5kcy5cbiAgICAgKi9cbiAgICBnZXRMb2NhbEJvdW5kcyhyZWN0KSB7XG4gICAgICAgIHRoaXMudXBkYXRlVGV4dCh0cnVlKTtcbiAgICAgICAgcmV0dXJuIHN1cGVyLmdldExvY2FsQm91bmRzKHJlY3QpO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogY2FsY3VsYXRlcyB0aGUgYm91bmRzIG9mIHRoZSBUZXh0IGFzIGEgcmVjdGFuZ2xlLiBUaGUgYm91bmRzIGNhbGN1bGF0aW9uIHRha2VzIHRoZSB3b3JsZFRyYW5zZm9ybSBpbnRvIGFjY291bnQuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9jYWxjdWxhdGVCb3VuZHMoKSB7XG4gICAgICAgIHRoaXMudXBkYXRlVGV4dCh0cnVlKTtcbiAgICAgICAgdGhpcy5jYWxjdWxhdGVWZXJ0aWNlcygpO1xuICAgICAgICAvLyBpZiB3ZSBoYXZlIGFscmVhZHkgZG9uZSB0aGlzIG9uIFRISVMgZnJhbWUuXG4gICAgICAgIHRoaXMuX2JvdW5kcy5hZGRRdWFkKHRoaXMudmVydGV4RGF0YSk7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBNZXRob2QgdG8gYmUgY2FsbGVkIHVwb24gYSBUZXh0U3R5bGUgY2hhbmdlLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX29uU3R5bGVDaGFuZ2UoKSB7XG4gICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIHRoZSBmaWxsIHN0eWxlLiBDYW4gYXV0b21hdGljYWxseSBnZW5lcmF0ZSBhIGdyYWRpZW50IGJhc2VkIG9uIHRoZSBmaWxsIHN0eWxlIGJlaW5nIGFuIGFycmF5XG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzdHlsZSAtIFRoZSBzdHlsZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBsaW5lcyAtIFRoZSBsaW5lcyBvZiB0ZXh0LlxuICAgICAqIEByZXR1cm4ge3N0cmluZ3xudW1iZXJ8Q2FudmFzR3JhZGllbnR9IFRoZSBmaWxsIHN0eWxlXG4gICAgICovXG4gICAgX2dlbmVyYXRlRmlsbFN0eWxlKHN0eWxlLCBsaW5lcykge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoc3R5bGUuZmlsbCkpIHtcbiAgICAgICAgICAgIHJldHVybiBzdHlsZS5maWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRoZSBncmFkaWVudCB3aWxsIGJlIGV2ZW5seSBzcGFjZWQgb3V0IGFjY29yZGluZyB0byBob3cgbGFyZ2UgdGhlIGFycmF5IGlzLlxuICAgICAgICAvLyBbJyNGRjAwMDAnLCAnIzAwRkYwMCcsICcjMDAwMEZGJ10gd291bGQgY3JlYXRlZCBzdG9wcyBhdCAwLjI1LCAwLjUgYW5kIDAuNzVcbiAgICAgICAgdmFyIGdyYWRpZW50O1xuICAgICAgICB2YXIgdG90YWxJdGVyYXRpb25zO1xuICAgICAgICB2YXIgY3VycmVudEl0ZXJhdGlvbjtcbiAgICAgICAgdmFyIHN0b3A7XG4gICAgICAgIHZhciB3aWR0aCA9IHRoaXMuY2FudmFzLndpZHRoIC8gdGhpcy5fcmVzb2x1dGlvbjtcbiAgICAgICAgdmFyIGhlaWdodCA9IHRoaXMuY2FudmFzLmhlaWdodCAvIHRoaXMuX3Jlc29sdXRpb247XG4gICAgICAgIC8vIG1ha2UgYSBjb3B5IG9mIHRoZSBzdHlsZSBzZXR0aW5ncywgc28gd2UgY2FuIG1hbmlwdWxhdGUgdGhlbSBsYXRlclxuICAgICAgICB2YXIgZmlsbCA9IHN0eWxlLmZpbGwuc2xpY2UoKTtcbiAgICAgICAgdmFyIGZpbGxHcmFkaWVudFN0b3BzID0gc3R5bGUuZmlsbEdyYWRpZW50U3RvcHMuc2xpY2UoKTtcbiAgICAgICAgLy8gd2FudGluZyB0byBldmVubHkgZGlzdHJpYnV0ZSB0aGUgZmlsbHMuIFNvIGFuIGFycmF5IG9mIDQgY29sb3VycyBzaG91bGQgZ2l2ZSBmaWxscyBvZiAwLjI1LCAwLjUgYW5kIDAuNzVcbiAgICAgICAgaWYgKCFmaWxsR3JhZGllbnRTdG9wcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBsZW5ndGhQbHVzMSA9IGZpbGwubGVuZ3RoICsgMTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgbGVuZ3RoUGx1czE7ICsraSkge1xuICAgICAgICAgICAgICAgIGZpbGxHcmFkaWVudFN0b3BzLnB1c2goaSAvIGxlbmd0aFBsdXMxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBzdG9wIHRoZSBibGVlZGluZyBvZiB0aGUgbGFzdCBncmFkaWVudCBvbiB0aGUgbGluZSBhYm92ZSB0byB0aGUgdG9wIGdyYWRpZW50IG9mIHRoZSB0aGlzIGxpbmVcbiAgICAgICAgLy8gYnkgaGFyZCBkZWZpbmluZyB0aGUgZmlyc3QgZ3JhZGllbnQgY29sb3VyIGF0IHBvaW50IDAsIGFuZCBsYXN0IGdyYWRpZW50IGNvbG91ciBhdCBwb2ludCAxXG4gICAgICAgIGZpbGwudW5zaGlmdChzdHlsZS5maWxsWzBdKTtcbiAgICAgICAgZmlsbEdyYWRpZW50U3RvcHMudW5zaGlmdCgwKTtcbiAgICAgICAgZmlsbC5wdXNoKHN0eWxlLmZpbGxbc3R5bGUuZmlsbC5sZW5ndGggLSAxXSk7XG4gICAgICAgIGZpbGxHcmFkaWVudFN0b3BzLnB1c2goMSk7XG4gICAgICAgIGlmIChzdHlsZS5maWxsR3JhZGllbnRUeXBlID09PSBUZXh0U2V0dGluZ3NfMS5UZXh0U2V0dGluZ3MuVEVYVF9HUkFESUVOVC5MSU5FQVJfVkVSVElDQUwpIHtcbiAgICAgICAgICAgIC8vIHN0YXJ0IHRoZSBncmFkaWVudCBhdCB0aGUgdG9wIGNlbnRlciBvZiB0aGUgY2FudmFzLCBhbmQgZW5kIGF0IHRoZSBib3R0b20gbWlkZGxlIG9mIHRoZSBjYW52YXNcbiAgICAgICAgICAgIGdyYWRpZW50ID0gdGhpcy5jb250ZXh0LmNyZWF0ZUxpbmVhckdyYWRpZW50KHdpZHRoIC8gMiwgMCwgd2lkdGggLyAyLCBoZWlnaHQpO1xuICAgICAgICAgICAgLy8gd2UgbmVlZCB0byByZXBlYXQgdGhlIGdyYWRpZW50IHNvIHRoYXQgZWFjaCBpbmRpdmlkdWFsIGxpbmUgb2YgdGV4dCBoYXMgdGhlIHNhbWUgdmVydGljYWwgZ3JhZGllbnQgZWZmZWN0XG4gICAgICAgICAgICAvLyBbJyNGRjAwMDAnLCAnIzAwRkYwMCcsICcjMDAwMEZGJ10gb3ZlciAyIGxpbmVzIHdvdWxkIGNyZWF0ZSBzdG9wcyBhdCAwLjEyNSwgMC4yNSwgMC4zNzUsIDAuNjI1LCAwLjc1LCAwLjg3NVxuICAgICAgICAgICAgdG90YWxJdGVyYXRpb25zID0gKGZpbGwubGVuZ3RoICsgMSkgKiBsaW5lcy5sZW5ndGg7XG4gICAgICAgICAgICBjdXJyZW50SXRlcmF0aW9uID0gMDtcbiAgICAgICAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGxpbmVzLmxlbmd0aDsgaSQxKyspIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50SXRlcmF0aW9uICs9IDE7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBmaWxsLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZmlsbEdyYWRpZW50U3RvcHNbal0gPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdG9wID0gKGZpbGxHcmFkaWVudFN0b3BzW2pdIC8gbGluZXMubGVuZ3RoKSArIChpJDEgLyBsaW5lcy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RvcCA9IGN1cnJlbnRJdGVyYXRpb24gLyB0b3RhbEl0ZXJhdGlvbnM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZ3JhZGllbnQuYWRkQ29sb3JTdG9wKHN0b3AsIGZpbGxbal0pO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50SXRlcmF0aW9uKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gc3RhcnQgdGhlIGdyYWRpZW50IGF0IHRoZSBjZW50ZXIgbGVmdCBvZiB0aGUgY2FudmFzLCBhbmQgZW5kIGF0IHRoZSBjZW50ZXIgcmlnaHQgb2YgdGhlIGNhbnZhc1xuICAgICAgICAgICAgZ3JhZGllbnQgPSB0aGlzLmNvbnRleHQuY3JlYXRlTGluZWFyR3JhZGllbnQoMCwgaGVpZ2h0IC8gMiwgd2lkdGgsIGhlaWdodCAvIDIpO1xuICAgICAgICAgICAgLy8gY2FuIGp1c3QgZXZlbmx5IHNwYWNlIG91dCB0aGUgZ3JhZGllbnRzIGluIHRoaXMgY2FzZSwgYXMgbXVsdGlwbGUgbGluZXMgbWFrZXMgbm8gZGlmZmVyZW5jZVxuICAgICAgICAgICAgLy8gdG8gYW4gZXZlbiBsZWZ0IHRvIHJpZ2h0IGdyYWRpZW50XG4gICAgICAgICAgICB0b3RhbEl0ZXJhdGlvbnMgPSBmaWxsLmxlbmd0aCArIDE7XG4gICAgICAgICAgICBjdXJyZW50SXRlcmF0aW9uID0gMTtcbiAgICAgICAgICAgIGZvciAodmFyIGkkMiA9IDA7IGkkMiA8IGZpbGwubGVuZ3RoOyBpJDIrKykge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZmlsbEdyYWRpZW50U3RvcHNbaSQyXSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RvcCA9IGZpbGxHcmFkaWVudFN0b3BzW2kkMl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzdG9wID0gY3VycmVudEl0ZXJhdGlvbiAvIHRvdGFsSXRlcmF0aW9ucztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZ3JhZGllbnQuYWRkQ29sb3JTdG9wKHN0b3AsIGZpbGxbaSQyXSk7XG4gICAgICAgICAgICAgICAgY3VycmVudEl0ZXJhdGlvbisrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBncmFkaWVudDtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIERlc3Ryb3lzIHRoaXMgdGV4dCBvYmplY3QuXG4gICAgICogTm90ZSogVW5saWtlIGEgU3ByaXRlLCBhIFRleHQgb2JqZWN0IHdpbGwgYXV0b21hdGljYWxseSBkZXN0cm95IGl0cyBiYXNlVGV4dHVyZSBhbmQgdGV4dHVyZSBhc1xuICAgICAqIHRoZSBtYWpvcml0eSBvZiB0aGUgdGltZSB0aGUgdGV4dHVyZSB3aWxsIG5vdCBiZSBzaGFyZWQgd2l0aCBhbnkgb3RoZXIgU3ByaXRlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fGJvb2xlYW59IFtvcHRpb25zXSAtIE9wdGlvbnMgcGFyYW1ldGVyLiBBIGJvb2xlYW4gd2lsbCBhY3QgYXMgaWYgYWxsIG9wdGlvbnNcbiAgICAgKiAgaGF2ZSBiZWVuIHNldCB0byB0aGF0IHZhbHVlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jaGlsZHJlbj1mYWxzZV0gLSBpZiBzZXQgdG8gdHJ1ZSwgYWxsIHRoZSBjaGlsZHJlbiB3aWxsIGhhdmUgdGhlaXJcbiAgICAgKiAgZGVzdHJveSBtZXRob2QgY2FsbGVkIGFzIHdlbGwuICdvcHRpb25zJyB3aWxsIGJlIHBhc3NlZCBvbiB0byB0aG9zZSBjYWxscy5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRleHR1cmU9dHJ1ZV0gLSBTaG91bGQgaXQgZGVzdHJveSB0aGUgY3VycmVudCB0ZXh0dXJlIG9mIHRoZSBzcHJpdGUgYXMgd2VsbFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuYmFzZVRleHR1cmU9dHJ1ZV0gLSBTaG91bGQgaXQgZGVzdHJveSB0aGUgYmFzZSB0ZXh0dXJlIG9mIHRoZSBzcHJpdGUgYXMgd2VsbFxuICAgICAqL1xuICAgIGRlc3Ryb3kob3B0aW9ucykge1xuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgb3B0aW9ucyA9IHsgY2hpbGRyZW46IG9wdGlvbnMgfTtcbiAgICAgICAgfVxuICAgICAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgQ2xlYW5VcFNldHRpbmdzXzEuQ2xlYW5VcFNldHRpbmdzLmRlZmF1bHREZXN0cm95T3B0aW9ucywgb3B0aW9ucyk7XG4gICAgICAgIHN1cGVyLmRlc3Ryb3kob3B0aW9ucyk7XG4gICAgICAgIC8vIG1ha2Ugc3VyZSB0byByZXNldCB0aGUgdGhlIGNvbnRleHQgYW5kIGNhbnZhcy4uIGRvbnQgd2FudCB0aGlzIGhhbmdpbmcgYXJvdW5kIGluIG1lbW9yeSFcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5jYW52YXMgPSBudWxsO1xuICAgICAgICB0aGlzLl9zdHlsZSA9IG51bGw7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBUaGUgd2lkdGggb2YgdGhlIFRleHQsIHNldHRpbmcgdGhpcyB3aWxsIGFjdHVhbGx5IG1vZGlmeSB0aGUgc2NhbGUgdG8gYWNoaWV2ZSB0aGUgdmFsdWUgc2V0XG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICovXG4gICAgZ2V0IHdpZHRoKCkge1xuICAgICAgICB0aGlzLnVwZGF0ZVRleHQodHJ1ZSk7XG4gICAgICAgIHJldHVybiBNYXRoLmFicyh0aGlzLnNjYWxlLngpICogdGhpcy5fdGV4dHVyZS5vcmlnLndpZHRoO1xuICAgIH1cbiAgICA7XG4gICAgc2V0IHdpZHRoKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudXBkYXRlVGV4dCh0cnVlKTtcbiAgICAgICAgdmFyIHMgPSBNYXRoU2V0dGluZ3NfMS5NYXRoU2V0dGluZ3Muc2lnbih0aGlzLnNjYWxlLngpIHx8IDE7XG4gICAgICAgIHRoaXMuc2NhbGUueCA9IHMgKiB2YWx1ZSAvIHRoaXMuX3RleHR1cmUub3JpZy53aWR0aDtcbiAgICAgICAgdGhpcy5fd2lkdGggPSB2YWx1ZTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFRoZSBoZWlnaHQgb2YgdGhlIFRleHQsIHNldHRpbmcgdGhpcyB3aWxsIGFjdHVhbGx5IG1vZGlmeSB0aGUgc2NhbGUgdG8gYWNoaWV2ZSB0aGUgdmFsdWUgc2V0XG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICovXG4gICAgZ2V0IGhlaWdodCgpIHtcbiAgICAgICAgdGhpcy51cGRhdGVUZXh0KHRydWUpO1xuICAgICAgICByZXR1cm4gTWF0aC5hYnModGhpcy5zY2FsZS55KSAqIHRoaXMuX3RleHR1cmUub3JpZy5oZWlnaHQ7XG4gICAgfVxuICAgIDtcbiAgICBzZXQgaGVpZ2h0KHZhbHVlKSB7XG4gICAgICAgIHRoaXMudXBkYXRlVGV4dCh0cnVlKTtcbiAgICAgICAgdmFyIHMgPSBNYXRoU2V0dGluZ3NfMS5NYXRoU2V0dGluZ3Muc2lnbih0aGlzLnNjYWxlLnkpIHx8IDE7XG4gICAgICAgIHRoaXMuc2NhbGUueSA9IHMgKiB2YWx1ZSAvIHRoaXMuX3RleHR1cmUub3JpZy5oZWlnaHQ7XG4gICAgICAgIHRoaXMuX2hlaWdodCA9IHZhbHVlO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBzdHlsZSBvZiB0aGUgdGV4dC4gU2V0IHVwIGFuIGV2ZW50IGxpc3RlbmVyIHRvIGxpc3RlbiBmb3IgY2hhbmdlcyBvbiB0aGUgc3R5bGVcbiAgICAgKiBvYmplY3QgYW5kIG1hcmsgdGhlIHRleHQgYXMgZGlydHkuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtvYmplY3R8UElYSS5UZXh0U3R5bGV9XG4gICAgICovXG4gICAgZ2V0IHN0eWxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3R5bGU7XG4gICAgfVxuICAgIDtcbiAgICBzZXQgc3R5bGUoc3R5bGUpIHtcbiAgICAgICAgc3R5bGUgPSBzdHlsZSB8fCB7fTtcbiAgICAgICAgaWYgKHN0eWxlIGluc3RhbmNlb2YgVGV4dFN0eWxlXzEuVGV4dFN0eWxlKSB7XG4gICAgICAgICAgICB0aGlzLl9zdHlsZSA9IHN0eWxlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fc3R5bGUgPSBuZXcgVGV4dFN0eWxlXzEuVGV4dFN0eWxlKHN0eWxlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxvY2FsU3R5bGVJRCA9IC0xO1xuICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFNldCB0aGUgY29weSBmb3IgdGhlIHRleHQgb2JqZWN0LiBUbyBzcGxpdCBhIGxpbmUgeW91IGNhbiB1c2UgJ1xcbicuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtzdHJpbmd9XG4gICAgICovXG4gICAgZ2V0IHRleHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90ZXh0O1xuICAgIH1cbiAgICA7XG4gICAgc2V0IHRleHQodGV4dCkge1xuICAgICAgICB0ZXh0ID0gU3RyaW5nKHRleHQgPT09IG51bGwgfHwgdGV4dCA9PT0gdW5kZWZpbmVkID8gJycgOiB0ZXh0KTtcbiAgICAgICAgaWYgKHRoaXMuX3RleHQgPT09IHRleHQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl90ZXh0ID0gdGV4dDtcbiAgICAgICAgdGhpcy5kaXJ0eSA9IHRydWU7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBUaGUgcmVzb2x1dGlvbiAvIGRldmljZSBwaXhlbCByYXRpbyBvZiB0aGUgY2FudmFzLlxuICAgICAqIFRoaXMgaXMgc2V0IHRvIGF1dG9tYXRpY2FsbHkgbWF0Y2ggdGhlIHJlbmRlcmVyIHJlc29sdXRpb24gYnkgZGVmYXVsdCwgYnV0IGNhbiBiZSBvdmVycmlkZGVuIGJ5IHNldHRpbmcgbWFudWFsbHkuXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IDFcbiAgICAgKi9cbiAgICBnZXQgcmVzb2x1dGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Jlc29sdXRpb247XG4gICAgfVxuICAgIDtcbiAgICBzZXQgcmVzb2x1dGlvbih2YWx1ZSkge1xuICAgICAgICB0aGlzLl9hdXRvUmVzb2x1dGlvbiA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5fcmVzb2x1dGlvbiA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9yZXNvbHV0aW9uID0gdmFsdWU7XG4gICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgIH1cbiAgICA7XG59XG5leHBvcnRzLlRleHQgPSBUZXh0O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jbGFzcyBUZXh0TWV0cmljcyB7XG4gICAgY29uc3RydWN0b3IodGV4dCwgc3R5bGUsIHdpZHRoLCBoZWlnaHQsIGxpbmVzLCBsaW5lV2lkdGhzLCBsaW5lSGVpZ2h0LCBtYXhMaW5lV2lkdGgsIGZvbnRQcm9wZXJ0aWVzKSB7XG4gICAgICAgIGlmICghVGV4dE1ldHJpY3MuY2FudmFzKSB7XG4gICAgICAgICAgICBUZXh0TWV0cmljcy5jYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgICAgIFRleHRNZXRyaWNzLmNhbnZhcy53aWR0aCA9IFRleHRNZXRyaWNzLmNhbnZhcy5oZWlnaHQgPSAxMDtcbiAgICAgICAgICAgIFRleHRNZXRyaWNzLl9jYW52YXMgPSBUZXh0TWV0cmljcy5jYW52YXM7XG4gICAgICAgICAgICBUZXh0TWV0cmljcy5fY29udGV4dCA9IFRleHRNZXRyaWNzLmNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudGV4dCA9IHRleHQ7XG4gICAgICAgIHRoaXMuc3R5bGUgPSBzdHlsZTtcbiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgdGhpcy5saW5lcyA9IGxpbmVzO1xuICAgICAgICB0aGlzLmxpbmVXaWR0aHMgPSBsaW5lV2lkdGhzO1xuICAgICAgICB0aGlzLmxpbmVIZWlnaHQgPSBsaW5lSGVpZ2h0O1xuICAgICAgICB0aGlzLm1heExpbmVXaWR0aCA9IG1heExpbmVXaWR0aDtcbiAgICAgICAgdGhpcy5mb250UHJvcGVydGllcyA9IGZvbnRQcm9wZXJ0aWVzO1xuICAgIH1cbiAgICBzdGF0aWMgaW5pdCgpIHtcbiAgICAgICAgaWYgKCFUZXh0TWV0cmljcy5jYW52YXMpIHtcbiAgICAgICAgICAgIFRleHRNZXRyaWNzLmNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICAgICAgVGV4dE1ldHJpY3MuY2FudmFzLndpZHRoID0gVGV4dE1ldHJpY3MuY2FudmFzLmhlaWdodCA9IDEwO1xuICAgICAgICAgICAgVGV4dE1ldHJpY3MuX2NhbnZhcyA9IFRleHRNZXRyaWNzLmNhbnZhcztcbiAgICAgICAgICAgIFRleHRNZXRyaWNzLl9jb250ZXh0ID0gVGV4dE1ldHJpY3MuY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogTWVhc3VyZXMgdGhlIHN1cHBsaWVkIHN0cmluZyBvZiB0ZXh0IGFuZCByZXR1cm5zIGEgUmVjdGFuZ2xlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgLSB0aGUgdGV4dCB0byBtZWFzdXJlLlxuICAgICAqIEBwYXJhbSB7UElYSS5UZXh0U3R5bGV9IHN0eWxlIC0gdGhlIHRleHQgc3R5bGUgdG8gdXNlIGZvciBtZWFzdXJpbmdcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFt3b3JkV3JhcF0gLSBvcHRpb25hbCBvdmVycmlkZSBmb3IgaWYgd29yZC13cmFwIHNob3VsZCBiZSBhcHBsaWVkIHRvIHRoZSB0ZXh0LlxuICAgICAqIEBwYXJhbSB7SFRNTENhbnZhc0VsZW1lbnR9IFtjYW52YXNdIC0gb3B0aW9uYWwgc3BlY2lmaWNhdGlvbiBvZiB0aGUgY2FudmFzIHRvIHVzZSBmb3IgbWVhc3VyaW5nLlxuICAgICAqIEByZXR1cm4ge1BJWEkuVGV4dE1ldHJpY3N9IG1lYXN1cmVkIHdpZHRoIGFuZCBoZWlnaHQgb2YgdGhlIHRleHQuXG4gICAgICovXG4gICAgc3RhdGljIG1lYXN1cmVUZXh0KHRleHQsIHN0eWxlLCB3b3JkV3JhcCwgY2FudmFzID0gVGV4dE1ldHJpY3MuX2NhbnZhcykge1xuICAgICAgICB3b3JkV3JhcCA9ICh3b3JkV3JhcCA9PT0gdW5kZWZpbmVkIHx8IHdvcmRXcmFwID09PSBudWxsKSA/IHN0eWxlLndvcmRXcmFwIDogd29yZFdyYXA7XG4gICAgICAgIHZhciBmb250ID0gc3R5bGUudG9Gb250U3RyaW5nKCk7XG4gICAgICAgIHZhciBmb250UHJvcGVydGllcyA9IFRleHRNZXRyaWNzLm1lYXN1cmVGb250KGZvbnQpO1xuICAgICAgICAvLyBmYWxsYmFjayBpbiBjYXNlIFVBIGRpc2FsbG93IGNhbnZhcyBkYXRhIGV4dHJhY3Rpb25cbiAgICAgICAgLy8gKHRvRGF0YVVSSSwgZ2V0SW1hZ2VEYXRhIGZ1bmN0aW9ucylcbiAgICAgICAgaWYgKGZvbnRQcm9wZXJ0aWVzLmZvbnRTaXplID09PSAwKSB7XG4gICAgICAgICAgICBmb250UHJvcGVydGllcy5mb250U2l6ZSA9IHN0eWxlLmZvbnRTaXplO1xuICAgICAgICAgICAgZm9udFByb3BlcnRpZXMuYXNjZW50ID0gc3R5bGUuZm9udFNpemU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgY29udGV4dC5mb250ID0gZm9udDtcbiAgICAgICAgdmFyIG91dHB1dFRleHQgPSB3b3JkV3JhcCA/IFRleHRNZXRyaWNzLndvcmRXcmFwKHRleHQsIHN0eWxlLCBjYW52YXMpIDogdGV4dDtcbiAgICAgICAgdmFyIGxpbmVzID0gb3V0cHV0VGV4dC5zcGxpdCgvKD86XFxyXFxufFxccnxcXG4pLyk7XG4gICAgICAgIHZhciBsaW5lV2lkdGhzID0gbmV3IEFycmF5KGxpbmVzLmxlbmd0aCk7XG4gICAgICAgIHZhciBtYXhMaW5lV2lkdGggPSAwO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgbGluZVdpZHRoID0gY29udGV4dC5tZWFzdXJlVGV4dChsaW5lc1tpXSkud2lkdGggKyAoKGxpbmVzW2ldLmxlbmd0aCAtIDEpICogc3R5bGUubGV0dGVyU3BhY2luZyk7XG4gICAgICAgICAgICBsaW5lV2lkdGhzW2ldID0gbGluZVdpZHRoO1xuICAgICAgICAgICAgbWF4TGluZVdpZHRoID0gTWF0aC5tYXgobWF4TGluZVdpZHRoLCBsaW5lV2lkdGgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB3aWR0aCA9IG1heExpbmVXaWR0aCArIHN0eWxlLnN0cm9rZVRoaWNrbmVzcztcbiAgICAgICAgaWYgKHN0eWxlLmRyb3BTaGFkb3cpIHtcbiAgICAgICAgICAgIHdpZHRoICs9IHN0eWxlLmRyb3BTaGFkb3dEaXN0YW5jZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGluZUhlaWdodCA9IHN0eWxlLmxpbmVIZWlnaHQgfHwgZm9udFByb3BlcnRpZXMuZm9udFNpemUgKyBzdHlsZS5zdHJva2VUaGlja25lc3M7XG4gICAgICAgIHZhciBoZWlnaHQgPSBNYXRoLm1heChsaW5lSGVpZ2h0LCBmb250UHJvcGVydGllcy5mb250U2l6ZSArIHN0eWxlLnN0cm9rZVRoaWNrbmVzcylcbiAgICAgICAgICAgICsgKChsaW5lcy5sZW5ndGggLSAxKSAqIChsaW5lSGVpZ2h0ICsgc3R5bGUubGVhZGluZykpO1xuICAgICAgICBpZiAoc3R5bGUuZHJvcFNoYWRvdykge1xuICAgICAgICAgICAgaGVpZ2h0ICs9IHN0eWxlLmRyb3BTaGFkb3dEaXN0YW5jZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFRleHRNZXRyaWNzKHRleHQsIHN0eWxlLCB3aWR0aCwgaGVpZ2h0LCBsaW5lcywgbGluZVdpZHRocywgbGluZUhlaWdodCArIHN0eWxlLmxlYWRpbmcsIG1heExpbmVXaWR0aCwgZm9udFByb3BlcnRpZXMpO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogQXBwbGllcyBuZXdsaW5lcyB0byBhIHN0cmluZyB0byBoYXZlIGl0IG9wdGltYWxseSBmaXQgaW50byB0aGUgaG9yaXpvbnRhbFxuICAgICAqIGJvdW5kcyBzZXQgYnkgdGhlIFRleHQgb2JqZWN0J3Mgd29yZFdyYXBXaWR0aCBwcm9wZXJ0eS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgLSBTdHJpbmcgdG8gYXBwbHkgd29yZCB3cmFwcGluZyB0b1xuICAgICAqIEBwYXJhbSB7UElYSS5UZXh0U3R5bGV9IHN0eWxlIC0gdGhlIHN0eWxlIHRvIHVzZSB3aGVuIHdyYXBwaW5nXG4gICAgICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudH0gW2NhbnZhc10gLSBvcHRpb25hbCBzcGVjaWZpY2F0aW9uIG9mIHRoZSBjYW52YXMgdG8gdXNlIGZvciBtZWFzdXJpbmcuXG4gICAgICogQHJldHVybiB7c3RyaW5nfSBOZXcgc3RyaW5nIHdpdGggbmV3IGxpbmVzIGFwcGxpZWQgd2hlcmUgcmVxdWlyZWRcbiAgICAgKi9cbiAgICBzdGF0aWMgd29yZFdyYXAodGV4dCwgc3R5bGUsIGNhbnZhcykge1xuICAgICAgICBpZiAoY2FudmFzID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIGNhbnZhcyA9IFRleHRNZXRyaWNzLl9jYW52YXM7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgdmFyIHdpZHRoID0gMDtcbiAgICAgICAgdmFyIGxpbmUgPSAnJztcbiAgICAgICAgdmFyIGxpbmVzID0gJyc7XG4gICAgICAgIHZhciBjYWNoZSA9IHt9O1xuICAgICAgICB2YXIgbGV0dGVyU3BhY2luZyA9IHN0eWxlLmxldHRlclNwYWNpbmc7XG4gICAgICAgIHZhciB3aGl0ZVNwYWNlID0gc3R5bGUud2hpdGVTcGFjZTtcbiAgICAgICAgLy8gSG93IHRvIGhhbmRsZSB3aGl0ZXNwYWNlc1xuICAgICAgICB2YXIgY29sbGFwc2VTcGFjZXMgPSBUZXh0TWV0cmljcy5jb2xsYXBzZVNwYWNlcyh3aGl0ZVNwYWNlKTtcbiAgICAgICAgdmFyIGNvbGxhcHNlTmV3bGluZXMgPSBUZXh0TWV0cmljcy5jb2xsYXBzZU5ld2xpbmVzKHdoaXRlU3BhY2UpO1xuICAgICAgICAvLyB3aGV0aGVyIG9yIG5vdCBzcGFjZXMgbWF5IGJlIGFkZGVkIHRvIHRoZSBiZWdpbm5pbmcgb2YgbGluZXNcbiAgICAgICAgdmFyIGNhblByZXBlbmRTcGFjZXMgPSAhY29sbGFwc2VTcGFjZXM7XG4gICAgICAgIC8vIFRoZXJlIGlzIGxldHRlclNwYWNpbmcgYWZ0ZXIgZXZlcnkgY2hhciBleGNlcHQgdGhlIGxhc3Qgb25lXG4gICAgICAgIC8vIHRfaF9pX3NfJyAnX2lfc18nICdfYV9uXycgJ19lX3hfYV9tX3BfbF9lXycgJ18hXG4gICAgICAgIC8vIHNvIGZvciBjb252ZW5pZW5jZSB0aGUgYWJvdmUgbmVlZHMgdG8gYmUgY29tcGFyZWQgdG8gd2lkdGggKyAxIGV4dHJhIGxldHRlclNwYWNlXG4gICAgICAgIC8vIHRfaF9pX3NfJyAnX2lfc18nICdfYV9uXycgJ19lX3hfYV9tX3BfbF9lXycgJ18hX1xuICAgICAgICAvLyBfX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19cbiAgICAgICAgLy8gQW5kIHRoZW4gdGhlIGZpbmFsIHNwYWNlIGlzIHNpbXBseSBubyBhcHBlbmRlZCB0byBlYWNoIGxpbmVcbiAgICAgICAgdmFyIHdvcmRXcmFwV2lkdGggPSBzdHlsZS53b3JkV3JhcFdpZHRoICsgbGV0dGVyU3BhY2luZztcbiAgICAgICAgLy8gYnJlYWsgdGV4dCBpbnRvIHdvcmRzLCBzcGFjZXMgYW5kIG5ld2xpbmUgY2hhcnNcbiAgICAgICAgdmFyIHRva2VucyA9IFRleHRNZXRyaWNzLnRva2VuaXplKHRleHQpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgLy8gZ2V0IHRoZSB3b3JkLCBzcGFjZSBvciBuZXdsaW5lQ2hhclxuICAgICAgICAgICAgdmFyIHRva2VuID0gdG9rZW5zW2ldO1xuICAgICAgICAgICAgLy8gaWYgd29yZCBpcyBhIG5ldyBsaW5lXG4gICAgICAgICAgICBpZiAoVGV4dE1ldHJpY3MuaXNOZXdsaW5lKHRva2VuKSkge1xuICAgICAgICAgICAgICAgIC8vIGtlZXAgdGhlIG5ldyBsaW5lXG4gICAgICAgICAgICAgICAgaWYgKCFjb2xsYXBzZU5ld2xpbmVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpbmVzICs9IFRleHRNZXRyaWNzLmFkZExpbmUobGluZSk7XG4gICAgICAgICAgICAgICAgICAgIGNhblByZXBlbmRTcGFjZXMgPSAhY29sbGFwc2VTcGFjZXM7XG4gICAgICAgICAgICAgICAgICAgIGxpbmUgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgd2lkdGggPSAwO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gaWYgd2Ugc2hvdWxkIGNvbGxhcHNlIG5ldyBsaW5lc1xuICAgICAgICAgICAgICAgIC8vIHdlIHNpbXBseSBjb252ZXJ0IGl0IGludG8gYSBzcGFjZVxuICAgICAgICAgICAgICAgIHRva2VuID0gJyAnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaWYgd2Ugc2hvdWxkIGNvbGxhcHNlIHJlcGVhdGVkIHdoaXRlc3BhY2VzXG4gICAgICAgICAgICBpZiAoY29sbGFwc2VTcGFjZXMpIHtcbiAgICAgICAgICAgICAgICAvLyBjaGVjayBib3RoIHRoaXMgYW5kIHRoZSBsYXN0IHRva2VucyBmb3Igc3BhY2VzXG4gICAgICAgICAgICAgICAgdmFyIGN1cnJJc0JyZWFraW5nU3BhY2UgPSBUZXh0TWV0cmljcy5pc0JyZWFraW5nU3BhY2UodG9rZW4pO1xuICAgICAgICAgICAgICAgIHZhciBsYXN0SXNCcmVha2luZ1NwYWNlID0gVGV4dE1ldHJpY3MuaXNCcmVha2luZ1NwYWNlKGxpbmVbbGluZS5sZW5ndGggLSAxXSk7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJJc0JyZWFraW5nU3BhY2UgJiYgbGFzdElzQnJlYWtpbmdTcGFjZSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBnZXQgd29yZCB3aWR0aCBmcm9tIGNhY2hlIGlmIHBvc3NpYmxlXG4gICAgICAgICAgICB2YXIgdG9rZW5XaWR0aCA9IFRleHRNZXRyaWNzLmdldEZyb21DYWNoZSh0b2tlbiwgbGV0dGVyU3BhY2luZywgY2FjaGUsIGNvbnRleHQpO1xuICAgICAgICAgICAgLy8gd29yZCBpcyBsb25nZXIgdGhhbiBkZXNpcmVkIGJvdW5kc1xuICAgICAgICAgICAgaWYgKHRva2VuV2lkdGggPiB3b3JkV3JhcFdpZHRoKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgd2UgYXJlIG5vdCBhbHJlYWR5IGF0IHRoZSBiZWdpbm5pbmcgb2YgYSBsaW5lXG4gICAgICAgICAgICAgICAgaWYgKGxpbmUgIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHN0YXJ0IG5ld2xpbmVzIGZvciBvdmVyZmxvdyB3b3Jkc1xuICAgICAgICAgICAgICAgICAgICBsaW5lcyArPSBUZXh0TWV0cmljcy5hZGRMaW5lKGxpbmUpO1xuICAgICAgICAgICAgICAgICAgICBsaW5lID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIHdpZHRoID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gYnJlYWsgbGFyZ2Ugd29yZCBvdmVyIG11bHRpcGxlIGxpbmVzXG4gICAgICAgICAgICAgICAgaWYgKFRleHRNZXRyaWNzLmNhbkJyZWFrV29yZHModG9rZW4sIHN0eWxlLmJyZWFrV29yZHMpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGJyZWFrIHdvcmQgaW50byBjaGFyYWN0ZXJzXG4gICAgICAgICAgICAgICAgICAgIHZhciBjaGFyYWN0ZXJzID0gdG9rZW4uc3BsaXQoJycpO1xuICAgICAgICAgICAgICAgICAgICAvLyBsb29wIHRoZSBjaGFyYWN0ZXJzXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgY2hhcmFjdGVycy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNoYXIgPSBjaGFyYWN0ZXJzW2pdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGsgPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UgYXJlIG5vdCBhdCB0aGUgZW5kIG9mIHRoZSB0b2tlblxuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGNoYXJhY3RlcnNbaiArIGtdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5leHRDaGFyID0gY2hhcmFjdGVyc1tqICsga107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxhc3RDaGFyID0gY2hhcltjaGFyLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNob3VsZCBub3Qgc3BsaXQgY2hhcnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIVRleHRNZXRyaWNzLmNhbkJyZWFrQ2hhcnMobGFzdENoYXIsIG5leHRDaGFyLCB0b2tlbiwgaiwgc3R5bGUuYnJlYWtXb3JkcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29tYmluZSBjaGFycyAmIG1vdmUgZm9yd2FyZCBvbmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhciArPSBuZXh0Q2hhcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrKys7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBqICs9IGNoYXIubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjaGFyYWN0ZXJXaWR0aCA9IFRleHRNZXRyaWNzLmdldEZyb21DYWNoZShjaGFyLCBsZXR0ZXJTcGFjaW5nLCBjYWNoZSwgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hhcmFjdGVyV2lkdGggKyB3aWR0aCA+IHdvcmRXcmFwV2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lcyArPSBUZXh0TWV0cmljcy5hZGRMaW5lKGxpbmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhblByZXBlbmRTcGFjZXMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lID0gJyc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGggPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbGluZSArPSBjaGFyO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGggKz0gY2hhcmFjdGVyV2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gcnVuIHdvcmQgb3V0IG9mIHRoZSBib3VuZHNcbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlcmUgYXJlIHdvcmRzIGluIHRoaXMgbGluZSBhbHJlYWR5XG4gICAgICAgICAgICAgICAgICAgIC8vIGZpbmlzaCB0aGF0IGxpbmUgYW5kIHN0YXJ0IGEgbmV3IG9uZVxuICAgICAgICAgICAgICAgICAgICBpZiAobGluZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lcyArPSBUZXh0TWV0cmljcy5hZGRMaW5lKGxpbmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGluZSA9ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGggPSAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBpc0xhc3RUb2tlbiA9IGkgPT09IHRva2Vucy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgICAgICAvLyBnaXZlIGl0IGl0cyBvd24gbGluZSBpZiBpdCdzIG5vdCB0aGUgZW5kXG4gICAgICAgICAgICAgICAgICAgIGxpbmVzICs9IFRleHRNZXRyaWNzLmFkZExpbmUodG9rZW4sICFpc0xhc3RUb2tlbik7XG4gICAgICAgICAgICAgICAgICAgIGNhblByZXBlbmRTcGFjZXMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgbGluZSA9ICcnO1xuICAgICAgICAgICAgICAgICAgICB3aWR0aCA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gd29yZCBjb3VsZCBmaXRcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHdvcmQgd29uJ3QgZml0IGJlY2F1c2Ugb2YgZXhpc3Rpbmcgd29yZHNcbiAgICAgICAgICAgICAgICAvLyBzdGFydCBhIG5ldyBsaW5lXG4gICAgICAgICAgICAgICAgaWYgKHRva2VuV2lkdGggKyB3aWR0aCA+IHdvcmRXcmFwV2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgaXRzIGEgc3BhY2Ugd2UgZG9uJ3Qgd2FudCBpdFxuICAgICAgICAgICAgICAgICAgICBjYW5QcmVwZW5kU3BhY2VzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIC8vIGFkZCBhIG5ldyBsaW5lXG4gICAgICAgICAgICAgICAgICAgIGxpbmVzICs9IFRleHRNZXRyaWNzLmFkZExpbmUobGluZSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHN0YXJ0IGEgbmV3IGxpbmVcbiAgICAgICAgICAgICAgICAgICAgbGluZSA9ICcnO1xuICAgICAgICAgICAgICAgICAgICB3aWR0aCA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGRvbid0IGFkZCBzcGFjZXMgdG8gdGhlIGJlZ2lubmluZyBvZiBsaW5lc1xuICAgICAgICAgICAgICAgIGlmIChsaW5lLmxlbmd0aCA+IDAgfHwgIVRleHRNZXRyaWNzLmlzQnJlYWtpbmdTcGFjZSh0b2tlbikgfHwgY2FuUHJlcGVuZFNwYWNlcykge1xuICAgICAgICAgICAgICAgICAgICAvLyBhZGQgdGhlIHdvcmQgdG8gdGhlIGN1cnJlbnQgbGluZVxuICAgICAgICAgICAgICAgICAgICBsaW5lICs9IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICAvLyB1cGRhdGUgd2lkdGggY291bnRlclxuICAgICAgICAgICAgICAgICAgICB3aWR0aCArPSB0b2tlbldpZHRoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsaW5lcyArPSBUZXh0TWV0cmljcy5hZGRMaW5lKGxpbmUsIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIGxpbmVzO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogQ29udmllbmllbmNlIGZ1bmN0aW9uIGZvciBsb2dnaW5nIGVhY2ggbGluZSBhZGRlZCBkdXJpbmcgdGhlIHdvcmRXcmFwXG4gICAgICogbWV0aG9kXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSAge3N0cmluZ30gICBsaW5lICAgIC0gVGhlIGxpbmUgb2YgdGV4dCB0byBhZGRcbiAgICAgKiBAcGFyYW0gIHtib29sZWFufSAgbmV3TGluZSAtIEFkZCBuZXcgbGluZSBjaGFyYWN0ZXIgdG8gZW5kXG4gICAgICogQHJldHVybiB7c3RyaW5nfSAgIEEgZm9ybWF0dGVkIGxpbmVcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkTGluZShsaW5lLCBuZXdMaW5lID0gdHJ1ZSkge1xuICAgICAgICBpZiAobmV3TGluZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBuZXdMaW5lID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBsaW5lID0gVGV4dE1ldHJpY3MudHJpbVJpZ2h0KGxpbmUpO1xuICAgICAgICBsaW5lID0gKG5ld0xpbmUpID8gKGxpbmUgKyBcIlxcblwiKSA6IGxpbmU7XG4gICAgICAgIHJldHVybiBsaW5lO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogR2V0cyAmIHNldHMgdGhlIHdpZHRocyBvZiBjYWxjdWxhdGVkIGNoYXJhY3RlcnMgaW4gYSBjYWNoZSBvYmplY3RcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSAgICAgICAgICAgICAgICBrZXkgICAgICAgIFRoZSBrZXlcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9ICAgICAgICAgICAgICAgIGxldHRlclNwYWNpbmcgIFRoZSBsZXR0ZXIgc3BhY2luZ1xuICAgICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgY2FjaGUgICAgICBUaGUgY2FjaGVcbiAgICAgKiBAcGFyYW0gIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9ICBjb250ZXh0ICAgIFRoZSBjYW52YXMgY29udGV4dFxuICAgICAqIEByZXR1cm4ge251bWJlcn0gICAgICAgICAgICAgICAgVGhlIGZyb20gY2FjaGUuXG4gICAgICovXG4gICAgc3RhdGljIGdldEZyb21DYWNoZShrZXksIGxldHRlclNwYWNpbmcsIGNhY2hlLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciB3aWR0aCA9IGNhY2hlW2tleV07XG4gICAgICAgIGlmICh3aWR0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2YXIgc3BhY2luZyA9ICgoa2V5Lmxlbmd0aCkgKiBsZXR0ZXJTcGFjaW5nKTtcbiAgICAgICAgICAgIHdpZHRoID0gY29udGV4dC5tZWFzdXJlVGV4dChrZXkpLndpZHRoICsgc3BhY2luZztcbiAgICAgICAgICAgIGNhY2hlW2tleV0gPSB3aWR0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd2lkdGg7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgd2Ugc2hvdWxkIGNvbGxhcHNlIGJyZWFraW5nIHNwYWNlc1xuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9ICAgd2hpdGVTcGFjZSAgVGhlIFRleHRTdHlsZSBwcm9wZXJ0eSB3aGl0ZVNwYWNlXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gIHNob3VsZCBjb2xsYXBzZVxuICAgICAqL1xuICAgIHN0YXRpYyBjb2xsYXBzZVNwYWNlcyh3aGl0ZVNwYWNlKSB7XG4gICAgICAgIHJldHVybiAod2hpdGVTcGFjZSA9PT0gJ25vcm1hbCcgfHwgd2hpdGVTcGFjZSA9PT0gJ3ByZS1saW5lJyk7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgd2Ugc2hvdWxkIGNvbGxhcHNlIG5ld0xpbmUgY2hhcnNcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSAgIHdoaXRlU3BhY2UgIFRoZSB3aGl0ZSBzcGFjZVxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59ICBzaG91bGQgY29sbGFwc2VcbiAgICAgKi9cbiAgICBzdGF0aWMgY29sbGFwc2VOZXdsaW5lcyh3aGl0ZVNwYWNlKSB7XG4gICAgICAgIHJldHVybiAod2hpdGVTcGFjZSA9PT0gJ25vcm1hbCcpO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogdHJpbXMgYnJlYWtpbmcgd2hpdGVzcGFjZXMgZnJvbSBzdHJpbmdcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSAgdGV4dCAgVGhlIHRleHRcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9ICB0cmltbWVkIHN0cmluZ1xuICAgICAqL1xuICAgIHN0YXRpYyB0cmltUmlnaHQodGV4dCkge1xuICAgICAgICBpZiAodHlwZW9mIHRleHQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IHRleHQubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIHZhciBjaGFyID0gdGV4dFtpXTtcbiAgICAgICAgICAgIGlmICghVGV4dE1ldHJpY3MuaXNCcmVha2luZ1NwYWNlKGNoYXIpKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0ZXh0ID0gdGV4dC5zbGljZSgwLCAtMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIGlmIGNoYXIgaXMgYSBuZXdsaW5lLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9ICBjaGFyICBUaGUgY2hhcmFjdGVyXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gIFRydWUgaWYgbmV3bGluZSwgRmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIHN0YXRpYyBpc05ld2xpbmUoY2hhcikge1xuICAgICAgICBpZiAodHlwZW9mIGNoYXIgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChUZXh0TWV0cmljcy5fbmV3bGluZXMuaW5kZXhPZihjaGFyLmNoYXJDb2RlQXQoMCkpID49IDApO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyBpZiBjaGFyIGlzIGEgYnJlYWtpbmcgd2hpdGVzcGFjZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSAgY2hhciAgVGhlIGNoYXJhY3RlclxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59ICBUcnVlIGlmIHdoaXRlc3BhY2UsIEZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaXNCcmVha2luZ1NwYWNlKGNoYXIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjaGFyICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoVGV4dE1ldHJpY3MuX2JyZWFraW5nU3BhY2VzLmluZGV4T2YoY2hhci5jaGFyQ29kZUF0KDApKSA+PSAwKTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFNwbGl0cyBhIHN0cmluZyBpbnRvIHdvcmRzLCBicmVha2luZy1zcGFjZXMgYW5kIG5ld0xpbmUgY2hhcmFjdGVyc1xuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9ICB0ZXh0ICAgVGhlIHRleHRcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmdbXX0gIEEgdG9rZW5pemVkIGFycmF5XG4gICAgICovXG4gICAgc3RhdGljIHRva2VuaXplKHRleHQpIHtcbiAgICAgICAgdmFyIHRva2VucyA9IFtdO1xuICAgICAgICB2YXIgdG9rZW4gPSAnJztcbiAgICAgICAgaWYgKHR5cGVvZiB0ZXh0ICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIHRva2VucztcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRleHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjaGFyID0gdGV4dFtpXTtcbiAgICAgICAgICAgIGlmIChUZXh0TWV0cmljcy5pc0JyZWFraW5nU3BhY2UoY2hhcikgfHwgVGV4dE1ldHJpY3MuaXNOZXdsaW5lKGNoYXIpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRva2VuICE9PSAnJykge1xuICAgICAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgICAgIHRva2VuID0gJyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKGNoYXIpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdG9rZW4gKz0gY2hhcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG9rZW4gIT09ICcnKSB7XG4gICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRva2VucztcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGV4aXN0cyB0byBiZSBlYXNpbHkgb3ZlcnJpZGRlblxuICAgICAqIEl0IGFsbG93cyBvbmUgdG8gY3VzdG9taXNlIHdoaWNoIHdvcmRzIHNob3VsZCBicmVha1xuICAgICAqIEV4YW1wbGVzIGFyZSBpZiB0aGUgdG9rZW4gaXMgQ0pLIG9yIG51bWJlcnMuXG4gICAgICogSXQgbXVzdCByZXR1cm4gYSBib29sZWFuLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9ICB0b2tlbiAgIFRoZSB0b2tlblxuICAgICAqIEBwYXJhbSAge2Jvb2xlYW59ICBicmVha1dvcmRzICBUaGUgc3R5bGUgYXR0ciBicmVhayB3b3Jkc1xuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IHdoZXRoZXIgdG8gYnJlYWsgd29yZCBvciBub3RcbiAgICAgKi9cbiAgICBzdGF0aWMgY2FuQnJlYWtXb3Jkcyh0b2tlbiwgYnJlYWtXb3Jkcykge1xuICAgICAgICByZXR1cm4gYnJlYWtXb3JkcztcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGV4aXN0cyB0byBiZSBlYXNpbHkgb3ZlcnJpZGRlblxuICAgICAqIEl0IGFsbG93cyBvbmUgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgYSBwYWlyIG9mIGNoYXJhY3RlcnNcbiAgICAgKiBzaG91bGQgYmUgYnJva2VuIGJ5IG5ld2xpbmVzXG4gICAgICogRm9yIGV4YW1wbGUgY2VydGFpbiBjaGFyYWN0ZXJzIGluIENKSyBsYW5ncyBvciBudW1iZXJzLlxuICAgICAqIEl0IG11c3QgcmV0dXJuIGEgYm9vbGVhbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSAgY2hhciAgVGhlIGNoYXJhY3RlclxuICAgICAqIEBwYXJhbSAge3N0cmluZ30gIG5leHRDaGFyICBUaGUgbmV4dCBjaGFyYWN0ZXJcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9ICB0b2tlbiBUaGUgdG9rZW4vd29yZCB0aGUgY2hhcmFjdGVycyBhcmUgZnJvbVxuICAgICAqIEBwYXJhbSAge251bWJlcn0gIGluZGV4IFRoZSBpbmRleCBpbiB0aGUgdG9rZW4gb2YgdGhlIGNoYXJcbiAgICAgKiBAcGFyYW0gIHtib29sZWFufSAgYnJlYWtXb3JkcyAgVGhlIHN0eWxlIGF0dHIgYnJlYWsgd29yZHNcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSB3aGV0aGVyIHRvIGJyZWFrIHdvcmQgb3Igbm90XG4gICAgICovXG4gICAgc3RhdGljIGNhbkJyZWFrQ2hhcnMoY2hhciwgbmV4dENoYXIsIHRva2VuLCBpbmRleCwgYnJlYWtXb3Jkcykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgdGhlIGFzY2VudCwgZGVzY2VudCBhbmQgZm9udFNpemUgb2YgYSBnaXZlbiBmb250LXN0eWxlXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZvbnQgLSBTdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBzdHlsZSBvZiB0aGUgZm9udFxuICAgICAqIEByZXR1cm4ge1BJWEkuSUZvbnRNZXRyaWNzfSBGb250IHByb3BlcnRpZXMgb2JqZWN0XG4gICAgICovXG4gICAgc3RhdGljIG1lYXN1cmVGb250KGZvbnQpIHtcbiAgICAgICAgLy8gYXMgdGhpcyBtZXRob2QgaXMgdXNlZCBmb3IgcHJlcGFyaW5nIGFzc2V0cywgZG9uJ3QgcmVjYWxjdWxhdGUgdGhpbmdzIGlmIHdlIGRvbid0IG5lZWQgdG9cbiAgICAgICAgaWYgKFRleHRNZXRyaWNzLl9mb250c1tmb250XSkge1xuICAgICAgICAgICAgcmV0dXJuIFRleHRNZXRyaWNzLl9mb250c1tmb250XTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcHJvcGVydGllcyA9IHt9O1xuICAgICAgICB2YXIgY2FudmFzID0gVGV4dE1ldHJpY3MuX2NhbnZhcztcbiAgICAgICAgdmFyIGNvbnRleHQgPSBUZXh0TWV0cmljcy5fY29udGV4dDtcbiAgICAgICAgY29udGV4dC5mb250ID0gZm9udDtcbiAgICAgICAgdmFyIG1ldHJpY3NTdHJpbmcgPSBUZXh0TWV0cmljcy5NRVRSSUNTX1NUUklORyArIFRleHRNZXRyaWNzLkJBU0VMSU5FX1NZTUJPTDtcbiAgICAgICAgdmFyIHdpZHRoID0gTWF0aC5jZWlsKGNvbnRleHQubWVhc3VyZVRleHQobWV0cmljc1N0cmluZykud2lkdGgpO1xuICAgICAgICB2YXIgYmFzZWxpbmUgPSBNYXRoLmNlaWwoY29udGV4dC5tZWFzdXJlVGV4dChUZXh0TWV0cmljcy5CQVNFTElORV9TWU1CT0wpLndpZHRoKTtcbiAgICAgICAgdmFyIGhlaWdodCA9IDIgKiBiYXNlbGluZTtcbiAgICAgICAgYmFzZWxpbmUgPSBiYXNlbGluZSAqIFRleHRNZXRyaWNzLkJBU0VMSU5FX01VTFRJUExJRVIgfCAwO1xuICAgICAgICBjYW52YXMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgY2FudmFzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSAnI2YwMCc7XG4gICAgICAgIGNvbnRleHQuZmlsbFJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIGNvbnRleHQuZm9udCA9IGZvbnQ7XG4gICAgICAgIGNvbnRleHQudGV4dEJhc2VsaW5lID0gJ2FscGhhYmV0aWMnO1xuICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9ICcjMDAwJztcbiAgICAgICAgY29udGV4dC5maWxsVGV4dChtZXRyaWNzU3RyaW5nLCAwLCBiYXNlbGluZSk7XG4gICAgICAgIHZhciBpbWFnZWRhdGEgPSBjb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCB3aWR0aCwgaGVpZ2h0KS5kYXRhO1xuICAgICAgICB2YXIgcGl4ZWxzID0gaW1hZ2VkYXRhLmxlbmd0aDtcbiAgICAgICAgdmFyIGxpbmUgPSB3aWR0aCAqIDQ7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgdmFyIGlkeCA9IDA7XG4gICAgICAgIHZhciBzdG9wID0gZmFsc2U7XG4gICAgICAgIC8vIGFzY2VudC4gc2NhbiBmcm9tIHRvcCB0byBib3R0b20gdW50aWwgd2UgZmluZCBhIG5vbiByZWQgcGl4ZWxcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGJhc2VsaW5lOyArK2kpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGluZTsgaiArPSA0KSB7XG4gICAgICAgICAgICAgICAgaWYgKGltYWdlZGF0YVtpZHggKyBqXSAhPT0gMjU1KSB7XG4gICAgICAgICAgICAgICAgICAgIHN0b3AgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXN0b3ApIHtcbiAgICAgICAgICAgICAgICBpZHggKz0gbGluZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHByb3BlcnRpZXMuYXNjZW50ID0gYmFzZWxpbmUgLSBpO1xuICAgICAgICBpZHggPSBwaXhlbHMgLSBsaW5lO1xuICAgICAgICBzdG9wID0gZmFsc2U7XG4gICAgICAgIC8vIGRlc2NlbnQuIHNjYW4gZnJvbSBib3R0b20gdG8gdG9wIHVudGlsIHdlIGZpbmQgYSBub24gcmVkIHBpeGVsXG4gICAgICAgIGZvciAoaSA9IGhlaWdodDsgaSA+IGJhc2VsaW5lOyAtLWkpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGokMSA9IDA7IGokMSA8IGxpbmU7IGokMSArPSA0KSB7XG4gICAgICAgICAgICAgICAgaWYgKGltYWdlZGF0YVtpZHggKyBqJDFdICE9PSAyNTUpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RvcCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghc3RvcCkge1xuICAgICAgICAgICAgICAgIGlkeCAtPSBsaW5lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcHJvcGVydGllcy5kZXNjZW50ID0gaSAtIGJhc2VsaW5lO1xuICAgICAgICBwcm9wZXJ0aWVzLmZvbnRTaXplID0gcHJvcGVydGllcy5hc2NlbnQgKyBwcm9wZXJ0aWVzLmRlc2NlbnQ7XG4gICAgICAgIFRleHRNZXRyaWNzLl9mb250c1tmb250XSA9IHByb3BlcnRpZXM7XG4gICAgICAgIHJldHVybiBwcm9wZXJ0aWVzO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogQ2xlYXIgZm9udCBtZXRyaWNzIGluIG1ldHJpY3MgY2FjaGUuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtmb250XSAtIGZvbnQgbmFtZS4gSWYgZm9udCBuYW1lIG5vdCBzZXQgdGhlbiBjbGVhciBjYWNoZSBmb3IgYWxsIGZvbnRzLlxuICAgICAqL1xuICAgIHN0YXRpYyBjbGVhck1ldHJpY3MoZm9udCkge1xuICAgICAgICBpZiAoZm9udCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBmb250ID0gJyc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZvbnQpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBUZXh0TWV0cmljcy5fZm9udHNbZm9udF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBUZXh0TWV0cmljcy5fZm9udHMgPSB7fTtcbiAgICAgICAgfVxuICAgIH1cbiAgICA7XG59XG4vKipcbiAqIEludGVybmFsIHJldHVybiBvYmplY3QgZm9yIHtAbGluayBQSVhJLlRleHRNZXRyaWNzLm1lYXN1cmVGb250IGBUZXh0TWV0cmljcy5tZWFzdXJlRm9udGB9LlxuICpcbiAqIEB0eXBlZGVmIHtvYmplY3R9IEZvbnRNZXRyaWNzXG4gKiBAcHJvcGVydHkge251bWJlcn0gYXNjZW50IC0gVGhlIGFzY2VudCBkaXN0YW5jZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IGRlc2NlbnQgLSBUaGUgZGVzY2VudCBkaXN0YW5jZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IGZvbnRTaXplIC0gRm9udCBzaXplIGZyb20gYXNjZW50IHRvIGRlc2NlbnRcbiAqIEBtZW1iZXJvZiBQSVhJLlRleHRNZXRyaWNzXG4gKiBAcHJpdmF0ZVxuICovXG4vKipcbiAqIENhY2hlIG9mIHtAc2VlIFBJWEkuVGV4dE1ldHJpY3MuRm9udE1ldHJpY3N9IG9iamVjdHMuXG4gKiBAbWVtYmVyb2YgUElYSS5UZXh0TWV0cmljc1xuICogQHR5cGUge09iamVjdH1cbiAqIEBwcml2YXRlXG4gKi9cblRleHRNZXRyaWNzLl9mb250cyA9IHt9O1xuLyoqXG4gKiBTdHJpbmcgdXNlZCBmb3IgY2FsY3VsYXRlIGZvbnQgbWV0cmljcy5cbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJvZiBQSVhJLlRleHRNZXRyaWNzXG4gKiBAbmFtZSBNRVRSSUNTX1NUUklOR1xuICogQHR5cGUge3N0cmluZ31cbiAqIEBkZWZhdWx0IHzDiXFcbiAqL1xuVGV4dE1ldHJpY3MuTUVUUklDU19TVFJJTkcgPSAnfMOJcSc7XG4vKipcbiAqIEJhc2VsaW5lIHN5bWJvbCBmb3IgY2FsY3VsYXRlIGZvbnQgbWV0cmljcy5cbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJvZiBQSVhJLlRleHRNZXRyaWNzXG4gKiBAbmFtZSBCQVNFTElORV9TWU1CT0xcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKiBAZGVmYXVsdCBNXG4gKi9cblRleHRNZXRyaWNzLkJBU0VMSU5FX1NZTUJPTCA9ICdNJztcbi8qKlxuICogQmFzZWxpbmUgbXVsdGlwbGllciBmb3IgY2FsY3VsYXRlIGZvbnQgbWV0cmljcy5cbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJvZiBQSVhJLlRleHRNZXRyaWNzXG4gKiBAbmFtZSBCQVNFTElORV9NVUxUSVBMSUVSXG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQGRlZmF1bHQgMS40XG4gKi9cblRleHRNZXRyaWNzLkJBU0VMSU5FX01VTFRJUExJRVIgPSAxLjQ7XG4vKipcbiAqIENhY2hlIG9mIG5ldyBsaW5lIGNoYXJzLlxuICogQG1lbWJlcm9mIFBJWEkuVGV4dE1ldHJpY3NcbiAqIEB0eXBlIHtudW1iZXJbXX1cbiAqIEBwcml2YXRlXG4gKi9cblRleHRNZXRyaWNzLl9uZXdsaW5lcyA9IFtcbiAgICAweDAwMEEsXG4gICAgMHgwMDBEXG5dO1xuLyoqXG4gKiBDYWNoZSBvZiBicmVha2luZyBzcGFjZXMuXG4gKiBAbWVtYmVyb2YgUElYSS5UZXh0TWV0cmljc1xuICogQHR5cGUge251bWJlcltdfVxuICogQHByaXZhdGVcbiAqL1xuVGV4dE1ldHJpY3MuX2JyZWFraW5nU3BhY2VzID0gW1xuICAgIDB4MDAwOSxcbiAgICAweDAwMjAsXG4gICAgMHgyMDAwLFxuICAgIDB4MjAwMSxcbiAgICAweDIwMDIsXG4gICAgMHgyMDAzLFxuICAgIDB4MjAwNCxcbiAgICAweDIwMDUsXG4gICAgMHgyMDA2LFxuICAgIDB4MjAwOCxcbiAgICAweDIwMDksXG4gICAgMHgyMDBBLFxuICAgIDB4MjA1RixcbiAgICAweDMwMDBcbl07XG5leHBvcnRzLlRleHRNZXRyaWNzID0gVGV4dE1ldHJpY3M7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNsYXNzIFRleHRTZXR0aW5ncyB7XG59XG5UZXh0U2V0dGluZ3MuVEVYVF9HUkFESUVOVCA9IHtcbiAgICBMSU5FQVJfVkVSVElDQUw6IDAsXG4gICAgTElORUFSX0hPUklaT05UQUw6IDEsXG59O1xuVGV4dFNldHRpbmdzLmRlZmF1bHRTdHlsZSA9IHtcbiAgICBhbGlnbjogJ2xlZnQnLFxuICAgIGJyZWFrV29yZHM6IGZhbHNlLFxuICAgIGRyb3BTaGFkb3c6IGZhbHNlLFxuICAgIGRyb3BTaGFkb3dBbHBoYTogMSxcbiAgICBkcm9wU2hhZG93QW5nbGU6IE1hdGguUEkgLyA2LFxuICAgIGRyb3BTaGFkb3dCbHVyOiAwLFxuICAgIGRyb3BTaGFkb3dDb2xvcjogJ2JsYWNrJyxcbiAgICBkcm9wU2hhZG93RGlzdGFuY2U6IDUsXG4gICAgZmlsbDogJ2JsYWNrJyxcbiAgICBmaWxsR3JhZGllbnRUeXBlOiBUZXh0U2V0dGluZ3MuVEVYVF9HUkFESUVOVC5MSU5FQVJfVkVSVElDQUwsXG4gICAgZmlsbEdyYWRpZW50U3RvcHM6IFtdLFxuICAgIGZvbnRGYW1pbHk6ICdBcmlhbCcsXG4gICAgZm9udFNpemU6IDI2LFxuICAgIGZvbnRTdHlsZTogJ25vcm1hbCcsXG4gICAgZm9udFZhcmlhbnQ6ICdub3JtYWwnLFxuICAgIGZvbnRXZWlnaHQ6ICdub3JtYWwnLFxuICAgIGxldHRlclNwYWNpbmc6IDAsXG4gICAgbGluZUhlaWdodDogMCxcbiAgICBsaW5lSm9pbjogJ21pdGVyJyxcbiAgICBtaXRlckxpbWl0OiAxMCxcbiAgICBwYWRkaW5nOiAwLFxuICAgIHN0cm9rZTogJ2JsYWNrJyxcbiAgICBzdHJva2VUaGlja25lc3M6IDAsXG4gICAgdGV4dEJhc2VsaW5lOiAnYWxwaGFiZXRpYycsXG4gICAgdHJpbTogZmFsc2UsXG4gICAgd2hpdGVTcGFjZTogJ3ByZScsXG4gICAgd29yZFdyYXA6IGZhbHNlLFxuICAgIHdvcmRXcmFwV2lkdGg6IDEwMCxcbiAgICBsZWFkaW5nOiAwLFxufTtcbmV4cG9ydHMuVGV4dFNldHRpbmdzID0gVGV4dFNldHRpbmdzO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBUZXh0U2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL1RleHRTZXR0aW5nc1wiKTtcbmNvbnN0IENvbG9yU2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL0NvbG9yU2V0dGluZ3NcIik7XG5jb25zdCBVdGlsc1NldHRpbmdzXzEgPSByZXF1aXJlKFwiLi9VdGlsc1NldHRpbmdzXCIpO1xuY2xhc3MgVGV4dFN0eWxlIHtcbiAgICBjb25zdHJ1Y3RvcihzdHlsZSkge1xuICAgICAgICB0aGlzLnN0eWxlSUQgPSAwO1xuICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgIFV0aWxzU2V0dGluZ3NfMS5VdGlsc1NldHRpbmdzLmRlZXBDb3B5UHJvcGVydGllcyh0aGlzLCBzdHlsZSwgc3R5bGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IFRleHRTdHlsZSBvYmplY3Qgd2l0aCB0aGUgc2FtZSB2YWx1ZXMgYXMgdGhpcyBvbmUuXG4gICAgICogTm90ZSB0aGF0IHRoZSBvbmx5IHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBvYmplY3QgYXJlIGNsb25lZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1BJWEkuVGV4dFN0eWxlfSBOZXcgY2xvbmVkIFRleHRTdHlsZSBvYmplY3RcbiAgICAgKi9cbiAgICBjbG9uZSgpIHtcbiAgICAgICAgdmFyIGNsb25lZFByb3BlcnRpZXMgPSB7fTtcbiAgICAgICAgVXRpbHNTZXR0aW5nc18xLlV0aWxzU2V0dGluZ3MuZGVlcENvcHlQcm9wZXJ0aWVzKGNsb25lZFByb3BlcnRpZXMsIHRoaXMsIFRleHRTZXR0aW5nc18xLlRleHRTZXR0aW5ncy5kZWZhdWx0U3R5bGUpO1xuICAgICAgICByZXR1cm4gbmV3IFRleHRTdHlsZShjbG9uZWRQcm9wZXJ0aWVzKTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFJlc2V0cyBhbGwgcHJvcGVydGllcyB0byB0aGUgZGVmYXVsdHMgc3BlY2lmaWVkIGluIFRleHRTdHlsZS5wcm90b3R5cGUuX2RlZmF1bHRcbiAgICAgKi9cbiAgICByZXNldCgpIHtcbiAgICAgICAgVXRpbHNTZXR0aW5nc18xLlV0aWxzU2V0dGluZ3MuZGVlcENvcHlQcm9wZXJ0aWVzKHRoaXMsIFRleHRTZXR0aW5nc18xLlRleHRTZXR0aW5ncy5kZWZhdWx0U3R5bGUsIFRleHRTZXR0aW5nc18xLlRleHRTZXR0aW5ncy5kZWZhdWx0U3R5bGUpO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogQWxpZ25tZW50IGZvciBtdWx0aWxpbmUgdGV4dCAoJ2xlZnQnLCAnY2VudGVyJyBvciAncmlnaHQnKSwgZG9lcyBub3QgYWZmZWN0IHNpbmdsZSBsaW5lIHRleHRcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge3N0cmluZ31cbiAgICAgKi9cbiAgICBnZXQgYWxpZ24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hbGlnbjtcbiAgICB9XG4gICAgO1xuICAgIHNldCBhbGlnbihhbGlnbikge1xuICAgICAgICBpZiAodGhpcy5fYWxpZ24gIT09IGFsaWduKSB7XG4gICAgICAgICAgICB0aGlzLl9hbGlnbiA9IGFsaWduO1xuICAgICAgICAgICAgdGhpcy5zdHlsZUlEKys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyBpZiBsaW5lcyBjYW4gYmUgd3JhcHBlZCB3aXRoaW4gd29yZHMsIGl0IG5lZWRzIHdvcmRXcmFwIHRvIGJlIHNldCB0byB0cnVlXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtib29sZWFufVxuICAgICAqL1xuICAgIGdldCBicmVha1dvcmRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYnJlYWtXb3JkcztcbiAgICB9XG4gICAgO1xuICAgIHNldCBicmVha1dvcmRzKGJyZWFrV29yZHMpIHtcbiAgICAgICAgaWYgKHRoaXMuX2JyZWFrV29yZHMgIT09IGJyZWFrV29yZHMpIHtcbiAgICAgICAgICAgIHRoaXMuX2JyZWFrV29yZHMgPSBicmVha1dvcmRzO1xuICAgICAgICAgICAgdGhpcy5zdHlsZUlEKys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFNldCBhIGRyb3Agc2hhZG93IGZvciB0aGUgdGV4dFxuICAgICAqXG4gICAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBnZXQgZHJvcFNoYWRvdygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Ryb3BTaGFkb3c7XG4gICAgfVxuICAgIDtcbiAgICBzZXQgZHJvcFNoYWRvdyhkcm9wU2hhZG93KSB7XG4gICAgICAgIGlmICh0aGlzLl9kcm9wU2hhZG93ICE9PSBkcm9wU2hhZG93KSB7XG4gICAgICAgICAgICB0aGlzLl9kcm9wU2hhZG93ID0gZHJvcFNoYWRvdztcbiAgICAgICAgICAgIHRoaXMuc3R5bGVJRCsrO1xuICAgICAgICB9XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBTZXQgYWxwaGEgZm9yIHRoZSBkcm9wIHNoYWRvd1xuICAgICAqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdldCBkcm9wU2hhZG93QWxwaGEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kcm9wU2hhZG93QWxwaGE7XG4gICAgfVxuICAgIDtcbiAgICBzZXQgZHJvcFNoYWRvd0FscGhhKGRyb3BTaGFkb3dBbHBoYSkge1xuICAgICAgICBpZiAodGhpcy5fZHJvcFNoYWRvd0FscGhhICE9PSBkcm9wU2hhZG93QWxwaGEpIHtcbiAgICAgICAgICAgIHRoaXMuX2Ryb3BTaGFkb3dBbHBoYSA9IGRyb3BTaGFkb3dBbHBoYTtcbiAgICAgICAgICAgIHRoaXMuc3R5bGVJRCsrO1xuICAgICAgICB9XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBTZXQgYSBhbmdsZSBvZiB0aGUgZHJvcCBzaGFkb3dcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgZHJvcFNoYWRvd0FuZ2xlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZHJvcFNoYWRvd0FuZ2xlO1xuICAgIH1cbiAgICA7XG4gICAgc2V0IGRyb3BTaGFkb3dBbmdsZShkcm9wU2hhZG93QW5nbGUpIHtcbiAgICAgICAgaWYgKHRoaXMuX2Ryb3BTaGFkb3dBbmdsZSAhPT0gZHJvcFNoYWRvd0FuZ2xlKSB7XG4gICAgICAgICAgICB0aGlzLl9kcm9wU2hhZG93QW5nbGUgPSBkcm9wU2hhZG93QW5nbGU7XG4gICAgICAgICAgICB0aGlzLnN0eWxlSUQrKztcbiAgICAgICAgfVxuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogU2V0IGEgc2hhZG93IGJsdXIgcmFkaXVzXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICovXG4gICAgZ2V0IGRyb3BTaGFkb3dCbHVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZHJvcFNoYWRvd0JsdXI7XG4gICAgfVxuICAgIDtcbiAgICBzZXQgZHJvcFNoYWRvd0JsdXIoZHJvcFNoYWRvd0JsdXIpIHtcbiAgICAgICAgaWYgKHRoaXMuX2Ryb3BTaGFkb3dCbHVyICE9PSBkcm9wU2hhZG93Qmx1cikge1xuICAgICAgICAgICAgdGhpcy5fZHJvcFNoYWRvd0JsdXIgPSBkcm9wU2hhZG93Qmx1cjtcbiAgICAgICAgICAgIHRoaXMuc3R5bGVJRCsrO1xuICAgICAgICB9XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBBIGZpbGwgc3R5bGUgdG8gYmUgdXNlZCBvbiB0aGUgZHJvcHNoYWRvdyBlLmcgJ3JlZCcsICcjMDBGRjAwJ1xuICAgICAqXG4gICAgICogQG1lbWJlciB7c3RyaW5nfG51bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgZHJvcFNoYWRvd0NvbG9yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZHJvcFNoYWRvd0NvbG9yO1xuICAgIH1cbiAgICA7XG4gICAgc2V0IGRyb3BTaGFkb3dDb2xvcihkcm9wU2hhZG93Q29sb3IpIHtcbiAgICAgICAgdmFyIG91dHB1dENvbG9yID0gQ29sb3JTZXR0aW5nc18xLkNvbG9yU2V0dGluZ3MuZ2V0Q29sb3IoZHJvcFNoYWRvd0NvbG9yKTtcbiAgICAgICAgaWYgKHRoaXMuX2Ryb3BTaGFkb3dDb2xvciAhPT0gb3V0cHV0Q29sb3IpIHtcbiAgICAgICAgICAgIHRoaXMuX2Ryb3BTaGFkb3dDb2xvciA9IG91dHB1dENvbG9yO1xuICAgICAgICAgICAgdGhpcy5zdHlsZUlEKys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFNldCBhIGRpc3RhbmNlIG9mIHRoZSBkcm9wIHNoYWRvd1xuICAgICAqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdldCBkcm9wU2hhZG93RGlzdGFuY2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kcm9wU2hhZG93RGlzdGFuY2U7XG4gICAgfVxuICAgIDtcbiAgICBzZXQgZHJvcFNoYWRvd0Rpc3RhbmNlKGRyb3BTaGFkb3dEaXN0YW5jZSkge1xuICAgICAgICBpZiAodGhpcy5fZHJvcFNoYWRvd0Rpc3RhbmNlICE9PSBkcm9wU2hhZG93RGlzdGFuY2UpIHtcbiAgICAgICAgICAgIHRoaXMuX2Ryb3BTaGFkb3dEaXN0YW5jZSA9IGRyb3BTaGFkb3dEaXN0YW5jZTtcbiAgICAgICAgICAgIHRoaXMuc3R5bGVJRCsrO1xuICAgICAgICB9XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBBIGNhbnZhcyBmaWxsc3R5bGUgdGhhdCB3aWxsIGJlIHVzZWQgb24gdGhlIHRleHQgZS5nICdyZWQnLCAnIzAwRkYwMCcuXG4gICAgICogQ2FuIGJlIGFuIGFycmF5IHRvIGNyZWF0ZSBhIGdyYWRpZW50IGVnIFsnIzAwMDAwMCcsJyNGRkZGRkYnXVxuICAgICAqIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEL2ZpbGxTdHlsZXxNRE59XG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtzdHJpbmd8c3RyaW5nW118bnVtYmVyfG51bWJlcltdfENhbnZhc0dyYWRpZW50fENhbnZhc1BhdHRlcm59XG4gICAgICovXG4gICAgZ2V0IGZpbGwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9maWxsO1xuICAgIH1cbiAgICA7XG4gICAgc2V0IGZpbGwoZmlsbCkge1xuICAgICAgICB2YXIgb3V0cHV0Q29sb3IgPSBDb2xvclNldHRpbmdzXzEuQ29sb3JTZXR0aW5ncy5nZXRDb2xvcihmaWxsKTtcbiAgICAgICAgaWYgKHRoaXMuX2ZpbGwgIT09IG91dHB1dENvbG9yKSB7XG4gICAgICAgICAgICB0aGlzLl9maWxsID0gb3V0cHV0Q29sb3I7XG4gICAgICAgICAgICB0aGlzLnN0eWxlSUQrKztcbiAgICAgICAgfVxuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogSWYgZmlsbCBpcyBhbiBhcnJheSBvZiBjb2xvdXJzIHRvIGNyZWF0ZSBhIGdyYWRpZW50LCB0aGlzIGNhbiBjaGFuZ2UgdGhlIHR5cGUvZGlyZWN0aW9uIG9mIHRoZSBncmFkaWVudC5cbiAgICAgKiBTZWUge0BsaW5rIFBJWEkuVEVYVF9HUkFESUVOVH1cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgZmlsbEdyYWRpZW50VHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZpbGxHcmFkaWVudFR5cGU7XG4gICAgfVxuICAgIDtcbiAgICBzZXQgZmlsbEdyYWRpZW50VHlwZShmaWxsR3JhZGllbnRUeXBlKSB7XG4gICAgICAgIGlmICh0aGlzLl9maWxsR3JhZGllbnRUeXBlICE9PSBmaWxsR3JhZGllbnRUeXBlKSB7XG4gICAgICAgICAgICB0aGlzLl9maWxsR3JhZGllbnRUeXBlID0gZmlsbEdyYWRpZW50VHlwZTtcbiAgICAgICAgICAgIHRoaXMuc3R5bGVJRCsrO1xuICAgICAgICB9XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBJZiBmaWxsIGlzIGFuIGFycmF5IG9mIGNvbG91cnMgdG8gY3JlYXRlIGEgZ3JhZGllbnQsIHRoaXMgYXJyYXkgY2FuIHNldCB0aGUgc3RvcCBwb2ludHNcbiAgICAgKiAobnVtYmVycyBiZXR3ZWVuIDAgYW5kIDEpIGZvciB0aGUgY29sb3IsIG92ZXJyaWRpbmcgdGhlIGRlZmF1bHQgYmVoYXZpb3VyIG9mIGV2ZW5seSBzcGFjaW5nIHRoZW0uXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJbXX1cbiAgICAgKi9cbiAgICBnZXQgZmlsbEdyYWRpZW50U3RvcHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9maWxsR3JhZGllbnRTdG9wcztcbiAgICB9XG4gICAgO1xuICAgIHNldCBmaWxsR3JhZGllbnRTdG9wcyhmaWxsR3JhZGllbnRTdG9wcykge1xuICAgICAgICBpZiAoIVV0aWxzU2V0dGluZ3NfMS5VdGlsc1NldHRpbmdzLmFyZUFycmF5c0VxdWFsKHRoaXMuX2ZpbGxHcmFkaWVudFN0b3BzLCBmaWxsR3JhZGllbnRTdG9wcykpIHtcbiAgICAgICAgICAgIHRoaXMuX2ZpbGxHcmFkaWVudFN0b3BzID0gZmlsbEdyYWRpZW50U3RvcHM7XG4gICAgICAgICAgICB0aGlzLnN0eWxlSUQrKztcbiAgICAgICAgfVxuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogVGhlIGZvbnQgZmFtaWx5XG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtzdHJpbmd8c3RyaW5nW119XG4gICAgICovXG4gICAgZ2V0IGZvbnRGYW1pbHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9mb250RmFtaWx5O1xuICAgIH1cbiAgICA7XG4gICAgc2V0IGZvbnRGYW1pbHkoZm9udEZhbWlseSkge1xuICAgICAgICBpZiAodGhpcy5mb250RmFtaWx5ICE9PSBmb250RmFtaWx5KSB7XG4gICAgICAgICAgICB0aGlzLl9mb250RmFtaWx5ID0gZm9udEZhbWlseTtcbiAgICAgICAgICAgIHRoaXMuc3R5bGVJRCsrO1xuICAgICAgICB9XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBUaGUgZm9udCBzaXplXG4gICAgICogKGFzIGEgbnVtYmVyIGl0IGNvbnZlcnRzIHRvIHB4LCBidXQgYXMgYSBzdHJpbmcsIGVxdWl2YWxlbnRzIGFyZSAnMjZweCcsJzIwcHQnLCcxNjAlJyBvciAnMS42ZW0nKVxuICAgICAqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfHN0cmluZ31cbiAgICAgKi9cbiAgICBnZXQgZm9udFNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9mb250U2l6ZTtcbiAgICB9XG4gICAgO1xuICAgIHNldCBmb250U2l6ZShmb250U2l6ZSkge1xuICAgICAgICBpZiAodGhpcy5fZm9udFNpemUgIT09IGZvbnRTaXplKSB7XG4gICAgICAgICAgICB0aGlzLl9mb250U2l6ZSA9IGZvbnRTaXplO1xuICAgICAgICAgICAgdGhpcy5zdHlsZUlEKys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFRoZSBmb250IHN0eWxlXG4gICAgICogKCdub3JtYWwnLCAnaXRhbGljJyBvciAnb2JsaXF1ZScpXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtzdHJpbmd9XG4gICAgICovXG4gICAgZ2V0IGZvbnRTdHlsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZvbnRTdHlsZTtcbiAgICB9XG4gICAgO1xuICAgIHNldCBmb250U3R5bGUoZm9udFN0eWxlKSB7XG4gICAgICAgIGlmICh0aGlzLl9mb250U3R5bGUgIT09IGZvbnRTdHlsZSkge1xuICAgICAgICAgICAgdGhpcy5fZm9udFN0eWxlID0gZm9udFN0eWxlO1xuICAgICAgICAgICAgdGhpcy5zdHlsZUlEKys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFRoZSBmb250IHZhcmlhbnRcbiAgICAgKiAoJ25vcm1hbCcgb3IgJ3NtYWxsLWNhcHMnKVxuICAgICAqXG4gICAgICogQG1lbWJlciB7c3RyaW5nfVxuICAgICAqL1xuICAgIGdldCBmb250VmFyaWFudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZvbnRWYXJpYW50O1xuICAgIH1cbiAgICA7XG4gICAgc2V0IGZvbnRWYXJpYW50KGZvbnRWYXJpYW50KSB7XG4gICAgICAgIGlmICh0aGlzLl9mb250VmFyaWFudCAhPT0gZm9udFZhcmlhbnQpIHtcbiAgICAgICAgICAgIHRoaXMuX2ZvbnRWYXJpYW50ID0gZm9udFZhcmlhbnQ7XG4gICAgICAgICAgICB0aGlzLnN0eWxlSUQrKztcbiAgICAgICAgfVxuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogVGhlIGZvbnQgd2VpZ2h0XG4gICAgICogKCdub3JtYWwnLCAnYm9sZCcsICdib2xkZXInLCAnbGlnaHRlcicgYW5kICcxMDAnLCAnMjAwJywgJzMwMCcsICc0MDAnLCAnNTAwJywgJzYwMCcsICc3MDAnLCA4MDAnIG9yICc5MDAnKVxuICAgICAqXG4gICAgICogQG1lbWJlciB7c3RyaW5nfVxuICAgICAqL1xuICAgIGdldCBmb250V2VpZ2h0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZm9udFdlaWdodDtcbiAgICB9XG4gICAgO1xuICAgIHNldCBmb250V2VpZ2h0KGZvbnRXZWlnaHQpIHtcbiAgICAgICAgaWYgKHRoaXMuX2ZvbnRXZWlnaHQgIT09IGZvbnRXZWlnaHQpIHtcbiAgICAgICAgICAgIHRoaXMuX2ZvbnRXZWlnaHQgPSBmb250V2VpZ2h0O1xuICAgICAgICAgICAgdGhpcy5zdHlsZUlEKys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFRoZSBhbW91bnQgb2Ygc3BhY2luZyBiZXR3ZWVuIGxldHRlcnMsIGRlZmF1bHQgaXMgMFxuICAgICAqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdldCBsZXR0ZXJTcGFjaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGV0dGVyU3BhY2luZztcbiAgICB9XG4gICAgO1xuICAgIHNldCBsZXR0ZXJTcGFjaW5nKGxldHRlclNwYWNpbmcpIHtcbiAgICAgICAgaWYgKHRoaXMuX2xldHRlclNwYWNpbmcgIT09IGxldHRlclNwYWNpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuX2xldHRlclNwYWNpbmcgPSBsZXR0ZXJTcGFjaW5nO1xuICAgICAgICAgICAgdGhpcy5zdHlsZUlEKys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFRoZSBsaW5lIGhlaWdodCwgYSBudW1iZXIgdGhhdCByZXByZXNlbnRzIHRoZSB2ZXJ0aWNhbCBzcGFjZSB0aGF0IGEgbGV0dGVyIHVzZXNcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgbGluZUhlaWdodCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xpbmVIZWlnaHQ7XG4gICAgfVxuICAgIDtcbiAgICBzZXQgbGluZUhlaWdodChsaW5lSGVpZ2h0KSB7XG4gICAgICAgIGlmICh0aGlzLl9saW5lSGVpZ2h0ICE9PSBsaW5lSGVpZ2h0KSB7XG4gICAgICAgICAgICB0aGlzLl9saW5lSGVpZ2h0ID0gbGluZUhlaWdodDtcbiAgICAgICAgICAgIHRoaXMuc3R5bGVJRCsrO1xuICAgICAgICB9XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBUaGUgc3BhY2UgYmV0d2VlbiBsaW5lc1xuICAgICAqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdldCBsZWFkaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGVhZGluZztcbiAgICB9XG4gICAgO1xuICAgIHNldCBsZWFkaW5nKGxlYWRpbmcpIHtcbiAgICAgICAgaWYgKHRoaXMuX2xlYWRpbmcgIT09IGxlYWRpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuX2xlYWRpbmcgPSBsZWFkaW5nO1xuICAgICAgICAgICAgdGhpcy5zdHlsZUlEKys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFRoZSBsaW5lSm9pbiBwcm9wZXJ0eSBzZXRzIHRoZSB0eXBlIG9mIGNvcm5lciBjcmVhdGVkLCBpdCBjYW4gcmVzb2x2ZSBzcGlrZWQgdGV4dCBpc3N1ZXMuXG4gICAgICogRGVmYXVsdCBpcyAnbWl0ZXInIChjcmVhdGVzIGEgc2hhcnAgY29ybmVyKS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge3N0cmluZ31cbiAgICAgKi9cbiAgICBnZXQgbGluZUpvaW4oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9saW5lSm9pbjtcbiAgICB9XG4gICAgO1xuICAgIHNldCBsaW5lSm9pbihsaW5lSm9pbikge1xuICAgICAgICBpZiAodGhpcy5fbGluZUpvaW4gIT09IGxpbmVKb2luKSB7XG4gICAgICAgICAgICB0aGlzLl9saW5lSm9pbiA9IGxpbmVKb2luO1xuICAgICAgICAgICAgdGhpcy5zdHlsZUlEKys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFRoZSBtaXRlciBsaW1pdCB0byB1c2Ugd2hlbiB1c2luZyB0aGUgJ21pdGVyJyBsaW5lSm9pbiBtb2RlXG4gICAgICogVGhpcyBjYW4gcmVkdWNlIG9yIGluY3JlYXNlIHRoZSBzcGlraW5lc3Mgb2YgcmVuZGVyZWQgdGV4dC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgbWl0ZXJMaW1pdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21pdGVyTGltaXQ7XG4gICAgfVxuICAgIDtcbiAgICBzZXQgbWl0ZXJMaW1pdChtaXRlckxpbWl0KSB7XG4gICAgICAgIGlmICh0aGlzLl9taXRlckxpbWl0ICE9PSBtaXRlckxpbWl0KSB7XG4gICAgICAgICAgICB0aGlzLl9taXRlckxpbWl0ID0gbWl0ZXJMaW1pdDtcbiAgICAgICAgICAgIHRoaXMuc3R5bGVJRCsrO1xuICAgICAgICB9XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBPY2Nhc2lvbmFsbHkgc29tZSBmb250cyBhcmUgY3JvcHBlZC4gQWRkaW5nIHNvbWUgcGFkZGluZyB3aWxsIHByZXZlbnQgdGhpcyBmcm9tIGhhcHBlbmluZ1xuICAgICAqIGJ5IGFkZGluZyBwYWRkaW5nIHRvIGFsbCBzaWRlcyBvZiB0aGUgdGV4dC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgcGFkZGluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhZGRpbmc7XG4gICAgfVxuICAgIDtcbiAgICBzZXQgcGFkZGluZyhwYWRkaW5nKSB7XG4gICAgICAgIGlmICh0aGlzLl9wYWRkaW5nICE9PSBwYWRkaW5nKSB7XG4gICAgICAgICAgICB0aGlzLl9wYWRkaW5nID0gcGFkZGluZztcbiAgICAgICAgICAgIHRoaXMuc3R5bGVJRCsrO1xuICAgICAgICB9XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBBIGNhbnZhcyBmaWxsc3R5bGUgdGhhdCB3aWxsIGJlIHVzZWQgb24gdGhlIHRleHQgc3Ryb2tlXG4gICAgICogZS5nICdibHVlJywgJyNGQ0ZGMDAnXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtzdHJpbmd8bnVtYmVyfVxuICAgICAqL1xuICAgIGdldCBzdHJva2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdHJva2U7XG4gICAgfVxuICAgIDtcbiAgICBzZXQgc3Ryb2tlKHN0cm9rZSkge1xuICAgICAgICB2YXIgb3V0cHV0Q29sb3IgPSBDb2xvclNldHRpbmdzXzEuQ29sb3JTZXR0aW5ncy5nZXRDb2xvcihzdHJva2UpO1xuICAgICAgICBpZiAodGhpcy5fc3Ryb2tlICE9PSBvdXRwdXRDb2xvcikge1xuICAgICAgICAgICAgdGhpcy5fc3Ryb2tlID0gb3V0cHV0Q29sb3I7XG4gICAgICAgICAgICB0aGlzLnN0eWxlSUQrKztcbiAgICAgICAgfVxuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogQSBudW1iZXIgdGhhdCByZXByZXNlbnRzIHRoZSB0aGlja25lc3Mgb2YgdGhlIHN0cm9rZS5cbiAgICAgKiBEZWZhdWx0IGlzIDAgKG5vIHN0cm9rZSlcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgc3Ryb2tlVGhpY2tuZXNzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3Ryb2tlVGhpY2tuZXNzO1xuICAgIH1cbiAgICA7XG4gICAgc2V0IHN0cm9rZVRoaWNrbmVzcyhzdHJva2VUaGlja25lc3MpIHtcbiAgICAgICAgaWYgKHRoaXMuX3N0cm9rZVRoaWNrbmVzcyAhPT0gc3Ryb2tlVGhpY2tuZXNzKSB7XG4gICAgICAgICAgICB0aGlzLl9zdHJva2VUaGlja25lc3MgPSBzdHJva2VUaGlja25lc3M7XG4gICAgICAgICAgICB0aGlzLnN0eWxlSUQrKztcbiAgICAgICAgfVxuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogVGhlIGJhc2VsaW5lIG9mIHRoZSB0ZXh0IHRoYXQgaXMgcmVuZGVyZWQuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtzdHJpbmd9XG4gICAgICovXG4gICAgZ2V0IHRleHRCYXNlbGluZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RleHRCYXNlbGluZTtcbiAgICB9XG4gICAgO1xuICAgIHNldCB0ZXh0QmFzZWxpbmUodGV4dEJhc2VsaW5lKSB7XG4gICAgICAgIGlmICh0aGlzLl90ZXh0QmFzZWxpbmUgIT09IHRleHRCYXNlbGluZSkge1xuICAgICAgICAgICAgdGhpcy5fdGV4dEJhc2VsaW5lID0gdGV4dEJhc2VsaW5lO1xuICAgICAgICAgICAgdGhpcy5zdHlsZUlEKys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFRyaW0gdHJhbnNwYXJlbnQgYm9yZGVyc1xuICAgICAqXG4gICAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBnZXQgdHJpbSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RyaW07XG4gICAgfVxuICAgIDtcbiAgICBzZXQgdHJpbSh0cmltKSB7XG4gICAgICAgIGlmICh0aGlzLl90cmltICE9PSB0cmltKSB7XG4gICAgICAgICAgICB0aGlzLl90cmltID0gdHJpbTtcbiAgICAgICAgICAgIHRoaXMuc3R5bGVJRCsrO1xuICAgICAgICB9XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBIb3cgbmV3bGluZXMgYW5kIHNwYWNlcyBzaG91bGQgYmUgaGFuZGxlZC5cbiAgICAgKiBEZWZhdWx0IGlzICdwcmUnIChwcmVzZXJ2ZSwgcHJlc2VydmUpLlxuICAgICAqXG4gICAgICogIHZhbHVlICAgfCBOZXcgbGluZXMgfCAgIFNwYWNlc1xuICAgICAqICAtLS0gICAgIHwgLS0tICAgICAgIHwgICAtLS1cbiAgICAgKiAnbm9ybWFsJyB8IENvbGxhcHNlICB8ICAgQ29sbGFwc2VcbiAgICAgKiAncHJlJyAgICB8IFByZXNlcnZlICB8ICAgUHJlc2VydmVcbiAgICAgKiAncHJlLWxpbmUnICAgfCBQcmVzZXJ2ZSAgfCAgIENvbGxhcHNlXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtzdHJpbmd9XG4gICAgICovXG4gICAgZ2V0IHdoaXRlU3BhY2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93aGl0ZVNwYWNlO1xuICAgIH1cbiAgICA7XG4gICAgc2V0IHdoaXRlU3BhY2Uod2hpdGVTcGFjZSkge1xuICAgICAgICBpZiAodGhpcy5fd2hpdGVTcGFjZSAhPT0gd2hpdGVTcGFjZSkge1xuICAgICAgICAgICAgdGhpcy5fd2hpdGVTcGFjZSA9IHdoaXRlU3BhY2U7XG4gICAgICAgICAgICB0aGlzLnN0eWxlSUQrKztcbiAgICAgICAgfVxuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIGlmIHdvcmQgd3JhcCBzaG91bGQgYmUgdXNlZFxuICAgICAqXG4gICAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBnZXQgd29yZFdyYXAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93b3JkV3JhcDtcbiAgICB9XG4gICAgO1xuICAgIHNldCB3b3JkV3JhcCh3b3JkV3JhcCkge1xuICAgICAgICBpZiAodGhpcy5fd29yZFdyYXAgIT09IHdvcmRXcmFwKSB7XG4gICAgICAgICAgICB0aGlzLl93b3JkV3JhcCA9IHdvcmRXcmFwO1xuICAgICAgICAgICAgdGhpcy5zdHlsZUlEKys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFRoZSB3aWR0aCBhdCB3aGljaCB0ZXh0IHdpbGwgd3JhcCwgaXQgbmVlZHMgd29yZFdyYXAgdG8gYmUgc2V0IHRvIHRydWVcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgd29yZFdyYXBXaWR0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dvcmRXcmFwV2lkdGg7XG4gICAgfVxuICAgIDtcbiAgICBzZXQgd29yZFdyYXBXaWR0aCh3b3JkV3JhcFdpZHRoKSB7XG4gICAgICAgIGlmICh0aGlzLl93b3JkV3JhcFdpZHRoICE9PSB3b3JkV3JhcFdpZHRoKSB7XG4gICAgICAgICAgICB0aGlzLl93b3JkV3JhcFdpZHRoID0gd29yZFdyYXBXaWR0aDtcbiAgICAgICAgICAgIHRoaXMuc3R5bGVJRCsrO1xuICAgICAgICB9XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgYSBmb250IHN0eWxlIHN0cmluZyB0byB1c2UgZm9yIGBUZXh0TWV0cmljcy5tZWFzdXJlRm9udCgpYC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gRm9udCBzdHlsZSBzdHJpbmcsIGZvciBwYXNzaW5nIHRvIGBUZXh0TWV0cmljcy5tZWFzdXJlRm9udCgpYFxuICAgICAqL1xuICAgIHRvRm9udFN0cmluZygpIHtcbiAgICAgICAgLy8gYnVpbGQgY2FudmFzIGFwaSBmb250IHNldHRpbmcgZnJvbSBpbmRpdmlkdWFsIGNvbXBvbmVudHMuIENvbnZlcnQgYSBudW1lcmljIHRoaXMuZm9udFNpemUgdG8gcHhcbiAgICAgICAgdmFyIGZvbnRTaXplU3RyaW5nID0gKHR5cGVvZiB0aGlzLmZvbnRTaXplID09PSAnbnVtYmVyJykgPyAoKHRoaXMuZm9udFNpemUpICsgXCJweFwiKSA6IHRoaXMuZm9udFNpemU7XG4gICAgICAgIC8vIENsZWFuLXVwIGZvbnRGYW1pbHkgcHJvcGVydHkgYnkgcXVvdGluZyBlYWNoIGZvbnQgbmFtZVxuICAgICAgICAvLyB0aGlzIHdpbGwgc3VwcG9ydCBmb250IG5hbWVzIHdpdGggc3BhY2VzXG4gICAgICAgIHZhciBmb250RmFtaWxpZXMgPSB0aGlzLmZvbnRGYW1pbHk7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh0aGlzLmZvbnRGYW1pbHkpKSB7XG4gICAgICAgICAgICBmb250RmFtaWxpZXMgPSB0aGlzLmZvbnRGYW1pbHkuc3BsaXQoJywnKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gZm9udEZhbWlsaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAvLyBUcmltIGFueSBleHRyYSB3aGl0ZS1zcGFjZVxuICAgICAgICAgICAgdmFyIGZvbnRGYW1pbHkgPSBmb250RmFtaWxpZXNbaV0udHJpbSgpO1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgZm9udCBhbHJlYWR5IGNvbnRhaW5zIHN0cmluZ3NcbiAgICAgICAgICAgIGlmICghKC8oW1xcXCJcXCddKVteXFwnXFxcIl0rXFwxLykudGVzdChmb250RmFtaWx5KSkge1xuICAgICAgICAgICAgICAgIGZvbnRGYW1pbHkgPSBcIlxcXCJcIiArIGZvbnRGYW1pbHkgKyBcIlxcXCJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvbnRGYW1pbGllc1tpXSA9IGZvbnRGYW1pbHk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICgodGhpcy5mb250U3R5bGUpICsgXCIgXCIgKyAodGhpcy5mb250VmFyaWFudCkgKyBcIiBcIiArICh0aGlzLmZvbnRXZWlnaHQpICsgXCIgXCIgKyBmb250U2l6ZVN0cmluZyArIFwiIFwiICsgKGZvbnRGYW1pbGllcy5qb2luKCcsJykpKTtcbiAgICB9XG4gICAgO1xufVxuZXhwb3J0cy5UZXh0U3R5bGUgPSBUZXh0U3R5bGU7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IEV2ZW50RGlzcGF0Y2hlcl8xID0gcmVxdWlyZShcIi4vRXZlbnREaXNwYXRjaGVyXCIpO1xuY29uc3QgUmVjdGFuZ2xlXzEgPSByZXF1aXJlKFwiLi4vZmxhc2gvZ2VvbS9SZWN0YW5nbGVcIik7XG5jb25zdCBQb2ludF8xID0gcmVxdWlyZShcIi4uL2ZsYXNoL2dlb20vUG9pbnRcIik7XG5jb25zdCBFdmVudF8xID0gcmVxdWlyZShcIi4vRXZlbnRcIik7XG5jb25zdCBUZXh0dXJlVXZzXzEgPSByZXF1aXJlKFwiLi9UZXh0dXJlVXZzXCIpO1xuY29uc3QgQmFzZVRleHR1cmVfMSA9IHJlcXVpcmUoXCIuL0Jhc2VUZXh0dXJlXCIpO1xuY29uc3QgSW1hZ2VSZXNvdXJjZV8xID0gcmVxdWlyZShcIi4vSW1hZ2VSZXNvdXJjZVwiKTtcbmNvbnN0IENhbnZhc1Jlc291cmNlXzEgPSByZXF1aXJlKFwiLi9DYW52YXNSZXNvdXJjZVwiKTtcbmNvbnN0IE1hdGhTZXR0aW5nc18xID0gcmVxdWlyZShcIi4vTWF0aFNldHRpbmdzXCIpO1xuY29uc3QgQ2FjaGVTZXR0aW5nc18xID0gcmVxdWlyZShcIi4vQ2FjaGVTZXR0aW5nc1wiKTtcbmNvbnN0IERpc3BsYXlTZXR0aW5nc18xID0gcmVxdWlyZShcIi4vRGlzcGxheVNldHRpbmdzXCIpO1xuY29uc3QgTmV0d29ya1NldHRpbmdzXzEgPSByZXF1aXJlKFwiLi9OZXR3b3JrU2V0dGluZ3NcIik7XG5jb25zdCBJbnN0YW5jZUNvdW50ZXJfMSA9IHJlcXVpcmUoXCIuL0luc3RhbmNlQ291bnRlclwiKTtcbmNsYXNzIFRleHR1cmUgZXh0ZW5kcyBFdmVudERpc3BhdGNoZXJfMS5FdmVudERpc3BhdGNoZXIge1xuICAgIGNvbnN0cnVjdG9yKGJhc2VUZXh0dXJlLCBmcmFtZSA9IG51bGwsIG9yaWcgPSBudWxsLCB0cmltID0gbnVsbCwgcm90YXRlID0gbnVsbCwgYW5jaG9yID0gbnVsbCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2FsbGVkIHdoZW4gdGhlIGJhc2UgdGV4dHVyZSBpcyB1cGRhdGVkXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICogQHBhcmFtIHtQSVhJLkJhc2VUZXh0dXJlfSBiYXNlVGV4dHVyZSAtIFRoZSBiYXNlIHRleHR1cmUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9uQmFzZVRleHR1cmVVcGRhdGVkID0gKGJhc2VUZXh0dXJlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVJRCsrO1xuICAgICAgICAgICAgLy8gVE9ETyB0aGlzIGNvZGUgbG9va3MgY29uZnVzaW5nLi4gYm9vIHRvIGFidXNpbmcgZ2V0dGVycyBhbmQgc2V0dGVycyFcbiAgICAgICAgICAgIGlmICh0aGlzLm5vRnJhbWUpIHtcbiAgICAgICAgICAgICAgICBJbnN0YW5jZUNvdW50ZXJfMS5JbnN0YW5jZUNvdW50ZXIuYWRkQ2FsbChcIlJlY3RhbmdsZS5nZXRSZWN0YW5nbGVcIiwgXCJUZXh0dXJlIG9uQmFzZVRleHR1cmVVcGRhdGVkXCIpO1xuICAgICAgICAgICAgICAgIHRoaXMuZnJhbWUgPSBSZWN0YW5nbGVfMS5SZWN0YW5nbGUuZ2V0UmVjdGFuZ2xlKDAsIDAsIGJhc2VUZXh0dXJlLndpZHRoLCBiYXNlVGV4dHVyZS5oZWlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mcmFtZSA9IHRoaXMuX2ZyYW1lO1xuICAgICAgICAgICAgICAgIC8vIFRPRE8gbWF5YmUgd2F0Y2ggb3V0IGZvciB0aGUgbm8gZnJhbWUgb3B0aW9uXG4gICAgICAgICAgICAgICAgLy8gdXBkYXRpbmcgdGhlIHRleHR1cmUgd2lsbCBzaG91bGQgdXBkYXRlIHRoZSBmcmFtZSBpZiBpdCB3YXMgc2V0IHRvIG5vIGZyYW1lLi5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudmFsaWQgPSB0aGlzLmJhc2VUZXh0dXJlLnZhbGlkO1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KEV2ZW50XzEuRXZlbnQuZ2V0RXZlbnQoXCJ1cGRhdGVcIikpO1xuICAgICAgICAgICAgLy8gdGhpcy5lbWl0KCd1cGRhdGUnLCB0aGlzKTtcbiAgICAgICAgICAgIC8vIHRoaXMuYmFzZVRleHR1cmUuYWRkRXZlbnRMaXN0ZW5lcihcInVwZGF0ZVwiLCB0aGlzLm9uQmFzZVRleHR1cmVVcGRhdGVkKVxuICAgICAgICB9O1xuICAgICAgICAvLyBJbnN0YW5jZUNvdW50ZXIuY291bnQodGhpcylcbiAgICAgICAgdGhpcy5ub0ZyYW1lID0gZmFsc2U7XG4gICAgICAgIGlmICghZnJhbWUpIHtcbiAgICAgICAgICAgIHRoaXMubm9GcmFtZSA9IHRydWU7XG4gICAgICAgICAgICBmcmFtZSA9IFJlY3RhbmdsZV8xLlJlY3RhbmdsZS5nZXRSZWN0YW5nbGUoMCwgMCwgMSwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJhc2VUZXh0dXJlIGluc3RhbmNlb2YgVGV4dHVyZSkge1xuICAgICAgICAgICAgYmFzZVRleHR1cmUgPSBiYXNlVGV4dHVyZS5iYXNlVGV4dHVyZTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGJhc2UgdGV4dHVyZSB0aGF0IHRoaXMgdGV4dHVyZSB1c2VzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLkJhc2VUZXh0dXJlfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5iYXNlVGV4dHVyZSA9IGJhc2VUZXh0dXJlO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBpcyB0aGUgYXJlYSBvZiB0aGUgQmFzZVRleHR1cmUgaW1hZ2UgdG8gYWN0dWFsbHkgY29weSB0byB0aGUgQ2FudmFzIC8gV2ViR0wgd2hlbiByZW5kZXJpbmcsXG4gICAgICAgICAqIGlycmVzcGVjdGl2ZSBvZiB0aGUgYWN0dWFsIGZyYW1lIHNpemUgb3IgcGxhY2VtZW50ICh3aGljaCBjYW4gYmUgaW5mbHVlbmNlZCBieSB0cmltbWVkIHRleHR1cmUgYXRsYXNlcylcbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7UElYSS5SZWN0YW5nbGV9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9mcmFtZSA9IGZyYW1lO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBpcyB0aGUgdHJpbW1lZCBhcmVhIG9mIG9yaWdpbmFsIHRleHR1cmUsIGJlZm9yZSBpdCB3YXMgcHV0IGluIGF0bGFzXG4gICAgICAgICAqIFBsZWFzZSBjYWxsIGB1cGRhdGVVdnMoKWAgYWZ0ZXIgeW91IGNoYW5nZSBjb29yZGluYXRlcyBvZiBgdHJpbWAgbWFudWFsbHkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuUmVjdGFuZ2xlfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50cmltID0gdHJpbTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgd2lsbCBsZXQgdGhlIHJlbmRlcmVyIGtub3cgaWYgdGhlIHRleHR1cmUgaXMgdmFsaWQuIElmIGl0J3Mgbm90IHRoZW4gaXQgY2Fubm90IGJlIHJlbmRlcmVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy52YWxpZCA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyB3aWxsIGxldCBhIHJlbmRlcmVyIGtub3cgdGhhdCBhIHRleHR1cmUgaGFzIGJlZW4gdXBkYXRlZCAodXNlZCBtYWlubHkgZm9yIFdlYkdMIHV2IHVwZGF0ZXMpXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJlcXVpcmVzVXBkYXRlID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgV2ViR0wgVVYgZGF0YSBjYWNoZS4gQ2FuIGJlIHVzZWQgYXMgcXVhZCBVVlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLlRleHR1cmVVdnN9XG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3V2cyA9IFRleHR1cmUuREVGQVVMVF9VVlM7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWZhdWx0IFRleHR1cmVNYXRyaXggaW5zdGFuY2UgZm9yIHRoaXMgdGV4dHVyZVxuICAgICAgICAgKiBCeSBkZWZhdWx0IHRoYXQgb2JqZWN0IGlzIG5vdCBjcmVhdGVkIGJlY2F1c2UgaXRzIGhlYXZ5XG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuVGV4dHVyZU1hdHJpeH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudXZNYXRyaXggPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBpcyB0aGUgYXJlYSBvZiBvcmlnaW5hbCB0ZXh0dXJlLCBiZWZvcmUgaXQgd2FzIHB1dCBpbiBhdGxhc1xuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLlJlY3RhbmdsZX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub3JpZyA9IG9yaWcgfHwgZnJhbWU7IC8vIG5ldyBSZWN0YW5nbGUoMCwgMCwgMSwgMSk7XG4gICAgICAgIHRoaXMuX3JvdGF0ZSA9IE51bWJlcihyb3RhdGUgfHwgMCk7XG4gICAgICAgIGlmIChyb3RhdGUgPT09IHRydWUpIHtcbiAgICAgICAgICAgIC8vIHRoaXMgaXMgb2xkIHRleHR1cmVwYWNrZXIgbGVnYWN5LCBzb21lIGdhbWVzL2xpYnJhcmllcyBhcmUgcGFzc2luZyBcInRydWVcIiBmb3Igcm90YXRlZCB0ZXh0dXJlc1xuICAgICAgICAgICAgdGhpcy5fcm90YXRlID0gMjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLl9yb3RhdGUgJSAyICE9PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2F0dGVtcHQgdG8gdXNlIGRpYW1vbmQtc2hhcGVkIFVWcy4gSWYgeW91IGFyZSBzdXJlLCBzZXQgcm90YXRpb24gbWFudWFsbHknKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYmFzZVRleHR1cmUudmFsaWQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm5vRnJhbWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoZnJhbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgZnJhbWUucmVjeWNsZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBJbnN0YW5jZUNvdW50ZXJfMS5JbnN0YW5jZUNvdW50ZXIuYWRkQ2FsbChcIlJlY3RhbmdsZS5nZXRSZWN0YW5nbGVcIiwgXCJUZXh0dXJlXCIpO1xuICAgICAgICAgICAgICAgIGZyYW1lID0gUmVjdGFuZ2xlXzEuUmVjdGFuZ2xlLmdldFJlY3RhbmdsZSgwLCAwLCBiYXNlVGV4dHVyZS53aWR0aCwgYmFzZVRleHR1cmUuaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGVyZSBpcyBubyBmcmFtZSB3ZSBzaG91bGQgbW9uaXRvciBmb3IgYW55IGJhc2UgdGV4dHVyZSBjaGFuZ2VzLi5cbiAgICAgICAgICAgICAgICBiYXNlVGV4dHVyZS5hZGRFdmVudExpc3RlbmVyKFwidXBkYXRlXCIsIHRoaXMub25CYXNlVGV4dHVyZVVwZGF0ZWQpO1xuICAgICAgICAgICAgICAgIC8vIGJhc2VUZXh0dXJlLm9uKCd1cGRhdGUnLCB0aGlzLm9uQmFzZVRleHR1cmVVcGRhdGVkLCB0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZnJhbWUgPSBmcmFtZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJhc2VUZXh0dXJlLmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkZWRcIiwgdGhpcy5vbkJhc2VUZXh0dXJlVXBkYXRlZCk7XG4gICAgICAgICAgICAvLyBiYXNlVGV4dHVyZS5vbmNlKCdsb2FkZWQnLCB0aGlzLm9uQmFzZVRleHR1cmVVcGRhdGVkLCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQW5jaG9yIHBvaW50IHRoYXQgaXMgdXNlZCBhcyBkZWZhdWx0IGlmIHNwcml0ZSBpcyBjcmVhdGVkIHdpdGggdGhpcyB0ZXh0dXJlLlxuICAgICAgICAgKiBDaGFuZ2luZyB0aGUgYGRlZmF1bHRBbmNob3JgIGF0IGEgbGF0ZXIgcG9pbnQgb2YgdGltZSB3aWxsIG5vdCB1cGRhdGUgU3ByaXRlJ3MgYW5jaG9yIHBvaW50LlxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLlBvaW50fVxuICAgICAgICAgKiBAZGVmYXVsdCB7MCwwfVxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKGFuY2hvcikge1xuICAgICAgICAgICAgdGhpcy5kZWZhdWx0QW5jaG9yID0gUG9pbnRfMS5Qb2ludC5nZXRQb2ludChhbmNob3IueCwgYW5jaG9yLnkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kZWZhdWx0QW5jaG9yID0gUG9pbnRfMS5Qb2ludC5nZXRQb2ludCgwLCAwKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogVXBkYXRlIElEIGlzIG9ic2VydmVkIGJ5IHNwcml0ZXMgYW5kIFRleHR1cmVNYXRyaXggaW5zdGFuY2VzLlxuICAgICAgICAgKiBDYWxsIHVwZGF0ZVV2cygpIHRvIGluY3JlbWVudCBpdC5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl91cGRhdGVJRCA9IDA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgaWRzIHVuZGVyIHdoaWNoIHRoaXMgVGV4dHVyZSBoYXMgYmVlbiBhZGRlZCB0byB0aGUgdGV4dHVyZSBjYWNoZS4gVGhpcyBpc1xuICAgICAgICAgKiBhdXRvbWF0aWNhbGx5IHNldCBhcyBsb25nIGFzIFRleHR1cmUuYWRkVG9DYWNoZSBpcyB1c2VkLCBidXQgbWF5IG5vdCBiZSBzZXQgaWYgYVxuICAgICAgICAgKiBUZXh0dXJlIGlzIGFkZGVkIGRpcmVjdGx5IHRvIHRoZSBUZXh0dXJlQ2FjaGUgYXJyYXkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge3N0cmluZ1tdfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50ZXh0dXJlQ2FjaGVJZHMgPSBbXTtcbiAgICB9XG4gICAgZGVzdHJ1Y3RvcigpIHtcbiAgICAgICAgaWYgKHRoaXMuZGVmYXVsdEFuY2hvcikge1xuICAgICAgICAgICAgdGhpcy5kZWZhdWx0QW5jaG9yLnJlY3ljbGUoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlZmF1bHRBbmNob3IgPSBudWxsO1xuICAgICAgICBpZiAodGhpcy50cmltKSB7XG4gICAgICAgICAgICB0aGlzLnRyaW0ucmVjeWNsZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudHJpbSA9IG51bGw7XG4gICAgICAgIGlmICh0aGlzLm9yaWcpIHtcbiAgICAgICAgICAgIHRoaXMub3JpZy5yZWN5Y2xlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vcmlnID0gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGlzIHRleHR1cmUgb24gdGhlIGdwdS5cbiAgICAgKlxuICAgICAqL1xuICAgIHVwZGF0ZSgpIHtcbiAgICAgICAgdGhpcy5iYXNlVGV4dHVyZS51cGRhdGUoKTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIERlc3Ryb3lzIHRoaXMgdGV4dHVyZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZGVzdHJveUJhc2U9ZmFsc2VdIFdoZXRoZXIgdG8gZGVzdHJveSB0aGUgYmFzZSB0ZXh0dXJlIGFzIHdlbGxcbiAgICAgKi9cbiAgICBkZXN0cm95KGRlc3Ryb3lCYXNlKSB7XG4gICAgICAgIGlmICh0aGlzLmJhc2VUZXh0dXJlKSB7XG4gICAgICAgICAgICBpZiAoZGVzdHJveUJhc2UpIHtcbiAgICAgICAgICAgICAgICAvLyBkZWxldGUgdGhlIHRleHR1cmUgaWYgaXQgZXhpc3RzIGluIHRoZSB0ZXh0dXJlIGNhY2hlLi5cbiAgICAgICAgICAgICAgICAvLyB0aGlzIG9ubHkgbmVlZHMgdG8gYmUgcmVtb3ZlZCBpZiB0aGUgYmFzZSB0ZXh0dXJlIGlzIGFjdHVhbGx5IGRlc3Ryb3llZCB0b28uLlxuICAgICAgICAgICAgICAgIGlmIChDYWNoZVNldHRpbmdzXzEuQ2FjaGVTZXR0aW5ncy5UZXh0dXJlQ2FjaGVbdGhpcy5iYXNlVGV4dHVyZS5pbWFnZVVybF0pIHtcbiAgICAgICAgICAgICAgICAgICAgVGV4dHVyZS5yZW1vdmVGcm9tQ2FjaGUodGhpcy5iYXNlVGV4dHVyZS5pbWFnZVVybCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuYmFzZVRleHR1cmUuZGVzdHJveSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdGhpcy5iYXNlVGV4dHVyZS5yZW1vKCd1cGRhdGUnLCB0aGlzLm9uQmFzZVRleHR1cmVVcGRhdGVkLCB0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuYmFzZVRleHR1cmUgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9mcmFtZSkge1xuICAgICAgICAgICAgdGhpcy5fZnJhbWUucmVjeWNsZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2ZyYW1lID0gbnVsbDtcbiAgICAgICAgdGhpcy5fdXZzID0gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMudHJpbSkge1xuICAgICAgICAgICAgdGhpcy50cmltLnJlY3ljbGUoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRyaW0gPSBudWxsO1xuICAgICAgICBpZiAodGhpcy5vcmlnKSB7XG4gICAgICAgICAgICB0aGlzLm9yaWcucmVjeWNsZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3JpZyA9IG51bGw7XG4gICAgICAgIHRoaXMudmFsaWQgPSBmYWxzZTtcbiAgICAgICAgVGV4dHVyZS5yZW1vdmVGcm9tQ2FjaGUodGhpcyk7XG4gICAgICAgIHRoaXMudGV4dHVyZUNhY2hlSWRzID0gbnVsbDtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgdGV4dHVyZSBvYmplY3QgdGhhdCBhY3RzIHRoZSBzYW1lIGFzIHRoaXMgb25lLlxuICAgICAqXG4gICAgICogQHJldHVybiB7UElYSS5UZXh0dXJlfSBUaGUgbmV3IHRleHR1cmVcbiAgICAgKi9cbiAgICBjbG9uZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUZXh0dXJlKHRoaXMuYmFzZVRleHR1cmUsIHRoaXMuZnJhbWUsIHRoaXMub3JpZywgdGhpcy50cmltLCB0aGlzLnJvdGF0ZSwgdGhpcy5kZWZhdWx0QW5jaG9yKTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIGludGVybmFsIFdlYkdMIFVWIGNhY2hlLiBVc2UgaXQgYWZ0ZXIgeW91IGNoYW5nZSBgZnJhbWVgIG9yIGB0cmltYCBvZiB0aGUgdGV4dHVyZS5cbiAgICAgKiBDYWxsIGl0IGFmdGVyIGNoYW5naW5nIHRoZSBmcmFtZVxuICAgICAqL1xuICAgIHVwZGF0ZVV2cygpIHtcbiAgICAgICAgaWYgKHRoaXMuX3V2cyA9PT0gVGV4dHVyZS5ERUZBVUxUX1VWUykge1xuICAgICAgICAgICAgdGhpcy5fdXZzID0gbmV3IFRleHR1cmVVdnNfMS5UZXh0dXJlVXZzKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdXZzLnNldCh0aGlzLl9mcmFtZSwgdGhpcy5iYXNlVGV4dHVyZSwgdGhpcy5yb3RhdGUpO1xuICAgICAgICB0aGlzLl91cGRhdGVJRCsrO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogSGVscGVyIGZ1bmN0aW9uIHRoYXQgY3JlYXRlcyBhIG5ldyBUZXh0dXJlIGJhc2VkIG9uIHRoZSBzb3VyY2UgeW91IHByb3ZpZGUuXG4gICAgICogVGhlIHNvdXJjZSBjYW4gYmUgLSBmcmFtZSBpZCwgaW1hZ2UgdXJsLCB2aWRlbyB1cmwsIGNhbnZhcyBlbGVtZW50LCB2aWRlbyBlbGVtZW50LCBiYXNlIHRleHR1cmVcbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge251bWJlcnxzdHJpbmd8SFRNTEltYWdlRWxlbWVudHxIVE1MQ2FudmFzRWxlbWVudHxIVE1MVmlkZW9FbGVtZW50fFBJWEkuQmFzZVRleHR1cmV9IHNvdXJjZVxuICAgICAqICAgICAgICBTb3VyY2UgdG8gY3JlYXRlIHRleHR1cmUgZnJvbVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gU2VlIHtAbGluayBQSVhJLkJhc2VUZXh0dXJlfSdzIGNvbnN0cnVjdG9yIGZvciBvcHRpb25zLlxuICAgICAqIEByZXR1cm4ge1BJWEkuVGV4dHVyZX0gVGhlIG5ld2x5IGNyZWF0ZWQgdGV4dHVyZVxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tKHNvdXJjZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHZhciBjYWNoZUlkID0gbnVsbDtcbiAgICAgICAgaWYgKHR5cGVvZiBzb3VyY2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjYWNoZUlkID0gc291cmNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFzb3VyY2UuX3BpeGlJZCkge1xuICAgICAgICAgICAgICAgIHNvdXJjZS5fcGl4aUlkID0gXCJwaXhpaWRfXCIgKyAoTWF0aFNldHRpbmdzXzEuTWF0aFNldHRpbmdzLnVpZCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhY2hlSWQgPSBzb3VyY2UuX3BpeGlJZDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdGV4dHVyZSA9IENhY2hlU2V0dGluZ3NfMS5DYWNoZVNldHRpbmdzLlRleHR1cmVDYWNoZVtjYWNoZUlkXTtcbiAgICAgICAgaWYgKCF0ZXh0dXJlKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9uc1sncmVzb2x1dGlvbiddID09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMucmVzb2x1dGlvbiA9IE5ldHdvcmtTZXR0aW5nc18xLk5ldHdvcmtTZXR0aW5ncy5nZXRSZXNvbHV0aW9uT2ZVcmwoc291cmNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRleHR1cmUgPSBuZXcgVGV4dHVyZShuZXcgQmFzZVRleHR1cmVfMS5CYXNlVGV4dHVyZShzb3VyY2UsIG9wdGlvbnMpKTtcbiAgICAgICAgICAgIHRleHR1cmUuYmFzZVRleHR1cmUuY2FjaGVJZCA9IGNhY2hlSWQ7XG4gICAgICAgICAgICBCYXNlVGV4dHVyZV8xLkJhc2VUZXh0dXJlLmFkZFRvQ2FjaGUodGV4dHVyZS5iYXNlVGV4dHVyZSwgY2FjaGVJZCk7XG4gICAgICAgICAgICBUZXh0dXJlLmFkZFRvQ2FjaGUodGV4dHVyZSwgY2FjaGVJZCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbGV0cyBhc3N1bWUgaXRzIGEgYmFzZSB0ZXh0dXJlIVxuICAgICAgICByZXR1cm4gdGV4dHVyZTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIEFkZHMgYSBUZXh0dXJlIHRvIHRoZSBnbG9iYWwgVGV4dHVyZUNhY2hlLiBUaGlzIGNhY2hlIGlzIHNoYXJlZCBhY3Jvc3MgdGhlIHdob2xlIFBJWEkgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7UElYSS5UZXh0dXJlfSB0ZXh0dXJlIC0gVGhlIFRleHR1cmUgdG8gYWRkIHRvIHRoZSBjYWNoZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgLSBUaGUgaWQgdGhhdCB0aGUgVGV4dHVyZSB3aWxsIGJlIHN0b3JlZCBhZ2FpbnN0LlxuICAgICAqL1xuICAgIHN0YXRpYyBhZGRUb0NhY2hlKHRleHR1cmUsIGlkKSB7XG4gICAgICAgIGlmIChpZCkge1xuICAgICAgICAgICAgaWYgKHRleHR1cmUudGV4dHVyZUNhY2hlSWRzLmluZGV4T2YoaWQpID09PSAtMSkge1xuICAgICAgICAgICAgICAgIHRleHR1cmUudGV4dHVyZUNhY2hlSWRzLnB1c2goaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKENhY2hlU2V0dGluZ3NfMS5DYWNoZVNldHRpbmdzLlRleHR1cmVDYWNoZVtpZF0pIHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybigoXCJUZXh0dXJlIGFkZGVkIHRvIHRoZSBjYWNoZSB3aXRoIGFuIGlkIFtcIiArIGlkICsgXCJdIHRoYXQgYWxyZWFkeSBoYWQgYW4gZW50cnlcIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgQ2FjaGVTZXR0aW5nc18xLkNhY2hlU2V0dGluZ3MuVGV4dHVyZUNhY2hlW2lkXSA9IHRleHR1cmU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhIFRleHR1cmUgZnJvbSB0aGUgZ2xvYmFsIFRleHR1cmVDYWNoZS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xQSVhJLlRleHR1cmV9IHRleHR1cmUgLSBpZCBvZiBhIFRleHR1cmUgdG8gYmUgcmVtb3ZlZCwgb3IgYSBUZXh0dXJlIGluc3RhbmNlIGl0c2VsZlxuICAgICAqIEByZXR1cm4ge1BJWEkuVGV4dHVyZXxudWxsfSBUaGUgVGV4dHVyZSB0aGF0IHdhcyByZW1vdmVkXG4gICAgICovXG4gICAgc3RhdGljIHJlbW92ZUZyb21DYWNoZSh0ZXh0dXJlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGV4dHVyZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHZhciB0ZXh0dXJlRnJvbUNhY2hlID0gQ2FjaGVTZXR0aW5nc18xLkNhY2hlU2V0dGluZ3MuVGV4dHVyZUNhY2hlW3RleHR1cmVdO1xuICAgICAgICAgICAgaWYgKHRleHR1cmVGcm9tQ2FjaGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSB0ZXh0dXJlRnJvbUNhY2hlLnRleHR1cmVDYWNoZUlkcy5pbmRleE9mKHRleHR1cmUpO1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHRleHR1cmVGcm9tQ2FjaGUudGV4dHVyZUNhY2hlSWRzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlbGV0ZSBDYWNoZVNldHRpbmdzXzEuQ2FjaGVTZXR0aW5ncy5UZXh0dXJlQ2FjaGVbdGV4dHVyZV07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRleHR1cmVGcm9tQ2FjaGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGV4dHVyZSAmJiB0ZXh0dXJlLnRleHR1cmVDYWNoZUlkcykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZXh0dXJlLnRleHR1cmVDYWNoZUlkcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIC8vIENoZWNrIHRoYXQgdGV4dHVyZSBtYXRjaGVzIHRoZSBvbmUgYmVpbmcgcGFzc2VkIGluIGJlZm9yZSBkZWxldGluZyBpdCBmcm9tIHRoZSBjYWNoZS5cbiAgICAgICAgICAgICAgICBpZiAoQ2FjaGVTZXR0aW5nc18xLkNhY2hlU2V0dGluZ3MuVGV4dHVyZUNhY2hlW3RleHR1cmUudGV4dHVyZUNhY2hlSWRzW2ldXSA9PT0gdGV4dHVyZSkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgQ2FjaGVTZXR0aW5nc18xLkNhY2hlU2V0dGluZ3MuVGV4dHVyZUNhY2hlW3RleHR1cmUudGV4dHVyZUNhY2hlSWRzW2ldXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0ZXh0dXJlLnRleHR1cmVDYWNoZUlkcy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgcmV0dXJuIHRleHR1cmU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIDtcbiAgICBnZXQgZnJhbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9mcmFtZTtcbiAgICB9XG4gICAgO1xuICAgIHNldCBmcmFtZShmcmFtZSkge1xuICAgICAgICB0aGlzLl9mcmFtZSA9IGZyYW1lO1xuICAgICAgICB0aGlzLm5vRnJhbWUgPSBmYWxzZTtcbiAgICAgICAgdmFyIHggPSBmcmFtZS54O1xuICAgICAgICB2YXIgeSA9IGZyYW1lLnk7XG4gICAgICAgIHZhciB3aWR0aCA9IGZyYW1lLndpZHRoO1xuICAgICAgICB2YXIgaGVpZ2h0ID0gZnJhbWUuaGVpZ2h0O1xuICAgICAgICB2YXIgeE5vdEZpdCA9IHggKyB3aWR0aCA+IHRoaXMuYmFzZVRleHR1cmUud2lkdGg7XG4gICAgICAgIHZhciB5Tm90Rml0ID0geSArIGhlaWdodCA+IHRoaXMuYmFzZVRleHR1cmUuaGVpZ2h0O1xuICAgICAgICBpZiAoeE5vdEZpdCB8fCB5Tm90Rml0KSB7XG4gICAgICAgICAgICB2YXIgcmVsYXRpb25zaGlwID0geE5vdEZpdCAmJiB5Tm90Rml0ID8gJ2FuZCcgOiAnb3InO1xuICAgICAgICAgICAgdmFyIGVycm9yWCA9IFwiWDogXCIgKyB4ICsgXCIgKyBcIiArIHdpZHRoICsgXCIgPSBcIiArICh4ICsgd2lkdGgpICsgXCIgPiBcIiArICh0aGlzLmJhc2VUZXh0dXJlLndpZHRoKTtcbiAgICAgICAgICAgIHZhciBlcnJvclkgPSBcIlk6IFwiICsgeSArIFwiICsgXCIgKyBoZWlnaHQgKyBcIiA9IFwiICsgKHkgKyBoZWlnaHQpICsgXCIgPiBcIiArICh0aGlzLmJhc2VUZXh0dXJlLmhlaWdodCk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RleHR1cmUgRXJyb3I6IGZyYW1lIGRvZXMgbm90IGZpdCBpbnNpZGUgdGhlIGJhc2UgVGV4dHVyZSBkaW1lbnNpb25zOiAnXG4gICAgICAgICAgICAgICAgKyBlcnJvclggKyBcIiBcIiArIHJlbGF0aW9uc2hpcCArIFwiIFwiICsgZXJyb3JZKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnZhbGlkID0gd2lkdGggJiYgaGVpZ2h0ICYmIHRoaXMuYmFzZVRleHR1cmUudmFsaWQ7XG4gICAgICAgIGlmICghdGhpcy50cmltICYmICF0aGlzLnJvdGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5vcmlnID0gZnJhbWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudmFsaWQpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVXZzKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSB0ZXh0dXJlIGlzIHJvdGF0ZWQgaW5zaWRlIHRoZSBhdGxhc1xuICAgICAqIHNldCB0byAyIHRvIGNvbXBlbnNhdGUgZm9yIHRleHR1cmUgcGFja2VyIHJvdGF0aW9uXG4gICAgICogc2V0IHRvIDYgdG8gY29tcGVuc2F0ZSBmb3Igc3BpbmUgcGFja2VyIHJvdGF0aW9uXG4gICAgICogY2FuIGJlIHVzZWQgdG8gcm90YXRlIG9yIG1pcnJvciBzcHJpdGVzXG4gICAgICogU2VlIHtAbGluayBQSVhJLkdyb3VwRDh9IGZvciBleHBsYW5hdGlvblxuICAgICAqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdldCByb3RhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yb3RhdGU7XG4gICAgfVxuICAgIDtcbiAgICBzZXQgcm90YXRlKHJvdGF0ZSkge1xuICAgICAgICB0aGlzLl9yb3RhdGUgPSByb3RhdGU7XG4gICAgICAgIGlmICh0aGlzLnZhbGlkKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVV2cygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBUaGUgd2lkdGggb2YgdGhlIFRleHR1cmUgaW4gcGl4ZWxzLlxuICAgICAqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdldCB3aWR0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3JpZy53aWR0aDtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFRoZSBoZWlnaHQgb2YgdGhlIFRleHR1cmUgaW4gcGl4ZWxzLlxuICAgICAqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdldCBoZWlnaHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9yaWcuaGVpZ2h0O1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogQW4gZW1wdHkgdGV4dHVyZSwgdXNlZCBvZnRlbiB0byBub3QgaGF2ZSB0byBjcmVhdGUgbXVsdGlwbGUgZW1wdHkgdGV4dHVyZXMuXG4gICAgICogQ2FuIG5vdCBiZSBkZXN0cm95ZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQGNvbnN0YW50XG4gICAgICogQG1lbWJlciB7UElYSS5UZXh0dXJlfVxuICAgICAqL1xuICAgIHN0YXRpYyBnZXQgRU1QVFkoKSB7XG4gICAgICAgIHJldHVybiBuZXcgVGV4dHVyZShuZXcgQmFzZVRleHR1cmVfMS5CYXNlVGV4dHVyZSgpKTtcbiAgICB9XG4gICAgLyoqXG4gKiBBIHdoaXRlIHRleHR1cmUgb2YgMTB4MTAgc2l6ZSwgdXNlZCBmb3IgZ3JhcGhpY3MgYW5kIG90aGVyIHRoaW5nc1xuICogQ2FuIG5vdCBiZSBkZXN0cm95ZWQuXG4gKlxuICogQHN0YXRpY1xuICogQGNvbnN0YW50XG4gKiBAbWVtYmVyIHtQSVhJLlRleHR1cmV9XG4gKi9cbiAgICBzdGF0aWMgZ2V0IFdISVRFKCkge1xuICAgICAgICByZXR1cm4gVGV4dHVyZS5jcmVhdGVXaGl0ZVRleHR1cmUoKTtcbiAgICB9XG4gICAgc3RhdGljIGNyZWF0ZVdoaXRlVGV4dHVyZSgpIHtcbiAgICAgICAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICBjYW52YXMud2lkdGggPSAxNjtcbiAgICAgICAgY2FudmFzLmhlaWdodCA9IDE2O1xuICAgICAgICB2YXIgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9ICd3aGl0ZSc7XG4gICAgICAgIGNvbnRleHQuZmlsbFJlY3QoMCwgMCwgMTYsIDE2KTtcbiAgICAgICAgcmV0dXJuIG5ldyBUZXh0dXJlKG5ldyBCYXNlVGV4dHVyZV8xLkJhc2VUZXh0dXJlKG5ldyBDYW52YXNSZXNvdXJjZV8xLkNhbnZhc1Jlc291cmNlKGNhbnZhcykpKTtcbiAgICB9XG59XG5UZXh0dXJlLkRFRkFVTFRfVVZTID0gbmV3IFRleHR1cmVVdnNfMS5UZXh0dXJlVXZzKCk7XG4vKipcbiAqIENyZWF0ZSBhIG5ldyBUZXh0dXJlIHdpdGggYSBCdWZmZXJSZXNvdXJjZSBmcm9tIGEgRmxvYXQzMkFycmF5LlxuICogUkdCQSB2YWx1ZXMgYXJlIGZsb2F0cyBmcm9tIDAgdG8gMS5cbiAqIEBzdGF0aWNcbiAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fFVpbnQ4QXJyYXl9IGJ1ZmZlciBUaGUgb3B0aW9uYWwgYXJyYXkgdG8gdXNlLCBpZiBubyBkYXRhXG4gKiAgICAgICAgaXMgcHJvdmlkZWQsIGEgbmV3IEZsb2F0MzJBcnJheSBpcyBjcmVhdGVkLlxuICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIC0gV2lkdGggb2YgdGhlIHJlc291cmNlXG4gKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IC0gSGVpZ2h0IG9mIHRoZSByZXNvdXJjZVxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSBTZWUge0BsaW5rIFBJWEkuQmFzZVRleHR1cmV9J3MgY29uc3RydWN0b3IgZm9yIG9wdGlvbnMuXG4gKiBAcmV0dXJuIHtQSVhJLlRleHR1cmV9IFRoZSByZXN1bHRpbmcgbmV3IEJhc2VUZXh0dXJlXG4gKi9cblRleHR1cmUuZnJvbUJ1ZmZlciA9IGZ1bmN0aW9uIGZyb21CdWZmZXIoYnVmZmVyLCB3aWR0aCwgaGVpZ2h0LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBUZXh0dXJlKEJhc2VUZXh0dXJlXzEuQmFzZVRleHR1cmUuZnJvbUJ1ZmZlcihidWZmZXIsIHdpZHRoLCBoZWlnaHQsIG9wdGlvbnMpKTtcbn07XG4vKipcbiAqIENyZWF0ZSBhIHRleHR1cmUgZnJvbSBhIHNvdXJjZSBhbmQgYWRkIHRvIHRoZSBjYWNoZS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAcGFyYW0ge0hUTUxJbWFnZUVsZW1lbnR8SFRNTENhbnZhc0VsZW1lbnR9IHNvdXJjZSAtIFRoZSBpbnB1dCBzb3VyY2UuXG4gKiBAcGFyYW0ge1N0cmluZ30gaW1hZ2VVcmwgLSBGaWxlIG5hbWUgb2YgdGV4dHVyZSwgZm9yIGNhY2hlIGFuZCByZXNvbHZpbmcgcmVzb2x1dGlvbi5cbiAqIEBwYXJhbSB7U3RyaW5nfSBbbmFtZV0gLSBIdW1hbiByZWFkYWJsZSBuYW1lIGZvciB0aGUgdGV4dHVyZSBjYWNoZS4gSWYgbm8gbmFtZSBpc1xuICogICAgICAgIHNwZWNpZmllZCwgb25seSBgaW1hZ2VVcmxgIHdpbGwgYmUgdXNlZCBhcyB0aGUgY2FjaGUgSUQuXG4gKiBAcmV0dXJuIHtQSVhJLlRleHR1cmV9IE91dHB1dCB0ZXh0dXJlXG4gKi9cblRleHR1cmUuZnJvbUxvYWRlciA9IGZ1bmN0aW9uIGZyb21Mb2FkZXIoc291cmNlLCBpbWFnZVVybCwgbmFtZSkge1xuICAgIHZhciByZXNvdXJjZSA9IG5ldyBJbWFnZVJlc291cmNlXzEuSW1hZ2VSZXNvdXJjZShzb3VyY2UpO1xuICAgIHJlc291cmNlLnVybCA9IGltYWdlVXJsO1xuICAgIHZhciBiYXNlVGV4dHVyZSA9IG5ldyBCYXNlVGV4dHVyZV8xLkJhc2VUZXh0dXJlKHJlc291cmNlLCB7XG4gICAgICAgIHNjYWxlTW9kZTogRGlzcGxheVNldHRpbmdzXzEuRGlzcGxheVNldHRpbmdzLlNDQUxFX01PREUsXG4gICAgICAgIHJlc29sdXRpb246IE5ldHdvcmtTZXR0aW5nc18xLk5ldHdvcmtTZXR0aW5ncy5nZXRSZXNvbHV0aW9uT2ZVcmwoaW1hZ2VVcmwpLFxuICAgIH0pO1xuICAgIHZhciB0ZXh0dXJlID0gbmV3IFRleHR1cmUoYmFzZVRleHR1cmUpO1xuICAgIC8vIE5vIG5hbWUsIHVzZSBpbWFnZVVybCBpbnN0ZWFkXG4gICAgaWYgKCFuYW1lKSB7XG4gICAgICAgIG5hbWUgPSBpbWFnZVVybDtcbiAgICB9XG4gICAgLy8gbGV0cyBhbHNvIGFkZCB0aGUgZnJhbWUgdG8gcGl4aSdzIGdsb2JhbCBjYWNoZSBmb3IgZnJvbUZyYW1lIGFuZCBmcm9tSW1hZ2UgZnVuY3Rpb25zXG4gICAgQmFzZVRleHR1cmVfMS5CYXNlVGV4dHVyZS5hZGRUb0NhY2hlKHRleHR1cmUuYmFzZVRleHR1cmUsIG5hbWUpO1xuICAgIFRleHR1cmUuYWRkVG9DYWNoZSh0ZXh0dXJlLCBuYW1lKTtcbiAgICAvLyBhbHNvIGFkZCByZWZlcmVuY2VzIGJ5IHVybCBpZiB0aGV5IGFyZSBkaWZmZXJlbnQuXG4gICAgaWYgKG5hbWUgIT09IGltYWdlVXJsKSB7XG4gICAgICAgIEJhc2VUZXh0dXJlXzEuQmFzZVRleHR1cmUuYWRkVG9DYWNoZSh0ZXh0dXJlLmJhc2VUZXh0dXJlLCBpbWFnZVVybCk7XG4gICAgICAgIFRleHR1cmUuYWRkVG9DYWNoZSh0ZXh0dXJlLCBpbWFnZVVybCk7XG4gICAgfVxuICAgIHJldHVybiB0ZXh0dXJlO1xufTtcbmV4cG9ydHMuVGV4dHVyZSA9IFRleHR1cmU7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IFN5c3RlbV8xID0gcmVxdWlyZShcIi4vU3lzdGVtXCIpO1xuY29uc3Qgc2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL3NldHRpbmdzXCIpO1xuY2xhc3MgVGV4dHVyZUdDU3lzdGVtIGV4dGVuZHMgU3lzdGVtXzEuU3lzdGVtIHtcbiAgICBjb25zdHJ1Y3RvcihyZW5kZXJlcikge1xuICAgICAgICBzdXBlcihyZW5kZXJlcik7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb3VudFxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqIEByZWFkb25seVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jb3VudCA9IDA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDaGVjayBjb3VudFxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqIEByZWFkb25seVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jaGVja0NvdW50ID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1heGltdW0gaWRsZSB0aW1lLCBpbiBzZWNvbmRzXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICogQHNlZSBQSVhJLnNldHRpbmdzLkdDX01BWF9JRExFXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm1heElkbGUgPSBzZXR0aW5nc18xLnNldHRpbmdzLkdDX01BWF9JRExFO1xuICAgICAgICAvKipcbiAgICAgICAgICogTWF4aW11bSBudW1iZXIgb2YgaXRlc20gdG8gY2hlY2tcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKiBAc2VlIFBJWEkuc2V0dGluZ3MuR0NfTUFYX0NIRUNLX0NPVU5UXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNoZWNrQ291bnRNYXggPSBzZXR0aW5nc18xLnNldHRpbmdzLkdDX01BWF9DSEVDS19DT1VOVDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEN1cnJlbnQgZ2FyYWJhZ2UgY29sbGVjdGlvbiBtb2RlXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuR0NfTU9ERVN9XG4gICAgICAgICAqIEBzZWUgUElYSS5zZXR0aW5ncy5HQ19NT0RFXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm1vZGUgPSBzZXR0aW5nc18xLnNldHRpbmdzLkdDX01PREU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrcyB0byBzZWUgd2hlbiB0aGUgbGFzdCB0aW1lIGEgdGV4dHVyZSB3YXMgdXNlZFxuICAgICAqIGlmIHRoZSB0ZXh0dXJlIGhhcyBub3QgYmVlbiB1c2VkIGZvciBhIHNwZWNpZmllZCBhbW91bnQgb2YgdGltZSBpdCB3aWxsIGJlIHJlbW92ZWQgZnJvbSB0aGUgR1BVXG4gICAgICovXG4gICAgcG9zdHJlbmRlcigpIHtcbiAgICAgICAgdGhpcy5jb3VudCsrO1xuICAgICAgICBpZiAodGhpcy5tb2RlID09PSBzZXR0aW5nc18xLnNldHRpbmdzLkdDX01PREVTLk1BTlVBTCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2hlY2tDb3VudCsrO1xuICAgICAgICBpZiAodGhpcy5jaGVja0NvdW50ID4gdGhpcy5jaGVja0NvdW50TWF4KSB7XG4gICAgICAgICAgICB0aGlzLmNoZWNrQ291bnQgPSAwO1xuICAgICAgICAgICAgdGhpcy5ydW4oKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHRvIHNlZSB3aGVuIHRoZSBsYXN0IHRpbWUgYSB0ZXh0dXJlIHdhcyB1c2VkXG4gICAgICogaWYgdGhlIHRleHR1cmUgaGFzIG5vdCBiZWVuIHVzZWQgZm9yIGEgc3BlY2lmaWVkIGFtb3VudCBvZiB0aW1lIGl0IHdpbGwgYmUgcmVtb3ZlZCBmcm9tIHRoZSBHUFVcbiAgICAgKi9cbiAgICBydW4oKSB7XG4gICAgICAgIHZhciB0bSA9IHRoaXMucmVuZGVyZXIudGV4dHVyZTtcbiAgICAgICAgdmFyIG1hbmFnZWRUZXh0dXJlcyA9IHRtLm1hbmFnZWRUZXh0dXJlcztcbiAgICAgICAgdmFyIHdhc1JlbW92ZWQgPSBmYWxzZTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYW5hZ2VkVGV4dHVyZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciB0ZXh0dXJlID0gbWFuYWdlZFRleHR1cmVzW2ldO1xuICAgICAgICAgICAgLy8gb25seSBzdXBwb3J0cyBub24gZ2VuZXJhdGVkIHRleHR1cmVzIGF0IHRoZSBtb21lbnQhXG4gICAgICAgICAgICBpZiAoIXRleHR1cmUuZnJhbWVidWZmZXIgJiYgdGhpcy5jb3VudCAtIHRleHR1cmUudG91Y2hlZCA+IHRoaXMubWF4SWRsZSkge1xuICAgICAgICAgICAgICAgIHRtLmRlc3Ryb3lUZXh0dXJlKHRleHR1cmUsIHRydWUpO1xuICAgICAgICAgICAgICAgIG1hbmFnZWRUZXh0dXJlc1tpXSA9IG51bGw7XG4gICAgICAgICAgICAgICAgd2FzUmVtb3ZlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdhc1JlbW92ZWQpIHtcbiAgICAgICAgICAgIHZhciBqID0gMDtcbiAgICAgICAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IG1hbmFnZWRUZXh0dXJlcy5sZW5ndGg7IGkkMSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1hbmFnZWRUZXh0dXJlc1tpJDFdICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hbmFnZWRUZXh0dXJlc1tqKytdID0gbWFuYWdlZFRleHR1cmVzW2kkMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWFuYWdlZFRleHR1cmVzLmxlbmd0aCA9IGo7XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIHRoZSB0ZXh0dXJlcyB3aXRoaW4gdGhlIHNwZWNpZmllZCBkaXNwbGF5T2JqZWN0IGFuZCBpdHMgY2hpbGRyZW4gZnJvbSB0aGUgR1BVXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BJWEkuRGlzcGxheU9iamVjdH0gZGlzcGxheU9iamVjdCAtIHRoZSBkaXNwbGF5T2JqZWN0IHRvIHJlbW92ZSB0aGUgdGV4dHVyZXMgZnJvbS5cbiAgICAgKi9cbiAgICB1bmxvYWQoZGlzcGxheU9iamVjdCkge1xuICAgICAgICAvLyB2YXIgdG0gPSB0aGlzLnJlbmRlcmVyLnRleHR1cmVTeXN0ZW07XG4gICAgICAgIHZhciB0bSA9IHRoaXMucmVuZGVyZXIudGV4dHVyZTtcbiAgICAgICAgLy8gb25seSBkZXN0cm95IG5vbiBnZW5lcmF0ZWQgdGV4dHVyZXNcbiAgICAgICAgaWYgKGRpc3BsYXlPYmplY3QuX3RleHR1cmUgJiYgZGlzcGxheU9iamVjdC5fdGV4dHVyZS5fZ2xSZW5kZXJUYXJnZXRzKSB7XG4gICAgICAgICAgICB0bS5kZXN0cm95VGV4dHVyZShkaXNwbGF5T2JqZWN0Ll90ZXh0dXJlKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gZGlzcGxheU9iamVjdC5jaGlsZHJlbi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgdGhpcy51bmxvYWQoZGlzcGxheU9iamVjdC5jaGlsZHJlbltpXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xufVxuZXhwb3J0cy5UZXh0dXJlR0NTeXN0ZW0gPSBUZXh0dXJlR0NTeXN0ZW07XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IE1hdHJpeF8xID0gcmVxdWlyZShcIi4vTWF0cml4XCIpO1xuY2xhc3MgVGV4dHVyZU1hdHJpeCB7XG4gICAgY29uc3RydWN0b3IodGV4dHVyZSwgY2xhbXBNYXJnaW4gPSBudWxsKSB7XG4gICAgICAgIHRoaXMuX3RleHR1cmUgPSB0ZXh0dXJlO1xuICAgICAgICB0aGlzLm1hcENvb3JkID0gbmV3IE1hdHJpeF8xLk1hdHJpeCgpO1xuICAgICAgICB0aGlzLnVDbGFtcEZyYW1lID0gbmV3IEZsb2F0MzJBcnJheSg0KTtcbiAgICAgICAgdGhpcy51Q2xhbXBPZmZzZXQgPSBuZXcgRmxvYXQzMkFycmF5KDIpO1xuICAgICAgICAvKipcbiAgICAgICAgICogVHJhY2tzIFRleHR1cmUgZnJhbWUgY2hhbmdlc1xuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3VwZGF0ZUlEID0gLTE7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDaGFuZ2VzIGZyYW1lIGNsYW1waW5nXG4gICAgICAgICAqIFdvcmtzIHdpdGggVGlsaW5nU3ByaXRlIGFuZCBNZXNoXG4gICAgICAgICAqIENoYW5nZSB0byAxLjUgaWYgeW91IHRleHR1cmUgaGFzIHJlcGVhdGVkIHJpZ2h0IGFuZCBib3R0b20gbGluZXMsIHRoYXQgbGVhZHMgdG8gc21vb3RoZXIgYm9yZGVyc1xuICAgICAgICAgKlxuICAgICAgICAgKiBAZGVmYXVsdCAwXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2xhbXBPZmZzZXQgPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2hhbmdlcyBmcmFtZSBjbGFtcGluZ1xuICAgICAgICAgKiBXb3JrcyB3aXRoIFRpbGluZ1Nwcml0ZSBhbmQgTWVzaFxuICAgICAgICAgKiBDaGFuZ2UgdG8gLTAuNSB0byBhZGQgYSBwaXhlbCB0byB0aGUgZWRnZSwgcmVjb21tZW5kZWQgZm9yIHRyYW5zcGFyZW50IHRyaW1tZWQgdGV4dHVyZXMgaW4gYXRsYXNcbiAgICAgICAgICpcbiAgICAgICAgICogQGRlZmF1bHQgMC41XG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2xhbXBNYXJnaW4gPSAodHlwZW9mIGNsYW1wTWFyZ2luID09PSAndW5kZWZpbmVkJykgPyAwLjUgOiBjbGFtcE1hcmdpbjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHRleHR1cmUgc2l6ZSBpcyB0aGUgc2FtZSBhcyBiYXNlVGV4dHVyZVxuICAgICAgICAgKiBAbWVtYmVyIHtib29sZWFufVxuICAgICAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAgICAgKiBAcmVhZG9ubHlcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaXNTaW1wbGUgPSBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogdGV4dHVyZSBwcm9wZXJ0eVxuICAgICAqIEBtZW1iZXIge1BJWEkuVGV4dHVyZX1cbiAgICAgKi9cbiAgICBnZXQgdGV4dHVyZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RleHR1cmU7XG4gICAgfVxuICAgIDtcbiAgICBzZXQgdGV4dHVyZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLl90ZXh0dXJlID0gdmFsdWU7XG4gICAgICAgIHRoaXMuX3VwZGF0ZUlEID0gLTE7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBNdWx0aXBsaWVzIHV2cyBhcnJheSB0byB0cmFuc2Zvcm1cbiAgICAgKiBAcGFyYW0ge0Zsb2F0MzJBcnJheX0gdXZzIG1lc2ggdXZzXG4gICAgICogQHBhcmFtIHtGbG9hdDMyQXJyYXl9IFtvdXQ9dXZzXSBvdXRwdXRcbiAgICAgKiBAcmV0dXJucyB7RmxvYXQzMkFycmF5fSBvdXRwdXRcbiAgICAgKi9cbiAgICBtdWx0aXBseVV2cyh1dnMsIG91dCkge1xuICAgICAgICBpZiAob3V0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG91dCA9IHV2cztcbiAgICAgICAgfVxuICAgICAgICB2YXIgbWF0ID0gdGhpcy5tYXBDb29yZDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB1dnMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgIHZhciB4ID0gdXZzW2ldO1xuICAgICAgICAgICAgdmFyIHkgPSB1dnNbaSArIDFdO1xuICAgICAgICAgICAgb3V0W2ldID0gKHggKiBtYXQuYSkgKyAoeSAqIG1hdC5jKSArIG1hdC50eDtcbiAgICAgICAgICAgIG91dFtpICsgMV0gPSAoeCAqIG1hdC5iKSArICh5ICogbWF0LmQpICsgbWF0LnR5O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiB1cGRhdGVzIG1hdHJpY2VzIGlmIHRleHR1cmUgd2FzIGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGZvcmNlVXBkYXRlIGlmIHRydWUsIG1hdHJpY2VzIHdpbGwgYmUgdXBkYXRlZCBhbnkgY2FzZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSB3aGV0aGVyIG9yIG5vdCBpdCB3YXMgdXBkYXRlZFxuICAgICAqL1xuICAgIHVwZGF0ZShmb3JjZVVwZGF0ZSkge1xuICAgICAgICB2YXIgdGV4ID0gdGhpcy5fdGV4dHVyZTtcbiAgICAgICAgaWYgKCF0ZXggfHwgIXRleC52YWxpZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZm9yY2VVcGRhdGVcbiAgICAgICAgICAgICYmIHRoaXMuX3VwZGF0ZUlEID09PSB0ZXguX3VwZGF0ZUlEKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdXBkYXRlSUQgPSB0ZXguX3VwZGF0ZUlEO1xuICAgICAgICB2YXIgdXZzID0gdGV4Ll91dnM7XG4gICAgICAgIHRoaXMubWFwQ29vcmQuc2V0KHV2cy54MSAtIHV2cy54MCwgdXZzLnkxIC0gdXZzLnkwLCB1dnMueDMgLSB1dnMueDAsIHV2cy55MyAtIHV2cy55MCwgdXZzLngwLCB1dnMueTApO1xuICAgICAgICB2YXIgb3JpZyA9IHRleC5vcmlnO1xuICAgICAgICB2YXIgdHJpbSA9IHRleC50cmltO1xuICAgICAgICBpZiAodHJpbSkge1xuICAgICAgICAgICAgVGV4dHVyZU1hdHJpeC50ZW1wTWF0LnNldChvcmlnLndpZHRoIC8gdHJpbS53aWR0aCwgMCwgMCwgb3JpZy5oZWlnaHQgLyB0cmltLmhlaWdodCwgLXRyaW0ueCAvIHRyaW0ud2lkdGgsIC10cmltLnkgLyB0cmltLmhlaWdodCk7XG4gICAgICAgICAgICB0aGlzLm1hcENvb3JkLmFwcGVuZChUZXh0dXJlTWF0cml4LnRlbXBNYXQpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0ZXhCYXNlID0gdGV4LmJhc2VUZXh0dXJlO1xuICAgICAgICB2YXIgZnJhbWUgPSB0aGlzLnVDbGFtcEZyYW1lO1xuICAgICAgICB2YXIgbWFyZ2luID0gdGhpcy5jbGFtcE1hcmdpbiAvIHRleEJhc2UucmVzb2x1dGlvbjtcbiAgICAgICAgdmFyIG9mZnNldCA9IHRoaXMuY2xhbXBPZmZzZXQ7XG4gICAgICAgIGZyYW1lWzBdID0gKHRleC5fZnJhbWUueCArIG1hcmdpbiArIG9mZnNldCkgLyB0ZXhCYXNlLndpZHRoO1xuICAgICAgICBmcmFtZVsxXSA9ICh0ZXguX2ZyYW1lLnkgKyBtYXJnaW4gKyBvZmZzZXQpIC8gdGV4QmFzZS5oZWlnaHQ7XG4gICAgICAgIGZyYW1lWzJdID0gKHRleC5fZnJhbWUueCArIHRleC5fZnJhbWUud2lkdGggLSBtYXJnaW4gKyBvZmZzZXQpIC8gdGV4QmFzZS53aWR0aDtcbiAgICAgICAgZnJhbWVbM10gPSAodGV4Ll9mcmFtZS55ICsgdGV4Ll9mcmFtZS5oZWlnaHQgLSBtYXJnaW4gKyBvZmZzZXQpIC8gdGV4QmFzZS5oZWlnaHQ7XG4gICAgICAgIHRoaXMudUNsYW1wT2Zmc2V0WzBdID0gb2Zmc2V0IC8gdGV4QmFzZS5yZWFsV2lkdGg7XG4gICAgICAgIHRoaXMudUNsYW1wT2Zmc2V0WzFdID0gb2Zmc2V0IC8gdGV4QmFzZS5yZWFsSGVpZ2h0O1xuICAgICAgICB0aGlzLmlzU2ltcGxlID0gdGV4Ll9mcmFtZS53aWR0aCA9PT0gdGV4QmFzZS53aWR0aFxuICAgICAgICAgICAgJiYgdGV4Ll9mcmFtZS5oZWlnaHQgPT09IHRleEJhc2UuaGVpZ2h0XG4gICAgICAgICAgICAmJiB0ZXgucm90YXRlID09PSAwO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgO1xufVxuVGV4dHVyZU1hdHJpeC50ZW1wTWF0ID0gbmV3IE1hdHJpeF8xLk1hdHJpeCgpO1xuZXhwb3J0cy5UZXh0dXJlTWF0cml4ID0gVGV4dHVyZU1hdHJpeDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgU3lzdGVtXzEgPSByZXF1aXJlKFwiLi9TeXN0ZW1cIik7XG5jb25zdCBCYXNlVGV4dHVyZV8xID0gcmVxdWlyZShcIi4vQmFzZVRleHR1cmVcIik7XG5jb25zdCBHTFRleHR1cmVfMSA9IHJlcXVpcmUoXCIuL0dMVGV4dHVyZVwiKTtcbmNvbnN0IFV0aWxzU2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL1V0aWxzU2V0dGluZ3NcIik7XG5jb25zdCBXZWJHTFNldHRpbmdzXzEgPSByZXF1aXJlKFwiLi9XZWJHTFNldHRpbmdzXCIpO1xuY2xhc3MgVGV4dHVyZVN5c3RlbSBleHRlbmRzIFN5c3RlbV8xLlN5c3RlbSB7XG4gICAgY29uc3RydWN0b3IocmVuZGVyZXIpIHtcbiAgICAgICAgc3VwZXIocmVuZGVyZXIpO1xuICAgICAgICAvLyBUT0RPIHNldCB0byBtYXggdGV4dHVyZXMuLi5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJvdW5kIHRleHR1cmVzXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuQmFzZVRleHR1cmVbXX1cbiAgICAgICAgICogQHJlYWRvbmx5XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmJvdW5kVGV4dHVyZXMgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEN1cnJlbnQgbG9jYXRpb25cbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKiBAcmVhZG9ubHlcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY3VycmVudExvY2F0aW9uID0gLTE7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMaXN0IG9mIG1hbmFnZWQgdGV4dHVyZXNcbiAgICAgICAgICogQG1lbWJlciB7UElYSS5CYXNlVGV4dHVyZVtdfVxuICAgICAgICAgKiBAcmVhZG9ubHlcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubWFuYWdlZFRleHR1cmVzID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEaWQgc29tZW9uZSB0ZW1wZXIgd2l0aCB0ZXh0dXJlcyBzdGF0ZT8gV2UnbGwgb3ZlcndyaXRlIHRoZW0gd2hlbiB3ZSBuZWVkIHRvIHVuYmluZCBzb21ldGhpbmcuXG4gICAgICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl91bmtub3duQm91bmRUZXh0dXJlcyA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogQmFzZVRleHR1cmUgdmFsdWUgdGhhdCBzaG93cyB0aGF0IHdlIGRvbid0IGtub3cgd2hhdCBpcyBib3VuZFxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLkJhc2VUZXh0dXJlfVxuICAgICAgICAgKiBAcmVhZG9ubHlcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudW5rbm93blRleHR1cmUgPSBuZXcgQmFzZVRleHR1cmVfMS5CYXNlVGV4dHVyZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHVwIHRoZSByZW5kZXJlciBjb250ZXh0IGFuZCBuZWNlc3NhcnkgYnVmZmVycy5cbiAgICAgKi9cbiAgICBjb250ZXh0Q2hhbmdlKCkge1xuICAgICAgICB2YXIgZ2wgPSB0aGlzLmdsID0gdGhpcy5yZW5kZXJlci5nbDtcbiAgICAgICAgdGhpcy5DT05URVhUX1VJRCA9IHRoaXMucmVuZGVyZXIuQ09OVEVYVF9VSUQ7XG4gICAgICAgIHRoaXMud2ViR0xWZXJzaW9uID0gdGhpcy5yZW5kZXJlci5jb250ZXh0LndlYkdMVmVyc2lvbjtcbiAgICAgICAgdmFyIG1heFRleHR1cmVzID0gZ2wuZ2V0UGFyYW1ldGVyKGdsLk1BWF9URVhUVVJFX0lNQUdFX1VOSVRTKTtcbiAgICAgICAgdGhpcy5ib3VuZFRleHR1cmVzLmxlbmd0aCA9IG1heFRleHR1cmVzO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1heFRleHR1cmVzOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuYm91bmRUZXh0dXJlc1tpXSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVE9ETyBtb3ZlIHRoaXMuLiB0byBhIG5pY2UgbWFrZSBlbXB0eSB0ZXh0dXJlcyBjbGFzcy4uXG4gICAgICAgIHRoaXMuZW1wdHlUZXh0dXJlcyA9IHt9O1xuICAgICAgICB2YXIgZW1wdHlUZXh0dXJlMkQgPSBuZXcgR0xUZXh0dXJlXzEuR0xUZXh0dXJlKGdsLmNyZWF0ZVRleHR1cmUoKSk7XG4gICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIGVtcHR5VGV4dHVyZTJELnRleHR1cmUpO1xuICAgICAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIDEsIDEsIDAsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIG5ldyBVaW50OEFycmF5KDQpKTtcbiAgICAgICAgdGhpcy5lbXB0eVRleHR1cmVzW2dsLlRFWFRVUkVfMkRdID0gZW1wdHlUZXh0dXJlMkQ7XG4gICAgICAgIHRoaXMuZW1wdHlUZXh0dXJlc1tnbC5URVhUVVJFX0NVQkVfTUFQXSA9IG5ldyBHTFRleHR1cmVfMS5HTFRleHR1cmUoZ2wuY3JlYXRlVGV4dHVyZSgpKTtcbiAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV9DVUJFX01BUCwgdGhpcy5lbXB0eVRleHR1cmVzW2dsLlRFWFRVUkVfQ1VCRV9NQVBdLnRleHR1cmUpO1xuICAgICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCA2OyBpJDErKykge1xuICAgICAgICAgICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1ggKyBpJDEsIDAsIGdsLlJHQkEsIDEsIDEsIDAsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV9DVUJFX01BUCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5MSU5FQVIpO1xuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfQ1VCRV9NQVAsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2wuTElORUFSKTtcbiAgICAgICAgZm9yICh2YXIgaSQyID0gMDsgaSQyIDwgdGhpcy5ib3VuZFRleHR1cmVzLmxlbmd0aDsgaSQyKyspIHtcbiAgICAgICAgICAgIHRoaXMuYmluZChudWxsLCBpJDIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBCaW5kIGEgdGV4dHVyZSB0byBhIHNwZWNpZmljIGxvY2F0aW9uXG4gICAgICpcbiAgICAgKiBJZiB5b3Ugd2FudCB0byB1bmJpbmQgc29tZXRoaW5nLCBwbGVhc2UgdXNlIGB1bmJpbmQodGV4dHVyZSlgIGluc3RlYWQgb2YgYGJpbmQobnVsbCwgdGV4dHVyZUxvY2F0aW9uKWBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UElYSS5UZXh0dXJlfFBJWEkuQmFzZVRleHR1cmV9IHRleHR1cmUgLSBUZXh0dXJlIHRvIGJpbmRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xvY2F0aW9uPTBdIC0gTG9jYXRpb24gdG8gYmluZCBhdFxuICAgICAqL1xuICAgIGJpbmQodGV4dHVyZSwgbG9jYXRpb24gPSAwKSB7XG4gICAgICAgIHZhciByZWYgPSB0aGlzO1xuICAgICAgICB2YXIgZ2wgPSByZWYuZ2w7XG4gICAgICAgIGlmICh0ZXh0dXJlKSB7XG4gICAgICAgICAgICB0ZXh0dXJlID0gdGV4dHVyZS5iYXNlVGV4dHVyZSB8fCB0ZXh0dXJlO1xuICAgICAgICAgICAgaWYgKHRleHR1cmUudmFsaWQpIHtcbiAgICAgICAgICAgICAgICB0ZXh0dXJlLnRvdWNoZWQgPSB0aGlzLnJlbmRlcmVyLnRleHR1cmVHQy5jb3VudDtcbiAgICAgICAgICAgICAgICB2YXIgZ2xUZXh0dXJlID0gdGV4dHVyZS5fZ2xUZXh0dXJlc1t0aGlzLkNPTlRFWFRfVUlEXSB8fCB0aGlzLmluaXRUZXh0dXJlKHRleHR1cmUpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRMb2NhdGlvbiAhPT0gbG9jYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50TG9jYXRpb24gPSBsb2NhdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCArIGxvY2F0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYm91bmRUZXh0dXJlc1tsb2NhdGlvbl0gIT09IHRleHR1cmUpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2wuYmluZFRleHR1cmUodGV4dHVyZS50YXJnZXQsIGdsVGV4dHVyZS50ZXh0dXJlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGdsVGV4dHVyZS5kaXJ0eUlkICE9PSB0ZXh0dXJlLmRpcnR5SWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVUZXh0dXJlKHRleHR1cmUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmJvdW5kVGV4dHVyZXNbbG9jYXRpb25dID0gdGV4dHVyZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRMb2NhdGlvbiAhPT0gbG9jYXRpb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRMb2NhdGlvbiA9IGxvY2F0aW9uO1xuICAgICAgICAgICAgICAgIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTAgKyBsb2NhdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0aGlzLmVtcHR5VGV4dHVyZXNbZ2wuVEVYVFVSRV8yRF0udGV4dHVyZSk7XG4gICAgICAgICAgICB0aGlzLmJvdW5kVGV4dHVyZXNbbG9jYXRpb25dID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogUmVzZXRzIHRleHR1cmUgbG9jYXRpb24gYW5kIGJvdW5kIHRleHR1cmVzXG4gICAgICpcbiAgICAgKiBBY3R1YWwgYGJpbmQobnVsbCwgaSlgIGNhbGxzIHdpbGwgYmUgcGVyZm9ybWVkIGF0IG5leHQgYHVuYmluZCgpYCBjYWxsXG4gICAgICovXG4gICAgcmVzZXQoKSB7XG4gICAgICAgIHRoaXMuX3Vua25vd25Cb3VuZFRleHR1cmVzID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5jdXJyZW50TG9jYXRpb24gPSAtMTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmJvdW5kVGV4dHVyZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuYm91bmRUZXh0dXJlc1tpXSA9IHRoaXMudW5rbm93blRleHR1cmU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFVuYmluZCBhIHRleHR1cmVcbiAgICAgKiBAcGFyYW0ge1BJWEkuVGV4dHVyZXxQSVhJLkJhc2VUZXh0dXJlfSB0ZXh0dXJlIC0gVGV4dHVyZSB0byBiaW5kXG4gICAgICovXG4gICAgdW5iaW5kKHRleHR1cmUpIHtcbiAgICAgICAgdmFyIHJlZiA9IHRoaXM7XG4gICAgICAgIHZhciBnbCA9IHJlZi5nbDtcbiAgICAgICAgdmFyIGJvdW5kVGV4dHVyZXMgPSByZWYuYm91bmRUZXh0dXJlcztcbiAgICAgICAgaWYgKHRoaXMuX3Vua25vd25Cb3VuZFRleHR1cmVzKSB7XG4gICAgICAgICAgICB0aGlzLl91bmtub3duQm91bmRUZXh0dXJlcyA9IGZhbHNlO1xuICAgICAgICAgICAgLy8gc29tZW9uZSBjaGFuZ2VkIHdlYkdMIHN0YXRlLFxuICAgICAgICAgICAgLy8gd2UgaGF2ZSB0byBiZSBzdXJlIHRoYXQgb3VyIHRleHR1cmUgZG9lcyBub3QgYXBwZWFyIGluIG11bHRpLXRleHR1cmUgcmVuZGVyZXIgc2FtcGxlcnNcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYm91bmRUZXh0dXJlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChib3VuZFRleHR1cmVzW2ldID09PSB0aGlzLnVua25vd25UZXh0dXJlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYmluZChudWxsLCBpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgYm91bmRUZXh0dXJlcy5sZW5ndGg7IGkkMSsrKSB7XG4gICAgICAgICAgICBpZiAoYm91bmRUZXh0dXJlc1tpJDFdID09PSB0ZXh0dXJlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudExvY2F0aW9uICE9PSBpJDEpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCArIGkkMSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudExvY2F0aW9uID0gaSQxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0aGlzLmVtcHR5VGV4dHVyZXNbdGV4dHVyZS50YXJnZXRdLnRleHR1cmUpO1xuICAgICAgICAgICAgICAgIGJvdW5kVGV4dHVyZXNbaSQxXSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemUgYSB0ZXh0dXJlXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7UElYSS5CYXNlVGV4dHVyZX0gdGV4dHVyZSAtIFRleHR1cmUgdG8gaW5pdGlhbGl6ZVxuICAgICAqL1xuICAgIGluaXRUZXh0dXJlKHRleHR1cmUpIHtcbiAgICAgICAgdmFyIGdsVGV4dHVyZSA9IG5ldyBHTFRleHR1cmVfMS5HTFRleHR1cmUodGhpcy5nbC5jcmVhdGVUZXh0dXJlKCkpO1xuICAgICAgICAvLyBndWFyYW50ZWUgYW4gdXBkYXRlLi5cbiAgICAgICAgZ2xUZXh0dXJlLmRpcnR5SWQgPSAtMTtcbiAgICAgICAgdGV4dHVyZS5fZ2xUZXh0dXJlc1t0aGlzLkNPTlRFWFRfVUlEXSA9IGdsVGV4dHVyZTtcbiAgICAgICAgdGhpcy5tYW5hZ2VkVGV4dHVyZXMucHVzaCh0ZXh0dXJlKTtcbiAgICAgICAgLy8gdGV4dHVyZS5vbignZGlzcG9zZScsIHRoaXMuZGVzdHJveVRleHR1cmUsIHRoaXMpO1xuICAgICAgICByZXR1cm4gZ2xUZXh0dXJlO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogVXBkYXRlIGEgdGV4dHVyZVxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1BJWEkuQmFzZVRleHR1cmV9IHRleHR1cmUgLSBUZXh0dXJlIHRvIGluaXRpYWxpemVcbiAgICAgKi9cbiAgICB1cGRhdGVUZXh0dXJlKHRleHR1cmUpIHtcbiAgICAgICAgdmFyIGdsVGV4dHVyZSA9IHRleHR1cmUuX2dsVGV4dHVyZXNbdGhpcy5DT05URVhUX1VJRF07XG4gICAgICAgIHZhciByZW5kZXJlciA9IHRoaXMucmVuZGVyZXI7XG4gICAgICAgIGlmICh0ZXh0dXJlLnJlc291cmNlICYmIHRleHR1cmUucmVzb3VyY2UuY2FuVXBsb2FkKSB7XG4gICAgICAgICAgICB0ZXh0dXJlLnJlc291cmNlLnVwbG9hZChyZW5kZXJlciwgdGV4dHVyZSwgZ2xUZXh0dXJlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiAodGV4dHVyZS5yZXNvdXJjZSAmJiB0ZXh0dXJlLnJlc291cmNlLnVwbG9hZChyZW5kZXJlciwgdGV4dHVyZSwgZ2xUZXh0dXJlKSlcbiAgICAgICAgZWxzZSBpZiAodGV4dHVyZS5yZXNvdXJjZSAmJiB0aGlzLnVwbG9hZFRleHR1cmUocmVuZGVyZXIsIHRleHR1cmUsIGdsVGV4dHVyZSwgdGV4dHVyZS5yZXNvdXJjZSkpIHtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGRlZmF1bHQsIHJlbmRlclRleHR1cmUtbGlrZSBsb2dpY1xuICAgICAgICAgICAgdmFyIHdpZHRoID0gdGV4dHVyZS5yZWFsV2lkdGg7XG4gICAgICAgICAgICB2YXIgaGVpZ2h0ID0gdGV4dHVyZS5yZWFsSGVpZ2h0O1xuICAgICAgICAgICAgdmFyIGdsID0gcmVuZGVyZXIuZ2w7XG4gICAgICAgICAgICBpZiAoZ2xUZXh0dXJlLndpZHRoICE9PSB3aWR0aFxuICAgICAgICAgICAgICAgIHx8IGdsVGV4dHVyZS5oZWlnaHQgIT09IGhlaWdodFxuICAgICAgICAgICAgICAgIHx8IGdsVGV4dHVyZS5kaXJ0eUlkIDwgMCkge1xuICAgICAgICAgICAgICAgIGdsVGV4dHVyZS53aWR0aCA9IHdpZHRoO1xuICAgICAgICAgICAgICAgIGdsVGV4dHVyZS5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgICAgICAgICAgZ2wudGV4SW1hZ2UyRCh0ZXh0dXJlLnRhcmdldCwgMCwgdGV4dHVyZS5mb3JtYXQsIHdpZHRoLCBoZWlnaHQsIDAsIHRleHR1cmUuZm9ybWF0LCB0ZXh0dXJlLnR5cGUsIG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGxldHMgb25seSB1cGRhdGUgd2hhdCBjaGFuZ2VzLi5cbiAgICAgICAgaWYgKHRleHR1cmUuZGlydHlTdHlsZUlkICE9PSBnbFRleHR1cmUuZGlydHlTdHlsZUlkKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVRleHR1cmVTdHlsZSh0ZXh0dXJlKTtcbiAgICAgICAgfVxuICAgICAgICBnbFRleHR1cmUuZGlydHlJZCA9IHRleHR1cmUuZGlydHlJZDtcbiAgICB9XG4gICAgO1xuICAgIHVwbG9hZFRleHR1cmUocmVuZGVyZXIsIGJhc2VUZXh0dXJlLCBnbFRleHR1cmUsIHNvdXJjZSkge1xuICAgICAgICB2YXIgZ2wgPSByZW5kZXJlci5nbDtcbiAgICAgICAgdmFyIHdpZHRoID0gYmFzZVRleHR1cmUucmVhbFdpZHRoO1xuICAgICAgICB2YXIgaGVpZ2h0ID0gYmFzZVRleHR1cmUucmVhbEhlaWdodDtcbiAgICAgICAgLy8gc291cmNlID0gc291cmNlIHx8IHRoaXMuc291cmNlO1xuICAgICAgICBpZiAoc291cmNlLmNvbnN0cnVjdG9yWyduYW1lJ10gPT0gXCJDYW52YXNSZXNvdXJjZVwiKSB7XG4gICAgICAgICAgICBzb3VyY2UgPSBzb3VyY2Uuc291cmNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNvdXJjZS5jb25zdHJ1Y3RvclsnbmFtZSddID09IFwiSW1hZ2VSZXNvdXJjZVwiKSB7XG4gICAgICAgICAgICBzb3VyY2UgPSBzb3VyY2Uuc291cmNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNvdXJjZS5jb25zdHJ1Y3RvclsnbmFtZSddID09IFwiVmlkZW9SZXNvdXJjZVwiKSB7XG4gICAgICAgICAgICBzb3VyY2UgPSBzb3VyY2Uuc291cmNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGVsc2UgaWYoc291cmNlLmNvbnN0cnVjdG9yWyduYW1lJ10gPT0gXCJHcmFkaWVudFJlc291cmNlXCIpXG4gICAgICAgIC8vIHtcbiAgICAgICAgLy8gICAgIGlmKCFzb3VyY2Uuc291cmNlKVxuICAgICAgICAvLyAgICAge1xuICAgICAgICAvLyAgICAgICAgIHJldHVyblxuICAgICAgICAvLyAgICAgfVxuICAgICAgICAvLyAgICAgc291cmNlID0gc291cmNlLnNvdXJjZVxuICAgICAgICAvLyB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICB9XG4gICAgICAgIGdsLnBpeGVsU3RvcmVpKGdsLlVOUEFDS19QUkVNVUxUSVBMWV9BTFBIQV9XRUJHTCwgYmFzZVRleHR1cmUucHJlbXVsdGlwbHlBbHBoYSk7XG4gICAgICAgIGlmIChiYXNlVGV4dHVyZS50YXJnZXQgPT09IGdsLlRFWFRVUkVfMkQgJiYgZ2xUZXh0dXJlLndpZHRoID09PSB3aWR0aCAmJiBnbFRleHR1cmUuaGVpZ2h0ID09PSBoZWlnaHQpIHtcbiAgICAgICAgICAgIGdsLnRleFN1YkltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgMCwgMCwgYmFzZVRleHR1cmUuZm9ybWF0LCBiYXNlVGV4dHVyZS50eXBlLCBzb3VyY2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZ2xUZXh0dXJlLndpZHRoID0gd2lkdGg7XG4gICAgICAgICAgICBnbFRleHR1cmUuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICAgICAgZ2wudGV4SW1hZ2UyRChiYXNlVGV4dHVyZS50YXJnZXQsIDAsIGJhc2VUZXh0dXJlLmZvcm1hdCwgYmFzZVRleHR1cmUuZm9ybWF0LCBiYXNlVGV4dHVyZS50eXBlLCBzb3VyY2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogRGVsZXRlcyB0aGUgdGV4dHVyZSBmcm9tIFdlYkdMXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7UElYSS5CYXNlVGV4dHVyZXxQSVhJLlRleHR1cmV9IHRleHR1cmUgLSB0aGUgdGV4dHVyZSB0byBkZXN0cm95XG4gICAgICogQHBhcmFtIHtib29sZWFufSBbc2tpcFJlbW92ZT1mYWxzZV0gLSBXaGV0aGVyIHRvIHNraXAgcmVtb3ZpbmcgdGhlIHRleHR1cmUgZnJvbSB0aGUgVGV4dHVyZU1hbmFnZXIuXG4gICAgICovXG4gICAgZGVzdHJveVRleHR1cmUodGV4dHVyZSwgc2tpcFJlbW92ZSA9IGZhbHNlKSB7XG4gICAgICAgIHZhciByZWYgPSB0aGlzO1xuICAgICAgICB2YXIgZ2wgPSByZWYuZ2w7XG4gICAgICAgIHRleHR1cmUgPSB0ZXh0dXJlLmJhc2VUZXh0dXJlIHx8IHRleHR1cmU7XG4gICAgICAgIGlmICh0ZXh0dXJlLl9nbFRleHR1cmVzW3RoaXMucmVuZGVyZXIuQ09OVEVYVF9VSURdKSB7XG4gICAgICAgICAgICB0aGlzLnVuYmluZCh0ZXh0dXJlKTtcbiAgICAgICAgICAgIGdsLmRlbGV0ZVRleHR1cmUodGV4dHVyZS5fZ2xUZXh0dXJlc1t0aGlzLnJlbmRlcmVyLkNPTlRFWFRfVUlEXS50ZXh0dXJlKTtcbiAgICAgICAgICAgIC8vIHRleHR1cmUub2ZmKCdkaXNwb3NlJywgdGhpcy5kZXN0cm95VGV4dHVyZSwgdGhpcyk7XG4gICAgICAgICAgICBkZWxldGUgdGV4dHVyZS5fZ2xUZXh0dXJlc1t0aGlzLnJlbmRlcmVyLkNPTlRFWFRfVUlEXTtcbiAgICAgICAgICAgIGlmICghc2tpcFJlbW92ZSkge1xuICAgICAgICAgICAgICAgIHZhciBpID0gdGhpcy5tYW5hZ2VkVGV4dHVyZXMuaW5kZXhPZih0ZXh0dXJlKTtcbiAgICAgICAgICAgICAgICBpZiAoaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgVXRpbHNTZXR0aW5nc18xLlV0aWxzU2V0dGluZ3MucmVtb3ZlSXRlbXModGhpcy5tYW5hZ2VkVGV4dHVyZXMsIGksIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogVXBkYXRlIHRleHR1cmUgc3R5bGUgc3VjaCBhcyBtaXBtYXAgZmxhZ1xuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1BJWEkuQmFzZVRleHR1cmV9IHRleHR1cmUgLSBUZXh0dXJlIHRvIHVwZGF0ZVxuICAgICAqL1xuICAgIHVwZGF0ZVRleHR1cmVTdHlsZSh0ZXh0dXJlKSB7XG4gICAgICAgIHZhciBnbFRleHR1cmUgPSB0ZXh0dXJlLl9nbFRleHR1cmVzW3RoaXMuQ09OVEVYVF9VSURdO1xuICAgICAgICBpZiAoIWdsVGV4dHVyZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICgodGV4dHVyZS5taXBtYXAgPT09IFdlYkdMU2V0dGluZ3NfMS5XZWJHTFNldHRpbmdzLk1JUE1BUF9NT0RFUy5QT1cyIHx8IHRoaXMud2ViR0xWZXJzaW9uICE9PSAyKSAmJiAhdGV4dHVyZS5pc1Bvd2VyT2ZUd28pIHtcbiAgICAgICAgICAgIGdsVGV4dHVyZS5taXBtYXAgPSAwO1xuICAgICAgICAgICAgZ2xUZXh0dXJlLndyYXBNb2RlID0gV2ViR0xTZXR0aW5nc18xLldlYkdMU2V0dGluZ3MuV1JBUF9NT0RFUy5DTEFNUDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGdsVGV4dHVyZS5taXBtYXAgPSB0ZXh0dXJlLm1pcG1hcCA+PSAxO1xuICAgICAgICAgICAgZ2xUZXh0dXJlLndyYXBNb2RlID0gdGV4dHVyZS53cmFwTW9kZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiAodGV4dHVyZS5yZXNvdXJjZSAmJiB0ZXh0dXJlLnJlc291cmNlLnN0eWxlKHRoaXMucmVuZGVyZXIsIHRleHR1cmUsIGdsVGV4dHVyZSkpXG4gICAgICAgIC8vIHsgOyB9XG4gICAgICAgIC8vIGVsc2VcbiAgICAgICAgLy8ge1xuICAgICAgICB0aGlzLnNldFN0eWxlKHRleHR1cmUsIGdsVGV4dHVyZSk7XG4gICAgICAgIC8vIH1cbiAgICAgICAgZ2xUZXh0dXJlLmRpcnR5U3R5bGVJZCA9IHRleHR1cmUuZGlydHlTdHlsZUlkO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogU2V0IHN0eWxlIGZvciB0ZXh0dXJlXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7UElYSS5CYXNlVGV4dHVyZX0gdGV4dHVyZSAtIFRleHR1cmUgdG8gdXBkYXRlXG4gICAgICogQHBhcmFtIHtnbFRleHR1cmV9IGdsVGV4dHVyZVxuICAgICAqL1xuICAgIHNldFN0eWxlKHRleHR1cmUsIGdsVGV4dHVyZSkge1xuICAgICAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuICAgICAgICBpZiAoZ2xUZXh0dXJlLm1pcG1hcCkge1xuICAgICAgICAgICAgZ2wuZ2VuZXJhdGVNaXBtYXAodGV4dHVyZS50YXJnZXQpO1xuICAgICAgICB9XG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkodGV4dHVyZS50YXJnZXQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbFRleHR1cmUud3JhcE1vZGUpO1xuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKHRleHR1cmUudGFyZ2V0LCBnbC5URVhUVVJFX1dSQVBfVCwgZ2xUZXh0dXJlLndyYXBNb2RlKTtcbiAgICAgICAgaWYgKGdsVGV4dHVyZS5taXBtYXApIHtcbiAgICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4gKi9cbiAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkodGV4dHVyZS50YXJnZXQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgdGV4dHVyZS5zY2FsZU1vZGUgPyBnbC5MSU5FQVJfTUlQTUFQX0xJTkVBUiA6IGdsLk5FQVJFU1RfTUlQTUFQX05FQVJFU1QpO1xuICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZ2wudGV4UGFyYW1ldGVyaSh0ZXh0dXJlLnRhcmdldCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCB0ZXh0dXJlLnNjYWxlTW9kZSA/IGdsLkxJTkVBUiA6IGdsLk5FQVJFU1QpO1xuICAgICAgICB9XG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkodGV4dHVyZS50YXJnZXQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgdGV4dHVyZS5zY2FsZU1vZGUgPyBnbC5MSU5FQVIgOiBnbC5ORUFSRVNUKTtcbiAgICB9XG4gICAgO1xufVxuZXhwb3J0cy5UZXh0dXJlU3lzdGVtID0gVGV4dHVyZVN5c3RlbTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgR3JvdXBEOF8xID0gcmVxdWlyZShcIi4vR3JvdXBEOFwiKTtcbmNsYXNzIFRleHR1cmVVdnMge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLngwID0gMDtcbiAgICAgICAgdGhpcy55MCA9IDA7XG4gICAgICAgIHRoaXMueDEgPSAxO1xuICAgICAgICB0aGlzLnkxID0gMDtcbiAgICAgICAgdGhpcy54MiA9IDE7XG4gICAgICAgIHRoaXMueTIgPSAxO1xuICAgICAgICB0aGlzLngzID0gMDtcbiAgICAgICAgdGhpcy55MyA9IDE7XG4gICAgICAgIHRoaXMudXZzRmxvYXQzMiA9IG5ldyBGbG9hdDMyQXJyYXkoOCk7XG4gICAgfVxuICAgIC8qKlxuICogU2V0cyB0aGUgdGV4dHVyZSBVdnMgYmFzZWQgb24gdGhlIGdpdmVuIGZyYW1lIGluZm9ybWF0aW9uLlxuICpcbiAqIEBwcm90ZWN0ZWRcbiAqIEBwYXJhbSB7UElYSS5SZWN0YW5nbGV9IGZyYW1lIC0gVGhlIGZyYW1lIG9mIHRoZSB0ZXh0dXJlXG4gKiBAcGFyYW0ge1BJWEkuUmVjdGFuZ2xlfSBiYXNlRnJhbWUgLSBUaGUgYmFzZSBmcmFtZSBvZiB0aGUgdGV4dHVyZVxuICogQHBhcmFtIHtudW1iZXJ9IHJvdGF0ZSAtIFJvdGF0aW9uIG9mIGZyYW1lLCBzZWUge0BsaW5rIFBJWEkuR3JvdXBEOH1cbiAqL1xuICAgIHNldChmcmFtZSwgYmFzZUZyYW1lLCByb3RhdGUpIHtcbiAgICAgICAgdmFyIHR3ID0gYmFzZUZyYW1lLndpZHRoO1xuICAgICAgICB2YXIgdGggPSBiYXNlRnJhbWUuaGVpZ2h0O1xuICAgICAgICBpZiAocm90YXRlKSB7XG4gICAgICAgICAgICAvLyB3aWR0aCBhbmQgaGVpZ2h0IGRpdiAyIGRpdiBiYXNlRnJhbWUgc2l6ZVxuICAgICAgICAgICAgdmFyIHcyID0gZnJhbWUud2lkdGggLyAyIC8gdHc7XG4gICAgICAgICAgICB2YXIgaDIgPSBmcmFtZS5oZWlnaHQgLyAyIC8gdGg7XG4gICAgICAgICAgICAvLyBjb29yZGluYXRlcyBvZiBjZW50ZXJcbiAgICAgICAgICAgIHZhciBjWCA9IChmcmFtZS54IC8gdHcpICsgdzI7XG4gICAgICAgICAgICB2YXIgY1kgPSAoZnJhbWUueSAvIHRoKSArIGgyO1xuICAgICAgICAgICAgcm90YXRlID0gR3JvdXBEOF8xLkdyb3VwRDguYWRkKHJvdGF0ZSwgR3JvdXBEOF8xLkdyb3VwRDguTlcpOyAvLyBOVyBpcyB0b3AtbGVmdCBjb3JuZXJcbiAgICAgICAgICAgIHRoaXMueDAgPSBjWCArICh3MiAqIEdyb3VwRDhfMS5Hcm91cEQ4LnVYKHJvdGF0ZSkpO1xuICAgICAgICAgICAgdGhpcy55MCA9IGNZICsgKGgyICogR3JvdXBEOF8xLkdyb3VwRDgudVkocm90YXRlKSk7XG4gICAgICAgICAgICByb3RhdGUgPSBHcm91cEQ4XzEuR3JvdXBEOC5hZGQocm90YXRlLCAyKTsgLy8gcm90YXRlIDkwIGRlZ3JlZXMgY2xvY2t3aXNlXG4gICAgICAgICAgICB0aGlzLngxID0gY1ggKyAodzIgKiBHcm91cEQ4XzEuR3JvdXBEOC51WChyb3RhdGUpKTtcbiAgICAgICAgICAgIHRoaXMueTEgPSBjWSArIChoMiAqIEdyb3VwRDhfMS5Hcm91cEQ4LnVZKHJvdGF0ZSkpO1xuICAgICAgICAgICAgcm90YXRlID0gR3JvdXBEOF8xLkdyb3VwRDguYWRkKHJvdGF0ZSwgMik7XG4gICAgICAgICAgICB0aGlzLngyID0gY1ggKyAodzIgKiBHcm91cEQ4XzEuR3JvdXBEOC51WChyb3RhdGUpKTtcbiAgICAgICAgICAgIHRoaXMueTIgPSBjWSArIChoMiAqIEdyb3VwRDhfMS5Hcm91cEQ4LnVZKHJvdGF0ZSkpO1xuICAgICAgICAgICAgcm90YXRlID0gR3JvdXBEOF8xLkdyb3VwRDguYWRkKHJvdGF0ZSwgMik7XG4gICAgICAgICAgICB0aGlzLngzID0gY1ggKyAodzIgKiBHcm91cEQ4XzEuR3JvdXBEOC51WChyb3RhdGUpKTtcbiAgICAgICAgICAgIHRoaXMueTMgPSBjWSArIChoMiAqIEdyb3VwRDhfMS5Hcm91cEQ4LnVZKHJvdGF0ZSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy54MCA9IGZyYW1lLnggLyB0dztcbiAgICAgICAgICAgIHRoaXMueTAgPSBmcmFtZS55IC8gdGg7XG4gICAgICAgICAgICB0aGlzLngxID0gKGZyYW1lLnggKyBmcmFtZS53aWR0aCkgLyB0dztcbiAgICAgICAgICAgIHRoaXMueTEgPSBmcmFtZS55IC8gdGg7XG4gICAgICAgICAgICB0aGlzLngyID0gKGZyYW1lLnggKyBmcmFtZS53aWR0aCkgLyB0dztcbiAgICAgICAgICAgIHRoaXMueTIgPSAoZnJhbWUueSArIGZyYW1lLmhlaWdodCkgLyB0aDtcbiAgICAgICAgICAgIHRoaXMueDMgPSBmcmFtZS54IC8gdHc7XG4gICAgICAgICAgICB0aGlzLnkzID0gKGZyYW1lLnkgKyBmcmFtZS5oZWlnaHQpIC8gdGg7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51dnNGbG9hdDMyWzBdID0gdGhpcy54MDtcbiAgICAgICAgdGhpcy51dnNGbG9hdDMyWzFdID0gdGhpcy55MDtcbiAgICAgICAgdGhpcy51dnNGbG9hdDMyWzJdID0gdGhpcy54MTtcbiAgICAgICAgdGhpcy51dnNGbG9hdDMyWzNdID0gdGhpcy55MTtcbiAgICAgICAgdGhpcy51dnNGbG9hdDMyWzRdID0gdGhpcy54MjtcbiAgICAgICAgdGhpcy51dnNGbG9hdDMyWzVdID0gdGhpcy55MjtcbiAgICAgICAgdGhpcy51dnNGbG9hdDMyWzZdID0gdGhpcy54MztcbiAgICAgICAgdGhpcy51dnNGbG9hdDMyWzddID0gdGhpcy55MztcbiAgICB9XG4gICAgO1xufVxuZXhwb3J0cy5UZXh0dXJlVXZzID0gVGV4dHVyZVV2cztcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgRXZlbnREaXNwYXRjaGVyXzEgPSByZXF1aXJlKFwiLi9FdmVudERpc3BhdGNoZXJcIik7XG5jb25zdCBUaWNrZXJMaXN0ZW5lcl8xID0gcmVxdWlyZShcIi4vVGlja2VyTGlzdGVuZXJcIik7XG5jb25zdCBzZXR0aW5nc18xID0gcmVxdWlyZShcIi4vc2V0dGluZ3NcIik7XG5jbGFzcyBUaWNrZXIgZXh0ZW5kcyBFdmVudERpc3BhdGNoZXJfMS5FdmVudERpc3BhdGNoZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB2YXIgdGhpcyQxID0gdGhpcztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBmaXJzdCBsaXN0ZW5lci4gQWxsIG5ldyBsaXN0ZW5lcnMgYWRkZWQgYXJlIGNoYWluZWQgb24gdGhpcy5cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHR5cGUge1RpY2tlckxpc3RlbmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5faGVhZCA9IG5ldyBUaWNrZXJMaXN0ZW5lcl8xLlRpY2tlckxpc3RlbmVyKG51bGwsIG51bGwsIEluZmluaXR5KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEludGVybmFsIGN1cnJlbnQgZnJhbWUgcmVxdWVzdCBJRFxuICAgICAgICAgKiBAdHlwZSB7P251bWJlcn1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3JlcXVlc3RJZCA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbnRlcm5hbCB2YWx1ZSBtYW5hZ2VkIGJ5IG1pbkZQUyBwcm9wZXJ0eSBzZXR0ZXIgYW5kIGdldHRlci5cbiAgICAgICAgICogVGhpcyBpcyB0aGUgbWF4aW11bSBhbGxvd2VkIG1pbGxpc2Vjb25kcyBiZXR3ZWVuIHVwZGF0ZXMuXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9tYXhFbGFwc2VkTVMgPSAxMDA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbnRlcm5hbCB2YWx1ZSBtYW5hZ2VkIGJ5IG1heEZQUyBwcm9wZXJ0eSBzZXR0ZXIgYW5kIGdldHRlci5cbiAgICAgICAgICogVGhpcyBpcyB0aGUgbWluaW11bSBhbGxvd2VkIG1pbGxpc2Vjb25kcyBiZXR3ZWVuIHVwZGF0ZXMuXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9taW5FbGFwc2VkTVMgPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciBvciBub3QgdGhpcyB0aWNrZXIgc2hvdWxkIGludm9rZSB0aGUgbWV0aG9kXG4gICAgICAgICAqIHtAbGluayBQSVhJLlRpY2tlciNzdGFydH0gYXV0b21hdGljYWxseVxuICAgICAgICAgKiB3aGVuIGEgbGlzdGVuZXIgaXMgYWRkZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XG4gICAgICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmF1dG9TdGFydCA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogU2NhbGFyIHRpbWUgdmFsdWUgZnJvbSBsYXN0IGZyYW1lIHRvIHRoaXMgZnJhbWUuXG4gICAgICAgICAqIFRoaXMgdmFsdWUgaXMgY2FwcGVkIGJ5IHNldHRpbmcge0BsaW5rIFBJWEkuVGlja2VyI21pbkZQU31cbiAgICAgICAgICogYW5kIGlzIHNjYWxlZCB3aXRoIHtAbGluayBQSVhJLlRpY2tlciNzcGVlZH0uXG4gICAgICAgICAqICoqTm90ZToqKiBUaGUgY2FwIG1heSBiZSBleGNlZWRlZCBieSBzY2FsaW5nLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDFcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGVsdGFUaW1lID0gMTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNjYWxlciB0aW1lIGVsYXBzZWQgaW4gbWlsbGlzZWNvbmRzIGZyb20gbGFzdCBmcmFtZSB0byB0aGlzIGZyYW1lLlxuICAgICAgICAgKiBUaGlzIHZhbHVlIGlzIGNhcHBlZCBieSBzZXR0aW5nIHtAbGluayBQSVhJLlRpY2tlciNtaW5GUFN9XG4gICAgICAgICAqIGFuZCBpcyBzY2FsZWQgd2l0aCB7QGxpbmsgUElYSS5UaWNrZXIjc3BlZWR9LlxuICAgICAgICAgKiAqKk5vdGU6KiogVGhlIGNhcCBtYXkgYmUgZXhjZWVkZWQgYnkgc2NhbGluZy5cbiAgICAgICAgICogSWYgdGhlIHBsYXRmb3JtIHN1cHBvcnRzIERPTUhpZ2hSZXNUaW1lU3RhbXAsXG4gICAgICAgICAqIHRoaXMgdmFsdWUgd2lsbCBoYXZlIGEgcHJlY2lzaW9uIG9mIDEgwrVzLlxuICAgICAgICAgKiBEZWZhdWx0cyB0byB0YXJnZXQgZnJhbWUgdGltZVxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqIEBkZWZhdWx0IDE2LjY2XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRlbHRhTVMgPSAxIC8gc2V0dGluZ3NfMS5zZXR0aW5ncy5UQVJHRVRfRlBNUztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRpbWUgZWxhcHNlZCBpbiBtaWxsaXNlY29uZHMgZnJvbSBsYXN0IGZyYW1lIHRvIHRoaXMgZnJhbWUuXG4gICAgICAgICAqIE9wcG9zZWQgdG8gd2hhdCB0aGUgc2NhbGFyIHtAbGluayBQSVhJLlRpY2tlciNkZWx0YVRpbWV9XG4gICAgICAgICAqIGlzIGJhc2VkLCB0aGlzIHZhbHVlIGlzIG5laXRoZXIgY2FwcGVkIG5vciBzY2FsZWQuXG4gICAgICAgICAqIElmIHRoZSBwbGF0Zm9ybSBzdXBwb3J0cyBET01IaWdoUmVzVGltZVN0YW1wLFxuICAgICAgICAgKiB0aGlzIHZhbHVlIHdpbGwgaGF2ZSBhIHByZWNpc2lvbiBvZiAxIMK1cy5cbiAgICAgICAgICogRGVmYXVsdHMgdG8gdGFyZ2V0IGZyYW1lIHRpbWVcbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAxNi42NlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5lbGFwc2VkTVMgPSAxIC8gc2V0dGluZ3NfMS5zZXR0aW5ncy5UQVJHRVRfRlBNUztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBsYXN0IHRpbWUge0BsaW5rIFBJWEkuVGlja2VyI3VwZGF0ZX0gd2FzIGludm9rZWQuXG4gICAgICAgICAqIFRoaXMgdmFsdWUgaXMgYWxzbyByZXNldCBpbnRlcm5hbGx5IG91dHNpZGUgb2YgaW52b2tpbmdcbiAgICAgICAgICogdXBkYXRlLCBidXQgb25seSB3aGVuIGEgbmV3IGFuaW1hdGlvbiBmcmFtZSBpcyByZXF1ZXN0ZWQuXG4gICAgICAgICAqIElmIHRoZSBwbGF0Zm9ybSBzdXBwb3J0cyBET01IaWdoUmVzVGltZVN0YW1wLFxuICAgICAgICAgKiB0aGlzIHZhbHVlIHdpbGwgaGF2ZSBhIHByZWNpc2lvbiBvZiAxIMK1cy5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKiBAZGVmYXVsdCAtMVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5sYXN0VGltZSA9IC0xO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmFjdG9yIG9mIGN1cnJlbnQge0BsaW5rIFBJWEkuVGlja2VyI2RlbHRhVGltZX0uXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIC8vIFNjYWxlcyB0aWNrZXIuZGVsdGFUaW1lIHRvIHdoYXQgd291bGQgYmVcbiAgICAgICAgICogLy8gdGhlIGVxdWl2YWxlbnQgb2YgYXBwcm94aW1hdGVseSAxMjAgRlBTXG4gICAgICAgICAqIHRpY2tlci5zcGVlZCA9IDI7XG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgMVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zcGVlZCA9IDE7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIG9yIG5vdCB0aGlzIHRpY2tlciBoYXMgYmVlbiBzdGFydGVkLlxuICAgICAgICAgKiBgdHJ1ZWAgaWYge0BsaW5rIFBJWEkuVGlja2VyI3N0YXJ0fSBoYXMgYmVlbiBjYWxsZWQuXG4gICAgICAgICAqIGBmYWxzZWAgaWYge0BsaW5rIFBJWEkuVGlja2VyI3N0b3B9IGhhcyBiZWVuIGNhbGxlZC5cbiAgICAgICAgICogV2hpbGUgYGZhbHNlYCwgdGhpcyB2YWx1ZSBtYXkgY2hhbmdlIHRvIGB0cnVlYCBpbiB0aGVcbiAgICAgICAgICogZXZlbnQgb2Yge0BsaW5rIFBJWEkuVGlja2VyI2F1dG9TdGFydH0gYmVpbmcgYHRydWVgXG4gICAgICAgICAqIGFuZCBhIGxpc3RlbmVyIGlzIGFkZGVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtib29sZWFufVxuICAgICAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdGFydGVkID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBlbmFibGVkLCBkZWxldGluZyBpcyBkaXNhYmxlZC5cbiAgICAgICAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICAgICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3Byb3RlY3RlZCA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogSW50ZXJuYWwgdGljayBtZXRob2QgYm91bmQgdG8gdGlja2VyIGluc3RhbmNlLlxuICAgICAgICAgKiBUaGlzIGlzIGJlY2F1c2UgaW4gZWFybHkgMjAxNSwgRnVuY3Rpb24uYmluZFxuICAgICAgICAgKiBpcyBzdGlsbCA2MCUgc2xvd2VyIGluIGhpZ2ggcGVyZm9ybWFuY2Ugc2NlbmFyaW9zLlxuICAgICAgICAgKiBBbHNvIHNlcGFyYXRpbmcgZnJhbWUgcmVxdWVzdHMgZnJvbSB1cGRhdGUgbWV0aG9kXG4gICAgICAgICAqIHNvIGxpc3RlbmVycyBtYXkgYmUgY2FsbGVkIGF0IGFueSB0aW1lIGFuZCB3aXRoXG4gICAgICAgICAqIGFueSBhbmltYXRpb24gQVBJLCBqdXN0IGludm9rZSB0aWNrZXIudXBkYXRlKHRpbWUpLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gdGltZSAtIFRpbWUgc2luY2UgbGFzdCB0aWNrLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fdGljayA9IGZ1bmN0aW9uICh0aW1lKSB7XG4gICAgICAgICAgICB0aGlzJDEuX3JlcXVlc3RJZCA9IG51bGw7XG4gICAgICAgICAgICBpZiAodGhpcyQxLnN0YXJ0ZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBJbnZva2UgbGlzdGVuZXJzIG5vd1xuICAgICAgICAgICAgICAgIHRoaXMkMS51cGRhdGUodGltZSk7XG4gICAgICAgICAgICAgICAgLy8gTGlzdGVuZXIgc2lkZSBlZmZlY3RzIG1heSBoYXZlIG1vZGlmaWVkIHRpY2tlciBzdGF0ZS5cbiAgICAgICAgICAgICAgICBpZiAodGhpcyQxLnN0YXJ0ZWQgJiYgdGhpcyQxLl9yZXF1ZXN0SWQgPT09IG51bGwgJiYgdGhpcyQxLl9oZWFkLm5leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcyQxLl9yZXF1ZXN0SWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcyQxLl90aWNrKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEludGVybmFsbHkgYWRkcyB0aGUgZXZlbnQgaGFuZGxlciBzbyB0aGF0IGl0IGNhbiBiZSBzb3J0ZWQgYnkgcHJpb3JpdHkuXG4gICAgICogUHJpb3JpdHkgYWxsb3dzIGNlcnRhaW4gaGFuZGxlciAodXNlciwgQW5pbWF0ZWRTcHJpdGUsIEludGVyYWN0aW9uKSB0byBiZSBydW5cbiAgICAgKiBiZWZvcmUgdGhlIHJlbmRlcmluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtUaWNrZXJMaXN0ZW5lcn0gbGlzdGVuZXIgLSBDdXJyZW50IGxpc3RlbmVyIGJlaW5nIGFkZGVkLlxuICAgICAqIEByZXR1cm5zIHtQSVhJLlRpY2tlcn0gVGhpcyBpbnN0YW5jZSBvZiBhIHRpY2tlclxuICAgICAqL1xuICAgIF9hZGRMaXN0ZW5lcihsaXN0ZW5lcikge1xuICAgICAgICAvLyBGb3IgYXR0YWNoaW5nIHRvIGhlYWRcbiAgICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzLl9oZWFkLm5leHQ7XG4gICAgICAgIHZhciBwcmV2aW91cyA9IHRoaXMuX2hlYWQ7XG4gICAgICAgIC8vIEFkZCB0aGUgZmlyc3QgaXRlbVxuICAgICAgICBpZiAoIWN1cnJlbnQpIHtcbiAgICAgICAgICAgIGxpc3RlbmVyLmNvbm5lY3QocHJldmlvdXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gR28gZnJvbSBoaWdoZXN0IHRvIGxvd2VzdCBwcmlvcml0eVxuICAgICAgICAgICAgd2hpbGUgKGN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAobGlzdGVuZXIucHJpb3JpdHkgPiBjdXJyZW50LnByaW9yaXR5KSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyLmNvbm5lY3QocHJldmlvdXMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcHJldmlvdXMgPSBjdXJyZW50O1xuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBOb3QgeWV0IGNvbm5lY3RlZFxuICAgICAgICAgICAgaWYgKCFsaXN0ZW5lci5wcmV2aW91cykge1xuICAgICAgICAgICAgICAgIGxpc3RlbmVyLmNvbm5lY3QocHJldmlvdXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3N0YXJ0SWZQb3NzaWJsZSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFRyaWdnZXJzIGFuIHVwZGF0ZS4gQW4gdXBkYXRlIGVudGFpbHMgc2V0dGluZyB0aGVcbiAgICAgKiBjdXJyZW50IHtAbGluayBQSVhJLlRpY2tlciNlbGFwc2VkTVN9LFxuICAgICAqIHRoZSBjdXJyZW50IHtAbGluayBQSVhJLlRpY2tlciNkZWx0YVRpbWV9LFxuICAgICAqIGludm9raW5nIGFsbCBsaXN0ZW5lcnMgd2l0aCBjdXJyZW50IGRlbHRhVGltZSxcbiAgICAgKiBhbmQgdGhlbiBmaW5hbGx5IHNldHRpbmcge0BsaW5rIFBJWEkuVGlja2VyI2xhc3RUaW1lfVxuICAgICAqIHdpdGggdGhlIHZhbHVlIG9mIGN1cnJlbnRUaW1lIHRoYXQgd2FzIHByb3ZpZGVkLlxuICAgICAqIFRoaXMgbWV0aG9kIHdpbGwgYmUgY2FsbGVkIGF1dG9tYXRpY2FsbHkgYnkgYW5pbWF0aW9uXG4gICAgICogZnJhbWUgY2FsbGJhY2tzIGlmIHRoZSB0aWNrZXIgaW5zdGFuY2UgaGFzIGJlZW4gc3RhcnRlZFxuICAgICAqIGFuZCBsaXN0ZW5lcnMgYXJlIGFkZGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtjdXJyZW50VGltZT1wZXJmb3JtYW5jZS5ub3coKV0gLSB0aGUgY3VycmVudCB0aW1lIG9mIGV4ZWN1dGlvblxuICAgICAqL1xuICAgIHVwZGF0ZShjdXJyZW50VGltZSkge1xuICAgICAgICBpZiAoY3VycmVudFRpbWUgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgY3VycmVudFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZWxhcHNlZE1TO1xuICAgICAgICAvLyBJZiB0aGUgZGlmZmVyZW5jZSBpbiB0aW1lIGlzIHplcm8gb3IgbmVnYXRpdmUsIHdlIGlnbm9yZSBtb3N0IG9mIHRoZSB3b3JrIGRvbmUgaGVyZS5cbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gdmFsaWQgZGlmZmVyZW5jZSwgdGhlbiBzaG91bGQgYmUgbm8gcmVhc29uIHRvIGxldCBhbnlvbmUga25vdyBhYm91dCBpdC5cbiAgICAgICAgLy8gQSB6ZXJvIGRlbHRhLCBpcyBleGFjdGx5IHRoYXQsIG5vdGhpbmcgc2hvdWxkIHVwZGF0ZS5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gVGhlIGRpZmZlcmVuY2UgaW4gdGltZSBjYW4gYmUgbmVnYXRpdmUsIGFuZCBubyB0aGlzIGRvZXMgbm90IG1lYW4gdGltZSB0cmF2ZWxpbmcuXG4gICAgICAgIC8vIFRoaXMgY2FuIGJlIHRoZSByZXN1bHQgb2YgYSByYWNlIGNvbmRpdGlvbiBiZXR3ZWVuIHdoZW4gYW4gYW5pbWF0aW9uIGZyYW1lIGlzIHJlcXVlc3RlZFxuICAgICAgICAvLyBvbiB0aGUgY3VycmVudCBKYXZhU2NyaXB0IGVuZ2luZSBldmVudCBsb29wLCBhbmQgd2hlbiB0aGUgdGlja2VyJ3Mgc3RhcnQgbWV0aG9kIGlzIGludm9rZWRcbiAgICAgICAgLy8gKHdoaWNoIGludm9rZXMgdGhlIGludGVybmFsIF9yZXF1ZXN0SWZOZWVkZWQgbWV0aG9kKS4gSWYgYSBmcmFtZSBpcyByZXF1ZXN0ZWQgYmVmb3JlXG4gICAgICAgIC8vIF9yZXF1ZXN0SWZOZWVkZWQgaXMgaW52b2tlZCwgdGhlbiB0aGUgY2FsbGJhY2sgZm9yIHRoZSBhbmltYXRpb24gZnJhbWUgdGhlIHRpY2tlciByZXF1ZXN0cyxcbiAgICAgICAgLy8gY2FuIHJlY2VpdmUgYSB0aW1lIGFyZ3VtZW50IHRoYXQgY2FuIGJlIGxlc3MgdGhhbiB0aGUgbGFzdFRpbWUgdmFsdWUgdGhhdCB3YXMgc2V0IHdpdGhpblxuICAgICAgICAvLyBfcmVxdWVzdElmTmVlZGVkLiBUaGlzIGRpZmZlcmVuY2UgaXMgaW4gbWljcm9zZWNvbmRzLCBidXQgdGhpcyBpcyBlbm91Z2ggdG8gY2F1c2UgcHJvYmxlbXMuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFRoaXMgY2hlY2sgY292ZXJzIHRoaXMgYnJvd3NlciBlbmdpbmUgdGltaW5nIGlzc3VlLCBhcyB3ZWxsIGFzIGlmIGNvbnN1bWVycyBwYXNzIGFuIGludmFsaWRcbiAgICAgICAgLy8gY3VycmVudFRpbWUgdmFsdWUuIFRoaXMgbWF5IGhhcHBlbiBpZiBjb25zdW1lcnMgb3B0LW91dCBvZiB0aGUgYXV0b1N0YXJ0LCBhbmQgdXBkYXRlIHRoZW1zZWx2ZXMuXG4gICAgICAgIGlmIChjdXJyZW50VGltZSA+IHRoaXMubGFzdFRpbWUpIHtcbiAgICAgICAgICAgIC8vIFNhdmUgdW5jYXBwZWQgZWxhcHNlZE1TIGZvciBtZWFzdXJlbWVudFxuICAgICAgICAgICAgZWxhcHNlZE1TID0gdGhpcy5lbGFwc2VkTVMgPSBjdXJyZW50VGltZSAtIHRoaXMubGFzdFRpbWU7XG4gICAgICAgICAgICAvLyBjYXAgdGhlIG1pbGxpc2Vjb25kcyBlbGFwc2VkIHVzZWQgZm9yIGRlbHRhVGltZVxuICAgICAgICAgICAgaWYgKGVsYXBzZWRNUyA+IHRoaXMuX21heEVsYXBzZWRNUykge1xuICAgICAgICAgICAgICAgIGVsYXBzZWRNUyA9IHRoaXMuX21heEVsYXBzZWRNUztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsYXBzZWRNUyAqPSB0aGlzLnNwZWVkO1xuICAgICAgICAgICAgLy8gaWYgbm90IGVub3VnaCB0aW1lIGhhcyBwYXNzZWQsIGV4aXQgdGhlIGZ1bmN0aW9uLlxuICAgICAgICAgICAgLy8gV2UgZ2l2ZSBhbiBleHRyYSBtcyB0byBlbGFwc2VkTVMgZm9yIHRoaXMgY2hlY2ssIGJlY2F1c2UgdGhlIG5hdHVyZSBvZlxuICAgICAgICAgICAgLy8gcmVxdWVzdCBhbmltYXRpb24gZnJhbWUgbWVhbnMgdGhhdCBub3QgYWxsIGJyb3dzZXJzIHdpbGwgcmV0dXJuIHByZWNpc2UgdmFsdWVzLlxuICAgICAgICAgICAgLy8gSG93ZXZlciwgYmVjYXVzZSByQUYgd29ya3MgYmFzZWQgb24gdi1zeW5jLCBpdCdzIHdvbid0IGNoYW5nZSB0aGUgZWZmZWN0aXZlIEZQUy5cbiAgICAgICAgICAgIGlmICh0aGlzLl9taW5FbGFwc2VkTVMgJiYgZWxhcHNlZE1TICsgMSA8IHRoaXMuX21pbkVsYXBzZWRNUykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZGVsdGFNUyA9IGVsYXBzZWRNUztcbiAgICAgICAgICAgIHRoaXMuZGVsdGFUaW1lID0gdGhpcy5kZWx0YU1TICogc2V0dGluZ3NfMS5zZXR0aW5ncy5UQVJHRVRfRlBNUztcbiAgICAgICAgICAgIC8vIENhY2hlIGEgbG9jYWwgcmVmZXJlbmNlLCBpbi1jYXNlIHRpY2tlciBpcyBkZXN0cm95ZWRcbiAgICAgICAgICAgIC8vIGR1cmluZyB0aGUgZW1pdCwgd2UgY2FuIHN0aWxsIGNoZWNrIGZvciBoZWFkLm5leHRcbiAgICAgICAgICAgIHZhciBoZWFkID0gdGhpcy5faGVhZDtcbiAgICAgICAgICAgIC8vIEludm9rZSBsaXN0ZW5lcnMgYWRkZWQgdG8gaW50ZXJuYWwgZW1pdHRlclxuICAgICAgICAgICAgdmFyIGxpc3RlbmVyID0gaGVhZC5uZXh0O1xuICAgICAgICAgICAgd2hpbGUgKGxpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXIgPSBsaXN0ZW5lci5lbWl0KHRoaXMuZGVsdGFUaW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaGVhZC5uZXh0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2FuY2VsSWZOZWVkZWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZGVsdGFUaW1lID0gdGhpcy5kZWx0YU1TID0gdGhpcy5lbGFwc2VkTVMgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubGFzdFRpbWUgPSBjdXJyZW50VGltZTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIERlc3Ryb3kgdGhlIHRpY2tlciBhbmQgZG9uJ3QgdXNlIGFmdGVyIHRoaXMuIENhbGxpbmdcbiAgICAgKiB0aGlzIG1ldGhvZCByZW1vdmVzIGFsbCByZWZlcmVuY2VzIHRvIGludGVybmFsIGV2ZW50cy5cbiAgICAgKi9cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBpZiAoIXRoaXMuX3Byb3RlY3RlZCkge1xuICAgICAgICAgICAgdGhpcy5zdG9wKCk7XG4gICAgICAgICAgICB2YXIgbGlzdGVuZXIgPSB0aGlzLl9oZWFkLm5leHQ7XG4gICAgICAgICAgICB3aGlsZSAobGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICBsaXN0ZW5lciA9IGxpc3RlbmVyLmRlc3Ryb3kodHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9oZWFkLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIHRoaXMuX2hlYWQgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBTdG9wcyB0aGUgdGlja2VyLiBJZiB0aGUgdGlja2VyIGhhcyByZXF1ZXN0ZWRcbiAgICAgKiBhbiBhbmltYXRpb24gZnJhbWUgaXQgaXMgY2FuY2VsZWQgYXQgdGhpcyBwb2ludC5cbiAgICAgKi9cbiAgICBzdG9wKCkge1xuICAgICAgICBpZiAodGhpcy5zdGFydGVkKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX2NhbmNlbElmTmVlZGVkKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFN0YXJ0cyB0aGUgdGlja2VyLiBJZiB0aGUgdGlja2VyIGhhcyBsaXN0ZW5lcnNcbiAgICAgKiBhIG5ldyBhbmltYXRpb24gZnJhbWUgaXMgcmVxdWVzdGVkIGF0IHRoaXMgcG9pbnQuXG4gICAgICovXG4gICAgc3RhcnQoKSB7XG4gICAgICAgIGlmICghdGhpcy5zdGFydGVkKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fcmVxdWVzdElmTmVlZGVkKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYW55IGhhbmRsZXJzIG1hdGNoaW5nIHRoZSBmdW5jdGlvbiBhbmQgY29udGV4dCBwYXJhbWV0ZXJzLlxuICAgICAqIElmIG5vIGhhbmRsZXJzIGFyZSBsZWZ0IGFmdGVyIHJlbW92aW5nLCB0aGVuIGl0IGNhbmNlbHMgdGhlIGFuaW1hdGlvbiBmcmFtZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIC0gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uIHRvIGJlIHJlbW92ZWRcbiAgICAgKiBAcGFyYW0geyp9IFtjb250ZXh0XSAtIFRoZSBsaXN0ZW5lciBjb250ZXh0IHRvIGJlIHJlbW92ZWRcbiAgICAgKiBAcmV0dXJucyB7UElYSS5UaWNrZXJ9IFRoaXMgaW5zdGFuY2Ugb2YgYSB0aWNrZXJcbiAgICAgKi9cbiAgICByZW1vdmUoZm4sIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIGxpc3RlbmVyID0gdGhpcy5faGVhZC5uZXh0O1xuICAgICAgICB3aGlsZSAobGlzdGVuZXIpIHtcbiAgICAgICAgICAgIC8vIFdlIGZvdW5kIGEgbWF0Y2gsIGxldHMgcmVtb3ZlIGl0XG4gICAgICAgICAgICAvLyBubyBicmVhayB0byBkZWxldGUgYWxsIHBvc3NpYmxlIG1hdGNoZXNcbiAgICAgICAgICAgIC8vIGluY2FzZSBhIGxpc3RlbmVyIHdhcyBhZGRlZCAyKyB0aW1lc1xuICAgICAgICAgICAgaWYgKGxpc3RlbmVyLm1hdGNoKGZuLCBjb250ZXh0KSkge1xuICAgICAgICAgICAgICAgIGxpc3RlbmVyID0gbGlzdGVuZXIuZGVzdHJveSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXIgPSBsaXN0ZW5lci5uZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5faGVhZC5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLl9jYW5jZWxJZk5lZWRlZCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogQWRkIGEgaGFuZGxlciBmb3IgdGhlIHRpY2sgZXZlbnQgd2hpY2ggaXMgb25seSBleGVjdXRlIG9uY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAtIFRoZSBsaXN0ZW5lciBmdW5jdGlvbiB0byBiZSBhZGRlZCBmb3Igb25lIHVwZGF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gW2NvbnRleHRdIC0gVGhlIGxpc3RlbmVyIGNvbnRleHRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3ByaW9yaXR5PVBJWEkuVVBEQVRFX1BSSU9SSVRZLk5PUk1BTF0gLSBUaGUgcHJpb3JpdHkgZm9yIGVtaXR0aW5nXG4gICAgICogQHJldHVybnMge1BJWEkuVGlja2VyfSBUaGlzIGluc3RhbmNlIG9mIGEgdGlja2VyXG4gICAgICovXG4gICAgYWRkT25jZShmbiwgY29udGV4dCwgcHJpb3JpdHkpIHtcbiAgICAgICAgaWYgKHByaW9yaXR5ID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHByaW9yaXR5ID0gVGlja2VyLlVQREFURV9QUklPUklUWS5OT1JNQUw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZExpc3RlbmVyKG5ldyBUaWNrZXJMaXN0ZW5lcl8xLlRpY2tlckxpc3RlbmVyKGZuLCBjb250ZXh0LCBwcmlvcml0eSwgdHJ1ZSkpO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXIgYSBoYW5kbGVyIGZvciB0aWNrIGV2ZW50cy4gQ2FsbHMgY29udGludW91c2x5IHVubGVzc1xuICAgICAqIGl0IGlzIHJlbW92ZWQgb3IgdGhlIHRpY2tlciBpcyBzdG9wcGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gLSBUaGUgbGlzdGVuZXIgZnVuY3Rpb24gdG8gYmUgYWRkZWQgZm9yIHVwZGF0ZXNcbiAgICAgKiBAcGFyYW0geyp9IFtjb250ZXh0XSAtIFRoZSBsaXN0ZW5lciBjb250ZXh0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwcmlvcml0eT1QSVhJLlVQREFURV9QUklPUklUWS5OT1JNQUxdIC0gVGhlIHByaW9yaXR5IGZvciBlbWl0dGluZ1xuICAgICAqIEByZXR1cm5zIHtQSVhJLlRpY2tlcn0gVGhpcyBpbnN0YW5jZSBvZiBhIHRpY2tlclxuICAgICAqL1xuICAgIGFkZChmbiwgY29udGV4dCA9IG51bGwsIHByaW9yaXR5ID0gbnVsbCkge1xuICAgICAgICBpZiAocHJpb3JpdHkgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgcHJpb3JpdHkgPSBUaWNrZXIuVVBEQVRFX1BSSU9SSVRZLk5PUk1BTDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fYWRkTGlzdGVuZXIobmV3IFRpY2tlckxpc3RlbmVyXzEuVGlja2VyTGlzdGVuZXIoZm4sIGNvbnRleHQsIHByaW9yaXR5KSk7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBDb25kaXRpb25hbGx5IHJlcXVlc3RzIGEgbmV3IGFuaW1hdGlvbiBmcmFtZS5cbiAgICAgKiBJZiB0aGUgdGlja2VyIGhhcyBiZWVuIHN0YXJ0ZWQgaXQgY2hlY2tzIGlmIGEgZnJhbWUgaGFzIG5vdCBhbHJlYWR5XG4gICAgICogYmVlbiByZXF1ZXN0ZWQsIGFuZCBpZiB0aGUgaW50ZXJuYWwgZW1pdHRlciBoYXMgbGlzdGVuZXJzLiBJZiB0aGVzZVxuICAgICAqIGNvbmRpdGlvbnMgYXJlIG1ldCwgYSBuZXcgZnJhbWUgaXMgcmVxdWVzdGVkLiBJZiB0aGUgdGlja2VyIGhhcyBub3RcbiAgICAgKiBiZWVuIHN0YXJ0ZWQsIGJ1dCBhdXRvU3RhcnQgaXMgYHRydWVgLCB0aGVuIHRoZSB0aWNrZXIgc3RhcnRzIG5vdyxcbiAgICAgKiBhbmQgY29udGludWVzIHdpdGggdGhlIHByZXZpb3VzIGNvbmRpdGlvbnMgdG8gcmVxdWVzdCBhIG5ldyBmcmFtZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3N0YXJ0SWZQb3NzaWJsZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhcnRlZCkge1xuICAgICAgICAgICAgdGhpcy5fcmVxdWVzdElmTmVlZGVkKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5hdXRvU3RhcnQpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogQ29uZGl0aW9uYWxseSBjYW5jZWxzIGEgcGVuZGluZyBhbmltYXRpb24gZnJhbWUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9jYW5jZWxJZk5lZWRlZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3JlcXVlc3RJZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5fcmVxdWVzdElkKTtcbiAgICAgICAgICAgIHRoaXMuX3JlcXVlc3RJZCA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICogQ29uZGl0aW9uYWxseSByZXF1ZXN0cyBhIG5ldyBhbmltYXRpb24gZnJhbWUuXG4gKiBJZiBhIGZyYW1lIGhhcyBub3QgYWxyZWFkeSBiZWVuIHJlcXVlc3RlZCwgYW5kIGlmIHRoZSBpbnRlcm5hbFxuICogZW1pdHRlciBoYXMgbGlzdGVuZXJzLCBhIG5ldyBmcmFtZSBpcyByZXF1ZXN0ZWQuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuICAgIF9yZXF1ZXN0SWZOZWVkZWQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9yZXF1ZXN0SWQgPT09IG51bGwgJiYgdGhpcy5faGVhZC5uZXh0KSB7XG4gICAgICAgICAgICAvLyBlbnN1cmUgY2FsbGJhY2tzIGdldCBjb3JyZWN0IGRlbHRhXG4gICAgICAgICAgICB0aGlzLmxhc3RUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgICAgICB0aGlzLl9yZXF1ZXN0SWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5fdGljayk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFRoZSBmcmFtZXMgcGVyIHNlY29uZCBhdCB3aGljaCB0aGlzIHRpY2tlciBpcyBydW5uaW5nLlxuICAgICAqIFRoZSBkZWZhdWx0IGlzIGFwcHJveGltYXRlbHkgNjAgaW4gbW9zdCBtb2Rlcm4gYnJvd3NlcnMuXG4gICAgICogKipOb3RlOioqIFRoaXMgZG9lcyBub3QgZmFjdG9yIGluIHRoZSB2YWx1ZSBvZlxuICAgICAqIHtAbGluayBQSVhJLlRpY2tlciNzcGVlZH0sIHdoaWNoIGlzIHNwZWNpZmljXG4gICAgICogdG8gc2NhbGluZyB7QGxpbmsgUElYSS5UaWNrZXIjZGVsdGFUaW1lfS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKi9cbiAgICBnZXQgRlBTKCkge1xuICAgICAgICByZXR1cm4gMTAwMCAvIHRoaXMuZWxhcHNlZE1TO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogTWFuYWdlcyB0aGUgbWF4aW11bSBhbW91bnQgb2YgbWlsbGlzZWNvbmRzIGFsbG93ZWQgdG9cbiAgICAgKiBlbGFwc2UgYmV0d2VlbiBpbnZva2luZyB7QGxpbmsgUElYSS5UaWNrZXIjdXBkYXRlfS5cbiAgICAgKiBUaGlzIHZhbHVlIGlzIHVzZWQgdG8gY2FwIHtAbGluayBQSVhJLlRpY2tlciNkZWx0YVRpbWV9LFxuICAgICAqIGJ1dCBkb2VzIG5vdCBlZmZlY3QgdGhlIG1lYXN1cmVkIHZhbHVlIG9mIHtAbGluayBQSVhJLlRpY2tlciNGUFN9LlxuICAgICAqIFdoZW4gc2V0dGluZyB0aGlzIHByb3BlcnR5IGl0IGlzIGNsYW1wZWQgdG8gYSB2YWx1ZSBiZXR3ZWVuXG4gICAgICogYDBgIGFuZCBgUElYSS5zZXR0aW5ncy5UQVJHRVRfRlBNUyAqIDEwMDBgLlxuICAgICAqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IDEwXG4gICAgICovXG4gICAgZ2V0IG1pbkZQUygpIHtcbiAgICAgICAgcmV0dXJuIDEwMDAgLyB0aGlzLl9tYXhFbGFwc2VkTVM7XG4gICAgfVxuICAgIDtcbiAgICBzZXQgbWluRlBTKGZwcykge1xuICAgICAgICAvLyBNaW5pbXVtIG11c3QgYmUgYmVsb3cgdGhlIG1heEZQU1xuICAgICAgICB2YXIgbWluRlBTID0gTWF0aC5taW4odGhpcy5tYXhGUFMsIGZwcyk7XG4gICAgICAgIC8vIE11c3QgYmUgYXQgbGVhc3QgMCwgYnV0IGJlbG93IDEgLyBzZXR0aW5ncy5UQVJHRVRfRlBNU1xuICAgICAgICB2YXIgbWluRlBNUyA9IE1hdGgubWluKE1hdGgubWF4KDAsIG1pbkZQUykgLyAxMDAwLCBzZXR0aW5nc18xLnNldHRpbmdzLlRBUkdFVF9GUE1TKTtcbiAgICAgICAgdGhpcy5fbWF4RWxhcHNlZE1TID0gMSAvIG1pbkZQTVM7XG4gICAgfVxuICAgIDtcbiAgICBzZXQgbWF4RlBTKGZwcykge1xuICAgICAgICBpZiAoZnBzIC8gMTAwMCA+PSBzZXR0aW5nc18xLnNldHRpbmdzLlRBUkdFVF9GUE1TKSB7XG4gICAgICAgICAgICB0aGlzLl9taW5FbGFwc2VkTVMgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gTWF4IG11c3QgYmUgYXQgbGVhc3QgdGhlIG1pbkZQU1xuICAgICAgICAgICAgdmFyIG1heEZQUyA9IE1hdGgubWF4KHRoaXMubWluRlBTLCBmcHMpO1xuICAgICAgICAgICAgLy8gTXVzdCBiZSBhdCBsZWFzdCAxLCBidXQgYmVsb3cgMSAvIHNldHRpbmdzLlRBUkdFVF9GUE1TXG4gICAgICAgICAgICB2YXIgbWF4RlBNUyA9IE1hdGgubWluKE1hdGgubWF4KDEsIG1heEZQUykgLyAxMDAwLCBzZXR0aW5nc18xLnNldHRpbmdzLlRBUkdFVF9GUE1TKTtcbiAgICAgICAgICAgIHRoaXMuX21pbkVsYXBzZWRNUyA9IDEgLyBtYXhGUE1TO1xuICAgICAgICB9XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAqIFRoZSBzaGFyZWQgdGlja2VyIGluc3RhbmNlIHVzZWQgYnkge0BsaW5rIFBJWEkuQW5pbWF0ZWRTcHJpdGV9IGFuZCBieVxuICoge0BsaW5rIFBJWEkuVmlkZW9SZXNvdXJjZX0gdG8gdXBkYXRlIGFuaW1hdGlvbiBmcmFtZXMgLyB2aWRlbyB0ZXh0dXJlcy5cbiAqXG4gKiBJdCBtYXkgYWxzbyBiZSB1c2VkIGJ5IHtAbGluayBQSVhJLkFwcGxpY2F0aW9ufSBpZiBjcmVhdGVkIHdpdGggdGhlIGBzaGFyZWRUaWNrZXJgIG9wdGlvbiBwcm9wZXJ0eSBzZXQgdG8gdHJ1ZS5cbiAqXG4gKiBUaGUgcHJvcGVydHkge0BsaW5rIFBJWEkuVGlja2VyI2F1dG9TdGFydH0gaXMgc2V0IHRvIGB0cnVlYCBmb3IgdGhpcyBpbnN0YW5jZS5cbiAqIFBsZWFzZSBmb2xsb3cgdGhlIGV4YW1wbGVzIGZvciB1c2FnZSwgaW5jbHVkaW5nIGhvdyB0byBvcHQtb3V0IG9mIGF1dG8tc3RhcnRpbmcgdGhlIHNoYXJlZCB0aWNrZXIuXG4gKlxuICogQGV4YW1wbGVcbiAqIGxldCB0aWNrZXIgPSBQSVhJLlRpY2tlci5zaGFyZWQ7XG4gKiAvLyBTZXQgdGhpcyB0byBwcmV2ZW50IHN0YXJ0aW5nIHRoaXMgdGlja2VyIHdoZW4gbGlzdGVuZXJzIGFyZSBhZGRlZC5cbiAqIC8vIEJ5IGRlZmF1bHQgdGhpcyBpcyB0cnVlIG9ubHkgZm9yIHRoZSBQSVhJLlRpY2tlci5zaGFyZWQgaW5zdGFuY2UuXG4gKiB0aWNrZXIuYXV0b1N0YXJ0ID0gZmFsc2U7XG4gKiAvLyBGWUksIGNhbGwgdGhpcyB0byBlbnN1cmUgdGhlIHRpY2tlciBpcyBzdG9wcGVkLiBJdCBzaG91bGQgYmUgc3RvcHBlZFxuICogLy8gaWYgeW91IGhhdmUgbm90IGF0dGVtcHRlZCB0byByZW5kZXIgYW55dGhpbmcgeWV0LlxuICogdGlja2VyLnN0b3AoKTtcbiAqIC8vIENhbGwgdGhpcyB3aGVuIHlvdSBhcmUgcmVhZHkgZm9yIGEgcnVubmluZyBzaGFyZWQgdGlja2VyLlxuICogdGlja2VyLnN0YXJ0KCk7XG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFlvdSBtYXkgdXNlIHRoZSBzaGFyZWQgdGlja2VyIHRvIHJlbmRlci4uLlxuICogbGV0IHJlbmRlcmVyID0gUElYSS5hdXRvRGV0ZWN0UmVuZGVyZXIoKTtcbiAqIGxldCBzdGFnZSA9IG5ldyBQSVhJLkNvbnRhaW5lcigpO1xuICogZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChyZW5kZXJlci52aWV3KTtcbiAqIHRpY2tlci5hZGQoZnVuY3Rpb24gKHRpbWUpIHtcbiAqIHJlbmRlcmVyLnJlbmRlcihzdGFnZSk7XG4gKiB9KTtcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gT3IgeW91IGNhbiBqdXN0IHVwZGF0ZSBpdCBtYW51YWxseS5cbiAqIHRpY2tlci5hdXRvU3RhcnQgPSBmYWxzZTtcbiAqIHRpY2tlci5zdG9wKCk7XG4gKiBmdW5jdGlvbiBhbmltYXRlKHRpbWUpIHtcbiAqIHRpY2tlci51cGRhdGUodGltZSk7XG4gKiByZW5kZXJlci5yZW5kZXIoc3RhZ2UpO1xuICogcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGUpO1xuICogfVxuICogYW5pbWF0ZShwZXJmb3JtYW5jZS5ub3coKSk7XG4gKlxuICogQG1lbWJlciB7UElYSS5UaWNrZXJ9XG4gKiBAc3RhdGljXG4gKi9cbiAgICBzdGF0aWMgZ2V0IHNoYXJlZCgpIHtcbiAgICAgICAgaWYgKCFUaWNrZXIuX3NoYXJlZCkge1xuICAgICAgICAgICAgdmFyIHNoYXJlZCA9IFRpY2tlci5fc2hhcmVkID0gbmV3IFRpY2tlcigpO1xuICAgICAgICAgICAgc2hhcmVkLmF1dG9TdGFydCA9IHRydWU7XG4gICAgICAgICAgICBzaGFyZWQuX3Byb3RlY3RlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFRpY2tlci5fc2hhcmVkO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogVGhlIHN5c3RlbSB0aWNrZXIgaW5zdGFuY2UgdXNlZCBieSB7QGxpbmsgUElYSS5pbnRlcmFjdGlvbi5JbnRlcmFjdGlvbk1hbmFnZXJ9IGFuZCBieVxuICAgICAqIHtAbGluayBQSVhJLkJhc2VQcmVwYXJlfSBmb3IgY29yZSB0aW1pbmcgZnVuY3Rpb25hbGl0eSB0aGF0IHNob3VsZG4ndCB1c3VhbGx5IG5lZWQgdG8gYmUgcGF1c2VkLFxuICAgICAqIHVubGlrZSB0aGUgYHNoYXJlZGAgdGlja2VyIHdoaWNoIGRyaXZlcyB2aXN1YWwgYW5pbWF0aW9ucyBhbmQgcmVuZGVyaW5nIHdoaWNoIG1heSB3YW50IHRvIGJlIHBhdXNlZC5cbiAgICAgKlxuICAgICAqIFRoZSBwcm9wZXJ0eSB7QGxpbmsgUElYSS5UaWNrZXIjYXV0b1N0YXJ0fSBpcyBzZXQgdG8gYHRydWVgIGZvciB0aGlzIGluc3RhbmNlLlxuICAgICAqXG4gICAgICogQG1lbWJlciB7UElYSS5UaWNrZXJ9XG4gICAgICogQHN0YXRpY1xuICAgICAqL1xuICAgIHN0YXRpYyBnZXQgc3lzdGVtKCkge1xuICAgICAgICBpZiAoIVRpY2tlci5fc3lzdGVtKSB7XG4gICAgICAgICAgICB2YXIgc3lzdGVtID0gVGlja2VyLl9zeXN0ZW0gPSBuZXcgVGlja2VyKCk7XG4gICAgICAgICAgICBzeXN0ZW0uYXV0b1N0YXJ0ID0gdHJ1ZTtcbiAgICAgICAgICAgIHN5c3RlbS5fcHJvdGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gVGlja2VyLl9zeXN0ZW07XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBNYW5hZ2VzIHRoZSBtaW5pbXVtIGFtb3VudCBvZiBtaWxsaXNlY29uZHMgYWxsb3dlZCB0b1xuICAgICAqIGVsYXBzZSBiZXR3ZWVuIGludm9raW5nIHtAbGluayBQSVhJLlRpY2tlciN1cGRhdGV9LlxuICAgICAqIFRoaXMgd2lsbCBlZmZlY3QgdGhlIG1lYXN1cmVkIHZhbHVlIG9mIHtAbGluayBQSVhJLnRpY2tlci5UaWNrZXIjRlBTfS5cbiAgICAgKiBXaGVuIHNldHRpbmcgdGhpcyBwcm9wZXJ0eSBpdCBpcyBjbGFtcGVkIHRvIGEgdmFsdWUgYmV0d2VlblxuICAgICAqIGAxYCBhbmQgYFRBUkdFVF9GUE1TICogMTAwMGAuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICogQGRlZmF1bHQgNjBcbiAgICAgKi9cbiAgICBnZXQgbWF4RlBTKCkge1xuICAgICAgICBpZiAodGhpcy5fbWluRWxhcHNlZE1TKSB7XG4gICAgICAgICAgICByZXR1cm4gMTAwMCAvIHRoaXMuX21pbkVsYXBzZWRNUztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2V0dGluZ3NfMS5zZXR0aW5ncy5UQVJHRVRfRlBNUyAqIDEwMDA7XG4gICAgfVxuICAgIDtcbn1cbi8qKlxuICogUmVwcmVzZW50cyB0aGUgdXBkYXRlIHByaW9yaXRpZXMgdXNlZCBieSBpbnRlcm5hbCBQSVhJIGNsYXNzZXMgd2hlbiByZWdpc3RlcmVkIHdpdGhcbiAqIHRoZSB7QGxpbmsgUElYSS5UaWNrZXJ9IG9iamVjdC4gSGlnaGVyIHByaW9yaXR5IGl0ZW1zIGFyZSB1cGRhdGVkIGZpcnN0IGFuZCBsb3dlclxuICogcHJpb3JpdHkgaXRlbXMsIHN1Y2ggYXMgcmVuZGVyLCBzaG91bGQgZ28gbGF0ZXIuXG4gKlxuICogQHN0YXRpY1xuICogQGNvbnN0YW50XG4gKiBAbmFtZSBVUERBVEVfUFJJT1JJVFlcbiAqIEBtZW1iZXJvZiBQSVhJXG4gKiBAdHlwZSB7b2JqZWN0fVxuICogQHByb3BlcnR5IHtudW1iZXJ9IElOVEVSQUNUSU9OPTUwIEhpZ2hlc3QgcHJpb3JpdHksIHVzZWQgZm9yIHtAbGluayBQSVhJLmludGVyYWN0aW9uLkludGVyYWN0aW9uTWFuYWdlcn1cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBISUdIPTI1IEhpZ2ggcHJpb3JpdHkgdXBkYXRpbmcsIHtAbGluayBQSVhJLlZpZGVvQmFzZVRleHR1cmV9IGFuZCB7QGxpbmsgUElYSS5BbmltYXRlZFNwcml0ZX1cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBOT1JNQUw9MCBEZWZhdWx0IHByaW9yaXR5IGZvciB0aWNrZXIgZXZlbnRzLCBzZWUge0BsaW5rIFBJWEkuVGlja2VyI2FkZH0uXG4gKiBAcHJvcGVydHkge251bWJlcn0gTE9XPS0yNSBMb3cgcHJpb3JpdHkgdXNlZCBmb3Ige0BsaW5rIFBJWEkuQXBwbGljYXRpb259IHJlbmRlcmluZy5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBVVElMSVRZPS01MCBMb3dlc3QgcHJpb3JpdHkgdXNlZCBmb3Ige0BsaW5rIFBJWEkucHJlcGFyZS5CYXNlUHJlcGFyZX0gdXRpbGl0eS5cbiAqL1xuVGlja2VyLlVQREFURV9QUklPUklUWSA9IHtcbiAgICBJTlRFUkFDVElPTjogNTAsXG4gICAgSElHSDogMjUsXG4gICAgTk9STUFMOiAwLFxuICAgIExPVzogLTI1LFxuICAgIFVUSUxJVFk6IC01MCxcbn07XG5leHBvcnRzLlRpY2tlciA9IFRpY2tlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY2xhc3MgVGlja2VyTGlzdGVuZXIge1xuICAgIGNvbnN0cnVjdG9yKGZuLCBjb250ZXh0LCBwcmlvcml0eSwgb25jZSA9IGZhbHNlKSB7XG4gICAgICAgIGlmIChjb250ZXh0ID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIGNvbnRleHQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcmlvcml0eSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBwcmlvcml0eSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uY2UgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgb25jZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgaGFuZGxlciBmdW5jdGlvbiB0byBleGVjdXRlLlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAbWVtYmVyIHtGdW5jdGlvbn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZm4gPSBmbjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjYWxsaW5nIHRvIGV4ZWN1dGUuXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBtZW1iZXIgeyp9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGN1cnJlbnQgcHJpb3JpdHkuXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucHJpb3JpdHkgPSBwcmlvcml0eTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHRoaXMgc2hvdWxkIG9ubHkgZXhlY3V0ZSBvbmNlLlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAbWVtYmVyIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vbmNlID0gb25jZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBuZXh0IGl0ZW0gaW4gY2hhaW4uXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBtZW1iZXIge1RpY2tlckxpc3RlbmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5uZXh0ID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBwcmV2aW91cyBpdGVtIGluIGNoYWluLlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAbWVtYmVyIHtUaWNrZXJMaXN0ZW5lcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucHJldmlvdXMgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogYHRydWVgIGlmIHRoaXMgbGlzdGVuZXIgaGFzIGJlZW4gZGVzdHJveWVkIGFscmVhZHkuXG4gICAgICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW1pdCBieSBjYWxsaW5nIHRoZSBjdXJyZW50IGZ1bmN0aW9uLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRlbHRhVGltZSAtIHRpbWUgc2luY2UgdGhlIGxhc3QgZW1pdC5cbiAgICAgKiBAcmV0dXJuIHtUaWNrZXJMaXN0ZW5lcn0gTmV4dCB0aWNrZXJcbiAgICAgKi9cbiAgICBlbWl0KGRlbHRhVGltZSkge1xuICAgICAgICBpZiAodGhpcy5mbikge1xuICAgICAgICAgICAgaWYgKHRoaXMuY29udGV4dCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZm4uY2FsbCh0aGlzLmNvbnRleHQsIGRlbHRhVGltZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZuKGRlbHRhVGltZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlZGlyZWN0ID0gdGhpcy5uZXh0O1xuICAgICAgICBpZiAodGhpcy5vbmNlKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3Ryb3kodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU29mdC1kZXN0cm95aW5nIHNob3VsZCByZW1vdmVcbiAgICAgICAgLy8gdGhlIG5leHQgcmVmZXJlbmNlXG4gICAgICAgIGlmICh0aGlzLl9kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlZGlyZWN0O1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogRGVzdHJveSBhbmQgZG9uJ3QgdXNlIGFmdGVyIHRoaXMuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtoYXJkID0gZmFsc2VdIGB0cnVlYCB0byByZW1vdmUgdGhlIGBuZXh0YCByZWZlcmVuY2UsIHRoaXNcbiAgICAgKiAgICBpcyBjb25zaWRlcmVkIGEgaGFyZCBkZXN0cm95LiBTb2Z0IGRlc3Ryb3kgbWFpbnRhaW5zIHRoZSBuZXh0IHJlZmVyZW5jZS5cbiAgICAgKiBAcmV0dXJuIHtUaWNrZXJMaXN0ZW5lcn0gVGhlIGxpc3RlbmVyIHRvIHJlZGlyZWN0IHdoaWxlIGVtaXR0aW5nIG9yIHJlbW92aW5nLlxuICAgICAqL1xuICAgIGRlc3Ryb3koaGFyZCkge1xuICAgICAgICBpZiAoaGFyZCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBoYXJkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZGVzdHJveWVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5mbiA9IG51bGw7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IG51bGw7XG4gICAgICAgIC8vIERpc2Nvbm5lY3QsIGhvb2sgdXAgbmV4dCBhbmQgcHJldmlvdXNcbiAgICAgICAgaWYgKHRoaXMucHJldmlvdXMpIHtcbiAgICAgICAgICAgIHRoaXMucHJldmlvdXMubmV4dCA9IHRoaXMubmV4dDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQucHJldmlvdXMgPSB0aGlzLnByZXZpb3VzO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlZGlyZWN0IHRvIHRoZSBuZXh0IGl0ZW1cbiAgICAgICAgdmFyIHJlZGlyZWN0ID0gdGhpcy5uZXh0O1xuICAgICAgICAvLyBSZW1vdmUgcmVmZXJlbmNlc1xuICAgICAgICB0aGlzLm5leHQgPSBoYXJkID8gbnVsbCA6IHJlZGlyZWN0O1xuICAgICAgICB0aGlzLnByZXZpb3VzID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHJlZGlyZWN0O1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogQ29ubmVjdCB0byB0aGUgbGlzdC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7VGlja2VyTGlzdGVuZXJ9IHByZXZpb3VzIC0gSW5wdXQgbm9kZSwgcHJldmlvdXMgbGlzdGVuZXJcbiAgICAgKi9cbiAgICBjb25uZWN0KHByZXZpb3VzKSB7XG4gICAgICAgIHRoaXMucHJldmlvdXMgPSBwcmV2aW91cztcbiAgICAgICAgaWYgKHByZXZpb3VzLm5leHQpIHtcbiAgICAgICAgICAgIHByZXZpb3VzLm5leHQucHJldmlvdXMgPSB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubmV4dCA9IHByZXZpb3VzLm5leHQ7XG4gICAgICAgIHByZXZpb3VzLm5leHQgPSB0aGlzO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogU2ltcGxlIGNvbXBhcmUgZnVuY3Rpb24gdG8gZmlndXJlIG91dCBpZiBhIGZ1bmN0aW9uIGFuZCBjb250ZXh0IG1hdGNoLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gLSBUaGUgbGlzdGVuZXIgZnVuY3Rpb24gdG8gYmUgYWRkZWQgZm9yIG9uZSB1cGRhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb250ZXh0IC0gVGhlIGxpc3RlbmVyIGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBgdHJ1ZWAgaWYgdGhlIGxpc3RlbmVyIG1hdGNoIHRoZSBhcmd1bWVudHNcbiAgICAgKi9cbiAgICBtYXRjaChmbiwgY29udGV4dCkge1xuICAgICAgICBjb250ZXh0ID0gY29udGV4dCB8fCBudWxsO1xuICAgICAgICByZXR1cm4gdGhpcy5mbiA9PT0gZm4gJiYgdGhpcy5jb250ZXh0ID09PSBjb250ZXh0O1xuICAgIH1cbiAgICA7XG59XG5leHBvcnRzLlRpY2tlckxpc3RlbmVyID0gVGlja2VyTGlzdGVuZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IFNwcml0ZV8xID0gcmVxdWlyZShcIi4vU3ByaXRlXCIpO1xuY29uc3QgVHJhbnNmb3JtXzEgPSByZXF1aXJlKFwiLi4vZmxhc2gvZ2VvbS9UcmFuc2Zvcm1cIik7XG5jb25zdCBUZXh0dXJlTWF0cml4XzEgPSByZXF1aXJlKFwiLi9UZXh0dXJlTWF0cml4XCIpO1xuY29uc3QgUmVjdGFuZ2xlXzEgPSByZXF1aXJlKFwiLi4vZmxhc2gvZ2VvbS9SZWN0YW5nbGVcIik7XG5jb25zdCBUZXh0dXJlXzEgPSByZXF1aXJlKFwiLi9UZXh0dXJlXCIpO1xuY29uc3QgUG9pbnRfMSA9IHJlcXVpcmUoXCIuLi9mbGFzaC9nZW9tL1BvaW50XCIpO1xuY29uc3QgQ2FjaGVTZXR0aW5nc18xID0gcmVxdWlyZShcIi4vQ2FjaGVTZXR0aW5nc1wiKTtcbmNvbnN0IEluc3RhbmNlQ291bnRlcl8xID0gcmVxdWlyZShcIi4vSW5zdGFuY2VDb3VudGVyXCIpO1xuY2xhc3MgVGlsaW5nU3ByaXRlIGV4dGVuZHMgU3ByaXRlXzEuU3ByaXRlIHtcbiAgICBjb25zdHJ1Y3Rvcih0ZXh0dXJlLCB3aWR0aCA9IDEwMCwgaGVpZ2h0ID0gMTAwKSB7XG4gICAgICAgIHN1cGVyKHRleHR1cmUpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX29uVGV4dHVyZVVwZGF0ZSA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLnV2TWF0cml4KSB7XG4gICAgICAgICAgICAgICAgdGhpcy51dk1hdHJpeC50ZXh0dXJlID0gdGhpcy5fdGV4dHVyZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY2FjaGVkVGludCA9IDB4RkZGRkZGO1xuICAgICAgICB9O1xuICAgICAgICBpZiAod2lkdGggPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgd2lkdGggPSAxMDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhlaWdodCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBoZWlnaHQgPSAxMDA7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRpbGUgdHJhbnNmb3JtXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge1BJWEkuVHJhbnNmb3JtfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50aWxlVHJhbnNmb3JtID0gbmV3IFRyYW5zZm9ybV8xLlRyYW5zZm9ybSgpO1xuICAgICAgICAvLyAvLy8gcHJpdmF0ZVxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHdpdGggb2YgdGhlIHRpbGluZyBzcHJpdGVcbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fd2lkdGggPSB3aWR0aDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBoZWlnaHQgb2YgdGhlIHRpbGluZyBzcHJpdGVcbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlciB7bnVtYmVyfVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5faGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2FudmFzIHBhdHRlcm5cbiAgICAgICAgICpcbiAgICAgICAgICogQHR5cGUge0NhbnZhc1BhdHRlcm59XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9jYW52YXNQYXR0ZXJuID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIG1hdHJpeCB0aGF0IGlzIGFwcGxpZWQgdG8gVVYgdG8gZ2V0IHRoZSBjb29yZHMgaW4gVGV4dHVyZSBub3JtYWxpemVkIHNwYWNlIHRvIGNvb3JkcyBpbiBCYXNlVGV4dHVyZSBzcGFjZVxuICAgICAgICAgKlxuICAgICAgICAgKiBAbWVtYmVyIHtQSVhJLlRleHR1cmVNYXRyaXh9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnV2TWF0cml4ID0gdGV4dHVyZS51dk1hdHJpeCB8fCBuZXcgVGV4dHVyZU1hdHJpeF8xLlRleHR1cmVNYXRyaXgodGV4dHVyZSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQbHVnaW4gdGhhdCBpcyByZXNwb25zaWJsZSBmb3IgcmVuZGVyaW5nIHRoaXMgZWxlbWVudC5cbiAgICAgICAgICogQWxsb3dzIHRvIGN1c3RvbWl6ZSB0aGUgcmVuZGVyaW5nIHByb2Nlc3Mgd2l0aG91dCBvdmVycmlkaW5nICdfcmVuZGVyJyBtZXRob2QuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge3N0cmluZ31cbiAgICAgICAgICogQGRlZmF1bHQgJ3RpbGluZ1Nwcml0ZSdcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucGx1Z2luTmFtZSA9ICd0aWxpbmdTcHJpdGUnO1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciBvciBub3QgYW5jaG9yIGFmZmVjdHMgdXZzXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XG4gICAgICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnV2UmVzcGVjdEFuY2hvciA9IGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGFuZ2VzIGZyYW1lIGNsYW1waW5nIGluIGNvcnJlc3BvbmRpbmcgdGV4dHVyZVRyYW5zZm9ybSwgc2hvcnRjdXRcbiAgICAgKiBDaGFuZ2UgdG8gLTAuNSB0byBhZGQgYSBwaXhlbCB0byB0aGUgZWRnZSwgcmVjb21tZW5kZWQgZm9yIHRyYW5zcGFyZW50IHRyaW1tZWQgdGV4dHVyZXMgaW4gYXRsYXNcbiAgICAgKlxuICAgICAqIEBkZWZhdWx0IDAuNVxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgY2xhbXBNYXJnaW4oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnV2TWF0cml4LmNsYW1wTWFyZ2luO1xuICAgIH1cbiAgICA7XG4gICAgc2V0IGNsYW1wTWFyZ2luKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudXZNYXRyaXguY2xhbXBNYXJnaW4gPSB2YWx1ZTtcbiAgICAgICAgdGhpcy51dk1hdHJpeC51cGRhdGUodHJ1ZSk7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBUaGUgc2NhbGluZyBvZiB0aGUgaW1hZ2UgdGhhdCBpcyBiZWluZyB0aWxlZFxuICAgICAqXG4gICAgICogQG1lbWJlciB7UElYSS5PYnNlcnZhYmxlUG9pbnR9XG4gICAgICovXG4gICAgZ2V0IHRpbGVTY2FsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGlsZVRyYW5zZm9ybS5zY2FsZTtcbiAgICB9XG4gICAgO1xuICAgIHNldCB0aWxlU2NhbGUodmFsdWUpIHtcbiAgICAgICAgdGhpcy50aWxlVHJhbnNmb3JtLnNjYWxlLmNvcHlGcm9tKHZhbHVlKTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFRoZSBvZmZzZXQgb2YgdGhlIGltYWdlIHRoYXQgaXMgYmVpbmcgdGlsZWRcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge1BJWEkuT2JzZXJ2YWJsZVBvaW50fVxuICAgICAqL1xuICAgIGdldCB0aWxlUG9zaXRpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRpbGVUcmFuc2Zvcm0ucG9zaXRpb247XG4gICAgfVxuICAgIDtcbiAgICBzZXQgdGlsZVBvc2l0aW9uKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudGlsZVRyYW5zZm9ybS5wb3NpdGlvbi5jb3B5RnJvbSh2YWx1ZSk7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIHRoZSBvYmplY3QgdXNpbmcgdGhlIFdlYkdMIHJlbmRlcmVyXG4gICAgICpcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHBhcmFtIHtQSVhJLlJlbmRlcmVyfSByZW5kZXJlciAtIFRoZSByZW5kZXJlclxuICAgICAqL1xuICAgIF9yZW5kZXIocmVuZGVyZXIpIHtcbiAgICAgICAgLy8gdHdlYWsgb3VyIHRleHR1cmUgdGVtcG9yYXJpbHkuLlxuICAgICAgICB2YXIgdGV4dHVyZSA9IHRoaXMuX3RleHR1cmU7XG4gICAgICAgIGlmICghdGV4dHVyZSB8fCAhdGV4dHVyZS52YWxpZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudGlsZVRyYW5zZm9ybS51cGRhdGVMb2NhbFRyYW5zZm9ybSgpO1xuICAgICAgICB0aGlzLnV2TWF0cml4LnVwZGF0ZSgpO1xuICAgICAgICByZW5kZXJlci5iYXRjaC5zZXRPYmplY3RSZW5kZXJlcihyZW5kZXJlci5wbHVnaW5zW3RoaXMucGx1Z2luTmFtZV0pO1xuICAgICAgICByZW5kZXJlci5wbHVnaW5zW3RoaXMucGx1Z2luTmFtZV0ucmVuZGVyKHRoaXMpO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgYm91bmRzIG9mIHRoZSB0aWxpbmcgc3ByaXRlLlxuICAgICAqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9jYWxjdWxhdGVCb3VuZHMoKSB7XG4gICAgICAgIHZhciBtaW5YID0gdGhpcy5fd2lkdGggKiAtdGhpcy5fYW5jaG9yLng7XG4gICAgICAgIHZhciBtaW5ZID0gdGhpcy5faGVpZ2h0ICogLXRoaXMuX2FuY2hvci55O1xuICAgICAgICB2YXIgbWF4WCA9IHRoaXMuX3dpZHRoICogKDEgLSB0aGlzLl9hbmNob3IueCk7XG4gICAgICAgIHZhciBtYXhZID0gdGhpcy5faGVpZ2h0ICogKDEgLSB0aGlzLl9hbmNob3IueSk7XG4gICAgICAgIHRoaXMuX2JvdW5kcy5hZGRGcmFtZSh0aGlzLnRyYW5zZm9ybSwgbWluWCwgbWluWSwgbWF4WCwgbWF4WSk7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBsb2NhbCBib3VuZHMgb2YgdGhlIHNwcml0ZSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BJWEkuUmVjdGFuZ2xlfSByZWN0IC0gVGhlIG91dHB1dCByZWN0YW5nbGUuXG4gICAgICogQHJldHVybiB7UElYSS5SZWN0YW5nbGV9IFRoZSBib3VuZHMuXG4gICAgICovXG4gICAgZ2V0TG9jYWxCb3VuZHMocmVjdCkge1xuICAgICAgICAvLyB3ZSBjYW4gZG8gYSBmYXN0IGxvY2FsIGJvdW5kcyBpZiB0aGUgc3ByaXRlIGhhcyBubyBjaGlsZHJlbiFcbiAgICAgICAgaWYgKHRoaXMuY2hpbGRyZW4ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLl9ib3VuZHMubWluWCA9IHRoaXMuX3dpZHRoICogLXRoaXMuX2FuY2hvci54O1xuICAgICAgICAgICAgdGhpcy5fYm91bmRzLm1pblkgPSB0aGlzLl9oZWlnaHQgKiAtdGhpcy5fYW5jaG9yLnk7XG4gICAgICAgICAgICB0aGlzLl9ib3VuZHMubWF4WCA9IHRoaXMuX3dpZHRoICogKDEgLSB0aGlzLl9hbmNob3IueCk7XG4gICAgICAgICAgICB0aGlzLl9ib3VuZHMubWF4WSA9IHRoaXMuX2hlaWdodCAqICgxIC0gdGhpcy5fYW5jaG9yLnkpO1xuICAgICAgICAgICAgaWYgKCFyZWN0KSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9sb2NhbEJvdW5kc1JlY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgSW5zdGFuY2VDb3VudGVyXzEuSW5zdGFuY2VDb3VudGVyLmFkZENhbGwoXCJSZWN0YW5nbGUuZ2V0UmVjdGFuZ2xlXCIsIFwiVGlsaW5nU3ByaXRlIGdldExvY2FsQm91bmRzXCIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sb2NhbEJvdW5kc1JlY3QgPSBSZWN0YW5nbGVfMS5SZWN0YW5nbGUuZ2V0UmVjdGFuZ2xlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlY3QgPSB0aGlzLl9sb2NhbEJvdW5kc1JlY3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBJbnN0YW5jZUNvdW50ZXJfMS5JbnN0YW5jZUNvdW50ZXIuYWRkQ2FsbChcIlJlY3RhbmdsZS5nZXRSZWN0YW5nbGVcIiwgXCJUaWxpbmdTcHJpdGUgZ2V0TG9jYWxCb3VuZHNcIik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYm91bmRzLmdldFJlY3RhbmdsZShyZWN0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3VwZXIuZ2V0TG9jYWxCb3VuZHMocmVjdCk7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYSBwb2ludCBpcyBpbnNpZGUgdGhpcyB0aWxpbmcgc3ByaXRlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQSVhJLlBvaW50fSBwb2ludCAtIHRoZSBwb2ludCB0byBjaGVja1xuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgb3Igbm90IHRoZSBzcHJpdGUgY29udGFpbnMgdGhlIHBvaW50LlxuICAgICAqL1xuICAgIGNvbnRhaW5zUG9pbnQocG9pbnQpIHtcbiAgICAgICAgbGV0IGRlZmF1bHRwb2ludCA9IFBvaW50XzEuUG9pbnQuREVGQVVMVDtcbiAgICAgICAgdGhpcy53b3JsZFRyYW5zZm9ybS5hcHBseUludmVyc2UocG9pbnQsIGRlZmF1bHRwb2ludCk7XG4gICAgICAgIHZhciB3aWR0aCA9IHRoaXMuX3dpZHRoO1xuICAgICAgICB2YXIgaGVpZ2h0ID0gdGhpcy5faGVpZ2h0O1xuICAgICAgICB2YXIgeDEgPSAtd2lkdGggKiB0aGlzLmFuY2hvci54O1xuICAgICAgICBpZiAoZGVmYXVsdHBvaW50LnggPj0geDEgJiYgZGVmYXVsdHBvaW50LnggPCB4MSArIHdpZHRoKSB7XG4gICAgICAgICAgICB2YXIgeTEgPSAtaGVpZ2h0ICogdGhpcy5hbmNob3IueTtcbiAgICAgICAgICAgIGlmIChkZWZhdWx0cG9pbnQueSA+PSB5MSAmJiBkZWZhdWx0cG9pbnQueSA8IHkxICsgaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogRGVzdHJveXMgdGhpcyBzcHJpdGUgYW5kIG9wdGlvbmFsbHkgaXRzIHRleHR1cmUgYW5kIGNoaWxkcmVuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdHxib29sZWFufSBbb3B0aW9uc10gLSBPcHRpb25zIHBhcmFtZXRlci4gQSBib29sZWFuIHdpbGwgYWN0IGFzIGlmIGFsbCBvcHRpb25zXG4gICAgICogIGhhdmUgYmVlbiBzZXQgdG8gdGhhdCB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuY2hpbGRyZW49ZmFsc2VdIC0gaWYgc2V0IHRvIHRydWUsIGFsbCB0aGUgY2hpbGRyZW4gd2lsbCBoYXZlIHRoZWlyIGRlc3Ryb3lcbiAgICAgKiAgICAgIG1ldGhvZCBjYWxsZWQgYXMgd2VsbC4gJ29wdGlvbnMnIHdpbGwgYmUgcGFzc2VkIG9uIHRvIHRob3NlIGNhbGxzLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudGV4dHVyZT1mYWxzZV0gLSBTaG91bGQgaXQgZGVzdHJveSB0aGUgY3VycmVudCB0ZXh0dXJlIG9mIHRoZSBzcHJpdGUgYXMgd2VsbFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuYmFzZVRleHR1cmU9ZmFsc2VdIC0gU2hvdWxkIGl0IGRlc3Ryb3kgdGhlIGJhc2UgdGV4dHVyZSBvZiB0aGUgc3ByaXRlIGFzIHdlbGxcbiAgICAgKi9cbiAgICBkZXN0cm95KG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIuZGVzdHJveShvcHRpb25zKTtcbiAgICAgICAgdGhpcy50aWxlVHJhbnNmb3JtID0gbnVsbDtcbiAgICAgICAgdGhpcy51dk1hdHJpeCA9IG51bGw7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBIZWxwZXIgZnVuY3Rpb24gdGhhdCBjcmVhdGVzIGEgbmV3IHRpbGluZyBzcHJpdGUgYmFzZWQgb24gdGhlIHNvdXJjZSB5b3UgcHJvdmlkZS5cbiAgICAgKiBUaGUgc291cmNlIGNhbiBiZSAtIGZyYW1lIGlkLCBpbWFnZSB1cmwsIHZpZGVvIHVybCwgY2FudmFzIGVsZW1lbnQsIHZpZGVvIGVsZW1lbnQsIGJhc2UgdGV4dHVyZVxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ3xQSVhJLlRleHR1cmV8SFRNTENhbnZhc0VsZW1lbnR8SFRNTFZpZGVvRWxlbWVudH0gc291cmNlIC0gU291cmNlIHRvIGNyZWF0ZSB0ZXh0dXJlIGZyb21cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd2lkdGggLSB0aGUgd2lkdGggb2YgdGhlIHRpbGluZyBzcHJpdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IC0gdGhlIGhlaWdodCBvZiB0aGUgdGlsaW5nIHNwcml0ZVxuICAgICAqIEByZXR1cm4ge1BJWEkuVGlsaW5nU3ByaXRlfSBUaGUgbmV3bHkgY3JlYXRlZCB0ZXh0dXJlXG4gICAgICovXG4gICAgLy8gc3RhdGljIGZyb20gIChzb3VyY2UsIHdpZHRoLCBoZWlnaHQpXG4gICAgLy8ge1xuICAgIC8vICAgICByZXR1cm4gbmV3IFRpbGluZ1Nwcml0ZShUZXh0dXJlLmZyb20oc291cmNlKSwgd2lkdGgsIGhlaWdodCk7XG4gICAgLy8gfTtcbiAgICAvKipcbiAgICAgKiBIZWxwZXIgZnVuY3Rpb24gdGhhdCBjcmVhdGVzIGEgdGlsaW5nIHNwcml0ZSB0aGF0IHdpbGwgdXNlIGEgdGV4dHVyZSBmcm9tIHRoZSBUZXh0dXJlQ2FjaGUgYmFzZWQgb24gdGhlIGZyYW1lSWRcbiAgICAgKiBUaGUgZnJhbWUgaWRzIGFyZSBjcmVhdGVkIHdoZW4gYSBUZXh0dXJlIHBhY2tlciBmaWxlIGhhcyBiZWVuIGxvYWRlZFxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBmcmFtZUlkIC0gVGhlIGZyYW1lIElkIG9mIHRoZSB0ZXh0dXJlIGluIHRoZSBjYWNoZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCAtIHRoZSB3aWR0aCBvZiB0aGUgdGlsaW5nIHNwcml0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgLSB0aGUgaGVpZ2h0IG9mIHRoZSB0aWxpbmcgc3ByaXRlXG4gICAgICogQHJldHVybiB7UElYSS5UaWxpbmdTcHJpdGV9IEEgbmV3IFRpbGluZ1Nwcml0ZSB1c2luZyBhIHRleHR1cmUgZnJvbSB0aGUgdGV4dHVyZSBjYWNoZSBtYXRjaGluZyB0aGUgZnJhbWVJZFxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tRnJhbWUoZnJhbWVJZCwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICB2YXIgdGV4dHVyZSA9IENhY2hlU2V0dGluZ3NfMS5DYWNoZVNldHRpbmdzLlRleHR1cmVDYWNoZVtmcmFtZUlkXTtcbiAgICAgICAgaWYgKCF0ZXh0dXJlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKFwiVGhlIGZyYW1lSWQgXFxcIlwiICsgZnJhbWVJZCArIFwiXFxcIiBkb2VzIG5vdCBleGlzdCBpbiB0aGUgdGV4dHVyZSBjYWNoZSBcIiArICh0aGlzKSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgVGlsaW5nU3ByaXRlKHRleHR1cmUsIHdpZHRoLCBoZWlnaHQpO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogSGVscGVyIGZ1bmN0aW9uIHRoYXQgY3JlYXRlcyBhIHNwcml0ZSB0aGF0IHdpbGwgY29udGFpbiBhIHRleHR1cmUgYmFzZWQgb24gYW4gaW1hZ2UgdXJsXG4gICAgICogSWYgdGhlIGltYWdlIGlzIG5vdCBpbiB0aGUgdGV4dHVyZSBjYWNoZSBpdCB3aWxsIGJlIGxvYWRlZFxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpbWFnZUlkIC0gVGhlIGltYWdlIHVybCBvZiB0aGUgdGV4dHVyZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCAtIHRoZSB3aWR0aCBvZiB0aGUgdGlsaW5nIHNwcml0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgLSB0aGUgaGVpZ2h0IG9mIHRoZSB0aWxpbmcgc3ByaXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIFNlZSB7QGxpbmsgUElYSS5CYXNlVGV4dHVyZX0ncyBjb25zdHJ1Y3RvciBmb3Igb3B0aW9ucy5cbiAgICAgKiBAcmV0dXJuIHtQSVhJLlRpbGluZ1Nwcml0ZX0gQSBuZXcgVGlsaW5nU3ByaXRlIHVzaW5nIGEgdGV4dHVyZSBmcm9tIHRoZSB0ZXh0dXJlIGNhY2hlIG1hdGNoaW5nIHRoZSBpbWFnZSBpZFxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tSW1hZ2UoaW1hZ2VJZCwgd2lkdGgsIGhlaWdodCwgb3B0aW9ucykge1xuICAgICAgICAvLyBGYWxsYmFjayBzdXBwb3J0IGZvciBjcm9zc29yaWdpbiwgc2NhbGVNb2RlIHBhcmFtZXRlcnNcbiAgICAgICAgaWYgKG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBvcHRpb25zID0ge1xuICAgICAgICAgICAgICAgIHNjYWxlTW9kZTogYXJndW1lbnRzWzRdLFxuICAgICAgICAgICAgICAgIHJlc291cmNlT3B0aW9uczoge1xuICAgICAgICAgICAgICAgICAgICBjcm9zc29yaWdpbjogYXJndW1lbnRzWzNdLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgVGlsaW5nU3ByaXRlKFRleHR1cmVfMS5UZXh0dXJlLmZyb20oaW1hZ2VJZCwgb3B0aW9ucyksIHdpZHRoLCBoZWlnaHQpO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogVGhlIHdpZHRoIG9mIHRoZSBzcHJpdGUsIHNldHRpbmcgdGhpcyB3aWxsIGFjdHVhbGx5IG1vZGlmeSB0aGUgc2NhbGUgdG8gYWNoaWV2ZSB0aGUgdmFsdWUgc2V0XG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICovXG4gICAgZ2V0IHdpZHRoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd2lkdGg7XG4gICAgfVxuICAgIDtcbiAgICBzZXQgd2lkdGgodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fd2lkdGggPSB2YWx1ZTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFRoZSBoZWlnaHQgb2YgdGhlIFRpbGluZ1Nwcml0ZSwgc2V0dGluZyB0aGlzIHdpbGwgYWN0dWFsbHkgbW9kaWZ5IHRoZSBzY2FsZSB0byBhY2hpZXZlIHRoZSB2YWx1ZSBzZXRcbiAgICAgKlxuICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXQgaGVpZ2h0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faGVpZ2h0O1xuICAgIH1cbiAgICA7XG4gICAgc2V0IGhlaWdodCh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9oZWlnaHQgPSB2YWx1ZTtcbiAgICB9XG4gICAgO1xufVxuZXhwb3J0cy5UaWxpbmdTcHJpdGUgPSBUaWxpbmdTcHJpdGU7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IE9iamVjdFJlbmRlcmVyXzEgPSByZXF1aXJlKFwiLi9PYmplY3RSZW5kZXJlclwiKTtcbmNvbnN0IFNoYWRlcl8xID0gcmVxdWlyZShcIi4vU2hhZGVyXCIpO1xuY29uc3QgUXVhZFV2XzEgPSByZXF1aXJlKFwiLi9RdWFkVXZcIik7XG5jb25zdCBNYXRyaXhfMSA9IHJlcXVpcmUoXCIuL01hdHJpeFwiKTtcbmNvbnN0IFdlYkdMU2V0dGluZ3NfMSA9IHJlcXVpcmUoXCIuL1dlYkdMU2V0dGluZ3NcIik7XG5jb25zdCBDb2xvclNldHRpbmdzXzEgPSByZXF1aXJlKFwiLi9Db2xvclNldHRpbmdzXCIpO1xuY29uc3QgQmxlbmRNb2Rlc1NldHRpbmdzXzEgPSByZXF1aXJlKFwiLi9CbGVuZE1vZGVzU2V0dGluZ3NcIik7XG5jbGFzcyBUaWxpbmdTcHJpdGVSZW5kZXJlciBleHRlbmRzIE9iamVjdFJlbmRlcmVyXzEuT2JqZWN0UmVuZGVyZXIge1xuICAgIGNvbnN0cnVjdG9yKHJlbmRlcmVyKSB7XG4gICAgICAgIHN1cGVyKHJlbmRlcmVyKTtcbiAgICAgICAgdmFyIHVuaWZvcm1zID0geyBnbG9iYWxzOiB0aGlzLnJlbmRlcmVyLmdsb2JhbFVuaWZvcm1zIH07XG4gICAgICAgIHRoaXMuc2hhZGVyID0gU2hhZGVyXzEuU2hhZGVyLmZyb20oVGlsaW5nU3ByaXRlUmVuZGVyZXIudmVydGV4JDMsIFRpbGluZ1Nwcml0ZVJlbmRlcmVyLmZyYWdtZW50JDIsIHVuaWZvcm1zKTtcbiAgICAgICAgdGhpcy5zaW1wbGVTaGFkZXIgPSBTaGFkZXJfMS5TaGFkZXIuZnJvbShUaWxpbmdTcHJpdGVSZW5kZXJlci52ZXJ0ZXgkMywgVGlsaW5nU3ByaXRlUmVuZGVyZXIuZnJhZ21lbnRTaW1wbGUsIHVuaWZvcm1zKTtcbiAgICAgICAgdGhpcy5xdWFkID0gbmV3IFF1YWRVdl8xLlF1YWRVdigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UElYSS5UaWxpbmdTcHJpdGV9IHRzIHRpbGluZ1Nwcml0ZSB0byBiZSByZW5kZXJlZFxuICAgICAqL1xuICAgIHJlbmRlcih0cykge1xuICAgICAgICB2YXIgcmVuZGVyZXIgPSB0aGlzLnJlbmRlcmVyO1xuICAgICAgICB2YXIgcXVhZCA9IHRoaXMucXVhZDtcbiAgICAgICAgdmFyIHZlcnRpY2VzID0gcXVhZC52ZXJ0aWNlcztcbiAgICAgICAgdmVydGljZXNbMF0gPSB2ZXJ0aWNlc1s2XSA9ICh0cy5fd2lkdGgpICogLXRzLmFuY2hvci54O1xuICAgICAgICB2ZXJ0aWNlc1sxXSA9IHZlcnRpY2VzWzNdID0gdHMuX2hlaWdodCAqIC10cy5hbmNob3IueTtcbiAgICAgICAgdmVydGljZXNbMl0gPSB2ZXJ0aWNlc1s0XSA9ICh0cy5fd2lkdGgpICogKDEuMCAtIHRzLmFuY2hvci54KTtcbiAgICAgICAgdmVydGljZXNbNV0gPSB2ZXJ0aWNlc1s3XSA9IHRzLl9oZWlnaHQgKiAoMS4wIC0gdHMuYW5jaG9yLnkpO1xuICAgICAgICBpZiAodHMudXZSZXNwZWN0QW5jaG9yKSB7XG4gICAgICAgICAgICB2ZXJ0aWNlcyA9IHF1YWQudXZzO1xuICAgICAgICAgICAgdmVydGljZXNbMF0gPSB2ZXJ0aWNlc1s2XSA9IC10cy5hbmNob3IueDtcbiAgICAgICAgICAgIHZlcnRpY2VzWzFdID0gdmVydGljZXNbM10gPSAtdHMuYW5jaG9yLnk7XG4gICAgICAgICAgICB2ZXJ0aWNlc1syXSA9IHZlcnRpY2VzWzRdID0gMS4wIC0gdHMuYW5jaG9yLng7XG4gICAgICAgICAgICB2ZXJ0aWNlc1s1XSA9IHZlcnRpY2VzWzddID0gMS4wIC0gdHMuYW5jaG9yLnk7XG4gICAgICAgIH1cbiAgICAgICAgcXVhZC5pbnZhbGlkYXRlKCk7XG4gICAgICAgIHZhciB0ZXggPSB0cy5fdGV4dHVyZTtcbiAgICAgICAgdmFyIGJhc2VUZXggPSB0ZXguYmFzZVRleHR1cmU7XG4gICAgICAgIHZhciBsdCA9IHRzLnRpbGVUcmFuc2Zvcm0ubG9jYWxUcmFuc2Zvcm07XG4gICAgICAgIHZhciB1diA9IHRzLnV2TWF0cml4O1xuICAgICAgICB2YXIgaXNTaW1wbGUgPSBiYXNlVGV4LmlzUG93ZXJPZlR3b1xuICAgICAgICAgICAgJiYgdGV4LmZyYW1lLndpZHRoID09PSBiYXNlVGV4LndpZHRoICYmIHRleC5mcmFtZS5oZWlnaHQgPT09IGJhc2VUZXguaGVpZ2h0O1xuICAgICAgICAvLyBhdXRvLCBmb3JjZSByZXBlYXQgd3JhcE1vZGUgZm9yIGJpZyB0aWxpbmcgdGV4dHVyZXNcbiAgICAgICAgaWYgKGlzU2ltcGxlKSB7XG4gICAgICAgICAgICBpZiAoIWJhc2VUZXguX2dsVGV4dHVyZXNbcmVuZGVyZXIuQ09OVEVYVF9VSURdKSB7XG4gICAgICAgICAgICAgICAgaWYgKGJhc2VUZXgud3JhcE1vZGUgPT09IFdlYkdMU2V0dGluZ3NfMS5XZWJHTFNldHRpbmdzLldSQVBfTU9ERVMuQ0xBTVApIHtcbiAgICAgICAgICAgICAgICAgICAgYmFzZVRleC53cmFwTW9kZSA9IFdlYkdMU2V0dGluZ3NfMS5XZWJHTFNldHRpbmdzLldSQVBfTU9ERVMuUkVQRUFUO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlzU2ltcGxlID0gYmFzZVRleC53cmFwTW9kZSAhPT0gV2ViR0xTZXR0aW5nc18xLldlYkdMU2V0dGluZ3MuV1JBUF9NT0RFUy5DTEFNUDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgc2hhZGVyID0gaXNTaW1wbGUgPyB0aGlzLnNpbXBsZVNoYWRlciA6IHRoaXMuc2hhZGVyO1xuICAgICAgICB2YXIgdyA9IHRleC53aWR0aDtcbiAgICAgICAgdmFyIGggPSB0ZXguaGVpZ2h0O1xuICAgICAgICB2YXIgVyA9IHRzLl93aWR0aDtcbiAgICAgICAgdmFyIEggPSB0cy5faGVpZ2h0O1xuICAgICAgICBUaWxpbmdTcHJpdGVSZW5kZXJlci50ZW1wTWF0JDEuc2V0KGx0LmEgKiB3IC8gVywgbHQuYiAqIHcgLyBILCBsdC5jICogaCAvIFcsIGx0LmQgKiBoIC8gSCwgbHQudHggLyBXLCBsdC50eSAvIEgpO1xuICAgICAgICAvLyB0aGF0IHBhcnQgaXMgdGhlIHNhbWUgYXMgYWJvdmU6XG4gICAgICAgIC8vIHRlbXBNYXQuaWRlbnRpdHkoKTtcbiAgICAgICAgLy8gdGVtcE1hdC5zY2FsZSh0ZXgud2lkdGgsIHRleC5oZWlnaHQpO1xuICAgICAgICAvLyB0ZW1wTWF0LnByZXBlbmQobHQpO1xuICAgICAgICAvLyB0ZW1wTWF0LnNjYWxlKDEuMCAvIHRzLl93aWR0aCwgMS4wIC8gdHMuX2hlaWdodCk7XG4gICAgICAgIFRpbGluZ1Nwcml0ZVJlbmRlcmVyLnRlbXBNYXQkMS5pbnZlcnQoKTtcbiAgICAgICAgaWYgKGlzU2ltcGxlKSB7XG4gICAgICAgICAgICBUaWxpbmdTcHJpdGVSZW5kZXJlci50ZW1wTWF0JDEucHJlcGVuZCh1di5tYXBDb29yZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzaGFkZXIudW5pZm9ybXMudU1hcENvb3JkID0gdXYubWFwQ29vcmQudG9BcnJheSh0cnVlKTtcbiAgICAgICAgICAgIHNoYWRlci51bmlmb3Jtcy51Q2xhbXBGcmFtZSA9IHV2LnVDbGFtcEZyYW1lO1xuICAgICAgICAgICAgc2hhZGVyLnVuaWZvcm1zLnVDbGFtcE9mZnNldCA9IHV2LnVDbGFtcE9mZnNldDtcbiAgICAgICAgfVxuICAgICAgICBzaGFkZXIudW5pZm9ybXMudVRyYW5zZm9ybSA9IFRpbGluZ1Nwcml0ZVJlbmRlcmVyLnRlbXBNYXQkMS50b0FycmF5KHRydWUpO1xuICAgICAgICBzaGFkZXIudW5pZm9ybXMudUNvbG9yID0gQ29sb3JTZXR0aW5nc18xLkNvbG9yU2V0dGluZ3MucHJlbXVsdGlwbHlUaW50VG9SZ2JhKHRzLnRpbnQsIHRzLndvcmxkQWxwaGEsIHNoYWRlci51bmlmb3Jtcy51Q29sb3IsIGJhc2VUZXgucHJlbXVsdGlwbHlBbHBoYSk7XG4gICAgICAgIHNoYWRlci51bmlmb3Jtcy50cmFuc2xhdGlvbk1hdHJpeCA9IHRzLnRyYW5zZm9ybS53b3JsZFRyYW5zZm9ybS50b0FycmF5KHRydWUpO1xuICAgICAgICBzaGFkZXIudW5pZm9ybXMudVNhbXBsZXIgPSB0ZXg7XG4gICAgICAgIHJlbmRlcmVyLnNoYWRlci5iaW5kKHNoYWRlcik7XG4gICAgICAgIHJlbmRlcmVyLmdlb21ldHJ5LmJpbmQocXVhZCk7IC8vICwgcmVuZGVyZXIuc2hhZGVyLmdldEdMU2hhZGVyKCkpO1xuICAgICAgICByZW5kZXJlci5zdGF0ZS5zZXRCbGVuZE1vZGUoQmxlbmRNb2Rlc1NldHRpbmdzXzEuQmxlbmRNb2Rlc1NldHRpbmdzLmNvcnJlY3RCbGVuZE1vZGUodHMuYmxlbmRNb2RlLCBiYXNlVGV4LnByZW11bHRpcGx5QWxwaGEpKTtcbiAgICAgICAgcmVuZGVyZXIuZ2VvbWV0cnkuZHJhdyh0aGlzLnJlbmRlcmVyLmdsLlRSSUFOR0xFUywgNiwgMCk7XG4gICAgfVxuICAgIDtcbn1cblRpbGluZ1Nwcml0ZVJlbmRlcmVyLmZyYWdtZW50U2ltcGxlID0gXCJ2YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXHJcXG5cXHJcXG51bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjtcXHJcXG51bmlmb3JtIHZlYzQgdUNvbG9yO1xcclxcblxcclxcbnZvaWQgbWFpbih2b2lkKVxcclxcbntcXHJcXG4gICAgdmVjNCBzYW1wbGUgPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZUZXh0dXJlQ29vcmQpO1xcclxcbiAgICBnbF9GcmFnQ29sb3IgPSBzYW1wbGUgKiB1Q29sb3I7XFxyXFxufVxcclxcblwiO1xuVGlsaW5nU3ByaXRlUmVuZGVyZXIuZnJhZ21lbnQkMiA9IFwidmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XFxyXFxuXFxyXFxudW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXI7XFxyXFxudW5pZm9ybSB2ZWM0IHVDb2xvcjtcXHJcXG51bmlmb3JtIG1hdDMgdU1hcENvb3JkO1xcclxcbnVuaWZvcm0gdmVjNCB1Q2xhbXBGcmFtZTtcXHJcXG51bmlmb3JtIHZlYzIgdUNsYW1wT2Zmc2V0O1xcclxcblxcclxcbnZvaWQgbWFpbih2b2lkKVxcclxcbntcXHJcXG4gICAgdmVjMiBjb29yZCA9IG1vZCh2VGV4dHVyZUNvb3JkIC0gdUNsYW1wT2Zmc2V0LCB2ZWMyKDEuMCwgMS4wKSkgKyB1Q2xhbXBPZmZzZXQ7XFxyXFxuICAgIGNvb3JkID0gKHVNYXBDb29yZCAqIHZlYzMoY29vcmQsIDEuMCkpLnh5O1xcclxcbiAgICBjb29yZCA9IGNsYW1wKGNvb3JkLCB1Q2xhbXBGcmFtZS54eSwgdUNsYW1wRnJhbWUuencpO1xcclxcblxcclxcbiAgICB2ZWM0IHNhbXBsZSA9IHRleHR1cmUyRCh1U2FtcGxlciwgY29vcmQpO1xcclxcbiAgICBnbF9GcmFnQ29sb3IgPSBzYW1wbGUgKiB1Q29sb3I7XFxyXFxufVxcclxcblwiO1xuVGlsaW5nU3ByaXRlUmVuZGVyZXIudmVydGV4JDMgPSBcImF0dHJpYnV0ZSB2ZWMyIGFWZXJ0ZXhQb3NpdGlvbjtcXHJcXG5hdHRyaWJ1dGUgdmVjMiBhVGV4dHVyZUNvb3JkO1xcclxcblxcclxcbnVuaWZvcm0gbWF0MyBwcm9qZWN0aW9uTWF0cml4O1xcclxcbnVuaWZvcm0gbWF0MyB0cmFuc2xhdGlvbk1hdHJpeDtcXHJcXG51bmlmb3JtIG1hdDMgdVRyYW5zZm9ybTtcXHJcXG5cXHJcXG52YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXHJcXG5cXHJcXG52b2lkIG1haW4odm9pZClcXHJcXG57XFxyXFxuICAgIGdsX1Bvc2l0aW9uID0gdmVjNCgocHJvamVjdGlvbk1hdHJpeCAqIHRyYW5zbGF0aW9uTWF0cml4ICogdmVjMyhhVmVydGV4UG9zaXRpb24sIDEuMCkpLnh5LCAwLjAsIDEuMCk7XFxyXFxuXFxyXFxuICAgIHZUZXh0dXJlQ29vcmQgPSAodVRyYW5zZm9ybSAqIHZlYzMoYVRleHR1cmVDb29yZCwgMS4wKSkueHk7XFxyXFxufVxcclxcblwiO1xuVGlsaW5nU3ByaXRlUmVuZGVyZXIudGVtcE1hdCQxID0gbmV3IE1hdHJpeF8xLk1hdHJpeCgpO1xuZXhwb3J0cy5UaWxpbmdTcHJpdGVSZW5kZXJlciA9IFRpbGluZ1Nwcml0ZVJlbmRlcmVyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBJT0Vycm9yRXZlbnRfMSA9IHJlcXVpcmUoXCIuL0lPRXJyb3JFdmVudFwiKTtcbmNvbnN0IEV2ZW50RGlzcGF0Y2hlcl8xID0gcmVxdWlyZShcIi4vRXZlbnREaXNwYXRjaGVyXCIpO1xuY29uc3QgRXZlbnRfMSA9IHJlcXVpcmUoXCIuL0V2ZW50XCIpO1xuY2xhc3MgVVJMTG9hZGVyIGV4dGVuZHMgRXZlbnREaXNwYXRjaGVyXzEuRXZlbnREaXNwYXRjaGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5vbkh0dHBSZXNwb25zZSA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLnhtbGh0dHAucmVhZHlTdGF0ZSA9PSA0ICYmIHRoaXMueG1saHR0cC5zdGF0dXMgPT0gMjAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGF0YSA9IHRoaXMueG1saHR0cC5yZXNwb25zZVRleHQ7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KEV2ZW50XzEuRXZlbnQuZ2V0RXZlbnQoRXZlbnRfMS5FdmVudC5DT01QTEVURSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy54bWxodHRwLnJlYWR5U3RhdGUgPT0gNCAmJiB0aGlzLnhtbGh0dHAuc3RhdHVzID09IDAgJiYgdGhpcy54bWxodHRwLnJlc3BvbnNlVGV4dCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2RhdGEgPSB0aGlzLnhtbGh0dHAucmVzcG9uc2VUZXh0O1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChFdmVudF8xLkV2ZW50LmdldEV2ZW50KEV2ZW50XzEuRXZlbnQuQ09NUExFVEUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMueG1saHR0cC5yZWFkeVN0YXRlID09IDQgJiYgdGhpcy54bWxodHRwLnN0YXR1cyA9PSA0MDQpIHtcbiAgICAgICAgICAgICAgICB2YXIgZXJyb3JldmVudCA9IG5ldyBJT0Vycm9yRXZlbnRfMS5JT0Vycm9yRXZlbnQoSU9FcnJvckV2ZW50XzEuSU9FcnJvckV2ZW50LklPX0VSUk9SKTtcbiAgICAgICAgICAgICAgICBlcnJvcmV2ZW50LnRleHQgPSBcIkNvdWxkIG5vdCBmaW5kIGZpbGUgXCIgKyB0aGlzLnJlcXVlc3QudXJsO1xuICAgICAgICAgICAgICAgIGVycm9yZXZlbnQuZXJyb3JJZCA9IDQwNDtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZXJyb3JldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLnhtbGh0dHAucmVhZHlTdGF0ZSA9PSA0ICYmIHRoaXMueG1saHR0cC5zdGF0dXMgPT0gNDAzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVycm9yZXZlbnQgPSBuZXcgSU9FcnJvckV2ZW50XzEuSU9FcnJvckV2ZW50KElPRXJyb3JFdmVudF8xLklPRXJyb3JFdmVudC5JT19FUlJPUik7XG4gICAgICAgICAgICAgICAgZXJyb3JldmVudC50ZXh0ID0gXCJDcm9zcyBPcmlnaW4gRXJyb3IgXCIgKyB0aGlzLnJlcXVlc3QudXJsO1xuICAgICAgICAgICAgICAgIGVycm9yZXZlbnQuZXJyb3JJZCA9IDQwMztcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZXJyb3JldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLnhtbGh0dHAucmVhZHlTdGF0ZSA9PSA0ICYmIHRoaXMueG1saHR0cC5zdGF0dXMgIT0gMjAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVycm9yZXZlbnQgPSBuZXcgSU9FcnJvckV2ZW50XzEuSU9FcnJvckV2ZW50KElPRXJyb3JFdmVudF8xLklPRXJyb3JFdmVudC5JT19FUlJPUik7XG4gICAgICAgICAgICAgICAgZXJyb3JldmVudC50ZXh0ID0gXCJVbmtvd24gRXJyb3IgXCIgKyB0aGlzLnJlcXVlc3QudXJsO1xuICAgICAgICAgICAgICAgIGVycm9yZXZlbnQuZXJyb3JJZCA9IHRoaXMueG1saHR0cC5zdGF0dXM7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGVycm9yZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnhtbGh0dHAgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICB9XG4gICAgZGVzdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIuZGVzdHJ1Y3RvcigpO1xuICAgICAgICBpZiAodGhpcy54bWxodHRwKSB7XG4gICAgICAgICAgICB0aGlzLnhtbGh0dHAub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnhtbGh0dHAgPSBudWxsO1xuICAgICAgICBpZiAodGhpcy5yZXF1ZXN0KSB7XG4gICAgICAgICAgICB0aGlzLnJlcXVlc3QuZGVzdHJ1Y3RvcigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVxdWVzdCA9IG51bGw7XG4gICAgICAgIHRoaXMuX2RhdGEgPSBudWxsO1xuICAgIH1cbiAgICBnZXQgdXJsKCkge1xuICAgICAgICBpZiAodGhpcy5yZXF1ZXN0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0LnVybDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZ2V0IGRhdGEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kYXRhO1xuICAgIH1cbiAgICBzZXQgZGF0YSh2YWx1ZSkge1xuICAgIH1cbiAgICBjbG9zZSgpIHtcbiAgICB9XG4gICAgbG9hZCh2YWx1ZSkge1xuICAgICAgICB0aGlzLnJlcXVlc3QgPSB2YWx1ZTtcbiAgICAgICAgdmFyIHBhdGggPSB0aGlzLnJlcXVlc3QudXJsO1xuICAgICAgICBpZiAoIXBhdGgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5yZXF1ZXN0LmRhdGEpIHtcbiAgICAgICAgICAgIHZhciBwYXJhbXMgPSAnJztcbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiB0aGlzLnJlcXVlc3QuZGF0YSkge1xuICAgICAgICAgICAgICAgIHBhcmFtcyArPSBrZXkgKyBcIj1cIiArIHRoaXMucmVxdWVzdC5kYXRhW2tleV0gKyBcIiZcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhcmFtcyA9IHBhcmFtcy5zdWJzdHIoMCwgcGFyYW1zLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgcGF0aCArPSBcIj9cIiArIHBhcmFtcztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnhtbGh0dHAub3Blbih0aGlzLnJlcXVlc3QubWV0aG9kLCBwYXRoLCB0cnVlKTtcbiAgICAgICAgdGhpcy54bWxodHRwLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IHRoaXMub25IdHRwUmVzcG9uc2U7XG4gICAgICAgIGlmIChwYXRoLmluZGV4T2YoXCIuanNvblwiKSA8IDApIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlcXVlc3QuY29udGVudFR5cGUgIT0gJ2pzb24nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy54bWxodHRwLnNldFJlcXVlc3RIZWFkZXIoJ0NvbnRlbnQtVHlwZScsICd0ZXh0L3htbCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnJlcXVlc3QuZW52ZWxvcCkge1xuICAgICAgICAgICAgdGhpcy54bWxodHRwLnNlbmQodGhpcy5yZXF1ZXN0LmVudmVsb3ApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy54bWxodHRwLnNlbmQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgZGF0YUZvcm1hdCgpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHNldCBkYXRhRm9ybWF0KHZhbHVlKSB7XG4gICAgfVxufVxuZXhwb3J0cy5VUkxMb2FkZXIgPSBVUkxMb2FkZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IFVSTFJlcXVlc3RNZXRob2RfMSA9IHJlcXVpcmUoXCIuL1VSTFJlcXVlc3RNZXRob2RcIik7XG5jb25zdCBGbGFzaEJhc2VPYmplY3RfMSA9IHJlcXVpcmUoXCIuL0ZsYXNoQmFzZU9iamVjdFwiKTtcbmNsYXNzIFVSTFJlcXVlc3QgZXh0ZW5kcyBGbGFzaEJhc2VPYmplY3RfMS5GbGFzaEJhc2VPYmplY3Qge1xuICAgIGNvbnN0cnVjdG9yKHBhdGggPSBudWxsKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuX3JlcXVlc3RNZXRhRGF0YSA9IG5ldyBSZXF1ZXN0TWV0YURhdGEoKTtcbiAgICAgICAgdGhpcy5fdGltZW91dCA9IDA7XG4gICAgICAgIHRoaXMuX2Nyb3NzT3JpZ2luID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5yZXNldChwYXRoKTtcbiAgICB9XG4gICAgZGVzdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5fdXJsID0gbnVsbDtcbiAgICAgICAgdGhpcy5fbWV0aG9kID0gVVJMUmVxdWVzdE1ldGhvZF8xLlVSTFJlcXVlc3RNZXRob2QuUE9TVDtcbiAgICAgICAgbGV0IGluZGV4ID0gVVJMUmVxdWVzdC5VUkxSZXF1ZXN0Q2FjaGUuaW5kZXhPZih0aGlzKTtcbiAgICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICAgICAgVVJMUmVxdWVzdC5VUkxSZXF1ZXN0Q2FjaGUucHVzaCh0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXNldChwYXRoID0gbnVsbCkge1xuICAgICAgICB0aGlzLl91cmwgPSBwYXRoO1xuICAgICAgICB0aGlzLl9tZXRob2QgPSBVUkxSZXF1ZXN0TWV0aG9kXzEuVVJMUmVxdWVzdE1ldGhvZC5QT1NUO1xuICAgICAgICB0aGlzLl9jb250ZW50VHlwZSA9IG51bGw7XG4gICAgICAgIHRoaXMuX2VudmVsb3AgPSBudWxsO1xuICAgICAgICB0aGlzLl9kYXRhID0gbnVsbDtcbiAgICB9XG4gICAgc3RhdGljIGdldFVSTFJlcXVlc3QocGF0aCA9IG51bGwpIHtcbiAgICAgICAgaWYgKFVSTFJlcXVlc3QuVVJMUmVxdWVzdENhY2hlLmxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IHVyID0gVVJMUmVxdWVzdC5VUkxSZXF1ZXN0Q2FjaGVbVVJMUmVxdWVzdC5VUkxSZXF1ZXN0Q2FjaGUubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBVUkxSZXF1ZXN0LlVSTFJlcXVlc3RDYWNoZS5sZW5ndGggLT0gMTtcbiAgICAgICAgICAgIHVyLnJlc2V0KHBhdGgpO1xuICAgICAgICAgICAgcmV0dXJuIHVyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgVVJMUmVxdWVzdChwYXRoKTtcbiAgICB9XG4gICAgc2V0IHJlcXVlc3RNZXRhRGF0YSh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9yZXF1ZXN0TWV0YURhdGEgPSB2YWx1ZTtcbiAgICB9XG4gICAgZ2V0IHJlcXVlc3RNZXRhRGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlcXVlc3RNZXRhRGF0YTtcbiAgICB9XG4gICAgc2V0IHRpbWVvdXQodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fdGltZW91dCA9IHZhbHVlO1xuICAgIH1cbiAgICBnZXQgdGltZW91dCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RpbWVvdXQ7XG4gICAgfVxuICAgIHNldCBjcm9zc09yaWdpbih2YWx1ZSkge1xuICAgICAgICB0aGlzLl9jcm9zc09yaWdpbiA9IHZhbHVlO1xuICAgIH1cbiAgICBnZXQgY3Jvc3NPcmlnaW4oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jcm9zc09yaWdpbjtcbiAgICB9XG4gICAgc2V0IGVudmVsb3AodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fZW52ZWxvcCA9IHZhbHVlO1xuICAgIH1cbiAgICBnZXQgZW52ZWxvcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VudmVsb3A7XG4gICAgfVxuICAgIGdldCByZXF1ZXN0SGVhZGVycygpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHNldCByZXF1ZXN0SGVhZGVycyh2YWx1ZSkge1xuICAgIH1cbiAgICBnZXQgY29udGVudFR5cGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb250ZW50VHlwZTtcbiAgICB9XG4gICAgc2V0IGNvbnRlbnRUeXBlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2NvbnRlbnRUeXBlID0gdmFsdWU7XG4gICAgfVxuICAgIGdldCB1cmwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl91cmw7XG4gICAgfVxuICAgIHNldCB1cmwodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fdXJsID0gdmFsdWU7XG4gICAgfVxuICAgIHNldCBkYXRhKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2RhdGEgPSB2YWx1ZTtcbiAgICB9XG4gICAgZ2V0IGRhdGEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kYXRhO1xuICAgIH1cbiAgICBnZXQgbWV0aG9kKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWV0aG9kO1xuICAgIH1cbiAgICBzZXQgbWV0aG9kKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX21ldGhvZCA9IHZhbHVlO1xuICAgIH1cbn1cblVSTFJlcXVlc3QuVVJMUmVxdWVzdENhY2hlID0gW107XG5leHBvcnRzLlVSTFJlcXVlc3QgPSBVUkxSZXF1ZXN0O1xuY2xhc3MgUmVxdWVzdE1ldGFEYXRhIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5taW1lVHlwZSA9ICcnO1xuICAgICAgICB0aGlzLnNraXBTb3VyY2UgPSBmYWxzZTtcbiAgICB9XG59XG5leHBvcnRzLlJlcXVlc3RNZXRhRGF0YSA9IFJlcXVlc3RNZXRhRGF0YTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY2xhc3MgVVJMUmVxdWVzdE1ldGhvZCB7XG59XG5VUkxSZXF1ZXN0TWV0aG9kLkdFVCA9IFwiR0VUXCI7XG5VUkxSZXF1ZXN0TWV0aG9kLlBPU1QgPSBcIlBPU1RcIjtcbmV4cG9ydHMuVVJMUmVxdWVzdE1ldGhvZCA9IFVSTFJlcXVlc3RNZXRob2Q7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNsYXNzIFVuaWZvcm1Hcm91cCB7XG4gICAgY29uc3RydWN0b3IodW5pZm9ybXMgPSBudWxsLCBfc3RhdGljID0gbnVsbCkge1xuICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiB1bmlmb3JtIHZhbHVlc1xuICAgICAgICAgICAgICAgICAqIEBtZW1iZXIge29iamVjdH1cbiAgICAgICAgICAgICAgICAgKiBAcmVhZG9ubHlcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgdGhpcy51bmlmb3JtcyA9IHVuaWZvcm1zO1xuICAgICAgICAvKipcbiAgICAgICAgICogSXRzIGEgZ3JvdXAgYW5kIG5vdCBhIHNpbmdsZSB1bmlmb3Jtc1xuICAgICAgICAgKiBAbWVtYmVyIHtib29sZWFufVxuICAgICAgICAgKiBAcmVhZG9ubHlcbiAgICAgICAgICogQGRlZmF1bHQgdHJ1ZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5ncm91cCA9IHRydWU7XG4gICAgICAgIC8vIGxldHMgZ2VuZXJhdGUgdGhpcyB3aGVuIHRoZSBzaGFkZXIgP1xuICAgICAgICB0aGlzLnN5bmNVbmlmb3JtcyA9IHt9O1xuICAgICAgICAvKipcbiAgICAgICAgICogZGlydHkgdmVyc2lvblxuICAgICAgICAgKiBAcHJvdGVjdGVkXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGlydHlJZCA9IDA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiB1bmlxdWUgaWRcbiAgICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmlkID0gVW5pZm9ybUdyb3VwLlVJRCQyKys7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVbmlmb3JtcyB3b250IGJlIGNoYW5nZWQgYWZ0ZXIgY3JlYXRpb25cbiAgICAgICAgICogQG1lbWJlciB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3RhdGljID0gISFfc3RhdGljO1xuICAgIH1cbiAgICB1cGRhdGUoKSB7XG4gICAgICAgIHRoaXMuZGlydHlJZCsrO1xuICAgIH1cbiAgICA7XG4gICAgYWRkKG5hbWUsIHVuaWZvcm1zLCBfc3RhdGljKSB7XG4gICAgICAgIHRoaXMudW5pZm9ybXNbbmFtZV0gPSBuZXcgVW5pZm9ybUdyb3VwKHVuaWZvcm1zLCBfc3RhdGljKTtcbiAgICB9XG4gICAgO1xuICAgIHN0YXRpYyBmcm9tKHVuaWZvcm1zLCBfc3RhdGljKSB7XG4gICAgICAgIHJldHVybiBuZXcgVW5pZm9ybUdyb3VwKHVuaWZvcm1zLCBfc3RhdGljKTtcbiAgICB9XG4gICAgO1xufVxuVW5pZm9ybUdyb3VwLlVJRCQyID0gMDtcbmV4cG9ydHMuVW5pZm9ybUdyb3VwID0gVW5pZm9ybUdyb3VwO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBVdGlsc1NldHRpbmdzXzEgPSByZXF1aXJlKFwiLi9VdGlsc1NldHRpbmdzXCIpO1xuY2xhc3MgVXJsIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5wcm90b2NvbCA9IG51bGw7XG4gICAgICAgIHRoaXMuc2xhc2hlcyA9IG51bGw7XG4gICAgICAgIHRoaXMuYXV0aCA9IG51bGw7XG4gICAgICAgIHRoaXMuaG9zdCA9IG51bGw7XG4gICAgICAgIHRoaXMucG9ydCA9IG51bGw7XG4gICAgICAgIHRoaXMuaG9zdG5hbWUgPSBudWxsO1xuICAgICAgICB0aGlzLmhhc2ggPSBudWxsO1xuICAgICAgICB0aGlzLnNlYXJjaCA9IG51bGw7XG4gICAgICAgIHRoaXMucXVlcnkgPSBudWxsO1xuICAgICAgICB0aGlzLnBhdGhuYW1lID0gbnVsbDtcbiAgICAgICAgdGhpcy5wYXRoID0gbnVsbDtcbiAgICAgICAgdGhpcy5ocmVmID0gbnVsbDtcbiAgICB9XG4gICAgLy8gZm9ybWF0IGEgcGFyc2VkIG9iamVjdCBpbnRvIGEgdXJsIHN0cmluZ1xuICAgIHN0YXRpYyB1cmxGb3JtYXQob2JqKSB7XG4gICAgICAgIC8vIGVuc3VyZSBpdCdzIGFuIG9iamVjdCwgYW5kIG5vdCBhIHN0cmluZyB1cmwuXG4gICAgICAgIC8vIElmIGl0J3MgYW4gb2JqLCB0aGlzIGlzIGEgbm8tb3AuXG4gICAgICAgIC8vIHRoaXMgd2F5LCB5b3UgY2FuIGNhbGwgdXJsX2Zvcm1hdCgpIG9uIHN0cmluZ3NcbiAgICAgICAgLy8gdG8gY2xlYW4gdXAgcG90ZW50aWFsbHkgd29ua3kgdXJscy5cbiAgICAgICAgaWYgKFV0aWxzU2V0dGluZ3NfMS5VdGlsc1NldHRpbmdzLnV0aWwuaXNTdHJpbmcob2JqKSkge1xuICAgICAgICAgICAgb2JqID0gVXJsLnVybFBhcnNlKG9iaik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEob2JqIGluc3RhbmNlb2YgVXJsKSkge1xuICAgICAgICAgICAgcmV0dXJuIFVybC5wcm90b3R5cGUuZm9ybWF0LmNhbGwob2JqKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqLmZvcm1hdCgpO1xuICAgIH1cbiAgICBzdGF0aWMgdXJsUmVzb2x2ZU9iamVjdChzb3VyY2UsIHJlbGF0aXZlKSB7XG4gICAgICAgIGlmICghc291cmNlKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVsYXRpdmU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFVybC51cmxQYXJzZShzb3VyY2UsIGZhbHNlLCB0cnVlKS5yZXNvbHZlT2JqZWN0KHJlbGF0aXZlKTtcbiAgICB9XG4gICAgc3RhdGljIHVybFJlc29sdmUoc291cmNlLCByZWxhdGl2ZSkge1xuICAgICAgICByZXR1cm4gVXJsLnVybFBhcnNlKHNvdXJjZSwgZmFsc2UsIHRydWUpLnJlc29sdmUocmVsYXRpdmUpO1xuICAgIH1cbiAgICByZXNvbHZlT2JqZWN0KHJlbGF0aXZlKSB7XG4gICAgICAgIGlmIChVdGlsc1NldHRpbmdzXzEuVXRpbHNTZXR0aW5ncy51dGlsLmlzU3RyaW5nKHJlbGF0aXZlKSkge1xuICAgICAgICAgICAgdmFyIHJlbCA9IG5ldyBVcmwoKTtcbiAgICAgICAgICAgIHJlbC5wYXJzZShyZWxhdGl2ZSwgZmFsc2UsIHRydWUpO1xuICAgICAgICAgICAgcmVsYXRpdmUgPSByZWw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBVcmwoKTtcbiAgICAgICAgdmFyIHRrZXlzID0gT2JqZWN0LmtleXModGhpcyk7XG4gICAgICAgIGZvciAodmFyIHRrID0gMDsgdGsgPCB0a2V5cy5sZW5ndGg7IHRrKyspIHtcbiAgICAgICAgICAgIHZhciB0a2V5ID0gdGtleXNbdGtdO1xuICAgICAgICAgICAgcmVzdWx0W3RrZXldID0gdGhpc1t0a2V5XTtcbiAgICAgICAgfVxuICAgICAgICAvLyBoYXNoIGlzIGFsd2F5cyBvdmVycmlkZGVuLCBubyBtYXR0ZXIgd2hhdC5cbiAgICAgICAgLy8gZXZlbiBocmVmPVwiXCIgd2lsbCByZW1vdmUgaXQuXG4gICAgICAgIHJlc3VsdC5oYXNoID0gcmVsYXRpdmUuaGFzaDtcbiAgICAgICAgLy8gaWYgdGhlIHJlbGF0aXZlIHVybCBpcyBlbXB0eSwgdGhlbiB0aGVyZSdzIG5vdGhpbmcgbGVmdCB0byBkbyBoZXJlLlxuICAgICAgICBpZiAocmVsYXRpdmUuaHJlZiA9PT0gJycpIHtcbiAgICAgICAgICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICAvLyBocmVmcyBsaWtlIC8vZm9vL2JhciBhbHdheXMgY3V0IHRvIHRoZSBwcm90b2NvbC5cbiAgICAgICAgaWYgKHJlbGF0aXZlLnNsYXNoZXMgJiYgIXJlbGF0aXZlLnByb3RvY29sKSB7XG4gICAgICAgICAgICAvLyB0YWtlIGV2ZXJ5dGhpbmcgZXhjZXB0IHRoZSBwcm90b2NvbCBmcm9tIHJlbGF0aXZlXG4gICAgICAgICAgICB2YXIgcmtleXMgPSBPYmplY3Qua2V5cyhyZWxhdGl2ZSk7XG4gICAgICAgICAgICBmb3IgKHZhciByayA9IDA7IHJrIDwgcmtleXMubGVuZ3RoOyByaysrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJrZXkgPSBya2V5c1tya107XG4gICAgICAgICAgICAgICAgaWYgKHJrZXkgIT09ICdwcm90b2NvbCcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W3JrZXldID0gcmVsYXRpdmVbcmtleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy91cmxQYXJzZSBhcHBlbmRzIHRyYWlsaW5nIC8gdG8gdXJscyBsaWtlIGh0dHA6Ly93d3cuZXhhbXBsZS5jb21cbiAgICAgICAgICAgIGlmIChVcmwuc2xhc2hlZFByb3RvY29sW3Jlc3VsdC5wcm90b2NvbF0gJiZcbiAgICAgICAgICAgICAgICByZXN1bHQuaG9zdG5hbWUgJiYgIXJlc3VsdC5wYXRobmFtZSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wYXRoID0gcmVzdWx0LnBhdGhuYW1lID0gJy8nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZWxhdGl2ZS5wcm90b2NvbCAmJiByZWxhdGl2ZS5wcm90b2NvbCAhPT0gcmVzdWx0LnByb3RvY29sKSB7XG4gICAgICAgICAgICAvLyBpZiBpdCdzIGEga25vd24gdXJsIHByb3RvY29sLCB0aGVuIGNoYW5naW5nXG4gICAgICAgICAgICAvLyB0aGUgcHJvdG9jb2wgZG9lcyB3ZWlyZCB0aGluZ3NcbiAgICAgICAgICAgIC8vIGZpcnN0LCBpZiBpdCdzIG5vdCBmaWxlOiwgdGhlbiB3ZSBNVVNUIGhhdmUgYSBob3N0LFxuICAgICAgICAgICAgLy8gYW5kIGlmIHRoZXJlIHdhcyBhIHBhdGhcbiAgICAgICAgICAgIC8vIHRvIGJlZ2luIHdpdGgsIHRoZW4gd2UgTVVTVCBoYXZlIGEgcGF0aC5cbiAgICAgICAgICAgIC8vIGlmIGl0IGlzIGZpbGU6LCB0aGVuIHRoZSBob3N0IGlzIGRyb3BwZWQsXG4gICAgICAgICAgICAvLyBiZWNhdXNlIHRoYXQncyBrbm93biB0byBiZSBob3N0bGVzcy5cbiAgICAgICAgICAgIC8vIGFueXRoaW5nIGVsc2UgaXMgYXNzdW1lZCB0byBiZSBhYnNvbHV0ZS5cbiAgICAgICAgICAgIGlmICghVXJsLnNsYXNoZWRQcm90b2NvbFtyZWxhdGl2ZS5wcm90b2NvbF0pIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHJlbGF0aXZlKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciB2ID0gMDsgdiA8IGtleXMubGVuZ3RoOyB2KyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGsgPSBrZXlzW3ZdO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRba10gPSByZWxhdGl2ZVtrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5wcm90b2NvbCA9IHJlbGF0aXZlLnByb3RvY29sO1xuICAgICAgICAgICAgaWYgKCFyZWxhdGl2ZS5ob3N0ICYmICFVcmwuaG9zdGxlc3NQcm90b2NvbFtyZWxhdGl2ZS5wcm90b2NvbF0pIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVsUGF0aCA9IChyZWxhdGl2ZS5wYXRobmFtZSB8fCAnJykuc3BsaXQoJy8nKTtcbiAgICAgICAgICAgICAgICB3aGlsZSAocmVsUGF0aC5sZW5ndGggJiYgIShyZWxhdGl2ZS5ob3N0ID0gcmVsUGF0aC5zaGlmdCgpKSkge1xuICAgICAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghcmVsYXRpdmUuaG9zdCkge1xuICAgICAgICAgICAgICAgICAgICByZWxhdGl2ZS5ob3N0ID0gJyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghcmVsYXRpdmUuaG9zdG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVsYXRpdmUuaG9zdG5hbWUgPSAnJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJlbFBhdGhbMF0gIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbFBhdGgudW5zaGlmdCgnJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZWxQYXRoLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVsUGF0aC51bnNoaWZ0KCcnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0LnBhdGhuYW1lID0gcmVsUGF0aC5qb2luKCcvJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucGF0aG5hbWUgPSByZWxhdGl2ZS5wYXRobmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgICAgICAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICAgICAgICAgIHJlc3VsdC5ob3N0ID0gcmVsYXRpdmUuaG9zdCB8fCAnJztcbiAgICAgICAgICAgIHJlc3VsdC5hdXRoID0gcmVsYXRpdmUuYXV0aDtcbiAgICAgICAgICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlbGF0aXZlLmhvc3RuYW1lIHx8IHJlbGF0aXZlLmhvc3Q7XG4gICAgICAgICAgICByZXN1bHQucG9ydCA9IHJlbGF0aXZlLnBvcnQ7XG4gICAgICAgICAgICAvLyB0byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICAgICAgICAgICAgaWYgKHJlc3VsdC5wYXRobmFtZSB8fCByZXN1bHQuc2VhcmNoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHAgPSByZXN1bHQucGF0aG5hbWUgfHwgJyc7XG4gICAgICAgICAgICAgICAgdmFyIHMgPSByZXN1bHQuc2VhcmNoIHx8ICcnO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wYXRoID0gcCArIHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQuc2xhc2hlcyA9IHJlc3VsdC5zbGFzaGVzIHx8IHJlbGF0aXZlLnNsYXNoZXM7XG4gICAgICAgICAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGlzU291cmNlQWJzID0gKHJlc3VsdC5wYXRobmFtZSAmJiByZXN1bHQucGF0aG5hbWUuY2hhckF0KDApID09PSAnLycpLCBpc1JlbEFicyA9IChyZWxhdGl2ZS5ob3N0IHx8XG4gICAgICAgICAgICByZWxhdGl2ZS5wYXRobmFtZSAmJiByZWxhdGl2ZS5wYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJyksIG11c3RFbmRBYnMgPSAoaXNSZWxBYnMgfHwgaXNTb3VyY2VBYnMgfHxcbiAgICAgICAgICAgIChyZXN1bHQuaG9zdCAmJiByZWxhdGl2ZS5wYXRobmFtZSkpLCByZW1vdmVBbGxEb3RzID0gbXVzdEVuZEFicywgc3JjUGF0aCA9IHJlc3VsdC5wYXRobmFtZSAmJiByZXN1bHQucGF0aG5hbWUuc3BsaXQoJy8nKSB8fCBbXSwgcmVsUGF0aCA9IHJlbGF0aXZlLnBhdGhuYW1lICYmIHJlbGF0aXZlLnBhdGhuYW1lLnNwbGl0KCcvJykgfHwgW10sIHBzeWNob3RpYyA9IHJlc3VsdC5wcm90b2NvbCAmJiAhVXJsLnNsYXNoZWRQcm90b2NvbFtyZXN1bHQucHJvdG9jb2xdO1xuICAgICAgICAvLyBpZiB0aGUgdXJsIGlzIGEgbm9uLXNsYXNoZWQgdXJsLCB0aGVuIHJlbGF0aXZlXG4gICAgICAgIC8vIGxpbmtzIGxpa2UgLi4vLi4gc2hvdWxkIGJlIGFibGVcbiAgICAgICAgLy8gdG8gY3Jhd2wgdXAgdG8gdGhlIGhvc3RuYW1lLCBhcyB3ZWxsLiAgVGhpcyBpcyBzdHJhbmdlLlxuICAgICAgICAvLyByZXN1bHQucHJvdG9jb2wgaGFzIGFscmVhZHkgYmVlbiBzZXQgYnkgbm93LlxuICAgICAgICAvLyBMYXRlciBvbiwgcHV0IHRoZSBmaXJzdCBwYXRoIHBhcnQgaW50byB0aGUgaG9zdCBmaWVsZC5cbiAgICAgICAgaWYgKHBzeWNob3RpYykge1xuICAgICAgICAgICAgcmVzdWx0Lmhvc3RuYW1lID0gJyc7XG4gICAgICAgICAgICByZXN1bHQucG9ydCA9IG51bGw7XG4gICAgICAgICAgICBpZiAocmVzdWx0Lmhvc3QpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3JjUGF0aFswXSA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgc3JjUGF0aFswXSA9IHJlc3VsdC5ob3N0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3JjUGF0aC51bnNoaWZ0KHJlc3VsdC5ob3N0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQuaG9zdCA9ICcnO1xuICAgICAgICAgICAgaWYgKHJlbGF0aXZlLnByb3RvY29sKSB7XG4gICAgICAgICAgICAgICAgcmVsYXRpdmUuaG9zdG5hbWUgPSBudWxsO1xuICAgICAgICAgICAgICAgIHJlbGF0aXZlLnBvcnQgPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChyZWxhdGl2ZS5ob3N0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWxQYXRoWzBdID09PSAnJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVsUGF0aFswXSA9IHJlbGF0aXZlLmhvc3Q7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWxQYXRoLnVuc2hpZnQocmVsYXRpdmUuaG9zdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVsYXRpdmUuaG9zdCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtdXN0RW5kQWJzID0gbXVzdEVuZEFicyAmJiAocmVsUGF0aFswXSA9PT0gJycgfHwgc3JjUGF0aFswXSA9PT0gJycpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1JlbEFicykge1xuICAgICAgICAgICAgLy8gaXQncyBhYnNvbHV0ZS5cbiAgICAgICAgICAgIHJlc3VsdC5ob3N0ID0gKHJlbGF0aXZlLmhvc3QgfHwgcmVsYXRpdmUuaG9zdCA9PT0gJycpID9cbiAgICAgICAgICAgICAgICByZWxhdGl2ZS5ob3N0IDogcmVzdWx0Lmhvc3Q7XG4gICAgICAgICAgICByZXN1bHQuaG9zdG5hbWUgPSAocmVsYXRpdmUuaG9zdG5hbWUgfHwgcmVsYXRpdmUuaG9zdG5hbWUgPT09ICcnKSA/XG4gICAgICAgICAgICAgICAgcmVsYXRpdmUuaG9zdG5hbWUgOiByZXN1bHQuaG9zdG5hbWU7XG4gICAgICAgICAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgICAgICAgICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgICAgICAgICBzcmNQYXRoID0gcmVsUGF0aDtcbiAgICAgICAgICAgIC8vIGZhbGwgdGhyb3VnaCB0byB0aGUgZG90LWhhbmRsaW5nIGJlbG93LlxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJlbFBhdGgubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBpdCdzIHJlbGF0aXZlXG4gICAgICAgICAgICAvLyB0aHJvdyBhd2F5IHRoZSBleGlzdGluZyBmaWxlLCBhbmQgdGFrZSB0aGUgbmV3IHBhdGggaW5zdGVhZC5cbiAgICAgICAgICAgIGlmICghc3JjUGF0aCkge1xuICAgICAgICAgICAgICAgIHNyY1BhdGggPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNyY1BhdGgucG9wKCk7XG4gICAgICAgICAgICBzcmNQYXRoID0gc3JjUGF0aC5jb25jYXQocmVsUGF0aCk7XG4gICAgICAgICAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgICAgICAgICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIVV0aWxzU2V0dGluZ3NfMS5VdGlsc1NldHRpbmdzLnV0aWwuaXNOdWxsT3JVbmRlZmluZWQocmVsYXRpdmUuc2VhcmNoKSkge1xuICAgICAgICAgICAgLy8ganVzdCBwdWxsIG91dCB0aGUgc2VhcmNoLlxuICAgICAgICAgICAgLy8gbGlrZSBocmVmPSc/Zm9vJy5cbiAgICAgICAgICAgIC8vIFB1dCB0aGlzIGFmdGVyIHRoZSBvdGhlciB0d28gY2FzZXMgYmVjYXVzZSBpdCBzaW1wbGlmaWVzIHRoZSBib29sZWFuc1xuICAgICAgICAgICAgaWYgKHBzeWNob3RpYykge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlc3VsdC5ob3N0ID0gc3JjUGF0aC5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIC8vb2NjYXRpb25hbHkgdGhlIGF1dGggY2FuIGdldCBzdHVjayBvbmx5IGluIGhvc3RcbiAgICAgICAgICAgICAgICAvL3RoaXMgZXNwZWNpYWxseSBoYXBwZW5zIGluIGNhc2VzIGxpa2VcbiAgICAgICAgICAgICAgICAvL3VybC5yZXNvbHZlT2JqZWN0KCdtYWlsdG86bG9jYWwxQGRvbWFpbjEnLCAnbG9jYWwyQGRvbWFpbjInKVxuICAgICAgICAgICAgICAgIHZhciBhdXRoSW5Ib3N0ID0gcmVzdWx0Lmhvc3QgJiYgcmVzdWx0Lmhvc3QuaW5kZXhPZignQCcpID4gMCA/XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5ob3N0LnNwbGl0KCdAJykgOiBmYWxzZTtcbiAgICAgICAgICAgICAgICBpZiAoYXV0aEluSG9zdCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQuYXV0aCA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0Lmhvc3QgPSByZXN1bHQuaG9zdG5hbWUgPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICAgICAgICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgICAgICAgICAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICAgICAgICAgICAgaWYgKCFVdGlsc1NldHRpbmdzXzEuVXRpbHNTZXR0aW5ncy51dGlsLmlzTnVsbChyZXN1bHQucGF0aG5hbWUpIHx8ICFVdGlsc1NldHRpbmdzXzEuVXRpbHNTZXR0aW5ncy51dGlsLmlzTnVsbChyZXN1bHQuc2VhcmNoKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wYXRoID0gKHJlc3VsdC5wYXRobmFtZSA/IHJlc3VsdC5wYXRobmFtZSA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAgIChyZXN1bHQuc2VhcmNoID8gcmVzdWx0LnNlYXJjaCA6ICcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXNyY1BhdGgubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBubyBwYXRoIGF0IGFsbC4gIGVhc3kuXG4gICAgICAgICAgICAvLyB3ZSd2ZSBhbHJlYWR5IGhhbmRsZWQgdGhlIG90aGVyIHN0dWZmIGFib3ZlLlxuICAgICAgICAgICAgcmVzdWx0LnBhdGhuYW1lID0gbnVsbDtcbiAgICAgICAgICAgIC8vdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgICAgICAgICAgIGlmIChyZXN1bHQuc2VhcmNoKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnBhdGggPSAnLycgKyByZXN1bHQuc2VhcmNoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnBhdGggPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIGEgdXJsIEVORHMgaW4gLiBvciAuLiwgdGhlbiBpdCBtdXN0IGdldCBhIHRyYWlsaW5nIHNsYXNoLlxuICAgICAgICAvLyBob3dldmVyLCBpZiBpdCBlbmRzIGluIGFueXRoaW5nIGVsc2Ugbm9uLXNsYXNoeSxcbiAgICAgICAgLy8gdGhlbiBpdCBtdXN0IE5PVCBnZXQgYSB0cmFpbGluZyBzbGFzaC5cbiAgICAgICAgdmFyIGxhc3QgPSBzcmNQYXRoLnNsaWNlKC0xKVswXTtcbiAgICAgICAgdmFyIGhhc1RyYWlsaW5nU2xhc2ggPSAoKHJlc3VsdC5ob3N0IHx8IHJlbGF0aXZlLmhvc3QgfHwgc3JjUGF0aC5sZW5ndGggPiAxKSAmJlxuICAgICAgICAgICAgKGxhc3QgPT09ICcuJyB8fCBsYXN0ID09PSAnLi4nKSB8fCBsYXN0ID09PSAnJyk7XG4gICAgICAgIC8vIHN0cmlwIHNpbmdsZSBkb3RzLCByZXNvbHZlIGRvdWJsZSBkb3RzIHRvIHBhcmVudCBkaXJcbiAgICAgICAgLy8gaWYgdGhlIHBhdGggdHJpZXMgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIGB1cGAgZW5kcyB1cCA+IDBcbiAgICAgICAgdmFyIHVwID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IHNyY1BhdGgubGVuZ3RoOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgbGFzdCA9IHNyY1BhdGhbaV07XG4gICAgICAgICAgICBpZiAobGFzdCA9PT0gJy4nKSB7XG4gICAgICAgICAgICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChsYXN0ID09PSAnLi4nKSB7XG4gICAgICAgICAgICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgdXArKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHVwKSB7XG4gICAgICAgICAgICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgdXAtLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBpZiB0aGUgcGF0aCBpcyBhbGxvd2VkIHRvIGdvIGFib3ZlIHRoZSByb290LCByZXN0b3JlIGxlYWRpbmcgLi5zXG4gICAgICAgIGlmICghbXVzdEVuZEFicyAmJiAhcmVtb3ZlQWxsRG90cykge1xuICAgICAgICAgICAgZm9yICg7IHVwLS07IHVwKSB7XG4gICAgICAgICAgICAgICAgc3JjUGF0aC51bnNoaWZ0KCcuLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChtdXN0RW5kQWJzICYmIHNyY1BhdGhbMF0gIT09ICcnICYmXG4gICAgICAgICAgICAoIXNyY1BhdGhbMF0gfHwgc3JjUGF0aFswXS5jaGFyQXQoMCkgIT09ICcvJykpIHtcbiAgICAgICAgICAgIHNyY1BhdGgudW5zaGlmdCgnJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhc1RyYWlsaW5nU2xhc2ggJiYgKHNyY1BhdGguam9pbignLycpLnN1YnN0cigtMSkgIT09ICcvJykpIHtcbiAgICAgICAgICAgIHNyY1BhdGgucHVzaCgnJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGlzQWJzb2x1dGUgPSBzcmNQYXRoWzBdID09PSAnJyB8fFxuICAgICAgICAgICAgKHNyY1BhdGhbMF0gJiYgc3JjUGF0aFswXS5jaGFyQXQoMCkgPT09ICcvJyk7XG4gICAgICAgIC8vIHB1dCB0aGUgaG9zdCBiYWNrXG4gICAgICAgIGlmIChwc3ljaG90aWMpIHtcbiAgICAgICAgICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlc3VsdC5ob3N0ID0gaXNBYnNvbHV0ZSA/ICcnIDpcbiAgICAgICAgICAgICAgICBzcmNQYXRoLmxlbmd0aCA/IHNyY1BhdGguc2hpZnQoKSA6ICcnO1xuICAgICAgICAgICAgLy9vY2NhdGlvbmFseSB0aGUgYXV0aCBjYW4gZ2V0IHN0dWNrIG9ubHkgaW4gaG9zdFxuICAgICAgICAgICAgLy90aGlzIGVzcGVjaWFsbHkgaGFwcGVucyBpbiBjYXNlcyBsaWtlXG4gICAgICAgICAgICAvL3VybC5yZXNvbHZlT2JqZWN0KCdtYWlsdG86bG9jYWwxQGRvbWFpbjEnLCAnbG9jYWwyQGRvbWFpbjInKVxuICAgICAgICAgICAgdmFyIGF1dGhJbkhvc3QgPSByZXN1bHQuaG9zdCAmJiByZXN1bHQuaG9zdC5pbmRleE9mKCdAJykgPiAwID9cbiAgICAgICAgICAgICAgICByZXN1bHQuaG9zdC5zcGxpdCgnQCcpIDogZmFsc2U7XG4gICAgICAgICAgICBpZiAoYXV0aEluSG9zdCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5hdXRoID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5ob3N0ID0gcmVzdWx0Lmhvc3RuYW1lID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG11c3RFbmRBYnMgPSBtdXN0RW5kQWJzIHx8IChyZXN1bHQuaG9zdCAmJiBzcmNQYXRoLmxlbmd0aCk7XG4gICAgICAgIGlmIChtdXN0RW5kQWJzICYmICFpc0Fic29sdXRlKSB7XG4gICAgICAgICAgICBzcmNQYXRoLnVuc2hpZnQoJycpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc3JjUGF0aC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wYXRobmFtZSA9IG51bGw7XG4gICAgICAgICAgICByZXN1bHQucGF0aCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQucGF0aG5hbWUgPSBzcmNQYXRoLmpvaW4oJy8nKTtcbiAgICAgICAgfVxuICAgICAgICAvL3RvIHN1cHBvcnQgcmVxdWVzdC5odHRwXG4gICAgICAgIGlmICghVXRpbHNTZXR0aW5nc18xLlV0aWxzU2V0dGluZ3MudXRpbC5pc051bGwocmVzdWx0LnBhdGhuYW1lKSB8fCAhVXRpbHNTZXR0aW5nc18xLlV0aWxzU2V0dGluZ3MudXRpbC5pc051bGwocmVzdWx0LnNlYXJjaCkpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wYXRoID0gKHJlc3VsdC5wYXRobmFtZSA/IHJlc3VsdC5wYXRobmFtZSA6ICcnKSArXG4gICAgICAgICAgICAgICAgKHJlc3VsdC5zZWFyY2ggPyByZXN1bHQuc2VhcmNoIDogJycpO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5hdXRoID0gcmVsYXRpdmUuYXV0aCB8fCByZXN1bHQuYXV0aDtcbiAgICAgICAgcmVzdWx0LnNsYXNoZXMgPSByZXN1bHQuc2xhc2hlcyB8fCByZWxhdGl2ZS5zbGFzaGVzO1xuICAgICAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgO1xuICAgIHN0YXRpYyB1cmxQYXJzZSh1cmwsIHBhcnNlUXVlcnlTdHJpbmcgPSBudWxsLCBzbGFzaGVzRGVub3RlSG9zdCA9IG51bGwpIHtcbiAgICAgICAgaWYgKHVybCAmJiBVdGlsc1NldHRpbmdzXzEuVXRpbHNTZXR0aW5ncy51dGlsLmlzT2JqZWN0KHVybCkgJiYgdXJsIGluc3RhbmNlb2YgVXJsKSB7XG4gICAgICAgICAgICByZXR1cm4gdXJsO1xuICAgICAgICB9XG4gICAgICAgIHZhciB1ID0gbmV3IFVybDtcbiAgICAgICAgdS5wYXJzZSh1cmwsIHBhcnNlUXVlcnlTdHJpbmcsIHNsYXNoZXNEZW5vdGVIb3N0KTtcbiAgICAgICAgcmV0dXJuIHU7XG4gICAgfVxuICAgIHJlc29sdmUocmVsYXRpdmUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzb2x2ZU9iamVjdChVcmwudXJsUGFyc2UocmVsYXRpdmUsIGZhbHNlLCB0cnVlKSkuZm9ybWF0KCk7XG4gICAgfVxuICAgIDtcbiAgICBwYXJzZUhvc3QoKSB7XG4gICAgICAgIHZhciBob3N0ID0gdGhpcy5ob3N0O1xuICAgICAgICB2YXIgcG9ydCA9IFVybC5wb3J0UGF0dGVybi5leGVjKGhvc3QpO1xuICAgICAgICBpZiAocG9ydCkge1xuICAgICAgICAgICAgcG9ydCA9IHBvcnRbMF07XG4gICAgICAgICAgICBpZiAocG9ydCAhPT0gJzonKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3J0ID0gcG9ydC5zdWJzdHIoMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBob3N0ID0gaG9zdC5zdWJzdHIoMCwgaG9zdC5sZW5ndGggLSBwb3J0Lmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhvc3QpIHtcbiAgICAgICAgICAgIHRoaXMuaG9zdG5hbWUgPSBob3N0O1xuICAgICAgICB9XG4gICAgfVxuICAgIDtcbiAgICBwYXJzZSh1cmwsIHBhcnNlUXVlcnlTdHJpbmcgPSBudWxsLCBzbGFzaGVzRGVub3RlSG9zdCA9IG51bGwpIHtcbiAgICAgICAgaWYgKCFVdGlsc1NldHRpbmdzXzEuVXRpbHNTZXR0aW5ncy51dGlsLmlzU3RyaW5nKHVybCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQYXJhbWV0ZXIgJ3VybCcgbXVzdCBiZSBhIHN0cmluZywgbm90IFwiICsgdHlwZW9mIHVybCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ29weSBjaHJvbWUsIElFLCBvcGVyYSBiYWNrc2xhc2gtaGFuZGxpbmcgYmVoYXZpb3IuXG4gICAgICAgIC8vIEJhY2sgc2xhc2hlcyBiZWZvcmUgdGhlIHF1ZXJ5IHN0cmluZyBnZXQgY29udmVydGVkIHRvIGZvcndhcmQgc2xhc2hlc1xuICAgICAgICAvLyBTZWU6IGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0yNTkxNlxuICAgICAgICB2YXIgcXVlcnlJbmRleCA9IHVybC5pbmRleE9mKCc/JyksIHNwbGl0dGVyID0gKHF1ZXJ5SW5kZXggIT09IC0xICYmIHF1ZXJ5SW5kZXggPCB1cmwuaW5kZXhPZignIycpKSA/ICc/JyA6ICcjJywgdVNwbGl0ID0gdXJsLnNwbGl0KHNwbGl0dGVyKSwgc2xhc2hSZWdleCA9IC9cXFxcL2c7XG4gICAgICAgIHVTcGxpdFswXSA9IHVTcGxpdFswXS5yZXBsYWNlKHNsYXNoUmVnZXgsICcvJyk7XG4gICAgICAgIHVybCA9IHVTcGxpdC5qb2luKHNwbGl0dGVyKTtcbiAgICAgICAgdmFyIHJlc3QgPSB1cmw7XG4gICAgICAgIC8vIHRyaW0gYmVmb3JlIHByb2NlZWRpbmcuXG4gICAgICAgIC8vIFRoaXMgaXMgdG8gc3VwcG9ydCBwYXJzZSBzdHVmZiBsaWtlIFwiICBodHRwOi8vZm9vLmNvbSAgXFxuXCJcbiAgICAgICAgcmVzdCA9IHJlc3QudHJpbSgpO1xuICAgICAgICBpZiAoIXNsYXNoZXNEZW5vdGVIb3N0ICYmIHVybC5zcGxpdCgnIycpLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgLy8gVHJ5IGZhc3QgcGF0aCByZWdleHBcbiAgICAgICAgICAgIHZhciBzaW1wbGVQYXRoID0gVXJsLnNpbXBsZVBhdGhQYXR0ZXJuLmV4ZWMocmVzdCk7XG4gICAgICAgICAgICBpZiAoc2ltcGxlUGF0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMucGF0aCA9IHJlc3Q7XG4gICAgICAgICAgICAgICAgdGhpcy5ocmVmID0gcmVzdDtcbiAgICAgICAgICAgICAgICB0aGlzLnBhdGhuYW1lID0gc2ltcGxlUGF0aFsxXTtcbiAgICAgICAgICAgICAgICBpZiAoc2ltcGxlUGF0aFsyXSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlYXJjaCA9IHNpbXBsZVBhdGhbMl07XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnF1ZXJ5ID0gdGhpcy5wYXJzZSh0aGlzLnNlYXJjaC5zdWJzdHIoMSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5xdWVyeSA9IHRoaXMuc2VhcmNoLnN1YnN0cigxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VhcmNoID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucXVlcnkgPSB7fTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHByb3RvID0gVXJsLnByb3RvY29sUGF0dGVybi5leGVjKHJlc3QpO1xuICAgICAgICBpZiAocHJvdG8pIHtcbiAgICAgICAgICAgIHByb3RvID0gcHJvdG9bMF07XG4gICAgICAgICAgICB2YXIgbG93ZXJQcm90byA9IHByb3RvLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB0aGlzLnByb3RvY29sID0gbG93ZXJQcm90bztcbiAgICAgICAgICAgIHJlc3QgPSByZXN0LnN1YnN0cihwcm90by5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGZpZ3VyZSBvdXQgaWYgaXQncyBnb3QgYSBob3N0XG4gICAgICAgIC8vIHVzZXJAc2VydmVyIGlzICphbHdheXMqIGludGVycHJldGVkIGFzIGEgaG9zdG5hbWUsIGFuZCB1cmxcbiAgICAgICAgLy8gcmVzb2x1dGlvbiB3aWxsIHRyZWF0IC8vZm9vL2JhciBhcyBob3N0PWZvbyxwYXRoPWJhciBiZWNhdXNlIHRoYXQnc1xuICAgICAgICAvLyBob3cgdGhlIGJyb3dzZXIgcmVzb2x2ZXMgcmVsYXRpdmUgVVJMcy5cbiAgICAgICAgaWYgKHNsYXNoZXNEZW5vdGVIb3N0IHx8IHByb3RvIHx8IHJlc3QubWF0Y2goL15cXC9cXC9bXkBcXC9dK0BbXkBcXC9dKy8pKSB7XG4gICAgICAgICAgICB2YXIgc2xhc2hlcyA9IHJlc3Quc3Vic3RyKDAsIDIpID09PSAnLy8nO1xuICAgICAgICAgICAgaWYgKHNsYXNoZXMgJiYgIShwcm90byAmJiBVcmwuaG9zdGxlc3NQcm90b2NvbFtwcm90b10pKSB7XG4gICAgICAgICAgICAgICAgcmVzdCA9IHJlc3Quc3Vic3RyKDIpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2xhc2hlcyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFVcmwuaG9zdGxlc3NQcm90b2NvbFtwcm90b10gJiZcbiAgICAgICAgICAgIChzbGFzaGVzIHx8IChwcm90byAmJiAhVXJsLnNsYXNoZWRQcm90b2NvbFtwcm90b10pKSkge1xuICAgICAgICAgICAgLy8gdGhlcmUncyBhIGhvc3RuYW1lLlxuICAgICAgICAgICAgLy8gdGhlIGZpcnN0IGluc3RhbmNlIG9mIC8sID8sIDssIG9yICMgZW5kcyB0aGUgaG9zdC5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBhbiBAIGluIHRoZSBob3N0bmFtZSwgdGhlbiBub24taG9zdCBjaGFycyAqYXJlKiBhbGxvd2VkXG4gICAgICAgICAgICAvLyB0byB0aGUgbGVmdCBvZiB0aGUgbGFzdCBAIHNpZ24sIHVubGVzcyBzb21lIGhvc3QtZW5kaW5nIGNoYXJhY3RlclxuICAgICAgICAgICAgLy8gY29tZXMgKmJlZm9yZSogdGhlIEAtc2lnbi5cbiAgICAgICAgICAgIC8vIFVSTHMgYXJlIG9ibm94aW91cy5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBleDpcbiAgICAgICAgICAgIC8vIGh0dHA6Ly9hQGJAYy8gPT4gdXNlcjphQGIgaG9zdDpjXG4gICAgICAgICAgICAvLyBodHRwOi8vYUBiP0BjID0+IHVzZXI6YSBob3N0OmMgcGF0aDovP0BjXG4gICAgICAgICAgICAvLyB2MC4xMiBUT0RPKGlzYWFjcyk6IFRoaXMgaXMgbm90IHF1aXRlIGhvdyBDaHJvbWUgZG9lcyB0aGluZ3MuXG4gICAgICAgICAgICAvLyBSZXZpZXcgb3VyIHRlc3QgY2FzZSBhZ2FpbnN0IGJyb3dzZXJzIG1vcmUgY29tcHJlaGVuc2l2ZWx5LlxuICAgICAgICAgICAgLy8gZmluZCB0aGUgZmlyc3QgaW5zdGFuY2Ugb2YgYW55IGhvc3RFbmRpbmdDaGFyc1xuICAgICAgICAgICAgdmFyIGhvc3RFbmQgPSAtMTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgVXJsLmhvc3RFbmRpbmdDaGFycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBoZWMgPSByZXN0LmluZGV4T2YoVXJsLmhvc3RFbmRpbmdDaGFyc1tpXSk7XG4gICAgICAgICAgICAgICAgaWYgKGhlYyAhPT0gLTEgJiYgKGhvc3RFbmQgPT09IC0xIHx8IGhlYyA8IGhvc3RFbmQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGhvc3RFbmQgPSBoZWM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYXQgdGhpcyBwb2ludCwgZWl0aGVyIHdlIGhhdmUgYW4gZXhwbGljaXQgcG9pbnQgd2hlcmUgdGhlXG4gICAgICAgICAgICAvLyBhdXRoIHBvcnRpb24gY2Fubm90IGdvIHBhc3QsIG9yIHRoZSBsYXN0IEAgY2hhciBpcyB0aGUgZGVjaWRlci5cbiAgICAgICAgICAgIHZhciBhdXRoLCBhdFNpZ247XG4gICAgICAgICAgICBpZiAoaG9zdEVuZCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAvLyBhdFNpZ24gY2FuIGJlIGFueXdoZXJlLlxuICAgICAgICAgICAgICAgIGF0U2lnbiA9IHJlc3QubGFzdEluZGV4T2YoJ0AnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGF0U2lnbiBtdXN0IGJlIGluIGF1dGggcG9ydGlvbi5cbiAgICAgICAgICAgICAgICAvLyBodHRwOi8vYUBiL2NAZCA9PiBob3N0OmIgYXV0aDphIHBhdGg6L2NAZFxuICAgICAgICAgICAgICAgIGF0U2lnbiA9IHJlc3QubGFzdEluZGV4T2YoJ0AnLCBob3N0RW5kKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE5vdyB3ZSBoYXZlIGEgcG9ydGlvbiB3aGljaCBpcyBkZWZpbml0ZWx5IHRoZSBhdXRoLlxuICAgICAgICAgICAgLy8gUHVsbCB0aGF0IG9mZi5cbiAgICAgICAgICAgIGlmIChhdFNpZ24gIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgYXV0aCA9IHJlc3Quc2xpY2UoMCwgYXRTaWduKTtcbiAgICAgICAgICAgICAgICByZXN0ID0gcmVzdC5zbGljZShhdFNpZ24gKyAxKTtcbiAgICAgICAgICAgICAgICB0aGlzLmF1dGggPSBkZWNvZGVVUklDb21wb25lbnQoYXV0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0aGUgaG9zdCBpcyB0aGUgcmVtYWluaW5nIHRvIHRoZSBsZWZ0IG9mIHRoZSBmaXJzdCBub24taG9zdCBjaGFyXG4gICAgICAgICAgICBob3N0RW5kID0gLTE7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IFVybC5ub25Ib3N0Q2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgaGVjID0gcmVzdC5pbmRleE9mKFVybC5ub25Ib3N0Q2hhcnNbaV0pO1xuICAgICAgICAgICAgICAgIGlmIChoZWMgIT09IC0xICYmIChob3N0RW5kID09PSAtMSB8fCBoZWMgPCBob3N0RW5kKSkge1xuICAgICAgICAgICAgICAgICAgICBob3N0RW5kID0gaGVjO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGlmIHdlIHN0aWxsIGhhdmUgbm90IGhpdCBpdCwgdGhlbiB0aGUgZW50aXJlIHRoaW5nIGlzIGEgaG9zdC5cbiAgICAgICAgICAgIGlmIChob3N0RW5kID09PSAtMSkge1xuICAgICAgICAgICAgICAgIGhvc3RFbmQgPSByZXN0Lmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaG9zdCA9IHJlc3Quc2xpY2UoMCwgaG9zdEVuZCk7XG4gICAgICAgICAgICByZXN0ID0gcmVzdC5zbGljZShob3N0RW5kKTtcbiAgICAgICAgICAgIC8vIHB1bGwgb3V0IHBvcnQuXG4gICAgICAgICAgICB0aGlzLnBhcnNlSG9zdCgpO1xuICAgICAgICAgICAgLy8gd2UndmUgaW5kaWNhdGVkIHRoYXQgdGhlcmUgaXMgYSBob3N0bmFtZSxcbiAgICAgICAgICAgIC8vIHNvIGV2ZW4gaWYgaXQncyBlbXB0eSwgaXQgaGFzIHRvIGJlIHByZXNlbnQuXG4gICAgICAgICAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZSB8fCAnJztcbiAgICAgICAgICAgIC8vIGlmIGhvc3RuYW1lIGJlZ2lucyB3aXRoIFsgYW5kIGVuZHMgd2l0aCBdXG4gICAgICAgICAgICAvLyBhc3N1bWUgdGhhdCBpdCdzIGFuIElQdjYgYWRkcmVzcy5cbiAgICAgICAgICAgIHZhciBpcHY2SG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lWzBdID09PSAnWycgJiZcbiAgICAgICAgICAgICAgICB0aGlzLmhvc3RuYW1lW3RoaXMuaG9zdG5hbWUubGVuZ3RoIC0gMV0gPT09ICddJztcbiAgICAgICAgICAgIC8vIHZhbGlkYXRlIGEgbGl0dGxlLlxuICAgICAgICAgICAgaWYgKCFpcHY2SG9zdG5hbWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgaG9zdHBhcnRzID0gdGhpcy5ob3N0bmFtZS5zcGxpdCgvXFwuLyk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBob3N0cGFydHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJ0ID0gaG9zdHBhcnRzW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXBhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghcGFydC5tYXRjaChVcmwuaG9zdG5hbWVQYXJ0UGF0dGVybikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXdwYXJ0ID0gJyc7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMCwgayA9IHBhcnQubGVuZ3RoOyBqIDwgazsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnQuY2hhckNvZGVBdChqKSA+IDEyNykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSByZXBsYWNlIG5vbi1BU0NJSSBjaGFyIHdpdGggYSB0ZW1wb3JhcnkgcGxhY2Vob2xkZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UgbmVlZCB0aGlzIHRvIG1ha2Ugc3VyZSBzaXplIG9mIGhvc3RuYW1lIGlzIG5vdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBicm9rZW4gYnkgcmVwbGFjaW5nIG5vbi1BU0NJSSBieSBub3RoaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld3BhcnQgKz0gJ3gnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3cGFydCArPSBwYXJ0W2pdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIHRlc3QgYWdhaW4gd2l0aCBBU0NJSSBjaGFyIG9ubHlcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbmV3cGFydC5tYXRjaChVcmwuaG9zdG5hbWVQYXJ0UGF0dGVybikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsaWRQYXJ0cyA9IGhvc3RwYXJ0cy5zbGljZSgwLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbm90SG9zdCA9IGhvc3RwYXJ0cy5zbGljZShpICsgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJpdCA9IHBhcnQubWF0Y2goVXJsLmhvc3RuYW1lUGFydFN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYml0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkUGFydHMucHVzaChiaXRbMV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3RIb3N0LnVuc2hpZnQoYml0WzJdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vdEhvc3QubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3QgPSAnLycgKyBub3RIb3N0LmpvaW4oJy4nKSArIHJlc3Q7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaG9zdG5hbWUgPSB2YWxpZFBhcnRzLmpvaW4oJy4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmhvc3RuYW1lLmxlbmd0aCA+IFVybC5ob3N0bmFtZU1heExlbikge1xuICAgICAgICAgICAgICAgIHRoaXMuaG9zdG5hbWUgPSAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGhvc3RuYW1lcyBhcmUgYWx3YXlzIGxvd2VyIGNhc2UuXG4gICAgICAgICAgICAgICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXB2Nkhvc3RuYW1lKSB7XG4gICAgICAgICAgICAgICAgLy8gSUROQSBTdXBwb3J0OiBSZXR1cm5zIGEgcHVueWNvZGVkIHJlcHJlc2VudGF0aW9uIG9mIFwiZG9tYWluXCIuXG4gICAgICAgICAgICAgICAgLy8gSXQgb25seSBjb252ZXJ0cyBwYXJ0cyBvZiB0aGUgZG9tYWluIG5hbWUgdGhhdFxuICAgICAgICAgICAgICAgIC8vIGhhdmUgbm9uLUFTQ0lJIGNoYXJhY3RlcnMsIGkuZS4gaXQgZG9lc24ndCBtYXR0ZXIgaWZcbiAgICAgICAgICAgICAgICAvLyB5b3UgY2FsbCBpdCB3aXRoIGEgZG9tYWluIHRoYXQgYWxyZWFkeSBpcyBBU0NJSS1vbmx5LlxuICAgICAgICAgICAgICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLnRvQVNDSUkodGhpcy5ob3N0bmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcCA9IHRoaXMucG9ydCA/ICc6JyArIHRoaXMucG9ydCA6ICcnO1xuICAgICAgICAgICAgdmFyIGggPSB0aGlzLmhvc3RuYW1lIHx8ICcnO1xuICAgICAgICAgICAgdGhpcy5ob3N0ID0gaCArIHA7XG4gICAgICAgICAgICB0aGlzLmhyZWYgKz0gdGhpcy5ob3N0O1xuICAgICAgICAgICAgLy8gc3RyaXAgWyBhbmQgXSBmcm9tIHRoZSBob3N0bmFtZVxuICAgICAgICAgICAgLy8gdGhlIGhvc3QgZmllbGQgc3RpbGwgcmV0YWlucyB0aGVtLCB0aG91Z2hcbiAgICAgICAgICAgIGlmIChpcHY2SG9zdG5hbWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZS5zdWJzdHIoMSwgdGhpcy5ob3N0bmFtZS5sZW5ndGggLSAyKTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdFswXSAhPT0gJy8nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3QgPSAnLycgKyByZXN0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBub3cgcmVzdCBpcyBzZXQgdG8gdGhlIHBvc3QtaG9zdCBzdHVmZi5cbiAgICAgICAgLy8gY2hvcCBvZmYgYW55IGRlbGltIGNoYXJzLlxuICAgICAgICBpZiAoIVVybC51bnNhZmVQcm90b2NvbFtsb3dlclByb3RvXSkge1xuICAgICAgICAgICAgLy8gRmlyc3QsIG1ha2UgMTAwJSBzdXJlIHRoYXQgYW55IFwiYXV0b0VzY2FwZVwiIGNoYXJzIGdldFxuICAgICAgICAgICAgLy8gZXNjYXBlZCwgZXZlbiBpZiBlbmNvZGVVUklDb21wb25lbnQgZG9lc24ndCB0aGluayB0aGV5XG4gICAgICAgICAgICAvLyBuZWVkIHRvIGJlLlxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBVcmwuYXV0b0VzY2FwZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgYWUgPSBVcmwuYXV0b0VzY2FwZVtpXTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdC5pbmRleE9mKGFlKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBlc2MgPSBlbmNvZGVVUklDb21wb25lbnQoYWUpO1xuICAgICAgICAgICAgICAgIGlmIChlc2MgPT09IGFlKSB7XG4gICAgICAgICAgICAgICAgICAgIGVzYyA9IGVzY2FwZShhZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3QgPSByZXN0LnNwbGl0KGFlKS5qb2luKGVzYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gY2hvcCBvZmYgZnJvbSB0aGUgdGFpbCBmaXJzdC5cbiAgICAgICAgdmFyIGhhc2ggPSByZXN0LmluZGV4T2YoJyMnKTtcbiAgICAgICAgaWYgKGhhc2ggIT09IC0xKSB7XG4gICAgICAgICAgICAvLyBnb3QgYSBmcmFnbWVudCBzdHJpbmcuXG4gICAgICAgICAgICB0aGlzLmhhc2ggPSByZXN0LnN1YnN0cihoYXNoKTtcbiAgICAgICAgICAgIHJlc3QgPSByZXN0LnNsaWNlKDAsIGhhc2gpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBxbSA9IHJlc3QuaW5kZXhPZignPycpO1xuICAgICAgICBpZiAocW0gIT09IC0xKSB7XG4gICAgICAgICAgICB0aGlzLnNlYXJjaCA9IHJlc3Quc3Vic3RyKHFtKTtcbiAgICAgICAgICAgIHRoaXMucXVlcnkgPSByZXN0LnN1YnN0cihxbSArIDEpO1xuICAgICAgICAgICAgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnF1ZXJ5ID0gdGhpcy5wYXJzZSh0aGlzLnF1ZXJ5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3QgPSByZXN0LnNsaWNlKDAsIHFtKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgICAgICAgICAvLyBubyBxdWVyeSBzdHJpbmcsIGJ1dCBwYXJzZVF1ZXJ5U3RyaW5nIHN0aWxsIHJlcXVlc3RlZFxuICAgICAgICAgICAgdGhpcy5zZWFyY2ggPSAnJztcbiAgICAgICAgICAgIHRoaXMucXVlcnkgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdCkge1xuICAgICAgICAgICAgdGhpcy5wYXRobmFtZSA9IHJlc3Q7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFVybC5zbGFzaGVkUHJvdG9jb2xbbG93ZXJQcm90b10gJiZcbiAgICAgICAgICAgIHRoaXMuaG9zdG5hbWUgJiYgIXRoaXMucGF0aG5hbWUpIHtcbiAgICAgICAgICAgIHRoaXMucGF0aG5hbWUgPSAnLyc7XG4gICAgICAgIH1cbiAgICAgICAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICAgICAgICBpZiAodGhpcy5wYXRobmFtZSB8fCB0aGlzLnNlYXJjaCkge1xuICAgICAgICAgICAgdmFyIHAgPSB0aGlzLnBhdGhuYW1lIHx8ICcnO1xuICAgICAgICAgICAgdmFyIHMgPSB0aGlzLnNlYXJjaCB8fCAnJztcbiAgICAgICAgICAgIHRoaXMucGF0aCA9IHAgKyBzO1xuICAgICAgICB9XG4gICAgICAgIC8vIGZpbmFsbHksIHJlY29uc3RydWN0IHRoZSBocmVmIGJhc2VkIG9uIHdoYXQgaGFzIGJlZW4gdmFsaWRhdGVkLlxuICAgICAgICB0aGlzLmhyZWYgPSB0aGlzLmZvcm1hdCgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICogQ29udmVydHMgYSBVbmljb2RlIHN0cmluZyByZXByZXNlbnRpbmcgYSBkb21haW4gbmFtZSBvciBhbiBlbWFpbCBhZGRyZXNzIHRvXG4gKiBQdW55Y29kZS4gT25seSB0aGUgbm9uLUFTQ0lJIHBhcnRzIG9mIHRoZSBkb21haW4gbmFtZSB3aWxsIGJlIGNvbnZlcnRlZCxcbiAqIGkuZS4gaXQgZG9lc24ndCBtYXR0ZXIgaWYgeW91IGNhbGwgaXQgd2l0aCBhIGRvbWFpbiB0aGF0J3MgYWxyZWFkeSBpblxuICogQVNDSUkuXG4gKiBAbWVtYmVyT2YgcHVueWNvZGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcyB0byBjb252ZXJ0LCBhcyBhXG4gKiBVbmljb2RlIHN0cmluZy5cbiAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBQdW55Y29kZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gZG9tYWluIG5hbWUgb3JcbiAqIGVtYWlsIGFkZHJlc3MuXG4gKi9cbiAgICB0b0FTQ0lJKGlucHV0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1hcERvbWFpbihpbnB1dCwgZnVuY3Rpb24gKHN0cmluZykge1xuICAgICAgICAgICAgcmV0dXJuIFVybC5yZWdleE5vbkFTQ0lJLnRlc3Qoc3RyaW5nKVxuICAgICAgICAgICAgICAgID8gJ3huLS0nICsgdGhpcy5lbmNvZGUoc3RyaW5nKVxuICAgICAgICAgICAgICAgIDogc3RyaW5nO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RyaW5naWZ5UHJpbWl0aXZlKHYpIHtcbiAgICAgICAgc3dpdGNoICh0eXBlb2Ygdikge1xuICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgIHJldHVybiB2ID8gJ3RydWUnIDogJ2ZhbHNlJztcbiAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzRmluaXRlKHYpID8gdiA6ICcnO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xuICAgIGVuY29kZShvYmosIHNlcCA9IG51bGwsIGVxID0gbnVsbCwgbmFtZSA9IG51bGwpIHtcbiAgICAgICAgc2VwID0gc2VwIHx8ICcmJztcbiAgICAgICAgZXEgPSBlcSB8fCAnPSc7XG4gICAgICAgIGlmIChvYmogPT09IG51bGwpIHtcbiAgICAgICAgICAgIG9iaiA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhvYmopLm1hcChmdW5jdGlvbiAoaykge1xuICAgICAgICAgICAgICAgIHZhciBrcyA9IGVuY29kZVVSSUNvbXBvbmVudCh0aGlzLnN0cmluZ2lmeVByaW1pdGl2ZShrKSkgKyBlcTtcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmpba10pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvYmpba10ubWFwKGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ga3MgKyBlbmNvZGVVUklDb21wb25lbnQodGhpcy5zdHJpbmdpZnlQcmltaXRpdmUodikpO1xuICAgICAgICAgICAgICAgICAgICB9KS5qb2luKHNlcCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ga3MgKyBlbmNvZGVVUklDb21wb25lbnQodGhpcy5zdHJpbmdpZnlQcmltaXRpdmUob2JqW2tdKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkuam9pbihzZXApO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQodGhpcy5zdHJpbmdpZnlQcmltaXRpdmUobmFtZSkpICsgZXEgK1xuICAgICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KHRoaXMuc3RyaW5naWZ5UHJpbWl0aXZlKG9iaikpO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogQSBzaW1wbGUgYEFycmF5I21hcGAtbGlrZSB3cmFwcGVyIHRvIHdvcmsgd2l0aCBkb21haW4gbmFtZSBzdHJpbmdzIG9yIGVtYWlsXG4gICAgICogYWRkcmVzc2VzLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRvbWFpbiBUaGUgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCBmb3IgZXZlcnlcbiAgICAgKiBjaGFyYWN0ZXIuXG4gICAgICogQHJldHVybnMge0FycmF5fSBBIG5ldyBzdHJpbmcgb2YgY2hhcmFjdGVycyByZXR1cm5lZCBieSB0aGUgY2FsbGJhY2tcbiAgICAgKiBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBtYXBEb21haW4oc3RyaW5nLCBmbikge1xuICAgICAgICB2YXIgcGFydHMgPSBzdHJpbmcuc3BsaXQoJ0AnKTtcbiAgICAgICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgICAgICBpZiAocGFydHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgLy8gSW4gZW1haWwgYWRkcmVzc2VzLCBvbmx5IHRoZSBkb21haW4gbmFtZSBzaG91bGQgYmUgcHVueWNvZGVkLiBMZWF2ZVxuICAgICAgICAgICAgLy8gdGhlIGxvY2FsIHBhcnQgKGkuZS4gZXZlcnl0aGluZyB1cCB0byBgQGApIGludGFjdC5cbiAgICAgICAgICAgIHJlc3VsdCA9IHBhcnRzWzBdICsgJ0AnO1xuICAgICAgICAgICAgc3RyaW5nID0gcGFydHNbMV07XG4gICAgICAgIH1cbiAgICAgICAgLy8gQXZvaWQgYHNwbGl0KHJlZ2V4KWAgZm9yIElFOCBjb21wYXRpYmlsaXR5LiBTZWUgIzE3LlxuICAgICAgICBzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShVcmwucmVnZXhTZXBhcmF0b3JzLCAnXFx4MkUnKTtcbiAgICAgICAgdmFyIGxhYmVscyA9IHN0cmluZy5zcGxpdCgnLicpO1xuICAgICAgICB2YXIgZW5jb2RlZCA9IHRoaXMubWFwKGxhYmVscywgZm4pLmpvaW4oJy4nKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdCArIGVuY29kZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgZ2VuZXJpYyBgQXJyYXkjbWFwYCB1dGlsaXR5IGZ1bmN0aW9uLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCBmb3IgZXZlcnkgYXJyYXlcbiAgICAgKiBpdGVtLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gQSBuZXcgYXJyYXkgb2YgdmFsdWVzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFjayBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBtYXAoYXJyYXksIGZuKSB7XG4gICAgICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgICAgICByZXN1bHRbbGVuZ3RoXSA9IGZuKGFycmF5W2xlbmd0aF0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGZvcm1hdCgpIHtcbiAgICAgICAgdmFyIGF1dGggPSB0aGlzLmF1dGggfHwgJyc7XG4gICAgICAgIGlmIChhdXRoKSB7XG4gICAgICAgICAgICBhdXRoID0gZW5jb2RlVVJJQ29tcG9uZW50KGF1dGgpO1xuICAgICAgICAgICAgYXV0aCA9IGF1dGgucmVwbGFjZSgvJTNBL2ksICc6Jyk7XG4gICAgICAgICAgICBhdXRoICs9ICdAJztcbiAgICAgICAgfVxuICAgICAgICB2YXIgcHJvdG9jb2wgPSB0aGlzLnByb3RvY29sIHx8ICcnLCBwYXRobmFtZSA9IHRoaXMucGF0aG5hbWUgfHwgJycsIGhhc2ggPSB0aGlzLmhhc2ggfHwgJycsIGhvc3QgPSBmYWxzZSwgcXVlcnkgPSAnJztcbiAgICAgICAgaWYgKHRoaXMuaG9zdCkge1xuICAgICAgICAgICAgaG9zdCA9IGF1dGggKyB0aGlzLmhvc3Q7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5ob3N0bmFtZSkge1xuICAgICAgICAgICAgaG9zdCA9IGF1dGggKyAodGhpcy5ob3N0bmFtZS5pbmRleE9mKCc6JykgPT09IC0xID9cbiAgICAgICAgICAgICAgICB0aGlzLmhvc3RuYW1lIDpcbiAgICAgICAgICAgICAgICAnWycgKyB0aGlzLmhvc3RuYW1lICsgJ10nKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnBvcnQpIHtcbiAgICAgICAgICAgICAgICBob3N0ICs9ICc6JyArIHRoaXMucG9ydDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5xdWVyeSAmJlxuICAgICAgICAgICAgVXRpbHNTZXR0aW5nc18xLlV0aWxzU2V0dGluZ3MudXRpbC5pc09iamVjdCh0aGlzLnF1ZXJ5KSAmJlxuICAgICAgICAgICAgT2JqZWN0LmtleXModGhpcy5xdWVyeSkubGVuZ3RoKSB7XG4gICAgICAgICAgICBxdWVyeSA9IHRoaXMuZW5jb2RlKHRoaXMucXVlcnkpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzZWFyY2ggPSB0aGlzLnNlYXJjaCB8fCAocXVlcnkgJiYgKCc/JyArIHF1ZXJ5KSkgfHwgJyc7XG4gICAgICAgIGlmIChwcm90b2NvbCAmJiBwcm90b2NvbC5zdWJzdHIoLTEpICE9PSAnOicpIHtcbiAgICAgICAgICAgIHByb3RvY29sICs9ICc6JztcbiAgICAgICAgfVxuICAgICAgICAvLyBvbmx5IHRoZSBzbGFzaGVkUHJvdG9jb2xzIGdldCB0aGUgLy8uICBOb3QgbWFpbHRvOiwgeG1wcDosIGV0Yy5cbiAgICAgICAgLy8gdW5sZXNzIHRoZXkgaGFkIHRoZW0gdG8gYmVnaW4gd2l0aC5cbiAgICAgICAgaWYgKHRoaXMuc2xhc2hlcyB8fFxuICAgICAgICAgICAgKCFwcm90b2NvbCB8fCBVcmwuc2xhc2hlZFByb3RvY29sW3Byb3RvY29sXSkgJiYgaG9zdCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGhvc3QgPSAnLy8nICsgKGhvc3QgfHwgJycpO1xuICAgICAgICAgICAgaWYgKHBhdGhuYW1lICYmIHBhdGhuYW1lLmNoYXJBdCgwKSAhPT0gJy8nKSB7XG4gICAgICAgICAgICAgICAgcGF0aG5hbWUgPSAnLycgKyBwYXRobmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghaG9zdCkge1xuICAgICAgICAgICAgaG9zdCA9ICcnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoYXNoICYmIGhhc2guY2hhckF0KDApICE9PSAnIycpIHtcbiAgICAgICAgICAgIGhhc2ggPSAnIycgKyBoYXNoO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZWFyY2ggJiYgc2VhcmNoLmNoYXJBdCgwKSAhPT0gJz8nKSB7XG4gICAgICAgICAgICBzZWFyY2ggPSAnPycgKyBzZWFyY2g7XG4gICAgICAgIH1cbiAgICAgICAgcGF0aG5hbWUgPSBwYXRobmFtZS5yZXBsYWNlKC9bPyNdL2csIGZ1bmN0aW9uIChtYXRjaCkge1xuICAgICAgICAgICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChtYXRjaCk7XG4gICAgICAgIH0pO1xuICAgICAgICBzZWFyY2ggPSBzZWFyY2gucmVwbGFjZSgnIycsICclMjMnKTtcbiAgICAgICAgcmV0dXJuIHByb3RvY29sICsgaG9zdCArIHBhdGhuYW1lICsgc2VhcmNoICsgaGFzaDtcbiAgICB9XG4gICAgO1xufVxuVXJsLnJlZ2V4U2VwYXJhdG9ycyA9IC9bXFx4MkVcXHUzMDAyXFx1RkYwRVxcdUZGNjFdL2c7XG5VcmwucG9ydFBhdHRlcm4gPSAvOlswLTldKiQvO1xuVXJsLnNpbXBsZVBhdGhQYXR0ZXJuID0gL14oXFwvXFwvPyg/IVxcLylbXlxcP1xcc10qKShcXD9bXlxcc10qKT8kLztcblVybC5wcm90b2NvbFBhdHRlcm4gPSAvXihbYS16MC05ListXSs6KS9pO1xuVXJsLnJlZ2V4Tm9uQVNDSUkgPSAvW15cXHgyMC1cXHg3RV0vO1xuVXJsLmhvc3RsZXNzUHJvdG9jb2wgPSB7XG4gICAgJ2phdmFzY3JpcHQnOiB0cnVlLFxuICAgICdqYXZhc2NyaXB0Oic6IHRydWVcbn07XG5Vcmwuc2xhc2hlZFByb3RvY29sID0ge1xuICAgICdodHRwJzogdHJ1ZSxcbiAgICAnaHR0cHMnOiB0cnVlLFxuICAgICdmdHAnOiB0cnVlLFxuICAgICdnb3BoZXInOiB0cnVlLFxuICAgICdmaWxlJzogdHJ1ZSxcbiAgICAnaHR0cDonOiB0cnVlLFxuICAgICdodHRwczonOiB0cnVlLFxuICAgICdmdHA6JzogdHJ1ZSxcbiAgICAnZ29waGVyOic6IHRydWUsXG4gICAgJ2ZpbGU6JzogdHJ1ZVxufTtcblVybC5ob3N0RW5kaW5nQ2hhcnMgPSBbJy8nLCAnPycsICcjJ107XG5VcmwuZGVsaW1zID0gWyc8JywgJz4nLCAnXCInLCAnYCcsICcgJywgJ1xccicsICdcXG4nLCAnXFx0J107XG5VcmwudW53aXNlID0gWyd7JywgJ30nLCAnfCcsICdcXFxcJywgJ14nLCAnYCddLmNvbmNhdChVcmwuZGVsaW1zKTtcblVybC5hdXRvRXNjYXBlID0gWydcXCcnXS5jb25jYXQoVXJsLnVud2lzZSk7XG5Vcmwubm9uSG9zdENoYXJzID0gWyclJywgJy8nLCAnPycsICc7JywgJyMnXS5jb25jYXQoVXJsLmF1dG9Fc2NhcGUpO1xuVXJsLmhvc3RuYW1lUGFydFBhdHRlcm4gPSAvXlsrYS16MC05QS1aXy1dezAsNjN9JC87XG5VcmwuaG9zdG5hbWVQYXJ0U3RhcnQgPSAvXihbK2EtejAtOUEtWl8tXXswLDYzfSkoLiopJC87XG5VcmwuaG9zdG5hbWVNYXhMZW4gPSAyNTU7XG5VcmwudW5zYWZlUHJvdG9jb2wgPSB7XG4gICAgJ2phdmFzY3JpcHQnOiB0cnVlLFxuICAgICdqYXZhc2NyaXB0Oic6IHRydWVcbn07XG5leHBvcnRzLlVybCA9IFVybDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY2xhc3MgVXRpbHNTZXR0aW5ncyB7XG4gICAgc3RhdGljIHJlbW92ZUl0ZW1zKGFyciwgc3RhcnRJZHgsIHJlbW92ZUNvdW50KSB7XG4gICAgICAgIHZhciBsZW5ndGggPSBhcnIubGVuZ3RoO1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgaWYgKHN0YXJ0SWR4ID49IGxlbmd0aCB8fCByZW1vdmVDb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJlbW92ZUNvdW50ID0gKHN0YXJ0SWR4ICsgcmVtb3ZlQ291bnQgPiBsZW5ndGggPyBsZW5ndGggLSBzdGFydElkeCA6IHJlbW92ZUNvdW50KTtcbiAgICAgICAgdmFyIGxlbiA9IGxlbmd0aCAtIHJlbW92ZUNvdW50O1xuICAgICAgICBmb3IgKGkgPSBzdGFydElkeDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICBhcnJbaV0gPSBhcnJbaSArIHJlbW92ZUNvdW50XTtcbiAgICAgICAgfVxuICAgICAgICBhcnIubGVuZ3RoID0gbGVuO1xuICAgIH1cbiAgICBzdGF0aWMgZGVlcENvcHlQcm9wZXJ0aWVzKHRhcmdldCwgc291cmNlLCBwcm9wZXJ0eU9iaikge1xuICAgICAgICBmb3IgKHZhciBwcm9wIGluIHByb3BlcnR5T2JqKSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzb3VyY2VbcHJvcF0pKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W3Byb3BdID0gc291cmNlW3Byb3BdLnNsaWNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRbcHJvcF0gPSBzb3VyY2VbcHJvcF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIGFyZUFycmF5c0VxdWFsKGFycmF5MSwgYXJyYXkyKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShhcnJheTEpIHx8ICFBcnJheS5pc0FycmF5KGFycmF5MikpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXJyYXkxLmxlbmd0aCAhPT0gYXJyYXkyLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkxLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBpZiAoYXJyYXkxW2ldICE9PSBhcnJheTJbaV0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHN0YXRpYyB1bnNhZmVFdmFsU3VwcG9ydGVkKCkge1xuICAgICAgICBpZiAodHlwZW9mIFV0aWxzU2V0dGluZ3MudW5zYWZlRXZhbCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICByZXR1cm4gVXRpbHNTZXR0aW5ncy51bnNhZmVFdmFsO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgZnVuYyA9IG5ldyBGdW5jdGlvbigncGFyYW0xJywgJ3BhcmFtMicsICdwYXJhbTMnLCAncmV0dXJuIHBhcmFtMVtwYXJhbTJdID09PSBwYXJhbTM7Jyk7XG4gICAgICAgICAgICBVdGlsc1NldHRpbmdzLnVuc2FmZUV2YWwgPSBmdW5jKHsgYTogJ2InIH0sICdhJywgJ2InKSA9PT0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgVXRpbHNTZXR0aW5ncy51bnNhZmVFdmFsID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFV0aWxzU2V0dGluZ3MudW5zYWZlRXZhbDtcbiAgICB9XG4gICAgc3RhdGljIGlzV2ViR0xTdXBwb3J0ZWQoKSB7XG4gICAgICAgIHZhciBjb250ZXh0T3B0aW9ucyA9IHsgc3RlbmNpbDogdHJ1ZSwgZmFpbElmTWFqb3JQZXJmb3JtYW5jZUNhdmVhdDogdHJ1ZSB9O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKCF3aW5kb3dbJ1dlYkdMUmVuZGVyaW5nQ29udGV4dCddKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICAgICAgdmFyIGdsID0gY2FudmFzLmdldENvbnRleHQoJ3dlYmdsJywgY29udGV4dE9wdGlvbnMpIHx8IGNhbnZhcy5nZXRDb250ZXh0KCdleHBlcmltZW50YWwtd2ViZ2wnLCBjb250ZXh0T3B0aW9ucyk7XG4gICAgICAgICAgICB2YXIgc3VjY2VzcyA9ICEhKGdsICYmIGdsLmdldENvbnRleHRBdHRyaWJ1dGVzKCkuc3RlbmNpbCk7XG4gICAgICAgICAgICBpZiAoZ2wpIHtcbiAgICAgICAgICAgICAgICB2YXIgbG9zZUNvbnRleHQgPSBnbC5nZXRFeHRlbnNpb24oJ1dFQkdMX2xvc2VfY29udGV4dCcpO1xuICAgICAgICAgICAgICAgIGlmIChsb3NlQ29udGV4dCkge1xuICAgICAgICAgICAgICAgICAgICBsb3NlQ29udGV4dC5sb3NlQ29udGV4dCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdsID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiBzdWNjZXNzO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG59XG5VdGlsc1NldHRpbmdzLnV0aWwgPSB7XG4gICAgaXNTdHJpbmc6IGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiAoYXJnKSA9PT0gJ3N0cmluZyc7XG4gICAgfSxcbiAgICBpc09iamVjdDogZnVuY3Rpb24gKGFyZykge1xuICAgICAgICByZXR1cm4gdHlwZW9mIChhcmcpID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG4gICAgfSxcbiAgICBpc051bGw6IGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgICAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcbiAgICB9LFxuICAgIGlzTnVsbE9yVW5kZWZpbmVkOiBmdW5jdGlvbiAoYXJnKSB7XG4gICAgICAgIHJldHVybiBhcmcgPT0gbnVsbDtcbiAgICB9XG59O1xuZXhwb3J0cy5VdGlsc1NldHRpbmdzID0gVXRpbHNTZXR0aW5ncztcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgQmFzZUltYWdlUmVzb3VyY2VfMSA9IHJlcXVpcmUoXCIuL0Jhc2VJbWFnZVJlc291cmNlXCIpO1xuY29uc3QgVGlja2VyXzEgPSByZXF1aXJlKFwiLi9UaWNrZXJcIik7XG5jbGFzcyBWaWRlb1Jlc291cmNlIGV4dGVuZHMgQmFzZUltYWdlUmVzb3VyY2VfMS5CYXNlSW1hZ2VSZXNvdXJjZSB7XG4gICAgY29uc3RydWN0b3Ioc291cmNlLCBvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICAvLyB0aHJvdyBcInN0b3BcIlxuICAgICAgICBpZiAoIShzb3VyY2UgaW5zdGFuY2VvZiBIVE1MVmlkZW9FbGVtZW50KSkge1xuICAgICAgICAgICAgdmFyIHZpZGVvRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3ZpZGVvJyk7XG4gICAgICAgICAgICB2aWRlb0VsZW1lbnQuc2V0QXR0cmlidXRlKCd3ZWJraXQtcGxheXNpbmxpbmUnLCAnJyk7XG4gICAgICAgICAgICB2aWRlb0VsZW1lbnQuc2V0QXR0cmlidXRlKCdwbGF5c2lubGluZScsICcnKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc291cmNlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHNvdXJjZSA9IFtzb3VyY2VdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgQmFzZUltYWdlUmVzb3VyY2VfMS5CYXNlSW1hZ2VSZXNvdXJjZS5jcm9zc09yaWdpbih2aWRlb0VsZW1lbnQsIChzb3VyY2VbMF0uc3JjIHx8IHNvdXJjZVswXSksIG9wdGlvbnMuY3Jvc3NvcmlnaW4pO1xuICAgICAgICAgICAgLy8gYXJyYXkgb2Ygb2JqZWN0cyBvciBzdHJpbmdzXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNvdXJjZS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIHZhciBzb3VyY2VFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc291cmNlJyk7XG4gICAgICAgICAgICAgICAgdmFyIHJlZiA9IHNvdXJjZVtpXTtcbiAgICAgICAgICAgICAgICB2YXIgc3JjID0gcmVmLnNyYztcbiAgICAgICAgICAgICAgICB2YXIgbWltZSA9IHJlZi5taW1lO1xuICAgICAgICAgICAgICAgIHNyYyA9IHNyYyB8fCBzb3VyY2VbaV07XG4gICAgICAgICAgICAgICAgdmFyIGJhc2VTcmMgPSBzcmMuc3BsaXQoJz8nKS5zaGlmdCgpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgdmFyIGV4dCA9IGJhc2VTcmMuc3Vic3RyKGJhc2VTcmMubGFzdEluZGV4T2YoJy4nKSArIDEpO1xuICAgICAgICAgICAgICAgIG1pbWUgPSBtaW1lIHx8IChcInZpZGVvL1wiICsgZXh0KTtcbiAgICAgICAgICAgICAgICBzb3VyY2VFbGVtZW50LnNyYyA9IHNyYztcbiAgICAgICAgICAgICAgICBzb3VyY2VFbGVtZW50LnR5cGUgPSBtaW1lO1xuICAgICAgICAgICAgICAgIHZpZGVvRWxlbWVudC5hcHBlbmRDaGlsZChzb3VyY2VFbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE92ZXJyaWRlIHRoZSBzb3VyY2VcbiAgICAgICAgICAgIHNvdXJjZSA9IHZpZGVvRWxlbWVudDtcbiAgICAgICAgfVxuICAgICAgICBzdXBlcihzb3VyY2UpO1xuICAgICAgICB0aGlzLmNhblVwbG9hZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9hdXRvVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5faXNBdXRvVXBkYXRpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fdXBkYXRlRlBTID0gb3B0aW9ucy51cGRhdGVGUFMgfHwgMDtcbiAgICAgICAgdGhpcy5fbXNUb05leHRVcGRhdGUgPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hlbiBzZXQgdG8gdHJ1ZSB3aWxsIGF1dG9tYXRpY2FsbHkgcGxheSB2aWRlb3MgdXNlZCBieSB0aGlzIHRleHR1cmUgb25jZVxuICAgICAgICAgKiB0aGV5IGFyZSBsb2FkZWQuIElmIGZhbHNlLCBpdCB3aWxsIG5vdCBtb2RpZnkgdGhlIHBsYXlpbmcgc3RhdGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZW1iZXIge2Jvb2xlYW59XG4gICAgICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYXV0b1BsYXkgPSBvcHRpb25zLmF1dG9QbGF5ICE9PSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByb21pc2Ugd2hlbiBsb2FkaW5nXG4gICAgICAgICAqIEBtZW1iZXIge1Byb21pc2U8dm9pZD59XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2xvYWQgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2FsbGJhY2sgd2hlbiBjb21wbGV0ZWQgd2l0aCBsb2FkLlxuICAgICAgICAgKiBAbWVtYmVyIHtmdW5jdGlvbn1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3Jlc29sdmUgPSBudWxsO1xuICAgICAgICAvLyBCaW5kIGZvciBsaXN0ZW5lcnNcbiAgICAgICAgdGhpcy5fb25DYW5QbGF5ID0gdGhpcy5fb25DYW5QbGF5LmJpbmQodGhpcyk7XG4gICAgICAgIGlmIChvcHRpb25zLmF1dG9Mb2FkICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgdGhpcy5sb2FkKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJpZ2dlciB1cGRhdGluZyBvZiB0aGUgdGV4dHVyZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtkZWx0YVRpbWU9MF0gLSB0aW1lIGRlbHRhIHNpbmNlIGxhc3QgdGlja1xuICAgICAqL1xuICAgIHVwZGF0ZShkZWx0YVRpbWUgPSAwKSB7XG4gICAgICAgIGlmICghdGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgIC8vIGFjY291bnQgZm9yIGlmIHZpZGVvIGhhcyBoYWQgaXRzIHBsYXliYWNrUmF0ZSBjaGFuZ2VkXG4gICAgICAgICAgICB2YXIgZWxhcHNlZE1TID0gVGlja2VyXzEuVGlja2VyLnNoYXJlZC5lbGFwc2VkTVMgKiB0aGlzLnNvdXJjZS5wbGF5YmFja1JhdGU7XG4gICAgICAgICAgICB0aGlzLl9tc1RvTmV4dFVwZGF0ZSA9IE1hdGguZmxvb3IodGhpcy5fbXNUb05leHRVcGRhdGUgLSBlbGFwc2VkTVMpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLl91cGRhdGVGUFMgfHwgdGhpcy5fbXNUb05leHRVcGRhdGUgPD0gMCkge1xuICAgICAgICAgICAgICAgIHN1cGVyLnVwZGF0ZShkZWx0YVRpbWUpO1xuICAgICAgICAgICAgICAgIHRoaXMuX21zVG9OZXh0VXBkYXRlID0gdGhpcy5fdXBkYXRlRlBTID8gTWF0aC5mbG9vcigxMDAwIC8gdGhpcy5fdXBkYXRlRlBTKSA6IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFN0YXJ0IHByZWxvYWRpbmcgdGhlIHZpZGVvIHJlc291cmNlLlxuICAgICAqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEByZXR1cm4ge1Byb21pc2U8dm9pZD59IEhhbmRsZSB0aGUgdmFsaWRhdGUgZXZlbnRcbiAgICAgKi9cbiAgICBsb2FkKCkge1xuICAgICAgICB2YXIgdGhpcyQxID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMuX2xvYWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9sb2FkO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzb3VyY2UgPSB0aGlzLnNvdXJjZTtcbiAgICAgICAgaWYgKChzb3VyY2UucmVhZHlTdGF0ZSA9PT0gc291cmNlLkhBVkVfRU5PVUdIX0RBVEEgfHwgc291cmNlLnJlYWR5U3RhdGUgPT09IHNvdXJjZS5IQVZFX0ZVVFVSRV9EQVRBKVxuICAgICAgICAgICAgJiYgc291cmNlLndpZHRoICYmIHNvdXJjZS5oZWlnaHQpIHtcbiAgICAgICAgICAgIHNvdXJjZS5jb21wbGV0ZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgc291cmNlLmFkZEV2ZW50TGlzdGVuZXIoJ3BsYXknLCB0aGlzLl9vblBsYXlTdGFydC5iaW5kKHRoaXMpKTtcbiAgICAgICAgc291cmNlLmFkZEV2ZW50TGlzdGVuZXIoJ3BhdXNlJywgdGhpcy5fb25QbGF5U3RvcC5iaW5kKHRoaXMpKTtcbiAgICAgICAgaWYgKCF0aGlzLl9pc1NvdXJjZVJlYWR5KCkpIHtcbiAgICAgICAgICAgIHNvdXJjZS5hZGRFdmVudExpc3RlbmVyKCdjYW5wbGF5JywgdGhpcy5fb25DYW5QbGF5KTtcbiAgICAgICAgICAgIHNvdXJjZS5hZGRFdmVudExpc3RlbmVyKCdjYW5wbGF5dGhyb3VnaCcsIHRoaXMuX29uQ2FuUGxheSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9vbkNhblBsYXkoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9sb2FkID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzJDEudmFsaWQpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKHRoaXMkMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzJDEuX3Jlc29sdmUgPSByZXNvbHZlO1xuICAgICAgICAgICAgICAgIHNvdXJjZS5sb2FkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5fbG9hZDtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgdW5kZXJseWluZyBzb3VyY2UgaXMgcGxheWluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBwbGF5aW5nLlxuICAgICAqL1xuICAgIF9pc1NvdXJjZVBsYXlpbmcoKSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSB0aGlzLnNvdXJjZTtcbiAgICAgICAgcmV0dXJuIChzb3VyY2UuY3VycmVudFRpbWUgPiAwICYmIHNvdXJjZS5wYXVzZWQgPT09IGZhbHNlICYmIHNvdXJjZS5lbmRlZCA9PT0gZmFsc2UgJiYgc291cmNlLnJlYWR5U3RhdGUgPiAyKTtcbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgdW5kZXJseWluZyBzb3VyY2UgaXMgcmVhZHkgZm9yIHBsYXlpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgcmVhZHkuXG4gICAgICovXG4gICAgX2lzU291cmNlUmVhZHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNvdXJjZS5yZWFkeVN0YXRlID09PSAzIHx8IHRoaXMuc291cmNlLnJlYWR5U3RhdGUgPT09IDQ7XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBSdW5zIHRoZSB1cGRhdGUgbG9vcCB3aGVuIHRoZSB2aWRlbyBpcyByZWFkeSB0byBwbGF5XG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9vblBsYXlTdGFydCgpIHtcbiAgICAgICAgLy8gSnVzdCBpbiBjYXNlIHRoZSB2aWRlbyBoYXMgbm90IHJlY2VpdmVkIGl0cyBjYW4gcGxheSBldmVuIHlldC4uXG4gICAgICAgIGlmICghdGhpcy52YWxpZCkge1xuICAgICAgICAgICAgdGhpcy5fb25DYW5QbGF5KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9pc0F1dG9VcGRhdGluZyAmJiB0aGlzLmF1dG9VcGRhdGUpIHtcbiAgICAgICAgICAgIFRpY2tlcl8xLlRpY2tlci5zaGFyZWQuYWRkKHRoaXMudXBkYXRlLCB0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuX2lzQXV0b1VwZGF0aW5nID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogRmlyZWQgd2hlbiBhIHBhdXNlIGV2ZW50IGlzIHRyaWdnZXJlZCwgc3RvcHMgdGhlIHVwZGF0ZSBsb29wXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9vblBsYXlTdG9wKCkge1xuICAgICAgICBpZiAodGhpcy5faXNBdXRvVXBkYXRpbmcpIHtcbiAgICAgICAgICAgIFRpY2tlcl8xLlRpY2tlci5zaGFyZWQucmVtb3ZlKHRoaXMudXBkYXRlLCB0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuX2lzQXV0b1VwZGF0aW5nID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIEZpcmVkIHdoZW4gdGhlIHZpZGVvIGlzIGxvYWRlZCBhbmQgcmVhZHkgdG8gcGxheVxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfb25DYW5QbGF5KCkge1xuICAgICAgICB2YXIgcmVmID0gdGhpcztcbiAgICAgICAgdmFyIHNvdXJjZSA9IHJlZi5zb3VyY2U7XG4gICAgICAgIHNvdXJjZS5yZW1vdmVFdmVudExpc3RlbmVyKCdjYW5wbGF5JywgdGhpcy5fb25DYW5QbGF5KTtcbiAgICAgICAgc291cmNlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NhbnBsYXl0aHJvdWdoJywgdGhpcy5fb25DYW5QbGF5KTtcbiAgICAgICAgdmFyIHZhbGlkID0gdGhpcy52YWxpZDtcbiAgICAgICAgdGhpcy5yZXNpemUoc291cmNlLnZpZGVvV2lkdGgsIHNvdXJjZS52aWRlb0hlaWdodCk7XG4gICAgICAgIC8vIHByZXZlbnQgbXVsdGlwbGUgbG9hZGVkIGRpc3BhdGNoZXMuLlxuICAgICAgICBpZiAoIXZhbGlkICYmIHRoaXMuX3Jlc29sdmUpIHtcbiAgICAgICAgICAgIHRoaXMuX3Jlc29sdmUodGhpcyk7XG4gICAgICAgICAgICB0aGlzLl9yZXNvbHZlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5faXNTb3VyY2VQbGF5aW5nKCkpIHtcbiAgICAgICAgICAgIHRoaXMuX29uUGxheVN0YXJ0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5hdXRvUGxheSkge1xuICAgICAgICAgICAgc291cmNlLnBsYXkoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogRGVzdHJveXMgdGhpcyB0ZXh0dXJlXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgZGlzcG9zZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzQXV0b1VwZGF0aW5nKSB7XG4gICAgICAgICAgICBUaWNrZXJfMS5UaWNrZXIuc2hhcmVkLnJlbW92ZSh0aGlzLnVwZGF0ZSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc291cmNlKSB7XG4gICAgICAgICAgICB0aGlzLnNvdXJjZS5wYXVzZSgpO1xuICAgICAgICAgICAgdGhpcy5zb3VyY2Uuc3JjID0gJyc7XG4gICAgICAgICAgICB0aGlzLnNvdXJjZS5sb2FkKCk7XG4gICAgICAgIH1cbiAgICAgICAgQmFzZUltYWdlUmVzb3VyY2VfMS5CYXNlSW1hZ2VSZXNvdXJjZS5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuICAgIH1cbiAgICA7XG4gICAgLyoqXG4gICAgICogU2hvdWxkIHRoZSBiYXNlIHRleHR1cmUgYXV0b21hdGljYWxseSB1cGRhdGUgaXRzZWxmLCBzZXQgdG8gdHJ1ZSBieSBkZWZhdWx0XG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtib29sZWFufVxuICAgICAqL1xuICAgIGdldCBhdXRvVXBkYXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYXV0b1VwZGF0ZTtcbiAgICB9XG4gICAgO1xuICAgIHNldCBhdXRvVXBkYXRlKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdGhpcy5fYXV0b1VwZGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5fYXV0b1VwZGF0ZSA9IHZhbHVlO1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9hdXRvVXBkYXRlICYmIHRoaXMuX2lzQXV0b1VwZGF0aW5nKSB7XG4gICAgICAgICAgICAgICAgVGlja2VyXzEuVGlja2VyLnNoYXJlZC5yZW1vdmUodGhpcy51cGRhdGUsIHRoaXMpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2lzQXV0b1VwZGF0aW5nID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLl9hdXRvVXBkYXRlICYmICF0aGlzLl9pc0F1dG9VcGRhdGluZykge1xuICAgICAgICAgICAgICAgIFRpY2tlcl8xLlRpY2tlci5zaGFyZWQuYWRkKHRoaXMudXBkYXRlLCB0aGlzKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9pc0F1dG9VcGRhdGluZyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgO1xuICAgIC8qKlxuICAgICAqIEhvdyBtYW55IHRpbWVzIGEgc2Vjb25kIHRvIHVwZGF0ZSB0aGUgdGV4dHVyZSBmcm9tIHRoZSB2aWRlby4gTGVhdmUgYXQgMCB0byB1cGRhdGUgYXQgZXZlcnkgcmVuZGVyLlxuICAgICAqIEEgbG93ZXIgZnBzIGNhbiBoZWxwIHBlcmZvcm1hbmNlLCBhcyB1cGRhdGluZyB0aGUgdGV4dHVyZSBhdCA2MGZwcyBvbiBhIDMwcHMgdmlkZW8gbWF5IG5vdCBiZSBlZmZpY2llbnQuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAgICovXG4gICAgZ2V0IHVwZGF0ZUZQUygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3VwZGF0ZUZQUztcbiAgICB9XG4gICAgO1xuICAgIHNldCB1cGRhdGVGUFModmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB0aGlzLl91cGRhdGVGUFMpIHtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUZQUyA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIDtcbiAgICAvKipcbiAgICAgKiBVc2VkIHRvIGF1dG8tZGV0ZWN0IHRoZSB0eXBlIG9mIHJlc291cmNlLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7Kn0gc291cmNlIC0gVGhlIHNvdXJjZSBvYmplY3RcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXh0ZW5zaW9uIC0gVGhlIGV4dGVuc2lvbiBvZiBzb3VyY2UsIGlmIHNldFxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IGB0cnVlYCBpZiB2aWRlbyBzb3VyY2VcbiAgICAgKi9cbiAgICBzdGF0aWMgdGVzdChzb3VyY2UsIGV4dGVuc2lvbikge1xuICAgICAgICByZXR1cm4gKHNvdXJjZSBpbnN0YW5jZW9mIEhUTUxWaWRlb0VsZW1lbnQpXG4gICAgICAgICAgICB8fCBWaWRlb1Jlc291cmNlLlRZUEVTLmluZGV4T2YoZXh0ZW5zaW9uKSA+IC0xO1xuICAgIH1cbiAgICA7XG59XG5WaWRlb1Jlc291cmNlLlRZUEVTID0gWydtcDQnLCAnbTR2JywgJ3dlYm0nLCAnb2dnJywgJ29ndicsICdoMjY0JywgJ2F2aScsICdtb3YnXTtcbmV4cG9ydHMuVmlkZW9SZXNvdXJjZSA9IFZpZGVvUmVzb3VyY2U7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IFByb2dyYW1fMSA9IHJlcXVpcmUoXCIuL1Byb2dyYW1cIik7XG5jb25zdCBNYXRyaXhfMSA9IHJlcXVpcmUoXCIuL01hdHJpeFwiKTtcbmNvbnN0IFNoYWRlcl8xID0gcmVxdWlyZShcIi4vU2hhZGVyXCIpO1xuY29uc3QgQ2FjaGVTZXR0aW5nc18xID0gcmVxdWlyZShcIi4vQ2FjaGVTZXR0aW5nc1wiKTtcbmNvbnN0IFVuaWZvcm1Hcm91cF8xID0gcmVxdWlyZShcIi4vVW5pZm9ybUdyb3VwXCIpO1xuY29uc3QgRGlzcGxheVNldHRpbmdzXzEgPSByZXF1aXJlKFwiLi9EaXNwbGF5U2V0dGluZ3NcIik7XG5jbGFzcyBXZWJHTFNldHRpbmdzIHtcbiAgICBzdGF0aWMgY3JlYXRlSW5kaWNlc0ZvclF1YWRzKHNpemUpIHtcbiAgICAgICAgdmFyIHRvdGFsSW5kaWNlcyA9IHNpemUgKiA2O1xuICAgICAgICB2YXIgaW5kaWNlcyA9IG5ldyBVaW50MTZBcnJheSh0b3RhbEluZGljZXMpO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgaiA9IDA7IGkgPCB0b3RhbEluZGljZXM7IGkgKz0gNiwgaiArPSA0KSB7XG4gICAgICAgICAgICBpbmRpY2VzW2kgKyAwXSA9IGogKyAwO1xuICAgICAgICAgICAgaW5kaWNlc1tpICsgMV0gPSBqICsgMTtcbiAgICAgICAgICAgIGluZGljZXNbaSArIDJdID0gaiArIDI7XG4gICAgICAgICAgICBpbmRpY2VzW2kgKyAzXSA9IGogKyAwO1xuICAgICAgICAgICAgaW5kaWNlc1tpICsgNF0gPSBqICsgMjtcbiAgICAgICAgICAgIGluZGljZXNbaSArIDVdID0gaiArIDM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluZGljZXM7XG4gICAgfVxuICAgIHN0YXRpYyBjYW5VcGxvYWRTYW1lQnVmZmVyKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgc3RhdGljIGdlbmVyYXRlTXVsdGlUZXh0dXJlU2hhZGVyKGdsLCBtYXhUZXh0dXJlcykge1xuICAgICAgICBpZiAoIUNhY2hlU2V0dGluZ3NfMS5DYWNoZVNldHRpbmdzLnByb2dyYW1DYWNoZVttYXhUZXh0dXJlc10pIHtcbiAgICAgICAgICAgIHZhciBzYW1wbGVWYWx1ZXMgPSBuZXcgSW50MzJBcnJheShtYXhUZXh0dXJlcyk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1heFRleHR1cmVzOyBpKyspIHtcbiAgICAgICAgICAgICAgICBzYW1wbGVWYWx1ZXNbaV0gPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgQ2FjaGVTZXR0aW5nc18xLkNhY2hlU2V0dGluZ3MuZGVmYXVsdEdyb3VwQ2FjaGVbbWF4VGV4dHVyZXNdID0gVW5pZm9ybUdyb3VwXzEuVW5pZm9ybUdyb3VwLmZyb20oeyB1U2FtcGxlcnM6IHNhbXBsZVZhbHVlcyB9LCB0cnVlKTtcbiAgICAgICAgICAgIHZhciBmcmFnbWVudFNyYyA9IFdlYkdMU2V0dGluZ3MuZnJhZ1RlbXBsYXRlJDE7XG4gICAgICAgICAgICBmcmFnbWVudFNyYyA9IGZyYWdtZW50U3JjLnJlcGxhY2UoLyVjb3VudCUvZ2ksIG1heFRleHR1cmVzKTtcbiAgICAgICAgICAgIGZyYWdtZW50U3JjID0gZnJhZ21lbnRTcmMucmVwbGFjZSgvJWZvcmxvb3AlL2dpLCBXZWJHTFNldHRpbmdzLmdlbmVyYXRlU2FtcGxlU3JjKG1heFRleHR1cmVzKSk7XG4gICAgICAgICAgICBDYWNoZVNldHRpbmdzXzEuQ2FjaGVTZXR0aW5ncy5wcm9ncmFtQ2FjaGVbbWF4VGV4dHVyZXNdID0gbmV3IFByb2dyYW1fMS5Qcm9ncmFtKFdlYkdMU2V0dGluZ3MudmVydGV4JDEsIGZyYWdtZW50U3JjKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdW5pZm9ybXMgPSB7XG4gICAgICAgICAgICB0aW50OiBuZXcgRmxvYXQzMkFycmF5KFsxLCAxLCAxLCAxXSksXG4gICAgICAgICAgICB0cmFuc2xhdGlvbk1hdHJpeDogbmV3IE1hdHJpeF8xLk1hdHJpeCgpLFxuICAgICAgICAgICAgZGVmYXVsdDogQ2FjaGVTZXR0aW5nc18xLkNhY2hlU2V0dGluZ3MuZGVmYXVsdEdyb3VwQ2FjaGVbbWF4VGV4dHVyZXNdLFxuICAgICAgICB9O1xuICAgICAgICB2YXIgc2hhZGVyID0gbmV3IFNoYWRlcl8xLlNoYWRlcihDYWNoZVNldHRpbmdzXzEuQ2FjaGVTZXR0aW5ncy5wcm9ncmFtQ2FjaGVbbWF4VGV4dHVyZXNdLCB1bmlmb3Jtcyk7XG4gICAgICAgIHJldHVybiBzaGFkZXI7XG4gICAgfVxuICAgIHN0YXRpYyBnZW5lcmF0ZVNhbXBsZVNyYyhtYXhUZXh0dXJlcykge1xuICAgICAgICB2YXIgc3JjID0gJyc7XG4gICAgICAgIHNyYyArPSAnXFxuJztcbiAgICAgICAgc3JjICs9ICdcXG4nO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1heFRleHR1cmVzOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgICAgICAgIHNyYyArPSAnXFxuZWxzZSAnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGkgPCBtYXhUZXh0dXJlcyAtIDEpIHtcbiAgICAgICAgICAgICAgICBzcmMgKz0gXCJpZih2VGV4dHVyZUlkIDwgXCIgKyBpICsgXCIuNSlcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNyYyArPSAnXFxueyc7XG4gICAgICAgICAgICBzcmMgKz0gXCJcXG5cXHRjb2xvciA9IHRleHR1cmUyRCh1U2FtcGxlcnNbXCIgKyBpICsgXCJdLCB2VGV4dHVyZUNvb3JkKTtcIjtcbiAgICAgICAgICAgIHNyYyArPSAnXFxufSc7XG4gICAgICAgIH1cbiAgICAgICAgc3JjICs9ICdcXG4nO1xuICAgICAgICBzcmMgKz0gJ1xcbic7XG4gICAgICAgIHJldHVybiBzcmM7XG4gICAgfVxuICAgIHN0YXRpYyBjaGVja01heElmU3RhdGVtZW50c0luU2hhZGVyKG1heElmcywgZ2wpIHtcbiAgICAgICAgaWYgKG1heElmcyA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHZhbHVlIG9mIGAwYCBwYXNzZWQgdG8gYGNoZWNrTWF4SWZTdGF0ZW1lbnRzSW5TaGFkZXJgJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNoYWRlciA9IGdsLmNyZWF0ZVNoYWRlcihnbC5GUkFHTUVOVF9TSEFERVIpO1xuICAgICAgICB3aGlsZSAodHJ1ZSkgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zdGFudC1jb25kaXRpb25cbiAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBmcmFnbWVudFNyYyA9IFdlYkdMU2V0dGluZ3MuZnJhZ1RlbXBsYXRlLnJlcGxhY2UoLyVmb3Jsb29wJS9naSwgV2ViR0xTZXR0aW5ncy5nZW5lcmF0ZUlmVGVzdFNyYyhtYXhJZnMpKTtcbiAgICAgICAgICAgIGdsLnNoYWRlclNvdXJjZShzaGFkZXIsIGZyYWdtZW50U3JjKTtcbiAgICAgICAgICAgIGdsLmNvbXBpbGVTaGFkZXIoc2hhZGVyKTtcbiAgICAgICAgICAgIGlmICghZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKHNoYWRlciwgZ2wuQ09NUElMRV9TVEFUVVMpKSB7XG4gICAgICAgICAgICAgICAgbWF4SWZzID0gKG1heElmcyAvIDIpIHwgMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHZhbGlkIVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXhJZnM7XG4gICAgfVxuICAgIHN0YXRpYyBnZW5lcmF0ZUlmVGVzdFNyYyhtYXhJZnMpIHtcbiAgICAgICAgdmFyIHNyYyA9ICcnO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1heElmczsgKytpKSB7XG4gICAgICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICAgICAgICBzcmMgKz0gJ1xcbmVsc2UgJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpIDwgbWF4SWZzIC0gMSkge1xuICAgICAgICAgICAgICAgIHNyYyArPSBcImlmKHRlc3QgPT0gXCIgKyBpICsgXCIuMCl7fVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzcmM7XG4gICAgfVxuICAgIHN0YXRpYyBtYXhSZWNvbW1lbmRlZFRleHR1cmVzKG1heCkge1xuICAgICAgICB2YXIgYWxsb3dNYXggPSB0cnVlO1xuICAgICAgICB2YXIgbWF0Y2ggPSAobmF2aWdhdG9yLnVzZXJBZ2VudCkubWF0Y2goL09TIChcXGQrKV8oXFxkKyk/Lyk7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgdmFyIG1ham9yVmVyc2lvbiA9IHBhcnNlSW50KG1hdGNoWzFdLCAxMCk7XG4gICAgICAgICAgICBpZiAobWFqb3JWZXJzaW9uID49IDExKSB7XG4gICAgICAgICAgICAgICAgYWxsb3dNYXggPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBtYXRjaCQxID0gKG5hdmlnYXRvci51c2VyQWdlbnQpLm1hdGNoKC9BbmRyb2lkXFxzKFswLTkuXSopLyk7XG4gICAgICAgIGlmIChtYXRjaCQxKSB7XG4gICAgICAgICAgICB2YXIgbWFqb3JWZXJzaW9uJDEgPSBwYXJzZUludChtYXRjaCQxWzFdLCAxMCk7XG4gICAgICAgICAgICBpZiAobWFqb3JWZXJzaW9uJDEgPj0gNykge1xuICAgICAgICAgICAgICAgIGFsbG93TWF4ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWxsb3dNYXggPyBtYXggOiA0O1xuICAgIH1cbiAgICBzdGF0aWMgc2V0UHJlY2lzaW9uKHNyYywgcHJlY2lzaW9uKSB7XG4gICAgICAgIGlmIChzcmMuc3Vic3RyaW5nKDAsIDkpICE9PSAncHJlY2lzaW9uJykgLy8gJiYgc3JjLnN1YnN0cmluZygwLCAxKSAhPT0gJyMnKVxuICAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIChcInByZWNpc2lvbiBcIiArIHByZWNpc2lvbiArIFwiIGZsb2F0O1xcblwiICsgc3JjKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3JjO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0VGVzdENvbnRleHQoKSB7XG4gICAgICAgIGlmICghV2ViR0xTZXR0aW5ncy5jb250ZXh0KSB7XG4gICAgICAgICAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgICAgICB2YXIgZ2w7XG4gICAgICAgICAgICBpZiAoRGlzcGxheVNldHRpbmdzXzEuRGlzcGxheVNldHRpbmdzLlBSRUZFUl9FTlYgPj0gRGlzcGxheVNldHRpbmdzXzEuRGlzcGxheVNldHRpbmdzLkVOVi5XRUJHTDIpIHtcbiAgICAgICAgICAgICAgICBnbCA9IGNhbnZhcy5nZXRDb250ZXh0KCd3ZWJnbDInLCB7fSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWdsKSB7XG4gICAgICAgICAgICAgICAgZ2wgPSBjYW52YXMuZ2V0Q29udGV4dCgnd2ViZ2wnLCB7fSlcbiAgICAgICAgICAgICAgICAgICAgfHwgY2FudmFzLmdldENvbnRleHQoJ2V4cGVyaW1lbnRhbC13ZWJnbCcsIHt9KTtcbiAgICAgICAgICAgICAgICBpZiAoIWdsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGZhaWwsIG5vdCBhYmxlIHRvIGdldCBhIGNvbnRleHRcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBXZWJHTC4gVHJ5IHVzaW5nIHRoZSBjYW52YXMgcmVuZGVyZXInKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGZvciBzaGFkZXIgdGVzdGluZy4uXG4gICAgICAgICAgICAgICAgICAgIGdsLmdldEV4dGVuc2lvbignV0VCR0xfZHJhd19idWZmZXJzJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgV2ViR0xTZXR0aW5ncy5jb250ZXh0ID0gZ2w7XG4gICAgICAgICAgICByZXR1cm4gZ2w7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFdlYkdMU2V0dGluZ3MuY29udGV4dDtcbiAgICB9XG4gICAgc3RhdGljIGRlZmF1bHRWYWx1ZSh0eXBlLCBzaXplKSB7XG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnZmxvYXQnOlxuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgY2FzZSAndmVjMic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoMiAqIHNpemUpO1xuICAgICAgICAgICAgY2FzZSAndmVjMyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoMyAqIHNpemUpO1xuICAgICAgICAgICAgY2FzZSAndmVjNCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoNCAqIHNpemUpO1xuICAgICAgICAgICAgY2FzZSAnaW50JzpcbiAgICAgICAgICAgIGNhc2UgJ3NhbXBsZXIyRCc6XG4gICAgICAgICAgICBjYXNlICdzYW1wbGVyMkRBcnJheSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICBjYXNlICdpdmVjMic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBJbnQzMkFycmF5KDIgKiBzaXplKTtcbiAgICAgICAgICAgIGNhc2UgJ2l2ZWMzJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEludDMyQXJyYXkoMyAqIHNpemUpO1xuICAgICAgICAgICAgY2FzZSAnaXZlYzQnOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgSW50MzJBcnJheSg0ICogc2l6ZSk7XG4gICAgICAgICAgICBjYXNlICdib29sJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBjYXNlICdidmVjMic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFdlYkdMU2V0dGluZ3MuYm9vbGVhbkFycmF5KDIgKiBzaXplKTtcbiAgICAgICAgICAgIGNhc2UgJ2J2ZWMzJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gV2ViR0xTZXR0aW5ncy5ib29sZWFuQXJyYXkoMyAqIHNpemUpO1xuICAgICAgICAgICAgY2FzZSAnYnZlYzQnOlxuICAgICAgICAgICAgICAgIHJldHVybiBXZWJHTFNldHRpbmdzLmJvb2xlYW5BcnJheSg0ICogc2l6ZSk7XG4gICAgICAgICAgICBjYXNlICdtYXQyJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEZsb2F0MzJBcnJheShbMSwgMCxcbiAgICAgICAgICAgICAgICAgICAgMCwgMV0pO1xuICAgICAgICAgICAgY2FzZSAnbWF0Myc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoWzEsIDAsIDAsXG4gICAgICAgICAgICAgICAgICAgIDAsIDEsIDAsXG4gICAgICAgICAgICAgICAgICAgIDAsIDAsIDFdKTtcbiAgICAgICAgICAgIGNhc2UgJ21hdDQnOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRmxvYXQzMkFycmF5KFsxLCAwLCAwLCAwLFxuICAgICAgICAgICAgICAgICAgICAwLCAxLCAwLCAwLFxuICAgICAgICAgICAgICAgICAgICAwLCAwLCAxLCAwLFxuICAgICAgICAgICAgICAgICAgICAwLCAwLCAwLCAxXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHN0YXRpYyBib29sZWFuQXJyYXkoc2l6ZSkge1xuICAgICAgICB2YXIgYXJyYXkgPSBuZXcgQXJyYXkoc2l6ZSk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFycmF5W2ldID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH1cbiAgICBzdGF0aWMgbWFwVHlwZShnbCwgdHlwZSkge1xuICAgICAgICBpZiAoIVdlYkdMU2V0dGluZ3MuR0xfVEFCTEUpIHtcbiAgICAgICAgICAgIHZhciB0eXBlTmFtZXMgPSBPYmplY3Qua2V5cyhXZWJHTFNldHRpbmdzLkdMX1RPX0dMU0xfVFlQRVMpO1xuICAgICAgICAgICAgV2ViR0xTZXR0aW5ncy5HTF9UQUJMRSA9IHt9O1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0eXBlTmFtZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICB2YXIgdG4gPSB0eXBlTmFtZXNbaV07XG4gICAgICAgICAgICAgICAgV2ViR0xTZXR0aW5ncy5HTF9UQUJMRVtnbFt0bl1dID0gV2ViR0xTZXR0aW5ncy5HTF9UT19HTFNMX1RZUEVTW3RuXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gV2ViR0xTZXR0aW5ncy5HTF9UQUJMRVt0eXBlXTtcbiAgICB9XG4gICAgc3RhdGljIG1hcFNpemUodHlwZSkge1xuICAgICAgICByZXR1cm4gV2ViR0xTZXR0aW5ncy5HTFNMX1RPX1NJWkVbdHlwZV07XG4gICAgfVxuICAgIHN0YXRpYyBnZW5lcmF0ZVVuaWZvcm1zU3luYyhncm91cCwgdW5pZm9ybURhdGEpIHtcbiAgICAgICAgdmFyIHRleHR1cmVDb3VudCA9IDA7XG4gICAgICAgIHZhciBmdW5jID0gXCJ2YXIgdiA9IG51bGw7XFxuICAgIHZhciBjdiA9IG51bGxcXG4gICAgdmFyIGdsID0gcmVuZGVyZXIuZ2xcIjtcbiAgICAgICAgZm9yICh2YXIgaSBpbiBncm91cC51bmlmb3Jtcykge1xuICAgICAgICAgICAgdmFyIGRhdGEgPSB1bmlmb3JtRGF0YVtpXTtcbiAgICAgICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgICAgICAgIGlmIChncm91cC51bmlmb3Jtc1tpXS5ncm91cCkge1xuICAgICAgICAgICAgICAgICAgICBmdW5jICs9IFwiXFxuICAgICAgICAgICAgICAgICAgICByZW5kZXJlci5zaGFkZXIuc3luY1VuaWZvcm1Hcm91cCh1di5cIiArIGkgKyBcIik7XFxuICAgICAgICAgICAgICAgIFwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRPRE8gJiYgdW5pZm9ybURhdGFbaV0udmFsdWUgIT09IDAgPC0tIGRvIHdlIHN0aWxsIG5lZWQgdGhpcz9cbiAgICAgICAgICAgIGlmIChkYXRhLnR5cGUgPT09ICdmbG9hdCcgJiYgZGF0YS5zaXplID09PSAxKSB7XG4gICAgICAgICAgICAgICAgZnVuYyArPSBcIlxcbiAgICAgICAgICAgIGlmKHV2LlwiICsgaSArIFwiICE9PSB1ZC5cIiArIGkgKyBcIi52YWx1ZSlcXG4gICAgICAgICAgICB7XFxuICAgICAgICAgICAgICAgIHVkLlwiICsgaSArIFwiLnZhbHVlID0gdXYuXCIgKyBpICsgXCJcXG4gICAgICAgICAgICAgICAgZ2wudW5pZm9ybTFmKHVkLlwiICsgaSArIFwiLmxvY2F0aW9uLCB1di5cIiArIGkgKyBcIilcXG4gICAgICAgICAgICB9XFxuXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXG4gICAgICAgICAgICBlbHNlIGlmICgoZGF0YS50eXBlID09PSAnc2FtcGxlcjJEJyB8fCBkYXRhLnR5cGUgPT09ICdzYW1wbGVyQ3ViZScgfHwgZGF0YS50eXBlID09PSAnc2FtcGxlcjJEQXJyYXknKSAmJiBkYXRhLnNpemUgPT09IDEgJiYgIWRhdGEuaXNBcnJheSkgXG4gICAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZnVuYyArPSBcIlxcbiAgICAgICAgICAgIHJlbmRlcmVyLnRleHR1cmUuYmluZCh1di5cIiArIGkgKyBcIiwgXCIgKyB0ZXh0dXJlQ291bnQgKyBcIik7XFxuXFxuICAgICAgICAgICAgaWYodWQuXCIgKyBpICsgXCIudmFsdWUgIT09IFwiICsgdGV4dHVyZUNvdW50ICsgXCIpXFxuICAgICAgICAgICAge1xcbiAgICAgICAgICAgICAgICB1ZC5cIiArIGkgKyBcIi52YWx1ZSA9IFwiICsgdGV4dHVyZUNvdW50ICsgXCI7XFxuICAgICAgICAgICAgICAgIGdsLnVuaWZvcm0xaSh1ZC5cIiArIGkgKyBcIi5sb2NhdGlvbiwgXCIgKyB0ZXh0dXJlQ291bnQgKyBcIik7XFxuOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG1heC1sZW5cXG4gICAgICAgICAgICB9XFxuXCI7XG4gICAgICAgICAgICAgICAgdGV4dHVyZUNvdW50Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkYXRhLnR5cGUgPT09ICdtYXQzJyAmJiBkYXRhLnNpemUgPT09IDEpIHtcbiAgICAgICAgICAgICAgICBpZiAoZ3JvdXAudW5pZm9ybXNbaV0uYSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gYW5kIHNvbWUgc21hcnQgY2FjaGluZyBkaXJ0eSBpZHMgaGVyZSFcbiAgICAgICAgICAgICAgICAgICAgZnVuYyArPSBcIlxcbiAgICAgICAgICAgICAgICBnbC51bmlmb3JtTWF0cml4M2Z2KHVkLlwiICsgaSArIFwiLmxvY2F0aW9uLCBmYWxzZSwgdXYuXCIgKyBpICsgXCIudG9BcnJheSh0cnVlKSk7XFxuICAgICAgICAgICAgICAgIFxcblwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZnVuYyArPSBcIlxcbiAgICAgICAgICAgICAgICBnbC51bmlmb3JtTWF0cml4M2Z2KHVkLlwiICsgaSArIFwiLmxvY2F0aW9uLCBmYWxzZSwgdXYuXCIgKyBpICsgXCIpO1xcbiAgICAgICAgICAgICAgICBcXG5cIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkYXRhLnR5cGUgPT09ICd2ZWMyJyAmJiBkYXRhLnNpemUgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPIC0gZG8gd2UgbmVlZCBib3RoIGhlcmU/XG4gICAgICAgICAgICAgICAgLy8gbWF5YmUgd2UgY2FuIGdldCBhd2F5IHdpdGggb25seSB1c2luZyBwb2ludHM/XG4gICAgICAgICAgICAgICAgaWYgKGdyb3VwLnVuaWZvcm1zW2ldLnggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBmdW5jICs9IFwiXFxuICAgICAgICAgICAgICAgIGN2ID0gdWQuXCIgKyBpICsgXCIudmFsdWU7XFxuICAgICAgICAgICAgICAgIHYgPSB1di5cIiArIGkgKyBcIjtcXG5cXG4gICAgICAgICAgICAgICAgaWYoY3ZbMF0gIT09IHYueCB8fCBjdlsxXSAhPT0gdi55KVxcbiAgICAgICAgICAgICAgICB7XFxuICAgICAgICAgICAgICAgICAgICBjdlswXSA9IHYueDtcXG4gICAgICAgICAgICAgICAgICAgIGN2WzFdID0gdi55O1xcbiAgICAgICAgICAgICAgICAgICAgZ2wudW5pZm9ybTJmKHVkLlwiICsgaSArIFwiLmxvY2F0aW9uLCB2LngsIHYueSk7XFxuICAgICAgICAgICAgICAgIH1cXG5cIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZ1bmMgKz0gXCJcXG4gICAgICAgICAgICAgICAgY3YgPSB1ZC5cIiArIGkgKyBcIi52YWx1ZTtcXG4gICAgICAgICAgICAgICAgdiA9IHV2LlwiICsgaSArIFwiO1xcblxcbiAgICAgICAgICAgICAgICBpZihjdlswXSAhPT0gdlswXSB8fCBjdlsxXSAhPT0gdlsxXSlcXG4gICAgICAgICAgICAgICAge1xcbiAgICAgICAgICAgICAgICAgICAgY3ZbMF0gPSB2WzBdO1xcbiAgICAgICAgICAgICAgICAgICAgY3ZbMV0gPSB2WzFdO1xcbiAgICAgICAgICAgICAgICAgICAgZ2wudW5pZm9ybTJmKHVkLlwiICsgaSArIFwiLmxvY2F0aW9uLCB2WzBdLCB2WzFdKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBcXG5cIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkYXRhLnR5cGUgPT09ICd2ZWM0JyAmJiBkYXRhLnNpemUgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPIC0gZG8gd2UgbmVlZCBib3RoIGhlcmU/XG4gICAgICAgICAgICAgICAgLy8gbWF5YmUgd2UgY2FuIGdldCBhd2F5IHdpdGggb25seSB1c2luZyBwb2ludHM/XG4gICAgICAgICAgICAgICAgaWYgKGdyb3VwLnVuaWZvcm1zW2ldLndpZHRoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZnVuYyArPSBcIlxcbiAgICAgICAgICAgICAgICBjdiA9IHVkLlwiICsgaSArIFwiLnZhbHVlO1xcbiAgICAgICAgICAgICAgICB2ID0gdXYuXCIgKyBpICsgXCI7XFxuXFxuICAgICAgICAgICAgICAgIGlmKGN2WzBdICE9PSB2LnggfHwgY3ZbMV0gIT09IHYueSB8fCBjdlsyXSAhPT0gdi53aWR0aCB8fCBjdlszXSAhPT0gdi5oZWlnaHQpXFxuICAgICAgICAgICAgICAgIHtcXG4gICAgICAgICAgICAgICAgICAgIGN2WzBdID0gdi54O1xcbiAgICAgICAgICAgICAgICAgICAgY3ZbMV0gPSB2Lnk7XFxuICAgICAgICAgICAgICAgICAgICBjdlsyXSA9IHYud2lkdGg7XFxuICAgICAgICAgICAgICAgICAgICBjdlszXSA9IHYuaGVpZ2h0O1xcbiAgICAgICAgICAgICAgICAgICAgZ2wudW5pZm9ybTRmKHVkLlwiICsgaSArIFwiLmxvY2F0aW9uLCB2LngsIHYueSwgdi53aWR0aCwgdi5oZWlnaHQpXFxuICAgICAgICAgICAgICAgIH1cXG5cIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZ1bmMgKz0gXCJcXG4gICAgICAgICAgICAgICAgY3YgPSB1ZC5cIiArIGkgKyBcIi52YWx1ZTtcXG4gICAgICAgICAgICAgICAgdiA9IHV2LlwiICsgaSArIFwiO1xcblxcbiAgICAgICAgICAgICAgICBpZihjdlswXSAhPT0gdlswXSB8fCBjdlsxXSAhPT0gdlsxXSB8fCBjdlsyXSAhPT0gdlsyXSB8fCBjdlszXSAhPT0gdlszXSlcXG4gICAgICAgICAgICAgICAge1xcbiAgICAgICAgICAgICAgICAgICAgY3ZbMF0gPSB2WzBdO1xcbiAgICAgICAgICAgICAgICAgICAgY3ZbMV0gPSB2WzFdO1xcbiAgICAgICAgICAgICAgICAgICAgY3ZbMl0gPSB2WzJdO1xcbiAgICAgICAgICAgICAgICAgICAgY3ZbM10gPSB2WzNdO1xcblxcbiAgICAgICAgICAgICAgICAgICAgZ2wudW5pZm9ybTRmKHVkLlwiICsgaSArIFwiLmxvY2F0aW9uLCB2WzBdLCB2WzFdLCB2WzJdLCB2WzNdKVxcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIFxcblwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciB0ZW1wbGF0ZVR5cGUgPSAoZGF0YS5zaXplID09PSAxKSA/IFdlYkdMU2V0dGluZ3MuR0xTTF9UT19TSU5HTEVfU0VUVEVSU19DQUNIRUQgOiBXZWJHTFNldHRpbmdzLkdMU0xfVE9fQVJSQVlfU0VUVEVSUztcbiAgICAgICAgICAgICAgICB2YXIgdGVtcGxhdGUgPSB0ZW1wbGF0ZVR5cGVbZGF0YS50eXBlXS5yZXBsYWNlKCdsb2NhdGlvbicsIChcInVkLlwiICsgaSArIFwiLmxvY2F0aW9uXCIpKTtcbiAgICAgICAgICAgICAgICBmdW5jICs9IFwiXFxuICAgICAgICAgICAgY3YgPSB1ZC5cIiArIGkgKyBcIi52YWx1ZTtcXG4gICAgICAgICAgICB2ID0gdXYuXCIgKyBpICsgXCI7XFxuICAgICAgICAgICAgXCIgKyB0ZW1wbGF0ZSArIFwiO1xcblwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRnVuY3Rpb24oJ3VkJywgJ3V2JywgJ3JlbmRlcmVyJywgZnVuYyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3LWZ1bmNcbiAgICB9XG59XG5XZWJHTFNldHRpbmdzLlVQTE9BRFNfUEVSX0ZSQU1FID0gNDtcbldlYkdMU2V0dGluZ3MuR0xTTF9UT19BUlJBWV9TRVRURVJTID0ge1xuICAgIGZsb2F0OiBcImdsLnVuaWZvcm0xZnYobG9jYXRpb24sIHYpXCIsXG4gICAgdmVjMjogXCJnbC51bmlmb3JtMmZ2KGxvY2F0aW9uLCB2KVwiLFxuICAgIHZlYzM6IFwiZ2wudW5pZm9ybTNmdihsb2NhdGlvbiwgdilcIixcbiAgICB2ZWM0OiAnZ2wudW5pZm9ybTRmdihsb2NhdGlvbiwgdiknLFxuICAgIG1hdDQ6ICdnbC51bmlmb3JtTWF0cml4NGZ2KGxvY2F0aW9uLCBmYWxzZSwgdiknLFxuICAgIG1hdDM6ICdnbC51bmlmb3JtTWF0cml4M2Z2KGxvY2F0aW9uLCBmYWxzZSwgdiknLFxuICAgIG1hdDI6ICdnbC51bmlmb3JtTWF0cml4MmZ2KGxvY2F0aW9uLCBmYWxzZSwgdiknLFxuICAgIGludDogJ2dsLnVuaWZvcm0xaXYobG9jYXRpb24sIHYpJyxcbiAgICBpdmVjMjogJ2dsLnVuaWZvcm0yaXYobG9jYXRpb24sIHYpJyxcbiAgICBpdmVjMzogJ2dsLnVuaWZvcm0zaXYobG9jYXRpb24sIHYpJyxcbiAgICBpdmVjNDogJ2dsLnVuaWZvcm00aXYobG9jYXRpb24sIHYpJyxcbiAgICBib29sOiAnZ2wudW5pZm9ybTFpdihsb2NhdGlvbiwgdiknLFxuICAgIGJ2ZWMyOiAnZ2wudW5pZm9ybTJpdihsb2NhdGlvbiwgdiknLFxuICAgIGJ2ZWMzOiAnZ2wudW5pZm9ybTNpdihsb2NhdGlvbiwgdiknLFxuICAgIGJ2ZWM0OiAnZ2wudW5pZm9ybTRpdihsb2NhdGlvbiwgdiknLFxuICAgIHNhbXBsZXIyRDogJ2dsLnVuaWZvcm0xaXYobG9jYXRpb24sIHYpJyxcbiAgICBzYW1wbGVyQ3ViZTogJ2dsLnVuaWZvcm0xaXYobG9jYXRpb24sIHYpJyxcbiAgICBzYW1wbGVyMkRBcnJheTogJ2dsLnVuaWZvcm0xaXYobG9jYXRpb24sIHYpJyxcbn07XG5XZWJHTFNldHRpbmdzLkdMU0xfVE9fU0lOR0xFX1NFVFRFUlNfQ0FDSEVEID0ge1xuICAgIGZsb2F0OiBcIlxcbiAgICBpZihjdiAhPT0gdilcXG4gICAge1xcbiAgICAgICAgY3YudiA9IHY7XFxuICAgICAgICBnbC51bmlmb3JtMWYobG9jYXRpb24sIHYpXFxuICAgIH1cIixcbiAgICB2ZWMyOiBcIlxcbiAgICBpZihjdlswXSAhPT0gdlswXSB8fCBjdlsxXSAhPT0gdlsxXSlcXG4gICAge1xcbiAgICAgICAgY3ZbMF0gPSB2WzBdO1xcbiAgICAgICAgY3ZbMV0gPSB2WzFdO1xcbiAgICAgICAgZ2wudW5pZm9ybTJmKGxvY2F0aW9uLCB2WzBdLCB2WzFdKVxcbiAgICB9XCIsXG4gICAgdmVjMzogXCJcXG4gICAgaWYoY3ZbMF0gIT09IHZbMF0gfHwgY3ZbMV0gIT09IHZbMV0gfHwgY3ZbMl0gIT09IHZbMl0pXFxuICAgIHtcXG4gICAgICAgIGN2WzBdID0gdlswXTtcXG4gICAgICAgIGN2WzFdID0gdlsxXTtcXG4gICAgICAgIGN2WzJdID0gdlsyXTtcXG5cXG4gICAgICAgIGdsLnVuaWZvcm0zZihsb2NhdGlvbiwgdlswXSwgdlsxXSwgdlsyXSlcXG4gICAgfVwiLFxuICAgIHZlYzQ6ICdnbC51bmlmb3JtNGYobG9jYXRpb24sIHZbMF0sIHZbMV0sIHZbMl0sIHZbM10pJyxcbiAgICBpbnQ6ICdnbC51bmlmb3JtMWkobG9jYXRpb24sIHYpJyxcbiAgICBpdmVjMjogJ2dsLnVuaWZvcm0yaShsb2NhdGlvbiwgdlswXSwgdlsxXSknLFxuICAgIGl2ZWMzOiAnZ2wudW5pZm9ybTNpKGxvY2F0aW9uLCB2WzBdLCB2WzFdLCB2WzJdKScsXG4gICAgaXZlYzQ6ICdnbC51bmlmb3JtNGkobG9jYXRpb24sIHZbMF0sIHZbMV0sIHZbMl0sIHZbM10pJyxcbiAgICBib29sOiAnZ2wudW5pZm9ybTFpKGxvY2F0aW9uLCB2KScsXG4gICAgYnZlYzI6ICdnbC51bmlmb3JtMmkobG9jYXRpb24sIHZbMF0sIHZbMV0pJyxcbiAgICBidmVjMzogJ2dsLnVuaWZvcm0zaShsb2NhdGlvbiwgdlswXSwgdlsxXSwgdlsyXSknLFxuICAgIGJ2ZWM0OiAnZ2wudW5pZm9ybTRpKGxvY2F0aW9uLCB2WzBdLCB2WzFdLCB2WzJdLCB2WzNdKScsXG4gICAgbWF0MjogJ2dsLnVuaWZvcm1NYXRyaXgyZnYobG9jYXRpb24sIGZhbHNlLCB2KScsXG4gICAgbWF0MzogJ2dsLnVuaWZvcm1NYXRyaXgzZnYobG9jYXRpb24sIGZhbHNlLCB2KScsXG4gICAgbWF0NDogJ2dsLnVuaWZvcm1NYXRyaXg0ZnYobG9jYXRpb24sIGZhbHNlLCB2KScsXG4gICAgc2FtcGxlcjJEOiAnZ2wudW5pZm9ybTFpKGxvY2F0aW9uLCB2KScsXG4gICAgc2FtcGxlckN1YmU6ICdnbC51bmlmb3JtMWkobG9jYXRpb24sIHYpJyxcbiAgICBzYW1wbGVyMkRBcnJheTogJ2dsLnVuaWZvcm0xaShsb2NhdGlvbiwgdiknLFxufTtcbldlYkdMU2V0dGluZ3MuR0xTTF9UT19TSVpFID0ge1xuICAgIGZsb2F0OiAxLFxuICAgIHZlYzI6IDIsXG4gICAgdmVjMzogMyxcbiAgICB2ZWM0OiA0LFxuICAgIGludDogMSxcbiAgICBpdmVjMjogMixcbiAgICBpdmVjMzogMyxcbiAgICBpdmVjNDogNCxcbiAgICBib29sOiAxLFxuICAgIGJ2ZWMyOiAyLFxuICAgIGJ2ZWMzOiAzLFxuICAgIGJ2ZWM0OiA0LFxuICAgIG1hdDI6IDQsXG4gICAgbWF0MzogOSxcbiAgICBtYXQ0OiAxNixcbiAgICBzYW1wbGVyMkQ6IDEsXG59O1xuV2ViR0xTZXR0aW5ncy5HTF9UT19HTFNMX1RZUEVTID0ge1xuICAgIEZMT0FUOiAnZmxvYXQnLFxuICAgIEZMT0FUX1ZFQzI6ICd2ZWMyJyxcbiAgICBGTE9BVF9WRUMzOiAndmVjMycsXG4gICAgRkxPQVRfVkVDNDogJ3ZlYzQnLFxuICAgIElOVDogJ2ludCcsXG4gICAgSU5UX1ZFQzI6ICdpdmVjMicsXG4gICAgSU5UX1ZFQzM6ICdpdmVjMycsXG4gICAgSU5UX1ZFQzQ6ICdpdmVjNCcsXG4gICAgQk9PTDogJ2Jvb2wnLFxuICAgIEJPT0xfVkVDMjogJ2J2ZWMyJyxcbiAgICBCT09MX1ZFQzM6ICdidmVjMycsXG4gICAgQk9PTF9WRUM0OiAnYnZlYzQnLFxuICAgIEZMT0FUX01BVDI6ICdtYXQyJyxcbiAgICBGTE9BVF9NQVQzOiAnbWF0MycsXG4gICAgRkxPQVRfTUFUNDogJ21hdDQnLFxuICAgIFNBTVBMRVJfMkQ6ICdzYW1wbGVyMkQnLFxuICAgIFNBTVBMRVJfQ1VCRTogJ3NhbXBsZXJDdWJlJyxcbiAgICBTQU1QTEVSXzJEX0FSUkFZOiAnc2FtcGxlcjJEQXJyYXknLFxufTtcbldlYkdMU2V0dGluZ3MuR0xfVEFCTEUgPSBudWxsO1xuV2ViR0xTZXR0aW5ncy5jb250ZXh0ID0gbnVsbDtcbldlYkdMU2V0dGluZ3MuUFJFQ0lTSU9OX0ZSQUdNRU5UID0gJ2hpZ2hwJztcbldlYkdMU2V0dGluZ3MuUFJFQ0lTSU9OX1ZFUlRFWCA9ICdoaWdocCc7XG5XZWJHTFNldHRpbmdzLmZyYWdUZW1wbGF0ZSA9IFtcbiAgICAncHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7JyxcbiAgICAndm9pZCBtYWluKHZvaWQpeycsXG4gICAgJ2Zsb2F0IHRlc3QgPSAwLjE7JyxcbiAgICAnJWZvcmxvb3AlJyxcbiAgICAnZ2xfRnJhZ0NvbG9yID0gdmVjNCgwLjApOycsXG4gICAgJ30nXG5dLmpvaW4oJ1xcbicpO1xuV2ViR0xTZXR0aW5ncy52ZXJ0ZXgkMSA9IFwicHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcclxcbmF0dHJpYnV0ZSB2ZWMyIGFWZXJ0ZXhQb3NpdGlvbjtcXHJcXG5hdHRyaWJ1dGUgdmVjMiBhVGV4dHVyZUNvb3JkO1xcclxcbmF0dHJpYnV0ZSB2ZWM0IGFDb2xvcjtcXHJcXG5hdHRyaWJ1dGUgZmxvYXQgYVRleHR1cmVJZDtcXHJcXG5cXHJcXG51bmlmb3JtIG1hdDMgcHJvamVjdGlvbk1hdHJpeDtcXHJcXG51bmlmb3JtIG1hdDMgdHJhbnNsYXRpb25NYXRyaXg7XFxyXFxudW5pZm9ybSB2ZWM0IHRpbnQ7XFxyXFxuXFxyXFxudmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XFxyXFxudmFyeWluZyB2ZWM0IHZDb2xvcjtcXHJcXG52YXJ5aW5nIGZsb2F0IHZUZXh0dXJlSWQ7XFxyXFxuXFxyXFxudm9pZCBtYWluKHZvaWQpe1xcclxcbiAgICBnbF9Qb3NpdGlvbiA9IHZlYzQoKHByb2plY3Rpb25NYXRyaXggKiB0cmFuc2xhdGlvbk1hdHJpeCAqIHZlYzMoYVZlcnRleFBvc2l0aW9uLCAxLjApKS54eSwgMC4wLCAxLjApO1xcclxcblxcclxcbiAgICB2VGV4dHVyZUNvb3JkID0gYVRleHR1cmVDb29yZDtcXHJcXG4gICAgdlRleHR1cmVJZCA9IGFUZXh0dXJlSWQ7XFxyXFxuICAgIHZDb2xvciA9IGFDb2xvciAqIHRpbnQ7XFxyXFxufVxcclxcblwiO1xuV2ViR0xTZXR0aW5ncy5mcmFnVGVtcGxhdGUkMSA9IFtcbiAgICAndmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7JyxcbiAgICAndmFyeWluZyB2ZWM0IHZDb2xvcjsnLFxuICAgICd2YXJ5aW5nIGZsb2F0IHZUZXh0dXJlSWQ7JyxcbiAgICAndW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXJzWyVjb3VudCVdOycsXG4gICAgJ3ZvaWQgbWFpbih2b2lkKXsnLFxuICAgICd2ZWM0IGNvbG9yOycsXG4gICAgJyVmb3Jsb29wJScsXG4gICAgJ2dsX0ZyYWdDb2xvciA9IGNvbG9yICogdkNvbG9yOycsXG4gICAgJ30nXG5dLmpvaW4oJ1xcbicpO1xuV2ViR0xTZXR0aW5ncy5NSVBNQVBfVEVYVFVSRVMgPSAxO1xuV2ViR0xTZXR0aW5ncy5XUkFQX01PREUgPSAzMzA3MTtcbldlYkdMU2V0dGluZ3MuVEFSR0VUUyA9IHtcbiAgICBURVhUVVJFXzJEOiAzNTUzLFxuICAgIFRFWFRVUkVfQ1VCRV9NQVA6IDM0MDY3LFxuICAgIFRFWFRVUkVfMkRfQVJSQVk6IDM1ODY2LFxuICAgIFRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWDogMzQwNjksXG4gICAgVEVYVFVSRV9DVUJFX01BUF9ORUdBVElWRV9YOiAzNDA3MCxcbiAgICBURVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1k6IDM0MDcxLFxuICAgIFRFWFRVUkVfQ1VCRV9NQVBfTkVHQVRJVkVfWTogMzQwNzIsXG4gICAgVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9aOiAzNDA3MyxcbiAgICBURVhUVVJFX0NVQkVfTUFQX05FR0FUSVZFX1o6IDM0MDc0LFxufTtcbldlYkdMU2V0dGluZ3MuRk9STUFUUyA9IHtcbiAgICBSR0JBOiA2NDA4LFxuICAgIFJHQjogNjQwNyxcbiAgICBBTFBIQTogNjQwNixcbiAgICBMVU1JTkFOQ0U6IDY0MDksXG4gICAgTFVNSU5BTkNFX0FMUEhBOiA2NDEwLFxuICAgIERFUFRIX0NPTVBPTkVOVDogNjQwMixcbiAgICBERVBUSF9TVEVOQ0lMOiAzNDA0MSxcbn07XG5XZWJHTFNldHRpbmdzLlRZUEVTID0ge1xuICAgIFVOU0lHTkVEX0JZVEU6IDUxMjEsXG4gICAgVU5TSUdORURfU0hPUlQ6IDUxMjMsXG4gICAgVU5TSUdORURfU0hPUlRfNV82XzU6IDMzNjM1LFxuICAgIFVOU0lHTkVEX1NIT1JUXzRfNF80XzQ6IDMyODE5LFxuICAgIFVOU0lHTkVEX1NIT1JUXzVfNV81XzE6IDMyODIwLFxuICAgIEZMT0FUOiA1MTI2LFxuICAgIEhBTEZfRkxPQVQ6IDM2MTkzLFxufTtcbldlYkdMU2V0dGluZ3MuTUlQTUFQX01PREVTID0ge1xuICAgIE9GRjogMCxcbiAgICBQT1cyOiAxLFxuICAgIE9OOiAyLFxufTtcbldlYkdMU2V0dGluZ3MuU0NBTEVfTU9ERVMgPSB7XG4gICAgTElORUFSOiAxLFxuICAgIE5FQVJFU1Q6IDAsXG59O1xuV2ViR0xTZXR0aW5ncy5XUkFQX01PREVTID0ge1xuICAgIENMQU1QOiAzMzA3MSxcbiAgICBSRVBFQVQ6IDEwNDk3LFxuICAgIE1JUlJPUkVEX1JFUEVBVDogMzM2NDgsXG59O1xuV2ViR0xTZXR0aW5ncy5kZWZhdWx0QnVmZmVyT3B0aW9ucyA9IHtcbiAgICBzY2FsZU1vZGU6IFdlYkdMU2V0dGluZ3MuU0NBTEVfTU9ERVMuTkVBUkVTVCxcbiAgICBmb3JtYXQ6IFdlYkdMU2V0dGluZ3MuRk9STUFUUy5SR0JBLFxuICAgIHByZW11bHRpcGx5QWxwaGE6IGZhbHNlLFxufTtcbldlYkdMU2V0dGluZ3MuQ0FOX1VQTE9BRF9TQU1FX0JVRkZFUiA9IFdlYkdMU2V0dGluZ3MuY2FuVXBsb2FkU2FtZUJ1ZmZlcigpO1xuV2ViR0xTZXR0aW5ncy5TUFJJVEVfTUFYX1RFWFRVUkVTID0gV2ViR0xTZXR0aW5ncy5tYXhSZWNvbW1lbmRlZFRleHR1cmVzKDMyKTtcbmV4cG9ydHMuV2ViR0xTZXR0aW5ncyA9IFdlYkdMU2V0dGluZ3M7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNsYXNzIFhNTFBhcnNlciB7XG4gICAgc3RhdGljIHBhcnNlKHZhbHVlKSB7XG4gICAgICAgIHZhciBwYXJzZXIgPSBuZXcgRE9NUGFyc2VyKCk7XG4gICAgICAgIHZhciByZXN1bHQgPSBwYXJzZXIucGFyc2VGcm9tU3RyaW5nKHZhbHVlLCBcInRleHQveG1sXCIpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbmV4cG9ydHMuWE1MUGFyc2VyID0gWE1MUGFyc2VyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jbGFzcyBzZXR0aW5ncyB7XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYSBkaWdpdC9pbnRlZ2VyIGludG8gYSBiYXNpYyBjb2RlIHBvaW50LlxuICAgICAqIEBzZWUgYGJhc2ljVG9EaWdpdCgpYFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRpZ2l0IFRoZSBudW1lcmljIHZhbHVlIG9mIGEgYmFzaWMgY29kZSBwb2ludC5cbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgYmFzaWMgY29kZSBwb2ludCB3aG9zZSB2YWx1ZSAod2hlbiB1c2VkIGZvclxuICAgICAqIHJlcHJlc2VudGluZyBpbnRlZ2VycykgaXMgYGRpZ2l0YCwgd2hpY2ggbmVlZHMgdG8gYmUgaW4gdGhlIHJhbmdlXG4gICAgICogYDBgIHRvIGBiYXNlIC0gMWAuIElmIGBmbGFnYCBpcyBub24temVybywgdGhlIHVwcGVyY2FzZSBmb3JtIGlzXG4gICAgICogdXNlZDsgZWxzZSwgdGhlIGxvd2VyY2FzZSBmb3JtIGlzIHVzZWQuIFRoZSBiZWhhdmlvciBpcyB1bmRlZmluZWRcbiAgICAgKiBpZiBgZmxhZ2AgaXMgbm9uLXplcm8gYW5kIGBkaWdpdGAgaGFzIG5vIHVwcGVyY2FzZSBmb3JtLlxuICAgICAqL1xuICAgIHN0YXRpYyBkaWdpdFRvQmFzaWMoZGlnaXQsIGZsYWcpIHtcbiAgICAgICAgLy8gIDAuLjI1IG1hcCB0byBBU0NJSSBhLi56IG9yIEEuLlpcbiAgICAgICAgLy8gMjYuLjM1IG1hcCB0byBBU0NJSSAwLi45XG4gICAgICAgIHJldHVybiBkaWdpdCArIDIyICsgNzUgKiAoZGlnaXQgPCAyNikgLSAoKGZsYWcgIT0gMCkgPDwgNSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgZ2VuZXJpYyBlcnJvciB1dGlsaXR5IGZ1bmN0aW9uLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVGhlIGVycm9yIHR5cGUuXG4gICAgICogQHJldHVybnMge0Vycm9yfSBUaHJvd3MgYSBgUmFuZ2VFcnJvcmAgd2l0aCB0aGUgYXBwbGljYWJsZSBlcnJvciBtZXNzYWdlLlxuICAgICAqL1xuICAgIHN0YXRpYyBlcnJvcih0eXBlKSB7XG4gICAgICAgIHRocm93IFJhbmdlRXJyb3Ioc2V0dGluZ3MuZXJyb3JzW3R5cGVdKTtcbiAgICB9XG4gICAgLyoqXG4gKiBDb252ZXJ0cyBhIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMgKGUuZy4gYSBkb21haW4gbmFtZSBsYWJlbCkgdG8gYVxuICogUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cbiAqIEBtZW1iZXJPZiBwdW55Y29kZVxuICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzLlxuICogQHJldHVybnMge1N0cmluZ30gVGhlIHJlc3VsdGluZyBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuICovXG4gICAgc3RhdGljIGVuY29kZShpbnB1dCkge1xuICAgICAgICB2YXIgbiwgZGVsdGEsIGhhbmRsZWRDUENvdW50LCBiYXNpY0xlbmd0aCwgYmlhcywgaiwgbSwgcSwgaywgdCwgY3VycmVudFZhbHVlLCBvdXRwdXQgPSBbXSwgXG4gICAgICAgIC8qKiBgaW5wdXRMZW5ndGhgIHdpbGwgaG9sZCB0aGUgbnVtYmVyIG9mIGNvZGUgcG9pbnRzIGluIGBpbnB1dGAuICovXG4gICAgICAgIGlucHV0TGVuZ3RoLCBcbiAgICAgICAgLyoqIENhY2hlZCBjYWxjdWxhdGlvbiByZXN1bHRzICovXG4gICAgICAgIGhhbmRsZWRDUENvdW50UGx1c09uZSwgYmFzZU1pbnVzVCwgcU1pbnVzVDtcbiAgICAgICAgLy8gQ29udmVydCB0aGUgaW5wdXQgaW4gVUNTLTIgdG8gVW5pY29kZVxuICAgICAgICBpbnB1dCA9IHNldHRpbmdzLnVjczJkZWNvZGUoaW5wdXQpO1xuICAgICAgICAvLyBDYWNoZSB0aGUgbGVuZ3RoXG4gICAgICAgIGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xuICAgICAgICAvLyBJbml0aWFsaXplIHRoZSBzdGF0ZVxuICAgICAgICBuID0gc2V0dGluZ3MuaW5pdGlhbE47XG4gICAgICAgIGRlbHRhID0gMDtcbiAgICAgICAgYmlhcyA9IHNldHRpbmdzLmluaXRpYWxCaWFzO1xuICAgICAgICAvLyBIYW5kbGUgdGhlIGJhc2ljIGNvZGUgcG9pbnRzXG4gICAgICAgIGZvciAoaiA9IDA7IGogPCBpbnB1dExlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICBjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50VmFsdWUgPCAweDgwKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0LnB1c2goc2V0dGluZ3Muc3RyaW5nRnJvbUNoYXJDb2RlKGN1cnJlbnRWYWx1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGhhbmRsZWRDUENvdW50ID0gYmFzaWNMZW5ndGggPSBvdXRwdXQubGVuZ3RoO1xuICAgICAgICAvLyBgaGFuZGxlZENQQ291bnRgIGlzIHRoZSBudW1iZXIgb2YgY29kZSBwb2ludHMgdGhhdCBoYXZlIGJlZW4gaGFuZGxlZDtcbiAgICAgICAgLy8gYGJhc2ljTGVuZ3RoYCBpcyB0aGUgbnVtYmVyIG9mIGJhc2ljIGNvZGUgcG9pbnRzLlxuICAgICAgICAvLyBGaW5pc2ggdGhlIGJhc2ljIHN0cmluZyAtIGlmIGl0IGlzIG5vdCBlbXB0eSAtIHdpdGggYSBkZWxpbWl0ZXJcbiAgICAgICAgaWYgKGJhc2ljTGVuZ3RoKSB7XG4gICAgICAgICAgICBvdXRwdXQucHVzaChzZXR0aW5ncy5kZWxpbWl0ZXIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIE1haW4gZW5jb2RpbmcgbG9vcDpcbiAgICAgICAgd2hpbGUgKGhhbmRsZWRDUENvdW50IDwgaW5wdXRMZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIEFsbCBub24tYmFzaWMgY29kZSBwb2ludHMgPCBuIGhhdmUgYmVlbiBoYW5kbGVkIGFscmVhZHkuIEZpbmQgdGhlIG5leHRcbiAgICAgICAgICAgIC8vIGxhcmdlciBvbmU6XG4gICAgICAgICAgICBmb3IgKG0gPSBzZXR0aW5ncy5tYXhJbnQsIGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50VmFsdWUgPj0gbiAmJiBjdXJyZW50VmFsdWUgPCBtKSB7XG4gICAgICAgICAgICAgICAgICAgIG0gPSBjdXJyZW50VmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSW5jcmVhc2UgYGRlbHRhYCBlbm91Z2ggdG8gYWR2YW5jZSB0aGUgZGVjb2RlcidzIDxuLGk+IHN0YXRlIHRvIDxtLDA+LFxuICAgICAgICAgICAgLy8gYnV0IGd1YXJkIGFnYWluc3Qgb3ZlcmZsb3dcbiAgICAgICAgICAgIGhhbmRsZWRDUENvdW50UGx1c09uZSA9IGhhbmRsZWRDUENvdW50ICsgMTtcbiAgICAgICAgICAgIGlmIChtIC0gbiA+IHNldHRpbmdzLmZsb29yKChzZXR0aW5ncy5tYXhJbnQgLSBkZWx0YSkgLyBoYW5kbGVkQ1BDb3VudFBsdXNPbmUpKSB7XG4gICAgICAgICAgICAgICAgc2V0dGluZ3MuZXJyb3IoJ292ZXJmbG93Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWx0YSArPSAobSAtIG4pICogaGFuZGxlZENQQ291bnRQbHVzT25lO1xuICAgICAgICAgICAgbiA9IG07XG4gICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50VmFsdWUgPCBuICYmICsrZGVsdGEgPiBzZXR0aW5ncy5tYXhJbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MuZXJyb3IoJ292ZXJmbG93Jyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50VmFsdWUgPT0gbikge1xuICAgICAgICAgICAgICAgICAgICAvLyBSZXByZXNlbnQgZGVsdGEgYXMgYSBnZW5lcmFsaXplZCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHEgPSBkZWx0YSwgayA9IHNldHRpbmdzLmJhc2U7IC8qIG5vIGNvbmRpdGlvbiAqLzsgayArPSBzZXR0aW5ncy5iYXNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ID0gayA8PSBiaWFzID8gc2V0dGluZ3MudE1pbiA6IChrID49IGJpYXMgKyBzZXR0aW5ncy50TWF4ID8gc2V0dGluZ3MudE1heCA6IGsgLSBiaWFzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChxIDwgdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcU1pbnVzVCA9IHEgLSB0O1xuICAgICAgICAgICAgICAgICAgICAgICAgYmFzZU1pbnVzVCA9IHNldHRpbmdzLmJhc2UgLSB0O1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnB1c2goc2V0dGluZ3Muc3RyaW5nRnJvbUNoYXJDb2RlKHNldHRpbmdzLmRpZ2l0VG9CYXNpYyh0ICsgcU1pbnVzVCAlIGJhc2VNaW51c1QsIDApKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBxID0gc2V0dGluZ3MuZmxvb3IocU1pbnVzVCAvIGJhc2VNaW51c1QpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKHNldHRpbmdzLnN0cmluZ0Zyb21DaGFyQ29kZShzZXR0aW5ncy5kaWdpdFRvQmFzaWMocSwgMCkpKTtcbiAgICAgICAgICAgICAgICAgICAgYmlhcyA9IHNldHRpbmdzLmFkYXB0KGRlbHRhLCBoYW5kbGVkQ1BDb3VudFBsdXNPbmUsIGhhbmRsZWRDUENvdW50ID09IGJhc2ljTGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgZGVsdGEgPSAwO1xuICAgICAgICAgICAgICAgICAgICArK2hhbmRsZWRDUENvdW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICsrZGVsdGE7XG4gICAgICAgICAgICArK247XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dHB1dC5qb2luKCcnKTtcbiAgICB9XG4gICAgLyoqXG4qIEJpYXMgYWRhcHRhdGlvbiBmdW5jdGlvbiBhcyBwZXIgc2VjdGlvbiAzLjQgb2YgUkZDIDM0OTIuXG4qIGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM0OTIjc2VjdGlvbi0zLjRcbiogQHByaXZhdGVcbiovXG4gICAgc3RhdGljIGFkYXB0KGRlbHRhLCBudW1Qb2ludHMsIGZpcnN0VGltZSkge1xuICAgICAgICB2YXIgayA9IDA7XG4gICAgICAgIGRlbHRhID0gZmlyc3RUaW1lID8gc2V0dGluZ3MuZmxvb3IoZGVsdGEgLyBzZXR0aW5ncy5kYW1wKSA6IGRlbHRhID4+IDE7XG4gICAgICAgIGRlbHRhICs9IHNldHRpbmdzLmZsb29yKGRlbHRhIC8gbnVtUG9pbnRzKTtcbiAgICAgICAgZm9yICggLyogbm8gaW5pdGlhbGl6YXRpb24gKi87IGRlbHRhID4gc2V0dGluZ3MuYmFzZU1pbnVzVE1pbiAqIHNldHRpbmdzLnRNYXggPj4gMTsgayArPSBzZXR0aW5ncy5iYXNlKSB7XG4gICAgICAgICAgICBkZWx0YSA9IHNldHRpbmdzLmZsb29yKGRlbHRhIC8gc2V0dGluZ3MuYmFzZU1pbnVzVE1pbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNldHRpbmdzLmZsb29yKGsgKyAoc2V0dGluZ3MuYmFzZU1pbnVzVE1pbiArIDEpICogZGVsdGEgLyAoZGVsdGEgKyBzZXR0aW5ncy5za2V3KSk7XG4gICAgfVxuICAgIC8qKlxuKiBDcmVhdGVzIGFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIG51bWVyaWMgY29kZSBwb2ludHMgb2YgZWFjaCBVbmljb2RlXG4qIGNoYXJhY3RlciBpbiB0aGUgc3RyaW5nLiBXaGlsZSBKYXZhU2NyaXB0IHVzZXMgVUNTLTIgaW50ZXJuYWxseSxcbiogdGhpcyBmdW5jdGlvbiB3aWxsIGNvbnZlcnQgYSBwYWlyIG9mIHN1cnJvZ2F0ZSBoYWx2ZXMgKGVhY2ggb2Ygd2hpY2hcbiogVUNTLTIgZXhwb3NlcyBhcyBzZXBhcmF0ZSBjaGFyYWN0ZXJzKSBpbnRvIGEgc2luZ2xlIGNvZGUgcG9pbnQsXG4qIG1hdGNoaW5nIFVURi0xNi5cbiogQHNlZSBgcHVueWNvZGUudWNzMi5lbmNvZGVgXG4qIEBzZWUgPGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nPlxuKiBAbWVtYmVyT2YgcHVueWNvZGUudWNzMlxuKiBAbmFtZSBkZWNvZGVcbiogQHBhcmFtIHtTdHJpbmd9IHN0cmluZyBUaGUgVW5pY29kZSBpbnB1dCBzdHJpbmcgKFVDUy0yKS5cbiogQHJldHVybnMge0FycmF5fSBUaGUgbmV3IGFycmF5IG9mIGNvZGUgcG9pbnRzLlxuKi9cbiAgICBzdGF0aWMgdWNzMmRlY29kZShzdHJpbmcpIHtcbiAgICAgICAgdmFyIG91dHB1dCA9IFtdLCBjb3VudGVyID0gMCwgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aCwgdmFsdWUsIGV4dHJhO1xuICAgICAgICB3aGlsZSAoY291bnRlciA8IGxlbmd0aCkge1xuICAgICAgICAgICAgdmFsdWUgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuICAgICAgICAgICAgaWYgKHZhbHVlID49IDB4RDgwMCAmJiB2YWx1ZSA8PSAweERCRkYgJiYgY291bnRlciA8IGxlbmd0aCkge1xuICAgICAgICAgICAgICAgIC8vIGhpZ2ggc3Vycm9nYXRlLCBhbmQgdGhlcmUgaXMgYSBuZXh0IGNoYXJhY3RlclxuICAgICAgICAgICAgICAgIGV4dHJhID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcbiAgICAgICAgICAgICAgICBpZiAoKGV4dHJhICYgMHhGQzAwKSA9PSAweERDMDApIHsgLy8gbG93IHN1cnJvZ2F0ZVxuICAgICAgICAgICAgICAgICAgICBvdXRwdXQucHVzaCgoKHZhbHVlICYgMHgzRkYpIDw8IDEwKSArIChleHRyYSAmIDB4M0ZGKSArIDB4MTAwMDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdW5tYXRjaGVkIHN1cnJvZ2F0ZTsgb25seSBhcHBlbmQgdGhpcyBjb2RlIHVuaXQsIGluIGNhc2UgdGhlIG5leHRcbiAgICAgICAgICAgICAgICAgICAgLy8gY29kZSB1bml0IGlzIHRoZSBoaWdoIHN1cnJvZ2F0ZSBvZiBhIHN1cnJvZ2F0ZSBwYWlyXG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgY291bnRlci0tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH1cbiAgICAvKipcbiAqIFR5cGVkZWYgZm9yIGRlY29tcG9zZURhdGFVcmkgcmV0dXJuIG9iamVjdC5cbiAqXG4gKiBAbWVtYmVyb2YgUElYSS51dGlsc1xuICogQHR5cGVkZWYge29iamVjdH0gRGVjb21wb3NlZERhdGFVcmlcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBtZWRpYVR5cGUgTWVkaWEgdHlwZSwgZWcuIGBpbWFnZWBcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzdWJUeXBlIFN1YiB0eXBlLCBlZy4gYHBuZ2BcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBlbmNvZGluZyBEYXRhIGVuY29kaW5nLCBlZy4gYGJhc2U2NGBcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBkYXRhIFRoZSBhY3R1YWwgZGF0YVxuICovXG4gICAgLyoqXG4gICAgICogU3BsaXQgYSBkYXRhIFVSSSBpbnRvIGNvbXBvbmVudHMuIFJldHVybnMgdW5kZWZpbmVkIGlmXG4gICAgICogcGFyYW1ldGVyIGBkYXRhVXJpYCBpcyBub3QgYSB2YWxpZCBkYXRhIFVSSS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBQSVhJLnV0aWxzXG4gICAgICogQGZ1bmN0aW9uIGRlY29tcG9zZURhdGFVcmlcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZGF0YVVyaSAtIHRoZSBkYXRhIFVSSSB0byBjaGVja1xuICAgICAqIEByZXR1cm4ge1BJWEkudXRpbHMuRGVjb21wb3NlZERhdGFVcml8dW5kZWZpbmVkfSBUaGUgZGVjb21wb3NlZCBkYXRhIHVyaSBvciB1bmRlZmluZWRcbiAgICAgKi9cbiAgICBzdGF0aWMgZGVjb21wb3NlRGF0YVVyaShkYXRhVXJpKSB7XG4gICAgICAgIHZhciBkYXRhVXJpTWF0Y2ggPSBzZXR0aW5ncy5EQVRBX1VSSS5leGVjKGRhdGFVcmkpO1xuICAgICAgICBpZiAoZGF0YVVyaU1hdGNoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG1lZGlhVHlwZTogZGF0YVVyaU1hdGNoWzFdID8gZGF0YVVyaU1hdGNoWzFdLnRvTG93ZXJDYXNlKCkgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgc3ViVHlwZTogZGF0YVVyaU1hdGNoWzJdID8gZGF0YVVyaU1hdGNoWzJdLnRvTG93ZXJDYXNlKCkgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgY2hhcnNldDogZGF0YVVyaU1hdGNoWzNdID8gZGF0YVVyaU1hdGNoWzNdLnRvTG93ZXJDYXNlKCkgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgZW5jb2Rpbmc6IGRhdGFVcmlNYXRjaFs0XSA/IGRhdGFVcmlNYXRjaFs0XS50b0xvd2VyQ2FzZSgpIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIGRhdGE6IGRhdGFVcmlNYXRjaFs1XSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG59XG4vKipcbiAqIFRhcmdldCBmcmFtZXMgcGVyIG1pbGxpc2Vjb25kLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBuYW1lIFRBUkdFVF9GUE1TXG4gKiBAbWVtYmVyb2YgUElYSS5zZXR0aW5nc1xuICogQHR5cGUge251bWJlcn1cbiAqIEBkZWZhdWx0IDAuMDZcbiAqL1xuc2V0dGluZ3MuVEFSR0VUX0ZQTVMgPSAwLjA2O1xuLyoqXG4gKiBEZWZhdWx0IGZpbHRlciByZXNvbHV0aW9uLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBuYW1lIEZJTFRFUl9SRVNPTFVUSU9OXG4gKiBAbWVtYmVyb2YgUElYSS5zZXR0aW5nc1xuICogQHR5cGUge251bWJlcn1cbiAqIEBkZWZhdWx0IDFcbiAqL1xuc2V0dGluZ3MuRklMVEVSX1JFU09MVVRJT04gPSAxO1xuLy8gVE9ETzogbWF5YmUgY2hhbmdlIHRvIFNQUklURS5CQVRDSF9TSVpFOiAyMDAwXG4vLyBUT0RPOiBtYXliZSBhZGQgUEFSVElDTEUuQkFUQ0hfU0laRTogMTUwMDBcbi8qKlxuICogVGhlIGRlZmF1bHQgc3ByaXRlIGJhdGNoIHNpemUuXG4gKlxuICogVGhlIGRlZmF1bHQgYWltcyB0byBiYWxhbmNlIGRlc2t0b3AgYW5kIG1vYmlsZSBkZXZpY2VzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBuYW1lIFNQUklURV9CQVRDSF9TSVpFXG4gKiBAbWVtYmVyb2YgUElYSS5zZXR0aW5nc1xuICogQHR5cGUge251bWJlcn1cbiAqIEBkZWZhdWx0IDQwOTZcbiAqL1xuc2V0dGluZ3MuU1BSSVRFX0JBVENIX1NJWkUgPSA0MDk2O1xuLyoqXG4gKiBEZWZhdWx0IEdhcmJhZ2UgQ29sbGVjdGlvbiBtb2RlLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBuYW1lIEdDX01PREVcbiAqIEBtZW1iZXJvZiBQSVhJLnNldHRpbmdzXG4gKiBAdHlwZSB7UElYSS5HQ19NT0RFU31cbiAqIEBkZWZhdWx0IFBJWEkuR0NfTU9ERVMuQVVUT1xuICovXG5zZXR0aW5ncy5HQ19NT0RFID0gMDtcbi8qKlxuICogRGVmYXVsdCBHYXJiYWdlIENvbGxlY3Rpb24gbWF4IGlkbGUuXG4gKlxuICogQHN0YXRpY1xuICogQG5hbWUgR0NfTUFYX0lETEVcbiAqIEBtZW1iZXJvZiBQSVhJLnNldHRpbmdzXG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQGRlZmF1bHQgMzYwMFxuICovXG5zZXR0aW5ncy5HQ19NQVhfSURMRSA9IDYwICogNjA7XG4vKipcbiAqIERlZmF1bHQgR2FyYmFnZSBDb2xsZWN0aW9uIG1heGltdW0gY2hlY2sgY291bnQuXG4gKlxuICogQHN0YXRpY1xuICogQG5hbWUgR0NfTUFYX0NIRUNLX0NPVU5UXG4gKiBAbWVtYmVyb2YgUElYSS5zZXR0aW5nc1xuICogQHR5cGUge251bWJlcn1cbiAqIEBkZWZhdWx0IDYwMFxuICovXG5zZXR0aW5ncy5HQ19NQVhfQ0hFQ0tfQ09VTlQgPSA2MCAqIDEwO1xuLyoqXG4qIFRoZSBnYyBtb2RlcyB0aGF0IGFyZSBzdXBwb3J0ZWQgYnkgcGl4aS5cbipcbiogVGhlIHtAbGluayBQSVhJLnNldHRpbmdzLkdDX01PREV9IEdhcmJhZ2UgQ29sbGVjdGlvbiBtb2RlIGZvciBQaXhpSlMgdGV4dHVyZXMgaXMgQVVUT1xuKiBJZiBzZXQgdG8gR0NfTU9ERSwgdGhlIHJlbmRlcmVyIHdpbGwgb2NjYXNpb25hbGx5IGNoZWNrIHRleHR1cmVzIHVzYWdlLiBJZiB0aGV5IGFyZSBub3RcbiogdXNlZCBmb3IgYSBzcGVjaWZpZWQgcGVyaW9kIG9mIHRpbWUgdGhleSB3aWxsIGJlIHJlbW92ZWQgZnJvbSB0aGUgR1BVLiBUaGV5IHdpbGwgb2YgY291cnNlXG4qIGJlIHVwbG9hZGVkIGFnYWluIHdoZW4gdGhleSBhcmUgcmVxdWlyZWQuIFRoaXMgaXMgYSBzaWxlbnQgYmVoaW5kIHRoZSBzY2VuZXMgcHJvY2VzcyB0aGF0XG4qIHNob3VsZCBlbnN1cmUgdGhhdCB0aGUgR1BVIGRvZXMgbm90ICBnZXQgZmlsbGVkIHVwLlxuKlxuKiBIYW5keSBmb3IgbW9iaWxlIGRldmljZXMhXG4qIFRoaXMgcHJvcGVydHkgb25seSBhZmZlY3RzIFdlYkdMLlxuKlxuKiBAbmFtZSBHQ19NT0RFU1xuKiBAZW51bSB7bnVtYmVyfVxuKiBAc3RhdGljXG4qIEBtZW1iZXJvZiBQSVhJXG4qIEBwcm9wZXJ0eSB7bnVtYmVyfSBBVVRPIC0gR2FyYmFnZSBjb2xsZWN0aW9uIHdpbGwgaGFwcGVuIHBlcmlvZGljYWxseSBhdXRvbWF0aWNhbGx5XG4qIEBwcm9wZXJ0eSB7bnVtYmVyfSBNQU5VQUwgLSBHYXJiYWdlIGNvbGxlY3Rpb24gd2lsbCBuZWVkIHRvIGJlIGNhbGxlZCBtYW51YWxseVxuKi9cbnNldHRpbmdzLkdDX01PREVTID0ge1xuICAgIEFVVE86IDAsXG4gICAgTUFOVUFMOiAxLFxufTtcbi8qKlxuICogQ29uc3RhbnRzIHRoYXQgc3BlY2lmeSBmbG9hdCBwcmVjaXNpb24gaW4gc2hhZGVycy5cbiAqXG4gKiBAbmFtZSBQUkVDSVNJT05cbiAqIEBtZW1iZXJvZiBQSVhJXG4gKiBAc3RhdGljXG4gKiBAZW51bSB7c3RyaW5nfVxuICogQGNvbnN0YW50XG4gKiBAcHJvcGVydHkge3N0cmluZ30gTE9XPSdsb3dwJ1xuICogQHByb3BlcnR5IHtzdHJpbmd9IE1FRElVTT0nbWVkaXVtcCdcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBISUdIPSdoaWdocCdcbiAqL1xuc2V0dGluZ3MuUFJFQ0lTSU9OID0ge1xuICAgIExPVzogJ2xvd3AnLFxuICAgIE1FRElVTTogJ21lZGl1bXAnLFxuICAgIEhJR0g6ICdoaWdocCcsXG59O1xuLyoqXG4qIEdyYXBoaWNzIGN1cnZlcyByZXNvbHV0aW9uIHNldHRpbmdzLiBJZiBgYWRhcHRpdmVgIGZsYWcgaXMgc2V0IHRvIGB0cnVlYCxcbiogdGhlIHJlc29sdXRpb24gaXMgY2FsY3VsYXRlZCBiYXNlZCBvbiB0aGUgY3VydmUncyBsZW5ndGggdG8gZW5zdXJlIGJldHRlciB2aXN1YWwgcXVhbGl0eS5cbiogQWRhcHRpdmUgZHJhdyB3b3JrcyB3aXRoIGBiZXppZXJDdXJ2ZVRvYCBhbmQgYHF1YWRyYXRpY0N1cnZlVG9gLlxuKlxuKiBAc3RhdGljXG4qIEBjb25zdGFudFxuKiBAbWVtYmVyb2YgUElYSVxuKiBAbmFtZSBHUkFQSElDU19DVVJWRVNcbiogQHR5cGUge29iamVjdH1cbiogQHByb3BlcnR5IHtib29sZWFufSBhZGFwdGl2ZT1mYWxzZSAtIGZsYWcgaW5kaWNhdGluZyBpZiB0aGUgcmVzb2x1dGlvbiBzaG91bGQgYmUgYWRhcHRpdmVcbiogQHByb3BlcnR5IHtudW1iZXJ9IG1heExlbmd0aD0xMCAtIG1heGltYWwgbGVuZ3RoIG9mIGEgc2luZ2xlIHNlZ21lbnQgb2YgdGhlIGN1cnZlIChpZiBhZGFwdGl2ZSA9IGZhbHNlLCBpZ25vcmVkKVxuKiBAcHJvcGVydHkge251bWJlcn0gbWluU2VnbWVudHM9OCAtIG1pbmltYWwgbnVtYmVyIG9mIHNlZ21lbnRzIGluIHRoZSBjdXJ2ZSAoaWYgYWRhcHRpdmUgPSBmYWxzZSwgaWdub3JlZClcbiogQHByb3BlcnR5IHtudW1iZXJ9IG1heFNlZ21lbnRzPTIwNDggLSBtYXhpbWFsIG51bWJlciBvZiBzZWdtZW50cyBpbiB0aGUgY3VydmUgKGlmIGFkYXB0aXZlID0gZmFsc2UsIGlnbm9yZWQpXG4qL1xuc2V0dGluZ3MuR1JBUEhJQ1NfQ1VSVkVTID0ge1xuICAgIGFkYXB0aXZlOiB0cnVlLFxuICAgIG1heExlbmd0aDogMTAsXG4gICAgbWluU2VnbWVudHM6IDgsXG4gICAgbWF4U2VnbWVudHM6IDIwNDgsXG4gICAgX3NlZ21lbnRzQ291bnQ6IGZ1bmN0aW9uIF9zZWdtZW50c0NvdW50KGxlbmd0aCwgZGVmYXVsdFNlZ21lbnRzID0gbnVsbCkge1xuICAgICAgICBpZiAoZGVmYXVsdFNlZ21lbnRzID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIGRlZmF1bHRTZWdtZW50cyA9IDIwO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5hZGFwdGl2ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRTZWdtZW50cztcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzdWx0ID0gTWF0aC5jZWlsKGxlbmd0aCAvIHRoaXMubWF4TGVuZ3RoKTtcbiAgICAgICAgaWYgKHJlc3VsdCA8IHRoaXMubWluU2VnbWVudHMpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMubWluU2VnbWVudHM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocmVzdWx0ID4gdGhpcy5tYXhTZWdtZW50cykge1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5tYXhTZWdtZW50cztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG59O1xuc2V0dGluZ3MuaW5pdGlhbE4gPSAxMjg7XG5zZXR0aW5ncy5pbml0aWFsQmlhcyA9IDcyO1xuc2V0dGluZ3Muc3RyaW5nRnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZTtcbnNldHRpbmdzLmRlbGltaXRlciA9ICctJztcbnNldHRpbmdzLm1heEludCA9IDIxNDc0ODM2NDc7XG5zZXR0aW5ncy5mbG9vciA9IE1hdGguZmxvb3I7XG5zZXR0aW5ncy5iYXNlID0gMzY7XG5zZXR0aW5ncy50TWluID0gMTtcbnNldHRpbmdzLnRNYXggPSAyNjtcbi8qKiBFcnJvciBtZXNzYWdlcyAqL1xuc2V0dGluZ3MuZXJyb3JzID0ge1xuICAgICdvdmVyZmxvdyc6ICdPdmVyZmxvdzogaW5wdXQgbmVlZHMgd2lkZXIgaW50ZWdlcnMgdG8gcHJvY2VzcycsXG4gICAgJ25vdC1iYXNpYyc6ICdJbGxlZ2FsIGlucHV0ID49IDB4ODAgKG5vdCBhIGJhc2ljIGNvZGUgcG9pbnQpJyxcbiAgICAnaW52YWxpZC1pbnB1dCc6ICdJbnZhbGlkIGlucHV0J1xufTtcbnNldHRpbmdzLmRhbXAgPSA3MDA7XG5zZXR0aW5ncy5iYXNlTWludXNUTWluID0gc2V0dGluZ3MuYmFzZSAtIHNldHRpbmdzLnRNaW47XG5zZXR0aW5ncy5za2V3ID0gMzg7XG4vKipcbiogUmVnZXhwIGZvciBkYXRhIFVSSS5cbiogQmFzZWQgb246IHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vcmFnaW5nd2luZC9kYXRhLXVyaS1yZWdleH1cbipcbiogQHN0YXRpY1xuKiBAY29uc3RhbnQge1JlZ0V4cHxzdHJpbmd9IERBVEFfVVJJXG4qIEBtZW1iZXJvZiBQSVhJXG4qIEBleGFtcGxlIGRhdGE6aW1hZ2UvcG5nO2Jhc2U2NFxuKi9cbnNldHRpbmdzLkRBVEFfVVJJID0gL15cXHMqZGF0YTooPzooW1xcdy1dKylcXC8oW1xcdysuLV0rKSk/KD86O2NoYXJzZXQ9KFtcXHctXSspKT8oPzo7KGJhc2U2NCkpPywoLiopL2k7XG4vLyBUYWtlbiBmcm9tIHRoZSBiaXQtdHdpZGRsZSBwYWNrYWdlXG5zZXR0aW5ncy5kZWZhdWx0VmVydGV4ID0gXCJhdHRyaWJ1dGUgdmVjMiBhVmVydGV4UG9zaXRpb247XFxyXFxuYXR0cmlidXRlIHZlYzIgYVRleHR1cmVDb29yZDtcXHJcXG5cXHJcXG51bmlmb3JtIG1hdDMgcHJvamVjdGlvbk1hdHJpeDtcXHJcXG5cXHJcXG52YXJ5aW5nIHZlYzIgdlRleHR1cmVDb29yZDtcXHJcXG5cXHJcXG52b2lkIG1haW4odm9pZClcXHJcXG57XFxyXFxuICAgIGdsX1Bvc2l0aW9uID0gdmVjNCgocHJvamVjdGlvbk1hdHJpeCAqIHZlYzMoYVZlcnRleFBvc2l0aW9uLCAxLjApKS54eSwgMC4wLCAxLjApO1xcclxcbiAgICB2VGV4dHVyZUNvb3JkID0gYVRleHR1cmVDb29yZDtcXHJcXG59XCI7XG5zZXR0aW5ncy5kZWZhdWx0RmlsdGVyVmVydGV4ID0gXCJhdHRyaWJ1dGUgdmVjMiBhVmVydGV4UG9zaXRpb247XFxyXFxuXFxyXFxudW5pZm9ybSBtYXQzIHByb2plY3Rpb25NYXRyaXg7XFxyXFxuXFxyXFxudmFyeWluZyB2ZWMyIHZUZXh0dXJlQ29vcmQ7XFxyXFxuXFxyXFxudW5pZm9ybSB2ZWM0IGlucHV0U2l6ZTtcXHJcXG51bmlmb3JtIHZlYzQgb3V0cHV0RnJhbWU7XFxyXFxuXFxyXFxudmVjNCBmaWx0ZXJWZXJ0ZXhQb3NpdGlvbiggdm9pZCApXFxyXFxue1xcclxcbiAgICB2ZWMyIHBvc2l0aW9uID0gYVZlcnRleFBvc2l0aW9uICogbWF4KG91dHB1dEZyYW1lLnp3LCB2ZWMyKDAuKSkgKyBvdXRwdXRGcmFtZS54eTtcXHJcXG5cXHJcXG4gICAgcmV0dXJuIHZlYzQoKHByb2plY3Rpb25NYXRyaXggKiB2ZWMzKHBvc2l0aW9uLCAxLjApKS54eSwgMC4wLCAxLjApO1xcclxcbn1cXHJcXG5cXHJcXG52ZWMyIGZpbHRlclRleHR1cmVDb29yZCggdm9pZCApXFxyXFxue1xcclxcbiAgICByZXR1cm4gYVZlcnRleFBvc2l0aW9uICogKG91dHB1dEZyYW1lLnp3ICogaW5wdXRTaXplLnp3KTtcXHJcXG59XFxyXFxuXFxyXFxudm9pZCBtYWluKHZvaWQpXFxyXFxue1xcclxcbiAgICBnbF9Qb3NpdGlvbiA9IGZpbHRlclZlcnRleFBvc2l0aW9uKCk7XFxyXFxuICAgIHZUZXh0dXJlQ29vcmQgPSBmaWx0ZXJUZXh0dXJlQ29vcmQoKTtcXHJcXG59XFxyXFxuXCI7XG5leHBvcnRzLnNldHRpbmdzID0gc2V0dGluZ3M7XG4iXSwic291cmNlUm9vdCI6IiJ9